00:00:06 <jfischoff> one
00:00:13 <MaskRay> Which library to use for aggregating file handles?
00:00:47 <burbul> jfischoff: go on...
00:01:39 <jfischoff> List is not built in
00:02:12 <jfischoff> I don't know about lambdabot, on the command line with djinn you define datatypes and classes
00:02:27 <burbul> Hmmm... docs have
00:02:28 <burbul> @djinn a -> [a] -> [a]
00:02:28 <lambdabot> Error: Undefined type []
00:02:49 <burbul> http://lambda-the-ultimate.org/node/1178
00:02:55 <burbul> oh well, doesn't matter.
00:03:23 <jfischoff> the standalone djinn has more options
00:04:13 <burbul> I'm just surprised as the docs suggest the last thing I typed could be put straight into #haskell
00:06:21 <mbuf> for the expression In (Cons 1 (In (Cons 2 (In (Cons 3 (In Nil)))))), which module provides "In"?
00:09:53 <mysticc> @hoogle In
00:09:54 <lambdabot> Prelude init :: [a] -> [a]
00:09:54 <lambdabot> Data.List init :: [a] -> [a]
00:09:54 <lambdabot> Prelude data Int :: *
00:12:03 <hpaste_> mbuf pasted “Graph representation” at http://hpaste.org/67581
00:12:35 <mbuf> how does the graph representation actually look like for [(1,Cons 1 2),(2,Cons 2 3),(3,Cons 3 4),(4,Nil)]
00:13:44 <mbuf> Is it like Cons is the node, and there is 1 as its left child and another Cons as the right child (which in turn has 2 as its left child and another Cons as its right child)?
00:17:16 <adimit> @pl \x -> f x || g x
00:17:16 <lambdabot> liftM2 (||) f g
00:22:44 <burbul> what monad is that liftM2 in?
00:22:54 <adimit> burbul: (->)
00:23:09 <adimit> where it's sufficient for it to be a functor.
00:23:26 <fmap> actually ((->) a)
00:23:31 <burbul> is liftM2 defined on functors?
00:23:33 <adimit> yeah, silly me.
00:23:39 <burbul> @hoogle liftM2
00:23:39 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:23:56 <burbul> @hoogle (->)
00:23:57 <lambdabot> keyword ->
00:23:57 <lambdabot> Test.QuickCheck.Function data (:->) a c
00:24:06 <jfischoff> lifts are like fmaps
00:24:21 <burbul> That bit I understand
00:24:21 <adimit> except that there's no fmap2 I know of.
00:24:39 <shachaf> No, you need Applicative for liftMn for n /= 1
00:24:42 <mm_freak> shachaf: ok, i'm convinced now that de bruijn indices are better =)
00:24:43 <shachaf> (Including n = 0)
00:24:44 <burbul> But as far as the compiler is concerned, it looks as if it can only be applied to monads
00:24:45 <jfischoff> yeah I guess you use applicative
00:24:54 <shachaf> mm_freak: Success!
00:24:56 <burbul> So I'm wondering where the monad instance declaration for ((->) a) is
00:25:06 <shachaf> mm_freak: De Bruijn sequences have nothing to do with this, but they're also pretty neat.
00:25:15 <jfischoff> shachaf: go o
00:25:17 <jfischoff> n
00:25:29 <mm_freak> shachaf: are they related to what i'm doing right now?
00:25:35 <shachaf> mm_frea: Nope.
00:25:40 <shachaf> (Well, not that I know of.)
00:25:55 <shachaf> jfischoff: I once went to a talk about card magic done with De Bruijn indices.
00:26:02 <mm_freak> ok, then i'll proceed without building a time-wasty wikipedia browse tree =P
00:26:20 <shachaf> mm_freak: Pft. Have you learned nothing from IRC?
00:26:31 <jfischoff> I'm embraced to say I'm intrigued
00:26:42 <mm_freak> ok ok
00:26:46 * shachaf embraces jfischoff.
00:26:58 <jfischoff> how do you make those dots?
00:27:16 <mm_freak> ok, combinatorics…  i'll postpone reading that, because i really want to get this language implemented
00:27:36 <shachaf> Which dots?
00:28:42 <jfischoff> colloquy formats the inner monologue remarks with some character.
00:28:51 <jfischoff> I'm not sure how to do it
00:28:53 <lukexi> anyone have any idea exactly what the workarounds are in this ghc ticket? i can't compile anything on OS X 10.8 :o http://hackage.haskell.org/trac/ghc/ticket/5899
00:29:13 * lukexi explains you can use /me to invoke the third person
00:29:24 <shachaf> Oh, that.
00:29:31 * jfischoff I hope this works
00:29:35 * shachaf suggests that you follow lukexi's lead.
00:29:39 <jfischoff> nice
00:29:51 <mm_freak> Typ :-> (Var 0 :-> Typ) :-> (Var 1 :-> Var 1 :$ Var 0) :-> Var 2 :-> Var 1 :$ Var 0
00:29:59 <jfischoff> \me fells very accomplished
00:30:01 <mm_freak> that looks nice, but is unintelligible
00:30:07 <adimit> jfischoff: it's not really dots — it's actually a control character that clients are free to render any way they wish (or not at all.) In my client, it's '*', not dots.
00:30:13 <jfischoff> haha
00:30:14 <mm_freak> but i've written a Show instance that introduces variable names, which is much better =)
00:30:40 <shachaf> That belongs in a pretty-print function, not a Show instance. :-(
00:31:26 <mm_freak> the Show instance is a pretty straightforward translation, only introducing variables…  the pretty printer will do what its name suggests, and it will use Text and Builder instead of String
00:31:36 <mm_freak> i'd like to be able to understand my debugging output =)
00:36:24 <shachaf> No reason for your debugging output to use Show.
00:36:42 <adimit> I usually use Text.Groom for my debugging output…
00:36:46 <shachaf> I guess at least you maintain read . show === id (assuming you have Read), so it's not too bad.
00:36:51 <mm_freak> shachaf: i understand Show as a sole debugging tool
00:36:59 <mm_freak> i don't have Read
00:37:15 <mm_freak> i won't have a parser at all, as this language is supposed to be a core language
00:55:04 * hackagebot yesod 1.0.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.3 (MichaelSnoyman)
00:55:06 * hackagebot yesod-test 0.2.0.3 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.3 (MichaelSnoyman)
01:01:39 <fragamus> takeWhile fst [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:02:05 <fragamus> I want to invert the boolean extracted by fst
01:02:21 <fragamus> but I have type coercion problems
01:02:40 <womb> > 7*7
01:02:41 <lambdabot>   49
01:03:12 <womb> what coercion problems ?
01:03:20 <fragamus> > takeWhile fst [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:03:21 <lambdabot>   []
01:03:53 <womb> take while takes a foo that says until he has to take stuff
01:04:14 <womb> @hoogle takeWhile
01:04:14 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
01:04:14 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
01:04:14 <lambdabot> Data.ByteString.Char8 takeWhile :: (Char -> Bool) -> ByteString -> ByteString
01:04:33 <womb> so this foo cant be fst, it has to be a -> Bool
01:04:41 <womb> if it will be false he will stop taking from list
01:04:44 <womb> and return
01:04:52 <womb> so majbe you need something like map ?
01:05:00 <womb> map fst [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:05:14 <womb> this will make list of fst value for each tuple in list
01:05:30 <womb> > map fst [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:05:31 <lambdabot>   [False,False,True]
01:05:36 <womb> like this :)
01:05:46 <danr> fragamus: do you want to do takeWhile (fst . not) ?
01:05:50 <mm_freak> % ./test3
01:05:51 <mm_freak> (a : Set) -> (b : a -> Set) -> (c : (d : a) -> b d) -> (d : a) -> c d
01:06:02 <danr> > takeWhile (fst . not) [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:06:02 <lambdabot>   Couldn't match expected type `(GHC.Bool.Bool, b)'
01:06:03 <lambdabot>         against inferred ...
01:06:05 <mm_freak> shachaf: that Show instance is much nicer than a direct translation of de bruijn indices =)
01:06:10 <danr> uh not . fst I mean
01:06:10 <fragamus> > takeWhile (fst. . not)      [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:06:11 <lambdabot>   <no location info>: parse error on input `.'
01:06:35 <mm_freak> ok, now comes the type checker…  i think it will be extraordinarily simple
01:06:37 <womb> :t (not . fst)
01:06:37 <lambdabot> forall b. (Bool, b) -> Bool
01:06:40 <fragamus> > takeWhile (not . fst)      [(False,[1,2,3]),(False,[4,5,6]),(True,[7,8,9])]
01:06:42 <lambdabot>   [(False,[1,2,3]),(False,[4,5,6])]
01:06:46 <fragamus> yaaay
01:06:53 <fragamus> i feel so dense
01:06:55 <danr> yay :)
01:07:05 <womb> damn
01:07:08 <womb> i wanted to help
01:07:12 <womb> and danr did it ;/
01:07:20 <womb> you ruined my life
01:07:21 <womb> D:
01:07:33 <danr> > 7 * 8
01:07:34 <lambdabot>   56
01:07:39 <womb> > 7*7
01:07:40 <lambdabot>   49
01:07:55 <hpaste_> “Vagif Verdi” pasted “bulls and cows” at http://hpaste.org/67582
01:08:04 <mysticc> @quote
01:08:05 <lambdabot> DCliche says: @remember elliott @remember @remember @remember
01:08:09 <mysticc> @quote
01:08:09 <lambdabot> ozataman says: I've tried killing many times
01:08:18 <mysticc> @quote
01:08:18 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
01:08:22 <mysticc> @quote
01:08:23 <lambdabot> RaymondChen says: The problem with being dead right is you're dead.
01:08:43 <womb> @quote
01:08:44 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
01:19:41 <mysticc> @quote womb
01:19:41 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
01:19:49 <mysticc> @quote mm_freak
01:19:49 <lambdabot> mm_freak says: using combinators instead of explicit recursion can be justified with about the same reasoning as using 'while' instead of explicit 'goto' in imperative programming
01:20:12 <ment> @quote hitler
01:20:12 <lambdabot> gwern says: [I have] heard hitler, stalin, and mao all used windows or macs
01:20:37 <mysticc> @quote ment
01:20:37 <lambdabot> nand` says: Programming in front of the compiler is like physics; you observe a system, make deductions, use these to build models then find methodology to arrive at your solution. Programming (with)
01:20:37 <lambdabot>  the compiler is like mathematics; your thoughts, your system, your rules, your experiments
01:20:50 <womb> o shit i use mac
01:20:59 <mysticc> @slap womb
01:20:59 <lambdabot> I don't perform such side effects on command!
01:21:14 <mysticc> @slap womb
01:21:15 * lambdabot will count to five...
01:21:15 <womb> now i feel sad and lonely
01:21:17 <ment> well, i'm quite sure hitler used plan 9
01:21:32 <womb> what is "plan 9" ? :D
01:21:43 <mysticc> @slap womb
01:21:43 * lambdabot decomposes womb into several parts using the Banach-Tarski theorem and reassembles them to get two copies of womb!
01:21:50 <ment> here's the proof: http://hitlerpictures.net/Hitler-bunny.jpg
01:23:36 <womb> ultimate hipster
01:23:50 <Elemir> Heil Milner. Static type nazi! \o
01:24:56 <womb> \o
01:25:08 <mysticc> @slap lambdabot
01:25:08 * lambdabot decomposes lambdabot into several parts using the Banach-Tarski theorem and reassembles them to get two copies of lambdabot!
01:25:16 <mysticc> @slap lambdabot
01:25:16 * lambdabot submits lambdabot's email address to a dozen spam lists
01:27:34 <womb> @slap mysticc
01:27:35 * lambdabot will count to five...
01:27:41 <womb> @slap mysticc
01:27:41 * lambdabot slaps mysticc with a slab of concrete
01:28:02 <womb> \m/....O_O....\m/
01:29:06 <womb> i did not even know haskell people can joke
01:29:15 <womb> i thought jokes are not staticly typed
01:30:06 <koala_man> it's just puns that don't work, due to typing errors
01:31:37 <sw1sh> how to use NoImplicitPrelude in GHCi ? "ghci -XNoImplicitPrelude" and ":m -Prelude" don't work.
01:33:42 <danr> sw1sh: import Prelude() seems to work
01:33:59 <danr> but I do not know why the NoImplicitPrelude switch and :m - does not work
01:35:16 <sw1sh> import Prelude() doesn't work too
01:41:51 <JaffaCake1> sw1sh: is this in ghci?  I think the NoImplicitPrelude flag does not currently affect ghci (it should, that's a bug).  But 'import Prelude()' does work.
01:44:03 <sw1sh> disabling Prelude in file works fine, but not inside interpreter thats the problem
01:44:53 <JaffaCake> sw1sh: what GHC version?
01:45:13 <sw1sh> 7.4.1
01:45:41 <JaffaCake> import Prelude()
01:45:58 <JaffaCake> that works - it will still show Prelude in the prompt, but nothing is imported
01:49:30 <shachaf> In GHC 7.0 you could :m - Prelude and it woudl disappear from the prompt.
01:49:33 <shachaf> I guess that's gone?
01:49:51 <JaffaCake> yes, the behaviour changed a little in this area
01:50:00 <JaffaCake> in 7.0 it wasn't possible to say import Prelude ()
01:50:06 <sw1sh> JaffaCake: yes it really works, Prelude> just didnt dissapear
01:50:31 <mm_freak> does somebody have GHC 7.0 around?  i think i have found a bug, but i'd like to test against older versions before i submit a report
01:50:49 <shachaf> Several people, probably. You should say what it is. :-)
01:53:31 <hpaste_> “Ertugrul Söylemez” pasted “This code causes weird behavior” at http://hpaste.org/67584
01:53:50 <mm_freak> could somebody try to run this code?
01:54:10 <mm_freak> with GHC 7.0 that is
01:54:21 <mm_freak> it should print three lines (which may not make much sense to you)
01:54:44 <mm_freak> with GHC 7.4.1 it aborts after the first line with "Not in scope: 0"
01:58:17 <gdeest> mm_freak: same thing, here
01:58:39 <gdeest> Left "Expected *** Exception: Not in scope: 0
01:58:40 <shachaf> Prints "Not in scope: 0" in GHC 7.0.4.
01:59:03 <gdeest> GHC 7.0.4 too
01:59:17 <Phlogistique> mm_freak: doesn't compile with 6.12
01:59:21 <mm_freak> hmm, ok, thanks
01:59:27 <mm_freak> Phlogistique: doesn't compile?
01:59:51 <Phlogistique> mm_freak:  http://sprunge.us/KeCW
02:00:20 <mm_freak> ah, you need to import Control.Monad.Instances
02:00:55 <mm_freak> oh, i think i found the cause
02:01:40 <mm_freak> yeah i found it
02:01:43 <mm_freak> thanks guys
02:01:52 <mm_freak> wasn't a GHC bug =)
02:01:59 <Phlogistique> 10:59:59 < mm_freak> ah, you need to import Control.Monad.Instances <- doesn't work either
02:02:05 <Phlogistique> same error
02:03:16 <mm_freak> the old base didn't include a Monad instance for Either?
02:03:31 <merijn> I don't suppose haskell syntax allows for blank lines in do blocks?
02:03:41 <mm_freak> merijn: of course it does
02:03:56 <merijn> mm_freak: Oh, neat. I never thought to try :)
02:04:09 <mm_freak> merijn: blank lines are entirely ignored
02:04:41 <merijn> Man, now I really only need mixfix to be well and truly happy... :p
02:04:47 <mm_freak> exception: quasiquotes
02:05:06 * hackagebot yesod-test 0.2.0.4 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.4 (MichaelSnoyman)
02:05:49 <merijn> Are there theoretical reasons for not having mixfix or is mostly no one wants to implement it or maintain the resulting complicated code?
02:06:16 <quicksilver> no theoretical reasons
02:06:35 <quicksilver> mostly, no one has done it.
02:06:49 <quicksilver> there are practical tradeoffs, but agda is exploring the space
02:07:19 <merijn> Yeah, I know. Parsing must be a bitch
02:07:58 <quicksilver> that's not the practical tradeoff I'm talking about
02:08:00 <merijn> OTOH, as I pointed out yesterday it would turn haskell into the EDSL master race, crushing the smug LISP weenies under our type theory powered death machine :p
02:08:04 <quicksilver> parsing is just a SMOP.
02:08:14 <quicksilver> any fule can write a parser.
02:08:30 <mm_freak> quicksilver: what's the tradeoff?  because people can write all sorts of weirdly shaped functions?
02:08:33 <quicksilver> I'm talking about the effect mixfix operators have on language readability
02:08:51 <quicksilver> and how much context you need to "mentally parse" a given expression
02:09:11 <mm_freak> merijn: haskell is great, but it's far from a death machine =)
02:09:41 <merijn> mm_freak: Type theory powered kitten dispenser?
02:10:23 <quicksilver> merijn: for example, consider the expression "foo bar baz bam ni po"
02:10:37 <merijn> quicksilver: True, then again, as the saying goes: Real programmers can write assembler in any language
02:10:47 <quicksilver> in haskell you can be confident that that is one function "foo" with five parameters.
02:11:04 <quicksilver> in agda you need to know if any of those six symbols have defined mixfixedness
02:11:09 <merijn> quicksilver: Seems like a problem easily solved by structural editing :>
02:11:19 <quicksilver> indeed.
02:11:37 <mm_freak> merijn: all i'm saying is that you're probably overstating the power of haskell's type system…  it's just more powerful than every other practical language =)
02:11:38 <quicksilver> the same problem exists with binops of course
02:11:58 <quicksilver> you don't know how (a ~ b # c) associates
02:11:59 <mysticc> What is a mixfix operator
02:12:05 <merijn> mm_freak: I'm just utilising hyperbole for maximum propaganda
02:12:08 <quicksilver> mysticc: http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.Mixfix
02:12:23 <quicksilver> but with haskell the problem is limited to binops
02:12:29 <mm_freak> mysticc: in agda the if/then/else construct is a regular function, yet you notate just like in haskell
02:12:39 <merijn> mysticc: mixfix lets you define functions like "if a then b else c" where a, b and c are argument and the rest is the function name
02:12:56 <quicksilver> in agda you can't do any useful lexical analysis without knowing the mixfixity of every symbol involved.
02:13:00 <mm_freak> merijn: in fact just right now i'm exploring the land of dependent types for practical programming =)
02:13:12 <mm_freak> sort of like edwin brady, but i'm focussing on other things
02:13:23 <merijn> quicksilver: Where is most Agda stuff happening? Do you know?
02:13:43 <merijn> (Or I guess that should be addressed to everyone)
02:14:14 <merijn> From the URL and a quick google I'm guessing Chalmers?
02:14:15 <quicksilver> in #agda ?
02:14:34 <merijn> I meant an actual physical "where" :)
02:14:48 <mm_freak> merijn: theorem proving…  nothing much is happening in the programming sector
02:15:00 <mm_freak> most agda people don't even compile their code…  they're happy when it typechecks =)
02:15:01 <quicksilver> Thorsten is still in nottingham as far as I know
02:15:25 <quicksilver> and as you say, chalmers
02:15:36 <merijn> mm_freak: I guess. I'm interested in dependent typing, but from a slightly more practical direction. Pure theory is not my cup of tea
02:16:13 <merijn> Or rather pure theory for theory's sake, rather than pure theory for practical stuff's sake
02:23:05 <mm_freak> merijn: you may want to check out idris then
02:23:21 <mm_freak> it's still in its infancy, but it's probably what you're looking for
02:23:38 <mm_freak> http://idris-lang.org/
02:24:07 <merijn> Aww...
02:24:11 <merijn> eager :(
02:33:01 <earthy> hm... idris is especially interesting when contrasting with bitc
02:39:58 <merijn> @pl \f -> (\x y _ -> f x y)
02:39:58 <lambdabot> ((const .) .)
02:44:46 <mroman_> @pf ((const .) .)
02:44:47 <lambdabot> Maybe you meant: bf pl
02:45:13 <merijn> What's the best way to pass multiple do blocks to a function? parenthesis, introduce a local function for each do block or something else?
02:45:55 <mm_freak> merijn: matter of taste
02:46:11 <bitonic> merijn: if the do blocks are like 2 lines you can inline them... otherwise I'd put them in local variables, but it's up to you really
02:46:18 <bitonic> you can format them nicely using braces
02:46:20 <quicksilver> merijn: nothing wrong with parenthesis.
02:47:30 <merijn> bitonic: Yeah, but how would I inline them? "foo do <code here> do <other code here>" and then on separate lines do indented eually for both?
02:47:48 <merijn> (lunch)
02:48:07 <bitonic> merijn: with "inline" I mean 'do foo; bar;'
02:48:07 <mm_freak> merijn: personally i'd use parentheses
02:48:17 <mm_freak> it's the only case where i write directly after the 'do'
02:48:17 <bitonic> merijn: without newlines
02:48:23 <bitonic> you will always need parens anyways
02:48:39 <bitonic> e.g. foo do {one; two} do {three; four} won't work
02:48:50 <bitonic> foo (do one; two;) (do three; four;) will
02:48:58 <hpaste_> “Ertugrul Söylemez” pasted “Passing computations” at http://hpaste.org/67585
02:48:59 <bitonic> well you can omit the last semicolon as well
02:49:08 <mm_freak> merijn: see the paste for how i would write it
02:49:29 * quicksilver would do it mm_freak's way
02:49:44 <bitonic> I probably wouldn't just because I don't like how it looks :P
02:49:48 <bitonic> it's a matter of taste really...
02:50:01 <mm_freak> bitonic: i mostly care about readability
02:50:23 <mm_freak> style/aesthetic comes next
02:51:41 <mm_freak> i got used to that style when i was heavily working with arrow notation, where this question arises all the time
02:55:36 <mm_freak> shachaf: i think i'm going back to named arguments…  de bruijn indices complicate other things too much
02:55:45 <mm_freak> error messages from the type checker become unintelligible
02:56:05 <shachaf> mm_freak: :-(
02:56:10 <shachaf> But they're so much more sensible!
02:56:15 <shachaf> Names are so arbitrary.
02:57:48 <bitonic> mm_freak: how do de bruijin indices compilate things (I'm actually curious, in my little experience they're much clearer)
02:58:03 <bitonic> mm_freak: yeah I know but I can't help looking at that and cringe :P
02:58:06 <bitonic> it looks like lisp!
02:58:09 <mm_freak> i'm not questioning their elegance, but unfortunately practical concerns force me to go back…  they would be useful in simply typed lambda calculus, but in a dependently typed language they disturb more than they help
02:58:35 <bitonic> mm_freak: yeah but I'm asking how they disturb things
02:58:41 <mm_freak> bitonic: your type checker gives you a type error like:  expected 0 -> 1 3, inferred 1 3
02:58:55 <bitonic> mm_freak: oh ok, error reporting is a problem, but you can carry the names with the indices
02:58:56 <quicksilver> bitonic: you say that like it's a bad thing. There is nothing unaesthetic about parens for grouping, you need to fix your aesthetics :)
02:59:34 <bitonic> quicksilver: *you* need to fix you aestetics! I just can't stand parens-heavy syntaxes :P
03:00:02 <mm_freak> bitonic: let me say it this way:  with named arguments you need a substitution function and an alpha-conversion function
03:00:06 <bitonic> well more specifically I don't like where parens span on more than one like
03:00:14 <mm_freak> with de bruijn indices you need additional stuff virtually everywhere
03:00:26 <quicksilver> bitonic: it's not parens-heavy.
03:00:44 <quicksilver> bitonic: parens-heavy is where you have lots of them. these aren't even nested!
03:00:52 <mm_freak> bitonic: i prefer "print (f x)" over "print $ f x" or "print . f $ x"
03:00:58 <bitonic> mm_freak: mh. well the shifting and substituting functions for de bruijin indices are very simple. and less error prone in my experience
03:01:10 <bitonic> quicksilver: yeah read my next message, I don't like there parens span over multiple lines, mostly
03:01:18 <bitonic> mm_freak: I agree with that
03:01:36 <quicksilver> bitonic: do you also dislike [] and {} which span multiple lines?
03:01:47 <bitonic> quicksilver: no
03:01:53 <mm_freak> bitonic: i'd totally use them in a language with a clear distinction between value level and type level
03:02:01 <mm_freak> in fact i'm going to have to implement such a language
03:02:11 <mm_freak> but for my DT core language i'll go with names
03:02:51 <bitonic> well ok. I'll implement a language with dep. types sooner or later and I'll see :P
03:02:59 <quicksilver> bitonic: fair enough. makes no sense to me :P
03:03:17 <bitonic> quicksilver: yeah it's completely arbitrary, you can't argue with that! ehe
03:04:18 <mm_freak> bitonic: one really bad thing about them is that when you carry names with you you will have to make sure that every component in your system generates the same names and that evaluation doesn't change the names in a way that disturbs this process
03:04:41 <mm_freak> i haven't even tried to do that, because the sole apparent complexity turns me off
03:05:07 <mm_freak> in every other way i agree with both you and shachaf
03:05:26 <bitonic> uhm ok, it's hard to picture these problems until you face them
03:07:00 <mm_freak> well, this is about the tenth time i (intentionally) reimplement my core language from scratch…  i want to be really fluent and try many options with that before i go into productive development
03:07:30 <bitonic> mm_freak: wait you actually want to develop an usable language?
03:07:37 <mm_freak> yeah
03:07:56 <bitonic> oh. good luck.
03:08:05 <bitonic> what are your goals?
03:08:22 <bitonic> the usual dependently-typed-but-practical fairy tale :P?
03:08:26 <bitonic> (just kidding)
03:08:34 <mm_freak> well, first of all a framework for compiling dependently typed FP languages
03:09:04 <mm_freak> the plan is to have three languages, the highest compiling all the way down to the lowest
03:09:27 <bitonic> mm_freak: i'm sure you've looked at epic/idris
03:09:39 <mm_freak> i have
03:10:01 <bitonic> epic looks like a good start for a low-level functional language
03:10:09 <mm_freak> the lowest is a statically, strongly typed C-like language, designed to be easily optimizable, the middle (core) language is a DT language that performs the hard type-level work
03:10:14 <mm_freak> and finally there is the high level language
03:10:40 <mm_freak> currently i'm working on the low and middle levels
03:11:45 <mm_freak> well, i looked into epic, but my goals for the low level language are slightly different
03:11:49 <womb> > 7*7
03:11:50 <lambdabot>   49
03:12:09 <mm_freak> it will be an imperative language with a high level type system, but low level operations
03:12:16 <womb> guys how come warp is so fast ?
03:12:17 <bitonic> uhm
03:12:23 <bitonic> womb: magic
03:12:29 <mm_freak> womb: haskell =)
03:12:38 <womb> snap uses libevent and in warp they also uses async evented thing
03:12:47 <womb> so in theory it is same apporach
03:12:57 <bitonic> womb: snap does much more than warp
03:13:02 <bitonic> well the snap server
03:13:05 <bitonic> iirc
03:13:14 <womb> snap is slower in benchmarks ;/
03:13:18 <womb> i'm so confused
03:13:22 <mm_freak> yeah, snap is slightly higher level
03:13:26 <mm_freak> but only slightly
03:13:53 <mm_freak> warp trusts the RTS to do the right thing, and the RTS is good at doing the right thing
03:14:04 <mm_freak> also it uses fast abstractions for almost everything
03:14:09 <mm_freak> conduits, builders, etc.
03:14:36 <womb> RTS can you explain more about it ;p
03:14:42 <bitonic> womb: this explains why snap is fast: http://steve.vinoski.net/pdf/IC-Warp_a_Haskell_Web_Server.pdf
03:14:44 <mm_freak> haskell's run-time system
03:14:48 <womb> but its like 16k vs 8k req/sec
03:15:01 <mm_freak> the execution environment that powers every haskell application
03:15:13 <mm_freak> it is responsible for resources and threading
03:15:26 <mysticc> I was just trying to use criterion and wrote a toy bench program http://paste.pocoo.org/show/586962/ .. and got results http://paste.pocoo.org/show/586965/ .. As far I can see is map so slower than my naive implementation ... ?
03:15:47 <womb> ok, i need to read about this, i'm haskell newbie but i ome from a world of distributed programming and this performance diff makes me so confused.
03:15:59 <mm_freak> the benchmarks indicate that warp even outperforms HTTP server programs written in C, including apache, and frankly i'm not surprised
03:16:20 <mm_freak> multithreading in C is very difficult and it's almost impossible to reach the speed of a concurrent haskell program
03:16:25 <womb> its not hard to outperform apache ;p
03:16:30 <srhb`> Isn't Apache notoriously slow?
03:16:47 <mm_freak> apache itself, configured properly, isn't that slow
03:16:47 <womb> try to outperform nginx rather then apache
03:16:53 <quicksilver> how fast apache is depends how you configure it
03:17:02 <quicksilver> but raw webserver req/s are very very rarely your bottleneck
03:17:04 <mm_freak> womb: on my server nginx is the main bottleneck
03:17:12 <womb> nice
03:17:35 <mm_freak> a benchmark against raw warp turns more requests/second
03:17:36 <womb> why not change to haproxy and just eliminate nginx and serve assets from warp / faster thing :P
03:17:37 <quicksilver> the difference between 100/sec and 80,000/sec from your web server doesn't matter if something else is taking more than 10 milliseconds.
03:17:44 <mm_freak> because nginx is powerful
03:17:46 * mysticc thinks we should change LAMP to LW?H .. 
03:18:17 <mm_freak> it is very flexible and takes responsibility to do boilerplate stuff like logging
03:18:25 <srhb`> Heh..
03:18:33 <srhb`> Linux, Yesod, Acid-State, Haskell
03:18:37 <srhb`> LYAH. <_<
03:18:47 <mm_freak> hehe
03:18:55 <mysticc> srhb`: Acid-State .. still not sure ...
03:19:08 <merijn> mm_freak: Apache is not really a speed monster, though
03:19:09 <srhb`> mysticc: Well I was kind of designing it for ambiguity, I admit..
03:19:41 <mm_freak> merijn: i covered that =)
03:19:43 <srhb`> And indeed, it is true. It's very hard to conjure up reasonable scenarios where all you want to do is serve pages really really really really fast.
03:20:22 <quicksilver> mysticc: doesn't your NFData instance for your 'List' type do nothing?
03:20:49 <burbul> @pl \x -> [x]
03:20:50 <lambdabot> return
03:20:54 <mysticc> quicksilver: I have never used criterion .. so just declared the instance which does nothing
03:20:59 <quicksilver> mysticc: so you've proved that doing nothing is faster than running a map over a list of 1000000 elements.
03:21:13 <mysticc> hehehe
03:21:15 <quicksilver> mysticc: NFData and deepseq are not part of criterion :P
03:21:22 <merijn> Does acid-state let you store to disk?
03:21:42 <quicksilver> the purpose of acid-state is to store to disk.
03:21:53 <mm_freak> merijn: what does ACID tell you? =)
03:22:57 <mysticc> mm_freak: Can I have say a 100gb database on a 4gb ram on acid-state ?
03:23:09 <quicksilver> no.
03:23:16 <quicksilver> (I don't think so, anyway)
03:23:18 <mysticc> @hoogle NFData
03:23:18 <lambdabot> Control.Parallel.Strategies class NFData a
03:23:19 <lambdabot> Control.DeepSeq class NFData a
03:23:21 <quicksilver> acid-state isn't about databases.
03:23:24 <mm_freak> mysticc: no
03:23:41 <quicksilver> it's about acid access to haskell data structures
03:23:57 <mm_freak> acid-state is not a database service…  it gives you the ability to safely store an in-memory data structure to disk
03:24:10 * mysticc thinks haskell should have a native database ..
03:24:23 <mm_freak> a real database is a very complicated piece of work
03:24:25 <merijn> Damn, disconnected
03:24:52 <mysticc> merijn: disconnected , from ?
03:25:01 <mysticc> mm_freak:
03:25:04 <mm_freak> one workaround is to create a huge swap partition
03:25:16 <merijn> mm_freak: I think ACID tells me something about atomicity, consistency, isolation and durability. Neither of which specifies I can dump it to a file and parse it back in :p
03:25:25 <mm_freak> he was disconnected by that "remote host" guy =)
03:25:33 <mysticc> mm_freak: Haskell is powerfull enough for doing such complicated thing better than C ..
03:25:36 <mm_freak> mr. host did it
03:26:07 <merijn> mm_freak: Anyway, if you mentioned anything after that acid question I missed it
03:26:09 <mm_freak> merijn: durability is the feature of ACID that tells you that
03:26:43 <bitonic> merijn: acid-state provides very strong durability guarantees. you can unplug the AC and you'd still have your data
03:27:08 <mm_freak> mysticc: yet it's a complicated thing…  feel free to implement a real database service in haskell, but before you do decide about the model you want to follow
03:27:15 <mm_freak> relational?  document-based?  …?
03:27:15 <mysticc> bitonic: Why the hell would I unplug the AC .. :P
03:27:49 <bitonic> mysticc: you wouldn't, but a power outage would have the same effect
03:27:54 <mm_freak> acid-state can't even be compared to a database service
03:28:13 <bitonic> mm_freak: it can. they have some overlap in functionality
03:28:24 <quicksilver> it can usefully be compared
03:28:26 <bitonic> acid-state can be an alternative to a more traditional database service
03:28:27 <mysticc> mm_freak: Cant it be build in a modular fashion .. same backend , different frontend ?
03:28:28 <quicksilver> but they are indeed different.
03:28:43 <womb> o fock, warp is not using libev he is using fork-join like erlang style thing.
03:28:44 <womb> Omg
03:28:49 <womb> i started to love haskell
03:29:27 <merijn> womb: The haskell runtime is already implemented using epoll/kqueue/select underneath
03:29:40 <mysticc> womb: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
03:29:44 <womb> yeah i read
03:29:57 <womb> kqueue but API is still "dead easy old school" :D
03:30:01 <merijn> womb: So using libev inside haskell makes very little sense
03:30:02 <womb> omfg
03:30:09 <womb> yeah
03:30:18 <womb> my mind just got blown away
03:30:32 <womb> for me writing code in haskell is hard ;/ because ii'm newbie
03:30:38 <womb> this is just pure awesome
03:31:02 <mm_freak> mysticc: it's already built that way
03:31:12 <mm_freak> the frontend is acid-state, the backend is (usually) safecopy
03:31:18 <merijn> @quote writing.incorrect
03:31:19 <lambdabot> <roconnor> says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
03:31:19 <lambdabot> haskell ;) <kmc> that's a pretty good summary
03:31:29 <womb> its like "wow" really "wow" so new bottleneck will be redis lol :D
03:31:39 <mm_freak> mysticc: but all that doesn't change the fact that update/query computations involve having the value in memory
03:31:55 <womb> i wonder if people try to implement things like bitcask or redis in haskell to gain performance also in db field
03:31:57 <mm_freak> it's just the way acid-state is designed and there is nothing you can do about it without assuming further knowledge about the data
03:32:07 <mm_freak> so if you want the features of a real database, you have to choose a data model
03:32:10 <mm_freak> relational, etc.
03:32:27 <womb> i'm using mostly key-value storages
03:32:35 <womb> redis / mongodb / riak
03:32:50 <womb> so i was  a bit scepting because of static typing
03:32:58 <mysticc> womb: Haskell should have something like riak in erlang ..
03:33:00 <bitonic> womb: redis will be faster than any key-value Haskell thing available in terms of number of writes/reads per second
03:33:03 <mm_freak> womb: static typing is actually your friend there
03:33:10 <womb> you can call me crazy but i don't care about ACID state of transactions :D
03:33:24 <merijn> womb: You say that now, but...
03:33:31 <mm_freak> womb: you have an untyped storage, so your data /must/ pass validation to be encoded in the corresponding haskell data structures
03:33:44 <womb> yes thats my only "problem"
03:33:52 <merijn> That's the same thing that most people say about float "oh, I don't really care that they behave a bit differently"
03:34:02 <mysticc> bitonic: what's the bottleneck  ?
03:34:05 <womb> mainly im doing scraping / data minning  / extraction so i have shitloads of unstructured data
03:34:09 <merijn> Usually followed (a week or so later) by "why the hell did I use floats?!"
03:34:18 <bitonic> mysticc: bottleneck of what?
03:34:25 <mysticc> bitonic: redis in haskell
03:34:26 <womb> i don't do currency etc.
03:34:44 <mm_freak> womb: in the worst case you can always use Map String String
03:34:49 <bitonic> mysticc: I'm not saying you can't write redis in Haskell.
03:34:57 <bitonic> I'm saying right now it doesn't exist :P
03:35:06 <mysticc> bitonic: I am saying why cant you beat redis ...
03:35:12 <bitonic> mysticc: I didn't say that
03:35:14 * hackagebot zlib-enum 0.2.2.1 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2.2.1 (MalteSommerkorn)
03:35:35 <mysticc> bitonic:  bitonic> | womb: redis will be faster than any key-value Haskell thing available in terms of number of writes/reads per second
03:35:55 <bitonic> mysticc: where in that message I say that you'll never be able to beat redis?
03:36:50 <mysticc> bitonic: Oh .... I see .. someone should give it a try ..
03:36:51 <womb> mm_freak: i don't wanna do String String because its cheating and i lose all befentis
03:37:01 <burbul> If there an easy way to write a type signature for a variable introduced in a do block ?
03:37:15 <burbul> (In the way that you can for a let block)
03:37:20 <mm_freak> womb: then the type system is your friend =)
03:37:20 <bitonic> burbul: ScopedTypeVariables
03:37:26 <mysticc> burbul: whats the problem
03:37:33 <womb> mm_freak:  my biggest problems is network latency really ;/ but i managed to reduce memory usage from 16 gb on app server in ruby to 57 mb when i switched to erlang
03:37:41 <bitonic> burbul: e.g. (x :: Int) <- foo
03:37:42 <quicksilver> variables introduced in do blocks don't have a specific signature syntax
03:37:44 <womb> which is massive improvement
03:37:45 <mm_freak> the type system is always your friend
03:37:51 <quicksilver> but you can either annotate the variable using an extension
03:37:59 <quicksilver> or the expression (the foo in bitonic's example) without any extension
03:38:07 <bitonic> burbul: of course you can write the type sig on the rhs but it's often uglier
03:38:37 <mm_freak> bitonic: btw, we have a redis-like feature in haskell
03:38:41 <womb> i'm exploring haskell because i would love to have even better performance, we have dedicated hardware with 8 core cpus so CPU's are not a problem. But above 16gb ram usage it started to be a problem ;/
03:38:46 <mm_freak> you find it in the containers library =)
03:38:47 <quicksilver> the extension used to be called PatternSignatures (which is logical enough) but in recent GHC it got merged into ScopedTypeVariabls I think.
03:38:51 <burbul> right -- thanks. (I knew abotu those, but was hoping I could do what you do in a let block for readability)
03:38:56 <mysticc> Why do people use ruby ..
03:39:09 <burbul> I've got ScopedTypeVariabls  switched on -- '(x :: Int) <- foo' works great
03:39:22 <Arafangion> mysticc: It's a good object oriented scripting language.
03:39:35 <bitonic> mm_freak: that won't even come close to redis in terms of speed, sadly
03:39:42 <bitonic> in redis use case
03:39:45 <mm_freak> womb: if you try to manage the storage with haskell itself, your memory behavior will be worse, but interfacing to something like redis should work fine
03:39:52 <Arafangion> mysticc: One available by default. (Except for windows, which doesn't count)
03:40:04 <bitonic> yeah the good thing about redis is that it's a very simple service you can talk to
03:40:10 <mm_freak> haskell /programs in memory/ have a low footprint, but the memory behavior can be difficult to predict
03:40:40 <womb> mm_freak: problem with big data structures in functional languages is massive gc/cpu cluster fock. That's why i need to use external storage.
03:40:52 <Arafangion> mm_freak: I've lost being able to predict memory usage even in traditional imperative languages.  It's easy to predict until you start using frameworks and large libraries.
03:41:06 <womb> mm_freak: if you have a tree with 50k nodes and you insert new node you get a feeling of being "r*ped"
03:41:30 <womb> it only kills me that i learn haskell so slow ;p
03:41:52 * mysticc thinks We should start Haskell World Domination ..
03:41:54 <womb> but thats probably because i'm stupid :D
03:42:56 <merijn> womb: If its any consolation I tried to start learning 5 times over 1-2 years before thinks finally went "click"
03:43:30 <womb> oh nice, with erlang i was "production ready" after week spending on casual reading of Joe book and playing with rebar ;p
03:43:55 <hiptobecubic> I am trying to learn the relationship between types and typeclasses but it's unclear to me which is more appropriate for some idea.  For example, I have two different items i want to model. They have some properties in common, like having a 'start date' and an 'end date', etc. Would it make sense for there to be a type class that captures the commonalities between them and then make them both instances of it?
03:44:05 <mm_freak> womb: GC and CPU aren't that bad in haskell…  they are also quite easy to predict and benchmark…  it's really the memory behavior
03:44:14 <merijn> womb: Once type signatures and typeclasses start clicking for you, you are well under way
03:44:22 <mm_freak> usually when a haskell program has good memory behavior it automagically also has good CPU/GC behavior
03:44:27 <quicksilver> hiptobecubic: as a rule of thumb
03:44:33 <quicksilver> hiptobecubic: never, ever, write a typeclass.
03:44:45 <womb> in erlang each process has its own gc, thats great feature.
03:44:45 <hiptobecubic> quicksilver, :D that was what i originally understood yeah
03:44:51 <mm_freak> Arafangion: well, i'm talking about the asymptotic memory behavior
03:44:59 <womb> but i have read about haskell parallel gc
03:45:05 <womb> and i was like "this is awesome"
03:45:06 <hiptobecubic> quicksilver, but why are they hailed as being so useful? and how do i model this problem then?
03:45:08 <quicksilver> hiptobecubic: typeclasses are not a general purpose abstraction for programming with; they're a specific method for overloading.
03:45:21 <hiptobecubic> quicksilver, but i *do* actually need overloading
03:45:26 <mysticc> womb: Where do your read that ..
03:45:33 <quicksilver> hiptobecubic: then, for the overloading part, typeclasses are the right answer.
03:45:38 <quicksilver> hiptobecubic: (but only for that part)
03:45:46 <merijn> hiptobecubic: Because they *are* very useful, just not for inheritance-like purposes
03:46:03 <hiptobecubic> quicksilver, if i do "premium o", then it is implemented differently depending on the type of o
03:46:10 <mm_freak> womb: btw, data structures in haskell use sharing, so even a giant pure tree structure is easy to modify
03:46:20 <womb> mysticc:  i google like 2 weeks ago some white paper i can try to find it again
03:46:25 <hiptobecubic> but for just properties of 'o', those belong in just a record?
03:47:06 <hiptobecubic> "startDate o"  should come from   "data O = o {startDate :: Whatever}" ?
03:50:17 <bjorkintosh> how is concurrency handled in haskell?
03:50:20 <bjorkintosh> is there support for it?
03:50:45 <hiptobecubic> bjorkintosh, google "concurrent haskell" and look for the haskellwiki
03:50:59 <bjorkintosh> i can see it on wiki
03:51:08 <bjorkintosh> but is it a standard extension?
03:51:24 <womb> mm_freak: http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Parallel_garbage_collection this is the place i was reading abut parallel garbage collections
03:51:37 <quicksilver> there is only one implementation of haskell that matters at the moment for systems work, bjorkintosh
03:51:44 <merijn> bjorkintosh: What do you mean by "how is concurrency handled"? Do you just mean thinks like servers dealing with multiple clients, etc?
03:51:44 <quicksilver> and that implementation supports the concurrency.
03:52:25 <bjorkintosh> merijn, concurrency in terms of multiple cores and whatnot.
03:52:47 <mm_freak> bjorkintosh: it's not even an extension…  concurrency is a builtin feature of the RTS and the base library
03:52:56 <mm_freak> sort of like erlang
03:52:56 <bjorkintosh> hmm.
03:52:57 <EnglishGent> hello :)
03:53:02 <hiptobecubic> merijn, how are 'inheritence-like' purposes handled?
03:53:06 <bjorkintosh> i was going to say ... like erlang?
03:53:37 <bjorkintosh> thanks hiptobecubic.
03:54:20 <bjorkintosh> did not know that about haskell.
03:54:26 <mm_freak> bjorkintosh: when it comes to concurrency haskell and erlang have many things in common
03:54:33 <merijn> hiptobecubic: Usually you can just do things like "data Foo = Foo <bunch of fields here>" and if you have two data types bar/baz "inheriting" it use "data Bar = Bar Foo <other fields>" and "data Baz = Baz Foo <other fields>", although it depends on exactly how you plan to use things
03:55:43 <hiptobecubic> if i have three types, A, B, and C, and all of them have four different fields in common, but have at least one unique field of their own
03:56:04 <srhb`> hiptobecubic: Make a datatype for the common fields.
03:56:11 <hiptobecubic> ok
03:56:18 <srhb`> (Or, that's one way to do it)
03:56:21 <quicksilver> hiptobecubic: (NB "just a record" is probably not quite thinking straight; haskell doesn't have records, haskell just has a special notation for accessing named fields)
03:56:22 <hiptobecubic> i thought's where the classes came in, but i guess i was one level too high
03:56:24 <merijn> hiptobecubic: The four common fields would be in Foo (in my example)
03:56:34 <mm_freak> you can also do this with a GADT
03:56:53 <srhb`> huh, we have GADTs?
03:56:56 <srhb`> x_x
03:57:04 <mm_freak> srhb`: are you serious?
03:57:25 <srhb`> Someone neglected to tell me!
03:57:32 <mm_freak> GADTs have been there for a long time now…
03:57:42 <mm_freak> {-# LANGUAGE GADTs #-}
03:57:46 <srhb`> God..
03:57:57 <srhb`> Well, thanks. -_-
03:58:18 <mm_freak> that changes your life, doesn't it? =)
03:58:19 <quicksilver> it's quite surprising you could understand the phrase "GADT" without knowing that haskell had them
03:58:27 <srhb`> mm_freak: By a slightly degree. Dammit. :P
03:58:28 <mm_freak> indeed
03:58:32 <srhb`> slight*
03:58:32 <quicksilver> since that phrase, in its current form, was essentially invented by GHC
03:58:46 <quicksilver> it only has meaning outside haskell by virtue of comparing to the haskell implementation.
03:58:49 <mm_freak> quicksilver: although features usually get discussed long before GHC finally implements them
03:59:01 <hiptobecubic> quicksilver, yes i realize it's just some sugar for doing something terrible like  "start (o _ _ _ _ _ _ start) = start", right?
03:59:01 <quicksilver> long before it makes it in the stable branch, perhaps.
03:59:07 <quicksilver> hiptobecubic: yeah.
03:59:10 <mm_freak> or that
03:59:10 <adimit> srhb`: there's a video by heinrich apfelmus introducing GADTs in Haskell which I found very nice: http://apfelmus.nfshost.com/blog/2010/06/01-gadts-video.html
03:59:17 <quicksilver> hiptobecubic: and it's not even very sweet sugar :)
03:59:26 <srhb`> quicksilver: The explanation of ADTs in Haskell and their restrictions vs. "G..."
03:59:34 <srhb`> But yes, I am surprised too.
03:59:42 <srhb`> adimit: Thanks!
03:59:45 <mm_freak> i even stopped writing non-G-ADTs except for simple enum types
03:59:47 <bitonic> hiptobecubic: I nice upside of record syntax is that you can add/remove fields to your record without breaking any pattern
04:00:20 <hiptobecubic> well i assume it's expanded properly at compile time?
04:00:43 <hiptobecubic> so the pattern *is* changing, it just doesn't matter because you didn't write it
04:01:10 <mm_freak> i think the core language doesn't know about records, but i could be wrong
04:01:31 <merijn> @src (->) r (>>=)
04:01:31 <lambdabot> Source not found. :(
04:01:38 <EnglishGent> hi all :)
04:01:45 <merijn> @src (->) (>>=)
04:01:45 <lambdabot> f >>= k = \ r -> k (f r) r
04:01:49 <mm_freak> hi there EnglishGent
04:01:52 <srhb`> EnglishGent: Hi
04:02:55 <EnglishGent> not really a Haskell question (apologies) - but this one of the few places I know where someone might be able to help... but does anybody know what on earth a 'traced category' is? I know a little category theory - but the wikipedia entry is wibble to me... and apparently I need to know to understand a (Haskell relevant) paper I am trying to wade through
04:03:07 <EnglishGent> any help gratefully appreciated :)
04:03:17 <EnglishGent> hi srhb` :)
04:03:27 <EnglishGent> hi mm_freak :)
04:05:40 <jfischoff> out of curiosity is the paper about moniodial traced categories?
04:06:16 <EnglishGent> the paper is about 'rational & negative types'
04:06:32 <jfischoff> yes, I know the paper. The Indiana guys
04:06:33 <EnglishGent> and it makes reference to monodial traced categories
04:06:47 <EnglishGent> monodial categories I get (I think)
04:06:58 <EnglishGent> traced categories are completely new to me
04:07:36 <jfischoff> was this the wikipedia article http://en.wikipedia.org/wiki/Traced_monoidal_category?
04:08:18 <EnglishGent> yes
04:08:58 <EnglishGent> my knowledge of category theory comes from self-study - sadly I am not in academia & never had the chance to do a proper course in it
04:09:12 <EnglishGent> so stuff as dense as that is nearly impenetrable to me :/
04:09:23 * EnglishGent keeps trying though :)
04:10:20 <EnglishGent> if you know the paper I'm trying to grok I'd appreciate any help :)
04:10:38 <adimit> I'm in nearly the  same boat (my subject is far from cat theory) and I'm self-studying it via Lawvere's books.
04:11:01 <EnglishGent> <-- a humble industy programmer who desperately *wants* to understand Haskell & the math behind it
04:11:02 <adimit> but I can't offer help for that specific paper:-|
04:11:05 <EnglishGent> hi adimit :)
04:11:17 <jfischoff> This was one of the first papers on the Pi language, not sure if it helps
04:11:18 <jfischoff> https://www.cs.indiana.edu/~rpjames/papers/rc.pdf
04:11:36 <merijn> EnglishGent: I think knowing category theory disqualifies you from calling yourself an industry programmer...
04:12:03 <adimit> :-)
04:12:07 <EnglishGent> adimit - 'conceptual mathematics' ? (book) :)
04:12:07 <hiptobecubic> this video on GADTS is nicely done :)
04:12:08 <mm_freak> oh good…  luckily i don't know category theory =)
04:12:39 <adimit> hiptobecubic: isn't it? I'm just rewatching it. apfelmus++
04:12:41 <EnglishGent> merijn - well as I said I only know it because of self-study.... but ty :)
04:13:07 <hiptobecubic> adimit, yeah. I didn't get phantom types until now
04:13:12 * EnglishGent is definitely the most mathematically inclined of the people in his office... I had to explain DeMorgan's laws to someone a while back :|
04:13:36 <adimit> EnglishGent: yeah, that one, and another one. One was Lawvere and Rosenburgh, the other Lawvere and Schanuel (you meant the second one.)
04:14:07 <jfischoff> EnglishGent: Why are you interested in reversible programming?
04:14:11 <adimit> I think the latter one is easier to understand, but the former one is more… dunno, mathematical?
04:14:24 <bitonic> EnglishGent: sadly I can't answer your question, but I can naively suggesting you Awodey book on category theory
04:14:26 <mm_freak> EnglishGent: my sympathies
04:14:27 * jfischoff is very interested in reversible programming 
04:14:33 <EnglishGent> jfischoff - well a) because of it's connection with physics
04:14:56 <bitonic> EnglishGent: I read the first chapters and it tries hard to make CT likeable. Not sure if it covers traced categories
04:14:58 <mm_freak> in my last work i implemented iteratees in PHP…  interestingly my coworkers used them with no problems even though they didn't understand anything about iteratees
04:16:13 <bjorkintosh> mm_freak, they didn't have to did they?
04:16:32 <EnglishGent> and b) I'm interested in type theory generally - and I like the idea of 'negative and fractional types' - as it seems to make type expressions even closer to arithmetic - I came across the thing about the relatioship between type expressions, & differentiation a while back (one-hole contexts)
04:16:40 <EnglishGent> and I'd like to know how deep the analogy goes
04:16:42 <EnglishGent> :)
04:17:01 <mm_freak> bjorkintosh: well, i provided a large library of prefab iteratees, so all they needed to do was to stick them together
04:17:22 <mm_freak> the way to combine them felt a little weird to them, but it worked well
04:17:46 <merijn> @djinn (a -> b -> c) -> (a -> b -> c -> d) -> a -> b -> d
04:17:46 <lambdabot> f a b c d = b c d (a c d)
04:17:51 <mm_freak> new Print(new FileInput("blah.txt"))
04:17:52 <mm_freak> =)
04:18:02 <adimit> mm_freak: iteratees aren't very difficult to understand; they're very akin to unix pipes… I think the "difficult" thing about understanding iteratees for me was to understand oleg's notes on them and the iteratee-library's judicious use of CPS
04:18:26 <jfischoff> EnglishGent: Differentiation shows up in their paper. Its the unfold process.
04:18:32 <rzys> somebody knows if there is some diagram of hask?
04:18:33 <mm_freak> adimit: iteratees aren't trivial to understand, when you need to /implement/ them…  of course combining them is easy
04:18:37 <merijn> Yeah, iteratees are easy, the libraries are hard
04:18:40 <merijn> @pl \f a b c d -> b c d (a c d)
04:18:41 <lambdabot> const (flip (liftM2 ap))
04:18:45 <merijn> :t ap
04:18:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:18:47 <rzys> with nice little arrows and such :>
04:19:07 <mm_freak> rzys: you can easily draw it
04:19:21 <mm_freak> start with Maybe a, then Maybe (Maybe a), then Maybe (Maybe (Maybe a))
04:19:27 <mm_freak> and just go on, until you have all Maybe objects
04:20:04 <mm_freak> it will take some time until you can draw the morphisms, though…  be brave =)
04:20:14 * EnglishGent admits to having never heard of iteratees (ooh! a new concept!) :)
04:20:35 <mm_freak> EnglishGent: you don't need them…  conduits are the new shiny abstraction for stream processing =)
04:20:46 <rzys> would Maybe a be in the diagram?
04:21:08 <mm_freak> rzys: Hask is the category of all haskell types
04:21:10 <rzys> wouldnt it be just Maybe Int, Maybe (Maybe Int) ........
04:21:25 <rzys> is Maybe a   a type?
04:21:28 <mm_freak> well, ok, it doesn't contain the constructors
04:21:48 <mm_freak> but even then you have infinitely many of them
04:22:18 <mm_freak> this raises an interesting question
04:22:28 <mm_freak> does Hask capture universal quantification?
04:22:49 <rzys> yes, the diagram would need to be kind of simpel ofc
04:23:27 <mm_freak> are you sure?  type application is implicit in haskell, but i suspect it would be explicit in Hask, if it had it
04:23:29 <womb> bit.ly/K2I4Kg wow i was looking for sucha tool yesterday :D
04:23:52 <mm_freak> (forall a. a -> a) is really a type lambda and the compiler applies it for you
04:25:26 <mysticc> @hoogle NFData
04:25:26 <lambdabot> Control.Parallel.Strategies class NFData a
04:25:26 <lambdabot> Control.DeepSeq class NFData a
04:26:22 <Alan> hmm... trying to work out how i would achieve f [a, b, c] = f a b c
04:26:31 <quicksilver> @tell copumpkin it's not about whether all *values* are implicitly partial but about whether all *terms* are implicitly partial.
04:26:31 <lambdabot> Consider it noted.
04:26:35 <rzys> mm_freak, sorry did you say maybe there wouldn't be infinitely many 'subtypes' of Maybe (Maybe.... in de diagram?
04:26:40 <womb> guys how long it took you to from newbie to production level programming style in haskell ( i mean lang + few libs etc ) i'm going now bit mental at work about features of haskell i read about.
04:26:41 <quicksilver> @tell it's a static not a dynamic property being discussed.
04:26:41 <lambdabot> Consider it noted.
04:26:41 <mm_freak> Alan: you can't
04:26:49 <quicksilver> @tell copumpkin it's a static not a dynamic property being discussed.
04:26:49 <lambdabot> Consider it noted.
04:27:01 <mm_freak> Alan: well, you can with massive help from advanced type system features
04:27:03 <Botje> womb: going on five years now.
04:27:24 <mm_freak> rzys: there would, but Maybe itself wouldn't be in the diagram
04:27:30 <Botje> womb: the first few months is your brain exploding to make room for more of it :)
04:27:31 <womb> Botje: :( long
04:27:33 <mm_freak> because (->) has kind * -> * -> *
04:27:35 <Alan> mm_freak: it seems like something that should be a fold with ($), but yeah, then i realised the type is different at every stage...
04:27:42 <womb> Botje: my brain is melting yes
04:27:53 <Botje> womb: I was 'good enough' in six months
04:27:56 <mm_freak> Alan: exactly…  it is possible, but not worth the work
04:28:05 <Botje> but it depends on experience, of course
04:28:07 <Alan> mm_freak: fair enougth
04:28:24 <womb> Botje: the haskell just kicked in, walls are melting.
04:28:28 <mm_freak> Alan: you can do it with lightweight dependent types, so give it a shot with type level numbers, if you want to
04:28:40 <bitonic> womb: if you're already a programmer, it won't take you long to be knowledgeable enough to write mid-sized applications in Haskell
04:28:45 <Botje> womb: eh, keep up :)
04:28:49 <Botje> you'll survive
04:29:18 <sipa> womb: how long have you been Haskelling, and what feature in particular causes brainmelt?
04:29:21 <Alan> mm_freak: well actually i think I only need 1- and 2-argument applications anyway, so i'll just special case it..
04:29:25 <srhb> womb: I managed to write a snake game after two months, does that help? :-)
04:29:28 <mm_freak> rzys: actually what i'm saying is that forall a. Maybe a wouldn't be in the diagram
04:29:49 <rzys> mm_freak, iirc in some online page about haskell and category theory it said that a functor maps objects in hask to a subcategory in hask. i suppose Maybe a would have to be some kind of subcategory?
04:30:11 <mm_freak> rzys: Maybe A, yes
04:30:18 <ment> @hoogle m a -> (a -> b) -> m b
04:30:19 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
04:30:19 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
04:30:19 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
04:30:38 <mm_freak> rzys: forall a. Maybe a is a family of subcategories…  one subcategory for every type
04:30:58 <mm_freak> ah, no
04:31:08 <mm_freak> forall a. Maybe a is the functor
04:31:33 <quicksilver> you can argue about notation
04:31:33 <mm_freak> i don't know how to characterize the subcategory it forms
04:31:38 <quicksilver> but there is a subcategory
04:31:40 <rzys> Maybe A would be the subcategory with objects like Maybe Int Maybe Double?
04:31:44 <quicksilver> and Maybe a is a reasonable name for that subcat
04:31:55 <quicksilver> Maybe Hask is another reasonable name for it
04:32:08 <mm_freak> yeah, Maybe Hask sounds reasonable
04:32:21 <womb> sipa: i have read 80% of Real World Haskell on barcode recon thing my face melted first when he started to stack code and convert things into >>? etc :D
04:32:33 <womb> i hate when people overload operators etc :D
04:33:41 <bitonic> womb: then you'll hate haskellers
04:34:04 <rzys> does thinking about hask etc. improve ones understanding of haskell or is it rather likely to confuse the crap out of one?
04:34:34 <mm_freak> rzys: neither
04:34:56 <mm_freak> you will see the connection to category theory, but otherwise for practical programming you don't really need it
04:36:18 <rzys> mm_freak, okay good to hear. because before i tried to picture (liftM2 (,) realPart imagPart) in my head how it would look like in a diagram of Hask. :S
04:36:44 <rzys> and it gave me a headache hehe
04:37:08 <mm_freak> well, liftM2 isn't the easiest thing to start with, because for that one you need the notion of applicative functors
04:37:12 <mm_freak> (or monads, if you prefer)
04:38:49 <rzys> yea i think i just need to keep on programming and read some stuff about it and slowly let it seep in my head.
04:39:02 <mm_freak> talk to edwardk, the oleg of category theory
04:39:03 <mm_freak> =)
04:40:26 <mm_freak> @quote edwardk
04:40:26 <lambdabot> edwardk says: zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
04:40:57 <mm_freak> @quote edwardk
04:40:58 <lambdabot> edwardk says: i spend a lot of time hated
04:41:05 <rzys> haha
04:41:08 <mm_freak> lol
04:41:47 <rzys> holy shit 1% battery
04:42:09 <rzys> soon comes the incredibly loud thinkpad low battery sound and i'm in a completely silent library
04:42:36 <rzys> gotta shutdown this thing as fast as possible :S
04:42:45 <Alan> Oops, i think i tore the fabric of reality....
04:42:56 <Alan> my parsec parser is complaining because it expected what it got
04:43:01 <Alan> unexpected 's'
04:43:01 <Alan> expecting space, letter or digit, "_", ",", ";", new-line or end of input
04:43:07 <quicksilver> bitonic: I don't think haskellers overload operators very often.
04:43:14 <Alan> last time i checked, 's' was a letter....
04:43:28 <mm_freak> depends on what you mean by "overloading"
04:43:33 <quicksilver> bitonic: you don't often see (>>) used for anything other than Monad.>>, you don't often see <*> for anything other than Applicative.<*>
04:43:46 <quicksilver> mm_freak: in this context, I mean using the same operator for two different meanings
04:44:03 <mm_freak> yeah
04:44:08 <quicksilver> which is what I think womb means by "12:32 < womb> i hate when people overload operators etc :D"
04:46:45 <mm_freak> i wonder if i can encode a dependently typed SK calculus
04:47:15 <mm_freak> that one ought to be very easy to compile
04:48:08 <EnglishGent> hi quicksilver :)
04:49:13 <mm_freak> but how to encode types in SK?  should i assign types to variables or to S and K?
04:50:23 <mm_freak> i think variables will do…  i'll try
04:53:44 <t7> bitonic: where did you learn about substitution composition (your @@ operator in ml-w)? I havnt read why it works anywhere but other implementations have it like that
04:55:49 <t7> "Any mutual recursion can be converted to direct recursion by inlining the code of one procedure into the other." holy crap is this true?
04:56:06 <Jaak> yes
04:56:38 <Jaak> not sure about method, but it's always possible to convert to direct recursion
04:57:28 <t7> mm_freak: let me know if you manage todo that :)
04:58:27 <mm_freak> hmm, that's not as easy as i thought
04:59:00 <t7> i never managed to implement that last axis of the lambda calculus
04:59:44 <mm_freak> i implemented it many times now
05:00:02 <t7> src
05:00:03 <mm_freak> but if i can reduce the lambda calculus to a supercombinator calculus compilation will be much easier
05:00:30 <mm_freak> source is not online yet, although earlier i pasted a sample on hpaste
05:00:50 <MaskRay> How can i get `m (Source m B.ByteString)' instead of `m (Source (ResourceT m) B.ByteString)' from    responseBody `liftM` http request manager
05:01:08 <mm_freak> t7: http://hpaste.org/67584 ⇐ this is a buggy version of my experiment with de bruijn indices
05:01:55 <mm_freak> one of the two bugs can be solved by starting with (map show [0..]) instead of emptyCtx in the Show instance
05:02:02 <mm_freak> the other bug i haven't figured out yet
05:02:38 <t7> polymorphic types and type constructors are easy todo but dependant types...
05:03:40 <mm_freak> dependent types actually simplify most things
05:05:36 <mm_freak> i think S is going to have a very scary type in a dependent SK calculus
05:07:01 <t7> mm_freak: its desont look like lambda calc though: wheres the abstraction, Application etc
05:07:46 <mm_freak> t7: SK is equivalent to lambda calculus
05:07:58 <t7> no i mean your paste above
05:08:08 <mm_freak> ah
05:08:16 <mm_freak> (:$) is application, (:->) is lambda
05:08:44 <mm_freak> in a DT language there is no difference between the lambda arrow and the type arrow, so i merged them into a single constructor
05:09:01 <Alan> @src Text.Parsec.Token.integer
05:09:01 <lambdabot> Source not found. Maybe you made a typo?
05:09:08 <Alan> hmmm...
05:09:38 <mm_freak> and it's using de bruijn indices, so when you write ("Nat" :-> "Nat") :-> x, then the variable 0 in x will refer to the bound variable, unless you are in a deeper lambda
05:10:29 * hackagebot fixplate 0.1.2 - Uniplate-style generic traversals for fixed-point types, with some extras.  http://hackage.haskell.org/package/fixplate-0.1.2 (BalazsKomuves)
05:10:39 <mm_freak> ok, the type of S is too scary for my taste…  i go back to lambda calculus =)
05:11:11 <Alan> @src Text.ParserCombinators.Parsec.Token.integer
05:11:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:11:22 <t7> mm_freak: whats Typ?
05:11:42 <t7> and Var ...
05:11:58 <t7> ah ignore im not reading the GADT
05:12:09 <Alan> should i be using Text.ParserCombinators.Parsec or Text.Parsec?
05:14:19 <Ptival> http://stackoverflow.com/questions/6029371/whats-the-different-between-text-parsercombinators-parsec-and-text-parsec
05:16:27 <mm_freak> t7: Typ is the equivalent to Set…  because this is only a test i have Set : Set, so the calculus is logically inconsistent
05:16:46 <t7> yeah, would it be alot of work to add universes?
05:17:04 <mm_freak> in this simple case no
05:17:15 <mm_freak> use Typ :: Int -> Expr
05:17:29 <t7> Set n : Set n + 1
05:17:59 <mm_freak> for universe polymorphism one way is to add a primitive natural number type and have:  Typ :: Expr -> Expr
05:18:11 <mm_freak> then the type checker must ensure that the argument of Set is a Nat
05:19:01 <mm_freak> at least that's how i did it…  i don't know how other languages do it
05:19:19 <mm_freak> i think most have Set : Set except the popular ones like agda, coq and epigram
05:22:43 <Alan> well this is awkward.... Text.Parsec.Token has something I need, but it's not actually exported :(
05:25:56 <t7> mm_freak: how can (t :-> x) : (t :-> tx)
05:26:11 <t7> Int -> Bool : Int -> Set
05:26:35 <Alan> so here's a question... should i be using Int or Integer?
05:26:40 <Alan> what's the difference between them?
05:26:54 <t7> Integer is bigger
05:26:58 <t7> bigger and better
05:27:07 <quicksilver> but slower.
05:27:15 <Alan> i see
05:27:53 <fmap> > 10^30 :: Int
05:27:53 <lambdabot>   5076944270305263616
05:27:56 <mm_freak> Int -> Bool : Set1
05:27:59 <fmap> 10^30 :: Integer
05:28:00 <mm_freak> @ t7
05:28:04 <fmap> > 10^30 :: Integer
05:28:05 <lambdabot>   1000000000000000000000000000000
05:28:18 <mm_freak> t7: (x : Int) -> x : Int -> Int
05:28:43 <mm_freak> and Int -> Bool : Int -> Set1
05:28:58 <t7> ah
05:29:06 <mm_freak> read it as:  \(x : Int) -> Bool
05:29:08 <t7> im getting mixed up with arrows and abstraction :D
05:29:14 <mm_freak> yeah
05:29:35 <mm_freak> just remember that lambda and function arrow are unified, so every lambda is a function arrow and vice versa
05:29:40 <t7> god this is gonna get confusing
05:29:46 <mm_freak> the type system makes sure this is consistent
05:31:21 <mm_freak> ok, with the help of agda i have found the type of S
05:31:22 <t7> mm_freak: im using names rather than de bruijn indexes for mine, what should i do with the bound name ?
05:31:23 <mm_freak> it is indeed scary
05:31:40 <mm_freak> s : {E : Set} → {A : E → Set} → {B : (e : E) → A e → Set} → ((e : E) → (x : A e) → B e x) → (g : (e : E) → A e) → (e : E) → B e (g e)
05:31:51 <mm_freak> welcome to the wonderful world of dependent types =)
05:31:59 <t7> i mean after type checking
05:32:13 <mm_freak> t7: what exactly do you mean?
05:32:32 <t7> \ x : Bool -> x  :   \ x : Bool -> Bool
05:32:39 <t7> is that gonna mess things up
05:33:01 <mm_freak> t7: add a few parentheses to make this clearer
05:33:10 <mm_freak> \(x : Bool) -> x : (x : Bool) -> Bool
05:33:31 <t7> \ (x : Bool) -> x    type checks to    \(x : Bool) -> Bool
05:33:44 <mm_freak> the values in types are only used when type checking…  in other words your type checker needs to be able to reduce terms to normal form
05:33:46 <t7> ah hang on
05:34:06 <mm_freak> in this particular case the x is ignored
05:34:12 <mysticc> mm_freak: How did you type → ?
05:34:21 <mm_freak> mysticc: i copied it from my editor
05:34:46 <t7> so i guess i should have Expr = Abs (Maybe Name) Type Expr
05:34:53 <mm_freak> i thought the type of the composition operator is scary
05:34:59 <mm_freak> S beats it any day =)
05:35:48 <mm_freak> ok, just for fun i'm going to find the type of K, and then i will give up and go back to my beloved lambdas =)
05:36:06 <t7> its funny what we find fun, isnt it.
05:36:54 <mm_freak> hehe
05:37:55 <mm_freak> ok, i don't see any value in making the type of K's second argument dependent on the value of its first, so i'll try it the other way around
05:38:10 <ment> damn, i spent two hours writing a custom data parser before i figured out i can just "deriving (Read)" ...
05:38:40 <t7> haha
05:38:45 <mm_freak> and that's not possible of course…
05:40:09 <t7> mm_freak: can yours type "Nat" -> "Nat"
05:40:30 <mm_freak> t7: i don't understand the question
05:40:53 <t7> i think that should have the type Set or Typ or whatever?
05:41:03 <t7> but yours allways returns a :->
05:41:03 <mm_freak> for "Nat" :-> "Nat" it will infer "Nat" :-> Typ
05:41:15 <mm_freak> or it should
05:41:42 <mm_freak> correct would be "Nat" -> Typ 1, but i have only one universe
05:42:01 <t7> shouldnt it just be Typ 1?
05:42:14 <mm_freak> no, it's a function
05:42:15 <t7> Int -> Int has the kind *
05:42:30 <t7> not Int -> *
05:42:39 <mm_freak> \(x : Nat) -> Nat takes a natural number, ignores it and returns the type Nat
05:43:13 <mm_freak> so it has type Nat -> Set, actually
05:43:30 <mm_freak> i think…
05:43:39 <t7> hmm that seems to go against everything i know
05:44:10 <mm_freak> yeah, agda confirmed it
05:44:22 <mm_freak> test : ℕ → Set
05:44:22 <mm_freak> test = \x → ℕ
05:45:36 <mm_freak> t7: note that Nat -> Nat is a function…  (Nat -> Nat) x : Set
05:45:44 <mm_freak> it ignores whatever x you pass it
05:45:48 <mm_freak> and returns Nat
05:46:19 <mm_freak> note that the notation is T -> X, where T is the /type/ of the argument, not the argument itself
05:46:25 <mm_freak> and X is the type of the result
05:47:13 <t7> \x : Bool -> True    has the type  Bool -> Bool  which  has the type   Bool -> Set
05:47:20 <t7> aha
05:47:22 <t7> ahahaha
05:47:25 <MaskRay> How to convert a ByteString (in encoding A) to encoding B ?
05:48:05 <mm_freak> MaskRay: there is an iconv binding on hackage
05:49:09 <mm_freak> MaskRay: the preferred way is not to let the wrong encoding come up in the first place by using the encoding-agnostic text library
05:50:37 * hackagebot signed-multiset 0.3 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.3 (StefanHoldermans)
05:51:25 <MaskRay> mm_freak: the ByteString is originally generated by Network.HTTP.Conduit, but i do not know how to make it handle the charset
05:53:21 <mm_freak> MaskRay: the http-conduit library doesn't deal with the body itself, only with its transfer
05:53:49 <mm_freak> unless you use a higher level library you have to make sure that you request the correct encoding and convert if the server fails to provide it
05:56:39 <peterlenson> Is there any way to more specifically type integers. I only want my function called with 0 or positive integers. Can I use the type system to do that?
05:57:30 <bitonic> peterlenson: not using the existing Integer type.
05:57:47 <MaskRay> Many thanks. I'll look into these libraries
05:58:00 <bitonic> the common solution is to declare a newtype, e.g. 'newtype Natural = Natural Integer', and then define smart constructors to check that the number is > 0
05:58:12 <bitonic> peterlenson: and define the other operations accordingly
05:58:16 <ehamberg> you could look at the natural-numbers package on hackage.
05:59:11 <peterlenson> thanks
06:00:06 <bitonic> peterlenson: btw, you can express in more powerful type systems. It's interesting that "How do I subtype Integer" is by far the most common question with a dependent types solution, at least here.
06:01:07 <mm_freak> another way to ensure this is taking the value of the number along with the type
06:01:32 <mm_freak> newtype TInt n = TInt Integer
06:02:33 <mm_freak> add :: TInt x -> TInt y -> TInt (x :+: y)
06:02:48 <jeff_s_> Quick question, if a data type is declared something like "data X = X !A !B ... !Z", and I declare "instance NFData X", do I have to evaluate each field of X with rnf, or does ! take care of the strictness?
06:03:05 <jeff_s_> OK, maybe not so quick, but a question regardless!
06:03:12 <mm_freak> jeff_s_: you have to evaluate
06:03:22 <jeff_s_> mm_freak - ok thanks!
06:03:25 <bitonic> mm_freak: how does that improve the smart constructors solution?
06:03:28 <mm_freak> jeff_s_: strict fields force weak-head normal form, not normal form
06:03:38 <jeff_s_> ah I see, so ! is like seq.
06:03:56 <mm_freak> bitonic: it allows general integers, but for certain functions you can request, for example, nonnegative numbers
06:04:22 <bitonic> mm_freak: but that is true in general, it doesn't help in restricting Integers to naturals
06:04:24 <mm_freak> bitonic: you can even request fancier things like:  quadratic numbers, or numbers with a certain remainder modulo some other number
06:05:39 * hackagebot yesod-test 0.2.0.5 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.5 (MichaelSnoyman)
06:05:41 * hackagebot xml2html 0.1.2.2 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.2.2 (MichaelSnoyman)
06:35:52 <mysticc> I read about cas added to ghc .. but cant find about it on ghc manual .. where to read about it ?
06:37:58 <Ptival> cas?
06:40:39 <hpc> compile-and-segfault
06:40:43 <hpc> gcc has had that feature for years
06:41:14 <Botje> or maybe compare and swap.
06:41:33 <hpc> that sounds more likely
06:41:37 <Ptival> indeed
06:42:48 <Botje> mysticc: in that case, http://hackage.haskell.org/packages/archive/IORefCAS/0.1.0.1/doc/html/Data-CAS.html looks relevant.
06:44:04 <hpc> one would think CAS is made obsolete by all the other threading primitives GHC has
06:44:25 <Botje> there's always people who want to write C in haskell
06:44:29 <quicksilver> it might help if mysticc explained what he was reading :)
06:45:00 <hpc> i just wish i could write haskell in C
06:45:03 <quicksilver> certainly CAS is a vital part of how the RTS implements some of those threading primitives.
06:45:08 <hpc> even just forkIO would be wonderful
06:45:20 <t7> hp laptops come with so much shit
06:46:01 <bitonic> t7: -blah
06:46:02 <hpaste_> LambdaDusk pasted “Cabal install errors” at http://hpaste.org/67590
06:46:13 <LambdaDusk> anyone can help me with the error in the above?
06:46:28 <LambdaDusk> I have seen it often and I need to know how to deal with it
06:46:30 <JesusIsLord> LambdaDusk: any particular reason you want to reinstall cabal-install ?
06:46:41 <quicksilver> LambdaDusk: you can't install that version of cabal-install on that version of GHC, basically.
06:46:44 <LambdaDusk> update, rather
06:46:58 <JesusIsLord> this particular reason means that the GHC version is not compatible (the "base" package version is tied to GHC)
06:47:03 <byorgey> you need to say cabal install cabal-install-0.14.0  if you want the latest version
06:47:05 <JesusIsLord> message*
06:47:11 <LambdaDusk> because of this error: $ cabal install --only-dependencies --constraint "ixset < 1.0.3"
06:47:11 <LambdaDusk> Resolving dependencies...
06:47:11 <LambdaDusk> cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"
06:47:16 <byorgey> cabal-install-0.10.2 is marked as the "preferred" version on Hackage
06:47:36 <LambdaDusk> I have deleted all the .cabal and .ghc files and I can't get rid if that ixset error
06:47:39 <merijn> hpc: Sounds like you want Go? *ducks and runs*
06:47:45 <byorgey> oh, wait, you have an older version of GHC
06:47:58 <JesusIsLord> really? base-4.5.0.0 must be pretty new
06:48:05 <byorgey> oh, no, sorry, I was misreading it
06:48:09 <hpc> merijn: lol
06:48:15 <quicksilver> reinstalling cabal-install won't solve your ixset.cabal problem
06:48:15 <byorgey> I was right the first time =)
06:48:23 <LambdaDusk> then what can I do?
06:48:25 <JesusIsLord> yeah it's 7.4.1 :)
06:48:26 <LambdaDusk> I need that package
06:48:58 <merijn> hpc: At least you get forkIO and some reasonably sensible polymorphism...
06:48:59 <JesusIsLord> LambdaDusk: which package? cabal-install version 0.14.0 ?
06:49:04 <LambdaDusk> ixset
06:49:13 <JesusIsLord> merijn: polymorphism? in Go ?
06:49:28 <LambdaDusk> but every time I try to touch it, I get "cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal""
06:49:34 <merijn> JesusIsLord: Yes.
06:49:39 <LambdaDusk> I don't even try to install version 1.0.3
06:49:45 <JesusIsLord> LambdaDusk: did you try "cabal update" ?
06:49:51 <LambdaDusk> and I have deleted all the .cabal files
06:49:53 <LambdaDusk> yes, twice
06:50:12 <merijn> JesusIsLord: What would you call interfaces if not polymorphic?
06:50:35 <JesusIsLord> so if i read your command correctly, you want version 1.0.2 and not the latest version? let me try to install this, then
06:50:47 <byorgey> LambdaDusk: can you do whatever you are trying to do, but pass -v3 to cabal and then paste the output on hpaste.org?
06:50:53 <JesusIsLord> merijn: oh i was taking a jab at the parametric polymorphism in Go
06:51:00 <JesusIsLord> or the lack thereof
06:51:36 <JesusIsLord> LambdaDusk: cabal install ixset==1.0.2 works for me (GNU/Linux; GHC 7.4.1)
06:52:02 <merijn> JesusIsLord: It's still a more convenient than C (which the base line in the discussion) and (as I said) reasonably sensible
06:52:16 <hpaste_> LambdaDusk pasted “Verbose cabal error” at http://hpaste.org/67591
06:53:29 <LambdaDusk> JesusIsLord: Nope, that fails too. It's always ixset 1.0.3, even when I explicitely deman ixset 1.0.2
06:53:45 <LambdaDusk> byorgey: pasted, as you could see
06:54:55 <quicksilver> as far as I can it's not complaining about what you're asking it to do
06:55:00 <quicksilver> it's not even getting that far
06:55:10 <quicksilver> it's complaining that its files on disk are in a tangle?
06:55:33 <LambdaDusk> but I removed them all =/
06:55:45 <LambdaDusk> unless cabal uses more folders than .cabal and .ghc
06:56:26 <JesusIsLord> did you try "cabal install ixset==1.0.2" while standing in a different working directory?
06:56:47 <LambdaDusk> JesusIsLord: Yep, same result
06:56:52 <byorgey> LambdaDusk: whta is in the directory where you are calling cabal?
06:56:58 <kallisti> I think we as a community are too ready to nuke each others .cabal directories. :P
06:57:17 <JesusIsLord> kallisti: i did this a few times, but i think things have been getting better :)
06:57:29 <byorgey> it seems to be complaining about not being able to read a file in the current directory
06:57:32 <LambdaDusk> byorgey: my project, freshly cloned: https://github.com/scan/ponyfolder-yesod
07:01:18 <kallisti> I managed to get cabal into an unstable state once
07:01:26 <kallisti> and the recommendation from #haskell was to reinstall everything
07:01:32 <kallisti> but after some tinkering around I managed to fix it.
07:01:46 <bitonic> yeah! rm -rf ~/.ghc ; rm -rf ~/.cabal.
07:01:48 <quicksilver> kallisti: the problem is that there aren't many people who understand how to give correct advice.
07:02:15 <quicksilver> if dcoutts_ and Saizan aren't awake, nobody else seems able to untangle cabal issues as a rule ;)
07:02:29 <quicksilver> I know that I can't help with any but the simplest problems with it.
07:02:33 * gienah_ doesn't know what causes that ixset 1.0.3 error, I have seen it, but I avoid it using runhaskell ./Setup.hs configure; one thing that is wrong with ixset-1.0.3.tar.gz is it is missing the tests referenced in the Test-Suite, I copy the missing tests so not sure if that fixes it or not
07:02:47 <bitonic> Saizan is a great untangler of any kind of issue.
07:04:20 * LambdaDusk tries what gienah_ purposed
07:04:37 <t7> mm_freak: why do you need applyLam? why not just return ty?
07:04:38 <gienah_> the gentoo ebuild that copies the missing tests, the missing tests are in the files subdir: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/ixset
07:04:55 <LambdaDusk> strangely it all worked fine on my laptop
07:05:05 <mm_freak> t7: applyLam performs deep application
07:05:29 <t7> ah substitution?
07:05:36 <mm_freak> \(\(0 1)) x = \(0 x)
07:05:41 <mm_freak> that's what applyLam does
07:05:48 <t7> :|
07:05:57 <dcoutts> LambdaDusk: what does cabal --version say?
07:06:19 <LambdaDusk>  dcoutts:  cabal --version
07:06:19 <LambdaDusk> cabal-install version 0.10.2
07:06:19 <LambdaDusk> using version 1.10.2.0 of the Cabal library
07:06:22 <dcoutts> the issue is that there's a file in the hackage index that your version of cabal cannot read
07:06:43 <dcoutts> we try to prevent this with upload checks, but there's one sneaking through
07:07:32 <dcoutts> a workaround is to use the latest cabal version
07:07:49 <dcoutts> but I should probably go hack it in the hackage index directly...
07:07:55 <LambdaDusk> which won't install because of that base stuff ^^
07:08:09 <JesusIsLord> LambdaDusk: you need the explicit version
07:08:11 <quicksilver> dcoutts: so cabal 1.10.2.0 is currently unusable with hackage? because it will always get upset by this file even if you download something else? Or is it only stuff which has ixset in its dependency graph?
07:08:25 <dcoutts> quicksilver: if it's in the transitive closure
07:08:30 * quicksilver nods
07:08:33 <jeff_s_> Excellent! I believe I finished converting Aeson to use Data.Decimal rather than the bizarre Attoparsec Number.
07:08:54 <LambdaDusk> jeff_s_: Strangely I find that great news
07:09:05 <dcoutts> LambdaDusk: it will install for older ghc versions
07:09:17 <jeff_s_> I'm going to make a pull request, then we'll see what happens.
07:09:22 <elliott> jeff_s_: hmm, why not Rational?
07:09:30 <LambdaDusk> dcoutts: But not for my 7.4.1
07:09:55 <kallisti> jeff_s_: what's bizzare about it?
07:10:02 <kosmikus> LambdaDusk: it works for 7.4.1. "cabal install cabal-install-0.14.0"
07:10:18 <jeff_s_> kallisti - mostly I don't like that it's limited to Double.
07:10:25 <kallisti> ah
07:10:44 <elliott> Rational would avoid a dependency and should be able to represent as much afaict
07:10:44 <kallisti> could ust BigFloat
07:10:52 <jeff_s_> elliott - I started using Rational, but I decided I didn't like it for some reason. Let me see if I can retrace my steps.
07:11:31 * kallisti wonders how quickly a decimal literal can be converted to a Rational compared to a BigFloat.
07:11:50 <t7> dependant types are a real mind fuck
07:12:04 <t7> my brain doesnt have enough ram to work out if im getting this right
07:12:20 <kallisti> jeff_s_: there's always CReal. :D
07:13:08 <elliott> Prelude Numeric> readFloat "3.14" :: [(Rational,String)]
07:13:08 <elliott> [(157 % 50,"")]
07:13:10 <kallisti> oh I misunderstood the purpose of BigFloat. I thought it was arbitrary precision.
07:13:10 <elliott> kallisti: ^
07:13:15 <kallisti> elliott: ah. /that/ fast.
07:13:29 <elliott> but aeson is using ByteString
07:13:30 <elliott> so
07:13:33 <elliott> it probably rolls its own anyway
07:13:49 <kallisti> it uses Attoparsec.Number
07:14:02 <hpaste_> t7 pasted “fml” at http://hpaste.org/67592
07:14:24 <t7> mm_freak: could you check line 57 if you get a min
07:15:03 * kallisti would like to see some benchmarks on Rational vs. Decimal vs. Double conversion.
07:15:17 <kallisti> I suspect Decimal is quick to convert, but then actually slower to use.
07:16:35 <mysticc> what is a state thread at strefs ?
07:16:40 <kallisti> oh look I'm completely wrong. Decimal is a floating point representation.
07:17:09 <quicksilver> it's a funny name.
07:17:11 <jeff_s_> elliott - My decision to use Decimal might have been as simple as it being easier to create than Rational.
07:17:14 <tromp> 15^3
07:17:17 <tromp> > 15^3
07:17:17 <jeff_s_> Otherwise, I don't remember.
07:17:18 <lambdabot>   3375
07:17:23 <elliott> jeff_s_: see above with readFloat, then :p
07:17:28 <kallisti> easier to create in what sense?
07:17:30 <quicksilver> > (3.12 :: Rational)
07:17:32 <lambdabot>   78 % 25
07:17:36 <mysticc> > 15^(15^15)
07:17:38 <mm_freak> t7: why is your abstraction identifier a Maybe?
07:17:41 <quicksilver> jeff_s_: ^^ how hard are Rationals to create, exactly?
07:17:41 <lambdabot>   mueval: ExitFailure 1
07:17:41 <lambdabot>  mueval: Prelude.undefined
07:18:03 <t7> mm_freak: because Arrows often dont have labels
07:18:20 <tromp> > 5*4050000
07:18:22 <jeff_s_> They're not, but they were when I was getting ready to sleep. :)
07:18:22 <mm_freak> t7: i just use _ for that
07:18:23 <lambdabot>   20250000
07:18:37 <mysticc> What are STRef used for ?
07:18:38 <mm_freak> t7: i'd still introduce an identifier everywhere, otherwise your code is going to be complicated
07:18:46 <mm_freak> t7: other than that it looks correct to me
07:18:50 <quicksilver> mysticc: mutable variables.
07:18:54 <jeff_s_> One thing that Decimal can do that is not obvious to me with rational, is printing.
07:18:58 <quicksilver> jeff_s_: :)
07:19:02 <mysticc> quicksilver: IOrefs ?
07:19:02 <t7> does that sub on line 57 make sense?
07:19:09 <mm_freak> t7: yes
07:19:17 <quicksilver> > showFFloat (Just 4) (3.5 :: Rational) ""
07:19:18 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
07:19:18 <lambdabot>    arising from a u...
07:19:23 <mm_freak> t7: wait
07:19:24 <quicksilver> interesting.
07:19:34 <mm_freak> t7: no, actually it doesn't
07:19:41 <jeff_s_> I'm parsing JSON, and there's no case where JSON can produce 1 % 3. Decimal lines up better with the numbers I get from JSON.
07:19:55 <kallisti> jeff_s_: that's a pretty weak argument.
07:20:01 <kallisti> % is just a constructor function
07:20:12 <kallisti> the textual representation compared to that isn't important.
07:20:15 <elliott> jeff_s_: that's only if you use read...
07:20:23 <elliott> erm, sho
07:20:23 <elliott> w
07:20:26 <elliott> if you use the functions in Numeric it's fine
07:20:37 <mm_freak> t7: when you have f x and f is of type (a : A) -> B a, then assuming everything is type-correct, the type of f x is B x
07:20:43 * hackagebot yesod 1.0.1.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.4 (MichaelSnoyman)
07:20:45 * hackagebot yesod-platform 1.0.3.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.3.2 (MichaelSnoyman)
07:21:05 <mm_freak> t7: so you need to substitute i by the /value/ e2
07:21:05 <quicksilver> it does seem to be true that the standard library doesn't have a way to print Rationals into decimal-formatted strings
07:21:12 <quicksilver> at least if it does, I don't see it
07:21:24 <mm_freak> t7: i recommend using clearer names for your variables, because it can be easy to get lost in your own code when writing a type checker
07:21:30 <mm_freak> Ap f x -> …
07:21:49 <quicksilver> which seems a bit sad :)
07:22:31 <kallisti> Decimal is probably a good choice here, honestly. Despite the required dependency.
07:23:10 <kallisti> it's trivial to convert a decimal literal to a Decimal.
07:23:43 <quicksilver> well that's true of Rational, too
07:24:06 * kallisti isn't actually sure how to do that.
07:24:51 <quicksilver> > readFloat "1.2345" :: [(Rational,String)]
07:24:52 <lambdabot>   [(2469 % 2000,"")]
07:25:06 <quicksilver> or, in a haskell source file, simply
07:25:10 <quicksilver> > 1.2345 :: Rational
07:25:11 <lambdabot>   2469 % 2000
07:25:17 <quicksilver> obviously not quite the same thing.
07:25:21 <kallisti> right, but in the context of Attoparsec.
07:25:31 <kallisti> I don't think readFloat would be the best way?
07:25:33 <kallisti> maybe it is.
07:25:35 <merijn> @hoogle (Eq a) => [(a,b)] -> a -> b -> [(a, b)]
07:25:35 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
07:25:35 <lambdabot> Data.Graph.Inductive.NodeMap insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
07:25:36 <lambdabot> Data.Graph.Inductive.NodeMap delMapNodes :: (Ord a, DynGraph g) => NodeMap a -> [a] -> g a b -> g a b
07:25:50 <kallisti> I'm saying I don't actually know how to do what readFloat does.
07:26:20 <quicksilver> split at the dot and divide by 10^ the length of the part after the dot?
07:26:21 <merijn> Is there an update/remove variant of Data.List.lookup or do I have to write one myself?
07:26:22 <elliott> If it's doing ByteStrings then it'll be hand-rolling a parser anyway
07:26:32 <MaskRay> How to handle URI?
07:27:08 <kallisti> > 12345%1000
07:27:09 <lambdabot>   2469 % 200
07:27:14 <kallisti> > 12345%10000
07:27:15 <lambdabot>   2469 % 2000
07:27:18 <kallisti> unless it just does that. :P
07:28:12 <yitz> @type delete -- merijn: but for update, i think you have to write it yourself
07:28:13 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
07:28:36 <mysticc> quicksilver: Why do we use STRef .. Isn't IORefs are for that purpose ..
07:29:15 <quicksilver> mysticc: STRefs can be  used in pure code
07:29:28 <quicksilver> well that's true of IORefs too, for a weak meaning of 'used'
07:29:42 <quicksilver> but what I really mean is "ST computations (which read and write STRefs) can be run from pure code)
07:29:42 <mysticc> quicksilver: So what are atomicmodify for ?
07:29:47 <kallisti> the result of algorithms that use STRefs can be computed in pure code.
07:29:48 <bitonic> mysticc: STRef are to be used in the ST monad, which allows you to have mutable references only
07:29:58 <bitonic> mysticc: keeping out all the other side effects
07:30:13 <quicksilver> mysticc: I don't know what you mean by 'atomicmodify' but I think you're mixing levels of abstraction.
07:30:25 <quicksilver> atomicModifyIORef is for IO code running in multiple threads?
07:30:37 <quicksilver> STRef is for mutable data algorithms running purely
07:30:42 <quicksilver> threads don't come into ST
07:31:01 <bitonic> mysticc: btw, since ST is less side-effectfull than IO, every ST action can be used as an IO action
07:31:08 <augur> edsko: are you edsko de vries?
07:31:14 <bitonic> @type stToIO
07:31:16 <lambdabot> Not in scope: `stToIO'
07:31:25 <bitonic> @hoogle sttoio
07:31:25 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
07:31:25 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
07:31:25 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
07:31:38 <t7> stToIO = lift
07:31:46 <bitonic> t7: no?
07:31:55 <edsko> augur: yes?
07:32:01 <mysticc> bitonic: quicksilver : I meant what is this for http://hackage.haskell.org/packages/archive/IORefCAS/0.1.0.1/doc/html/Data-CAS.html#v:casSTRef
07:32:03 <augur> edsko: :O
07:32:05 <augur> awesome
07:32:27 <mysticc> casstref ?
07:32:28 * kallisti wonders why Decimal uses only a Word8 for decimalPlaces.
07:32:30 <edsko> augur: ?
07:32:53 <mysticc> augur: ??
07:33:12 <sp3ctum> it would be really funny if the conversation just ended now
07:33:32 <quicksilver> mysticc: don't see the point of that since STRefs can't be used in threaded code
07:33:35 <augur> edsko: your catsters index is great. <3
07:33:36 <quicksilver> maybe I miss something
07:33:58 <edsko> augur: hehe :) glad you like it
07:34:00 <quicksilver> > let num = "1234.5678"; (whole,('.':frac)) = break (=='.') num; scale = 10^(genericLength frac) in (fromInteger ((read whole)*scale+(read frac)) / (fromInteger scale) :: Rational)
07:34:01 <lambdabot>   6172839 % 5000
07:34:11 <mysticc> quicksilver: I meant what is use of atomic here ... How to have state run across several threads ?
07:34:11 <quicksilver> kallisti: ^^ boring but utterly trivial.
07:34:26 <quicksilver> mysticc: I don't think you can, with ST, therefore I don't see the point.
07:34:35 <quicksilver> I'm probably missing something.
07:36:06 <mysticc> quicksilver: Isnt that like having a side effect inside st monad ?
07:39:21 <t7> how do i unpack a cabal package again?
07:39:27 <t7> i forget the command
07:39:30 <JesusIsLord> cabal unpack
07:39:58 <t7> ah ;)
07:40:03 <t7> dir
07:40:12 <kallisti> ewwwww windows
07:40:17 * kallisti vomits.
07:40:22 <t7> im at work
07:40:28 <kallisti> you're dealing with a sensitive crowd here.
07:40:40 <wferi> Hi! ghci refuses the string "\?x" with lexical error in string/character literal at character 'x'. why?
07:40:52 <JesusIsLord> wferi: \ is an escape character
07:40:56 <Gracenotes> some of these people have been forcedo tu se windows *their whole lives*
07:40:57 <JesusIsLord> if you want to input a \, use \\
07:41:08 <Gracenotes> ...that was quite a permutation
07:41:30 <JesusIsLord> it sounds Spanish :)
07:41:39 <merijn> kallisti: Keep in mind that SPJ (at least, and probably some others) develop GHC solely on windows
07:41:48 <parcs`> is that really true
07:42:04 <parcs`> because windows support sucks
07:42:05 <kallisti> marienz: ah, my lord and master SPJ, you say?
07:42:08 * kallisti changes his ways.
07:42:09 <bitonic> merijn: I'm not sure that's how it goes. they're definitely paid by windows
07:42:11 <mm_freak> well, SPJ works for microsoft
07:42:16 <bitonic> *by microsoft
07:42:18 <merijn> parcs`: I saw an SPJ talk where he referred to xmonad and his general cluelessness about X11 and window managers
07:42:19 <elliott> "paid by windows"
07:42:27 <elliott> bitonic: microsoft research, no?
07:42:29 <merijn> This leads me to believe he is at least not a linux dev
07:42:29 <parcs`> ghci on windows randomly crashes with an unreachable mvar exception
07:42:29 <elliott> not really the same thing
07:42:37 <bitonic> elliott: the money comes from microsoft
07:42:39 <singpolyma> I have a data that is a bunch of record alternations:   data A = A {blah::Int} | B {blah::Int}   etc  I want to make a single data constructor opaque and leave the rest transparent.  Doable?
07:42:46 <quicksilver> he was an academice who worked on haskel before he moved to MSR
07:42:47 <marienz> that's one of the more confusing mistabs I've had recently
07:42:51 <merijn> bitonic: Paid by windows is a gross exaggeration. MSR is really unrelated to any product division
07:42:54 <parcs`> merijn: perhaps he is an ubuntu user ;)
07:42:56 <quicksilver> moving to MSR didn't particularly change him
07:43:00 <quicksilver> he just got a nicer office
07:43:03 <elliott> merijn: bitonic corrected to microsoft
07:43:07 <mm_freak> it's not bad that SPJ works on windows…  as long as he does, GHC will remain portable to at least windows =)
07:43:10 <kallisti> marienz: ha
07:43:55 <marienz> (esp. if you factor in I didn't know SPJ was a person until I read context)
07:43:57 <merijn> parcs`: Maybe, but considering his talk was powerpoint in windows and some other small things lead me to conclude he's not really a linux aficionado :p
07:44:01 <merijn> I could be wrong, though
07:45:34 <quicksilver> if you are very curious about SPJ's working environment he kindly provided some clues on his homepage : http://research.microsoft.com/en-us/um/people/simonpj/win32-cheat.html
07:45:44 * hackagebot ImperativeHaskell 0.2.0.1 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-0.2.0.1 (MatthewMirman)
07:45:44 <mm_freak> this is really weird
07:45:53 <mm_freak> the more powerful i make my type system, the simpler the implementation gets
07:45:53 <elliott> is that underlining hackagebot is doing new?
07:45:58 <t7> "Make your caps-lock key into a duplicate of Ctrl" all of my why
07:45:58 <MaskRay> Is it possible to use ContT inside ResourceT ?
07:46:07 <bitonic> quicksilver: that looks old
07:46:11 <quicksilver> it is old, yes
07:46:20 <elliott> MaskRay: continuations interact badly with resource finalisation like that
07:46:35 <elliott> MaskRay: it might be possible, but it's probably a bad idea, at least if you use it on the wrong side
07:46:35 <merijn> t7: Because that is the traditional position of the caps lock key? Also, so you can use Caps+[ for esc in vim
07:46:43 <mm_freak> now i added universe polymorphism and suddenly what used to be "Typ :: Int -> Expr" is now just "Typ :: Expr"
07:47:15 <mm_freak> Set : (n : Nat) -> Set (n + 1)
07:47:22 <elliott> merijn: *control key, rather
07:47:23 <augur> anyone know of alternatives to quantifiers as varying variable bindings?
07:47:33 <kallisti> "Make the printer staple by default"  0_o
07:47:42 <kallisti> where do you get the fancy printer staplers.
07:47:45 <merijn> elliott: That was my point, if you remap caps to control
07:48:00 <t7> kallisti: all of our copiers do folding and stapling :)
07:48:02 <MaskRay> And the ContT implementation is still abstruse to me
07:48:21 <kallisti> t7: can they make coffee and do my laundry as well?
07:48:40 <t7> no but they print booklets in their sleep
07:48:52 <copumpkin> elliott: if you go surfing, will we call it the elliott wave?
07:48:53 <lambdabot> copumpkin: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:48:57 <parcs`> fancy
07:49:00 <mm_freak> elliott: there is nothing wrong with ContT over ResourceT…  unless you lift the regions to ContT you can't do any damage
07:49:07 <mm_freak> and i doubt that you can lift them
07:49:19 <elliott> mm_freak: right, it's ResourceT over ContT that would be the problem, I think
07:49:23 <mm_freak> yeah
07:49:34 <elliott> in fact ResourceT may even require MonadControl
07:49:38 <elliott> in which case you couldn't use it over ContT
07:49:40 <elliott> oh, wait, no
07:49:43 <elliott> then it'd have no MonadTrans
07:49:45 <kallisti> elliott: is MonadBaseControl IO ContT  possible? I noticed there was no instance for it.
07:49:53 <elliott> ContT cannot be MonadControl
07:50:15 <mm_freak> it is believed that ContT cannot be MonadControl for similar reasons as for MonadFix
07:50:24 <mm_freak> (MonadFix is possible, but it's hacky)
07:50:42 <elliott> well, it's not clear how continuations should interact with resource finalisation
07:50:47 <elliott> either you get finalisers running twice, or you leak resources
07:51:04 <elliott> it's a very old problem in the lisp community
07:51:17 <elliott> see, e.g. http://www.nhplace.com/kent/PFAQ/unwind-protect-vs-continuations-original.html
07:51:20 <mm_freak> yeah…  nobody has found a sane solution so far
07:51:24 <phryk> I have ghc-7.4.1 and cabal-install-0.13.3. However ghc doesn't look into ~/.cabal/lib for libraries…
07:51:27 <mm_freak> but it might be possible
07:51:34 <phryk> How do I get it to look in there as well?
07:51:43 <mm_freak> phryk: you have to install the package through cabal
07:51:52 <elliott> mm_freak: I think it's something that continuations inherently stop you solving
07:51:53 <phryk> mm_freak: Which package?
07:51:59 <elliott> and that if you want resource finalisation, you want something weaker than continuations
07:52:02 <elliott> e.g. one-shot continuations
07:52:06 <mm_freak> phryk: then it gets registered (see ghc-pkg)
07:52:13 <mm_freak> phryk: GHC by itself doesn't know anything about ~/.cabal
07:52:16 <phryk> mm_freak: It does not, that is my problem.
07:52:35 <mm_freak> phryk: you can register the package manually using the ghc-pkg tool
07:53:03 <phryk> I installed yesod with cabal install, I get the yesod binary and can start a whole yesod project just fine with 'yesod devel', but when I try to use yesod directly, I only get module not found…
07:53:29 <mm_freak> phryk: that's weird
07:53:36 <MaskRay> How much does ContT resembles delimited continuation (one implementation is the shift/reset operators)
07:53:38 <phryk> mm_freak: Isn't there something like a 'libpath' where I can just append ~/.cabal/lib/ ?
07:53:45 <mm_freak> phryk: ask on the yesod mailing list, where all the yesod devs hang out
07:53:56 <phryk> mm_freak: it's not yesod specific.
07:54:06 <mm_freak> phryk: there is…  you can find the corresponding option in the GHC manual, but it's really just a workaround
07:54:10 <phryk> mm_freak: all packages installed with cabal install aren't being found by ghc
07:54:40 <mm_freak> MaskRay: ContT /is/ delimited CPS
07:55:01 <mm_freak> MaskRay: the delimiter is runContT
07:55:03 <MaskRay> As the callcc doesn't seem to share many similarities with Scheme's call-cc
07:55:21 <mm_freak> MaskRay: functionally it's exactly the same as scheme's call/cc
07:55:22 <EvanR> > mappend () ()
07:55:23 <lambdabot>   ()
07:55:33 <mm_freak> MaskRay: the difference is that callCC from MonadCont has a type
07:55:37 <elliott> MaskRay: runContT is shift, and something else is reset
07:55:39 <elliott> I forget whcih :)
07:55:41 <elliott> *which
07:55:41 <phryk> mm_freak: I'll look into it, just got notice that  i gotta go. be back in ~40 min or so
07:55:45 <elliott> erm
07:55:50 <mm_freak> phryk: good luck
07:55:50 <elliott> I might have that backwards, w/e
07:56:03 <elliott> MaskRay: indeed oleg often defines the two in terms of ContT to use them
07:56:18 <elliott> see e.g. http://okmij.org/ftp/continuations/zipper.html#traversable
07:56:31 <elliott> or rather the bottom of http://okmij.org/ftp/Haskell/ZipperTraversable.hs
07:56:33 <mm_freak> what is "shift" and "reset"?
07:56:40 <elliott> reset m = runCont m id
07:56:44 <elliott> shift e = Cont (\k -> reset (e k))
07:56:52 <mm_freak> i see
07:56:55 <elliott> mm_freak: the standard delimited control operators
07:57:09 <elliott> see e.g. http://en.wikipedia.org/wiki/Delimited_continuation
07:57:32 <mm_freak> so shift enters the next "frame" and reset leaves it
07:57:48 <kallisti> shift resembles callCC to me.
07:58:17 <MaskRay> I'll take notes on all you said but at present I have to leave aside these unintelligible concepts ...
07:58:27 <EvanR> in blaze, MarkupM a has the a just so it can be a monad, and Markup = MarkupM () used with do syntax? or is there another reason
07:58:27 <elliott> mm_freak: well, you put reset around your delimited control stuff
07:58:35 <elliott> oh hmm
07:58:36 <MaskRay> Is there any good tutorials on MonadBase MonadControl ...
07:58:39 <elliott> no, you put shift around your delimited control stuff
07:58:42 <elliott> and then use reset to get out
07:58:46 <kallisti> MaskRay: not really
07:58:47 <elliott> yeah
07:58:57 <kallisti> MonadBase is just a generalized MonadIO
07:59:02 <kallisti> so learn that first if you don't know about it.
07:59:06 <mm_freak> elliott: that's a weird way to define reset
07:59:24 <mm_freak> ah no
07:59:28 <mm_freak> actually it isn't
07:59:48 <mm_freak> my brain is still in the CoC world, so i'm gonna go back there now =)
07:59:53 <kallisti> what is the difference between shift and callCC?
07:59:59 <mm_freak> kallisti: nothing
08:00:02 <kallisti> oh. good.
08:00:15 <mm_freak> well, the name =)
08:00:20 <kallisti> I was fairly sure it looked like the same thing.
08:00:21 <mm_freak> "shift" sounds less scary
08:00:36 <mm_freak> but wait a minute
08:01:08 <elliott> ok, you do
08:01:10 <mm_freak> callCC f = Cont (\k -> runCont (f k) k)
08:01:16 <mm_freak> no?
08:01:18 <elliott> reset ((+) <$> 2 <*> shift (\k -> k 4))
08:01:18 <elliott> or something
08:01:21 <mm_freak> @src callCC
08:01:21 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:01:23 <elliott> and that evaluates to 4
08:01:25 <mm_freak> @src callCC ContT
08:01:25 <lambdabot> Source not found. You untyped fool!
08:01:31 <elliott> @src ContT callCC
08:01:32 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
08:01:58 <mm_freak> so shift and callCC are indeed different
08:03:49 <kallisti> it looks like shift is a somewhat restricted form.
08:06:21 <jeff_s_> So I guess the next problem for using Rational with JSON is - how do I print values?
08:06:32 <jeff_s_> 1 % 3 doesn't convert without rounding.
08:06:56 <jeff_s_> I could choose an arbitrary point to round at, but then someone won't be happy with it.
08:07:04 <MaskRay> still haven't catch on callCC
08:07:19 <elliott> jeff_s_: well, you can choose a fixed number and use "..." after that fixed number
08:07:26 <elliott> it depends what purpose you want the printing for
08:07:31 <jeff_s_> elliott - that breaks the json spec
08:07:37 <elliott> oh
08:07:43 <elliott> you mean serialising
08:07:48 <jeff_s_> Yes, serializing to JSON.
08:08:10 <jeff_s_> Decimal doesn't have this problem (Neither does Data.Fixed.*)
08:08:22 <elliott> Data.Fixed.* is just picking an arbitrary point to round at
08:08:25 <elliott> hmm, can JSON really not represent 1/3?
08:08:26 <elliott> that's terrible
08:08:49 <elliott> you could take the precision as a parameter, I suppose
08:08:49 <ment> main.exe: Prelude.read: no parse
08:08:54 <ment> what the hell does that mean
08:08:59 <mysticc> Where I can see exact changes between ghc versions ?
08:09:22 <Jeanne-Kamikaze> it means the whatever thing you're parsing does not match the expected format
08:09:32 <Jeanne-Kamikaze> like trying to read 123asdy1d8gh as a number
08:09:34 <jeff_s_> So the numeric type for Aeson would become Int * Rational?
08:09:39 <jfischoff> ment: it is haskells super awesome error message for when read from the Read typeclass
08:09:46 <elliott> jeff_s_: huh?
08:09:48 <elliott> no.
08:09:55 <elliott> i mean you'd take it as a parameter to the serialisation process
08:09:56 <elliott> jeff_s_: anyway
08:09:58 <ment> ah! derived "read". got it
08:10:00 <elliott> jeff_s_: if you want to match JSON perfectly
08:10:03 <elliott> then Double is the correct thing
08:10:07 <elliott> because that's what javascript uses
08:10:13 <EvanR> attojson isnt building..
08:10:16 <jeff_s_> Double isn't the correct thing, since it doesn't meet the spec.
08:10:21 <elliott> and why it doesn't support 1/3 (because it just uses the decimal representation of the float)
08:10:28 <elliott> I do not believe the spec specifies how to interpret numbers at all
08:10:29 <EvanR> Module `Data.Attoparsec.Char8' does not export `many'
08:10:30 <elliott> just their syntax
08:10:32 <elliott> look at the JS implementation
08:10:36 <elliott> (s, plural)
08:10:45 <elliott> hell, look at the canonical (but unsafe) eval() implementation
08:11:40 <jeff_s_> JSON doesn't have to conform to what eval() will accept.
08:12:18 <elliott> eval() will accept huge decimals
08:12:21 <elliott> it'll just turn them into doubles, that's all
08:12:30 <kallisti> well, if both the serializer and parser is Haskell, then huge arbitrary decimals will convert correctly
08:12:40 <elliott> again, JSON doesn't really have any defined semantics, just syntax; for the semantics, you have to look at the original/canonical/reference implementations
08:13:20 <jeff_s_> I don't want the implementation to impose any semantics, really.
08:13:28 <kallisti> er..
08:13:35 <elliott> good luck with that
08:13:41 <elliott> if you don't want to impose any semantics, you just have a recogniser
08:13:44 <kallisti> you want the implementation to be a NOP?
08:13:47 <elliott> isJSON :: ByteString -> Bool
08:13:49 <kallisti> oh or that.
08:14:44 <elliott> anyway I guess if you want to parse every JSON syntax tree into a representation and do not want to equate any two jumbles of digits (except for leading 0s, scientific notation vs. no scientific notation and all the *other* things JSON equates), and want every value of your representation to have a corresponding JSON representation that loses no information, then Decimal is the right thing
08:14:59 <elliott> but that is probably a silly goal, since it differs from how everyone produces and accepts JSON
08:15:39 <jeff_s_> Then I'm silly.
08:16:29 <elliott> if you really don't want to "drop information"
08:16:35 <elliott> then you have to use a String to represent numbers
08:16:46 <elliott> because 00300 works in json too, as does 3e2 etc.
08:17:00 <elliott> (ooh, I bet "007" does something unexpected with eval())
08:17:01 <yitz> EvanR: i think many is in D.A.Combinator
08:17:23 <jeff_s_> I didn't think leading 0s were acceptable..
08:17:24 <yitz> EvanR: if not, then D.A itself. not in .Char8 in any case.
08:18:12 <EvanR> yitz: do i need to fork attojson and fix this in order to use it?
08:18:12 <singpolyma> Hmm... is there a way to export record-field deconstructor functions without also enabling the    val { field = stuff }   syntax ?
08:18:32 <mm_freak> 'many' is in Control.Applicative
08:18:48 <yitz> EvanR: ohh.. in attojson? weird.
08:18:51 <elliott> jeff_s_: oh, you're right. but 300 and 3e+2 are.
08:18:54 <yitz> mm_freak: ah, right
08:18:58 <elliott> as is 300.00000
08:19:08 <jeff_s_> elliott - I have those working for Decimal.
08:19:11 <EvanR> yitz: i get this error when trying to install attojson
08:19:18 <EvanR> Text/JSON/AttoJSON.hs:25:56:
08:19:19 <elliott> jeff_s_: you parse 300 and 3e+2 differently?
08:19:24 <EvanR> Module `Data.Attoparsec.Char8' does not export `many'
08:19:25 <elliott> that's nonsense
08:19:32 <jeff_s_> Er wait, one sec, I'm using my Rational branch... gotta switch
08:19:37 <bitonic> singpolyma: good question. I don't think that's possible.
08:19:43 <elliott> jeff_s_: if you parse them as 300, then that's my point
08:19:56 <elliott> jeff_s_: JSON has lots of number representations that mean the same thing
08:20:09 <singpolyma> bitonic: that's a bit of a pain
08:20:10 <jeff_s_> elliott - yup, I'm pretty sure I had all of them working.
08:20:25 <elliott> jeff_s_: yes, so you only equate a _subset_ of things everything else does
08:20:26 <bitonic> singpolyma: I've never been in your situation, but I can understand why you would want to do that
08:20:53 <rwbarton> a python (e.g.) implementation might not equate 300 and 300.00000
08:20:55 <elliott> jeff_s_: either parse every digit string differently (in which case you end up with String as your number representation), or do what the rest of the world does... there's no reason to go half-way
08:21:03 <bitonic> singpolyma: I'm not 100% sure, so you can still hope. Did you look at what the standard says?
08:21:05 <elliott> rwbarton: right, the current implementation uses Integer or Double
08:21:08 <singpolyma> bitonic: Yeah.  I have a smart constructor, but it's not very enforced if users can just "update" record fields without it
08:21:12 <elliott> because most languages have integers or doubles
08:21:23 <elliott> (admittedly, that leads to an edge-case where a JS impl can't process something that uses too large an integer)
08:21:27 <elliott> (but nothing's perfect)
08:21:56 <jeff_s_> How about for someone who's trying to pass financial information via JSON? Doesn't it make sense to use somethign like Decimal instead of Double, then? Even if it's unusual.
08:22:13 <elliott> jeff_s_: then they shouldn't be using JSON!
08:22:19 <elliott> because all their consumers will mangle the information by parsing it as Double
08:22:22 <elliott> actually, they can use JSON
08:22:25 <elliott> but they should use e.g. [3,14] for 3.14
08:22:39 <elliott> putting financial stuff in something that 90% of implementations will parse as a float
08:22:40 <quicksilver> can't they use "3.14" ?
08:22:41 <elliott> is a really dumb idea
08:22:43 <elliott> quicksilver: yes
08:22:50 <jeff_s_> quicksilver - that would have been my choice.
08:22:55 <elliott> (and that's a fine example of why a haskell implementation doing that would lead to bugs)
08:23:00 <singpolyma> bitonic: do you know what section of the standard that would be in?
08:23:09 <elliott> (because people would do it and it'd break once they use another language to parse their common, language-agnostic interchange data)
08:23:12 <EvanR> use Rational and it will accept and produce compatible stuff
08:23:13 * quicksilver isn't sure if JSON implementations squash strings to numbers.
08:23:22 <quicksilver> elliott: anyhow, I'm not sure I buy your argument.
08:23:25 <yitz> EvanR: an older version of attoparsec did export its own version of many, for inlining purposes. that was discontinued at some point
08:23:32 <EvanR> yitz: i see that
08:23:37 <EvanR> i dont see many in attoparsec
08:23:40 <elliott> EvanR: Rational doesn't work because you can't do 1/3
08:23:47 <quicksilver> elliott: if I'm designing a financial API, I may well have some control over my clients; I can specify what I produce and if they process it wrong, they have a bug.
08:23:50 <EvanR> you also cant se 1/3 in JSON
08:23:54 <EvanR> cant do
08:23:58 <bitonic> singpolyma: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15 ?
08:24:03 <elliott> quicksilver: yeah, so you're not using JSON any more
08:24:03 <quicksilver> elliott: I don't have to care about "90% of implementations" if I make it clear I don't support broken ones.
08:24:09 <elliott> that's not broken!
08:24:11 <elliott> it's what the original one does
08:24:13 <yitz> EvanR: it's there in version 0.8.0.0 of attoparsec for example
08:24:30 <quicksilver> elliott: "broken" for me :) anyhow I think you take my point.
08:24:35 <EvanR> yitz: can i download both old and new attoparsec with cabal...
08:24:38 <elliott> quicksilver: I don't, really, you can do that but you're not using JSON
08:24:42 <elliott> you're using FinancialJSON(tm)
08:24:46 <quicksilver> sure.
08:24:46 <kallisti> elliott: the original isn't broken, but supporting higher precision isn't broken either.
08:24:51 <quicksilver> and the world doesn't end.
08:25:02 <yitz> EvanR: the AttoJson package obviously hasn't been updated for a while. and its cabal file doesn't specifiy an upper limit on its attoparsec dependency, which is not recommended for this reason.
08:25:06 <elliott> quicksilver: yep. but that doesn't mean something calling itself a general-use JSON parser should do it
08:25:10 <elliott> because it'll lead to said silent breakage
08:25:15 <elliott> if you use a different format, use a different parser
08:25:15 <quicksilver> well yes, I agree there.
08:25:26 <elliott> quicksilver: and since this is about a change to aeson...
08:25:28 <EvanR> yitz: annoying because all the json libs are either too complicated or too not working
08:25:33 <quicksilver> now, do JSON parsers treat strings which look like numbers as numbers?
08:25:36 <elliott> no
08:25:44 <elliott> javascript is not _that_ badly typed
08:26:03 <quicksilver> OK, so then the pragmatic solution for applications is to use strings, for financial data
08:26:05 <EvanR> quicksilver: no way
08:26:11 <elliott> quicksilver: agreed
08:26:18 <elliott> or [beforedec,afterdec]
08:26:25 <rwbarton> {'dollars': 3, 'cents': 14}
08:26:25 <kallisti> elliott: certain /users/ of JSON definitely will accept numeric strings as numbers.
08:26:30 <quicksilver> and the solution for the libraries is 'it's fine if you use Double for floating point, as Real Work shouldn't use JSON floating point anyway"
08:26:36 <EvanR> elliott: fixed point
08:26:38 <elliott> certain users of JSON will only accept a single string and run it as ruby code
08:26:39 <kallisti> elliott: Selenium code, for example. ;)
08:26:40 <elliott> that doesn't mean json evals ruby
08:26:45 <elliott> EvanR: json does not have that
08:26:54 <EvanR> elliott: you can encode many things in json
08:27:00 <elliott> yes
08:27:06 <EvanR> it also doesnt have 'either' but you can encode it into a string
08:27:09 <elliott> and the way to encode fixed point in json is probably to use a string or an object or a list
08:27:12 <elliott> EvanR: duh
08:27:18 <elliott> quicksilver just said to encode it in a string, are you listening??
08:27:25 <EvanR> so you can encode a fixed point number into a json number
08:27:31 <EvanR> no array needed
08:27:33 <elliott> no you can't
08:27:38 <mm_freak> i'd say the type annotation operator ':' should be right-associative…  is that sensitive?
08:27:42 <elliott> well, you maybe can stuff it into a double
08:27:42 <quicksilver> rwbarton: well actually the standard for that is something like { "USD" : 314 }, because there is an ISO standard which says there is an implied exponent of 2.
08:27:44 <elliott> but it'd be nonsense
08:27:47 <mm_freak> so i can write value : type : kind : sort : …
08:27:56 <EvanR> elliott: 1234 instead of 12.34
08:28:11 <elliott> EvanR: uhhh you realise floats start to mess up once you go beyond 2^something?
08:28:11 * kallisti is a conforming JSON parser.
08:28:12 <rwbarton> that isn't "right-associativity"
08:28:13 <elliott> even purely integral
08:28:18 <rwbarton> however you should write that anyways
08:28:22 <quicksilver> rwbarton: then again, I wonder if that's unsafe because perhaps there are 32-bit JSON impls and you might want to transfer more than 20 million dollars.
08:28:33 <EvanR> elliott: you mean double
08:28:42 <EvanR> implementation will probably use double
08:28:45 <elliott> EvanR: doubles are floats
08:28:47 <elliott> floating-point numbers
08:28:56 <elliott> (they're not `float`s, though)
08:29:03 <EvanR> and the biggest integer consecutive double is really big
08:29:25 <singpolyma> bitonic: yeah, looks like it's not possible.  Oh well.  Thanks
08:31:29 <EvanR> the attojson dependencies are wrong, it should say attoparsec < something as well as > something
08:31:38 <bitonic> singpolyma: too bad. it would actually be useful.
08:31:51 <EvanR> might be easier than updating it to be compatible with new attoparsec
08:31:56 <yitz> EvanR: you don't like aeson?
08:32:16 <EvanR> yitz: aeson requires you to mess with attoparsec
08:32:18 <kallisti> jeff_s_: I would honestly prefer not to have a decimal dependency if I can avoid it.
08:32:21 <elliott> no it does not
08:32:29 <yitz> EvanR: no not if you don't want to.
08:33:32 <EvanR> yitz: how do you convert ByteString into Maybe Object or Array
08:33:38 <kallisti> I use jstring as a nice string parser in other code, but no the typical use case requires no attoparsec.
08:33:51 <t7> mm_freak: can you show me a way to make the type checker loop?
08:33:52 <yitz> EvanR: decode or decode'
08:33:57 <yitz> decode' is stricter
08:34:28 <EvanR> ok so js values are also FromJSON
08:34:37 <yitz> yes
08:34:55 <EvanR> is there a way to get parse errors
08:35:00 <EvanR> messages
08:35:07 <kallisti> yes. use fromJSON.
08:35:20 <gwern> '    Lazy evaluation is a distinctive feature of R that has the potential for reducing unnecessary work performed by a computation. Our corpus, however, does not bear this out. Fig. 14(a) shows the rate of promise evaluation across all of our data sets. The average rate is 90%. Fig. 14(b) shows that on average 80% of promises are evaluated in the ﬁrst function they are passed into.' http://lambda-the-ultimate.org/node/4507
08:35:21 <kallisti> that will give you a Result a, which is just a sum type.
08:35:48 <kallisti> also note that the "Parser" used by parseJSON is not the same Parser as used in attoparsec.
08:36:05 <kallisti> the only place where attoparsec is exposed is json, json', and all the other stuff in Data.Aeson.Parser
08:36:37 <EvanR> alright so all the same functionality is there
08:36:46 <EvanR> but i like the simpler api in attojson
08:36:49 <EvanR> so i can make a wrapper
08:37:07 <yitz> EvanR: i think you will quickly like aeson better if you try it
08:37:33 <EvanR> i have tried it
08:37:43 <EvanR> its better than Text.JSON
08:38:06 <mm_freak> t7: make a value of an infinite type
08:38:29 <mm_freak> t7: you will need to add some means of general recusion to do it
08:38:32 <mm_freak> recursion
08:38:37 <kallisti> > let wtf = [1,2,3] in foldl (+) wtf wtf
08:38:38 <lambdabot>   No instance for (GHC.Num.Num [t])
08:38:38 <lambdabot>    arising from a use of `e_1123' at <int...
08:38:42 <mm_freak> in the calculus i defined there was no general recursion
08:39:03 <kallisti> > let wtf = [1,2,3] in foldl (++) wtf wtf
08:39:04 <lambdabot>   No instance for (GHC.Num.Num [t])
08:39:04 <lambdabot>    arising from a use of `e_1123' at <int...
08:39:07 <kallisti> oh. nevermind.
08:39:16 <EvanR> alright enough haskell for the moment, ... need to switch back to ruby for work
08:39:49 <bitonic> gwern: that is interesting, thanks
08:40:06 <gwern> bitonic: it reminds me I should work more on my Haskell corpus analysis stuff...
08:40:51 <pqmodn> mm_freak: is there a distinction between "general" recursion and other kinds of recursion?
08:41:10 <gwern> pqmodn: structural recursion? total
08:41:13 <bitonic> pqmodn: yes
08:41:25 <bitonic> pqmodn: structural recursion, well founded recursion, etc.
08:41:32 <rwbarton> general recursion is the most... general
08:41:39 <pqmodn> i see
08:42:06 <MaskRay> How to record cookie in http-conduit
08:42:12 <bitonic> pqmodn: with general recursion there is no restriction whatsoever on recursive calls. this makes writing diverging functions a breeze.
08:42:35 <pqmodn> bitonic: are kinds of recursion which ensure termination?
08:42:36 <rwbarton> so other forms of recursion are also "general recursion", but with constraints on the form of the recursive calls you can prove more things about your function (e.g. it terminates)
08:42:41 <pqmodn> ah
08:42:46 <bitonic> pqmodn: yes, like the ones I cited
08:42:49 <t7> mm_freak: when i type check nat -> nat in coq it returns Set, not nat -> Set
08:43:41 <elliott> that is correct
08:44:28 <bitonic> pqmodn: the problem is that general recursion takes away some expressivity which is considered quite essential in programming languages - if a language doesn't have general recursion it isn't turing complete
08:44:39 <bitonic> actually, that is incorrect
08:45:00 <c_wraith> also needs infinite memory :)
08:45:03 <bitonic> let's say that if your programming language is terminating it isn't turing complete
08:45:07 <mm_freak> t7: you are confusion notation
08:45:20 <bitonic> of course general recursion is not the only construct to write non-terminating functions :P
08:45:21 * gwern sighs ~16G of haskell repos, and what do I do with it? sometmes check for reverse dependencies
08:45:27 <mm_freak> \(x : Nat) -> Nat is a function
08:45:33 <mm_freak> Nat -> Nat is a set
08:46:01 <bitonic> c_wraith: well, nowadays memory is supposed to be infinite when talking about turing complete languages :P
08:46:03 <gustavderdrache> i'm interested in using the persistent package, but i don't see a way to specify what kind of field types I can specify for textual columns
08:46:06 <t7> dont they both have the same representation
08:46:10 <gustavderdrache> (i'm in the right channel, i hope)
08:46:46 <danr> mm_freak: subtle difference between \(x : Nat) -> Nat and (x : Nat) -> Nat :)
08:46:52 <pcavs> What's the accepted, best performance HashMap/Table out there?
08:47:10 <mm_freak> ok, now i'm starting to feel insecure
08:47:10 <bitonic> pcavs: log n where the base of the log is very large
08:47:14 <bitonic> at least in functional languages
08:47:20 <bitonic> and with very large I mean 16/32
08:47:21 <parcs`> gustavderdrache: Text is advocated
08:47:30 <gustavderdrache> parcs`: oh, no, not that
08:47:40 <gustavderdrache> i meant VARCHAR(n) versus, say, BIGTEXT
08:47:41 <mm_freak> t7: let me investigate
08:47:43 <gustavderdrache> or whatever MySQL calls it
08:48:38 <pcavs> bitonic: yeah, but I was wondering what implementation? Data.Map.Map?
08:48:48 <parcs`> gustavderdrache: oh, well you have no control over that i don't think
08:48:52 <gustavderdrache> hrm
08:48:54 <bitonic> pcavs: HashMap in containers
08:49:10 <parcs`> persistent automatically chooses the best internal type for the haskell data type you are using
08:49:28 <gustavderdrache> i did some spelunking and found some way to create my own persist fields for things
08:49:33 <gustavderdrache> so i may have to do that
08:49:59 <parcs`> gustavderdrache: the people at #yesod are generally more familiar with persistent btw :)
08:50:04 <gustavderdrache> okay, yeah
08:50:13 <gustavderdrache> i may ask there :)
08:50:15 <gustavderdrache> thanks for the pointer
08:50:26 <mm_freak> hmm
08:50:35 <mm_freak> then i wonder whether it's really possible to unify lambda and pi
08:51:07 <elliott> mm_freak: ah!
08:51:11 <elliott> mm_freak: automath did that.
08:51:20 <elliott> but yes, the problem is that your "types" get extra arguments.
08:51:22 <elliott> it's kind of funky.
08:51:25 <t7> mm_freak: coq seems to give e1 -> e2  the type of  universe_max(e1, e2) + 1
08:51:58 <mm_freak> agda gives Set1 for ℕ → ℕ as expected
08:52:07 <t7> assuming Set is in the Set of Type
08:52:17 <mm_freak> my calculus gives ℕ → Set
08:52:52 <mm_freak> i wonder if that's inconsistent…  so far i haven't had any logical anomalies
08:53:11 <t7> maybe you stumbled on a new thing :)
08:53:22 <elliott> it's not a new thing, as i said
08:53:26 <mm_freak> it's certainly not new
08:53:38 <elliott> mm_freak: well, you can't pass that to a function expecting a Set
08:53:40 <elliott> which is kind of lame
08:53:49 <elliott> but you could have a typeclass for setty things, I suppose :P
08:53:55 <mm_freak> elliott: is there any problem with that?  if anything it appears to be a generalized calculus
08:53:59 <copumpkin> mm_freak: wat
08:54:20 <elliott> well it's wrong because it means you can't do much useful with function types...
08:54:23 <mm_freak> i mean for me it makes perfect sense that Nat -> Nat is of type Nat -> Set
08:54:40 <t7> mm_freak: you cant write an id function that works with functions
08:54:43 <copumpkin> mm_freak: wat
08:54:44 <elliott> maybe you're high :)
08:54:47 <copumpkin> mm_freak: also, Nat -> Nat is in Set
08:54:49 <copumpkin> not Set1
08:55:01 <mm_freak> copumpkin: agda infers Set1
08:55:07 <copumpkin> mm_freak: no it doesn't
08:55:09 <bitonic> mm_freak: no
08:55:12 <bitonic> that's Set0
08:55:14 <mm_freak> of course you can write an identity function
08:55:27 <copumpkin> mm_freak: http://snapplr.com/y77g
08:55:30 <mm_freak> (A : Set) -> (x : A) -> x
08:55:32 <copumpkin> mm_freak: allow dolio to school you
08:55:35 <mm_freak> that's the identity function in my calculus
08:55:42 <copumpkin> mm_freak: wait what
08:55:47 <t7> mm_freak: now pass that a (Bool) -> Bool
08:55:51 <t7> it wont type check
08:55:54 <t7> with yours
08:55:55 <copumpkin> mm_freak: that type doesn't make sense
08:55:56 <bitonic> mm_freak: that's not an identity function
08:56:03 <bitonic> id : (A : Set) -> A -> A
08:56:03 <mm_freak> t7: it does
08:56:05 <elliott> mm_freak: what
08:56:09 <parcs`> what!?!!
08:56:10 <elliott> that's completely broken
08:56:12 <bitonic> WHAT?
08:56:16 <elliott> mm_freak: you can't pass that 3
08:56:17 <mm_freak> copumpkin, bitonic: that's not a type
08:56:17 <elliott> because 3 isn't a type
08:56:21 <mm_freak> it's a function
08:56:29 <elliott> oh
08:56:30 <bitonic> mm_freak: what is a weird syntax then
08:56:34 <mm_freak> yeah
08:56:38 <copumpkin> mm_freak: very weird
08:56:39 <elliott> mm_freak: and what type does that function have?
08:56:39 <copumpkin> but anyway
08:56:44 <copumpkin> Nat -> Nat has type Set, not Set1
08:56:45 <mm_freak> i have unified lambda and pi
08:56:50 <copumpkin> and your Nat -> Set as a type is weird
08:56:54 <mm_freak> so far everything works well
08:57:19 <mm_freak> ok, let me finish this calculus…  then we can see whether it all makes sense =)
08:57:30 <copumpkin> so when you say
08:57:31 <mm_freak> elliott: the type is (A : Set) -> A -> A
08:57:40 <copumpkin> [11:51:36] <mm_freak> agda gives Set1 for ℕ → ℕ as expected
08:57:45 <copumpkin> is that a lambda or a type?
08:57:53 <copumpkin> and how about your example where Nat -> Set
08:57:56 <copumpkin> is that a lambda or a type?
08:57:56 <elliott> i think i'll just let mm_freak run into problems himself
08:58:00 <mm_freak> copumpkin: my impression is that i have a different calculus
08:58:09 <copumpkin> I'm just trying to make sense what that is
08:58:32 <mm_freak> copumpkin: there is no difference between Type and Expr in my calculus
08:58:50 <copumpkin> that's fine
08:58:55 <copumpkin> I'm trying to make sense of what you said before
08:59:07 <copumpkin> Nat -> Nat does not have type Set1
08:59:10 <mm_freak> copumpkin: i have unified lambdas and dependent products into a single construct
08:59:26 <mm_freak> copumpkin: yeah, i was wrong about that
08:59:27 <copumpkin> and if your calculus gives it type Nat -> Set, that's weird
08:59:53 <dolio> Actually, Set1 is never the right type for that, regardless of whether it's a function space or a lambda expression.
08:59:57 <dolio> Unless Nat : Set1.
09:00:24 <mm_freak> it's weird, but it totally seems to work…  i have written some test expressions
09:00:39 <copumpkin> mm_freak: the question is what it means for the type of a function to be a function
09:01:27 <mm_freak> copumpkin: i'm not sure what it "means"…  for a few days i'm testing the consistency of this calculus
09:01:44 <elliott> it's consistent
09:01:46 <elliott> it's just stupid :P
09:01:57 <mm_freak> elliott: what makes you sure?
09:02:13 <dolio> There are papers on calculi with only lambda.
09:02:15 <elliott> well i'm not "sure" there's just no reason for it to be inconsistent
09:02:17 <elliott> and automath did it, at least
09:02:27 <elliott> and automath worked fine, as I understand it
09:03:39 <mm_freak> i read augustss' "simpler easier" page and found that i can collapse lambda and pi, so i did
09:03:55 <elliott> mm_freak: what i meant was more "if anyone will find a consistency, it won't be you in a few days, because the idea isn't new" :p
09:03:58 <elliott> erm
09:04:00 <elliott> *an inconsistency
09:04:02 <mm_freak> not sure about the implications, but yeah, now one implication is that Nat -> Nat : Nat -> Set
09:04:19 <mm_freak> where Nat : Set
09:04:37 <mm_freak> so (Nat -> Nat) 0 : Set
09:04:38 <elliott> maybe if you have (a -> Set) -> Set
09:04:42 <elliott> then it'll work out
09:04:50 <elliott> so you can shove Nat -> Set into Set
09:05:43 <mm_freak> elliott: huh?  that's a higher order function to me
09:05:48 <mm_freak> and i wouldn't know what to apply to it
09:05:57 <elliott> embed : (a -> Set) -> Set
09:06:03 <elliott> embed (Nat -> Set) : Set
09:06:04 <elliott> so
09:06:08 <elliott> if you have
09:06:11 <elliott> foo : Nat -> Nat; foo x = ...
09:06:22 <elliott> then embed (the type of foo's type) uhhhh forget it
09:06:43 <mm_freak> i don't understand…  when do i infer a function and when not?
09:06:57 <elliott> wat
09:07:02 * elliott gives up
09:07:11 <bitonic> what is the question again?
09:07:23 <mm_freak> well, given Nat -> Nat and i want to typecheck
09:07:36 <mm_freak> my algorithm infers Nat -> Set for that one
09:07:55 <bitonic> mm_freak: how could that be?
09:08:18 <mm_freak> bitonic: because Nat -> Nat is a function…  it's equivalent to \(x : Nat) -> Nat
09:08:31 <rwbarton> wtf is going on
09:08:36 <danr> ?
09:08:49 <mm_freak> lol everybody is waking up by my weird calculus =)
09:09:06 <rwbarton> oh you just don't mean what you say, okay
09:09:15 <bitonic> mm_freak: do you agree that the kind of 'Nat -> Nat' in haskell is *?
09:09:23 <mm_freak> bitonic: yes
09:09:33 <mm_freak> and i know what you want to say =)
09:09:39 <bitonic> ok. Do you agree that having it to be 'Nat -> *' wouldn't make any sense?
09:10:01 <mm_freak> bitonic: in the calculus used by haskell yes
09:10:10 <bitonic> ok. how does it make sense in your calculus?
09:10:19 <bitonic> actually wait
09:10:21 <mm_freak> collapse lambda and pi
09:10:30 <mm_freak> then this is a logical consequence
09:10:35 <bitonic> do you agree that it doesn't make any sense in martin-lof TT as well?
09:10:45 <mm_freak> yes
09:11:09 <bitonic> what's pi again?
09:11:14 <elliott> dependent product
09:11:20 <rwbarton> if "Nat -> Nat" secretly means "\(x : Nat) -> Nat" then of course Nat -> Nat : Nat -> Set
09:11:25 <rwbarton> however, that premise is insane
09:11:57 <bitonic> elliott: dependend product as in sigma or as in universal quantification?
09:12:07 <elliott> sigma is dependent sum
09:12:07 <rwbarton> dependent product as in pi :P
09:12:14 <elliott> dependent function arrow
09:12:17 <elliott> is pi
09:12:19 <mm_freak> well, we have established that it's unusual, but are there any obvious implications?
09:12:27 <bitonic> elliott: they call it in all kind of ways, ok
09:12:37 <rwbarton> don't you mean... Nat -> Nat is equivalent to (x : Nat) -> Nat
09:12:37 <elliott> mm_freak: how do you have a list of functions (Nat -> Nat)?
09:12:42 <elliott> i.e. haskell [Nat -> Nat]
09:12:45 <rwbarton> not \(x : Nat) -> Nat
09:12:49 <elliott> remember that a List type will only take Set
09:12:55 <elliott> rwbarton: no, he means what he says
09:13:15 <mm_freak> elliott: let me think
09:13:15 <rwbarton> is he being sensible?
09:13:19 <elliott> rwbarton: no
09:13:49 <bitonic> elliott: dependend product in this case is universal quantification
09:13:49 <rwbarton> you can unify lambda and pi via "Nat -> Nat is equivalent to (x : Nat) -> Nat", right
09:13:53 <mm_freak> elliott: well that would be List (Nat -> Nat)
09:14:01 <elliott> rwbarton: no
09:14:05 <mysticc> Anybody knows about iorefCAS package ?
09:14:07 <elliott> mm_freak: NOPE!
09:14:09 <mm_freak> elliott: a valid member of this list would be, for example, (x : Nat) -> x
09:14:12 <elliott> mm_freak: (Nat -> Nat) : (Nat -> Set)
09:14:13 <rwbarton> wait what's lambda
09:14:14 <elliott> List : Set -> Set
09:14:17 <elliott> you can't pass (Nat -> Nat) to List
09:14:24 <elliott> try again
09:15:00 <bitonic> elliott: or dependent function space, or whatever. where do they call it pi?
09:15:02 <rwbarton> I thought it was a nondependent function arrow
09:15:12 <elliott> bitonic: martin lof type theory calls it pi
09:15:32 <bitonic> elliott: ok, TTFP doesn't call it pi, or I missed something :P
09:15:49 <mm_freak> elliott: you're right, there is no obvious way to construct a list of that type
09:15:59 <elliott> bitonic: the syntax is Π(x:T) : S
09:16:02 <elliott> for (x:T) -> S
09:16:21 <elliott> mm_freak: right. you essentially make functions into second-class citizens
09:16:27 <elliott> mm_freak: you will need a way to be "typey polymorphic"
09:16:29 <eacameron> Give this : main = do {content <- lines `fmap` getContents; print (parseGramFields `Prelude.map` content)}  Is there a way to move the `parse... `Prelude.map` content` to the `content <- ...` line?
09:16:33 <elliott> so that things can take both Set, Blah -> Set, etc.
09:16:37 <bitonic> elliott: yeah, it's an universal quantification, forall x : T. S, where S can depend on x
09:16:38 <elliott> to construct a useful List
09:16:59 <mm_freak> understood…  i'll add pi back =/
09:17:06 <mm_freak> man, this felt so elegant
09:18:08 <bitonic> mm_freak: lambda is already a special case of pi anyways, discarding the value
09:18:20 <bitonic> I'm not sure what you'd gain by "collapsing" it that way
09:18:56 <mm_freak> bitonic: do you mean the type lambda?
09:19:08 <hpaste_> “Vagif Verdi” pasted “bulls and cows” at http://hpaste.org/67593
09:19:09 <sclv> > (7**(exp 1 - exp (negate 1)) - 9) * pi^2
09:19:10 <lambdabot>   867.530901981685
09:19:21 <bitonic> mm_freak: I mean '->'
09:19:21 <sclv> "jenny i got your number"
09:19:49 <mm_freak> eacameron: use function composition
09:20:03 <mm_freak> map parseGramFields . lines
09:20:17 <bitonic> 'A -> B' is basically 'forall (x : T). \ _ -> B', in haskell syntax
09:20:53 <mm_freak> alright
09:20:54 <dolio> elliott: Πx:T. S
09:20:56 <mm_freak> back to coding
09:21:10 <elliott> dolio: wikipedia uses : at least http://en.wikipedia.org/wiki/Intuitionistic_type_theory#.CE.A0-types
09:21:37 <dolio> No, it doesn't.
09:21:47 <efie> does anyone know if the yesod book will be in color?
09:21:51 <elliott> oh
09:21:52 <elliott> indeed not
09:21:55 <dolio> :)
09:21:55 <elliott> it just has bad spacing
09:21:56 <tac-tics> mmmm, pie types
09:22:09 <eacameron> mm_freak: awesome, that worked perfectly. I'm hoping I catch on soon...? ;)
09:22:40 <bitonic> oh, I just noticed yesod new shiny website!
09:22:45 <bitonic> catching up with happstack and snap
09:22:54 <elliott> so does happstack :p
09:23:09 <elliott> happstack's has tiny fonts though
09:23:16 <bitonic> still looks a bit unfinished
09:24:00 <elliott> just like happstack OH SNAP (i have never used happstack)
09:24:03 <elliott> (or yesod, or snap)
09:24:10 <elliott> haha "oh snap"
09:24:11 <elliott> sigh
09:24:13 <bitonic> happstack is the best.
09:24:32 <bitonic> as proven by its website abundance of whitespace.
09:26:20 <womb> > 7*7
09:26:21 <phryk> I'm still trying (without success) to get ghc to look for packages in ~/.cabal/lib/. Could anyone provide help?
09:26:21 <lambdabot>   49
09:26:45 <womb> have you thought about using cabal-dev ?
09:26:52 <womb> and keep packages locally to your project
09:27:01 <dcoutts> phryk: they have to be registered with ghc-pkg, cabal does this automatically
09:27:03 <womb> more space sure but safe
09:27:43 <elliott> phryk: again, that's not how it works :p
09:28:06 <dcoutts> phryk: if you have files in ~/.cabal/lib/ but the corresponding package is not registered with ghc-pkg, then ghc will know nothing about it
09:28:36 <dcoutts> phryk: use ghc-pkg list to see what you have, then use cabal install to install the ones you want
09:28:51 <elliott> phryk: are you trying to install a package by copying it to ~/.cabal/lib or something?
09:29:54 <phryk> dcoutts: My problem is that packages I installed with cabal install don't show up with ghc-pkg list and are not found when imported with ghc.
09:30:10 <phryk> elliott: no, just using `cabal install <packagename>` as normal user
09:30:20 <elliott> ok, then the problem isn't that it's not looking at ~/.cabal/lib
09:30:21 <dcoutts> phryk: if they're not listed with ghc-pkg then they're really not registered
09:30:24 <elliott> it's that they're not registering properly
09:30:29 <elliott> do you have multiple ghcs installed or something?
09:30:37 <phryk> dcoutts: Yes, that is *the problem I have*
09:30:46 <elliott> you didn't say that :p
09:30:57 <elliott> are you sure "cabal install" is not failing?
09:31:01 <phryk> YES
09:31:02 <dcoutts> phryk: and cabal reports that it installs successfully?
09:31:09 <phryk> dcoutts: YES.
09:31:21 <elliott> are you sure?
09:31:25 <elliott> hpaste cabal's entire output
09:31:32 <dcoutts> followed by ghc-pkg list
09:31:44 <phryk> elliott: what do you mean by cabals entire output
09:31:51 <elliott> "cabal install foo"
09:31:55 <elliott> copy the entire output
09:31:57 <elliott> put it on http://hpaste.org/
09:32:08 <elliott> not foo literally, the package you want :p
09:35:12 <phryk> elliott, dcoutts: http://hpaste.org/67594 <-- ghc-pkg list
09:35:30 <elliott> and `cabal install foo`?
09:35:45 <phryk> coming along, I'm on an old p-m here :P
09:36:00 <elliott> oh, cabal is equally slow on all hardware
09:36:19 <dcoutts> parallel package builds nearly ready :-)
09:36:26 <bitonic> dcoutts: really?! yay
09:36:40 <dcoutts> bitonic: it's only building multiple independent packages in parallel
09:36:45 <phryk> http://hpaste.org/67595 cabal install curl
09:36:56 <elliott> ghc-pkg --version
09:36:58 <elliott> what does that give you?
09:37:04 <bitonic> dcoutts: ah... still something :)
09:37:09 <dcoutts> e.g. helps a lot with cabal install yesod, but not with individual packages
09:37:16 <phryk> also: after cabal install curl ran through, ghc-pkg list does *not* show curl :P
09:37:37 <phryk> GHC package manager version 6.12.3
09:37:47 <elliott> hmmmmmm wtf
09:38:10 <elliott> perhaps try cabal install -v3 curl and hpaste that output
09:38:20 <elliott> but dcoutts might have a better idea than me :p
09:38:28 * dcoutts would like to see the -v3 output too
09:38:44 <rwbarton> i find it a little weird that you have so many global packages installed
09:39:01 <phryk> dcoutts: can i just rebuild the curl lib, or do i have to remove (if so: how?) the package beforehand?
09:39:03 <elliott> rwbarton: really?
09:39:07 <rwbarton> and yet cabal install curl tried to install locally
09:39:08 <elliott> that looks like mostly the boot packages to me
09:39:11 <elliott> oh
09:39:12 <elliott> wait
09:39:17 <elliott> phryk: your packages are messed up
09:39:19 <rwbarton> should there really be multiple versions of so many?
09:39:21 <elliott> you have two versions of Cabal!
09:39:27 <elliott> naughty
09:39:32 <dcoutts> elliott: that's ok
09:39:36 <elliott> hmm, it is?
09:39:39 <elliott> I thought Cabal was a boot package
09:39:43 <phryk> I err what o_O
09:39:52 <dcoutts> elliott: but you can install extra versions ok
09:40:00 <elliott> ok then
09:40:03 <elliott> that's unusual :)
09:41:13 <rwbarton> maybe permissions on /home/phryk/.ghc/i386-linux-6.12.3/package.conf.d are messed up somehow?
09:41:16 <dcoutts> phryk: you should be able to just cabal install curl -v3
09:41:33 <phryk> rwbarton: The packages I have installed should all be deps of cabal and/or cabal-install; those i installed using the distros package manager (portage)
09:41:36 <rwbarton> well that is probably a better plan than my blindly guessing
09:42:09 * monochrom would want the whole hard disk uploaded
09:42:46 <phryk> http://hpaste.org/67596 <- cabal install curl -v3
09:43:13 <elliott> lol
09:43:20 <dcoutts> heh, cabal thinks it is installed
09:43:22 <elliott> is this the first time you have tried to install curl?
09:43:30 <dcoutts> which means ghc-pkg thinks it is installed
09:43:32 <elliott> (i.e. did you first encounter this problem with another package)
09:43:40 <elliott> are you _really_ really_ sure ghc-pkg does not list it now
09:43:50 <phryk> elliott: the first time was a few minutes back, the -v3 was the second time
09:44:06 <dcoutts> and tell us what 'which ghc' and 'which ghc-pkg' reports
09:44:07 <elliott> right
09:44:10 <phryk> that was why i asked if i had to uninstall it beforehand
09:44:29 <phryk> /usr/bin/ghc /usr/bin/ghc-pkg
09:44:50 <elliott> phryk: don't worry, you can't uninstall packages
09:44:55 <dcoutts> phryk: and presumably 'ghc-pkg list curl'  does now list it
09:44:55 <elliott> well, you can, but it's easier to just uninstall everything and start again
09:44:56 <monochrom> well, look at "ghc-pkg list" again
09:45:03 <phryk> elliott: That's reason enough for me to worry…
09:45:16 <elliott> phryk: now you're thinking with cabal
09:45:23 <elliott> reinstalling everything isn't that bad. cabal-dev makes it even easier!
09:45:24 <phryk> dcoutts: shit yes it does o_O
09:45:33 <phryk> This confuses me.
09:45:39 <elliott> phryk: i suspect it was installed all along
09:45:43 <elliott> and you just didn't notice or something
09:45:52 <phryk> What was installed?
09:46:03 <dcoutts> curl
09:46:06 <rwbarton> curl, as of the first time you installed it just now
09:46:12 <monochrom> no, we all saw the old ghc-pkg list output
09:46:23 <rwbarton> but not the post-"cabal install curl" output
09:46:24 <elliott> monochrom: yes, but did you see what phryk said after?
09:46:51 <elliott> monochrom: they said it does not list curl after the install
09:46:54 <elliott> so that ghc-pkg list was _pre_ install
09:47:03 <phryk> I installed curl with cabal install (first time, I'm sure about that), then did another cabal install with the -v3 switch
09:47:17 <rwbarton> let's try another package then
09:47:24 <monochrom> I saw what he/she said both before and after. presumably he/she was honest, i.e., already tried "cabal install curl" before asking
09:47:42 <phryk> Ah
09:47:48 <elliott> if I say "didn't notice"
09:47:51 <phryk> I could've been wrong when I said that curl didn't show up.
09:47:56 <elliott> then I don't assume dishonestly, just a mistake
09:47:59 <elliott> *dishonesty
09:48:03 <dcoutts> ping me if you can reproduce it
09:48:10 <phryk> I read the output of ghc-pkg list wrong.
09:48:20 <elliott> seems like phryk found a heisenbug in cabal
09:48:42 <phryk> elliott: I have this problem on two of my machines
09:48:50 <phryk> Both running gentoo.
09:49:02 <elliott> well, gentoo users should be used to random, unexplainable breakage
09:49:08 <phryk> Im trying to do another 'cabal install yesod' and see if after that yesod shows up
09:49:16 <phryk> elliott: Actually no.
09:49:41 <phryk> I'm used that stuff might break if I don't do maintenance for a long period of time, but never experienced one I couldn't explain.
09:49:46 <rwbarton> it sounds like in retrospect there was never any unexpected behavior
09:49:53 <phryk> even if it took hours and hours to get to the bottom of the problem :3
09:50:03 <elliott> rwbarton: no, there was
09:50:08 <rwbarton> which?
09:50:10 <elliott> oh hmm
09:50:12 <elliott> 17:46 <phryk> I installed curl with cabal install (first time, I'm sure about that), then did another cabal install with the -v3 switch
09:50:15 <elliott> you're right, since the first one worked
09:50:27 <rwbarton> there might have been before phryk showed up here
09:50:55 <phryk> lol
09:50:59 <phryk> yesod won't install now…
09:51:16 <phryk> cabal: cannot configure conduit-0.4.1. It requires base >=4.3 && <5
09:51:19 <phryk> For the dependency on base >=4.3 && <5 there are these packages: base-4.3.0.0,
09:51:21 <phryk> base-4.3.1.0, base-4.4.0.0, base-4.4.1.0 and base-4.5.0.0. However none of
09:51:23 <phryk> them are available.
09:51:30 <phryk> Should I just update ghc? (This machine still has a 6.x version)
09:51:31 <elliott> yes
09:51:36 <elliott> you want 7.0.4 or 7.4.1
09:51:38 <elliott> probably 7.0.4
09:51:43 <dcoutts> phryk: yesod now depends on ghc-7+
09:51:44 <monochrom> or use older conduit
09:51:50 <elliott> phryk: btw, you need to throw out all packages if you upgrade ghc
09:51:54 <monochrom> or use older yesod
09:52:07 <phryk> elliott: I'll delete my whole .cabal if that is a safe move.
09:52:32 <phryk> gentoo has a tool to rebuild all haskell libs that were built using the distros package manager.
09:52:35 <fliiipy> Hi, im really new to Haskell, is there a better way of writing: http://pastebin.com/UfTVAs8A
09:52:36 <fliiipy> ?
09:52:37 <mauke> The paste UfTVAs8A has been copied to http://hpaste.org/67597
09:52:43 <dcoutts> phryk: wouldn't make a lot of difference, you seem only to have 4 packages installed in your user package db
09:52:57 <mauke> fliiipy: isPunct = (`elem` "?!.")
09:53:12 <fliiipy> Oh. Wow. Thanks.
09:53:20 <mauke> :t isPunct
09:53:21 <lambdabot> Not in scope: `isPunct'
09:53:38 <mauke> :t isPunctuation
09:53:39 <lambdabot> Char -> Bool
09:53:42 <elliott> phryk: and ~/.ghc
09:53:46 <monochrom> phryk: you need to see my http://www.vex.net/~trebla/haskell/sicp.xhtml for how much .cabal/lib doesn't matter
09:53:49 <mauke> > filter isPunctuation [minBound .. maxBound]
09:53:50 <lambdabot>   "!\"#%&'()*,-./:;?@[\\]_{}\161\171\183\187\191\894\903\1370\1371\1372\1373\...
09:54:06 <phryk> dcoutts: elliott, monochrom, rwbarton: thanks for your help, it'll take some hours until the new ghc is ready, I'll prolly come in tomorrow and report again :P
09:55:00 <elliott> phryk: you should really use binary builds of ghc if you want to keep your sanity
09:55:07 <bitonic> mauke: uhm. according to haskell, '༊' is punctuation.
09:55:25 <mauke> ok?
09:55:44 <phryk> elliott: ah right.
09:56:24 <ion> U+0F0A TIBETAN MARK BKA- SHOG YIG MGO
09:56:33 <ion> Category: Po (Punctuation, Other)
09:56:39 <elliott> phryk: especially since it depends on ghc anyway :)
09:56:53 <phryk> What depends on ghc?
09:57:18 <elliott> GHC
09:57:25 <elliott> GHC is written in GHC Haskell
09:57:29 <elliott> (it doesn't compile on any other compiler)
09:58:00 * nand` has been using source builds of GHC fine for quite a while; no loss of sanity involved
09:59:10 <monochrom> "to build GHC, you must first install GHC"
09:59:18 <phryk> nand`: on my current desktop machine I do that as well…
09:59:32 <phryk> nand`: but on an old p-m 1.8ghz cpu with 1G ddr1 ram…
10:00:18 <monochrom> of course, the prospect of using 6.12 to build 7.0 or 7.4 exists
10:00:45 <monochrom> I think it comes down to the keyword "gentoo". what do you expect
10:00:58 <phryk> :P
10:01:16 <monochrom> (case in point: they build every kernel)
10:05:16 <nand`> monochrom: yeah; I use a binary build to bootstrap the source build
10:05:26 <nand`> takes about 25 minutes on my somewhat rusty machine
10:12:24 <nand`> monochrom: don't very early versions of GHC build with C?
10:12:55 <nand`> it might be possible to download the last version of GHC doesn't require GHC then use that to build successive versions
10:13:08 <nand`> last versions of GHC that*
10:13:33 <int-e> nand`: good luck with that. according to wikipedia, "GHC originally started in 1989 as a prototype, written in LML (Lazy ML) by Kevin Hammond at the University of Glasgow. Later that year, the prototype was completely rewritten in Haskell, except for its parser ..."
10:13:43 <nand`> I see
10:14:01 <bitonic> nand`: there is a way to port GHC to new platform
10:14:11 <bitonic> nand`: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
10:14:16 <elliott> you can still download lazy ml,I think
10:14:17 <nand`> bitonic: well; you can use existing GHC to build for a new platform; no?
10:14:17 <elliott> *, I
10:14:29 <bitonic> nand`: no, even without having GHC
10:14:29 <elliott> or get it from augustss at least :P
10:14:35 <nand`> elliott: what's the preferred lazy ML implementation?
10:14:40 <elliott> bitonic: you need GHC to make the unregistered build
10:14:40 <FliipMan> How do I get information about a haskell inbuilt function and see the code of that function?
10:14:45 <elliott> nand`: I doubt there was ever two
10:14:54 <bitonic> nand`: you can compile GHC to C on another platform, then compile the resulting C on a new platform, and then start from there
10:15:13 <int-e> nand`: but ghc can generate somewhat portable C code to allow bootstrapping to a new platform.
10:15:22 <bitonic> nand`: but this stopped working in GHC 6.something, so you have to start from that
10:16:17 <nand`> I think that's what the article describes
10:16:24 <elliott> bitonic: they broke unregistered builds?
10:16:25 <elliott> hahaha
10:17:10 <nand`> what inbuilt functions does haskell have? Does the specification require a certain Prelude?
10:17:22 <bitonic> elliott: well actually I think that the problem is that -fvia-C is gone.
10:17:23 <mauke> @where report
10:17:23 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
10:17:38 <elliott> bitonic: hmm, it's not actually gone in 7.0 afaik
10:17:51 <bitonic> elliott: oh, then it should work
10:17:52 <elliott> nand`: yes, the Prelude and some modules are specified
10:18:00 <elliott> bitonic: it's deprecated in 7.2 I think?
10:18:02 <elliott> maybe it is  gone by now
10:18:05 <elliott> but i think 7.0 has it at least
10:18:06 <nand`> elliott: ah yes; I see it now
10:18:08 <bitonic> I'm pretty sure it's gone by now
10:18:23 <elliott>     Warning: The -fvia-c flag does nothing; it will be removed in a future GHC release
10:18:25 <elliott> so it's gone by 7.2
10:18:33 <elliott> still on 7.2 here...
10:18:36 <int-e> bitonic: the registerised C backend is gone. the unregisterised one is still there
10:18:49 <elliott> right, I thought they weren't the same thing...
10:19:16 <bitonic> I've never done that myself. I remember someone saying on the mailing list that they had to start from 6,
10:19:26 <int-e> although I have no idea whether it can actually be used for bootstrapping atm. I have never had the need to find out.
10:20:49 * hackagebot cmu 1.6 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.6 (JohnRamsdell)
10:33:10 <mm_freak> oh
10:33:27 <mm_freak> i know why agda inferred Set1 for Nat -> Nat
10:33:39 <mm_freak> the /type/ of Nat -> Nat's type is Set1 =)
10:33:58 <mm_freak> i should have asked it to infer the /value/ at that spot, not the type
10:35:42 <shirt> what are the differences between virthualenv, cabal-dev, and capri?
10:35:43 <copumpkin> oh :)
10:36:00 <copumpkin> mm_freak: keep going and you'll get to Set omega! >_>
10:38:17 <mm_freak> hehe
10:39:38 <FliipMan> How would I get the following function to invert... ie add a not function? functionA = filter functionB
10:40:44 <Botje> filter (not . functionB)
10:40:50 * hackagebot diagrams-svg 0.3.5 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3.5 (DeepakJois)
10:40:52 * hackagebot unfoldable 0.4.0 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.4.0 (SjoerdVisscher)
10:41:07 <FliipMan> thank you.
10:41:53 <elliott> FliipMan: that's equivalent to filter (\x -> not (functionB x))
10:42:50 <mm_freak> elliott: how exactly did automath unify lambda and pi?
10:43:08 <elliott> mm_freak: I don't remember :)
10:43:10 <FliipMan> Sorry im completely new to haskell, I dont understand you elliott. I cant get my head around sectioning
10:43:15 <elliott> ah, http://www.cs.ru.nl/~freek/aut/ is where i saw it
10:43:19 <elliott> FliipMan: nothing to do with sectioning
10:43:23 <elliott> I was just explaining Botje's example for you
10:43:31 <elliott> FliipMan: it's the same as defining "functionC x = not (functionB x)"
10:43:32 <mm_freak> elliott: thanks
10:43:34 <elliott> then using filter functionC
10:43:36 <mendez> lambdabot: [x | x <- [1..10]]
10:43:46 <elliott> FliipMan: (\x -> ...) is just a lambda expression, which is like defining a function and immediately using it
10:43:56 <elliott> i.e., "foo (\x -> bar)" is like "f x = bar" then "foo f"
10:44:02 <FliipMan> What was the \x?
10:44:28 <elliott> that's the syntax for it
10:44:34 <elliott> it's just a lambda / anonymous function
10:44:39 <elliott> have you used Python or C#?
10:44:44 <elliott> in Python it's "lambda x: ..."
10:44:49 <elliott> in C# I think it's "x => ..."
10:44:49 <FliipMan> No =(
10:45:09 <elliott> well...
10:45:13 <elliott> FliipMan: when you say (\x -> blah blah blah)
10:45:18 <elliott> that's just a function that takes x as a parameter
10:45:20 <elliott> and has result blah blah blah
10:45:21 <elliott> like
10:45:22 <nand`> The reason why it's ‘\’ is because; and there is absolutely no doubt to the verifiability and sincerity of this quote; “it looks like a lambda if you squint really hard”
10:45:24 <elliott> myFunction x = blah blah blah
10:45:36 <elliott> is also
10:45:39 <elliott> myFunction = \x -> blah blah blah
10:45:45 <elliott> meh, are you reading Learn You a Haskell?
10:45:46 <elliott> it'll explain it
10:45:46 <FliipMan> ah ok.
10:46:03 <FliipMan> Im just using internet resources at the moment.
10:46:09 <elliott> @where lyah
10:46:09 <lambdabot> http://www.learnyouahaskell.com/
10:46:13 <FliipMan> I will get a book soon though (When I can afford one) lol
10:46:16 <elliott> it's free online
10:46:18 <nand`> LYAH is free of charge
10:46:19 <elliott> (also in book form)
10:46:20 <FliipMan> Oh ok.
10:46:24 <FliipMan> Thank you.
10:46:27 <elliott> np :)
10:46:38 <newtrekemotion> LYAH is AWESOME that is what I'm going through right now.
10:46:41 <FliipMan> I didnt know about that. Cheers.
10:46:42 <FliipMan> lol
10:47:07 <nand`> there's also RWH
10:47:09 <nand`> @where RWH
10:47:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:47:27 <elliott> ...but you shouldn't read it before LYAH.
10:47:31 <elliott> (and maybe not even then.)
10:51:32 <burbul> Is there a tool that counts lines of code, comments, etc. in Haskell? (The only one I can find requires Perl, which I don't have installed.)
10:51:47 <elliott> try sloccount
10:51:53 <elliott> or ohloh's thing, ohcount
10:52:59 <burbul> thanks
10:55:28 <elliott> burbul: oh, sloccount is Perl.
10:55:32 <elliott> why don't you have perl, though?
10:55:38 <elliott> even GHC uses perl. well, used to
10:56:11 <nand`> that has me thinking.. is there a utility for gathering the metrics of Haskell code other than a raw line count?
10:56:23 <elliott> well, both those tools ignore comments and whitespace and the like
10:56:26 <nand`> like, say, number of function definitions or number of function applications
10:57:12 <mm_freak> elliott: i can't find any material on the calculus automath uses…  apparently it's lost in history
10:57:24 <elliott> mm_freak: there's a few more modern papers about it, I think
10:57:34 <elliott> or you could read the implementation on the page i linked
11:00:20 * kallisti should write Kallisti's (Poignant) Guide to Haskell
11:00:28 <kallisti> the entire thing will just be a book of impressionist paintings.
11:00:51 * hackagebot language-javascript 0.5.4 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.4 (AlanZimmerman)
11:01:20 <flixil> Hello, I'm trying to make my first haskel program which should sum all the numbers multiple of 3 and less than 1000. I'm trying to accomplish the first problem from the euler project and I'm trying not to use list comprehensions
11:01:38 <kallisti> are you familiar with the range syntax?
11:02:05 <kallisti> > [2, 4 .. 10]
11:02:06 <lambdabot>   [2,4,6,8,10]
11:02:20 <flixil> I try doing sum (below_filter 1000 (all_multiple 3))
11:02:25 <flixil> Yes, I read it, but the problem is getting infinite lists
11:02:34 <kallisti> hm?
11:02:35 <flixil> where all_multiple x = iterate (+ x) 0
11:02:38 <fmap> @where hpaste
11:02:39 <lambdabot> http://hpaste.org/
11:02:41 <kallisti> why do you need an infinite list?
11:02:44 <fmap> flixil: ^
11:02:53 <flixil> I don-t need it :) ok i'll past there
11:03:15 <kallisti> flixil: oh, well then get rid of it.
11:03:24 <monochrom> "the problem is I'm getting an unwanted infinite list and an accidental pregnancy"
11:03:35 <kallisti> > take 5 [1..]
11:03:36 <lambdabot>   [1,2,3,4,5]
11:03:37 <kallisti> tada!
11:04:06 <rwbarton> takeWhile is what you want here
11:04:14 <flixil> what i want is filter the infinite list by taking the numbers smaller than 1000 knowing that ...
11:04:18 <flixil> Oh yes, thanks a lot
11:04:23 <kallisti> well, yes. I didn't want to spoil everything. :P
11:04:30 <kallisti> if I wanted to do that I would just say:
11:04:36 <rwbarton> ...
11:04:37 <kallisti> > sum [3,6 .. 100]
11:04:38 <lambdabot>   1683
11:04:46 <kallisti> er wait
11:04:51 <flixil> i did it with a list comprehension already, i just tried to use hoogle to find nice functions to use
11:04:51 <kallisti> > last [3,6 .. 100]
11:04:52 <lambdabot>   99
11:04:56 <kallisti> okay. yes.
11:05:12 <kallisti> range syntax is not a list comprehension.
11:07:04 <Lorehead> fixil: If youre willing to see a spolier, heres a version I did yesterday.
11:07:10 <Lorehead> http://pastebin.com/q3gVLVuV
11:07:12 <mauke> The paste q3gVLVuV has been copied to http://hpaste.org/67599
11:07:22 <bobry> I'm probably missing something obvious, but wtf -- https://gist.github.com/1aeeaf62b14f87ca6266 (64-bit GHC)
11:07:23 <flixil> sum [x | x <- [1..999], x `mod` 3 == 0 ]
11:07:47 <flixil> How can i count the elements on a list?
11:08:05 <bobry> flixil: length of the list you mean?
11:08:17 <rwbarton> bobry: what's wtf about that?
11:08:57 <elliott> looks right to me
11:09:18 <elliott> bobry: try -1 :: Word64
11:09:20 <elliott> basically
11:09:23 <elliott> (-1 :: WordN)
11:09:27 <elliott> is identical to (maxBound :: WordN)
11:09:36 <elliott> and maxBound :: Word64 is all-bits-1
11:09:41 <elliott> which is -1 in twos-complement
11:09:51 <elliott> but ofc a 64-bit Int can fully represent the maximum 32-bit word
11:10:11 <bobry> so it doesn't overflow and I don't get the -1?
11:10:30 <elliott> huh?
11:10:33 <elliott> > maxBound :: Word64
11:10:34 <lambdabot>   18446744073709551615
11:10:39 <flixil> bobry :) yes, exactly
11:10:50 <elliott> 18446744073709551615 is 64 ones, in binary
11:10:55 <elliott> which is the representation of -1 in two's complement
11:10:56 <rwbarton> it converts via Integer
11:10:58 <elliott> Word is unsigned, Int isn't
11:11:02 <elliott> oh, I see
11:11:08 <elliott> right, the conversion is always a safe black box
11:11:15 <bobry> yup, now I get it, thanks :)
11:11:15 <elliott> it uses arbitrary-precision Integers
11:13:49 <NemesisD> can someone please remind me where the setting is to automatically build packages with performance instrumentation?
11:14:50 <elliott> performance?
11:14:52 <elliott> do you mean profiling?
11:14:55 <elliott> it's in ~/.cabal/config
11:14:58 <elliott> the library-profiling setting
11:15:04 <elliott> comment it out (remove the "-- ") and set it to True
11:15:19 <NemesisD> oh yeah
11:15:28 <NemesisD> does it default to on?
11:15:34 <monochrom> I want performance instrumentation too. -O2 is not enough performance
11:15:56 <elliott> NemesisD: no
11:16:28 <flixil> ok, now the question is, instead of calling my function on wingchi after defining it with let, if i define my function without let on a file and load that file, how can it just print the answer automatically using main?
11:17:13 <monochrom> cannot
11:17:14 <NemesisD> brand new i5-2500k, compiling haskell modules is sooo fast
11:18:19 <elliott> flixil: your question doesn't make much sense
11:19:40 <Lorehead> fixil: If I understand correctly, you can either use ghc -e, or ghci.
11:20:21 <Lorehead> Im not familiar with winghci specifically, but I imagine it has the same options?
11:21:01 <flixil> i'm using winghci, and i load a file i have with the definitions of my functions. But i'm not sure how to use main
11:21:20 <Lorehead> You mean, how to write a main function?
11:21:41 <flixil> I've seen that you can do main = putStrLn "Hello world"
11:21:42 <elliott> main = ...
11:21:45 <elliott> main isn't a function
11:21:49 <elliott> flixil: you can do
11:21:52 <elliott> main = print (foo 42)
11:21:52 <flixil> and i want to print the result of my function
11:21:53 <donri> main = print $ callToFunction -- mimics ghci
11:21:57 <elliott> to have your program print the result of foo 42
11:21:58 <elliott> like ghci
11:22:24 <monochrom> you still have to manually type in "main" or ":main" to run it
11:22:29 <flixil> oh :) print instead of putStrLn. Thanks
11:22:38 <donri> or runhaskell file.hs
11:22:41 <flixil> yes, but i can compile it and just execute it later
11:23:09 <donri> flixil: putStrLn writes a string plus a newline, print prints a string representation of arbitrary values
11:23:12 <elliott> flixil: right, putStrLn prints strings, print prints any value that has a Show instance
11:23:17 <elliott> flixil: but note that print and putStrLn differ on strings
11:23:20 <elliott> print includes the quotes, putStrLn doesn't
11:23:28 <elliott> putStrLn is "raw" output; print is "show this like GHCi / as Haskell code"
11:25:41 <flixil> Thanks, I think i finished my first multiline haskel program :) Tomorrow I'll do next euler problem. Thanks everyone
11:26:27 <Lorehead> Enjoy!
11:27:53 <Beelsebob> anyone know where I can find a function to compute the nth root of a value?
11:27:59 <Beelsebob> (or specifically the 12th root)
11:28:12 <nyingen> so are conduits the new iteratees?
11:28:42 <nyingen> I ran across some stuff implying this, but I'd like to know whether I should start using conduit instead of enumerator
11:28:43 <c_wraith> nyingen: maybe. they're an experiment.
11:29:10 <nyingen> part of the reason I use the enumerator library is because of all the "foo-enumerator" packages on hackage
11:29:17 <c_wraith> nyingen: you can tell that they're an experiment by the fact that their implementation has changed radically once, and completely (though less radically) another time
11:29:28 <nyingen> yeah, I've been following it a bit on the blog
11:29:54 <nyingen> since it was part of yesod, which I don't use, I haven't been reading very carefully
11:30:01 <elliott> conduit isn't really part of yesod
11:30:09 <elliott> I don't think many people are using enumerators any more
11:30:18 <elliott> it's all conduits or sometimes pipes (and a few people still using iteratee)
11:30:24 <nyingen> I see
11:30:33 <elliott> http-enumerator is now http-conduit
11:30:42 <elliott> so if you want to do HTTP, that's a good motivator for using conduits :p
11:30:57 <nyingen> most of my use is with XML or flat text files
11:31:20 <monochrom> the 12th root of 2 is (2 :: Double)**(1/12), unless you mean something else.
11:31:34 <nyingen> I have hundreds of XML files to process, some of which are very large, so libxml-enumerator seemed like a good idea, except of course how annoying it is to program with the enumerator library
11:31:48 <nyingen> no offense to its author at all; the concept is just very hard to use
11:32:03 <donri> nyingen: hxt is nice, duno how performant
11:32:08 <elliott> nyingen: there is xml-conduit
11:32:14 <nyingen> does it have a sax interface?
11:32:22 <elliott> i believe so, yes.
11:32:28 <nyingen> well, maybe I'll try it
11:32:31 <elliott> not sure though.
11:32:39 <nyingen> what about these pipes I keep hearing about?
11:32:41 <elliott> yes
11:32:41 <elliott> http://hackage.haskell.org/packages/archive/xml-conduit/0.7.0.1/doc/html/Text-XML-Stream-Parse.html
11:32:47 <nyingen> elliott: thanks
11:32:51 <elliott> pipes are cleaner than conduit but there aren't really any practical libraries using them yet
11:33:01 <elliott> and there's a lot of disagreement about finalisation etc.
11:33:14 * elliott wants cmccann's streaming data library
11:34:17 <nyingen> it seems like a lot of existing code on hackage has APIs for enumerator, which is why I've been using it
11:34:36 <nyingen> a brief skim of hackage shows that there are some -conduit packages but not that many
11:35:04 <elliott> meh
11:35:08 <elliott> most of the important stuff is there
11:35:18 <nyingen> Also, I remember some discussion on -cafe some months back about the proliferation of iteratee implementations and which one should be 'standardized on' by the community
11:35:25 <nyingen> after iterIO came out, IIRC.
11:35:34 <elliott> i think you'll find conduit stuff is a _lot_ more lively than enumerator these days
11:35:36 <elliott> iterIO never really took off
11:35:45 <nejucomo> Why does the haskell platform depend on GL?
11:35:55 <nyingen> yeah, I had that impression. was it because the author caused the package to depend on SSL? :)
11:35:57 <EvanR> whats a platform without graphics
11:35:59 <elliott> nejucomo: it comes with opengl packages
11:36:04 <elliott> nyingen: never mind ssl, it depends on unix
11:36:17 <elliott> nyingen: anyway, there's a lot of conduit packages if you ask me: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:conduit
11:36:34 <elliott> conduit has 20, enumerator 27: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:enumerator -- but the enumerator list also includes pipes!
11:36:35 <elliott> and iterIO
11:36:39 <elliott> so I'd say they're about equal
11:36:46 <nejucomo> I can think of many server platforms that have no graphics.
11:36:50 <elliott> (both pipes implementations, in fact)
11:36:58 <elliott> nejucomo: OpenGL does not depend on a display ;)
11:36:59 <EvanR> those servers are not enterprise ready
11:37:59 <nejucomo> heh...
11:38:02 <nyingen> elliott: Alright, then I'll go read a conduit tutorial if I can find one
11:38:14 <elliott> nyingen: i think the one in the yesod book is out of date
11:38:21 <elliott> nyingen: you should probably just read the haddocks
11:38:31 <elliott> nyingen: the types are much simpler than enumerator
11:38:50 <nyingen> elliott: I sure hope it's less painful than enumerator. I implemented an enumeratee that collected lines from a text file into a complete record to send to an iteratee, and frankly it was mind-boggling
11:39:04 <elliott> nyingen: Source m a = a stream of as running in monad m; Conduit i m o = turns a stream of is into a stream of os in monad m; Sink i m r = takes a bunch of is and finally produces an r in monad m, then stops
11:39:18 <elliott> (and they're all based on a single Pipe type, similar to that of pipes)
11:39:24 <nyingen> sounds promising.
11:39:43 <elliott> then there's just (=$=) to plug two together (and the "legacy" special cases ($=) and (=$) which only work with sources and sinks, before they were all unified)
11:39:56 <elliott> and ($$) to go from source + sink --> final result
11:40:27 <nyingen> sounds like the 'enumeratee' analogue would be a bit simpler in this paradigm
11:40:40 <elliott> standard combinators are in Data.Conduit.List, Data.Conduit.{Binary,Text} for ByteString and Text respectively, and you can write manual stuff using await + yield and do notation
11:40:45 <elliott> nyingen: Conduit correponds to enumeratee, I think
11:40:49 <nyingen> cool
11:40:53 <nyingen> elliott: thanks for the advice
11:40:57 <elliott> np :)
11:41:06 <elliott> yeah, Enumeratee is Conduit
11:41:18 <elliott> nyingen: oh, and ignore things like sourceState
11:41:29 <elliott> it's legacy stuff that's a lot uglier than using do notation and await+yield
11:41:38 <elliott> (but the sequencing stuff is useful still)
11:42:14 <elliott> nyingen: ...finally, you'll usually want to use ResourceT IO as the monad you run things in
11:42:23 <elliott> since that's what the standard file sources etc. do
11:42:29 <Janni> Hello.
11:42:37 <elliott> (but you can just use MonadResourceIO iirc)
11:42:51 <elliott> oh, monadresource requires monadio
11:42:54 <elliott> so just MonadResource then
11:42:58 <elliott> ok, i think that's it :p
11:46:41 <jeff_s_> If I have a function with N arguments, is there a quick way to apply one value to all N arguments?
11:46:57 <jeff_s_> er, apply the function to the same value N times. SOmething like that.
11:47:44 <mm_freak> jeff_s_: try to write the type of that application combinator
11:48:13 <jeff_s_> I'm thinking that means no...
11:48:20 <mm_freak> jeff_s_: just try it
11:48:32 <mm_freak> if you succeed you have your combinator
11:48:39 <mm_freak> if you fail you will understand why
11:49:07 <Janni> Does anyone know whether there is a class -- let's call it Arity -- of which all the tuple types are instances of? Such that I can determine the arity of a tuple by saying "arity (undefined :: (a,b)" which should yield 2?
11:49:12 <elliott> Janni: no
11:49:18 <elliott> Janni: the report does not even require more than 16-tuples iirc
11:49:25 * elliott thinks all questions like "is there a function to do abstract task X" should be required to come with a type signtaure :) (re mm_freak)
11:49:51 <mm_freak> jeff_s_: in haskell "is there a function X?" often boils down to "can you write a type for X?"
11:50:07 <mm_freak> s/often/almost always/
11:50:09 <clsmith> well, "is the a function" implies prelude
11:50:12 <clsmith> *there
11:51:01 <jeff_s_> Yes, of course. I'll just write the quick and dirty version. I doubt anything fancier will be any better.
11:51:11 <EvanR> Janni: ok but if your function takes type a where a is instance of Arity, all youll be able to do with it is check the arity
11:51:38 <Janni> Hmm. Not even a class which abstracts over the set of all possible tuple types?
11:51:39 <mm_freak> jeff_s_: i give you a hint…  the function you want, if possible, has two arguments, the first of which is a function
11:51:41 <Janni> EvanR: Yes.
11:51:45 <elliott> Janni: just don't use tuples
11:51:49 <elliott> above size two, at least
11:51:59 <mm_freak> jeff_s_: so your function would have the type:  (? -> b) -> a -> b
11:52:01 <elliott> but no, there is no abstraction over all tuples, there is not even a guarantee many tuple types exist
11:52:04 <EvanR> all you need is 2
11:52:05 <elliott> GHC only supports up to size 62, I think
11:52:06 <mm_freak> now fill in the question mark =)
11:52:11 <EvanR> (a,b) (a,(b,c)) ;)
11:52:15 <elliott> mm_freak: er, I think not.
11:52:38 <elliott> what is "a"?
11:52:52 <monochrom> instance Arity Int where arity _ = 42  -- just for the sake of it
11:53:02 <tromp> > 5* product [1..9]
11:53:03 <lambdabot>   1814400
11:53:07 <elliott> monochrom: so Ints are 42 bits?
11:53:15 <elliott> or are they a tuple of something else :)
11:53:18 <monochrom> 42 arities
11:53:21 <nand`> EvanR: (a,(b,c)) and (a,b,c) are not-so-subtly distinct
11:53:30 <monochrom> @quote 17-arity
11:53:31 <lambdabot> No quotes match. My mind is going. I can feel it.
11:53:37 <monochrom> @quote 17-ary
11:53:37 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
11:53:38 <jeff_s_> :t (,,,,,,,,,,,,)
11:53:39 <lambdabot> forall a b c d e f g h i j k l m. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
11:53:50 <mm_freak> elliott: imagine a function that applies a value to a function as many times as the arity of the function…  please don't reveal whether that's possible…  it's jeff_s_' mission to figure that out =)
11:53:53 <EvanR> nand`: yeah but you can represent all (A,B,C) with (A,(B,C))
11:53:57 <elliott> uhh
11:54:00 <elliott> mm_freak: when did jeff_s_ say arity?
11:54:07 <elliott> oh!
11:54:12 <elliott> i totally misread his question. sorry.
11:54:19 <nand`> EvanR: yeah; it's just that boxing rules are completely different, seq (A,(B,C)) is not the same as (A,B,C)
11:54:20 * elliott shuts up
11:54:24 <nand`> seq (A,B,C) even
11:54:31 <mm_freak> no worries =)
11:54:34 <EvanR> nand`: meh pesky seq crap
11:54:37 <elliott> EvanR: you need a strict tuple to do that
11:54:43 <hiptobecubic> I'm still not getting this 'overload' idea
11:54:54 <elliott> otherwise (a,_|_) and (a,(_|_,_|_)) both correspond to (a,_|_,_|_)
11:55:02 <elliott> hiptobecubic: what overload idea?
11:55:16 <EvanR> pesky _|_
11:55:28 <jeff_s_> _|_ looks just like my _|_.
11:55:55 <hiptobecubic> I have a data type with two fields, say. 'start' and 'end'. I have two other data types, one has those two fields and also a 'mid' field, the other has those two and a 'pre' field
11:55:57 <mm_freak> well, ⊥ powers most programming languages, so it must be good for something =)
11:56:15 <EvanR> so powerful!
11:56:29 <hiptobecubic> I was trying to find a way to have the commonalities captured in some kind of 'parent' type that the second two types inherit
11:56:51 <hiptobecubic> earler, merijn said "Usually you can just do things like "data Foo = Foo <bunch of fields here>" and if you have two data types bar/baz "inheriting" it use "data Bar = Bar Foo <other fields>" and "data Baz = Baz Foo <other fields>", although it depends on exactly how you plan to use things"
11:57:12 <hiptobecubic> but I don't see how that works, semantically
11:57:21 <tromp> > 4^9
11:57:22 <lambdabot>   262144
11:57:33 <elliott> hiptobecubic: data Line = Line { start :: T, end :: T }
11:57:35 <hiptobecubic> also it doesn't type check here, but that's probably because i'm doing wrong because I don't quite get it
11:57:44 <elliott> hiptobecubic: data LineWithPointHighlightedOrSomething =  LineWithPointHighlightedOrSomething Line T
11:57:47 <elliott> etc.
11:57:52 <elliott> there is no inheritance, no parents
11:58:06 <elliott> there is only composition and aggregation of types (and ad-hoc overloading through typeclasses, but it is unlikely you want that here)
11:58:07 <mm_freak> hiptobecubic: note that you need to compose the field accessors
11:58:17 <elliott> right, you'll need (start . line) or such
11:58:28 <hiptobecubic> ah ok
11:58:44 <mm_freak> hiptobecubic: using lenses you can do this elegantly with a type class
11:58:45 <donri> needs moar lenses
11:58:49 <elliott> hiptobecubic: but, unless the thing with a mid conceptually has the thing with start and end as a part, then the naming concidence is just that, a conicidence
11:58:50 <hiptobecubic> so the Line is 'inside' the LineWithPoint....
11:58:52 <elliott> *coincidence
11:59:03 <elliott> make sure that it is a semantic relation and not just a coincidence before doing this
11:59:08 <elliott> if it is a coincidence, just change the names
11:59:16 <mm_freak> class Line a where start :: Lens a T; end :: Lens a T
11:59:17 <Janni> OK, to give you a hint what I'm aiming at. I have a function "replace :: (Edges -> RHS) -> Rewrite T" where Rewrite is a monad. Using "replace" the user can define a rewrite rule but he might require a (finite) number of edges which the Rewrite-monad supplies him with. In my current implementation Edges is simply a type synonym for [Edge]. The user can now use replace in the following way "replace $ \e1:e2:e3:_ -> ..." to write a rule that re
11:59:20 <hiptobecubic> it's not a coincidence
11:59:43 <elliott> mm_freak: :(
11:59:58 <mm_freak> elliott: something wrong?
12:00:02 <byorgey> Janni: you got cut off after "to write a rule that re..."
12:00:11 <elliott> yes, it's terrible to use typeclasses just to avoid a meaningful composition :)
12:00:25 <t7> mm_freak: what happend with your calculus
12:00:33 <Janni> ...that requires three edges but will of course get an ugly run-time error when he accidentally uses "replace $ \[e1,e2,e3] -> ...".
12:00:42 <mm_freak> elliott: you're just upset that he doesn't get to use this extremely elegant (.) from Control.Category =P
12:00:49 <mm_freak> t7: working on it
12:00:57 <mm_freak> t7: the pi is back =)
12:00:57 <hiptobecubic> To be concrete. I'm making a program that's working with options in the financial sense. They have different properties but they all share some, like having a start and end date, for example
12:01:17 <t7> ah cool pm me a paste when you have something
12:01:20 <elliott> Janni: hmm
12:01:24 <elliott> Janni: is it OK to just have
12:01:24 <Janni> I thought the nicest solution (syntax-wise) for the user would be if he could write "replace $ \(e1,e2,e3) -> ...".
12:01:33 <elliott> nah, that's not the best solution
12:01:40 <elliott> Janni: what if you allow replaces to nest?
12:01:47 <byorgey> Janni: but wouldn't that have the same problem?
12:02:03 <elliott> withEdge :: (Edge -> Replace ()) -> Replace (); replace :: Replace a -> Rewrite a
12:02:03 <elliott> or such
12:02:07 <hiptobecubic> They all have the concept of an 'underlying something' from which the option derives it's value, but these underlyings are not necessarily of the same type. They could be other options, stocks, weather reports, whatever
12:02:11 <elliott> in fact, edge :: Replace Edge might be enough
12:02:34 <Janni> byorgey: The type would then determine the arity. "replace" can therefore generate the correct number of edges.
12:02:35 <mm_freak> t7: i'm still in the de bruijn indices vs. names dilemma
12:02:52 <hiptobecubic> I'm having trouble coming up with a reasonable way to model this problem.
12:02:52 <elliott> mm_freak: bruijn
12:02:53 <elliott> no question
12:02:54 <mm_freak> both have their advantages and disadvantages
12:03:05 <elliott> mm_freak: or bruijn for local, names for global
12:03:13 <byorgey> use locally nameless, it's the best of both worlds
12:03:24 <mm_freak> yeah, makes sense
12:03:29 <elliott> mm_freak: a nice term repr for untyped lambda calculus is data Term a = Var a | App (Term a) (Term a) | Lam (Term (Maybe a))
12:03:35 <elliott> then you use Term Void for terms with no free variables
12:03:39 <elliott> the best part is: it's a Monad
12:03:43 <elliott> and (>>=) does variable binding
12:03:50 <elliott> that's why de bruijn is awesome :p
12:04:05 <mm_freak> elliott: that sounds amazing =)
12:04:11 <mm_freak> thanks for that
12:04:26 <mm_freak> i'll see if i can do this in my typed calculus
12:04:28 <byorgey> Janni: yeah, I think you probably want something along the lines of what elliott was saying
12:04:28 <elliott> dunno how practical it is for bigger languages or whether it has any real-world downsides, mind you
12:04:31 <elliott> but it's really beautiful
12:04:43 <hiptobecubic> in OOP I would just have data members in some base class for the common parts, and each option inherits that and overloads the appropriate functions for evaluation etc. I'm not sure how to handle it in haskell
12:04:46 <byorgey> Janni: basically make a tiny domain-specific language for rewrite rules
12:05:06 <Janni> elliott, byorgey: Yeah I get it. Thanks for the hint. I'm considering it...
12:05:19 * elliott takes back his suggestion of the withEdge version of that DSL, btw
12:05:29 <elliott> (you can trivially turn it into the nicer edge version with ContT)
12:05:33 <elliott> (so there's no point exposing that API)
12:05:55 <elliott> Janni: you might find applicative notation helpful there too
12:06:03 <elliott> replace (f <$> edge <*> edge <*> edge)
12:06:05 <elliott> is like
12:06:11 <elliott> replace (\(a:b:c:_) -> f a b c)
12:06:28 <elliott> actually, replace should be :: Replace RHS -> Rewrite T, but I guess that's obvious
12:08:21 <jeff_s_> mm_freak: I think the best I could do is write one function that I apply N times, which is kind of silly... I suppose template haskell could do it, but I'm not going there.
12:08:54 <stepkut> can this function be implemented, first' :: (Functor m, Monad m, Functor n, Monad n) => (m a -> n a) -> (m (a, x) -> n (a, x))
12:08:56 <mm_freak> jeff_s_: at this point you might see why we have zipWith, zipWith3, zipWith4, etc. =)
12:09:30 <elliott> stepkut: no
12:09:38 <elliott> stepkut: but (forall a. m a -> n a) -> (m (a, x) -> n (a, x)) can
12:09:41 <elliott> which is probably what you really meant
12:10:06 <stepkut> elliott: maybe
12:10:17 <rwbarton> given the name "first'" rather than "id" i doubt it
12:10:31 <elliott> oh, indeed
12:10:37 <elliott> hmmm
12:10:41 <elliott> yeah, can't be done
12:10:53 <elliott> consider n = Identity, a = ()
12:10:59 <elliott> (m a -> Identity ()) is trivial
12:11:05 <elliott> but works with arbitrary m
12:11:10 <stepkut> I should ask my real question I guess
12:11:16 <elliott> then you get m ((), x) -> Identity ((), x)
12:11:16 <stepkut> this function exists: mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:11:18 <elliott> which is a magic run-any-monad function
12:11:34 <stepkut> is it possible to write: mapStateT' :: (m a -> n b) -> StateT s m a -> StateT s n b
12:11:42 <elliott> no
12:11:48 <elliott> again, pick n = Identity, b = ()
12:12:04 <elliott> mapStateT' (const (return ())) :: StateT s m a -> StateT s Identity ()
12:12:09 <elliott> where did the m go?
12:12:24 <t7> what did you do with n?
12:12:28 <elliott> hmm, that function is actually trivially possible to write
12:12:32 <t7> where did you hide m?
12:12:41 <elliott> t7: eh? I set n to Identity
12:12:48 <elliott> anyway, my counter-example doesn't quite work there
12:13:13 <stepkut> elliott: not sure I follow.. why doesn't that apply to the normal mapStateT ?
12:13:19 <stepkut> which definitely exists
12:13:29 <elliott> stepkut: because that contains the (s, ) -- anyway my counterexample doesn't work there
12:13:32 <elliott> but just rewrite StateT as its definition
12:13:50 <elliott> (m a -> n b) -> (s -> m (a, s)) -> (s -> n (b, s))
12:13:53 <elliott> hmm
12:14:03 <elliott> you can write a function with that type
12:14:07 <elliott> but it won't do what you want
12:14:22 <stepkut> oh ?
12:14:50 <stepkut> I just want a version of mapStateT that doesn't let the user modify the state
12:15:19 <elliott> stepkut: are you sure you don't want (forall a. m a -> n a) then?
12:15:29 <elliott> then fmap afterwards
12:15:41 <copumpkin> zomg NatTrans m n
12:15:59 <stepkut> elliott: i suppose..
12:16:01 <mm_freak> elliott: not sure whether i got it…  what does x >>= f mean?
12:16:07 <mm_freak> for Expr
12:16:11 <mm_freak> or Term as you call it
12:16:12 <elliott> mm_freak: f is the "dictionary"
12:16:15 <copumpkin> mm_freak: substitution
12:16:16 <elliott> thing of (->) as a lookup table
12:16:23 <elliott> (Void -> a) -- there are no variables, so you just pass absurd
12:16:26 <stepkut> elliott: I have done it that way before..
12:16:30 <elliott> (Maybe Void -> a) -> maybe myBinding absurd
12:16:34 <stepkut> the forall a. version
12:16:48 <elliott> (Maybe (Maybe Void) -> a) -> maybe myBinding (maybe myOtherBinding absurd)
12:16:50 <elliott> and so on
12:16:53 <mm_freak> can you give an explicit example?
12:16:57 <elliott> Nothing is 0
12:17:01 <elliott> Just is S, think of it like naturals
12:17:04 <elliott> mm_freak: sure
12:17:04 <Janni> elliott: While I can appreciate the beauty of your solution, I'm not completely happy with it, simply because it requires more code of the user. For my problem "edge <*> edge <*> edge <*> edge" carries no more information than the numeral 4 on the type level, because I (currently) see no purpose of any inhabitants of the type Replace you suggested other than "edge"...
12:17:06 <stepkut> converting the 'm' to an 'n' is the most important goal.. just seems odd that you can only do a -> b if you also permit the user to do s -> s
12:17:15 <elliott> Janni: sure you do, you have Monad
12:17:31 <elliott> Janni: (<*>) proves you have more inhabitants
12:17:38 <elliott> mm_freak: ok, so
12:17:55 <elliott> mm_freak: Apply (Var Nothing) (Var (Just Nothing))
12:17:56 <elliott> is
12:17:58 <elliott> (0 1)
12:18:17 <copumpkin> eww
12:18:25 <elliott> Apply (Var Nothing) (Var (Just Nothing)) >>= \v -> case v of { Nothing -> binding for 0; Just Nothing -> binding for 1; Just (Just void) -> impossible, bail out, call (absurd void) }
12:18:31 <elliott> -->
12:18:35 <elliott> Apply (binding for 0) (binding for 1)
12:18:37 <copumpkin> why not use Nats and Fins?
12:18:46 <elliott> copumpkin: because it makes the type simpler
12:18:53 <elliott> and lets you have a Monad
12:19:04 <elliott> copumpkin: data Term a = Var a | Apply (Term a) (Term a) | Lambda (Term (Maybe a))
12:19:09 <copumpkin> oh
12:19:30 <copumpkin> fair enough, I guess :P
12:19:38 <elliott> mm_freak: you can of course just replace one variable by doing
12:19:45 <elliott> \v -> case v of { thespecificvariwant -> binding; _ -> v }
12:19:47 <elliott> erm
12:19:48 <stepkut> maybe I should just forall the s.
12:19:49 <elliott> \v -> case v of { thespecificvariwant -> binding; _ -> Var v }
12:19:56 <elliott> stepkut: yeah, that would work too
12:20:18 <mm_freak> elliott: i don't see the advantage of this…  it seems like more to type
12:20:27 <elliott> mm_freak: compared to what?
12:20:33 <elliott> the main advantage is, your types keep you honest
12:20:37 <elliott> a term with a free variable cannot pose as a term with none
12:20:44 <mm_freak> i see
12:20:49 <elliott> there is no possibility of runtime failure because you said (Var 42)
12:20:50 <elliott> and tried to evaluate it
12:21:40 <mm_freak> do i want Maybe here or would Nat be preferable?
12:21:44 <elliott> you want Maybe
12:21:52 <elliott> it wouldn't work without it
12:21:56 <elliott> mm_freak: also, there's a really short definition of evaluation with this type
12:21:58 <elliott> but i forget what it is
12:23:13 <elliott> mm_freak: you can define your own types if you want though
12:23:15 <elliott> but it'd be kinda pointless
12:23:23 <elliott> data NoFree; data OneFree a = OneFree a
12:23:34 <elliott> Term (OneFree (OneFree NoFree))
12:23:42 <mm_freak> hehe
12:23:44 <elliott> well
12:23:47 <elliott> data Z; data S a = S a
12:23:48 <elliott> might work
12:23:51 <elliott> since it makes using Var shorter
12:24:15 <mm_freak> i'm still not sure whether i've really understood it
12:24:24 <mm_freak> let me try it out
12:24:36 <elliott> easiest way to understand it is to implement the instances and a few functions for untyped lc
12:24:57 <elliott> and try to see how it stops you using more free variables than you declare
12:25:06 <elliott> mm_freak: oh, gadt form might help too
12:25:09 <elliott> Lam :: Term (Maybe a) -> Term a
12:25:16 <elliott> i.e. give me a term with a free variable, and I'll wrap it in a lambda
12:25:17 <mm_freak> i've written it in GADT form anyway
12:25:23 <elliott> (making it not so free)
12:25:32 <mm_freak> oh!
12:25:38 <mm_freak> that last statement helped =)
12:26:23 <elliott> (if you have globals, you can deal with them by simply adding | Name String)
12:26:37 <elliott> (then evaluation gets a Map String (Term Void) context)
12:26:47 <monochrom> yikes, the type counts the number of free variables
12:26:55 <mm_freak> i think i got it
12:27:14 <mm_freak> Var Nothing is a term with a free variable
12:27:24 <mm_freak> then Lam (Var Nothing) binds it
12:27:29 <elliott> right
12:27:30 <elliott> 0 and (\0)
12:27:40 <monochrom> the result has no more free variable
12:27:55 <elliott> it is probably better to use data Void; data Succ a = Succ a now that I think about it
12:27:59 <elliott> makes Var literals a lot less confusing
12:27:59 <elliott> erm
12:28:01 <elliott> *data Zero
12:28:07 <monochrom> you are evil :)
12:28:55 <elliott> monochrom: thanks!
12:29:01 <elliott> I don't think I invented that representation though
12:29:47 <monochrom> I am more evil. last night I thought up evil material for next year's April 1st
12:30:21 <mm_freak> i'd use DataKinds and data Scope a = Void | Succ a
12:30:23 <monochrom> there are technical difficulties. I have 11 months to solve them
12:30:24 <mm_freak> does that make sense?
12:31:04 <elliott> mm_freak: mmmm not sure that will work
12:31:07 <monochrom> or else GHC new versions have to unfold changes that solve them :)
12:31:10 <elliott> remember that Monad demands you be polymorphic
12:31:16 <elliott> and if you use Succ in your type decl, it won't have kind * -> *
12:31:22 <elliott> it'll be Scope AnyK -> * or whatever
12:31:29 <elliott> maybe PolyKinds fixes that
12:31:33 <elliott> in which case sure, but use Zero not Void
12:31:33 <mm_freak> elliott: it's the same as what you defined…  i just let GHC lift that thing to the type level =)
12:31:40 <elliott> mm_freak: yes, but the kind differs
12:31:41 <mm_freak> oh
12:31:44 <elliott> however
12:31:46 <mm_freak> yeah, true
12:31:46 <elliott> with PolyKinds it might be ok
12:31:49 <elliott> not sure, try it out
12:32:08 <elliott> oh wait
12:32:10 <elliott> mm_freak: no, it won't work
12:32:14 <elliott> because you need to use Zero/Succ at the value level
12:32:17 <elliott> and to have them have the matching types
12:32:27 <elliott> but lifted types don't have values
12:32:27 <monochrom> anyway have you seen my http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065 ? :)
12:32:34 <mm_freak> i see
12:32:41 <dolio> Did they really use "AnyK"?
12:33:00 <mm_freak> elliott: is there an article about that representation somewhere?
12:33:13 <elliott> dolio: yes, that is how it is displayed :(
12:33:18 <elliott> apparently that's being fixed in 7.6
12:33:23 <elliott> mm_freak: I don't know, sorry -- but almost certainly
12:33:31 <elliott> mm_freak: I don't even remember where I found it, or whether I reinvented it independently
12:33:35 <mm_freak> there is…  found a few =)
12:33:39 <elliott> but I've stuck to it since
12:33:40 <dolio> "Any" is the reason you use formal logic.
12:33:48 * elliott is interested in links too
12:34:54 <dolio> Is any man mortal?
12:34:57 <dolio> Is any swan white?
12:35:16 <mm_freak> elliott: there is a paper by richard bird and ross paterson
12:35:22 <mm_freak> http://www.soi.city.ac.uk/~ross/papers/debruijn.html
12:35:44 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
12:36:20 <dolio> I thought that was you.
12:36:22 <monochrom> is anyone going to explain to me how to go from IO String to IO? :)
12:36:35 <elliott> mm_freak: yep, that's it
12:36:50 <monochrom> yes, I wrote it
12:36:58 <elliott> mm_freak: ahhhh, my definition was wrong
12:36:59 <elliott> it should be
12:37:10 <elliott> data Zero; data Succ a = Zero | Succ a
12:37:11 <elliott> how confusing!!
12:37:37 <mm_freak> elliott: what do you need the Zero type for?
12:37:45 <elliott> mm_freak: for terms with zero free variables
12:37:48 <elliott> it's your top-level type
12:37:53 <elliott> eval :: Term Zero -> ...
12:37:56 <monochrom> it thus pain me when in math channels the experts answer beginners about "for all" by putting all the emphasis on "any"
12:37:57 <mm_freak> ah, i see
12:38:08 <clsmith> i found the type-checked de bruijn indices fascinating. that is amazing.
12:38:12 <elliott> mm_freak: admittedly, eval could probably be Term a -> Term a
12:38:19 <elliott> mm_freak: and just keep terms with free variables intact
12:38:21 <elliott> but eh
12:38:25 <clsmith> and it's a nested data type monad. really strange
12:38:26 <mm_freak> elliott: well, let me read the paper first
12:38:33 <elliott> probably for the best :)
12:38:41 <mm_freak> thanks for that pointer, it's really intriguing =)
12:38:50 <mm_freak> ⇐ is reading now
12:38:53 <elliott> no problem :) any chance to evangelise my favourite representation!
12:40:33 <dolio> monochrom: Your last example isn't intuitionistically valid. :)
12:40:51 <monochrom> I love classical logic!
12:41:35 <elliott> mm_freak: bah, their definition of joinE is really ugly
12:41:47 <elliott> (defining (>>=) is really simple, in fact)
12:42:03 <elliott> well, joinE isn't ugly. but gfoldE is
12:42:42 <monochrom> recently my new philosophical objection to intuitionistic logic is that its semantics are (we know several) less intuitive
12:42:46 <Spockz> elliott: what are you guys talking on?
12:43:05 <elliott> Spockz: a nice representation for the untyped lambda calculus
12:43:15 <elliott> monochrom: "we know several"?
12:43:26 <monochrom> Heyting, Kripke, ...
12:43:43 * elliott thinks your sentence does not really pars.e
12:43:45 <elliott> *parse.
12:44:00 <Spockz> irc is like ruby in that way :)
12:44:34 <johnnowak> hello all. is there a way that I can coerce cabal/ghc into having two versions of a package with the same name installed? I'm in an impossible situation where two packages require different versions of the same package.
12:44:37 <monochrom> we know several semantics of intuitionistic logic. all of them are less intuitive than the usual semantics of classical logic
12:45:03 <Spockz> johnnowak: I didn't know that was a problem?
12:45:18 <monochrom> I also know how to object to my objection, but I'm keeping that secret for now :)
12:45:22 <johnnowak> it appears to be a problem
12:45:34 <Spockz> johnnowak: if you set the constraints correctly in the cabal file then building the package should go okay
12:45:37 <acowley> johnnowak: great answer
12:45:41 <dolio> johnnowak: There's no problem with them being installed. There's just a problem with a single build using both.
12:45:52 <acowley> johnnowak: Are you trying to depend on two versions simultaneously with a new library/exe?
12:46:07 <dolio> There's a summer of code project this year trying to fix that, apparently, but I wouldn't get your hopes up.
12:46:13 <Spockz> ah your package is depending on said two packages that depend on a different version of just another package? :)
12:46:22 <dcoutts> dolio: not quite
12:46:34 <johnnowak> my problem is that i've got agda installed and i want to install idris. i get the following: http://heap.johnnowak.com/2012/04/25/cabal-idris.txt
12:46:44 <dolio> dcoutts: Which?
12:46:46 <dcoutts> dolio: that's about installing multiple instances of the same version of a package at the same time (not using them at the same time)
12:46:46 <johnnowak> it looks to me like i've got a version conflict
12:46:57 <dolio> Oh, okay.
12:47:11 <elliott> johnnowak: it depends on an older mtl indirectly
12:47:19 <elliott> johnnowak: try --avoid-reinstalls?
12:47:24 <dcoutts> dolio: you're thinking of encapsulated dependencies
12:47:30 <elliott> ah
12:47:31 <elliott> no
12:47:36 <elliott> haskeline just doesn't do mtl 2.1
12:47:48 <elliott> johnnowak: the easiest thing may be to cabal unpack haskeline
12:47:52 <elliott> and loosen its mtl dependency to <2.3
12:47:54 * monochrom applauds the new warning and subsequent refusal of "The following packages are likely to be broken by the reinstalls"
12:47:58 <elliott> then cabal install that
12:48:00 <johnnowak> elliott: that appears to work. does this mean I'll have multiple versions of installed correctly?
12:48:01 <dolio> dcoutts: Is that for, for instance, installing foo-1.0 with bar-1.0 and bar-2.0 in case baz needs foo-1.0 and bar-1.0, and quux needs foo-1.0 and bar-2.0?
12:48:07 <elliott> johnnowak: yikes, cancel that
12:48:10 <Spockz> johnnowak: do you have the newest cabal :)
12:48:12 <elliott> it'll be doing something insane to avoid the reinstall
12:48:22 <elliott> johnnowak: do what i said instead with haskeline. if that breaks, haskeline will need patching
12:48:30 <dolio> dcoutts: And foo doesn't care whether it has bar-1.0 or bar-2.0.
12:48:31 <acowley> I have idris, mtl 2.*, and haskeline all installed.
12:48:44 <acowley> ah
12:48:59 <acowley> I have mtl-2.0.1.0
12:49:07 <acowley> haskeline is just slightly too tight
12:49:15 <elliott> johnnowak: anyway, hopefully once you have a relaxed haskeline installed, it'll just work
12:49:23 <elliott> you should probably contact the maintainer about it
12:49:25 <johnnowak> i would just like a clear answer on if i can have multiple versions of the same package installed or not
12:49:49 <johnnowak> not sure i understand if that's okay or not
12:49:58 <dcoutts> dolio: yes, but crucially baz and quux must not expose in their interfaces and types defined in bar
12:49:59 <acowley> johnnowak: Yes, you can. The problem is that you can't have multiple instances of the same version but built against different dependencies installed.
12:50:04 <elliott> johnnowak: yes, but in this case, you do not want it
12:50:10 <dcoutts> dolio: erm, and/any
12:50:14 <elliott> note how cabal says all your packages are going to break if you do :)
12:50:22 <johnnowak> okay, i understand the issue i'm having now.. thanks guys
12:51:10 <dcoutts> monochrom: kosmikus and I discussed the behaviour of that quite a bit, the reinstall/breakage check
12:51:31 <dcoutts> monochrom: so I'm glad you like it
12:51:51 <monochrom> so now I have to update my page...
12:52:12 <dcoutts> monochrom: we could have gone for something more conservative still, since strictly speaking we don't always know what packages could be broken
12:52:28 <dcoutts> monochrom: e.g. if you're installing into global, we don't know if we'll break user packages
12:53:03 <dcoutts> monochrom: but it's a usability tradeoff, otherwise it'd have to warn every time anything were reinstalled
12:53:13 <dolio> dcoutts: Why would it matter if baz and quux did that? Or are you talking about the multiple versions of bar in a single dependency graph thing?
12:53:20 <jfischoff> I need to represent a the object graph from a object oriented language in Haskell, and I can't shake this feeling I am doing it wrong. Anyone have a elegant way to represent an OO object graph?
12:53:21 <dolio> I meant the current project.
12:53:46 <dcoutts> dolio: didn't your example involve one package indirectly depending on bar-1.0 and bar-2.0?
12:54:22 <dcoutts> monochrom: so you may like to note that corner case on your page
12:54:48 <dcoutts> monochrom: that it does not check for breakage in package dbs it's not been told to look at
12:55:04 <Spockz> elliott: I'm currently designing a (data) reactive framework. I understand you called that `adaptive' before?
12:55:13 <dolio> dcoutts: No. I meant I want to install both bar and quux, separately. bar requires foo-1.0 and bar-1.0, and quux requires foo-1.0 and bar-2.0, so that would require having both foo-1.0 with bar-1.0 and foo-1.0 with bar-2.0 installed, if I'm not mistaken.
12:55:29 <dolio> Er, "install both baz and quux."
12:55:32 <elliott> Spockz: I'm not sure what you mean
12:55:50 <dolio> Is that what the current project is trying to solve?
12:55:58 <dcoutts> dolio: oh then you need the "multiple instances of the same package version" thing, that's the nix-style persistent package store
12:55:59 <Spockz> elliott: didn't you write a paper on adaptive/reactive frameworks?
12:56:29 <dcoutts> dolio: if you had a package that depended on both bar and quxx then you would also need encapsulated dependencies
12:56:36 <dolio> Right.
12:56:44 <dolio> And the nix-style store is what's being done now?
12:56:49 <dcoutts> dolio: yes
12:56:55 <dolio> Okay. I get it.
12:57:00 <johnnowak> i wonder if cabal could avoid this problem i'm having by disallowing a package X from depending on a package Y and the specifying any dependencies that are version restrictions of those required by Y... seems like you'll be bound to run into this issue otherwise
12:57:23 <elliott> Spockz: I think you want conal
12:57:26 <dcoutts> dolio: and the second project is about package environments, the cabal-dev/src/meta/blah use cases
12:57:27 * elliott isn't Conal Elliott
12:57:31 <Spockz> aah :P
12:57:34 <Spockz> Sorry elliott :)
12:57:44 <elliott> don't worry, it's a common mistake; flattering if anything :P
12:57:52 <Spockz> :)
12:58:31 <dcoutts> johnnowak: hmm, seems reasonable that these things are basically independent and you use a solver to find a solution
12:58:38 <acowley> elliott: is your lastname Conal?
12:58:44 <Spockz> elliot: poof and gone is he
12:58:55 <Spockz> elliottt: poof and gone is he
12:59:00 <johnnowak> dcoutts: but then you get this scenario where installing something else later may be impossible
12:59:03 <dcoutts> johnnowak: you may well require a more specific version of some dep than one of your other deps requires it to be
12:59:04 <Spockz> elliott: poof and gone is he (third time is a charm)
12:59:18 <dcoutts> johnnowak: well there's better general solutions to that problem
12:59:44 <elliott> acowley: haha
12:59:53 <johnnowak> dcoutts: such as?
13:00:12 <dcoutts> johnnowak: you mean it becomes impossible without reinstalling existing packages
13:00:34 <dcoutts> johnnowak: and the solution to that is to be able to install multiple instances of the same package
13:00:34 <johnnowak> yes, and possibly breaking ones that are already installed
13:00:49 <johnnowak> multiple instances of the same version of the same package
13:00:52 <dcoutts> yes
13:01:07 <johnnowak> would work
13:01:11 * dcoutts should blog about the distinction between these three things
13:01:32 <monochrom> actually, I tried "cabal install --dry-run idris" just now and it in no way brings in mtl-1.1.1.1. it brings in mtl-2.0.1.0
13:01:40 <acowley> I'm starting to interpret commented-out code I leave in a file as passive aggression directed towards future me.
13:01:51 <acowley> monochrom: that's how it worked for me
13:02:19 <johnnowak> i've got the latest packages and ghc 7.4.1.. not sure why it's just me with the issue
13:02:50 <johnnowak> maybe if i smash the packages i've got and start over it'll go
13:02:54 <monochrom> ok, I only tried with ghc 7.0.3 and 7.0.4
13:03:22 <acowley> I'm on 7.4.1
13:03:53 <acowley> Can't you ask cabal to fill a dependency with a specific version?
13:04:02 <johnnowak> i've no idea
13:04:09 <monochrom> alright, still mtl-2.0.1.0 on 7.4.1
13:04:12 <acowley> something like cabal install idris --constraint=mtl-2.0.1.0
13:04:36 <dcoutts> syntax is pkg == ver, or other operators
13:04:47 <acowley> there you go
13:06:14 <johnnowak> thanks again everyone
13:06:47 <acowley> why does the Enum instance for () not wrap around on succ/pred?
13:07:19 <Botje> it doesn't do that for other Enum instances either.
13:07:19 <monochrom> haskell report forbids wrap-around if both Enum and Bounded are given
13:07:27 <Botje> stupid Enum.
13:08:20 <acowley> monochrom: thanks for the clarification. That kind of stinks.
13:08:50 <acowley> Well, stinks for particular nefarious purposes.
13:09:35 <acowley> Apparently laziness has prevented me from violently discovering that behavior of succ
13:09:40 <acowley> how handy
13:10:18 <monochrom> return (succ ()) >> putStrLn "no error!" :)
13:10:31 <acowley> I never look at that particular value when its type is so uninformative, so I've got a big thunk hiding an exception that I studiously never make eye contact with.
13:11:03 <monochrom> > maxBound :: ()
13:11:04 <lambdabot>   ()
13:11:46 <elliott> acowley: please petition the committee to not outlaw the wrap around
13:11:49 <elliott> and make the standard instances do it
13:11:49 <elliott> thanks
13:12:32 <acowley> elliott: I shall execute political maneuvers of such magnitude that I will *become* the committee, at which point all succs will step!
13:13:00 <elliott> acowley: please do, you sound easier to convince than the committee
13:13:16 <monochrom> if you ask about motivation, most people expect [x..] to be a non-cyclic list.
13:13:19 <acowley> Yeah, I'm pretty easy going. You want your phone number to be 123-4567, too?
13:13:45 <acowley> well I'll be
13:13:50 <acowley> > [()..]
13:13:51 <lambdabot>   [()]
13:14:12 <acowley> I would have guessed that would be an entirely cyclic infinite list
13:14:44 <monochrom> or should I say, the original authors expect most people to expect [x..] to be non-cyclic. (nested modal operators!)
13:14:51 <acowley> my naivete has been pierced
13:15:08 <sclv> > succ (maxBound :: Int)
13:15:09 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
13:15:16 <monochrom> what I will agree to is that the haskell report cannot please everyone
13:15:45 <acowley> I think my issue is that I avoid error whenever possible, and wrapping around for finite types is a simple way to avoid it.
13:15:49 <sclv> remember kids, always succ safely!
13:16:02 <ion> Getting a cyclic list out of [foo..] is trivial, getting a non-cyclic list out of a cyclic [foo..] is annoying.
13:16:03 <rwbarton> next up, 1 / 0 = 0
13:16:08 <acowley> > succ (maxBound :: ())
13:16:09 <ion> > cycle [()..]
13:16:09 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
13:16:09 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
13:16:17 <acowley> How come the error message for () is worse?
13:16:34 <sclv> > (maxBound :: ())
13:16:35 <lambdabot>   ()
13:16:40 <sclv> > succ ()
13:16:41 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
13:16:44 <rwbarton> technically any argument would be bad
13:17:04 <rwbarton> *Exception: Prelude.Enum.().succ: why are you calling me
13:17:29 <monochrom> anyway, my personal opinion is that I want [x..] to be non-cyclic too, so I side with the original authors. and then, I value consistency a lot too, so succ should not cycle either
13:17:31 <ion> “> succ ()” “Nothing”
13:17:41 <acowley> ion: you could do your own takeWhile using maxBound and an equality comparison
13:17:52 <monochrom> and I completely disbelieve in "make every function total"
13:18:03 <sclv> It has to be doing that anyway, otherwise it would hit the exception :-)
13:18:10 <sclv> I do believe in making every function total though.
13:18:21 <sclv> except fromString :-)
13:18:21 <acowley> Your commitment to disbelief must take a lot of faith
13:18:33 <Spockz> sclv: really *every* function?
13:18:56 <hpc> i believe in it being easy to tell when a function isn't total
13:18:58 <sclv> fromString and fromInt should throw exceptions. in fact that's mostly what they should do.
13:19:13 <acowley> I suppose I should use a custom unit type that does not have an instance of Bounded and whose succs wrap.
13:19:16 <acowley> ()'
13:19:20 <sclv> > let fromString = throw in fromString "easy!"
13:19:20 <lambdabot>   Not in scope: `throw'
13:20:06 <sclv> data TrivialIdeal = TrivialIdeal ?
13:20:19 <acowley> indeed
13:20:30 <kallisti> @src (++)
13:20:30 <lambdabot> []     ++ ys = ys
13:20:31 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:20:31 <lambdabot> -- OR
13:20:32 <lambdabot> xs ++ ys = foldr (:) ys xs
13:20:34 <acowley> It sounds fancy, too.
13:20:54 <elliott> sclv: fromString and fromInteger should run at compile time
13:21:01 <elliott> like template haskell except less crap
13:21:08 <sclv> I do all my aritmatic mod 0 -- it me prove so much more.
13:21:23 <elliott> monochrom: I want [x..] to be non-cyclic too
13:21:24 <acowley> Now that you say it, I bet someone has data TrivialIdeal = TrivialIdeal somewhere on hackage. I should pull in something like category-extras to avoid code duplication.
13:21:33 <elliott> monochrom: enumFromTo already needs a condition
13:21:35 <elliott> it can still use succ
13:21:41 <elliott> after all, you can't condition on _|_
13:21:50 <elliott> acowley: category-extras is dead :p
13:21:53 <sclv> elliott: but then it's more work for them to throw exceptions at run time :-)
13:22:14 <monochrom> fromString :: String -> Maybe a : http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22070
13:22:14 <acowley> elliott: all the more reason for me to take it as a dependency for a definition like that!
13:22:33 <monochrom> oh, nevermind, slightly different. but still
13:22:51 <sclv> basically I make all my functions total except for fromString and fromInteger and then whenever I want a partial function I define fromString with an appropriate newtype. that way I keep all the partiality in one safe well defined place.
13:23:14 <elliott> monochrom: haha, that's a terrible idea
13:23:55 <monochrom> the article is suggesting "instance IsString (Maybe MyType)" on a case-by-case basis
13:24:03 <elliott> monochrom: yes, but... it's for literals
13:24:07 <elliott> you'll always just wrap it in fromJust
13:24:14 <elliott> because a programmer never writes a literal and thinks "oh, this is wrong"
13:24:21 <monochrom> yeah, precisely what other people replies
13:25:21 <monochrom> anyway it's an unusually long thread for the GHC mailing list. good entertainment if you want to kill time :)
13:25:53 <elliott> oh, it's not haskell-cafe? that explains the reasonable responses
13:26:03 <monochrom> hahaha
13:26:31 <monochrom> @remember elliott oh, it's not haskell-cafe? that explains the reasonable responses ["it" = GHC mailing list]
13:26:31 <lambdabot> It is stored.
13:27:13 <nejucomo> Is it just me or is this an impossible dependency: Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5
13:27:18 <monochrom> anyway, I shamelessly plug again my contribution, please take it as a joke: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065
13:28:34 <monochrom> but I have some serious intent too. why don't we switch over to list literals for ByteString, since string literals are poor and morally wrong for it
13:29:38 <monochrom> but it's a slippery slope anyway. so in the end I'm fine with calling it a joke
13:30:05 <monochrom> my real big evil joke though, like I said, is reserved for next year's April 1st!
13:30:16 <elliott> monochrom: list literals would be pointless
13:30:26 <elliott> since they're painful and verbose enough that B.pack is no big deal
13:30:28 <sclv> We really should have bytearray literals deep down in the mix. I'd be happy to have them terribly ugly and requiring quasiquotes or the like to generate...
13:30:33 <elliott> the solution is to get rid of the IsString ByteString instance entirely
13:30:43 <elliott> and smite people who still live in an ASCII universe
13:30:54 <elliott> at least it's in .Char8 (aka .EvilAndWrong)
13:30:55 <acowley> ow
13:31:02 <acowley> I think someone just smote me
13:31:51 <monochrom> I agree about getting rid of IsString ByteString. it's only purpose is to please people who are still living in the ascii past
13:32:04 <sclv> 256 characters was good enough for grandpa, and its good enough for me.
13:33:02 <monochrom> or alternatively I go stereotyping and say "people who are still living in the conservative southern US"
13:34:02 <sclv> ಠ_ಠ
13:34:38 <acowley> is that Agda?
13:35:29 <sclv> I'm sure it could be!
13:35:45 <nejucomo> "If God didn't want them us to speak English, he would have put them funny characters in ASCII."
13:36:24 <monochrom> actually what bytearray literal do you envision? I think that's more interesting than my personal worldview :)
13:37:17 <acowley> What I find amusing about unicode in source code is that I end up enjoying writing it more than reading it. Writing it makes me feel clever and subtle; reading it makes me think the author was being obfuscating and obscure.
13:37:51 <Gracenotes> is there a way to show a CReal in another base?
13:38:20 <elliott> Gracenotes: it has RealFloat, right?
13:38:22 <elliott> look at the Numeric module
13:38:27 <Gracenotes> for an arbitrary number of digits
13:38:35 <elliott> (why are you using CReal?!)
13:38:44 <Gracenotes> only because I want an arbitrary number of digits
13:38:55 <elliott> ok, dunno if Numeric will work then
13:39:03 <elliott> Gracenotes: (you realise it's not suitable for general use, right?)
13:39:11 <elliott> equality diverges for equal arguments, etc.
13:39:25 <elliott> are you sure you don't just want Rational?
13:39:31 <Gracenotes> well, I mean, its equality is not actual equality
13:39:42 <elliott> sure it is, it just uses _|_ for True
13:39:48 <Gracenotes> hm. I suppose Rational will suffice, if I can display it to an arbitrary number of digits
13:39:58 <sclv> monochrom: not sure exactly -- something pretty primitive. #{12,344,125,454} or the like. maybe even rougher.
13:40:03 <Gracenotes> elliott: I mean, for plenty of numbers it does return True
13:40:03 <elliott> as long as you don't need to represent pi...
13:40:07 <Gracenotes> not almost all
13:40:13 <elliott> Gracenotes: no it doesn't
13:40:19 <elliott> it always returns False or diverges
13:40:21 <dolio> > 1 == (1 :: CReal)
13:40:21 <lambdabot>   True
13:40:25 <elliott> if you mean the CReal in Few Digits
13:40:25 <elliott> hmm
13:40:27 <elliott> oh
13:40:29 <sclv> the main point is it compiles to the direct bytes, not the syntax.
13:40:34 <elliott> the CReal in numbers compares to a certain number of digits, right?
13:40:37 <elliott> that one's really evil
13:40:39 <Gracenotes> yes.
13:40:57 <Gracenotes> I mean, it represents numbers as functions
13:41:04 <hpc> CReal docs say not to try for exact equality and use epsilon compare
13:41:05 <Gracenotes> very creative
13:41:14 <elliott> creative? it's just the computable reals
13:41:15 <hpc> iirc
13:41:19 <elliott> which is exactly why you really don't want it for real programs :p
13:41:23 <sclv> Gracenotes: take a look at showCReal -- http://hackage.haskell.org/packages/archive/numbers/3000.0.0.0/doc/html/src/Data-Number-CReal.html#showCReal
13:41:35 <Gracenotes> sclv: does that have a base/radix parameter?
13:41:41 <elliott> no
13:41:57 <sclv> nope. but you should be able to figure out how to rewrite it really easily
13:42:10 <Gracenotes> :| spigot algorithm?
13:42:26 <sclv> basically look for everywhere there's a 10 and change it to "base" :-)
13:42:29 <Gracenotes> well, the most trivial kind
13:42:59 <Gracenotes> oh, you mean to access the package internals
13:44:12 <sclv> ah, i notice that pulling out the function inside CR might be hard...
13:45:03 <QF-MichaelK> is there a way to compile and run but not create an executable in my working directory? ghc ... my.hs, perhaps I should use ghci instead if I want to do that?
13:45:49 <Gracenotes> Anyway, on the note of doing X to do Y, I just want to verify properties of (1/9999^2) in other bases
13:46:02 <Gracenotes> I don't want to have to do any hard maths, though >_>
13:46:08 <Botje> QF-MichaelK: there's runhaskell, or you can indeed load your file into ghci and invoke "main"
13:46:33 <Botje> (runhaskell might be called runghc on your system)
13:46:43 <sclv> Gracenotes: no, I think you actually want to patch the numbers library. clearly :-)
13:46:56 <Gracenotes> 1/9999^2 = 0.0001000200030004 ... 00100011001200130014 ... 0145014601470148 ... 567856795680 ... etc.
13:47:06 <QF-MichaelK> Botje: runhaskell works, thanks, that's exactly what I was looking for.
13:47:55 <sclv> there are also the AERN packages which are apparently more serious than CReal, but I dunno if htey have base functions either.
13:48:10 <sclv> I do suspect that rationals sound more reasonable.
13:48:49 <Gracenotes> it is definitely a rational number. but I want all of the digits. until it repeats.
13:48:52 <sclv> but even then you probably need to write yr. own algorithm to get the digits out in the proper bases
13:49:59 <elliott> Gracenotes: you should really just use Rational :)
13:50:42 <byorgey> Gracenotes: I think I have some code to get the repeating portion of a decimal expansion, I can try to dig it up if you like
13:51:10 <byorgey> it's not very complicated, basically just simulate the usual long division algorithm and look for repeats
13:51:46 <nejucomo> How can I determine where this nonsensical dependency constraint for Cabal comes from?  base >=4 && <3 && >=2 && <5
13:52:02 <elliott> show us the full cabal output?
13:52:08 <elliott> (are you on the new cabal-install yet?)
13:52:10 <dcoutts> nejucomo: it'll be a conjunction of two constraints
13:52:11 <elliott> (it gives more helpful errors)
13:52:19 <byorgey> neju	what are you trying to do?
13:52:42 <Gracenotes> byorgey: I'm finding that patching CReal, hackily, may just work
13:52:47 <nejucomo> byorgey: I'm running cabal-install's ./bootstrap.sh script.  I've just installed ghc 7.4.1
13:53:01 <dcoutts> nejucomo: it doesn't simplify that constraint because it'd simplify to impossible, so it retains the original elements
13:53:15 <byorgey> whoops, tab-completion fail
13:53:48 <Gracenotes> okay. digitToInt was the wrong tack
13:53:51 <nejucomo> dcoutts: I understand that.  What I don't understand is where the constraints come from.
13:53:54 <Gracenotes> or, other way around
13:54:42 <dcoutts> nejucomo: btw, make sure you're using cabal-install-0.14.0, it's been tested with 7.4.1, including the bootstrap
13:55:14 <nejucomo> Ah, thanks.  I'll try that.
13:58:20 <Gracenotes> gr. I might have to actually understand this code to change it.
13:59:00 <elliott> you realise you could just use its base conversion algorithm on Rationals, right? :o
13:59:02 <elliott> *:p
14:01:14 <Gracenotes> multiplying by a power of the base many times is not actually that hard
14:01:19 <Gracenotes> ...still
14:01:28 <Gracenotes> I assume that's the algorithm
14:05:42 <Gracenotes> okay, it seems to work
14:06:04 <Gracenotes> says 0.25 is 0.4_{16}
14:06:13 <Gracenotes> and 0.01_{2}
14:07:19 <Gracenotes> and, what I was trying to show in the first place does work
14:07:32 <Gracenotes> > showCRealBase 110 16 (1/0xFF^2)
14:07:32 <lambdabot>   Not in scope: `showCRealBase'
14:07:32 <Gracenotes> "0.000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d4"
14:07:40 <Gracenotes> ssh, I wasn't talking to you, lambdabot
14:07:40 <Clint> in attoparsec, how would i discard all input until an action matches?
14:13:30 <nejucomo> Clint: I'm not too familiar with attoparsec specifics, but wouldn't it be something like:  ( myPattern <|> anyByte >> myPattern )   ?
14:17:00 <Clint> nejucomo: why would that work for multiple bytes?
14:17:07 <jajmon> how do i install base-4.5.0.0 ?
14:17:53 <nejucomo> Clint: Sorry, something recursive like:  dropStuffBeforeMyPattern = ( myPattern <|> anyChar >> dropStuffBeforeMyPattern )
14:18:10 <nejucomo> -btw I have no idea about how performant that is.
14:18:13 <jajmon> trying to isntall git-annex with cabal but i'm getting this error message "For the dependency on base >=4.5 && <5 there are these packages: base-4.5.0.0. However none of them are available."
14:18:28 <Clint> nejucomo: that's okay, i can optimize later
14:18:37 <jajmon> any idea what to do? im following these steps http://git-annex.branchable.com/install/OSX/
14:20:34 <sclv> Gracenotes: nice.
14:20:43 <sclv> I'm sure there's a pretty simple proof of why that's the case.
14:20:53 <nejucomo> jajmon: One possibility is to install a new ghc which comes with a new base...
14:21:24 <Clint> jajmon: did you read the comments?
14:22:05 <jajmon> Clint, yup
14:24:03 <jajmon> im not sure what ghc version i need though
14:24:10 <jajmon> 7.0 ?
14:24:23 <jajmon> do i need to compile ghc? >_<
14:24:54 <nejucomo> I'm not sure where to look that information up, but I just installed ghc 7.4.1 and it came with base 4.5.0.0, I believe.
14:25:12 <jajmon> ah yea looks like you need 7.4
14:25:14 <nejucomo> I'd bet there are ghc binary packages, but I'm not certain.
14:25:39 <Clint> nejucomo: thanks, that worked once i changed >> to *>
14:26:19 * nejucomo looks up *>
14:27:20 <nejucomo> How do I search for *> on hoogle?
14:27:43 <nejucomo> Actually, I don't understand the syntax for symbolic binary infix functions…  which character sequences are possible?
14:27:52 <Enigmagic> @hoogle "*>"
14:27:52 <lambdabot> Parse error:
14:27:52 <lambdabot>   "*>"
14:27:52 <lambdabot>   ^
14:27:57 <mauke> nejucomo: http://www.haskell.org/hoogle/?q=*%3E
14:27:59 <nejucomo> Exactly.
14:28:02 <Enigmagic> works on the version i have installed
14:28:09 <mauke> @hoogle *>
14:28:09 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
14:28:09 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
14:28:10 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
14:28:16 <elliott> nejucomo: any sequence of punctuation is allowed
14:28:26 <nejucomo> Ah, I searched for "attoparsec *>" which gave some error.
14:28:26 <elliott> for the definition of punctuation, consult the report
14:28:28 <elliott> anyway
14:28:30 <elliott> @hoogle (*>)
14:28:30 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
14:28:30 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
14:28:30 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
14:28:33 <elliott> enclose infix operators in ()
14:28:38 <JesusIsLord> nejucomo: it's an APplicative thing
14:28:50 <JesusIsLord> nejucomo: attoparsec's parsers are Applicative
14:28:51 <nejucomo> elliott: Are you sure?  I've tried defining ':' before and I thought it failed...
14:28:57 <jajmon> so like, ghc 7.0.4 is the current stable release?
14:28:58 <elliott> nejucomo: yes, (:) is special
14:29:03 <elliott> also, only constructors can start with :
14:29:06 <elliott> it's uppercase punctuation
14:29:21 <dixie> :t map
14:29:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:29:22 <JesusIsLord> data T a b = a :+ b -- e.g.
14:29:26 <dixie> :t fmap
14:29:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:29:33 <nejucomo> Where's a reference on punctuation?  So any sequence can be defined?
14:29:38 <nejucomo> What about ::  ?
14:29:38 <JesusIsLord> nejucomo: the Report.
14:29:40 <elliott> @where report
14:29:40 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:29:44 <elliott> nejucomo: :: is an OK constructor name
14:29:45 <nejucomo> Aha...
14:29:46 <elliott> er
14:29:48 <elliott> no it isn't
14:29:49 <JesusIsLord> no
14:29:51 <elliott> because it's type annotation :)
14:29:52 <elliott> ok ok
14:29:55 <elliott> :, ::, -> are special
14:30:00 <monochrom> the haskell report plus the unicode standard
14:30:00 <JesusIsLord> -- also
14:30:03 <elliott> see http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4 for symbols
14:30:08 <JesusIsLord> {-
14:30:52 <monochrom> there are a few reserved words
14:31:07 <JesusIsLord> jajmon: i'd recommend installing the Haskell platform, which iirc has ghc 7.0.4
14:31:45 <jajmon> JesusIsLord, for git-annex GHC 7.4 is required methinks
14:31:58 <JesusIsLord> oh i dunno about that
14:32:08 <jajmon> so how do i go about installing the platform + ghc 7.4?
14:32:23 <JesusIsLord> i run GHC 7.4.1 personally; i ran into only little trouble
14:32:42 <hpc> jajmon: install ghc + cabal
14:32:48 <jajmon> i've found binaries for 7.4 for mac osx
14:32:49 <hpc> jajmon: cabal install things you need, when you need them
14:32:53 <jajmon> ok
14:33:02 <monochrom> the haskell platform has not been updated to ghc 7.4 yet
14:33:38 <nejucomo> Hm, that report does not say '[' is a reservedop, but I cannot do: let a [ b = (a, b)
14:33:42 <monochrom> the home page says expect one in May
14:33:58 <JesusIsLord> [ is not an operator
14:34:11 <JesusIsLord> it's used for lists and list comprehensions
14:34:52 <JesusIsLord> nejucomo: it's a "special"
14:35:55 <monochrom> symbol -> ... | uniSymbol { except special, _, ", ' }
14:36:31 <monochrom> special -> ... [
14:36:59 <monochrom> please read the grammar rules thoroughly. do not use intuition.
14:48:19 <cg_morton> is it accurate to say that lazy evaluation with foldr is equally as efficient as tail recursion with foldl'?  that's what I'm getting from http://www.haskell.org/haskellwiki/Stack_overflow , just want to make sure I understand
14:48:44 <copumpkin> it's different
14:49:13 <JesusIsLord> no, they are different cg_morton.
14:49:20 <JesusIsLord> foldr produces results "immediately"
14:50:31 <cg_morton> ah right, you get the first result in constant time (assuming it's a non-strict function), right?
14:50:46 <elliott> not necessarily constant
14:50:55 <JesusIsLord> depends on the function
14:51:21 <JesusIsLord> but for instance,  head . foldr id []  is O(1)
14:51:40 <elliott> JesusIsLord: i doubt that types
14:51:42 <elliott> :t head . foldr id []
14:51:43 <lambdabot> forall a. [[a] -> [a]] -> a
14:51:49 <elliott> oh
14:51:57 <JesusIsLord> err, wups.
14:52:00 <JesusIsLord> but yeah.
14:52:11 <JesusIsLord> head . foldr (:) []
14:52:18 <elliott> right
14:55:22 <hpaste_> mog pasted “parsec problem” at http://hpaste.org/67608
14:57:35 <hpaste_> parsec pasted “mog” at http://hpaste.org/67609
14:58:07 <elliott> parsec fights back!
14:58:14 <hpaste_> mog annotated “mog” with “mog (annotation)” at http://hpaste.org/67609#a67610
14:59:18 <tazjin> Cabal just gave me this error:
14:59:21 <tazjin> cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"
14:59:26 <tazjin> any ideas what could cause that?
14:59:46 <mog_> if anyone feels like it, I don't get why the modification I suggest in the annotation isn't legal and I'd appreciate help (first time Parsec): http://hpaste.org/67609
15:00:18 <elliott> @hoogle count
15:00:18 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
15:00:19 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
15:00:19 <lambdabot> Data.ByteString.Lazy.Char8 count :: Char -> ByteString -> Int64
15:00:27 <elliott> hmm, does Parsec actually have a count?
15:00:44 <elliott> mog_: anyway, I bet count takes Parser a and returns Parser [a]
15:00:50 <elliott> so, you can't use it as a Parser a
15:00:55 <elliott> try adding type annotations to all your parsers.
15:00:55 <mog_> hum
15:01:01 <elliott> (you should add type annotations to all top-level declarations)
15:01:06 <elliott> then your mistake, and ghc's errors, will become clearer
15:01:52 <mog_> yeah I guess that'll be a good exercise, but how can I achieve the same thing then? Like repeating 5 times a card in a hand? Sorry if it's a stupid question, it's still totally new to me
15:02:32 <jfischoff> mog_: you would use the "many" combinator
15:02:34 <elliott> well, that will be fine, but you probably need to change line or something
15:02:46 <elliott> ah, so that is what count is
15:02:50 <elliott> it's just replicateM with another name
15:02:51 <elliott> how silly
15:03:02 <elliott> in fact, that's basically how it's implemented
15:03:06 <elliott> you should use replicateM instead :p
15:03:15 <jfischoff> yeah, but I think it is slightly different for a specific count
15:03:45 <elliott> it behaves differently for <= 0
15:03:51 <elliott> but otherwise it's implemented as sequence (replicate n m)
15:03:57 <elliott> I just checked
15:04:20 <mog_> jfischoff: how would I specify 5 instances precisely with a many?
15:04:30 <elliott> you wouldn't
15:04:32 <jfischoff> right
15:04:35 <elliott> and it wouldn't change the type
15:04:37 <elliott> so forget that :p
15:04:41 <mog_> ok ok : d
15:04:49 <jfischoff> its like manyN or something like that
15:04:58 <jfischoff> its near many in the doc
15:05:00 <jfischoff> I think
15:05:08 <jfischoff> :P
15:05:10 <elliott> it's count
15:05:15 <jfischoff> there you go
15:05:17 <elliott> which is what mog_ is using :p
15:05:23 <jfischoff> ha
15:05:26 <jfischoff> whoops
15:05:32 <mog_> then I'll have to adpat my line thingy : ]
15:05:36 <mog_> adapt*
15:05:50 <monochrom> http://www.vex.net/~trebla/haskell/lazy.xhtml
15:06:31 <mog_> actually I just added a layer of [] in my pokerFile type and it's fine.
15:06:35 <mog_> thanks for the hints guys :)
15:06:52 * elliott wasn't hinting, just lazy! :)
15:07:52 <nand`> What's the simplest way to implement (encodeUtf8 :: String -> ByteString, decodeUtf8 :: ByteString -> String) ?
15:08:27 <nand`> I can write encodeUtf8 = Data.Text.Encoding.encodeUtf8 . Data.String.fromString
15:08:49 <nand`> but 1. doesn't this seem a bit roundabout? and 2. how would I write decodeUtf8? I don't see an obvious Text -> String
15:09:01 <JesusIsLord> unpack
15:09:03 <bitonic> is there an enumerator -> conduit conversion guide?
15:09:41 <cg_morton> okay, I've got a proper laziness question.  If you do:   let r = [1,2..]  and then something like  take 500 r  (in ghci so it has to eval and print), then, is r going to store [1,2,3,4,5,6,---,500..] (that is, as far as it was evaluated by take) or will it still be stored as [1,2..]?
15:10:06 <elliott> cg_morton: It is implementation-defined.
15:10:13 <elliott> In almost all implementations, yes, it will remember.
15:10:24 <elliott> When thunks are evaluated, they are replaced with their result (destructively).
15:10:35 <monochrom> we know it's ghci. yes it will store that much
15:11:16 <bitonic> for example, Step include the notion of errors, how does that work in conduit?
15:11:21 <monochrom> the :print command will help you
15:11:52 <elliott> bitonic: just use exceptions in the underlying monad
15:11:57 <elliott> bitonic: ResourceT is MonadBaseControl
15:12:07 <elliott> so use the operators from lifted-base
15:12:12 <elliott> http://hackage.haskell.org/packages/archive/lifted-base/0.1.0.4/doc/html/Control-Exception-Lifted.html
15:12:52 <bitonic> elliott: ok, I was wondering if there was some specific way
15:13:49 <cg_morton> Interesting.  I think there's a limit to how much it will store.  I do    let r = [1,2..]    , then    show r     and my memory usage goes up and up and up, but when I halt it falls back down to 3% higher than when I called show.
15:15:25 <bitonic> lol. bas van dijk surely likes unicode
15:15:51 <mauke> dĳk
15:16:06 * hackagebot openpgp-Crypto 0.3 - Implementation of cryptography for use with OpenPGP using the Crypto library  http://hackage.haskell.org/package/openpgp-Crypto-0.3 (StephenWeber)
15:18:10 <bitonic> elliott: so wait, I'm not sure I get this. When should I use ResourceT?
15:20:09 <monochrom> cg_morton: this time, try "print r"
15:20:54 <jajmon> installing crypto failed. any idea why? http://pastebin.com/Rnq2pjw4
15:20:56 <mauke> The paste Rnq2pjw4 has been copied to http://hpaste.org/67611
15:21:25 <JesusIsLord> jajmon: yeah this is due to the numerical hierarchy changes in GHC 7.4
15:21:41 <bitonic> elliott: it doesn't look like I should need ResourceT at all if I just want to throw/catch errors, right?
15:21:46 <cg_morton> monochrom: huh.  what makes it different?
15:21:50 <hpaste_> “@0nifr” pasted “"guarded instances" (GHC #5590) example” at http://hpaste.org/67612
15:22:07 <jajmon> JesusIsLord :/
15:22:09 <JesusIsLord> jajmon: try to find a patched version or patch it yourself
15:22:14 <JesusIsLord> jajmon: it's not that difficult
15:22:24 <jajmon> well i dont even know haskell
15:23:23 <monochrom> normally, when you enter an expression, not only ghci evaluates and prints the answer, but also binds it to "it" for your future reference. for example, "show r" -> "let it = show r"
15:23:43 <monochrom> this explains the memory growth. the huge string is being stored.
15:24:27 <monochrom> but then you hit ctrl-c, ghci screws "it", that explains freeing up memory
15:24:30 <frontendloader> [(a,b,c) | a<-[1..100], b<-[1..100], c<-[1..100], a^3+b^3==c^3] this doesn't terminate with an empty list?
15:24:44 <JesusIsLord> it should.
15:24:57 <c_wraith> It is a little big
15:25:00 <monochrom> lastly, print r :: IO (), "print r" -> "it <- print r", there is only a () to store
15:25:17 <jajmon> surely someone must have built crypto with ghc 7.4?
15:27:09 <bitonic> jajmon: well, that library is not up to date with 7.4 changes
15:27:21 <bitonic> specifically that Num does not imply Show
15:27:31 <monochrom> lastly for the second time, [Char] is huge. if the length is n, the memory footprint can be n*4*4 or n*4*8 bytes depending on 32-bit or 64-bit platform. "show r" grows much faster than "r"
15:27:33 <JesusIsLord> frontendloader: what is your problem? :)
15:27:46 <jajmon> bitonic actually crypto isnt even listed as a dependency: http://git-annex.branchable.com/install/
15:27:50 <jajmon> :/
15:28:02 <Enigmagic> bitonic: a fair bit of conduit does not require ResourceT. you can use IO directly in a number of cases
15:28:03 <ktosiek> I want to write a simple notification deamon, which dbus package should I look into?
15:28:18 <ktosiek> dbus-core looks promising, but there are some others too
15:28:29 <bitonic> jajmon: it's probably pulled in by something else then :P
15:28:36 <frontendloader> JesusIsLord: My problem might have been related to how haskell deals with lazy evaluation. I had a list l that I was using instead of [1..100]
15:29:00 <frontendloader> I started off at 100k and cranked it down to 10 eventually, but it was still not terminating in reasonable time
15:29:12 <JesusIsLord> it's O(n^3)
15:29:17 <frontendloader> it was probably still stuck at [1..100k]
15:29:50 <frontendloader> the evaluation time isn't the problem, the problem is if I do let l = [1..100000]
15:29:55 <JesusIsLord> it also helps to compile it instead of running it in ghci
15:30:35 <frontendloader> [(a,b,c) | a<-l, b<-l, c<-l, a^3+b^3==c^3] and do this instead
15:30:50 <frontendloader> and them modify l to be smaller and smaller until it should terminate in a reasonable amount of time
15:31:39 <frontendloader> I had that list comprehension stored in a variable
15:31:52 <frontendloader> and was just doing take 1 var
15:32:05 <JesusIsLord> did you rebind your list to the variable?
15:32:19 <frontendloader> no I didn't rebind, I assume that was the problem
15:32:25 <JesusIsLord> because if you don't, it still refers to the "old value" of l
15:32:35 <JesusIsLord> really this is a misnomer. modification does not exist in Haskell.
15:32:45 <JesusIsLord> so what you did was *shadowing*, you really wrote something like
15:33:05 <JesusIsLord> let l = large_list in (let lst = ... l ... in (let l = small_list in take 1 lst))
15:34:17 <JesusIsLord> haskell is lexcially scoped, not dynamically scoped.
15:34:25 <jajmon> bitonic, found a patch http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/dev-haskell/crypto/files/crypto-4.2.4-ghc-7.4.patch?revision=1.1
15:34:36 <jajmon> can i tell cabal to use it?
15:34:54 <JesusIsLord> cabal unpack; cd Crypto-*; apply patch; cabal install
15:35:29 <Enigmagic> someone should just upload a new version of Crypto to hackage already
15:36:20 <elliott> 23:17 <bitonic> elliott: so wait, I'm not sure I get this. When should I use ResourceT?
15:36:23 <elliott> 23:21 <bitonic> elliott: it doesn't look like I should need ResourceT at all if I just want to throw/catch errors, right?
15:36:35 <elliott> bitonic: well, all the standard conduit things prefer ResourceT. it used to be required.
15:36:51 <elliott> if you handle any files... you want ResourceT
15:36:59 <elliott> because of the resource finalisation it offers and which the standard conduit things use
15:41:36 <jajmon> my god
15:41:42 <jajmon> JesusIsLord, that worked.
15:42:16 <JesusIsLord> cool.
15:42:22 <jajmon> now lets see if i can get through the rest of them..
15:43:11 <jajmon> oh-my-god. i now have git-annexed installed!
15:48:24 <monochrom> oh-my-god sounds like a great package name too. cabal install oh-my-god :)
15:48:52 * dcoutts wonders if '!' would work in package names...
15:49:01 <dcoutts> cabal install omg!!!
15:49:14 * dcoutts suspects it might, except on windows
15:50:40 <monochrom> would be great as version numbers too. "selecting omg-!!!!! (hackage or installed), discarding omg-!!!, omg-!!, omg-!.!.!, omg-!.!, omg-!, omg-0.!!!"
15:58:25 <bitonic> jajmon: the eaasiest thing is probably just to edit the relevant file
15:58:35 <bitonic> elliott: ok, I'm reading warp source to have an idea
15:58:45 <JesusIsLord> bitonic: it's been resolved
15:58:49 <jajmon> bitonic, sure, if you know haskell :)
15:59:04 <bitonic> jajmon: ah, you just want to install that application?
15:59:11 <jajmon> yup
15:59:14 <bitonic> why do you have GHC 7.4 in the first place?
15:59:24 <bitonic> the safest bet right now is 7.0.4
15:59:35 <bitonic> expecially if you are not willing to put up with things like this
15:59:48 <jajmon> because 7.0.4 didnt work with git-annex, which is what i wanted to install
16:00:05 <bitonic> jajmon: really? that's weird. so it works with 7.2 only?
16:00:17 <JesusIsLord> no 7.4, the error was in Crypto
16:00:29 <jajmon> this page says 7.4 http://git-annex.branchable.com/install/
16:00:41 <bitonic> jajmon: well but then I'd expect all the deps to work with 7.4 as well
16:00:46 <JesusIsLord> jajmon: unfortunately Haskell is sometimes still a bit immature :(
16:01:08 <JesusIsLord> compared to Java, say
16:01:10 <bitonic> this has nothing to do with haskell bein "immature" :P
16:01:19 <jajmon> bitonic, yea me too. but the patch i found worked
16:01:23 <JesusIsLord> bitonic: why not?
16:01:26 <jajmon> so its all good now
16:01:28 <jajmon> i guess ;)
16:01:42 <JesusIsLord> the language is still evolving and breaking backwards compatibility
16:01:48 <JesusIsLord> which is fine for me, really
16:01:58 <bitonic> JesusIsLord: there is a very stable language, std Haskell
16:02:09 <JesusIsLord> ah yeah, i meant the ecosystem.
16:02:14 <JesusIsLord> haskell proper is quite stable
16:02:14 <bitonic> is up to the devs to use experimental features really
16:02:39 <JesusIsLord> removing the Show constriant is not really a matter of choice
16:02:43 <bitonic> it's definitely not "immature", they're just not scared about pushing new things and breaking things
16:02:58 <JesusIsLord> i said "a bit immature"
16:02:59 <bitonic> JesusIsLord: well yeah, in this case they actually broke std stuff :P
16:03:13 <bitonic> JesusIsLord: I really wouldn't say Haskell is immature in any respect, but ok
16:03:20 <jajmon> isnt breaking things exactly what kids tend to do? ie, the definition of being immature ;)
16:03:33 <gwern> > ((12 * 14) - (0.15 * 12 * 14) + 21 + 5
16:03:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:03:41 <JesusIsLord> well immature has a negative connotation, which i really do not want to attach to Haskell.
16:03:45 <gwern> > ((12 * 14) - (0.15 * 12 * 14)) + 21 + 5
16:03:46 <lambdabot>   168.8
16:04:01 <JesusIsLord> i disagree with avoiding success / breaking stuff to improve the language
16:04:05 <bitonic> jajmon: I prefer a language that moves forward breaking little things like this
16:04:05 <JesusIsLord> err, agree*
16:04:34 <jajmon> sure :)
16:04:47 <cg_morton> gwern: you use IRC as a calculator?
16:05:13 <copumpkin> all the time
16:05:24 <copumpkin> his math is so glorious 900 people must see it!
16:05:26 <elliott> he has a divine right to do so
16:08:39 <gwern> cg_morton: God wouldn't've created #haskell and lambdabot for me if he didn't want me using it as a calculator
16:10:40 <gwern> > ((((12 * 14) - (0.15 * 12 * 14))) - (0.08 * 12 * 14))  + 21 + 5
16:10:40 <lambdabot>   155.36
16:10:50 <gwern> > ((((12 * 14) - (0.15 * 12 * 14))) + (0.08 * 12 * 14))  + 21 + 5
16:10:50 <lambdabot>   182.24
16:26:08 <hpaste_> stj pasted “quicksort ” at http://hpaste.org/67614
16:26:11 <stj> due to lazy evaluation, head . quick is O(n) on average.... can I somehow using function quick get the maximum element in a similiar way?
16:26:29 <JesusIsLord> yes, use quickSortBy ...
16:26:31 <stj> head.quick is much faster than sum.quick, and last.quick is as slow as sum.quick
16:27:02 <elliott> stj: http://apfelmus.nfshost.com/articles/quicksearch.html?
16:27:11 <elliott> that's for minimum, but minimum is just maximum with a reversed comparison :p
16:27:35 <stj> JesusIsLord: I'm more interested in finding out if GHC is smart enough to realize that it can discard the part with smaller elements after partitioning the list
16:27:50 <stj> seems like it isn't, but perhaps I'm missing something
16:28:04 <JesusIsLord> dunno, i never understand performance issues in Haskell tbh
16:28:14 <JesusIsLord> seems unlikely
16:28:40 <stj> elliott: message #3 looks interesting
16:28:52 <elliott> you should read them all :p
16:28:59 <elliott> ok, maybe not the mergesort one
16:29:04 <elliott> but 2 and 3 are relevant
16:29:32 <byorgey> stj: it has nothing to do with how smart GHC is.  Finding the last element of a list requires traversing the whole list, and in order to output the list it has to be sorted.
16:30:05 <byorgey> stj: instead of doing 'last' on quick, parameterize quick by the comparison, and pass it a reversed comparison function to get the list sorted in descending order
16:30:40 <elliott> oh, yeah, last can never work
16:30:48 <elliott> singly linked lists and all that
16:31:09 * hackagebot yesod 1.0.1.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.5 (MichaelSnoyman)
16:31:11 * hackagebot yesod-platform 1.0.3.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.3.3 (MichaelSnoyman)
16:33:07 <stj> so, GHC is not smart enough to figure out the trick
16:34:09 <c_wraith> stj: you mean ghc isn't smart enough to replace functions with ones that do entirely different things?
16:34:17 <c_wraith> stj: because that's what it would take
16:34:19 <stj> elliott: in that case, the claim in message #3 is false
16:34:32 <elliott> that is not true
16:35:06 <elliott> but yes, it is not really about "smartness"
16:35:08 <stj> I have just tested it -- print . (!!999999) . quick $ mkList 1000000 gen
16:35:22 <elliott> either your expectation is wrong, or quick is wrong
16:35:41 <elliott> try it with the qsort from that article
16:35:47 <fmap> why not just use some O(n) selection algorithm?
16:35:49 <stj> (!!999999) . quick is as slow as sum . quick, which is noticeably slower than (!!0) . quick, even (!!1000) . quick
16:35:59 <elliott> stj: uhhh, yes
16:36:01 <elliott> it's O(k)
16:36:07 <elliott> interesting fact: 999999 > 1000
16:36:10 <stj> I see, I will try...
16:36:13 <elliott> :p
16:36:22 <elliott> your behaviour is expected
16:36:51 <c_wraith> also, if you're passing in a list that's already sorted, you'll be getting worst-case behavior
16:37:43 <stj> elliott: I admit it, I was wrong :) my function was indeed much different
16:38:01 <elliott> ok, but your behaviour is still expected, even for the right thing :p
16:38:14 <c_wraith> pay attention to how the pivot is selected and the input list, too
16:38:28 <c_wraith> sorted input with selecting the first element as the pivot guarantees worst-case runtime
16:38:46 <stj> what does this tilda mean? zip2nd (_:xs) ~(y:ys) = y:zip2nd xs ys
16:39:03 <elliott> irrefutable pattern
16:39:04 <JesusIsLord> irrefutable pattern match
16:39:06 <elliott> it's equivalent to
16:39:18 <elliott> zip2nd (_:xs) yss = let y = head ys; ys = tail yss in ...
16:39:23 <elliott> (consider how they differ on [])
16:39:23 <JesusIsLord> zip2nd .. ys' = let (y:ys) = ys' in ...
16:39:37 <JesusIsLord> err no.
16:39:39 <JesusIsLord> ugh
16:39:51 <elliott> hmm, maybe yes actually, isn't let sufficiently lazy like that?
16:40:22 <JesusIsLord> yeah it is.
16:40:26 <shachaf> Yep.
16:40:43 <JesusIsLord> so that might be clearer than using head/tail
16:46:26 <stj> hmm, I'm still puzzled what's the magic behind this zip2nd function, how does it make anything different? can someone elaborate on that?
16:46:46 <JesusIsLord> well a pattern match can fail. an irrefutable pattern match doesn't.
16:47:03 <JesusIsLord> so f (x:xs) ~(y:ys) = ...
16:47:36 <JesusIsLord> will always bind pass if the first value is of the form (x:xs), even if the second value is the empty list
16:47:57 <JesusIsLord> only as soon as the value of y or ys is demanded, a runtime error will occur
16:50:13 <JesusIsLord> as another example, the following is nonsense: f ~(x:xs) = ...; f [] = ...
16:50:22 <JesusIsLord> the second clause is meaningless since the first one will always pass
16:50:24 <otters> what's ~?
16:50:31 <JesusIsLord> otters: irrefutable pattern
16:50:35 <otters> oh
16:50:39 <stj> I see... very interesting
16:50:58 <JesusIsLord> stj: TBH i never used them except when i learned about them; they don't come up that often
16:51:51 <otters> I don't get what irrefutable means
16:52:05 <JesusIsLord> it means it always matches.
16:52:10 <stj> in fact, I think there is no point in using zip2nd on the 'ls' part of the list
16:52:12 <c_wraith> it means it's an error if the data doesn't match the pattern
16:52:17 <otters> oh
16:52:39 <scb> So, should I use haskell for a introduction to compilers/interpreters course?
16:52:44 <JesusIsLord> definitely.
16:53:05 <c_wraith> and the consequence of that is that it doesn't actually check data for matching the pattern until it needs to for you to use a value from it
16:53:07 <scb> I should point out my proficiency with Haskell is the same proficiency I have putting a rocket in mars.
16:53:19 <stj> scb: I can't wait for my course to begin to put haskell to use
16:53:50 <JesusIsLord> scb: i'd love to use haskell for a compiler course.
16:54:07 <JesusIsLord> scb: but obviously if you're not at least a bit comfortable with some basics it'll be a steep learning curve
16:54:27 <stj> c_wraith: isn't that, kind of, a hint to compiler that says: hey, ignore the left part of the list whenever you can.... just what I initially wanted?
16:54:42 <scb> JesusIsLord: What do you call basics?
16:55:05 <JesusIsLord> scb: defining a data type, writing recursive functions, using the basic higher order functions
16:55:15 <JesusIsLord> stj: that happens anyway
16:55:23 <Axman6> we used bison and yacc for the main compiler in our compiler course, but we had a basic lambda calculus compuler in haskell too
16:55:32 <JesusIsLord> stj: length [] = 0; length (x:xs) = 1 + length xs; -- the elements are in fact never evaluated
16:55:46 <scb> JesusIsLord: I guess I am at that point. What scares me to no end is figuring out monads and stuff like that.
16:55:50 <c_wraith> stj: well, it still doesn't help with random access. finding the last element of a list still requires generating all the constructors in the list
16:55:59 <Axman6> since i knew haskell better than the lecturer did, i decided i'd go the monadic route. he wasn't too happy about that
16:56:02 <Twey> Compilers were removed from our course.  Apparently they were too hard & people failed the coursework.
16:56:05 <Twey> :-\
16:56:08 <JesusIsLord> scb: oh, well the parser monad is a really neat monad.
16:56:25 <JesusIsLord> Axman6: haha, i did a networking assignment in Haskell once.
16:56:30 <JesusIsLord> Axman6: the TA was not pleased.
16:56:31 <Axman6> Twey: people are supposed to fail coursework >_<
16:56:37 <Twey> I know.  :-\
16:56:53 <Twey> Axman6: Why wasn't he happy?
16:57:09 <JesusIsLord> scb: i think the RWH chapter on parsing is quite decent
16:57:27 <scb> JesusIsLord: I guess the compiler course won't allow for much beyond Happy. I guess we will have to write the whole Parser+Lexer+Evaluator
16:57:28 <Axman6> Twey: we've been having this debate about the first year course i tutor. i think this semester is going to have a higher failure rate than previous years, and i think this is a good thing. far too many people passed in previous years who shouldn't have
16:57:47 <Axman6> Twey: well, it was supposed to be a single look ahead parser, and mine had backtracking >_>
16:58:21 <Twey> Axman6: Ah.
16:58:38 <scb> JesusIsLord: I have that book. I'll check it out.
16:58:41 <Twey> Axman6: Whereabouts do you live?
16:58:59 <scb> Worst case scenario I fall back to python... but this is such a great opportunity to learn Haskell.
16:59:10 <JesusIsLord> ugh python.
16:59:23 <JesusIsLord> writing compilers is really nice in Haskell
16:59:25 <Axman6> Twey: Aus
16:59:31 <Twey> Axman6: Is it common to change course there?
16:59:51 <JesusIsLord> in fact a haskell-hater told me after the haskell course "yeah Haskell is useful for trees and compilers and math, but for real work, you have to use X"
17:00:08 <Axman6> hmm, not too common i think, but i'm not sure. it's wuite common to start by doing a double degree and drop one of the degrees though
17:00:26 <Clint> trees and compilers and math
17:00:28 <Axman6> JesusIsLord: yeah, no one in the real world uses trees or compilers or maths
17:00:34 <Twey> Heheh
17:00:36 <Axman6> everyone uses objects!
17:00:45 <scb> thats pretty much all computer science =x.
17:00:49 <Twey> Which totally don't involve trees
17:01:00 <JesusIsLord> Axman6: well tbh the haskell course did not teach us how to write "hello world" and even had some CT in it. I loved it, but i can see why some people didn't.
17:01:03 <c_wraith> objects also don't involve graphs
17:01:10 * hackagebot webdriver 0.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.3 (AdamCurtis)
17:01:34 <JesusIsLord> they changed this in later years
17:01:38 <sam7> Can I get some help with my code please? http://hpaste.org/67617
17:02:50 <stj> JesusIsLord: did other students find haskell very difficult?
17:03:17 <JesusIsLord> stj: some got it very quickly, some never learned.
17:03:40 <stj> I'be been learning haskell for 3 months now and still, some things are *very* difficult and deep to me
17:03:40 <JesusIsLord> difficult to say how you will perceive it
17:04:00 <JesusIsLord> stj: people still say that after 3 years, even a decade :)
17:04:10 <stj> for example, what about monads, applicative functors and such things? did they grasp it?
17:04:14 <Twey> Haskell is really easy
17:04:18 <JesusIsLord> oh we didn't even cover that
17:04:22 <Twey> Some of the stuff people *do* in Haskell, on the other hand…
17:04:31 <Twey> 005825 < JesusIsLord> stj: some got it very quickly, some never learned.
17:04:38 <Twey> JesusIsLord: Sounds like computer science in a nutshell.
17:04:44 <JesusIsLord> Twey: pretty much.
17:04:52 <JesusIsLord> at least programming
17:07:17 <stj> that's what I'm concerned about, seems like the difficulty is a dealbreaker... almost noone at my university is interested in haskell, there is a course on it, but of ourse, that's just very shallow haskell
17:07:54 <JesusIsLord> do you understand type classes?
17:08:10 <stj> I do
17:08:28 <JesusIsLord> cool.
17:08:41 <JesusIsLord> i'd say, try to work through the chapter on parsing in RWH. it doesn't use the m-word
17:08:42 <stj> a bit about applicative functors, randoms, and very basic stuff about monads
17:09:51 <stj> sure, but I'd rather learn the m-word very well and go through LYAH first
17:10:07 <JesusIsLord> i also can recommend the typeclassopedia.
17:10:28 <stj> oh yes, I've seen it, awesome, that's the next thing on my list
17:17:15 <sam4> Can I get some help with this code please? http://hpaste.org/67617
17:18:24 <shachaf> "q = reflectNum (Proxy::Proxy q)"
17:18:46 <shachaf> Is that meant to be a recursive definition?
17:18:48 <shachaf> Oh, wait.
17:18:54 <JesusIsLord> no
17:18:55 <shachaf> Is q meant to be a type or a value or both?
17:19:06 <sam4> both
17:19:16 <sam4> I just want to carry the q around with g
17:19:22 <kallisti> @hoogle Parsec integer
17:19:22 <ajg> Hi. I'm trying to (I think) combine two monads, Parsec and Maybe, but so far I've only done so clumsily: `foo p = do { x <- optionMaybe (lookAhead p); if isNothing x then return () else mzero }`
17:19:22 <lambdabot> No results found
17:19:25 <sam4> but it seems that the only way is to define it as a type
17:19:35 <ajg> Can that be simplified somehow?
17:19:43 <JesusIsLord> @src guard
17:19:43 <lambdabot> guard True  =  return ()
17:19:43 <lambdabot> guard False =  mzero
17:20:07 <shachaf> You probably want a more specialized combinator than guard.
17:20:22 <shachaf> What's optionMaybe?
17:20:24 <shachaf> Oh.
17:20:34 <JesusIsLord> Nothing <- optionMaybe (lookAhead p) -- would this work?
17:20:51 <shachaf> JesusIsLord: It'll work if "fail" is defined for it.
17:20:57 <ajg> optionMaybe produces Nothing on failure or Just x on success
17:21:07 <JesusIsLord> shachaf: yeah I know; but I don't know if Parsec does so.
17:21:41 <ajg> JesusIsLord: let me try that
17:22:40 <sam4> Is there really no way to achieve what I am trying to do :(
17:22:54 <shachaf> sam4: I don't know!
17:23:05 <shachaf> You haven't said what that is yet. :-)
17:23:13 <shachaf> Hmm, or maybe you have.
17:24:16 <sam4> I want g to act sort of like a static variable in other languages
17:24:27 <ajg> well, guard works.
17:24:27 <sam4> with variable q associated with g
17:24:47 <sam4> but it seems that I cannot access q in other functions
17:24:48 <ajg> JesusIsLord: not sure what you meant by Nothing <- ... ?
17:24:59 <shachaf> sam4: You're shadowing g there, by the way, you know.
17:25:21 <sam4> shadowing?
17:27:55 <td123> let g = 1 in g where g = 2
17:28:30 <shachaf> The name "g" refers to several different things, including a global name and a function argument.
17:28:43 <shachaf> "q" is also used for both a type and a value -- they're different 'q's.
17:29:13 <sam4> oops I should change that
17:29:28 <sam4> sorry for the confusion
17:30:35 <sam4> http://hpaste.org/67618
17:30:56 <sam4> I have it like this but what I want to achieve is the last two lines
17:30:58 <sam4> in genTrap
17:45:39 <aalevy_> when i run "ghci -package ghc" i get an error, "cannot satisfy -package ghc". running ghc 7.4.1 and cabal 1.14. why would this happen?
17:49:06 <byorgey> aalevy_: what is the output of "ghc-pkg list ghc"?
17:49:37 <byorgey> ghci -package ghc works for me (with the same versions)
17:50:34 <aalevy_> yeah, it works for me as well on a different box
17:51:02 <aalevy_> output == ghc-7.4.1
17:51:34 <aalevy_> i'm going to nuke everything and install ghc+cabal fresh
18:33:05 <Brolapse> how can I go about ordering a list by the lists members values of a tuple e.g. [(a,b,c,[(d,e)])] and I want to order it by e
18:33:36 <elliott> you should really use a data type not a tuple there
18:33:53 <Brolapse> well it's a type
18:33:58 <Brolapse> (d,e) = f
18:34:09 <mauke> sortBy (comparing ...)
18:34:27 <Brolapse> wat
18:34:41 <Brolapse> i couldn't find any good examples of sortBy on googel
18:34:54 <mauke> so stop copying from examples
18:35:10 <Brolapse> so i'll ask you lot instead :D
18:35:22 <mauke> no, thanks
18:35:34 <mendez> Brolapse: lol @ nick
18:35:36 <Brolapse> but i really am stuck :(
18:36:44 <cmears> > sortBy (comparing length) ["alpha", "beta", "pi", "iota"]
18:36:45 <lambdabot>   ["pi","beta","iota","alpha"]
18:38:07 <tgeeky> hm. that reads more naturally with "sort" instead of "sortBy"
18:40:21 <cg_morton> sort sorts lexically, though
18:40:57 <cg_morton> > sort ["alpha", "beta", "pi", "iota"]
18:40:58 <lambdabot>   ["alpha","beta","iota","pi"]
18:41:32 <tgeeky> cg_morton: right, I was saying it would sound better to me if we renamed the sortBy function 'sort'
18:41:57 <tgeeky> maybe not
18:42:39 <mauke> hey, "sort by comparing length" reads like english
18:42:57 <cg_morton> Brolapse: if you're still listening, you can use sort if the type in the array is an instance of Ord
18:43:26 <Brolapse> it's not i don't think
18:43:34 <tgeeky> mauke: yeah. Originally, I was thinking "sort, (comparing length), [..]" but "sort (by comparing length) [..]" works well too
18:44:10 <cg_morton> that's the beauty of typeclasses, you can make it an instance of Ord
18:46:18 <Brolapse> how do i make it an instance of ord
18:47:21 <kallisti> Brolapse: make what an instance of ord?
18:47:23 <kallisti> that ugly tuple thing?
18:47:31 <kallisti> you probably don't want to do that.
18:47:54 <kallisti> I would use sortBy and comparing
18:48:16 <Brolapse> i can't work out how it'd return the whole list ordered
18:48:25 <cg_morton> he's already creating a list of them, it should be a type already
18:48:45 <kallisti> "it should be a type already" what.
18:49:04 <cg_morton> sort or sortBy will return an ordered list, you just need a way to compare the elements
18:49:49 <kallisti> > sortBy (comparing (\(x,y,z,a) -> a)) [(1,2,3,4), (5,6,7,8), (-1,-2,-3,-4)]
18:49:50 <lambdabot>   [(-1,-2,-3,-4),(1,2,3,4),(5,6,7,8)]
18:50:32 <Brolapse> mind blown
18:54:07 <kallisti> Brolapse: I'll assume that's something like understanding.
18:57:35 <heatsink> Can someone here help with type-level addition?
19:00:30 <parcs`> don't ask to ask ;)
19:01:08 <heatsink> Well, I think it's a bit beyond the average Haskell question
19:01:57 <hpaste_> Heatsink pasted “Type addition” at http://hpaste.org/67619
19:02:21 <heatsink> I pasted my code
19:03:09 <heatsink> I'm getting type errors like "Could not deduce (Vector a ~ Vector a0)" in the last two lines of code
19:03:37 <heatsink> I think I have to prove to the type inference engine that (S ::: a) :+ b ~ S ::: (a :+ b)
19:03:44 <heatsink> But I don't know how to do that
19:04:39 <heatsink> Actually, that one's an axiom
19:04:54 <heatsink> So I don't know what it's complaining about.
19:09:47 <twopoint718> I was looking for a function that does something like this: let both f g x = f x && g x
19:10:11 <twopoint718> Anyone know of something like that?
19:10:40 <twopoint718> I thought it would be cool to write boolean stuff like "both (>0) (<27)"
19:11:54 <heatsink> :t on
19:11:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:12:02 <BMeph> > let both = liftM2 (&&) in both (>0) (<27) 6
19:12:03 <lambdabot>   True
19:12:26 * BMeph buffs his oh-so-attentive fingernails... ;)
19:12:29 <td123> let a = (&&) <$> (>0) <*> (<27)
19:13:11 <heatsink> Nice try, but it still doesn't look like perl.
19:13:52 <heatsink> And my type errors go away if I use a data family instead of a type family
19:14:11 <twopoint718> Aha! I knew there was something like that lurking. I had looked at 'on' but hadn't seen how to apply it.
19:14:23 <heatsink> Time to add lots of explicit newtype wrapping and unwrapping to my code.
19:14:31 <glguy> :t mappend $ map (All.) [(> 0), (<27)]
19:14:32 <lambdabot> forall a. (Num a, Ord a) => [a -> All] -> [a -> All]
19:15:08 <glguy> oops
19:15:44 <heatsink> 'on' gives you f x `g` f y, it's not quite the same
19:15:48 <glguy> ?type getAll . mconcat . map (All.) [(> 0), (<27)]
19:15:48 <lambdabot>     The section `> 0' takes one argument,
19:15:49 <lambdabot>     but its type `[Bool]' has none
19:15:49 <lambdabot>     In the expression: (> 0)
19:16:11 <glguy> ?type getAll $ (mconcat $ map (All.) [(> 0), (<27)])
19:16:12 <lambdabot>     Couldn't match expected type `All' against inferred type `a -> All'
19:16:12 <lambdabot>     In the second argument of `($)', namely
19:16:12 <lambdabot>         `(mconcat $ map (All .) [(> 0), (< 27)])'
19:16:21 <glguy> well, it's working in myGHCI :)
19:16:37 <glguy> ?type getAll . (mconcat $ map (All.) [(> 0), (<27)])
19:16:37 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
19:16:41 <glguy> there we go :)
19:20:21 <gwern> @quote
19:20:22 <lambdabot> nixon says: I ha\/E zeeN it. I xnOW. I 8eLIe\/3 T|-|At.
19:20:46 <twopoint718> glguy: what's the '(All.)' about?
19:22:40 <twopoint718> glguy: I've already run off to go read http://learnyouahaskell.com/functors-applicative-functors-and-monoids
19:24:57 <parcs`> aw heatsink left
19:25:08 <parcs`> i was going to help him
19:25:21 <parcs`> why do people not stay connected to irc 24/7 anyway
19:26:02 <glguy> ?type (getAll, (All .))
19:26:03 <lambdabot> forall (f :: * -> *). (Functor f) => (All -> Bool, f Bool -> f All)
19:26:43 <twopoint718> parcs`: their laptop lid slips?
19:28:02 <parcs`> true irc users stay connected via a vps
19:28:58 <twopoint718> parcs`: my coworker has been brewing his ideal tmux + mosh + vps solution, he's on IRC all the time now
19:30:03 <twopoint718> glguy: Thanks for the pointer. I can't say that I would have hit upon the mconcat idea
19:30:27 <glguy> I'm not advocating for it, just sharing it ;)
19:30:52 <twopoint718> I kinda get that, but cool nonetheless!
19:31:41 <twopoint718> I've been on a "rethinking booleans" kick lately. I see how crazy they can get in real code.
19:33:39 <glguy> :t \ n -> all ($ n) [(>0),(<30)]
19:33:39 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
19:36:15 * hackagebot openpgp-asciiarmor 0.0 - OpenPGP (RFC4880) ASCII Armor codec  http://hackage.haskell.org/package/openpgp-asciiarmor-0.0 (ClintAdams)
19:40:01 <parcs`> @tell heatsink re http://hpaste.org/67619, you need to use a data family to define Vector because type families are not injective. because type/data families are open, someone could additionally declare 'type instance Vector (Stuff ::: a) = Double ::: Vector a' and now it is not clear to ghc whether the expressions 'n ::: x' on line 33 or 'n ::: flatten x y' on line 34 have the type 'Vector (Stuff ::: a)' or
19:40:02 <lambdabot> Consider it noted.
19:40:04 <parcs`> 'Vector (S ::: a)'. data families alleviate this issue by ensuring that type functions are injective so that the types of those two expressions can be unambiguously inferrered
19:40:19 <parcs`> oh damn
19:41:26 <parcs`> @tell heatsink 'Vector (S ::: a)'. data families alleviate this issue by ensuring that type functions are injective so that the types of those two expressions can be unambiguously inferred
19:41:27 <lambdabot> Consider it noted.
19:43:00 <byorgey> @tell heatsink also, if you use the HEAD version of ghc, it has type-level naturals built in =)
19:43:00 <lambdabot> Consider it noted.
19:43:15 <monochrom> w00t haskell weekly news!
20:03:29 <romildo> When compiling (with ghc-7.4.1) a module generated with alex, I am getting a warning: "Pattern bindings containing unlifted types should use an outermost bang pattern: ((I# (ord_c))) = fromIntegral c"
20:03:29 <lambdabot> romildo: You have 1 new message. '/msg lambdabot @messages' to read it.
20:03:34 <romildo> What that means?
20:04:34 <Maxdamantus> What has similar functionality to: Monad m => (m a, m b) -> m (a, b) ?
20:04:50 <copumpkin> :t uncurry (liftM2 (,))
20:04:51 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
20:05:07 <Maxdamantus> Ah, right.
20:05:20 <Maxdamantus> Thanks.
20:05:23 <copumpkin> :)
20:08:39 <pitor> I'm having trouble installing SDL-gfx (Haskell binding to the C library SDL_gfx). I have SDL_gfx.dll, and I thought I knew which options to specify either in the source .cabal file or on the command line to "cabal install" but every time I run "runhaskell Setup.lhs configure" I still get an error saying that the "SDL_gfx lib not found".  I'm running cabal 1.10.2.0 and ghc 6.12.3 on windows.  I already have the other haskell SDL packages install
20:09:56 <sam1> I have a general question: http://hpaste.org/67621
20:09:59 <ski> romildo : apparently, it would prefer `!(I# ord_c) = fromIntegral c' ..
20:13:42 <sam1> can anyone help?
20:15:20 <tgeeky> sam1: you're asking, can the where block of one function access a defn. in another where block of another function?
20:16:27 <parcs`> pitor: do you have the header files installed?
20:18:28 <pitor> parcs`: I believe so, but as I'm not windows, I don't think there's a standard installation directory for them.  I tried specifying the directory they're located in with "Include-Dirs" in the .cabal file, but it still fails
20:18:56 <parcs`> "not windows?"
20:19:19 <pitor> er, "as I'm on windows". sorry
20:19:27 <tgeeky> pitor: if my memory is correct, there is an include directory and a lib directory
20:19:37 <eh> > map toLower ((pack "test")::ByteString)
20:19:38 <lambdabot>   Not in scope: type constructor or class `ByteString'
20:19:58 <pitor> the SDL_gfx C source didn't have either an "include" or a "lib" subdirectory
20:19:58 <ski> sam1 : you could pass `g' as an argument .. maybe you'd want to try "7.11.3. Implicit parameters" <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters>
20:20:57 <tgeeky> pitor: I'm not suggesting that it did. I'm saying that haskell / ghc may have different options other than include-dirs
20:21:00 <pitor> the .h files are in the SDL_gfx-x.y.z directory itself. i've tried putting the .dll files in that directory as well, and in a 'lib' subdir which I made myself. both methods fail
20:22:08 <ski> sam1 : hm, though i think in your particular case you can probably just constraint the type variable `q' in the type of `g', at the use of it inside `myFunc' ..
20:22:11 <tgeeky> pitor: try: cabal configure --extra-include-dirs=<directory where the file is> --extra-lib-dirs=<directory where the files is>
20:24:54 <pitor> tgeeky: sorry, no. "SDL_gfx lib not found"
20:25:19 <tgeeky> pitor: let me look at the package. can you paste the link to the source?
20:25:32 <tgeeky> pitor: I'm probably the only talking person on Windows, we're pretty rare, so hopefully I can help
20:25:55 <tgeeky> pitor: that said, I've never even used a 6.xx GHC
20:27:33 <pitor> tgeeky: thanks for the help.  haskell source is here: http://hackage.haskell.org/packages/archive/SDL-gfx/0.6.0/SDL-gfx-0.6.0.tar.gz
20:27:33 <pitor> I pulled the C source from here: http://www.ferzkopp.net/Software/SDL_gfx-2.0/SDL_gfx-2.0.13.zip (via http://www.ferzkopp.net/Software/SDL_gfx-2.0/)
20:33:19 <romildo> ski, then probably alex should be patched to consider the ! in the generated code. Tomorrow I will take a closer look at this issue.
20:34:44 <ski> romildo : possibly .. i confess i don't know why the warning suggests this change
20:35:46 <carter> brei'm being adventurous and seeing how much of the stuff I normally use on hackage builds with today's ghc 7.5 head :)
20:42:25 <tgeeky> pitor: just looking at things a bit. I'm assuming what's failing is building SDL (which sdl-gfx depends on)
20:42:32 <sordina1> Hey guys. I've just done a cabal update and can't see cabal-install 0.14.0 as per the announce. This seems to happen quite often. What might I do to resolve this? The version cabal list gives is 0.10.2.
20:42:57 <tgeeky> pitor: I'm guessing that this is a binding to a much older SDL version (indeed, the WIN32 doc mentions sdl-1.2.12)
20:43:16 <tgeeky> pitor: so even if you did get this to compile (somehow), it probably wouldn't work anyway
20:43:39 <pitor> tgeeky: well, thanks for the help. looks like it's back to linux for me, then
20:43:51 <tgeeky> pitor: I don't know if this would be any better on linux
20:44:03 <tgeeky> pitor: unless you can get ahold of an old version of the sdl source
20:45:37 <parcs`> > (-5) ** (1/3)
20:45:37 <lambdabot>   NaN
20:45:39 <pitor> tgeeky: the libsdl page seems to have many older versions available. perhaps I'll start from scratch with the version mentioned in the WIN32 docs
20:45:40 <parcs`> booooooo
20:46:09 <shirt> new versions of sdl should work fine, the api has not changed in years
20:46:38 <dolio> > 5 ** (1/3)
20:46:38 <lambdabot>   1.7099759466766968
20:46:50 <dolio> > (-5 ** (1/3)) ** 3
20:46:51 <lambdabot>   -4.999999999999998
20:46:53 <kallisti> @hoogle withSocketsDo
20:46:53 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
20:46:53 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
20:46:53 <lambdabot> Network withSocketsDo :: IO a -> IO a
20:50:05 <parcs`> > -5 ** (1/3)
20:50:06 <lambdabot>   -1.7099759466766968
20:50:11 <parcs`> > (-5) ** (1/3)
20:50:12 <lambdabot>   NaN
20:50:20 <parcs`> :(
20:56:20 <ski> > (-5) ** (1/3) :: Complex Double
20:56:21 <lambdabot>   0.8549879733383486 :+ (-1.480882609682364)
20:56:56 <frontendloader> cute
20:58:52 <ski> > (-5) ** (1/3) :: Dif Double
20:58:53 <lambdabot>   NaN~~
20:59:21 <rwbarton> NaNcat?
20:59:37 <ski> @slap lambdabot
20:59:38 * lambdabot would never hurt lambdabot!
21:02:21 <augur> hmm
21:02:26 <augur> oleg is far more ... professorial
21:02:28 <augur> than i expected
21:06:14 <nyingen> he's also a russian handball player
21:07:04 <shachaf> Is that any different from American Handball?
21:07:43 <nyingen> i think it's a similar difference as between American roulette and Russian roulette
21:08:18 <parcs`> @hoogle performGC
21:08:18 <lambdabot> System.Mem performGC :: IO ()
21:11:02 <carter> for anyone who wants to play with the current ghc head with the type level nats and strings and type promotion, I build the installer package for OS X 64 bit :)
21:11:03 <carter> http://dl.dropbox.com/u/167530/GHC-7.5.20120425-x86_64.pkg
21:15:23 <lilfrost> Hello friends, I am working through "Learn You a Haskell For Great Good" and I keep getting a "parse error on input '::' " in GHCi. I have been unable to figure out what is wrong through googling. The code is here http://pastebin.com/4ZwVVt56 any help would be appretiated.
21:15:26 <mauke> The paste 4ZwVVt56 has been copied to http://hpaste.org/67623
21:16:06 <rwbarton> you can't use the ` character in a variable name
21:16:17 <rwbarton> use '
21:16:44 <lilfrost> OH FUCK I thought that was a " ' " <3 tyvm
21:21:20 * hackagebot ImperativeHaskell 1.0.0.0 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-1.0.0.0 (MatthewMirman)
21:44:05 <sordina1> Ah n/m apparently the preference is for <0.14.0
21:50:15 <frontendloader> That seems like an odd thing to have done, re: ImperativeHaskell
21:51:26 <Maxdamantus> http://kormacode.blogspot.co.nz/2011/11/c-style-haskell_10.html lol
21:53:34 <frontendloader> I'm almost not surprised. There's a certain attitude in people who like FP about trying to take the road less traveled wherever possible.
22:04:22 <sam4> Can I ask a question?
22:04:56 <ulfdoz> sam4: You already did.
22:06:04 <sam4> Oh oops
22:06:12 <sam4> well I have a question here
22:06:12 <sam4> http://hpaste.org/67625
22:08:55 <ski> <tgeeky> sam1: you're asking, can the where block of one function access a defn. in another where block of another function?
22:09:01 <ski> <ski> sam1 : you could pass `g' as an argument .. maybe you'd want to try "7.11.3. Implicit parameters" <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters>
22:09:11 <ski> <ski> sam1 : hm, though i think in your particular case you can probably just constraint the type variable `q' in the type of `g', at the use of it inside `myFunc' ..
22:09:31 <ski> sam4 ^
22:10:39 <sam4> Can you explain that a little further?
22:11:11 <sam4> so if I want to use 'g' in myFunc, I don't need a type constraint for 'g' for myFunc right?
22:11:23 <ski> you need to provide more context about `myFunc'
22:12:01 <ski> by "type constraint" do you mean "type signature" ?
22:12:24 <ski> or do you refer to the class constraints (like `(ReifiesNum q, CyclotomicRing m r c, Unbox c)' for `g') ?
22:12:42 <sam4> I want to achieve the second last line here: http://hpaste.org/67626 because I want to use 'q' in the calculation
22:12:46 <sam4> I'm not sure if this is achievable
22:13:02 <sam4> I meant both I guess
22:13:28 <ski> (next time, *annotate* the orgiginal paste by using the "Annotate" button, instead fo creating a new paste)
22:13:58 <sam4> oops sorry
22:14:50 <ski> it's not clear where you want the type variable `q' in `genTrap' to be bound / come from
22:15:30 <sam4> Yes that is the problem I think
22:16:03 <sam4> the thing is that I want 'g' to act sort of like a static variable that other functions in the module can use
22:16:10 <dmwit> let proxyFor :: a -> Proxy a; proxyFor _ = Proxy
22:16:11 <ski> also, you're not using the former `g' inside `genTrap' -- maybe you intended to do this ?
22:16:28 <sam4> the 'q' is associated with 'g' and was wondering if other functions can get access to 'q'
22:16:49 <ski> sam4 : "I want 'g' to act sort of like a static variable ..." -- do you mean `g' or `q' ?
22:17:13 <sam4> ok I made all the variables names confusing
22:17:19 <sam4> give me a moment :(
22:17:51 <ski> well, maybe you intended `q' to be associated with `g' as you say -- but that's not what the code actually does (at the moment)
22:18:20 <sam4> http://hpaste.org/67626
22:18:57 <sam4> I renamed 'g' as 'gen' because these are different
22:19:40 <ski> ok, that's (somewhat) better
22:19:50 <sam4> well I associated 'q' in 'g' when I define 'g' right?
22:20:12 <ski> sam4> :t (-^)
22:20:19 <sam4> Can I use 'g' and its associated 'q' in genTrap?
22:20:27 <sam4> that's a repa thing
22:20:35 <ski> the type being ?
22:20:45 <ski> sam4 : no, you defined `q' as a local variable inside the definition of `g'
22:21:18 <ski> callers of `g' can't see any internal implementations details of `g' (such as it using a value variable `q' inside)
22:21:32 <sam4> (-^)
22:21:52 <ski> that's not the type of it
22:21:59 <sam4> Yes that is exactly the problem and I was wondering if there is a way around it
22:22:20 <ski> i'm not sure what the type of `g', as used in `genTrap' is
22:23:12 <ski> presumably i uses a concrete type for `q' in the `ReifiesNum q' constraint used by `g' (or maybe that's implied by some of the other constraints on `genTrap')
22:23:30 <sam4> this is how I defined the types sorry http://hpaste.org/67626
22:24:28 * ski is still waiting for the type of `(-^)' ..
22:24:42 <sam4> what do you mean the type of (-^)
22:24:48 <sam4> sorry I am relatively new to haskell
22:25:07 <ski> i'm wondering what the type of `(-^)', presumably as defined by the library you got it from
22:25:10 <ski> something like
22:25:14 <ski>   (-^) :: ...
22:25:20 <ski> i wonder what the `...' here is
22:26:09 <ski> hm, though i suppose dmwit could probably be applied anyway
22:26:11 <sam4> http://hackage.haskell.org/packages/archive/repa/3.1.1.1/doc/html/Data-Array-Repa.html
22:26:22 <qnikst> hello, how can I write smth like liftIO . forkIO $ src $$ sink, using conduit-0.4 where src and sink over MonadIO and MonadBaseControlIO
22:26:49 <ski>   proxyFromPrimVector :: PrimVector q c -> Proxy q
22:26:55 <ski>   proxyFromPrimVector _ = Proxy
22:26:58 <qnikst> it condiut-0.2 it was liftIO.forkIO$ runResourceT $ src $$ sink
22:27:44 <sam4> Oh I see, that may be an option
22:29:07 <ski> i'm not sure how exactly `PrimVector q c' is an instance of the family `Array r sh e'
22:30:21 <ski> (also, `PrimVector' sounds suspiciously like an implementation detail -- are you sure you want to define things explicitly in terms of it)
22:30:30 <ski> (/me doesn't know repa, though, could be wrong)
22:31:35 <ski> i suspect there's a more elegant solution here -- but i'm not quite sure what it is
22:31:58 <ski> i think you could probably use something like
22:32:07 <sam4> I believe so, well at least I can use the proxyFromPrimVector
22:32:20 <ski>   q = reflectNum (proxyFromPrimVector as)
22:32:22 <ski> here
22:32:55 <ski> maybe passing instead of `as' either `g -^ (mmultP as' rs)' (named with some temporary name), or possibly `g' itself
22:33:06 <ski> i'm not sure whether it matters which of these you pass
22:33:25 <ski> another option would be to pass a `Proxy q' as argument to `g'
22:33:58 <ski> (but maybe then that defeats the purpose of using `ReifiesNum q' in the first place ?)
22:35:33 * ski hopes this has been of some minuscule help, at least
22:36:33 <sam4> Well at least I gained some great insights
22:36:49 <sam4> thank you so much for the detailed help!
22:37:20 <sam4> I'll try to work something out with proxyFromPrimVector
22:41:27 * hackagebot buildbox 2.1.0.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.0.1 (BenLippmeier)
22:43:45 <hpaste_> mmcdermo pasted “Forked cron never executes” at http://hpaste.org/67629
22:44:18 <mmcdermo> So I am attempting to create a thread that will perform an IO action every t seconds
22:44:33 <mmcdermo> It works when I don't fork it off, but when I do it never executes
22:44:44 <mmcdermo> http://hpaste.org/67629
22:44:57 <qnikst> mmcdermo: your main thread finished before action executes
22:45:02 <mmcdermo> Dur
22:45:32 <mmcdermo> qnikst: ty. I somehow presumed the normal laws of multithreading didn't apply to haskell lol
22:51:04 <nyingen> @quote
22:51:04 <lambdabot> benalene says: are testicles like penis boobs?
22:51:12 <nyingen> ...
22:51:13 <nyingen> @quote
22:51:13 <lambdabot> Botje says: unlike bridges, tentacles work just fine in programming
22:51:25 <dmwit> ...
22:51:28 <nyingen> @quote
22:51:28 <lambdabot> WillDonnelly says: monads are okay after a bit (though I'm still a little suspicious of them)
22:51:38 <nyingen> oh well.
22:51:45 <nyingen> let's play craps
22:51:48 <nyingen> @dice 2d6
22:51:48 <lambdabot> 2d6 => 7
22:51:49 <Enigmagic> swing and a miss
22:52:05 <dmwit> ?quote
22:52:05 <lambdabot> BONUS says: i have not forsaken anybody!!!  i am just equal parts busy and lazy
22:52:23 <nyingen> @quote Enigmagic
22:52:23 <lambdabot> Enigmagic says: we use the 'rsync' deploy model
22:52:47 <nyingen> didn't microsoft repackage rsync as "Windows Update"?
22:52:56 <Enigmagic> i'm not helping the matter much here either ;)
22:53:14 <nyingen> @quote microsoft
22:53:14 <lambdabot> PaulGraham says: What's scary about Microsoft is that a company so big can develop software at all. They're like a mountain that can walk.
22:53:23 <Enigmagic> nyingen: it's rsync + scheduling
22:53:44 <dmwit> ?quote linux
22:53:45 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
22:53:45 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
22:54:29 <nyingen> @quote freebsd
22:54:29 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
22:54:29 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
22:55:35 <nyingen> @quote php
22:55:35 <lambdabot> FogCreek says: Since throwing away a large code base and starting from scratch is typically a bad idea, the final decision was to have an intern write a compiler to translate a subset of ASP into
22:55:35 <lambdabot> PHP.
22:56:06 <dmwit> hah
22:56:11 <Enigmagic> heh
23:06:27 * hackagebot ddc-war 0.2.1.1 - Disciplined Disciple Compiler test driver and buildbot.  http://hackage.haskell.org/package/ddc-war-0.2.1.1 (BenLippmeier)
23:26:12 <nyingen> 30 min with no activity?
23:26:15 <nyingen> @quote
23:26:15 <lambdabot> koeien says: Let's register it [monomorphismrestriction.com] to prevent it from being used ;)
23:31:28 * hackagebot wai-middleware-route 0.4.0 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.4.0 (AlexanderDorofeev)
23:46:29 * hackagebot syb 0.3.6.1 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.6.1 (JosePedroMagalhaes)
23:55:29 <sopvop> @quote
23:55:30 <lambdabot> LeonardoDaVinci says: Those who are enamored of practice without theory are like a pilot who goes into a ship without rudder or compass and never has any certainty where he is going. Practice should
23:55:30 <lambdabot> always be based on a sound knowledge of theory.
23:55:49 <sopvop> I agree.
