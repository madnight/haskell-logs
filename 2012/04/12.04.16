00:13:49 * hackagebot ghc-mod 1.10.15 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.15 (KazuYamamoto)
00:14:30 <domingogallardo> Trying the lessons on the browser
00:33:50 * hackagebot repa-devil 0.3.0 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.0 (RaphaelJavaux)
00:41:45 <shachaf> So "initial algebra" just means something like e.g. ((:),[]) in the context of foldr?
00:42:07 <shachaf> Or ia :: Maybe (Mu Maybe) -> Mu Maybe; ia x = In x?
00:48:42 <Saizan> an algebra for the functor F is a type A with a function F A -> A, so if you take Mu F as A then the associated function is In, but that's isomorphic to ((:),[]) if you take A = [a] (for F X = 1 + a*X)
00:50:36 <Saizan> well, more like either (const []) (uncurry (:)) but same difference
00:53:16 <womb> hi
00:57:03 <CarminT> Hows everyone doing?
01:06:44 <DrSyzygy> :t (>>=)
01:06:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:17:30 <reinoud> @hoogle min
02:17:30 <lambdabot> Prelude min :: Ord a => a -> a -> a
02:17:30 <lambdabot> Data.Ord min :: Ord a => a -> a -> a
02:17:31 <lambdabot> Prelude minBound :: Bounded a => a
02:34:54 <ursthegiz> I would be interested in jour opinions on Frege, is it an enrichment, or do you consider it as not so important?
02:37:14 <merijn> ursthegiz: I've never heard his name before (well, that's not true, I heard it once before), so while he may have had an important influence it was apparently not big enough to feel that I should be reading his work rather than later work based on it
02:38:33 <ursthegiz> merijn: see here :http://code.google.com/p/frege, the programming language: Frege
02:38:51 <merijn> ursthegiz: Ah, you might want to specify that next time ;)
02:40:04 <merijn> ursthegiz: At a quick glance I would say not so important
02:41:11 <merijn> Haskell is more flexible and if you want to do "practical" programming that requires JVM libraries you are probably better of using Scala or some other more fully featured JVM language (or I guess in the .NET case F#)
02:41:58 <merijn> If you want more complex/experimental/advanced than Haskell then stuff like Agda, Epigram and F* are more interesting to investigate than this seems to be
02:42:08 <roconnor> does the quicktime link at the bottom of http://www.media.is.ed.ac.uk/live/webcast/Milner2012/Milner-Symposium.html work for other people?
02:42:33 <merijn> It opens a 174 byte .mov for me?
02:43:33 <merijn> (Which when opened in QuickTime player doesn't do anything, so no)
02:43:57 <ursthegiz> merijn: I have looked at Clojure, which also looks intereseting in this respect (JVM integration). Thansk for your opinion.
02:44:40 <merijn> ursthegiz: I haven't personally looked into Clojure much, but from what I've seen it is A) a fairly interesting Lisp, especially the focus on immutability and STM and B) quite useful for production
02:44:53 <roconnor> man this sucks.  Due to my ports beging blocked I have to connect to the web-based streem via my house VPN in Canada :(
02:45:17 <merijn> ursthegiz: So I would definitely recommend checking Clojure out if JVM integration is important to you
02:45:21 <roconnor> Paris -> Residential House in Canada -> Edinburgh
02:48:23 <dongdong> hello
02:48:53 <ursthegiz> Any more opinions on Frege http://code.google.com/p/frege/ ?
02:49:10 <ursthegiz> or experience?
02:50:18 <zhulikas> I would want it to be a complete ripoff of Haskell which runs on JVM
02:50:40 <zhulikas> without any differences
02:50:46 <zhulikas> but that's just me
02:53:52 <quicksilver> there have been several haskell/jvm efforts of different flavours
02:53:58 <quicksilver> it turns out that in practice nobody actually wants to use one
02:54:01 <quicksilver> and they all bitrotted
02:55:04 <srhb> If there was something that allowed you to write Haskell and just have it run on Android with no effort at all, I bet it wouldn't bitrot. Getting there seems to be an issue, however. :-)
02:55:07 <zhulikas> maybe that's because of the haskell itself?
02:55:26 <zhulikas> it's complicated for beginners
02:55:33 <zhulikas> so only a few actually begins...
02:56:02 <quicksilver> srhb: android doesn't use the JVM, of course.
02:56:16 <srhb> quicksilver: Oh, I thought it did!
02:56:22 <quicksilver> it uses dalvik.
02:56:27 <srhb> Isn't dalvik a JVM though?
02:56:27 <zhulikas> yeah.
02:56:28 <quicksilver> google's vm-which-isnt-the-jvm
02:56:35 <zhulikas> It is not even fully compatible with standard java library
02:56:35 <srhb> I see.
02:56:56 <zhulikas> a castrated jvm
02:57:04 <quicksilver> the way to get haskell on android is surely a native ARM backend with shims for androids native code API
02:57:21 <sipa> zhulikas: that was the reason to develop an own environment in the first place
02:57:22 <zhulikas> java on android is done that way afaik
02:57:23 <quicksilver> especially since the native ARM backend is being used on iPhone these days.
02:57:32 <zhulikas> using JNI to C
02:57:59 <zhulikas> so there is no need to do anything with java anyway on android
02:58:03 <quicksilver> I used to think a haskell/jvm port would be nice for applets in webpages.
02:58:16 <quicksilver> but these days it seems likely that a haskell/js backend is a better target
02:58:22 <quicksilver> (and there are already a couple of those)
02:59:17 <ursthegiz> would'nt jvm access give you access to a large pool of exsiting libraries? I think, this is the main motivation.
02:59:58 <quicksilver> people think that's the main motivation
03:00:07 <quicksilver> until they actually look at a java library and consider using it
03:00:14 <quicksilver> then they feel ill and have to lie down for a few weeks.
03:00:17 <zhulikas> I wouldn't support that idea. Seeing Clojure on JVM which uses existing java libs makes it ugly as hell and as far from Lisp as you can get
03:01:06 <koala_man> what's it called in C and such when you have magic return values like -1 to indicate failure?
03:01:24 <koala_man> instead of Maybe or Either
03:04:22 <adimit> koala_man: sentinel value?
03:05:04 <koala_man> ah, thanks
03:13:20 <reinoud> hi folks
03:13:58 <reinoud> is there a way to have a function abort with a custom message? i.e. like `invalid parameter a=4'  and optionally abort the evaluation?
03:14:05 <bitonic> reinoud: 'error'?
03:14:15 <bitonic> > error "invalid parameter a=4"
03:14:16 <lambdabot>   *Exception: invalid parameter a=4
03:14:40 <adimit> reinoud: your options are using: ErrorT, Either, or exceptions (error, which bitonic suggested.)
03:15:05 <quicksilver> well, perhaps not error, which isn't designed to be catchable
03:15:14 <quicksilver> but a "proper" async exception which is.
03:15:29 <bitonic> since he used the term "abort" I suggested error
03:15:32 <merijn> reinoud: It kinda depends on how critical the error is. Do you want to continue/handle it later on? Or do you just want to crash and burn with an informative message
03:15:34 <bitonic> abort sounds quite definitive
03:15:50 <quicksilver> true enough
03:15:57 <adimit> well, it kind of depends on the kind of application that's being written. If it's some non-critical run-once thing, I'd go with error.
03:16:16 <adimit> other than that it almost certainly pays to use proper exceptions or actually ErrorT
03:16:39 <bitonic> it's not about how critical the application is, it's about what kind of thing you're doing
03:17:22 <bitonic> e.g. division will almost always be a partial function
03:17:59 <zhulikas> what about Either a ?
03:18:14 <zhulikas> Left error, Right result
03:18:41 <bitonic> reinoud: 'error' is quite brutal. if you actually expect to reject the input without the user having to take care of that, use Maybe or Either if you want an error
03:18:42 <zhulikas> Either a a
03:19:28 <bitonic> Either a a won't be of much use to reinoud :P
03:19:40 <zhulikas> :)))
03:21:21 <pyry`> (/quit
03:21:37 <merijn> Time to bring up my favorite haskell joke...
03:21:45 <merijn> data Neither a b = Left | Right
03:22:05 <zhulikas> :D
03:22:07 <adimit> merijn: har har.
03:23:11 <reinoud> thanks a lot
03:23:22 <reinoud> just crash and burn yes...
03:23:26 <reinoud> @hoogle error
03:23:26 <lambdabot> Prelude error :: [Char] -> a
03:23:27 <lambdabot> Control.Exception.Base ErrorCall :: String -> ErrorCall
03:23:27 <lambdabot> Control.Exception ErrorCall :: String -> ErrorCall
03:25:41 <merijn> > error "Yay!" + 5
03:25:42 <lambdabot>   *Exception: Yay!
03:26:21 <adimit> try explaining that to somebody coming from eager duck-type land.
03:26:44 <merijn> adimit: That's not so hard
03:27:00 <adimit> it's not so hard to get them to say "yeah, I think I got it."
03:27:03 <merijn> > tail [error "Yay",1,2,3,4] -- this is harder
03:27:04 <lambdabot>   [1,2,3,4]
03:28:27 <reinoud> > error "hello "++ show 4
03:28:29 <lambdabot>   "*Exception: hello
03:29:04 <reinoud> > error ("hello " ++ show 4)
03:29:05 <lambdabot>   *Exception: hello 4
03:29:13 <reinoud> :) the () is important aparently
03:29:29 <merijn> reinoud: Yes, function application binds tighter than operators
03:29:37 <adimit> reinoud: functional application takes precedence over ++
03:29:45 <adimit> merijn was faster :-|
03:29:49 <merijn> reinoud: Of course you can use ($)
03:29:57 <merijn> > error $ "hello " ++ show 4
03:29:59 <lambdabot>   *Exception: hello 4
03:30:42 <merijn> error is just a function like any other, it will just throw an exception whenever you try to use its results. (Note that it is lazily evaluated like anything else, see my tail example above)
03:32:08 <bitonic> merijn: error is not "a function like any other". you can't define it manually
03:32:23 <bitonic> or maybe you meant "error is not a keyword" :P
03:32:26 <bitonic> in which case I agree
03:32:34 <shachaf> bitonic: Sure you can.
03:32:38 <shachaf> error x = error x
03:32:42 <bitonic> shachaf: that is not the same.
03:32:48 <shachaf> Operationalist!
03:32:59 <bitonic> you can definitely define diverging function manually, thanks a lot :P
03:33:11 <merijn> bitonic: Just because you can't write it directly doesn't make it something other than "a function like any other"
03:33:24 <merijn> It behaves identical to all other haskell functions
03:33:31 <adimit> depends on one's definition of 'like'
03:33:47 <bitonic> merijn: no it doesn't, the only other way to crash your program in haskell is partial patterns
03:33:49 <bitonic> and undefined
03:33:55 <bitonic> which is closely related to error
03:34:03 <reinoud> lets see if this finally aborts with the bad parameters it somehow gets
03:34:22 <shachaf> bitonic: Operationalist!
03:34:29 <bitonic> shachaf: ehe
03:34:34 <shachaf> bitonic: Anyway, x = x is a way to crash your program.
03:34:45 <merijn> bitonic: I could just write a function that doesn't have any patterns and it'd behave like error, just without the error message
03:35:04 <bitonic> merijn: now you can relate diverging functions to error and undefined, but they still have different (operational?) semantics
03:35:23 <bitonic> merijn: what's the type of that function?
03:35:45 <bitonic> you want 'String -> a'. How do you define "without any patterns"?
03:35:51 <bitonic> *define it
03:36:35 <shachaf> Anyway, unsafePerformIO is in the Haskell spec now.
03:36:52 <merijn> "foo s = undefined"?
03:36:59 <shachaf> So you can say error s = unsafePerformIO (putStrLn s >> exit)
03:37:01 <bitonic> merijn: that's the same as error (undefined)
03:37:01 <merijn> Tada, "String -> a"
03:37:34 <bitonic> merijn: yeah, that's ceating. undefined = error without the message
03:37:35 <merijn> What's the difference in operational semantics? Beyond the fact that error happens to print its argument?
03:37:45 <bitonic> shachaf: no it's not :P
03:37:57 <shachaf> What's not?
03:38:05 <bitonic> unsafePerformIO, unless I'm missing something
03:38:11 <shachaf> It's in Haskell 2010.
03:38:13 <merijn> How is that cheating?
03:38:25 <bitonic> merijn: undefined is magic in the same way that error is magic.
03:38:30 <merijn> No one said that error "was like any other function (except those without undefined)"
03:38:37 <merijn> I disagree that undefined is magic
03:38:39 <bitonic> merijn: define it without error or undefined
03:38:46 <bitonic> merijn: ok, define 'undefined' manually.
03:38:55 <bitonic> in std haskell
03:38:57 <merijn> _|_
03:39:08 <bitonic> merijn: they're not the same thing.
03:39:22 <merijn> That brings me back to the point that the fact that something can't be written in std haskell doesn't magically make it different from other functions
03:39:38 <merijn> It behaves like a function, thus it is a function
03:39:47 <merijn> Pedantry notwithstanding
03:40:07 <bitonic> merijn: I think undefined and error are pretty special, and it's important to stress it
03:40:18 <merijn> I was just pointing out that all usual application rules and lazy evaluation semantics apply
03:40:25 <bitonic> and they are primitives, you can't define them manually
03:40:53 <merijn> You can't define integers manually either, but that doesn't stop us from considering them full blown data types
03:41:21 <bitonic> merijn: of course you can define them manually.
03:41:35 <adimit> not the way they are defined.
03:41:41 <merijn> bitonic: Show me?
03:41:47 <bitonic> no, but they'd have the same semantics
03:42:04 <bitonic> data Nat = Zero | Suc Nat, data Integer = Pos Nat | Neg Nat
03:42:21 <adimit> so… they'd *behave* the same way. That's the entire argument.
03:42:26 <merijn> bitonic: No, that's not the same
03:42:28 <bitonic> adimit: that's exactlhy my argument.
03:42:37 <bitonic> you can't define a function that behave like undefined or error.
03:42:47 <merijn> Sure you can
03:42:55 <adimit> and they wouldn't even behave the same way, because they'd blow the stack frame before long.
03:42:56 <merijn> foo = foo
03:42:59 <bitonic> ...no. you can't. I'm tired of this discussion.
03:43:09 <bitonic> merijn: foo = foo will never terminate. undefined surely does.
03:43:14 <merijn> let x = x in head x
03:43:30 <quicksilver> who says undefined terminates?
03:43:36 <quicksilver> and who says foo = foo does not?
03:43:41 <bitonic> merijn: that will never terminate as well
03:43:49 <adimit> that's implementation dependent…
03:43:54 <quicksilver> I don't think the language spec says either of those things?
03:43:56 <merijn> bitonic: I'm pretty sure that isn't specified anywhere
03:44:13 <merijn> You can't make up arbitrary semantics that confirm your point
03:44:14 <quicksilver> it may well be the case that undefined aborts the program - but it may also be the case that foo = foo does
03:44:33 <merijn> (Well, you can, but it quickly renders the discussion pointless)
03:44:42 <quicksilver> describing what undefined does in GHC as "termination" is not the normal semantic meaning of terminate, either
03:44:56 <quicksilver> (although it does of course match more generally used meanings of terminate)
03:45:36 <bitonic> let's see what the report says about this
03:46:59 <bitonic> quicksilver: if my implementation defined 'error x = error x', would that be legal haskell?
03:47:06 <quicksilver> I have no idea
03:47:13 <quicksilver> (I don't care very much either :P)
03:47:22 <bitonic> I'm pretty sure it wouldn't
03:47:49 <quicksilver> but I think "foo = foo" and "undefined" are more alike than different, as far as haskell is concerned.
03:47:57 <bitonic> I do not care either, but merijn is saying that error and _|_ are the same thing, and I think that's pretty misleading
03:48:07 <quicksilver> error is an example of _|_
03:48:23 <bitonic> quicksilver: well, _|_ in the sense of something with no value
03:48:34 <quicksilver> are you just making stuff up now?
03:48:39 <quicksilver> _|_ means something very precise.
03:48:41 <bitonic> but error also says more than that (that execution will stop)
03:48:49 <bitonic> quicksilver: what does it mean then?
03:48:51 <quicksilver> I don't know what "somethign with no value" means
03:49:03 <bitonic> well clarify then
03:49:22 <quicksilver> _|_ is an important part of the semantics of (functional programming languages like) haskell
03:49:31 <quicksilver> it has a clear meaning.
03:49:35 <bitonic> quicksilver: which is...?
03:49:59 <quicksilver> it represents computations which fail to terminate; fail to produce a value
03:50:02 <Jaak> and value in sense that's it's in value domain
03:50:14 <quicksilver> the awkward squard paper is fairly good as far as I remember.
03:50:28 <bitonic> quicksilver: which is exactly what I meant with "something with no value". whatever
03:50:38 <shachaf> bitonic: As far as the program is concerned, all _|_s are equal.
03:50:39 <quicksilver> I appreciate that might be what you meant.
03:50:43 <shachaf> "A call to error terminates execution of the program and returns an appropriate error indication to the operating system. It should also display the string in some system-dependent manner. When undefined is used, the error message is created by the compiler."
03:50:50 <quicksilver> but it would be helpful if you learnt what things *actually* mean
03:50:55 <shachaf> " The actual program behavior when an error occurs is up to the implementation. The messages passed to the error function in these translations are only suggestions; implementations may choose to display more or less information when an error occurs."
03:50:57 <quicksilver> rather than expecting us to guess what you mean.
03:51:05 <shachaf> error x = error x looks perfectly valid to me.
03:51:06 <bitonic> shachaf: I think that's saying much more than "fail to terminate".
03:51:15 <shachaf> But it doesn't really matter.
03:51:47 <shachaf> Eh. The behavior of "let x = x in x" could also be nontermination.
03:51:58 <bitonic> it does, when programming in Haskell
03:52:02 <shachaf> The fact that something is _|_ is much more interesting than which particular _|_ it is.
03:52:10 <shachaf> Er, could also be termination.
03:52:17 <shachaf> GHC catches it and prints <<loop>>
03:52:26 <quicksilver> "let x = x in x" and "error <blah>" are both non-termination
03:52:32 <bitonic> quicksilver: I learnt what _|_ *actually* mean. You're just assuming things about me now because I chose words poorly.
03:52:33 <shachaf> Right.
03:52:35 <merijn> Especially since all _|_'s are equal from a semantics perspective
03:52:46 <shachaf> I misused the word "termination" there.
03:52:53 <quicksilver> bitonic: I apologise if I appear to be assming stuff about you
03:52:54 <Jaak> > let x = x in x :: Int
03:52:57 <lambdabot>   mueval-core: Time limit exceeded
03:53:01 <shachaf> Jaak: lambdabot is a special case.
03:53:08 <Jaak> mhmh
03:53:15 <quicksilver> bitonic: you're being very pedantic and slightly agressive - people who behave like that are going to be held to higher standards.
03:53:36 <bitonic> quicksilver: I'm not aggressive at all. You're the one who jumped in saying "i'm making stuff up"
03:53:42 <merijn> bitonic: You are
03:54:16 <bitonic> the whole point I was trying to make is that error is a very peculiar function in all the Haskell implementations I know. I assumed too much about what the standard said about it I guess
03:54:19 <merijn> You jumped on a simplified explanation to a simple newbie question with obscure semantic arguments and then defend them with questionable understanding of semantics
03:54:24 <quicksilver> bitonic: you actually are. You have been so several times in this conversation. (Incidentally I'm not claiming that my own behaviour is not agressive)
03:55:50 <bitonic> quicksilver: I'm sorry if I came accross as aggressive, I certainly didn't mean to, and I can't see where I was scrolling back. I'll just go back to work now
03:56:23 <bitonic> *where I was scrolling back
03:56:30 <quicksilver> bitonic: apology accepted. I'm sorry if I seem unreasonable. I'll also go back to work :)
03:56:51 <bitonic> :)
03:56:58 <bitonic> me and you often get into this silly arguments
03:58:03 <t7> get a room allready
03:58:18 <bitonic> merijn: the only reason why I started this is that I don't think it's useful to tell people that 'error' is "just another function", I don't want them to feel to comfortable using it :P
03:58:24 <bitonic> but yeah it got out of hand
03:59:00 * hackagebot peg 0.2 - a lazy non-deterministic concatenative programming language  http://hackage.haskell.org/package/peg-0.2 (DustinDeWeese)
04:00:06 <ksf> do we have a library for -- for a lack of better term -- forgetful caches?
04:01:08 <ion> store _ = pure (); fetch f key = f key
04:01:13 <ion> err, return (f key)
04:01:17 <ion> err, pure (f key)
04:01:36 <ksf> "forgetful" as in "don't forget stuff while they're used, or if they're used regularly"
04:02:54 <merijn> ksf: I guess you want something like python's weakref's?
04:03:33 <quicksilver> GHC has weak pointers
04:03:37 <merijn> (Which are references that don't prevent garbage collection of the referred data)
04:03:40 <quicksilver> they're a little bit fiddly to use right.
04:04:02 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
04:04:02 * hackagebot factory 0.2.0.4 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.4 (AlistairWard)
04:04:10 <ksf> jep, it's probably going to involve weak refs, but I didn't plan on writing the cache myself ;)
04:04:11 <luite_> a simpler solution might be lrucache
04:04:25 <quicksilver> it's much more powerful general to write your own cache management code
04:04:43 <quicksilver> because you probably want your own limits on amount of memory used and/or thresholds on popularity
04:04:55 <quicksilver> on the other hand, WeakRefs might be a useful tool in actually writing your own cache
04:05:28 <bitonic> one thing that would be useful is something like soft pointers in java -- things that GCed when the system runs low on memory.
04:07:23 <quicksilver> only when it's low on memory, or at every GC?
04:07:39 <quicksilver> I wonder how it distinguishes between "low on memory" and "every GC"
04:08:09 <bitonic> "Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand."
04:08:14 <ksf> I also don't care about the actual size of the cache, the important thing is that it doesn't explode.
04:08:19 <sam6> What is the difference between regular Data.Vector and Data.Vector.Unboxed?
04:08:31 <bitonic> quicksilver: I'm not sure exactly how they work, but they work pretty well in my experience.
04:08:31 <quicksilver> bitonic: sounds like they're not making many promises about when it really happens then :)
04:08:32 <ksf> unboxed vectors are unboxed.
04:08:45 <ksf> that is, they don't store pointers to stuff, but stuff.
04:08:57 <ksf> which also means that they are strict in all their elements.
04:09:19 <ksf> ...and faster.
04:09:56 <sam6> how is it related to pairs? or what is the description about pairs about?
04:10:00 <bitonic> quicksilver: well I've seen production code with caches implemented with those and they worked pretty well, so they must are worth something eheh
04:10:15 <bitonic> I can't write propery this morning :P
04:10:25 <Ptival> properly* ? :)
04:10:30 <bitonic> ahah, yes
04:10:49 <merijn> The difference between boxed and unboxed (let's take Int's as a simple example) is just that boxed Int's are basically a pointer to either an int or a thunk that may or may not return an int when evaluated. Whereas an unboxed int is really just an int and is incapable of referring to thunks and potential bottoms, right?
04:11:05 <quicksilver> bitonic: yeah, insufficiently specified things can still work very well in practice ;)
04:11:17 <quicksilver> bitonic: on the other hand, they can turn out not to work well for the reasons the coder thought they did.
04:11:21 <quicksilver> caches are fiddly to understand.
04:11:29 <Ptival> so unboxed implies not lazy?
04:11:41 <bitonic> quicksilver: true. maybe we could specify them better in Haskell land
04:12:11 <merijn> Ptival: I dunno, I'm just summarising my understanding and hoping people will confirm the correctness or point out errors
04:12:11 <quicksilver> bitonic: it's genuinely quite hard to distinguish between "routine GC" and "running low on memory" on modern systems
04:12:27 <quicksilver> bitonic: and GHC doesn't have brilliant support for trying to stick to a given memory footprint.
04:12:38 <quicksilver> (the heap limit parameters tend to cause a lot of GC thrashing)
04:12:52 <quicksilver> virtual memory makes it quite hard to know when too much memory is too much.
04:12:58 <merijn> It's cheaper to buy more RAM than invent better GC :p
04:13:00 <bitonic> quicksilver: uhm, then I wonder how erlang/java do it
04:13:02 <ksf> quicksilver, well, my use case is caching glyphs. and I literally *do* have to cache them because the X server, not me, is holding onto them.
04:13:07 <quicksilver> bitonic: so do I :)
04:13:09 <Tinned_Tuna> merijn: it's so sad that's true :-p
04:13:10 <quicksilver> bitonic: which is why I asked.
04:13:29 <thoughtpolice_> merijn: basically. there's a bit more to it than that (lifted/unlifted values,) but yeah, boxed types contain pointers to heap objects, unboxed contains a value, a la Int vs Int#
04:13:30 <quicksilver> bitonic: but there may be some excellent anwsers, or some pretty good ones in practice.
04:13:36 <quicksilver> I'm not familiar with either of their GCs.
04:13:52 <quicksilver> merijn: always always, yes.
04:13:53 <thoughtpolice_> merijn: the first section here should give a bit more precise definition http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
04:14:03 * hackagebot squeeze 1.0.2.3 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.2.3 (AlistairWard)
04:14:08 <merijn> Tinned_Tuna: I have an anonymous quote in my quotes file: "Algorithms are for people who don't know how to buy RAM."
04:14:13 <bitonic> quicksilver: they work in very different way actually, so the answers are most likely very different. So we have double the change of getting a good answer!
04:14:27 <merijn> quicksilver: Was that in response to my boxed/unboxed summary?
04:14:57 <Ptival> merijn: sometimes you also need to buy a new CPU :\
04:15:07 <quicksilver> merijn: no, it was in response "it's cheaper to buy more RAM than invent better GC"
04:15:21 <merijn> thoughtpolice_: Meh, I was mostly concerned whether my rough understanding was roughly correct
04:15:32 <merijn> thoughtpolice_: I can always look up exact semantics when I need them
04:15:41 <thoughtpolice_> merijn: then yeah, you're pretty much correct
04:16:14 <Ptival> sometimes it's good to have a one-line summary of a concept that does not miss on important details :)
04:17:31 <Ptival> sam6: what was your question about pairs related to unboxed?
04:17:45 <merijn> Ptival: s/sometimes/often/ or even s/sometimes/always/
04:18:15 <sam6> I'm just generally not sure about the description about pairs in http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed.html#t:MVector
04:23:55 <Ptival> sam6: I think is is just an example of an "how to unbox your own datatype"
04:26:19 <Ptival> unboxing isn't "about pairs"
04:29:34 <sam6> I see I guess I'll have to do some more reading
04:31:16 <hayashi> @pl ap fst snd (f *** g)
04:31:17 <lambdabot> ap fst snd (f *** g)
04:31:19 <hayashi> zen
04:31:54 <hayashi> I was honestly expecting lambdabot to obfuscate an already pointfree expression into a stream of dots and flips then
04:32:35 <bitonic> hayashi: pl won't try to do anything if you don't have points already :)
04:32:35 <hayashi> @pl ap fst snd . (f *** g)
04:32:36 <lambdabot> ap fst snd . (f *** g)
04:32:41 <hayashi> Aw
04:32:48 <ksf> why doesn't lrucache's insert come with a way to tell which entry was thrown away?
04:32:59 <ksf> I need to finalise the bugger.
04:33:07 <hayashi> @pl \f g -> ap fst snd . (f *** g)
04:33:07 <lambdabot> ((ap fst snd .) .) . (***)
04:33:17 <hayashi> thank you lambdabot
04:33:23 <hayashi> that's more like it
04:34:05 <flux> @pl \f g snd -> ap fst snd . (f *** g)
04:34:06 <lambdabot> (flip ((.) . ap fst) .) . (***)
04:34:12 <ksf> "It doesn't perform very well, there's a general lack of interest, and
04:34:12 <ksf> nobody interested in supporting it.  The right thing to do is make it
04:34:12 <ksf> available as a Cabal package."
04:34:14 <flux> when you just need to parametrize the used 'snd' function
04:34:17 <ksf> http://www.mail-archive.com/haskell-cafe@haskell.org/msg09588.html
04:34:29 <ksf> that explains a lot :)
04:34:35 <hayashi> how about
04:34:46 <hayashi> @pl \f g fst snd -> ap fst snd . ( f *** g )
04:34:46 <lambdabot> (flip (flip . ((.) .) . ap) .) . (***)
04:35:11 <hayashi> I swear @pl tries to reduce everything down to Morse code
04:35:19 <bitonic> hayashi: if you're trying to generate absurd pl output, there are excellent examples on the wiki
04:36:14 <bitonic> @pl \f g (a,b) -> (f a, g b)
04:36:15 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
04:36:18 <bitonic> I like this one
04:37:17 <hayashi> especially since that looks like an application of *** >_>
04:37:29 <bitonic> yeah, sadly pl is not awayre of arrows
04:37:32 <bitonic> *aware
04:37:56 <hayashi> however, it's painfully very aware of the -> monad?
04:37:57 <quicksilver> it's not even aware of haskell syntax :(
04:39:20 <hayashi> I find pl useful for when I'm having a massive brain fart with making things pointfree, but most of pl's job is convincing me to keep things pointed for make benefit glorious sanity of code readers =P
04:39:33 <hayashi> Or use arrows.
04:40:09 <Ptival> ironically, pl is making your point :)
04:41:09 <hayashi> I'm worried I pointfree too much stuff as it is >_>
04:41:29 <merijn> hayashi: I just result to horrible type hacks to make things point free (and then I find out I still can't make it work...I wonder if I can trick edwardk into solving my problems if he shows his face in here...)
04:41:39 <edwardk> ?
04:41:53 <kallisti> can I document a derived instance?
04:42:00 * edwardk hides his face.
04:42:12 <edwardk> kallisti: with haddock comments?
04:42:15 <kallisti> like:  data X deriving (Eq -- ^this is important stuff about this Eq instance
04:42:15 <Botje> merijn: typically you go "X is impossible in haskell" and wait for the blog posts.
04:42:15 <kallisti> )
04:42:17 <Ptival> @edwardk \f g (a,b) -> (f a, g b)
04:42:17 <lambdabot> Unknown command, try @list
04:42:17 <kallisti> edwardk: yes.
04:42:27 <edwardk> kallisti: not sure. maybe with standalone deriving?
04:42:33 <merijn> edwardk: I tried making things work based on your vgrad code, and I eventually found a way to implement the typeclass but then GHC isn't able to properly type infer to make it work
04:42:57 <kallisti> edwardk: I'll give it a test and see.
04:43:18 <edwardk> ptival: bimap in bifunctors
04:43:36 <hpaste_> merijn pasted “Type hackery” at http://hpaste.org/67092
04:43:57 <edwardk> merijn: ah. @tell or email me the issue, and i'll poke at it
04:44:39 <edwardk> the solution i was proposing was to get rid of the 'm' based instances and make them up for particular concrete type constructors
04:45:04 <edwardk> as it is (m b) and (c -> f) overlap
04:45:28 <edwardk> but (Foo b) and (c -> f) do not
04:45:28 <merijn> oh, because (->) r is instance of monad?
04:45:34 <kallisti> edwardk: it gives a parse error so I'm guessing "no"
04:45:41 <merijn> Curses!
04:45:42 <edwardk> nah, just because ((->) c) can match m
04:45:44 <kallisti> I'll try standalone deriving
04:46:10 <edwardk> kallisti: with StandaloneDeriving turned on?
04:46:31 <merijn> edwardk: Could I constrain it by doing "class (Monad m) => Hack m" and just constraining all possible instances to have m as a monad?
04:46:38 <edwardk> the instance in scope are irrelevant, since no backtracking is done.
04:46:44 <kallisti> edwardk: it didn't work in just the regular deriving clause.
04:46:45 <edwardk> so that doesn't work
04:46:51 <merijn> The first works but requires to much type annotation to be useful
04:46:53 <edwardk> you need the constructors to be distinguishable
04:47:16 <kallisti> edwardk: also doesn't work with standalone deriving. :(
04:47:16 <edwardk> kallisti: and standalone ?
04:47:17 <kallisti> oh well
04:47:19 <edwardk> ah well
04:47:21 <kallisti> I'll just put a note somewhere
04:47:23 <edwardk> then you're out of luck
04:47:38 * kallisti submits an issue to haddock. :P
04:48:02 <edwardk> kallisti: the main concern will be whether or not haddock can get what it needs out of the ghc api for those
04:48:19 <edwardk> there i don't know the answer
04:48:22 <merijn> For example: "foo return ['c'] :: (Monad m, Hack Char [] (m Char) g) => g" where (with the current instances) the values of m and g should be uniquely identifiable
04:48:30 <kallisti> edwardk: I would think all it needs is the name...
04:48:35 <kallisti> unless I'm missing something
04:48:57 <edwardk> kallisti: well, i don't know if the ghc api holds onto those comments for later extraction
04:49:11 <kallisti> ah
04:49:34 <kallisti> it's probably not often that people wish to document a derived instance
04:49:39 <edwardk> merijn: yes, what i'm proposing is instance Hack a [] [b] [a] where
04:49:47 <edwardk> or whatever the equivalent is
04:49:58 <edwardk> merijn: then [] and (->) c don't overlap
04:50:02 <edwardk> unlike (->) c and m
04:50:18 <merijn> Yeah, I guess I'll just go that route
04:50:26 <edwardk> and you probably need more fundeps
04:50:30 <kallisti> but I want to specifically mention that you should use an IO-lifted equality function for my type, instead of Eq (but the Eq and Ord instances  exist so that you can do stuff with Map and friends)
04:51:10 <edwardk> a m -> g, g -> m a, etc
04:51:38 <edwardk> afk a bit
04:51:52 <kallisti> {-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable,
04:51:52 <kallisti>     TemplateHaskell, OverloadedStrings, ExistentialQuantification,
04:51:52 <kallisti>     MultiParamTypeClasses, TypeFamilies, NoMonoLocalBinds
04:51:53 <kallisti>   #-}
04:51:57 <kallisti> oh, oops.
04:52:14 <kallisti> silly irssi
04:52:19 <merijn> edwardk: It just annoys me that I'd have to add extra restrictions that I have to manually track in the instance definition, while it seems the compiler should be able to infer what I want...
04:52:37 <edwardk> it can't. accept it and move on ;)
04:52:56 <edwardk> or live with overlapping instances and the fact that this will just go nuts when you go to use it with the reader monad
04:53:12 <merijn> I guess it can't because of the open world assumption?
04:53:13 <edwardk> personally i prefer the former approach
04:53:19 <edwardk> yep exactly
04:53:32 <merijn> If only we had habit like instance chains with explicit closing this would work fine! >.>
04:53:54 <edwardk> This is why I use those Exp and AD newtypes, which _only_ exist so that instances have a place to 'grab onto'
04:54:00 <kallisti> just turn on IncoherentInstances everything will be fine.
04:54:19 <merijn> Unfortunately if I demand volunteers to implement that everyone will probably suggest I do it myself...
04:54:31 <edwardk> pretty much
04:54:37 <kallisti> newtypes are not too difficult to make.
04:54:48 <kallisti> you get all of the instances of the old type for free, pretty much
04:56:04 <kallisti> StandaloneFunctionDeriving
04:57:20 <kallisti> newtype Blah = Blah (Map Float Value);  deriving insert :: Float -> Value -> Blah -> Blah
04:57:23 <kallisti> :>
04:59:16 <yadav> okay haskell n00b here, tell me is it mature enough (and supports concurrency) to develop a commercial platform on it (for ex. a payment gateway) and also a really good book or any other resource to start with?
04:59:29 <yadav> thanks in advance
05:00:03 <Botje> there's learn you a haskell and real world haskell
05:00:05 <Botje> both free books
05:00:26 <merijn> yadav: Haskell is certainly mature enough, it's used in the financial world by several companies
05:00:51 <merijn> yadav: As Botje suggests I would recommend Learn You a Haskell followed by Real World Haskell as intro books
05:00:53 <merijn> @where lyah
05:00:53 <lambdabot> http://www.learnyouahaskell.com/
05:00:55 <merijn> @where rwh
05:00:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:01:01 <Botje> yadav: however, it's probably a bad idea to do something involving money as a learning project :)
05:01:03 <kallisti> if 20 years isn't enough for Haskell to become mature, then I think there would be a problem..
05:01:26 <merijn> kallisti: Yeah, funny how haskell predates Java, Python and Ruby :D
05:02:15 <merijn> (Even funnier still is how much older Erlang is)
05:03:55 <hs_nab> yo all. FP and haskell nab here. I dont get this whole immutability thing - wont data structures get incredibly slow by that? for example does anyone have a link comparing lets the performance of a binary tree implementation in haskell/c
05:04:33 <hs_nab> -lets
05:04:36 <merijn> hs_nab: What you are forgetting is that immutability also allows for a lot of optimisation that mutable structures don't support
05:04:57 <hs_nab> merijn namely?
05:05:14 <hs_nab> no pointer aliasing or stuff like that?
05:05:24 <hpc> hs_nab: sharing - when you want to change say, the root of a binary tree
05:05:28 <Botje> hs_nab: if you add a node to a binary tree, you only need to update O(log n) nodes. you can reuse the other parts of the tree.
05:05:43 <hpc> you make a tree that is a branch with the new element
05:05:43 <Axman6> hs_nab: data can be resused safely always, doing this in a mutable language is extremely difficult to get right
05:05:57 <hpc> the left subtree is the same subtree as the first tree
05:06:00 <merijn> For example, when you have a binary tree and update the left branch you have to create a new tree, but the right branch of the new tree can just use the right branch of the old tree
05:06:01 <hpc> and same for the right subtree
05:06:14 <hpc> so you still only have to allocate/traverse a single element
05:06:30 <merijn> Since immutability guarantees that the old tree can never be changed
05:06:37 <hpc> in any mutable language, if you really did want a copy of the tree with just that one element changed, that's a whole traversal
05:06:37 <reinoud> @hoogle Maybe
05:06:37 <lambdabot> Prelude data Maybe a
05:06:38 <lambdabot> Data.Maybe data Maybe a
05:06:38 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
05:06:46 <hs_nab> give me 2 minutes to read all that
05:07:00 <merijn> hs_nab: You end up having to do a little more work than in mutable languages, but not as much as you'd naively expect
05:07:32 <Axman6> hs_nab: also immutable structures make for amazingly easy and powerful concurrent use. all you need is an atomic compare and swap instruction, and you can share an immutable structure between threads, without much worry, and with very good performance
05:07:42 <kallisti> it's also important to note that the algorithms that are efficient on mutable structures are not the ones that are efficient on immutable ones.
05:08:27 <kallisti> mergesort works much better on immutable data than quicksort, for example.
05:08:38 <kallisti> (in fact I don't really know that quicksort makes sense without mutability)
05:08:58 <merijn> hs_nab: In C/Java if you want to copy a list and append a new item to the front you need to copy the entire old list. Because else you get wrong behaviour if the old list changes. In haskell you just create one new node and point it to the start of the old list and treat the new node as your "new" list. This will work since the old one never changes
05:09:05 <hs_nab> kallisti inplace quicksort for sure not :D
05:10:00 <hs_nab> merijn wow those are some powerful ideas there
05:10:18 <hs_nab> merijn i never thought about immuability this way
05:10:29 <merijn> hs_nab: This StackOverflow also has some discussion about complexity of pure functional programming: http://stackoverflow.com/questions/1990464/efficiency-of-purely-functional-programming
05:11:19 <merijn> There is a proof that you can convert any mutable program into an immutable one with a "log n" slow down (which is not so bad), and in many common cases you can find different algorithms which are just as fast as the mutable ones
05:11:54 <merijn> hs_nab: In addition, haskell does let you use mutable data too. But only when it is properly typed as mutable data (for example, IORef's)
05:11:55 <hpc> hs_nab: in general, when you read about "haskell can't BLAH", think about what you gain by having that as an assumption, rather than what it prevents you from doing
05:12:22 <kallisti> hpc: Haskell can't interact with the outside world!
05:13:21 <kallisti> (but then consider how efficient your programs can be when you don't even need to run them!)
05:13:25 <hs_nab> hpc this is like whole new world for me, im coding in c for like 10 years (22 now), these ideas are so alien to me. but at the same time i am very excited.
05:13:28 <merijn> hs_nab: Yeah, it's common that people don't stop to think of those ideas :) I remember having a compiler class with a C-like target language and almost all optimisations we discussed ended with "but you can't do this, because someone might change the global state". C compilers have gotten much better at checking whether things can be changed, but in general they're still fairly limited
05:13:57 <hs_nab> log n slowdown merijn is almost like nothing
05:13:57 <merijn> hs_nab: Also, as Axman6 pointed out, immutable data makes threading trivial. You can't have data races without mutable data :)
05:14:17 <kallisti> it also makes a lot of other things trivial
05:14:19 <kallisti> like continuations
05:15:41 <kallisti> hs_nab: also note that immutability /is/ possible, it's just not as commonly used.
05:15:55 <merijn> kallisti: I think you mean mutability :p
05:15:59 <hs_nab> kallisti you mean mutability?
05:16:02 <kallisti> er, yes. :P
05:16:13 <Axman6> data Tree a b = Leaf a b | Node a b  (Tree a) (Tree a); lookup :: Ord a => a -> Tree a b -> Maybe b; lookup x (Leaf y b) | x == y = Just b | otherwise = Nothing; lookup x (Node y b l r) = case compare x y of LT -> lookup x l; GT -> lookup x r; EQ -> Just b -- an example of working with trees in haskell
05:16:33 <Axman6> for hs_nab
05:16:43 <hs_nab> Axman6 syntax so clean
05:16:56 <Axman6> looks pretty ugly on a single line =)
05:17:00 <hpc> haha
05:17:05 <merijn> Well, you can use braces and semicolons if you want. But people will dislike you :p
05:17:47 <kallisti> @pl \x y z g h -> h (x y) y z (g h x)
05:17:48 <lambdabot> ap (flip . ((flip . (((.) . ap) .) . flip) .) . (flip . flip id =<<)) (flip flip)
05:17:54 <kallisti> yeah I agree Haskell has pretty clean syntax.
05:18:10 <merijn> I'm pretty sure @pl doesn't count :p
05:18:22 * kallisti flips merijn.
05:18:26 <hayashi> @pl \x -> f x >>= g
05:18:26 <lambdabot> (g =<<) . f
05:18:34 <hayashi> ick
05:18:40 <hpc> @pl [x | x <- heyLookAListComprehension, iWonderWhatThisWillDo]
05:18:41 <lambdabot> [x | x <- heyLookAListComprehension, iWonderWhatThisWillDo]
05:18:48 <hpc> @pl \x -> [x | x <- heyLookAListComprehension, iWonderWhatThisWillDo]
05:18:48 <lambdabot> (: [iWonderWhatThisWillDo]) . (<- heyLookAListComprehension) . join (|)
05:19:00 <hs_nab> hmmm the fact is I mainly code network apps in C (data intensive apps like NoSQL databases and similar stuff), or web apps in Node.js(CMS-es with dynamic code loading, etc). do you think i would win by learning Haskell?
05:19:11 <kallisti> hpc: pl doesn't grok list comprehensions it seems
05:19:12 <hs_nab> *win anything
05:19:35 <kallisti> haskell can do both of those things. But it will take a while before you can use it efficiently for such things.
05:19:37 <merijn> hs_nab: I would argue learning haskell will always win you something. Even if it's just insight in how things can be done differently
05:19:43 <Axman6> hs_nab: definitely, haskell is a fantastic language for writing network apps
05:19:47 <hpc> hs_nab: a lot of what node.js claims to be good at, you will find haskell does better
05:19:55 <merijn> My C code is certainly different after learning haskell
05:20:02 <Axman6> you get the performance of event based systems like node, without having to write shitty event based code ;)
05:20:02 <hs_nab> hpc Node.js sucks, i just use it cause PHP sucks even more
05:20:39 <merijn> And Node.js seems to glorify asynchronous programming. I used to think this was a good idea until I realised the value of green threads and synchronous programming :)
05:20:45 <hs_nab> callbacks make me puke +1
05:21:00 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=5 -- here's some totally-from-scratch haskell CGI
05:21:20 <hpc> an example of bending haskell syntax to fit the problem
05:21:54 <merijn> hs_nab: In haskell the general approach is to just have synchronous code and have one thread per connection. The lightweight threads can easily scale up to 100k or more threads
05:22:04 <hs_nab> to be honest i plan to stop writing in C and Node.js, and swap them for Google Go. Go seems neat, but maybe I could go one step further and learn Haskell
05:22:15 <quicksilver> merijn: if your approach to true threading is to try to program with shared mutable state and suffer from bugs where one thread is exposed to another thread's temporarily broken invariants, which you learn to fix by explicit locking, then you come to hate threads and appreciate the simplicity of callbacks.
05:22:28 <ben> hs_nab: if you wanna take not quite that step, look into rust :)
05:22:41 <merijn> quicksilver: Yes, that's why I originally thought callbacks were a good idea
05:22:52 <Axman6> hs_nab: GHC's IO subsystem is based around libev or kqueue, which gives us fantastic performance for high level IO code (it's trivial to write simple servers that can handle 100,000 requests a second on a not very powerful machine)
05:22:53 <quicksilver> merijn: on the other hand, if your approach to threading is default-immutable state and simple synchronisation primitives, then threads seem to have a lot more going for them.
05:23:10 <merijn> hs_nab: I kinda like Go as a "fixed" C, but it lacks C's portability and is just not quite there yet
05:23:18 <hs_nab> ben that seems neat too, but so young now.
05:23:26 <ben> yeah.
05:23:39 <ben> but it's kinda inbetween C and go and haskell ;)
05:23:49 <hs_nab> Axman6 that sounds nice, though i cant believe that 100 000 req :D thats too frigging high
05:24:02 <merijn> hs_nab: I think Haskell as more interesting to learn than Go, mostly because Go is not all that exciting and innovating
05:24:16 <Axman6> hs_nab: it's poretty simple to do, i've done it myself, with less than 100 lines of code (simple ping pong server mind you)
05:24:44 <Axman6> uh, that was for merijn (your nicks show up as the same colour)
05:24:55 <hs_nab> merijn But at the same time Go is so practical, I am scared Haskell will be exciting and stuff but wont speed up my developement speed even when I am sufficiently familiar with it.
05:25:02 <merijn> (Also, people in this channel are awesome. Major point in haskell's favour. :>)
05:25:19 <merijn> hs_nab: Go isn't used much outside Google yet, so...
05:25:23 <ben> so practical that the gc is choking on 32 bit systems :>
05:25:24 <hs_nab> Yes, you are really heplful and friendly, I appreciate that.
05:26:01 <merijn> hs_nab: If you know C and Haskell I wager you can pick up Go in half a week or so, so you can always learn it for money-oriented programming if needed
05:26:10 <merijn> (Probably even less time)
05:26:18 <quicksilver> hs_nab: haskell has a lot to teach you. It will take some time to learn the lessons though.
05:26:27 <hs_nab> I have just finished to write a B+tree in Go (just to learn the language). I think i will do the same in haskell and see the difference
05:26:30 <quicksilver> not the language itself, which I'm sure you can learn quite fast.
05:26:44 <quicksilver> but the lessons from the different approach taken
05:26:47 <merijn> 1.5 years in the haskell community has taught me more than 3 years of CS education
05:26:49 <bitonic> well, if you want to learn money-oriented programming even Go might be too risky.
05:26:53 <hs_nab> merijn Already learned Go in a week
05:26:55 <Axman6> aye, the lessons haskell teaches you take quite some time to firstly learn, and secondly understand why they're worthwhile
05:27:18 <quicksilver> ideally all programms should learn haskell, and also lisp
05:27:22 <quicksilver> programmers.
05:27:29 <quicksilver> even if they never use either in anger.
05:27:32 <bitonic> hs_nab: is it an on-disk B-tree or is it just a data structure? in the former case I wouldn't start with that in haskell
05:27:54 <merijn> quicksilver: Lisp is still on my to do list. I guess I should learn Racket for my PLT cred?
05:28:05 <hs_nab> bitonic It is inmemory only
05:28:08 <bitonic> merijn: racket is very nice. or nowadays you can go for clojure as well
05:28:11 <hs_nab> But plan to add persistence
05:28:12 <hpc> if you want to be really pathological, write a distributed B-tree in erlang
05:28:21 <bitonic> guile is nice too, more lightweight then racket
05:28:41 <merijn> Clojure gives less PLT street cred
05:28:53 <quicksilver> merijn: I don't think it matters much which, to be honest.
05:28:58 <merijn> quicksilver: Probably not
05:29:25 <bitonic> it matters if you want to learn by doing, racket is a very nice environment
05:29:33 <bitonic> with a comprehensive library
05:29:44 <bitonic> good docs, etc.
05:29:47 <merijn> I've already started reading SICP a bit (and already read the McCarthy paper) so I feel I have a ok grasp of Lisp's ideas. It's just actual use that I haven't tried :p
05:29:50 <quicksilver> merijn: just spending some time thinking about homoiconic programming, macros, hygienic macros compared to a type system
05:29:51 <hs_nab> i read that somewhere that if quantum computers will be here(next 5-10 years) we can forget imperative programming altogether, what do you think about that?
05:30:19 <merijn> hs_nab: BS, because 1) they won't be ready, 2) won't replace normal computers and 3) are nearly impossible to program
05:30:38 <merijn> Quantum computers can solve *some* problems better than normal computers, but not all of them
05:30:55 <merijn> And it takes people with a PhD 2 years to write a single simple algorithm for them.
05:31:06 <Axman6> as far as we know, they're definitely not general purpose computers
05:31:09 <merijn> I wouldn't worry about them
05:31:29 <Axman6> merijn: what of all the PhD owners who'
05:31:36 <hs_nab> Axman6 dont they mean to be later?
05:31:47 <merijn> You have a bigger risk of suffering from the concurrency revolution where we switch to many core NUMA architectures with non-deterministic computation
05:31:55 <Axman6> who've come up with the algorithms we use every day to make programming the computers we use mpossible? =)
05:32:40 <kallisti> > (`replicateM` "abc") =<< [0..]  --obligatory showing off for hs_nab
05:32:41 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
05:33:03 <hiptobecubic> kallisti, it's not impressive if you don't know whats going on
05:33:10 <Axman6> > filterM (const [True, False]) "abc"
05:33:11 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
05:33:13 <hs_nab> errmmm im trying to grasp
05:33:14 <hs_nab> :D
05:33:15 <kallisti> hiptobecubic: that makes it even more impressive, I think. :P
05:33:24 <Axman6> powerset!
05:33:36 <kallisti> hs_nab: I wouldn't worry about it right now..
05:33:40 <merijn> > let fibonaccis = 0 : 1 : zipWith (+) fibonaccis (tail fibonaccis) in fibonaccis
05:33:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:33:45 <hiptobecubic> Axman6, i still haven't figured out how that hell that one works.
05:33:51 <hs_nab> lambdabot is an HS interpreter?
05:33:52 <hs_nab> :D
05:33:54 <merijn> Obligatory fibonacci solutions
05:34:00 <hiptobecubic> lambdabot, is everything
05:34:04 <hs_nab> :DDDDDDDDDD
05:34:06 <Axman6> hiptobecubic: yeah i'm still not sure 100% either, but i haven't spent much time thinking about it =)
05:34:07 <hs_nab> neat
05:34:23 <kallisti> hiptobecubic: you can think of the powerset as walking up to each element of the set and asking "are you in the set or not?"
05:34:25 <merijn> hs_nab: Yes, and much more. It also has a search machine that lets you search by type signature and "simplify" (for some value of simple) code
05:34:28 <kallisti> if you take all of the possible combinations
05:34:30 <Axman6> > fix (scanl(+) . (1:))
05:34:31 <lambdabot>   Couldn't match expected type `[a] -> [a]'
05:34:31 <lambdabot>         against inferred type `[t]'
05:34:33 <kallisti> where an element is either in the set, or not
05:34:34 <Axman6> hmm
05:34:35 <kallisti> you get the powerset
05:34:42 <Axman6> > fix (scanl1(+) . (1:))
05:34:44 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
05:34:48 <Axman6> nope
05:35:03 <ion> > fix ((0:) . scanl (+) 1)
05:35:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:35:08 <emias> i
05:35:11 <hs_nab> what about that lazy evaluation thing? seems fucked up for me (sorry for the language)
05:35:14 <Axman6> thanks ion =)
05:35:33 <Axman6> hs_nab: infinite data structures are amazingly useful
05:35:41 <kallisti> so filterM (const [True, False])   is producing the distinct possibility that an element is in a particular subset of the powerset or not in a particular subset of the powerset.
05:35:44 <kallisti> for each element in the set
05:35:49 <merijn> hs_nab: It can be pretty useful in some scenarios (but the only one I can think of the top of my head is probably a bit to hard to explain right now)
05:35:51 <Axman6> > let label xs = zip [1..] xs in label "Helo"
05:35:51 <lambdabot>   [(1,'H'),(2,'e'),(3,'l'),(4,'o')]
05:35:58 <Axman6> l* >_>
05:36:20 <Axman6> :t filterM
05:36:20 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:36:45 <hs_nab> but can i switch to eager evaluation if i want to?
05:36:53 <Axman6> sure
05:36:59 <kallisti> hs_nab: the primary benefit of lazy evaluation is that it allows you to express a computation in a very concise way, without it being horribly inefficient
05:36:59 <macobo> It's possible, but kinda akward.
05:37:22 <Axman6> but, if you're learning haskell, DO NO TRY TO USE EAGER EVALUATION UNTIL YOU COMPLETELY UNDERSTAND WHY LAZY EVALUATION IS SO USEFUL!
05:37:35 <navaati> hi
05:37:36 <hs_nab> Axman ok
05:37:53 <hs_nab> hi
05:38:02 <merijn> > tail [error "Whoops?", 1,2,3,4]
05:38:03 <lambdabot>   [1,2,3,4]
05:38:04 <mekeor> hi navaati :)
05:38:12 <kallisti> hs_nab: also lazy evaluation only really works sanely in Haskell because there are no side-effects to any given computation.
05:38:17 <navaati> is there a difference between rank n types and existential quantification, or is it the same thing ?
05:38:54 <hs_nab> kallisti What if someting wont be calculated until it must be shown to me, but that thing takes 1 hour to calculate?
05:39:09 <quicksilver> I suspect that in practice the most important thing about lazy evaluation is making value recursion easy and natural
05:39:11 * hackagebot HsOpenSSL 0.10.2.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.2.1 (MasatakeDaimon)
05:39:15 <hs_nab> kallisti Sorry if i a.,misunderstood lazy eval b.,cant express my thoughts well
05:39:22 <quicksilver> q.v. ML and its ever-so-annoying value restriction.
05:39:36 <navaati> hs_nab: you can control how the evaluation is done
05:40:01 <navaati> so if you need the value to be gradually computed even if it's not immediatly needed, you can
05:40:09 <quicksilver> why lazy evaluation : http://stackoverflow.com/a/265548
05:40:20 <hs_nab> reading that link quicksilver
05:40:30 <kallisti> hs_nab: well most likely you'll already start computing that 1 hour computation at the beginning
05:40:36 <kallisti> ...if that makes sense.
05:40:43 <kallisti> I mean, it would depend on the scenario, of course.
05:40:47 <hs_nab> kallisti fine, thats what i wanted to know
05:40:56 <hs_nab> this lang seems so cutting edge
05:41:08 <hiptobecubic> > filterM (==1) [1,2,3]
05:41:09 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
05:41:09 <lambdabot>         against inferred typ...
05:41:16 <hiptobecubic> :t filterM
05:41:17 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:41:18 <Axman6> :t filteRM
05:41:18 <lambdabot> Not in scope: `filteRM'
05:41:20 <Axman6> bleh
05:41:38 <navaati> hs_nab: lazy evaluation is not really cutting-edge, it have existed for tens of years i think
05:41:53 <hs_nab> navaati not that, the whole of it :D
05:41:53 <navaati> it is just that mainstream languages are so boring :D
05:41:57 <merijn> Well yes, since haskell is 22 years old :p
05:42:09 <hiptobecubic> > filterM (return . (==1)) [1,2,3]
05:42:10 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
05:42:10 <lambdabot>    arising from a use of `M67487115...
05:42:12 <Axman6> hs_nab: you haven't even heard about things like our easy parallelism (which is different from concurrency) and software transactinal memory =)
05:42:17 <hiptobecubic> lol
05:42:17 <kallisti> hiptobecubic: essentially the list you return produces multiple possibilities for whether a predicate holds. if you say [True] then it's only always True, if you say [False] then it's only always False, if you say [True, False] then it can be both, and both possibilities will be produced in the otput.
05:42:28 <kallisti> I don't remember what happens with []
05:42:37 <hiptobecubic> > filterM (const []) [1,2,3]
05:42:38 <lambdabot>   []
05:42:50 <hiptobecubic> > filterM (const [True, True]) [1,2,3]
05:42:51 <hs_nab> Axman6 so you think Haskell is better suited for a wider range of architectures compared to imperative programming? Because thats the next question i wanted to ask
05:42:51 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
05:43:08 <hiptobecubic> > filterM (const [False, True]) [1,2,3]
05:43:09 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
05:43:18 <merijn> hs_nab: I do, because you can do imperative programming in haskell, but not functional programming in C/Java
05:43:28 <hiptobecubic> > filterM (const [False, True, False]) [1,2,3]
05:43:29 <lambdabot>   [[],[3],[],[2],[2,3],[2],[],[3],[],[1],[1,3],[1],[1,2],[1,2,3],[1,2],[1],[1...
05:43:34 <merijn> I'm not joking, I really like haskell as an imperative language...
05:43:45 <Axman6> hs_nab: not necessarilly, i think haskell is well suited to many problems, but you should always use the right tool for the job. sometimes the right tool is PHP, sometimes it's C++, sometimes assembly
05:43:55 <hs_nab> merijn It doesnt even has a loop, has it?
05:44:00 <hs_nab> *have
05:44:06 <hiptobecubic> hs_nab, sure it does
05:44:12 <hiptobecubic> :t for
05:44:12 <lambdabot> Not in scope: `for'
05:44:15 <hiptobecubic> :D
05:44:16 <merijn> :t forM
05:44:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:44:17 <Axman6> hs_nab: lists are loops
05:44:19 <hiptobecubic> :t forM
05:44:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:44:29 <merijn> Lists are loops waiting to happen ;)
05:45:08 <hs_nab> one more question and i wont bother the lords more
05:45:21 <navaati> (btw, PHP is *NEVER
05:45:25 <navaati> * the right tool)
05:45:31 <hs_nab> +1
05:45:41 <Axman6> hs_nab: we welcome all (relevant) questions
05:45:44 <kallisti> everything PHP does, Perl does better. :P
05:46:16 <merijn> Axman6: And even a lot of irrelevant ones :p
05:46:28 <Axman6> indeed =)
05:46:48 <kallisti> hs_nab: but yeah that's an interesting thing about lazy evaluation. Your data structures also double as flow control structures.
05:47:21 <kallisti> thus lists are equivalent to a linear loop, where each element in the sequence is the next value in the loop.
05:47:30 <hs_nab> what about the developement speed in haskell, in day to day tasks? please be honest :)
05:47:53 <merijn> When you're just starting probably very low. When you get a bit proficient, quite fast.
05:47:57 <hs_nab> kallisti i like that approach
05:48:04 <hs_nab> merijn what if i learn it well?
05:48:04 <Axman6> i'm a hell of a lot faster in Haskell than I am in C =)
05:48:08 <merijn> I wrote most of my distributed reference counting simulation in about a day
05:48:22 <Axman6> but to be honest, I don't think that's a sensible question
05:48:27 <kallisti> well, from my experience, it can be pretty quick. I wrote a client for the Selenium WebDriver protocol in about 5 days, and Selenium devs estimated it would take about 2 weeks or so.
05:48:29 <hs_nab> hpc is your name an abbr. of high performance computing?
05:48:29 <merijn> And then I spend half a week on self-gratifying type hackery
05:49:40 <kallisti> hs_nab: while it likely takes longer to code up solutions in Haskell than it does, say, Python, you save a lot of time in the debugging.
05:49:49 <kallisti> because there's just not as many runtime error possibilities.
05:50:02 <hs_nab> kallisti Since i enjoy coding more than debuggins, seems like a deal :D
05:50:08 <hs_nab> debugging*
05:50:22 <kallisti> yes most of your errors are compile errors.
05:50:31 <kallisti> in general.
05:50:32 <Axman6> well many
05:51:47 <kallisti> it certainly depends on what you're doing.
05:52:33 <kallisti> most runtime errors I get involve faulty input/output handling.
05:52:34 <hs_nab> its so fascinating that the GHC performs kinda good compared to GCC
05:53:23 <kallisti> since -Wall warns you about partial case expressions, I don't get very many exhausted pattern matches
05:53:34 <Axman6> GHC isn't a C compiler, so it's not really a good idea to compare the two
05:53:51 <hs_nab> Axman6 no no no
05:54:02 <HugoDaniel> ghc uses gcc
05:54:09 <Axman6> not any more
05:54:11 <merijn> HugoDaniel: No
05:54:11 <HugoDaniel> oh
05:54:18 <HugoDaniel> sorry, im outdated then :)
05:54:19 <kallisti> hs_nab: there's less overhead associated with abstraction than in a side-effectful language.
05:54:22 <merijn> There is a native (default) and llvm backend
05:54:28 <kallisti> because most of it can just be inlined away.
05:54:31 <hs_nab> i mean the fact Haskell which seems so high level can be compiled to native code efficiently is fascinating
05:55:04 <kallisti> it turns out equation reasoning leads to good optimization techniques.
05:55:07 <kallisti> *equational
05:55:32 <navaati> hs_nab: it is *precisely* because it's so high-level that it can compile to so efficient code
05:55:44 <hs_nab> okay im gonna compile my first haskell program no :D
05:55:53 <hs_nab> navaati that seems so counter-intuitive for me
05:55:57 <hs_nab> now*
05:56:39 <hiptobecubic> hs_nab, i asked him that a few weeks ago. It's not related.
05:56:46 <hs_nab> i run a web developer company in my country, haskell's website is so nice :D
05:57:08 <hs_nab> hiptobecubic i see
05:57:13 <navaati> hs_nab, the concept is that the compiler has a lot more static knowledge about your program in haskell than in C, so it can be more clever
05:57:20 <kallisti> hs_nab: let me know if you need any Haskell freelancers. ;)
05:57:45 <hiptobecubic> hs_nab, in C, you can't assume very much about what the programmer was intending to do.
05:57:57 <hs_nab> kallisti :DD sure. we dont have staff for now, we are mostly just a bunch of friends started a company =)
05:58:19 <Axman6> hs_nab: i'd ask for a job too, if i didn't hate web dev =)
05:58:30 <hiptobecubic> Amen
05:58:40 * kallisti is not picky.
05:59:07 <hiptobecubic> it's unfortunate that web dev is so clearly the future of user-facing applications
05:59:13 <merijn> kallisti: Clearly you ahven't done much web dev before ;)
05:59:17 <hiptobecubic> because damn, it's terrible.
05:59:33 <navaati> hiptobecubic: don't be so pessimistic
05:59:42 <hs_nab> hiptobecubic That is an interesting concept.
05:59:59 <nand`> what's the best way to refine “data Foo = X Foo | Y Foo | N” so that chains of X or Y have to be consecutive, eg. “X (X (X (X N)))” or “Y (Y N)” are allowed but “X (Y (X N))” is not?
06:00:01 <hs_nab> (compiler knowing the intention behind the programmers actions)
06:01:04 <merijn> nand`: "data X; data Y; data Foo a = F (Foo a)"?
06:01:18 <hs_nab> Web developement isnt that bad. Doing boring domain-specific CRUD apps with a gui is much worse. You could say that web dev is similar but i find it much more challenging
06:01:22 <hs_nab> and exciting
06:01:26 <thoughtpolice_> it is of course worth mentioning as well, that GHC generates fast code because it has had a lot of calculated engineering effort and years of research thrown at the problem, and there are lots of fine details which add up to saving runtime performance here and there. a lot of optimizations are certainly enabled or simpler thanks to purity though
06:01:31 <navaati> nand`: i think you can only do that by adding a phantom parameter to your type
06:01:59 <hs_nab> Anyone read the "Pure functional data structures" book, i plan to order
06:02:09 <nand`> merijn: that could work, basically an Either [X] [Y]
06:02:21 <merijn> hs_nab: Okasaki?
06:02:30 <nand`> navaati: that was my first thought as well but I figured it'd end up very ugly
06:02:34 <navaati> nand`: it could be quite nice with GADT and kind promotion, actually
06:02:34 <hs_nab> y
06:02:37 <hs_nab> nand' y
06:02:57 <hs_nab> damn :D what character is that?
06:02:58 <hs_nab> :D
06:03:04 <nand`> I was thinking a GADT along the lines of X :: forall a. IsX a => Foo a -> Foo a
06:03:11 <hs_nab> ` i dont have this on my keyboard
06:03:11 <hs_nab> :D
06:03:37 <navaati> hs_nab: you have it, it's simply a backquote…
06:03:47 <merijn> navaati: Don't be so sure
06:04:17 <merijn> Not everyone uses a ISO US101 keyboard
06:04:22 <nand`> hs_nab: in my US International layout (based on QWERTY) I obtain it by pressing the key to the left of ‘1’
06:04:42 <navaati> merijn: damn, there are keyboards without backquote ? annoying to code in haskell…
06:05:01 <navaati> (on a french azerty it's altgr+7)
06:05:01 <hs_nab> nand` at me it does: "
06:05:03 <hs_nab> XD
06:05:07 <hiptobecubic> i find that there are no keyboards which have all the keys i want
06:05:08 <merijn> navaati: I'm not sure. But I certainly wouldn't presume all national keyboard layouts do
06:05:20 <hiptobecubic> I always end up having to map things myself all over the place
06:05:32 <merijn> hs_nab: What keyboard layout do you have? (Alternatively, what country are you in?)
06:05:33 <nand`> If that does not work; you could try pressing the Tabulator key after typing “nand” which depending on your client will probably auto-complete to “nand`”; that aside it doesn't matter since my client is configured to highlight “nand” as well :)
06:05:34 <hs_nab> hiptobecubic that sucks so much
06:05:43 <hs_nab> merijn Hungarian
06:05:54 <hiptobecubic> hs_nab, only the first time. Now I just bring my config file with me.
06:06:36 <nand`> merijn: I find most nationalized keyboard layouts to be particularly painful for programming in comparison with QWERTY, Haskell included
06:06:38 <hs_nab> hiptobecubic well i could do that, im too hyperactive and absent minded
06:06:39 <merijn> hs_nab: Looks like "Alt Gr + 7" for standard hungarian layout
06:06:51 <hs_nab> `
06:06:52 <merijn> https://en.wikipedia.org/wiki/File:KB_Hungary.svg
06:06:52 <hs_nab> daamn
06:06:53 <hs_nab> :D
06:06:57 <nand`> this is the reason I forced myself to relearn from QWERTZ to QWERTY; it makes coding much easier
06:07:12 <hs_nab> never felt the need to use it
06:07:13 <hs_nab> :D
06:07:20 <hiptobecubic> <3 US101
06:07:46 <hiptobecubic> although I have fashioned my own alt-gr bindings for french and special chars
06:07:58 <nand`> (that being said I can't stand standard QWERTY; I use the key between z and left shift (produces ‘\’ and ‘|’) very actively)
06:08:40 * quicksilver has switched between the Mac-UK version of QWERTY and the PC-UK version of QWERTY over the years and never had a big problem with either
06:08:48 <quicksilver> fingers learn slight variations fast.
06:08:55 <hiptobecubic> nand`, it's as close as tab on qwerty. Most people seem to reach tab alright.
06:09:06 <hayashi> @pl \(c, f) -> balanceBrackets x c f xs
06:09:07 <lambdabot> uncurry (flip flip xs . balanceBrackets x)
06:09:20 * barrucadu should learn to touch-type
06:09:25 <hiptobecubic> hayashi, stay on topic please. We're discussing keyboards.
06:09:32 <nand`> hiptobecubic: yes, US International works somewhat like this. I have very many Alt Gr bindings; most of which I never set or use myself, but I did have to add some; most notably: “ ” × ÷ ≈ āēōū ≠ ‘ ’
06:09:57 <navaati> i will end up making a custom map too, so i can have ∀, ⇒, ∷, ≫ and ∘ at the tip of my fingers…
06:10:24 <hiptobecubic> I don't know what it is, but programming with unicode chars seems like the devil.
06:10:36 <nand`> Agda says hello
06:10:46 * hs_nab just installed the haskell platform on his win box
06:10:52 <navaati> bah, i really like it
06:10:53 <merijn> navaati: I want fancy advanced input (like Chinese people use) that accepts LaTeX commands for unicode
06:11:20 <navaati> merijn: there is an emacs input method
06:11:25 <nand`> merijn: consider using an IME like scim or whatever replaces it now; you could probably make a ruleset for that
06:11:38 <nand`> which would work for all programs, mind
06:11:45 <merijn> navaati: I'm not an emacs user, and that wouldn't work for all programs
06:12:02 <navaati> and also something more general for these IBus or SCIM things
06:12:03 <hayashi> ok then
06:12:05 <hayashi> @pl \(are, the) -> mechanical keyboards are the best
06:12:06 <lambdabot> uncurry (flip flip best . mechanical keyboards)
06:12:09 <hayashi> ^~^
06:12:10 <merijn> nand`: Yeah, I considered hacking something together, but it's a lot of work as these things aren't very well documented
06:12:17 <hs_nab> yo GHCi is an interpreter i guess
06:12:25 <hiptobecubic> hayashi, much better.
06:12:31 <hiptobecubic> hs_nab, yes. REPL
06:12:51 <merijn> navaati: Does SCIM support OSX?
06:13:01 * nand` finds the distinction between compiler and interpreter close to meaningless
06:13:16 <hiptobecubic> well have a nice day. i'm off
06:13:26 <navaati> merijn: ah, dunno, i was assuming linux
06:13:44 <navaati> but maybe
06:14:38 <nand`> I thought iBus was made by Apple; but that might just be the name throwing me off
06:15:23 <nand`> nvm, I was completely off
06:16:41 <hs_nab> anyone does AI/NNs in haskell?
06:17:12 <nand`> hs_nab: I think there was some discussion about NNs yesterday
06:17:38 <hs_nab> gotta check log if i find it
06:17:43 <navaati> NN ?
06:17:47 <hs_nab> neural net
06:17:53 <navaati> ah, ouch
06:18:11 <byorgey> hs_nab: there are several packages for NNs on Hackage, if I remember rightly
06:18:13 <nand`> http://hackage.haskell.org/package/HaskellNN-0.1.3 <- I think this was mentioned
06:18:25 <hs_nab> checking the pkg
06:19:57 <sanjoyd> Is it possible to say "If either a or b is an instance of typeclass X, then Either a b is also an instance"?
06:20:52 <sanjoyd> I get a duplicate instance error (since I'm declaring Either a b twice), but is it possible to somehow work around that?
06:20:55 <hs_nab> http://books.openlibra.com/pdf/haskell_tutorial_for_c_programmers_en.pdf its this paper any good?
06:22:23 <hs_nab> Its kinda sad tough i lost touch in the first 3 lines "The order to these operations does not matter. T" O.o
06:26:52 <hpaste_> navaati pasted “rfqguif” at http://hpaste.org/67093
06:26:56 <t7> my friend just boated to me about have you can set True to False in python (globally, in the middle of a computation).... how on earth is that a good thing
06:27:09 <mekeor> hs_nab: i suppose that it's only good for (former) C programmers ;)  so, don't read if you aren't :)
06:27:25 <hs_nab> mekeor I am
06:27:52 <navaati> wtf… i tried to resolve nand`'s problem (about X X X N or Y Y Y N but not X Y X N) but i run in this error even is the RankNTypes IS activated…
06:28:03 * nand` wonders if using “funtional” instead of ”functional” was intentional
06:28:13 <fmap> hs_nab: it's kinda senseless since "these operations" are not correct haskell anyway
06:28:58 <hs_nab> t7 :DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
06:29:13 <hs_nab> t7 thats nuts
06:29:34 <nand`> t7: reminds me of “let 2+2 = 5 in ... ”
06:29:40 <hs_nab> how do i write a main function?
06:29:44 <hs_nab> in a file?
06:29:45 <nand`> (which is of course something completely different but still just as pointless)
06:29:51 <navaati> main = <blah>
06:29:57 <navaati> where main :: IO ()
06:30:33 <mekeor> > let 2+2 = 5 in 2+2
06:30:34 <lambdabot>   5
06:30:39 <nand`> won't GHC's type checker accept any IO x where x is a meta-variable?
06:30:49 <mekeor> yes, it does.
06:30:56 <mekeor> @type exitSuccess
06:30:57 <lambdabot> Not in scope: `exitSuccess'
06:31:02 <mekeor> @hoogle exitSuccess
06:31:02 <lambdabot> System.Exit ExitSuccess :: ExitCode
06:31:02 <lambdabot> System.Exit exitSuccess :: IO a
06:31:10 <navaati> nand`: for main ? ah, i though it was striclty an IO ()
06:31:10 <sanjoyd> nand`:  even otherwise you can trivially add a `return ()` in the end.
06:31:29 <nand`> sanjoyd: Indeed, I was just musing on the accuracy of navaati's addendum
06:31:30 * mekeor often uses exitSuccess and exitFailure.
06:32:20 <nand`> mekeor: but that's fine, because forall a. IO a can be an IO () too so that would still type check if main :: IO ()
06:32:33 <nand`> and doesn't necessarily prove or disprove the question
06:33:03 <hs_nab> can i
06:33:13 <hs_nab> do incremental builds when my project gets large
06:33:16 <hs_nab> ?
06:33:29 <nand`> I double checked it; it does indeed accept, say, “main = return 5”
06:33:32 <navaati> hs_nab: it's automatically done by ghc or cabal
06:33:35 <mekeor> nand`: ah, hmm. but `main :: IO a' `main = exitSuccess' works..
06:33:42 <nand`> hs_nab: you can be splitting your project into modules
06:33:45 <nand`> by*
06:34:02 <navaati> mekeor: exitSuccess does not prove anything : it's an action that never returns
06:34:07 * hs_nab wrote his first haskell hello world program
06:34:14 * hs_nab is so excited
06:34:17 <mekeor> navaati: ??
06:34:35 <nand`> navaati: whether it returns or not is of no interest to the type checker
06:35:18 <nand`> but, indeed, main :: IO a; main = exitSuccess proves it
06:35:19 <navaati> err, hum, i misunderstood what you meant
06:35:31 <hs_nab> guys seriously does handling infinite list has any practical use case?
06:35:33 <navaati> yeah
06:35:41 <navaati> hs_nab: fuck yeah
06:35:42 <nand`> hs_nab: yes
06:35:53 <hs_nab> no way on earth :D
06:35:55 <hs_nab> how?
06:35:57 <nand`> hs_nab: ever used generators in languages like python?
06:36:03 <hs_nab> nope
06:36:08 <hs_nab> never done python
06:36:24 <navaati> (btw, anyone has an idea on this http://hpaste.org/67093 ?)
06:36:34 <nand`> (generators are probably used in more languages than python, I just couldn't name a better example off the top of my head)
06:36:58 <greg`> hello?
06:37:06 <mekeor> hi greg`
06:37:56 <nand`> navaati: what happens if you use something like “N :: Foo n” instead, thus omitting the “problematic” .?
06:37:58 <navaati> hs_nab: say you want to have nth fibonnacci number. the idiomatic way to do this in haskell is to construct the infinite list of fibs and index the number you want
06:38:18 <nand`> does it still automatically imply the “forall” since it's a free variable?
06:38:22 <nand`> navaati: bah, O(n)
06:38:47 <navaati> nand`: i said idiomatic, not efficient :)
06:38:49 <nand`> an O(1) solution for fib n exists, based on the golden ratio
06:39:02 <fmap> fibonnacci numbers are very practical use case
06:39:02 <greg`> ive just screwed up my haskell installation, how can i completely rebuild it?
06:39:11 <mekeor> nand`: i know that formula by heart! =)
06:39:16 <navaati> nand`: implying you have a precise enough golden ratio
06:39:23 <hs_nab> navaati so alien :D where can i find the documentation for functions like putStrLn?
06:39:44 <nand`> navaati: which can be precomputed to a desired degree and stored in much less time than it would take to traverse the list for the same kind of accuracy
06:39:44 <navaati> search for "hackage base" in google, it should do
06:39:45 <hs_nab> if i type any expresson lambdabot executes it?
06:39:48 <hs_nab> 2  + 2
06:39:52 <hs_nab> :D
06:39:54 <hs_nab> not for me
06:40:03 <mekeor> > 2 + 2
06:40:04 <lambdabot>   4
06:40:08 <hs_nab> space?
06:40:10 <nand`> @hoogle putStrLn
06:40:10 <lambdabot> Prelude putStrLn :: String -> IO ()
06:40:10 <lambdabot> System.IO putStrLn :: String -> IO ()
06:40:10 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
06:40:19 <mekeor> hs_nab: with a > at the beginning
06:40:27 <hs_nab> mekeor aaa i see
06:40:38 <navaati> hs_nab : http://hackage.haskell.org/package/base-4.2.0.2
06:40:49 <hs_nab> what namespace am i in by default?
06:40:55 <haskellMaster> hey yo
06:41:01 <navaati> hs_nab: Prelude
06:41:03 <hs_nab> haskellMaster dat name
06:41:05 <hs_nab> _D
06:41:08 <mekeor> haskellMaster: hi
06:41:09 <hs_nab> navaati ty
06:41:16 <byorgey> nand`: that is only O(1) if you stipulate that exponentiating a floating-point number with enough precision is O(1), which is completely unrealistic.
06:41:52 <mekeor> byorgey: well, you could just use `round', couldn't you?
06:41:59 <byorgey> nand`: more realistically, the nth Fibonacci number can be computed in O(log n) time, either by exponentiating a sufficiently accurate floating-point number, or using some variation on matrix exponentiation
06:42:03 <byorgey> mekeor: what do you mean?
06:42:40 <nand`> byorgey: true enough
06:42:48 <mekeor> byorgey: you can compense the missing floating-point precision with `round', that is just round the final calculation or so...
06:43:17 <mekeor> s/compense/compensate/
06:43:20 <byorgey> mekeor: no, that doesn't help, if it is not accurate enough in the first place you will get the wrong answer after doing 'round'
06:43:41 <mekeor> that's true..
06:44:14 <nand`> is this the part where you start involving random numbers and differing starting conditions
06:44:51 <hs_nab> is the haskell compiler being tweaked continously?
06:44:55 <byorgey> I don't see how that would help.
06:44:56 <hs_nab> optimizations, features, etc?
06:45:08 <byorgey> hs_nab: yes
06:45:10 <navaati> hs_nab: god yes, heavily
06:45:21 <hs_nab> nice.
06:45:33 <cheater_> @hoogle Monoid
06:45:33 <lambdabot> Data.Monoid module Data.Monoid
06:45:33 <lambdabot> Data.Monoid class Monoid a
06:45:33 <lambdabot> package monoid-owns
06:45:40 <hs_nab> the standard is comittee driven, or is it a company/one man show/open source?
06:45:40 <cheater_> @hoogle Group
06:45:41 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
06:45:41 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
06:45:41 <lambdabot> System.Posix.Types type GroupID = CGid
06:45:46 <cheater_> @hoogle Semigroup
06:45:47 <lambdabot> package Semigroup
06:45:47 <lambdabot> package semigroupoid-extras
06:45:47 <lambdabot> package semigroupoids
06:46:02 <nand`> byorgey: I've seen it done eg. to determine whether a large number is prime to a certain degree of accuracy
06:46:03 <navaati> of course it is open-source, but there also is a comitee
06:46:17 <navaati> and companies contibuting
06:46:37 <nand`> didn't GHC make it into the Google Summer of Code, for example?
06:46:42 <nand`> or was that Haskell in general
06:46:45 <navaati> (notably Galois and Microsoft iirc)
06:46:48 <byorgey> Haskell in general.
06:47:14 <mekeor> SPJ works at MS Research
06:47:22 <byorgey> > (round $ (((1 + sqrt 5)/2)^50) / sqrt 5) == (let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 50)
06:47:23 <lambdabot>   True
06:47:29 <byorgey> > (round $ (((1 + sqrt 5)/2)^100) / sqrt 5) == (let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100)
06:47:30 <lambdabot>   False
06:47:45 <mekeor> byorgey: proven. you won :)
06:48:13 <byorgey> it wasn't a contest, but ok =)
06:48:45 <Tinned_Tuna> Ok, so I've been trying to use the plugin library for haskell, and I seem to have hit upon a wall
06:49:00 <sanjoyd> How do I check if a value is undefined?
06:49:07 <Tinned_Tuna> https://github.com/TinnedTuna/Haskell-Plugin-Tutorial
06:49:12 <sanjoyd> Is it possible to do so, first of all?
06:49:18 <mekeor> sanjoyd: don't use undefined.
06:49:22 <Tinned_Tuna> The make function is not placing the .hi file beside the .o file
06:49:25 <mekeor> sanjoyd: use Maybe instead
06:49:30 <fmap> sanjoyd: no
06:49:31 <merijn> sanjoyd: Why would you need to?
06:49:31 <sanjoyd> mekeor: I mean, as an intellectual curiosity.
06:49:43 <Tinned_Tuna> More worryingly, if the .hi file is not found, the library call evaluates to undefined.
06:49:50 <sanjoyd> merijn: I'm playing.
06:49:52 <Tinned_Tuna> (the call to load, that is.)
06:50:16 <flamingspinach> The following occurs in the gentle introduction: "the principal type of head is [a]->a; [b]->a, a->a, or even a are correct types, but too general"
06:50:21 <flamingspinach> how is a->a a correct type for head?
06:50:22 <Tinned_Tuna> sanjoyd:  I don't think it's possible to compare to undefined
06:50:25 <byorgey> sanjoyd: it is possible.  Check out the source of the spoon package to see how it can be done.
06:50:29 <Tinned_Tuna> > undefined == Just 1
06:50:30 <byorgey> @package spoon
06:50:30 <lambdabot> http://hackage.haskell.org/package/spoon
06:50:30 <lambdabot>   *Exception: Prelude.undefined
06:50:36 <Tinned_Tuna> > Just 1 == undefined
06:50:37 <lambdabot>   *Exception: Prelude.undefined
06:50:43 <Tinned_Tuna> > 1 == undefined
06:50:44 <lambdabot>   *Exception: Prelude.undefined
06:50:48 <sanjoyd> Tinned_Tuna: of course, not by direct comparision.
06:50:51 <Tinned_Tuna> > undefined == undefined
06:50:52 <lambdabot>   *Exception: Prelude.undefined
06:50:55 <sanjoyd> I know it has to be something indirect.
06:50:56 <merijn> flamingspinach: You mean because of empty lists?
06:50:59 <byorgey> Tinned_Tuna: it isn't possible to compare for equality to undefined, but it is possible to catch the exception that undefined throws when evaluated.
06:51:08 <bitonic> flamingspinach: I think with "correct type" they just mean "well formed types"
06:51:26 <bitonic> not "correct for head"
06:51:29 <sanjoyd> Also, since more people are here now, I'll repeat something:
06:51:30 <sanjoyd> Is it possible to say "If either a or b is an instance of typeclass X, then Either a b is also an instance"?
06:51:40 <Tinned_Tuna> byorgey: whut? I thought it was an 'uncatchable-end-of-the-world' exception? I.e. your runtime simply got it and terminated your program?
06:51:43 <bitonic> sanjoyd: not in the general case
06:51:44 <flamingspinach> bitonic: I'm pretty sure that in context they mean "correct for head" - the other two are certainly correct for head
06:51:55 <sanjoyd> bitonic: but when can it be done?
06:52:02 <flamingspinach> of course, I could be wrong...
06:52:03 <byorgey> Tinned_Tuna: in theory, yes.  In practice, no. =)
06:52:05 <bitonic> flamingspinach: [a] -> a is the only wrong one there
06:52:06 <flamingspinach> merijn: I'm not sure I follow
06:52:07 <sanjoyd> As in, what are the non-general cases?
06:52:10 <bitonic> *sorry, the only right one
06:52:13 <bitonic> flamingspinach: the other 3 are wrong
06:52:19 <merijn> flamingspinach: Nevermind, I parsed your question wrong
06:52:27 <bitonic> sanjoyd: it depends, there is no general answer
06:52:55 <flamingspinach> bitonic: um, yes, [a]->a is "the type" of head, but they're defining what it means for something to be "the type" in this paragraph
06:53:10 <flamingspinach> and so far, the other types are supposed to be inclusive of the value head
06:53:19 <bitonic> sanjoyd: I'm guessing they're introducing the concept of principal type
06:53:20 <flamingspinach> section 2.1 http://www.haskell.org/tutorial/goodies.html
06:53:22 <bitonic> sorry, flamingspinach
06:53:27 <flamingspinach> yes, exactly
06:54:07 <bitonic> flamingspinach: I don't have time to read that, but [b] -> a, a -> a or a don't type 'head'
06:54:16 <bitonic> hence my answer :P
06:54:31 <flamingspinach> [b] -> a fits because b could equal a, they're just variables
06:54:40 <flamingspinach> a fits because a could substitute for "[a] -> a" which is itself a type
06:54:50 <flamingspinach> but what I don't see is how a -> a fits
06:54:50 <haskellMaster> is this chat written in haskell ?
06:55:00 <byorgey> flamingspinach: it doesn't.
06:55:00 <bitonic> flamingspinach: it could, but '[b] -> a' is implicitly 'forall a b. [b] a'
06:55:12 <merijn> haskellMaster: The chat is just IRC
06:55:23 <Axman6> haskellMaster: no... this is just normal IRC
06:55:23 <haskellMaster> don't tell me this
06:55:26 <flamingspinach> bitonic: yes, it's too general because it only fits head for certain values of the quantification
06:55:26 <haskellMaster> I'm the haskell master
06:55:29 <bitonic> flamingspinach: so that is saying for all lists of type b, whatever b might be, I can give you an 'a', whatever a might be
06:55:35 <flamingspinach> I know, I know :)
06:55:37 <bitonic> which is obviously not the case for 'head'
06:55:57 <flamingspinach> yes, what you are saying is that [b] -> a is not the PRINCIPAL type of head, but I understand that already
06:56:03 <byorgey> flamingspinach: yeah, I'm looking at the tutorial now and it is simply wrong.
06:56:10 <flamingspinach> OK, well that answers my question lol
06:56:12 <byorgey> a -> a  is not a correct type for head.
06:56:13 <haskellMaster> btw.
06:56:32 <byorgey> flamingspinach: b -> a  would be though.
06:56:34 <haskellMaster> do you now a good tutorial to begin haskell tutorial ? something like to try things out ?
06:56:50 <flamingspinach> byorgey: possibly a->a was a typo for b->a ?
06:56:54 <byorgey> @where tryhaskell
06:56:54 <lambdabot> http://tryhaskell.org/
06:56:55 <byorgey> @where lyah
06:56:56 <lambdabot> http://www.learnyouahaskell.com/
06:56:59 <byorgey> haskellMaster: ^^^
06:57:02 <flamingspinach> @where rwh
06:57:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:57:04 <byorgey> flamingspinach: yes, probably
06:57:19 <flamingspinach> OK, thanks byorgey, bitonic :) back to reading...
06:57:30 <haskellMaster> they are too complex for me
06:57:46 <byorgey> flamingspinach: by the way, the "gentle introduction" is actually not very gentle
06:57:48 <haskellMaster> do you have some simple tutorials ?
06:58:03 <byorgey> flamingspinach: there's nothing wrong with it, I'm just saying that so you don't feel stupid if you find it difficult =)
06:58:27 <byorgey> haskellMaster: tryhaskell.org is too complex for you?
06:58:42 <haskellMaster> yes :(
06:58:52 <flamingspinach> byorgey: I know, but I tried lyah and somehow got kind of bored with it and stopped reading around chapter 4... I thought the gentle introduction might be a bit faster paced...
06:58:53 <flamingspinach> I'm sure I'll run into something monstrous halfway through the gentle introduction and run crying back to lyah, though ;)
06:58:53 <haskellMaster> i need something with pictures
06:59:09 <navaati> haskellMaster: learn you a haskell has pictures :D
06:59:16 <byorgey> flamingspinach: ok, sounds good =)
07:00:03 <flamingspinach> btw I'm a mathematician by training - does that change the standard recommendation of lyah -> rwh at all? Is there perhaps some special manual for mathematicians to learn haskell? :P
07:00:19 <flamingspinach> I say "mathematician" but maybe "mathematics student" is more accurate...
07:00:21 <copumpkin> flamingspinach: categories for the working mathematician
07:00:25 <copumpkin> ;)
07:00:34 <copumpkin> flamingspinach: I hear bird's book is nice
07:00:34 <byorgey> hahahaha
07:00:37 <nand`> > seq undefined ()
07:00:38 <lambdabot>   *Exception: Prelude.undefined
07:00:41 <flamingspinach> copumpkin: I actually started reading that a while ago... I should read it some more :) but my immediate goal is to try to learn some haskell haha
07:00:43 <nand`> ^- catch that error?
07:00:51 <flamingspinach> bird's book?
07:00:56 <earthy> there's http://homepages.cwi.nl/~jve/HR/
07:01:01 <nand`> (meant for sanjoyd)
07:01:02 <copumpkin> http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460 I think
07:01:09 <byorgey> flamingspinach: yeah, then the gentle intro is probably good for you
07:01:19 <navaati> flamingspinach: rwh is intended for people who already programm in other languages
07:01:22 <flamingspinach> aha
07:01:22 <copumpkin> from what I've seen of people working through exercises in it, they tend to be a bit more abstract and mathematical
07:01:26 <copumpkin> but I haven't actually read it
07:01:29 <copumpkin> so I might be completely wrong :P
07:01:40 <flamingspinach> navaati: well, I have done some programming, mainly in Python... a tiny bit of C...
07:01:45 <byorgey> flamingspinach: also check out the typeclassopedia at some point (though it's not an intro to Haskell)
07:01:48 <byorgey> @where typeclassopedia
07:01:49 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:02:07 <flamingspinach> byorgey: by... you! :) thanks
07:02:15 <byorgey> hehe, yep =)
07:03:11 <flamingspinach> well I'll keep an eye out for Bird's book, thanks for the suggestion copumpkin
07:03:24 <flamingspinach> bbl, dinner...
07:03:24 <mekeor> earthy: that book is even saved in lambdabot:
07:03:28 <mekeor> @where hr
07:03:29 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
07:03:56 <mekeor> @where bird
07:03:56 <lambdabot> http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460
07:04:55 <hs_nab> can i load code dynamically?
07:05:01 <bitonic> well, there's another bird as well - the functiona pearls :P
07:05:12 <mekeor> bitonic: oO
07:05:13 <bitonic> hs_nab: not easily, you have to resort to the GHC API.
07:05:15 <quicksilver> there are a number of ways to do that, hs_nab
07:05:29 <quicksilver> GHC has an API for it and various people have written libraries to make it easier
07:05:37 <hs_nab> i will look into then
07:05:43 <quicksilver> http://hackage.haskell.org/package/hint-0.3.3.4
07:05:50 <quicksilver> it is not entirely for the light hearted :)
07:05:57 <bitonic> ah right, hint is pretty nice
07:06:04 <quicksilver> erm
07:06:08 <quicksilver> faint-hearted, even :)
07:06:10 <byorgey> "faint of heart"?
07:06:14 <byorgey> =)
07:06:36 <byorgey> hint is so sad, it is not for light-hearted people
07:06:41 <bitonic> hs_nab: I wouldn't look into that if you're learning haskell :P
07:07:04 <hs_nab> i wont for now, just wanted to know if it possible
07:07:09 <hs_nab> it is*
07:07:43 <hs_nab> how can i import a local
07:07:46 <hs_nab> package
07:07:47 <hs_nab> ?
07:08:33 <nand`> you don't import packages, you import modules
07:08:46 <hs_nab> ok. how can i import local modules?
07:08:48 <hs_nab> :D
07:08:51 <mekeor> import Foo
07:08:53 <nand`> same as any other :)
07:09:03 <mekeor> (filename: "Foo.hs")
07:09:08 <nand`> as long as ghc can find that module
07:09:49 <mekeor> nand`: but you usually the module name should equal the filename, right?
07:10:10 <nand`> mekeor: do you know if that's actually a requirement?
07:10:26 <nand`> will GHC automatically search for local .hs files in order to find it?
07:10:27 <mekeor> nand`: no. that's why i asked.
07:10:57 <mekeor> s/but you usually/but usually/ # btw
07:11:04 <bitonic> yeah GHC will look the filename corresponding to the module name
07:11:53 <bitonic> you can name a module differently from the filename
07:12:06 <bitonic> but ghc won't find it
07:12:27 <mekeor> okay
07:12:30 <bitonic> actually wait.
07:12:35 <mekeor> okay
07:12:41 * mekeor waits
07:12:55 <bitonic> mekeor: I'm having doubts now... :P
07:13:50 <navaati> bitonic: reading at the man of GHC, it will look for modules by their filename. Of course if you directly specify the file on the commandline, the name doesn't matter
07:14:15 <bitonic> mekeor: no I was wrong there it doesn't enforce that
07:14:31 <bitonic> navaati: yeah
07:16:47 <mekeor> aha. okay.
07:17:36 <hpaste_> sarfraz pasted “case of empty bytestring” at http://hpaste.org/67095
07:17:37 <sarfraz> hi
07:18:24 <sarfraz> ghc gives me errors about my import in my paste
07:18:39 <sarfraz> something about my binding
07:18:48 <rwbarton> paste the error
07:18:50 <sarfraz> can someone give me pointers?
07:18:52 <mekeor> sarfraz: remove (lines) and (getArgs)
07:19:04 <mekeor> sarfraz: on line 4 and 5
07:19:13 <navaati> does GHC build haskell 98 or 2010 by default ?
07:19:21 <Axman6> well, straight away i can see several problems. you can't pattern match on B.empty in a case statement, and second, you're using B.empty as something of type [ByteString]
07:19:40 <sarfraz> oh ok
07:20:37 <Axman6> also your indentation is horrible in main :\
07:20:55 <sarfraz> i used that because it worked well with lists
07:20:57 <merijn> @hoogle (a -> Bool) -> m a -> m ()
07:20:57 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
07:20:57 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
07:20:58 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
07:21:10 <merijn> @hoogle m a -> (a -> Bool) -> m ()
07:21:10 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
07:21:10 <lambdabot> Test.QuickCheck.Gen suchThat :: Gen a -> (a -> Bool) -> Gen a
07:21:11 <lambdabot> Test.QuickCheck suchThat :: Gen a -> (a -> Bool) -> Gen a
07:22:03 <womb> > 7*7
07:22:04 <lambdabot>   49
07:22:28 <sarfraz> Qualified name in binding position: B.empty
07:22:33 <sarfraz> that's the error
07:22:41 <merijn> There was some form of until construct for monads, right? Why can't I find it?
07:22:52 <rwbarton> right so that's < Axman6> well, straight away i can see several problems. you can't pattern match on B.empty in a case statement,
07:22:59 <Axman6> sarfraz: i already told you, you can't use B.empty as a pattern
07:23:38 <sarfraz> yes i understood, what i can't find is how to do it without
07:23:45 <rwbarton> many options
07:23:50 <Axman6> don't use case statements
07:24:02 <rwbarton> if B.null st2 then ... else ...
07:24:11 <rwbarton> would be the most straightforward
07:24:31 <rwbarton> can also write
07:24:42 <rwbarton> takeHead st1 st2 | B.null st2 = ...   | otherwise = ...
07:25:07 <sarfraz> ohh ok thks :)
07:25:18 <sarfraz> didn't know of null
07:25:38 <rwbarton> could also use (B.uncons -> Nothing) like in main but it's rather overkill
07:27:14 <sarfraz> ok it works
07:27:24 <sarfraz> rwbarton++karma
07:27:37 <sarfraz> Axman6++karma
07:27:45 <sarfraz> tss didn't work...
07:27:52 <copumpkin> if you left out the "karma" bit, it would
07:28:12 <sarfraz> Axman6++
07:28:23 <sarfraz> well you get the point
07:28:28 <sarfraz> bye
07:46:45 <d34df00d> Hi!
07:47:16 <d34df00d> Has anybody used the graph-rewriting package? ( http://hackage.haskell.org/package/graph-rewriting-0.5.3 )
07:47:26 <d34df00d> I wonder whether there are some good examples of using it.
07:47:44 <d34df00d> I tried understanding graph-rewriting-ski, but I'm not that familiar with lambda calculus to use it as an example.
07:49:16 * hackagebot rewriting 0.2.2 - Generic rewriting library for regular datatypes.  http://hackage.haskell.org/package/rewriting-0.2.2 (JosePedroMagalhaes)
08:02:08 <greg`> Hi does anyone know how i can fix the error "Could not find module 'Text.Regex.Posix'"?
08:02:32 <merijn> Dumb question maybe, but do you have it installed? :p
08:02:50 <fmap> greg`: install regex-posix?
08:02:56 <qnikst> install regex-posix?
08:03:06 <erewhon_> Is Text.Regex.Posix not in the default install?
08:03:09 <mzero> well - are you building your project with a .cabal file?
08:03:31 <mzero> if so, you'll have to include the regex-posix package in the dependency list
08:03:37 <greg`> um actually i have reinstalled haskell
08:03:45 <greg`> so im just checking cabal now
08:03:49 <mzero> using haskell platform?
08:04:26 <mzero> but again, how are you compiling - ghc? loading in ghci?  cabal build   --- in otherwords how the compilation was invoked will affect how we help you fix that error
08:04:31 <erewhon_> sorry, you need to "cabal install regex-posix", I think...
08:04:40 <greg`> yeah thats what i did
08:04:45 <greg`> i got Text/Regex/Posix/Wrap.hsc:355:1:
08:04:45 <greg`>     Unacceptable result type in foreign declaration: IO CInt
08:04:46 <merijn> Man, Debug.Trace is awesome for diagnosing problems :D
08:04:47 <qnikst> it's better to use cabal-dev :)
08:04:50 <greg`> failed to install
08:05:01 <greg`> cabal-dev?
08:05:11 <greg`> how can i install cabal-dev?
08:05:16 <mzero> wait wait wait
08:05:25 <mzero> we still don't know how you are compiling your code
08:05:26 <greg`> sudo apt-get install cabal-dev?
08:05:42 <mzero> let's not jump to bigger axes unless we know he needs 'em
08:05:45 <erewhon_> @package regex-posix
08:05:45 <lambdabot> http://hackage.haskell.org/package/regex-posix
08:06:01 <greg`> yes that package is not installing in cabal
08:06:02 <mzero> (compiles huge Haskell programs with many packages... never uses cabal-dev...)
08:06:07 <greg`> im getting errors when compiling it
08:06:24 <qnikst> cabal install cabal-dev, it's a cabal that will make sandbox for your code.
08:06:28 <rwbarton> gah
08:06:38 <Clint> or apt-get install libghc-regex-posix-dev
08:06:45 <mzero> which - from the looks of the errors, a sandbox isn't going to help a wit
08:06:55 <qnikst> yep
08:07:34 <mzero> I'm just trying to determine if the package is there and not being seen, or if it isn't installed
08:08:13 <mzero> greg`: if you wnat to see if the package is there, run this at the shell:     ghc-pkg list | grep regex
08:08:27 <mzero> the package regex-posix should list and not be in parenthesis or brackets
08:08:59 <greg`> ghc-pkg list | grep regex                                                                           ─┘
08:08:59 <greg`>     regex-base-0.93.2
08:09:03 <greg`>     regex-base-0.93.2
08:09:29 <Clint> apt-get install libghc-regex-posix-dev
08:09:33 <greg`> its showing that the base packages are there , there is no posix though, strangely enough my emacs flymake compiles ok
08:09:41 <greg`> i'll try that Clint thanks
08:10:04 <rwbarton> IME installing libraries other than through cabal install (--user) always leads to tragedy
08:10:19 <Clint> not if you do it right
08:10:26 <greg`> rwbarton i think you are right
08:10:27 <rwbarton> that may be but why take the risk
08:10:34 <greg`> i was trying to avoid using apt
08:10:36 <rwbarton> why are there two lines of output there anyways
08:10:40 <Clint> because it's less headache
08:10:45 <mzero> two versions, rwbarton
08:10:49 <mzero> oh - wait, no
08:10:57 <mzero> but probably installed twice, in two places
08:11:01 <greg`> i dont know, it seems its in there twice :-o
08:11:06 <rwbarton> probably a global version from apt and a user version from cabal install
08:11:21 <greg`> i think i need to rip out the apt stuff
08:12:59 <greg`> i feel like i just want to redo my entire haskell installation
08:13:14 <greg`> but it seems bits of it are squirrelled away all over the place
08:13:44 <rwbarton> what version of ghc do you have?
08:14:20 <greg`> 7.5 it says
08:14:38 <greg`> 7.5.20120305
08:14:53 <mzero> ooo bleeding edge
08:15:41 <qnikst> can smbd help me with TH. I want to generate smth equivalent to "f (t+c*h) (y+h*(zipWith (*) ks ls))" https://gist.github.com/2387857#file_gistfile1.hs
08:15:43 <greg`> ah , yeah i think i tried to compile the latest from source
08:15:54 <fmap> you probably want 7.4 or even 7.0.3
08:16:12 <qnikst> using raw TH types leads to hell in usage
08:16:14 <greg`> ok i just need to downgrade
08:16:39 <qnikst> and I don't understand how to use [||] syntax in my case
08:16:47 <greg`> this is the problem i think i compiled from source
08:16:56 <greg`> and now i dont know where it dumped it
08:17:32 <greg`> im a bit scared to go straight to /usr/local/bin and delete  it from there because it may not be a clean uninstall
08:19:35 <mzero> what platform are you on, greg` ?
08:20:11 <greg`> ubuntu
08:20:18 <greg`> 11.04
08:21:29 <rwbarton> qnikst: something like [| f (t+c*h) (y + d * zipWith $(return $ ListE ks) ls) |]  perhaps
08:21:52 <mzero> oy, well, 11.04 packages are ghc 6 -- that's a little old ---
08:22:30 <qnikst> rwbarton: thanks will check
08:22:52 <rwbarton> though i guess you will need to do the same kind of thing to f, t, h, y, etc.
08:22:59 <mzero> I'd be inclined then, to install GHC 7.0.4 from generic binary, then install haskell platofrm from source
08:23:03 <zhulikas> greg`, use runQ [||]
08:23:34 <rwbarton> greg`: yes I would remove everything ghc-related from your package manager
08:23:59 <mzero> http://www.haskell.org/ghc/download_ghc_7_0_4#distros   and    http://hackage.haskell.org/platform//linux.html    and    follow instructions at http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
08:24:40 <mzero> but unless you need something out of 7.4 or 7.5 --- 7.0.4 is just fine (it isn't as old as it looks, there was never a 7.2 released)
08:24:51 <qnikst> i'm trying to split problem it pieces full problem is that i should generate [| \f h y -> let [(problem I've posted)] in y+h*...|]
08:25:02 <mzero> next Haskell Plaform will be 7.4 based, but that is a month away
08:25:12 <greg`> whats runQ?
08:25:27 <qnikst> and I want to avoid all zipWith eth functions in resulting code
08:25:28 <rwbarton> zhulikas is bad at addressing people
08:25:32 <mzero> greg`: i think that was meant for qnikst
08:25:53 <greg`> ok thanks im going to remove everyothing from package manager
08:26:13 <rwbarton> ghc just moves too quickly for it to be practical to have good debian/ubuntu support
08:26:19 <greg`> um how do i remove the installation that i compiled from source safely?
08:27:33 <greg`> i am trying a sudo make uninstall from the directory
08:28:23 <mzero> blast everything under ~/.cabal and ~/.ghc  except  ~/.cabal/config and ~/.ghc/ghci.config
08:28:35 <mzero> the rest will get overwritten in the install process
08:28:50 <greg`> thanks
08:28:54 <mzero> which, I admit, isn't "cleanly"
08:29:10 <greg`> its way better than what i have, thanks
08:29:15 <greg`> ls
08:30:01 <mzero> if you haven't customized ~/.cabal/config you can nuke that too
08:30:18 <mzero> ditto ~/.ghc/ghci.config
08:30:34 <rwbarton> "zipWith ks ls" isn't very plausible, btw.
08:31:14 <qnikst> rwbarton: idea is to have straight forward code it a "imperative" style
08:31:35 <Philippa> ANF is great for 'imperative' style, but first-order imperative is a much stronger restriction
08:31:51 <qnikst> i.e. I'd prefer to generate 1*a + 2*b + 3*c thater then zipWith (*) [1,2,3] [a,b,c]
08:32:15 <Philippa> right, you're after first order?
08:32:16 <rwbarton> so i imagined you might want to produce 1*a + 2*b + 3*c but that is a far cry from zipWith ks ls
08:32:23 <rwbarton> but okay
08:32:34 <Philippa> rwbarton: "zipWith what?"
08:33:14 <rwbarton> I would probably not bother with [||], too much hassle. instead foldl1 (InfixE plus) $ zipWith ks ls etc.
08:33:17 <rwbarton> argh
08:33:27 <rwbarton> zipWith (InfixE mult) ks ls
08:33:31 <rwbarton> Philippa: yes exactly.
08:33:39 <Tinned_Tuna> Bad idea of the day: Haskell Blog Engine
08:33:50 <Philippa> Tinned_Tuna: it's been done. I wrote a small wiki ages back, too
08:34:05 <Philippa> (and others have done nicer ones since)
08:34:08 <qnikst> rwbarton: hm..
08:34:08 <Tinned_Tuna> Philippa: it's more bad ideas for me, I have too many projects.
08:34:16 <Philippa> *nod*
08:34:21 <Tinned_Tuna> I have at least one a day. Sadly, I can't knock out a project in a day.
08:34:37 <Philippa> yeah. I'm kinda caught up trying to find a universal language for discussing type inference schemes in usefully, for example
08:34:39 <Philippa> heh, yes
08:34:59 <Philippa> I mean, I've sat down and knocked out a small PL implementation in a day and the first version of the wiki happened in a similar timeframe, but...
08:35:35 <barrucadu> Tinned_Tuna: I wrote one last week over a couple of days, it was rather fun
08:35:38 <Philippa> (I already knew the structure of the code in advance, a couple of hundred LoC in a day isn't so much in that situation)
08:35:39 <Tinned_Tuna> I need to work out how to work parsec in a sane way. Then I can do really fun things.
08:35:49 <Philippa> yeah, knowing one good parsing framework's a big deal
08:36:07 <Tinned_Tuna> I used lex and parsec a couple years ago. It was like pulling eyes.
08:36:51 <qnikst> rwbarton: so It will be smth like AppE (AppE (VarE f)) (InfixE (VarE t) (plus) (InfixE (VarE h) mult (VarE c)) (....
08:37:05 <Tinned_Tuna> anyways
08:37:06 <Tinned_Tuna> tea break
08:38:33 <Philippa> Tinned_Tuna: ouch, I'd stick with Parsec or a similar framework for lexing myself
08:38:53 <Philippa> (and have done: Parsec's regular expression subset is at least not direly slow)
08:39:02 <Philippa> nothing wrong with a separate lexer though
08:39:50 <qnikst> rwbarton: and plus is (mkName "+") ?
08:42:55 <rwbarton> i don't know offhand
08:42:59 <rwbarton> however you do it
08:44:29 <qnikst> :@hoogle Double -> Rational
08:44:55 <liyang> realToFrac
08:45:10 <mauke> :t toRational
08:45:11 <lambdabot> forall a. (Real a) => a -> Rational
08:45:47 * qnikst used real to frac but whats better?
08:46:12 <c_wraith> @src Real
08:46:12 <lambdabot> class  (Num a, Ord a) => Real a  where
08:46:12 <lambdabot>     toRational      ::  a -> Rational
08:46:25 <mauke> @src realToFrac
08:46:25 <lambdabot> realToFrac = fromRational . toRational
08:46:28 <c_wraith> ...  That is a very silly class name
08:46:30 <mauke> no difference
08:46:36 <qnikst> ok
08:47:01 * qnikst also doesn't like using Rational in generated code..
08:47:18 <liyang> For coercions between integral numbers, it's fromIntegral; for floating numbers it's realToFrac. They'll get rewritten down to the same thing as if you'd used a more specific conversion function. (Probably.)
08:47:33 <c_wraith> huh?  Why object to Rational?
08:48:03 <qnikst> i forced to use rational because of DoublePrimL type
08:48:44 <qnikst> hm
08:48:50 <qnikst> everything is ok sorry
08:49:04 <rwbarton> "floating point" literals are actually built with fromRational
08:49:09 <c_wraith> Rational's a good type
08:49:20 <Mathnerd314> does type X = Y in a module always allow using Y's in place of X's?
08:49:21 <qnikst> c_wraith: depend on task
08:49:34 <qnikst> but yes it is
08:49:39 <c_wraith> Well, it's a good interface type
08:49:59 <c_wraith> You may choose to do your computations with some other type, but it works well to convey information on the edges
08:50:01 <quicksilver> Mathnerd314: and X's in place of Y's also.
08:50:06 <mauke> Mathnerd314: I think yes
08:50:18 <mauke> quicksilver: I don't agree with that
08:50:21 <quicksilver> Mathnerd314: and as for "always"
08:50:32 <quicksilver> Mathnerd314: not in type instances
08:50:48 <quicksilver> which is maybe what mauke means by disagreeing with me?
08:50:50 <liyang> type synonym instances?!
08:50:53 <Mathnerd314> -XTypeSynonymInstances :p
08:50:57 <mauke> yes
08:51:07 <liyang> Makes baby SPJ cry.
08:52:38 <liyang> module RealToFrac where f :: Double -> Rational; f = realToFrac
08:53:02 <liyang> $ ghc -c -O1 -ddump-simpl realToFrac.hs
08:53:07 <liyang> RealToFrac.f = GHC.Float.$fRealDouble_$ctoRational
08:54:19 * hackagebot PropLogic 0.9.0.3 - Propositional Logic  http://hackage.haskell.org/package/PropLogic-0.9.0.3 (DavidFox)
08:54:21 * hackagebot logic-classes 1.4.3 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.3 (DavidFox)
08:58:16 <MarcWeber> I'm trying to understand typefamilies (http://www.haskell.org/haskellwiki/GHC/Type_families). That's why I thought it would be a nice exercise to implement add and empty for the given data family. However I fail: http://dpaste.com/732559/
09:03:55 <navaati> MarcWeber: you're using a data family instead of a type family for Container
09:04:19 * hackagebot HsOpenSSL 0.10.3 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3 (MasatakeDaimon)
09:04:50 <qnikst> rwbarton: thanks now it works but I feel myself like lisper ;)
09:07:03 <keep_learning> Hello All
09:07:57 <keep_learning> If I am running the multithread program ( par , pseq ) then during GC time  every thread is stopped ?
09:08:14 <kanoxpm21> hello, someone know how ot use quickcheck please??
09:08:40 <rwbarton> keep_learning:  i think the answer is currently "yes but the GC itself will run on multiple threas"
09:09:15 <mauke> wasn't there some work on not stopping the world for minor collections?
09:09:29 <quicksilver> certainly has been some work on it
09:09:35 <keep_learning> rwbarton, Thanks
09:09:51 <quicksilver> JaffaCake was working to make minor GCs (nursery only) run in their own threads, since the nurseries are thread-local
09:09:56 <kanoxpm21> someone can tell me what i have to put in the pattern of FORALL condition of quickcheck?
09:09:57 <navaati> i can remember an article from spj, yeah, i thought this work was atm included in ghc
09:10:32 <kanoxpm21> someone can tell me what i have to put in the pattern of FORALL condition of quickcheck?
09:11:46 <quicksilver> http://hackage.haskell.org/trac/ghc/blog/new-gc-preview
09:11:55 <quicksilver> mauke, keep_learning ^^
09:12:15 <hayashi> Never used the FORALL condition in quickcheck (in fact, only used quickcheck a tiny bit), sorry
09:12:17 <keep_learning> kanoxpm21, put your code on http://hpaste.org and  I think you will certainly get response
09:13:29 <quicksilver> kanoxpm21: if you mean "forAll" then the answer is "a value of type Gen x"
09:13:35 <quicksilver> where x is the value you're trying to generate
09:13:41 <quicksilver> :t forAll
09:13:42 <lambdabot> forall a prop. (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
09:14:02 <parcs`> > last (iterate (/ 10) 0.1)
09:14:10 <lambdabot>   mueval: ExitFailure 1
09:14:11 <lambdabot>  mueval: Prelude.undefined
09:14:20 * hackagebot circ 0.0.0 - A Compiler IR Compiler.  http://hackage.haskell.org/package/circ-0.0.0 (TomHawkins)
09:14:29 <mauke> quicksilver: "it should be in the autumn 2011 major release of GHC"
09:14:29 <parcs`> hmm i wonder when  Underflow exception is thrown
09:14:37 <mauke> did that happen?
09:14:48 <rwbarton> last doesn't actually examine the elements
09:14:56 <MarcWeber> navaati: thanks, got it.
09:15:02 <rwbarton> but floating point "exceptions" aren't haskell exceptions anyways
09:15:21 <rwbarton> at least, not by default, possibly there is some way to observe them
09:16:15 <quicksilver> mauke: I wondered the same thing. I don't know.
09:16:37 <hpaste_> jonathan pasted “Quantified property quickcheck” at http://hpaste.org/67099
09:16:59 <kanoxpm21> quicksilver thanks. i have made a post
09:17:07 <hpaste_> liyang pasted “type families @MarcWeber perhaps this is what you were after” at http://hpaste.org/67100
09:17:35 <quicksilver> kanoxpm21: it's the name of the variable
09:17:45 <quicksilver> as it will occur in property x
09:17:59 <quicksilver> forAll intGen (\x -> 1 + x == x + 1)
09:18:21 <kanoxpm21> let me see
09:18:23 <quicksilver> "x" is the name of the abitrary int which is generated by intGen and then checked that 1+x is the same as x+1
09:19:28 <liyang> MarcWeber: the last line should of course say: foldr add empty "OH HAI THAR"
09:20:28 <navaati> :t intGen
09:20:31 <lambdabot> Not in scope: `intGen'
09:21:12 <quicksilver> navaati: it was an example.
09:22:24 <kanoxpm21> its this correct: prop_mifun x = forAll ("aeiou" 'elem' string) $ \x
09:22:25 <kanoxpm21> ?
09:22:33 <quicksilver> kanoxpm21: no.
09:23:10 <quicksilver> I assume you meant "aeiou" `elem` string
09:23:15 <quicksilver> but that's not a "Gen"
09:23:37 <quicksilver> and your lambda \x is incomplete
09:23:58 <qnikst> rwbarton: sorry for silly question but can you explain DecE type?
09:24:21 <qnikst> ops LetE
09:24:25 <zhulikas> > all (
09:24:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:24:39 <rwbarton> no because
09:24:39 <rwbarton> oh
09:24:43 <rwbarton> it's a let expression
09:24:46 <zhulikas> > all (\a -> elem a "aeiou") "aio"
09:24:47 <lambdabot>   True
09:25:17 <rwbarton> qnikst: have you seen http://hackage.haskell.org/packages/archive/template-haskell/latest/doc/html/Language-Haskell-TH-Syntax.html#t:Exp ?
09:25:24 <kanoxpm21> look, i have a function right, that is called mifun x, where x is a string
09:25:27 <qnikst> looking at it
09:25:41 <kanoxpm21> how could be the code to use the quantified propery correctly
09:26:14 <kanoxpm21> with that function
09:26:15 <kanoxpm21> to test it
09:26:20 <quicksilver> kanoxpm21: what is your level of haskell understanding?
09:26:24 <qnikst> hm seems I understood
09:26:27 <kanoxpm21> very low
09:26:41 <quicksilver> kanoxpm21: do you know what an anonymous function is? a lambda?
09:26:47 <kanoxpm21> my first time. Its a proyect for the collage
09:26:50 <quicksilver> kanoxpm21: do you know what a 'Gen' is an how to make one?
09:27:10 <quicksilver> kanoxpm21: trying to learn how to use forAll without understanding the building blocks is going to be hard.
09:27:23 <kanoxpm21> :S i'm look jejeje.
09:27:35 <kanoxpm21> wait a minute
09:27:40 <qnikst> I need LetE [FunD (mkName "n") (Clause [] (Normal Exp))
09:27:42 <kanoxpm21> let me show to u the code
09:31:15 <hpaste_> jonathan pasted “Quantified property quickcheck haskell” at http://hpaste.org/67103
09:31:43 <kanoxpm21> quicksilver there is the code
09:31:45 <quicksilver> kanoxpm21: two basic problems.
09:31:55 <quicksilver> kanoxpm21: (1) "aeiou" `elem` x is not a Gen
09:31:57 <kanoxpm21> yes?
09:32:02 <kanoxpm21> oki
09:32:04 <keep_learning> what is the maximum heap size I can pass through  -H option to improve the GC time
09:32:15 <quicksilver> kanoxpm21: (2) \(a,z) -> mifun x doesn't seem likely to be what you mean
09:32:24 <quicksilver> "x" isn't declared
09:32:31 <quicksilver> and you don't do anything with a and z
09:32:36 <kanoxpm21> i'm completely lose :P
09:32:47 <quicksilver> for ways to generate Gens, see http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck-Gen.html
09:33:10 <quicksilver> for (2) I suspect you mean \x -> mifun x
09:33:30 <kanoxpm21> okay, and X will get the value that the generator makes?
09:33:35 <quicksilver> yes
09:33:40 <kanoxpm21> hmmm
09:33:41 <quicksilver> precisely :-)
09:33:45 <zhulikas> @hoogle toLower
09:33:45 <lambdabot> Data.Char toLower :: Char -> Char
09:33:45 <lambdabot> Data.Text toLower :: Text -> Text
09:33:46 <lambdabot> Data.Text.Lazy toLower :: Text -> Text
09:34:33 <kanoxpm21> so ihave to make a generator that generate strings?
09:34:35 <kanoxpm21> right ?
09:37:18 <aib> @pl fmap
09:37:18 <lambdabot> fmap
09:37:42 <aib> um, wasn't there an alias for fmap? some operator?
09:37:45 <byorgey> <$>
09:37:47 <aib> cheers
09:37:50 <byorgey> from Control.Applicative
09:38:02 <mk> what is the advantage of currying over partial application, and varargs?
09:38:30 <quicksilver> kanoxpm21: yes
09:38:32 <byorgey> oh, I guess it's actually exported from Data.Functor now
09:38:37 <quicksilver> kanoxpm21: (because your mifun wants strings)
09:38:53 <kanoxpm21> ty, let me seee
09:40:01 <quicksilver> kanoxpm21: on reflection, there is another problem :)
09:40:14 <quicksilver> kanoxpm21: "\x -> mifun x" isn't a property :)
09:40:15 <kanoxpm21> which one
09:40:34 <kanoxpm21> :s
09:40:36 <quicksilver> you probably want something which is true-or-false : a boolen
09:40:39 <quicksilver> for example
09:40:43 <quicksilver> \x -> mifun x == x
09:40:55 <quicksilver> would say that, for all the strings considered, mifun x was the same as x
09:40:59 <kanoxpm21> ah ok
09:41:06 <quicksilver> (this would be true for strings with no vowels in, I guess, from your code)
09:41:19 <kanoxpm21> like mifun x /= x
09:41:22 <kanoxpm21> is a property
09:46:03 <aib> mk: currying and partial application are complements of eachother
09:46:50 <mk> aib: what do you mean?
09:46:58 <aib> http://stackoverflow.com/questions/218025/what-is-the-difference-between-currying-and-partial-application
09:48:07 <Luke> ozataman_: hadocks still aren't working for csv-conduits
09:48:18 <ozataman_> Luke: no clue why. they are working on my local index
09:48:26 <ozataman_> Luke: I'll actually upload an update - sec
09:50:49 <ozataman_> OK, just released 0.2 - few improvements/changes in the API
09:50:57 <mk> aib: I understand how both work, but I'm still not sure why that makes them complements. The one difference I know of is that curried functions can't support varargs, although those can be simulated with a list
09:51:08 <Luke> ozataman_: cool - thanks
09:51:32 <Luke> ozataman_: yeah still hadocks don't work online. weird
09:51:39 <Luke> it's like their not being uploaded or something
09:54:22 * hackagebot csv-conduit 0.2 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.2 (OzgunAtaman)
09:54:36 <kanoxpm21> sample (arbitrary :: Gen Bool)
09:54:41 <kanoxpm21> thats correct?
09:55:25 <Luke> ozataman_: this package is awesome btw. i love it
09:55:46 <ozataman_> Luke: cool :)
10:02:19 <Luke> ozataman_: enumerators or conduits, which do you like better?
10:02:48 <ozataman_> Luke: I haven't done performance benchmarks yet, but conduits are far easier and flexible to use, in my opinion
10:09:12 <Luke> Snoyman's usually pretty performance conscious.
10:11:26 <ksf> someone explain to me like I'm six what's the difference between sufficiently compositional actors and FRP.
10:12:25 <sm> you'll understand when you're older...
10:13:01 <osfameron> sm++
10:13:21 <elliott> Do six years olds know the word "everything"?
10:17:16 <ksf> my intended actor semantics might just be sufficiently FRPy and my intended FRP implementation sufficiently actorial to make them look the same.
10:28:07 <qnikst> last thing about TH
10:28:33 <qnikst> how to make user be able to write [rk|....|]
10:29:00 <qnikst> I have string parser to internal type and function that maps that type to Q-Expr
10:31:38 <elliott> define a quasiquoter:
10:31:46 <elliott> http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH-Quote.html
10:31:52 <elliott> rk :: QuasiQuoter
10:35:38 <qnikst> elliott: is it normal that I'm defining only quoteExp?
10:37:04 <elliott> qnikst: Sure.
10:37:14 <elliott> qnikst: Fill in the others with (error "rk can only be used as blah blah") if you want.
10:37:24 <elliott> That'll give more useful errors when you use it in other contexts.
10:38:52 <qnikst> ok
10:40:25 <gustavderdrache> i just installed the latest Haskell Platform on a Mac
10:40:42 <gustavderdrache> is there a reason that GHC is looking in /Developer for gcc?
10:40:58 <gustavderdrache> i only have the OS X Command-Line tools, instead of a full Xcode install
10:42:29 <luite_> yeah the directory has been changed recently
10:42:58 <luite_> you can make a symlink to /usr in /Developer /usr or edit the wrapper scripts ghc and runghc
10:43:17 <gustavderdrache> ah, yes
10:43:20 <gustavderdrache> symlinks fix everything
10:43:28 <gustavderdrache> except too many layers of symlinks
10:44:27 * hackagebot ConsStream 0.1 - Trivial re-export of Wouter Swierstra's Stream package,  avoiding module name clash.  http://hackage.haskell.org/package/ConsStream-0.1 (ConalElliott)
10:44:32 <gustavderdrache> sweet, that fixed it
10:44:36 <gustavderdrache> thanks luite_++
10:52:33 <qnikst> strage QuasiQuoted variant doest work while if I'm running same code to Q-Exp generator everything works
10:54:32 <sam7> Is there a good haskell library for doing vector/matrix operations that is fast and works on num types?
10:54:50 <drunK> hello. is there a possibility that call to `error` somewhere within IO monad (or monadic stack over IO) (I mean, like that: bla1 >> error "ups" >> bla2) will not immediately throw an exception? if so, how can this be prevented from happening?
10:54:57 <qnikst> i've got     Couldn't match kind `*' against `#'
10:55:32 <elliott> drunK: That will throw an exception. But you should use throwIO instead.
10:55:34 <elliott> Or evaluate.
10:56:10 <t7> http://www.media.is.ed.ac.uk/live/webcast/Milner2012/Milner-Symposium.html SPJ live now
10:58:41 <vsajip> On Windows, .hs files which have a shebang line #!/usr/bin/env runhaskell don't work, resulting in a "parse error on input '#!' - though they run fine on Linux. Is there a simple way of circumventing this error, and so having scripts that are cross-platform?
10:58:49 <aib> @pl \(a,b) -> a
10:58:50 <lambdabot> fst
10:59:06 <aib> @pl \((a,b),c) -> (a*b)
10:59:06 <lambdabot> uncurry (uncurry ((const .) . (*)))
10:59:51 <Saizan> vsajip: you could make them literate haskell
11:00:39 <sam7> Is there a good haskell library for doing vector/matrix operations that is fast and works on num types?
11:01:22 <vsajip> Saizan: thanks, but that would mean changing them all, right? (I'm new to Haskell.)
11:01:58 <thelema> Was anyone recording the Milner Symposium webcast (or know where it's available to watch)?  I missed most of the panel discussion which just ended, and would like to review it.
11:02:49 <drunK> elliott: yep, I know throwIO is better in such case. Apparently there may have been the case where throwing exception from `error` call was somehow deferred and appeared later than it should have (I didn't see it myself though, that's why I'm investigating possible scenarios)
11:03:21 <elliott> drunK: Well, return (error "foo") won't throw an exception.
11:03:27 <colah> How should I denote memory complexity? ie. What is the equivelant to big-O notation for memory? (slightly off topic, but this seemed like a place that people might know)
11:03:35 <elliott> The problem with (return $! error "foo") is that it'll throw an exception if it's just evaluated, not executed.
11:03:46 <elliott> colah: Big-O applies to space usage too
11:03:46 <Botje> colah: it's the same.
11:04:30 <colah> Ah, OK. So just say for example "the algorithms memory behaviour is O(n)"?
11:04:35 <colah> Or similar.
11:04:40 <Botje> yes.
11:04:46 <colah> Awesome, thanks.
11:05:10 <drunK> elliott: sure, but it was specifically about calling error like it was monadic action. anyway, thanks for the help
11:09:54 <qnikst> again about TH: http://paste.pocoo.org/show/582527/
11:10:22 <qnikst> for some reason I'll get strange error for quasiquoted function
11:10:33 <elliott> qnikst: simple, you have a kind error
11:10:41 <elliott> why are you using unboxed literals?
11:11:09 <qnikst> it's not me..
11:11:22 <qnikst> I'm paste all code and explain
11:12:11 <qnikst> here is my code: https://gist.github.com/2387857#file_template.hs
11:12:44 <qnikst> unboxed literals are comming from (LitE $ DoublePrimL $ toRational c)
11:13:00 <qnikst> I have no idea how to write it in other way
11:13:13 <qnikst> but q-exp that I get seems fine
11:13:20 <elliott> RationalL
11:13:57 <elliott> but you should probably just use lift
11:14:14 <elliott> ...and also the lowercase functions that are lifted to Q rather than the uppercase constructors
11:15:07 <qnikst> btw, if it possible to use unboxed ones it will be fine because it for computational task
11:15:44 <qnikst> and it will not be ''thunked'' so unboxed variant looks good, unless it doesn't work
11:16:05 <elliott> You don't want to use unboxed types unless you really know what you're doing.
11:16:07 <elliott> they're very second-class.
11:16:27 <elliott> GHC's strictness analyser should take care of pure arithmetic code.
11:16:33 <qnikst> ok
11:17:01 <qnikst> i'll agree in this case
11:18:10 <qnikst> elliott: thanks
11:18:14 <qnikst> it works
11:20:01 <BrianHV> is there any brilliant way to simplify encodeCommandArgs? all it's doing is concatenating the result of calling encode* on all the constructors' parameters. https://github.com/brianhv/vim-netbeans-hs/blob/master/Serializer.hs
11:20:32 <qnikst> elliott: can I ask you some more questions? about this code
11:24:36 <Botje> BrianHV: presumably you can do it with Data.Generics and/or Data.Typeable, but I have no clue, sorry :)
11:25:03 <elliott> qnikst: if they're simple enough ;) I don't have time to look through all of it right now
11:25:57 <qnikst> ok, I'll fix minor problems and ask if smth left
11:28:21 <qnikst> elliott: it seems I should somehow add type for my functoin, so I'll have to do it explicitly?
11:30:59 <elliott> qnikst: not sure what you mean
11:32:04 <keep_learning> Hello all
11:32:36 <qnikst> I'm trying to write test1 = [qrk| ... |]
11:32:48 <keep_learning> There is library which provides different run time option to determine the optimal run
11:33:09 <keep_learning> I don't remember the library
11:33:13 <qnikst> qrk generates some code, but fails with message that I should add (Fractional (Scalar a)) to type
11:34:18 <qnikst> can I set type explicitly by; test1 :: ... \n test1 = [qrk|..|]
11:34:34 <gspr> If I were to say that I'm throwing around ByteStrings of data between functions in various C libraries, would you say I should perhaps not try to force Haskell onto my project in the first place?
11:34:40 <qnikst> or I should change qrk so it will generate function declaration
11:34:42 <gspr> (Vague question-warning!)
11:35:35 <mm_freak> gspr: haskell is also fine as a glue language
11:40:41 <lispy> gspr: I prefer to use Haskell for heavly lifting, but using it for glue probably works okay. One thing to watch out for is that it's easy to incorrectly specify the FFI import/export as the C types are not checked.
11:41:25 <c_wraith> it's especially easy to specify them incorrectly in such a way that they work on your system, but segfault elsewhere
11:42:59 <qnikst> elliott: I discard my question I've found the answer
11:43:16 <danharaj> god I hate Maple
11:43:19 <danharaj> I hate that I have to use Maple
11:52:46 <nexion> case HMS.lookup (T.pack "s") requestJsonObject of
11:52:46 <nexion>   Just (J.String sessionIdST) ->
11:52:46 <nexion>     let sessionId = LT.fromStrict sessionIdST -- is there a nice way to combine this 'let' statement into the above? I'm only interested in the lazy version, so having the ST is just unnecessary code
11:53:31 <yadav> thanks merijn lambdabot Botje; kallisti_ 20 years wow!
11:54:50 <elliott> nexion: yes, if you use the ViewPatterns extension
11:54:58 <elliott> Just (J.String (LT.fromStrict -> sessionId)) -> ...
11:56:50 <ksf> @pl (\k -> n:0:0:0:k)
11:56:50 <lambdabot> ([n, 0, 0, 0] ++)
11:56:55 <ksf> gah.
11:57:28 <gspr> mm_freak, lispy: Thanks for your feedback. I just started feeling stupid for just throwing data from C library to C library. (Doing the actual heavy lifting in Haskell is out of the question, since I'm calling upon thousands of man-hours of code in the libraries in question :) )
11:57:29 <nexion> elliott: interesting.. will look into that, thanks :)
11:57:38 <ksf> not that it's actually measurably less performant, but it's a break in style.
11:59:00 <elliott> ksf: ((n:) . (0:) . (0:) . (0:)) if you want
11:59:37 <ksf> (n:0:0:0:) should just work.
11:59:42 <ksf> it's perfectly unambigious.
12:00:00 <ksf> even (:n:0:0:0:) is.
12:00:03 <danr> @type (n:0:0:0)
12:00:04 <lambdabot>     No instance for (Num [Expr])
12:00:04 <lambdabot>       arising from the literal `0' at <interactive>:1:7
12:00:04 <lambdabot>     Possible fix: add an instance declaration for (Num [Expr])
12:00:08 <elliott> well, it doesn't.
12:00:12 <danr> @type \n -> (n:0:0:0)
12:00:13 <lambdabot> forall a. (Num a, Num [a]) => a -> [a]
12:00:28 <danr> @type \n -> (n:0:0:0:) -- should have a last cons as well
12:00:29 <lambdabot>     The operator `:' [infixr 5] of a section
12:00:29 <lambdabot>         must have lower precedence than that of the operand,
12:00:29 <lambdabot>           namely `:' [infixr 5]
12:08:51 <Franciman> hi all
12:09:08 <Franciman> what's the most efficient way for reading an integer from a bytestring?
12:10:05 <elliott> there is readInt(eger) in Data.ByteString.Char8.
12:11:45 <nyingen> what is a 'hidden module' in a package, and how do I access it?
12:12:26 <BrianHV> :t Data.ByteString.concatMap
12:12:27 <lambdabot> (Word8 -> BSC.ByteString) -> BSC.ByteString -> BSC.ByteString
12:12:47 <BrianHV> why isn't that (a -> ByteString) -> [a] -> ByteString?
12:12:58 <monochrom> you have to rebuild the package with those modules exposed, if you want to access them
12:13:15 <monochrom> and it means changing the package's *.cabal file
12:13:20 <nyingen> I see
12:13:24 <nyingen> I will try that
12:15:49 <nyingen> if I can get this demo to work, I might submit some patches to the package maintainer. I think they hid too many functions, making it hard to integrate their lib with other C libs
12:17:38 <ezyang> http://monoidal.blogspot.com/2012/04/descending-level-ladder.html <-- I'm a bit confused, I thought values and proofs were the same thing
12:18:02 <Franciman> elliot ok thanks
12:18:09 <Franciman> is it faster than read?
12:20:46 <sanjoyd> ezyang: I think the post uses a loose meaning of a "proof".
12:21:10 <sanjoyd> Values are proofs when types are propositions.
12:23:39 <ezyang> So what do they mean?
12:24:00 <Luke> I'm trying to use conduits, specifically using csv-conduit, to process CSV files. The examples help me tie in my row processor but I'm not sure how to actually get the data out of the Conduit given the type signature. The example is here: https://github.com/ozataman/csv-conduit
12:24:18 <elliott> ezyang: They seem to mean that a proof is a proof that a type is inherited.
12:24:27 <elliott> But that's just a constructor you can't eliminate, more or less.
12:24:39 <copumpkin> inhabited :P
12:24:43 <elliott> Er, yes.
12:24:45 <elliott> That is, Inhabited T is a type with witness :: T -> Inhabited T but nothing letting you get a T out of it.
12:24:54 <elliott> (But that proofs Not (Not T), I suppose.)
12:25:00 <elliott> So I don't really see how it relates to the value level.
12:25:10 <elliott> Franciman: You can't use read on ByteStrings.
12:25:37 <Franciman> hmm yes, I meant read on strings sorry
12:26:44 <ezyang> elliott: OK, then we are similarly confused
12:26:50 <BrianHV> Luke: I'm not sure exactly where your issue lies, but I've found the functions in Data.Conduit.List to be most helpful for converting conduit data into something useful
12:27:14 <Luke> BrianHV: I actually have a map type not a list
12:27:23 <Luke> BrianHV: so I'm not sure how to hook map functions into the conduit
12:27:48 <elliott> ezyang: I got all intrigued by the intro, but yeah, I'm not seeing much meaning here. :(
12:28:38 <elliott> oh, in fact I think Inhabited T is exactly ~~T
12:28:49 <elliott> although I might be wrong...
12:29:00 <elliott> wait, no -- ~~(forall P, P \/ ~P) is true
12:29:00 <dolio> You can have a universe of propositions that aren't strictly types, if you get really specific about what you want types to be.
12:29:26 <dolio> However, the idea that they are "below" values somehow isn't well founded, I think.
12:29:26 <BrianHV> Luke: are you trying to do your processing inside the conduit stream? or do you want to operate on the results of the completed conduit stream?
12:29:33 <ozataman_> Luke: you need to build a Conduit to operate on the CSV stream
12:30:30 <ozataman_> Luke: you have 2 options to construct a conduit: use conduitState from the conduit package or drop down to low level and build an recursive action
12:30:33 <Luke> ozataman_: right - i'm not sure what that loosk like though. how do I get access to the data in the conduit?
12:30:47 <elliott> ozataman_: not true!
12:30:53 <elliott> you can write a conduit with do notation and await/yield
12:30:55 <Luke> ozataman_: wouldn't this be a conduitIO?
12:31:29 <Luke> elliott: I think that might be what I'm looking for.
12:31:41 <ezyang> I mean, values are silly anyway because in all "real" programming languages they admit bottom...
12:32:09 <BrianHV> oh, there's a conduitState? that might solve my problem.
12:32:14 <ezyang> It's all fun and games, until you get a "universe inconsistency"
12:32:17 <ozataman_> Luke: see: http://hpaste.org/67111 haven't tried typechecking it, but should work
12:32:39 <Luke> yeah I think I just didn't know await/yeild was the API into the Conduit
12:32:41 <ozataman_> Luke: or you can use conduitState - don't think you'll need the IO version unless you have to do IO to process each row
12:32:42 <Luke> thanks guys
12:33:23 <ozataman_> I should probably add such an example to the README
12:33:36 <Luke> ozataman_: oh so m can be state? I thought m had to do IO
12:33:48 <Luke> ozataman_: m being the type var from the Conduit type
12:34:07 <Luke> ozataman_: it's not your fault - i'm just new to conduits and am unfamiliar with the API
12:34:52 <ozataman_> Luke: well m has to be able to do IO, I think, so the upstream sourceFile/etc. can work
12:35:14 <ozataman_> but your processor need not use IO, in which case conduit saves some time by avoiding a bunch of binds
12:35:33 <Luke> ozataman_: hmm - i'm confused =)
12:35:42 <Luke> let me mess with this code you sent me
12:36:16 <ozataman_> Luke: ah nvm, my bad. the API changed too many times :) even conduitState has an m (..) action there
12:36:58 <Luke> ozataman_: as far as I understand, the 'm' has to be of type MonadResource which can do IO?
12:37:53 <ozataman_> the conduitIO version allocates an outside resource for you if you need it (totally outside of the CSV parsing/rendering)
12:38:05 <Clint> what are you trying to do in your conduit?
12:38:24 <Luke> ozataman_: ah
12:39:13 <Luke> ozataman_: really I won't ever call conduit{IO|State} because sourceFile is building it for me, right?
12:40:06 <ozataman_> Luke: well, you could still use it. I think you may be confusing the purpose of conduitState. it is a 'maker' of conduits - a convenience function if you will - so you don't have to manually recurse and thread state using await/yield
12:40:13 <ozataman_> if you use it, you don't use await/yield
12:40:30 <Luke> oooh
12:40:44 <Luke> yeah you're right - I was confusing it with building the initial conduits
12:40:45 <ozataman_> for the super simple case state could become (), and input could become (MapRow Text)
12:40:52 <elliott> i would say await/yield is usually more convenient
12:40:59 <elliott> conduitState predates it, really
12:41:13 <elliott> (since the pipes model wasn't there previously)
12:41:14 <bgamari> Is there no right-hand equivalent for Data.Foldable.find on Data.Sequence.Seq?
12:41:24 <ozataman_> elliott: I like to await/yield model better too
12:41:44 <Luke> awesome - thanks - I'm starting to see how these things are intended to be used now
12:43:01 <ozataman_> elliott: also, from the other day, the new modular cabal is much better. I still got it to choke on something, but it is far easier to constrain it so it works compared to the old cabal
12:43:13 <ozataman_> at least I got my project compiling again :)
12:46:20 <kosmikus> ozataman_: choke on something? if you found a bug, please report :)
12:47:10 <ozataman_> kosmikus: :) I have no idea if it is a bug. Just a configuration of packages where I would hope for it to be able to solve for the right combination, but it fixates on the latest of one of the packages and walks into dependency hell. Is that a bug?
12:47:21 <ozataman_> I solved it by manually constraining a pkg in my .cabal file
12:48:56 <elliott> ozataman_: \o/
12:49:01 <elliott> ozataman_: it's annoying that you have to specify --solver=modular
12:49:19 <ozataman_> elliott: not sure why, but cabal-dev already uses that
12:49:31 <ozataman_> elliott: I see it when I do cabal-dev install -v
12:49:33 <elliott> ah, neat
12:50:43 <merijn> I remember seeing a proposal about implementing instance chains for GHC, but I can no longer find it?
12:51:00 <Luke> ozataman_: what's the type of doStuffOnX in your example?
12:51:47 <Luke> it's a Pipe right?
12:52:00 <Luke> is there a reason to use pipes at that level?
12:52:13 <ozataman_> Luke: yeah, it would have to be. not at all, unless you're goind to do liftIO. so it needn't be monadic
12:53:50 <Luke> so really doStuffOnX could be pure instead of monadic?
12:54:07 <Luke> that was just random that you called it monadically?
12:54:19 <peel> what's the right way to do something like `let modifiedText = case k of  "Backspace" ->  when (not (null inputText)) (init inputText)`?
12:59:32 <peel> anyone?
13:00:42 <Monk_NT> yes?
13:00:54 <peel> what's the right way to do something like `let modifiedText = case k of  "Backspace" ->  when (not (null inputText)) (init inputText)`?
13:01:10 <monoidal> I don't think there is a shortcut
13:01:24 <peel> when doesn't even work
13:01:35 <peel>  Couldn't match expected type `IO ()' with actual type `[a0]' In the return type of a call of `init' In the second argument of `when', namely `(init inputText)' In the expression: when (not (null inputText)) (init inputText)
13:01:42 <monoidal> if null inputText then inputText else init inputText
13:02:05 <monoidal> when is for monadic actions, when you want to execute something conditionally
13:02:37 <peel> yeah, i saw that in the docs; don't completely understand monadic actions, though
13:02:47 <peel> just thought there might be a similar way that isn't monadic
13:02:56 <monoidal> if/then/else is not monadic
13:02:59 <peel> if/then works but i thought there was something more clever ;)
13:03:06 <peel> thanks
13:03:10 <peel> monoidal++
13:05:25 <Monk_NT> peel, you could use guards
13:06:00 <peel> Monk_NT: with case?
13:06:35 <Monk_NT> oh, sorry, didn't see case :(
13:06:44 <peel> np
13:07:10 <mokus> > case 42 of x | even x -> "even" | otherwise -> "odd"
13:07:11 <lambdabot>   "even"
13:07:12 <peel> anyone here use windows 8 with wxhaskell and know how to get rid of the console that pops up?
13:07:31 <peel> it didn't happen in windows 7
13:07:40 <monoidal> case k of "Backspace" | not (null inputText) -> init inputText; otherwise -> []; ...
13:07:58 <monoidal> umm there is a | instead of |
13:08:50 <peel> that will be useful knowledge
13:11:39 <Monk_NT> Are those guards or are they called something else in that case?
13:12:17 <geekosaur> they're guards
13:16:53 <Luke> so if I want to thread state through my conduit, I have to make a ResourceT State stack?
13:17:34 <c_wraith> Actually, it'd be ResourceT StateT
13:17:37 <kosmikus> ozataman_: you could try if unlimited backtracking helps; --max-backjumps=-1
13:17:47 <Luke> c_wraith: because it needs IO?
13:17:57 <c_wraith> Luke: because conduit is a monad itself
13:18:10 <Luke> c_wraith: so conduit would be the most inner monad?
13:18:24 <mm_freak> ResourceT State is fine, as long as your sources/sinks/conduits don't use IO
13:18:34 <Luke> they don't
13:19:00 <Luke> well I don't know if that's true. I'm using the CSV conduit stuff so I guess they use IO
13:19:01 <mm_freak> anyway, all three are stateful by themselves…  you only need StateT when you want global state
13:19:51 <Luke> I'm not sure if I need that or not. actually I may not since I think my conduit holds the thread until it's done processing the whole file
13:20:21 <Luke> I may actually just need to thread the reader monad through my row processor
13:20:24 <arnoldas> help, I don't get the idea behind the currying concept.. e.g. if I have a function with typsignature like this Int -> (Int -> Int), it means a function (e.g. add) takes the first given argument (e.g. add 1 2 would be 1) and returns a function (Int -> Int) - how do I write this?
13:21:06 <arnoldas> what is this (Int -> Int), how does this look like?
13:21:10 <ozataman_> Luke: the csv-conduit package simply exposes a Conduit ByteString m CSV () type, which is a type that does not do any IO
13:21:22 <ozataman_> and of course a reverse Conduit CSV m ByteString () type
13:21:30 <ozataman_> ah sorry, with Conduit you don't need the ()
13:21:48 <ski> arnoldas : e.g. `add x = add_x where add_x y = x + y'
13:22:18 <ski> (`add 1 2' would here be `3')
13:22:32 <Luke> ozataman_: so the files aren't actually processed until the runResourceT ?
13:23:17 <hpaste_> Luke pasted “CSV Conduit” at http://hpaste.org/67113
13:23:21 <ski> arnoldas : so, given that definition of `add', the function `add', when given an argument `x' will return the function `add_x', where the function `add_x', when given an argument `y' as input will return `x + y'
13:23:24 <Luke> ^what i have so far
13:23:27 <ozataman_> Luke: until runResourceT you're just constructing the machinery or defining the pipeline of computations, depending on how you want to look at it
13:23:33 <ski> arnoldas : do you understand ?
13:24:00 <Luke> ozataman_: yeah if I want to keep sums across all my rows, I can't tell if I need to pass state through the ResourceT monad or not
13:25:25 <arnoldas> ski: not really.. I ment the case if just one argument is given, just x.. partially applied function
13:25:29 <Luke> sorry for all the stupid questions - just trying to wrap my head around conduits
13:25:53 <ski> arnoldas : well, my `add x = ..x..' is just that case
13:26:10 <arnoldas> ski: how can haskell add just one number if definition of add says add two numbers
13:26:11 <ski> it says what `add' will return when just one argument (`x') is given
13:26:12 <ozataman_> Luke: ah I see. I think you may want to make m StateT (MyAccumulator) IO
13:26:38 <Luke> ozataman_: ah ok thanks
13:26:38 <ozataman_> you can then make stateful adjustments in your processCsvConduit
13:26:41 <Monk_NT> arnoldas: Becouse of laziness
13:26:43 <ski> arnoldas : if given one number, it will return a function that will wait for another number to be given, before adding them
13:26:50 <Luke> ozataman_: exactly - that's what I thought. thanks
13:27:02 <ski> Monk_NT : no, not because of laziness .. the same would hold in a strict language
13:27:05 <Mait_> Hey, I'm following this book turorial, http://learnyouahaskell.com
13:27:18 <Mait_> How can I declare func type in ghci? When I type these in ghci, always give me error(withe let , or without let).
13:27:43 <Mait_> <interactive>:3:5:
13:27:43 <Mait_>     The type signature for take' lacks an accompanying binding
13:27:46 <mm_freak> Luke: what do you need state for anyway?  CSV is pretty much stateless
13:27:48 <Mait_> like this
13:27:52 <mm_freak> except perhaps the header line
13:27:58 <ski> @let add :: Int -> (Int -> Int); add x = add_x  where  add_x y = x + y
13:27:59 <lambdabot>  Defined.
13:28:03 <ski> > add 1 2
13:28:07 <lambdabot>   mueval-core: Time limit exceeded
13:28:13 <ski> @let add :: Int -> (Int -> Int); add x = add_x  where  add_x y = x + y
13:28:13 <Luke> mm_freak: summing across rows and cols etc
13:28:13 <lambdabot>  <local>:5:0:
13:28:13 <lambdabot>      Duplicate type signature:
13:28:13 <lambdabot>        <local>:5:0-25: add :: In...
13:28:15 <ski> er
13:28:18 <ski> > add 1 2
13:28:21 <lambdabot>   3
13:28:27 <ski> @botsnack
13:28:27 <lambdabot> :)
13:28:40 <mm_freak> Luke: that's the job of a sink or a conduit…  you would use the latter for things like running sums
13:28:57 <Luke> mm_freak: how would it keep the sum across rows?
13:28:58 <ski> > let add_one = add 1 in [add_one 1,add_one 20,add_one 300]
13:29:00 <lambdabot>   [2,21,301]
13:29:01 <monoidal> arnoldas: You can read add x y = x + y as add = \x -> (\y -> x + y)
13:29:12 <ski> > let add_one = add 1 in map add_one [1,20,300]
13:29:14 <lambdabot>   [2,21,301]
13:29:36 <Monk_NT> ski: Yes, you are right...
13:29:37 <mm_freak> Luke: depends on what the sink receives
13:29:51 <Monk_NT> ski: I had to stop and think for this long
13:29:54 <ski> arnoldas : `map' takes a function and a list, and calls the function on each element of the list -- above the function is `add_one' which was returned by `add 1' here
13:29:57 <ski> arnoldas : can you follow those examples ?
13:30:17 <Monk_NT> ski++
13:30:35 <arnoldas> ski: I think yes
13:30:53 <Luke> mm_freak: can the sink keep it's own state across inputs?
13:30:57 <ski> Monk_NT : i would wait with that until arnoldas says s/he's understood anything i said ;)
13:31:09 <arnoldas> monoidal: ty, that's what I wanted to know
13:31:21 <ski> arnoldas : so, `add 1' here returns a function, the function that will add one to its input
13:31:47 <ski> arnoldas : above, i called this function `add_one' in the `let', and called that function three times, on three different inputs
13:32:07 <Monk_NT> ski: Nevermind, even if you are wrong, you were helpful, and made me think, so that's some good karma on you :)
13:32:16 <ski> each time, the `add_x' function was called with `y' being bound to three different values (`1',`20',`300')
13:32:38 <mm_freak> Luke: across inputs?  as in when you restart the ResourceT computation?
13:32:58 <Luke> mm_freak: no like across rows of the csv
13:33:07 <Luke> mm_freak: between chunks
13:33:24 <ozataman_> Luke: oh. you can then just thread statein the recursive call
13:33:27 <ski> (but the `add_x' function that `add 1' returns "knows" that `x' is in this case `1', so the `add_x y = x + y' it uses will actually be `add_x y = 1 + y' -- if you call `add 42' to get a function, the `add_x' that that returns will "know" a different value for `x')
13:33:45 <Luke> ozataman_: yeah that's what I'm confused about =)
13:33:47 <ski> arnoldas : if what i just said sounds complicated, you can probably skip it for now
13:33:48 <ozataman_> Luke: I thought you needed to know *after* the runResourceT finishes for the rest of your program or something
13:34:00 <Luke> ozataman_: will my conduit visit the whole file before going on to the next pipe in the pipeline?
13:34:07 <Luke> ozataman_: no
13:34:17 <ski> arnoldas : however, note that one can rewrite the definition `add_x y = x + y' as `add_x = \y -> x + y'
13:34:18 <ozataman_> Luke: no, the whole conduit pipeline will process one row at a time
13:34:32 * kallisti notes that foldM from Data.Conduit.List is a good way to thread state in a conduit.
13:34:34 <Luke> ozataman_: then how can I keep state for just one conduit in the pipeline?
13:34:42 <ski> arnoldas : `\y -> x + y' means *the* (not necessarily named) function which, when given an input (call it `y'), will return `x + y'
13:34:55 <ozataman_> by adding a parameter to your processConduit
13:34:58 <kallisti> Luke: ^
13:35:13 <kallisti> foldM or fold
13:35:15 <Luke> kallisti: I don't have a lit though
13:35:17 <Luke> list*
13:35:21 <kallisti> List doesn't actually use lists
13:35:21 <Luke> ozataman_: ok thanks
13:35:24 <ozataman_> so it is processConduit acc = doStuff >> processConduit (newAcc)
13:35:27 <ski> arnoldas : so the whole definition `add x = add_x  where  add_x y = x + y' can be rewritten as `add x add_x  where  add_x = \y -> x + y'
13:35:27 <kallisti> it's list-like combinators
13:35:32 <ski> arnoldas : do you follow ?
13:35:33 <kallisti> because a conduit itself is a kind of "sequence"
13:36:01 <kallisti> Luke: fold has nothing to do with lists, in fact.
13:36:19 <ski> arnoldas : sorry, i meant : so the whole definition `add x = add_x  where  add_x y = x + y' can be rewritten as `add x = add_x  where  add_x = \y -> x + y'
13:36:40 <kallisti> Luke: the only problem is that foldM is a Sink, but this can be fixed by using the sequence function, which changes a Sink into a Conduit.
13:37:46 <Luke> this is confusing =) I can't tell what will be called when
13:37:51 <hiptobecubic> Those of you using ghc-mod in emacs, does it tell you type class restraints on type variables in function types? It doesn't seem to in vim.
13:38:57 <ski> (s/restraints/constraints/ :)
13:39:10 <kallisti> Luke: it's just a pipeline of processors. Each processor is demand-driven, so that it performs some computation when a value is ready for it. This happens when the pipe before it yields a result.
13:39:59 <hiptobecubic> ski, thanks :)
13:41:55 <hiptobecubic> For example, i have a function with type   asianAnalytic :: Integral a => Double -> Double -> Double -> Double -> Double -> a -> Double, but ghc-mod just returns Double -> Double -> Double -> Double -> Double -> a -> Double
13:42:45 <Luke> kallisti: right but if my state of the pipeline is recursive then how am I not processing the whole input stream before passing it to the next phase?
13:43:31 <kallisti> Luke: it depends on how your recursion is set up
13:43:37 <kallisti> if it's done correctly then the answer is: lazy evaluation
13:43:57 <hiptobecubic> Well i guess i'll investigate tomorrow.
13:44:30 <Luke> kallisti: even if it's lazy, wouldn't the next stage of the pipeline need to be called after each call to my state of the pipeline?
13:44:35 * ski wonders what kind of stream processor type kallisti&Luke is talking about
13:44:46 <Luke> ski: conduits
13:44:56 * ski knows nothing about those
13:45:03 <Luke> join the club =)
13:45:11 <ski> @hackage conduits
13:45:12 <lambdabot> http://hackage.haskell.org/package/conduits
13:45:12 <kallisti> Luke: each time your recursive function will HaveOutput it defers to the next computation in the pipeline, yes.
13:45:42 <Luke> kallisti: but my state is still kept even though it defers to the next computation in the pipeline?
13:45:47 <kallisti> sure
13:45:51 <Luke> how?
13:46:07 <kallisti> well, I'd need to see your code to really explain it.
13:46:16 <Luke> http://hpaste.org/67113
13:46:47 <Luke> i'm just going to sum a column of each row
13:46:55 <Luke> the sum being the state
13:47:58 <kallisti> Luke: the way it works is that >>= sets up the function that's passed to it as "the pipe to run next"
13:48:03 <ski> if this is anything similar to `data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)', then it keeps the state because each time a component in the pipeline accepts an input or generates an output, it is "replaced" by the next version of itself (because of how composition of pipelines is defined)
13:49:31 <kallisti> so yield returns HaveOutput (return ()) (FinalizePure ()) (processRow row)
13:49:37 * hackagebot control-monad-exception 0.10.2 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.10.2 (PepeIborra)
13:49:39 <kallisti> and then >>= is applied to that
13:49:49 <kallisti> which then replaced the return () with the rest of your computation
13:49:55 <kallisti> it's a continuation, basically.
13:50:05 <Luke> hmm ok
13:51:25 <Luke> maybe I just need to mess around with it a bit more in order to start internalizing it
13:51:31 <kallisti> yep
13:51:36 <Luke> thanks for answering all my questions
13:51:45 <kallisti> but essentially >>= preserves the state of your computation so that it can be executed later
13:51:45 * shapr boings cheerfully
13:51:54 <Luke> kallisti: ok thanks
13:52:24 <kallisti> Luke: also you can rewrite that case with maybe, if you prefer
13:52:45 <Luke> the fail of maybe will return ()?
13:53:07 <kallisti> await >>= maybe (return ()) (\row -> yield (processRow row) >> processCsvConduit)
13:53:18 <kallisti> with layout it looks a little better
13:53:25 <Luke> yeah thanks
13:53:33 <Luke> gotcha - thanks so much
13:53:37 <kallisti> no prob.
13:53:41 <ski> Luke : btw, instead of `case csvRow of Nothing -> return (); Just row -> do ..row..', you can say `forM csvRow $ \row -> do ..row..'
13:53:41 <rasfar> shapr, you still unicycle then?
13:53:44 <ski> using
13:53:44 <ski> @type Data.Traversable.forM
13:53:45 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Data.Traversable.Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
13:53:48 <kallisti> Luke: actually I end up doing that await >>= maybe (return ()) ...  boilerplate quite a bit
13:53:52 <kallisti> I feel it can probably be abstracted in some way.
13:53:55 <shapr> rasfar: I do, what about you?
13:53:58 <ski> with `t' there being `Maybe
13:54:03 <ski> s//'/
13:54:17 <shapr> men jag älska ä!
13:54:24 <rasfar> never tried, but i moved to montreal some months ago, and there's a fair amount of unicyclists around here
13:54:30 <Luke> kallisti: I imagine I can use the List fold stuff then?
13:54:47 <kallisti> Luke: you can, but the way you have it written right now may be the clearest.
13:55:00 * ski gillar `' ocks, men skulle inte ha det i detta fallet :)
13:55:11 <Luke> kallisti: yeah while I try to understand wtf is going on =D
13:55:24 <kallisti> Luke: but have a look at Conduit.List... it has nothing to do with lists.
13:55:28 <shapr> ski: jaså
13:55:43 <Luke> kallisti: yeah I see that now
13:55:52 <kallisti> (it's perhaps somewhat poorly named)
13:56:07 <ski> kallisti : as i said to Luke, instead of `maybe (return ())' you can use `forM' or `mapM' from `Data.Traversable'
13:56:10 <ski> @type Data.Traversable.mapM
13:56:11 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
13:57:09 <kallisti> ski: ah indeed
13:57:57 <ski> kallisti : so i suppose `await >>= mapM $ \row -> do ..row..' in your case -- maybe you need brackets there, i'm not sure
13:58:07 <BrianHV> is there a function of type Conduit [a] m a that just passes the items through one at a time instead of as a list?
13:58:24 <kallisti> ski: yeah you need brackets or composition
13:58:32 <kallisti> actually use >=> instead of >>=
13:58:38 <kallisti> and that will work
13:58:49 <ski> hm, it will ?
13:58:58 <kallisti> believe so.
13:59:00 <Luke> @type (>=>)
13:59:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:59:04 <ski> `await' doesn't look like a function, to me
13:59:17 <kallisti> oh, indeed.
13:59:28 <Luke> @type (>>=)
13:59:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:00:09 <mm_freak> BrianHV: i don't think so, but it should be very easy to write
14:00:22 <mm_freak> use conduitState with a () state
14:01:47 <tazjin> Okay so, what is :- in a type signature? I've never seen that before and it's almost impossible to google for symbols
14:02:10 <monoidal> tazjin: http://www.haskell.org/hoogle/?hoogle=%3A-
14:02:11 <mm_freak> tazjin: it's a type
14:02:14 <Luke> ski: i can't seem to get this to compile: processCsvConduit acc = await >>= (mapM_ (\row -> yield (processRow row))) >> processCsvConduit acc
14:02:18 <ski>   forM =<< await $ \row -> do ..row..  -- i think this will work
14:02:24 <monoidal> tazjin: whoops, not the same
14:02:27 <mm_freak> tazjin: in infix notation, that's why it might look confusing
14:02:35 <monoidal> but yes, it is type operator (-XTypeOperators)
14:02:50 <tazjin> Okay, thanksies
14:03:23 <ski> Luke : that isn't even equivalent to the original code -- that will always call `processCsvConduits', instead of only calling it in the `Just row' case, which was what your previous code did
14:03:53 <mwc> Hmm, any undocument workarounds to ghc's -M dependency generation being transitive (processes included modules). I need a non-transitive version, process the module and stop without processing any unstable imports.
14:03:55 <Luke> ski: I don't follow
14:04:16 <ski> Luke : which do you want ? (a) always continue calling `processCsvConduit'; or (b) only continue calling it in the `Just row' case ?
14:04:24 <Luke> ski: you mean throw the recursive call into the lambda?
14:04:38 <kallisti> yes
14:04:43 <Luke> k
14:04:54 <Veinor> is there any way in ghci to see what type a type family 'resolves' to?
14:05:23 <ski> Luke : i'm talking about your original code in the paste <http://hpaste.org/67113> -- that code only calls `processCsvConduit' (recursively) in case `csvRow' was of shape `Just row'
14:05:40 <Luke> yeah
14:05:54 <Luke> what's the mapM saving me from then?
14:06:06 <ski> Luke : but now your code attempt above seemed to want to always continue calling `processCsvConduit' (because it wasn't inside the `mapM_' call)
14:06:12 <kallisti> in the case where there's no more input you want the computation to terminate, instead of diverging infinitely, which is what would happen with the recursive call on the outside.
14:06:36 <Luke> processCsvConduit acc = await >>= (mapM_ (\row -> yield (processRow row) >> processCsvConduit acc))
14:06:38 <Luke> ?
14:06:52 <ski> Luke : the `mapM_'/`forM_' is for not having to write `case csvRow of Nothing -> return (); Just row -> do ..row..' boilerplate
14:07:20 <Luke> processCsvConduit acc = await >>= maybe (return ()) (\row -> yield (processRow row) >> processCsvConduit acc)
14:07:20 <Luke> was the latest code I had
14:07:33 <ski> i'm not sure what this `acc' is
14:07:48 <Luke> does nothing yet =)
14:07:52 <kallisti> ski: well clearly it has type a  :)
14:07:59 <Luke> haa
14:08:21 <ski>   processCsvConduit = do
14:08:24 <ski>     csvRow <- await
14:08:27 <ski>     forM_ csvRow $ \row -> do
14:08:28 <ski>       ..row..
14:08:32 <ski> should work
14:09:44 <Luke> it's the ..row.. i'm missing you on =)
14:09:59 <kallisti> that's your processRow stuff
14:10:23 <kallisti> basically your do block as it was
14:10:25 <ski> oh .. that's just shorthand for your original `yield (processRow row)' and `processCsvConduit' rows
14:10:42 <ski> (i didn't write it out explicitly, because i didn't touch that part of the code)
14:10:44 --- mode: ChanServ set +o copumpkin
14:10:47 --- mode: ChanServ set -o copumpkin
14:10:57 * ski stares blankly
14:11:08 <kallisti> fear the mighty copumpkin.
14:11:15 <copumpkin> sorry, my mistake :P
14:11:54 <Luke> processCsvConduit = await >>= mapM_ (\row -> yield $ processRow row >> processCsvConduit)
14:11:54 <Luke> how is this wrong?
14:12:11 <cofreecokallisti> Luke: $ has lower prec than >>
14:12:16 <ski> Luke : i think if you remove the `$' it will work
14:12:29 <ski> er, replace it with brackets, i.e.
14:12:34 <ezyang> When you do the data Mu t = Mu (t (Mu t)) trick, what is 't' called?
14:12:52 <Luke> processCsvConduit = await >>= mapM_ (\row -> yield (processRow row) >> processCsvConduit)
14:12:52 <Luke> same problem here
14:13:39 <kallisti> Luke: must be a different problem, then.
14:13:44 <kallisti> because that code isn't equivalent
14:14:02 <ski> Luke : did you import `mapM_' from `Data.Traversable' yet (and presumably also hide (or import qualified) `mapM_' from `Control.Monad' (or wherever you're getting it from))
14:14:05 <ski> ?
14:14:14 <kallisti> with the $ you had yield (processRow row >> processCsvConduit)
14:14:16 <Luke> ski: oh good call - that's got to be it
14:14:27 <Luke> kallisti: which do I want here?
14:14:29 <ezyang> Does it even have a name?
14:14:36 <kallisti> Luke: think about it. ;)
14:14:37 * hackagebot language-javascript 0.5.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.1 (AlanZimmerman)
14:14:48 <ezyang> I guess, more generally speaking, when you take the fixpoint of a function, is there a distinguished name for the function being fixpointed?
14:14:51 <ski> Luke : you want `yield (processRow row) >> processCsvConduit'
14:15:01 <Luke> ski: ok that's what I thought
14:15:04 <ski>   processCsvConduit = await >>= mapM_ (\row -> do yield (processRow row); processCsvConduit)
14:15:08 <ski> or that
14:15:09 <ski> or
14:15:13 <Luke> righ
14:15:14 <ski>   processCsvConduit = await >>= mapM_ (\row -> do yield $ processRow row; processCsvConduit)
14:15:17 <ski> if you must
14:15:21 <Luke> haha
14:15:51 * ski generally thinks `$' is way too overused -- at least by some people
14:16:14 * BrianHV couldn't be happier with his conduit code.
14:16:18 <kallisti> or fix $ \loop -> (await >>= void . mapM_) (\row -> do do do yield (processRow row) >> processCsvConduit)
14:16:21 <kallisti> er
14:16:23 <kallisti> or fix $ \loop -> (await >>= void . mapM_) (\row -> do do do yield (processRow row) >> loop)
14:16:56 <kallisti> er.... nevermind
14:16:59 <kallisti> don't pay attention to me.
14:17:35 <ski> mm_freak : .. could also be an infix class
14:17:39 <Luke> =p
14:19:09 <mm_freak> ski: i've never seen an infix class
14:19:31 <mm_freak> though i assume some people use them for traditional class-based type level arithmetic
14:19:58 <hpaste_> Luke pasted “Conduit 2” at http://hpaste.org/67118
14:20:06 <Mathnerd314> ezyang: fixee? :-)
14:20:09 <Luke> ^ still has compiler error
14:20:28 <Luke> there's no mapM_ in Data.Traversable
14:20:39 <ski> mm_freak : i think i saw some edwardk code using it a week or so ago
14:20:41 <kallisti> @hoogle Data.Traversable.mapM_
14:20:41 <lambdabot> No results found
14:20:46 <kallisti> @hoogle Data.Traversable.mapM
14:20:47 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:20:57 <ski> oh .. right
14:21:06 <edwardk> mm_freak: you can use them with TypeOperators
14:21:08 * ski tries to recall what it's actually named
14:21:08 <Luke> Control.Monad wont work huh?
14:21:16 <ezyang> That doesn't seem very standard :&0
14:21:17 <mm_freak> mapM_ belongs to Foldable
14:21:37 <ski> @type Data.Foldable.forM_
14:21:38 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Data.Foldable.Foldable t, Monad m) => t a -> (a -> m b) -> m ()
14:21:41 <ski> @type Data.Foldable.mapM_
14:21:42 <mm_freak> edwardk: i know…  i just haven't seen anyone use them
14:21:42 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
14:21:49 <ski> Luke : those are the ones you want ^
14:21:54 <Luke> success =)
14:21:58 <Luke> Foldable - thanks
14:22:27 <ski> (Luke : initially i was thinking only of `mapM' and `forM', not `mapM_',`forM_', which was why i was looking in `Data.Traversable' instead of `Data.Foldable')
14:22:41 <Luke> yeah I know - the _ was me =)
14:22:48 <Luke> thanks a lot
14:23:06 <Mathnerd314> ezyang: after a point, you just have to start assigning names systematically...
14:23:11 <ski> Luke : and no, `Control.Monad.mapM_'/`Control.Monad.forM_' won't work here, because those only accepts lists, they are not polymorphic over other data structures (like `Maybe' in your case)
14:23:23 <ezyang> Also, makes it sound like it's a sandwich trimming :^)
14:24:33 <rasfar> by analogy with chemistry (precipitate, filtrate), it would be ... fixate :-/
14:24:53 <Luke> ski: why don't the Traversable/Foldable mapM and forM work for lists?
14:25:31 <Mathnerd314> rasfar: fixate is already in use
14:25:42 <mwc> rasfar: by analogy with math operands, eg, dividend, radicand, we could suggest "fixand"
14:25:43 <ski> Luke : they *do* work for lists, but they also work for other data types -- however, the ones in `Control.Monad' only works over lists (in any monad)
14:25:52 * kallisti is somewhat unclear on what makes something a continuation in Haskell
14:25:56 <Luke> ah
14:26:10 <ezyang> I know, I'll call it Endo.
14:26:20 <ski>   processCsvConduit = ((await >>=) . mapM_) $ \row -> do
14:26:20 <ski>     ..row..
14:26:39 <ski> Luke : i think you could do that, if you wish to avoid naming `csvRow' in your code
14:26:49 <ski> (it looks somewhat clunky, though)
14:27:00 <Luke> heh
14:27:41 <ski> mwc : "fixand" re what ?
14:28:51 <Mathnerd314> ezyang: how does that help? :p
14:28:52 <rasfar> Mathnerd314: it's somehow apropos though, fixate (fixate (fixate... -- wow that word sound totally alien to me now
14:29:37 <Mathnerd314> I'll vote for fixand
14:29:39 * hackagebot certificate 1.2.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.0 (VincentHanquez)
14:29:40 * hackagebot tls 0.9.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.3 (VincentHanquez)
14:29:57 <fakier> help
14:30:00 <fakier> lol
14:30:04 <fakier> hey y'all
14:30:06 <hayashi> Naming things in Haskell can be really hard, because often you'll come up with a combinator that does so many different things that it's hard to pin a name that's shorter than its constituent code on it >_>
14:30:07 <rasfar> ski: ezyang asked what the "object" of a fixpt is called, if there's any standard nomenclature
14:30:11 <hayashi> Or is that just me
14:30:52 <hayashi> Or it does abstract things like sandwiching two functions together in a very obtuse but often repeated way
14:30:58 <ezyang> And it so happens that you can only take the fixpoints of endofunctors in Haskell...
14:31:12 <mwc> yes, hence Endo
14:31:30 <rasfar> it's the "endo the line" :)
14:31:41 <hayashi> mmm, endoscopy
14:33:34 <aib> what class should I use for operating on a 2D rectangular number matrix? ideally, I want an operation that can blit such a rectangle onto a bigger one, but I doubt any matrix library has such a feature
14:34:20 <mwc> Sounds like you want one of the numerical array libraries on Hackage
14:34:25 <Mathnerd314> ezyang: but not every endofunctor has a fixed point (discounting _|_)
14:34:40 <hpaste_> keep_learning pasted “parallel strategy” at http://hpaste.org/67119
14:34:53 <ezyang> it's true.
14:34:55 <keep_learning> Hello all
14:35:27 <keep_learning> I have a function recurSparse  xs ys
14:35:46 <keep_learning> and I am trying to call this function using parListChunk
14:36:00 <keep_learning> The sequential code is more better than parallel code
14:36:40 <keep_learning> Why parallel code is performing bad
14:37:21 <keep_learning> http://hpaste.org/67119
14:38:58 <mwc> aib: at the high end, check out accelerate for parallel array computation, at the low end, just use StorableArray and write some routines to blit it. I think there are a few packages on Hackage that do the latter, although I can't recall their names.
14:39:17 <aib> mwc: okay, thanks
14:39:29 <mwc> StorableArray will allow you to basically implement your blits as memcpys
14:39:36 <mwc> Foreign is your friend
14:39:38 * hackagebot tls-extra 0.4.5 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.5 (VincentHanquez)
14:39:51 <mwc> but take a look for a package that does that already, I'm sure they exist
14:40:40 <ski> rasfar : itym "fixed point" by "fixpt" -- do you mean the argument or the result of `fix' by "object" ?
14:41:18 * ski defaults to assuming argument, lacking contrary evidence
14:42:01 <rasfar> ski: i should refer you to ezyang (surprised you missed that discussion, it was interleaved with your own).  yep, the argument.
14:42:40 <ski> rasfar : heh, i was probably too involved with the other discussion to follow it properly :)
14:42:41 <rasfar> he settled on "endo" since only endos can have fixpts (although not all endos do)
14:44:34 <rasfar> s/he/they/  oops, trying to keep to the rule about that
14:44:53 <ski> (i would probably use the general word "operand" instead of "object" -- as in "the operand of the square-root function can be called \"radicand\"")
14:45:17 <ski> (well, s/function/operator/, i suppose -- operator and operand(s))
14:45:25 <rasfar> sorry, "object" was my own term, operand is certainly better
14:46:10 <rasfar> mwc did in fact suggest "fixand" on that basis
14:47:14 <keep_learning> Some one please
14:47:17 <keep_learning> http://hpaste.org/67119
14:48:00 * ski likes the traditional math terms "augend","addend"; "subtrahend","minuend"; "multiplicand","multiplier"; "dividend","divisor"; "abscissa","ordinate","applicate"; &c.
14:48:41 <rasfar> keep_learning: is there significant overhead in taking the length of the list?  do you do so in the non-parallel code to maximise comparability?
14:50:34 <keep_learning> rasfar, The length of the list is 490228
14:50:45 <keep_learning> and recurSparse is sequential
14:50:46 <rasfar> maybe easiest would be to just use the numeric literal -- right -- so
14:50:47 <kallisti> elliott: hello elliott@unaffiliated/elliott
14:50:58 <rasfar> > 490228 `div` 8
14:50:59 <lambdabot>   61278
14:51:05 <rasfar> just use that as your chunk size?
14:51:38 <rasfar> (just for the test)
14:51:49 <ksf> damn. I got HaRe to build with ghc 7.4.1, just to discover that it wants to slurp up things like Control.Applicative before refactoring.
14:53:45 <rasfar> well, never mind, this can't be the explanation, it is not going to take on the order of 10 seconds to take the length of such a list on your machine!
14:54:13 <keep_learning> rasfar, Yes and run time is almost same
14:54:52 <rasfar> keep asking, someone will help; not much else going on at the moment :)
14:55:32 <qnikst> hm .. I have function where i'm do let i = mkName "i" ... and I call inner function where I do the same, is it possible for inner function to see that binding in outter?
14:55:54 <keep_learning> rasfar,  :)
14:56:03 <qnikst> i.e. I have  outter f = do { let i = mkName ; inner } where inner = ..
14:58:41 <mm_freak> in reflection 1.1 what's the proper way to get integers up the type level?
14:58:58 <mm_freak> do i have to define my own Nat type again?
14:59:22 <mm_freak> (clarification: i'm using DataKinds)
15:00:01 <elliott> mm_freak: hi
15:00:06 <mm_freak> hi there elliott
15:00:07 <elliott> mm_freak: you can just reflect an Integer
15:00:12 <elliott> (I worked on the new reflection)
15:00:18 <elliott> mm_freak: no need to define anything
15:00:25 <elliott> the exposing of the intermediate steps was just a performance hack really
15:00:30 <ksf> ...HaRe is a prime example of why academia is useless when it comes to producing code.
15:00:36 <mm_freak> elliott: not that simple…  i'm working on my modular arithmetic library again
15:00:47 <elliott> mm_freak: well, I've done it
15:00:54 <elliott> mm_freak: (ReifiesNum s) --> (Reifies s Integer)
15:01:13 <mm_freak> elliott: i have this type:  data Modulus = FiniteRing Integer
15:01:20 <mm_freak> it will be extended later
15:01:25 <elliott> mhm
15:01:27 <elliott> (Reifies s Modulus) then
15:01:31 <ksf> we should bait some gsoc people to fix it.
15:01:40 <mm_freak> now i'm defining this instance:  instance (Reifies n Integer) => Num (Mod (FiniteRing n) Integer)
15:01:41 <rasfar> qnikst: i would guess, "not" -- would be easy to write a test i guess
15:01:45 <mm_freak> but that's a kind error
15:01:55 <mm_freak> because Reifies wants *, but is getting Modulus
15:02:10 <elliott> uh
15:02:12 <elliott> eh?
15:02:18 <elliott> please
15:02:21 <elliott> tell me what you had before reflection 1.1?
15:02:33 <elliott> it's trivial to translate anything pre-1.1 to 1.1
15:02:37 <qnikst> rasfar: question is about is it possible to restructure
15:02:38 <qnikst> =)
15:02:44 <mm_freak> before that i had an entirely different approach
15:03:04 <elliott> ok, well
15:03:08 <mm_freak> data FiniteRingMod; data CrtMod; data PolynomialField; …
15:03:13 <elliott> instance (Reifies n Modulus) => Num (Mod n Integer)
15:03:25 <mm_freak> hmm
15:03:27 <elliott> shall i show you my trivial modular arithmetic code?
15:03:40 <rasfar> qnikst: i thought the question was, are let bindings inside a "do" visible in a "where" (outside the "do")?
15:03:45 <elliott> mm_freak: remember, (Reifies s a) is like (s :: a)
15:03:51 <elliott> instance (n :: Modulus) => Num (Mod n Integer)
15:04:06 <mm_freak> elliott: that will destroy most of the clean structure of the library…  i have separate modules for all the different kinds of moduli
15:04:16 <elliott> here: http://hpaste.org/66565
15:04:31 <mm_freak> note that Mod is a data family
15:04:35 <elliott> mm_freak: then I do not understand your question, really
15:04:40 <elliott> Mod cannot be a data family
15:04:40 * hackagebot PropLogic 0.9.0.4 - Propositional Logic  http://hackage.haskell.org/package/PropLogic-0.9.0.4 (DavidFox)
15:04:42 <elliott> because the reified values are opaque
15:04:50 <qnikst> rasfar: it's not visible, and it's normal :)  but I see no easy and correct way to rewrite
15:04:55 <mm_freak> elliott: don't confuse Mod and Modulus
15:05:03 <mm_freak> data family Mod :: Modulus -> * -> *
15:05:27 <elliott> mm_freak: ok, well, reflection does not do the datakind stuff -- the reflected type is of kind *
15:05:32 <elliott> now, you can probably build datakind stuff on top of it
15:05:42 <elliott> oh, I see
15:05:44 <mm_freak> i see
15:05:51 <elliott> mm_freak: well, what you'd need is
15:05:53 <rasfar> qnikst: you can pass thing bound by a "let" as arguments to a function defined in the "where", maybe that could help?
15:05:58 <elliott> instance (Reifies n Integer) => Num (Mod (FiniteRing (reflect (Proxy :: Proxy n))) Integer)
15:06:00 <elliott> but you can't do that
15:06:38 <elliott> mm_freak: but, what's wrong with
15:06:43 <elliott> instance Num (Mod (FiniteRing n) Integer)
15:06:43 <elliott> ?
15:07:00 <elliott> I mean I don't understand what you're trying to use reflection for :)
15:07:03 <mm_freak> fromIntegral needs to use 'reflect' to get the modulus
15:07:09 <mm_freak> uhm
15:07:11 <mm_freak> fromInteger
15:07:38 <elliott> out of curiosity, is there a reason you can't simply change Modulus?
15:07:41 <elliott> so that something like http://hpaste.org/66565 works
15:08:37 <mm_freak> that would support only one modulus type
15:09:02 <jfischoff> is runCommand/createProcess supposed to be blocking?
15:09:04 <mm_freak> the library should support CRT moduli as transparently as possible
15:09:10 <mm_freak> (at least)
15:09:34 <mm_freak> but i might have an idea
15:09:37 <elliott> mm_freak: well
15:09:45 <elliott> mm_freak: data Modulus a = Modulus a
15:09:50 <elliott> then
15:09:51 <elliott> instance (Reifies n Integer) => Num (Mod (FiniteRing n) Integer)
15:09:52 <elliott> will work
15:11:18 <mm_freak> elliott: i got it
15:11:24 <mm_freak> yeah
15:11:32 <mm_freak> same solution =)
15:11:39 <mm_freak> data Modulus a = FiniteRing a
15:11:49 <mm_freak> thanks for your time
15:12:07 <elliott> mm_freak: np :) let me (or edwardk) know if you run into any other issues
15:12:37 <jfischoff> the answer is no
15:13:36 <keep_learning> Kindly some one please have a look at my code http://hpaste.org/67119
15:13:59 <keep_learning> and tell me if I am using parListChunk correctly or not
15:14:32 <keep_learning> I am trying to learn strategy
15:17:09 <sam7> is there a good vector/matrix operation library in haskell that works on Num class and is relatively fast?
15:18:33 <pyry`> Anyone have time for a "help me i come from the imperative world" question?
15:18:40 <pyry`> I've googled furiously, but I'm still not sure what to do
15:19:16 <bitonic> pyry`: don't ask to ask :)
15:19:35 <hpc> pyry`: you get one question for free and just asked it; further questions are $4.99
15:19:38 <hpc> ;)
15:19:44 <pyry`> hpc: :D
15:19:46 <hpc> or 800 microsoft points
15:20:00 <pyry`> haha, oh crap, now i have to buy a $100,000,000 license
15:20:48 <pyry`> i think what i can boil my question down to in similarity is an imperative wordcount program that operates on input that is already one word per line and sorted
15:21:18 <pyry`> my imperative version is that i read the file line by line, if the current line matches the next line, then it's appended to a chunk, if not, that chunk is counted and something is outputted
15:21:44 <pyry`> i've seen that there are easier ways to a wordcount in haskell, but that's not exactly what i'm looking for
15:22:49 <ksf> @hoogle nub
15:22:49 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
15:22:49 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
15:23:12 <ksf> that's what you want, semantically, but not really, as it's quadratical as it doesn't expect a sorted list :)
15:23:32 <pyry`> ksf: mm, i can inspect further
15:23:40 <pyry`> in any case it's something i should learn from the standard libraries
15:23:41 <pyry`> :D
15:23:51 <ksf> but using that is good enough for a first prototype.
15:23:57 <pyry`> do you know if "nub" is short for something more mnemonic?
15:24:07 <ksf> main = interact (show . length . nub . lines)
15:24:40 <rasfar> if already sorted, how about:  map head $ group  ?
15:24:41 * hackagebot wai-middleware-static 0.1.0 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.1.0 (AndrewFarmer)
15:24:47 <ksf> :t group
15:24:48 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:25:07 <pyry`> i'd tried a solution using group, which was fine
15:25:08 <rasfar> (it groups adjacent, identical elements
15:25:15 <pyry`> but the method of reading the file made it much slower than it needed to be
15:25:27 <pyry`> and i've got a fairly large input
15:25:35 <ksf> yep.
15:25:52 <ksf> main = interact (show . length . group . lines) should work just fine.
15:25:54 <rasfar> oh, i thought ... shouldn't it be lazy?
15:26:17 <ksf> group is a foldr.
15:26:20 <rasfar> right, you want counts, not the actual unique elements, oops
15:26:53 <rasfar> keep_learning: is it possible to, and have you tried, using just rseq?
15:27:09 <ksf> there's other considerations like not using String but something faster, but asymptotically you should be fine with group.
15:28:03 <ksf> pyry`, you can use the same-named stuff from Data.ByteString.Lazy
15:28:18 <keep_learning> rasfar,  No I haven't tried rseq because I have to evaluate the whole list
15:28:35 <keep_learning> rasfar, let me try this
15:29:01 <rasfar> right, okay -- i thought maybe the "deep" part was, forcing evaluation of the elements
15:29:55 <rasfar> if anyone knows Control.Parallel.Strategies, we're talking about http://hpaste.org/67119
15:30:44 <ksf> rasfar, threadscope is your friend.
15:31:37 <rasfar> keep_learning: ksf says "threadscope is your friend" ;)  -- although i'll keep it in mind when i get a bigger and badder netbook
15:32:17 <keep_learning> rasfar, ksf Thank you both.
15:32:33 <ksf> oh. and if you only got eight *threads* as opposed to cores you might want to try with four.
15:33:02 <ksf> at least as far as intel is concerned a thread is merely a insn decoder and dispatcher, it doesn't actually make stuff faster...
15:34:19 <Luke> ski: how does this foldable mapM work on await? does it have infinite list semantics or something?
15:36:24 <ski> Luke : `mapM_ _ Nothing = return (); mapM_ f (Just a) = f a'
15:37:15 <ski> i.e. basically the same as your original `case csvRow of Nothing -> return (); Just row -> ..row..', it's just that tedious boiler-plate was hidden behind the `mapM_'/`forM_' call
15:40:04 <ksf> ski, maybe is a functor, too.
15:40:19 <ski> yes ?
15:40:24 <ksf> that is, mapM is overkill, use fmap
15:40:26 <Luke> ski: oh gotcha - this doesn't operate on a list, but a foldable
15:40:31 <Luke> ooh ok cool
15:40:31 <Luke> thanks
15:40:38 <ski> ksf : doesn't do the same thing as `mapM_'
15:40:41 <verement> shouldn't the second equation be `mapM_ f (Just a) = f a >> return ()' or something?
15:40:57 <ski> (nor does it do the same thing as `mapM')
15:41:28 <ski> @type fmap (\s -> putStrLn s)
15:41:29 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f (IO ())
15:41:38 <magicman> :t mapM_
15:41:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:41:46 <ski> @type Data.Foldable.mapM_ (\s -> putStrLn s)
15:41:47 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t String -> IO ()
15:41:47 <magicman> :t Data.Foldable.mapM_
15:41:48 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
15:41:59 <ski> @type Data.Traversable.mapM (\s -> putStrLn s)
15:42:00 <lambdabot> forall (t :: * -> *). (Data.Traversable.Traversable t) => t String -> IO (t ())
15:42:09 <ksf> hmmm yes. and no sequence_ in sight.
15:42:17 <ksf> @hoogle sequence_
15:42:17 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
15:42:18 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
15:42:18 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
15:42:24 * ski nods
15:42:56 <ksf> but you could use the prelude sequence and fmap and not depend on Foldable.
15:43:12 <ski> no
15:43:22 <ksf> @instances Maybe
15:43:23 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
15:43:27 <ski> `Prelude.sequence' only works on lists
15:43:59 <ksf> yes. that's what maybetolist is for :)
15:44:02 <ski> @instances-importing Data.Foldable Data.Traversable Maybe
15:44:03 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
15:44:17 <ski> @instances-importing Data.Foldable Data.Traversable Foldable
15:44:18 <lambdabot> Maybe, []
15:44:22 <ski> @instances-importing Data.Foldable Data.Traversable Traversable
15:44:22 <lambdabot> Maybe, []
15:44:32 <ski> ksf : yeah, you could do that
15:45:40 <elliott> ksf: So depend on Data.Maybe instead?
15:46:05 <ksf> that's H98/H2010
15:46:19 <ksf> well, foldable is in base, too.
15:46:23 <elliott> ksf: It's all in base.
15:46:33 <elliott> Control.Applicative isn't defined by Haskell 2010 either, but that doesn't mean it's unportable.
15:46:39 <elliott> It's perfectly-portable library code.
15:46:41 <elliott> As is Foldable.
15:47:21 <ksf> as long as you're not using import Maybe alongside with base modules there's nothing to complain.
15:47:36 <ksf> using haskell98 and base finally broke with ghc 7.4.2
15:47:39 <ksf> err .1
15:47:48 <ski>   processCsvConduit = (await >>=) . (. maybeToList) . fmap $ \row -> do ..row..
15:47:49 <ski> vs.
15:47:56 <ski>   processCsvConduit = ((await >>=) . mapM_) $ \row -> do ..row..
15:48:34 <elliott> ksf: Exactly; there's as little to complain about as there is with a Data.Foldable "dependency"...
15:48:37 <hpaste_> “Nicolas Frisby (@0nifr)” pasted “faking universal quantification in constraints” at http://hpaste.org/67121
15:48:53 <elliott> I think Foldable might even be in base 2, so it'd work on Hugs. But don't quote me on that.
15:50:15 <ksf> speaking of hugs, an up to date haskell interpreter would be a great thing to have.
15:50:15 <ski> > logBase 2 "Foldable"
15:50:16 <lambdabot>   No instance for (GHC.Float.Floating [GHC.Types.Char])
15:50:16 <lambdabot>    arising from a use...
15:50:39 <ksf> as it is, things like hint aren't really made for embedding a scripting language.
15:53:30 <mm_freak> i'd love to have an embeddable Agda type checker and evaluator
15:53:46 <mm_freak> that would make a great scripting language for haskell programs
15:54:10 <elliott> @remember mm_freak <mm_freak> i'd love to have an embeddable Agda type checker and evaluator  <mm_freak> that would make a great scripting language for haskell programs
15:54:11 <lambdabot> Good to know.
15:54:16 <ion> :-)
15:54:32 <elliott> mm_freak: it's written in Haskell
15:54:34 <ksf> I was rather thinking of haskell plus type-family ducktypes minus monomorphism restriction plus ghci defaulting.
15:54:38 <elliott> and works as a library
15:54:39 <elliott> so you could!
15:54:43 * hackagebot scotty 0.4.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.0 (AndrewFarmer)
15:54:44 <elliott> ksf: "type-family ducktypes"?
15:55:09 <mm_freak> elliott: i tried
15:55:18 <mm_freak> the library is really made for the emacs mode and the executable
15:55:23 <ksf> class Num a b where;    type NumCo a b :: *;    (+) :: a -> b -> NumCo a b
15:55:30 <elliott> ksf: disgusting
15:55:54 <mm_freak> it's extraordinarily difficult to get it to work
15:56:21 * ski wonders who here is "Nicolas Frisby (@0nifr)"
15:56:34 <ksf> uhc might be faster to get up to speed, there.
15:58:40 <ski> @unquote
15:58:40 <lambdabot> Badger says: one does not simply >>= into mordor
15:59:59 <ion> @donquijote
16:00:00 <lambdabot> Unknown command, try @list
16:00:03 <ion> @quijote
16:00:03 <lambdabot> troll says: #haskell
16:00:15 <elliott> thanks troll
16:00:20 <elliott> @forget troll #haskell
16:00:20 <lambdabot> Done.
16:00:43 <elliott> ski: I think @unquote should remove a quote at random
16:00:53 <ski> to whomever "Nicolas Frisby (@0nifr)" is : i suspect it will work just fine in current implementations at least .. but you might want to ask about it on the mailing list
16:00:55 <elliott> or, @quote name \n ... \n @unquote should quote everything anybody says in the ...
16:01:12 <ski> however, in a type-passing implementation, it would probably not work fine
16:01:28 <ion> @@ @remember lambdabot @quote
16:01:28 <lambdabot>  Good to know.
16:01:31 <ski> (i'm not sure whether jhc would qualify here, e.g.)
16:01:45 <mm_freak> @quote agda
16:01:45 <lambdabot> dpiponi says: Agda's worse than video game. I keep thinking "I'll just eliminate one more case from my theorem and then do something else..."
16:01:46 <ski> elliott : surely also stating the quote it removes :)
16:01:53 <ion> @quote lambdabot
16:01:54 <lambdabot> lambdabot says: I CAN HAS CHEEZBURGER?
16:02:06 <mm_freak> @quote agda
16:02:06 <lambdabot> cmccann says: someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
16:02:07 <elliott> ski: no, it should be a mystery :)
16:02:14 <mm_freak> lol
16:02:19 <elliott> <ion> @@ @remember lambdabot @quote
16:02:19 <elliott> :D
16:02:21 <ski> ion :)
16:02:39 <ski> @remember ion @@ @remember lambdabot @quote
16:02:39 <lambdabot> It is stored.
16:02:42 <mm_freak> ICANN HAS .cheeseburger?
16:02:43 * elliott wonders what code ski is talking about
16:02:52 <elliott> @remember mm_freak ICANN HAS .cheeseburger?
16:02:52 <lambdabot> I will never forget.
16:03:42 <ion> @quote lambdabot says
16:03:43 <lambdabot> lambdabot says: lambdabot says:  lambdabot hasn't said anything memorable
16:03:48 <ski> elliott : the one one hpaste_ said one "Nicolas Frisby (@0nifr)" pasted above at <http://hpaste.org/67121>, with title "faking universal quantification in constraints"
16:04:13 <Saizan> i don't quite see the point of the class though
16:04:33 <elliott> ski: well, that looks like someone hpasting it to put it on e.g. twitter
16:04:37 <elliott> (given the @handle)
16:04:41 <elliott> weird to set the channel though
16:05:22 <mm_freak> Mucat:  I CAN HAS BURGER (BURGER (BURGER (BURGER (BURGER (BURGER …
16:05:42 <elliott> ski: hehe, that's wacky
16:05:49 <elliott> i like it!
16:06:00 <Saizan> ah, i see that Forall_S con => is a bit nicer than (forall a. Dict (con a)) ->
16:06:44 <ski> Saizan : instead of stating a constraint `forall a. Foo a' (in a type signature, or in an `instance' or `class' context) (which is currently not allowed), you'd state `Forall_S Foo' as the contraint
16:06:46 <Saizan> or con Skolem
16:08:07 <shachaf> Help! I'm doing multiple unsafeCoerces and unsafePerformIOs and the equivalent of pointer comparison, and -O changes the behavior of my code.
16:08:18 <shachaf> That makes it a GHC bug, right?!?
16:08:25 <ski> istr edwardk had something which you could use to express contraints like `forall a. Foo a => Bar a' with, as well
16:08:26 <rwbarton> unsafeGhc
16:08:32 <mauke> ghc -funsafe
16:08:46 <shachaf> You can't spell "-funsafe" without "fun" and "safe".
16:08:50 <mm_freak> ski: do you mean the Exists type?
16:09:41 <ski> mm_freak : no, there was a paste maybe a week ago or something with `(:-) :: (* -> Constraint) -> (* -> Constraint) -> (* -> Constraint)', iirc
16:09:59 <mm_freak> oh
16:10:21 * ski doesn't recall the details, and can't find the paste atm
16:10:36 <mm_freak> what would that do?  require an instance given another instance?
16:10:50 <elliott> @remember shachaf You can't spell "-funsafe" without "fun" and "safe".
16:10:51 <lambdabot> It is stored.
16:11:15 <ski> shachaf : well, are you only using `unsafeCoerce' to convert between equal types, and `unsafePerformIO' on arguments which (semantically/behaviourally) is euqal to `return a' for some `a' ?
16:11:35 <shachaf> ski: The unsafeCoerce should be OK.
16:11:38 <Saizan> i think :- was a datatype
16:11:40 * ski suspects the pointer comparision might be bad
16:11:44 <shachaf> Actually, I don't think anything is being broken.
16:11:48 <ski> Saizan : could have been
16:11:57 <shachaf> In fact, without -O it just computes the same value multiple times.
16:12:02 <shachaf> With -O it only computes it once.
16:12:10 <shachaf> That means I wrote code that respects -O!
16:12:11 <ski> that sounds ok, to me
16:12:25 <shachaf> Right.
16:12:43 <ski> (assuming the value, once computed, is short-lived, or doesn't take up much space)
16:17:20 <mm_freak> can i constrain the GHC version in my cabal file?
16:18:04 <elliott> mm_freak: sure
16:18:14 <elliott> if impl(ghc <= ...) buildable: False
16:18:30 <shachaf> Why doesn't this print anything?
16:18:32 <shachaf> data Hi = Hi
16:18:54 <shachaf> instance Show Hi where show = trace "trace" `seq` \_ -> "hi"
16:19:32 <shachaf> Oh, wait.
16:19:47 <shachaf> It's because I was being silly and misusing trace.
16:20:21 <elliott> Oh, duh.
16:20:22 <elliott> I was wondering.
16:21:01 <Eduard_Munteanu> You probably want    "trace" `trace` "hi"    or something like that
16:21:25 <Eduard_Munteanu> Well, along with   show _
16:21:28 <pyry`> i like the maniacal feeling that comes from learning small things in haskell
16:21:31 * ski wonders what mischaf shacheaf is up to
16:21:36 <shachaf> Eduard_Munteanu: Right, show = trace "trace" (\_ -> "hi")
16:21:36 <elliott> Eduard_Munteanu: He means trace "trace" (\_ -> "hi")
16:21:37 <Eduard_Munteanu> Heh.
16:21:43 <pyry`> now i understand why learnyouahaskell has examples involving fire the missiles
16:21:45 <Eduard_Munteanu> Or that, yeah.
16:21:45 <elliott> ski: http://stackoverflow.com/questions/10168939/laziness-and-polymorphic-values
16:21:54 <elliott> pyry`: That's actually a running joke in the Haskell community.
16:22:00 <elliott> (SPJ said it once.)
16:22:14 <pyry`> ahhh, how'd it develop?
16:22:27 <Phlogistique> is there a 'string buffer' monad out there?
16:22:45 <sipa> Phlogistique: what would it do?
16:22:46 <Eduard_Munteanu> Dunno, it was probably said to emphasize the unsafe in unsafeLaunchMissiles.
16:22:48 <elliott> Phlogistique: Writer? not sure why you'd want that. take a look at blaze-builder perhaps?
16:22:49 <ion> instance Show Hi where show = trace "trace" 42 `seq` \_ -> "hi"
16:22:50 <elliott> @where blaze-builder
16:22:50 <lambdabot> I know nothing about blaze-builder.
16:22:52 <elliott> ugh
16:22:54 <elliott> @hackage blaze-builder
16:22:54 <lambdabot> http://hackage.haskell.org/package/blaze-builder
16:22:55 <c_wraith> Phlogistique: you want Builders?
16:22:59 <shachaf> ion: Also works.
16:23:04 <Phlogistique> sipa: like IO, but in a string
16:23:06 <rwbarton> or the Put monad
16:23:14 <elliott> that's for ByteString though
16:23:16 <Phlogistique> elliott: I'll look at that
16:23:16 <rwbarton> yes
16:23:20 <elliott> Phlogistique: like IO, but in a string??
16:23:20 <rwbarton> is blaze-builder not?
16:23:26 <elliott> rwbarton: I was talking about blaze-builder
16:23:30 <ski> @quote delliott
16:23:30 <lambdabot> shachaf says: * shachaf = delliott/dt
16:23:35 <rwbarton> oh
16:23:55 <Phlogistique> no, I want something more abstract than blaze-builder
16:24:19 <Phlogistique> well, I'll do it myself, I just wanted to confirm that there is no obvious out-the-shelf solution
16:24:20 <Eduard_Munteanu> Are you calling elliott primitive? :P
16:24:27 <delliott> -NickServ- This nickname is registered. Please choose a different nickname, or identify via /msg NickServ identify <password>.
16:24:38 <elliott> I wonder how many people get disappointed that "elliott" is registered per year
16:24:42 <Phlogistique> I'm not sure what the Writer monad does. I'll take a look
16:24:51 <elliott> more abstract than blaze-builder howso?
16:24:53 <elliott> Writer works for any monoid
16:25:02 <elliott> it isn't nearly as efficient as blaze-builder though
16:25:08 <mm_freak> thanks
16:25:10 <elliott> (you probably want to use Writer with DList if you want to build a String)
16:25:21 <elliott> mm_freak: thanks?
16:25:28 <elliott> @where ops
16:25:28 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
16:25:34 <elliott> that cho94-8-88-178-12-119.fbx.proxad.net bot keeps joining and quitting with different names
16:25:45 <copumpkin> hmm
16:25:45 <elliott> it's happening in multiple channels (with different IPs I think)
16:26:05 <elliott> (it was excess flooding in another channel lately... seems to be a bit slower now)
16:26:18 <copumpkin> nothing fundamentally wrong with it if it isn't very frequent
16:26:22 <copumpkin> I'll keep an eye on it though
16:26:38 <Eduard_Munteanu> What's happening? oO
16:26:45 <elliott> yeah, just letting you know it's probably not going to stop :p
16:26:50 <elliott> Eduard_Munteanu: some mysterious bot
16:27:02 * elliott @where ops'd on instinct after seeing it quit before realising it wasn't from flooding
16:28:03 <rgr> from learnyouahaskell  I see [1,2,3] is just syntactic sugar for 1:2:3:[]  .. in this case why is 'a':'b':[] not valid as a longer winded  ['a','b'] or "ab" ?
16:28:10 <elliott> it uh
16:28:11 <elliott> it is
16:28:14 <elliott> > 'a':'b':[]
16:28:15 <lambdabot>   "ab"
16:28:26 <monoidal> > ['a','b']
16:28:27 <lambdabot>   "ab"
16:28:50 <ion> > "ab"
16:28:51 <Eduard_Munteanu> Maybe you tried "a":"b":[]
16:28:51 <lambdabot>   "ab"
16:28:58 <Eduard_Munteanu> > "a":"b":[]
16:28:58 <lambdabot>   ["a","b"]
16:29:00 <rgr> but not when calling length? What am I missing?
16:29:08 <monoidal> operator priority
16:29:16 <geekosaur> parentheses, I suspect
16:29:17 <monoidal> > length ('a':'b':[])
16:29:18 <lambdabot>   2
16:29:28 <rgr> oh ffs, of course. sorry for wasting your time.
16:29:38 <Eduard_Munteanu> Function application binds the tightest.
16:29:41 <hpaste_> tgeeky pasted “list of things you'd find in your ideal haskell-platform” at http://hpaste.org/67124
16:30:06 <ion> edwardk's integration package?
16:30:25 <elliott> edwardk has an integration package?
16:30:29 <elliott> Oh!
16:30:30 <elliott> For integration.
16:30:35 <elliott> Not a package that integrates all his other integration packages.
16:30:42 <edwardk> it just has tanh-sinh quadrature
16:30:43 <ski> rgr :  length 'a':'b':[]  will be interpreted as  (length 'a'):'b':[]
16:30:43 <tgeeky> elliott: no, like the opposite of ad
16:30:46 <elliott> Erm.
16:30:48 <elliott> *Not a package that integrates all his other packages.
16:30:58 <tgeeky> that is a list of things I'd like to find in my haskell-platform, along with the things that I find anyway (like it or not) in my haskell-platform. PLEASE ADD!
16:31:00 <elliott> tgeeky: I don't think "the opposite of AD" makes much sense.
16:31:10 <Eduard_Munteanu> Mm, there should be a metapackage for his categories stuff.
16:31:23 <Eduard_Munteanu> A-la category-extras.
16:31:35 <tgeeky> guys, please add things to the list that you would want. Please categorize them, too, if you can.
16:31:36 <monoidal> you can integrate automatically ala seemingly impossible functional programs, but it is unlike AD
16:31:58 <ski> monoidal : you can ?
16:32:18 <monoidal> ski: http://conal.net/blog/posts/exact-numeric-integration
16:32:29 <ski> monoidal : interesting, ty
16:32:30 <elliott> monoidal: oh, hey, are you the author of that proofs-below-values post?
16:32:33 <tgeeky> to #haskell, the key difference between this list and the current haskell-platform list, is that this list has the "why" it's included
16:32:34 <monoidal> yes
16:32:45 <elliott> monoidal: did you see the discussion in the logs?
16:32:57 <edwardk> ski: yeah there is a really nice paper on the topic
16:33:02 <monoidal> IRC logs? will check
16:33:08 <elliott> monoidal: http://tunes.org/~nef/logs/haskell/12.04.16
16:33:10 <elliott> monoidal: grep for 12:17:38 <ezyang> http://monoidal.blogspot.com/2012/04/descending-level-ladder.html <-- I'm a bit confused, I thought values and proofs were the same thing
16:33:27 <elliott> (It was a pretty short discussion.)
16:33:36 <ski> edwardk : mentioned in that conal blag or elsewhere ?
16:34:34 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.395&rep=rep1&type=pdf
16:34:42 <edwardk> mentioned here, now ;)
16:34:54 <tgeeky> edwardk: what's the name of the package, so I can fix it
16:35:16 <edwardk> tgeeky: which? integration?
16:35:33 <elliott> tgeeky: Is this list going to be actually used for anything?
16:35:50 <elliott> By the way, I find the inclusion of a package named "colour" in a section titled "Color" offensive :)
16:36:16 * elliott does not see zeroth as remotely important enough for the Platform.
16:36:29 <ski> zeroth ?
16:36:41 <luite_> edwardk: obviously he still needs to convince you to write or finish it ;)
16:37:14 <ion> @remember elliott By the way, I find the inclusion of a package named "colour" in a section titled "Color" offensive :)
16:37:14 <lambdabot> Okay.
16:37:18 <kallisti> > let f = const True in map f [False, True]
16:37:19 <lambdabot>   [True,True]
16:37:22 <edwardk> luite_: i've had enough requests for an edwardk package that I'm thinking about it ;)
16:37:25 <kallisti> totally monotonic!!
16:37:30 <tgeeky> elliott: yes, it's going to be used for my continuious integration/buildbot/self-building haskell-platform 2.0 thingmajigger
16:37:30 <kallisti> radical.
16:37:46 <elliott> tgeeky: is that anything official?
16:37:48 <tgeeky> elliott: this list, along with packages which have a high degree of reverse deps, will be included
16:37:52 <edwardk> elliott: hah. i have a colorimetry package that is colour on steroids that should be going up soon
16:37:58 <tgeeky> elliott: no, but hopefully if it's released more regularly than the platform, it will be
16:38:04 <luite_> edwardk: cool!
16:38:08 * elliott doubts it
16:38:19 <lcfrs> would any javascript-savvy haskellers be so kind as to proofread my Arrows port to coffeescript?
16:38:20 <elliott> the Platform is nice because it gets a lot of human attention and is always stable
16:38:31 <luite_> edwardk: does it let you work with custom spectral power distributions?
16:38:35 <elliott> people who want to live on the bleeding edge are fine with cabal (well, as fine as anyone is with cabal)
16:38:39 <Phlogistique> @hoogle (a -> c) -> (,) a b -> (,) c b
16:38:40 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
16:38:40 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:38:40 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
16:38:43 <elliott> edwardk: call it "color" for maximum confusing
16:38:45 <tgeeky> elliott: i don't mean that kind of continuous
16:38:45 <elliott> *confusion
16:38:52 <elliott> edwardk: (please don't)
16:38:55 <tgeeky> elliott: and the goal is essentially to remove the human part
16:38:55 <elliott> tgeeky: didn't say you did :)
16:39:00 <elliott> right, exactly
16:39:13 <monoidal> elliott: Hm. I didn't thought a lot about what is the underlying logic - "inhabited" was rather a guiding intuition
16:39:23 <tgeeky> elliott: I'm going to try to implement the metrics (which are rudimentary) in the book "Code Simplicity"
16:39:41 <tgeeky> elliott: and try to see if I can 'detect stability' using them, and decide when to increment versions, using them
16:39:53 <monoidal> elliott: If we have a type data Equal a b where Eq :: Equal a a, then a _value_ Eq works as a proof of a statement about types.
16:39:56 <ion> “$foo with site enhancement oil” is even more awesome than “$foo on steroids”.
16:39:57 <edwardk> luite_: yes, and has photopic and scotopic response curves, the recent SPJS cone data so you can model non-standard colorblind observers, and a bunch of stock illuminants
16:40:02 <elliott> monoidal: well, I didn't really understand the post
16:40:16 <tgeeky> edwardk: what is wrong with you
16:40:17 <luite_> edwardk: ah that's quite a bit of steroids :)
16:40:28 <tgeeky> edwardk: I wouldn't even know if half those words were made up
16:40:30 <edwardk> luite: i'd been fiddling with adding icc profile loading
16:40:32 <elliott> edwardk: I've always wanted to model non-standard colourblind observers.
16:40:57 <tgeeky> elliott: you know, just the other day I woke up, wondering what the world would be like through the eyes of non-standard colorblind observers.
16:41:30 <elliott> I don't think Haskell can ever hope to enter the enterprise if we can't model non-standard colourblind observers with it.
16:41:49 <ion> @remember elliott I don't think Haskell can ever hope to enter the enterprise if we can't model non-standard colourblind observers with it.
16:41:50 <lambdabot> Done.
16:42:22 <edwardk> luite_: basically what i have are observers, illuminants, color working spaces and photopic/scotopic responses
16:42:42 <tgeeky> edwardk: see your collection "Color Space and its Divisions"
16:42:44 <edwardk> elliott: it was mostly a target of opportunity.
16:42:56 <elliott> edwardk: i'm just kidding around, it sounds v. interesting :)
16:42:58 <monoidal> elliott: I will try to be simple. I have added a new level, below values. We cannot observe it in Haskell, since values are the lowest. So we simulate them, by shifting up every level in the universe. Values become types, types become kinds etc. As in the initial example where type level computation worked as value level computation.
16:43:33 <elliott> monoidal: Sure, but you haven't really explained what that level is :)
16:43:43 <elliott> You've said something about Eq, but Eq is a value.
16:43:50 <luite_> edwardk: right, are your working spaces the usual XYZ, Lab and various RGB spaces, or something more fancy?
16:43:53 <edwardk> elliott: the fact that it can model protanopic/deuteranopic observers, etc. was a nice bonus
16:43:57 <tgeeky> elliott: I think the difference between edwardk and us is -- he has a severe FILO queue in his head because of ADD, bue he can code so fucking fast that, every once in a while, a package pops out
16:44:28 <monoidal> elliott: The value Eq (assuming Eq :: Equal a a) is a value in shifted up universe. It is a witness of type equality.
16:44:29 <edwardk> luite_: right now just those. sadly i can't get enough information on the actual location of the peaks for different monitors to do anything more accurate.
16:44:41 <elliott> monoidal: It's a value in the non-shifted universe too.
16:44:53 <elliott> If you are saying it represents something in the non-shifted universe, what is the thing it represents?
16:45:24 <tgeeky> edwardk: seriously though. good book. great diagrams and notes. "Color Space and its Divisions"
16:45:39 <monoidal> elliott: Let's call this Eq'. Eq' is an entity which is a level lower than values. So it is typed by values, just like types are typed by kinds.
16:45:40 <luite_> edwardk: hmm, you mean computer monitors?
16:45:59 <elliott> monoidal: Huh?
16:46:01 <elliott> Let's call what Eq'?
16:46:39 <monoidal> elliott: We can define data Equal a b where Eq :: Equal a a. This is a normal Haskell definition.
16:46:44 <elliott> Yes, I got that much.
16:46:45 <edwardk> luite_: yeah. i'd like to have a better estimate of what the actual wavelengths i'll get out of a monitor will look like for a R G and B, rather than faking it with tristimulus equivalents
16:47:32 <luite_> edwardk: ah right, usual icc profiles only have the location of the primaries in Lab or XYZ space :(
16:47:37 <monoidal> elliott: With a powerful kind system (for example, Omega has one), you can define kind Equal2 a b  where Eq2 :: Equal2 a a. This defines a new kind Equal2 and a new type Eq2.
16:47:37 <edwardk> thats something that of course varies from manufacturing process to manufacturing process
16:47:49 <edwardk> luite_: exactly. and they don't have a place to dump all that extra data
16:47:51 <monoidal> elliott: This is a GADK.
16:47:55 <ski> (monoidal : .. i assume you know that with `data Equal {A : Set} (a : A) : A -> Set where Refl :: Equal a a' in Agda2, `Refl' would be a witness of value equality)
16:47:55 <elliott> monoidal: You can do that in Haskell too with DataKinds, but yes, I understand that as well.
16:48:08 <edwardk> luite_: right now i just have sRGB and a couple of other boring working spaces
16:48:09 <Veinor> i wonder if it'd be beneficial to make some kind of virthualenv-like wrapper on top of cabal-dev
16:48:27 <monoidal> So, Equal2 is completely analogous to Equal, only a level higher. Let Equal' be completely analogous to Equal, only a level lower.
16:48:28 <Veinor> so that you can say 'cabal-dev sandbox ~/sandboxes/foo' and then everything automatically gets --sandbox=~/sandboxes/foo
16:48:38 <monoidal> elliott: ^
16:49:02 <elliott> monoidal: Okay, so you're not saying that Haskell *does* have such below-values things, you're just saying that it *could*?
16:49:09 <monoidal> elliott: Yes.
16:49:37 <monoidal> elliott: I think more, it *should*.
16:49:43 <elliott> Well... okay. That seems fairly obvious to me; perhaps less so if you're not aware of dependently-typed languges which *do* have such a uniform hierarchy of values -> types -> kinds -> sorts -> ...
16:49:50 <elliott> I don't see what the point is, though.
16:50:15 <elliott> But, FWIW, your post very strongly implies that Haskell *does* have such a level.
16:50:17 <Saizan> Veinor: there are virtual-env-like things on hackage btw, not sure how they'd interact with cabal-dev though
16:50:23 <elliott> Which is why we were so confused by it.
16:51:04 <ski> monoidal : i once pondered something a bit like what you're thinking about -- only that instead of the "value level", i had logic programming goals, and then i had proofs of those on the level below
16:51:08 <edwardk> anyways i left off any concern about spectroscopy/reflection, beyond say conversions from dumb RGB values to approximate spectral density curves in a manner similar to how PBRT converts them.
16:51:13 <ski> s/you're/you seem to be/
16:52:07 <Philippa> elliott: that's not what sorts are
16:52:14 <edwardk> but my main concern is that i really want the ability to take derivatives of the various curves with respect to wavelength, which means I need to provide nice cubic interpolation
16:52:22 <monoidal> elliott: This might be confusing, I agree. But I find the extension to proofs very natural, more than dependent types (which allow types to depend on values)
16:52:41 * ski was tempted to comment on "sorts" as well ..
16:52:43 <monoidal> Philippa: I think it depends on terminology, Omega uses the word 'sorts'
16:52:56 <luite_> edwardk: ah, i have no idea how pbrt does that, never worked with it
16:53:00 <Philippa> yeah, but Omega is thoroughly non-standard in its usage
16:53:12 <elliott> I've seen other things use "sort" for the level above kinds, too.
16:53:26 <elliott> I know it's often used to refer to {values, types, kinds, ...} itself.
16:53:31 <ski> (in some accounts of logic, "sort" basically means "type", so a many-sorted logic is basically a logic with more than one type)
16:53:38 <luite_> edwardk: is there some standard?
16:53:40 <edwardk> and i want to do something approximately correct for wavelengths beyond the visible spectrum. even if its just blending with a linear combination of blackbody illuminant curves
16:53:56 <Philippa> ski: true. Still not the usual definition in the context of type systems though
16:54:01 * ski nods
16:54:24 <edwardk> luite_: not sure. PBRT uses a model involving several reflectants and illuminants for different colors and interpolating
16:54:39 <monoidal> What I find unnatural about dependent types is that values and types seem to be mixed: you can have a Vector Int 5. That 5 seems to be a value, and values should not influence types.
16:54:43 <Philippa> elliott: it's really not a good idea to use that usage as if it's standard, anyway
16:54:53 <edwardk> luite: which yields much better answers than of course just blending R G and B lights
16:55:22 <monoidal> In my post, I have a language with similar reasoning abilities, but the level distinction is completely retained.
16:55:25 <ski> monoidal : well, how about the set `{n : |N | n < m}' in math ?
16:55:36 <elliott> Philippa: do you have a better name for the level above kinds?
16:55:36 <geekosaur> monoidal, that is exactly what they are, and it's about as unnatural as imaginary numbers or negative numbers, etc., i.e. as unnatural as the beholder's inability to stretch
16:55:37 <luite_> right, although the latter might be more correct if your source is actually a screen (especially if it's the new RED laser projector) :)
16:55:38 <ski> monoidal : here `m' is also a value, not a type, e.g. it could be `5'
16:55:45 <edwardk> sure
16:55:47 <edwardk> =)
16:55:58 <elliott> <monoidal> What I find unnatural about dependent types is that values and types seem to be mixed: you can have a Vector Int 5. That 5 seems to be a value, and values should not influence types.
16:56:08 <elliott> why not? we have types influencing types, values influencing values, and types influencing values (typeclasses)
16:56:11 <Philippa> elliott: There isn't a single "the level above kinds", although "universe" is common and useful
16:56:43 <elliott> monoidal: actually with dependently-typed languages, it's not even values influencing types per se; it's just that types become normal values, of type Type
16:56:50 <elliott> (and then Type is of type Type[1], Type[1] is of type Type[2], etc.)
16:57:03 <elliott> Vector is just a function of type Type -> Int -> Type or such
16:57:07 <monoidal> ski: I agree this might be a type. But it is not in a non-dependently-typed language in this mindset.
16:57:18 <Philippa> ...elliott, you're not even /trying/ to use consistent terminology now, are you?
16:57:30 <Philippa> (hint: beta-normalisation isn't inherently "evaluation")
16:57:42 <elliott> err, when did I say anything about evaluation?
16:57:53 <edwardk> luite: hrmm, 9334x7000 resolution. even I may have trouble filling that many pixels ;)
16:58:00 <monoidal> elliott: I find natural that a level A can influcence B if A >= B.  So a value can depend on a type, but not conversely.
16:58:21 <Philippa> elliott: it's implicit in "value" there
16:58:23 <elliott> well, we can already have types depending on values in GHC today
16:58:30 <mm_freak> elliott: for your help
16:58:36 <elliott> Philippa: err, I disagree
16:58:38 <ski> monoidal : if i understand you correctly, i think you don't like `Vector Int 5', since this is a type, but `5' is a value, while otoh `exists n : |N. perfectNumber n /\ odd n' would be fine even though `n' is a value, since this whole thing isn't a type (it's a proposition, and it has proofs, not values)
16:59:16 <Philippa> "types become normal values" - evaluation is "the process of turning something into a value"
16:59:26 <elliott> Philippa: no, I meant that in a dependently-typed language, types become normal values
16:59:31 <Philippa> yeah, but they don't
16:59:31 <elliott> compared to a non-dependent language
16:59:35 <elliott> no, compared to a non-dependent language
16:59:37 <monoidal> ski: Yes. In the terminology from the post, `exists n : |N. perfectNumber n /\ odd n' is a value, and you could write a proof.
16:59:37 <elliott> as in:
16:59:40 <elliott> haskell: types are not normal values
16:59:43 <Philippa> as in asspull, elliott
16:59:43 <elliott> agda: types are normal values
16:59:53 <elliott> wtf? that's what I meant, and what I said
16:59:54 <Philippa> types are not "normal values" unless you redefine what it is to be a value
16:59:58 <ski> monoidal : "I agree this might be a type. But it is not in a non-dependently-typed language in this mindset." -- "this" referring to `5' ? what is "it" ?
17:00:17 <elliott> you're seriously saying that types are not values in dependently-typed languages?
17:00:23 <Philippa> yes, I am
17:00:28 <monoidal> ski: "it" = Vector Int 5
17:00:35 <Philippa> that's a common myth, in fact
17:00:49 <Philippa> "dependently typed" means that types /contain/ values/things from the value level
17:00:51 <ski> monoidal : "But is not" -- is not what ? a type ?
17:00:54 <byorgey> elliott: what's your definition of "value"?
17:00:57 <byorgey> everything hinges on this.
17:01:01 <Eduard_Munteanu> I guess it depends what a value is in that particular context. Types can be values there.
17:01:21 <hpc> types and values are both first-class, if that's your definition
17:01:26 <byorgey> everyone always throws that word around like it's obvoius what it means. but then everyone has a different idea of what it means.
17:01:28 <elliott> byorgey: agreed -- values are things terms reduce to
17:01:28 <monoidal> ski: It is invalid syntax without dependent types, unless 5 is lifted (defined on type level as well)
17:01:32 <Philippa> hpc: ...no
17:01:33 <Eduard_Munteanu> Values as members, for instance.
17:01:43 <ski> monoidal : ok
17:01:44 <elliott> as i was saying,
17:01:44 <elliott> <elliott> well, we can already have types depending on values in GHC today
17:01:45 <ski> monoidal : example of "So a value can depend on a type, but not conversely." ?
17:01:46 <elliott> monoidal: with e.g.
17:01:47 <hpc> Philippa: eh?
17:01:48 <Philippa> the "STLC + dependent typing" corner of the lambda cube in no sense has "first class types"
17:01:59 <elliott> monoidal: withNat :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
17:02:02 <elliott> given data Z; data S n; class Nat
17:02:03 <hpc> ah
17:02:10 <elliott> instance Nat Z; instance (Nat n) => Nat (S n)
17:02:14 <monoidal> ski: type classes are in some sense functions from types to values
17:02:26 <elliott> Philippa: ok, s/in dependently-typed languages/in common dependently-typed languages/ or /in Coq\/Agda/
17:02:27 <Philippa> elliott: term is also overloaded
17:02:33 <elliott> everything's overloaded
17:02:39 <byorgey> elliott: so then, what are "terms"?  Note that some dependently typed languages collapse everything onto one syntax of "terms" and some don't.
17:02:44 <Philippa> yeah, but term's overloaded in exactly the way you're trying to clear up
17:02:45 <Eduard_Munteanu> I think he means the whole infinite tower of types, not just dependent types bolted onto the STLC.
17:02:50 <mm_freak> elliott: types depending on values in GHC?  how?
17:02:56 <elliott> mm_freak: consider withNat :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
17:02:59 <elliott> mm_freak: or the reflection package
17:03:07 <elliott> indeed, reflection gives you more or less exactly a restricted form of dependent-typing
17:03:07 <mm_freak> elliott: still types
17:03:17 <elliott> eh?
17:03:19 <Philippa> elliott: that substitution's an important distinction, yes
17:03:20 <mm_freak> i mean the types still depend on types
17:03:23 <elliott> the type "n" that withNat chooses depends on the value of the Integer
17:03:26 <elliott> that's a type depending on a value
17:03:39 <monoidal> but that integer is a type now, right?
17:03:42 <elliott> Philippa: right; I misunderstood what your complaint was
17:04:09 <mm_freak> elliott: you still can't have a Mod type with a value-level modulus
17:04:10 <Eduard_Munteanu> I guess you can call terms either of "urelements" or certain things, depending on which side of the typing relation you're looking at.
17:04:17 <Philippa> stops you getting confused about a lot of things - the rest of the 'first-classness' comes from parametric polymorphism and having type-level functions as well as value-level functions in types
17:04:29 <elliott> mm_freak: well, so? it's just an explicit lift
17:04:52 <Philippa> knowing that value-level functions in types are distinct from type-level functions matters, for example
17:05:10 <Eduard_Munteanu> As in, in 'x : A', x is a value of A and A is the type of x. But you can have 'A : Set' and A is a value of Set and so on.
17:05:48 <mm_freak> elliott: there is this weird codomain type in agda that depends on a function and the members belong to the codomain of that function…  how would you express this type in haskell?
17:05:57 <ski> monoidal : hm, ok -- but so are ordinary polymorphic operations then (especially ones which takes GADT things as input)
17:06:06 <mm_freak> the type is commonly called Image
17:06:09 <Philippa> Eduard_Munteanu: yep, usages get complicated. "Inhabitant" works too, but still
17:06:19 <Eduard_Munteanu> Or I guess you could only point at things like forall A : Set, x : A, x is a vlue.
17:06:19 <elliott> mm_freak: I didn't say Haskell was dependently-typed.
17:06:24 <Eduard_Munteanu> *value
17:06:24 <elliott> It doesn't go all the way.
17:06:24 <monoidal> ski: I don't understand
17:06:45 <elliott> But it does have types depending on values.
17:06:48 <mm_freak> elliott: what's the difference between "is a dependently typed language" and "has dependent types"?
17:06:57 <hpc> mm_freak: ooh, where is this in the agda stdlib?
17:07:03 <elliott> well, I never said Haskell has dependent types either :)
17:07:20 <mm_freak> elliott: what's a "type depending on values" then?
17:07:25 <Philippa> in Vector Int 5, 5 is still a value. It's a value that's a parameter to a type constructor
17:07:35 <mm_freak> hpc: i don't know, i read about it in the tutorial
17:08:00 <Philippa> which is to say, the type Vector Int 5 /depends/ on the value 5
17:08:16 <hpc> mm_freak: it sounds a bit like Σ
17:08:29 <Eduard_Munteanu> Hm, yeah.
17:08:34 <elliott> mm_freak: as I said, withNat :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
17:08:45 <elliott> mm_freak: choice of type n depends on value of Integer
17:08:49 <Eduard_Munteanu> You can't really do that in Haskell.
17:08:54 <elliott> reflection does that with any value
17:08:54 <hpc> a pair of (value in the codomain) + (value of domain you can pass to the function to get first value)
17:08:58 <monoidal> ski: We can think of "Ord" as a function taking type "x" and giving a value of type "x -> x -> Ordering". It needs to be explicitly declared, for example by pattern matching on types: Ord Int = compareInts etc.
17:09:01 <elliott> (except the types are opaque there; not so for withNat)
17:09:02 <Philippa> compare and contrast map <Int> (+1) [1,2,3] (where <Int> is type application)
17:09:02 <Eduard_Munteanu> Maybe if you squint at exponentials :/
17:09:03 <ski>   data Image {A B : Set} (f : A -> B) : B -> Set where Foo : (a : A) -> Image f (f a)  -- ?
17:09:04 * hpc -> #agda
17:09:05 <Eduard_Munteanu> Erm.
17:09:07 <Eduard_Munteanu> Existentials.
17:09:19 <mm_freak> elliott: haskell has higher rank types with constraints
17:09:46 <Philippa> yeah, and it now has constraints that are 'interesting'
17:09:58 <monoidal> ski: On the other hand, "id" is also dependent on typing, but notice we would write "Ord Int", but "id @Int". This is a different kind of application.
17:10:00 <Philippa> (which is to say, aren't elaborated away into dictionary types)
17:10:24 <Philippa> monoidal: application of a different /sort/, if we're being picky
17:10:35 <Philippa> (hence the distinction I called elliott out on)
17:10:46 <monoidal> well, I was not using technical meaning of kind or sort
17:10:51 * elliott just calls those "levels".
17:11:01 <Philippa> sure, but I was using sort technically to illustrate
17:11:18 <Philippa> elliott: they're not necessarily totally ordered
17:11:29 <Philippa> and I don't just mean because of dependent types
17:11:55 <Philippa> "levels" only really works well when they are
17:12:10 <Eduard_Munteanu> Mm, I think there are two notions of sorts too... either something above kinds, or Set levels. The latter is common in Agda, but I think I've heard the former too.
17:12:19 <ski> monoidal : yes, but you could imagine `data Foo :: * -> * where FooInt :: Foo Int; ...' with `fooOrd :: Foo a -> (a -> a -> Ordering); fooOrd FooInt = compareInt; ...'
17:12:26 <Philippa> Eduard_Munteanu: the latter isn't Set levels
17:12:43 <Philippa> it's something more powerful and nuanced than that
17:13:03 <ski> monoidal : i guess i was saying that there's maybe not so large a difference between `compare @Int' and `fooOrd FooInt'
17:13:06 <Philippa> read up on Pure Type Systems if you want to cover some more possibilities
17:13:17 <Philippa> ski: lambda cube time? :-)
17:13:19 <Eduard_Munteanu> Ah.
17:13:33 <mm_freak> i think i'd agree that GHC can emulate dependent types to the extent higher rank types allow, and we call that lightweight dependent types
17:13:42 <mm_freak> another approximation is existential types
17:13:44 <monoidal> ski: I think this is not that different from normal pattern matching. That FooInt is a value, and fooOrd behaves differently because it was given a different value, not a type
17:14:06 <monoidal> ski: of course that value FooInt serves as a proxy to give a type, but it is still a value
17:14:10 * ski thinks you all need to slow down a bit :)
17:14:39 <mm_freak> but none of those really give you "types depending on values"…  the resulting types don't depend on values…  it's just that the /choice/ of a non-dependent type depends on a value
17:15:42 <elliott> mm_freak: What if: withVectorOfSize :: Integer -> (forall v. (Vector v) => Proxy v -> r) -> r, where Vector had all the operations of a vector of a certain, finite size?
17:15:45 <Eduard_Munteanu> Mm... Vec A is a valid expression, for example.
17:15:54 <Eduard_Munteanu> Even if not fully applied.
17:15:56 <ski> monoidal : i agree with you -- i'm mererly trying to grasp and compare different viewpoints here
17:15:58 <Philippa> mm_freak: yeah, the real trick involved is proxying. Conor McBride's "Faking It" is a good intro
17:16:05 <elliott> with size :: proxy (v a) -> Integer, fromList :: [a] -> Maybe (v a)
17:16:07 <elliott> and so on
17:16:15 <elliott> that's possible, standardly or with reflection
17:16:26 <elliott> how does that differ from e.g. letting you write Vec 3 or Vec 4, beyond being more inconvenient to write?
17:16:31 <Philippa> Eduard_Munteanu: yeah, one meaning of expression and one of term are equivalent which is awkward
17:16:33 <elliott> I don't see how the type doesn't depend on the value there
17:17:12 <ski> mm_freak : what is the difference here ?
17:17:29 <Philippa> elliott: "depend" is a technical term
17:17:57 <mm_freak> elliott: i still don't see dependent types there…  you have just moved the choice of a non-dependent type to the run-time
17:17:58 <Philippa> basically, things depend on other things if there's a function arrow from the dependee to the dependent
17:18:26 <elliott> Philippa: sure, I think withNat demonstrates such an arrow, it's just hidden behind CPS style
17:19:57 <Philippa> I've got a screenful of crud here, where's withNat again?
17:20:22 <mm_freak> the program's behaviour depends on the type and the type is chosen dynamically…  that's why it feels like a dependent type, but it's not
17:20:42 <ski>   withNat :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
17:20:44 <elliott> Philippa: withNat :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
17:21:06 <elliott> factor out the CPS style: withNat :: Integer -> (exists n s.t. (Nat n))
17:21:14 <Philippa> okay, for the sake of argument are we assuming ConstraintKinds?
17:21:27 <elliott> I don't see why
17:21:30 <elliott> although you can if you want
17:21:39 <Philippa> because the moment you're using a typeclass to infer types, /you're cheating/
17:21:51 * ski . o O ( `exists n. Nat n *> ()' )
17:21:53 <mm_freak> he's not doing that
17:21:54 <elliott> well, I never claimed not to be cheating :)
17:21:59 <elliott> although I don't understand what you mean by that
17:22:08 <elliott> withNat would look like
17:22:13 <mm_freak> Philippa: the type class is really just to make the type useful
17:22:15 <elliott> withNat 0 k = k (Proxy :: Proxy Z)
17:22:18 <monoidal> I see proxies (as in data Proxy a = Proxy) as a workaround for the fact that Haskell has no syntax for applying a type to value. For example, the floatDigit function that takes a float only to know its type.
17:22:28 <elliott> withNat n k = ...this case is uglier...
17:22:40 <elliott> but it aclls k with Proxy (S m), where m is the type repr of (n-1)
17:22:41 <elliott> *calls
17:22:44 <elliott> assume e.g.
17:22:48 <Eduard_Munteanu> mm_freak: I think we usually talk about *static* dependently-typed systems.
17:22:50 <mm_freak> i see Proxy in this case used to get around having to write (undefined :: a)
17:22:53 <Philippa> elliott: right. There isn't a dependency in that sense, the /value/ doesn't show up in the type
17:22:54 <elliott> data Z; data S n; class Nat n where toInteger :: proxy n -> Integer
17:23:04 <elliott> Philippa: well, the value becomes the type :)
17:23:06 <Philippa> Eduard_Munteanu: I'd go so far as to say it's ill-defined on dynamic ones
17:23:19 <elliott> Philippa: the withVectorOfSize example is more compelling, because you /can't tell/ there's no dependent types going on
17:23:22 <Philippa> elliott: right, "proxying". Much like when you're playing MtG, it's because you don't have the real thing
17:23:33 <mm_freak> Eduard_Munteanu: huh?  why the remark?
17:23:36 <Eduard_Munteanu> Philippa: hm, really? I'm not sure but I guess one could defer checking to runtime. Beats me why though.
17:23:37 <elliott> <elliott> mm_freak: What if: withVectorOfSize :: Integer -> (forall v. (Vector v) => Proxy v -> r) -> r, where Vector had all the operations of a vector of a certain, finite size?  <elliott> with size :: proxy (v a) -> Integer, fromList :: [a] -> Maybe (v a)
17:24:01 <Philippa> Eduard_Munteanu: right, that's taking an existing semantics and doing weird things with it
17:24:02 <Eduard_Munteanu> mm_freak: you mentioned something about working with types at runtime
17:24:08 <elliott> it behaves just like a dependently-typed language would if withVectorOfSize n k = k (Proxy :: Proxy (Vector n))
17:24:15 <mm_freak> Eduard_Munteanu: you are choosing a type at runtime
17:24:17 <elliott> ignore the Proxy
17:24:21 <elliott> it could just be (forall v. (Vector v) => r)
17:24:24 <elliott> if haskell didn't ban that
17:24:24 <mm_freak> in elliott's examples
17:24:43 <mm_freak> that's not dynamic typing, it's just choosing at run-time
17:25:02 <Eduard_Munteanu> Ah, not in the context of typechecking.
17:25:38 <ski> elliott : surely you need class constraints for `v' on `size :: Proxy (v a) -> Integer' and `fromList :: [a] -> Maybe (v a)' ?
17:25:41 <Philippa> explicitly carrying along the dynamic residue of dependent types is also "cheating"
17:25:45 <Eduard_Munteanu> Though one can argue you're not really choosing the type at runtime either. It's just that you have a type that fits all. Everything else is certain data representations posing as types.
17:26:05 <Philippa> (the dependent lang "never existed", or at least you can't tell it did)
17:26:07 <Eduard_Munteanu> For example, typeclass dictionaries.
17:26:09 <mm_freak> Eduard_Munteanu: true
17:26:26 <mm_freak> you're choosing a dictionary at run-time
17:26:26 <elliott> ski: that was listing typeclass elements
17:26:28 <elliott> of Vector v
17:26:39 <Philippa> rather, you're building/passing one, but yeah
17:26:47 <Philippa> (you never do a case analysis to pick one)
17:26:50 <ski> elliott : oh, ok
17:26:57 <elliott> Philippa: well, you can't tell it isn't dependent behind the scenes :)
17:27:00 <mm_freak> Philippa: you do
17:27:04 <elliott> I think it's close enough to types depending on values
17:27:09 <elliott> even if hidden behind lots of noise
17:27:43 <mm_freak> elliott: "it's close enough to dependen types" = lightweight dependent types =)
17:27:47 <monoidal> going to sleep, good night
17:27:54 <Philippa> mm_freak: not in the chunk of code that's generated via a dictionary-passing transform, you don't
17:27:54 <ski> night, monoidal
17:28:03 <Philippa> you might paste in a case analysis from a dictionary...
17:28:40 <elliott> mm_freak: meaning http://okmij.org/ftp/Computation/lightweight-dependent-typing.html?
17:30:32 <Philippa> oh, for a non-level example of sorts? Turns out constraints and instances in Haskell work pretty nicely as they generalise :p
17:30:51 <Philippa> (and I knew that some time ago, it just didn't come to mind straight away)
17:32:40 <ski> @tell monoidal in any case, i'm not sure how you'd want to express sets/types like `{m : |N | m < n}' or `Vector A n' in your system -- maybe you don't want to express them, or don't miss them much, though ?
17:32:41 <lambdabot> Consider it noted.
17:34:37 <ski> @ask monoidal also, i'm not clear on whether you intend all values to have "proofs", or only those values which are propositions (presumably having type `Prop') -- in the former case, what would "proofs" for values like `(False,Just EQ)' and `Left (True : [])' look like ?
17:34:37 <lambdabot> Consider it noted.
17:37:02 <mm_freak> elliott: not sure
17:39:57 <ski> @tell monoidal re your <http://monoidal.blogspot.se/2012/04/descending-level-ladder.html>, i'm not happy how you in `PairC :: a := (Fst a, Snd a)' represent a pair of values (shifted into types) with a *product type* (a type of pairs), instead of using a dedicated type expressing a *pair of types* (ideally such a type, combining two types, wouldn't have kind `*') :)
17:39:57 <lambdabot> Consider it noted.
17:40:39 <Philippa> note to self: as "typeness" is defined by the "typed by" relationship (inc. "kinds are the types of types"), so "sortness" is defined by (generalisations of) the Rules in the lambda cube and PTSes. This makes a reasonably quick explanation for future use...
17:41:10 <elliott> ski: I like how blogspot links sneakily leak your location nowadays
17:42:08 <Philippa> (Rules boiling down to "what you can build functions between and what they count as")
17:42:11 <ski> Philippa : "sorts" there being those things which can occur as the right operand to the `:' relationship (which could be taken to be overloaded/polymorphic on level) ?
17:42:25 <ski> elliott ?
17:42:35 <elliott> ski: your link is to "monoidal.blogspot.se"
17:42:42 <elliott> because blogspot redirect people to country-specific domains nowadays for some reason
17:42:45 <ski> ah, ok :)
17:43:07 * ski didn't notice that
17:44:42 * ski always uses <http://www.google.com/webhp?hl=en> (or with s/webhp?hl=en/search?hl=en&q=.../) to avoid that kind of thing with google ..
17:45:36 <elliott> you can tell google you always want .com, btw
17:45:38 * nand`` just avoids google
17:45:41 <Philippa> ski: they're that too, yeah
17:45:41 <elliott> but i forget how :)
17:45:55 <elliott> nand``: having fun with bing?
17:46:25 <nand``> elliott: DuckDuckGo actually
17:46:30 <Philippa> (hence * being the sort of types but /not/ "all type expressions")
17:46:49 <hpc> nand``: DDG uses bing data in their index
17:46:59 <Philippa> (but we don't usually call it that because the interesting part is what the LHS of the : types)
17:46:59 <hpc> so close enough :P
17:47:18 <elliott> I find DDG's results about as useless as Bing's, so close enough
17:47:46 <hpc> i use DDG almost entirely for the zero-click box
17:47:57 <ski> elliott : without using cookies or logging in to an account ?
17:48:41 <elliott> ski: well, it probably sets a cookie so that it knows not to send you to the regional site. I think it's http://google.com/ncr.
17:48:53 <elliott> yes, indeed -- that's the "Go to Google.com" link on the regional sites
17:49:28 <nand`> hpc: I thought DuckDuckGo uses its own crawler + indexer? Either way, doesn't really matter to me as long as bing doesn't get my search queries in the end
17:50:14 <hpc> nand`: it uses whatever data it can get; it doesn't do much crawling because that's a lot of server cycles that could be spent indexing
17:54:47 <tertl6>  http://channel9.msdn.com/coding4fun/blog/Escape-the-fear-of-writing-XNA-games-for-Windows-Phone-75-and-XBOX-360?utm_source=dlvr.it&utm_medium=twitter
17:55:01 <ForSpareParts> What's the syntax for using a Maybe in a constructor? I wanted to do something like Type ... | Constructor Type (Maybe Type), but it said that Maybe "wasn't applied to enough type arguments"
17:55:43 <elliott> tertl6: what is the relevance to Haskell?
17:55:52 <elliott> ForSpareParts: that's correct, you must have done something else wrong :)
17:56:07 <tertl6> oops wrong channel, sorry :\
17:56:58 <elliott> ok :)
17:57:54 <ForSpareParts> elliott: would you mind taking a look?
17:57:54 <nand`> Type ... |    <- is “Type” also a type constructor? If so; that's wrong; type constructors are functions (values) and not types
17:57:56 <hpaste_> ForSpareParts pasted “datatypes” at http://hpaste.org/67125
17:58:18 <ForSpareParts> nand`: nope, Type is my data type
17:59:52 <elliott> ForSpareParts: uh.
18:00:00 <elliott> ForSpareParts: can i see the whole file?
18:00:40 <ForSpareParts> elliott: sure! It's a bit long, though...
18:00:46 <hpaste_> ForSpareParts pasted “scheme interpreter” at http://hpaste.org/67126
18:00:49 <nand`> ForSpareParts: compiles fine for me
18:00:55 <nand`> the snippet you sent before
18:01:34 <ForSpareParts> nand`: yeah, I just tried it on its own -- should've done that before I posted it. For some reason, in the context of the whole file that line breaks...
18:01:34 <elliott> `"import Maybe"
18:01:35 <elliott> don't do that
18:01:41 <elliott> that's a haskell98 package
18:01:44 <elliott> import Data.Maybe
18:01:52 <ForSpareParts> Ah! Thanks!
18:02:05 <ForSpareParts> So I know in the future -- what's the difference between them?
18:02:44 <hpc> in general, don't use top-level modules
18:02:51 <hpc> like Maybe, List, IO, etc
18:03:11 <ForSpareParts> Those are all the deprecated versions?
18:03:13 <hpc> the heirarchical ones are the modern ones
18:03:14 <hpc> yes
18:03:22 <hpc> Data.Maybe, Data.List, Data.IO
18:03:35 <hpc> the only exception i can think of is Numeric
18:03:50 <ForSpareParts> OK.
18:03:54 <hpc> which has some odds and ends you won't find in other places
18:04:25 <twomashi> is it possible to put a guard inline, ie, not in it's own function
18:04:46 <hpc> twomashi: how do you mean?
18:06:09 <twomashi> i mean usually a guard is the first thing in a function... but I want to do other things in the function before using a guard, and have the guard access local variables
18:06:23 <elliott> uh... "if... then... else"?
18:06:36 <twomashi> elliott: yes but a guard is cleaner...
18:06:42 <ForSpareParts> twomashi: "case" might do what you want
18:06:48 <ForSpareParts> or something like it
18:06:55 <twomashi> "case True of" doesnt work
18:07:10 <twomashi> case True of .. 1 == 1 = < parse error
18:08:00 <ForSpareParts> I don't think you're using case quite right. Correct me if I'm wrong, but wouldn't it be something like:
18:08:14 <fgomez> case var of   posval 1 -> something   posval2 -> somethingelse
18:08:53 <twomashi> case var... I have to check several vars for correctness
18:08:56 <ForSpareParts> case bool of True -> trueVal    False -> falseVal
18:08:57 <twomashi> gets ugly quick
18:09:05 <ForSpareParts> fgomez beat me to the punch
18:09:27 <twomashi> anyway im realising that this is what where is for :)
18:09:30 <twomashi> "where" *
18:10:37 <elliott> twomashi: You can do
18:10:39 <danharaj> huh. a lot of flim flam is popping up on /r/haskell
18:10:43 <elliott> case () of _ | guard1 -> ... | guard2 -> ...
18:10:52 <elliott> but it's ugly.
18:11:11 <elliott> danharaj: did you see that ridiculous hogwarts one?
18:11:14 <twomashi> elliot: <interactive>:2:5: Parse error in pattern: 1 == 1
18:11:25 <tertl6> hello
18:11:29 <elliott> /r/haskell can be an interesting place sometimes :p
18:11:33 <danharaj> elliott: I reported it. Did you see the submission that said they designed a language that was lazy and pure and concatenative but was none of those?
18:11:53 <tertl6> why dont the haskell wilobooks example work with GHCi
18:11:54 <tertl6> ?
18:11:54 <danharaj> or the one that's really about dependent types but says things that don't make sense?
18:12:09 <elliott> danharaj: hmm, Peg? I looked over it and it seemed interesting, even if the IO model is silly; is it not concatenative?
18:12:26 <elliott> that "descending the level ladder" thing which I assume you're referring to was discussed in here with the author some minutes ago
18:12:36 <elliott> my conclusion is that everyone else is as confused as I am about it, including the author :)
18:12:46 <tertl6> lol
18:13:07 <danharaj> elliott: Calling it pure when it's io model doesn't even make sense is ;\ ;\ ;\
18:13:32 <elliott> danharaj: well, I think it's technically "pure", because you can only create the world value at the REPL
18:13:34 <danharaj> idk why I'm ranting.
18:13:46 <elliott> you can still "dup" it though
18:13:49 <luite_> hmm, is it possible to splice quasiuotes with th?
18:13:51 <elliott> so I'm not sure what's up with that
18:14:11 <danharaj> elliott: It feels as thrown together as php. (sick burn)
18:14:34 <elliott> harsh :)
18:14:54 * elliott isn't sure it makes much sense, but finds what little sense it makes interesting, ignoring the silly IO model
18:15:18 <danharaj> also what's with that submission about a thing called Make that is not Make at all!
18:15:21 <danharaj> so confused :(
18:15:33 <elliott> meh, that thing /is/ like make, people are just misinterpreting it
18:15:40 <elliott> it's about a build system that, instead of producing files, produces haskell values
18:15:53 <danharaj> I don't get it, isn't that just a haskell program?
18:15:57 <elliott> including dependency resolution, etc.
18:16:17 <elliott> danharaj: well, perhaps ;)
18:16:28 <elliott> it combines it with a kind of resource acquisition
18:16:56 * elliott does think a lot of the /r/haskell submissions are crappy, though
18:17:02 <elliott> but hey, it's better than the rest of reddit
18:21:16 <danharaj> I think I discounted the Control.Make thing because the author didn't understand what referential transparency was.
18:21:44 * elliott disagrees that they don't understand what it is
18:21:54 <elliott> (and have been defending him in the comments :p)
18:21:59 <elliott> he's just expressing what he means poorly
18:22:13 * elliott has read enough of his blog posts before to know he's not incompetent
18:22:57 <BMeph> elliott: Just incontinent? ;)
18:24:25 <danharaj> elliott: I will take a closer look at their previous posts to figure out what their make is all about.
18:24:56 <elliott> haha
18:24:59 <elliott> that might or might not help :)
18:29:26 <danharaj> so if I understand their dependency problem correctly...
18:29:33 <danharaj> I'm not sure why they don't use reader and state.
18:29:35 <danharaj> :p
18:30:29 <elliott> danharaj: well, because they'd have to encode all resources they could possibly want statically, and initialise them all whether they want them or not
18:32:01 <danharaj> elliott: instead of the reader carrying the resources, the reader can carry IO actions that acquire the resources, and they can be run when needed.
18:32:11 <danharaj> Carry around capabilities, not resources.
18:33:47 <elliott> danharaj: right -- that works, but then you need a State to cache the results... and then if you add things to the mix so that you don't need to encode the possible resources in the type but instead get them from instances, etc. then you're 90% of the way to his Make type!
18:35:42 <danharaj> elliott: I'd need to see a use example. Zie's use of dynamic throws me off. I dislike dynamic alllootttttt.
18:36:39 * elliott dislikes Typeable too
18:36:58 <luite_> hmm i can work around it here by running quoteExp manually
18:37:13 * byorgey hugs Typeable
18:37:19 <elliott> danharaj: oh, they wrote a follow-up: http://awelonblue.wordpress.com/2012/04/16/make-for-haskell-values-pt-2-of-k/
18:39:01 <byorgey> the follow-up doesn't really seem to clarify much.
18:41:21 <scooty-puff> is there a simple way to use multipl MonadReader instances together?
18:41:50 <scooty-puff> lifting seems like one option, other is newtype wrapping and then aliasing local' = ..., ask' = ... (or this could work with lift)
18:41:54 <luite_> lots of lift!
18:42:48 <scooty-puff> k
18:43:15 <byorgey> scooty-puff: those are the only simple ways I know of.  If you want a very cool yet complex and difficult-to-understand-due-to-lack-of-documentation solution, see http://hackage.haskell.org/package/Monatron
18:43:19 <luite_> hehe don't know if that's the best solution, perhaps you can make some askXxx = lift.ask for your stack
18:43:40 <elliott> ooh, what is that? looks cool
18:43:43 <elliott> (Monatraon)
18:43:44 <elliott> *Monatron
18:43:49 <luite_> hmm, never seen that one
18:43:53 <sam3> What class is Elt in haskell?
18:44:08 <elliott> nice 404 link, sigh
18:44:15 <elliott> sam3: isn't that a repa thing?
18:44:56 <byorgey> sam3: it depends. where did you see it?
18:45:03 <byorgey> elliott: let me find you the paper
18:45:13 <sam3> I am looking at repa so I guess its a repa thing?
18:45:30 <elliott> it's a typeclass for things that can be elements of repa lists
18:45:36 <elliott> basically, "things that can be unboxed"
18:46:16 <byorgey> elliott: http://users.ugent.be/~tschrijv/Research/papers/monads_zippers_views.pdf
18:47:16 <byorgey> hmm, I guess this is more recent: http://dl.acm.org/citation.cfm?id=2034781  but behind a paywall.
18:47:22 <sam3> I am not sure how much you are familiar with repa but do you know why I get an error when I try to print out the sum of two dimensional arrays?
18:47:44 <byorgey> anyway, it's from ICFP '11.  The basic idea is to treat a stack of monad transformers like a list zipper.
18:47:46 <sam3> give me one sec
18:48:42 <elliott> byorgey: thanks
18:48:52 <luite_> byorgey: can it be applied to existing stacks?
18:48:57 <elliott> byorgey: so you can move left and right in it instead of lifting?
18:49:03 <sam3> http://hpaste.org/67130
18:49:08 <elliott> and the rest of the transformers move around correspondingly, becoming "below" your current monad, so to speak?
18:49:10 <elliott> that sounds super-cool
18:49:13 <sam3> I am not sure if anyone is familiar with repa
18:49:21 <byorgey> elliott: yeah, and you can define a bunch more combinators on top of that basic interface
18:49:33 <byorgey> elliott: it is a really cool idea.
18:49:45 <byorgey> luite_: yes, if I recall correctly
18:52:48 <byorgey> sam3: perhaps this is relevant (from http://hackage.haskell.org/packages/archive/repa/3.1.1.1/doc/html/Data-Array-Repa.html):
18:52:55 <byorgey> "Arrays of type (Array D sh a) or (Array C sh a) are not real arrays. They are represented as functions that compute each element on demand. You need to use computeS, computeP, computeUnboxedP and so on to actually evaluate the elements."
18:53:04 <byorgey> sam3: I am not actually familiar with repa
18:54:36 <sam3> hm2026 I'll try compute functions
18:54:38 <byorgey> data instance Array D sh e = ADelayed sh (sh -> e)
18:54:52 <byorgey> so it makes sense there is no Show instance for that since it would need to show a function
18:55:23 <elliott> I think repa got more confusing in 3.0.
18:55:23 <byorgey> sam3: there may not be Show instances for any of the Array types.
18:55:50 <byorgey> elliott: that's how you know it is better
18:57:30 <sam3> if I just declare it, x = fromListUnboxed (Z :. 2 :. 3 :: DIM2) ([0..5] :: [Int])
18:57:36 <sam3> then there does seem to be Show
18:57:40 <sam3> x = fromListUnboxed (Z :. 2 :. 3 :: DIM2) ([0..5] :: [Int])
18:59:07 <byorgey> sam3: and what does it say if you ask for the type of x?
18:59:39 <sam3> x :: Array U DIM2 Int
19:00:45 <sam3> oh2026 I tried computeUnboxedP and then it worked2026 :\
19:01:45 <Axman6> sam3: what IRC client are you using? i'm getting some strange stuff in the messages you're sending: oh^2026 I tried computeUnboxedP and then it worked^2026
19:03:49 <sam3> I'm not sure...
19:04:59 <elliott> :D
19:07:24 <Mathnerd314> sam3: is there a title bar? does it say something in it?
19:07:31 <elliott> They left.
19:08:03 <Mathnerd314> :-/
19:08:21 <Mathnerd314> are there any Haskell IRC clients?
19:08:45 <Mathnerd314> @google haskell irc client
19:08:47 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
19:08:47 <lambdabot> Title: IRC channel - HaskellWiki
19:09:50 <nyingen> there's lambdabot
19:10:22 <shachaf> And preflex.
19:10:22 <Mathnerd314> nyingen: how do you use it to send messages?
19:10:23 <shachaf> And geordi.
19:10:36 <elliott> There's that manatee thing.
19:10:55 <lambdabot> Mathnerd314: hi
19:11:15 <Mathnerd314> elliott: right, was just looking at that
19:11:36 <Mathnerd314> lambdabot: but are you doing that without IRC?
19:11:50 <lambdabot> Mathnerd314: i truely am
19:13:14 <luite_> is it possible to qq a type with variables without requiring a forall?
19:13:50 <hpc> whatever happened to ManateeLazyCat?
19:13:56 <hpc> preflex: seen ManateeLazyCat
19:13:57 <preflex>  ManateeLazyCat was last seen on #haskell 34 days, 11 hours, 39 minutes and 30 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
19:14:02 <hpc> huh
19:14:35 <hpc> heh, still speaking english with chinese grammar :P
19:15:02 <Mathnerd314> luite_: qq = quasiquote?
19:15:04 <luite_> yeah
19:15:21 <luite_> [t| Blah x y z |] requires x,y,z to be in scope
19:15:44 <luite_> [t| forall x y z. Blah x y z |] doesn't, but relies on explicit forall syntax
19:16:08 <Mathnerd314> and you don't like explicit forall syntax because...
19:16:25 <luite_> it requires an extension
19:16:38 <luite_> in the module where it's spliced
19:18:39 <Mathnerd314> ugh
19:21:03 <Mathnerd314> who made that design decision? :p
19:24:58 <danharaj> oh god maple
19:25:10 <danharaj> Is mathematica less terrible as a programming language?
19:25:16 <danharaj> Maybe I should learn it right now.
19:25:27 <elliott> Mathematica is, uh... an interesting programming language.
19:25:32 <elliott> It's a term-rewritey thing.
19:25:33 <rwbarton> from what i recall, "probably"
19:25:54 <danharaj> the way maple deals with lists makes me want to die
19:26:03 <elliott> Mathematica can be pretty slow if you don't do all your computation with built-ins, I think. And it's sort of brittle.
19:26:13 <elliott> But it's pretty usable, I think.
19:27:30 <Mathnerd314> elliott: other than the price tag
19:28:36 <elliott> Mathnerd314: Does Maple cost less?
19:28:59 <Mathnerd314> I was comparing to Sage
19:29:15 <elliott> I wasn't.
19:29:40 <Axman6> no one was...
19:31:15 <elliott> "Is Python better than PHP?" "Yes." "Other than the dynamic typing." "Is PHP statically typed?" "I was comparing to Haskell."
19:34:03 <danharaj> what's Sage?
19:34:30 <Mathnerd314> @google sage mathematics
19:34:32 <lambdabot> http://www.sagemath.org/
19:34:32 <lambdabot> Title: 30 Sage: Open Source Mathematics Software
19:34:50 * hackagebot logic-classes 1.4.4 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.4 (DavidFox)
19:35:00 <danharaj> oh hey this looks nice.
19:35:05 <Mathnerd314> every open-source math library under the sun glued together into a Python framework
19:35:56 <danharaj> nevermind o_o
19:36:10 <elliott> @remember danharaj <danharaj> oh hey this looks nice.  <Mathnerd314> every open-source math library under the sun glued together into a Python framework  <danharaj> nevermind o_o
19:36:10 <lambdabot> Done.
19:37:57 <monochrom> hahaha
19:38:08 <Mathnerd314> danharaj: IIRC it even interfaces with Maple and Mathematica too
19:38:24 <danharaj> I don't get it.
19:38:45 <danharaj> Do they also tape their hammers, saws, screwdrivers, and blenders to their pick-up truck?
19:39:51 <tgeeky> danharaj: my other car is a space shuttle
19:40:19 <tgeeky> and yes, I velcro those things here and there
19:41:02 <Mathnerd314> tgeeky: don't they fall off during takeoff and re-entry? :p
19:41:29 <tgeeky> Mathnerd314: ah, you see, but we drive our car from the *inside*
19:41:35 <monochrom> they don't fall off during re-entry. they vaporize
19:42:04 <elliott> speaking of rubbish in /r/haskell... http://www.reddit.com/r/haskell/comments/sb3kb/haskell_newbie_questionstrouble_installing_using/c4cp4la
19:46:00 * ski . o O ( `/rubbish/haskell' )
19:48:02 <cudima> I get compilation errors trying to install the latest crypto package and the hscurses package. My first experience with cabal-install. What's the right way to handle this?
19:48:25 <monochrom> http://www.rubbish.com/subrubbish/<topic name>/circlejerk/303482
19:48:55 <elliott> monochrom: pretty much
19:49:52 <tgeeky> is a circlejerk just a form of communist masturbation?
19:51:15 <ski> it might be related to the credit card transform
19:53:04 <Veinor> how do i tell bootstrap.sh to install profiling libs for everything it bootstraps?
19:53:25 <elliott> Veinor: EXTRA_CONFIG_OPTS=--enable-library-profiling -- but i'm not sure the variable is called that
19:53:37 <elliott> it's in the first few lines of bootstrap.sh, just find its name and then blah=--enable-library-profiling sh ./bootstrap.sh
19:54:15 <Veinor> looks like it's EXTRA_CONFIGURE_OPTS
19:54:17 <Veinor> thanks :)
19:54:30 <elliott> np :)
19:55:40 <cudima> I'm trying to build the latest crypto package and getting compilation errors
19:56:03 <Veinor> odd
19:56:19 <shergill> that took way longer than it should've. just downgraded back to ghc 7.0.4. finally stuff compiles without exitfailure 11
19:56:22 <Veinor> it won't install text: collect2: ld returned 1 exit status
19:56:31 <Veinor> ... oh i know what it is
19:56:31 <luite_> Veinor: I personally use it to install cabal install and then remove ~/.ghc
19:56:43 <cudima> I'm a newbie so I don't know if I should start digging inside code or it's a settings issue
19:56:52 <luite_> since it usually has older dependencies
19:57:55 <Veinor> (i was out of disk on /tmp)
20:12:11 <tgeeky> Cale: thanks for the book. Pretty interesting development. I wasn't even aware how diverse of a system you could generate from clifford algebras.
20:12:52 <tgeeky> that's too general.. just the quaternions / octonions
20:19:26 <Veinor> what exactly does split-objs do?
20:20:32 <elliott> split objs
20:24:40 <Veinor> :|
20:24:56 <Veinor> on a related note, what're the advantages/disadvantages of telling cabal to --enable-shared?
20:25:19 <elliott> advantages: you can build haskell programs with shared libraries, so if you care about big executables...
20:25:29 <elliott> disadvantages: it means you build everything 3 times
20:25:32 <elliott> (normal, profiling, dynamic)
20:25:49 <Veinor> ah
20:26:19 <luite_> hmm, does shared require profiling?
20:26:25 <elliott> no, but nobody builds without profiling
20:26:34 <luite_> i build without profiling
20:27:09 <luite_> disabled it because builds were taking too long
20:28:55 <Veinor> how do you time?
20:29:16 <parcs`> also, faster linking times
20:29:25 <Veinor> faster with or without shared?
20:29:32 <parcs`> with
20:30:11 <Veinor> gcc: error: dist/build/cbits/cbits.dyn_o: No such file or directory
20:30:21 <luite_> Veinor: I don't time, but I got annoyed enough to disable it... it's what you get when working on stuff that has lots of dependencies
20:30:44 <parcs`> and faster load times too because the libs can be cached in memory
20:31:10 <Veinor> what am i missing with this cbits thing?
20:31:28 <luite_> cbits.dyn_o
20:31:32 <Veinor> well yes
20:35:15 <Veinor> but how do i get this cbits.dyn_o
20:35:27 <Veinor> i'm trying to compile text with --enable-shared
20:36:53 <ski> tgeeky : hm, what book was that ?
20:39:31 <Veinor> oh, it's probably because i don't have shared libraries for base
20:39:40 <tgeeky> ski: http://www.maths.qmul.ac.uk/~raw/ http://www.maths.qmul.ac.uk/~raw/TFSG.html
20:40:26 <tgeeky> anyone want to take on construction (at least semi-presentations?) of all the finite simple groups (and families)?
20:40:38 <gienah> Veinor: maybe doing the configure and build with --verbose=3 and examining the output may give some hints
20:40:54 * tgeeky writes that on a note, and sticks it on the whiteboard.
20:42:02 <ben> Hey, is there a version of ghcjs that works with ghc 7.4?
20:42:58 <hamishmack> ben: https://github.com/hamishmack/ghcjs
20:44:56 <hamishmack> ben: I added a sort of GC over Easter so that I could implement weak pointers and finalizers
20:45:00 <ben> cool, cheers
20:45:07 <ski> tgeeky : ty
20:46:51 <elliott> hi dog
20:46:57 <dog> yes, this is dog
20:47:11 <shachaf> hi dog
20:47:17 <shachaf> dog: You owe me five dola..
20:47:19 <shachaf> s/.$//
20:47:22 <dog> dog.
20:47:47 <shachaf> how you a dog learned english?
20:47:55 <dog> this is dog
20:48:18 <shachaf> mr dog this is anna
20:48:25 <copumpkin> sorry, was afk for a few and my dog got my keyboard
20:48:29 <tgeeky> hamishmack: bless you!
20:48:32 <Veinor> the problem is there's a cbits/cbits.c file that isn't getting a dyn_o
20:48:35 <shachaf> (That doesn't say "anna", by the way. It says (reverse "anna").)
20:48:43 <shachaf> copumpkin: Oh.
20:48:54 <shachaf> copumpkin: I feel bad now. I told your dog they owe me five dola.
20:50:26 <copumpkin> :)
20:51:34 <thoughtpolice_> lol copumpkin
20:52:41 <Veinor> so how do i convince cabal to build a .dyn_o file for a .c file?
20:53:11 <shachaf> elliott: When are you going to update your answer to do the unsafeCoerce thing?
20:57:27 <thoughtpolice_> Veinor: if it's in the c-sources directive of the cabal file, and building dynamically doesn't compile those C files with -fPIC (or otherwise doesn't work them in to the build properly,) i'd say you should file a bug
20:59:01 <Veinor> k
21:08:08 <Veinor> Network/Socket.hsc:340:16: parse error on input `CALLCONV'
21:10:01 <hamishmack> ben: It looks like I had accidentally left some stuff out of my last commit.  I have pushed them now.
21:10:46 <Veinor> i get this CALLCONV error every time i try to compile network
21:11:25 <ben> hamishmack: Ah, that works much better :))
21:11:26 <ben> thanks
21:11:43 <elliott> Veinor: what ghc version?
21:11:49 <elliott> i think you need to patch it with 7.4
21:12:19 <Veinor> 7.4
21:12:21 <Veinor> what's the patch?
21:12:36 <elliott> doubling some #s, i forget
21:12:45 <shachaf> MagicHash##
21:14:52 <Veinor> the odd thing is, it only fails when compiling profiling
21:15:58 <elliott> odd
21:16:49 <koala_bot> I need to write a program with some stochastic components, and my professor warned that some random number generators are far less random than he found acceptable. Does Haskell have a reliably uniformly random number generator? Is there one that's better than others that may exist?
21:16:57 <hpaste_> Xorlev pasted “UrlExtender.hs” at http://hpaste.org/67131
21:17:10 <Xorlev> Hey guys. I've been learning Haskell for a few days now and I've managed to get stuck on this bit of code running a HTTP request ^
21:17:31 <Xorlev> "The last statement in a 'do' construct must be an expression:"
21:18:00 <Xorlev> I'm confused, because I thought it was an expression.
21:18:03 <elliott> the problem is that the last statement in a do construct must be an expression :)
21:18:14 <rwbarton> "x <- y" is not an expression
21:18:15 <Veinor> Xorlev: you need to deindent your case statement
21:18:33 <rwbarton> ah yes
21:18:38 <elliott> Xorlev: are you indenting with tabs?
21:18:45 <elliott> if so, set your editor not to
21:18:56 <elliott> ps, I suspect the response code you want is 200, not 2
21:19:00 <Xorlev> 4 spaces is what Haskell likes?
21:19:06 <rwbarton> spaces is what Haskell likes
21:19:20 <elliott> Xorlev: Haskell treats tabs as 8 spaces.
21:19:29 <elliott> You are using tabs as something other than 8 spaces, and worse, mixing them with spaces.
21:19:30 <rwbarton> look at hpaste, how your code is obviously not indented properly
21:19:38 <Saizan> Xorlev: what matters is vertical alignment
21:19:42 <Xorlev> elliott: I was playing with pattern matching, so I'm okay with 202, 201 etc.
21:20:01 <rwbarton> 'case' on line 16 needs to be under 'resp' on line 15
21:20:15 <rwbarton> similarly lines 26/22
21:20:16 <elliott> Xorlev: "2" does not match 200, 201, etc.
21:20:18 <elliott> it matches 2 :)
21:20:19 <elliott> oh!
21:20:22 <elliott> it's in a three-tuple
21:20:22 <elliott> i see.
21:20:25 <elliott> how silly
21:21:35 <Veinor> odd, i keep getting the callconv error
21:21:48 <Veinor> maybe there's a bug in cabal
21:21:59 <rwbarton> I wonder about the error message in that hpaste, unless it's cut off
21:22:07 <elliott> try -v3 and compare profiling and non-profiling
21:22:31 <elliott> (at Veinor)
21:23:03 <wli> Tab characters represent advances to the next tabstop setting, which is a property of a terminal configuration or an graphical display program's configuration. This variance in display is why the use of tab characters is advised against. The "standard" tabstop configuration is one tabstop every 8 columns in a character cell terminal or emulator for such, and that's how the compiler interprets them. This may vary from how your editor or display program is configure
21:23:57 <Xorlev> Thank you so much. I have it running now. I knew Haskell was whitespace sensitive but I hadn't realized just how sensitive.
21:24:15 <wli> I simply recommend configuring tabstops in the display or editing program to the standard.
21:24:36 <ski> wli : cut off at "... This may vary from how your editor or display program is configure"
21:24:53 <wli> ski: You only missed one character.
21:25:03 <wli> Or maybe two. "d."
21:25:08 * ski guesses it was "d"
21:26:33 <koala_bot> Any insight on random number generators?
21:26:47 <ski> (seems 468 characters came through in that message ..)
21:27:19 * ski doesn't know much about making PRNGs
21:27:53 <koala_bot> bummer
21:29:07 <ski> i haven't tried it, but istr hearing about
21:29:08 <ski> @hackage mersenne-random
21:29:08 <lambdabot> http://hackage.haskell.org/package/mersenne-random
21:29:52 <Xorlev> mersenne twister isn't suitable for cryptography
21:29:57 <koala_bot> Any idea how that compares to System.Random?
21:30:03 <Xorlev> But if you don't need it for that, it's good :)
21:30:24 <koala_bot> Not crypto but the random-er the better :P Doing stochastic genetic algorithms and my prof seems to be picky on the topic
21:32:06 <Xorlev> Is a period of 2^19937-1 good enough for you?
21:32:39 <Xorlev> It will absolutely blaze, since the mersenne-random package uses the SIMD instructions (SSE2)
21:32:53 <koala_bot> The ridiculousness of his warnings is evident in the fact that I only need binary numbers 00, 01, and 10 :P
21:33:23 <Xorlev> Haha.
21:34:05 <koala_bot> I think it's less a matter of range and more a matter of frequency/distribution
21:34:20 <Xorlev> I think you'll be alright. You could generate 50,000 numbers and bucket them mod 3, do a plot.
21:34:24 <koala_bot> I haven't done a lot of reading on random number generators so I don't really know what makes a good one... lol
21:34:42 <koala_bot> I think he specifically requested we generate bit strings directly, e.g. - one bit at a time
21:34:46 <koala_bot> it's weird
21:36:02 <Xorlev> Looks like MTRandom can return bools, so you can do it that way.
21:37:16 <Veinor> oh, i think i fixed the issue
21:37:22 <koala_bot> Thanks Xorlev :) Hopefully it's "random" enough! ;)
21:37:32 <Veinor> it turns out i was using a version of ghc different from the one i thought i was using
21:39:53 <Xorlev> koala_bot: Just make a function to return 0. Nobody will know :)
21:40:19 <koala_bot> lol.
21:40:26 <koala_bot> He doesn't collect the code, you know...
21:40:27 <koala_bot> ;)
22:15:23 <Peaker> dcoutts, hey, any chance you received my message?
22:23:42 <raf> hello every one i am new joined today only
22:24:10 <Axman6> congratulations. what did you join?
22:24:28 <Saizan> hi
22:24:37 <raf> hi..
22:27:46 <Axman6> raf: so are you learning haskell?
22:30:46 <raf> ya i am learning it..where are u from?
22:31:05 <Axman6> the internet
22:31:10 <Axman6> >_>
22:31:22 <Axman6> Australia is probably the answer you were after though =)
22:32:23 <raf> Axman :may i know your name?
22:32:31 <Axman6> Axman6
22:32:38 <chu> Getting a bit weird.
22:32:47 <Orclev_> a bit
22:33:29 * Orclev_ returns to lurking... and doing things he probably shouldn't with Data.Dynamic
22:41:02 <Orclev_> if you have a Dynamic, and you know it's a member of some class, but you don't know exactly what it is, can you do anything meaningful with it? For example, you know it has an instance of Show, is it possible to use show on it somehow?
22:42:19 <elliott> np
22:42:23 <elliott> *no
22:42:25 <elliott> alas
22:42:34 <danharaj> Dynamic doesn't carry around dictionaries?
22:42:43 <elliott> nope
22:42:55 <elliott> it's just a typeable existential
22:43:08 <danharaj> ah
22:43:11 <elliott> imo typeable should provide dictionaries
22:43:11 <danharaj> Orclev_: Are you sure you want to use Dynamic?
22:43:24 <copumpkin> elliott: arbitrary ones? how would that work?
22:43:26 <danharaj> yes that would be good although how would you tell GHC to carry around ALL the dictionaries.
22:43:34 <copumpkin> typeable has its own dictionary :P
22:43:43 <elliott> copumpkin: badly
22:45:16 <Orclev_> danharaj: not entirely, but it's the best solution I've seen... I need a heirarchal data structure that support mixed kinds of data, all must support a common class to be used in one location, but other parts of the code will actually know the contents of the structure and will need to be able to navigate... I thought I was there with Dynamic, but it falls just short it seems
22:45:50 <danharaj> Orclev_: Sounds like you want a GADT!
22:46:09 <Orclev_> danharaj: that's what I have now and it's messy, I'm looking for something cleaner
22:46:17 <danharaj> :3
22:46:49 <Orclev_> or maybe I'm just doing it wrong... need to do more research
22:46:57 <danharaj> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
22:47:05 <Orclev_> yes, I've read that
22:47:06 <danharaj> this post was helpful to me when I was navigating a similar idea.
22:47:10 <danharaj> a hm indeed
22:50:35 <Orclev_> danharaj: that was actually very close to what I originally had, the problem I ran into is I can't mutate arbitrary content in the data heirarchy when it's represented as functions, so I converted everything back
22:52:28 <nyingen> @quote
22:52:28 <lambdabot> sinelaw says: It always ends in an insult.
22:52:40 <nyingen> @quote
22:52:40 <lambdabot> dkc says: one way to scale a learning curve is to just flatten it with your face
22:56:44 <yitz> Orclev_: almost always, a design like that was inspired by OO-think. if you begin thinking about the original problem from scratch in haskell, you'll likely end up with something totally different.
22:57:25 <Orclev_> yitz: I'm trying to abstract away a set of operations so that I can describe them in a pure way in one location, and later actually perform them
22:59:06 <Orclev_> I would like to not have to define all the operations up front as later on I end up with a really nasty case statement matching on everything, rather than a much nicer class based system where the compiler handles making sure the right instance of the function gets called
22:59:10 <yitz> Orclev_: ok, but operations act upon data. often it's helpful to think about data types first, and only then start thinking about the operations.
23:00:32 <yitz> Orclev_: i think the reason we usually think along those lines in haskell is that we want to get maximal leverage power from the type system.
23:01:01 <Orclev_> well, plus a 20 line long case statement is nasty
23:01:12 <yitz> Orclev_: right
23:03:43 <yitz> Orclev_: if you define all of your data types first, in the most natural way for each one, you will probably see that some aspect of the "operations" do abstract over them nicely, and others really don't and are therefore best defined separately for each.
23:03:54 <yitz> *aspects
23:05:03 <Orclev_> not really
23:05:45 * yitz now stops talking in generalities, not knowing any of the details of Orclev_'s problem space.
23:06:09 <Orclev_> it's primarily a set of blitting instructions to combine various pieces of visual data, sometimes rendered text, graphics, or simple fills
23:06:42 <yitz> Orclev_: i'm actually working on something similar to that too
23:06:56 <yitz> Orclev_: i found that semigroups are really really helpful
23:07:06 <Orclev_> semigroups?
23:07:18 <yitz> Orclev_: like a monoid, but without an empty element
23:07:43 <yitz> Orclev_: graphic objects have a location on the canvas, so there is no single natural "empty" one.
23:07:51 <yitz> @hackage semigroups
23:07:52 <lambdabot> http://hackage.haskell.org/package/semigroups
23:08:54 <copumpkin> what's the operation?
23:09:06 <yitz> Orclev_: if you can manage to make all of your object types an instance of Semigroup, you then have a general way to combine smaller ones into bigger ones
23:09:50 <yitz> copumpkin: making bigger, possibly more complex, graphic objects out of smaller ones.
23:09:58 <copumpkin> ah
23:10:27 <Orclev_> hmm... that might work... I really only have one way to combine graphics which is: over :: Image -> Image -> Image... so conceptually I suppose <> = over
23:10:55 <yitz> Orclev_: i also defined a type class "Rectangular", for things that are contained within a rectangular bounding box. the methods give the coordinates of the lower-left corner, the width, and the height of the bounding box
23:12:18 <Orclev_> hmm, except I'm back where I started then, I'm trying to perform the combination in such a way that I can still retrieve the underlying instances
23:12:23 <elliott> <Orclev_> it's primarily a set of blitting instructions to combine various pieces of visual data, sometimes rendered text, graphics, or simple fills
23:12:27 <elliott> my earlier advice might help ;)
23:12:59 <Orclev_> elliott: yes, and it has a lot, but I ran into some problems
23:12:59 <yitz> Orclev_: my classic non-trivial Semigroup instance is for blocks of text. it finds the new bounding box, and combines the text content by adding a space and observing possible hyphenation
23:13:22 <elliott> e.g. just represent every image as (SDL.Screen -> Coords -> IO ()), where coords is the top-left position to draw it
23:14:26 <elliott> and not need any classes or case statements at all
23:14:40 <Orclev_> elliott: the problem I ran into is I'm trying to describe the entire scene to draw in a pure way before actually doing it so that I can only perform updates on what changes from render to render instead of rebuilding the entire thing from scratch on each frame
23:15:09 <yitz> elliott: you can't get any information out of those objects then, though. you can only draw them.
23:15:16 <elliott> Orclev_: right - the blackboard lib i linked you to dealt with that
23:15:25 <elliott> yitz: sure, but that is not necessarily a bad thing.
23:15:36 <yitz> elliott: right, depends on the application.
23:16:44 <elliott> Orclev_: it'll likely be much more convenient and efficient going down a route like that rather than an algebraic representation
23:19:33 <yitz> elliott: even if you do need to get some kind of higher-level information out of the objects, you can represent only that algebraicly while representing their shape as you say
23:19:51 <elliott> yitz: you can bundle the info with the actions, yes
23:19:55 <elliott> and have your combinators update that info
23:21:25 <mbuf> is there a recommended library for CSV parsing? an example would be useful to refer to
23:21:28 <yitz> Orclev_: my application doesn't render the objects, it reads them and tries to recognize them.
23:22:47 <yitz> mbuf: yeah there are a lot of 'em out there.
23:23:13 <mbuf> yitz: anything that is widely used/recommended?
23:23:19 <elliott> Orclev_: you might find this library helpful for inspiration: http://hackage.haskell.org/package/graphics-drawingcombinators
23:23:36 <yitz> mbuf: a lot of it depends on what you need. do you need to support a huge swath of all the csv syntaxes out there? (what a bottomless pit)
23:23:47 <mbuf> yitz: no, just basic is fine
23:26:30 <hpaste_> rnons pasted “yosog fail” at http://hpaste.org/67134
23:29:27 <yitz> mbuf: here's a really really simple one:
23:29:32 <yitz> @hackage csv
23:29:32 <lambdabot> http://hackage.haskell.org/package/csv
23:29:41 <yitz> mbuf: and here's a much more complete one:
23:29:49 <yitz> @hackage csv-conduit
23:29:49 <lambdabot> http://hackage.haskell.org/package/csv-conduit
23:30:07 <mbuf> yitz: thanks
23:39:37 <Orclev_> elliott: I'll get back to you, I've tried doing things like the blackboard example twice now and it always ended in disaster with some seriously nasty nasty update logic, but I'll kick it around some more and see if I can figure out a better way of doing it
23:40:32 <elliott> Orclev_: well, the update logic doesn't need to be part of your pure image code -- ideally, it can be part of the FRP stuff
23:40:38 <elliott> (not that this is necessarily possible)
23:40:45 <elliott> but it shouldn't be _too_ messy
23:44:07 <nyingen> @quote
23:44:08 <lambdabot> ConorMcBride says: "Sometimes it's easier to search for good programs in the space of well typed programs, rather than in the space of ascii turds."
23:44:45 <nyingen> I've noticed people like to wax scatological about perl
23:49:25 <shachaf> @quote
23:49:26 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
23:49:35 <shachaf> @quote
23:49:35 <lambdabot> boegel says: * boegel goes to inflate Itkovian's balls
23:49:38 <shachaf> @quote
23:49:39 <lambdabot> OlinShivers says: Oh, yes, the *acknowledgements*. I think not. I did it. I did it all, by myself.
23:49:56 <nyingen> "no thanks to my lazy grad students"
23:50:58 <elliott> (see http://www.scsh.net/docu/html/man.html for the full thing)
23:52:51 <Peaker> @seen dcoutts
23:52:51 <lambdabot> Unknown command, try @list
23:52:59 <elliott> preflex: xseen dcoutts
23:53:00 <preflex>  dcoutts was last seen on freenode/#ghc 15 hours, 27 minutes and 18 seconds ago, saying: when we change it to cope with other dirs we'll break the API, so you shouldn't get silent failure
23:53:06 <elliott> has lambdabot had @seen for years?
23:53:55 <Peaker> thanks, no idea
23:55:05 <yitz> elliott: it did. they disabled it because it was a slow memory leak that eventually caused crashes. use preflex instead.
23:55:23 <elliott> i just asked because people keep using it even though i've never seen it work :)
23:55:44 <Peaker> #cabal is quiet. not getting responses on cabal-devel-owner. cabal-devel is auto-rejecting my messages (do I need to register before sending?) and I'm not sure what to do with my cabal patch... After getting used to github, this is so frustrating
23:56:08 <elliott> Peaker: probably it is a mailman list?
23:56:09 <yitz> the @seen plugin should say "use preflex instead". (or it should be fixed to work properly in lambdabot itself)
23:56:20 <Peaker> elliott, not sure what that entails
23:56:51 <elliott> http://www.haskell.org/mailman/listinfo/cabal-devel
23:56:52 <elliott> subscribe there
23:58:23 <Peaker> Hmm.. it has "email my password to me" option. Bah
23:59:36 <yitz> Peaker: A hollow voice says "plugh".
