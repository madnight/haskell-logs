00:04:01 <Enigmagic> :r
00:04:03 <Enigmagic> bah
00:26:05 <cadabra> How do you write maybeShow? E.g. maybeShow x = if x instance of Show then Just (show x) else Nothing
00:30:41 <ChristianS> cadabra: haskell is typesafe so which type do you want your x to have?
00:32:04 <cadabra> a
00:32:18 <Ptival> cadabra: being an instance of Show implies passing an additional argument to your function, therefore you cannot "test it"
00:33:24 <Ptival> you could write a typeclass MayShow with a maybeShow method though
00:33:47 <Ptival> and automate Show a => MaybeShow a
00:33:56 <Ptival> I think
00:34:05 <danr> Ptival: yeah, and I guess you could use overlapping and undecidable instances to instantiate them (hee-hee)
00:34:28 <Ptival> and have a default maybeShow a = Nothing
00:34:33 <Ptival> forall a
00:34:35 <cadabra> Something along those lines is what I'm curious about. Maybe DefaultSignatures like edwardk mentioned above.
00:35:03 <cadabra> But I can't have more than one default signature... :/
00:35:11 <edwardk> overlapping instances are just always a bad idea
00:35:15 <edwardk> cadabra: yeah =/
00:39:42 * hackagebot blaze-html-contrib 0.2 - Some contributions to add handy things to blaze html.  http://hackage.haskell.org/package/blaze-html-contrib-0.2 (ChrisDone)
00:40:31 <clinton> Is there a way in Yesod to keep some "state", but not write it to disk. I know I can use yesod's persistance or acid-state for something more permanent, but I just need roughly "global" data which can be regenerated on restart (i.e. is writable, but no need to write to disk).
00:40:55 <arossouw> how can i access elements of a tuple individually ?
00:41:30 <clinton> II've tried adding my state (as a test, just an Int) to the foundation type, which works for read access, but I'm not sure how to write to it.
00:41:34 <cadabra> arossouw: let (a, b, c) = tuple in ...
00:41:42 <arossouw> ok, thanks
00:41:46 <clinton> perhaps that is the incorrect approach though
00:42:36 <arossouw> hehe, been reading so much Real World Haskell, that i dream about haskell code
00:44:44 * hackagebot blaze-html-contrib 0.2.1 - Some contributions to add handy things to blaze html.  http://hackage.haskell.org/package/blaze-html-contrib-0.2.1 (ChrisDone)
00:48:17 <arossouw> can you use haskell as a replacement for C++ Gui programming?
00:49:42 * hackagebot digestive-functors-snap 0.3.2.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.3.2.0 (JasperVanDerJeugt)
00:51:13 <merijn> arossouw: I don't see why not? (Mind you, I haven't done haskell GUI programming, but I don't see why it should be more difficult than doing the same in any other language...)
00:52:07 <arossouw> ok, great
00:52:26 <arossouw> not sure if i should go for wxWidgets or GTK
00:52:46 <edwardk> arossouw: what platform are you on?
00:52:54 <arossouw> unix/linux
00:53:00 <edwardk> arossouw: then it doesn't matter much
00:53:05 <arossouw> ok
00:53:15 <edwardk> on a mac, the gtk stuff is a lot easier to get going but the wxwidgets look better
00:53:45 <arossouw> ye, i've seen some demos looks good
00:55:21 <ivanm> since when has profiling support been able to tell you which sub-part of a function took up runtime? :o
00:55:28 <ivanm> this is *awesome*
00:56:23 <jelly1> hi
00:56:40 <jelly1> does anyone know if haskell-x11 1.6 is considered stable?
00:57:14 <jelly1> i guess so, but i can't really find a changelog on their github/in the tar.gz
00:57:21 <jelly1> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11 ;)
01:00:02 <tasidus> on tags on the github repo either :(
01:00:08 <tasidus> no*
01:03:01 <t7_> i had a dream i had to buy a new server to run 10 virtual machines. I was looking at quadcore laptops...
01:03:23 <t7_> even my dreams are nerdy
01:04:09 <jelly1> t7_: 10 VM's of what
01:04:22 <t7_> just for thin client workstations
01:04:36 <jelly1> oh
01:04:44 * hackagebot snap-auth-cli 0.1.0.0 - Command-line tool to manage Snap AuthManager database  http://hackage.haskell.org/package/snap-auth-cli-0.1.0.0 (DmitryDzhus)
01:04:46 * hackagebot PlayHangmanGame 0.2 - Play Hangman Game  http://hackage.haskell.org/package/PlayHangmanGame-0.2 (HaishengWu)
01:05:10 <arbn> t7: The ultimate goal is to write code in your dreams and remember it upon waking. That way, you don't waste any time.
01:05:53 <t7> arbn: sometimes im stuck working on a bug for hours so i goto bed. Then when i wake up i solve it in 5 mins
01:06:13 <jelly1> arbn: :D
01:06:23 <jelly1> t7: take breaks more often
01:06:29 <merijn> If I have "cycle l" and repeatedly pop the first element, will I have roughly constant memory usage for that list?
01:11:18 <blah> @pl \p f x -> join $ liftA2 unless (fmap p x) (fmap f x)
01:11:18 <lambdabot> ((join .) .) . (. fmap) . ap . (liftA2 unless .) . fmap
01:12:47 <blah> @djinn  (a -> Bool) -> (a -> m ()) -> m a -> m ()
01:12:47 <lambdabot> -- f cannot be realized.
01:13:41 <merijn> blah: What would the (a -> Bool) be used for?
01:14:05 <blah> @type join $ unless <$> (fmap p x) <*> (fmap f x)
01:14:07 <lambdabot>     Couldn't match expected type `a -> Bool'
01:14:07 <lambdabot>            against inferred type `Expr'
01:14:07 <lambdabot>     In the first argument of `fmap', namely `p'
01:14:33 <blah> @type \p f x -> join $ unless <$> (fmap p x) <*> (fmap f x)
01:14:34 <lambdabot> forall (m :: * -> *) a. (Monad m, Applicative m) => (a -> Bool) -> (a -> m ()) -> m a -> m ()
01:14:56 <merijn> :t unless
01:14:57 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:15:13 <blah> merijn: it's the predicate used by unless
01:17:54 <blah> is there a pretty way to factor out that \f -> fmap f x  ?
01:19:57 <merijn> blah: And what would factoring it out accomplish? (Not sure I understand the problem...)
01:19:59 <deggis> blah: (flip fmap) f?
01:20:12 <danr> blah: (`fmap` x)
01:20:38 <deggis> oh
01:20:52 <blah> but see how i have to use that pattern twice?
01:21:06 <merijn> :t (<*>)
01:21:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:21:12 <danr> blah: I think you need to be more precise what you want to do :)
01:23:14 <blah> i want to find a beautiful way to write   \p f x -> join $ unless <$> (fmap p x) <*> (fmap f x)  that doesn't repeat itself twice at the end
01:26:04 <blah> @pf \x -> f x x
01:26:04 <lambdabot> Maybe you meant: bf pl
01:26:13 <blah> @pl \x -> f x x
01:26:13 <lambdabot> join f
01:26:27 <zhulikas> @type unless
01:26:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:26:59 <merijn> :t uncurry
01:27:00 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:27:55 <merijn> :t \x -> curry (<*>) . join (&&&) (flip fmap x)
01:27:55 <lambdabot> forall a b a1 b1 (f :: * -> *). (Monoid (f b1), Functor f) => f a1 -> (a1 -> b1) -> (a -> b) -> ((f b1, f b1), a) -> ((f b1, f b1), b)
01:28:33 <merijn> Oh wait, that's wrong too
01:29:32 <blah> @pl \x -> f (fmap p x) (fmap g x)
01:29:32 <lambdabot> ap (f . fmap p) (fmap g)
01:29:45 * hackagebot hums 0.4.2 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.4.2 (BardurArantsson)
01:30:18 * merijn doesn't see the big problem with the original code anyway
01:30:29 <merijn> Maybe I'd move the fmap's into a where clause
01:30:33 <merijn> But other than that...
01:30:58 <blah> doesn't repeated code bug you?
01:31:14 <merijn> A bit, but unreadable code bugs me more
01:31:27 <merijn> And all alternatives so far make the readability ten billion times worse
01:31:42 <merijn> Besides, I mostly work on C code right now, repeated code all over the place...
01:32:10 <blah> but hella readable, am i right?
01:32:57 <merijn> It's C, of course it's not readable. So as a result you end up hacking templates in CPP and terrifying bachelor students that think they'll "quickly" hack the codebase for their thesis project :>
01:34:18 <blah> :)  anyway, it seems like some kind of "lift unless" exists and communicates what i want.
01:41:00 <roconnor> preflex: seen dibblego
01:41:00 <preflex>  dibblego was last seen on #haskell 3 hours, 49 minutes and 30 seconds ago, saying: yes, other languages have it -- but often it is so difficult, that it is not worth using
01:45:15 <koala_man> so insertion sort on a sorted list with d inversions runs in O(n+d)? why not O(n+nd)? it has to move on average n/2 elements for each inversion, right?
02:04:59 <merijn> If I have "cycle l" and repeatedly pop the first element, will I have roughly constant memory usage for that list? i.e. "foo (x:xs) = (some IO stuff); foo xs", ignoring memory used by the IO stuff, does "foo $ cycle [1]" have (roughly) constant memory usage for the list?
02:06:00 <roconnor> merijn: it should, if foo uses its argument linearly.
02:06:02 <shachaf> @src cycle
02:06:02 <lambdabot> cycle [] = undefined
02:06:02 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
02:06:14 <roconnor> merijn: note that repeat x = cycle [x]
02:06:30 <shachaf> In GHC it'll be an actual cyclic list in memory.
02:06:37 <merijn> roconnor: Yeah, I have an actual list though, was just simplifying my example :)
02:06:42 <roconnor> oh right
02:06:45 <roconnor> shachaf is right
02:06:47 <shachaf> (As opposed to e.g. cycle xs = xs ++ cycle xs)
02:06:56 <roconnor> it will use constant memory even if foo doesn't use it linearly
02:07:28 <merijn> Basically I want to distribute uniformly across a list of output Chan's and had this whole queue system and suddenly thought "why not just write to the first item of 'cycle outputs'" :)
02:07:30 <shachaf> (Well, maybe it would optimize the latter into the cyclic form. But in the former case it'll definitely do it.)
02:08:04 <merijn> oh, wait...
02:08:42 <merijn> I forgot that doing that will leave me no way to actually terminate all output Chan's when I'm done...
02:08:47 <merijn> Back to the drawing board
02:08:58 <earthy> add a marker
02:09:24 <shachaf> Yay, it's earthy.
02:09:29 <earthy> i.e.,  cycle (map Just xs ++ Nothing)
02:09:32 <merijn> earthy: Might as well just pass the list twice then, one finite for termination and one cycle
02:09:46 <earthy> yeah, that's also possible
02:12:59 <hpaste> merijn pasted “Cycling Chan's” at http://hpaste.org/66424
02:13:20 <merijn> This way seems simpler than having to complicate the logic to check for a "new" marker
02:13:53 <merijn> oh wait, wrong function composition in the top level >.>
02:16:32 <earthy> yep, seems clean
02:18:25 <roconnor> merijn: unnecessary use of $ ?
02:19:07 <merijn> roconnor: Oh, right. My original code concatenated two lists there
02:19:25 <merijn> Odd that HLint doesn't catch that on hpaste...
02:19:41 <roconnor> indeed
02:20:09 <roconnor> > cycle []
02:20:10 <lambdabot>   *Exception: Prelude.cycle: empty list
02:20:38 <roconnor> merijn: your program will crash if given an empty list of outputs
02:20:48 <merijn> Yeah
02:21:55 <merijn> It's a quick simulation hack to get some performance figures, error handling is optional (or superfluous even, in the finest tradition of academic software)
02:26:56 <merijn> @hoogle Maybe a -> (a -> m ()) -> m ()
02:26:57 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:26:57 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:26:57 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:29:11 <merijn> @hoogle Maybe a -> (a -> b) -> b -> b
02:29:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:29:12 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
02:29:12 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
02:30:00 <merijn> :t \f -> maybe (return ()) f
02:30:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
02:30:36 <merijn> I can't imagine this combinator not yet existing...
02:31:35 <Rmx> @djinn a -> b
02:31:36 <lambdabot> -- f cannot be realized.
02:31:48 <Rmx> @djinn a -> b -> a
02:31:49 <lambdabot> f a _ = a
02:31:59 <merijn> Rmx: const
02:32:02 <merijn> :t const
02:32:03 <lambdabot> forall a b. a -> b -> a
02:32:11 <merijn> > const 1 "foo"
02:32:12 <lambdabot>   1
02:32:19 <Rmx> yep
02:32:41 <Rmx> but I came across an article about @djinn
02:32:46 <Rmx> and I had to test it!
02:35:14 <liyang> merijn: traverse or traverse_ will work.
02:35:39 <liyang> or for / for_ for a flipped version.
02:35:57 <merijn> :t traverse
02:35:57 <lambdabot> Not in scope: `traverse'
02:36:10 <bitonic> @hoogle traverse
02:36:10 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:36:10 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:36:10 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
02:37:38 <jay_gridley> hello, is possible to tell haskell not to automatically escape quotes in input string?
02:37:54 <merijn> jay_gridley: What do you mean?
02:38:07 <merijn> Haskell doesn't automatically escape quotes
02:38:14 <jay_gridley> ahh, Show does
02:38:35 <merijn> Show prints a parsable representation, so it will add/escape quotes of String's, yes
02:38:47 <roconnor> jay_gridley: use putStr or putStrLn instead of print
02:39:11 <roconnor> jay_gridley: er maybe I'm guessing too much about your problem :)
02:41:03 <jay_gridley> I am printing value (type of String), but it is wrapped in type constructor, so, when I want to print it, I do it like putStrLn $ show myVal, cannot do it without Show
02:41:55 <jay_gridley> putStrLn myVal produce error, because myVal is type of (SStringVal String)
02:42:43 <bitonic> jay_gridley: you should just have a method YourType -> String
02:42:49 <bitonic> that extracts the string
02:43:17 <jay_gridley> bitonic: will try
02:43:24 <bitonic> if it's just a newtype with a string in it, you can just do 'newtype YourType = YourType {unYourType :: String}', and unYourType will be of type 'YourType -> String'
02:43:34 <danr> @djinn ((p -> q) -> p) -> p
02:43:34 <lambdabot> -- f cannot be realized.
02:44:07 <bitonic> @djinn (p -> q) -> p -> q
02:44:07 <lambdabot> f a = a
02:45:43 <t7> is there anyway to access the private bindings in a module
02:45:50 <t7> without including the whole source?
02:46:48 <zeiris> Have a module that exports everything, and then a "public interface" module that exports just the important bits?
02:47:05 <t7> its a module on hackage
02:47:43 <bitonic> t7: no you can't import non-exported stuff.
02:47:52 <t7> :(
02:47:57 <t7> code duplication
02:48:13 <zeiris> Bug package author to export the function :)
02:49:48 <t7> how can i feed CPP preprocessor defines to cabal?
02:50:11 <t7> because i can define RSA_TEST and it exports it
02:52:23 <t7> never mind
02:52:37 <ivanm> jay_gridley: un-wrap it?
02:53:12 <jay_gridley> ivanm: I've used what bitonic suggested and its done
02:57:31 <Franciman> hi all, can I ask for leksah related problem?
02:57:48 <bitonic> Franciman: sure
02:58:10 <bitonic> maybe if there's a #leksah it'd be more appropriate, but asking here is fine as well I guess
02:58:28 * ivanm glares at his internet connection
02:59:19 <Franciman> ok, when I build a source file, haskell comes out with this error : Setup: You need to re-run the 'configure' command. The version of Cabal being
02:59:19 <Franciman> used has changed
02:59:32 <Franciman> *leksah comes out with this error
02:59:49 * hackagebot sodium 0.2.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.2.0.0 (StephenBlackheath)
03:03:18 <Rmx> anyone tried Sodium here ?
03:03:52 <Rmx>  @djinn p -> p -> p -> p
03:04:05 <Rmx> @djinn p -> p -> p -> p
03:04:05 <lambdabot> f _ _ a = a
03:04:28 <ClaudiusMaximus> @pl \o f x y -> liftM2 (\(a, b) (c, d) -> (a `o` c, b `o` d)) (f x) (f y)
03:04:30 <lambdabot> join . ((flip . ((.) .)) .) . (.) . liftM2 . (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
03:05:52 <bitonic> yeeee
03:06:26 <ClaudiusMaximus> .. i guess i'll be pointy this time
03:08:28 <bitonic> ClaudiusMaximus: you can use (first o >>> second o)
03:08:51 <bitonic> ah, no
03:09:03 <bitonic> no yes, you can
03:09:25 <bitonic> :t \o f x y -> liftM2 (first o >> second o) (f x) (f y)
03:09:26 <lambdabot>     Couldn't match expected type `a2 -> r'
03:09:26 <lambdabot>            against inferred type `(b, c)'
03:09:27 <lambdabot>     In the second argument of `(>>)', namely `second o'
03:09:28 <ClaudiusMaximus> yeah i tried (-)***(-) but there's misc curry/uncurry needed somewhere i think
03:09:32 <bitonic> :t \o f x y -> liftM2 (first o >>> second o) (f x) (f y)
03:09:33 <lambdabot>     Couldn't match expected type `a2 -> r'
03:09:33 <lambdabot>            against inferred type `(c, c)'
03:09:33 <lambdabot>     In the second argument of `(>>>)', namely `second o'
03:10:57 <ClaudiusMaximus> :t \o f x y -> liftM2 (curry $ uncurry o *** uncurry o) (f x) (f y)
03:10:58 <lambdabot> forall t a b c (m :: * -> *). (Monad m) => (a -> b -> c) -> (t -> m (a, b)) -> t -> t -> m (c, c)
03:11:14 <bitonic> oh, right
03:12:15 <ClaudiusMaximus> @pl \o f x y -> liftM2 (curry $ uncurry o *** uncurry o) (f x) (f y)
03:12:15 <lambdabot> join . ((flip . ((.) .)) .) . (.) . liftM2 . curry . liftM2 (***) uncurry uncurry
03:13:22 <ClaudiusMaximus> :t \o f -> liftM2 (curry $ uncurry o *** uncurry o) `on` f
03:13:22 <lambdabot> forall a b c (m :: * -> *) a1. (Monad m) => (a -> b -> c) -> (a1 -> m (a, b)) -> a1 -> a1 -> m (c, c)
03:18:25 <ClaudiusMaximus> arg.  i have two numerical algorithms (f :: a -> Maybe b) (g :: b -> Maybe a), such that if the algorithms don't fail it should hold that (f =<< g b = Just b) (g =<< f a = Just a) -- howver, i'm getting inequalities despite algorithms not obviously failing - and i don't know which of f,g is/are to blame
03:18:25 <bitonic> ClaudiusMaximus: so the lesson here is that pl can be improved :P
03:20:59 <ClaudiusMaximus> any suggestions for detecting which of f,g is broken?  (feel free to assume that only one is broken)
03:21:21 <ivanm> maybe I'm going about this the wrong way
03:21:23 <int-e> ClaudiusMaximus: just curious, should f >=> g >=> f = f and g >=> f >=> g = g hold, or is either of f and g allowed to fail on the output of the other?
03:22:23 <ivanm> if I've got say a list of ascending non-repeated Ints, is there any way I can work out which values are missing from a consecutive listing? e.g. missing [1,2,4,7] = [3,5,6]
03:22:24 <int-e> ClaudiusMaximus: I think you can't, really. you can always take one as the specification and construct an inverse counterpart.
03:23:10 <t7> i need a large e and d for commutative RSA but the RSA lib doesnt like it :(
03:23:18 <t7> runs out of memorez
03:23:55 <merijn> ivanm: start with [1..] and filter out everything in your list, the result should be all the missing ones, no?
03:24:26 <ClaudiusMaximus> > concatMap (\(lo, hi) -> [lo + 1 .. hi - 1]) . (zip`ap`tail) $ [1,2,4,7] -- ivanm
03:24:28 <lambdabot>   [3,5,6]
03:24:29 <ivanm> merijn: well, I'm currently using Sets, and it's rather expensive...
03:24:52 <ivanm> ClaudiusMaximus: :o
03:24:55 <ivanm> that's nice!
03:25:15 <ClaudiusMaximus> :)
03:27:37 <ClaudiusMaximus> int-e: i think that property should hold in an ideal world - but it isn't~
03:28:54 <int-e> t7: uh do you have a small example program for that?
03:29:11 <merijn> Anyone have a good cheatsheet for haskell syntax for stuff like guards/case/etc
03:29:17 <t7> nah deleted it now
03:29:19 <t7> using xor
03:29:26 <t7> for ultimate security
03:30:01 <int-e> encrypt x = x `xor` x -- the ultimate, secure, xor encryption!
03:30:32 <romildo> Does anybody know a good translation of "flush the output" and "buffer mode" to Portuguese?
03:31:31 <bitonic> that is an intersting question for #haskell.
03:31:38 <int-e> t7: it's just that I don't understand why RSA should run out of memory, especially since at least one of e and d will always be large (same order of magnitude as phi(n) typically).
03:31:57 <t7> i guess it didnt like a big e
03:32:02 <t7> because e was hard coded
03:32:08 <t7> or maybe i messed up somewhere else
03:32:37 <koeien> "big e", you mean E ?
03:32:45 <koeien> capitalization is important in haskell.
03:32:49 <t7> e > 64k
03:33:05 <int-e> t7: but if you look at rsa_ep (encrypt) and rsa_dp (decrypt) in the library, you'll see that they use virtually identical code.
03:33:24 <romildo> bidigo, I asked here because I am preparing a class on functional programming using Haskell. The topic I am working is IO. And this terms appear in the documentation. So I thought my question could fit here.
03:33:27 <t7> must have been me then
03:34:15 <romildo> bidigo, I intended to answer bitonic, not you . Sorry.
03:34:21 <bidigo> no prob
03:38:45 <ivanm> ClaudiusMaximus: that definitely sped my program up!
03:38:49 <ivanm> just not enough :(
03:39:53 <ivanm> (I'm trying to ensure my usage of provided keys is dense and thus re-use those values that have been deleted, etc. ... but adding such functionality in is doubling runtime :s)
03:40:01 <int-e> koeien: fwiw, it was a lower case e, just containing a big value.
03:41:16 <merijn> ivanm: You're checking for free keys everytime you get a new key?
03:41:30 <t7> @hoogle shuffle
03:41:31 <lambdabot> package random-shuffle
03:41:39 <ivanm> merijn: yeah
03:41:40 <merijn> Why not keep a cache of free keys and append at the end if the cache is empty, then you just have to update your cache every so often
03:41:45 <ivanm> I started trying to cache deleted keys
03:41:49 <ivanm> the code got very fugly very fast
03:44:05 <merijn> @hoogle (a -> Bool) -> m () -> m a -> m ()
03:44:05 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
03:44:06 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
03:44:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:44:13 <ivanm> merijn: because the code got very fugly very fast
03:44:17 <merijn> @hoogle (a -> Bool) -> m a -> m () -> m ()
03:44:18 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
03:44:18 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
03:44:18 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:44:37 <ivanm> and if the cache is empty I need to generate new maximum ones, etc.
03:55:08 <t7> @hoogle IO b -> Int -> [b]
03:55:08 <lambdabot> Prelude replicate :: Int -> a -> [a]
03:55:08 <lambdabot> Data.List replicate :: Int -> a -> [a]
03:55:08 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
03:56:43 <t7> > replicate 3 randomIO
03:56:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:56:44 <lambdabot>    `System.Random.Random a'...
03:56:53 <t7> > replicate 3 (randomIO  :: IO Int)
03:56:54 <lambdabot>   [<IO Int>,<IO Int>,<IO Int>]
03:57:28 <bitonic> > replicateM 3 (randomIO :: IO Int)
03:57:29 <lambdabot>   <IO [Int]>
03:57:39 <bitonic> t7: lambdabot can't execute IO actions, for obvious reasons
03:58:30 <t7> @src replicate
03:58:30 <lambdabot> replicate n x = take n (repeat x)
04:03:15 <merijn> @pl \x y -> fromMaybe x (fmap return y)
04:03:16 <lambdabot> (. fmap return) . fromMaybe
04:03:34 <merijn> @pl \f -> fmap return f
04:03:34 <lambdabot> fmap return
04:06:30 <hpaste> t7 pasted “Decentralized shuffle” at http://hpaste.org/66425
04:07:32 <t7> super secure xor
04:19:00 <merijn> There's no convenient syntax for "do {x <- foo; if x then bar else baz}", right?
04:19:17 <merijn> I hate having to come up with superfluous names :(
04:20:20 <koeien> if' :: a -> a -> Bool -> a
04:20:38 <koeien> foo >>= if' bar baz
04:20:59 <merijn> Yeah, that's what I thought
04:21:10 <merijn> We need to steal Habit's case<- and if<- syntax...
04:22:00 <merijn> (Habit has "case<- foo of ..." which is identical to "x <- foo; case x of ...". Same for if)
04:28:25 <Cale> merijn: I would rather just have case sections
04:28:36 <t7> wow i can reduce alices encryption to only 4 possibilities
04:28:43 <t7> xor isnt so secure then
04:29:01 <Cale> merijn: i.e.  translate  case of ...  into  \fresh -> case fresh of ...
04:29:16 <Cale> merijn: then you don't need anything do-notation specific, you just use >>=
04:29:25 <Cale> foo >>= case of ...
04:29:44 <ivanm> merijn: anonymous case statements have been proposed before
04:29:52 <ivanm> I think it was just lack of someone willing to implement :p
04:30:10 <ivanm> interesting.... if I compile and run my program, I get an error; if I run it in ghci, it runs OK
04:30:14 <ivanm> yippee!!!!! :D
04:33:32 <Entroacceptor> a Heisenbug!
04:36:55 <dobblego> roconnor: hi
04:37:29 <ivanm> Entroacceptor: yup!
04:38:24 <roconnor> dobblego: where is dibblego?
04:38:36 <dobblego> he's busy at the office
04:38:42 <roconnor> I see
04:39:07 <roconnor> dobblego: do you have a proof that the results form joinL and returnL satify the lens laws?
04:39:29 <dobblego> no, I do not -- I was just playing and have no good use-case for it
04:39:38 <dobblego> I was on a train home, escaping dibblegoness
04:39:56 <roconnor> I'm worried that the results don't satify the required laws
04:40:03 <ivanm> how about dabblego?
04:40:05 <dobblego> that is quite possible, even likely
04:40:17 <roconnor> dobblego: I'm good with renaming maybeLens to justLens
04:40:23 <dobblego> yeah I think that is important
04:40:30 <roconnor> I agree
04:40:37 <dobblego> e.g. leftLens, rightLens, headLens, ?!maybeLens?!
04:40:41 <dobblego> cool
04:41:23 <roconnor> although it is such an important partial lens ... I wonder if it needs a shorter name :)
04:41:34 <dobblego> maybe an alias?
04:41:50 <roconnor> well, maybe we should stick with justLens for now
04:42:00 <dobblego> ok
04:42:34 <osa1> is there a way to see type of a inner function(a function defined in a `where` block) ?
04:42:49 <roconnor> osa1: not to my knowledge
04:43:00 <hpc> osa1: factor it out and use :t
04:43:07 <hpc> or give it a type signature, then look at it :P
04:43:20 <osa1> hpc: it uses lots of values from outer functions, it would be hard to get it out
04:43:22 <koeien> yeah that's a bit unfortunate osa1.
04:44:04 <roconnor> dobblego: I was worried that you were using joinL and returnL
04:44:19 <dobblego> roconnor: no, I was just thinking aloud, sorry
04:44:22 <roconnor> np
04:44:23 <stj> I'm using haskell-mode in emacs. After typing "when (c /= ' ') $ do" and pressing enter, then tab, I get weird indentation of 7 spaces -- anyone else experiencing this annoying and ugly behavior?
04:44:48 <dobblego> roconnor: your hunch that it doesn't satisfy the laws is similar to mine, hence the question
04:45:19 <hpc> stj: so it indents to just after the "c"?
04:45:32 <stj> hpc: yes
04:46:06 <hpc> "when ..." wouldn't happen to be indented one space, would it?
04:46:07 <ivanm> osa1: IIRC, you can kinda do it by giving it a bogus type and seeing what the type inferrer says it should be when you try loading it in ghci
04:46:20 <ivanm> did Simon Marlow end up implementing stack traces in ghc?
04:46:21 <hpc> could be that <tab> actually does a tab stop
04:46:28 <roconnor> dobblego: maybe dmwit can figure out what the categorical notion defines ||||| operation.  I'd like to have it; its just that I prefer to have laws for type classes ... granted my ColourOps type class doesn't have any laws ... though now that I think about it at least `over` is a monid action.
04:46:40 <roconnor> *monoid action
04:46:46 <dobblego> roconnor: totally agree
04:46:48 <hpaste> stj pasted “my haskell related configuratoin in .emacs” at http://hpaste.org/66428
04:46:59 <roconnor> dobblego: oh good :)
04:47:02 <dobblego> we were discussing it earlier with edwardk
04:47:15 <roconnor> I've been reading the logs over the last 2 days
04:47:17 <stj> hpc: I have when... inside main = do, and it's indented by two spaces
04:47:24 <dobblego> roconnor: I sat down yesterday and understood your problem well
04:47:31 <stj> hbc: it's not a tab stop
04:47:41 <roconnor> dobblego: sounds like every other lens library has this function ...
04:47:43 <hpc> huh, neat
04:47:52 <hpc> ive never used haskell-mode, so that's about as far as my debugging goes
04:47:53 <dobblego> roconnor: well, edwardk and I wrote the scalaz one
04:48:05 <roconnor> hah
04:48:08 <stj> hpc: what do you use?
04:48:09 <roconnor> so it isn't exactly independent :D
04:48:12 <dobblego> right
04:48:16 <hpc> i use vim
04:48:29 <dobblego> I wrote this paper for Scala Days 2012 http://dropbox.tmorris.net/media/doc/lenses.pdf
04:48:34 <hpc> with no plugins or anything; just the default syntax highlighting
04:51:49 <ivanm> oh, +RTS -xc
04:51:57 <ivanm> except it doesn't help all that much...
04:53:21 <roconnor> dobblego: :)
05:06:35 <t7> roconnor: You know a good commutative cipher?
05:06:43 <t7> cant find much online
05:06:55 <roconnor> t7: what does that mean again?
05:07:29 <t7> f(a) >>= f(b)   ==   f(b) >>= f(a)
05:08:12 <roconnor> what does >>= mean?
05:08:22 <t7> erm
05:08:24 <roconnor> maybe I shoudl ask what does cipher mean
05:08:40 <sipa> i think he just means fa . fb $ x == fb . fa $ x, for all x
05:08:51 <t7> if i encode a message with key 'a' and then encode it again with key 'b' the result will be the same as 'b' then 'a'
05:08:55 <sipa> ah
05:09:11 <sipa> f a . f b $ x == f b . f a $ x, for all a b and x
05:09:18 <sipa> and f is reversible
05:09:48 <roconnor> t7: wouldn't elgamel have this property?
05:10:28 * roconnor is speculating
05:10:57 <qnikst> t7 you can just use `xor` )
05:11:07 <t7> qnikst: i was using xor
05:11:13 <sipa> roconnor: i doubt that; elgamal adds an ephemeral key
05:11:19 <t7> but my message size is small and its really weak
05:11:20 <qnikst> it will be a bad cipher but it will be commutative
05:11:51 <t7> http://hpaste.org/66425   <-   i need to swap the key
05:11:57 <qnikst> if it's possible to use long key (as message size) then there will be no problems
05:11:58 <sipa> xor is extremely strong encryption - under the condition that your key is as long as the message, and only used once
05:12:05 <roconnor> t7: if your message size is smaller than your key then `xor` is a perfect cypher
05:12:22 <qnikst> sipa: it's very uncommon situation
05:12:23 <roconnor> oh right, and only used once :/
05:12:31 <sipa> roconnor: and randomly generated
05:12:39 <sipa> or rather, uniformly distributed
05:12:49 <roconnor> sipa: all keys should be randomly generated
05:12:56 <roconnor> well
05:13:02 <roconnor> I guess some are generated by hashes
05:13:06 <sipa> roconnor: no, but they should be indistinguishable from random
05:13:13 <t7> length $ filter (==standardDeck) $ map (sort . (\x -> map (encrypt x) alice_shuffled)) [0..255]  -- shows that 'a' can be 1 of 4 keys
05:13:25 <roconnor> sipa: oh right, to be perfect they should be randomly generated
05:13:33 <sipa> indeed
05:13:42 <mrBG> is there an oldschool video games channel on irc
05:13:43 <roconnor> but they are pretty damn good even if generated by a hash or whatnon
05:13:46 <roconnor> &whatnot
05:13:52 <mrBG> i need to ask about a specific game
05:14:00 <mrBG> http://www.youtube.com/watch?v=Q17oeFtLvvQ @1.49 in that movie
05:14:04 <mrBG> whats its name
05:16:04 <t7> i guess i can just share a deck of huge numbers first
05:16:09 <t7> would that work?
05:19:06 <t7> @hoogle m a -> m [a]
05:19:06 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
05:19:07 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
05:19:07 <lambdabot> Test.QuickCheck.Gen listOf :: Gen a -> Gen [a]
05:19:19 <t7> @hoogle m a -> [m a]
05:19:19 <lambdabot> Data.List inits :: [a] -> [[a]]
05:19:19 <lambdabot> Data.List permutations :: [a] -> [[a]]
05:19:19 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:20:29 <Ptival> mrBG: did you listen to the video? =__= it says it (Contra, spread gun)
05:32:08 <Ptival> to data structures savvy people: I'm looking for a data structure like a dictionary whose key space is hierarchically organized, such that insertion affects all keys in the hierarchy of the insert key (both upwards and downwards)
05:33:11 <Ptival> and such that lower keys are "allocated" lazily
05:34:18 <Ptival> (the hierarchy represent groups of lower-ranked keys, and low keys must only exist if they convey extra information that other members of the group do not share)
05:35:20 <dobblego> roconnor: I have made the changes discussed, completed the rename of Split to Product, maybeLens -> justLens and an export list on Data.Lens.Partial.Common
05:35:47 <roconnor> dobblego: um
05:36:02 <roconnor> I already renamed Split to Product
05:36:07 <roconnor> :/
05:36:16 <dobblego> you left some dangly bits
05:36:24 <roconnor> Oh?
05:36:26 <roconnor> okay
05:37:20 <dobblego> https://github.com/roconnor/data-lens/pull/4#commits-pushed-42b628b
05:41:26 <roconnor> dobblego: is it possible to "pull request" it into roconnor:2.9.0 ?
05:41:39 <dobblego> I believe so, yes
05:45:06 <Tinned_Tuna> Heya, I'm just looking at lambdabot, is there any documentation anywhere on the plugins, as in, developing plugins (I don't want to actually develop a plugin, I just want to see what would be involved)
05:47:48 <t7> @src when
05:47:48 <lambdabot> when p s = if p then s else return ()
05:51:37 <Tinned_Tuna> ugh, I sometimes feel that () is just Haskell's null...
05:51:50 <Cale> () is a one-element type...
05:52:11 <Cale> (or two, depending how you count ;)
05:52:36 <Jaak> yeap, ( and )
05:52:42 <Cale> Tinned_Tuna: if you can produce () as a result, it is the only defined value you can produce
05:52:51 <Cale> I mean () and undefined are both values of type ()
05:52:59 <Jaak> (i know)
05:53:03 <Tinned_Tuna> So, what does when do then:
05:53:05 <Tinned_Tuna> @src when
05:53:05 <lambdabot> when p s = if p then s else return ()
05:53:24 <koeien> when p s is equal to s if p, otherwise equal to return ()
05:53:28 <Cale> :t when
05:53:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:53:45 <koeien> for instance, when (x == 3) (putStrLn "x was equal to 3")
05:53:55 <Tinned_Tuna> Ahh, so s *must* be of type m ()
05:54:05 <Cale> It takes a boolean value, and an action x of type m (), and if the boolean value is true, the result is x, otherwise, it is return (), which is the action which "does nothing" and produces () as its result.
05:54:23 <Tinned_Tuna> yup, gotcha
05:54:36 <Tinned_Tuna> I was thinking that s could have a slightly more varied type
05:54:48 <Cale> You can tell from the definition that it would have to be m (), because its type has to match the type of return ()
05:55:16 <Cale> (so it's not that the type signature is arbitrarily restricted)
05:55:17 <Tinned_Tuna> Cale: unless, like me, you mistake that for being able to crop up in almost any m a
05:55:25 <Tinned_Tuna> rather than contraining that a to be () :-p
05:55:45 <Cale> right, () isn't a value of most types :)
05:55:55 <Tinned_Tuna> :-)
05:56:07 <Cale> Now, we could write something like   dangerWhen :: Bool -> m a -> m a
05:56:14 <Tinned_Tuna> My assumption of Haskell being a realatively safe language
05:56:19 <Tinned_Tuna> is safe again
05:56:21 <Cale> dangerWhen p s = if p then s else return undefined
05:56:43 <Tinned_Tuna> Unlike java, where public Integer doSomething(...) {... return null; }...
05:56:50 <Cale> yeah
05:56:53 <quicksilver> or you can write "ignoreMeWhen :: Bool -> m a -> m ()"
05:57:01 <Tinned_Tuna> is entirely reasonable and dangerous
05:57:07 <Cale> quicksilver's suggestion is good :)
05:57:19 <Cale> In fact, that *should* be the type of when
05:57:25 <Tinned_Tuna> :t when
05:57:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:57:59 <Cale> We can always turn any  x :: m a  into   x >> return () :: m ()
05:58:26 <Cale> :t let when p x = if p then x >> return () else return () in when
05:58:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m ()
05:58:48 <Cale> Or, you could do this...
05:59:00 <Cale> :t let when p x = if p then fmap Just x else return Nothing in when
05:59:00 <lambdabot> forall (f :: * -> *) a. (Monad f, Functor f) => Bool -> f a -> f (Maybe a)
05:59:05 <Cale> oh, derp
05:59:11 <Cale> :t let when p x = if p then liftM Just x else return Nothing in when
05:59:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m (Maybe a)
05:59:35 <Cale> (Monad ought to be a subclass of Functor, but it's not :P)
06:00:50 <Tinned_Tuna> Cale: how long until Haskell is brought in line with reality in that respect?
06:01:16 <Cale> I don't know
06:01:29 <Cale> It'll happen in GHC before it happens in Haskell-as-standardised
06:01:35 <Tinned_Tuna> It's not an issue which affects people by and large (from my experience), but I don't know how fast the Haskell standardisation process goes, or if it's even on the list.
06:01:42 <merijn> :t when
06:01:43 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:01:50 <Cale> The standard is supposed to document what exists
06:01:57 <koeien> Haskell has been too succesful.
06:02:15 <Cale> koeien: Though, we're seeing changes now...
06:02:21 <koeien> in 1997 this would have been fixed in an instant
06:02:35 <koeien> Cale: yeah this surprised me TBH (re the Num class constraints)
06:02:40 <Cale> yeah
06:02:48 <Tinned_Tuna> koeien: in 1997 I don't think I'd even her of functors or monads.
06:02:51 <Cale> Num is finally relatively fixed
06:02:55 <merijn> koeien: I was informed that Monad not requiring Functor was deliberate
06:03:12 <Cale> It's deliberate for a stupid reason
06:03:40 <Cale> By which I mean it *was* deliberate, but the rationale provided weren't good rationale.
06:03:41 <koeien> oh well, success also means good bindings to libraries so i can get more things done.
06:05:08 <Cale> Basically, the desire was for people to be able to write Monad instances where they want them and get on with their lives without having to provide an instance of Functor first, in the case that it's easier to do that. I think whoever suggested that wasn't thinking about the fact that you can provide superclass instances which use methods of the subclass.
06:05:31 <koeien> yes, that is actually pretty neat
06:05:42 <koeien> you can just write instance Functor X where fmap = liftM
06:05:43 <Cale> i.e. in this case, you can always write   instance Functor M where fmap = liftM
06:05:44 <Cale> yeah
06:16:01 <roconnor> Cale: that was a pretty silly oversight ... must have been a lot of ML thinking back then.
06:17:10 <Cale> I remember coming across the entire archive of the mailing list for the H98 standard process at one point. I wonder if it's still online.
06:18:12 <roconnor> Cale: but in the end we later found/invented Applicative, so the heirarchy was ruined anyways.
06:18:47 <Cale> Yeah, though it would still be nice to be able to assume that monads support fmap, even if we can't assume they support <*>
06:20:33 <roconnor> @type (<$>)
06:20:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:20:42 <roconnor> Cale: ya, that would be nice
06:21:19 <roconnor> because if they support fmap they support <$>
06:21:32 <quicksilver> Cale: I couldn't find it the last couple of times I looked. Which doesn't mean it isn't online of course.
06:21:51 <sabrehagen> i'm trying to use the splitOn function from Data.List.Split but when i say import Data.List.Split i get the error 'could not find module Data.List.Split'. why is this?
06:22:04 <quicksilver> maybe you haven't installed the package sabrehagen ?
06:22:24 <sabrehagen> hmm...okay. it's it a basic function?
06:22:27 <Cale> sabrehagen: Yeah, it's probably because the split package isn't installed.
06:22:35 <sabrehagen> quicksilver, do i use cabal to install?
06:22:38 <Cale> cabal install split
06:22:44 <sabrehagen> Cale, thanks
06:33:32 <sabrehagen> now i'm trying to convert a list of strings to ints using show (map (\x -> read [x]::Int) (splitOn "\n" numbers)) but it's not working. i assume this is because splitOn is being called for every map. i've also tried puting splitOn into a separate list and mapping to that, but to no avail.
06:33:55 <koeien> splitOn "\n" is just lines
06:34:11 <sabrehagen> koeien, my file is line delimeted
06:34:18 <koeien> i mean, lines is a Prelude function
06:34:21 <koeien> :t lines
06:34:22 <lambdabot> String -> [String]
06:34:28 <t7> 2 ^ x = y   can i reange that to solve for x?
06:34:40 <koeien> t7: yes. google for "logarithm"
06:34:41 <teneen> Are ZipLists Monads? Why?
06:34:48 <koeien> teneen: no, but i forgot the reason.
06:35:01 <sabrehagen> koeien, i'll look into that
06:35:16 <bscarlet> sabrehagen: how is it not working?
06:35:18 <koeien> sabrehagen: but your mistake is somewhere else. why did you use [x] instead of just x ?
06:35:29 <dobblego> teneen: no, because the Applicative does not correspond to ap
06:35:38 <dobblego> (<*>) /= ap
06:35:54 <sabrehagen> koeien, i'm new to haskell and i'm using something i found on stack overflow :$
06:36:08 <koeien> sabrehagen: no problem.
06:36:31 <koeien> in haskell the best way to think about things is often in terms of types.
06:36:38 <teneen> dobblego: But this is not part of the monad laws, is it?
06:36:45 <sabrehagen> koeien, okay, go on
06:37:02 <koeien> sabrehagen: so, you have a large String that corresponds to your input
06:37:08 <sabrehagen> koeien, are you saying there's a discrepancy between \x and [x]?
06:37:10 <koeien> you chop that into the lines with "lines"
06:37:17 <koeien> sabrehagen: no
06:37:27 <koeien> then you map over it. so we look at the type of map
06:37:28 <koeien> :t map
06:37:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:37:31 <dobblego> teneen: no, it isn't, but it is part of the de facto laws about Monad/Applicative/Functor
06:37:53 <koeien> so in our case, [a] = [String] (the lines of your input), so a = String. similarly, you wanted to read integers, so b = Integer
06:38:00 <dobblego> teneen: similarly, we do not write Monad instances such that liftM /= fmap
06:38:10 <koeien> so you should pass to map a function of type String -> Integer
06:38:16 <dobblego> (although, doing so would violate laws so not exactly similarly)
06:38:28 <sabrehagen> koeien, okay, i'm with you
06:38:40 <koeien> sabrehagen: cool. well \ introduces an "anonymous function".
06:38:42 <teneen> dobblego: I see
06:38:46 <roconnor> granted it is pretty much impossible, for techincial reasons, to have liftM /= fmap.
06:38:54 <roconnor> even if you tried.
06:38:59 <sabrehagen> koeien, okay, i don't think i've come across them yet...
06:39:00 <quicksilver> teneen, koeien : you can make ZipLists monads using a join which "takes the diagonal": element 1 of list 1, element 2 of list 2, etc. This works for infinite lists and it works for "lists which are all teh same length".
06:39:00 <dobblego> teneen: there is no way to write a Monad for ZipList such that ap=(<*>)
06:39:08 <roconnor> the best you could do is along the lines of fmap = undefined.
06:39:32 <koeien> sabrehagen: then forget about them for a moment. just write a function, let's call it "readInteger", that takes a String and yields an Integer
06:39:49 <koeien> sabrehagen: so at toplevel, add readInteger :: String -> Integer; readInteger = read
06:39:49 <sabrehagen> koeien, alright, i'll do that as practice and come back to you
06:39:53 <teneen> roconnor: example of such a case?
06:40:53 <koeien> sabrehagen: cool.
06:40:56 <teneen> quicksilver: Can you show an example?
06:41:19 <sabrehagen> koeien, the only bit i don't get about that is 'readInteger = read'. surely read should have some inputs right? or is it implicit?
06:41:37 <sabrehagen> shouldn't it be readInteger a b = read a b
06:41:57 <koeien> that's implicit.
06:42:10 <koeien> but read should take only one argument, not two
06:42:41 <sabrehagen> koeien, oh whoops, yeah. i'm still getting used to haskell syntax
06:42:53 <quicksilver> teneen: well, join [[1,2,3],[4,5,6],[7,8,9]] = [1,5,9]
06:43:27 <koeien> but it's implicit, sabrehagen. read = readInteger is the same as read x = readInteger x (except for a detail that i don't care about at the moment.)
06:43:53 <teneen> quicksilver: Ohh, ok thanks!
06:43:54 <quicksilver> (technically, but more noisily, written as : join (ZipList [ZipList [1,2,3],ZipList [4,5,6],ZipList [7,8,9]] = ZipList [1,5,9] )
06:43:54 <sabrehagen> koeien, okay, gotcha
06:44:12 <koeien> sabrehagen: so, now you can write  map readInteger (lines input)
06:45:20 <koeien> sabrehagen: does that work for you?
06:45:41 <teneen> quicksilver: is such an instance useful in real life? or it is just a proof of concept?
06:45:47 <sabrehagen> koeien, that makes sense, and i'm sure it will. i'm getting an annoying error now because of "possibly incorrect indentation" when using do
06:45:57 <koeien> sabrehagen: could you paste your code?
06:46:00 <koeien> @hpaste
06:46:00 <lambdabot> Haskell pastebin: http://hpaste.org/
06:46:07 <quicksilver> teneen: not sure, really. I imagine you can find ways to use it if you try really hard.
06:46:30 <zhulikas> > join [1,2,3]
06:46:31 <lambdabot>   No instance for (GHC.Num.Num [a])
06:46:31 <lambdabot>    arising from a use of `e_1123' at <int...
06:46:36 <sabrehagen> koeien, is 7 lines okay to paste here?
06:46:42 <koeien> no, hpaste
06:46:52 <sabrehagen> okay
06:47:22 <hpaste> sabrehagen pasted “indentation error” at http://hpaste.org/66429
06:47:34 <sabrehagen> wow, that's handy :)
06:47:47 <merijn> sabrehagen: Are you using tabs?
06:47:51 <koeien> sabrehagen: you missed a ) I think
06:48:05 <int-e> yea
06:48:05 <sabrehagen> no, all spaces
06:48:06 <danr> sabrehagen: yes, you're missing a parenthesis
06:48:11 <int-e> putStrLn (show (map readInteger (lines numbers)) <- )
06:48:13 <sabrehagen> duuuuuhhhhhhh.............
06:48:17 <quicksilver> merijn: he's not, you can tell by dragging a selection around. (at least in my browser you can)
06:48:27 <merijn> sabrehagen: btw, "print = putStrLn . show"
06:48:29 <sabrehagen> sorry guys...
06:48:34 <teneen> quicksilver: Last but not least, will that instance retain the property "ap == <*>" ? as dobblego mentioned
06:48:50 <t7> YEESSSS
06:48:55 <sabrehagen> merijn, thanks, i'll use that in future :)
06:49:16 <int-e> sabrehagen: print $ map readInteger (lines numbers) -- less likely to make such mistakes when using fewer parentheses :)
06:49:20 <t7> my RSA commutative works :)
06:49:24 <saml> hey, give me some programming quizzes that could be completed under 30 mintues
06:49:32 <merijn> sabrehagen: You can simplify the last line to: "print . map readInteger . lines $ numbers"
06:49:44 <quicksilver> teneen: yes, it would
06:49:59 <quicksilver> teneen: (for the 'ap' corresponding to my new 'join', not the normal 'ap' for [])
06:50:00 <sabrehagen> merijn, that syntax confuses my head still a bit at my early stage
06:50:08 <koeien> saml: define f n | mod n 2 == 0 = n `div` 2; | otherwise = 3*n+1. does iterate f x always contain 1 for any x >= 1 ?
06:50:31 <teneen> quicksilver: I see. Thanks a lot!
06:50:40 <sabrehagen> hmm...what does ExerciseFour: Prelude.read: no parse
06:50:40 <sabrehagen>  mean?
06:50:52 <saml> koeien, that's more of a math question
06:50:58 <merijn> sabrehagen: "(f . g) x = f (g x)", you can read it as pipeline, put numbers into lines, put the result of that into "map readInteger" and the result of *that* into print
06:51:01 <koeien> sabrehagen: you entered something which is not an integer (perhaps a blank line?)
06:51:09 <saml> maybe with coding, answers could be easily found
06:51:18 <merijn> sabrehagen: It means you try to read something which doesn't match your input type.
06:51:21 <koeien> saml: i was joking with you :) this is a well-known unsolved problem.
06:51:26 <merijn> > read "test" :: Int
06:51:27 <lambdabot>   *Exception: Prelude.read: no parse
06:51:29 <saml> what's 3*n+1 ? prime?
06:51:30 <merijn> > read "1" :: Int
06:51:31 <lambdabot>   1
06:51:38 <saml> koeien, what's the name of the problem?
06:51:47 <sabrehagen> koeien, ahh i see
06:51:53 <koeien> saml: "hailstone numbers" / collatz conjecture
06:52:07 <sabrehagen> koeien, nice! that part is sorted. thank you :)
06:52:18 <saml> do you think those or "euler problems"  are good for interview coding tests?
06:52:22 <saml> job interview
06:52:25 <merijn> saml: Terrible
06:52:28 <koeien> not really
06:52:32 <t7> this is so awesome
06:52:32 <merijn> saml: They're all math and almost no coding
06:52:37 <saml> i'm trying to hire people.. not sure what coding questions to ask
06:52:43 <koeien> I would do way better than my coding ability
06:52:51 <koeien> many people would do worse
06:52:56 <saml> should i ask  stuff from functional pearls?
06:53:01 <koeien> but it depends on the exact position
06:53:05 <qnikst> saml: about project that you want them to work on :)
06:53:05 <merijn> saml: "What's the last cool thing you did? Why was it cool? Explain the trickiest problem you encountered? How did you solve it?"
06:53:58 <saml> no.. those will be in person.. i want some simple coding questions  that they can do in their leisure  before they come in.
06:54:07 <saml> sort of like pre-screening tests for haskell programmers
06:54:13 <koeien> oh, just ask a fold on a tree or something
06:54:30 <koeien> do you require /assume haskell knowledge?
06:54:58 <saml> not really... just basic stuff  like walking a tree  etc
06:55:10 <saml> i want the candidate to complete in any language
06:55:19 <roconnor> t7: RSA with the same modulus and different exponents?
06:55:25 <t7> yeah
06:55:38 <koeien> i'd ask basic stuff like folds on a tree. "find the sum of all leaves of a tree", and things like this
06:55:58 <roconnor> t7: that means that essentially a and b have the same private key
06:56:01 <saml> but simply asking "walk this tree breadth first with constant space" isn't as good as a question where the candidate has to figure out the problem is about walking a tree...etc.
06:56:07 <roconnor> t7: or some agent handed out private keys to them.
06:56:07 <bitonic> replace all the values in a tree with the maximum value, traversing the tree once
06:56:17 <t7> yeah...
06:56:23 <t7> shit
06:57:03 <t7> lol
06:57:23 <t7> what the hell kinda algo am i gonna implement mental poker with
06:57:35 <t7> no actually
06:57:36 <roconnor> t7: do any of these semi-homomorphic encryption schemes do what you want, or whatever they are called?
06:57:41 <t7> they can share p and q freely
06:58:07 <sabrehagen> so i can research functions of name x, what is it called when you have an in place function of the form (\x -> ....)
06:58:10 <roconnor> t7: why can they share p and q freely?
06:58:25 <t7> because they have to factor someone elses e still
06:58:28 <koeien> sabrehagen: this is  called an "anonymous function" or a "lambda function"
06:58:36 <t7> 1 < e < phi
06:58:36 <koeien> (the \ resembles a lambda)
06:58:37 <sabrehagen> koeien, okay, thanks :)
06:58:38 <roconnor> t7: inverting e is easy given p and q.
06:58:53 <koeien> it is a value that is a function, it has no name
06:59:01 <koeien> for example:
06:59:07 <koeien> > map (\x -> x + 1) [1,2,3]
06:59:08 <lambdabot>   [2,3,4]
06:59:12 <t7> still gonna take longer than a game of poker
06:59:20 <t7> a hand*
06:59:21 <roconnor> t7: given p and q, we can compute phi(pq) easily, and then we can compute the inverse of e mod phi(pq) easily.
06:59:34 <roconnor> t7: not really, it is trivial
06:59:37 <koeien> t7: huh? no. if p and q are known, you can calculate d
06:59:42 <koeien> in fact, this is how it is done at key generation
06:59:44 <merijn> sabrehagen: Are you familiar with other programming languages already? If so, which one(s)?
06:59:55 <t7> how does SRA work?
06:59:59 <t7> im doing it wrong
07:00:02 <roconnor> t7: it will take a few mircoseconds to compute.
07:00:26 <koeien> RSA works because a^phi(n) = 1 mod n
07:00:26 <sabrehagen> merijn, c, java, VB, little c++, perl, and english :P
07:01:00 <roconnor> t7: have you looked at the Paillier cryptosystem yet?
07:01:13 <t7> no i will have a look
07:03:11 <t7> roconnor: looks perfect
07:03:14 <merijn> sabrehagen: Hmm, you know have Java has anonymous classes? i.e. because you don't really care enough about them to give them a name...
07:03:20 <t7> has anyone implemented this in haskell yet? :3
07:03:30 <roconnor> not to my knowledge
07:03:36 <roconnor> but there is a lot of stuff on hackage
07:03:41 <koeien> it's not a good idea to do so, except for educational purposes
07:03:45 <merijn> sabrehagen: "\x -> ..." is similar, but for functions. i.e. you define a function inline without bothering to give it a name
07:03:55 <sabrehagen> ahh yes, that's true, i do remember our lecture mentioning that...
07:04:18 <roconnor> t7: pish posh, I say ignore koeien's objections
07:04:21 <merijn> "foo = \x -> 2*x" is the same as "foo x = 2*x"
07:04:22 <sabrehagen> merijn, do you find that once you go functional, you never want to go back?
07:04:28 * roconnor says the guy who implemented ECC
07:04:32 <koeien> sabrehagen: definitely!
07:04:56 <t7> well its only for a game
07:04:57 <merijn> sabrehagen: I wouldn't say never, for some cases other languages can just be nicer. But you're way of writing programs (even non-functional ones!) will be permanently altered :p
07:05:29 <sabrehagen> merijn, yeah i'm starting to see that. it's quite a different way of thinking - especially in terms of side effects.
07:05:41 <roconnor> t7: AFAIK, the only reason not to reimplement cryto algorithms yourself is worries about side-channel attacks.
07:06:11 <merijn> sabrehagen: But since haskell has higher order functions we don't always feel like coming up with a name just to use a function once, i.e. "foo x = 2*x; map foo" we just want to use it once and forget about. Anonymous functions let us do this by allowing "map (\x -> 2*x)", now we don't have to try and think of a good name
07:06:27 <mauke> did someone say perl?
07:06:31 <koeien> immutability / separating side effects is something that is also very useful in the imperative world
07:06:53 <sabrehagen> merijn, sure, like a little once of handy tool that is really only needed for that situation and can help with compactness
07:07:13 <merijn> sabrehagen: Yes, that's pretty much all there is to it
07:07:22 <sabrehagen> ;t map
07:07:25 <sabrehagen> :t map
07:07:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:07:55 <merijn> > map (\x -> 2*x) [1..10]
07:07:56 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
07:08:14 <merijn> (Although in haskell you don't need a lambda for that)
07:08:19 <merijn> > map (2*) [1..10]
07:08:20 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
07:09:11 <sabrehagen> merijn, ahh that's right, i remember \ being called lambda now. it's often hard to take in all the detail when you're in a lecture. little bits come back to you when you hear them mentioned down the track and the puzzle pieces start fitting together
07:09:23 <sabrehagen> hence lambda functions
07:10:13 <merijn> They're named after the lambda calculus where everything is a function. And the \ was chosen because it's ASCII but still looks like a lambda
07:10:43 <koeien> is there a separate lambda that is not the Greek lambda in unicode?
07:10:55 <sabrehagen> merijn, gotcha :)
07:11:10 <merijn> koeien: No, I think
07:11:18 <quicksilver> yes, there are severl
07:11:26 <quicksilver> amusing mispelt as LAMDA I believe
07:11:33 <Tinned_Tuna> map (**2) [1..10] :: [Int]
07:11:36 <Tinned_Tuna> >map (**2) [1..10] :: [Int]
07:11:37 <Tinned_Tuna> > map (**2) [1..10] :: [Int]
07:11:38 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
07:11:38 <lambdabot>    arising from a use of...
07:11:40 <t7> roconnor: found an implementation on google
07:11:51 <t7> encryption involves finding a prime !
07:11:59 <t7> this is gonna be slow
07:12:02 <quicksilver> they're outside the BMP though
07:12:08 <quicksilver> (most maths stuff is outside the BMP)
07:12:09 <quicksilver> http://unicode-search.net/unicode-namesearch.pl?term=LAMDA
07:12:19 <sabrehagen> merijn, i altered my function to use a lambda function, i.e. print (sum (map (\x -> read x::Int) (lines numbers))) and i only added the ::Int after getting an error message and remembering how i'd seen it structured before. I don't really understand how the ::Int works or why it is applied in that form, that is, with two colons.
07:12:33 <koeien> sabrehagen: :: means a "type signature"
07:12:39 <merijn> sabrehagen: Read can return any type
07:12:49 <merijn> sabrehagen: The compiler figures out which one you want from the context
07:12:50 <koeien> the reason that you need one here is that the compier cannot know which type you meant
07:12:57 <sabrehagen> ahh, so you're explicitly specifying it's return type?
07:12:59 <merijn> But sometimes it cannot tell, so you have to specify
07:13:02 <koeien> sabrehagen: yes
07:13:09 <koeien> sabrehagen: most of the time it's inferred
07:13:13 <merijn> > read "1"
07:13:13 <sabrehagen> gotcha
07:13:14 <lambdabot>   *Exception: Prelude.read: no parse
07:13:17 <merijn> > read "1" :: Int
07:13:18 <lambdabot>   1
07:13:23 <merijn> > read "1" + 2
07:13:24 <lambdabot>   3
07:13:34 <koeien> merijn: defaulting at work there.
07:13:41 <int-e> > read "()" -- lambdabot uses extended defaulting
07:13:41 <lambdabot>   ()
07:13:45 <merijn> Ah
07:13:48 <sabrehagen> haha gotcha
07:14:00 <ion> “extended” defaulting?
07:14:18 <merijn> sabrehagen: In general the compiler checks "where is it used and what type does that want?" and then assumes that that was the read instance you meant
07:14:22 <koeien> quicksilver: ah i see. i cannot use them for \ i suppose.
07:14:25 <int-e> haskell98 only has defaulting for numeric classes, Num, Floating.
07:14:36 <merijn> Obviously (in the "read "1"" example) it sometimes cannot tell from context
07:14:56 <ion> Found it: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html#extended-default-rules
07:15:00 <int-e> haskell2010 is probably the same?
07:15:08 <sabrehagen> merijn, right, so sometimes you can leave off the ::x if the compiler can work out what you want?
07:15:16 <koeien> yes, almost always in fact
07:15:17 <merijn> sabrehagen: Most times, most likely
07:15:31 <koeien> sabrehagen: the :: is not special that it can only be used in a lambda
07:15:35 <merijn> sabrehagen: The compiler is very good at inferring what you wanted :p
07:15:39 <koeien> sabrehagen: it can be used on any expression. for example
07:15:43 <koeien> > 3 :: Float
07:15:44 <lambdabot>   3.0
07:15:52 <merijn> > maxBound :: Char
07:15:53 <lambdabot>   '\1114111'
07:15:55 <merijn> > maxBound :: Int
07:15:56 <lambdabot>   9223372036854775807
07:15:58 <koeien> but the compiler *will* check it, it's not a "cast" like in C
07:16:11 <koeien> > 3 :: Bool
07:16:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:16:11 <lambdabot>    arising from the literal `3'...
07:16:22 <quicksilver> koeien: I think the general feelings is that giving different meanings to characters which, whilst technically different, are rendered almost the same, is probably not a good idea.
07:16:24 <koeien> this is a difficult way of saying that booleans are not numbers
07:16:35 <quicksilver> koeien: these is a discussion of it in a bug report somewhere.
07:16:41 <sabrehagen> merijn, koeien, these are only for functions that in java would be called overloaded right? you can't just do this for any function? or is it function composition?
07:16:46 <merijn> sabrehagen: Although understanding the maxBound example depends on understanding typeclasses
07:16:53 <koeien> quicksilver: that's a reasonable criticism. also you don't want to use the "real" lambda, because there are Greek people who might want to use it.
07:16:59 <Lemmih>  > 0 :: Bool
07:17:00 <int-e> yes, haskell2010 is the same, see http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
07:17:01 <lambdabot> False
07:17:17 <quicksilver> koeien: exactly.
07:17:43 <mauke> > False :: 1
07:17:44 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
07:17:45 <lambdabot>         against inferred t...
07:17:49 <merijn> sabrehagen: It's a bit complex to explain simply, though and I have to run. But maybe someone else has time
07:18:00 <koeien> sabrehagen: :: works on any expression.
07:18:06 <sabrehagen> merijn, no worries
07:18:12 <sabrehagen> koeien, merijn, thanks for your help guys. that got me through that exercise i had to complete by midnight. off to bed now, and back at it tomorrow morning. thanks for your time and patience :)
07:18:34 <sabrehagen> koeien, good to know, i'll experiment with it. thanks!
07:19:39 <int-e> and ghc's "extended defaulting" is described at http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html#extended-default-rules
07:22:44 <t7> roconnor: whats the maximum size integer i can encrypt and decrypt with this
07:22:58 <t7> it seems to be just above  2 ^ (keysize - 1)
07:23:11 <roconnor> I'm not sure; I've never used it
07:23:28 <roconnor> says in wikipedia that m is in Z_n
07:23:29 <koeien> which scheme?
07:23:59 <t7> what does that mean? blackboard z to the lower 2
07:24:03 <t7> maths...
07:24:16 <roconnor> t7: where
07:24:21 <koeien> Z_m means "integers modulo m"
07:24:33 <koeien> (sometimes also the m-adic integers, but not in this context)
07:24:44 <mauke> ℤ₂
07:25:01 <t7> ah ok
07:25:21 <roconnor> I would be surprised if ℤ₂ occurs anywhere here
07:25:55 <t7> hmm pq is gonna be dynamic tho
07:26:43 <roconnor> t7: possibly this scheme doesn't do what you want
07:26:58 <t7> no it should be fine
07:27:12 <t7> as long as p and q are garanteed to be above something
07:28:43 <Tinned_Tuna> Is anyone familiar with the System.Plugins package?
07:29:28 <Tinned_Tuna> And if yes, where I can I find some relatively thorough documentation? I've been looking for a short while and I can't seem to see much.
07:31:14 <t7> ah awesome this is easy
07:31:24 <antibot> > let if' a b c = if a then b else c in if' <$> pure True <*> print 1 <*> print 2
07:31:25 <lambdabot>   <IO ()>
07:31:48 <Tinned_Tuna> @src pure
07:31:48 <lambdabot> Source not found. Maybe you made a typo?
07:32:10 <quicksilver> it's a method so it's implementation varies by instance
07:32:16 <quicksilver> incidentally @src is not a useful tool.
07:32:28 <quicksilver> it is sketchy in what it contains and some of it is lies.
07:34:03 <koeien> it's useful for educational purposes like map, foldr, and so on
07:34:27 <Tinned_Tuna> <3 education
07:37:58 <antibot> Why is Applicative so strict?
07:40:20 <roconnor> strict?
07:40:51 <antibot> both 1 and 2 are printed if you say "let if' a b c = if a then b else c in if' <$> pure True <*> print 1 <*> print 2"
07:41:26 <roconnor> antibot: one of the fundamental properties of applicative is that you cannot chose actions based on the results of another action.
07:42:02 <antibot> Nothing in applicative doc says that it's anti-lazy.
07:42:20 <roconnor> antibot: it isn't a laziness issue
07:42:57 <roconnor> well, not a laziness issue in the traditional sense.
07:43:30 <scooty-puff> is it possible to infer principal types in a system that has extensible records, where record subtyping is possible, but coercion is not explicit (where a subtype is any extension of a supertype - i.e. {x: t} is a supertype of {x: t, y: t'})?
07:43:42 <danr> > let if' a b c = if a then b else c in execWriter (if' <$> pure True <*> tell [1] <*> tell [2])
07:43:43 <lambdabot>   [1,2]
07:44:20 <scooty-puff> i know its possible if coercion is explicit - since it can be embedded in haskell in such a way and have types inferred correctly
07:44:20 <roconnor> antibot: your expression is equivalent to do { a <- return True; b <- print 1; c <- print 2; return (if a then b else c)}
07:44:38 <scooty-puff> (not exactly a proof..)
07:48:07 <dannyg> any tips on debugging a haskell program that hangs? I tried the debugger, but it seems to stop at a simple tuple creation: http://pastebin.com/dh65P0sm
07:48:09 <mauke> The paste dh65P0sm has been copied to http://hpaste.org/66433
07:51:07 <t7> roconnor: how do i use this for commutative encryption then ?
07:51:27 <roconnor> um
07:51:34 <t7> i understand D(E(m1) * E(m2)) = m1 + m2
07:51:42 <t7> but i duno how that helps
07:52:00 <roconnor> t7: It doesn't give you commutative encryption, but I though it might give you a property that is useful enough.
07:53:57 <koeien> this is called "homomorphic encryption", it can be useful in secure multiparty computation
07:54:14 <roconnor> koeien: each party generates a different random r
07:54:15 <roconnor> er
07:54:24 <roconnor> t7: each party generates a different random r
07:54:28 <t7> im not sure this is what i need :(
07:55:00 <roconnor> t7: maybe you can give a high level description of the properties you want
07:56:10 <t7> i need to be able to encrypt information with different keys, and decrypt again in a different order
07:56:33 <koeien> i think that works with RSA as well, doesn't it?
07:56:46 <koeien> oh! no, maybe not.
07:57:36 <roconnor> t7: higher level than that
07:57:44 <roconnor> why do you want to do this?
07:58:56 <t7> shuffle cards securely without a third party
07:59:01 <t7> 'mental poker'
08:00:17 <roconnor> t7: can you just use DH secret exchange?
08:01:12 <koeien> you could maybe use elgamal
08:01:15 <t7> i dont think so,
08:01:27 <roconnor> t7: describe shuffle cards securely
08:01:30 <t7> i need to be able to decrypt the value of the card again w
08:01:56 <t7> http://en.wikipedia.org/wiki/Mental_poker   read shuffling cards using commutative encryption
08:02:06 <t7> its quite elegant and simple really
08:02:17 <Clint> is there an elgamal library on hackage that's not bindings-gpgme?
08:02:31 <Saizan> scooty-puff: this one claims completeness of type inference without explicit coercion iirc http://legacy.cs.uu.nl/daan/pubs.html#scopedlabels
08:03:14 <Saizan> scooty-puff: you can't parametrize functions over labels though, iirc
08:04:01 <Clint> why do i get "Data/Conduit/Cereal.hs:41:23-41: Irrefutable pattern failed for pattern Data.Serialize.Get.Fail s"?
08:04:14 <koeien> t7: ElGamal is commutative I think
08:04:47 <t7> ah cool
08:05:05 <koeien> everybody works in the same cyclic group
08:05:12 <roconnor> man
08:05:16 <roconnor> I said ElGamal
08:05:25 <roconnor> sipa shot me down
08:05:37 <koeien> sipa?
08:05:47 <sipa> *smoking gun*
08:05:51 <koeien> ah!
08:06:08 <koeien> it has been two years+ since i took this course
08:07:44 <t7> ah man theres no haskell code
08:07:57 <t7> time for my first hackage package perhaps
08:08:45 <koeien> ElGamal is not that difficult to do. but there are probably a lot of caveats (re key selection and so on)
08:10:34 <mraxilus_> how can I use takeWhile to take upto and including the element that breaks the condition.
08:11:07 <t7> http://www.antifraudlabs.com/presentations/pages/security_comm_RSA.aspx this page talks about using rsa by sharing p and q :|
08:12:07 <parcs`> :t uncurry (++) . second (take 1) .: partition
08:12:08 <lambdabot>     Couldn't match expected type `((d, [a]), (d, [a]))'
08:12:08 <lambdabot>            against inferred type `[a1] -> ([a1], [a1])'
08:12:08 <lambdabot>     Probable cause: `partition' is applied to too few arguments
08:12:19 <parcs`> :t (uncurry (++) . second (take 1)) .: partition
08:12:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:12:34 <fetter_oml> good afternoon to you :)
08:12:35 <koeien> t7: yes, but there e is not shared.
08:12:45 <parcs`> > ((uncurry (++) . second (take 1)) .: partition) (=='a') "ohai"
08:12:47 <lambdabot>   "ao"
08:12:50 <koeien> t7: that is possible as well. but there is no "public key" there.
08:13:02 <t7> koeien: wtf that is what i had before
08:13:12 <parcs`> oops partition doesn't do what i thought it does
08:13:15 <t7> you guys convinced me it was insecure
08:13:25 <koeien> it's insecure if you also give e or d
08:13:36 <parcs`> > ((uncurry (++) . second (take 1)) .: span) (=='a') "ohai"
08:13:37 <t7> god damnit
08:13:38 <lambdabot>   "o"
08:14:03 <koeien> from p,q and e (or d) you can find d (or e)
08:14:07 <parcs`> > ((uncurry (++) . second (take 1)) .: span) (/='a') "ohai"
08:14:08 <t7> koeien: so i can share p and w
08:14:08 <lambdabot>   "oha"
08:14:13 <t7> q*
08:14:19 <t7> phew i still have the code
08:14:24 <koeien> yes, it's bsaically the same as ElGamal though
08:14:54 <koeien> they depend on different assumptions of "hardness"
08:15:24 <roconnor> t7: oh neat
08:15:25 <hpaste> t7 pasted “codez” at http://hpaste.org/66434
08:15:31 <roconnor> t7: both parties keep d and e a secret
08:15:46 <roconnor> t7: I didn't know this
08:15:51 <parcs`> mraxilus_: takeWhile p xs ++ take 1 (dropWhile p xs)
08:16:01 <roconnor> I mean, I didn't know that it was okay for your question to have this property
08:16:11 <koeien> mraxilus_: look into "span"
08:16:30 <t7> awesome, now i just have to implement the poker protocol
08:16:58 <koeien> in general you can choose stupid values of p and q. but here that's not a problem I think. absolutely unsure
08:17:54 <koeien> (if you choose p and q very close or very far apart, factorizing becomes easier)
08:18:30 <koeien> also you want phi(n) to have certain properties in "real" RSA
08:19:24 <roconnor> this whole metal poker thing looks like it'd be easier over an elliptic curve.
08:19:40 <roconnor> now that I know it isn't public-key crypto.
08:19:53 <koeien> why, roconnor?
08:20:14 <roconnor> koeien: fewer bad things can go wrong than in RSA?
08:20:59 <koeien> ok, sure. i'm not an expert on crypto so i would not do this myself if my business depended on it
08:21:09 <roconnor> RSA needs padding
08:21:30 <roconnor> oh wait
08:21:33 <roconnor> e and d are secret
08:21:35 <roconnor> hmm
08:21:48 <roconnor> ... all my RSA intuitions are wrong for this application
08:22:20 <t7> roconnor: yeah its a bit inside out when you share p and q
08:22:30 <clsmith> hey. if i have a polymorphic function f, if there a way to pass it to (a function like) Data.Function.on in such a way that the function takes two separate types? i'm suspecting not, but it would be great if it were possible :p
08:23:19 <clsmith> context: (mappend `on` measure), where measure needs to change two different types into the same type which are then mappended
08:23:29 <roconnor> still with RSA ... in theory your message could be a multiple of p or q.
08:23:47 <roconnor> and that problem goes away with ECC over a curve of prime order.
08:24:05 <roconnor> with ECC on such a curve the only bad point is 0.
08:24:20 <Philonous> Can I kill a thread that is blocking on hGet?
08:25:27 <drdo> How can i tell cabal to pass the env variable CFLAGS as cflags to hsc2hs? (Or, what's the right thing to do if i'm relying on CFLAGS to pass include directories?)
08:25:41 <hpaste> killy9999 pasted “Understanding error message” at http://hpaste.org/66435
08:26:09 <killy9999> why the error arises from the use of '1' ?
08:26:10 <koeien> killy9999: goodGuard -1 parses as (goodGuard) - (1)
08:26:15 <killy9999> yes, I know
08:26:20 <dcoutts_> drdo: you probably don't want to be using CFLAGS, rather use --extra-include-dir
08:26:21 <koeien> killy9999: ah, you want to know the reason?
08:26:27 <killy9999> but I'm trying to decompose errpor message :)
08:26:34 <koeien> killy9999: (-) is of type Num a => a -> a -> a
08:26:38 <dcoutts_> drdo: but if you really do, then you'll need custom code in the Setup.hs
08:26:40 <killy9999> yes
08:26:43 <koeien> goodGuard is of type Int -> String
08:26:51 <parcs`> killy9999: numeric literals are polymorphic. ghc is trying to find a function instance of Num
08:26:54 <parcs`> and failing
08:26:58 <koeien> so it tries to find a Num instance of Int -> String, but there is none in scope
08:27:12 <drdo> dcoutts_: I don't want to include a specify directory. How would people use this with headers in non-standard locations?
08:27:14 <killy9999> yes, I understand that
08:27:25 <killy9999> but I don't get why it complains about literal `1'
08:27:26 <killy9999> ?
08:27:40 <killy9999> I'd understand complaining about goodGuard
08:27:40 <koeien> killy9999: numeric literals are overloaded
08:27:49 <killy9999> what does it mean?
08:27:51 <pqmodn> 1 :: Num a
08:27:53 <dcoutts_> drdo: that's the point, the user who has headers in non-standard locations uses the --extra-include-dir= --extra-lib-dir= flags
08:27:57 <koeien> killy9999: so instead of 1 you should really read fromInteger 1
08:28:06 <koeien> pqmodn: no, 1 :: Num a => a
08:28:21 <pqmodn> koeien: doh, right
08:28:37 <drdo> dcoutts_: oh, i thought you were talking about hard coding them in the cabal file. That sounds reasonable, thanks
08:28:39 <parcs`> killy9999: it's not complaining about goodGuard
08:28:43 <koeien> killy9999: so goodGuard - fromInteger 1
08:28:44 <parcs`> it's complaining about 1
08:28:52 <koeien> parcs`: and (-)
08:29:00 <dcoutts_> drdo: so sounds like you don't need to do anything then
08:29:01 <killy9999> I still don't get it...
08:29:09 <drdo> dcoutts_: Indeed
08:29:15 <dcoutts_> drdo: as those flags exist and the info gets passed through to hsc2hs etc
08:29:17 <parcs`> get what/
08:29:20 <reinoud> @hoogle foldr
08:29:20 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
08:29:21 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
08:29:21 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
08:29:22 <koeien> killy9999: ok, so goodGuard - 1 is basically goodGuard - fromInteger 1, do you agree?
08:29:41 <killy9999> well, it produces almost the same error message :)
08:29:48 <koeien> yes
08:29:57 <koeien> (-) :: Num a => a -> a -> a
08:30:08 <nand`> :t fromInteger
08:30:09 <lambdabot> forall a. (Num a) => Integer -> a
08:31:22 * killy9999 is trying to understand why there has to be fromInteger 1 insetad of simply 1
08:31:47 * killy9999 understands
08:31:51 <koeien> look at fromInteger's type
08:31:55 <koeien> :t fromInteger
08:31:55 <lambdabot> forall a. (Num a) => Integer -> a
08:32:11 <koeien> it means that fromInteger 1 is of type Num a => a, so of *any numeric type* you want
08:32:28 <parcs`> :t 1
08:32:29 <lambdabot> forall t. (Num t) => t
08:32:35 <killy9999> that's why it's called polymorphoic, right?
08:32:38 <koeien> yes
08:32:56 <koeien> so 1 can be a Double, an Integer, a Word32, and so on
08:33:23 <killy9999> but it can be Int -> String and that's what the error says...
08:33:35 <killy9999> I think I get it
08:33:41 <koeien> no it cannot be, unless you provide an instance of Num for that type
08:33:42 <nand`> fromInteger 1 is redundant
08:33:56 <koeien> nand`: yes, but it illustrates the point of overloaded numeric literals
08:34:02 <zhulikas> > fromInteger 1 :: Char
08:34:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:34:03 <lambdabot>    arising from a use of `GHC....
08:34:13 <nand`> > 1 :: Char
08:34:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:34:14 <lambdabot>    arising from the literal `1...
08:34:18 <nand`> same thing
08:34:18 <killy9999> man, even simple errors in Haskell are magic
08:34:29 <nand`> killy9999: wait till you get to “My brain just exploded”
08:34:34 <koeien> killy9999: i can see why this - is confusing
08:34:45 <nand`> > "foo" - 1
08:34:47 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:34:47 <lambdabot>    arising from the literal ...
08:35:13 <nand`> The “No instance for (Num [Char]) error means that [Char] isn't a number
08:35:23 <nand`> it's the same as “No instance for (Num String)”
08:35:26 <killy9999> It's nofusing because the error doesn't complain about the first argument to (-), which obviously has wrong type, but it complains about 1
08:35:32 <nand`> personally, I would have written it “No Num instance for String” but that's just me
08:35:45 <koeien> killy9999: oh yeah both are wrong
08:35:55 <koeien> killy9999: the 1 also requires the instance
08:36:07 <killy9999> ?
08:36:10 <koeien> killy9999: just like (-). the reason is that 1 is really fromInteger 1
08:36:31 <koeien> killy9999: so you need to define fromInteger for Int -> String, that's what it says
08:36:48 <quicksilver> when it type checks ("foo" - 1) the first thing it conclues is that (1) takes the same type as ("foo")
08:36:59 <quicksilver> because the type of (-) says that its two arguments are the same type.
08:37:18 <quicksilver> so it first concludes that (1) is a string, and tries to make that possible with a Num instance for String.
08:37:43 <nand`> In (a - b) what I think is happening is that it first matches the parameter of (-) against a's type; which fails, but then it still continues on with the resulting (a-) :: A -> A where A is the type of a; so in your case it would be something like ("foo" -) :: String -> String; it then *again* tries to match (1) against this, which fails a second time because String can't be a Num <- this might explain why
08:37:44 <nand`> you're getting errors for both parameters
08:37:46 <nand`> but I could be wrong
08:37:56 <nand`> Err, Num can't be a String*
08:38:01 <nand`> Num a => a more like
08:38:43 <quicksilver> nand`: nope.
08:38:52 <quicksilver> nand`: matching (-) against a does not fail.
08:38:55 <quicksilver> it generates a constraint.
08:39:01 <quicksilver> generating a constraint is never failure.
08:39:26 <nand`> wouldn't that end up as Num String => String -> String -> String then?
08:39:32 <nand`> if a is a String in this example
08:39:35 <quicksilver> ("foo" - 1) is a valid haskell term, its type is String, but it has a constraint (Num String)
08:39:55 <saml> > "foo" - 1
08:39:56 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:39:56 <lambdabot>    arising from the literal ...
08:39:59 <nand`> :t ("foo" - 1)
08:39:59 <lambdabot>     No instance for (Num [Char])
08:40:00 <lambdabot>       arising from the literal `1' at <interactive>:1:9
08:40:00 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
08:40:02 <quicksilver> that constraint isn't satisfied by the context that lambdabot can see
08:40:06 <ion> One can easily make a Num String instance. :-P
08:40:23 <quicksilver> constraint satisfication is logically a separate phase from type checking.
08:40:28 <nand`> I was wondering whether :t would attempt to verify constraints as well
08:40:39 <nand`> seems it does
08:40:43 <quicksilver> it does if there are no variables left.
08:41:01 <roconnor> poor damienradtke ... is thinking too imperatively
08:41:05 <quicksilver> constraints which have a variable can be satisfied or propagated
08:41:20 <quicksilver> constraints with no variable must be satisfied or it's a type error.
08:41:32 <quicksilver> :t show []
08:41:33 <lambdabot> String
08:41:35 <roconnor> and/or not modular enough
08:41:56 <quicksilver> hmm I think that defaulting messed that up
08:42:01 <quicksilver> :t \x -> show [x]
08:42:02 <lambdabot> forall t. (Show t) => t -> String
08:42:23 <nand`> :t show ([] :: [a])
08:42:24 <lambdabot> String
08:42:26 <quicksilver> ^^ that one had a Show [t] constraint, which was satisfied. But its satisfication generated a Show t constraint.
08:42:35 <quicksilver> and that got propagated.
08:42:49 <quicksilver> I'm not sure my terminology is right, here.
08:43:25 <reinoud> is there a way how i can beautify this?
08:43:27 <reinoud> -- | returns if a face has more than one zero point recorded
08:43:27 <reinoud> needs_split :: [Edge] -> Bool
08:43:27 <reinoud> needs_split edges = length [length edge > 2 | edge <- edges] > 1
08:43:40 <Philippa_> quicksilver: I wouldn't describe it as phases quite that way and I suspect I'm trying to push the same model of typechecking as you albeit with different terminology, FWIW :-)
08:44:04 <dylukes> reinoud: edges is a list of what?
08:44:11 <dylukes> er, what is an Edge, specifically.
08:44:21 <nand`> needs_split = any (\edge -> length edge > 2)
08:44:23 <reinoud> Edge = [zeropoint]
08:44:34 <dylukes> You could use filter/length
08:44:40 <nand`> or needs_split = any ((>2) . length)
08:44:59 <nand`> oh wait
08:44:59 <dylukes> That's better yeah. Less wasted work.
08:45:01 <nand`> it's >1 not >0
08:45:01 <reinoud> oh i didn't know that construct
08:45:09 <nand`> that will not work as expected
08:45:16 <t7> does anyone know a wrapper around the encrypt and decrypt calls in Crypto.Encryption*
08:45:21 <dylukes> reinoud: check out the Special Folds section here
08:45:21 <dylukes> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
08:45:36 <dylukes> and/or/any/all/sum/product are really useful combinators.
08:46:14 <nand`> reinoud: I'm not sure if your code will even work as expected, [length edge > 2 | edge <- edges] will be of type :: [Bool] but still contain one item for each item in the original list
08:46:15 <dylukes> reinoud: One thing to consider by the way is,
08:46:29 <dylukes> nand`: Notice the length and >1 on the outside
08:46:32 <quicksilver> Philippa_: believing that type-checking only generates constraints and never rejects them at that stage is very useful to give intuitiion as to why constraint solving never backtracks, I find.
08:46:39 <quicksilver> Philippa_: even though we can of course imagine different algorithms.
08:46:43 <dylukes> So, reinoud, are you going to need to figure out WHICH elements need splitting?
08:46:46 <nand`> dylukes: yeah but that's then equivalent to needs_split edges = length edges > 1
08:46:51 <dylukes> In that case, querying for the bool is a waste of effort.
08:46:56 <nand`> dylukes: since the length doesn't get changed in the comprehension
08:47:05 <dylukes> You could just do needs_split :: [Edge] -> [Edge]
08:47:11 <dylukes> where an empty list denotes nothing needs splitting.
08:47:15 <bitonic> ;lkkj;lkj;
08:47:18 <Philippa_> yeah, I've a feeling there are cases where it has to solve part way through checking though
08:47:20 <dylukes> Or something ,dunno.
08:47:26 <dylukes> Not sure what you're doing.
08:47:39 <reinoud> no just if one of the elements is too big. Can i use `and (map (>2) $ map (length) edges) ?
08:47:40 <Philippa_> (I should read through the OutsideIn paper thoroughly!)
08:47:51 <reinoud> err map (>1)
08:48:03 <reinoud> and use `or'
08:48:04 <reinoud> sigh
08:48:05 <Philippa_> separating constraint generation and constraint solving is useful though, yes. I just wouldn't use 'phase'
08:48:15 <Guest65986> hi
08:48:18 <nand`>  map f . map g is equal to map (f . g)
08:48:35 <quicksilver> bitonic: be careful, you appear to have passed out onto your keyboard. Should we call a medic? Or was it your cat?
08:49:01 <reinoud> needs_split edges = or map ((>1) . length) edges ?
08:49:41 <bitonic> quicksilver: damn, sorry about that. I'm fine, blame erlang.
08:49:52 <bitonic> I was thinking while playing with the keyboard.
08:49:53 <nand`> reinoud: that's definitely a type error unless you insert a $ after or, and it's still not the same thing; what is the algorithm supposed to check for exactly?
08:50:46 <reinoud> ok, `or $ map' :)
08:51:25 <nart> ciao :)
08:52:00 <yitz> reinoud: use (not null . drop 1) instead of ((>1) . length)
08:52:06 <reinoud> well there is a list being produced with all intersections of a math function with a cube and if it intersects more than one time it needs to subdivide.
08:52:19 <t7> fromOctets 256 $ decrypt (n, d2) $ decrypt (n, d) $ encrypt (n, e2) $ encrypt (n, e) $ toOctets 256 1337  -- :D
08:52:20 <reinoud> length is expensive yes :)
08:53:48 <reinoud> yitz: thats not compiling...
08:54:13 <yitz> reinoud: sorry. (not . null . drop 1)
08:54:26 <yitz> @type (not . null . drop 1)
08:54:27 <lambdabot> forall a. [a] -> Bool
08:54:35 <reinoud> tnx!
08:55:42 <reinoud> yay... lets see
08:59:22 <killy9999> can I introduce typeclass constraint in a type (not data) so that I can use that type as a synonym to a tuple of Num ?
09:01:28 <Saizan> killy9999: not really
09:02:24 <Saizan> you end up creating higher-rank types that way instead of what you want
09:02:39 <killy9999> mhm, thanks
09:06:00 <strager> @pl a >>= \x -> return $ (b . x)
09:06:00 <lambdabot> (b .) `fmap` a
09:06:09 <strager> Ah, of course
09:07:49 <zhulikas> @pl a >>= \b -> c >>= d
09:07:49 <lambdabot> a >> (d =<< c)
09:08:05 <zhulikas> @type (=<<)
09:08:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:08:21 <zhulikas> @type (>>=)
09:08:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:08:27 <zhulikas> ah, I see
09:12:52 <zhulikas> [[1, 1], [1, 2], [2, 2], [2, 3]..]
09:12:55 <zhulikas> how can I generate something like that?
09:13:11 <zhulikas> oh, not like that...
09:13:13 <zhulikas> nevermind
09:13:51 <strager> > take 10 $ map (\x -> [x `div` 2, (x+1) `div` 2]) [2..]
09:13:52 <lambdabot>   [[1,1],[1,2],[2,2],[2,3],[3,3],[3,4],[4,4],[4,5],[5,5],[5,6]]
09:14:24 <strager> There's probably some more clever way without divison =]
09:14:25 <zhulikas> more like
09:14:33 <zhulikas> all possible combinations of two integers in given interval
09:14:42 <strager> Oh
09:14:44 <joeytwiddle> > ;typeof $
09:14:45 <lambdabot>   <no location info>: parse error on input `;'
09:14:54 <zhulikas> I know, that one was wrong
09:15:02 <zhulikas> that sequence I gave
09:15:09 <joeytwiddle> > :t ($)
09:15:09 <lambdabot>   <no location info>: parse error on input `:'
09:15:17 <strager> :t ($)
09:15:18 <lambdabot> forall a b. (a -> b) -> a -> b
09:16:32 <joeytwiddle> f $ x = f x    -- it's used to avoid having to use brackets?
09:16:40 <edwardk> joeytwiddle: yes
09:16:45 <joeytwiddle> ty!
09:16:59 <edwardk> joeytwiddle: nothing to close at the end that way
09:17:06 <joeytwiddle> damn right
09:17:16 <joeytwiddle> that's awesome.  gotta put that in my language!
09:17:56 <strager> =]
09:20:48 <dmwit> Is there a way to ask GHC to stop after a given stage?
09:21:14 <dmwit> e.g. I can add -ddump-parsed to get it to print what it's meditating on after the parsing stage, but can I ask it also not to meditate?
09:21:16 <kallisti> let me make sure I understand this correctly
09:21:26 <kallisti> when deciding instances, GHC completely ignores the constraint on the instance?
09:21:31 <dmwit> yes
09:21:48 <dmwit> It chooses an instance without looking at the constraint, then checks the constraint.
09:21:59 <kallisti> thus there can't be an instance for (Monad m) => m  and (Num a) => a
09:22:09 <kallisti> as these are just both "any type"
09:22:21 <dmwit> Well, that one especially because m and a have different kinds.
09:22:22 <dmwit> But yes.
09:22:34 <kallisti> got it.
09:23:40 <kallisti> is realToFrac the best way to get from Float to Double?
09:23:46 <copumpkin> yep
09:23:50 <kallisti> good good.
09:24:07 <copumpkin> it ends up being pretty efficient in most cases, I think
09:24:14 <kallisti> I might actually know things about Haskell guys!
09:24:31 <kallisti> as long as you don't get too philosophical about knowledge.
09:24:41 <strager> There is no type.
09:24:58 <strager> So, got my code compiling ... time to take a break ;P
09:25:18 <kallisti> :t Rational
09:25:18 <lambdabot> Not in scope: data constructor `Rational'
09:25:20 <kallisti> er
09:25:26 <kallisti> constructor for ratio..
09:25:31 <kallisti> :t (%)  --let's go with this
09:25:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:26:02 <kallisti> I have sort of dynamic typey type with constructors for Double, Integer, Text, and Bool
09:26:27 <kallisti> and a class to convert values to this dynamic typey thing. is instance (Integral a) => Class (Ratio a) where ...
09:26:30 <kallisti> reasonable?
09:27:57 <kallisti> (for the curious, this is for handling Firefox profiles. I'm not using this type because I think I need dynamic typing when I don't or anything of that nature)
09:28:21 <scooty-puff> Saizan: k, thanks
09:28:31 <pls> hi, i've a data and I do some operations on it... at the end, I would like to transform it into a string, to save it on a file... my problem, I don't achieve to print how is the data - I lose the newlines and tabs caracters, and my data is presented in a only line.... could anyone help me?
09:29:00 <kallisti> pls: you mean your strings are printed as string literals with \n instead of newlines and
09:29:05 <kallisti> \t instead of tabs?
09:29:28 <pls> ah, I used: show myData to do this
09:29:32 <kallisti> yes
09:29:36 <kallisti> and you derived Show?
09:30:27 <pls> yes, i derive it
09:30:35 <kallisti> by default it just calls show on all of your record fields, and outputs the syntax for a record constructor.  MyType { x = "blah\nblah\nblah", y = 1, z = True }
09:30:51 <kallisti> which you can then later read with the derived Read, assuming there's not any tricky fields.
09:31:26 <kallisti> if you need some sort of structure to your output format, you'll want to write a custom serialization instance. One library that's useful towards that end is called cereal.
09:33:34 <kallisti> pls: does that help?
09:34:47 <kallisti> > 0.2 :: Fixed
09:34:48 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
09:34:50 <pls> in fact, my data, as I see it in the notepad++, is structured with newlines and tabs to organize it with identation....
09:35:00 <kallisti> > 0.2 :: Fixed E6
09:35:01 <lambdabot>   0.200000
09:35:34 <kallisti> pls: is this not what you want?
09:37:27 <pls> yes, but if i apply show on it, the output show me mydata in an only line... and i lose the formation that i would to preserve to show to the final user....
09:37:43 <c_wraith> pls: then don't use show
09:38:12 <kallisti> depending on your audience, show is likely a poor method of displaying output to a user.
09:38:16 <pls> i might to create my function to do this?
09:38:44 <kallisti> pls: yes, you can create your own Show instance if you like.
09:38:48 <kallisti> or just write your own function
09:39:16 <kallisti> you may want to have a look at the Text.Show module, which has some convenience functions for writing Show instances.
09:39:39 <pls> hum... maybe... good tip :)
09:39:49 <kallisti> > showChar '[' . shows 2 . showChar ']' $ ""
09:39:51 <lambdabot>   "[2]"
09:40:38 <kallisti> > showParen . showString "stuff + morestuff" $ ""
09:40:38 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:40:39 <lambdabot>         against inferred type ...
09:40:47 <kallisti> > showParen True . showString "stuff + morestuff" $ ""
09:40:48 <lambdabot>   Couldn't match expected type `GHC.Show.ShowS'
09:40:48 <lambdabot>         against inferred type...
09:40:50 <kallisti> ...er
09:41:19 <kallisti> oh
09:41:36 <kallisti> > showParen True (showString "stuff + morestuff") ""
09:41:37 <lambdabot>   "(stuff + morestuff)"
09:42:58 <kallisti> wow I might actuall use a CPP macro for these instances..
09:43:04 <kallisti> there's a lot of Integral types.
09:46:36 <pls> ok, kallisti.. thank you for your tips... i will reread all you said and think a litle :)... it is necessary to study more about Show before to take a final decision :)
09:47:55 <kallisti> no problem
09:47:57 <kallisti> > 2 :: CIntMax
09:47:58 <lambdabot>   Not in scope: type constructor or class `CIntMax'
09:50:01 <singpolyma> What's the best way to make a newtype that can only represent, say, positive numbers?
09:51:34 <koeien> use a smart constructor
09:51:34 <geekosaur> singpolyma, that's a difficult question; you're looking for dependent types, which are not directly supported
09:52:08 <singpolyma> koeien: and hide the normal constructor?
09:52:12 <geekosaur> there are a number of approaches, none of which is fully competent (smart constructors will prevent you from creating one but won't help with an errant subtraction, for instance)
09:52:26 <bitonic> geekosaur: ? it will, if you re-define subtraction
09:52:53 <geekosaur> bitonic, point there was you need to make sure you've covered all the places it can happen.  oh, and it's all runtime errors when you do
09:53:06 <singpolyma> right.  really I'd like to have the "normal" data constructor do a check or whatever, instead of using a seperate function as the constructor, but that's just a syntactic thing
09:53:13 <kallisti> should I use hashmap or unordered-containers?
09:53:26 <bitonic> geekosaur: yes of course, but you *can*. I agree that it's an inferior solution to a dependent type
09:53:58 <geekosaur> peano numbers in the type system get you compile time checking and a complete inability to have accidental negative numbers, but (a) slow (b) painful
09:54:12 <geekosaur> there are various other ways to do it, which is best depends on what's most important to you
09:54:46 <singpolyma> well, static checks are obviously nicer, but I expected I'd have to live without them in this case
09:56:09 <geekosaur> the cheap method is the smart constructor and wrapped operations
09:56:35 <singpolyma> ok
09:56:47 <bitonic> geekosaur: maybe he just doesn't need subtractions, and you can jus throw an error if you want a "Num" instance. Ugly, but pretty safe (in the sense that you'll avoid subtle errors)
09:57:27 <geekosaur> bitonic, do you believe we are having a dispute?  I just more or less said that in fewer words
09:57:59 <bitonic> ? no no dispute, I ust thought you were implying a different subtraction
09:58:29 <geekosaur> I just assumed someone looking for type magic because that's what I usually run into in #haskell :)
09:58:36 <kallisti> is there a relatively platform-independent way to create temp directories in Haskell?
09:58:56 <bitonic> geekosaur: if you want peano numbers you're screwed in the first place with Haskell anyways
09:59:05 <dmwit> There is already a hackage package for efficient (lazy) Nats.
09:59:09 <singpolyma> geekosaur: well, type magic is the ideal, but I've run into similar things before (wanting typechecked list lengths) and assumed the type system couldn't do this
09:59:29 <dmwit> Oh, I lied, they're Peano Nats.
09:59:41 <dmwit> I thought there was an efficient (binary) representation of Nats lying around in this package...
10:00:03 <c_wraith> I know *some* package has that implementation available
10:00:35 <geekosaur> there's more than one such package last I checked
10:00:47 <dmwit> ?hackage nat
10:00:48 <lambdabot> http://hackage.haskell.org/package/nat
10:01:05 <geekosaur> think there's a package with typechecked list lengths too
10:01:17 <geekosaur> (does @hackage actually check for packages now?)
10:01:28 <dmwit> No, but that's really what it's called.
10:01:43 <dmwit> I used an external tool (my browser!) to find it.
10:02:04 <geekosaur> ok, just checking
10:03:46 <kallisti> hm, is there a recursive directory copy function anywhere out there?
10:04:05 <dmwit> system "cp"
10:04:13 <dmwit> system "cp -r", I mean
10:04:23 <kallisti> no I need windows too.
10:04:47 <merijn> This works (ignoring the fact that baz is partial), "data Foo = A {bar :: String, baz :: Int} | B {bar :: String}" right?
10:04:47 <dmwit> There is a sad lack of recursive directory functions in general.
10:04:55 <dmwit> yes
10:04:56 <tgeeky_> kallisti: haskell, in windows, will have MSYS behind it, which will have cp
10:05:00 <merijn> Excellent
10:05:43 <tgeeky_> kallisti: minigw, at least, that is
10:05:48 <tgeeky_> or mingw
10:05:53 <dmwit> singpolyma: There are also the naturals and natural-numbers packages if you want Integer-backed natural numbers instead of lazy bit-lists.
10:06:10 <kallisti> tgeeky_: ..it will?
10:06:20 <kallisti> I was under the impression that I could compile standalone applications for Windows platforms.
10:06:36 <dmwit> Yeah, I'm super skeptical of tgeeky_'s claim here.
10:06:53 <hpc> ghc has a native code generator
10:07:17 <kallisti> anyway I can just roll my recursive directory copy code, as I'm sure many have done in the past. code_dupplication--
10:07:37 <geekosaur> actually I would expect it to be part of cabal...
10:07:38 <hpc> if you install the platform, ghc --make will ust work
10:07:41 <hpc> *just work
10:07:42 <kallisti> code_duplication--
10:08:53 <geekosaur> ...ding!  Distribution.Simple.Utils
10:09:16 <kallisti> huh, interesting.
10:09:16 <geekosaur> kallisti: ^^
10:09:30 <kallisti> cabal is on the cutting edge of Haskell recursive directory copy technology.
10:09:57 <kallisti> dependending on Cabal will be funny.
10:10:51 <geekosaur> but it's a bootlib so guaranteed to be available everywhere ghc is
10:11:13 <singpolyma> well, and you only need it at build time anyway
10:11:15 <kallisti> why then is it installing when I type "cabal install Cabal"?
10:11:47 <singpolyma> it would be icky to require it at runtime, but ghc is happy to statcially link all the things
10:13:25 <geekosaur> kallisti, because cabal-install is happy to create unnecessary diamond dependencies?
10:13:31 <geekosaur> ghc-pkg list Cabal
10:13:45 <kallisti> so when packaging for Hackage should I exclude a Cabal dependency?
10:14:30 <geekosaur> I would, since you need the Cabal library to install anything anyway
10:15:06 <geekosaur> (this is why Cabal itself comes with a bootstrap script, because otherwise its dependencies would try to use Cabal to install themselves...)
10:15:28 <singpolyma> geekosaur: you only need cabal to install things as a dev ;)
10:15:33 <singpolyma> my users don't install cabal
10:15:37 <singpolyma> because that's crazy
10:16:15 <t7> how can i prove a message came from someone ...
10:16:26 <geekosaur> singpolyma, there is Cabal the library, and there is cabal-install the program.  the former is packaged as part of the compiler
10:16:29 <koeien> using digital signatures
10:16:38 <merijn> t7: Google "non-repudiation"
10:16:53 <Clint> how do i tell runhaskell to ignore monads-tf?
10:16:56 <singpolyma> sure, but my users don't have a compiler
10:17:09 <singpolyma> because they are not devs
10:17:21 <geekosaur> singpolyma, and this is significant because?
10:17:43 <t7> lol i was thinking about p2p poker... but someone could just create lots of peers
10:17:46 <kallisti> hm there's a createTempDirectory function that would be useful to me
10:17:49 <kallisti> but it's in a hidden module.
10:17:54 <t7> and have 9 of himself at a 10 person table
10:18:14 <t7> i guess it will have to be heads up
10:18:14 <singpolyma> geekosaur: ... because that's why they don't have cabal, and why cabal could not be a runtime dependency for me.  but, as I said, GHC statically links all the things, so it works out ;)
10:18:17 <merijn> t7: Without having out-of-band identification it's pretty impossible
10:18:19 <singpolyma> s/;)/:)
10:18:40 <geekosaur> right, I'm wondering whyt the runtime dep thing matters at all
10:18:47 <kallisti> oh wait System.IO.Temp has that nevermind
10:18:58 <merijn> t7: And even with out-of-band identification you're not safe (if the out-of-band isn't particularly secure, for example using Facebook accounts or Twitter since you can create multiple of those)
10:19:05 <c_wraith> @hoogle System.IO.Temp
10:19:05 <lambdabot> package template
10:19:06 <lambdabot> package template-haskell
10:19:06 <lambdabot> package templatepg
10:19:13 <merijn> t7: Short of making users print photocopies of their ID...
10:19:25 <geekosaur> merijn: and that's gameable too
10:19:26 <singpolyma> geekosaur: ... I'm not sure what you're asking.  It doesn't matter in practise, because of the static linking
10:19:27 <t7> i will only accept blood samples handed in person
10:19:48 <geekosaur> singpolyma, I'm trying to understand why you raised the point to start with
10:20:22 <kallisti> me too
10:21:19 <singpolyma> Oh, because if we didn't static link, then (hypothetically) depending on cabal would be having a development dependency for a production system.  which is weird, and can cause distribution problems
10:22:46 <singpolyma> anyway.  not important
10:24:35 <mysticc> Is there a  function like cons for tuple .. eg cons a (b,c,d) = (a,b,c,d) ??
10:25:07 <geekosaur> mysticc, no, because every tuple is a distinct type
10:25:39 <mysticc> geekosaur: So It is never possible to write one ..
10:25:42 <mysticc> in haskell
10:25:56 <azaq23> you shouldn't need to, because if you do you're using the wrong type
10:26:13 <zhulikas> TH should be capable of writing such thing
10:26:14 <geekosaur> to a certain extent you can do it with a type class, or you can do it in TH... but in general the need to do so means you want some other type in reality
10:26:36 <blackdog> it's a good sign you want the wrong thing :)
10:26:45 <mysticc> azaq23: yup .. I dont need .. I was just messing with some types .. and thinking is that possible ..
10:26:48 <kallisti> "temp directory to create the directory in"
10:27:06 <kallisti> what. that requires me to know the name of the temp directory directory, which isn't very platform neutral.
10:27:40 <kallisti> I guess I'll just use getTemporaryDirectory
10:29:20 <geekosaur> kallisti, portable and secure tempfiles are remarkably difficult in any language, I'm afraid.  best case is that mkstemp() is supported on the target platform, but AFAIK no standard has yet adopted/required it :/
10:30:31 <geekosaur> ...and, as I feared, it's not in the API supported by mingw/msys :/
10:31:26 <hpaste> t7 pasted “RSA mental poker” at http://hpaste.org/66437
10:32:21 <t7> I duno why people say its computationaly unfeesable. Maybe that was years ago ?
10:34:05 <hpaste> timthelion pasted “How is table in scope, when inside the lambda???” at http://hpaste.org/66438
10:35:33 <timthelion> Hey, can someone explain the scoping of lambda's in gtk2hs?
10:35:38 <geekosaur> timthelion, how is it not in scope?
10:35:44 <t7> why is there no parZip :(
10:35:47 <byorgey> timthelion: table is in scope in everything after line 1
10:35:54 <byorgey> it has nothing to do with lambdas.
10:36:00 <c_wraith> timthelion: the body of a lambda (rather necessarily) doesn't remove anything from scope
10:36:21 <timthelion> but the lambda doesn't get evaluated at the time when it is defined.
10:36:28 <geekosaur> so?
10:36:34 <c_wraith> timthelion: you've never heard of closures?
10:36:45 <ben> Yeah, but all the things the lambda uses get copied into the lambda when it's created
10:36:48 <ben> so it's cool
10:36:48 <timthelion> c_wraith: I can't say I have.
10:37:19 <t7> @src zip
10:37:19 <c_wraith> > let plus x = \y -> x + y in (plus 5) 7
10:37:20 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
10:37:20 <lambdabot> zip _      _      = []
10:37:20 <lambdabot>   12
10:37:22 <t7> @src zipWith
10:37:22 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:37:22 <lambdabot> zipWith _ _      _      = []
10:37:29 <timthelion> ben: aha, this is a bit tricky then.  is table a pointer to a table then?
10:37:39 <quicksilver> don't think about how it's implemented
10:37:40 <ben> timthelion: Haskell doesn't say
10:37:46 <quicksilver> well you can if you like, it's interesting :)
10:37:47 <Philonous> is it, generally speaking, a bad idea to use asynchronous exceptions to knock a thread out of a blocking state (e.g. blocking on recv) ?
10:37:56 <timthelion> quicksilver: but it's important how it is implemented :)
10:38:00 <c_wraith> timthelion: all you need to know is that bindings close over their environment
10:38:03 <quicksilver> timthelion: important for what?
10:38:12 <quicksilver> timthelion: it's not important to understand how to use it.
10:38:22 <quicksilver> it's important if you want to understand how GHC works. Which is interesting, sure.
10:38:24 <ben> I guess it's important to know whetherh you'll get away with closing over huge vectors or whatever
10:38:33 <ben> (which you do)
10:38:35 <quicksilver> but you could write a haskell compiler a different way from GHC.
10:38:40 <geekosaur> Philonous, I expect it's a *necessary* idea.  (which does not mean it's not a bad idea...)
10:39:17 <Philonous> geekosaur:  The alternative would be to rely on non-blocking variants and do explicit polling
10:39:30 <timthelion> quicksilver: well if it is a pointer, than I would be worried about eager GC killing the table...  That's my main concern about scope.
10:39:37 <t7> :t uncurry
10:39:38 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:39:54 <c_wraith> timthelion: a closure is a combination of a function and an environment for looking up names in the function body that are not bound in the arguments to the function
10:40:10 <c_wraith> timthelion: that's not garbage collection you're describing, that's memory corruption
10:40:15 <quicksilver> timthelion: don't worry, just believe it works.
10:40:21 <quicksilver> timthelion: if the table is in scope you can use it.
10:40:29 <timthelion> quicksilver: you sound like a radical christian.
10:40:31 <quicksilver> timthelion: however, the point you make is precisely what GC is *for*
10:40:43 <quicksilver> GC is for making sure it doesn't kill things which are still reachable
10:40:44 <c_wraith> timthelion: some badly designed reference counting systems *do* corrupt memory.  But they're not garbage collection
10:40:46 <quicksilver> from anywhere.
10:41:19 <quicksilver> timthelion: I don't intend to; I mean to make it clear that the way the language *works* is different from the way the compiler is *implemented*.
10:41:55 <quicksilver> it is absolutely fundamental to haskell than in "let x = 5 in \y -> {.... blah ...}" you are permitted to use 'x' in the body of the lambda.
10:42:14 <quicksilver> whether or not it arranges that by copying the '5' or storing a pointer to it... well that's an implementation choice.
10:42:15 <geekosaur> well, tbh there's more to it because it's really a reference to an FFI-returned Gtk+ object.  but it's up to gtk2hs to make sure those are managed appropriately, and you should assume it does and report bugs when it doesn't
10:42:22 <c_wraith> timthelion: the other direction can be a problem in practice. a closure can hold something in memory longer than you expect. But the opposite is impossible.
10:42:24 <quicksilver> the cmpiler might do different things in different cases.
10:42:28 <timthelion> quicksilver: sometimes these things ARE important though.  What if I had an event handled by a lambda, refering to a giant data structure.  If I don't understand this, I'll get a terrible memory leak.
10:43:09 <quicksilver> timthelion: yes, certainly. It only matters if the lambda actually refers to the structure, though.
10:43:19 <c_wraith> timthelion: the implementation details *still* aren't important to that.  You don't need to know how GHC implements closures and thunks to know how to eliminate them when they are causing memory issues
10:43:21 <quicksilver> timthelion: and furthermore, it only matters if the lambda itself is also reachable.
10:43:44 <ben> If it's an event callback, it'll likely be bound into some gtk object that's gonna live for a while
10:43:53 <timthelion> quicksilver: but how is "reachability" defined in terms of a gtk2hs event handler?
10:44:11 <dcoutts> timthelion: I helped implement this bit, so I can say how it works
10:44:32 <dcoutts> timthelion: it does work, it uses ForeignPtr for all the Gtk GObjects.
10:44:49 <dcoutts> when the ForeignPtr becomes unreachable, the GObject ref count is decremented
10:45:10 <dcoutts> which may result in the object being free'd on the C side if the ref count drops to 0
10:45:29 <timthelion> ok
10:45:48 <dcoutts> the existence of the reference to the Gtk+ object within the closure keeps the object alive
10:45:49 <geekosaur> (gtk+ being written in C, it does ref counting instead of real gc...)
10:47:13 <timthelion> dcoutts: and if I run a command to delete the table, but the event was owned by the main window.  Then an error will occure and the program will crash when the event is run, I presume?
10:47:55 <dcoutts> timthelion: the reference to the table remains
10:48:13 <timthelion> even though the table is no longer visible on screen
10:48:48 <dcoutts> if you mean a GObject, then you cannot really delete the table because it's reference counted
10:48:56 <dcoutts> and the event handler has a reference
10:49:57 <dcoutts> timthelion: the object lifetime and being visible on screen are not quite the same thing
10:50:23 <mysticc> I have class A a b c .. how to write a functional dependecy that a and b together determine c ..
10:51:13 <timthelion> dcoutts: OK, I'm wondering about GTK.Widget.destroy  .
10:51:49 <dcoutts> timthelion: it doesn't free the object but it puts it into a "null" state, yes you probably shouldn't do that if you still have references to it
10:52:07 <b0fh_ua> Hi all! I need help with HXT - with the code listed at http://hpaste.org/66439 I can get all values of "name" attribute for each <input> tag under <form> tag, how do I get pairs of (name,value) for each of such tag?
10:52:15 <dcoutts> timthelion: indeed you probably don't ever need to use GTK.Widget.destroy
10:53:17 <timthelion> dcoutts: I have a table of VBox's with different widgets filling them.  When I change the type of the item in the table, I thought simply destroying the VBox and putting a new one in would be the correct way to do things.
10:53:51 <dcoutts> timthelion: so the docs say widget destroy makes it drop refs to other objects and removes it from its parent container
10:54:23 <Cale> mysticc: class A a b c | a b -> c where
10:55:08 <mysticc> Cale: Yeah .. thanks .
10:55:26 <timthelion> dcoutts: thanks for all your help. I'll play with it, and show you what I've got when I get there.
10:56:27 <dcoutts> timthelion: np
10:56:33 <donri> b0fh_ua: using arrow notation might be easiest here
10:56:57 <donri> or perhaps (&&&) or whatever that one is called?
10:57:57 <b0fh_ua> donri: not sure that I did understand you
10:58:01 <clintm> dcoutts: also, as an aside from another random person, thanks for the partial evaluation paper you wrote.  04 or so, I think.  even with almost no mathematical background, I learned a ton about the foundations - and especially the parts regarding the 'mix' equation.
10:58:24 <b0fh_ua> donri: brilliant
10:58:33 <b0fh_ua> &&& is what I was looking for
10:58:36 <donri> b0fh_ua: ... >>> (getAttrValue "name" &&& getAttrValue "value")
10:58:44 <b0fh_ua> yeah, exactly
10:58:45 <b0fh_ua> thanks a lot!
10:58:49 <donri> \o/
10:59:03 <dcoutts> clintm: oh cool :-)
10:59:18 <jay_gridley> hello, I need quick hint, I have a list of tuples [(A,B)] and need list of [B] from it, how to?
10:59:22 <dcoutts> clintm: I gave up shortly after, too hard :-)
10:59:29 <donri> jay_gridley: map snd
10:59:35 <dcoutts> clintm: you working on PE? it's cool stuff
11:02:22 <killy9999> anyone uses ghc-mod for Emacs??
11:02:56 <killy9999> I can't get some features to work...
11:03:58 <donri> i use it with vim ...
11:06:48 <killy9999> donri: and everything works?
11:06:55 <donri> define "everything" :)
11:07:16 <killy9999> Inserting module import for a function?
11:08:02 <donri> it autocompletes available modules and their functions for me
11:08:08 <killy9999> or inserting inferred type
11:08:37 <killy9999> I can only complete keywords and local symbols
11:09:43 <t7> @djinn [a] -> a
11:09:43 <lambdabot> Error: Undefined type []
11:10:34 <t7> @pl (f 256 :: a -> b) . (g :: c -> d -> a)
11:10:35 <lambdabot> (line 1, column 13):
11:10:35 <lambdabot> unexpected ">"
11:10:35 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
11:10:43 <t7> :t (f 256 :: a -> b) . (g :: c -> d -> a)
11:10:44 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
11:10:44 <lambdabot>       from the context ()
11:10:44 <lambdabot>       arising from a use of `f' at <interactive>:1:1-5
11:12:11 <t7> print $ map (fromOctets 256) $ zipWith (decryptWithKey) keys ready   -- am i being an effing moron here: why cant i put (fromOctets 256 .) before the decrypt with key ?
11:12:20 <t7> and remove the map
11:14:18 <clintm> dcoutts: I'm working on just plain being a better haskell programmer.  I lack the background to -really- get everything out of a paper like that, but thanks in part to the khan academy, I'm getting there.
11:14:43 <clintm> I have to self-educate to make up for the sub-standard public education I got in high school.
11:14:49 <dcoutts> clintm: I see, good for you
11:15:15 * hackagebot buildwrapper 0.5.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.5.2 (JeanPhilippeMoresmau)
11:20:58 <blackdog> killy9999: I use ghc-mod. what's the problem you're seeing?
11:24:31 <relation> hi.. can i some how use "uniformVector :: (PrimMonad m, Variate a, Vector v a) => Gen (PrimState m) -> Int -> m (v a)" (mwc-random) with Par monad?.. to generate multiple such vectors in parallel?
11:24:38 <clintm> ghc-mod and cabal-dev.... like chocolate and peanut butter.
11:25:16 <clintm> "you got your ghc-mod in my cabal-dev!  Hey, you got your cabal-dev in my ghc-mod!  .... hrm.... well, that's.... that tastes pretty good."
11:25:47 <scooty-puff> to anyone familiar with HM(X), for HM(SUB), how would you normalize subtype predicates tau1 <: beta, tau2 <: beta - i understand how it may be done by hand, but i can't think of a good normalization algorithm that doesn't scan all constraints for ones that contain beta
11:26:38 <scooty-puff> basically, when type variables are involved, how do you do anything with subtype constraints
11:27:17 <dcoutts> scooty-puff: I used to use a graph representation
11:27:38 <Veinor> clintm: i prefer haskell-mode myself
11:27:44 <relation> or should i embed somehow Gen and define new PrimMonad instance?
11:28:29 <luffy> hi. is it possible to write a transparent memoize function in haskell? one with signature (a -> b) -> (a -> b) instead of  (a -> b) -> (a -> F b)
11:29:11 <scooty-puff> dcoutts, you don't happen to have any material i could look over, do you (or know of any papers - though preferable code - i could look over)?
11:29:25 <byorgey> luffy: not in general, but you can for particular choices of 'a'
11:29:43 <byorgey> luffy: e.g. see http://hackage.haskell.org/package/data%2Dmemocombinators
11:30:12 <clintm> veinor: so do I... I think it's actually a requirement of ghc-mod, but I'm not sure.  I've always just used them together.
11:30:25 <qnikst> how to plot list of dots connected with line? =)
11:31:21 <Veinor> qnikst: http://hackage.haskell.org/package/fgl-5.4.2.4, specifically Data.Graph.Inductive.Graphviz
11:31:56 <byorgey> qnikst: is this a plot of some data?
11:32:02 <dcoutts> scooty-puff: this is a while ago, and I'm not sure were basing this on any papers, but we just used a graph of subtype constraints between variables
11:32:11 <scooty-puff> dcoutts, like a graph where the edges are constraints, the vertices are the type variables, solve in a particular order - for a subtype, where the root or top value is {}, and tau1 and tau2 share nothing until then, or any other particular case, .. hmm, guess just not sure how to go about it
11:32:12 <byorgey> qnikst: i.e. does the locations of the dots have meaning?
11:32:17 <dcoutts> scooty-puff: then things like path compression become graph algorithms
11:32:20 <qnikst> this is a trajectory
11:32:29 <scooty-puff> k
11:32:41 <byorgey> qnikst: ok, then fgl/graphviz is not what you want.  Try the Chart package
11:33:03 <qnikst> me currently looks at gnuplot, but api frighten me
11:33:47 <byorgey> qnikst: if you just want something really simple and don't care about drawing axes or labels or anything like that, you could also try 'gloss'
11:34:27 <sclv> scooty-puff: trifonov and smith have a good paper.
11:34:29 <luffy> byorgey: thanks for the answer! i dont understand how that works
11:34:32 <qnikst> I need axes label m.b. (not now errors)
11:34:50 <luffy> byorgey: how can it work without mutable collections to back? (sorry the lib code is too dense for me!)
11:34:50 <qnikst> will check gfl and chart
11:35:09 <byorgey> luffy: essentially it works by turning the function into a data structure which (lazily) stores all the results of the function
11:35:29 <byorgey> luffy: it works because of laziness. you create a data structure to store "all" the results, but only the ones which get used are actually computed
11:35:32 <scooty-puff> sclv: thanks, found it here http://flint.cs.yale.edu/trifonov/papers/subcon.pdf
11:35:33 <singpolyma> Is there a way to do something like readFile, but not even open the file unless the data is requested?
11:35:55 <sclv> i like it because they put some thought into implementation and representation.
11:36:46 <sclv> but yeah, in general, if you mix the concerns of simplification and generation you can build up structures as you go along.
11:36:55 <sclv> rather than just having a big bag of constraints.
11:37:02 <sclv> and things become much more tractible.
11:37:08 <luffy> byorgey: makes sense. thanks much!
11:37:30 <sclv> this is sort of like what yr standard hm algos do to begin with, just with more structure.
11:37:52 <scooty-puff> k, thanks, this looks like it will get me in the right direction
11:38:46 <scooty-puff> (i kept finding HM(X) papers that mention subtyping, but i could not figure out how to normalize the additional constraints)
11:40:04 <dmwit> singpolyma: unsafeInterleaveIO (readFile "foo")
11:40:16 * hackagebot kmeans-vector 0.2 - An implementation of the kmeans clustering algorithm based on the vector package  http://hackage.haskell.org/package/kmeans-vector-0.2 (AlpMestanogullari)
11:40:44 <zhulikas> @hoogle a -> [a]
11:40:44 <lambdabot> Prelude repeat :: a -> [a]
11:40:44 <lambdabot> Data.List repeat :: a -> [a]
11:40:45 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
11:41:00 <singpolyma> dmwit: what is unsafe about unsafeInterleaveIO?
11:41:08 <zhulikas> @hoogle String -> [String]
11:41:09 <lambdabot> Prelude lines :: String -> [String]
11:41:09 <lambdabot> Data.List lines :: String -> [String]
11:41:09 <lambdabot> Data.String lines :: String -> [String]
11:41:41 <zhulikas> @hoogle Int -> [Char]
11:41:42 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
11:41:42 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
11:41:42 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
11:42:02 <sclv> scooty-puff: in the presence of rank-n polymorphism, it becomes tricky to figure out exactly what "normalizing" means... one reason I like the T&S paper (among others) is that their canonical constraint map is one way to approach the issue.
11:42:09 <dmwit> singpolyma: It does lazy IO. I'm sure there's information on the web for that search term.
11:42:29 <dmwit> http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
11:43:49 <singpolyma> dmwit: that SO article seems like it would apply to readFile, etc, as well
11:44:03 <singpolyma> but those are not marked unsafe
11:44:19 <c_wraith> readFile is lazy, yes
11:44:25 <dmwit> http://stackoverflow.com/questions/6668716/haskell-lazy-bytestring-read-write-progress-function is actually what I was looking for; see CA McCann's answer.
11:44:44 <dmwit> Perhaps readFile ought to be marked as unsafe. =)
11:45:04 <c_wraith> I'd support that
11:45:17 * hackagebot tomato-rubato-openal 0.1.0.1 - Easy to use library for audio programming.  http://hackage.haskell.org/package/tomato-rubato-openal-0.1.0.1 (HeinrichApfelmus)
11:45:29 <t7> @pl  map (\c -> map (\ks -> foldl (\c k -> encryptWithKey k c) c ks) playerKeys) deck
11:45:29 <lambdabot> map (flip map playerKeys . foldl (const (join encryptWithKey))) deck
11:45:42 <zhulikas> @hoogle Char -> Int
11:45:42 <lambdabot> Data.Char digitToInt :: Char -> Int
11:45:42 <lambdabot> Data.Char ord :: Char -> Int
11:45:42 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
11:47:06 <singpolyma> the upshot of that seems to be "it's not really unsafe, it's just technically impure so we mark it unsafe"
11:47:22 <c_wraith> Well.  And it can have hard-to-predict effects
11:47:34 <dmwit> It's not just impurity.
11:47:37 <dmwit> It's also unpredictable.
11:47:47 <dmwit> Like, even more unpredictable than plain old impurity.
11:47:59 <singpolyma> unpredictable because you're trusting the GC to clean up after you?
11:48:15 <dmwit> No, unpredictable because its behavior depends on how the code that calls it behaves.
11:48:47 <dmwit> For example, readFile may return bits of one file and bits of another if somebody happens to write to that file in the middle of your read.
11:48:50 <dmwit> Which is weird.
11:48:57 <singpolyma> oh, sure
11:49:20 <c_wraith> look at the common mistake: x <- withFile "foo" ReadMode hGetContents
11:50:01 <c_wraith> that will give you an empty string for x.  But if you make a change that *should* be harmless...
11:50:24 <zhulikas> @hoogle Floating a -> Int
11:50:24 <lambdabot> Warning: Unknown type Floating
11:50:24 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
11:50:24 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
11:50:28 <zhulikas> uhm
11:50:32 <zhulikas> @hoogle Double -> Int
11:50:32 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
11:50:32 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:50:32 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
11:50:39 <c_wraith> x <- withFile "foo" ReadMode $ do { s <- hGetContents ; print (length s) ; return s }
11:50:52 <c_wraith> suddenly, it actually returns the contents of the file.
11:51:10 <c_wraith> And that *isn't* a way you expect things to matter.
11:51:12 <singpolyma> c_wraith: right, I guess I can see that
11:51:13 <zhulikas> @hoogle Floating a => a -> Int
11:51:13 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
11:51:14 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
11:51:14 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
11:51:31 <zhulikas> @hoogle Floating a, Num b => a -> b
11:51:32 <lambdabot> Parse error:
11:51:32 <lambdabot>   Floating a, Num b => a -> b
11:51:32 <lambdabot>             ^
11:51:34 <c_wraith> err  pretend I put the correct lambda in there
11:51:36 <pqmodn> zhulikas: would you do that in a private window with lambdabot please?
11:51:42 <c_wraith> zhulikas: you probably want round, ceiling, or floor
11:51:48 <zhulikas> @hoogle round
11:51:49 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:51:49 <lambdabot> package rounding
11:51:49 <lambdabot> package roundtrip
11:51:51 <zhulikas> thank you
11:51:56 <zhulikas> pqmodn, I will, sorry
11:52:34 <c_wraith> x <- withFile "foo" ReadMode $ \h -> do { s <- hGetContents h ; print (length s) ; return s } is what I meant :)
11:53:04 <singpolyma> right.  ok, so it's unsafe because you have to be careful around the edges.  which makes sense
11:54:08 <c_wraith> yeah.
11:54:20 <mk> is the constructor for a monad equivalent to return/pure/unit?
11:54:21 <c_wraith> It's sometimes a useful tool, but you really need to be aware of the details.
11:54:42 <c_wraith> mk: sometimes.  Just is equivalent to return
11:54:48 <c_wraith> mk: but Nothing isn't
11:55:49 <mk> must return have a 1-1 mapping from originals to monadic values, or could it map them all to a single monadic value?
11:56:41 <c_wraith> mk: it has to obey the monad law: for all x with type m a, x >>= return must equal x
11:56:49 <c_wraith> mk: that's the only restriction on return.
11:57:48 <mk> I'm still confused by the monadic laws, and am trying to understand them in terms of the behaviour of return/bind
11:57:59 <mk> so is that a no?
11:58:19 <mk> or does the monad law entail that there must be a 1-1 mapping?
11:58:31 <c_wraith> They do not.
11:58:56 <mk> hmm
11:59:01 <c_wraith> But they depend on the definition of >>= and the type, as well
11:59:11 <c_wraith> consider the most trivial possible monad
11:59:18 <c_wraith> data Trivial a = Trivial
11:59:22 <mk> identity?
11:59:28 <c_wraith> no, less useful than that.
11:59:38 <Franciman> hey people, what's the difference between existentially qualified types and universally quantified types?
11:59:53 <mk> does Trivial map them all to a single value?
12:00:01 <c_wraith> it has to.  There's only a single value of the type
12:00:38 <c_wraith> What would return be for that type?
12:00:53 <mk> c_wraith: I follow - this is just the monad that I was asking about
12:01:14 <mk> is return different from the constructor?
12:01:38 <c_wraith> yes.  The constructor has the type Trivial a.  return needs the type a -> Trivial a
12:02:18 <sclv> Franciman: existentials you write with exists.
12:02:19 <mk> I think I might be confused about the constructor. Isn't it a function?
12:02:24 <sclv> universals you write with forall.
12:02:33 <Franciman> but I don't see any difference
12:02:44 <Franciman> semantically
12:02:48 <c_wraith> mk: It's a function if it takes arguments
12:02:53 <Franciman> well I *can't*
12:03:10 <pqmodn> mk: both return and the constructor have the return type "Trivial a", but the constructor takes no args and return takes one arg
12:03:14 <c_wraith> Franciman: it's the difference between "all cats are black" and "there exists a black cat"
12:03:35 <sclv> think of exists a. p a as (property p, an a for which p holds true)
12:03:52 <Franciman> and what purpose can they serve that universally quantified cant?
12:03:54 <sclv> and forall a. p a as (function which given any a, returns a proof of p a)
12:03:56 <mk> c_wraith: if a type Trivial a is defined, doesn't that create a constructor, Trivial 1, Trivial "aa" (that is, a function a -> Trivial a ?)
12:04:18 <sclv> in constructive type theoretical terms, at least.
12:04:34 <sclv> existentials and universals are duals too.
12:04:41 <sclv> in that you can build one using the other.
12:04:44 <c_wraith> mk: no..  Constructors are value level.  How do you make a value of type Trivial Int?  Just by using the constructor: Trivial
12:04:50 <Franciman> ah ok
12:04:53 <pqmodn> mk: data Trivial a = T -- the constructor is just "T", which has the type Trivial a
12:04:56 <Franciman> thanks very much :)
12:05:22 <c_wraith> yes, pqmodn makes a good point.  I probably should not have named the constructor the same thing as the type. It's confusing for this purpose.
12:06:26 <mk> I'm not sure I see why a constructor doesn't take arguments. T 1 seems to take an argument
12:07:18 <pqmodn> data Trivial a = T0 | T1 a | T2 a a -- T0 takes no args, T1 takes a argument of type "a", etc
12:08:19 <pqmodn> said another way, T0 :: Trivial a, T1 :: a -> Trivial a, T2 :: a -> a -> Trivial a
12:08:38 <mk> oh, yes, sorry - I follow
12:10:47 <mk> Trivial a = T -- this constructs a single Trivial value having a Trivial type corresponding to 'a'
12:11:37 <pqmodn> yeah, so T :: Trivial a. but like c_wraith was saying, return :: a -> Trivial a. so the constructor T and return aren't the same, because they have different types
12:11:43 <mk> while Trivial a = T a defines a constructor that has a 1-1 mapping with the values of whichever type is fed to it
12:13:00 <mk> I see. But there must be a function that does accept any value of any type (a -> Trivial a), and this function is called return
12:14:27 <mk> usually this condition can be satisfied just by virtue of defining a constructor like Trivial a = T a, but if such a constructor is not specified, then a different function must be defined
12:14:34 <mk> is that right?
12:15:48 <mk> or is there something more to it?
12:18:43 <pqmodn> mk: no i think that's right, return must be defined as such. if you have a one arg constructor that matches the type of return you still may have a reason to not just do return = T, for instance.
12:19:20 <pqmodn> that is if you have T :: a -> T a, you don't *have* to define return = T. you can, of course
12:19:39 <mk> can multiple returns be defined?
12:20:17 <mk> or must there be only one "official" return, to fit the typeclass?
12:22:00 <pqmodn> mk: you'd need to declare multiple instances of Monad
12:22:04 <adnauseam> hpc: awake man? i'm trying to get lambdabot to compile
12:22:14 <pqmodn> mk: which is not allowed in Haskel98, but you can work around it using newtype
12:22:29 <Dilberto> Hola!  Soy un representante de la comunidad linuxiana en Tijuana!  Unanse con nosotros en nuestro canal!  #gultij !
12:22:51 <zzing> Can anyone recommend a good sample of modern opengl code in haskell? Modern meant to refer to programmable pipeline rather than fixed function.
12:23:08 <pqmodn> mk: eg, "instance Monad T where ..." with one definition of return, and another "instance Monad T where ..." with the other definition of return will be rejected.
12:25:08 <mk> pqmodn: ok, so that's a no - if I want a second sort of return, I might as well define a second monad, yes?
12:25:22 <pqmodn> mk: right
12:27:52 <mk> the return function does not need to map onto all values in the monad, while the set of constructors does, correct?
12:29:02 <pqmodn> mk: if you mean define another instance of monad, yes. you don't necessarily have to duplicate T though. there are several avenues: http://www.haskell.org/haskellwiki/Multiple_instances
12:29:57 <pqmodn> mk: also http://www.haskell.org/haskellwiki/Newtype
12:30:52 <relation> is there a way to run this function "partialSort :: (PrimMonad m, MVector v e, Ord e) => v (PrimState m) e -> Int -> m ()" in parallel (for multiple vectors), for example using Par monad? thanks a lot for any answer, even that which say it is impossible.
12:35:07 <mk> in the Maybe monad, return is: return x = Just x (in other words, it maps to the constructor)
12:35:31 <mk> what is a way to define return which violates the monad laws?
12:35:49 <pqmodn> i think return = Nothing would violate one of the laws, unless you also redefined (>>=)
12:36:02 <pqmodn> well, return x = Nothing
12:36:22 <dmwit> Yes, this would violate "return x >>= f = f x".
12:36:47 <dmwit> (For example, with "f = Just".)
12:37:56 <zhulikas> how can I make leksah output execution time of my application?
12:38:31 <pqmodn> also, x >>= return == x would be false for x = Just 1
12:54:28 <jacobian> I need a fixed-point combinator for cabal update; cabal-install
12:54:52 <pqmodn> heh
12:55:18 <jacobian> I think I'm on round 5...
12:57:50 <dmwit> You should not need to cabal update more than once in any given cabal session.
12:58:07 <dmwit> Also, can you say what you're doing that requires multiple invocations of cabal install?
12:58:46 <dmwit> (cabal update only does something interesting when new packages are uploaded to Hackage)
13:00:36 <Targen> Hi.  I've been trying to do a bit of pointless exploration in Hackage by installing lots of things and playing with them, and, as I don't really know what I'm doing, I seem to have horribly broken everything.  I've got a large amount of broken packages.  From what I've read, it seems I've updated core packages, which is apparently something one should almost never do.  Is there some guide on how to fix this sort of mess, or perhaps something that explains
13:00:36 <Targen> how it all works?
13:00:57 <dmwit> Reinstall GHC.
13:01:57 <dmwit> I thought I had that trebla link bookmarked...
13:02:06 <ion> targen: rm -fr ~/.cabal ~/.ghc
13:02:22 <dmwit> Here we go http://www.vex.net/~trebla/haskell/sicp.xhtml
13:02:33 <Targen> ion: I'm afraid I've been too stupid for that solution to work: I've done nearly everything with --global.
13:02:45 <Targen> But if that's the solution, I can fix it.  Thanks :)
13:02:52 <ion> Ouch. Never do that again. :-)
13:03:12 <dmwit> Targen: (That link is for you.)
13:03:25 <Targen> dmwit: Thanks!
13:09:01 <dmwit> wikipedia++
13:11:18 <Philippa_> okay, there's been a policy change in #haskell-ops that people should possibly know about: we're asking non-ops not to idle in there
13:12:34 <Philippa_> if someone's heading in to raise an issue and wants someone to come with them to provide a second non-op log of what happened, that's fine by us
13:17:41 <dmwit> #haskell is big enough that #haskell-ops needs policies!
13:17:53 <dmwit> I think we're failing to avoid success. =)
13:18:11 <hpc> we are avoiding successful failure
13:19:07 <ion> #haskell-ops-ops
13:19:52 <hpc> @let ops chan = chan ++ "-ops"
13:19:53 <Philippa_> ion: we'll need channel inference next!
13:19:53 <lambdabot>  Defined.
13:20:05 <ion> > iterate ops "#haskell"
13:20:07 <lambdabot>   ["#haskell","#haskell-ops","#haskell-ops-ops","#haskell-ops-ops-ops","#hask...
13:20:14 <hpc> :D
13:20:28 <Philippa_> as a couple of brief visitors have discovered, the policy isn't entirely uncontroversial. But yeah, discuss away if you want to
13:22:32 <hpaste> Clint pasted “broken conduit” at http://hpaste.org/66445
13:22:40 <Clint> can anyone see what i'm doing wrong there?
13:23:27 <Saizan> Clint: why do you suspect so?
13:23:43 <ion> philippa: I don’t have an opinion about the matter, but i’m curious: what triggered the change?
13:24:10 <Clint> Saizan: because it quits partway through
13:24:12 <copumpkin> Clint: the tubes might be clogged
13:24:44 <Clint> could be, could be
13:24:54 <Saizan> Clint: with no error message?
13:25:18 <Clint> Saizan: nope
13:25:31 <nand`> What's a good library to read bitmap images (like .png, .jpg or .bmp) and do some processing on them?
13:26:13 <nand`> preferably in some way that's similar to [[Color]]
13:26:23 <nand`> since I'll be doing predominantly row and line-based processing
13:26:38 <Philippa_> ion: we had someone idling who has a history of getting into certain kinds of arguments, and their idling it was having a chilling effect - including on ops
13:27:26 <Philippa_> basically, if someone wants to bring up a sensitive issue, we don't want them having to worry that eg one of the people who they believe are mistreated them is idling in chan and may jump in with more at any moment
13:27:27 <dmwit> nand`: DevIL, gtk, gd
13:28:05 <nand`> ah, I can use Codec.Image.PNG to get a PNGImage
13:28:32 <ion> philippa: Aye, makes sense.
13:30:31 <nand`> dmwit: gd looks good, thanks
13:32:32 <byorgey> nand`: there's also JuicyPixels
13:32:53 <kummerer> hey
13:33:01 <byorgey> which has the advantage of not requiring the FFI, not sure how it compares otherwise
13:33:10 <byorgey> hi kumm...
13:33:18 <byorgey> that was quick
13:39:14 <nand`> byorgey: yeah, gd wraps everything inside IO
13:39:19 <nand`> which would make my code ugly
13:39:27 <byorgey> yep
13:40:44 <zhulikas> > foldl1 (+) [1..3] :: Expr
13:40:45 <lambdabot>   1 + 2 + 3
13:40:54 <zhulikas> how is this thing called? :: Expr
13:41:41 <c_wraith> zhulikas: it's a library that lambdabot has installed
13:41:51 <zhulikas> yeah, but how is the library called?
13:41:54 <zhulikas> I forgot the name of it
13:41:57 <nand`> byorgey: do you have experience working with juicypixels? It uses a “dynamic image type” which is satisfied by RGB images, YUV images etc.; do you know if it errors out if I try to match a dynamic image against a different type than the actual file it was loaded from or will it perform the conversions appropriately?
13:42:04 <nand`> if so, that makes my job much easier, since I'm working with YUV data either way
13:42:27 <byorgey> zhulikas: http://hackage.haskell.org/package/simple-reflect
13:42:32 <zhulikas> thanks
13:42:38 <c_wraith> > reduction $ 1 + 1
13:42:38 <lambdabot>   Not in scope: `reduction'
13:42:47 <byorgey> nand`: I don't know, I've never used it
13:42:56 <Ptival> what's the simplest immutable 2d array in Haskell?
13:43:01 <ezyang> Having too much fun with the <* <$ combinators
13:43:03 <nand`> okay, thanks for the suggestion either way
13:43:09 <byorgey> ezyang: not possible
13:43:37 <byorgey> Ptival: use Data.Array with (x,y) indices.
13:43:37 <nand`> I guess I'll find out :)
13:44:07 <ezyang> They're so handy for parser combinators
13:44:23 <dmwit> JuicyPixels, eh?
13:44:32 <Ptival> byorgey: thanks
13:44:34 <byorgey> ezyang: indeed!
13:44:43 <Targen> So, reading a bit about the limits on the scope of cabal-install and the fun consequences it has (packages breaking, more packages breaking, packages breaking horribly, often having to compute dependency closures by hand to do things like removing packages and such)... is there some proper solution to these issues?  Some extension of the idea of cabal-install that does more things?
13:45:30 <byorgey> Targen: the (unreleased) HEAD version of cabal-install apparently has a rewritten/much improved dependency solver which does a better job.
13:45:35 <dmwit> The situation is improving. Newer cabal-install's warn you before they break things. =)
13:45:55 <Targen> Great. :)  I'll check it out then.
13:46:18 <unlink> e.g. java -Dsome.property=value clojure.main script.clj
13:46:21 <byorgey> But it's a very difficult problem.  I don't know if a "proper solution" is possible, or what that would even mean.
13:46:32 <unlink> wrong channel. sorry.
13:46:54 <dmwit> A proper solution is easy. Let the version "number" of a package include the versions of its dependencies.
13:47:06 <ezyang> In other news, is there a word for transforming: (try (string "foo" >> bar) <|> (string "foo" >> baz))) to (string "foo" >> (bar <|> baz))?
13:47:10 <dmwit> It's just too space-intensive to be worth it.
13:47:13 <ezyang> I'm tempted to call it factoring.
13:47:14 <Targen> Indeed.  I was a Gentoo user for years and years, so I'm too familiar with the difficulties of this sort of system.  I still have nightmares. ;)
13:47:16 <sm> new cabal won't break your packages unless you really force it to, just this is a big improvement
13:47:21 <dmwit> ezyang: Yes, it's called left-factoring.
13:47:30 <hpc> ezyang: distributing?
13:47:39 <dmwit> distributing is the other way
13:48:09 <hpc> oh, that it is
13:48:18 <ezyang> dmwit: cool.
13:49:06 <dmwit> Hm, it suddenly occurred to me that I must not have understood that paper I read yesterday.
13:49:35 <dmwit> It talked about grammars being both LR and RL, the latter of which I assumed meant right-recursive, but that would be RR.
13:49:48 <Targen> Right2010
13:49:51 <Targen> whoops.
13:49:54 <Targen> Right-to-left?
13:50:17 <dmwit> According to Google, "right-linear" is more likely.
13:50:23 <Targen> Ah, indeed.
13:50:44 <dmwit> That's quite a strong restriction, actually.
13:52:23 <dmwit> I wonder if they just made a mistake. They claimed Pascal was RL, but RL can't even match parentheses according to this Wikipedia page.
13:52:43 <Saizan> RL would be reading input Right to left and producing a Left-most derivation, i think
13:52:55 <hpc> RL can match parens
13:53:18 <dmwit> hcp: "a simple example of a context-free, non-linear language is the Dyck language of well-balanced bracket pairs"
13:53:21 <dmwit> hpc, I mean
13:53:26 <dmwit> http://en.wikipedia.org/wiki/Linear_grammar
13:54:06 <Saizan> i.e. an RL-parser would work like that, and an RL-grammar is one that can be parsed like that without lookahead
13:54:08 <dmwit> Anyway, yeah, they use the notation RL(k), so I feel confident they just mean either RR(k) or the reversal of the language is LR(k).
13:54:39 <dmwit> Perhaps those two conditions are the same, I don't even know.
13:57:07 <fdsgdsfg> How do I create an Object in Haskell?
13:57:19 <byorgey> fdsgdsfg: what do you mean by Object?
13:57:29 <hpc> @hoogle Object
13:57:30 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Objects module Graphics.Rendering.OpenGL.GL.Texturing.Objects
13:57:30 <lambdabot> Graphics.UI.GLUT.Objects module Graphics.UI.GLUT.Objects
13:57:30 <lambdabot> Graphics.UI.GLUT.Objects data Object
13:57:36 <dmwit> hpc--
13:57:42 <hpc> :P
13:57:54 <Targen> They shouldn't be, I believe.  Shouldn't the relationship between "the reversal is LR(k)" and RR(k) be the same as the one between LL(k) and LR(k)?
13:58:04 <dmwit> hpc++ okay okay jokes shouldn't be punished =P
13:58:23 <byorgey> jokes that confuse newbies should be.
13:58:44 <dmwit> Targen: Ah, good point.
13:59:02 <hpc> fdsgdsfg: if you mean "Object" as in an actual data type, check Graphics.UI.GLUT.Objects
13:59:16 <hpc> fdsgdsfg: if you mean the java notion of "Object", that notion doesn't exist in haskell
13:59:18 <Targen> dmwit: What paper is this, by the way?  It sounds fun.
13:59:29 <dmwit> Oh, here's a footnote! "G is RL(k) iff its reversal is LR(k)"
13:59:37 <fdsgdsfg> hpc: But Haskell is OOP, right?
13:59:47 <dmwit> Targen: "Incremental Parsing" by Ghezzi and Mandrioli
13:59:57 <hpc> no
14:00:01 <Targen> I'll look it up. :)
14:00:35 <fdsgdsfg> dmwit: the best is yacc, right?
14:01:19 <byorgey> fdsgdsfg: no, it is not.  Haskell is functional.  It's quite a different style than OOP.
14:01:34 <fdsgdsfg> Thanks!
14:02:44 <fdsgdsfg> Are there any modern day consumer applications created with Haskell?
14:03:07 <dmwit> ?google haskell in industry
14:03:09 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
14:03:09 <lambdabot> Title: Haskell in industry - HaskellWiki
14:03:31 <Philippa_> I'm not familiar with many myself, most are intended for other programmers or industrial use
14:04:10 <Philippa_> rather, plenty exist, but we're not talking nice big GUI apps for the most part
14:04:22 <hpc> @google darcs
14:04:24 <lambdabot> http://darcs.net/
14:04:24 <lambdabot> Title: Darcs
14:04:53 <hpc> @google pugs
14:04:54 <lambdabot> http://en.wikipedia.org/wiki/Pug
14:04:54 <lambdabot> Title: Pug - Wikipedia, the free encyclopedia
14:05:00 <Targen> A generous-enough definition of "consumer" would admit at least xmonad.
14:05:00 <dmwit> See also: ^F "program:" on http://hackage.haskell.org/packages/archive/pkg-list.html
14:05:01 <hpc> @google perl pugs
14:05:03 <lambdabot> http://en.wikipedia.org/wiki/Pugs
14:05:03 <lambdabot> Title: Pugs - Wikipedia, the free encyclopedia
14:05:04 <hpc> -- rather
14:05:10 <Enigmagic> heh
14:05:59 <Philippa_> pandoc's a favourite in that ballpark
14:06:14 <hpc> or snap/yesod/happstack
14:06:33 <Clint> git-annex
14:06:46 <Philippa_> that's tools to build consumer stuff rather than consumer stuff though. Pandoc's at least got plenty of non-programmer uses - niche, but consumer
14:07:01 <Philippa_> (well, prosumerish, but if Office counts as consumer here?)
14:07:41 <fdsgdsfg> Thanks!
14:08:00 <fdsgdsfg> Haskell is just a calculator. Discuss
14:08:44 <Enigmagic> Computers are just calculators that are used to watch porn.
14:09:48 <JoeyA> Should we @remember that?
14:10:38 <hpc> nah
14:10:42 <nand`> @pl \c -> a (b c) c
14:10:42 <lambdabot> a =<< b
14:12:23 <nand`> @pl \c -> a (\x y -> x * b c x y) c
14:12:24 <lambdabot> a =<< liftM2 (.) (*) . b
14:12:42 <dmwit> readable
14:12:44 <dmwit> ship it
14:12:46 <nand`> hehe
14:12:56 <nand`> I think I'll stick with the verbose form
14:16:03 <Rudii> what can we use the bot for in this channel?
14:16:14 <Rudii> any kind of help command to find out?
14:16:15 <pqmodn> companionship
14:16:19 <hpc> @list
14:16:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:16:27 <hpc> (it's a pretty shitty list though)
14:16:30 <Rudii> appreciated
14:16:35 <Phlogistique> lambdabot: Can you help Rudii?
14:16:54 <Rudii> don't think he does man :(
14:17:04 <Phlogistique> ...isn't it supposed to answer "Yes, Haskell can do that."
14:17:08 <Phlogistique> at some point it did.
14:17:32 <hpc> @faq can haskell suddenly take away features that probably never existed?
14:17:32 <lambdabot> The answer is: Yes! Haskell can do that.
14:17:51 <sipa> @vixen can you provide companionship for Rudii?
14:17:51 <lambdabot> Don't try to take on a new personality; it doesn't work.
14:18:13 <hpc> is vixen still an alias to @nixon?
14:18:26 <hpc> @vixen i really can't tell
14:18:27 <lambdabot> Once you get into this great stream of history, you can't get out.
14:18:31 <hpc> yep, still nixon
14:18:46 <fdsgdsfg> @faq 5 / 0
14:18:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:18:55 <hpc> > 5/0
14:18:56 <lambdabot>   Infinity
14:19:21 <hpc> (not a bug, it's the wacky upside-down world of IEEE floats)
14:19:48 <Philippa_> fdsgdsfg: all computable functions are equivalent to some endofunction on the natural numbers. So yes, but aside from IO concerns and the ilk, so's any programming language
14:20:58 <sipa> @nixon are you alive?
14:20:58 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
14:21:29 <hpc> @where waldo
14:21:29 <lambdabot> http://planet.haskell.org
14:21:37 <hpc> lolwut
14:24:24 --- mode: ChanServ set +o mauke
14:26:24 --- mode: mauke set -o mauke
14:28:29 <t7> what happens if i write to a handle after calling hGetLine
14:28:32 <t7> in another thread
14:28:38 <t7> is that safe :)
14:29:27 <dmwit> t7: Try it and see. =)
14:29:28 <Philippa_> lazy IO does dodgy stuff, if that's what you're wondering! But you shouldn't segfault or anything
14:29:41 <t7> dmwit: it will take hours to set up
14:29:42 <dcoutts> t7: it is safe in the sense that it'll not crash, but I'm not sure if it'll block 'til the previous op is done or if it'll proceed
14:30:04 <dmwit> hours lol
14:30:12 <dcoutts> t7: Handles have a MVar lock in them internally, so all handle ops are thread safe
14:30:22 <t7> ah cool
14:30:27 <t7> but
14:30:37 <t7> i would like to be able to send :|
14:33:03 <Ptival> is STUArray () a normal thing to have?
14:34:22 <copumpkin> no, if that's the state token type
14:34:27 <hpaste> nand` pasted “Image center” at http://hpaste.org/66447
14:34:29 <copumpkin> especially since it has kind * -> * -> *
14:34:35 <copumpkin> which means it might be hard finding values
14:34:55 <t7> @hoogle a -> [a] -> [a]
14:34:56 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:34:56 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:34:56 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:35:48 <Ptival> copumpkin: I meant STUArray () (,) Bool or something...
14:36:07 <copumpkin> no
14:37:04 <dmwit> still looks like a kind error
14:37:11 <copumpkin> :)
14:37:19 <copumpkin> I'm assuming he means (Int,Int) or something
14:37:31 <Ptival> yes
14:37:34 <dmwit> It's still being applied to like... eight arguments.
14:37:42 <copumpkin> it should have three
14:37:47 <dmwit> Anyway, normal is "forall s. STUArray s SomethingConcrete"
14:37:59 <dmwit> ah, yeah, three
14:38:03 <copumpkin> yeah, if you have anything concrete in your state token
14:38:07 <copumpkin> you won't be able to runST it
14:38:10 <dmwit> Anyway, normal is "forall s. STUArray s SomeIndex SomeConcreteElementType"
14:38:19 <Ptival> ok
14:38:29 <copumpkin> now the question is how did you get () in there?
14:38:39 <copumpkin> none of the standard functions pick anything specific for s
14:38:48 <Ptival> I did not, I thought I had to provide a state and I have no idea what I want as a state :)
14:38:53 <copumpkin> oh, nope :)
14:39:29 <Ptival> I need to write down a type signature to make Haskell happy with the function it gladly type-checked anyway
14:39:57 <t7> @hoogle IO a -> IO ()
14:39:57 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:39:57 <lambdabot> Control.Exception.Base block :: IO a -> IO a
14:39:57 <lambdabot> Control.Exception block :: IO a -> IO a
14:40:09 <copumpkin> Ptival: yeah, that type parameter is never used at the value-level
14:41:12 <Ptival> it's a phantom type?
14:41:25 <Ptival> or existential type?
14:41:28 <Ptival> or something? :p
14:41:39 <copumpkin> phantom
14:41:46 <Ptival> ok
14:42:00 <copumpkin> :t runST
14:42:01 <lambdabot> forall a. (forall s. ST s a) -> a
14:42:21 <copumpkin> it's just a trick to prevent leakage
14:42:26 <copumpkin> a clever one :)
14:42:53 <Elemir> > maybeToList . listToMaybe
14:42:54 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
14:42:54 <lambdabot>    arising from a use ...
14:46:59 <t7> my p2p is working
14:47:14 <t7> soon i will have the worlds most powerful botnet
14:47:19 <t7> written in haskell
14:47:33 <t7> i wonder how to do upnp....
14:47:34 <kaitocracy> is there a generalized null function? basically null = (== mempty)
14:47:47 <copumpkin> kaitocracy: you can write one for any Foldable instance, if you like
14:47:56 <copumpkin> but no, I don't think so otherwise
14:53:09 <hpaste> nand` annotated “Image center” with “Image center (annotation)” at http://hpaste.org/66447#a66448
14:54:30 <zhulikas> @hoogle [m a] -> m [a]
14:54:30 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:54:31 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:54:31 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
14:55:31 <qnikst> how to apply list of functions to value and get list to get list of new values?
14:56:20 <t7> accept is giving me a weird port number
14:56:27 <copumpkin> qnikst: map
14:56:28 <t7> wtf ...
14:56:43 <copumpkin> t7: what's wrong with that?
14:56:52 <qnikst> copumpkin: comap?
14:56:52 <t7> well i am listening on 1234
14:57:00 <t7> and accept is returning 61312
14:57:02 <sipa> t7: is it telling you the source port?
14:57:02 <t7> or something
14:57:04 <copumpkin> qnikst: oh, sorry, I was confused
14:57:07 <copumpkin> qnikst: use sequence
14:57:19 <copumpkin> t7: the port accept gives you isn't the listen port
14:57:25 <qnikst> :t sequence
14:57:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:57:36 <t7> do i get a new one for every client or something?
14:57:50 <copumpkin> > sequence [(+1), (*6), (/4)] 5
14:57:51 <lambdabot>   [6.0,30.0,1.25]
14:57:53 <copumpkin> r7: yeah
14:57:58 <qnikst> ok
14:58:00 <qnikst> thanks
14:58:15 <t7> i never knew that...
14:58:26 <qnikst> @hoogle sequence
14:58:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:58:26 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:58:26 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
14:58:47 <qnikst> copumpkin: it's prelude one?
14:58:52 <copumpkin> Control.Monad
14:58:53 <Elemir> Hem
14:58:57 <copumpkin> and you might need Control.Monad.Instances too
14:59:06 <Elemir> Vty doesn't support unicode input??
14:59:33 <hpaste> int80_h pasted “fun with sequence” at http://hpaste.org/66449
15:00:37 <int80_h> hiya
15:05:10 <Peaker> int80_h: foldr (.) id should come in handy
15:08:02 <int80_h>  Peaker : ah..okay now I have something to play with
15:08:09 <int80_h>  Peaker: thanks :)
15:08:21 <dmwit> int80_h: do { f <- [foo, bar, baz]; x <- [PreVal .. PostVal]; return (f x) }
15:09:19 <Peaker> oh silly me, int80_h, ignore me ;) Your func isn't a->a
15:10:13 <Peaker> for dmwit's solution gonna need a deriving (Enum) on Step
15:11:19 <dmwit> probably also need a toplevel sequence_ or something
15:12:07 <int80_h> ah thanks :)
15:21:42 <fetter_oml> its outrageous how easy learning haskell is
15:22:09 <bill```> the amount of errors in real world haskell was infurating, but aside from that i agree
15:22:35 <fetter_oml> especially if you realise that youve tried to programm functionally all your life, and it was a pain in the ass not being able to
15:22:51 <edwardk> fetter_oml: thats pretty much how i fell into the community here
15:23:19 <yan_> is there a straightforward way to convert [Char] to ByteString for testing my ByteString funcs
15:23:30 <alpounet> yan_, pack?
15:23:34 <copumpkin> fetter_oml: it's interesting how some people feel the way you do (I did) and others consider it to be a huge pain to learn
15:23:36 <adnauseam> regarding FlexibleInstances, where should i insert it in a file ?
15:23:44 <yan_> alpounet: pack takes Word8s, no?
15:23:53 <c_wraith> yan_: different pack.  see .Char8
15:23:59 <yan_> ah ty
15:24:03 <fetter_oml> and the learnyouahaskell.com tutorial is damn good, does the author live around #here ?
15:24:05 <alpounet> yan_, Data.ByteString.Char8.pack doesn't, it takes [Char]
15:24:16 <edwardk> fetter_oml: i had had a whole host of toy language designs that were all trying to figure out how to reuse purity and idempotence in an imperative setting, had written tons of crazy c++ template metaprograms. then wham a decent pure functional programming language smacked me upside the head.
15:24:18 <c_wraith> yan_: just be aware of what does to non-ascii characters. :)
15:24:31 <edwardk> fetter_oml: BONUS comes on here from time to time
15:24:33 <alpounet> fetter_oml, he used to but hasn't been around for a while now I think
15:24:39 <edwardk> fetter_oml: not so much lately though
15:24:43 <alpounet> preflex, seen BONUS
15:24:43 <preflex>  BONUS was last seen on #haskell 340 days, 2 hours, 56 minutes and 44 seconds ago, saying: yeah i think that's better as well
15:24:59 * fetter_oml wants to capture and hug him
15:25:02 <t7> @hoogle (a -> Bool) -> [a] -> Bool
15:25:03 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
15:25:03 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
15:25:03 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
15:25:30 <drdo> a -> State# s -> (# State# s,a #)
15:25:38 <fetter_oml> well, enough of a break. time to dive into another chapter
15:25:39 <drdo> What do those surrounding hashes mean?
15:25:58 <edwardk> drdo: the (#   #) pair mean 'unboxed tuple'
15:26:01 <c_wraith> drdo: they're part of a GHC extension.  Usually used to indicate low-level thing
15:26:02 <c_wraith> s
15:26:08 <c_wraith> drdo: like unboxed types
15:26:15 <drdo> edwardk: Oh, alright
15:26:18 <edwardk> normally a tuple can be lazy in its own right
15:26:39 <edwardk> (# ,  #) is saying to actually return two separate values without wrapping them in something
15:26:56 <c_wraith> If you're seeing State# s, you're probably looking at ST/IO's implementation
15:27:05 <edwardk> the # in State is just a cute that its a low level thing, and that it doesn't have kind *.
15:27:08 <edwardk> :k State#
15:27:08 <lambdabot> Not in scope: type constructor or class `State#'
15:27:09 <c_wraith> Or something that works with their implementation
15:27:30 <drdo> I'm looking at using MVector's from remote's ProcessM
15:27:40 <alpounet> c_wraith, or a shootout impl? hah
15:27:40 <edwardk> internally, when you take apart an Int, it is data Int = I# Int#
15:27:51 <edwardk> where Int# has kind # not *
15:27:55 <Enigmagic> i want type family support for (#)
15:28:10 <Targen> What's the preferred/practical way to install GHC and friends manually if one expects to break things and have to delete everything and reinstall and such?  I ask mostly because it seems the makefiles in the GHC binary packages for Linux offer no uninstall mechanism...
15:28:20 <acowley> I pretty much alternate between spelling "lazilly" and "lazily". This is not helping the aesthetics of my comments and log messages.
15:28:26 <drdo> There doesn't seem to a MonadIO implementation of PrimMonad
15:28:33 <edwardk> State# takes a 'world' (typically the RealWorld) and gives you a value of kind # to represent that world. it takes up no space, its passed as a 0-width argument
15:28:49 <drdo> *It looks like there's isn't a MonadIO implementation
15:28:53 <acowley> Does anyone know if there's a name for an algebraic structure like a semiring where the multiplicative identity element is an absorbing element for the addition operation?
15:29:07 <edwardk> drdo; correct, just IO and (ST s)
15:29:09 <DanBurton> a value that takes up no space. Interesting.
15:29:17 <edwardk> you could implement one for any particular monad you need though
15:29:19 <c_wraith> drdo: PrimMonad can't be MonadIO.  ST is built on top of it.
15:29:26 <Targen> That is, is it a good idea or does anyone have experience doing something like installing all Haskell-related stuff in something like /usr/local/haskell/*
15:29:34 <edwardk> since all you need is the monad homomorphism from IO
15:29:49 <drdo> c_wraith: I mean the other way around, every MonadIO being a PrimMonad
15:29:56 <c_wraith> Targen: I just install it all in my user directory.  Or in multiple subdirectories of it when I want multiple GHCs
15:30:43 <edwardk> Targen: just install it in your current user, it runs fine and most things wind up in ~/.cabal
15:30:56 <Targen> edwardk, c_wraith: That seems like a much better strategy.  Thanks!
15:31:07 <drdo> I can just lift it anyway, so it's fine
15:31:34 <edwardk> drdo: the problem is you can't just make 'every MonadIO into an instance of PrimMonad', not without bad overlapping instances
15:32:30 <edwardk> you can make instances for particular instances of MonadIO, you can make default signatures for when its a MonadIO to ease that burden, and you can make a newtype wrapper for folks who didn't think to make their MonadIO based monad an instance of PrimMonad, but thats about it
15:32:33 <djahandarie> acowley, I haven't heard of one :(
15:33:07 <acowley> To give an example of my out-of-the-blue question, probabilities form a handy semiring with max as the addition operation and numeric multiplication as the multiplication operation. The multiplicative identity element, 1, is also an absorbing element for max on probabilities. Natural numbers have a similar construction.
15:33:27 <acowley> djahandarie: Me either, and I have no idea how to track down what such a thing might be called other than asking here :/
15:34:07 <dmwit> Well, there's #math or ##math or whatever.
15:34:32 <edwardk> djahandarie: would it be possible to get something like fmapNewtype :: Newtype n o => (o -> n) -> f o -> f n; fmapNewtype _ = unsafeCoerce and the obvious funmapNewtype added to Control.Newtype?
15:34:46 <edwardk> er
15:34:56 <edwardk> fmapNewtype :: (Functor f, Newtype n o) => ...
15:35:01 <acowley> dmwit: Yes, but I tend to be more optimistic that #haskell or ##categorytheory will answer my questions in terms I understand :)
15:35:22 <edwardk> and -- in a partect world -- the analogous contramapNewtype and uncontramapNewtype
15:35:54 <djahandarie> edwardk, I've needed that myself before actually, so maybe... but it feels dirty having unsafeCoerce there, since we don't have a REAL guarantee it's a newtype
15:36:10 <edwardk> djahandarie: yes, but it can make a huge asymptotic difference
15:36:57 <edwardk> er s/partect/perfect
15:36:59 * byorgey would find it very surprising if functions exported by Control.Newtype break when you give an instance which does not actually involve a newtype.
15:37:21 <byorgey> maybe we should have  fmapNewtype and unsafeFmapNewtype.
15:37:41 <djahandarie> edwardk, dunno. I have already seen a reasonable number of uses that are more like 'isomorphism' than 'newtype'
15:37:43 <edwardk> i just want the operations
15:37:55 <djahandarie> I think I could shove them into a seperate model
15:38:11 <edwardk> i don't care what you call them so long as i have a canonical place to find them that i don't have to write
15:38:18 <djahandarie> Control.Newtype.Unsafe
15:38:22 * byorgey wants a 'lift2'-type function for Control.Newtype as well.
15:38:25 <edwardk> djahandarie: thats fine
15:38:34 <edwardk> djahandarie: thats even better actually
15:38:35 <dolio> I thought we already determined that unsafeCoercing was actually unsafe.
15:39:00 <djahandarie> I thought we determined it was safe? Unless this was another conversation that I wasn't involved in
15:39:19 <zhulikas> is it possible to append haskell code into specific modules during compilations based on QQ which is written at some place?
15:39:19 <dolio> I know Conor wanted something that looked safe but wasn't.
15:39:34 <dolio> Maybe it was unrelated.
15:39:35 <edwardk> bah, "Man Up and Use UnsafeCoerce" (MUAUUC?) ;)
15:39:50 <djahandarie> I think I know what you're talking about dolio
15:39:55 <zhulikas> so code is not placed instead of QQ, but appended in various places (quite unrelated ones)
15:40:08 <djahandarie> I definitely remember seeing blah = unsafeCoerce somewhere in one of his blogs... can't quite remember
15:40:08 <acowley> ##math is much more chaotic than #haskell :/
15:40:48 <dolio> The problem is usually in conjunction with generalized newtype deriving.
15:41:23 <dolio> Which can write instances that are impossible to actually write by hand using newtype wrappers.
15:42:09 <hpc> dolio: orly?
15:42:22 <dolio> Unless they've fixed it lately.
15:43:00 <byorgey> no, still not fixed.
15:43:28 <edwardk> i can still do the iso hack at last check
15:45:07 <acowley> Okay, I guess ##math is a fun twist on the usual internet mix of insanity and depravity.
15:45:13 <dolio> hpc: Basically, newtype deriving assumes that since A is represented the same as newtype B = B A, that T A is the same as T B for arbitrary T.
15:45:16 <edwardk> class Iso a b where iso :: f a -> f b; osi :: f b -> f a; instance Iso a a where iso = id; osi = id  -- then newtype derive instances of Iso OldType for newtype Newtype = Newtype Oldtype
15:45:51 <dolio> But T can in general do case analysis on its argument to determine what type it is.
15:45:52 <edwardk> the unsafeCoerce being used above is a more principled iso hack
15:45:58 <hpc> dolio: oh, huh
15:46:14 <hpc> dolio: like with gadts?
15:46:32 <dolio> Or type families.
15:46:33 <byorgey> hpc: yes, with gadts or type families.
15:46:35 <edwardk> hpc: consider letting f be 'Set'
15:46:59 <dolio> Yeah, it's also a problem with Set.
15:47:03 <edwardk> and just have a newtype Reverse = Reverse Int deriving (Iso Int)  -- with a custom Eq,Ord, etc
15:47:14 <edwardk> you can iso :: Set Int -> Set Reverse
15:47:20 <dolio> You can produce an ill-formed set that way.
15:47:21 <edwardk> but it didn't resort the set
15:47:38 <djahandarie> Heh
15:47:48 <hpc> oh neat
15:48:08 <dolio> Of course, you can do that with the Set API anyway.
15:48:21 <dolio> But the docs will warn you at least.
15:48:25 <edwardk> hpc: in general generalized newtype deriving needs a lot of extra checks that nobody is sure how to state
15:48:32 <hpc> but iso doesn't "look unsafe", yeah
15:48:35 <edwardk> well, the Set API version pays to traverse it
15:48:45 <dolio> Well, "mapMonotonic" doesn't necessary look unsafe.
15:48:47 <edwardk> i'm trying to avoid walking over it
15:48:50 <dolio> Unless you know what it's doing.
15:49:19 <hpc> dolio: it at least indicates "f should be monotonic"
15:49:28 <edwardk> the safety side-condition is why i wanted the Functor instance constraint for fmapNewtype
15:49:30 <hpc> visually, at least
15:50:34 <dolio> That won't be good enough when people put constrained functors in. :)
15:50:48 <dolio> So, 30 years from now or so.
15:50:52 <edwardk> =P
15:51:06 <edwardk> in the meantime i'll get 30 years of productive code and be retired on a beach somewhere
15:53:29 <djahandarie> lol
15:58:33 <Elemir> Guys, there can I found ghc-7.0 for some tests?
15:58:50 <Elemir> Without installation, btw
15:59:25 <tech2> Elemir: what kind of tests?
15:59:48 <Elemir> newCString "й" >>= (\buf -> peekCStringLen (buf, 1))
15:59:57 <Elemir> Run this string
16:00:05 <geekosaur> afaik you need to install it *somewhere* for testing; but virthualenv will let you set up a sandbox with its own compiler
16:00:13 <dpratt71> occasionally I try to learn something by looking at how certain core library functions are implemented; I usually do this via Hoogle/Hackage, but for class instance methods, it doesn't work so well; is there a way?
16:00:44 <Elemir> geekosaur: I told about web test or free shells
16:01:42 <byorgey> Elemir: I don't know of any such thing.
16:02:49 * Elemir knows codepad, but their version of ghc is unknowed for me
16:05:30 * hackagebot clua 0.3 - C to Lua data wrapper generator  http://hackage.haskell.org/package/clua-0.3 (TomSchouten)
16:09:07 <acowley> Elemir: there's http://about.travis-ci.org/blog/announcing_support_for_haskell_on_travis_ci/
16:10:01 <mk> if I have a monad where there is only 1 monadic value per type, and return simply returns that value, then what must bind look like?
16:11:28 <Philippa_> build the only non-bottom value of the appropriate type
16:12:18 <mk> so it doesn't have to feed the value through the function at all?
16:12:25 <Philippa_> I think you can still do that if the input's bottom
16:12:32 <pqmodn> mk: i got stuck too, because m a -> (a -> m b) -> m b -- you don't need to actually apply (a -> m b)
16:12:35 <pqmodn> mk: right
16:12:39 <Philippa_> well, you can prove what it's supposed to be
16:12:53 <mk> Philippa_: I'm pretending bottom doesn't exist
16:12:55 <Philippa_> (modulo _|_, but you've got a choice there)
16:13:10 <Philippa_> then you've got a choice between matching on the expected input or just being const result
16:13:42 <mk> pqmodn: I'm still confused there, because of one of the monad laws...
16:14:25 <mk> bind(return(V), f) = f(V)
16:14:28 <pqmodn> mk: i think this would work: x >>= f = Trivial. or as Philippa_ says, you could pattern match: (>>=) Trivial f = Trivial
16:14:44 <Philippa_> or optionally, f Trivial
16:14:49 <mk> pqmodn: the >>= notation confuses me at the moment
16:15:40 <pqmodn> mk: you can convert infix operators to regular-looking functions like this: (>>=) x f rather than x (>>=) f
16:15:44 <mk> if bind can take any arbitrary monadic function, how can that law be met?
16:15:49 <pqmodn> mk: sorry, rather than x >>= f
16:16:24 <Philippa_> mk: because modulo bottom, we know it's const Trivial
16:16:53 <mk> oh, I guess if the only monadic value that exists is Trivial/T, then all those monadic functions will be forced to return it
16:16:58 <pqmodn> mk: yeah
16:17:24 <pqmodn> mk: bind :: m a -> (a -> m b) -> m b -- f must have the type a -> m b, the only "m b" value is Trivial
16:17:27 <Philippa_> and you'll be forced to pass _|_ to the function anyway
16:17:36 <Philippa_> (otherwise, you don't have an a handy)
16:17:44 <mk> ok, that's coming together a bit... so what if we have Trivial a ... T1|T2?
16:18:00 <pqmodn> Philippa_: ah, now i get why you mention _|_
16:18:29 <Philippa_> hrmm, and f might reasonably be strict
16:18:48 <mk> Philippa_: I'm not familiar at all with how bottom works, but I worry that trying to fit that in too will be confusing
16:19:04 <Philippa_> mk: for now, it's just another value
16:19:13 <Philippa_> but it's also the /only/ thing that can have the type forall a.a
16:19:14 <mk> Philippa_: of which type?
16:19:20 <pqmodn> mk: x >>= f = Trivial -- or k >>= f = f undefined -- undefined :: a
16:19:38 <pqmodn> mk: it's a member of every type
16:19:44 <pqmodn> :t undefined
16:19:45 <lambdabot> forall a. a
16:19:49 <mk> pqmodn: can I pretend it doesn't exist?
16:20:12 <pqmodn> mk: you don't need to understand it yet if you don't want to think about it
16:20:13 <Philippa_> if you do that, your only option is to ignore f completely
16:20:31 * hackagebot yall 0.1 - Lenses with a southern twang  http://hackage.haskell.org/package/yall-0.1 (BrandonSimmons)
16:21:10 <pqmodn> mk: there's no way to construct an arbitrary value of type"a" though, without something like "undefined".
16:21:15 <Philippa_> (but you can assume for total input, you're going to get Trivial back then)
16:21:18 <mk> I'm not sure what f is, and I might be unable to understand why I'd need to ignore f unless I first understand bottom
16:21:22 <tazjin> I saw a paper very recently on the general design of GHC, I think SPJ was one of the authors - can't seem to find it anymore, does anyone have an idea where I could have seen that / where it is?
16:21:46 <Philippa_> pqmodn: yeah. The monad laws dictate what the result would have to be given a total function, though
16:22:06 <Philippa_> (we know the function modulo _|_ is const Trivial)
16:22:14 <Philippa_> (we know that the input 'should' exist...)
16:22:30 <Philippa_> (we know we have to behave as if the function received that input, which we happen to've discarded)
16:22:55 <pqmodn> mk: if f has the type "a -> m b", and you want to apply an "a" to f, where can you get an "a"? take Maybe as an example, Maybe a = Just a | Nothing -- well, we can get an "a" by deconstructing Just. however with Trivial, there's no wrapped "a"
16:23:00 <mk> I have no idea what modulo means
16:23:02 <Ralith> tazjin: OutsideIn(X)?
16:23:15 <Philippa_> mk: pretending _|_ doesn't exist
16:23:48 <ivanm> if I have two lists of values xs and ys (of equal length) and I want to create a mapping function between them f :: x -> y (such that xs !! i --> ys !! i), is there a more efficient way of doing so than using an intermediary Map?
16:24:19 <acowley> Broken associated type defaults are giving me fits. I have some code for which GHC produces interface files that it rejects on subsequent recompilations due to the bug of the default not being properly propagated.
16:24:22 <Philippa_> pqmodn: we can prove what would happen if we'd kept the a. Ain't it great?
16:24:35 <mk> pqmodn: I'm not sure I follow. With trivial, there's simply a dummy value, and there's one such value for every type that Trivial allows (all of them)
16:24:40 <tazjin> Ralith: Nope, not that one. I think the title was really just "The Glasgow Haskell Compiler", but it's not in the list of papers on SPJ's Microsoft Research site
16:24:50 <Philippa_> (but once _|_ is in the picture, you're in trouble because you need to propagate f's strictness)
16:24:52 <pqmodn> Philippa_, :)
16:25:32 * hackagebot PDBtools 0.0.2 - A library for analysis of 3-D protein coordinates  http://hackage.haskell.org/package/PDBtools-0.0.2 (GrantRotskoff)
16:25:51 <pqmodn> mk: the value has the type "m a" here, where m = Trivial.
16:25:54 <c_wraith> ivanm: an intermediate structure giving good lookup times is probably your best bet - unless your use case looks things up only one or twice
16:26:42 <pqmodn> mk: because Trivial isn't actually wrapping an "a" value, we can't apply f without manufacturing an "a" value.
16:26:47 <mk> pqmodn: right - but there are numerous such values. If the language presently has bools and ints, then by defining this function we now have MBool and MInt
16:28:00 <pqmodn> mk: let me back up a second, does this make sense: x >>= f = Trivial
16:28:01 <mk> pqmodn: I'm not sure I follow. Why do we need to apply f?
16:28:18 <ivanm> c_wraith: yeah, I'm using a Map, it's just slow (going from a direct linear addition shift to a lookup replacement) :s
16:28:45 <ivanm> might try leaving it as a list
16:28:46 <mk> pqmodn: bind(x,f) = TR (let's call that single Trivial a typed value TR) - right?
16:29:04 <c_wraith> ivanm: if the type of x is suitably constricted, you might be able to do better. If it's something that could be an Ix efficiently, for instance.
16:29:04 <mk> where f is a monadic function
16:29:05 <pqmodn> mk: right. in this case you don't need to apply f
16:29:19 <ivanm> c_wraith: newtypes around Words
16:29:23 <mk> pqmodn: right, you simply know that you're going to be returning TR in any case
16:29:43 <c_wraith> ivan: unsorted-containers HashMap then?
16:30:04 <pqmodn> mk: i thought you were asking how can we apply f. which is an interesting question, and you *can* apply f
16:30:24 <pqmodn> mk: this is another definition, x >>= f = f undefined
16:30:29 <mk> pqmodn: right - you were saying that we needed to apply f, or something?
16:30:39 <pqmodn> mk: no you don't need to. you can, though
16:30:49 <ivanm> c_wraith: I thought unsorted-containers was useful for things like Strings, etc. rather than numeric types :s
16:31:01 <mk> pqmodn: bind(x, f) = f-undefined? I'm not sure what f undefined means
16:31:06 <pqmodn> mk: but to apply f, you need to know about _|_ (aka undefined)
16:31:18 <pqmodn> :t undefined
16:31:19 <lambdabot> forall a. a
16:31:23 <c_wraith> ivanm: it's a better implementation of IntMap, for your use case
16:31:37 <c_wraith> ivanm: it has a special optimized fromList, too
16:31:38 <mk> pqmodn: but what does the syntax "f undefined" mean?
16:31:52 <pqmodn> mk: basically, undefined = undefined. this would never terminate, but we can convince the type checker that it has *any* type.
16:32:02 <ivanm> c_wraith: more optimised than fromAscList ?
16:32:16 <mk> pqmodn: to me it looks like you're writing something nonsensical like "abc" 99.7
16:32:33 <c_wraith> ivanm: well.  differently optimized now.  It uses mutation operations internally, rather than copying.
16:32:41 <pqmodn> mk: ah, undefined is just a term like any other. call it foo if you like. define foo = foo
16:32:57 <ivanm> c_wraith: OK, I'll try
16:33:11 <pqmodn> mk: the value never terminates
16:33:18 <mk> pqmodn: oh, I see. So f(undefined). The bracketless notation often confuses me
16:33:23 <ivanm> but these lists aren't all that big (<= 20)
16:34:00 <c_wraith> ivanm: which is why *how many* lookups you do with the resulting function is important. If you only use it once, it will never be faster to convert it to an intermediate structure
16:34:22 <ivanm> c_wraith: about 3 times
16:34:29 <mk> pqmodn: hmm, I'm not sure why something doesn't terminate (and why is it that the value doesn't? Isn't it functions or procedures that never do?)
16:34:46 <pqmodn> mk: you can think of it as a function on zero arguments
16:35:08 <c_wraith> ivanm: in that case, just leaving it as a list might be fastest.  It's impossible to guess - benchmark.
16:35:16 <mk> pqmodn: isn't that just a constant?
16:35:21 <pqmodn> mk: to evaluate foo, we evaluate foo. obviously this is cyclical, it's recursion with no base case
16:35:29 <ivanm> c_wraith: yeah, doing that now
16:35:30 <pqmodn> mk: yeah it is
16:35:56 <pqmodn> mk: it's not a function in the mathematical sense
16:36:19 <pqmodn> mk: if this makes it clearer: foo x = foo(x - 1)
16:36:22 <mk> pqmodn: what if I write 88=88?
16:36:38 <dmwit> > let 88 = 88 in 3
16:36:39 <lambdabot>   3
16:36:57 <pqmodn> mk: it's just some term that whose evaluation never terminates
16:37:32 <mk> pqmodn: right, I see that - perhaps I've lost hold of where undefined is
16:37:53 <mk> pqmodn: are we writing undefined = undefined? Or was that undefined = f(undefined)?
16:37:58 <ivanm> c_wraith: turns out to be about the same
16:38:00 <pqmodn> mk: undefined = undefined
16:38:14 <pqmodn> mk: this is the same idea as foo(x) = foo(x-1). neither terminate
16:38:46 <pqmodn> mk: we can convince the type checker that foo has the type "int -> string" or "int -> [int]" or "int -> a"
16:39:00 <pqmodn> mk: and we can convince the type checker that undefined has the type "string" or "int" or "a"
16:39:09 <mk> pqmodn: it seems like we're just writing 'a'='a', which seems to be something the compiler should just ignore
16:39:36 <pqmodn> mk: that's a trivial case, but the compiler can't solve the halting problem in general.
16:39:58 <ivanm> c_wraith: dammit, I've got to determine what's more important: being able to re-use identifiers from the graph after deleting them, or speed :s
16:40:10 <pqmodn> mk: we can always construct some term which the compiler can't prove or disprove if it terminates
16:40:38 <pqmodn> mk: at least in a non-total language
16:40:41 <mk> pqmodn: it seems strange that the compiler can't simply assume that because both sides of = have exactly the same forms written, it's a tautology and can be ignored
16:41:08 <pqmodn> mk: well, it turns out that its not a useless definition
16:41:28 <pqmodn> mk: does it make sense that we can say foo :: Int -> a? and undefined :: a ?
16:41:40 <pqmodn> mk: forall a
16:42:40 <mk> it seems strange that the Int doesn't somehow constrain the type of the output
16:42:44 <mk> if I'm reading that right
16:42:48 <pqmodn> you are
16:43:21 <mk> I'd just say that such functions shouldn't exist, but apparently I think some do
16:43:33 <pqmodn> mk: they don't exist in a total language
16:44:11 <mk> does total just mean a language where they do not exist?
16:44:21 <pqmodn> total means all computations terminate
16:44:32 <pqmodn> no exceptions, no infinite loops, etc
16:44:50 <mk> is there any such language?
16:44:59 <mk> and is there any such language that is at all useful?
16:45:26 <pqmodn> sure, i think Agda, Coq, etc are total languages
16:46:20 <mk> so if I'm following, we need to handle bottom, because... it makes itself part of every type that we define?
16:47:51 <Philippa_> more or less, yeah
16:48:04 <Philippa_> but worse, because you can't pattern match for it
16:48:19 <Philippa_> so there's this property called strictness - f is strict iff f _|_ = _|_
16:48:26 <mk> and we can choose to execute functions passed to bind, by feeding them _|_?
16:48:33 <pqmodn> yes
16:48:44 <pqmodn> in the particular example we were talking about that is
16:48:56 <pqmodn> we needed to produce an "a" value
16:49:17 <mk> and why not _|_?
16:49:37 <mk> since it is an 'a' value
16:49:51 <pqmodn> not just "why not", but _|_ is the only term we have that has the right type
16:50:27 <pqmodn> only because Trivial, the constructor has no "a" fields
16:51:15 <mk> it seems to have cheated somewhat. I still don't believe that it's a real value (it seems to be a representation of something weird going on with a computation of any type), but I follow why it would fit there
16:51:51 <pqmodn> mk: the type only says *if* this term produces a value, its type is "a"
16:51:57 <mk> do we need _|_ in a non-total language?
16:52:14 <Philippa_> we need it in a non-strict language
16:52:20 <Philippa_> if everything's strict you don't need to think about it
16:52:25 <Philippa_> it's "just" non-termination
16:52:30 <mk> Philippa_: strict?
16:52:40 <Philippa_> I defined strictness above
16:52:42 <pqmodn> f _|_ = _|_
16:53:21 <mk> ah, I remember that - I'm not sure I follow though, since strictness is defined in terms of bottom, which isn't needed for strictness...
16:53:29 <pqmodn> the argument is evaluated first before applying f
16:53:34 <acowley> I prefer saying that in a non-strict language it is helpful to think about _|_
16:55:54 <pqmodn> mk: in a strict language you still can define x = x, and it has the type "forall a. a"
16:56:17 <pqmodn> mk: eg in Java you can throw an exception instead of returning a value
16:56:30 <mauke> template<typename T> T f() { return f<T>(); }
16:57:37 <pqmodn> but it's not a particularly useful construct because if you pass it to a function, it never terminates. in a non-strict language that's not the case
16:58:14 <Philippa_> mk: what's take 1 ones where ones = 1 : ones?
16:58:36 <Philippa_> ones is an infinite (thus non-terminating) list [1,1,1,1,1,...]
16:58:55 <Philippa_> in a strict language, the answer is you don't get an answer. In a non-strict language, it's 1
16:59:20 <pqmodn> in a non-strict language, bottom is a value just like ones is
16:59:29 <Philippa_> in a non-strict language you can play with really big stuff all you want, so long as you never accidentally the entire infinity
16:59:38 <mk> Philippa_: the notation with where, and : ones is confusing
16:59:51 <pqmodn> mk: ones = cons(1, ones)
17:00:04 <mk> ok. Lazyness
17:00:15 <Philippa_> non-strictness. Lazyness is an implementation strategy for it
17:00:17 <mauke> struct ones = { 1, &ones };
17:01:00 <mk> Philippa_: hmm - so lazyness is a sort of non-strictness?
17:01:17 <Philippa_> right. A language is non-strict when not all its functions are strict
17:02:31 <mk> I'm unsure what strict means - though I think I get that lazyness is an opposite?
17:02:42 <Philippa_> strict means exactly the equation
17:02:51 <Philippa_> if the function gets _|_ as a parameter, it returns _|_
17:03:04 <Philippa_> non-terminating input => non-terminating output
17:03:18 <mk> if I take 1 from [1,1,...], I get 1. I don't see why this could be an issue in any language
17:03:37 <Philippa_> because most languages expect you to fully evaluate [1,1,...]
17:03:42 <Philippa_> which takes forever - literally
17:04:21 <mk> right, it can never be evaluated. But that's not what [1,1,...] ever is - it's actually just a value
17:04:32 <Philippa_> except you never get the whole value
17:04:47 <Philippa_> and that 'never getting' is representing in a denotational semantics by the value _|_
17:05:21 <mk> it's very easy to make, you just pop it into existence. But the value has this interesting property that when you put it into the head() function, you get 1
17:05:22 <Philippa_> to put it another way: if it can never be evaluated, it *isn't* a value
17:05:42 <Philippa_> "just pop it into existance" - how does this work?
17:05:44 <mk> and when you put it into tail(), you get an entirely new value (though in this case, you actually just get ones again)
17:06:02 <Philippa_> I think you mean "by definition" - many languages /don't let you write that definition/
17:06:06 <mk> Philippa_: in the same way that writing "hello world" pops the string value into existence
17:06:17 <Philippa_> it doesn't, though
17:06:18 <mauke> ok, can we use [1 ..] as an example?
17:06:29 <mauke> > [1 ..]
17:06:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:06:32 <Philippa_> "hello world" = 'h':'e':'l':...:[]
17:06:43 <Philippa_> : and [] are "constructors", which have to be evaluated
17:07:00 <mk> Philippa_: right :) nevermind that then. What about the value 3875348783?
17:07:01 <pqmodn> where [] = [], they are "values" -- evaluating [] yields [] itself
17:07:05 <bairui> hi, guys. I'm very new to haskell (and FP in general). I'm impressed with what I've seen so far. I had a look at hackage for GUI libs. It seems Wx and Gtk are the current big players, with FRP promising to be the way of the future. Can anyone here shed some wisdom on where I should invest in getting my haskell GUI on?
17:07:29 <Philippa_> mk: ignoring type classes, that's what you get when you /evaluate/ the int literal 3875348783
17:07:43 <pqmodn> mk: evaluating 3875348783 yields 3875348783 itself.
17:08:15 <Philippa_> in other words, the int literal is another constructor
17:08:20 <mk> this is what I mean by popping into existence
17:08:56 <Philippa_> right. For non-atomic values, they don't pop into existance whole - they're evaluated piece by piece, either all at once or bit by bit
17:09:06 <Philippa_> if you do it all at once, which most languages require, you don't terminate
17:09:21 <Philippa_> (most languages instead let you use mutability and references or pointers to provide recursion)
17:09:42 <Philippa_> (to a first approximation, Haskell doesn't know what those are and nor does any other pure functional language)
17:09:55 <mk> even in languages which I would consider non-lazy - take java for example - you would create a lazy list that implements List, perhaps throws an exception on size(), and so on...
17:10:12 <Philippa_> mk: which is an object full of references and functions
17:10:26 <Philippa_> constructors in Haskell provide POD
17:10:31 <mk> POD?
17:10:35 <Philippa_> Plain Old Data
17:10:53 <pqmodn> mk: right. you can't evaluate ones = cons(1, ones) in Java because it won't terminate. you need to use another approach -- mutability or corecursion
17:10:54 <mk> I'm thinking in terms of values
17:11:03 <Philippa_> yes, so am I
17:11:29 <Philippa_> the /value/ ones doesn't contain any "code" whatsoever - no functions
17:11:31 <mk> as far as I see it, [1,2] and [1,1,1,...] are both just values (not even composite values!) - just values
17:11:34 <Philippa_> you can tell, you look at the type
17:11:50 <Philippa_> as values, [1,1,1,...] can never exist
17:12:00 <Philippa_> you have neither the memory to remember it nor the time to build it
17:12:06 <mk> it's not a composite value
17:12:08 <pqmodn> mk: a value evaluates to itself. there is no further evaluation of a value
17:12:13 <Philippa_> yes it is
17:12:25 <Philippa_> that , maps roughly to a constructor : or cons
17:12:32 <mk> it's just a special value such that if you feed it to head, you get another non-composite value: 1
17:12:45 <Philippa_> to put it another way: see all those 1s in it? Those are values, so the list built of them /must/ be composite
17:12:53 <Philippa_> you might not want to build it that way, but in this language, that's what it is
17:13:17 <Philippa_> understand: in a non-strict language, 'value' suddenly means something more precise than you thought it does
17:13:19 <mk> this assumes that you need to actually "build" the list from a small set of atoms
17:13:28 <Philippa_> which you do in Haskell
17:13:52 <mk> alright. But that's not inherent to the definition of value
17:14:00 <pqmodn> mk: what definition of a value?
17:14:05 <Philippa_> it /is/ inherent to its definition /in Haskell/
17:14:11 <Philippa_> there is no universal definition of the word
17:14:29 <mk> pqmodn: s/conception/definition (it might be hard to get into something precise here)
17:14:40 <Philippa_> the closest you'll find is "that which comes out of an evaluator"
17:14:44 <pqmodn> hehe
17:15:57 <Philippa_> mk: you're in new territory, so concepts you thought were solid are going to turn out not to have quite the scope you thought they did. That happens when you step outside your comfort zone, it's normal
17:16:49 <mk> Philippa_: sure, I understand - it's just that the way I've been thinking of values (never-composite unchanging entities which may be passed to functions) seems to make it hard for me to get what you all are (very patiently :) teaching me
17:16:54 <Philippa_> for strict languages there's a concept that's near-equivalent to "data" that works just fine, but in non-strict ones you have to separate values from the processes that generate them. (Un)fortunately, you'll then probably pun between the two anyway
17:17:06 <Philippa_> values are not atomic
17:17:14 <Philippa_> at least, not in general
17:17:25 <Philippa_> that Java value you had in mind? It probably has fields and methods
17:17:31 <Philippa_> that's composition
17:17:32 <mk> Philippa_: I think the way I'm thinking of a value is an improvement over how I thought of values before (which is as composites, as you're saying)
17:17:43 <pqmodn> mk: you're describing what many call "primitive values"
17:17:50 <mauke> pqmodn: I don't think so
17:18:08 <pqmodn> mauke: never-composite, immutable
17:18:11 <mauke> it sounds like axioms
17:18:16 <mk> Philippa_: Well, java doesn't quite have values, it has objects, and objects are almost always not values
17:18:20 <Philippa_> the fact you can put an abstraction box around it doesn't make it inherently atomic, you're just treating it as now being atomic
17:18:28 <mauke> that is, a value is defined by the operations on it
17:18:35 <Philippa_> mk: sure. But let's posit a suspiciously java-like language that doesn't have that artificial split
17:19:10 <pqmodn> mauke: aka abstract data type?
17:19:35 <mk> Philippa_: it's not an artificial split. Objects are mutable, therefore they are not values - right?
17:19:39 <Philippa_> mk: I'm not saying you don't have a useful concept, FWIW. But its applicability may not be as wide as you think
17:20:06 <Philippa_> mk: fine, take the ML route. Objects live in 'cells', you mutate the contents of the cell
17:20:29 <Philippa_> (there are purely functional OO systems whose objects would be similar to the objects here)
17:20:38 <Philippa_> (only, they live somewhere else)
17:21:11 <Philippa_> it so happens that their methods give us 'successor' objects and sugar splats them straight over their predecessors in the cell referenced by 'self'
17:21:25 <mk> Philippa_: yeah, I'm a fan of cells in place of objects, but I think values are more fundamental
17:22:02 <Philippa_> okay. So: the value of ones /as we know it/ starts out as $ones. Then we look a bit further, and it's 1:$ones or [1,$ones]
17:22:14 <Philippa_> the /value/ might be immutable, but the program's knowledge of it isn't
17:22:29 <Philippa_> as it happens, if we accidentally the entire value, we actually get _|_
17:22:34 <mk> Philippa_: right - the way I'm thinking of it is that we simply pass the original value, like [], to cons (along with e.g. 1), and this gives us the atomic value that we conveniently write as [1]
17:22:47 <Philippa_> *when it's evaluated*
17:23:44 <Philippa_> until evaluation, you're not holding any of the value itself, you just have $ones - a placeholder that tells you which process wants evaluating to find the value
17:24:05 <Philippa_> until you've evaluated, you're still doing algebra on values
17:24:15 <Philippa_> if you evaluated fully, you might not terminate
17:24:28 <mk> so what you're saying is, if we instruct the language to actually construct the value from a small set of basic forms, it will never finish, and the value of that is _|_ ?
17:24:53 <Philippa_> right. Thankfully, if we only take 1 then we don't need to construct the whole list
17:25:24 <Philippa_> what tells the language to actually construct (or rather, evaluate) is whatever's using the list
17:25:34 <mk> I think we're on the same page as far as that goes then - but I think that we can "get a hold" of the value without needing to instruct the language to construct it
17:25:35 <Philippa_> which could be the other side of the codebase from what builds it for all we know
17:25:49 <Philippa_> right, but that 'hold' is really on the process that builds it
17:26:09 <mk> hmm - repeat?
17:26:36 <Philippa_> the things we bind to variables in haskell, even if they have a 'value' type, aren't values
17:27:00 <mk> interesting - what are they?
17:27:06 <pqmodn> eg, x = undefined doesn't full evaluate undefined
17:27:10 <Philippa_> they're processes for building values. If we've evaluated it, then the process is "look at this value"
17:28:38 <Philippa_> (if you prefer, you can take a disjoint union of those two possibilities - called a "thunk" - but that's entirely equivalent)
17:28:53 <c_wraith> hmm.  That's a terrific answer for not getting into implementation, but getting the important semantics across.
17:29:10 <pqmodn> yeah, nicely done :)
17:29:25 <mk> ok, I follow this
17:29:29 <Philippa_> c_wraith: it's also how GHC actually did it last time I looked, at least for boxed values :-)
17:30:43 <johannes_> hey guys
17:30:45 <mk> I see it a bit differently, where what you bind to the variables (as you describe it) is actually the value itself. The process is just part of various functions, like first or tail
17:30:47 <Philippa_> so _|_ is equivalent to a process spinning its wheels, which means it's the one 'value' you're not allowed to pattern-match against
17:31:16 <Philippa_> hi johannes_
17:31:30 <mk> johannes_: hey, welcome
17:31:46 <johannes_> i may be a little of topic but would recommend haskell as a first language
17:32:01 <Philippa_> mk: what do you think a function is, and what is evaluation? Assuming we're still talking about Haskell or a similar language
17:33:17 <johannes_> a function or method is anything that can be called by the compiler, perform a action, or call another function
17:33:18 <mk> Philippa_: a function is a way to get from one value to another value, over a set of values
17:33:56 <Philippa_> mk: do you mean the more precise version, sets and all, or something else?
17:34:04 <johannes_> yeah guys i am only 11 so you might need to speak accordingly
17:34:18 <pqmodn> johannes_: welcome to #haskell :)
17:34:21 <Philippa_> johannes_: ah, you're asking if haskell is a good first language?
17:34:21 <mk> Philippa_: version?
17:34:26 <johannes_> yes
17:34:33 <Philippa_> It'd be unusual, but I'd think so, yes
17:34:42 <byorgey> johannes_: Philippa_ was talking to mk, not asking you what you think a function is =)
17:34:54 <johannes_> okay
17:35:00 <sizz> why does this get stuck at 62?   [ 2*x | x <- [0..], x^2 > 3, x^2 < 999 ]
17:35:04 <Philippa_> what it isn't necessarily is a good language for doing all the cool things people are doing in different languages quickly - you'll get a web page doing stuff faster in PHP, for example
17:35:21 <Philippa_> mk: the description you gave has multiple interpretations. "a way"?
17:35:28 <johannes_> i know i learned html
17:35:38 <mk> johannes_: haskell is a powerful language, and like all more-powerful languages, it is harder to learn at first
17:35:46 <byorgey> johannes_: sure, Haskell is a fine first language.
17:35:50 <Philippa_> haskell will teach you a lot more about ways to think about programming though
17:35:51 <byorgey> @where LYAH
17:35:51 <lambdabot> http://www.learnyouahaskell.com/
17:35:57 <byorgey> johannes_: try reading that ^^^
17:36:04 <byorgey> johannes_: and ask lots of questions in here =)
17:36:05 <Philippa_> so I'd recommend it, but be willing to spend time with other languages as well?
17:36:14 <pqmodn> sizz: because it's continuing to try x greater than 333... but the predicate fails
17:36:34 <byorgey> sizz: because it just keeps checking bigger and bigger values of x forever
17:37:00 <johannes_> i have a question, how many of you are professional programmers
17:37:03 <byorgey> sizz: evaluation of list comprehensions is not smart enough to know that there will never be any more values of x that satisfy the guards.
17:37:14 <mk> Philippa_: we don't have access to real values (they're up in the platonic ether), so we use representations of them. By "a way", I mean that we can convert one representation into the appropriate other
17:37:16 <sizz> i see
17:37:23 <sizz> thanks
17:37:26 <Philippa_> mk: that's still too ambiguous
17:37:36 <byorgey> sizz: use 'takeWhile' if you know that you want to stop as soon as you find a value that does not satisfy a guard
17:37:41 <pqmodn> johannes_: probably most people here are
17:38:09 <Philippa_> mk: does this conversion /do/ anything? or is it another thing in the ether that 'does' nothing but mapping?
17:38:34 <Philippa_> mk: if you know set theory, "I mean set-theoretic functions" is a good answer
17:38:41 <johannes_> okay o here that java or c++ is better to get me a job. Is this true?
17:39:01 <pqmodn> johannes_: depends on what kind of job you want, and in which industry
17:39:03 <mk> Philippa_: yes, it definitely does something - it produces ("converts" wasn't the right word) a new representation given some other, according to the inert mapping
17:39:13 <Philippa_> you'll have plenty of time to learn a language to get a job in later in life. You don't know what the market will look like when you're 16 or 18 yet
17:39:40 <johannes_> okay so should i learn c++ to
17:39:43 <byorgey> johannes_: if you are 11 years old, then I would say that by the time you will be getting a job Haskell will definitely be better.
17:39:54 <Philippa_> mk: *sigh*. Okay, 'inert'. It's a pure function, yes? Modellable by a 1:1 relation?
17:40:07 <Philippa_> don't learn C++ for now
17:40:20 <Philippa_> C++ is a really bad language that gets used for some tasks for historical reasons
17:40:25 <johannes_> okay thanks guys you are really helpful. if i can i will be on tomorrow
17:40:28 <Philippa_> learn it if you want to do something that C++ is good at, and not before
17:40:35 <johannes_> bye
17:40:38 <Philippa_> (I learned it because I was interested in game development in the 90s)
17:40:40 <byorgey> bye johannes_
17:40:47 <Philippa_> bye johannes_
17:41:10 <Philippa_> (acceptable in the 80s, what in the 90s?)
17:41:19 <sizz> I wish I was 11 and just learning programming now ;)
17:41:20 <mk> mk: inert is just meant to get at the distinction between simple mappings, and real-world functions which need to churn away at things. Yes, there's a 1-1 mapping, though for some values, some functions don't map to anything
17:41:44 <Philippa_> okay, that "for some values..." - you're using partial functions. That's no good for a denotational semantics
17:42:11 <mk> Philippa_: I mean 1 / 0 = nothing
17:42:17 <nart> mmm haskell as a first lang ?. it seems tough
17:42:21 <Philippa_> right, we'd say 1 / 0 = _|_
17:42:44 <Philippa_> or alternatively insist that you not be allowed to have (1,0) as an input in the first place - change the type
17:42:53 <sizz> could be easier as a first lang .. no baggage
17:42:57 <byorgey> nart: any language as a first language is touch.
17:42:58 <mk> Philippa_: isn't there a distinction between non-termination, and non-definition, like 1 / 0?
17:42:58 <Philippa_> (Haskell's ability to do that's limited, of course)
17:43:04 <byorgey> *tough
17:43:05 <Philippa_> mk: nope
17:43:40 <mk> Philippa_: that seems strange
17:43:47 <nkpart> I've got a module that exports another, like this: module Foo ( module Bar ) where ... import Bar
17:43:52 <Philippa_> I mean, we could add one and have _|_(non-definition) - and GHC's runtime effectively does. But the language semantics doesn't need to
17:43:55 <nkpart> hlint is telling me to use the import/export shortcut
17:43:58 <Philippa_> they're both forms of partiality
17:44:00 <nkpart> anyone know what that is?
17:44:35 <pqmodn> mk: you can redefine your function to encode success and failure as values. eg, Maybe
17:44:37 <Philippa_> (this is why you catch exceptions for non-definition in the IO monad, btw)
17:44:47 <mk> Philippa_: seems like one is more akin to trying to put a string into addnum, while the other is just... non-termination
17:45:09 <Philippa_> well yes, but if you're trying to model how the language behaves /as a total function/, what else are you going to do?
17:45:16 <pqmodn> mk: neither produce a value
17:45:16 <Philippa_> well, make the distinction. But you don't need it
17:45:19 <mk> pqmodn: right, though that seems appropriate for something non-deterministic...
17:45:31 <nart> byorgey: yes i know, but i think solo-learning haskell as a first language is tougher than .. say python
17:45:57 <mk> pqmodn: either that, or exceptions, maybe, and 'undefined' all model the same thing
17:46:04 <Philippa_> nart: I think that depends a bit on your background, though the learning curve against stuff you can readily do is differently shaped
17:46:10 <Philippa_> Maybe doesn't model the same thing at all
17:46:20 <Philippa_> Maybe is strictly part of the object language
17:46:25 <byorgey> nart: I really don't have a good idea either way.  I would love to see an actual empirical study of this sort of thing.
17:46:39 <Philippa_> exceptions are part of IO, which is a separate language which we happen to use to interpret Haskell
17:46:52 <byorgey> at least Haskell has #haskell
17:47:01 <Philippa_> undefined is a particular term in Haskell, but I suspect you mean _|_
17:47:12 <mk> Philippa_: I'm not sure, it seems like the use of maybe is equivalent to the use of exceptions (and the use of null, for that matter), but we don't have to get into that discussion :)
17:47:41 <Philippa_> I'd rather skip the discussion of /which equivalence/ for now, yes. There's a nit, I have picked it and it holds, yes?
17:48:46 <mk> yes, I agree that we can treat 1/0 and non-termination in a very similar way
17:48:49 <nart> byorgey: that would be interesting. my thought is that stuff like monads & co that makes haskell the awesome language that it is, would work *against* at the beginning when you just want to do basic stuff
17:49:03 <nart> * *against* you
17:49:44 <DanBurton> I wonder, if Haskell had a less steep learning curve, if #haskell would be as friendly and helpful as it is
17:49:58 <DanBurton> "steep learning curve" coming from imperative languages, that is.
17:50:14 <mk> nart: it pays off in the end. you can choose a short steep learning curve, or you can choose a very long gradual one, which sometimes slopes down, by learning a less powerful language
17:50:31 <Philippa_> nart: eh, a basic IO tutorial is enough to do basic stuff. You get some minor notational inconvenience (and if you have Applicative in scope it's really minor) but that's about it
17:50:43 <byorgey> nart: you may be right.  What we need are some "learning environments" (a la DrRacket) that package up some of that stuff for you so you can write interesting programs that actually do I/O without having to learn about that yet
17:51:16 <Philippa_> byorgey: you mean a bit like having your code wrapped in a more interesting version of interact for you?
17:51:40 <mk> Philippa_: I think we were talking about strictness, and originally, about the monad laws
17:51:43 <DanBurton> I think ghci accomplishes much in that regard
17:51:57 <Philippa_> mk: right. You can't define strictness without _|_
17:51:58 <byorgey> Philippa_: yeah, precisely
17:52:20 <byorgey> gloss is a good exmaple of this approach, but I'm thinking of something a bit more general-purpose
17:52:27 <Philippa_> a function f is strict exactly when f _|_ = _|_
17:52:31 <byorgey> I mean gloss-web
17:52:52 <Philippa_> so: if you have return foo >>= bar and bar is strict, what happens?
17:53:26 <Elemir> Type error
17:53:27 <Philippa_> well, the Trivial monad is in trouble because it threw foo away
17:53:30 <mk> Philippa_: can't read the notation...
17:53:33 <Elemir> :t (>>=)
17:53:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:53:48 <Philippa_> mk: that's Haskell. Bind (Return (foo), bar)
17:54:42 <Philippa_> if you're working in a strict language then you get to assume 'equality modulo _|_' anyway and you're fine :-)
17:54:50 <mk> Philippa_: yeah I just don't have a good fix on the precedence rules etc. yet
17:55:21 <Philippa_> function application (that isn't an operator) is always highest precedence
17:56:24 <Philippa_> all our functions take one parameter, so return foo = return (foo)
17:57:13 <mk> so return foo simply creates the appropriate monadic value, which it binds through bar
17:57:17 <Philippa_> right
17:57:42 <mk> I don't see where bar's strictness comes in
17:58:09 <Philippa_> that law about return foo >>= bar = return (bar foo)
17:58:28 <mk> _|_ means "a value that I am having infinite trouble evaluating"?
17:58:39 <Philippa_> that'll do for now, yeah
17:59:05 <Philippa_> but what actually matters is: it's the other value of your Trivial type, the one you never wanted
17:59:11 <Philippa_> and you can't pattern-match against it
17:59:50 <Philippa_> (you can match for Trivial of course, but that doesn't help: you don't know if bar wanted the value or not)
18:00:30 <mk> Philippa_: are you sure the return should be there on the right side?
18:00:45 <Philippa_> ...no, I'm not and it shouldn't
18:00:47 <Philippa_> it's late here
18:01:03 <Philippa_> sorry about that
18:01:29 <mk> np, it's to your credit that I'm following along enough to notice
18:01:31 <Philippa_> anyway, the real problem is: you have to behave as if bar had the chance to play with foo's _|_
18:01:56 <Philippa_> but if foo wasn't _|_, not so much
18:04:01 <Philippa_> you've basically got four cases - bar is or isn't strict, and foo is or isn't _|_
18:04:01 <mk> so if you do pass [monadic?] _|_ through bind, you have to pretend that you gave it to the function?
18:04:12 <Philippa_> right
18:04:39 <Philippa_> so if bar is strict you have to yield _|_
18:04:44 <mk> what's a clear case of a strict and non-strict bar? (err, let's call bar "fun")
18:04:45 <Philippa_> if bar is non-strict, it's Trivial
18:05:10 <mk> Philippa_: oh, this makes sense
18:05:14 <Philippa_> fun x = x+1 -- this is strict for built-in types
18:05:21 <Philippa_> fun x = 42 -- this is non-strict
18:06:27 <mk> so non-strict means that the function essentially either discards the value entirely, or that it doesn't quite need to fully-construct the value in order to get what it needs from it?
18:06:42 <Philippa_> hi JaffaCake. I forget whether you're prone to sleep patterns like mine or not, but if the latter I'm guessing you're not in the UK right now?
18:07:20 <Philippa_> mk: more or less. A simpler way to put it is "isn't too demanding"
18:07:43 <Philippa_> (evaluation happens on-demand)
18:08:02 <Philippa_> ...ah! I am most likely talking to an unattended client of JaffaCake's :-)
18:09:15 <mk> so other cases of non-strictness, besides lazy partial evaluation and simply ignoring the value might be... handling the value by passing it to a non-strict function to get a result...
18:09:19 <mk> I can't think of others
18:10:32 <mk> stuffing it into a monad that is hooked up to an oracular evaluator
18:11:41 <mk> in any case, I think this makes sense now
18:11:57 <mk> Philippa_: thank you
18:12:00 <Philippa_> heh. Basically, case analysis and a few built-ins 'demand' stuff. Everything else is plumbing
18:12:13 <Philippa_> evaluation starts because you asked what the answer is
18:12:18 <Philippa_> and np
18:12:18 <ivanm> for some reason, when searching on hayoo for CReal, it doesn't list the numbers result
18:12:23 <ivanm> only HERA and simpleirc
18:14:02 <mk> what happens with a TwoTrivial a = T1 | T2 ? when there was one trivial value, we could simply assume that the bound-in function would return the lone monadic value (and there's the whole foray concerning bottom)
18:14:50 <Philippa_> ignoring bottom? You can't build a monad instance that satisfies the laws AFAIK
18:15:02 <mk> it seems like return would not know which of T1 and T2 each value gets bound to
18:15:08 <Philippa_> so, having got this far I figure I probably deserve an answer to this one now: have I just done your homework for you? :-)
18:15:41 <mk> Philippa_: nope :)
18:16:28 <mk> Philippa_: which is much appreciated, because I don't otherwise have a way to get decent help with learning this
18:17:29 <mk> if there are two monadic functions, one which returns T1 when given true and T2 when given false, and another one that does the reverse...
18:18:04 <mk> it seems that the monadic laws can't be satisfied?
18:18:58 <mk> that might not be clear
18:19:46 <Philippa_> if you write the two Bool -> TwoTrivial functions...
18:19:50 <mk> must return always either a) essentially "store" or contain exactly the value given it, so that it can be used to get accurate results, or b)...
18:20:05 <Philippa_> b)... not care about f
18:20:24 <Philippa_> the Maybe monad works there
18:20:35 <mk> we must be dealing with ... right, exactly, and the only way to do that seems to be in cases where our monad has just *one* monadic value
18:20:47 <Philippa_> also, a modification on a) - you can actually run more than one set of calls, as in the list monad
18:21:22 <Philippa_> but what you're actually dealing with here is: if you implemented the monad as an abstract machine, how many continuations would it keep track of?
18:22:06 <mk> Philippa_: which part of the monad deals with continuations?
18:22:17 <Philippa_> all those values effectively do
18:22:30 <Philippa_> monads 'hide' a particular structure you could implement via CPS instead
18:24:21 <Philippa_> I'm tired and should try to do other stuff tonight though, so it's probably better if someone else tries to explain this one. But look at the Maybe and [] monads for counterexamples to your idea - they were mind-expanding for me when I first learned about monads as well
18:24:43 <mk> Philippa_: sure - thank you
18:26:39 <mk> could I construct an OddEvenNeither monad, such that its return mapped everything except numbers to Neither, and numbers to either Odd or Even? (where odd, even, and neither are all monadic values?)
18:30:33 <c_wraith> mk: not with haskell's type system as it stands. You would need a restriction on the type of return to get it to vary its behavior on the type of a.
18:32:07 <mk> c_wraith: you're saying that it would not be possible for return to detect when it was dealing with a number?
18:32:14 <c_wraith> mk: correct
18:32:26 <c_wraith> :t even
18:32:27 <lambdabot> forall a. (Integral a) => a -> Bool
18:32:39 <c_wraith> and a type that's an instance of Integral, in particular
18:32:47 <mk> hmm. Suppose that it were an Integral a => OddEven a monad (if I've got that right?)
18:33:28 <c_wraith> mk: that'd be a kind error.  The type that becomes a monad needs to have the kind * -> *
18:33:29 <mk> so, forget the Neither value. Would it be possible to have that, and still satisfy the monad laws?
18:35:38 <mk> c_wraith: what's the right formulation, and is one possible? I'm not as interested in the type, I just want it to map numbers to Even and Odd
18:36:28 <mk> (in other words, I want an example of a monad where the monadic values discard important information about the original values)
18:36:30 <c_wraith> mk: it wouldn't be possible with the existing Monad formulation, due to limitations unrelated to the monad laws.
18:37:29 <mk> but in principle it's possible to create such a "return" function?
18:38:07 <c_wraith> mk: part what makes something a monad is that it isn't sensitive to the types it "contains" (for lack of a better term).  The types present in the type arguments aren't allowed to affect the behavior return and (>>=) have
18:38:22 <c_wraith> *of* return and...
18:39:04 <nus> @src join
18:39:04 <lambdabot> join x =  x >>= id
18:39:42 <mraxilus> How do I get ghci to print out one list element per line rather than the default of printing them one after another?
18:40:03 <niklasb_> mraxilus: mapM_ print lst
18:40:12 <mk> I see. So when you create a monad, you really do have only two options: a) limit it to precisely one value, as with Trivial, or b) if you're taking a monadic value, you have to store its original value, or else you won't be able to satisfy the monadic laws
18:40:42 <c_wraith> mk: there are other ways to limit value...
18:40:45 <adu> Monads are so cool
18:41:01 <mk> c_wraith: what do you mean?
18:41:03 <byorgey> mraxilus: see also the 'groom' package
18:41:12 <c_wraith> mk: data Silly a = S Int Int String
18:41:58 <c_wraith> mk: that has many possible values, and can be made into a monad in a rather similar way to the Trivial example, though a bit more complicated.
18:42:18 <magicman> c_wraith: How would that satisfy the monad laws?
18:42:41 <mk> and what do its return and bind look like?
18:42:43 <mraxilus> byorgey: cool, thanks
18:42:49 <c_wraith> magicman: choose a monoid for each of the three args.  It's essentially a combination of a writer monad and the trivial monad
18:43:39 <magicman> f True = S 1 1 "a", f False = S 2 2 "b", f' = f . not; return True >>= f, return False >>= f, return True >>= f', return False >>= f'
18:43:57 <magicman> return can't do anything with its argument, so must always return the same value, x.
18:45:00 <c_wraith> mk: return _ = Silly 0 0 "" ; (Silly x y s) >>= f = let (Silly x' y' z') = f (Silly 0 0 "") in Silly (x + x') (y + y') (z ++ z')
18:45:05 <c_wraith> that...  probably is right.
18:45:16 <c_wraith> I'd need to double-check that >>= follows the laws
18:45:28 <c_wraith> oh, nevermind
18:45:30 <magicman> Umm, f doesn't need to take a Silly a
18:45:31 <c_wraith> hah.
18:45:33 <c_wraith> yes
18:45:51 <c_wraith> (Silly x y s) >>= f = let (Silly x' y' z') = f undefined in Silly (x + x') (y + y') (z ++ z')
18:45:56 <c_wraith> Not very exciting
18:46:04 <tgeeky_> but super silly!
18:46:24 <c_wraith> that's rather exceptionally partial
18:46:31 <pqmodn> supercilious!
18:46:34 <c_wraith> but...  Oh well.
18:46:35 <magicman> But that breaks return x >>= f == f x if f is strict.
18:47:15 <c_wraith> magicman: generally bottoms are ignored when checking the laws.  About half the monads out there aren't in the presence of bottoms.  (Reader, IO, etc)
18:48:05 <magicman> Reader, too?
18:48:09 <mk> I'm not familiar enough with the notation to see what silly is doing
18:48:44 <mk> I see that there are infinite x infinite x infinite values in silly, all constructed using the Silly constructor
18:49:04 <c_wraith> mk: it's acting as the trivial monad in the type variable, and just making sure to maintain associativity and identity in the other things it contains.
18:49:30 <mk> c_wraith: "in the type variable"?
18:49:50 <c_wraith> The value of type a that it fails to carry around :)
18:50:19 <pqmodn> mk, Silly a -- the type variable "a"
18:51:04 <mk> can we make that a less silly Silly a = S Int?
18:51:18 <c_wraith> sure, but it'll be basically the same
18:51:34 <mk> ok - so return just returns Silly 0
18:51:47 <mk> what does bind do?
18:51:52 <c_wraith> return _ = S 0 ; (S x) >>= f = let (S x') = f undefined in S (x + x')
18:52:24 <pqmodn> mk: this seems a lot like x >>= f = Trivial, if you recall.
18:52:38 <mk> I'm having trouble parsing the let and the f undefined
18:52:47 <adu> has anyone heard of Alexey Radul?
18:53:29 <mk> pqmodn: well, in Trivial, you can assume that all monadic functions must return Trivial. Here, it seems you can't do that, because there are many monadic values. So that's why I'm wondering about bind
18:53:31 <c_wraith> hmm.  I can rewrite it a bit
18:53:56 <c_wraith> (S x) >>= f = case f undefined of S x' -> S (x + x')
18:54:03 <c_wraith> is that formulation easier to read?
18:54:19 <c_wraith> (that's not an exact translation, but the details of the difference aren't important here)
18:54:26 <mk> what's the rough english translation?
18:54:30 <pqmodn> mk: yeah, i mean similar in that the fields for the constructor don't have an effect on its type.
18:54:52 <c_wraith> "apply f to undefined, add the resulting Int with the Int from the other argument"
18:55:22 <mk> what happens when you apply something to undefined?
18:55:46 <c_wraith> depends on what it is.
18:55:57 <c_wraith> > let f = const 1 in f undefined
18:55:57 <lambdabot>   1
18:56:02 <nus> the callee, so to say, gets to decide
18:56:10 <mk> is undefined a value?
18:56:18 <c_wraith> yes, undefined is a value
18:56:27 <mk> is it like _|_?
18:56:34 <c_wraith> it is a bottom, yes
18:56:45 <nus> @src undefined
18:56:45 <lambdabot> undefined =  error "Prelude.undefined"
18:56:51 <c_wraith> but rather than non-termination, it terminates with an error message
18:57:08 <c_wraith> > let f = (* 2) in f undefined
18:57:09 <lambdabot>   *Exception: Prelude.undefined
18:57:36 <pqmodn> @src error
18:57:36 <lambdabot> error s = throw (ErrorCall s)
18:57:42 <pqmodn> @src throw
18:57:42 <lambdabot> throw exception = raise# exception
18:58:37 <mk> and this will return the value Silly 0 for all possible monadic functions that can be passed to bind?
18:59:08 <pqmodn> is it right that you can't distinguish one _|_ value from another (eg, non-termination from error)?
18:59:50 <c_wraith> mk: not necessarily
19:00:15 <c_wraith> (S 5) >>= const (S 7)
19:00:19 <c_wraith> What's that going to do?
19:00:36 <theorbtwo> > (S 5) >>= const (S 7)
19:00:37 <lambdabot>   Not in scope: data constructor `S'Not in scope: data constructor `S'
19:00:59 <c_wraith> theorbtwo: lambdabot is more useful when we're talking about types it knows
19:01:15 <theorbtwo> c_wraith: Quite true
19:01:18 <vodik> woudn't that be the same as return (S 7)?
19:01:27 <c_wraith> vodik: not in this case
19:04:19 <mk> oh, I think I see why it satisfies the laws
19:04:53 <c_wraith> > execWriter $ tell "5" >>= const (tell "7") -- vodik: it's closer to this, but without the mild cheating
19:04:54 <lambdabot>   "57"
19:05:14 <vodik> i see
19:06:07 <mk> so suppose we have monadic value Silly 8
19:06:49 <mk> if we bind silly 8 with return, we get silly 8 back?
19:07:10 <c_wraith> Actually, there'd be no way to get S 8 back from return
19:07:22 <mk> but we're binding
19:07:26 <c_wraith> oh.
19:07:32 <c_wraith> you mean the >>= return case
19:07:33 <c_wraith> yes
19:07:39 <c_wraith> because it will add 0 to the 8
19:09:09 <mk> and likewise, if we... bound (Silly 8) with some other function...
19:09:40 <mk> bind would return the result of function(8)?
19:09:52 <mk> I don't see how it could
19:09:57 <c_wraith> I'm not really sure what you mean by that, to be honest. :)
19:10:31 <mk> the other monadic identity law says that bind(return(8), f) = f(8)
19:11:06 <mk> and return(8) = Silly 0
19:11:26 <c_wraith> Ah.  If you leave out values of f that are strict, that's true
19:11:39 <mk> so bind(Silly0, f) = f(8)? that can't work
19:12:04 <c_wraith> it can if and only if f doesn't use its argument
19:12:21 <c_wraith> Which is why I called the case silly in the first place :)
19:12:31 <mk> but f is arbitrary - that is, "for all possible monadic functions"
19:12:58 <mk> does that mean that Silly cannot satisfy that monadic identity law?
19:13:25 <dangsos> shapr: hiyo
19:13:44 <c_wraith> mk: it only can modulo bottoms.  Unfortunately, the implementation has a *lot* of bottoms.
19:14:05 <c_wraith> mk: here's a better example
19:14:23 <c_wraith> mk: data Function a b = F (a -> b)
19:14:31 <mk> c_wraith: I'm not sure I see why bottoms are involved. Suppose I define a simple f which returns Silly 3 when given any value
19:15:24 <c_wraith> mk: then in that case, the law will hold
19:16:13 <ivanm> I might have managed to find a use for the index part of the Data.Map API! :o
19:16:26 <mk> so when: bind(return(8), mkfn), this is bind (Silly0, mkfn)... = mkfn(8) = Silly3
19:17:11 <c_wraith> mk: sadly, I've got to leave.  Someone else will have to take over
19:17:26 <mk> yes, right - but if mkfn is simply +1, then it won't hold
19:17:47 <c_wraith> > undefined + 1
19:17:48 <lambdabot>   *Exception: Prelude.undefined
19:18:01 <c_wraith> clearly not, but it's a bottom, in this case :)
19:18:02 <mk> yes, but my function returns 4
19:18:12 <mk> err, 9?
19:18:32 <mk> mkfn(8) = Silly 9
19:18:44 <mk> undefined does not equal Silly 9
19:19:11 <mk> c_wraith: alright - thanks
19:19:20 <dmwit> If you can bring me up to date on what you're talking about, I can try to help a bit.
19:19:27 <mk> I'm still not sure that Silly meets the monad laws under any conditions, though :)
19:19:59 <YellowOnion> I'm curious is there a hInteract? I can't find one and I though it would be useful unless I'm missing something (new too haskell so who chance I am)
19:20:12 <tgeeky_> @type interact
19:20:13 <lambdabot> (String -> String) -> IO ()
19:20:20 <mk> dmwit: c_wraith defined Silly a = Silly Int; its return is Silly 0, and its bind is...
19:20:33 <YellowOnion> huge change*
19:20:49 <mk> (S x) >>= f = case f undefined of S x' -> S (x + x')
19:21:08 <YellowOnion> tgeeky_: yeah I want one that allows me to choose the handle I interact with
19:21:13 <dmwit> YellowOnion: I don't know of one, but you can define hInteract in out f = hGetContents in >>= hPutStr out . f
19:21:13 <mk> I'm not sure that it meets the monadic identity laws
19:21:18 <geekosaur> @src interact
19:21:18 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:22:00 <YellowOnion> dmwit: thanks
19:22:08 <dmwit> mk: hmm... that looks a bit sketchy
19:22:10 <mk> dmwit: one of the laws is bind((return v) f) = (f v)
19:22:29 <mk> return v is of course Silly 0
19:22:35 <dangsos> shapr: i join haskell because of you and you're afk! unacceptable....sorta
19:22:38 <dmwit> not quite, it's bind (return v) f = (f v) (note different parenthesization).
19:22:53 <dmwit> anyway
19:23:16 <mk> dmwit: oh - yes I'm using math parens, because haskell's make it difficult for me to follow notation - anyway
19:23:25 <YellowOnion> geekosaur: that looks like a useful tool thanks
19:23:30 <zeiris> I'm writing a quick assembler/disassembler (for 0x10c, if anyone cares) and planning to just use binary's Get/Put for parsing/packing. Is there a better option? I'm a bit leery of the lack of built-in error handling.
19:24:02 <dmwit> bind (return v) f = bind (Silly 0) f = case f undefined of S x' -> S (0 + x') <- doesn't look like f v to me
19:24:06 <geekosaur> keep in mind @src only works for a small subset of standard Haskell98 functions
19:24:35 <mk> so now we have, bind(Silly0 f) = (f v). If I define a monadic inc function, which takes v, and returns... e.g. 9, returns Silly10
19:24:40 <dmwit> It will be f v only when f completely ignores its argument.
19:25:04 <JoeyA> zeiris: Check out cereal
19:25:06 <JoeyA> @hackage cereal
19:25:07 <lambdabot> http://hackage.haskell.org/package/cereal
19:25:16 <dmwit> mk: Please be consistent. If you want math notation, at least write bind(Silly(0), f) = f(v).
19:25:19 <mk> but f is "all possible monadic functions" for that monad
19:25:33 <dmwit> And I agree, this instance doesn't satisfy the laws.
19:25:42 <dmwit> Was c_wraith claiming it did?
19:25:45 <mk> dmwit: sorry, right
19:25:50 <zeiris> Thanks JoeyA.
19:26:05 <mk> dmwit: I think so, I was looking for an instance of a monad (and monads of course satisfy the laws)
19:27:01 <mk> in the end, what this means is that return must not discard, or lose any information whatsoever about the value given to it
19:27:36 <mk> except in one, single case: when your monad is the Trivial monad (which has only one monadic value, so you can infer that all monadic functions return it when you make your bind)
19:27:53 <dmwit> Ah, I see, c_wraith was confused about how "strict" and "ignore bottoms when checking laws" interacted.
19:28:25 <dmwit> You don't need to use bottom to see that this implementation does not obey the laws with a strict f.
19:28:57 <dmwit> (In fact, f need not even be strict to break this law. =)
19:28:57 <mk> otherwise, the monadic value produced by return v *must* have a reference back to v
19:29:09 <mk> is that right?
19:29:17 <dmwit> hm
19:29:22 <dmwit> I'm not so sure that's right, no.
19:29:42 <pqmodn> dmwit: this is what c_wraith was trying to demonstrate, but his counterexample didn't obey the laws
19:30:13 <dmwit> Okay. Let's see if we can cook up a real one, then.
19:30:26 <dmwit> s/one/counterexample/
19:30:40 <mk> dmwit: I suspect that it might be. Otherwise, I can simply generate a monadic function that will break under the above monadic law
19:30:43 <deech> Are there any examples of creating a bridge between a dynamic language and Haskell? I know of HsLua which has the bare minumum and a Python bridge that only supports calling Python from Haskell.
19:31:14 <luite> UHC has some javascript ffi for the javascript codegenerator
19:33:06 <mk> this is the case because if for any two values given to return, return yields the same monadic value... and yet my function returns different monadic values given those values...
19:33:49 <mk> then bind will be unable to know which of the monadic values my function will return, since it's being given that monadic value which return yields for both original values
19:33:51 <mk> qed?
19:34:29 <deech> luite: i thought uhc was bound to Javascript at the compiler level. If I was writing UHC with the regular backend I wouldn't be able to talk to Javascript in the same way.
19:35:04 <dmwit> mk: Yes, I buy it. That sounds right.
19:35:08 <Mathnerd314> :t \a b x y -> \x -> (\y -> if (x == y) then a else b) (return y)
19:35:09 <lambdabot> forall t t1 a (m :: * -> *). (Eq (m a), Monad m) => t -> t -> t1 -> a -> m a -> t
19:35:37 <Mathnerd314> :t \a b x y -> \x -> (\y -> if (x == y) then a else b) y
19:35:38 <lambdabot> forall t t1 a. (Eq a) => t -> t -> t1 -> a -> a -> t
19:35:45 <dmwit> mk: Though the "for any two values given to return, return yields the same monadic value" is quite a subtle observation. =)
19:35:47 <luite> deech: yeah, it might not be the greatest example, but I think that the haskell side of the code shows some way to deal with dynamic values from javascript
19:36:13 <dmwit> I think it's true by parametricity, though I'm not confident I could prove it.
19:36:33 <deech> luite: That's a good idea. I'm interested in how a static language like Haskell can handle the flexible Javascript objects.
19:37:38 <Mathnerd314> :t \a b x y -> let f y = if (x == y) then a else b in f y == return y >>= f
19:37:39 <lambdabot>     Couldn't match expected type `m a' against inferred type `Bool'
19:37:39 <lambdabot>     In the first argument of `(>>=)', namely `f y == return y'
19:37:39 <lambdabot>     In the expression: f y == return y >>= f
19:38:00 <pqmodn> mk: sorry, i missed your hypothesis. is it that "return must not lose information"?
19:38:24 <dmwit> pqmodn: Almost. Either the monad is isomorphic to Trivial or return must not lose its argument.
19:38:28 <Mathnerd314> :t \a b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f)
19:38:29 <lambdabot> forall a (m :: * -> *) b. (Eq a, Monad m, Eq (m b)) => m b -> m b -> a -> a -> Bool
19:38:44 <mk> pqmodn: yes, except in one case (the Trivial monad - because you can infer which values will be returned by all monadic functions in Trivial)
19:38:44 <pqmodn> dmwit: ah, right.
19:38:56 <Mathnerd314> @check \a b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f)
19:38:56 <lambdabot>   No instance for (GHC.Classes.Eq (m b))
19:38:57 <lambdabot>    arising from a use of `GHC.Classe...
19:39:25 <Mathnerd314> @check \(a :: Maybe Int) b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f)
19:39:25 <lambdabot>   Parse error in pattern at "b" (column 19)
19:40:20 <mk> I think it's possible to, for example, have return yield IncMonad 4 when given 3, and then have the bind decrement that before passing it to the function
19:40:22 <Mathnerd314> @check \a b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f) :: Maybe Int -> Maybe Int -> Int -> Int -> Bool
19:40:23 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int
19:40:25 <mk> but that doesn't really lose information
19:41:17 <Mathnerd314> @check (\a b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f)) :: Maybe Int -> Maybe Int -> Int -> Int -> Bool
19:41:18 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int
19:42:11 <Mathnerd314> @check \a b x y -> let f :: Int -> Maybe Int; f y = if (x == y) then a else b in f y == (return y >>= f)
19:42:12 <lambdabot>   "OK, passed 500 tests."
19:42:12 <mk> Mathnerd314: you can also /msg lambdabot ;)
19:42:43 <Mathnerd314> mk: yeah... but I got it working as soon as I realized that
19:42:58 <dmwit> mk: I think in a more exciting language you could have a monad that lost information. Luckily for us, Haskell doesn't allow return to behave differently when called at different types.
19:43:46 <Philippa_> sometimes sheer boringness is one of Haskell's best features
19:43:49 <mk> dmwit: how would that work? I don't think that my pseudo-proof above was bound to haskell
19:44:02 <Philippa_> mk: think typecase or similar
19:44:16 <mk> Philippa_: typecase?
19:44:22 <pqmodn> mk: by overloading bind so bind on "m Int" is a different function than on "m String"
19:44:59 <Mathnerd314> I don't think that changes anything
19:44:59 <Philippa_> mk: like case analysis, except you look at the value's type instead
19:45:21 <Mathnerd314> it might lose the type, but you get it back when applying f
19:45:27 <mk> pqmodn: how would that help? You'd still have the problem that if you lost information (ie, return yielded the same monadic value when given any 2 distinct values)...
19:45:32 <dmwit> mk: Your proof began with the assumption that if return's implementation ever threw away its argument, it would have to throw away its argument no matter what type it was given.
19:45:35 <pcavs> If I'm using alex, or haskell regexes in general, how do I create a character class for just tabs and spaces? I've tried [\t ' '] but that doesn't seem to work
19:45:49 <dmwit> mk: This happens to be true in Haskell (because implementations aren't allowed to depend on types), but other languages don't have any such restriction.
19:45:52 <dmwit> e.g. Agda
19:45:52 <mk> well, then I'd be able to create the function I described
19:46:21 <Philippa_> Mathnerd314: you get it subject to parametricity
19:46:35 <glguy> dmwit: How do implementations in Agda depend on types?
19:46:37 <mk> dmwit: oh, so you're saying that if there's a type with only one value, then it could work via inference? Sure, but that's not really information loss
19:46:47 <dmwit> mk: (Of course, your bind would have to play along and do something different based on what type it was called at, too.)
19:47:25 <dmwit> glguy: I can write something like f : forall A : Set, forall a : A, a -> if A = Int then Bool else String, no?
19:47:29 <Mathnerd314> Philippa_: the point IIRC was that a -> m a must be an injection
19:47:33 <pcavs> pcavs: in case anyone was interested, [\t \ ] was the key
19:47:39 <glguy> dmwit: no
19:47:44 <glguy> that seems different
19:47:49 <dmwit> ...wut
19:47:49 <glguy> and you can't do equality on types
19:48:11 <dmwit> Okay, maybe not Agda, then. I just picked it because it was big, and I assumed it had typecase.
19:48:26 <Philippa_> heh. C++! (you may start your puking...)
19:48:32 <dmwit> mk: I don't think that's what I'm saying, no.
19:48:35 <Mathnerd314> Philippa_: which is true regardless of what bind does
19:49:07 <mk> dmwit: hmm, don't follow then. Why would sensitivity to types matter?
19:49:31 <dmwit> mk: I'm saying I could carve off half the types somehow, and let my monad be Trivial on one half and Identity on the other.
19:49:34 <dmwit> (roughly)
19:49:44 <dmwit> Perhaps.
19:49:48 <dmwit> I'm not sure whether that's possible or not.
19:49:58 <dmwit> All I'm saying is that the assumption in the first sentence of your proof isn't true in all languages.
19:50:48 <mk> is identity just trivial but *->* rather than *?
19:51:03 <dmwit> No, Identity is newtype Identity a = Identity a
19:51:09 <dmwit> compare newtype Trivial a = Trivial
19:51:11 <mk> ok, right
19:51:25 <Philippa_> Mathnerd314: you're assuming parametricity still, I think
19:51:29 <mk> what would it mean for it to be trivial for half?
19:51:32 <dmwit> But the choice of Identity wasn't important, let it be [] or IO or whatever you want.
19:51:52 <mk> it seems like "trivial for half" is just the maybe monad with lost information
19:52:07 <Philippa_> you're definitely assuming a lack of things like unrestrained reflection
19:52:33 <mk> oh, nevermind, you're carving it along type boundaries, not within types. Hmm
19:53:31 <mk> might that fail on monadic functions of the form a -> M b?
19:54:06 <Mathnerd314> Philippa_: well, m a can contain different things depending on a. but I don't think that matters.
19:54:08 <dmwit> I haven't even picked a language yet, how should I know?? =P
19:54:44 <Mathnerd314> :t \a b x y -> let f y = if (x == y) then a else b in f y == (return y >>= f)
19:54:45 <lambdabot> forall a (m :: * -> *) b. (Eq a, Monad m, Eq (m b)) => m b -> m b -> a -> a -> Bool
19:55:01 <mk> yes I think it might. If you make half of your types Trivial (or information-losing), then my function will want that information, will work when it's not being bound, but will fail when being bound in the usual way
19:55:57 <mk> (because your monadic value lost information)
19:56:03 <Mathnerd314> Philippa_: ^ that function, if given two distinguishable values of m b, proves that return is injective (since it's true by the monad law)
19:56:12 <mk> so the type-carving doesn't seem to be a counterexample
19:56:57 <dmwit> mk: What if I propose a carving into sets of types S1 and S2 such that if s1 \in S1 and s2 \in S2, then s1 -> m s2 isn't inhabited (i.e. there are no functions of that type)? =)
19:57:53 <Modius> Haskell readfile and possible ambiguity over when it closes - is there some alternative library for file actions that makes closing behavior more explicit?
19:57:54 <mk> yes that works, I was actually just thinking of how that plays out :)
19:58:02 <Mathnerd314> dmwit: pretty certain it's always inhabited, since (const (return s2)) is a member
19:58:02 <Philippa_> Mathnerd314: m a can also /alter/ the a
19:58:15 <Philippa_> ...wait, no, it can't, fair enough
19:58:24 <mk> but it also works to just specify that your language has no functions whatsoever, so it's not a very interesting counterexample to what I said
19:58:46 <Philippa_> eh, I'm clearly too tired. Night :-)
19:59:02 <mk> Philippa_: good night! thanks again for the earlier chat
19:59:02 <JoeyA> @hoogle withFile
19:59:02 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
19:59:07 <JoeyA> Modius: You could use withFile, which closes the file handle when the callback completes.
19:59:26 <JoeyA> If you want to get more fancy, you could use ResourceT
19:59:28 <dmwit> mk: I like your characterization well enough that I believe in my heart of hearts that any counterexample will be unsatisfying.
19:59:29 <JoeyA> @hackage resourcet
19:59:29 <lambdabot> http://hackage.haskell.org/package/resourcet
20:00:05 <mk> dmwit: I'm not sure if that's a good thing :)
20:00:17 <mk> which characterization?
20:01:01 <dmwit> "return v always refers to v, except when it's trivial"
20:02:05 <kaitocracy> hmm does something similiar to sequence exist that is :: Monad m => [ a -> m a ] -> (a -> m a)
20:02:09 <shachaf> All monads are trivial.
20:02:15 <kaitocracy> basically something that runs through a list and does >=>
20:02:48 <mk> mm, right. I like it too, because I felt very confused until I was much more sure of it
20:03:16 <copumpkin> :t foldr1 (>=>)
20:03:17 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
20:03:19 <dmwit> :t foldr (>=>) return
20:03:20 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
20:03:25 <dmwit> Mine's better.
20:03:28 <copumpkin> yeah it is
20:03:30 <copumpkin> not sure what I was thinking
20:03:46 <kaitocracy> right just thought it would already be a library function
20:03:55 <dmwit> don't think so
20:04:03 <dmwit> Looks a lot like sequence for State, though.
20:04:17 <dmwit> StateT, I mean.
20:04:44 <JoeyA> :t runStateT
20:04:45 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
20:05:14 <JoeyA> I wonder if I can get lambdabot to spit out the type of foldr (>=>) return in terms of StateT and sequence...
20:05:15 <magicman> foldr is mapM_ for State. Ish.
20:05:43 * hackagebot process-conduit 0.4.0 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.4.0 (HideyukiTanaka)
20:08:57 <mk> if return v always refers to v, then what sort of constraints are put on bind?
20:10:09 <eyu> I did "cabal update" and now ghc requires filepath ==1.3.0.0 AND filepath ==1.2.0.1
20:10:12 <eyu> !
20:10:24 <eyu> (the same version of ghc, too)
20:11:46 <JoeyA> eyu: Do `ghc-pkg check`, and axe away packages with `ghc-pkg unregister foo-1.2.3.4` until ghc-pkg check is happy.
20:12:14 <JoeyA> Unfortunately, cabal doesn't automatically upgrade dependencies.
20:12:26 <dmwit> You should probably add --constraint "ghc installed" and --constraint "filepath installed" when you try to reinstall whatever it was that broke things, too.
20:12:45 <ClaudiusMaximus> hm, i need a zipper over an alternating list of Integer and Rational that starts and ends with an Integer - how should i model this?
20:13:29 <JoeyA> The nuclear option: go to your .ghc and remove the directory corresponding to your GHC version (e.g. x86_64-linux-7.4.1)
20:13:44 <JoeyA> You'll have to rebuild all your packages, though.
20:13:49 <JoeyA> (if you do that)
20:15:26 <kaitocracy> huh what is wrong with this type definition?
20:15:27 <kaitocracy> type Validator a = MonadWriter [Text] m => Maybe a -> m (Maybe a)
20:15:38 <mauke> it contains a constraint
20:15:42 <dmwit> kaitocracy: No contexts allowed in type aliases.
20:15:48 <kaitocracy> oh
20:15:50 <mauke> also m is not in scope
20:16:12 <kaitocracy> well it's forall m
20:16:12 <Axman6> constraints should never go on types, only on the functions that use them
20:16:40 <kaitocracy> type Validator a = Maybe a -> Writer [Text] (Maybe a)
20:16:42 <kaitocracy> so I had that before
20:16:50 <kaitocracy> I was trying to generalize it to all MonadWriters
20:17:12 <JoeyA> ClaudiusMaximus: data Alternating a b = ACons a b (Alternating a b) | AEnd a
20:17:22 <kaitocracy> what's the proper way to do that?
20:17:23 <JoeyA> That's not the zipper, but that's what you're zipping over, correct?
20:18:21 <ClaudiusMaximus> JoeyA: yep
20:18:28 <dmwit> ClaudiusMaximus: data FunnyList a b = FunnyList a [(b, a)]; data FunnyAZipper a b = FunnyAZipper [(a,b)] {- hole is here -} [(b,a)]; data FunnyBZipper a b = FunnyBZipper a [(b,a)] {- hole is here -} [(a,b)] a
20:18:36 <mk> does the maybe monad satisfy the monad laws? For bind(return(0), f), it has to return the same thing as f(0)...
20:19:06 <JoeyA> dy/dx (a*b*x + a) = a*b
20:19:23 <mk> does this mean that bind itself can't lose any information, and that only monadic functions are able to mess with anything in a monad besides the value that the monadic value is obligated to refer to?
20:19:26 <dmwit> bind(return(0), f) = bind(Just(0), f) = f(0) -- done
20:19:32 <JoeyA> This just says that each history entry in the zipper needs to contain an a and a b.
20:19:45 <dmwit> mk: (The last equality there is just by examining the definition of bind.)
20:20:15 <mk> right, yeah - but I can't create a bind that discards information when given Just 1, and then tries to bypass the bound function
20:20:29 <ClaudiusMaximus> dmwit: mm, that looks scary, but it might work
20:20:39 <dmwit> mk: Hm. No, I think bind is allowed to discard information when it's not handed something that happens to be the output of return. =)
20:20:47 <JoeyA> ClaudiusMaximus: A neat little thing I learned from http://en.wikibooks.org/wiki/Haskell/Zippers is that you can derive the zipper of a data type by computing the derivative, like you would in calculus.
20:21:34 <JoeyA> kaitocracy: newtype Validator a = Validator (Maybe a -> Writer [Text] (Maybe a))
20:21:58 <JoeyA> Though I'm not entirely sure that's how you mean to structure it.
20:22:05 <ClaudiusMaximus> JoeyA: right, i vaguelly knew that via osmosis from here...
20:22:09 <mk> dmwit: so... a monadic value, as generated by return, *must* refer back to the value (except in the special case of trivial), and bind cannot touch that part of the monad - only the extra stuff
20:22:10 <JoeyA> Perhaps newtype Validator a = Validator (a -> Writer [Text] (Maybe a)) would be a tad better.
20:22:43 <kaitocracy> huh
20:23:01 <mk> so if there are monadic values in addition to those generated by return, then those are meant for bind
20:23:25 <dmwit> I'm not sure I understood that last sentence.
20:23:34 <mk> and they can only be generated by monadic functions.... (hmm, or can some of them be generated by bind?)
20:23:42 <pqmodn> mk: i appreciate you working through this, i hadn't really thought through the implications of the laws myself :)
20:23:53 <JoeyA> kaitocracy: The Validator can stop when it hits an invalid value, correct?
20:24:13 <JoeyA> Or do you want it to keep going, even though it has Nothing to go on?
20:24:14 <ClaudiusMaximus> dmwit: is there a particular reason that you made two different types?  why not data FunnyZipper a b = FunnyAZipper ... | FunnyBZipper ...
20:24:28 <mk> pqmodn: thanks - I appreciate the channel's receptiveness :)
20:24:46 <mk> dmwit: so... in the maybe monad, there are the "return values"
20:24:47 <dmwit> ClaudiusMaximus: The holes have different types, so you'll want different operations on them.
20:24:53 <nand`> What's CReal a part of?
20:25:02 <dmwit> ClaudiusMaximus: One has a hole for a's; the other has a hole for b's.
20:25:08 <nand`> (and that's the unbounded precision type, right?
20:25:21 <pqmodn> mk: you mean the parameter given to return can't be molested by bind. however the monadic value may have multiple fields in addition to "a" which bind can play with
20:25:22 <mk> that is, the values specially dedicated to return, so that it can work in the "non-information-losing" way that it must. But then there's also Nothing
20:26:27 <mk> pqmodn: yes, exactly - though I suspect that perhaps bind can molest them if they are not the "return-monadic values"
20:26:31 <dmwit> mk: Well, you might be interested in [], for example, where there can be many values. I think you could make at least two perfectly good Monad instances for [], the one we know and love plus the one that treats [] like a glorified Maybe.
20:26:35 <JoeyA> http://hackage.haskell.org/package/numbers
20:26:38 <JoeyA> (I think)
20:26:53 <ClaudiusMaximus> dmwit: hmm, i guess that would indeed force my algorithm to be more correct - thanks!
20:27:01 <JoeyA> > showCReal 100 pi
20:27:01 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
20:27:12 <JoeyA> @src pi
20:27:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:27:38 <JoeyA> Ah, pi is a method of the Floating class.
20:27:45 <JoeyA> A Floating type can make pi whatever it wants :D
20:27:46 <mk> at the very least it seems certain that if bind messes with any of the "return-monadic" values (ie, the ones that return... returns), then it's in big trouble
20:28:53 <pqmodn> mk: can you clarify what you mean by return-monadic values. does that exclude the Int in this example: data Foo a = X Int a; return a = X 0 a
20:28:57 <dmwit> mk: yes
20:29:23 <mk> this is because if it messes with them at any time, it will mess with them when we're testing if it meets the monadic identity law, where we'll be passing it return V
20:31:01 <Zamarok> Anyone feel like critiquing some short newbie code? I would appreciate it :)
20:31:02 <Zamarok> https://gist.github.com/2307719
20:31:33 <mk> pqmodn: that one is an ... rmonadic.. rodanic?... value, since there exist some values which cause return to return it
20:31:34 * glguy remembers doing this project euler problem :)
20:32:16 <mk> pqmodn: on the other hand, if you are able to construct a value which return does *not* return (like Nothing), then it is not an r-monadic value
20:32:20 <Zamarok> glguy: I solved it a while ago :) today my little sister was doing math so I got intrigued on finding the best way to find pythagorean triplets
20:32:30 <pqmodn> mk: okay, i understand what you mean now
20:32:32 <glguy> You can generate them rather than testing for them
20:33:35 <Zamarok> glguy: really? I imagine that would be a lot faster. How so?
20:33:40 <mk> pqmodn: the reason for the distinction is that bind can't touch those values, because it doesn't want to blow up (lose information passed in... and out? of the function f) when we are testing the bind(return(v), f) = f(x) monadic identity law
20:33:55 <ClaudiusMaximus> JoeyA: thanks for the idea, but i think dmwit's is better despite that it might take O(n^2) to get from one end of a list of length n to the other...
20:33:59 <pqmodn> mk: since return is parametric we can't define it to behave depending on the value of a
20:34:45 <pqmodn> mk: so there's really only ever one "r-monadic" constructor
20:35:15 <JoeyA> I don't see why it would... all you need is a list* of items before the current position, and a list of items after the current position.
20:35:27 <pqmodn> mk: that is, i can't do return x = if x == 0 then Nothing else Just x, because that's not sufficiently polymorphic (return "hi" would be ill-typed)
20:35:30 <JoeyA> * Since the items alternate, using two separate types will be helpful.
20:35:33 <glguy> Zamarok: I don't have my project euler code on this computer, but I can share with you later
20:35:36 <JoeyA> (instead of built-in list)
20:35:38 <mk> pqmodn: I agree with the second message.. I think... yes, right? but return need not be that constructor
20:35:43 <glguy> you can google around for the topic too (that's how I figured it out)
20:36:29 <mk> pqmodn: that's right, but you also can't just decide to return Nothing
20:36:37 <pqmodn> mk: right, return isn't the same as the constructor. but there's only ever one constructor which bind must "preserve"
20:36:38 <mk> pqmodn: for all cases
20:36:40 <pqmodn> mk: yeah
20:36:41 <JoeyA> I should point out that the zipper you get by getting the derivative of the Alternating type only lets you traverse the items in chunks of two.
20:36:44 <Zamarok> glguy: Thanks, I would love to see it if you get on your other PC later.. you could send it to me in a private message if you feel like it.
20:37:12 <kaitocracy> okay it's about time I asked, in ByteString and Text there're both strict and lazy versions, is there a rule of thumb as to which should be used when?
20:37:54 <dmwit> JoeyA: Depends. I think you could probably take the derivative with respect to either a or b.
20:37:59 <mk> pqmodn: (as an aside, if return could detect types, it might mess with them in interesting ways, like incrementing just the infinite numbers by 1, and then storing them, and bind would decrement them)
20:39:25 <dmwit> JoeyA: Or perhaps I didn't understand what you meant by "chunks of two".
20:39:27 <mk> ok, so [1, "message"] might not be an r-monadic value, if return simply returns things like [1] and ["foo"]
20:39:27 <pqmodn> ah, interesting.
20:39:52 <mk> but of course it can be constructed using other constructors
20:40:36 <mk> is bind allowed to touch "message"? or must the other stuff only be altered by the monadic function?
20:40:38 <ClaudiusMaximus> JoeyA, dmwit: ahh getting there now i think:    data A a b = ACons a (B b a) ; data B b a = BNil | BCons b (A a b) ; data ZA a b = ZA (B b a) {- hole a -} (B b a) ; data ZB b a = ZB (A a b) {- hole b -} (A a b)
20:40:44 <JoeyA> dmwit: The derivative of a*b*x + a, where x represents the fixpoint (whatever that means) of the Alternating data type , is a*b
20:40:44 <mk> I suspect that it might be able to touch "message"
20:41:09 <JoeyA> The zipper is thus (Alternating a b, [(a,b)])
20:41:26 <glguy> Zamarok: You shouldn't use head/tail where pattern matching is an option
20:41:30 <JoeyA> Where [(a,b)]  is the history.
20:41:47 <JoeyA> dmwit: So if you want to step back or forward, you have to do it two units at a time.
20:41:53 <glguy> try: (b,bs) <- init (tails as) in your list comprehension
20:42:01 <dmwit> JoeyA: The derivative with respect to a is surely b*x + 1
20:42:14 <dmwit> JoeyA: And the derivative with respect to b is surely a*x
20:42:28 <glguy> err, b:bs (and then you can leave out the init
20:42:30 <dmwit> But I think you're missing out on the rule for fixpoints. I think it's not so simple as that.
20:42:33 <pqmodn> mk: my brain is fatigued, but i suspect no. consider Maybe a = Just a (ignore Nothing for now). we decided bind can't touch a without breaking the monadic laws. in the cast of list, does substituting the type constructor [] = Maybe suffice to show you can't touch the contents of the list?
20:42:37 <JoeyA> I don't know much about the derivative trick, besides what I read on that wiki page.
20:43:28 <glguy> JoeyA: the problem is that the equation was actually x = a*b*x + a
20:43:52 <glguy> (x on both sides)
20:43:52 <JoeyA> Ah, that's enlightening
20:44:06 <pqmodn> mk: maybe i'm wrong there and this is more along the lines of data Two a b = T a b and if return a = T a "whatever", then return is free to modify the second b field
20:44:15 <mk> pqmodn: I'm uncertain because of how the... is it the set or list monad? they seem to mess with the output, and flatten things...
20:44:21 <mk> (I have to step away a moment)
20:44:45 <dangsos> shapr: hiyo
20:46:06 <pqmodn> mk: i guess it's closer to Two, consider data List a = Cons a (List a) | Null, and return a = Cons a Null. i'd need to actually work out the laws again and i'm too tired to do it tonight :)
20:46:23 <ClaudiusMaximus> dmwit, JoeyA: did my datas make sense?  seemed easier than messing around rejuggling lists of pairs around each step, or being limited to stepping two steps at once...
20:46:53 <pqmodn> mk: but i suspect bind can modify fields that return didn't build using "a"
20:47:39 <dmwit> ClaudiusMaximus: Oughtn't your data B b a have a BNil a? and oughtn't ACons take a B a b?
20:47:54 <dmwit> oh
20:48:08 <dmwit> You switched B's arguments, too. Okay. Strike the second complaint.
20:48:56 <ClaudiusMaximus> dmwit: well, if there was BNil a, then i could have ACons a1 (BNil a2) which isn't alternating
20:49:18 <dmwit> Oh bother.
20:49:22 <dmwit> Yes, of course you're right.
20:49:27 <dmwit> I'm just terrible at reading.
20:49:53 * dmwit skipped the fact that there's no ANil
20:49:58 <ClaudiusMaximus> dmwit: thanks for the validation - never sure if i'm making sense at 04:50
20:50:08 <nand`> pi = 16 * atan (fromRational (1%5)) - 4 * atan (fromRational (1%239)) -- why not just 4 * atan 1
20:50:27 <dmwit> Okay, tracking through, I feel pretty confident that your zippers make sense.
20:50:50 <dmwit> wait
20:50:56 <dmwit> blegh
20:51:19 <dmwit> Does ZA make sense?
20:51:36 <ClaudiusMaximus> dmwit: i think so, because BNil
20:51:37 <dmwit> Yeah, I guess it does.
20:52:00 <dmwit> Yes, I think those types look fine.
20:52:20 <dmwit> Sorry for waffling so much. I'm not so skilled at reading other people's code. =P
20:53:07 <shapr> dangsos: howdy
20:53:17 <ClaudiusMaximus> dmwit++ JoeyA++ # helping figure out alternating list zipper
20:53:26 <ClaudiusMaximus> now i go code this up for real - laterz!
20:53:46 <shapr> dangsos: Have you seen any Haskell code yet?
20:53:54 <hpaste> “Joey Adams” pasted “Zipper over an alternating list” at http://hpaste.org/66455
20:54:21 <JoeyA> That's straightforward (in my opinion), and precise (unless I messed up somewhere).
20:54:33 <dangsos> shapr: nope i figured you could teach me over a text interface inn about 10 minutes or so
20:54:34 <nyingen> So I'm working on a small interpreter for a dynamically-typed language...is there a 'standard' approach to embedding such a type system into haskell, and doing coercions and whatnot?
20:54:40 <JoeyA> And doesn't involve transforming the history at every step.
20:54:51 <shapr> dangsos: It may take more than ten minutes.
20:54:55 <nand`> I tested 4 * atan 1 and it produces the same output as “pi” for the same 10,000 decimal places, most likely more
20:55:08 <mk> pqmodn: oh, right - lists are like recursive invocations of return ... er, is that right?
20:55:11 <nand`> I really wonder why it isn't encoded that way. Does “atan 1” depend on pi in some way? According the code, it shouldn't
20:55:17 <dangsos> shapr: lol, that and I've been working on a website for my moms business, trying to do more productive and less idle time ;0
20:55:24 <nand`> maybe performance reasons?
20:56:02 <shapr> dangsos: You can build nice websites with Haskell :-)
20:56:13 <mk> pqmodn: oh, the other law is bind(Mv, return) = Mv
20:56:24 <mk> this means that bind can't mess with anything
20:56:37 <Zamarok> glguy: Oh yea, I know I shouldn't use head/tail, but how would I pattern match that?
20:56:47 <shapr> dangsos: I built my website with Haskell, though it's entirely static.
20:57:19 <dangsos> shapr: ive never understood the need to build websites with anything but htlm javascript and php...do prog languages add functionality or just speed up the process?
20:57:30 <dangsos> shapr: link?
20:57:32 <mk> for any monadic value, bind must construct precisely the same monadic value after grabbing the reference-value and putting it into return, and then getting it out (and then putting all the other stuff back in order to get Mv again
20:57:38 <Zamarok> glguy: and I found the series of numbers [1 + 1/3, 2 + 2/5, 3 + 3/7] to generate pythagorean triplets too.. is that how you did it?
20:57:39 <dmwit> dangsos: PHP is a programming language...
20:57:51 <shapr> dangsos: my website is http://www.scannedinavian.com/
20:58:10 <dangsos> dmwit: true, but even that isnt needed for static websites like my website in mind
20:58:25 <JoeyA> kaitocracy: For strict vs lazy, you want to avoid a bunch of tiny chunks, since each chunk has a few dozen bytes of overhead (I don't know exactly how many).
20:58:31 <mk> actually I'm not sure if that's right
20:58:46 <JoeyA> But if you're reading a large file, you can use lazy ByteString or Text to achieve lazy IO.
20:58:49 <dmwit> dangsos: (And yes, I think good languages have much to offer even for static websites.)
20:59:26 <JoeyA> I usually default to strict ByteString.
20:59:57 <dangsos> dmwit: im extremely new to website design, are there libraries in languages to build websites etc?
21:00:25 <dmwit> ?faq Are there libraries in Haskell to build websites etc?
21:00:26 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:28 <shapr> dangsos: My webiset is build from really simple markup and gets turned into web pages.
21:00:36 <glguy> Zamarok: (\xs -> [(a,b,c) | a:as <- tails xs, b:bs <- tails as, c <- bs])
21:01:13 <Zamarok> glguy: Oh! I didn't know you could use (:) like that... great.
21:01:15 <zachk> dangsos: happstack, snap , yesod ...
21:01:41 <dmwit> Hakyll looks nice for static websites.
21:01:48 <JoeyA> kaitocracy: I suppose the rule of thumb for strict vs lazy ByteString/Text is (feel free to correct me, folks): use strict if you know the string is going to be small, and use lazy for long strings.  If you're constructing a large string, use Builder instead of either of those.
21:02:50 <shapr> dangsos: I'm a fan of hakyll, check it out:http://jaspervdj.be/hakyll/
21:02:54 <dangsos> shapr: "gets turned into a webpage" how does this magic happen?
21:03:12 <tgeeky_> dangsos: actual magic. Imported fresh, from China.
21:03:28 <nand`> china magic is counterfeit
21:03:29 <dangsos> shapr: be back on in a min wife just got home
21:03:34 <shapr> ok
21:03:50 <dangsos> tgeeky_: lol everyone knows magic comes from taiwan, china is just the middleman
21:04:12 <tgeeky_> dangsos: true, but recent flooding has diluted taiwan's magic production facilities.
21:11:11 <kallisti> so if I were on a Darwin system
21:11:24 <kallisti> the CPP macro darwin_HOST_OS would be defined, yes?
21:12:33 <dangsos> shapr: back
21:15:09 <dangsos> shapr: so when you say simple markup, do you mean like <html><body><h1><p> gets turned into fancy sauce with code, or is there a bit more markup and the code just does fancy effects?
21:15:30 <shapr> I mean there's way less markup, and the output is pretty html that you never have to write yourself.
21:15:44 <dmwit> I bet his markup doesn't even look like HTML.
21:15:52 <dangsos> i like not writing html
21:16:40 <JoeyA> I'd like to create an EDSL for my application for converting between JSON and DOM nodes.  I can't simply define a JSON -> Html function because I want to generate JavaScript that renders DOM nodes, rather than perform the conversion in Haskell.
21:16:44 <dangsos> im guessing python has libraries that do similar things (is that okay to language-drop in other channels, or heresy?)
21:17:17 <shergill> is there any reason why it's a convention to not add type annotations for main?
21:17:29 <shapr> dangsos: Here's an example, source code is here: http://scannedinavian.com/~shae/2012-02-28-kinect-ideas.md and the resulting webpage is http://www.scannedinavian.com/articles/kinect-ideas.html
21:17:32 <JoeyA> What's a good way to express functions in target-language-land, as opposed to literal Haskell functions?
21:17:58 <shapr> dangsos: I've been asked to prepare for sleeping, so I have about ten more minutes before I'm off for the night.
21:18:40 <dangsos> shapr: cool, im already in bed, it's when i do most of my reading so im about to go hit up some python libraries and see what im missing out on
21:19:18 <shapr> dangsos: Did you see the markdown source?
21:19:32 <shapr> This is much easier than writing a web page by hand: http://scannedinavian.com/~shae/2012-02-28-kinect-ideas.md
21:20:11 <hpaste> ClaudiusMaximus annotated “Zipper over an alternating list” with “Zipper over an alternating list (annotation)” at http://hpaste.org/66455#a66456
21:20:21 <dangsos> that has code in it? looks like plaintext to me
21:20:37 <shapr> dangsos: it is, and the output of that is: http://www.scannedinavian.com/articles/kinect-ideas.html
21:21:49 <dangsos> shapr: that's pretty terrific alternative to <><><>/<>/,?></.,?<?><?<>?>,><?<?<.,></<><//<><><><
21:21:53 <shapr> I agree
21:22:41 <adu> hi shapr
21:22:49 <shapr> howdy adu, how's code?
21:22:53 <adu> good
21:23:02 <adu> I'm writing a Scheme in Go
21:23:16 <adu> *shh* don't tell the Haskell ppl
21:23:16 <shapr> That sounds like fun.
21:23:21 <shapr> :-)
21:23:37 <adu> https://github.com/andydude/droscheme
21:23:42 <adu> if you're interested
21:23:58 <shapr> I haven't even looked at Go, so that should be interesting to read!
21:24:14 <JoeyA> adu: You're secret's safe with all 828 of us.
21:24:20 <adu> JoeyA: :)
21:24:29 <shapr> Is that all we have on the channel at the moment?
21:25:06 <dangsos> shapr: judging by the lack of human whitespace in your webpage's css file I'm guessing haskell libraries made that for you too?
21:25:10 <elliott> Who killed lambdabot :(
21:25:30 <adu> shapr: so far I have about half of the string/vector/bytevector types implemented, and like 90% of the parser
21:26:03 <shapr> dangsos: Yup
21:26:12 <JoeyA> > "She's dead, Jim"
21:26:14 <shapr> ok, time for me to sleep, goodnight folks!
21:26:29 <elliott> Cale: :(
21:26:29 <shapr> adu: I'll look at your code tomorrow, thanks for the url :-)
21:26:30 <adu> shapr: and I've given up on call/cc, so I think I'll try to implement raise/guard instead (Go has builtin panic/recover functions)
21:26:33 <dangsos> shapr: nite
21:26:34 <rasfar> shapr, you may remember me lamenting about the treatment of a visitor with a "bad idea well intended" -- i think i was being oversensitive.  i'm off too. g'nite
21:26:43 <elliott> Someone should put lambdabot in a shell script loop :p
21:28:06 <mk> why is (Monad) return called return?
21:28:23 <elliott> because
21:28:24 <tgeeky_> mk: it's also called pure
21:28:25 <kallisti> to confuse imperative programmers.
21:28:53 <mk> tgeeky_: I think unit is another name, too
21:29:08 <tgeeky_> mk: maybe. unit is also (), so maybe not.
21:29:19 <mk> tgeeky_: maybe not
21:29:35 <mk> does anyone know the general reason for it?
21:29:44 <adu> Monads are so cool
21:29:55 <elliott> "return" is a word, it doesn't mean much
21:30:05 <elliott> and it's confusing
21:30:09 <elliott> that's three reasons :)
21:30:38 <mk> liftM for example makes some sense, because it "lifts" the head and the tail of the function up into the... monadic heights, as it were.
21:31:15 <mk> ap makes obvious sense, though <*> looks inane
21:31:23 <adu> mk: my guess is that every simple example uses 'return' at the end of a do statement, which certainly apeases imperative programmers, it's when they see return in the middle of a do statement, or outside of a do statement that imperative programmers get confused
21:31:45 <mk> I think I understand why it's called pure, but I don't know the motivation between return, but probably someone smart called it that for a reason
21:31:47 <tgeeky_> mk: I like to think of return like a reply or echo command
21:32:02 <tgeeky_> s/command/function/
21:32:21 <elliott> there is no good reason
21:32:26 <adu> I like to think of return as lift0
21:32:29 <mk> elliott: who first used return?
21:32:31 <clintm> hrm... any of you using cabal-dev with 7.4.1?  I can't seem to convince it to run ghci.
21:32:35 <elliott> it is one of the N stupid things in Haskell
21:32:38 <tgeeky_> adu: that is pretty nice, actually
21:32:39 <elliott> mk: uh, maybe C. probably not C.
21:32:43 <mk> adu: lift0 can also lift functions
21:32:43 <elliott> probably before that.
21:32:56 <adu> mk: no, that's liftM
21:33:32 <mk> adu: I mean that your lift0 "lift0"s functions
21:34:00 <adu> if by functions you mean constants, then yes
21:34:06 <tgeeky_> @type return (map negate xs) -- damn lambdabot
21:34:12 <lambdabot> Not in scope: `xs'
21:34:15 <elliott> oh lambdabot is back yay
21:34:24 <tgeeky_> @type return (map negate [1,2,3]) -- damn lambdabot
21:34:30 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m [a]
21:34:42 <mk> adu:  I mean functions. You can call return +, for example. It gives you the monadic value that corresponds to the function (+)
21:34:58 <tgeeky_> @t return (+)
21:35:02 <tgeeky_> @type return (+)
21:35:04 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:35:06 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m (a -> a -> a)
21:35:14 <nand`> return could have been called “eta”
21:35:32 <mk> of course, it's totally inert, you can't use it on its own, and you need ap aka <*> to actually use it
21:35:37 <adu> @type liftM (1+)
21:35:37 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t -> m t
21:35:44 <nand`> with join being called “mu”
21:36:02 <elliott> join is a nicer name than mu
21:36:03 <mk> adu: so lifting is different from returning
21:36:07 <nand`> indeed
21:36:08 <adu> @type lift0 (+)
21:36:09 <lambdabot> Not in scope: `lift0'
21:36:12 <mk> join is called mu?
21:36:22 <elliott> mk: lift0 is reasonable because you can define it by analogy with liftM, liftM2, liftM3
21:36:26 <elliott> liftM :: (a -> b) -> (m a -> m b)
21:36:31 <elliott> liftM2 :: (a -> b -> c) -> (m a -> m b -> m c)
21:36:37 <nand`> and return is a nicer name than eta, as confusing as it may be, “eta” is not very easy to correlate with what it does
21:36:38 <elliott> liftM0 :: (a) -> (m a)
21:36:45 <tgeeky_> elliott: which is why I liked it
21:36:51 <elliott> tgeeky_: yeah, i was explaining to mk
21:36:53 <elliott> nand`: neither is return :)
21:36:55 <tgeeky_> it's a (constant, scalar lift)
21:37:02 <adu> @type liftM0 (+)
21:37:02 <lambdabot> Not in scope: `liftM0'
21:37:07 <tgeeky_> adu: it doesn't exist
21:37:10 <elliott> liftM0 = return
21:37:22 <elliott> let's call it moo as a compromise between mu and liftM00
21:37:23 <adu> elliott: yes, that was my intent
21:37:25 <mk> elliott: I'm not sure that it's reasonable, because return happily takes (a->b)
21:37:28 <tgeeky_> elliott: mooooo
21:37:33 <elliott> mk: liftM happily takes (a -> b -> c)
21:37:44 <mk> elliott: indeed, and so does return
21:37:45 <elliott> liftM2 happily takes (a -> b -> c -> d)
21:37:52 <elliott> mk: then it isn't unreasonable
21:37:55 <adu> @type liftM2 (+)
21:37:56 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
21:37:58 <elliott> the same applies to liftM, liftM2
21:38:01 <tgeeky_> return means, "monadize my constant-ized value"
21:38:04 <elliott> so liftM0 does not break the pattern at all
21:38:07 <nand`> agree with elliott, liftM0 is perfectly reasonable
21:38:19 <nand`> it even sounds logical too
21:38:19 <elliott> all you're saying is "liftM0 is polymorphic"... but so are the other liftMs
21:38:22 <tgeeky_> adu: I don't know if anyone has tried that before
21:38:28 <nand`> since return “lifts”
21:38:30 <elliott> nand`: now if only it wasn't terribly ugly :)
21:38:33 <tgeeky_> adu: I think you have inadvertantly invented something here
21:38:41 <nand`> elliott: yeah, liftM0 seems annoying to read and type
21:38:46 <nand`> :t lift
21:38:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:38:47 <tgeeky_> elliott: well, we don't need to make people use it, but at least it can be there to explain where it fits in the scheme
21:38:49 <nand`> ah
21:38:58 <adu> tgeeky_: I can't be the only one
21:39:06 <nand`> just “lift” could be reasonable for return, but then the existing lift would have to be liftTrans or something
21:39:09 <nand`> liftT?
21:39:09 <adu> everybody knows return = liftM0
21:39:12 <mk> hmm, I do suspect now that what you're saying is right, but I'm still not a fan of it as a name
21:39:23 <elliott> it's an awful name, but a consistent one
21:39:31 <tgeeky_> adu: well, I didn't until you said so, so your hypothesis is disproven.
21:39:41 <adu> hmm
21:39:43 <mk> bind is another name that makes some sense
21:39:57 <adu> liftM0 © 2012 adu
21:39:59 <mk> but why return?
21:40:17 <nand`> mk: to confuse C++ programmers, obviously
21:40:22 <dmwit> Because they thought it would only ever be used at the end of do blocks, where it kind of looks like a return statement from other languages.
21:40:29 <tgeeky_> mk: this is easy to investigate. if return shows up in the literature at the same time as do notation, then it's because return sounds imperative-y.
21:40:32 <nand`> do print "foo"; print "bar"; return 5
21:40:34 <tgeeky_> If not, then it's for some other reason.
21:40:42 <mk> nand`: I'm starting to suspect that perhaps this is really the reason
21:40:46 <elliott> yeah it's obviously because of the imperative connection...
21:40:52 <elliott> a badly thought-out decision
21:40:57 <elliott> just like fail. and the numeric typeclasses.
21:40:59 <mk> tgeeky_: good point
21:41:01 <tgeeky_> elliott: obviously, until someone reads the literature and finds out it wasn't :O
21:41:02 <elliott> and head and tail.
21:41:08 <Cale> I think it's a good name
21:41:11 <nand`> mk: the same argument can be made for many haskell names
21:41:12 <tgeeky_> dmwit: probably has read the relevant literature
21:41:12 <elliott> tgeeky_: then my comments will spontaneously cease to have ever been made
21:41:16 <mk> this makes sense as an explanation of return
21:41:18 <tgeeky_> elliott: i like it
21:41:19 <nand`> for example “class”
21:41:20 <Cale> return x is the computation which does nothing, except to return x
21:41:27 <Cale> What's wrong with that? :)
21:41:32 <adu> hi Cale
21:41:37 <mk> this is like when they named javascript
21:41:43 <elliott> tgeeky_: this has the annoying effect of making me unable to say "this sentence is false"
21:41:55 <tgeeky_> elliott: shit!
21:42:00 <adu> mk: you mean LiveScript?
21:42:03 <elliott> no, it's OK, I quoted it
21:42:21 <mk> adu: ecmascript?
21:42:32 <elliott> you mean java?
21:42:39 <adu> mk: yes, what was your analogy?
21:42:39 <mk> elliott: no actually
21:42:53 <adu> LiveScript = JavaScript = ECMAScript
21:42:53 <Cale> It wasn't named poorly, it was just named without consideration for what the term means in other languages
21:43:01 <Cale> (return)
21:43:13 <mk> adu: they thought it would help programmers see the similarity between the two languages (I believe), but this turned out unhelpful
21:43:29 <elliott> no, it was for marketing
21:43:30 <elliott> solely
21:43:32 <adu> and Java was once called Oak
21:43:33 <Cale> hah
21:43:49 <elliott> now it will turn out that the committee chose "return" to market haskell to c programmers.
21:43:49 <Cale> Oh, "Javascript" was, yeah
21:44:08 <mk> elliott: that's roughly what I mean, yes :)
21:44:27 <mk> how about the term "monad" itself?
21:44:31 <elliott> mk: category theory
21:44:38 <nand`> adu: and now CoffeeScript of course compiles down to JavaScript while referencing the Java logo
21:44:42 <elliott> mk: see http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from for the gory details
21:44:45 <mk> right - how'd it get into there?
21:44:59 <elliott> right, my link answers that
21:45:02 <mk> ah, excellent
21:45:12 <adu> nand`: I wouldn't say that's the java logo
21:45:44 <adu> billions of cafés have cups as their logo
21:46:16 <kaitocracy> is there a version of read that returns Just a if successful and Nothing if unsuccessful?
21:46:32 <elliott> kaitocracy: yes, reads
21:46:40 <elliott> kaitocracy: note that it spells Nothing as [], and Just a as [(a,"")]
21:46:42 <elliott> :t reads
21:46:42 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:46:49 <nand`> adu: a fair point; but based on the context an association can certainly be made
21:46:56 <kaitocracy> ahh got it
21:47:14 <elliott> kaitocracy: I believe readMaybe s = case reads s of [(a, s')] | all isSpace s' = Just a | otherwise = Nothing
21:47:15 <nand`> a non-trivial association that is
21:47:21 <mk> I wonder what an operad is
21:47:22 <elliott> kaitocracy: will get you the equivalent of read with a Maybe return
21:47:39 <elliott> mk: http://ncatlab.org/nlab/show/operad, hope this helps ;)
21:48:38 <nand`> remind me to ask camccann the next time I want to know why something is called the way it is
21:51:46 <JoeyA> In a class context, is it fine to use the same type variable for the arguments, to indicate that both arguments must be the same type for the context to hold?
21:51:49 <adu> I've been reading a paper by Alexey Radul, and he makes it appear that Monads and Ports (he calls them cells and propagators) are a worthy contender for Turing machines and lambda calculus
21:51:52 <JoeyA> e.g. instance Attributable a a => Attributable (a -> a) a
21:52:03 <elliott> JoeyA: yes
21:52:08 <elliott> i think you need FlexibleContexts
21:52:08 <JoeyA> It compiles, but I thought you had to have a really fancy feature for that to work.
21:52:15 <elliott> nah, that's just unification
21:52:20 <JoeyA> okay, good
21:52:32 <elliott> Just like (Num a) => (a,a) is okay :p
21:52:34 <JoeyA> I was afraid this would need at least UndecidableInstances.
21:52:44 <JoeyA> I'm trying to generalize the attribute trick used by blaze-html
21:54:04 <adu> s/for/to replace/
21:54:50 <kaitocracy> elliott: wait your function falls through if reads returns more than one result
21:55:07 <nand`> adu: so what happens when you implement monads in the lambda calculus in order to simulate a turing machine?
21:55:26 <elliott> kaitocracy: yep
21:55:30 <elliott> kaitocracy: never happens with standard parsers
21:55:35 <kaitocracy> elliott: oh I see
21:55:37 <elliott> it's for "ambiguous parses", historical reasons, you want to reject them
21:55:48 <kaitocracy> okay I see
21:55:55 <kaitocracy> man there's a lot of weird historical stuff in Haskell
21:56:00 <zeiris> Compiler library question! https://gist.github.com/2308067
21:56:18 <zeiris> I've got a nice tree of data types for the entire instruction set + labels for assemblers.
21:56:57 <zeiris> Which feels... Good, but slightly inadequate when implementing tools. What if I want a debugger that associates instructions with machine code? Or a parser that associates parsed instructions with nearby comments?
21:57:26 <zeiris> I've seen some libraries that use a type of (Expr a) for their ASTs, instead of just (Expr) as I have now. Is that their purpose, or did I misunderstand it?
21:57:53 <nand`> zeiris: store an Int with each node in the tree that points to the line of source?
21:58:18 <nand`> (disclaimer: haven't looked at your paste)
21:59:08 <zeiris> I suppose I don't have to deal with a tree, since it's assembly. So I could use (Expr,a) to do things like store line numbers, yeah.
21:59:12 <adu> nand`: I don't know, here is the paper: http://web.mit.edu/~axch/www/phd-thesis.pdf
22:03:09 <danharaj> ... what is universe polymorphism and why does agda have it.
22:03:17 <adu> lol
22:04:44 <strager> @pl \d -> do { (a,b) <- c d ; return (b a) }
22:04:44 <lambdabot> (line 1, column 10):
22:04:44 <lambdabot> unexpected "{"
22:04:44 <lambdabot> expecting variable, "(", operator or end of input
22:04:54 <strager> @pl \d -> do (a,b) <- c d ; return (b a)
22:04:54 <lambdabot> (line 1, column 23):
22:04:54 <lambdabot> unexpected ";"
22:04:54 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
22:05:02 <strager> @pl \d -> ( do { (a,b) <- c d ; return (b a) } )
22:05:02 <lambdabot> (line 1, column 12):
22:05:03 <lambdabot> unexpected "{"
22:05:03 <lambdabot> expecting variable, "(", operator or ")"
22:05:06 <strager> =[?
22:05:24 <strager> Can I run @pl locally so I don't spam this channel?
22:08:07 <glguy> you can send /msg to lambdabot
22:08:55 <mk> is there a monad for which return x is not equal to ItsSimpleConstructor x?
22:09:04 <mk> (besides, I think, the Trivial monad?)
22:09:56 <mk> I suspect that the answer is "no"
22:10:45 <mbuf> Not in scope: additionalKeysP, what could be missing?  http://fpaste.org/oLCC/
22:14:10 <glguy> mk have you looked at the continuation monad?
22:14:42 <mk> glguy: I have not
22:16:24 <mk> glguy: where might I find its definition?
22:16:30 <glguy> That is typically implemented with a single constructor and isn't "ItsSimpleConstructor x"
22:16:45 <glguy> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-Cont.html
22:18:40 <mk> where is its return defined?
22:20:00 <glguy> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Cont.html#cont
22:21:48 <mk> return a = ContT ($ a) ?
22:22:27 <mk> what does the $ mean?
22:22:36 <nand`> :t ($)
22:22:37 <lambdabot> forall a b. (a -> b) -> a -> b
22:23:36 <shachaf> mk: It's the same as the regular ($) in Haskell.
22:23:59 <shachaf> You should probably have a pretty good grasp on Haskell syntax before trying to figure out ContT. :-)
22:24:04 <nand`> :t ($ undefined)
22:24:05 <lambdabot> forall a b. (a -> b) -> b
22:24:41 <nand`> > ($ 5) square
22:24:42 <lambdabot>   Not in scope: `square'
22:24:45 <nand`> hmm
22:24:57 <nand`> > let square x = x*x in ($ 5) square
22:24:58 <lambdabot>   25
22:25:06 <mk> shachaf: perhaps, but I've found that it sometimes gets in the way - I spend much time parsing it, and it's hard enough to think about monads
22:25:10 <nand`> > let square x = x*x in square $ 5
22:25:11 <lambdabot>   25
22:25:12 <nand`> > let square x = x*x in square 5
22:25:13 <lambdabot>   25
22:25:49 <shachaf> mk: You shouldn't spend any of your time learning about Cont "thinking about monads". :-)
22:25:54 <shachaf> mk: By the way, start with Cont.
22:26:05 <shachaf> (Not that it's any different from ContT. But start with Cont.)
22:26:18 <mk> so return a = ContT ($ a) means that...
22:26:31 <shachaf> mk: Do you know what (+ 5) means?
22:26:45 <shachaf> It's just like (+ 5), but with ($) instead of (+). Because ($) is just an operator.
22:27:01 <nand`> ContT ($ a) is the same as ContT (\f -> f a)
22:27:06 <glguy> return a = ContT (\f -> f a)
22:27:21 <mk> shachaf: I'm not interested in cont in particular, I was wondering whether there was a monad such that its return did not simply point to one of its simple constructors
22:28:09 <mk> that makes a bit more sense, but I'm not sure what \f means
22:29:06 <nand`> mk: you shouldn't be considering monads before knowing how \ works :P
22:29:14 <mk> if I'm looking at $'s type right, it just takes a function and returns ... probably the same function
22:29:27 <shachaf> Yep.
22:29:49 <nand`> but for your question, a simple definition of State will have return as some construction of functions that is not a simple type constructor
22:29:54 <JoeyA> \ is "lambda", the god of functional programming.  It defines a function in-place, with one or more arguments.
22:30:05 <nand`> using type State s a = s -> (a, s)
22:30:20 <mk> nand`: I disagree with that, because there always seems to be something that I should learn before learning monads, but I never know what those things are until attempting to learn monads ;)
22:30:23 <nand`> mk: yes ($) = id
22:30:42 <nand`> mk: I recommend going through LYAH at least once
22:31:03 <JoeyA> My thought on ContT:  (a -> m r) -> m r  is relatively simple: pass a value to a continuation, which will eventually yield some type r in the distant future.  callCC, on the other hand, is a bit confusing, since the callback arbitrarily throws away a continuation.  Consider callCC as an example of what you can do in ContT.
22:31:36 <mk> nand`: I've gone through parts of it numerous times, but if $ is simply identity, then I don't see what it has anything to do with learning monads
22:32:11 <kallisti> does anyone know of a nice way to create a zip archive without using temporary directories?
22:32:13 <JoeyA> What does a wrench have to do with fixing cars?
22:32:17 <nand`> you don't need $ to learn monads :)
22:32:26 <nand`> just ContT
22:32:31 <nand`> and possibly a lot of others
22:32:34 * shachaf sighs.
22:33:16 <nus-> @src ($)
22:33:16 <lambdabot> f $ x = f x
22:33:18 <nand`> JoeyA: wasn't callCC originally written with djinn or something
22:33:20 <nus-> @src id
22:33:20 <lambdabot> id x = x
22:33:37 <mk> JoeyA: nothing, if I have pliers handy and it's going to cost me time and mental strain to go to the store ;)
22:34:15 <nand`> :t (id :: (a -> b) -> (a -> b))
22:34:16 <lambdabot> forall a b. (a -> b) -> a -> b
22:34:20 <nand`> :t ($)
22:34:21 <lambdabot> forall a b. (a -> b) -> a -> b
22:35:12 <kaitocracy> I feel like someone should make a ByteString typeclass so that we can use the functions in ByteString without worrying to much about whether or not it's strict or lazy
22:35:35 <kaitocracy> actually is there a good reason not to do this?
22:35:44 <nand`> note that “f $ x = f x” is equivalent to “($) f x = f x” which is reducable to “($) f = f”
22:36:38 <JoeyA> kaitocracy: If a function is written in terms of that type class (meaning generic to both strict and lazy bytestrings), there will be dictionary overhead unless it's inlined.
22:36:55 <mk> hmm, I see
22:37:18 <kallisti> JoeyA: I was under the impression that the dictionary overhead only applied to existentials.
22:37:29 <kaitocracy> is that significant? because writing two versions of every one of my functions is getting to be really annoying
22:37:32 <kallisti> and perhaps some other cases.
22:37:38 <kallisti> like rank-n types
22:39:00 <JoeyA> kaitocracy: What do your functions do?
22:39:08 <kallisti> but in the simplest cases there's no need to use a dictionary, you can just compile to distinct functions internally.
22:40:13 <kaitocracy> JoeyA: strip spaces from the beginning and end of a bytestring, turn a bytestring of only whitespace into Nothing, safely reimplement readInt in terms of readInteger to return Nothing on overflow
22:40:14 <kaitocracy> etc
22:40:18 <JoeyA> "<kallisti> does anyone know of a nice way to create a zip archive without using temporary directories?" A quick search on Hackage reveals the zip-archive package.  Unfortunately, it's unusable due to its GPL license, unless your program is GPL or for internal use.
22:40:18 <nus-> mk, x >>= f = join (fmap f x); ; join x = x >>= id; id x = x ; map _ [] = []; map f (x:xs) = f x : map f xs -- to mull over
22:42:50 <kallisti> JoeyA: I'm using BSD3 which should be GPL compatible.
22:43:12 <mk> nus-: what does the _ mean?
22:43:35 <nus-> mk, take a guess?
22:43:42 <JoeyA> There's also LibZip, but Hackage reports a build failure.
22:44:21 <mk> nus-: identity?
22:44:37 <JoeyA> kallisti: Indeed, but the effective license of your whole project will be GPL if you use a GPL dependency.
22:44:46 <kallisti> JoeyA: oh..
22:44:52 <kallisti> hm
22:45:04 <nus-> mk, basically it means you don't care for the value of the parameter
22:45:15 <JoeyA> Meaning if you're writing a library, and want people to be able to use it in proprietary projects, GPL dependencies are off-limits.
22:45:27 <mk> nus-: not sure I follow
22:45:41 <JoeyA> (even though *you* are writing a free library!)
22:45:47 <kallisti> JoeyA: I'm writing bindings for Selenium, which I imagine sees quite a lot of use in proprietary software.
22:45:50 <mk> so for any?
22:46:16 <kallisti> yes _ is just like a regular pattern variable
22:46:20 <kallisti> but it's not given a name.
22:46:33 <nus-> mk, in "map _ [] =" we're analyzing a case where we don't care for one of the parameters and the other is an empty list
22:46:34 <mk> oh ok, so forget mapping over the empty list, just give it back
22:47:21 <JoeyA> kallisti: Sounds interesting!  Please don't use a GPL dependency, so I'll be able to use your library ;-)
22:47:35 <kallisti> JoeyA: bah, but I need zip archives...
22:47:43 <kallisti> to work with Firefox profiles.
22:47:50 <kallisti> perhaps I'll just use zlib directly because it's BSD3
22:47:52 <JoeyA> Did you look at LibZip?
22:48:04 <kallisti> no I wasn't aware of it.
22:49:04 <kallisti> ah, this might do.
22:49:09 <JoeyA> zlib by itself doesn't deal with zip files, but it looks fairly trivial to support.
22:49:37 <JoeyA> I wonder if LibZip will be usable on Windows, though...
22:49:57 <JoeyA> If you're automating web browser testing, won't IE testing be pretty important?
22:50:01 <kallisti> yes
22:50:14 <kallisti> hm, yeah LibZip appears to use libzip as a dependency. I don't know if that exists on Windows.
22:50:51 <kallisti> I mean, it should be obtainable, but it would be a burden to the developer.
22:51:10 <JoeyA> Right.
22:51:26 <zeiris> I have module A with a data type definition, and module B where I define an instance of some well-known class for A's data.
22:51:32 <zeiris> How can I export just the instance from B?
22:51:49 <kallisti> you can't control instance exporting.
22:52:22 <kallisti> once you import an instance it exists everywhere, so to speak.
22:52:56 <JoeyA> kallisti: One option would be to contact the author of zip-archive and see if he's willing to loosen the license to BSD3, for all of our sakes.  zip-archive's dependencies are all BSD3.
22:53:28 <kallisti> perhaps.
22:55:53 <kallisti> JoeyA: https://github.com/kallisti-dev/hs-webdriver  oh here's the current code btw. All of the core features are there, but it's still a work in process (and undocumented)
23:00:24 <kallisti> JoeyA: wait why would zip-archive work on Windows?
23:01:44 <JoeyA> kallisti: Why wouldn't it?  I know for a fact the zlib package works on Windows (it includes all the zlib .c files to make things convenient for Windows users).
23:01:49 <kallisti> oh.
23:01:52 * kallisti is clueless about Windows.
23:02:11 <JoeyA> You'd be surprised how much you can get working on Windows if you try.
23:02:21 <yitz> zeiris: that's called an "orphan instance". it causes all kinds of troubles. you should avoid doing that.
23:02:21 <kallisti> couldn't I do the same with libzip?
23:03:35 <yitz> zeiris: to avoid being an "orphan instance", an instance should only be declared either in the same module as the class declaration or in the same module as the data type declaration.
23:04:13 <JoeyA> kallisti: I suppose you could, but you have to change bindings-libzip, rather than your own package.
23:04:22 <JoeyA> (that, or copy the bindings from those packages into your own)
23:04:48 <JoeyA> Seems like it would be easier to contact the author of the zip-archive package ;-)
23:05:00 <yitz> zeiris: in your case, since the class is well-known and you don't have control over the module in which it is declared, you need to declare the instance for your data type in the same module in which the data type itself is declared.
23:05:48 * hackagebot shakespeare-css 1.0.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.1 (MichaelSnoyman)
23:05:50 * hackagebot hamlet 1.0.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.1 (MichaelSnoyman)
23:11:55 <zeiris> yitz: that's clear, thanks.
23:15:48 * hackagebot yesod 1.0.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.0 (MichaelSnoyman)
23:15:50 * hackagebot yesod-auth 1.0.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.0.0 (MichaelSnoyman)
23:15:52 * hackagebot yesod-core 1.0.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.0 (MichaelSnoyman)
23:15:54 * hackagebot yesod-default 1.0.0 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.0.0 (MichaelSnoyman)
23:15:57 * hackagebot yesod-form 1.0.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.0.0 (MichaelSnoyman)
23:18:27 <JoeyA> Hmm, when's yesod 1.0.0 gonna be released?
23:18:39 <JoeyA> (jk)
23:19:01 <luite> JoeyA: probably next monday officially
23:19:10 <JoeyA> ah
23:19:28 <luite> this is uploaded as 1.0.0, but will be announaced as a release candidate
23:20:02 <luite> since cabal doesn't really support 1.0.0 prereleases or something and still work with the >= 1.0 && < 1.1 version bounds
23:20:58 * hackagebot yesod-json 1.0.0 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.0.0 (MichaelSnoyman)
23:21:00 * hackagebot yesod-newsfeed 1.0.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.0.0 (MichaelSnoyman)
23:21:02 * hackagebot yesod-persistent 1.0.0 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.0.0 (MichaelSnoyman)
23:21:04 * hackagebot yesod-routes 1.0.0 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.0.0 (MichaelSnoyman)
23:21:06 * hackagebot yesod-sitemap 1.0.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.0.0 (MichaelSnoyman)
23:25:38 <JoeyA> Hmm, is there an extension such that Default values will be used when record members aren't given?
23:25:50 <JoeyA> Or for Maybe, Nothing will be used?
23:26:08 * hackagebot yesod-static 1.0.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.0.0 (MichaelSnoyman)
23:26:10 * hackagebot yesod-test 0.2.0 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0 (MichaelSnoyman)
23:27:49 <luite> JoeyA: the release of a new yesod-platform package will mark the official 1.0
23:30:14 <JoeyA> The common idiom here is to define smart constructors, e.g. foo = Foo {x = Nothing, y = Nothing}.  However, if some of the fields are mandatory: a) you'll get unwanted warnings if the smart constructor doesn't give them default values, and b) you'll not get warnings if you don't initialize the remaining fields when using foo.
23:34:16 <kallisti> for required fields with no defaults, I usually just have my "smart constructor" take the require fields as arguments.
23:34:25 <kallisti> if there's not too many
23:34:55 <kallisti> JoeyA: also to answer your question: I don't think so.
23:35:00 <JoeyA> Thanks
23:35:45 <kallisti> I'm sure it's possible to make default Default instances with some GHC.Generics magic
23:35:49 * hackagebot msgpack 0.7.1.4 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1.4 (HideyukiTanaka)
23:40:49 * hackagebot msgpack-rpc 0.7.1.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.7.1.1 (HideyukiTanaka)
23:45:08 <YellowOnion> if I was to add a new pattern match to issueCmd in this example: http://hpaste.org/66459 is there a way to automate the modification of the data type Cmd?
23:45:31 <kallisti> no. just add it by hand.
23:45:49 * hackagebot xturtle 0.1.11 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.11 (YoshikuniJujo)
23:46:11 <kallisti> well, of course there's a way. It just doesn't exist, that I know of.
23:47:00 <YellowOnion> kallisti: I could possibly do it with vim
23:47:10 <kallisti> YellowOnion: you can however easily automate issueCmd by deriving Show for Cmd and then doing issueCmd = lowerHead . show where lowerHead [] = []; lowerHead (x:xs) toLower x : xs
23:47:28 <kallisti> excuse me.  lowerHead (x:xs) = ...
23:48:15 <kallisti> map toLower would result in shorter, less efficient code.
23:49:20 <YellowOnion> kallisti: the output of this function is high simplified for the question, I haven't even figured out the details yet
23:50:38 <YellowOnion> but it's interacting with a console app which is a game server
23:52:03 <YellowOnion> I actually have a Python/Twisted version implemented but thought it would be a good way to learn Haskell's IO
23:52:59 <kallisti> YellowOnion: an IRC bot?
23:54:02 <YellowOnion> kallisti: allows me to use in game chat to do a world backup
23:54:28 <kallisti> I'm actually working on a IRC client library using network-conduit and attoparsec. they're in very early development.
23:54:31 <kallisti> oh, not IRC then.
23:54:51 <YellowOnion> https://github.com/YellowOnion/minecraft.py/blob/master/minecraft.py
23:56:06 <YellowOnion> Twisted makes things a little weird, but it's usually pretty good for event based programming
23:56:23 <kallisti> but yes you may, while you're writing Haskell, find yourself wishing to automate some things that would normally be very quick to write in Python as you would just represent it as strings or hash tables or whatever.
23:57:09 <kallisti> in cases such as this, where I'm doing a large pattern match, I prefer to use case expressions.
23:57:20 <kallisti> instead of writing "issueCmd" over and over again.
23:58:23 <YellowOnion> I remember readin about that somewhere
23:58:28 <kallisti> YellowOnion: also a common idiom in Haskell is to use concurrency with blocking IO, rather than asynchronous IO.
23:58:35 <kallisti> (which is what Twisted uses)
23:59:36 <kallisti> YellowOnion: basically you're writing a sugared version of a case expression.
23:59:58 <kallisti> instead you could write:  issueCmd c = case c of { Say -> "say"; Kick -> "kick"; ... }
