00:07:37 * hackagebot alternative-io 0.0.1 - IO as Alternative instance (deprecated)  http://hackage.haskell.org/package/alternative-io-0.0.1 (KazuYamamoto)
00:14:22 <nyingen> @quote
00:14:22 <lambdabot> Lamport says: Programmers will find any excuse to dismiss an approach that would require them to learn something new.
00:18:03 <mm_freak> s/Programmers/Non-Haskell-Programmers/
00:18:56 <geekosaur> whwreas haskell programmers will find any excuse to write monad tuotrials
00:19:00 <geekosaur> tutorials
00:19:53 <ramier> indentation in haskell is pretty important eh
00:20:00 <ramier> took some notes from python i guess
00:23:48 <ClaudiusMaximus> ramier: i'm guessing haskell took indentation/layout from miranda, and miranda was pre-python
00:24:27 <ramier> i was making a joke trying to get people riled up, but for some reason people don't get riled up here
00:25:47 <ClaudiusMaximus> ramier: i didn't know python was so old though, around the same age as haskell it seems :)
00:26:57 <ramier> haha wikipedia has it "Appeared in 191 B.C."
00:28:39 <ClaudiusMaximus> haha, still not as good as the time i read on wikipedia that 24 is the largest number.
00:33:53 <mm_freak> this channel is trollable
00:34:01 <mm_freak> you just have to know the right questions to ask
00:34:20 <mm_freak> and you have to have a certain knowledge to know them
00:39:50 <adamt> if i have a list like [n0, n1, n2, ..,] and want to do computations pairwise on n0 and n1, n1 and n2, .., and return the results as a list; what would be the pragmatic haskell way of doing that?
00:41:42 <adamt> there must be a prettier way than foo (n:ns) = .... ++ foo ns
00:42:19 <shachaf> > (zip <*> tail) [a,b,c,d,e]
00:42:19 <lambdabot>   [(a,b),(b,c),(c,d),(d,e)]
00:42:37 <adamt> perfect. :)
00:42:49 <Wooga> foldr1 (\x ys -> x + ys) [1,2,3]
00:43:10 <Wooga> err, 's' is not valid here
00:43:15 <Wooga> sumply \x y
00:43:20 <Wooga> simply*
00:43:46 <shachaf> I don't think that's what adamt wants.
00:44:14 <ramier> <*> looks advanced
00:45:03 <adamt> i think shachaf's suggestion is exacly what i want.
00:45:20 <shachaf> ramier: In this case it means the same as (\xs -> zip xs (tail xs))
00:45:20 <adamt> but thanks both of you :)
00:45:39 <ramier> oh i see
00:48:20 <pdxleif> If trees are monads, by transitive entailment, does that mean trees are burritos?
00:50:11 <ChristianS> monads aren't burritos, so no
00:52:41 * hackagebot hamlet 1.0.1.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.1.1 (MichaelSnoyman)
00:52:43 * hackagebot persistent 0.9.0.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.9.0.3 (MichaelSnoyman)
00:52:45 * hackagebot wai-app-static 1.2.0.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.2.0.2 (MichaelSnoyman)
00:56:30 <ramier> is there a function to randomize a list, or do i have to write it
00:57:42 * hackagebot xml2html 0.1.2.1 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.2.1 (MichaelSnoyman)
00:57:55 <ramier> yea its in Data.Random.Extras
01:17:42 * hackagebot yesod-core 1.0.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.1.1 (MichaelSnoyman)
01:23:26 <womb> > 7*7
01:23:26 <lambdabot>   49
01:23:28 <womb> im back
01:24:04 <danr> womb: wb ;)
01:34:24 <raboof> i wrote my first haskell app this weekend - it reads a txt file organized as a hierarchy (with indentation)  and allows the user to view and filter the tree
01:34:45 <raboof> https://github.com/raboof/treeview - i probably made a lot of beginners' mistakes, would be interested in any feedback
01:38:10 <TSC> raboof: You might like to see some of the functions in Data.Char
01:38:16 <TSC> (to replace your isBlank)
01:38:48 <TSC> You could also define:
01:38:51 <TSC> removeBlank = filter (not . isBlank)
01:39:23 <TSC> But it seems pretty good to me
01:40:25 <timtheli1n> raboof: I'm pretty sure the onSomeEvent functions are all depricated and you should instead use someEvent `on` ...
01:41:51 <mm_freak> in a dependently typed language can one get along with /only/ type indices?
01:43:24 <mm_freak> agda pseudocode:  data Vec : Sat -> Nat -> Set where nil : (X : Set) -> Vec Set 0; cons : (X : Set) -> (n : Nat) -> X -> Vec X n -> Vec X (n + 1)
01:43:31 <mm_freak> s/Sat/Set/
01:43:50 <mm_freak> feels perfectly reasonable to do that, but i'm not sure
01:45:53 <danr> mm_freak: what are you exactly asking? are you enquiring about indicies and parameters of inductive families?
01:46:22 <danr> mm_freak: in your example above, Vec would actually have the type Set -> Nat -> Set1 since its constructors quantifies over Set
01:48:29 <mm_freak> danr: i'm still working on my toy compiler for a dependently typed language, and now i want to add inductive families
01:48:48 <mm_freak> right now i would have to have a list of type arguments as well as a type
01:49:36 <mm_freak> the usual Vec type would have a name, a list of arguments ([X : Set]) and a type (Nat -> Set)
01:49:45 <mm_freak> i wonder if i can merge the latter two
01:51:10 <danr> mm_freak: your language will be less expressible if you do not have parameters
01:51:33 <mm_freak> danr: i suspected so, but i'd like to understand why
01:51:49 <mm_freak> all i'm doing is moving type arguments to arguments of its constructors
01:51:57 <mm_freak> and i'm not sure i get the implications
01:55:48 <mm_freak> danr: you were right
01:56:24 <raichoo> hi folks
01:56:27 <danr> mm_freak: for instance, check out this russel paradox using type-in-type, which allows constructors which quantify over Set give rise to data types in Set: http://red.cs.nott.ac.uk/~txa//g53cfr/l20.html/l20.html
01:57:01 <danr> The problem is that in the definition of R, you create an element of M with an argument that also is M, i.e. the problem is that you let the Set in the data type definition quantify over itself
01:59:07 <danr> whereas, if you move (I : Set) to be a parameter of M, then this parameter will witness at which "level" the set was created
02:04:15 <mm_freak> danr: not sure i'm following…  the thing i don't get is that you can write this:
02:04:21 <mm_freak> test : (X : Set) → Set
02:04:21 <mm_freak> test x = x
02:05:17 <mm_freak> oh
02:05:22 <mm_freak> i think i'm seeing it now
02:05:27 <mm_freak> thanks
02:06:34 <mm_freak> i mean i could just let Set : Set in my language as i'm designing it as a core language, but i'd like to get the logic straight
02:06:36 <danr> the difference is between having data M : Set where (which should be Set1 really) and data M (I : Set) : Set where... in Altenkirch's example above
02:06:58 <danr> mm_freak: if you're fine with an inconsistent logic that's one way to go :)
02:07:23 <mm_freak> i'm not fine with that =)
02:07:30 <mm_freak> i just observed that many core language are
02:09:55 <hpaste_> Rob pasted “non-optimal list functions?” at http://hpaste.org/67478
02:10:01 <rs46> Can someone tell me a more optimal way to expressing xs in the following... http://hpaste.org/67478
02:10:23 <rs46> Is there a nicer (and shorter) way of expressing xs ?
02:10:45 <opqdonut> :t lookup
02:10:46 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:11:00 <opqdonut> will simplify it a bit
02:11:29 <rs46> opqdonut: cool. Are you able to annotate tat hpaste ?
02:11:34 <rs46> s/tat/that/
02:11:54 <opqdonut> another solution is simply using unzip
02:12:03 <rs46> oh...
02:12:17 <opqdonut> > unzip (zip ["a","b","c","d"] (cycle [1,2,3]))
02:12:18 <lambdabot>   (["a","b","c","d"],[1,2,3,1])
02:12:26 <opqdonut> or have I misunderstood you?
02:12:40 <rs46> the evaluation of xs is
02:12:44 <rs46> [([1,4],"n1"),([2,5],"n2"),([3,6],"n3")]
02:12:58 <opqdonut> oh, right, sorry
02:15:11 <opqdonut> let n = ["a","b","c"]; ns = zip [1,2,3,4,5,6] (cycle n) in groupBy ((==) `on` snd) (sortBy (comparing snd) ns)
02:15:14 <opqdonut> > let n = ["a","b","c"]; ns = zip [1,2,3,4,5,6] (cycle n) in groupBy ((==) `on` snd) (sortBy (comparing snd) ns)
02:15:15 <lambdabot>   [[(1,"a"),(4,"a")],[(2,"b"),(5,"b")],[(3,"c"),(6,"c")]]
02:16:51 <rs46> opqdonut: thanks :-)
02:17:28 <tdammers> there must be a simpler way to get this
02:17:42 <opqdonut> going via a Data.Map would be cleaner
02:17:46 <rs46> tdammers: hhm yep. Any ideas ?
02:17:49 <rs46> true.
02:18:02 <tdammers> maybe abandon the whole zip-and-cycle idea, and go directly to the lists
02:18:02 <opqdonut> :t unionsWith
02:18:03 <lambdabot> Not in scope: `unionsWith'
02:18:09 <opqdonut> :t M.unionsWith
02:18:10 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [M.Map k a] -> M.Map k a
02:19:16 <t7> try catch blocks are monadic computations?
02:19:57 <t7> (in java, C++, c# ..._
02:22:00 <opqdonut> no
02:22:10 <opqdonut> but one can use a monad to express the same things
02:29:27 <t7> how do i use Either in a StateT
02:29:31 <t7> this is confusing
02:29:50 <niklasb> t7: StateT (ErrorT String)?
02:29:56 <quicksilver> same way as you use Either outside a StateT? :) Can you ask a clearer question?
02:30:15 <t7> runStateT (Right 123) 0
02:30:47 <danr> return (Right 123)
02:30:56 <quicksilver> :t runStateT
02:30:57 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
02:31:06 <quicksilver> the first arg to runStateT is a "StateT" value
02:31:13 <quicksilver> "Right 123" is not a StateT value.
02:31:14 <danr> Right.
02:31:25 <quicksilver> what are you trying to do t7?
02:31:50 <t7> return an Either while carrying state... ?
02:32:09 <quicksilver> then danr guessed right
02:32:13 <quicksilver> return (Right 123)
02:32:32 <quicksilver> not really specific to Either, though, you'd have to "Return" any value...
02:32:43 <tdammers> rs46: you could split c into chunks of size length ns
02:33:28 <t7> quicksilver: have you read through typing haskell in haskell? if so; why is there TVars and TGens ?
02:33:31 <rs46> what is c ?
02:33:35 <tdammers> and then fold them back together
02:34:08 <tdammers> [1,2,3,4,5,6]
02:34:11 <dreixel> RankNTypes question:
02:34:16 <dreixel> f :: (forall a. Eq a => a -> (forall b. Eq b => b)) -> c
02:34:24 <dreixel> g :: (forall a b. (Eq a, Eq b) => a -> b) -> c
02:34:30 <dreixel> are the types of f and g equal?
02:34:38 <rs46> ah yes.
02:34:44 <rs46> I see..
02:34:46 <rs46> ok...
02:35:07 <tdammers> so first you'd go from [1,2,3,4,5,6] to [[1,2,3],[4,5,6]]
02:35:13 <rs46> gotcha. cheers !
02:36:02 <quicksilver> t7: no, I haven't read it. The difference is between free and quantified variables, it's a little subtle if you haven't already spent some time thinking about how H-M inference works.
02:36:09 <merijn> dreixel: I think not, because a specific version of f can take multiple second arguments (of different types), whereas the second cannot. But I'm not an expert, so someone else would have to confirm or call me an idiot
02:36:29 <t7> quicksilver: i managed to implement it using only one type for tvars
02:36:35 <t7> but i did have type schemes
02:36:46 <t7> is it something specific to type classes]
02:36:55 <quicksilver> t7: when you are unifying two (partially inferred, perhaps) types, then you have to distinguish between variables which are unconstrained and can be freely unifed, and types which are already fixed.
02:37:17 <merijn> dreixel: For example I think that "let foo = f () in (foo "a", foo 1)" is correct, but "let foo = g () in (foo "a", foo 1)" is a type error
02:37:32 <quicksilver> t7: well there is certainly more than one way of encoding it.
02:37:32 <t7> Ah i stored which variables were bound in the scheme
02:37:40 * quicksilver nods
02:45:52 <merijn> No one has yelled at me for being wrong about RankNTypes yet, does that mean I'm right?
02:46:32 <mauke> no
02:46:48 <merijn> ah, bugger
02:47:26 <mauke> http://en.wikipedia.org/wiki/Warnock%27s_dilemma
02:48:50 <tdammers> Suppose I have a quasi-quoter that interpolates valid Haskell expressions inside curly braces into a string.
02:49:17 <tdammers> So I can go let a = "foobar" in [quoter|asdf:{a}|]
02:49:26 <dreixel> merijn: I'm not entire sure, but I further minimized the example, and now I'm pretty sure this is unintended behaviour: http://hackage.haskell.org/trac/ghc/ticket/6032
02:49:30 <tdammers> and it spits out the equivalent of "asdf:foobar"
02:50:17 <tdammers> now I want to add something like lets to the syntax
02:50:55 <tdammers> so that I can define sub-templates
02:51:24 <tdammers> I'm a bit stuck on how I'd do that
02:52:02 <tdammers> I'm using Language.Haskell.Meta to parse stuff inside {}, but if I want to accept this kind of syntax:
02:52:46 <tdammers> {let a x = foo:{x}}subtemplate:{a "foobar"}
02:53:24 <tdammers> I need to be able to parse incomplete Haskell, or I need a way to replace parts of an already-parsed expression, or something like that
03:04:11 <ment> how to modify just a part of state? (instead of doing (x,a,b,c) <- get; put (x+1,a,b,c) }
03:04:41 <danr> ment: well there are no given functions to modify 4-tuples
03:05:09 <danr> but if you use 2-tuples you can use first and second from Control.Applicative as: modify (first (+1))
03:05:21 <danr> @hoogle first
03:05:22 <lambdabot> Data.Monoid First :: Maybe a -> First a
03:05:22 <lambdabot> Data.Monoid newtype First a
03:05:22 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
03:06:19 <danr> ment: you can also use one of the many lens packages, for instance fclabels which I gave an example usage of here: http://stackoverflow.com/a/9079105/165544
03:06:28 <quicksilver> ment: modifty (\(x,a,b,c,) -> (x+1,a,b,c)) helps a bit
03:06:34 <ment> the modify thingie seems like a good idea
03:06:39 <quicksilver> ment: but data-lens (which is like fclabels but better) is a better solution in general.
03:06:57 <ment> i could just instead use my own mod functions on custom datatype
03:07:07 <ment> danr, quicksilver: thanks
03:07:39 <danr> ment: ekmett has given a nice comparison of lens packages here: http://stackoverflow.com/a/5769285/165544
03:08:02 <wli> It's useful to define classes for fst, snd, thd, etc. in tuples.
03:08:17 <shachaf> Is it?
03:08:27 <shachaf> What's a function that you'd want to be polymorphic in tuple size?
03:08:40 <quicksilver> wli: I don't find it useful :)
03:08:47 <quicksilver> although it's certainly reasonable.
03:09:16 <tdammers> hmm, let me rephrase my question
03:09:34 <tdammers> I have a string "f x y = ", and an ExpQ
03:09:37 <wli> Just the accessors and updaters in the classes introducing those accessors and updaters. So then one can write mapFst (+1) or some such.
03:10:39 <tdammers> how can I get these to to be wrapped around another ExpQ so that they act like a let would?
03:11:12 <tdammers> i.e., something like String -> ExpQ -> ExpQ -> ExpQ
03:18:29 <mm_freak> ok, so what is the rule to ensure consistency?  if a type index is of type Set n, then the resulting type must be of type Set (n + 1)?
03:20:50 <mgsloan> tdammers: parseLet s d e = parseExp $ "let " ++ s ++ prettyPrint d ++ " in " ++ prettyPrint e
03:21:06 <mgsloan> at least, that's the dirty way using haskell-src-meta
03:22:05 <tdammers> :t prettyPrint
03:22:06 <lambdabot> Not in scope: `prettyPrint'
03:22:15 <mgsloan> might be a good idea to have {} and () in there too
03:22:22 <womb> >7*7
03:22:28 <tdammers> yeah
03:22:32 <womb> > putStrLn "lambdabot"
03:22:33 <lambdabot>   <IO ()>
03:22:39 <womb> > 7*7
03:22:40 <lambdabot>   49
03:22:42 <sordina1> Hey. Is it possible ot splice names into a declaration quasiquote?
03:22:46 <tdammers> so prettyPrint basically un-parses an ExpQ?
03:23:15 <mgsloan> tdammers: oops, yeah prettyPrint is for haskell-src-exts not template haskell..  I meant "pprint"
03:23:30 <hpaste_> Sordina pasted “Spliced Names” at http://hpaste.org/67479
03:23:35 <sordina1> Like http://hpaste.org/67479
03:23:46 <mgsloan> tdammers: right, but you also need to run the ExpQ
03:24:19 <sordina1> Without constructing the expression by hand?
03:24:36 <kamatsu> if i have that join . fmap return = id, and the other monad and functor laws, how can I prove that join . return = id ?
03:24:36 <kamatsu> hmm
03:24:50 <tdammers> I think I can  handle that
03:24:52 <jk__> Lets say I have data D = I Int | B Bool. Now I an eval function that returns D. I would like to be able to simply call eval expression1 + eval expression2, but that is not possible because of the types. What would be the cleanest way to go with it? Thanks for any ideas
03:25:25 <kamatsu> use a GADT
03:26:11 <kamatsu> parameterise your expression language by the type it will evaluate to
03:26:18 <quicksilver> jk__: how would you add (I 5) to (B True) ?
03:26:18 <kamatsu> then eval :: Expr a -> a
03:26:21 <mm_freak> you don't need a GADT in this particular case
03:26:29 <kamatsu> mm_freak, no, but it'd be nicer
03:26:36 <mm_freak> data D a = I a | B a
03:26:47 <ion> quicksilver: PHP developers would be happy to tell you.
03:26:49 <mm_freak> it would look nicer, but wouldn't make a difference
03:27:01 <jk__> Well it can cost me a lot of time, cause I used bnfc so as I understand I would have to add phantom types everywhere
03:27:16 <mm_freak> one useful thing about the GADT is that it constrains the values you can build
03:27:34 <mm_freak> data D :: * -> * where I :: Int -> D Int; B :: Bool -> D Bool
03:27:36 <jk__> quicksilver: Of course that doesn't make sense
03:27:46 <quicksilver> jk__: so what would you like it to do?
03:27:48 <merijn> jk__: The GADT tutorial describes exactly these sort of eval like scenarios. So even if you do something similar it might be neat to take a look: https://en.wikibooks.org/wiki/Haskell/GADT
03:27:50 * hackagebot GenI 0.22.0.1 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.22.0.1 (EricKow)
03:28:06 <quicksilver> jk__: (and what do you want (B False) + (B True) to do?)
03:28:19 <jk__> merijn: I already looked at that
03:28:33 <jk__> quicksilver: Generally throw an error
03:28:45 <flux> indeed it looks like evaluators are the bread and butter of GADTs, I suppose there are some other uses as well :)
03:29:14 <jk__> mm_freak said something about other method, how can I go around this without GADT?
03:29:51 <mm_freak> jk__: the GADT approach is almost the same, just safer
03:29:58 <mm_freak> it disallows you to construct wrong values in the first place
03:30:00 <kamatsu> the reason we suggest GADTs is because it makes the expression type error a compile time one
03:30:14 <mm_freak> while the non-GADT method catches the error elsewhere
03:30:32 <jk__> I understand
03:30:43 <mm_freak> both are compile-time errors
03:30:51 <kamatsu> er, rather
03:30:56 <mm_freak> the GADT method just finds the error earlier
03:31:11 <kamatsu> one makes it a type error to construct invalid terms
03:31:13 <mm_freak> in the sense that it tells you where you are constructing the wrong value, not where you are using it
03:31:17 <womb> :t map
03:31:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:32:01 <mm_freak> GADTs also allow knowledge acquisition through pattern matching
03:32:38 <womb> i'm noob, how do you debug things without ability to "print" stuff inisde eg function
03:32:53 <merijn> womb: For debugging you can just print stuff
03:32:56 <womb> i often get q bit crazy because of it
03:32:59 <merijn> womb: Debug.trace
03:33:04 <womb> oh
03:33:08 <womb> you just rocked my world
03:33:13 <womb> thank you master
03:33:19 <merijn> womb: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Debug-Trace.html
03:33:27 <womb> this is perfect
03:33:59 <merijn> womb: Obviously not safe for production code, but perfectly adequate for debugging
03:34:13 <mm_freak> jk__: with the GADT this is a valid set of patterns:  f :: D a -> a -> a;  f (I x) 3 = …;  f (B x) True = …
03:34:20 <mm_freak> this is impossible without a GADT
03:34:20 <womb> traceShow ftw
03:35:50 <wli> How would one define a let expression in such a GADT AST?
03:36:44 <navaati> hi
03:36:44 <lambdabot> navaati: You have 1 new message. '/msg lambdabot @messages' to read it.
03:36:48 <kamatsu> wli, i've done such in agda, but i think when you introduce variables it would get a bit scary in agda.
03:36:53 <kamatsu> *in haskell, derp
03:37:01 <jk__> Thank you for your help, I wasn't writing because I have to really think about it I am pretty new to Haskell. I'll try what you all said
03:38:02 <mm_freak> wli: is the expression language typed?
03:38:16 <mm_freak> doesn't matter actually
03:38:37 <mm_freak> my way to do this is:  Let :: n -> Expr n -> Expr n -> Expr n
03:38:42 <mm_freak> where n is the type of names
03:39:06 <mm_freak> the second argument is in scope for the third argument under the name given by the first argument
03:39:35 <wli> mm_freak: What if you need mutual recursion and pattern bindings?
03:40:24 <mm_freak> wli: well, you can make a list
03:40:42 <mm_freak> LetRec :: Map n (Expr n) -> Expr n -> Expr n
03:40:53 <wli> mm_freak: How does one avoid heterogeneous collection issues?
03:41:08 <mm_freak> wli: what do you mean?
03:41:43 <wli> mm_freak: Insistence on the phantom type matching for the bound expression and body, etc.
03:42:08 <mm_freak> wli: i still don't understand…  could you give an example?
03:42:42 <wli> mm_freak: It needs a code sample that tries to use it to see it.
03:43:49 <kamatsu> hm
03:44:13 <kamatsu> everyone seems to say that join . return = id is one of the monad laws, but strictly it isn't
03:44:41 <kamatsu> join . fmap return = id is, but i'm trying to prove the law above given this.
03:44:49 <t7> does anyone know of a simple implementation of Hindley-milner algorithm W?
03:45:09 <mm_freak> wli: currently i have no Let in my language, but if there is a problem with my approach i'll certainly run into it
03:45:14 <bitonic> t7: hey I basically did mine because you asked :P
03:45:24 <t7> yours used substitutions
03:45:35 <t7> whats the one that uses constraints?
03:45:45 <kamatsu> something like HM(X)
03:45:48 <t7> and bitonic yours was very helpful :)
03:46:04 <kamatsu> it's easy enough to convert W into a constraint version
03:46:13 <kamatsu> instead of unifying you just return an equality constraint
03:46:29 <kamatsu> and solve them all with unification later
03:46:30 <t7> yeah Let is the hard bit
03:47:06 <bitonic> t7: oh wel, I'm not familiar with that
03:48:16 <wli> mm_freak: I tried this at one point: http://hpaste.org/67043
03:50:42 <hpaste_> “Ertugrul Söylemez” pasted “GADT for a dependently typed language” at http://hpaste.org/67481
03:50:50 <mm_freak> wli: see the paste for what i currently have
03:51:12 <mm_freak> where Type = Expr
03:52:08 <mm_freak> i have a working type checker and evaluator…  before i add Let i want to implement WithType
03:57:54 * hackagebot yesod-form 1.0.0.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.0.0.3 (MichaelSnoyman)
04:01:09 <wli> mm_freak: The let part is what stymies me.
04:02:31 <mm_freak> wli: what's the [ident] list in your LetExpr?
04:02:50 <wli> mm_freak: The function arguments.
04:02:54 * hackagebot repa 3.1.3.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.3.1 (BenLippmeier)
04:02:56 * hackagebot repa-algorithms 3.1.3.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.1.3.1 (BenLippmeier)
04:02:58 * hackagebot repa-io 3.1.3.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.1.3.1 (BenLippmeier)
04:04:11 <mm_freak> ah, i see
04:04:30 <mm_freak> well, i have lambdas for that
04:06:14 <Baughn> @find void
04:06:15 <lambdabot> Not in scope: type variable `void'
04:06:18 <Baughn> @browse void
04:06:18 <lambdabot> Unknown command, try @list
04:06:25 <Baughn> @search void
04:06:25 <lambdabot> Unknown command, try @list
04:06:30 <Baughn> @hoogle void
04:06:31 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:06:31 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
04:06:31 <lambdabot> package void
04:08:01 * hackagebot repa-examples 3.1.3.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.1.3.1 (BenLippmeier)
04:18:21 <merijn> Style question for operators: "liftM2 (+) a b" or "(+) <$> a <*> b"
04:18:50 <kamatsu>  i tend to use <$> and <*> because it's what i naturally reach for regardless of function
04:18:53 <mm_freak> replace liftM2 by liftA2, then i prefer the former, but most people seem to prefer the latter
04:18:57 <kamatsu> but i would say liftM2 looks nicer
04:19:11 <merijn> :t liftA2
04:19:12 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
04:19:22 <mm_freak> same, but with Applicative instead of Monad
04:19:27 <merijn> hmm, I need to remember liftA2 for a change
04:20:10 <mm_freak> if the functor is implemented properly, liftA2 will usually be faster than liftM2
04:21:07 <DrSyzygy> :t liftM2
04:21:07 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:21:29 <DrSyzygy> mm_freak: that's odd -- why should there be a difference at all?
04:22:12 <mm_freak> DrSyzygy: because liftM2 cannot use the knowledge from Applicative…  it basically has to emulate <*> and fmap
04:22:49 <DrSyzygy> Remind me -- what extra knowledge (beyond functoriality, which liftM2 surely can assume?) is needed; or for that matter guaranteed by Applicative?
04:22:57 * hackagebot yesod-newsfeed 1.0.0.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.0.0.1 (MichaelSnoyman)
04:23:08 <quicksilver> Applicative contains no knowledge not contained in Monad.
04:24:12 <quicksilver> it is *almost conceivable* than an Applicative instance might have a specialised implementation of <*>, since <*> is a method, which is somehow faster than just using >>= as in the definition of liftM2.
04:24:17 <quicksilver> not quite conceivable though :)
04:24:26 <mm_freak> DrSyzygy: you only have (>>=) and return, on which you have to build…  you have to use (>>=) two times and return one time…  they don't directly encode the combinators you need
04:24:33 <quicksilver> in GHC small methods like that will all inline anyway.
04:25:12 <mm_freak> ok, hypothetically speaking:  if i allow Set : Set and define every type through type indices, am i missing functionality?
04:26:00 <mm_freak> again the agda pseudocode would be:  data Vec : Set -> Nat -> Set where nil : {X : Set} -> Vec X 0; …
04:26:42 <mm_freak> in other words:  are type parameters only necessary to ensure logical consistency or is there some functionality i'm missing?
04:29:21 <DrSyzygy> mm_freak: Monads have to be functors, though? So we'd have fmap as well.
04:29:46 <merijn> DrSyzygy: In a theoretical sense, yes. But the language doesn't enforce it
04:29:56 <navaati> DrSyzygy: they are but thay don't have to in the Monad class
04:30:18 <DrSyzygy> Pffft. Bloody pragmatic view of the language! Ra ra categories ra.
04:30:19 <DrSyzygy> ;-)
04:31:31 <mm_freak> DrSyzygy: not in haskell…  you have liftM, which is defined in terms of (>>=) and return
04:31:40 <t7> is there a list delete all?
04:31:45 <navaati> btw will this change one day ? after all they made the situation about Num change, so… maybe there is hope
04:32:02 <mm_freak> navaati: i wouldn't count on it
04:32:12 <navaati> mm_freak: why ?
04:32:52 <mm_freak> history indicates that haskell tends to get worse over time
04:33:09 <mm_freak> we used to have monad comprehensions, map = fmap, etc.
04:33:17 <navaati> rhoooo, no, GHC 7.4 was great !
04:33:21 <tdammers> mm_freak: so basically Miranda was perfect, and things went downhill from there?
04:33:35 <mm_freak> navaati: sure, type system features improve all the time
04:33:39 <navaati> ah, then i think that it gets better because i don't know the past ><
04:34:02 <navaati> then it's not haskell that get worse, it's base
04:34:04 <mm_freak> tdammers: ah no, i'd say that haskell is way better than miranda =)
04:34:15 <mm_freak> navaati: yeah, you could say that
04:34:24 <mm_freak> also it's controversial whether this is actually bad
04:34:40 <mm_freak> for example there is at least one valid argument in favor of a list-special 'map'
04:34:55 <DrSyzygy> mm_freak: Namely?
04:34:56 <navaati> mm_freak: ah ?
04:35:04 <navaati> ah, yeah, simpler to understand for noobs
04:35:09 <mm_freak> types are specifications, so 'map' is basically more specified and thus less error-prone
04:35:28 <navaati> hum, i don't agree with that
04:35:30 <mm_freak> if you type 'map' you get a type error if your functor is Maybe instead of []
04:35:42 <quicksilver> mm_freak: "history indicates that haskell tends to get worse over time" <-- rubbish
04:35:48 <quicksilver> I call a nasty piece of FUD.
04:36:04 <navaati> let's have types the more general possible, and if the programmer wants to enforce a specific type, it can declaure it by itself
04:36:27 <mm_freak> quicksilver: sorry =)
04:36:34 <quicksilver> all of your examples are particular cases where the haskell 98 stanards committee made some compromises (controversial ones, and many people think they got them wrong).
04:36:39 <quicksilver> that's one point in time.
04:36:47 <quicksilver> in the 14 years since 1998 things have only got better
04:37:03 <quicksilver> haskel2011 was a small step in the right direction; GHC evolution has contained lots of large steps in the right direction.
04:37:09 <quicksilver> monad comprehensions are back :)
04:37:10 <mm_freak> well, my objection isn't even against the language
04:37:24 <t7> > let deleteAll x xs | xs' == xs = xs | otherwise = delete x xs' where xs' = delete x xs in deleteAll [1,2,1,2,1,2,3,1]
04:37:25 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
04:37:25 <lambdabot>    arising from a ...
04:37:32 <t7> > let deleteAll x xs | xs' == xs = xs | otherwise = delete x xs' where xs' = delete x xs in deleteAll 1 [1,2,1,2,1,2,3,1]
04:37:33 <lambdabot>   [2,2,1,2,3,1]
04:37:39 <mm_freak> the language is fine…  the only thing i miss is dependent types, but i'm used to have to emulate them
04:38:27 <mm_freak> and it would be great, if there was a lightweight RTS, such that you can write programs for smaller systems
04:38:35 <merijn> t7: Isn't that just "filter (x==)"?
04:38:53 <t7> filter (x/=) :(
04:39:01 <merijn> mm_freak: HaLVM/house?
04:39:03 <t7> im a bit slow this morning
04:39:09 <merijn> t7: Whatever, close enough :p
04:39:36 <merijn> quicksilver: What are monad comprehensions?
04:39:37 <mm_freak> merijn: those are forks
04:39:44 <navaati> no, the problem (well, "problem"… let's say "non-perfection") is with the standard lib that doesn't use all of the language
04:39:47 <t7> @pl \x xs -> filter (x /=) xs
04:39:47 <lambdabot> filter . (/=)
04:40:05 <t7> wut
04:40:15 <navaati> and doesn't have a very good typeclass hierarchy
04:40:41 <t7> @pl \x xs -> filter (/= x) xs
04:40:41 <lambdabot> filter . (/=)
04:40:49 <merijn> navaati: You can just implement your own Prelude, though
04:41:08 <navaati> merijn: pointless if i'm the only on to use it
04:41:14 <navaati> only one*
04:41:30 <merijn> I'm sure there is a reasonable interest in a prelude where map/(.) = fmap, and similar
04:42:11 <t7> lambdabot: @pl filter (/= 1) [1..10]
04:42:11 <lambdabot> filter (1 /=) [1..10]
04:42:27 <navaati> it wouldn't work because every single lib is linked against the standard prelude's Monad, etc.
04:42:34 <mm_freak> i don't think that (.) = fmap is a good generalization
04:42:49 <mm_freak> i'd rather generalize it to the Category version
04:43:04 <navaati> "(.) = fmap" for the (-> r) instance of Functor ?
04:43:31 <mm_freak> navaati: (.) = fmap
04:44:09 <mm_freak> then function composition would be captured by the (-> r) instance, but as said i don't find that useful…  (.) from Control.Category would be much more useful
04:44:19 <navaati> (i'd rather made (.) the Category version by default instead of having it specialized for (->))
04:44:28 <mm_freak> yeah, my point
04:44:45 <mm_freak> i'd just move everything from Control.Category into the Prelude
04:45:08 <navaati> ah, ok, i didn't understand you this way. yeah sure
04:45:15 <merijn> mm_freak: I think we need a Racket like approach where the compiler supports multiple dialects for beginners and advanced users
04:45:37 <navaati> merijn: ah ! that's an interesting approach
04:45:39 <merijn> Where the simple one is similar to what we have now and the advanced one uses the extremely general forms
04:46:03 <merijn> (e.g. things like specialised map vs just fmap)
04:46:20 <navaati> how would you do that ? a compiler flag/language extension where types are displayed in their specialized form ?
04:46:37 <navaati> actually the same problem arose for reactive-banana, iirc
04:47:09 <merijn> Essentially you just have two or more standard libraries, as the language itself doesn't really require changing
04:47:18 <merijn> (In the case of haskell)
04:47:56 <navaati> the problem is compatibility : we need the Monad version of both preludes to be compatible, which is not possible atm
04:47:57 <hpc> {-# LANGUAGE HardMode #-}
04:48:04 <navaati> hpc: hell yeah
04:48:18 <merijn> navaati: beginner and advanced code is not mutually compatible, I think
04:48:31 <hpc> {-# LANGUAGE OlegMode #-}
04:48:36 <navaati> merijn: why not ?
04:49:02 <merijn> hpc: OlegMode doesn't impact the value level anyway :p
04:49:06 <hpc> :D
04:49:14 <navaati> Oleg ?
04:49:23 <hpc> @quote oleg
04:49:23 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
04:49:30 <merijn> ^^
04:49:32 <merijn> So true
04:49:58 <hpc> oleg is notorious for writing ridiculously complex programs at the type level in haskell98
04:50:01 <navaati> ah. yeah. so true
04:50:06 <hpc> also for proving make is turing-complete
04:50:15 <navaati> oh, funny
04:50:18 <hpc> and a bunch of other stuff
04:50:20 <merijn> navaati: Here: http://okmij.org/ftp/
04:50:34 <merijn> @quote prolog
04:50:35 <lambdabot> <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
04:50:43 <merijn> @quote prolog
04:50:43 <lambdabot> Glor says: * Glor has joined #haskell  <Glor> hello i know this is not a prolog channel but noone is in prolog and im wondering if i could ask a question about prolog in here
04:50:47 <merijn> blah
04:50:58 <merijn> Not the oleg quote I was looking for
04:51:35 <navaati> Glor's try was not stupid
04:54:24 <mm_freak> merijn: or just an actively developed helium =)
04:55:40 <mm_freak> {-# LANGUAGE DependentTypes, InductiveFamilies, SanePrelude #-}
04:55:41 <mm_freak> =)
04:56:32 <merijn> @quote cutting.edge
04:56:33 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
04:57:13 <navaati> Inductive families are agda's types ?
04:57:30 <Elemir> {-# LANGUAGE LinearTypes #-} is more needed for general purpose language
04:57:32 <merijn> And Coq and Epigram and ECC
04:57:35 <mm_freak> navaati: basically yeah
04:57:58 <mm_freak> but seriously i'd vote for uniqueness types
04:57:58 <merijn> Time to make myself look smart ;p
04:58:34 <earthy> hm. uniqueness types have an infective property
04:58:44 <Brolapse> yo how I go about comparing strings ignoring case?
04:58:59 <navaati> merijn: Agda/Coq/Epigram have the same type system, don't they ?
04:59:04 <Elemir> Uniqueness types considered harmful, linear more safeful
04:59:04 <earthy> compare `on` toLower ?
04:59:17 <Elemir> navaati: No, they don't
04:59:20 <t7> @pl c `Set.union` Set.fromList (map (\(_, v') -> Equal (TVar v') t) $ filter ((== id) . fst) a)
04:59:20 <lambdabot> (line 1, column 3):
04:59:20 <lambdabot> unexpected "`"
04:59:20 <lambdabot> expecting variable, "(", operator or end of input
04:59:28 <mm_freak> Brolapse: i'd use the case-insensitive package
04:59:31 <bitonic> navaati: well, they're based on the same concepts, but they're not the same
04:59:50 <mm_freak> Brolapse: http://hackage.haskell.org/package/case-insensitive
05:00:13 <merijn> navaati: They share much of the same underlying type theory, but they are not the same
05:00:15 <ment> just to be sure - function definition with a guard continues with pattern matching if all guards eval to False?
05:00:26 <merijn> ment: Yes
05:00:38 <ment> awesome
05:04:11 <navaati> cabal-dev can be used as a drop-in replacement to cabal-install, right ?
05:05:36 <merijn> What's the data type for 32 bit (unsigned) ints?
05:05:53 <navaati> merijn: Data.Word.Word32
05:06:04 <navaati> Data.Int.Int32 for the signed one
05:06:22 <merijn> navaati: Thanks
05:07:05 <t7> wh5a (Wei Hu), are you in here?
05:09:15 <navaati> hahaha, darcs package description in archlinux is "Decentralized replacement for CVS with roots in quantum mechanics" :D
05:09:51 <hpc> it's okay though, because CVS is based on flat-earth theory
05:10:34 <navaati> (flat-earth and geocentric)
05:11:00 <hpc> don't be silly; earth is at the top
05:11:05 <hpc> it's turtles all the way down
05:14:11 <navaati> aww, crap, darcs needs to be built but necessary packages don't exist… archlinux suxx for haskell. I miss my gentoo…
05:15:14 <egomes> Does anybody know how to parse to a phantom type?
05:15:26 <hpc> egomes: parse?
05:15:31 <bitonic> egomes: I don't understand your question, what do you need to do?
05:15:35 <navaati> egomes: "parse" ? what do you mean ?
05:16:30 <egomes> I have to make an instance of "parseJSON"
05:16:59 <byorgey_> egomes: if you mean parse a value of a GADT such that the value of some phantom type parameter is determined by the value, you have to make an existential wrapper and parse to that.
05:17:04 <egomes> for this data type "data CombDist = forall a . Distribution a =>  CombDist a"
05:17:57 <byorgey_> oh, that should be possible.  Are you having some particular trouble?
05:18:01 * hackagebot yesod 1.0.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.2 (MichaelSnoyman)
05:18:03 * hackagebot yesod-auth 1.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.0.2 (MichaelSnoyman)
05:18:53 <egomes> yes, when I do "instance FromJSON CombDist where parseJSON a@(Object v) = CombDist <$> v .: "CombDist"
05:19:18 <egomes> I get "add a type signature that fixes these type variable(s)" from ghc
05:20:08 <byorgey_> egomes: what is the type of v? and the type of .: ?  Can you paste the code along with the entire error message on hpaste.org?
05:20:53 <byorgey_> egomes: also, for future reference, pasting the code and error message is the very first thing you should have done, rather than asking a vague question about parsing
05:21:45 <fmap> (.:) is from Aeson i guess
05:22:11 <byorgey_> probably, but I'm not familiar with aeson
05:24:17 <hpaste_> “edgar gomes” pasted “parse phantom types” at http://hpaste.org/67483
05:26:03 <hpc> @hoogle (.:)
05:26:04 <lambdabot> No results found
05:27:33 <byorgey> egomes: OK, the problem is that .: can return a value of any type
05:27:59 <egomes> @fmap: yes, it's from aeson
05:27:59 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:28:08 <byorgey> its behavior is actually determined by what type you want to get out of it!
05:28:47 <navaati> any arch user here ?
05:29:08 <egomes> OK, I was thinking on that, but is there a workaround?
05:29:10 <byorgey> so if all you do is wrap it in CombDist, GHC has no idea what type to pick
05:29:14 <byorgey> hmmm
05:29:25 <quicksilver> there isn't a workarond, no
05:29:31 <quicksilver> you have to decide what type you want and tell the compiler.
05:29:34 <byorgey> egomes: the only workaround is to specify what type you want
05:29:42 <quicksilver> the compiler can't guess
05:29:53 <quicksilver> it's quite useful to think abot what you're asking the compiler to do here :)
05:30:56 <byorgey> the type of the result determines how the value will be parsed -- there's no way to just look at the raw string data coming in and figure out what type it represents.
05:30:58 <egomes> So I've to give up from the phantom type :-(
05:31:51 <egomes> I got it. Thank you a lot, guys!
05:32:21 <tgeeky> egomes: I think they are telling you that you could use type annotations
05:32:41 <tgeeky> egomes: but I'm an idiot, so possibly also goose zebra monster cheeseburger heyena.
05:33:22 <byorgey> hmm, not cheeseburger
05:33:27 <byorgey> but the others could work
05:34:18 <quicksilver> egomes: no, I'm not saying that
05:34:32 <quicksilver> in fact I'm not sure that *is* a phantom type
05:34:41 <quicksilver> certainly it's not obvious that it's phantom from what you've shown us
05:34:47 <quicksilver> but removing it doesn't seem to solve the problem.
05:34:56 <quicksilver> The problem is just that you need to specify what type(s) you want to parse as.
05:36:55 <egomes> quicksilver: I've used it to create a heterogeneous list
05:37:19 <quicksilver> I'm really fairly sure you shouldn't be using the word 'phantom'
05:37:26 <navaati> a phantom type ? for a hlist ?
05:37:37 <quicksilver> sounds like you're talking about using an existential wrapper for a heterogenous list
05:37:40 <quicksilver> that's fine.
05:37:45 <quicksilver> that doesn't make parsing impossible
05:38:02 <quicksilver> it just means that your parser has to do some work to decide what "type" the bit it's parsing is.
05:38:41 <egomes> oopss, i thought they were the same :-[
05:39:14 <navaati> hlists are usually about hiding the type using existentials, whereas phantom types are about adding type information
05:39:31 <quicksilver> one approach when parsing at multiple possible types is simply to try them one after another
05:39:39 <quicksilver> trying the next if the previous failed.
05:40:26 <merijn> @pl \f -> do {in <- newChan; forkIO (f in); return in}
05:40:26 <lambdabot> (line 1, column 10):
05:40:27 <lambdabot> unexpected "{"
05:40:27 <lambdabot> expecting variable, "(", operator or end of input
05:43:27 <ment> (from Hugs' Data.Map) lookup :: (Monad a, Ord b) => b -> Map b c -> a c
05:43:33 <ment> why the Monad constraint?
05:43:41 <quicksilver> merijn: newChan >>= ((>>) . forkIO . f) `ap` return
05:43:52 <quicksilver> ment: a (bad) way to indicate failiure.
05:43:52 <mauke> because it's full of fail
05:44:05 <ment> oh, right
05:44:11 <ment> i forgot maybe is also a monad
05:44:19 <merijn> :t \f -> (>>) <$> forkIO . f <*> return
05:44:20 <egomes> quicksilver: But then I will lose  some of the modularity given by the type class, don't I?
05:44:20 <lambdabot> Not in scope: `forkIO'
05:44:33 <quicksilver> egomes: I think you're imagining something which is impossible
05:44:41 <quicksilver> egomes: but unless you can ask more precise questions I'm not sure.
05:44:59 <quicksilver> egomes: do you expect the compiler to magically attempt parsing at a list of types it doesn't even know the length of?
05:45:18 <merijn> quicksilver: I like "(>>) <$> forkIO . f <*> return" better, unless someone can come up with something even prettier
05:45:29 <navaati> *disclaimer : not a troll* why are people using hugs ?
05:45:36 <quicksilver> merijn: I like {in <- newChan; forkIO (f in); return in} myself
05:45:43 <mauke> navaati: small download, easy to build
05:45:47 <quicksilver> merijn: pointful notation is nice and easy to read :)
05:45:56 <quicksilver> navaati: written in portable C works on many many platforms.
05:46:05 <navaati> mauke: ah, good point, ghc takes 3 hours to build
05:46:19 <mauke> and requires ghc to build
05:46:45 <navaati> mauke: wtf ?
05:46:46 <merijn> quicksilver: Meh, I'm right now rather ambivalent about which I end up using
05:46:55 <egomes> quicksilver: I know, there no magic :-/
05:47:07 * earthy prefers quicksilver's version
05:47:22 <earthy> makes it more immediately clear what's happening
05:47:25 <merijn> navaati: You bootstrap with an old C implemented GHC and then recursively build newer versions until you reach the current GHC
05:47:29 <quicksilver> navaati: GHC, as shipped, requires GHC to build
05:47:49 <quicksilver> merijn: that sounds odd.
05:47:53 <srhb> merijn: I wonder how long that process takes from scratch. :-)
05:47:57 <quicksilver> merijn: GHC has never been implemented in C.
05:48:00 <merijn> quicksilver: I thought that was the procedure on freebsd
05:48:03 <navaati> this is typically the case where an Arrow instance of a -> m b would be great…
05:48:04 <flux> GHC crosscompiles, though?
05:48:06 <quicksilver> all versions of GHC were written in haskell.
05:48:07 <merijn> quicksilver: I meant using the GHC to C backend
05:48:09 <quicksilver> flux: no.
05:48:14 <quicksilver> merijn: I thought maybe you meant that.
05:48:15 <flux> well that's a bummer
05:48:19 <earthy> GHC compiles -fvia-c
05:48:19 <bitonic> quicksilver: what he means is that you compile to C with an existant GHC and then compile the C on the new platform
05:48:20 <egomes> quicksilver: Now I've to leave. Thank you again.
05:48:21 <quicksilver> merijn: which is why I said "sounds odd" :)
05:48:25 <bitonic> egomes: not anymore
05:48:34 <mauke> bitonic: mistab?
05:48:38 <bitonic> or is it just deprecated?
05:48:40 <merijn> Compile GHC to C on one machine, copy over C source. Compile C on native machine, proceed building to current
05:48:44 <bitonic> yeah, earthy
05:48:45 <quicksilver> merijn: (because that's not was 'implemented in C' sounds like it means)
05:49:05 <earthy> *but* you still have to make sure the GHC that compiles to C generates the right wordsizes
05:49:10 <earthy> and endiannesses
05:49:21 <quicksilver> flux: they're working on it, though.
05:49:35 <bitonic> I think merijn is referring to this process: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
05:49:44 <quicksilver> flux: e.g. http://www.haskell.org/pipermail/iphone/2012-March/000120.html
05:50:39 <navaati> ouch, crosscompiling is really needed because… building ghc on a 3Ghz quadcore tkes hours, so i can't even imagine on an iphone…
05:50:50 <dzhus> hours?
05:51:08 <mauke> easily
05:51:15 <dzhus> Average merge time: 1 hour, 1 minute and 48 seconds.
05:51:30 <navaati> dzhus: ah ? what's your machine ?
05:51:32 <merijn> It's to piss of all the Arch/Gentoo fans :D
05:51:49 <quicksilver> merijn: there are easier ways of doing that
05:51:50 <dzhus> navaati: AMD Athlon(tm) 64 X2 Dual Core Processor 5000+
05:51:59 <navaati> dzhus: oh…
05:52:03 <dzhus> quite old
05:52:05 <tgeeky> dzhus: that's a little old/weak
05:52:18 <mauke> merijn: USE=binary
05:52:25 <tgeeky> navaati: but the point is well taken. Cross compilation would be wonderful
05:52:54 <navaati> ah, no, i remember, it took hours once because the prebuild ghc needed to bootstrap it was not ready, and so the ebuild had to build ghc twice…
05:52:56 <bitonic> they're pretty close to that, via LLVM. the next release should have something
05:53:35 <navaati> i've dreamed about writing haskell programs for my openmoko :D
05:53:36 <tgeeky> bitonic: at the rate GHC release notes are going, I won't be surprised to see that GHC 7.8 is sentient.
05:53:58 <bitonic> {-# LANGUAGE SkyNet #-}
05:54:00 <mauke> GHC 8: sufficiently smart
05:54:06 <dzhus> given (f :: a -> m b) and (g :: b -> m c), how to compose two into (h :: a -> m c)? shouldn't it be just >>=?
05:54:21 <mauke> :t (>=>)
05:54:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:54:22 <bitonic> @type >=>
05:54:23 <lambdabot> parse error on input `>=>'
05:54:28 <dzhus> ah
05:54:38 <serialhex> http://xkcd.com/1046/ <~ skynet,m built in ghc :P
05:54:53 <quicksilver> {-# LANGUAGE ExistentialCrisis #-}
06:06:11 <dzhus> Still not sure about hours for GHC compilation. Will try to build with bootstrapping now.
06:13:02 * hackagebot yesod-test 0.2.0.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.1 (MichaelSnoyman)
06:18:04 * hackagebot type-level-numbers 0.1.0.3 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.0.3 (AlexeyKhudyakov)
06:23:03 * hackagebot yesod-platform 1.0.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.2 (MichaelSnoyman)
06:26:53 <navaati> rhaaa, xkcd link dropping = oops, one hour has passed
06:30:37 <Arafangion> I just wish to say that "Real world haskell" is an _excellent_ book, I'm up somewhere around chapter 4 now. :)
06:31:51 <efie> if a function with the same parametes is called several times in a programm, does haskell calculate the result every single time or does it do efficiency optimization on its own? (like calculating the result once and storing it in a data structe for fast access)
06:33:03 <navaati> efie: depends
06:33:11 <Botje> efie: most implementations won't do that.
06:33:21 <dschoepe> efie: No, but that result can be achieved fairly easily, e.g. with the memoize package.
06:34:49 <efie> ok, I will try this memoization stuff then, thanks
06:35:11 <navaati> in local expressions there is sharing, isn't there ?
06:38:03 * hackagebot unfoldable 0.3.0 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.3.0 (SjoerdVisscher)
06:38:56 <quicksilver> navaati: not of functions called with the same parameters, no.
06:39:10 <quicksilver> navaati: local sharing of named values (with no parameters), yes.
06:39:20 <quicksilver> also, non-local.
06:39:24 <quicksilver> the locality is neither here nor there.
06:39:25 <navaati> like if i do let blah = (f x,f x), no sharing ?
06:39:43 <quicksilver> most likely no sharing.
06:39:59 <quicksilver> GHC only does CSE in very limited circumstances.
06:40:17 <navaati> i *must* do let blah = let y = f x in (y,y) ? duh.
06:40:38 <quicksilver> if you want to be sure of the sharing, yes.
06:40:56 <quicksilver> although it's almost never necessary to nest lets like that
06:41:47 <navaati> ah, let y = f x; blah = (y,y) in … would work ?
06:42:05 <navaati> (i mean, yes it would work, but would it share as well ?)
06:43:03 * hackagebot hsx 0.10.0 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.0 (NiklasBroberg)
06:43:04 <navaati> (bah, cabal-dev doesn't tell to haddock where the deps are…)
06:43:05 * hackagebot HJScript 0.6.0 - HJScript is a Haskell EDSL for writing JavaScript programs.  http://hackage.haskell.org/package/HJScript-0.6.0 (NiklasBroberg)
06:43:13 <efie> I'm thinkg about if I can solive this without using a memoize package: Say f :: Int -> Int and f 1 = 1, f 2 = 2, f 3 = 3 are called several times. What if create all those (input, result) pairs in a list and instead of calling the f1 f2 functions I look 1, 2 in the list of pairs up to get the result? Would this be as efficient as using mesmorizing functions?
06:43:38 <navaati> efie: it's precisely what memoize does
06:43:41 <quicksilver> navaati: yes it would share.
06:43:59 <quicksilver> navaati: as I said, locality is neither here nor there.
06:44:06 <efie> navaati: ok :)
06:44:13 <navaati> quicksilver: *nod*
06:44:27 <quicksilver> navaati: y = f x; blah = (y,y); at the top level of a module is fine too.
06:44:31 <killy9999> I just got "The implementation of functional programming languages" by Simon PJ from my library. Is it worth reading if I want to understand how GHC works?
06:44:41 <quicksilver> navaati: or across two modules, for that matter.
06:44:55 <mm_freak> killy9999: yes
06:45:38 <killy9999> I wonder how much knowledge is assumed
06:45:53 <killy9999> introduction says that I  shoul be familiat with functional programming
06:46:00 <killy9999> but I'm affraid there's more than that
06:46:12 <quicksilver> just try it, what's the worst that can happen? :)
06:46:19 <navaati> "being familiar with FP" is pretty vague :p
06:46:30 <hiptobecubic> intimately familiar
06:46:33 <navaati> headache
06:46:35 <quicksilver> you might be prompted to do some more research and end up reading some moreinteresting stuff.
06:46:42 <hiptobecubic> You need to know what size bra ghc wears.
06:47:51 <killy9999> the worst case scenario is probably commiting my time and realizing it was a waste :)
06:48:04 <efie> to get a pair (a,b) out of a list of (different) pairs  is there a more efficient way than writing head $ filter (\(c,d) -> c == a) list?
06:48:07 * hackagebot hsp 0.7.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.7.0 (NiklasBroberg)
06:48:09 * hackagebot hsx 0.10.1 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.1 (NiklasBroberg)
06:48:23 <navaati> i wouldn't consider being too familiar with ghc : she's powerful but capricious and she likes bondage…
06:48:38 <Botje> killy9999: I think they explain features as they go.
06:48:55 <killy9999> efie: there's fst function that gets first element of a pair
06:49:08 <navaati> btw, i'd love it if my library had spj's books…
06:49:11 <efie> killy9999: ah, thanks
06:49:32 <killy9999> navaati: yeah, I was surprised to find it
06:49:51 <killy9999> I went to get a Appel's book on compilers and I found this
06:50:12 <killy9999> also found a PhD thesis "Implementing Lazy Functional Languages"
06:50:35 <killy9999> an old one
06:50:41 <navaati> (french library not having a lot of english books doesn't help, of course… *sigh*)
06:52:53 <killy9999> Polish library having this book is a surprise..
06:53:51 <quicksilver> efie: lookup
06:54:43 <eacameron> whatever happened with "defaulting"? http://hackage.haskell.org/trac/haskell-prime/wiki/Defaulting
06:54:49 <navaati> btw, where is the best place to do haskell at school/place where haskell development happen ?
06:55:01 <navaati> (by place i mean university or something like that)
06:55:12 <merijn> navaati: In which country/area?
06:55:25 <navaati> merijn: doesn't matter
06:55:31 <notthemessiah> yale and glasgow?
06:55:36 <navaati> english-speaking, though
06:55:56 <merijn> University of Utrecht works quite a lot on interesting haskell stuff (UHC and the haskell to JS compiling)
06:56:16 <merijn> There's another one in Sweden that I forgot the name of that does quite a lot of Haskell
06:56:23 <bitonic> merijn: chalmers
06:56:26 <navaati> isn't yale a fucking difficult to go to place ? like very high standing and so on ?
06:56:28 <merijn> Ah, yes. Chalmers
06:56:44 <navaati> ah, chalmers is in sweden ? i wouldn't have guessed
06:56:54 <bitonic> navaati: choosing your undergrad uni on how much haskell they do is probably not a good idea :P
06:57:03 <liyang> There's very little left in the University of Glasgow.
06:57:04 <navaati> bitonic: eh, why not ?
06:57:13 <bitonic> navaati: it tells you something but it's definitely not enough
06:57:18 <danr> I'm at Chalmers right now listening to John Hughes lecturing about parallell functional programming... maybe I should pay more attention to the lecture though
06:57:22 <bitonic> you should look at the entire syllabus
06:57:48 <earthy> bitonic: there is a bit of correlation between 'lots of haskell' and 'good programming curriculum' though
06:57:53 <liyang> But there's the University of Strathclyde in Glasgow which is highly regarded in the area.
06:58:03 <bitonic> earthy: probably
06:58:15 <merijn> Utrecht has the advantage that people enrolled at one Dutch university are entitled to follow courses at *any* Dutch university (at least nationals, but I think the same applies to international students)
06:58:25 <navaati> bitonic: i don't want to go there to learn haskell, i want to go because people doing haskell are there
06:58:26 <earthy> it does
06:58:36 <ment> @hoogle (a -> Maybe a) -> t a -> t a
06:58:36 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
06:58:37 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
06:58:37 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
06:58:37 <merijn> And there's a bunch which have quite nice courses unrelated to FP
06:58:52 <earthy> plus, Utrecht is generally good when it comes to CS
06:59:13 <earthy> although I don't know its current financial status... there's been some cutbacks in the past few years
06:59:25 <navaati> i ask because i tried the university in my town (marseille, quite a big city…) and… it was shit
06:59:34 <earthy> marseille... yeah.
06:59:49 <navaati> which is strange because iirc it is where prolog comes from
06:59:56 <liyang> (Utrecht also has the advantage of MagicHash being freely available.)
07:00:04 <earthy> but if you're used to marseille, then .nl climate is shit. :)
07:00:10 <merijn> Word
07:00:22 <navaati> liyang: damn, you can have entire Hash Tables ? wow
07:00:47 <merijn> We had an intern from Marseille and when it was raining he stayed home for a day "because of the bad weather" :p
07:00:58 <navaati> earthy: bah, i come from lille and am atm in dublin, so…
07:01:05 <merijn> Where everyone else was like "are you kidding? I cycled to work!"
07:01:08 <earthy> navaati: in france I'd stay with universities associated with inria
07:01:38 <navaati> earthy: ah ? i'll check that
07:01:48 <navaati> aren't they the guys that do a lot of ocaml ?
07:01:51 <merijn> Yeah, INRIA is quite good
07:01:52 * earthy nods
07:01:55 <merijn> ocaml and Coq, yes
07:02:19 <navaati> sounds good. may be difficult to enter, though, but, well.
07:02:53 <earthy> well, I haven't really heard from any interesting french CS research that is *not* associated somehow with INRIA
07:02:56 <earthy> so there's that.
07:03:06 * earthy isn't in france though
07:03:27 <merijn> That's because most of the French stuff is still mostly french, rather than English :p
07:03:35 * earthy can read french... mostly
07:04:22 <navaati> but, eh, these universities in nl and sweden, i guess one but speak dutch and swedish to follow the courses, right ?
07:04:50 <merijn> All master courses in NL are taught in English and so are some (but I would guess minority) of the bachelor courses
07:04:53 <earthy> navaati: depends. in .nl at least the master's courses tend to be offered in English
07:05:09 <navaati> interesting… france is really retard
07:05:23 <earthy> not retarded. arrogant. :)
07:05:24 <killy9999> what about Nottingham?
07:05:46 <earthy> killy9999: no clue 'bout nottingham
07:05:52 <earthy> I would offer the option of Nijmegen
07:05:52 <killy9999> there's a FP lab
07:05:58 <killy9999> http://fp.cs.nott.ac.uk/
07:06:00 <earthy> which has less Haskell, but more CS security
07:06:24 <merijn> killy9999: Yeah, but McBride moved to Strathclyde (another option, if no one mentioned it yet)
07:06:25 <killy9999> I'm looking for a place where I could do some research on Haskell
07:06:44 <merijn> If you like pain and hard theory, that is :p
07:06:44 <killy9999> McBride?
07:06:54 <earthy> merijn: what pain? :)
07:07:34 <navaati> eacameron: i dunno but i vote 4 !
07:07:37 <merijn> That name triggers sheer terror in a lot (most?) people with some type theory knowledge :p
07:07:57 <killy9999> I was thinking also about St. Andrews
07:07:59 <merijn> He has some very cool ideas, but his papers are...notoriously difficult
07:08:04 <killy9999> they also seem to have FP lab
07:08:05 * hackagebot mtl 2.1.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1.1 (EdwardKmett)
07:08:09 <earthy> james mickinna is in Nijmegen though. :)
07:08:30 <efie> quicksilver: thanks!
07:08:31 <merijn> Yeah, Nijmegen does some need FP stuff to, with Clean
07:08:35 <merijn> s/need/neat
07:08:38 <earthy> Clean is a dead end
07:08:52 <earthy> as is its research group, imnsho
07:08:53 <killy9999> st. Andrews developd Hume IIRC
07:09:03 <efie> by using the memorizing thing my program runs like 2 minutes faster :)
07:09:06 <killy9999> but Hume seems to be dead
07:09:26 <earthy> but, there's a *really* strong theory department
07:09:28 <merijn> killy9999: I can ask around here, I think one of the St. Andrews guys working on Hume is my project group
07:09:51 <earthy> what with Geuvers, Barendregt, McKinna...
07:10:24 <merijn> killy9999: Oh wait, he's at Heriot-Watt
07:10:31 <earthy> bit of a pity we couldn't find funding for my continued employment there... (or at Utrecht)
07:10:51 <raboof> earthy: do they still exist? :)
07:11:12 <raboof> (the Clean group)
07:11:14 <earthy> what, the clean research group? yes.
07:11:20 <earthy> at least, they did last november
07:11:23 <merijn> Barendregt died recently, didn't he? (Someone famous & Dutch anyway, lemme check)
07:11:26 <tomprince> merijn: Terror? I find his papers very fun to read.
07:11:34 <earthy> Henk?! not that *I* know of...
07:11:38 <roconnor> merijn: you are thinking of de bruijn
07:11:42 <earthy> wasn't that de Bruijn? :)
07:11:53 <merijn> oh, duh
07:12:12 <merijn> tomprince: You are probably much more intelligent than me, then.
07:12:45 <merijn> Yes, I was thinking of de Bruijn
07:13:05 * hackagebot Yablog 0.0.1.1 - A simple blog engine powered by Yesod.  http://hackage.haskell.org/package/Yablog-0.0.1.1 (HiromiIshii)
07:13:07 <killy9999> merijin: do you know what's the status of FP research at Heriot-Watt?
07:13:13 <tomprince> Well, they certainly require work. But I find his delivery entertaining.
07:13:20 <merijn> tomprince: I read A View from the Left and it took me the better part of 5 months and I still only get half of it
07:13:29 <killy9999> I couldn't find any information on their webpage
07:13:47 <merijn> killy9999: Not really, as I only occasionally interact with people there
07:14:01 <byorgey> merijn: to be fair, that is by far one of the most difficult of his papers
07:14:08 <byorgey> I only get half of that one too.
07:14:28 <merijn> killy9999: Also depends on how pure you want your FP to be :p
07:14:32 <tomprince> merijn: Well, I never meant fun to contrast with hard.
07:15:37 <tomprince> I was just commenting that most of his work that I have read is *playful*.
07:16:42 <merijn> I know their doing some work on a functional array language which is supposed/going to support automatic statistical optimisation (i.e. you run the code and monitor, then try to optimise the compiled code based on runtime statistics)
07:17:05 <merijn> But it's fairly different from "traditional" FP like haskell/ML
07:17:19 <cfricke> Hey there. I am having difficulties with a natural number representation. More specifically, the plus function. I understand the how and why, but have difficulties writing it properly:
07:17:21 <hpaste_> cfricke pasted “natural plus” at http://hpaste.org/67485
07:17:27 <merijn> tomprince: Sure, it just reads like a theoretical hammer to the face
07:18:05 * hackagebot Yablog 0.0.1.2 - A simple blog engine powered by Yesod.  http://hackage.haskell.org/package/Yablog-0.0.1.2 (HiromiIshii)
07:18:32 <byorgey> cfricke: someone just had this exact same issue on the mailing list.  The problem is that Natural really ought to be  Natural = forall a. (a -> a) -> (a -> a)
07:18:37 <byorgey> cfricke: let me see if I can find you a link.
07:18:54 <cfricke> byorgey: That would be lovely, thanks!
07:20:03 <navaati> byorgey: isn't the only possible value for your Natural type id ?
07:20:14 <byorgey> no
07:20:34 <byorgey> there are also things like  \f x -> f (f (f x))  and so on
07:20:48 <byorgey> in fact, the only possible values are exactly models of the natural numbers =)
07:21:02 <navaati> oh, yeah, of course, meh…
07:21:24 <navaati> oh, is this the definition of naturals in lambda calculus ?
07:21:36 <byorgey> yes, the so-called "Church encoding" of naturals
07:21:39 <sully> byorgey: and the function that diverges, and the function that raises an error...
07:22:00 <byorgey> sully: heh, shush =)
07:22:09 <navaati> sully: these does not exist in a Trully Pure language :p
07:22:17 <sully> sure, yeah
07:22:20 <sully> but haskell ain't that :P
07:22:23 <byorgey> (you're right of course)
07:22:45 <sully> you want system F
07:22:55 <merijn> killy9999: I guess you just missed my remark: <merijn> I know they're (Heriot-Watt) doing some work on a functional array language which is supposed/going to support automatic statistical optimisation (i.e. you run the code and monitor, then try to optimise the compiled code based on runtime statistics) <merijn> But it's fairly different from "traditional" FP like haskell/ML
07:22:58 <navaati> byorgey: i'm just wondering… i can see how you write succ (you apply another f) but… how do you write pred ?
07:23:12 <cfricke> byorgey: It wasn't the haskell-beginners mailing list, by any chance?
07:23:26 <byorgey> cfricke: oh, it might have been, maybe that's why I can't find it =)
07:23:49 <navaati> (i only know the "N = S N | Z" definition of N…)
07:23:56 <cfricke> byorgey: Hm, I closely follow it but not able to find it either.
07:24:06 <byorgey> navaati: pred is tricky!
07:24:08 <merijn> navaati: Writing Pred is very hard in Church encoded numerals
07:24:11 <liyang> killy9999: there's very little research "on Haskell" itself anywhere. It's mostly research on X using Haskell as a testbed.
07:24:17 <merijn> Scott encoding is better in that scenario
07:24:30 <navaati> ah, ok, it's not just me :)
07:24:38 <merijn> (Mogensen-Scott, even)
07:24:51 <byorgey> cfricke: well, I can't find it, but I think I can explain it.
07:24:54 <cfricke> Pred is tricky. I don't know, why I even bother with that representation.
07:25:08 <sordina1> Does anyone know what the parser used by [d| |] quasiquoter is called and if I can reuse it in non-quasi-quote form?
07:25:20 <byorgey> cfricke: the problem is that plus' takes a (Natural a) as its first argument, which is a function expecting something of type (a -> a)
07:25:28 <liyang> killy9999: In order of size in England at least, you're probably looking at Nottingham, Oxford and York.
07:25:33 <byorgey> cfricke: but you are passing it succ' which has type  Natural a -> Natural a
07:25:59 <byorgey> cfricke: a -> a   and  (Natural a -> Natural a) cannot unify.
07:26:12 <cfricke> byorgey: Yeah, I figured. It works, however not with the type signature supplied.
07:26:50 <byorgey> cfricke: the solution is to make  Natural an existential type:  newtype Natural = Natural (forall a. (a -> a) -> (a -> a))
07:27:02 <byorgey> cfricke: that is, a Natural is a function which must be able to take *any* type as its argument
07:27:56 <byorgey> cfricke: another way to see that your definition of Natural is not the one you want is to realize that it admits things like   (\f x -> if x == 42 then 3 else 17) :: Natural Int  which does not make sense
07:28:05 * hackagebot Yablog 0.0.1.3 - A simple blog engine powered by Yesod.  http://hackage.haskell.org/package/Yablog-0.0.1.3 (HiromiIshii)
07:28:14 <cfricke> byorgey: Thanks, I shall try that! I am still rather new to Haskell and haven't touched forall, yet.
07:28:53 <bitonic> Dybber: that's not an existential type
07:28:57 <bitonic> sorry, byorgey
07:29:02 <byorgey> cfricke: basically you're running up against the fact that Church encoding makes the most sense in an *untyped* lambda calculus.  To get it to work in a typed lambda calculus requires some contortions.
07:29:25 <byorgey> bitonic: you're right, sorry, it's just higher-rank
07:29:37 <navaati> it's a rank2 type rather than an existential,right ? i don't really see the difference
07:29:52 <ment> is it possible to convince pattern matching to fail in a monad?
07:29:58 <bitonic> navaati: yes, they're very different thing (the 'forall' to define existentials is confusing)
07:30:11 <bitonic> ment: yes, use 'case'
07:30:12 <byorgey> cfricke: I don't know whether this is really the best exercise for someone just learning Haskell =)
07:30:26 <killy9999> liyang: thanks
07:30:30 <ment> bitonic: splendid, thanks
07:30:46 <bitonic> ment: yw
07:30:48 <cfricke> byorgey: Thank you very much for the insight. I was conversing with Simon Thompson (the author of the book containing this exercise), but he wouldn't go into detail, just stating what he already wrote.
07:31:04 <killy9999> liyang: what about GHC development?
07:31:15 <killy9999> Microsoft Research at Cambridge?
07:31:16 <hpaste_> dzhus pasted “Obscure ErrorT problem” at http://hpaste.org/67486
07:32:40 <liyang> killy9999: that's not research, and mostly confined to MSR and Well-Typed. But there's nothing stopping you from joining in.
07:33:48 <cfricke> byorgey: Can I get this working in ghci? I seem to be missing some flag. Sorry to bother.
07:33:56 <byorgey> liyang: it is too research.
07:34:07 <byorgey> also some of that happening at U Penn in collaboration with MSR.
07:35:05 <liyang> byorgey: what, just hacking on GHC? Not unless you had something novel to add to it, in which case you'd have a paper in the pipeline too.
07:35:31 <byorgey> liyang: but much of the hacking on GHC these days has to do with adding novel things to it.
07:35:57 <byorgey> I agree just fixing bugs and such isn't research.
07:37:02 <efie> to benefit from parallelism, I have to compile my program in ghci with :load "x.hs" -threaded +RTS -N, have I not? it says target `-threaded' is not a module name or a source file
07:37:17 <byorgey> cfricke: try Rank2Types
07:40:02 <navaati> efie: i'm not sure you can do that with ghci, but try giving them to the commandline, not to :load
07:42:13 <zhulikas> down
07:42:26 <aszlig> hm, what's the best method of overriding linker options in cabal?
07:42:42 <navaati> dmwit: thanks for the cairo update
07:43:09 <efie> navaati: no, this does not work; http://www.haskell.org/haskellwiki/Parallelism#Multicore_GHC says that it should work this GHC
07:43:09 <aszlig> i thought about using --no-link and do it manually
07:43:19 <efie> (or is there a difference between GHC and GHCi?)
07:43:25 <cfricke> byorgey: Got it, thanks.
07:43:52 <aszlig> but otoh i'd need the object files to be linked
07:44:08 <navaati> is it only *possible* to write pred for church encoding ? if not in haskell, in lambda calculus ?
07:44:21 <opqdonut> in haskell, yes
07:44:31 <opqdonut> it just takes some effort, and it is O(n)
07:44:38 <opqdonut> (in lambda calculus too)
07:44:54 <navaati> opqdonut: oh ? would be interested if you have a code snippet somewhere
07:46:34 <bitonic> navaati: yes it's possible in both cases
07:46:44 <bitonic> the trick is to advance from 0
07:46:48 <bitonic> untill you reach your number
07:46:53 <bitonic> while keeping the previous number as well
07:47:00 <bitonic> e.g. in a church encoded pair
07:47:04 <opqdonut> yeah
07:47:20 <navaati> and how do i know i've reached my number ?
07:47:31 <navaati> do you have equality on functions ?
07:47:32 <bitonic> navaati: you can test for equality
07:47:41 <opqdonut> or you can use the input number to do the advancing n times
07:47:47 <opqdonut> so you don't need equality
07:48:01 <bitonic> yes, that's what you'll do in lambda-calculus
07:48:18 <navaati> actually i don't even know how you can know you've reached zero…
07:48:38 <bitonic> navaati: you can easily write an iszero function with the classic church encoding
07:48:54 <bitonic> zero (const false) true
07:49:17 <aszlig> hm, damn, this is fully done with ghc --make...
07:49:26 <aszlig> s/with/&in/
07:49:37 <navaati> i mean, you can't deconstruct and pattern-match functions like you can with data…
07:50:17 <aszlig> okay, question rephrased: how can i change link flag orders and/or add/remove flags at that point?
07:50:27 <bitonic> navaati: you don't need that
07:50:49 <navaati> ah ! 0 = const id, right ?
07:50:49 <opqdonut> actually, the wiki page for church encoding has a simpler pred
07:50:53 <opqdonut> http://en.wikipedia.org/wiki/Church_encoding
07:51:05 <aszlig> -no-link and doing linking manually would be a possibility, but how do i need the list of to-be-linked object files then?
07:51:15 <opqdonut> it doesn't have equality tho
07:51:19 <t7> StateT Int (Either String) Double = return $ Left "no"
07:51:22 <bitonic> navaati: zero f x = x
07:51:23 <t7> is that correct?
07:51:55 <aszlig> s/need/get/
07:52:15 <aszlig> something like "-pretend-to-link" :-D
07:53:06 * hackagebot type-level-numbers 0.1.0.4 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.0.4 (AlexeyKhudyakov)
07:57:57 <aszlig> okay, maybe i'm not specific enough, what i want is the following:
07:57:57 <cfricke> opqdonut: That link helped me a great deal. Thanks!
07:58:44 <aszlig> gcc -Bstatic -lffi -lgmp -Bdynamic ... everything else
07:59:34 <cfricke> byorgey: Got it to work with my prior notation which is supposedly taken straight from Church (just like succ): plus' n m f x = n f (m f x)
08:01:21 <t7> is there a lift either?
08:02:00 <t7> @hoogle m a -> s m t ->
08:02:00 <lambdabot> Parse error:
08:02:00 <lambdabot>   m a -> s m t ->
08:02:00 <lambdabot>                  ^
08:02:02 <t7> @hoogle m a -> s m t
08:02:03 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
08:02:03 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
08:02:03 <lambdabot> Text.Regex.Base.RegexLike AllMatches :: (f b) -> AllMatches f b
08:02:16 <t7> :t lift
08:02:16 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:02:46 <t7> so many monads
08:02:50 <t7> so little time
08:05:54 <navaati> why so many builds broke with ghc 7.4 ? what has changed so much ? i can't tell by reading the changelog…
08:06:42 <dzhus> built ghc in two hours
08:06:58 <copumpkin> navaati: Eq/Show superclasses of Num were removed
08:07:37 <tdammers> why did they exist in the first place?
08:07:53 <copumpkin> lack of foresight back in the day, I assume?
08:07:56 <dzhus> maybe the same reason why Functor does not imply Monad.
08:07:58 <navaati> ah, i wouldn't have thought that had broken so much things…
08:08:00 <copumpkin> same reason Num is still badly thought out
08:08:05 <dzhus> erm, vice versa
08:08:33 <copumpkin> navaati: a lot of people could previously assume values of Num were showable and comparable for equality, whereas now they need to say so explicitly
08:09:08 <navaati> anyway, it shows that base is going in the right direction
08:09:08 <Arafangion> Why shouldn't a Num be showable?
08:09:16 <tdammers> Why should it have to be?
08:09:26 <navaati> Arafangion: there are a lot of numbers that you can't show
08:09:32 <copumpkin> Arafangion: because there are plenty of valid instance of Num that are functions, for example
08:09:53 <tdammers> Num and Show should be orthogonal
08:10:07 <Arafangion> navaati: You mean, there are plenty of numbers you can't even approximate?
08:10:18 <copumpkin> there are plenty of numbers that do not have a meaningful way of showing them
08:10:41 <Arafangion> Fair enough.
08:10:41 <navaati> Arafangion: no, i was thinking about what copumpkin said : you can't show functions
08:10:49 <copumpkin> > sin^2 + cos^2 $ 5
08:10:50 <lambdabot>   0.9999999999999999
08:10:58 <Arafangion> navaati: I'm not far enough into Haskell to understand that... yet.
08:11:02 <copumpkin> > sin + cos $ 4
08:11:03 <lambdabot>   -1.4104461161715403
08:11:09 <copumpkin> > sin
08:11:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:11:10 <lambdabot>    arising from a use of `...
08:11:12 <navaati> Arafangion: it's not haskell, it's maths :)
08:11:57 <Arafangion> navaati: The concept of a function being itself a number doesn't compute. :)
08:12:14 <copumpkin> perhaps you haven't seen enough math then :)
08:12:22 <navaati> because you assume too much things about what a number is
08:12:26 <copumpkin> or, to put it another way, "define a number"
08:13:01 <Arafangion> navaati: Perhaps I'm making too many assumptions as to what a 'Num' is.
08:13:11 <copumpkin> Num is a horrible class
08:13:19 <typoclass> so after this change, is Num allright now? or is it still controversial?
08:13:21 <copumpkin> it mixes a bunch of things that should not be mixed
08:13:21 <merijn> Arafangion: The idea is that you can add functions that will take numbers as well as numbers, as shown by the examples above
08:13:23 <navaati> here, Num is the class of things that you can add, multiply, get from an Integer, etc.
08:13:34 <mokus_> > let phi = (1 + sqrt 5)/2 in (id^2-id) phi
08:13:35 <lambdabot>   1.0
08:13:46 <hpaste_> ment pasted “patmatch” at http://hpaste.org/67488
08:13:58 <Younder> is there a athematics channel on freenode?
08:14:09 <Younder> is there a a mathematics channel on freenode?
08:14:16 <zomg> I think you're looking for #spelling
08:14:17 <zomg> ;)
08:14:19 <ment> why does it fail?
08:14:19 <navaati> Younder: yes : #haskell
08:14:21 <Arafangion> Cool - g'night! (1am. :( )
08:14:32 <kallisti> Arafangion: well in calculus for example it's common to talk about things like f + g
08:14:40 <merijn> Younder: Yes, but it's not very good in my experience. Either trivial homework or phd level stuff
08:14:41 <kallisti> where (f + g)(x) = f(x) + g(x)
08:14:44 <Younder> navaati, I use it for that purpose all the time
08:14:52 <zomg> I would try #math or such though, no idea if they exist
08:15:10 <Younder> zomg, It doesn't
08:15:13 <navaati> what is this PhD stuff ? wich age does it correspond to ?
08:15:24 <Arafangion> kallisti: Yep, but while it's common to talk about equations, it's slightly less common to talk about them as just a number.
08:15:37 <merijn> navaati: What do you mean?
08:15:39 <kallisti> well you're basically defining the addition operation on the set of functions
08:15:41 <kallisti> it's the same thing
08:15:43 <byorgey> #math does exist, doesn't it?
08:15:46 <kallisti> don't let the word "number" confuse you.
08:15:55 <copumpkin> it's pointless to spend time discussing what a number is and isn't without defining what you mean by number
08:15:55 <byorgey> oh, it's ##math
08:16:12 <Arafangion> kallisti: It's not confusing me, I just assumed it was a one-dimensional scalar.
08:16:18 <typoclass> navaati, PhD means a doctor title
08:16:20 <byorgey> Younder: IIRC ##math has a reputation for being not all that friendly
08:16:21 <kallisti> ah
08:16:25 <Younder> I think he refers to the newsgroup alt.sci.math
08:16:27 <kallisti> Arafangion: well, are complex numbers one-dimensional scalars?
08:16:29 <navaati> merijn: a PhD is a level of diploma, right ? and at which age do one typically get it ?
08:16:39 <copumpkin> navaati: there isn't a specific age
08:16:46 <merijn> navaati: doctoral, as typoclass says
08:16:48 <quicksilver> merijn: typically 25-28
08:16:59 <merijn> quicksilver: Now I'm depressed :(
08:17:00 <quicksilver> depending how long you take and whether you did a master's or not.
08:17:11 <navaati> oh, quite an advanced stuff, ok
08:17:12 <Arafangion> kallisti: No, indeed they aren't.
08:17:18 <copumpkin> many people go back to get a Ph.D. after working for a while
08:17:21 * byorgey is 30 and still has 2 years to go to finish his PhD
08:17:31 <copumpkin> navaati: as advanced as traditional degrees get. It's required to become a professor in many places
08:17:50 <byorgey> but yes, I worked for 4 years first
08:18:04 <Arafangion> kallisti: G'night, I need to sleep. :)
08:18:13 <merijn> Arafangion: Also, matrices. The generality of the Num typeclass lets you make a Num instance for matrices. Which means you can add/multiply them as expected
08:18:16 <kallisti> Num is pretty ill-defined, but I think there's still some expectations to how it works. Just not very... well-defined ones. :P
08:18:20 <kallisti> Arafangion: night
08:18:25 <navaati> Arafangion: good night
08:18:26 <copumpkin> navaati: it's not a "learning" degree as much as a research degree, where you're expected to produce original research and become an expert in your field
08:19:00 <Younder> Hi most unfriendly folk. I am the younder boy.
08:19:11 <navaati> yeah, there is a similar thing in france (doctorat), i had just no idea of what it meant
08:19:26 <merijn> navaati: Yeah, PhD is a bit of an Americanism
08:19:37 <merijn> It's spreading to Europe via the UK
08:19:43 <kallisti> copumpkin: how would numeric literals overload to in with revised typeclasses replacing Num?
08:19:48 <kallisti> *what
08:19:56 <Younder> sorry, that was ment for '##math'
08:20:01 <quicksilver> merijn: americanism?
08:20:14 * earthy is 36 and simply hasn't finished a PhD
08:20:17 <copumpkin> kallisti: probably something like "InjectionFromNaturals", "InjectionFromIntegers", and "InjectionFromRAtionals"
08:20:19 <merijn> quicksilver: Englishanism then?
08:20:26 <navaati> kallisti: you still can have a Num class, especially since now it's possible to have typeclass synonyms
08:20:27 <copumpkin> latinism!
08:20:29 <copumpkin> philosophiae doctor
08:20:43 <merijn> I had never heard the term before I started conversing with people from the US/UK
08:21:04 <navaati> copumpkin: ah, yeah, more clever solution…
08:21:04 <kallisti> copumpkin: that works.
08:21:37 <kallisti> naming is kind of bad though. :P
08:21:44 <kallisti> not everyone knows what an injection is.
08:22:06 <kallisti> IsNatural, etc would match the other classes of that sort.
08:22:17 <copumpkin> I hate "Is" as a class prefix though
08:22:21 <copumpkin> and it's kind of a misnomer
08:22:31 <quicksilver> From is better than Is
08:22:33 <quicksilver> (for this)
08:22:37 <copumpkin> how about "SuperNatural" ;)
08:22:42 <typoclass> Naturalish ;)
08:22:43 <kallisti> yes From is better
08:22:46 <copumpkin> SuperString, SuperInteger, SuperRAtional
08:22:49 <copumpkin> ;)
08:23:43 <kallisti> edwardk: you around?
08:24:01 <Younder> The 'Surreal' is far more interesting.. (On numbers and game theory. John Connaway. )
08:24:09 <edwardk> yeah
08:24:50 <kallisti> well, I guess I won't pester you too much about my `tell. Well, I already did actually...
08:24:54 <edwardk> kallisti: so you're looking for something like a Writer where you specify the reducer?
08:24:59 <kallisti> yep
08:25:05 <kallisti> three typeclass variables
08:25:10 <edwardk> kallisti: why not just a combinator?
08:25:20 <kallisti> and tell is modified to work with c instead of uh... w or whatever
08:25:22 <navaati> the problem is that type signatures will become long as hell : (CanAdd n, CanMul n, CanDiv n) => n -> n (i know there are proper terms for these class, but don't know them)
08:25:26 <kallisti> edwardk: how do you mean?
08:26:15 <kallisti> you mean just make a function that composes unit and tell?
08:26:17 <edwardk> log :: (Reducer e w, MonadWriter w m) => e -> m (); log = tell . unit
08:26:19 <edwardk> yeah
08:26:31 <edwardk> then you can log anything that you can reduce to the current monoid
08:26:32 <kallisti> hm, don't you lose the possibly more efficient representation of snoc/cons?
08:26:35 <edwardk> rather than just one thing
08:26:43 <edwardk> not really
08:26:50 <edwardk> because the monad doesn't know what its carrying
08:26:59 <edwardk> so its forced to use the full monadic join every time anyways
08:27:01 <quicksilver> like a mule
08:27:11 <kallisti> right.. that's the rationale behind a second typeclass.
08:27:16 <edwardk> you could make 3 constructors, etc. which gets pretty ugly
08:27:17 <kallisti> that would know that what its carrying is a Reducer.
08:27:48 <edwardk> but then you can only really be a monad up to some quotient where you ignore those constructors
08:28:13 <edwardk> do you see the problem? how do you wrote >>= for your monad?
08:28:20 <edwardk> er how do you write
08:28:29 <kallisti> I'd have to attempt to write it out to see.
08:28:40 <edwardk> do so, you'll see the problem ;)
08:28:58 <quicksilver> edwardk: (I'm lacking context but that might be acceptable if you provide an interface in which you can't distinguish?)
08:29:20 <edwardk> quicksilver: thats the quotient i mentioned. in theory it would work
08:29:42 <edwardk> quicksilver: but then you still have lots of case overhead, so it may not be a win in practice for many reducers
08:30:56 <edwardk> gah making a decent Floating instances for quaternions is a pain in the behind.
08:31:26 <kallisti> (a, w) >>= f = f a
08:31:27 <kallisti> er
08:31:31 <kallisti> disregard that
08:31:53 <kallisti> hm, oh..
08:31:55 <edwardk> i have exp, sin, cos, log, etc. just need to finish up the asin, etc. cases which really want another quaternion to use to choose the branch cuts
08:32:18 <kallisti> you need a third element I think?
08:32:44 <quicksilver> asin = error "damn it, choose your own branch cut, I don't know"
08:33:06 <edwardk> kallisti: or you need a 'data M r m a = None a | One r a | Some m a'
08:34:18 <edwardk> basically for asin i just take your existing imaginary components and rescale them to play the role of 'i', and use the same series reasoning that gives you the complex asin
08:34:56 <edwardk> with some care to try to avoid needless NaNs
08:35:35 <edwardk> which forces it to only work over RealFloat instances like Complex =(
08:35:57 <edwardk> if abs and signum didn't suck I could have a decent Cayley-Dickson construction and wouldn't need this
08:36:47 <quicksilver> edwardk: what useful programming can one do given a good Num absrtaction for quaternions?
08:37:14 <edwardk> you can use them like gaussian gaussian integers ;)
08:37:27 <kallisti> (a, Left c) >>= f = (a, unit c) >>= f; (a, Right w) >>= f = (b, Right w') where (b, either') = f a; w' = case either' of Left c -> w `snoc` c; Right w2 -> w `mappend` w2
08:37:33 <kallisti> maybe I should hpaste
08:37:58 <kallisti> basically instead of just w you have Either c w
08:38:50 <kallisti> return a = (a, Right mempty)
08:39:13 <newtrekemotion> So does anyone have any experience with HaXr?
08:39:34 <kallisti> edwardk: am I missing something?
08:40:01 <edwardk> kallisti: but you also want to deal with the empty case without using mempty
08:40:40 <edwardk> kallisti: or the moment you do almost anything your extra constructor will be destroyed
08:41:09 <edwardk> but i don't think you'll save much work
08:41:16 <kallisti> could you give an example?
08:41:29 <navaati> :t zipWithM
08:41:30 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
08:41:32 <quicksilver> edwardk: that doesn't sound very useful to me :)
08:42:03 * quicksilver designs a revolutionary but almost impossible puzzle game based on a 4D unit grid just to make edwardk feel useful.
08:42:05 <edwardk> quicksilver: it also has the benefit that you dont wind up with huge dictionaries getting passed in order to add two things
08:42:25 <kallisti> I'll try to implement this beast and see what happens
08:42:28 <navaati> quicksilver: that already exist, sorry
08:42:35 <edwardk> kallisti: tell foo >> return ()
08:42:55 <edwardk> kallisti: or use almost any applicative combinator, etc.
08:42:56 <quicksilver> navaati: not written in haskell.
08:43:07 <navaati> true
08:43:07 * hackagebot latex 0.1.0.1 - Parse, format and process LaTeX files  http://hackage.haskell.org/package/latex-0.1.0.1 (HenningThielemann)
08:43:13 <edwardk> and you blow away the knowledge that you had only cons'ed a single element
08:43:25 <edwardk> kallisti: thats why you'd need 3 constructors at least
08:43:28 <quicksilver> navaati: and (if you mean Miegakure) it's not released; show me the code or it didn't happen :)
08:43:36 <edwardk> kallisti: because then when you return you retain that fact
08:44:05 <edwardk> kallisti: ultimately, you can just use a difference list as the monoid though
08:44:12 <edwardk> kallisti: which removes the asymptotic benefit of doing this
08:46:58 <navaati> quicksilver: oh, i thought it was. i didn't even remember the name, actually, only that something like that existed
08:47:20 <edwardk> i'm still waiting for miegakure to get released. that should be a lot of fun
08:49:16 <newtrekemotion> So I'm trying to do something like http://hackage.haskell.org/packages/archive/haxr/3000.8.5/doc/html/Network-XmlRpc-Client.html
08:49:33 <newtrekemotion> But I don't have a URL for my server I have an IP
08:49:55 <newtrekemotion> And I keep getting back a bad URI user error
08:51:43 <newtrekemotion> Any thoughts?
08:53:35 <eacameron> why are haskell executables so huge! my 25-line program compiles to a 2.5 MB executable
08:53:57 <Scabdates> !topic
08:53:58 <ion> You can link dynamically if you want to.
08:54:07 <eacameron> ion: link to what
08:54:22 <ion> The Haskell runtime.
08:54:35 <eacameron> ion: how do you do that?
08:54:51 <navaati> -dynamic
08:54:52 <navaati> iirc
08:54:52 <Scabdates> i've got a set of code to delete an element at a given index of a list, pretty pedestrian, but this is my first time using haskell and i'm having trouble wrapping my brain around how it defines functions coming from a java programming background. any advice?
08:55:01 <newtrekemotion> http://hpaste.org/67489 Here is the code that I was referencing
08:55:15 <kallisti> edwardk: I'm missing what the problem is.
08:55:21 <eacameron> navaati: any reason to do dynamic linking besides smaller executables?
08:55:26 <kallisti> other than "tell forces you into a monoid" which makes sense.
08:55:49 <edwardk> kallisti: tell a >> return () -- forces you into the monoid, which means that you'll get almost 0 use out of the extra constructor
08:55:50 <navaati> eacameron: not having the rts copied 500 times on your disk
08:56:05 <edwardk> because the moment you do _anything_ it'll devolve to the monoid constructor
08:56:06 <ion> And in your memory if you run multiple programs all of which use the same runtime version.
08:56:07 <navaati> it's the usual argument over shared libs…
08:56:21 <eacameron> navaati: any performance reasons?
08:56:23 <kallisti> edwardk: unless you have a second typeclass, which implements the equivalent of log = tell . unit in terms of the monad
08:56:50 <navaati> eacameron: no, it's purely aesthetic
08:56:51 <edwardk> kallisti: but the concern is that rarely to i have a program that consists. solely of 'tell' ;)
08:57:13 <kallisti> well the use case for this is that you have repeated calls of log"
08:57:15 <kallisti> and tell if you want
08:57:16 <navaati> eacameron: hum, well, yeah, as ion said, there is RAM consumption
08:57:28 <eacameron> navaati: ahh ok...and the default build is obviously more portable
08:57:41 <navaati> yes
08:57:42 <pqmodn> eacameron: dynamic linking has a cost at runtime (the linker needs to resolve all the symbols)
08:57:45 <edwardk> kallisti: so in the meantime you won't be using any other combinators? no >>'s no do blocks where you bind variables?
08:57:53 <edwardk> kallisti: i find that highly implausible
08:57:54 <kallisti> of course
08:57:59 <kallisti> of course you would use those.
08:58:04 <Younder> Typeclass in Inabelle and typeclass in Haskell and Coq seem identical. Is this a mathematical imperative?
08:58:04 <eacameron> pqmodn: is it a start-up cost or a constant running cost?
08:58:10 <navaati> pqmodn: yeah but it only happens at program loading time, not really runtime
08:58:19 <edwardk> kallisti: well, the moment you do that your singleton value in the extra constructor gets forced into the monoid
08:58:24 <navaati> start-up cost
08:58:25 <kallisti> the assumption here is that w `mappend` mempty is going to be retty fast
08:58:33 <pqmodn> eacameron: it may be both actually, google around for "dynamic static linking performance". certainly a startup cost though
08:59:07 <eacameron> pqmodn: hmm...and it's likely that the linking cost is higher than the memory loading cost...
08:59:17 <edwardk> kallisti: but now tell >> (big monoidal action) is fast but tell >> return 1234 >> (big monoidal action) can be ridiculously expensive
08:59:31 <ppilate> What does "qualified" mean in "import qualified Data.Text as T"?
08:59:33 <edwardk> kallisti: hence why i'm saying you need a third case
08:59:34 <pqmodn> eacameron: there's no memory savings. both approaches load the libraries into memory once and share pages across processes
08:59:49 <edwardk> kallisti: so that you can fuse those with the singleton constructors without cost
08:59:58 <eacameron> pqmodn: ahh, they BOTH share the memory. good to know
09:00:00 <pqmodn> eacameron: i think the biggest advantage for dynamic linking is probably disk space
09:00:03 <navaati> pqmodn: sharing with static linking ? i don't think so…
09:00:07 <dmwit> ppilate: It means "don't define unqualified names".
09:00:13 <pqmodn> navaati: let me get a link, one sec
09:00:18 <edwardk> but like i said, you can get the cheap asymptotics just by changing the monoid to an endomorphism over the type you are interested in rather than that tye
09:00:19 <edwardk> er type
09:00:30 <ion> ppilate: Data.Text’s exports don’t get imported to your module’s namespace, only under “T”.
09:00:33 <edwardk> so this whole thing is an exercise in overengineering
09:00:45 <navaati> pqmodn: if it's the case, well, nice !
09:00:51 <dmwit> ppilate: see http://stackoverflow.com/questions/8327032/write-this-scala-matrix-multiplication-in-haskell/8331995#8331995
09:01:07 <dmwit> The first section is my understanding of how imports work.
09:02:03 <pqmodn> navaati, eacameron: there's also the argument that fixing a shared librarie fixes all the programs using it, but some say that doesn't work out in practice. of course statically linked programs must be recompiled to take advantage of fixed is the linked library
09:02:16 <typoclass> ppilate: with "import Data.Text" you can use its function "pack". with "import Data.Text as T" you can use "pack" or "T.pack" (both mean the same function). with "import qualified Data.Text as T", you can use only "T.pack" (but not "pack")
09:02:43 <navaati> pqmodn: why wouldn't that work out ?
09:02:53 <kallisti> edwardk: ah I see
09:03:03 <ppilate> typoclass: I see, thanks
09:03:08 <kallisti> big monoidal action could be doing many small snocs
09:03:14 <kallisti> but the >> still forces mappend
09:03:18 <edwardk> yep
09:03:19 <pqmodn> navaati: i'm not sure, it may be changes to libraries are often bigger than a simple fix and cause breakage?
09:03:47 <edwardk> kallisti: in practice just work with Writer (Endo m) instead of Writer m
09:03:49 <typoclass> ppilate: you're welcome
09:03:53 <quicksilver> pqmodn: did you just say that static libraries share memory? not generally, no.
09:04:05 <kallisti> edwardk: are there absolutely no circumstances where Reducer is a better choice?
09:04:10 <navaati> maybe. anyway, shared libs are More Elegant ™
09:04:13 <quicksilver> pqmodn: maybe with clever page deduping that some OSes have - but that conflicts with smart linking
09:04:29 <quicksilver> and I would say that most systems which use static linking use smart linking.
09:04:48 <edwardk> kallisti: none that i can think of, you _might_ be able to get some benefit out of it if you used the listen/censor/pass plumbing a lot, but meh
09:05:50 <pqmodn> quicksilver: perhaps i misunderstood this (or it's wrong) http://harmful.cat-v.org/software/dynamic-linking/
09:06:33 <pqmodn> i'm not sure if he's saying re-running the *same* program shares pages (of course) or something else
09:07:10 <kallisti> edwardk: well I guess my quest for good ideas continues. :P
09:07:23 <quicksilver> pqmodn: he's just saying that, as far as I know.
09:07:38 <quicksilver> pqmodn: it's of course true that the *entire* C library isn't shared, as long as you use smart linking.
09:08:00 <quicksilver> it's certainly true that dynamic linking is a bucket of eels
09:08:07 <quicksilver> and that people misunderstand both the pros and cons.
09:09:34 <pqmodn> quicksilver: do two separate programs, one statically linked to printf and another statically linked to printf + gets, share printf? it seems unlikely, but i thought that was his claim
09:10:06 <pqmodn> i guess you're right, the OS would need to do quite a bit of work for that to happen
09:10:43 <quicksilver> pqmodn: they do not.
09:10:48 <quicksilver> pqmodn: and I don't think that is his claim
09:10:57 <pqmodn> quicksilver: ah
09:11:02 <quicksilver> pqmodn: I think his claim is that two separate instances of that process
09:11:14 <quicksilver> either fork()ed or independently exec() - it does not matter which
09:11:17 <quicksilver> will share it.
09:11:38 <pqmodn> quicksilver: hmm, that claim is less impressive :)
09:11:44 <pqmodn> but i think you're right, i misread it
09:12:21 <quicksilver> people in general ignored his arguments, since Linux and *BSD and OSX all have a dynamic libc :)
09:12:26 <quicksilver> but the argument is certainly complicated.
09:13:08 * hackagebot bibtex 0.1 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.1 (HenningThielemann)
09:13:12 <tromp> is there a pragma that implies {-# INLINE foo #-} for every toplevel function foo defined in a source file?
09:14:45 <ppilate> How do I "exit" the module I've `import'ed in GHCi?
09:14:49 <quicksilver> don't think so tromp
09:14:58 <quicksilver> although there may be flags to tweak the inliner at compile time
09:15:24 <fmap> ppilate: :m -Module
09:15:46 <ppilate> thanks fmap
09:17:57 <ppilate> http://hpaste.org/67490 can someone please explain to me, why the latter code doesn't work, whilst the former does?
09:18:32 <ppilate> oh, sorry, I think I forgot to pinch in a `return' there
09:18:37 <ppilate> Hm, no, still no luck
09:21:21 <sm> gwern: that's a darn impressive site you've built up there (http://gwern.net)
09:21:28 <quicksilver> ppilate: the first works?
09:21:39 <quicksilver> ppilate: then "irew" is no monadic, so you shouldn't feed it to >>=
09:21:44 <quicksilver> ppilate: "ireq"
09:22:07 <sm> gwern: I especiialy like the catchy summary in left margin
09:22:46 <quicksilver> ppilate: also T.reverse isn't monadic so you shouldn't feed *into* it with >>=
09:23:04 <ppilate> quicksilver: yeah i've updated it: http://fpaste.org/RUgK/
09:23:05 <gwern> sm: thanks
09:23:07 <ppilate> still doesn't work tho
09:23:16 <quicksilver> ppilate: >>= expects something of type (m a) on the left and something of type (a -> m b) on the right
09:23:37 <quicksilver> ppilate: are we allowed to know what the error is?
09:23:45 <quicksilver> ppilate: or are you keeping that secret so it's more interesting for us to guess?
09:23:51 <gwern> sm: there's a lot of little touches I'm proud of - did you notice the floating footnotes or how inline quotes are shaded?
09:26:24 <phaer> From time to time i run in to conflicts installing a package using cabal-install because another package installed another version of a dependency. Are there general solutions/workarounds for this?
09:26:55 <troutwine> phaer: http://hackage.haskell.org/package/cabal-dev-0.9.1
09:27:52 <hpaste_> kallisti pasted “beautiful code” at http://hpaste.org/67491
09:27:56 <kallisti> edwardk: ^
09:28:04 <sm> gwern: I hadn't noticed the floating footnotes yet. I went there to check out the quote shading (from hakyll list) (had to squint pretty hard to see it on this monitor)
09:28:09 <phaer> troutwine: Exactly what i was looking for. thanks.
09:28:21 <troutwine> phaer: No problem.
09:28:25 <kallisti> edwardk: I borrowed as much as I could from the style of mtl, and then completely ruined it with pointfree everywhere
09:28:30 <bitonic> ppilate: the $ and >>= probably don't play well together.
09:28:50 <edwardk> kallisti: devil's advocate: type Fastener w = Writer (Endo w)
09:28:54 <bitonic> ppilate: but paste the error as quicksilver said
09:28:57 <quicksilver> good point bitonic
09:29:03 <ppilate> bitonic, quicksilver: sorry, i have some troubles running the build atm
09:29:06 <kallisti> edwardk: that's not the same thing though. :P
09:29:08 <sm> gwern: your site page explains why no obviously blog-like section. What does the site feed show - page creations or.. ?
09:29:23 <gwern> sm: revisions
09:29:26 <edwardk> kallisti: its not, but you can use the cons from the reducer to build your endomorphism
09:29:34 <edwardk> kallisti: and you bypass the extra constructors
09:29:45 <sm> ah. What do you mean by floating footnotes anyhow ?
09:30:13 <kallisti> edwardk: the extra constructors won't really be apparent to anyone actually using this code.
09:30:50 <kallisti> but yeah Endo would work nicely.
09:30:52 <edwardk> consM :: (Reducer e w, MonadWriter w m) => e -> m (); consM e = tell (Endo (cons e))
09:31:03 <edwardk> done
09:31:05 <edwardk> no drama ;)
09:31:17 <edwardk> er
09:31:21 <edwardk> MonadWriter (Endo w) m
09:31:35 <kallisti> edwardk: it would be nice if you could both cons and snoc via 2 different combinators
09:31:38 <kallisti> rather than picking one or the other
09:31:49 <glguy> What's the story with parsec3 and parsec-3? Which one is intended to be used by new packages?
09:31:53 <edwardk> there you run into a bit of a problem
09:32:12 <edwardk> glguy: parsec-3
09:32:14 <ppilate> bitonic, quicksilver: i actually just replaced 'return $ ...' with 'return ( ... )' and it worked
09:32:14 <kallisti> all problems are solvable by adding more constructors. :P
09:32:15 <ppilate> thanks :)
09:32:16 <edwardk> parsec3 was a dumb idea
09:32:19 <bitonic> glguy: parsec
09:32:27 <bitonic> edwardk++
09:32:29 <bobfang> say if we have a function bits::Int bits= 10 how can I write a function to change its value
09:32:40 <bitonic> bobfang: you can't change its value.
09:32:48 <bitonic> also, bits :: Int is not a function.
09:32:58 <bobfang> ok...
09:33:00 <kallisti> newtype Fastener c w a = Fastener { runFastener :: (a, Maybe (Either (Either c c) w)) }   -- edwardk: what's the problem?
09:33:21 <bitonic> bobfang: if you're new to Haskell, I just want to tell you that there are great reasons for that :)
09:33:32 <bitonic> (the fact that you can't change values)
09:33:38 <edwardk> kallisti: well beside how many extra bottoms you've got there? there isn't any real rhyme or reason to the constructors involved
09:33:58 <bobfang> so how can I have such a thing that to change a value?
09:34:12 <kallisti> bobfang: what are you trying to do? or are you simply curious?
09:34:15 <kallisti> there are multiple ways.
09:34:21 <edwardk> kallisti: also why bother saying whether to snoc or cons the element?
09:34:21 <bobfang> I want to do it
09:34:31 <bitonic> bobfang: I'm not sure what you're asking. Haskell restricts mutability at the type level
09:34:34 <edwardk> kallisti: just use the appropriate operation when you have a monoid being joined with a singleton
09:34:39 <bitonic> bobfang: you want to do what?
09:34:46 <rwbarton> values can't change, that is like saying "how do I change the value 3"
09:35:03 <kallisti> edwardk: it may be possible with some clever typeclass methods
09:35:10 <kallisti> to skip the extra constructor
09:35:13 <byorgey> bobfang: in Haskell you never mutate values.  Instead, you use functions that take an old value and return a new value.
09:35:46 <kallisti> bobfang: so you're just curious then? you have no particular problem domain?
09:35:47 <bobfang> I am trying to write an caculator
09:35:48 <byorgey> bobfang: so instead of having a variable that you mutate, you e.g. pass a value as a parameter to a function, then every time you want to "change" it you can call the function again with a different value.
09:36:03 <bitonic> @where LYAH
09:36:03 <lambdabot> http://www.learnyouahaskell.com/
09:36:03 <edwardk> anyways, the benefit of the 3 constructor version is that you can snoc or cons appropriately, for the few monoids that don't care about direction (e.g. are fingertree based), but for anything less the difference list version should work fine
09:36:10 <bitonic> bobfang: ^^^ is a good introduction to Haskell
09:36:29 <kallisti> bobfang: you likely don't need to mutate a variable.
09:36:40 <bobfang> mainc::IO()
09:36:40 <bobfang> mainc  = do
09:36:42 <bobfang>          putStrLn "Hello,Welcome to Calc"
09:36:43 <bobfang>          procedure
09:36:45 <bobfang>          where procedure=do
09:36:46 <bobfang>                          putStr "Input:"
09:36:48 <bobfang>                          a<-getLine
09:36:49 <bobfang>                          if a /= "q"
09:36:51 <bobfang>                          then putStrLn (calc a)>>procedure
09:36:52 <bobfang>                          else
09:36:54 <bobfang>                               putStrLn "Exiting"
09:36:55 <bobfang> bits::Int
09:36:55 <bitonic> ehe.
09:36:55 --- mode: ChanServ set +o glguy
09:36:56 <bobfang> bits = 10
09:36:57 <bobfang> Thats the outline
09:37:01 --- kick: bobfang was kicked by glguy (Your behavior is not conducive to the desired environment.)
09:37:16 <typoclass> glguy: you only kicked him after he was finished
09:37:24 <bitonic> byorgey: well, maybe he's new to IRC...
09:37:25 <glguy> I'm only human
09:37:37 <rwbarton> though what he pasted doesn't even look relevant to the question
09:38:02 <byorgey> glguy: that's quite harsh.
09:38:09 * hackagebot shelly 0.5.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.5.0 (GregWeber)
09:38:12 <byorgey> I'd rather give him the benefit of the doubt and explain not to paste in IRC first.
09:38:18 <bitonic> byorgey++
09:38:25 <kallisti> edwardk: I may actually flesh this thing out further, since it might be marginally useful to someone.
09:38:37 <glguy> byorgey: no, it was extremely reasonable. I was just attempting to stop the flood
09:38:37 <edwardk> knock yourself out ;)
09:38:39 <glguy> He isn't banned
09:38:49 --- mode: glguy set -o glguy
09:39:00 <sm> +1, please don't kick too fast
09:39:04 <byorgey> well, you could have at least used a more explanatory kick message
09:39:07 <typoclass> glguy: i don't feel you were reasonable. you gave no warning to someone who clearly is a newbie
09:39:29 <copumpkin> calm down, it was clearly not a punitive kick but one where he assumed the paste wasn't over yet
09:39:32 <glguy> the point is his client was stuck on flood, kicking him flushes that
09:39:43 <copumpkin> in retrospect, the paste was over
09:39:47 <bitonic> glguy: actually he was done :P
09:39:49 <glguy> anyone confused about how this works can join #haskell-ops if they have more questions
09:39:51 <byorgey> yes, I understand that.  But the question is whether bobfang will understand the difference.
09:39:56 <dmwit> Perhaps further complaints about the kick should go to #haskell-ops?
09:40:05 <byorgey> ok.
09:41:45 <bobfang> Sorry for the trouble
09:42:09 <bobfang> I just need a integer to specify how many bits I want to print out
09:42:12 <typoclass> bobfang: sorry for kicking you. please use hpaste if you want to paste code
09:42:14 <typoclass> @where hpaste
09:42:14 <lambdabot> http://hpaste.org/
09:43:01 <Axman6> bobfang: we need more context than that, what are you trying to do?
09:43:12 <hpaste_> Bob pasted “Calc” at http://hpaste.org/67492
09:43:28 <byorgey> bobfang: you can use that definition of bits if the value of bits will never change.  But if it should be possible to change it using a "global variable" like that will not work.
09:43:54 <bobfang> so what should I do?
09:43:55 <byorgey> bobfang: instead you need to pass the current value of bits as a parameter to 'procedure' or something
09:44:11 <byorgey> that way when procedure calls itself recursively it can (optionally) pass a different value of bits
09:44:57 <bobfang> I don't quite understand
09:45:08 <bobfang> how do you optionally pass a value?
09:45:20 <bitonic> byorgey: if you're new to functional programming, things will be much clearer if you read an introduction to Haskell first, even if brief
09:45:27 <copumpkin> lol
09:45:37 <bitonic> sorry, bobfang :P
09:45:38 <copumpkin> yeah byorgey, if you want I can explain how to write fibonacci
09:45:39 <byorgey> bobfang: sorry, I meant it will always pass a value, and optionally the value can change
09:45:51 <bitonic> (but byorgey if you need an introduction to Haskell I can provide you with one!)
09:46:02 <byorgey> hehehe
09:46:12 <bobfang> ok I will try... Thanks guys
09:46:26 <bitonic> bobfang: again, LYAH is the best introductory text, imo
09:46:29 <bitonic> @where LYAH
09:46:29 <lambdabot> http://www.learnyouahaskell.com/
09:46:52 <bobfang> I've read that, But I need some practice I think
09:47:24 <bitonic> bobfang: well I'm pretty sure they spend some time explaining immutability :)
09:47:51 <byorgey> copumpkin: can you explain how to write a fast version of fibonacci in Agda along with a proof that it gives the same result as the naive version? =)
09:48:17 <copumpkin> byorgey: I actually wrote something like that a while back, but it's on my other computer :)
09:48:23 <byorgey> hehe =)
09:48:24 <copumpkin> I think glguy might have done it too, though
09:48:50 <copumpkin> I vaguely remember him doing something like that, but I have been known to be wrong
09:48:51 <glguy> I think i have it online
09:48:52 <copumpkin> …one
09:48:54 <copumpkin> time
09:48:55 <bobfang> Can you have where in where?
09:49:07 <bobfang> Am I clear?
09:49:15 <rwbarton> you can have where in a declaration in a where
09:49:33 <Maksim> Кто играет mix в кс без стима
09:49:35 <rwbarton> which is a yes, I guess
09:50:04 <glguy> http://www.galois.com/~emertens/fibencode/Fib.html -- Implements fib in an efficient way and shows that it behaves like the naive implementation
09:50:04 <bobfang> thanks
09:50:17 <Maksim>  Кто играет в контерстрайк
09:50:22 <glguy> "efficient"
09:50:31 <typoclass> maksim, please stick to english in this channel
09:50:32 <Maksim> Кто   русский
09:50:50 <copumpkin> this is not counterstrike
09:50:51 <Maksim> whats
09:50:55 <glguy> Maksim: this is an English speaking channel, please consult "/msg alis list #haskell-*" for other languages
09:51:08 <copumpkin> Maksim: Никто не говорит на русском языке здесь
09:51:24 <copumpkin> Maksim: Мы не играем контрудар, либо
09:51:39 <Elemir> Хм
09:51:42 <Elemir> Argh
09:52:07 <Maksim> не понял
09:52:19 <Maksim> контер-страйк
09:52:31 <Axman6> is there a #haskell.ru?
09:52:36 <rwbarton> this seems off-topic for multiple reasons
09:52:46 <Elemir> Axman6: gentoo-haskell ;3
09:52:55 <Axman6> o.O
09:53:09 <copumpkin> he's interested in counterstrike
09:53:16 <Maksim> БЛИН кто играет контер-страйк
09:53:18 <hpaste_> Bob pasted “Calc” at http://hpaste.org/67493
09:53:20 <copumpkin> was trying (with google translate) to explain to him that this isn't the place
09:53:27 <bobfang> I modified it
09:53:40 <Elemir> He's troll
09:53:43 <Philippa> urgh, campersnipe. So not worth it if you have anything else to do in your life
09:53:44 <bobfang> But the compiler complained
09:53:54 <bobfang> What should I do?
09:54:07 <kamatsu> bobfang, how did it complain
09:54:22 <Maksim> who plays a mix to whom is necessary +1
09:54:23 <bobfang> Calc.hs:16:38: parse error on input `='
09:54:30 <kamatsu> paste your code
09:54:35 <kamatsu> (in hpaste)
09:54:40 <bobfang> http://hpaste.org/67493
09:54:41 <rwbarton> he did
09:54:56 <navaati> gwern: great article about silkroad :)
09:55:04 <kamatsu> oh
09:55:45 <kamatsu> hm
09:55:49 <kamatsu> what are you trying to do here?
09:55:53 <kamatsu> p = 10?
09:56:08 <Axman6> also then p = read (tail a)
09:56:13 <Axman6> makes no sense
09:56:19 <Axman6> (in haskell)
09:56:35 <bobfang> I need to specify the number of bits I want to print out
09:58:05 <rwbarton> well there are a lot of issues here
09:58:16 <rwbarton> I suggest leaving mainc aside entirely until calc does what you want
09:58:18 <rwbarton> use ghci to test it
09:58:26 <kallisti> augh circular dependencies.
10:01:46 <hayashi> Are there any base functions for repeatedly applying a function to its own input until it reaches a fixed point?  Or, more simply, deleting every occurrence of an item from a list
10:01:55 <hayashi> maybe I should stop being lazy and write one myself >_>
10:02:00 <rwbarton> @type showCReal
10:02:01 <lambdabot> Int -> CReal -> String
10:02:10 <otters> hayashi: fix?
10:02:11 <copumpkin> hayashi: I don't know of any, although I have written one before
10:02:16 <ppseafield> hayashi: filter (/= notThis) xs
10:02:24 <Axman6> hayashi: iterate?
10:02:27 <copumpkin> no
10:02:31 <Axman6> iterate and filter
10:02:36 <copumpkin> no
10:02:47 <otters> recursion
10:02:50 <Axman6> uh, right, finding the fixed point
10:03:07 <rwbarton> I don't really understand "more simply" in your question
10:03:15 <copumpkin> you need adjacent values
10:03:16 <rwbarton> but "no" and "filter" seem like the right answers
10:03:24 <copumpkin> lol
10:03:42 <rwbarton> am i missing something
10:03:45 <hayashi> filter is actually what I want, lol.  Badly worded question on my part anyway
10:03:54 <copumpkin> you'll want an ap zip in there, and then to pull out the value where adjacent elements are equal
10:04:12 <copumpkin> those two questions seem completley unrelated, but if you says so :P
10:04:13 <copumpkin> -s
10:04:19 <rwbarton> maybe he plans to write filter by repeatedly applying the "remove first occurrence of x" function
10:04:25 <Axman6> > let f g x = let x' = g x in if x == x' then x else f g x'
10:04:26 <lambdabot>   not an expression: `let f g x = let x' = g x in if x == x' then x else f g ...
10:04:32 <hayashi> What rwbarton said >_>
10:04:46 <otters> Axman6: isn't that just fix
10:04:50 <copumpkin> no
10:04:52 <copumpkin> :t fix
10:04:53 <lambdabot> forall a. (a -> a) -> a
10:04:53 <Axman6> > let f g x = let x' = g x in if x == x' then x else f g x' in f (`div` 2) 10
10:04:54 <lambdabot>   0
10:04:55 <sm> gwern: ah! I see what you mean. Floating footnotes. :)
10:05:08 <copumpkin> fix doesn't take a starting value
10:05:13 <Axman6> > fix (`div` 2) 10
10:05:14 <lambdabot>   No instance for (GHC.Real.Integral (t -> a))
10:05:14 <lambdabot>    arising from a use of `e_12...
10:05:23 <Axman6> bleh, right
10:05:28 <hayashi> I forgot completely about filter and decided in a fit of badly optimised silliness to repeatedly spin delete until it didn't delete anything.
10:05:37 <copumpkin> :)
10:05:52 <hayashi> Nothing like worst case O(n²)
10:06:05 <hayashi> on an O(n) problem
10:06:17 <Axman6> hayashi: anything wrong with the code i put earlier?
10:06:51 <hayashi> No idea, because what I really wanted all along was just filter >_<
10:08:10 <rwbarton> the Prelude is wise
10:08:25 <barrucadu> Trust in the Prelude
10:09:21 <rwbarton> not so much for having filter as for not having your other function ;)
10:09:45 <copumpkin> well, having that other fix function can be handy
10:09:48 <copumpkin> but yeah, not for this :P
10:10:18 <kallisti> ha, I think I need to draw a graph of my inter-module dependencies on paper. :P
10:14:04 <c_wraith> GHC enforces that it remains acyclic, anyway
10:15:20 <bitonic> you *can* have cyclic dependencies with some fiddling
10:16:09 <bitonic> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
10:16:48 <bitonic> but nobody does that :P
10:16:54 <c_wraith> bitonic: that's not really cyclic dependencies.  That's just splitting a source file apart.
10:17:10 <c_wraith> bitonic: you don't really get proper module boundaries between them
10:18:16 <bitonic> c_wraith: right, it's still interesting that that feature exists
10:19:27 <c_wraith> Interesting.  It's closer to being a proper module boundary than I thought..  But it also requires more programmer work than I thought.  Yeah, that's a good feature to not use.
10:19:42 <thoughtpolice> edwardk: just a heads up, GHC HEAD now does support abstraction/quantification over kinds w/ PolyKinds enabled
10:19:50 <edwardk> thoughtpolice: YES!
10:19:52 <thoughtpolice> edwardk: gogogo! do awesome stuff!
10:20:12 <tibbe> Is there any way to write: f :: C a => [a] -> …, that works with heterogenus list, without providing an existential wrapper?
10:20:19 <tibbe> e.g. using a wellplaced forall
10:20:26 <edwardk> thoughtpolice: time for me to bump my local install to head again
10:20:53 <c_wraith> tibbe: nope. instance witnesses are only stored in existentials
10:20:58 <tibbe> :/
10:21:06 <tibbe> I wish GHC could create one for mel
10:21:08 <tibbe> me*
10:21:23 <tibbe> f :: C a => [forall. a] -> ...
10:21:26 <tibbe> or perhaps
10:21:37 <tibbe> f :: [forall a. C a => a] -> ...
10:21:51 <Saizan> with ConstraintKinds we can have a generic existential wrapper though
10:21:51 <thoughtpolice> edwardk: i saw some commits fly by cvs-ghc the other night mentioning kind abstraction so i built a copy of HEAD last night and tried it out. at least, 'data D1 :: k -> *' now works :)
10:22:03 <Saizan> tibbe: that means something else
10:22:17 <c_wraith> yeah, that's rank-2 types, not existential
10:22:26 <c_wraith> well, Rank-N, in general
10:22:26 <edwardk> thoughtpolice: now i need to try out the shiny new category stuff
10:22:40 <tibbe> dont we abuse forall to mean thereis in data declarations?
10:22:53 <copumpkin> not really an abuse
10:22:59 <copumpkin> it's just looking at the existential from the other side
10:23:00 <c_wraith> sort of verging on abuse
10:23:07 <Cale> tibbe: It's placed on the outside of the constructor
10:23:07 <edwardk> tibbe: its not an abuse if you look at it from the perspective of the constructor
10:23:15 <tibbe> hmm
10:23:28 <Cale> For all x, there is a constructor C with a parameter of type x
10:23:32 <copumpkin> if you have an existential payload, your constructor is universal
10:24:05 <Cale> Or, look at it in GADT syntax :)
10:24:32 <Cale> data T where C :: forall a. (...) => a -> T
10:24:55 <Cale> that's also definitely a forall :)
10:25:58 <slack1256> is there any roadmap for hackage 2?
10:26:12 <slack1256> i'm hoping to see stats of packages
10:26:35 <Axman6> i'm hoping to see (enforced) changelogs
10:27:14 <edwardk> slack1256: cmccann has been fiddling with it, so have some other folks, but i'm not aware of a formal roadmap
10:27:22 <c_wraith> slack1256: It's currently in the state "needs polishing, and no one is really doing the work needed."
10:27:38 <c_wraith> Lots of people start to look at it, then go "there's still too much to do"
10:27:56 <alpounet> http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0 gathers some info about it
10:29:26 <parcs`> any gsoc people working on hackage 2?
10:29:39 <edwardk> not this year
10:29:50 * Axman6 puts a challenge to Michael Snoyman: I bet you can't write a better hackage in yesod with features X Y and Z
10:31:29 <slack1256> Axman6 might get hackabala
10:35:37 <slack1256> what is the closest that i can get to "erlang-like process" in haskell
10:35:48 <slack1256> haskell-mpi? or there is anything more "cool"
10:35:58 <alpounet> parcs`, there are a few proposals that will help Hackage2 indirectly though
10:35:58 <donri> @hackage remote
10:35:59 <lambdabot> http://hackage.haskell.org/package/remote
10:36:24 <donri> ^ "cloud haskell" in erlang style
10:37:04 <slack1256> great, thanks dori
11:05:52 <lysgaard> I have a cabal package I've not updated in a while. Now it complains that both base and haskall-98 includes the Prelude module, and there fore throws an ambigious error. How do I hide one of theese preludes?
11:06:25 <Clint> lysgaard: remove haskell98
11:07:47 <lysgaard> Clint: Is it depreceated? My library complains that it misses some modules when I remove them.
11:08:19 <byorgey> lysgaard: you probably just need to update the names of the modules to correspond to the new hierarchical standard names.
11:08:22 <byorgey> e.g.  List --> Data.List
11:08:42 <byorgey> lysgaard: haskell98 and base now provide incompatible versions of the Prelude so you have to choose one or the other.
11:09:09 <byorgey> it used to be that if you wanted to write a Haskell 98 program you imported both base and haskell98; now you would just import haskell98.
11:09:26 <byorgey> but if you want to stick to a standard you're probably better off going with Haskell 2010 at this point.
11:10:20 <lysgaard> byorgey: Yeah, I want to be "future compatible" not algging behind. So what package should i depend on to support Haskell 2010
11:10:28 <byorgey> lysgaard: base.
11:11:00 <byorgey> lysgaard: well, I guess if you want exactly Haskell 2010 you can depend on haskell2010 instead of base.
11:11:36 <lysgaard> byorgey: I'll take base if it's the most fluid one of the lot.
11:11:47 <byorgey> yep
11:13:57 <nand`> implementing a non-optimized mandelbrot function; I want to check if the function diverges to infinity within n applications given input C; is there a better way than: not . null . filter (>2) . take n $ iterate (mandel c) 0
11:14:22 <nand`> well; I could do it “in-place” using tail recursion but I want to see if there's a more “elegant” way
11:17:20 <byorgey> nand`: what's inelegant about that?
11:17:30 <byorgey> that looks lovely to me
11:17:42 <nand`> byorgey: I don't really like the idea of passing around a list for when I really only need to count the number of applications
11:17:59 <byorgey> it uses lazy evaluation to elegantly express the policy of evaluating at most n iterations, but stopping early as soon as you find one greater than 2
11:18:05 <nand`> but I guess it's all fine since “filter” should completely dispose of unwanted list entries; right?
11:18:06 <RichyB> nand`, GHC might be able to deforest that.
11:18:16 <nand`> as in, they won't be stuck in memory
11:18:24 <byorgey> nand`: right.
11:18:27 <RichyB> Yep.
11:18:51 <nand`> alright; then I'm happy
11:19:14 <RichyB> Also, GHC is not bad at deforesting functions that look like compositions of maps and folds.
11:19:27 <byorgey> it will run in a constant amount of memory, and in practice it may even compile down to a tight loop without any list cells being allocated at all.
11:19:50 <RichyB> nand`, if you want to rice it up, you could install ghc-core and examine the intermediate code that GHC produces.
11:20:05 <nand`> that would be an interesting experiment
11:20:36 <RichyB> Hell, now that cabal-install makes it so easy, I would recommend installing ghc-core anyway.
11:20:46 <RichyB> The results are pretty! Colours everywhere. :)
11:21:15 <nand`> No cabal-install for me; `emerge ghc-core` :)
11:21:22 <RichyB> Win.
11:21:33 <RichyB> But yeah, what byorgey is talking about deforestation, where GHC figures out that it can get rid of the intermediate lists and do the whole thing in-place.
11:22:38 <c_wraith> If only GHC could actually figure that out.  But list fusion is actually part of the list libraries involving rewrite rules. GHC actually isn't doing general-purpose deforestation. Just applying the rewrite rules from Data.List
11:26:53 <parcs`> does stream-fusion still provide a benefit over the standard Data.List?
11:28:13 * hackagebot representable-functors 2.4 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.4 (EdwardKmett)
11:28:16 * hackagebot language-javascript 0.5.3 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.3 (AlanZimmerman)
11:30:11 <lysgaard> Anyone know the state of this project for fixing the cabal dependency clutter, did it just fizz? http://skilpat.tumblr.com/post/9411500320/a-modular-package-language-for-haskell
11:30:56 <frerich_> Is anybody aware of projects which use some Haskell-based DSL to describe web applications, and "running" those applications then generates PHP or JavaScript?
11:33:15 * hackagebot representable-tries 2.4 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.4 (EdwardKmett)
11:33:51 <byorgey> lysgaard: I doubt it, but it may be a while before we actually see any concrete fruit from that project
11:39:59 <hpaste_> WraithM pasted “xmobar with libmpd problems” at http://hpaste.org/67497
11:43:09 <WraithM> I've been having a bunch of problems with xmobar. I'm on gentoo. I've been seeing a few problems related to gentoo and xmobar from my google searches. I assume I just have a dependency problem.
11:43:16 * hackagebot kan-extensions 2.4 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.4 (EdwardKmett)
11:43:22 <kallisti> @hoogle MonadBaseControl
11:43:23 <lambdabot> No results found
11:43:58 <dmwit> WraithM: Have you tried xmobar from darcs?
11:44:05 <WraithM> No.
11:44:27 <WraithM> Should I give that a try?
11:44:30 <nand`> I have libmpd problems with xmobar
11:44:35 <nand`> also on gentoo
11:44:42 <nand`> but I'm using the darcs version
11:44:45 <dmwit> I don't know, but a problem with compiling is likely to be fixed quickly.
11:45:36 <WraithM> I don't really know what darcs is other than a distribution system.
11:45:50 <WraithM> Is there a good place to look up how to install from darcs?
11:46:10 <nand`> WraithM: in gentoo just emerge =xmobar-9999
11:46:22 <WraithM> Thanks
11:46:26 <nand`> you'll need the gentoo-haskell overlay; for more information #gentoo or #Gentoo-Haskell
11:48:16 * hackagebot adjunctions 2.4 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.4 (EdwardKmett)
11:48:37 <dmwit> It seems to be git and not darcs, anyway.
11:48:58 <dmwit> Hackage tells you how to get it: git clone git://github.com/jaor/xmobar.git
11:49:05 <WraithM> Oh, I have tried git
11:49:15 <t7> can a type arguement in a scheme have a kind other than *
11:49:25 <t7> i asked this ages ago but i forgot the answer
11:49:42 <dmwit> yes
11:49:50 <dmwit> :t fmap
11:49:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:53:18 * hackagebot trifecta 0.50.2.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.50.2.1 (EdwardKmett)
11:56:18 <frerich_> Hm, that reminds me: I looked at trifecta a while ago and there's a small example parser at https://github.com/ekmett/trifecta/blob/master/examples/RFC2616.hs - it has a <$!> function which made me wonder - isn't it exactly the same as fmap?
11:56:28 <frerich_> I wonder why that function is needed.
11:56:50 <edwardk> frerich_: $ is to <$> what $! is to <$!>
11:57:02 <dmwit> frerich_: It has a different type, and it's a bit stricter.
11:57:08 <edwardk> <$!> forces the content
11:57:25 <edwardk> this is why it needs the monad not just the functor
11:59:19 <edwardk> as example parsers go that one isn't very compelling, i just wanted a parser that had already been implemented in parsec/attoparsec for benchmark purposes
12:12:16 <EvanR> the answer is blowin in the wind
12:16:47 <lysgaard> Can cabal-dev do the sdist command?
12:18:17 * hackagebot hackager 1.0.0 - Hackage testing tool  http://hackage.haskell.org/package/hackager-1.0.0 (DavidTerei)
12:20:22 <lysgaard> the reason I'm asking is that cabal-dev sdist fails, even though the package configures, builds and installs fine.
12:20:30 <Dodek> what's the name of a package that will let me execute other programs, like system() in C?
12:21:10 <dmwit> ?hackage process
12:21:10 <lambdabot> http://hackage.haskell.org/package/process
12:21:20 <dmwit> Dodek:
12:21:21 <Dodek> dmwit: thank you
12:27:24 <hpaste_> edwardk pasted “quaternions for malc” at http://hpaste.org/67500
12:32:06 <hpaste_> “Joey Adams” pasted “GSoC 2012 accepted students for Haskell” at http://hpaste.org/67502
12:32:38 <JoeyA> The GSoC server is getting a lot of 500s.  Here's a mirror of the accepted students for Haskell.
12:35:22 <dmwit> Wait, shapr is a GSoC student?
12:35:29 <dmwit> Isn't he like... ancient?
12:35:36 <c_wraith> He's a student
12:35:45 <dmwit> Well, alright then!
12:35:45 <c_wraith> GSoC doesn't care about age.  Just studenthood.
12:36:38 <monochrom> shapr is ancient and student
12:38:18 * hackagebot hackager 1.0.1 - Hackage testing tool  http://hackage.haskell.org/package/hackager-1.0.1 (DavidTerei)
12:41:59 <adimit> silly question: is there an "idiom" of sorts for foldl with state? I'm tempted to do something like ((State,Accumulator) -> ListItem -> (State,Accumulator)) as a folding function. I could of course use C.M.State with foldM
12:43:03 <Botje> :t mapAccumL
12:43:04 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:43:18 * hackagebot diagrams-svg 0.3.4 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3.4 (DeepakJois)
12:43:27 <Botje> close but no cigar :[
12:44:09 <merijn> adamt: That seems pretty sensible to me
12:44:12 <jfischoff> adimit: I've used (State, Accum) many times, there could be a better way
12:44:12 <merijn> err
12:44:19 <merijn> s/adamt/adimit
12:44:30 <dzhus> yay gsoc
12:45:22 <adimit> jfischoff, merijn: aje. I was worried about the overhead of wrapping and unwrapping (,) all the time, but I don't think it shouldn't be too bad.
12:45:32 <adimit> s/n't//
12:46:15 <merijn> adimit: I doubt it will be a significant performance issue
12:46:59 <adimit> merijn: so do I :-)
12:47:09 <adimit> but I thought maybe there'd be a better way.
12:47:28 <jfischoff> adimit: is the state readonly?
12:47:49 <jfischoff> adimit: if so you could use a closure to make it cleaner
12:47:57 <adimit> jfischoff: no, it has to be modified during folding.
12:48:31 <jfischoff> adimit: that's what I thought, if you find a cleaner way let me know :)
12:49:49 <adimit> jfischoff: There's two alternatives, as far as I can see: using State or using ST, then using foldM. The latter *might* fix *highly unlikely* performance issues, *maybe*. Oh well, and then there's IORef.s
12:51:05 <adamt> merijn: Damn, i just thought i had said something clever. :)
12:51:26 <adimit> combine IORefs with unsafePerformIO for maximum effect.
12:51:31 <merijn> adamt: Oh well, better luck next time ;)
13:03:10 <adimit> Haskell uses utf-16 for String representation internally, no?
13:03:29 <monochrom> how do you know?
13:03:54 <adimit> well, it isn't utf-8
13:04:12 <sipa> how do you know?
13:04:17 <adimit> > "ü"
13:04:18 <lambdabot>   "\252"
13:04:35 <sipa> at no point have you observed the internal representation
13:04:48 <sipa> a Char is a unicode code point, and String is [Char]
13:04:57 <adimit> ü in unicode is 195 188
13:05:18 <adimit> *utf-8
13:05:40 <adimit> not unicode, sorry. Yeah' I haven't seen the internal representation, that's true. hmm...
13:05:52 <Veinor> it can't be utf-16 because every character in utf-16 is 16 bits long
13:05:58 <Veinor> (at least)
13:06:50 <monochrom> you don't know how many abstraction layers have been acrossed when putChar is done
13:07:01 <Veinor> yeah
13:07:30 <Veinor> i'm not sure how Char is represented internally
13:07:42 <adimit> that is correct. The behaviour I'm actually most interested in is ByteString.Char8's pack, I guess.
13:07:58 <monochrom> that one is iso-latin-1
13:08:19 * hackagebot ImperativeHaskell 0.2.0.0 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-0.2.0.0 (MatthewMirman)
13:09:18 <RichyB> Veinor, a Char is a whole unicode codepoint.
13:09:26 <RichyB> Not a glyph, not 8-bits or 16-bits.
13:09:40 <monochrom> Veinor knows
13:09:48 <RichyB> Wrong target.
13:09:59 <adimit> well, I don't know, so thanks for the info.
13:10:08 <monochrom> it's interesting to observe how the most recent answerer is treated as the asker
13:10:18 <RichyB> The implementation happens to be a boxed 32-bit integer, which means it's pretty meaty.
13:10:39 <sipa> monochrom: it's called question passing style (CPS)
13:10:53 <RichyB> monochrom, I was answering "<Veinor> i'm not sure how Char is represented internally"
13:11:44 <sipa> U+00FC ü Latin Small Letter U with diaeresis
13:11:53 <sipa> = 252 in decimal
13:12:50 <sipa> adimit: looks perfectly right to me
13:13:14 <adimit> yeah. interesting. ByteString.writeFile writes FC (after invoking ByteString.Char8.pack,) Prelude.writeFile writes C3BC, which is UTF-8 — this might be because I've my system set to utf8
13:14:06 <adimit> Prelude.writeFile's documentation doesn't mention the fact that it makes adjustments to the code point.
13:14:44 <monochrom> System.IO documentation has a section on that
13:15:38 <monochrom> and not adjustment to code point. encoding and decoding for I/O
13:15:48 <sipa> adimit: what adjustments?
13:15:48 <RichyB> adimit, you can't write Unicode code-points to a file. You have to convert them to a stream of bytes first.
13:16:07 <adimit> yeah, that's what I meant, sorry, I misspoke.
13:16:16 <adimit> encoding/decoding, not adjustment.
13:16:44 <RichyB> No panic, just wanted to make sure you weren't confused on the point.
13:16:44 <adimit> RichyB: but that's what ByteString.writeFile does when you just ByteString.pack a String.
13:17:00 <rwbarton> ByteString.pack is the problem there
13:17:02 <rwbarton> not ByteString.writeFile
13:17:10 <RichyB> ByteString.writeFile just writes vectors of bytes.
13:18:04 <RichyB> ByteString.pack is the only thing that can be doing anything with codepoints. writeFile doesn't actually get to see code-points at all. No [Char] appears in its type (except for the file name but let's gloss over that.)
13:18:06 <adimit> indeed. So why does ByteString.Char8.pack just take the codepoints? I guess, realistically, we'd need it to take an encoding, too.
13:18:08 <rwbarton> If anyone answered your actual question I missed it.
13:18:17 <rwbarton> Char8.pack just takes the low byte of the Unicode code point and spits out that byte.
13:18:51 <RichyB> It's meant for quick 'n' dirty things where you know that the [Char]s are all in the ASCII range
13:19:00 <shachaf> adimit: Data.ByteString.Char8 is evil.
13:19:03 <RichyB> or quick 'n' dirty things where you happen to be using [Char] wrong on purpose.
13:19:04 <rwbarton> It's morally an error to pass a Unicode code point above 0xff (or maybe even above 0x7f) to Char8.pack.
13:19:07 <RichyB> It's evil.
13:19:09 <adimit> rwbarton: oh damn. I thought it'd at least split 'em up or so. That means that any character in the higher ranges get lost.
13:19:33 <shachaf> It's for "Chars" that are really not GHC Chars but ASCII/ISO-8859-1 codepoints.
13:19:34 <RichyB> rwbarton, 0x7f, code points in the range 0x80-0xff don't self-encode in any unicode serialisation.
13:19:39 <shachaf> If you want to encode, use an encoding function.
13:19:41 <monochrom> Char8.pack does iso-latin-1
13:19:53 <adimit> I did not know Char8.pack is so bad. And I'm sure many people didn't know that. I got bitten by an encoding pack in a library recently.
13:20:08 <shachaf> It's a tragedy.
13:20:08 <adimit> I think ultimately it boils down to the use of pack.
13:20:16 <jfischoff> is Text the correct alternative?
13:20:25 <monochrom> many people just assume ascii, so Char8.pack works for them
13:20:27 <kallisti> @hoogle ConnError
13:20:27 <lambdabot> Network.Stream data ConnError
13:20:30 <rwbarton> well, you had to import the Data.ByteString.Char8 module, right, see the first two lines of documentation at http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html
13:20:31 <shachaf> Text is a good alternative when you want to represent text.
13:20:31 <adimit> Yeah, I'm rewriting the library atm to use Text instead of String.
13:20:34 <shachaf> Sometimes String is also good.
13:21:13 <shachaf> jfischoff: (Your name tag was left conspicuously untaken at BayHac last weekend!)
13:21:33 <jfischoff> yes, I had to goto a bot mitzvah
13:21:35 <adimit> rwbarton: the first couple of lines in a doc file are usually the ones I skip :-\ well, I shouldn't be so lazy.
13:22:00 <jfischoff> shachaf: I'm really sad I missed it :(
13:22:14 <jfischoff> next year
13:23:23 <dmwit> bot mitzvah -- for when a bot has served IRC for 13 years
13:23:32 <jfischoff> :)
13:23:45 <dolio> "SAMSUNG EcoGreen F4 ... 2TB SATA ..."
13:23:49 <adimit> is there an IsString instance for Text?
13:24:00 <dolio> "Features: 667GB Formatted Capacity ..."
13:24:05 <dolio> Uh...
13:24:11 <dolio> Whoops.
13:24:13 <adimit> yes, there is. Stupid question, disregard.
13:24:14 <dolio> Wrong channel.
13:24:24 <RichyB> dolio, your filesystem and partitioning scheme suck. ;P
13:24:37 <dolio> RichyB: That's the spec on newegg.
13:24:47 <dmwit> Is it internally RAID-ed or something?
13:25:00 <jfischoff> adimit: IsString is also evil
13:25:07 <RichyB> No. 2TB is the right capacity for that hard drive.
13:25:24 <adimit> jfischoff: can you elaborate?
13:25:25 <RichyB> That model doesn't have any fancy features. It's just NewEgg being silly.
13:26:05 <gwern> hm, 8 students for this GSoC. I was wondering if we'd be cut
13:26:29 <jfischoff> jfischoff: With Text, it is probably always fine, but with more restrictive types it can lead to runtime errors for things that should be caught at compile time (quasi quotes is many times better)
13:26:48 <jfischoff> haha s/jfischoff/adimit
13:27:13 <adimit> as my grandma used to say: when you're talking to yourself, you can at least be sure you're talking to somebody sensible!
13:28:00 <jfischoff> adimit: I like to say, I talk to myself because your crazy!
13:28:00 <adimit> uh, quasi quoting is template haskell, no? That has a big red "careful, timesink" flag for me. Haven't looked at it yet.
13:28:35 <dmwit> jfischoff: ...because my crazy what?
13:28:49 <jfischoff> right you're
13:28:56 <dmwit> ;-)
13:29:06 <jfischoff> :p
13:29:23 <shachaf> dmwit: I'm pretty sure jfischoff was talking about adimit's crazy.
13:29:31 <ktosiek> Hi! I have problems building hopencl, it tells me "Missing C library: OpenCL" (there's "Extra-Libraries: OpenCL" in .cabal)
13:29:40 <ktosiek> what is it looking for exactly?
13:29:43 <adimit> shachaf: it's big.
13:29:54 <monochrom> OpenCL C-side library
13:29:56 <ktosiek> I got python-opencl examples running on the same machine
13:30:04 <dmwit> ktosiek: hopencl is a Haskell binding to OpenCL. You still have to have the real OpenCL installed.
13:30:06 <adimit> ktosiek: you need the dev headers.
13:30:09 <shachaf> ktosiek: Probably something like libopencl-dev or opencl-headers or wahtever it's called.
13:30:13 <monochrom> python is not a good test
13:30:24 <dmwit> ktosiek: For most libraries on Linux, there's a libfoo and libfoo-dev package; you need the -dev version.
13:30:35 <adimit> in debian (and probably derivatives) it's actually called opencl-headers.
13:30:38 <ktosiek> dmwit: OpenCL is different
13:30:49 <ktosiek> and I do have opencl-headers
13:31:07 <shachaf> I recommend strace.
13:31:10 <ktosiek> that's why I'm asking what is it really looking for - OpenCL.h?
13:31:22 <dmwit> It's likely just asking pkgconfig.
13:31:26 <jfischoff> adimit: Yeah, writing your own quasiquoter can be time consuming the first time, more I meant that IsString is a bad language feature the way it is implemented. I wouldn't worry about it too much on practical level.
13:31:27 <dmwit> That's what I would do if I were a build system.
13:31:46 <ktosiek> oh, pkgconfig, right
13:31:59 <adimit> jfischoff: ok. Well, I'd be using it (and recommending its use in a library) only in conjunction with data.Text.
13:32:16 <ktosiek> now I wonder why there's no opencl in pkgconfig :-|
13:32:18 <jfischoff> adimit: I think you are safe there
13:32:26 <ktosiek> but that's not haskell issue
13:32:30 <rudyl313> my haskell library is starting to require users to import a bunch of different modules to do something useful... is it common practice (and/or possible) to export functions and types from various module in a single large module?
13:32:40 <dmwit> yes
13:32:53 <adimit> the nice thing about IsString is its immidiate intuitive appeal… just put that language extension in and type string literals without worry.
13:33:12 <rudyl313> dmwit: will I ever have collisions if two larger modules are exporting the same function from one of the minor modules?
13:33:13 <dmwit> module Convenient (module Inconvenient, module Really.Inconvenient, module Inconvenient.Internal) where import Inconvenient; etc.
13:33:30 <monochrom> no collision, GHC is smart
13:33:31 <dmwit> rudyl313: Don't export symbols; export modules.
13:33:35 <dmwit> That avoids collisions.
13:33:49 <rudyl313> dmwit: awesome... thanks!
13:33:59 <dmwit> Also, listen to monochrom, he knows more than me about a lot of stuff, so he's probably more right about this.
13:34:11 <monochrom> for example observe how ByteString from Data.ByteString and ByteString from Data.ByteString.Char8 are considered identical
13:34:13 <rudyl313> monochrom: noted!
13:34:23 <eacameron> is it possible to put imports at the *end* of the file?
13:34:29 <dmwit> No.
13:34:37 <shachaf> Not such that GHC will accept it.
13:34:58 <adimit> ktosiek: I had the same problem as you with hopencl (also had opencl-headers installed) I then installed nvidia-opencl-dev, then it worked (debian distro.)
13:34:59 <ktosiek> well, sounds like idea for an extension
13:35:06 <Brolapse> why does "words (readFile "myfile.txt)" not work?
13:35:08 <dzhus> gwern: how much slots did Haskell get last year?
13:35:11 <adimit> hope this helps.
13:35:11 <ktosiek> adimit: thanks, I'll try
13:35:12 <Brolapse> missing a "
13:35:24 <dmwit> Brolapse: Because readFile does IO. Perhaps you want words <$> readFile "myfile.txt"
13:35:31 <gwern> dzhus: 7
13:35:40 <dmwit> or fmap words (readFile "myfile.txt") if you don't want to import Control.Applicative.
13:35:47 <dzhus> Though my proposal to Haskell.org didn't make it, I'll still be hacking Haskell this summer for K
13:35:53 <ktosiek> :t liftM words $ readFile "myfile.txt"
13:35:53 <monochrom> how it is done: ByteString is really from Data.ByteString.Internal or something. then both Data.ByteString and Data.ByteString.Char8 re-exports it. there is no confusion.
13:35:54 <lambdabot> IO [String]
13:36:19 <jfischoff> :t words
13:36:19 <lambdabot> String -> [String]
13:36:24 <jfischoff> :t readFile
13:36:25 <lambdabot> FilePath -> IO String
13:36:46 <monochrom> it is actually a Haskell Report requirement to be not confused
13:36:47 <jfischoff> Brolapse: See how the types don't match up?
13:36:53 <kallisti> so it seems the best way to deal with YAML at the moment is to actually convert it into JSON first.
13:36:55 <Brolapse> yeah but i didnt know where to look
13:37:02 <kallisti> given the current state of Haskell libraries
13:37:03 <Brolapse> to go from string io to just string
13:37:08 <dmwit> monochrom++
13:37:17 <Brolapse> fmap words (readFile "myfile.txt")
13:37:19 <Brolapse> appears to work
13:37:28 <Brolapse> so shall go with that ty
13:37:30 <dmwit> Brolapse: You don't go from an IO String to a String. You go from a thing that consumes Strings to a thing that consumes IO Strings.
13:37:44 <adimit> Brolapse: that's because IO is both a Monad and a Functor.
13:37:54 <dmwit> (=<<) :: (String -> IO a) -> (IO String -> IO a)
13:38:14 <dmwit> fmap :: (String -> a) -> (IO String -> IO a)
13:39:03 <kallisti> fmap is probably clearer like this:   fmap :: (a -> b) -> IO a -> IO b
13:39:14 <adimit> liftM and fmap behave exactly the same for things that implement both Monad and Functor.
13:39:23 <shachaf> kallisti: YAML contains more information than JSON, you know.
13:39:30 <kallisti> oh it does?
13:39:31 <ktosiek> but some monads aren't functors?
13:39:41 <shachaf> It's not just an alternate syntax.
13:39:47 <shachaf> ktosiek: Some functors aren't monads.
13:40:06 <byorgey> ktosiek: all monads are functors.  some types which are instances of Monad are not instance of Functor, but that is a bug
13:40:20 <ktosiek> byorgey: ok :-)
13:40:22 <kallisti> shachaf: oh right the more advanced features.
13:40:27 <adimit> ktosiek: afaicr it's the other way around, but there are haskell monads that aren't also Functors because Monad doesn't require you to be Functor, which is kind of an oversight of the Haskell report.
13:41:27 <ktosiek> so, adding instance Functor a => Monad a would be sensible?
13:41:39 <adimit> theoretically, yeah.
13:41:45 <Cale> wait, what?
13:41:47 <Cale> No
13:41:50 <copumpkin> lol
13:41:53 <adimit> no?
13:42:02 <dmwit> No, you want class Functor a => Monad a
13:42:03 <Cale> Adding a *superclass constraint*
13:42:05 <monochrom> calm down people, s/instance/class/
13:42:08 <Cale> Functor a => Monad a
13:42:11 <copumpkin> instance Monad f => Functor f if anything
13:42:17 <copumpkin> but that'd be horrible
13:42:31 <Cale> yeah, it would overlap with anything
13:42:40 <Cale> and so we wouldn't be able to use any other instance :P
13:42:49 <dmwit> English is rubbish at quantifiers.
13:42:52 <copumpkin> yep :)
13:43:09 <ktosiek> isn't there some "find best-matching instance" extension?
13:43:19 <adimit> dmwit: especially quantifiers in object position.
13:43:25 <rwbarton> we don't like to talk about that extension
13:43:25 <dmwit> ktosiek: Yes, but it's evil.
13:43:41 <Brolapse> how to output "\" in haskell without it thinking \ is new line
13:43:41 <jfischoff> dmwit: go on
13:43:46 <dmwit> It's a tossup between that and the Unsafe.* hierarchy. At least the latter have a legitimate use.
13:43:54 <monochrom> is that IncomprehensionInstances?
13:43:58 <dmwit> Brolapse: "\\"
13:44:02 <Brolapse> ty
13:44:51 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html if anything :)
13:45:03 <dmwit> jfischoff: Here's a nice property of Haskell as she is programmed today: given two source programs A and B which both compile and which differ only by the set of instances declared, the compiled programs will behave exactly the same.
13:45:16 <dmwit> jfischoff: The Extension Which Shall Not Be Named ruins this property.
13:46:14 <jfischoff> hehe
13:46:18 <byorgey> corollary: without TEWSNBN, it is impossible to change the behavior of a program by adding instances.
13:46:41 <byorgey> or removing.
13:46:42 <monochrom> what is TEWhatever?
13:46:54 <byorgey> The Extension Which Shall Not Be Named
13:47:03 <byorgey> surely you are not asking me to Name it.
13:47:04 <monochrom> oh God :)
13:47:27 <acowley> I call it Reginald
13:47:47 <c_wraith> That's odd, given that it's named Ted
13:47:51 <monochrom> thank God we are not getting to the YHWH extension yet
13:48:01 <shachaf> But instance Monad f => Functor f is provably "the same" as any other valid Functor instance!
13:48:24 <byorgey> acowley: no! If you give it a name, soon you're going to start letting it in the house, then it will sleep in your bed...
13:48:26 <dmwit> Not at all. I have a half-dozen Functors lying around here which are not Monads!
13:48:34 <shachaf> Hmm?
13:48:44 <shachaf> I'm talking about the case where you only use this instance if there isn't a more specific one.
13:48:45 <rudyl313> how can I export a module that I imported qualified?
13:48:54 <ktosiek> dmwit: and they do not care about instance Monad f => Functor f?
13:49:03 <c_wraith> huh.  well, I've figured out the extension which cannot be named.
13:49:04 <ktosiek> as they are not Monads...
13:49:17 <dmwit> rudyl313: Just stick "module The.Name.Of.The.Module" in your export list. You can't export the names qualified.
13:49:18 <ktosiek> c_wraith: so you can not name it with us :-D
13:49:39 <rudyl313> dmwit: it complains that the module wasn't imported
13:49:44 <dmwit> ?hpaste
13:49:44 <lambdabot> Haskell pastebin: http://hpaste.org/
13:50:11 <c_wraith> On the other hand, I'm still waiting for an explanation of IncoherentInstances that tells me *why* it's in GHC.  When has it ever done what someone wanted?
13:50:56 <monochrom> strange, you have to use the qualified name
13:52:01 <byorgey> yeah, you have to use the qualified name in the export list.  But anyone who now imports the module *doesn't* get to use the qualified name.
13:52:16 <byorgey> which makes sense, since the qualified name is just a way to refer to the module *locally*
13:52:27 <byorgey> though I'm not sure why you *must* use the qualified name in the export list.
13:52:42 <dmwit> I'm lost.
13:52:47 <dmwit> Module names can't be qualified.
13:52:58 <monochrom> I mean the "as" name
13:53:13 <dmwit> ...wow
13:53:23 <monochrom> module F(module Data.Char) where import qualified Data.Char as C -- error
13:53:34 <monochrom> module F(module C) where import qualified Data.Char as C -- accepted
13:53:36 * dmwit trawls the Report
13:54:15 <byorgey> import F; foo = C.toUpper  -- error
13:54:22 <byorgey> import F; foo = toUpper -- accepted
13:54:51 <rwbarton> what about import qualified Data.Char as C; foo = Data.Char.toUpper
13:55:02 <monochrom> the Report is not very clear on this. or obscure wording. I can't find it quickly
13:55:22 <dmwit> http://www.haskell.org/onlinereport/modules.html point 5. in Export Lists?
13:55:28 <dmwit> (not sure, still reading it)
13:56:00 <dmwit> did learn that module Mod (module Mod) where is okay, though.
13:56:05 <dmwit> Which is a bit weird and cool.
13:56:09 <chris2> what am i doing wrong? instance Functor Monad where fmap = liftM
13:56:15 <chris2>     The first argument of `Functor' should have kind `* -> *',
13:56:15 <chris2>     but `Monad' has kind `(* -> *) -> Constraint'
13:56:34 <rwbarton> Monad is not a type constructor
13:56:36 <dmwit> chris2: A couple things. First of all, Monad is a type class, not a type constructor.
13:56:43 <chris2> oh
13:56:50 <chris2> so instance Monad m => Functor m ?
13:57:06 <ktosiek> I would guess Monad f => Functor (f a)
13:57:10 <rwbarton> yes, except that won't work either
13:57:11 <alpounet> dmwit, is that equivalent to module Mod where ... ?
13:57:15 <opqdonut> ktosiek: Functor f
13:57:23 <ktosiek> :-C
13:57:41 <rwbarton> but it will be closer to working
13:57:46 <dmwit> alpounet: Yes, except it also lets you export other modules.
13:57:47 <chris2> Illegal instance declaration for `Functor m'
13:58:02 <alpounet> dmwit, oh right, that's indeed cool
13:58:03 <dmwit> alpounet: e.g. you could do module Mod (module Mod, module Control.Applicative) where
13:58:52 <dmwit> Anyway, it seems like this is a bug in GHC from my reading.
13:59:14 <dmwit> module Foo(module Control.Applicative) where import qualified Control.Applicative as App -- should be allowed, and export nothing
14:01:33 <gabor> I remember having read a GHC commit message that HEAD supports instance associated types with defaults. However a relatively recent GHC does not get
14:01:43 <gabor> instace Foo a where
14:01:54 <gabor> zap that
14:01:59 <dmwit> ?hpaste perhaps
14:02:00 <lambdabot> Haskell pastebin: http://hpaste.org/
14:02:08 <gabor> k
14:02:33 <dmwit> notthemessiah: Is yeganesh-2.5 fast enough for you? =)
14:02:49 <user317> i have a bunch of players that played matches against each other on random teams, anyone know of a good algorithm for ranking the individual players?  my initial approach was to use elo, and change each player based on the expected outcome of the average strength of the teams
14:03:52 <user317> and keep iterating until the standigns stabalize
14:04:39 <dmwit> user317: Have you had a look at TrueSkill, which tries to carefully work out how to do these kinds of things?
14:04:44 <hpaste_> gabor pasted “assoc type defaults” at http://hpaste.org/67508
14:05:16 <user317> dmwitt, its ms patented ranking system, i dont see a lot of papers on how it works
14:05:51 <dmwit> gabor: I think the declarations and definitions have to be separate.
14:05:55 <dmwit> not 100% sure of that
14:05:56 <notthemessiah> dmwit: haven't done an darcs pull yet
14:06:03 <notthemessiah> I'll do that now
14:06:19 <adnauseam> where can i find info about "first" ?
14:06:45 <adnauseam> i've a definition first (a,b,c) = a, and i'm trying to understand what that means in the context of the function
14:06:48 <acowley> gabor: What's the error message?
14:06:57 <adnauseam> function @ http://blogs.msdn.com/b/matt/archive/2009/03/17/prime-factorization-using-unfold-in-haskell.aspx
14:07:08 <dmwit> user317: http://research.microsoft.com/apps/pubs/default.aspx?id=67956 ?
14:07:14 <dmwit> user317: http://research.microsoft.com/en-us/projects/trueskill/faq.aspx
14:07:17 <rwbarton> "first (a,b,c) = a" is the info about first.
14:07:39 <rwbarton> It tells you that first (a,b,c) = a.
14:07:51 <dmwit> adnauseam: What more do you want to know about first?
14:07:52 <rwbarton> What other info is there to know?
14:07:55 <hpaste_> gabor annotated “assoc type defaults” with “assoc type defaults (annotation)” at http://hpaste.org/67508#a67509
14:08:21 * hackagebot network 2.3.0.12 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.12 (JohanTibell)
14:08:23 <gabor> acowley: I do not remember, this comp. has no 7.5
14:08:50 <dmwit> gabor: It looks less weird if you give the kind annotations. Then it looks very parallel to the repetition needed for giving type declarations / default implementations for methods.
14:08:59 <qnikst> hello, on Data.Vector page there is code in examples smth like <1,2,3>
14:09:04 <acowley> oh yes, dmwit is quite right
14:09:15 <acowley> I've only used this for Constraints, where the kind annotation makes the repetition more informative
14:09:25 <dmwit> gabor: e.g. type Domain c a b :: *; type Domain c a b = a looks quite parallel to (<$>) :: c a b -> Domain c a b -> Codomain c a b; (<$>) = fmap
14:09:30 <qnikst> is it possible to use such notation in programs or it's just for simplifying?
14:09:37 <gabor>  dmwit, acowley: will check tomorrow, thanks
14:10:43 <rwbarton> dmwit: when I try that in 7.2.1, I get the same error as without "type Domain c a b :: *" etc.
14:10:48 <rwbarton> But maybe 7.2.1 is too old
14:10:59 <dmwit> I think even 7.4 is too old.
14:11:03 <gabor> yes, 7.2 is too ancient for that
14:11:27 <adnauseam> dmwit: i'm trying to find an example of it, because i dont understand what it does in that context
14:11:29 <qnikst> i don't like using [a,b,c] = fromList (vector)
14:12:07 <dmwit> Oh, no, 7.4 is new enough.
14:12:11 <acowley> I often impress myself by how consistently I forget the emacs keyboard shortcut for upcase/lowercase a region, then spend longer googling for the answer than it would take to manually make the edit. My inclination to automate process is self-destructive at times.
14:12:37 <dmwit> > let first (a, b, c) = a in first (3, 4, "hello!") -- adnauseam, here you go
14:12:38 <lambdabot>   3
14:12:58 <Peaker> acowley, C-x, u[pper case],  C-x l[ower case] ?
14:13:09 <acowley> Peaker: M-l, M-u
14:13:19 <acowley> well, anything would do
14:13:46 <aristid> acowley: just use M-x for the commands you don't use so often. i find words easier to memorise than keybindings
14:13:58 <acowley> aristid: that's good advice
14:13:58 <Peaker> C-x, C-[u/l] also works
14:14:25 <acowley> Yes, and the M- versions sometimes confound my expectations
14:14:35 <aristid> M-u is upcase-word
14:14:57 <rwbarton> dmwit: what's a little odd is that I get the error message "Type declaration in a class must be a kind signature or synonym default:"
14:15:23 <acowley> I also need to avoid trying out random key combos in emacs just to see what happens. It's like closing my eyes and throwing my laptop out the window.
14:15:28 <rwbarton> which mildly suggests that this version of GHC supports synonym defaults, but I guess not.
14:16:39 <dmwit> That is weird.
14:16:50 <dmwit> But I have a file here that works in 7.4 but not 7.2.
14:17:07 <dmwit> class Foo a where type Domain a; type Domain a = a
14:17:23 <dmwit> (And, as you say, the error in 7.2 mentions synonym defaults.)
14:18:06 <kallisti> wow the YAML spec is incomprehensible.
14:19:17 <gwern> whew. I wish pages like https://www.google-melange.com/gsoc/project/google/gsoc2012/shayannajd/18001 linked *anywhere* to the full proposal
14:19:24 <gwern> some of the short proposals are just indecipherable
14:22:44 <dmwit> "Trac detected an internal error while creating a ticket... it is recommended that you inform your local Trac administrator... to that end, you could create a ticket."
14:22:47 <dmwit> hm
14:23:41 <merijn> :D
14:41:11 <dmwit> TIL that imports do *not* always define the fully-qualified name for everything exported by that module. Both "as" and "hiding" affect which fully-qualified names are defined.
14:41:17 <dmwit> So that explains the module-export thing.
14:43:22 * hackagebot mainland-pretty 0.1.2.0 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.2.0 (GeoffreyMainland)
14:43:48 <monochrom> yeah. actually GHC experiments here turns out some very strange results
14:44:09 <dmwit> I *think* I understand things now.
14:44:38 <dmwit> import Foo.Bar as Baz actually doesn't define any Foo.Bar.x constants, only Baz.x.
14:44:53 <dmwit> (And only "Baz" is considered to be an imported module, not "Foo.Bar".)
14:45:33 <dmwit> hiding affects not only the unqualified names, but also the qualified names (where here the name they're qualified by again depends on whether there's an "as" clause or not).
14:46:14 <dmwit> And of course, "qualified" just means the unqualified names aren't defined. This affects module exports, since only exports where both the qualified and unqualified names are available are exported.
14:46:59 <dmwit> What's the strange result you're seeing...?
14:48:03 <monochrom> the last one you just mentioned. the Report wording is treacherous!
14:48:21 <rwbarton> dmwit: that makes sense, I guess, what if you import X as Y and now you want to use another module named Y
14:49:26 <rwbarton> need to be able to import Y as Z without clobbering the name Y
14:49:34 <dmwit> yep
14:51:25 <monochrom> no no no, that would be too easy on your brain...
14:51:46 <dmwit> Hm. I wonder what happens if I import two things as A and export module A...
14:51:57 <monochrom> import Data.List; import Control.Monad as Data.List   -- try it! hahahaha...
14:52:18 <monochrom> then "module A" refers to the union
14:52:39 <dmwit> yes it does
14:53:08 <dmwit> (That would have been my guess. But it just goes to show that even Haskell's simple module system could be an ASS to implement.)
14:54:11 <edwardk> can you export things other than real module names?
14:54:28 <edwardk> that'd be pretty darn convenient
14:54:44 <dmwit> If you import Foo as Bar, then you not only *can* export Bar, you *must*.
14:55:02 <dmwit> (in the sense that you can't export Foo unless you also import it without the "as".)
14:55:02 <edwardk> dmwit: ah neat
14:55:29 <dmwit> You can also export the module you're currently defining.
14:55:39 <thoughtpolice> yeah, it's valid to say 'module F (module X) where import Control.Applicative as X' for example
14:55:39 <monochrom> essentially, the export list uses exactly the same names as whatever names your module body uses
14:55:55 <dmwit> If you can't be bothered to list all the things you define, and still want to export some other module's names.
14:56:09 <thoughtpolice> i usually use a trick like that to export a crapton of modules through a single module
14:56:13 <twomashi> Is there a way to map a function (a -> Maybe b) until a Just b is found?
14:56:27 <dmwit> catMaybes . map
14:56:28 <thoughtpolice> something like 'module F (module X) where import Foo as X; import Bar as X; import Baz as X; ...'
14:56:46 <dmwit> :t \fs x -> catMaybes . map ($x) $ fs
14:56:47 <lambdabot> forall a a1. [a1 -> Maybe a] -> a1 -> [a]
14:56:49 <monochrom> now I wonder how much haddock is confused by that :)
14:57:12 <dmwit> :t \f -> catMaybes . map f -- misread the question
14:57:13 <thoughtpolice> monochrom: by what I did?
14:57:13 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
14:57:17 <monochrom> yes
14:57:30 <twomashi> thanks dmwit
14:57:38 <thoughtpolice> i believe it works fine, but i haven't had a need to use that in a while. i do know it tracks regular module re-exports just dandy
14:57:53 <dmwit> ?hoogle (a -> Maybe b) -> [a] -> [b]
14:57:53 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
14:57:53 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:57:53 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:58:02 <dmwit> Oh, even better, there's mapMaybe.
14:58:23 * hackagebot exception-transformers 0.3.0.2 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.3.0.2 (GeoffreyMainland)
14:58:42 <kallisti> ..does the order of data declarations affect when they're in scope?
14:58:50 <kallisti> because I'm getting that a type is not declared, but... it is.
14:58:52 <twomashi> dmwit: so I want head . mapMaybe
14:59:11 <dmwit> twomashi: You might want that. But you shouldn't want that.
14:59:27 <relation> hi, is there any fast implementation of set manipulation? thanks
14:59:33 <dmwit> Just use pattern matching, and admit that you have to deal with the possibility of not having any results.
14:59:36 <kallisti> there's Data.Set and Data.HashSet
14:59:40 <twomashi> dmwit: why?
14:59:53 <dmwit> ?quote Cale sprynge
14:59:53 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
15:00:04 <kallisti> relation: Data.HashSet tends to be faster, especially with things like string keys . it's in the unordered-collections package
15:00:13 <dmwit> s/may/must/ in that quote
15:00:21 <dmwit> ?free [a] -> a
15:00:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:00:25 <relation> kallisti: and something unboxed possibly?
15:00:31 <dmwit> ?free head :: [a] -> a
15:00:31 <lambdabot> f . head = head . $map f
15:00:39 <dmwit> cute
15:00:54 <kallisti> relation: oh. no. not that I know of.
15:01:14 <twomashi> dmwit: so one should be wary of head?
15:01:32 <dmwit> twomashi: Yes, it's not safe to use head. It's partial.
15:01:47 <dmwit> Use a case, and deal with both the populated-list and unpopulated-list cases, instead.
15:02:03 <ktosiek> I think it's the only situation when it's not safe to use head
15:02:09 <ktosiek> :-D
15:02:13 <kallisti> so yeah line 242 is complaining that the type "Element" isn't in scope
15:02:21 <twomashi> right… or really a function that returns (Just head) or Nothing if theres no justs
15:02:24 <kallisti> meanwhile I have a newtype declaration for Element at line 384
15:02:32 <kallisti> I didn't realize the sequencing of declarations mattered in a module.
15:02:41 <twomashi> but point taken. Thanks
15:03:17 <dmwit> People often jump to using listToMaybe when they're about to pattern match on the Maybe a value anyway. Don't do that, it's weird.
15:03:37 <twomashi> why? it was looking so good..
15:03:41 <twomashi> listToMaybe . mapMaybe
15:03:58 <dmwit> That's fine, if you really *need* a Maybe.
15:04:10 <dmwit> But if the next thing you're going to do with that Maybe is pattern match, then just pattern match on the list.
15:04:15 <dmwit> No need to stick a translation layer in there.
15:04:43 <kallisti> ...anyone?
15:04:44 <twomashi> ah I gotcha. In my case I dont need to pattern match, I'm already in a (Maybe a) block
15:04:56 <dmwit> "case (case answer of [] -> Nothing; (x:xs) -> Just x) of Nothing -> foo; Just x -> bar" is better written as just "case answer of [] -> foo; (x:xs) -> bar".
15:05:12 <dmwit> kallisti: insufficient data for meaningful answer
15:05:24 <dmwit> ?hpaste a minimal example that we can reproduce your error with
15:05:24 <lambdabot> Haskell pastebin: http://hpaste.org/
15:05:24 <kallisti> dmwit: when does the ordering of declarations matter?
15:05:34 <dmwit> The ordering of declarations never matters.
15:05:35 <kallisti> because it apparently does.
15:06:10 <kallisti> if you want I can paste the entire 740 line file.
15:08:02 <dzhus> gwern: you should look for links to published proposals with /review/ in them
15:08:11 <dzhus> if they're posted somewhere
15:08:23 * hackagebot exception-mtl 0.3.0.2 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3.0.2 (GeoffreyMainland)
15:08:24 <gwern> dzhus: I didn't see any. I found the longer ones by googling the title
15:08:36 <Peaker> dmwit, scrolled up to read what you said about modules. I wish Haskell just copied Python's import syntax
15:08:37 <kallisti> http://sprunge.us/dgGU?haskell
15:08:44 <kallisti> behold one 740 line file
15:08:52 <kallisti> and one 2 line error:
15:08:55 <kallisti> src/Test/WebDriver/Commands.hs:242:34: Not in scope: type constructor or class `Element'
15:09:19 <kallisti> and at line 384 a newtype declaration for a type named Element.
15:09:20 <kallisti> discuss.
15:09:26 <Peaker> Template Haskell definitely makes declaration order matter
15:09:54 <kallisti> in what way? always? everywhere?
15:10:08 <kallisti> or only when TH is invoked.
15:10:23 <Peaker> I think when TH is invoked, it can only see the declarations that happened before it in the file
15:10:33 <Peaker> (but I'm not entirely sure that's it)
15:10:35 <kallisti> hm, perhaps that's important.
15:10:36 <dmwit> sprunge-- broken copy and paste
15:10:37 <kallisti> I'll check.
15:10:55 <kallisti> dmwit: hm?
15:11:10 <dmwit> When I copy and paste, the line numbers are included.
15:11:18 <kallisti> oh just take off the ? in the URL
15:11:27 <kallisti> and it turns off all the formatting
15:11:41 <kallisti> see? it's easy. sprunge is infallible.
15:11:41 <dmwit> That should not be necessary. My karma reduction stands.
15:12:48 <kallisti> I should really split this module up
15:12:52 <kallisti> but it's just... so much work. :P
15:13:05 <Peaker> kallisti, we need better IDEs to make it less work
15:13:11 <dmwit> After deleting everything except the definition of FrameSelector and Element, this file compiles.
15:13:17 <dmwit> So it is not declaration order that is screwing you over.
15:16:17 <kallisti> Peaker: command line tools are fine too
15:16:24 <kallisti> easier to add into IDEs than the reverse.
15:17:14 <Veinor> man
15:17:24 <Veinor> sometimes i wish Show had type (Show a, IsString b) => a -> b
15:17:31 <Veinor> er, i wish show had type...
15:18:06 <dmwit> fromString . show has that type!
15:18:21 <dmwit> ?let polyShow = fromString . show
15:18:22 <lambdabot>  <local>:2:11: Not in scope: `fromString'
15:18:24 * hackagebot shelly 0.5.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.5.1 (GregWeber)
15:18:25 <dmwit> aww
15:18:40 <Peaker> kallisti, that could be good in our current textual editing world
15:19:08 <kallisti> Veinor: you should look at the recent patch to interpolatedstring-perl6. It basically makes it so that you can convert between String/Text/ByteString/Show-instances
15:19:09 <dmwit> Peaker: Roslyn, baby!
15:19:16 <kallisti> it may also be black magic. but that's okay. it's worth it.
15:19:29 <acowley> I just used fmap.fmap.fmap … this is simultaneously a code smell and a code eyesore
15:19:42 <Peaker> dmwit, is that like .NET's haskell-src-exts?
15:19:59 <Peaker> acowley, SECs are not a code-smell
15:20:04 <dmwit> Don't know much about haskell-src-exts.
15:20:17 <Peaker> acowley, but maybe it is better to use specific functions than fmap
15:20:24 <zachk> is there a nice solid introduction to the reader monad somwhere?
15:20:37 <Veinor> kallisti: ?
15:20:49 <kallisti> yes. that is a nice question mark there.
15:20:50 <dmwit> It makes all the compiler phases (right up through IL generation) of the C# and VB compilers available programmatically, though.
15:21:05 <Peaker> @where SEC
15:21:05 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:21:10 <Peaker> acowley, did you read that ^^ ?
15:21:30 <kallisti> replying with "?" is always like "no please, ramble blindly until it makes sense. I won't bother to provide any helpful information."
15:21:33 <edwardk> I find the SEC approach to be a worse "code smell" than judicious use of fmap ;)
15:21:34 <sclv> I think renaming fmap doesn't actually make things that much better :-)
15:21:47 <Peaker> dmwit, cool.. I dream of making them interactively available (i.e: make it a no-brainer to follow your code through the optimization phases and assembly without being a tool guru)
15:21:51 <edwardk> kallisti: ?
15:21:59 <sclv> It's like resodding a field because the grass keeps dying from the superfund site next door.
15:22:25 <Peaker> edwardk, what do you mean? unary fmap composition *is* part of the SEC approach
15:22:33 <Peaker> edwardk, what is bad about SECs? I love SECs :)
15:22:49 <kallisti> help what is this acronym.
15:22:57 <dmwit> ?where sec
15:22:57 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:23:04 <sclv> kallisti: ?
15:23:04 <acowley> Peaker: I've read it, yes, and while I like it in theory I haven't found it really useful in my own coding. I usually take this as a criticism of me, but it is what it is
15:23:42 <acowley> Maybe I should just put fffmap = fmap.fmap.fmap somewhere
15:23:51 <dmwit> Oh, this is even better than I thought it would be.
15:23:53 <kallisti> augh, no more question marks. No one in this channel believes in goodness.
15:24:02 <dmwit> "These functions allow you to parse a subset of a source file, such as an expression, statement, or comment."
15:24:09 <Peaker> acowley, I use SECs all the time, like crazy :-)
15:24:40 <edwardk> The main issue that I have is that it takes someone out of the code to go hunt down some silly combinator. i'd rather say fmap than result. its clear and unambiguous and generalizes when i defunctionalize
15:24:43 <acowley> Peaker: Do nested lenses count? Because I suppose I do use them sometimes.
15:25:01 <Peaker> acowley, lenses are similar to SECs but they are much less general
15:25:17 <acowley> Peaker: that's why I asked for permission to count :)
15:25:21 <sclv> if you're always fmapping three deep into the same thing, you could give your alias a meaningful name.
15:25:26 <kallisti> Veinor: I patched interpolatedstring-perl6 so you can do  x = [qc|This is a Bytestring {2 + 2}] :: ByteString
15:25:27 <Peaker> edwardk, How do you do: (fmap . argument . first . const) 5 ?
15:25:46 <Veinor> kallisti: ... ew that's awful
15:25:47 <acowley> Peaker: even in that limited setting, though, (edwardk: stop reading here) I can't say I find the lens code all that readable when I come back to it.
15:25:50 <edwardk> thats because "semantic editor combinator" is just a very verbose way to say "function composition" ;)
15:26:14 <Peaker> edwardk, that's reductionist.. SECs are a particular pattern of function composition
15:26:21 <kallisti> Veinor: hm? you mean string interpolation in general? oh.. well, I'm sorry.
15:26:27 <edwardk> (fmap . flip fmap . first . const) 5
15:26:30 <kallisti> I find it extremely convenient to be able to do that.
15:26:31 <dmwit> Peaker: Thanks for the pointer to haskell-src-exts.
15:26:35 <sclv> kallisti: you shouldn't need to use quasiquotes for that -- just overload IsString and use unsafePerformIO :-)
15:26:35 <Peaker> edwardk, Computers are just a verbose way of saying arranged-particles
15:26:43 <acowley> The SEC terminology actually turned me off, too
15:27:02 <kallisti> sclv: I'm not seeing how that would help.
15:27:05 <Peaker> dmwit, :)
15:27:09 <sclv> it was a bad joke, sorry.
15:27:12 <edwardk> for me i just don't find that the individual semantic editor combinators cross the fairbairn threshold. they are individually all too simple
15:27:48 <Peaker> edwardk, every time I read that line of code, I'll be wasting a few extra seconds deciphering the unused extra generality in there...
15:28:07 <acowley> edwardk: at how many f's does my family of ffffffffmap functions cross the threshold? :P
15:28:25 <dmwit> Peaker: I'm a bit confused, and having trouble tracking down the answer: does haskell-src-exts discard comments and quotient by whitespace?
15:29:04 <Peaker> dmwit, I don't know haskell-src-exts very well myself, sorry
15:29:06 <edwardk> i will occasionally defined (:.) inline or something like it when i'm using fmap . fmap a lot, but the alternative is that i take my nice self contained package, and add some baroque dependency on a third party package, and force any reader of the code to stop, jump out and look at its documentation, and come back if they aren't familiar with every one of those combinators
15:29:39 <Peaker> dmwit, http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.2/doc/html/Language-Haskell-Exts-Syntax.html#t:Module <-- seems to suggest no representation of whitespace or comments
15:29:42 <edwardk> Peaker: in practice, i just don't use the flip fmap combinator. i tend to use the presence of flip as one of the signals that i shouldn't be using point free
15:30:36 <Peaker> edwardk, https://github.com/Peaker/bottle/blob/master/bottlelib/Graphics/UI/Bottle/Widget.hs#L193 <-- look at this
15:30:56 <Peaker> edwardk, that's an example of why I really love SECs
15:31:16 <acowley> Would it be gauche to use (╯°□°）╯︵  as an alias for flip?
15:31:18 <Peaker> edwardk, I've got a record (SizeDependentWidgetData) that I want to "translate" (i.e: move it around)
15:31:47 <Peaker> edwardk, it's so great to be able to reach directly into all the places in the record and move them, even if they are inside functions, arguments, maybes, tuples, etc.
15:32:10 <navaati1> grmbl, ghc cannot derive a show instance for an existentially quantified type…
15:32:32 <jfischoff> Peaker: what is bottle for?
15:32:55 <acowley> Now I've got the line: pure = Best . pure . pure . pure
15:33:00 <edwardk> peaker: but then the moment you have a monadic side-effect you have to replumb all that code in a dramatically different way
15:33:13 <Peaker> jfischoff, structural editor for a Haskell-like language.. but it's very preliminary work
15:33:17 <eXeC64> I'm new to functional programming and haskell but it seems to me like a large portion of the code is unpacking data and then repacking it with changes. Am I missing an important concept?
15:33:18 <sclv> ffffmap : haskell :: caaadadddr : lisp
15:33:25 <Peaker> edwardk, why? I just "liftM" to penetrate the monad
15:33:26 <dmwit> I don't want a pretty-printer. I want an ugly-printer.
15:33:42 <acowley> I think I'll need the DSM IV for the metatheory of whatever I'm doing.
15:34:07 <Peaker> edwardk, I have plenty of "m (Widget (bla bla ..))" types that I SEC-edit via (liftM . Widget.atThisOrThat . fmap . ...)
15:34:08 <acowley> eXeC64: SECs
15:34:16 <acowley> eXeC64: or lenses
15:34:23 <edwardk> Peaker: no, when you have something like takesFocusM :: (Monad m, Functor f) => (Direction -> m (f Id)) -> Widget f -> m (Widget f)
15:34:37 <jfischoff> Peaker: What os?
15:34:41 <navaati> acowley: what are SECs ?
15:34:49 <Peaker> jfischoff, should be portable, we use GLFW-b for the windowing stuff
15:34:52 <sclv> ?where sec
15:34:53 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:35:01 <acowley> The nice thing about pure.pure.pure or fmap.fmap.fmap code is that you just keep repeating yourself until you get the nod from the type checker.
15:35:11 <edwardk> acowley: hah
15:35:17 <monochrom> hahaha
15:35:19 <navaati> sclv: thx
15:35:20 <edwardk> navaati: functions
15:35:22 <Peaker> edwardk, SECs are restricted to pure functions, but generalizing them to do that should be interesting as well
15:35:36 <Peaker> edwardk, that said, I encounter a lot more pure functions I want to apply than effectful ones in that code
15:35:41 <eXeC64> acowley, Thanks. That looks useful.
15:36:01 <kallisti> dmwit: Peaker: appears to be the TH but I can't decipher why
15:36:02 <conal> Peaker: which was the original motivation -- extending to tangible-value manipulations.
15:36:29 <eXeC64> Also, is there a good project in haskell I could examine to get a better feel for a practical application of haskell?
15:36:39 <Peaker> conal, hey, I tried to reach you a couple of times in the last couple of weeks
15:36:43 <merijn> eXeC64: xmonad?
15:36:54 <edwardk> Peaker: i am somewhat concerned that that happens because you are "looking for your keys in the lit portion of the parking lot" ;)
15:36:59 <conal> Peaker: hi.
15:37:10 <merijn> eXeC64: Fairly small (I believe about 2k LOC), fairly popular and fairly practical
15:37:19 <Peaker> conal, I thought maybe you could help with a conceptual hurdle with the graphics-drawingcombinators library (which seems to follow through on many of your principles)
15:37:20 <eXeC64> merijn, That's currently what I'm looking at now. Just wanted to check if there's other good examples.
15:37:24 <kallisti> eXeC64: -shameless plug- you can check out the project I'm working on right now http://hackage.haskell.org/package/webdriver-0.2
15:37:27 <eXeC64> xmonad happens to be my favourite window manager
15:37:37 <kallisti> eXeC64: it reeks of practical.
15:37:44 <eXeC64> kallisti, Thanks. I'll take a look
15:37:44 <edwardk> Peaker: but in the end, whatever keeps you productive i guess
15:37:59 <acowley> dance like nobody's watching, love like you'll never be hurt, and code like you'll never face code review
15:38:02 <Peaker> edwardk, Usually if you need an effectful function, you could perform the effects first, and then apply the SEC
15:38:54 <edwardk> gotta run
15:39:13 <Peaker> conal, the function "tint" in http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.4.1/doc/html/Graphics-DrawingCombinators.html   says one thing, but (I think it) does another, and I am having trouble figuring out how an implementation could be correct w.r.t the simple denotational semantics
15:39:17 <conal> Peaker: or use the more general arrowish form of SECs, as in Eros.
15:39:25 <kallisti> eXeC64: the github repo is a bit less horribly bug-riddled
15:39:33 <kallisti> until I'm ready for another release.
15:39:52 <Peaker> conal, Ah, I need to study those more deeply, I've only given it a cursory glance
15:40:26 <dmwit> Peaker: By the way, I mentioned your complaint to byorgey to see if diagrams could do better. He said it actually has the same problem... but it has a more expressive language for base diagrams, so you can just express rounded rectangles as a single unit.
15:40:39 <dmwit> You might look at that if you want to be practical.
15:40:44 <conal> Peaker: do check them out. the general/arrowish SECs were the key to tangible functional programming.
15:40:55 <Peaker> dmwit, thanks!  It's weird that problem is slightly hard to solve
15:41:29 <Peaker> dmwit, well, I need it for real-time graphics (ideally 60FPS, too)
15:42:20 <EvanR> SEC?
15:42:45 <conal> Peaker: looking at the semantics & implementation of tint ...
15:43:03 <Peaker> conal, anyway, my problem was when trying to draw a semi-transparent image which itself is a composition of images.. Whenever you add transparency to the opaque composite image, its implementation (the opaque images that originally composed it) are exposed
15:43:39 <EvanR> oh semantic editor combinators
15:43:48 <dmwit> The problem is that fixing this Really Correctly involves doing all the color compositing in the library, rather than shipping out to whatever drawing library is underneath.
15:44:23 <conal> Peaker: i've not looked at this library before. hard for me to guess what he's getting at.
15:44:47 <Peaker> conal, what do you mean? are the denotational semantics he's specifying there unclear?
15:44:49 <dmwit> (Which is probably significantly slower, since often the underlying drawing library has the API it does because that's what the hardware exposes...)
15:44:58 <conal> Peaker: sry. i mean with the implementation.
15:45:34 <conal> Peaker: the denotational model is fairly simple, though not as simple as i used in pan & vertigo.
15:46:03 <Peaker> conal, because of the extra "Pick" stuff he added to his model?
15:46:36 <conal> Peaker: that images always carry colors *in addition to* another value at each point.
15:46:45 <Peaker> dmwit, yeah, I think it should be possible to do it with the underlying library/hardware, if you go through textures or such (it will have a smaller penalty)
15:47:47 <dmwit> Textures are unfortunately resolution-dependent.
15:47:57 <Peaker> conal, yeah, he wants to support composition of images and pickers simultaneously, and he fused the semantics at the Image level.. I guess he could compose a pair of (Image, Picker) instead so Image remains simple
15:47:57 <conal> Peaker: i probably can't help here. have you asked luqui?
15:48:24 * hackagebot ref-fd 0.3.0.2 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.3.0.2 (GeoffreyMainland)
15:48:44 <Peaker> conal, well, the problem seems to be more general than just graphics-drawingcombinators, given that the diagrams also seems to have it.. it's a conceptual problem with implementing these simple image semantics in general, when transparency is involved
15:48:57 <conal> Peaker: i wouldn't expect to want to have a color all the time. for instance, i used images full of bools, angles, & functions.
15:49:06 <Peaker> conal, (and when colorizing in the implementation is done by underlying libs/hardware)
15:49:33 <Peaker> conal, ah, how do you utilize OpenGL for images that do happen to have colors?
15:49:42 <conal> Peaker: i guess i haven't understood your question. something about working with colors-with-transparency..
15:50:03 <conal> Peaker: oh. opengl. z-buffering & translucency don't get along.
15:50:26 <t7> draw front to back
15:50:31 <t7> or something :)
15:50:34 <dzhus> Is there any instance for Either which allows me to map over Right value only, leaving Left inact?
15:50:45 <t7> fmap?
15:50:48 <conal> yeah. and turn off the a-buffer.
15:50:51 <Peaker> conal, Well, I tried to compose a "rounded rect" by composing two rects that form a "plus" sign, with 4 circles that add rounded-ness on the edges.   This looks great.  Then I try to "tint" this rounded rect to be transparent, but instead, you see all the shapes inside it becoming transparent and you see all of their outlines on the resulting shape
15:50:59 <Veinor> > fmap (+1) [Left "hello!", Right 8]
15:50:59 <lambdabot>   No instance for (GHC.Num.Num
15:51:00 <lambdabot>                     (Data.Either.Either [GHC.T...
15:51:05 <Veinor> oh right
15:51:09 <Peaker> conal, well, I am using 2d images here, no z-buffering
15:51:15 <Veinor> > map (fmap (+1)) [Left "hello!", Right 8]
15:51:16 <lambdabot>   [Left "hello!",Right 9]
15:51:34 <Peaker> dzhus, Functor, Applicative, Monad  all work on the Right value only
15:51:46 <dzhus> looks like I missed something, thanks
15:51:48 <conal> Peaker: yep. that's pretty broken. oh. good. not a z-buffering issue. sounds like a bug. have you asked luqui?
15:52:19 <Peaker> conal, Haven't reached him either :)  I'm still waiting for him to upload the new version to hackage
15:52:34 <dmwit> Peaker: I expect the practical answer is to use bezier.
15:52:43 <conal> Peaker: i doubt there's anything deeper than an implementation bug there.
15:52:49 <dmwit> Peaker: (Can you fill in a bezierCurve?)
15:53:05 <Peaker> conal, anyway, this bug seems particularly difficult, it seems like it would be really hard to compose a transparent-rounded-rect with OpenGL if you don't take the composite image into some texture first
15:53:49 <Peaker> dmwit, I don't think that's possible. I can emulate a circle with polygons, though, like I think ordinary circle code does
15:54:22 <dmwit> Yeah, I see that. convexPoly might be your best bet.
15:54:27 <jfischoff> Peaker: you can draw curves with shaders
15:54:46 <conal> Peaker: fortunately, luqui cares about well-definedness & correctness of implementation w.r.t denotation. so he may want to address this issue (rather than offer an implementation-oriented excuse for the current behavior).
15:54:51 <jfischoff> Peaker: you might not want to
15:54:55 <Peaker> jfischoff, dmwit: The problem is that this just works around this particular bug in graphics-drawingcombinators, and I'm wondering if this bug is solvable in the general case
15:55:07 * dmwit nods supportively
15:55:15 <jfischoff> ditto
15:55:24 <jfischoff> hey conal
15:55:33 <Peaker> conal, Yeah, I agree... But I do roughly understand how luqui's implementation works, and I can't figure out how to solve the bug myself
15:55:48 <conal> jfischoff: hi! i was hoping to see you last weekend at bayhac. how's life?
15:56:08 <Peaker> if every composite tinting went through an extra OpenGL texture, it would probably have a significant performance penalty
15:56:31 <jfischoff> life is good. I wanted to make but I was in LA for family. Started a new job, programming in haskell everyday :)
15:56:45 <conal> Peaker: might need to replace the implementation rather than fix.
15:57:14 <conal> jfischoff: congrats!! i'm delighted to hear about your new job. :)
15:57:36 <Peaker> conal, you've done lots of OpenGL work, iirc, so I thought maybe on the implementation-side of things, you'd have any idea how to get OpenGL to add transparency to an opaque composite drawn via smaller drawing primitive calls
15:58:00 <Peaker> conal, and I wanted to confirm it is indeed a bug and not a misunderstanding on my side, so you've already helped :)
15:59:19 <conal> Peaker: ah, i see. i don't want to think about OpenGL wrangling right now. sry.
15:59:43 <Peaker> conal, ok, thanks anyway
15:59:58 <conal> Peaker: another example of probably not fixable & needs replacing.
16:00:21 <jfischoff> conal: what do you want to think about now? :)
16:01:12 <conal> jfischoff: i'm thinking about programmable logic & parallel functional programming these days.
16:01:43 <jfischoff> conal:sounds very cool
16:02:07 <conal> jfischoff: for my job. i have tons to learn. a lot of potential to contribute at work, but i'm so dreadfully ignorant of EECS issues.
16:03:53 <jfischoff> jfischoff: Right, I feel same way, both about electronics in general and with my new job. So much I can do, so much to learn
16:04:02 <jfischoff> ha s/jfischoff/conal
16:04:42 <conal> jfischoff: i'd love to chat in person again, and i'm in silicon valley half time now.
16:05:15 <jfischoff> conal: great, just shoot me an email, and will grab lunch or dinner.
16:05:46 <conal> jfischoff: will do :)
16:05:52 <jfischoff> :)
16:16:12 <nart> hi
16:20:35 <dmwit> ?remember darcs It's too late to use atexit
16:20:35 <lambdabot> It is stored.
16:20:37 <dmwit> very ominous
16:24:04 <user317> dmwit: elo turned out really usefull.  i took out 5 games from my tranning set and after 20k iterations the resulting strengths were able to predict the games i took out with 0.03 error
16:24:49 <user317> dmwit: well, usefully in the sense that it found the obvious 5 players that where the most significant factors
16:30:08 <hpaste_> brolapse pasted “brolapse” at http://hpaste.org/67512
16:30:34 <Brolapse> i just pasted that, any idea what I'm doing wrong?
16:30:51 <dmwit> Yes, your type signature is wrong.
16:30:52 <jfischoff> you can't get out of the IO monad
16:31:02 <jfischoff> you can only get in
16:31:02 <dmwit> load :: String -> IO ()
16:31:27 <dmwit> Also, putStrLn takes a String, but t is a [String].
16:31:29 <Brolapse> dmwit, when i do that Couldn't match expected type `IO t0' with actual type `[String]'
16:31:43 <dmwit> Also, lines doesn't do IO, so you need to use let instead of <-.
16:31:50 <dmwit> e.g. let t = lines s
16:32:12 <dmwit> I think that just about covers it.
16:32:25 <Brolapse> Couldn't match expected type `[t0]' with actual type `IO String'
16:32:56 <dmwit> Did you make all three changes? If so, hpaste the new code.
16:32:59 <Brolapse> i don't get why lines doesn't do IO
16:33:05 <dmwit> because
16:33:06 <dmwit> :t lines
16:33:07 <lambdabot> String -> [String]
16:33:25 <aristid> Brolapse: because it doesn't need to do any I/O to split a  string into lines.
16:33:28 <dmwit> I don't get why lines would need to do IO. It just breaks a String on its newlines.
16:33:44 <Brolapse> IO String is obv different to String but I don't understand why it doesn't just change itself
16:34:04 <dmwit> Ah, well, that's easy.
16:34:07 <dmwit> Nothing ever changes itself.
16:34:14 <Brolapse> dmwit, i'm trying to parse stuff from a .txt into a list
16:34:18 <dmwit> In fact, nothing ever changes. Thanks, immutability!
16:34:49 <dmwit> Sounds like a good task to try.
16:34:50 <hpaste_> brolapse pasted “brolapse” at http://hpaste.org/67513
16:35:07 <dmwit> load :: String -> IO [String]
16:35:47 <Brolapse> and it works!
16:35:55 <Brolapse> thank you
16:39:08 <aristid> Brolapse: have you also succeeded in writing dmwit's load function? :)
16:39:34 <Brolapse> what do you mean aristid
16:42:23 <dmwit> :t lines <$> readFile "myfile.txt" -- Brolapse
16:42:23 <lambdabot> IO [String]
16:43:23 <burbul> @pl flip ($)
16:43:24 <lambdabot> flip id
16:43:46 <burbul> :t ($)
16:43:47 <niklasb> I always have to think twice when I see that.
16:43:47 <lambdabot> forall a b. (a -> b) -> a -> b
16:43:58 <burbul> yes, that made my head hurt!
16:44:17 <c_wraith> the key is that ($) is just a specialized id
16:44:20 <burbul> yup
16:44:38 <burbul> I got it once I saw the type signature
16:44:50 <burbul> @pl foldM (flip ($))
16:44:50 <lambdabot> foldM (flip id)
16:45:17 <burbul> Is foldM (flip ($)) idiomatic? I feel like there should be a  nicer way of writing that.
16:45:39 <nart> anyone here uses eclipsefp ?
16:45:53 <c_wraith> It's not really idiomatic, no.  But there isn't a really idiomatic approach to that.
16:46:18 <aristid> Brolapse:  dmwit | load :: String -> IO [String]
16:46:24 <burbul> ok -- thanks.
16:46:28 <aristid> Brolapse: you can try writing a function with that type
16:46:42 <dmwit> aristid: ...he did write a function of that type.
16:46:47 <aristid> dmwit: oh?
16:46:48 <dmwit> (It's on hpaste.)
16:46:58 <aristid> dmwit: ok, i did not notice that
16:47:10 <aristid> oh, and...
16:47:10 <Brolapse> :P thats why i was confused
16:47:17 <aristid> sorry, nevermind, i was more confused
16:47:38 <aristid> String is an evil type *lame excuse*
16:52:57 <hpaste_> niklasb pasted “simple test case producer” at http://hpaste.org/67514
16:53:14 <niklasb> I want to write a test function for some kind of external application. Therefore I'd like to have a function that produces a test case and a checker function to verify the output. the above is a very simple example. what would be a good way to generalize this?
16:53:56 <niklasb> I'm thinking it has something to do with continuations, but I'm not sure
16:54:27 <jfischoff> niklasb: have you looked at any existing test frameworks?
16:54:50 <niklasb> jfischoff: I only know QuickCheck to a certain degree
16:55:02 <hpaste_> whittle pasted “dependency resolution” at http://hpaste.org/67515
16:55:21 <niklasb> but it's only a toy project, nothing serious. I just want to figure out the general concept behind this pattern
16:55:35 <whittle> When I get dependency resolution errors list this one, where should I start debugging from?
16:57:45 <whittle> s/list/like/
16:58:43 <jfischoff> niklasb: You might want to look here anyway: http://hackage.haskell.org/packages/archive/test-framework/0.5/doc/html/Test-Framework-Providers-API.html#t:Test to see how they implemented their Test datatype
16:58:43 <Peaker> niklasb, what you described sounds very much like QuickCheck?
17:01:23 <niklasb> hm, okay thanks guys, I guess I have to get some sleep before thinking about this further...
17:01:38 * kallisti_ is doing the "create countless instances for every monad trasformer" dance.
17:03:18 <kallisti_> hmm apparently Cont has no MonadBaseControl instance.
17:03:28 <kallisti_> it must not be very trivial..
17:03:51 <francisl> is it possible to change a rewrite function at runtime in haskell?
17:04:13 <kallisti_> you mean a rewrite rule? not that I know of.
17:04:14 <kallisti_> why?
17:04:29 <kallisti_> you can turn off rewrite rules during compilation
17:04:32 <kallisti_> if that helps.
17:09:18 <francisl> Just curious if I can change behaviour of a running program
17:09:21 <francisl> thanks
17:09:55 <dmwit> Yes, you can.
17:09:58 <dmwit> It's easy.
17:10:06 <dmwit> You write two functions, one with the rewritten version and one without.
17:10:19 <dmwit> At runtime, you call whichever of the two functions you want.
17:10:40 <dmwit> It seems like a weird thing to want, though. Usually rewrite rules only exist for things that are strictly improvements.
17:11:06 <francisl> ok, but I can't put a interpreter in my app (like a javascript console in firebug) and change code live
17:11:42 <shapr> Why not?
17:11:48 <shapr> > 1 + 1
17:11:48 <lambdabot>   2
17:11:55 <shapr> > map (+1) [1..5]
17:11:56 <lambdabot>   [2,3,4,5,6]
17:12:04 <shapr> francisl: the irc bot does what you want, right?
17:12:34 <dmwit> I'm not sure I see the connection between the two things you've asked for (conditionally removing rewrite rules and interpreting code).
17:12:49 <dmwit> Can you just say what your toplevel goal is so we can give you real help instead of trying to guess what you want?
17:12:51 <kallisti_> "change the behavior of a running program" and "load plugins and interpret Haskell code at runtime" are 2 different things. One is a subset of the other.
17:13:23 <jfischoff> francisl: http://hackage.haskell.org/package/hint
17:15:20 <kallisti_> obviously if you statically compile a program, it's quite difficult to change its behavior at runtime. Dynamically loaded or interpreted code, on the other hand, is a bit more pliable.
17:15:44 <Peaker> are type families reasonably stable in ghc? I'm getting a very peculiar error that seems wrong
17:16:00 <kallisti_> as far as I know they're stable in the latest versions.
17:16:16 <kallisti_> they do turn on MonoLocalBinds so you may be having issues with that.
17:16:19 <kallisti_> I had similar weirdness.
17:16:26 <francisl> I was thinking of something like emacs, where you can reload function when the application is running
17:16:33 <kallisti_> yeah that's possible
17:16:39 <kallisti_> in fact lambdabot does just that with its plugin syste.
17:16:41 <kallisti_> *system
17:18:01 <kallisti_> even C can accomplish such things through dlopen, so it's not a particularly rare capability.
17:18:24 <jfischoff> Peaker: Generalized new type deriving was broken for a while with type families, still could be. There were TH issues too. Don't know the current state.
17:18:26 <francisl> quite rare to see that kind of thing in C
17:18:54 * kallisti_ recently wrote a Haskell interface to a IRC bot written in C.
17:19:03 <kallisti_> that bot used dlopen.
17:19:52 <kallisti_> so not only can Haskell dynamically load Haskell code, but other languages' code can dynamically load Haskell code. :P
17:20:01 <francisl> I always though it was only possible in dynamic language … I still have lot to learn
17:20:38 <kallisti_> it's just somewhat easier to make highly ridiculously over-the-top dynamicism in those languages.
17:20:52 <kallisti_> emacs lisp is a good example.
17:21:09 <kallisti_> but "load a library at runtime" is much simpler. That happens all the time.
17:21:31 <Peaker> jfischoff, thanks.. I'm having trouble without TH/deriving
17:21:41 <Peaker> jfischoff, will try to reduce my (large) example
17:22:08 <kallisti_> Peaker: my problem was solved by giving my local bindings type signatures
17:22:16 <kallisti_> because they were being inferred monomorphically, even with NoMonoLocalBinds
17:22:34 <thoughtpolice_> are you using GADTs?
17:22:44 * kallisti_ isn't.
17:23:24 <kallisti_> I believe there's an example on HaskellWiki of a situation where enabling TypeFamilies makes a particular kind of type inferrence undecideable.
17:23:35 <kallisti_> but I'm fuzzy on the details.
17:23:41 <thoughtpolice_> hm, i was fairly certain GHC generally inferred the most polymorphic type for local let bindings, the exception being -XGADTs is specified. perhaps that behavior has changed.
17:24:13 <luite> it was changed
17:24:26 <thoughtpolice_> ah, figured. i guess it always defaults to monomorphic let bindings now?
17:24:32 <thoughtpolice_> when did that happen?
17:24:32 <c_wraith> yeah.  several features trigger an extension called MonolocalBinds now
17:24:35 <c_wraith> 7.0
17:24:42 <c_wraith> when the type checker was changed
17:24:46 <thoughtpolice_> well yes, i know that.
17:24:49 <c_wraith> It's part of the outside-in algorithm
17:25:18 <thoughtpolice_> what I was saying was that GHC infers a polymorphic type for a local let binding, *unless* GADTs is specified, as GADTs implies MonoLocalBinds
17:25:29 <c_wraith> GADTs isn't the only one, so far as I know
17:25:33 <thoughtpolice_> i was under the assumption that was still the case, but kallisti_ says he is getting monomorphic types for his local bindings, even without GADTs
17:25:38 <thoughtpolice_> ah, ok
17:25:49 <c_wraith> kallisti_: do you have any other type extensions enabled?
17:25:49 <luite> pattern bindings are also monomorphic now
17:25:51 <kallisti_> moreover, NoMonoLocalBinds doesn't seem to help.
17:25:53 <kallisti_> c_wraith: plenty
17:25:58 <kallisti_> well, the code is completely different now
17:26:02 <thoughtpolice_> then yeah, that would probably be it
17:26:03 <kallisti_> but it's still available on git.
17:29:32 <Peaker> kallisti_, I don't even have local bindings there
17:33:35 <Lorehead> http://www.patheos.com/blogs/longobedience/2012/04/19/on-being-an-absolute-ass/
17:33:41 <Lorehead> Sorry, wrong window.
17:33:57 <hpaste_> Peaker pasted “Minimal TF example” at http://hpaste.org/67520
17:34:01 <Lorehead> Not very relevant to Haskell.
17:35:20 <twomashi> is there a nice way to do "takeWhile for a maximum of n elements" ?
17:35:51 <JoeyA> > (take 10 . takeWhile (<3)) [-10..10]
17:35:53 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
17:36:01 <JoeyA> > (take 10 . takeWhile (<3)) [-3..10]
17:36:02 <lambdabot>   [-3,-2,-1,0,1,2]
17:36:22 <Saizan> Peaker: f is unusable because m appears only as the argument of Tag and since type families aren't guaranteed injective it won't ever be able to infer which m you want
17:36:48 <JoeyA> twomashi: There is: just apply take 10 as well.
17:37:03 <twomashi> JoeyA: sorry, badly phrased. dropWhile for a maximum of n elements
17:37:45 <dmwit> let (b, e) = splitAt n xs in dropWhile p b ++ e
17:37:56 <Peaker> Saizan, thanks! so it would make sense to errorize on "f" ?
17:38:15 <Saizan> Peaker: you can either make Tag a data family, or add a proxy argument to f so that m appears outside of type families
17:38:59 <JoeyA> dmwit: I think that'll discard items if the predicate stops returning true before the limit is reached.
17:39:26 <JoeyA> > let dropWhileN n p xs = let (b, e) = splitAt n xs in dropWhile p b ++ e
17:39:26 <lambdabot>   not an expression: `let dropWhileN n p xs = let (b, e) = splitAt n xs in dr...
17:39:32 <JoeyA> @let dropWhileN n p xs = let (b, e) = splitAt n xs in dropWhile p b ++ e
17:39:33 <lambdabot>  Defined.
17:39:43 <JoeyA> > dropWhileN 10 (<3) [-10..10]
17:39:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
17:40:04 <JoeyA> > dropWhileN 10 (<3) [0..10]
17:40:05 <lambdabot>   [3,4,5,6,7,8,9,10]
17:40:21 <dmwit> Looks good to me.
17:40:28 <JoeyA> hmm
17:40:30 <otters> > dropWhileN 3 (<10) [1..10]
17:40:32 <lambdabot>   [4,5,6,7,8,9,10]
17:40:33 <Saizan> Peaker: not letting you define f you mean? i think it would make sense
17:40:35 <otters> neat
17:40:44 <twomashi> > dropWhileN 5 (<3) [1..10]
17:40:45 <lambdabot>   [3,4,5,6,7,8,9,10]
17:40:53 <Peaker> Saizan, yeah, I was confused by this for like 40 minutes, the error message was misleading
17:41:10 <Peaker> (adding type signatures, toying around, eventually generating smaller example)
17:42:09 <JoeyA> @let love = (<3)
17:42:10 <lambdabot>  Defined.
17:42:58 <twomashi> let crash = length [1..]
17:43:00 <twomashi> crashes?
17:43:56 <JoeyA> > length [1 :: Word8..]
17:43:57 <lambdabot>   <no location info>: parse error on input `Word8..'
17:44:03 <JoeyA> > length [(1 :: Word8) ..]
17:44:04 <lambdabot>   255
17:44:05 <dmwit> twomashi: Nah, just an infinite loop.
17:44:28 <twomashi> sum [1..] then
17:44:57 <JoeyA> @src sum
17:44:57 <lambdabot> sum = foldl (+) 0
17:45:07 <JoeyA> pfft, why isn't it implemented in terms of foldl' ?
17:45:09 <twomashi> might take a few days but it would run out of memory
17:45:25 <JoeyA> Leaks memory when I run it from ghci 7.4.1
17:45:40 <JoeyA> As in, 250MB/s memory leak
17:45:55 <twomashi> JoeyA: the number would grow extremely quickly.
17:47:05 <JoeyA> No, I'm getting thunks piling up.  The number would grow quadratically; the space required, O(log(t^2)) = O(2*log(t)) = O(log t)
17:47:48 <kallisti_> JoeyA: I have no clue, but it should be.
17:48:05 <kallisti_> also @src lies, it's best to check the actual source.
17:48:33 <JoeyA> @src love
17:48:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:48:52 <kallisti_> JoeyA: but I guess the rationale is that not all Num instances work best strictly.
17:49:05 <kallisti_> foldl' is assuming you're dealing with Int, Word, Integer, etc.
17:49:18 <Saizan> sum being implemented with foldl is a long-standing issue from the Report
17:49:42 <Saizan> kallisti_: those that don't generally won't work well with foldl either, but should rather use foldr
17:49:56 <kallisti_> hm, yeah that's true
17:50:21 <Saizan> the rationale is that Report writers overestimated the effectiveness of strictness analysis
17:54:33 <kallisti_> wow, this is a lot of stuff.
17:54:50 * kallisti_ is used to working with projects upwards 1.5k lines
17:54:53 <kallisti_> *isn't
17:55:11 <kallisti_> it's only happened a few times.
17:55:42 <c_wraith> I'm on line 3373 of the current file in my current emacs buffer.  yes, it's haskell code. :)
17:56:04 <kallisti_> I just finished splitting up a 800ish line module into multiple modules because it was "too big"
17:56:44 <c_wraith> This module is way too big.  But it's just tests.  Most of it is data as code
17:56:59 <ion> Data is code is data.
17:57:26 <kallisti_> code is data as code and data is code as data
17:57:55 <kallisti_> and documentation is whitespace
17:58:12 <jfischoff> #zenhaskell
17:58:18 <kallisti_> (really informative whitespace_
17:58:18 <kallisti_> )
17:58:52 <kallisti_> c_wraith: I'm too lazy to be a good tester.
18:00:01 <c_wraith> This project involves json-based web services. With good test support code in place, it's easier to write tests than anything other way of testing the new stuff I write.
18:00:23 <kallisti_> hey so does this code!
18:00:37 * kallisti_ high fives c_wraith
18:01:09 <kallisti_> (note that I interpreted json-based web services to basically mean JSON + HTTP, which my current library falls under)
18:02:10 <c_wraith> Oh.  I'm writing an app server that responds with json
18:02:30 <c_wraith> The test framework is entirely black-box. It makes http requests to it, and checks for expected answers.
18:02:58 <kallisti_> c_wraith: you should use my Selenium bindings. :D :D :D :D
18:03:01 <Martin____> hi, I use hugs98 and just want to use let and it throws an syntax error?
18:03:02 <kallisti_> totally well tested (not really)
18:03:10 <kallisti_> I've used them and they work.
18:03:13 <kallisti_> so that counts for something.
18:03:35 <Martin____> let b = [1,2,3] "and it throws" ERROR - Syntax error in expression (unexpected end of input)
18:03:37 <kallisti_> Martin____: code?
18:03:39 <kallisti_> oh
18:04:00 <kallisti_> is this in a Haskell source file? Because you need to write an in clause
18:04:05 <kallisti_> > let x = 2 in x
18:04:06 <lambdabot>   2
18:04:08 <kallisti_> > let x = 2
18:04:09 <lambdabot>   not an expression: `let x = 2'
18:04:35 <Martin____> no in interpreter
18:04:49 <kallisti_> hm, I'm not familiar with hugs. But in ghci that would be allowed.
18:04:52 <Martin____> but it also makes an error message with in a source file and as module loaded
18:04:57 <Martin____> ok
18:05:55 <Martin____> with as module and loaded it throws ERROR "funktion.hs":7 - Syntax error in input (unexpected keyword "let")
18:06:10 <dmwit> You don't need let in files.
18:06:32 <Martin____> ok
18:06:46 <kallisti_> Martin____: a Haskell source file is already a list of top level bindings and declarations
18:06:51 <Martin____> ok
18:06:55 <kallisti_> so let isn't needed in that.
18:07:20 <kallisti_> a let expression is just that, an expression.
18:07:29 <Martin____> what could I try in the interpreter instead of let = [1,2,3], so that won't work that way
18:07:37 <Martin____> let b = ...
18:07:52 <dmwit> I'm not sure I understood the question, but you could try
18:07:59 <dmwit> let b = [1,2,3] in b
18:08:21 <Martin____> that is it
18:08:26 <Martin____> thank you dmwit
18:08:56 <Martin____> what does in means in that case
18:09:39 <dmwit> It separates a collection of bindings from the expression that uses those bindings.
18:11:24 <Lorehead> Okay, you know how in math class, you might use a variable in an expression?  Like, for example, -0.5 * g * x^2?
18:11:44 <Martin____> ok
18:12:22 <Lorehead> Well, whats g mean, in this context?  One way you might express that is: let g = 9.81 in the expression.  So, let g = 9.81 in -0.5 * g * x^2.
18:12:42 <Lorehead> Another way of putting that would be: -0.5 * g * x^2 where g = 9.81.
18:13:39 <Martin____> ahhh
18:14:01 <Martin____> it puts the binding b = ... in the expression with b and throws the result
18:14:11 <Lorehead> Yeah.
18:14:28 <Martin____> Thanks
18:14:41 <Lorehead> Not exactly the terminology Id use, but I think I get what youre saying.
18:15:40 <Martin____> let b = 1 in b+1 it throws 2
18:16:02 <Martin____> no :D
18:16:22 <rwbarton> "throw" is not the word you want
18:16:23 <Martin____> yes syntax error ok thank you and good night then
18:16:28 <Martin____> ahhh ok, sorry
18:16:34 <rwbarton> perhaps "yields"
18:16:40 <Martin____> have to translate
18:16:58 <napping> Is there a version of HList using type families? I was trying to do something like records and had trouble at a remove function
18:17:25 <Lorehead> The word throws usually refers to exceptions, which are another thing entirely.
18:17:31 <Martin____> yields is good
18:17:50 <Martin____> sorry I'm not that exact
18:19:24 <parcs`> napping: i don't think some hlist things are expressible with type families, specifically things involving conditional type equality
18:20:43 <Martin____> have to go so thank you and good bye
18:21:21 <napping> that's where I had trouble - type instance Remove f (f ': fs) = Remove f fs ; type instance Remove f (g ': fs) = g ': Remove f fs
18:21:48 <parcs`> yeah
18:22:25 <parcs`> you can hackishly do that with functional dependencies
18:25:21 <vhd> how reliable is debug.trace? its printing my trace after the program has halted, and printing the trace string 3 times when it can only run once.
18:26:23 <tkahn6> anyone here interning in san francisco this summer?
18:26:31 <tkahn6> woops wrong channel
18:26:40 <geekosaur> vhd, it is reliably telling you where your expression is being evaluated
18:26:58 <geekosaur> you have more laziness than you think somewhere
18:27:10 <danharaj> also less sharing than you think
18:27:17 <danharaj> if it's printing more than you expect
18:27:26 <vhd> hmm
19:27:05 <tazjin> What optimization level does cabal use by default when building a program? (+ how can I set it?)
19:30:13 <parcs`> O1
19:31:04 <JoeyA> Is there any difference between ghc -O2 and ghc -O3 ?
19:31:29 <parcs`> no, O2 is the maximum
19:32:00 <parcs`> tazjin: you can change it by editing the project's cabal file or passing -O2 to the 'cabal install' command
19:32:19 <tazjin> Yeah, I'm searching for the specific option in the cabal file
19:33:04 <tazjin> the cabal user guide only mentions passing it as an option
19:34:29 <parcs`> ghc-options: -O2
19:36:22 <tazjin> Oh. Yeah, right, thanks :P
20:12:56 <Brolapse> what's the best way to go about breaking up a string to iterate through it comparing letters
20:13:23 <Brolapse> because having it come in as a string, (x:xs) and then comparing x with another character e.g. ","
20:13:26 <dmwit> No need to break it up at all. It's already a list of letters (actually, characters).
20:13:43 <Brolapse> can i not access it like (x:xs)
20:14:04 <dmwit> (x:xs) is a fine pattern for String.
20:14:28 <Brolapse> when i try to compare x == "," with guards
20:14:35 <Brolapse> Couldn't match expected type `[Char]' with actual type `Char'
20:14:42 <dmwit> Perhaps you meant x == ','
20:14:45 <rwbarton> "," isn't a character
20:14:48 <rwbarton> it's a string
20:14:54 <Brolapse> i tried that before
20:15:04 <Brolapse>     Couldn't match expected type `[Char]' with actual type `Char'
20:15:17 <Brolapse> oh wait i'm looking at the wrong part now :)
20:15:17 <rwbarton> You probably have some other error.
20:15:32 <rwbarton> Also, you might just want to use the pattern (',':xs)
20:16:04 <Brolapse> i dont think that would work, i want to test if any of the characters in the string are ','
20:17:13 <rwbarton> Not sure how that is relevant.
20:17:15 <dmwit> I think you're probably confused.
20:17:41 <Orclev_> > filter (==',') "This is an example, or something"
20:17:42 <lambdabot>   ","
20:18:07 <Orclev_> probably not the most performant way to do it though
20:18:21 <Brolapse> i was thinking of filter but it doesnt fit my purpose, i'm breaking up strings with commas seperating them
20:18:46 <Orclev_> ah, there's a function for that, I just can't think of it at the moment
20:18:48 <Twey> Brolapse: Consider using the ‘split’ package from Hackage.
20:18:49 <geekosaur> :t break
20:18:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:18:55 <dmwit> It sounds like you're writing a CSV parser!
20:18:56 <dmwit> Don't do that.
20:18:58 <geekosaur> (or span)
20:19:02 <dmwit> CSV is a terrible format.
20:19:09 <geekosaur> but ==dmwit, if it's CSV, don't do it by hand
20:19:14 <dmwit> If you must, use one of the already-existing CSV parsers online.
20:19:24 <dmwit> If it's just for learning, well, invent a better format first. =)
20:19:25 <Brolapse> dmwit, :P, it's just some silly coursework so CSV will do me
20:19:29 <Twey> There's no function in the standard libraries to do it for arbitrary numbers of separators.
20:19:46 <Brolapse> i thought writing my own would be simple
20:19:54 <Orclev_> huh, I thought there was, oh well
20:20:00 <Twey> It's fairly simple, but not as simple as *not* writing your own.  :þ
20:20:33 <Brolapse> theres one that splits on spaces and one that splits on \n
20:20:45 <dmwit> ?hackage split
20:20:45 <lambdabot> http://hackage.haskell.org/package/split
20:21:09 <Brolapse> oo got it working, though it's coming out backwards
20:21:22 <Brolapse> i could fix it or i could be lazy and just use reverse haha
20:21:51 <Orclev_> well, at any rate it should be able to write something that's fairly trivial with fold
20:22:35 <Orclev_> that was a really mangled sentence... that's what I get for typing half of it, reading something in ghc, and then typing the second half
20:22:55 <Brolapse> how to combine char and string
20:23:06 <Orclev_> ++?
20:23:12 <Orclev_> :?
20:23:12 <Brolapse> string and char i mean
20:23:24 <JoeyA> > "Hello" ++ ['!']
20:23:25 <lambdabot>   "Hello!"
20:23:36 * hackagebot network 2.3.0.13 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.13 (JohanTibell)
20:23:40 <Brolapse> JoeyA, so the char made into a list
20:23:46 <JoeyA> Yes
20:23:52 <Brolapse> <3 ty
20:24:40 <tazjin> @src break
20:24:40 <lambdabot> break p =  span (not . p)
20:24:54 <tazjin> @src span
20:24:54 <lambdabot> span _ xs@[]                     =  (xs, xs)
20:24:54 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
20:24:55 <lambdabot>                   | otherwise    =  ([],xs)
20:25:23 <JoeyA> Sigh, Network.Socket.connect is *still* marked unsafe, even though it can block.
20:26:50 <dmwit> Wait, how are "can block" and "unsafe" in opposition?
20:27:00 <glguy_> JoeyA: Where is it marked "unsafe"?
20:27:24 <glguy_> foreign import CALLCONV unsafe "connect"
20:27:25 <glguy_> ?
20:27:34 <JoeyA> foreign import CALLCONV unsafe "connect"
20:27:35 <JoeyA> Right
20:27:54 <Orclev_> hmm... which is more performant, "Some long string" ++ ['c'] or using Data.Text and doing snoc (pack "Some long string") 'c'
20:28:01 <JoeyA> And on Windows, that can block, since the socket is in blocking mode (since GHC doesn't have proper IO manager support for Windows)
20:29:06 <JoeyA> dmwit: If an unsafe FFI call blocks, it can tie up the whole RTS.
20:29:21 <JoeyA> More precisely, any FFI call that blocks will tie up the whole RTS in a program without -threaded.
20:29:59 <JoeyA> However, with -threaded, when a safe FFI blocks, another OS thread can handle Haskell threads that aren't blocked on FFI calls.
20:30:26 <tazjin> Orclev_: They're both O(n)
20:30:28 <JoeyA> An unsafe call skips steps needed to ensure another thread will be ready to step in.
20:31:23 <JoeyA> (I think that's how it works)
20:31:24 <parcs`> JoeyA: did you inform the maintainer?
20:31:35 <JoeyA> Yup: http://trac.haskell.org/network/ticket/44
20:31:56 <Orclev_> tazjin: is there a way to concatenate either a character or a string to another string that's better than O(n)? I sort of thought that was one of the main selling points to Data.Text
20:32:21 <glguy_> JoeyA: so even with the socket set to non-blocking connect will still block?
20:32:39 <tazjin> Orclev_: Well, there's append from Data.Text for Text -> Text -> Text
20:32:46 <JoeyA> It shouldn't block in that case.
20:33:00 <glguy_> JoeyA: "socket" sets all its sockets non-blocking
20:33:16 <glguy_> and the connect function handles blocking with a threadWaitWrite
20:33:21 <JoeyA> glguy_: But as I said, on Windows the socket is in blocking mode.
20:33:45 <JoeyA> And threadWait* don't quite work on Windows, for the reason I've mentioned.
20:34:05 <dmwit> JoeyA: Oh, that kind of unsafe.
20:34:09 <glguy_> ah (I'm still catching up:) :)
20:34:18 <dmwit> I thought you meant unsafe in the Safe Haskell sense. which was confusing
20:34:56 <JoeyA> I mean unsafe in the FFI call sense.
20:35:05 <glguy_> I see this explained in the comments of the module now
20:35:19 <JoeyA> All Haskell code is unsafe, since you can trap the RTS in a loop by not performing allocation.
20:37:47 <parcs`> JoeyA: it doesn't look like that trac gets much attention
20:38:04 * glguy_ wonders if this is typo "newtype CWchar = CWchar GHC.Int.Int32"
20:38:16 <parcs`> perhaps you should email the maintainer or even ask him on irc (he goes by the name tibbe i think)
20:38:29 <glguy_> Why is this Foreign.C.Types definition not using a capital C for char like everything else?
20:40:19 <JoeyA> I guess because the C type is wchar, and only the first letter is capitalized.  CPtrdiff follows the same convention.
20:40:37 <JoeyA> CULong does not, because the U and L belong to two different words.
20:40:42 <JoeyA> (unsigned and long)
20:40:58 <glguy_> Ah, I see
20:41:15 <glguy_> newtype CSChar = CSChar GHC.Int.Int8 -- I was looking at this, but it is a "signed char" not an "schar"
20:41:38 <JoeyA> But CIntPtr does not appear to follow the convention I mentioned.
20:42:59 <JoeyA> Acme package idea: FFI bindings for setjmp and longjmp.
20:43:30 <JoeyA> :i CJmpBuf
20:43:38 <JoeyA> @hoogle CJmpBuf
20:43:38 <lambdabot> Foreign.C.Types data CJmpBuf
20:46:08 <tibbe> parcs`: what's the issue?
20:47:28 <parcs`> tibbe: have you seen http://trac.haskell.org/network/ticket/44
20:47:31 <glguy_> tibbe: The issue is that JoeyA was filing a bug that network-*'s Network.Socket.connect is blocking
20:47:40 <glguy_> which is bad for people who still use Windows ;)
20:48:20 <tibbe> parcs`: glguy_: This is "by design" i.e. we can't support non-blocking on Windows easily IIRC
20:48:28 <tibbe> there's a comment somewhere in the source about that
20:48:33 <glguy_> (because the import is "unsafe" this is a problem)
20:48:33 <tibbe> perhaps even in the haddock
20:48:34 <JoeyA> And by extension, people who have to write programs for people who still use Windows (because they have to run programs that only run on Windows).
20:49:02 <tibbe> from the docs: NOTE: blocking on Windows unless you compile with -threaded (see GHC ticket #1129)
20:49:05 <glguy_> tibbe: yeah, the haddock does have a  comment about this issue and offers the SAFE_ON_WIN macro as a temporary fix, it seems
20:49:28 <tibbe> if someone who runs windows would like to take a stab at fixing it please go ahead
20:49:35 <tibbe> note that windows has its own I/O manager as well
20:50:26 <tibbe> btw, we long since abandoned Trac for network bug tracking
20:50:38 <tibbe> I should update the .cabal file :/
20:50:45 <tibbe> thought I already have
20:51:07 <tibbe> https://github.com/haskell/network/issues
20:51:31 <glguy_> tibbe: So you are saying that the foreign import for connect should not be marked "safe"?
20:51:45 <tibbe> glguy_: I'm saying I don't know
20:51:54 <tibbe> the issue is very old
20:51:56 <JoeyA> System.Posix.Internals.setNonBlockingFD is a no-op on Windows
20:51:56 <tibbe> predates me
20:51:56 <tibbe> an
20:51:57 <glguy_> anyway, this is JoeyA's bug :)
20:52:10 <tibbe> and we have noone who's willing to maintain the windows part of network
20:52:37 <tibbe> JoeyA: due to the ticket mentioned in the docs perhaps?
20:53:03 <JoeyA> tibbe: My point is, c_connect is being called on a blocking socket on Windows.
20:53:20 <JoeyA> So connect needs to be marked safe, at least on Windows.
20:53:34 <JoeyA> Perhaps the SAFE_ON_WIN macro should be used.
20:53:36 <tibbe> JoeyA: do you know why it's marked as unsafe?
20:53:46 <tibbe> I don't
20:53:58 <tibbe> so either it's an oversight or the person who wrote it did so on purpose
20:54:01 <JoeyA> I don't.  Probably because the author thought it would always be non-blocking
20:54:03 <tibbe> someone needs to figure that out
20:54:12 <tibbe> could be
20:54:20 <tibbe> feel free to change it and test the change
20:54:29 <tibbe> I don't have a valid windows license anymore
20:57:26 <JoeyA> tibbe: Goes back to commit 459910b1: "Catch up with hslibs/net"
20:58:33 <JoeyA> Which set a bunch of other functions unsafe
20:58:42 <tibbe> JoeyA: any comment why?
20:58:55 <JoeyA> Nope
20:58:58 <tibbe> :/
20:59:10 <tibbe> the history of the network project isn't the prettiest
20:59:50 <JoeyA> So what is hslibs/net ?
21:00:00 <tibbe> no idea
21:00:06 <tibbe> probably a relic that's gone
21:00:10 <JoeyA> Google suggests it's a CVS repository somewhere
21:00:14 <tibbe> yeah
21:00:23 <tibbe> perhaps it was a branch at some point that got merged
21:01:55 <tibbe> so generally we're lacking people who understand networking (or are willing to figure out the details) and contribute to network
21:02:07 <tibbe> I'm mostly focused on not breaking the windows support
21:02:16 <tibbe> and merging patches from others
21:02:18 <tibbe> but that's it
21:02:56 <tibbe> afk
21:03:03 <JoeyA> Making connect safe shouldn't break anything, though.
21:04:38 <JoeyA> If it causes any users any issues, I will send another bug report :-)
21:06:22 <JoeyA> But if it helps, I'll attach a small test case to the ticket (after copying the ticket to github) when I get time.
21:06:41 <glguy_> What is the correct behavior for peek in the case that you attempt to peek memory which is not a valid encoding of the object you said it was
21:06:53 <glguy_> Storable's peek
21:09:55 <JoeyA> Are you mapping an enumeration to something like this?  data Color = Red | Orange | Yellow | Green | Blue | Violet
21:10:37 <JoeyA> I'm trying to find a precedent somewhere.
21:10:40 <glguy_> I'm specifically wondering what peek should do for SockAddr when you call it on something that isn't one of the families  that the network library's sockaddr supports (or isn' a sockaddr at all)
21:10:43 <glguy_> https://github.com/haskell/network/issues/32
21:17:45 <JoeyA> glguy_: I'm thinking you could just use error, with a message that includes the number.  That, or add an "UnknownSockAddrFamily" data constructor.
21:26:13 <nyingen> @quote
21:26:13 <lambdabot> psykotic says: so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel
21:26:14 <lambdabot> parking transformation
21:26:43 <monochrom> hahaha that's the greatest Lie group tutorial I have seen
21:28:02 <JoeyA> @quote semi-closed
21:28:03 <lambdabot> No quotes match. :(
21:28:05 <JoeyA> @quote semiclosed
21:28:06 <lambdabot> No quotes match. That's something I cannot allow to happen.
21:28:10 <JoeyA> @quote closed
21:28:10 <lambdabot> MiguelMitrofanov says: The first glimpse of this [logo] vote scared me so much that I've closed the page, stopped the browser, and shut my computer down.
21:29:10 <JoeyA> @quote semicloses
21:29:11 <lambdabot> dmwit says: <dmwit> hGetContents does not close its handle.  <dmwit> hGetContents semicloses its handle.
21:30:03 <JoeyA> That wasn't just a joke.  From the docs: "Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed."
21:30:23 <dmwit> I didn't really intend it as a joke, but really as a near quotation from the docs.
21:30:28 <dmwit> I'm just misunderstood.
21:30:33 <JoeyA> heh
21:30:39 <nyingen> @quote dmwit
21:30:39 <lambdabot> dmwit says: ATOYOTA. Race fast. Safe car. A TOYOTA.
21:30:50 <nyingen> @quote dmwit
21:30:51 <lambdabot> dmwit says: For basically all good properties P, IEEE 754 is not P.
21:30:55 <nyingen> heh
21:31:01 <nyingen> the quotable dmwit.
21:31:07 <mauke> preflex: quote dmwit
21:31:08 <preflex>  <dmwit> For basically all good properties P, IEEE 754 is not P.
21:31:12 <mauke> preflex: quote-count dmwit
21:31:13 <preflex>  dmwit has 1 quote
21:32:15 <sizz> is there any way to force module installation in cabal?
21:32:29 <monochrom> in what sense?
21:32:31 <JoeyA> cabal install --reinstall ?
21:32:50 <JoeyA> Or cabal install --force-reinstall .  Or cabal install --force-reinstalls
21:33:01 <JoeyA> (not sure what the difference among these is)
21:33:08 <sizz> i'm trying to install http-enumerator, but it requires an older version of certificate than is available, so it won't install
21:33:37 <dmwit> No, you can't force it to ignore constraints.
21:33:49 <dmwit> However, you can use cabal unpack and try changing the constraints in the cabal file.
21:33:53 <monochrom> write and install a blank certificate package yourself
21:34:18 <JoeyA> sizz: Sounds like you're installing too-old a version?
21:34:19 <dmwit> If it builds after relaxing the constraints, you're probably fine (but no guarantees).
21:34:19 <monochrom> (to see what's wrong with the idea of forcing in this case)
21:35:01 <JoeyA> sizz: Also, why not use http-conduit?  Michael Snoyman plans to deprecate http-enumerator if nobody's interested in it.
21:35:23 <JoeyA> (I recently switched my code from -enumerator to -conduit, so that's one less user)
21:35:32 <sizz> i'll look into cabal unpack and http-conduit
21:35:33 <Twey> Is -conduit better?
21:35:34 <sizz> thanks
21:35:39 <c_wraith> Twey: it's maintained
21:35:44 <ivanm> Twey: many people think so
21:35:51 <c_wraith> Twey: -enumerator was deprecated like... yesterday
21:35:57 <Twey> Ah
21:35:59 <Twey> ivanm: Why?
21:36:18 <ivanm> Twey: see michael's blog posts when he first announced conduit
21:36:26 <ivanm> better error messages, better resource management, etc.
21:36:29 <JoeyA> Because the Yesod team is transitioning from enumerator to conduit
21:36:48 <JoeyA> Err, they transitioned
21:36:56 <ivanm> JoeyA: that's because they think it's better; it's not better just because they transitioned :)
21:37:03 <Twey> Aha
21:37:17 <sizz> can it use simpleHttp?
21:37:39 <ivanm> though IIUC, the "better error message" part isn't quite as good as it used to be now that they've gone back to type aliases with the pipe-like implementation
21:37:40 <JoeyA> I think simpleHttp stayed the same in both versions (except for the module and package name).
21:38:54 <monochrom> the abduction of http-enumerator: http://article.gmane.org/gmane.comp.lang.haskell.web/2439/
21:39:20 <ivanm> monochrom: "abduction" ?
21:40:07 <monochrom> joke
21:44:13 <Brolapse> how do i go from IO [list] to [list]
21:44:26 <copumpkin> you don't
21:44:33 <copumpkin> you take whatever you wanted to do with [list] into IO
21:44:39 <copumpkin> instead of getting things out of it
21:44:50 <copumpkin> something about mohammed and the mountain
21:45:31 <Brolapse> well is there a way to use getLine without returning IO [list]
21:45:32 <Brolapse> or some other way
21:45:36 <glguy_> copumpkin: Is this where monads come in?
21:45:46 <copumpkin> Brolapse: no
21:46:02 <copumpkin> glguy_: monadmed and the mountain?
21:46:18 <mauke> Brolapse: getLine doesn't return IO [Char], it *is* an IO [Char]
21:46:41 <Brolapse> so how can i take the information inside the list and put it into something useable
21:46:55 <mauke> by using >>=
21:47:12 <copumpkin> that's what I'm saying: you want to take your notion of "usable" (whoever consumes the list) and put that into IO, instead of taking the list out of IO and working on it somewhere else
21:47:15 <JoeyA> do {line <- getLine; putStrLn line}
21:47:24 <JoeyA> Shorthand: getLine >>= putStrLn
21:47:41 <mauke> getLine >>= \line -> putStrLn line
21:47:45 <mauke> while we're at it :-)
21:53:38 * hackagebot tablestorage 0.1 - Azure Table Storage REST API Wrapper  http://hackage.haskell.org/package/tablestorage-0.1 (PhilFreeman)
22:01:04 <monochrom> @quote ls.*contain
22:01:05 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:03:07 <Twey> Ha
22:09:36 <nyingen> @quote monochrom
22:09:36 <lambdabot> monochrom says: [..] the standard library should not come with all conceivable data structures; instead it should come with a coupon for a course on how to design data structures.
22:09:51 <monochrom> hahaha
22:09:59 <nyingen> I always enjoy designing my own hash table
22:11:16 <monochrom> quote a mono a day, keeps the tibbe away?
22:11:41 <shachaf> @quite tibbe
22:11:41 <lambdabot> Maybe you meant: quit quote
22:12:06 * BMeph much prefers monochrom's quote, where he asks how to take the String away from IO String, so he can "just have the IO". ;)
22:12:23 <monochrom> @quote monochrom String
22:12:23 <lambdabot> monochrom says: How do I extract the IO out of IO String?
22:12:54 <BMeph> You Da Man!
22:16:51 <nyingen> @quote BMeph
22:16:51 <lambdabot> BMeph says: (about parsec)> 'Cause it's light-years ahead of the competition!
22:16:57 <nyingen> hurr durr
22:17:04 <nyingen> @quote ytmnd
22:17:04 <lambdabot> No quotes match. Take a stress pill and think things over.
22:17:05 <monochrom> hehehe
22:41:16 <Brolapse> string formatting using printf, how do you pad?
22:48:22 <AfC> Brolapse: "%4s" gives you a 4 wide string, though be aware there are many subtleties regarding wider strings, alignment, etc. I'm not sure if Text.Printf is calling printf(3) or emulating it.
22:50:50 <Veinor> it looks like it just emulates it
23:16:56 <Orclev_> so, I've got this problem where I'm trying to add type signatures to let bindings inside a do block, and it keeps complaining that one of my type variables doesn't match... I know they're the exact same type, but I don't know what that type is... if I rename the type it complains it doesn't match, and if I keep the name the same it complains it doesn't match
23:17:36 * BMeph coughs: -XScopedTypeVariables
23:17:49 <BMeph> Sorry, must be a spring cold... ;)
23:18:17 <Orclev_> hmm, nope still complaining about it
23:19:00 <Orclev_> Couldn't match type `t' with `t1' `t' is a rigid type variable bound by the type signature for... etc.
23:19:18 <Orclev_> if I rename t to t1 it just flip flops the names in the error message
23:19:50 <Veinor> could you hpaste your code?
23:20:04 <Orclev_> yeah, give me a min
23:20:26 <Brolapse> what's a simple way to order a list e.g. [age,name] order by name
23:20:33 <Brolapse> or age
23:20:55 <Veinor> Brolapse: are they a list of tuples?
23:21:23 <Brolapse> [String, String, Int, [String, Float]]
23:21:30 <Veinor> that's... not a type that makes sense
23:21:54 <Veinor> > sortBy (comparing `on` fst) [(1, "hi"), (0, "zzz"), (1.5, "quux")]
23:21:55 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> a
23:22:05 <Veinor> ?
23:22:18 <Veinor> oh right
23:22:24 <Veinor> > sortBy (comparing fst) [(1, "hi"), (0, "zzz"), (1.5, "quux")]
23:22:25 <lambdabot>   [(0.0,"zzz"),(1.0,"hi"),(1.5,"quux")]
23:22:28 <Brolapse> [(String, String, Int, Float)] is the structure sorry
23:22:33 <Veinor> > sortBy (comparing snd) [(1, "hi"), (0, "zzz"), (1.5, "quux")]
23:22:34 <lambdabot>   [(1.0,"hi"),(1.5,"quux"),(0.0,"zzz")]
23:22:48 <Veinor> if you have a data type like that you should probably declare your own instead of passing around tuples
23:23:15 <Veinor> something like data Person = Person { firstName :: String, lastName :: String, age :: Int, someOtherQuantity :: Double }
23:23:35 <hpaste_> Orclev_ pasted “Say what?” at http://hpaste.org/67525
23:24:44 <Veinor> Orclev_: and if you do etickDelta :: R.Event t Word32?
23:24:57 <Orclev_> same error but the t1 and t reversed
23:25:17 <Orclev_> oh, actually the R. can be ignored, that's a typo
23:25:24 <Veinor> ah ok
23:25:43 <Orclev_> the type of both is Event t Word32
23:26:29 <Veinor> so etickDelta :: Event t Word32 doesn't work?
23:26:36 <Veinor> (leaving the type of setup the same)
23:26:36 <Orclev_> nope
23:26:43 <mauke> obviously
23:26:43 <Orclev_> that's what it is now
23:26:53 <mauke> Orclev_: what if you remove line 5?
23:27:37 <hpaste_> “that guy” annotated “Say what?” with “Say what? (annotation)” at http://hpaste.org/67525#a67526
23:28:07 <Orclev_> then further down I get more type errors, I was trying to trace it back to it's root by adding explicit type signatures till I found the one that didn't match up, but it broke at the very first one with this screwy error
23:28:34 <mauke> it's not "screwy"
23:28:42 <mauke> type variables are implicitly forall quantified
23:28:55 <Orclev_> hmm, I'll try adding the forall on there
23:28:57 <Veinor> ... ah, that's what ScopedTypeVariables does
23:29:24 <Veinor> Orclev_: enable ScopedTypeVariables and change the t1 to t
23:29:28 <Veinor> like in http://hpaste.org/67525#a67526
23:29:51 <Orclev_> did that, same error
23:30:24 <c_wraith> you need explicit foralls with ScopedTypeVariables
23:30:40 <c_wraith> that annotation looks right
23:30:59 <Orclev_> adding the forall didn't fix it either... I wonder if the type error is something else entirely and it's just latching on to the wrong part
23:31:37 <Orclev_> going to try pulling it out into smaller top level functions and see if I can track it down that way
23:31:47 <Veinor> Orclev_: did you include the forall in the type of setup?
23:31:52 <Orclev_> Veinor: yes
23:32:08 <Orclev_> Veinor: and in the type of etickDelta
23:32:12 <mauke> Orclev_: bzzt, wrong
23:32:18 <Veinor> don't put it in the type of etickDelta, just setup
23:32:48 <Orclev_> ah, ok, now I'm getting a different saner type error
23:33:11 <Orclev_> perfectly that's where I was trying to get to
23:33:18 <Orclev_> perfect even
23:33:47 <Orclev_> so, why is the forall t. necessary at the top level but not inside the let statement?
23:34:10 <mauke> <mauke> type variables are implicitly forall quantified
23:34:19 <Veinor> if you put a forall inside the let statement, then what you were saying is 'for any type t, etickDelta has the type Event t Word32'
23:34:35 <mauke> so when you had 'Event t Word32' that wasn't the same 't' as setup's
23:34:37 <Veinor> but that's obviously not true, because the type t might not be the same as the type t that's in the type of setup
23:35:03 <Orclev_> ok, that makes sense there, but why is it necessary to put the forall at the top level then?
23:35:16 <mauke> "rigid type variable" is the compiler saying "hold on, you can't use any type you want here. it has to be the same type as in setup!"
23:35:36 <mauke> ScopedTypeVariables is a language extension that changes how type variables work
23:35:38 <Veinor> that, i'm not sure about
23:35:47 <mauke> but it doesn't change standard H98 type signatures
23:35:56 <mauke> it only changes the scope of variables introduced with 'forall'
23:36:17 <mauke> and it makes them visible in any type signature in setup's body
23:37:00 <Veinor> ah
23:37:01 <Orclev_> ah, so the effect of ScopedTypeVariables is two fold, you need to explicity add a forall, but it also causes declarations inside the body to inherit the type variables?
23:37:20 <mauke> ... inherit the type variables created by 'forall'
23:37:49 <mauke> variables created without an explicit 'forall' remain local to the type signature they're in
23:37:50 <Veinor> note that ScopedTypeVariables doesn't make you use the forall everywhere. just wherever you want to inherit type variables.
23:38:51 <Orclev_> that's good to know, I ran into a similar problem previously but after putzing around with it for an hour or so I just rewrote the code to not use the type signature in the let binding
23:42:57 <Orclev_> yay, no more type errors... the last one was a , after a constructer arguments, used to languages that make you seperate variables with ,s
23:56:21 <MHD0> Hmmm. Error Monoids are underrepresented
23:57:07 <MHD0> within e m = m `catchError` (mappend e)
23:57:16 <MHD0> Is such a useful combinator
23:57:24 <MHD0> Especially in parsing
