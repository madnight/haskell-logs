00:00:39 <edwardk> @tell roconnor not sure what you've been up to with your dev branch of data-lens, but i had to push a version 2.0.3 to fix dependency changes, fyi
00:00:39 <lambdabot> Consider it noted.
00:03:00 <Zamarok> Is there a function in Hackage that will determine if a Realfrac has reapeating decimal digits?
00:03:09 <Zamarok> Specifically a Rational
00:03:12 <elliott> Control/DeepSeq.hs:56:1:
00:03:12 <elliott>     array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe.
00:03:15 <elliott> edwardk: lhc really hates me.
00:09:06 <Zamarok> Anyone know how to determine if a rational will be a finite or infinite decimal?
00:09:42 * hackagebot free 2.1 - Monads for free  http://hackage.haskell.org/package/free-2.1 (EdwardKmett)
00:09:44 * hackagebot groupoids 0.2.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.2.1 (EdwardKmett)
00:10:12 <c_wraith> Zamarok: determine if the denominator's factors are only 2 and 5?
00:10:14 <shachaf> Zamarok: In base 10, all the prime factors of the (simplified) denominator are either 2 or 5.
00:10:14 <Zamarok> I can't think of a way that doesn't involve actually evaluating the digits.. which leads to infinite calculation. My code for finding the repeating part works, but only on infinitely repeating ratios like (5%7), but not (1%2)
00:10:30 <Zamarok> That's interesting.. let's see.
00:10:37 <shachaf> Zamarok: 1%2 is repeating! 0.50000...
00:10:46 <shachaf> There's always a repeating part.
00:10:54 <Zamarok> Well yes, but I mean ones with non-zero digits
00:11:00 <Zamarok> like (1%9)
00:11:13 <shachaf> Anyway, less code, more mathematics.
00:11:32 <edwardk> Zamarok: 9 has two 3s in it, which are neither 2 not 5 ;)
00:11:41 <edwardk> er nor
00:12:09 <hpaste> Zamarok pasted “repeatingDigits” at http://hpaste.org/66692
00:12:31 <shachaf> Also, this is a "project euler" problem, isn't it. :-(
00:12:34 <Zamarok> That's what I have so far. Try it on (5 % 7) or (1 % 983).
00:12:47 <edwardk> > 5 % 7
00:12:48 <lambdabot>   5 % 7
00:12:56 <elliott> thanks lambdabot
00:12:59 <Zamarok> Well, I solved the problem with intuition, not code.. but after I solved it I wanted to code it
00:13:04 <edwardk> > fromRational (5 % 7)
00:13:05 <lambdabot>   0.7142857142857143
00:13:25 <edwardk> 7 isn't made up of 2s and 5s
00:13:34 <shachaf> > 2 + 5
00:13:35 <lambdabot>   7
00:13:38 <shachaf> QED
00:13:39 <edwardk> =P
00:14:20 <shachaf> Zamarok: Your life will probably be easier* if you generalize it to an arbitrary base.
00:14:26 <Zamarok> shachaf: is there a rule against chatting about projectEuler problems? I mean, this code could be used on a great many PE problems, and it has real-life applications
00:14:46 * hackagebot eq 0.3.6 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.6 (EdwardKmett)
00:14:48 * hackagebot void 0.5.5.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.5.1 (EdwardKmett)
00:15:01 <elliott> poor edwardk
00:15:17 <danharaj> is it time for another edwardk package cascade? :D
00:15:25 <shachaf> Zamarok: There's no rule, it's just that the solutions to all the interesting ones have very little to do with Haskell.
00:15:26 <edwardk> yep
00:15:34 <edwardk> because SOMEONE made me update semigroups
00:15:39 <edwardk> to make it hugs compatible
00:15:43 <Zamarok> shachaf: oh ok
00:15:45 * elliott hides
00:15:53 <danharaj> Asking edwardk to update a package is like setting off a deadly thunk.
00:15:56 <edwardk> and there are a bunch of other changes that have been lurking waiting to happen
00:16:00 <elliott> maybe i should try and get every edwardk package i can working on hugs
00:16:04 <elliott> just to maximise his fun
00:16:06 <edwardk> elliott: =P
00:16:27 <danharaj> edwardk `seq` cabal install semigroup
00:16:32 <edwardk> anyways this was also triggered by the new version of transformers
00:16:37 <Zamarok> shachaf: so why not default to base 10? I don't see the benefit, but I've never really done any math like this before
00:17:40 <shachaf> Zamarok: The idea is that if you abstract the base away, all the irrelevant details (like 2 and 5) go away, and you're left with just the interesting part.
00:18:09 <elliott> Configuring lhc-0.10... setup: Package lhc-0.10 can't be built on this system. cabal: Error: some packages failed to install: lhc-0.10 failed during the building phase. The exception was: ExitFailure 1
00:18:13 <elliott> WHAT DO YOU WANT FROM ME?!
00:18:26 <elliott>  if impl(ghc == 6.12.*) && arch(x86_64)
00:18:26 <elliott>   buildable:         True
00:18:26 <elliott>  else
00:18:26 <elliott>   buildable:         False
00:18:29 <elliott> what.
00:18:32 <Zamarok> hmm I'll try
00:18:44 <elliott> oh, lhc hasn't been updated since 2010!
00:18:52 <danharaj> woop
00:19:05 <elliott> this explains a lot
00:19:21 * koninkje thought lhc died
00:19:30 <elliott> probably it did
00:19:32 <elliott> 2010 is pretty dead
00:19:36 <elliott> but edwardk had to mention it
00:19:40 <edwardk> =)
00:19:59 <edwardk> i figured if i set you to an impossible task i'd get you out of my hair for a whie ;)
00:20:18 <koninkje> I'm always sad when fledgling Haskell compilers die off
00:20:52 <edwardk> that reminds me i should get back to working on turbohaskell some time
00:20:53 <koninkje> they all seem to die right after all the infrastructure gunk has been done, but before they're fully functional
00:21:05 <edwardk> koninkje: we call that the cabal wall
00:21:21 <koninkje> And then there's Hugs, which just lost the race
00:21:50 <koninkje> I'm glad JHC was revived and UHC seems to be making progress
00:22:01 <elliott> (isn't jhc lowercase?)
00:22:29 <elliott> jhc interests me because of its weird typeclass repr.
00:22:34 <elliott> i'm not sure it could use the fast impl of reflection
00:22:37 <elliott> if it had mptcs
00:22:54 <elliott> wow, this lhc code assumes Monad has a Functor superclass or something
00:23:14 <zzo38> I made a program to draw a triangle on a DVI document, but, how to make draw polygon, ellipse, line of thickness, path of line segments of specified thickness such that they will be joined together properly, ...
00:23:16 <zzo38> Do you know?
00:23:41 <koninkje> well, I'm off to bed. Work tomorrow
00:24:42 * hackagebot charset 0.3.0.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.0.1 (EdwardKmett)
00:28:09 <elliott> does anyone have ghc 6.12 lying around?
00:28:56 <edwardk> pretty sure the fast implementation is right out with jhc
00:29:29 <edwardk> i am not even half way through updating =(
00:29:42 * hackagebot persistent 0.9.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.9.0.1 (MichaelSnoyman)
00:29:44 * hackagebot persistent-mongoDB 0.9.0.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.9.0.1 (MichaelSnoyman)
00:30:21 <elliott> uugh
00:30:24 <elliott> shachaf: you have 6.12 right?
00:30:38 <shachaf> elliott: Nope.
00:30:58 <elliott> :(
00:31:00 <Enigmagic> 6.12 makes me cry
00:34:46 * hackagebot persistent-mysql 0.9.0.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.9.0.1 (MichaelSnoyman)
00:34:49 * hackagebot persistent-postgresql 0.9.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.9.0.1 (MichaelSnoyman)
00:34:50 * hackagebot persistent-sqlite 0.9.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.9.0.1 (MichaelSnoyman)
00:34:52 * hackagebot persistent-template 0.9.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.9.0.1 (MichaelSnoyman)
00:34:54 * hackagebot pool-conduit 0.1.0.1 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.0.1 (MichaelSnoyman)
00:36:04 <elliott> edwardk: hmm, would this be reflection 1.1.4 or 1.2?
00:36:18 <edwardk> did you change the api?
00:36:39 <edwardk> if not then 1.1.4
00:36:41 <elliott> oh, right, I didn't, I was wondering because of the tagged dep, but that doesn't matter
00:36:51 <elliott> such a small version increase for such an achievement ;)
00:36:58 <edwardk> welcome to my life
00:37:21 <elliott> @quote elliott majesty
00:37:21 <lambdabot> No quotes match. Maybe you made a typo?
00:37:23 <elliott> @quote edwardk majesty
00:37:23 <lambdabot> edwardk says: <elliott> cmccann: the instances list haddock generates is now a thing of majesty  <edwardk> elliott: welcome to my world
00:38:11 <edwardk> ok, so i'm not a very original thinker ;)
00:38:54 <elliott> (how does p && q || r parse? I'm useless with operator precedences :( )
00:39:56 * hackagebot servius 1.0.0.1 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.0.0.1 (MichaelSnoyman)
00:39:59 * hackagebot shakespeare 1.0.0.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.0.1 (MichaelSnoyman)
00:40:00 * hackagebot shakespeare-css 1.0.1.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.1.1 (MichaelSnoyman)
00:40:02 * hackagebot ad 1.3.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.3.1 (EdwardKmett)
00:40:04 * hackagebot shakespeare-i18n 1.0.0.1 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0.1 (MichaelSnoyman)
00:40:41 <Enigmagic> > True && False || True
00:40:42 <lambdabot>   True
00:41:05 <Enigmagic> > True && False || False
00:41:07 <lambdabot>   False
00:41:08 <elliott> Enigmagic: you realise that's True independent of how they parse?
00:41:11 <edwardk> (p&&q)||r
00:41:15 <elliott> right
00:41:40 <Enigmagic> elliott: yes, i'm also on slow internet
00:41:54 <gnoi> Enigmagic: lucky one
00:42:23 <gnoi> False || True && False
00:42:27 <gnoi> > False || True && False
00:42:29 <lambdabot>   False
00:42:34 <edwardk> i miss the slow internet. this new fast one with all the video ads gets kind of annoying from time to time
00:42:44 <Enigmagic> gnoi: lucky that it's slow?
00:43:00 <gnoi> Enigmagic: yeah, edwardk undestand me
00:43:11 <Enigmagic> ad block plus ... don't see too many ads nowadays
00:43:51 <edwardk> just cats, eh?
00:44:14 <Enigmagic> i don't go to sites that have cats :P
00:44:19 <elliott> that was chrome adblock :P
00:44:41 <edwardk> ah
00:44:42 <edwardk> forgot
00:45:06 * hackagebot shakespeare-js 1.0.0.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.0.1 (MichaelSnoyman)
00:45:08 * hackagebot shakespeare-text 1.0.0.1 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.1 (MichaelSnoyman)
00:45:10 * hackagebot wai 1.2.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.2.0.1 (MichaelSnoyman)
00:45:12 * hackagebot wai-app-static 1.2.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.2.0.1 (MichaelSnoyman)
00:45:14 * hackagebot wai-eventsource 1.2.0.1 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.2.0.1 (MichaelSnoyman)
00:46:37 <hpaste> elliott pasted “wat” at http://hpaste.org/66693
00:48:01 <elliott> $ cabal-dev install --hugs --with-cpphs="$(which cpphs-hugs)" --hugs-options="-98 +o" --hugs-option=-F'cpp -P -traditional' --hugs-option=-P':{Home}/.cabal/lib/hugs/packages/*'
00:48:10 <elliott> hooray for hugs
00:50:16 * hackagebot wai-frontend-monadcgi 1.2.0.1 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.2.0.1 (MichaelSnoyman)
00:50:19 * hackagebot wai-handler-devel 1.2.0.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.2.0.1 (MichaelSnoyman)
00:50:20 * hackagebot wai-handler-fastcgi 1.2.0.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.2.0.1 (MichaelSnoyman)
00:50:22 * hackagebot wai-handler-launch 1.2.0.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.2.0.1 (MichaelSnoyman)
00:50:24 * hackagebot wai-handler-scgi 1.2.0.1 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.2.0.1 (MichaelSnoyman)
00:51:06 <edwardk> clearly snoyman is winning in the race to destroy hackage
00:51:33 <edwardk> is automated approach is much faster than my hand-written one
00:51:35 <edwardk> er his
00:51:42 <clintm> hehe.... he's a machine!
00:51:42 <lambdabot> clintm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:52:03 <hpaste> Zamarok annotated “repeatingDigits” with “repeatingDigits (annotation)” at http://hpaste.org/66692#a66694
00:52:25 <Zamarok> There we go, fixed it.
00:52:29 <edwardk> i think snoyman is the man, snoyberg is the machine
00:52:35 <edwardk> its really snoyborg
00:52:49 <clintm> edwardk: hrm, never thought of it that way.
00:52:57 <clintm> hah
00:53:41 <Enigmagic> i'm surprised you do it all by hand
00:54:03 <edwardk> hard to do otherwise given the crazy dependency graphs
00:54:07 <elliott> snoyman may have his fancy "tools" and "programs"
00:54:11 <elliott> but edwardk has GREP
00:54:22 <edwardk> and given the fact that as i go i often discover some of these things require major version bumps, etc.
00:54:31 <edwardk> elliott++
00:54:35 <edwardk> and find
00:54:49 <elliott> have you considered just removing all version constraints?
00:54:51 <edwardk> i've been known to employ sed and perl on occasion too =P
00:54:55 <Enigmagic> crazy like what?
00:55:03 <Enigmagic> no roots?
00:55:10 <elliott> Enigmagic: see graph on http://hackage.haskell.org/package/category-extras
00:55:23 <elliott> and that's incomplete
00:55:26 * hackagebot wai-test 1.2.0.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.2.0.1 (MichaelSnoyman)
00:55:28 * hackagebot wai-websockets 1.2.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.2.0.1 (MichaelSnoyman)
00:55:30 * hackagebot warp 1.2.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.0.1 (MichaelSnoyman)
00:55:32 <Enigmagic> that doesn't look that crazy
00:55:32 * hackagebot warp-static 1.2.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.2.0.1 (MichaelSnoyman)
00:55:35 * hackagebot yesod 1.0.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.0.1 (MichaelSnoyman)
00:55:37 <edwardk> Enigmagic: and some of these need to have wider ranges than others
00:55:43 <edwardk> Enigmagic: thats because its about 20% of it
00:56:03 <edwardk> it contains only what was broken out of category-extras
00:56:16 <Enigmagic> still doesn't sound crazy
00:56:22 <elliott> sounds like Enigmagic is volunteering
00:56:46 <edwardk> anyways some packages need to be able to allow multiple versions of external libraries, others don't, almost every major version change somewhere else necessitates some subset getting a major version bump
00:56:55 <edwardk> but if i bump all my major versions, then i cause problems
00:57:18 <elliott> is this really better than category-extras? :P
00:57:23 <edwardk> elliott: i'm not sure
00:57:28 <Enigmagic> elliott: i'm only 1/3 of the way through replacing cabal-install :P
00:57:35 <edwardk> thats why i've reverted to the 'mega-package' approach
00:57:39 <edwardk> with trifecta and algebra
00:57:50 <elliott> Enigmagic: howso?
00:58:05 <Enigmagic> elliott: no upload functionality
00:58:10 <Enigmagic> for one
00:58:12 <elliott> i mean
00:58:17 <elliott> what are you replacing it with, and why?
00:58:30 <Enigmagic> bumping versions seems like something lots of people have to do now, so it should be in a common tool
00:58:40 <elliott> edwardk: honestly, i think you could have something as easy as the mega-package stuff with a sufficiently smart program maintaining the actual cabal files
00:58:45 <elliott> but it'd probably be a pain to write in the first place
00:58:52 <edwardk> there is the rub
00:59:12 <Enigmagic> elliott: we use this for our builds and some cabal-install sorts of things https://github.com/alphaHeavy/shake-install
00:59:15 <edwardk> plus other people like submitting patches
00:59:33 <Enigmagic> elliott: eventually i'll just have it pull from hackage too since it already builds crap in parallel :P
01:00:14 <Enigmagic> probably the next time i have to bump compilers i'll just hack that in
01:00:28 * elliott increasingly thinks we should just get rid of hackage
01:00:37 * hackagebot yesod-core 1.0.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.0.2 (MichaelSnoyman)
01:00:39 * hackagebot either 0.3 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.3 (EdwardKmett)
01:00:41 * hackagebot data-lens-fd 2.0.1 - Lenses  http://hackage.haskell.org/package/data-lens-fd-2.0.1 (EdwardKmett)
01:00:43 * hackagebot zlib-conduit 0.4.0.1 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.4.0.1 (MichaelSnoyman)
01:00:43 <edwardk> elliott: did you use haskell before hackage?
01:00:45 * hackagebot graphs 0.4 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.4 (EdwardKmett)
01:01:00 <elliott> edwardk: no, but before hackage was also before github
01:01:27 <edwardk> you want dependencies on repos?
01:01:36 <elliott> sure
01:01:40 <elliott> or branches, tags of repos
01:01:42 <edwardk> fair
01:01:56 <edwardk> i'll say this though
01:01:58 <edwardk> the moment you do
01:02:04 <elliott> branches are where the api-compatibility work goes on anyway, and with widespread use of topic branches, they're already meant to be stable
01:02:07 <edwardk> some large percentage will put their stuff up on their own server
01:02:13 <elliott> edwardk: yep
01:02:14 <edwardk> then they'll get bored with the community
01:02:16 <edwardk> and go away
01:02:19 <edwardk> and the servers will die
01:02:32 <elliott> yes, that's fair -- however i think it can be mitigated
01:02:44 <shachaf> That's why the world needs a global DHT.
01:02:47 <elliott> (but i do agree it's a major problem)
01:02:58 <shachaf> Which is content-addressed.
01:02:59 <osfameron> DHT?
01:03:08 <shachaf> Where people can just depend on a git revision hash.
01:03:26 <osfameron> ah, distributed hash table
01:03:26 <elliott> edwardk: one solution is just to have a few people run a tool which spiders announced packages and archives all the packages they reference, internet archive-style
01:03:36 <elliott> edwardk: we could reassign the hackage machine to it ;)
01:03:45 <edwardk> elliott: reasonable
01:03:46 <Veinor> this reminds me of an issue i was running into
01:04:12 <edwardk> elliott: if i were designing a new language i'd probably do that
01:04:18 <Veinor> ... oh maybe i'm just doing it wrong
01:04:22 <edwardk> but i'm not in a clean room ;)
01:04:42 <edwardk> er.. well, thats just the fact that i haven't cleaned up lately..
01:04:44 <edwardk> but aside from that
01:04:50 <elliott> edwardk: not that i think a hackage-style index is inherently a bad thing -- but from the issues with the hackage software itself, to the dependency hell we get because cabal is kinda dumb and can't support multiple versions well, I think its usefulness as an archive + index + docsite is outweighed by all the ugh
01:05:14 <elliott> (those same spidering machines could host a "hackage2-style" popularity-ranked index, and build docs)
01:05:32 <elliott> (at which point you get a more distributed hackage with better dependency handling)
01:06:18 <edwardk> like i said, if i were doing it over, i'd probably consider going that route, but before hackage, everything was a nigh uninstallable mess
01:06:22 <elliott> yeah
01:06:57 <Enigmagic> so when's hackage 2 going to be released ?:P
01:07:08 <edwardk> enigmagic: get the community a maintainer for it =P
01:07:18 <edwardk> Enigmagic: thats what kept it from going live in the first place
01:07:22 <elliott> i make the bold prediction of never
01:07:27 <elliott> just like the next version of cabal will never be released
01:07:31 <Enigmagic> i'll maintain it if it's statically generated
01:07:38 <Enigmagic> :P
01:07:46 <elliott> perhaps they'll be never-released long enough for me to write tinc, the perfect cabal-install successor that does everything my way
01:07:48 <Enigmagic> rsync to s3
01:08:08 <elliott> oh snap, that's accidentally the perfect name for a cabal replacement
01:08:12 <edwardk> anyways its being worked on
01:08:25 <edwardk> tinc?
01:08:28 <edwardk> this is not cabal?
01:08:36 <elliott> there is no cabal
01:08:43 <elliott> (cf http://en.wikipedia.org/wiki/Backbone_cabal)
01:08:54 <elliott> but that backronym would also work, yes :)
01:09:16 <Veinor> can you make the logo be some kind of reference to http://en.wikipedia.org/wiki/File:There%27s_no_cabal.png
01:09:38 <elliott> i think that would be almost impossible
01:09:44 * hackagebot hyphenation 0.2.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1 (EdwardKmett)
01:09:46 * hackagebot wl-pprint-extras 1.6.2 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6.2 (EdwardKmett)
01:09:48 * hackagebot wl-pprint-extras 1.6.3 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6.3 (EdwardKmett)
01:09:50 * hackagebot csv-conduit 0.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.1 (OzgunAtaman)
01:09:52 * hackagebot wl-pprint-terminfo 0.8.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.3 (EdwardKmett)
01:10:00 <kallisti> elliott: how do I put a description below a section heading in haddock?
01:10:01 <Veinor> the broom over the eye
01:10:15 <kallisti> do I... put it under the section heading? :P
01:10:20 <elliott> yes
01:10:24 <kallisti> amazing.
01:13:30 <mcstar> data  (Integral a)      => Ratio a = !a :% !a  deriving (Eq)
01:13:38 <mcstar> what are the ! marks here?
01:13:45 <elliott> strictness annotations
01:13:47 <mcstar> and why doesnt this work in ghci?
01:14:00 <mekeor> mcstar: usually things are lazy in haskell. ! makes them strict.
01:14:04 <elliott> because ghci doesn't do data declarations in < 7.4
01:14:17 <mekeor> mcstar: think of ghci as a do-block.
01:14:20 <mcstar> i have 7.4.1
01:14:27 <mekeor> you can't define data-types in a do-block.
01:14:32 <elliott> edwardk: i'll have a reflection patch for you sometime in the next year once i convince hugs to be reasonable
01:14:32 <mcstar> its weird, cause it says: Illegal datatype context (use -XDatatypeContexts):
01:14:39 <shachaf> mekeor: That's wrong in GHC 7.4.1
01:14:42 <edwardk> elliott: sounds good
01:14:45 <shachaf> mcstar: That's because you're using a datatype context.
01:14:46 <mcstar>  Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language
01:14:51 <mekeor> shachaf: ah, cool. i didn't know that. nice.
01:14:52 <shachaf> mcstar: I.e., data Foo a => ...
01:15:02 <shachaf> mcstar: It's telling you exactly what the problem is in the error message.
01:15:06 <shachaf> Just read the error message. :-)
01:15:09 <edwardk> mcstar: data Integral a => … isn't used any more
01:15:17 <shachaf> mcstar: However, you shouldn't use datatype contexts. They're deprecated for ar eason.
01:15:34 <edwardk> mcstar: it hasn't been useful since 1998, so they just got rid of it
01:15:35 <mcstar> i mean, it says i should use the -XDatatypeContexts, after that it tells me it is deprecated
01:15:39 <mcstar> k
01:16:02 <mekeor> shachaf: what's the reason?
01:16:08 <gnoi> > !10
01:16:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:16:12 <shachaf> mcstar: You can use that option if you want to enable them.
01:16:12 * mekeor thinks its practical..
01:16:17 <shachaf> mcstar: But you don't want to enable them.
01:16:18 <kallisti> hm, haddocks linking doesn't seem to work with operators
01:16:21 <shachaf> mekeor: It does nothing.
01:16:23 <mcstar> ok
01:16:31 <kallisti> '(.:)' leaves the apostrophes in verbatim.
01:16:31 <shachaf> @google why not datatype contexts?
01:16:33 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
01:16:33 <lambdabot> Title: NoDatatypeContexts – Haskell Prime
01:16:37 <mcstar> when i said in ghci, i meant i loaded the file into ghci
01:16:54 <mcstar> i think the do block thingy doesnt apply then
01:17:05 <mekeor> shachaf: sure it does.  Num a => makes sure that (+), (-), (*) &c are defined on a, e.g.
01:17:05 <edwardk> mcstar: the old notion of data Foo a => Bar a = … is gone. you just have data Bar a = ...
01:17:06 <lispy>  if you really want the constraint then use a GADT
01:17:19 <shachaf> mekeor: No, it doesn't.
01:17:22 <edwardk> lispy: though the GADT constraint means something different than the old data type constraint
01:17:22 <shachaf> mekeor: Read that web page.
01:17:29 <lispy> But for most stuff, you just want the constraint when you define some, but not all, functions so just leave the constraint off
01:17:30 <kallisti> how do I link to operators in haddock...
01:17:36 <shachaf> The GADT constraint is useful, yes, but it's a completely different thing.
01:17:53 <mcstar> thanks all
01:18:09 <edwardk> mekeor: data Num a => Foo a = …     puts the requirement that that dictionary be available when you go to make a value of type Foo. However, it doesn't PUT that dictionary anywhere
01:18:33 <edwardk> mekeor: whereas with the GADT data Foo a where Foo :: Num a => … that means to store it in the data constructor
01:18:47 <mekeor> ah, i got it.
01:18:56 <edwardk> mekeor: the former is almost never what you want, because it forces extra dictionary constructions and never helps
01:18:58 <kallisti> hm I think you just omit the parens.  so '.:' instead of '(.:)'
01:19:00 <edwardk> the latter is quite useful
01:19:29 <edwardk> the main thing it has led to is that you couldn't make Ratio and Complex into Functor instances or Traversable or Foldable, etc.
01:19:32 <mekeor> shachaf: yea, that link was useful. nice. thanks
01:19:35 <lispy> THis is why Haskell98 is completely broken </troll> :)
01:19:41 <elliott> edwardk: how inconvenient is it for you when you need to make a new tagged release?
01:19:47 <mcstar> my example is from base-4.3.1.0, i guess i should take a look at a more recent version
01:19:52 <edwardk> elliott: *groan*
01:19:52 <elliott> oh god
01:19:58 <elliott> oh god
01:20:06 * edwardk arches an eyebrow
01:20:13 <elliott> so, it turns out that the reason cabal install is so fast with hugs is that it doesn't actually load the code at all
01:20:15 <elliott> it just copies it
01:20:43 <edwardk> sounds er.. fast
01:20:51 <elliott> erm
01:20:53 <elliott> so
01:20:54 <elliott> insert  :: Foldable f => Ord a => a -> f a -> NonEmpty a
01:20:55 <elliott> what's up with this
01:20:59 <elliott> in semigroups
01:21:03 <elliott> hugs doesn't like that one bit
01:21:21 <edwardk> elliott: i'll fix it
01:21:27 <edwardk> ghc likes it fine ;)
01:21:32 <elliott> lemme test some more first
01:21:38 <elliott> btw the comment with the type sig at the top is outdated too
01:22:04 <elliott> uh oh
01:22:22 <elliott> i think i might have just _really_ ruined edwardk's day
01:22:39 <edwardk> now what?
01:22:51 <hpaste> elliott pasted “oops” at http://hpaste.org/66695
01:23:30 <edwardk> elliott: can't help you there ;)
01:23:33 <elliott> see, since i assumed that cabal was actually loading this code, and since I'd previously verified everything worked correctly when I ripped out the semigroups dependency (and instance) from tagged
01:23:42 <edwardk> haha
01:23:43 <elliott> i just assumed that semigroups itself was working, since it cabal installed
01:23:48 <elliott> it... doesn't
01:23:54 <edwardk> sweet
01:24:03 <edwardk> only 5 hours so far ;)
01:24:26 <elliott> i forget, how much did you hate the idea of tagged losing the Semigroup instance
01:24:28 <edwardk> i'll let you track down how to fix those two then
01:24:33 <edwardk> pretty badly
01:25:08 <elliott> well... is it OK to #ifdef out the instance for Last? whenever anyone would use it, they'd have to depend on the newer base version anyway
01:25:17 <elliott> so there's no conceivable breakage I can think of, if it's conditioned on Last actually being present
01:25:21 <shachaf> #ifdefs. :-(
01:25:25 <elliott> oh wait!
01:25:31 <elliott> edwardk: you just import Data.Monoid hiding (Last)
01:25:38 <elliott> all I have to do is change it to an explicit import list
01:25:44 <elliott> *phew*
01:26:04 <edwardk> i just dropped the dependency from Tagged
01:26:06 <edwardk> one sec
01:26:09 <elliott> wait!
01:26:10 <elliott> you don't have to
01:26:27 <edwardk> yeah i know, but its not _that_ bad
01:26:32 <elliott> i can fix semigroups easily without a major version change at all
01:26:35 <elliott> or are minor version changes just as abd
01:26:36 <elliott> *bad
01:27:15 <edwardk> semigroups i could live with a minor version change since its in the same day. later on when folks have it installed it breaks a lot of stuff
01:27:16 <elliott> bah
01:27:21 <elliott> edwardk: but wait one second first
01:27:27 <elliott> because tagged is slightly broken too >_>
01:27:30 <elliott> it imports Data.Data unconditionally
01:27:40 <elliott> actually wait wtf
01:27:41 <elliott> it worked before
01:27:59 <elliott> hmm, right
01:28:18 <edwardk> ifdefing it
01:28:28 <mcstar> it is nice that haskell's standard libraries are quite readable
01:28:55 <elliott> edwardk: I'm sorry about this, I'm going to have to actually use hugs for something so it doesn't feel completely frivolous :P
01:29:07 <edwardk> hah
01:29:10 <kallisti> has anyone else had issues linking to identifiers in out-of-scope modules (with haddock)?
01:29:10 <edwardk> sok
01:29:20 <edwardk> fortunately almost nothing i have depends on the new tagged yet
01:29:34 <edwardk> so i don't have to redo the last few hours
01:30:31 <elliott> edwardk: i'm surprised you've managed to avoid a cyclic package dependency
01:30:43 <kallisti> also how do you link to a constructor rather than a type.
01:30:45 <edwardk> i always break it by merging packages or by pushing things one level down
01:30:52 <edwardk> which is part of how things get so deep
01:30:58 <elliott> fwiw you might want to revert the semigroup change in your repo, since it's lying when it claims to support base 2 and probably 3
01:31:17 <edwardk> it took me almost a year to break up category-extras because i couldn't get it to break up
01:31:18 <edwardk> well
01:31:21 <edwardk> fix it ;)
01:31:28 <elliott> yeah i will
01:31:28 <edwardk> i'll take the explicit import list
01:31:34 <elliott> edwardk: was your vapourware haskell compiler going to support unhinted cyclic module dependencies?
01:31:39 <edwardk> i just wanted to get tagged off my list
01:31:56 <edwardk> i hadn't gotten past type checking
01:32:10 <edwardk> that vaporware needs me to spend more time on revisions and less on reflection ;)
01:32:25 <elliott> that's why i said "was" :)
01:32:46 <edwardk> the idea was to figure out the module dependency graph and type check it in cycles
01:32:54 <edwardk> though that may not work with template haskell existing
01:33:26 <elliott> great, so all you need is to use your compiler and there's no reason cabal couldn't support cyclic package dependencies
01:33:43 <edwardk> er
01:33:45 <edwardk> package deps?
01:33:47 <edwardk> no, nothing
01:33:49 <edwardk> sorry
01:33:50 <edwardk> i misparsed
01:33:55 <edwardk> module dependencies yes
01:34:06 <elliott> right, but what are packages but a bunch of modules? :)
01:34:07 <edwardk> package dependencies no
01:34:25 <edwardk> they also have all sorts of arcane third party build processes
01:34:30 <elliott> pfft
01:36:49 <edwardk> i always forget how many of these things i have
01:37:05 <elliott> ERROR "./Data/List/NonEmpty.hs":103 - Syntax error in declaration (unexpected selector "#ifdef")
01:37:11 <elliott> ... this is despite it running cpphs
01:37:35 <kallisti> I find it very strange that haddock is not cross-linking to other modules correctly..
01:37:43 <fqsxr> ghci question: Is it possible to get the type of fmap for a particular functor, eg. ((->) r)
01:37:53 <elliott> yes, substitute the functor for f
01:37:53 <edwardk> elliott: nice
01:38:01 <elliott> fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
01:38:02 <elliott> -->
01:38:07 <elliott> fmap :: (a -> b) -> (r -> a) -> (r -> b)
01:38:31 <fqsxr> I mean could ":t fmap" give me that?
01:38:41 <elliott> no
01:38:44 <fqsxr> ok
01:38:49 <mcstar> i didnt know haskell supported C# and F#
01:38:50 <shachaf> fqsxr: You can verify it, though.
01:39:03 <shachaf> By typing :t fmap :: (a -> b) -> (r -> a) -> (r -> b)
01:39:05 <bitonic> mcstar: it doesn't
01:39:29 <mcstar> take a look at GHC.Types
01:39:30 <bitonic> (assuming that you mean "has FFI interop with C# and F#")
01:39:40 <elliott> ghc =/= haskell
01:39:44 * hackagebot tagged 0.4 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4 (EdwardKmett)
01:39:46 * hackagebot reflection 1.1.4 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.4 (EdwardKmett)
01:39:48 * hackagebot ml-w 0.1 - Minimal ML language to to demonstrate the W type  infererence algorithm.  http://hackage.haskell.org/package/ml-w-0.1 (FrancescoMazzoli)
01:39:49 <bitonic> mcstar: ah. very funny :P
01:39:53 <mcstar> XD
01:40:30 <elliott> edwardk: i like the reflection reupload
01:40:41 <edwardk> ?
01:40:51 <edwardk> major bumped tagged, so i had to update it
01:41:03 <elliott> yah
01:41:09 <elliott> it'll just be rather short-lived as i finish this patch ;)
01:41:32 <edwardk> oh that
01:42:00 <elliott> hmm... i think hugs has completely forgotten how to use cpp
01:42:27 <mcstar> ghci tells me (:) is defined in GHC.Types, but its not there
01:42:34 <elliott> oh!
01:42:38 <elliott> it's interacting badly with cabal-dev
01:42:38 <elliott> sigh
01:42:42 <edwardk> one of your flags?
01:43:18 <elliott> no, actually, that's a lie
01:43:19 <elliott> it's just broken
01:43:32 <elliott> and i have absolutely no idea why
01:43:53 <etpace> Does GHC optimise "foo :: Bool -> String; foo = show" to a known function call?
01:44:45 * hackagebot streams 0.8.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.2 (EdwardKmett)
01:44:47 * hackagebot speculation 1.4.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.4.1 (EdwardKmett)
01:45:00 <edwardk> etpace: that goes into the .hi file, and is exposed to the inliner, so it should virtually always inline that
01:45:04 <timthelion> anyone know how to uninstall ghc on linux after it's been installed from binary?  make uninstall and make remove don't work :(
01:45:16 <shachaf> timthelion: Delete the files.
01:45:35 <timthelion> shachaf: you've got to be kidding me !  Which files were installed?
01:45:46 <shachaf> I don't know.
01:45:58 <bitonic> timthelion: you can make install again and check
01:46:03 <shachaf> checkinstall
01:46:04 <mcstar> what is the purpose of this convention: (-#) = let x = x in x
01:46:05 <shachaf> It's the future.
01:46:16 <shachaf> mcstar: It's like "undefined", I guess.
01:46:20 <shachaf> Not sure why they did that.
01:46:27 <bitonic> edwardk, elliott: since you're talking about hugs, do you know how to have 'base' registered as a package in hugs?
01:46:44 <edwardk> bitonic: elliott has been trying to get hugs to work correctly for hours
01:46:49 <timthelion> shachaf: neither checkinstall nor makecheckinstall exist.
01:47:01 <shachaf> checkinstall is a program that you install.
01:47:04 <elliott> bitonic: i do not know anything about hugs. hugs is completely confounding. hugs defies all logic.
01:47:09 <elliott> hugs is. hugs isn't. hugs was. hugs will be.
01:47:11 <bitonic> edwardk: what's the problem with hugs? most simple package I write work with it
01:47:13 <shachaf> It lets "make install" turn anything into a package.
01:47:31 <elliott> hugs wasn't. hugs won't be.
01:47:35 <elliott> hugs might have been. hugs might be.
01:47:44 <elliott> hugs shouldn't have been, but hugs will have been.
01:47:57 <timthelion> shachaf: on which distribution?
01:48:05 <shachaf> timthelion: A lot of them.
01:48:15 <shachaf> @google what is checkinstall?
01:48:17 <lambdabot> http://www.debian-administration.org/articles/147
01:48:17 <lambdabot> Title: Installing packages from source code with checkinstall
01:48:37 <shachaf> You won't be able to install mongrel2 with it, though, due to a bug in checkinstall and/or mongrel2 and/or the combination.
01:48:39 <elliott> hugs won't not have failed to be.
01:49:03 <tech2> elliott: did you remember to take your meds this morning?
01:49:17 <bitonic> elliott: I doubt you'll ever be able to use reflection with hugs, since it depends on Data.Data
01:49:47 <bitonic> I mean you could port Data.Data to hugs first, extracting it from base :P
01:49:55 <edwardk> bitonic: where does it use Data.Data?
01:50:28 <timthelion> shachaf: checkinstall is a .deb/rpm thing.  Doesn't exist on arch.
01:50:29 <bitonic> it depends on proxy that use Data.Data
01:50:33 <bitonic> edwardk
01:50:33 <elliott> tech2: hugs is meds, hugs isn't meds, hugs becomes meds
01:50:35 <edwardk> thats been fixed
01:50:55 <tech2> elliott: okay.... *pat* *pat*
01:50:56 <bitonic> ok, then I'm out of date, let's try
01:51:02 <shachaf> timthelion: OK, but the point of it is to figure out what the files are in this case.
01:51:09 <shachaf> timthelion: Arch has its own methods for doing this.
01:51:11 <shachaf> Anyway, I don't know.
01:51:22 <mcstar> arch isnt object oriented
01:51:26 <bitonic> edwardk: I just pulled 'tagged' and it uses Data.Data
01:51:41 <edwardk> it should have an if !impl(hugs)
01:51:45 <edwardk> guarding that
01:51:55 <edwardk> tagged 0.4?
01:52:18 <bitonic> edwardk: wait, I'm not using .cabal anyway right now
01:52:32 <timthelion> shachaf: well I make installed, thinking that make remove was going to exist, like it SHOULD exist if the make file was written correctly :(  I kind of assumed that these standards loving haskellers would be able to write a makefile correctly :(
01:52:43 <bitonic> edwardk: I just put everything in one source tree
01:52:45 <timthelion> shachaf: if I hadn't assumed that, then I would have packaged it from the get go.
01:53:03 <edwardk> bitonic: did you pull the latest of each?
01:53:08 <edwardk> they updated in the last half hour
01:53:09 <shachaf> timthelion: Uninstalling is way more complicated than installing.
01:53:18 <bitonic> edwardk: yes
01:53:18 <shachaf> I would not rely on Makefiles being able to uninstall.
01:53:21 <timthelion> shachaf: only for ghc...
01:53:33 <osa1> do we have an equivalent for Python's virtualenv?
01:53:35 <edwardk> and the verdict?
01:53:52 <elliott> osa1: cabal-dev. (some people use hsenv but i don't like it)
01:53:59 <bitonic> edwardk: yes the problem is that I can't use cabal with hugs, since it complains about 'base' missing
01:54:00 <edwardk> the Data.Data references should all be wrapped in inapplicable #ifdefs
01:54:19 <bitonic> wait I can set the CPP flag manually
01:54:30 <mcstar> are the Haskell Hierarchical Libraries available on my system as well as haskell.org?
01:54:38 <mcstar> (i mean the source)
01:54:45 * hackagebot semigroupoid-extras 0.2.7 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.7 (EdwardKmett)
01:54:45 <edwardk> erm, the CPP flag is something you want to _not_ have no?
01:54:47 * hackagebot rope 0.6.2 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6.2 (EdwardKmett)
01:54:49 * hackagebot profunctors 0.1.2 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.2 (EdwardKmett)
01:54:51 * hackagebot profunctor-extras 0.3.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.2 (EdwardKmett)
01:54:57 <timthelion> shachaf: if they don't include a make uninstall, then they certainly shouldn't have recomended I "make install" in the README.  They should have said WARNING WARNING, this must be packaged before installing...
01:55:19 <shachaf> timthelion: You are correct. I am a bad person. I'm sorry. :-(
01:55:49 <bitonic> timthelion: I make install all my GHCs and I'm fine :P
01:56:05 <timthelion> bitonic: but then how do you remove them afterwards?
01:56:35 <elliott> edwardk: oh wait!
01:56:39 <elliott> edwardk: you don't set C- never mind
01:56:42 <elliott> hugs doesn't care about cpp flag
01:56:43 <bitonic> timthelion: I never remove it!
01:57:27 <timthelion> bitonic: and when you upgrade, you just install over?
01:57:45 <gienah> timthelion: you could package it, with the same options as you used when you did make install, to make it install everything in the same locations, then pkg install it with some flag to ignore the conflicts, then pkg uninstall it
01:57:56 <elliott> --prefix=/opt/ghc
01:57:57 <elliott> problem solved
01:58:04 <bitonic> timthelion: GHC binaries are versioned, so I just keep the old ones
01:58:15 <kallisti> so I have a client library for Selenium in Haskell. I want my client verions to sync with Selenium releases, so that it's easy to figure out which client version you would want to use with a given server version. However..
01:58:26 <bitonic> edwardk: the problem is that you're using CPP flags to make hugs work, but hugs doesn't use CPP afaik
01:58:26 <kallisti> I also want to follow package versioning policy.
01:58:38 <mcstar> all i see is .hi interface files, but theres a lot of documentation, what is the preferred way to this? just open one in a browser?
01:58:45 <mcstar> are*
01:58:54 <kallisti> so I was thinking I could do something like have the first 2 version numbers be the selenium major release, and the inner 2 versions would be major and minor... or something.
01:59:13 <elliott> bitonic: you need to use cpphs-hugs
01:59:13 <timthelion> gienah: I could.  Perhaps, it sounds like a similar ammount of work to reinstalling linux...
01:59:22 <kallisti> <selenium A>.<selenium B>.<major version>.<minor version>   but I don't know if that's actually a good idea.
01:59:33 <edwardk> bitonic: then hugs is hosed
01:59:35 <edwardk> =)
01:59:45 * hackagebot keys 2.1.3 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.3 (EdwardKmett)
01:59:46 <elliott> edwardk: i honestly can't figure out how to fix semigroups
01:59:51 <edwardk> it was all elliott's mad idea ;)
01:59:52 <bitonic> elliott: with -F? or do you run the cpp before and then hugs?
01:59:55 <edwardk> elliott: ?
01:59:59 <elliott> edwardk: the #ifdef thing
02:00:04 <elliott> it's running cpp but the #ifdef just stays there
02:00:11 <edwardk> lovely
02:00:12 <elliott> bitonic: let me get you the command
02:00:23 <elliott> edwardk: i'll look into it later... for now I'll finish off the reflection patch
02:00:38 <elliott> bitonic: with cabal it's --hugs --with-cpphs="$(which cpphs-hugs)" --hugs-options="-98 +o" --hugs-option=-F'cpp -P -traditional'
02:00:48 <elliott> bitonic: command-line you can do cpphs-hugs -98 +o -F'cpp -P traditional'
02:01:03 <mcstar> timthelion: how do you use the documentation provided by your system?
02:01:12 <kallisti> one problem with that is that syncing with Selenium kind of removes the benefits of PVP anyway..
02:01:22 <bitonic> elliott: ok, I was close then :P
02:01:28 <gienah> timthelion: I can give a list of all the files/directories where we install it on gentoo if that helps (would need to know the ghc version)
02:01:46 <bitonic> elliott: thanks
02:01:58 <kallisti> because I'll likely have releases with no changes at all, but I'll still be changing the major version numbers.
02:02:13 <mcstar> emacs haskell mode maybe has some documentation interface, or just open /usr/share/doc/ghc/html/libraries/doc-index.html every time
02:02:36 <mcstar> it is an open question though, how do you guys access documentation
02:02:40 <timthelion> gienah: 7.0.4 , that would help. since arch uses the same directories.
02:02:55 <elliott> mcstar: i just use hackage
02:02:57 <kallisti> mcstar: I google hackage. :P
02:03:12 <bitonic> mcstar: you can enable the docs in cabal
02:03:21 <bitonic> I strongly suggest it, since hackage is often down :P
02:03:27 <elliott> you dont get source links then
02:03:31 <mcstar> bitonic: what does it mean?
02:03:34 <mcstar> o.O
02:03:38 <osa1> what's the hackage name of hsenv? I can't install it with cabal install hsenv
02:03:45 <mcstar> i thought cabal is for installing things
02:04:01 <kallisti> cabal is a build tool. It can build documentation too.
02:04:25 <mcstar> what format will that be in?
02:04:30 <kallisti> HTML
02:04:35 <kallisti> see cabal haddock
02:04:39 <mcstar> i guess i already have that installed
02:04:49 <mcstar> /usr/share/doc/ghc/html
02:04:52 <elliott> osa1: pah, cabal-dev is better :) but i think hsenv is not on hackage
02:05:03 <kallisti> mcstar: you have to explicitly generate docs for other packages though
02:05:04 <bitonic> mcstar: just enable 'documentation' in .cabal/config
02:05:09 <osa1> elliott: I'll try both :)
02:05:11 <kallisti> so cabal haddock package-name
02:05:14 <kallisti> for example
02:05:24 <kallisti> generates docs for package-name.
02:05:32 <mcstar> i see, had-dock is a name game on documentation
02:06:03 <kallisti> yes, we're all so clever aren't we.
02:06:04 <hpaste> gienah pasted “timthelion: ghc 7.0.4 files and directories on gentoo, the -> are symlinks” at http://hpaste.org/66696
02:06:18 <timthelion> gienah: thanks!
02:06:27 <kallisti> mcstar: Hackage also uses haddock to generate its HTML docs.
02:06:31 <mcstar> kallisti: yes!
02:06:35 <kallisti> it's in the same format.
02:06:46 <mcstar> i like that haskell makes more sense than other systems
02:07:03 <bitonic> gienah: timthelion installed with the pre-packaged binaries
02:07:44 * gienah built it on gentoo from the dev-lang/ghc-7.0.4.ebuild
02:08:36 <kallisti> mcstar: well documentation and build systems (or even package repositories) aren't particularly unique to Haskell, but it might be a bit better organized.
02:08:59 <mcstar> no i meant the language
02:09:19 <kallisti> oh, okay.
02:09:31 <mcstar> (im not familiar with the infrastructure to judge)
02:09:46 * hackagebot pointed 2.1 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.1 (EdwardKmett)
02:09:47 * hackagebot reducers 0.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.2 (EdwardKmett)
02:09:49 * hackagebot compressed 0.2 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.2 (EdwardKmett)
02:09:52 * hackagebot syb-extras 0.2.2 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.2 (EdwardKmett)
02:10:16 <Palmik> Hmm, what is the reasoning behind ParsecT having a state? I could understand if it were not monad transformer.
02:11:03 <edwardk> palmik: i seem to recall that user state is reverted across backtracks
02:11:09 <edwardk> whereas the one you transform would be kept
02:11:24 <edwardk> so both have a place
02:11:34 <Palmik> Yeah, that explains it, thanks. :)
02:13:06 <elliott> edwardk: stupid me!
02:13:11 <edwardk> ?
02:13:19 <elliott> edwardk: the whole #ifdef problem was that i simply wasn't telling hugs to use a preprocessor when I ran it
02:13:23 <osa1> strange, hsenv's activate doesn't work for me
02:13:24 <edwardk> sweet
02:13:25 <elliott> I'm so used to compilers...
02:13:29 <elliott> edwardk: however!
02:13:35 <elliott> ERROR "/home/elliott/hugs/lib/hugs/packages/tagged/Data/Tagged.hs":50 - No member "readPrec" in class "Read"
02:13:47 <edwardk> oh yeah feel free to rewrite that to use readsPrec
02:13:50 <elliott> OK
02:14:05 <shachaf> Does readPrec exist?
02:14:33 <bitonic> elliott: how did you manage to install with cabal and hugs anyways? If I try to install anything it complains about 'base' missing?
02:14:46 * hackagebot monad-products 0.2.1 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.1 (EdwardKmett)
02:14:48 <elliott> bitonic: yeah everything depends on base 4
02:14:51 <elliott> pick packages that don't
02:15:14 <bitonic> elliott: no even base 3 doesn't work, 'base' is just not registered
02:15:18 <bitonic> or so it seems
02:15:20 <elliott> edwardk: i'll do the semigroups fix too, and then you can readd the instance in tagged whenever you next have to do a semigroups release ;)
02:15:22 <elliott> bitonic: base 3 is not ok
02:15:23 <elliott> you need base 2
02:15:25 <elliott> hugs is really old
02:15:40 <bitonic> ah.
02:16:34 <elliott> edwardk: can i hide your (<$) member defn behind an ifndef __HUGS__? i could technically condition it on the version of base but i've no idea what version that would be
02:16:42 <elliott> or whether hugs+cabal even supports MIN_VERSION stuff
02:16:49 <edwardk> sure
02:17:07 <elliott> honestly i'm shocked hugs even has applicative
02:17:15 <edwardk> likewise
02:17:26 <edwardk> must have just made it in under the wire
02:17:38 <elliott> yeah
02:17:43 <elliott> one last safeguard against the future
02:18:31 <edwardk> slowly getting there. about 75% done
02:19:37 <bitonic> can I have conditionals in .cabal files based on package versions?
02:20:01 <kallisti> are there other packages that use a similar version system to what I'm suggesting?
02:20:12 <kallisti> where one section of the version is sync'd with some other library version
02:20:19 <elliott> @type readPrec
02:20:19 <lambdabot> Not in scope: `readPrec'
02:20:21 <elliott> @type readsPrec
02:20:21 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
02:20:22 <elliott> oh cmon
02:20:24 <elliott> @hoogle readPrec
02:20:24 <lambdabot> Text.ParserCombinators.ReadPrec data ReadPrec a
02:20:24 <lambdabot> Text.Read readPrec :: Read a => ReadPrec a
02:20:24 <lambdabot> Text.ParserCombinators.ReadPrec readPrec_to_P :: ReadPrec a -> (Int -> ReadP a)
02:20:28 <kallisti> I'm trying to figure out the best way to do that while also using PVP
02:20:30 <elliott> bah humbug
02:20:34 <edwardk> elliott: look in Text.Read for the overview
02:20:44 <edwardk> it gives a good comparison of the GHC approach vs the regular
02:21:13 <edwardk> i've just gotten used to writing them by hand when i have a strange type
02:22:48 <elliott> ok, now for the things i actually gotta ifdef out
02:22:50 <elliott> ERROR "./Data/Semigroup.hs":168 - Undefined type constructor "Monoid.First"
02:22:54 <elliott> actually i would use MIN_VERSION here
02:22:58 <elliott> except
02:23:06 <elliott> i actually don't see how hugs could possibly support that
02:23:11 <bitonic> elliott: whoa you're right, I can actually install my cabal pkgs with hugs!
02:23:41 <edwardk> just make a cabal flag for HAS_FirstLast or something
02:23:49 <edwardk> and predicate it on the base version
02:24:26 <elliott> edwardk: how about HAS_VaguelyModernBase which covers (<$) too ;)
02:24:34 <edwardk> hah
02:24:46 * hackagebot monad-st 0.2.1 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.1 (EdwardKmett)
02:24:48 * hackagebot intervals 0.2.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.1 (EdwardKmett)
02:25:41 <elliott> edwardk: your git tagged still imports semigroup
02:25:42 <elliott> s
02:26:07 <mcstar> i still dont understand this, ghci says (:) is Defined in `GHC.Types', i checked the documentation on my system, and it isnt documented being there
02:26:13 <edwardk> doh
02:26:35 <edwardk> check repo now
02:27:00 <chrisdone> did anyone get gitit to work with nginx or a server which doesn't do anchor rewriting?
02:27:15 <chrisdone> … with a base-url
02:27:31 <edwardk> mcstar: (:) is magic
02:27:46 <edwardk> mcstar: its built in, but Data.Typeable has to report it being somewhere
02:29:09 <mcstar> edwardk: so it is another kind of magic than stuff that is in the documentation but implemented by ghc?
02:29:33 <edwardk> well, GHC.Prim and GHC.Types are pretty special places
02:29:46 * hackagebot ml-w 0.1.1 - Minimal ML language to to demonstrate the W type  infererence algorithm.  http://hackage.haskell.org/package/ml-w-0.1.1 (FrancescoMazzoli)
02:29:48 * hackagebot representable-functors 2.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.2 (EdwardKmett)
02:29:49 <edwardk> lots of stuff baked into GHC makes assumptions about them
02:30:40 <elliott> ERROR "./Data/Tagged.hs":40 - Cannot derive instances of class "RealFloat"
02:30:49 <elliott> i'm starting to see why hugs died a miserable deaht
02:30:50 <elliott> *death
02:30:51 <elliott> it sucks
02:31:01 <edwardk> elliott: =)
02:31:07 <elliott> it isn't happy with any of your generalised newtype deriving
02:31:10 <edwardk> time to manually instantiate RealFloat!
02:31:11 <edwardk> =)
02:31:12 <elliott> @src RealFloat
02:31:12 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:31:22 <edwardk> have fun
02:31:23 <elliott> is it one of the two-member or twenty-member numeric typeclasses :)
02:31:42 <edwardk> i plead the fifth
02:31:47 <edwardk> @src RealFloat
02:31:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:34:46 * hackagebot adjunctions 2.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.2 (EdwardKmett)
02:35:36 <elliott> oh crap
02:35:39 <elliott> RealFloat is the huge one
02:35:46 <elliott> edwardk: do you really use that instance?!
02:35:57 <edwardk> elliott: =P
02:36:00 * elliott cries, copies a billion lines
02:36:03 <edwardk> elliott: it exists because it should exist
02:39:06 <elliott> awesome!!!
02:39:10 <elliott> ghc and hugs  disagree about what's in RealFloat
02:39:58 <elliott> wait, no they don't...
02:40:03 <edwardk> *golf clap*
02:44:46 * hackagebot representable-tries 2.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.2 (EdwardKmett)
02:44:48 * hackagebot kan-extensions 2.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.2 (EdwardKmett)
02:44:50 * hackagebot representable-profunctors 0.4.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.1 (EdwardKmett)
02:45:46 <kallisti> so, using my current version naming scheme, the current version is 0.0.0.0.0  :P
02:46:06 <kallisti> should I, maybe reconsider this?
02:47:02 <edwardk> kallisti: just collapse unused trailing 0s and you get version 0 or 0.0
02:48:14 <kallisti> edwardk: well, sure. but eventually it'll end up being like... 2.20.0.1.1 or whatever
02:48:15 <elliott> edwardk: representable-profunctors! isn't that the top?
02:48:27 <edwardk> elliott: nope
02:48:31 <elliott> lol
02:48:40 <kallisti> the first 2 versions are the Selenium version, the last three are the package version following PVP.
02:48:51 <kallisti> I'm still not sold.
02:49:27 <kallisti> but it ensures that you know exactly which version of my package to use for whatever version of Selenium you have.
02:49:59 <edwardk> elliott: nopeabout half way through patching trifecta
02:50:33 <elliott> kallisti: if anything append the selenium
02:50:48 <kallisti> what do you mean./
02:51:01 * kallisti was going to include a mention either in the project description or somewhere else.
02:51:20 <elliott> instead of sel.pvp do pvp.sel if anythin
02:51:20 <elliott> g
02:51:26 <edwardk> kallisti: the issue with that approach is that your versioning scheme doesn't wind up following the pvp itself
02:51:35 <kallisti> ahhhh yes actually that would be better
02:51:41 <kallisti> because the selenium version only indicates protocol changes
02:51:42 <elliott> in which case the selenium numbers become really minor noise that doesn't violate the pvp
02:51:44 <elliott> but
02:51:46 <elliott> seriously just use the pvp
02:51:54 <elliott> you're allowed to have further info in the description
02:51:55 <edwardk> elliott: well that doesn't work with ranges
02:52:03 <elliott> edwardk: also true
02:52:37 <kallisti> I do like that better though, as a new selenium version doesn't really affect my API necessarily
02:52:39 <edwardk> kallisti: what about trying to keep the package supporting a range of versions through flags ?
02:52:42 <kallisti> and if it does I can just change the major version as well.
02:52:49 <edwardk> that way the user just installs your app
02:52:52 <kallisti> edwardk: -shudders-
02:53:22 <kallisti> I might do that. you mean by using cabal flags yes?
02:53:34 <elliott> could make it a runtime thing instead
02:53:42 <elliott> if you have instances that depend on the protocol then you could use reflection!
02:53:50 <kallisti> heh
02:53:52 <edwardk> kallisti: yes
02:54:08 <kallisti> runtime might be a better choice actually
02:54:09 <edwardk> kallisti: try to export the same api regardless of detected selenium install
02:54:12 <kallisti> right
02:54:15 <kallisti> that makes sense.
02:54:22 <elliott> kallisti: yes, but if you have e.g. Serialize instances that differ based on protocol version
02:54:23 <edwardk> kallisti: and just make it part of the install process to detect
02:54:28 <kallisti> I don't want to force people using older Selenium versions to use my older broken code.
02:54:29 <elliott> then you need reflection to get that info in
02:54:37 <edwardk> using whatever autoconf ridden horribleness you have to use to make it work
02:54:45 <elliott> (if you make it runtime)
02:54:46 * hackagebot trifecta 0.50 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.50 (EdwardKmett)
02:54:53 <elliott> \o/
02:55:01 <kallisti> elliott: ah right
02:55:17 <elliott> kallisti: ...but that's exactly what reflection is designed for and now it's **faster** **than** **ever**!
02:55:25 <elliott> works on Hugs! almost
02:55:34 <edwardk> elliott is a bit biased
02:55:36 <kallisti> I'll look into this ***amazing*** ***new*** ***technology***
02:55:39 <kallisti> but really it scares me.
02:55:42 <kallisti> I looked at the code.
02:55:47 <edwardk> kallisti: its short now
02:55:53 <kallisti> it still scares me.
02:55:57 <edwardk> ;)
02:56:24 <edwardk> elliott: i was actually able to avoid updating about half of my packages
02:56:25 <kallisti> elliott: and yes serialization instances differing based on protocol is highly likely
02:56:33 <kallisti> in fact that's the most likely change.
02:57:32 <edwardk> how are you talking to selenium?
02:57:38 <kallisti> HTTP
02:57:46 <edwardk> so its not a linking concern
02:58:04 <kallisti> a Selenium server is just a special kind of HTTP server that sends and receives JSON.
02:58:08 <edwardk> so just make a data type or class describing the versioning scheme
02:58:08 <elliott> kallisti: right, then as i said reflection is exactly what you wan
02:58:09 <elliott> t
02:58:09 <edwardk> sure
02:58:30 <elliott> add a type param to all the relevant types, (Reifies v SeleniumVersion) => in the constraint, bam, you're done
02:58:32 <kallisti> I'll use build flags for now, since I don't know how common it would be that you want to use drastically different versions of Selenium with one build...
02:58:35 <elliott> pah!
02:58:40 <elliott> what about end-user programs?
02:58:51 <elliott> reflection makes everything better
02:59:00 <edwardk> kallisti: well the issue is if you use flags there is the problem that nobody can safely depend on you if your behavior changes
02:59:24 <edwardk> i can depend on a package
02:59:31 <edwardk> i can't depend on a package with a particular set of flags
02:59:37 <kallisti> ah yes
02:59:46 * hackagebot monadic-arrays 0.2.1 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.1 (EdwardKmett)
02:59:54 <elliott> see, edwardk knows reflection is the best solution to any problem
03:00:02 <kallisti> elliott: in the constraint of the serialization instance, you mean?
03:00:06 <elliott> kallisti: yeah
03:00:08 <kallisti> hm
03:00:14 <edwardk> hence why the class SeleniumVersion s where blah :: s -> WhateverYouWantToDoForBlah
03:00:15 <kallisti> that's not too difficult. I think.
03:00:23 <edwardk> approach isn't a bad idea.
03:00:28 <elliott> and you recover it with reflect (Proxy :: Proxy v)
03:00:32 <elliott> which :: SeleniumVersion
03:00:33 <edwardk> elliott: =P
03:00:34 <kallisti> why a class instead of a type.
03:00:53 <elliott> i'm saying it jokingly but i actually believe reflection is the best way here
03:00:56 <edwardk> kallisti: that works too, but a class can be plumbed some places data can't
03:01:16 <elliott> oh what edwardk says is basically equivalent
03:01:21 <edwardk> elliott: yes
03:01:22 <elliott> and simpler in this case
03:01:24 <edwardk> baby steps ;)
03:01:32 <elliott> bah
03:01:43 <elliott> what reflection needs is nice syntax for Proxy
03:01:52 <elliott> if you could say reflect ~ver then nobody would hesitate to use it :p
03:01:57 <edwardk> in the end, when he needs it to be based on runtime values he can make a version of SeleniumVersion that uses reflection
03:02:02 <elliott> yeah
03:02:04 <edwardk> but by then it'll be solving a pain
03:02:05 <kallisti> I'd personally prefer a type over a class I think.
03:02:10 <elliott> kallisti: you can't plumb a type into instance
03:02:11 <elliott> s
03:02:21 <elliott> Serialize does not offer a nice parameter on every function to put your dictionary in
03:02:32 <elliott> but it can't stop you putting a constraint in
03:02:38 <edwardk> kallisti: the issue only becomes when you nee to make an instance of something like Eq or whatever for something that depends on the selenium version
03:02:49 <kallisti> oh I see.
03:03:10 <edwardk> whereas the class approach lets you deal with that
03:03:26 <edwardk> and provides an avenue for extension
03:03:35 <edwardk> when you have new versions that supply additional functionality
03:03:43 <kallisti> how do I turn a version into a class constraint or... well, I'm probably saying that all wrong.
03:03:45 <edwardk> you can make a new class and instantiate it for some subset of the versions
03:04:00 <edwardk> lets take a simple example
03:04:08 <edwardk> class Version1Features a where ...
03:04:15 <elliott> kallisti: f.e.
03:04:23 <edwardk> class Version1Features a => Version2Features a where ...
03:04:36 <elliott> kallisti: instance (SeleniumVersion ver) => Eq (SomeType ver) where (==) = seleniumEq
03:04:40 <edwardk> then you can make a data type for version 1 and for version 2, etc.
03:04:43 <elliott> (in that case the logic is so trivial that you could just punt it to the class)
03:05:01 <elliott> (but if (==) had common logic for all versions you could put it there)
03:05:15 <edwardk> ok, fun as this is, i should have been asleep several hours ago.
03:05:34 <edwardk> elliott: can you toss me the drastically longer Tagged when you get a chance? =)
03:05:45 <elliott> edwardk: yeah, plus the reflection
03:05:49 <elliott> edwardk: and semigroups
03:06:00 <elliott> (the semigroups changes can wait to be released until you have something of value obviously :p)
03:06:02 <kallisti> elliott: and then I subclass versions as typeclasses as edwardk described?
03:06:14 <elliott> kallisti: sure. you don't need to though, if you don't need to
03:06:16 <elliott> (helpful)
03:06:21 <elliott> you can just give instances of the same typeclass
03:06:30 <kallisti> ah yes
03:06:51 <kallisti> okay so then each version is an empty data type with an instance for SeleniumVersion
03:06:57 <kallisti> you pass that in somewhere
03:07:04 <elliott> (as a Proxy)
03:07:35 <kallisti> the user doesn't need to worry about the Proxy thought, right?
03:07:38 <kallisti> *though
03:07:46 <edwardk> elliott: oleg came back with another approach ;)
03:07:56 <elliott> edwardk: oh god
03:07:59 <elliott> edwardk: go on
03:08:08 <edwardk> @hpaste
03:08:08 <lambdabot> Haskell pastebin: http://hpaste.org/
03:08:19 <elliott> i'm terrified
03:08:30 <elliott> if this invalidates all my hugs effort though
03:08:34 <elliott> then i don't like oleg any more
03:08:36 <hpaste> edwardk pasted “oleg's oleggery of reflection” at http://hpaste.org/66699
03:08:59 <elliott> thank god, it's uglier
03:09:05 <edwardk> hah
03:09:10 <kallisti> sheesh I still have so much to do, and now I'm going to do this reflection stuff which is ALREADY OBSOLETE.
03:09:11 <zenzike> does the 666 mean it's really evil code?
03:09:25 <elliott> oh that's sneaky
03:09:32 <edwardk> i kinda like it
03:09:36 <elliott> yeah
03:09:37 <elliott> bet it's slower ;)
03:09:42 <edwardk> possibly
03:09:47 <edwardk> IORefs aren't that slow
03:09:54 <elliott> slower than a function call
03:10:03 <edwardk> yes, but a lot safer ;)
03:10:07 <elliott> actually
03:10:11 <elliott> that's not thread-safe
03:10:17 <kallisti> wait so....
03:10:18 <elliott> at all
03:10:44 <kallisti> reify creates a Proxy from an instance?
03:10:45 <edwardk> he forces it with seq up front in reify
03:10:48 <kallisti> I don't really get this...
03:10:58 <elliott> kallisti: ignore reflection
03:11:04 <elliott> you don't need the package itself for now
03:11:08 <kallisti> well yes
03:11:12 <elliott> edwardk: so? it's one IORef per "a"
03:11:19 <kallisti> I wasn't going to add it this moment, but I'd still like to have a good grasp of it.
03:11:21 <elliott> if another thread tramples on that ioref by reifying itself before it gets read back...
03:11:35 <edwardk> yes, but since its used polymorphically if you NOINLINE reify it doesn't know anything about the choices of a you use
03:11:53 <elliott> it uses "a" as the cell type, not "s"
03:11:57 <edwardk> so its forced to make up the dictionary for the instance fresh each time
03:11:58 <edwardk> yes
03:11:59 <elliott> so it does know what a is... it's a
03:12:01 <elliott> hmm
03:12:04 <elliott> ok
03:12:05 <bitonic> edwardk: is there a 'Group' class in one of your package?
03:12:06 <elliott> right
03:12:12 <edwardk> bitonic: several ;)
03:12:15 <kallisti> oh nevermind reify is the opposite of what I just said.
03:12:20 <elliott> ugh, I still prefer the unsafeCoerce :)
03:12:37 <bitonic> edwardk: I just need something with <> and unit of kind *
03:12:39 <elliott> once you get into unportable territory like that might as well go all the way
03:12:42 <bitonic> I'd use monoid if it wasn't * -> *
03:12:49 <elliott> bitonic: uh monoid is *
03:12:53 <elliott> Monoid :: * -> Constraint
03:12:54 <edwardk> bitonic: monoid is *
03:13:03 <bitonic> ah right
03:13:13 <elliott> monoid on (* -> *) is called Applicative or Monad :)
03:13:16 <bitonic> I got confused ehe
03:13:19 <bitonic> yes
03:13:24 <edwardk> still need a package?
03:13:39 <bitonic> edwardk: not really, even if what I have is a group not a Monoid
03:13:43 <bitonic> but I guess it doesn't matter
03:13:44 <kallisti> elliott: it looks to me as though you still need the proxy in order to retrieve the data..
03:13:54 <kallisti> is that correct?
03:13:56 <edwardk> bitonic: k. otherwise there is one in algebra
03:13:58 <elliott> kallisti: no, you can make up the proxy from anywhere
03:14:01 <elliott> because Proxy contains no information
03:14:08 <bitonic> since the group properties can't be expressed in haskell anyways
03:14:10 <elliott> you just turn on ScopedTypeVariables
03:14:13 <edwardk> bitonic: there was one in monoids, but that package is deprecated in favor of reducers which lacks a group type
03:14:19 <elliott> as long as the magic "s" type is in scope, just reflect (Proxy :: Proxy s)
03:14:21 <elliott> and you get it
03:14:31 <edwardk> bitonic: sure, but you can have a negate or invert operation in a class with the assumption it holds
03:14:37 <kallisti> ah. so I can ignore the proxy completely once I reify the value.
03:14:38 <bitonic> edwardk: yeah
03:14:43 <edwardk> the unit properties of a monoid can't be checked either
03:14:46 <elliott> kallisti: well you need it at the first step
03:14:51 <elliott> to unify your type with the phantom s you get
03:15:38 <elliott> ERROR "./Data/Tagged.hs":96 - No member "floatRadix" in class "RealFrac"
03:15:39 <elliott> i don't get it
03:15:45 <elliott> oh
03:15:45 <bitonic> elliott: actually yes negate might turn out useful, I might use Group
03:15:48 <elliott> floatRadix is in RealFloat
03:16:30 <elliott> @src RealFrac
03:16:30 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
03:16:30 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
03:16:30 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
03:16:33 <kallisti> elliott: by "your type" you mean the "r" in reify, or...?
03:16:33 <elliott> could be worse
03:16:41 <elliott> kallisti: no, the quantified "s"
03:16:46 <elliott> think of it like this: that "s" contains your value
03:16:53 <elliott> it's your value, lifted to the type level, magically
03:16:53 <kallisti> yes I understand that part.
03:16:59 <elliott> a is the type of the value
03:17:00 <kallisti> so then r = Blah s
03:17:01 <elliott> r is your return value
03:17:06 <elliott> kallisti: the point is you have like
03:17:09 <bitonic> edwardk: do you have a non-numeric group?
03:17:34 <elliott> createStuff :: (Reifies v SeleniumVersion) => IO (Blah v, Blech v, Bleech v)
03:17:38 <elliott> and you have to make that v be the s
03:17:41 <elliott> so you write
03:17:45 <edwardk> bitonic: i had it in 'monoids' but thats deprecated these days
03:17:46 <kallisti> elliott: so I can reify a, take the quantified s and "store" it in the version type paramter of my type, and return that as "r"
03:17:52 <kallisti> elliott: and then I have a version associated with that ype.
03:17:54 <kallisti> *type
03:18:10 <elliott> kallisti: no, no, you put reify around your _whole_ use of the thing
03:18:14 <bitonic> edwardk: so the answer is "no"?
03:18:14 <elliott> it's like runST
03:18:16 <elliott> you have one reify
03:18:25 <kallisti> elliott: oh I see.
03:18:29 <elliott> and all the "s"s inside unify
03:18:41 <elliott> which means that regular unification propagates your value around
03:18:41 <edwardk> bitonic: there is an additive or multiplicative group in 'algebra' but thats a lot to bring in for such a simple feature
03:19:02 <elliott> kallisti: have you seen the Monoid example?
03:19:08 <bitonic> edwardk: mhm... it's weird that there isn't one
03:19:13 <elliott> or my quick modular arithmetic value?
03:19:15 <kallisti> I did but this was before I understood what I was looking at.
03:19:23 <edwardk> bitonic: just fell off my radar
03:19:24 <kallisti> maybe now I can gather something from it.
03:19:31 <elliott> http://hpaste.org/66565
03:19:34 <elliott> it might make more sense now
03:19:36 <edwardk> i can look at making a package if i can come up with enough nice ones
03:19:36 <elliott> here "p" is the modulus
03:19:44 <alpounet> is there any "reference" modulo arithmetic package?
03:19:52 <edwardk> making just a groups package that uses reducers and adds groups for as many of them as possible
03:19:56 <elliott> alpounet: monoids circa $oldversion ;)
03:20:34 <kallisti> elliott: woah wait. Reifies p? isn't there 2 parameters to Reifies?
03:20:46 <elliott> yes
03:20:49 <elliott> i pass both
03:20:53 <elliott> not sure what you are looking at
03:20:59 <kallisti> oh. a comment. :P
03:21:00 <kallisti> nevermind
03:21:07 <elliott> oh, that was the old type families stuff
03:21:13 <elliott> that got half replaced by an emacs mass-replace
03:21:36 <hpaste> timthelion pasted “Do I really need scrwinMVar?  the type of postGUIAsync is IO () -> IO ()” at http://hpaste.org/66700
03:21:56 <elliott> edwardk: btw do you use two or four spaces to indent? i can never tell
03:22:02 <elliott> every time i think i've figured it out i find something contradicting it
03:22:13 <elliott> so i just mimic the directly neighbouring lines :p
03:22:15 <timthelion> Hello, is the only way to do that with an MVar??? Seems clunky...
03:22:30 <elliott> timthelion: looks fine to me
03:22:55 <timthelion> elliott: It just seems strange to me that I need an MVar there...
03:23:07 <relation> hi! somebody with an idea how to implement simple PRNG on GPU using Data.Array.Accelerate? thanks
03:23:16 <bitonic> edwardk: btw, why is 'monoids' obsolete?
03:24:09 <edwardk>  bitonic: it conflicts with reducers which is strictly more general
03:24:12 <elliott> ERROR "./Data/Tagged.hs":40 - Cannot derive instances of class "Floating"
03:24:22 <elliott> i am paying for my hubris
03:24:36 <edwardk> i just didn't port a couple of things out of there because they weren't appropriate to the new scope
03:24:54 <edwardk> elliott: =)
03:24:58 <bitonic> edwardk: ok
03:25:42 <kallisti> elliott: withProxy is the unification step, correct?
03:26:09 <kallisti> in modulo'
03:26:18 <amtal> I have a feeling I'm seriously misunderstanding the Get monad in cereal. If I do "f = do a <- getWord16; b <- getWord16 ...", and then "g = do ab <- f; c<-getWord16; ...", it should parse [a][b][c] from the stream, right?
03:26:24 <amtal> Not [a][c][b]?
03:26:28 <elliott> kallisti: yes
03:26:40 <elliott> amtal: indeed
03:26:54 <amtal> Time to go nuts then.
03:27:47 <amtal> edwardk: at a glance, what would you say about this use of Trifecta for parsing assembly? https://github.com/amtal/soyuz/blob/master/DCPU16/Assembly/Parser.hs  (I'm having trouble with 'warn's being spammed multiple times due to my use of try. I don't know whether I should be lifting warnings out, or reducing my use of try, or what.)
03:27:53 <elliott> does anyone even use Tagged
03:27:59 <kallisti> elliott: oh, that's really simple.. there's just a lot of noise.
03:28:19 <elliott> kallisti: yeah newtype instances generally look like noise
03:29:08 <kallisti> the difficult part will be figuring exactly where to add the noise to my program so that it doesn't look too ugly.
03:30:06 <elliott> it won't be nearly as noisy in practice
03:30:14 <edwardk> amtal: hrmm, i'd reduce the reliane on try, but you can also use listen/pass
03:30:26 <edwardk> they are a bit tricky with trifecta at the moment
03:30:31 <edwardk> but they should work
03:31:11 <amtal> edwardk: you mean wrap the (Parser String a) in a RWS monad transformer?
03:31:29 * elliott wonders if Tagged has uses Proxy doesn't account for
03:31:31 <edwardk> no, Parser should be an instance of MonadWriter
03:31:48 <edwardk> elliott: yes, a number of people still use Tagged
03:32:08 <edwardk> it has some benefits in that its purely newtype noise rather than a lambda
03:32:11 <edwardk> so it may be faster
03:34:00 <amtal> So (Parser String Foo) would become (WriterT WState (Parser String Foo))?
03:34:50 * hackagebot yesod 1.0.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.0.2 (MichaelSnoyman)
03:34:51 <amtal> And then all code would be unchanged, except... Wait, I don't have a runParser. The only thing I found was parseTest and parseFile.
03:35:13 <elliott> edwardk: yeah
03:35:14 <edwardk> amtal: no, the Parser itself is a writer already
03:35:18 <elliott> it's so ugly to use though :)
03:35:24 <elliott> (IME)
03:35:29 <amtal> But where does it hide the state of the writer? I don't see it in the signature o.O
03:35:40 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Prim.hs#L137
03:36:07 <edwardk> it reads and writes (ErrLog e) entries, which with pass/listen you could censor by hand
03:36:16 <edwardk> but those are harder to work with than diagnostics
03:36:26 <edwardk> which is why i keep meaning to rewrite the diagnostic subsystem
03:36:41 <elliott> so the basic problem is that trifecta repeats diagnostics when backtracking?
03:36:43 <edwardk> but every time i start i wind up having something else come along and push that branch farther away
03:37:06 <amtal> Hum. Well, I think I'm just gonna try to reduce my use of try, and tell users to put up with 10x warnings.
03:37:11 <amtal> Or maybe make the warnings full on errors.
03:37:12 <edwardk> elliott: diagnostics from warnings, yes
03:37:22 <edwardk> if you make them errors, then it backtracks them
03:37:28 <edwardk> and does what you'd expect
03:37:29 <elliott> right
03:37:36 <elliott> seems like you could avoid that through some kind of magic :p
03:37:42 <elliott> recording when you've emitted a certain diagnostic from a certain branch
03:38:01 <edwardk> harder than you'd think since they are polymorphic and involve higher order functions
03:38:02 <elliott> ERROR "Data/Tagged.hs":40 - Can only derive instances of Enum for enumeration types
03:38:02 <elliott> hey, at least that means it can do Bounded
03:38:07 <elliott> edwardk: ugh
03:38:35 <edwardk> amtal: i'd swap them to errors
03:38:43 <edwardk> amtal: then it should do the right thing
03:39:16 <amtal> Fair enough. I don't have any warn-y stuff yet anyway.
03:39:18 <edwardk> ok, i'm going to try to get a couple of hours of sleep before work
03:39:52 <elliott> edwardk: my apologies :)
03:40:25 <edwardk> meh, libraries wound up improved
03:40:59 <elliott> mmm, hugs gives much nicer type errors than ghc
03:41:05 <elliott> apart from renaming all the type variables
03:41:29 <edwardk> i really do need to finish that type error slicer
03:41:36 <elliott> holy crap it compiles!!!
03:41:42 <edwardk> elliott++
03:45:24 <amtal> Strange bug that I assume is either me misunderstanding monad serialization, or a bug in cereal: https://gist.github.com/262ef543e5af059749f8
03:45:59 <amtal> Two getWord16be's are sequenced together (as far as I can tell) but only the first runs. The second, returns junk.
03:47:29 <alpounet> elliott, how come you're using hugs? any particular reason?
03:49:50 <elliott> alpounet: "Because it's there"
03:50:18 <amtal> Another way to phrase the bug, is (get :: Get Instruction) always consumes one Word, even when the instruction contains two. The second word is... not random, but not present in the source bytestring either o.O
04:09:53 * hackagebot yesod-platform 1.0.0 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.0 (MichaelSnoyman)
04:10:46 <Peaker> Yesod 1.0 was just released?
04:13:30 <elliott> Peaker: yes, and we just had a day of edwardk package updates too!
04:14:55 <amtal> Oh yeah, it was me being dumb and misinterpreting output. Cereal's fine, monads still work, false alarm guys.
04:15:45 <Peaker> elliott: cool :)
04:17:47 <elliott> amtal: *phew* i was worried about monads
04:18:07 * kallisti sheds a single tear of joy as he marvels at this 
04:18:19 <kallisti> Manipulating Firefox profiles in pure code. :D :D :D
04:18:22 <kallisti> (sort of)
04:18:57 <kallisti> (the trick is that you have to "prepare" them before sending them across network. This does all the IO stuff that was deferred by the pure code )
04:55:02 <Skola> I am trying to parse a sentence where I want to split contracted words into certain parts ("isn't" -> ["is", "n't"]), but I am unsure where to put them in my parser.
04:55:19 <hpaste> Skola pasted “how do I deal with contractions?” at http://hpaste.org/66702
04:55:50 <Skola> the contraction function returns [String] instead of the expected String
04:56:06 <Skola> but I don't know where it's supposed to go
04:59:52 <fryguybob> @hackage tokenize
04:59:53 <lambdabot> http://hackage.haskell.org/package/tokenize
05:00:07 <fryguybob> Skola: Is this what you are looking for?
05:00:57 <Skola> I've looked at that
05:01:04 <Skola> but it doesn't do all I want
05:01:11 <Skola> + this is more or less an exercise
05:02:31 <harlekin> Hi, how would I parse a C float using attoparsec? My problem is putting the 4 Word8s together correctly.
05:02:38 <hpaste> dp_wiz pasted “How to properly add IO to attoparsec:Parser?” at http://hpaste.org/66703
05:14:23 <dp_wiz> Any hints on #66703?
05:14:55 * hackagebot probability 0.2.4 - Probabilistic Functional Programming  http://hackage.haskell.org/package/probability-0.2.4 (HenningThielemann)
05:18:30 <RaphaelJ> Hey, what does the [2] means in inline PRAGMAs ? (like "{-# INLINE [2] sizeBounds #-}")
05:22:02 <geekosaur> it's roughly the compiler phase in which to do the inlining, letting you control when it happens relative to when RULES fire etc.
05:22:37 <elliott> RaphaelJ: see http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/pragmas.html#inline-noinline-pragma
05:23:25 <kallisti> when was support for source-repository added to cabal?
05:23:32 * kallisti is trying to figure out which cabal version he needs.
05:23:43 <kallisti> currently I require >= 1.6 because I use version wildcard things.
05:24:40 <RaphaelJ> elliott: yes, but this doesn't talk about the [x] parameter
05:25:20 <elliott> it does
05:25:22 <elliott> "Phase control" section
05:26:09 <RaphaelJ> elliott: Oh, my bad, I skipped after the INLINE section, thanks
05:29:56 * hackagebot yesod-auth-zendesk 0.1.0.3 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-0.1.0.3 (FelipeLessa)
05:36:20 <ksf_> what vector library should I use? I don't need anything fancy, but fast would be nice.
05:36:23 <ksf_> Data.Tensor?
05:42:27 <kallisti> ah it's 1.6
05:42:29 <kallisti> good
05:46:09 <MagneticDuck> Hey everyone! I have a question about how guards in case statements work... <http://hpaste.org/66704>
05:46:12 <amtal> I don't know if I'm misusing trifecta or what, but changing certain things is a giant pain in the ass. Do I understand correctly, that when a monadic parser is doing a pass, then ignoring the effects of try... It's doing so completely sequentially?
05:46:14 <MagneticDuck> I see what they do...
05:46:21 <MagneticDuck> And I can use them fine...
05:46:30 <MagneticDuck> But I don't understand HOW IT WORKS.
05:47:19 <MagneticDuck> Basically, I guess that you can put guards after a pattern like that in a case statement...
05:47:30 <amtal> So if I do `brackets (fooparser)` on "[asdf]", fooparser doesn't get "asdf". It gets "asdf]", and needs to look for ]?
05:47:43 <MagneticDuck> Is this a specialized thing?
05:47:50 <elliott> MagneticDuck: the pattern matches if the guard is true
05:47:54 <elliott> just like in a function definition
05:48:23 <MagneticDuck> Alright... maybe my question seems silly.
05:48:32 <MagneticDuck> Is that use of guards specialized for cases?
05:48:54 <elliott> well, i don't quite understand the question :) guards appear in clauses, so clauses of a function or clauses of a case
05:49:01 <elliott> in that case, all the guards are attached to a single _ pattern
05:49:04 <elliott> you can imagine
05:49:07 <elliott> f _
05:49:09 <elliott>   | cond1 = ...
05:49:10 <elliott>   | cond2 = ...
05:49:19 <elliott> in this case, you can think of it as taking f and immediately applying it to ()
05:49:37 <MagneticDuck> Yes... but you use arrows instead of equal signs.
05:50:17 <elliott> yes, that is the difference between case and function clauses
05:50:38 <amtal> So essentially, if you stick a parser inside a "braces :: p a -> p a" type deal... The thing you put in has to parse to the end of the brace itself, and double-check that the end brace exists.
05:50:52 <MagneticDuck> I guess that's just a different meaning for a case statement. It doesn't really bear resemblance to the normal case statement where you match to patterns.
05:50:56 <amtal> The sole point of using "braces" is to... Print an error message for unmatched braces?
05:51:17 <MagneticDuck> Okay... it isn't like you can put guards after wherever you put a pattern?
05:51:26 <MagneticDuck> So I could write:
05:51:30 <elliott> MagneticDuck: it does bear a resemblance
05:51:33 <MagneticDuck> case () of
05:51:33 <elliott> it's just a degenerate case
05:51:35 <elliott> you have one pattern: _
05:51:49 <MagneticDuck> Okay.
05:51:50 <elliott> here's a perhaps more helpful example:
05:51:54 <elliott> case (x,y) of
05:52:01 <elliott>   (42,z)
05:52:04 <elliott>     | magic z = ...
05:52:07 <elliott>     | otherwise = ...
05:52:11 <elliott>   (43,z) -> ...
05:52:13 <elliott>   _ -> default
05:52:18 <elliott> erm
05:52:22 <elliott> said = where i meant -> there :)
05:52:31 <MagneticDuck> Ah okay.
05:52:33 <MagneticDuck> ty
05:53:04 <MagneticDuck> Interesting.
05:56:31 <kallisti> MagneticDuck: also note that if no guards succeed for one pattern, then the case can "fall through" to other patterns.
05:56:48 <kallisti> this behavior is occasionally useful.
05:56:54 <MagneticDuck> kallisti: Yeah. Just like other guards.
05:57:29 * kallisti actually didn't know about that feature for a long time.
06:00:55 <ksf_> Data.Vec seems to be broken.
06:03:02 <jaspervdj> So I'm wondering in what ways unsafeSTToIO is unsafe
06:03:30 <elliott> it's not called that, is it?
06:03:32 <elliott> @hoogle stToIO
06:03:32 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
06:03:32 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
06:03:32 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
06:03:39 <elliott> oh.
06:03:43 <elliott> it's... not
06:03:44 <bitonic> jaspervdj: the 's' can escape
06:03:49 <byorgey> jaspervdj: http://www.haskell.org/pipermail/haskell-cafe/2009-April/060719.html
06:03:54 <bitonic> I think.
06:03:59 <cheater> i bet now you're happy they called it "unsafe".
06:04:02 <elliott> oh, of course
06:04:09 <jaspervdj> Right
06:04:11 <jaspervdj> thanks guys!
06:04:21 <elliott> byorgey: you're very quick with the haskell-cafe link :P
06:04:30 * byorgey is very quick with the Google
06:04:50 <bitonic> jaspervdj: RealWorld guarantees that you can't do anything with it
06:05:03 * byorgey also has a text file of mroe than 1MB full of organized, tagged links and other bits of information
06:05:22 <cheater> byorgey: upload please!
06:05:28 <jaspervdj> bitonic: Yeah, I didn't know about the stToIO function, looks like exactly what I need
06:05:52 <byorgey> cheater: hah, no thanks, it's also full of my to-do lists and personal thoughts etc.
06:06:12 <fryguybob> -- TODO: remember to never upload this file.
06:06:24 <bitonic> now the question is: are there any use cases for unsafeSTToIO?
06:06:27 <byorgey> I suppose I could just strip out all the links and upload those.
06:06:35 <cheater> byorgey: ah, gotcha
06:06:43 <cheater> byorgey: i've got a system like that too
06:06:56 <cheater> byorgey: how about posting an excerpt, to show what sort of structure you use for it?
06:07:26 <byorgey> cheater: it's just an emacs .org file, with three levels of hierarchy for the date and then a bunch of tagged entries under each date
06:07:35 <cheater> ah
06:07:45 <cheater> i've never used emacs org mode.
06:07:46 <byorgey> cheater: links, notes on papers I've read, to-do lists, etc.
06:08:08 <cheater> i do the same.
06:08:11 <byorgey> cheater: it's quite nice.  Though probably not worth learning emacs for, if you don't already know emacs
06:08:19 <hpaste> timthelion pasted “How do I do abstract types then?” at http://hpaste.org/66706
06:08:22 <cheater> but for me, it's a directory structure, i keep my papers and notes in the same place
06:08:35 <cheater> this is nice because e.g. i have a lot of videos in my haskell dir
06:08:36 <byorgey> cheater: yeah, that makes sense too
06:08:43 <byorgey> right, cool
06:08:48 <timthelion> How do I do abstract types?  I tried defining a function as f :: a -> a and it don't work :(
06:08:53 <cheater> the haskell dir has many subdirs too
06:08:59 <cheater> it's all kinda fractal as need happens
06:09:20 <cheater> i started doing that last year and it was the best thing i came up with for organizing my work ever
06:09:34 <byorgey> timthelion: you have to parameterize the ThreadObject type over a
06:09:38 <byorgey> timthelion: data ThreadObject a = ...
06:09:45 <timthelion> byorgey: OH, thank you
06:10:10 <cheater> mostly because it allows me to pull together various bits of info i learn about during a very long period of time: if two files end up in the same dir, but two years apart, i'll probably notice there's a connection. wouldn't happen if it were all segregated by date.
06:11:37 <byorgey> cheater: yeah, good point, that's one downside of my system
06:14:09 <cheater> what would you say are the strong points of your system?
06:14:32 <cheater> there must be a lot lacking in the way i organize
06:14:45 <byorgey> cheater: one is that it's a lot easier to review what I've been thinking about/working on recently.
06:14:53 <cheater> mhm
06:15:09 <byorgey> cheater: it's also easy to search by tag, which I presume is difficult in a hierarchically-organized system
06:15:19 <byorgey> unless you have special tools to process tags and do the search for you
06:15:21 <dp_wiz> What's wrong ith C.M.Writer example in http://learnyouahaskell.com/for-a-few-monads-more#writer? Ghc complains with "Not in scope: data constructor `Writer'"...
06:15:35 <elliott> dp_wiz: use "writer" instead.
06:15:38 <elliott> library changes - sorry.
06:15:48 <cheater> byorgey: for me, the hierarchy is the tags
06:15:58 <cheater> however, there's only one tag per item
06:15:59 <cheater> that's bad
06:16:26 <cheater> so i'll have a tag called topics/computers/haskell/haskell guis/
06:16:38 <byorgey> cheater: right, to me those are "categories" and not "tags" -- ultimately it doesn't matter what you call it, but it's a very different organizational system.
06:16:42 <cheater> and then i'll have a tag called topics/computers/haskell/haskell refactoring
06:16:54 <cheater> but those can't share elements unless i symlink, but symlinking is such a drag
06:17:10 <cheater> what sort of tags do you use?
06:17:27 <byorgey> cheater: right. and what about the haskell guis that also have to do with mathematics pedagogy and dinosaurs? etc.
06:17:56 <byorgey> cheater: I use all sorts of tags. I could generate a tag cloud if you really wanted. =)
06:17:57 <cheater> yeah
06:18:05 <cheater> that's very cool
06:18:13 <cheater> you know i'm looking forward to getting on with btrfs
06:18:17 <cheater> i heard it allows tagging
06:18:25 <cheater> or at least doesn't preclude it
06:18:32 <cheater> i think it could be very very fun
06:18:40 <cheater> i have so much stuff laying around that i could tag
06:18:54 <cheater> just my music to name a classical example
06:19:18 <byorgey> oh, yeah, a file system that supported this kind of thing would be sweet
06:19:32 <byorgey> hmm, I just realized perhaps we should move to -blah
06:20:37 <cheater> well i'm on my way to the gym
06:20:45 <cheater> so let's just leave it at that ;)
06:21:20 <byorgey> cheater: ok, ncie chatting with you, enjoy the gym =)
06:21:25 <byorgey> *nice
06:21:58 <cheater> you too byorgey :)) thx
06:24:22 <hpaste> amtal pasted “how do parser combinators work” at http://hpaste.org/66707
06:24:59 <cheater> oh look what i found out before going out byorgey
06:25:01 <cheater> man setfattr
06:25:07 <cheater> works on ext*
06:25:21 <byorgey> woah, really?
06:27:10 <byorgey> cheater: when I try it on my machine I get 'operation not supported' errors =P
06:27:40 <cheater> what FS?
06:27:41 <cheater> fat?
06:28:26 <Phlogistique> cheater: you're fat.
06:28:40 <cheater> :<
06:29:02 <byorgey> uh, I forget how to check what filesystem I have
06:29:11 <Phlogistique> byorgey: df
06:29:15 <cheater> mount
06:29:39 <Phlogistique> oops, df doesn't tell about filesystem types
06:29:41 <cheater> in the weights of one girl, a "slightly overweight young leonardo di caprio"
06:29:49 <cheater> i would say that's still a bit from fat ;)
06:29:59 <byorgey> oh, it's nfs
06:30:10 <cheater> nfs doesn't support anything
06:30:13 <byorgey> right
06:30:15 <cheater> why are you using nfs?
06:30:23 <byorgey> this is my desktop machine at school
06:30:25 <geekosaur> it does with the right option
06:30:43 <cheater> i fully intend to go btrfs once their raid 5 style mirroring is fully implemented
06:30:43 <geekosaur> (df -T)
06:32:05 <byorgey> hmm, but I even get 'operation not supported' when doing setfattr on a file stored on the local hard drive (ext3)
06:32:26 <byorgey> well, whatever, I need to finish making slides for my talk
06:34:15 <cheater> byorgey: http://fengnet.com/book/Linux.Server.Hacks.Volume.Two/0596100825/morelnxsvrhks-CHP-5-SECT-10.html
06:34:21 <cheater> yeah, and i gotta go
06:34:22 <cheater> :)
06:34:23 <cheater> cya
06:34:27 <byorgey> later
06:38:33 <hpaste> “_Mikey” pasted “replace” at http://hpaste.org/66708
06:39:01 <_Mikey> just wondering why my replace func complains about being infinite
06:42:55 <mekeor> _Mikey: there's one closing bracket too much, i think.
06:43:16 <mekeor> _Mikey: replace "list)" with "list", i think.
06:43:35 <_Mikey> ahh
06:43:46 <_Mikey> sorry that was an edit to make it cleaner for hpaste
06:44:04 <mekeor> ah
06:44:04 <_Mikey> it still throws the error    Occurs check: cannot construct the infinite type: a0 = [a0]
06:44:27 <joachifm> _Mikey: consider the types of (:) and take.
06:44:41 <mekeor> well, you do `a : b : c' but a is a list, b is an element, and c is a list.
06:44:47 <_Mikey> eessh
06:44:55 <_Mikey> I need a :[]
06:44:56 <mekeor> _Mikey: you've to use ++ instead, i think
06:45:26 <mekeor> take (index-1) list ++ (item : drop index list)
06:45:49 <ozataman> why the heck would cabal not chose a lower than latest version during dependency resolving in order to satisfy all the packages listed in a .cabal file? It keeps trying to install the very latest of some of the packages deep in the dependency chain!!!
06:46:12 <mekeor> > let index=5; list=[1..10]; item=100; in take (index-1) list ++ (item : drop index list)
06:46:14 <lambdabot>   [1,2,3,4,100,6,7,8,9,10]
06:46:18 <mekeor> bump
06:46:30 <_Mikey> ok
06:46:58 <_Mikey> but.. I was trying to avoid ++ because when the lists get long it is more expensive
06:47:14 <_Mikey> but I'm not sure I think think it might be the same either way
06:48:16 <mekeor> _Mikey: hmm.. idk.
06:48:33 <elliott> <ozataman> why the heck would cabal not chose a lower than latest version during dependency resolving in order to satisfy all the packages listed in a .cabal file? It keeps trying to install the very latest of some of the packages deep in the dependency chain!!!
06:48:39 <mekeor> _Mikey: btw, i think using span instead of take&drop is more efficient.
06:48:47 <elliott> ozataman: probably to avoid reinstalls or such
06:48:49 <elliott> try development cabal version with --solver=modular.
06:49:07 <ozataman> elliott: it is doing it on a fresh cabal-dev sandbox
06:49:14 <rbasken> who knows a good book for learning haskell?
06:49:35 <_Mikey> RWH
06:49:36 <mekeor> _Mikey: oh, no, actually `splitAt'.
06:49:41 <mekeor> @where rwh
06:49:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:49:43 <_Mikey> @RWH
06:49:44 <mekeor> @where lyah
06:49:44 <lambdabot> Unknown command, try @list
06:49:44 <lambdabot> http://www.learnyouahaskell.com/
06:49:46 <_Mikey> ohh
06:49:51 <mekeor> :Þ
06:50:00 <_Mikey> splitAt could do it
06:50:06 <mekeor> yep
06:50:11 <rbasken> thanx
06:50:14 <dp_wiz> Is there a transformer or whatever to add IO capabilities to existing monad?
06:50:15 <_Mikey> I think we should make a library function though
06:50:17 <elliott> ozataman: modular solver then
06:50:18 <_Mikey> :)
06:50:25 <ozataman> what used to build from scratch a few days ago doesn't build anymore, just because I did a cabal update!
06:50:34 <ozataman> yeah, guess to
06:50:41 <ozataman> where's the devel repo?
06:50:59 <rbasken> i look for a haskell solution of the einstein ridle
06:51:19 <ozataman> nvm, found it
06:51:46 <elliott> ozataman: make sure to use the right branch
06:51:47 <elliott> what ghc version?
06:51:52 <ozataman> elliott: 7.4.1
06:51:54 <elliott> if 7.4.1, you want to fetch the 1.14 branch instead
06:52:00 <ozataman> elliott: and funny, cabal install darcs doesn't work due to dep hell :)
06:52:02 <elliott> ok, that's:
06:52:06 <elliott> ozataman: use the darcs binary
06:52:23 <elliott> http://wiki.darcs.net/Binaries -> darcs get --lazy darcs get http://darcs.haskell.org/cabal-branches/cabal-1.14/
06:52:26 <roconnor> how do I do cabal fetch dependencies?
06:52:26 <elliott> blow away ~/.cabal, ~/.ghc
06:52:33 <elliott> cd cabal-install, bootstrap.sh
06:52:37 <elliott> roconnor: do you want cabal install --dependencies-only?
06:52:45 <elliott> ozataman: then try your install plan again with --solver=modular
06:52:58 <roconnor> elliott: yes
06:53:54 <Axman6> @check \n xs -> let (as,bs) = splitAt n xs in length xs == length as + length bs
06:53:55 <lambdabot>   "OK, passed 500 tests."
06:54:39 <ozgura> how does one debug parsec? I have a parser which fails to parse some input but I cannot see why.
06:55:22 <ozgura> how does one debug a parser implemented using parsec is probably a better way to put it, as I don't want to debug parsec itself.
07:05:34 <Absolute0> Is it wrong to thing of >>= as fmap with the parameters swapped?
07:06:40 <byorgey> Absolute0: yes.
07:06:46 <byorgey> @type (>>=)
07:06:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:06:50 <byorgey> @type flip fmap
07:06:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
07:07:01 <byorgey> spot the difference!
07:07:58 <Absolute0> fmap (+2) Just 2 = Just 2 >>= (+2)
07:08:03 <Absolute0> if y can get that to run...
07:08:07 <Absolute0> if i
07:09:39 <byorgey> those are not equal.  in fact, the second does not type check.
07:09:46 <byorgey> > fmap (+2) (Just 2)
07:09:47 <lambdabot>   Just 4
07:09:51 <byorgey> > Just 2 >>= (+2)
07:09:52 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
07:09:52 <lambdabot>    arising from a use of...
07:10:05 <Absolute0> I see, fmap returns a regular type, >>= expects the function to return a type within a context.
07:10:13 <byorgey> right.
07:10:49 <Absolute0> i think that yhal's over explanation of things is unecessary
07:10:52 <ksf_> what's the point of Data.Reify if I can't reify more than one value?
07:11:07 <byorgey> yhal?
07:11:21 <Absolute0> lyah
07:11:28 <ksf_> reader transformers, at least, can be stacked.
07:12:01 * elliott doesn't understand ksf_'s question
07:12:02 <Axman6> Absolute0: well, you seem to have got to a point where you don't understand something quite fundamental, so I guess you should pay more attention when reading LYAH ;)
07:12:02 <Zedrikov> Hi, is there a way to keep all the files generated by Haddock?
07:12:06 <elliott> Data.Reify is for observable sharing
07:12:08 <byorgey> overexplanations are always unnecessary.  But what counts as overexplanation and what is not enough depends largely on the reader, not the explanation.
07:12:18 <ksf_> oh. Data.Reflect, I mean.
07:12:33 <byorgey> although that's not to say some explanations aren't better than others.
07:12:37 <elliott> do you mean Data.Reflection?
07:12:42 <Zedrikov> My package has a problem, with the Haddock prologue, but when I want to read it, it has been cleared.
07:13:24 <ksf_> Absolute0, try the typeclassopedia, it has all the useful overexplanation.
07:13:58 <Absolute0> Axman6: I understand better with examples, LYAH explains more.
07:14:18 <elliott> ksf_: ?
07:14:50 <ksf_> elliot, http://hackage.haskell.org/packages/archive/reflection/1.1.3/doc/html/Data-Reflection.html
07:14:56 <elliott> right
07:15:06 <elliott> well, I don't quite understand your confusion :)
07:15:09 <elliott> you can reify multiple values
07:15:11 <elliott> nest them
07:15:13 <elliott> they each get their own "s"
07:15:31 <Axman6> Absolute0: examples can only go so far if you haven't understood the fundamental concepts
07:15:33 <elliott> or reify a product type...
07:15:37 <byorgey> Zedrikov: the files generated by Haddock shouldn't disappear.  if you generate them with 'cabal haddock' they are generated into dist/doc/html/.
07:15:37 <ksf_> byorgey, btw, what ever happened to the idea of a typeclassopedia 2.0 with an arrowchoice etc. track?
07:15:58 <Axman6> Absolute0: specifically, you should have been able to see form the types of fmap and (>>=) that they are indeed not the same thing
07:16:03 <Axman6> from*
07:16:07 <byorgey> ksf_: I haven't worked on it in a while, but it's still on my list of things to get around to
07:16:11 <ksf_> elliott, yes, but I've got to pass the proxy around just like I would pass around the value.
07:16:12 <byorgey> ksf_: I've already done some work updating it
07:16:18 <elliott> ksf_: nope!
07:16:21 <elliott> ksf_: that's the thing
07:16:31 <elliott> ksf_: you only need the Proxy to unify the types right at the start
07:16:39 <elliott> ksf_: everywhere else, you _only_ need the "s" in your type signature
07:16:43 <elliott> you can recreate the proxy from ANYWHERE
07:16:48 <elliott> just do (Proxy :: Proxy s)
07:16:49 <Absolute0> Axman6: by comparing concepts to earlier concepts that we already understand, learning becomes easier.
07:16:55 <elliott> (with ScopedTypeVariables)
07:17:05 <Absolute0> I would now say that (>>=) is a beefed up fmap.
07:17:14 <elliott> ksf_: this means you can have instances with Reifies constraints, and it gets propagated automatically -- the s type _is_ the value
07:17:22 <elliott> the Proxy is just (), it contains nothing
07:17:27 <elliott> it's just there to let you know what the type is
07:17:51 <Axman6> Absolute0: i wouldn't. fmap can be implemented in terms of (>>=), but they serve very different purposes
07:17:57 <Zedrikov> byorgey: cabal haddock reports me haddock: failed to parse haddock prologue from file: dist/doc/html/<package>/haddock-prolog<hash>.txt, but when I list this directory I don't find this file
07:17:58 <ksf_> but when I need to use scopedtypevariables I need to have type signatures and could thus equally well be using implicit parameters.
07:18:06 <elliott> Absolute0: well, (>>=) is fmap + join afterwards
07:18:34 <byorgey> Zedrikov: oh, hmm, it sounds like the Haddock is not getting generated in the first place
07:18:34 <elliott> ksf_: the advantages over implicit parameters are well-documented by the paper. one: you can have _multiple_ contexts here, with implicit parameters you can't mix two together. (and reflection stops you mixing two unrelated contexts)
07:18:40 <Clint> Axman6: did you catch my complaint about your cereal blog post?
07:18:42 <elliott> ksf_: two, adding a type signature can't change the value you get
07:18:48 <elliott> ksf_: three, no dynamically-scoped weirdness.
07:18:49 <byorgey> Zedrikov: sorry, I don't really know then
07:18:58 <Axman6> Clint: i think so. mind telling me where the error is again?
07:19:18 <Clint> Axman6: i think it was a lack of backticks somewhere in many or many1
07:19:48 <elliott> ksf_: (oh, and the paper says that implicit params can't appear in the constraint of class or instance declarations, which would be a major flaw, but which I don't believe holds of GHC)
07:20:00 <elliott> ksf_: oh yeah, and implicit parameters break beta-reduction. reflection doesn't
07:20:15 <Absolute0> typeclassopedia looks very nice
07:20:18 <Absolute0> i'll give it a read
07:20:40 <elliott> ksf_: but really the paper enumerates the advantages better than i could
07:20:44 <Axman6> Clint: many p = many1 p mplus return [] that one?
07:20:50 <Clint> sounds right
07:21:17 <elliott> ksf_: (there's also the fact that implicit parameters are so unloved because of these problems that they're all but de-facto deprecated)
07:22:11 <ksf_> well, so far I refrained from actually reading it because I didn't come across examples of how it's actually used in the implicit parameters / readerT way
07:22:45 <Absolute0> is there a typeclassopedia pdf or mobi version?
07:23:02 <elliott> Absolute0: the wiki page is the official one now, any pdfs are probably old
07:23:02 <ksf_> the original version is a pdf.
07:23:17 <Absolute0> https://www.google.com/search?sourceid=chrome&client=ubuntu&channel=cs&ie=UTF-8&q=Typeclassopedia+pdf
07:23:19 <elliott> ksf_: well, examples/Monoid.hs is an example, so is my cheap modular arithmetic thing on hpaste (that mostly looks like the paper)
07:23:23 <elliott> ksf_: and the paper itself has several strong examples.
07:23:32 <Absolute0> is there any app that nicely converts web pages to pdf?
07:23:46 <elliott> (http://hpaste.org/66565 for my hpaste)
07:24:13 <elliott> seriously though, just read the paper ;)
07:24:25 <Absolute0> i am at work, and I have a kindle
07:24:41 <Absolute0> can read it on the commut back
07:25:18 <elliott> oh, i meant ksf_
07:25:20 <elliott> not you :)
07:25:46 <Axman6> Clint: hmm, not sure what's up, they're showing up in the editing window just fine, but not in the browser
07:26:05 <Clint> oh well
07:26:38 <Axman6> no idea how to fix that. the post is quite old anyway
07:29:14 <seven> hi
07:30:37 <seven> is it possible to return a string with function which prints sth
07:31:02 <seven> sory list not string
07:31:07 <seven> but not IO list
07:31:31 <seven> so i have normal function which have side effect of printing list
07:31:42 <ciaranm> seven: no
07:31:42 <elliott> No.
07:32:03 <seven> or maby somehow unpack that list from monad outside?
07:33:29 <seven> or some other idea on how to do that?
07:33:55 <seven> (print list, which i want to do sth with leater)
07:38:05 <rwbarton> you write a function that returns a IO [whatever].
07:38:51 <rwbarton> are you doing this for debugging?
07:38:56 <seven> i have
07:39:04 <seven> sort of
07:39:28 <seven> but i will need output anyway
07:40:01 * hackagebot midimory 0.0 - A Memory-like (Concentration, Pairs, ...) game for tones  http://hackage.haskell.org/package/midimory-0.0 (HenningThielemann)
07:41:47 <Peaker> I wrote a little Python script around "cabal update" that prints progress (by stat'ing the download/extract files), and extract time is non-negligible. It can probably be sped up significantly by parallelizing the extract with the download
07:47:26 <Axman6> Peaker: time for more iteratees?
07:49:44 * Axman6 -> sleep
08:00:01 * hackagebot tagged 0.4.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.1 (EdwardKmett)
08:00:03 * hackagebot midimory 0.0.0.1 - A Memory-like (Concentration, Pairs, ...) game for tones  http://hackage.haskell.org/package/midimory-0.0.0.1 (HenningThielemann)
08:06:12 <twomashi> What's the best way to create a Set of elements in a Map given a list of keys?
08:06:53 <ChristianS> twomashi: do you want a set or a map?
08:07:00 <twomashi> a set
08:08:37 <ChristianS> Data.Set.fromList should do what you want
08:09:04 <twomashi> thing is that the lookup method of the Map returns a Maybe… So I can't simply call lookup for each of the keys in my list or I will have a list of Maybes
08:09:07 <twomashi> which seems useless
08:09:25 <twomashi> a Just [t] would not be useless
08:09:37 <twomashi> but a [Maybe t] yes
08:10:06 <rwbarton> I don't understand your original question, it seems to have either too many or too few words.
08:10:18 <rwbarton> can you actually say what the input(s) and output(s) are
08:11:11 <copumpkin> so you want to filter the keys of the map by the list and return a set of those keys?
08:11:45 <kallisti> filter (`elem` ls) m
08:12:30 <twomashi> no
08:12:39 <kallisti> I think he wants to filer the values.
08:12:42 <kallisti> *filter
08:12:43 <twomashi> ok forget the set
08:12:43 <solarus> > foldrWithKey (\k a b -> if elem k [1,3] then a:b else b) [] (fromList [(1,'a'),(2,'b'),(3,'c')])
08:12:44 <lambdabot>   Not in scope: `foldrWithKey'
08:12:47 <solarus> meh
08:12:52 * ksf_ gives up
08:12:53 <solarus> works anywap
08:12:54 <solarus> y
08:12:59 <twomashi> I want to get a list of values from a Map given a list of keys
08:13:06 <kallisti> ah
08:13:27 <twomashi> but I cant map the keys over Map.lookup because it returns a Maybe
08:13:32 <solarus> twomashi: foldrWithKey is what you want
08:13:33 <twomashi> and a list of Maybe is useless to me
08:13:42 <kallisti> mapM (`lookup m`) ls
08:13:46 <kallisti> like this?
08:13:53 <ksf_> elliott, can you give me a simple example of using data.reflect without getting monoid instances or anything involved? that is, nothing you could'nt do with Reader
08:13:55 <rwbarton> how can anyone know what he wants :/
08:14:12 <copumpkin> > mconcat [Just 5, Nothing, Just 4, Nothing, Nothing]
08:14:13 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:14:13 <lambdabot>    `Data.Monoid.Monoid t'
08:14:13 <lambdabot>  ...
08:14:14 <kallisti> twomashi: ls is a list of keys, m is the map.
08:14:18 <copumpkin> > msum [Just 5, Nothing, Just 4, Nothing, Nothing]
08:14:18 <lambdabot>   Just 5
08:14:21 <copumpkin> whoops
08:14:27 <twomashi> solarus, kallisti, thanks I will try both
08:14:38 <copumpkin> > [x | Just x <- [Just 5, Nothing, Just 4, Nothing, Nothing]]
08:14:38 <lambdabot>   [5,4]
08:14:47 <kallisti> (note I didn't pay any attention to module qualification so you'll have to do that yourself)
08:14:49 <rwbarton> @hoogle [Maybe a] -> [a]
08:14:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:14:50 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:14:50 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:14:53 <copumpkin> oh yeah
08:14:55 <copumpkin> that one
08:14:59 <ksf_> or is it plain impossible to get ghc to infer that (Reifies s Foo) must be in the context?
08:15:02 * hackagebot Vec-Boolean 1.0.4 - Provides Boolean instances for the Vec package  http://hackage.haskell.org/package/Vec-Boolean-1.0.4 (TobiasBexelius)
08:15:02 <solarus> twomashi: in my example [1,3] was the list of keys
08:15:05 <kallisti> rwbarton: mapM should be sufficient
08:15:10 <kallisti> but yes mapMaybe or catMaybes is good.
08:15:11 <rwbarton> that does something totally different
08:15:14 <copumpkin> it's annoying cause it should be called justs, according to the lefts/rights convention set in Data.Either
08:15:20 <solarus> you can take that list as an argument instead and it should work
08:15:26 <kallisti> rwbarton: assuming he wants a Maybe [a], if he wants just an a then he should use mapMaybe
08:15:36 <kallisti> mapMaybe (`lookup m`) ls
08:15:39 <rwbarton> why are we guessing what he wants
08:16:09 <elliott> <ksf_> elliott, can you give me a simple example of using data.reflect without getting monoid instances or anything involved? that is, nothing you could'nt do with Reader
08:16:26 <elliott> well, the modular thing qualifies, but ok, i'll give a quick example
08:16:28 <kallisti> copumpkin: it should be catLeft and catRight based on the standard set by catMaybe. :P
08:16:32 <elliott> sec
08:16:33 <kallisti> (that makes less sense)
08:16:34 <copumpkin> eww
08:16:46 <copumpkin> kallisti: Maybe is the type constructor, Left/Right are data constructors
08:16:51 <kallisti> yes, because that.
08:17:17 <kallisti> the point was that the standard was arbitrarily chosen to exist.
08:17:18 * fryguybob proposes nothings
08:18:12 * kallisti wonders why haskell-cabal-mode isn't highlighting source-repository correctly.
08:18:31 <kallisti> it's been around since 1.6
08:18:37 <kallisti> so it's not like it's cutting edge or anything.
08:20:02 * hackagebot Vec-Transform 1.0.5 - Extends the Vec package with some 4x4 transform matrices  http://hackage.haskell.org/package/Vec-Transform-1.0.5 (TobiasBexelius)
08:20:04 * hackagebot data-lens 2.9.0 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.9.0 (RussellOConnor)
08:21:06 <elliott> ksf_: one minute
08:21:54 * kallisti wonders if anyone has made a hashmap zipper on Hackage. :D
08:22:17 <kallisti> (yes that's basically just a HashMap with an associated key)
08:23:02 <Zedrikov> what interesting options are available to find out why haddock failed?
08:23:19 <Zedrikov> I got an error and do not see where it is.
08:23:27 <kallisti> it should just go to stderr
08:23:30 <kallisti> as far as I know.
08:24:00 <Zedrikov> stderr reports only that an error occured, not what caused it
08:24:59 <kallisti> well you could try -v, but that sounds odd to me.
08:25:06 <kallisti> that wouldn't provide an error message.
08:25:08 <kallisti> +it
08:25:14 <ksf_> oh.
08:25:30 <Zedrikov> More precisely, I get: haddock: failed to parse haddock prologue from file: dist/doc/html/xchat-plugin/haddock-prolog27188.txt
08:25:41 <kallisti> oh
08:25:55 <Zedrikov> Indeed the file is not created; but I have no indication why it wasn't.
08:26:07 <kallisti> is xchat-plugin your library or someone elses?
08:26:23 <Zedrikov> It is one I intended to do
08:26:31 <Zedrikov> It is not someone else
08:27:06 <ksf_> nah that doesn't get s into scope, either.
08:27:11 <kallisti> Zedrikov: http://trac.haskell.org/haddock/ticket/183
08:27:14 <kallisti> this may be relevant.
08:27:27 <kallisti> they had an issue with their cabal file it seems.
08:27:40 <hpaste> elliott pasted “reflection example” at http://hpaste.org/66715
08:27:45 <elliott> ksf_: ^
08:28:31 <elliott> edwardk: (maybe something like that would be nice in the examples dir? ^)
08:28:48 <kallisti> elliott: even though ReaderT performs a similar function it can't go in all of the places reflection can.
08:29:03 <kallisti> (actually I'm not even sure why I mention it)
08:29:14 <edwardk>  (Reifies p MyConfig) => Report p -- no need for the magic parens there ;)
08:29:18 <kallisti> of course you probably already know this. :P
08:29:28 <elliott> edwardk: i put parens around all of my contexts
08:29:32 <elliott> it's just a thing i do
08:29:36 <edwardk> i deliberately remove them ;)
08:29:49 * edwardk wages a one man war on parens
08:29:53 * ksf_ looks
08:29:59 <monochrom> I put half of them
08:30:16 <monochrom> Reifies p MyConfig) => Report p
08:30:25 <edwardk> monochrom++
08:30:28 <kallisti> seems legit.
08:31:03 <edwardk> monochrom is a c preprocessing crazy. what he didn't tell you was #define Reifies (
08:31:07 <kallisti> so ScopedTypeVariables essentially follows scoping rules similar to normal variables?
08:31:31 <edwardk> kallisti: if you have a forall they'll flow from the signature, otherwise they are introduced by ::'s
08:31:51 <elliott> kallisti: yes, if you use forall
08:31:58 <elliott> stupid backwards compatibility thing i think
08:32:22 <kallisti> it also looks as though they exist within instance declarations.
08:32:32 <kallisti> er, I mean, the instance variables are in scope throughout the method declarations
08:32:36 <kallisti> based on elliott's example
08:32:44 <edwardk> elliott: anyways feel free to throw it in the examples folder
08:32:55 <edwardk> i'll strip off the parens later ;)
08:33:10 <elliott> yeah, i'll get it running on hugs ootb first :P
08:33:11 <edwardk> kallisti: yep
08:33:20 <kallisti> I actually think I prefer explicit unification functions to scoped type variables...
08:33:29 <elliott> kallisti: you say that now
08:33:34 <edwardk> kallisti: its a mixed bag
08:33:34 <elliott> try fishing the "p" out of a complex type signature
08:33:43 <elliott> with a weird one-use explicitly-typed function
08:33:55 <elliott> (of course, running on hugs is far more important than such trivial concerns such as "helping people use the library")
08:34:01 <edwardk> kallisti: plus scoped type variables don't have to be inlined to work, so they appear to be slightly faster in practice ;)
08:34:16 <kallisti> ah yes, that's true.
08:34:36 <elliott> hahaha
08:34:36 <kallisti> my programs often screech to a halt because of all of those explicit unifying no-op functions
08:34:44 <elliott> well you know
08:34:56 <elliott> you have to offset the copies of your 100 million field records every time you change a field
08:35:22 <kallisti> yeah, I'm getting kind of disenchanted with Haskell these days.
08:35:30 <edwardk> kallisti: ?
08:35:31 <ksf_> elliott, well, I was trying to get rid of the type signature in run.
08:35:43 <edwardk> kallisti: =)
08:35:45 <ksf_> I should probably think about how to move more code into calculate.
08:35:48 <elliott> ksf_: you can't -- that's where it receives the s in the first place!
08:35:51 <kallisti> I think edwardk missed the jo -- there we go. :P
08:35:57 <elliott> ksf_: you can turn it into IO (Proxy p)
08:36:00 <elliott> rather than Proxy p -> IO ()
08:36:01 <elliott> if that makes you happier
08:36:34 <elliott> ksf_: the point is that you annotate all the relevant data types with the reified type
08:36:46 <kallisti> the Hackage people haven't responded to my username request in 3 whole hours. This is ludicrous.
08:36:46 <elliott> that way, it ensures you never mix data from two different reifications
08:36:56 <elliott> and it propagates and infers without needing to pass Proxys around everywhere
08:37:23 <elliott> ksf_: anyway don't try and match run/calculate/etc. too directly -- the whole thing i was trying to demonstrate is that you can have all sorts of code and it just fits together as long as you have that "p"
08:37:57 <kallisti> elliott: I was wondering if it would be possible to do some kind of equality on selenium versions.
08:38:00 <kallisti> what do you think?
08:38:09 <kallisti> (I don't see a particular need for it, but I was wondering nonetheless)
08:38:15 <elliott> INSUFFICIENT DATA FOR MEANINGFUL ANSWER
08:38:33 <edwardk> kallisti: yeah its almost like they are in a different timezone or something ;)
08:38:36 <kallisti> kill -9 elliott
08:38:37 * elliott will henceforth use that as his default "vague question" response
08:39:01 <kallisti> elliott: the vast majority of human speech acts is vague.
08:39:08 <kallisti> get used to it.
08:39:54 <kallisti> basically the question is something like:
08:40:44 <kallisti> if I have data A = A; data B = B;  can I write a (meaningful) equality function on them, using some kind of type trickery.
08:41:15 <elliott> step 1. what type does your function have
08:41:16 <olsner> just define: eq2 A B = True
08:41:19 <kallisti> assuming A and B are, say, versions. It may be useful to test if 2 versions are the same.
08:41:27 <kallisti> elliott: yes, that's part of the question. :P
08:41:33 <elliott> well you see
08:41:34 <elliott> if you use reflection
08:41:41 <elliott> you just define one ADT with all your versions, which can have Eq
08:41:49 <elliott> and you don't need to define the type-level versions
08:41:52 <elliott> because it makes them automatically ;)
08:42:00 <kallisti> that's going to be a fun instance.
08:42:06 <elliott> eh?
08:42:11 <elliott> you won't have to write any instances
08:42:20 <kallisti> the serialization instances, are all going to look fun. lots of cases for different versions.
08:42:23 <elliott> (though you might want to)
08:42:29 <ksf_> hmm. considering the code I have is heavily monadic (IO) anyway, stacks seem to be the choice with less noise. (modulo liftIO)
08:42:41 <elliott> kallisti: nah: just delegate it to the class edwardk told you to define for versions
08:42:53 <elliott> ksf_: sounds like you've found an opportunity for improvement in your code ;)
08:43:12 <elliott> but yeah it's not like this is less typing than ReaderT if that's all you do
08:43:23 <elliott> kallisti: so that each version has its own code for serialising
08:43:32 <elliott> kallisti: (and newer versions could delegate to older versions when nothing changed)
08:43:33 <ksf_> elliott, I'm eagerly awaiting your pure implementation of xhb ;)
08:43:39 <kallisti> elliott: doesn't that imply not using a singular ADT?
08:43:54 <kallisti> if there's a class involved?
08:44:03 <kallisti> I mean, unless there's just one instance for this class. :P
08:44:12 <elliott> kallisti: well, you can encode it into the ADT itself... but that would work too
08:44:27 <elliott> so many options! only one of them will work best for you, but i have no idea which, so I just give you them all
08:44:34 <kallisti> ah okay, I see.
08:44:42 <kallisti> yeah I probably have no use for equality.
08:44:58 <elliott> ksf_: well, start by removing the X server...
08:45:28 <ksf_> I'm pondering making the X server an actual actor.
08:45:32 <ksf_> or, rather, multiple ones.
08:46:19 <kallisti> edwardk: what timezone?
08:46:42 <ksf_> xhb needs an interface overhaul, anyway. while the x protocol gives you error or success notifications for everything (asyncronously), the current implementation requires a global error handler.
08:46:46 <edwardk> i think they are all in GMT or thereabouts
08:47:03 <ksf_> ...for calls that don't return a result, that is.
08:47:07 <elliott> everyone that matters is in GMT
08:47:11 <elliott> or BST, depending
08:47:59 <kallisti> what is the criteria? the website wasn't very specific, so I assumed "not much"
08:48:03 <kallisti> I just included a link to the code..
08:48:08 <mauke> s/is/are/
08:48:09 <kallisti> should be sufficient.
08:48:24 <elliott> kallisti: for hackage usernames?
08:48:26 <kallisti> yes.
08:48:28 <elliott> nothing
08:48:31 <kallisti> excellent.
08:48:36 <elliott> i just said "gimme an account so i can upload acme-strfry" and I got it in 4 minutes
08:49:02 <elliott> actually, 5 minutes
08:49:18 <elliott> oh, it was supply-monad, not acme-strfry.
08:49:22 <elliott> but someone beat me to that particular punch
08:49:25 <thoughtpolice> the type level literal work got merged into GHC head \o/
08:51:09 <edwardk> thoughtpolice: woot!
08:51:26 <edwardk> thoughtpolice foo :: Proxy "Int"
08:52:00 <edwardk> we'll be able to swap elliott's slow path to use kind level bytes
08:52:15 <edwardk> or a kind level IntPtr ;)
08:58:52 <Veinor> i wonder how much of dependency hell is due to people using overly strict cabal dependencies
08:59:28 <kallisti> what is the difference between using Setup.hs and using cabal directly without arguments?
08:59:31 <ksf_> a lot.
08:59:48 <ksf_> and breakage hell is caused by people not using overly strict dependencies.
08:59:49 <Veinor> specifically, dependencies on text-0.11.7.3 or whatever when all they use is T.pack and T.unpack
09:00:19 <ksf_> leksah may be to blame, there.
09:00:34 <Veinor> well, i was just making that case up
09:00:43 <ksf_> iirc, that is last I tried it, which is quite a long time ago, it auto-generated dependencies on specific versions.
09:00:49 <Veinor> ah, that's unfortunate
09:01:24 <ksf_> that's one of the reasons we need a maintenance squad that fixes such things with extreme prejudice.
09:01:56 <ksf_> ...as most people don't commit fixes as not to infringe on the maintainer.
09:02:49 <Veinor> yeah
09:03:10 <Veinor> i tend to run into dependency hell more often thatn brakeage hell
09:03:54 <ksf_> cabal install --redefine-constraint might be useful.
09:04:38 <t7> hmm i cant have a list of things that implement a class can i.. ?
09:04:51 <ksf_> yes and no.
09:05:14 <t7> How do people write games without oop?
09:05:44 <ksf_> you can definitely write instances that depend on some other instance, and that gives you an instance for a whole set of types.
09:06:24 <ksf_> I'm a game developer and have yet to come across a game that had any serious amount of oop.
09:06:25 <Veinor> ksf_: --redefine-constraint?
09:06:36 <t7> ksf_: source engine?
09:06:42 <ksf_> yes, to switch a constraint on a particular package to a new one.
09:07:00 <t7> i thought everyone derives entitys from some base class
09:07:04 <ksf_> t7, nope, j2me.
09:07:23 <ksf_> using oop under j2me is about as broken as using java for embedded devices in the first place.
09:07:23 <Veinor> doesn't seem to exist for me
09:07:31 <t7> how do you store all the monsters in the game
09:07:36 <t7> a list for each type?
09:07:45 <ksf_> well, in a struct or something.
09:07:49 <Mathnerd314> t7: entities aren't objects
09:08:24 <Mathnerd314> although they might be represented by them
09:08:37 <ksf_> when it comes to j2me, a couple arrays.
09:09:06 <t7> ksf_: what if you have 100 different types of thing in game that all need updating
09:09:33 <ksf_> then you make an array that represents the type of every unit.
09:09:52 <dmwit> ?remember RaymondChen The problem with being dead right is you're dead.
09:09:52 <lambdabot> Done.
09:10:04 <t7> so most units will carry round lots of redundant member variables ?
09:10:05 * hackagebot stm-conduit 0.4.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.4.0 (ClarkGaebel)
09:10:18 <ksf_> ...the .class file overhead for 100 classes, alone, everything else being similar, amounts to a couple of fullscreen images.
09:10:37 <ksf_> and you rather want more sprites than bloated code.
09:10:48 <ksf_> t7, nope.
09:11:41 <ksf_> t7, but I'm talking about embedded programming. haskell is another league.
09:15:03 <ksf_> t7, http://code.google.com/p/lambdacube/source/browse/#svn%2Ftrunk%2FhStunts
09:15:56 <ksf_> ...bullet is a wart in that code, though.
09:18:52 <ezyang> Behold! The wonders of lazy IO. writeList2Chan resultChan . split (keepDelimsR (whenElt p)) =<< parseXML `fmap` hGetContents fout
09:19:07 <Veinor> which does?
09:20:26 <ezyang> it reads out a stream of XML events, and feeds them into a channel delimited by elements identified by predicate p
09:20:34 <Mathnerd314> @hoogle writeList2Chan
09:20:35 <lambdabot> Control.Concurrent.Chan writeList2Chan :: Chan a -> [a] -> IO ()
09:21:47 <djahandarie> Does it also memory leak like a sieve?
09:21:57 <ezyang> Nope!
09:22:00 <djahandarie> Nice :D
09:22:14 <ezyang> That being said, you do have to be careful about bracketing
09:24:40 <djahandarie> Is there a "standard" package for configuration files these days?
09:25:04 <elliott> there's configurator
09:25:36 <djahandarie> Oh, that looks nice
09:27:30 <twomashi> @hoogle (a -> b) -> f a -> f b
09:27:30 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
09:27:30 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
09:27:30 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
09:34:25 <hpaste> “Alexander Yuriev” pasted “Dijkstra for words - opt” at http://hpaste.org/66718
09:34:30 <ezyang> Huh. I wonder if dependent types solve the multiple type classes per data structure problem
09:37:27 <killy9999> how to get the newer version of a package using cabal?
09:37:39 <ezyang> cabal install packagename
09:37:43 <ezyang> un-intuitively enough
09:37:54 <rwbarton> imo the way you "solve" that "problem" is by passing dictionary records around
09:38:17 <edwardk> eyang: that isn't a problem, its a feature
09:38:20 <killy9999> ezyang: thanks, will try that
09:38:26 <Mathnerd314> ezyang: maybe it should be 'cabal reinstall'?
09:38:43 <killy9999> should be cabal upgrade I guess...
09:38:46 <ezyang> it makes sense if you squint at it enough
09:39:07 <ezyang> edwardk: Maybe.
09:39:25 <edwardk> ezyang: write scala for a few months, then we'll check in on how you feel about it ;)
09:39:55 <edwardk> the first two weeks are awesome, then the realization sets in of what it costs you
09:40:00 <Mathnerd314> the problem is multiple type class *instances*, right?
09:40:31 <edwardk> Mathnerd314: yes, did i misparse his statement?
09:40:47 <ezyang> So, the point is this.
09:41:03 <Mathnerd314> no, just checking. maybe deriving both Functor and Monad was the problem :p
09:41:15 <ezyang> If I allow multiple instances per class, one problem is having Map Ord versus Map (Reverse Ord) and distinguishing the two.
09:41:28 <edwardk> ezyang: thats the start of the slippery slope, yes
09:41:30 <ezyang> But obviously I'm going to promote that ordering to the type level, if I'm in a dependently typed language.
09:41:59 <edwardk> in a dependently typed setting you can do a lot of stuff. in agda you can get it to fill in the hole if there is only one thing to put there
09:42:08 <edwardk> but inference in general goes to hell
09:42:18 <ezyang> yep :^)
09:42:37 <edwardk> just use the dependent types you can get from the reflection package in haskell today ;)
09:42:47 <edwardk> problem solved
09:42:53 <killy9999> what Haskell IDE do you guys use?
09:43:02 <ciaranm> killy9999: unix
09:43:18 <ezyang> vim + ghci + runghc
09:43:18 <killy9999> ciatanm: and more precisely?
09:43:22 <edwardk> ezyang: a particularly insidious example: https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs#L33
09:43:26 <killy9999> I meant IDE, not the OS
09:43:32 <elemir> XMonad
09:43:34 <trydent> Leksah is a good IDE
09:43:37 <ciaranm> killy9999: unix is an ide!
09:43:49 <killy9999> ciaranm: come on...
09:43:55 <ciaranm> killy9999: no, really
09:43:59 <elemir> ciaranm++
09:44:19 <elemir> GUI shit for designers, not for coders
09:44:21 <edwardk> ezyang: that combines the evil of both the reflection and the constraints package to make up an arbitrary instance in local scope
09:44:26 <killy9999> I take "unix" as "I don;t uses dedicated Haskel IDE"
09:44:54 <ezyang> "whoo"
09:44:56 <ciaranm> killy9999: unix is "integrated", via pipes etc, and is a "development environment" via your choice of editor and compiler
09:44:57 <edwardk> killy9999: most people don't
09:44:58 <killy9999> elemir: ok, so what refactoring features does unix provide?
09:45:05 <killy9999> do you refactor your code with sed?
09:45:16 <ciaranm> i refactor using vim and the compiler, personally
09:45:17 <edwardk> killy9999: sometimes
09:45:19 <elemir> With ex
09:45:35 <edwardk> killy9999: usually i prefer to use perl -e though ;)
09:46:00 <killy9999> ok, I know that this is a baaaad question to ask in #haskell but have you ever worked in Eclpse woth Java?
09:46:01 <ciaranm> a refactoring tool in an ide is generally a sign that its text processing and compiler integration aren't good enough
09:46:12 <edwardk> killy9999: yes
09:46:19 <ciaranm> killy9999: sure. it's got nearly as much functionality as unix had in 1980
09:46:40 <ciaranm> eclipse has "refactoring" tools because it can't do decent compiler integration or text processing yet
09:46:43 <edwardk> killy9999: its a nice experience. there is also leksah that provides that sort of thing in haskell
09:46:59 <elemir> `Refactoring' is a joke, IMHO
09:47:02 * killy9999 just upgraded to latest version of leksah
09:47:09 <killy9999> elemir: why?
09:47:15 <edwardk> killy9999: there also exists a vim plugin for haskell which can provide type checking information, etc.
09:47:20 <killy9999> I think that's a rather important practice when coding'
09:47:21 <edwardk> in practice i almost never use them
09:47:22 <elemir> Because changing names is a refactoring
09:47:41 <killy9999> edwardk: I've been experimenting with haskell mode for emacs and ghc-mod
09:47:54 <elemir> Rewriting I/O from lazy IO to Iteratee — good sample of refactoring
09:48:14 <elemir> But fucking editor cannot do it for you
09:48:21 <ciaranm> elemir: that's probably not "refactoring" in the Fowler sense
09:48:23 <killy9999> no, it can't
09:48:40 <killy9999> but it can do a whole lot of stuff that programmer shouldn't be bothered with
09:48:43 <edwardk> killy9999: ultimately it comes down to finding a productive work environment. if you are more comfortable with that functionality bundled into your IDE so be it. the unix guys tend to pull it out and use external tools that they can recycle for other non-IDE purposes. one isn't necessarily better than the other, just a different emphasis
09:48:44 <elemir> Soo, `refactoring in IDE' is a joke
09:49:23 <killy9999> just to make things clear, I use linux
09:49:25 <edwardk> the main problem i have is that most of the time i'm 'refactoring' my code wouldn't compile if i wanted it to, so i don't take small enough steps that the refactoring tools are helpful to me enough of the time to retain in my muscle memory
09:49:59 <ciaranm> edwardk: then you're not "refactoring"
09:50:07 <ciaranm> you're "making changes"
09:50:10 <edwardk> ciaranm: =)
09:50:44 <edwardk> ciaranm: fair nuff. but rarely do the refactors that i make consist solely of lifting lambdas or changing arities or something where such a tool is all that useful
09:50:47 <elemir> Also interesting task — write unix-like utilities for AST processoring
09:51:24 <ciaranm> edwardk: refactoring is software engineering. software engineers don't use lambdas.
09:51:27 <edwardk> the main thing i want in haskell that we don't have is decent hole support so i can see what i've brought into scope that i can use to make progress
09:52:32 <killy9999> new version of leksah offers a list of files in a package, now that's progres...
09:53:06 <ciaranm> unix had wildcards by 1980
09:53:09 <ciaranm> so not really
09:53:12 <gdoteof> System/Directory.hs:133:32: Not in scope: `fileSystemEncoding'     <-- i am getting this trying to do `cabal install directory`
09:53:54 <killy9999> ciaranm: that was irony\
09:54:08 <dmwit> gdoteof: Don't cabal install directory; upgrade GHC instead.
09:54:22 <trydent> @edwardk what is hole support
09:54:23 <lambdabot> Unknown command, try @list
09:54:29 <gdoteof> mmk
09:54:40 <rwbarton> we really need an @edwardk command
09:54:55 <dmwit> gdoteof: Don't cabal install any of the packages on this page:
09:54:58 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
09:55:19 <edwardk> trydent: in agda you can put placeholders in your code and then refine them to see the type of the placeholder and what things have been brought into scope that can be used to make progress on it
09:55:35 <gdoteof> dmwit: gotcha.  recommended best way to upgrade on ubuntu?  i am upto date with released packages
09:55:39 <edwardk> and there are a bunch of tools you can use to quickly fly through expanding out code in those holes
09:55:58 <dmwit> gdoteof: Just grab the latest binary from the GHC website.
09:56:07 <edwardk> so what you have is the type of the placeholder which functions as a 'goal' type, and then the type of the stuff you have in local lexical scope which provides the tools you use to reach the goal
09:56:31 <edwardk> it makes programming into more or less a game of trying to reach the goal using the parts you have on hand
09:57:50 <pcapriotti> is it possible to make ghcmod-vim work with an arbitrary cabal-dev sandbox?
09:58:15 <killy9999> dmwit: remember when a few days ago I asked about meaning of error message displayed when I did apply someFunction to -1 ?
09:59:08 <dmwit> killy9999: To be quite honest, no.
09:59:17 <dmwit> killy9999: Probably you meant to apply it to (-1), though.
09:59:23 <killy9999> yes
09:59:42 <killy9999> anyway, I was thinking about it and there is still one more thing I don't understand
09:59:46 <dmwit> Was the error sufficiently explained? If not, I can take another shot at it.
09:59:49 <dmwit> great, ask away
09:59:59 <killy9999> well, the message itself is now clear to my
10:00:06 <killy9999> but whta isn't clear is
10:00:30 <killy9999> when I type someFunction -1 why does - get higher precedence than function application (space)?
10:00:49 <killy9999> function application has the highest precedence after all
10:00:52 <rwbarton> what
10:01:07 <c_wraith> killy9999: because the lexer doesn't care about the lack of whitespace.  "-1" and "- 1" are the exact same to it
10:01:09 <dmwit> There's no precedence involved.
10:01:11 <edwardk> killy9999: space binds tighter than almost everything in haskell (almost because {}'s and @ break that rule)
10:01:22 <rwbarton> this is just like
10:01:23 <rwbarton> x - y
10:01:33 <rwbarton> there *is no* function application
10:01:41 <edwardk> killy9999: -1 isn't a single lexeme
10:02:10 <killy9999> ok
10:02:28 <dmwit> killy9999: precedence decides where parentheses go when there are multiple parenthesizations (e.g. when there are multiple infix operators).
10:02:31 <edwardk> and the only reason (-1) works is that there is a hack to make it not form a section ;)
10:02:33 <trydent> @edwardk so the IDE needs the agda-like functionality or does it just need to be built into a development environment?
10:02:33 <lambdabot> Unknown command, try @list
10:02:34 <dmwit> There is only one here, so precedence plays no role.
10:03:04 <edwardk> trydent: its a combination of typechecker support and ide support
10:03:18 <edwardk> trydent: we can sort of fake it using implicit params right now, but its awkward
10:03:19 * killy9999 checks the haskell report to see the find the definition of haskell lexemes
10:03:43 <killy9999> edwardk: right, didn't notice that this cab be a section..
10:04:02 <t7> wheres glGenTextures in OpenGL ?
10:04:19 <c_wraith> whoa.  type-level string literals?
10:04:39 <ClaudiusMaximus> t7: look up ObjectName
10:05:22 <trydent> Is there a movement to get hole support implemented?
10:05:45 <t7> ClaudiusMaximus: wtf i need another library to call this ... :S
10:06:18 <ClaudiusMaximus> t7: i think it's re-exported by OpenGL
10:07:13 <hpaste> Teo pasted “Daten Auslesen ” at http://hpaste.org/66719
10:07:15 <parcs`> trydent: you can fake holes in ghc 7.6 with -fdefer-type-errors and unbound implicit parametrs
10:07:41 <t7> ClaudiusMaximus: does the opengl package have another way to user textures?
10:08:09 <ClaudiusMaximus> t7: it's kinda confusing, especially if you're used to OpenGLRaw (whcih is very close to the C api); something like do{ textureObjectsList <- genObjectNames 42 ; {- code that uses it tells compiler it's a texture -}  }
10:09:29 <t7> ClaudiusMaximus: not i need bind texture :3
10:09:35 <t7> maybe i should just use raw
10:10:36 <ClaudiusMaximus> t7: you can mix the two, depending which is more convenient
10:11:12 <kallisti> https://github.com/kallisti-dev/hs-webdriver/blob/master/webdriver.cabal  I feel like these dependencies are probably not ideal.
10:11:35 <kallisti> they're probably too strict in many cases.
10:12:59 * kallisti will do some tweaking.
10:17:40 <mekeor> > foldl (flip (:)) [] "this is brilliant."
10:17:42 <lambdabot>   ".tnaillirb si siht"
10:23:32 <kallisti> mekeor: I think you want foldr there.
10:23:49 <kallisti> :t foldl
10:23:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:24:01 <kallisti> oh nevermind
10:24:04 <mekeor> kallisti: say, how?
10:24:06 <mekeor> heh..
10:27:39 <kallisti> hm, still no reply from Hackage.
10:27:54 * kallisti is apparently not very patient.
10:30:22 <koala_bot> I'm having trouble with a type error while attempting to flesh out some code stubs - but the weird thing is what I'm trying to do seems to work elsewhere in the code. Can anyone offer some advice?
10:30:34 <kallisti> not without more information.
10:30:59 <hpaste> koala_bot pasted “eval” at http://hpaste.org/66720
10:31:24 <rwbarton> er
10:31:45 <koala_bot> in the first case of eval, it's using x, a Prop Int, to pull a value from the assign list. I try that for the second line as well just as a test and I get an error that I cannot use Prop Int to specify a part of the list
10:31:49 <rwbarton> because in the first one x is an Int and in the second one x is not an Int
10:31:52 <koala_bot> but it's done in the previous line just fine
10:32:00 <koala_bot> hm
10:32:05 <hiptobecubic> These C9 videos are pretty great.
10:32:18 <koala_bot> oof.
10:32:26 <koala_bot> rwbarton - how can I go about using a Prop Int as if it were an Int?
10:32:34 <kallisti> edwardk: what's a good rule of thumb to figure out what my mtl dependency line should look like..
10:32:37 <rwbarton> you can't
10:32:38 <kallisti> (vague question)
10:32:40 <rwbarton> since it isn't
10:32:49 <rwbarton> it's not even remotely like an Int
10:32:55 <koala_bot> hm.
10:32:59 <edwardk> kallisti: mtl > 2.0 && < 2.2 is pretty likely to be correct these days
10:33:01 <koala_bot> Then I haven't got a clue how to do this...
10:33:05 <rwbarton> anyways you don't want to do this on line 15 at all
10:33:05 <kallisti> edwardk: that was my thought
10:33:06 <edwardk> er >= 2.0
10:33:12 <kallisti> edwardk: yes
10:33:34 <hiptobecubic> I am sure it's my inexperience, but some of these abstractions seem pretty crazy
10:33:52 <kallisti> edwardk: fun stuff. this dependency hunting.
10:34:03 <edwardk> kallisti: the thing that changed is that 2.1 added state, reader, and writer to the classes
10:34:11 <koala_bot> rwbarton: I need to take the and of the values at positions x and y in the assign array but if I cannot use x and y as Ints somehow or another than I am at a loss as to how to accomplish this.
10:34:11 <edwardk> which were added into transformers 0.3
10:34:16 <glguy> koala_bot: You have to write the function Prop Int -> Int yourself and use that
10:34:18 <rwbarton> no you don't
10:34:24 <koala_bot> no?
10:34:26 <rwbarton> no.
10:34:31 <kallisti> edwardk: er, they weren't already there?
10:34:40 --- mode: glguy set -o glguy
10:34:41 <rwbarton> what are x and y, if you are being passed AndP x y
10:34:48 <hiptobecubic> What is the purpose of defining Foldable and how does it add information that wasn't already present in the Monoid definitions?
10:34:49 <edwardk> no, just get and put for MonadState for instance
10:34:53 <koala_bot> Prop Int, rwbarton
10:34:59 <edwardk> adding state means that modify can avoid a round trip
10:35:00 <kallisti> edwardk: ohhh, lowercase. gotcha.
10:35:00 <rwbarton> right
10:35:02 <rwbarton> which is what
10:35:06 <rwbarton> what does it mean
10:35:16 <rwbarton> it's some other formula
10:35:27 <teneen> How to convert an mutable vector to a none mutable one using "unsafeFreeze"?
10:35:28 <kallisti> edwardk: what changed when going to 2.0?
10:35:39 <teneen> How can this piece of code work "unsafeNew 100 >>= return . V.toList . V.unsafeFreeze" ?
10:35:40 <rwbarton> it's not going to be a single variable
10:35:43 <rwbarton> necessarily
10:35:50 <rwbarton> so you don't want to look stuff up in assign at all
10:35:56 <edwardk> hiptobecubic: Foldable lets you take something apart, a Monoid lets you build it up. You can fold with a monoid, but there are other useful folks, foldr and foldl may admit a more efficient definiton than the one they get in terms of foldMap
10:36:02 <edwardk> er other useful folds
10:36:05 <koala_bot> But assign is where the values are...
10:36:22 <teneen> It complains that V.MVector (from Data.Vector.Unboxed) is not the same as MVector (which is from Data.Vector.Unboxed.Mutable)
10:36:25 <rwbarton> maybe it doesn't even use any variables
10:36:40 <koala_bot> rwbarton I'm sorry but I'm not following :(
10:36:43 <c_wraith> ">>= return ."  -> "<$>"
10:36:50 <edwardk> hiptobecubic: you can always make a monoid out of folding left or right, but it may not be fast
10:36:54 <c_wraith> oh.
10:36:58 <c_wraith> except you need a flip
10:36:59 <hiptobecubic> edwardk, hmm
10:36:59 <kallisti> edwardk: the only thing that changed from base 3 to base 4 is the exception handling, yes? I'll probably want 4 then, since I use that.
10:37:00 <rwbarton> okay, well i have to go anyways
10:37:01 <c_wraith> nevermind then
10:37:07 <koala_bot> thank you for trying
10:37:21 <kallisti> right now I just have base == 4.*
10:38:17 <hiptobecubic> edwardk, I don't see how foldMap would be any different than foldr (mappend . f) mempty or something
10:38:54 <edwardk> was that it? hiptobecubic foldMap and foldr are inter-definable. however, consider foldMap on a tree. it can be made more efficient
10:39:01 <hiptobecubic> edwardk, or... i guess foldr is only for List type so what I said is kind of nonsensical?
10:39:11 <edwardk> hiptobecubic: no foldr is in Foldable as well
10:39:30 <hiptobecubic> @hoogle Foldable
10:39:30 <lambdabot> Data.Foldable module Data.Foldable
10:39:31 <lambdabot> Data.Foldable class Foldable t
10:39:31 <lambdabot> Control.Seq seqFoldable :: Foldable t => Strategy a -> Strategy (t a)
10:39:54 <hiptobecubic> @src foldMap []
10:39:55 <lambdabot> Source not found.
10:40:04 <hiptobecubic> i always forget the syntax of this thing
10:40:13 <sipa> concatMap?
10:40:31 <kallisti> concatMap = concat . map
10:40:43 <kallisti> .. oh wait Foldable nevermind I'm silly.
10:41:21 * kallisti has an "automatic help noob" reflex that seems to kick in when he has absolutely no context.
10:41:27 <t7> default constraint would be cool
10:41:40 <t7> if ambiguous, then choose x
10:42:02 <kallisti> you mean a typeclass for default values, or...?
10:42:04 <kallisti> because that already exists.
10:42:34 <t7> like when calling an opengl function with literals its ambigious
10:42:41 <t7> maybe it could choose GLdouble
10:42:45 <kallisti> ah
10:42:56 <kallisti> that kind of default.
10:43:49 <hiptobecubic> t7, doesn't the compiler already do that? I almost never specify the types of my literals
10:43:51 <kallisti> edwardk: also what's the most sane way to keep track of package updates?
10:44:23 <edwardk> kallisti: not sure. i suck at tracking other people's updates
10:44:42 <kallisti> I guess the obvious solution is to just log everything hackagebot says.
10:44:46 <kallisti> and then grep it.
10:45:16 <hiptobecubic> I am pretty disappointed with package management in Haskell, I must say. And i'm kind of surprised that a group with such strong monadic tendencies wouldn't have a nicer system for keep track of state :)
10:45:24 <hiptobecubic> keeping*
10:46:07 <ksf_> cabal is not a package manager.
10:47:01 <ksf_> it is a common architecture for building applications and libraries.
10:47:06 * kallisti thinks package maintenance has been pretty painless so far, compared to what it could be.
10:47:23 <kallisti> ksf_: "build tool" is sufficient
10:47:42 <ksf_> to be precise, he're a nice rant: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
10:48:24 <hiptobecubic> I didn't mention cabal. although i'd argue it's the closest that there is
10:48:57 <hiptobecubic> But no, it's not a package manager. It's 1/3rd of a package manager.
10:51:53 <ksf_> it works perfectly fine, better than any other dependency solver out there, btw, unless you expect it to do something that requires uninstalling.
10:52:53 <ksf_> but there's a simple solution to that: nuke your ~/.cabal and ~/.ghc or use cabal-dev, in the first place.
10:56:16 <hiptobecubic> ksf_, do you strictly use cabal-dev for everything?
10:56:52 <ksf_> nope, it's not worth the bother. what I'm working on tends to have shared dependencies.
10:57:33 <ksf_> with the exception of xmonad, that is, but that's installed system-wide.
10:58:41 <hiptobecubic> ksf_, had i thought about it, i would have cabal-dev installed xmonad
11:00:05 <tsou> is there a ready function that removes an element from a list by index?
11:00:20 <ksf_> well, I've spend months with a broken xmonad install. you only need the install to recompile, after that the binary gets cached in ~/.xmonad
11:00:21 <c_wraith> tsou: \\
11:00:27 <c_wraith> err, nevermind
11:00:29 <c_wraith> that's wrong
11:00:41 <ksf_> :t break
11:00:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:00:44 <c_wraith> @hoogle Int -> [a] -> [a]
11:00:44 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:00:44 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:00:45 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:00:51 <c_wraith> :t delete
11:00:52 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
11:01:02 <tsou> c_wraith: tried these ;)
11:01:05 <c_wraith> yeah, hmm.
11:01:11 <c_wraith> indexing into lists isn't common
11:01:13 <hiptobecubic>  but if you change your config then you can't rebuild
11:01:24 <ksf_> yep, but I spend months not doing that.
11:01:25 <hiptobecubic> which i am still doing pretty often as i find new things
11:01:58 <tsou> c_wraith: thought that since (!!) exists, there would be a remove-by-index function as well
11:02:36 <c_wraith> tsou: length also exists.  In most cases, using (!!) or length is wrong :)
11:03:30 <ksf_> > let remove i xs = let (h, t) = break i xs in h ++ (drop 1 xs) in (remove 3 [1..10, remove 3 [1..2]
11:03:31 <lambdabot>   <no location info>: parse error on input `,'
11:03:37 <ksf_> > let remove i xs = let (h, t) = break i xs in h ++ (drop 1 xs) in (remove 3 [1..10], remove 3 [1..2]
11:03:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:03:40 <ksf_> > let remove i xs = let (h, t) = break i xs in h ++ (drop 1 xs) in (remove 3 [1..10], remove 3 [1..2])
11:03:42 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
11:03:42 <lambdabot>    arising from the literal `3'...
11:03:55 <ksf_> > let remove i xs = let (h, t) = splitAt i xs in h ++ (drop 1 xs) in (remove 3 [1..10], remove 3 [1..2])
11:03:57 <lambdabot>   ([1,2,3,2,3,4,5,6,7,8,9,10],[1,2,2])
11:04:08 <tsou> ksf_: i've defined one myself, i just prefer to use existing ones... if they exist
11:04:16 <ksf_> > let remove i xs = let (h, t) = splitAt i xs in h ++ (drop 1 t) in (remove 3 [1..10], remove 3 [1..2])
11:04:18 <lambdabot>   ([1,2,3,5,6,7,8,9,10],[1,2])
11:04:23 <tsou> c_wraith: what kind of "wrong" do you have in mind for (!!)?
11:04:53 <ksf_> you should generally pattern-match on lists.
11:05:17 <ksf_> if you need to remove things, filter is usually the right choice.
11:05:25 <tsou> well
11:05:43 <tsou> that's if you decide whether to remove something or not based on the element, and not on its position..
11:06:08 <tsou> anyway, i guess it's safe to assume that a remove function like that doesn't exist
11:06:12 <ksf_> yep.
11:06:15 <c_wraith> tsou: things like - « [ (xs !! i, ys !! i) | i <- [1 .. length xs] ]
11:06:30 <ksf_> lists are meant to have their first element removed, not an arbitrary one.
11:06:38 <c_wraith> tsou: If we didn't have (!!) and length, maybe people wouldn't do that as much :)
11:06:57 <tsou> wow
11:07:01 <tsou> that sure is ugly :)
11:07:22 <c_wraith> It's the natural translation of array-based code in C, though
11:07:35 <tsou> yeah, got it..
11:07:36 <c_wraith> For people who don't realize how much haskell lists aren't arrays
11:08:01 <ksf_> ...and that you can use haskell arrays like lists :)
11:08:16 <tsou> i got you, still there are cases where such a remove thing is useful
11:09:00 <c_wraith> tsou: it's true, the cases do exist.  But..  You'll have to write them yourself.  possibly using an ugly combination of break and drop. :)
11:10:09 <hiptobecubic> tsou, i tried exactly replicate the way quicksort is done in an imperative language a few weeks ago. it involved a lot of random list shuffling and it was both very hideous and slow as hell.
11:10:12 * hackagebot plugins 1.5.2.1 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.2.1 (JeremyShaw)
11:10:19 <_Mikey> Hi guys
11:10:27 <_Mikey> the state monad holds two values
11:10:52 <_Mikey> which one is the state and what is the use of the other value?
11:11:00 <hpaste> tsou pasted “remove” at http://hpaste.org/66722
11:11:10 <c_wraith> _Mikey: the state monad holds one value.  That value is a function.
11:11:17 <tsou> c_wraith: doesn't look ugly, it's just looks like something i'd find in Data.List...
11:11:23 <monochrom> "s" is the state and "a" is the other value
11:11:32 <_Mikey> ahh ok
11:11:54 <monochrom> I take a liberal interpretation of "hold", of course
11:11:55 <tsou> hiptobecubic: makes sense :)  (were you just curious on how it'd work?)
11:13:20 <hiptobecubic> tsou, was for the online Design and Analysis of Algorithms course on Coursera. Part of the problem was counting the number of comparisons required when using different rules for selecting pivot elements, which meant you had to follow the algorithm that they discussed *exactly*
11:13:41 <tgeeky> sounds difficult and interesting
11:13:50 <tsou> hiptobecubic: i see..
11:14:15 <edwardk> hiptobecubic: sounds like a job for a dsl ;)
11:14:16 <hiptobecubic> took me many hours in haskell and five minutes in python. sometimes the algorithm just calls for mutable state.
11:14:41 <hiptobecubic> not that it's the best algorithm, but again, i had to use theirs because the question was really about the algorithm and not the list
11:14:43 <bill```> too bad there's not a monad for that or anything :)
11:15:00 <hiptobecubic> bill```, indeed.
11:15:03 <hiptobecubic> :)
11:15:22 <hiptobecubic> there was a lot of "rotateR" and "rotateL" and drop/span going on
11:15:26 <bill```> though i agree that it is tempting to do quick stuff in another language (ruby, for me)
11:16:16 <hiptobecubic> I was pretty annoyed at the question actually. I wanted to do all of the problems in haskell and right away they ask a question that is specifically terrible in functional style
11:18:05 <mnieminen> is there a way to combine ord and maybe
11:18:30 <mnieminen> something like function :: Maybe Ord a -> Maybe Ord a -> Bool
11:18:33 <mnieminen> ofcourse that does not work
11:18:37 <hiptobecubic> does that make sense a question?
11:18:41 <hiptobecubic> sense as a *
11:18:46 <ksf_> Ord a => Maybe a -> Maybe a -> Bool?
11:18:46 <hiptobecubic> isn't Ord a type class?
11:18:57 <mnieminen> oh yeah!
11:19:41 <ksf_> > (>=)  <$> (Just 3) (Just 2)
11:19:42 <lambdabot>   Couldn't match expected type `t -> f a'
11:19:42 <lambdabot>         against inferred type `Data...
11:19:51 <ksf_> > (>=)  <$> (Just 3) <*> (Just 2)
11:19:52 <lambdabot>   Just True
11:20:00 <ksf_> > (>=)  <$> (Just 3) <*> (Nothing)
11:20:01 <lambdabot>   Nothing
11:20:01 <hiptobecubic> Is there a difference in the role of monads vs applicative functors? they seem equivalent, at least based on looking at them for ten minutes in this video
11:20:14 <ksf_> hiptobecubic, monads are more powerful.
11:20:24 <ksf_> to understand why, have a look at this type signature:
11:20:30 <ksf_> :t (>>=)
11:20:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:20:49 <ksf_> :t (<*>)
11:20:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:21:11 <ksf_> a monad allows you to influence the continuation of the program by a value.
11:21:21 <hiptobecubic> ksf_, that's what i was looking at when i thought of the question
11:21:36 <ksf_> monads vs. applicatives is a lot like contexty vs. context-free grammars.
11:21:39 <hiptobecubic> ksf_, you mean sequentialize the computations?
11:21:49 <ksf_> no, applicatives can do that, too.
11:21:57 <_Mikey> >runState (do{put5; return 'X'}) 1
11:22:00 <hiptobecubic> Then I don't think I understand enough to know what you mean
11:22:04 <_Mikey> >runState (do{put 5; return 'X'}) 1
11:22:14 <_Mikey> > runState (do{put 5; return 'X'}) 1
11:22:15 <lambdabot>   ('X',5)
11:22:29 <_Mikey> > runState (do{return 'X'}) 1
11:22:30 <lambdabot>   ('X',1)
11:22:40 <_Mikey> > runState (do{return 1}) 1
11:22:41 <lambdabot>   (1,1)
11:22:55 <ksf_> hiptobecubic, in an applicative, you don't have a combinator that takes an  arrow from a pure value to a thing in the functor.
11:23:01 <_Mikey> > runState (do{put 3; return 1}) 1
11:23:02 <lambdabot>   (1,3)
11:23:18 <_Mikey> > runState (do{put 5; put 3; return 1}) 1
11:23:19 <lambdabot>   (1,3)
11:23:26 <ksf_> hiptobecubic, an applicative doesn't allow you to look at the result of getLine and decide what to do based on it.
11:23:35 <ksf_> its execution path can't be influenced by runtime values.
11:23:41 <_Mikey> > runState (do{put 5; put 3; return 2}) 1
11:23:42 <lambdabot>   (2,3)
11:23:48 <_Mikey> aha!
11:24:28 <ksf_> > runState (modify (*2) >> return 2) 3
11:24:30 <lambdabot>   (2,6)
11:25:34 <Veinor> yay, new plugins
11:25:38 <hiptobecubic> ksf_, ah ok
11:25:49 <hiptobecubic> so there's no applicative answer to the IO monad
11:26:02 <hiptobecubic> you can't examine any of the results of computation?
11:26:43 <ksf_> well yes you can, but those can't influence the f part, only the a part.
11:27:40 <hiptobecubic> hmmm
11:27:47 <hiptobecubic> And in monads you can influence the M?
11:28:05 <hiptobecubic> i mean, the m
11:28:09 <nand`> > let 1=2 in 1 -- why does this even parse? shouldn't it throw in invalid name error?
11:28:10 <lambdabot>   1
11:28:11 <nand`> an*
11:28:55 <copumpkin> nand`: nope
11:29:05 <ksf_> hiptobecubic, yes you can.
11:29:05 <copumpkin> > let !1 = 2 in False
11:29:06 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
11:29:08 <ksf_> :t (>>=)
11:29:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:29:14 <ksf_> look at the second argument.
11:29:29 <copumpkin> > let (5, x) = (5, 7) in x -- nand`
11:29:30 <lambdabot>   7
11:29:40 <hiptobecubic> ksf_, ah ok. yes. the a can affect the m b
11:29:40 <copumpkin> > let (5, x) = (6, 7) in x -- nand`
11:29:41 <lambdabot>   *Exception: <interactive>:3:4-18: Irrefutable pattern failed for pattern (5...
11:29:50 <nand`> copumpkin: interesting
11:29:51 <ksf_> which reads "I allow you to give me an m on basis of the a I give you"
11:30:08 <joshuatly> hey there, got a question, instead of return (), what function i can use to stop the program completely?
11:30:09 <hiptobecubic> > let a = b; b = a in b
11:30:13 <lambdabot>   mueval-core: Time limit exceeded
11:30:25 <ksf_> joshuatly, you can't do that with return ()
11:30:32 <ksf_> @hoogle exitWith
11:30:33 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
11:30:43 <joshuatly> oh i see
11:30:47 <hiptobecubic> ksf_, yes i see. then why are applicative functors everyone's favorite toy then?
11:31:06 <ksf_> because they allow for more optimisation, in particular, introspection, than monads.
11:31:28 <ksf_> also because it's bad style to use more powerful abstractions than you need.
11:31:55 <joshuatly> Thanks :D
11:32:14 <mnieminen> is there a way to check if variable is Just
11:32:27 <ksf_> the preferred way is a) pattern matching and b)
11:32:29 <ksf_> :t maybe
11:32:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:32:37 <ksf_> there's also
11:32:39 <ksf_> :t isJust
11:32:40 <lambdabot> forall a. Maybe a -> Bool
11:33:00 <ksf_> @djinn b -> (a -> b) -> Maybe a -> b
11:33:01 <lambdabot> f a b c =
11:33:01 <lambdabot>     case c of
11:33:01 <lambdabot>     Nothing -> a
11:33:01 <lambdabot>     Just d -> b d
11:33:14 <mnieminen> variable == Nothing works, but variable == Just does not
11:33:28 <mnieminen> isJust seems good :)
11:33:29 <monochrom> right, == is the wrong way to think about it
11:33:29 <ksf_> :t Just
11:33:30 <lambdabot> forall a. a -> Maybe a
11:33:35 <ksf_> that's a function, not a value.
11:33:52 <hiptobecubic> ksf_, I thought I understood this just now, but apparently not. If <*> is defined as you showed, and in it, b clearly depends on a, how is f b not affected by a?
11:33:55 <hiptobecubic> :t <*>
11:33:56 <lambdabot> parse error on input `<*>'
11:33:59 <hiptobecubic> :t (<*>)
11:34:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:34:15 <ksf_> the b is affected by a.
11:34:20 <ksf_> but not one f by the other.
11:35:14 * hackagebot bindings-sc3 0.3.0 - Bindings to the SuperCollider synthesis engine library.  http://hackage.haskell.org/package/bindings-sc3-0.3.0 (StefanKersten)
11:35:16 * hackagebot hsc3-process 0.6.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.6.0 (StefanKersten)
11:35:25 <ksf_> try to write an <*> that tries to analyse a or b, and you'll see :)
11:36:27 <ksf_> ...you can't expect either of them as they're polymorphic. to get an f based on any of them you'd need another argument passed in... of type a -> f b or similar.
11:36:38 <Veinor> oh, plugins programs still require a ghc installation :/
11:36:47 <ksf_> at which point you have a monad.
11:36:55 <hiptobecubic> ksf_, hmm
11:37:08 <ksf_> hiptobecubic, did you already read the typeclassopedia?
11:37:14 <hiptobecubic> No.
11:37:16 <monochrom> generally, ghc-api programs require a ghc installation
11:37:29 <hiptobecubic> googleing...
11:38:27 <Veinor> monochrom: yeah. is there any way to do a plugins-type thing that odesn't?
11:38:51 <monochrom> no
11:40:14 * hackagebot hsc3-server 0.3.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.3.0 (StefanKersten)
11:40:51 <Veinor> :(
11:40:56 <Veinor> damn
11:41:43 <Veinor> does it require a full install of all the modules the plugin uses, though, or just the ghc binary?
11:44:00 <monochrom> you need the *.hi and *.o files of the libraries that happen to be used by the actual plugins. and the package database.
11:44:23 <monochrom> you don't need ghc's executable, actually
11:44:44 <c_wraith> because it statically links in the entire ghc library.
11:45:00 <c_wraith> but yeah, you need the interface and object files for libraries that plugins will use.
11:46:57 <monochrom> think of your executable as already containing ghc's executable
11:48:55 <thoughtpolice> edwardk: just got back from lunch and checked IRC, but yes! https://gist.github.com/2345391 :D
11:48:56 <Veinor> monochrom: i tried using it on a ghc-less system
11:49:03 <hpaste> ClaudiusMaximus pasted “merging rank2 callback streams” at http://hpaste.org/66723
11:49:04 <Veinor> didn't work
11:49:15 <Veinor> tester: libraries/Cabal/Cabal/Distribution/Simple/GHC.hs:519:5-51: Irrefutable pattern failed for pattern Data.Maybe.Just ghcProg
11:49:20 <edwardk> thoughtpolice: =)
11:49:22 <ClaudiusMaximus> any wizards care to take a look at my confusion and solve it?
11:49:32 <edwardk> great, more fuel for the interminable record debate
11:49:51 <monochrom> you must not pass in Nothing
11:50:00 <Veinor> i'm not passing in Nothing anywhere
11:50:27 <monochrom> oh, cabal? you call up cabal?
11:50:46 <Veinor> no
11:50:55 <Veinor> val <- (load "P1.o" [] [] "value") :: IO (LoadStatus String)
11:50:56 <thoughtpolice> edwardk: the ghci prompt is awfully confusing though, because SingI et al are elaborated weird. ghci says that SingI is defined as 'class SingI k0 a where sing :: Sing k0 a'
11:51:13 <thoughtpolice> edwardk: but ghci's :k command says SingI has kind * -> Constraing
11:51:18 <edwardk> thoughtpolice: that happens with anything polykinded
11:51:23 <edwardk> you see the kinds in the types
11:51:32 <thoughtpolice> which confused me for a little bit
11:51:36 <edwardk> it doesn't hide them to match up with what you'd expect
11:51:45 <thoughtpolice> ah
11:51:51 <monochrom> then who is calling up "libraries/Cabal/Cabal/Distribution/Simple/GHC.hs" ?
11:52:16 <Veinor> i assume plugins itself
11:53:33 <mrBG> is jude in jude law pronounced "judd" or "juuud"?
11:53:41 <Clint> the latter
11:53:57 <monochrom> well then, I was talking about pure ghc-api
11:54:27 <monochrom> "yu das"
11:55:14 * hackagebot hsc3-server 0.3.1 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.3.1 (StefanKersten)
12:04:05 <mekeor> is hoogle open-source/free ?  where's its code?
12:04:28 <hpaste> y pasted “simple example” at http://hpaste.org/66724
12:04:35 <mekeor> ah: http://code.haskell.org/hoogle/
12:04:52 * Clint nods.
12:04:57 <yan_> can someone provide insight into why this seemingly simple function isn't behaving as i'd expect: http://hpaste.org/66724
12:05:48 <Clint> what do you expect?
12:06:31 <akosch> will filterM from Control.Monad overflow the stack when called on a large input list? It doesn't look tail-recursive to me...
12:06:40 <yan_> Clint: for it to find the mean of the list.. the error i'm receiving is not being able to deduce (a ~ Int)
12:06:49 <yan_> from listLen
12:07:12 <Saizan> yan_: what's the type of myLength' ?
12:07:43 <yan_> Saizan: [a] -> Int
12:07:47 <Saizan> ok
12:08:10 <Saizan> that explaines the error, because listSum is going to be of type [a]
12:08:19 <hpaste> y annotated “simple example” with “simple example (annotation)” at http://hpaste.org/66724#a66725
12:08:35 <yan_> i updated the post with myLength'
12:08:35 <Saizan> for the fixed 'a' which is the type of the elements of you input list
12:09:00 <Saizan> and your use of on forces listSum and listLen to have the same type
12:09:01 <shachaf> yan_: It's a polymorphism thing -- it would probably work with a rank-2 "on".
12:09:15 <shachaf> yan_: (Hi!)
12:09:24 <yan_> shachaf: hey shachaf :)
12:09:49 <yan_> (decided to dust off the haskell notes :P)
12:10:01 <shachaf> > ((\i -> (i "hi", i 3)) :: forall a. (a -> a) -> (String,Int)) id
12:10:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:10:02 <lambdabot>         against inferred type ...
12:10:03 <shachaf> > ((\i -> (i "hi", i 3)) :: (forall a. a -> a) -> (String,Int)) id
12:10:04 <lambdabot>   ("hi",3)
12:11:05 <mekeor> omg. there's filterM but not partitionM.
12:11:51 <monochrom> partitionM may do undesirable things. try implementing it and see
12:11:58 <mekeor> monochrom: oO
12:12:02 <mekeor> O_
12:12:03 <mekeor> O
12:12:17 <shachaf> yan_: The simplpest thing to do here is probably just to type fromIntegral twice.
12:12:19 <monochrom> ok, maybe not
12:12:57 <mekeor> monochrom: :)
12:15:15 * hackagebot hjsmin 0.0.16 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.16 (AlanZimmerman)
12:15:32 <mekeor> bummer. there's no concatMapM
12:17:00 <rribeiro> Hello all! I have a very basic question on I/O
12:17:18 <rribeiro> how can I print a message before reading a value from the keyboard?
12:17:33 <rribeiro> Because it is reversing the order of these two actions
12:17:48 <Saizan> hFlush studout
12:17:53 <Saizan> after the printing
12:17:55 <Veinor> main = do
12:18:01 <Veinor>   putStrLn "hello there!"
12:18:07 <Veinor>   val <- getLine
12:18:10 <Veinor>   putStrLn val
12:18:20 <t7> can I put loads of data in an IO ref without make reads slow?
12:18:29 <t7> r an mvar
12:19:25 <Saizan> t7: IORef/MVar only hold a pointer to the data
12:19:33 <osa1> why `many $ (char '\\' >> oneOf "nrt\\") <|> anyChar` doesn't match "\\n" ?
12:19:48 <t7> Saizan: so i can have a huge mutable array in one and its fine?
12:20:05 <mekeor> isn't it annoying that most (high-order?) functions needs an monadic and a non-monadic version?  i think therefore "effects" exist, right, because that's really annoying, man..
12:20:52 <Saizan> t7: yeah, it just adds another layer of indirection
12:21:10 <elemir> mekeor: For example?
12:21:18 <rribeiro> Saizan: Thank you!
12:21:27 <elemir> mapM, map and so on?
12:21:30 <mekeor> elemir: partitionM, unlessM, whenM
12:21:39 <mekeor> ^ these don't exist.
12:21:55 <elemir> :t liftM
12:21:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:21:59 <mekeor> these exist: foldM, mapM, mapM_, foldM_, filterM,... zipWithM, zipWithM_...
12:22:13 <elemir> :t liftM when
12:22:14 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
12:22:31 <elemir> Hem
12:22:53 <elemir> What do you expect of whenM?
12:23:07 <elemir> m Bool -> m () -> m ()?
12:23:14 <mekeor> yep
12:23:17 <mekeor> er, no
12:23:27 <mekeor> m Bool -> m () -> m () -> m ()
12:23:35 <mekeor> :t when
12:23:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:23:39 <elemir> o_O
12:23:45 <mekeor> er...
12:23:46 <elemir> Whhhat?
12:23:50 <mekeor> no, stop
12:23:55 <mekeor> you were right, sorry =)
12:23:59 <elemir> ok :)
12:24:30 <Veinor> osa1: it matches for me
12:24:31 <elemir> :t f >>= (\t -> when t)
12:24:32 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
12:24:32 <lambdabot>       arising from a use of `f' at <interactive>:1:0
12:24:32 <lambdabot>     Possible fix:
12:24:42 <elemir> Ou
12:24:53 <_Mikey> can I write an if statement
12:24:59 <elemir> :t (\x -> f >>= (\t -> when t x))
12:25:00 <lambdabot> forall (m :: * -> *). (SimpleReflect.FromExpr (m Bool), Monad m) => m () -> m ()
12:25:06 <_Mikey> which which is true for a particular type
12:25:09 <_Mikey> like
12:25:15 <elemir> :t (>>=)
12:25:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:25:18 <_Mikey> if (a isAn Int
12:25:21 <_Mikey> )
12:25:21 <elemir> Hem
12:25:51 <elemir> :t \x -> (\t -> when t x)
12:25:51 <Saizan> _Mikey: only with Typeable
12:25:52 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
12:26:33 <_Mikey> so I'd have to make it an instance of typeable -.-
12:26:34 <elemir> _Mikey: What do you really want?
12:26:47 <_Mikey> I have an Either
12:27:00 <_Mikey> and I want to run the function again if its Right
12:27:06 <_Mikey> if its Left stop
12:27:08 <hiptobecubic> it would be nice to see some statistics on how lambdabot is used here
12:27:19 <elemir> What means stop?
12:27:30 <_Mikey> print the String that I store in Left
12:27:36 <elemir> Have you a monadic code?
12:27:36 <Saizan> _Mikey: you don't need to compare types then
12:27:59 <elemir> So you can return `(m ())' from if
12:28:26 <_Mikey> Its not monadic at the moment
12:28:29 <Saizan> _Mikey: you can pattern match on the Left and Right constructors
12:28:34 <_Mikey> I'm just patternmatching
12:28:41 <_Mikey> ok
12:28:49 <elemir> What means a stop when?
12:29:03 * elemir can't understand stopping of pure code
12:29:11 <_Mikey> Ahhhhhhh I could put the functionality I want into the pattenmatch
12:29:47 <mekeor> _Mikey: heh. i already talked about that today on #haskell. unfortunately that's not possible. there are no i-call-them-"high-typed-function" in haskell. function can only get values, not types.
12:30:12 <Cale> mekeor: hm?
12:30:15 * hackagebot snaplet-mongodb-minimalistic 0.0.6.2 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.2 (PetrPilar)
12:30:22 <mekeor> Cale: am i wrong?
12:30:37 <elemir> kind get types :)
12:30:38 <Cale> Perhaps you're looking for type families?
12:30:56 <mekeor> Cale: perhaps, yes.
12:31:11 <_Mikey> hmmm
12:31:36 <mekeor> anyway. join #idris for haskell with FULL dependent types. (unlike #agda, it's a general-purpose programming language.)
12:32:04 <mekeor> (but yet in heavy development.)
12:32:34 <elemir> Dependent types are not computable at all
12:32:40 <Cale> Eager evaluation :(
12:32:46 <copumpkin> elemir: huh
12:33:08 <mekeor> Cale: you can make it lazy explicitly.
12:33:24 <mekeor> but, yea, that's bummer anyways.
12:33:43 <Cale> Laziness only works if most things are lazy, which only tends to happen if things are lazy by default.
12:35:19 * hackagebot snaplet-mongodb-minimalistic 0.0.6.3 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.3 (PetrPilar)
12:35:35 <mekeor> Cale: join #idris and discuss. you can still hardly influence idris.
12:41:37 <hpaste> ClaudiusMaximus annotated “merging rank2 callback streams” with “merging rank2 callback streams (solved!)” at http://hpaste.org/66723#a66728
12:43:52 <tkahn6> does anyone else here think the record update syntax is really weak? it's annoying that it's not first class
12:44:09 <ksf_> about everyone.
12:44:11 <osa1> do we have a standard function for \x -> [x] ?
12:44:20 <tkahn6> ok i'm glad i'm not crazy :)
12:44:27 <edwardk> tkahn6: yes, but its funny how hard it is to improve it
12:44:29 <ksf_> tkahn6, have a look at fclabels etc.
12:44:44 <monochrom> return can act as \x -> [x]
12:44:55 <yan_> osa1: (:[]) ?
12:45:00 <tkahn6> ksf_: will do
12:45:02 <Cale> Robot monkey
12:45:07 <monochrom> there is also pure, iirc
12:45:18 <monochrom> > pure True :: [Bool]
12:45:18 <lambdabot>   [True]
12:45:19 <ClaudiusMaximus> :t (:{-robot-}[{-monkey-}])
12:45:20 <lambdabot> forall a. a -> [a]
12:45:21 <monochrom> yeah
12:45:37 <sthiruva> Haskell newbie here, I have a basic question. I am wondering if this is the right place to ask couple of questions..
12:45:47 <osa1> yan_: thanks
12:45:54 <yan_> osa1: np
12:46:59 <sthiruva> I am able to get this to compile: type Tp = (Int, Int)
12:47:25 <sthiruva> data ListItem = Int | Tp
12:47:41 <sthiruva> where as something like data ListItem = Int | (Int, Int)
12:47:46 <sthiruva> does not compile.
12:47:54 <tkahn6> sthiruva: you need a value constructor
12:48:02 <tkahn6> before each of those types
12:48:37 <ksf_> and now we all see that capitalising both constructors and types was a bad idea.
12:48:37 <tkahn6> sthiruva: as in data ListItem = ListItemInt Int | ListItemTuple Tp
12:48:49 <sthiruva> so defining "Tp" makes it a value constructor?
12:49:03 <tkahn6> but generally if you find yourself doing this you should rethink your solution
12:49:04 <ksf_> about as good an idea as calling return return.
12:51:38 <sthiruva> tkahn6: ListItem = ListItemInt Int | ListItemTuple Tp makes sense, but why would   ListItem =  Int |  Tp  work? Am I missing something fundamental?
12:52:10 <sthiruva> what does  ListItem =  Int |  Tp  actually mean?
12:52:27 <tkahn6> sthiruva: well in haskell it means nothing because it won't compile
12:52:59 <tkahn6> actually it will
12:53:23 <tkahn6> but those types become value constructors
12:53:25 <tkahn6> 'types'
12:53:40 <tkahn6> like data Color = Red | Green | Blue
12:54:16 <tkahn6> you're saying that Red, Green, and Blue are values of type Color
12:54:24 <sthiruva> ok
12:54:39 <osa1> is there a readBin function like readOct and readHex ?
12:54:48 <tkahn6> in ListItem = Int | Tp, you're saying Int itself is a value
12:55:03 <sthiruva> ok.. that makes sense
12:55:41 <tkahn6> so think about the problem you're solving, you want to be able to have a list of tupels and integers
12:55:52 <sthiruva> yes
12:55:56 <tkahn6> so what does a single integer represent in this case?
12:56:02 <ksf_> [Either Int (Int,Int)]
12:56:14 <sthiruva> yes..
12:56:27 <sthiruva> it is either an Int or a tuple of ints
12:56:34 <sthiruva> like ksf_ says
12:56:46 <ksf_> type MyList = [Either Int (Int,Int)]
12:57:03 <ksf_> @hoogle Either
12:57:04 <lambdabot> Prelude data Either a b
12:57:04 <lambdabot> Data.Either data Either a b
12:57:04 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:57:18 <sthiruva> ok..
12:58:37 <tkahn6> i've never really used Either for anything but error conditions
12:58:51 <tkahn6> and tbh i haven't seen it used in any other context
12:59:36 <ksf_> oh, it's useful in cases where... well, you can use it and it doesn't make sense to go for a data type.
12:59:56 <ksf_> like, using it inside a function only and using things like partitionEither
13:00:37 <ksf_> like in "partitionEithers . map classifyIntoEither $ xs"
13:01:14 <ksf_> ...more efficient than using two filters.
13:01:27 <ksf_> and guaranteed not to drop elements by bug.
13:01:51 <tkahn6> ah interesting
13:08:11 <hiptobecubic> ksf_, is that better than just folding over xs and building up from ([], [])?
13:09:42 <hiptobecubic> let f = .... in foldr (\a (l, r) -> if f a then (a:l, r) else (l, a:r)) ([], []) or something?
13:10:20 <hiptobecubic> i guess the partition does that... but without Either
13:10:49 <gspr> Can one assume that CInt is always the same as Int?
13:10:49 <sthiruva> thank you ksf_ and tkahn6. bye for now.
13:11:01 <tkahn6> sthiruva: good luck
13:14:56 <edwardk> is there a way to use CPP to find out the version of a package dependency when being built by cabal?
13:16:41 <ksf_> hiptobecubic, the Either should fold away.
13:17:00 <ksf_> if in doubt, consult core and use stream-fusion.
13:17:31 <hiptobecubic> but what's the point of using the either at all if you just throw it away immediately?
13:17:37 <hiptobecubic> you could just partition?
13:17:52 <ksf_> @hoogle partition
13:17:52 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
13:17:53 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
13:17:53 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
13:17:57 <ksf_> oh.
13:18:10 <ksf_> well, I said "things like" :)
13:18:51 <gdoteof> dmwit: please excuse my ignorance,i do i just cd into the dir and cabal install?
13:19:03 <hiptobecubic> ksf_, I wasn't correcting you. I am usually missing some key insight about suggestions made in here and I wanted to poke around and see if that were the case here as well.
13:20:27 <ksf_> well, I'm usually bold and let the channel correct me.
13:20:58 <gdoteof> dmwit: nm.  i am seeing the instlal instructions and getting an error when i do ./configure
13:21:31 <ksf_> you only have to say "a monad is an endomorphism in a category of zygohistomorphic prepromorphisms" and people will jump at you :)
13:21:51 <gdoteof> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot ope
13:22:12 <gdoteof> (no such file or directory)  -- suggestions?
13:22:25 <ksf_> install libgmp?
13:23:11 <gdoteof> ksf_: simple and elegant solution
13:23:36 <gdoteof> i tried my normal sudo apt-get install libgmp<tab> nothing there.  i am looking
13:24:36 <gdoteof> wow.  nm again
13:24:45 <gdoteof> its already installed apparently
13:26:11 <rwbarton> > maxBound :: CInt
13:26:12 <lambdabot>   Not in scope: type constructor or class `CInt'
13:26:29 <rwbarton> > maxBound :: Foreign.C.Types.CInt
13:26:30 <lambdabot>   Not in scope: type constructor or class `Foreign.C.Types.CInt'
13:26:50 <gdoteof> i add libgmp3-dev
13:26:51 <rwbarton> gspr: on 64-bit linux they are different
13:27:13 <rwbarton> (in case you didn't get your question answered already)
13:27:20 <rwbarton> CInt is C's "int" which is 32 bits
13:29:11 <gdoteof> libgmp3c2 apparently was the package i needed
13:32:29 <Phlogistique> any project out there using _both_ HUnit and QuickCheck?
13:32:49 <gnoi> Question about Text.Regex.TDFA. How can I use `defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt' in calling (=~) function?
13:32:49 <hiptobecubic> probably
13:32:51 <Phlogistique> I'm writing a program for which I find it hard to write properties for some functions
13:33:41 <jeff_s_> I thought strings could be used in pattern matching? I'm getting an overlapping pattern match warning for ">" and "<".
13:33:43 <jeff_s_> Is that normal?
13:33:50 <jeff_s_> I'm using GHC 7.0.4.
13:35:22 <Phlogistique> http://batterseapower.github.com/test-framework/ uh, this looks cool
13:35:35 <gspr> rwbarton: Weird.. ghc -Wall complains about uneccessary fromIntegral's when I say (fromIntegral 5) :: CInt
13:35:48 <nexion> hey guys, I'd like to be able to detect failures in the Get monad (Data.Binary.Get) which defines 'fail' as 'error' -- what can I do to gently catch such errors, possibly by using Maybe?
13:35:51 <glguy> try (5 :: CInt)
13:36:22 <rwbarton> 5 already means fromIntegral 5
13:36:29 <rwbarton> er
13:36:30 <rwbarton> fromInteger 5
13:36:33 <gspr> Ah, I didn't know it could interpret literals as CInt's
13:36:41 <glguy> nexion: you can use a different library, cereal (the library) is just like Data.Binary but has the exception behavior you are asking for
13:36:44 <rwbarton> same way it works with Doubles, etc., anything that has a Num instance
13:36:45 <gspr> I thought they ended up as Int or something, and then I thought I had to convert
13:36:46 <Phlogistique> > let { f ">" = 0; f "<" = 1; f _ = 2 } in f "<"
13:36:47 <lambdabot>   1
13:36:51 <Phlogistique> jeff_s_: see above
13:36:57 <gspr> ah, right, I actually knew that :p
13:37:00 <Phlogistique> can you give an example?
13:37:00 <gspr> thanks
13:37:14 <rwbarton> np
13:37:34 <jeff_s_> Phlogistique - that's what I thought, but I'm getting an overlapping instance warning.
13:37:54 <Phlogistique> http://batterseapower.github.com/test-framework/ this looks cool, is it used by anyone?
13:37:55 <nexion> ah I see.. is it the one I should be using instead of Data.Binary for just about everything?
13:40:04 --- mode: ChanServ set +o glguy
13:43:58 <ClaudiusMaximus> is there an easy way to get ghci's :browse pretty printer to use the full width of the terminal instead of squashing it all on the left hand side?
13:45:04 --- mode: glguy set +b Radium!~carbon@117.203.11.193
13:45:27 <waxjar> how do i close a ghci session?
13:45:53 <zenzike> waxjar: type :q
13:46:00 <waxjar> thank you :)
13:46:12 <zenzike> np :-)
13:47:04 <zenzike> waxjar: also handy is :r which reloads a file, this saves you from quit and relaunch
13:47:21 <waxjar> ah, that'll be useful :)
13:47:26 <luite> dcoutts: is there anything holding back an upload of a cabal-install that works with ghc 7.4 to hackage?
13:49:54 <gnoi> Question about Text.Regex.TDFA. How can I use `defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt' in calling (=~) function?
13:50:21 * hackagebot semigroupoids 1.3.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.1 (EdwardKmett)
13:54:34 --- mode: ChanServ set +o monochrom
13:54:58 --- mode: monochrom set -b *!*@unaffiliated/morpheus/x-0931003
13:55:04 --- mode: monochrom set -o monochrom
13:58:20 <luite> I have a program that runs fine when compiled to an executable, but when I run a very simple runhaskell script that does exactly the same, I get a segmentation fault in a few seconds.
13:58:33 <luite> the script is run with the right package id's explicitly enabled (with hash)
13:58:46 <luite> any idea how to go about debugging this? crash reports don't seem to give much information
13:59:24 --- mode: glguy set -b Radium!~carbon@117.203.11.193
13:59:33 --- mode: glguy set +b Radium!*@*
14:00:03 <hpc> luite: when ive had that behavior, it's always been due to a wonky FFI binding
14:00:22 * hackagebot comonad-transformers 2.1.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.1.1 (EdwardKmett)
14:00:43 <luite> hpc: I can't anything useful out of the crash reports so far, and I have no idea where to look
14:01:11 <luite> hpc: any ideas? gdb on the core file doesn't give me much either, with backtrace
14:01:35 <hpc> no idea
14:01:48 <hpc> just throwing the idea out to see if it stuck
14:02:12 <Phlogistique> what's the most common idiom/lib for random-access ordered collections starting at 0?
14:02:54 <Phlogistique> or is it advised to always write code for arrays with arbitrary bounds like provided by the standard lib?
14:05:15 <luite> Phlogistique: if you don't have a known bound, IntMap might be the way
14:05:22 * hackagebot data-lens 2.0.4 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.4 (EdwardKmett)
14:05:24 * hackagebot distributive 0.2.2 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.2.2 (EdwardKmett)
14:06:06 <luite> Phlogistique: you can get ranges of keys with split
14:06:51 <Phlogistique> luite: wait - I'm not looking for something _more_ powerful, I'm looking for something _less_ powerful
14:07:12 <Phlogistique> arrays indexed by Ints starting with 0
14:08:42 <luite> Phlogistique: hm, I'm not sure what you want then. You want to make your code more generic or something?
14:10:41 <Phlogistique> no, I want to make my code less generic
14:10:41 <luite> Phlogistique: vector has arrays indexed by Int, starting at 0
14:11:31 <luite> and I guess that's pretty much the standard package for that kidn of things :)
14:11:36 <Phlogistique> or rather, I don't even want to make my code generic; I want to make my code simple, and I can afford to convert to a specific datatype before using my data
14:11:47 <edwardk> @tell roconnor i had to push another 2.0.x lens version to allow snap to build with the platform. you may want to merge the change set
14:11:47 <lambdabot> Consider it noted.
14:11:49 <luite> right, vector it is then, probably :)
14:12:00 --- mode: glguy set -b Radium!*@*
14:12:42 <Phlogistique> luite: will look into that, thanks
14:13:45 <luite> Phlogistique: it does come with the same limitations as regular arrays, updating is expensive since you potentially need to copy the whole array (or use a mutable variant that lives in ST)
14:15:49 <Phlogistique> also, I'm curious: what kind of things are sthe Prelude's Arrays useful for?
14:16:55 <luite> they're more flexible being indexed by Ix instead of Int
14:17:18 <luite> so simple 2D arrays indexed by tuples for example
14:17:23 <Phlogistique> oh
14:17:29 <Phlogistique> indeed
14:18:00 <luite> for more serious 2D-specific arrays you might look into repa, or perhaps hmatrix if you're doing linear algebra things
14:19:22 * mightybyte thinks edwardk should become an atheist
14:19:37 * edwardk is going to snap.
14:20:23 * hackagebot comonad-extras 2.1.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.1.1 (EdwardKmett)
14:20:27 <Cale> what was that about?
14:20:51 <edwardk> cale: the bot in #snapframework repeats comments from here containing 'heist' or 'snap'
14:21:05 <Cale> haha
14:21:47 <LambdaDusk> snappy atheists
14:22:34 <luite> snap heist snap heist snap heist snap heist
14:22:47 <edwardk> If I snapped during a bank heist, do you think any atheists would notice?
14:23:15 <LambdaDusk> I could be even meaner
14:23:35 <glguy> inadvisable
14:23:41 --- mode: glguy set -o glguy
14:24:10 <edwardk> glguy++
14:24:26 <snappy-atheist> This would be mean.
14:25:09 <thetallguy> quasi haskell question: I was downloading papers this weekend and a bunch were named 10.1.1.xx.xxxx.pdf.  Anyone know what the type is?
14:25:20 <edwardk> snappy-atheist: what do you mean?
14:25:33 <hpc> Cale: i emailed you some lambdabot changes
14:26:04 <hpc> fixing a couple of issues with newer djinn versions and some compile errors
14:26:08 <hpc> @djinn-ver
14:26:08 <lambdabot> ersion 2009-09-04.
14:26:14 <hpc> "ersion" -- lol
14:27:17 <flowenol> ok, maybe you heard this tons of times, im having some problems with compiling a file that contains an import ParseLib
14:27:35 <flowenol> the message being Failed to load interface for `ParseLib':
14:28:21 <thetallguy> flowenol: is your cwd the same directory?
14:28:40 <flowenol> thetallguy can you explain
14:28:58 <thetallguy> flowenol: i'm trying to remember the details of this "bug"
14:29:16 <flowenol> the old mod-x question :P
14:29:33 <flowenol> the problem is i have no file for parselib
14:29:43 <flowenol> i believe its supposed to be bundled
14:29:53 <thetallguy> flowenol: I think it's this: if a library is installed (visible with ghc-pkg list), and your cwd includes a file of the same name, ghc gets confused
14:30:04 <thetallguy> flowenol: something like that
14:30:24 * hackagebot MonadCatchIO-transformers 0.3.0.0 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.0.0 (AriePeterson)
14:30:24 <flowenol> maybe the problem is i dont have it installed
14:30:26 <flowenol> heh sec
14:30:40 <thetallguy> flowenol: another possibility is you have a stale ghci session
14:30:48 <flowenol> not installed -_-
14:30:58 <flowenol> heh im a total haskell noob
14:31:21 <flowenol> stupid question is there a repository?
14:31:34 <thetallguy> ghc-pkg list and ghc-pkg describe can help in these instances
14:32:04 <thetallguy> flowenol: by repository perhaps you mean hackage/cabal?
14:32:14 <flowenol> maybe
14:33:04 <flowenol> i mean somewhere where libs are gathered for download, if there is such thing for haskell
14:33:19 <hpc> @where hackage
14:33:19 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
14:33:22 <hpc> @where platform
14:33:23 <lambdabot> http://hackage.haskell.org/platform/
14:33:41 <hpc> either of those could be interpreted as "repository"
14:34:06 <thetallguy> flowenol: what OS?
14:34:10 <flowenol> gentoo
14:34:15 <hpc> hackage is more like apt repos, and platform is more like "the huge mess of stuff you get by default with a good linux distro"
14:34:15 <flowenol> already reading on it
14:34:40 <thetallguy> flowenol: there should be some gentoo packages as well, Ithink
14:34:49 <flowenol> yep
14:34:53 <flowenol> there is some info on it
14:35:26 * hackagebot semigroupoids 1.3.1.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3.1.1 (EdwardKmett)
14:35:28 * hackagebot pipes-core 0.1.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-core-0.1.0 (PaoloCapriotti)
14:35:30 * hackagebot pipes-extra 0.1.0 - Various basic utilities for Pipes.  http://hackage.haskell.org/package/pipes-extra-0.1.0 (PaoloCapriotti)
14:35:32 * hackagebot pipes-attoparsec 0.0.2 - Utilities to convert a parser into a pipe.  http://hackage.haskell.org/package/pipes-attoparsec-0.0.2 (PaoloCapriotti)
14:35:34 * hackagebot pipes-network 0.0.2 - Utilities to deal with sockets.  http://hackage.haskell.org/package/pipes-network-0.0.2 (PaoloCapriotti)
14:35:52 <flowenol> ah now there is my problem, i only emerged ghc
14:36:12 <qnikst> hello, how getCurrentTime should work
14:36:37 <qnikst> e.g. I have UTC clocktime in bios and UTC+4 in /etc/conf.d/hwclock
14:36:37 <thetallguy> flowenol: the haskell platform is a good place to start
14:36:46 <flowenol> but what i exactly want is to understand a haskell source file, and write it in a language I understand better
14:37:16 <qnikst> getCurrent time shows bios one, is it right?
14:38:42 <glguy> qnikst: getCurrentTime gets the current system time in UTC. If you want the current system time in your local time zone, try getZonedTime
14:40:58 <qnikst> glguy: I'm just trying to understand how it works
14:41:17 <fUD> Yo.
14:42:07 <ikeg> flowenol: I wonder this may help you, but, FYI, http://www.haskell.org/haskellwiki/Gentoo/HaskellPlatform
14:42:09 <crntaylor> Hi all
14:42:29 <flowenol> ikeg yep its what I am reading atm, thanks
14:42:42 <crntaylor> I'm working through some exercises in Structure and Interpretation of Computer Programs and completing the exercises in haskell
14:42:55 <crntaylor> I seem to be getting stuck repeatedly on the chapter about state
14:43:02 <crntaylor> wondered if anyone fancies answering a couple of questions
14:43:23 <glguy> qnikst: Those function get their time from ctime(3), a C standard library function
14:43:50 <glguy> crntaylor: IRC works best if you just ask your questions and hope someone wants to answer
14:44:08 <ikeg> flowenol: wish it helps you. please continue the discussion if your problem isn't solved.
14:44:12 <crntaylor> @glguy fair play!
14:44:12 <lambdabot> Unknown command, try @list
14:44:21 <flowenol> ikeg thanks :)
14:44:36 <flowenol> goot to see the comunity is more helpful than a few years ago
14:44:36 <crntaylor> I'm working through section 3.3 of SICP, found here: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.4
14:45:00 <glguy> crntaylor: also, don't use '@' when you are addressing someone, or you'll upset lambdabot :)
14:45:00 <crntaylor> the section on writing a digital circuit simulator
14:45:04 <flowenol> by any chance anyone has seen this before http://paste.pocoo.org/show/578685/
14:45:08 <crntaylor> I've written this code: https://gist.github.com/2346720
14:45:10 <flowenol> and no I dont want the solution
14:45:16 <crntaylor> glguy hah ok thanks
14:45:35 <ikeg> flowenol: "The #haskell channel is a very friendly, welcoming place to hang out, teach and learn."
14:46:16 <flowenol> ikeg unfortunately it wasn't a few years ago :( at least that was my experience
14:46:23 <flowenol> around 6/7 years heh
14:46:24 <crntaylor> I can't figure out how to write the procedures that should be fed in with AddAction
14:46:51 <crntaylor> I'm not even sure what their type signature should be
14:47:40 <keep_learning> Hello all
14:48:01 <keep_learning> I am trying to make IntMap ( IntMap Double ) as instance of NFData
14:48:05 <keep_learning> instance NFData ( IM.IntMap ( IM.IntMap Double ) )
14:48:09 <flowenol> btw any quick tutorial for someone with backgrounds in lisp java and other languages like that
14:48:13 <keep_learning> is this correct  ?
14:48:23 <crntaylor> My attempts are under the section headed '--Compound procedures', but they don't typecheck
14:48:35 <flowenol> like if there is any sort of correspondence between java/lisp/etc and haskell syntax
14:49:51 <Cale> hpc: why me?
14:50:04 <glguy> keep_learning: given that instance NFData a => NFData (IntMap a) -- Defined in `Data.IntMap', I would have expected that you wouldn't need a new instance
14:50:19 <Cale> hpc: Well, I guess it'll be important when I update djinn :)
14:50:44 <keep_learning> glguy, Thank you
14:51:11 <mekeor> guys, here's a little riddle: what is `function' in `filterM (function not doesFileExist) contents' ?
14:51:29 <mekeor> keep_learning, keep learning haskell!
14:52:00 <keep_learning> mekeor, Yes  I am still learning Haskell :)
14:52:19 <hpc> Cale: you were the maintainer on the lambdabot hackage page
14:52:25 <mekeor> f***. i should have mentioned that contents :: [FilePath].
14:55:00 <mekeor> @hoogle Monad m => (a -> a) -> (b -> m a) -> b -> m a
14:55:00 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
14:55:01 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
14:55:01 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
14:56:15 <Cale> hpc: yeah, whoever uploaded that lied
14:56:30 <Cale> (or, well, was mistaken)
14:56:49 <mekeor> what is `function' such that 'filterM (function not doesFileExist) listOfFilePaths' works?
14:57:04 <Cale> fmap
14:57:08 <tkahn6> flowenol: you should look at LYAH
14:57:11 <tkahn6> @google LYAH
14:57:14 <lambdabot> http://learnyouahaskell.com/
14:57:14 <lambdabot> Title: Learn You a Haskell for Great Good!
14:57:34 <mekeor> Cale: nope. doesn't work.
14:58:07 <glguy> needs a compose
14:58:09 <Cale> oh (fmap .)
14:58:09 <flowenol> tkahn6 will look into it
14:58:15 <Cale> er
14:58:28 <Cale> yeah, fmap not . doesFileExist
14:58:29 <flowenol> can someone explain me what does the many do here?          do s <- many (do char 's')
14:58:34 <mekeor> ah
14:58:45 <mekeor> glguy: you're great.
14:58:53 <tkahn6> flowenol: its a kleene star
14:58:53 <Cale> flowenol: the second do is unnecessary
14:58:54 <mekeor> Cale isn't as much great as you.
14:58:56 <tkahn6> like form a regular expression
14:59:04 <Cale> mekeor: ?
14:59:05 <mekeor> glguy++
14:59:05 <tkahn6> from*
14:59:12 <mekeor> Cale: :Þ
14:59:14 <glguy> Cale++
14:59:19 * mekeor wanted to troll a bit...
14:59:21 * glguy transitively applies the karma
14:59:39 <mekeor> glguy is wise.
14:59:50 <tkahn6> flowenol: that expression is conceptually equivalent to /s*/
14:59:53 <mekeor> Cale: you're a very experienced haskeller, aren't you?
15:00:02 <flowenol> tkahn6 ah regex like
15:00:03 <Cale> yes
15:00:24 <flowenol> tkahn6 a great way for me to understand
15:00:25 * hackagebot hsc3-server 0.3.2 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.3.2 (StefanKersten)
15:00:25 <tkahn6> flowenol: correct `many` = `*`
15:00:37 <flowenol> thanks
15:00:38 <tkahn6> and `many1` = '+'
15:00:38 <Cale> I've been programming in Haskell for 10 years, and it's my job
15:00:40 <tkahn6> yeah gl
15:01:17 <flowenol> btw for thse helping me this is what i am trying to understand http://paste.pocoo.org/show/578685/  it is supposed to have some errors
15:01:24 <mekeor> Cale: nice. cool. i like you.
15:01:51 <gnoi> How can I use \b (word boundaries) in regex-pcre-builtin?
15:02:05 <ikeg> well, 'do foobar' is exactly same 'foobar', but, it may be confused a Haskell newbie. My opinion: it's a mess
15:02:06 <Mathnerd314> Cale: how often have you used fix id?
15:02:28 <gnoi> > "Hello world" =~ "\bworld\b" :: Bool
15:02:29 <gnoi> False
15:02:30 <lambdabot>   False
15:02:39 <Cale> Mathnerd314: only as often as I needed an example of a nonterminating computation?
15:02:40 <gnoi> But I want True for it
15:02:58 <Botje> gnoi: try \\b instead
15:03:23 <ikeg> anyway it is important to point out about do, and Cale++
15:03:39 <gnoi> Botje: great
15:03:54 <Mathnerd314> Cale: so you've never used it in a "real" program?
15:04:14 <ciaranm> you've got to watch out for people who have been using haskell for too long. some of them get grumpy and mean in their old age.
15:04:32 <Cale> Mathnerd314: that's a pretty safe bet
15:04:35 <hpc> ciaranm: orly?
15:04:44 <Cale> Mathnerd314: I'd either use undefined or a call to error
15:04:49 <Cale> Mathnerd314: most of the time
15:05:07 <Cale> Mathnerd314: unless for some obscure reason, I really needed evaluation to block and not die
15:05:37 <ciaranm> hpc: one of the guys whose name shows up in the credits for all the original haskell papers tried to have me assassinated!
15:06:03 <ciaranm> and all because i said there obviously weren't 4 functions Bool -> Bool
15:06:33 * ikeg have a breakfast now
15:07:53 <Phlogistique> how do I generate an arbitrary instance for (Int,Int) ?
15:08:03 <Phlogistique> s/arbitrary/Arbitrary/
15:08:22 <Cale> you don't have to
15:08:26 <glguy> instance (Arbitrary a, Arbitrary b) => Arbitrary (a, b) -- Defined in `Test.QuickCheck.Arbitrary'
15:08:26 <Cale> because it's already defined
15:08:33 <glguy> teamwork!
15:08:36 <Mathnerd314> ciaranm: there are 4 /total/ functions
15:09:03 <Phlogistique> Cale: well, then for data Foo = Foo Int Int
15:09:13 <ciaranm> Mathnerd314: that wasn't the question, though
15:09:31 <Phlogistique> but well, I guess I can take a look at the instance definition for (Arbitrary a, Arbitrary b)
15:09:33 <Cale> actually, even that's maybe not true, depending on whether you consider  f x = True  to be the same as   f x = case x of True -> True; False -> True  or not.
15:09:52 <Cale> They differ in where _|_ gets sent :)
15:09:54 <ciaranm> not!
15:10:11 <ciaranm> the answer is obviously. uhm. 11, i think. maybe.
15:12:00 <Phlogistique> Couldn't GHC automatically derive Arbitrary instances when they are trivial?
15:12:05 <Cale> instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b) where
15:12:05 <Cale>   arbitrary = oneof [liftM Left arbitrary, liftM Right arbitrary]
15:12:06 <Cale>   
15:12:06 <Cale>   shrink (Left x)  = [ Left  x' | x' <- shrink x ]
15:12:06 <Cale>   shrink (Right y) = [ Right y' | y' <- shrink y ]
15:12:12 <Cale> er, oops :)
15:12:23 <Phlogistique> such as instance Arbitrary Pattern where arbitrary = liftM3 Pattern arbitrary arbitrary arbitrary
15:12:26 <Cale> instance (Arbitrary a, Arbitrary b)
15:12:26 <Cale>       => Arbitrary (a,b)
15:12:26 <Cale>  where
15:12:26 <Cale>   arbitrary = liftM2 (,) arbitrary arbitrary
15:12:28 <Cale>   
15:12:30 <Cale>   shrink (x,y) = [ (x',y) | x' <- shrink x ]
15:12:31 <Phlogistique> or this, yes
15:12:32 <Cale>               ++ [ (x,y') | y' <- shrink y ]
15:12:34 <Cale> there it is :)
15:12:44 <hpc> Phlogistique: you could probably make an extension to do it, if one doesn't exist
15:12:50 <Phlogistique> I don't understand what shrink does
15:12:59 <Mathnerd314> Cale: use hpaste?
15:13:09 <glguy> yeah, someone should really have kicked himself
15:13:20 <Cale> produces a bunch of smaller examples to try once a counterexample to a property has been found
15:14:34 <Phlogistique> what's a "smaller" example?
15:14:36 <glguy> ciaranm: I think I've come up with 12 values of that type
15:14:44 <glguy> ciaranm: did you count the outright "undefined"?
15:14:57 <Cale> Phlogistique: That's the question which shrink answers :)
15:15:38 <glguy> oh, I double counted one :)
15:15:47 <ciaranm> glguy: isn't undefined the same as f _ = let x = x in x ?
15:16:10 <glguy> ciaranm: const undefined and undefined aren't the same
15:16:52 <ciaranm> glguy: hrm. they're not?
15:16:53 <Cale> It'll try to remove or shrink elements of lists, make numbers 0 or positive if possible, try to make boolean values False...
15:17:41 <glguy> ciaranm: I guess it depends on your definition of different, but you can seq (const undefined) and not get bottom but you can't do that to undefined
15:17:52 <ciaranm> glguy: seq doesn't exist
15:17:54 <Cale> It'll also try to divide numeric values by 2
15:17:55 <danharaj> seq breaks a lot of things
15:18:06 <Phlogistique> Cale: I think I'm supposed to intuitively get something here that I don't get
15:18:13 <ciaranm> glguy: nor does unsafePerformIO
15:18:25 <Cale> Phlogistique: QuickCheck is trying to find cases on which a property fails
15:18:48 <ciaranm> so i think the answer is 11
15:18:49 <Cale> Phlogistique: Once it's found one by random search, it does a bunch of nonrandom searching to try to "simplify" the example that it's found
15:19:02 <Cale> Phlogistique: and it uses shrink iteratively to try to do that
15:19:06 <Phlogistique> Cale: oh, OK
15:19:11 <Phlogistique> Cale: got it
15:19:12 <ciaranm> since there's no way to do "parallel or" in haskell, right?
15:19:59 <glguy> ciaranm: What subset of Haskell are you interested in?
15:20:22 <glguy> or are you not talking about haskell at all
15:20:22 <ciaranm> glguy: the stuff in the alleged category Hask
15:20:37 <Cale> Hehe, *which* alleged category Hask though? :)
15:20:59 <ciaranm> the one where the answer is 11
15:21:04 <Cale> hehehe
15:21:37 <Phlogistique> ciaranm: wha"t's parallel or"
15:21:55 <Phlogistique> oops, the " got a little to far
15:22:08 <ciaranm> Phlogistique: a `parallelOr` b is true if either a is true or b is true
15:37:33 <flowenol> well just translated the code into something I can read
15:37:36 <flowenol> -4-^!2sss%s1818171616!2ss8!6ss%s5643!3ssaf1f5f3&*
15:37:40 <flowenol> ops wrong one
15:37:46 <flowenol> ^-[0-9]-\^(![0-9]ss*|%s[0-9][0-9]*)(![0-9]ss*|%s[0-9][0-9]*)(![0-9]ss*|%s[0-9][0-9]*)[0-9][0-9]*(![0-9]ss*|%s[0-9][0-9]*)(![0-9]ss*|%s[0-9][0-9]*)(![0-9]ss*|%s[0-9][0-9]*)a(f[0-9])*&\*
15:37:50 <ciaranm> this isn't #perl!
15:37:56 <flowenol> yea i know
15:38:07 <flowenol> just wanted to share
15:38:13 <flowenol> damn i love regex
15:38:38 <gnoi> flowenol: parsec
15:38:59 <flowenol> it was http://paste.pocoo.org/show/578685/
15:39:03 <adu> gnoi: what?
15:39:14 <ciaranm> parsec!
15:39:25 <gnoi> adu: what?
15:39:33 <flowenol> but for someone who knows nothing about parsec or haskell
15:39:37 <mgsloan> flowenol: other parsing methods are indeed recommended, but here's something I made that I think is pretty nifty: http://hackage.haskell.org/packages/archive/rex/0.3.1/doc/html/Text-Regex-PCRE-Rex.html
15:39:38 <ciaranm> SAY WHAT AGAIN
15:39:53 <flowenol> translating it into regex was a great achievement for me
15:40:13 <flowenol> mgsloan regex implementation? :D
15:40:32 <mgsloan> not implementation.  Just compile-time regex literals
15:40:37 <flowenol> ah
15:40:38 <gnoi> flowenol: translating it into a parsec parser could be a great achievement too
15:40:39 <mgsloan> in expressions or on the pattern side of functions
15:40:42 <t7> do people in America not say goodbye on the phone or is that just in the movies?
15:40:56 <Zamarok> t7: that's just movies lol
15:41:01 <flowenol> gnoi true, im just commenting on my point of view
15:41:19 <flowenol> gnoi if I had the regex and had to write the parsec parser
15:43:01 <mcstar> i believe it is not possible to match the head and next to head elements of a list with an AS pattern, am i correct?
15:43:50 <glguy> t7: in my family there are a few layers of "goodbye" to get thorugh
15:44:26 <t7> that sounds alot more pleasant :)
15:45:05 <adu> gnoi: you msg'd me
15:45:06 <mgsloan> flowenol: This gets kinda dense, but the beginning shows how straightforward it is to do regex implementations in Haskell: http://sebfisch.github.com/haskell-regexp/regexp-play.pdf
15:45:49 <gnoi> mcstar: what's wrong with list@(x:y:xs) ?
15:46:13 <mcstar> gnoi: doest that bind list to the whole expression?
15:46:22 <Zamarok> Hey guys, I have a mathy question.. how would you determine if a number would be in this sequence? https://oeis.org/A105115
15:46:46 <mcstar> i need a:b:rest where i dont have to recreate [a,b]
15:46:59 <ciaranm> mcstar: a:b:rest doesn't start with [a:b]
15:47:06 <ciaranm> er, [a, b]
15:47:56 <mcstar> i know how it starts, im just saying i cant do that, probably im right, just want a confirmation
15:48:08 <ciaranm> you can't
15:50:43 <zzing> I am trying to use haskeline for some basic input, and I am using something pretty close to what their one example has but it only outputs the line of text I have. I was wondering if there is something obvious to everyone else but oblivious to me that I am doing wrong: https://gist.github.com/ffa7d5c458d315be4aa1    (only line 6 seems to do anything)
15:59:02 <mcstar> i just made an AES enc/dec world class software
15:59:27 <zzing> mcstar, you did your own encryption?
15:59:31 <osager> hi all can i use hoogle cmdline to search for haskell source code ?
15:59:43 <mcstar> Codec.Crypto.AES
15:59:46 <mcstar> XD
16:00:14 <mcstar> i just needed to customize it
16:00:29 <tkahn6> osager: cabal install hoogle
16:00:38 <mcstar> im starting to like this haskell thing
16:00:45 <osager> hi tkahn6 idid that
16:01:06 <tkahn6> osager: so what are you asking?
16:01:10 <ciaranm> just when you start it like it, it creeps up on you and stabs you in the back
16:01:10 <osager> i can use hoogle --info foo
16:01:22 <osager> but i would like to see source code
16:01:27 <osager> of library functions
16:01:32 <osager> not just type information
16:01:36 <tkahn6> oh i see
16:01:43 <mcstar> ciaranm: nah, cant be right
16:01:57 <mcstar> am only afraid of monad transformers
16:02:09 <iihavetoes26> i just learned me a haskell. how should i hone my haskell skills?
16:02:38 <mcstar> learned vs. learnt?
16:02:43 <ciaranm> iihavetoes26: write a small compiler
16:03:22 <hpc> iihavetoes26: write anything, really
16:03:51 <hpc> compiler, IRC bot, website, etc
16:04:06 <glguy> mcstar: learnt is for people with a queen ;)
16:04:18 <hpc> @wn learnt
16:04:19 <lambdabot> No match for "learnt".
16:04:24 <hpc> @wn learned
16:04:24 <lambdabot> *** "learned" wn "WordNet (r) 3.0 (2006)"
16:04:24 <lambdabot> learned
16:04:24 <lambdabot>     adj 1: having or showing profound knowledge; "a learned jurist";
16:04:24 <lambdabot>            "an erudite professor" [syn: {erudite}, {learned}]
16:04:24 <lambdabot>     2: highly educated; having extensive information or
16:04:26 <lambdabot> [7 @more lines]
16:04:28 <mgsloan> iihavetoes26: Yeah, best to pick something that's interesting to you!  Read others' code, read the code of the prelude, and the libraries you use.  Take a look at this maybe: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
16:04:50 <tech2> God bless Her Majesty ;)
16:04:52 <td123> iihavetoes26: pick an algorithm and implement it :) (avoid graph algorithms at least for now)
16:05:09 <ciaranm> i disagree with any style guide that doesn't start with "import Prelude hiding ((.))"!
16:05:54 <mcstar> iihavetoes26: maybe do something visually pleasing with gloss
16:06:07 <iihavetoes26> thanks for the suggestions!
16:07:01 <mcstar> td123: why?
16:07:30 <mm_freak> ciaranm: so you needlessly import Control.Category and hide both (.) and 'id' all the time?  that sounds like a waste of time to me
16:08:28 <zzing> When it comes to parsing, should I look at Parsec 2, or 3, or another (attoparsec?)?
16:08:34 <bobajett> hmm I wonder if we should build a  haskell padwan to jedi roadmap for other padwans to follow
16:09:09 <mcstar> another star trek fun, pff
16:09:33 <ciaranm> mm_freak: (.) should be fmap
16:09:45 <mm_freak> no, why?
16:10:08 <mm_freak> (.) from Control.Category sounds like a much better and more useful generalization of (.)
16:10:41 <hpc> prelude's (.) and id are fine
16:10:48 <mcstar> td123: id like to understand what is behind your advice
16:10:55 <hpc> because every other Category instance is a pain in the ass to deal with in real code
16:11:04 <hpc> and the only really interesting stuff is in Arrow anyway
16:11:18 <mm_freak> i agree, but i wouldn't mind putting Category into the Prelude
16:11:24 <hpc> skip importing Category, import Arrow, and only use (***)/(&&&)
16:11:27 <mm_freak> i would, however, mind generalizing (.) to fmap
16:11:38 <mm_freak> hpc: that's also wrong
16:11:43 <hpc> Prelude's specialized types have their place for newbies
16:11:49 <mm_freak> the Category instance for lenses is very useful
16:11:50 <rwbarton> not just newbies
16:11:55 <mm_freak> also Category is very useful for AFRP
16:11:56 <rwbarton> people who like to read code also benefit
16:12:32 <hpc> mm_freak: ah, i haven't done any lens/frp work
16:12:34 <ciaranm> if i had to suffer to write it, you should have to suffer twice as much to read it
16:12:43 <hpc> it doesn't play nice with my brain
16:13:22 <mm_freak> hpc: then you shouldn't go as far as saying "this sucks for all instances", if you know only sucking ones
16:15:06 <zzo38> I can implement tail for any MonadLogic; many of list operations can be generalized to Functor, Applicative, Alternative, Monad, MonadPlus, MonadLogic, Traversable, Foldable, ...
16:16:06 <zzo38> (To generalize [] to other types. To generalize the index and lengths, you can use my Peanoid and Copeanoid classes)
16:17:38 <zzo38> And there is other things too:   consA :: Alternative f => x -> f x -> f x; consA x = (pure x <|>);   liftList :: Alternative f => [x] -> f x; liftList = foldr consA empty;   tailL :: MonadLogic m => m x -> m x; tailL = msplit >=> maybe (error "tailL: empty list") snd;
16:22:00 <zzo38> Isn't Logic (in "logict" package) like defining a list by fold?
16:29:05 <mgsloan> implicit view patterns are not in GHC, right?
16:29:28 <mgsloan> I guess I could just test, but I'm not sure where I'd import the "View" class from in order to try
16:38:50 <mcstar> crypto course is fun
16:39:01 <mcstar> is anyone taking it from here?
16:41:31 <Clint> the stanford one?
16:41:46 <mcstar> yeah, with dan bohen
16:41:52 <mcstar> boneh
16:42:20 <sipa> i am
16:42:32 <mcstar> im doing week3 homeworks
16:42:40 <mcstar> just before deadline
16:42:49 <|Steve|> Dan is my academic grandfather.
16:43:03 <sipa> mcstar: which one was that?
16:43:13 <sipa> oh, the shortened sha256 one
16:43:21 <mcstar> collision resistant hash functions
16:43:27 <mcstar> and message authentication
16:43:35 <sipa> a lot easier than the assignments from week 1
16:43:54 <mcstar> idk
16:44:14 <mcstar> i paid more attention to the first one, thats for sure
16:44:32 <mcstar> i dont have much time, and the videos are lenghty
16:44:54 <mcstar> not one by one, but there are many
16:46:14 <mcstar> what kind of accent does Dan have? i can clearly understand him all the time
16:54:07 <zzo38> tail = msplit >=> maybe (error "tail: empty list") snd; x !! n = either id (error "(!!): no element") $ foldl (\y x -> y >>= maybe (Left x) Right . predP) (Right n) x; length = foldr (const succP) zeroP;   And then I can write the other ones generalized list function too
16:54:35 * mgsloan wonders if I missed the answer to my question
16:55:08 <zzo38> Is there any other one, or thing wrong with this one, do you think so?
16:58:03 <mcstar> mgsloan: you didnt
16:58:19 <mcstar> *if he* btw
16:58:24 <mgsloan> mcstar: cool, thanks! I really need to set up persistent irc..
17:23:14 <dscw80_> http://projecteuler.net/problem=4 is string manipulation all that easy in Haskell?
17:25:11 <azaq23> http://unrelatedlink.com/ is vague topic that verb?
17:25:48 <djahandarie> azaq23, yes!
17:29:39 <glguy> dscw80_: That problem is easy in Haskell. Is there a particular thing you wanted to know how to do?
17:31:03 <mcstar> dscw80_: you can do everything with a string you can do with a list: [Char]
17:31:34 <dscw80_> glguy: easy in java. I just brute forced it, start at 999*999 and loop down reverse the string and string compare to see if palindrome. How would you go about it in Haskell?
17:31:37 <mcstar> i couldnt do every problem in haskell yet
17:32:17 <glguy> dscw80_: I'd probably do the same thing in Haskell as you did in Java
17:32:20 <dscw80_> mcstar:  it's real easy in ruby, 4 lines of code.
17:33:32 <glguy> something like this:
17:33:34 <glguy> > maximum [ p | a <- [100..999], b <- [a..999], let p = a*b, show p == reverse (show p)]
17:33:35 <lambdabot>   906609
17:34:15 <mcstar> i mean there were some problems where i needed mutable trees or something, and i havent done much mutable things
17:35:31 * hackagebot ad 1.4 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.4 (EdwardKmett)
17:35:32 <mcstar> i liked my solution to the Pell equation, that i did in haskell
17:36:02 <shachaf> dscw80_: What's the point of asking about those problems in here?
17:36:49 <mcstar> btw ppl load up a shitload of code to the forum of each problem, im sure there is at least 1 haskell
17:38:47 <byorgey> shachaf: to learn?
17:39:43 <mcstar> one thing can be annoying in the forum, when rookie python programmers brag about how easy and conscice their solution is
17:41:34 <irene-knapp1> on the other hand, I've taken flack at work for how verbose my solutions are
17:41:43 <irene-knapp1> "Why is this four lines instead of one?"  "Um, clarity?"
17:42:19 <otters> go back to your college comp sci course, noob
17:42:33 <irene-knapp1> my crowning achievement was when I had to make a variable to hold the name of the actual variable I wanted to refer to
17:42:49 <irene-knapp1> because the actual variable name was too long to fit on one line
17:42:58 <irene-knapp1> I called the placeholder really_long_variable_name
17:43:27 <mcstar> good joke
17:43:27 <irene-knapp1> (yes, I did grimace at the necessity for it.  don't worry.  I'm not crazy :D)
17:44:06 <mcstar> ghc truncates symbol names at 8 and a half character anyway
17:45:40 <irene-knapp1> is the half character the high nibble or the low one?
17:46:11 <mcstar> platform dependent, the report doesnt say explicitely which one
17:46:42 <irene-knapp1> haha okay then
17:47:08 <irene-knapp1> of course if it's a wide character, it's really 8-and-a-quarter characters
17:50:31 * hackagebot pktree 0.2 - Implementation of the PKTree spatial index data structure  http://hackage.haskell.org/package/pktree-0.2 (StephenWeber)
17:51:04 <bgamari> Anyone know why attoparsec doesn't appear to have a "many" combinator?
17:52:02 <shachaf> bgamari: I think it's in Alternative.
17:52:58 <shachaf> import Control.Applicative (many)
17:53:54 <bgamari> Ahhh
17:53:56 <bgamari> Thanks!
17:59:34 <hpaste> scombinator pasted “Problem 2” at http://hpaste.org/66741
18:00:00 <scombinator> Is there a nicer way of solving that? I wasn't sure (y:xs) was going to work
18:00:32 <scombinator> It's meant to (and does, I think) return the second to last item of a list
18:02:35 <BrianHV> well, you can leave out one level of parens... (x:y:xs)
18:02:51 <scombinator> cool
18:02:59 <BrianHV> I think I'd personally go with pattern matching rather than guards there
18:03:44 <scombinator> I didn't know how to match the end of the list
18:04:30 <BrianHV> myButLast (x:y:[]) = x
18:05:09 <scombinator> Ah
18:06:06 <scombinator> myButLast (x:xs) = myButLast xs
18:06:55 <BrianHV> yep
18:07:15 <scombinator> btw, do you know a decent haskell mode for emacs?
18:07:23 <BrianHV> I'm a vim guy myself
18:08:14 <donri> scombinator: http://youtu.be/E6xIjl06Lr4
18:08:40 <donri> i think that's https://github.com/haskell/haskell-mode
18:10:33 * hackagebot ghc-mod 1.10.13 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.13 (KazuYamamoto)
18:10:54 <BrianHV> hackagebot is timely
18:11:23 <scombinator> I see
18:15:15 <|Steve|> > fix (\f x -> if x < 2 then 0 else (f (x-1)) + (f (x-2))) 5
18:15:15 <lambdabot>   0
18:15:25 <|Steve|> > fix (\f x -> if x < 2 then 1 else (f (x-1)) + (f (x-2))) 5
18:15:26 <lambdabot>   8
18:16:56 <|Steve|> How is fix implemented?
18:18:19 <mekkz> Can anybody tell me what some real-world applications for haskell might be? i just started learning it and i'm really curious as to what it can do.
18:19:09 <mcstar> research papers
18:19:10 <brownies> i hope someone figures out the answer and writes a book about it
18:19:33 <scombinator> brownies: Perhaps they could call it 'Real-world haskell'?
18:19:56 <brownies> scombinator: maybe. maybe. crazy idea, i know.
18:20:12 <mekkz> i can always count on irc to make me feel like a dumbass
18:20:53 <scombinator> It's a programming language, real world applications include all real world applications for programming languages in general.
18:20:54 <mcstar> afaik haskell is good for anything except systems programming
18:21:10 <mcstar> (you dont want gc there)
18:21:17 <mcstar> (or who knows)
18:21:41 <hpc> sometimes you can get away with gc, if you write it yourself and have a ginormous brain
18:22:03 <scombinator> Lisp machines had gc
18:22:17 <mcstar> lisp machines disappeared
18:22:37 <scombinator> Perhaps they were missing a root pointer?
18:23:06 <mcstar> AES is definitely stronger than me
18:23:10 <hpc> mcstar: because the world wasn't ready to be shown how little computer science it knows
18:23:28 <hpc> ;)
18:23:54 <mcstar> truly novel ideas need time to be accepted
18:24:44 <bobajett> mcstar: re: systems programming: http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/A-Means-to-Many-Ends-10-Years-of-Haskell-at-Galois?format=html5
18:24:46 <BrianHV> from the neco-ghc install directions: "Unarchive neco-ghc and put it into a dir of your &rtp."  my what now?
18:25:34 <bobajett> those guys were writing device drivers and their own networking stack
18:25:53 <scombinator> BrianHV: Real-time Transport Protocol?
18:26:47 <BrianHV> scombinator: I don't have such a protocol, much less a directory in it. ;)
18:27:26 <mcstar> bobajett: they had much time on their hands
18:27:28 <clinton> 'cabal update' only seems to download the package list, not actually upgrade any packages. How do I get cabal to update all packages?
18:28:06 <hpc> clinton: you would cabal install every package again individually
18:28:13 <aristid> clinton: cabal upgrade,if it wouldn't refuse to operate :)
18:28:17 <hpc> or ideally, just cabal install the interesting ones
18:28:51 <mcstar> windows is in the making of F*
18:29:01 <hpc> dealing with different versions of things with cabal is... complicated
18:29:06 <mcstar> sry, MS research
18:29:16 <brownies> BrianHV: your run time path
18:29:29 <BrianHV> brownies: ah! thanks
18:29:43 <clinton> as in, I need to ask to upgrade the particular packages I want to upgrade?
18:30:01 <hpc> clinton: yeah
18:30:12 <mcstar> i didnt know that either
18:30:55 <hpc> say you installed preposterous-haskell-program (PHP for short) and the version you downloaded 6 months ago had a huge security flaw
18:31:02 <hpc> "cabal update; cabal install PHP" -- done
18:31:33 <hpc> you might need to --reinstall somewhere in there, but i think that's it
18:31:36 <monochrom> by 2020, you will be able to "cabal install gcc" :)
18:31:36 <mcstar> i didnt find a remove command
18:33:32 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why blind upgrade is a bad idea
18:33:45 <hpaste> scombinator pasted “problem 5” at http://hpaste.org/66745
18:34:07 <scombinator> How do I reverse a list without using a helper function (as in the paste)
18:35:28 <hpc> scombinator: would (++) count as a helper function?
18:35:33 <hpc> > "abc" ++ "def"
18:35:34 <lambdabot>   "abcdef"
18:36:00 <hpaste> mcstar annotated “problem 5” with “problem 5 (annotation)” at http://hpaste.org/66745#a66746
18:36:03 <scombinator> hpc: To my mind a helper function is one that is never used elsewhere
18:36:16 <hpc> ah, groovy
18:36:36 <hpc> well, suppose you were reversing "abc"
18:36:45 <hpc> 'a' would clearly be at the end of the list
18:36:52 <hpc> and the start of the list would be (reverse "bc")
18:37:03 <hpc> or in other words
18:37:09 <hpc> > "bc" ++ ['a']
18:37:11 <lambdabot>   "bca"
18:37:20 <hpc> > "cb" ++ ['a'] -- rather
18:37:22 <lambdabot>   "cba"
18:37:41 <hpc> and reversing the empty list is obviously the empty list
18:37:47 <hpc> that should be the whole definition
18:38:00 <pqmodn> in System F (impredicative polymorphism), in the term id = (/\a. \x:a. x) does a range over types (*) _and_ type constructors (* => *)?
18:38:49 <scombinator> mcstar: I get an occurs check issue with 'myrev xs = foldl (:) [] xs'
18:38:50 <dolio> No, that wouldn't make sense.
18:38:58 <pqmodn> dolio: yeah, i didn't think so... but..
18:39:08 <dolio> There are no inhabitants of types with kind * -> *.
18:39:20 <hpc> :t foldl
18:39:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:39:25 <hpc> :t foldl (:)
18:39:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:39:26 <lambdabot>       Expected type: a
18:39:26 <lambdabot>       Inferred type: [a]
18:39:31 <dolio> And not in an "empty type" way but in a "this is nonsense" way.
18:39:33 <hpc> :t foldl (flip (:))
18:39:34 <lambdabot> forall b. [b] -> [b] -> [b]
18:40:11 <dolio> Also, there's nothing like * -> * in System F.
18:40:32 <pqmodn> dolio: http://www.pps.jussieu.fr/~miquel/enseignement/mpri/SystF.pdf on slide 6 it shows applying (forall a. a -> a) as the type argument. is the kind of (forall a. a->a) simply "*"?
18:40:37 <scombinator> ah
18:40:48 <dolio> pqmodn: Yes.
18:41:20 <dolio> * is the only kind in System F.
18:41:31 <hpaste> mcstar annotated “problem 5” with “problem 5 (annotation) (annotation)” at http://hpaste.org/66745#a66747
18:41:41 <pqmodn> dolio: oh that's right
18:42:55 <hpaste> scombinator annotated “problem 5” with “problem 5 (annotation)” at http://hpaste.org/66745#a66748
18:44:40 <mcstar> watch out with append, fastest way to reverse a list is using an accumulator
18:45:22 <BrianHV> scombinator: thanks for finally motivating me to install the vim ghc modes.
18:45:25 <scombinator> I figured, this is pedagogical
18:45:34 <scombinator> did I?
18:45:41 <BrianHV> you did.
18:45:52 <BrianHV> just by asking about the emacs mode.
18:46:28 <mcstar> almost 4am
18:46:31 <mcstar> bb
18:50:06 <llayland> Do you like the vim mode and which one did you use?
18:56:06 <stepkut> mirror, mirror on the wall, which atom/rss library is the fairest of them all?
19:00:24 <hpc> stepkut: you are, my queen
19:00:50 <stepkut> hpc: well.. since I did write one of the RSS libraries.. that is a reasonable answer..
19:00:54 <hpc> stepkut: you might try looking at xml libraries
19:01:05 <stepkut> :-/
19:01:20 * stepkut tries to avoid looking at XML as much as possible
19:01:34 <hpc> then you're pretty much boned, since RSS is XML
19:01:59 <stepkut> I know.. but I would rather create a value of type RSS and have it generate most of the XML for me
19:03:00 <waxjar> is haskell similar to lisp?
19:03:14 <scombinator> waxjar: for which value of lisp?
19:03:48 <waxjar> i don't understand that question :p
19:04:05 <parcs`> no it's not similar
19:04:29 <stepkut> waxjar: it shares some things in common, such as first class functions and closures -- but many things are quite different. the overall experience is certainly very different.
19:05:11 <waxjar> ok, thanks parks and stepkut
19:05:11 <stepkut> waxjar: they are related due to their common foundation in lamba calculus.. but they diverge very quickly
19:08:58 <mm_freak> anyone have an idea how to best use acid-state in presence of multiple processes accessing the same database, when you don't want to have a server process running in the background?
19:09:38 <mm_freak> like:  using acid-state for a small batch-style command line utility that may run multiple times simultaneously…  serialized access would be fine
19:09:51 <BrianHV> ghc-mod seems to choke on preprocessor directives...
19:10:43 <pqmodn> dolio: i'm a bit puzzled. isn't /\a.a the identity function on types, why is it not * -> *?
19:10:48 <hpc> mm_freak: look for IPC libs, perhaps?
19:11:10 <hpc> http://hackage.haskell.org/package/ipc -- extremely beta, it seems
19:11:20 <hpc> but technically does inter-process communication
19:11:20 <dolio> pqmodn: That's ill-formed.
19:11:28 <mm_freak> hmm
19:11:46 <dolio>  /\ binds a type and has a term as a body.
19:11:47 <mm_freak> Build failureghc-6.12 (log), ghc-7.0 (log)
19:11:51 <mm_freak> looks bad
19:12:05 <pqmodn> dolio: got it. thanks!
19:12:11 <mm_freak> that library was last updated in 2010
19:12:19 <dolio> At least in System F.
19:14:07 <mm_freak> i guess i'll resort to writing an HTTP server with an API, although that feels ugly =/
19:14:20 <parcs`> doesn't acid-state has a network backend?
19:14:28 <mm_freak> it does, but i don't want to use it
19:14:44 <parcs`> why notL
19:15:11 <mm_freak> because it's just a hack to allow multiple processes to access the same database…  there is no security layer at all and i have no performance data
19:16:00 <mm_freak> i might resort to sqlite, but acid-state is really amazing
19:19:42 <scooty-puff> is there a function similar to: HashSet a -> Maybe (a, HashSet a)
19:21:00 <parcs`> const Nothing?
19:23:26 <copumpkin> lol
19:25:26 <scooty-puff> (don't care what "a" is, just want to take one from it)
19:31:19 <zzo38> length :: (Peanoid i, Foldable t) => t x -> i; length = foldr (const succP) zeroP;     Is this correct foldr or would foldl be better?
19:38:38 <dmwit> Wouldn't HashSet a -> [a] be better in a lot of ways?
19:38:51 <dmwit> Or do you really want the set without the element?
19:39:13 <zzo38> dmwit: Better for what purpose?
19:40:07 <dmwit> I guess it's not better, since that's offered, and presumably scooty-puff would have just used that if it were good enough.
19:40:27 <rwbarton> HashSet is some kind of wrapper around IntSet right?
19:40:27 <jk__> hello
19:41:15 <dmwit> rwbarton: Doesn't seem to be. HashSet a is basically HashMap a (), which doesn't call out to IntMap anywhere.
19:42:11 <dmwit> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/src/Data-HashMap-Base.html#HashMap
19:42:16 <dmwit> jk__: howdy
19:42:21 <zzo38> You can use TypeRep as the keys in a HashMap if it is useful to you. Soon after I posted a library using it, the author of that library posted another one which allows the use of TypeRep as keys.
19:42:29 <rwbarton> how does that relate to http://hackage.haskell.org/packages/archive/hashmap/1.0.0.2/doc/html/Data-HashSet.html
19:42:50 <dmwit> ...I thought we were talking about unordered-containers-Data.HashSet
19:43:14 <rwbarton> afaict there is no context; I didn't realize there was more than one
19:43:23 <dmwit> Me neither.
19:44:17 <zzo38> You can with HashSet too, yes HashSet is like the type (\x -> HashMap x ()) and Tree from Data.Tree is like (Cofree [])
19:44:28 <scooty-puff> dmwit, didn't want to rebuild HashSet from the tail
19:45:38 <rwbarton> there's difference
19:46:36 <rwbarton> unclear how efficient it is though
20:12:02 <scombinator> So you can't use pattern matching to specify something like 'equal a a = True' ?
20:12:23 <rwbarton> no
20:13:10 <scombinator> lame
20:17:54 <shachaf> scombinator: Haskell the language doesn't really have a general concept of "equality".
20:18:45 <sebz> Hi, I'm playing around with GADTs for the first time and not too sure how to deal with this type error I'm getting.
20:18:49 <hpaste> sebz pasted “GADTs” at http://hpaste.org/66749
20:18:58 <sebz> "Couldn't match type `b' with `Triv'"
20:19:16 <copumpkin> Obj' :: Subcategory' Triv
20:19:22 <copumpkin>  Subcategory' b
20:19:36 <copumpkin> b is not Triv
20:19:39 <sebz> right
20:20:02 <sebz> so is there a way to do something like this correctly?
20:20:09 <copumpkin> depends what you're trying to do
20:20:14 <copumpkin> are you trying to make an existential b there?
20:20:18 <copumpkin> where you get to pick the b?
20:20:33 <sebz> I'm not really sure… but that sounds right
20:20:38 <copumpkin> functor :: forall a b. Subcategory a -> Subcategory' b
20:20:46 <copumpkin> that's forall
20:20:50 <copumpkin> the caller of functor gets to choose b
20:20:59 <copumpkin> and could easily make it (Int -> Int -> Int)
20:21:16 <copumpkin> and you need to be able to provide Subcategory' (Int -> Int -> Int) for the caller if he asks for it
20:21:42 <copumpkin> if that's too onerous, you probably want exists b., which you can't write directly in Haskell
20:22:03 <copumpkin> you can approximate it either with a rank-2 continuation or with an existential wrapper
20:22:46 <sebz> I'll read up on those
20:23:16 <copumpkin> the easiest way is to make it functor :: Subcategory a -> (forall b. Subcategory' b -> r)
20:23:28 <copumpkin> -> r
20:23:41 <copumpkin> functor :: Subcategory a -> (forall b. Subcategory' b -> r) -> r, that is
20:24:08 <copumpkin> and then instead of just returning Obj, you call the function with Obj
20:27:38 <clinton> :t <$>
20:27:38 <lambdabot> parse error on input `<$>'
20:28:34 <clinton> I've been using yesod, and noticed this '<$>' operator. Is it a generic haskell operator or something yesod specific?
20:28:46 <clinton> (unfortunately, I find "<$>" hard to google)
20:28:58 <Clint> @src (<$>)
20:28:58 <lambdabot> f <$> a = fmap f a
20:29:17 <glguy>   	-- Defined in `Data.Functor'
20:29:26 <glguy> usually people get it from Control.Applicative
20:29:39 <alkalurops> I bought, awhile ago, The Haskell Road to Logic, Maths and Programming. I am a newbie to Haskell. Is this a reasonable place to start.
20:32:56 <alkalurops> I am interested in an attempt to implement the Risch Algorithm using Haskell.
20:33:18 <clinton> ah, thanks for that, it makes sense now
20:34:19 <alkalurops> Ijust want to do it for purely transcendental functions.
20:37:47 <sebz> copumpkin: thanks!
20:41:14 <dmwit> clinton: You can use Hoogle to search for functions.
20:41:20 <alkalurops> I am new to Haskell. Please recommend a good place to start.
20:41:22 <dmwit> http://www.haskell.org/hoogle/?q=%3C%24%3E
20:41:28 <dmwit> ?where gentle
20:41:28 <lambdabot> http://www.haskell.org/tutorial/
20:41:30 <dmwit> ?where lyah
20:41:30 <lambdabot> http://www.learnyouahaskell.com/
20:41:34 <dmwit> alkalurops: There, or there.
20:41:57 <dmwit> Oh, I missed the context, sorry.
20:42:27 <dmwit> The book you got is a great place to start.
20:43:07 <dmwit> I don't know enough about the Risch Algorithm or transcendental functions to give more specific advice than "read a lot about Haskell and write a lot of Haskell".
20:44:03 <alkalurops> dmwit: Understand, I will probably not attempt it. I am interested in improving my thought process about how to development software. And the idea of a program as a proof was an interesting idea to me.
20:44:23 <dmwit> You might like to take a look at the automatic differentiation packages on Hackage, though.
20:44:34 <dmwit> (Just guessing from the first sentence of the Wikipedia page on the Risch algorithm. =)
20:45:47 <dmwit> http://hackage.haskell.org/package/ad
20:46:42 <alkalurops> I already gave up that idea. I have a full time job and am interested in learning Haskell to help me think in code better.
20:46:57 <alkalurops> I want to improve my dev skills, and thought Haskell might help.
20:47:15 <dmwit> That attitude will help, that's for sure. =)
20:47:45 <dmwit> I think Haskell has many things to teach a programmer who hasn't tried out the functional paradigm or the immutable paradigm before.
20:48:40 <glguy> alkalurops: You should dive in and come back here when you have some questions about what you learned
20:48:53 <alkalurops> I finished my tour of Eiffel and it helped a bit.
20:49:40 <dmwit> I think Haskell's type system has many things to teach a programmer who hasn't tried the "excellent, light-weight static analysis" paradigm before, too. =)
20:50:25 <alkalurops> My main interest in Haskell is related to the Curry-Howard correspondence stuff.
20:51:41 <dmwit> You might want to jump straight to Coq/Agda for that!
20:51:56 <dmwit> ?quote Cale inconsistent
20:51:56 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
20:52:28 <shachaf> That sense is about as interesting as the theorems.
20:54:35 <rsimoes> intuitionist logic! out with the law of the excluded middle!
20:56:46 * monochrom supports the law of the excluded middle
20:57:05 <zzo38> Why is there no Monad for Cofree? Can (Cofree f) make a monad if f is Alternative? Based on Data.Tree you might have:   return = (:< empty); join ((x :< y) :< z) = x :< (y <|> fmap join z);   But can it always make a monad in this way?
20:57:39 <zzo38> monochrom: The law of excluded middle is for classical logic, not for intuitionistic logic. So it doesn't matter whether or not you support it; in some cases it applies and other it won't
20:58:34 <alkalurops> It is more important to preserve justification then it is truth. ( Random illogical thought)
20:58:58 <zzo38> (Cofree f) can certainly be never Alternative; since Alternative and Comonad are mutually exclusive.
20:59:26 <zzo38> Do you know?
21:00:25 <glguy> monochrom: What kind of support do you provide?
21:00:51 <glguy> Do you find the elements in the cases that they do exist?
21:01:22 <alkalurops> So can haskell be used to prove that an CPU works correctly?
21:01:50 <zzo38> alkalurops: Unless it is the Haskell Computer, I doubt it.
21:02:08 <dmwit> alkalurops: Yes. It would be a herculean task, and Haskell is not the right tool for it, but it could probably be done.
21:02:17 <glguy> You won't be doing much proving in Haskell
21:02:36 <dmwit> alkalurops: It would involve encoding the properties you mean by "works correctly" as a Haskell type, and then implementing a term that inhabits that type.
21:02:41 <shachaf> glguy: The only reason is that proving things is so easy in Haskell!
21:02:47 <shachaf> proof = proof, QED
21:03:28 <dmwit> alkalurops: I believe there have even been some attempts to make proofs about hardware (though these are usually done in Coq, not Haskell).
21:03:36 <glguy> Haskell adds additional constraints if you want your types to represent proofs, and the things you can prove will be trivial
21:03:45 <dmwit> Tough to make a good connection between the hardware and software artifacts, though; that part will always be informal.
21:05:57 <monochrom> you can write a theorem prover in haskell. this prover does not have to have anything to do with the curry-howard koolaid
21:06:04 <zzo38> Is edwardk in here he wrote "free" package so maybe he knows if it can make a monad in this way? Although I suppose that contradicts the existing Applicative instance even if it is
21:06:29 <zzo38> Also, tell edwardk that it is not really a comonad transformer and a monad transformer
21:06:44 <dmwit> ?tell zzo38 how to use ?tell
21:06:45 <lambdabot> Consider it noted.
21:07:06 <dmwit> ?ask zzo38 if he knows how to use ?ask
21:07:06 <lambdabot> Consider it noted.
21:07:15 <zzo38> ?tell edwardk that it is not really a comonad transformer and a monad transformer
21:07:16 <lambdabot> Consider it noted.
21:07:24 <glguy> dmwit: I'm sure edwardk appreciates your teaching that :-p
21:07:33 <dmwit> zzo38: You might want to tell him what "it" is. =)
21:07:40 <zzo38> dmwit: O, yes.
21:07:41 <lambdabot> zzo38: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:08:02 <dmwit> glguy: hm... whoops
21:08:05 <zzo38> ?tell edwardk that Cofree and Free is not really a comonad transformer and a monad transformer
21:08:05 <lambdabot> Consider it noted.
21:08:13 <glguy> edwardk: You should sign dmwit up for some mailing lists
21:08:36 * dmwit turns his spam filter up to 11
21:09:23 <edwardk> zzo38: correct
21:09:23 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:10:03 <zzo38> dmwit: Eleven? Is that the maximum setting? Set it up to infinity.
21:10:20 <edwardk> zzo38: i plan to go back and add the transformer versions of each
21:10:25 <dmwit> Yeah, but there's so many false positives when I crank it up to infinity.
21:11:01 <zzo38> edwardk: Yes, you can make FreeT and CofreeT, please.
21:11:12 <edwardk> zzo38: will do
21:11:31 <edwardk> zzo38: i already had someone pop up with an issue on github =)
21:11:47 <zzo38> OK
21:12:35 <zzo38> edwardk: Do you know if Cofree can make a monad in a way I said about? However, that is not compatible with the Applicative instance you already have, so it won't work anyways
21:13:09 <edwardk> zzo38: there is a comonad possible for cofree
21:13:11 <edwardk> er a monad
21:13:21 <edwardk> and yeah there is that
21:15:52 <zzo38> edwardk: Do you have other names for what I called Initialize and Finalize?
21:16:04 <edwardk> zzo38: i missed the statement of them
21:16:36 <zzo38> data Initialize x; data Finalize x = Finalize;   Now Initialize is comonad (some disagree) and Finalize is monad
21:17:12 <zzo38> (And I believe these monads/comonads can also be used on any category having final/initial objects too)
21:17:43 <edwardk> they are
21:18:09 <edwardk> I don't know if I have them in the current set of libraries though. hrmm
21:19:17 <dmwit> You surely have Void somewhere for Initialize.
21:19:30 <zzo38> If you don't already have a name, I suppose you could call them Initialize and Finalize, if you want to
21:19:37 <dmwit> I feel confident a man of your stature and taste would have Unit somewhere as well.
21:19:38 <edwardk> I have void, I just think I let its parameterized version go
21:19:49 <edwardk> it was in category-extras
21:19:54 <dmwit> oh, quite, they're, like, Void1 and Unit1, aren't they
21:20:31 <tkahn6> is there an idiomatic way to distinguish between values which values in a State monad may be modified and which should not be modified?
21:20:46 <dmwit> tkahn6: Yes, use Reader for the ones that shouldn't be modified.
21:20:56 <tkahn6> dmwit: ok i thought about doing that
21:21:04 <tkahn6> what does that type signature look like?
21:21:44 <dmwit> (MonadReader m r, MonadState m s) => ...
21:21:45 <dmwit> I guess.
21:22:06 <zzo38> Would it be like:   StateT s ((->) r)
21:22:24 <dmwit> StateT s (Reader r) a
21:22:40 <dmwit> tkahn6: To be honest, I'm not sure I understand the question yet.
21:22:58 <tkahn6> dmwit: hmm i have an environment that should not be modified
21:23:05 <dmwit> There's also RWS(T), if you plan on mixing in some Writer action.
21:23:28 <edwardk> zzo38: anyways, to make it haskell 98, the newtype Initial a = Initial (Initial a) -- is probably the right version of higher rank Void for comonad-transformers
21:23:42 <tkahn6> and i have state that should be modified (and i don't want to have to pass that around to each function)
21:24:08 <dmwit> tkahn6: Yes, so functions that need to use the environment would put "MonadReader m MyFancyDancyEnvironmentType" in their class context, and functions that need to use the modifiable state would put "MonadState m MyFancyDancyState" in their class context.
21:24:10 <shachaf> edwardk: Or Initial a = Initial Void?
21:24:22 <zzo38> edwardk: Well, I don't like that, since you can use non-Haskell98 too and including many of my libraries too are using extensions
21:24:23 <edwardk> shachaf: thought about it, but i don't like the box there
21:24:45 <edwardk> zzo38: well, i maintain a strict layering so that all of the non-haskell 98 libraries sit on top
21:24:53 <zzo38> OK
21:24:56 <edwardk> this doesn't compromise the presence of any instances
21:25:08 <edwardk> because anything that needs anything higher sits at a higher tier
21:25:09 <shachaf> There's a box there?
21:25:21 <edwardk> oh just newtype
21:25:21 <zzo38> Is there a way to search Hackage by sender?
21:25:23 <edwardk> hrmm
21:25:24 <edwardk> that works
21:25:40 <dmwit> zzo38: I found a list of all uploads ever once, but I don't remember where.
21:25:43 <edwardk> shachaf: i like that
21:25:54 <dmwit> (Which included the user name of the person who uploaded it.)
21:25:57 <zzo38> Is there a way to search Hackage by other things such as date and license too?
21:25:58 <tkahn6> dmwit: ok i'll see if that makes sense
21:26:10 <tkahn6> (to me)
21:26:18 <edwardk> zzo38: you can download the package list which contains all the .cabal files
21:26:24 <edwardk> zzo38: i use that when i need to mine information
21:27:01 <zzo38> Does the "cabal" program include commands for those things?
21:29:04 <zzo38> Another thing is, I made a generalization of some common Haskell functions like this:   tail :: MonadLogic m => m x -> m x;   (!!) :: (Copeanoid i, Foldable t) => t x -> i -> x;   length :: (Peanoid i, Foldable t) => t x -> i;   filter :: MonadPlus m => (x -> Bool) -> m x -> m x;   iterate :: Alternative f => (x -> x) -> x -> f x;   unfoldr :: Alternative f => (b -> Maybe (a, b)) -> b -> f a;   And I can show you the codes too if you want to
21:29:19 <zzo38> Are they good using these types or do you suggest otherwise?
21:30:25 <edwardk> well the alternative based unfolds/filters are a bit awkward because it only really works for one of the two sets of semantics that gets applied to Alternative/MonadPlus
21:31:15 <edwardk> Copeanoid is that you can deconstruct it like a conat?
21:31:23 <zzo38> What is the other set, is it the backward one?
21:31:39 <zzo38> Copeanoid is meaning you can decrement it like    predP :: x -> Maybe x;
21:31:51 <zzo38> And, Peanoid means it has zero and successor
21:31:54 <edwardk> yes, thats the conat case
21:32:01 <edwardk> if you view that as pattern matching
21:33:20 <edwardk> clearly Initial needs to be InitialT in the proud tradition of making everything needlessly into a transformer ;)
21:33:46 <edwardk> newtype InitialT w a = InitialT { runInitialT :: w Void }
21:34:06 <edwardk> LimitT?
21:42:32 <edwardk> interestingly i seem to hang up on instance Extend w => Extend (InitialT w) where
21:42:59 <edwardk> i think i finally found the non-extend transformer i was looking for
21:43:46 <edwardk> i _can_ duplicate the transformer using absurd, but its not really the right one hrmm
21:53:12 <tkahn6> if i have two functions with type signatures: StateT a m1 b1 and StateT a m2 b2 is it possible to combine them without doing runStateT?
21:53:42 <tkahn6> the first one is actually StateT a IO b1
21:54:01 <shachaf> tkahn6: Think about what StateT means and the answer will come to you. :-)
21:54:44 <shachaf> (The answer is "no".)
21:54:54 <tkahn6> heh that's what i was leaning towards
21:55:00 <tkahn6> yeah that makes sense
21:56:17 <tkahn6> thanks
22:05:23 <clinton> I was going to put a Data.Map in a TVar, but then I thought it would perhaps make more sense to have a mutable map, not an immutable one like Data.Map (as TVar is going to effectively make it mutable). Does this sort of idea make sense? And if so, what data type should I be using?
22:09:51 <JoeyA> clinton: If you had a mutable map (e.g. a binary tree implemented with TVars), I think there would be an awful lot of TVar overhead.
22:09:52 <Axman6> clinton: you'll probably find that using Data.Map inside a TVar is a better choice (or even inside an IORef if you don't need transactions)
22:10:45 <JoeyA> Data.Map uses a shared representation internally.
22:11:02 <JoeyA> For example, suppose you have a 10-volume encyclopedia on a bookshelf.
22:11:37 <JoeyA> If you want to add an entry about Haskell, you don't have to burn your entire bookshelf, just the H-I-J-K book.
22:12:23 <JoeyA> Better yet, like ripping out the pages closest to Haskell and rewriting them.
22:12:46 <JoeyA> Except if someone has the old bookshelf, they can still see the old pages.  Sorry, bad analogy.
22:13:48 <JoeyA> One time, I implemented AVL using IORefs.  Data.Map was faster, if I recall correctly.
22:14:20 <JoeyA> The overhead of having to allocate O(log n) objects per insertion versus O(1) objects is surprisingly low.
22:19:01 <shachaf> JoeyA: That's because log n ~= 1
22:19:36 <JoeyA> It's more like 10 or 20 when you have a lot of objects in the dictionary.
22:19:45 <clinton> JoeyA: What makes a immutable representation of map faster when there's only one reader/writer at a time?
22:20:16 <clinton> I see what you're saying that Data.Map inside a TVar may not be much worse, but out of interest, what makes it better?
22:20:19 <shachaf> JoeyA: O(1)
22:20:26 <shachaf> If that makes you happier.
22:20:41 * hackagebot hspec 0.9.2.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.2.1 (SimonHengel)
22:21:25 <JoeyA> clinton: I was comparing it to a binary tree implemented with TVars, which would incur a lot of STM overhead.
22:22:00 <clinton> JoeyA: Couldn't you "wrap" the whole structure in one TVar?
22:22:04 <JoeyA> With an immutable representation, only one concurrent variable needs to be updated, regardless of how many items are in the map.
22:22:14 <clinton> (if you don't need fine grained locking)
22:22:28 <JoeyA> clinton: You'd need to lock the whole structure.  TVar doesn't provide locking...
22:22:39 <JoeyA> err, you can emulate a lock with TVar
22:22:44 <JoeyA> You can also do the same with MVar
22:23:14 <clinton> JoeyA: Sorry, I use "locking" loosely. It does some optimistic retry I know.
22:23:36 <clinton> I guess that needs immutable structures anyway?
22:23:36 <JoeyA> If you wrap the structure in a TVar, you still need to perform mutations to change a tree built from IORefs.
22:24:15 <tibbe> unordered-containers HashMap is O(log16 n)
22:24:15 <JoeyA> Which involves unsafe use of unsafeIOToSTM
22:25:14 <clinton> as in, I guess you can only do optimistic locking with mutable structures, because you may do a change that you need to scrap
22:25:50 <clinton> so I immutable structures can have atomicity without locks, but mutable structures require locks, would that be right?
22:26:21 <tibbe> yes and no
22:26:36 <tibbe> the immutable structure itself doesn't need any locks
22:26:52 <tibbe> but if you want to share one immutable structure throughout your program you need something like IORef (Map k v)
22:26:59 <tibbe> and atomicModifyIORef
22:27:06 <tibbe> fortunately that's quite easy to reason about
22:27:21 <tibbe> also means that you can have any number of readers and they won't be affected by writes
22:27:34 <tibbe> as they can keep references to old maps, gotten through readIORef
22:29:51 <clinton> tibbe: But you can share that immutable structure without locks, yes? Because if you have multiple simultaneous transactions using doing writes, you can apply them all at the same time, and when one completes, just scrap and retry any other active ones?
22:30:05 <tibbe> clinton: yes
22:30:19 <tibbe> clinton: once you do readIORef you get a copy of the map at that point in time
22:30:23 <clinton> whereas, with a mutable data structure, you'll need to lock, as you can't just scrap changes
22:30:32 <tibbe> in a way
22:30:47 <tibbe> the difference is when you update the immutable map you have both the old and new copies around
22:30:59 <tibbe> readers always succeed and never block
22:31:09 <tibbe> writers might need to retry (that's what atomicModifyIORef does)
22:31:39 <clinton> so if I have a counter with count 0, and two people update it at the same time, I end up with two counters with count 1, then I scrap one (one was invalid), and retry the update, and I end up with one counter at 2 yes?
22:31:43 <tibbe> clinton: you might want to watch http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey , it translates directly to haskell constructs such as IORef and STM
22:32:19 <tibbe> clinton: atomicModifyIORef uses CAS (compare-and-swap) so it retries if the value was changed between it was read and written
22:34:13 <copumpkin> preflex: seen DanBurton
22:34:13 <preflex>  DanBurton was last seen on #haskell 3 days, 6 hours, 20 minutes and 56 seconds ago, saying: > foo where foo = 3
23:13:12 <Orclev_> anyone have any clue why bracket might be causing a segmentation fault? I had essentially my own version of bracket that was working fine, but figured it was better to use the library
23:13:46 <Axman6> Orclev_: depends on how you're using it
23:14:14 <Orclev_> hmm... it just occured to me I might have the order of the args wrong... it might be freeing the value before it uses it
23:14:58 <Orclev_> yep, had the args swaped
23:15:36 <Axman6> yeah, bracket alloc free action
23:15:51 <Orclev_> yeah, I was using brack alloc action free
23:16:46 <Orclev_> pretty rare the type system doesn't catch something like that for you, one of the few cases where you actually can pass the wrong arguments
23:25:42 * hackagebot FilePather 0.2.0 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.2.0 (TonyMorris)
23:26:38 <zeiris> Huh. My project, build as an executable, is 13 megabytes in size. O.o
23:27:08 <zeiris> Is this normal. I'm scared to distribute a 13MB assembler, when others are <50KB :p
23:27:24 <zzo38> zeiris: Haskell programs are always large executables when GHC is used
23:27:39 <zeiris> Are there any viable alternatives to GHC I'm not aware of?
23:27:58 <ChristianS> zeiris: looks like you used *a lot* of dependencies.
23:28:06 <zzo38> There are other Haskell compilers; I don't know how well any of them works
23:29:29 <zeiris> Hm. `strip -p --strip-uneeded --remove-section=.comment` drove it down to 7MB.
23:31:12 <ChristianS> zeiris: yes, strip helps a lot (cabal does it automatically, i think), otherwise you really have to think about whether you need all those dependencies.
23:33:37 <zeiris> ChristianS: I can cheat and use gzexe. It feels kind of dirty to do it with a command line tool, but it's down to 1.8mb.
23:34:37 <zeiris> Yeah, that adds ~230ms to load time :[
23:37:11 <zzo38> If edwardk is still on: I think I have made a datatype which will make a comonad from any MonadLogic.
23:40:31 <zzo38> data Cologic f x = x :| f x; duplicate (x :| y) = (x :| y) :| (msplit y >>= maybe mzero (uncurry f)) where { f h t = mplus (pure (h :| t)) (msplit t >>= maybe mzero (uncurry f)); };
23:42:09 <dmwit> zeiris: You can make it much smaller by building with shared libraries. But if you have to distribute the libraries, too, that won't save you anything.
23:42:22 <dmwit> zeiris: You only save if the other guy happens to have those shared libraries already.
23:42:36 <dmwit> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/using-shared-libs.html
23:44:07 <dmwit> Of course, they'll have shared-library versions of many packages already if they have a GHC distribution, but then you might as well just ship them source. =)
23:50:11 <zzo38> If the Applicative instance for Cofree is not used in any other programs that export Cofree, you should probably change it to the Monad from Alternative and then change the existing one into a wrapper for zipped Cofree? Or should it be done other way around; make a wrapper for the non-zipped version and keep the zipped version as is?
23:50:25 <zeiris> dmwit: thanks. No worries - it'll make selling the thing to users a bit harder (I can imagine the wtf's now :D) but I'll just beat those down with features.
23:51:26 <zzo38> Perhaps easier, I (or anyone else) can make up a wrapper for the Cofree monad from any Alternative
23:52:54 <zzo38> It means, (Cofree Maybe) is like a non-empty list!
