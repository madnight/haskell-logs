00:02:07 <mgsloan> buddhist Haskell:  empty? = const True
00:57:11 * hackagebot test-framework-quickcheck 0.2.8.1 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.2.8.1 (MaxBolingbroke)
01:02:11 * hackagebot test-framework-quickcheck2 0.2.12.2 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.12.2 (MaxBolingbroke)
01:10:51 <ricli85> I would like to write a quick check property that takes a double in the range [0.0, 1.0]
01:10:58 <ricli85> what is the best way to do that?
01:11:38 <ricli85> do I have to create a generator and then use forAll?
01:13:12 <ski> i think one could also use `==>'
01:13:23 <ski> though `forAll' is probably better / more efficient
01:13:48 <ski> (`==>' will generate lots of stuff, and discard the ones which doesn't fit your constraint)
01:14:03 <ricli85> it feels more efficient to generate a number in a specific range instead of generating one and then discarding with ==>
01:14:16 <ski> indeed
01:14:36 <mux> couldn't you generate two random doubles and then divide the bigger one by the smaller one?
01:15:10 <mux> you'd have to handle 0 in some specific way though
01:15:47 <ricli85> that would also be a solution in this particular case
01:16:06 <ricli85> but I find it less direct
01:16:26 <mux> I don't actually know about forAll, so if it allows you to get that directly, it's most likely better
01:16:48 <ricli85> it is easy to create a generator for numbers in a range
01:19:36 <ski> it's probably not harder than writing other (primitive) generators
01:19:50 <ski> probably a call to `randomR' plus something more
01:20:05 * ski doesn't recall how to make a generator (apart from the monadic interface stuff)
01:20:13 <ski> @type randomR
01:20:14 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
01:20:22 <ricli85> I did it like this (not tested though): aPercent = choose (0.0, 1.0)
01:21:20 <ski> > unfoldr (Just . randomR (0,1)) (mkStdGen 945) :: [Double]
01:21:22 <lambdabot>   [0.5077386833745378,5.188013893830945e-5,0.2390292127940406,0.5302260532114...
01:21:45 <ski> yeah, `choose' is probably for this
01:25:17 <ricli85> how can I use forAll if I want to pass two arbitrary values?
01:25:47 <ricli85> do I have to nest forAll calls?
01:28:50 <ski> @type \aGen bGen k -> forAll aGen $ \a -> forAll bGen $ \b -> k a b
01:28:51 <lambdabot> forall a a1 prop. (Show a, Show a1, Testable prop) => Gen a -> Gen a1 -> (a -> a1 -> prop) -> Property
01:29:11 <ski> @type \aGen bGen k -> forAll (liftM2 (,) aGen bGen) $ \(a,b) -> k a b
01:29:12 <lambdabot> forall a1 a2 prop. (Show a1, Show a2, Testable prop) => Gen a1 -> Gen a2 -> (a1 -> a2 -> prop) -> Property
01:30:26 <ski> @type \aGen bGen k -> (`runCont` uncurry k) $ do a <- cont (forAll aGen); b <- cont (forAll bGen); return (a,b)
01:30:28 <lambdabot> forall a a1. (Show a, Show a1) => Gen a -> Gen a1 -> (a -> a1 -> Property) -> Property
01:30:53 <ski> @type \aGen bGen k -> (`runCont` uncurry k) $ liftM2 (,) (cont (forAll aGen)) (cont (forAll bGen))
01:30:54 <lambdabot> forall a1 a2. (Show a1, Show a2) => Gen a1 -> Gen a2 -> (a1 -> a2 -> Property) -> Property
01:31:24 <augur> ski: any new and interesting data structures?
01:31:31 <ski> @type \aGen bGen k -> (`runCont` id) $ liftM2 (return .: k) (cont (forAll aGen)) (cont (forAll bGen))
01:31:33 <lambdabot> forall a1 a2. (Show a1, Show a2) => Gen a1 -> Gen a2 -> (a1 -> a2 -> Prop) -> Gen Prop
01:31:41 <augur> besides continuations, of course :D
01:32:15 <ski> ricli85 : ^ there's a couple of ways
01:32:48 <ski> (probbably you'll want one of the first two ..)
01:33:02 <ski> augur : data structures for doing what ?
01:33:10 <augur> ski: anything!
01:33:22 <augur> ski: tho if you know of interesting data structures for graphs i'd be curious
01:33:24 * ski doesn't really know
01:33:35 <augur> i know about the typical functional graph stuff
01:33:55 <ski> copumpkin was talking about some kind of finite map with different types of keys or something the other day, iiuc
01:34:17 * ski didn't pay very much attention to the discussion at the time
01:34:21 <adamt> If i want to make a datatype that is a string that can only contain certain characters (e.g. A-Z, a-z, -_), how would i go about doing that?
01:35:23 <ski> augur : i don't know very much about existing data structures for graphs .. i only know some things i'd like to be able to do in an ideal graph library
01:36:28 <ski> adamt : make an abstract datatype, make a conversion function to strings, make a partial conversion function from strings, maybe make some interesting combinators
01:37:11 <adamt> ski: Lots of google-worthy phrases, thank you.
01:37:11 * hackagebot svm-simple 0.2.7 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.2.7 (VilleTirronen)
01:37:20 <ski> adamt : one possible implementation would be to make a `newtype' of a string, having the partial conversion function from strings check if the given string satisfies your condition, and if so wrap (otherwise return `Nothing')
01:37:56 <ski> (well, the only more or less technical phrase there was "abstract data type" (ADT), i think ..)
01:38:20 <adamt> ski: Enough to feed into google though. :)
01:39:31 <ski> augur : basically, a graph library should allow one to annotate the nodes and edges of an existing graph -- also, one should be able to encode algorithms like e.g. liveness analysis in a natural way (one shouldn't have to manyally check for cycles, the library should handle that, as long as the operations are assumed to be "idempotent")
01:39:55 <ski> (there's probably other interesting considerations in the creation of a graph library, though)
01:41:06 * ski assumes augur only needs DAGs rather than general graphs, though
01:41:31 <augur> well, for my purposes yes
01:41:37 <augur> but im just looking for interesting ideas :)
01:42:48 <ski> another thing which i'd like a nice answer to is the question of how to do zippers over graphs in a nice way
01:42:56 <ski> especially graphs which can contain cycles
01:43:17 <PointFree> Is there any way to retrieve the precedence of an infix operator?
01:43:37 <ski> (and of course the graphs should be persistant, not ephemeral)
01:43:50 <Saizan> PointFree: :info in ghci
01:43:52 <ski> PointFree : try `:i ++' in GHCi ?
01:44:29 <PointFree> Okay, thanks.
01:49:48 <augur> ski: any interest in AI?
01:50:55 <ski> i'm not exactly sure what falls under AI, but i find several of the specfic ideas and methods interesting
01:51:58 <ski> (e.g. those mentioned in AIMA, or in Ivan Bratko's "Prolog: Programming for Artificial Intelligence")
01:59:06 <PointFree> > ((:) =<< flip div 1 . (8 *) . head) [1]
01:59:08 <lambdabot>   [8,1]
01:59:25 <PointFree> Why doesn't this work on ghci?
02:00:11 <JesusIsLord> caleaskell?
02:00:33 <Botje> PointFree: you need to import Control.Monad.Instances
02:00:34 <JesusIsLord> import Control.Monad.Instances
02:00:42 <Botje> which has the ((->) r ) monad instance
02:00:43 <PointFree> Oh.
02:01:34 <PointFree> ty, Botje.
02:01:55 <Botje> JesusIsLord was not far behind me ;)
02:02:10 <PointFree> Yeah, ty, JesusIsLord, you too!
02:02:39 <PointFree> I wonder why instance Monad ((->) r) isn't in the Prelude... Both Monad and (->) are.
02:03:16 <quicksilver> because it makes for strange error messages, PointFree
02:03:22 <JesusIsLord> that'd make it an orphan instance :) which are discouraged i suppose
02:03:46 <PointFree> Oh.
02:03:46 <Botje> PointFree: "confusion for newbies" was an important factor in deciding what goes in haskell98 and its prelude
02:04:00 <Botje> that's why we can't have nice things^W^Wmonad comprehensions
02:04:04 <quicksilver> if you miss out a paramter you accidentally end up in the (->) monad
02:04:20 <quicksilver> :t do { putStrLn; return 5 }
02:04:21 <lambdabot> forall b. (Num b) => String -> b
02:05:00 <quicksilver> (to be honest the error you get currently isn't that much better :P)
02:06:06 <PointFree> Well, I am a former C++ programmer so I am very used to trying to get things right before getting weird errors spit by the compiler, and I am one among said Haskell newbies...
02:06:52 <Botje> PointFree: I import a few packages into any new haskell file by default
02:07:04 <Botje> Data.List, Control.Monad, Control.Monad.Instances
02:07:12 <JesusIsLord> lol http://kormacode.blogspot.com/2011/11/c-style-haskell_10.html
02:07:34 <PointFree> JesusIsLord: Good Lord, that is ugly.
02:08:17 <JesusIsLord> i'd hide the Prelude's (<) and related functions
02:08:28 <PointFree> Although it is lulzy.
02:13:42 <PointFree> How can I read the source of the instantiation of (=<<) for Monad ((->) r) ?
02:13:58 <Phlogistique> JesusIsLord: pretty nice
02:14:05 <mekeor> PointFree: "(->) a b" is the same as "a -> b".
02:14:23 <Phlogistique> would be good to save something slightly less involved to do this in Hackage
02:14:25 <JesusIsLord> PointFree: look at the source code of Control.Monad.Instances
02:15:32 <Phlogistique> (by less involved I mean less magic, but still with a nicer syntax for writing imperative code)
02:16:21 <Botje> @src (>>=) ((->) r)
02:16:22 <lambdabot> Source not found. Just try something else.
02:16:32 <Botje> uh, boo
02:16:39 <JesusIsLord> @src (>>=) []
02:16:39 <lambdabot> Source not found. My brain just exploded
02:16:43 <JesusIsLord> @src [] (>>=)
02:16:44 <lambdabot> xs >>= f     = concatMap f xs
02:16:50 <JesusIsLord> @src ((-> r)) (>>=)
02:16:51 <lambdabot> Source not found. My pet ferret can type better than you!
02:16:54 <JesusIsLord> ugh.
02:17:05 <JesusIsLord> @src ((->) r) (>>=)
02:17:06 <lambdabot> Source not found. There are some things that I just don't know.
02:17:11 <JesusIsLord> :(
02:17:43 <PointFree> Where are the sources for Haskell's standard modules?
02:17:53 <PointFree> I mean, not the ones online.
02:17:58 <JesusIsLord> the Report defines them, afaik
02:17:58 <PointFree> But the ones in my machine.
02:18:09 <PointFree> Ok, lemme see.
02:19:14 <JesusIsLord> (note that the "real" definitions might be slightly different, but they should be equivalent)
02:20:23 <Peaker> maybe it could be useful to allow a monad annotation to "do", so you could say    do :: IO { ... }     instead of annotating the full type of the result of the do or just one of the statements in it (which may still cause weird errors)
02:20:45 <JesusIsLord> do { return () :: IO (); ... }
02:20:55 <JesusIsLord> if you'd really want it.
02:21:23 <Peaker> JesusIsLord, will it make the errors sane?
02:21:33 <JesusIsLord> i think if you start at the beginning it should mostly work
02:21:33 <PointFree> I hate type annotations.
02:21:40 <Peaker> @src (->) (>>=)
02:21:41 <lambdabot> f >>= k = \ r -> k (f r) r
02:21:45 <JesusIsLord> ah!
02:21:57 <JesusIsLord> ty
02:22:38 <PointFree> wth
02:22:50 <t7> mm_freak: you awake?
02:23:01 <JesusIsLord> PointFree: (->) r is the Reader monad.
02:23:18 <mekeor> @time mm_freak
02:23:22 <JesusIsLord> so it means that every computation in this monad has an "environment"
02:23:35 <JesusIsLord> this "environment" is the value r.
02:23:45 <Peaker> (=<<) :: (a -> r -> b) -> (r -> a) -> r -> b      is very similar to:   (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b             (only flipped)
02:25:13 <PointFree> I would like to know what the data constructors of the type "(->) a b" are.
02:25:26 <JesusIsLord> so \r -> k (f r) r   means: "the value (f r), of type a, gets passed to k to yield another value of type r -> b; to get a b we pass r to it"
02:26:08 <PointFree> It is all really confusing when the same terms are used for both "data values" and "type values".
02:26:13 <mm_freak> t7: more or less
02:26:31 <JesusIsLord> PointFree: you mean the r in this case?
02:26:54 <PointFree> In "\r -> k (f r) r", r is clearly a data value.
02:26:56 <JesusIsLord> i can see why that might be confusing, although it makes for nice shorthand notation
02:27:05 <PointFree> But in "of type r -> b", r is a type value.
02:27:15 <JesusIsLord> yes
02:28:06 <JesusIsLord> you can also write  "data T = T", in fact this is widely done
02:28:35 <JesusIsLord> like data Person = Person { name :: String, age :: Integer }
02:28:42 <t7> mm_freak: i thought about that typing issue as i was falling asleep
02:28:49 <t7> do you need another pass ?
02:29:05 <PointFree> I would not define a new data type just to make it a tuple.
02:29:15 <JesusIsLord> PointFree: I would, why not?
02:29:33 <JesusIsLord> more typing = good
02:29:43 <PointFree> I guess I got *too* sold on the idea that algebraic data types = good.
02:29:47 <JesusIsLord> newtype Kilograms = Kilograms Double
02:29:56 <JesusIsLord> newtype Seconds = Seconds Double
02:30:01 <JesusIsLord> now I can no longer add kilograms to seconds
02:30:24 * ski usually prefers `data Foo = MkFoo ...' if no other sensible data constructor name suggests itself
02:30:40 <Phlogistique> @src \r -> ((->) r) (>>=)
02:30:40 <lambdabot> Source not found. My mind is going. I can feel it.
02:30:43 <JesusIsLord> ski's convention is also widely used, yes. I don't use it myself.
02:31:04 <quicksilver> data Foo = FooFactoryBuilderFactory ...
02:31:09 * PointFree would make lists out of pairs and maybes.
02:31:22 * ski finds that using the same name for the type constructor and the data constructor relatively often confuses newbies
02:33:13 <PointFree> newtype List a = Maybe (a, List a)
02:33:30 <JesusIsLord> you can do that, sure :)
02:33:51 <JesusIsLord> you just need a constructor name
02:34:02 <JesusIsLord> e.g. newtype List a = MkList (Maybe (a, List a))
02:34:12 <JesusIsLord> (newtype is more like "data" than like "type")
02:34:13 <PointFree> Oooooooooh.
02:34:40 <PointFree> I really meant "type".
02:34:42 <PointFree> Buuuuuuuuuut.
02:34:46 <PointFree> It is not legal.
02:35:05 <PointFree> Gawd, why cannot I compute types as easily as I can compute data?
02:36:43 <ski> it doesn't like cyclic types
02:39:05 <PointFree> ski: What's so bad about cyclic types?
02:39:42 <JesusIsLord> i think you can make "infinite types" with them, can't you?
02:40:16 <PointFree> What do you mean by "infinite"?
02:40:58 <JesusIsLord> type T = T, for example
02:41:08 <JesusIsLord> or maybe type T = T -> T
02:41:11 <PointFree> Ohhhhhhhhhhhhhhhhhhh.
02:41:40 <PointFree> "let x = x" madness brought to the type system, right?
02:41:50 <JesusIsLord> otoh you can write newtype T = T T
02:42:09 <augur> usually that cyclic stuff is impossible to typecheck
02:42:28 <PointFree> I would expect that to make the compiler run forever.
02:42:54 <quicksilver> the explicit constructor gives the typechecker an 'anchor' to make type inference possible
02:43:09 <Peaker> PointFree, if you write the Y combinator on top of infinite types (encoded as newtypes) it can cause the compiler to enter an infinite inlining loop
02:43:17 <augur> or at least, infinite types cant type check
02:43:26 <augur> unless you have a fancy type system
02:43:26 <JesusIsLord> yeah there is a pathological example in the GHC manual
02:43:28 <Peaker> (known WONTFIX bug in ghc :) )
02:44:34 <ski> augur : it's not impossible to check (e.g. `ocaml -rectypes' does it) -- but it turns out that it masks many mistakes, inferring strange cyclic types, instead of giving you a type error
02:44:53 <ski> PointFree,quicksilver ^
02:44:53 <augur> ski: yeah, you need a fancier type system!
02:45:12 <augur> ski: if you just have a simple type system. T = T -> T is afaik not possible to type check
02:45:29 <quicksilver> There was one interesting usenet(?) post in which someone demonstrated that every possible variation of a term type checked
02:45:42 <quicksilver> so the type system became completely unable to detect error.
02:45:46 <quicksilver> (under ocaml -rectypes)
02:45:58 <ski> (and O'Caml supports it at all because of their structural typing for OO records while supporting binary and recursive methods -- the `-rectypes' flag enables as well in cases not going through at least one object type)
02:47:56 <ski> Peaker : i assume you've seen roconnor's "Y Combinator in Haskell" <http://r6.ca/blog/20060919T084800Z.html> ..
02:58:57 <Peaker> ski, nope,  I discovered it independently :)
02:59:43 <ski> (well, i meant the `NOINLINE' pragma)
03:01:31 <Peaker> well, I guess it will just behave in that case?
03:01:42 <Peaker> (just as fix, that is)
03:09:30 <bitonic> mm_freak: btw, there are no problems in having indices only
03:09:34 <bitonic> that's what epigram and idris do
03:09:42 <bitonic> but they don't let you specify the universes manually
03:10:00 <bitonic> everything is `Set' but they are cumulative universes behind the scenes
03:10:25 <bitonic> I'm not sure why Agda hasn't followed that path, which seems clearer
03:12:16 * hackagebot MeanShift 0.1 - Mean shift algorithm  http://hackage.haskell.org/package/MeanShift-0.1 (VilleTirronen)
03:13:44 <bitonic> I'm not sure if there are no problems if you specify the universes explicitly, but I don't see why you would
03:19:08 <quicksilver> bitonic: I don't know either but I bet there is a reason :)
03:19:19 <quicksilver> bitonic: (I mean, the agda developers thought about this hard and had epigram to learn from...)
03:20:19 <bitonic> quicksilver: well, one reason I can think of is that maybe you can't have an algorithm to infer polymorphic universes
03:20:57 <bitonic> another thing that I might have misunderstoo is that I'm not sure what a simple `Set' means in agda. maybe it means "try to infer the unverse", but I don't think so
03:21:22 <ziman> isn't that just Set 0 ?
03:21:25 <bitonic> anyways I ask for #agda, but it looks pretty silent for the time being
03:21:31 <bitonic> ziman: yes that's what I knew as well
03:21:36 <mrout> wtf is ->
03:21:55 <Ke> @type (->)
03:21:57 <lambdabot> parse error on input `->'
03:22:01 <bitonic> @kind (->)
03:22:02 <lambdabot> ?? -> ? -> *
03:22:12 <bitonic> mrout: it's the function arrow!
03:22:13 <ziman> at least when I get unresolved level metas, fixing them with (: Set) always works
03:22:14 <Taneb> a -> b means "if you give this function an a, this function gives you a b"
03:22:18 <Taneb> mrout: ^
03:22:27 <shurikas> @kind (<-)
03:22:28 <lambdabot> parse error on input `<-'
03:22:32 <Taneb> Unless it's in a case expression?
03:22:33 <shurikas> :(
03:22:36 <Ke> 1 collect underwear -> 2 ?? -> 3 profit
03:22:44 <bitonic> Taneb: or in a lambda declaration
03:22:48 <Taneb> Ah yes
03:22:52 <shurikas> @type (<-)
03:22:53 <lambdabot> parse error on input `<-'
03:22:57 <shurikas> aww snap
03:23:09 <bitonic> ziman: yes, and I'm pretty sure the tutorial said that Set === Set0
03:23:13 <JesusIsLord> <- is special, shurikas
03:23:23 <shurikas> JesusIsLord, I know you are special
03:23:24 <ziman> shurikas, (<-) is syntax used in the do-notation and view patterns
03:23:34 <JesusIsLord> used for do notation, pattern guards, view patterns
03:23:36 <shurikas> (->) is a syntax as well
03:23:52 <JesusIsLord> shurikas: :)
03:24:05 <bitonic> shurikas: it's also a first class type constructor
03:24:21 <mrout> This makes no sense
03:24:35 <bitonic> well, he didn't let us explain :(
03:40:09 <Saizan> (->) is the name of a type constructor at least
03:40:40 <Saizan> though it's just syntax when appearing in a lambda, e.g. \ x -> x
03:40:48 <liyang> @type (->)
03:40:50 <lambdabot> parse error on input `->'
03:40:54 <liyang> Huh.
03:40:59 <Saizan> @kind (->)
03:41:00 <lambdabot> ?? -> ? -> *
03:41:14 <JesusIsLord> liyang: values have types, types have kinds.
03:41:45 <liyang> JesusIsLord: and kinds have…?
03:42:00 <quicksilver> however, GHC's kind for that type is not very interesting unless you are interested in the details of GHC's implementation.
03:42:08 <quicksilver> * -> * -> * would be a better kind.
03:42:09 <bitonic> sorts
03:42:24 <bitonic> regarding to the type of kinds :P
03:42:26 <liyang> and sorts?
03:42:35 <bitonic> liyang: eeehhhh
03:42:37 <JesusIsLord> liyang: haskell is not dependently typed.
03:42:47 <bitonic> JesusIsLord: that doesn't have much to do with that
03:42:53 <JesusIsLord> yeah, true.
03:42:57 * liyang thinks the names are a bit silly.
03:42:58 <bitonic> for example in PL Omega you can go as high as you want in the tower.
03:43:16 <bitonic> (and it doesn't have dep. types)
03:43:45 <JesusIsLord> "haskell's type system is untyped", what do you think about this statement?
03:44:16 <liyang> Yes. I do think about this.
03:44:52 <quicksilver> JesusIsLord: it is an untrue statement.
03:44:54 <bitonic> JesusIsLord: why would you say that?
03:45:04 <JesusIsLord> bitonic: i heard it somewhere.
03:45:05 <bitonic> JesusIsLord: then the simply typed lambda calculus is "untyped"
03:45:31 <quicksilver> when you type "Maybe Int" you are witnessing the checking within the type system.
03:45:40 <quicksilver> it won't let you use "Int Int" or "Maybe Maybe" as types
03:45:51 <quicksilver> that's the type-level type-checking
03:45:57 <quicksilver> known as 'kind-checking'
03:46:01 <JesusIsLord> yeah. good point.
03:46:33 <bitonic> JesusIsLord: it's actually a much safe type system than the values' type system
03:46:37 <bitonic> *safes
03:46:39 <bitonic> *safer :P
03:47:00 <JesusIsLord> qua re?
03:47:11 <bitonic> JesusIsLord: well you can't have things that inhabit every kind, for once.
03:47:22 <bitonic> while you can have things that inhabit every type
03:47:25 <JesusIsLord> "undefined" does not exist, you mean
03:47:29 <bitonic> JesusIsLord: yeah
03:47:58 <bitonic> types & type classes are strongly normalising (without UndecidableInstances and similar)
03:48:02 <bitonic> well.
03:48:12 <bitonic> it doesn't make much sense to say that "type classes are strongly normalising"
03:48:25 <bitonic> but hopefully you get my point
03:48:52 <bitonic> the type checker will never loop when searching for an instance
03:50:00 <JesusIsLord> Clear. Thanks.
03:51:33 <bitonic> JesusIsLord: UndecidableInstances changes that. In fact with UndecidableInstances the type class system is turing complete!
03:51:51 <liyang> ? and ?? are kind-variables, whereas * is the ground kind. (And # is the unboxed kind.)
03:52:53 <ski> `?' and `??' are not kind variables
03:53:18 <liyang> They're not?
03:53:20 <JesusIsLord> bitonic: I got the Glorious GHC fail to terminate sometime with UndecidableInstances on. :)
03:53:38 <bitonic> JesusIsLord: it has a maximum recursion depth, so it should terminate
03:53:44 <bitonic> but you can write loops
03:53:51 <ski> liyang : see the subkinding hierarchy a bit down at <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes>
03:54:04 <JesusIsLord> bitonic: It terminated, but it did not do what I wanted.
03:54:15 <JesusIsLord> oh well
03:54:15 <bitonic> ski: In some sense they are - they're either * or unlifted types, no?
03:54:25 <bitonic> ski: yeah
03:54:30 <bitonic> I think that's what liyang meant
03:54:41 <liyang> ski: oh.
03:54:42 <ski> bitonic : no, type/kind variables are very different from sub-typing/kinding
03:54:47 <liyang> I'm not sure what I meant now.
03:55:31 <liyang> But that wiki page clears things up, so I'll shut up.
03:55:47 <bitonic> ski: I guess, right
03:56:04 <Eduard_Munteanu> We already have subkinding, AFAICT.
03:56:15 <ski> (btw, it's not clear to me why functions can't take unboxed tuples as arguments ..)
03:58:13 <ski> > (\ (# _ , _ #) -> ()) (# 'a' , 'b' #)
03:58:15 <lambdabot>   Couldn't match kind `(#)' against `??'
03:58:18 <ski> > case (# 'a' , 'b' #) of (# _ , _ #) -> ()
03:58:19 <lambdabot>   ()
03:58:28 <ski> > case (# (# 'a' , 'b' #) , 'c' #) of (# (# _ , _ #) , _ #) -> ()
03:58:30 <lambdabot>   Couldn't match kind `(#)' against `??'
03:58:43 <Eduard_Munteanu> ski: perhaps one is supposed to pass them individually, say as register arguments?
03:59:09 * ski isn't sure what that last one doesn't work
03:59:13 <ski> @kind (# , #)
03:59:14 <lambdabot> ? -> ? -> (#)
03:59:42 <adamt> All i see is a lot of unhappy smiley faces. YMMV.
03:59:42 <ski> Eduard_Munteanu : yeah, but in some cases it might be handy to do `type Blah = (# ... , ... #)'
04:00:02 <ski> it seems nonmodular to have to manually curry
04:00:58 <ski> (Eduard_Munteanu : yeah, which was why i linked to that wiki entry ..)
04:01:07 <Eduard_Munteanu> The manual seems to imply the purpose of unboxed tuples is returning multiple arguments efficiently.
04:01:18 <Saizan> can you erase System F terms into STLC while preserving dynamic semantics?
04:02:02 <Eduard_Munteanu> I guess it just lets you write the return type appropriately, but when you pass them, you have to unpack it.
04:02:12 <bitonic> Saizan: what do you mean with "dynamic semantics", in the context of System F?
04:02:56 <ski> Saizan : maybe using a universal type ?
04:08:06 <Saizan> ski: yes, except functions still need arrow types, but for example id [() -> ()] (id [()]) () would need to be translated to something like (\ (_ : U) (f : U -> U) -> f) (() -> ()) (\ (_ : U) (f : U) -> U) (), assuming both () and (() -> ()) get to be of the universal type U
04:08:51 <Saizan> ski: so it seems the translation is not so modular, it needs to specialize type applications
04:15:16 <bitonic> oh, dynamic semantics simply means how things are evaluated at runtime.
04:15:19 * bitonic hids
04:15:21 <bitonic> *hides
04:39:09 <range_> hi
04:39:18 <JesusIsLord> hi range_
04:40:28 <mekeor> hi
04:42:56 <k-zed> hi all (newbie here)
04:43:18 <k-zed> i wanted to do something like this: data Primitive = Point Float Float | Line Point Point
04:43:31 <k-zed> this doesn't work - i guess because Point isn't a type, it's a data constructor
04:43:45 <k-zed> regardless, what would be the common way to do something like this?
04:44:06 <mauke> data Point = Point Double Double; data Line = Line Point Point
04:44:07 <JesusIsLord> k-zed: you could do a few things
04:44:17 <JesusIsLord> yes, like mauke said
04:44:25 <JesusIsLord> the other route is GADTs, but I think this is clearer
04:44:33 <k-zed> sure, but i won't be able to do things like func :: Primitive -> whatever
04:44:49 <JesusIsLord> data Primitive = PrimPoint Point | PrimLine Line
04:45:18 <k-zed> so then i'll have to use twice-encapsulated data structures to do everything?
04:45:29 <JesusIsLord> in that case, yes.
04:45:47 <k-zed> ok - thanks
04:46:01 <JesusIsLord> you could also done data Primitive a where Point :: Float -> Float -> Primitive PPoint; Line :: Primitive PPoint -> Primitive PPoint -> Primitive PLine
04:46:09 <JesusIsLord> data PPoint; data PLine
04:46:15 <JesusIsLord> but I think that's uglier
04:47:16 <k-zed> hm i don't get that syntax
04:47:31 <JesusIsLord> it's GADT syntax. Don't bother at this moment if you don't know it. :)
04:47:44 <k-zed> ok, full ack :)
04:51:11 <range_> lens are u turk?
04:52:13 <range_> guys 5 : [2,3] results [5,2,3]. how can i do [2,3,5] ?
04:52:28 <JesusIsLord> [2,3] ++ [5]
04:52:45 <JesusIsLord> Note that (++) is slow.
04:53:00 <range_> hm..
04:53:06 <JesusIsLord> It might be better to yield the reverse list, and then reverse at the end.
04:53:16 <JesusIsLord> It depends on what you want to accomplish.
04:53:22 <range_> [1] ++ [1..100]
04:53:28 <range_> it works thanks :)
04:54:11 <JesusIsLord> To be more precise, xs ++ ys is O(length xs)
04:54:19 <fmap> or use data structure that has O(1) right-side appends
04:54:25 <JesusIsLord> like Data.Sequence
04:54:32 <JesusIsLord> or is that O(log n)?
04:54:34 <JesusIsLord> oh well.
04:54:42 <frerich> Hmm, I recently noticed that (&&&) and 'uncurry' can be combined in intersting ways. Like, something like 'length &&& head' yields a nie tuple to feed to 'uncurry replicate'. I wonder - do you people have other useful examples of how to combine those, or maybe other tricks for using 'uncurry'? So far, the function seemed quite useless to me but now I realize that it can actually be really neat.
04:54:56 <range_> reverse (11 : reverse ( [1..10] ) ) i see :)
04:55:43 <quicksilver> frerich: uncurry is a really boring function.
04:55:48 <quicksilver> frerich: tuples are boring, too.
04:56:17 <quicksilver> frerich: but occasionally, if it suits you to use arrow functions to build tuples then, yes, uncurry helps you pass that tuple to a curried function :)
04:57:00 <danr> frerich: you can implement the S combinator with uncurry and &&&
04:57:02 <ski> JesusIsLord : .. it's more that left-associated calls to it are slow
04:57:08 <danr> @type \f g -> uncurry f . (id &&& g)
04:57:09 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
04:57:14 <danr> well, with id and (.) too :)
04:57:22 <JesusIsLord> ski: which is often what happens in practice if you use it in a fold or so
04:57:25 <ski> (and it's not `log', no)
04:57:29 * ski nods
04:57:34 * hackagebot persistent-mysql 0.9.0.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.9.0.2 (FelipeLessa)
04:57:55 <ski> (but `(++)' itself isn't really slow, given the single-linked nature of lists)
04:58:07 <JesusIsLord> yes, it's just how it is.
04:58:52 <frerich> quicksilver: I became aware of this particular combination when reading some blog entry about run-length encoding in Haskell, and somewhere I saw 'encode = map (length &&& head)' and 'decode = concatMap (curry replicate)'. I was pretty much blown away by how short it is :-). It made me wonder, maybe &&& and uncurry can be useful if you want to map a function over something but the function takes two arguments
04:58:52 <frerich>  (and both arguments can be computed for a single given list element). So it's a nicer way of doing 'map (\x -> f (g x) (h x))' or so.
04:59:09 <range_> can we do window applications in haskell?
04:59:11 <frerich> I certainly didn't realize I could've used uncurry in my code so far, maybe I should check whethre it can simplify things...
04:59:20 <ski> range_ : yes
04:59:25 <ski> next question !
04:59:25 <quicksilver> frerich: I think it's a less nice way to do that.
04:59:28 <JesusIsLord> range_: you mean GUI's?
04:59:35 <JesusIsLord> @faq Can we write GUIs in Haskell?
04:59:36 <lambdabot> The answer is: Yes! Haskell can do that.
04:59:37 <quicksilver> frerich: the nicer way is to use zipWith.
04:59:42 <frerich> quicksilver: Err sorry, I meant 'decode = concatMap (uncurry replicate)' of course.
04:59:43 <range_> yes GUI or something that.
04:59:56 <quicksilver> frerich: uncurry helps you if you ended up with a layer of (,) you didn't want, but it's nicer just not to get that layer in the first place.
05:00:04 <range_> in vb.net you can do window applications or console applications
05:00:14 * JesusIsLord is not familiar with VB.NET
05:00:35 <JesusIsLord> If you want to do a GUI application, I think Gtk2Hs is the most common choice.
05:02:04 <range_> @JesusIsLord : Thanks :)
05:02:05 <lambdabot> Unknown command, try @list
05:02:29 <range_> @list
05:02:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:02:33 <k-zed> JesusIsLord: just as a matter of interest: is there any way to do native osx gui in haskell?
05:02:55 <range_> @fact
05:02:56 <lambdabot> I can not handle empty facts.
05:03:37 <JesusIsLord> k-zed: not familiar with OS X development. If you can write them in C, it should be possible using the FFI.
05:03:51 <k-zed> fair enough :)
05:04:02 <JesusIsLord> Using the FFI is not particularly difficult.
05:04:18 <JesusIsLord> However, using Objective-C might be, I don't know that. C++ definitely is a pain.
05:05:06 <k-zed> probably would be easier to just handle data and logic with haskell, and the gui in objc...
05:05:25 <k-zed> anyhow i'm perfectly happy with playing with simple things atm :)
05:06:06 <JesusIsLord> calling Haskell code should be doable as well, as you can call C functions.
05:06:14 <hpc> k-zed: there's cocoa bindings, iirc
05:06:16 <hpc> @hoogle cocoa
05:06:17 <lambdabot> No results found
05:06:17 <quicksilver> k-zed: there have been one or two aborted attempts at haskell-cocoa bindings.
05:06:23 <hpc> oh, :(
05:06:26 <quicksilver> I don't think theyr'e actively maintained.
05:06:37 <quicksilver> k-zed: on the other hand wxwidgets uses native OSX widgets.
05:06:46 <JesusIsLord> isn't wx C++?
05:07:04 <k-zed> it is
05:07:12 <k-zed> but i guess that's more likely to have haskell bindings than cocoa
05:07:22 <hpc> @hoogle wx
05:07:22 * JesusIsLord wonders how that has been accomplished then
05:07:22 <lambdabot> package wx
05:07:22 <lambdabot> package wxAsteroids
05:07:22 <lambdabot> package wxcore
05:07:38 <quicksilver> JesusIsLord: by a (mostly autogenerated) C API wrapper
05:08:10 <hayashi> @pl \x y = flip ( x ) <$> y
05:08:10 <lambdabot> (line 1, column 6):
05:08:11 <lambdabot> unexpected "="
05:08:11 <lambdabot> expecting pattern or "->"
05:08:11 <JesusIsLord> quicksilver: interesting.
05:08:24 <hayashi> lolfail
05:08:29 <hayashi> @pl \x y -> flip ( x ) <$> y
05:08:30 <lambdabot> (<$>) . flip
05:08:44 <JesusIsLord> hayashi: why do you include the parens there?
05:08:54 <hayashi> I have absolutely no ida.
05:09:03 <hayashi> Nor do I have an idea.
05:09:30 <hayashi> I think it's because I quickly mauled that lambda from something where x was originally an infix operator
05:09:44 <hpc> @pl \x f -> ($ x) <$> f
05:09:44 <lambdabot> (<$>) . flip id
05:10:49 <quicksilver> JesusIsLord: http://wxc.sourceforge.net/
05:11:09 <sabrehagen> hi, could somebody explain the => to me in the following syntax? "instance (Card c) => Card (S c) where"
05:11:19 <JesusIsLord> it provides a context
05:11:36 <quicksilver> sabrehagen: it says that "S c" is an instance of Card if the type "c" is.
05:11:39 <JesusIsLord> "whenever c is an instance of Card, here is an instance for S c of Card
05:11:44 <JesusIsLord> "
05:12:21 <JesusIsLord> in the implementation you can use the context Card c
05:12:36 <bitonic> asdf
05:12:39 <bitonic> ops. sorry.
05:12:46 <quicksilver> bitonic: ghjkl
05:12:53 * bitonic shouldn't bash the keyword while thinking.
05:12:56 <sabrehagen> quicksilver, JesusIsLord, i'm having trouble even understanding that. could you doctor the simplest example of where => is present?
05:12:58 <JesusIsLord> QWERTY users, heretics.
05:13:19 <JesusIsLord> sabrehagen: as an example, try Ord a => Ord [a]
05:13:24 <hpc> sabrehagen: newtype Sum a = Sum a
05:13:59 <hpc> sabrehagen: instance Num a => Monoid (Sum a) where mempty = Sum 0; mappend (Sum x) (Sum y) = Sum (x + y)
05:14:00 <JesusIsLord> sabrehagen: compare [] [] = EQ; compare [] _ = LT; compare _ [] = GT; compare (x:xs) (y:ys) = ...
05:14:32 <JesusIsLord> here you use compare x y, which is allowed because of the fact that we assumed that a was an instance of Ord.
05:14:56 <sabrehagen> hpc, i like the look of "newtype Sum a = Sum a" as a simple example, i'm still not sure what's going on there though
05:15:23 <sabrehagen> also, i should say, i'm about three weeks into teaching myself haskell so my knowledge is very basic
05:15:33 <JesusIsLord> sabrehagen: a Num instance has two monoids associated to it, the multiplication monoid and the addition monoid. If you don't know what a monoid is, don't worry.
05:15:37 <hpc> sabrehagen: it defines a Monoid instance for all numeric types, through a wrapper type
05:15:50 <hpc> sabrehagen: in this case, the monoid is (0, +)
05:16:03 <hpc> there's another newtype, Product, with a different monoid (1, *)
05:16:10 <hpc> @src Monoid
05:16:10 <lambdabot> class Monoid a where
05:16:11 <lambdabot>     mempty  :: a
05:16:11 <lambdabot>     mappend :: a -> a -> a
05:16:11 <lambdabot>     mconcat :: [a] -> a
05:16:22 <sabrehagen> JesusIsLord, i don't know what it is, but i guess that won't affect this example. please go on :)
05:17:02 <hpc> sabrehagen: if you just wrote "instance Monoid (Sum a) where mempty = Sum 0; ..." -- it wouldn't compile, because you are using "0" where it expects a fully polymorphic value
05:17:05 <hpc> :t 0
05:17:06 <lambdabot> forall t. (Num t) => t
05:17:24 <JesusIsLord> sabrehagen: if you continue with the Ord [a] example, you can write now compare (x:xs) (y:ys) | x < y = LT; | x > y = GT; x == y = compare xs ys
05:17:30 <hpc> with the (Num a) constraint on the instance, it knows that "a" will always be a Num, and it's legal
05:17:42 <JesusIsLord> sabrehagen: this is the so-called "lexicographical order", also called the dictionary-ordering
05:18:04 <hpc> > "bacon" > "chocolate"
05:18:04 <lambdabot>   False
05:19:22 <yitz> > compare "lambdabot" "preflex"
05:19:23 <lambdabot>   LT
05:19:43 <hpc> haha
05:20:03 <hpc> @let (<=>) = compare
05:20:04 <lambdabot>  Defined.
05:20:29 <hpc> Prelude needs the spaceship operator...
05:23:26 <bitonic> do @lets last forever?
05:23:28 <bitonic> > foo
05:23:29 <lambdabot>   Not in scope: `foo'
05:23:31 <hpc> until @undefine
05:23:33 <bitonic> ok, no
05:23:37 <bitonic> hpc: ah
05:23:57 <bitonic> hpc: are they periodically @undefined?
05:24:01 <hpc> no
05:24:07 <hayashi> @pl \x y -> (f x) `g` (f y)
05:24:07 <lambdabot> (. f) . g . f
05:24:37 <hpc> @pl \i wonder -> "if" `this is a` "parse error"
05:24:37 <lambdabot> (line 1, column 19):
05:24:37 <lambdabot> unexpected "`"
05:24:37 <lambdabot> expecting variable, "(", operator or end of input
05:24:50 <bitonic> hayashi: g `on` f?
05:25:11 <hpc> > (g `on` f) x y
05:25:12 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:25:12 <lambdabot>    `GHC.Show.Show b'
05:25:13 <lambdabot>      a...
05:25:15 <hpc> :(
05:25:20 <ski> bitonic : until lambdabot is restarted, or until someone `@define's them away
05:25:28 <hpc> :t f
05:25:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:25:37 <hiptobecubic> Is there no 'map' function for mutable vectors?
05:25:48 <bitonic> @type \f g -> (. f) . g . f
05:25:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> a -> b) -> f (f b)
05:25:59 <bitonic> @type \f g -> g `on` f
05:26:00 <lambdabot> forall b c a. (a -> b) -> (b -> b -> c) -> a -> a -> c
05:26:26 <hpc> hiptobecubic: try Traversable
05:26:29 <Taneb> hiptobecubic, is there a Functor instance?
05:26:30 <hpc> i think
05:26:51 <hpc> Taneb: Functor doesn't mutate the results
05:27:22 <hpc> and the types don't work out right
05:27:37 <sabrehagen> i'm sorry JesusIsLord, i'm really not following, can you break down the example "Ord a => Ord [a]" again. But as though you're teaching a total beginner :)
05:27:37 <hpc> it's the same reason you can't fmap into an IORef
05:27:51 <JesusIsLord> sabrehagen: no problem.
05:27:56 <JesusIsLord> are you familiar with the Ord type class?
05:27:59 <ski> @type Data.Array.MArray.mapArray  -- maybe this ?
05:28:01 <lambdabot> forall e' e (a :: * -> * -> *) i (m :: * -> *). (Data.Array.Base.MArray a e' m, Data.Array.Base.MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
05:28:12 <sabrehagen> JesusIsLord, i was just trying to research it, and i'm not
05:28:20 <JesusIsLord> sabrehagen: are you familiar with type classes in general?
05:28:21 <ski> (you can `fmap' on `CoYoneda IORef', though)
05:28:41 <hpc> @hoogle (a -> b) -> t a -> f (t b)
05:28:41 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:28:41 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
05:28:42 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
05:28:48 <hpc> @hoogle (a -> t b) -> t a -> f (t b)
05:28:49 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:28:49 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:28:49 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:28:56 <sabrehagen> JesusIsLord, hmmm, let me do some background reading and see if i am. the name isn't ringing any bells...
05:28:57 <hpc> :(
05:28:58 <hayashi> bitonic: thanks muchly
05:29:04 <ski> @hoogle+
05:29:04 <hayashi> exactly what I needed!
05:29:05 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:29:05 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:29:05 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
05:29:09 <JesusIsLord> sabrehagen: ah, then => is going to be difficult to understand.
05:29:16 <hpc> @src Ord
05:29:16 <lambdabot> class  (Eq a) => Ord a  where
05:29:16 <lambdabot>     compare      :: a -> a -> Ordering
05:29:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:29:16 <lambdabot>     max, min         :: a -> a -> a
05:29:25 <JesusIsLord> sabrehagen: read up in your favorite tutorial/book about them
05:29:26 <sabrehagen> JesusIsLord, let me do some type class reading and i'll get back to you
05:29:34 <JesusIsLord> cool
05:30:00 <ski> @type Data.Traversable.traverse
05:30:01 <ski> @type Data.Traversable.mapA
05:30:02 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:30:03 <lambdabot> Not in scope: `Data.Traversable.mapA'
05:30:04 <ski> @type Data.Traversable.mapA
05:30:05 <lambdabot> Not in scope: `Data.Traversable.mapA'
05:30:06 <ski> arg
05:30:08 <ski> @type Data.Traversable.mapM
05:30:09 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:30:45 <hiptobecubic> hmm
05:32:50 <sabrehagen> JesusIsLord, so is "Ord a => Ord [a]" saying that all a's in the list have to be able to be ordered?
05:32:51 <hpc> that probably gives a new vector back instead of mutating the original
05:32:57 <hpc> sabrehagen: yes
05:32:58 <JesusIsLord> sabrehagen: yes
05:33:11 <sabrehagen> great!
05:35:11 <sabrehagen> so returning to "instance (Card c) => Card (S c) where", this would say Card (S c) has to be an instance of (Card C)?
05:35:34 <JesusIsLord> (Card c) is not the typeclass.
05:35:36 <JesusIsLord> Card is
05:35:46 <mauke> no, c has to be an instance of Card
05:35:49 <ski> it says that if `Card c' (if `c' is in class `Card'), then `Card (S c)' (then `S c' is in class `Card')
05:36:01 <hiptobecubic> hpc, well you can't mapM over an immutable unboxed vector it seems
05:36:03 <nru> @src partition
05:36:04 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:36:04 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:36:04 <lambdabot>                               | otherwise = (ts, x:fs)
05:36:14 <nru> why is (ts,fs) made irrefutable?
05:36:18 <hiptobecubic>     No instances for (Monad V.Vector, Data.Traversable.Traversable V.Vector)....
05:36:18 <Taneb> :t (mconcat .) . zipWith compare
05:36:19 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
05:36:40 <Taneb> @quickcheck ((mconcat .) . zipWith compare) == compare
05:36:40 <lambdabot> Unknown command, try @list
05:36:45 <Taneb> @list
05:36:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:36:58 <Taneb> @help check
05:36:59 <lambdabot> check <expr>
05:36:59 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
05:37:07 <Taneb> @check ((mconcat .) . zipWith compare) == compare
05:37:08 <lambdabot>   "*Exception: (==): No overloading for function
05:37:16 <Taneb> @check ((mconcat .) . zipWith compare) = compare
05:37:17 <lambdabot>   Parse error at "=" (column 33)
05:37:21 <bitonic> @check \l -> ((mconcat .) . zipWith compare $ l) == compare l
05:37:23 <lambdabot>   "*Exception: (==): No overloading for function
05:37:27 <nru> @help elite
05:37:28 <lambdabot> elite <phrase>. Translate English to elitespeak
05:37:46 <sabrehagen> JesusIsLord, ski, okay, next question, how can Card have two parameters? (sorry if parameters is the wrong word). The example has the heading "class Card c where". Is this some kind of currying?
05:37:51 <nru> @elite what's elite speak?
05:37:52 <lambdabot> \/\/H4t'z0rz 3LITE SpeAx?
05:37:52 <Taneb> @check \l -> (((mconcat .) . zipWith compare $ l)  :: Int -> Ordering) == compare l
05:37:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:37:53 <bitonic> @check \l r -> (mconcat $ zipWith compare l r) == compare (l :: [Int]) r
05:37:55 <lambdabot>   "Falsifiable, after 9 tests:\n[]\n[1]\n"
05:38:15 <Taneb> @check \l m -> (((mconcat .) . zipWith compare $ l m)  :: [Int] -> [Int] -> Ordering) == compare l m
05:38:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]
05:38:22 <Taneb> @more
05:38:35 <nru> Taneb: you might want to try things in query with lambdabot
05:38:51 <nru> before doing them on the public channel (I'm also guilty of this, though)
05:39:27 <JesusIsLord> sabrehagen: Card does not have two parameters, only one, namely (S c)
05:39:32 <JesusIsLord> S is some kind of data type
05:40:02 <ski> nru : i think to enable consuming an input list that doesn't fit in memory all at once
05:40:02 <sabrehagen> JesusIsLord, haha okay, that makes sense
05:40:54 <ski> sabrehagen : note that the type `[a]' is really syntactic sugar for `[] a' -- here `[]' corresponds to the `S' in the type `S c'
05:41:05 <ski> @kind Maybe
05:41:06 <lambdabot> * -> *
05:41:07 <ski> @kind Either
05:41:08 <lambdabot> * -> * -> *
05:41:09 <ski> @kind []
05:41:10 <lambdabot> * -> *
05:41:19 <hayashi> For an applicative parser for infix operations, is ( parseEnd <* gap ) <**> parseBody <*> ( gap *> parseEnd ) overly cryptic?
05:41:24 <JesusIsLord> it's possible to have multi-parameter-type classes if you enable some extension
05:41:28 <ski> > read "[0,1,2]" :: [] Int
05:41:29 <lambdabot>   [0,1,2]
05:42:31 <ski> nru : iow, to make it incremental, instead of bulky
05:42:43 <sabrehagen> ski, thanks :)
05:43:17 <ski> > let partition p xs = foldr (select p) ([],[]) xs where select p x ~(ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs) in partition even [0 ..]
05:43:19 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
05:43:21 <ski> > let partition p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x = (x:ts,fs) | otherwise = (ts,x:fs) in partition even [0 ..]
05:43:23 <lambdabot>   *Exception: stack overflow
05:43:49 <ski> nru : and an infinite list ^ is of course a list which doesn't fit in memory all at once :)
05:44:45 <hpaste_> Jeanne-Kamikaze pasted “unsafe behaviour” at http://hpaste.org/67869
05:44:52 <nru> ski: oh
05:44:55 <nru> ski: thanks
05:44:55 <Jeanne-Kamikaze> can anyone help explain this :/ ?
05:45:29 <JesusIsLord> Jeanne-Kamikaze: what is the behavior you expected?
05:45:38 <Jeanne-Kamikaze> JesusIsLord, I'm not quite sure
05:45:43 <JesusIsLord> probably inlining
05:46:05 <Jeanne-Kamikaze> inlining the call to foo ?
05:46:21 <JesusIsLord> well you promised that you don't care how often "getLine" is executed.
05:46:51 <Jeanne-Kamikaze> oh
05:47:03 <Jeanne-Kamikaze> true that
05:47:15 <JesusIsLord> you could try {-# NOINLINE foo #-}
05:47:25 <JesusIsLord> but, again, this is not something you can or should rely on
05:47:52 <bitonic> Jeanne-Kamikaze: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Unsafe.html#v:unsafePerformIO
05:47:56 <bitonic>  that explains what to look for
05:49:44 <bitonic> JesusIsLord: but of course you should *never* break referential transparency
05:49:51 <Jeanne-Kamikaze> I see, thanks for the help
05:49:58 <bitonic> apart from those suggestions
05:50:00 <JesusIsLord> bitonic: of course not :)
05:50:07 <Jeanne-Kamikaze> yeah I was just wondering why the behaviour was different
05:50:08 <bitonic> sorry, it was for Jeanne-Kamikaze
05:50:29 <Jeanne-Kamikaze> it's not real life code
05:51:35 <ski> nru : basically, without the `~', the recursive call in `foldr' is forced before the `p x' is checked, meaning that it will partition the list from the end towards the front
05:54:43 <hayashi> Is there a less likely to trip people up way of writing ( parseEnd <* gap ) <**> parseBody <*> ( gap *> parseEnd ), given that parseEnd :: Parser RelationEnd and parseBody :: Parser (RelationEnd->RelationEnd->Relationship)?
05:55:36 <aib> anyone here use Haskell professionally? I've recently started learning; I plan to use it for prototyping non-GUI applications and of course learning a language broadens your horizons, but... I was wondering what the other practical applications were.
05:55:37 <bitonic> hayashi: liftA2?
05:55:45 <hayashi> I like the way that expression captures the exact parse flow and applicative nature of what I'm doing, but I'm getting epically trolled over the complete indecipherability of it to people who haven't been sitting up for hours with Control.Applicative
05:55:46 <JesusIsLord> aib: yes, I have.
05:56:01 <bitonic> hayashi: e.g. liftA2 parseBody (parseEnd <* gap) (gap *> parseEnd)
05:56:17 <aib> JesusIsLord: what did you use it for, if you don't mind me asking?
05:56:23 <JesusIsLord> computational geometry.
05:56:25 <bitonic> hayashi: wait, no.
05:56:34 <JesusIsLord> linear algebra
05:56:35 <yitz> bitonic: no, it appears that the parseBody function is itself created by parsing
05:56:42 <bitonic> why isn't parseBody :: RelationEnd -> RelationEnd -> Parser Relationship?
05:56:44 <nru> > let partition p xs = foldr (select p) ([],[]) xs where select p x xs | p x = first (x:) xs | otherwise = second (x:) xs in partition even [0 ..]
05:56:45 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
05:57:01 <Svarg> are semantics of IORefs defined anywhere? or rather what are the semantics of IORefs?
05:57:05 <nru> right.
05:57:07 <JesusIsLord> for me Haskell has the sweet spot between performance and expressiveness
05:57:19 <yitz> hayashi: if you really mean that, then it is very clear.
05:58:02 <hayashi> bitonic: Mainly due to trying to get everything down in terms of applicative.  Part of me wishes I hadn't now, it took me ages to do and has resulted in arguably heavily less readable code =P
05:58:05 <quicksilver> Svarg: fairly clear, aren't they? a heap of mutable typed cells?
05:58:13 <quicksilver> Svarg: did you have a specific doubt about their semantics?
05:58:59 <yitz> hayashi: your expression says that between the two ends, you parse content that is used to create a function that tells you how to create a Relationship from two ends. is that what you want?
05:59:11 <hayashi> yitz: Pretty much
05:59:18 <bitonic> hayashi: yeah but what you're doing seems odd (generating the function based on what you parse)
05:59:30 <crodjer> Any suggestion for a web framework (mostly to contribute) in haskell?
05:59:30 <Svarg> quicksilver: i'm just wondering whether 2 concurrent writes to an IORef could leave the ref in some undefined state with incomplete data from both writes
05:59:32 <crodjer> I come from a django background, would like to implement some of the ideas from there. My target is basically to brush up my haskell concepts and hopefully improve a web framework.
05:59:44 <bitonic> crodjer: happstack, snap, yesod
05:59:44 <quicksilver> Svarg: nope.
05:59:49 <quicksilver> Svarg: IORef writes are atomic.
05:59:54 <aib> JesusIsLord: something similar here. I don't feel comfortable without a ghci shell around anymore
06:00:01 <Svarg> quicksilver: great - was hoping that's the case
06:00:07 <Svarg> thanks
06:00:08 <hayashi> Basically, if it really is as completely impenetrable as people say, it's supposed to be parsing an infix relationship between two endpoints, taking the operator referred to by the bit parsed in the middle and applying it to the bits that get parsed at both end
06:00:09 <yitz> hayashi: i use applicative parsers all the time but i have never done that. i agree with bitonic that is seems quite an unusual approach.
06:00:09 <hayashi> *ends
06:00:11 <quicksilver> Svarg: (the IORef itself is only a pointer, it can only contain apointer to one value or the either, there is no intermediate)
06:00:26 <JesusIsLord> Jeanne-Kamikaze: the issue i face though with Haskell is lack of bindings to C++ libraries
06:00:33 <Svarg> quicksilver: is this documented anywhere?
06:00:33 <JesusIsLord> er, aib: ^
06:00:56 <nand`> generating a parser based on what you're parsing smells of vulnerabilities due to unexpected inputs
06:00:59 <quicksilver> Svarg: probably not, although it would be documented if anything worse was possible :)
06:01:23 <JesusIsLord> aib: in this respect Python is much nicer.
06:01:39 <JesusIsLord> aib: but Python has the usual disadvantages (slow, typing system)
06:01:46 <aib> JesusIsLord: big typo :p. but it's easy to use C libraries, no?
06:01:55 <JesusIsLord> aib: yes, C is very straightforward
06:02:14 <Svarg> quicksilver: fair enough - i suppose that's good enough, in the worst case i can easily switch to MVars
06:02:16 <yitz> hayashi: you'd usuaaly write something like: applyOp <$> arg <*> opType <*> arg
06:02:21 <hayashi> yitz: admittedly I did come up with the start of this at about 4 in the morning whilst very sleep deprived =P
06:02:38 <bitonic> hayashi: I suggest you post an example of what you're parsing... the usual scheme is f <$> p1 <*> p2 ...
06:02:45 <crodjer> bitonic: I already saw the list and was hoping to find out the youngest and one which has some concepts about implementations in haskell to teach.
06:02:48 <bitonic> where `f' is a non-monadic data constructor of some sort
06:02:49 <aib> JesusIsLord: yeah, the (almost-lack-of-a-) typing system in Python is what turns me off from it
06:03:23 <fryguybob> aib: A sort of extensive answer to your question is in the Haskell Communities and Activities Report.
06:03:26 <fryguybob> @where communities
06:03:26 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Communities_and_Activities_Report
06:03:26 <nand`> for me, it's the emphasis on imperative coding styles
06:03:33 <bitonic> crodjer: uhm. I'm not sure. There's been some activity in terms of FRP development, but I don't know if there is anything usable for real applications
06:03:38 <aib> fryguybob: ah cheers, I'll have a look
06:05:31 <hpaste_> hayashi pasted “Parsing fun” at http://hpaste.org/67872
06:05:53 <bitonic> crodjer: there's `netwire', which is a proof of concept and doesn't work with recent versions of the libraries it depends on
06:05:58 <bitonic> sorry, `webwire'
06:06:03 <hayashi> and yes, I know, the thing I'm working on is a crime against humanity, I blame uni software engineering projects.
06:06:15 <crodjer> bitonic: FRP is for web?
06:06:34 <bitonic> crodjer: it can be applied to web development yes
06:06:48 <bitonic> (I don't have experience personally)
06:07:09 <crodjer> Okay
06:07:27 <Taneb> A MonadPlus is just a Monoid Monad, right?
06:07:40 <crodjer> Seems like snap is also still in its 0.*s, so I will look into that a little.
06:08:46 <bitonic> crodjer: there's plenty to do in Happstack as well, don't be fooled by version numbers :P
06:08:57 <JesusIsLord> Happstack is just older
06:09:05 <bitonic> for example, in Happstack, they're building a new webserver, and they want to replace IxSet with something better
06:09:07 <bitonic> and other stuff
06:09:20 <bitonic> crodjer: http://www.happstack.com/C/ViewPage/7
06:10:58 <crodjer> Okay. Thanks for the info!
06:11:18 <bitonic> crodjer: no problem, you can join the respective channels as well (#happs, #snapframework, and #yesod)
06:11:40 <crodjer> Yes. Sure
06:11:51 <aib> um, is there a sort of introduction to FRP somewhere? http://www.haskell.org/haskellwiki/FRP is a bit lacking in that respect (why do I keep wanting to type "respect"? shouldn't it be "aspect"?)
06:12:01 <hayashi> bitonic: (apologies if you already saw it but) code dump up there --^ (an example string would be "Foo(+Bar[5])--Baz(-Frob[1..*])"
06:12:29 <Svarg> aib: i'd recommend conal's papers
06:12:32 <crodjer> I like the snaplets concepts with snap. From top looks like it might be similar to django apps.
06:12:46 <Svarg> aib: starting with fran, and moving to newer stuff
06:13:42 <efie> "To make x an instance of Num Haskell requires that we also make it an instance of Show and Eq"  - why then it is "class Num a where" and not  "class (Show a, Eq a) => Num a where"? Where do I see that I have to make it an instance of Show and Eq?
06:13:47 <Svarg> aib: frp means different things to different people though, which is unfortunate - there is more than one definition
06:13:51 <JesusIsLord> efie: this is new in GHC 7.4
06:14:20 <Svarg> aib: http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming
06:14:33 <JesusIsLord> efie: but yeah, you would expect the latter if you read that.
06:14:47 <efie> JesusIsLord: So Haskel itself does not demands it?
06:14:50 <mikeplus64> is there a printf for Data.Text?
06:14:56 <JesusIsLord> efie: GHC 7.4 does not demand it anymore
06:15:02 <aib> Svarg: excellent. I already have a few hours' worth of stuff to read. thanks
06:15:33 <Svarg> aib: no problem
06:16:44 <efie> jesusislord: ok thanks!
06:18:13 <efie> Furthermore, I have a question regarding this post: http://stackoverflow.com/questions/10375532/haskell-understanding-no-instance-for-error-messages-in-ghci/10381132#10381132 - I wonder how "instance Show (a -> b) where show f = "<function>"" works. If I call a funciton f, is "<function>" displayed on the screen?
06:18:31 <JesusIsLord> efie: only in GHCi
06:18:48 <JesusIsLord> applying a function to an argument is not affected
06:19:02 <JesusIsLord> it just means that you can write "show f", and get "<function>"
06:19:22 <JesusIsLord> (which is what ghci does for you if you write a value on the prompt)
06:19:35 <Taneb> Hold on
06:19:48 <Taneb> If I change from HashMap and HashSet to Map and Set
06:20:01 <Taneb> It'll be less efficient
06:20:18 <efie> JesusIsLord: but "show (3 3)" prints "0" and not "3 3"
06:20:31 <efie> in WinGHCi
06:20:41 <JesusIsLord> that's correct. what is the type of (3 3) ?
06:21:05 <Svarg> Taneb: depends on what you are doing and how you are doing things
06:21:15 <Taneb> But it will have one less requirement!
06:21:16 <Taneb> Ha!
06:21:17 <Taneb> Haha!
06:21:25 <Taneb> Svarg, they're storing strings
06:21:27 <Botje> JesusIsLord: can we assume an arbitrary Integral (a -> b) instance? :o)
06:21:42 <Svarg> Taneb: that doesn't say much
06:21:43 <JesusIsLord> Botje: the context is a stack overflow post.
06:21:54 <Botje> oh. boo.
06:22:08 <JesusIsLord> Botje: so there is an instance (Integral a, Integral B) => Num (a->b)
06:22:15 <JesusIsLord> lowercase b there
06:22:24 <Taneb> Svarg, HashMap String String and HashSet String. The Strings are put in by users and are arbitrary
06:23:04 <efie> JesusIsLord: I dont know, how do I get ghci to print "<Function>" on the screen?
06:23:22 <JesusIsLord> let f x = 37 x in f
06:23:22 <ski> JesusIsLord : you don't need `Integral a', no ?
06:23:58 <Taneb> The HashSet will contain URLs and names of Censuses and marriage records etc
06:23:59 <JesusIsLord> ski: the implementation is somewhat peculiar; it uses modular arithmetic instead of the standard pointwise definitions
06:24:03 <Taneb> The HashSet is more arbitrary
06:24:25 <ski> JesusIsLord : hm, where is this from ?
06:24:32 <JesusIsLord> http://stackoverflow.com/questions/10375532/haskell-understanding-no-instance-for-error-messages-in-ghci/10381132#10381132
06:25:42 <ski> JesusIsLord : oh, i see
06:26:32 <efie> "let f x = 37 x in f" I don't get this.. f is of type  a -> Int a?
06:26:49 <JesusIsLord> efie: you can ask ghci. :t let f x = 37 x in f
06:27:29 <mm_freak> t7: if you have a solution, i'd be happy to learn
06:27:36 <efie> ah, ok
06:28:02 <bitonic> mm_freak: did you read my previous messages about indices/parameters?
06:28:14 <ski> JesusIsLord : actually, i don't see why it uses `mod' in `fromInteger', but nowhere else ..
06:28:41 <mm_freak> bitonic: not sure
06:28:52 <JesusIsLord> ski: i'm not sure, it's a bit weird.
06:29:03 <JesusIsLord> ski: the usual thing to do would be fromInteger = const
06:29:23 <efie> ski: because the one who asked the question asked for it
06:29:29 <efie> in a comment below
06:29:32 <t7> mm_freak: just check the type after typing the whole thing, if its a Pi then its a Set
06:29:52 <t7> im not sure if thats the most elegant way todo it
06:30:15 <bitonic> mm_freak: http://tunes.org/~nef/logs/haskell/12.04.30 , at 03:09:30
06:30:15 <ski> JesusIsLord *nod*
06:30:39 <hiptobecubic> When i use -prof it sometimes doesn't report how much time is spent in each function, but it DOES report the memory allocation. For time it will say something like "0 ticks @ 20ms", which is clearly false because -RTS -sstderr says it took 178 seconds
06:30:43 <mm_freak> t7: how does that solve the problem?  remember:  the problem is that the type checker infers the wrong type, not that it accepts a wrong type
06:31:27 <t7> yeah because i was typing to Pi before i typed the whole expression
06:31:41 <t7> typing the Pi *
06:31:44 <mm_freak> bitonic: thanks…  my problem isn't about universes at all
06:31:58 <hiptobecubic> compiling with  "ghc --make -prof -auto-all -caf-all -fforce-recomp -rtsopts optionModel"
06:32:30 <t7> that might not make any sense
06:32:45 <mm_freak> t7: i'm not sure what you mean…  my problem is specifically related to de bruijn indices
06:33:24 <bitonic> mm_freak: well, but the anwer to "what do we lose by unifying indices and parameters" is probably "not much"
06:33:28 <mm_freak> the same code with names worked perfectly…  i just updated it to work with indices instead, and now it goes crazy
06:35:14 <hiptobecubic> switching to data.vector was pretty godly as far as speed goes, but it's still not C competitive yet. I'm hopeful though, I just don't have a very good relationship with ghc yet i guess
06:35:58 <mm_freak> t7: do you mean to discover the function type using a specialized algorithm?
06:36:12 <hiptobecubic> I think it's spending all of it's time allocating and reallocating memory :/
06:36:42 <t7> mm_freak: yeah like another pass
06:36:56 <hiptobecubic> GC % is very low, but it says it's allocating something like 100MB/s
06:37:48 <mm_freak> hiptobecubic: you have to make smart choices between boxed and unboxed vectors
06:38:08 <mm_freak> boxed vectors can be constructed in very interesting ways
06:38:26 <mm_freak> t7: so you think the problem isn't related to indexing?
06:38:44 <t7> im not sure now...
06:38:59 <t7> mm_freak: is there no typing rules for coc?
06:39:10 <t7> im not even 100% on the semantics
06:39:49 <mm_freak> t7: i don't think so…  as said, the same code worked perfectly with names
06:44:36 <mog_> I was wondering... is there an already existing standard function zipWithN that takes a binary operation, a list of N elements, an applies the binary operation in a successive manner to the nth elements of the list at each step to get a resulting nth element? Sounds it'd be very useful
06:44:53 <mog_> and each time I think something would be useful it almost certainly already exists so I thought I'd ask
06:45:42 <mm_freak> mog_: it doesn't exist, but it's easy to write
06:45:43 <Botje> do you apply it only to the two adjacent elements?
06:45:48 <mm_freak> you're just mapping a foldl
06:46:05 <mm_freak> map . foldl (+) 0
06:46:06 <Botje> or do you reuse the results of the earlier results as well
06:46:30 <mm_freak> well, it's a zip, so i guess the results are mutually unrelated
06:46:47 <mog_> well for example in zipWith (*) [[1, 2], [3, 4], [5, 6]] it'd be [1*3*5, 2*4*6]
06:47:14 <mm_freak> > map . foldl (*) 1 . transpose $ [[1, 2], [3, 4], [5, 6]]
06:47:15 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
06:47:24 <mm_freak> > map (foldl (*) 1) . transpose $ [[1, 2], [3, 4], [5, 6]]
06:47:25 <lambdabot>   [15,48]
06:47:29 <mog_> yup with a transpose it's fine
06:47:31 <mog_> you're right :)
06:48:29 <mog_> thanks for the input!
06:48:53 <mm_freak> in practice you'll most likely want to use foldl' instead of foldl
06:49:41 <mog_> yup I already ran into some bad bad bad thunks so now I'm paying attention to this difference : ]
06:57:28 <ppilate> Hi
06:57:36 <Svarg> hi
06:57:38 <ppilate> can somebody please explain 'seq' to me?
06:57:51 <ppilate> How is it being used?
06:58:03 <JesusIsLord> seq is a magical function
06:58:09 <Botje> it evaluates its first argument up to the first constructor, then throws it away and returns its second argument.
06:58:13 <JesusIsLord> seq x y is bottom if x is bottom, and y otherwise
06:58:22 <Botje> it's typically used to prevent buildup of unevaluated thunks
06:58:27 <Svarg> x `seq` y will force the evaluation of x and return y
06:58:47 <ppilate> > (print "test" `seq` 1)
06:58:48 <lambdabot>   1
06:58:52 <JesusIsLord> ppilate: no no no!
06:58:57 <JesusIsLord> evaluation is not executation!
06:58:57 <ppilate> ok, well
06:59:09 <JesusIsLord> print "test" is not *executed*; it is *evaluated*
06:59:09 <ehamberg> > [undefined] `seq` 1
06:59:10 <lambdabot>   1
06:59:16 <ppilate> then why would you use it?
06:59:26 <JesusIsLord> ppilate: to prevent thunks from building up.
06:59:31 <JesusIsLord> ppilate: for example, consider
06:59:37 <JesusIsLord> > foldl (+) 0 [1..1000]
06:59:38 <lambdabot>   500500
06:59:41 <JesusIsLord> > foldl (+) 0 [1..10000]
06:59:42 <lambdabot>   50005000
06:59:43 <JesusIsLord> > foldl (+) 0 [1..100000]
06:59:44 <lambdabot>   5000050000
06:59:46 <JesusIsLord> > foldl (+) 0 [1..100000000]
06:59:50 <lambdabot>   mueval-core: Time limit exceeded
06:59:51 <bitonic> ppilate: with "force the evaluation" they mean "force the first constructor", which is not what you might expect
06:59:55 <JesusIsLord> > foldl' (+) 0 [1..100000000]
06:59:59 <lambdabot>   mueval-core: Time limit exceeded
07:00:04 <JesusIsLord> oh well
07:00:23 <nand`> > x `seq` x where x = 1+2
07:00:24 <lambdabot>   <no location info>: parse error on input `where'
07:00:37 <JesusIsLord> nand`: that's not an expression, use let
07:00:58 <Svarg> > let x = x in 3
07:00:59 <lambdabot>   3
07:01:00 <nand`> > let x = 1+2 in x `seq` x
07:01:02 <lambdabot>   3
07:01:04 <Svarg> > let x = x in x `seq` 3
07:01:08 <lambdabot>   mueval-core: Time limit exceeded
07:01:25 <nand`> (this would evaluate 1+2 even if nothing uses the returned value afterwards)
07:01:51 <ppilate> ah, so it forces lazy evaluations ?
07:02:03 <t7> can someone build OpenAL on windows for me from hackage :3
07:02:09 <t7> i dont have msys at work
07:02:29 <Svarg> well it causes a lazy thunk to be evaluated - forces strictness
07:03:41 <ppilate> I see, thanks
07:04:00 <ppilate> can you give me some concrete examples, please?
07:04:24 <ppilate> Why would you want to evaluate a lazy thunk at the specific place
07:04:33 <ppilate> erm, in the specific code section
07:05:57 <nand`> concrete example: foldl';
07:06:02 <nand`> -;
07:06:36 <t7> is there any kind of audio output stuff in the haskell platform?
07:06:37 <Svarg> ppilate: consider what happens behind the scenes when you write 1 + 2 + 3
07:06:51 <bitonic> ppilate: this gives a lengthy explanation: http://book.realworldhaskell.org/read/profiling-and-optimization.html
07:07:34 <Lemmih> t7: Not sure. But there are Haskell bindings to both SDL and OpenAL.
07:07:34 <Svarg> ppilate: you don't get 6, at least not right away - instead you get a thunk, that adds 1 to another thunk, that adds 2 and 3
07:07:47 <t7> Lemmih: i cant build them :|
07:07:54 <nand`> foldl (+) 0 [1,2,3,4] evaluates down to ((1+2)+3)+4 before (3+3)+4 before 6+4 before 10; foldl' (+) 0 [1,2,3,4] evaluates down to (3+..) to (6..) to 10 right away
07:08:10 <Lemmih> t7: Using Windows?
07:08:14 <t7> yeah
07:08:22 <mm_freak> t7: i may have found the problem
07:08:48 <Svarg> ppilate: this requires some additional processing to construct, and then takes up more space than the result of the computation would take up by itself
07:08:50 <mm_freak> TcResult (A : Set) → (A → A) → A → A
07:08:50 <mm_freak> \(A : Set) (x : A → A) → x
07:09:03 <mm_freak> seems to work =)
07:09:12 <JesusIsLord> zomg agda
07:09:38 <mm_freak> JesusIsLord: no agda
07:10:01 <ppilate> ah, thanks nand`
07:10:05 <mm_freak> t7: no, i was overenthusiastic…  it doesn't solve the problem…  it just solves this instance of it
07:10:13 <t7> bah :p
07:10:47 <t7> are you sure thats even the right type?
07:12:04 <mm_freak> very sure, but let me verify
07:12:40 <t7> ah yeah
07:12:42 <t7> thats right
07:13:13 <mm_freak> t7: verified
07:17:07 <wtfcurry> If I make a function chain like this Are(You(Idiot)) out of "Are you idiot". Is that currying?
07:17:44 <mm_freak> wtfcurry: in currying application is left-associative
07:17:54 <mm_freak> so:  (Are You) Idiot ;)
07:18:43 <wtfcurry> mm_freak: so the conversion I did cannot be called currying?
07:18:56 <mm_freak> no
07:19:12 <wtfcurry> So thats whats called chaining?
07:19:38 <nand`> there's nothing that states currying has to be left associative; in a couniverse our colambdas might as well be right associative
07:19:49 <Svarg> wtfcurry: in what context?
07:19:58 <mm_freak> yeah, it's just chaining:  Are (You Idiot) = (Are . You) Idiot
07:20:26 <nand`> Are $ You $ Idiot using Haskell's ($) operator
07:20:33 <mm_freak> nand`: i don't know what the corresponding colambda calculus would look like =)
07:20:49 <nand`> mm_freak: don't worry; you'd need a cobrain to understand it
07:20:56 <mm_freak> hehe
07:20:59 <nand`> not to be confused with a coprocessor
07:21:13 <nand`> (alternatively, edwardk)
07:21:19 <mm_freak> no worries, nobody has a coprocessor these days
07:21:47 <sray> hi, i am always forcing myself change my code {a<-foo;b<-bar a ; return (fooooo b) } to {b<-foo>>=bar; return (foooo b)}. which is true: the later can run faster OR to compiler (with -O ) the two pieces of code are the same
07:21:48 <Svarg> unless you count gpu-s
07:21:49 <nand`> I thought the FPUs were still referred to as coprocessors
07:22:18 <mm_freak> you know…  there are chuck norris fight-jokes and bruce schneier crypto-jokes…  where are the edward kmett categorical jokes? ;)
07:22:19 <nand`> and don't the shiny new processors these days have sort of integrated GPUs as well
07:23:05 <nand`> good question; unfortunately I don't know enough about categories and humor to contribute
07:23:14 <Botje> sray: it's exactly the same.
07:23:24 <Botje> sray: so it comes down to style.
07:23:31 <mm_freak> nand`: well, you could start with comathematicians and ffee
07:23:43 <nand`> sray: why not foooo <$> foo <*> bar
07:23:44 <mm_freak> @quote comath
07:23:45 <lambdabot> No quotes match. Wrong!  You cheating scum!
07:23:52 <sray> thx
07:24:03 <nand`> wait
07:24:16 <mm_freak> @remember Comathematicians turn cotheorems into ffee.
07:24:17 <lambdabot> I will remember.
07:24:20 <nand`> foooo <$> (foo >>= bar)
07:24:25 <nand`> but that's just as ugly
07:24:28 <Botje> mm_freak: *groan*
07:24:44 <sray> { foo>>= bar>>= return.fooooo } like this ?
07:25:03 <mauke> mm_freak: you have failed
07:25:22 <mauke> @forget Comathematicians turn cotheorems into ffee.
07:25:22 <lambdabot> Done.
07:25:40 <nand`> ffee?
07:25:47 <mm_freak> i know it's old, but it should be recorded somewhere for reference =)
07:26:10 <mauke> but not as "Comathematicians says: turn cotheorems into ffee."
07:26:13 <nand`> sray: spaces are cheap!
07:26:20 <nand`> apart from that it looks like it should type check fine
07:27:39 <mm_freak> mauke: oh
07:28:04 <mm_freak> although if you replace . by ! it would work =)
07:30:30 <mm_freak> nand`: foo >>= fmap foooo . bar
07:32:55 <nand`> fmap fooo . bar =<< foo
07:32:57 <nand`> same order
07:33:42 <sray> nand`: well for me space is cheap, but time is expensive. i just hoping i can run the gc fewer times.
07:34:11 <EvanR> meh just dispense with the gc and use infinite space
07:34:20 <nand`> sray: I meant spaces as in literal space characters, not space as in memory :)
07:34:50 <nand`> “foo>>= bar>>= return.bat” is a lot uglier than “foo >>= bar >>= return . bat”
07:35:28 * hayashi is sure he's already PL'd this today, but
07:35:47 <hayashi> @pl f x -> f <$ g x
07:35:47 <lambdabot> (line 1, column 5):
07:35:48 <lambdabot> unexpected ">" or "-"
07:35:48 <lambdabot> expecting variable, "(", operator or end of input
07:35:55 <hayashi> nyoron, forgot the \
07:35:58 <hayashi> @pl \f x -> f <$ g x
07:35:58 <lambdabot> (. g) . (<$)
07:36:04 <hayashi> I'm having one of those days.
07:36:24 <bitonic> hayashi: I'd stop worrying about pl'ing everything and just hoogle the needed combinator :P
07:36:39 <bitonic> and/or ask here
07:37:18 <t7> http://blog.tmorris.net/20-intermediate-haskell-exercises/   is excersize 3  furry = (.)  ?
07:37:46 <hayashi> well, generally I find pl's usually the best first step for if I'm having a brainfart and all I need is a basic combinator, and usually comes in with some comic relief if something more expressive is what I'm looking for =P
07:37:52 <Botje> t7: yes.
07:38:47 <byorgey> hayashi: heh, fair enough =)
07:40:25 <bitonic> hayashi: yeah pl is quite entertaining
07:40:39 <bitonic> hayashi: but I'd always stop if you need to section .
07:47:42 <hayashi> bitonic: don't worry, I had no intentions of using (. g) . (<$) =P
07:48:01 <mm_freak> t7: i found it! =)
07:48:13 <t7> huzzah
07:48:33 <mm_freak> checkLam ctx (Lam (nfExpr -> t) x) = do tx <- check (fmap (mapFree succ) $ t <| ctx) x; return (t :-> tx)
07:48:42 <mm_freak> the "fmap (mapFree succ)" is the important part
07:49:03 <mm_freak> for the recursive check of x you need to increment all free variables in the context by 1
07:49:12 <t7> ah ok
07:49:15 <t7> why is that?
07:49:28 * hayashi wonders if naming a function (>>-->) is going too far
07:49:42 <t7> because getting rid of the lambda?
07:49:44 <JesusIsLord> not at all :)
07:49:57 <bitonic> hayashi: proper arrows, not like >>>!
07:50:00 <mm_freak> the reason is that for each instance of Pi you add one reference layer
07:50:11 <t7> ah ofcourse
07:50:19 <byorgey> ugh, de Bruijn =P
07:50:44 <byorgey> this is exactly why locally nameless is so much better
07:50:54 <mm_freak> my problem was that i only incremented the indices of the topmost item on the context stack, but the type of x can refer to earlier items on the stack, too
07:51:16 <mm_freak> byorgey: well, wouldn't locally nameless run into the same issue?
07:51:23 <byorgey> mm_freak: no, it wouldn't.
07:51:31 <mm_freak> byorgey: is there a paper about it?
07:51:45 <byorgey> mm_freak: because with locally nameless, free variables are represented by names, not indices
07:51:45 <mm_freak> or a tutorial?
07:52:03 <mm_freak> byorgey: ah, i see
07:52:16 <mm_freak> but isn't substitution then more difficult?
07:52:31 <byorgey> no, not really
07:52:43 <mm_freak> ok, i have to go now…  i'll give it a shot when i return
07:52:54 <byorgey> mm_freak: read "I am not a number -- I am a free variable" by McBride + McKinna
07:53:07 <mm_freak> locally nameless means this:  data Name = Free Text | Bound Index;  Var :: Name -> Expr
07:53:10 <mm_freak> right?
07:53:24 <byorgey> yes
07:53:28 <mm_freak> ok, thanks
07:53:53 <Svarg> mm_freak: out of curiosity, what are you working on?
07:54:01 <mm_freak> Svarg: a dependently typed core language
07:54:01 <Svarg> a new dependently typed language?
07:54:05 <Svarg> ah cool :)
07:54:15 <mm_freak> something like pisigma
07:54:20 <Svarg> interesting
07:55:13 <mm_freak> byorgey: anyway, i'm happy to have made this experience =)
07:55:32 <mm_freak> it showed me why pure de bruijn is not a cure, just a different problem =)
07:55:35 <fmap> ct
07:55:41 <fmap> sorry (
07:55:55 <Svarg> mm_freak: have you seen the blog on name binding?
07:56:01 <byorgey> mm_freak: indeed, it's hard to appreciate good solutions without really understanding the problems =)
07:56:23 <mm_freak> Svarg: which one of the hundreds of them? ;)
07:56:25 <Svarg> mm_freak: http://namebinding.wordpress.com/
07:56:28 <mm_freak> ah
07:56:29 <quicksilver> byorgey: a very important observation.
07:56:40 <byorgey> mm_freak: also (shameless plug) you may be interested in http://hackage.haskell.org/package/unbound
07:56:55 <quicksilver> byorgey: that's one reason monads can be hard to appreciated (they're a solution to a problem many people haven't appreciated)
07:56:59 <mm_freak> Svarg: thanks for the pointer…  i'll bookmark it
07:57:03 <byorgey> quicksilver: yes, good point.
07:57:21 <Svarg> mm_freak: have a look at robert atkey's unembedding domain specific languages if you haven't seen it already
07:57:50 <yitz> quicksilver: yes, applicatives can do just about everything we need
07:58:04 <Svarg> i found playing with de bruijn indices much easier after reading through that
07:58:55 <quicksilver> byorgey: I happened to learn about monads just a few months after implementing ML parsing following the example in Paulson's book
07:59:17 <quicksilver> byorgey: so I immediately had a problem in my head they fitted.
07:59:34 <byorgey> quicksilver: I'm not familiar with that book, but makes sense
07:59:54 <quicksilver> byorgey: examples towards the end of http://www.cl.cam.ac.uk/~mjcg/Lectures/FuncProg/www/intro-fp/parse.ML
08:00:10 <byorgey> honestly I don't remember when or why I learned about monads.
08:00:25 <bitonic> oh that big green book is nice. the other example (the tactical theorem prover) is nice as well
08:00:40 <quicksilver> they end up with a combinator which embeds everything into tuples
08:00:57 <quicksilver> since they don't have ">>= \x ->" as a way to name the results of sub-parts
08:01:24 <quicksilver> then they have to fmap things via tupple destructors like ">> (fn ((_,p),_) => p)"
08:01:33 <quicksilver> where >> is fmap.
08:01:34 <byorgey> ah, yes, I see
08:01:59 <t7> im stuck on 6 :*(
08:02:07 <t7> i have banana id . banana
08:02:12 <byorgey> oh, and failure is handled by throwing exceptions
08:03:42 <t7> @hoogle Monad m => (a -> b) -> (m a) -> (m b)
08:03:44 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
08:03:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
08:03:45 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
08:03:54 <bitonic> t7: also known as `fmap'.
08:04:18 <mauke> bitonic: no, liftM
08:04:33 <byorgey> t7: you can't apply banana to something of type  (a -> b), since banana requires  (a -> m b)
08:04:46 <bitonic> mauke: fmap = liftM, apart from type-classes constraint annoyances
08:04:50 <t7> i can do a join with banana id
08:04:53 <bitonic> (but I'm sure you knew that)
08:04:54 <t7> right?
08:04:56 <mauke> bitonic: specifically liftM because it needs to be defined in terms of return/>>=
08:04:58 <byorgey> t7: indeed
08:05:18 <t7> furry' f x = banana id $ banana f x   should work in my world
08:05:18 <bitonic> mauke: I don't follow you
08:05:37 <mauke> or banana/unicorn as they're called here
08:05:37 <byorgey> t7: you don't need that for this exercise, however.
08:05:50 <bitonic> mauke: ah, you're referring to the specific exercise
08:06:31 <byorgey> t7: no, because furry' must work for f having *any* type  (a -> b),  and applying banana to it will only work if it is of the form  (a -> m b)
08:06:32 <t7> i must need a join
08:06:38 <mauke> :t \f x -> (>>=) id $ (>>=) f x
08:06:40 <lambdabot> forall a b a1. (a -> a1) -> (a1 -> a -> a -> b) -> a -> b
08:06:52 <mauke> d'oh
08:07:07 <mauke> :t \f x -> (>>= id) $ (>>= f) x
08:07:08 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> m (m b)) -> m a -> m b
08:07:42 <t7> byorgey: do you know the answer? (dont tell me)
08:07:46 <byorgey> t7: I do.
08:07:58 <mauke> join goes the wrong way
08:08:38 <byorgey> t7: you are right that banana id = join.  But the solution does not use (or need) join.
08:08:45 <t7> haha that was easy
08:08:50 <t7> im such amuppet some times
08:09:10 <t7> @pl \f -> banana (\x -> unicorn (f x))
08:09:11 <lambdabot> banana . (unicorn .)
08:09:35 <byorgey> that's it =)
08:10:00 <byorgey> I would write  \f -> banana (unicorn . f)
08:10:05 * tgeeky now assumes that unicorn horns are actually bananas.
08:10:28 <byorgey> furry bananas.
08:10:39 <EvanR> horny furry bananas
08:14:09 <hpaste_> Mog pasted “Infinite type problem” at http://hpaste.org/67880
08:14:35 <luite> tgeeky / t7: better watch out with those bananas/horns http://www.youtube.com/watch?v=ddgAkaeMavQ
08:14:58 <luite> if you're a muppet :p
08:15:39 <byorgey> mog_: can you please paste the error message as well?
08:15:55 <napping> you're trying to end up with infinitely nested lists
08:15:59 <mog_> huh, I didn't post the question yet!
08:16:06 <byorgey> mog_: oh, ok =)
08:16:07 <mog_> nice bot =)
08:16:44 <hpaste_> Mog annotated “Infinite type problem” with “Infinite type problem (annotation)” at http://hpaste.org/67880#a67881
08:16:58 <mog_> ok I attached the error
08:17:08 <byorgey> mog_: what is lists2tree supposed to do?
08:17:22 <mog_> It's supposed to recursively merge tails whose heads are the same
08:17:36 <mog_> under the forml (head, tail)
08:17:38 <mog_> at each step
08:17:38 <napping> you have to use a type like Data.Tree if you want that sort of thing
08:17:45 <byorgey> mog_: so what should be the output of  lists2tree [["x", "y"], ["x", "z"]] ?
08:17:57 <byorgey> mog_: I suspect you are trying to use lists for something they cannot be used for
08:18:21 <mog_> it would be [(x, [(y, []), (z, [])])]
08:18:34 <mog_> I'll look into the Tree type, thanks :)
08:18:46 <napping> and you want a result type like mu Tree. [(String,Tree)] ?
08:18:51 <byorgey> mog_: yeah, you can't do that.  because the depth is not fixed.
08:18:59 <byorgey> (you can't do it with lists that is)
08:19:06 <mog_> but it stops, so I thought it was fine : ]
08:19:39 <byorgey> mog_: the problem is that you cannot give  [], [(x, [(y, [])]], and [(x, [(y, [(z, [])])])]  all the same type
08:19:56 <mog_> oh, I see
08:20:05 <mog_> that makes sense :)
08:20:16 <byorgey> mog_: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
08:20:18 <napping> or that you can, but it turns out to not be a good idea to infer types like that
08:20:40 <napping> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020074.html
08:20:56 <mog_> thanks for the pointers, it's appreciated :)
08:21:06 <byorgey> well, OK, those particular three values you CAN find a common type for.  The point is that if you do not know in advance how deep it will go, the type has to be infinite.
08:21:31 <napping> O'Caml actually handles infinite types as part of the class system, but usually requires you have an object involved
08:21:42 <mog_> ok
08:22:16 <napping> the message I linked to gives some examples where infinite types allow bogus programs
08:22:36 <mm_freak> yeehaa…  finally my dependent application operator typechecks =)
08:22:38 <mm_freak> TcResult (A : Set) → (B : A → Set) → ((x : A) → B x) → (x : A) → B x
08:22:41 <mm_freak> \(A : Set) (B : A → Set) (x : (x : A) → B x) (y : A) → x y
08:25:53 <t7> banana f g y = f (g y) y
08:26:00 <t7> what good is that
08:26:12 <mm_freak> t7: that's flip (<*>)
08:26:47 <mm_freak> so it's a flipped S combinator
08:27:05 <t7> i thought it looked like an S combinator
08:30:01 <dgpratt> mm_freak: whaddya think this is? #agda? ;-)
08:31:00 <t7> next step universes
08:31:00 <mm_freak> dgpratt: it's my own language implemented in haskell…  i'm currently experimenting with various approaches to implementing CoC
08:31:09 <t7> then universe polymorphism
08:31:15 <mm_freak> t7: no, nest step is locally nameless
08:31:16 <t7> then termination checking
08:31:22 <dgpratt> mm_freak: !!
08:31:40 <mm_freak> and i'll do universe polymorphism right away, i see no need to start with universes
08:31:49 <napping> locally nameless worked pretty well for me, at least with a much simpler language
08:32:16 <dgpratt> mm_freak: not that I really understand any of it, but this bit looks esp. strange: (x : (x : A) → B x)
08:32:23 <dgpratt> (to me)
08:32:43 <t7> that looks like a Show error?
08:32:51 <mm_freak> dgpratt: A : Set, B : A -> Set
08:33:02 <mm_freak> it's not a show error…  the outer x is a different one
08:33:27 <dgpratt> mm_freak: oh, different 'x', I see
08:33:29 <t7> are doing chr on your indexes?
08:33:34 <t7> lazy :)
08:33:36 <napping> should have used DeBruijn syntax in the concrete syntax too :)
08:33:39 <mm_freak> t7: ?
08:35:03 <t7> types are such an awesome thing
08:35:32 <t7> i just wanna evangelise to all the ruby and python coders... on reddit... because i know they dont like it
08:37:26 <mm_freak> \(A : Set) (B : A → Set) (x : (tx : A) → B tx) (y : A) → x y
08:37:28 <mm_freak> better? =P
08:37:51 <napping> How about \(A : Set) (B : A → Set) (x : (tx : A) → B tx) (y :  A) → x y
08:38:04 <t7> il allow it
08:38:07 <mekeor> mm_freak: btw, how is your language-experiment going?
08:38:52 <mm_freak> mekeor: this is my experiment…  i now have a core language with de bruijn indices and Set : Set…  after work i'm going to switch to locally nameless
08:39:24 <napping> Oops, I meant \Set (0 → Set) (1 → 1 0) 2 → 1 0 ;)
08:40:23 <mm_freak> napping: your indices are wrong =)
08:40:29 <mekeor> mm_freak: cool.
08:40:45 <napping> If each -> is a binder?
08:40:58 <mm_freak> napping: beware of the difference between the left and right sides
08:41:16 <mm_freak> (->) is a binder for the right side
08:41:58 <mm_freak> in (x : A) -> B, x is not in scope for A
08:42:15 <hpaste_> scooty-puff pasted “Is this possible?” at http://hpaste.org/67882
08:42:45 <mm_freak> scooty-puff: that's not possible
08:42:53 <scooty-puff> k
08:42:57 <mm_freak> 's' is not in scope for 'm a'
08:43:10 <mm_freak> and the type system forbids you to bring it in scope
08:44:56 <t7> byorgey: question 13
08:45:05 <t7> i have jellybean . furry'
08:45:22 <t7> but i get ambiguous vars
08:45:48 <t7> no thats a lie
08:45:55 <scooty-puff> how does runST get away with it?  and does that mean that a free monad for some STAction s a = read st ref, write st ref, etc., could not be written (or not have the ST action run?)
08:46:03 <t7> \x f (jellybean . furry' f) x
08:46:28 <byorgey> t7: furry' cannot be applied to f
08:46:33 <napping> you'd probably need something like a per-monad lifting function to push the forall inside
08:46:36 <byorgey> t7: furry' expects a function, but f has type  m (a -> b)
08:46:40 <byorgey> which is not a function.
08:47:42 <ski> scooty-puff : you'd need `Monad m => (forall s. m (f s)) -> m (forall s. f s)' for that
08:48:02 <scooty-puff> k
08:48:29 <ski> could you elaborate on what you mean by "free monad for some STAction s a = ..." ?
08:49:17 <ski> (also, `runST' gets away with it because it's magic / a primitive)
08:49:47 <ski> (i don't recall whether there's any in-haskell implementation of `ST' ..)
08:57:16 <quintessence> it appears that evilRunST = unsafePerformIO . unsafeCoerce works (in GHC)
08:59:23 <ski> heh, using which type for `unsafeCoerce' ?
08:59:47 <scooty-puff> ski, i wanted to define a FreeT (similar to kmett's free) (eventually a church encoded version)
08:59:49 <scooty-puff> brb
09:01:06 <quintessence> unsafeCoerce :: (forall s. ST s a) -> IO a, though it infers it if you give the whole thing the same signature as runST
09:01:42 <ski> (yeah, i wasn't suggestion you had an explicit type ascription)
09:02:35 <ski> but you could just as well use
09:02:35 * ski bows
09:02:39 <ski> argh
09:02:43 <ski> @type Control.Monad.ST.stToIO
09:02:44 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
09:03:18 <ski> (so only the `unsafePerformIO' is unsafe, then)
09:03:48 <quintessence> is it actually instantiating unsafeCoerce with that rank-2 type, or does it pick something else that also works?
09:07:13 <ski> quintessence : your version ?
09:07:22 <quintessence> yeah
09:07:26 <hpaste_> napping annotated “Is this possible?” with “Is this possible? (annotation)” at http://hpaste.org/67882#a67889
09:07:57 <ski> quintessence : well, if you have no annotation, it might well be `unsafeCoerce :: ST s a -> IO a' instead
09:08:42 <hiptobecubic> Why doesn't ghc-mod include type class constraints when it returns a type?
09:08:42 <napping> scooty-puff: there's a verion using an explicit lifting operation. I don't know how to get one of those, but it's probably implied by parametricity
09:08:53 <ski> napping : oh, that `unFlip (Flip f) = f' matching is allowed now ?
09:09:18 <napping> apparently? I'm on 7.2.1
09:09:50 <ski> last i tried something like this, i got errors when matching (nontrivially) on polymorphic arguments
09:10:39 <untitled> hi, can you show an example of modifying an MVar containing int? incrementing it for example
09:11:25 <parcs`> "This improves efficiency slightly but significantly for most programs, and ...." what
09:11:42 <Botje> modifyMVar_ mv (return . (+1))
09:11:47 <bitonic> untitled: modifyMVar ref (\x -> return (x + 1, ())
09:11:53 <kallisti> withMVar succ mVar
09:12:05 <kallisti> er
09:12:08 <kallisti> withMVar mVar succ
09:12:19 <kallisti> withMVar mVar (return . succ)   -- do de do de do
09:12:19 <Botje> kallisti: succ needs to ba a -> IO b
09:13:24 <untitled> thanks
09:13:31 <parcs`> modifyMVar is not atomic btw
09:13:34 <napping> unsafeCoerce does seems to serve as a lifter
09:13:39 <parcs`> if that is important to you
09:13:43 <ski> (napping : and i'm not sure if it's directly implied by parametricity -- it's *something* like that, though)
09:15:26 <ski> @hoogle MVar a -> (a -> (a,b)) -> IO b
09:15:27 <lambdabot> No results found
09:15:33 <ski> @hoogle MVar a -> (a -> a) -> IO ()
09:15:33 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
09:15:33 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
09:15:33 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:16:43 <ski> @type Control.Concurrent.MVar.swapMVar
09:16:44 <lambdabot> forall a. GHC.MVar.MVar a -> a -> IO a
09:19:53 <parcs`> i am sad that there is no xor for Bool
09:20:34 <napping> this does allow impredicative types http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
09:20:55 <ski> parcs` : `(/=)'
09:22:10 <parcs`> neat
09:22:14 <parcs`> but you can't chain em :(
09:22:54 <bitonic> parcs`: what do you mean? /= behaves exactly like a binary Bool xor
09:23:52 <bitonic> and for more than 2-way xor you can do `\l -> nub l == []'
09:24:05 <parcs`> > True /= False /= True
09:24:06 <lambdabot>   Precedence parsing error
09:24:07 <lambdabot>      cannot mix `GHC.Classes./=' [infix 4] and `GH...
09:24:33 <bitonic> actually, `\l -> not . null . nub $ l'
09:25:10 <osa1> so I'm new at haskell and monad stuff and I was wondering, why ST monad is a monad but not applicative? I thought every monad is already applicative functor(and every applicative functor is already functor)
09:25:10 <bitonic> parcs`: but that won't be a 3-way xor anyways (which, I suppose, is what you want to do)
09:25:30 <c_wraith> osa1: just an oversight. I think new enough versions of base make ST Applicative
09:25:47 <osa1> c_wraith: oh, ok. thanks.
09:25:59 <c_wraith> yeah, It's applicative in the newest version of base
09:27:17 <ski> @type liftM2 (&&) (not . null) (null . tail) . filter id
09:27:18 <lambdabot> [Bool] -> Bool
09:27:58 <hiptobecubic> Oh apparently it's a bug in ghc which is now fixed..
09:28:00 <napping> unfortunately Monad does not require Functor
09:28:24 <bitonic> ski: why isn't `not . null . nub' enough? assuming that `nub' is lazy it'll be efficient anyways
09:28:25 <hiptobecubic> but if i update. i have to rebuild the entire world again :(
09:29:50 <sclv> when would not . null . nub not be the same as not . null !?
09:32:09 <bitonic> sclv: ah, right, it'll leave one element in
09:32:41 <parcs`> > (not . null . nub $ [1, undefined], not . null $ [1, undefined])
09:32:43 <lambdabot>   (True,True)
09:32:51 <bitonic> `\l -> length (nub l) < 2'
09:33:05 <bitonic> mhm, no
09:33:05 <parcs`> > (not . null . nub $ [undefined, 1], not . null $ [undefined, 1])
09:33:08 <lambdabot>   (True,True)
09:33:08 <bitonic> length is monolithic
09:33:12 <parcs`> damn, plan thwarted
09:33:31 <bitonic> so yeah, what ski said
09:43:05 <jfischoff> Is there a explicit way to say that I want to export everything from the current module? I need to reexport an internal module and everything in the current one, and I don't feel like listing everything out.
09:44:21 <bitonic> module Foo where ...
09:44:25 <bitonic> with no list
09:44:54 <jfischoff> but I need to list to re-export right?
09:45:24 <bitonic> jfischoff: no, you can just write `module Foo' in the list of exports
09:46:00 <jfischoff> and that will export the external module and my module?
09:46:18 <bitonic> module Bar (module Foo) where ... will work
09:46:26 <napping> that will just include everything from Foo
09:46:30 <bitonic> in this case it'll export everything that's in Foo
09:46:47 <napping> if you have tons of definitions in the module that you want to re-export from, maybe you can move them to a third module
09:46:48 <jfischoff> yeah no doubt but will it export everything from Bar also
09:47:20 <bitonic> jfischoff: if you want to export everything for bar as well, don't include a list of exports
09:47:24 <bitonic> *Bar
09:47:34 <jfischoff> napping:  That sounds like a good idea
09:47:39 <bitonic> `module Bar where; import Foo' will export everything that's in Foo
09:48:19 <jfischoff> bitonic: really?
09:48:58 <bitonic> jfischoff: really.
09:49:11 <napping> no, I just tried it
09:49:20 <bitonic> ok, then I'm badly misremembering
09:49:26 <hiptobecubic> how can i list all of the packages i have installed?
09:49:29 <bitonic> since I haven't done that in a while. let me try...
09:49:33 <bitonic> hiptobecubic: ghc-pkg list
09:49:50 <napping> that doesn't re-export anything
09:49:53 <allbery_b> last I checked implicit export lists did not re-export modules (and I wouldn't expect thjem to, it'd cause massive clashes)
09:50:01 <jfischoff> napping: agreed
09:50:34 <hiptobecubic> bitonic, thanks
09:50:47 <napping> Coq has explicit Import and Export forms, for either case
09:51:35 <bitonic> jfischoff, napping: you're right, sorry
10:00:19 <hayashi> YAy
10:01:13 <hayashi> I'm trying to get my package to use mtl >=2 && <2.1, every other package it uses is requiring mtl-1.1.0.2, despite being listed on hackage as either being fine with version 2 or having no version limit whatsoever
10:01:44 <hayashi> I assume this is going to culminate in widespread recompiles
10:01:52 <ski> bitonic : well, it's enough as well -- i just stated an alternative
10:03:10 <ski> hm
10:03:20 <ski> > (not . null . nub) [True]
10:03:22 <lambdabot>   True
10:03:23 <ski> > (not . null . nub) [True,False]
10:03:25 <lambdabot>   True
10:03:32 <ski> > (not . null . nub) [True,False,True]
10:03:34 <lambdabot>   True
10:03:43 <stilgart> :t nub
10:03:44 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:03:54 <ski> bitonic : actually, i take that back, the `nub' version doesn't work :)
10:04:26 <bitonic> ski: yes, it's not null, but `null . tail'
10:04:48 <ski> > (not . null . tail . nub) []
10:04:51 <lambdabot>   *Exception: Prelude.tail: empty list
10:05:11 <bitonic> ski: and the usual precautions :)
10:05:29 <bitonic> which is way I said "then do what ski said"
10:05:38 <bitonic> also, it's not clear what `xor []' would be
10:05:44 <bitonic> or `xor [False]'
10:06:40 <ski> `xor []' should be `False' of course
10:06:41 <ppseafield> With Repa, is there a reason that the parallelized functions all return monadic values?
10:06:57 <ski> well, at least if we assume it checks whether exactly one operand is `True'
10:07:06 <ski> (which is what i was assuming we wanted)
10:07:35 <ski> if we iterate binary xor instead we get "is an odd number of the operands `True' ?"
10:07:55 <bitonic> ski: I was actually implementing "check if the elements are not all the same"
10:08:09 <bitonic> but I guess yours make more sense
10:08:21 <ski> ah, generalized `(/=)' then, not generalized xor :)
10:08:40 <bitonic> ski: yeah that's more what I did
10:08:51 <ski> not really :)
10:09:00 <ski> (maybe you intended to do it, though)
10:09:57 <bitonic> ski: well, checking that nub'ing yields a list with length < 2 seems like a good method, no?
10:10:23 <bitonic> well, it won't work with one element lists
10:11:20 <napping> what are you trying to compute? not all equal?
10:11:45 <ski> @type foldr (\a foo p -> p a && foo (liftM2 (&&) p (a /=))) (\p -> True) `flip` \a -> True
10:11:46 <lambdabot> forall a. (Eq a) => [a] -> Bool
10:12:02 <ski> (exercise : make it more pointless)
10:12:59 <ski> oh, wait
10:13:21 <ski> you said "elements are not all the same", i implemented "all elements are different"
10:13:47 <ski> (which imo is the the most useful generalization here)
10:14:02 <bitonic> @type \l -> case l of [] -> True; [_] -> False; _ -> null . tail . nub $ l
10:14:03 <lambdabot> forall a. (Eq a) => [a] -> Bool
10:15:17 <ski> (wouldn't you have `length . (>= 2)' then ?)
10:16:06 <bitonic> ski: length is monolithic
10:16:42 <ski> yeh, i'm just wondering if you want "not all are the same" or "all are the same"
10:16:53 <bitonic> ski: not all are the same
10:16:59 <bitonic> damn I'm missing a `not' there
10:17:12 <bitonic> `not . null . tail . nub' :P
10:17:13 <ski> yeah, and `[]' should map to `False'
10:17:24 <bitonic> ski: why?
10:17:44 <ski> (because all elements of `[]' are the same, so "not all are the same" should give `False')
10:18:18 <xplat> "the phrases extensional equality and compact topology are the phrases that keep keep me from trying haskell" (http://stackoverflow.com/questions/1717553/pointer-equality-in-haskell)
10:18:21 <bitonic> oh right. this little function got me confused :P
10:19:07 <xplat> i wish it were more widely understood that it's not that using haskell requires you to know words like that, it's that knowing words like that requires you to use haskell
10:19:31 <ski> xplat : bah, "extensional equality" isn't even scary math ..
10:19:52 <rwbarton> the text in question doesn't even contain the phrase "compact topology" :P
10:20:15 <rwbarton> oh, it used to
10:20:49 <ski> (it just means "observational/behavioural equality" -- for functions : two functions are extensionally equal if they give results for the same arguments (and in all circumstances, if we're talking about impure functions))
10:23:30 <xplat> i'm starting to write a sort of lazy evaluator
10:23:57 <dmwit> Oh, you found a grad student?
10:24:09 <dmwit> Thank you, thank you, I'll be here all week!
10:24:43 <path[l]> hahaha
10:24:48 <path[l]> I thought you were serious
10:25:11 <xplat> i don't want to write a garbage collector to scan the heap for unused graph nodes and kill them, since the GHC runtime already contains a perfectly serviceable one
10:25:33 <xplat> dmwit: i think in this situation i am the grad student
10:25:37 * hayashi wonders if it's at all possible to lift a conditional up in order to choose an applicative based on the result of another applicative.  That sounds like it's turning into monadic bind
10:26:16 <dmwit> hayashi: Correct, that is exactly the kind of thing Applicative can not do.
10:26:32 <hayashi> Yay
10:26:52 <ski> xplat : hm, would <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/System-Mem-Weak.html> work ?
10:27:55 <xplat> ski: yeah, i wanted to use that, along with some kind of well-behaved unique IDs for the thunks (IORef?)
10:29:19 <alpounet> xplat, what about http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html ?
10:29:52 <hayashi> Is this supposed to turn into a sort of game where you see how much code you can write in a pure style, and the rest of it you then see how much you can write in an applicative style, and the rest goes to monads, or are you supposed to just stick with monads as soon as something monadic appears in impure code?  =P
10:30:56 <xplat> hayashi: depends how much you can write in each style and how reusable it looks like it will be
10:31:24 <dmwit> Once monadic operations are involved, the only reason to choose between Monad notation and Applicative notation is personal aesthetics.
10:31:31 <dmwit> tl;dr "go with your heart"
10:34:32 <xplat> i don't think StableNames quite do what i want
10:35:20 <dmwit> Have you said what you want yet?
10:35:44 <xplat> i need to keep a table full of the values for the thunks that have been evaluated (and maybe the content for the ones that haven't, although that's probably not strictly necessary if i can share it in haskell)
10:36:04 <xplat> i need to be able to generate new thunks with a given content
10:36:32 <napping> you need the table for hash-consing?
10:36:39 <xplat> i need to be able to force a thunk (look up the answer if it's already evaluated, else evaluate it)
10:36:56 <ski> hayashi : istr we were talking a bit here one time about having a subclass of `Applicative i' adding an operation `eitherA :: forall a b c. i (a -> c) -> i (b -> c) -> i (Either a b) -> i c'
10:36:59 <xplat> actually in this case i want to *not* hash-cons
10:37:38 <dmwit> Okay, so you want a supply of unique id's and an efficient lookup/retrieval by id, then?
10:37:44 <xplat> right
10:37:48 <napping> I don't think you have yet explained why you can't share haskell thunks for this
10:38:05 <dmwit> How about using one of the mutable, resizable arrays and a bit of state telling the largest index you've used + the current maximum size of the array?
10:38:35 <yan_> i'm using a MaybeT transformer over IO and ending up needing to 'lift $' every line within the IO monad for it to typecheck.. are there common ways of calling normal -> IO .. functions within a MaybeT that don't add much syntax?
10:38:39 <dmwit> It's low-tech and you get amortized O(1) for all the operations.
10:38:39 <xplat> napping: because evaluation of thunks is in a monad
10:38:40 <xil> hey everyone. So arrays have the "amap" function, but can't I just use fmap?
10:39:10 <xplat> dmwit: i want thunks to go away when they are no longer referenced
10:39:16 <ski> hayashi : there are reasons to prefer applicative functors to monads. in some cases a library based on applicative functors can be more efficient (because the interface is more general, capturing more things, so code is more restricted in what it can do, which can help with efficiency)
10:39:26 <dmwit> xil: Whenever your IArray instance is also a Functor instance, yes.
10:39:41 <dmwit> xplat: oh, right
10:39:42 <xil> dmwit: oh so amap is for when your instance isn't one of Functor
10:39:45 <xplat> so it's either 'write a garbage collector' or 'use some kind of weak-keyed table'
10:39:56 <napping> with no sufficiently pure run?
10:40:25 <dmwit> yan_: Usually you make a handful of primitives that do IO and call those instead.
10:40:42 <xplat> napping: the run has to be able to see state, at least read-only
10:41:01 <byorgey> yan_: well, if you have a sequence of lines which all are in IO, instead of  lift $ thing1; lift $ thing2; lift $ thing3 ...  you can say   lift $ do thing1; thing2; thing3
10:41:13 <xil> dmwit: but I am right that map is equivalent to fmap where the Functor is []?
10:41:28 <dmwit> ?src fmap []
10:41:28 <lambdabot> Source not found. :(
10:41:31 <dmwit> ?src [] fmap
10:41:31 <lambdabot> fmap = map
10:41:37 <xil> haha, awesome
10:41:39 <byorgey> yan_: but you can't get away without any explicit lifting at all, as far as I know
10:41:41 <xil> thanks =]
10:41:43 <ski> @type let amap :: (Data.Array.IArray.IArray a e0, Data.Array.IArray.IArray a e1, Ix i) => (e0 -> e1) -> a i e0 -> a i e1; amap = fmap in amap
10:41:44 <lambdabot>     Could not deduce (Functor (a i))
10:41:45 <lambdabot>       from the context (Data.Array.Base.IArray a e0,
10:41:45 <lambdabot>                         Data.Array.Base.IArray a e1,
10:41:48 <napping> If it's safe to cache the result, it can't depend to heavily on state
10:42:01 <xplat> but putting the thunks even in Reader destroys haskell-level sharing of the results
10:42:11 <xplat> also, evaluation can fail
10:42:20 <hiptobecubic> upgrading ghc is ... rather involved
10:42:33 <napping> maybe you could avoid an explicit table by using something like TVar (Either (EvalM a) | (Result a))
10:42:39 <hiptobecubic> it will be nice when cabal gets parallel building
10:42:49 <hiptobecubic> even at the package level
10:43:28 <napping> if you explicitly don't want to hash-cons new similar thunks
10:43:47 <napping> use GHC at least for garbage collection
10:44:28 <xplat> well, if evaluation fails, it should be tried again later, and the thunk should be updated with the intermediate result
10:59:21 <ski> xplat : yeah, e.g. you'd like to replace `fst (<thunk0>,<thunk1>)' with `<thunk0>' (see <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks>)
11:01:12 <xplat> ski: yeah
11:01:38 <xplat> it's hard to even find anything on hackage using Weak pointers, though
11:03:04 <ski> also "SRFI 45: Primitives for expressing iterative lazy algorithms" <http://srfi.schemers.org/srfi-45/srfi-45.html> might be interesting (specifically the `lazy' primitive)
11:03:52 <yan_> i have a function "Entry -> IO (Maybe String)" that takes an entry and potentially returns a string. then i have another function "Maybe String -> Entry -> Entry" that modifies an entry depending on whether its first argument is right. is there a way to 'compose' those two functions (even though the latter is not in IO)?
11:04:04 <xplat> a commented-out section in Reactive, and an obsolete version of intern are all i've got so far
11:04:19 <yan_> that will enable me to map a list of entries to anotehr list, but having the second list have some entries that are modified depending on that 'Maybe String'
11:04:21 <xplat> yan_: fmap it
11:04:56 <jfischoff> xplat: what are the weak pointers used for?
11:04:56 <ski>   liftM (`bar` otherEntry) . foo
11:05:34 <ski> (assuming `foo :: Entry -> IO (Maybe String)' and `bar :: Maybe String -> Entry -> Entry')
11:05:35 <yan_> xplat: hmm. but the second function takes two args..
11:05:46 <xplat> jfischoff: what i need really are not just weak pointers but a whole weak hashtable
11:06:11 <xplat> yan_: ski already answered more thoroughly
11:06:50 <xplat> jfischoff: to store results of thunks when i evaluate them in an interpreter for a lazy language
11:07:13 <ski> yan_ : `otherEntry' is the second argument
11:07:36 <ski> did you want `Entry -> Entry -> IO Entry' as result
11:07:52 <xplat> in short: i can't recycle haskell's lazy evaluation because interpreted evaluation is in a monad, but i still want to recycle the underlying garbage collector instead of writing my own
11:08:47 <jfischoff> xplat: ah
11:09:15 <ski> yan_ : i suspect there's no nicer fully pointless version of it
11:09:21 <yan_> xplat: i have a list of entries, i want to update some of them (map to a new list). what decides whether or not i map is the 'Entry -> IO (Maybe String)" function. i can just move that test inside it and have it map "Entry -> IO (Entry)" but it's on a different level of abstraction
11:09:32 <ski> @pl \otherEntry -> liftM (`bar` otherEntry) . foo
11:09:32 <lambdabot> (. foo) . fmap . flip bar
11:09:39 <ski> doesn't look that readable
11:09:58 <ski> hm, i suppose it should be
11:10:08 <xplat> ski: barInIO = flip . liftM . flip $ bar
11:10:12 <ski> @pl \entry otherEntry -> (liftM (`bar` otherEntry) . foo) entry
11:10:12 <lambdabot> flip ((. foo) . fmap . flip bar)
11:10:27 <yan_> basically, each Entry has a url field. that "Entry -> IO (Maybe String)" performs some IO to gather if that URL can be updated to a newer one. if it can, it returns a Just newurl
11:10:28 <xplat> er, flip . (liftM .) . flip $ bar
11:10:36 <yan_> so i'm trying to transform this list, updating urls where it can
11:10:57 <ski> xplat : where is `foo' ?
11:11:21 <yan_> ski, xplat: (this is my first haskell project, so i'm sure i'm making every mistake in the book)
11:11:35 <xplat> ski: barInIO (foo e1) e2
11:12:31 <ski> yan_ : do you want a resulting function `Entry -> Entry -> IO Entry' or `Entry -> IO Entry' ?
11:13:27 <yan_> ski: i want the resulting to be able to be mapped over a [Entry]
11:13:38 <yan_> so Entry->Entry
11:14:01 <xplat> you mean Entry -> IO Entry
11:14:24 <ski> so, you want to (a) translate each `Entry' in the list (possibly doing `IO') into `Maybe' a new `Entry'
11:14:25 <yan_> xplat: yes, then i can use mapM
11:14:50 <ski> then you want to combine this `Maybe Entry' with another `Entry' (the original one ?) into a new `Entry'
11:14:57 <ski> (that's (b))
11:15:01 <yan_> ski: yes
11:15:17 <ski> which other `Entry' do you want to combine with, is it the original one ?
11:15:40 <xplat> @pl \e -> liftM (\x -> bar x e) (foo e)
11:15:40 <lambdabot> ap (fmap . flip bar) foo
11:16:10 <ski> somewhat inscrutable, i think :)
11:16:50 <xplat> it's basically zip`ap`tail all over again
11:18:58 <timthelion> is there still no natural number support in haskell?
11:19:21 <xplat> you'd think with weakrefs in ghc being like 10 years old someone would have published a reusable weak hashtable
11:19:51 <c_wraith> xplat: that would require a useable hashtable
11:20:00 <c_wraith> xplat: those have only been around for a year or so
11:20:13 <timthelion> I found the natural number trac ticket. it's 6 years old with no comments
11:21:29 <importantshock> timthelion: type-level naturals are coming in 7.6.1 - http://hackage.haskell.org/trac/ghc/ticket/4385 - may not be what you want though.
11:22:10 <timthelion> thanks, i'll look at it.
11:23:36 <importantshock> oleg has a library that does type-level naturals too.
11:23:41 <timthelion> I just want to make data Rectangle = Rectangle { x :: Int,y::Int,width::Natural,height::Natural}
11:23:55 <timthelion> nothing unusual
11:24:06 <jfischoff> why not a new type?
11:24:11 <jfischoff> newtype
11:25:30 <timthelion> jfischoff, could do that to I guess, but that doesn,t help me with the natural numbers, does it?
11:27:15 <jfischoff> timthelion: depends. You could use smart constructors to ensure that only naturals are actually created
11:27:48 <timthelion> \me doesn't know how to do that.
11:28:23 <dmwit> wrong slash =)
11:28:35 <timthelion> sorry
11:28:44 <dmwit> You write something like
11:28:51 <dmwit> newtype Natural = Natural Integer
11:28:57 <dmwit> don't export Natural; instead, export
11:29:01 <dmwit> natural :: Integer -> Maybe Natural
11:29:08 <jfischoff> timthelion: its simpler then it sounds.
11:29:12 <Luke> ozataman: does it make sense to have csv-conduit us ByteString instead of Text?
11:29:20 <jfischoff> dmwit: explained it well
11:29:30 <dmwit> Similarly, don't export (-); instead, export diffNatural :: Natural -> Natural -> Maybe Natural
11:29:48 <dmwit> I think there are a few packages on Hackage that provide this already.
11:29:59 <timthelion> dmwit, thanks, I think I got it
11:30:04 <ski> or you could make sure to interpret `Natural n' as `2 * n' when `n >= 0' and as `-2 * n - 1' when `n < 0'
11:30:18 <dmwit> yuck
11:30:24 * ski grins
11:33:03 <xplat> ski that would work out to be surprisingly limited in horribleness
11:33:22 <xplat> compared to some of the options
11:33:33 <jfischoff> there's always data Natural = Zero | Succ Natural
11:33:39 <xplat> most arithmetic would be constant time, etc
11:33:42 <dmwit> Yes, efficiency be damned.
11:33:54 <dmwit> More realistically, there's type Natural = [Bit]
11:34:20 <xplat> er, constant time-overhead, it's already not constant time for Integer
11:34:38 <ski> because `(genericLength [0 ..] :: Natural) > 0' should return `True' !
11:40:39 <Luke> ozataman: nevermind I see that it's me using ByteString ;-P
11:45:31 <zaltekk> hey guys. i'm an understand computer science student with one semester left to go. i just finished a course where our last project was written in ocaml(with restrictions to avoid imperative programming), and i've become really intrigued.
11:45:51 <dmwit> Welcome, zaltekk!
11:45:57 <zaltekk> however, i'm having a hard time deciding on which functional language to learn(i'd like to have some reasoning rather than just picking something blindly)
11:46:25 <zaltekk> i came across http://www.haskell.org/haskellwiki/Comparison_of_functional_programming_languages and i found it really useful, but i'm looking for something with maybe a bit more detail
11:46:56 <importantshock> zaltekk: how so? what further criteria interest you?
11:47:06 <jfischoff> zaltekk: have you written a simple functional language yourself?
11:47:20 <zaltekk> jfischoff: written a functional language myself? no.
11:47:24 <monochrom> reason to choose ocaml: so you have oop and imperative to fall back on. reason to choose haskell: so you don't have oop or imperative to fall back on.
11:47:42 <zaltekk> importantshock: maybe pros/cons of, say, lazy evaluation over eager evaluation and monads over side-effects
11:47:47 <dmwit> My favorite way to describe the difference is that Haskell was designed, and OCaml grew.
11:48:40 <monochrom> (yes, I'm using dualism. every property is a pro and con.)
11:49:05 <ski> @where whyfp
11:49:06 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
11:49:15 <ski> mentions some modularity aspects of laziness
11:51:07 <zaltekk> monochrom: i'm assuming OO isn't really a concern in functional programming, the way it improves imperative?
11:51:50 <ozataman> Luke: yeah, Text is likely better for most scenarios
11:52:01 <ozataman> Luke: csv-conduit supports both
11:53:13 <ski> zaltekk : with eager, it's easier to predicate when what gets evaluated, and it's easier to predict space usage accurately. laziness as some modularity advantages (see paper above)
11:54:02 <zaltekk> i'm glad to see there is a native compiler and a profiler like with ocaml
11:54:38 <ski> zaltekk : with effects encoded using monads, we can be sure that non-monadic code doesn't have effects -- which helps with writing, understanding and refactoring
11:55:09 <ski> it can also potentially help an implementation perform more aggressive high-level optimizations (such as loop fusion, e.g.)
11:55:31 <Veinor> what's the difference between MonadUnsafeIO and MonadIO?
11:55:49 <dmwit> spelling
11:56:03 <dmwit> Haha! I kid. But where is MonadUnsafeIO from?
11:56:16 <Veinor> http://hackage.haskell.org/packages/archive/resourcet/0.3.2.1/doc/html/Control-Monad-Trans-Resource.html#t:MonadUnsafeIO
11:56:17 <zaltekk> ski: does uniqueness and lazy lists have that advantage as well?
11:56:34 <napping> those all preserve referential transparency
11:57:18 <dmwit> Veinor: The point being, I suppose, that some monads can do *some* but not *all* IO actions.
11:57:19 <napping> so basically yes, but I don't think the implementations usually optimize as aggressively as GHC
11:57:34 <dmwit> Those should implement MonadUnsafeIO, and tell what the proof burden for callers of unsafeLiftIO is.
11:57:42 <dolio> Lazy lists are bad for IO because it's easy to write deadlocks.
11:57:50 <ski> zaltekk : if you have composable continuations as side-effects (alternatively ordinary continations, and also state), then, by Andrzej Filinkski's "Representing Monads" and "Representing Layered Monads" (see <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>), you can *reflect* any monad which you can implement into a corresponding side-effect, which will then appear as a built-in side-effect to the language
11:57:51 * hackagebot git-annex 3.20120430 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120430 (JoeyHess)
11:57:52 <dmwit> e.g. ST allows it, and asks that you prove that only memory accesses happen in the IO action you pass.
11:57:58 <Veinor> dmwit: ah, that makes sense
11:58:43 <Eduard_Munteanu> Assuming I want to build some simple dynamic webpage with forms, what do I use? Presumably Yesod for "scripting", but what about dealing with HTML (or better, not dealing with it :D) in a more pleasant way?
11:58:46 <Veinor> so MonadIO means 'you can do whatever IO you want', MonadUnsafeIO means 'you can do some IO, if you use unsafeLiftIO your action must satisfy some property'
11:59:00 <Veinor> Eduard_Munteanu: yesod and snap both have HTML templating engines
11:59:15 <dmwit> yes
11:59:19 <zaltekk> okay. you guys have been a great help
11:59:31 <Veinor> yesod's mixes rendering and logic some (you can call functions inside it), snap's is pure rendering
11:59:47 <Eduard_Munteanu> Veinor: I see. Does that allow me to create input stuff directly (I don't need much of a layout), or do I have to make a template first? I'd rather go simple :)
11:59:51 * Eduard_Munteanu is feeling lazy
12:00:08 <zaltekk> since i've already learned a bit about using ocaml functionally i think that trying out haskell in the same way will be very helpful in deciding where to invest more time
12:00:18 <ski> zaltekk : i think Oleg made an implementation of composable continuations for O'Caml (there's an easy one for SML/NJ and Mlton which have continuations), so that you can write something like `reify (fun () -> reflect [2,3] + reflect [400,500])' and have it return `[402;502;403;503]'
12:01:04 <ski> zaltekk : perhaps one of the more interesting examples of this would be to reflect a parser monad
12:01:19 <Eduard_Munteanu> Veinor: I guess I'm mostly looking for a HTML "toolkit", much like say Gtk2Hs for X :)
12:01:21 <ski> (another example might be reflecting `Lwt.t')
12:01:38 <dmwit> Eduard_Munteanu: You can use the HTML5 backend for GTK.
12:01:40 <dmwit> =)
12:01:42 <dekuked> in #django
12:01:48 <Eduard_Munteanu> dmwit: hm, neat idea.
12:02:20 <dmwit> I actually have no idea whether that requires some support from gtk2hs or not. If it does, then you can't do it. =P
12:02:42 <Eduard_Munteanu> dmwit: hm yeah, besides, interfacing properly with the notion of HTML forms.
12:03:07 <ski> zaltekk : yes, uniqueness typing resp. modes as in Clean resp. Mercury is another pure way of handling state effects -- however this doesn't handle other effects, so you might want to use monads (or applicative functors) anyway for expressing such
12:03:09 <dmwit> It wouldn't use forms, no.
12:03:24 <dmwit> Are forms a requirement for some reason?
12:04:12 <Eduard_Munteanu> dmwit: basically, I need to write a web interface to upload some files and modify a database, and I'm in no mood for HTML :D
12:04:52 <Clint> you can pretty much do that without any html in yesod
12:04:54 <Clint> it'll be ugly though
12:05:30 <Eduard_Munteanu> Oh, it doesn't matter if it looks like a hacker webpage, just a simple minimal layout.
12:06:07 <Eduard_Munteanu> i.e. I don't really need any fancy looks
12:06:42 <ski> zaltekk : i assume you've heard of <http://ocsigen.org/lwt/manual/>, and that it basically uses a monad
12:06:58 <Eduard_Munteanu> I guess there might be some templates I could snatch freely.
12:07:18 <zaltekk> ski: yes, i've heard of it, but never used it.
12:08:02 <Clint> http://www.yesodweb.com/book/forms
12:08:46 <Eduard_Munteanu> Thanks, I'll try that, perhaps it's enough.
12:09:14 <gintas> hi, I have quick question: is it safe to compile untrusted .hs source code under ghc? That is, can I assume that ghc will not get into an infinite loop or reveal contents of system files? One attack vector I know of would be the C preprocessor, but I think I can get around that by just prepending my own module header ("module Foo where"), which means that input source code will not be able to provide its own file-header pragmas 
12:09:14 <gintas> thus can't enable CPP). Are there any other gotchas that I should take into account?
12:09:25 <napping> template haskell
12:09:42 <c_wraith> template haskell can do *anything* at compile time
12:09:44 <Eduard_Munteanu> TH can pretty much do anything AFAICT.
12:09:58 <Eduard_Munteanu> Also OPTIONS pragmas
12:10:00 <napping> also, are you quite sure you're just going to compile it and not run it or even load it in ghci?
12:10:15 <gintas> napping: right. TH is also enabled using a file-header pragma, right?
12:10:23 <gintas> No, just compiling.
12:10:42 <Eduard_Munteanu> SafeHaskell stuff might address some of those issues, but I'm unsure.
12:10:43 <napping> or a command line option, yes. If it's just a single file, making sure there are no funny pragmas at the top should be enough
12:10:54 <napping> how untrusted is it?
12:11:08 <gintas> Strangers-from-the-web-submitting-code untrusted.
12:11:13 <gintas> It's a single file.
12:11:36 <napping> strangers-from-the-web-finding-zero-day-buffer-overflows-in-ghc untrusted?
12:11:59 <Eduard_Munteanu> gintas: see what lambdabot uses, if that's enough
12:12:05 <Eduard_Munteanu> mu-eval that is.
12:12:07 <gintas> I want to set up an online mini-IDE that would be able to type-check programs.
12:12:22 <Eduard_Munteanu> (however you can't do IO or anything like that)
12:12:33 <Eduard_Munteanu> Hm, just typechecking?
12:12:47 <gintas> Eduard_Munteanu: thanks, I already looked into it. It's a bit too limited for me though, it only does expressions.
12:13:06 <scooty-puff> i'm having some trouble with the church-encoded version of Free as a transformer - should it be: newtype F f m a = F { runF :: forall r . (a -> m r) -> (f (m r) -> m r) -> m r }
12:13:08 <gintas> Eduard_Munteanu: yeah, and sane error messages.
12:13:15 <scooty-puff> or (f r -> m r)
12:13:27 <zaltekk> gintas: codepad.org?
12:13:29 <napping> stripping pragmas will get you pretty far.
12:13:38 <napping> ah, there are some inputs that will hang GHC, if that's also a concern
12:13:46 <Eduard_Munteanu> gintas: have a look at SafeHaskell, maybe that helps you. In any case, it might be wise to add an additional security layer on top (strict MAC like SELinux, a VM, stuff like that)
12:14:04 <Eduard_Munteanu> And yeah, resource limits.
12:14:07 <napping> at least with -O, something about recursive newtypes
12:14:30 <Eduard_Munteanu> I think luite was working on something similar.
12:14:38 <gintas> napping: I probably won't be running with optimization.
12:14:45 <Eduard_Munteanu> You might want to prod him if he's around.
12:15:08 <gintas> Eduard_Munteanu: thanks, I'll try.
12:15:39 <yan_> hm if i have a list of URLs, is there a monad that will encapsulate a few IO actions per URL? i.e. i have a list of URLs, i want to (download, issue an HTTP request, report success/failure) for each one
12:16:04 <Eduard_Munteanu> :t sequence
12:16:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:16:49 <Eduard_Munteanu> yan_: you could mapM your action over a list of URLs.
12:17:05 <Eduard_Munteanu> :t mapM
12:17:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:17:59 <Eduard_Munteanu> Unless you're looking for something else, you don't need a special monad.
12:21:54 <ski> zaltekk : type classes in Haskell are nice. there's also extensions like higher-rank types, existential types, GADTs
12:22:15 <ski> (i think i saw some GADT prototype for O'Caml somewhere)
12:22:41 <napping> first class modules get you pretty far
12:23:00 <zaltekk> ski: i'm assuming type classes are to functional programming what objects are to imperative programming?
12:23:14 <zaltekk> maybe i'm way off, but i'm trying to grasp things very generally for now
12:23:32 <fragamus> I did this and it was already installed: cabal install MonadRandom     THE PROBLEM:      :m + Control.Monad.Random     RESULTS IN      Could not find module `Control.Monad.Random'
12:23:48 <zaltekk> i found Learn You a Haskell for Great Good on safari books online, and i'm starting to read it
12:23:58 <napping> that's probably too general
12:23:59 <zaltekk> so hopefully it can clear up a lot of terminology for me
12:24:08 <ski> zaltekk : "type classes are to functional programming what objects are to imperative programming" -- not directly
12:24:09 <Eduard_Munteanu> @where lyah
12:24:09 <lambdabot> http://www.learnyouahaskell.com/
12:24:18 <zaltekk> oh it's a free book?
12:24:18 <hpaste_> scooty-puff pasted “Improve "improve" and remove MonadFree constraint from runSTT?” at http://hpaste.org/67890
12:24:23 <Eduard_Munteanu> zaltekk: sure
12:24:38 <napping> classes mix together tons of sutff. typeclasses are somewhat similar to interfaces
12:24:46 <eviltwin_b> zaltekk, beware:  typeclasses are not OO.  they are for ad-hoc polymorphism.
12:24:49 <Eduard_Munteanu> It's usually the one most often recommended in here.
12:25:50 <zaltekk> eviltwin_b: oh, okay
12:25:50 <Eduard_Munteanu> There's also a paper variant you can buy, maybe that's why you stumbled into it there.
12:26:02 <eviltwin_b> thinking of them as OO wil get you into trouble quickly.
12:26:13 <scooty-puff> any advice?  i hate the MonadFree (STAction RealWorld) m constraint, and improve .. isn't great
12:26:16 <zaltekk> eviltwin_b: i was thinking "maybe that helps with complexity"
12:26:21 <scooty-puff> (for previous post)
12:26:47 <Eduard_Munteanu> scooty-puff: um, how did you get that?
12:26:48 <zaltekk> Eduard_Munteanu: there is also Real World Haskell. but it seems like it'd be better to read after LYAH
12:26:59 <scooty-puff> Eduard_Munteanu: ?
12:27:17 <Eduard_Munteanu> zaltekk: RWH is quite useful, although it might not be as easy-going as LYAH.
12:27:19 <scooty-puff> i mean "previous paste"
12:27:28 <Eduard_Munteanu> Also, the wikibooks on Haskell.
12:27:41 <zaltekk> Eduard_Munteanu: hence my thoughts on it being a second book to read, if i go that distance
12:27:44 <ski> zaltekk : type classes are sortof like a module type (a signature) which specify a couple of abstract types, plus operations on them. then you can (separatedly) implement (at most one) module having that module type, for each combination of concrete implementations of the types in the module. then you can use the operations in the module without explicitly having to specify which module implementing the module type you're using (there can be a
12:27:48 <Eduard_Munteanu> (which is nice for some mathy aspects and advanced stuff, but maybe less so for the basics)
12:28:26 <eviltwin_b> (ok, I know what you're saying and that's still painful...)
12:28:38 <ski> zaltekk : this is a very rough picture/comparision with O'Caml modules
12:28:38 <fragamus> ANYONE KNOW WHAT TO DO ABOUT Could not find module `Control.Monad.Random'
12:28:55 <magicman> ski: You broke off after "(there can be a")
12:29:00 <magicman> -)
12:29:07 <ski> "(there can be at most one, given that you know the concrete types)"
12:29:11 <c_wraith> fragamus: you should try installing it.
12:29:21 <Eduard_Munteanu> zaltekk: yeah. Although keep in mind it's not necessary to stick with a single source. If/when you feel comfortable, you can look into other stuff.
12:29:22 <zaltekk> ski: yeah that makes sense. although i must admit we haven't used those in my class. it was just one small project with very limited scope
12:29:40 <ski> zaltekk : oh, i forgot to mention. Haskell doesn't have the great module system (including functors) of the MLs
12:29:41 <fragamus> cabal install MonadRandom   did not work
12:29:49 <zaltekk> Eduard_Munteanu: that's the nice thing about safari books...i can look at tons of material without buying it all
12:29:57 <eviltwin_b> ghc-pkg find-module Control.Monad.Random
12:30:03 <Eduard_Munteanu> Sometimes a second point of view can be useful.
12:30:18 <Eduard_Munteanu> scooty-puff: nevermind, perhaps I missed some context.
12:30:22 <c_wraith> fragamus: modules aren't packages. cabal installs packages
12:30:26 <bitonic> zaltekk: LYAH is free
12:33:13 <fragamus> eviltwin_b: it found the package but cabal won't install it because it is already installed
12:33:51 <dmwit> ?src scanl
12:33:52 <lambdabot> scanl f q ls = q : case ls of
12:33:52 <lambdabot>     []   -> []
12:33:52 <lambdabot>     x:xs -> scanl f (f q x) xs
12:34:46 <eviltwin_b> fragamus, pastebin the output of that command somewhere.  (one of the possible causes of that failure is multiple packages providing it)
12:34:53 <ski> scooty-puff : what happens if you use `STT s []' ?
12:36:41 <dmwit> :t mapAccum
12:36:42 <lambdabot> Not in scope: `mapAccum'
12:36:47 <dmwit> ?hoogle mapAccum
12:36:47 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:36:47 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:36:47 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:37:25 <hpaste_> fragamus pasted “multiple package problem” at http://hpaste.org/67891
12:38:23 <fragamus> eviltwin_b: you are right, it is installed in multiple places
12:39:07 <fragamus> eviltwin_b: what do we do about it
12:40:47 <eviltwin_b> that's only in one place (it lists multuple places exist, but package is only under one of them).  can't say why you can't import it into ghci
12:42:24 <fragamus> eviltwin_b: ok thanks for trying
12:44:30 <rwbarton> did you restart ghci after cabal installing the package? what is the error message you get?
12:44:50 <eviltwin_b> aaactually, fragamus, it occurs to me there might be version conflicts, but it is hard to tell/not enough information
12:46:28 <timtheli1n> Let me get this rigth, there are no exceptions in pure code, just errors?
12:49:31 <scooty-puff> ski: in this case, type error - no instance for MonadFree (STAction RealWorld) []
12:49:34 <scooty-puff> which is maybe your point
12:49:48 <jfischoff> timtheli1n: Are you defining exceptions as a language feature?
12:53:13 <timtheli1n> jfischoff: What do you mean by "language feature"?
12:53:43 <ski> scooty-puff : i think `STT s []' (and perhaps `STT s (Cont o)' even more) are agreed to be hard or impossible to do, at least with a generic implementation
12:54:02 <scooty-puff> k
12:54:20 <ski> scooty-puff : `STT s []' would need to be able to backtrack updates, e.g.
12:54:58 <ski> so, if your implementation (claimed to) be able to handle these cases (generically), that'd would be reason to suspect the implementation is bad
12:55:23 <scooty-puff> k - as it is right now, its pretty much useless - that does explain a lot though
12:55:26 <c_wraith> Well.  If you don't mind losing the in-place memory updates, you can keep the denotational semantics of ST in STT. Just not the operational
12:55:46 <ski> scooty-puff : i have to say i don't follow all the details of it (yet at least)
12:55:52 <monochrom> pure code cannot catch-handle exceptions. pure code can throw exceptions, to be caught-handled in IO. for GHC anyway.
12:55:56 <scooty-puff> c_wraith: yeah, was just thinking about changing to State (IntMap Any)
12:56:03 <jfischoff> timtheli1n: one way to define exceptions is as the "sad path" things like parser errors. Expected behavior that requires a local abort. Conversely errors can be defined as logic errors. Things that should never happen. "error" the function raises an Exception that can be handled in IO
12:56:38 <timtheli1n> jfischoff: I'm trying to write the function evaluate :: a -> (a -> a) -> IO a ; evaluate a f =  --returns f a if there is no error, or a if f a returns an error.
12:56:40 <monochrom> however, beware of when you think pure code throws exceptions. you are usually wrong about when.
12:56:42 <ski> c_wraith : yeah, if you just pass around state versions, it should be possible (maybe using `Obj' or something)
12:57:14 <timtheli1n> for ALL ALL ALL funcions (a -> a), so that running ANY function (a->a) will NEVER crash, only just return the first a rather than the f a
12:57:41 <geekosaur> solving thehalting problem, are we?
12:58:02 <timtheli1n> geekosaur: there is no paradox here, it's very simple.
12:58:11 <monochrom> there is already Control.Exception.evaluate, with a much simpler type, and the simpler type suffices for what can be "all all all" universally done
12:58:32 <monochrom> (i.e., all you need is a -> IO a)
12:58:36 <scooty-puff> f a `catch` \ _ -> return a
12:58:40 <ski> timtheli1n : you can represent exceptions using the monad `Either e' (or `ErrorT e m')
12:58:52 <ski> (timtheli1n : also, all Haskell code is pure)
12:59:12 <monochrom> however, beware of how much it evaluates. there is no way to universally "evaluate completely"
12:59:26 <Cale> timtheli1n: What if f x doesn't terminate?
12:59:27 <timtheli1n> ski: but I'm not talking about that case.  I'm talking about (a -> a) specifically
12:59:30 <jfischoff> timtheli1n: look at scooty-puff
12:59:37 <ski> timtheli1n : ok
12:59:41 <timtheli1n> Cale: I'll accept that as a case.
12:59:49 <Taneb> Hello
13:00:01 <monochrom> well, you are not hearing me at all, so I'll stop
13:00:10 <Taneb> Since I have now accepted that trying to get cross-compilerness for my library is a lost coause
13:00:20 <timtheli1n> jfischoff: hm?
13:00:20 <Taneb> I have decided to make a version using the features GHC has to offer
13:00:39 <Cale> Yeah, monochrom has the answer
13:00:55 <monochrom> the correct answer is always invisible to the asker
13:01:00 <Taneb> I'll turn the Strings back into Texts
13:01:01 <jfischoff> or monochrom :)
13:01:18 <timtheli1n> monochrom: I'm hearing you, I'm just not having the time to think about, look up, and reply...
13:01:20 <scooty-puff> :t \ a f -> return (f a) `Control.Exception.catch` \ (_ :: SomeException) -> return a
13:01:22 <lambdabot>     Not in scope: type constructor or class `SomeException'
13:01:33 <monochrom> (well, what else could we expect? afterall, if the correct answer were visible to the asker, the asker wouldn't ask to begin with)
13:01:39 <Taneb> Replace the Json instance with either SafeCopy or Serialize
13:01:52 <jfischoff> what's wrong with scooty-puff's answer?
13:02:16 <timtheli1n> jfischoff: that I cannot read that fast :D
13:02:20 <monochrom> "return (f a)" throws no exception. ever.
13:02:35 <Cale> timtheli1n: Note that if you write this function, it will still return f x in the case that f x = [1,2,error "foo"] or any other datastructure containing errors.
13:02:54 <Taneb> monochrom, what if f a divides by 0?
13:02:55 <jfischoff> monochrom: go on, I'm listening.
13:02:55 <timtheli1n> Cale: really?
13:03:02 <ski> @type \a f -> return (f a) `Control.Exception.catch` \ (_ :: Control.Exception.SomeException) -> return a
13:03:04 <lambdabot> forall a. a -> (a -> a) -> IO a
13:03:14 <Taneb> Actually, wait. Laziness.
13:03:15 <scooty-puff> monochrom: yeah, just had to check that for myself, but makes sense
13:03:40 <ski> @type \a f -> Control.Exception.evaluate (f a) `Control.Exception.catch` \ (_ :: Control.Exception.SomeException) -> return a
13:03:41 <lambdabot> forall a. a -> (a -> a) -> IO a
13:03:46 <scooty-puff> well, maybe i'm just not evaulating whats return'ed
13:03:48 <Taneb> Is there a tutorial on Data.Serialize anywhere?
13:03:49 <Cale> timtheli1n: Unless you try to do something general to traverse many different types of datastructures (which you could do with deepseq), but this will restrict your polymorphism further
13:04:28 <monochrom> you could try "return $! (f a)". but I would stick with Control.Exception.evaluate.
13:04:37 <c_wraith> > liftM2 div (Just 5) (Just 0) `seq` ()
13:04:38 <lambdabot>   ()
13:04:40 <Cale> timtheli1n: As monochrom says, there's no general way to "completely evaluate" a structure.
13:04:53 <c_wraith> > liftM2 div (Just 5) (Just 0) `deepseq` ()
13:04:54 <lambdabot>   Not in scope: `deepseq'
13:04:57 <scooty-puff> there are things that come close, but require some cooperation
13:04:58 <scooty-puff> yep
13:05:02 <c_wraith> Cale: can lambdabot have deepseq?
13:05:05 <monochrom> there is some chance that $! (which is just seq) has weaker guarantees than evaluate
13:05:31 <lambdabot> i truely can.
13:05:37 <c_wraith> > liftM2 div (Just 5) (Just 0) `deepseq` ()
13:05:38 <lambdabot>   Not in scope: `deepseq'
13:05:42 <c_wraith> but not yet :)
13:06:54 <Cale> > liftM2 div (Just 5) (Just 0) `using` rdeepseq
13:06:55 <lambdabot>   *Exception: divide by zero
13:07:07 <monochrom> another disappointing point is that all of you are led astray by the unnecessarily long and special "a -> (a -> a) -> IO a" type. you should ask yourself first of all why it is not more generally "b -> (b -> a) -> IO a", and secondly why it is not simply "a -> IO a"
13:07:50 <monochrom> admittedly, "b -> (b -> a) -> IO a" would make sense in SML, but Haskell is not SML
13:08:08 <jfischoff> monochrome: so is the issue that because of laziness the f a might not actually evaluate where we are trying to catch it?
13:08:21 <monochrom> right
13:08:43 <monochrom> to a large extent, actually "return x" must refuse to evaluate x
13:08:51 <Cale> And even if we tell it to evaluate, it can produce a constructor applied to some still-unevaluated expressions containing errors.
13:09:14 <monochrom> (unless you absolutely want return to break a monad law in case of bottom)
13:09:33 <Cale> (and because of polymorphism, there's no way to pattern match that constructor and force those errors to be evaluated)
13:09:45 <jfischoff> right, but I guess I am confused why the `catch` is not dragged along.
13:09:52 <Taneb> May I be loud for a second?
13:10:08 <jfischoff> which is say I am confused by many things relating to laziness :)
13:10:18 <monochrom> the catch is fine. there is just nothing to catch
13:10:19 <scooty-puff> jfischoff: it is only catching "return", not the evaluation of a - maybe?
13:10:57 <jfischoff> so catch evaluates immendiantly?
13:11:18 <rwbarton> @type catch
13:11:19 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:11:28 <scooty-puff> @type Control.Exception.catch
13:11:28 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
13:11:33 <Cale> Evaluating (return undefined) doesn't produce an error.
13:11:33 <rwbarton> catch completes before the exception ever happens
13:11:37 <Cale> (at least for the IO monad)
13:11:40 <monochrom> you're writing "if 'x'=='y' then 0 else 1", getting 1, and asking the wrong question "why is my if-then-else not honoured". answer: your if-then-else is honoured.
13:11:41 <rwbarton> so, catch cannot catch the exception
13:11:48 <Cale> Only executing it and evaluating its result does.
13:12:34 <Cale> But then even executing   return [undefined]  and evaluating its result doesn't produce an error
13:12:46 <Cale> You have to take the head of the list and evaluate *that* to get the error
13:13:12 <Cale> Which you might not do, if you were only concerned with the length of the list, say.
13:13:37 <jfischoff> got it…for now
13:13:40 <jfischoff> :)
13:13:40 <shachaf> Taking the head of [] and evaluating it will also give you an error. :-)
13:14:31 <Cale> Taneb: What's this about being loud?
13:15:14 <timtheli1n> OK, finally got done reading.
13:15:15 <timtheli1n> :)
13:15:17 <Cale> Taneb: you're looking for a tutorial on Data.Serialize? (i.e. from cereal?)
13:15:41 <Eduard_Munteanu> I figure funny stuff could happen if we had an Agda construction like records and head would return 'SomeRecordConstructor undefined' for head ([] :: SomeRecordType).
13:15:45 <timtheli1n> So I'm pretty sure that scooty-puff is right with his catch, but I'm very concerned about Cale's statement about lists.
13:15:47 <Taneb> Cale, yes
13:15:50 <Eduard_Munteanu> *Agda-like
13:16:39 <Eduard_Munteanu> I mean, constructions where the compiler could assume the inhabitant must have a given form.
13:16:55 <jfischoff> timtheli1n: the conclusion of the conversation was that the catch wouldn't catch anything.
13:17:28 <jfischoff> timtheli1n: So I would say he was wrong and monochrome was right.
13:17:45 <Taneb> Cale, any suggestions?
13:17:45 <Cale> timtheli1n: Well, what are you trying to achieve?
13:17:48 <scooty-puff> timtheli1n: yeah, except unless forced, and even then, maybe not - would have to evaluate the entire structure
13:17:50 <scooty-puff> right
13:18:03 <Cale> Taneb: I honestly don't know, but you might also search for tutorials on using binary,
13:18:15 <Cale> because the two libraries are nearly identical in interface
13:18:48 <timtheli1n> Cale: I'm not sure how to explain without you understanding what my ThreadObjects are https://github.com/timthelion/gridhaskell-haskarrow/blob/master/ThreadObject.lhs
13:18:49 <Cale> The library itself is pretty straightforward to use
13:19:49 <c_wraith> Simon Peyton-Jones talks really fast
13:20:01 <Cale> Taneb: So if you look in http://hackage.haskell.org/packages/archive/cereal/0.3.5.1/doc/html/Data-Serialize.html
13:20:06 <ski> @quote SPJ
13:20:06 <lambdabot> SPJ says: will be a legend after his death
13:20:44 <jfischoff> @quote SPJ
13:20:45 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
13:20:45 <Cale> Taneb: you see that there's a class Serialize with two methods, get and put, and with a lot of instances for all sorts of basic datatypes
13:21:09 <Cale> Taneb: and then below that, you have encode and decode (and lazy ByteString versions of those)
13:21:37 <Taneb> Cale: okay?
13:21:50 <timtheli1n> Cale: A ThreadObject a signal, is a globaly mutable type. Where I have the function update :: ThreadObject a signal -> (a -> a) -> IO.  And I call update whenever a person presses a button in my GUI.  I want the function passed to update, to leave the ThreadObject's value as it was if the function passed by update fails.
13:21:56 <ski> @quote Sarah.Peyton.Jones
13:21:57 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
13:21:57 <Cale> Taneb: and those will, for any instance of the Serialize class, move between a ByteString containing binary data, and a proper datastructure of the appropriate type
13:22:11 <dgpratt> indeed, those SPJ quotes are appearing *very* quickly
13:22:14 <Taneb> How do I declare instances?
13:22:17 <Taneb> For Binary
13:22:18 <timtheli1n> Cale: so that when a person presses a button in the GUI and there is a bug, then instead of losing everything, nothing happens.
13:22:29 <Taneb> Or Serialize
13:22:41 <ski> (dgpratt : ?)
13:23:19 <dgpratt> ski: I was confirming the perception of c_wraith regarding the speed with which SPJ communicates
13:24:04 <timtheli1n> Cale: did I provide enough info on my use case?
13:24:06 <Cale> Taneb: Okay, so for that, you'll need to understand a little about how the Get monad and Putter monad work, but it's usually fairly straightforward and formulaic to encode things in terms of already existing instances (using get and put on another datatype)
13:25:20 <timtheli1n> Wait, I can explain it simply.  I have function f, that returns a new state for my object when a button is pressed.  If function f fails, I want to keep the old state, otherwise, I want the new state.
13:26:26 <dgpratt> I hate applications that appear to keep working when there has been an unanticipated error
13:26:33 <Cale> timtheli1n: I think perhaps! In my opinion error shouldn't be called in any case where you actually intend to be able to catch the error.
13:26:55 <Cale> timtheli1n: It's something which is theoretically possible to do, but which is unnecessarily fiddly.
13:27:03 <Cale> Do you have the user running arbitrary code?
13:27:28 <timtheli1n> Cale: yes, I do have the user running arbitrary code
13:27:50 <timtheli1n> Cale: think something an order of magnitude more chaotic than emacs :)
13:28:23 <Cale> timtheli1n: Okay, in that case, you should have a way to isolate the runtime errors. Are you using hint?
13:28:44 <Cale> (or the GHC API?)
13:29:12 <timtheli1n> Cale: well, I'm not evaluating.  The program is comipled.
13:29:26 * timtheli1n found emacs too slow.
13:29:44 <Cale> So the user inputs Haskell code which is compiled, and executes separately from the host program?
13:30:03 <Cale> Or have you written a complete Haskell interpreter?
13:30:23 <timtheli1n> Cale: No, the user inputs code, or downloads a non IO function from the web.  Recompiles and restarts, and then uses the function.
13:30:45 <timtheli1n> compilation is done with ghc
13:31:15 <Cale> So, the new user code is baked into the program itself? In that case, I don't think there's any way to make things safe.
13:31:25 <timtheli1n> :(
13:31:45 <Taneb> Thanks, Cale
13:31:48 <Cale> (and in some sense, there shouldn't be... what if the user wants the program to crash?)
13:31:53 <timtheli1n> even using safe haskell to block out unsafePreformIO?
13:32:19 <timtheli1n> Cale: that's somewhat unusual behavior.
13:32:24 <Cale> Taneb: sorry I have two conversations going on here... if you need help understanding how to write get/put instances, I can try to provide an example
13:32:34 <Taneb> Cale, nah, it's okay
13:32:42 <Taneb> Cale, I'm gonna go in a minute anyway
13:32:46 <Taneb> You've been great!
13:33:07 <timtheli1n> I just want to be able to assure the user that a function passed to update won't crash the program or even corrupt the data(I can prevent the later using type safety)
13:33:57 <timtheli1n> I'm not preventing the user from doing something outside of update that WOULD crash the program :)
13:34:53 <jfischoff> timtheli1n: if there is a top level run loop you should be able to put a catch there, but I could easily be wrong...
13:36:03 <timtheli1n> jfischoff: Well that's what I had hoped, and yes, I do have such a loop.  But Cale has just told us that if the value gets poisoned with an error somewhere inside a list, then we won't catch the error in time.
13:37:02 <jfischoff> timtheli1n: Like the program will crash before the catch happens?
13:37:21 <sclv> ok I have a dumb question about exponentials if anyone feels like clearing this up.
13:37:30 <timtheli1n> jfischoff: no, rather the program will crash AFTER I have stored the new state :/
13:37:38 <sclv> exponentials in the datatype sense, not the number sense.
13:37:43 <sclv> so data Unit = Unit
13:37:45 <sclv> is 1
13:37:51 <sclv> data Two = A | B is two
13:37:58 <Cale> timtheli1n: It's not that you won't catch it in time
13:37:59 <sclv> Two -> Two is an exponential
13:38:06 <sclv> that indeed has 2^2 possible values.
13:38:13 <Cale> timtheli1n: It's more that you'll try to catch it too early
13:38:26 <sclv> and Two -> Void has 2^0 possible values.
13:38:34 <rwbarton> 0^2
13:38:36 <Cale> timtheli1n: and it will escape in the result of your catch
13:38:39 <Kody> Anyone know what causes "lexical error at character '\DEL'"  -- the script runs fine, but get that error after compiling. (happens for EVERY script)
13:38:42 <Cale> without being detected
13:38:57 <sclv> rwbarton: oops. That answers my question!
13:39:01 <sclv> brain slip.
13:39:26 <sclv> I was going to ask how Two -> One could only have one value, and not 2^1 :-)
13:39:26 <timtheli1n> Cale: I also have a function sync :: a -> IO, which draws the value onto the screen.  If sync ends up drawing all of a, than would catching an error from sync, and reverting to the old state suffice, so long as sync truely looks at all of a?
13:39:29 <sclv> but its 1^2.
13:39:33 <sclv> facepalm.
13:40:36 <timtheli1n> Cale: It seems like I have run into a "problem" where I don't want laziness :)
13:40:47 <sclv> so relatedly, positive and negative data coincide over finite domains, right?
13:41:05 <sclv> actually, what's a good reference for negative types in general?
13:41:21 <sclv> is this something I only need to really bother with with dependent type theory?
13:41:29 <sclv> or could it ever matter in the haskell world?
13:41:51 <Cale> timtheli1n: Well, essentially, yeah. Consider how anything you might do to try to catch these errors would operate on an infinite list (with no errors in it)
13:43:02 <Cale> timtheli1n: This sort of thing is why people usually consider errors of the sort thrown by error and undefined to be semantically equivalent to nontermination.
13:43:11 <Cale> (They don't terminate, but they do it quickly)
13:43:15 <Cale> :)
13:43:20 <timtheli1n> Cale: :)
13:44:17 <ClaudiusMaximus> > 2^2^2^2  -- I wrote a fast zipWith :: Bits b => (Bool -> Bool -> Bool) -> b -> b -> b, analysing all 16 cases, but I don't think I'll bother with zipWith3 if it does have this many cases
13:44:18 <lambdabot>   65536
13:45:10 <timtheli1n> Cale: I think what I'll do, is I'll catch errors, both on update, and sync.  And tell the users, that if they NEED the guarantee, then they should do something like sequence a, somewhere in the sync(if a is a list) or some similar function if a is a tree, ect...  That would then ensure that the error gets thrown within the correct iteration of the update loop timeframe...
13:45:14 <ski> > iterate (2 ^) 0 !! 5
13:45:16 <lambdabot>   65536
13:45:27 <rwbarton> it's just 2^8
13:45:34 <rwbarton> not 2^2^2^2
13:45:48 <ClaudiusMaximus> rwbarton: ah ok, still, 256 is a long case statement :)
13:45:52 <rwbarton> (also, "just")
13:46:01 <Cale> timtheli1n: Yeah, if it's the user's responsibility to deepseq or whatever, then there's no problem.
13:46:39 <Cale> timtheli1n: There might actually be no problem with having partially defined values in that state, depending on what the user was doing with them.
13:47:07 <timtheli1n> Cale: I can do that.  Since the number of different types of a is relatively low.  In an image editor for example, we have one Image type, but many many Image -> Image functions that could fail!
13:47:09 <Cale> timtheli1n: After all, since your code has no idea what type those values are, there's not really any risk of your own code evaluating those errors, right?
13:47:58 <timtheli1n> Cale: but I want to make sure that when the user calls update, they will get something useable at the end, and not end up with broken data, not knowing where it broke...
13:48:15 <Cale> Well, it would have to be broken in their own code
13:48:41 <Cale> Since your code is polymorphic, unless it replaces the value with flat out undefined, there's nothing it could do to cause that problem.
13:50:06 <timtheli1n> I think, since almost all values of a, get esencially deapseq'ed by being drawn on the screen, I should be in the clear in almost all cases.  Thanks.
13:50:43 <Cale> timtheli1n: How do you draw completely arbitrary values on the screen?
13:51:02 <Cale> timtheli1n: Is there a typeclass here that you haven't been telling us about? :)
13:51:20 <timtheli1n> Cale: I don't draw them :) the person who defines a does :D
13:51:28 <Cale> oh, in that case, it's their problem
13:51:29 <ski> how ?
13:51:44 <timtheli1n> Cale: well it's my problem to do the error handling.
13:51:50 <Cale> Why is that?
13:52:04 <Cale> Provide the user a way to signal an error
13:52:09 <Cale> and leave it up to them to use it
13:52:27 <Cale> because there's no way that your code has of interacting with values of a type that it doesn't know
13:54:51 <timtheli1n> Cale: For a good example, look at line 235 of this file https://github.com/timthelion/gridhaskell-haskarrow/blob/master/GridDrawing.lhs
13:55:29 <timtheli1n> If gridSetDisplayCellText errors out, I don't want gridObject to be updated.  Otherwise I do want it to be updated.
13:56:22 <timtheli1n> The behavior that I want, is the same, however, regardles of what type of object I'm updating, and regardless of what function I'm using to update it.
14:00:43 <qnikst>     Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect
14:00:54 <qnikst> what to use instead of it?
14:01:37 <c_wraith> qnikst: was that from ghc or hsc2hs?
14:02:03 <qnikst> from ghc
14:02:24 <qnikst> The Glorious Glasgow Haskell Compilation System, version 7.4.1
14:02:38 <c_wraith> And I assume you're trying to interact with a native library?
14:02:41 <quicksilver> INCLUDE was deprecated in 6.10
14:02:56 <quicksilver> since then GHC just relies on direct use of the C ABI
14:03:04 <quicksilver> are you compiling some very very old code?
14:03:09 <quicksilver> or reading some old documentation?
14:03:13 <qnikst> c_wraith: yes
14:03:43 <c_wraith> qnikst: I'd strongly recommend using hsc2hs, at a minimum. and it *does* have an #include directive
14:03:55 <qnikst> quicksilver: bindings to libguestfs, last commit was 3 month ago
14:04:14 <quicksilver> well you could just ignore the warning.
14:04:23 <quicksilver> it doesn't mean compilation will fail.
14:04:27 <qnikst> ok
14:04:55 <qnikst> it fails but with Linking Guestfs010Basic ...
14:04:56 <qnikst> ./Guestfs.o: file not recognized: File truncated
14:05:09 <qnikst> collect2: ld returned 1 exit status
14:07:57 <quicksilver> probably not related
14:08:05 <quicksilver> (to the warnings, I mean)
14:08:18 <monochrom> disk full?
14:08:19 <timtheli1n> Why do I sometimes get foreign languages when I look something up on haskell's wiki? http://www.haskell.org/haskellwiki/Data
14:09:30 <hpc> timtheli1n: because fromage fromage chateaux gracias
14:09:33 <qnikst> quicksilver: I'm also think so
14:09:50 * ski thought it wasn't pentecost yet ..
14:10:07 <hpc> timtheli1n: probably lack of editing guidelines for that sort of thing
14:10:10 <monochrom> because no one in the English-speaking world cares about haskell wiki anymore
14:10:15 <hpc> or just people breaking the guidelines
14:10:48 * timtheli1n notes that he wasn't complaining about there BEING foreign language docs.  Just that they wheren't seperated in some logical fassion.
14:11:07 <timtheli1n> I was just woried that it was trying to autodetect my language for me.
14:11:20 <quuxman> is there a UI library for mouse events? I want to register a callback that's called when a given region (that moves around) is clicked
14:11:35 <timtheli1n> Since I lie about my locale, in order to preform better ad blocking :D
14:12:11 <timtheli1n> I tell everyone I'm spanish, then block everything in spanish. which works great :D
14:12:25 <hpc> timtheli1n: haha
14:17:40 <quuxman> looks like cabal has changed somewhat since I last developed Haskell. What's with this error? setup: The pkg-config package glib-2.0 is required but it could not be found.
14:17:46 <xil> hey everyone. Can I put type declarations in the where clause of a function?
14:17:51 <quuxman> (on running: cabal install gtk)
14:18:12 <monochrom> it means it can't find the C-side files
14:18:36 <quuxman> so I just need some -dev packages
14:18:40 <byorgey> xil: yes
14:18:42 <ski> xil : unfortunately not (in current implementation)
14:18:54 <ski> byorgey : oh, they've added it recently ?
14:19:00 <byorgey> xil: oh, do you mean like   type Foo = Bar, or data Foo = ... ?
14:19:04 <xil> type
14:19:09 <byorgey> or do you just mean  foo :: SomeType; foo = ...
14:19:16 <xil> type Foo = Bar
14:19:18 <ski>   foo x = ..
14:19:20 <ski>     where
14:19:23 <byorgey> ok, sorry, I misunderstood your question.  No, you can't.
14:19:26 <ski>     type Bar = ...
14:20:02 <xil> okay, darn. Thanks
14:20:05 <ski> xil : there's nothing really wrong with the idea, given some suitable restrictions (the interesting ones are on instances)
14:20:18 <ski> it's just that nothing like that is implemented
14:20:36 <ski> (btw, it is possible in the MLs)
14:20:37 <xil> I just wanted to limit the scope, but really it only matters to hide it from imports
14:20:44 * ski nods
14:20:46 <JoeyA> > 3 `mappend` 5
14:20:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:20:47 <lambdabot>    `Data.Monoid.Monoid a'
14:20:47 <lambdabot>  ...
14:20:52 <JoeyA> > 3 `mappend` 5 :: Int
14:20:53 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:20:53 <lambdabot>    arising from a use of...
14:21:25 <ski> xil : i've wanted to do that sometimes as well, for "temporary types" (especially as then i could have avoided two or three parameters of the types
14:21:26 <ion> > Sum 3 `mappend` Sum 5
14:21:28 <lambdabot>   Sum {getSum = 8}
14:21:35 <zoolotto> Birds with lights like bikes
14:21:37 <JoeyA> Ah, newtype wrappers.
14:22:00 <JoeyA> I forgot about those in Data.Monoid
14:22:11 <ski> > Last (Just 3) `mappend` Last (Just 5)
14:22:12 <lambdabot>   Last {getLast = Just 5}
14:22:35 <xil> ski: yeah I have a bunch of functions in the where of another that have  the type "H.MinPrioHeap Int ( Int, ( Int, Int, Int, Int ))" and writing that a lot is annoying
14:22:53 <xil> well not that type totally, but that in their type declaration
14:24:40 <ion> > let toAvg x = (Sum x, Sum 1); getAvg (Sum x, Sum n) = x/fromIntegral n; avg = foldMap toAvg in getAvg (avg [5,15,25] `mappend` avg [0,10,30])
14:24:41 <lambdabot>   Not in scope: `foldMap'
14:24:48 <ion> > let toAvg x = (Sum x, Sum 1); getAvg (Sum x, Sum n) = x/fromIntegral n; avg = Data.Foldable.foldMap toAvg in getAvg (avg [5,15,25] `mappend` avg [0,10,30])
14:24:49 <lambdabot>   14.166666666666666
14:25:41 <ion> forgot 20. `mappend` toAvg 20. :-P
14:26:58 <quuxman> but this is an old familiar error: System/Glib.hs:1:1: Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.1
14:27:04 <quuxman> can't believe that's still plaguing cabal
14:28:10 <monochrom> eh? I haven't encountered that for years. cannot reproduce.
14:28:47 <quuxman> I am using debian. Probably everybody here is using Ubuntu. Isn't there a batteries included distribution of ghc that already has gtk and whatnot?
14:29:15 <ion> monochrom: I’m sorry to hear that. Did you want children?
14:29:23 <Clint> quuxman: probably everything you want is already packaged for debian
14:29:24 <monochrom> haha
14:29:55 <monochrom> anyway, gtk-0.12 built just fine here at ghc 7.0.3
14:32:08 <hpc> i had a similar issue last week that i resolved with a cabal update
14:32:31 <hpc> which made a wonky dependency work itself out
14:33:43 * timtheli1n thought that leksah would finally build on gtk 7.4.1, but gtksourceview2 already got broken on arch :), as soon as one thing gets updated and fixed(leksah) another thing becomes out of date.  The two packages missed eachother by weeks I think.
14:33:55 <monochrom> well, I guess it's ghc 7.4's change to haskell98 that causes the conflict. gtk.cabal was written before ghc 7.4
14:34:41 * timtheli1n can't wait to try leksah, as he is writting a type of IDE himself.
14:35:05 <EvanR> unix is an integrated development environment ;)
14:35:07 <monochrom> and glib.cabal. now I wonder why glib.cabal wants both base and haskell98
14:35:44 <timtheli1n> EvanR: I'm not saying that I would use leksah, for me scribes(text editor) and bash work pretty darn well.  But I'd still like to take a look.
14:36:00 * timtheli1n forgot to mention xmonad, an integral part of the IDE)
14:36:22 <EvanR> speaking of which i havent looked at manatee yet
14:36:47 <hpc> is manatee still maintained?
14:36:52 <hpc> preflex: seen manateelazycat
14:36:52 <preflex>  manateelazycat was last seen on #haskell 48 days, 7 hours, 2 minutes and 26 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
14:37:11 <EvanR> the chinese government may have gotten him
14:37:19 <EvanR> hes too productive and creative
14:37:24 <quuxman> I think I have a very old version of cabal
14:37:26 <monochrom> no, a bank did
14:37:34 <hpc> monochrom: oh god, that's even worse
14:37:40 <EvanR> yes, it is
14:37:42 <byorgey> quuxman: what version?
14:38:27 <byorgey> for ghc-7.4 you need gtk-0.12.3 .
14:38:37 <timtheli1n> If I had any money, I'd invest in whatever bank employs dons and the like.
14:39:05 <byorgey> quuxman: also, have you done 'cabal update' recently?
14:44:23 <dixie> hmm, I read some slideset about monad-par and there was comment about function parMapChunk - like should be part of library but isn't. Why it isn't included ?
14:46:21 <dixie> Is that because it is not desired to have method which expect as an input chunk size but rather something more smart which calculates the chunk depending on cpu count ?
14:46:41 <timtheli1n> How could something as cool as manatee get abandoned :(
14:53:13 <cydergoth> Afternoon. Does anyone know what is going on with the version of Leksah on Hackage? It seems to be b0rked
14:53:39 <bitonic> cydergoth: what sort of problems are you having?
14:53:55 <cydergoth> Dependency problems with leksah-server, and cabal
14:54:11 <bitonic> cydergoth: your best shot is to paste the errors and seee
14:54:14 <bitonic> @hpaste
14:54:14 <lambdabot> Haskell pastebin: http://hpaste.org/
14:54:18 <bitonic> here ^^^
14:54:49 <hpaste_> jacrisp pasted “leksah errors” at http://hpaste.org/67894
14:55:01 <cydergoth> http://hpaste.org/67894
14:55:56 <cydergoth> cabal was just re-installed with cabal install cabal && cabal install cabal-install
14:56:07 <cydergoth> So should be the latest version
14:56:34 <bitonic> cydergoth: what version of GHC/HP?
14:56:50 <cydergoth> 7.03
14:57:00 <bitonic> also, installing cabal-install manually is not a good idea (should work, but you shouldn't need to)
14:57:24 <bitonic> cydergoth: any particular reason why are you not installing it from hackage directly?
14:57:40 <cydergoth> I tried that first, then got the same errors
14:57:58 <bitonic> cydergoth: anyways, that is not the last version of cabal-install
14:58:13 <bitonic> I'm not sure what to do here, but installing the last version of GHC will most likely solve that problem
14:58:21 <cydergoth> oh, I did a cabal update first
14:58:30 <cydergoth> Ok, so a GHC update then update cabal?
14:58:31 <bitonic> dcoutts can probably help you better
14:58:59 <bitonic> cydergoth: I'm not sure you *need* to do that, but that'll definitley bring you to the latest cabal version. you don't need to upgrade cabal it ships with GHC
14:59:12 <bitonic>  how did you install GHC?
14:59:37 <cydergoth> I'm on Ubuntu, so the system version is old. I compiled it myself
14:59:56 <bitonic> cydergoth: uhm, then you can just remove the version you installed and install the latest
15:00:04 <bitonic> cydergoth: I'd suggest to just grab the latest binaries
15:00:27 <cydergoth> Ok, I'll look into that
15:00:32 <cydergoth> thx
15:00:35 * timtheli1n also cannot install leksah :)
15:01:09 <bitonic> since Hackage can build it, I'm confident that it'll work with a stock GHC 7.4
15:01:11 <hpaste_> timthelion pasted “leksah errors ” at http://hpaste.org/67895
15:01:27 <mekeor`> timtheli1n: yea, leskah seems to need ghc 6 or so… IIRC.
15:01:38 <mekeor`> (there's #leskah (or so), btw..)
15:01:54 <cydergoth> I had Leksah 10 running on ghc 7.0.3 or so I believe
15:01:58 <bitonic> mekeor`: http://hackage.haskell.org/package/leksah says "Built OnionKnight ghc-7.4"
15:02:08 <timtheli1n> mekeor`: who's users are a very small subset of the users on #haskell :)
15:02:11 <tazjin> mekeor`: Leksah, it's Haskell with one l backwards ;-)
15:02:12 <bitonic> I don't know where "OnionKnight" came from.
15:02:31 <hpaste_> pqmodn pasted “problematic "Rigid type variable"” at http://hpaste.org/67896
15:02:34 <mekeor`> timtheli1n: true.
15:02:36 <mekeor`> bitonic: ah.
15:02:37 <EvanR> tazjin: i never realized that
15:02:49 <mekeor`> tazjin: i know. an dit's an editor.
15:03:14 <pqmodn> i'm trying to define map on church-encoded lists (http://hpaste.org/67896) but i'm not sure how to correct the type error
15:03:28 <mekeor`> > let f l = tail . reverse in f "haskell"
15:03:29 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
15:03:30 <lambdabot>    arising from a use ...
15:03:37 <mekeor`> > let f = tail . reverse in f "haskell"
15:03:39 <lambdabot>   "leksah"
15:03:51 <pqmodn> my map isn't actually doing any mapping, i tried simplifying it to a -> a
15:04:11 <pqmodn> but changing to SList a -> SList b and calling f generates the same error
15:06:04 <pqmodn> if hpaste isn't showing a type error, could it be specific to my version of GHC (7.0.4)?
15:07:13 <monochrom> people seem to really like compiling compilers themselves, and it seems to be beyond the XY Problem
15:08:13 * timtheli1n thinks manatee looks really cool, and is amazed that it didn't take over the world.
15:08:23 <Mathnerd314> ClaudiusMaximus: you could generate it with template haskell
15:08:25 <c_wraith> monochrom: a lot of people believe any software they compile themselves is magically faster than pre-built binaries
15:09:13 <bitonic> @google gentoo ricers
15:09:15 <lambdabot> http://funroll-loops.info/
15:09:15 <lambdabot> Title: Welcome to Gentoo is Rice, the Volume goes to 11 here.
15:09:23 <monochrom> that certainly applies to the gentoo people, but the phenomenon is much wider than that
15:09:25 <timtheli1n> c_wraith: It is if you are running it on a 128 bit Sun server, and the only precompiled binaries are i686 :D
15:09:51 <monochrom> "I'm on ubuntu 10.04, therefore I must build GHC myself" is the more common XY Problem here
15:10:31 <stilgart> (I can't believe that ubuntu does not provide ghc as a package)
15:10:34 <bitonic> cydergoth: FWIW, I just installed leksah with GHC 7.4
15:10:34 <Clint> it does
15:10:35 <cydergoth> The ubuntu packages were well out of date at one point, and by compile I should have said 'install'
15:10:37 <bitonic> stilgart: it does
15:10:47 <cydergoth> bitonic, In the process of doing it myself
15:10:47 <monochrom> oh, ubuntu does, just usually old
15:10:52 <timtheli1n> bitonic: what distro do you have?
15:11:03 <bitonic> timtheli1n: ubuntu 12.04
15:11:10 <Clint> http://packages.ubuntu.com/search?keywords=ghc
15:11:14 * timtheli1n uses arch, but is looking to move somewhere else as he has too many problems with things not building.
15:11:29 <bitonic> cydergoth: the only annoyance will probably be installing gtk2hs.
15:11:38 <bitonic> you also need the gtksourceview2 dev libs
15:11:40 <cydergoth> the latest precise pangolin package of ubuntu is 7.4.1, so if you're on that you should be ok (I am)
15:11:41 <timtheli1n> Is ubuntu the defacto distro for haskell?
15:11:45 <blackdog> cydergoth: it's all much better on pangolin.
15:11:47 <monochrom> don't move, pasture not greener elsewhere, actually yellower
15:12:00 <cydergoth> ha blackdog you beat me to it ;-)
15:12:01 <timtheli1n> monochrom: what do you use?
15:12:16 <napping> installing your own compilers is often the only way to get tolerably recent versions
15:12:22 <monochrom> arch is closer to the de facto distro for haskell because dons put in work
15:12:25 <stilgart> timtheli1n: your favorite distro is
15:12:33 <ClaudiusMaximus> Mathnerd314: true i guess - though i don't care enough, and i'd rather use a static generator so the package still works with hugs
15:12:37 <timtheli1n> monochrom: 9 months ago it was :/
15:12:43 <bitonic> cydergoth: I don't care I always go with the binaries anyways
15:12:59 <bitonic> cydergoth: so I can have multiple versions
15:13:04 <bitonic> (of GHC)
15:13:12 <timtheli1n> the current AUR packages don't build, since ghc has changed.
15:13:24 <monochrom> but I just use ubuntu.
15:14:09 <jnials> I just gave up on ArchHaskell, trying the build your own route right now.
15:14:17 * jnials crosses fingers.
15:14:40 <timtheli1n> jnials: building your own what?
15:14:52 <jnials> haskell toolchain.
15:15:02 <bitonic> jnials: why?
15:15:05 <bitonic> actually, what?
15:15:07 <luis> I'm looking for a lexer in Haskell. I've found alex. Are there any alternatives I should be aware of?
15:15:17 <EvanR> parsec?
15:15:21 <bitonic> just get the nice GHC generic binaries people. Never had a problem with them.
15:15:21 <timtheli1n> jnials: that doesn't help, when half the packages use the old ghc, and half the packages use the new.  You get conficts none the less
15:15:27 <EvanR> attoparsec
15:16:31 <jnials> I was trying to get leksah to work, no dice.  Got the generic binaries .704 binaries and the 2011.11.04 platform and installing them now.
15:16:37 <monochrom> "I build my own linux distro"
15:17:12 <Clint> in debian you just apt-get install leksah
15:17:15 <bitonic> jnials: do you mean 7.0.4 or 7.4?
15:17:22 <monochrom> "last time I tried slackware, I said to it: you have failed me for the last time!"
15:17:42 <jnials> Sorry, 7.0.4.  Typing and working at the same time.
15:18:11 <bitonic> jnials: at this stage, I think getting 7.4 is a better choice
15:18:19 <luis> EvanR: so, either alex+happy or attoparsec?
15:18:26 <EvanR> i only use slackware when i dont feel like building my own distro
15:18:28 <timtheli1n> Clint: I used debian for about 6 months years ago, and got annoyed with all the packages being like 3 years old.  Has it gotten better in that regard, does it have say gnome3 or anything?
15:18:41 <Clint> timtheli1n: as long as you're not running stable, sure
15:18:57 <jnials> bitonic:  Probably, but I'm just trying to learn haskell at this point.
15:19:18 <hpc> timtheli1n: debian testing is a good months-old distro
15:19:27 <timtheli1n> Clint: and is leksah worth changing distro's for(changing distros=apx 7 hours work)
15:19:35 <jnials> Once I get the basics down, I'll worry about fine-tuning the versions.
15:19:43 <hpc> or if you don't mind being insane, debian unstable
15:19:47 <Clint> timtheli1n: i don't know; i've never tried it
15:19:50 <cydergoth> at least cabal has some dependency management, I remember the bad old days of doing this sort of stuff with random C files and no dependency information
15:20:16 <cydergoth> sccs without changesets *shudder*
15:20:28 * timtheli1n wonders if with testing he wouldn't have the same exact problem as with arch.
15:20:37 <Clint> which problem is that?
15:20:43 <alpounet> what was the problem with arch?
15:20:45 <timtheli1n> hpc: arch linux IS debian unstable, is it not?
15:21:07 <hpc> timtheli1n: no, arch has its own policy on packaging
15:21:23 <hpc> ubuntu basically took debian testing and changed the default packaging, if you need a baseline
15:21:36 <timtheli1n> hpc: I was joking.  But the arch devs just package everything the day it's released, and never test it.
15:21:40 <hpc> ah :P
15:22:10 <hpc> timtheli1n: yeah, if i wanted messy packaging i would use gentoo :D
15:22:13 <EvanR> and the arch users upgrade that day
15:22:19 <EvanR> and their linux stops working
15:22:23 <timtheli1n> http://hpaste.org/67895
15:22:35 <jnials> Not quite as bad as that.  But when you get off the mainline stuff it can get messy.
15:22:39 <timtheli1n> that's the trouble with arch today.  But tomorrow, the trouble will be different
15:22:43 <monochrom> ubuntu devs do their own testing
15:22:56 <timtheli1n> btw, that was actually cabal install leksah, somehow I got cut off
15:23:18 <hpc> timtheli1n: "fatal erre"?
15:23:19 <timtheli1n> EvanR: yep :)
15:23:39 <timtheli1n> hpc: let me see if I can't repaste non trucated
15:24:04 <hpc> timtheli1n: it almost looks like you took a screenshot of a terminal and OCR'd it
15:24:09 <jnials> And ArchHaskell is not part of the main dev tree.
15:24:21 <cydergoth> bitonic, I was under the impression that using cabal install was the 'official' way to install haskell packages
15:24:28 <cydergoth> Is that not the case?
15:25:31 <bitonic> cydergoth: it is, did I state differently?
15:25:34 <notthemessiah> anything else seems to be a road to dependency hell in arch
15:25:55 <timtheli1n> hpc: It's because I'm using a large font on gnome-terminal(because I'm a little tiny bit dyslexic, and don't like small fonts), and gnome-terminal doesn't like the fact that there are only 50 characters to the row...
15:26:24 <hpaste_> timthelion annotated “leksah errors ” with “leksah errors  (annotation)” at http://hpaste.org/67895#a67898
15:26:44 <timtheli1n> "adresař neexistuje" == the address doesn't exist...
15:27:02 <hpc> timtheli1n: eek
15:27:21 <timtheli1n> eek what?
15:27:31 <hpc> it's a very unhappy error
15:27:41 <cydergoth> bitonic, you just seemed to be suggesting that getting the binaries is a better option
15:27:43 <hpc> ima try and install it myself
15:27:43 <timtheli1n> what does it mean?
15:27:47 <bitonic> timtheli1n: install libgtksourceview2.0-dev
15:27:47 <hpc> this debian vm just finished cloning
15:27:53 <cydergoth> But I usually only do that for the platform
15:27:59 <bitonic> well, `apt-get install libgtksourceview2.0-dev'
15:28:02 <hpc> timtheli1n: some file it needs doesn't exist
15:28:07 <bitonic> cydergoth: the GHC binaries
15:28:12 <timtheli1n> hpc: I got that part
15:28:38 <cydergoth> Yes, that's what I do. I probably should have put installed in my orginal command and then this whole thread wouldn't have happened ;-~
15:29:16 <hpc> cloned the wrong vm...
15:29:37 <hpc> timtheli1n: yeah, bitonic's suggestion will likely fix it
15:31:14 <timtheli1n> hpc: I already have http://www.archlinux.org/packages/extra/x86_64/gtksourceview2/files/ which includes usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h
15:32:34 <pqmodn> hmm, i solved my problem by using newtype (fwiw)
15:33:44 * timtheli1n wonders if there is a way to tell cabal to look for a different file...
15:36:04 <hpc> timtheli1n: was about to suggest making sure it's on your PATH, but it definitely should be if it's in /usr/include
15:36:33 <timtheli1n> hpc: well the difference is between gthsourceview.h and gtksourceview2.h :(
15:36:53 <timtheli1n> the little number 2 is the bugger.
15:37:13 <hpc> timtheli1n: ah, try a symlink then
15:37:30 <hpc> ln -s /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview.h /usr/include/gtksourceview-2.0/gtksourceview/gtksourceview2.h
15:37:45 <timtheli1n> hpc: you're so smart, didn't think of that
15:37:57 <hpc> heh, not my trick
15:38:06 <hpc> and i happened to have symlinks on the mind...
15:38:56 <hpc> timtheli1n: you should also try emailing the maintainer of that arch package
15:39:27 <cydergoth> I think I've just hit the same 2.h problem on Ubuntu as well
15:39:43 <hpc> curious
15:39:58 <cydergoth> dist/build/Graphics/UI/Gtk/SourceView/Types.h:1:28: fatal error: gtksourceview2.h: No such file or directory
15:40:22 <cydergoth> I have the libgtksourceview2.0-dev package installed
15:40:56 <timtheli1n> hpc: it's not his problem, I looked at the PKGBUILD file(the file he used to build gtksourceview2.0 and he didn't do ANYTHING unusual, just make, make install.
15:41:10 <hpc> hmm
15:41:24 <hpc> the gtksourceview repo uses a different file layout, it seems
15:41:48 <hpc> oh, or it uses the same one
15:42:02 <hpc> and it's a 2-yo file
15:43:08 <timtheli1n> the question I have is "who owns this Types.h"
15:43:14 * hpc can't tell which is the "right" filenmae
15:43:18 <hpc> filename, even
15:43:54 <hpc> timtheli1n: gtksourceview
15:43:58 <timtheli1n> I think that the correct one must be the one without the number, since it's the one used by http://ftp.gnome.org/pub/gnome/sources/gtksourceview/2.10/gtksourceview-${pkgver}.tar.bz2
15:44:01 <cydergoth> ok, got it
15:44:15 <hpc> i think
15:44:20 <cydergoth> gtksourceview2.h is in the haskel package, not /usr/include
15:44:24 <timtheli1n> hpc: so gtksourceview is in conflict with itself about naming?
15:44:50 <timtheli1n> cydergoth: hm?
15:44:52 <cydergoth> It is a small include file which includes all the /usr/include ones
15:45:05 <timtheli1n> cydergoth: and where is it?
15:45:12 <hpc> hackage's build failure is inherited from depends :/
15:45:35 <cydergoth> cabal unpack gtksourceview2-0.12.3
15:45:38 <cydergoth> It is in there
15:45:49 <timtheli1n> cydergoth: and now what?
15:46:10 <cydergoth> So I'm guessing the .cabal file needs to specific an include directory within the package?
15:47:07 <cydergoth> Ah, x-c2hs-Header: gtksourceview2.h - so looks like an c2hs issue?
15:47:18 * timtheli1n is reminded of the fact that he spend today reading about Russels paradox...
15:48:08 <EvanR> include all directories that dont include themselves
15:49:39 <timtheli1n> EvanR: exactly :)
15:53:49 <quuxman> @hoogle getArgs
15:53:50 <lambdabot> System.Environment getArgs :: IO [String]
15:53:50 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
16:01:44 <cydergoth> timtheli1n, dunno, this looks like gtk2hs problem, I don't know nuffing about that
16:02:12 <timtheli1n> cydergoth: OK, thanks for lookin into it.
16:02:53 <cydergoth> It looks to me like the generated files are trying to load that header file, but the compiler isn't locating it even tho' it is in the package
16:03:00 <cydergoth> this is cabal magic I think
16:03:35 * ski . o O ( `not (knows cydergoth (not (exists thing. about thing that)))' )
16:05:15 <cydergoth> x-c2hs-Header seems to be the important directive but google isn't telling me anything useful abotu it
16:08:10 <gwern> haha. '  Maybe use some other repo for the hello world example?   $ darcs get http://darcs.net darcs  is too many darc.  Using darcs to check out darcs and commit a file named darcs.cabal just conflates too many things unnecessarily.'
16:08:20 <gwern> I like to say darcs. darcs darcs darcs darcs darcs!
16:08:25 * jnials thinks he better stick with emacs and forget anything interesting in haskell unless he wants to reinstall his laptop.
16:08:50 <cydergoth> jnials, I'm starting to think you're right....
16:10:59 <alpounet> jnials, not managing to install leksah?
16:11:25 <jnials> Nope.  Same issue timtheli1n is running into.
16:11:26 <timtheli1n> jnials: you really don't need leksah to program haskell :)
16:12:28 <timtheli1n> perhaps we should have googled. http://hackage.haskell.org/trac/gtk2hs/ticket/1260
16:12:48 <timtheli1n> jnials: that should fix it
16:12:58 <bitonic> so wait did I get lucky with this gtksourceview2 thing? it worked for me, on ubuntu
16:13:38 <cydergoth> now why didn't that show up when I googled it?
16:14:15 <bitonic> btw, emacs + ghc-mod is the best way to write Haskell :)
16:14:32 <hpc> bitonic: piffles
16:14:42 <timtheli1n> cydergoth: no clue?
16:14:48 <hpc> side-by-side terminals of vim and ghci
16:14:50 <bitonic> hpc: it's true.
16:15:16 <cydergoth> I'd just got to the point where I'd figured that out as well ;-~
16:15:41 <cydergoth> bitonic maybe you had a version already installed?
16:15:52 <blackdog> bitonic: +1
16:16:09 <timtheli1n> $ cabal configure --extra-include-dirs=. gtksourceview2
16:16:09 <timtheli1n> cabal: No cabal file found.
16:16:09 <timtheli1n> Please create a package description file <pkgname>.cabal
16:16:12 <bitonic> cydergoth: no, I installed it now
16:16:13 <timtheli1n> sigh
16:16:31 <bitonic> cydergoth: both the dev headers and the normal one
16:16:32 <cydergoth> timtheli1n: cabal install  --extra-include-dirs=. leksah
16:16:34 <blackdog> although it's a bit frustrating when you hit weird glitches - if you build ghc-mod with eecutable profiling, everything dies.
16:16:50 <cydergoth> bitonic, I mean the haskel package
16:17:23 <bitonic> cydergoth: I installed everything now :P
16:18:38 <cydergoth> emacs +fhc-mod looks like a nice combination
16:18:58 <cydergoth> Ok, I'm off now, thanks for the help people
16:18:59 <cydergoth> ttfn
16:19:00 <blackdog> cydergoth: if you're a vim type, i believe ghc-mod works well there too.
16:19:20 <cydergoth> No, I'm an emacs guy all the way
16:20:33 <jnials> Oh, and that last bit was the last thing I needed.
16:20:56 <timtheli1n> jnials: worked?
16:21:01 <jnials> Yup.
16:21:10 * timtheli1n is still building
16:21:16 <timtheli1n> you must have a faster system than me.
16:22:20 <jnials> Yeah, my work laptop smokes.  8 cores, 8G ram.
16:22:43 <timtheli1n> WTF!!! WOW! didn't know there were 8 core laptops...
16:23:03 <jnials> Stinkpad with an intel i9 processor.
16:23:28 <blackdog> jnials: w520?
16:23:47 <jnials> I use it to w510.  I got one of the last 510's before they put out the 520's.
16:23:49 <blackdog> there was a recent Thinkpad that could take 32gb of ram...
16:24:19 <jnials> Mine will take 16G.  I'll probably convince my boss to let me upgrade soon.
16:24:19 * hayashi is trying and failing badly, due to not getting types 100%, to make a polymorphic type ( Database -> m a ) -> m a for any combination of m and a
16:24:28 <timtheli1n> but probably not a tablet ;)  I was just looking at the newer tablets, and they weren't any better than the one I've got now :/
16:24:51 <hayashi> (where m must be a MonadIO)
16:25:02 <hayashi> If that's even _possible_ >~>
16:25:26 <hpc> what's your Database type?
16:25:26 <hayashi> Which I'm beginning to suspect could possibly not be the case.
16:25:37 <acowley> hayashi: can m be a MonadPlus?
16:27:03 <hayashi> Database is the one from haskelldb; m seemingly can't be a MonadPlus (as both IO and ErrorT String IO need to satisfy m at the moment)
16:27:59 <acowley> How about Database -> m (Maybe a)?
16:29:02 <quuxman> @hoogle GLfloat
16:29:02 <lambdabot> No results found
16:30:00 <bitonic> @hackage OpenGL
16:30:00 <lambdabot> http://hackage.haskell.org/package/OpenGL
16:30:03 <bitonic> quuxman: ^^^
16:31:08 <hayashi> acowley: Has to be an instance of MonadIO.  Basically I'm trying to stuff the result of http://hackage.haskell.org/packages/archive/haskelldb-hdbc-postgresql/2.1.0/doc/html/Database-HaskellDB-HDBC-PostgreSQL.html into a general type synonym
16:31:20 <hayashi> Thinking about it, I'm almost certainly going about this the wrong way
16:31:53 <acowley> Ah, that is quite different
16:31:58 <quuxman> I have a little helper like so: vertex2f :: Float -> Float -> IO (); vertex2f a b = vertex $ Vertex2 a b
16:32:12 <quuxman> Apparently there have been some minor changes in types, because that used to work, and is now producing a type error
16:32:46 <hayashi> because surely if I'm storing the result of that and then trying to use it for two different monads one after the other then actually I can't see how that'd work out
16:32:47 <quuxman> No instance for (VertexComponent Float). Now there is only a GLfloat instance for VertexComponent
16:32:52 <hayashi> *shrug*
16:33:15 <hayashi> let's just peg it at "I have no idea what I'm doing" and leave it there
16:33:40 <acowley> quuxman: you need to do realToFrac
16:33:43 <quuxman> however, GLfloat is defined in Graphics.Rendering.OpenGL.Raw.Core31.TypesInternal, and that doesn't look like something I'm supposed to import
16:33:50 <acowley> quuxman: On the a and b
16:33:58 <quuxman> ah thanks
16:34:24 <acowley> quuxman: The change was GLfloat and friends going from type synonyms to newtypes.
16:34:54 <acowley> For Float you can actually get away with unsafeCoerce, but someone will probably frown at a kitten for me having said that.
16:35:04 <hayashi> the thing I'm trying to use ends up having the type ((Database -> m a) -> m a), or should do, and then I'm trying to pass that to one function as ((Database -> ErrorT String IO a) -> ErrorT String IO a) and to another one as ((Database -> IO a) -> IO a)
16:35:21 <hayashi> which now that I'm writing it sounds like there's something worse afoot in the general concept of what I'm trying to do, because that sounds silly
16:36:12 * hayashi should probably work on coercing the latter function to work with ErrorT String IO a because not doing so is making things hurt
16:37:14 <hpc> hayashi: start by writing a function of type (Database -> IO a) -> IO a
16:37:46 <hpc> hint: you'll need some value of type Database to start with
16:37:56 <hpc> or a way to get one
16:39:59 <hayashi> I can probably just make the existing plumbing work if I can coax something that returns IO a to lift up to ErrorT String IO a
16:42:42 <quuxman> acowley: now I get an ambiguous type error
16:43:34 <acowley> quuxman: because it doesn't know you want GLfloats
16:43:40 <hayashi> Hmm, the function I'm using to create the ((Database -> m a) -> m a) automatically infers to ((Database -> IO a) -> IO a) as soon as it touches a function wanting that, and then breaks when passed through to something wanting m to be ErrorT String IO
16:43:51 <hayashi> I'm not sure if this is standard behaviour or doing polymorphism wrong
16:43:53 <acowley> quuxman: you can just stick an annotation on one parameter, e.g. (realToFrac a :: GLfloat)
16:44:29 <quuxman> ah, I need both realToFrac and a new type annotation like I had before. So I should import GLfloat from which module?
16:44:31 <acowley> quuxman: That whole interface is quite frustrating to use, btw. You're not doing anything wrong.
16:44:43 <acowley> GLfloat is in scope with whatever the standard OpenGL import is
16:44:45 <quuxman> acowley: good to know. That's why I'm making these little helper functions
16:44:48 <acowley> Graphics.Rendering.OpenGL or something
16:45:53 <acowley> Note that the type is in scope, but the constructor is still hidden.
16:46:08 <hayashi> Splitting the function into two calls to the same thing, one passed to the first thing and another passed to the second, works.
16:46:28 <quuxman> cool it works now
16:49:00 <ski> hayashi : .. is this `((Database -> m a) -> m a)' thing an argument ?
16:49:37 * ski thinks hayashi maybe wants Rank2Types here
16:52:12 <ski> hayashi : i suspect you want `forall m. Monad m => (Database -> m a) -> m a' as type for this thing
16:52:23 * hayashi checks a thing
16:52:32 <hpc> (MonadIO)
16:52:50 <ski> hm, could be `MonadIO' instead, yes
16:53:32 <hayashi> I'd actually put that on the returning function, but to seemingly no avail
16:53:52 <hayashi> er, wait
16:54:10 <hayashi> the function that I'm calling to return that (Database -> m a) -> m a function.
16:56:14 <hayashi> The result of that's still going straight to Database -> IO a as soon as it hits the first function that uses it, and then causes a massive trip-up when the same function is passed to something that uses it as Database -> ErrorT String IO a
16:58:28 <fragamus> i love Data.Map it is so well done
17:04:54 <hayashi> ski: needless to say, still getting the likes of Couldn't match expected type `ErrorT String IO TableDesc'
17:04:54 <hayashi>            against inferred type `IO TableDesc'
17:04:57 <hayashi> damn enter key
17:05:17 <hayashi> Blech, why did I think using ErrorT was a good idea
17:05:54 <jfischoff> ErrorT is a bad idea? There is an alternative?
17:06:11 <c_wraith> ErrorT has an unfortunate dependence on Error
17:06:40 <jfischoff> c_wraith: go on.
17:07:08 <c_wraith> The error class has the strange assumption that you want to be able to convert arbitrary strings to errors.
17:07:18 <c_wraith> And ErrorT is based on that class
17:08:24 <hayashi> Welp, ( forall m. MonadIO m => ( Database -> m a ) -> m a) definitely isn't holding up its end of the bargain
17:08:36 <ski> hayashi : have you pasted the code somewhere ?
17:08:49 <hayashi> Not yet, but I could do.
17:09:24 <ski> did you try adding `{-# LANGUAGE Rank2Types #-}' to the start of the file as well ?
17:09:51 <jfischoff> c_wraith: That's way I only use String as my error, because it pretty much is. Still I'm fine with it, because don't really have an errors that I need to pattern match on I guess
17:09:52 <hpaste_> hayashi pasted “Definitely doing something VERY wrong here” at http://hpaste.org/67901
17:10:01 <jfischoff> c_wraith: is there a better way?
17:10:06 <hayashi> ski: --^
17:10:15 <hayashi> I've got RankNTypes up there (for some very bizarre reason)
17:10:29 <ski> ok, `RankNTypes' also would work in cases `Rank2Types' work
17:11:04 <hayashi> As for the DatabaseBind type synonym, I tried eliminating it and replacing it with the actual type to no avail
17:11:37 <ski> btw, i traditionally call your `>:', `.:' :)
17:12:05 <ski> (and `(.::) = (.) . (.) . (.)', &c.)
17:12:08 <c_wraith> jfischoff: There are other packages that have similar semantics, but don't depend on the Error class. Go looking, if you need one, I guess
17:12:42 <jfischoff> c_wraith: good to know
17:13:59 <hayashi> (nb: replacing one of the lines that uses withSrc withDst with the same thing pointing to withSrcIo withDstIo causes the entire thing to compile correctly, obviously because of some form of narrowing that will probably turn out given my luck to be fundamental to the way Haskell works)
17:23:16 <ski> hayashi : ok, i think i see now
17:23:56 <ski> i was thinking you were passing the `DatabaseBind m a' as argument to where you wanted to use it both with `m' as `IO', and as `ErrorIO' (for a separate use)
17:24:06 <ski> however, you don't seem to do that
17:24:49 <ski> the explicit `forall' in `withDB' is effectless, since it is applies to a result, and not to an argument
17:25:09 <ski> (basically the same type is inferred anyway)
17:25:26 <ski> the problem is around line `116'
17:25:42 <ski> here you're wanting to use `withSrc' (and `withDst') with two different types
17:26:07 <ski> as said, i was thinking you here got `withSrc' and `withDst' as arguments from elsewhere
17:26:36 <hayashi> Ah
17:27:30 <ski> and if that had been the case, then writing `syncTable :: DBDescriptor -> String -> (forall m. Monad m => DatabaseBind m a) -> (forall m. Monad m => DatabaseBind m a) -> ErrorIO ()' would probably have helped
17:28:25 <ski> (or with `MonadIO', depending on what `postgresqlConnect' requires -- though i suppose it seems likely it requires `MonadIO')
17:28:56 <ski> anyway, `withSrc' and `withDst' are declared locally here
17:29:07 <ski> and i think this is a case where the DMR is biting
17:29:36 <ski> you could fix this i think by either adding `{-# LANGUAGE NoMonomorphismRestriction #-}'
17:29:50 <ski> or simply by adding type signatures to `withSrc' and `withDst'
17:30:18 <hayashi> Ah, I'll try one of those then ^~^
17:31:22 <ski> .. a third option is by defining them as `withSrc k = withDB src db user pass k', i.e. "eta-expanding" the definition (really expanding it by extensionality)
17:31:43 <ski> all three of these options defuses the DMR
17:32:46 <ski> so, the problem, iiuc, was that the DMR forced `withSrc' and `withDst' to be non-constrained, because they were defined with no explicit argument patterns in the definiendum
17:33:21 <acowley> Chalmers is trending on Twitter! Go, Agda! IIUC, the Heat get assists from Chalmers via Agda.
17:33:29 <ski> in this case (unless there's a type signature), the DMR refuses to infer types like `... => ...'
17:34:40 <ski> this caused the `MonadIO m' constraint to "decay", by fixing `m' to be concrete type (either `IO' or `ErrorIO') -- and then the problem was that `checkExists' wanted it to be `IO', while `getStructure' wanted it to be `ErrorIO'
17:34:59 <ski> so, the loss of overloading caused a loss of polymorphism
17:35:12 <ski> hayashi : that's as far as i understand it (not having tested the code)
17:35:18 <ski> hayashi : can you get it to work ?
17:35:34 <hayashi> Yeah, it's working now (with Rank2Types intact, at least)
17:36:09 <hayashi> I just added type signatures, then went on to knock m out as an explicit parameter on DatabaseBind and add it in as a context
17:36:42 <hayashi> Thanks ski, didn't realise it'd boil down to manually specifying types =P
17:36:50 <hayashi> I'll have to look up what the DMR is at some point
17:37:43 <monochrom> monomorphism restriction
17:37:50 <ski> (dreaded)
17:37:58 <ski> consider `let x = expensiveComputation in ..x..x..'
17:38:42 <ski> the argument is that navely, one'd expect a thunking implementation to compute `x' here at most once
17:39:31 <ski> but if `x' has a type like `forall a. Foo a => ..a..', and the two uses of `x' uses it with different types for `a', then this won't happen
17:39:38 <hayashi> Ah
17:40:09 <ski> because `x' would because like a function because the dictionary-passing implementation of constraints would translate to a function accepting an argument
17:40:28 <ski> but if we just look syntactically at the code, this isn't apparent
17:41:28 <ski> so, the DMR basically forces `x' to be shared in such an implementation, by forbidding it having any class constraints, unless it has an explicit type signature, or is explicitly declared as taking arguments (in the definiendum)
17:41:35 <ski> that's the rationale for it
17:41:55 <ski> nowadays, most people seem to just want it to go away, though :)
17:42:09 <ski> (hence the `NoMonomorphismRestriction' language extension)
17:42:32 <ski> hayashi : i hope that explains it somewhat
17:42:42 <hayashi> Well, I thought what I was doing was running up against a limitation of Haskell, but I didn't know exactly what and thus didn't know how to fix it =P
17:45:06 <hayashi> Now I can go back to dealing with an applicative addiction~
18:00:45 * hayashi now has the fun issue of IO exceptions appearing in his nicely ErrorT'd lawn
18:01:04 <hayashi> God knows what to do with them.
18:03:06 <nyingen> @quote
18:03:07 <lambdabot> <Reporter> says: How are your children, Morbo?   <Morbo> Belligerent and numerous.
18:03:15 <nyingen> @quote
18:03:16 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:03:17 <nyingen> @quote
18:03:17 <lambdabot> JohnyBoy says: so have a nice goodspeed
18:03:56 * ski would consider making `data DBError = TableDoesNotExist | TableStructuresDiffer'
18:04:22 <ski> maybe thowing in some `IOException's in there as well
18:35:54 <kallisti> hm, got a build error while compiling wxHaskell on Windows?
18:35:58 <kallisti> anyone know stuff about this
18:43:13 * hackagebot wai-app-file-cgi 0.5.10 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.10 (KazuYamamoto)
18:44:06 <BrianHV> kallisti: it's wxHaskell that's failing, not wx?
18:46:27 <kallisti> BrianHV: it could be an issue with wx
18:46:32 <kallisti> I may have found a workaround though
18:58:14 * hackagebot mighttpd2 2.5.11 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.11 (KazuYamamoto)
19:34:42 <gentleben> anyone used template haskell with constraint kinds?
19:40:58 <JoeyA> I wish Control.Monad.Writer.Class had a variant of listen that steals the output, but emits mempty.  listen :: m a -> m (a, w)  not only returns the w, but emits it as well.
19:42:04 <JoeyA> Sure, it's simple enough to apply censor (const mempty) on top of this, but the default behavior of listen is surprising.
19:46:04 <ryanfessler> So quick syntax question... I'm using encode from Data.Binary and I was wondering if the parentheses matter in this case: (encode 0 :: Word32) or (encode (0 :: Word32))
19:47:23 <rwbarton> yes, they do matter
19:49:39 <ryanfessler> Okay, kinda figured that, but I figured I'd make sure. Thanks!
19:54:43 <kallisti> BrianHV: so it would appear that I need libstdC++.dll to run my app.
19:57:45 <Axman6> rwbarton: (encode 0 :: Word32) is ((encode 0) :: Word32)
19:57:53 <Axman6> uh, ryanfessler
19:58:08 <Axman6> ok IRC from Fiji to Australia isn't very responsive
20:06:20 <ymasory> how do i indicate failure inside the IO monad, so the monad returns empty?
20:08:08 <kallisti> ymasory: unless you mean "throw a runtime exception" there's not really a way to do that.
20:08:34 <kallisti> if you want the result of an IO computation to possibly fail
20:08:38 <kallisti> you can do  IO (Maybe a)
20:08:39 <ymasory> kallisti: so if i throw an exception inside the IO monad, the resulting monad will be empty if someone binds it?
20:08:50 <kallisti> no
20:09:06 <kallisti> it will throw an exception
20:09:12 <kallisti> which can be caught asynchronously by exception handlers.
20:09:22 <kallisti> that's probably not what you meant
20:09:33 <kallisti> but it's the closest equivalent (within IO)
20:09:43 <kallisti> of course you're free to use monadic error handling within the result of an IO
20:09:49 <kallisti> or even use something like MaybeT IO a
20:09:57 <ymasory> ah. well don't all io computations possibly fail? what's the normal thing to do here for say, a function that reads a string through the network? IO (Maybe String) or IO (String)?
20:10:18 <kallisti> the normal thing in my experience is just throw exceptions
20:10:41 <ymasory> what happens to the purpose binding the monad, if the monad throws an exception?
20:10:41 <kallisti> if you're using a networking library, just let it throw its exception
20:10:50 <kallisti> unless you want to create your own interface to expose to others
20:11:12 <kallisti> it.. vanishes
20:11:25 <kallisti> it works very much like exception handling in imperative languages if you're familiar with it.
20:12:18 <kallisti> x <- readSocket s
20:12:22 <kallisti> if readSocket throws an exception
20:12:32 <ymasory> so by vanishes i understand that it doesn't stop the program, and the monad returns "empty" so the bind code isn't entered?
20:12:36 <kallisti> then it will call the innermost exception handler
20:12:39 <kallisti> or exit the program
20:12:53 <kallisti> there is no "empty"
20:13:05 <kallisti> and yes IO exceptions can exit the program.
20:13:08 <kallisti> if there are no handlers.
20:14:01 <kallisti> x <- readSocket s `catch` (\e::IOException -> doSomethingElse)
20:14:21 <kallisti> here I've applied an exception handler, which will catch any IOExceptions
20:14:48 <kallisti> (might need parens around that parameter)
20:14:52 <ymasory> okay thanks
20:15:24 <ymasory> so if not exiting is desired, without forcing the client to handle exceptions, then i guess IO (Maybe a) is what i'm looking for
20:15:56 <kallisti> sure
20:16:00 <kallisti> maybe
20:16:18 <kallisti> there are multiple exception handling mechanisms you can use.
20:16:55 <ymasory> kallisti: this is actually for scala, so i'm not sure if going into those would be helpful :)
20:17:07 <kallisti> whut
20:17:21 <kallisti> scala has an IO monad?
20:17:31 <ymasory> kallisti: this is for scala, using scalaz for haskell typeclasses. i didn't get a good answer in #scala so i decided to ask here
20:17:36 <ymasory> scalaz does
20:17:52 <kallisti> oh
20:19:39 <kallisti> ymasory: I'm not sure why you would an IO monad in a multi-paradigm language.
20:19:45 <kallisti> there's not much point.
20:21:02 <ymasory> kallisti: mult-paradigm doesn't mean you have to use all the paradigms. if you decide to do things purely, and use the widely available wrappers for impure java code, you can get the same benefits
20:21:28 <ymasory> the compiler just can't guarantee that you remembered to put all the side-effecting stuff in the right monad
20:30:52 <randomclown> Say I try to model Java objects in Haskell. i.e. "JObject = JInt Int | JLong Integer ... is there a way for me to declare a
20:31:04 <randomclown> data JType = JInt | JLong ...
20:31:21 <randomclown> then associate a later with each entry later in another data declaration?
20:31:47 <randomclown> then associate a value* later with each entry
20:32:52 <JoeyA> You could use GADTs: data JType a where JInt :: JType Int; JLong :: JType Integer ...
20:32:56 <quuxman> how do you set the pager for ghci?
20:33:13 <JoeyA> Then data JObject a = JObject (JType a) a
20:33:22 <JoeyA> randomclown: ^
20:33:26 <randomclown> hmm
20:33:31 <randomclown> building firealarm went off
20:33:37 <randomclown> g2g
20:33:49 <JoeyA> GADTs are pretty powerful stuff...
20:34:16 <quuxman> I want to be able to search the tab completion list
20:58:39 <penryu> I think I'm missing something.  I'm looking for a function (a -> b -> (a,b)), but the closest I can get is: head $ zip [a] [b]
20:59:13 <penryu> easy enough to write, but I still feel like I'm missing something.
21:00:03 <JoeyA> penryu: (,)
21:00:06 <JoeyA> :t (,)
21:00:07 <lambdabot> forall a b. a -> b -> (a, b)
21:00:20 <JoeyA> > (,) 1 3
21:00:21 <lambdabot>   (1,3)
21:00:29 <shapr> @hoogle (a -> b -> (a,b))
21:00:30 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
21:00:30 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:00:30 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:00:32 <JoeyA> :t \a b -> (a, b)
21:00:33 <lambdabot> forall t t1. t -> t1 -> (t, t1)
21:00:50 <pitor> I'm receiving a "Fields not initialized" warning when setting up a data-type.  i don't attempt to use these fields until after they've been properly initialized, though. is there a way to make the compiler suppress these warnings?
21:01:05 <penryu> JoeyA: well shit. hoogle was useless on that one.
21:01:16 <penryu> JoeyA: thanks. I knew I was missing something big.
21:02:01 <JoeyA> pitor: you could initialize them to undefined.  Unfortunately, you'll lose specific error messages if you do accidentally evaluate one of these fields.
21:02:18 <penryu> shapr: yeah.. any tips on hoogling for that one? I didn't have any better luck than hoogle.
21:02:30 <penryu> s/hoogle/lambdabot/
21:02:41 <pitor> JoeyA: ah, that did the trick. thanks!
21:02:43 <JoeyA> There should be an -fno-warn-... switch
21:04:13 <JoeyA> pitor: -fno-warn-missing-fields
21:04:20 <pitor> JoeyA: thx!
21:04:29 <JoeyA> That is, add {-# OPTIONS_GHC -fno-warn-missing-fields #-} to the top of your module.
21:05:17 <shapr> penryu: That is weird, I would have expected hoogle to return (,)
21:06:24 <JoeyA> What version of GHC will support "type warnings" (where the compiler builds your program even in the presence of type errors, and replaces affected values with error values) ?
21:06:59 <JoeyA> I've seen it demoed one or two times in Haskell-related videos.
21:07:36 <Saizan> if it's already implemented it'll probably go into 7.6
21:08:33 <JoeyA> I wasn't sure if it was in 7.4 yet or not.
21:09:08 <pdxleif> It's not - it's in master or something, though
21:12:53 <nyingen> how many people are subscribed to haskell-cafe?
21:13:41 <JoeyA> At least one.
21:14:39 <JoeyA> I don't know, sorry.
21:15:36 <nyingen> we can strengthen your claim by counting the number of distinct addresses in the last week or two of posts
21:15:41 <nyingen> "at least 25"
21:15:49 <nyingen> and your mom
21:16:00 <JoeyA> http://www.haskell.org/haskellwiki/Mailing_lists gives a clue, but the figure given may be out of date: "Remember that your posting will be sent to thousands of people, some of whom are very busy."
21:16:20 <JoeyA> Though the number of subscribers and the number of posters are different.
21:17:06 <JoeyA> This IRC channel has 842 nicks in it, but only a small percentage of them have said anything in the last hour.
21:18:22 <nyingen> this channel has impressive membership, indeed
21:18:23 <Yarou> anything
21:18:45 <nyingen> more than one person has come in here for the first time and done a double-take at the number of users
21:19:15 <mefisto> I was surprised at the number of users... just joined for the first time today
21:20:34 <mefisto> trying to figure out whether I want to try my next project in rails or one of the haskell frameworks
21:25:40 <shapr> JoeyA: Would be a fun project to calculate the actual number of active users on IRC channels from logs.
21:26:06 <shapr> mefisto: If you've not tried both, I'd say give each framework an hour or two to get started with, and then start with the one you like better.
21:26:32 <shapr> mefisto: If you've already tried one, your next project should use the other one, so you have a better understanding of more tools!
21:26:57 <mefisto> shapr: have you used both?
21:27:22 <shapr> I've not used Ruby, but I have used Python/Django/Zope/Plone.
21:27:28 <shapr> And I've done webdev in Haskell also.
21:28:50 <hpaste_> fragamus pasted “looking for help tightening this bit of code” at http://hpaste.org/67904
21:29:10 <mefisto> shapr: what was the haskell webdev experience like for you
21:30:02 <shapr> mefisto: I enjoyed it more than the Python webdev, actually.
21:30:24 <shapr> mefisto: Partly because Python webdev has a scary dark neighborhood that will mug you if your code walks through it without safeguards.
21:30:59 <shapr> Ok, not really, but my major problem with Python webdev was that I could never trust that my huge monster REQUEST object was not being modified when I wasn't looking.
21:31:33 <shapr> Too many times I had to fight the assumption that my REQUEST was the one and only request, and that it came from a real browser.
21:32:05 <mefisto> shapr: that's been sort of similar to the worry I've had in the playing around I've done with rails... there's a lot of magic going on and not sure how to predict or control it
21:32:14 <hpaste_> fragamus pasted “looking for help tightening this bit of code” at http://hpaste.org/67905
21:33:01 <kallisti> mefisto: Haskell all the way. \o/
21:33:24 * kallisti is in no way biased. all #haskell users are completely impartial.
21:33:40 <shapr> I probably AM biased, I started this channel!
21:33:58 <shapr> We built this channel... on lambdas and bind!
21:34:10 <shapr> I have to come up with better lyrics for that :-/
21:35:26 <shapr> mefisto: Anyway, both sides are worth learning, you should choose the one you enjoy most.
21:35:34 <dmwit> ?users
21:35:34 <lambdabot> Unknown command, try @list
21:35:41 <dmwit> Oh, did that get removed, too?
21:35:42 <dmwit> bummer
21:36:03 <mefisto> the intellectual purity of haskell seems appealing :D
21:36:15 <JoeyA> @stalk dmwit
21:36:16 <lambdabot> I won't; I want to go get some cookies instead.
21:36:16 <shapr> mefisto: I strongly agree, that's one of my favorite parts.
21:36:20 * shapr blinks
21:36:25 <JoeyA> @help stalk
21:36:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:37:07 * dmwit blinks
21:37:19 <dmwit> ?help talk
21:37:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:37:57 <allbery_b> no edit distance w/@help, it outputs that for anything unknown
21:38:14 <shapr> @stalk lambdabot
21:38:14 * lambdabot would never hurt lambdabot!
21:38:20 <dmwit> aaaah
21:38:23 <shapr> @slap preflex
21:38:24 * lambdabot slaps preflex with a slab of concrete
21:38:24 <dmwit> ?slap dmwit
21:38:24 * lambdabot pokes dmwit in the eye
21:38:48 <JoeyA> @fix me
21:38:48 <lambdabot> Maybe you meant: bid faq ft id thx
21:38:56 <shapr> @break
21:38:56 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
21:39:04 <shapr> huh, that's new.
21:39:08 <JoeyA> Hmm, apparently @stalk is an easter egg
21:39:17 <shapr> I think @stalk is corrected to @slap
21:40:02 <JoeyA> @slap JoeyA
21:40:02 * lambdabot pokes JoeyA in the eye
21:41:54 <dmwit> ?list
21:41:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:42:07 <dmwit> ?read
21:42:07 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
21:42:12 <dmwit> shapr: ?
21:46:42 <kallisti> Levenshtein is a pretty cool guy. eh finds edit distance and doesn't afraid of anything.
21:47:06 <Xorlev> I hear he was tired of people getting his name wrong.
21:47:33 <kallisti> ha. that's a good one.
21:49:41 <lispy> Hmm...I can't find anything roughly of the form [Either String a] -> Either String [a]
21:49:44 <lispy> Something like catRights
21:50:25 <dmwit> :t partitionEithers
21:50:26 <lambdabot> forall a b. [Either a b] -> ([a], [b])
21:50:28 <dmwit> :t sequence
21:50:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:51:18 <lispy> partitionEithers is probably exactly what I want...
21:51:26 <lispy> my as are error strings
21:51:48 <lispy> so then I can print all my errors as warnings and take all my good values and keep computing
21:53:15 <wli> @type let classify p = map (\x -> if p x then Right x else Left x) in classify
21:53:16 <lambdabot> forall a. (a -> Bool) -> [a] -> [Either a a]
22:14:53 <Enigmagic> vlc
22:14:57 <Enigmagic> gah
22:24:51 <nyingen> @quote
22:24:51 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:24:53 <nyingen> @quote
22:24:53 <lambdabot> donw says: [of JavaScript booleans] I've heard of duck-typing, and static-typing, but this is the first time I've heard of Schrödinger-typing...
22:25:52 <dmwit> ?quote nyingen
22:25:53 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:25:57 <dmwit> aw
22:26:05 <dmwit> ?quote vlc
22:26:05 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
22:29:39 <squimmy> Dear #haskell, would some kind person please explain to me why this code does what I want it to? i thought that values were immutable in haskell! (http://pastebin.com/hRRp9naV)
22:29:41 <mauke> The paste hRRp9naV has been copied to http://hpaste.org/67906
22:30:43 <dmwit> By line 11, there are two variables named input, one of which shadows the other.
22:30:59 <squimmy> oh...
22:31:01 <dmwit> You may prove to yourself that they both still exist by doing something like
22:31:14 <dmwit> 9 let x' = print input
22:31:18 <dmwit> 13 x'
22:32:22 <squimmy> does that mean to say that values will remember which 'version' of a value is assigned to them?
22:32:42 <dmwit> I'm not sure what that means.
22:33:01 <kallisti> it means that the first input and the second input have completely different scopes.
22:33:11 <squimmy> ok
22:33:34 <kallisti> when you desugar do notation it's translated into >>= and anonymous functions
22:33:41 <squimmy> is there a way of ending the scope of the second input to bring the first one back into scope, or would i need to use a closure to access it from then on
22:33:44 <kallisti> each input is a different parameter to a different function
22:33:55 <squimmy> kallisti: right
22:34:07 <dmwit> You may give the second variable a name other than input.
22:34:20 <squimmy> dmwit: that's a much better idea
22:34:34 <dmwit> You may introduce a new do-block and name the second variable input as well; its scope will end at the end of the second do-block.
22:34:42 <dmwit> There might be other fixes.
22:35:09 <squimmy> thank you. that actually explains it very welll
22:53:25 <jfischoff> is there a canonical, or efficient, way to due running averages, or equivalent online computations, in haskell?
22:54:35 <dmwit> :t scanl
22:54:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:54:40 <jfischoff> moving average
22:54:49 <jfischoff> cool
22:55:04 <jfischoff> how does that work with streams?
22:55:06 <dmwit> :t \f -> map (f . take 10) . tails
22:55:07 <lambdabot> forall b a. ([a] -> b) -> [a] -> [b]
22:55:14 <dmwit> for moving averages
22:55:26 <jfischoff> yeah
22:55:28 <dmwit> jfischoff: I'm not sure I understood that question. Streams?
22:55:52 <jfischoff> if the input is infinite, does it affect anything?
22:55:57 <dmwit> If you're asking how lazy it is... very lazy.
22:55:58 <jfischoff> do I need scanr
22:56:01 <dmwit> No, infinite input is fine.
22:56:05 <dmwit> scanl is the lazy one.
22:56:08 <dmwit> scanr is strict.
22:56:08 <jfischoff> ah
22:56:27 <dmwit> It is a rite of passage to work out why foldr and scanl are the right ones to use.
22:56:37 <jfischoff> haha
22:56:45 <jfischoff> right I need it
22:57:51 <ski> > (tail . map (uncurry (/)) . scanl (\(sum,count) n -> (sum + n,count + 1)) (0,0)) [2,4,9,9]  -- jfischoff
22:57:53 <lambdabot>   [2.0,3.0,5.0,6.0]
22:58:46 <jfischoff> I don't usually have to write online programs. I'm missing a good intuitive understanding of the relationship between laziness and infinite data.
22:59:15 <ski> @src partition
22:59:15 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
22:59:16 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
22:59:16 <lambdabot>                               | otherwise = (ts, x:fs)
22:59:25 <ski> > partition even [0..]
22:59:26 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
22:59:44 <ski> > join (***) (take 4) (partition even [0..])
22:59:45 <lambdabot>   ([0,2,4,6],[1,3,5,7])
23:00:02 <ski> jfischoff : firgure out why there's a `~' in the definition
23:00:30 <jfischoff> I've only seen that in the docs :)
23:01:36 <ski> fragamus : replace `lr = ' with `(l,r) = ', and also `fst lr' and `snd lr' by `l' resp. `r'
23:03:06 <ski> > (tail . map (uncurry (/)) . scanl (\(sum,count) n -> (sum + n,count + 1)) (0,0)) [2,4,9,9] :: [Expr]
23:03:08 <lambdabot>   [(0 + 2) / (0 + 1),(0 + 2 + 4) / (0 + 1 + 1),(0 + 2 + 4 + 9) / (0 + 1 + 1 +...
23:13:15 <xil> hey everyone. I regularly want to map a function through a list, but only selectively return elements, based on some feedback from the function. Anyone know how I can do that?
23:15:42 <xil> I need to get a rubber duck, haha
23:15:54 <xil> found Data.Maybe.mapMaybe
23:16:06 <dmwit> There's a few ways. filter, map, list comprehensions, and yes, mapMaybe
23:17:42 <dmwit> concatMap/(>>=) is a good option, too, in many cases
23:18:25 <xil> well filter is ugly if I want the function to have control of what's pulled out. And list comprehension can be large. mapMaybe is pretty much exactly what I was looking for
23:18:48 <xil> how would you use concatMap or >>=?
23:19:11 <dmwit> just like mapMaybe, but return [] or [x] (or [x,y]) instead of Nothing or Just x
23:19:43 <dmwit> Maybe has no analogue for the third option.
23:20:23 <xil> I think my confusion comes from trying to make sense of the need for that in my current context. You probably have a much better idea of the general case
23:22:41 <booogey> Hey can someone help me with a haskell problem plz
23:23:19 <dmwit> Don't ask to ask, just ask.
23:23:42 <ski> > [0,1,2,3] >>= join replicate  -- xil ?
23:23:43 <lambdabot>   [1,2,2,3,3,3]
23:24:01 <ski> > [0,1,2,3] >>= \n -> replicate n n
23:24:02 <lambdabot>   [1,2,2,3,3,3]
23:24:13 <ski> > do n <- [0,1,2,3]; replicate n n
23:24:14 <lambdabot>   [1,2,2,3,3,3]
23:24:24 <booogey> the question is "Using a ZF-expression define the function unique which takes a list of integers and returns the list of those integers that occur once in the argument, so for example unique [1,2,3,1,2,4] will return [3,4]"
23:24:27 <ski> > [m | n <- [0,1,2,3] , m <- replicate n n]
23:24:28 <lambdabot>   [1,2,2,3,3,3]
23:24:48 <booogey> but im not sure how i would compare each element in the list with each other using a Zf :S
23:24:59 <ski> booogey : you're sure you're not after miranda ?
23:25:10 <booogey> is miranda a function?
23:25:17 <ski> miranda is a language
23:25:20 <booogey> oh
23:25:34 <xil> ski: dmwit: ah I understand why the case of returning [x,y...] is relevant. I only return [] or [x] from my function, or something equivalent, like Nothing or Just x
23:25:37 <booogey> no this is a "past exam question" for a haskell exam.. got an exam in a couple hours :x
23:25:42 <ski> list comprehensions in Haskell is called ZF-comprensions in Miranda, iirc
23:25:55 <booogey> oh right.
23:26:03 <booogey> yeah ZF/list comprehsension same thing to me :P
23:26:25 <dmwit> booogey: You can both iterate over the list and use the list in your predicate.
23:26:35 <ski> booogey : could you compare one element with the rest of them, with a list comprehension ?
23:26:43 <dmwit> Perhaps that hint will help you a bit?
23:27:14 <jfischoff> they should have called them ZF-comprehensions
23:28:00 <booogey> im not sure how the predicate which takes a list will be... is it something like "unique xs = [ a | a <-xs, a /= xs ]" ?
23:28:26 <ski> booogey : that's a start
23:28:45 <ski> `a /= xs' needs to be fixed, though
23:28:53 <ski> `a' is an element, `xs' is a list
23:30:15 <booogey> arghh i really have no clue :S "unique xs = [ a | a <-xs, (\x -> a /= x) xs ]"  ? :S
23:32:32 <ski> hint : you should probably use recursion
23:33:41 <booogey> lol ski probably... but the question said i can only use a ZF expression lol which is why im a bit confused
23:35:25 <jfischoff> booogey: yeah that's not your fault. Bad name to begin with :p
23:36:25 <ski> booogey : no, it didn't
23:36:42 <ski> it said you should use a ZF-expression
23:36:55 <ski> it didn't say you couldn't also use recursion
23:37:02 <booogey> hmmm touche
23:55:19 <mysticc> booogey: Still there ?
23:55:56 <booogey> yep
23:56:03 <mysticc> booogey: unique xs = [a | a <- xs  , [ b | b <- xs , b == a] == [a] ]
23:56:50 <booogey> woahh ZF inside a ZF didnt know you could do that :O thank you for the knowledge!!
23:57:07 <mysticc> booogey: :) ..
23:57:16 <dmwit> I hope you demanded big tall moneys.
23:57:47 <mysticc> dmwit: What ?
23:58:31 <shachaf> That sounds like a terrible homework question.
23:58:45 <shachaf> List comprehensions ought to be taken out of Haskell-for-teaching-purposes.
23:59:04 <mysticc> shachaf: homework questions are always terrible ..
23:59:28 <dmwit> https://groups.google.com/group/comp.lang.haskell/browse_thread/thread/0f478bb42c896fa9?pli=1
23:59:54 <shachaf> mysticc: Hardly.
