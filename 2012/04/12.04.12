00:06:07 <augur> @tell Philippa do you know of anything on CSP for non-numeric problems?
00:06:07 <lambdabot> Consider it noted.
00:22:28 <Ngevd> Hello
00:22:39 <adnam> howdy!
00:22:41 <Ngevd> I think I have way too many packages installed...
00:22:59 <Ngevd> What's the best way to uninstall them all and start again?
00:23:23 * hackagebot webdriver 0.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.1 (AdamCurtis)
00:23:47 <Axman6> rm -rf ~/.ghc ~/.cabal works but you'll lose any settings you had in ~/.cabal. there may be better ways, but that's usually all i do
00:28:17 <Ngevd> Axman6, that would be great if I wasn't on Windows
00:28:34 <Ngevd> I'll figure out a way
00:30:35 <Ngevd> RD /s
00:33:17 <Ngevd> ...Command prompt sucks.
00:39:10 <sohum> @src asTypeIn
00:39:11 <lambdabot> a `asTypeIn` f = a where _ = f a
00:39:11 <lambdabot> infixl 0 `asTypeIn`
00:40:31 <ion> ngevd: You’ll get a decent command-line interface for Windows™ by installing mintty and either msys or cygwin.
01:03:52 <jetru> I have a bunch of IO functions( readFile/writeFile ) running inside the ErrorT monad using runErrorT. When one of these IO functions fail, it seems that runErrorT doesn't catch onto these IO exceptions and handle them
01:04:13 <jetru> anyway I can do that?
01:04:40 <shachaf> ErrorT has nothing to do with IO exceptions.
01:14:05 <bombel8> hi!
01:14:14 <bombel8> > 2 + 2
01:14:16 <lambdabot>   4
01:17:03 <gdeest> Does lambdabot timeout if I feed him an expression that takes too long to compute ?
01:17:44 <kadoban> gdeest: that'd be a pretty good assumption
01:18:05 <ion> lambdabot is secretly still computing all the bottoms since the beginning of time.
01:18:21 <gdeest> XD
01:18:42 <ion> When she finishes, she’ll output “42”.
01:18:49 <gwillen> > 7 / 0
01:18:50 <lambdabot>   Infinity
01:18:57 <gwillen> > 0 / 0
01:18:58 <lambdabot>   NaN
01:19:23 <gwillen> I guess it would have been easier to ask ghci that first.
01:19:24 <gdeest> > Control.Monad.filterM (const [True, False]) [1..]
01:19:26 <lambdabot>   *Exception: stack overflow
01:19:29 <gwillen> heh!
01:19:31 <gdeest> OK :P
01:19:54 <shachaf> Modern GHC doesn't even *have* stack overflows.
01:20:39 <gdeest> Yeah, it has an infinite stack of turtles
01:20:53 <gwillen> shachaf: what if I ask here, then do you want the shirt? ;-)
01:20:53 <int-e> shachaf: sure it does ... just try manipulating really big integers *g* (gmp likes using the C stack for temporary storage)
01:21:18 <shachaf> gwillen: I don't usually have shirts with text on them.
01:21:32 <bombel8> > let me = be
01:21:33 <lambdabot>   not an expression: `let me = be'
01:21:34 <gwillen> I think basically all my shirts have text on them
01:21:35 <shachaf> Or pictures. Except for monochromatic pictures. Where by monochromatic I mean one color.
01:21:46 <shachaf> I don't think that's what people usually mean by monochromatic.
01:21:56 <gwillen> currently I am wearing one that says "morgan stanely", because it was free
01:21:59 <mcstar> is it possible to extract a value from the IO monad?
01:22:05 <gwillen> stanley*
01:22:06 <mcstar>  i guess it isnt
01:22:14 <shachaf> int-e: That's not a *GHC* stack overflow...
01:22:27 <shachaf> gwillen: Free shirts I occasionally take exception with.
01:22:28 <int-e> shachaf: but you weren't specific enough
01:22:28 <gwillen> mcstar: unsafePerformIO, but if you have to ask you probably shouldn't use it.
01:22:38 <mcstar> BS.unfoldr (\x -> if x <= 5 then Just (do n <-random gen; n, x + 1) else Nothing) 0
01:22:43 <mcstar> i want to do thi ^^
01:22:45 <shachaf> gwillen: If you send me a free monad shirt, I'll wear it.
01:22:53 <gwillen> shachaf: cafepress charges me for the shirt, same as you :-(
01:22:59 <shachaf> mcstar: That's not how random works.
01:23:22 <mcstar> this random gives IO a, where is is Num
01:23:28 <mcstar> a*
01:23:46 <mcstar> the point is, i have to build up a bystring from random numbers
01:23:51 <shachaf> mcstar: I recommend reading an introduction to how random and IO work in Haskell.
01:23:52 <mcstar> without consing up a list first
01:24:30 <gdeest> Is it possible to find a function based on its type ? For example, a tool that would return "System.IO.Unsafe.unsafePerformIO" whan you give it "IO a -> a"
01:24:36 <shachaf> @hoogle IO a -> a
01:24:36 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
01:24:37 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
01:24:37 <lambdabot> Foreign unsafePerformIO :: IO a -> a
01:24:45 <gdeest> Nice :)
01:25:30 <mcstar> ah, thanks
01:25:37 <mcstar> just what i neede
01:25:39 <mcstar> d
01:25:54 <gwillen> That will probably not actually turn out to be true. But good luck.
01:26:00 <shachaf> mcstar: Wait, what?
01:26:08 <shachaf> mcstar: Don't use unsafePerformIO!
01:26:10 <mcstar> unsafePerformIO solved it
01:26:12 <shachaf> @slap gdeest
01:26:13 * lambdabot clobbers gdeest with an untyped language
01:26:13 <mcstar> i know i know
01:26:17 <mcstar> its just for testing
01:26:17 <shachaf> mcstar: No, seriously.
01:26:19 <shachaf> Don't do it.
01:26:28 <gdeest> mcstar: Debug.Trace trace ?
01:26:38 <mcstar> yeah?
01:26:43 <mcstar> i use trace
01:27:02 <gdeest> So it's not just for debugging ?
01:27:06 <shachaf> mcstar: Just do it the proper way.
01:27:34 <gdeest> Don't you like to peel monads ? :P
01:28:05 <mcstar> when i will know the proper way i promise ill do it that way
01:28:25 * hackagebot lzma-conduit 0.4.0 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.4.0 (NathanHowell)
01:28:37 <shachaf> mcstar: You should learn the proper w right now.
01:28:54 <mcstar> yes sire!
01:28:57 <shachaf> The proper way would probably involve zipping an infinite list of random numbers with your list or something.
01:29:34 <mcstar> shachaf: the point that i want to try, is to NOT make list
01:29:39 <mcstar> but directly a bystring
01:29:51 <mcstar> OMG i cant type bytestring right
01:30:02 <shachaf> mcstar: Nothing wrong with making a list.
01:30:08 <shachaf> Seriously, make a list.
01:30:19 <shachaf> Why don't you want to make a list? Efficiency?
01:30:22 <mcstar> shachaf: i did, before, but now i want to test it if it improves performance
01:30:46 <shachaf> You're doing this for *performance*?
01:30:57 * shachaf washes hands of this mess.
01:31:05 <mcstar> have you ever heard of human curiosity?
01:31:42 <gwillen> mcstar: he's a haskeller, so it's unlikely ;-)
01:31:47 <Elemir> Hem, is there mutt clone, written on haskell?
01:31:50 * gwillen be trollin' the interwebs
01:32:11 <kallisti> Elemir: not that I know of
01:32:48 * Elemir wants to simply mail/news pager without implementing any protocol
01:33:16 <Elemir> Mutt is very verbose now :(
01:34:44 <gabrielita> hola
01:35:50 <gabrielita> hay alguien aqi?
01:43:10 <earthy> no, there's no one here.
01:45:49 <alpounet> obviously.
01:46:26 <mcstar> interesting, with no optimization flag, the unsafeIO works, but with -O i get a bytestring filled with the same random number
01:52:45 <hirsch_> Is yesod broken at the moment, I want to compile a scaffolded project with the actual version and I get the error:
01:52:45 <hirsch_> Settings/StaticFiles.hs:1:1:
01:52:45 <hirsch_>     Exception when trying to run compile-time code:
01:52:45 <hirsch_>       sinkHash
01:52:45 <hirsch_>       Code: staticFiles staticDir
01:53:00 <yezariaely> is it a bad idea to call getContents to lazily read a file and hClose in a auxillary function when I return the lazy string?
01:53:12 <yezariaely> readSomething :: String -> IO String
01:53:56 <Lemmih> yezariaely: Yes. hGetContents will close the handle once it is done.
01:54:44 <yezariaely> Lemmih: ah ok, wonderful thx
02:01:33 <mcstar> ok, i solved, it now unsafePerformIO works with -O
02:03:26 * hackagebot lzma-conduit 0.4.1 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.4.1 (NathanHowell)
02:04:37 <kallisti> mcstar: I'm guessing it had something to do with a lack of a NOINLINE ?
02:06:03 <kallisti> Elemir: I'm currently working on a irc-conduit package. smtp-conduit might be feasible as well?
02:06:27 <MasseR> Is it just me or has the conduit got more traction than enumerator ever did?
02:06:49 <kallisti> MasseR: seems that way
02:08:12 <timthelion> I have a gtk Table filled with buttons, http://imageshack.us/f/37/grideditfreemovement.jpg/ and when I press a button, I replace it with an Entry http://imageshack.us/f/94/gridediteditcell.jpg/ and unfortunately, that entry is larger than the buttons, and causes every cell of the Table to resize, causing problems.   Any ideas on how I might fix this?  I cannot find a "Fixed Size Container"
02:08:22 * timthelion thinks he just got cut off.
02:34:51 <mcstar> shachaf: memory consumption more than doubles if i dont use unsafePerformIO, i understand i shouldnt, and i wont, and thats why i ask you, how would you lower memory consumption safely?
02:36:26 <gdeest> I see space leaks.
02:36:51 <merijn> mcstar: Well, step one would be to profile and figure out where the memory consumption is coming from
02:37:54 <mcstar> ok, ill find some example of profiling
02:38:05 <merijn> mcstar: http://book.realworldhaskell.org/read/profiling-and-optimization.html
02:38:21 <merijn> That has a pretty elaborate discussion of how to profile haskell memory use
02:39:07 <mcstar> k thanks
02:39:11 <merijn> I think it also has some examples on how to reduce memory usage, but not sure. Never worked with it so far
02:44:44 <mcstar> ah, i need to rebuild my libs
02:45:04 <mcstar> what would be the appropriate cabal flag?
02:47:08 <mcstar> ok
02:47:57 <ClaudiusMaximus> mcstar: put "library-profiling: True" -- in your .cabal/config, ideally before installing anything - even though it compiles everything twice i figure i'll want to profile at some point..
02:48:56 <mcstar> done
02:58:28 * hackagebot yesod-auth-kerberos 1.0.0 - Kerberos Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-kerberos-1.0.0 (ArashRouhani)
03:09:04 <mcstar> hm, when i want to profile, should i use optimization flag, or not?
03:09:48 <Rmx> after having install ghc 7.4.1 over the last haskell platform (7.0.4), cabal install still can't use base 4.5, and select 4.3 instead. how can I specifiy wich version of base to use ( or how can I install base 4.5..)
03:15:44 <Rmx> problem solved
03:15:54 <Rmx> cabal install gloss-examples --with-compiler=C:\ghc\ghc-7.4.1\bin\ghc.exe
03:17:01 <Entroacceptor> Rmx: have a look at hsenv
03:18:04 <kallisti> @hoogle Char -> Int
03:18:05 <lambdabot> Data.Char digitToInt :: Char -> Int
03:18:05 <lambdabot> Data.Char ord :: Char -> Int
03:18:05 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
03:18:13 <kallisti> :t toEnum
03:18:15 <lambdabot> forall a. (Enum a) => Int -> a
03:18:29 * hackagebot repa 3.1.1.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.1.1 (BenLippmeier)
03:18:40 <mcstar> where is my CharKey?
03:21:17 <MHD0> I am trying to install Repa but it says i require base 4.5. I have recompiled the latest stable version from source to no avail.
03:22:56 <Lemmih> MHD0: You probably need to upgrade GHC.
03:23:58 <MHD0> Lemmih: I did. Unless you mean removing it and recompiling from latest source isn't upgrading.
03:24:34 <cheater_> why don't you look in the .cabal file?
03:25:10 <MHD0> Hmmm
03:25:12 <MHD0> Good idea
03:25:14 <Lemmih> MHD0: GHC-7.4.1 includes base-4.5
03:25:24 <Lemmih> MHD0: What version are you using?
03:25:42 <MHD0> It appears I am stuck with 7.2
03:25:46 <MHD0> For some odd reason
03:25:56 <Lemmih> 7.2 isn't really the latest source.
03:26:02 <MHD0> The Yum repositories have 7.2
03:26:12 <MHD0> And it appears I grapped the wrong source
03:26:15 <MHD0> Do'h
03:28:16 <mcstar> hm, ARR_WORDS is the space leak
03:29:01 <endojelly> following this question about F# on stack overflow: http://stackoverflow.com/questions/6104221/why-is-this-f-code-so-slow/6104300
03:29:35 <endojelly> I wonder how Haskell handles it. I imagine that, with a generic min function in the same module, ghc would be smart enough to build an Int version of it
03:29:57 <endojelly> but what if my min function is, say, part of the standard library?
03:30:04 <endojelly> and thus already compiled?
03:30:20 <alpounet> depends if there's a specialization for it
03:30:24 <alpounet> see the SPECIALIZE pragma
03:30:43 <endojelly> so I'd have to explicitly specify specializations for it in my library?
03:31:06 <wern> What is good way of representing a list of lists of lists, …, of Strings in Haskell? I've looked at rose trees (and forests of rose trees), but would like to minimize the number of constructors like Node  (rootLabel, subforest), etc and just have vanilla Strings and lists. Is it possible to construct such nested lists of arbitrary depth?
03:31:50 <mcstar> everything is possible?
03:32:15 <cheater_> i think he's just asking what way is the nicest from the usability point of view
03:32:22 <ion> @faq Can Haskell construct nested lists of arbitrary depth?
03:32:22 <lambdabot> The answer is: Yes! Haskell can do that.
03:32:29 <Saizan> i think GHC by default tries to remove dictionaries's indirection via the "static argument transformation" at the site where the type is known
03:32:29 <cheater_> where the code is easiest to look at
03:33:04 <ion> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
03:33:22 <Saizan> and something like min3 is likely to get inlined
03:34:03 <ion> How about some domain-specific wrapper over that?
03:34:12 <endojelly> Saizan, dictionaries?
03:35:15 <ion> The typeclass instance structures.
03:35:44 <ion> “data Num a = Num { fromInteger :: Integer -> a; (+) :: a -> a -> a; … }”
03:35:45 <Saizan> endojelly: GHC implements typeclasses by making functions take records that contain the implementations of methods
03:35:48 <mcstar> what to make of this? http://imgur.com/nOvMv
03:35:55 <Saizan> endojelly: and those are called dictionaries
03:36:14 <endojelly> Saizan, oh, didn't know that. nice.
03:36:38 <merijn> mcstar: Paste the code of ARR_WORDS and maybe someone can figure out what/why is leaking
03:37:00 <endojelly> Saizan, can it still do that optimization on compiled code, though?
03:37:15 <mcstar> merijn: thats the problem, i dont even know what that is
03:37:26 <Saizan> ARR_WORDS is not something you define
03:37:38 <Saizan> i think it's the memory for arrays, but icbw
03:37:57 <wern> ion: thanks, I've looked into that. I just wondered if there was a more elegant to construct nested lists of strings that I've completely missed, but the answer seems to be no then
03:38:28 <mcstar> hah, i have a hunch. ofc
03:38:52 <Saizan> endojelly: if ghc decides some function should be inlined it'll put the code in the .hi files so it can do this sort of thing for compiled code too
03:39:05 <endojelly> Saizan, ah. that's what I was missing, thanks.
03:39:09 <mcstar> ofc since SHA256 is message digester, i.e. it can consume 32bytes at a time, and make a hash incrementally
03:39:19 <mcstar> i think it stores all my inputs to it in an array
03:39:31 <mcstar> even if i dont use that explicitely anymore
03:40:05 <Saizan> endojelly: but also i think that even if min3 doesn't get inlined there should be a single dictionary lookup per call rather than 2, those that wouldn't help so much here
03:40:17 <Saizan> s/those//
03:40:54 <endojelly> Saizan, I see. I think I'll take a look at the compiled code later on
03:41:20 <Saizan> ghc-core is nice for this
03:41:38 <endojelly> isn't ghc-core still lazy?
03:42:39 <Saizan> yes, the Core language is lazy, but you can already see the effects of most of these optimizations
03:43:39 <Saizan> (the -dsuppress-* flags are nice to get a cleaner output)
03:43:41 <endojelly> Saizan, great, I'll also take a look at that, then
03:45:45 <mekeor> when should i use String, Text or Bytestring? more precisely, i'm reading (and parsing) lots of text-files, so which string-type would you recommend?
03:46:21 <merijn> mekeor: For text files you should use Text
03:46:37 <mekeor> merijn: okay. when should i use bytestring ?
03:46:44 <merijn> Binary data
03:46:48 <mekeor> ah. okay.
03:46:50 <merijn> The string part of the name is misleading
03:46:58 <merijn> It should really just be "bytes"
03:47:03 <mekeor> merijn: ah, okay. fine. thanks :)
03:47:24 <Saizan> mcstar: http://stackoverflow.com/questions/7241470/what-is-arr-words-in-a-ghc-heap-profile
03:51:04 <EnglishGent> hello :)
03:51:26 <mekeor> hi EnglishGent
03:52:35 <EnglishGent> hi mekeor :)
03:53:48 <merijn> :t \x y -> (`foldr` x y)
03:53:49 <lambdabot> forall t a b. (t -> b) -> t -> (a -> b -> b) -> [a] -> b
03:55:18 <merijn> :t \x y -> ((`foldr` x) y)
03:55:19 <lambdabot> forall a b. b -> (a -> b -> b) -> [a] -> b
03:55:42 <EnglishGent> not technially a haskell question... but one of the few places I know where I could ask this... does anyone know of a good introduction to domain theory?
03:56:06 <EnglishGent> ideally something online - but textbooks work as well :)
03:57:34 <mekeor> EnglishGent: well, http://en.wikipedia.org/wiki/Domain_theory is fine.
03:57:53 <mekeor> ;) :Þ :) :D
03:57:58 <Saizan> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics <- this is a very basic introduction, but could be a start
03:58:14 <anicake> hi all
03:58:17 <mekeor> hi anicake
03:58:17 <EnglishGent> thanks mekeor, Saizan :)
03:58:22 <EnglishGent> hi anicake
03:59:42 <mcstar> Saizan: thanks
04:00:16 <merijn> Is there a way to provide a (record syntax) datatype with default values so that I can have "data Foo = Foo { foo :: Stuff, bar :: Stuff}" and only need to write the specific fields I want different when creating a new instance? Or should I just write a wrapper function mkFoo?
04:00:58 <Botje> yes, smart constructor.
04:01:08 <Botje> merijn: or you could provide a 'default' Foo instance that people can extend.
04:01:37 <mekeor> merijn: defaultValue = Foo { foo = someStuff, bar = someOtherStuff }
04:01:55 <mekeor> merijn: then, just do: defaultValue { foo = someUpdate }
04:02:35 <mekeor> merijn: and don't export the constructor `Foo'.
04:03:15 <mekeor> http://www.haskell.org/haskellwiki/Smart_constructors
04:04:40 <merijn> Botje, mekeor: Thanks, that seem to essentially boil down to have a mkFoo, so I'll just do something in that direction :)
04:05:13 <mekeor> yep
04:13:21 <Saizan> the default value is nicer than mkFoo because update syntax is nicer
04:24:13 <sanjoyd> What does this mean "isUnLiftedType ty | Just ty' <- coreView ty = isUnLiftedType ty'" ?
04:24:29 <sanjoyd> As in, the syntax "f x | T a <- g x = bar" ?
04:24:36 <azaq23> it's a view pattern
04:24:40 <merijn> pattern guard
04:24:55 * sanjoyd googles
04:24:57 <merijn> If gx pattern matches with T a, then it executes. Else it falls through
04:25:29 <mekeor> @where pattern guards
04:25:29 <lambdabot> I know nothing about pattern.
04:25:33 <mekeor> bummer
04:25:59 <sanjoyd> Yeah, got it.
04:26:33 <merijn> mekeor: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
04:26:48 <mekeor> @where pattern guards
04:26:48 <lambdabot> guard http://www.haskell.org/haskellwiki/Pattern_guard
04:26:57 <merijn> That's the paper describing their use case/introduction
04:32:22 <nart> ciao :)
04:33:59 <mekeor> ciao, nart
04:34:24 <nart> why ByteString.Lazy.Char8 doesn't implement hGetLine ?
04:35:03 <merijn> nart: Because bytes don't have lines?
04:35:13 <ion> Wouldn’t it be just an alias to ByteString.Lazy.hGetLine?
04:35:45 <nart> merijn: but Data.ByteString has it
04:35:58 <merijn> Ah, you're right
04:36:06 <nart> the strict bytestring has it while the lazy one doesn't
04:36:12 <merijn> Man, they shouldn't have done that, IMO...
04:36:21 <sanjoyd> > 5 :: Int#
04:36:22 <lambdabot>   Not in scope: type constructor or class `Int#'
04:36:33 <sanjoyd> How do I access the unlifted types?
04:37:02 <sanjoyd> Do I need to import something?
04:37:51 <ion> import GHC.Prim or something and use -XMagicHash. And i think it’s 5# :: Int#.
04:38:41 * hackagebot peg 0.1 - a lazy non-deterministic concatenative programming language  http://hackage.haskell.org/package/peg-0.1 (DustinDeWeese)
04:39:26 <sanjoyd> Umm, so unlifted types have kind #.
04:39:58 <nart> how can i read lines from a file using ByteString.Lazy ?
04:41:35 <Saizan> ?type Data.ByteString.Lazy.hGetLine
04:41:36 <lambdabot> Not in scope: `Data.ByteString.Lazy.hGetLine'
04:43:15 <Saizan> nart: you could hGetContents and use lines
04:43:48 <nart> Saizan:  i'll try that, ty
04:44:06 <ion> Or a strict hGetLine and put that into a lazy BS.
04:44:15 <Saizan> look at Text too if you have textual data
04:48:10 <merijn> I'm starting to get my "so abstract the code becomes completely ununderstandable"-fu :p
04:52:34 <Zariel> is there a better way to do this? https://gist.github.com/e06f32c3fcd4e4735a1f
04:52:48 <Zariel> for use with parsec
04:53:16 <merijn> "return . return $ anyChar"?
04:53:33 <chra> I would do: (:[]) <$> anyChar
04:54:09 <merijn> Actually
04:54:27 <gdeest> this applicative style thing is really something I need to get my head around
04:54:32 <merijn> Actually, "return <$> anyChar" would be better
04:54:49 <ion> pure <$> anyChar :-(
04:54:49 <Zariel> where is the documentation for <$> ?
04:54:52 <merijn> gdeest: I spent the last two days understanding it, now I can write gems like:
04:54:57 <ion> Data.Functor
04:55:00 <merijn> "(-->) task1 task2 chan = (>>=) <$> task2 chan <*> flip task1"
04:55:32 <ion> merijn: But perhaps you shouldn’t. ;-)
04:55:36 <gdeest> Not sure it makes for clarity
04:55:47 <merijn> ion: I know, but the original was even worse :p
04:55:48 <gdeest> But it's terse, for sure
04:56:04 <merijn> ion: I'm playing around with argument order to see if I can clean it up a bit
04:56:19 <danr> @type \t1 t2 ch -> (>>=) <$> t2 ch <*> flip t1
04:56:20 <lambdabot> forall t (m :: * -> *) a b a1. (Monad m) => (a -> a1 -> m b) -> (t -> a1 -> m a) -> t -> a1 -> m b
04:57:59 <merijn> danr: Basically I have "type Task = Chan Field -> Info a -> IO (Chan Field)" and want to compose two tasks, passing the same info structure to both, that's what it does. But because of the IO in the return of Task it gets messy
05:01:38 <kallisti> question about IRC: it seems as though most of the parameters in USER are ignored for clients, but they're still required...
05:01:50 <kallisti> should I just throw in anything for those parameters?
05:05:22 <ion> Might as well put the hostname and the servername in there, it’s not as if you lose anything that way. http://www.irchelp.org/irchelp/rfc/chapter4.html#c4_1_3
05:05:28 <merijn> If "(->) r" is an instance of Functor, does that mean that "(->) a ((->) b)" is too?
05:06:21 <hpc> merijn: sure, if you fix the kind error
05:06:52 <merijn> (Yeah, I'm not sure I got that type right...)
05:06:54 <hpc> (->) a :. (->) b -- should be a Functor
05:07:20 <hpc> where fmap = (.:), i bet
05:08:19 <hpc> that should generalize to any Functor f,g => f :. g
05:13:46 <merijn> I realise I'm being stubborn, but dammit. I won't give up until I have a nice way to write this...
05:14:24 <byorgey> merijn: there's no way to write functor composition without making a newtype.  Haskell doesn't have type-level lambdas.
05:14:31 <merijn> Essentially I need a function of the type "(a -> b -> m b) -> (a -> b -> m b) -> a -> b -> m b"
05:14:54 <merijn> i.e. it pass the input a to both functions and the result of applying the first one to the second one...
05:16:03 <gdeest> @hoogle (a -> b -> m b) -> (a -> b -> m b) -> a -> b -> m b
05:16:03 <lambdabot> No results found
05:16:06 <byorgey> "and the result of applying the first one to the second one" --- huh?
05:16:06 <gdeest> No luck :P
05:16:07 <hpc> :t (>=>)
05:16:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:16:30 <merijn> The closest thing I found so far was "(-->) task1 task2 chan = (>>=) <$> task2 chan <*> flip task1", but that's a bit cryptic (and I'd like to eliminate that chan variable if possible...)
05:16:51 <byorgey> @type \f g a -> f a >=> g a
05:16:52 <lambdabot> forall t a (m :: * -> *) b c. (Monad m) => (t -> a -> m b) -> (t -> b -> m c) -> t -> a -> m c
05:16:59 <merijn> hpc: \o/
05:17:06 <merijn> Maybe I want "fmap (>=>)"
05:17:13 <hpc> :t fmap (>=>)
05:17:14 <lambdabot> forall a (m :: * -> *) b c (f :: * -> *). (Monad m, Functor f) => f (a -> m b) -> f ((b -> m c) -> a -> m c)
05:17:23 <byorgey> not quite
05:17:27 <hpc> :t (Prelude..) (>=>)
05:17:27 <lambdabot> forall a (m :: * -> *) b c a1. (Monad m) => (a1 -> a -> m b) -> a1 -> (b -> m c) -> a -> m c
05:17:35 <hpc> yeah...
05:17:44 <byorgey> @type liftA2 (>=>)
05:17:44 <hpc> :t flip (Prelude..) (>=>)
05:17:45 <lambdabot> forall a (m :: * -> *) b c (f :: * -> *). (Monad m, Applicative f) => f (a -> m b) -> f (b -> m c) -> f (a -> m c)
05:17:45 <lambdabot> forall c a (m :: * -> *) b c1. (Monad m) => (((b -> m c1) -> a -> m c1) -> c) -> (a -> m b) -> c
05:17:52 <byorgey> not fmap, liftA2
05:18:05 <hpc> @src liftM2
05:18:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:18:19 <hpc> byorgey: not quite that either
05:18:29 <byorgey> eh? why not?
05:18:30 <merijn> Well, I can rewrite "(>>=) <$> task2 chan <*> task1" to "(>=>) <$> task2 <*> task1"
05:18:41 <hpc> i think
05:18:42 <byorgey> that's liftA2 (>=>).
05:18:50 <byorgey> oh, but flipped?
05:18:51 <merijn> :t liftA2
05:18:52 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:18:54 <hpc> oh wait, that is what you want
05:19:06 <hpc> forgot 'f' is going to be (->) a
05:19:11 <byorgey> right
05:19:30 <byorgey> merijn: oh, you want to pass the output of the second argument to the first?
05:19:44 <merijn> byorgey: Yeah, I'm building the graph in reverse order
05:19:53 <byorgey> ok, in that case  liftA2 (<=<)
05:19:58 <merijn> (so I can share output Chan's between multiple forkIO threads)
05:20:20 <byorgey> @type  liftA2 (<=<) :: (a -> b -> m b) -> (a -> b -> m b) -> a -> b -> m b
05:20:21 <lambdabot>     Could not deduce (Monad m) from the context ()
05:20:21 <lambdabot>       arising from a use of `<=<' at <interactive>:1:7-11
05:20:21 <lambdabot>     Possible fix:
05:20:29 <byorgey> @type  liftA2 (<=<) :: Monad m => (a -> b -> m b) -> (a -> b -> m b) -> a -> b -> m b
05:20:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m b) -> (a -> b -> m b) -> a -> b -> m b
05:20:52 <merijn> byorgey: Well, it type checks, so that's a start :p
05:21:16 <hpc> > let f x y = Just (x + y); g x 0 = Nothing; g x y = Just (x / y); (-->) = liftA2 (>=>) in (f --> g) 5 (-5) -- i think this will be Nothing
05:21:17 <lambdabot>   Nothing
05:21:21 <hpc> yay
05:21:45 <hpc> :t liftA2
05:21:46 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:21:50 <hpc> :t (<=<)
05:21:50 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:22:27 <hpc> :t liftA2 (<=<)
05:22:29 <lambdabot> forall b (m :: * -> *) c a (f :: * -> *). (Monad m, Applicative f) => f (b -> m c) -> f (a -> m b) -> f (a -> m c)
05:22:34 <merijn> In true haskell style my 4 lines IO function with 5 variables has evaporated into a two word point free implementation...
05:23:26 <Philippa> two words and how many operators?
05:23:32 <hpc> haha
05:23:41 <merijn> Philippa: I counted the one operator as one of the two words
05:24:48 <hpc> (^<>) = do { (.) <- (....); (.<); (>.^) <- (<<<) (.); return (>.^)} -- two words and pointfree; how elegant!
05:25:12 * gdeest vomits
05:25:32 <quicksilver> mekeor: good to know, thanks
05:25:47 <nart> what's the fastest json library ?
05:26:09 <merijn> It went from "(-->) task1 task2 chan = (>>=) <$> task2 chan <*> task1" to "(-->) = liftA2 (<=<)"
05:26:44 <hpc> shouldn't that be (<--) now?
05:26:56 <merijn> No
05:28:06 <hpc> why?
05:28:13 <merijn> The original one is reversed to. You want to specify sequences forward "a --> b" meaning output of a goes into b, but I want to create backwards so I can have multiple tasks writing into a single output Chan (which means having to create output first and build the graphs backwards)
05:28:39 <Elemir> @hoogle (....)
05:28:39 <lambdabot> No results found
05:29:05 <hpc> merijn: and so the output of b goes to a, doesn't it?
05:29:11 <merijn> So a task takes an output Chan and returns its input Chan. So you first create b and use the input chan of b as input for a
05:29:49 * kallisti needs some help with conduit 0.4
05:29:55 <merijn> hpc: yes, but the output of b is its input Chan
05:30:38 <hpaste> kallisti pasted “IRC connect?” at http://hpaste.org/66856
05:30:46 <kallisti> in runIRCClient
05:31:10 <hpc> so it works out that way for just this use case then
05:31:11 <mekeor> Why is Data.Text (still) (marked as) experimental (on hackage)?
05:31:13 <kallisti> the (connect >> out)  thing is obviously wrong. I think I need to use resumePipe or something.
05:31:41 <hpc> if this was in a general-purpose library, it should definitely be the other way around
05:31:44 <reinoud> @hoogle par
05:31:45 <lambdabot> Data.Char ParagraphSeparator :: GeneralCategory
05:31:45 <lambdabot> Text.Read parens :: ReadPrec a -> ReadPrec a
05:31:45 <lambdabot> Data.Version parseVersion :: ReadP Version
05:31:53 <hpc> thisActionSecond --> thenThisFirst -- confusing
05:31:58 <kallisti> basically I want to send some commands to the output sink before passing it to the client itself.
05:32:05 <merijn> hpc: No, you are misunderstanding
05:32:20 <merijn> hpc: It *is* "thisActionFirst --> thisActionSecond"
05:32:48 <hpc> merijn: not when you define it as liftA2 (<=<)
05:32:55 <merijn> I mentioned earlier the input types are "type Task = Info a -> Chan Field -> IO (Chan Field)"
05:33:19 <merijn> To a task takes a Chan and spawns a thread that does some work and writes the result to an output channel
05:34:06 <merijn> The problem is that if I have tasks that run in parallel I want to aggregate the result, so the output Chan must be created first, then passed to the Task creation function (which should then return the input channel of that task)
05:35:01 <merijn> So if I construct tasks like that (argument is the output channel, return value is the input channel) then you want to compose in reverse. Since the output channel of a will be the input channel of b (i.e. b's result)
05:35:03 <hpc> merijn: yeah, so you use it like (action --> createChan)
05:35:41 <hpc> merijn: but in the general case, for uses where it's (action --> anotherAction), anotherAction is getting done first
05:35:43 <merijn> So "a --> b" (a's result going into b) needs to create b first and then pass b's input channel to a, so a can use it as output channel
05:36:20 <merijn> hpc: --> composes tasks, the order in which tasks are getting created is irrelevant since they are persistent
05:36:53 <merijn> Who cares that 'b' is instantiated before 'a', the input of the resulting composition goes into the task associated with a before it goes into b
05:38:10 <eacameron> If I'm using Data.Text everywhere instead of String, is there a way to make Data.Text imports override Prelude imports?
05:39:17 <hpc> merijn: http://hpaste.org/66857 -- this is what i mean
05:39:23 <rekado> Hi, I'm looking for a function that converts a Lazy ByteString into a base64 representation of a LBS.
05:39:32 <hpc> merijn: act2 is executing before act1
05:39:39 <rekado> I only found the strict version in base64-bytestring
05:39:39 <kallisti> rekado: I haven't found such a thing unfortunately
05:39:44 <kallisti> only the strict, yes.
05:39:50 <rekado> kallisti: too bad.
05:39:58 <merijn> hpc: Sure, but (-->) has a stricter type than liftA2 (<=<) so your example is a type error
05:40:02 <kallisti> yes. I might actuall contact the maintainer and see about submitting a patch.
05:40:05 <kallisti> *actually
05:40:20 <quicksilver> rekado: simple enough to use the strict version on a lazy bytestring though
05:40:36 <hpc> merijn: that's what i mean; the name works for you but not in the general case
05:41:01 <rekado> kallisti: there is a lazy implementation in HsOpenSSL, but I don't feel like importing this package only for that function
05:41:20 <kallisti> rekado: ah, well we can just send that code to the maintainer then.
05:41:23 * hpc is doing a terrible job explaining what he means
05:41:41 <rekado> quicksilver: of course, but I have to constantly shift between the LBS and SBS in the code, just because of that.
05:41:46 <quicksilver> rekado: no you don't.
05:41:52 <quicksilver> rekado: toChunks . map encode . fromChunks
05:42:09 <kallisti> that doesn't work
05:42:17 <merijn> hpc: I think we're int violent agreement but talking past eachother? :p
05:43:01 <quicksilver> kallisti: why not?
05:43:10 <hpc> merijn: probably
05:43:27 <hpc> merijn: it's neat how simply constraining the type affects what the name should be
05:43:29 <quicksilver> kallisti: oh, extra padding if the chunks aren't the right length?
05:44:28 <kallisti> yes.
05:44:29 <merijn> @hoogle m a -> (a -> m b) -> m a
05:44:30 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:44:30 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:44:30 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:45:24 <merijn> I refuse to believe no one has implemented that combinator yet...
05:45:33 <kallisti> quicksilver: well, maybe not.
05:45:54 <eacameron> anyone? How can I make Data.Text imports override Prelude?
05:45:55 <kallisti> quicksilver: I think you would have to explicitly handle the padding at least.
05:46:12 <merijn> If I try to search Hayoo! it clobbers my query when I start typing an ->, am I doing something wrong?
05:46:17 <kallisti> eacameron: there are serveral options.
05:46:30 <kallisti> you can do:  import Data.Text as T
05:46:38 <kallisti> and now you can prepend T. to Text functions that conflict
05:46:43 <kallisti> if you need to use both Prelude and Data.Text
05:46:49 <eacameron> kallisti: Yeah, I'm trying to avoid the T thing
05:46:51 <kallisti> you would want:  import qualified Data.Text as T
05:46:56 <kallisti> eacameron: otherwise you just want to do
05:47:01 <kallisti> import Prelude hiding (x, y, z)
05:47:12 <kallisti> (but I prefer the T thing :P )
05:47:17 <eacameron> kallisti: isn't Prelude imported already?
05:47:32 <kallisti> only if you don't import it explicitly
05:48:06 <eacameron> kallisti: ahhh, ok. thanks a ton. I might just stick with the T thing, though, since I have a whole slew of functions I'm using. I'd have to "hide" all of them
05:48:06 <kallisti> so for example if you want to hide the Prelude you can do:  import Prelude ()
05:48:22 <eacameron> kallisti: oh, I never knew that: cool
05:48:43 <merijn> @djinn m a -> (a -> m b) -> m a
05:48:44 <lambdabot> f a _ = a
05:48:53 <merijn> Not what I had in mind >.>
05:49:24 <eacameron> merijn: This is the only place on might mistake >.> with a Haskell infix operator ;)
05:49:37 <eacameron> merijn: *one
05:49:44 <Botje> merijn: what would the role of the a -> m b be?
05:49:56 <Axman6> f ma g = do { a <- ma; g a; return a}?
05:50:01 <merijn> Botje: IO action to run
05:50:13 <Axman6> :t let f ma g = do { a <- ma; g a; return a} in f
05:50:14 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> (b -> m a) -> m b
05:50:19 <merijn> Axman6: Yeah, I have that now. I just wanted a nice combinator for that :p
05:50:20 <Axman6> heh
05:50:25 <hpc> i can see cases where that's useful
05:50:26 <fmap> eacameron: You can hide whole Prelude with -XNoImplicitPrelude
05:50:37 <Axman6> @@ pl undo f ma g = do { a <- ma; g a; return a}
05:50:37 <lambdabot>  pl undo f ma g = do { a <- ma; g a; return a}
05:50:42 <Axman6> -_-
05:50:51 <merijn> Botje: Sample use case, create a new IO value, pass it to a forkIO, then return the newly created value
05:50:53 <Axman6> @. pl undo f ma g = do { a <- ma; g a; return a}
05:50:53 <lambdabot> f = (. flip (liftM2 (>>)) return) . (>>=)
05:50:54 <eacameron> fmap: so that's the same as `import Prelude ()` ?
05:50:55 <hpc> eacameron: which has the benefit of also not importing instances
05:51:17 <merijn> do { chan <- newChan; forkIO $ doStuff chan; return chan}
05:51:27 <fmap> eacameron: no, import imports instances
05:51:34 <hpc> eacameron: importing nothing from Prelude still gives you instances (im not sure which ones Prelude defines)
05:51:51 <eacameron> hpc: instances means types and classes?
05:51:56 <Botje> newChan >>= (forkIO . doStuff) *> return -- or something?
05:52:01 <kallisti> no it means just instances.
05:52:04 <kallisti> of typeclasses
05:52:05 <hpc> eacameron: instances means instances of classes
05:52:11 <Botje> bleh, nevermind. that's the wrong *>
05:52:19 <hpc> "instance Foo Bar where ..." is imported
05:52:22 <hpc> but not Foo or Bar
05:52:34 <eacameron> hpc: it's always simpler than I thought ;)
05:52:39 <hpc> so if you import Foo and Bar in the future, but not another instance
05:52:41 <hpc> it's still there
05:52:59 <hpc> i have no clue if that matters or not for any real use cases
05:53:08 <kallisti> me neither.
05:53:16 <kallisti> that's why I chose not to worry about it. ;)
05:53:27 <hpc> the more you know, etc
05:53:37 <kallisti> though NoImplicitPrelude is probably the more correct thing to do.
05:53:48 <hpc> @let tmyk = text "http://1.bp.blogspot.com/-21_jyYvyZxo/T16-fJ9X6oI/AAAAAAAADqI/HaJaKxYuxfg/s1600/themoreyouknow.jpg"
05:53:49 <lambdabot>  Defined.
05:54:04 <kallisti> more than likely if you want NoImplicitPrelude you also want RebindableSyntax as well.
05:54:10 <kallisti> (which implies NoImplicitPrelude)
05:54:25 <eacameron> hpc: kallisti: so "import XYZ (x, y, z)" only imports functions and datatypes?
05:54:33 <kallisti> and all instances
05:54:44 <eacameron> kallisti: right, forgot that
05:54:50 <kallisti> instances are always imported and exported from everything
05:55:13 <eacameron> kallisti: got it..
05:55:34 <kallisti> also:  import XYZ (T(..))
05:55:45 <merijn> Botje: Not exactly pretty: "newChan >>= fst . (return &&& forkIO . undefined)"
05:55:45 <kallisti> imports T and all of its constructors  if it's a type
05:55:51 <kallisti> or all of its methods if it's a TypeClass
05:55:54 <kallisti> .... *typeclass
05:56:05 <kallisti> TooMuchHaskellProgramming
05:56:50 <kallisti> well, more technically all of the /exported/ constructors and methods...
05:57:09 <kallisti> this is typically what you want when explicitly importing types.
05:57:28 <kallisti> unless you need solely the type, for a type annotation somewhere.
05:58:15 <rekado> kallisti, quicksilver: just sent an email to Bryan suggesting he copies the LBS base64 implementation.
05:58:26 <kallisti> rekado: awesome
05:58:37 <merijn> :t let x >>=| f = x >>= fst . (return &&& f) in (>>=|)
05:58:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> b) -> m a
05:59:18 <merijn> Hmm, now I just need a good operator for that :p
05:59:55 <quicksilver> preflex: seen bos
05:59:56 <preflex>  bos was last seen on #darcs 26 days, 16 hours, 37 minutes and 21 seconds ago, saying: I installed darcs-beta with -fbase44, but darcs-fastconvert - even when patched to depend on darcs-beta - cannot be built because cabal is selecting the wrong deps
06:02:19 <bitonic> merijn: that's 'x <* (x >>= f)'
06:02:43 <merijn> bitonic: Ha! I knew someone must've written that combinator before :)
06:02:50 <bitonic> merijn: which combinator?
06:02:59 <bitonic> I mean it's really easy to write
06:03:04 <merijn> m a -> (a -> m b) -> m a
06:03:05 <bitonic> I'm not sure it deserves a name :P
06:03:24 <khanage> is it possible to export a class instance from a module?
06:03:39 <kallisti> no. all instances are implicitly exported and imported from modules.
06:04:11 <khanage> kallisti: so that would override an explicit export list?
06:04:24 <kallisti> yes, if such a thing were possible. but it's not.
06:04:25 <khanage> kallisti: or is it best to just put instances in a normal module
06:04:44 <kallisti> khanage: what do you mean by normal module?
06:05:07 <kallisti> in other words: any instances you import, are also exported. and there's no way to hide instances.
06:05:19 <bitonic> merijn: ah wait sorry, >>=| is 'x *> (f <$> x)'
06:05:34 <khanage> kallisti: sorry, i'm probably not using the right terms. I mean a module where I don't provide a list of exports, e.g. module Thing ( module Data.Monoid, et al) where
06:05:55 <magicman> > [1,2,3] *> ((+1) <$> [1,2,3])
06:05:56 <lambdabot>   [2,3,4,2,3,4,2,3,4]
06:06:04 <khanage> kallisti: ahh, right, thanks :)
06:06:12 <kallisti> khanage: yeah it's irrelevant here
06:06:16 <magicman> > let x >>=| f = x >>= fst . (return &&& f) in [1,2,3] >>=| (+1)
06:06:18 <lambdabot>   [1,2,3]
06:07:03 <magicman> You want \x f -> x >>= \x' -> f x' >> return x' ? Looks like that's neither of the two :P
06:07:06 <hpc> > let x >>=| f = x >>= snd . (return &&& f) in [1,2,3] >>=| (+1)
06:07:07 <lambdabot>   Ambiguous type variable `m' in the constraint:
06:07:07 <lambdabot>    `GHC.Base.Monad m'
06:07:07 <lambdabot>      a...
06:07:12 <hpc> pah
06:07:21 <kallisti> khanage: http://en.wikipedia.org/wiki/Open_world_assumption
06:07:37 <bitonic> no, 'x <* (f <$> x)', I'm distracted today :P
06:08:16 <magicman> That's just the result of x, and x's effects twice.
06:08:17 <hpc> @src (<*)
06:08:18 <lambdabot> (<*) = liftA2 const
06:08:41 <magicman> You want the effects of x, the effects of x >>= f, but also the result of x.
06:08:51 <magicman> Otherwise, why bother with the f at all, right?
06:08:57 <hpc> > [1,2] <* [1,2]
06:08:58 <lambdabot>   [1,1,2,2]
06:08:59 <bitonic> m <* n = do x <- m; n; return x
06:09:07 <hpc> > [1,2] <* (succ <$> [1,2])
06:09:08 <lambdabot>   [1,1,2,2]
06:09:12 <hpc> > [1,2] *> (succ <$> [1,2])
06:09:13 <lambdabot>   [2,3,2,3]
06:09:34 <hpc> > [1,2] *> [1,2]
06:09:35 <lambdabot>   [1,2,1,2]
06:09:37 <hpc> huh
06:09:44 <bitonic> *> = >>
06:09:45 <kallisti> I have often wanted a <* that takes a lambda.
06:10:03 <hpc> kallisti: you mean (<*>)? ;)
06:10:06 <bitonic> kallisti: a lambda for the second argument?
06:10:08 <kallisti> no
06:10:09 <kallisti> yes
06:10:30 <kallisti> like <*, but analogous to >>= instead of >>
06:10:41 <hpc> :t (<*)
06:10:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:10:49 <magicman> @pl \x f -> x >>= \x' -> f x' >> return x'
06:10:49 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
06:10:54 <magicman> (there ya go <_<)
06:11:09 <kallisti> rolls off the tongue.
06:11:37 <magicman> > let x >>=| f = x >>= \x' -> f x' >> return x' in [1,2,3] >>=| (\x -> [x,x*10])
06:11:37 <lambdabot>   [1,1,2,2,3,3]
06:12:42 <magicman> I guess it's more obvious with getLine >>=| putStrLn, but lambdabot doesn't like that <_<
06:13:01 <danr> magicman: echoing and return?
06:13:04 <magicman> :t let x >>=| f = x >>= \x' -> f x' >> return x' in getLine >>=| putStrLn
06:13:05 <lambdabot> IO String
06:13:06 <magicman> Aye.
06:13:07 <kallisti> I would call it (<*=)  but that's kind of a weird operator name.
06:13:13 <bitonic> strange, I never wanted such a thing
06:13:30 <kallisti> it becomes more useful when your monad does side-effects.
06:13:48 <magicman> In IO, State, Writer, etc. it's useful.
06:14:02 <bitonic> I use those monads all the time, and still :P
06:14:17 <bitonic> I guess I just quickly write what I need with the applicative combinators and I don't even notice
06:14:18 <magicman> It's nonsensical in Reader, and it does *something* in [], but I'm not sure if anyone wants that :p
06:14:47 <magicman> I think you actually need Monad for it. Applicative isn't enough.
06:15:27 <bitonic> magicman: no I mean, the applicative combinators are really useful to write this kind of stuff concisely
06:15:49 <magicman> Sure.
06:17:06 <magicman> do {x' <- x; f x'; return x'} -- I think that's the most concise it'll get. Except through pre-defined operator.
06:17:17 <bitonic> yes
06:17:27 <bitonic> you don't even need the braces
06:17:31 <magicman> Point.
06:17:51 <bitonic> and I wouldn't call a monadic action 'x' :D
06:18:31 <bitonic> do x <- m; f x; return x. pointed programming doesn't get enough love
06:18:41 <bitonic> in FP land
06:19:27 <magicman> Eh, I've only been calling it x because we've been defining the combinator as x >>=| f :p
06:19:39 <magicman> Though I guess that one could be called m as well.
06:19:52 * danr worries that bitonic will start a campaign for pointful Haskell programming
06:19:54 <flux> bitonic, it needs a good punch line. "Programming with a point!" "Why code pointlessly!"
06:19:55 <kallisti> addiction to variable names i bad, mmk
06:20:18 <magicman> But x <* (f <$> x) === x <* x.
06:21:47 <bitonic> danr: eheh maybe!
06:22:53 <bitonic> pointless is great but some people go too far :P
06:27:25 <magicman> I like how @pl is basically "convert to BCKW calculus".
06:28:04 <magicman> It's got some other shortcuts, like the liftMn family, but at the heart there's (.), flip, const, and join.
06:29:19 <bitonic> magicman: the liftMn family was made obsolete by <$> and <*>
06:29:26 <magicman> I know.
06:29:47 <bitonic> just saying :P
06:29:49 <magicman> I'm talking about the functionality of @pl.
06:30:02 <mm_freak> you know?  i disagree there
06:30:17 <mm_freak> liftA* and liftM* are often nicer than combinations of <$> and <*>
06:30:20 <bitonic> mm_freak: ah, right. @pl is kinda useless
06:30:29 <bitonic> sorry, magicman
06:30:41 <bitonic> mm_freak: I prefer <$> and <*>, I don't have to think about the 'n'
06:30:45 <magicman> Ooh, is it based on the not-always-being-Applicative-when-it-is-a-Monad? In that case, they're not the same, sure.
06:31:06 <bitonic> magicman: no it's not, but it has a - limited - set of hard-coded combinators
06:31:08 <magicman> I prefer <$> and <*> too, actually >_>
06:31:20 <bitonic> and it's missing all the Arrow and Applicative stuff
06:31:26 <mm_freak> bitonic: if n is small and the whole expression is on one line, liftA* is usually easier to read
06:31:41 <bitonic> mm_freak: tastes
06:31:55 <mm_freak> in particular it can be an advantage to see n in the code, because sometimes it's not visible
06:32:07 <mm_freak> f' = liftA3 f x y
06:32:32 <mokus> lift[AM]. are nicer when you're just lifting but not applying - eg, foo = liftA3 bar rather than foo x y z = bar <$> x <*> y <*> z
06:33:18 <bitonic> mokus: you can use (bar <$>) eh
06:33:21 <mokus> or like mm_freak's example where you're applying but not fully
06:33:25 <mm_freak> i think liftA* is nicer whenever everything fits on one line
06:33:35 <mm_freak> for multiline combinations i use <*>, too
06:33:37 <mokus> @type ((+) <$>)
06:33:38 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
06:33:47 <mokus> @type liftA2 (+)
06:33:48 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
06:34:04 <bitonic> mokus: right
06:35:14 <bitonic> yeah I always get confused with those
06:35:39 <bitonic> I just prefer to use always the applicative ones... but I guess sometimes the lifts are more convenient
06:35:51 <knightlain> Hi People
06:35:58 <knightlain> can somebody help me with haskell?
06:35:58 <mokus> yup, like so many things it's a matter of both taste and situation
06:37:00 <geekosaur> knightlain, don't ask to ask, just ask
06:37:55 <knightlain> Ok
06:38:04 <knightlain> I have a binary tree like this
06:38:14 <knightlain> data AB t = A (AB t) t (AB t) | V deriving Show
06:38:29 <knightlain> that data structure represents it
06:38:49 <knightlain> but how can I get it to show its structures
06:38:55 <knightlain> in preorder
06:38:55 <knightlain> inorder
06:38:58 <knightlain> and postorder?
06:39:06 <bitonic> knightlain: you want to flatten its contents?
06:39:16 <bitonic> e.g. get a list of values in its nodes?
06:39:24 <knightlain> just get its values
06:39:32 <knightlain> yes
06:39:55 <bitonic> knightlain: 'toList (A l v r) = toList l ++ [v] ++ toList r; toList V = []'
06:39:58 <mm_freak> knightlain: first write the type of the function you want
06:40:05 <danr> knightlain: is this homework?
06:40:09 <bitonic> actually yeah I shouldn't just have written it like this :P
06:40:18 <mm_freak> i really don't understand why people here insist on providing ready-made solutions
06:40:24 <mm_freak> that's not helpful at all
06:40:27 <bitonic> mm_freak: you're right, I usually don't
06:40:31 <bitonic> I just typed it
06:40:42 <bitonic> and I definitely don't "insist" in providing them
06:41:08 <danr> anyways, that's just one way of solving it. a typical bitonic way, full of points :P
06:41:19 <knightlain> well
06:41:21 <knightlain> it is
06:41:27 <knightlain> but I try to ask specific questions
06:41:32 <knightlain> and not to have the exact answer
06:42:03 <mm_freak> knightlain: then ignore the code and write it yourself…  as said, first write its type signature…  the type often tells you what the function has to look like
06:42:48 <danr> knightlain: oh, what mm_freak said, and pattern matching
06:44:31 <mm_freak> knightlain: a nicer way to turn a custom data structure into a list is to write a Foldable instance…  see Data.Foldable
06:45:04 <knightlain> Showtree :: AB -> [Int]
06:45:28 <mm_freak> knightlain: that type is not correct (and is also a syntax error)
06:45:38 <fmap> mm_freak: i don't get how types could be helpful in this particular case
06:46:45 <mm_freak> fmap: it tells you about the arguments and the result and really doesn't leave many valid possibilities…  it's very difficult to write an incorrect function when the type is given
06:47:17 <mm_freak> in haskell a type is a specification
06:48:21 <fmap> mm_freak: ok, now he has 3 functions with the same type
06:48:29 <t7> roconnor: did you get my pm, i forgot to auth
06:49:09 <mm_freak> fmap: what's your point?
06:56:21 <keep_learning> Hello all
06:56:30 <fmap> mm_freak: types won't help
06:57:21 <keep_learning> Can we have unboxed vector of unboxed vectors . Like this U.Vector ( U.Vector )
06:57:23 <mm_freak> fmap: so writing a type is a mistake?  you realize you're in a haskell channel?
06:57:34 <mm_freak> keep_learning: no
06:57:50 <danr> keep_learning: an unboxed vector is not unboxed itself
06:57:54 <mm_freak> keep_learning: you can use an unboxed vector of size x*y or a boxed vector of unboxed vectors
06:58:12 <keep_learning> mm_freak: Thanks
06:58:15 <mm_freak> keep_learning: you can also use a higher level abstraction like repa
07:00:01 <keep_learning> So which one is best option . list of unboxed vectors ( [ U.Vector ] )  or Boxed vector of Unboxed vectors in terms of performance
07:01:20 <mm_freak> keep_learning: from those two fairly limited choices usually the latter is preferable, unless you generate and consume the inner vectors in a streaming fashion
07:02:30 <keep_learning> mm_freak: danr Thank you
07:07:32 <womb> > 7 ^ 2
07:07:33 <lambdabot>   49
07:07:37 <womb> correct!
07:10:18 <hpaste> merijn pasted “No instance error” at http://hpaste.org/66860
07:10:25 <merijn> What did I mess up here?
07:11:59 <geekosaur> merijn: you gave a type signature that didn't mention Monad
07:12:07 <merijn> oh
07:12:10 <geekosaur> but (>>) needs it
07:12:17 <merijn> *facepalm*
07:12:47 <merijn> Well, that was dumb
07:12:48 <geekosaur> (slightly bogus error message, you used (>>), it should not mention (>>=) even though that's how (>>) is implemented)
07:13:03 <merijn> geekosaur: I do use >>= in the top level
07:13:21 <geekosaur> oh, right, sorry
07:14:48 <womb> i think =>> would look better then >>=
07:15:42 <Ptival> I think than would look better than then
07:17:36 <mm_freak> womb: comonads use =>>
07:17:41 <Tinned_Tuna> Just finished reading Plugging in Haskell. I am thoroughly convinced that I can do anything with Haskell now.
07:18:02 <Tinned_Tuna> I think I'll start the reimplementation of my (python) statistical analysis tool soon...
07:18:11 <Tinned_Tuna> Well, as soon as I can figure out how to do the database stuff
07:18:58 <mm_freak> Tinned_Tuna: there are basically three choices:  HDBC, persistent and acid-state
07:19:21 <mm_freak> there are some more, but most of them are either highly experimental or outdated
07:19:37 <adnauseam> plugging in haskell? do you mean plugging haskell in?
07:20:08 <Tinned_Tuna> adnauseam: possibly...
07:20:24 * Tinned_Tuna goes to find the title...
07:21:13 <Tinned_Tuna> Yes, it is Plugging Haskell In
07:21:15 <adnauseam> is it an academic paper ?
07:22:31 <Tinned_Tuna> adnauseam: aye. It's linked from the plugins-1.5.2.1 page, but the link is dead. I had to go and grab it off dl.acm.org
07:23:34 <adnauseam> found a copy,  i'll be giving it a read man
07:23:59 <Tinned_Tuna> it's quite a short paper, but it makes me feel that if I write my app in the right way, extending it's functionality will be no problem at all.
07:24:54 <Mathnerd314> how does one build the Haskell platform, starting from the source and a copy of GHC? are there instructions anywhere?
07:25:43 <Tinned_Tuna> And possibly able to upgrade/change the functionality without bringing the system down at all.
07:25:45 <adnauseam> Tinned_Tuna: always take care not to fall into the pit of dependency hell
07:26:06 <Tinned_Tuna> As in, cabal dependencies, or dependencies between the plugins/extensions?
07:26:34 <Tinned_Tuna> At the moment, I plan to rely on GetOpts, ConfigFile, (databasething) and plugins-1.5.2.1 from cabal.
07:26:58 <adnauseam> Mathnerd314: it's straight forward
07:27:30 <adnauseam> Mathnerd314: get tar.gz file, tar xvf it, cd into it, do ./configure and then make install
07:28:09 <kallisti> is there any particular reason not to simply include the Safe extension in the cabal file, rather than in every module?
07:28:14 <adnauseam> if you get issues, resolve them one by one. sadly building it on your own does require basic console knowledge
07:28:27 <kallisti> also what's the best way to do so? I was going to add -XSafe to ghc-options, but you could also conditionally include an extensions field
07:28:59 <adnauseam> Mathnerd314: and make sure you have the proper ghc version install, too
07:31:36 <hpc> did hackage just go down?
07:31:47 <kallisti> hpc: it's unresponsive for me
07:31:47 <hpc> oh no, it's just slow for me
07:32:17 <hpc> it's responsive now; it just barfs on the package index pages
07:32:56 <merijn> infixr is ((1 + 1) + 1) + 1 and infixl is 1 + (1 + (1 + 1)), right?
07:34:08 <kallisti> merijn: backwards
07:34:31 <merijn> So close >.>
07:35:03 <hpc> it had to be one or the o
07:35:05 <hpc> er
07:35:10 <hpc> other
07:35:17 <kallisti> man my documentation for webdriver is bad.
07:35:19 <kallisti> I need to fix that.
07:35:27 <hpc> incidentally, it's the same association as foldr/l
07:35:37 <hpc> > foldr (+) 0 [1..5]
07:35:38 <lambdabot>   15
07:35:45 <hpc> > foldr (+) x [1..5]
07:35:46 <lambdabot>   1 + (2 + (3 + (4 + (5 + x))))
07:35:51 <hpc> > foldl (+) x [1..5]
07:35:52 <lambdabot>   x + 1 + 2 + 3 + 4 + 5
07:36:03 <hpc> (pretend that was parenthesized
07:36:27 <kallisti> or pretend it uses the associativity of (+) and thus doesn't show any parentheses.
07:36:46 <hpc> also that
07:41:36 <dmwit> pqmodn: Looks good!
07:45:15 <lamanabie> Whopaaa hej !
07:48:21 <merijn> :t (.) . (.)
07:48:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:48:39 <merijn> :t let (.) = Prelude.. in (.) . (.)
07:48:40 <lambdabot> parse error on input `Prelude..'
07:48:50 <merijn> :t Prelude..
07:48:51 <lambdabot> parse error on input `Prelude..'
07:48:56 <merijn> :t Prelude.(.)
07:48:57 <lambdabot> Not in scope: data constructor `Prelude'
07:49:01 <merijn> hmm
07:49:47 <geekosaur> :t (Prelude..)
07:49:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:50:01 <merijn> :t let (.) = (Prelude..) in (.) . (.)
07:50:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:50:17 <merijn> :t let (.) = (Prelude..) in (.) . (.) . (.)
07:50:18 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
07:51:31 <roconnor> How does 0x10c differ from ICFP-contest 2006?
07:52:32 <merijn> roconnor: Did ICFP2006 involve controlling a spaceship in an MMO game?
07:53:01 <roconnor> merijn: nope, just a robot.
07:53:17 <merijn> Networked robots?
07:53:27 <roconnor> hmm, maybe not :(
07:53:40 <merijn> There's your two differences, then :)
07:54:15 <roconnor> :)
07:54:56 <merijn> bah, there's no nice way to do "foo . bar" where bar needs multiple arguments before it returns the result needed by foo, right?
07:55:19 <mekeor> is (a >>= liftM b) th same as (liftM b a) ?
07:55:20 <merijn> i.e. "\x y z -> foo . bar x y z", but pointfree
07:55:22 <mekeor> merijn: right.
07:56:10 <merijn> mekeor: No, because liftM b wraps b's input type with a monad
07:56:26 <danr> @type \f g -> ((f .) .) .) . g
07:56:27 <lambdabot> parse error on input `)'
07:56:31 <danr> @type \f g -> ((f .) .) . g
07:56:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
07:56:42 <merijn> danr: I said nice :p
07:57:13 <danr> merijn: bah! with that attitude you might just as well join bitonic's pointful campaign
07:57:56 <merijn> mekeor: "\a b -> a >>= liftM b" has type "m (m a) -> (a -> m b) -> m (m b)", whereas "\a b -> liftM b a" has type "m a -> (a -> b) -> m b"
07:58:16 <merijn> (I think, I did that by hand...)
07:58:26 <merijn> :t \a b -> a >>= liftM b
07:58:27 <lambdabot> forall (m :: * -> *) a1 b. (Monad m) => m (m a1) -> (a1 -> b) -> m b
07:58:40 <merijn> :t \a b -> liftM b a
07:58:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
07:58:51 <merijn> bah, so close
07:59:22 <mekeor> hmm
08:00:16 <merijn> danr: Well, at least I have the decency to be annoyed by the lack of beautiful pointfree methods...
08:00:25 * mekeor got it working.
08:02:51 <merijn> @src (.)
08:02:52 <lambdabot> (f . g) x = f (g x)
08:02:52 <lambdabot> NB: In lambdabot,  (.) = fmap
08:03:17 <merijn> @src (->) a fmap
08:03:18 <lambdabot> Source not found. My mind is going. I can feel it.
08:04:08 <geekosaur> @src (->) fmap
08:04:09 <lambdabot> fmap = (.)
08:05:53 <mekeor> huh? what does that mean? i know (->) but what's ((->) fmap) ??
08:06:11 <mekeor> (->) a b == a -> b
08:06:17 <merijn> mekeor: fmap implementation for the type (->)
08:06:22 <merijn> @src Maybe fmap
08:06:22 <lambdabot> fmap _ Nothing       = Nothing
08:06:22 <lambdabot> fmap f (Just a)      = Just (f a)
08:06:43 <mekeor> oO
08:07:21 <roconnor> @src IO fmpa
08:07:21 <lambdabot> Source not found.
08:07:23 <roconnor> @src IO fmap
08:07:24 <lambdabot> fmap f x = x >>= (return . f)
08:07:34 <roconnor> @src liftM
08:07:35 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:07:44 <mekeor> cool.
08:08:33 <bitonic> danr: ahah if you keep bringing this up I'm actually going to make a little webpage
08:08:57 <merijn> argh, this is annoying the crap out of me...
08:09:12 <mekeor> so, "@src Maybe fmap" means "look for the implementation of 'fmap :: (a -> b) -> Maybe a -> Maybe b'", right?
08:09:27 <mekeor> bitonic: lol
08:10:28 <mekeor> so, "@src (->) fmap" means "look for the implementation of 'fmap :: (a -> b) -> (a ->) -> (b ->)'", right?
08:10:51 <quicksilver> mekeor: @src is a work of fiction
08:11:09 <mekeor> ?
08:11:10 <quicksilver> mekeor: @src A B means "search through a manually maintained text file for "A B""
08:11:19 <mekeor> ah
08:11:20 <quicksilver> there is no particular rule about how instances should be stored
08:11:27 <quicksilver> but that is, indeed, the convention adopted.
08:11:33 <geekosaur> and it's not smart enough to parse ((->) e)
08:11:42 <geekosaur> so (->) is used as shorthand
08:11:51 <mekeor> hm
08:12:20 <rwbarton> in haskell 98 "(->) fmap" is enough to identify the instance anyways
08:18:23 <hpaste> Simon pasted “Expect but not” at http://hpaste.org/66862
08:19:56 <mekeor> why does this not work?:   do { code <- liftM Data.Text.Lazy.lines (Data.Text.Lazy.IO.readFile someFilePath) }   -- i get  "Couldn't match expected type `Text' with actual type `Data.Text.Internal.Text'"
08:20:59 <rwbarton> probably where you use that code it expects an (IO) strict Text
08:21:16 <mekeor> rwbarton: i don't use code.
08:21:32 <mekeor> (i just started writing that function..)
08:21:34 <rwbarton> then how can you get error messages
08:21:37 <rwbarton> ghc is code
08:21:40 <rwbarton> irc client is code
08:22:16 <rwbarton> oh you called your variable code
08:22:21 <rwbarton> i meant the code you wrote
08:22:22 <mekeor> oh :D
08:22:24 <mekeor> okay :D
08:22:27 <rwbarton> :)
08:23:18 <geekosaur> I would call it strange if Data.Text.Lazy.IO produces a strict Text
08:23:31 <mekeor> me, too.
08:23:34 <gdeest> Does someone know of a Haskell library that would allow me to remove accents from unicode characters ?
08:23:49 <rwbarton> anyways it seems your error is likely a strict/lazy mismatch, but obviously (hopefully?) that mismatch is not in the code you provided
08:24:22 <rwbarton> why do you have Text imported unqualified anyways?
08:24:40 <Y_Less> I'm currently reading about "Applicative", but my major question is WHY? It seems to be abstracting "return" and "ap", but I'm not even sure why "ap" is needed in the first place. The Control.Monad documentation states that "return f `ap` x1 `ap` ... `ap` xn" is equivalent to "liftMn f x1 x2 ... xn", but the latter seems much more concise so I'm not sure why you'd even use the former to require
08:24:40 <Y_Less> the abstraction. Especially when "f :: a -> b -> c", then "liftM f x" and "return f `ap` x" both have type "m (b -> c)", so I really can't see the advantage of the latter.
08:24:44 <mekeor> rwbarton: i have it qualified.
08:24:56 <rwbarton> then why is ghc talking about `Text'
08:25:14 <rwbarton> maybe hpaste your whole module?
08:25:25 <mekeor> rwbarton: yea, wait a sec
08:25:43 <quicksilver> Y_Less: because there exist structures which are Applicative but not Monad
08:25:45 <Clint> gdeest: you could use unicode-normalization and then filter out all combining characters
08:25:53 <quicksilver> Y_Less: (they support ap but not join)
08:26:04 <tazjin> mekeor: This works for me
08:26:06 <tazjin> > code <- liftM Data.Text.Lazy.lines $ Data.Text.Lazy.IO.readFile "Main.hs"
08:26:06 <tazjin> > :t code
08:26:06 <tazjin> code :: [Text]
08:26:07 <lambdabot>   <no location info>: parse error on input `:'
08:26:07 <lambdabot>   can't find file: L.hs
08:26:16 <baleft> How do you explain "Applicative" to your neighbour?
08:26:19 <gdeest> Clint: thanks
08:26:28 <hpc> Y_Less: foo <$> bar <*> baz <*> quux <*> schnoz <*> blargle -- this is nicer than liftM'ILostCount foo bar baz quux schnoz blargle
08:26:34 <mekeor> tazjin: hmmm
08:26:42 <hpc> because you still have to define that liftM, for larger numbers of arguments
08:26:50 <hpc> and count the arguments
08:27:01 <hpc> and update that count if you add another argument later
08:27:02 <hpc> etc
08:27:15 <geekosaur> gdeest, I think there are bindings for both icu and iconv
08:27:16 <mekeor> oh fooo!! i did 'import qualified Data.Lazy.IO as IO' . shit. sorry guys, thanks.
08:27:37 <mekeor> rwbarton: ^. thanks. thank you, too, tazjin and geekosaur :)
08:27:45 <liyang> Or write foo `fmap` bar `ap` baz `ap` quux `ap` schnoz `ap` blargle :)
08:27:49 <merijn> What's the correct pragma to solve this: "(Use -XMultiParamTypeClasses to allow multi-parameter classes)"?
08:27:52 <quicksilver> hpc: that is not an argument for Applicative though.
08:28:04 <quicksilver> hpc: that's just an argument for two particular infix operators.
08:28:07 <gdeest> geekosaur: thanks too (that's really a domain I am not as ease with)
08:28:17 <hpc> quicksilver: well yeah; that was his question :P
08:28:19 <quicksilver> you can do (<$>) = fmap; (<*>) = ap; for Monads, without using Applicative.
08:28:23 <rwbarton> {-# LANGUAGE MultiParamTypeClasses #-}
08:28:25 <mekeor> merijn: LANGUAGE MultiParamTypeClasses -- ?
08:28:28 <quicksilver> that's not how I read his question.
08:28:44 <hpc> "but I'm not even sure why "ap" is needed in the first place."
08:28:47 <mekeor> quicksilver: refering to which question?
08:28:53 * quicksilver nods
08:28:57 <merijn> rwbarton, mekeor: Thanks :)
08:29:22 <merijn> Is there a pragma cheapsheet because I forget the correct symbol sequence all the time...
08:29:37 <merijn> (The MultiParamTypeClasses part I could guess ;)
08:29:50 <bitonic> merijn: there's one "symbol" to remember: LANGUAGE
08:30:05 <merijn> bitonic: The {-# part too
08:30:11 <geekosaur> well, that and the {-# metasyntax
08:30:13 <bitonic> coincidentally, it is exactly the same as the word "language" in english :P
08:30:23 <bitonic> ah well. that's just an # :P
08:30:53 <Y_Less> It sort of makes a bit more sense now - I think my main problem is the "how do you explain applicative to your neighbor" problem in that a lot of the Haskell documentation seems to be written for category theorists, instead of imperative programmers trying to hack something together. Thanks though.
08:31:08 <quicksilver> it's certainly not written for category theorists
08:31:14 <quicksilver> btu I can understand why you might think that.
08:31:25 <quicksilver> (category theorists would find it as incomprehensible as you do, though)
08:32:20 <Y_Less> OK, well that really raises the question of who it IS written for...
08:32:53 <bitonic> Y_Less: functional programmers
08:32:58 <quicksilver> Y_Less: computer scientists / functional programmers
08:33:31 <womb> > 7 * 7
08:33:32 <lambdabot>   49
08:35:15 <danr> womb: you already did 7 ^ 2 today!
08:35:16 <Chaze> oh wow, my antivirus reports a virus in ghci.exe..
08:39:39 <gdeest> geekosaur: ICU looks great ; Clint: Unicode normalization (with ICU) seems the way to go !
08:39:50 <gdeest> iconv is marked as experimental
08:40:08 <geekosaur> that marking is more or les smeaningless
08:40:55 <geekosaur> (dirty little secret:  the only states in practice are "experimental" and "stable".  "stable" is synonymous with "dead")
08:41:27 <gdeest> It doesn't seem to include any way to normalize text, anyway (unless I am just too ignorant about Unicode to see it)
08:44:21 <geekosaur> gdeest, the iconv method involves asking it to convert to a magic "locale", IIRC
08:50:11 <gdeest> *Main> removeAccents $ pack "Édouard et Gaël, ça va pas la tête !?"
08:50:12 <gdeest> "Edouard et Gael, ca va pas la tete !?"
08:50:51 <gdeest> removeAccents = pack . (filter isLatin1) . unpack . (normalize NFD)
08:51:53 <bitonic> gdeest: I have to write that down somewhere
08:52:09 <bitonic> or it should be packaged in some libraries along with similar functions
08:52:15 <bitonic> those things are really annoying to do manually :P
08:52:50 <gdeest> True enough !
08:53:01 <bitonic> gdeest: where does 'normalize' come from?
08:54:23 <gdeest> Data.Text.ICU.Normalize
08:55:25 <bitonic> ok, that's a package to remember
09:07:34 <statusfailed> In a source file, why can I do a let at the top level like this? "let y = 3 in f x = x + y"
09:07:39 <statusfailed> -why
09:08:26 <hpc> statusfailed: the syntax is "let defns in expr"
09:08:33 <hpc> "f x = x + y" isn't an expression
09:08:37 <hpc> you can do
09:08:47 <hpc> f = let y = 3 in \x -> x + y
09:09:28 <statusfailed> hpc: but there's no way to have the let first, right?
09:10:02 <hpc> no
09:10:11 <statusfailed> ok, thanks :)
09:10:21 <statusfailed> I'm just writing a comparison to F# and wanted to be sure
09:23:24 <notthemessiah> any ways to do a reverse dependency search through hackage?
09:23:24 <lambdabot> notthemessiah: You have 1 new message. '/msg lambdabot @messages' to read it.
09:30:59 <lispy> hello everybody!
09:31:24 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
09:31:25 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:31:35 <lispy> glguy_: Hi
09:31:42 <lispy> glguy: Oops, which glguy_?
09:32:01 <lispy> notthemessiah: yes
09:32:07 <copumpkin> double glguy
09:32:08 <lispy> notthemessiah: There is a website for it
09:32:16 <lispy> notthemessiah: but I always forget the URL
09:32:30 <glguy> double the fun
09:33:32 <quicksilver> notthemessiah: http://packdeps.haskellers.com/
09:34:03 <lispy> quicksilver: thanks!
09:34:14 <quicksilver> although that's for the specific case of upper bound restrictions
09:34:27 <quicksilver> http://packdeps.haskellers.com/reverse
09:35:10 <lispy> edwardk: Do you know how many gsoc slots we got this year?
09:35:12 <danr> @type .:
09:35:13 <lambdabot> parse error on input `.:'
09:35:17 <danr> @type (.:)
09:35:18 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
09:35:28 <edwardk> lispy: not yet
09:35:38 <edwardk> lispy: guessing it'll be 7-8
09:35:48 <lispy> edwardk: heh, okay that was my guess when someone asked me :)
09:35:53 <edwardk> but i marked a few more for acceptance just in case
09:35:53 <zhulikas> and how many proposals there are?
09:36:11 * lispy is not getting the melange notices at the moment
09:36:16 <danr> > fix $ ([1,1] ++) .: zipWith (+) <*> tail
09:36:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:36:22 <danr> there we go
09:36:29 <lispy> danr: nice
09:36:35 <edwardk> zhulikas: We had 26 proposals this year
09:36:50 <danr> lispy: I like how we can use the S-combinator there
09:37:04 <lispy> danr: is that what you call .: ?
09:37:14 <lispy> :t zipWith (+) <*> tail
09:37:15 <lambdabot> forall a. (Num a) => [a] -> [a]
09:37:18 <danr> lispy: no, <*> for the reader applicative is S
09:37:39 <edwardk> Now, admittedly we probably had ~3 projects that received somewhere between 2 and 5 applications to do the same thing, so it whittles the field somewhat
09:37:45 <notthemessiah> lispy: quicksilver: thanks
09:37:48 <danr> I have no good name for .:, but (.) . (.) gives some associations
09:38:19 <mm_freak> is the FFI the only way to get assembly code into a haskell program?
09:38:42 <hpc> mm_freak: probably
09:38:47 <edwardk> mm_freak: You can use ffi to something like libffi if you need a more general interface
09:39:03 <lispy> edwardk: I can't see the proposals. I can only see the haskell.org org proposal
09:39:40 <lispy> mm_freak: and harpy
09:39:43 <edwardk> lispy: sign up as a mentor =P
09:39:52 <lispy> edwardk: I thought I was...
09:39:56 <mm_freak> i rather thought about creating thunks directly to gain some speed…  is that possible?
09:40:01 <edwardk> lispy: you're an org admin, not a mentor presently
09:40:11 <edwardk> thats why you can't see anything
09:40:17 <edwardk> apply to haskell.org and i'll approve you
09:40:37 <lispy> okay, trying to do that...UI fail on my part
09:40:45 <edwardk> Like all things melange its a little strange
09:42:09 <lispy> Okay, I'm confused
09:42:17 <lispy> Do I do it from my dashboard?
09:42:36 <edwardk> not sure
09:43:33 <mcstar> no wonder space is soo huge, haskell leaks space all the time
09:44:13 <merijn> What does FlexibleInstances do?
09:44:47 <edwardk> merijn: norally an instance is only allowed to have the form MyClass (Foo a b c) where a b and c are all distinct variables
09:44:53 <hpc> merijn: it makes the instances out of rubber instead of plastic ;)
09:44:58 <edwardk> merijn: FlexibleInstances lets you break this rule
09:45:15 <hpc> it lets you "dig deeper" with type variables
09:45:17 <lispy> edwardk: okay, you go to the "HOME" link and then on there is some text about applying. No where else in the UI seems to have the application link :(
09:45:18 <edwardk> merijn: instance Foo a a;  instance Bar [Char] etc all require FlexibleInstances
09:45:22 <hpaste> merijn pasted “FlexibleInstances?” at http://hpaste.org/66867
09:45:39 <lispy> edwardk: sent
09:45:39 <edwardk> I'll email carol
09:45:44 <edwardk> oh, even better
09:45:59 <edwardk> approved
09:46:15 <edwardk> fortunately you missed most of the spam ;)
09:46:30 <lispy> I'm on the mailing list; I just ignore it
09:46:30 <merijn> Which part of my paste breaks stuff? I don't think I understand the more advanced typeclass stuff enough to understand what/why I'm doing stuff
09:46:32 * EnglishGent has long since lost track of all the extensions to Haskell & the relationships between them :(
09:46:53 <rwbarton> i guess the fact that m is a variable rather than a type constructor? weird that MultiParamTypeClasses doesn't imply FlexibleInstances
09:47:00 <edwardk> merijn: Almost any use of MPTCs need FlexibleInstances
09:47:06 <merijn> Ah
09:47:19 <edwardk> You'd need to have constructors on both arguments to the typeclass to avoid it
09:47:24 <edwardk> its usually not worth dodging
09:47:32 <edwardk> its not a hard extension to implement
09:47:44 <EnglishGent> indeed <contraversial>the fact that there are so many extensions, which have to be added to the compiler, instead of being done in the code using the extensions suggests (to me) there's something wrong with the very foundations of the language (a lack of macros?)</contraversial>
09:47:51 <edwardk> so other than the typing haskell in haskell writeup i'm not aware of an MPTC implementation that doesn't do flexible instances
09:47:58 <EnglishGent> btw - I think it's a *beautiful* language :)
09:48:17 <EnglishGent> but ... the ever expanding list of extensions is difficult to ignore... :|
09:48:31 <benmachine> EnglishGent: it's kind of a research language
09:48:34 <edwardk> rwbarton: correct. to be a classical instance, it'd need a constructor on m
09:48:41 <lispy> benmachine: yeah, that
09:48:43 <benmachine> so it's not altogether that surprising that a lot of people extend it
09:48:48 <hpaste> merijn annotated “FlexibleInstances?” with “FlexibleInstances? (annotation)” at http://hpaste.org/66867#a66868
09:48:52 <EnglishGent> hi benmachine, lispy :)
09:48:59 * benmachine waves
09:49:01 <merijn> Right, changed it to this + FlexibleInstances and now it seems to work
09:49:33 <benmachine> I think the behaviour of MPTCs without FlexibleInstances is buggy
09:49:43 <benmachine> I can't remember whether I actually got around to submitting a bug on it
09:49:48 <rwbarton> i will just say what i said the last time this subject came up, if you can come up with an extension mechanism that allows you to add things like MPTCs and GADTs, more power to you, macros are not the answer though
09:49:49 <benmachine> (if nothing else, the error message needs to be better)
09:50:03 <hpc> MPTCs should imply FlexibleInstances, ideally
09:50:21 <hpc> since the two are used together so often, and you don't really lose anything by enabling both instead of just one
09:50:57 <edwardk> hpc: like i said, the only implementation i know of that has one but not the other is THIH
09:51:14 <benmachine> edwardk: I wonder what sorts of MPTC instances it allows
09:51:19 <edwardk> hpc: it does require a fair bit of restructuring to handle though
09:51:21 <benmachine> I bet it allows some that GHC doesn't by default
09:51:23 <matthiasgorgens1> Does somebody have an example of using Network.Curl?
09:51:33 <edwardk> benmachine: nah, they'd have to follow the classic rules
09:51:42 <edwardk> benmachine: as a result they are kinda boring =)
09:52:27 <benmachine> edwardk: sure, but GHC MPTC instances without flexibility seem really super boring
09:52:42 <benmachine> to the point where I wonder if it's intentional how boring they are
09:53:22 <benmachine> edwardk: or maybe that's the right amount of boring, and the problem is just the GHC's error messages suggest more is allowed
09:53:25 <benmachine> than is
09:53:42 <benmachine> well, the error message doesn't explicitly refer to MPTCs at all, but the reasonable assumption doesn't hold
09:53:50 <lispy> edwardk: thanks, I'm in!
09:54:34 <lispy> edwardk: I won't have any time to rank anything probably until Saturday
09:54:42 <edwardk> lispy: no problem
09:54:45 <lispy> But, I'll do my best to sort through some apps
09:54:52 <edwardk> we've received pretty good feedback so far
09:54:59 <lispy> Great
09:55:01 <edwardk> so the rankings won't change much from any one person from here out
09:55:05 <edwardk> but the commentary is useful
09:55:10 <lispy> gotcha
09:55:11 * hackagebot colada 0.4.1 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.4.1 (GrzegorzChrupala)
09:56:50 <Cale> https://bugs.php.net/bug.php?id=54547 -- ROFL
09:57:04 <Cale> What is it with PHP and terribly stupid comparison bugs?
09:57:25 <elliott> I really don't think that one is stupid if you accept what PHP's == does
09:57:41 <lispy> Cale: javascript has the same bug
09:57:42 <elliott> It's not string equality, it's "thing equality", i.e. "01" == "1" etc.
09:57:46 <elliott> === is string equality.
09:57:51 <c_wraith> edwardk: I'm looking at your keys package right now. I could really use a sentence about the intended semantics of index. In particular.. What if the key isn't found?
09:57:56 <elliott> Since the two numbers there are equal due to floating-point, they compare as equal with ==
09:57:57 <matthiasgorgens1> lispy: javascript's bug is slightly less egregious.
09:58:00 <lispy> Cale: It's due to weak typing
09:58:14 <Cale> I understand that it does conversions when the types of things are different, but it seems to also be converting things to numbers even when both are strings.
09:58:22 <ben> > 9223372036854775807 == 9223372036854775808.0
09:58:23 <lambdabot>   True
09:58:23 <bitonic> Cale: of course
09:58:28 <lispy> Well, maybe not weak typing exactly. But treating floats as integers is problematic
09:58:32 <elliott> Cale: You know how Perl just has scalars, and they're both numbers and strings?
09:58:46 <c_wraith> Cale: the general rule for php is "== causes bugs. pretend it doesn't exist" :)
09:58:48 <Cale> elliott: yeah, though I'm not required to agree with that :)
09:58:51 <elliott> Cale: It's not that PHP automatically converts between the two when necessary using ==. It *doesn't distinguish* between the two when using ==.
09:58:51 <bitonic> Cale: in javascript you can also do "12" + 34. And you can do "12" - 34. Guess what each does
09:59:02 <elliott> Cale: I agree it's stupid behaviour, but if you accept that behaviour, that "bug" isn't really a bug.
09:59:08 <benmachine> c_wraith: that sounds silly. might as well s/==/PHP/ in that case >_>
09:59:12 <lispy> ben: yeah, (==) on floats is insane
09:59:25 <Cale> elliott: Right, I understand what's going on here, but it's still ridiculous :)
09:59:26 <lispy> (sadly)
09:59:35 <elliott> Cale: It is that :)
09:59:41 <c_wraith> benmachine: well, yes, that's my preferred approach :)
09:59:44 <ben> does php come with a repl?
09:59:50 <parcs`> yeah, php -a
09:59:52 <elliott> Cale: I feel sorry for the poor PHP devs who have to deal with people heckling them on their bug tracker.
10:00:00 <luite> Cale: well I got a division by zero exception for a numeric literal in ghci :)
10:00:02 <ben> cheers
10:00:05 <elliott> Not enough to forgive them for PHP though
10:00:20 <ben> ... you still need to wrap stuff in <?php ?>?
10:00:30 <lispy> Since when does #haskell defend bad semantics of php ;)
10:00:35 <parcs`> no, but you need semicolons
10:00:38 <hpc> lispy: since it isn't haskell
10:00:45 <lispy> (or more to the point, let's get back on topic :)
10:00:50 <Cale> luite: hah, that's interesting
10:01:05 <ben> I typed php -a, it said interactive mode enabled, then echo "9223372036854775807" === "9223372036854775808"; and it printed echo "9223372036854775807" === "9223372036854775808";
10:01:22 <benmachine> ben: try using <?php ?>
10:01:28 <ben> then it didn't print anything
10:01:30 <ben> oh well
10:01:33 <luite> Cale: actually in the GHC STABLE snapshot that I Was running yesterday, 2.55 = division by zero, 2.54 = infinite loop (gets stuck in some gcd algorithm)
10:01:58 <Cale> luite: oh, in an unreleased version?
10:01:59 <mysticc> what does this means {-# UNPACK #-}
10:02:11 <edwardk> Clearly the answer is they need to introduce ====
10:02:13 <parcs`> ben: you'll probably want var_dump("9223372036854775807" === "9223372036854775808");
10:02:27 <Cale> mysticc: Normally fields of constructors are pointers to data
10:02:28 <c_wraith> mysticc: it means "store the value right here, instead of as an indirection to another location"
10:02:49 <luite> Cale: yeah, it's a bit tricky to reproduce, but and I think it's platform dependent, but it looks like there are some problems with libgmp on OS X
10:02:50 <benmachine> for the record, perl has ("9223372036854775807" == "9223372036854775808") but ("9223372036854775807" ne "9223372036854775808")
10:02:54 <Cale> Well, actually pointers to code which returns data (possibly immediately) when jumped into
10:03:04 <mysticc> Cale: Is this similar to unboxed things
10:03:07 <Cale> yes
10:03:14 <elliott> it's exactly unboxing
10:03:16 <Cale> It unboxes the field into the constructor record
10:03:32 <copumpkin> @let x ==== y = (reads x :: [(Double, String)]) == reads y || (reads x :: [(Int, String)]) == reads y || (reads x :: [(Bool, String)]) == reads y || x == y
10:03:33 <lambdabot>  Defined.
10:03:35 <edwardk> benmachine: i guess the issue here is that strcmp is scary ;)
10:03:46 <copumpkin> > "0xff" == "255
10:03:47 <lambdabot>   <no location info>:
10:03:47 <lambdabot>      lexical error in string/character literal at end o...
10:03:52 <copumpkin> > "0xff" ==== "255"
10:03:53 <lambdabot>   True
10:03:55 <edwardk> :t (====)
10:03:56 <lambdabot> String -> String -> Bool
10:04:05 <parcs`> @slap copumpkin
10:04:05 * lambdabot pushes copumpkin from his chair
10:04:08 <parcs`> :P
10:04:22 <benmachine> edwardk: using strcmp seems to be the sensible solution, but I bet most people don't
10:04:26 <edwardk> lambdabot has a good idea. he's just a few feet from me
10:04:39 <elliott> copumpkin: that's amazing
10:04:48 <copumpkin> elliott: it clearly needs to be an MPTC
10:05:02 <copumpkin> and I need to throw some fromEnum in there too
10:05:10 <copumpkin> so "False" == 0
10:05:12 * hackagebot splice 0.5 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.5 (CetinSert)
10:05:14 * hackagebot splice 0.5.1 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.5.1 (CetinSert)
10:05:22 <elliott> reallyUnsafePtrEquality# (unsafeCoerce# x) (unsafeCoerce# y)
10:05:29 <edwardk> meh, clearly a ==== b = show a == show b
10:05:48 <benmachine> elliott: huh? isn't reallyUnsafePtrEquality# polymorphic anyways?
10:05:52 <elliott> oh, is it?
10:05:54 <EnglishGent> hi copumpkin!
10:05:56 <EnglishGent> ltns!
10:05:58 <copumpkin> hey EnglishGent :)
10:05:59 <EnglishGent> :)
10:06:15 <Cale> reallyUnsafePtrEquality# :: a -> a -> Int#
10:06:21 <benmachine> oh right
10:06:25 <benmachine> so you'd need one of the unsafeCoerces
10:06:29 <Cale> It could be more unsafe!
10:06:34 <merijn> I can use "(->) r" to mean "r ->" in a typeclass/signature, how do I make "a -> r ->" given "(->) r"?
10:06:35 <benmachine> except it would probably just return false anyway
10:06:38 <Cale> reallyReallyUnsafePtrEquality# :: a -> b -> Int#
10:06:40 <edwardk> reallyReallyUnsafePtrEquality
10:06:43 <edwardk> yeah
10:06:46 <thoughtpolice> ugh, i hate it when a segfault lands somewhere in haskell-land
10:06:55 <benmachine> Cale: surely it is at worst non-RT
10:06:59 <Cale> Or maybe even unsafeCoerce the result too
10:07:02 <benmachine> sounds much less upsetting than unsafeCoerce
10:07:04 <Cale> reallyReallyReallyUnsafePtrEquality# :: a -> b -> c
10:07:09 <benmachine> hah
10:07:19 <parcs`> merijn: Compose (a ->) (r ->) ?
10:07:31 <copumpkin> Cale: sounds good to me
10:07:36 <merijn> parcs`: Where is Compose defined?
10:08:01 <merijn> :k Compose
10:08:02 <lambdabot>     Not in scope: type constructor or class `Compose'
10:08:02 <edwardk> merijn: transformers
10:08:05 <parcs`> not sure.. it's newtype Compose f g a = Compose (f (g a))
10:08:10 <copumpkin> :.: is a nicer name for it
10:08:11 <hpc> newtype Compose f g x = In {out :: f (g x)}
10:08:15 <benmachine> merijn: possibly more than one place but transformers has Data.Functor.Compose
10:08:15 <hpc> or :.:
10:08:17 <hpc> or :.
10:08:20 <edwardk> copumpkin: sadly that requires an extension
10:08:28 <edwardk> copumpkin: since TypeOperators aren't standard
10:08:30 <copumpkin> yeah, I use GHC, not Haskell :D
10:08:41 <elliott> :.: looks like a smiley
10:08:42 <dolio> Obviously the right name is O
10:08:47 <elliott> all you need is that + vector-space
10:08:53 <copumpkin> dolio: ugh
10:08:54 <tsou> > let x = 9223372036854775807.0 in and [x == x + i | i <- [0..1024]]
10:08:54 <lambdabot>   True
10:08:55 <copumpkin> I hate that
10:09:00 <edwardk> I used to have a class for composition in category-extras
10:09:06 <elliott> (x :: A :.: B) ^+^ (y :: C :.: D)
10:09:19 <benmachine> edwardk: is it fair to say there's essentially no controversy in TypeOperators?
10:09:28 <tsou> can someone explain to me why this holds? :|
10:09:31 <elliott> it has the baseline controversy of any extension
10:09:41 <edwardk> that way you can have class Compose o where compose :: f (g a) -> (f `o` g) a; decompose :: (f `o` g) a -> f (g a)
10:09:49 <benmachine> tsou: because of floating-point
10:09:50 <tsou> (sorry i'm still in the previous conversation about the php "bug")
10:09:53 <benmachine> tsou: if it helps:
10:09:55 <elliott> tsou: floating point
10:10:02 <elliott> 9223372036854775807 is just too big :)
10:10:03 <merijn> Hmm, I'm not sure whether I even want Compose...
10:10:09 <edwardk> benmachine: little controversy, but not universal support =(
10:10:09 <benmachine> > let x :: Rational; x = 9223372036854775807.0 in and [x == x + i | i <- [0..1024]]
10:10:10 <lambdabot>   False
10:10:14 <merijn> Lemme pastebin my problem
10:10:23 <benmachine> edwardk: surely not hard to implement, though?
10:10:28 <edwardk> elliott here has been steadily porting my packages to hugs ;)
10:10:38 <benmachine> hah
10:10:39 <tsou> yeap, i just don't get why 1024 is the magic number to "break" it
10:10:42 <benmachine> I thought hugs was dead :P
10:10:45 <elliott> it is!
10:10:48 <tsou> it's not? :P
10:10:55 <hpc> tsou: because of epsilon stuff
10:11:04 <hpc> > let x :: Rational; x = 9223372036854775807.0 in and [x == x + i | i <- [0..1023]]
10:11:05 <lambdabot>   False
10:11:15 <hpc> > let x :: Rational; x = 9223372036854775807.0 in and [x == x + i | i <- [0..255]]
10:11:16 <lambdabot>   False
10:11:19 <hpc> > let x :: Rational; x = 9223372036854775807.0 in and [x == x + i | i <- [0..1]]
10:11:20 <lambdabot>   False
10:11:26 <hpc> oh, Rational
10:11:29 <hpc> you sneaky bastard
10:11:29 <benmachine> hpc: hint: Rationals are exact :P
10:11:36 <benmachine> that's not sneaky!
10:11:40 <benmachine> that's totally allowed
10:11:42 <benmachine> I allowed it
10:12:07 <hpc> benmachine: it's sneaky when i ignore it because i expected "make x a float" boilerplate
10:12:20 <benmachine> > let x = 9223372036854775807.0 in x == x + 1024
10:12:20 <lambdabot>   True
10:12:22 <benmachine> > let x = 9223372036854775807.0 in x == x + 1025
10:12:23 <lambdabot>   False
10:12:26 <tsou> so, why x == x + 1024, but not to x + 1025?  (that was the question)
10:12:28 <benmachine> hpc: heh
10:12:36 <elliott> tsou: because floating point(TM)
10:12:47 <hpc> tsou: x = some number * 10 ^ something
10:12:54 <tsou> elliott: heh, :)
10:12:55 <benmachine> hpc: uh, 2^something
10:12:57 <luite> 2^ actually
10:12:58 <luite> right
10:13:03 <hpc> whatever
10:13:15 <benmachine> hpc: well, it's relevant on account of how 1024 is a power of two
10:13:18 <hpc> and that (some number)... fuck it, because floating point(TM)
10:13:19 <Cale> 2^63
10:13:21 <edwardk> tsou: its the precision of the mantissa at that scale
10:13:24 <Cale> > 2^63
10:13:25 <lambdabot>   9223372036854775808
10:13:30 <hpc> benmachine: how do you know it wasn't 10 base 2?
10:13:31 <Cale> > 2^63 - 1
10:13:32 <lambdabot>   9223372036854775807
10:13:40 <Cale> > (2^63 - 1) :: Double
10:13:41 <lambdabot>   9.223372036854776e18
10:13:42 <benmachine> hpc: I'm just that incisive
10:13:43 <hpc> tsou: read the IEEE float spec sometime
10:13:46 <Cale> > (2^63) :: Double
10:13:47 <lambdabot>   9.223372036854776e18
10:13:55 <edwardk> you get 53 bits of mantissa (including the leading 1) out of a double
10:13:55 <hpc> it might explain
10:14:02 <edwardk> 63-53 = 10 bits = 1024
10:14:16 <Cale> > 2^63 - (2^63 - 1) :: Double
10:14:17 <lambdabot>   0.0
10:14:21 <tsou> aha!
10:14:24 <Cale> > (2^63 - 2^63) - 1 :: Double
10:14:25 <lambdabot>   -1.0
10:14:37 <tsou> i'll go with "because edwardk (TM)" :P
10:14:37 <Cale> > (2^63 - 2^63) + 1 :: Double
10:14:38 <lambdabot>   1.0
10:14:44 <edwardk> tsou: fair nuff
10:14:48 <benmachine> Cale: subtraction isn't associative?!? :O
10:14:56 <benmachine> (jk)
10:14:57 <Cale> Subtraction isn't associative normally :)
10:14:57 <edwardk> benmachine: nope
10:15:06 <Cale> But addition isn't associative either here :)
10:15:11 <edwardk> benmachine: but you don't even have assoiative addition here
10:15:14 <copumpkin> at least it's commutative
10:15:16 <Cale> > 2^63 + (-2^63) + 1 :: Double
10:15:16 <benmachine> yes yes I got that
10:15:17 <lambdabot>   1.0
10:15:23 <Cale> > 2^63 + ((-2^63) + 1) :: Double
10:15:24 <lambdabot>   0.0
10:15:26 <tsou> edwardk: no, i meant that what you said makes sense.. thanks ;)
10:15:29 <hpaste> merijn pasted “Type hackery” at http://hpaste.org/66869
10:15:40 <mdmkolbe> "uncurry" lets me convert "a -> b -> c -> d" to "(a, b) -> c -> d", is there a short incantation for converting it to "a -> (b, c) -> d"?  (I can write a helper function to do it, but I'm curious if there is a more elegant way.)
10:15:41 <edwardk> copumpkin: not if you take into account the individual signals carried by the NaNs ;)
10:15:55 <merijn> Ok, so that is sorta what I want to implement. But the problem with the second (wishful thinking) instances is that the a appears out of nowhere...
10:16:04 <benmachine> :t (uncurry .)
10:16:05 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f ((a, b) -> c)
10:16:16 <Cale> mdmkolbe: flip?
10:16:24 <Cale> hmm
10:16:31 <benmachine> Cale: that would curry the wrong things
10:16:39 <benmachine> (uncurry .) will do fine
10:16:41 <c_wraith> :t (uncurry Prelude.)
10:16:41 <lambdabot> Not in scope: data constructor `Prelude'
10:16:46 <c_wraith> :t (uncurry Prelude..)
10:16:47 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> a1 -> (a, b) -> c
10:16:47 <Cale> oh, right
10:16:55 <mdmkolbe> Cale, is right, "flip . uncurry. flip"
10:17:08 <Cale> no, that doesn't do what you wanty
10:17:10 <Cale> want*
10:17:14 <benmachine> :t flip . uncurry . flip
10:17:15 <lambdabot> forall a b a1 b1. (b1 -> a1 -> a -> b) -> a -> (a1, b1) -> b
10:17:21 <merijn> Any clues how to unbreak my examples? (For example, can I write "class Hack ((->) a) where" to have one argument while still binding a, or is there some other fancy trick?
10:17:30 <mdmkolbe> sorry, I spoke to soon, yeah, it doesn't do what I want
10:17:42 <benmachine> mdmkolbe: (uncurry .) I think will do it
10:17:52 <Cale> merijn: I'm not sure I understand what you're trying to do there.
10:17:57 <benmachine> mdmkolbe: some people like to do 'result = (.)' and then 'result uncurry'
10:18:08 <Cale> > fmap uncurry
10:18:09 <lambdabot>   Overlapping instances for GHC.Show.Show
10:18:09 <lambdabot>                              (f (a ...
10:18:13 <Cale> :t fmap uncurry
10:18:14 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f ((a, b) -> c)
10:18:51 <Cale> :t fmap uncurry :: (e -> a -> b -> c) -> (e -> (a,b) -> c)
10:18:52 <lambdabot> forall e a b c. (e -> a -> b -> c) -> e -> (a, b) -> c
10:19:04 <benmachine> man, I came in here because I couldn't remember how to heap profile, now I'm talking to people about uncurrying
10:19:07 * benmachine is not focussed
10:19:11 <merijn> Cale: I'm not sure how to translate the compose of the fictious second example to the actual "not a type error" first example
10:19:12 * benmachine goes back to reading the manual
10:19:16 <dmwit> What's wrong with \f a b c -> f a (b,c)?
10:19:24 <Cale> dmwit: nothing :)
10:19:29 * EnglishGent hands benmachine a cup of strong coffee (focus)
10:19:30 <EnglishGent> :)
10:19:30 <mcstar> nice, i spead up my program 1000x
10:19:56 <merijn> Cale: i.e. if (r ->) is an instance of hack than I want to make "(b -> r ->)" an instance too
10:20:29 <mcstar> (ofc, i paid a high price: now it isnt working correctly)
10:20:35 <Cale> mcstar: lol
10:21:43 <mdmkolbe> thanks benmachine and Cale.  Those both work quite nicely.
10:22:11 <Cale> merijn: hmm
10:23:05 <Cale> merijn: It's hard to know what you mean with the question marks everywhere
10:24:05 <merijn> The question marks are there because the a (from the top class definition) is not in scope when I define it as just "Hack f" rather than "Hack f a", but if I define "Hack f a" then I can't compose as easily
10:24:20 <merijn> Although I guess I could do "Compose ((->) b) (f a)"?
10:24:49 <Cale> It might help to take a step back and look at the context where this is showing up
10:25:47 <merijn> Cale: Anyway, I just noticed it's past 19:00 so I need to head home, but I'll be on to discuss it when I get there. (If you come up with something in the mean time, feel free to msg me using lambdabot :>)
10:26:01 <Cale> Also, if you have to define things for the Compose newtype, you're unlikely to be all that happy with the resulting usage.
10:26:31 <Cale> (because you'll have to write lots of wrapping and unwrapping, which probably defeats the purpose of having a lifting instance in the first place)
10:26:56 <edwardk> One benefit of using Compose is that you get a lot of instances
10:27:50 <edwardk> transformers provides some, almost every one of my category-extras breakout packages has some instances for Compose, keys, etc.
10:29:00 <JoeyA> What calls GHC.Conc.ensureIOManagerIsRunning ?  Is this called once by the RTS at the beginning of the program?  Is it (supposed to be) safe to call again from other threads?
10:30:24 <teneen> Why does the following not work?
10:30:26 <teneen> @let itM f x = f x >>= \x' -> itM f x' >>= \xs -> return (x':xs)
10:30:27 <lambdabot>  <local>:6:0:
10:30:27 <lambdabot>      Warning: Pattern match(es) are overlapped
10:30:27 <lambdabot>               In...
10:30:48 <teneen> > head $ itM (\x -> [x,x+1]) 1
10:30:51 <lambdabot>   *Exception: stack overflow
10:31:40 <hpc> teneen: you build up a stack of (>>= \xs -> return (stuff : xs))
10:32:13 <teneen> hpc: it should only evaluate the first element?
10:32:22 <teneen> hpc: I don't see why it's not lazy?
10:32:45 <hpc> teneen: no, because side effects happen too
10:33:07 <hpc> and the side effects for [] don't work with that kind of function
10:33:26 <hpc> teneen: imagine if you did IO with itM
10:33:48 <hpc> teneen: you would be doing the same IO forever and never get to that last return
10:34:06 <teneen> yes but lazy IO should work!
10:34:14 <dmwit> teneen: You have to pick an "xs" before you can get to "return (x':xs)", but "xs" depends on "itM".
10:34:38 <mm_freak> teneen: lazy IO is a hack and you have to trigger it explicitly using unsafeInterleaveIO
10:34:41 <dmwit> So you don't get to the part where you return something before calling yourself recursively -> infinite loop.
10:34:52 <teneen> dmwit: Why doesn't it treat xs as a thunk?
10:35:09 <hpc> teneen: it does; (>>=) isn't function application
10:35:13 <hpc> it does other things
10:35:33 <mm_freak> btw, otherwise i don't see why itM wouldn't work…  it's looks like a reasonable iterateM
10:35:35 <hpc> teneen: run this in ghci:
10:35:40 <hpc> let itM = ...
10:35:43 <mm_freak> but it will space-overflow
10:35:53 <hpc> let action str = do {putStrLn str; return str}
10:36:00 <hpc> itM action "hello"
10:36:05 <dmwit> teneen: xs would be a thunk, if it was ever bound to anything.
10:36:15 <hpc> it will keep printing hello over and over and over and over...
10:36:25 <mm_freak> don't run that
10:36:37 <mm_freak> if you don't abort that in time, it will probably crash your computer
10:36:45 <hpc> also that
10:36:50 <magicman_> Details <_<
10:36:54 <teneen> hpc: Yes I did try that, and I actually expected this
10:37:02 <hpc> you can't get to x' because (>>=) has to do the side effects first
10:37:26 <mm_freak> x' is reached and passed to the second invocation of 'f'
10:37:33 <mm_freak> but itM itself will never give a result
10:37:47 <hpc> er yeah, you'll never get to that last return
10:37:48 <teneen> hpc: What side-effects does (>>=) for lists do?
10:37:49 <hpc> is what i meant
10:37:56 <rwbarton> teneen: it has no way to know that e.g. f 5 is not []
10:38:04 <hpc> teneen: the side effects for lists is "try all combinations"
10:38:18 <rwbarton> so it can never know that it should start producing a result
10:38:40 <hpc> > itM (const []) 1
10:38:42 <lambdabot>   []
10:38:51 <mm_freak> teneen: the nature of the side effect doesn't really matter…  unless the monad supports short-circuiting the result depends on the recursive call
10:39:06 <mm_freak> that's a dependency that will never be satisfied
10:39:07 <hpc> > itM (const Nothing) 1
10:39:09 <lambdabot>   Nothing
10:39:32 <hpc> > itM (ContT $ \_ -> ["yes"]) 1
10:39:32 <lambdabot>   Couldn't match expected type `a -> m a'
10:39:33 <lambdabot>         against inferred type `Cont...
10:39:40 <rwbarton> it should work in the Identity monad
10:39:42 <hpc> :t ContT
10:39:43 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
10:40:00 <hpc> > itM (ContT $ \_ -> Identity "yes") 1
10:40:01 <lambdabot>   Couldn't match expected type `a -> m a'
10:40:01 <lambdabot>         against inferred type `Cont...
10:40:07 <mm_freak> > itM (const $ ContT (const ()) ()
10:40:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:40:12 <hpc> oh yes, that
10:40:15 <mm_freak> > itM (const $ ContT (const ())) ()
10:40:16 <lambdabot>   Couldn't match expected type `m r' against inferred type `()'
10:40:23 <mm_freak> …
10:40:33 <mm_freak> > itM (const $ ContT (const $ return ())) ()
10:40:35 <lambdabot>   No instance for (GHC.Show.Show
10:40:35 <lambdabot>                     (Control.Monad.Trans.Con...
10:40:38 <mm_freak> there we go
10:40:43 <rwbarton> > itM (\x -> x + d) 0 3
10:40:44 <lambdabot>   Couldn't match expected type `m SimpleReflect.Expr'
10:40:44 <lambdabot>         against inferre...
10:40:53 <mm_freak> > runContT (itM (const $ ContT (const $ return ())) ()) return
10:40:54 <lambdabot>   Couldn't match expected type `[()]' against inferred type `()'
10:40:56 <hpc> > itM (const $ contT (const "yes")) "oogle boogle"
10:40:57 <lambdabot>   Not in scope: `contT'
10:40:59 <rwbarton> > itM (\x -> \d -> x + d) 0 3
10:41:01 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
10:41:02 <hpc> > itM (const $ ContT (const "yes")) "oogle boogle"
10:41:03 <lambdabot>   No instance for (GHC.Show.Show
10:41:03 <lambdabot>                     (Control.Monad.Trans.Con...
10:41:10 <ClaudiusMaximus> can i mark up nested lists in Haddock?  what's the correct syntax to do that if it's possible?
10:41:12 <benmachine> is this really helping :P
10:45:49 <teneen> dmwit, hpc: After translating it to concatMap it's kind of clear for me why it should terminate!
10:46:01 <teneen> shouldn't :D
10:47:46 <teneen> btw this was one of two implementations I came across on this SO question: http://stackoverflow.com/questions/7630798/whats-wrong-with-my-attempted-implementation-of-iteratem
10:51:40 <hpaste> killy9999 pasted “Prelude.read: no parse” at http://hpaste.org/66872
10:52:11 <killy9999> any suggestion why can I write a file, but get an error when reading it?
10:53:51 <killy9999> wow, it's quiet in here today...
10:54:49 <elliott> killy9999: are your instances for Task derived?
10:55:26 <hpaste> killy9999 annotated “Prelude.read: no parse” with “Prelude.read: no parse (annotation)” at http://hpaste.org/66872#a66873
10:55:30 <killy9999> yes
10:56:09 <elliott> shrug, hpaste the saved file that doesn't load
10:56:26 <DevHC_> oh, cockfucking shitfucks
10:56:28 <DevHC_> internal error: stg_ap_ppp_ret
10:56:28 <DevHC_>     (GHC version 7.0.4 for i386_unknown_freebsd)
10:56:32 <DevHC_> has this been fixed?
10:56:44 <elliott> DevHC_: That's a rather vague explanation of your problem.
10:56:47 <elliott> Are you using any unsafe features?
10:56:51 <elliott> If not, report a GHC bug.
10:56:53 <DevHC_> not really
10:56:56 <elliott> Not really?
10:56:57 <sclv> I'd bet it has been fixed
10:56:58 <DevHC_> FFI
10:56:59 <elliott> That sounds like yes :)
10:57:04 <elliott> Yes, you can do things like that with the FFI.
10:57:11 <elliott> It's probably a bug in your code.
10:57:15 <killy9999> hm...
10:57:27 <killy9999> elliott: I skipped the imports
10:57:28 <DevHC_> unfortunately ghc 7.2+ish segfaults even more
10:57:40 <elliott> killy9999: ?
10:57:42 <sclv> same sorts of errors or different ones?
10:57:45 <killy9999> so it won't load most likely...
10:57:52 <DevHC_> segfault.
10:57:54 <elliott> killy9999: I don't understand.
10:57:57 <DevHC_> not internal error, segfault
10:58:13 <singpolyma> under GHC, if a call into C code blocks in the C code, that blocks the whole RTS even when -threaded, yes?
10:58:20 <sclv> segfaults are likely your problem.
10:58:23 <elliott> singpolyma: No.
10:58:27 <sclv> internal errors are usually ghc's
10:58:29 <elliott> singpolyma: Not if you import it as "safe" (the default).
10:58:32 <elliott> If you import it as "unsafe" then yes
10:58:39 <DevHC_> 7.0.3ish works perfectly
10:58:45 <elliott> but otherwise it'll just block the current OS thread.
10:58:45 <killy9999> oh, sorry, I meant you mean that my files from hpaste don't load
10:59:01 <elliott> DevHC_: That just means your code doesn't show its bugs on 7.0.3.
10:59:08 <DevHC_> ORLY
10:59:14 <singpolyma> elliott: oh, interesting, ok
10:59:18 <sclv> if the code you are importing has certain quirks w/r/t how it expects you to interact with it.
10:59:40 <sclv> it could be that the 7.0.3 runtime happened to call it "correctly"
10:59:51 <DevHC_> doubtfully
10:59:57 <sclv> i've never had a ghc segfault that was the fault of thc
11:00:01 <sclv> er. ghc
11:00:08 <sclv> and i've had a zillion other errors
11:00:13 <sclv> and filed a zillion other reports.
11:00:13 <DevHC_> GHC+libraries has always been a clockfuck
11:00:29 <DevHC_> notably on 64-bit linux machines
11:00:31 <sclv> oh wait -- i did have one back in the day. in the 6.10 series there was a bug with threading and file handles.
11:00:48 <sclv> which led to a genuine runtime segfault.
11:01:17 <sclv> anyway you should try 7.4
11:01:31 <keep_learning> Hello all
11:02:02 <DevHC_> a few more notes:
11:02:07 <keep_learning> I have two unboxed vectors of type ( Int , Double )
11:02:15 <DevHC_> GHC is segfaulty on windows (XP)
11:02:15 <keep_learning> and I want to concatenate them
11:02:37 <keep_learning> but both of vectors can have some common element which I have to add and replace by single element
11:02:52 <DevHC_> i'm talking about the GHC which came pre-built with the latest haskell platform
11:03:43 <keep_learning> Lets say I have U.fromList  [ ( 1 , 1.0 ) , ( 2 , 1.0 )  ]  and U.fromList  [ ( 0 , 1.0 ) , ( 1 , 1.0 ) ]
11:03:45 <DevHC_> does GHC 7.4 finally support building libraries on 64-bit machines?
11:04:14 <keep_learning> after concatenating it should be  U.fromList  [ ( 0 , 1.0 ) , ( 1 , 2.0 ) , ( 2 , 1.0 ) ]
11:04:36 <keep_learning> Any idea how to do this
11:05:33 <lispy> keep_learning: good user name
11:05:38 <DevHC_> oh and: GHCs (pre-built 6.10.4ish, locally compiled GHC7.0.4, etc.) segfault at non-deterministic times on FreeBSD-CURRENT, for me, but not some other d00d i've talked to
11:05:52 <keep_learning> lispy, Thanks
11:06:16 <mekeor> well. keepLearning would be nicer, IMO :Þ
11:07:06 <keep_learning> mekeor, Yes keepLearning is more Haskellish then keep_learning
11:07:28 <lispy> keep_learning: So after concatenation you want Ints and Doubles? You don't want the Ints to become doubles?
11:07:29 <mekeor> yep
11:07:53 <keep_learning> lispy, No
11:07:57 <t7> keep_learning: map head . group . concat  ?
11:08:04 <keep_learning> I got an idea
11:08:33 <keep_learning> concatenate them , sort them and merge the equal elements
11:08:46 <mekeor> @src group
11:08:46 <lambdabot> group = groupBy (==)
11:08:50 <rwbarton> are the inputs guaranteed to be sorted?
11:08:55 <mekeor> @src groupBy
11:08:55 <lambdabot> groupBy _  []       =  []
11:08:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:08:55 <lambdabot>     where (ys,zs) = span (eq x) xs
11:09:49 <sclv> DevHC_: Sounds like you have bigger problems :-(. Could be freebsd related? I've always used linux and done fine, and only had problems on windows with sockety/IO things.
11:09:50 <t7> > let ronpaul2012 = map head . group . concat in ronpaul2012 [ ( 1 , 1.0 ) , ( 2 , 1.0 ) ] [ ( 0 , 1.0 ) , ( 1 , 1.0 ) ]
11:09:51 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
11:09:51 <keep_learning> rwbarton, Yes
11:09:52 <lispy> keep_learning: oh, I think what you want would be easy with Data.Map
11:10:24 <rwbarton> then you should do the normal merging sorted lists thing
11:10:43 <lispy> keep_learning: it has an insertWith (or was it unionWith) that should do this
11:11:22 <t7> > let ronpaul2012 = map head . group . (++) in ronpaul2012 [ ( 1 , 1.0 ) , ( 2 , 1.0 ) ] [ ( 0 , 1.0 ) , ( 1 , 1.0 ) ]
11:11:23 <lambdabot>   Couldn't match expected type `[a]' against inferred type `m -> m'
11:11:43 <kallisti> what comes next in this sequence:  foo, bar, baz, ...
11:11:48 <keep_learning> lispy rwbarton : Thank you both
11:11:49 <DevHC_> sclv: yes, it could be freebsd-related
11:12:28 <DevHC_> the non-deterministic GHC segfaults r coming from execution points in libthr
11:12:36 <DevHC_> something about a thread pointer being 0
11:12:53 <DevHC_> but that is not related to the internal errors i'm getting now
11:13:08 <hpaste> killy9999 annotated “Prelude.read: no parse” with “Prelude.read: no parse reproduced in GHCi” at http://hpaste.org/66872#a66875
11:13:20 <sclv> right. the errors you're getting now are clearly a ghc bug. i've seen similar ones.
11:13:32 <sclv> and saw them fixed when i upgraded ghc.
11:13:34 <dmwit> Is there a way to ask for just the actual parsing bit of a reads function? I want to read in a Haskell String that I happen to already know isn't prefixed by spaces, parentheses, etc. more quickly than reads does (since it checks for these things).
11:13:36 <killy9999> any ideas in my reading error?
11:14:25 <dmwit> killy9999: Perhaps you meant :: [Task]
11:14:55 <DevHC_> sclv: do u have a 64-bit linux machine to test some FFI code?
11:15:02 <DevHC_> -sclv
11:15:03 <sclv> not at the moment, sorry.
11:15:06 <dmwit> kallisti: quux
11:15:17 <killy9999> dmwit: right, that fixes the problem in GHCi
11:15:18 <DevHC_> does ANYONE have a 64-bit machine to test some code i have?
11:15:32 <killy9999> still I have the problem when working with files...
11:15:52 <lispy> DevHC_: can you use travis-ci?
11:15:54 <t7> DevHC_: paste away
11:16:01 <killy9999> DevHC, I have 64-bit linux
11:16:06 <DevHC_> Liskni_si: wuzzat?
11:16:20 <lispy> DevHC_: http://beta.travis-ci.com/
11:16:23 <DevHC_> killy9999: code incoming S00N(TM)
11:16:49 <lispy> DevHC_: it's continuous integration testing for open source code, but I bet you could use it to test your 64bit code
11:17:10 <dmwit> killy9999: Probably a stray newline or some such nonsense. You haven't been editing the file by hand, have you?
11:17:18 * lispy plans to add build slaves for all his github repos, RealSoonNow(tw)
11:17:21 <lispy> tm*
11:17:32 <killy9999> dmwit: no
11:17:40 <killy9999> I created the file by saving with my function
11:17:58 <killy9999> and then I try to read it using symmetric read function
11:18:08 <dmwit> (Is there a reason you didn't use readFile?)
11:18:43 <killy9999> dmwit: readFile returns a String, I need [Task] so I figured out I can use withFile
11:18:44 <iago> hi, does somebody know why GHC defines CInt as a wrapper over Int32 ? (a C int may have more than 32 bits)
11:18:46 <DevHC_> lispy: i'm not paying a dime, fuck that shit
11:18:59 <elliott> DevHC_: it's free.
11:19:02 <DevHC_> also, that crappy website requires javascript and has google analytics
11:19:09 <elliott> (I believe.)
11:19:13 <dmwit> kallisti: see also http://catb.org/jargon/html/M/metasyntactic-variable.html
11:19:17 <lispy> elliott: yes, it's free
11:19:23 <dmwit> killy9999: fmap read readFile
11:19:27 <DevHC_> "Why pay for a server to sit idle for 20 hours of the day when you can just run your tests on demand, paying for the time you use."
11:19:51 <elliott> DevHC_: you're being pretty hostile to someone who's just trying to help you, you know...
11:20:07 <DevHC_> not really
11:20:12 <elliott> yes really
11:20:17 <DevHC_> nope
11:20:17 <killy9999> dmwit: how to wrap that in a function?
11:20:18 <geekosaur> yes really
11:20:40 <dmwit> killy9999: loadTextFileDataBase databaseFile = fmap read (readFile databaseFile)
11:20:49 <DevHC_> what should i say? should i say that i will use that service, while not actually doing so in the background?
11:20:56 <dmwit> killy9999: or just loadTextFileDataBase = fmap read . readFile
11:21:13 <lispy> DevHC_: maybe I gave you the wrong link, look at this: http://travis-ci.org/
11:21:26 <lispy> DevHC_: You can sign in with a github account and set things up
11:21:31 <DevHC_> D:
11:21:59 <killy9999> dmwit: we have progress :)
11:22:02 <geekosaur> had you considered saying it in a less incendiary fashion?
11:22:09 <killy9999> gtd: todo.txt: openFile: resource busy (file is locked)
11:22:12 <elliott> DevHC_: No, but you could express your complaints in a less abrasive and assuming manner.
11:22:46 <DevHC_> u could also stop misinterpreting my comments as flaming
11:23:00 <DevHC_> lispy: can't be assed to get a github account now
11:23:05 <elliott> I didn't say you were flaming, but you are being pretty rude.
11:23:12 <DevHC_> orly
11:23:29 <DevHC_> u could also stop misinterpreting my comments as being rude
11:23:37 <lispy> Oh boy.
11:23:37 <dmwit> sooo much drama
11:23:38 <elliott> Sigh.
11:23:49 <killy9999> OK, so now's the problem: I'm trying to read the file, process the data that I got and write it again to the same file
11:24:03 <lispy> DevHC_: github is pretty slick. Once you get it setup, travis-ci is also pretty cool.
11:24:05 <elliott> dmwit: bit one-sided for drama
11:24:05 <killy9999> I get this: openFile: resource busy (file is locked)
11:24:11 <dmwit> killy9999: Windows?
11:24:15 <killy9999> nope
11:24:25 <lispy> killy9999: lWhat do you use to open the file?
11:24:28 <dmwit> Oh, writeFile.
11:24:29 <killy9999> I guess that it's because files are read lazy, right?
11:24:30 <Botje> killy9999: standard procedure is to write to a secondary file and rename it after the fact
11:24:42 <dmwit> Yeah, if you need to close the file, you need to open it manually, too. So, bummer, you can't use readFile and writeFile.
11:24:45 <dmwit> Sorry about that!
11:24:46 <Botje> that also stops a crashing process from eating your file
11:24:53 <mcstar> YAY i think i did it
11:24:57 <lispy> killy9999: haskell standard says to lock files. If you read in lazy then it's easy to try writing to it again while it's still open.
11:24:57 <geekosaur> DevHC, this may come as a surprise to you, bur your apparent accustomed form of language is not generally considered appropriate for public forums
11:25:17 <geekosaur> also, oddly enough, you are not the one who gets to define that
11:25:25 <killy9999> lispy: yeah, I figured out that's what's going on
11:25:43 <killy9999> ok, so now I'm going to fix that
11:25:45 <killy9999> somehow..
11:25:49 <dmwit> Is there a tool that will let me inspect the instance declaration for a given class/type pair?
11:25:58 <DevHC_> geekosaur: what can i say, i like expressive words
11:26:03 <dmwit> I'd like to take a look at String's Read instance (or Char's, not sure which is appropriate here).
11:26:13 <killy9999> but first I'm going to get something to eat
11:26:16 * killy9999 is away
11:26:38 <geekosaur> DevHC_, and of course everyone is obligated to humor you, since you desire it?
11:26:44 <elliott> DevHC_: It doesn't matter whether you like them; it matters whether the people you are talking with like them.
11:27:15 <BigEndian> the people with whom you are talking, far superior
11:27:46 <DevHC_> to me, it doesn't matter
11:28:00 <dmwit> geekosaur, elliott: Stop. You have the self-control to; he may not.
11:28:10 <DevHC_> i'm not going to switch word-selection styles because U don't like them
11:28:31 <dmwit> The GHC.Read link on Hackage is broken. =/
11:30:23 <mcstar> this is getting to bother me even more, i use a liftM_ now, and its faster, again, but the space leak is still leaking
11:30:24 <lispy> dmwit: what type of breakage? 404?
11:30:30 <dmwit> lispy: yep
11:30:46 <dmwit> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/GHC-Read.html
11:31:41 <hpc> mcstar: i had a space leak on my irc bot from doing "return ()" after a recursive loop call
11:31:56 <hpc> mcstar: and building up a huge (>> return () >> return () >> ...) action
11:32:04 <elliott> hpc: ouch
11:32:08 <hpc> perhaps that could be it?
11:32:25 <hpc> elliott: yeah, talk about sneaky bugs :P
11:34:34 <parcs`> iago: are you on a 32 bit machine?
11:34:51 <iago> parcs`, no, on a 64-bit one
11:35:30 <parcs`> iago: i think int is 32 bits even on 64 bit systems
11:35:53 <elliott> Int is 64-bit on 64-bit
11:36:00 <elliott> or are you talking about C
11:36:06 <parcs`> c
11:36:18 <elliott> there are systems where int is 64-bit on 64-bit machines
11:36:21 <parcs`> gcc says int is 32 bits, and so ghc says "ok"
11:36:22 <elliott> but they're pretty rare :P
11:37:53 <mcstar> hpc: i get huge amount of bytestrings 'pinned;
11:38:09 <dmwit> :t lexP
11:38:11 <lambdabot> Not in scope: `lexP'
11:38:13 <parcs`> the c standard requires ints to be at least 16 bits in size
11:38:14 <dmwit> :t lex
11:38:15 <lambdabot> String -> [(String, String)]
11:42:21 * dmwit claps his hands
11:42:34 <dmwit> :t Text.Read.Lex.lexString
11:42:35 <lambdabot> Not in scope: `Text.Read.Lex.lexString'
11:42:53 * dmwit unclaps his hands
11:44:02 <iago> parcs`, thanks, indeed GCC says int is 32-bit
11:44:13 <Twey> *palc*
11:46:56 <DevHC_> where (which lib) should the existence of stg_newByteArrayzh come from?
11:48:25 <Twey> preflex: zdec zh
11:48:25 <preflex>  #
11:48:36 <kallisti> {-# LANGUAGE TemplateHaskell, TypeSynonymInstances, FlexibleInstances,  UndecidableInstances, OverlappingInstances, IncoherentInstances,  MultiParamTypeClasses #-}
11:48:41 * kallisti is finally a real Haskell programmer.
11:49:03 <luite> ugh IncoherendInstances
11:49:05 <luite> uh, t
11:49:07 <luite> not d
11:49:07 <elliott> don't use IncoherentInstances
11:49:09 <elliott> ever
11:49:20 <elliott> this isn't even an "lol don't use unsafeCoerce it'll blow up your house"
11:49:33 <DevHC_> kallisti: REAL(TM)
11:49:40 <kallisti> what if it has no semantic difference ever?
11:49:42 <Twey> DevHC_: Looks like maybe Data.Text.Array?  That's a post-mangler name.
11:50:08 <sclv> You have a problem. You think "I'll use incoherent instances." Now you don't even know what your problem is anymore.
11:50:22 <Twey> DevHC_: It also looks like something really low-level you shouldn't be messing with.
11:50:32 <kallisti> the 2 instances have the exat same result, the difference is that one id and the other is not. it's basically an optimization.
11:50:34 <Twey> (trailing # indicates unpacked magic stuff)
11:50:35 <kallisti> *exact
11:50:51 <DevHC_> Twey: i'm just compiling a shared library, and i'm getting this unresolved symbol
11:51:02 <Twey> DevHC_: What library?
11:51:09 <DevHC_> my shared library
11:51:26 <Twey> DevHC_: Did you remember to link in all the dependencies?
11:51:39 <DevHC_> --make should have done that for me
11:51:39 <Twey> (specifically, Data.Text?)
11:51:42 <Twey> Mm
11:51:57 <kallisti> elliott: you're one to talk, exploiting GHC magic to essentially create instances at runtime.
11:53:06 <elliott> kallisti: I'm not saying "IncoherentInstances is really hard you should avoid it if possible".
11:53:11 <elliott> I'm saying "IncoherentInstances should not even exist".
11:53:49 <kallisti> I don't see how it's any worse than unsafeCoerce and friends.
11:54:24 <DevHC_> ok, now here's the shared library fuckage:
11:54:29 <scooty-puff> a lazy monad wrapping a strict monad will still be lazy, while a strict monad wrapping a lazy monad will be... lazy in the outer one's effects?
11:54:30 <DevHC_> /usr/bin/ld: /usr/lib/ghc-6.12.1/libHSrts.a(RtsAPI.o): relocation R_X86_64_32 against `ghczmprim_GHCziBool_True_closure' can not be used when making a shared object; recompile with -fPIC
11:54:30 <DevHC_> /usr/lib/ghc-6.12.1/libHSrts.a: could not read symbols: Bad value
11:54:51 <DevHC_> (the "next stop" after adding -L /usr/lib -lHSrts)
11:54:52 <mekeor> @where hpaste -- use hpaste
11:54:53 <lambdabot> http://hpaste.org/
11:54:53 <parcs`> stop breaking ghc!
11:55:11 * kallisti realizes he's had a good day when he switches emacs to a buffer named Internal.hs<3>
11:55:25 * hackagebot pointfree 1.0.4.3 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4.3 (BenMillwood)
11:56:08 <scooty-puff> *strict in the outer one's effects
11:56:20 <Twey> benmachine: Is that λb's @pl?
11:56:37 <elliott> Twey: Yes.
11:56:48 <Twey> Aha
11:57:24 <DevHC_> however, after compiling a GHC with -fPIC (i hope i put -fPIC in the correct places), i get:
11:57:25 <DevHC_> Implicit import declaration:
11:57:25 <DevHC_>     Could not find module `Prelude':
11:57:25 <DevHC_>       Perhaps you haven't installed the "dyn" libraries for package `base'?
11:58:29 <merijn> I've been thinking about my problem all wrong... one epiphany in the train later I think I have my solution
11:58:45 <hpaste> merijn annotated “Type hackery” with “Type hackery (annotation)” at http://hpaste.org/66869#a66877
12:00:31 <dmwit> kallisti: The difference between unsafeCoerce and IncoherentInstances is this: if the code A compiles, and code B compiles, and the only difference is that code B has additional instances, then: with unsafeCoerce, the two compiled results will behave exactly the same (perhaps both crash, for example); with IncoherentInstances, this property does not hold.
12:01:24 <dmwit> Whether you hold as fervent a belief that this is bad as elliott does is another question.
12:01:57 <elliott> It's just evil :(
12:02:45 <mcstar> RWH mentions Data.Array.Vector, what is this?
12:03:40 <elliott> That's the old uvector library, I believe.
12:03:56 <elliott> Another piece of outdated material.
12:05:54 <luite> does hackage 2 allow packages to be deprecated in some way?
12:07:51 <mcstar> elliott: ok, what to use then?
12:08:29 <luite> does anyone know offhand what I need to do to run Distribution.Simple.Configure.configure with a some fake-ghc-wrapper option
12:10:10 <elliott> mcstar: The vector package, probably.
12:10:19 <anicake> hi haskellers!
12:10:23 <alpounet> yes, the vector package is uvector's successor
12:10:26 * hackagebot variable-precision 0.1 - variable-precision floating point  http://hackage.haskell.org/package/variable-precision-0.1 (ClaudeHeilandAllen)
12:10:47 <alpounet> luite, i think deprecation is planned for hackage2
12:10:54 <alpounet> don't think it's already implemented though
12:14:28 <pqmodn> dmwit: in System-F omega can the (->) type constructor also be defined at the object level?
12:14:50 <t7> value level? no
12:15:01 <t7> values have to have a kind of * i think
12:15:14 <pqmodn> t7: not value-level, it's a type constructor like Maybe
12:15:37 <t7> whats object level?
12:15:43 <dmwit> pqmodn: No, (->) is not definable.
12:15:50 <copumpkin> ([a] -> x) -> ([b] -> y) -> [(a, b)] -> (x, y)
12:16:07 <dmwit> pqmodn: Every language has a few base types (or constructors). In System F, (->) is one of these.
12:16:13 <pqmodn> t7, for instance Either = \a:*. \b:*. \r:*. (a -> r) -> (b -> r) -> r
12:16:29 <pqmodn> dmwit: is there another language which can define this?
12:16:43 <dmwit> pqmodn: Yes, but only in terms of more powerful type constructors. =)
12:16:48 <pqmodn> dmwit: i suppose it would require "kind constructors" ?
12:16:57 <dmwit> pqmodn: e.g. Agda and Coq define (->) as a dependent product with no dependency.
12:17:21 <pqmodn> ok, i'll pursue that another time, but it's helpful to know where to look :)
12:17:45 <dmwit> x -> y = forall x. y exactly when y does not include x as a free variable
12:18:12 <dmwit> err
12:18:15 <t7> pqmodn: i guess you could define it as a type constructor yourself but type checking application needs to know about it...
12:18:39 <dmwit> e -> e' = forall x:e. e' when e' does not include x as a free variable, I mean
12:18:40 <nexion> hey guys, if I have a list like [("k1", "v1"), ("k2", "v2"), ("k3", "v3")] and I'd like to read that into either "Just (v1, v3)" or Nothing (if the k1 or k3 pair is missing), what's the nicest way to do that?
12:18:48 <DevHC_> verified for a pre-built GHC 7.4.1:
12:18:49 <DevHC_> /usr/bin/ld: /home/amsterdam/lghc/lib/ghc-7.4.1/libHSrts.a(RtsAPI.o): relocation R_X86_64_32 against `ghczmprim_GHCziTypes_True_closure' can not be used when making a shared object; recompile with -fPIC
12:18:49 <DevHC_> /home/amsterdam/lghc/lib/ghc-7.4.1/libHSrts.a: could not read symbols: Bad value
12:19:25 <nexion> the only ways I can think of involve using filter to look for k1 and then k3
12:19:34 <nexion> but I suspect there is a much better way
12:19:46 <dmwit> nexion: do v1 <- lookup "k1" list; v2 <- lookup "k2" list; return (v1, v2)
12:20:03 <elliott> (Unfortunately that has bad GC properties.)
12:20:14 <dmwit> He said nicest. =)
12:20:20 <elliott> Right :)
12:20:27 <nexion> lol
12:20:35 <nexion> what's wrong with it?
12:20:36 <elliott> (,) <$> lookup "k1" xs <*> lookup "k2" xs  -- I nicered it!
12:20:42 <elliott> nexion: It retraverses the list each time
12:20:51 <dmwit> nexion: It traverses the list twice, meaning it can't be GC'd as it's produced.
12:21:02 <elliott> More importantly it's probably slower
12:21:03 <dmwit> nexion: You could write a significantly uglier version that traversed the list only once.
12:21:06 <elliott> Now if you have a zippable fold type...
12:21:17 <elliott> then you could do (,) <$> lookup' "k1" xs <*> lookup' "k2" xs.
12:21:26 <elliott> But that's probably not worth the effort of writing for this one function :p
12:21:42 * dmwit is willing to bet that performance isn't an issue
12:21:49 <dmwit> Or else we wouldn't be seeing association lists and the like.
12:21:51 <nexion> yeah, I'll optimize if it becomes a bottleneck later on, but I doubt it
12:21:51 * elliott too
12:22:30 <nexion> what about going from (Maybe v1, Maybe v2) to Maybe (v1, v2)?
12:22:43 <dmwit> :t liftM2 (,)
12:22:44 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
12:22:48 <copumpkin> uncurry (liftM2 (,))
12:23:03 <hpc> note that you lose information in the cases (Nothing, Just _) and (Just _, Nothing)
12:23:10 <dmwit> :t do v1 <- m1; v2 <- m2; return (v1, v2) -- recognize this skeleton from any recent suggested code, nexion?
12:23:11 <lambdabot> Not in scope: `m1'
12:23:11 <lambdabot> Not in scope: `m2'
12:23:16 <dmwit> :t \m1 m2 -> do v1 <- m1; v2 <- m2; return (v1, v2) -- recognize this skeleton from any recent suggested code, nexion?
12:23:17 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => m t -> m t1 -> m (t, t1)
12:23:18 <copumpkin> hpc: there's no way you could have provided a Just there
12:24:16 <gwern> > 841 + 2038 + 2372
12:24:18 <lambdabot>   5251
12:24:31 <mcstar> can i use a vector-bytestring where a bytestring is expected?
12:24:44 <elliott> No.
12:24:53 <hpc> there's probably conversion functions
12:24:54 <elliott> vector-bytestring is experimental; you should probably not use it.
12:24:58 <elliott> But yes, there are.
12:25:05 <nexion> what do you mean, dmwit? what's a skeleton?
12:25:15 <elliott> (Heck, it even depends on criterion right now :) )
12:25:31 <dmwit> nexion: That's not a technical term. I just meant you should look at the code I suggested earlier and see if you could notice the similarities.
12:25:56 <nexion> to the one with the lookups?
12:26:00 <dmwit> yes
12:26:09 <nexion> ya
12:26:13 <elliott> Is there a faster way of getting (n .&. 255) and (n `unsafeShiftR` 8) together?
12:26:36 <dmwit> Depending on sign, quotRem is pretty fast.
12:26:45 <dmwit> Profile to see if it's faster than bit operations.
12:26:55 <dmwit> Probably not, though.
12:27:18 <t7> :t unsafeShiftR
12:27:19 <lambdabot> Not in scope: `unsafeShiftR'
12:27:28 <t7> :|
12:28:32 <elliott> dmwit: I forget which one quotRem is. I can't handle getting a negative from the first operation.
12:28:36 <mcstar> this damn vector-bytestring has the whole haskage as dependency
12:28:44 <mcstar> c*
12:28:51 <elliott> mcstar: Why are you using it? It's an experimental package meant as a proposal to replace the main bytestring
12:28:52 <hpc> > quotRem (-5) 5
12:28:53 <lambdabot>   (-1,0)
12:28:54 <elliott> not as something to actually use
12:28:59 <elliott> it even depends on a benchmarking library :)
12:29:00 <hpc> > quotRem (-5) 4
12:29:01 <lambdabot>   (-1,-1)
12:29:08 <elliott> > divMod (-5) 4
12:29:08 <hpc> > divMod (-5) 4
12:29:09 <lambdabot>   (-2,3)
12:29:09 <lambdabot>   (-2,3)
12:29:12 <elliott> Right.
12:29:30 <alpounet> divMod enforces the rest to be positive, yes
12:29:36 <elliott> @check \x -> (x .&. 255) >= 0
12:29:37 <lambdabot>   "OK, passed 500 tests."
12:29:40 <elliott> @check \x -> (negate x .&. 255) >= 0
12:29:41 <lambdabot>   "OK, passed 500 tests."
12:31:13 <mcstar> elliott: because im going crazy over this space leak
12:35:27 * hackagebot reactive-banana 0.5.0.1 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.5.0.1 (HeinrichApfelmus)
12:38:06 <dervall> So, my easter haskell adventure is concluded now, hopefully I'll get to code in it again. I wrote a blog post about the experience http://binarysculpting.com/2012/04/12/a-review-of-my-haskell-adventure/ . Anyone care to comment?
12:38:54 <dervall> From the perspective of a .NET guy with no real functional programming experience by the way
12:39:29 <mcstar> sad
12:39:40 <mcstar> i hoped you were an F# guy
12:39:57 <dervall> never had the oppotunity to be honest
12:40:17 <mcstar> probably gonna read it nevertheless
12:40:28 <mcstar> it is better, than going crazy
12:41:05 <hpc> dervall: pretty accurate
12:41:26 <hpc> dervall: with the side-note that getting SDL working on windows in any other language is going to be just as much a pain
12:41:48 <dervall> hpc: I did it in C++ some time ago, was pretty easy IIRC
12:41:59 <Clint> what's the best way to repeat a bytestring infinitely?
12:42:02 <hpc> haskell is definitely a language for linux users
12:42:16 <Cale> Yeah, Windows is a second class citizen when it comes to programming in general. I think one contributing factor is just that there's not that much in the way of development tools which can be relied on to exist in any Windows installation.
12:42:26 <mcstar> hpc: how so? i thought that was perl
12:42:55 <dervall> Cale: Well, yes, it's visual studio country here
12:42:55 <zomg> Cale: unless you work with .NET of course ;)
12:43:08 <Zariel> Im not going mad, you can pattern match against a value constructor right?
12:43:20 <hpc> ghc on windows all but installs linux already
12:43:23 <Cale> Zariel: yes
12:43:26 <kallisti> Zariel: last I checked
12:43:37 <Cale> Zariel: data constructors are exactly the things which you can pattern match against
12:43:55 <hpc> Zariel: are you pattern matching on the data constructor or the type constructor?
12:43:56 <benmachine> Twey: I've done basically zero authorship on pointfree, btw, I just update the dependencies and make sure it isn't broken
12:44:01 <mcstar> windows needs a kick ass console at least
12:44:10 <hpc> hint: data Bool = False | True -- type constructor = value constructors
12:44:16 <dervall> Well, powershell is pretty good these days..
12:44:28 <benmachine> hpc: possibly not the least ambiguous use of = there
12:44:30 <mcstar> but the shell itslef sucks
12:44:33 <dervall> though I actually use git bash for everything now
12:44:35 <mcstar> afaik, i can be wrong
12:44:35 <Cale> Yeah, I'm surprised that it seems nobody has written a really good terminal emulator for Windows (or at least I couldn't find one)
12:44:42 <Cale> There's putty
12:44:42 <hpc> benmachine: yeah...
12:44:43 <sclv> dervall: nice article
12:44:43 <mcstar> ^^
12:44:46 <Cale> but that's specialised to ssh
12:44:50 <sclv> i'm sure you found this? http://hackage.haskell.org/packages/archive/JuicyPixels/1.1/doc/html/Codec-Picture.html
12:44:55 <Zariel> ah right i see, when you pattern match you have to specifiy each of the arguments not just the reference to the value (?)
12:45:02 <dervall> sclv: Thanks!
12:45:03 <sclv> i guess learning to use an api off of a few hackage docs is a bit of na art...
12:45:14 <hpc> dervall: haskell programmers tend to avoid IDEs because ghc gives nice error messages
12:45:17 <parcs`> you can use putty to ssh to a cygwin environment on the same machine ;)
12:45:18 <benmachine> Zariel: perhaps if you show us the pattern match that isn't working for you, that would help
12:45:28 <sclv> there's also a command to cabal install haddocks locally
12:45:30 <mcstar> there is mintty
12:45:31 <hpc> (not nice as in complete sentences, but nice as in actually pointing to the line the error is on)
12:45:33 <sclv> if you can't get them on hackage.
12:45:33 <mcstar> its is quite ok
12:45:40 <mcstar> but it runs cygwin
12:45:44 <mcstar> not cmd
12:45:50 <dervall> sclv: Nope. Didn't find that. Can't navigate hackage yet
12:45:55 <hpc> dervall: and they use ghci to quickly type-check their code
12:46:19 <sclv> sadly, hackage has no good navigation yet.
12:46:32 <Cale> I can think of a number of things that a haskell-specific IDE could do really well, but they're not things which are already done by existing IDEs, and most of the features of existing IDEs seem a bit extraneous in the context of Haskell, at least to me.
12:46:33 <dervall> hpc: Ghc gives good error messages once you speak its language! In the beginning it spits out goobledegook to you
12:46:33 <hpc> (hoogle is decent navigation)
12:46:38 <Zariel> im trying to pattern match like this https://gist.github.com/cba508563adc50a031ea
12:46:42 <hpc> dervall: true...
12:46:43 <mcstar> windows has another shortcoming: a good tiling wm
12:46:45 <sclv> its just a big list of packages + google search + a somewhat arbitrary hierarchy.
12:46:52 <Zariel> but I guess i have to include all the arguments in the matching?
12:47:03 <sclv> the oft-delayed hackage 2 rollout will eventually, supposedly, make things nicer.
12:47:07 <Cale> Zariel: MSH has more parameters than that, yes
12:47:12 <dervall> hpc: I mean, I kinda understand it now and its cool. But in the beginning it was all like O_o
12:47:20 <merijn> Cale: Speaking of which, are you aware of any research groups work on structural editors for haskell (you know, with fancy stuff like type checking built in....)
12:47:30 <Cale> Zariel: but it's in record syntax, so if you want to extract one or two fields, you can do that.
12:47:43 <Cale> merijn: Not specifically
12:47:46 <rwbarton> Zariel: you don't need to pattern match at all there
12:48:07 <rwbarton> '(MSH msh)' -> 'msh'
12:48:07 <Zariel> rwbarton: there is more than just MSH i want to match against
12:48:24 <merijn> Cale: Bummer, I've been looking around to see if anyone would be willing to let me work on something like that for my PhD...
12:48:25 <Zariel> i just cut out the rest of the declaration
12:48:25 <Cale> Zariel: The datatype you're using has only one constructor though
12:48:29 <Cale> Zariel: oh
12:48:44 <dervall> Another thing, for those that read the article, think it will fly with reddit? I don't want to pollute the discussion by posting things that noone wants to see. And /r/haskell seems pretty active
12:48:59 <Cale> Zariel: in that case, you can use   (msh @ MSH {}) to match the constructor
12:49:04 <Zariel> it could be the case that I am designing it wrong, but there will be a fair few constructors
12:49:08 <Cale> (and bind the whole structure to the variable msh)
12:49:08 <sclv> post away to haskell reddit!
12:49:11 <Zariel> Cale: ahh thanks
12:49:15 <hpc> dervall: the first impressions of new haskell coders will probably be welcome
12:49:20 * hpc isn't a regular redditor
12:49:23 <rwbarton> you can also use record pattern matching syntax
12:49:24 <sclv> proggit, on the other hand, you never know how it will be recieved...
12:49:27 <alpounet> dervall, you should post it
12:49:38 <Zariel> Cale: is the {} match against all arguments to the constructor?
12:49:45 <alpounet> having beginners publish about their experience discovering Haskell and its ecosystem is really good
12:49:51 <rwbarton> parseSegments' (MSH { getMessageType = t }) rest = if t == "ORU^RO1" then ORU msh
12:49:55 <rwbarton> or indeed
12:49:55 <dervall> I thought that I should write the first impressions down, since they won't be first impressions very long :)
12:49:56 <Cale> Zariel: yeah
12:50:09 <alpounet> and can give hints about what the focus should be on to make it easier, etc
12:50:15 <rwbarton> parseSegments' (MSH { getMessageType = "ORU^RO1" }) rest = ORU msh -- oh but now i see i lost msh
12:50:21 <Cale> Zariel: It's a degenerate case of record pattern matching (which actually is available even if you didn't declare the datatype using record syntax)
12:50:21 <rwbarton> parseSegments' msh@(MSH { getMessageType = "ORU^RO1" }) rest = ORU msh -- oh but now i see i lost msh
12:50:44 <dervall> alpounet: thanks for your input! I'll post it
12:51:38 <Zariel> coming from a java background, having ghc compile is such an awesome feeling knowing that i have the correct code :D
12:52:13 <DevHC_> http://slexy.org/view/s20duRnH7k
12:52:13 <DevHC_> how's this as an attempt to "compile GHC 7.4.1 with support for building shared libraries"?
12:52:28 <Cale> rwbarton: hehe, after the edit, you regained it, but your comment went out of date :)
12:52:34 <rwbarton> yes :(
12:52:39 <rwbarton> such is the fate of comments
12:52:43 <twomashi> rCompose func (x:xs) = (func x) . (rCompose func xs)
12:52:49 <twomashi> ghc doesnt like this ^^
12:52:59 <twomashi> but it looks like it should be valid to me
12:53:10 <hpc> :t let rCompose func (x:xs) = (func x) . (rCompose func xs) in rCompose
12:53:11 <lambdabot> forall t b (f :: * -> *). (Functor f) => (t -> b -> b) -> [t] -> f b
12:53:16 <twomashi> Occurs check: cannot construct the infinite type: b = b -> c
12:53:31 <hpc> :t let rCompose func (x:xs) = (func x) Prelude.. (rCompose func xs) in rCompose
12:53:32 <lambdabot> forall t c a. (t -> c -> c) -> [t] -> a -> c
12:53:37 <rwbarton> maybe your base case is wrong or you have a wrong type signature or wrong usage
12:53:51 <parcs`> :t foldr (.) id
12:53:52 <lambdabot> forall b. [b -> b] -> b -> b
12:53:53 <Cale> dervall: There used to be a Visual Studio extension for Haskell, a long time ago.
12:54:02 <Cale> dervall: I don't think it's been kept up to date.
12:54:06 <DevHC_> no replies...
12:54:11 <hpc> :t let rCompose func (x:xs) = (func x) . (rCompose func xs); rCompose func [] = func in rCompose
12:54:11 * DevHC_ starts compiling impatiently
12:54:11 <dervall> Right, so it's on reddit now, in case anyone cares to comment, vote and stuff http://www.reddit.com/r/haskell/comments/s6okb/first_impressions_of_haskell_a_review_of_my/
12:54:12 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> b
12:54:12 <lambdabot>     Probable cause: `func' is applied to too few arguments
12:54:12 <lambdabot>     In the expression: func
12:54:17 <hpc> :t let rCompose func (x:xs) = (func x) . (rCompose func xs); rCompose func [] = id in rCompose
12:54:18 <lambdabot> forall t a. (t -> a -> a) -> [t] -> a -> a
12:54:26 <dervall> Cale: it died with VS 2005
12:54:53 <dervall> Cale: Now there is nothing, seems to be one student working but his source is not open
12:54:54 <td123> DevHC_: I think 7.4.1 already builds shared libs
12:55:20 <DevHC_> "with support for building non-GHC shared libraries using the GHC compiler"
12:55:21 <td123> DevHC_: otherwise, what are all these .so's doing in my package :P
12:55:22 <hpc> @hoogle (t -> a -> a) -> [t] -> a -> a
12:55:22 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
12:55:22 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
12:55:23 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:55:33 <dervall> Cale: And writing visual studio addons _sucks so hard_. Believe me, I did it once. Awful api
12:55:40 <hpc> @src foldr
12:55:41 <lambdabot> foldr f z []     = z
12:55:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:55:47 <DevHC_> td123: btw: omfg an apostrophe for plural
12:57:38 <merijn> Is there a way to constrain "instance Foo a" to only work for values of a that are functions? (i.e. allowing the implementation of a separate instance for functions without OverlappingInstances)
12:58:07 <td123> DevHC_: I will ignore to comment on your lack of terminating punctuation. :P
12:58:08 <Cale> DevHC_: There's an unfortunate case where you want to pluralise something which isn't a proper word where it seems kinda standard to put an apostrophe between the non-word and the pluralising s.
12:58:09 <sclv> instance Foo (a -> b)
12:58:17 <sclv> I think you need overlap for that tho?
12:58:27 <merijn> sclv: Yes, hence my question...
12:58:44 <sclv> there's no problem with using overlap
12:58:55 <Cale> (but I'm not sure that's actually the right convention to adopt)
12:58:56 <sclv> instances like that are precisely what its for
12:58:59 <rwbarton> "instance Foo (a -> b)" is 100% plain old haskell 98... unless i am missing some other context
12:59:26 <merijn> rwbarton: "<merijn> Is there a way to constrain "instance Foo a" to only work for values of a that are functions? (i.e. allowing the implementation of a separate instance for functions without OverlappingInstances)"
12:59:27 <DevHC_> Cale: don't u dare to use the word "standard" ("common" is more correct)
12:59:29 <twomashi> i think my rCompose function broke haskell
12:59:36 <Cale> sclv: That is a single top-level type constructor applied to distinct type variables, so it's a H98 instance head
12:59:39 <merijn> Err...
12:59:44 <sclv> cale: on its own, sure.
12:59:45 <rwbarton> i didn't understand your question really
12:59:47 <merijn> I meant "that are not functions"
12:59:52 <sclv> but the moment you want some other instances.
12:59:55 <sclv> ...
12:59:56 <rwbarton> oh that part is important
12:59:59 <rwbarton> :)
12:59:59 <td123> DevHC_: also, I build non-ghc libs w/ a .so fine
13:00:05 <Cale> DevHC_: There's no meaningful distinction between standard and common in English :)
13:00:13 <merijn> rwbarton: Yeah, stupid typo...
13:00:26 <Cale> (I mean, when it comes to the English language)
13:00:33 <sclv> merijn: that's hard even with overlap!
13:00:44 <DevHC_> we need to speak teh PROPER(TM) version of english
13:00:50 <sclv> the only way i know of is some oleg hack that I wouldn't recommend.
13:00:52 <Cale> sclv: huh?
13:00:54 <merijn> sclv: I know, but easy things aren't worth doing :p
13:00:57 <td123> DevHC_: if you want, here's the build.mk for reference https://projects.archlinux.org/svntogit/packages.git/tree/trunk/build.mk?h=packages/ghc
13:00:58 <magicman> @hoogle [a] -> StdGen -> ([a],StdGen)
13:00:58 <lambdabot> No results found
13:00:59 <DevHC_> standard is defined by http://en.wikipedia.org/wiki/Standard
13:01:03 <Cale> sclv: It won't overlap with any other H98 instance head
13:01:09 <sclv> Cale: an instance for everything that is *not* an arrow is hard even without overlap
13:01:14 <sclv> or even with i mean.
13:01:16 <magicman> Hrm. Any function to generate a random permutation from a list of items?
13:01:19 <elliott> DevHC_: that's a disambiguation page!
13:01:23 <elliott> itym http://en.wiktionary.org/wiki/standard
13:01:34 <Philonous> There should be a way to match constructors without having to mention all the fields
13:01:40 <elliott> Philonous: there is
13:01:41 <Cale> Philonous: there is
13:01:41 <elliott> C{}
13:01:44 <Cale> lol
13:01:53 * elliott was hoping Cale would say C{} too
13:01:57 <Philonous> That works? Splendid.
13:02:14 <magicman> Though there's no way to match a constructor only mentioning *some* fields. It's either all or none.
13:02:20 <Cale> There is a way to do that too
13:02:20 <magicman> Unless it's a record constructor, then you're in luck.
13:02:24 <Cale> right
13:02:34 <Cale> (Make it a record constructor, name the fields you want)
13:02:36 <magicman> But not in the general case. I should've phrased that differently.
13:02:54 <Cale> Well, in the general case, you use _ for any args you don't want to name
13:02:56 <DevHC_> td123: IIRC, using that gives me the relocation error when linking with HSrts
13:03:04 <Philonous> Cale:  Btw. thanks for pointing me to hexpat-pickle. I ported it to xml-types and it's really nice to use.
13:03:10 <Cale> Philonous: great!
13:04:32 <Philonous> I just keep wondering whether there is some more general concept behind them and I just can't see it
13:04:59 <DevHC_> btw what r the differences between HSrts, HSrts_l and HSrts_p
13:05:00 <DevHC_> ?
13:05:28 * hackagebot crypto-api 0.10.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.10.1 (ThomasDuBuisson)
13:06:17 <DevHC_> td123: i'm actually talking about support for building shared libraries on x86_64 D:
13:06:51 <alpounet> DevHC_, _p is the profiling-enabled version
13:07:05 <mcstar> should i just be content that Bytetring
13:07:11 <mcstar> early Return
13:07:35 <mcstar> should i just be content that ByteStrings consume 5x their net size?
13:07:50 <rwbarton> are your bytestrings roughly 12 bytes long?
13:07:57 <td123> DevHC_: got a test program to see if I get that error?
13:07:59 <mcstar> 32bytes long
13:08:14 <rwbarton> when i estimated the overhead of a bytestring earlier it came to about 8 words
13:08:25 <rwbarton> but i might have miscounted
13:08:42 <elliott>  see http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
13:08:44 <elliott> s/^ //
13:08:48 <elliott> it's 9 words
13:09:31 <DevHC_> td123: S00N(TM)
13:10:25 <dmwit> -Wall++
13:10:41 <hpc> haha, only in haskell could a cache of Chars be an optimization
13:11:14 <rwbarton> funny but jvm has the same optimization :)
13:11:32 <c_wraith> java has an Integer cache, even :)
13:11:35 <mysticc> why this is giving error .. http://paste.pocoo.org/show/580375/
13:12:13 <hpc> the jvm has a string cache i thought
13:12:15 <Zariel> ok this is utterly amazing, parseSegments' (msh @ MSH { getMessageType = "ORU^R01" }) rest = ORU msh
13:12:40 <c_wraith> hpc: the String cache (the intern pool) is something slightly different
13:13:15 <elliott> Zariel: parseSegments' msg@MSH{ getMessageType = "ORU^R01" } rest = ORU msh  -- shorter ;)
13:13:33 <rwbarton> you can delete a lot more spaces :P
13:13:40 <mysticc> what do I have to do to use the following .. f :: Int# -> Int#
13:14:05 <mysticc> It is giving parse error
13:14:06 <mcstar> elliott: before, it consumed 77% memory, now, when i dont insert into the hashtable, i get 74% cosumation
13:14:13 <mysticc> on the type itself
13:14:15 <rwbarton> mysticc: -XMagicHash
13:14:17 <hpc> mysticc: you have two choices
13:14:19 <hpc> magic hash
13:14:26 <hpc> or reconsider your approach to that function
13:14:40 <DevHC_> well, building GHC fails: /bin/bash: fork: Resource temporarily unavailable D:
13:14:47 <DevHC_> that sux, i can haz resource hax?
13:14:53 <elliott> hpc: red pill and blue pill, right?
13:14:56 <hpc> DevHC_: too much -j?
13:15:01 <DevHC_> no
13:15:08 <hpc> well crap :P
13:15:29 * hackagebot lzma-conduit 0.4.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.4.2 (NathanHowell)
13:16:32 <elliott> Oh god dammit I hate cpp
13:16:50 <elliott> Thought this was the weirdest bug ever before I realised that cpp things ' starts a character literal
13:18:44 <c_wraith> elliott: yep.  CPP isn't a great match for haskell syntax
13:19:03 <c_wraith> CPP is strangely too *smart*
13:19:35 <mysticc> hpc: Is there a show instance for unboxed Int
13:20:19 <elliott> OK, why oh why does pattern-matching on a Word8 turn into a tree of eqWord#s? All the other numeric types end up with a nice flat "case".
13:22:45 <mysticc> how to display a variable of type Int# ... or how to write a show instance for it ..
13:22:47 <zhulikas> I assume getting last 10 digits of a 1000digit number is faster using modulus operator than using "drop ( (length l) - 10) list" where list is "show number". Is that correct?
13:22:56 <elliott> mysticc: Put it in an Int.
13:22:59 <elliott> (why are you using unboxed types?)
13:23:11 <c_wraith> zhulikas: absolutely correct
13:23:24 <mysticc> elliott: just trying something out .. nothing seriout
13:23:42 <zhulikas> what about getting first 10 digits of 1000digit number?
13:23:53 <zhulikas> well, n-digit number
13:24:24 <c_wraith> Show isn't optimal for that, since it's not lazy.  But unless you're willing to write a lot of complex code yourself, it's pretty good
13:24:31 <zhulikas> take 10 $ show number     -- I don't expect show to be lazy
13:24:46 <c_wraith> I tried to write a lazy show once.  It worked, but it was *slow*
13:25:05 <rwbarton> really it is Integer that is not optimal for that
13:25:13 <zhulikas> slow as in faster than original but not fast enough to be worth writing such complicated function?
13:25:41 <c_wraith> zhulikas: Only faster than the original in very limited cases, slower if using the whole output, and very complicated
13:25:59 <DevHC^> td123, Twey, elliott: http://slexy.org/view/s20ZftKcow
13:26:40 <zhulikas> so using show is the most sane option then, right?
13:26:48 <c_wraith> yeah
13:26:56 <zhulikas> ok, thanks
13:27:40 <zhulikas> at least I can optimize on getting last part using modulus... as before I walked all the way to the end of a (show number) and dropped what was not needed
13:27:44 <elliott> Anyone who knows Core: Does Type.integerToWord (Type.smallInteger blah) turn into anything expensive asm-wise?
13:30:00 <Enigmagic> elliott: it looks like it should be free
13:30:35 <elliott> Enigmagic: Thanks.
13:30:56 <DevHC^> td123, elliott, Twey: TALK
13:31:04 * DevHC^ waits impatiently
13:31:16 <elliott> DevHC^: I'm not going to compile some code just because you randomly pinged me to.
13:31:25 <elliott> I'm not your compiler.
13:31:59 <DevHC^> not randomly, u were shoving some "politeness drama" onto me while i was raging about GHC bugs
13:32:08 <rwbarton> lol
13:32:42 <zhulikas> what ghc bugs?
13:32:44 <copumpkin> o.O
13:32:45 * zhulikas missed the whole thing
13:32:57 <zhulikas> s/thing/drama
13:33:03 <DevHC^> rwbarton: u look like a compiler
13:33:11 <rwbarton> it was just normal DevHC rudeness
13:33:17 <rwbarton> sorry if you were looking for drama
13:33:25 <zhulikas> awwww snap.
13:33:36 <DevHC^> what the clockfuck?
13:33:38 * zhulikas keeps looking for some drama elsewhere
13:33:45 <DevHC^> rwbarton: do u even know what the n word means?
13:33:55 <copumpkin> DevHC^: calm down
13:35:01 <DevHC^> copumpkin: i'm no less calm than u
13:35:02 <mcstar> DevHC^: i can reproduce the error
13:35:03 <shergill> DevHC^: you can't handle the truth
13:35:24 <copumpkin> DevHC^: ignoring your comment for spelling "you" as "u"
13:35:42 <DevHC^> shergill: WRONG
13:36:25 <DevHC^> copumpkin: ENGLISH(TM): http://slexy.org/view/s2DFQTNrGq
13:37:05 <copumpkin> i c
13:37:10 <copumpkin> ;)
13:37:35 <dmwit> "c"? What is that, ENGLISH2.0?
13:38:34 <DevHC^> c has room for in ENGLISH(TM)
13:38:47 <copumpkin> DevHC^: parse error
13:38:48 <copumpkin> anyway
13:38:57 <dmwit> ?tell notthemessiah Just pushed a patch that halves yeganesh startup time. Further improvement will require more work than I have time for this afternoon, I think.
13:38:57 <lambdabot> Consider it noted.
13:39:01 <DevHC^> copumpkin: not really
13:39:48 <DevHC^> "y" cannot be used as "why", but "YUNO" (yes, an acronym) can be defined as "why you no"
13:40:02 <copumpkin> which still doesn't work
13:40:07 <DevHC^> explain
13:40:22 <Clint> why you no indeed
13:40:26 <copumpkin> anyway, this is #haskell
13:40:35 <copumpkin> if you want inanity, try #haskell-blah
13:40:44 <elliott> DevHC^: FWIW, not yelling at people to talk when they don't immediately respond to a contextless paste link would be a good example of politeness I would appreciate.
13:41:20 <DevHC^> no, elliott, that's called cocksuckage
13:41:32 <copumpkin> DevHC^: quit it
13:41:34 <elliott> It's called not being a dick. But clearly this is futile.
13:41:53 <DevHC^> the addressing of others as "bitch", "motherfucker", etc. implies strong friendship
13:41:59 --- mode: ChanServ set +q *!*@dsl51B6967F.pool.t-online.hu
13:42:29 <copumpkin> DevHC^: join #haskell-ops if you want to talk about it
13:42:40 <dmwit> Thanks, whoever's controlling ChanServ.
13:42:45 <elliott> ChanServ++
13:42:58 <elliott> Does anyone know where the source to old versions of base (pre-3.0.3.1 that's on Hackage) can be found?
13:42:58 <mcstar> hah
13:43:06 <elliott> Do I have to sift through the VCS repo or old GHC tarballs?
13:43:21 <dmwit> elliott: I suppose you could get the source distribution of GHC-6.x or whatever.
13:43:22 <erisco> with FRP, clearly events only know when to fire by polling... so if I have an event that is, say, listening for a button press, where do I do that polling?
13:43:31 <elliott> erisco: Most FRP implemenations are push-based.
13:43:39 <elliott> i.e., there'll be some IO code running that fires the event once the button is pressed.
13:43:46 <elliott> (Of course, that IO code is external to the FRP system.)
13:44:06 <kallisti> elliott: have you taken a look at stringtable-atom? it's pretty interesting.
13:44:08 <erisco> elliott: Mr. Conal Elliot?
13:44:55 <elliott> erisco: nope, sorry :)
13:44:59 <elliott> (but his name has two ts as well!)
13:45:05 <elliott> conal goes by the nick conal here
13:45:07 <erisco> sorry
13:45:11 <copumpkin> (and he gets annoyed if you don't put the extra T in)
13:45:27 <elliott> copumpkin: me or conal? ;)
13:45:30 * hackagebot HTTP 4000.2.3 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.3 (GaneshSittampalam)
13:45:43 <copumpkin> elliott: conal
13:46:00 <elliott> copumpkin: right. me too :)
13:46:03 <elliott> Does anyone know how far back http://darcs.haskell.org/packages/base/ goes?
13:46:13 <elliott> I guess not earlier than 2003, since that's when darcs came out :)
13:47:10 <erisco> seems a bit troublesome then, but I suppose I'll figure it out
13:47:13 <dmwit> elliott is so sensitive, he gets upset when you leave the extra t out of *other* people's names!
13:49:11 <elliott> dmwi: Right!
13:49:23 <dmwit> hah
13:50:14 <elliott> Hi there, David Michael Witt!
13:50:44 <erisco> seems a bit round-a-bout, but I suppose I'll have the main update poll for input device changes, fire corresponding IO events, where the FRP events can listen and subsequently push the new data
13:50:44 <dmwitt> Why howdy! It's nice to finally tell people my TRUE IDENTITY.
13:50:53 <mcstar> dimwit
13:50:59 <mcstar> thats how i read it(sry)
13:51:10 <elliott> I think that's how you're meant to read it.
13:51:14 <dmwitt> That's how it's meant to be read. =)
13:51:15 <elliott> At least, if it isn't, I've been reading it all wrong.
13:51:20 <mcstar> XD ok
13:51:32 <elliott> erisco: Polling is probably a bad idea.
13:51:37 <mekeor> emm see star
13:52:00 <mekeor> eh risk oh
13:52:04 <erisco> elliott: how do I not poll for changes in device states?
13:52:18 <elliott> erisco: well, what are the devices?
13:52:19 <erisco> elliott: all I can do is ask "is the mouse button held down now?" "how about now?"
13:52:21 <dmwit> Depends on the device, I'm sure.
13:52:23 <elliott> How are you accessing them?
13:52:43 <erisco> through XNA, and polling is all I have
13:52:47 <dmwit> Oh, what? You *definitely* should not be polling for mouse clicks.
13:52:52 <dmwit> whaaaat
13:52:55 <dmwit> XNA--
13:53:06 <erisco> even if XNA pushed me the changes, then XNA is polling under the hood
13:53:16 <erisco> somewhere down the line someone is polling
13:53:23 <kallisti> XNA is the silliest of things.
13:53:27 <elliott> erisco: That's not really true.
13:53:31 <elliott> I mean, at the lowest hardware level, it might be.
13:53:40 <elliott> But polling vs. event-handling is the difference between 0% CPU use and 100% CPU use.
13:53:49 <elliott> I have absolutely no doubt that XNA provides an event-based/callback interface.
13:54:28 <dmwit> Yeah, I would be beyond surprised if XNA really only offered polling.
13:54:41 <kallisti> pretty sure it does. pretty sure I've used it actually.
13:54:45 <elliott> Especially since I've seen XNA games run in my browser, and my CPU didn't even overheat.
13:54:47 * kallisti helpful.
13:55:09 <dmwit> http://forums.create.msdn.com/forums/t/87007.aspx <- mentions all kinds of events like LeftMouseButtonUp and LeftMouseButtonDown
13:55:11 <elliott> erisco: (Also, most FRP frameworks will be happier being fed event-based stuff than polling-based stuff.)
13:55:29 <dmwit> from searching for "mouse" on the XNA website
13:55:46 <tgeeky__> this goes all the way back to the systems class about polling and the trick of hardware interrupts
13:56:36 <elliott> Uh oh, dons is back in the SO game :)
13:56:47 <c_wraith> so much for the rest of us!
13:56:52 <erisco> dmwit: this is Silverlight, which is different unfortunately
13:57:07 <dmwit> Doesn't matter to me, I hit my 10k goal and I'm just coasting now!
13:57:24 * elliott hit 20k today! \o/ Not obsessed, not obsessed, not obsessed...
13:57:49 <JoeyA> 20k what?
13:57:59 <elliott> Weasels.
13:58:00 <dmwit> 20k Valuable Internet Points
13:58:18 * JoeyA gets back in his time machine
13:58:19 <zomg> elliott: you have to bang pretty hard to get 20k tbh
13:58:35 <c_wraith> I was happy to hit 1k.
13:58:35 <zomg> I have 14k and most questions I've answered are really, really basic stuff I can't even bother answering anymore
13:58:51 <zomg> I'd probably have more than 14k if I had bothered answering every one of those :P
13:58:53 <JoeyA> Ah, StackOverflow
13:59:08 <elliott> I think you get more upvotes in [haskell] than most other places.
13:59:15 <elliott> But that's just my subjective impression from seeing answers in other tags.
13:59:18 <zomg> Yeah spose you might
13:59:20 <JoeyA> I've noticed that, too.
13:59:25 <c_wraith> well. There's a lot less churn
13:59:30 <zomg> I tend to answer mostly web dev related topics since that's where my main skillset is
13:59:36 <elliott> c_wraith: Either that, or Haskellers are just naturally kind ;)
13:59:38 <c_wraith> So really good answers get noticed by more people
13:59:48 <elliott> Oh, HWN linking to the top SO questions every week can't hurt either
13:59:58 <elliott> That garbage collection answer shot up to 100 points after that
14:00:19 <JoeyA> I got disproportionately many points for this question: http://stackoverflow.com/q/3518619/149391
14:00:25 <JoeyA> (which I answered myself)
14:01:04 <elliott> Isn't it ~/.ghci nowadays, not ~/.ghc/ghci.conf?
14:01:34 <dmwit> I have noticed that questions with two complementary answers get ungodly numbers of votes.
14:01:50 <dmwit> Somebody want to pair up to write excellent complementary answers to questions? =P
14:01:53 * dmwit karma farming
14:02:03 <JoeyA> elliott: I don't know.  Doesn't that only work if your cd is the home directory?
14:02:16 <c_wraith> I was surprised how little care I got when I asked a question about audio APIs in C. Only one up-vote for my question, and I was the only person to up-vote any answers.
14:02:16 <elliott> JoeyA: "Your cd"?
14:02:22 <JoeyA> current directory
14:02:27 <elliott> I don't understand.
14:02:50 <JoeyA> If you use .ghci for your ghci configuration, does it still work if you: cd ~/foo/bar/baz; ghci  ?
14:02:57 <elliott> Sure, why wouldn't it?
14:03:18 <mcstar> cd is change directory, pwd is current dir
14:03:32 <dmwit> I understood what he meant.
14:03:58 <dmwit> elliott: It would be reasonable to assume that ghci looked at ./.ghci. This would enable project-specific ghci configs.
14:03:58 <otters> what does pwd mean exactly
14:04:00 <JoeyA> I'm just going by http://stackoverflow.com/a/3521401/149391: "GHC will also load any .ghci file it finds in the current directory."
14:04:04 <dmwit> otters: path to working directory
14:04:07 <elliott> dmwit: Ah. Doesn't it?
14:04:07 <mcstar> present working directory
14:04:14 * tgeeky_ votes for #2
14:04:26 <tgeeky_> but expects he is wrong
14:04:31 <elliott> [elliott@dinky tmp]$ echo sdjiofsdf >~/.ghci
14:04:31 <elliott> [elliott@dinky tmp]$ ghci
14:04:31 <elliott> <interactive>:2:1: Not in scope: `sdjiofsdf'
14:04:49 <dmwit> elliott: Perhaps it does; then it shouldn't surprise you that putting .ghci in ~ definitely implies that ~/.ghci gets run after cd ~/foo/bar/baz; ghci
14:04:52 <JoeyA> Ah, good to know.
14:05:06 <JoeyA> Go post that on the StackOverflow thread if you need 100 more rep.
14:05:08 <dmwit> elliott: I mean, I find the "why wouldn't it?" question a bit much. =)
14:05:32 <dmwit> s/shouldn't surprise you/might surprise somebody/
14:05:34 <JoeyA> (e.g. in case StackOverflow does another "recalc" setting you back to 19k)
14:05:39 * elliott is confused at dmwit now :)
14:05:45 <elliott> JoeyA: They do recalcs every 5 minutes now, I think.
14:05:56 <dmwit> I'm not sure it's worth explaining my complaint.
14:07:18 <elliott> dmwit: I understand why it might not, knowing that it looks at .ghci.
14:12:09 <hammer13> ping
14:12:23 <hammer13> ok still connected
14:12:39 <elliott> @ping
14:12:39 <lambdabot> pong
14:12:40 <elliott> lambdabot???
14:12:42 <elliott> lambdabot! :'(
14:13:00 <hpaste> killy9999 pasted “Parsing problem solved” at http://hpaste.org/66881
14:13:24 <killy9999> Anyone can explain why one version works and the other doesn't?
14:13:32 <killy9999> I've spent few hours on this one
14:13:54 <killy9999> and as a blind shot I used readIO which I accidentaly found in the apidoc
14:14:05 <elliott> killy9999: Simply: return is lazy.
14:14:05 <killy9999> now I'd like to know why this works
14:14:18 <killy9999> and?
14:14:20 <elliott> When you do return (read blah), the (read blah) is not evaluated until you later force that value in your program.
14:14:28 <elliott> By that time, the file is already closed, since you left the withFile block.
14:14:34 <killy9999> mhm
14:14:36 <elliott> hGetContents uses lazy IO, so it won't have even read a single byte by then.
14:14:44 <killy9999> as was suspecting that
14:14:45 <elliott> So it'll try and read the empty string.
14:14:47 <killy9999> but
14:15:03 <killy9999> I believe that I saw lots of this kind of code in LYAH for example
14:15:13 <elliott> Are you sure?
14:15:19 <elliott> If yes, then it's a bug in LYAH :)
14:15:48 <osa1> how can I convert a binary number as a string to Int ?
14:15:48 <hpaste> killy9999 pasted “Code from LYAH” at http://hpaste.org/66882
14:15:54 <timthelion> if I have data D = D {a::A,b::B,c::C,c::D} and mything :: D, and I want to create mything' which is identical except with a different d, is the only way to do mything' (D a b c d) d' = (D a b c d')?
14:16:04 <timthelion> It seems like a lot to write for such a simple action
14:16:05 <killy9999> here's a rewrite of withFile from LYAH
14:16:09 <elliott> timthelion: mything' x d' = x{d=d'}
14:16:16 <elliott> timthelion: You probably want to use lenses.
14:16:29 <timthelion> elliott: thanks
14:16:47 <killy9999> so, readIO is not lazy?
14:17:15 <hpc> :t readIO
14:17:16 <lambdabot> forall a. (Read a) => String -> IO a
14:17:39 <rwbarton> readIO produces an IO exception if the string does not parse, so it cannot be lazy
14:17:45 <killy9999> umm... does this say anything anout being lazy?
14:17:54 <killy9999> mhm
14:18:01 <rwbarton> the type signature? not reallly
14:18:03 <hpc> @src readIO
14:18:03 <lambdabot> Source not found. Maybe you made a typo?
14:18:04 <rwbarton> -l
14:18:09 <elliott> readIO s = case reads s of [(x,"")] -> return x; _ -> throwIO "aaaaa" -- more or less
14:18:39 <killy9999> well, then it looks like return has very limited use?
14:18:55 <c_wraith> return has exactly one use.  The one implied by its type signature.
14:19:01 <killy9999> elliott: but that definition of readIO also uses return...
14:19:45 <killy9999> :t return
14:19:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:19:48 <elliott> killy9999: Yes, but it looks at "reads"'s result before doing the return.
14:19:56 <elliott> return does not have very limited use.
14:20:03 <elliott> What has very limited use is lazy IO, as done by hGetContents.
14:20:16 <elliott> If hGetContents just read the entire file immediately, as most people would expect, you'd have no problem with either version.
14:20:25 <killy9999> elliott: but if return is lazy, then shouldn't reads also be performed lazily?
14:20:33 --- mode: ChanServ set -q *!*@dsl51B6967F.pool.t-online.hu
14:20:35 <elliott> Yes, but it wouldn't matter, because it'd be passed the right string.
14:20:55 <c_wraith> killy9999: the thing is, *case* is not not lazy.  And a case expression needs to be evaluated before it even knows if it will use return
14:21:24 <killy9999> c_wraith: gotcha
14:21:24 <elliott> Ooh, it's not not lazy.
14:21:27 <elliott> So it's classically lazy.
14:21:28 <elliott> killy9999: But, again, this would work *perfectly* if hGetContents wasn't weird.
14:21:37 <elliott> Don't worry about return, worry about withFile in combination with hGetContents.
14:21:43 <elliott> Note that if you use hGetContents, you can just use openFile.
14:21:49 <elliott> Since hGetContents closes the file once the whole string is consumed.
14:21:52 <elliott> (But this tends to be error-prone.)
14:21:58 <rwbarton> or you can just use readFile, normally
14:22:04 <rwbarton> which is not very error prone
14:22:20 <elliott> It is error prone, because people don't consume the whole string and then e.g. try to write to the same file.
14:22:24 <killy9999> rwbarton: but then I'm writing to the same file, so I need to close it on my own
14:22:28 <rwbarton> those people are crazy anyways
14:22:29 <elliott> Which ISTR killy9999 had problems with before.
14:22:33 <rwbarton> oh sorry :P
14:22:44 <dmwit> hGetContents does not close its handle.
14:23:15 <dmwit> hGetContents semicloses its handle.
14:23:19 <c_wraith> readFile closes its handle.
14:23:29 <elliott> No, it doesn't.
14:23:34 <elliott> It closes its handle once you evaluate the [].
14:23:40 <elliott> @remember dmwit <dmwit> hGetContents does not close its handle.  <dmwit> hGetContents semicloses its handle.
14:23:40 <lambdabot> I will remember.
14:23:56 <elliott> It uses a semicloson.
14:24:08 <copumpkin> -_-
14:24:14 <killy9999> So, is there any way my code could be written better?
14:24:31 <killy9999> considering the fact that I'm proecessing data from that file and rewriting it with new data?
14:24:54 <elliott> killy9999: Using readIO there is fine.
14:25:17 <killy9999> OK
14:25:35 * hackagebot usb 1.1.0.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.1.0.1 (BasVanDijk)
14:26:48 <djahandarie> Is there a way to way to specify some IO action that should happen when a Handle closes?
14:26:54 <killy9999> then I'll call it a day
14:27:03 <djahandarie> I.e., my Handle is closed by something, I want to fire an IO action in response to that
14:27:11 <merijn> If there is a type level Compose, is there a type level Id too?
14:27:16 <c_wraith> djahandarie: Not really.
14:27:22 <elliott> djahandarie: Maybe something unportable?
14:27:32 <elliott> http://hackage.haskell.org/package/knob creates its own Handles using GHC stuff.
14:27:36 <c_wraith> djahandarie: you can just pass around (and decorate) a "close" action
14:27:47 <elliott> I bet you could write your own create-a-Handle-which-delegates-to-this-other-Handle-but-which-does-fancy-stuff-on-close code.
14:28:00 <dmwit> merijn: Of course. newtype Id a = Id a
14:28:15 <djahandarie> Well, my use case is that I have an open connection to a server, and the server may close that connection and I want to respond to that close immediately when it happens, I don't want to wait for an error when doing some operation with the Handle.
14:29:07 <dmwit> e.g. http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html
14:29:30 <merijn> dmwit: Oh, I was trying (guessing) Data.Functor.Id instead of Identity >.>
14:29:45 <c_wraith> djahandarie: so you're really looking for notification of being closed remotely?
14:29:52 <djahandarie> Yeah.
14:30:04 <c_wraith> Not sure what the options there are.
14:30:17 <djahandarie> Seems like it should be a really basic thing that anyone would want
14:30:22 <dmwit> :t bracket
14:30:23 <lambdabot> Not in scope: `bracket'
14:30:32 <elliott> djahandarie: Surely you'll be e.g. receiving from the Handle in a loop?
14:30:33 <djahandarie> It doesn't throw an exception
14:30:37 <elliott> In which case, you'll find out about when it closes pretty fast.
14:30:58 <dmwit> djahandarie: I guess the usual way is to write yourself a with* function.
14:31:22 <copumpkin> then you wrap it in ContT IO
14:31:24 <dmwit> e.g. withFancyFileThatDoesSomethingNeatWhenIt'sClosed :: FilePath -> (Handle -> IO ()) -> IO ()
14:31:29 <djahandarie> I don't want to wait to use the handle to find out it's not working.
14:31:37 <elliott> djahandarie: Why are you ever not using the handle?
14:31:45 <DevHC^> _
14:31:52 <c_wraith> djahandarie: I'm not even seeing anything for this in the bsd sockets library layer underneath
14:31:56 <djahandarie> Because sometimes it's not used
14:31:58 <elliott> djahandarie: I don't think the OSes even support what you want.
14:32:01 <elliott> djahandarie: Well, make it always used :)
14:32:08 <elliott> Receive from it in a loop in another thread, push what you get into a Chan.
14:32:32 <djahandarie> Sigh. Alright.
14:32:35 <mekeor> is this lazy?: »takeWhile (/="foo") $ words $ unlines listOfTexts« -- i mean, will haskell apply ›unlines‹ and ›words‹ completely before it applies ›takeWhile‹ ?
14:32:45 <mcstar> Productivity -32.1% of total user, -32.0% of total elapsed
14:32:46 <c_wraith> djahandarie: admittedly, TCP supports it.  But I'm not seeing OS support
14:32:50 <copumpkin> mekeor: yeah, it is
14:33:02 <mekeor> copumpkin: great. i love haskell more now.
14:33:19 <copumpkin> :)
14:34:02 <parcs`> > words (unlines ["hi", "there", undefined])
14:34:02 <lambdabot>   ["hi","there"*Exception: Prelude.undefined
14:34:42 <mekeor> cool
14:35:08 <mcstar> -s says 4614 MB total memory in use, but the heap graph shows ~1.3GB, why is that?
14:35:27 <geekosaur> er, EOF ona socket is jus like on any other handle, at least on POSIX:  0-length read
14:35:29 <DevHC^> lambdabot: hey w8 that's not right
14:35:30 <mcstar> i mean thats the maximum on the graphs
14:35:59 <DevHC^> it should be something like: ["hi","there", "*Exception: Prelude.undefined
14:36:30 <DevHC^> > ["hi","there", undefined]
14:36:31 <lambdabot>   ["hi","there","*Exception: Prelude.undefined
14:36:34 <copumpkin> that's different
14:36:37 <DevHC^> nvm
14:36:54 <dmwit> DevHC^: No, because it can't tell whether another word will start after "there" or not.
14:37:17 <DevHC^> dmwit: the "words&unlines" part didn't register here
14:37:25 <dmwit> aha
14:37:31 <ajg> hi. what's the best way to recombine the monadic output of &&&?
14:37:53 <dmwit> Can you show us a few input/output pairs, ajg?
14:37:59 <dmwit> I don't understand the question, yet.
14:38:24 <dmwit> Or the type of the function you want might even be enough.
14:38:31 <mcstar> any thoughts? the programs retains 4.5GB memory, while the profiler output shows only 1.3Gb usage
14:38:55 <dmwit> mcstar: There's a good thread discussing this stuff on the Haskell mailing list.
14:39:06 <merijn> Are there any examples using Data.Functor.Compose/Data.Functor.Identity that I can look at? I got my types right, but now I need to give useful implementation for the type...
14:39:21 <dmwit> http://haskell.1045720.n5.nabble.com/What-do-the-following-numbers-mean-td5612292.html
14:39:34 <ajg> say foo : Int -> IO (), bar : Int -> IO (), getSomeInt >>= (foo &&& bar)
14:39:39 <merijn> mcstar: Where are you getting the 4.5GB number from?
14:39:50 <mcstar> merijn: from top, and -s output
14:39:54 <mcstar> dmwit: thanks
14:40:32 <dmwit> ajg: Okay, go on.
14:40:38 <merijn> mcstar: Top is completely useless for determining memory usage
14:40:50 <monochrom> @type ((undefined :: Int -> IO ()) &&& (undefined :: Int -> IO ())
14:40:51 <lambdabot> parse error (possibly incorrect indentation)
14:41:03 <monochrom> @type (undefined :: Int -> IO ()) &&& (undefined :: Int -> IO ())
14:41:04 <lambdabot> Int -> (IO (), IO ())
14:41:09 <ajg> well, now I have a tuple of IO ()
14:41:15 <ajg> right
14:41:16 <elliott> uncurry (liftM2 (,))
14:41:28 <elliott> Then you get IO ((), ()).
14:41:30 <elliott> But, err...
14:41:32 <elliott> I'd just do:
14:41:36 <dmwit> Yeah, you probably just don't want to use (&&&) at all.
14:41:37 <elliott> getSomeInt >>= \a -> foo a >> bar a
14:41:44 <mcstar> merijn: totally not useless
14:41:56 <elliott> getSomeInt >>= liftM2 (>>) foo bar, if you must.
14:41:57 <dmwit> getSomeInt >>= liftM2 (>>) foo bar
14:42:01 <elliott> dmwit: *hi5*
14:42:04 <dmwit> o/
14:42:07 <ajg> interesting. i would have thought there was a monadic way to do &&&
14:42:17 <elliott> It's not a "monadic way", really...
14:42:22 <elliott> It's not even anything to do with (&&&).
14:42:32 <merijn> mcstar: Top reports address space usage, not actual physical memory usage, which is what you care about
14:42:51 <ajg> alright, i guess a lambda it is. thanks!
14:42:57 <dmwit> But yeah, getSomeInt >>= \a -> foo a >> bar a is much less likely to piss future you off.
14:43:07 <mcstar> merijn: my system becomes unresponsive when top reports >90% memory usage
14:43:10 <ajg> dmwit: good point :)
14:43:16 <mcstar> i mean kswapd starts swapping...
14:43:34 <mcstar> the physical memory is gone, totall, just like top says
14:43:45 <elliott> ajg: Hey, me and dmwit gave a non-lambda version.
14:43:46 <elliott> But... yeah :)
14:43:51 <elliott> ajg: Have you considered do notation?
14:43:57 <elliott> do { x <- getSomeInt; foo x; bar x } is probably the nicest of all.
14:44:03 <merijn> Lambda be gone: "getSomeInt >>= (>>) <$> foo <*> bar" :p
14:44:05 <elliott> (Except without the {;}.)
14:44:11 <elliott> merijn: Way ahead of you :)
14:44:21 <merijn> Bah
14:44:30 <merijn> Back to my own question:
14:44:39 <dmwit> merijn: Probability of maintenance rage: 98% and rising...
14:44:43 <merijn> Are there any examples using Data.Functor.Compose/Data.Functor.Identity that I can look at? I got my types right, but now I need to give useful implementation for the type...
14:45:12 <ajg> merijn: that's not bad, though a bit too noisy. thanks, though.
14:45:28 <merijn> elliott's one with liftM2 is much nicer
14:45:44 * merijn is stealing it to replace his example
14:46:44 <parcs`> :t (runKleisli .) . ((&&&) `on` Kleisli)
14:46:45 <lambdabot> forall (m :: * -> *) a c. (Monad m) => (a -> m c) -> (a -> m c) -> a -> m (c, c)
14:47:17 <ajg> elliott: do does look pretty nice. might go with that :)
14:48:08 <Peaker> Is there any nice high level socket lib?
14:48:32 <merijn> Peaker: As far as I can tell, no.
14:48:32 <parcs`> network-conduit has some stuff
14:50:23 <Peaker> will toy with network conduit, thanks :)
14:50:42 <kallisti> Peaker: what's the application?
14:52:00 <JoeyA> :t \f -> do {a <- getLine; b <- getLine; f a b}
14:52:01 <lambdabot> forall b. (String -> String -> IO b) -> IO b
14:52:11 <JoeyA> :t \f -> f <*> getLine <*> getLine
14:52:12 <lambdabot> forall b. IO (String -> String -> b) -> IO b
14:52:28 <JoeyA> Isn't there some way to use <*> or something to write do {a <- getLine; b <- getLine; f a b} more concisely?
14:52:47 <kallisti> JoeyA: f <$> getLine <*> getLine
14:52:48 <kallisti> er
14:52:50 <mauke> :t liftM2
14:52:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:52:51 <merijn> JoeyA: "\f -> liftM2 f getLinegetLine"?
14:52:51 <kallisti> oopse
14:52:58 <JoeyA> :t \f -> f <$> getLine <*> getLine
14:52:59 <lambdabot> forall b. (String -> String -> b) -> IO b
14:53:06 <kallisti> JoeyA: that's not correct.
14:53:12 <JoeyA> :t \f -> join $ f <$> getLine <*> getLine
14:53:13 <lambdabot> forall a. (String -> String -> IO a) -> IO a
14:53:30 <kallisti> JoeyA: (f =<< getLine) <*> getLine
14:53:32 <mauke> :t liftM2 ?f getLine getLine
14:53:33 <lambdabot> forall r. (?f::String -> String -> r) => IO r
14:53:49 <mauke> :t join $ join (liftM2 ?f) getLine
14:53:50 <lambdabot> forall a. (?f::String -> String -> IO a) => IO a
14:53:53 <Peaker> kallisti: Just toying with networking, to kill time :)
14:54:15 <merijn> :t \f -> join . liftM2 f $ getLine
14:54:16 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
14:54:16 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
14:54:16 <lambdabot>     In the second argument of `(.)', namely `liftM2 f'
14:54:29 <JoeyA> Thanks.  I think I'll just use join and liftM2.
14:54:40 <parcs`> why not use your original code
14:55:36 <JoeyA> It's less concise, and I have to come up with awkward variable names.
14:56:30 <JoeyA> Meh, I'll just use the original code.\
14:56:36 <parcs`> yay
14:59:38 <acowley> :t \f -> join $ f <$> getLine <*> getLine
14:59:39 <lambdabot> forall a. (String -> String -> IO a) -> IO a
14:59:55 <acowley> I think I would have gone that way
15:02:26 <kallisti> Peaker: feel free to help me with https://github.com/kallisti-dev/irc-conduit  while you're messing around with network stuff. :)
15:02:45 <kallisti> Peaker: (it's somewhat relevant, since I'm using network-conduit)
15:04:36 <kallisti> Peaker: in particular, you could attempt to break it. :D
15:04:44 <kallisti> I doubt it will be difficult.
15:06:15 <Peaker> kallisti: heh.. still learning conduit basics
15:06:31 <kallisti> me too! :D
15:06:59 <Peaker> I have a source a, pipe b, pipe c, pipe d, and sink e.   I could do: (a $$ (b =$= c =$= d =$= e))  or other arbitrary compositions... what's the canoncail way?
15:07:29 <kallisti> I don't believe that's correct
15:07:35 <kallisti> (assuming by "pipe" you mean "conduit")
15:08:09 <Peaker> well, $$ is for "running" but I'm wondering why do: a $$ b   and not have something like:  runConduit $ a =$= b  ?
15:08:41 <Peaker> http://hackage.haskell.org/packages/archive/conduit/0.4.1/doc/html/Data-Conduit.html#v:-61--36--61-
15:09:02 <kallisti> well, it depends on if you want to run them or not. :P
15:09:17 <Peaker> =$= seems to take Conduit  a-to-b    and Conduit b-to-c    and result in    Conduit a-to-c
15:09:26 <Peaker> s/Conduit/Pipe
15:09:30 <kallisti> Peaker: note that in the latest versions of conduit all of the fuse operators are actually just the same function with specific types.
15:09:37 <parcs`> Peaker: a $$ b and runPipe $ a =$= b are exactly the same it seem
15:09:40 <Peaker> and $$ seems to run and fuse two pipes. Why not fuse first, and run second?
15:09:53 <Peaker> where's runPipe?
15:10:18 <kallisti> Peaker: it's entirely dependent on your purpose.
15:10:22 <parcs`> dunno, where's runConduit?
15:10:25 <kallisti> if you run it immediately, then you want $$
15:10:29 <kallisti> if you don't, then you don't want $$
15:10:30 <kallisti> ..
15:10:41 <kallisti> runPipe is in the .Internal module I believe
15:10:45 <parcs`> oh, runConduit was a theoretical thing
15:11:00 <Peaker> well, it seems a bit arbitrary that you use $$ after fusing all-but-the-last-step
15:11:14 <Peaker> why not fuse everything and then run it? i.o.w, why isn't runPipe exposed?
15:11:20 <kallisti> what?
15:11:46 <kallisti> who is "you"?
15:11:51 <Peaker> kallisti: if I have a bunch of pipes I want to fuse together and eventually run... I have to fuse them with =$= apparently, and when I have 2 left, I use $$
15:12:00 <Peaker> kallisti: "you" in the general sense
15:12:30 <kallisti> typically you're working with 2 ends of something
15:12:53 <Peaker> well, I'm using runTCPServer, which takes an "Application m", which is a: Source .. -> Sink .. -> m ()
15:12:58 <kallisti> yes
15:13:08 <DevHC^> shapr: hi
15:13:14 <Peaker> so I have src, sink, and a bunch of my own processors, which I want to link up and run
15:13:19 <kallisti> yes
15:13:26 <Peaker> so I'm wondering what the canonical way to do that
15:13:31 <kallisti> there isn't one
15:13:33 <shapr> DevHC^: howdy
15:13:57 <kallisti> Peaker: not for that vague circumstance. there's a bunch of different ways to write the same thing.
15:14:19 <Peaker> kallisti: ok.. will ignore it and carry on then :)
15:14:31 <Peaker> (I thought it meant I was missing some elegant way to do it)
15:14:44 <kallisti> maybe
15:15:39 <mauke> DevHC^: #haskell isn't #ghc
15:16:13 <mauke> for best results, report gcc bugs to ##c
15:16:23 <kallisti> Peaker: perhaps if you attempt to find runtime errors in my irc-conduit code you will become more enlightened.
15:16:26 <Peaker> How do I make a pass-through pipe?
15:16:28 <kallisti> (complete lies)
15:16:33 <kallisti> Peaker: what does that mean
15:16:34 <DevHC^> mauke: gcc or ghc?
15:16:45 <Peaker> kallisti: What's the identity for =$= ?
15:16:49 <mcstar> haha, guys! i wrote code, that hangs ghc!
15:17:03 <DevHC^> mcstar: explain
15:17:06 <kallisti> what do you want that for..
15:17:07 <Peaker> mcstar: newtype wrappers allowing y combinator ? :)
15:17:12 <mcstar> no
15:17:19 <mcstar> [1 of 1] Compiling Main             ( rndbs.hs, rndbs.o )
15:17:21 <mcstar> thats it
15:17:23 <Peaker> kallisti: understanding the lib :)
15:17:30 <kallisti> Peaker: fmap id pipe
15:17:34 <mcstar> if i dont use -O it compiles
15:17:34 <kallisti> ?
15:17:39 <mcstar> with -O3 it just hangs
15:17:43 <mcstar> 100% cpu though
15:18:04 <kallisti> Peaker: I do: maybe (C.Done Nothing ()) yield =<< await
15:18:07 <mcstar> ok, happens with -O2
15:18:09 <kallisti> but I'm also not sure that's the best way
15:18:10 <mcstar> too
15:18:53 <mcstar> all i have is this: where fun arg = | otherwise = do blahblah
15:19:00 <Peaker> kallisti: under a "forever" ?
15:19:05 <kallisti> Peaker: no
15:19:13 <lispy> Has anyone else run into this? http://hackage.haskell.org/trac/ghc/ticket/6003
15:19:30 <kallisti> Peaker: ...but I probably should
15:19:33 <kallisti> actually :P
15:19:41 <mauke> mcstar: (there is no -O3)
15:19:43 <Peaker> kallisti: so you probably pass-through just 1 thing? :)
15:19:48 <mcstar> mauke: it accepts it
15:19:50 <kallisti> yeah
15:19:55 <kallisti> a better solution would be to use fix
15:20:00 <kallisti> or to... find the actual way to do the thing I want to do.
15:20:01 <mauke> mcstar: yes, and turns it into -O2
15:20:11 <mauke> or at least all recent ghcs do that
15:20:18 <mcstar> nevertheless, should really a compiler hand mid-compilation?
15:20:25 <mcstar> hang*
15:20:27 <DevHC^> mcstar: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html
15:20:31 <mauke> mcstar: no
15:20:47 <DevHC^> mauke: in fact it SHOULD(TM)
15:21:12 <Peaker> kallisti: You said "fmap id pipe". What's "pipe"?
15:21:18 <kallisti> a pipe
15:21:21 <kallisti> ..
15:21:27 <mcstar> DevHC^: what part is pertinent?
15:21:40 <hpaste> timthelion pasted “Type error which I cannot figure out” at http://hpaste.org/66884
15:21:41 <parcs`> Peaker: the pass-through pipe would probably be map id, where map is from Data.Conduit.List
15:22:02 <timthelion> can someone please take a look at that type error and see if they can't catch what's going on?
15:22:09 <DevHC^> what's "pertinent"?
15:22:32 <parcs`> ie relevant
15:22:38 <DevHC^> mcstar: "GHC's inliner can be persuaded into non-termination using the standard way to encode recursion via a data type."
15:23:12 <kallisti> Peaker: fix $ \p -> NeedInput (HaveOutput p (return ()))
15:23:23 <copumpkin> DevHC^: that's been common knowledge for a while, if you're talking about negative recursion
15:23:26 <kallisti> just passes along whatever it receives.
15:23:29 <Peaker> parcs`: thanks
15:23:48 <Peaker> kallisti: I was hoping not to have to mess with the low-level primitives directly
15:23:52 <Peaker> (at least not at first)
15:24:00 <copumpkin> DevHC^: here's something about something that sounds like that from 2006: http://r6.ca/blog/20060919T084800Z.html
15:24:02 <mauke> timthelion: can you give me a complete version of the code?
15:24:11 <mauke> timthelion: I mean something I can use to replicate the problem
15:24:43 <hpaste> timthelion annotated “Type error which I cannot figure out” with “Type error which I cannot figure out (annotation)” at http://hpaste.org/66884#a66885
15:24:50 <parcs`> copumpkin: does the inliner still do that?
15:24:54 <timthelion> mauke: that is the whole thing...
15:25:10 <copumpkin> parcs`: I haven't tried, but I wouldn't be too surprised
15:25:14 <kallisti> Peaker: I don't know.. there doesn't seem to be a good way to do that.
15:25:27 <kallisti> you could use forever I think
15:27:51 <kallisti> Peaker: I think it wants you to connect to one sink and then resume or something
15:28:00 <kallisti> but I don't know exactly how to do that in my case.
15:28:03 <mauke> timthelion: 'action v1 v2' is a tuple, not an IO action
15:28:08 <mauke> timthelion: you want a let binding
15:28:19 <timthelion> mauke: aha!
15:28:24 <timthelion> thank you
15:28:36 <timthelion> I've gotten bitten by that before...
15:28:37 <kallisti> Peaker: perhaps if I use resumePipe
15:28:46 <rwbarton> also you may want to either make it an action or rename that variable
15:28:54 <monochrom> DevHC^: I have always reported GHC bugs without any account. example: http://hackage.haskell.org/trac/ghc/ticket/5442
15:29:33 <monochrom> oh haha, finally it receives the milestone goal of 7.6 :)
15:30:17 <DevHC^> monochrom: u need to get a stick
15:30:28 <copumpkin> ...
15:30:38 <DevHC^> WAT
15:30:53 <monochrom> yes, what do you mean?
15:31:17 <DevHC^> poking is a way to persuade ppl to look @ bug reports and fix bugs
15:31:25 <copumpkin> no it isn't
15:31:30 <copumpkin> it's a way to piss people off
15:31:38 <DevHC^> that and to persuade ppl to...
15:31:42 <copumpkin> no
15:31:51 <DevHC^> statistics show it
15:34:03 <Peaker> kallisti: any idea how to control chunking? i.e: I do Conduit.Text.decode utf8, and I think I'm getting it line-by-line
15:34:04 <monochrom> I am not going to argue over that. My point is to tell you that the website does not require creating an account to report a bug.
15:34:09 <Peaker> but that seems like an arbitrary boundary
15:34:22 <Peaker> oh actually, the line buffering is probably from my telnet :)
15:34:24 <luite> I'm running Distribution.Simple.Configure.configure, but it says there are missing dependencies (all of them), while cabal configure works. any idea what could be wrong?
15:34:45 <Saizan> luite: --user ?
15:34:58 <luite> Saizan: yes they are user packages
15:35:30 <Saizan> luite: my guess is that cabal configure uses --user by default while D.S.C.configure doesn't
15:35:33 <DevHC^> monochrom: (un)fortunately i have registered an account there LONG(TM) ago
15:35:55 <luite> Saizan: yes mine too, but the question is then how to enable --user :)
15:36:32 <mcstar> well, guys, here is the code, that hangs with -O2 http://sprunge.us/HPcQ
15:36:38 <mcstar> pls take a look
15:36:42 <dcoutts> luite: it's one of the ConfigFlags
15:36:49 <Peaker> ok, there's line buffering somewhere in conduit, probably in the text decode
15:36:55 <Peaker> seems to be undocumented
15:36:59 <Saizan> luite: configUserInstall
15:37:13 <kallisti> Peaker: yeah await and yield are the shorthand versions of my fix example
15:37:17 <Saizan> (a field of ConfigFlags)
15:37:39 <luite> yeah I just found it, thanks!
15:38:05 <kallisti> Peaker: forever $ await >>= fromMaybe (Done Nothing ()) . yield
15:39:04 --- mode: ChanServ set +o mauke
15:39:05 --- mode: mauke set +q $a:DevHC
15:39:30 <luite> (I kind of expected them to have the same defaults as cabal-install if you use defaultConfigFlags, is there a way to get the default flags that cabal-install would use?)
15:41:05 --- mode: mauke set -o mauke
15:41:29 <luite> I could've known though, sinceDefaultConfigFlags is not IO
15:41:45 <rwbarton> interesting typo
15:42:08 <luite> hehe, oops
15:42:26 <timthelion> which typo?
15:42:32 <mcstar> camelcase
15:42:42 <dcoutts> luite: the flags cabal-install uses depends on the user's ~/.cabal/config
15:43:25 <mcstar> rwbarton: could you look at my extremely simle code i pasted, and tell me why makes it ghc hang?
15:43:35 <luite> dcoutts: yes I just realized that. fortunately I don't really need them to be the same
15:43:37 <rwbarton> oh i did take a glance at it
15:43:45 <rwbarton> i assume the problem is some RULES in vector misbehaving
15:43:51 <rwbarton> i think there is an option like -ddump-rules
15:43:57 <rwbarton> which might illuminate what is going on
15:44:12 <mcstar> rwbarton: this all is a bit disappointing for a beginner...
15:44:50 <rwbarton> it certainly is a bug in something, probably in the vector package rather than ghc proper though
15:44:53 <dcoutts> luite: the user install flag is just a set of defaults, if you want control, specify the prefix and the package dbs
15:45:03 <Peaker> kallisti: maybe      (Done Nothing ())  === return ()  ?
15:45:17 <mcstar> rwbarton: how should i apply that flag? i dont see any output
15:45:28 <rwbarton> it builds fine here though
15:45:33 <rwbarton> ghc 7.0.4
15:45:40 <mcstar> 7.4.x
15:45:51 <mcstar> 1
15:46:09 <mcstar> did you try with O2?
15:46:10 <rwbarton> ghc -O3 v -ddump-rules
15:46:14 <luite> dcoutts: oh defaults will probably work. I only need global+user and the inplace one for the package
15:46:22 <rwbarton> -O2 and -O3 (i don't think there really is a -O3 though)
15:46:51 <rwbarton> there doesn't seem to be any rule output here either
15:46:57 <rwbarton> hmm
15:47:05 <mcstar> can somebody with 7.4.1 comfirm this? preferable on Arch?
15:47:10 <dcoutts> luite: what are you doing ooi?
15:47:12 <rwbarton> oh
15:47:16 <rwbarton> ghc -O3 v -ddump-rule-firings
15:47:16 <kallisti> Peaker: maybe (return ())
15:48:35 <mcstar> rwbarton: hangs after roughly the 20th rule
15:48:44 <rwbarton> what is the last one
15:48:51 <luite> dcoutts: trying to improve the development server for yesod, which automatically rebuilds when you save a file
15:48:54 <mcstar> Rule fired: Class op return
15:49:09 <rwbarton> hmm
15:49:11 <rwbarton> i dunno then
15:49:14 <rwbarton> don't have 7.4 here
15:49:45 <mcstar> ok, i go fix my space leak then
15:49:58 <luite> dcoutts: rebuilds take a lot of time because ghc has to reload packages every time, so I have some hacks now that use the GHC API to do the rebuilds, without restarting, so packages stay loaded in memory
15:51:01 <dcoutts> luite: ah, sounds similar to what I've been thinking of recently, for IDE support
15:51:03 <Peaker> @type maybe (return ())
15:51:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
15:52:12 <mcstar> rwbarton: i think im a total idiot
15:52:18 <luite> dcoutts: greg weber has a GSoC proposal for making this more general, for IDE support, and adding the inotify/fsevents/readdirectorychanges libraries to make watching larger trees efficient
15:52:48 <dcoutts> luite: got a link?
15:53:11 <edwardk> dcoutts: apply as a mentor and i'll approve you so you can see it
15:53:38 <dcoutts> edwardk: I'm not sure that's kosher, I don't intend to be a mentor this year
15:53:41 <mcstar> rwbarton: im bitching about the space leak for like a day now, but i didnt cosider that my Debug.Trace.trace function in the guard, of the worker function, which i use for periodically write some info, is actually makes my code generation impossible
15:53:45 <td123> mcstar: ya your program seems to take up a lot of time when compiling it with ghc -O2
15:53:46 <Peaker> kallisti: forever $ maybe (return ()) yield =<< await      seems to be elegant&working
15:53:52 <dcoutts> edwardk: but thanks
15:53:53 <edwardk> thats fine. apply, vote, and we're good
15:54:03 <mcstar> td123: does it finish for you?
15:54:09 <edwardk> i've been trying to get gwern to do the same
15:54:15 <td123> mcstar: dunno, it's still going :P
15:54:16 <mcstar> i let run for like a minute
15:54:19 <mcstar> haha ok
15:54:39 <dcoutts> edwardk: you mean sign up purely to vote, not to be a mentor?
15:54:46 <edwardk> dcoutts: yeah
15:54:56 <dcoutts> edwardk: sounds dubious :-)
15:55:04 <edwardk> dcoutts: its up to the orgs
15:55:15 <dcoutts> edwardk: google don't mind that?
15:55:31 <edwardk> dcoutts: besides since a few of the proposals are about cabal, your voice would be welcome in the meta discussion
15:55:37 <edwardk> not at all
15:55:40 <dcoutts> ok
15:55:59 <alpounet> we have some pretty cool proposals
15:56:28 <shachaf> Are the proposals publicly-viewable?
15:56:29 <td123> mcstar: ya, I'm gonna kill it..
15:56:37 <edwardk> i talked sbahra into signing up as a mentor this year, but at most he plans to backup mentor stuff that deals with lock-free structures for instance
15:56:52 <alpounet> shachaf, i don't think so
15:57:03 <sbahra> \o
15:57:23 <edwardk> i'd like to get gwern involved more upfront because well, frankly he has some reasonably well thought out and vocal post hoc gripes about what gets approved, so i figured it'd be good to get him in where his commentary can do more good
15:57:32 <dcoutts> aye
15:58:01 <edwardk> and at least then it removes a bit of the peanut gallery effect. he'll know more about what we have to work with
16:02:14 <td123> mcstar: -O1 compiles fine, -O2 seems to get stuck (or take an unknown amount of time)
16:02:21 <mcstar> yes
16:02:30 <mcstar> which version of ghc and vector?
16:02:33 <td123> mcstar: maybe try turning on the optimizations 1 by 1 that differ o1 w/ o2
16:02:40 <td123> mcstar: on arch
16:02:46 <Peaker> kallisti: it seems like you've accidentally inlined ircSource/ircSink in runIRCClient
16:03:02 <td123> mcstar: vector 0.9.1
16:03:07 <mcstar> td123: we saw that it hangs in some kind of rule
16:03:18 <mcstar> i dont know what that is, but rwbarton does
16:05:18 <Peaker> kallisti: you also don't seem to handle line-splitting there
16:05:25 <Peaker> kallisti: it looks really nice. Conduit seems like a good job :)
16:05:39 <Peaker> (and this IRC shows that it makes nice things)
16:06:17 <Peaker> kallisti: maybe (C.Done Nothing ()) yield =<< await <-- probably wrong for the reasons we discussed
16:08:24 <hpaste> keep_learning pasted “merging two sorted unboxed vectors” at http://hpaste.org/66887
16:08:39 <keep_learning> hello all
16:08:54 <kallisti> Peaker: there's no need to handle line splitting
16:09:05 <keep_learning> I am merging two sorted vectors
16:09:12 <dcoutts> keep_learning: cons is not efficient for vectors
16:09:14 <kallisti> Peaker: and yeah that's fixed
16:09:40 <dcoutts> keep_learning: it copies the whole thing, it'll give you O(n^2) rather than O(n)
16:10:05 <keep_learning> dcoutts Yes , its O( n ) but I am not able to find other function which do this in O ( 1 )
16:10:22 <keep_learning> dcoutts Is there any way to do this O( n )
16:10:23 <dcoutts> keep_learning: you need to generate the whole vector as one thing
16:10:31 <edwardk> keep_learning: build a list, dump the list to the vector
16:11:19 <keep_learning> edwardk, convert the vector into list , merge them and convert back to vector ?
16:12:09 <edwardk> keep_learning: yes, or even just generate a pair of IntMaps, unionWith (+) or whatever and Vector.fromList. IntMap.toList the result
16:12:31 <dcoutts> keep_learning: or here's another approach, use Vector.iterateN
16:12:32 <kallisti> Peaker: once I get this working I plan to create a higher-level interface, built on top of this one.
16:12:38 <kallisti> for both clients and servers
16:13:24 <edwardk> dcoutts: he's merging equal values, which complicates things
16:13:28 <dcoutts> keep_learning: oh, no, the type is too restricted, nm
16:14:14 <keep_learning> edwardk, dcoutts Thank you both :)
16:14:51 <dcoutts> if it were like this my trick would work: iterateN :: Int -> (a -> (a, b)) -> a -> Vector b
16:15:08 <rwbarton> you could also use the vector stream internals
16:15:27 <dcoutts> keep_learning: so you can go via lists of course, if you want to do it efficiently I think you'd have to use Vector.create here
16:15:57 <dcoutts> oh, but there's no way to return the length, hmm
16:16:39 <dcoutts> ah! unfoldrN
16:16:54 <dcoutts> your seed is the pair of vectors to merge
16:18:13 <keep_learning> dcoutts I did not understand how to use unfoldrN to merge two vector
16:18:47 <dcoutts> keep_learning: start with a simpler problem, how do you express list merging as an unfoldr?
16:18:57 <dcoutts> the array/vector version is almost identical
16:20:01 <dcoutts> @type unfoldr
16:20:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:20:57 <dcoutts> in this case you want type b = ([a], [a])
16:22:16 <hpaste> benmachine pasted “panic!” at http://hpaste.org/66888
16:22:25 <alpounet> one of the mst elegant uses i've had for unfoldr was for computing the continued fraction development of a number
16:22:42 <benmachine> can anyone with a GHC HEAD verify for me if http://hpaste.org/66888 panics for them? it's a super tiny program so should be easy to check
16:22:44 <keep_learning> dcoutts Thanks you , I am still trying to figure out.
16:24:51 <benmachine> actually that's a #ghc question isn't it
16:26:28 <diPython> hello
16:26:37 <mekeor> hi, diPython
16:26:38 <diPython> has anyone used the llvm bindings?
16:26:54 <mekeor> dylukes: ?
16:26:58 <shachaf> diPython: That seems quite likely.
16:27:09 <shachaf> If you have a question about them, you should just ask that question.
16:27:14 <mekeor> diPython: dylukes hates it.
16:27:20 <dylukes> What?
16:27:31 <dylukes> diPython: krasin's LLVM bindings are BS.
16:27:32 <mekeor> as far as i understood it...
16:27:34 <dylukes> They're... quite bad.
16:27:45 <dylukes> There are no complete bindings yet. I'm working on some, but they're weeks away from being done.
16:27:55 <dylukes> krasin's are *literally* MSP430 + Find&Replace
16:28:05 <dylukes> and then a little monkeypatching to make it emit "correct" code.
16:28:14 <dylukes> If you turn on the optimizer it all breaks down though... hehe.
16:28:38 <diPython> krasin's? are those the ones in the hackage package?
16:28:53 <mauke> :reset
16:29:15 <diPython> i just want to extract all the information in the llvm ir to pure haskell
16:29:24 <diPython> but it seems that even to get the target layout
16:29:28 <diPython> is not that easy
16:29:38 <shachaf> dylukes: What are you talking about?
16:29:55 <dylukes> A certain LLVM backend for DPCU16.
16:30:27 <shachaf> dylukes: I don't think diPython was talking about MinecraftCPUthing.
16:30:33 <hpaste> dcoutts annotated “merging two sorted unboxed vectors” with “merging two sorted unboxed vectors (annotation)” at http://hpaste.org/66887#a66891
16:30:39 <shachaf> Just the LLVM bindings for Haskell.
16:30:43 <diPython> i'm talking about the package llvm
16:30:56 <dcoutts> keep_learning: ^^
16:31:09 <dylukes> Ahhh, gotcha.
16:31:13 <dylukes> mekeor mixed it up then.
16:31:14 <keep_learning> dcoutts Thank you :)
16:31:38 <dcoutts> keep_learning: obviously it's simplified compared to yours, I'm not doing lists of pairs
16:31:59 <dcoutts> keep_learning: and for vectors you can't do the pattern matching, have to use null, head and tail
16:32:11 <dcoutts> keep_learning: but the key point is how an unfoldr works
16:32:25 <keep_learning> dcoutts Thank you for this much help
16:32:34 <dcoutts> np, have fun
16:36:06 <kallisti> dcoutts: we need an OverloadedSequences extension. :(
16:36:57 * kallisti will mention this as often as he can.
16:37:45 <luite> hm, Distribution.Simple.Build.build says that the package cannot be build on my system, cabal build works fine. I get the PackageDescription directly from the GenericPackageDescription, is that wrong?
16:38:47 <rhapsodhy> Loading package primitive-0.4.1 ... ghc: mmap 192512 bytes at (nil): Operation not permitted
16:38:48 <zzing> When I try to install lhs2tex, cabal reports: <command line>: cannot satisfy -package Cabal-1.14.0: Cabal-1.14.0-c6d4670bd950298f6fdaae76fea539be is unusable due to missing or recursive dependencies:   directory-1.1.0.2-5ce8ec4d96e120807d0ed0cb6a25d0c4 process-1.1.0.1-dd810a368ec79f28445811c5f39bd53a       I definitely have both of those, and they are globally installed (not under ~). Any idea how to fix this?
16:39:00 <rhapsodhy> i get this error whenever i try to compile something
16:39:08 <rhapsodhy> what the what?
16:39:12 <Saizan> luite: iirc you want to look into/load from disk the LocalBuildInfo produced by configure
16:39:15 <rhapsodhy> using cabal
16:39:42 <dmwit> rhapsodhy: Something's broken, perhaps permissions?
16:40:03 <rwbarton> rhapsodhy: are you on some exotic OS/architecture?
16:40:25 <rhapsodhy> rwbarton: as long as debian sid on amd64 can be considered such
16:40:25 <Saizan> zzing: they might be getting shadowed away from other installations of the same versions
16:40:31 <luite> Saizan: yeah I have that, but it also requires a PackageDescription argument
16:40:56 <rhapsodhy> dmwit: permissions to what? i've purged and reinstalled the whole haskell env, still no luck
16:41:05 <rhapsodhy> i might have missed something tho
16:41:21 <dmwit> rhapsodhy: I mean file permissions on the package in your file system.
16:41:24 <luite> Saizan: it does contain a PackageDescrioption field, but it's a separate argument
16:41:27 <zzing> Saizan, process and directory are being shadowed by ~ installed ones I just noticed.
16:41:33 <dmwit> ghc-pkg info will tell you where on your filesystem to look.
16:41:42 <rwbarton> non-root programs aren't allowed to mmap stuff at null
16:41:49 <dmwit> rhapsodhy: It's really just a shot in the dark, though.
16:42:01 <rwbarton> the question is why does ghc want to do this
16:42:24 <zzing> Why would cabal have installed packages under ~ that are already the same version under /?
16:42:43 <rhapsodhy> rwbarton: good question
16:42:45 <rhapsodhy> funny thing is
16:42:49 <rwbarton> sadly i have no idea
16:42:56 <rhapsodhy> i set up a clean env with debootstrap
16:43:02 <rhapsodhy> and everything went like a bliss
16:43:06 <rhapsodhy> same os/arch
16:43:48 <rhapsodhy> the kernel was different
16:46:19 <Saizan> luite: i'd try passing the one contained in LocalBuildInfo rather than the one in GenericPackageDescription
16:48:16 <lec> O_o
16:48:56 <luite> Saizan: yeah tried that, seems to work :)
16:49:14 <augur> theres no quote facility in haskell, right?
16:53:56 <benmachine> augur: what do you mean?
16:55:02 <augur> benmachine: well, equivalent to quote in lisp
16:55:24 <benmachine> augur: I don't know much about quote in lisp, but TH gives similar sorts of things
16:55:29 <benmachine> (although is GHC not haskell)
16:55:56 <augur> benmachine: my understanding of TH is that its purely a pre-compile source transformer
16:56:10 <benmachine> yes
16:56:17 <augur> right, thats not what i mean
16:56:17 <augur> ok
16:56:18 <rwbarton> what do you expect something like quote to produce
16:56:20 <benmachine> fair enough
16:56:45 <augur> rwbarton: something in a built in data type
16:56:54 <rwbarton> haskell doesn't have this weird distinction between forms and values
16:57:07 <augur> like,   < f (\x -> y) > == App (Var "f") (Lam "x" (Var "y"))
16:57:12 <rwbarton> that is what TH gives you
16:57:21 <augur> sure, except its pre-compile
16:57:27 <rwbarton> ...
16:58:34 <benmachine> augur: how could you reasonably apply your hypothetical quote to runtime data, such that it matters?
16:58:37 <augur> rwbarton: in TH can you do unquoting?
16:58:51 <augur> benmachine: uh.. same way a lisp interpreter does
16:59:04 <augur> or maybe im misunderstanding what you mean
16:59:05 <rwbarton> you're going to have to be way more specific if you want to be understood
16:59:21 <augur> rwbarton: ok, so you dont know what unquoting is
16:59:23 <geekosaur> I think augur wants a haskell interpreter
16:59:23 <augur> ok, so like
16:59:24 <rwbarton> no
16:59:25 <benmachine> augur: well, look, if you write [| 7 + 4 |] you get a Q Exp where the Exp is InfixE something
16:59:26 <rwbarton> I know what that is
16:59:29 <rwbarton> I mean the rest of your line of questions
16:59:36 <augur> ok so then can TH do unquoting
16:59:40 <rwbarton> Prelude> Language.Haskell.TH.Syntax.runQ [| 7 + 4 |]
16:59:40 <rwbarton> InfixE (Just (LitE (IntegerL 7))) (VarE GHC.Num.+) (Just (LitE (IntegerL 4)))
17:00:08 <augur> ok, so now do an unquote
17:00:13 <rwbarton> Prelude> let x = [| 7 |] in Language.Haskell.TH.Syntax.runQ [| $(x) + 4 |]
17:00:13 <rwbarton> InfixE (Just (LitE (IntegerL 7))) (VarE GHC.Num.+) (Just (LitE (IntegerL 4)))
17:00:24 <geekosaur> no, we know what it is.  Do you understand that compiled languages are *compiled* and don't eva have an AST, just machine code?
17:01:06 <augur> rwbarton: interesting! but im guessing that its not type safe
17:01:25 <benmachine> the type safety of template haskell is a bit iffy
17:01:29 <rwbarton> it doesn't make any guarantee that the resulting value represents an expression that will type check
17:01:29 <augur> and forcs you to use THAT method -- let x = [| 7 |]
17:01:31 <augur> as opposed to
17:01:33 <benmachine> people have described it as both too storngly and too weakly typed
17:01:34 <augur> let x = 7
17:01:51 <rwbarton> well you have to unquote an expression
17:02:00 <zzing> I have some source that I would like to be able to record formula in a latex math form, but doing up an lhs file for use with lhs2tex seems to really look ugly. Is there an alternative?
17:02:25 <rwbarton> you can use IntegerL yourself if you want something of type Integer -> Expr
17:02:27 <augur> rwbarton: er.. what i mean is, it looks like the expression must be itself a TH value
17:02:48 <rwbarton> yes, otherwise it wouldn't even type check as a TH value
17:03:13 <rwbarton> there is a type class somewhere for converting Haskell values to the TH expressions for literals that represent them
17:03:15 <augur> hm, so i guess TH is a nice little wrapper for a quotational library
17:03:31 <benmachine> :t Language.Haskell.TH.Syntax.lift -- this too
17:03:31 <augur> thats interesting
17:03:32 <lambdabot> forall t. (Language.Haskell.TH.Syntax.Lift t) => t -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
17:03:35 <rwbarton> yes that's the one
17:03:52 <augur> will it work for arbitrary data types?
17:04:03 <rwbarton> it works for instances of Language.Haskell.TH.Syntax.Lift
17:04:05 <augur> i presume you'd have to write some code for converting to the TH types
17:04:28 <augur> so TH gets you *most* of the way there
17:04:59 <rwbarton> I'm not sure where we're going, but isn't Language.Haskell.TH.Syntax.lift exactly "converting to the TH types"?
17:05:51 <benmachine> rwbarton: you may have to write instances of Lift
17:05:54 <augur> "it works for instances of Language.Haskell.TH.Syntax.Lift"
17:05:57 <benmachine> see also: th-lift package
17:06:08 <benmachine> which uses TH to generate these instances
17:06:28 <augur> so yes, that's converting to the TH types, but it's stuff built on top
17:06:43 <rwbarton> I think mmorrow had a package with more Lift instances, but that was a long time ago so I don't remember too well
17:07:10 <augur> what i was really thinking was if GHC had a new constructor, say, Quote, that, when evaluated, returned the Expr arg of Quote
17:07:16 <benmachine> rwbarton: that was haskell-src-meta, it still has them but derives them all now
17:07:19 <benmachine> using th-lift
17:07:32 <augur> eval :: Expr -> Env -> Expr  ;  eval (Quote exp) _ = exp
17:07:32 <benmachine> augur: that's not a constructor as such, then
17:07:36 <benmachine> oh I see
17:07:48 <augur> bens: in the GHC-internal type, i mean
17:07:58 <augur> and so, of course, in the implemented version of haskell
17:08:32 <augur> i can see type safety becoming tricky
17:08:43 <augur> man i should try to implement a type safe homoiconic language in agda..
17:09:19 <augur> ahahahaaaa this is an exciting prospect :)
17:13:37 <tgeeky__> homoiconic. like "the artist formerly known as" Prince?
17:14:17 <augur> that, you're thinking "vaguely homophobic"
17:14:21 <augur> and by that i mean you
17:15:12 <tgeeky__> augur: perhaps. But he is currently named as a glyph.
17:15:34 <augur> a) that's not what I meant, b) he changed his name back
17:15:47 <tgeeky__> augur: this is a joke gone horribly wrong
17:15:49 <tgeeky__> did he?
17:16:00 <augur> it was a joke in bad taste
17:16:01 <augur> and yes, he did
17:17:02 <augur> afaik, anyway
17:17:07 <tgeeky__> and me being homophibic, is probably a type error
17:17:22 <tgeeky__> even if I spell it correctly
17:19:25 <Philippa> tgeeky__: context can change how people experience things sometimes?
17:19:48 <tgeeky__> Philippa: sure. That's why I gave up fast :)
17:20:02 <Philippa> on the internet, nobody knows you're not a het dog
17:20:24 <elliott> I know *I'm* a hotdog.
17:20:40 <tgeeky__> hopefully I can pay my dues by actuall learning what homoiconic means and that it's pretty interesting
17:20:54 <Philippa> elliott: I'd ask who the buns are, but -blah is thataway -> :-)
17:21:27 <elliott> I always knew -blah was contained within a smiley face.
17:37:19 <lispy> edwardk: do you know if gwern provided proposal feedback this year?
17:37:32 <edwardk> he hasn't
17:37:57 <lispy> edwardk: hmm...Last year he had strong feelings about projects but didn't get involved until they were already accepted/rejected.
17:38:09 <lispy> edwardk: It would be good if we could get him to look at the proposals now
17:38:42 <edwardk> lispy: i agree. he complained a bit that participating in the vetting process might ruin his objectivity or some such hogwash
17:38:53 <edwardk> lispy: so he may take some convincing
17:38:56 <lispy> edwardk: we may need to filter his feedback so that he doesn't scare anyway away, but I suspect he has some good ideas
17:39:16 <copumpkin> <snark>it's a lot more fun to bitch about existing ones than to take responsibility for picking better ones</snark>
17:39:30 <lispy> oh, snark tags
17:39:41 <lispy> copumpkin: you're on the semantic irc ain't ya?
17:39:47 <edwardk> <snark>well, we have gweber commenting unfiltered, so how bad could it be.</snark>
17:39:55 <copumpkin> lo
17:40:03 <copumpkin> lispy: damn right
17:40:10 <lispy> IRC 2.0
17:40:48 <lispy> I've been fighting java/tomcat all day. I need a shot of formalism to get me through this.
17:40:58 <monochrom> irc 2.0 gives you rounder fonts and gradient colours
17:42:20 <lispy> edwardk: I think slots were already allocated.  Can you check your mail to see if you know how many we have?
17:42:55 <lispy> edwardk: someone else who is running an org told me they found out on Wednesday...
17:43:09 <lispy> edwardk: or it might be in melange, I'll see if I can tell
17:43:10 <monochrom> (∀x. f x ⊑ y ⇔ x ⊑ g y) ⇒ (f∘g∘f = f)
17:43:22 <edwardk> lispy: i'll check
17:43:45 <lispy> oh, 8
17:43:47 <lispy> I see it
17:44:14 <lispy> edwardk: and at least one for darcs?
17:44:45 <edwardk> We still have the reserved slot for darcs through our org application, yes.
18:05:05 <edwardk> lispy: i emailed carol to figure out whats going on with slot allocation
18:06:57 <edwardk> lispy: we received 8
18:37:47 <elliott> hmm, when using cpp with Haskell, does it recognise haskell comments at all?
18:37:54 <elliott> or can you mess it up by putting funny stuff in the comments?
18:37:58 <elliott> (thinking e.g. an open quote)
18:39:21 <geekosaur> quotes are known to confuse it, yes
18:39:54 <elliott> yeah, i know foo' confuses it outside of comments
18:40:02 <elliott> but, I guess it does parse comments to
18:40:03 <elliott> *too
18:40:04 <elliott> sigh
18:40:08 <elliott> why do we still use CPP
18:40:30 <elliott> however the upside is that you can use CPP to generate haddocks :)
18:40:39 <Kaidelong> let nameRx = mkRegexWithOpts "<item name=\"[^\"]*\""
18:40:43 <Kaidelong> why doesn't this work
18:40:46 <Kaidelong> err
18:40:47 * hackagebot yesod-paginator 0.2.3 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.2.3 (PatrickBrisbin)
18:40:49 <Kaidelong> False False
18:40:51 <Kaidelong> being the opts
18:41:08 <elliott> define "doesn't work"
18:41:24 <Kaidelong> when I try it on regexpal it seems to match say, <item name="Crude Steel Axe"
18:41:33 <Kaidelong> but when I do it in the haskell interpreter it doesn't match anything at all
18:42:04 <elliott> not sure, then -- probably depends on what regex package you are using
18:42:10 <Kaidelong> Text.Regex
18:42:28 <rwbarton> can you demo in lambdabot
18:44:25 <Kaidelong> > let nameRx = mkRegexWithOpts "<item name=\"[^\"]*\"" False False in let Just (results) = (matchRegex nameRx "<item name=\"Crude Stone Axe\" iconFile=\"items/axe_stong.png\" level=\"1\" type=\"1\" >"
18:44:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:44:43 <Kaidelong> > let nameRx = mkRegexWithOpts "<item name=\"[^\"]*\"" False False in let Just (results) = (matchRegex nameRx "<item name=\"Crude Stone Axe\" iconFile=\"items/axe_stong.png\" level=\"1\" type=\"1\" >" in results
18:44:44 <lambdabot>   <no location info>: parse error on input `in'
18:45:10 <rwbarton> > let nameRx = mkRegexWithOpts "<item name=\"[^\"]*\"" False False in let Just (results) = matchRegex nameRx "<item name=\"Crude Stone Axe\" iconFile=\"items/axe_stong.png\" level=\"1\" type=\"1\" >" in results
18:45:10 <Kaidelong> > let nameRx = mkRegexWithOpts "<item name=\"[^\"]*\"" False False in matchRegex nameRx "<item name=\"Crude Stone Axe\" iconFile=\"items/axe_stong.png\" level=\"1\" type=\"1\" >" in results
18:45:11 <lambdabot>   Not in scope: `mkRegexWithOpts'Not in scope: `matchRegex'
18:45:11 <lambdabot>   can't find file: L.hs
18:45:23 <rwbarton> hmm
18:45:39 <rwbarton> @hoogle matchRegex
18:45:39 <lambdabot> Text.Regex matchRegex :: Regex -> String -> Maybe [String]
18:45:39 <lambdabot> Text.Regex matchRegexAll :: Regex -> String -> Maybe (String, String, String, [String])
18:45:48 <rwbarton> > undefined Text.Regex.matchRegex
18:45:49 <lambdabot>   Not in scope: `Text.Regex.matchRegex'
18:45:51 <rwbarton> :/
18:50:16 <Modius> Say I had a function in a (non-haskell) language that took an imperatively defined ()->int as a random input and returned type Result - obviously, the haskell can't have that call sig.  I respect that the formalism of haskell will force some solution where the caller decides if say a (global/threadguarded) random is used flat-out, or rationed out based on some metric.
18:50:48 <Modius> What are examples comparable to what I'm talking about?   Assume a variable number of draws against random by the function (i.e. not something you can just pass N random values to)
18:51:13 <Axman6> Modius: infinite list of random values
18:51:23 <Axman6> > randoms (mkStdGen 1234) :: [Int]
18:51:24 <lambdabot>   [-4523307068448592381,-4128524107189491389,-6113704948329601955,-3842414358...
18:51:32 <Axman6> > randoms (mkStdGen 1234) :: [Word]
18:51:33 <lambdabot>   No instance for (System.Random.Random GHC.Word.Word)
18:51:33 <lambdabot>    arising from a use ...
18:51:36 <Axman6> bleh
18:51:40 <Modius> Axman6:  I don't want that solution, as it doesn't reflect a general case I can apply to other things
18:51:55 <Modius> I want to know how to make something that interacts with random as IO
18:52:13 <Axman6> well, you can use the randomIO functions if you must
18:52:18 <Axman6> :t randomIO
18:52:18 <lambdabot> forall a. (Random a) => IO a
18:52:24 <Axman6> :t randomsIO
18:52:25 <lambdabot> Not in scope: `randomsIO'
18:52:31 <Axman6> :t randomIOs
18:52:32 <lambdabot> Not in scope: `randomIOs'
18:52:34 <Axman6> >_>
18:52:43 <Modius> The function is the essence of the algorithm, and the caller then chooses whether to have a shared random across all users (global/locked), or something elsee
18:52:46 <elliott> There is also http://hackage.haskell.org/package/MonadRandom.
18:52:47 <Axman6> anyway, you can use IO if you feel you must.
18:53:01 <elliott> Modius: It sounds like you want a prompt-based supply monad.
18:53:10 <Modius> The aim of this is understanding - I know how to implement as a stateless function; but it's not what I want to learn
18:53:22 <elliott> i.e. something that can say "hey, stop -- I need a value", and whatever's running it has to supply one, by whatever means it wishes.
18:53:43 <Modius> elliott:  I don't know the terminology; but so far it sounds like what I'm fishing for.
18:53:45 <Axman6> Modius: if you need to be stateless, then you need to use IO for random values
18:54:01 <Axman6> or, you can use a state monad which passes around the random value
18:54:06 <Axman6> uh seed
18:54:06 <Modius> elliott:  Any search terminology or example links?
18:54:20 <Modius> elliott:  Doesn't have to be randoms, can be anything that shows the principle.
18:54:20 <elliott> Axman6: I'm not sure you understand the requirements (though I'm not sure I do either) -- I think Modius wants an action that takes random values, but that can be used with all kinds of random supplies.
18:54:37 <Modius> elliott:  I think you understand what I'm asking for.
18:54:45 * Axman6 doesn't
18:54:48 <elliott> Modius: Well... I have an implementation of something that would work on my GitHub, but it's not how I'd write it were I to write it again today.
18:55:00 <elliott> But maybe it will give you some inspiration.
18:55:14 <elliott> https://raw.github.com/ehird/supply-monad/master/supply-monad/Control/Monad/Trans/Supply.hs
18:55:18 <Modius> hopefully isolated - I'm very new (well, low skilled, been trying for a while) with haskell
18:55:20 <elliott> (Go to the end of the file to see example use.)
18:55:33 <elliott> Oh, that's still the old broken representation.
18:55:39 <elliott> Yeah, you don't want to use that implementation :)
18:55:50 <elliott> There's also http://hackage.haskell.org/package/MonadPrompt.
18:56:18 <elliott> (And http://hackage.haskell.org/package/operational.)
18:56:44 <elliott> Modius: Basically you just want a monad that has one operation: random :: (Random a) => MyMonad a.
18:56:51 <elliott> Er, one additional operation over what Monad gives you, that is.
18:57:03 <elliott> Then "running" it involves specifying an interpreter for it that gives "random" some semantics in a base monad.
18:57:09 <elliott> It's less scary than it sounds.
18:57:19 <zzing> Does anyone use pandoc with a markdown lhs to produce nice html?
18:57:28 <Modius> This may be too over my head; but in the back of my mind I knew haskellers must have solved this.
18:58:11 <elliott> Well, I'm still not exactly sure what you want.
18:58:26 <Modius> elliott:  Every time you talk about it you're saying what sounds like what I want.
18:59:08 <Modius> elliott:  I don't have a specific program I'm writing now in haskell for this, I'm doing this in C# at work and thinking:  "How we pull these randoms is arbitrarily tied in with my otherwise stateless code - but how would I *really* make the definition of the algorithm stateless with respect to the random?
19:03:06 <elliott> Modius: Here, I'll write up a quick example of what I mean...
19:08:16 <hpaste> elliott pasted “Supply” at http://hpaste.org/66898
19:08:19 <elliott> Modius: ^
19:08:32 <elliott> you can ignore the lines before the definition of test if you don't understand them :)
19:09:44 <Modius> elliott:  Is "done" triggered by the usage pattern of the user (test)?
19:11:29 <elliott> I'm not sure what you mean.
19:18:02 <Modius> elliott:  Maybe my ignorance of haskellage; but the "Done" pattern, is that triggered by test being 'done' pulling values?
19:18:56 <elliott> No, the "Done" constructor is used for the "return" case..
19:19:09 <elliott> All Supply computations look like Supply (\a -> Supply (\b -> Done (a * b))).
19:19:16 <elliott> i.e. a chain of Supplys, followed by a Done.
19:21:08 <Modius> I'm half-understanding this the way I was picturing I'd have to do it cleanly in C# - in C# I'd need to have the function that does the logic return R, where R = Func<randomVal, R | Done> - that's what this is doing right?
19:21:33 <Modius> And the runSupply* functions are basically saying:  "Run this puppy pushing in new values until you're done"
19:22:17 <elliott> I don't know enough C# to say whether your assessment is correct, unfortunately.
19:22:31 <elliott> But the runSupply* functions do simply feed it values until it gives a final result, yes.
19:23:07 <Modius> Basically, mechanically, a function that returns a lambda that takes a random value, and returns either a lambda of the same type (run me again) or something indicating "done - here's your result"
19:23:14 <Modius> Heck, I can almost read this
19:23:44 <Modius> I think you've provided the sublime example - it'll be useful when I fully grok monads; but it'll also help me grok monads better as it does exactly what I asked for so I know what it's doing.
19:24:04 <elliott> Well, if you can express the concept of "either this type, or that type", then (Supply s a) is simply: "Either a result (a), or a function taking an s and returning Supply s a".
19:24:25 <elliott> So if it a computation a result, it simply gives that result; otherwise, if it needs another random value, it gives a function that takes one and returns a new computation.
19:24:26 <Modius> I'm babbling - I know enough haskell that it's obvious what it's doing in that reagard.
19:24:33 <Modius> elliott:  Yep
19:25:05 <Modius> The next step in understanding is - if "test" drew from multiple sources, (say we had a distinct FooSupply)
19:25:12 <elliott> The monadic interface simply gives a convenient interface to create these computations:
19:25:30 <elliott> We can create a computation that just returns a result: a -> Supply s a -- that's just Done, of course
19:25:32 <Modius> I assume that's where certain other techniques come into play to combine the sources and how I interact with them.
19:25:43 <elliott> Or we can compose a computation with something that expects its result: Supply s a -> (a -> Supply s b) -> Supply s b
19:26:00 <elliott> So, if we have a supply-based computation m, and we want to create a new computation based on its result, we can do:
19:26:06 <elliott> m >>= (\a -> ...create new computation...)
19:26:24 <elliott> We just need one more primitive to write supply-based computations without worrying about the implementation of the type itself: supply :: Supply s s
19:26:29 <elliott> That's just supply = Supply (\s -> Done s)
19:26:38 <elliott> It takes one value off the supply, and returns it.
19:26:41 <elliott> So, if we say
19:26:48 <elliott> supply >>= (\a -> ...create a computation based on a...)
19:26:57 <elliott> Then that gives us one supplied value, and lets us base a new computation off it.
19:27:08 <elliott> So the example that I showed, that takes two values off the supply and multiplies them, can be written as:
19:27:15 <elliott> supply >>= (\a -> supply >>= (\b -> return (a * b)))
19:27:16 <elliott> which is
19:27:22 <elliott> Supply (\a -> Supply (\b -> Done (a * b)))
19:27:36 <elliott> and indeed, the (supply >>= (\a -> supply >>= (\b -> return (a * b)))) form is exactly what the "do ..." stuff translates into
19:27:45 <elliott> Modius: Well, you're in full control of how you supply it values.
19:27:56 <elliott> You can supply it a few values from some IO-based source, suspend the computation, and then return to it later when you have some more values to give it.
19:28:09 <elliott> (For instance, you can write an interpreter of Supply that asks the user for each value.)
19:28:12 <Modius> elliot:  But what if it is drawing from 2 sources?
19:28:27 <elliott> (Or that asks the user for three values, then does something completely unrelated for a while, then asks the user for three values again, etc.)
19:28:44 <elliott> Modius: Well, the Supply computation only gets one source. But the definition of "source" is general.
19:28:48 <elliott> What do you mean by drawing from two sources?
19:29:14 <Modius> a <- supply1    b <- supply2                     <--- any techniques to playing that game?
19:29:39 <elliott> Ah, you want a variant of Supply that allows multiple supplies?
19:29:51 <elliott> That's also possible (and gets you closer to a full prompt monad).
19:30:17 <elliott> The use is still the same: you write "interpreters" that step computations through, having to give values for various requests along the way.
19:30:23 <elliott> You have to change the Supply type for it.
19:30:40 <Modius> Okay - so if writing it naively/special casing it, I'd boost up the Supply type to acommodate the request types
19:30:50 <Modius> But - I assume those other packages have goodies for combining them.
19:31:04 <elliott> Right, you could simply extend it to
19:31:18 <elliott> data Supply s1 s2 a = Done a | Supply1 (s1 -> Supply s1 s2 a) | Supply2 (s2 -> Supply s1 s2 a)
19:31:20 <elliott> But it's quite ugly :)
19:31:30 <elliott> With the prompt monad/operational stuff, you could instead write
19:31:47 <elliott> data MySupply a where Supply1 :: MySupply Int; Supply2 :: MySupply Double; ...
19:31:59 <elliott> and it'd handle all the plumbing for you, still just leaving you to write an "interpreter".
19:35:38 <Modius> Thanks elliott - btw, you conal.net?
19:36:47 <elliott> No.
19:36:49 <byorgey> Modius: no, that's conal
19:36:53 <elliott> That's - yes :)
19:37:00 <elliott> He's much more competent than I am.
19:37:13 <conal> Modius: hi
19:37:58 <Modius> I got dragged onto Twitter for an absurd reason; but now I'm trying to link it to people making programming quips
19:39:28 <Modius> elliott:  Thanks again - you knew exactly what I was fishing for, and gave a perfect small example that I can partially read, and that is food for thought for the rest.
19:40:05 <elliott> yay \o/
19:40:07 <elliott> :)
19:53:09 <zzing> Should I put my extensions in the cabal file or in comments in the respective source files?
19:53:55 <byorgey> in the respective source files.
19:56:00 <zzing> I have broken my source into modules, and I have exported a data constructor Ray in the one module, and imported the module into another but when I try to use Ray it says  that it is not in scope.
19:56:31 <byorgey> zzing: how did you export/import it?
19:56:41 <elliott> I bet you exported it as Ray, because the type is named Ray too
19:56:42 <elliott> Try Ray(..)
19:56:46 <elliott> (Or Ray(Ray) if you want that.)
19:56:49 <elliott> Same goes for the import.
19:57:00 <zzing> > module Geometry (Intersectable, Ray, Intersection, intersect) where
19:57:02 <lambdabot>   <no location info>: parse error on input `module'
19:57:45 <byorgey> zzing: yeah, to export data constructors you have to write  Type(Constructor1, Constructor2)  or  Type(..)  to export all the constructors
19:57:53 <sridatta> hey all. can anyone explain how rank-2 types help contain impure mutations in the ST monad? (as demonstrated in this simplified example http://www.vidarholen.net/contents/junk/catbag.html)
19:58:03 <zzing> ok, thank you both
19:59:14 <elliott> sridatta: Sure.
19:59:15 <zzing> It compiles, now I must work out a math problem
19:59:39 <elliott> sridatta: The "s" in (ST s a) represents a "state thread". This identifies, basically, a single ST "computation", and all the mutable variables it involves.
20:00:00 <elliott> sridatta: When you create STRefs, they're associated with the same state thread, i.e. newSTRef :: a -> ST s (STRef s a) -- note the same "s" in both types.
20:00:10 <elliott> sridatta: You can modify them freely within the same (ST s) monad.
20:00:26 <elliott> sridatta: When it comes to running it, you get runST :: (forall s. ST s a) -> a. What this means is that you're not allowed to know what "s" is.
20:00:37 <elliott> Your code has to work for all possible "s"s; it gets no information about what state thread it's actually in.
20:00:49 <elliott> sridatta: That means that you can't, e.g. runST a computation that tries to return an STRef.
20:00:49 <rwbarton> and especially, a cannot depend on s
20:00:51 <elliott> Right.
20:00:59 <elliott> So there's no way to let mutable variables escape that state thread.
20:01:17 <elliott> And you can't use mutable variables from *other* state threads, because they'll have their own "s" (that you don't know the precise choice of).
20:01:40 <elliott> Under the scenes, it's simply implemented with direct mutation of mutable variables, and runST simply runs the computation without checking anything at runtime; all the safety is in the types.
20:02:32 <sridatta> elliott: so basically you cannot return an STRef from one state thread because its "s" is known/"bound", whereas runST requires it to be "unspecified"?
20:02:36 <sridatta> sorry if I'm not using the right terms
20:02:41 <sridatta> new to this
20:02:47 <elliott> sridatta: Well, the basic thing is that (ST s (STRef s Int)) doesn't match (forall s. ST s a).
20:02:56 <aristid> @hoogle stToIO
20:02:56 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
20:02:56 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
20:02:56 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
20:03:05 <elliott> That's because you can't work with *any* s -- you require that the "s" is the same as the "s" in (STRef s Int) (which is your "a").
20:03:12 <elliott> Which is forbidden.
20:03:32 <elliott> Any attempt to sneak an STRef out of the monad will end with the same fate: you can't meet the stringent demand runST requires.
20:03:45 <elliott> Because a simply cannot depend on s.
20:03:48 <sridatta> oh, got it. I'm seeing what rwbarton meant by a cannot depend on s
20:04:19 <sridatta> elliott: cool. that's pretty neat. thank you
20:04:23 <glguy> http://control.monad.st/
20:05:00 <sizz> Which of The Haskell School of Expression, Programming in Haskell, and Learn You a Haskell is best for a first book on Haskell (non-functional background)?
20:05:01 <elliott> sridatta: Right, I mean that "a" is not allowed to mention "s" there, or it wouldn't fit (forall s. ST s a).
20:05:21 <elliott> sizz: Learn You a Haskell is the most recent and the most popular introductory book. shachaf likes Programming in Haskell a lot, I think.
20:05:27 <sridatta> awesome
20:05:29 <elliott> LYAH has the perk that it's available free online.
20:05:57 <elliott> I don't know anything about The Haskell School of Expression other than I hear it has a graphics combinator library thing that's kind of neat. But I gather it's rather unconventional.
20:06:37 <sizz> i looked through them all in the library.. HSoE looks like it might be outdated?
20:06:46 <byorgey> it's also out of date at this point.
20:06:48 <byorgey> yeah.
20:06:51 <elliott> I think it's quite old, yes.
20:07:10 <elliott> (When did Programming in Haskell come out, anyway?)
20:07:11 <zzing> Is there a completely unsafe, reckless, and otherwise dangerous thing I can use to print out the values of a variable inside of a pure function for testing purposes?
20:07:15 <sizz> I gather that Haskell is developing fast, so I guess I want a recent book
20:07:18 <elliott> zzing: see Debug.Trace
20:07:31 <elliott> sizz: Even LYAH is slightly out of date in one or two areas (but very minor areas) :)
20:07:57 <elliott> (I suggest you avoid reading Real World Haskell until you're experienced for exactly this reason; it's out of date in several major areas.)
20:08:09 <byorgey> elliott: PiH was published in 2007
20:08:22 <elliott> byorgey: Oh, that's more recent than I expected.
20:08:43 <elliott> sizz: Anyway, you probably won't go wrong with either of them. But I only have personal experience with LYAH.
20:09:13 <sizz> okay, I'll go PiH, then LYAH
20:09:22 <sizz> a bit of overlap is probably good anyway
20:09:32 <glguy> what kind of outdated stuff are we talking about here?
20:09:34 <elliott> sizz: I think you'll end up bored if you do that.
20:09:40 <elliott> glguy: In what?
20:09:50 <elliott> sizz: They'll both cover pretty introductory ground.
20:10:02 <glguy> LYAH or RWH are the most recent, I guess
20:10:25 <glguy> What's the kind of things that are so out of date that they are bad for new people?
20:10:25 <elliott> glguy: LYAH has mtl 1 stuff (State constructor, primarily)
20:10:51 <elliott> glguy: RWH has a huge pile of outdated stuff; suggests ByteString for text, mtl 1, uvector, other things I forget
20:11:07 <sizz> elliott: okay, but realize that I'm not a compsci or maths guy
20:11:16 <elliott> sizz: Are you a programmer guy?
20:11:24 <elliott> You don't need any mathematical knowledge to code Haskell.
20:11:35 <elliott> It's just different, not more complicated.
20:11:38 <sizz> i'm trying to be
20:11:52 <elliott> LYAH is aimed at those with previous non-functional programming experience.
20:11:54 <elliott> Dunno about PiH.
20:12:09 <elliott> glguy: Oh yeah, RWH does parsec 2 as well
20:12:25 <sizz> I can do shell and Perl and a bit of R, but am entirely self-taught
20:12:48 <sizz> I figure Haskell will force me to be more correct
20:12:52 <elliott> I should think plenty people here are self-taught :)
20:13:33 <elliott> Don't worry about a notion of "correctness", so much; what Haskell's type system is good at is catching stupid mistakes before you run into them.
20:13:50 <elliott> (And, with more sophistication, catching mistakes that even border on the non-stupid.)
20:14:01 <zzing> Is there a way I could have a function "debug a" where the name of whatever was passed into it could be known as a string so it could be printed?
20:14:22 <sizz> well I like what I see so far, so I'll just get stuck in!
20:14:23 <sizz> thanks
20:14:36 <elliott> zzing: Yes with Template Haskell, no without Template Haskell.
20:14:55 <zzing> elliott, I think I will be passing in the string manually :-)
20:14:59 <elliott> sizz: No problem :)
20:15:09 <elliott> sizz: Have fun, and good luck.
20:15:16 <shachaf> preflex: seen dcoutts
20:15:16 <preflex>  dcoutts was last seen on #haskell 3 hours, 42 minutes and 42 seconds ago, saying: np, have fun
20:16:43 <zzing> elliott, I should ask: Is Template Haskell painful or rewarding?
20:17:03 <elliott> Uh... if you want my honest opinion, it's painful.
20:17:07 <elliott> It's useful, but it's also painful.
20:17:14 <elliott> Others may have differing opinions.
20:17:36 <elliott> I think there is a package packaging up the "debug thing with function name" utility, though.
20:17:52 <zzing> Sounds like it is up there with C++ template metaprogramming
20:18:02 <byorgey> Template Haskell is actually fairly nice.  but learning how to use it is painful because there's no documentation.
20:18:13 <elliott> See, there's a differing opinion for you! :)
20:20:52 <Veinor> using template haskell is awesome
20:20:54 <Veinor> writing it, i dunno
20:21:22 <elliott> another differing opinion! :)
20:21:48 <rwbarton> you could also use CPP
20:23:27 <zzing> If I have a line that is long, what is the best method of breaking it up?  (i.e. where can you break it, and do you have to worry about indentation)
20:23:56 <elliott> You have to think about indentation. Not so much worry :)
20:24:08 <elliott> You can break it pretty much anywhere, unless you're in the middle of some special syntax like case or if.
20:24:30 <mauke> you can always indent the continuation more than the first line
20:27:58 <zzing> hmm, it worked this time
20:28:06 <zzing> debug trace is awesome
20:28:53 <elliott> Only use it for debugging!
20:29:53 <zzing> elliott, its evil nature tempts the best of us
20:30:22 <elliott> Only use it for debugging!!! :(
20:34:44 <zzing> Some how my acos is getting a 9.5 calculated, annoying. ;-(
20:40:38 <Zane> How do I use these functions?  http://hackage.haskell.org/packages/archive/digits/0.1/doc/html/Data-Digits.html
20:40:53 <Zane> I am a complete noob, I don't know how to import them
20:40:57 <elliott> by applying them to arguments of appropriate types :)
20:41:04 <thundercookies> elliott: hehe..
20:41:07 <elliott> "import Data.Digits" (are you reading a tutorial? it's better at explaining basics like these than IRC)
20:41:31 <Zane> I am reading "Learn You a Haskell"
20:42:39 <Zane> It says it can't find the module
20:43:16 <rwbarton> have you installed the package?
20:43:48 <Zane> oh I see now herp derp
20:44:04 <Zane> I thought it was installed with my platform, but it wasn't
20:44:13 <Zane> Thank you
20:44:29 <thundercookies> Hello, #haskell.. does anyone have a suggestion for a good "Understanding Monads" article or tutorial?
20:46:06 <elliott> thundercookies: Don't try to "understand monads".
20:46:21 <elliott> Just try to understand Haskell -- you'll end up using a bunch of monads on the way, which will be more helpful than any article or tutorial.
20:47:00 <elliott> Once you've accrued enough practical experience that you feel comfortable using specific examples of monads, you could take a look at the Typeclassopedia (http://www.haskell.org/haskellwiki/Typeclassopedia), which covers a large range of Haskell's abstract typeclasses in depth. But it's really best just to not worry about monads.
20:47:22 <elliott> If you read a good Haskell tutorial, it'll cover monads in due time.
20:48:16 <elliott> But it's actually really simple: a lot of structures happen to be able to compose as computations in certain similar ways; Haskell has an abstraction for those ways so they don't have to be redefined from scratch for every individual structure.
20:48:50 <elliott> That lets us write things like generic control structures which work with all kinds of mini-languages that add their own capabilities (like nondeterminism, state, or IO).
20:54:31 <BlankVerse> i am trying to install git-annex , i am getting the following error:
20:54:35 <hpaste> blankverse pasted “instaling git-annex” at http://hpaste.org/66901
20:54:36 <BlankVerse> Could not find module `Prelude' It is a member of the hidden package `base'.
20:54:53 <Elemir> Broken .cabal?
20:55:32 <elliott> The .cabal looks fine to me.
20:55:35 <elliott> How are you trying to install it?
20:56:35 <BlankVerse> elliott: cabal install inside the src directory?
20:56:53 <thundercookies> elliott: thanks for the heads up.. I've read plenty about Monads and instances of them in Haskell and have an understanding of them in general.  I was just wondering if there are good places to look for example programs using them.. State, Reader, IO, others.. common idioms, things like that.
20:56:54 <zzing> What does (?x::Int)  mean
20:57:05 <glguy> ?x is an implicit parameter
20:57:05 <lambdabot> Maybe you meant: . ? @ v
20:57:35 <zzing> Can you be more explicit on what you mean?
20:57:36 <elliott> zzing: it means whoever wrote that code is using an unloved and ugly extension :)
20:57:44 <Elemir> zzing: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/other-type-extensions.html
20:57:46 <BlankVerse> elliott: what does the "member of hidden package" mean?
20:57:54 <zzing> Its from http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/release-7-4-1.html :-)
20:58:01 <elliott> BlankVerse: It means it thinks it doesn't depend on a package that contains the module.
20:58:26 <Elemir> Hem, where can I find some type magic guides?
20:58:47 <elliott> thundercookies: Well, the best way is simply to write programs that use monads without caring that they're monads: if you want state, use the state monad, but the fact that it's a monad isn't really relevant to you; it just means you can use "do" notation.
20:59:03 * Elemir understands only System F magic, but cannot into interesting kind applications :(
20:59:04 <elliott> That said, as far as Monad Tutorials(tm) go, I think the least offensive is probably http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html.
20:59:15 <elliott> But I still don't think you need to read one at all until you've got some practical experience.
20:59:28 <ezyang> Hmm. What's the best monad for a fixed universe of errors that I want to pattern match on (the errors)
21:00:13 <Elemir> ezyang: You can use ErrorT and case, cannot you?
21:00:24 <ezyang> yeah, but errort is warty
21:00:28 <glguy> If ezyang didn't ask that question I'd have assumed that Elemir was on the right track
21:00:45 <rwbarton> isn't there an EitherT now?
21:00:55 <elliott> Yes, in transformers I think
21:01:19 <ezyang> I don't need a transformer, it's pure code.
21:01:25 <elliott> What's wrong with Either, then?
21:01:31 <ezyang> I could do EitherT Identity but that's kludgy
21:01:34 <Elemir> ErrorT Id :3
21:01:41 <elliott> There is also http://hackage.haskell.org/package/explicit-exception.
21:01:45 <elliott> ezyang: ...What happened to Either?
21:01:51 <ezyang> Where does that monad instance live?
21:01:58 <elliott> Control.Monad.Instances, I think.
21:02:01 <rwbarton> "what version of ghc do you have"
21:02:01 <elliott> It's a poor orphan.
21:02:05 <thundercookies> elliott: thanks for the link
21:02:08 <ezyang> Oh right, they fixed that, didn't they.
21:02:14 <glguy> ezyang: What about an EitherT are you wanting to improve upon?
21:02:29 <ezyang> nothing, it's just overkill in this instance.
21:02:47 <Elemir> Hem
21:02:51 <Elemir> > id >>= id
21:02:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
21:03:04 <Elemir> Logical
21:03:08 <Elemir> > 1 >>= id
21:03:09 <ezyang> anyway, Either with appropriately new GHC seems to be the right answer here.
21:03:09 <lambdabot>   No instance for (GHC.Show.Show (m b))
21:03:09 <lambdabot>    arising from a use of `M9154623978...
21:03:55 <mauke> > ["1"] >>= id
21:03:56 <lambdabot>   "1"
21:04:07 <ezyang> I forgot that life gets simpler when you don't care about being generic :-)
21:04:17 <elliott> Polymorphism is overrated.
21:04:36 <Elemir> :t ["1"] >>= id
21:04:37 <lambdabot> [Char]
21:04:51 <Elemir> :t 1 >>= id
21:04:52 <lambdabot> forall (m :: * -> *) b. (Num (m (m b)), Monad m) => m b
21:05:10 <Elemir> Hem
21:05:24 <mdmkolbe> If "f :: a -> b -> m c", "x :: m a" and "y :: m b", is there an elegant incantation for applying f to x and y?  (If there was only one argument I'd use (f =<< x))
21:05:50 <elliott> mdmkolbe: join (f <$> x <*> y)
21:07:21 <mdmkolbe> elliott: that basically uses the (r->) instance of monad?
21:07:36 <ezyang> either is not traversable? Travesty!
21:07:58 <elliott> mdmkolbe: Nope.
21:08:04 <elliott> mdmkolbe: It uses the m instance of Applicative.
21:08:09 <elliott> ezyang: Barely anything is Traversable, unfortunately.
21:08:45 <ezyang> I feel like most container-y functors should be traversable
21:08:56 <rwbarton> Maybe is Traversable
21:09:03 <rwbarton> so Either e really ought to be also
21:17:11 <augur> i dont understand Traversable :(
21:18:45 <Elemir> @src Traversable
21:18:46 <lambdabot> class (Functor t, Foldable t) => Traversable t where
21:18:46 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
21:18:46 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
21:18:46 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
21:18:46 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
21:19:05 <elliott> augur: sequenceA is the best way to understand it.
21:19:17 <elliott> augur: You can basically mechanically derive sequenceA implementations.
21:19:19 <elliott> For instance, if you have:
21:19:35 <elliott> data Foo a = Something Int | Blah a a | Bleh a (Foo a)
21:19:36 <elliott> then
21:19:59 <elliott> sequenceA (Something a) = pure (Something a); sequenceA (Blah a b) = Blah <$> a <*> b; sequenceA (Bleh a b) = Bleh <$> a <*> sequenceA b
21:20:17 <augur> ehhh
21:20:25 <elliott> It's literally just a distributive law.
21:20:38 <augur> i dont think like you, i need to see nice examples with pretty pictures :P
21:20:48 <elliott> You know sequence?
21:20:49 <elliott> :t sequence
21:20:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:21:00 <augur> i dont really understand sequence, again for the same reason
21:21:02 <elliott> It just executes all the actions in a list and collects the results.
21:21:14 <augur> ive never seen a nice explanation of it in a way i can understand
21:21:14 <elliott> sequence [getLine, getLine, getLine] :: IO [String].
21:21:26 <elliott> Which will contain three strings, from user input.
21:21:29 <elliott> Er.
21:21:33 <elliott> By "contain" I mean "return, when executed".
21:21:36 <augur> yea
21:21:41 * copumpkin slaps elliott 
21:21:45 <augur> lol
21:21:49 <augur> kinky
21:21:52 <elliott> copumpkin: I meant "the list will contain".
21:22:00 <elliott> But that turned into "the action will contain" by way of typo. :(
21:22:04 * copumpkin slaps elliott for trying to justify the abomination
21:22:12 <elliott> :'(
21:22:16 <copumpkin> preflex: seen dons
21:22:17 <preflex>  dons was last seen on #haskell 88 days, 10 hours, 8 minutes and 16 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
21:22:19 <copumpkin> wow
21:22:25 <augur> wow where is dons
21:22:30 <augur> being awesome i bet
21:22:30 <copumpkin> locked up
21:22:35 <augur> ?
21:22:38 <augur> really?
21:22:38 <byorgey> working for The Man
21:22:42 <augur> oh
21:22:45 <copumpkin> all he does now is take photos out of his office window
21:22:49 <augur> :(
21:22:57 <augur> whats he do again
21:23:04 <byorgey> works for some bank
21:23:08 <copumpkin> https://twitter.com/#!/donsbot/media/grid
21:23:13 <copumpkin> see, I'm not kidding
21:23:14 <augur> eugh
21:23:18 <byorgey> doing haskelly things, apparently
21:23:24 <elliott> preflex: xseen dons
21:23:24 <preflex>  dons was last seen on freenode/#haskell 88 days, 10 hours, 9 minutes and 24 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
21:23:28 <byorgey> but proprietary ones.
21:23:43 <augur> i like his photographs atleast!
21:23:48 <augur> mm new york :D
21:24:17 <byorgey> I was in new york by accident today
21:24:23 <augur> lol
21:24:38 <byorgey> I meant to go around it but missed the exit.
21:25:08 <augur> where in new york did you end up
21:25:09 <copumpkin> did you get out ASAP?
21:25:15 <copumpkin> you should've picked up soup dumplings
21:25:42 <elliott> byorgey: it's pretty low-profile, I can see how you'd end up in the middle of it by mistake
21:26:22 <byorgey> augur: massachusetts
21:26:36 <elliott> :D
21:26:41 <augur> ahh, the massachusetts part of new york
21:26:51 <copumpkin> yeah, I know that part quite well
21:26:57 <elliott> I ended up in Scotland, New York yesterday.
21:27:21 <djahandarie> Hmm, the Massachusetts part of New York? Is that near Los Angeles?
21:27:26 <copumpkin> I ended up in Jamaica, Boston
21:27:56 <elliott> copumpkin: Boston's part of New York, right?
21:28:01 <copumpkin> yeah
21:28:02 <augur> Jamaica is actually a part of new york you know
21:28:05 <elliott> Isn't it a suburb of Massacheusetts?
21:28:23 <liyang> New York is part of New York too I believe.
21:28:30 <copumpkin> Jamaica is also a part of Boston
21:28:31 <augur> theres a neighborhood in queens called Jamaica
21:28:43 <copumpkin> so your comment is implied by mine
21:28:47 <elliott> liyang: not since Bertrand Russell was mayor
21:29:00 <copumpkin> elliott: sounds like reflexivity to me
21:29:20 <augur> elliott: no no you're thinking of new york containing all new yorks that are not new york
21:29:31 <elliott> I knew this would happen.
21:29:39 <copumpkin> unless you're counting it as membership, I guess
21:29:39 * copumpkin slaps elliott for making this happen
21:29:51 <djahandarie> I wonder how an onlooker would gauge this conversation on the "these people must be mad" scale
21:30:17 <elliott> I've already done it, man. You can't punish me for what has already occurred. :(
21:30:47 <elliott> augur: Anyway, "all New Yorks that are not New York" is more commonly referred to as "Canada".
21:32:58 <augur> did you know that it's possible to define a "second-order" logic that is not plagued by russell's paradox?
21:33:22 <augur> but which is still powerful enough to give a lot of arithmetic?
21:33:52 <augur> the trick is to eschew actual sets
21:34:04 <augur> but to still have collective reference
21:34:46 <djahandarie> Doesn't any Hilbert system avoid Russell's paradox?
21:35:05 <augur> dunno, but isnt a hilbert system purely sentential, not even first-order?
21:35:14 <augur> so theres no quantification, nevermind quantification over sets
21:36:15 <djahandarie> Err, I said that incorrectly
21:36:38 <djahandarie> Russell's paradox applies TO Frege systems / Hilbert systems
21:36:54 <djahandarie> Both first-order logic and second-order logic should be fine
21:38:40 <djahandarie> The confusion probably comes in when things like naive set theory are formulated on top of things like first-order logic and are affected by Russell's paradox
21:41:57 <augur> i wonder whether it would be possible to have a programming language that uses plural logic
21:45:34 <augur> anyone know how i might go about trying to answer that question?
21:47:15 <elliott> TIAS
21:47:34 <augur> tias?
21:48:18 <elliott> Try It And See :p
21:48:24 <augur> lol
21:48:28 <augur> well what i mean is
21:48:39 <augur> the proof system for plural logic is the same as for second order logic
21:48:48 <augur> the model theory, however, is different
21:48:58 <augur> and thats how it avoids paradox
21:49:14 <augur> also, i guess the proof system has syntactic constraints of a sort that also do it
21:57:22 <augur> also, anyone have any suggestions on where to start approaching natural language comprehension? like, what sorts of tasks might be good initial testing areas?
21:58:06 <TSC> IRC bot? (:
21:58:11 <edwardk> statistical analysis ;)
21:58:45 <augur> edwardk: nooo i mean like, if you have a semantic theory, how you might go about doing something interesting with that in terms of natural language comprehension
21:58:51 <edwardk> =P
21:59:04 <edwardk> i know what you mean, but i felt the need to take the cheap shot =)
21:59:24 <augur> hows that a cheap shot? it's a completely different problem!
22:00:58 <edwardk> honestly i hadn't read the scrollback to the point where the specific problem you were addressing was clear
22:01:09 <augur> there is no specific problem, thats where it started :D
22:01:53 <augur> one of my profs is working on a really rather peculiar view of semantics where the "meaning" of an expression is an instruction to build a concept
22:02:39 <augur> and it has the nice advantage of not requiring that the concepts you build are unique, or even defined
22:03:13 <augur> like, expressions like "the red glorp" has a "meaning" even if there is no concept for "glorp" (as would just "glorp", of course)
22:04:10 <augur> and im sure this has uses for doing natural language comprehension, but im not quite sure how
22:04:54 <augur> possibly like if you have a system that doesn't know what everything means, but you want it to be able to manage nonetheless
22:05:54 <Utkarsh_> How do I fix this? main = map print (map read (words getLine))
22:06:12 <augur> map isnt going to return an IO ()
22:06:55 <Utkarsh_> I did mapM_ and got an error on words getLine
22:07:26 <shachaf> Utkarsh_: I recommend reading an introduction to how IO works in Haskell.
22:07:52 <shachaf> It'll probably be much better than whatever people can give you off-the-cuff here, and less work to boot.
22:07:55 <shachaf> @where faq
22:07:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:08:21 <shachaf> @google introduction to io in haskell
22:08:23 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:08:24 <lambdabot> Title: Introduction to IO - HaskellWiki
22:08:35 <shachaf> The FAQ is quite good; you should read it.
22:08:55 <Utkarsh_> ok, thanks!
22:12:12 <augur> what is this __ thing i see in http://okmij.org/ftp/Haskell/Haskell1/Haskell1.txt?
22:13:57 <liyang> Probably __ = undefined.
22:15:09 <augur> hmm
22:17:11 <dibblego> https://gist.github.com/2373889 can this be made a tad nicer?
22:17:31 <liyang> (It seems to be something I'd do if I were Oleg.)
22:18:37 <TSC> dibblego: is that unzip generalised to not-lists?
22:18:43 <shachaf> dibblego: Why make all those class methods?
22:18:44 <dibblego> TSC: yes
22:18:55 <shachaf> Also, I think that already exists by another name.
22:18:59 <dibblego> shachaf: no reason
22:19:06 <dibblego> shachaf: yes, it does, in many packages
22:19:25 <glguy> As class methods a user could optimize them to not work in terms of 2-tuples..
22:19:40 <mysticc> I was reading the stream fusion paper .. How unstream . maps f . maps g . stream removes intermediate datastructure but map f . map g .. does not .. would's map g will produce a lazy list which can be consumed by map f , If I am correct ?
22:19:44 <shachaf> dibblego: Can you come up with an equivalent of (<$>)/(<*>)?
22:20:04 <dibblego> shachaf: yes, (<*>) is derivable
22:20:09 <shachaf> mysticc: Yes, so the whole list won't be in memory at one time.
22:20:15 <shachaf> mysticc: But it still gets created.
22:20:33 <dibblego> (also vice versa from Applicative, liftA2 (,))
22:20:35 <mysticc> shachaf: Oh .. but in case of fusion .. the list itself is never created ?
22:20:47 <shachaf> mysticc: That is the goal, yes.
22:20:56 <mysticc> thanks ..
22:21:02 <dibblego> this is the same as Data.Zip.Unzip, except with the Functor constraint, which imo, doesn't belong anyway
22:21:23 <dibblego> I'm calling it -- can't be done neater
22:53:45 <ezyang> Grr, why does Traversable require a Foldable instance
22:54:10 <c_wraith> what can you traverse but not fold?
22:54:54 <ezyang> Data structures that have extra metadata in them. Granted, it might be breaking their Functorality.
22:55:15 <ezyang> but I don't think that's necessarily the case.
22:57:55 <zzing> :t ($)
22:57:56 <lambdabot> forall a b. (a -> b) -> a -> b
22:57:57 <zzing> @src ($)
22:57:58 <lambdabot> f $ x = f x
22:58:43 <zzing> Does ($) allow me to take something like norm2 (pos - c)  and change it to norm2 $ pos - c ?
22:59:05 <nand`> yes
22:59:34 <nand`> (f (a (b (c (d (e x)))))) = f $ a $ b $ c $ d $ e $ x
22:59:46 <nand`> or f . a . b . c . d . e $ x
23:01:53 <ezyang> I kind of want an applicative transformer ^.^
23:04:15 <zzing> I am getting annoyed with hmatrix and all of its typeclasses
23:04:38 <liyang> class AdditiveGroup from Conal's vector-space has a ^-^ method.
23:04:39 <zzing> My class has to have all this garbage: intersect :: (Floating b, Ord b, Product b, Container Vector b, Show b, RealOf b ~ b) => f b -> Ray b -> Maybe (Intersection b)
23:08:55 <zzing> In generated documentation what does type family RealOf x mean?
23:09:14 <glguy> Do you know what type families are?
23:09:51 <zzing> Probably not
23:10:33 <zzing> It is not in the index to real world haskell, so I have not seen it
23:10:59 <c_wraith> type families are functions from types to types.
23:11:39 <zzing> a -> b?
23:12:22 <zzing> It makes it sounds like a cast
23:12:26 <c_wraith> no
23:12:30 <c_wraith> they're just functions
23:12:45 <c_wraith> they don't convert anything.
23:13:20 <c_wraith> conversion would be a thing that happens to values
23:13:29 <c_wraith> type families are about types.
23:14:37 <dibblego> ezyang: applicative transformer as in TypeCompose?
23:14:49 <zzing> What would be an example that is easy to grasp?
23:15:39 <c_wraith> Hmm.  They're not that hard, really.  It's just annoying to build up an example, because there aren't any well-known freestanding ones.
23:16:33 <zzing> Is there a c++ analogy that can be made? For example templates are about types and metaprogramming with templates are programming with types.
23:17:22 <c_wraith> Not really.
23:17:47 <c_wraith> I guess the simplest example is something like a generic container library
23:18:13 <c_wraith> I'm going to motivate this with a type class, though it's not strictly part of what's going on.
23:18:31 <c_wraith> Let's call this a *really* primitive interface.
23:18:33 <liyang> Type families are 'functions' that take one type and give you back another type. (Not a value of one type and a value of another type.) They're type-level functions.
23:19:08 <c_wraith> class Container c where { empty :: c ; add :: e -> c -> c }
23:19:32 <c_wraith> The idea of that class is to declare a container that you can construct an empty value of, or add an element to
23:19:42 <c_wraith> The problem is that the type e in add doesn't work
23:19:53 <c_wraith> it isn't constrained to anything at all
23:20:07 <c_wraith> Which is clearly wrong - you only want to be able to add things of the right type.
23:20:35 <c_wraith> type families provide an approach for dealing with this.
23:21:20 <c_wraith> You can declare a type family, something like:  type family Element c
23:21:43 <c_wraith> Then you could change the class definition to: class Container c where { empty :: c ; add :: Element c -> c -> c }
23:22:06 <c_wraith> that says that add's first argument is whatever type *elements* of c are
23:22:08 <Veinor> what exactly is the difference between a data family and a type family?
23:22:22 <c_wraith> Veinor: injectivity - that's way off topic for an intro though :)
23:22:28 <Veinor> sure
23:22:33 <Veinor> when you're done, then? :)
23:22:38 <zzing> c_wraith, I can see this being very useful
23:22:48 <c_wraith> and you can declare instances of a type family
23:22:56 <c_wraith> so for something like this, you could do things like..
23:23:09 <c_wraith> type instance Element ([a]) = a
23:23:21 <Veinor> ... oh, i think rereading http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-families.html i understand it now anyway
23:23:34 <c_wraith> and really usefully, you can even do something like...
23:23:44 <c_wraith> type instance Element ByteString = Word8
23:24:00 <zzing> That sounds like a type alias
23:24:53 <c_wraith> Not really - aliases can't do pattern matching to determine how to resolve them
23:25:00 <Veinor> i really wish there was some kind of container class
23:25:17 <c_wraith> But that's the entire point of type families - you pattern match on the type arguments to determine the type result
23:25:23 * gdeest thinks "Type Families" should have been named "Type functions"
23:25:37 <c_wraith> gdeest: that would have been a clearer name, probably
23:25:40 <gdeest> Although correct from a mathematical point of view, this name is quite confusing
23:25:50 <zzo38> Is it ever possible to make a monad (or applicative) from Density comonad? I can think of    return = flip Density zero . const;   but then how to define join?
23:26:35 <c_wraith> zzing: So, the thing you were asking about, the full constraint was RealOf b ~ b
23:26:51 <zzo38> gdeest: OK; perhaps Ibtlfmm will call that feature "type functions" then
23:26:55 <zzing> Right, I see that thing now
23:27:00 <zzing> c_wraith, being that you seem to be one of knowledge, an aside question. I am in an unofficial online class that is involved in making a language. I have been interested in the creation of languages, and I wonder what is the leanest set of principles from Haskell's type system that would be required to be a useful type system in a basic language?
23:27:21 <zzo38> zzing: Types with parameters are very useful.
23:27:32 <zzing> zzo38, learned that from c++
23:27:55 <c_wraith> zzing: and are you familiar with the ~ constraint?  It's type equality.  That full constraint is "whatever RealOf b resolves to is the same type as b itself"
23:28:12 <zzing> c_wraith, yep had to make that work yesterday
23:28:34 <c_wraith> zzing: anyway, that's the really short version of type families.  Not actually very complicated.
23:28:59 <zzing> c_wraith, I think that skiming a lot of stuff in haskell is really simple. Its the layers that do it :P
23:29:14 <zzing> Speaking of types, how do people work with languages with little to no types? For example python.
23:29:24 <gdeest> Especially layers of monads (...)
23:29:37 <|Steve|> zzing: Python has types.
23:29:55 <gdeest> People from dynamic languages write a lot of tests, usualy.
23:30:06 <gdeest> +l
23:30:24 <c_wraith> zzing: as for the theoretical side of what's needed? I'm not one to ask there. I've learned to use a lot of tools, but I haven't really studied the theoretical connections between them
23:30:36 * BMeph thinks "type mapping" might have been nicer, FSVO "nicer". :)
23:30:53 <zzo38> There are programming languages without types; you have to use the operation according to what type you treat the memory as; such as, Forth
23:31:07 <gdeest> And yes, Python has types, but what type a given variable has at a particular point in a program is undecidable
23:31:09 <zzing> I wrote tests for my linear algebra library in C++ because I needed to verify things were working properly. but otherwise I have never written tests for anything.
23:31:46 <zzing> Anytime I tried to do graphics work in Python, the lack of a type system has always bitten me in the ass
23:31:54 <zzing> or that dynamic thing
23:31:56 <zzing> whatever it is :P
23:33:01 <liyang> Duck typing.
23:33:02 <zzing> Maybe I just use static type checking as a crutch...
23:33:17 <gdeest> It takes some time getting used to, but yeah, whenever GHC catches some stupid error for me such as using a variable instead of another one, I think to myself that it saved me 10 minutes of figuring out what was wrong.
23:33:27 <liyang> Ducks are well-known for biting people in the arse.
23:33:54 <c_wraith> Veinor: so, double-checking..  the only difference between type families and data families is that data families are injective. It's a compile error for a data family to return the same type for two different input types.
23:33:59 <gdeest> zzing: that's what Java people do with Eclipse's refactoring too ;)
23:34:02 <zzing> Like the lack of type checking on template parameters in C++ (I want concepts!)
23:34:47 <Veinor> c_wraith: ah, ok
23:35:16 <c_wraith> Veinor: I was sort of surprised to find out that was the only difference at all :)
23:36:21 <gdeest> Does someone know of an automatic way to escape special characters for inclusion in a regular expression ?
23:41:54 <zzing> gdeest, I would say when I have a function that is about twenty lines (intersection of a line and a sphere) it can be difficult to get it right with all of the types :-).
23:46:02 <zzing> Why does ghc say "Could not deduce (Floating e) arising from a use of `sqrt'" when it is the *only* way that it would be valid?
23:46:57 <BMeph> zzing: The issue is, you're trying to use 'sqrt' on something that it doesn't know is a Floating type. :)
23:47:34 <zzing> Can't it infer that it is, because there no other thing that makes sense?
23:47:36 <c_wraith> zzing: it's telling you that if you're going to specify a type signature, you really need to put the class constraints in it too
23:47:56 <c_wraith> zzing: that error message only happens when you specify the type but don't include a necessary constraint
23:48:03 <zzing> ok
23:48:16 <c_wraith> zzing: which is the compiler telling you "I can't make the function as general as you claim - I need this constraint"
23:48:36 <zzing> I need an -XInferForMe
23:48:52 <c_wraith> -Wall will do it, if you leave off the signature entirely
23:49:08 <Veinor> you can also load it in ghci and do :t function
23:51:07 <zzing> Can this be made simpler?    > normal (Sphere c _) p = scale ((/) 1 $ sqrt $ pc <.> pc) pc    where pc = p `sub` c
23:52:04 <c_wraith> (/) 1  is the same as (1 /)
23:52:17 <zzing> ok
23:52:25 <c_wraith> I'm not sure what <.> is
23:52:29 <c_wraith> dot product?
23:52:30 <zzing> dot product
23:52:43 <zzing> I just found the operator so I am using it instead of `dot`
23:53:34 <gdeest> zzing: what is your "line" datatype ?
23:53:49 <zzing> > data Ray a = Ray (Vector a) (Vector a)
23:53:50 <lambdabot>   <no location info>: parse error on input `data'
23:54:02 <gdeest> I would say this function is quite easy to write if you have a point and a vector
23:54:16 <gdeest> that seems to be what you have (writing a raytracer ? :) )
23:54:34 <zzing> gdeest, converting my c++ ray caster
23:55:39 <gdeest> to me, it looks like it's just a matter of solving a second degree equation
23:55:43 <gdeest> no ?
23:55:46 <zzing> https://gist.github.com/3ecbee332ed732c69b0a <-- line 21 to 43 shows the ugly of my intersection function in all its glory for the sphere.
23:56:03 <zzing> gdeest, It is a quadratic for the most part
23:56:17 <zzing> My notes are not present, so there is a thing missing
23:56:28 <zzing> I am fixing the 'theta' parameter right now
23:56:42 <zzing> I want to make my intersection function pretty
23:56:50 <zzing> 20 lines seems excessive
23:57:17 <gdeest> And you're solving for t right ?
23:57:23 <zzing> yes
23:57:50 <zzing> intersect is >    intersect :: (Floating b, Ord b, Product b, Container Vector b, Show b, RealOf b ~ b) => f b -> Ray b -> Maybe
23:58:18 <zzing> My mind isn't thinking in math right now, so it is taking four times longer to think this through
23:58:44 <gdeest> Maybe of what ?
23:58:56 <zzing> oops
23:58:59 <zzing> Maybe Intersection
23:59:04 <gdeest> OK :)
23:59:05 <zzing> (Intersection b)
23:59:10 <zzing> > data Intersection a = Intersection (Vector a) a
23:59:10 <lambdabot>   <no location info>: parse error on input `data'
23:59:14 <zzing> An Intersection represents a location and an angle.
23:59:25 <gdeest> What if you have more than one intersection ?
23:59:34 <zzing> It returns the closest
23:59:37 <gdeest> do you only care about the first one ?
23:59:38 <gdeest> Ok
23:59:39 <zzing> yes
23:59:47 <zzing> Otherwise it is obscured
