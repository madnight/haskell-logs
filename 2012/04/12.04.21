00:02:37 <qnikst> gdoteof: http://paste.pocoo.org/show/585073/
00:02:45 <qnikst> just fix types for you one
00:03:26 <qnikst> concatMapAccumL needed :)
00:07:14 <gdoteof> qnikst: that makes my head hurt.
00:09:18 <hpaste_> Enigmagic annotated “Handler/Meta.hs” with “Handler/Meta.hs (annotation)” at http://hpaste.org/67373#a67374
00:09:55 <Enigmagic> gdoteof: there's one that just does it recursively
00:12:10 <qnikst> gdoteof: where is the problem?
00:13:48 <qnikst> i can add another variant w/o concatting, that will look more straitforvard
00:14:13 <qnikst> ops it was done by Enigmagic
00:15:34 <gdoteof> I can grok Enigmagic's
00:24:12 <gdoteof> thanks for the help I really appreciate it.
00:31:13 <qnikst> hm.. mongoDB driver itself works
00:34:30 <Enigmagic> gdoteof: np
00:41:45 <wli> Hmm, sum(i,j,k | i,j,k >= 0, i+j+k==n) trinomial(n,i,j,k) f(i+j) g(j+k) is a little awkward.
00:59:53 <adamt> do you really have to import Data.List to use head?
01:01:20 <c_wraith> @hoogle head
01:01:21 <lambdabot> Prelude head :: [a] -> a
01:01:21 <lambdabot> Data.List head :: [a] -> a
01:01:21 <lambdabot> Network.HTTP.Base HEAD :: RequestMethod
01:01:27 <shachaf> Unfortunately not.
01:01:29 <c_wraith> looks like it's in the Prelude, too
01:02:02 <shachaf> head is a specialized "know what you're doing" function; it probably should be in a module.
01:02:10 <adamt> and the Prelude is always imported?
01:04:45 <adamt> Apparently not.
01:41:59 <srhb> I'm confused. How do I make my type Maze = [[MazeElement]] while still being able to declare my own instance of Show?
01:43:15 <bitonic> srhb: the short answer is that you should define a new type alltogether
01:43:42 <bitonic> you can provide an instance of Show for [[MazeElement]] with FlexibleInstances
01:43:58 <bitonic> but if MazeElement is an instance of Show itself, then you'll need OverlappingInstances as well
01:44:17 <bitonic> (because you have already instance Show a => [a], and thus Show a => [[a]])
01:44:49 <bitonic> srhb: so, the quick solution is, define a 'newtype Maze = Maze [[MazeElement]]'
01:45:22 <qnikst> btw, i've head it's a good way to use read/show for exporting data to code
01:45:37 <bitonic> qnikst: what do you mean with "exporting data to code"?
01:45:52 <srhb> Yeah, okay, but how do I make Maze a type in itself then? Hmm.
01:46:09 <bitonic> srhb: newtype, see my last message
01:46:31 <bitonic> qnikst: if you mean serializing som haskell data structure to a file and then reading it back, it depends. read/show are slow.
01:46:42 <srhb> bitonic: Yes, but that's the one that does not allow me to implement show myself, right?
01:46:46 <bitonic> they do have the advantage of being plain text, so if you don't need performance they are allright
01:46:57 <bitonic> srhb: of course it does, 'instance Show Maze where...'
01:47:26 <srhb> bitonic: Oh, it does.. I must have typoed before without noticing it. Thanks!
01:47:27 <qnikst> bitonic: I mean  read . show == id
01:47:44 <bitonic> qnikst: well yeah that should hold.
01:47:52 <qnikst> and for displaying data to user use some other functions
01:48:17 <shachaf> read . show === id isn't a guarantee structurally.
01:48:24 <bitonic> I'm not sure what you're asking (if you're even asking something :P)
01:48:32 <qnikst> i.e. if show maze will show a pretty text picture, that this is not fully correct
01:48:39 <shachaf> Although maybe read (show x) == x is, but that's introducing yet another type class.
01:49:13 <bitonic> qnikst: oh, right, I see what you mean. srhb might not need 'read' at all
01:49:21 <bitonic> and he can break that informal law
01:50:06 <shachaf> You know, there exist functions other than Show that have type x -> String for some type x.
01:50:16 <bitonic> that's true as well
01:50:43 <bitonic> srhb: you could simply have a 'prettyMaze :: Maze -> String', as shachaf suggests
01:50:57 <srhb> Of course. :)
01:51:06 <srhb> I can't decide which is best. Might not really matter.
01:57:28 <jaspervdj> verement_: What's your engine?
02:00:31 <abhiranjanlost> hi all
02:01:01 <abhiranjanlost> i had been trying to increase the stack size for a haskell program
02:01:14 <abhiranjanlost> with +RTS -K256 -RTS option
02:01:41 <abhiranjanlost> but it yeilds the error "Most RTS options are disabled. Link with -rtsopts to enable them."
02:03:05 <qnikst> is it cabalized?
02:05:14 <abhiranjanlost> @qniskst sorry i can get you
02:05:14 <lambdabot> Unknown command, try @list
02:05:23 <abhiranjanlost> #qniskst sorry i can get you
02:05:42 * hackagebot lifted-base 0.1.0.4 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1.0.4 (BasVanDijk)
02:06:16 <qnikst> do you use cabal or not?
02:06:46 <qnikst> anyway you should add -rtsopts option to build string either by ghc -rtopts file.hs
02:06:58 <qnikst> or by Ghc-options (afaik) in cabal file
02:08:14 <abhiranjanlost> yes i had been compiling it with "ghc -rtsopts file.hs"
02:08:45 <abhiranjanlost> and then executing it by "./file +RTS -K256M -RTS"
02:09:26 <abhiranjanlost> sorry, -K256m, which leads to error
02:09:31 <abhiranjanlost> "perfect: Most RTS options are disabled. Link with -rtsopts to enable them."
02:14:03 <abhiranjanlost> my file name is perfect.hs
02:15:26 <qnikst> http://paste.pocoo.org/show/585097/ strange
02:19:16 <abhiranjanlost> http://paste.pocoo.org/show/585100/ yes
02:20:36 <qnikst> try to delete file, and rebuild (there was --fforce option)
02:20:47 <qnikst> otherwise i give up
02:22:15 <abhiranjanlost> http://ideone.com/xMMWc
02:22:57 <abhiranjanlost> even codeforces.com can't provide 256MB, though they mentioned that they can
02:24:44 <abhiranjanlost> my ghc version is 7.0.3
02:32:43 <abhiranjanlost> deleting all other files, and then rebuilding it helps
02:45:43 * hackagebot hbro 0.9.0.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.9.0.0 (koral)
02:50:44 * hackagebot hbro-contrib 0.9.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-0.9.0.0 (koral)
02:54:52 <Wooga> hi, can someone recommend good haskell IDE?
02:55:07 <Wooga> with indentaion powers of Emacs and completion powers of Leksah
02:55:30 <Wooga> or maybe a way to tune Emacs or Leksah to gain each other advantages
03:20:06 <donri> Wooga: maybe ghc-mod for emacs, then
03:22:37 <Wooga> donri: looks prommising. thank you!
03:31:59 <TheLemonMan> whats the definition of a strict state thread ?
03:36:03 <notthemessiah> TheLemonMan: you mean this? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
03:36:03 <lambdabot> notthemessiah: You have 1 new message. '/msg lambdabot @messages' to read it.
03:37:35 <TheLemonMan> notthemessiah: yep, i dont get whats a possible case of use
03:38:19 <TheLemonMan> from what i got it introduces mutable objects while retaining the purity
03:43:02 <srhb> TheLemonMan: I used it to parse some binary files recently..
03:47:46 <srhb> TheLemonMan: Perhaps this helps http://www.haskell.org/haskellwiki/Monad/ST
03:48:04 <TheLemonMan> srhb: whats the advantage over pure code ?
03:48:15 <TheLemonMan> i just see it as a way to write imperative-ish haskell
03:48:54 <jhibberd> Hello. Could anyone tell me how to check whether a type (a) is a function (eg a -> a, or a -> a -> a) or just a primitive (eg a)?
03:49:32 <jhibberd> (I'm fairly new to Haskell)
03:51:01 <srhb> TheLemonMan: That page explains some of the benefits. :)
03:51:21 <notthemessiah> in ghci you use this command: "Prelude> :t foo"
03:51:25 <srhb> jhibberd: What do you mean "type check". Do you want to know how Haskell internally does it?
03:52:04 <srhb> jhibberd: What notthemessiah said is probably what you want, that's called printing the type signature.
03:52:42 <jhibberd> Inside a function that takes a value of type "a" I'd like to apply "x" to "a" if "a" happens to be a function, otherwise just return "a" if it isn't (eg if it's an Int).
03:53:29 <jhibberd> "a" is a dynamic type (Data.Dynamic)
03:54:13 <srhb> jhibberd: If you really are new to Haskell, the answer is probably "you're doing it wrong" :-)
03:54:55 <jhibberd> :) yeah that did occur to me - but was just curious to see if there was a way.
03:55:10 <srhb> jhibberd: There is, you can use fromDyn and a case to pattern match on the types you need
03:56:51 <jhibberd> srhb: How would you express a generic function as a pattern match? (Just x) and Nothing would match Maybe a but what would you use for "any kind of function"?
03:57:23 <srhb> jhibberd: Any kind of function wouldn't be doable without some extensions I believe. I'm not sure even then if it is possible.
03:57:31 <srhb> (ie. it's over my head)
03:57:57 <notthemessiah> possibly something along the lines of starting with data declarations? http://en.wikibooks.org/wiki/Haskell/Type_declarations
03:58:09 <jhibberd> srhb: Fair enough - thanks anyway
03:59:15 <srhb> jhibberd: Probably a good question for StackOverflow though. Even if people will yell at you. :-)
04:00:20 <jhibberd> srhb: I'll post now and see what happens.
04:01:35 <fmap> > typeOf ((+1))
04:01:36 <lambdabot>   Integer -> Integer
04:45:59 * hackagebot HFuse 0.2.4.1 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4.1 (PaulVanDerWalt)
04:51:01 * hackagebot blaze-markup 0.5.1.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.0 (JasperVanDerJeugt)
04:55:59 * hackagebot dotfs 0.1.1 - Filesystem to manage and parse dotfiles  http://hackage.haskell.org/package/dotfs-0.1.1 (PaulVanDerWalt)
04:56:01 * hackagebot blaze-html 0.5.0.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.5.0.0 (JasperVanDerJeugt)
05:00:59 * hackagebot snap-blaze 0.2.0.0 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.2.0.0 (JasperVanDerJeugt)
05:05:59 * hackagebot digestive-functors-blaze 0.3.0.2 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.3.0.2 (JasperVanDerJeugt)
05:16:00 * hackagebot libmpd 0.8.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.8.0 (JoachimFasting)
05:25:19 <Peaker> Is Ross Paterson still in charge of hackage passwords?
05:26:00 * hackagebot dotfs 0.1.1.1 - Filesystem to manage and parse dotfiles  http://hackage.haskell.org/package/dotfs-0.1.1.1 (PaulVanDerWalt)
05:31:00 * hackagebot dotfs 0.1.1.2 - Filesystem to manage and parse dotfiles  http://hackage.haskell.org/package/dotfs-0.1.1.2 (PaulVanDerWalt)
05:38:54 <ppilate> Hi
05:39:45 <byorgey> hi ppilate
05:46:01 * hackagebot dotfs 0.1.1.3 - Filesystem to manage and parse dotfiles  http://hackage.haskell.org/package/dotfs-0.1.1.3 (PaulVanDerWalt)
05:51:06 <iorivur> Is Int in Haskell is 30bit-length?
05:53:24 <luite> iorivur: depends on the compiler and platform, in ghc it's 32 or 64 bit
05:54:16 <iorivur> luite: Thanks. I'm using ghc and ghci.
05:54:39 <luite> iorivur: try maxBound :: Int
05:54:44 <luite> and minBound
05:54:48 <luite> > maxBound :: Int
05:54:49 <lambdabot>   9223372036854775807
05:55:02 <luite> looks like lambdabot is running on 64 bit
05:56:34 <iorivur> Thanks, my result is similar.
05:57:15 <Fishmanthing> hello
05:57:58 <Fishmanthing> what can I use if I have my own class, but I want to make an instance of it on lets say Char
05:58:36 <Fishmanthing> I did this by making a new data constructor wich masks char
05:58:51 <Fishmanthing> but I think there has to be some other way
06:02:31 <fmap> Fishmanthing: instance Class Char
06:03:06 <Fishmanthing> I didn't think that would, work, thank you :D
06:03:56 <Fishmanthing> fmap++
06:06:57 <Fishmanthing> fmap: But will that affect every Char, not just the ones in this module, but also other modules who use that one? Can I somehow evade that?
06:10:39 <fmap> Fishmanthing: Yes, it will affect every Char in modules where you import this one. You can't evade this behaviour, instances are always exported (and imported).
06:11:01 * hackagebot arrow-list 0.6 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.6 (SebastiaanVisser)
06:11:43 <Fishmanthing> fmap: So that means I have to go back to something like Data CharEncapsulate = CharEncapsulate { stuff :: char }
06:15:44 <fmap> Fishmanthing: Yes. You don't need separate data though, newtype will be enough.
06:16:03 * hackagebot xmlhtml 0.2.0 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.0 (JasperVanDerJeugt)
06:18:22 <Fishmanthing> fmap: Thank you! That was what I was looking for. I tried with type, but that didn't work, and I didn't know about newtype.
06:18:24 <Fishmanthing> fmap++
06:25:04 <osa1> I have a web server and I didn't use any web frameworks, I only used sockets. and now I need to use some kind of database to persist some data but I don't know much about relational databases and SQL, what's the easiest way to do that in haskell? when I do it in python, I'm using ORM's that don't expect from me to write SQL
06:25:39 <Clint> haskelldb except for the lack of documentation
06:26:54 <hemmie> hi room, quick question about cabal; I ran cabal update for the first time in a while just now, and it just output the line "Downloading the latest package list from hackage.haskell.org"... does that mean everything went ok or do I need to use a different command to update all packages? I can't find any useful info by using cabal --help...
06:27:05 <osa1> Clint: I may be in need of a good documentation since I don't know much about databases
06:31:01 <hemmie> or is it that cabal update just fetches the latest list, and you have to update each installed package manually?
06:32:54 <fmap> hemmie: cabal update doesn't update packages, it updates package list
06:33:47 <hemmie> fmap: thanks, so is there a command to update all installed packages? or is that not recommended?
06:39:51 <byorgey> hemmie: there is 'cabal install world' but it is not recommended.
06:40:10 <byorgey> hemmie: because there is no guarantee that the latest versions of all installed packages will all be compatible.
06:40:47 <hemmie> byorgey: ok, sounds reasonable, thanks :-)
06:59:45 <`Jake`> If I code a short program in Java, and I use Java as if it was Haskell, is that good or bad?
07:02:09 <byorgey> `Jake`: it depends.  hypothetically, are you going to code it on a Tuesday?
07:02:20 <`Jake`> no, on a saturday
07:02:27 <`Jake`> like, right now
07:02:49 <`Jake`> and I just forgot to use variables
07:04:46 <Philippa_> Did you remember the semicolons?
07:05:05 <Philippa_> (I goofed that way when I dug out C++ for one of the ICFP contests, wrote 50+ lines and hit compile...)
07:05:17 <`Jake`> Yes, I did
07:05:27 <`Jake`> fortunately
07:08:13 <byorgey> well, as long as no compilers were harmed I'd say it's a good thing
07:09:08 <`Jake`> cool
07:09:24 <Philippa_> Eh, I'm with the Erlangers on that one - let it crash!
07:14:21 <luffy_> Hi everyone. I am using Windows 7, and trying to install Atomo using cabal, but get the following error: http://paste.pocoo.org/show/585211/. Can somebody please help?
07:15:33 <luffy_> here is the verbose  output: http://paste.pocoo.org/show/585212/
07:16:45 <dcoutts_> luffy_: take a look at the error message, it suggests --extra-lib-dirs= and --extra-include-dirs=
07:17:13 <dcoutts_> you're using --extra-include-dirs= only and pointing to the lib dir, when you probably need to point it to the corresponding include dir
07:17:17 <byorgey> luffy_: is there an  \include subdirectory in C:\Program Files\pcre-7.
07:17:22 <byorgey> 0-bin?
07:17:39 <luffy_> byorgey: yes. there is include and bin.
07:17:45 <luffy_> dcoutts_: trying. thanks.
07:17:51 <byorgey> if so you should probably pass that to --extra-include-dirs, and pass the bin subdir to --extra-lib-dirs
07:18:10 <byorgey> I mean the lib subdir
07:19:10 <luffy_> byorgey: ok, trying that.
07:19:54 <luffy_> byorgey: re: 0-bin, that's part of line above. the reason for that newline in the paste is the limited width of my windows console.
07:21:07 <luffy_> :( http://paste.pocoo.org/show/585213/
07:25:35 <Wooga> hi, what would be an Eta reduction of (\x y -> length x `compare` length y) ?
07:26:04 <parcs`> compare `on` length
07:26:10 <Wooga> thanks
07:26:15 <luffy_> or comparing length. parcs' is more general.
07:26:15 <parcs`> or comparing length
07:26:24 <rwbarton> that is not an eta reduction though
07:26:27 <luffy_> and i am not sure that can be called eta reduction
07:26:31 <rwbarton> there is no eta reduction of that term
07:26:34 <luffy_> it's pointfree style
07:26:40 <parcs`> i assumed Wooga meant pointfree
07:26:48 <Wooga> well, Hlint thinks there Eta reduction is possible
07:27:23 <luffy_> http://paste.pocoo.org/show/585213/ Can anyone please help me with this? ):
07:27:25 <rwbarton> no, it doesn't. http://hpaste.org/67379
07:28:25 <dmwit> gdoteof_: Without even reading the code I can just apologize right now.
07:28:28 <dmwit> I was a bit grumpy last night.
07:29:45 <rwbarton> luffy_: install the Missing C library: pcre
07:29:56 <rwbarton> I see you are on windows, so I have no idea how you do this.
07:30:07 <Wooga> ah, sorry
07:30:12 <Wooga> was confused by my IDE
07:30:25 <Wooga> real expression producign Eta reduce error was: http://hpaste.org/67380
07:30:47 <rwbarton> yes
07:31:03 <rwbarton> there you have "f l = (...) l" so you can simplify to "f = (...)"
07:32:05 <byorgey> luffy_: no, pass --extra-include-dirs="C:\Program Files\pcre-7.0-bin\include" and --extra-lib-dirs="C:\Program Files\pcre-7.0-bin\lib"
07:32:19 <byorgey> you are passing \lib to include and \bin to lib =P
07:33:17 <rwbarton> ... oh.
07:33:20 <rwbarton> windows, you so silly!
07:33:44 <luffy_> ah! trying. thanks.
07:35:30 <reinoud> can someone give me a pointer to some tutorial or some other reference to using modifyable arrays in Haskell?
07:35:33 <luffy_> didnt work. i get the same error again.
07:35:45 <luffy_> it seems i am not going to be able to give atomo a whirl after all. :(
07:36:00 <raboof> Hi, I'm pretty new to haskell and trying to write a small gui app
07:36:33 <raboof> I have a TreeView witch is properly populated, but now I want to update its value set
07:36:38 <raboof> should I be using treeViewSetModel for that ?
07:36:46 <raboof> (I'm using using gtk2hs)
07:37:35 <luffy_> what does eta reduction mean anyway? reducing points?
07:39:13 <byorgey> luffy_: if you have f x = g y w x, it can be eta-reduced to  f = g y w
07:39:33 <luffy_> byorgey: so reducing points, essentially?
07:39:37 <byorgey> that is, in general, if  f x = g x  then f = g
07:39:42 <jgr> luffy_: basicly removing lambda-bindings
07:39:44 <byorgey> where f and g can be arbitrary expressions
07:39:52 <byorgey> luffy_: sure
07:39:58 <jonkri> what does it mean when the same constructor is used to the left and to the right of the equal sign in a newtype declaration, like "newtype MyType = MyType String"? how can that compile, since MyType sort of means two different things, "MyType" and "MyType a"
07:40:01 <luffy_> jgr, byorgey: ok, understood. thanks!
07:40:17 <byorgey> I guess more fundamentally, eta-reduction transforms  \x -> f x  into  f
07:40:34 <byorgey> and note that  g x = ...  is just syntax sugar for  g = \x -> ...
07:41:00 <byorgey> jonkri: they are two different things, inhabiting two different namespaces
07:41:20 <jgr> luffy_: but mind that there is no fundamental need to do eta-reductions by hand
07:41:22 <byorgey> the MyType on the left of the = is a type.  The MyType on the right of the = is a data constructor.
07:41:57 <byorgey> it will always be inferrable from the context which MyType is being referred to, because types and data constructors can't be used in the same places
07:42:11 <byorgey> (unless you turn on DataKinds =)
07:42:20 <luffy_> jgr: i tend to prefer pointfree style anyway (:
07:42:32 <jonkri> byorgey, wonderful explanation :) thank you!
07:42:41 <jgr> luffy_: yet hlint often eta-reduced for you.
07:42:52 <jgr> *reduces, sry
07:44:58 <jgr> luffy_: btw, i just googled "eta reduction" and the first hit says all you need to know :)
07:45:28 <luffy_> jgr: yeah i just needed to confirm it, because an earlier discussion here had me slightly confused :)
07:46:13 <jgr> luffy_: yeah. all those lamdba calculus reduction types and their purposes can be kind of confusing at first
07:46:57 <jgr> still, eta-reductions are very well handled by hlint, in contrast to most of the others
07:47:27 <jgr> so you basicly do not need to bother about them, just run hlint when done :)
07:49:16 <byorgey> one thing that may be confusing is that eta-reduction is actually a more general concept than just thinking about function arguments.  Basically you can have a notion of eta-expansion and -reduction for any type former.
07:49:23 <byorgey> what we have been talking about is eta-reduction for (->)
07:49:56 <byorgey> but you can also have eta-reduction for pairs, or for Either, etc.
07:50:14 <byorgey> but those don't really come up as much in the context of Haskell.
07:50:26 <jgr> byorgey: yet those are a little less usual to come across when coding.
07:50:32 <jgr> hehe
07:51:04 <byorgey> yeah, and actually I just realized they are not even valid in the context of lazy evaluation
07:51:05 * hackagebot bumper 0.5 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5 (ErikHesselink)
07:51:19 <adnauseam> is guard equal to | ?
07:51:23 <byorgey> e.g. eta-reduction for pairs says that  (fst p, snd p) = p
07:51:28 <jgr> adnauseam: no
07:52:01 <byorgey> but that's not true in Haskell if e.g. p = undefined
07:52:20 <jgr> or (a,b,c) :)
07:52:45 <byorgey> jgr: well, you have to specify that both sides are well-typed.  that's true even for the function version.
07:53:02 <byorgey> e.g.  \x -> f x  is not equal to f  when f = Just 6  =)
07:53:40 <byorgey> adnauseam: I don't understand your question.
07:53:43 <jgr> adnauseam: yet, both things are called the same, "guard" is a function belonging to the monad you're using and | is a way of more precise function denotatin.
07:54:07 <byorgey> but stuff that comes after | in a function declaration is *called* a guard.
07:54:09 <adnauseam> guard (c' `elem` [1..8] && r' `elem` [1..8]) == | (c' `elem` [1..8] && r' `elem` [1..8]) ?
07:54:30 <adnauseam> *rubs his chin*
07:54:31 <byorgey> adnauseam: ah, ok. no. the second does not make sense.
07:54:32 <jgr> adnauseam: no, as i said
07:54:42 <byorgey> | is syntax, not a function
07:54:46 <adnauseam> i'll go and re-read monads
07:54:55 <adnauseam> thanks <3
07:55:06 <jgr> adnauseam: like i said before, guard is a monadplus-instance function, whereas | is syntactic sugar
07:55:23 <adnauseam> what's the importance of syntactic sugar ?
07:55:26 <adnauseam> it sounds useless o_0
07:55:29 <jgr> adnauseam: yet do not nail me on monadPlus, im not sure
07:55:37 <jgr> adnauseam: to make your code more readable
07:55:37 <adnauseam> jgr, don't worry man
07:55:41 <byorgey> @type guard
07:55:42 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:55:50 <byorgey> I don't think guard is actually in the MonadPlus class though
07:56:01 <jgr> byorgey: ah, great, thanks. now i'm reassured ;)
07:56:01 <byorgey> it's just defined in terms of the MonadPlus methods
07:56:11 <sipa> adnauseam: C is barely more than syntactic sugar for assembly; does that make it useless?
07:56:26 <jgr> byorgey: yeah, it relies on monadPlus, but isn't defined there.
07:56:26 <adnauseam> sipa: i see your point
07:57:04 <jgr> adnauseam: as in: f a b = a*b is syntactic sugar for:
07:57:15 <jgr> f = \x -> \y -> x * y
07:57:21 <jgr> which one is more readable?
07:57:56 <adnauseam> jgr i'm having ahard time decide since i can read both :/
07:58:02 <adnauseam> i am a haskell noob though :/
07:58:15 <adnauseam> so i'm over thinking
07:58:53 <jgr> adnauseam: okay... then a more complex one. what is the meaning of [(a,b) | a <- [1..10], b <- [5..]]?
07:59:39 <jgr> list comprehensions are basicly syntactic sugar for some list monad constructs. but they are way more readable.
08:00:04 <adnauseam> a list comphrension giving a list of tuples (a,b) where a takes 1..10, and b takes 5.., where as since a is limited, i'm guessing it stops at 5+10 ?
08:00:13 <jgr> byorgey: does lambdabot know how to beta-reduce that to binds?
08:00:17 <hpaste_> bro pasted “mo” at http://hpaste.org/67383
08:00:19 <adnauseam> jgr; i see your point
08:00:40 <adnauseam> 5+9*
08:01:08 <jgr> adnauseam: yeah. i should have been more specific. i didn't mean the semantic meaning, i meant the syntacic meaning.
08:01:19 <adnauseam> syntatic meaning ?:o
08:01:23 <adnauseam> syntactic*
08:01:31 <jgr> adnauseam: like, what it can be beta-reduced to.
08:01:32 <adnauseam> what i gave was only semantic ?
08:01:39 <adnauseam> oh, i've no idea then o_0
08:01:51 <jgr> adnauseam: yeah, you said how you expect it to behave
08:01:57 <adnauseam> oh
08:01:58 <jgr> thats semantics
08:02:02 <adnauseam> :o
08:02:26 <adnauseam> so a list comprehension is actually a monad ?
08:02:26 <jgr> yet syntax is how it is written down, simplyfied.
08:02:31 <fmap> adnauseam: btw this comprehension won't stop
08:02:45 <adnauseam> fmap: even when a stops ?
08:02:49 <adnauseam> oh wait...
08:02:52 <jgr> adnauseam: a list comprehension is syntactic sugar for some binds in the list monad
08:02:55 <adnauseam> yeah.. now isee that it won't
08:03:07 <sipa> [(a,b) | a <- [1..10], b <- [5..]] is the same as do { a <- [1..10]; b <- [5..]; return (a,b) }
08:03:26 <ClaudiusMaximus> is there a way to exclude packages from +RTS -p -RTS profiling output? it's giving me way too much spam to deal with sensibly - looking at +RTS -? -RTS tells me no (there is something for heap profiling mentioned though) - should i just grep -v on the .prof file?
08:03:27 <jgr> sipa: yet do-notation is syntactic sugar, too
08:03:34 <adnauseam> [(1,5),(1,6),(1,oo)[
08:03:38 <adnauseam> [(1,5),(1,6),(1,oo)] :o
08:03:38 <sipa> jgr: let's go on
08:04:04 <sipa> [1..10] >>= (\a -> [5..] >>= \b -> return (a,b))
08:04:16 <jgr> sipa: you were faster. :)
08:04:31 <jgr> so, adnauseam, do you see the difference?
08:04:35 <jgr> 17:03:42 < sipa> [1..10] >>= (\a -> [5..] >>= \b -> return (a,b))
08:04:42 <jgr> 17:02:45 < sipa> [(a,b) | a <- [1..10], b <- [5..]]
08:04:44 <adnauseam> yes :o
08:04:46 <jgr> which one is easier?
08:04:47 <sipa> adnauseam: now compare [(a,b) | a <- [1..10], b <- [5..]]     with     [1..10] >>= (\a -> [5..] >>= (\b -> return (a,b)))
08:05:41 <adnauseam> yeah
08:05:51 <adnauseam> the second one is less readable since i dont get monads just yet
08:05:55 <adnauseam> :/
08:06:03 <mekeor> why is "main :: IO ()" and not "main :: [String] -> IO ()" ?
08:06:29 <`Jake`> Well, you can use getArgs to get arguments
08:06:30 <ion> mekeor: Don’t you mean [String] -> [String] -> IO ()?
08:06:36 <mekeor> `Jake`: of course.
08:06:46 <mekeor> ion: erm, why?
08:06:58 <mekeor> what are those lists?
08:07:13 <mekeor> i meant command-line arguments..
08:08:36 <ion> mekeor: int main (argc, char **argv, char **env)
08:08:58 <mekeor> ah. i never used char **env...
08:09:09 <mekeor> but anyway, yes, why?
08:10:09 <ion> Are you sure that style reflects all systems Haskell code is going to run on? Wouldn’t it be better to abstract it?
08:10:29 <mekeor> ion: idk. that's why i'm asking ;)
08:11:09 <mekeor> ion: so, abstraction is one advatage of :: IO (). alright. that's enough. gotta go, sry =)  cya
08:11:23 <`Jake`> ion:  here's a discussion about this topic: http://www.haskell.org/pipermail/haskell/2004-March/013847.html
08:11:23 <donri> main = getArgs >>= argumentativeMain
08:12:22 <ion> main = join (liftA2 argumentativeEnvironmentfulMain getArgs getEnvironment)
08:12:56 <donri> mekeor: i think the point is that there's more than the arguments you could possibly pass in, so to be consistent you'd need to do all (arguments, program name, environment variables...)
08:13:03 <ion> main = join (liftA2 argumentativeEnvironmentfulMainWithZerothArgumentAlso (liftA2 (:) getProgName getArgs) getEnvironment)
08:13:45 <donri> mekeor: it's more natural to have them be IO actions
08:17:47 <bobfang> say I have a rational number 2%3 how can i extract it to a any precision number like 0.66666666666666
08:17:50 <bobfang> thanks
08:18:30 <sipa> > (fromRational $ 2%3) :: Double
08:18:31 <lambdabot>   0.6666666666666666
08:18:31 <ion> > showCReal 1000 (2/3)
08:18:32 <lambdabot>   "0.666666666666666666666666666666666666666666666666666666666666666666666666...
08:18:51 <sipa> > (fromRational $ 2%3) :: CReal
08:18:52 <lambdabot>   0.6666666666666666666666666666666666666667
08:19:12 <donri> @hoogle Rational -> Double
08:19:12 <fmap> > realToFrac (2%3) :: Double
08:19:12 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
08:19:12 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
08:19:12 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
08:19:12 <lambdabot>   0.6666666666666666
08:19:32 <bobfang> sorry but what does $ mean here
08:19:39 <ion> f $ x = f x
08:19:46 <bobfang> oh ok thanks
08:20:04 <ion> Ignore it, its use above is not pretty. :-P
08:21:02 <sipa> I beg to differ!
08:21:06 * hackagebot snap-core 0.8.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.8.1 (GregoryCollins)
08:21:09 * hackagebot snap-server 0.8.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.8.1 (GregoryCollins)
08:21:11 * hackagebot snap 0.8.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.8.1 (GregoryCollins)
08:21:12 <merijn> bobfang: Do you want fixed precision or not? The above examples all return Double which is usally bad
08:21:35 <ion> Not mine. :-P
08:21:38 <bobfang> no I want any precision
08:22:01 <merijn> What does "any precision" mean? infinite?
08:22:29 <donri> there isn't any precision in that statement
08:22:32 <bobfang> it means if I want 1000, I get 1000... if i want 1000 million, I get 1000 million bit
08:22:35 <ion> Mine returned it to the precision of 1000 digits.
08:22:47 <sipa> bobfang: the word you look for is "arbitrary precision"
08:22:56 <bobfang> oh yeah
08:22:58 <bobfang> right
08:23:05 <merijn> Right
08:23:12 <merijn> Then Double is your enemy
08:23:16 <merijn> Avoid it like the plague
08:23:20 <bobfang> yep
08:23:31 <merijn> (I don't know the type you do want, unfortunately)
08:23:44 <ion> See above.
08:23:50 <bobfang> I tried CReal but it does not work
08:25:49 <donri> don't you want to stay in Rational?
08:26:44 <bobfang> yeah I want stay in Rational but when I print it out I want it like a number, not 2%3 but 0.666666666666666....
08:28:02 <donri> printf?
08:28:43 <Philippa> so I've decided that I really don't think the existential antipattern is an antipattern. Why? Coherence
08:29:04 * heatsink looks up existential antipatterns
08:29:35 <Philippa> it can be summed up "don't use existentials with typeclasses when you can pass a record around instead"
08:29:44 <heatsink> I see
08:29:53 <heatsink> I found an example
08:30:10 <heatsink> And the record method seems more natural to me
08:30:18 <heatsink> What do you mean by coherence?
08:30:22 <Philippa> mmm. But what it doesn't do is let you check that two values used the same record
08:30:35 <merijn> bobfang: Just convert to Double just before printing?
08:30:41 <Philippa> simple example: hash functions
08:30:55 <Philippa> simpler example: orderings
08:31:27 <ion> bobfang: Did you notice my example?
08:31:37 <ion> > showCReal 42 (2/3)
08:31:38 <lambdabot>   "0.666666666666666666666666666666666666666667"
08:31:44 <bobfang> yeah I noticed
08:31:55 <bobfang> But I can't load the module
08:32:04 <bobfang> Data.Number.CReal
08:32:10 <bobfang> I don't know why
08:32:19 <ion> Did you install the package?
08:32:23 <bobfang> Calc.hs:3:8:
08:32:24 <bobfang>     Could not find module `Data.Number.CReal':
08:32:25 <bobfang>       Use -v to see a list of the files searched for.
08:32:40 <heatsink> What do you mean by using the same record?  The record that contains interface/typeclass methods?
08:33:17 <bobfang> No, I did not.
08:33:27 <Philippa> heatsink: yep
08:35:31 <heatsink> In the typeclass case you have a pair (exists a. (Interface a, a))
08:36:10 <heatsink> And in the record encoding you just have an Interface a
08:36:24 <heatsink> Just 'Interface', rather
08:36:42 <heatsink> There's no separate 'a' object since that data is in the functions themselves
08:36:58 <Philippa> that's kinda optional, actually
08:37:15 <Philippa> the record encoding can be equivalent to the dictionary-transformed typeclass case
08:37:29 <Philippa> (and the typeclass doesn't need to come with an actual value)
08:37:46 <heatsink> Okay
08:37:53 <Philippa> but what's different is that (pre-dictionary transform) you're guaranteed that there's only one Interface for a given a
08:38:05 <heatsink> Yes
08:38:30 <Philippa> Sometimes you care about that. What if the Interface contains some kind of typeId, for example?
08:41:41 <heatsink> I still don't understand
08:42:04 <heatsink> In the record encoding case, if you need to ensure some constraints that are not part of the type system,
08:42:25 <heatsink> then you would treat the record type like an abstract data type
08:42:45 <Philippa> that doesn't give you the same set of constraints, though
08:42:57 <heatsink> and only use some record-creating functions that satisfy the internal consistency requirements
08:43:20 <Philippa> yeah, but you still can't enforce those constraints at compile-time
08:43:42 <Philippa> typeclasses are the only thing that can enforce "there shall only be one" like that in Haskell - we don't have linear types
08:44:45 <heatsink> Ah, yes
08:46:07 <heatsink> So if you want any subtype of some abstract type T, then you want an existential with a typeclass constraint
08:50:04 <bobfang> sorry but how can I use CReal ... I tried import Data.Number.CReal but the ghci complained about this.
08:51:09 <qnikst> can somebody help me with investigating why http-conduit hangs on some connections
08:51:19 <heatsink> Is the numbers package installed, bobfang?
08:52:36 <bobfang> no I can you tell me where  I  can get it?
08:52:43 <tehgeekmeister> I decided to revisit this comparison I did for fun between a perl script and a haskell version of it a few months back, and decided to trace the syscalls to see what's going on at that level.  Found that the haskell version is doing a bunch of sigprocmask calls, for some reason.  Anyone got an idea why or how I could look into this more?
08:52:50 <heatsink> cabal install numbers
08:53:16 <heatsink> That will install it in the global package database along with the other packages from when you installed GHC.
08:53:39 <tehgeekmeister> I'm using the enumerator package, perhaps an older version by now.
08:53:46 <bobfang> yeah it's working thanks.
08:56:07 * hackagebot bumper 0.5.0.1 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.0.1 (ErikHesselink)
08:56:18 <bobfang> tehgeekmeister:I got the error message ghc: could not execute: /Developer/usr/bin/gcc what to do next? I use haskell on mac
08:56:50 <heatsink> Have you installed xcode?
08:56:54 <tehgeekmeister> you need to install xcode or the command line tools
08:57:09 <tehgeekmeister> (if you don't know why you need xcode, i'd get the command line tools, they're smaller and good enough for most people.)
08:57:17 <bobfang> yes I have installed
08:59:00 <tehgeekmeister> try "stat /Developer/usr/bin/gcc"
08:59:53 <bobfang> No such file or directory
09:00:04 <bobfang> I think it is installed somewhere else
09:00:11 <bobfang> But I do have gcc
09:00:20 <bobfang> Bobs-MacBook-Pro:Hakell bobfang$ gcc
09:00:21 <bobfang> i686-apple-darwin11-llvm-gcc-4.2: no input files
09:01:09 <tehgeekmeister> well, you can try to teach ghc/everything else to work with the gcc you've installed, or you can just install the standard gcc into the standard location
09:01:12 <tehgeekmeister> and have fewer headaches
09:01:13 <fragamus> I'm on a mac, I installed Xcode, I fixed my PATH and the Haskell platform still complains "Developer Tools Missing"  "Please Install Xcode Developer Tools First"        I have gcc version 4.2.1, Thread model posix.   What else do I need?
09:01:21 <raboof> gtk2hs is confusing me. I create a TreeView with a TreeStore as model, which is a TreeModelClass. Then with 'treeViewGetModel mytreeview' I can get a TreeModel, which also is a TreeModelClass
09:01:48 <raboof> is this TreeModel my original TreeStore? Can I somehow 'cast' it to be able to use the TreeStore-specific methods?
09:02:15 <tehgeekmeister> fragamus: sorry, i have no clue.
09:02:27 <monochrom> yes there is a cast function for that. I'm too lazy to look up now
09:02:56 <dmwit> raboof: Tree*s are especially confusing in gtk. You might like to take a look at the sample code bundled with gtk2hs to see how to plug the various pieces together.
09:03:16 <hpaste_> icarroll pasted “Ambiguous type variable” at http://hpaste.org/67386
09:03:53 <dmwit> icarroll: Try (42 :: Int).
09:03:59 <raboof> dmwit: oh there's sample code - let me see if i can find that ;)
09:04:04 <dmwit> icarroll: Otherwise, how should it know which Num/TC instance to choose?
09:04:35 <icarroll> dimwit: yes, I know that using an explicit type would work, but I would like to avoid that
09:04:41 <icarroll> is there any way, or am I stuck?
09:04:54 <dmwit> You are stuck.
09:05:00 <icarroll> heh
09:05:01 <icarroll> ok
09:07:05 <ppjay> Hello! I'm using GHC and runhaskell. I run "runhaskell -Wall -Werror -XFlexibleInstances -XDeriveDataTypeable Test.hs", and I get an orphan instance warning, so I run "runhaskell -fno-warn-orphans -Wall -Werror -XFlexibleInstances -XDeriveDataTypeable Test.hs", and my program runs but closes immediately and produces no output. "runhaskell -XFlexibleInstances -XDeriveDataTypeable Test.hs" runs correctly! Very confused. Can anyone hel
09:07:06 <monochrom> no, you are not stuck. eliminate TC entirely.
09:07:54 <srhb> ppjay: hpaste your code?
09:08:22 <dmwit> Oh, I was assuming that this was cut down from a larger problem to highlight the tricky bit.
09:08:47 <icarroll> dimwit: I don't understand why it's a problem. Would you explain? I know the compiler can't decide which instance to choose, but I don't understand why not.
09:08:52 <monochrom> yes, but even for most large problems, type classes are a wrong approach
09:09:08 <icarroll> dimwit: Yes, this is trimmed from my program to avoid unnecessary complexity
09:09:31 <icarroll> monochrom: I don't know how to do what I want without type classes. I'm open to suggestions.
09:09:36 <monochrom> there is a haskell FAQ for that. look for the "monster" entry
09:09:54 <ppjay> srhb: sorry, I can't post it as I don't own the code, but I can summaries those command lines in http://pastebin.com/0utXBaAv
09:09:56 <mauke> The paste 0utXBaAv has been copied to http://hpaste.org/67387
09:10:02 <dmwit> icarroll: The rule is simple: if a program compiles without a particular type class instance, and the program also compiles with that type class instance, the two programs produced should behave exactly the same.
09:10:21 <dmwit> icarroll: Now, keeping that rule in mind, what strategy would you like the compiler to use to choose an instance for you in the code you pasted?
09:10:40 <Philippa> monochrom: I'm missing context because I dropped there :-(
09:10:48 <icarroll> dmwit: ok, let me look at the code
09:10:51 <dmwit> icarroll: Also, there's only one 'i' in my nick. =)
09:11:12 <icarroll> dmwit: yeah, just realized that sry
09:11:23 <Philippa> ah, okay, not directly following on from my earlier convo
09:11:45 <srhb> ppjay: If it's a bug in ghc you'll be hard pressed to find a solution without providing code that triggers the result, unless it happens for every single piece of code.
09:11:59 <srhb> ppjay: Of course you can simply try another version of ghc.
09:12:05 <srhb> (And pray)
09:12:39 <ppjay> srhb: turns out that if I put -Werror at the end it works, and then if i move it to the start it fails again! is that normal?
09:13:01 <hpaste_> djoyner pasted “My type fu is weak” at http://hpaste.org/67389
09:13:33 <djoyner> i've been banging my head on this one for hours.  can someone point me to the right concept?
09:14:16 <raboof> dmwit: hrm the examples seem to just keep a reference to the original store
09:14:42 <merijn> djoyner: Functions can't return different *types* based on values, you need dependent types for that
09:14:45 <dmwit> djoyner: "How do I choose different types based on runtime values?" You don't.
09:14:51 <srhb> djoyner: You can wrap those types in another type.
09:15:16 <dmwit> raboof: Perhaps I misunderstood the question, then. Let me look again.
09:15:46 <dmwit> Oh!
09:15:49 <icarroll> dmwit: what do you mean by choose an instance? are you talking about the implicit fromInteger?
09:15:53 <dmwit> Yes, I did misunderstand.
09:16:26 <djoyner> srhb: wrap how?
09:16:47 <srhb> djoyner: data MyType = NumberConstructor Int | CharConstructor Char, say..
09:16:48 <dmwit> icarroll: (42 :: (Num a, TC a) => a), but, to execute the typeclass method of TC, we must know which instance of TC to use the method from. Which instance should we choose?
09:16:59 <dmwit> raboof: one moment, looking at some documentation
09:18:27 <dmwit> raboof: class GObjectClass o where toGObject :: o -> GObject; unsafeCastGObject :: GObject -> o
09:18:40 <icarroll> dmwit: I was hoping that it would choose the only type which is an instance of both Num and TC, but apparently it won't
09:18:42 <djoyner> srhb: in my actual implementation i was using a type class, e.g. class Serializable a => MyData a and then the types I was trying to use were instances of that
09:19:03 <dmwit> icarroll: Correct. See the rule above. (one moment as I type a slightly longer explanation)
09:19:09 <icarroll> k
09:19:18 <djoyner> srhb: to use your suggestion I think I'd make your MyType an instance of Serialize then
09:19:26 <srhb> djoyner: Good idea.
09:20:29 <dmwit> icarroll: ...well, basically, the open-world assumption means you never know a complete list of all instances, so you can't say "well, there's only one instance in *this* file, so I'll just fudge it".
09:20:45 <dmwit> Some other file that you're not analyzing at the moment might define a whole host of additional instances.
09:20:55 <icarroll> dmwit: yeah, it has to compile the file before it knows what other instances may show up in other files
09:21:02 <dmwit> exactly
09:21:20 <majuscule> I've got `haskell-regex-posix` installed, but GHC can't find it.
09:21:33 <dmwit> djoyner: The usual way of doing such a thing is like this:
09:21:42 <icarroll> dmwit: no way to make it fudge it eh? :)
09:21:43 <majuscule> Could not find module `Text.Regex.Posix' Locations searched: Text/Regex/Posix.hs Text/Regex/Posix.lhs
09:22:03 <strager> majuscule: ghci -package haskell-regex-posix  # What's that show?
09:22:13 <srhb> djoyner: The problem with MyData a is that you can choose either MyData Int or MyData Char from that function, so you're just pushing the problem in front of you. :)
09:22:36 <dmwit> case input of "c" -> runResourceT $ mkSource s $$ (sinkPutter IO.stdout :: Sink Char m ()); "i" -> runResourceT $ mkSource s $$ (sinkPutter IO.stdout :: Sink Int m ())
09:22:43 <dmwit> djoyner: No additional types needed.
09:22:48 <majuscule> strager: cannot satisfy -package haskell-regex-posix
09:22:59 <strager> majuscule: Seems like it isn't installed then =]
09:23:24 <dmwit> djoyner: In other words, put the polymorphic consumer right there next to the monomorphic producer.
09:23:31 <raboof> dmwit: i guess i'll try keeping a reference around to the original typed store ;)
09:23:42 <dmwit> So that the whole type is a single type, rather than some mishmash of Int and Char.
09:23:48 <majuscule> strager: so i see! yet my distro's package manager confirms it is indeed installed, so I suppose I'll flag the package out of date. How can I get this installed on my own?
09:24:03 <dmwit> raboof: Why, did the name "unsafeCastGObject" scare you off?
09:24:09 <dmwit> raboof: If so, then it's doing it's job! =)
09:24:11 <djoyner> dmwit: thanks, will try that first
09:24:14 <raboof> dmwit: :)
09:24:16 <strager> majuscule: Using cabal-install:  cabal install <packagename>
09:24:48 <strager> majuscule: I prefer cabal-install over whatever Ubuntu says, except for things like base and ghc (Haskell Platform).
09:25:13 <raboof> dmwit: (also, it gave me 'Couldn't match expected type `GObject' with actual type `TreeModel'' and I'm not sure I should invest further time in fixing what is already a hack)
09:25:26 <majuscule> strager: I'm actually on Arch, and I can't seem to find any package that provides `cabal-install`
09:25:38 <dmwit> raboof: You probably need to cast it up to a GObject before you cast it down to a TreeSource.
09:25:41 <tehgeekmeister> is there a search of some sort for the ghc codebase somewhere?
09:25:51 <icarroll> dmwit: so, if I can't use typeclasses to allow me to use either a number or an algebraic type for a particular argument, is there anything else I can do? or do I need to wrap the number in a type and put up with the ugly?
09:26:04 <strager> majuscule: It might be called just `cabal`.  Maybe.
09:26:07 <majuscule> strager: here are the files that Arch's current package installs: http://dpaste.com/735136/
09:26:28 <dmwit> icarroll: Sorry, what? Typeclasses are exactly the mechanism you use to be able to pass either a number or an algebraic type.
09:26:29 <strager> Did you install ghc using Arch's PM?
09:26:46 <strager> tehgeekmeister: grep?  =]
09:26:54 <dmwit> "if I can't use typeclasses to allow me to use either a number or an algebraic type for a particular argument" is a faulty assumption, so the remainder of the question is void
09:27:05 <icarroll> dmwit: yes, which is why I wrote the code as I did
09:27:08 <tehgeekmeister> strager: i wanted to avoid that, but it seems to be the way to do it.
09:27:16 <majuscule> strager: lol, the package is cabal-install, and the command is cabal
09:27:36 <icarroll> dmwit: but as you can see, the way I'm doing it doesn't work
09:27:38 <tehgeekmeister> strager: (not because i dislike grep, but because i like reading source all pretty and hyperlinked on the web.)
09:27:39 <strager> majuscule: Yes, it's a bit confusing =]
09:27:40 <majuscule> strager: yes I did, that paste is the output of `pacman -Ql haskell-regex-posix`
09:27:47 <strager> tehgeekmeister: I agree with you.
09:27:53 <dmwit> icarroll: ...add a type signature, like I said about half an hour ago.
09:27:58 <strager> majuscule: I meant ghc, not that package.
09:28:03 <majuscule> also yes
09:28:14 <djoyner> dmwit: that did the trick, thanks
09:28:45 <icarroll> dmwit: yes, that will work technically, but requires that I put type signatures on all of the numbers in the code, of which there will be a lot
09:29:12 <icarroll> dmwit: I'm looking for a way to avoid putting warts on my numbers, but it looks like there isn't one
09:29:15 <strager> majuscule: `ghc --print-libdir` should include /usr/lib/ghc-7.4.1/site-local/
09:29:19 <icarroll> thank you for your help
09:29:44 <majuscule> strager: ahhh yes that'l be the problem won't it
09:29:46 <dmwit> icarroll: It only requires type signatures on number literals.
09:29:51 <majuscule> strager: it does not, how can I update that?
09:29:58 <tehgeekmeister> eeep.  hoogle doesn't know of this function used in one of the core ghc io libs, and it's not in the ghc codebase either.  where to search?
09:29:58 <strager> I have no idea =D
09:30:02 <majuscule> lol
09:30:08 <majuscule> thanks though!
09:30:15 <majuscule> i fear it'l be a compile time option
09:30:23 <strager> I'm off to BayHac; \o
09:30:26 <strager> Doubt it
09:30:29 <majuscule> actually wait
09:30:32 <strager> mm?
09:30:34 <icarroll> dmwit: yes, but there will be a lot of them. I'm trying to write an embedded dsl for assembly language
09:30:58 <icarroll> dmwit: I don't want to have to write "add A (0x42::Word16)"
09:31:06 <majuscule> strager: i think spoke in error, the output is `/usr/lib/ghc-7.4.1`, which the parent directory, so i don't think that'd be a problem?
09:31:36 <dmwit> icarroll: I think it's pretty normal for people writing in assembly to have non-polymorphic add instructions.
09:31:43 <dmwit> addWord16, addWord32, etc.
09:31:56 <dmwit> So you might consider that.
09:32:22 <strager> majuscule: dunno; I think site-local should be included
09:32:23 <dmwit> You might also consider making your other type (whatever it is) an instance of Num, and making add *only* take that type as a second argument.
09:32:25 <strager> Got a train to catch; bye!
09:32:27 <icarroll> dmwit: the polymorphism isn't in the numbers, it's in using either a literal or a register as the source. I could have different opcodes depending on the source, but that's not elegant either
09:32:35 <Philippa> I really need to write up the more complicated version of the RPG monster typing problem as a blog post some time
09:33:18 <dmwit> data AddOperand = Register Int | Literal Word16; instance Num AddOperand where fromInteger n = Literal (fromInteger n)
09:33:33 <dmwit> add :: Whatever -> AddOperand -> Assembly ()
09:33:41 <majuscule> strager: welllp, i've got everything working after installing with cabal, but this really sucks because a package of my own depends on the Arch haskell-regex-posix so it'l be broken for anybody else without wading through this shit as I have :-(
09:34:01 <icarroll> dmwit: ok, let me think about that for a minute
09:36:08 <icarroll> dmwit: I will try that approach. I'm not sure yet how it will interact with addressing modes, but I don't see any immediate show stoppers
09:36:12 <icarroll> thanks again
09:51:09 * hackagebot JuicyPixels-repa 0.3 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.3 (ThomasDuBuisson)
10:03:19 <Shayan> hi
10:03:59 <Shayan> ANyone here?
10:04:05 <Clint> no one
10:04:15 <Shayan> haha
10:04:34 <Shayan> i was thinking if there is a free (PDF) ebook
10:05:13 <qnikst> I've see one
10:05:17 <qnikst> *seen
10:05:19 <merijn> Shayan: Both "Learn You a Haskell" and "Real World Haskell" are available for free online. I don't think there's a free ebook, though
10:05:30 <merijn> @where lyah
10:05:31 <lambdabot> http://www.learnyouahaskell.com/
10:05:33 <merijn> @where rwh
10:05:33 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:05:35 <Shayan> i dont like reading online
10:05:46 <Shayan> i know i have read them
10:05:55 <merijn> Shayan: Most ereaders support html, don't they?
10:06:03 <Shayan> ok here comes a question
10:06:13 * hackagebot hoopl 3.8.7.4 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.7.4 (NormanRamsey)
10:06:14 <Shayan> which one do you like the most
10:06:28 <Shayan> python,c++,vb.net or haskell'
10:06:38 <niklasb> what's the simples way to transform a list of the format [1,2,3,4,5,6] into a list of pairs [(1,2),(3,4),(5,6)]?
10:06:45 <ion> intercal
10:06:46 <monochrom> lyah probably has an ebook form for sale on amazon
10:06:52 <yousong> i know you can open it in opera, and save as offline
10:07:00 <merijn> Shayan: Personal preference (in general, specific tasks might change the order) haskell > python > c++
10:07:30 <Shayan> i don't think haskell is as productive as the other three
10:07:30 <merijn> And I thought/hoped VB.net was dead/dying
10:07:36 <Shayan> but C++ is ugly
10:07:42 <Shayan> and messy
10:07:57 <merijn> Most shops have moved on to C# I think, which as far as I can tell is much, much better than VB.net
10:08:03 <theotherphil> A total beginner question: how do I set ghci to automatically load additional modules at startup
10:08:19 <zachk> in your $HOME .ghci
10:08:23 <NihilistDandy> ^
10:08:24 * monochrom is uninterested in this shallow kind of "discussion"
10:08:26 <theotherphil> I've created a ghci.conf file, with "import Data.List.Split" in it
10:08:47 <theotherphil> But when I start ghci I get "parse error on input "import" "
10:09:02 <BMeph> niklasb: 1) Make a copy of the list, starting from the second element; 2) Combine the two lists into a list of pairs; 3) Take every other element of the list of pairs.
10:09:04 <NihilistDandy> Change it to :m +Data.List.Split
10:09:14 <NihilistDandy> I think that'll do it
10:09:31 <merijn> monochrom: Well, in the interest of deeper discussion: I remember seeing a proposal for instance chains in GHC but can't find anything like that. Did I hallucinate it?
10:09:57 <niklasb> BMeph: i thought about that. but how to do 3) easily, as in without defining a new function?
10:09:58 <monochrom> I haven't seen that. what s instance chain?
10:10:05 <theotherphil> Then I get "syntax :module [+/-] ..."
10:10:22 <NihilistDandy> merijn: http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf ?
10:10:28 <monochrom> however, I seldom look for proposals. there must be a thousand proposals I have never seen
10:10:33 <merijn> NihilistDandy: Yeah, the habit stuff
10:10:40 <theotherphil> If I call import or :m from inside ghci then it's fine, but I get errors when putting the same lines in the .conf file
10:11:28 <monochrom> which ghc version? you need at least 7 for import
10:11:28 <merijn> monochrom: Instance chains let you provide a deterministic order for typeclass instances and also close a typeclass
10:11:47 <merijn> As a result you don't run into OverlappingInstances and friends quite as much
10:11:58 <merijn> Which in turn means neater type level coding
10:12:05 <theotherphil> 7.0.4. "import Data.List.Split" works fine when it type it in the command prompt
10:12:13 <theotherphil> *when I
10:13:05 <niklasb> BMeph: nevermind, Data.List.Split is nice for what I need
10:13:08 <merijn> I understood there was some interest in porting the ideas to GHC, so I wanted to know if someone had already introduced a concrete proposal (since I thought I saw one) to which I can contribute, rather than having to propose something from scratch myself
10:13:14 <BMeph> niklasb: In other places, it's refered to as a "Schwartian tranform". Basically, you 'zip' your list with a list of indices, process on the indices, them strip off the indices.
10:13:35 <niklasb> BMeph: oh, that's interesting. nice.
10:13:46 <niklasb> so I zip with [True,False,True,...] and filter on the second item
10:13:54 <merijn> Although I guess I should have asked in #ghc
10:14:14 <BMeph> niklasb: Yeah, '.Split' was made for such things. Really, Smalltalk/Squeak aside, Haskell programming is more like playing with Legos than anything else. :)
10:14:41 <niklasb> BMeph: I really like zip3 a (tail a) (map even [0..])
10:15:00 <niklasb> however, is there a better alternative for the last list? I just want to have [True,False,True,...]
10:15:00 <BMeph> niklasb: Simpler - zip on [0, 1, 2, 3, 4...], and filter on the 'even' ones, i.e. 'filter even'
10:15:06 <parcs`> does such a think as an indexed functor exist/
10:15:07 <monochrom> I just tested "import Data.List" in ghci.conf. works.
10:15:09 <parcs`> thing
10:15:23 <niklasb> BMeph: hm, isn't that what I'm doing?
10:15:40 <niklasb> Oh, yes
10:16:10 <theotherphil> Ah
10:16:14 <BMeph> niklasb: Why make a construct you don't really want? Use the info you have; skip the extras. :)
10:16:16 <theotherphil> Just noticed that the error is at the end of the first line
10:16:38 <theotherphil> "import Data.List" works fine, having a second line doesn't
10:17:00 <niklasb> BMeph: hm, I'm not entirely sure. I came up with `map fst . filter (even . snd) $ zip (zip xs (tail xs)) [0..]` but it's a bit verbose
10:17:34 <monochrom> eh? "import Data.List\nimportData.Char" works too here
10:18:12 <monochrom> err, I missed a space there. "import Data.List\nimport Data.Char"
10:18:15 <sanjoyd> [Off topic] Suggestion for a book on relational algebra.
10:18:17 <BMeph> niklasb: 'map snd . filter (even . fst) . zip [0..] $ zip xs (tail xs)' works, too. Same thing, just written differently. :)
10:19:08 <bobfang> sorry, if I don't  use CReal, how can I get arbitrary precision number. like I want to write a function showNumber::Int->Rational->String, if i type showNumber 100 (2%3) it will return a string like "0.666....(one hundred 6)"
10:19:12 <monochrom> Rutger Dijkstra's MSc thesis is the best book on relationa algebra. best for me. but it's very abstract. also hard to find.
10:19:15 <niklasb> BMeph: haha yeah, just changed it to that exact form
10:19:24 <niklasb> okay, neat.
10:19:45 <BMeph> bobfang: Use CReal. ;)
10:20:26 <bobfang> BMeph:I can't , I am doing my coursework and I don't think the professor will be happy with it...
10:20:52 <BMeph> bobfang: Bah, what does he know... ;)
10:21:33 <theotherphil> monochrom: yes, I'm a little confused as to why it's not working for me.
10:22:38 <monochrom> use a hex editor to look for funny bytes
10:24:29 * BMeph is firmly convinced that part of the problem newbies has with Haskell is that too much is easy to do compared to other languages.
10:24:42 <theotherphil> monochrom: Ok, it was due to notepad++ doing something funny. Works fine when I edit it in notepad. Sorry, should have been able to sort this one out myself, but assumed that the parse error was on the first use of "import" and that I was supposed to be doing something different. Thanks for your help.
10:25:14 * BMeph uses MP++
10:25:24 <monochrom> normally notepad++ doesn't do funny things. I always use it for haskell when in windows
10:25:24 * BMeph meant NP++
10:25:33 * BMeph too
10:26:13 * hackagebot bzlib-conduit 0.1.0.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.1.0.0 (HideyukiTanaka)
10:26:51 <theotherphil> For a .conf file, when you hit enter it adds a carriage return but not a line-feed
10:26:55 <monochrom> even notepad is untrustworthy. trust only a hex editor
10:27:54 <monochrom> ah, that's natural if notepad++ expects the file to belong to unix
10:28:30 <monochrom> no wait, it should be LF and no CR
10:28:32 <niklasb> theotherphil: you probably configured NP++ to save your files in Mac OS format then?
10:28:38 <niklasb> why on earth would you do that?
10:28:57 <zomg> I'm considering using Yesod with a for-fun web app project but I'm wondering how is WebSocket support in it?
10:29:10 <niklasb> monochrom: traditional Mac line endings are CR only, AFAIK
10:29:12 <zomg> I've done some nodejs stuff and I've been kind of spoiled by Socket.IO (it makes websockets ridiculously easy to do)
10:29:38 <monochrom> is it CR or is it LFCR?
10:29:39 <mzero> #BayHac - hackaton in progress!
10:30:01 <theotherphil> niklash: I didn't. And it's now working properly. So I've no idea what happened before. Anyway, it's working now. Thanks all
10:30:10 <mzero> "traditional" Mac, prior to OS X --- it was CR
10:30:32 <niklasb> mzero: yep, that's what I said
10:30:40 <monochrom> yeah I have pre-X Mac in mind too
10:31:02 * monochrom is old and wise. used Apple II
10:33:19 <dmwit> ?karma notepad
10:33:20 <lambdabot> notepad has a karma of 9
10:35:13 <monochrom> hehehe
10:35:37 <monochrom> I totally don't mind notepad getting all the karma
10:35:58 <dmwit> What do I search for to get information about using the version number in my .cabal file in my program code again?
10:36:27 <bitonic> @where pvp
10:36:27 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
10:36:30 <bitonic> dmwit: that?
10:36:34 <bitonic> ah, no.
10:36:37 <bitonic> Paths_something?
10:37:11 <bitonic> Paths_pkgname
10:37:32 <dmwit> found it
10:37:34 <dmwit> http://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
10:38:03 * BMeph really wishes "msvcrt.dll" could, and would, die in a fire...
10:38:15 <bitonic> dmwit: yep, that. I had parsed your question wrong :P
10:38:48 <dmwit> bitonic: thanks =)
10:39:26 <dmwit> What's the difference between extra-source-files and other-modules?
10:39:33 <dmwit> (For executables.)
10:39:53 <bitonic> dmwit: well, if you don't put the modules used internally in other-modules bad things happen
10:40:03 <bitonic> extra-source-files are non-haskell filepathrs
10:40:05 <bitonic> *filepaths
10:40:16 <bitonic> well not necessarely non-haskell, but not haskell modules that the application uses
10:40:33 <dmwit> I've got a package I wrote here with Haskell source files in extra-source-files, and nothing's going wrong.
10:40:54 <dmwit> (...yet =P)
10:41:12 <bitonic> dmwit: have you tried to run it? iirc it doesn't link it or something.
10:41:37 <bitonic> but the main difference is that other-source-files are arbitrary filepaths
10:42:01 <bitonic> dmwit: "Failing to do so (as of GHC 6.8.3) may lead to your library deceptively building without errors but actually being unusable from applications, which would fail at build time with a linker error."
10:42:43 <Saizan> considering the build system with GHC, it doesn't matter for executables, only for libs
10:43:12 <bitonic> oh, ok.
10:43:41 <dmwit> bitonic: Yes, I run it every day. And yes, it's not a library, so that comment doesn't seem to apply.
10:43:54 <bitonic> dmwit: my bad :)
10:44:28 <aanari> Anybody ever get a "Missing C library: iw"?  I have iw installed from sid though.
10:44:38 <dmwit> Let's see if I can share other-modules: lines across executable blocks... if so, I'll switch just because it's the Right Thing To Do.
10:44:48 <dmwit> aanari: Do you have iw-dev installed?
10:45:04 <bitonic> actually yeah, looking at my .cabals I never include other-modules. I think I copied and pasted since the first time :P
10:45:28 <aanari> dmwit: There is no iw-dev
10:46:00 <aanari> dmwit: Should I build from source?
10:46:10 <dmwit> aanari: Not an "iw" expert, but look for something similar. Usually, there are normal and -dev versions of each library.
10:46:15 <dmwit> You will need the -dev version.
10:46:33 <dmwit> pkgconfig will tell you when you've succeeded.
10:46:57 <dmwit> Seems other-modules can't be shared across blocks.
10:47:07 <dmwit> The choice of which things can and can't be shared seems really arbitrary.
10:47:53 <aanari> dmwith: Thanks, I can't find any dev versions so I'll try compiling from source
10:50:26 <dmwit> aanari: It's called libiw-dev.
10:50:27 <rasfar> i've got a libiw-dev in ubuntu fwiw
10:50:51 <nart_> hi
10:51:14 * hackagebot osm-download 0.3.4 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.3.4 (ThomasDuBuisson)
10:51:26 <rmunroe> Is there a general opinion here on prog21.dadgum.com?
10:51:28 <dmwit> aanari: Next time, don't suck at searching. =)
10:51:38 <dmwit> nart_: howdy
10:52:11 <aanari> dmwit: Thank you I'm sorry
10:52:14 <aanari> xD
10:53:12 <rasfar> dmwit: i've still not heard back from the author of explore-hackage, so i guess i'll go for it
10:53:55 <dmwit> wunderbar
10:54:37 <sm> morning all
10:55:32 <sm> I'm fed up with gist.github.com clients that don't work.. I bet someone has made one in haskell.. have you seen one ?
11:00:41 <kallisti> I ask a simple question in #ruby
11:00:46 <kallisti> a flamewar erupts
11:00:47 <nart> is there a function that "truncate" a long number like 9,299483943 to just 9.29 ?
11:00:49 <kallisti> I asked a simple question in #haskell
11:00:51 <kallisti> everyone is really helpful and mannered.
11:01:07 <dmwit> > truncate 929.9483943
11:01:08 <lambdabot>   929
11:01:22 * kallisti can't remember the name of it.
11:01:26 <hpc> > truncate -3.9
11:01:27 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
11:01:27 <lambdabot>    arising from a use of `...
11:01:31 <hpc> > truncate (-3.9)
11:01:32 <lambdabot>   -3
11:01:36 <nart> kallisti: the same, i cannot remember the name
11:01:38 <hpc> > floor (-4)
11:01:39 <lambdabot>   -4
11:01:54 <hpc> what's the opposite of truncate?
11:02:01 <dmwit> > printf "%0.2f" 9.2994833943
11:02:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:02:03 <lambdabot>    `Text.Printf.PrintfType ...
11:02:05 <kallisti> hpc: id?
11:02:11 <dmwit> hpc: No opposite, but you might also like round, floor, ceiling
11:02:11 <kallisti> : truncate
11:02:16 <kallisti> :t truncate
11:02:17 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:02:38 <hpc> i mean like
11:02:48 <dmwit> truncate is towards zero; round is towards nearest (with banker's rounding); ceiling is towards infty; floor is towards -infty.
11:02:59 <nart> > truncate 3.9999
11:02:59 <hpc> ^
11:03:00 <lambdabot>   3
11:03:09 <hpc> truncate is towards zero, so what's away from zero?
11:03:28 <hpc> (i used to know what it was, and it's bugging me not knowing)
11:03:31 <nart> > (truncate . (* 100) $ 3.999 )/ 100
11:03:32 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:03:32 <lambdabot>    `GHC.Real.Integral b'
11:03:32 <lambdabot>   ...
11:03:43 <dmwit> I don't think Haskell has one. I'm not sure I've heard a name for such a thing, either.
11:03:56 <nart> (truncate (3.99 * 100) `div`  100)
11:04:15 <dmwit> > fromInteger (truncate (3.999 * 100)) / 100
11:04:16 <lambdabot>   3.99
11:05:02 <dmwit> > let away x = signum x * ceiling (abs x) in away (-3.9)
11:05:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:05:03 <lambdabot>    `GHC.Real.RealFrac a'
11:05:03 <lambdabot>   ...
11:05:10 <nart> that's it, thanks dmwit .. it's ugly as hell but at least works
11:05:20 <dmwit> > let away :: RealFrac a => a -> a; away x = signum x * ceiling (abs x) in away (-3.9)
11:05:21 <lambdabot>   Could not deduce (GHC.Real.Integral a)
11:05:22 <lambdabot>    from the context (GHC.Real.RealFr...
11:05:30 <dmwit> ah right
11:05:42 <jonkri> what is the attoparsec equivalent of "many"?
11:05:44 <dmwit> > let away x = signum x * fromInteger (ceiling (abs x)) in away (-3.9)
11:05:45 <lambdabot>   -4.0
11:05:50 <dmwit> > let away x = signum x * fromInteger (ceiling (abs x)) in away 3.9
11:05:51 <lambdabot>   4.0
11:07:17 <adnauseam> o_0
11:08:02 <dmwit> jonkri: Uh, "many".
11:08:25 <jonkri> dmwit, it seems that it's no longer part of attoparsec - http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.1/doc/html/doc-index.html
11:08:45 <dmwit> jonkri: instance Monoid t => Alternative (Parser t)
11:08:51 <mekeor> what a nice book for haskell for yet non-programmers?
11:08:52 <dmwit> http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.1/doc/html/Data-Attoparsec-Types.html#t:Parser
11:09:01 <hpc> > let away x = round (signum x) * ceiling (abs x) in away 3.9
11:09:02 <lambdabot>   4
11:09:11 <hpc> > let away x = round (signum x) * ceiling (abs x) in away (-3.9) -- now the type is right
11:09:12 <lambdabot>   -4
11:10:32 <hepek> mekeor: http://learnyouahaskell.com/
11:11:33 <rasfar> you could also use Text.Printf(printf) followed by read :)
11:12:54 <rasfar> (not suggesting that would be efficient of course)
11:13:02 <mekeor> hepek: that's for already programmers :P
11:13:02 <dmwit> > '(' < 'c'
11:13:03 <lambdabot>   True
11:21:29 <`Jake`> mekeor: But it's also understandable if you aren't a programmer, I think
11:22:44 <mekeor> `Jake`: i think so, too. but i wanted to be sure because officially it's for programmers (see homepage).
11:23:29 <hepek> mekeor: check it out
11:24:04 <mekeor> hepek: i already know haskell. i was looking for a book for a friend…
11:24:48 <hepek> mekeor: that's probably the easiest programming book around
11:25:15 <hpaste_> wli pasted “Newton series / generating function products” at http://hpaste.org/67390
11:31:13 <Xorlev> mekeor: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
11:31:15 * hackagebot yeganesh 2.5 - small dmenu wrapper  http://hackage.haskell.org/package/yeganesh-2.5 (DanielWagner)
11:31:23 <Xorlev> Remember, you have no speed limits. Dive in, get messy.
11:31:33 <Nisani201> alright i have sort of a complicated scenario. I have a list of values and I want to apply a function to each one individually, but make a new list from each scenario. so like (-1) [1,2,3,4] = [[0,2,3,4],[1,1,3,4],[1,2,2,4],[1,2,3,3]
11:31:58 <mekeor> Xorlev: neat.
11:32:37 <Xorlev> mekeor: I started there. If I got confused, I'd google around and come back.
11:32:55 <dmwit> > let select xs = zip (inits xs) (tails xs); f = subtract 1 in [b ++ f m:e | (b, m:e) <- select [1..4]]
11:32:57 <lambdabot>   [[0,2,3,4],[1,1,3,4],[1,2,2,4],[1,2,3,3]]
11:33:16 <Nisani201> wow.
11:33:17 <Xorlev> I went through it several times and in the process built a lot of haskell stuff (followed the Roll your own IRC Bot tutorial in one instance)
11:33:21 <Nisani201> thank you dmwit
11:33:27 <jonkri> dmwit, i don't see how it being a monoid helps. what function are you suggesting that i should use?
11:33:38 <dmwit> jonkri: "many"
11:33:52 <jonkri> dmwit, from what package?
11:34:04 <dmwit> jonkri: base
11:34:43 <navaati> are the maintainer of the cairo binding around here ?
11:34:50 <dmwit> navaati: yo
11:34:55 <navaati> (hi)
11:35:06 <dmwit> Hi!
11:35:21 <ion> > let f op = zipWith g [0..] where { g n = zipWith (h n) [0..]; h 0 (x:xs) = op x:xs; h n (x:xs) = x:h (n-1) xs; h _ [] = [] } in f (-1) [1..4]
11:35:22 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
11:35:32 <jonkri> thanks dmwit
11:35:33 <ion> > let f op = zipWith g [0..] where { g n = zipWith (h n) [0..]; h 0 (x:xs) = op x:xs; h n (x:xs) = x:h (n-1) xs; h _ [] = [] } in f (subtract 1) [1..4]
11:35:33 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
11:38:48 <bobfang> How do you define a stack in haskell? THX :)
11:38:52 <wli> http://mathbin.net/92780 <— pre-rendered
11:38:59 <dmwit> bobfang: type Stack = []
11:39:03 <luite> bobfang: a list is more or less a stack :)
11:39:25 <dmwit> bobfang: push = (:); pop = head &&& tail
11:39:32 <navaati> dmwit: ah, maybe you are the maintainer of the cairo package ?
11:39:39 <dmwit> navaati: yup
11:40:16 <navaati> ok x)
11:40:30 <navaati> there is in cairo a very useful function cairo_image_surface_create_for_data()
11:40:39 <navaati> but there is no equivalent in the binding
11:40:47 <dmwit> Yeah, you submitted a patch, right?
11:40:51 <dmwit> That patch is going in.
11:40:53 <navaati> why ?/is it possible to add it ?
11:40:53 <dmwit> Later today, I hope.
11:41:24 <navaati> dmwit: uh ? no, i didn't. or it was sarcasm ?
11:41:36 <dmwit> Oh, yes, the patch was for pixbufNewFromData.
11:41:37 <dmwit> Sorry.
11:41:42 <hiptobecubic> So monads are monoids in the category of endofunctors, because they map Hask to Hask?
11:41:48 <navaati> erf :)
11:42:11 <dmwit> Oh, no, there's a patch for cairo_image_surface_create_for_data, too.
11:42:18 <navaati> ah, great !
11:42:22 <navaati> just in time
11:42:22 <BMeph> > let mapHead f [] = []; mapHead f (x:xs) = f x:xs; nisaFunc g xs = zipWith ((. g) . (++) (inits xs) (tails xs) in nisaFunc pred [1..4]
11:42:23 <lambdabot>   <no location info>: parse error on input `in'
11:42:28 <dmwit> Anyway, there's a few outstanding patches and I plan on looking at them as soon as I'm done writing up a release announcement for yeganesh. =)
11:42:30 <Saizan> hiptobecubic: mapping Hask to Hask is what makes them endofunctors
11:42:33 <Philippa> hiptobecubic: that gets you as far as the endofunctor bit. You need the natural transformations as well to become monoidal
11:42:33 <hiptobecubic> yes
11:42:37 <BMeph> > let mapHead f [] = []; mapHead f (x:xs) = f x:xs; nisaFunc g xs = zipWith ((. g) . (++)) (inits xs) (tails xs) in nisaFunc pred [1..4]
11:42:38 <lambdabot>   No instance for (GHC.Enum.Enum [a])
11:42:38 <lambdabot>    arising from a use of `e_114' at <in...
11:42:58 <hiptobecubic> You have to also obey the monoid laws, yes. which I guess are generalized in the monad laws?
11:43:31 <navaati> dmwit: that would be great, i'm making a binding to libdrm and i need a rendering api
11:43:34 <dmwit> monads are like... typed monoids
11:43:36 <Saizan> hiptobecubic: there is a generalization of monoid called "monoid object", which needs a monoidal category
11:44:14 <dmwit> Whoops, I meant *categories* are typed monoids!
11:44:15 <dmwit> silly me
11:44:23 <RandomBP> ...
11:44:25 <Saizan> hiptobecubic: if you take the category of endofunctors with composition as the tensor product then a monoid object is a monad
11:44:51 <Saizan> hiptobecubic: if you take that category as the monoidal one, i meant
11:44:52 <hiptobecubic> hmm ok
11:45:33 <Saizan> http://en.wikipedia.org/wiki/Monoidal_category
11:48:53 <Saizan> http://en.wikipedia.org/wiki/Monoid_object <- or maybe it's better to start from here, since you should recognize mu and eta as join and return
11:59:01 <Nisani201> dmwit: can you explain the select function in more detail so i can implement in in my program?
12:00:32 <dmwit> Nisani201: select is a function which nondeterministically chooses a position to split the input at, and splits it there.
12:01:40 <Nisani201> how would i implement it as a function like select :: (a -> b) -> [a] -> [[b]]
12:02:21 <dmwit> You should leave it as select :: [a] -> [([a], [a])] and tack on the other parsing afterwards.
12:02:28 <dmwit> That's what modularity is about.
12:02:40 <dmwit> eh... s/parsing/processing/
12:03:55 <srhb> Oh God. I just realized, maybe... Is it called Lift because it lifts up a horizontal arrow?
12:04:01 <Nisani201> erm. but then what is b ++ f m:e | (b, m:e) at the end
12:04:01 <Nisani201> ?
12:04:16 <dmwit> Nisani201: Do you know list comprehension syntax?
12:04:26 <Nisani201> somewhat.
12:04:29 <dmwit> > [ x + 3 | x <- [7, 16, 35] ]
12:04:30 <lambdabot>   [10,19,38]
12:04:51 <dmwit> > [ x + 3 | Just x <- [Nothing, Just 7, Nothing, Just 35, Just 16] ]
12:04:52 <lambdabot>   [10,38,19]
12:05:02 <dmwit> same idea as that
12:06:05 <dmwit> (b, m:e) <- select xs nondeterministically chooses a place to split (using select), then binds "b" to the part before the split, "m" to the value at the split, and "e" to the part after the split.
12:06:17 <dmwit> b ++ f m:e just unsplits it, but after applying f to the value at the split.
12:06:53 <dmwit> "b ++ [f m] ++ e" is probably clearer.
12:07:45 <Nisani201> ok thanks
12:12:20 <nand`> Is there a Haskell library that implements or helps implementing a DHT-based decentralized routing network?
12:13:42 <timthelion> what would the type of f be in let f arg action = action arg in f 1 (\x->x+1) or in (f 1 (\x y -> x+y)) 2 ?  As you see, f can take any argument and any function of any number of arguments and return either a function or a value...
12:14:23 <dmwit> :t let f arg action = action arg in f
12:14:24 <lambdabot> forall t t1. t -> (t -> t1) -> t1
12:14:33 <dmwit> Does that answer your question...?
12:14:40 <monochrom> f = flip ($)
12:14:45 * dmwit nods agreeably
12:14:53 <timthelion> dmwit: thanks
12:15:19 <nand`> f = flip id
12:15:31 <timthelion> I'm having trouble wrapping my mind arround the fact that (\x y -> x+y) can have the type (t->t1)
12:15:53 <nand`> t1 can really be t2 -> t3
12:16:04 <monochrom> t -> t1 where t1 = t -> u
12:16:34 <timthelion> ok, thank you
12:17:02 <monochrom> the power of uniformity is underappreciated
12:20:05 <srhb> I am confused. Is map a functor? And does map lift functions (morphisms?) to the context of... list(-objects?)?
12:20:44 <c_wraith> srhb: in haskell, only types can be instances of classes, and Functor is a class.  map is a function, not a type
12:21:21 <dmwit> srhb: Together, the [] type constructor and map function are a functor.
12:21:34 <srhb> So is my terminology wrong both in Haskell and category theory, or just in Haskell?
12:21:37 <dmwit> srhb: And yes, map lifts functions (yes, morphisms!) to the context of lists.
12:21:44 <srhb> aha.
12:21:58 <dmwit> srhb: Your terminology is nearly right. The only objection is that a functor has two pieces, not just one.
12:22:15 <dmwit> srhb: (So saying "map" is a functor isn't quite right: []/map is a functor.)
12:22:29 * Eduard_Munteanu finds it a bit annoying how they write that in CT books/texts... like Ff for fmap f.
12:22:29 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
12:22:34 <srhb> dmwit: Thanks. First venture into this. I'll need to read some more to understand that. :-)
12:23:11 <netbyte> What are some popular programs actually made with haskell
12:23:19 <niklasb_> XMonad
12:23:58 <Nimatek> GHC
12:23:59 <Yarou> darcs
12:24:06 <cjay> pandoc
12:24:21 <nand`> netbyte: I can't say anything about popularity, but right now I'm using xmonad, xmobar, yeganesh, darcs and vimus on a regular basis
12:24:25 <nand`> (not counting cabal and GHC)
12:24:58 <sm> yes don't forget cabal, used by every haskeller
12:24:59 <nand`> I've heard yesod is popular as well; as are some of the other Haskell web platforms
12:25:35 <Eduard_Munteanu> Presumably one might ask about Haskell apps that don't require you to be acquainted to Haskell already.
12:25:44 <Eduard_Munteanu> I guess pandoc fits that bill.
12:25:53 <sm> hledger
12:26:06 <niklasb_> hakyll
12:26:10 <Clint> git-annex
12:26:40 <sm> it's the haskell app roll-call
12:26:58 <sm> we need some new stuff
12:27:27 <nand`> `grep haskell-cabal /usr/portage/*/*/*.ebuild | wc -l` returns 340 but that's counting duplicates
12:27:33 <nand`> and haskell libraries
12:27:51 <srhb> is return really unit?
12:27:53 <niklasb_> nand`: what about `| sort | uniq`?:)
12:28:05 <niklasb_> or just uniq, dunno
12:28:14 <Eduard_Munteanu> srhb: the monad unit? Yes.
12:28:18 <aristid> git-annex maybe
12:28:26 <srhb> Hurrah.
12:28:30 <Eduard_Munteanu> :t return
12:28:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:28:37 <Eduard_Munteanu> :t join
12:28:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:28:54 <srhb> Well Im just glad I recognized "return" from the description of unit. :-)
12:29:01 <nand`> niklasb_: duplicates are for different versions, doesn't change the result; oh, and it's 1099 results for /var/lib/layman/haskell (mainly includes haskell libs)
12:29:05 <aristid> :t (liftM, return, join)
12:29:06 <Eduard_Munteanu> Heh.
12:29:06 <lambdabot> forall a1 r (m :: * -> *) a (m1 :: * -> *) (m2 :: * -> *) a11. (Monad m, Monad m1, Monad m2) => ((a1 -> r) -> m a1 -> m r, a -> m1 a, m2 (m2 a11) -> m2 a11)
12:32:23 <Zane> Is there a simple way to find the first element of a list that doesn't equal the previous element+1 and increment it?
12:33:19 <srhb> Zane: As in, return the same list but with that one element increased by one?
12:33:25 <netbyte> what are xmonad, xmobar, yeganesh, darcs, vimus
12:33:27 <Zane> yes
12:33:31 <netbyte> cabal?
12:33:45 <dmwit> > let weirdIncrement (x:y:rest) | x+1 /= y = x:y+1:rest; weirdIncrement (x:xs) = x:weirdIncrement xs; weirdIncrement [] = [] in weirdIncrement [1,2,3,5,7]
12:33:46 <lambdabot>   [1,2,3,6,7]
12:34:23 <dmwit> netbyte: JFGI
12:34:46 <nand`> isn't that second line a bit redundant; if it matches (x:xs) but not (x:y:rest) it must be (x:[]) so that's the same as just returning [x]
12:35:13 <nand`> netbyte: programs written in Haskell
12:35:13 <dmwit> Feel free to try eliminating it.
12:35:22 <dmwit> Do note that the first pattern has a guard, though.
12:35:24 <Zane> That's what I had, for some reason I think you could do it with a scan in one line that I can't figure out
12:35:39 <nand`> dmwit: oh, that explains it
12:36:10 <dmwit> It doesn't treat the whole list uniformly, so "scan(l|r)" is a bad match.
12:36:25 <dmwit> It probably can be done, but that doesn't mean it *should* be done. =)
12:36:38 <Zane> ok, thanks
12:36:40 <byorgey> Zane: you could probably do something complicated where you first zip the list with its own tail and then do a scan or something, but it's probably not worth it.
12:36:44 <srhb> Once you've incremented the number you want to "flip a switch" - which should tell you what dmwit sad
12:39:10 <sanjoyd> Does converting haskell functions to be tail recursive help?
12:39:19 <dmwit> It doesn't. It usually hurts.
12:39:31 <monochrom> it depends
12:40:00 <sanjoyd> For instance, in the example dmwit just gave, what if I pass a "result" list which keep consing to, and return on seeing []?
12:40:15 <sanjoyd> monochrom: ^
12:40:29 <dmwit> Guarded recursion is better than tail recursion when you have lazy data.
12:40:32 <jmcarthur> sanjoyd: dmwit's version is normally going to be considered better
12:40:35 <monochrom> the result list may be in the wrong order
12:40:40 <jmcarthur> sanjoyd: because the result can be lazily generated
12:40:44 <sanjoyd> monochrom: assuming I reverse it.
12:40:54 <sanjoyd> But yeah, I got my answer.
12:40:55 <sanjoyd> Thanks!
12:41:01 <monochrom> then it is more expensive
12:41:22 <jmcarthur> i'm not sure it would be strictly more expensive (i've never tested such a thing)
12:41:36 <sanjoyd> So, in the tail recursive version would have to recurse all the way down to [] to even get the first element.
12:41:47 <sanjoyd> But in a non-tail recursive version, I can get the first element right away.
12:41:52 <jmcarthur> basically
12:44:28 <monochrom> tail recursion is a common knee-jerk for those entrenched in eager evaluation. see my http://www.vex.net/~trebla/haskell/lazy.xhtml for a case where it totally makes no difference
12:47:27 <dmwit> Do you know of a situation where tail recursion helps (in Haskell)?
12:47:38 <dmwit> (re: "it depends" above)
12:48:25 <monochrom> yes. when you control some subexpressions to be eagerly evaluated
12:49:27 <luite> ./Handler/Refresh.hs: hGetContents: invalid argument (invalid byte sequence) <- has anyone seen this issue?
12:49:41 <luite> glibc then bails out with a double free or corruption error
12:49:45 <dmwit> Be more careful about choosing your encodings.
12:50:17 <jmcarthur> dmwit: one example is foldl'
12:50:18 <dmwit> e.g. if you expect the file to be in UTF-8, manually hSetEncoding h utf8
12:50:50 <nand`> foldl' isn't tail recursive though; just strict
12:51:58 * dmwit muses aloud: if they had written it as "lgo !z (x:xs) = lgo (f z x) xs", would you consider that tail-recursive?
12:53:29 <adnauseam> is there a way to make lambdabot load a module such as Monad.Applicative ?
12:53:47 <dmwit> Put Applicative.hs in Monad/
12:54:09 <adnauseam> in my lamdabot dir ?
12:54:17 <dmwit> Oh, I misunderstood, sorry.
12:54:19 <dmwit> Ignore me.
12:54:23 <adnauseam> ;p
12:54:32 <adnauseam> is it possible you think ?
12:54:36 <adnauseam> per default
12:54:45 <adnauseam> like > :m Data.Set
12:55:33 <c_wraith> there really isn't such a module as Monad.Applicative
12:55:46 <c_wraith> also, lambdabot has both Control.Monad and Control.Applicative in scope already
12:55:47 <luite> dmwit: hm, isn't the default utf8?
12:55:51 <adnauseam> i probably got the name wrong
12:56:01 <c_wraith> > (+1) <$> [1,2,3]
12:56:02 <lambdabot>   [2,3,4]
12:56:04 <adnauseam> oh
12:56:12 <dmwit> luite: The default depends on your environment variables.
12:56:31 <luite> ah k
12:57:07 <luite> looks like some odd characters ended up in my haskell file
12:57:34 <luite> but i guess the decoding error isn't handled properly by ghc
12:57:56 <dmwit> Huh. If true, that sounds like a bug worth reporting.
12:58:11 <c_wraith> well, if it corrupts libc data structures, it definitely should be reported
12:59:36 <adnauseam> c_wraith: can you give me an examp-le of how to use return ?
12:59:39 <adnauseam> @type return
12:59:40 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:59:47 <c_wraith> > return 5 :: Maybe Int
12:59:48 <lambdabot>   Just 5
12:59:51 <adnauseam> oh
12:59:56 <adnauseam> :o
12:59:58 <c_wraith> normally you don't need a type annotation
12:59:58 <adnauseam> thanks man \
13:00:05 <luite> http://hpaste.org/67393
13:00:58 <c_wraith> heh.  poof goes my internet.  Normally, the type of return is inferred.  Sometimes you need to add a type annotation in lambdabot or ghci, though
13:01:35 <adnauseam> c_wraith: yeah i think i jynxed it ;p
13:01:46 <adnauseam> c_wraith: and thanks man - i'll try it in all 3
13:01:55 <monochrom> as with all uses of type classes, you need enough context to nail the types
13:03:01 <adnauseam> mhm, the notion of "enough" context is interesting
13:03:10 <adnauseam> can there be "too little" context /
13:03:11 <adnauseam> ?
13:03:18 <adnauseam> ambiguity ?
13:03:26 <c_wraith> sure
13:03:29 <c_wraith> > return 5
13:03:30 <nand`> forall a. a   <- too little context
13:03:30 <lambdabot>   No instance for (GHC.Show.Show (m t))
13:03:31 <lambdabot>    arising from a use of `M5433994273...
13:03:44 <monochrom> (read "Just True") alone is not enough context
13:04:48 <monochrom> (main = return 5) is enough context because of implicit type sig for main :: IO ___
13:05:38 <monochrom> "enough context" is fragile, a 1-bit change can toggle it, yes
13:06:23 <monochrom> example: (main = return 5) -> (mbin = return 5), 1-bit corruption, totally opposite results
13:10:06 <adnauseam> monochrom: your last example flew by me ;p
13:12:22 <adnauseam> in
13:12:22 <nand`> I believe the difference between “a” and “b” are two bits in Unicode (and ASCII)
13:12:23 <adnauseam> wopwop :: Maybe Char
13:12:23 <adnauseam> wopwop = do   (x:xs) <- Just ""   return x
13:12:42 <adnauseam> return derives context from wopwop's definition ?
13:13:25 <Eduard_Munteanu> adnauseam: yeah, return's type must unify with wopwop's type
13:13:33 <adnauseam> hm, that's cool
13:13:59 <Eduard_Munteanu> @undo do { (x:xs) <- Just ""; return x }
13:14:00 <lambdabot> Just "" >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
13:14:45 <Eduard_Munteanu> return's return type :)
13:15:28 <adnauseam> oh it can disassemlbe statements :O
13:15:35 <adnauseam> is that called "beta deduction"  ?
13:15:59 <Eduard_Munteanu> That's just how do-notation is defined, more or less.
13:16:02 <adnauseam> someone said those words to me earlier andi was a bit bewildered by tthem
13:16:05 <byorgey> it's called desugaring.
13:16:16 <adnauseam> oh
13:16:18 <byorgey> "beta reduction", probably
13:17:04 <byorgey> beta reduction just means evaluating a function application by substituting the argument for the function parameter.
13:17:43 <Eduard_Munteanu> Remember do-notation is just a convention.
13:18:45 <adnauseam> *rubs his chin*
13:20:04 <Eduard_Munteanu> @undo do { x <- f; g x }
13:20:04 <lambdabot> f >>= \ x -> g x
13:21:13 <Eduard_Munteanu> Basically, for every binding statement you >>= to a lambda.
13:21:37 <Eduard_Munteanu> @undo do { x <- f; y <- g x; h y }
13:21:37 <lambdabot> f >>= \ x -> g x >>= \ y -> h y
13:23:08 <adnauseam> so do is basically kind of like $
13:23:29 <Eduard_Munteanu> Hm? How so?
13:23:36 <adnauseam> only wrapping with >>= instead of ()
13:23:53 <Eduard_Munteanu> Actually, ($) isn't sugar, it's a function.
13:24:24 <adnauseam> sugar is higher-functions that are made of other functions ?
13:24:49 <Eduard_Munteanu> Nah, sugar usually means a certain language feature that's translated by the compiler into simpler stuff.
13:24:58 <adnauseam> oh
13:25:10 <Eduard_Munteanu> Like [1,2,3,4] is sugar for 1:2:3:4:[].
13:25:14 <adnauseam> very subtle
13:25:25 <adnauseam> i always wonder about what [] translates to
13:25:45 <hpc> [] isn't sugar
13:25:48 <adnauseam> c array+pointers and then into assembler and machine code ?
13:25:57 <Eduard_Munteanu> Heh, no.
13:25:59 <adnauseam> is [] c's [] then ?
13:26:04 <nand`> no
13:26:07 <nand`> [] is a linked list
13:26:19 <hpc> [] is the empty linked list
13:26:20 <adnauseam> oh
13:26:30 <adnauseam> wow, didn't think it's a linked list
13:26:37 <hpc> and "[]" itself is a magic identifier that doesn't follow the rules but is specified as legal anyway
13:26:39 <adnauseam> though now that i think about it, it does behave as one
13:26:45 <adnauseam> especially with getting the head and tail
13:26:56 <adnauseam> and iterating with x:xs
13:27:31 <Eduard_Munteanu> data List a = Nil | Cons a (List a)
13:27:42 <nand`> adnauseam: it's more apparent if you look at its definition: data [a] = a : [a] | []    <- what it would look like if this was legal
13:27:55 <adnauseam> that's obvious only to someone who's learned sceheme or something like scheme
13:28:09 <adnauseam> i sadly come from java, and a noob at that, i didn't know what cons was :p
13:28:19 <adnauseam> before i looked it up after bumping into it with haskell
13:28:35 <Eduard_Munteanu> s/cons/tack_at_the_beginning/ then :)
13:28:37 <lucian> scheme is very nice, and so is clojure
13:28:58 <lucian> i find haskell's use of lists for strings quite pragmatic
13:29:05 <adnauseam> i looked at clojure and saw () hell :p
13:29:24 <Eduard_Munteanu> lucian: it's not really a good idea wrt performance, though
13:29:26 <lucian> adnauseam: it has quite a few data literals, and they're useful
13:29:30 <adnauseam> nand`: yeah i understandthat. but what do you mean by legality ?
13:29:43 <nand`> adnauseam: I believe the line I gave is not valid haskell for syntax reasons
13:29:44 <lucian> Eduard_Munteanu: in some ways, it's good for that too, they're "ropes" by default
13:30:11 <lucian> Eduard_Munteanu: and things like utf-8 become somewhat redundant, since you can just have variable length code points
13:30:11 <adnauseam> oh, strang..
13:30:45 <adnauseam> data [a] being the illegal part ?
13:31:05 <Anpheus_> I'm running xmonad with xfce in a Linux VM (xubuntu) and everything is great except some hotkeys are clearly being hooked by other parts of xfce
13:31:16 <Anpheus_> I've disabled almost all of the keyboard shortcuts in xfce
13:31:26 <byorgey> adnauseam: yeah, and also the [] part
13:31:36 <Anpheus_> but things like meta-key-l are still set to lock the desktop
13:31:43 <byorgey> adnauseam: lists just have special built-in syntax
13:31:48 <Anpheus_> So, how do I make xmonad top dog in terms of hotkeys?
13:31:49 <nand`> note that String = [Char] has its own disadvantages; 1. lots of memory consumption, 2. some common operations are very inefficient (eg. length or ++)
13:31:49 <adnauseam> byorgey: i understand
13:31:54 <Anpheus_> How do I force it to own all the keys?
13:32:30 <adnauseam> Anpheus_: chlorophorm
13:32:40 <adnauseam> :P
13:32:45 <geekosaur> Anpheus_, that has to be configured in whatever hypervisor you're using
13:32:48 <Anpheus_> was not sure if actual package on ubuntu repos or whatever
13:32:50 <Anpheus_> No no
13:32:58 <Anpheus_> The VM is getting the keys
13:33:03 <Anpheus_> but something in xubuntu is getting them before xmonad
13:33:15 <Anpheus_> for example, before I removed all the xubuntu keyboard shortcuts in the control panel
13:33:23 <Anpheus_> windows key j did something else
13:33:25 <Anpheus_> windows key 1 did something else
13:33:33 <Anpheus_> getting rid of those let xmonad use them
13:33:41 <srhb> I'm curious about the gloss interfaces. There's a play and a playIO.. Which one should I use?
13:34:15 <Anpheus_> so
13:34:28 <Anpheus_> So how do I make sure xmonad is not failing to register hotkeys?
13:34:59 <rasfar> Anpheus_ you have my sympathy, event ownership problems can be very difficult to sort out in a multilayered UI, especially if you don't want to hack the sources.
13:35:12 <srhb> Anpheus_: Perhaps you should ask the xfce peeps?
13:35:39 <srhb> Anpheus_: Otherwise known as "if Xmonad doesn't receive, Xmonad can't fix."
13:35:40 <Anpheus_> I figured someone might have run into these issues here, I've followed the xfce/xmonad doc on the haskell wiki to the tee
13:35:48 <srhb> That document is ancient.
13:35:52 <srhb> Mythic, in fact.
13:35:56 <Anpheus_> Legendary?
13:36:04 <srhb> Probably. :-)
13:44:50 <byorgey> srhb: use play if you can, or playIO if you need it.
13:44:59 <kejoki> Arch packages don't come with docs (eg, haddock.)  Can I use cabal to generate docs?  Where do those man pages in Debian come from?  I'm frequently in situations where I don't have a decent net connection.
13:46:21 <dmwit> kejoki: Yes, your ~/.cabal/config has a setting for executable and library documentation.
13:48:40 <luite> hmm what's this: http://hpaste.org/67394
13:49:41 <Lemon> so what was the haskell channel for semi-off-topic discussions again?
13:49:48 <geekosaur> looks like a type name with a character missing from your current locale
13:49:50 <dmwit> luite: Just use a utf8 locale already. =P
13:50:05 <dmwit> Lemon: -blah
13:50:07 <ion> Someone doesn’t use an UTF-8 locale in 2012? ಠ_ಠ
13:50:08 <Lemon> oh okay
13:50:30 <dmwit> Or at least a full-Unicode locale.
13:50:40 <dmwit> Doesn't have to be UTF-8 if you prefer another encoding. =)
13:51:21 <adimit> only after trying to use pip and gem did I come to appreciate what a boon cabal is, despite dependency hell.
13:51:34 <luite> dmwit: hehe, I think upgrading ubuntu to 12.04 messed up some locale settings
13:52:50 <srhb> join #haskell-blah
13:52:54 <srhb> oops
13:53:23 * kejoki )@^^!+  ...  old dogs like man pages!  
13:55:51 <vodik> can anyone point me in the right direction? how do i deal with cabal errors like <command line>: cannot satisfy -package-id entropy-0.2.1-fb9e52907f778bb6c4ed7ef30e3df0e9
13:55:54 <vodik> http://sprunge.us/AEgb?text
13:57:00 <luite> ion: well it was just some upgrade issue that i hadn't fixed yet, but I did find some interesting problem (bug?) thanks to this :p
13:57:33 <luite> the second one was not a bug though, just annoying people using unicode type names :p
13:58:17 <dmwit> vodik: ghc-pkg check
13:59:20 <dmwit> I wonder if cabal has an option like --ghc-verbose to complement --verbose.
14:02:33 <willsteps> Hello all. I have a load of functions that are all of type State -> (Result, State). I know that this pattern suggests a monad, but I can't make it work. I'm sure I've in the past seen tutorials about this pattern and how to  make it into a monad but I can't find them. Anyone know what I'm talking about?
14:03:00 <hpc> @hoogle State
14:03:01 <lambdabot> Control.Monad.State module Control.Monad.State
14:03:01 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
14:03:01 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
14:03:24 <vodik> dmwit: ah, thanks, that set me on the right track. i removed some system wide libs weren't fully unregistered
14:03:33 <hpc> (the source for State is odd because it's defined in terms of StateT, but the concept is exactly the same)
14:03:54 <dmwit> ?where aam
14:03:54 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
14:04:07 <dmwit> http://www.haskell.org/haskellwiki/All_About_Monads#The_State_monad
14:04:13 <willsteps> hpc: Thanks, I know about the State monad, and monads in general, but I can't seem to figure out how to apply it to create my own monad for this purpose.
14:04:20 <t7> bitonic & other guys who know hindley milner: cant i generate a list of substitutions/constraints and apply them all afterwords rather than as i walk the Expression tree?
14:04:24 <olddog> willsteps: The wikibook has a pretty good section on ... drat you dmwit.  I type too slow.
14:04:27 <t7> might look a bit clearer
14:04:30 <hpc> ah
14:04:34 <dmwit> willsteps: You might also like http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
14:04:37 <byorgey> willsteps: if you import Control.Monad.State, you can use the 'state' function to turn something of type  S -> (Result, S)  into a monadic action of type  State S Result
14:04:54 <byorgey> @type state
14:04:55 <lambdabot> forall s a. (s -> (a, s)) -> State s a
14:05:01 <byorgey> voila!
14:05:21 <willsteps> byorgey: I dont' want to expose the State monad as my API though. Surely that's an implementation detail and I want an opaque monad of my own typing. Can I wrap it somehow?
14:06:28 <byorgey> willsteps: sure,  newtype MyMonad a = MyMonad { runMyMonad :: State S a }  deriving (Functor, Applicative, Monad, MonadState S)
14:07:13 <byorgey> (be sure to enable GeneralizedNewtypeDeriving)
14:07:24 <dmwit> huh, does MonadState S work?
14:07:37 <dmwit> neat
14:07:40 <byorgey> yep
14:09:13 <bobfang> Is there any way I can convert a string to reverse polish form?
14:09:35 <dmwit> ?where parsec
14:09:35 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
14:09:52 <dmwit> ?where+ parsec http://legacy.cs.uu.nl/daan/parsec.html
14:09:52 <lambdabot> Done.
14:10:20 <dmwit> bobfang: enjoy =)
14:10:30 <bobfang> dmwit:Thanks
14:20:55 <hpc> @google shunting-yard algorithm
14:20:57 <lambdabot> http://en.wikipedia.org/wiki/Shunting-yard_algorithm
14:20:57 <lambdabot> Title: Shunting-yard algorithm - Wikipedia, the free encyclopedia
14:21:41 <tgeeky> @google bender the magnificient
14:21:43 <lambdabot> http://www.myspace.com/tidesil/music/songs/bender-the-magnificent-71241686
14:21:43 <lambdabot> Title: Bender The Magnificent by Tides- (RIP?!) | Song | Free Music, Listen Now
14:22:12 <hpc> heh
14:22:26 <tgeeky> myspace? I am disappoint.
14:22:36 <adnauseam> .jpg
14:22:52 <tgeeky> @google Good News, Everyone!
14:22:54 <lambdabot> http://www.youtube.com/watch?v=1D1cap6yETA
14:22:54 <lambdabot> Title: Good News Everyone! - YouTube
14:23:12 <adnauseam> @google i don't want planet anymore
14:23:14 <lambdabot> http://www.youtube.com/watch?v=35TbGjt-weA
14:23:15 <lambdabot> Title: I don't want to live on this planet anymore - YouTube
14:23:23 <HugoDaniel> hmm
14:24:09 <dmwit> ?quote
14:24:10 <lambdabot> sioraiocht says: was dons PhD in writing random haskell libraries?
14:26:12 <pqmodn> t7: yes, i think for instance "algorithm M" and "algorithm W" perform unification at different places, causing errors to be caught at different places
14:26:31 <tgeeky> dmwit: thanks for the reply re: negative and fractional types. Specific questions? Yes, I have them, but I don't want to waste time
14:28:30 <dmwit> hah
14:28:47 <dmwit> Well, I just gave a one-hour talk about the paper yesterday, so I've got it fairly fresh in mind if you want to talk now.
14:29:10 <dmwit> (Actually, I only gave half the talk or so -- turns out it takes longer to explain this stuff than I thought!)
14:30:10 <tgeeky> dmwit: Cool. I wish I was there. :(
14:30:11 * byorgey thinks dmwit's time was wasted by silly questions from people who hadn't done the homework =(
14:30:25 * tgeeky unwishes
14:30:31 <dmwit> There was some of that, I think, yeah. =)
14:31:12 <byorgey> dmwit: maybe you can give me the second half of the talk sometime soon
14:31:38 <dmwit> Yeah, sure!
14:31:49 <dmwit> I mean, it will just be a drawn-out version of the last five minutes, I think.
14:31:51 <tgeeky> dmwit: well, the first general question is -- what am I to think of when they speak of the language pi, and the language PI+ne? Is this a language on the level of System F+? "low level"?
14:32:09 <tgeeky> or on the Haskell core level?
14:32:10 <dmwit> Yes, it's a very small calculus.
14:32:30 <tgeeky> but this is perfectly implementable in Haskell, byorgey tells me.
14:32:33 <dmwit> Though I don't think it has the goal of being efficiently implementable (which the ones you mentioned sort of are).
14:32:43 <tgeeky> dmwit: ok. that's true.
14:33:11 <dmwit> The only thing you'd have to think briefly about during an implementation is how and when to do unification.
14:33:12 <tgeeky> dmwit: as a physicist, I have started writing the authors an email to be more careful in mentioning physics analogies and quantum things
14:33:27 <dmwit> (I have the beginning of an implementation here, and they claim to have a complete interpreter.)
14:33:55 <tgeeky> dmwit: So, you've done a lot of work on invertible computation and things. This seems to be a much more "low level" approach?
14:34:38 <dmwit> Well... I think their goal is to have a model of computation rather than a convenient language for computation. =)
14:35:01 <dmwit> But anyway Pi seems like a pretty complete language for isomorphisms (as does Pi+negatives).
14:35:15 <dmwit> Can't say I've reconciled myself to Pi+reciprocals yet.
14:35:57 <dmwit> Anyway, yes, I think describing this as "low level" is fair.
14:36:10 <tgeeky> dmwit: I'm pretty naive here, but even without going into the physics analogies, it seems to me like the you could use this toolkit to understand/observe/investigate situations where things are non-commutative (or even non-associative) like the quaternions/octonions
14:36:55 <dmwit> Can you elaborate a bit?
14:37:20 <tgeeky> dmwit: for instance, you might want to compute with fractional quaternions: 1/a + i/b + j/c + k/d
14:37:37 <tgeeky> this I presume would casue (3*4) = 12 simultaneous values to be created
14:37:51 <tgeeky> and then you'd need a bunch more functions to list the right and left associates
14:37:59 <tgeeky> err, left and right commutators
14:38:06 <tgeeky> or maybe both?
14:38:44 <dmwit> I suppose you'd need to start with a computational interpretation for i, j, and k, no?
14:39:03 <tgeeky> dmwit: for instance, the inversion of the unit quaternion: (1 + i + j + k) = (1 - i - j - k)/4
14:39:54 <tgeeky> dmwit: I think so. I would say their intepretation is 'trivial' but then again, I would have said that 0 + a = a + 0 = a is "trivial"
14:40:29 <dmwit> Well, what are the inhabitants of the type i?
14:41:04 <tgeeky> dmwit: hmm. I would have to guess.
14:41:28 <tgeeky> man... irssi is driving me MAD with these join/quits.
14:42:12 <monochrom> then don't use irssi. use manatee :)
14:42:18 <tgeeky> monochrom: do you?
14:42:29 <monochrom> I use xchat
14:42:32 <tgeeky> I thought that nobody except the guy who made it, use manatee :o
14:42:39 <monochrom> heh
14:42:40 <pqmodn> there's a way to configure JOIN/PART messages per-channel...
14:42:48 <tgeeky> pqmodn: yes, I've done that and it's now ignoring me
14:43:00 <pqmodn> (i can't seem to find it again)
14:43:03 <tgeeky> pqmodn: in fact, the window level doesn't have join part or quit in it... but it's still displaying
14:43:09 <dmwit> Every few months I toggle whether I have join/part messages display or not.
14:43:29 <dmwit> When you have them, it's annoying; when you don't have them, you sometimes respond to people who already left and get chided by co-conspirators.
14:43:35 <tgeeky> dmwit: so I'm ruling out void. My guess is that it's not (), either.
14:43:42 <dmwit> void and () are 0 and 1
14:43:48 <tgeeky> yeah, and it's like 1
14:43:51 <tgeeky> but it's a different 1 than 1
14:44:07 <tgeeky> well, it's like i
14:44:18 <tgeeky> > 2 :+ 2
14:44:19 <lambdabot>   2.0 :+ 2.0
14:44:40 <dmwit> In the paper, they discuss how algebraic numbers arise from recursive types. Do you really want to think about recursive types with negatives in them...?
14:44:59 <tgeeky> dmwit: yes, actually. that's exactly what I need to think about.
14:45:08 <dmwit> In any case, it doesn't seem trivial to me. Probably worth an entire paper if you have a good computational interpretation of i, j, and k!
14:45:13 <tgeeky> dmwit: I mean... I'm an idiot. I want my computer to think about it.
14:45:16 <kallisti> you could just use one of the existing bijections from natural numbers to integers
14:45:20 <kallisti> to model negative integers
14:45:27 <kallisti> though it may make defining operations difficult.
14:45:40 <kallisti> you need one that makes addition and multiplication easy.
14:45:50 <byorgey> kallisti: that's not really very interesting though. then you're not really saying anything about negative numbers at all.
14:46:25 <kallisti> ..I'm saying they're structurally the same as the natural numbers. :P
14:46:31 * byorgey agrees that a computational interpretation of i would be worth a paper
14:46:32 <kallisti> is that not enough? sheesh.
14:47:04 <tgeeky> at the risk of sounding stupid, what does one mean when one says "computation interpration of i"
14:47:14 <tgeeky> or is that the puzzle worth a paper?
14:47:26 <byorgey> kallisti: but they're *not* structurally the same.  they have the same cardinality.  But I don't think you can find any bijection which preserves the behavior of + and *
14:47:35 <dmwit> tgeeky: One means you've come up with a class of values and operations that behave "like i" does.
14:47:58 <dmwit> tgeeky: We say that the set of values {()} is a good interpretation of the type 1 because it behaves like 1: there's a product for which it's a unit, etc.
14:48:04 <tgeeky> dmwit: certainly the involutions of conjugation come into play
14:48:08 <byorgey> for example, you would want isomorphism between types corresponding to the algebraic laws one expects to hold of i.
14:48:09 <kallisti> byorgey: ah I see what you mean
14:48:20 <tgeeky> dmwit: i, is, of course, a group of order 4
14:48:27 <dmwit> tgeeky: We say that the empty set of values {} is a good interpretation of the type 0 because it behaves like 0: there's a sum for which it's a unit, and a product for which it's an annihilator.
14:48:44 <tgeeky> dmwit: hmm. nobody has said that, that way, to me yet
14:48:55 <dmwit> tgeeky: You didn't read the paper very carefully, then. =)
14:49:03 <tgeeky> dmwit: they never used the phrase empty set
14:49:05 <tgeeky> dmwit: not once!
14:49:15 <dmwit> Yes, but there aren't any values that have type 0. =)
14:49:52 <byorgey> the paper definitely had a sentence 'there are no values of type 0'.
14:50:00 <tgeeky> byorgey: yes, which we talked about.
14:50:25 <tgeeky> it also says that 0 won't correspond to a particle on a wire, which I'm just ignoring to avoid physics analogies.
14:50:46 <tgeeky> don't ever get a physicist started about |0>.
14:50:57 <dmwit> Anyway, what one would mean by "a computational interpretation of i" is a new syntactic class of values, together with semantic rules for manipulating those values, such that there were operations that looked like conversions between i*i and -1
14:51:29 <dmwit> Uh, I think |0> is pretty different than this...
14:51:35 <dmwit> It's more like |>, I think.
14:51:40 <dmwit> No particle, not even one in a 0-state!
14:51:50 <tgeeky> dmwit: right, but that's not even defined.
14:51:55 <dmwit> Exactly!
14:52:06 <tgeeky> dmwit: actually, it's explicitly undefined in physics. Where you expect nothing, you will find something.
14:52:29 <tgeeky> dmwit: I see what you mean, though :)
14:53:11 <tgeeky> dmwit: another question. What would be involved in allowing definitions like the list on the topleft of page 3
14:53:15 <tgeeky> from being a reality in Haskell
14:53:26 <dmwit> whoops, let me pull up the paper again
14:53:47 <tgeeky> zeroe : 0 + b <-> b : zeroi
14:53:48 <tgeeky> etc
14:54:15 <tgeeky> I don't think I have seen this kind of layout before (maybe in some of your papers), but it seems very handy
14:54:30 <tgeeky> I was a little confused about the double definition of "swap+" and "swapx"
14:54:42 <byorgey> tgeeky: those are their own inverse
14:54:53 <byorgey> that;s why they're listed on both sides
14:54:53 <DrSyzygy> oh, are we talking about the fractional and negative types thingie?
14:54:56 <dmwit> Yeah, swap+ and swap+ just happen to have the same type and implementation.
14:54:59 <dmwit> DrSyzygy: yes
14:55:00 <byorgey> yep
14:55:06 <DrSyzygy> delightful paper!!
14:55:09 <tgeeky> byorgey: yes, but eg. if I were to make this syntatic sugar, I would need to tell the program not to try to define them twice.
14:55:26 <byorgey> DrSyzygy: indeed.  dmwit just gave a delightful talk about it to the PL group at Penn
14:55:35 <DrSyzygy> awesome
14:55:40 <dmwit> yaaaay, people like me!
14:55:41 <DrSyzygy> oh, dmwit: you at penn??
14:55:45 <dmwit> I am!
14:55:49 * DrSyzygy will be visiting there in July!!
14:55:51 <DrSyzygy> 14-18.
14:55:55 <kallisti> byorgey: is data Integer = Positive Peano | Negative Peano  a more interesting definition? :P
14:55:58 <byorgey> =D
14:55:59 <tgeeky> byorgey: geting diagrams to draw these kinds of ... diagrams... in this paper. Would be a killer app for sure.
14:56:08 <tgeeky> kallisti: no
14:56:12 <dmwit> DrSyzygy: Cool, let's meet up! Also, too bad you weren't coming just a tad later for Hac Phi... =P
14:56:18 <DrSyzygy> sorry
14:56:26 <DrSyzygy> my summer is kinda ridiculously full planned
14:56:34 <byorgey> DrSyzygy: awesome!
14:57:00 <byorgey> dmwit: he'll be here for the ICFP programming contest though
14:57:07 <DrSyzygy> I will?
14:57:11 <byorgey> yes
14:57:16 <DrSyzygy> ... not gonna volunteer for your team though.
14:57:23 <byorgey> according to my calendar, at least
14:57:24 <byorgey> hehe
14:57:26 <DrSyzygy> I have collaboration partners hosting me ;-)
14:57:36 <byorgey> I know =)
14:57:38 <DrSyzygy> y'know, actual research leading to papers and shit like that ;-)
14:57:48 <tgeeky> dmwit: the other "main question" (a general question, not a specific one) is about how this stuff interacts with the third-list-homomorphism work, the "unfolding from the center" ideas
14:57:49 <dmwit> Awesome.
14:57:51 <byorgey> yawn
14:58:09 <DrSyzygy> third-list-homomorphism?
14:58:15 <dmwit> unfolding from the center?
14:58:41 <tgeeky> dmwit: DrSyzygy: http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf
15:00:27 <dmwit> I haven't seen this.
15:00:41 <dmwit> So I certainly can't relate the two.
15:03:23 <dmwit> I will say there's a pretty significant difference between relations and isomorphisms.
15:03:36 <dmwit> (Though they share many operations.)
15:04:36 <kallisti> dmwit: they're similar in that they're both relations, no?
15:04:38 <kallisti> :P
15:04:45 <DrSyzygy> ...
15:04:49 <DrSyzygy> very many things are
15:05:09 <dmwit> tgeeky: In the paper you linked, do Lemma 3 and Corollary 5 not precisely contradict each other?
15:05:55 <tgeeky> dmwit: lemma 3 is proof that they don't dualize
15:05:59 <tgeeky> proof by example
15:06:02 <tgeeky> lemma 5 is...
15:06:17 <DrSyzygy> Corollary 5 says they do.
15:06:35 <tgeeky> dmwit: oh, not necessarily. 5 is on the domain of relations
15:06:43 <dmwit> aha
15:06:47 <dmwit> Okay.
15:07:04 <dmwit> I'm not going to finish reading this right now (there's game night tonight!), but it looks like an interesting paper. Thanks for the tip.
15:07:07 <tgeeky> dmwit: I don't understand relations well enough to say if they do, but I assumed they don't automatically (assumption through ignorance)
15:07:16 <tgeeky> dmwit: np. there are a few more. I'll find the links and tell lambdabot for you
15:09:22 <tgeeky> dmwit: sjoerd ________ recently made a package describing part of this paper.
15:09:41 <dmwit> visscher?
15:09:48 <tgeeky> yep
15:10:33 <relation> hi, is there a way to pattern match data constructor without explicitly putting all the "_" "_" if i know, they wont be used? like u@(NewData ...), instead of u@(NewData _ _)
15:10:47 <tgeeky> relation: nope (I think)
15:11:13 <dmwit> u@(NewData {})
15:11:25 <relation> dmwit: :) thanks
15:11:27 <tgeeky> dmwit: really?
15:11:42 <dmwit> tgeeky: quite a hack, no?
15:11:58 <tgeeky> dmwit: it doesn't complain that your record thingy doesn't have the right number of elements? lol
15:12:02 * adnauseam saves it to his baby.hs file 
15:13:00 <DrSyzygy> dmwit: Neat.
15:13:48 <tgeeky> dmwit: aha. aptply named: http://hackage.haskell.org/package/unfoldable
15:17:09 <hpc> tgeeky: when you do a record match, it determines which records to match with the ones you give, and desugars the rest to '_'
15:17:29 <tgeeky> hpc: that sounds less dirty
15:17:30 <hpc> so (Foo {}) desugars to (Foo _ _ _ ...)
15:17:42 <tgeeky> hpc: and that works when partially applied?
15:17:59 <tgeeky> (Foo {a,b}) -> (Foo a b _ _ _...)?
15:17:59 <hpc> dunno
15:18:07 <hpc> oh, that doesn't work
15:18:14 <hpc> record matches are like
15:18:22 <Saizan> Foo {a = p, b = q} does
15:18:43 <tgeeky> Saizan: so if foo had 5 fields, it would put _ in the last 3?
15:18:45 <hpc> foo (Foo {width = w; height = h; subtree = t}) = foo t * w * h
15:18:49 <tgeeky> that's pretty neat, if so. It's kind of neat anyway.
15:18:56 <hpc> er, those should be commas
15:19:08 <Saizan> tgeeky: it would put _ in the ones that aren't a and b, it's for named fields, not positional
15:19:24 <hpc> if you try and do a record match like {foo = bar} on something that doesn't have foo, that's a compile error
15:19:46 <hpc> yeah, named fields only
15:20:19 <hpc> it's still a hack, but a "desugaring" hack, not a "magic special case for lulz" hack
15:20:35 <hpc> (the original {} thing)
15:29:50 <`Jake`> Wow, I should really get better at improving the perfomance of my haskell code... I wrote two small programs which do the same, in haskell and in Java, and the java-program is like 100 times as fast... At least I have the excuse that I didn't even know haskell a few weeks ago
15:30:25 <jmcarthur> `Jake`: they probably aren't actually the same program with that big of a difference
15:32:00 <jmcarthur> `Jake`: do feel free to stick your code on hpaste.org and see if somebody here might help you improve it
15:32:46 <`Jake`> Ok, but take care, it might look really noobish^^
15:33:00 <jmcarthur> that's the point :)
15:34:27 <`Jake`> yeah... Well, it might be important to know that t's about the Monty hall problem, which is aboutthe tv-show let's make a deal, I don't know if anyone knows that problem
15:34:36 <`Jake`> and let me add aa few comments really quickly
15:35:07 <`Jake`> sorry for the typos, I have to get used to my new keyboard
15:37:00 <jmcarthur> i know the monty hall problem
15:37:24 <`Jake`> ok
15:39:06 * BMeph thought the Monty Hall problem was: not enough goats...
15:39:11 <ramier> is there a good guide on how to format haskell? so i know the correct way to lay out a long function, with indentation and stuff
15:40:06 <hpaste_> “`Jake`” pasted “Monty Hall with bad performance” at http://hpaste.org/67398
15:40:22 <`Jake`> Oh, hpaste shows some errors
15:40:56 <Cale> ramier: basically, don't use tabs (configure your editor to use spaces only), and if something is part of something else, it should start in a deeper column, and if two things are siblings, they should line up vertically
15:41:28 <Cale> `Jake`: those aren't real errors though
15:41:28 <`Jake`> Even though I don't understand them... GHC compiled it
15:41:32 <`Jake`> ah ok
15:41:53 <`Jake`> OH, I can cick on them
15:41:57 <`Jake`> click*
15:42:00 <`Jake`> alright
15:42:30 <Cale> actually, its suggestion in one place to use uncurry would be better off as pattern matching
15:42:44 <Cale> You could say  (us, vs) = splitList xs
15:42:56 <jmcarthur> `Jake`: looks like there's a little wastefulness, but nothing blatantly terrible for performance. certainly doesn't look like anything warranting a 100 times slowdown...
15:43:08 <jmcarthur> `Jake`: how are you building it?
15:43:32 <`Jake`> I didn't really do anything special, I tried it with runhaskell and ghc --make
15:43:40 <Cale> Personally, I would tend to solve this kind of problem in a probability monad, rather than using random sampling, and calculate exact answers :)
15:43:48 <jmcarthur> `Jake`: try  ghc -O2 --make
15:43:50 <`Jake`> ok
15:44:05 <`Jake`> thanks
15:44:06 <jmcarthur> `Jake`: make sure to use -fforce-recomp if you haven't edited it
15:44:15 <`Jake`> ok, I'll do that
15:44:29 <`Jake`> oh, wait, I have edited it
15:45:35 <`Jake`> ghc: unrecognised flags: -02
15:45:43 <jmcarthur> O, not 0
15:45:47 <`Jake`> oh
15:47:34 <Useful-> O for 'optimise'
15:48:06 <`Jake`> I  tried to run it with 10000 samples, but it doesn't do anything now
15:48:16 <jmcarthur> err...
15:48:24 <jmcarthur> are you sure you didn't change anything else?
15:48:40 <jmcarthur> try it with runhaskell again to make sure?
15:48:40 <`Jake`> Pretty sure, yeah
15:48:43 <`Jake`> yeah
15:48:46 <`Jake`> runhaskell works
15:48:50 <jmcarthur> uh...
15:48:56 <jmcarthur> what version of ghc are you using?
15:49:07 <jmcarthur> i'll try it here
15:49:35 <`Jake`> is that the same as the ghci version?
15:49:53 <ramier> quick question; how do i map a tuple over a list? if i wanted to do "map (x, 0) [Clubs, Spades, Diamonds, Hearts]" and get back [(Clubs, 0), (Spades, 0), (Diamonds, 0), (Hearts, 0)]? and i haven't read past chapter 7 in learn you a haskell :)
15:50:12 <blackdog> ramier: have a play with repeat and zip
15:50:17 <ramier> oh
15:50:28 <jmcarthur> `Jake`: it seems to work for me with version 7.4.1
15:50:30 <ramier> i'll look into those, thanks
15:50:35 <jmcarthur> `Jake`: ghc --version
15:51:03 <`Jake`> 7.0.3... I'll update
15:51:19 <jmcarthur> ah there is a space leak. means there's some low hanging fruit. i'll look more closely
15:51:51 <jmcarthur> but nonetheless it does seem to be working for me at least, apart from the space leak
15:51:57 <Phlogistique> ramier: map (\x -> (x, 0))
15:52:29 <ramier> oh or that
15:52:29 <`Jake`> Is it a known issue that this doesn't work in 7.0.3?
15:52:37 <jmcarthur> no
15:52:38 <ramier> i came up with zip [Clubs, Spades, Diamonds, Hearts] $ repeat [0] too
15:52:40 <ramier> haskells so fun
15:52:58 <jmcarthur> i suspect you're just doing something weird, but i don't know what it could be
15:53:16 <`Jake`> Yeah... I guess I'll figure it out at some point
15:53:19 <blackdog> ramier: think you might mean "repeat 0"
15:53:22 <blackdog> but otherwise yes :)
15:53:54 <ramier> its like dancing
15:54:16 <jmcarthur> `Jake`: computeProbs *is* pretty wasteful and makes many passes over the list. i bet you could do it in just one pass, allowing it to be constructed and GCed a bit at a time
15:54:33 <blackdog> ramier: that's a fascinating simile - how so?
15:54:55 <`Jake`> OK... 'll compare it with my java method pretty quickly
15:54:59 <`Jake`> I*
15:55:47 <`Jake`> just because my java program is extremely similar to the haskell program
15:55:59 <ramier> one day when i know what I'm doing, it feels like i can make complex stuff happen through a few simple functions
15:56:46 <jmcarthur> `Jake`: also, i don't think i understand splitLists
15:56:58 <jmcarthur> *splitList
15:57:29 <`Jake`> Splitlist takes a list like [a,b,c,d,e,f] and splits it into [a,c,e] and [b,d,f]
15:57:35 <`Jake`> splitList
15:57:39 <jmcarthur> i see
15:57:57 <jmcarthur> you might be interested in System.Random's split
15:58:31 <`Jake`> ok, I'll look at that, also, I have found out my silly mistake about ghc -O2 --make
15:59:13 <hpc> jmcarthur: that split is totally unrelated
15:59:15 <hpc> :t split
15:59:16 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:59:27 <hpc> it splits a RNG into two RNGs
15:59:33 <jmcarthur> hpc: right
15:59:33 <hpc> and isn't really that sane of an operation
15:59:34 <`Jake`> I tried to give it an argument, like I would do it with the Java program, but obviously, that doesn't do anything
15:59:48 <jmcarthur> hpc: and he's using splitList to split a list of randomly generated values into two
15:59:56 <hpc> oh
15:59:57 <jmcarthur> hpc: he could have just generated two separate lists
16:00:00 <hpc> lol, that makes sense
16:00:48 <jmcarthur> `Jake`: your program?
16:00:53 <jmcarthur> `Jake`: you can make it take an argument
16:01:02 <`Jake`> jmcarthur: should I?
16:01:07 <jmcarthur> it's up to you?
16:01:19 <jmcarthur> getArgs, i think it is
16:01:29 <jmcarthur> might need to import System.Environment or something
16:01:34 <hpc> :t getArgs
16:01:35 <lambdabot> Not in scope: `getArgs'
16:01:43 <jmcarthur> :t System.Environment.getArgs
16:01:43 <lambdabot> IO [String]
16:01:48 <hpc> yeah, that
16:01:51 <`Jake`> jmcarthur: yeah, I know... I thought that it wouldn't make much difference, but I had to do it in the java-program
16:02:00 <jmcarthur> had to?
16:02:06 <`Jake`> because doing it the other way is not realy worth it in java
16:02:10 <`Jake`> overly complicated
16:02:18 <`Jake`> really*
16:02:28 <jmcarthur> i'm not sure i buy that. why would it be any more complicated than in haskell?
16:03:07 <`Jake`> because there's no getLine function... I'm pretty sure that the argument method is way easier in java
16:03:57 <jmcarthur> don't you just open a BufferedReader or somesuch?
16:04:06 <adnauseam> > length how would i go about determining a string's length ?
16:04:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:04:18 <jmcarthur> > length "like this"
16:04:19 <lambdabot>   9
16:04:21 <`Jake`> Yeah, but compared to a simple argument, it's more complicated ;-)
16:04:27 <adnauseam> shit i'm slow.
16:04:28 <adnauseam> thanks man
16:04:54 <jmcarthur> i think the argument way is simpler in haskell than the interactive way, too
16:04:55 <hpc> haha, wow
16:05:37 <hpc> adnauseam: if it makes you feel better, i just finished going through some #haskell logs and saw someone in 2006 ask "i am trying to get the length of a string but it says lenght isn't in scope?"
16:05:51 <jmcarthur> haha
16:06:02 <`Jake`> I think Java's way is still more complicated... Anyway, it doesn't really matter, as I said,  I didn't really care if it was interactive or not
16:06:05 <gdeest> @pl (\x -> (+) x $ (+1) x)
16:06:05 <lambdabot> ap (+) (1 +)
16:07:21 <LambdaDusk> anyone have a moment to help a dumb idiot? I have this: PonyServerPart (ReaderT (MongoPool e) (ErrorT e (ClientSessionT PonySession (ServerPartT m))) a) and I want to write runServer in which I somehow reach the middle ServerPart by using runReaderT, runErrorT and runClientSessionT
16:08:38 <adnauseam> hpc ; i still feela wee bit retarded tonight
16:08:44 <adnauseam> the beer's effect is wearing off
16:08:53 <adnauseam> i only got 1 left.. not sure if i should open it
16:09:02 <tgeeky> LambdaDusk: a dumb idiot?
16:09:26 <hpc> LambdaDusk: so i should be helping adnauseam then ;)
16:09:33 <LambdaDusk> I feel so dumb for not being able to untable chained transformers
16:09:55 <Brolapse> how do i go about formatting strings in haskell? e.g. floating point to 2 decimal places
16:09:58 <Brolapse> and proper padding
16:10:01 <hpc> LambdaDusk: start by running the outside first, and working your way inward
16:10:21 <hpc> Brolapse: same way as in C, more or less
16:10:31 <LambdaDusk> hpc: This is what I thought as well, but with a "let" or with a "<-"
16:10:43 <hpc> :t printf
16:10:44 <lambdabot> forall r. (PrintfType r) => String -> r
16:11:02 <hpc> in C you would printf, then figure out why it's printing pointer garbage
16:11:13 <hpc> in haskell, you use printf and then feel really bad about abusing the type system that way
16:11:50 <hpc> LambdaDusk: "without let or <-" sounds a lot like homework :P
16:12:10 <LambdaDusk> hpc: There you misread my question
16:12:14 <hpc> LambdaDusk: nice thing about let...in, is that if the definitions aren't mutally recursive you can transform code like this:
16:12:26 <hpc> let y = f x in g y ==> g (f x)
16:13:43 <hpc> im too sleepy to untangle that stack of monads myself, but just go outside-in with let-in until you get where you want, then remove the let-ins
16:14:54 <MHD0> Is there any strong Arrow Parser library with functionality akin to Parsec?
16:15:20 <MHD0> Like, based on that brilliant paper on LL(1) grammars
16:16:23 <LambdaDusk> I somehow don't get through the ErrorT, because the ClientSessionT doesn't seem to have an instance for it
16:17:26 <copumpkin> MHD0: I think arrow-based parsers have fallen out of fashion, in favor of applicative
16:22:28 <kallisti> copumpkin: fashion is one thing. The question is: which is better?
16:22:55 <copumpkin> kallisti: applicatives correspond more clearly to CFGs, I'd expect
16:23:03 <copumpkin> which is how most people expect to write their grammars
16:23:17 <kallisti> I've never used an arrow-based parser, but I do find applicative parsers intuitive.
16:24:01 <copumpkin> http://www.haskell.org/haskellwiki/Arrow#Parser
16:28:01 <adimit> When I get a String from ghci that contains escaped number sequences, what exatcly are those? Unicode control chars? Say, I get "\195\188"?
16:28:26 <adimit> they're obviously not octal, so I guess they're decimal representations of unicode control chars?
16:29:32 <kallisti> > ord '\195'
16:29:33 <lambdabot>   195
16:31:05 <adimit> kallisti: so I take it, it's the int representation of a unicode character…
16:32:09 <kallisti> adimit: it's decimal, yes
16:32:22 <kallisti> adimit: oh you mean the result of ord? yes, that's what ord does.
16:32:40 <adimit> kallisti: well, ord is a wrapper around fromEnum, so I figured :-P
16:32:51 <kallisti> > chr 195
16:32:52 <lambdabot>   '\195'
16:32:55 <kallisti> :t ord
16:32:56 <lambdabot> Char -> Int
16:33:15 <kallisti> hm
16:33:17 <adimit> > chr 97
16:33:18 <lambdabot>   'a'
16:33:18 <newsham> ?src ord
16:33:19 <lambdabot> Source not found. You speak an infinite deal of nothing
16:33:28 <kallisti> > ord (maxBound :: Char)
16:33:28 <lambdabot>   1114111
16:33:37 <newsham> > ord maxBound
16:33:38 <copumpkin> > ord maxBound
16:33:38 <lambdabot>   1114111
16:33:39 <lambdabot>   1114111
16:33:50 <kallisti> positively palindromic
16:33:50 * copumpkin glares at newsham 
16:34:25 <newsham> > reverse . show $ ord maxBound
16:34:27 <lambdabot>   "1114111"
16:34:30 * adimit wishes encoding problems in the 21st century would be a thing of the past…
16:34:40 <kallisti> adimit: nope
16:34:45 <kallisti> it's better than it was though
16:34:45 <newsham> adimit: stop using letters
16:35:02 <adimit> newsham: I'm a computational linguist. What the hell is left when I take out the letters?
16:35:11 <kallisti> computations. :P
16:35:31 <adimit> yeah, that's what I've been gravitating towards. ]
16:35:52 <augur> adimit: what kind of comp ling do you do?
16:35:57 <augur> i think ive asked you before but who knows
16:35:59 <newsham> adimit: something that doesnt require an encoding
16:35:59 <sipa> adimit: what encoding problems do you speak of? what is wrong with EBCDIC?
16:36:28 <kallisti> yeah. honestly I've never had any problems with windows-1252
16:36:49 <newsham> you linguists, always trying to map sounds and pictures to meanings
16:37:02 <adimit> augur: computational/algorthmic/algebraic semantics is my interest, but since that's barely offered at our U, I have to do a paper on corpus linguistic methods fro second language acquisition right now.
16:37:06 <adimit> *for.
16:37:24 <adimit> sipa: the same thing that's wrong with ASCII. C programmers love it too much.
16:37:35 <augur> tell me more, adimit :D
16:37:43 <jmcarthur> `Jake`: how fast is the java version?
16:37:47 <newsham> the people who made C dont use ascii anymore
16:38:11 <adimit> newsham: well, one of 'em is dead, so I guess he's pushing bits in the clouds nowadays.
16:38:20 <`Jake`> jmcarthur:  wait a sec
16:38:26 <adimit> augur: what do you wish to know? It'll get awfully off-topic for this channel, though.
16:38:54 <sipa> adimit: it's about computation here and about a language, how more on-topic could it be?
16:39:02 <kallisti> http://sprunge.us/HNUi?haskell  how would you guys write these 2 functions?
16:39:03 <newsham> there's always -blah
16:39:08 <augur> adimit: just some general overview stuff
16:39:12 <`Jake`> about 3 seconds for 10,000,000 samples
16:39:17 <`Jake`> jmcarthur
16:40:05 <kallisti> @let palindromes alphabet = [0..] >>= (`replicateM` alphabet) >>=  joinMirrors `ap` reverse where joinMirrors x y = (x++y) : map ((x++).(:y)) alphabet
16:40:06 <lambdabot>  Defined.
16:40:11 <`Jake`> I'm trying to integrate the System.Random.split function right now, btw
16:40:12 <adimit> augur: what's of greater interest to you? using haskell to process gigabites of corpus data, or follow in the footsteps of van Eijck and to formal semantics? I'll guess the latter.
16:40:13 <jmcarthur> `Jake`: alright. i made a version in haskell that on my machine runs in about 8 secs for that quantity
16:40:16 <kallisti> > palindromes [0..9]
16:40:18 <lambdabot>   [[],[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[0,0],[0,0,0],[0,1,0],[0,2,0],[...
16:40:21 <`Jake`> ok, cool
16:40:57 <augur> adimit: well, im a syntactician, so i like theory-relevant stuff.
16:40:58 <augur> koninkje: :O
16:41:04 <augur> you're no longer away!
16:41:06 <augur> :O
16:41:14 <koninkje> j0
16:41:14 <jmcarthur> `Jake`: i haven't profiled, but i bet the PRNG is a big contributor to the slowdown
16:41:30 <koninkje> Yeah, just settling in for the last bout of grading for this semester
16:41:31 <`Jake`> uhmm... PRNG?
16:41:37 <adimit> augur: ooh syntax. I try to stay away from that stuff, though I have been peering into writing a dep-parser in Haskell, because I think it'd be a great language for it.
16:41:55 <adimit> what with parallelization and all. Might be my master thesis.
16:42:18 <jmcarthur> `Jake`: System.Random
16:42:24 <koninkje> adimit: what soet of framework are you thinking?
16:42:31 <`Jake`> Ah, ok
16:42:32 <koninkje> (graph-based, LR-like,...)
16:42:35 <jmcarthur> `Jake`: PRNG = PsuedoRandom Number Generator
16:42:44 <`Jake`> jmcarthur: ok, thanks
16:42:51 <newsham> filter isPalindrome $ map show [0..]  ?  ;-)
16:43:15 <`Jake`> jmcarthur: could you post your version on hpaste?
16:43:29 <kallisti> newsham: that doesn't work for any alphabet
16:43:35 <jmcarthur> `Jake`: ah, and it's a bit faster with the llvm backend. down to 6.5s
16:43:38 <jmcarthur> `Jake`: sure
16:43:44 <`Jake`> jmcarthur: thanks
16:44:16 <hpaste_> jmcarthur annotated “Monty Hall with bad performance” with “Monty Hall with bad performance (annotation)” at http://hpaste.org/67398#a67399
16:44:22 <jmcarthur> `Jake`: ^^
16:44:39 <adimit> koninkje: if you're asking for framework, I haven't yet decided, but I'm leaning towards graph-based (again, though, it's not my actual field of expertise.)
16:44:55 <`Jake`> jmcarthur: nice one^^
16:45:32 <adimit> augur: and when it comes to comp. semantics, which is as formal as it gets, there's Blackburn & Bos 2005, implementing a rule-based chat-bot system in Prolog, that's just itching to be rewritten in something more sensible. Say haskell.
16:45:57 <augur> adimit: well but i mean
16:46:01 <augur> what are YOU interested in
16:46:12 <augur> thats what im asking
16:46:50 * kallisti is interested in birds.
16:47:06 <adnauseam> what's () called?
16:47:15 <kallisti> unit
16:47:23 <adimit> augur: sorry, I'm distracted by UTF-8 barfs on the other screen. I'm interested in: improving the type-systems behind stuff like CCG, where I think one can go beyond the typical Curry-Howard stuff that's currently used and actually use interesting concepts from modern PL research to improve the flexibility of the entire framework.
16:47:24 <kallisti> it's the type with one inhabitant
16:47:41 <adnauseam> @google feynman bird quote
16:47:43 <lambdabot> http://www.quotationspage.com/quote/26933.html
16:47:43 <lambdabot> Title: Quote Details: Richard Feynman: You can know the... - The Quotations Page
16:47:44 <siracusa> or unit type, depending on context
16:47:48 <augur> adimit: in what ways?
16:47:57 <adnauseam> hrm
16:48:03 <koninkje> adimit: ah, just curious. We have a lot of folks here who do dependency stuff, so ...
16:48:06 <kallisti> > sort [(),(),(),()]
16:48:06 <lambdabot>   [(),(),(),()]
16:48:15 <siracusa> :t ()
16:48:16 <adimit> koninkje: where's "here"?
16:48:16 <adnauseam> kallisti: i see. i'm trying to read about it so i understand it better
16:48:16 <lambdabot> ()
16:48:21 <kallisti> there we go. that list is much better when its sorted.
16:48:24 <koninkje> Indiana University
16:48:34 <newsham> i wonder which elements were swapped in that sort
16:48:52 <kallisti> adnauseam: its practical purpose is mostly to indicate that the result of something is completely uninteresting.
16:49:07 <kallisti> for example, the only real information you get from a value of type [()] is a length.
16:49:14 <koninkje> adimit: also, re CCG type systems, have you see my NASSLLI talk from a couple years back? (or will you be at NASSLLI this year?)
16:49:19 <kallisti> the elements aren't very interesting. you already know all about them.
16:49:49 <Peaker> kallisti, almost all, due to lifted products :(
16:49:51 <adimit> augur: it's research I haven't been able to touch for a while because of course work, so I'd have to go back to my notes, I'm sorry :-\
16:49:55 <kallisti> adnauseam: and I'm sure you've seen IO ()
16:50:05 <adimit> koninkje: i'm based in Europe, so I'll be at ESSLLI :-)
16:50:13 <newsham> > sortBy (compare `on` fst) [((),0), ((), 1), ((),2)]
16:50:14 <lambdabot>   [((),0),((),1),((),2)]
16:50:15 <koninkje> ah ha :)
16:50:20 <adimit> koninkje: NASSLLI is too expensive for me to get to.
16:50:23 <Peaker> > () == undefined
16:50:24 <lambdabot>   *Exception: Prelude.undefined
16:50:30 <adimit> koninkje: which would be your talk, btw, I'm interested.
16:50:33 <koninkje> I've been meaning to go to ESSLLI but haven't made it there yet
16:50:39 <augur> adimit: i just meant what sort of conceptual stuff were you aiming at
16:50:46 <augur> koninkje: imma try to get to nasslli :D
16:50:58 <koninkje> adimit: http://llama.freegeek.org/~wren/pubs/ccgjp_nasslli2010.pdf
16:51:03 <`Jake`> jmcarthur: fyi: it's about 7 seconds here
16:51:12 <koninkje> adimit: though I'm not sure how much can be gleaned from the slides alone
16:51:51 <adnauseam> kallisti: yeah i've seen IO (), and i understand the concept of IO, but not (). wikipedia hasa nice page about Unit Type though, and i think i understand things a bit better now =]
16:52:21 <koninkje> adimit: essentially, proposes a new lambda calculus for the semantics, which embeds the type system induced by the syntactic part
16:52:53 <koninkje> adimit: I don't mention much about the new type theory induced by that however, though it is something I've worked on (and hope to work more on this summer)
16:53:01 <adimit> augur: well, there's my notion of marrying CCG with DRT, essentially making CCG parser build up discourse structures instead of just spitting out logical formulas
16:53:02 <koninkje> augur: Well, I'll see you there then :)
16:53:10 <Peaker> adnauseam, data () = ()
16:53:40 <augur> koninkje: your arrow slashes are really painful :(
16:53:41 <adimit> koninkje: I'll definitely go through them slides, thanks :-) I might bug you with questions later if they're not clear enough!
16:53:55 <Peaker> for 8 options you need 3 bits.   for 4, need 2,   for 2, need 1,    for 1, need 0.  Unit type has 1 option, or 0 bits of information
16:54:00 <adnauseam> why is it bound to types such as IO though ?
16:54:07 <adnauseam> im trying to understand its functionm
16:54:09 <adnauseam> function
16:54:24 <Peaker> adnauseam, "IO ()" is not "binding" IO to (), it's just giving the unit type as a *parameter* to the IO type constructor
16:54:26 <koninkje> augur: Why's that? They're more symmetric than LaTeX's / and \ and they make clear which version of backslashes we're using (Lambek vs CCG)
16:54:46 <augur> koninkje: still, they're non-standard, so its hard to read
16:54:50 <jmcarthur> `Jake`: alright
16:55:00 <jmcarthur> `Jake`: with llvm?
16:55:07 <adnauseam> oh
16:55:18 <koninkje> augur: If I could find truly symmetric slashes sans the arrow heads, I'd use them instead
16:55:19 <adnauseam> i didn't think of it like that
16:55:37 <`Jake`> no, don't really know how to use that^^
16:55:44 <koninkje> the assymetry between / and \ is really hard to read for me
16:55:44 <Peaker> adnauseam, "IO" cannot be used on its own as a type of a value. It needs to be given a type, for the result that the IO action will produce
16:55:44 <Peaker> adnauseam, For example, "x :: IO Int" is valid (x is an IO action that yields an int) but "x :: IO" is not.
16:55:44 <Peaker> adnauseam, When you have an IO action that does not have any interesting value to yield, you signify that by saying it yields the () type, which means it can only yield the () value
16:56:24 <augur> koninkje: i just looked at \backslash and / produce symmetric results for me
16:56:38 <koninkje> they don't here. What font are you using?
16:56:40 <adnauseam> Peaker: thanks man!
16:56:42 <Peaker> adnauseam, print "Hello world" :: IO ()    (It has an interesting effect, but not an interesting result value)
16:56:54 <augur> koninkje: whatever is standard in texshop
16:56:57 <adimit> augur: I also wanted to see if it's possible to introduce a stronger type system into montague-semantics. You've got the typical e,t and complex tuples thereof type system there, and usually, every kind of special semantics that introduces new stuff also introduces types, like v in event semantics, etc, s when you count possible worlds, and they each have idiosyncratic behaviour.
16:56:58 <Peaker> adnauseam, no problem :)
16:57:00 <koninkje> hmm
16:57:46 <adimit> so the idea was to use dependent typing into the picture, which could then maybe even be able to express stuff like long-distance dependencies, but that's a *very* vague notion I have, and haven't yet been able to look into.
16:58:22 <augur> koninkje: i think a lot of your facts about case in japanese are false
16:58:27 <adimit> ok, now I gotta get back to wrenching.
16:58:33 <koninkje> augur: how's that now?
16:58:48 <augur> adimit: ive seen some work on pronouns using dependent types
16:58:57 <augur> adimit: i'd be interested in talking to you about this stuff some time
16:59:24 <augur> koninkje: just factually. lemme find something that masa's written that discusses this stuff
16:59:26 <augur> gimme a sec
16:59:46 <adimit> augur: ooh, do you remember where you've seen that work? I haven't yet. Then again, as I said, those are old notes from last year that I barely remember.
17:00:10 <koninkje> augur: the only facts I have are (a) mostly free ordering, (b) constrained order for affective arguments, (c) constrained order for datives, (d) native disagreement about nesting
17:00:12 <adimit> I'll be able to get into more detail once I pick up work on it again, which'll be sometime around this summer, I guess.
17:00:14 <augur> adimit: i think it was a barker/shan paper
17:00:33 <koninkje> augur: those've been confirmed by every native I've encountered, as well as my experience reading Japanese
17:00:51 <augur> koninkje: a lot of native disagreement seems to fall along east/west dialectal lines, in my experience
17:01:13 <jmcarthur> `Jake`: woot! ./Monty3 10000000  0.26s user 0.01s system 98% cpu 0.266 total
17:01:29 <`Jake`> jmcarthur: awesome!
17:01:37 <koninkje> augur: I wasn't able to find the grouping, but then luckily the theory doesn't take a stance on the matter
17:01:56 <hpaste_> jmcarthur annotated “Monty Hall with bad performance” with “Monty Hall with good performance” at http://hpaste.org/67398#a67400
17:02:08 <jmcarthur> `Jake`: ^^
17:02:40 <koninkje> augur: In my experience the "no scrambling into" is the default reading, with a few speakers who allow it. Though I'd love to see dialect information on the issue
17:02:54 <augur> no scrambling into?
17:03:24 <koninkje> The disagreement about whether scrambling-into is allowed or not (slide 23/27)
17:04:05 <koninkje> I've only found a couple natives who think it's okay, but even they say it's marginal and requires contextual support
17:04:20 <jmcarthur> `Jake`: anyway, hopefully there's enough there for you to learn a few tricks from
17:04:59 <`Jake`> jmcarthur: I think there definitely is, thanks for all your time!
17:05:19 <jmcarthur> np. optimization is fun sometimes
17:05:36 <`Jake`> at least in haskell.
17:05:52 <adimit> augur: I reserve the right to prod you about that in the future, because I can't find that barker/shan paper right now, but I'm very intrigued. In any case, I shouldn't let course work distract me so much!
17:06:22 <koninkje> adimit: Perhaps http://dx.doi.org/10.3765/sp.1.1
17:06:23 <augur> koninkje: oh, wow, you're talking about that phenomenon totally backwards from the standard treatments
17:06:31 <koninkje> Or something else on http://www.cs.rutgers.edu/~ccshan/
17:06:45 <augur> koninkje: ive only ever seen that described as scrambling OUT of the lower clause
17:07:16 <augur> koninkje: also, i know only speakers who accept such things. maybe not that particular sentence tho
17:07:19 <koninkje> I've heard it both ways; it depends on the framework's assumptions about moving I believe
17:07:41 <augur> koninkje: but koninje, that sentence almost certainly will be good with "sono hon ga"
17:08:05 <adimit> koninkje: interesting, couldn't find this over scholar. I guess google sometimes better than scholar.
17:08:08 <raboof> I just wrote my first not-completely-trivial Haskell program: a script that takes a plaintext hierarchy and presents it in a filterable gui
17:08:20 <`Jake> jmcarthur: sorry, if you said anything after my last sentence, I couldn't read it because my screen froze and I had to restart
17:08:26 <augur> adimit: im not sure it was a barker shan paper but i suspect it was
17:08:35 <raboof> uploaded it at https://github.com/raboof/treeview - anyone care to give me some quick tips on stuff I could improve upon?
17:08:53 <koninkje> augur: How would you have that sentence with "sono hon ga"? Kau doesn't take multiple subjects
17:09:12 <augur> koninkje: doesnt matter, pally. thems the facts. :)
17:09:35 <koninkje> What I mean is, WHere is your evidence that those "facts" exist?
17:09:37 <augur> lemme find some of the literature on phases for you
17:11:00 <newsham> http://www.thenewsh.com/~newsham/x/machine/parens.hs
17:14:07 <augur> koninkje: what are your "affective" predicates, btw?
17:14:32 <koninkje> predicates which take two ga arguments, rather than one ga and one wo
17:14:44 <koninkje> the latter being "operational"
17:14:54 <augur> koninkje: i mean outside of case issues
17:15:05 <koninkje> I have none
17:15:20 <augur> oh, so its just another way of saying double nominative verbs
17:15:30 <koninkje> I mean "affective" precicely to include the class of predicates for which they have that argument structure
17:15:44 <elliott> > ?haskell
17:15:44 <lambdabot>   mueval-core: internal error: PAP object entered!
17:15:45 <lambdabot>      (GHC version 6.12.3 f...
17:15:46 <elliott> Cale: ^g
17:15:55 <elliott> mauke: ^ (you maintain mueval right?)
17:15:58 <elliott> gwern: or was it you...
17:16:03 <gwern> me
17:16:13 <elliott> > ?asdf
17:16:14 <lambdabot>   mueval-core: internal error: PAP object entered!
17:16:14 <lambdabot>      (GHC version 6.12.3 f...
17:16:15 <elliott> not sure what's up with that
17:16:25 * hackagebot EitherT 0.2.0 - EitherT monad transformer  http://hackage.haskell.org/package/EitherT-0.2.0 (EyalLotem)
17:16:32 <koninkje> augur: not just verbs, adjectives too
17:16:39 <gwern> elliott: me neither. seen it before, but typically reinstalling and stuff fixed it
17:16:58 <elliott> heh
17:17:55 <koninkje> augur: I get the terminology from Harz-Jordan, and I've yet to see a different set of terminology that captures the distinction. Though, yes, it could be confusing if you're thinking of "affective" from a pragmatic perspective
17:18:48 <augur> koninkje: http://wellnowwhat.net/linguistics/Takahashi%202011.pdf is all about this case stuff in japanese
17:21:16 <augur> also its really not true that clause-internal scrambling has strictly no effects on meaning. it does have some (minor) topic/focus stuff, but it also has enormous effects on binding
17:21:27 <wli> > let { convolve as bs = zipWith3 (\n as' bs' -> sum (zipWith (\(i,a) (j,b) -> (fromIntegral $ i `choose` j) * (fromIntegral $ n `choose` i) * a * b) (zip [0..] as') (zip [0..] $ reverse bs'))) [0..] (inits as) (inits bs) ; choose n k | k < 0 || k > n = 0 | k == 0 || k == n = 1 | 2*k > n = choose n (n - k) | otherwise = div (n * choose (n - 1) (k - 1)) k } in take 10 $ convolve (repeat 1) (repeat 1) {- There must be a more efficient way to do that esp. with trinom
17:21:28 <lambdabot>   <no location info>: unterminated `{-'
17:22:11 <koninkje> Granted. But those are the sorts of semantics which semanticists routinely ignore.
17:22:28 <koninkje> I'm doing my part to get them not to, but one step at a time eh?
17:22:52 <augur> koninkje: er.. which are the sorts?
17:23:07 <koninkje> minor topic/focus differences do to lexical order
17:24:05 <augur> uh.. im not sure ive ever heard a semanticist who didn't expect order to have an effect on information structure
17:25:06 <koninkje> In my experience semanticists routinely ignore information structure whenever possible
17:25:28 <augur> hm
17:25:47 <augur> well, we syntacticians are happy when we can say these things have an information structure effect
17:27:58 <koninkje> I don't think that's precluded by my analysis
17:29:23 <augur> koninkje: i wasnt commenting on the analysis :p
17:29:25 <augur> just the fact
17:29:51 <augur> s
17:30:18 <koninkje> sure. IMO every difference in phrasing is going to have a difference in meaning; it's the nature of what we do with/to language
17:30:55 <adimit> koninkje: that's a very pragmatic (in the linguistic sense of pragmatic) approach.
17:30:58 <koninkje> But some of these differences are going to be ellided in any treatment; it's the nature of maps vs territories
17:31:14 <adnauseam> in
17:31:15 <adnauseam> guard :: (MonadPlus m) => Bool -> m ()
17:31:15 <adnauseam> guard True = return ()
17:31:15 <adnauseam> guard False = mzero
17:31:39 <adnauseam> is it simply return (), or return m ()?
17:31:40 <koninkje> My goal, however, is to reorient the sorts of things that people don't deal with. I don't like the current boundary between syntax and semantics
17:31:43 <adimit> esp. speakers of languages with highly redundant vocabulary might disagree.
17:31:56 <koninkje> I think it obscures more than it ellucidates
17:32:05 <augur> so koninkje, im not sure what your analysis gives that isn't already available in typical lambda calculus stuff, except maybe the restriction on argument reordering by dimension
17:32:17 <augur> also im not sure why you put it in the semantics and not the syntax
17:32:18 <elliott> adnauseam: It's... return ().
17:32:21 <elliott> The type of return () there is m ().
17:32:22 <koninkje> adimit: well, my undergrad training was in anthropological linguistics :)
17:33:19 <adimit> koninkje: yeah, mine was in formal semantics, so we'll have different approaches to that. I also learned Sanskrit & Hindi, where people say there are "true" synonyms, which don't even make a pragmatic difference in any measurable wayp.
17:33:22 <adimit> *way*
17:33:28 <koninkje> augur: that is precisely what it gives. The lambda calculus is, as always, a means to an end (constructing whatever logical formula)
17:33:29 <adnauseam> is then then the () pair of whatever monadPlus instance is called?
17:33:49 <adnauseam> i'm just having a wee hardtime seeing it come alone
17:34:03 <augur> koninkje: im not sure why you'd want to prohibit scrambling of things with the same case
17:34:12 <koninkje> augur: because the facts deny it
17:34:20 <elliott> adnauseam: Huh?
17:34:32 <elliott> It simply applies the function (return :: a -> m a) to the value (), producing m ().
17:34:40 <elliott> MonadPlus implies Monad, so you know return is available.
17:34:41 <augur> do they tho, koninkje?
17:34:47 <adnauseam> oh
17:34:54 <adnauseam> i understand
17:35:02 <kallisti> :t ()
17:35:03 <lambdabot> ()
17:35:03 <koninkje> augur: in every treatment I've seen, yes. Show me examples otherwise
17:35:36 <koninkje> augur: I mean specific examples. In the wild, preferably.
17:36:14 <kallisti> adnauseam: though the expression language mirrors the type language quite a bit, they don't correspond quite so directly.
17:37:37 <koninkje> augur: as for the complaint about not altering the syntactic side of CCG, it's possible to reflect the changes back up to the type level. I hope to write it up this summer, but that's the type theory I mentioned to adimit
17:38:25 <adnauseam> kallisti: that was chinese dude :p
17:38:31 <augur> koninkje: ive been thinking of similar stuff for A-bar movement for a while now
17:38:47 <koninkje> similar to which?
17:39:14 <kallisti> adnauseam: you seemed to think that because there was an m in m (), there should be an m somewhere in the value that produces the type m ()
17:39:35 <koninkje> augur: thanks for the link to Takahashi's thesis by the way. Looks interesting (albeit Chomskyan ;P)
17:40:11 <augur> koninkje: similar to this type-driven reordering stuff
17:40:12 <kallisti> > return 2 :: [Int]
17:40:13 <lambdabot>   [2]
17:40:17 <adnauseam> kallisti: yeah
17:40:21 * koninkje nods
17:40:24 <hpaste_> wli pasted “Newton series convolution” at http://hpaste.org/67401
17:40:28 <augur> koninkje: as for masa's thesis, yeah, its very chomskyan, but ignore the analysis and look at the data
17:41:01 <kallisti> > return 2 :: Maybe Int
17:41:02 <lambdabot>   Just 2
17:41:04 <adnauseam> kallisti: oh now i understand
17:43:07 <kallisti> > [1,2,3] `mplus` [4,5,6]
17:43:08 <lambdabot>   [1,2,3,4,5,6]
17:43:23 <kallisti> > Just 2 `mplus` Just 3
17:43:24 <lambdabot>   Just 2
17:43:35 <kallisti> > Nothing `mplus` Just 3
17:43:36 <lambdabot>   Just 3
17:45:52 <kallisti> adnauseam: mplus is something like a logical disjunction, where mzero represents "false"
17:47:06 <kallisti> or, well, that's how it works for many of the instances defined. I don't think there's really any laws forcing it to behave that way.
17:47:52 <kallisti> adnauseam: do you know what a logical disjunction is?
17:48:12 <sm> what's the best way to determine if a program has been given some standard input ?
17:48:29 <fmap> mplus is something like a mappend, where mzero represents mempty
17:48:48 <kallisti> sm: something like:  not . null =<< getContents
17:48:49 <kallisti> I guess
17:49:08 <kallisti> sm: depends on what you want to do afterward
17:49:17 <kallisti> er
17:49:18 <rwbarton> read from stdin and see what you get
17:49:20 <kallisti> not . null <$> getContents
17:50:02 <kallisti> for example if you use mapM on getContents to do some kind of processing, you can also handle the empty case by binding the result of that with a guard
17:50:05 <sm> actually hReady stdin seems to work. I'm just wondering when it will give that error (http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/System-IO.html#v:hReady)
17:50:10 <rwbarton> unless you mean, see whether there is anything available to read *now*
17:50:47 <kallisti> sm: what error?
17:50:52 <sm> I only want to check once at startup, did they run PROG ? or PROG <stuff or echo stuff | PROG
17:51:29 <sm> kallisti: that haddock says This operation may fail with:
17:51:32 <sm> System.IO.Error.isEOFError if the end of file has been reached.
17:51:41 <sm> which I'm not understanding
17:51:43 <spacebark> @yhjulwwiefzojcbxybbruweejw
17:51:44 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
17:51:46 <kallisti> oh. that would happen if there's no input, yes.
17:52:10 <kallisti> sometimes checks like that or unnecessary.
17:52:25 <kallisti> *are
17:53:00 <sm> hReady stdin >>= print seems to print true or false just as I want, so I don't get when it would raise the error
17:53:44 <kallisti> for example you can do stuff like
17:53:48 <rwbarton> if you reach eof on stdin. try hitting ctrl-d or your local os equivalent
17:54:12 <kallisti> getContents >>= mapM processStdIn >>= ((`when` processNoStdIn) . null)
17:54:52 <kallisti> in the case where stdin is empty, processStdIn is never called, and the null check causes processNoStdIn to occur
17:55:13 <kallisti> I'm sure you can do similar things with functions other than mapM
17:55:58 <sm> I have main = hReady stdin >>= print, and I haven't been able to make it error
17:56:17 <kallisti> maybe stdin is a special case then
17:56:28 <kallisti> or.. it could be platform specific?
17:56:31 <kallisti> I don't know
17:56:36 <sm> could be
17:57:50 <kallisti> main = getArgs >>= mapM (readFile >=> putStr) >>= (null >>> (`when` (getContents >>= putStr)))
17:57:57 <kallisti> here's a cat I wrote that uses that idea.
17:58:06 <kallisti> except with getArgs instead of getContents
18:01:38 * kallisti thinks perl has the best cat:  print <>
18:03:01 <kallisti> but perl cheats by having the builtin <>, which literally means something like "read in everything as cat would"
18:05:33 <geekosaur> sort of
18:05:57 <geekosaur> it's a lazy list of lines, unless you `$" = undef'
18:05:58 <kallisti> well, a cat that accepts no options
18:06:23 <kallisti> or unless you evaluate it in list context.
18:06:31 <geekosaur> this means possibly variabt bhavior if the line delimiter is modified; cat does block reads and knows nothing about line delimiters
18:06:50 <sm> ha! well rein in the horses.. I was all set to write a gist client and I just remembered seeing a github library on hackage
18:07:03 <sm> awesome
18:08:11 <sm> read-only. ah well
18:08:25 <Peaker> scrolled to the backlog... mplus is like mappend except in some misbehaving instances (e.g: MonadPlus IO in Control.Monad.Error, mzero isn't left-neutral)
18:08:34 <Peaker> oops, it isn't right-neutral
18:09:05 <kallisti> mappend does not work the same as mplus for Maybe
18:09:16 <adnauseam> here;s a strange question... are there any cool tricks that i can do with ghci ?
18:09:21 <Peaker> well, that's just because of an arbitrary choice
18:09:24 <adnauseam> like, generate ascii and such
18:09:41 <adnauseam> for entertainment value
18:09:53 <Peaker> but mzero/mplus have the same laws as mempty/mappend, except they're not followed by some instances as I said, and there are some more laws relating to Monads
18:10:13 <kallisti> yes, they are both monoids.
18:10:19 <Peaker> kallisti, given that Data.Monoid already has the First newtype, "mplus" behavior for Maybe is silly
18:10:42 <kallisti> mplus behavior for Maybe makes perfect sense
18:10:53 <Peaker> > First (Just 5) `mappend` First (Just 6)
18:10:54 <lambdabot>   First {getFirst = Just 5}
18:11:18 <Peaker> I think it would be more elegant if MonadPlus was the same as Monoid, when possible
18:11:20 <rwbarton> > mempty :: First Int
18:11:21 <lambdabot>   First {getFirst = Nothing}
18:11:28 <rwbarton> oh
18:11:28 <Peaker> similarly to how Applicative instance should match the Monad instance
18:11:43 * kallisti doesn't see any particular reason to do that.
18:12:24 <Peaker> kallisti, the whole reason we have MonadPlus, IMO, is because of language limitations.  If you could express:  class (forall a. Monoid (m a), Monad m) => MonadPlus m where {}   then you could reuse all the monoid code
18:12:48 <Peaker> so since MonadPlus is just a workaround to type expressiveness limitations, it may as well duplicate the exact behavior
18:13:43 <roha> hey, im a haskell newbie and i have a question to the experienced haskell programmers: i somehow got the feeling that if you want to do real world programs with haskell, that you are in the end just using the pseudo-imperative do-construct all over the place because you have to deal with real world data (in the IO monad) and that one is just back to the "old imperative style" without using all the cool functional techniques that are shown
18:13:43 <roha> in all the online tutorials.
18:14:12 <kallisti> roha: that's one way to program. However you can also extend the cool functional techniques into that realm.
18:14:15 <Peaker> roha, real world Haskell code is mostly functional, with a thin IO wrapper
18:14:35 <kallisti> roha: the do notation itself is just sugar for functional constructs.
18:14:43 <Peaker> roha, "do" doesn't bring you all the way back to imperative land
18:14:51 <Peaker> (only "do" in IO pretty much does)
18:15:14 <Peaker> the vast majority of my code's "do"s do not involve IO
18:16:33 <HugoDaniel> roha: nah, i like to do everything as pure as possible, and avoid do sugaring as much as possible... its easy and fun
18:16:40 <roha> so is it possible to do real world programs without having all functions type signatures with IO ... all over them?
18:16:56 <HugoDaniel> roha: not only is it possible, it is easier and desirable
18:17:25 <HugoDaniel> usually IO is your last stuff to be coded, all other stuff resides in mangling your datatypes/functions in creative ways
18:17:26 <kallisti> roha: depends on the problem. a fair degree of it will involve IO if you're interacting with outside sources of data. However, you can easily write pure functions that take the results of these IO actions.
18:17:57 <HugoDaniel> roha: go pure :)
18:18:07 * kallisti notes that do notation has nothing to do with purity.
18:18:15 <HugoDaniel> yes
18:18:33 <HugoDaniel> IO does not imply do notation, and do notaion does not imply IO
18:19:42 <Peaker> roha, most Haskell code doesn't have IO in its types, yeah
18:19:58 <Peaker> and when code does have IO too often, it's considered bad style
18:20:11 * kallisti doesn't consider it bad style.
18:20:19 <zachk> or its written by spj
18:20:37 <roha> so could you say that one should try to define all one's functions to be as general as possible and that only in some glue functions one would apply those 'pure' functions to data inside an IO monad?
18:20:54 <kallisti> that's a good design, yes.
18:21:11 <kallisti> some times you end up carrying IO around with you everywhere. This becomes common with monad transformers, for example.
18:21:39 <kallisti> but once you learn about applicative functors you'll find that this isn't much of a hinderance to writing code.
18:21:52 <kallisti> also once you get comfortable with using >>= itself
18:22:08 <kallisti> do notation can often be too verbose
18:22:12 <Cale> Usually you only use IO actions to describe the actual I/O that your program is doing, and all the actual computation is separate.
18:22:54 <HugoDaniel> roha: also, you can easily refactor everything to your heart desire because the haskell compiler type checks everything, telling you what you are forgetting :)
18:23:02 <roha> ok thats good to hear. i was just kind of discouraged after trying to do some XML parsing and suddenly i had IO .. all over my code :)
18:23:25 <Peaker> roha, maybe you can paste your code?
18:23:35 <kallisti> the only time you need IO is to actually read/write files
18:23:38 <kallisti> or other input output sources
18:23:43 <kallisti> in that program.
18:23:45 <HugoDaniel> roha: and you can always come here and yell, we are good listeners and like to help out
18:24:21 <roha> Peaker, i'll gladly come back to that offer when my code is a bit more mature :)
18:24:40 <roha> all, thanks so much! you have been a great help!
18:25:08 <kallisti> hm so....
18:25:15 <kallisti> DList is basically a specialized Endo, no?
18:25:32 <Peaker> kallisti, Endo over a Monoid, yeah
18:25:39 <Peaker> reassociate-mappends-to-right
18:26:21 <kallisti> Peaker: re: MonadPlus, I find the fact that Maybe defaults to the same behavior as First to be very useful.
18:26:32 <kallisti> "try this; if that fails, do this"
18:26:53 <Peaker> why not use the newtype, rather than the convenient fact that code duplication allowed a new instance behavior?
18:27:13 <kallisti> because the newtype is more effort when mplus is already there? :P
18:27:14 <Peaker> because the fact we have mzero/mempty and mplus/mappend is basically code duplication
18:28:03 <kallisti> I'm not going to use First because it's not as convenient. That's basically the bottom line. I have no holy war to wage.
18:28:04 <Peaker> well, I agree it is more convenient..  but I don't think it's worth the duplication
18:30:01 <kallisti> if the Monoid instance for Maybe also did the same thing, that would be great. But it doesn't really bother me. There's 2 classes, why not use them for 2 different things?
18:30:40 <kallisti> a bit of reason would be nice though. otherwise the decision of which behavior goes to which class is arbitrary.
18:31:01 <copumpkin> they can't do the same thing
18:31:08 <copumpkin> or rather, one can't do everything the other can
18:31:31 <Peaker> kallisti, if you change mappend to be like mplus it would be horrible :)
18:31:33 <Peaker> (for Maybe)
18:31:43 <Peaker> recursive mappend is simpler/nicer/more-useful
18:32:00 <kallisti> it is? I've used it 0 times.
18:32:05 <kallisti> I've used mplus multiple times.
18:32:11 <Peaker> kallisti, did you see conal's Type Class Morphisms paper?
18:32:14 <kallisti> perhaps I'm not the most imaginative.
18:32:17 <kallisti> no.
18:32:25 <Peaker> it's a very nice paper
18:32:35 <copumpkin> the Maybe instance for Monoid sucks
18:32:44 <Peaker> shows a much nicer-design for Data.Map, which demonstrates also the usefulness of recursive mappend
18:32:49 <copumpkin> it should really be instance Semigroup a => Monoid (Maybe a)
18:32:54 <rwbarton> quick, what's Maybe mempty `mappend` Nothing
18:33:02 <Peaker> copumpkin, what's Semigroup?
18:33:03 <kallisti> copumpkin: yes, it accomplishes nothing that can't be done with applicative.
18:33:12 <copumpkin> kallisti: huh? yes it does
18:33:19 <copumpkin> Peaker: monoid minus mempty
18:33:30 <copumpkin> Peaker: since the Maybe instance for Monoid doesn't use the underlying Monoid's mempty anyway
18:33:48 <Peaker> copumpkin, well, the classes are not fine-grained enough
18:33:53 <copumpkin> yeah, I know
18:34:49 <Peaker> kallisti, conal shows that if you have a total-map instead of Data.Map, then virtually the entire Data.Map vocabulary becomes re-uses of mappend, Data.Monoid newtypes, etc.
18:35:14 <kallisti> it is? I've used it 0 times.
18:35:17 <kallisti> er wrong
18:35:18 <kallisti> thing
18:35:23 <kallisti> copumpkin: isn't it equivalent to mappend <$> m1 <*> m2
18:35:26 <copumpkin> or if you eschew the pure requirement for Applicative and use edwardk's Apply class, Map is just an Apply
18:35:43 <copumpkin> kallisti: yeah, but that doesn't give you a monoid instance, so you can't use anything phrased with monoids (reducers, etc.)
18:35:59 <copumpkin> and you can't construct instances on the fly except by using scary tricks
18:36:15 * kallisti is completely unfamiliar with reducers
18:36:22 <kallisti> maybe I was too hasty in learning about monoids.
18:36:58 <copumpkin> oh, and wait, I don't think it's the same either
18:37:06 <copumpkin> yeah, it isn't
18:37:20 <copumpkin> with your applicative one Nothing eats everything
18:37:34 <copumpkin> it's acting like 0 for multiplication rather than 0 for addition
18:37:34 <kallisti> oh I see
18:39:07 <kallisti> hm reducer is interesting
18:39:08 <kallisti> :t unit
18:39:09 <lambdabot> Not in scope: `unit'
18:39:45 <Peaker> reducer = mconcat ?
18:40:11 <copumpkin> nah
18:40:15 <copumpkin> @hackage reducers
18:40:15 <lambdabot> http://hackage.haskell.org/package/reducers
18:40:22 <kallisti> I'm not really sure how to explain it
18:40:32 <copumpkin> it's a monoid along with an injection function
18:40:33 <kallisti> it's like you've lifted part of the type into the Monoid, but not the other part.
18:40:41 <copumpkin> or rather, a semigroup with one
18:41:03 <copumpkin> they let you do lots of things in parallel ways and give you efficient snoc/cons implementations if you can provide them
18:41:40 <copumpkin> here are some examples in an older version of the same package: http://hackage.haskell.org/package/monoids-0.1.36
18:41:57 <kallisti> is there a version of Writer that works with Reducer?
18:43:15 <copumpkin> not that I know of
18:46:00 <kallisti> what is Writer exactly
18:46:16 <kallisti> what's the theoretical nonsense version. :P
18:46:59 <koninkje> It's just the family of (e,_) functors. Similar to reader being the (e->_) functors
18:51:58 <augur> are there any interesting alternatives to binders, aside from HOAS?
18:52:11 <koninkje> define "interesting"
18:52:24 <augur> existing
18:52:25 <augur> :P
18:52:38 <augur> also, the more you can tell me about the better
18:52:40 <koninkje> PHOAS, De Bruijn,...
18:52:54 <augur> PHOAS?
18:53:08 <koninkje> http://adam.chlipala.net/papers/PhoasICFP08/
18:53:22 <augur> de bruijn indices are also surely binders, of a sort
18:53:23 <kallisti> copumpkin: hm, there's a valid instance for Reducer Word8 ByteString, no?
18:53:30 <kallisti> and Reducer Char Text
18:53:41 <byorgey> augur: Locally Nameless
18:53:49 <kallisti> since it basically generalizes cons.
18:54:00 <byorgey> augur: read "I am not a number, I am a free variable"
18:54:09 <copumpkin> kallisti: yeah, but not an efficient one
18:54:16 <kallisti> ah yeah
18:54:38 <koninkje> augur: also google for nominal logic
18:54:40 <kallisti> well, I can think of an efficint one for lazy Bytestring/Text... :P
18:54:41 <augur> byorgey: no i understand, but im really more concerned about the bind-er not the bind-ee
18:54:59 <kallisti> at least efficient in terms of O(1) cons :P
18:55:29 <byorgey> augur: oh. yeah, you may find nominal logic interesting
18:55:36 <byorgey> I'm not sure I understand exactly what you're asking for
18:55:47 * kallisti thinks a version of Writer specialized to Reducer would be nice.
18:55:52 <kallisti> you could shorten a bit of code that way.
18:56:22 <augur> byorgey: well, i dont know either! but something that has a different approach to solving the problem that binders solve
18:57:01 <kallisti> hm, well, I'm not sure it's possible to do it in the way I envisioned.
18:57:01 <BMeph> Doesn't Writer need the 'e' to be a Monoid, so-as to have a(n mempty) value for 'return'?
18:57:02 <koninkje> in that case you should look into combinator calculi and concatenative programming
18:57:08 <kallisti> BMeph: yes
18:57:14 <koninkje> BMeph: yes
18:57:36 <kallisti> the problem is that to implement MonadWriter you need to take the Reducer and transform it back into the Monoid.
18:57:52 <kallisti> but tell could just be snoc
18:58:34 <BMeph> It sounds more like you need a convenient Reducer => Monoid instance, instead.
18:58:41 <kallisti> yes
18:59:12 <kallisti> well, I could always just ditch MonadWriter..
18:59:18 <kallisti> and do it slightly differently.
18:59:38 <BMeph> Or maybe even the reverse, since it's already established.
18:59:45 <kallisti> MonadReducer   (I haven't quite figured out what to call the actual monad type though, since Reducer is already taken)
19:03:47 <kallisti> one nice benefit of such a monad is you don't have to wrap things in a Monoid newtype before you tell it
19:04:01 <kallisti> tell . All $ bool   would just be tell bool
19:04:11 <kallisti> (tell would be called something else)
19:12:08 <augur> byorgey: do you know of anything that has alternatives to binders?
19:12:13 <augur> nominal logic seems to still have them
19:13:15 <byorgey> augur: no, I don't
19:13:24 <byorgey> augur: I'm not sure what that would even mean.
19:13:41 <byorgey> what sort of alternative are you looking for?  i.e. what properties should it have?
19:14:08 <augur> im not looking for anything, im just curious
20:06:07 <kallisti> > f . f
20:06:08 <lambdabot>   No instance for (GHC.Show.Show (f b))
20:06:08 <lambdabot>    arising from a use of `M7211723435...
20:06:45 <kallisti> > iterate (.f) id <*> [x]
20:06:46 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
20:08:16 <rwbarton> :t f . f
20:08:17 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f a), Functor f) => f b
20:23:55 <wli> Looks like my first cut for Newton series convolution was incorrect.
20:24:19 <tgeeky> wli: text "You are the weakest link. Goodbye!"
20:28:39 <Cale> wli: Are you really just looking for the connection coefficients for falling factorials?
20:30:25 <wli> Cale: I can look at the formula as it's written down in a couple places I can get to. The main thing was trying to be efficient and lazy for the coefficients of the product series. Apparently I'm flubbing it, too.
20:31:42 <wli> Cale: It's rising factorials, though.
20:31:43 <Cale> (I'm also asking because I'm not entirely sure what the convolution of Newton series refers to)
20:32:22 <wli> Cale: Sometimes it's written \sum_{n=0}^\infty a_n \binom{x+n}{n}
20:32:54 <Cale> http://en.wikipedia.org/wiki/Finite_difference#Newton.27s_series gives an expansion in falling factorials
20:32:56 <wli> Cale: So I'm hammering out the coefficients of A(x)B(x) where A, B are two Newton series.
20:33:01 <Cale> right...
20:33:21 <Cale> ah, right, there's an additional k! in the denominator there.
20:34:24 <wli> http://mathbin.net/92780
20:41:27 <wli> > let { as = iterate (*3) 1 ; bs = iterate (*2) 1 } in take 5 $ zipWith3 (\n ias jbss -> sum $ zipWith (\(i, a) jbs -> fromIntegral (choose n i) * a * sum [fromIntegral (choose i j) * b | (j, b) <- jbs]) ias jbss) [0..] (map (zip [0..]) . tail $ inits as) (map (tail . inits . zip [0..] . reverse) . tail $ inits bs)
20:41:28 <lambdabot>   Not in scope: `choose'Not in scope: `choose'
20:41:38 <wli> Not quite right.
21:07:49 <augur> koninkje_away: ping
21:09:24 <augur> koninkje_away: http://www.ling.upenn.edu/Events/PLC/plc36/abstracts/Yamashita_PLC36.pdf 2a, 3a, 4
21:37:33 <dmwit> C programmers are weird.
21:37:44 <wli> Still getting segmentation faults during cabal install gtfs
21:37:47 <dmwit> "This macro is used to enforce static type safety by doing explicit casts wherever needed."
21:38:24 <dmwit> wli: Wow, are you still getting your new GHC set up? Weren't you fighting cabal like... two days ago??
21:38:57 <wli> dmwit: Not two days ago, last night. And I don't spend all day on all this.
21:39:04 <dmwit> of course
21:39:11 <dmwit> And I'm not blaming you.
21:39:27 <dmwit> I've probably spent several days total fighting various broken builds.
21:40:00 <wli> Okay, what's my recourse again?
21:40:30 <dmwit> I don't know. What's the newest situation?
21:40:46 <wli> dmwit: Nothing's new, I'm back where I left off.
21:41:26 <dmwit> If you want to start over, you can do it without nuking everything from orbit by unregistering any package shown in ghc-pkg list --user; the nuclear option is rm -r ~/.ghc
21:41:40 <dmwit> Actually, the latter is probably much simpler.
21:41:46 <wli> Unregistered everything and am trying cabal from there.
21:44:14 <wli> What's the —with-ghc-opts option actually again?
21:45:46 <dmwit> Where do you see that option?
21:46:15 <wli> I saw it last night, needed it for rowrecord
21:46:28 <dmwit> No, I mean, where in the documentation do you see it?
21:46:55 <wli> I don't see it anywhere in the docs because I don't remember its exact name.
21:47:03 <dmwit> From my reading, the only thing that really matches is in the configure/install step, as in --with-PROG=PATH
21:47:08 <wli> I think it may be —ghc-option= but am not sure.
21:47:20 <wli> It adds compile flags to the build.
21:47:25 <dmwit> Perhaps you're thinking about the ghc-options: block inside the cabal file?
21:47:46 <wli> It's not blocked, I just need to pass it.
21:48:18 <dmwit> I don't know a way of changing the options cabal passes to GHC from the command line.
21:48:21 <wli> I see what you mean. Yeah, I could pass it that way.
21:48:31 <wli> dmwit: Someone here did.
21:48:43 <dmwit> --PROG-options=OPTS looks promising, though I by no means guarantee that it works the way I think it works.
21:50:58 <wli> I think it's —ghc-option= or —ghc-options=
21:51:52 <elliott> Yeah, that appends though.
21:52:23 <wli> Okay, I needed appending anyway.
21:53:43 <wli> Looks like there's an OS X kernel issue hitting code loading. Weird segfaults happen unless I run sync before startup.
21:55:45 <nyingen> @quote
21:55:46 <lambdabot> Dianora says: He didn't bother waving his hands.
21:55:50 <nyingen> @quote
21:55:50 <lambdabot> bos says: [On the type signature of hPrintf] This makes me a sad Irish panda.
21:57:23 <dmwit> ?quote
21:57:23 <wli> I think I've got everything installed.
21:57:23 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. <souwh> oooh, those can be saved and reused later!
21:57:41 <nyingen> @quote wli
21:57:41 <lambdabot> wli says: My solution is to stop reading haskell.org
21:58:56 <wli> Now I have to figure out how to create tables and populate them in takusen.
22:04:51 <wli> The SIGSEGV was a missing library outright. rowrecord either wasn't installed or wasn't installed properly.
22:05:06 <wli> And the deps didn't notice it.
22:08:30 <nyingen> @quote dmit
22:08:30 <lambdabot> Cale says: Computing lengths is admitting defeat
22:08:33 <nyingen> @quote dmwit
22:08:34 <lambdabot> dmwit says: XML is syntactic foam.
22:08:40 <nyingen> amen, brother
22:12:24 <we23> Hi everybody, i need some advice. I am trying to set output in utf8. I can not install "encoding" pkg with cabal. I use haskell platform on windows7. Is there any other pkgs?
22:18:45 <nus-> we23, notice the package is dependent on ghc <6.10
22:19:01 <gienah> we23: try encoding-0.6.5.
22:19:42 <glguy> we23: You know that GHC now allows you to set the encoding on Handles, right?
22:19:44 <Cale> we23: um, is hSetEncoding in System.IO not enough here?
22:19:55 <glguy> (so you don't need an extra library to print in UTF-8 encoded text)
22:20:14 * gienah thinks encoding-0.6.6 is evil, was not uploaded by the maintainer, includes binaries when it should be source, has dubious patches not from the official repo
22:20:56 <nus-> gienah, are there reasons other than an old ghc version to use the package?
22:21:06 <we23> encoding-0.6.5 doesn't  work too.
22:21:08 <elliott> wait, someone made a major non-maintainer upload?
22:21:14 <elliott> without prior permission?
22:22:40 * gienah is looking if I did anything special to build encoding 0.6.5
22:24:25 <mdmarek_> Why does the following work!?
22:24:34 <mdmarek_> newtype Parser s t = P ([s] -> [([s],t)])
22:24:41 <gienah> elliott: I guess, I've emailed the maintainer twice with patches, guess he doesn't receive my emails
22:24:45 <mdmarek_> (<*>) :: Parser s (b -> a) -> Parser s b -> Parser s a
22:24:45 <mdmarek_> (<*>) (P p1) (P p2) = P ( \input -> [ (ss2,v1 v2) | (ss1,v1) <- p1 input, (ss2,v2) <- p2 ss1] )
22:25:15 <elliott> mdmarek_: it works because it's syntactically and semantically valid haskell
22:25:16 <mdmarek_> Specifically I don't understand the <- p1 input
22:25:27 <mdmarek_> or the <- p2 ss1
22:25:31 <elliott> that's a list comprehension
22:25:45 <mdmarek_> Yes it is!
22:25:47 <elliott> it's using the lists produced by the function applications (p1 input) and (p2 ss1)
22:25:51 <gienah> nus-: I don't know why you would use encoding, but I have tried to fix it to build with various ghc versions
22:25:55 <elliott> p1 :: [s] -> [([s],t)]
22:25:58 <elliott> per the definition of P
22:26:00 <elliott> same for p2
22:26:24 <mdmarek_> Thank you elliott
22:26:38 <elliott> np :p
22:27:06 <mdmarek_> Then one more question... what is (ss2, v1 v2)... why is that possible?
22:27:15 <mdmarek_> Should it not be (ss2, v1, v2)
22:28:55 <elliott> no, v1 is a value
22:29:02 <elliott> because the first parser has result (b -> a)
22:29:04 <elliott> so my type was actually wrong
22:29:04 <elliott> it's
22:29:11 <elliott> p1 :: [s] -> [([s],b -> a)]
22:29:15 <mdmarek_> is v1 a function?
22:29:17 <elliott> so v1 :: b -> a
22:29:18 <elliott> yep
22:29:19 <elliott> and v2 :: b
22:29:34 <mdmarek_> ahh...
22:30:14 <mdmarek_> I understand now. You are always of great help elliott...
22:30:19 <mdmarek_> thx
22:30:25 <elliott> yw :)
22:30:37 <elliott> basically p1 <*> p2 parses p1 then p2, in sequence
22:30:45 <elliott> and then applies the function result of the first to the result of the second
22:30:56 <elliott> except that with that type each input can have multiple possible parses
22:30:59 <elliott> so it's a bit trickier
22:31:21 <gienah> we23: I patched encoding for ghc 7.2.2, ghc 7.4.1, haxml 1.22, and ghc 6.12.3, my patches are here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/encoding/files
22:31:44 * gienah tried upstreaming the patches months ago, and again more recently
22:32:03 <mdmarek_> I take it from the list comprehension that for each function returned by <- p1 input
22:32:18 <mdmarek_> that function is run on each value from <- p2 ss1
22:33:17 <elliott> right
22:34:05 <we23> gienah: thank you, i will try it
22:43:43 <ramier> i just made a function that takes another function as an argument
22:43:47 <ramier> its better than sex
22:44:34 <sanjoyd> This has to go on bash.org
22:53:37 <gentleben> ramier: thats a rather strong statement
22:54:42 <tgeeky> ok. If I have this correct...
22:54:57 <tgeeky> Shouldn't we seriously consider the fact that cabal's default is: -- documentation: False
22:55:03 <tgeeky> because it causes ghc-pkg check
22:55:08 <tgeeky> to complain
22:55:23 <tgeeky> that's a bug
22:56:03 * tgeeky only knows Robert's Rules, so he waits for a "Second!"
22:56:35 <Veinor> haha
22:57:40 <tgeeky> actually, it generates 2 warnings for every package
22:57:54 <Veinor> it doesn't do that for me
22:58:02 <Veinor> well
22:58:03 <tgeeky> Veinor: you have changed your default cabal file
22:58:07 <Veinor> unless i... yeah
22:58:14 <tgeeky> I just reinstalled for the 5th time in a row on windows
22:58:16 <tgeeky> testing various things
22:58:32 <tgeeky> the default is clearly: -- documentation: False (meaning, that's the default value, and it's commented out too)
22:58:40 <Veinor> right, it is
22:58:52 <Veinor> but as long as i don't cabal install --enable-documentation anything, i don't get ghc-pkg check warnings
22:58:53 <tgeeky> and ghc-pkg check is often the first advice to figure out what's going on if you have a package problem
22:59:09 <zzo38> Is there an Either transformer, and if I use it with list monad can that do what I am attempting to do? (I also want to be able to do grouping with such a combination)
22:59:58 <tgeeky> Veinor: after I installed GHC 7.4.1 and cabal, the first thing I did was: cabal update, which generated the config file. Then I did: cabal install random, which did not generate any documentation. Then I did ghc-pkg check, and it has 2 warnings, for random
23:00:31 <Veinor> weird, i don't think it's ever done that for me before
23:00:42 <Veinor> i'd diagnose but i need to go to sleep
23:00:54 <tgeeky> Veinor: np, even discussing helps :O
23:01:18 <tgeeky> ghc-pkg
23:01:20 <tgeeky> errp
23:31:55 <hpaste_> wli pasted “generating function convolutions” at http://hpaste.org/67407
23:40:30 <wli> I gave up on efficiency and just wrote the definitions out.
23:45:35 <nus> wli, re: http://hpaste.org/67043 -- the problem there aren't GADTs, it's lists and maps not generic enough
23:46:08 <wli> nus: What should I do instead?
23:47:35 <nus> wli, f.e. http://www.haskell.org/haskellwiki/Type_families#Using_a_generic_map
23:49:30 <nus> @type fromList
23:49:31 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
23:49:36 <nus> @type Data.Map.fromList
23:49:37 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
23:51:05 <Axman6> @instances MonadRandom
23:51:06 <lambdabot> Couldn't find class `MonadRandom'. Try @instances-importing
23:51:10 <Axman6> no
23:51:37 * hackagebot buildbox 2.0.0.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.0.0.1 (BenLippmeier)
