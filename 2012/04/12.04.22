00:18:36 <Wooga> is it possible to write ``takeFirstWords input = map (head . words) $ lines input`` without introducing "input" variable?
00:19:51 <elliott> the answer is always yes
00:19:58 <elliott> in this case, it's even quite elegant
00:20:06 <elliott> @pl takeFirstWords input = map (head . words) $ lines input
00:20:06 <lambdabot> takeFirstWords = map (head . words) . lines
00:20:10 <Wooga> oh
00:20:13 <Wooga> thank you!
00:20:50 <shachaf> is it possible to write ``hiElliott (Foo x) = x'' without introducing "x" variable?
00:21:01 <shachaf> s/''/``/ # grr
00:21:02 <elliott> hiElliott = unFoo
00:21:16 <shachaf> data Foo = Foo { unBar :: Int } -- hi elliott
00:21:39 * hackagebot http-enumerator 0.7.3.3 - HTTP client package with enumerator interface and HTTPS support. (deprecated)  http://hackage.haskell.org/package/http-enumerator-0.7.3.3 (MichaelSnoyman)
00:35:57 <nand`> ?faq Can haskell write “takeFirstWords input = map (head . words) $ liens input” without introducing the “input” variable?
00:35:58 <lambdabot> The answer is: Yes! Haskell can do that.
00:37:14 <nand`> lines, even
00:37:46 <Saizan> ?pl takeFirstWords input = map (head . words) $ lines input
00:37:46 <lambdabot> takeFirstWords = map (head . words) . lines
00:40:07 <shachaf> elliott: hiElliott (Foo x y) = [x + y]
00:41:27 <shachaf> (data Foo = Foo { unFooX, unFooY :: Int })
00:41:37 <shachaf> That one will stump him for sure.
00:42:13 <elliott> hiElliott = (unFooX &&& unFooY) >>> uncurry (+) >>> pure
00:42:29 <nand`> hiElliot = return . (+) <$> unFooX <*> unFooY
00:42:44 <nand`> or pure, whatever
00:43:00 <Enigmagic> import Control.Monad.Instances; hiElliott = liftM2 (+) unFooX unFooY
00:43:07 <shachaf> elliott: WRONG
00:43:10 <shachaf> That's not the same function.
00:43:16 <elliott> it isn't?
00:43:26 <shachaf> hiElliott undefined `seq` ()
00:43:31 <elliott> Enigmagic: that won't work
00:43:39 <elliott> shachaf: oh come on
00:43:47 <Enigmagic> elliott: i forgot the list
00:43:55 <osa1> how does deriving from MonadIO work? does it work for any monad stacks with IO in it?
00:44:33 <shachaf> elliott: What?
00:45:09 <shachaf> osa1: Look up GeneralizedNewtypeDeriving for details.
00:45:19 <shachaf> @google generalised newtype deriving
00:45:22 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
00:45:22 <lambdabot> Title: NewtypeDeriving – Haskell Prime
00:45:32 <elliott> shachaf: that's so cheating
00:45:45 <shachaf> Which part, using @google?
00:45:48 <elliott> no
00:45:53 <elliott> hiElliott undefined
00:46:00 <shachaf> This isn't Agda.
00:46:42 <elliott> but it could be
00:47:16 <shachaf> Not enough Unicode.
01:00:47 <hpaste_> timthelion pasted “What are the types of updateMulti alsoUpdate and finallyUpdate?” at http://hpaste.org/67408
01:01:22 <timthelion> after struggling with the types of two functions for several hours, I gave up and deleted the type lines.  Now those functions magically compile and work.  Can GHC tell me the types those functions where given?
01:01:39 <geekosaur> load it in ghci and use :t
01:02:05 <timthelion> geekosaur: thanks
01:08:02 <TSC> Is there any way to get cabal to show the dependencies explicitly, so that I can try to fix the dreaded "This package indirectly depends on multiple versions of the same package" problem?
01:09:51 <geekosaur> -v usually shows what packages it's picking and why
01:10:52 <TSC> Ah, that will help, thanks
01:10:54 <sm> TSC: use install --dry -v3
01:11:21 <TSC> I'm only at the configure stage
01:11:38 <TSC> Oh, it still works
01:11:40 * hackagebot gist 0.1 - A reliable command-line client for gist.github.com  http://hackage.haskell.org/package/gist-0.1 (SimonMichael)
01:12:04 <TSC> If I do cabal install instead of configure, it all works
01:12:30 <TSC> What a pleasant surprise
01:13:31 <TSC> Is there some way to get it to do the "figure out solution and reinstall other packages" that install does, without actually installing the package I'm working on?
01:14:24 <donri> --only-dependencies? *just joined, missed discussion*
01:14:35 <sm> yes, if you want to actually install them, you can cabal install --only-dep
01:15:00 <TSC> Ah, wonderful
01:15:02 <TSC> Thanks!
01:15:04 <sm> and with latest cabal, --avoid-reinstall is often useful
01:15:25 <TSC> It would be nice if "cabal configure" suggested to run install --only-dep
01:15:33 <elliott> sm: and --solver=modular
01:15:44 <elliott> TSC: you can just "cabal install" if you want the whole thing installed in one go
01:16:00 <sm> elliott: yes, that's the default now with GHC >= 7
01:16:04 <sm> I typically only do cabal install --only-dep --avoid-reinstall --dry [-v3 if things get rough], and later cabal install --avoid-reinstall
01:16:17 <elliott> sm: huh? --solver=modular wasn't default in darcs a week or so ago
01:16:20 <donri> i think the idea is to get configure to pass so you can use build which is faster than install
01:16:47 <sm> cabal 1.14 was released
01:17:10 <elliott> i know it was, but i didn't know they made --solver=modular the default :)
01:17:31 <sm> yup, seems to be
01:17:48 <sm> I wonder why --avoid-reinstalls isn't default
01:17:49 <donri> --help says default: choose
01:18:07 <sm> yes, it chooses automatically based on GHC version
01:18:10 <donri> ah yea
01:18:26 <sm> which is good
01:18:29 <donri> how does the modular solver differ from topdown?
01:18:48 <sm> for one thing, Scientific Tests show it's 3 times faster
01:19:28 <sm> and gives much more useful logging.. aside from that I'm not sure
01:19:34 <elliott> why does it depend on ghc version, anyway?
01:20:00 <yitz> TSC: if you do everything inside cabal-dev, it's always safe to install everything. at worst, you can delete this sandbox and build again in a different one.
01:20:48 <Veinor> yeah
01:21:09 <TSC> Thanks, I'll check out cabal-dev
01:21:33 <Veinor> that reminds me, is cabal-dev still under active development? last commit was 2 months ago :(
01:21:57 <yitz> Veinor: it's used actively by its developers.
01:22:16 <Veinor> well sure i believe it's used actively :)
01:22:20 <elliott> it's not that much code, surely
01:22:26 <elliott> doesn't seem that weird if it doesn't change in a few months
01:22:33 <Veinor> i'm just saying, there are a couple outstanding issues that i think could really use some work
01:22:55 <yitz> Veinor: they are busy with other things, but occasionally they improve cabal-dev. if anything breaks, they fix it right away.
01:23:08 <Veinor> sure :)
01:23:14 <donri> you'll want to set up a shell alias like cabal-dev='PATH=$PWD/cabal-dev/bin:$PATH cabal-dev' to work around a bug in cabal-dev
01:23:14 <yitz> Veinor: so the cabal-dev code is definitely not bitrotted in any way, if that's what you are worried about.
01:23:37 <Veinor> donri: ?
01:23:39 <donri> i should probably report that upstream, lazy :P
01:23:41 <Veinor> what's the bug?
01:23:51 <yitz> donri: why? i have no such alias and everything works perfectly for me.
01:23:58 <donri> Veinor: some packages install preprocessors that other packages then depend on being in $PATH
01:24:03 <Veinor> ahhh
01:24:06 <elliott> those should be installed globally
01:24:13 <elliott> the fact that the preprocessors are written in haskell is irrelevant
01:24:19 <elliott> just like e.g. you wouldn't install gcc into the sandbox
01:24:27 <elliott> even if a package required it
01:24:32 <Veinor> yeah i always have a global install of alex/happy/whatever
01:24:39 <elliott> (you can build the preprocessors in another sandbox if you want and put that on the PATH)
01:25:07 <donri> that attitude sort of ruins hsp and HTF for two examples
01:26:41 * hackagebot colada 0.4.2 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.4.2 (GrzegorzChrupala)
01:26:48 <yitz> donri: i like elliot's solution.
01:27:02 <donri> (i'm specifically talking about OPTIONS_GHC -pgmF pragmas here)
01:27:19 <yitz> elliott: i don't agree that they should be installed globally. i should always have control over that.
01:27:41 <elliott> well, i generally install "apps" globally.
01:27:46 <elliott> obviously there's no requirement
01:27:54 <elliott> a sandbox per program is a bit too fiddly for me
01:28:00 <donri> -pgmF preprocessors aren't really "apps"
01:28:01 <yitz> elliott: packages that build something then assume that what they built is immediately available globally have a broken build process. in any language, not just haskell.
01:28:26 <Veinor> one of the kind of annoying cases is doing stiff with, say, yesod
01:28:44 <Veinor> where yesod init generates a scaffold that's only guaranteed to work with that same version of yesod
01:28:47 <elliott> yitz: uh, i never said anything of the sort
01:28:51 <Orclev_> I've also run into problems with cabal-dev and virthualenv when building some libraries with FFI bindings, if I remember GTK in particular is flaky if not installed with cabal install --global
01:29:01 <elliott> if something needs happy or alex and it isn't present it just gives up
01:29:04 <yitz> elliott: ok i misunderstood what you said :)
01:29:07 <elliott> how you install it is up to you, the fact that it's haskell is irrelevant
01:29:35 <yitz> < elliott> those should be installed globally
01:29:48 <donri> the trhsx executable from hsx is dependent on you importing modules from the same package. it's a library not a command-line tool you invoke yourself or from your program.
01:29:48 <elliott> well, "globally" as in "outside the sandbox"
01:30:05 <yitz> right, no build process should ever do that.
01:31:06 <yitz> like, if i type "make", i don't expect anything to be installed outside that directory tree until i later type "sudo make install". including any intermediate tools that are built.
01:31:30 <elliott> err, i never suggested that
01:31:40 <elliott> by "should" I meant _you_ the developer should install them globally
01:31:43 <elliott> by typing cabal install happy alex
01:31:58 <yitz> elliott: ok yeah now i understand that's what you meant.
01:32:04 <elliott> :)
01:36:50 <yitz> i can see how it would be convenient to have a cabal-dev alias like what donri said. personally i still prefer to watch broken build processes break, then manually make available whatever they need to have on the PATH.
01:37:35 <yitz> i find i can still build even complex things like yesod without *that* much trouble. i also don't do it that often.
01:39:59 <donri> I also have "cabal-dev/bin" in my actual $PATH :)
01:40:19 <yitz> donri: re: trhsx: hmm, seems there should be some way for that to work without having to put anything on the PATH in the middle of the build process.
01:40:33 <yitz> donri: ok, i can hear that. :)
01:42:02 <yitz> part of the issue i think is that TH needs pre-built things available.
01:42:12 <donri> i prefer to have the dependency on trhsx managed by cabal for the same reasons i use cabal at all
01:42:22 <donri> trhsx isn't TH
01:42:51 <donri> there's work ongoing for a QQ variant that doesn't need trhsx, with a different set of pros/cons
01:42:53 <yitz> ok just pointing out another place where this issue often comes up. i think that's where yesod gets into trouble, for example.
01:44:05 <donri> you mean for things like the coffee quoter?
01:44:25 <donri> that's more obviously an external dependency than hsx
01:47:03 <donri> really though this should be fixed in cabal proper not cabal-dev... add to $PATH any bin dirs next to the paths in $GHC_PKG_PATH or whatever that one is called
01:54:44 <Guest44571> hello
01:55:17 <timthelion> Guest44571: hi
01:57:49 <Guest44571> i need some help on parallelism
01:58:18 <timthelion> Guest44571: what kind of help?
01:59:01 <Guest44571> its for uni/college. im having a hard time why we need to use stategies
01:59:12 <Guest44571> understanding*
02:00:51 <timthelion> http://hackage.haskell.org/packages/archive/parallel/3.1.0.1/doc/html/Control-Parallel-Strategies.html
02:02:42 <Guest44571> ive tried to understand that page for a while, but i cant seem to understand it.
02:02:56 <timthelion> and this one? http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html
02:03:29 <Guest44571> i will try that one
02:04:17 * timthelion is not in a place to help, as he is hearing about strategies for the first time now :)
02:27:20 <efie> can I not substitute a with (Int,Int) in data Tree a = EmptyTree | Node a (Tree a) (Tree a)?
02:27:26 <efie> why*
02:30:21 <ziman> what's the error you're getting?
02:34:39 <efie> ziman: Type found: (Int, Int)     where type variable expected, in: (Int, Int)
02:35:34 <Wooga> *crank*
02:35:47 <yitz> efie: you can't put (Int, Int) on the LHS of a data declaration, no.
02:36:14 <yitz> efie: you can leave out a altogether and code (Int, Int) in its place everywhere on the RHS, or
02:37:04 <yitz> efie: you can leave the data declaration as it is, and use Tree (Int, Int) everywhere in the rest of your program.
02:37:27 <efie> ok - anyway, why it is forbidden?
02:37:38 <yitz> efie: it doesn't make sense
02:38:21 <yitz> efie: you are define a "type function". pattern matching is not supported for those, so the only thing that makes sense is a variable.
02:38:26 <yitz> *defining
02:39:01 <geekosaur> what would the meaning of `data Tree (Int,Int) = ...' be?
02:39:02 <efie> yitz: hm ok, thanks
02:39:19 <geekosaur> the whole point of parameters to `data Foo' is that they be variable
02:46:43 * hackagebot language-javascript 0.5.2 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.2 (AlanZimmerman)
02:53:05 <na_ka_na> hey guys i'm new to haskell, have a newb question, this works let mult4 x = (*2) $ (*2) x, but this doesn't let mult4 = (*2) $ (*2), is it a syntax problem ?
02:53:29 <shachaf> Sort of.
02:53:38 <shachaf> Do you know what $ does?
02:54:37 <na_ka_na> i think it starts a scope, like f x $ g y = f(x, g(y))
02:54:47 <Tomsik> na_ka_na, the second one is equivalent to mult4 x = ((*2) $ (*2)) x
02:55:06 <na_ka_na> instead of f(x, g, y)
02:55:07 <Tomsik> and probably the problem is with trying to apply (*2) to (*2)
02:55:19 <na_ka_na> yup that's the problem
02:56:05 <Tomsik> > let mult4 = (*2) . (*2) in mult4 4
02:56:06 <lambdabot>   16
02:56:17 <shachaf> na_ka_na: In Haskell syntax, f x $ g y === f x (g y)
02:56:32 <shachaf> So expand the definition of $: mult4 = (*2) ((*2))
02:56:43 <pigworker> Hi folks! I'm just failing to remember how to make ghci use Control.Newtype (in the newtype package). Can anyone remind me?
02:56:56 <na_ka_na> hmm, got it! didn't know about .
02:58:19 <shachaf> Use it as in import the module?
02:58:35 <hpaste_> mu pasted “Euterpea install” at http://hpaste.org/67409
02:58:47 <Tomsik> Is :l what you need?
02:58:52 <pigworker> yes, I put an import in my file, and ghci says "what the hell is Control.Newtype?"
02:58:57 <na_ka_na> hmm $ and . are operators, makes sense now
02:59:04 <shachaf> pigworker: :m + Control.Newtype should work.
02:59:06 <yitz> pigworker: in recent ghc, just type import statements at the ghci prompt
02:59:14 <shachaf> import Control.Newtype works since GHC 7.x.
02:59:16 <mukilan> hey, i'm trying to install Euterpea in ubuntu 11.0
02:59:37 <mukilan> i get these errors when i try cabal install http://hpaste.org/67409
03:00:05 <yitz> pigworker: or, old style, use :m as shachaf says to control what's in scope
03:00:26 <pigworker> ok, so I do :m +Control.Newtype and I get a complaint
03:00:33 <shachaf> yitz: :m has some advantages over import still. :-)
03:00:36 <shachaf> What's the complaint?
03:00:45 <pigworker> I do import Control.Newtype and I get no complaint or acknowledgement
03:00:54 <pigworker> Could not find module `Control.Newtype'
03:00:54 <pigworker>     Use -v to see a list of the files searched for.
03:00:55 <yitz> pigworker: i still use the :m stuff, because early 7.* ghci had some bug in the way import worked in ghci. not sure exactly what version fixed it
03:01:12 <pigworker> Prelude Data.List> :show packages
03:01:12 <pigworker> active package flags: none
03:01:13 <shachaf> pigworker: Does it get added to your prompt with "import"?
03:01:15 <yitz> shachaf: yes. 1. avoid said bug. 2. easier to type
03:01:22 <shachaf> pigworker: Are you sure it's installed?
03:01:29 <pigworker> no
03:01:46 <shachaf> yitz: 3. multiple imports on one line 4. :m - and :m, not just :m +
03:01:55 <yitz> advantage of import of :m is that you get to use "qualified".
03:02:06 <shachaf> Right, and hiding, and (), and so on.
03:02:26 <yitz> shachaf: 3. and 4. : ah yes, check.
03:03:32 <pigworker> ok, doing a reinstall of newtype sorted it out
03:03:51 <pigworker> I'm sure I didn't uninstall newtype
03:04:02 <shachaf> Maybe you're using a different version of GHC from when you installed it?
03:04:07 <shachaf> Each version has its own set of packages.
03:04:26 <pigworker> that's possible, but infuriating
03:05:41 <pigworker> I wonder what else has quietly stopped being there, apart from several thousand brain cells.
03:08:59 <shachaf> Hmm, "import Nonexistent.Module" silently fails.
03:09:02 <shachaf> That's probably a bug.
03:11:44 * hackagebot dtd 0.5.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.5.1 (MichaelSnoyman)
03:12:11 <pigworker> how hard would it be to make each new version install hunt out old installations and compile a list of packages which might need a reinstall?
03:13:08 <shachaf> pigworker: cabal maintains a list of installed packages in ~/.cabal/world
03:13:46 <pigworker> ok, so what happens to that on version update?
03:14:16 <shachaf> Not much. The old packages stick around -- you can still use the old GHC with the old packages, just not the new one.
03:14:48 <pigworker> ok, so all the data is present to give dimwits like me a better diagnosis of the problem
03:15:07 <shachaf> More or less.
03:15:14 <shachaf> Though I don't know that GHCi should know about Cabal.
03:16:36 <pigworker> given how much stuff has been moved out into hackage, that's less and less tenable
03:16:45 <shachaf> Possibly true.
03:16:50 <shachaf> You can always do something like $ cat .cabal/world | xargs -d '\n' cabal install
03:16:58 <shachaf> (That exact command line probably won't work/be a good idea.)
03:16:58 <pigworker> wrong pronoun
03:17:06 <pigworker> *I* can't do anything like that
03:17:35 <shergill> 'cabal install world' also works
03:17:50 <shachaf> shergill++
03:18:04 <pigworker> meaning "bring back everything I thought I had"? if only that worked on life
03:19:03 <killy9999> is there a way to automagically execute some commands at ghci startup like loading some modules, setting up a prompt etc.?
03:19:15 <shachaf> killy9999: Put them in ~/.ghci
03:19:29 <shachaf> (Or, alternatively, in .ghci in the current directory. Although it's kind of crazy that that works.)
03:19:34 <killy9999> ok
03:20:11 <killy9999> I would've guessed it if only ghci created some empty configuration file so I could know I can use it :)
03:23:23 <killy9999> when doing I/O should I use the 'do' notation or monadic binds >> and >>= ?
03:23:34 <killy9999> for the compiler it's ultimately the same, right?
03:24:16 <TSC> Yes, for the compiler it's the same
03:24:32 <shachaf> For the compiler it's different. For everything else it's the same. :-)
03:24:41 <TSC> Ha (:
03:24:48 <TSC> Is it possible to provide command line arguments for a program if you're running it in GHCi?
03:25:00 <killy9999> main arg1 arg2 ?
03:25:01 <shachaf> :set args, or something like that.
03:25:03 <Tomsik> I prefer to use =<< if it's just one
03:25:10 <Tomsik> and do notation for bigger blocks of code
03:25:12 <shachaf> Oh, it's :main args
03:25:42 <killy9999> Tomsik: thanks
03:25:44 <mekeor> shachaf: AFAIK both work
03:26:04 <shachaf> Yep.
03:26:12 <killy9999> I'm trying to figure out the best style to write my code
03:26:34 <shachaf> Just do whatever seems nicest.
03:26:46 <shachaf> Eventually you'll develop a niceness taste and then look at your old code in disgust.
03:27:07 <killy9999> :)
03:28:55 <Wooga> hi, is there a way to trace execution of expression in ghci/or in other similar tool?
03:29:06 <Wooga> s/execution/evaluation/
03:29:35 <shachaf> ghci has a debugger.
03:30:02 <killy9999> Wooga: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-debugger.html
03:30:40 <Wooga> shachaf: killy9999: thank you!
03:31:48 <killy9999> RWH says: "You can store and pass actions in pure code if you wish, though this isn't frequently done."
03:31:54 <killy9999> this confuses me
03:32:33 <shachaf> An "action" is a value. You can use it anywhere you can use values.
03:32:36 <Botje> nobody stops you from making a list of 50,000 getLine actions.
03:32:41 <killy9999> if I have an action in some function doesn't it automatically become impure?
03:32:52 <killy9999> well, yes
03:32:55 <zomg> Only if you run it
03:33:08 <killy9999> and I know that actions aren't performed until they are evaluated
03:33:15 <shachaf> No, nothing is "automatic".
03:33:15 <TSC> shachaf: Thanks
03:33:20 <shachaf> killy9999: That's incorrect.
03:33:23 <killy9999> by I'm wondering if putting things that way makes much sense...
03:33:25 <shachaf> Evaluation has nothing to do with execution.
03:33:55 * killy9999 thinks about that
03:34:14 <shachaf> The FAQ will probably be helpful.
03:34:16 <shachaf> @where faq
03:34:16 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:34:30 <killy9999> yeah, ok, I should have written executed instead of evaluated
03:34:57 * killy9999 RTFM's
03:39:02 <mukilan> can any one please help me with this error: Loading package old-locale-1.0.0.2 ... linking ... <interactive>: /home/mukilan/.cabal/lib/GLFW-0.5.0.1/ghc-7.0.3/HSGLFW-0.5.0.1.o: unknown symbol `atexit'
03:55:50 * pigworker just made a newtype wrapper ListU for [], to make Eq x => Monoid [x] with [] and union. Should that be standard issue?
04:00:15 <adnauseam> > (\x -> guard ((length x) == 4) "waht"
04:00:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:00:29 <adnauseam> > (\x -> guard ((length x) == 4)) "waht"
04:00:29 <lambdabot>   No instance for (GHC.Show.Show (m ()))
04:00:30 <lambdabot>    arising from a use of `M695154003...
04:00:44 <Overflight> Hello?
04:00:55 <adnauseam> > (\x -> guard ((length x) == 4) >> return x) "waht"
04:00:56 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
04:00:56 <lambdabot>    arising from a use ...
04:00:57 <stefanooldeman> In this tutorial for HTF there is something i'm missing… i don't get it where does the "reverseTests " function comes from.. http://hackage.haskell.org/packages/archive/HTF/0.5.0.0/doc/html/Test-Framework-Tutorial.html
04:01:52 <adnauseam> > let hello = "is it me you're looking for?" in hello
04:01:52 <lambdabot>   "is it me you're looking for?"
04:02:12 <Overflight> I'm not looking for anyone in particular :-P
04:02:38 <adnauseam> that will only get you raped, young lady
04:02:40 <Overflight> I found this link via the Try Haskell tutorial
04:03:00 <adnauseam> then it must be a good link
04:03:10 <adnauseam> welcome to #haskell
04:03:11 <Overflight> So I hope you don't mind if I ask this channel a bunch of noob questions
04:03:14 <Overflight> Thanks :-)
04:03:31 <adnauseam> they don't mind me asking them, so i'm sure they won't mind you asking them too :)
04:03:49 <srhb> That's not very fair, we roll a die, you were just lucky adnauseam.
04:04:05 <Overflight> Well my questions are a tad generic
04:09:15 <Wooga> oh yeah! after a couple of hours, pencil & papaer work and ghci debugging i've got how foldl is getting implemented via foldr %)
04:09:48 <adnauseam> i dont mind being lucky :o)
04:10:35 <Wooga> here is what helped me to understand it: http://paste.pocoo.org/show/585544/
04:10:44 <killy9999> Wooga: doing RWH exercises?
04:10:48 <Wooga> killy9999: yea
04:10:58 <adnauseam> wooga, nice man
04:10:59 <killy9999> I skipped that one :(
04:11:08 <adnauseam> im goingto start with real world haskell soon
04:11:49 <killy9999> I just finished the 7th chapter today
04:11:50 * hackagebot cabal-macosx 0.2.2 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.2.2 (EricKow)
04:13:10 <adnauseam> in which chapter does the assignment of foldr come ?
04:13:48 <Wooga> assignment?
04:14:33 <adnauseam> the one you did wooga
04:14:40 <Wooga> ah, the example i was trying understand to was from chapter 4. - Functional programming
04:14:54 <efie> Just to make sure I don't get carried away: If I use the data structure "data Tree a = EmptyTree | Node a [(Tree a)]", is it possible to write a fuction with the return type "[[a]]" which gives me all the lists of a's which are there on these ways through the tree which end in "Empty Tree"?
04:15:16 <adnauseam> excellent, early on:>
04:16:15 <pigworker> efie: looks like a job for list comprehensions to me
04:17:03 <efie> pigworker: So you think it is possible to write a function like this?
04:17:28 <pigworker> yes
04:17:38 <efie> ok, thanks
04:18:01 <pigworker> for EmptyTree, you should get [[]], ie one empty path
04:18:28 <killy9999> Haskel uses Hindley-Milner?
04:19:25 <efie> pigworker: yeah
04:19:42 <MaskRay> how to use 'lexically scoped type variables' in functions in instance definition?
04:19:59 <pigworker> for (Node a ts), you want to cons a onto all the paths from all the subtrees of ts, so list comprehensions are good kit
04:21:25 <MaskRay> In http://hpaste.org/67410  , how can i make the commented lines available?
04:22:04 <efie> pigworker: I think I get the idea, but what does cons exactly mean?
04:22:34 <pigworker> efie: "cons" is just the way to pronounce the ":" constructor of lists
04:22:46 <efie> ah, ok :)
04:25:46 <cts> MaskRay: In the comments are switches for ghc.  They are active as they are now.
04:28:08 <pigworker> killy9999: Haskell's type system has Hindley-Milner at the heart of it, but there's a lot more going on.
04:28:24 <MaskRay> cts: Could you please elaborate your elucidation? I want to use the 'forall b' defined in the 'class FibonacciCoding'
04:29:33 <srhb> cts: The comment is further down.
04:29:38 <srhb> cts: They are type signatures
04:30:00 <srhb> cts: --decode :: ...
04:30:07 <srhb> Not the pragmas. :)
04:30:20 <MaskRay> I mean to bring the type variable 'b' (defined in 'class FibonacciCoding') into scope
04:31:46 <MaskRay> Simply copying 'forall b. BitStream b => a -> b' from class definition to instance definition does not work
04:32:16 <MaskRay> ghc complains ' Misplaced type signature: encode :: forall b. BitStream b => a -> b'
04:32:47 <srhb> And one should think ScopedTypeVariables fixes that...
04:33:06 <efie> pigworker: should I not get [] for EmptyTree? so that the a's can be concatenated
04:33:18 <cts> MaskRay: Actually I never understood why it is necessary to say "forall",
04:33:19 <cts> because when declaring a function, one always means "forall".
04:33:21 <killy9999> pigworker: thanks
04:33:40 <srhb> cts: It has nothing to do with that though..
04:33:54 <efie> I'm also not sure how to decide for which of the subtrees I should create a list or append a
04:34:07 <srhb> MaskRay: http://stackoverflow.com/questions/8367426/why-cant-one-put-type-signatures-in-instance-declarations-in-haskell
04:34:35 <cts> srhb, MaskRay: And I never managed to give type signatures inside a function as you try.
04:35:26 <srhb> MaskRay: Also: http://hackage.haskell.org/trac/ghc/ticket/5676
04:35:30 <MaskRay> srhb: Then is there other approaches to bring the type variable 'b' into scope?
04:35:57 <srhb> MaskRay: Apparently it'll be in ghc 7.6
04:36:09 <srhb> MaskRay: Until then, just omit them like you did.
04:36:41 <srhb> MaskRay: Or declare them with their signatures outside the instance, and alias them in the instance.
04:37:47 <MaskRay> srhb: OK, i'll wait for 7.6 ...
04:38:20 <srhb> MaskRay: The pragma will be called "InstanceSigs"
04:38:42 <cts> srhb: And what is forall for?
04:39:09 <MaskRay> srhb: Did your last sentence mean 'move decode out of the class and define a proxy function in the class'
04:39:20 <srhb> MaskRay: Yes it did.
04:39:59 <srhb> MaskRay: Out of instance, though.. ^^
04:40:00 <chrisdone> anyone use SDL-image on ubuntu/debian and managed to solve the ./configure failure?
04:40:01 <lambdabot> chrisdone: You have 8 new messages. '/msg lambdabot @messages' to read them.
04:41:13 <srhb> MaskRay: So in the instance you get decode = decodeWithAnnotation
04:41:25 <MaskRay> cts: Using the extension ScopedTypeVariables to make type variables visible
04:42:21 <srhb> forall seems horribly overloaded..
04:42:31 <srhb> But I guess they're all the same.
04:43:48 <MaskRay> At least 3 semantics afaik
04:45:56 <MaskRay> existential quantifier, scoped type variables and its literal meaning
04:47:50 <killy9999> there seems to be a problem at HaskellWiki. When I try to add Haskell Wiki search to my list of firefox search engines I get an error
04:48:17 <killy9999> it says that there is no search plugin at http://www.haskell.org/haskellwiki/opensearch_desc.php
04:48:35 <killy9999> to whom should I report this?
04:55:27 <dvaerg> hey there, i'm a newbie to haskell and try to solve some homework problems, now i defined a function trans, which is about some  basic concepts of haskell (guards, cons-operator) but somehow it complains about the return value of trans. here is the code http://snipurl.com/23622hz-2602
04:56:52 * hackagebot multiplate-simplified 0.0.0.2 - Shorter, more generic functions for Multiplate.  http://hackage.haskell.org/package/multiplate-simplified-0.0.0.2 (BalazsEndresz)
04:58:02 <cts> dvaerg: Try "(trans xy)" instead of "[trans xy]".
04:58:30 <geekosaur> yes, trans already returns a list, you don't need to wrap it in another one
04:58:36 <dvaerg> ahhh
04:58:38 <dvaerg> :)
04:59:27 <geekosaur> also, I'd write (x + y):trans xs instead of [x + y] ++ trans xs
04:59:39 <geekosaur> and similarly for the other case
04:59:49 <Tomsik> Is there a good reason why Euterpea is not on hackage?
05:00:08 <mukilan> can any one please help me with this error: Loading package old-locale-1.0.0.2 ... linking ... <interactive>: /home/m/.cabal/lib/GLFW-0.5.0.1/ghc-7.0.3/HSGLFW-0.5.0.1.o: unknown symbol `atexit'
05:01:13 <dcoutts_> sounds like HSGLFW is missing a "extra-libraries" reference
05:01:52 <geekosaur> atexit is part of libc
05:03:01 <mukilan> what should i do to fix it?
05:03:27 <dvaerg> geekosaur: you may explain why, guy who is teaching us haskell says it's about the same "[x] ++ [y]" vs. "x:y:[]"
05:04:05 <geekosaur> dvaerg, it has the same end result but the ++ verdsion builds a single element list only to throw it away immediately
05:04:19 <geekosaur> mukilan, this is from ghci?
05:05:01 <mukilan> geekosaur: yes gchi v 7.0.3 . I am trying to run the examples from Euterpea
05:07:00 <geekosaur> the only fix is "don't do GUI stuff from ghci"; it's problematic in general, and ghci often has odd issues with functions that hook the C runtime in interesting ways (like atexit, the use of which by GLFW could well lead to core dumps)
05:07:52 <srhb> dvaerg: Is that your real first name? :o
05:08:16 <dvaerg> srhb: yeah, why you ask?
05:08:46 <dvaerg> thx @geekosaur @cts
05:08:57 <srhb> dvaerg: It means dwarf in Danish.. Well, dværg does. That's nice. ^^
05:09:12 <dvaerg> srhb: i know :)
05:09:16 <mukilan> i've managed to track down the problem to this http://hackage.haskell.org/trac/ghc/ticket/4456 using google...does this mean it is fixed in 7.2.1??
05:09:22 <everythingWorks> .
05:09:32 <srhb> dvaerg: I'll just be fascinated over here in my corner then. ;)
05:10:14 <dvaerg> srhb: fortunately, im not at home in Scandinavia
05:10:30 <dvaerg> not to say that i have something against it :)
05:10:35 <geekosaur> that particular instance is/was, but (a) I have no idea how HSGLFW was linked (b) no idea if it got broekn again (it was fixed back in 6.13.1 if I read that bug right) (c) atexit being problematic in genera, it's possible it was broken deliberately as a warning to not use it
05:10:42 <srhb> dvaerg: Ah well. :-) I can imagine it would get tiresome.
05:11:50 <geekosaur> (basically queueing an atexit() hook from inside the haskell runtime can lead to haskell data potentially being accessed after the runtime has been shut down)
05:14:00 <chrisdone> hm, is there a ghc warning to warn on incomplete guards?
05:14:16 <dixie> question is following: How to convert Char to Word8 ? I rather, how to use '\n' literal with Data.ByteString ?
05:15:20 <chrisdone> :t ord
05:15:20 <lambdabot> Char -> Int
05:16:02 <mukilan> geekosaur: So is there any other way to try out the examples here (http://haskell.cs.yale.edu/?page_id=269)...?
05:17:39 <dixie> chrisdone: still doesn't work... Couldn't match expected type `GHC.Word.Word8' with actual type `Int'
05:17:44 <joachifm> dixie: see Data.ByteString.Internal
05:18:24 <geekosaur> dixie, you want to use fromIntegral along with that to convert the Int to Word8
05:18:35 <geekosaur> mukilan, I don't know.
05:19:02 <dixie> joachifm: I'm getting 404 on Data.ByteString.Internal on hackage :(
05:19:13 <joachifm> dixie: the function you want is c2w
05:19:13 <geekosaur> chrisdone, -Wall probably tries, but unlike patterns I suspect it's not entirely reliable (read:  doing it right is the halting problem)
05:19:15 <dixie> geekosaur: thanks. I will try. I expected there is more elegant solution
05:19:16 <fmap> dixie: w2c and c2w from Data.ByteString.Internal
05:19:16 <mukilan> geekosaur: Oh ok, thanks for your help.
05:19:19 <fmap> iirc
05:20:10 <dixie> thanks, all. c2w... I need to dig more into Data.ByteString.Internal
05:20:41 <rs46> If I am using haskell code that has #ifndef macros, how do I use them... e.g. in this code: "#ifndef LAZY"
05:20:44 <rs46> I want to turn this flag on
05:20:51 <geekosaur> mukilan, basically without answers to the issues I raised earlier, there are no suggestions I can make.  best I can suggest is try reopening that bug, or maybe filing a bug against HSGLFW
05:20:57 <dixie> anyway, one clarification. Do you have also 404 on http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Internal.html ?
05:23:18 <chrisdone> geekosaur: i think always having an otherwise case would be ok to ensure complete guards
05:24:51 <rs46> Is there any way to tell ghc to allocate longer periods of time to executing Haskell threads? I want threads to be given more CPU time, and less threads allocation switching
05:25:06 <fmap> dixie: yes
05:27:05 <chrisdone> geekosaur: oh, it seems ghc already does this. then THAT MEANS NIKLAS IGNORED THE WARNING!!11
05:27:51 <chrisdone> cpp2hask on http://hackage.haskell.org/packages/archive/cpphs/1.13.3/doc/html/src/Language-Preprocessor-Cpphs-Position.html#line-87 — GHC warned of this…
05:44:48 <dixie> question: with parsec3 I can use Text.Parsec.ByteString but I still need to pack result of parser when I apply in parser something like "xs <- many1 digit". Am I right or I overlooked something ?
05:45:36 <hiptobecubic> how does (-) work as a binary and a unary operator?
05:46:50 <dixie> > :t (-)
05:46:51 <byorgey> hiptobecubic: parser shenanigans
05:46:51 <lambdabot>   <no location info>: parse error on input `:'
05:46:55 * hackagebot snap-server 0.8.1.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.8.1.1 (GregoryCollins)
05:46:55 <dixie> :t (-)
05:46:56 <lambdabot> forall a. (Num a) => a -> a -> a
05:47:26 <hiptobecubic> :t (2-)
05:47:27 <lambdabot> forall t. (Num t) => t -> t
05:47:31 <hiptobecubic> :t (-2)
05:47:31 <lambdabot> forall a. (Num a) => a
05:47:48 <dixie> :t -2
05:47:49 <lambdabot> forall a. (Num a) => a
05:48:49 <akosch> shameless self-promotion: http://stackoverflow.com/questions/10268052/generating-code-for-another-language-in-haskell
05:49:27 <byorgey> dixie: I think you're right.  If you're worried about performance you may want to look at something like attoparsec.
05:59:17 <geekosaur> chrisdone, yes,that was what I meant; checking for an otherwise case is easy, analyzing all provided cases to see if they're complete as is, not so much
06:00:39 <chrisdone> geekosaur: yes
06:01:50 <bobfang> say I have a string, I want convert every substring "sin" into "sin ", how should write a function to do it? THX
06:02:31 <bobfang> I mean every occurrence  of "sin" in the original string is replaced by "sin "
06:02:50 <chrisdone> there is replace in the missingH library
06:03:06 <chrisdone> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html#v%3Areplace
06:03:59 <chrisdone> or if you're using the split library you can split and use intercalate
06:04:03 <bobfang> Can I write it myself...
06:04:23 <bobfang> I am not supposed to use any function outside standard library
06:10:08 <Nimatek> > let replace _ _ [] = []; replace old new l@(x:xs) | old `isPrefixOf` l = new ++ replace old new rest | otherwise = x : replace old new xs where rest = drop (length old) l in replace "sin" "sin " "sinlolsinder"
06:10:09 <lambdabot>   "sin lolsin der"
06:11:50 <navaati> hello
06:13:47 <bobfang> hi
06:16:59 * hackagebot usb-id-database 0.4.0.7 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.7 (RoelVanDijk)
06:32:01 * hackagebot ls-usb 0.1.0.11 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.11 (RoelVanDijk)
06:34:50 <navaati> dmwit: hey, sorry to bother you but… what about this cairo update :] ?
06:39:30 <Wooga> hi, is there a way to terminate foldr execution as it possible with explicit recutsion here: http://paste.pocoo.org/show/585575/ ?
06:40:10 <Wooga> here both functions work on finite lists, but on infinite ones foldr hangs even when predicate failed
06:42:23 <navaati> Wooga: if your function can stop before having processed the whole list, then it's not a fold ;)
06:42:50 <Wooga> ah
06:42:51 <rwbarton> your "translation" to use foldr is wrong
06:43:24 <rwbarton> those two functions don't do the same thing even on finite lists
06:44:04 <srhb> Isn't there a fold with Maybes in the standard library which short-circuits on the first Nothing value? I think I saw that..
06:44:31 <rwbarton> your myTakeWhile *can* be written as a foldr, just not like this.
06:44:31 <parcs`> do you mean unfold
06:44:33 <parcs`> :t unfold
06:44:34 <lambdabot> Not in scope: `unfold'
06:44:36 <parcs`> :t unfoldr
06:44:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:44:39 <navaati> it's not fold, it's unfold
06:44:53 <navaati> (oh, lag)
06:44:57 <srhb> No, I was thinking of a short-circuiting fold. Maybe I wrote it myself. :-)
06:45:01 <Wooga> rwbarton: but how?
06:45:54 <rwbarton> Wooga, well i suggest you first experiment and verify for yourself that what i said earlier is true
06:46:00 <rwbarton> then, figure out what is wrong and how to fix it!
06:46:04 <rwbarton> no magic here
06:47:13 <rwbarton> what you have is close to being right, you just need to think a bit more carefully
06:48:06 <Wooga> aha, i see, the Fold implementation is porcessing each list element seperatly, it's more like filter
06:52:18 <srhb> I don't think I understand how regular foldr terminates when you don't use the next item in the list, though.. Something really smart is happening I'm sure.
06:52:19 <srhb> :P
06:53:28 <Wooga> yeah, and also i can't see how to solve this even for finite list in elegant way withou having accamulator like (True,[]) - where bool is for if predicate failed
06:54:01 <srhb> > foldr (\x y -> if x < 10 then x+y else x) [1..]
06:54:01 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
06:54:02 <lambdabot>    arising from a us...
06:54:18 <srhb> > foldr (\x y -> if x < 10 then x+y else x) 0 [1..]
06:54:19 <lambdabot>   55
06:54:37 * srhb has her brain melted
06:55:58 <Wooga> must be some kind of optimization...
06:56:00 <Wooga> > foldr (\x y -> x) 0 [1..]
06:56:01 <lambdabot>   1
06:56:03 <hpc> if it helps, you can do some renaming
06:56:04 <Wooga> > foldr (\x y -> y) 0 [1..]
06:56:07 <lambdabot>   mueval-core: Time limit exceeded
06:56:22 <hpc> > foldr (\x sum -> if x < 10 then x + sum else x) 0 [1..]
06:56:23 <lambdabot>   55
06:56:42 <adnauseam> [1..] has two definite members
06:56:50 <parcs`> @src foldr
06:56:50 <lambdabot> foldr f z []     = z
06:56:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:56:51 <adnauseam> 1 and oo
06:57:03 <adnauseam> where x = 1 and y = oo
06:57:29 <Wooga> oh, so oo is a number for haskell?
06:57:41 <adnauseam> ifinity symbol
06:58:05 <srhb> Ah, yes, of course.
06:58:43 <srhb> Duh..
06:59:07 <srhb> I'm pretty sure I knew and understood this a halfhour ago, and then it slipped from my brain somehow. :-)
06:59:09 <parcs`> you can also use an unfoldr to define takewhile. that should be easier
07:04:50 <rwbarton> by the way, calling the second argument to helper the "accumulator" is the wrong way to think about it
07:06:15 <rwbarton> lazy evaluation means it doesn't accumulate--it gets calculated as needed
07:06:52 <rwbarton> and its value is just what foldr would return if passed the rest of the list
07:10:20 <bobfang> how to write your own show function for a data type?
07:10:54 <niklasb_> bobfang: just write a function like showMyType and make your type an instance of Show manually
07:11:06 <rwbarton> instance Show MyType where show = showMyType
07:11:14 <niklasb_> that
07:11:16 <bobfang> ok
07:11:19 <bobfang> thanks
07:11:25 <rwbarton> or, you can use deriving Show if you want to use the automatically generated one
07:11:42 <bobfang> no I don't want to do that
07:14:30 <mn90018> I have used newtype to create my own version of Integer. Now I can't use + or - operators to that type. why?
07:14:40 <dylukes> Because you used newtype.
07:14:45 <dylukes> Newtype really means a *new* type.
07:14:56 <dylukes> If you want to be able to "unwrap" it, do something like:
07:15:15 <dylukes> newtype MyInt = MyInt { unMyInt :: Int }
07:15:21 <mauke> mn90018: what does the error message say?
07:16:42 <mn90018> no instace for (Num MyInteger)
07:17:22 <mn90018> arising from the literal 1
07:17:41 <mn90018> i guess it because I do x +1 where x is MyInteger
07:19:37 <mn90018> dylukes: that doesn't help
07:19:53 <csabahruska> hi
07:19:57 <dylukes> mn90018 It's not automatic...
07:20:01 <Wooga> mn90018: make it an instance of Num, i think it could help
07:20:14 <mn90018> should I then use unMyInt every time I wish to use + or - operators?
07:20:18 <Wooga> Num defines +,- and *
07:20:19 <dylukes> Pretty much.
07:20:24 <Wooga> well, not defines
07:20:26 <dylukes> If you just want a type alias use `type`
07:20:28 <dylukes> type MyInt = Int
07:20:31 <dylukes> that's just a synonym.
07:20:42 <Wooga> it declares them
07:20:48 <mn90018> true.. maybe a bit easier
07:20:51 <csabahruska> I'm looking for a generics
07:21:00 <fmap> mn90018: use -XGeneralizedNewtypeDriving to derive Num class for your wrapper
07:21:01 <dylukes> Generally speaking you probably don't need your own integer type.
07:21:11 <dylukes> Exactly… you could also do
07:21:11 <mn90018> what about Woogas solution.. how to add MyInt to Num type?
07:21:14 <csabahruska> I'm looking for a generic programming library with GADT support
07:21:23 <dylukes> newtype MyInt = MyInt { unMyInt :: Int } deriving Num
07:21:37 <dylukes> csabahruska: I think GHC's generics does.
07:21:37 <csabahruska> do you know any?
07:21:39 <fmap> er, *Deriving
07:22:27 <mn90018> Num is not a derivable class
07:22:40 <mn90018> says both me and the compiler
07:22:54 <csabahruska> dylukes: can i use it for (GADT) AST transformations/queries?
07:23:00 <dylukes> I'm not sure.
07:23:07 <dylukes> mn90018 Did you add GeneralizedNewtypeDeriving?
07:23:20 <dylukes> put {-# LANGUAGE GeneralizedNewtypeDeriving #-} at the top.
07:23:31 <Wooga> mn90018: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
07:23:40 <dylukes> It's smart enough to recognize this pattern of wrapper newtypes, and be able to pull out typeclass instances from the wrapped type to the newtype.
07:23:40 <rwbarton> both dylukes and the compiler should have told you to use GeneralizedNewtypeDeriving :)
07:23:56 <rwbarton> unless you are using hugs or something
07:24:00 <dylukes> rwbarton We did tell him too...
07:24:07 <donri> as does ghc i think?
07:24:27 <rwbarton> right, i don't know why i didn't say just "told"
07:24:30 <bobfang> a stupid question here: binary for 2 operands so _____ for 1 operand
07:24:36 <rwbarton> i guess some uncertainty about what compiler he was using
07:24:47 <rwbarton> bobfang: unary
07:24:52 <bobfang> oh thanks
07:26:37 <dreixel> GHC.Generics does not support GADTs.
07:27:44 <dreixel> csabahruska: there is some support for indexed datatypes in the latest release of http://hackage.haskell.org/package/instant-generics but it depends exactly how your GADTs look like
07:28:49 <csabahruska> ok, I'll check it
07:28:53 <csabahruska> thanks
07:29:12 <dreixel> csabahruska: let me know if you run into trouble
07:39:30 <csabahruska> dreixel: instant-generics looks ok, thanks
07:39:38 <csabahruska> bye
07:41:23 <bobfang> Is there anyone who is familiar with shutting yard ?
07:41:31 <bobfang> shutting yard algorithm
07:41:43 <srhb> bobfang: I think you mean shunting yard, and yes.
07:41:56 <bobfang> how do you implement it in haskell
07:42:19 <srhb> Well, I imagine you could do so in a number of ways.
07:43:19 <hpc> bobfang: you have 3 major pieces of data to worry about; the input string, the "shunt" stack, and the output queue
07:43:39 <hpc> for the stack you can use a list, with (:) being push and pattern-matching being pop
07:43:56 <hpc> the input string is just [Char]
07:44:12 <hpc> and for the output you can do something like
07:44:35 <hpc> foo inputs = (current token) : (foo newinputs)
07:44:43 <hpc> and laziness takes care of the rest
07:44:48 <bobfang> ok
07:44:55 <bobfang> I will try it
07:45:02 <hpc> that should give you a rough "shape" for your functions at least
07:45:14 <bobfang> yes, thanks
07:47:29 <ACh> Does any of you know how I may be able to replicate Threadscope's behavior in C? Apologies I have to ask this here, but I didn't get help anywhere else
07:48:04 <ACh> Basically, I'm asking about how to gather info to replicate Threadscope's graphs
07:48:26 <ACh> I'm running Linux, and have all the usual Linux tools
07:49:56 <JuanDaugherty> why did you select this channel?
07:50:33 <ACh> I find Threadscope the perfect tool, and I hoped whoever knew how to do this, would know how to help me!
07:51:00 <JuanDaugherty> the perfect tool
07:51:19 <ACh> :) for my purposes, I might add
07:51:57 <mm_freak> in a language without lightweight threads you'll have to integrate a similar tool into whatever concurrency framework you are using
07:52:55 <ACh> like, e.g. wrapping pthread functions, you mean?
07:54:49 <t7> dart is so retarded, run time type checking...
07:55:28 <hpc> t7: how innovative! :P
07:55:42 <hpc> python could learn a thing or two from them XD
07:55:49 <donri> i did that in python
07:55:53 <t7> im gonna invent a curly brace language with generics and typeclasses/interfaces
07:56:05 <t7> people will call me a god among men
07:56:22 <t7> and full type inference of course
07:57:03 <zenware> Can someone explain how haskell is interpreting things?
07:57:09 <hpc> t7: make it compile to haskell and do-notation
07:57:16 <zenware> When you define a value x = 10
07:57:16 <hpc> all pure computation happens in the Identity monad :D
07:57:22 <t7> everytime i think about a new language i add stuff onto it and end up with haskell :)
07:57:35 <Philippa> zenware: how much detail do you want?
07:57:36 <zenware> Is it saying that x is a function without parameters that returns 10?
07:57:38 <Philippa> no
07:57:43 <hpc> (a curly-brace language where everything was a do-block would be kind of interesting)
07:57:51 <hpc> zenware: it's saying x is the value 10
07:57:52 <Philippa> function in haskell strictly means things with -> as top-level type constructor
07:57:56 <Philippa> *however*
07:58:05 <hpc> http://conal.net/blog/posts/everything-is-a-function-in-haskell -- see also
07:58:27 <zenware> because defining a function and defining a "variable" can happen the same way
07:58:30 <Philippa> in most implementations it means x is a process that will generate 10 when asked for it. This matters when you're dealing with potentially-infinite structures
07:58:30 <hpc> zenware: when you write "f x = x", it's sugar for "f = \x -> x"
07:58:41 <Philippa> zenware: functions are values like any other
07:58:43 <hpc> which says "f is the value (function that takes x and returns it)"
07:59:06 <Philippa> f = ... is just "bind ... to f", regardless of what ... is
07:59:07 <zenware> Okay
07:59:14 <zenware> That's what I was thinking
07:59:18 <zenware> Thanks :D
07:59:35 <rwbarton> if you call (+) a "function of two parameters" then you can also call 10 a "function of zero parameters"
08:00:01 <hpc> except you can't, because "function of zero parameters" is awful terminology :P
08:00:09 <rwbarton> but you should probably not do that until you understand why that is okay to say
08:01:02 <zenware> Actually I haven't even managed to write anything in haskell or experiment with it, because I was too busy being in awe at how it might work under the hood, and trying to think up a better grammar.
08:01:47 <jmcarthur> zenware: they have the same syntax because all functions are values
08:01:51 <jmcarthur> zenware: however, not all values are functions
08:02:26 <Philippa> rwbarton: nope, the currying isomorphism doesn't have to include 0-ary - and if it did, it's probably \()->10 anyway
08:02:29 <hpc> also, if you want to be really technical, (+) is "function of one parameter that returns a function of one parameter that returns a number"
08:02:41 <rwbarton> nothing to do with currying
08:03:02 <hpc> (+) :: Num a => a -> (a -> a)
08:03:08 <rwbarton> "function with n arguments" is a1 -> a2 -> ... -> an -> b
08:03:10 <Philippa> everything to do with currying, as that's the basis on which we pick the n in n-ary function - the size of the tuple it'd uncurry to
08:03:11 <rwbarton> now set n = 0
08:03:12 <hpc> (we omit those parens for terseness)
08:03:51 <Philippa> rwbarton: my point being that at the least, there is /more than one basis/ for assigning arity to functions
08:04:10 <rwbarton> Philippa, surely () -> b is the "uncurried" form of b then
08:04:32 <hpc> rwbarton: what if b is a function?
08:04:41 <rwbarton> what
08:04:43 <Philippa> rwbarton: you gave the type, I gave the term. Same difference
08:04:49 <hpc> then you've uncurried something of type (a -> b -> c) to something of type (() -> a -> b -> c)
08:04:52 <hpc> genius! :P
08:04:54 <Philippa> but that "surely" isn't a given
08:04:58 <rwbarton> wow
08:05:03 <Philippa> () only looks a little like a tuple, it isn't /actually/ one
08:05:34 <rwbarton> hpc, exactly the same thing can happen when you uncurry a 3-argument function
08:05:42 <Philippa> (nor is it inherently supported by having products in general - there are plenty of CCCs where not having a notion of 0-ary at that level is valid)
08:06:08 <rwbarton> Philippa, on the uncurried side you map n-tuples to a result type, on the curried side you have terms of type a1 -> a2 -> ... -> an -> b, there is a perfect correspondence
08:06:16 <rwbarton> nothing special happens at n = 0
08:06:21 <Philippa> you're assuming a notion of 0-tuple in the first place
08:06:26 <rwbarton> well obviously
08:07:03 <hpc> i think we can all agree that incorrect notions of "what is a tuple" and "what is a function" lead to ridiculous conclusions
08:07:08 <Philippa> not everyone shares that assumption, and if you're building tuples out of categorical products then you don't get the assumption for free. You can describe currying in terms of categorical products and exponentionals
08:07:32 <rwbarton> anyways there are patterns you can extend to n = 0 if you are willing to be sensible. for example liftM3, liftM2, liftM1 = fmap, and liftM0 = return
08:07:48 <rwbarton> but apparently #haskell is not today, so fine.
08:08:16 <zenware> Yay! First time I ran ghci prelude and crashed a box from what I presume to be infinite recursion...
08:08:21 <Philippa> "0-ary function" breaks a lot of important ideas about functions in Haskell. It's not an unreasonable or insensible approach
08:09:06 <rwbarton> of course you have to understand that "a -> b" only unifies with functions of >= 1 argument, just like "a1 -> a2 -> b" only unifies with functions of >= 2 arguments.
08:09:24 <rwbarton> that's why I say it is a viewpoint you should not adopt lightly
08:09:53 <Philippa> right, which means it's at /least/ a matter of taste and thus rejecting it's not inherently being insensible
08:10:32 <rwbarton> I agree, but calling it insensible is inherently being insensible.
08:11:36 <Philippa> yeah. I don't recall doing so. Your original statement could be read as "any reasonable notion of n-ary function [allowing the pun on whether 0 is included] includes n=0" though
08:11:59 <Philippa> (plus your specific translation)
08:12:13 <Philippa> the lack of a good unique translation for n=0 doesn't help there :-)
08:14:29 <rwbarton> (also what's this about CCCs in which x is not x^1? you must have a very different definition of CCC)
08:14:45 <rwbarton> or i misunderstood
08:17:44 <rwbarton> Or are you going to tell me now that having "finite products" does not include 0-ary products? :P
08:18:08 <Philippa> doesn't even include 1-ary ones
08:18:30 <rwbarton> ?!?!
08:18:34 <Philippa> that part's just the pre-existing definition of function that clearly has one parameter
08:18:43 <rwbarton> how can a category not have 1-ary products
08:19:34 <Philippa> we may favour different encodings :-)
08:19:54 <rwbarton> Obviously we're talking about totally different things here, so whatever.
08:22:02 <Philippa> eh, fair enough, I went and RTFM and you're right there. Still not inherently a good idea to include 0-ary as actually-a-function when you're thinking in terms of lambda calculi though
08:22:37 <Philippa> (and I think we both agree it's really not a good starting point for beginners who need to grok alternate viewpoints?)
08:30:13 <rwbarton> Yep, definitely.
08:30:27 <rwbarton> That's why I added my second sentence.
08:31:22 <jmcarthur> i don't think it's entirely meritless to consider what a language might be like that isn't aware of a difference between x and x^1, but i have no idea what that would be like
08:33:48 <jmcarthur> same for various other equivalences in CCCs
08:33:54 <zenware> Since x^1 is just 1x or x, are they not the same thing?
08:34:14 <jmcarthur> they are equivalent, but they don't unify in haskell without transforming one into the other
08:34:19 <rwbarton> the category theory isn't a perfect match to the type theory, yeah, in a CCC x^1 may or may not "really be the same object as x" but in type theory there is an important distinction
08:34:47 <zenware> Interesting,
08:34:54 <ppilate> Hi! Can somebody please explain to me what does <*> do?
08:35:08 <Philippa> ppilate: it's easier to explain how it interacts with <$>
08:35:20 <ppilate> Ok, what does <$> do?
08:35:34 <rwbarton> I admit to being a category theorist rather than a type theorist, which no doubt colors my viewpoint on some of these issues.
08:35:37 <ppilate> Or at least, what keywords I should use in google?
08:35:42 <jmcarthur> zenware: the equivalence basically just means that you can always write a combinator that transforms one into the other, and the other way around
08:35:55 <jmcarthur> ppilate: it's fmap
08:36:01 <jmcarthur> <$> is
08:36:25 <jmcarthur> <*> is equivalent to Control.Monad.ap, but for Applicatives instead of Monads
08:36:25 <Philippa> \a b -> SomeConstructor a b <$> applicativeAction1 <*> applicativeAction2 -- the equivalent of SomeConstructor (applicativeAction1, applicativeAction2) in a typical imperative lang - in general, the LHS needs to be pure
08:37:03 <ppilate> I see, thanks
08:37:05 * hackagebot darcs 2.8.0 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.0 (FlorentBecker)
08:37:11 <jmcarthur> ooh new darcs
08:37:36 <ion> fa <*> xa is equivalent to “do f <- fa; x <- xa; return (f x)”
08:37:55 <ion> f <$> xa is equivalent to “do x <- xa; return (f x)”
08:39:23 <Philippa> rwbarton: <rwbarton> if you call (+) a "function of two parameters" then you can also call 10 a "function of zero parameters" <- I'd interpreted that if as implication, that's the bit I don't buy. We seem to agree on that but not whether the wording was a problem
08:40:18 <jmcarthur> > 10 "foo" "bar" "baz" -- 10 is a function of as many parameters as you want :P
08:40:19 <lambdabot>   10
08:40:42 <rwbarton> Philippa: well, I meant "can" as in "may"
08:40:44 <Philippa> ion: ... only true /if/ you're operating in a Monad, which matters because there are useful Applicatives that aren't Monads
08:41:03 <ion> sure
08:41:05 <Philippa> rwbarton: I'm not sure that changes anything on my end, but hey :-)
08:41:23 <rwbarton> as opposed to "... you must also call ..."
08:42:20 <rwbarton> I think it's a little weird and inconsistent to only use the "function of n parameters" terminology for n >= 1, but of course people can use whatever terminology they like and that seems to be more or less standard
08:42:22 <Philippa> mmm. "Might" could work better, at least connotationally
08:42:57 <Philippa> there's a pretty strong inconsistency at 0 unless you pick () -> b, though
08:42:58 <wli1> Newton generating function convolution (Newton series products) are more list manipulation than ordinary generating functions without being large excursions into number theory like Dirichlet generating functions.
08:43:00 <rwbarton> If I replace "function" with a made-up word, it sounds better, I think
08:43:03 <zenware> I've noticed a few people using some sort of /descriptor/ around words, and I'm curious as to what it represents.
08:43:11 <Philippa> yeah, the problem's functor
08:43:26 <Philippa> zenware: Italics, because the letters /lean/
08:43:26 <rwbarton> calling 10 a "blarxle of 0 parameters" is fine
08:44:03 <Philippa> yep. Hell, I'll even cheerfully allow 0-ary "monadic functions"
08:44:16 <zenware> Well actually, I'm not aware of how your IRC client is configured but the letters aren't leaning on my screen.
08:44:41 <rwbarton> I guess I'm used to math terminology in which people cheerfully add qualifiers to a noun to undermine its meaning completely
08:44:45 <Philippa> zenware: it's an ASCII-era convention, they won't lean but the / attempts to depict it
08:45:09 <DrSyzygy> zenware: Exactly therefore, we add the // symbols to indicate that we would have intended the /italic/ parts to lean if we /had/ had more control over type appearance.
08:45:25 <DrSyzygy> zenware: Just like people might use things like _underline_ and *boldface*.
08:45:30 <Philippa> yeah. I'm fine with that - half of why I'm happy with 0-ary monadic functions for example
08:45:38 <DrSyzygy> (and for those to cues, my irssi client actually adds the corresponding formatting)
08:45:43 <Philippa> (the other half being that you're not in the same language any more)
08:46:15 <Philippa> 0-th order functions clearly have to be values if they're anything at all, too
08:48:29 <BMeph> Some people think it's weird that 0 is a natural number. Isn't 0, a symbol for nothing?
08:48:32 <Philippa> but aside from the "I just came from C" problem, arity behaves differently. I think what I was trying to grasp at earlier, btw, is that you have to add extra arrows to map 1-ary (fair enough because there's an existing obvious definition) and 0-ary (oops, there's 2) whereas you get 2-ary on upwards from an isomorphism on arityless products
08:48:44 <jmcarthur> what's so unnatural about nothing?
08:49:06 <Philippa> jmcarthur: it took surprisingly long for it to show up in the history of mathematics
08:49:33 <jmcarthur> i know, but i think that is probably mostly due to momentum. not that i know the history very well, though
08:50:16 <BMeph> It was there all the timee, Philippa; nobody thought is was worth mentioning, because, y'know, it's nothing. ;)
08:50:38 <zenware> Maybe it's psychological, people want more things and as such imagine that 0 is bad/can't happen/etc
08:50:54 <jmcarthur> i don't believe in _|_
08:51:05 <jmcarthur> show me a _|_ and i'll believe in it
08:51:11 <DrSyzygy> jmcarthur: Don't worry. _|_ believes in you.
08:51:17 <zenware> -
08:51:23 <zenware> _|_ :D
08:51:39 <mm_freak> BMeph: 0 is not a symbol for nothing
08:51:54 <mm_freak> there is a difference between "0 is the quantity of nothing" and "0 is no quantity"
08:51:58 <mm_freak> 0 definitely is a quantity
08:52:06 * hackagebot hgithub 0.1.0 - Haskell bindings to the GitHub API  http://hackage.haskell.org/package/hgithub-0.1.0 (VoMinhThu)
08:52:10 <Philippa> mm_freak: I suspect BMeph knows this
08:52:41 <mm_freak> well, BMeph asked the question and i'm answering it =)
08:53:33 <mm_freak> jmcarthur: ⊥ is coming, you just have to have infinite patience for it to arrive =)
08:53:41 <Wooga> > groupBy (<) [1,2,2,3]
08:53:42 <lambdabot>   [[1,2,2,3]]
08:53:45 <Wooga> what the hell?
08:53:46 <ppilate> So, can one say that (fmap f x) get's a functor x, applies a natural transofrmation f to it and returns another functor?
08:53:55 <Wooga> shouldn't it be [[1,2],[2,3]] ?
08:54:25 <jmcarthur> mm_freak: what an unproductive thing to do ;)
08:54:31 <mm_freak> ppilate: nope, fmap itself is part of the functor
08:54:37 <mm_freak> ppilate: x is an object
08:54:54 <kallisti> it would be interesting to take concepts from Haskell and incorporate them into the design of a language that's "truly" imperative.
08:55:23 <jmcarthur> kallisti: what does it mean to be truly imperative?
08:55:43 <mm_freak> ppilate: fmap :: (a -> b) -> (f a -> f b)
08:55:44 <kallisti> good question
08:56:02 <mm_freak> it transfers a morphism from one category to another
08:56:08 <kallisti> I suppose not framing your imperative constructs in terms of pure abstractions helps.
08:56:15 <copumpkin> in this case between the same categories
08:56:19 <copumpkin> since they're both (->)
08:56:35 <Philippa> kallisti: which concepts?
08:57:00 <jmcarthur> kallisti: looked at other ML languages before?
08:57:08 <kallisti> I haven't.
08:57:27 <Philippa> the type system maps easily, for example. Monads aren't as useful without a pure metalanguage around them, because the effect system they give you ends up full of holes
08:57:31 <mm_freak> it's sad that there is no dependently typed programming language usable for real world applications =/
08:57:54 <Philippa> (anyone about to hand me the "one monad = trivial effect system" result is invited to consider what happens when you used multiple monads, transformers etc in one program)
08:57:58 <kallisti> I was thinking lazy evaluation in particular. And yeah, I know the problems with a naive approach to that.
08:58:16 <Philippa> mm_freak: played with Idris? It's not Haskell-level useful, but...
08:58:47 <mm_freak> Philippa: played with agda, coq, epigram and idris
08:58:53 <bobfang> I am  desperate now  can anybody show me an implementation of the shunting yard algorithm?
08:58:55 <mm_freak> all of them focus on theorem proving
08:59:01 <mm_freak> except idris
08:59:04 <BMeph> jmcarthur: What do you think of Ur, speaking of ML langs?
08:59:05 <mm_freak> which is simply not mature enough
08:59:09 <jmcarthur> kallisti: i'd recommend checking out something like OCaml (ignore the OO stuff it has). it's basically strict, impure haskell
08:59:14 <jmcarthur> BMeph: Ur is fun!
08:59:29 <BMeph> jmcarthur: (Assuming, that is, that you have....)
08:59:35 <jmcarthur> error messages are terrible
08:59:45 <jmcarthur> yeah i used it a bit in the past
09:00:20 <Philippa> bobfang: the wikipedia article has one
09:00:24 <jmcarthur> chlipala was looking to use it commercially and i took interest for a while, but then drifted away from that
09:00:24 <Philippa> not in Haskell, granted
09:00:36 <wli> Full abstraction might be interesting from the POV of allowing different operational implementations of the same source.
09:00:36 <bobfang> I think I need haskell
09:00:53 <jmcarthur> BMeph: Ur/Web feels very cohesive, to me
09:01:06 <jmcarthur> much moreso than any web framework i've ever tried
09:01:36 <Philippa> wli: it often is, IME
09:01:38 <jmcarthur> i also ran into a few bugs and the error messages are almost useless
09:01:46 <BMeph> jmcarthur: That sounds like a good thing.
09:02:04 <jmcarthur> chlipala was quick to fix bugs though
09:02:12 <BMeph> jmcarthur: The cohesiveness, not the uninformative errors and bugs, of course. :)
09:02:25 <jmcarthur> yeah
09:04:55 <jmcarthur> BMeph: but bugs and error messages aside, i highly recommend it for fun. i'm less certain about for production code
09:05:15 <hayashi> @pl \f g a b c -> f (g a b) c
09:05:15 <lambdabot> (.) . (.)
09:05:41 <zenware> bobfang: There's a full implementation in C I believe on the wikipedia page.
09:07:15 <wli> http://hpaste.org/67407 <— these could use efficiency improvement esp. where I use lookup
09:08:21 <ppilate> Can someone please help me with an analogy or whatnot in order to see List as a functor?
09:08:32 <ppilate> Functor, as in "mapping" between categories
09:08:50 <ppilate> Let's say we have List Int, what is the signature of that functor?
09:09:57 <Philippa> ppilate: you're mapping the category of haskell types onto the (sub)category of lists of various haskell types
09:11:33 <ppilate> Right, and what does (fmap f = map f) mean in that case?
09:12:06 * hackagebot vty 4.7.0.12 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.12 (CoreyOConnor)
09:12:57 <zomg> ppilate: it just means that fmap is an alias for map
09:13:08 <zomg> I mean it'st just a normal function declaration
09:13:09 <mm_freak> ppilate: it means that [] is your functor
09:13:22 <mm_freak> :t map
09:13:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:13:28 <ppilate> No, I mean in the cat. theory sense
09:13:42 <mm_freak> yeah, it means that [] is your functor
09:14:23 <ppilate> I got that, but what does fmap mean if we view list as a mapping from the category of types onto the category of lists of types
09:15:01 <jmcarthur> ppilate: fmap maps the arrows of the former category to arrows of the latter category
09:15:20 <mm_freak> the list functor takes morphisms in Hask to morphisms in the subcategory of lists
09:15:21 <Philippa> whereas [] (the type constructor) maps the objects
09:15:54 <mm_freak> it maps every object (type) a to [a] and every morphism (function) a -> b to [a] -> [b]
09:16:16 <ppilate> Ah I see. Sorry, I am not a mathematician, neither a type theorist
09:16:20 <ppilate> Thanks a lot, fuys.
09:16:23 <mm_freak> map :: (a -> b) -> ([a] -> [b])
09:16:25 <jmcarthur> fuys!
09:16:31 <ppilate> erm
09:16:34 <ppilate> guys rather :)
09:16:35 <jmcarthur> :)
09:17:06 * hackagebot GenI 0.22 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.22 (EricKow)
09:17:24 <kallisti> ^ cool
09:22:07 * hackagebot geni-gui 0.22.1 - GenI graphical user interface  http://hackage.haskell.org/package/geni-gui-0.22.1 (EricKow)
09:24:30 <wli> Something like sum [fromIntegral (trinomial i j (n - i - j)) * (a !! (n - i)) * (b !! (n - j))  | (i, a) <- as, (j, b) <- bs, i + j <= n] would be plausible for Newton generating function convolution if only the last check i + j <= n could somehow be avoided.
09:28:34 <rpglover64> I'm trying to understand how to use the compdata package. Is there anyone here who can help me?
09:28:36 <rpglover64> http://hackage.haskell.org/package/compdata-0.5.2
09:34:40 <upio> Consider a type WordXX (in Data.Word). Is a * b defined when they yields a multiplicative overflow?
09:36:19 <Enigmagic> upio: the result is truncated to fit
09:36:54 <upio> Enigmagic: Which means that the most significant bits are ignored?
09:37:12 <Enigmagic> yeah
09:37:27 <upio> good!
09:38:45 <Brolapse> hello, if i wanna call funcs f1 and f2 like so f1(f2(arg1,arg2,arg3,arg4),arg5))
09:39:00 <Brolapse> haskell isn't happy with me doing this
09:39:45 <siracusa> That's now how you call functions in Haskell
09:39:58 <Brolapse> i know
09:39:59 <Enigmagic> did you try using 'f1 (f2 arg1 arg2 arg3 arg4) arg5'
09:40:16 <Enigmagic> ?
09:40:33 <Brolapse> oh also arg 4 needs to go from string to int
09:40:50 <Enigmagic> :t read
09:40:51 <lambdabot> forall a. (Read a) => String -> a
09:40:54 <upio> Brolapse: but you can let f1 :: (a, b) -> c, f2 :: (d, e, f, g) -> h
09:41:15 <siracusa> When using GHC with the evaluate option -e, is it possible to specify a module import list?
09:41:37 <Brolapse> so putting read onto arg4
09:42:05 <Brolapse> 'f1 (f2 arg1 arg2 arg3 (read arg4)) arg 5'
09:42:07 <Brolapse> that doesn't work
09:42:08 * hackagebot cryptohash 0.7.5 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.5 (VincentHanquez)
09:42:20 <fmap> siracusa: ghc -e reads imports from ~/.ghci file
09:42:35 <ion> “doesn’t work” isn’t a very good description of the problem.
09:42:47 <Brolapse> Couldn't match expected type `Int' with actual type `[Char]'
09:42:48 <Enigmagic> siracusa: add another '-e' with 'module + Whateve' first
09:43:14 <td123> let newarg4 = read arg4 :: Int
09:43:14 <Enigmagic> err
09:43:25 <Enigmagic> siracusa: err, 'import Module' not module + :)
09:43:36 <ion> -e ':m + Foo' works, too.
09:43:50 <Brolapse> td123, that worked :)
09:43:51 <Brolapse> ty
09:43:58 <mekeor> oh, some people call »Maybe« a »type family«...
09:44:19 <siracusa> Enigmagic: Works fine, thanks!
09:44:46 <td123> Brolapse: if read can't infer the type you want, you need a type signature (:: Int in this case)
09:44:52 <siracusa> so each '-e' is like a line in GHCi?
09:45:31 <Brolapse> oh no td123 just doing "let myInt = read myString"
09:45:33 <Brolapse> worked
09:45:40 <Enigmagic> siracusa: something like that
09:46:16 <td123> I have no clue how your previous expression didn't work if that worked :P
09:46:19 <siracusa> Awesome, that solves two problems at once :-)
09:46:39 <Enigmagic> :)
09:47:39 <Brolapse> td123, i know, i'm having quite a hard time with haskell but mainly because i'm an idiot needing to rush coursework :P
09:47:48 <Brolapse> it's actually a pretty awesome language
09:48:21 <td123> ya, haskell is probably one language you shouldn't rush through :P
09:48:41 <Philippa> I dunno, it's pretty good for rush work
09:48:46 <ezyang> Is there a canonical reference for learning about equational reasoning / term rewriting?
09:50:03 <conal> ezyang: there's http://www4.in.tum.de/~nipkow/TRaAT/
09:50:46 <conal> ezyang: also some notes by Gerard Huet from the early/mid 80s.
09:51:07 <conal> ezyang: the latter was in CAML, iirc.
09:52:00 <ezyang> Handy. I'll have to pick up a copy from my university library.
09:52:25 <conal> ezyang: also: G. Huet, D. Oppen. Equations and Rewrite Rules: A Survey.
09:53:11 <conal> ezyang: might be what i remembered: G. Huet. Deduction and Computation.
09:53:43 <conal> ezyang: ah. this is it: G. Huet. Formal Structures for Computation and Deduction. Course Notes, Carnegie-Mellon University, May 1986 (184 pages). http://yquem.inria.fr/~huet/PUBLIC/Formal_Structures.pdf
09:54:01 <conal> ezyang: i'm scanning gerard's pubs page: http://pauillac.inria.fr/~huet/bib.html
09:54:21 <ezyang> (broader context: I'm trying to make an automatic grading system for high school algebra 2, and I'm trying to understand how the literature in rewrite systems applies)
09:54:26 <conal> ezyang: i was in that course at cmu.
09:54:30 <ezyang> Neat!
09:54:46 <zzing> If I wanted to write a graphical library in C++ with some regard to using it with Haskell at a later date, is there any sort of considerations I should have?
09:55:05 <conal> ezyang: interesting! how are you connecting automatic grading with term rewriting?
09:58:22 <ezyang> I remember doing lots of "equation slinging" problems, where I needed to show my work, back in High School. It seems to me that while I didn't know it, I was interacting with very simple rewrite systems.
09:58:42 <ezyang> Or possibly very complex rewrite systems :-)
09:58:56 <conal> ezyang: ah! yeah :)
09:59:38 <kowey> zzing: you might ask the wxhaskell team, as they have some experience wrapping the wxWidgets C++ code
10:00:53 <kowey> zzing: the current layout of wxHaskell being: wxc (which does C++ => C), and then a small wxcore library with some auto-generated Haskell on top of it and some use of phantom types to encode the OOPy inheritance tree, and wx library, which makes it a bit nicer and more Haskelly
10:01:07 <kowey> and perhaps something higher level on top, like apfelmus' reactive-banana
10:02:07 <zzing> kowey, worth considering. I am mainly using C++ because it is a better language and safer, just not as interoperable.
10:02:37 <zzing> I think I can keep some of it some what C-ish too, it is mainly the data structures I am interested in.
10:03:01 <zzing> What would be the best way to deal with situations where callbacks are warranted, say in the event of a mouse event or a key?
10:04:50 <zzing> On the reactive banana wiki page it says "No more spooky time leaks" -> what is a time leak?
10:05:08 <zzing> I am assuming we aren't talking about poking the space-time with a tachyon needle.
10:06:00 <hpaste_> wli annotated “generating function convolutions” with “generating function convolutions (annotation)” at http://hpaste.org/67407#a67426
10:06:54 <wli> Sped up egf's and dgf's, but ngf's still stymy me.
10:08:14 <kowey> zzing: I'm afraid I can't really help much! :-( I'm more of a user than an wxhaskell dev
10:08:41 <kowey> my only real contribution being some search and replace stuff to move us to Unicode strings, and some make-it-go stuff so I can use it on Mac :-)
10:08:52 <parcs`> zzing: "A time leak is a situation in which a value is dependent on past values for an arbitrary time interval, and they are not evaluated as they are produced, thus, suddenly forcing a value may take an arbitrary amount of time."
10:09:03 <miki> ciao
10:09:10 <miki> !list
10:09:35 <zzing> parcs`, the sudden evaluation of lazily produced values?
10:11:24 <Philippa> conal: I seem to be working with constraints a lot, do you reckon going through the basics on rewrite systems is probably a good idea for me?
10:13:20 <parcs`> zzing: i am not sure
10:13:22 <conal> Philippa: dunno. i don't remember seeing much connection between constraints & rewriting. which now seems odd to me. hm.
10:19:19 <hpaste_> wli annotated “generating function convolutions” with “ngfConv speedup” at http://hpaste.org/67407#a67427
10:23:36 <Doesthisworkonan> Ohey, this works on an iPod. Did not expect that.
10:24:31 <Philippa> conal: I wouldn't expect it to be as clear then, a lot's happened with constraints since, but yeah
10:25:03 <Philippa> (I'm in that aggravating "I really wish the books were cheaper!" position at the moment, too)
10:25:10 <dylukes> Philippa: out of curiosity what editor do you use for haskell REPL?
10:25:27 <byorgey> wli: interesting, I'd never seen Newton GFs before, what are they used for?
10:25:48 <wli> byorgey: Finite differences, of course.
10:26:01 <hayashi> Is there any way of pattern-matching against any unary constructor, or do I just have to specify all of them?  =P
10:26:04 <Philippa> dylukes: I use jedit as my general editor, I've just got a console instance running with ghci and no specific integration beyond that
10:26:13 <byorgey> wli: hmm, fair enough
10:26:14 <dylukes> gotcha.
10:26:20 <dylukes> I'm considering learning vim to really weigh it against emacs.
10:26:30 <dylukes> usually I use Sublime tho
10:26:33 <Philippa> ah. Yeah, I've decided I cba with either
10:26:52 <Doesthisworkonan> Cba?
10:26:57 <wli> byorgey: Usually the convolution rule drives the choice of generating function, and the convolution rule is rare to encounter in the field.
10:27:00 <hpc> hayashi: the nicest way would probably be view patterns
10:27:04 <hpc> and a function isUnary
10:27:10 <Philippa> Doesthisworkonan: Can't Be Arsed
10:27:20 <byorgey> wli: makes sense
10:27:28 <Doesthisworkonan> Thanks.
10:27:38 <wli> byorgey: I suspect they primarily crop up when the convolution rule doesn't drive the choice of generating function.
10:27:56 <hpc> or i suppose just isUnary + guard
10:28:01 <hpc> to avoid the extension
10:29:49 <Philippa> dylukes: I suspect I'd like Sublime if I'd, say, used a Mac before my 20th or maybe 25th b'day? The transition costs don't look worth it from here though
10:29:59 <dylukes> Sublime is for Mac too :\.
10:30:04 <dylukes> er, it's for everything.
10:30:20 <dylukes> cross platform. all the config/scripting is python/json.
10:30:37 <Philippa> ah. Is the windows port new?
10:30:38 <dylukes> but it uses textmate themes.
10:30:47 <dylukes> It was always cross platform.
10:30:49 <dylukes> From the start.
10:30:59 <dylukes> ST2 is not free but… in the beta nothing is enforced.
10:31:07 <dylukes> It just lets you use it and gives a pop up once in a blue moon.
10:31:51 <Philippa> ah, I'm thinking of another editor re the mac thing then
10:32:13 <Philippa> and... maybe sometime I've got a spare day or two to mess around configuring it, I'll have a look
10:32:25 <Philippa> (I'll no doubt start by cloning my existing setup then looking at how it can improve it)
10:32:32 <Philippa> (I'm /not/ attached to Java)
10:32:37 <pqmodn> perhaps you were thinking of TextMate
10:32:43 <dylukes> Philippa: http://dl.dropbox.com/u/25700582/VID_20120421_221536.mp4
10:32:48 <dylukes> Philippa: last night :P
10:33:19 <dylukes> er wait, this isn't blah.
10:33:44 <Philippa> heh. Watch my film rec :-)
10:33:54 <Philippa> you'll probably relate more than you expect
10:33:57 <Philippa> but yes, -blah
10:37:28 <mdmarek> l
10:37:47 <byorgey> m
10:40:22 <glguy> Anyone have a favorite library for Tries mapping (at least) [Char] to some value?
10:40:48 <glguy> (I'm trying to pare down my search space, hack age has a few libraries with the right keywords)
10:42:27 <benmachine> :t popCount
10:42:28 <lambdabot> Not in scope: `popCount'
10:42:31 <hpaste_> wli annotated “generating function convolutions” with “DCE, line length cleanups, title” at http://hpaste.org/67407#a67428
10:42:31 <benmachine> hmm
10:42:50 <benmachine> would anyone like to explain what popCount is doing on Integers
10:43:12 <glguy>  I would guess that it counts the number of 1's in a binary representation
10:43:19 <benmachine> glguy: I would guess that too
10:43:22 <glguy> is that not the case?
10:43:43 <byorgey> yes, that's what popCount does, I'm 95% sure
10:43:45 <benmachine> glguy: hmm, it depends which GHC I ask
10:43:56 <glguy> On my ghc 7.4.1 it seems like it is the "id" function
10:44:02 <benmachine> glguy: yeah :/
10:44:14 <benmachine> I tried my ghc from git and it seems to be correct
10:44:15 <byorgey> oh, weird =P
10:44:18 <byorgey> what module is it in?
10:44:23 <benmachine> Data.Bits
10:44:56 <byorgey> hmm, yeah, it does seem to be id
10:45:07 <glguy> byorgey: on negative numbers it seems to be "stall"
10:45:11 <benmachine> haha
10:45:13 <benmachine> oh dear :/
10:45:27 <glguy> quickCheck (\x -> (x >= 0) ==> fromIntegral (x :: Integer) == popCount x)
10:45:27 <glguy> +++ OK, passed 100 tests.
10:45:32 <byorgey> so it's a semi-decision procedure for positiveness
10:45:38 * benmachine giggles
10:46:29 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/5872 ah, sigh
10:46:51 <byorgey> "When given a nonnegative integer, popCount is guaranteed to return a nonnegative integer.  When given a negative integer, it may return a monkey."
10:47:19 * tgeeky devises plans to manufature monkeys
10:47:30 <benmachine> "just keep waiting, you never know"
10:47:53 * benmachine just implements his own popCount
10:48:16 <byorgey> hahaha, it's because of a precedence mistake =P
10:48:22 <benmachine> yep
10:48:27 <benmachine> x .&. x - 1
10:48:41 <benmachine> x .&. x = x, soo...
10:49:04 <glguy> It's pretty impressive that someone wrote that and then never tried running it on values other than 0 and 1
10:49:15 <byorgey> hah, so it also takes O(n) time to compute popCount n? =)
10:49:43 <benmachine> byorgey: well, no, it takes O(n) time to compute n :P
10:49:55 <byorgey> hehe
10:50:33 <byorgey> glguy: indeed.
10:51:15 <benmachine> I hope they have more tests now
10:51:33 <byorgey> I'm sure they do.  GHC is usually pretty good about adding tests for bugs that get fixed.
10:52:48 <benmachine> oh and then I wrote my own version for this program
10:52:53 <benmachine> and put parentheses in
10:52:59 <benmachine> around the (x .&. x)
10:53:01 * benmachine slaps self
10:54:56 <glguy> benmachine: It sounds like you didn't want to leave anything to change in duplicating the bug in case they fixed it upstream by changing precedences :)
10:54:57 <hpc> benmachine: genius
10:55:08 <rzys> hey, does somebody know if there is a library for sending emails over gmail (or similar)? the only thing i found, which does not require a local mail server is haskellnet but there seems to be e dependency issue with Text.Mime.
10:55:09 <benmachine> glguy: :P
10:56:32 <Saizan> rzys: you should be able to do that via smtp
10:57:57 <rzys> sorry, im a newb. could you give me some hints so that i can search the internet for more information?
10:58:19 <hpc> @hoogle smtp
10:58:21 <lambdabot> package SMTPClient
10:58:21 <lambdabot> package hsmtpclient
10:58:21 <lambdabot> package ismtp
10:58:31 <hpc> huh, the packages exist
10:58:36 <hpc> try some of those out
10:58:56 <rzys> great, thanks!
11:01:32 <Saizan> you've to find the parameters out of google's help pages for using gmail via an external mail client
11:03:18 <dmwit> > chr 6
11:03:19 <lambdabot>   '\ACK'
11:08:59 <scooty-puff> when it comes to type checking recursive bindings, f and g, i do it as let x = (fix $ \ x -> let f = fst x; g = snd x in <f, g>) in let f = fst x; g = snd x - however, this results in and instantiation of f and g, such that the type vars in the f and g in the type env don't line up with the f and g defintition type vars
11:09:03 <scooty-puff> i was wondering how ghc does this
11:09:11 <scooty-puff> without use a "fix" function
11:10:00 <scooty-puff> which hinders specialization, or a assume it will
11:10:03 <scooty-puff> type specialization
11:10:09 <scooty-puff> since i can't just apply a substitution
11:10:23 <scooty-puff> *a -> i
11:11:18 <dmwit> "the f and g definition type vars"?
11:12:07 <rwbarton> do you mean f and g have been provided with type signatures?
11:12:12 <scooty-puff> so fn f(x) { return g(x); } fn g(x) { return f(x); }
11:12:17 <scooty-puff> neither have been
11:12:29 <scooty-puff> (this isn't in terms of how haskell or ghc does it, but how in general to do it)
11:12:36 <scooty-puff> (so maybe not appropriate)
11:12:41 <dmwit> Also, fix (\x -> let f = fst x; g = send x in <f, g>) doesn't look right to me; where do the actual bodies of the "f" and "g" definitions come in?
11:13:05 <dmwit> s/send/snd/
11:13:42 <scooty-puff> \ x -> let f = fsg x; g = snd x in (<body of f, referring the the previously defined g>, <body of g, referring to the previously defined f>)
11:13:55 <Philippa> scooty-puff: polymorphic recursion doesn't have decidable type inference, so the usual approach is to assume recursive calls are monomorphic, typecheck everything in a binding group on that basis and then generalise
11:13:59 <dmwit> Also, have you got an explanation of HMX lying around? (I expect any such will have a section on recursive definitions.)
11:14:14 <Philippa> y'know, I'm not sure it does
11:15:29 <Philippa> scooty-puff: you need letrec (or something you treat as letrec) for it to make sense, you can't use single-binding lets
11:15:37 <scooty-puff> k
11:16:09 <scooty-puff> (btw, the problem i'm getting is mono f and mono have type a -> b, where x is assigned type var a
11:16:14 <Philippa> (you might also want to do a strongly-connected components analysis to create tighter binding groups and produce more polymorphic types)
11:16:40 <scooty-puff> but outside, where thye are generalized, given new type vars, making it so i can't just substituion the new type vars and expect the "x" type to be replaced
11:17:10 <scooty-puff> i will see if maybe using a letrec rule instead of just having a built in fix in the type env makes it work out better
11:18:13 <scooty-puff> (i'll put up an hpaste)
11:18:36 <Philippa> scooty-puff: keep track of which variables are existentially quantified (the ones you don't know about) and which are universally quantified (the generalised ones)
11:27:15 <hpaste_> scooty-puff pasted “Recursion and type checking” at http://hpaste.org/67435
11:27:36 <scooty-puff> Philippa, not sure if the paste clears anything up
11:28:26 <scooty-puff> don't want to have to regenerate a substitution whenever i specialize mutually recursive types
11:28:32 <sam6> Can I get some help with this code please? http://hpaste.org/67436
11:28:33 <scooty-puff> *types -> functions
11:29:05 <scooty-puff> simple recursive functions and nonrecursive functions don't undergo instantiation before being added to the type environment
11:29:09 <scooty-puff> so not a problem with those
11:29:55 <dmwit> sam6: Just delete the mTranspose [] = [] and mTranspose x@(fromList []) = x lines entirely, why not.
11:30:05 <dmwit> The other lines completely subsume them.
11:30:12 <scooty-puff> but if i instead specialize the t\type within the fix, such that everythign would still line up, whenever a speciallize one function in an scc, i have to specialize all
11:30:44 <scooty-puff> *a -> i - sorry about the spelling errors, text keeps blinking to white in my gnome install for some reason..
11:31:48 <sam6> dmwit: I see, but I'm not sure how I should even go about the second line
11:32:05 <sam6> does repeat (fromList []) make sense?
11:32:18 <dmwit> sam6: Yes, but there's no repeat for Vector.
11:32:33 <dmwit> (All Vectors are finite.)
11:32:51 <sam6> right, that's the problem :(
11:33:07 <sam6> I guess I have to come up with another approach for matrix transposition?
11:33:15 <dmwit> yes
11:33:27 <dmwit> sam6: Might I suggest repa, which has this kind of thing built-in?
11:33:41 <sam6> I looked into that actually
11:33:50 <sam6> repa-algorithms have matrix operations
11:34:05 <sam6> but it worked only for doubles and I need one that works for general Num
11:34:15 <sam6> or I might have not looked at it closely
11:34:51 <dmwit> oh
11:35:03 <dmwit> Well, that should be easy to fix. Bonus points for sending a patch to the maintainer.
11:35:15 <rwbarton> it looks rather like if you copied the source and deleted the type signature it would work for all Num (at least whatever can go into a repa array)
11:35:20 <dmwit> It's probably as easy as just replacing the "Double" in the type signature with a type variable and a Num constraint.
11:35:33 <dmwit> ...yes, what rwbarton said
11:36:09 <hayashi> damnit cabal haddock, why are you looking for hs files when all the code's in lhs files ._.;;
11:36:49 <mbixby> Hi, does anybody know how to apply a given function to both sides of Either? E.g. https://gist.github.com/2466077
11:37:05 <dmwit> :t join either
11:37:06 <lambdabot> forall a c. (a -> c) -> Either a a -> c
11:37:17 <sam6> I don't have a lot of experience with haskell to tell if it will work
11:37:25 <dmwit> mbixby: Oh, that can't be done.
11:37:38 <dmwit> mbixby: Although it looks like you're applying show to both sides, you actually aren't.
11:37:38 <sam6> but it should work if I just change all Double to other types?
11:37:52 <dmwit> mbixby: You're applying show@Type1 to one side and show@Type2 to the other side.
11:38:19 <dmwit> mbixby: You can use "either show show" instead of magicfunction, though.
11:38:28 <dmwit> mbixby: So that's still quite an improvement.
11:38:40 <dmwit> :t either show show
11:38:40 <mbixby> ok, thanks much dmwit
11:38:41 <lambdabot> forall a b. (Show a, Show b) => Either a b -> String
11:39:01 <dmwit> sam6: Yes.
11:39:17 <mbixby> right, sorry i missed that, thanks lambdadot
11:40:05 <sam6> let me try
11:40:34 <dmwit> sam6: For example, change "(Monad m) => Array U DIM2 Double -> Array U DIM2 Double -> m (Array U DIM2 Double)" to "(Monad m, Num a) => Array U DIM2 a -> Array U DIM2 a -> m (Array U DIM2 a)".
11:41:29 <rwbarton> you'll also need some repa type class(es)
11:41:38 <rwbarton> unless repa has unboxed arrays
11:41:41 <rwbarton> um
11:41:42 <rwbarton> boxed
11:41:44 <rwbarton> un-unboxed
11:41:48 <dmwit> oh
11:42:05 <dmwit> Well, try just deleting the type signature and see what GHC thinks of it. =)
11:42:25 <rwbarton> oh wow, repa changed a lot since the last time I used it
11:42:55 <sam6> I guess something like this should work? http://hpaste.org/67438
11:43:17 <sam6> but shouldn't you need an option for this to compile?
11:43:18 <rwbarton> ghc will be the judge of that
11:44:03 <pqmodn> can anyone recommend an application to manage a library of CS papers (PDF)? mac or linux is fine
11:45:03 <pqmodn> (sorry if this is off-topic)
11:46:19 <hayashi> Anyone got any ideas why I'm getting "module `(package name)-(version):Main' is defined in multiple files:" followed by the source of my project but with .hs instead of the correct .lhs as the extension, when using cabal haddock?
11:47:11 <dmwit> Well, have you got two files, one named Main.lhs and one named Main.hs?
11:47:25 <dmwit> (Sorry of that question sounds stupid, but it makes sense to ask the easy stuff first...)
11:47:41 <dmwit> s/of/if/
11:47:53 <hayashi> Nope, none of them are .hs, named Main, or have the Main module in them >_>
11:48:27 <dmwit> pqmodn: mkdir, mv, ln? ;-)
11:48:30 <wli> I usually use -main-is and point it at test driver repl's, but most of what I write is a lib and if there's a real program main at all it's minimalistic.
11:48:39 <hayashi> *constituent source code filenames
11:48:43 <hayashi> (This being a library)
11:48:59 <dmwit> Why don't you paste the whole error?
11:49:00 <dmwit> ?hpaste
11:49:00 <lambdabot> Haskell pastebin: http://hpaste.org/
11:49:09 <pqmodn> dmwit: it's grown too big for that :)
11:49:32 <dmwit> pqmodn: What features are you wishing you had that you don't have?
11:49:58 <pqmodn> full-text search and a way to prioritize what to read next
11:50:05 <sam6> Can you take a quick look? http://hpaste.org/67440
11:50:11 <pqmodn> i find new papers faster than i can read them :\
11:50:44 <dmwit> ah, yes
11:50:47 <hpaste_> wli annotated “generating function convolutions” with “DCE, line length cleanups, title, for real this time” at http://hpaste.org/67407#a67441
11:50:50 <dmwit> I use my bug tracker for that purpose. =)
11:50:59 <pqmodn> dmwit: that might work
11:51:04 <dmwit> sam6: Well, each error tells you how to fix it...
11:51:12 <jankud> Why (<) 2 3 return True, while let g = (<) and g 2 3, returns an error?
11:51:24 <dmwit> > let g = (<) in g 2 3
11:51:25 <lambdabot>   True
11:51:26 <mauke> jankud: because 'let' requires 'in'
11:51:32 <pqmodn> dmwit, actually that sounds pretty interesting. thanks :)
11:52:03 <jankud> mauke: But let g = (+) and g 2 3 returns 5
11:52:10 <mauke> no, it doesn't
11:52:16 <jankud> I am using interpreter btw
11:52:25 <mauke> doesn't matter
11:52:27 <tgeeky> > let g = (+) in g 2 3
11:52:28 <lambdabot>   5
11:52:38 <hpaste_> hayashi pasted “argh” at http://hpaste.org/67442
11:52:52 <hayashi> dmwit: That --^
11:52:55 <dmwit> jankud: If by "and" you mean "put these two things on separate lines", then I can't reproduce your claimed error.
11:53:07 <dmwit> jankud: Perhaps you'd better post a transcript of your ghci session to hpaste.org.
11:53:16 <mauke> hayashi: missing 'module' declarations?
11:53:50 <dmwit> hayashi: It looks like you forgot to say module Language.Php.Pretty where at the top of Pretty.lhs (and similarly for Syntax.lhs).
11:54:08 <hayashi> mauke: Both files have module declarations, the project builds fine, haven't tested it with something else, but Haddock seems convinced that the source files end in .hs!
11:54:25 <mauke> hayashi: paste the first lines of both files
11:54:32 <dmwit> hayashi: Is the module line prefaced by bird tracks? ;-)
11:54:36 <sam6> It seems that I have to have a contrain (Unbox a) but it seems to not be in scope
11:54:39 <jankud> http://hpaste.org/67443
11:54:46 <jankud> This is the interpreter output
11:54:58 <dmwit> hayashi: (The "haddock thinks they're .hs files" is a red herring. That's just what the un-lhs preprocessor does.)
11:54:59 <mauke> jankud: I notice that it doesn't contain 'and'
11:55:13 <mauke> jankud: also, monomorphism restriction
11:55:36 <jankud> mauke: Oh yes 'and' is a normal english word, my mistake sorry
11:55:38 <hayashi> dmwit: Yes, _though_ they currently have a wad of non-birded text above them, if that could be causing issues.
11:55:57 <dmwit> hayashi: Remember: blank line between every context switch.
11:56:23 <hayashi> Yep.  That's the case~
11:57:16 <jankud> mauke: Thank you for your help, I guess I know what's going on know:)
11:58:39 <dmwit> hayashi: Time to start pasting some code.
11:58:47 <dmwit> (Past time.)
11:59:14 <hpaste_> me pasted “adsf” at http://hpaste.org/67445
11:59:43 <dmwit> > Just "abc" ++ Just "def"
11:59:47 <lambdabot>   mueval-core: Time limit exceeded
11:59:50 <dmwit> uh
11:59:53 <dmwit> > Just "abc" ++ Just "def"
11:59:55 <ncksrv> how do I add whitespace between name and surname?
11:59:56 <lambdabot>   Just "abcdef"
12:00:09 <dmwit> > Just "abc" ++ Just " " ++ Just "def"
12:00:11 <lambdabot>   Just "abc def"
12:00:15 <dmwit> ncksrv: like that
12:00:21 <mauke> :t (++)
12:00:21 <ncksrv> no, the code must do it
12:00:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:00:22 <ncksrv> not me)
12:00:29 <mauke> ncksrv: that was code
12:00:30 <dmwit> ncksrv: My code is doing it.
12:00:46 <dmwit> ncksrv: (Though admittedly I'm using (++) instead of the more beginner-friendly mappend.)
12:00:49 <hayashi> Oh well, might as well stop being unhelpfully overprotective of my own awful and not-quite-ready-for-prime-time code then~~
12:00:54 <ncksrv> and with using <$> and <*> ?
12:01:01 <hpaste_> hayashi pasted “/me blushes at awfulness and unfinishedness of this” at http://hpaste.org/67446
12:01:05 <dmwit> ncksrv: Don't use <$> and <*>, they're unnecessary.
12:01:20 <dmwit> > mconcat [Just "hey", Just " ", Just "there"]
12:01:20 <ncksrv> in that case yes, but I'm just learning
12:01:21 <lambdabot>   Just "hey there"
12:02:10 <dmwit> Then write a better function than (++) as your first argument.
12:02:23 <ncksrv> m, ok
12:03:44 <hayashi> dmwit: One of the modules pasted up there --^  (expects the cause is something incredibly silly or trivial now)
12:08:12 <dmwit> hayashi: Which package is the pretty-printer from?
12:08:38 <dmwit> wl-pprint?
12:08:39 <hayashi> dmwit: wl-pprint
12:09:48 <hayashi> I'm not exactly very adept in it (and only recently found out about it), hence chunks of Pretty still handling strings and being written in weird and suboptimal ways.
12:10:17 <dmwit> I'm not really looking at your code.
12:11:27 <dmwit> Well, I get a completely different error than you. =P
12:12:01 <mauke> missing cabal build?
12:12:54 <dmwit> cabal build doesn't change the error I get
12:14:14 <hayashi> dmwit: *facepalms at self*  I should have pasted Syntax, given that Pretty is dependent on Syntax ._.
12:14:16 <kallisti> > (exp 1 ** ((0 :+ 1) * pi)) + 1
12:14:17 <lambdabot>   0.0 :+ 1.2246467991473532e-16
12:14:22 <kallisti> shouldn't this be 0? or am I doing something wrong?
12:14:25 <hpaste_> hayashi pasted “Nyoron” at http://hpaste.org/67448
12:14:33 <dmwit> hayashi: That's alright, I stuck a stub in my Syntax.lhs.
12:14:43 <hayashi> Ah.
12:14:47 <kallisti> is it a floating point error?
12:14:49 <dmwit> kallisti: rounding
12:14:52 <kallisti> aha
12:15:14 <dmwit> > exp ((0 :+ 1) * pi)
12:15:15 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
12:15:37 <dmwit> > exp (0 :+ pi)
12:15:38 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
12:16:14 <mauke> > abs (1 + exp (0 :+ pi))
12:16:15 <lambdabot>   1.2246467991473532e-16 :+ 0.0
12:17:02 <hayashi> Well, that's strange
12:17:15 <hayashi> if I take the preamble out of one of the source files, haddock gets a bit further
12:17:34 <tromp> @pl \x -> filter (testbit x pos) [0..40]
12:17:34 <lambdabot> flip filter [0..40] . flip testbit pos
12:17:40 <hayashi> and then spits a parse error out with the other one.
12:17:51 <dmwit> Yes, a parse error on "module".
12:17:53 <dmwit> I suspect a bug.
12:18:01 <dmwit> Which version of GHC are you using, 7.4?
12:18:09 <hayashi> Removing anything before the module tracks causes haddock to win.
12:18:21 <hayashi> 7.4.1, yeah.
12:18:40 <tromp> @pl \x -> filter (testbit x) [0..40]
12:18:43 <lambdabot> flip filter [0..40] . testbit
12:18:49 <mietek> Ugh
12:19:16 <mietek> Which package should I install to get Graphics.UI.Gtk.OpenGL ?
12:19:44 <mietek> It doesn't seem like it's included in gtk or opengl
12:19:57 <kallisti> gtkglext
12:20:06 <kallisti> http://hackage.haskell.org/packages/archive/gtkglext/0.11.0/doc/html/Graphics-UI-Gtk-OpenGL-Drawable.html
12:20:12 <kallisti> you can always look at the top of the Hackage docs to see the package.
12:20:19 <mietek> Ah, thanks
12:20:25 <hayashi> Everything is absolutely fine if the first bit is a birded comment
12:20:44 <dmwit> I would report this as a GHC bug.
12:20:45 <mauke> > -- weird
12:20:46 <lambdabot>   not an expression: `-- weird'
12:24:15 <efie> what is the difference between == [] and null? what is more efficient?
12:24:28 <mietek> http://stackoverflow.com/questions/10045313/error-installing-the-glade-library-for-haskell-via-cabal
12:24:41 <mietek> I've had exactly the same problem with gtkglext
12:25:10 <dmwit> efie: They are about equally efficient, but null works for more list types.
12:25:21 <dmwit> efie: (It doesn't require that elements be comparable for equality.)
12:25:43 <dmwit> mietek: It's on my todo list to figure out WTF is going on there.
12:25:44 <efie> dmwit: ah ok
12:25:47 <efie> thanks
12:26:02 <efie> to me null looks nicer
12:26:03 <dmwit> mietek: If you want to take a crack at it, feel free. Let me know what you discover.
12:26:03 <mietek> dmwit: cool
12:27:21 <Spockz> Someone with experience with Vacuum here? What do the I# and C# mean? Int(egers) and Chars? Also I have notes where no type name is provided, how can this happen?
12:28:42 <dmwit> Spockz: I# is the constructor for Int, C# for Char, yes.
12:29:01 <dmwit> Spockz: Code compiled with optimizations will have less typing information available at runtime.
12:29:07 <Spockz> this is from GHCI
12:29:26 <dmwit> For example, library code.
12:29:50 <dmwit> (I should make a disclaimer that I am definitely not a vacuum expert.)
12:29:53 <Spockz> dmwit: is that also why it doesn't recurse into there?
12:29:57 <dmwit> (But I've used it once or twice.)
12:30:02 <wli> I always wish for "optimize to the extent it doesn't interfere with debugging."
12:30:08 * hayashi is now confound by something else
12:30:17 <dmwit> wli: That's -O0. ;-)
12:31:00 <wli> dmwit: Not a priori, but in practice.
12:35:02 <Spockz> dmwit: do you know whether that it needs the type-info to recurse into the contents of a node?
12:35:46 <dmwit> I don't know, but it sounds plausible.
12:37:00 <hayashi> dmwit: Oddly enough, running Haddock manually works (except for not finding anything from the Haskell Platform libraries)
12:37:29 <Spockz> dmwit: indeed, but one of my earlier nodes also lacks a type but is being recursed into
12:41:16 <efie> is writing (pos,value):xs or tail xs more efficient?
12:41:36 <efie> oh it could have been x:xs
12:42:01 <merijn> You can also write "_:xs", but they should be equally efficient
12:42:27 <efie> ok
12:42:30 <Spockz> efie: the first forces evaluation where tail xs doens't
12:42:45 <merijn> oh, right
12:42:54 <efie> ah, sounds good :)
12:42:59 <Saizan> unless the first is an irrefutable pattern e.g. by being a let binding
12:43:28 <Spockz> Saizan: indeed
12:43:32 <bobfang> say I have ["a","b","c"]  is there a function I can use to glue them together to form a string "abc"
12:43:36 <bobfang> THX
12:43:37 <ion> > case [undefined, (1,2)] of (a,b):xs -> xs
12:43:38 <lambdabot>   *Exception: Prelude.undefined
12:43:48 <ion> > case [(undefined, undefined), (1,2)] of (a,b):xs -> xs
12:43:49 <lambdabot>   [(1,2)]
12:43:53 <ion> > case [undefined, (1,2)] of ~(a,b):xs -> xs
12:43:54 <lambdabot>   [(1,2)]
12:44:03 <Spockz> bobfang: yes concat
12:44:14 <dmwit> bobfang: Use Hoogle to answer this kind of question.
12:44:17 <bobfang> T
12:44:18 <dmwit> ?hoogle [String] -> String
12:44:19 <lambdabot> Prelude unlines :: [String] -> String
12:44:19 <lambdabot> Data.List unlines :: [String] -> String
12:44:19 <lambdabot> Data.String unlines :: [String] -> String
12:44:22 <bobfang> Okay
12:44:24 <bobfang> Thanks
12:44:28 <dmwit> ?hoogle [[a]] -> [a]
12:44:28 <lambdabot> Prelude concat :: [[a]] -> [a]
12:44:28 <lambdabot> Data.List concat :: [[a]] -> [a]
12:44:28 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
12:44:33 <Spockz> lol lambdabot those are not the ones we are looking for :)
12:44:37 <Spockz> and those are
12:44:57 <dmwit> The real hoogle lists concat very near the top.
12:49:20 <kallisti> it's too bad that fromString requires a runtime conversion
12:54:13 <srhb> kallisti: fromString?
12:54:31 * glguy wants an editor that can seamlessly show multiple files in series in a single editor.
12:54:35 <kallisti> yes. there's some slight overhead in converting string literals to ByteString/Text at runtime
12:54:43 <srhb> Oh.
12:54:46 <kallisti> that could be eliminated at compile-time if there were native support.
12:54:47 <glguy> It seems like it would be nice to look at multiple modules as one file
12:54:49 <dmwit> ?tell navaati darcs pull in your gtk2hs repository and enjoy =)
12:54:49 <lambdabot> Consider it noted.
12:55:35 <c_wraith> kallisti: The overhead is pretty minimal. They operate directly on GHC's internal format for the data - they never actually construct the linked list that makes up a String in memory
12:55:44 <dmwit> glguy: You've seen http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/ ?
12:55:57 <glguy> I saw *of* it :)
13:05:11 <dzhus> I can inverse Bool in Maybe with (fmap not), but how to inverse Bool in Maybe in IO?
13:05:21 <glguy> more fmaps
13:05:39 <wli> fmap (fmap not)
13:07:10 <Tomsik> :t fmap . fmap $ not
13:07:11 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f (f1 Bool) -> f (f1 Bool)
13:07:17 <adamch> Does anyone have a suggestion for a citation to Haskell's "deriving," in a scholarly context?
13:07:21 <hpaste_> dzhus pasted “A functor in a monad” at http://hpaste.org/67451
13:07:23 <parcs`> :t fmap fmap fmap not
13:07:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f (f1 Bool) -> f (f1 Bool)
13:09:14 <dzhus> There should be no more than 2 fmaps here I think
13:09:59 <Tomsik> dzhus, (.) is a special case of fmap
13:10:04 <glguy> dzhus: parcs` is using the fact that fmap is (.) for functions
13:10:20 <dzhus> right
13:10:52 <dmwit> adamch: The Report, unless you want to discuss GeneralizedNewtypeDeriving.
13:10:53 <dzhus> nah,       Actual type: Bool -> Bool
13:10:58 <parcs`> i have a parentheses and $ phobia
13:11:03 <dmwit> Then you'll probably want to cite one of the System Fc papers.
13:11:05 <glguy> ?type ((.).(.)) not :: IO (Maybe Bool) -> IO (Maybe Bool)
13:11:06 <lambdabot> IO (Maybe Bool) -> IO (Maybe Bool)
13:11:09 <adamch> dmwit, probably I don't want to get that fancy.
13:11:14 <glguy> Lambdabot is broken, so you cause abuse (.) to do it, too
13:11:26 <dzhus> glguy: this is it i think
13:12:04 <dzhus> nope
13:12:12 <dzhus>       Actual type: (Dataset -> a0 -> b0) -> Dataset -> a0 -> c0
13:12:18 <parcs`> import Control.Monad.Instances
13:13:52 <dzhus> nope
13:15:52 <adamch> dmwit, OK, I'll cite the specific section of the Report.  Thanks.
13:25:52 <hpaste_> dzhus pasted “Eventually had to do this explicitly” at http://hpaste.org/67452
13:28:17 <dmwit> :t (<$>)
13:28:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:28:23 <dmwit> uh...
13:28:37 <dmwit> inverseChecker = fmap (fmap not) -- ?
13:28:55 <dmwit> oh, not quite
13:29:42 <jankud> What's the best way to allow a function to return either Int or Bool?
13:29:50 <dzhus> dmwit: yip
13:29:56 <dzhus> jankud: Either Int Bool
13:30:04 <dmwit> inverseChecker original = fmap (fmap not) . original
13:30:27 <dmwit> inverseChecker = (fmap (fmap not) .)
13:30:29 <jankud> dzhus: srsly? I am just learning the language, that's actually amazing thanks
13:30:35 <dmwit> ...if you prefer point-free.
13:30:49 <hpc> @src Either
13:30:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:30:50 <dzhus> dmwit: You Gain 1 Golden Kudo
13:30:54 <hpc> wat
13:30:57 <dzhus> jankud: yep lol
13:31:10 <dzhus> jankud: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
13:31:14 <hpc> jankud: data Either a b = Left a | Right b
13:31:15 <dmwit> jankud: You will of course need to tag your Int's with Left and your Bool's with Right.
13:31:27 <hpc> Left is considered the "error" and Right the "success", in cases where it matters
13:31:43 <dmwit> inverseChecker = fmap (fmap (fmap not))
13:31:45 <dzhus> jankud: then pattern match on result to find out which one was actually returned
13:31:45 <parcs`> Maybe (Maybe Int)
13:31:48 <hpc> the convention lets you write types that look like "Either Error BaconFactory" or whatever
13:31:54 <dmwit> dzhus: There, that's the best one yet. =)
13:32:16 <dzhus> I liked the booby version but it didn't work
13:32:20 <dzhus> by glguy
13:32:39 <dmwit> parcs`: That's not at all the same.
13:32:50 <dmwit> or...
13:32:53 <dmwit> Oh, that's terrible.
13:32:54 <hpc> parcs`: oh god what
13:32:59 <jankud> Thanks again! :)
13:33:44 <dmwit> dzhus: It would have worked if you'd written (.) = fmap like it is in lambdabot.
13:34:13 <dmwit> :t (.)
13:34:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:34:52 <hpc> dzhus: you also would have had to hide (.) from Prelude
13:35:16 <glguy> While you are breaking standard definitions you could just name (.) = fmap (fmap not)
13:35:28 <glguy> make things short for this case
13:35:51 <dmwit> (.) = fmap doesn't break nearly as many things as your proposed definition would.
13:36:12 <dmwit> In fact, (.) = fmap only gives worse error messages than the usual (.); it doesn't break anything.
13:37:40 <Tomsik> dmwit, it makes some things pass that shouldn't
13:37:48 <dmwit> Define "shouldn't".
13:37:54 <mauke> dmwit: it makes some programs stop compiling
13:38:12 <dmwit> mauke: huh
13:38:20 * glguy guesses monomorphism restriction
13:38:30 <Tomsik> > (Just 1) . id
13:38:31 <lambdabot>   Couldn't match expected type `a -> b'
13:38:32 <lambdabot>         against inferred type `Data.M...
13:38:46 <Tomsik> > id . (Just 1)
13:38:47 <lambdabot>   Just 1
13:38:48 <dmwit> mauke: Hm, due to ambiguous instances or so?
13:39:16 <Tomsik> if I wanted this to work I'd get a custom category (.), that's what typechecking is for
13:39:43 <mauke> dmwit: yes
13:39:44 <dmwit> Tomsik: Isn't "get a custom category (.)" basically what we're discussing doing right now?
13:40:15 <dmwit> Except we're using Functor instead of Category. Not such a big difference.
13:40:18 <Tomsik> I mean that (.) = fmap is too permissive sometimes
13:40:38 * dmwit shrugs
13:40:42 <dmwit> Depends what you want.
13:40:47 <augur> hey, different crowd now, so i guess ill ask again
13:40:49 <dmwit> dzhus wanted boobies in his code.
13:40:58 <Tomsik> I'd rather have compiler rule out things like (putStrLn "abc") . id
13:41:06 <dmwit> It does rule that out.
13:41:14 <Tomsik> does it?
13:41:15 <augur> anyone know of any interesting approaches to eliminating names and binders (other than HOAS, de bruijn indices, nominal logic, etc.)?
13:41:18 <Tomsik> > putStrLn . id
13:41:19 <lambdabot>   Overlapping instances for GHC.Show.Show
13:41:19 <lambdabot>                              (GHC.B...
13:41:24 <dmwit> > fmap (putStrLn "abc") id
13:41:24 <lambdabot>   Couldn't match expected type `a -> b'
13:41:25 <lambdabot>         against inferred type `GHC.Ty...
13:41:25 <Tomsik> > (putStrLn "Abc") . id
13:41:26 <lambdabot>   Couldn't match expected type `a -> b'
13:41:26 <lambdabot>         against inferred type `GHC.Ty...
13:41:43 <Tomsik> > id . (putStrLn "Abc")
13:41:45 <lambdabot>   <IO ()>
13:42:04 <dmwit> augur: There's the locally nameless approach, but it doesn't completely eliminate names.
13:42:09 <dmwit> Unbound names still exist.
13:42:10 <tromp> augur: seems you enumerated all the known approaches:)
13:42:39 <tromp> you could use de bruijn levels rather than indices
13:42:56 <augur> tromp: :p
13:43:03 <augur> enumFrom HOAS
13:43:08 <augur> whats a de bruijn level?
13:43:29 <tromp> it numbers outside-in rather than inside-out
13:43:50 <augur> example
13:43:51 <augur> ?
13:43:51 <tromp> so S would be \ \ \ 1 3 (2 3)
13:44:14 <tromp> instead of \ \ \ 3 1 ( 2 1)
13:44:58 <ArtyomKazak>  > sum [fst $ randomR (0::Int, 1) (mkStdGen k) | k <- [1..1000]]
13:45:00 <rzys> hey, im trying to rewrite a ruby script in haskell to get a html page from a webpage which requires a login. in ruby the whole thing looked like this: http://pastebin.com/qFuVKRhr. i did this: http://pastebin.com/iqw27akM in Haskell but it doesn't seem to work. Do i miss something obvious? I'm using the library from http://hackage.haskell.org/packages/archive/HTTP/4000.2.2/doc/html/Network-HTTP.html
13:45:04 <mauke> The pastes qFuVKRhr iqw27akM have been copied to http://hpaste.org/67454 http://hpaste.org/67455
13:46:04 <ArtyomKazak> @run sum [fst $ randomR (0::Int, 1) (mkStdGen k) | k <- [1..1000]]
13:46:39 <ArtyomKazak> lambdabot, where are you?
13:47:12 <srhb> > "Here I am"
13:47:18 <srhb> NnNNNNNOOOOO
13:47:36 <ArtyomKazak> On my machine, it gives 1000.
13:47:59 <dmwit> ArtyomKazak: The sequence of first values to come out of a random number generator is not random.
13:48:17 <dmwit> s/random\./pseudo-random/
13:48:35 <dmwit> Only the sequence of values that comes out of a single seed is (pseudo)random.
13:49:05 <dmwit> If you want your coin-flipping application to look random across many runs, you will need to make your seed persistent.
13:49:34 <ArtyomKazak> But the first number should depend on the seed.
13:49:41 <zenware> Actually, you would rather have a random seed for it to appear random...
13:50:00 <dmwit> ArtyomKazak: That statement is deceptively simple.
13:50:04 <dmwit> The reality is not so simple, of course.
13:50:11 <dmwit> e.g. define "depend"
13:50:29 <zenware> It's a common misconception that random is an even spread.
13:50:31 <ArtyomKazak> Wait. It gives ones for first 10000 numbers, but later it starts giving zeros.
13:50:37 <dmwit> The output of randomR (1, 1) might not "depend" on the seed, even though it does use the seed in non-trivial computation before producing its result.
13:50:50 <zenware> Random could in fact be two of the same value in a row.
13:51:01 <ArtyomKazak> I know, I know :)
13:51:13 <dmwit> zenware: random seeds are not enough.
13:51:58 <dmwit> zenware: A random number generator can create good, truly pseudo-random sequences, and still have the property that the first number it outputs is always odd.
13:52:10 <dmwit> (for example)
13:53:36 <ArtyomKazak> Then the sequence is good only without its first element. Imagine such an generator used for running a lottery.
13:53:39 <rzys> somebody knows whats the best way to post form data? http://pastebin.com/iqw27akM is all i came up with :)
13:53:40 <mauke> The paste iqw27akM has been copied to http://hpaste.org/67455
13:53:44 <zenware> I didn't mention anything about it being bad the first number is always odd, in fact I made no reference to it, but there are several overt ways of fixing that.
13:53:46 <dmwit> ArtyomKazak: The first element is not special.
13:54:07 <dmwit> ArtyomKazak: A random number generator can create good, truly pseudo-random sequences, and still have the property that the 1065th number it outputs is always odd.
13:54:19 <dylukes> > 1 + 1
13:54:47 <dmwit> ArtyomKazak: That is: don't use pseudo-random numbers for lotteries!
13:55:12 <ArtyomKazak> In my case, I used it for simulating a small experiment.
13:55:23 <dmwit> ArtyomKazak: (In fact, this lesson was learned the hard way in the nethack community when one player manipulated the RNG into giving him a wand of wishing (the most powerful item in the game) on level 1 three times out of three games in one day.)
13:56:02 <zenware> dmwit: I can create good, psuedo-random numbers that have some sort of constants, but if I do I'm getting away from the point in being random.
13:56:24 <mauke> dmwit: heh. how?
13:56:51 <dmwit> mauke: Actually, the nethack server was doing an even worse thing: it was seeding by time.
13:57:09 <mauke> wait, server?
13:57:31 <hpaste_> timthelion pasted “Nonsensical behavior?” at http://hpaste.org/67456
13:57:36 <dmwit> mauke: Yes, it's not considered "special" if you achieve an effect on a local instance of nethack, since you can just change the executable by recompiling in whatever special thing you want to happen. =)
13:57:48 <benmachine> http://hackage.haskell.org/package/gutenberg-fibonaccis what is this I don't even
13:57:48 <timtheli1n>  Hello, I'm suffering from some seemingly random and illogical behavior...
13:57:53 <dmwit> mauke: So there are servers that you telnet into to play nethack; special things there are considered really special. =)
13:58:11 <glguy> When you use "otherwise" like the in a case expression you are actually naming the result "otherwise"
13:58:11 <ArtyomKazak> Appears to be that using consecutive seeds for mkStdGen is a very bad idea. Well, lesson learned.
13:58:17 <glguy> shadowing the previous definition
13:58:34 <mauke> timtheli1n: 'n' and 'otherwise' are the same pattern
13:59:01 <glguy> case … of n -> … -- the n will match everything
13:59:02 <timtheli1n> mauke: um?  I didn't understand case syntax apparently...
13:59:11 <dmwit> benmachine: I don't foresee a lot of reverse dependencies for that package.
13:59:20 <timtheli1n> ok
13:59:24 <mauke> > case 41 of n -> n + 1
13:59:37 <benmachine> dmwit: mm.
13:59:39 <geekosaur> case syntax is pattern matching.  "otherwise" is an irrefutable pattern which binds its match to that name, shadowing the exiting binding
13:59:42 <geekosaur> otherwise is not a keyword
13:59:46 <geekosaur> > otherwise
13:59:51 <ArtyomKazak> True
13:59:54 <geekosaur> hrm, we lost bot?
13:59:58 <ArtyomKazak> Yep.
14:00:06 <mkaito> As a learning project, I'm writing a little program to download stuff off certain sites. It downloads some images matching a pattern and the output should be a zip archive with the bunch. Would you load all the images into memory and then flush it straight into a zip file on disk, or download them to disk and then compress? All images of a batch are under 20mb, so I'd say a modern computer can handle it in
14:00:08 <mkaito> memory as a bytestring.
14:00:14 <timtheli1n> there was a netsplit a little bit back
14:00:33 <geekosaur> oh right, saw that, didn't notice lb was part of it
14:00:34 <dmwit> mkaito: in-memory seems fine, yeah
14:00:44 <mkaito> thanks :)
14:01:12 <mkaito> also, what's the lib of choice for extracting things from a html page?
14:01:22 <dmwit> tagsoup is nice for one-offs
14:01:26 <benmachine> mkaito: that depends on how tidy the page is
14:01:36 <benmachine> tagsoup is good for badly-written pages :P
14:01:38 <mkaito> it's html. you really expect it to be tidy? :P
14:01:40 <benmachine> but it's also good in general
14:02:18 <benmachine> http://hackage.haskell.org/package/tagsoup
14:02:27 <mkaito> I've been using tagsoup, and got it to work... somehow... the api documentation isn't as clear as I'd like it to be, so I wondered if there's something else.
14:02:45 <mkaito> thanks folks
14:03:21 <benmachine> mkaito: well, you can always ask here for clarification
14:03:25 <benmachine> except I should be doing work
14:03:28 <benmachine> and/or eating food
14:03:33 * benmachine gets back to that
14:03:38 <mkaito> food is imba
14:06:22 <mparodi_> Hello
14:06:50 <mparodi_> what book do you suggest me to learn Haskell?
14:07:08 <dmwit> ?where gentle
14:07:12 <dmwit> ack
14:07:23 <dmwit> http://www.haskell.org/tutorial/
14:07:30 <dmwit> http://learnyouahaskell.com/
14:07:39 <dmwit> http://book.realworldhaskell.org/
14:08:13 <efie> Hello, I am lost completing a function which transforms a Tree into a list: http://hpaste.org/67457 Can anyone give me the missing part or hints?
14:08:15 <mparodi_> dmwit, thank you
14:09:27 <dmwit> efie: You might want to write a helper function which also has access to the path through the tree used to reach the current node.
14:09:57 <dmwit> efie: (Also, why not generalize the type to Tree a -> [[a]]?)
14:10:35 <dmwit> Actually, I guess you can do it without a helper function if you've got a bit of chutzpah.
14:10:59 <mauke> the Failure case looks wrong
14:11:01 <dmwit> Take all the deeper paths and prepend the current node's value to them. =)
14:11:13 <dmwit> Yes, but he'll discover that himself soon enough when testing the code... right??
14:12:14 * hackagebot blaze-svg 0.3.0.1 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.0.1 (DeepakJois)
14:12:31 <efie> mauke: I don't get what might be wrong
14:12:44 <efie> with the failure case
14:12:46 <mauke> it should be []
14:12:59 <mauke> a tree of Failure has no solutions
14:13:24 <efie> ok
14:13:30 <hpaste_> timthelion pasted “what to do :(” at http://hpaste.org/67458
14:14:04 <timtheli1n> Should I try to report these kinds of things as bugs agains gtk2hs?  I just don't know what to do, they happen truely randomly.
14:14:56 * pigworker hacked all day, hits the hay.
14:15:40 <mparodi_> do you know the book "the craft of functional programming"? would you suggest it?
14:15:50 <dmwit> timtheli1n: Yes, sure. Having a reliable way to reproduce the problem would really help a lot, though.
14:16:32 <timtheli1n> dmwit: well, I have an application which could be uploaded to github, and running it 25 times will probably produce the crash at least once :)
14:17:05 <dmwit> Well, it would be much appreciated if you could at least make the application as small as possible before reporting the bug.
14:17:34 <dmwit> Remove features at random until the bug stops happening, then put that feature back in and continue.
14:17:55 <timtheli1n> dmwit: The application does not have many features.
14:18:08 <efie> dmwit: I'd like to do it for a special case and then, if it works, expand to be more general
14:18:08 <dmwit> The process shouldn't take long, then. =)
14:18:27 <dmwit> efie: Whatever floats your boat, I guess.
14:18:45 <efie> what does this mean?
14:18:56 <dmwit> "follow your heart"
14:19:00 <efie> ah ok :D
14:19:21 <timtheli1n> dmwit: That's actually a tremendous amount of work you are asking me to do.  The crash does not happen often.  So it is hard for me to tell if it has stopped happening, or if I'm just lucky...
14:19:46 <glguy> You should only do the work if you care if the bug goes away
14:19:55 <rzys> sorry for asking again, but does somebody know how to post a form via HTTP POST? what i came up with: http://hpaste.org/67455, the working ruby equivalent http://hpaste.org/67454
14:20:59 <efie> "take all the deeper paths and prepend the current node's value to them." I'm not sure if I get this right: If I come to "Node x [Success]]" I know that I have to add x to the list, but then I cannot get to the other values which were before I reached this end of the path, can I?
14:21:07 <rzys> the empy list in the Request Constructor is of type [Header]
14:21:43 <dmwit> efie: You should not pattern match on the list of children you have when trying to work out what to return for a Node.
14:21:47 <mauke> efie: you don't need them
14:21:51 <dmwit> efie: Let the recursive call pattern match on the children.
14:22:15 <Saizan> rzys: http://hackage.haskell.org/packages/archive/HTTP/4000.2.3/doc/html/Network-Browser.html#v:formToRequest
14:22:23 <timtheli1n> Gtk2hs would be much better, if gtk2hs function calls were not IO but rather GTK wrapped by IO.  Then I could at least check by typechecking to see if I've managed to surround absolutely everything that needs it with postGUIAsync.
14:24:35 <rzys> Saizan, thank you!
14:24:36 <dmwit> timtheli1n: You know what's great about open-source projects like gtk2hs...?
14:26:33 <timtheli1n> dmwit: I'm sure you don't want someone who has been coding in haskell 6 months(plus a few back when Dons decided to adopt me and teach me to write plugins for xmonad a few years ago) to attempt a major project involving the creation of monad wrappers.
14:27:15 <efie> um I don't get it ..
14:27:26 <timtheli1n> efie: hm?
14:27:26 <dmwit> You're wrong. I'd be thrilled to see you get involved in the gtk2hs community.
14:27:58 <timtheli1n> dmwit: I don't have a clue how to go about doing what I sugested though :(
14:28:07 <efie> timthelin: I am talking about my transform-tree problem above
14:28:14 <timtheli1n> efie: OK
14:29:18 <dmwit> Well, I could give you some pointers.
14:29:40 <efie> (me?)
14:29:48 <dmwit> The obvious place to start is with "newtype Gtk a = Gtk { runGtk :: IO a } deriving (Functor, Monad, MonadIO)".
14:29:59 <efie> oh, ok
14:31:07 <dmwit> You'd want to change the types of basically every function in Gtk to return a Gtk foo rather than an IO foo; except, perhaps, that postGUI(A)sync :: Gtk a -> IO a and mainGUI :: Gtk a -> IO ().
14:31:23 <dmwit> It would be a pretty tremendous project.
14:31:35 <serialhex> hey, is there any way to embed a lambda or function in a data constructor?  or am i looking for something that dosn't exsist??  example code (dosn't compile): `data Surreal = Surreal  { left  :: (\x -> Set.singleton x) Set.Set Surreal }`
14:31:40 <dmwit> And it would certainly break all kinds of backwards compatibility.
14:31:47 <timtheli1n> dmwit: are "most of the functions" automatically generated, or not?
14:31:49 <wjt> is it possible to tell hp2ps not to ellipsise the legend?
14:32:19 <dmwit> serialhex: Sorry, what do you want "singleton" to do when handed a type...?
14:32:46 <dmwit> timtheli1n: Not really, unfortunately.
14:33:04 <dmwit> serialhex: I don't understand what you want that to mean, so I'm not sure how to help you fix it.
14:33:09 <serialhex> dmwit: dosn't that create a set with just that element?
14:33:36 <dmwit> serialhex: singleton creates sets, yes, but it creates sets of Haskell values.
14:33:44 <dmwit> serialhex: Not a set of types!
14:33:48 * Philippa suspects serialhex wants dependent types
14:33:51 <serialhex> dmwit: surreal numbers are basically a pair of left & right sets of more surreal numbers.... and that's what i'm trying to implemtnt
14:34:00 <serialhex> possibly
14:34:10 <Philippa> but not necessarily for the underlying problem
14:34:30 <dmwit> data Surreal = Surreal { left :: Set (Set Surreal), right :: Set (Set Surreal) } -- ?
14:34:43 <serialhex> something like that yeah
14:34:55 <timtheli1n> dmwit: Well, I want to get to some level of being at beta with the program I'm writting before I tackle that.  And the reason, is that I'm trying to demonstrate a certain model of object management in multithreaded environments with my program.  If I am successfull, I'd kind of like my model to be used in a wrapper to GTK2HS.
14:35:22 <dmwit> timtheli1n: Yes, that seems perfectly legitimate.
14:35:34 <hpaste_> timthelion pasted “ThreadObject” at http://hpaste.org/67459
14:35:40 <serialhex> but when i do say: nil = Set.empty; zero = nil `Surreal` nil; one = zero `Surreal` nil (making the first 2 surreal numbers, 0 & 1) i get type errors...
14:36:15 <timtheli1n> dmwit: my model is a method of guaranteeing locks will be released thus preventing the MVar take will never be fulfilled crash.
14:36:30 <serialhex> oooh.... theres a paste service linked to #haskell???
14:36:35 <mparodi_> http://www.amazon.com/Haskell-Craft-Functional-Programming-Edition/dp/0201342758
14:36:39 <mparodi_> this is the book, do you know it?
14:36:43 * serialhex thinks thats spiffy
14:37:34 <dmwit> serialhex: Perhaps you meant one = singleton zero `Surreal` nil
14:37:36 <dmwit> err
14:37:40 <timtheli1n> dmwit: I pass actions between threads, rather than values.  That is, if I need to use and modify a value, rather than taking and putting an MVar, I pass the action to a thread dedicated to the value, and the value is "occupied" for the time that it takes the action to run.  Thus gauranteeing the lock.
14:37:54 <dmwit> serialhex: Perhaps you meant one = singleton (singleton zero) `Surreal` nil -- depending on whether I got the right number of Set type constructors
14:38:13 <serialhex> dmwit: yes, i can do that .... but IMO it's kind of funky to do that (not funky in a good way)
14:38:29 <hpc> @hoogle IO a -> IO (MVar a)
14:38:29 <dmwit> serialhex: Why?
14:38:31 <serialhex> so i'm just looking for a cleaner way to implement this stuff
14:38:38 <hpc> > "lambdabot?"
14:38:41 <hpc> :(
14:38:44 <dmwit> What makes it funky?
14:39:08 <timtheli1n> dmwit: GTK2HS doesn't work with this locking model, because a thread can arbitrarilly access and modify an object with getChildren or getParent...  So there is no way to guarantee that a widget is locked while it's being worked with :(
14:39:18 <serialhex> i want to be able to just put 2 surreal numbers on the left & right and get a surreal number back...
14:39:51 <dmwit> serialhex: But a surreal number doesn't contain two surreal numbers, it contains two sets of surreal numbers.
14:39:57 <efie> am I on the right track?  http://hpaste.org/67460 (though this does compile and I'm not sure why right now)
14:39:57 <serialhex> and yes, i know nil isn't a surreal, but it's kind of nessisary
14:39:58 <serialhex> yes
14:40:05 <timtheli1n> dmwit: and there is no way to bind a child to it's parent such that when the parent is being worked with the child is also in locked state.
14:40:11 <dmwit> serialhex: So why would it be funky for the type system to require you to put two sets rather than two surreals?
14:40:48 <dmwit> timtheli1n: I'm not really going to fight with you about your agenda. If you want a bug fixed, I've told you what I ask of you before I'll look at it.
14:41:12 <dmwit> Give me the smallest, most reliably-crashing program that you're able to give me.
14:41:17 <efie> (though this does >not< compile) ..
14:41:37 <hpaste_> hpc pasted “is this sane?” at http://hpaste.org/67461
14:41:49 <dmwit> efie: Yes, that looks very close to good.
14:41:50 <serialhex> dmwit: because you can have just a single surreal on either side...  this code works, but i *know* it's not a set: `data Surreal  = Nil | Surreal { left  :: Surreal , right :: Surreal } deriving (Show, Eq)`
14:41:51 <hpc> can someone who knows more about threading than i do comment on this code? http://hpaste.org/67461
14:42:06 <hpc> i want to know if the use of unsafeInterleaveIO is sane here
14:42:34 <dmwit> serialhex: Why not define a function like "surreal x y = singleton x `Surreal` singleton y" or something like that?
14:42:42 <hpc> for "give me a non-blocking thing back but block if i try to use it"
14:43:05 <serialhex> i could... and have that be the only interface to get surreals...
14:43:41 <dmwit> hpc: You might consider just "return (takeMVar var)".
14:44:06 <hpc> dmwit: that would make the calling thread block until 'act' finishes
14:44:15 <dmwit> hpc: Look again. =)
14:44:33 <dmwit> hpc: The calling thread gets handed an IO action which, when executed, blocks until act finishes.
14:44:48 <dmwit> spark :: IO a -> IO (IO a)
14:44:50 <serialhex> hmm....  haskell is very different, if this was ruby then i could just make it part of the constructor.... but since it's *not* ruby, i can have infinite numbers!!  (which is one of the cooler parts of surreals anyway!)
14:44:56 <hpc> dmwit: oh, nifty
14:45:38 <hpc> dmwit: does the interleaved version make sense though?
14:45:50 <dmwit> I'm not 100% sure, but I think yes.
14:45:53 <hpc> for this i don't really want the extra syntactic baggage
14:46:10 <hpc> groovy
14:46:53 <dmwit> efie: The only thing you're missing is that map collectSolutions returns a list of list of list of paths instead of just a list of list of paths.
14:47:03 <dmwit> efie: Think you can work out how to collapse one layer of list? =)
14:48:21 <dmwit> (that is, it returns an [[[a]]] containing one [[a]] for each child, but you really don't care *which* child gives solutions, so you want to collapse this a bit)
14:48:42 <ramier> is there a way where i can turn a list into type parameters, like doing Car [blue, 2012] into Car blue 2012 type
14:49:20 <monochrom> no, but I don't understand the question
14:49:35 <efie> dmwit: this sounds like a job for  concat?
14:49:56 <dmwit> efie: Yes it does!
14:50:17 <ramier> i have an array arr [blue, 2012], and i want to make the type "Car blue 2012"; i could do Car (arr !! 0) (arr !! 1), is there an easier way?
14:50:42 <dmwit> That's a list, not an array.
14:50:46 <dmwit> And yes, you can do something like
14:50:48 <ramier> err thats what i meant
14:50:58 <dmwit> case arr of [v1, v2] -> Car v1 v2
14:51:09 <ramier> ooooh
14:51:20 <ramier> that looks nicer, i'll do that :) thanks
14:51:47 <hpc> let [v1, v2] = arr in Car v1 v2 -- also this
14:52:08 <efie> dmwit: .. $ concat $ map collectSolutions ts? :|
14:52:09 <hpc> ramier: both of these will crash your program if you don't give a list of length 2
14:52:15 <ramier> yea i know
14:52:24 <dmwit> Probably you're binding "arr" somewhere that acn just be turned into the pattern [v1, v2] instead, so no case will be needed.
14:52:50 <dmwit> efie: You tell me. Does it type-check? Does it work?
14:52:56 <efie> no, it does not
14:53:06 <efie> "Equations for `collectSolutions' have different numbers of arguments"
14:53:35 <dmwit> ah
14:53:39 <dmwit> You need more parentheses.
14:53:44 <dmwit> collectSolutions (Node a ts) = ...
14:54:22 <monochrom> "Car v1 v2" is a value, not a type
14:54:34 <efie> dmwit: thanks a lot .. !
14:55:16 <efie> this looks so beautiful
14:56:05 <rasfar> aszlig, gienah in case you're around, i've made some progress on running my GHC binary as a CGI, but presently getting the following error when I try running the binary from the server command line:
14:56:08 <rasfar> test5.cgi: mkTextEncoding: invalid argument (Invalid argument)
14:56:34 <rasfar> is this an incompatibility between glibc versions?  and if so, am i out of luck?...
14:57:18 <efie> At the beginning I wasn't aware of the fact that mapping (:) x over an empty list produces an emtpy list
14:57:40 <kallisti> mapping anything over an empty list does that.
14:57:44 <rasfar> (i also get this error when compiling on my local machine:)
14:57:47 <rasfar> /usr/bin/ld: /usr/local/haskell-platform-2011.4.0.0/lib/ghc-7.0.4/libHSrts.a(Linker.o): in function internal_dlopen:Linker.c(.text+0x1107): warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
14:57:51 <kallisti> > map undefined []
14:58:07 <kallisti> oh lambdabot is gone
14:58:35 <ramier> this worked for me, but i'm wondering if it's standard practice or if there's a better way i can do it? :
14:58:37 <ramier>     case longestRanks of
14:58:37 <ramier>         (rank, count) | count >= 5 -> Just rank
14:58:38 <ramier>         _ -> Nothing
14:58:58 <ramier> using a single guard in case statements
14:59:14 <kallisti> what about it?
14:59:42 <ramier> is it standard to use guards in case statements
14:59:49 <kallisti> sure
15:00:18 <kallisti> practically every feature of case expressions are "standard"
15:01:07 <ramier> ok…because i did it using an if statement (rank, count) -> if count >= 5 then Just rank else Nothing and ghc complained Warning: Pattern match(es) are overlapped
15:01:43 <kallisti> ramier: what was the second case?
15:01:45 <dmwit> You might also like: (rank, count) -> guard (count >= 5) >> return rank
15:02:25 <ramier> the full thing's above, with the second case _ -> Nothing, so ghc was right with the warning, the guard fixed it
15:02:37 <kallisti> when using the if, you don't need the second case
15:02:44 <kallisti> it was complaining because _ and (rank, count) overlap
15:02:53 <parcs`> dmwit: i like rank <$ guard (count >= 5)
15:03:30 <dmwit> Well I like ensure ((>= 5) . snd)
15:03:34 <ramier> i don't think those advanced features have come up in the first 7 chapters of learn you a haskell yet
15:03:55 <parcs`> :t ensure
15:04:01 <parcs`> DNE
15:04:02 <dmwit> ensure p x = guard (p x) >> return x
15:04:12 <dmwit> I use it all the time.
15:04:19 <parcs`> does it exist in base
15:04:22 <dmwit> It's in Prelude.Dmwit
15:04:26 <parcs`> i c
15:04:31 <parcs`> never heard of that module
15:04:36 <dmwit> =)
15:04:45 <kallisti> ramier: yeah using Haskells primitives that's probably the best way to go about it (case with guards)
15:05:09 <hpaste_> dzhus pasted “Yet another functor-monad burrito” at http://hpaste.org/67462
15:05:16 <kallisti> I wouldn't worry about the advanced magic. ;)
15:05:51 <BMeph> parcs`: Obviously, you need to hang out with more dmwits... ;)
15:06:07 <serialhex> YAY!! i got it!! :D
15:06:09 <efie> thanks everybody, good night :)
15:06:39 <dmwit> dzhus: traverse f
15:06:45 <kallisti> dzhus: f <$> (M.lookup slot ds >>= M.lookup field)
15:07:00 <dzhus> kallisti: nope
15:07:12 <dzhus> tried that previously
15:07:26 <kallisti> oh because it's return Nothing
15:07:46 <serialhex> dmwit: thanks for the suggestion!
15:07:58 <kallisti> dzhus: M.lookup slot ds >>= M.lookup field >>= maybe (return Nothing) f
15:08:17 <dmwit> traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
15:08:19 <aufwind> I'd like to ask a question about syntax of functions with parameter matching. I want to write three syntactically different versions of the signum function. I have the if-then-else version and the "guards" version. Is it somehow possible to write a parameter matching version and/or a "case" version too? Here are my little snippets. (http://codepad.org/HmO7kqpI) Comments are welcome and appreciated. :-)
15:08:49 <dzhus> dmwit: this is great, thank you
15:09:21 <dzhus> This looks like specially done for cases when you need to peek under pillow but not uncover the whole bed
15:09:51 <serialhex> should i be using Set.singleton to create new single-element sets?  or is there something better i should use?
15:10:09 <kallisti> that sounds exactly like its use case.
15:10:13 <kallisti> so, yeah.
15:10:55 <serialhex> ok, i just wanted to make sure....  singletons in other langs are kind of different
15:15:11 <tryitout> @lambdabot \m x -> f x >= m
15:15:19 <tgeeky> serialhex: You might be thinking of http://en.wikipedia.org/wiki/Singleton_pattern ?
15:15:34 <dzhus> GoF heresy!
15:15:40 <tgeeky> serialhex: You went to Sets (which is a super-well-defined mathematical concept)
15:15:42 <serialhex> tgeeky: yeah, i wanted to be sure i wasn't doing that...
15:16:05 <tgeeky> serialhex: and I wouldn't expect you would normally load a set library in another language (say ruby? perl?) in order to make the singleton pattern
15:16:34 <tgeeky> serialhex: s/you/I/
15:16:37 <tryitout> @type map
15:16:42 <serialhex> i do want sets, i dont want to be making singletons of sets that can be re-used
15:17:01 <serialhex> and Set.singleton had me a bit confused... thats why the clarification
15:17:05 <dzhus> It's just that other languages have departed long enought from original mathematical meaning of «singleton»
15:17:27 <tryitout> hey guys, how I converse with the lambdabot?
15:17:37 <serialhex> oh?  and what is that dzhus??  (i'm not being facetious, i'm truely curious)
15:17:49 <tgeeky> tryitout:
15:18:13 <tgeeky> @let hello = text "how can I talk to lamdabot"
15:18:14 <dzhus> serialhex: set with one element
15:18:20 <tgeeky> @def hello = text "how can I talk to lamdabot"
15:18:22 <serialhex> > \m x -> f x >= m
15:18:34 <dzhus> serialhex: which matches its usage in Haskell
15:18:42 <tgeeky> @help
15:18:47 <tryitout> @help
15:18:50 <tgeeky> i think she's dead
15:18:53 <tgeeky> lambdabo
15:18:55 <tgeeky> yep
15:18:56 <aufwind> I found out, that I can mix parameter matching with one of the other cases (problem solved, I hope). Thanks anyway! :-)
15:18:57 <serialhex> dzhus: ahh, ok cool!  (i'm liking haskell more the more i use it :D )
15:19:22 <serialhex> aww... lambdabot dead?  :'(
15:19:31 <mauke> preflex: seen lambdabot
15:19:31 <preflex>  lambdabot was last seen on #haskell 1 hour, 37 minutes and 46 seconds ago, saying:   <IO ()>
15:19:38 <tryitout> oops... lambdbot's dead only when I think of her
15:19:45 <mauke> preflex: seen Cale
15:19:45 <preflex>  Cale was last seen on #haskell 17 hours and 1 second ago, saying: we23: um, is hSetEncoding in System.IO not enough here?
15:20:03 <tgeeky> LOL
15:20:15 <tgeeky> remind me to
15:20:18 <tgeeky> @remember  lambdabot was last seen on #haskell 1 hour, 37 minutes and 46 seconds ago, saying:   <IO ()>
15:20:21 <tgeeky> that's poetic
15:20:35 <timtheli1n> tgeeky: who is going to remember?
15:20:39 <tgeeky> timtheli1n: you
15:20:43 <tgeeky> timtheli1n: I assign you
15:20:55 <mauke> .oO( I choose you, timtheli1n! )
15:21:38 <tryitout> anyway, I'm trying to convert to pointless: \m x -> f x >= m
15:21:54 <tryitout> and I worked out this: (. f) . (=<<)
15:21:59 <tryitout> I wonder if there is any short form
15:22:07 <tryitout> shorter form
15:22:11 <monochrom> @pl \m x -> f x >>= m
15:22:19 <mauke> monochrom: welcome
15:22:25 <tryitout> @pl \m x -> f x >>= m
15:22:26 <monochrom> haha
15:22:27 <parcs`> there is (<=<) :: (b -> m c) -> (a -> m b) -> a -> m c
15:22:39 <tgeeky> lambdabot: (. f) . (=<<)
15:23:11 <tryitout> @pl \m x -> f x >>= m
15:23:18 <lambdabot> flip ((>>=) . f)
15:23:22 <parcs`> so \m x -> f x >>= m will be (<=< f)
15:23:29 <tryitout> well, flip is lame
15:23:39 <ramier> i have types representing cards, so data Rank = Two | .. | King | Ace deriving (Enum) and data Suit = Clubs | Hearts | … deriving (Enum), is there a trivial way to make data Card = Card Rank Suit deriving (Enum)?
15:23:44 <dmwit> ?pl \m x -> m =<< f x
15:23:52 <lambdabot> (. f) . (=<<)
15:23:54 <parcs`> :t ()
15:23:59 <dmwit> ramier: no
15:24:02 <lambdabot> ()
15:24:04 <ramier> : (
15:24:20 <ramier> : ( : (
15:24:32 <rasfar> aszlig, gienah i had to go offline (in case you would see the messages above and waste your time) -- i think i'll try a dedicated server!
15:24:40 <tryitout> thanks, parcs` <=< certainly looks more interesting!
15:24:45 <dmwit> ramier: If you derive Bounded on one of them, you can do it in a non-trivial but also non-repetitive way.
15:25:00 <dmwit> ramier: (As in you won't need to list all the cases, but you'll still need to write the instance yourself.)
15:25:10 <parcs`> :t \f -> [ \m x -> m =<< f x , (<=< f) ]
15:25:11 <ramier> hmm ok, i'll do that
15:25:16 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a1 -> m a) -> [(a -> m b) -> a1 -> m b]
15:25:33 <serialhex> is there a list of valid symbols for function names?
15:25:37 <dmwit> I suppose you'll probably need Eq, too.
15:25:48 <dmwit> serialhex: Yes, see the Report.
15:25:56 <tgeeky> serialhex: in the GHC docs, and on the ghci wiki
15:26:00 <tgeeky> under keywords, I think
15:26:04 <dmwit> > filter isLetter ['\0'..]
15:26:12 <serialhex> ok cool, thanks dmwit & tgeeky
15:26:13 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
15:26:21 <qnikst> hello, have smb experience with haskell-mongodb?
15:26:30 <DrSyzygy> What letter is \170?
15:26:36 <qnikst> I want to ask how to use JavaScr type
15:26:39 <mauke> U+00AA (c2 aa): FEMININE ORDINAL INDICATOR [ª]
15:26:41 <dmwit> > filter (any ($x) [isLetter, isPunctuation]) ['\0'..]
15:26:42 <dzhus> how to properly subtract two years from UTCTime?
15:26:47 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:26:53 <lambdabot>         against inferred ...
15:26:59 <dmwit> > text "\170"
15:27:06 <parcs`> dzhus: diffUTCTime
15:27:07 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
15:27:21 <parcs`> oh, you mean something else
15:27:36 <dmwit> dzhus: addUTCTime
15:27:55 <dzhus> parcs`: dmwit: this implies constant amount of time in year, which is false
15:28:12 <dmwit> yes, that's true
15:28:35 <parcs`> meh, it's constant enough
15:28:46 <dmwit> parcs`--
15:29:13 * parcs` felt that
15:29:14 <dmwit> dzhus: You may use toGregorian and fromGregorian
15:29:28 <dzhus> seems like the only option
15:29:29 <tgeeky> parcs`: it's not constant, it's not constant modulo anything
15:29:34 <dmwit> dzhus: However, do be careful that you don't produce an invalid Gregorian date by subtracting two years from a leap day.
15:29:39 <shapr> I am suddenly tempted to make a Haskell IRC game, where you get a type signature and a snippet of code with a blank spot, and you answer that question correctly by putting in code that gives that type (no undefined :-P )
15:30:10 <parcs`> tgeeky: i was being silly. 'constant enough' is an oxymoron to begin with
15:30:23 <dmwit> dzhus: Oh, there's addGregorianYearsClip.
15:30:34 <dmwit> and addGregorianYearsRollOver
15:30:56 <tgeeky> parcs`: i'm being funny too. But if I had my way, I'd cause all requests for the time to calculate using inflation-adjusted orbital mechanics.
15:31:39 <parcs`> hehe
15:31:51 <tgeeky> every single time.
15:32:10 <tgeeky> if your computer is too slow, then your clock would be innacurate. So we'll just do another run, adjusting for that.
15:36:26 <boccato> Can I cross-compile a windows exe from OSX with ghc?
15:36:44 <boccato> Or do I need a windows box?
15:37:04 <hpaste_> tvynr pasted “I Don't Know How Typeclasses Work” at http://hpaste.org/67464
15:37:29 <dmwit> boccato: I'm pretty sure that you need a Windows box (perhaps in a VM).
15:37:45 <tvynr> I'm having some trouble with typeclasses.  The paste is a representative example which I would expect would work.  Can I ask anyone to explain to me why that code produces a type error?
15:37:58 <qnikst> @hoogle Day -> Int
15:37:59 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
15:37:59 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
15:37:59 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
15:38:10 <mauke> tvynr: because 'b' is unknown
15:38:15 <mauke> er, wait
15:38:19 <glguy> tvynr: maybe you could have pasted the error?
15:38:23 <mauke> yeah
15:38:26 <dmwit> False. Because 'a' is unknown.
15:38:26 <mauke> is it about 5?
15:38:31 <boccato> dmwit: thx, ill try to set up a VM, my win note died
15:39:07 <dmwit> tvynr: Perhaps you would enjoy writing "test = unZ $ foo (5 :: Int)" instead.
15:39:33 <hpaste_> tvynr pasted “I Don't Know How Typeclasses Work: Error” at http://hpaste.org/67465
15:39:54 <glguy> tvynr: which part of that error did you need help with?
15:40:27 <mauke> :t 5
15:40:28 <lambdabot> forall t. (Num t) => t
15:40:54 <tvynr> glguy: I'm just perplexed as to why that code didn't select the single typeclass instance I wrote.
15:40:57 <tvynr> mauke: I see...
15:41:15 <mauke> 5 is polymorphic and the compiler doesn't check what instances actually exist
15:41:32 <mauke> (because other modules could add more later)
15:41:41 <glguy> tvynr:Haskell doesn't use the fact that it knows all of the possible instances to guess which type you meant
15:42:47 <glguy> tvynr: If you had a functional dependency "b -> a", then you'd be able to tell that 'a' was an Int given than 'b' was a Bool
15:42:53 <tvynr> mauke: I'm trying to use typeclasses to pretty up the construction of a fairly complex data structure and I'm getting an equivalent error.  I'm trying to figure out how to make this clean without explicitly type-annotating the call site (since that would defeat the point of the beautification).
15:43:15 <dmwit> tvynr: You can write something like
15:43:19 <tvynr> glguy: The problem is that this functional dependency does not hold in my actual case.
15:43:23 <dmwit> instance a ~ Int => Foo a Bool
15:43:40 <dmwit> if there are no other Bool instances
15:43:55 <dzhus> record-packed API's may seem a good alternative to typeclasses
15:44:17 <tvynr> dmwit: This is a representative example, of course... and my problem atm is that there *will* be other instances.
15:44:34 <dmwit> Will there be other instances with b ~ Bool? That's the important question.
15:44:39 <tvynr> dmwit, mauke: Thanks for clearing up the problem.
15:44:44 <tvynr> dmwit: Yes, that's the idea.
15:44:58 <dmwit> And other instances with a ~ Int?
15:45:23 <tvynr> dmwit: Shouldn't be, no.  But in the real case, a is parameterized.
15:45:44 <dmwit> If all instances with a ~ Int have b ~ Bool, then you may write
15:45:52 <tvynr> dmwit: The idea is that I have a wrapped structure such that I have to write things like (Foo (FooConstr x) (FooWrapper $ BarConstr y)) and I'd love to write (foo (fooConstr x) (barConstr y)).
15:45:52 <dmwit> eh... never mind
15:46:00 <dmwit> That doesn't help with this particular case anyway. =)
15:46:51 <dmwit> Anyway, we won't be able to suggest good solutions to the underlying problem until we know the underlying problem.
15:47:45 <tvynr> dmwit: I'll try to create a suitable MWE.  :)
15:48:36 <timtheli1n> dmwit: I managed to find a test case that guarantees a crash :)
15:49:28 <dmwit> timtheli1n: Wonderful!!
15:50:16 <timtheli1n> dmwit: so it's 1 am now.  I'll go to bed. And maybe tomorrow I'll work on gutting my code.
15:51:29 <dmwit> timtheli1n: Thanks, your hard work really matters.
15:52:38 <timtheli1n> dmwit: well I can tell you already, that the bug either relates to adding or removing widgets from a widget that is already drawn on the screen.
15:53:00 <hpaste_> tvynr pasted “Typeclass Troubles” at http://hpaste.org/67466
15:53:22 <tvynr> dmwit, glguy, mauke: If you're still interested, a more complete example appears at that paste.
15:53:27 <tvynr> dmwit, glguy, mauke: Thanks again for your help.
15:54:27 <qnikst> how to install modified package in cabal-dev project?
15:54:46 <tromp> :t maybe
15:54:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:55:42 <dmwit> tvynr: "lit" and "top" just shouldn't be in that class at all, they'll always be implemented as Lit and Top.
15:56:13 <dmwit> tvynr: For the other, I recommend something like class FooC v where type ContainedType v; pair :: v -> v -> Foo (ContainedType v)
15:56:15 <aufwind> Why is this self written function evaluating always to 0? http://codepad.org/rVydLs2E
15:56:21 <tvynr> dmwit: *nods*  But I don't understand why it produces an error.
15:56:42 <mauke> aufwind: because there's a 0 in line 7
15:56:48 <dmwit> tvynr: You can't determine "v" if it doesn't appear anywhere in the type of the class method.
15:57:05 <dmwit> tvynr: Every class method must mention every class variable (unless you have functional dependencies).
15:57:06 <aufwind> mauke: Shouldn't this line only be executed, if the list is empty?
15:57:20 <dmwit> s/class method/class method type/
15:57:21 <tvynr> dmwit: ...and so Haskell is concerned that there may be a second typeclass instance somewhere which would also be applicable...
15:57:29 <dmwit> yes
15:57:39 <tvynr> dmwit: That helps quite a bit.  Thanks.  :)
15:57:40 <spacebark> 0 * x = 0 for all x
15:57:48 <qnikst> how to install tar package to cabal-dev project?>
15:58:10 <mauke> aufwind: yes
15:58:14 <adnauseam> @hoogle divides
15:58:14 <lambdabot> No results found
15:58:17 <adnauseam> :o
15:58:25 <mauke> aufwind: every list is empty at the end
15:58:26 <aufwind> mauke: spacebark : I see my fault now. It is recursive.
15:58:27 <qnikst> thanks, I've found
15:58:27 <adnauseam> no divides ?
15:58:51 <aufwind> mauke: Yeah, that was clumsy of me.
15:59:12 <mauke> aufwind: prod (x : xs) = x * prod xs
15:59:33 <adnauseam> is div the same as divides ?
15:59:40 <mauke> :t div
15:59:41 <lambdabot> forall a. (Integral a) => a -> a -> a
15:59:55 <monochrom> eh? is someone trying to do "prod [] = 0"? :)
16:00:07 <mauke> monochrom: of course :-)
16:00:10 <aufwind> mauke: That is way more elegant. :-) I'll keep that in mind thanks. But since this is an exercise and I do have to use tail and head and null I have to figure out an other way. :-)
16:00:24 <mauke> aufwind: well, then just remove line 7
16:00:27 <mauke> done
16:00:54 <monochrom> my http://www.vex.net/~trebla/homework/empty.html explains why prod [] should be 1
16:01:14 <aufwind> mauke: This way prod [] (empty list) is evaluated to 1 too which is wrong.
16:01:24 <mauke> aufwind: no, it isn't
16:02:10 <qnikst> @hoogle Day -> UTC
16:02:10 <lambdabot> Warning: Unknown type UTC
16:02:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:02:10 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:02:16 <qnikst> @hoogle Day -> UTCTime
16:02:17 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
16:02:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:02:17 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:02:33 <adnauseam> is divides :: Integer -> Integer -> Bool ?
16:02:33 <hpaste_> tvynr pasted “Broke It Again :-P” at http://hpaste.org/67468
16:04:04 <tvynr> dmwit: I seem to be expecting a bit more inference than Haskell wants to give me.  :-P  Can you look at that paste?  I would've expected Haskell to infer t0~FooS from the fact that the "pair ..." expression on line 30 is passed to the FooS constructor.
16:04:08 <dmwit> tvynr: instance t1 ~ t2 => FooC t1 (Foo t2)
16:04:20 <aufwind> monochrom: Should I just "throw an exception" if someone tries to calculate prod [ ] ? :-)
16:04:32 <mauke> aufwind: no
16:05:42 <tvynr> dmwit: Wha... really?  I think I might not understand what the ~ constraint does...
16:05:46 <aufwind> mauke: I am sorry, perhaps I am overlooking something here, but his (http://codepad.org/sOPMPJiL) implementation evaluates to 1 for prod [ ]
16:05:52 <aufwind> his = this
16:05:56 <dmwit> tvynr: Again, we can't infer that t0 ~ FooS, because it's perfectly legitimate to later define an instance for FooC FooS (Foo Bool), say, since this can never overlap with the FooC t (Foo t) instance.
16:06:00 <tvynr> dmwit: I thought it asserted two types to be equal.  Is there some notion of equivalence I'm missing out on?
16:06:14 <dmwit> tvynr: No, you're right: ~ is type equality.
16:06:35 <mauke> aufwind: yes
16:06:58 <tvynr> dmwit: But... don't we have symmetry over type equality?  I'd figure that t~t would go without saying, in which case I'd think "(t1 ~ t2) => FooC t1 (Foo t2)" would be equivalent to "FooC t (Foo t)"
16:07:09 <dmwit> tvynr: You'd be wrong. =)
16:07:30 <dmwit> tvynr: In the former, t1 and t2 match any types, then later check that t1 and t2 happen to be equal.
16:07:35 <tvynr> dmwit: Apparently.  :-P
16:07:41 <dmwit> tvynr: In the latter, only types which are equal right away match.
16:07:44 <mauke> aufwind: why do you think that's a problem?
16:07:49 <dmwit> tvynr: (i.e. equal without doing any inference!)
16:08:11 <tvynr> dmwit: Aaaah... so the t1~t2 form captures a larger range of uses and then actively rejects some of them.
16:08:23 <dmwit> tvynr: Also, you should read "later check that t1 and t2 happen to be equal" as adding a constraint to the type inference, rather than a literal check.
16:08:30 <dmwit> tvynr: Yes, exactly.
16:08:30 <tvynr> dmwit: Fascinating.  Many thanks to you; this has been terrifically helpful.
16:08:34 <aufwind> mauke: Because I think I have not completed the exercise if I don't manage the case of passing an empty list to the function prod. Somehow I should "define" this case, shouldn't I?
16:08:45 <mauke> aufwind: YOU DID
16:08:55 <mauke> aufwind: YOU ARE DONE. YOUR CODE WORKS
16:09:26 <rzys> beginner question: is it possible to pattern match against IO? I have some function which returns IO (errorcode, String), is it possible to throw away this errorcode and just return IO String?
16:09:46 <aufwind> mauke: Well, thanks. :-)
16:09:54 <dmwit> rzys: Lots of ways to do it, here's a sampling.
16:09:54 <alkabetz> rzys: Sure, but what you really want is fmap snd.
16:09:55 <dmwit> fmap snd
16:09:58 <mauke> rzys: yes, but not with pattern matching against IO
16:10:02 <aufwind> mauke: Didn't meant to upset you.
16:10:06 <dmwit> do { (error, string) <- foo; return string }
16:10:17 <dmwit> do { x <- foo; return (snd x) }
16:10:21 <mauke> aufwind: well, then stop ignoring the answers you're getting
16:10:23 <dmwit> foo >>= return . snd
16:10:31 <dmwit> snd <$> foo
16:10:58 <rzys> awesome! i think im going with foo >>= return . snd :)
16:11:03 <tvynr> dmwit, rzys: The last one is my favorite.  :-P
16:11:19 <copumpkin> rzys: that's fmap snd foo
16:11:29 <dmwit> copumpkin: read better
16:11:56 * copumpkin reads better
16:12:55 <rzys> hmm, i have to hoohle <$> real quick. maybe im going with that on instead :)
16:13:04 <rzys> hoogle
16:13:15 <aufwind> mauke: Maybe I haven't phrased my question precisely, but I have certainly not ignored any answer. To me it would be more accurate, if I would have been able to define prod [ ]  = 0, instead of 1 but I don't see a way how. That's all.
16:13:28 <aufwind> mauke: But again, thanks for your help so far.
16:13:37 <aristid> @hoogle <$>
16:13:37 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
16:13:37 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:13:41 <copumpkin> aufwind: but 1 is the identity for multiplication
16:13:42 <mauke> aufwind: <monochrom> my http://www.vex.net/~trebla/homework/empty.html explains why prod [] should be 1
16:14:01 <DrSyzygy> aufwind: you don't want to define an empty product to be 0 -- no product would ever be non-zero...
16:14:17 <mauke> aufwind: <aufwind> mauke: This way prod [] (empty list) is evaluated to 1 too which is wrong.  <mauke> aufwind: no, it isn't
16:14:18 <copumpkin> you could have a special case for [x] = x
16:14:19 <copumpkin> but that sucks
16:14:20 <rzys> @hoogle fmap
16:14:20 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:14:20 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
16:14:20 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:14:40 <rzys> so is <$> the same as fmap in infix notation?
16:14:44 <copumpkin> yeah
16:14:46 <aristid> yes.
16:15:09 <aufwind> copumpkin: That is a convince argument, thanks. Apologize @ mauke. :-)
16:15:17 <aufwind> convincing, I meant.
16:20:28 <rubenz> where can I find a matrix library that permits entries to be rationals?
16:20:38 <hpc> hmatrix
16:20:44 <hpc> probably
16:21:11 <dmwit> Isn't hmatrix bindings to LAPACK?
16:21:13 <hpc> (in theory, it's as polymorphic as [], but i haven't looked at the whole package)
16:21:24 <dmwit> I'd be very surprised if LAPACK knew what to do with Rationals...
16:21:41 <hpc> http://hackage.haskell.org/packages/archive/hmatrix/0.14.0.1/doc/html/Data-Packed-Matrix.html
16:21:47 <hpc> oh, it uses Storable
16:51:34 <spacebark> does anyone know if there is a good way to do a web search and retrieve the results in haskell?
16:52:03 <Clint> what do you mean by "web search"
16:52:11 <spacebark> like google
16:52:39 <spacebark> like search a term and get a list of URLs and possibly the short blurbs that come with them
16:54:20 <Clint> if google doesn't have an api for that you could parse the html with tagsoup
16:54:38 <twomashi> I'd look for a command line interface to google and go from there
16:58:58 <spacebark> twomashi: good tip with the command line interface. I found one that looks really nice
17:19:08 <nyingen_> @quote
17:19:08 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:19:16 <otters> haha
17:19:22 <otters> scala could do it
17:19:24 <otters> /s
17:20:23 <aristid> otters: oleg can do it in haskell
17:20:31 <aristid> @quote prolog
17:20:31 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
17:20:39 <aristid> @quote oleg.*prolog
17:20:40 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
17:20:42 <otters> eulers?
17:20:54 <aristid> the first quote was the wrong one
17:21:05 <nyingen_> perhaps that refers to Project Euler
17:21:12 <otters> I see
17:32:14 <tsou> i recently read on some website about soing some calculations with nats defining their values on the type level..
17:32:24 <tsou> It had two links on two papers..
17:32:28 <tsou> does it ring any bells to anyone?
17:34:04 <tsou> ah, just remembered a "keyword", found it.. thanks anyway :)
17:36:09 <Eduard_Munteanu> tsou: Peano?
17:44:06 <frontendloader> can you monkey patch haskell?
17:44:28 <frontendloader> not haskell itself obv, but you understand me right?
17:44:46 <ion> Please provide an example of a use case.
17:44:55 <copumpkin> frontendloader: no, I don't really understand you :P
17:45:14 <copumpkin> if you're talking about opening a ruby class and adding stuff later, I'm not even sure what the corresponding operation would be in haskell
17:45:24 <copumpkin> so you'll have to elaborate a bit
17:45:43 <copumpkin> possibly creating new typeclasses and instances for existing types?
17:45:44 <JoeyA> I think "monkey patch" means update a running instance of a program with new code.
17:46:24 <frontendloader> that. Load/unload some kind of plugin in a running instance of a parent program.
17:46:32 <kallisti> sure just overwrite the bytes at runtime.
17:46:35 <copumpkin> @hackage hint
17:46:35 <lambdabot> http://hackage.haskell.org/package/hint
17:46:45 <kallisti> @hackage plugins
17:46:45 <lambdabot> http://hackage.haskell.org/package/plugins
17:46:45 <ion> Loading plugins is monkey patching?
17:46:55 <frontendloader> it can be a kind of monkey patching
17:46:57 <copumpkin> we can load plugins just fine
17:47:09 <frontendloader> if you're updating the version of a plugin while the parent program is alive
17:47:09 <copumpkin> the difference is what we allow them to do, I guess
17:47:20 <ion> olegych: Are you *the* Oleg? :-)
17:47:44 <OlegYch> nope, sorry
17:50:59 <quirck> hey
17:51:07 <quirck> i got a problem with instance
17:51:11 <quirck> http://pastebin.com/bYTxxcsM
17:51:13 <mauke> The paste bYTxxcsM has been copied to http://hpaste.org/67470
17:51:31 <quirck> i have no idea how should i add new instance to this class
17:51:45 <quirck> i don't wanna change the class structure
17:51:57 <quirck> is it possible to add new instance without changing the type of class?
17:52:24 <quirck> i get haskell error: ilegal instance declaration
17:52:43 <AtnNn> you can put the superclass in front of the class: instance Num a => Monoid a where
17:53:28 <quirck> the same error
17:53:34 <quirck> instance Num a => Monoid a where
17:53:58 <geekosaur> you need to indent the member functions too
17:54:43 <quirck> what do you mean?
17:56:14 <quirck> hmm, looks like instance Monoid Integer where
17:56:17 <quirck> works pretty good
17:57:58 <AtnNn> quirck: that instance declaration isn't valid in standard haskell because it conflicts with every other instance
17:58:24 <AtnNn> if it's really what you want, you can use the FlexibleInstances extension
17:58:54 <quirck> AtnNn, so how should i code it?
18:00:23 <AtnNn> you can make an isntance for the specific types (such as Integer)
18:01:05 <quirck> could you please show me any example of that?
18:01:26 <AtnNn> you said you just did.. did you?
18:02:11 <quirck> but you said, it's not valid
18:02:16 <quirck> as far as i understood
18:03:07 <AtnNn> sorry, your instance for Integer is valid, not your isntance for a
18:03:22 <quirck> ok :)
18:05:43 <AtnNn> also, if you want to explore, there is a Moniod class in Data.Monoid with (***) = mappend and e = mempty. if you look at the source, it has instances for Num a using newtype wrappers
18:06:49 <quirck> where can i find haskell sourcesodes?
18:10:15 <AtnNn> quirck: on hackage. you can search hackage using hayoo
18:10:23 <quirck> ok, thx :)
18:16:15 <quirck> hmm, i coded something like that: class Monoid a where (***) :: a -> a -> a e :: a
18:16:19 <quirck> infixl 6 ***
18:16:21 <quirck> instance Monoid Integer where e = 1 a *** b = a * b
18:16:24 <quirck> infixr 7 ^^^
18:16:26 <quirck> (^^^) :: Monoid a => a -> Integer -> a
18:16:29 <quirck> a ^^^ 0 = e
18:16:31 <quirck> a ^^^ n
18:16:34 <quirck>     | odd n     = a *** a_exp *** a_exp
18:16:36 <quirck>     | otherwise = a_exp *** a_exp
18:16:39 <quirck>     where a_exp = a ^^^ ( n `div` 2 )
18:16:41 <quirck> damn
18:16:44 <quirck> http://pastebin.com/5ZejfX1H
18:16:46 <mauke> The paste 5ZejfX1H has been copied to http://hpaste.org/67471
18:17:07 <quirck> how can i easly extend this instance to modular calculations?
18:17:32 <quirck> i mean, that i always wanna calculate a ^^^ b as a^b mod constant
18:18:41 <quirck> adding `mod` doesn't work
18:19:07 <monochrom> newtype Mod7 = M7 Int; instance Monoid Mod7 where { e = M7 1; (M7 x)***(M7 y) = M7 ((x * y) `rem` 7) }
18:19:21 <monochrom> that does modulo-7 multiplication
18:20:24 <monochrom> if the modulus is unknown upfront, that's harder, but other people know how
18:20:39 <quirck> hmm, pretty tricky :)
18:21:30 <monochrom> but they all involve a "data" or "newtype"
18:22:22 <AtnNn> if you add an Integral a constraint to (^^^), you can add `mod` constant after the calls to (***)
18:22:58 <quirck> i did change a *** b = a * b into a *** b = (a * b) `mod` constant
18:29:42 <christo_m> hi, im trying to write a function replace, that takes an alpha list, an index, and an alpha element to replace in the list, something like fun replace x i c
18:29:49 <christo_m> im trying to think about how i would write this with pattern matching and recursion
18:30:07 <christo_m> guidance?
18:32:00 <monochrom> replace (x:xs) 0 c = ?
18:32:21 <monochrom> replace xs n c = ?  (if n is not 0)
18:32:58 <monochrom> an error case: replace [] n c = ?
18:33:03 <christo_m> right i have those cases
18:33:07 <christo_m> but i dont know what to do for the last one
18:33:12 <christo_m> i cant amke it [], because then itll be alpha list list
18:33:18 <christo_m> what do i do when im at the end?
18:33:31 <monochrom> replace [x,y] 40 z = ?
18:33:33 <kallisti> would heap profiling go under "tests" or "benchmarks"?
18:33:38 <christo_m> i basically want to call replace recursively, decrimenting the index
18:34:37 <monochrom> ok, replace [x0, x1] 1 c = x0 : replace [x1] 0 c
18:37:32 <christo_m> haha monochrom sorry, im doing this in mosml
18:37:37 <christo_m> syntax should be similar tho
18:38:08 <byorgey> christo_m: you can't do anything in the last case, you just have to throw an error of some sort.
18:38:26 <christo_m> well, in the case that i > length of my list
18:38:30 <christo_m> you're saying error?
18:38:32 <christo_m> ya that makes sense.
18:38:36 <byorgey> what else can you do?
18:38:40 <christo_m> you're right.
18:38:45 <byorgey> you have to return something of type alpha but you don't have any.
18:39:13 <byorgey> it's like if someone is demanding cake and you don't have any cake.  the only thing you can do is run away screaming.
18:39:38 <byorgey> I suppose the screaming is not strictly necessary but it is entertaining.
18:40:13 <christo_m> hahah
18:40:16 <christo_m> good stuff
18:40:17 <christo_m> i like cake.
18:40:27 <christo_m> not too much though, its heavy, rich.
19:01:10 <stepkut> I noticed that for the monads in transformers, the Applicative and Alternative instances are defined in terms of the Monad and MonadPlus instances (aka, pure = return, (<*>) = ap, etc). But, it seems like it should be the other way around. Is that purely because Applicative came long after Monad, and so the mtl/transformers library already had the Monad/MonadPlus instances.. or is there some other advantage as well?
19:01:58 <liyang> Applicative came after.
19:02:05 <stepkut> liyang: right
19:02:25 <stepkut> liyang: but is that *only* reason..
19:02:44 <glguy> It makes sense to implement the Monad instance once and then derive all the rest from that
19:02:53 <liyang> There are many alternative typeclass hierarchies on Hackage that attempt to do it right, but they're not widely used.
19:02:57 <glguy> since those things are all monads, anyway
19:03:22 <stepkut> glguy: oh right.. because while you can do (<*>) = ap, going from <*> to >>= is not as straight-forward
19:03:44 * stepkut would have figured this out in about 5 minutes when he tried to implement Monad in terms of Applicative
19:03:57 <liyang> I don't think you can go from <*> to >>=.
19:04:04 <stepkut> liyang: exactly
19:04:49 * stepkut is trying to implement a version of StateT that tracks if you actually 'put' anything or not
19:05:29 <glguy> at the type level?
19:07:05 <dibblego> I expect it is because Applicative f => Applicative (StateT s f) is not possible
19:08:34 <byorgey> stepkut: sounds possible
19:09:04 <byorgey> the difficulty is with (>>=), you need a simple type function to combine the annotations
19:09:09 <stepkut> byorgey: yeah, it is mostly a mechanical transformation of StateT with a data Cleanliness a = Clean a | Dirty a, wrapper
19:09:13 <byorgey> basically type-level ||
19:09:33 <mm_freak> stepkut: do you want to be able to ask the question /before/ running a StateT computation?
19:09:40 <stepkut> mm_freak: nope
19:09:59 <stepkut> mm_freak: I'd use Agda for that :p
19:10:10 <mm_freak> i'd use an arrow for that =)
19:10:13 <byorgey> oh, so you only want to *record* whether or not 'put' ever gets called?
19:10:14 <stepkut> mm_freak: just need to check if a cookie needs to be updated or not
19:10:24 <stepkut> mm_freak: which I can wait till runtime to do
19:10:28 <stepkut> byorgey: yup
19:10:44 <mm_freak> stepkut: that's not what i mean…  i mean at run-time, but /before/ running the computation
19:10:57 <byorgey> stepkut: so you're wrapping just the state in Cleanliness? or the entire StateT?
19:11:07 <mm_freak> i.e. "is putting part of the computation?"
19:11:20 <mm_freak> that's an arrow
19:11:43 <mm_freak> "has putting happened?"…  that's still a monad
19:11:48 <stepkut> mm_freak: no.. when I do the equavilent of runStateT I want to get back a bool that indicates if 'put' was called or not
19:12:28 <byorgey> I guess you could track it statically with an indexed monad
19:13:04 <byorgey> stepkut: anyway, your approach sounds just fine for what you want to accomplish
19:13:11 <mm_freak> byorgey: with a monad you can't really do that
19:14:04 <stepkut> byorgey: right, but it is overkill for what I need.. I need 'easy to use' as well :p
19:14:04 <Eduard_Munteanu> Well, you can track some hidden state.
19:14:56 <Eduard_Munteanu> And have 'put' mess with it.
19:15:08 <stepkut> Eduard_Munteanu: yup
19:16:25 <stepkut> newtype MyStateT s m a = MyStateT { runMyStateT :: s -> Bool -> m (s, Bool, a) }
19:16:30 <stepkut> and then a bucketload of instances
19:16:47 <stepkut> mostly copy and paste
19:16:55 <stepkut> with some tweaking for the extra Bool
19:16:56 <mm_freak> stepkut: you don't need the Bool argument
19:17:04 * Eduard_Munteanu was wondering about that
19:17:06 <stepkut> mm_freak: oh ?
19:17:15 * AlbireoX`Away is away: Gone away for now
19:17:42 <mm_freak> stepkut: tracking is no state, it's a writer
19:18:19 <stepkut> mm_freak: yeah.. I had considered that
19:18:40 <stepkut> mm_freak: in this case I also allow deletion...
19:19:25 <mm_freak> stepkut: what do you mean?  a computation being able to lie about what happened earlier?
19:20:04 <stepkut> mm_freak: I'll paste it when I am done.. assuming I don't run into issues :)
19:20:48 <stepkut> I am thinking deletion might not quite work
19:21:06 <stepkut> though, really it is just setting an expiration flag.. in which case the writer would work :-/
19:22:13 <mm_freak> stepkut: just to be clear, just leave out the Bool argument…  don't use a writer ;)
19:22:24 * hackagebot global-config 0.2.0 - Global mutable configuration  http://hackage.haskell.org/package/global-config-0.2.0 (AlexanderDorofeev)
19:22:25 <mm_freak> i mean, don't use Writer =)
19:22:40 <stepkut> mm_freak: ?
19:23:14 <stepkut> oh..
19:23:17 <stepkut> I see
19:23:33 <mm_freak> newtype StateT s m a = MyStateT { runMyStateT :: s -> m (a, Bool, s) }
19:23:35 <stepkut> I don't need to know what the old Bool was, because I am only going to set it not read it
19:24:23 <mm_freak> you are going to read
19:24:32 <stepkut> so, I was thinking of doing something a bit like, newtype StateT s m a = MyStateT { runMyStateT :: s -> m (a, Bool, Maybe s) }, so that you could 'delet' the state value... but then I am not sure how I would implement 'get' from MonadState
19:24:34 <mm_freak> but not 'the last'
19:24:46 <mm_freak> you are going to signal, read and combine
19:24:52 <stepkut> yeah
19:24:57 <mm_freak> a computation signals and for example <*> combines
19:25:36 <mm_freak> stepkut: get :: StateT s m (Maybe s)
19:25:54 <mm_freak> but obviously that's really just an ad hoc monad for:  StateT (Maybe s) m a
19:27:25 * hackagebot wai-middleware-cache 0.3.3 - Caching middleware for WAI.  http://hackage.haskell.org/package/wai-middleware-cache-0.3.3 (AlexanderDorofeev)
19:28:10 <stepkut> mm_freak: for that to work, I need to make sure my writer is a Monoid
19:28:46 <mm_freak> stepkut: your writer writes a Bool, which is a monoid
19:28:59 <stepkut> mm_freak: well, the real code is, data SessionState = Encoded | Decoded | Modified | Expired
19:29:11 <stepkut> mm_freak: which, may be a monoid.. if I can figure out what the zero is
19:29:59 <mm_freak> stepkut: add a NoChange constructor, then it's a monoid
19:30:33 <luite> data Bool = True | False | NoChange
19:30:35 <stepkut> mm_freak: yeah.. I added Unknown, but NoChange is better :)
19:32:04 <luite> I like the Eq constraint better anyway :p
19:32:09 <stepkut> in Haskell, a Monoid is associative but not commutative?
19:32:25 <mm_freak> stepkut: correct
19:32:26 <luite> in general commutativity is not required
19:33:17 <mm_freak> stepkut: only the group-theoretic properties of a monoid are assumed
19:34:04 <stepkut> Encoded and NoChange might actually be the same thing
19:34:18 <stepkut> hmm, no, not quite
19:35:02 <stepkut> neither Encoded nor Decoded imply any changes to the state itself.. but it does matter internally because it indicates if certain work has been done or not
19:36:05 <luite> Decoded implies not expired right? Encoded doesn't?
19:36:06 <vyom> anyone know of a library that will help me generate trigrams from a body of text?
19:36:13 <stepkut> maybe those things don't belong in the same type though
19:36:31 <stepkut> I think that is the real problem.. one type is trying to track two different things
19:37:12 <luite> i think it's all a bit too complex, decrypting is really a minor overhead
19:38:00 <stepkut> luite: you think the cookie should be decrypted everytime even if the value is never used ?
19:38:52 <luite> stepkut: i think it wouldn't be a problem at least
19:39:21 <luite> you can decrypt aes faster than any network connection can send you cookies
19:39:52 <stepkut> luite: so ? why decrypt them if you don't need them ?
19:39:54 <luite> perhaps not quite true anymore with the hmac authentication
19:40:46 <luite> stepkut: to keep the code simpler and perhaps more general
19:40:58 <stepkut> luite: it should be invisible to the outside user..
19:41:23 <mm_freak> stepkut: isn't a field of booleans more like what you want?
19:41:34 <luite> stepkut: even those that want to implement some other session storage backend?
19:41:53 <stepkut> mm_freak: perhaps
19:42:21 <stepkut> luite: dunno yet
19:44:06 <luite> with yesod the choice was easy, the session data is read anyway because it is used to store some settings that override request headers, like accept-lang
19:48:33 <tehgeekmeister> ran into some weird behavior with enumerator based io doing a lot of seemingly unnecessary syscalls.  more info at the link, if anyone can chat about it a bit now.  http://stackoverflow.com/questions/10273696/why-does-haskell-enumerator-based-io-call-sigprocmask-so-often
19:50:24 <tgeeky> tehgeekmeister: why do you think they are unnecessary?
19:50:27 <tgeeky> tehgeekmeister: are they taking a long time?
19:51:10 <tehgeekmeister> tgeeky: well, i actually *know* they aren't necessary, as the same program runs fine in perl without making the same syscalls.  it may be more correct with them, though.  *shrug*
19:51:41 <tehgeekmeister> and yes, they're taking up most of the time in the script, blocking the program from doing the IO i actually asked for.
19:51:58 <tehgeekmeister> each one is fast, but there are *so* many of them.
19:53:57 <jeff_s_> Is there a better way to get the Integer value of NominalDiffTime? fromEnum is almost right, but it produces different result for 32 and 64 bit machines.
19:54:53 <tgeeky> tehgeekmeister: you didn't include exactly how you invoked the haskell file. Are you using runhaskell?
19:56:14 <parcs`> jeff_s_: round . realToFrac?
19:57:34 <mm_freak> jeff_s_: i'd answer, "don't do it", but why exactly do you need that?
19:58:44 <jeff_s_> parcs` - that looks pretty good. I'll check it.
19:59:01 <tgeeky> tehgeekmeister: I don't actually think I can help. That does look a little strange. If you don't get an answer in here, you might try #ghc. They are a little closer to syscalls than #haskell will be.
19:59:06 <jeff_s_> mm_freak - I need a time value to use as the source of a time-sensitive key.
19:59:24 <tehgeekmeister> tgeeky: no, compiling and running the binary
19:59:29 <jeff_s_> So I wan to go from POSIXTime or UTCTime to bytestring, for use with hashing.
19:59:37 <tgeeky> tehgeekmeister: did you use optimization flags like -O2?
19:59:58 <tehgeekmeister> hmm, i may have.  compiled it quite some time ago.
20:00:06 <tehgeekmeister> just had the idea to trace it recently
20:00:52 <tgeeky> tehgeekmeister: the strange thing, is that syscall is clearly related to IPC/thread flags, but I only see one thread of execution there.
20:01:14 <parcs`> jeff_s_: or numerator . toRational
20:01:40 <mm_freak> parcs`: no!
20:01:58 <mm_freak> Rational is auto-normalizing
20:02:26 <tehgeekmeister> tgeeky: oh, is it related to that?  how'd you determine that?
20:02:32 <parcs`> mm_freak: so what
20:03:01 <mm_freak> parcs`: so 3/10 and 6/10 have the same numerator
20:03:37 <tgeeky> tehgeekmeister: well, I guessed. I guessed that 55333 might be the pid, but if you look at the arguments to sigprocmask, the 2nd field is 0x________8 or C.
20:04:32 <tehgeekmeister> tgeeky: yes, that's true.  also 0x{1,3} correspond to the 8 and c instances.  hmm.
20:04:58 <tgeeky> tehgeekmeister: well, whatever those addresses are, they are probably the same chunk of alloated memory. maybe not.
20:05:06 <parcs`> what about numerator . (1e6 *) . toRational
20:05:41 <mm_freak> parcs`: same problem
20:05:45 <mm_freak> you need 1e12
20:05:53 <tgeeky> tehgeekmeister: try out the various RTS options: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
20:05:58 <tehgeekmeister> tgeeky: oh, interesting.  there's an order of magnitude more sigprocmask calls than read calls.  (there's a summary at the bottom of the trace, didn't think to include it.)
20:06:22 <mm_freak> anyway, i'd prefer realToFrac
20:06:23 <tgeeky> tehgeekmeister: yeah. that's bad. it's not the individual calls that are doing this, or even the blocking (probably)
20:06:39 <mm_freak> round . (* 10^12) . realToFrac
20:06:56 <mm_freak> if you need that precision anyway
20:07:54 * geekosaur wonders if this is in any way related to the performance issues in xmonad that are fixed by +RTS -V0 (7.4.1-specific)
20:08:02 <parcs`> > 12 * (log 10 / log 2)
20:08:02 <lambdabot>   39.863137138648355
20:08:10 <tgeeky> tehgeekmeister: try those flags: RTS -V0
20:08:26 <tgeeky> tehgeekmeister: though perhaps you aren't using GHC 7.4.1
20:08:35 <parcs`> are Double guaranteed to be 64 bit?
20:08:41 <parcs`> at least, anyway
20:09:05 <tgeeky> parcs`: yes, IEEE is
20:09:12 <tgeeky> parcs`: IEEE doubles
20:09:44 <parcs`> okay
20:10:40 <tehgeekmeister> tgeeky: i'm on some old ghc, don't know which.  *checking
20:10:59 <geekosaur> ok, that won't be related then
20:11:05 <tehgeekmeister> 7.0.4
20:11:32 <tehgeekmeister> i did --install-signal-handlers=no, and that got rid of the sigprocmask, as you might expect.
20:12:18 <tehgeekmeister> it still does select and sigreturn calls that the perl version doesn't, which is interesting, but it's just one of those per read, as opposed to multiple
20:12:22 <tehgeekmeister> so not as painful
20:19:27 <Guest50745> i am trying to understand how lyingsearch in http://lukepalmer.wordpress.com/2010/11/17/searchable-data-types/ works. seems to defy logic
20:20:18 <mauke> after a long and hard fight, we've managed to defeat logic
20:20:32 <mauke> finally our programs can be free
20:21:25 <geekosaur> tehgeekmeister, I'm still spelunking but so far the major caller of the sigprocmask stuff in the RTS is GC
20:22:19 <geekosaur> secondary is the TTY driver, but it would surprise me if that's making enough calls to be noticeable
20:22:20 <tehgeekmeister> geekosaur: when i add --install-signal-handlers=no, it doesn't do any calls to sigprocmask.  the remaining issue is the calls to select (which are understandable, but not performant).
20:22:37 <geekosaur> yes, if you disable signal handlers the whole thing is stubbed out
20:23:01 <geekosaur> select() is inevitable, I'm afraid
20:23:32 <geekosaur> perl is not threaded in any meaningful sense, and does not have an event loop architecture
20:23:42 <geekosaur> ghc's runtime is both threaded and based around n event loop
20:23:46 <tehgeekmeister> well, the perl version doesn't do those select() calls.  that may be bad, for some reason, but it doesn't do them.
20:23:50 <geekosaur> aand event loop means select() calls
20:23:53 <tehgeekmeister> ah, so it's just how ghc works.
20:23:56 <geekosaur> yes
20:24:21 <geekosaur> (Perl will do select calls if you use something that does an event loop, like POE or one of the GUI libraries)
20:24:37 <tehgeekmeister> well, i guess i can compare the two versions again, now, with the signal handlers disabled, and see if that makes much of a difference
20:25:45 <geekosaur> I think you want to profile, though; if what I am seeing s correct, the *real* problem is that you are GCing a whole lot
20:25:57 <geekosaur> because sigprocmask() is only invoked from the garbage collector
20:26:04 <tehgeekmeister> (i'd like to use haskell for some more of this sort of work, you see, but the io performance of this test some months back was bad enough i gave up.)
20:26:11 <tehgeekmeister> which profiler options would i use to check that?
20:26:17 <tehgeekmeister> i'm happy to run it with the profiler right away.
20:26:57 <tehgeekmeister> yeah, it still has miserable performance even without the signal handlers.  i'd guess you're probably right.
20:27:27 <geekosaur> I belibe the basic profiler option will give you information about GC
20:28:38 <tehgeekmeister> yeah, it's cpu bound, so that makes sense.  about to run with profiling.
20:29:39 <applicative> Guest50745: yes, it's wonderful; did you read the post by M. Escardo he mentions?
20:30:16 <liyang> jeff_s_: nothing wrong with a bit of unsafeCoerce... a NominalDiffTime is a newtype of a Fixed which in turn is a newtype of an Integer.
20:30:17 <Guest50745> i figured if i couldnt understand the simple case i would be completely lost
20:30:34 <jeff_s_> liyang - thanks! I'll try that.
20:31:19 <Guest50745> the article seems to suggest that the computations go to infinity and that is somehow bounded???
20:32:09 <glguy> Guest50745: it says that the predicates must be total
20:32:32 <glguy> In the definition of search' it says "search' f | f possibleMatch = Just possibleMatch | otherwise = Nothing"
20:32:47 <glguy> f must be total, so you can see that this definition is going to return
20:33:36 <Guest50745> but if we have x*x==15 as in the example, how does it know when to stop checking for a solution?
20:34:04 <glguy> Guest50745: once it tries and fails to test 15 it tries 15+...
20:34:13 <glguy> err, not 15, specifically
20:34:34 <mauke> Guest50745: the part that stops is ==
20:34:36 <glguy> but once the argument it returns gets sufficiently large it will show that x*x > 15
20:34:39 <glguy> and return
20:34:47 <mauke> but there is no > here
20:34:59 <tehgeekmeister> geekosaur: 90mb of allocation for .5mb of input
20:35:00 <glguy> == is defined by peeling off Succs
20:35:07 <tehgeekmeister> that seems a little excessive
20:35:10 <liyang> Is it obvious that Succ (Succ …) /= Succ Zero ? Where … needn't actually be evaluated.
20:35:20 <mauke> laziness is key here
20:36:01 <glguy> predicates that never return true will cause the lyingSearch to return infinity
20:36:30 <glguy> You can't test for infinity with a total function
20:36:32 <Guest50745> how does it know to stop after 16 tries?
20:36:50 <mauke> Guest50745: because it's running ... == 15
20:36:56 <liyang> jeff_s_: Actually there's plenty of things wrong with using unsafeCoerce. But if you're concerned about speed—which seems to be the case if you want a Hashable—then you kind of have to make a judgement call.
20:37:00 <glguy> lyingSearch (\x -> x*x == 15) is "infinity
20:37:15 <liyang> Guest50745: it only computes infinity up to 15.
20:37:18 <mauke> Guest50745: and 15 is a finite number
20:37:20 <glguy> infinity * infinity => infinity
20:37:26 <jeff_s_> liyang - I think I'm going to try to use Data.Time.Clock.CTimeval directly.
20:37:27 <glguy> infinity == 15 => False
20:38:44 <Guest50745> i understand the infinity calculation but am stumped as to how it got to infinity in the first place
20:38:54 <glguy> > repeat () == replicate 15 ()
20:38:55 <lambdabot>   False
20:39:07 <mauke> > let xs = 0 : map (+ 1) xs in xs
20:39:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:39:14 <mauke> Guest50745: ^ do you understand that?
20:39:34 <Guest50745> sure
20:39:35 <glguy> multiplication on Nat is the same as liftM2 (,) on [()]
20:39:53 <glguy> (basically)
20:40:13 <mauke> Guest50745: we're running lyingSearch with a predicate that's always false
20:40:22 <glguy> > let (*) = liftM2 (\ _ _ -> ()) in length (replicate 2 ()) (replicate 4 ())
20:40:23 <lambdabot>   Couldn't match expected type `[()] -> t'
20:40:23 <lambdabot>         against inferred type `GHC...
20:40:27 <glguy> > let (*) = liftM2 (\ _ _ -> ()) in length (replicate 2 ()) * (replicate 4 ())
20:40:28 <lambdabot>   Couldn't match expected type `m a1'
20:40:28 <lambdabot>         against inferred type `GHC.Type...
20:40:37 <mauke> Guest50745: lyingSearch _ = Succ (lyingSearch _)
20:40:37 <tehgeekmeister> geekosaur: grabField does a lot of allocation, which isn't surprising since it calls pack explicitly.  splitOn does more, but that must be somewhere in the implementation of it.
20:40:41 <copumpkin> liftM2 const?
20:40:52 <mauke> Guest50745: = Succ (Succ (Succ (Succ ...)))))
20:41:00 <glguy> > let (*) = liftM2 (\ _ _ -> ()) in length (replicate 2 () * replicate 4 ())
20:41:01 <lambdabot>   8
20:41:15 <tehgeekmeister> geekosaur: err, i mean, the implementation of one of the functions i'm calling, prolly splitwhen
20:41:16 <glguy> copumpkin: or that :)
20:41:27 <geekosaur> tehgeekmeister, I'm afraid I'm not so helpful when it comes to enumerator :/
20:41:42 <jeff_s_> liyang - by things wrong with unsafeCoerce, do you mean things other than what could happen if the implementation of NominalDiffTime changes?
20:42:08 <geekosaur> I know a little about the GHC RTS and POSIX signal and I/O foo, is why I started poking.  this is sounding like issues in enumerator to me, now
20:42:16 <glguy> > let (*) = liftM2 (\ _ _ -> ()); infinity = repeat () in (infinity * infinity) == replicate 15 ()
20:42:17 <lambdabot>   False
20:42:57 <tehgeekmeister> yeah, i think it's a problem in enumerator, too.  unfortunately, it's a little beyond my level, too, so I don't think i'll be tracing it down and fixing it, which is what I'd wanted to do.
20:43:00 <tehgeekmeister> other priorities.
20:44:54 <geekosaur> maybe look at one of the alternatives, like pipes?
20:45:15 <tehgeekmeister> right, i remember, i found this last time.  it converts from lazy to strict text on every chunk, after it concatenates all the chunks.
20:45:26 <Guest50745> we dont know the predicate is always false until each possibility is checked out : 0*0 1*1 ... n*n
20:45:40 <tehgeekmeister> pipes?  haven't heard of those yet.  i'll take a look.
20:45:45 <mauke> Guest50745: yes, we do
20:45:54 <Eduard_Munteanu> Guest50745: depends what the predicate is
20:45:55 <mauke> Guest50745: we can look at it and see that it will never work
20:46:06 <mauke> Eduard_Munteanu: acquire context
20:46:37 <Eduard_Munteanu> mauke: yeah, I kinda know the context... Luke Palmer's blog post.
20:46:52 <mauke> hmm
20:46:54 <Eduard_Munteanu> Didn't go through the whole scrollback though.
20:47:14 <mauke> ok, in my context "the predicate" refers to \x -> x*x == 15
20:47:31 <glguy> Guest50745: you need to focus on the fact that the predicate must be total
20:47:43 <glguy> Guest50745: (x -> x == x) wouldn't cut it, for example
20:47:45 <mauke> or you can just evaluate it step by step
20:47:54 <liyang> jeff_s_: mostly that. And the finding a way to live with yourself after you realise what you've done that comes afterwards.
20:48:16 <tehgeekmeister> ah, just another implementation of enumerators.  i'll give it a try soon.
20:48:23 <Eduard_Munteanu> It helps to define (==) yourself for that one.
20:50:01 <mauke> I'd say the key point is that lyingSearch never actually "returns"
20:50:22 <mauke> it keeps building an infinite result piece by piece
20:50:37 <mauke> but because of lazy evaluation that's perfectly ok and you can inspect the outer layers immediately
20:50:46 <Eduard_Munteanu> Yeah, or rather that nothing must return or finish, the computation can go on without something finishing.
20:51:24 <tgeeky> geekosaur: because sigprocmask() is only invoked from the garbage collector
20:51:30 <tgeeky> that's the kind of thing I was trying to figure not
20:52:00 <Guest50745> so how is x*x==16 different from x*x==15
20:52:17 <mauke> x*x==16 is true for 4
20:52:27 * hackagebot global-config 0.2.1 - Global mutable configuration  http://hackage.haskell.org/package/global-config-0.2.1 (AlexanderDorofeev)
20:52:43 <glguy> lyingSearch returned 4 when 4 passed the predicate
20:52:50 <glguy> "returned" :)
20:53:20 <glguy> Every total predicate either returns True for some finite number, or it always returns false
20:53:44 <Eduard_Munteanu> Better said, it got to the part where it produced S (S (S (S *thunk* :)
20:53:57 <geekosaur> lyingSearch just kept going, lazily, but the caller search' can tell when it's impossible for it to match (as soon as the expression is greater than the target) and can terminate with failure without inspecting any more of the lazy infinity
20:54:30 <Guest50745> ok so x > 15 so it says no point going on?
20:54:46 <mauke> well, that's what == ends up doing
20:55:06 <Guest50745> i guess that is where I am confused: how does == do that
20:55:07 <mauke> it reaches a point where one argument is Zero and the other is Succ ...
20:55:17 <glguy> Guest50745: do you understand how this can be true?
20:55:23 <glguy> > repeat () == replicate 15 ()
20:55:24 <lambdabot>   False
20:55:28 <Guest50745> ok that makes sense
20:55:32 <glguy> even though repeat makes an infinite list
20:55:48 <mauke> Guest50745: (==) is defined as: Zero == Zero = True; Succ x == Succ y = x == y; _ == _ = False
20:57:09 <applicative> Guest50745: try it with x*x==2 ; it realizes the number it is dealing with is Succ(Succ(Succ(something))), which cant match Succ(Succ Zero))
20:58:01 <Guest50745> that makes sense now. Thanks. i was hitting my head against a wall
20:58:27 <mauke> Head (Head (Head Wall))
20:58:46 <Eduard_Munteanu> Wall<-Head Normal Form :P
21:02:24 <applicative> Guest50745: it is pretty strange; I remember bafflement at the Escardo post was one of the things that got me trapped studying Haskell...
21:03:44 <wli> I'm glad I'm not trapped. Going back to C most of the time works for me.
21:04:15 <Guest50745> i am going to wait a couple of days before i try to tackle that one. but this stuff is awesome
21:04:39 <tsou> Eduard_Munteanu: no, "factorial", just remembered that the author, as an example had defined factorial on nats on the type level..
21:04:53 <tsou> Eduard_Munteanu: so it made looking for it easy: http://mvanier.livejournal.com/3820.html
21:05:02 <Eduard_Munteanu> Ah.
21:07:32 <TSC>  Hello all; I'm trying to "cabal install virthualenv", but I get "global constraint requires installed instance" for base -- I don't see where this global constraint comes from
21:08:09 <Orclev_> last I saw virthualenv hadn't been updated to the latest version of ghc
21:08:21 <TSC> Ah, I see
21:08:25 <Orclev_> which is a shame because I liked it a lot better than cabal-dev
21:08:57 <TSC> Yes, I was hoping to use it with a non-cabalized project, which seems impossible with cabal-dev
21:09:55 <Orclev_> hopefully somebody updates it soon, if I had the time I would do it myself, but I've already got more side projects than I have the time for
21:11:59 <applicative> TSC https://github.com/basvandijk/virthualenv.git has updated dependencies
21:12:37 <TSC> applicative: thanks, I will check it out
21:19:55 <nyingen_> two iteratee-based XML processing libs, not a scrap of documentation
21:24:01 <fragamus> hi guys I was trying to use fst to get the first item of a tuple but there was a problem.  I have three things in my tuple and not two.  Is fst really that limited?
21:24:14 <Orclev_> yes
21:24:24 <fragamus> does it suck or do I
21:24:36 <Orclev_> tuples are special because each number of items is a distinct type
21:24:41 <Eduard_Munteanu> fragamus: fst/snd only work with 2-tuples
21:24:46 <Orclev_> (a,b) isn't the same type as (a,b,c)
21:26:31 <fragamus> so I guess I could make my second item a tuple in itself.   Is that the way we do that?
21:26:46 <Eduard_Munteanu> That's one possible solution.
21:26:47 <TSC> Or you can use (\(a,_,_) -> a)
21:26:48 <Orclev_> > let (a,_,_) = (1,2,3) in a
21:26:49 <lambdabot>   1
21:27:12 <fragamus> it seems funny to let fst dictate the structure of my data
21:27:26 <Orclev_> then don't
21:27:49 <Orclev_> either pick something other than a tuple, or else us pattern matching to pull it apart
21:27:55 <Eduard_Munteanu> Or you could define your own 3-tuple projections. But if you have a larger tuple, you might want to consider making up a record.
21:28:06 <fragamus> yeah
21:28:15 <Orclev_> honestly tuples are convenient for quick and dirty stuff, but it's more descriptive to make your own type
21:28:16 <fragamus> i think that record thingy is more durable
21:28:24 <fragamus> yes
21:28:43 <fragamus> and the code reads less like martian
21:31:02 <Orclev_> I would say in general both tuples and lambdas should be avoided if possible because they're not really descriptive. They're ok once in a while or for quick and dirty stuff, but you should always be skepticle of them
21:32:35 <Saizan> I think lambdas are fine unless they get too big
21:33:10 <Saizan> often there's no point in naming a combinator just to shuffle an argument around
21:33:52 <Orclev_> yeah, in small doses they're fine, but I tend to prefer things like flip if I really need to shuffle the order of things
21:34:48 <Orclev_> likewise a tuple is fine if you just need a quick and dirty way to return some intermediate result inside of a let or where binding for instance, but if they creep into your main data structures that's probably a bad idea
21:34:58 <shachaf> Usually when I see "flip" I think that someone has over-@pl-ed.
21:37:50 <Orclev_> I try to avoid flip if I can as well, I'd rather rewrite the order of the parameters to a function than use flip, but sometimes you can't do that or it isn't worth the time to do it
21:38:10 <liyang> flip runStateT anyone?
21:38:33 <glguy> If you use MonadLib you don't have to do that, the arguments are already the right way around
21:38:50 <liyang> Hmm. Noted for future reference.
21:44:18 <TSC> What about flip map? That could be handy sometimes
21:44:31 <TSC> (if the function is long)
21:44:52 <geekosaur> it's been proposed ("for") but the name is taken
21:45:39 <TSC> What is "for" used for now?
21:46:08 <fragamus> For what is "for" used?
21:46:26 <Orclev_> Traversable according to hoogle
21:46:46 <fragamus> iterate for what
21:48:16 <geekosaur> Traversable is a generalization of "mappable", in a different dimension than Functor is.  for is flip traverse
21:48:25 <geekosaur> where traverse is the generalized map
21:49:09 <geekosaur> this is ... somewhat confusing
22:02:50 <stepkut> I have a monad transformer, newtype FooT st m a = ..., it has a MonadState instance which passes through to the underlying 'm'
22:03:40 <stepkut> but, I also want to provide a function like, viewStateT :: StateT st m a -> FooT st m a, which allows you to run a state function on the 'st' that is stored in FooT itself
22:03:53 <stepkut> but.. I am not really sure what the best name 'viewStateT' is
22:04:36 * liyang would call that liftSomething.
22:04:41 <stepkut> it is a bit like a lens or a view or something..
22:04:50 <stepkut> liyang: hmm
22:06:22 <stepkut> liyang: lift doesn't really have the right feel to me.. the goal is not to lift a StateT into FooT really... but rather to create a temporary environment where you can use MonadState on a portion of FooT that is not normally exposed that way
22:22:33 * hackagebot mighttpd2 2.5.9 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.9 (KazuYamamoto)
22:31:15 <Catnaroek> Hello, stupid n00b question. What happens if in the middle of some computation, my system runs out of available memory?
22:31:40 <Axman6> you'll get a really slow computer, or an exception
22:31:46 <Axman6> or possibly both
22:32:11 <Axman6> i've written apps in haskell that have easily eaten 6GB in less than a minute =)
22:33:36 <Catnaroek> Wow.
22:34:24 <abdulsattar> Has anyone here successfully deployed to Heroku?
22:35:16 <Axman6> abdulsattar: i believe blackdog has
22:35:30 <Axman6> Catnaroek: do you know about virtual memory?
22:36:02 <abdulsattar> blackdog: Have you deployed any app to Heroku?
22:36:26 <Catnaroek> Yeah, RAM + swap partition, visible from processes as if it were all a single memory.
22:36:47 <Catnaroek> By "running out of memory", I meant running out of virtual memory, not just RAM.
22:37:26 <Axman6> swap partitions are so dumb, so limiting >_<
22:37:49 <Orclev_> I disable swap more or less depending on the amount of my memory on the system
22:38:24 <Orclev_> unless I'm on a really low memory system I don't want it to use swap ever, if it needs to, something is leaking memory like mad and needs to be killed
22:38:29 <liyang> Axman6: oh snap!
22:39:30 <Catnaroek> Only now do I see why bottom is necessary.
22:39:50 <Axman6> is bottom necessary?
22:40:14 <Catnaroek> Well, I see no other way to deal with the problem of running out of memory.
22:40:44 <liyang> An exception is fine too.
22:40:45 <Axman6> what does bottom have to do with that?
22:41:27 <Catnaroek> Oh, I thought the value of error "An error." was bottom.
22:41:45 <liyang> Bottom is a bit more abstract than that.
22:42:22 <Axman6> > let x = x in x -- this is also a form of bottom
22:42:26 <lambdabot>   mueval-core: Time limit exceeded
22:42:37 <liyang> Bottom is your computer saying ¯\(°_0)/¯
22:42:40 <Orclev_> yeah, bottom is the return type of a function that never returns
22:42:46 <Saizan> bottom is the denotational semantics of exceptions
22:42:47 <Catnaroek> Oh, so bottom could also be something that fails to terminate.
22:42:51 <Catnaroek> I see.
22:43:05 <Saizan> (but not only)
22:43:34 <Axman6> error is a form of bottom, because it never returns any value, execution just stops where the exception is thrown
22:43:37 <liyang> The way to view it is that bottom is a potential value of (almost) any type.
22:43:39 <Catnaroek> Basically, bottom is anything that fails to work as expected given its type signature, right?
22:43:50 <Axman6> no...
22:43:53 <Catnaroek> Then?
22:44:32 <spacebark> bottom is when there is not enough information to reduce to a value right?
22:44:41 <Axman6> someone correct me if i'm wrong, but it is anything that fails to return a value (and as such, its return value can be anything)
22:44:55 <Orclev_> it's about the halting problem
22:45:55 <Axman6> it can be, but it's not limited to that. error "foo" is a form of bottom, but we know that it will terminate. there are things which we don't know if they will terminate which aren't bottom too
22:46:38 <shachaf> Axman6: What do you mean, "aren't bottom"? If we don't know whether they'll terminate we don't know whether they're _|_.
22:47:53 <Catnaroek> Someone please correct me if I am wrong. The way I see it, bottom is an emergency exit out of the type system.
22:48:32 <Catnaroek> Well, not bottom itself, but things that are forms of bottom.
22:48:50 <shachaf> Not particularly?
22:48:52 <Axman6> shachaf: right, i was thinking of two different things, and merged them while writing =)
22:49:03 <shachaf> I mean, it depends on what "an emergency exit out of the type system" means.
22:49:07 <shachaf> If it means _|_, then yes.
22:49:12 <liyang> Catnaroek: http://en.wikipedia.org/wiki/Mu_(negative)
22:49:33 <shachaf> Mu id = _|_
22:51:15 <liyang> no, 無, not μ.
22:51:34 <Catnaroek> liyang: No idea how I should even interpret that.
22:51:47 <liyang> Catnaroek: that is the correct answer.
22:51:59 <Catnaroek> zomg lolwat
22:52:11 <Catnaroek> Is that bottom?
22:52:30 <blackdog> abdulsattar: yeah
22:52:30 <Orclev_> lol
22:52:34 <shachaf> You're trying too hard to understand _|_.
22:52:57 <Orclev_> that was subtle liyang, took me a second to get it
22:52:58 <blackdog> been a while - it can be a bit of a pain, you have to make sure you build on exactly the same system as heroku has
22:53:12 <abdulsattar> blackdog: I did.
22:53:13 <Catnaroek> I did not even begin getting it.
22:53:19 <abdulsattar> I deployed to Heroku using 10.04
22:53:37 <abdulsattar> But when I deploy to it from Ubuntu 11.10, I get an error
22:53:58 <abdulsattar> blackdog: which version of Ubuntu did you use?
22:54:23 <Orclev_> Catnaroek: it was a bit of a pun. Bottom can't be evaluated, the runtime doesn't know how to interpret it, hence the joke about that being the correct answer
22:54:43 <Catnaroek> Oh.
22:54:45 <liyang> It just means you're asking a question that the program doesn't know how to answer (or cannot answer in a way that makes sense), so it returns _|_.
22:55:11 <shachaf> That's anthropomorphising the program a bit much for my taste.
22:55:22 <Catnaroek> I would say the same, shachaf.
22:56:06 <liyang> You say that now. One day…
22:56:27 <spacebark> i always thought it signified that there was not enough information to determine if it converged to a value
22:56:48 <copumpkin> > let (無) = (無) in 無
22:56:52 <lambdabot>   mueval-core: Time limit exceeded
22:57:21 <copumpkin> muri!
22:57:25 <abdulsattar> blackdog: you there?
22:58:27 <Catnaroek> I am trying to get a definition of bottom I can read without relying on linguistic tricks.
22:58:47 <copumpkin> Catnaroek: nontermination
22:58:58 <Catnaroek> Okay.
22:59:13 <liyang> We tried that before, but e.g. error "foo" does terminate.
22:59:28 <copumpkin> it doesn't observably terminate, from within haskell
22:59:48 <Catnaroek> Non-[termination in a way contemplated by the type of the expression] ?
23:00:07 <copumpkin> > let 無理 = 無理 in 無理
23:00:11 <lambdabot>   mueval-core: Time limit exceeded
23:01:12 <spacebark> termination in the sense of converging to a value
23:01:36 <shachaf> liyang: Not from the perspective of the program.
23:01:45 <shachaf> let x = x in x also terminates, after all.
23:02:17 <Catnaroek> I wondered if it is possible to design and implement a bottom-less language? Of course, this would imply sacrificing Turing-completeness.
23:02:26 <liyang> Catnaroek: yes. Agda.
23:02:37 <spacebark> yes. primitive recursive functions
23:02:46 <shachaf> But don't let pigworker hear you saying that.
23:02:57 <Catnaroek> I know, but... what happens if a process directed by an Agda program runs out of memory?
23:03:06 <shachaf> http://stackoverflow.com/questions/10212660/curry-howard-isomorphism/10212828#comment13132068_10212828
23:03:08 <Orclev_> it would ultimately be a lie though as any sort of IO exception would still be bottom
23:03:16 <shachaf> Catnaroek: What does that have to do with anything?
23:03:24 <shachaf> We're talkin' about semantics here.
23:03:34 <liyang> Orclev_: well, once you're in IO all is lost anyway.
23:04:27 <blackdog> @tell abdulsattar try http://www.yesodweb.com/blog/2011/07/haskell-on-heroku
23:04:27 <lambdabot> Consider it noted.
23:04:57 <Catnaroek> shachaf: Yes, if we used Agda programs to direct processes taking place in actual infinite-memory devices, I could clearly see why Agda would be bottom-less.
23:05:08 <Axman6> Catnaroek: languages usually have infininite memory. it's their implementations which are tied down by the restrictions of the real world
23:05:16 <shachaf> Axman6: Not C*!
23:05:22 <shachaf> * Unless you count files as memory.
23:05:23 <Catnaroek> Oh, I thought languages were just sets of strings.
23:05:40 <Axman6> languages have semantics for their execution as well
23:05:49 <shachaf> C isn't Turing-complete without file I/O.
23:05:56 <Axman6> shachaf: i totally do
23:06:01 <shachaf> It's only arguably TC with file I/O, depending on how you read the spec.
23:10:04 <pqmodn> shachaf: hmm, how does let x = x in x terminate?
23:10:10 <Catnaroek> shachaf: How come C is not Turing-complete without file I/O?
23:10:26 <pqmodn> Catnaroek: http://lemire.me/blog/archives/2011/03/08/breaking-news-htmlcss-is-turing-complete/ see the comments
23:10:33 <shachaf> pqmodn: <<loop>>
23:10:38 <shachaf> pqmodn: Alternatively: When I press ^C
23:10:45 <pqmodn> shachaf: heh, ok
23:10:50 <shachaf> It terminates just as much as error does.
23:11:13 <Catnaroek> pqmodn: Oh!
23:11:15 <Catnaroek> Very nice point.
23:12:15 <Catnaroek> Yes, now I see.
23:12:58 <Catnaroek> Now I see something ironical. C++'s template metaprogramming system *is* Turing-complete. C++ itself is not. Right?
23:13:07 <pqmodn> heh
23:13:27 <shachaf> C++ is TC in the same way that C is, I think.
23:14:16 <pikhq> C is TC iff you have files of infinite length.
23:14:33 <pikhq> Though C++ actually can be TC because of templates, I'm pretty sure.
23:14:33 <Catnaroek> *potentially infinite length
23:14:48 <shachaf> pikhq: And you interpret the spec to say that ftell() is allowed to fail.
23:14:55 <Catnaroek> pikhq: How would you work around the pointer size limitation?
23:15:12 <shachaf> By using a file.
23:15:14 <pikhq> The spec merely sets a minimum bound on template recursion, so.
23:15:27 <Catnaroek> shachaf: I meant, without using files.
23:15:32 <pikhq> You don't.
23:15:41 <Catnaroek> Anyway.
23:15:46 <pikhq> Without files, C describes a FSA.
23:16:28 <shachaf> > 2^64
23:16:29 <lambdabot>   18446744073709551616
23:16:32 <shachaf> That sure is a big number.
23:16:36 <shachaf> hi 2^64
23:16:40 <pqmodn> here, "files" also includes other IO, like sockets?
23:16:50 <shachaf> pqmodn: You just need files.
23:16:55 <pikhq> pqmodn: C doesn't have other IO, anyways.
23:17:07 <pqmodn> oh, that's right
23:17:08 <Catnaroek> s/C/POSIX/
23:17:11 <zenware> Are there any experienced Haskell hackers around, I'm interested in hearing about any fundamental flaws or possible conceptual flaws in functional programming, as well as some possible input on a preferred method of syntax for a functional language.
23:17:12 <shachaf> I don't think you can "store" things in sockets, either.
23:17:25 <pqmodn> shachaf: you can't but the remote end can do the storing
23:17:30 <shachaf> zenware: If you have a concrete question you should just ask it.
23:17:54 <pikhq> pqmodn: So, you could be talking to a inftaped. :)
23:17:58 <shachaf> pqmodn: Yay, so if you add a Turing-machine peripheral to C, it can be Turing-complete?
23:18:05 <pqmodn> shachaf: yes!
23:18:14 <pqmodn> :)
23:18:17 <Catnaroek> :O
23:18:28 <zenware> Not necessarily anything concrete, I'm just wanting to hear about others experiences, preferences, ideas, and general knowledge in regards to functional programming.
23:18:49 <Catnaroek> So C is Turing-complete modulo lack of availability of an infinite storage device.
23:19:19 <shachaf> zenware: My experience with IRC suggests that you're not going to get a useful answer to that.
23:19:29 <pqmodn> you need to be able to address an infinite number of "cells" too
23:19:38 <pikhq> pqmodn: Seeking suffices.
23:19:47 <zenware> Over the past several days I've been looking at Erlang, Haskell, and Clojure, but none of them seemed to work well for me, and it wasn't that my mind doesn't work in a functional manner it's more of...
23:19:52 <pqmodn> pikhq: yeah
23:20:13 <pikhq> zenware: The most you're going to get out of a question like that is "Functional programming is AWESOME!" here, and "Functional programming SUCKS!" in some other channels.
23:20:15 <zenware> I don't like the way things like syntax work in these functional languages, it's not satisfactory.
23:20:32 <Phlogistique> pikhq: but functional programming SUCKS!
23:20:45 <pqmodn> write your own syntax that transpiles to another language
23:20:55 <pikhq> You're really going to want to ask a somewhat more specific question.
23:20:59 <Phlogistique> zenware: try Javascript.
23:21:03 <Catnaroek> zenware: The way I see it, impure functional programming is just imperative programming with weird looping, so if you want to learn actual functional programming, use a pure functional language.
23:21:13 <smop> f$
23:21:15 <smop> f#
23:21:25 <Claudius1aximus> not being able to write instances for partially applied type synonyms is one fundamental limitation i ran up against recently - wish the ghc error message had had a pointer to "this is why i can't do that, dave"
23:21:30 <zenware> Well, over the past few days since nothing currently available is satisfactory I was going to write my own functional langauge, the main problem being that I can't think of any decent way for it to be structured...
23:21:37 <shachaf> Catnaroek: The way I see it, "functional" is a meaningless term.
23:21:49 <shachaf> So people ought to stop using it, especially in arguments.
23:22:22 <Catnaroek> shachaf: Meaningless? Wasn't "functional" all about functions being true mathematical functions of their arguments?
23:22:23 <Phlogistique> zenware: did you try Unlambda?
23:22:37 <pikhq> Catnaroek: "Functional" to me merely implies a focus on closures as a basic element of control flow.
23:22:42 <liyang> Catnaroek: bottom aside...
23:22:54 <Catnaroek> liyang: Yes, I am painfully aware of that.
23:23:00 <liyang> :)
23:23:06 <shachaf> Catnaroek: It's meaningless because it has so many different meanings.
23:23:11 <pikhq> liyang: Mathematical functions are not required to total. :)
23:23:25 <pikhq> s/to/to be/
23:23:55 <zenware> Phlogistique: No, I stuck with what appeared to be the more popular/mainstream functional languages
23:24:36 <Catnaroek> pikhq: I do not see how closures are thaaaaaaat fundamental. Of course, I would much rather use closures than a gazillion top-level declarations, but in theory you can get away with having every function declared at the top level.
23:25:00 <mm_freak> Catnaroek: in theory you can get away with what brainfuck provides
23:25:02 <pikhq> Anyways. "Functional" was a much more *meaningful* classification in the past than it is now... The distinguishing features of the "functional" languages were first-class functions, anonymous functions that closed, and garbage collection.
23:25:03 <pqmodn> zenware: if your main complaint is syntax, perhaps consider a language with macros.
23:25:08 <Claudius1aximus> (the reason it disallows instances for partially applied type synonyms is roughly that you can encode functions with type synonyms, and proving that functions are identical is undecidable, or something along those lines)
23:25:11 <pikhq> Most languages made since 1990 provide those.
23:25:29 <shachaf> pikhq: There are many people who'll disagree with you.
23:25:37 <pqmodn> Catnaroek: yes, i'm working on a concatenative language that has no closures but it is functional
23:25:44 <shachaf> So I recommend abandoning that term, once again.
23:26:14 <Catnaroek> Okay, okay.
23:26:18 <zenware> My main complaint is something I can't quite figure out how to phrase... Sort of how the "if"'s are possible without actually having them, by means of defining your function more than once with the parameter having a solid value
23:26:25 <Catnaroek> Wow, there is a Ragnaroek, and I am Catnaroek.
23:27:02 <pikhq> zenware: ... Do you mean pattern matching?
23:27:03 <Ragnaroek> morning :)
23:27:06 <Catnaroek> zenware: Maybe you should read how pattern matching is implemented.
23:27:14 <Catnaroek> Good morning, almost-homonym.
23:27:25 <zenware> For example fib n = fib (n-1) + fib (n-2) and fib 0 = 0 and fib 1 = 1
23:27:41 <Catnaroek> Well, fib 0 and fib 1 have to be defined *above* fib n.
23:27:41 <Ragnaroek> is catnaroek a special kind of ragnaroek?
23:28:07 <Catnaroek> Ragnaroek: Catnaroek is this epic longcat vs tacgnol battle that takes place on Caturday...
23:28:08 <zenware> ^In haskell, but would rather be defined in a C-Style with ifs and recursion instead...
23:28:19 <pqmodn> zenware: you can use an if statement in that case
23:28:36 <Orclev_> I prefer nyancat vs. tacnayn
23:28:53 <liyang> if-then-else is nothing but a specialised case-of for Bool.
23:29:04 <zenware> Yes, but it's weird that it's not needed because you can define the same function infinite times with static "parameters"
23:29:19 <pikhq> zenware: In much less idiomatic Haskell, that is: fib n = if n == 0 then 0 else if n == 1 then 1 else fib (n-1) + fib (n-2)
23:30:03 <Catnaroek> zenware: Basically, the function parameter gets matched with the first definition. If the matching fails, then it gets matched with the second definition. If the matching fails, the it gets matched with the third... and so on.
23:30:10 <Catnaroek> parameters*
23:30:23 <pikhq> zenware: And what it actually *is* is syntactic sugar for: fib n = case n of { 0 -> 0; 1->1; n -> fib (n-1) + fib (n-2) }
23:30:56 <pqmodn> zenware: it's not unusal for mathematical functions to be written that way, http://en.wikipedia.org/wiki/Continuous_function#Non-examples
23:30:56 <shachaf> pikhq: Except for the part where it's actually syntactic sugar for the if-else thing.
23:31:03 <shachaf> Because Num pattern-matching is defined in terms of Eq.
23:31:22 <shachaf> (OK, it's syntactic sugar for case n == 0 of False -> 0; True -> ...
23:31:23 <shachaf> )
23:31:29 <pikhq> shachaf: Darned oddities!
23:31:31 <zenware> I just generically don't like it.
23:31:42 <shachaf> zenware: You win.
23:31:45 <shachaf> Haskell is a stupidhead.
23:31:46 <pikhq> zenware: Why, precisely?
23:32:29 <zenware> My real problem is not being able to come up with a solution that might be equally or more efficient and readable as well as widely understood and likeable
23:32:30 * liyang typically uses case-of instead of spelling the function name out N times.
23:32:56 <Catnaroek> If statements are the poor man's pattern-matching. This should be clear in the fact most imperative languages lack a decent implementation of sum types.
23:33:02 <zenware> that's what I said previously, I can't quite explain my distaste
23:33:14 <shachaf> Catnaroek: Um, what?
23:33:18 * shachaf never mind.
23:33:23 <zenware> Perhaps tomorrow I will discover a proper way to phrase it
23:33:42 <pqmodn> perhaps you should try using them for a while, and see if you change your mind?
23:34:01 <pikhq> I'd imagine you're just being kinda weirded about it. The whole *point* is that it makes your conditionals much easier to read and easier to write.
23:34:14 <Catnaroek> shachaf: Try implementing what Djinn outputs when fed "Either a b -> (a -> c) -> (b -> d) -> Either c d" in an imperating language,
23:34:26 <liyang> https://github.com/tibbe/haskell-style-guide
23:34:52 <ziman> if you provide eliminators for your inductive datatypes, you can do away with pattern matching altogether, if I'm not mistaken :)
23:34:55 <shachaf> Catnaroek: "imperative" is about as meaningless as "functional", I think.
23:34:57 <pikhq> Doing some sort of operation on a parse tree in e.g. Java would be a really hairy-looking thing. In Haskell it looks like a fairly simple line.
23:35:07 <shachaf> Catnaroek: Anyway, ALGOL 68 had sum types.
23:35:40 <Catnaroek> Catnaroek: Wow. Then imperative languages have all but gone backwards in time!
23:35:51 <pikhq> fold_constants (Add (Constant x) (Constant y)) = Constant (x+y) -- For instance?
23:35:54 <Catnaroek> shachaf: The only typesafe implementation of sum types in an modern imperative language that I know is C++'s boost::variant, which takes a lot more code and is fugly as hell.
23:36:03 <Catnaroek> s/Catnaroek/shachaf/
23:37:14 <pikhq> Whereas that'd look like, uh. if(node.type == Add && node.left.type == Constant && node.right.type == Constant) return new Node(Constant, node.left.val + node.right.val);
23:37:17 <pikhq> ?
23:37:20 <pqmodn> zenware: a nice example where pattern matching is quite readable http://samedi9999.wordpress.com/2011/03/09/roman-numerals-in-scala/
23:37:50 <Catnaroek> pikhq: ?
23:38:06 <pikhq> </example type="contrived">
23:40:38 <zenware> Well the reason I was wondering is because I've sort-of set upon the creation of a purely functional language in the hopes of producing something better than what currently exists, but was incapable of deriving anything seemingly worthwhile.
23:42:00 <nus-> a first step would be formulating the problem
23:42:48 <mm_freak> zenware: if you're going to use a core language, please please please write it as a separate package
23:43:01 <spacebark> implementing a runtime system that would do efficient implicit parallelisation by examining successive program executions
23:43:21 <mm_freak> spacebark: i doubt that that's possible
23:43:59 <mm_freak> it will work for structurally simple programs for simple problems, but for more complicated problems it will get stuck in local minima
23:44:09 <zenware> I don't doubt the possibility but I think you are under-exaggerating the complexity of such a thing.
23:44:29 <ramier> understating perhaps
23:49:15 <Wooga> hi, is it possible to re-define dropWhile with foldr (indirectly, since direct implimentation is already not possible)?
23:49:35 <Wooga> i was reading [Hutton99] Graham Hutton. “A tutorial on the universality and expressiveness of fold”. Journal of Functional Programming. 9. 4. July 1999. 355-372. Cambridge University Press. 0956-7968. - http://www.cs.nott.ac.uk/~gmh/fold.pdf
23:49:45 <Wooga> but there is example that is not valid in haskell
23:50:05 <Wooga> namely, f x (ys, xs) = (if p x then ys else x : xs, x : xs)
23:50:40 <Wooga> i suppose the right side is lacking parentesis, f x (ys, xs) = (if p x then ys else (x : xs, x : xs))
23:50:46 <Wooga> but it still is not valid haskell
23:50:59 <Wooga> since types of if branches are different
23:51:56 <Wooga> i am confused by this page
23:52:24 <TSC> Maybe the parens go: ((if p x then ys else x : xs), x : xs)
23:52:34 <Wooga> oh
23:52:43 <TSC> Then ys and xs are the same type
23:53:30 <Wooga> yes, it makes sense now
23:53:36 <Wooga> thanks!
23:55:20 <TSC> No worries!
