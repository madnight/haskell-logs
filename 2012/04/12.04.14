00:04:18 <hayashi> @pl \f x -> (first (fromMaybe (f x))) x
00:04:19 <lambdabot> (first . fromMaybe =<<)
00:05:34 <mzhang> hi, how is "learn you a haskell for great good" as a beginner tutorial?
00:12:29 <liyang> 'tis good.
00:13:22 <hayashi> If you've got a data statement that is (and almost certainly always will be) one constructor with two arguments, is it worth keeping or should it be replaced with a type'd tuple?
00:13:46 <shachaf> hayashi: Keep it.
00:13:50 <shachaf> Type safety is good.
00:14:06 <shachaf> In general you should need a good reason to use tuples instead of your own data type.
00:14:17 <shachaf> mzhang: People around here generally recommend it.
00:17:27 <mzhang> shachaf: thanks, I'm gonna start with it
00:22:49 <wli> Variant records are there for more descriptiveness.
00:23:57 <wli> data T = C_1 { f_1_1 :: t_1_1, …} | C_2 { f_2_1 :: t_2_1, … } | ...
00:25:04 <wli> I'm a bit foggy on GADT bits mixing with that but just looked over it earlier.
00:40:30 <kizzo>  Not in scope: data constructor `FileHandle'
00:42:49 <danr> @hoogle FileHandle
00:42:50 <lambdabot> GHC.IO.Handle mkFileHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle
00:47:02 <hpaste_> kizzo pasted “pattern matching” at http://hpaste.org/66948
00:53:16 <kizzo> Maybe what you posted solves my problem..
00:53:20 <kizzo> hmm..
00:53:58 <danr> kizzo: Handle does not have any exported constructors
00:54:02 <kizzo> Nah it probably doesnt.
00:54:04 <danr> so you cannot pattern-match on Handle
00:54:06 <danr> yep, right
00:54:28 <kizzo> I have seen this: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-IO-Handle-Types.html#Handle
00:55:09 <kizzo> How are you ever supposed to use ioeGetHandle, if it returns a "Maybe Handle", but you can't pattern match agaist it like "Just (Handle h)" ?
00:55:12 <hayashi> \pl \f g x y z -> f (g x y z)
00:55:16 <hayashi> frick
00:55:19 <hayashi> @pl \f g x y z -> f (g x y z)
00:55:19 <lambdabot> (.) . (.) . (.)
00:55:29 <hayashi> I see a pattern emerging here
00:56:28 <hayashi> @unpl (.) . (.) . (.) . (.)
00:56:28 <lambdabot> (\ o b c f i l -> o (b c f i l))
00:56:50 <hayashi> interesting choice of letters to say the least
00:58:13 <kizzo> Ok maybe I'm just not supposed to be doing that..
00:59:28 <Enigmagic> kizzo: case ioeGetHandle ioe of Just h -> do something; Nothing -> do something else;
01:00:49 <kizzo> Thanks.
02:00:41 <hayashi> @pl \f g x y = (f x, g y)
02:00:41 <lambdabot> (line 1, column 10):
02:00:41 <lambdabot> unexpected "="
02:00:41 <lambdabot> expecting pattern or "->"
02:00:46 <hayashi> @pl \f g x y -> (f x, g y)
02:00:47 <lambdabot> flip . (((.) . (,)) .)
02:00:58 <hayashi> @pl \f g x y -> [f x, g y]
02:00:58 <lambdabot> (. flip (flip . ((:) .)) []) . flip . (((.) . (:)) .)
02:01:04 <hayashi> O_o
02:10:10 <sgronblo> Hello was about to have a nice little haskell time and do some of the exercises here https://github.com/tonymorris/course/ So I cloned the repo and tried to runhaskell Course.hs but I get an error mesage about QuickCheck2 not being installed
02:10:28 <shachaf> Sounds like installing QuickCheck2 might solve that problem?
02:10:56 <sgronblo> Is QuickCheck2 different from QuickCheck at version > 2?
02:11:17 <bitonic> sgronblo: there is no QuickCheck2
02:11:23 <sgronblo> cabal list quickcheck shows me I have 2.4.1.1 of QuickCheck installed
02:12:21 <bitonic> sgronblo: you should be fine then, post the error runhaskell gives you
02:12:23 <Peaker> sgronblo: can you paste the exact error message?
02:13:19 <sgronblo> Could not find module `Test.Framework.Providers.QuickCheck2'
02:13:21 <hayashi> @pl \f (g a b) -> f a b
02:13:22 <lambdabot> (line 1, column 7):
02:13:22 <lambdabot> unexpected "a"
02:13:22 <lambdabot> expecting operator or ")"
02:13:26 <hayashi> Nyoron.
02:14:20 <bitonic> sgronblo: first of all, that course includes a cabal file. so the best way is just to issue "cabal install" in that directory
02:14:47 <bitonic> that will install all the dependencies, including http://hackage.haskell.org/package/test-framework-quickcheck , which is the provider of that missing module
02:15:07 <sgronblo> bitonic: aha thanks, I'll give it a try
02:16:05 <sgronblo> ah crap, gcc problems.
02:16:33 <sgronblo> Cabal is trying to use it from /Developer/usr/bin/gcc
02:16:50 <sgronblo> But I think I managed to mess up my Xcode installation some time ago
02:18:32 <sgronblo> http://hackage.haskell.org/trac/hackage/ticket/896 I guess it seems related to this...
02:21:21 <sgronblo> Ok works now. Thanks for your assistance.
02:34:52 <chioque> window log on
02:35:20 <chioque> sorry for that, forgot to type '/'
02:35:29 <dhun_233> the wikibook on haskell got a LaTeX version http://en.wikibooks.org/wiki/File:Haskell.pdf
02:41:58 <mcstar> i dont understand people, why would binarysculpting pay for an editor to use with haskell, when there is emacs?
02:42:22 <tech2> mcstar: really, trolling with that, here?
02:42:43 <mcstar> trolling with what?
02:42:49 <mcstar> and no, it isnt trolling
02:43:07 <mcstar> im reading the blog someone linked in here the other day
02:43:15 <mcstar> i just forgot his username
02:43:46 <tech2> mcstar: emacs lisp isn't even a great lisp. You've heard about the proposals to replace it with guile, right?
02:44:17 <mcstar> i didnt say anything about emacslisp
02:44:18 <tech2> mcstar: so why _not_ pay for an editor to use with haskell?
02:44:27 <shachaf> mcstar: We understand that you like your editor. Other people like their editors. That doesn't make them the devil, and it's not a productive discussion unless you have something useful to add.
02:44:31 <tech2> mcstar: ah, sorry, misread what you wrote.
02:44:37 <shachaf> Keep in mind that people have had it thousands of times before.
02:44:59 <shachaf> Usually the only result is to get people angry.
02:45:11 <mcstar> i mean the guy starts with: haskell has no good ide...
02:45:27 <mcstar> hell, no, i dont want flame, sorry
02:47:31 * kallisti has an interesting, but tedious, idea for a project.
02:48:03 <kallisti> essentially a wrapper over the text package, but with encoding stored as a phantom type.
02:48:31 <mcstar> shachaf: does haskell-platform come with an editor btw?
02:48:50 <shachaf> kallisti: There was a GSoC project to convert Text to UTF-8 at one point.
02:49:05 <shachaf> mcstar: No.
02:49:25 <kallisti> shachaf: "convert Text to UTF-8"  wat
02:49:58 <shachaf> kallisti: Change the Text package so that it uses UTF-8 instead of UTF-16.
02:50:04 <kallisti> ogh
02:50:05 <shachaf> Excuse me, the "text" package.
02:50:12 <kallisti> for some reason I thought it was UTF-8
02:50:29 <kallisti> but then again, I kind of just assume everything is UTF-8
02:51:00 <shachaf> Maybe it's Unicode Big Endian.
02:53:37 <kallisti> my touchpad has apparently forgotten how to scroll
02:54:15 <mcstar> :t ($=)
02:54:16 <lambdabot> Not in scope: `$='
02:55:08 <Cale> mcstar: using OpenGL?
02:55:21 <mcstar> no, but that operator is from a code that does
02:55:29 <mcstar> so its some opengl magic?
02:55:31 <Cale> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
02:55:57 <mcstar> thanks
02:56:17 <Cale> It's just part of a little uniform interface to mutable state which the OpenGL library happens to use a bunch
03:00:59 <mcstar> let me quote something:
03:01:03 <mcstar> "So, I decided to just write a picture to disk instead. This also proved somewhat difficult, again due to the missing IDE."
03:01:19 <mcstar> btw, the guy is 'dervall'
03:01:46 <mcstar> i just dont get this, an ide cant write a program for you, can it?
03:03:32 <sgronblo> Can't you just contact the guy directly and set him straight if he's so mislead
03:03:54 <sgronblo> Free your mind. Let other people be "wrong" :)
03:05:20 <mcstar> okey dokey, free my mind, no problem, free my mind! aaaaaaaaa
03:06:23 <sgronblo> Any idea how I am supposed to run these tests in this repo https://github.com/tonymorris/course/ ?
03:06:48 <sgronblo> Nothing seems to happen when I make changes to the src/L02/List.hs file
03:13:43 <sgronblo> Any suggestions? I'm guessing the module needs to be recompiled somehow.
03:15:08 <sgronblo> ah I think I found it
03:18:49 <eci> sgronblo: and what did you find?
03:20:28 <sgronblo> oh oops, I found a Main.hs file which produced some passing tests which I thought was because of my implementation but I was wrong
03:20:37 <sgronblo> so I still didn't figure out how to actually run the tests
03:21:03 <shachaf> Run the test file?
03:21:07 <sgronblo> which one?
03:21:35 <shachaf> runghc test/src/L02/List/Tests.hs?
03:21:43 <sgronblo> Not runhaskell?
03:22:09 * hackagebot factory 0.2.0.1 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.1 (LennartAugustsson)
03:22:12 <shachaf> runhaskell if you prefer.
03:22:23 <sgronblo> Is there a difference?
03:22:35 <shachaf> Possibly.
03:23:44 <sgronblo> I always keep getting the todo error even for the functions I tried implementing
03:24:08 <kmels> how can one write a function that given a list of a list of tuples [[a]], returns a list of tuples, resulting of picking one tuple at a time? e.g. [
03:24:08 <kmels> a
03:24:20 <kmels> oh, wrong key
03:25:42 <kmels> i want to get [[a,d],[a,e],[a,f],[b,d],[b,e]..] given [[a,b,c],[d,e,f]], for example
03:25:55 <shachaf> [[a]] isn't the type of a list of tuples.
03:26:06 <shachaf> > sequence [[a,b,c],[x,y,z]]
03:26:07 <lambdabot>   [[a,x],[a,y],[a,z],[b,x],[b,y],[b,z],[c,x],[c,y],[c,z]]
03:28:02 <kmels> that's what i wanted, thank you
03:33:18 <mcstar> MOTD: naive parallelization makes programs slower
03:33:48 <JoshTriplett> Given a cabal package that I've modified and built, how can I fire up ghci and load the new version without installing it?
03:38:38 <Guest15978> hi
03:40:23 <JoshTriplett> Found the answer: ghci -package-conf dist/package.conf.inplace
03:41:19 <falko> hi
03:45:23 <fmap> > [[x,y] | x <- [1,2,3], y <- [4,5,6]]
03:45:24 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
03:46:26 <Peaker> sequence [1,2,3] [4,5,6]
03:46:34 <Peaker> > sequence [1,2,3] [4,5,6]
03:46:34 <lambdabot>   [1,2,3]
03:46:43 <shachaf> ...Ha.
03:46:45 <Peaker> > sequence [[1,2,3], [4,5,6]]
03:46:46 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
03:46:47 <shachaf> Well done, lambdabot.
03:46:48 <Peaker> oops ;-)
03:47:01 <shachaf> Peaker: (This was in response to a previous question that I already mentioned sequence for.)
03:47:46 <shachaf> It's a clever combination of weird instances that produces sequence [1,2,3] [4,5,6] --> [1,2,3]
03:49:45 <mcstar> is it possible for 'par' to use lightweight threads?
03:49:52 <mcstar> or is that the default?
03:50:38 <shachaf> I'm not sure I (or you) understand your question.
03:50:44 <shachaf> But as far as I do, what would be the point?
03:51:21 <mcstar> i just dont know whether par spawns an OS thread to do its work or not
03:51:58 <Peaker> it's the Monad (->) and Num (->), isn't it?
03:52:13 * hackagebot hspec 1.0.0.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.0.0.1 (SimonHengel)
03:53:02 <shachaf> Right.
03:53:10 <mcstar> btw, is haskell a good starting point to get myself familiarized with parallel stuff, or it would be better if i had some understanding of it from a more conventional viewpoint?
03:53:54 <shachaf> mcstar: What are you suggesting as the two alternatives that would be the answer to your question?
03:54:30 <mcstar> to the first one?
03:54:44 <shachaf> Yes.
03:55:33 <mcstar> well, i dont know what 'par' does to evaluate the form i pass to it, maybe it does some so called 'context switching' maybe it doesnt
03:56:18 <shachaf> I still don't understand what your question is.
03:56:46 <mcstar> can you shed some light on how does it work then?
03:59:17 <shachaf> mcstar: Let's say par "used lightweight threads". What would the advantage of that be?
03:59:28 <shachaf> Or what would you say the advantage of lightewight threads is in general?
04:00:10 <mcstar> i think the advantage is that those are not real threads, just 'work' scheduled to be computed on for exzample 1 real thread
04:00:26 <shachaf> OK. What does that mean, and why is it better?
04:01:03 <mcstar> it means the runtime doesnt have to ask the OS for new threads, and all the allocations that comes with that
04:01:08 <mcstar> so you save time
04:01:11 <mcstar> and gain granularity
04:02:05 <shachaf> OK.
04:02:10 <shachaf> What's the point of "par"?
04:02:47 <mcstar> from the doc, i take it means evaluate its first argument, before using it in its second argument
04:03:03 <mcstar> and this can be done 'not in the main thread'
04:03:06 <mcstar> i guess
04:03:44 <shachaf> OK.
04:03:50 <mcstar> "then it may convert a spark into a real thread"
04:03:55 <shachaf> So the point of "par" is to run computations in parallel.
04:03:57 <mcstar> i dont understand this specifically
04:04:10 <shachaf> Do you know the difference between "parallelism" and "concurrency"?
04:04:48 <mcstar> cocurrency, is when you have tasks that are independent from one another and can be done in any order
04:05:05 <mcstar> parallel, is when these are dont in parallel to one another, many at a time
04:05:11 <mcstar> dont->done
04:05:26 <shachaf> "parallel, is when these are done in parallel to one another"
04:05:37 <shachaf> That definition is difficult to argue with. :-)
04:05:57 <mcstar> it is not a linear execution of things
04:06:23 <mcstar> i dont know how else i should say this, you can do multiple things at once
04:06:34 <shachaf> OK.
04:06:59 <shachaf> Are you able to answer your question yet?
04:07:23 * zhulikas is confused. Who is explaining to whom about parallelism?
04:07:37 <mcstar> sry, took a leak
04:07:47 <shachaf> zhulikas: I am trying to get mcstar to explain parallelism to themselves, so that I can go to sleep. :-)
04:07:56 <mcstar> i am one person
04:08:13 <mcstar> shachaf: sry to keep you up
04:08:21 * zhulikas just wake up o/
04:08:36 <zhulikas> at 13:00, goddamnit
04:09:03 <shachaf> @time
04:09:06 <lambdabot> Local time for shachaf is Sat Apr 14 04:08:41 2012
04:09:11 <shachaf> Looks like I might be doing the same...
04:09:17 <zhulikas> :))
04:09:49 <shachaf> Anyway, now that you're awake, you can explain to mcstar what par and forkIO are.
04:10:05 <zhulikas> oh man, I am still a noob here
04:10:06 <shachaf> The original question was, I think, "does par use lightweight threads?".
04:10:16 <kowey> anybody from the MacOS X Strike Force around? http://www.haskell.org/haskellwiki/Mac_OS_X_Strike_Force
04:10:24 <mcstar> yeah, and i still cant answer that
04:10:28 <shachaf> Hey, it's kowey!
04:10:30 <shachaf> Hi, kowey!
04:10:37 <kowey> hello!
04:10:41 <zhulikas> I think it does, because par is encouraged even to small computations. So, it does, right?
04:11:14 <mcstar> "then it may convert a spark into a real thread"
04:11:26 <shachaf> mcstar: A good question to ask yourself would be: What's the point of using more than one OS thread, ever?
04:11:43 <zhulikas> the original example on Haskell site use par to calculate fibonacci sequence and yet it calculates it faster than without par. That means that overhead of creating parallel threads for small computations is smaller than performance gain of it
04:12:05 <kallisti> moreover, par does not require that anything become a thread
04:12:06 <zhulikas> but that's just speculations of a dilettante
04:12:36 <kallisti> so it's not as though you're spawning one thread for every integer.
04:13:07 <kallisti> you're putting thunks in a queue for existing threads to evaluate.
04:13:11 <shachaf> Yes, the number of threads used is constant for the runtime of the program, usually.
04:13:17 <kowey> I was wondering how obnoxious it would be for cabal-macosx to just dump application bundles in ~/Library/Haskell/Applications
04:13:30 <shachaf> kallisti: But I think mcstar can reason through this themselves given enough prodding.
04:13:46 <mcstar> shachaf: multiple real threads are needed to queue tasks on multiple cpu's
04:13:48 <mcstar> right?
04:13:52 <mcstar> i mean cores
04:14:05 <shachaf> More or less, yes.
04:14:11 <mcstar> i did some mpi work
04:14:18 <shachaf> And that's when you get actual parallel execution.
04:14:20 <azm> is parallelism subset of concurrency ?
04:14:30 <shachaf> azm: No, they're two different things.
04:14:43 <mcstar> for example QT is concurrent
04:14:49 <mcstar> but not necessarily parallel
04:15:00 <azm> oh, I got it
04:15:06 <zhulikas> I should implement parallelism in my algorithm today o/
04:15:10 <zhulikas> and learn it finally
04:15:15 <mekeor> azm: http://www.haskell.org/haskellwiki/Parallelism
04:15:18 <kallisti> concurrency is a property of algorithms. parallelism is a property of...
04:15:22 <kallisti> er, I was going somewhere with this.
04:15:26 <azm> concurrency might use parallelism
04:15:27 <mcstar> machines
04:15:31 <azm> to be more effiecient
04:15:33 <kallisti> yes. that's close enough.
04:15:34 <azm> and vice versa
04:15:38 <kowey> azm: Haskellers like talking about the difference partly because in Haskell you can do parallelism without directly exposing yourself to concurrency
04:15:41 <kallisti> it's a property of execution
04:15:41 <shachaf> azm: Sometimes parallelism will make it less efficient!
04:15:48 <shachaf> It's never so simple.
04:16:01 <azm> I see
04:16:13 <mekeor> let's assume i'm so dumb that i write 'f x = (someFunction x,someFunction x)'. does haskell evaluate someFunction twice then? (someFunction is pure.)
04:16:30 <mcstar> kowey: can you explain a bot?
04:16:32 <mcstar> bit*
04:16:41 <kowey> as kallisti was saying, you can think in terms of goals vs techniques
04:16:42 <shachaf> mekeor: "haskell" is a language specification; it doesn't evaluate anything.
04:16:50 <kowey> (eep! I'm no expert here, so please take me with salt)
04:16:53 <shachaf> mekeor: GHC will probably evaluate that twice, unless it decides not to.
04:17:01 <shachaf> @google parallelism vs concurrency
04:17:02 <lambdabot> http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference
04:17:02 <lambdabot> Title: language agnostic - Concurrency vs Parallelism - What is the difference? - Stack ...
04:17:05 <shachaf> @google parallelism vs concurrency haskell
04:17:06 <kowey> azm: so concurrency and performance are goals that you might have
04:17:08 <lambdabot> http://community.haskell.org/~simonmar/par-tutorial.pdf
04:17:08 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
04:17:17 <kowey> concurrency meaning being able to deal with more than one thing at the same time
04:17:17 <shachaf> Probably one of those will be good at explaining.
04:17:20 <kallisti> mekeor: in GHC, that would most likely be factored out by common sub-expression elimination
04:17:37 <shachaf> COncurrency is a perfectly reasonable thing to want without parallelism, and parallelism is a perfectly reasonable thing to want without concurrency.
04:17:37 <kowey> and performance meaning making things go zoom
04:17:40 <kallisti> but there's no guarantee
04:17:40 <shachaf> And often you want both.
04:17:43 <mekeor> kallisti: so, one evaluation?  shachaf said two...
04:18:00 <shachaf> mekeor: GHC will evaluate it twice, unless it decides to evaluate it once.
04:18:01 <kallisti> I don't think shachaf he said 2...
04:18:01 <mcstar> shachaf: my second question still stands: how much more complicated using haskell makes this learning?
04:18:06 <shachaf> Which is an optimization things.
04:18:11 <azm> kowey, makes sense
04:18:25 <shachaf> mcstar: Probably no more complicated than anywhere else.
04:18:31 <mekeor> kallisti: anyway. so i should rather write "f x = let y = someFunction x in (y,y)', right?
04:18:34 <cheater_> mcstar: what are you learning?
04:18:36 <shachaf> mcstar: You'll have to think and reason things out, though, either in Haskell or elsewhere.
04:18:45 <kallisti> mekeor: probably
04:18:50 <shachaf> Yes. Probably.
04:18:52 <kowey> azm: (feel free to stop me) whereas parallelism can be thought of as a means to an end
04:18:58 <kallisti> but you can always write the first example in a simple program
04:19:04 <kallisti> and then use ghc-core to look at the result. :D
04:19:05 <shachaf> That'll make it so that in most reasonable Haskell implementations it'll always be computed once.
04:19:10 <mekeor> kallisti: or use "where"...
04:19:10 <kowey> parallelism = doing things literally simultaneously (technique) in the interest of your goal (performance)
04:19:14 <mekeor> kallisti: what's ghc-core?
04:19:19 <cheater_> right, parallelism
04:19:44 <shachaf> @google what's ghc-core?
04:19:46 <lambdabot> http://stackoverflow.com/questions/6121146/reading-ghc-core
04:19:46 <lambdabot> Title: performance - Reading GHC Core - Stack Overflow
04:19:49 <mekeor> :D
04:20:09 <kowey> azm: and as others have pointed out, you can have one without the other, concurrency w/out parallelism (multiple threads, one core, still useful even if not literally simultaneous)
04:20:13 <azm> well I actually found nice presentation on this topic http://concur.rspace.googlecode.com/hg/talk/concur.html#landing-slide
04:20:16 <cheater_> mcstar: haskell has a lot of advantage over most other languages when it comes to parallelism. in other languages, you have to worry about a lot of crud that takes days, even weeks, to get right. in haskell it is very simple and you can actually concentrate on the nature of the parallelism.
04:20:20 <kowey> and in the Haskell world, parallelism without having to deal with concurrency
04:20:35 <kowey> although *under the hood*, somebody is writing concurrent code for you to enable that
04:20:38 <mekeor> shachaf, kallisti: thanks
04:20:40 <shachaf> The point of "lightweight threads" is to do concurrency efficiently.
04:21:06 <mcstar> cheater_: ok, i get it, but that is from a perspective of an experienced haskeller, if im right
04:21:11 <cheater_> no
04:21:20 <cheater_> i'm a newbie myself
04:21:23 <shachaf> What's from a perspective of an experienced Haskeller?
04:21:27 <cheater_> using mvars and stuff like that is simple
04:21:37 <azm> haha, thanks for explanation kowey. Kinda sums up what I read sofar but people seem to have distinct stances on this topic anyway in a subtle way
04:21:50 <cheater_> mcstar: in many languages you'll get so involved with actually implementing parallelism you won't actually have time to consider the bigger picture
04:22:02 <cheater_> which is why many of them suck badly
04:22:05 <kowey> so finally, to wrap this all up in the goals vs techniques/tools perspective
04:22:35 <mcstar> well, i dont really know other techiniques of implementing parallelism, except MPI and OpenMP
04:22:49 <cheater_> the only other languages i know of which might facilitate parallelism this well are smalltalk and erlang, maybe prolog
04:22:53 <mcstar> (and i didnt some concurrent programming on cuda)
04:22:56 <mcstar> did
04:23:03 <cheater_> see that's the thing
04:23:06 <cheater_> you're getting too caught up in the implementation
04:23:16 <shachaf> My usual technique of implementing parallelism is: ./program 1-50 & ./program 51-100; wait
04:23:28 <cheater_> if you want to learn about parallelism, you shouldn't be thinking about APIs and message standards
04:23:42 <cheater_> you should be thinking of things such as parallel computation strategies, parallel data structures, etc
04:24:07 <shachaf> mcstar: The point of CUDA, of course, is parallelism.
04:24:13 <cheater_> that's *actually* parallelism
04:24:39 <mcstar> well, it is implemented as parallel execution of *cooncurrent* jobs
04:24:44 <azm> can you do very efficient parallelism coding without proper concurrency  cheater_ ?
04:24:57 <mcstar> you just spawn the kernels, and yes, they will be executed in parallel
04:25:07 <mcstar> (well, some of them)
04:25:25 <cheater_> azm: efficiency is measured in relation to your bounds, your question is moot.
04:25:43 <mcstar> shachaf: i'd call that programming model concurrent
04:25:49 <azm> haha I mean eg. server load
04:26:09 <cheater_> same answer.
04:26:10 <shachaf> mcstar: The *goal* is parallelism.
04:26:27 <shachaf> Concurrency is treated as an unfortunate method of achieving that goal.
04:26:47 <mcstar> why unfortunate/
04:27:09 <kowey> I think one thing that makes things a bit harder to understand is that the techniques vs goals distinction depends a bit on what level you are looking at
04:27:17 <antibot> Is it possible to retrieve a haskell value from a shared haskell library?
04:27:43 <kowey> and a lower-level goal can be used to enable a higher-level technique
04:27:48 <mcstar> i think the cuda model is highly succesful
04:28:03 <mcstar> i dont see anything particularly unfortunate about it
04:28:11 <kowey> so when somebody says “parallelism is not the goal; performance is... whereas concurrency is a goal”
04:28:48 <kowey> and yet somebody else says something apparently contradictory “paralellism is the goal; concurrency is just an unfortunate technique to achieve it”; they're actually kind of talking about the same thing
04:29:02 <kallisti> antibot: yes.
04:29:08 <Shadow^Dancer> not necesarely
04:29:13 <kallisti> antibot: there's http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-DynamicLinker.html
04:29:26 <shachaf> kowey: We're talking about two different situations here.
04:29:27 <kallisti> which is a wrapper over the dlopen C stuff
04:29:39 <Shadow^Dancer> your goal migth be end faster a given task
04:29:43 <Shadow^Dancer> or, be responsive
04:29:54 <Shadow^Dancer> for multiple task, depite how long individual ones take
04:30:00 <kallisti> antibot: for HAskell-specific dynamic linking, check out http://hackage.haskell.org/package/plugins
04:30:25 <shachaf> kowey: In the case that you have, say, a server with thousands of connections, concurrency is just a reasonable way of looking at the problem.
04:30:39 <antibot> kallisti: plugins handle shared libs? I thought they only loaded .o's.
04:31:01 <shachaf> In the case that you want a value to be computed for every pixel, parallelism is what you really want -- for performance -- but you might end up writing concurrent code to achieve that goal.
04:31:21 * kowey listens carefully :-)
04:31:39 <kallisti> antibot: oh, er, I don't know. It says "dynamic linking" so I assumed shared lib.
04:31:58 <shachaf> Anyway I don't think the discussion will be very fruitful at this point.
04:32:11 <shachaf> mcstar can hopefully figure out the answer to their original question now.
04:32:21 <kallisti> concurrency is like, a state of mind, man.
04:32:21 <kowey> we might be throwing enough different things at it to become confusing
04:32:25 <mcstar> why do you say, their, and themselves?
04:32:29 <Tinned_Tuna> Heya, i'm hacking around with quickcheck to try and get a simple binarySearch implementation tests
04:32:45 <mcstar> it isnt confusing
04:32:45 <kallisti> mcstar: it's a gender neutral pronoun
04:32:50 <mcstar> im a he
04:32:51 <Tinned_Tuna> However, I'm struggling to get quickcheck to run my test, as I'm a little fail with the types
04:33:02 <Tinned_Tuna> https://gist.github.com/2383750
04:33:09 <azm> parallel coce eg. have to be synced which can lead to bottlenecks(without proper separation-concurrency)
04:33:15 <azm> *code
04:33:16 <Tinned_Tuna> It says that my type variable a is ambiguous, any thoughts?
04:33:32 <shachaf> mcstar: Because I don't know your gender (and don't care to know; "they" works for me).
04:33:49 <Tinned_Tuna> (The type of my binarySearch :: (Ord a) => [a] -> a -> Bool 0
04:33:50 <mcstar> shachaf: ok, sounds weird, im not used to it
04:34:12 <kowey> it's one of those interesting evolution of English things
04:34:57 * kowey apologies is if the rambling about goals vs techniques was distracting, was getting somewhere with that, but not good with concision :-)
04:36:38 <shachaf> kowey: AA++++++ rambling, would listen to again
04:40:33 <kallisti> would it be fair to say that Int and friends are actually the integers modulo maxBound+1?
04:40:46 <kallisti> seems fair.
04:40:47 <shachaf> kallisti: Not really.
04:40:54 <shachaf> Overflow behaviour is undefined.
04:41:11 <kallisti> hm. okay.
04:41:17 <kallisti> so they're just... undefined.. things.
04:41:24 <shachaf> Pretty much.
04:41:31 <shachaf> Talk to conal about that sometimes.
04:41:33 <Tinned_Tuna> maxBound+1 = undefined
04:41:34 <Tinned_Tuna> but
04:41:58 <Tinned_Tuna> for performance reasons, it does not have that exact behaviour, as overflow can be hard to detect
04:42:18 <Tinned_Tuna> John Regher has some blog posts/papers about trying to do it, except in C
04:42:30 <shachaf> Tinned_Tuna: Not _|_-undefined. "undefined behavior"-undefined.
04:42:59 <Tinned_Tuna> shachaf: aye, but undefined is technically defined in GHC to be an uncatchable exception/errpr
04:43:02 <Tinned_Tuna> shachaf: aye, but undefined is technically defined in GHC to be an uncatchable exception/errrr
04:43:09 <kallisti> confetti might billow from your computer, for example.
04:43:11 <Tinned_Tuna> *error
04:43:13 <kaf3ii> type T a = a -> (a, T a)
04:43:13 <kaf3ii> i find myself in need of this type, do i have any options beside newtypeing
04:43:17 <kallisti> this is a condition permissible by undefined behavior, but not by _|_
04:43:36 <Tinned_Tuna> I like bottom and I cannot lie?
04:43:37 <shachaf> kaf3ii: Nope.
04:43:53 <shachaf> kaf3ii: Well, you can do something with Mu or something like that.
04:44:09 <shachaf> But in general you need data/newtype somewhere to express a recursive type.
04:44:12 * kallisti is an other brother and can deny.
04:44:19 <Tinned_Tuna> :-D
04:44:25 <kaf3ii> shachaf: ok thanks
04:44:47 <shachaf> kaf3ii: That type might already exist in a library somewhere, though.
04:44:54 <Tinned_Tuna> kallisti: do you have any ideas about my quickcheck failings, I've never used it before :-/
04:45:04 <kallisti> I'v enever touched quickcheck either.
04:45:04 <shachaf> ...But I don't think I've seen it.
04:45:08 <kallisti> but maybe I can help.
04:45:35 <Tinned_Tuna> it is just a type error (apparently)
04:45:42 <Tinned_Tuna> https://gist.github.com/2383750
04:45:59 <Tinned_Tuna> It's seems like it's trying to reconcile Arbitrary a, Show a and Ord a
04:46:34 <kallisti> Tinned_Tuna: add Arbitrary and Show constraints to your type signature
04:46:36 <kallisti> and see what happens
04:46:40 <Tinned_Tuna> screen -r
04:46:43 <kallisti> I would need the actual type error to make a vetter suggestion
04:46:48 <kallisti> Tinned_Tuna: oopse
04:47:01 <kallisti> also you should be using -Ur :P
04:47:23 <Tinned_Tuna> hang on, I'll see if I can get the type error out of putty.
04:47:32 <kallisti> (or does re-attaching to a screen that was spawned with -U imply -U elsewhere? I am not know)
04:47:57 <Tinned_Tuna> kallisti: https://gist.github.com/2383823
04:48:00 <kallisti> oh wait Ord implies Eq
04:48:07 <Tinned_Tuna> that's the type error with the arbitrary and show constraints
04:48:23 <kallisti> yeah add Arbitrary a to your type signature
04:49:17 <Tinned_Tuna> kallisti: Sadly, just adding Arbitrary a doesn't work, nor does both Arbitrary a and Show a :-/
04:49:46 <Tinned_Tuna> the error doesn't seem to change...
04:50:13 <kallisti> your function takes 2 arguments
04:50:17 <kallisti> but I think it should only take 1
04:50:35 <kallisti> hm, oh no nevermind that should work actually, with the way the function instance for Testable works.
04:50:40 <kallisti> I believe
04:51:01 <kallisti> yeah
04:51:17 <kallisti> Tinned_Tuna: what happens when you add those constraints?
04:51:41 <kallisti> as I think they're needed
04:51:43 <Tinned_Tuna> as far as I can tell, literally nothing. The type error still claims it's ambiguous. Let me check again
04:52:21 <Tinned_Tuna> kallisti: aye, literally no change to the type error
04:53:45 <kallisti> oh
04:53:50 <kallisti> it doesn't know what type you want.
04:54:05 <kallisti> main = quickCheck prop_correct
04:54:15 <kallisti> it's like: "uh... what 'a' are you wanting me to test?'
04:54:18 <kallisti> *"
04:54:45 <kallisti> because the way Arbitrary works is it generates examples of a specific type.
04:54:50 <kallisti> there is no specific type given
04:54:52 <Tinned_Tuna> Ahh, so I have to specify Integer, or Char or something?
04:54:56 <kallisti> yep
04:55:11 <Tinned_Tuna> let's give that a whirl then :-)
04:55:43 <kallisti> you can leave prop_corrects signature alone
04:55:46 <kallisti> but just add an annotation in main
04:56:01 <kallisti> main = quickCheck (prop_correct :: String -> Char -> Property)
04:56:02 <kallisti> for example
04:56:23 <Tinned_Tuna> kallisti: that worked ^.^
04:56:30 <kallisti> cool
04:56:37 <kallisti> I don't know why I didn't see that before..
04:56:53 <kallisti> it's a similar error to:
04:56:55 <kallisti> > read "2"
04:56:56 <lambdabot>   *Exception: Prelude.read: no parse
04:56:57 <kallisti> er
04:57:01 <kallisti> bad example. :P
04:57:05 <Tinned_Tuna> > read '2'
04:57:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:57:06 <lambdabot>         against inferred ty...
04:57:08 <Tinned_Tuna> > read '2' :: Int
04:57:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:57:09 <lambdabot>         against inferred ty...
04:57:15 <Tinned_Tuna> damn :-p
04:57:27 <kallisti> lambdabot automatically defaults the type to ()
04:57:31 <Tinned_Tuna> But yes, I see the problem now. I think I was assuming QuickCheck was more magical than it was
04:57:33 <kallisti> in ghci you'd get an ambiguous type error.
04:57:57 <kallisti> open up ghci  and then type read "2"
04:58:01 <kallisti> and you'll get a similar error
04:58:07 <kallisti> then type
04:58:10 <kallisti> read "2" + read "2"
04:58:13 <kallisti> and you'll get a result.
04:58:30 <kallisti> in the first case, read "2" has no context with which GHC can infer the result type.
04:58:44 <kallisti> in the second case, you're using addition, which infers Num, which then defaults to Integer.
04:58:49 <Tinned_Tuna> > read '2' + read '2'
04:58:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:58:50 <lambdabot>         against inferred ty...
04:58:55 <kallisti> strings not characters.
04:59:02 <kallisti> > read "2" + read "2"
04:59:02 <lambdabot>   4
04:59:33 <Tinned_Tuna> Ah okies :-)
04:59:49 <Tinned_Tuna> makes more sense now. I'm not used to using read directly.
05:01:33 <kallisti> Tinned_Tuna: another example of an ambiguous type would be
05:01:41 <kallisti> show (read "hello")
05:01:54 <kallisti> read what exactly?
05:02:26 <flamingspinach> is there an updated version of the gentle introduction for haskell 2010?
05:02:36 <kallisti> not that I'm aware of.
05:02:50 <kallisti> Haskell 2010 is not much different than 98 though, at least in terms of the core language
05:03:01 <kallisti> mostly just some new extensions that have been around a long time are now standard.
05:03:06 <flamingspinach> ok, that's good to know...
05:04:15 <kallisti> (it also standardizes some libraries, but it doesn't introduce new language concepts that weren't already GHC extensions)
05:05:17 <kallisti> and I'm surprised that more wasn't standardized
05:05:38 <kallisti> FlexibleContexts, TypeSynonymInstances, ...
05:05:45 <kallisti> it's almost like they want Haskell to be simple to implement
05:05:47 <kallisti> ha!
05:05:53 <flamingspinach> has Haskell' died? The website says that most recently the Haskell 2011 committee has been appointed... in 2010...
05:06:31 <kallisti> not sure.
05:06:47 * kallisti thought Haskell' was still a thing, but the website does seem like it hasn't been updated.
05:07:36 <olsner> IIRC, Haskell' got dropped in favor of doing incremental updates like Haskell2010
05:08:04 <flamingspinach> the site says that it aims for incremental updates, but about once per year
05:09:44 <irene-knapp> I thought Haskell2010 was an output of the Haskell' committee
05:09:55 <kallisti> indeed
05:13:10 <sgronblo> so could someone help me figure out how I am supposed to run the tests in https://github.com/tonymorris/course/ this repo, to have my modified files recompiled at the same time
05:16:30 <t7> roconnor...
05:16:33 <t7> did he died?
05:16:57 <kallisti> sgronblo: cabal test, perhaps?
05:17:01 <kallisti> I'm not sure I understand the question
05:18:24 <gienah> sgronblo: probably something like: first fix the cabal file to add the tests; cabal configure --enable-tests; cabal build;  ./dist/build/test-course/test-course
05:19:35 <gienah> sgronblo: hmm, there's another cabal file in the test directory, guess you just build that then look for something in ./dist to run
05:20:41 <sgronblo> kallisti: well I try to run for example runghc test/L02/List/Tests.hs but it doesn't seem to cause a recompilation of the imported L02.List module
05:20:56 <sgronblo> so I'm not sure how people usually do this
05:21:10 <kallisti> if you add the test file to the cabal file you can just run "cabal test"
05:21:24 <kallisti> also you can do "cabal install" which will install the current repo as that packcage
05:21:36 <kallisti> which will do what you expect when you attempt to run the test directly via runghc
05:22:28 <sgronblo> does it get installed into some centralized module location?
05:22:39 <kallisti> yes
05:22:44 <kallisti> well, I don't think the tests do.
05:22:58 <sgronblo> ah and that's how the tests will get access to it then I guess?
05:23:02 <kallisti> you should just add the tests to the cab lfile and run with cabal test
05:23:47 <kallisti> sgronblo: there are some default places that ghc uses to lookup modules
05:23:48 <sgronblo> under what key should they be added?
05:23:52 <kallisti> you can also add your own with the -i option
05:24:35 <kallisti> sgronblo: oh
05:24:39 <gienah> sgronblo: you can crib by looking at hackage packages that that have tests like aeson
05:24:54 <kallisti> well, based on your cabal file
05:25:01 <sgronblo> should they be under exposed modules
05:25:01 <kallisti> it looks as though it actually exposes the "tests" as modules
05:25:14 <kallisti> not if they're actual tests.
05:25:27 <kallisti> but if it was already set up that way.
05:25:29 <kallisti> then leave it
05:25:37 <kallisti> but you need to add "test" to Hs-Source-Dirs
05:25:41 <Tinned_Tuna> What's the nicer version of length and (!!) that can deal with very long lists? I thought it was generic_length or something?
05:25:53 <kallisti> Tinned_Tuna: genericLength
05:25:58 <kallisti> but they're not nice. because they're O(n)
05:25:59 <Tinned_Tuna> kallisti: thanks!
05:26:07 <Tinned_Tuna> kallisti: aye, I know :-(
05:26:14 <hpc> and if you need genericLength because an Int overflows...
05:26:16 <hpc> god help you
05:26:31 <kallisti> heh. my thoughts exactly.
05:26:50 <Tinned_Tuna> hpc: I'm more trying to write a blog post about the analysis and optimisation of binarySearch, I'm not actually worried about it, I'm just covering the error in Bentley's implementation.
05:26:56 <hpc> ah
05:27:06 <sgronblo> well i still get package has no test suites after adding test to hs-source-dirs
05:27:44 <Tinned_Tuna> hpc: it's my first proper blog post on Haskell, and I suspect that it'll need a good proof reading when I'm done :-/
05:27:45 <kallisti> sgronblo: are these actual tests, or are they things you want to expose?
05:28:15 <hpc> Tinned_Tuna: hah, you should see my first blog post - it was HORRIBLE
05:28:20 <kallisti> sgronblo: http://www.haskell.org/cabal/users-guide/#test-suites
05:28:28 <hpc> you learn pretty quick what you do wrong, and then don't do it :P
05:28:46 * kallisti solves this problem by not writing blogs.
05:28:50 <sgronblo> kallisti: i would say they look like actual tests, you can dig around in the repo to see for yourself
05:28:59 <Tinned_Tuna> hpc: I don't know if this is going to be horrible, overly far reaching, or just too long to be a blog post. We'll see :-p
05:28:59 <kallisti> sgronblo: yes it appears that way.
05:29:23 <kallisti> sgronblo: https://github.com/snoyberg/conduit/blob/master/conduit/conduit.cabal
05:29:44 <kallisti> that's the user guide for cabal on how to specify test suites, and an example with test suites
05:29:44 <sgronblo> I think this guy should have mentioned how to run the tests in his README
05:29:54 <Tinned_Tuna> The plan is to cover (in a simplish) way, cranking out a program, testing it, reasoning about it's worst case run time and a reimplementation to try to alieviate some of the issues pointed out, without reintroducing any of the bugs!
05:30:00 <kallisti> he should have included tests as tests in the cabal file.
05:30:20 <mcstar> hpc: your blog being?
05:30:43 <kallisti> Tinned_Tuna: good idea. you can reimplement the list as Vectors. :D
05:31:25 <Tinned_Tuna> kallisti: my thoughts exactly
05:31:27 <sgronblo> are cabal files case insensitive?
05:31:47 <Tinned_Tuna> and the listy implementation gives rise to some simple but fun maths, for the analysis of the run time :-)
05:31:55 <kallisti> sgronblo: the section things are
05:32:27 <kallisti> obviously anything that refers to a case-sensitive name is case-sensitive (like directories)
05:32:40 <kallisti> pretty sure package names are case sensitive.
05:33:32 <hpc> mcstar: http://hpc.dyndns-web.com:8000/blog/
05:34:00 <hpc> (have fun guessing which post took me the longest to write :P)
05:34:09 <Tinned_Tuna> plus, it'll help shake out the cobwebs in my head about writing haskell and thinkning about it :-)
05:34:30 <EvilMachine> hmm… i can’t make sense of fgl. it’s so verbose and so unelegant… :/
05:34:58 <hpc> EvilMachine: oh god, and the haddock is awful
05:34:59 <EvilMachine> what am i missing?
05:35:06 <hpc> the top level module is just a bunch of re-exports
05:35:13 * kallisti probably needs more cobwebs.
05:35:57 * Spiderpig_ needs MOAR COBWEBS
05:35:58 <Tinned_Tuna> right, I'm off to write this post in full. Draft man, away!
05:36:01 <kallisti> sgronblo: also once you're done fixing the cabal file you can always do a pull request on the original
05:36:49 <EvilMachine> hmm… i’m thinking about implementing my own graph library
05:37:01 <EvilMachine> very minimalistic and elegant to the user
05:37:16 <EvilMachine> i’m not by far an expert on the subject
05:37:53 <hpc> EvilMachine: there might be a comparison of graph libs on stack overflow
05:38:00 <EvilMachine> so all i could come up with, is this analogy of a state pointer, and a large ball (visually) on top of it, that it rolls around with its feet. ;)
05:38:07 <EvilMachine> hpc: good idea
05:42:14 <EvilMachine> hmm, what would be the haskell equivalent of the following data structure (in pseudo code): a.next = pointerTo(b); b.next = pointerTo(a).
05:42:21 <EvilMachine> with data
05:43:17 <hpc> EvilMachine: zipper
05:43:29 <hpc> http://learnyouahaskell.com/zippers
05:44:16 <EvilMachine> hpc: can they deal with infinite circles too?
05:44:28 <hpc> yeah
05:44:34 <EvilMachine> interesting
05:44:40 <hpc> though you might untie the knot as you traverse it
05:44:51 <EvilMachine> i don’t know what that means
05:44:58 <hpc> like
05:44:59 <EvilMachine> ("untie")
05:45:01 <hpc> suppose you wrote
05:45:12 <hpc> let x = reallyExpensive : x in x
05:45:25 <hpc> er, bad example
05:45:30 <EvilMachine> :)
05:45:32 <hpc> but basically, you end up with recomputation
05:45:35 <hpc> ignore me :P
05:45:51 <hpc> oh, actually it's a good example
05:46:04 <EvilMachine> maybe you mean, that it can deal with *soft*links. but not infinite hardlinks?
05:46:05 <hpc> if you use x normally, the tail of the list points back to itself
05:46:24 <hpc> if you use (map id x), you now have an infinite list along the lines of [1..]
05:46:30 <hpc> with no pointer back
05:46:34 <EvilMachine> i always end up thinking in states
05:46:44 <hpc> it's just a performance detail
05:46:47 <EvilMachine> ok, i would want a pointer back
05:46:53 <EvilMachine> s/want/need
05:47:24 <hpc> anyhoo, the way a zipper works is
05:47:32 <hpc> say you zipped up [1..10]
05:47:46 <hpc> so you have zipper = List [] 1 [2..10]
05:47:55 <hpc> because you're currently "looking at" 1
05:47:59 <EvilMachine> i already can’t follow anymore
05:48:02 <hpc> oh
05:48:18 <EvilMachine> i thought zipping meant like in zip listA listB
05:48:25 * kallisti would be able to help if he knew the original problem.
05:48:26 <hpc> data Zipper a = Nil | List [a] a [a]
05:48:36 <EvilMachine> hpc: that’s a tree
05:48:36 <kallisti> EvilMachine: this is a different kind of "zip"
05:48:39 <kallisti> it's a zipper, not a zip.
05:48:52 <kallisti> a zipper is a data structure, zip is an operation
05:48:58 <EvilMachine> understood
05:48:58 <hpc> EvilMachine: not really; it's not recursive
05:49:05 <hpc> anyhoo
05:49:09 <EvilMachine> hmm
05:49:11 <EvilMachine> lol
05:49:14 <hpc> in List back cursor forward
05:49:22 <hpc> cursor is the element you are "looking at"
05:49:27 <hpc> it's kind of like "head"
05:49:37 <EvilMachine> aaah
05:49:38 <hpc> forward is kind of like "tail"
05:49:51 <kallisti> and then back is like this tumor growing out of your head.
05:49:53 <hpc> and "back" is the REVERSED list of elements you've scrolled past
05:49:54 * kallisti good analogy.
05:50:10 <hpc> so if you zip forward through [1..10] a few times, you get
05:50:28 <hpc> List [4, 3, 2, 1] 5 [6, 7, 8, 9, 10]
05:50:29 <EvilMachine> got it. so it’s like a tape. you consecutively move elements from "forward" to "a" to "back", when you "move" forward through it.
05:50:41 <kallisti> a list zipper is somewhat analogous to a doubly linked list.
05:50:52 <kallisti> EvilMachine: and yes it's very much like a tape. I use it in my brainfuck implementation.
05:50:56 <hpc> forward (List back cursor (next : rest)) = List (cursor : back) next rest
05:51:04 <hpc> back (List (you get the point
05:51:06 <kallisti> initial tape is Tape [] 0 (repeat 0)
05:51:10 <EvilMachine> hpc: understood it. :)
05:51:18 <hpc> and that's pretty much it
05:51:27 <hpc> things get confusing when you use other data structures
05:51:33 <hpc> because the notion of "reversing" changes
05:51:35 <hpc> but that's it
05:51:36 <EvilMachine> hpc: yeah, thought no. :)
05:51:56 <kallisti> in the case of trees, there are multiple ways to reverse.
05:52:07 <hpc> no, still only one way to reverse
05:52:17 <kallisti> oh?
05:52:17 <hpc> it's just that the "way up" looks like an ordinary branch
05:52:24 <EvilMachine> hpc: did you notice, that you just explained to me in a few lines, what learnyouahaskell explains in several pages? :D
05:52:26 <kallisti> ah okay.
05:52:27 <hpc> there's only one "go up" path for each node
05:52:53 <hpc> EvilMachine: LYAH does more derivation and has functions that use it
05:52:55 <EvilMachine> hpc: lol. i imagined that concept on my own before!
05:53:42 <hpc> the first zipper tutorials used trees and an awful maze analogy
05:53:56 <hpc> and shitty diagrams that didn't show you how going up the tree worked
05:53:57 <EvilMachine> hpc: so in a graph, you look at it through a “tree view" transformation. which itself can be seen through a "list view" transformation.
05:54:16 <EvilMachine> lol
05:54:20 <hpc> for a graph, i have no clue how a zipper would work :P
05:54:28 <hpc> just that it would be a lot of wonky recursion
05:54:35 <EvilMachine> the problem is the recursion
05:54:46 <kallisti> well a zipper over a graph walk would just be a list zipper
05:54:56 <hpc> a lot of graph libs represent graphs as a tuple of (nodes, edges)
05:54:56 <kallisti> I'm not sure what a "graph zipper" would even mean.
05:54:59 <hpc> or something like that
05:55:48 <kallisti> there's not really a single way to represent a graph, since all of the implementations have advantages.
05:55:54 <kallisti> depends on what you want to do with the graph.
05:56:30 <mcstar> using the scary term monad, rather than warm fuzzy thing < lol
05:56:53 * kallisti implemented a warm fuzzy thing just the other day.
05:57:53 <EvilMachine> well, i could also do it much simpler, and have data Graph a = Graph [Element a]; data Element a = Element { nr :: Index, data :: a, links :: [Link a] }; data Link a = Link { kind :: Index, elements :: [Index] }
05:58:26 <EvilMachine> oops, "Link a" should be just "Link"
05:58:59 <EvilMachine> kallisti: i know what a graph zipper could mean! yay!
05:59:10 <EvilMachine> kallisti: think of a multi-dimensional sphere
05:59:14 <azm> is there a way edit, load and reload the haskell program all in one window ?
05:59:22 <kallisti> ..
05:59:26 <EvilMachine> kallisti: now think of a needle. and the sphere stands on the needle
05:59:33 <azm> I use ghci but have o edit it in separate txt file
05:59:35 <kallisti> azm: yes. haskell-mode in emacs.
05:59:49 <azm> im in windows :/
05:59:50 <EvilMachine> kallisti: now think of every dimension as a zipper
05:59:57 <kallisti> azm: emacs can be too
06:00:00 <EvilMachine> kallisti: so a multi-dimensional zipper
06:00:02 <azm> oh great
06:00:16 <kallisti> can anyone read core? I need to figure out what's happening here..
06:00:26 <EvilMachine> kallisti: like having a ball on your feet, and rolling it. like a trackball. :D
06:00:36 <kallisti> are burritos involved?
06:00:43 <mcstar> my balls dont touch my feet
06:00:55 <mcstar> ah syr, not that kind of ball
06:01:09 <dervall> I'm confused about the function composition operator. For signature [Num] -> [Num] -> Num why does this not work: dot = foldr1 (+) . zipWith (*) but this does dot a b = foldr1 (+) (zipWIth (*) a b)
06:01:26 <mcstar> ah dervall hi, read your blog
06:01:36 <mcstar> errr, the post regarding haskell
06:01:42 <kallisti> :t (.)
06:01:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:01:46 <kallisti> er
06:01:51 <kallisti> :t (Prelude..)
06:01:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:02:05 <kallisti> dervall: because compositions type is for one argument functions (aka functions)
06:02:07 <EvilMachine> mcstar: not even your beach, basket, foot and gymnastic ones? ^^
06:02:14 <dervall> mcstar: hi :) hope you liked it
06:02:15 <kallisti> what you're doing is applying a function and then applying the result of that function
06:02:21 <kallisti> in the second example
06:02:24 <kallisti> (the one that works)
06:02:41 <kallisti> so when you do foldr1 (+) . zipWith (*)
06:02:43 <dervall> kallisti: So, composition operator can only deal with one parameter?
06:02:43 <kallisti> what you end up with is
06:02:49 <EvilMachine> hpc: any idea on how to implement a multi-dimensional zipper?
06:02:54 <mcstar> dervall: did you write that program in 2 days? starting from absolutely nothing?
06:02:56 <kallisti> (\x -> foldr1 (+) (zipWith (*) a))
06:03:02 <kallisti> er
06:03:04 <kallisti> (\x -> foldr1 (+) (zipWith (*) x))
06:03:10 <dervall> mcstar: yeah
06:03:18 <dervall> kallisti: Ah/
06:03:32 <mcstar> impressive
06:03:38 <kallisti> dervall: there are however some trick you can do, to make it work with 2-argument functions
06:03:50 <dervall> kallisti: I see! I thought it sort of pushed all of my stuff down to whatever was at the end of the chain
06:03:52 <azm> kallisti, so would you recommend the haskell for good flow coding ?
06:03:59 <azm> *emacks for hasskell
06:04:04 <kallisti> :t let (.) = (Prelude..) in (foldr1 (+) .) . zipWith (*)
06:04:05 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
06:04:12 <mcstar> however, i didnt like how you stressed that there is no good ide, you dont have to know the whole of emacs to start coding in haskell
06:04:12 <kallisti> azm: I use emacs exclusively for all programming. so yes.
06:04:20 <dervall> mcstar: Well, I have been coding for 20 years now :)
06:04:31 <dervall> mcstar: god that felt old...
06:04:34 <kallisti> dervall: (f .) . g = (\a b -> f (g a b))
06:04:36 <EvilMachine> mcstar: leksah is not *that* bad. :)
06:04:39 <kallisti> it's a point-free trick.
06:04:53 <kallisti> not recommended if you prefer people to be able to read your code at first glance.
06:05:07 <dervall> kallisti: Would it be considered good style to use that?
06:05:07 <EvilMachine> kallisti: uuum, why?
06:05:12 <EvilMachine> aah
06:05:15 <EvilMachine> oops.
06:05:26 <EvilMachine> forget what i said
06:05:26 <mcstar> dervall: specifically i didnt understand why would an ide make it easier to write a raytracer that outputs images?
06:05:31 <kallisti> dervall: it's... just a different style. some would say it's bad style. I think it is appropriate in certain places.
06:05:46 <kallisti> dervall: for readability you're better off defining a named function in a let or where clause.
06:06:09 <dervall> mcstar: well, I'm really an IDE guy, an ide makes everything easier for me to be honest
06:06:10 <kallisti> but I do use (f .) . g   in "real" code, from time to time
06:06:14 <EvilMachine> kallisti: exactly. trust no argument that is a sweeping generalization. including this one. :)
06:06:15 <kallisti> if it makes the code particularly concise.
06:06:42 <hiptobecubic> :t (id . ) . id
06:06:43 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
06:06:54 <hiptobecubic> Well that wasn't as informative as i'd hoped
06:06:54 <dervall> i think I will run with the "normal" way. I might do write only code otherwise, :)
06:07:05 <kallisti> heh, yeah.
06:07:22 <kallisti> I use it in hs-webdriver because I have a lot of very small one-line functions
06:07:54 <kallisti> and many people know what the (f .) . g trick does. Some even understand why. :P
06:08:03 <EvilMachine> lol.
06:08:11 <EvilMachine> what does it do, btw?
06:08:14 <kallisti> (if you expand it manually you'll see how it works)
06:08:29 <EvilMachine> hmm,
06:08:50 <EvilMachine> :unlambda (f .) . g
06:08:55 <EvilMachine> damn
06:09:29 <kallisti> (f .) . g  = \x -> (f .) (g x) = \x -> f . g x = \x y -> f (g x y))
06:09:51 <kallisti> -)
06:10:08 <kallisti> stupid parentheses.
06:10:45 <EvilMachine> h x y = f (g x y) -- i like that more tbh
06:10:45 <kallisti> it also generalizes
06:10:51 <kallisti> in that you can also do stuff like:
06:11:06 <kallisti> er... if I can remember how to write it.
06:11:09 <Philippa> mcstar: some people like IDEs, we can all find at least one text editor if that's what we want whether we use emacs, vi or ed
06:11:14 <EvilMachine> lool
06:12:11 <kallisti> :t let (.) = (Prelude..) in \f g h -> ((f .) . g .) . h
06:12:12 <lambdabot> forall b c a b1 a1 a2. (b -> c) -> (b1 -> a -> b) -> (a2 -> a1 -> b1) -> a2 -> a1 -> a -> c
06:12:50 <kallisti> I don't think that's right.
06:12:59 <kallisti> @unpl \f g h -> ((f .) . g .) . h
06:13:00 <lambdabot> \ f g h e n q -> f (g (h e n) q)
06:13:04 <kallisti> ..nope
06:13:12 <EvilMachine> Philippa: i like features like suggestions popping up, context-sensitive help, highlighting, built-in compilation debugging interface, refactoring… that’s what a IDE needs.
06:14:07 <kallisti> @unpl \f g h -> (((f .) . g) .) . h
06:14:07 <lambdabot> \ f g h e n q -> f (g (h e n) q)
06:14:24 <kallisti> @unpl \f g h -> ((f .) . g) . h
06:14:24 <lambdabot> \ f g h d m -> f (g (h d) m)
06:14:26 <kallisti> hm
06:14:29 * kallisti can't remember
06:14:31 <EvilMachine> i’m still thinking how to make a multi-dimensional zipper, and if it’s even possible.
06:14:37 <EvilMachine> pointers make this so much easier
06:14:38 * kallisti is bad at point-free
06:14:45 <Philippa> "multi-dimensional"?
06:14:53 <EvilMachine> kallisti: that makes you, just a human. :)
06:15:01 <EvilMachine> Philippa: yes
06:15:06 <kallisti> oh and if you want even more pointfree goodness
06:15:15 <kallisti> @unpl (.) . (.)
06:15:15 <lambdabot> (\ i b c f -> i (b c f))
06:15:41 <Philippa> EvilMachine: sorry, that was: "what/how do you mean, multi-dimensional?"
06:15:42 <EvilMachine> kallisti: the infamous double-boob. ;)
06:15:43 <kallisti> who needs those silly explicit function names.
06:16:01 <kallisti> EvilMachine: don't forget the third nipple.
06:16:13 <EvilMachine> indeed. :D
06:16:33 <EvilMachine> Philippa: well, if a zipper is like a tape that you move back and forth on, think of a sheet of paper instead, for 2 dimensions.
06:16:43 <EvilMachine> Philippa: so you can move in two directions
06:17:03 <EvilMachine> Philippa: generalize this to any amount of dimensions, and you know what i mean.
06:17:30 <EvilMachine> where every “dimension” would be a normal zipper on its own.
06:18:00 <Philippa> right. So you want to figure out a 2D analogue of lists first, no?
06:18:13 <EvilMachine> Philippa: a table? :)
06:18:25 <EvilMachine> Philippa: or just [[a]]
06:18:30 <fmap> @unpl \f g -> (. f) . g
06:18:30 <lambdabot> \ f g d i -> g d (f i)
06:18:31 <Philippa> Richard Bird did a talk on doing that with circular lists at the last Fun in the Afternoon, though I'm guessing you want finite!
06:18:52 <kallisti> a generalization of lists would need to be able to go both "right" and "down"
06:18:53 <fmap> @unpl \f g -> (. (. f)) . g
06:18:53 <lambdabot> \ f g e j -> g e (\ m -> j (f m))
06:18:53 <Philippa> yeah, a zipper of zippers will work
06:19:06 <EvilMachine> kallisti: a 2-dimensional? exactly
06:19:35 <kallisti> which [[a]] does not do.
06:20:00 <kallisti> well it does, but you lose information.
06:20:03 <Philippa> you'd have to keep a path in the inner list
06:20:09 <Philippa> or for it, rather
06:20:23 <EvilMachine> kallisti: a full generalization would be able to "go x" where x is the number of the dimension. "goRight = goForward 0" and "goDown = goForward 1", while "goAway = goForward 2"
06:20:46 <EvilMachine> kallisti: exactly. [[a]] loses information.
06:21:00 <Philippa> (what happens when the next list down isn't as long?)
06:21:02 <kallisti> this is a perfect opportunity to write "go go gadget" in actual code.
06:21:17 <kallisti> we should capitalize upon this.
06:21:25 <EvilMachine> Philippa: well, you couldn’t go there.
06:21:39 <EvilMachine> kallisti: lol
06:22:54 <EvilMachine> kallisti: i’m already starting on a module of tools then. like "go go gadgetto hammer!" (the "!" would be mandatory)
06:23:20 <EvilMachine> ok, i think i’ll give up on zippers for this.
06:23:49 <EvilMachine> Or does anyone have a better idea than: Graph a = Graph [Element a]; data Element a = Element { nr :: Index, data :: a, links :: [Link a] }; data Link a = Link { kind :: Index, elements :: [Index] }
06:23:54 <EvilMachine> oops
06:24:08 <EvilMachine> Graph a = Graph [Element a]; data Element a = Element { nr :: Index, data :: a, links :: [Link] }; data Link = Link { kind :: Index, elements :: [Index] }
06:24:29 <EvilMachine> Then I could implement an interface similar to a zipper.
06:24:45 <EvilMachine> But with a parameter to choose which link to go down.
06:25:03 <kallisti> once elliott is around you can ask him all about generalizations of zippers
06:25:08 <kallisti> as he did a lot of that pretty recently.
06:25:17 <EvilMachine> (yes, in my case, a list of elements under the same link is what i need. :)
06:25:20 <kallisti> thinks like multi-cursor zippers.
06:25:36 <EvilMachine> ah, yes, that would be needed too.
06:25:45 <Philippa> I think EvilMachine's still looking for the zipper on the right structure more than anything else?
06:25:53 <EvilMachine> but in my case, that would be as simple, as having an integer for every cursor.
06:26:58 <kallisti> that is no longer a zipper
06:27:04 <kallisti> that's just an array with indices.
06:27:50 <kallisti> data ArrayState i x = ArrayState (Array i x) i i
06:28:23 <EvilMachine> yep
06:28:35 <EvilMachine> never said it *has* to be a zipper. :)
06:28:46 <kallisti> what are our requirements again? I was never clear.
06:29:38 <EvilMachine> i want a graph data structure. with multiple pointers (as i now found out). it’s kinda like a internal "file" system, which multiple threads must be able to modify at the same time.
06:30:03 <EvilMachine> just that the "file system" is a real graph with infinite recursion/loops
06:30:38 <EvilMachine> (i wasn’t clear about that before. my bad.)
06:35:52 <kallisti> EvilMachine: well you could always just store the vertices as the "pointers"
06:36:01 <kallisti> or if you prefer
06:36:07 <kallisti> you could store the list of all of a vertices edges
06:36:11 <kallisti> as a "pointer"
06:36:24 <kallisti> but I think you can get that from the former.
06:36:37 <kallisti> using the Data.Graph library.
06:37:21 <EvilMachine> kallisti: exactly. that’s my "array with indices" solution
06:37:42 <EvilMachine> or did you mean something differently?
06:37:49 <EvilMachine> (i’m not very clear right now. :)
06:38:10 <kallisti> yes it's the same idea as the array one
06:40:46 * kallisti really needs help from someone who can read core and such
06:41:44 * EvilMachine doesn’t even know what "core" means, except "core memory from a 60s mainframe" ;)
06:41:56 <kallisti> Core is an intermediate language used by GHC
06:42:13 <EvilMachine> ah
06:42:14 <kallisti> it's a stripped down Haskell with all syntax sugar removed, and type coercions everywhere.
06:43:11 <EvilMachine> isn’t there a decompiler for Core → Haskell too?
06:43:23 <kallisti> I don't know
06:44:21 <EvilMachine> I guess Core should still be readable, if one knows haskell, no?
06:45:07 <kallisti> well, yes, I can read the syntax
06:45:10 <kallisti> but not what is going on at all.
06:45:25 <EvilMachine> lol. i know what you mean
06:46:35 <EvilMachine> Like this: „Hey Core! What always you saying, it gives zero sense, nottrue?“
06:47:17 <Saizan> kallisti: -dsuppress-* flags don't help=
06:47:19 <Saizan> ?
06:47:28 <kallisti> Saizan: I'm using ghc-core. doesn't help
06:47:38 <kallisti> I just need to see if ByteStrings are being converted into Strings..
06:47:39 <Saizan> ghc-core doesn't use those flags
06:47:47 <kallisti> but I don't know enough about the internals of either to figure out if that's what is happening
06:49:13 <kallisti> Saizan: you mean suppress-coercions?
06:51:17 <kallisti> oh
06:51:32 <kallisti> so at the top of ghc-core
06:51:37 <kallisti> is a simplified version of my code
06:51:39 * kallisti didn't see that.
06:51:42 <EvilMachine> hey kallisti, hpc, i found it! GHC itself uses a zipper that works on graphs interntally! see the answer by Norman Ramsey: http://stackoverflow.com/questions/9732084/how-do-you-represent-a-graph-in-haskell
06:51:44 <kallisti> at least I think that's what I'm looking at.
06:52:04 <kallisti> oh no
06:52:06 <kallisti> that's not quite what I want
06:52:14 <kallisti> it doesn't remove the TH
06:54:28 <hpc> oh hey, the phrase "untying the knot" isn't something i just made up on the spot :D
06:54:38 <hpc> yay me for stumbling into the correct terminology
06:54:47 <hpc> also neat
06:55:34 <EvilMachine> Paragraphs like these frighten me: The glorious Glasgow Haskell Compiler (GHC) uses two internal languages, both immutable: a high-level intermediate language descended from the spineless, tagless G-machine (Peyton Jones 1992); and a low-level language closely resembling a subset of C--. In the low-level language, each basic block has a unique identifier, and the implementation makes heavy use of a polymorphic unique finit
06:55:34 <EvilMachine> e map, which uses unique identifiers as keys.
06:56:02 <hpc> they got the name wrong
06:56:11 <hpc> Glorious Glasgow Haskell Compilation System
06:56:20 <hpc> ;)
06:56:41 <hpc> it's common for compilers to have multiple internal languages
06:56:51 <Saizan> Core is neither of those btw
06:57:05 <hpc> you can perform optimization passes at different levels of abstraction
06:57:11 <SpinelessTagless> Gargantuan Glorious Glasgow Haskell Compilation System System … System.
06:57:35 <kallisti> the paper on STG is actually pretty interesting.
06:58:28 <kallisti> hmm, is there a way to remove TH from the Core?
06:58:29 <EvilMachine> When you, as a mere programmer, have to read not one, but two papers, one of which written for another programming language, to be able to do something, you know that something’s not right. ;)
06:58:33 <kallisti> I think I might be seeing a lot of TH.
06:58:48 <kallisti> EvilMachine: you don't have to read the paper on STG to do anything in Haskell.
06:58:56 <EvilMachine> kallisti: feed it through the TH pre-processor?
06:59:05 <kallisti> is that a thing?
06:59:45 <EvilMachine> kallisti: What about being able to do what Norman Ramsey says in http://stackoverflow.com/questions/9732084/how-do-you-represent-a-graph-in-haskell
07:00:04 <EvilMachine> kallisti: don’t get me wrong btw. i like haskell a lot. :)
07:00:42 <kallisti> tying the knot is not very complicated
07:00:47 <hpc> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Practical_Graph_Handling -- go with this
07:01:10 <hpc> tying the knot is hard for sufficiently complex graphs
07:01:15 <hpc> and has dubious benefits
07:03:14 <EvilMachine> Contrary to popular belief, it’s called “tying the knot”, because you will end up hanging yourself, if you do it too often. ;)
07:03:49 <EvilMachine> thanks, hpc! :)
07:04:45 <EvilMachine> Why do i read that like it’s swearing: “A PhD thesis has been written on the subject of graphs and functional programming #king-thesis 2”
07:04:57 <EvilMachine> Damn that #king thesis!
07:05:02 <EvilMachine> ;)
07:05:22 <mcstar> learning haskell will make me a better programmer, even if i will not use haskell in practice
07:05:29 <mcstar> hm, where did i hear this before
07:05:37 <boccato> I am new to haskell, at chapter 7 of http://learnyouahaskell.com/, does anyone have a sugestion as to a test framework for me to start making little programs?
07:05:44 <EvilMachine> mcstar: :) You don’t have to convince me.
07:05:58 <EvilMachine> boccato: Quickcheck?
07:06:02 <EvilMachine> boccato: HUnit?
07:06:26 <EvilMachine> boccato: You will like this: http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
07:07:25 * hackagebot wxc 0.90.0.1 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.0.1 (JeremyODonoghue)
07:07:30 <boccato> I found those two in a quick search, it seems to me HUnit is easier for people who come from imperative languages.
07:08:07 <boccato> The book seems interesting! Thanks for the link!
07:08:14 <EvilMachine> boccato: I wouldn’t call Quickcheck hard. I would at least give that chapter from realworldhaskell a try, and decide then.
07:08:44 <kallisti> uh, stupid git question: how do I take an old commit and put it in my working tree?
07:08:52 <kallisti> I've tried reset and checkout but they don't seem to actually modify any files.
07:09:25 <EvilMachine> you mean in git?
07:09:29 <kallisti> yes
07:09:34 <boccato> Hard was not what I meant, just trying to learn one thing at a time an not get overwhelmed... though the immerse yourself in the language way is also quite appealing :)
07:10:16 <EvilMachine> boccato: yes, it’s imperative to keep the right balance between too hard and too easy. after all, that’s half of what makes a genius.
07:10:32 <EvilMachine> kallisti: hmm… sorry, i also don’t know. :/
07:10:43 <EvilMachine> kallisti: → #git ?
07:10:51 <kallisti> perhaps
07:14:12 <boccato> Well, thanks for confirming that by looking at HUnit and Quickcheck im on the right track.
07:14:26 <EvilMachine> :)
07:16:03 <EvilMachine> hmm… a monad can be seen as a kind of unfold of the monad into the world, or fold of actions into the monad, right?
07:18:37 <mauke> kallisti: from looking at the manual it seems git reset --keep <commit> does that
07:19:11 <kallisti> I figured it out. I wanted checkout
07:19:16 <kallisti> I just had it in a weird state previously or something...
07:19:25 <navaati> hi
07:21:00 <mauke> ah, is it git checkout -p <commit>?
07:21:41 <kallisti> no just checkout actually
07:21:46 <kallisti> seems to work fine
07:21:52 <kallisti> but previously it wasn't modifying any files... I'm not sure why
07:22:03 <kallisti> I deleted the directory, recloned, then did a checkout and it worked.
07:22:12 * kallisti is bad at git, obviously. :P
07:22:19 <mauke> ah, I see
07:25:47 <boccato> Do you guys use anything other than an editor an GHCI to develop? Maybe something like CLs SLIME?
07:25:58 <boccato> and*
07:26:03 <EvilMachine> boccato: I use leksah
07:27:02 <kallisti> hmm I don't think any rules are firing..
07:27:25 * hackagebot wxc 0.90.0.2 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.0.2 (JeremyODonoghue)
07:27:27 <kallisti> one sec
07:28:11 <kallisti> http://sprunge.us/aDPc?haskell  here's the source file
07:28:22 <kallisti> http://sprunge.us/cVjR?haskell  ghc-core output
07:28:32 <boccato> EvilMachine: Looks cool! I'll check it out.
07:28:43 <kallisti> I'm trying to see if the ByteString rewrite rules automatically remove a redundant conversion to string.
07:29:00 <kallisti> as elliott suggests that it would do that, but I'm not seeing where that happens.
07:29:38 <kallisti> oh let me turn off color
07:30:04 <kallisti> http://sprunge.us/EWVP?haskell  color codes removed
07:30:09 <EvilMachine> i think it should be illegal to write "unfoldG :: (Ord s) => (s -> (n, [(e, s)])) -> s -> (Vertex, LabGraph n e) -- where s is the seed type, n is the node labels, e the edges labels" instead of "unfoldG :: (Ord seed) => (seed -> (nodeLabel, [(edgeLabel, seed)])) -> seed -> (Vertex, LabGraph nodeLabel edgeLabel)". While the latter in naturally readable, the former is a PITA. ;)
07:31:06 <Saizan> EvilMachine: it's the opposite for me
07:31:09 <kallisti> yes English does wonders to self-document type expressions
07:31:24 <kallisti> but if you already know that letters mean, they're quicker to read.
07:31:27 <kallisti> *the
07:31:47 <EvilMachine> Saizan: There really seem to be two kinds of people. And most mathematicians are the kind that I don’t understand. :(
07:31:48 <exFalso> how can one check whether ghc is compiled with profiling info?
07:32:02 <kallisti> I think $wa is doing a conversion to string but I'm not sure.
07:32:02 <Saizan> kallisti: under RuleFired you can see the names of the rules which fired
07:32:09 <EvilMachine> Saizan: But i would really love to understand your way of thinking. So I can use both ways.
07:32:28 <kallisti> Saizan: yes, which further suggests that nothing fired.
07:32:43 <EvilMachine> kallisti: to me, it’s just one more level of indirection. :/
07:32:45 <kallisti> (nothing relevant to what I'm looking for, I mean)
07:33:25 <kallisti> hm, so, IncoherentInstances magic it is..
07:33:31 <kallisti> since that works fine.
07:33:46 <kallisti> and has the same drawbacks, in fact.
07:33:58 <EvilMachine> Saizan: You’re not living in Cologne, btw?
07:34:46 <kallisti> Saizan: so yeah it looks like it's converting to a string and back, yes?
07:35:17 <kallisti> so I either need to come up with a clever rewrite rule, or use what I was using before.
07:36:04 <Saizan> kallisti: $wa is converting to String
07:36:12 <kallisti> yeah
07:36:19 <Saizan> EvilMachine: nope
07:36:27 <kallisti> so I tried a rule like this
07:36:37 <kallisti> forall s. fromString (showQ s) = s
07:36:40 <kallisti> but that didn't work either.
07:36:46 <kallisti> I'm thinking because other optimizations happen
07:36:48 <kallisti> before that.
07:37:23 <EvilMachine> Saizan: Ok. I would offer a couple of beers or something alike to somebody who’d teach me how to think that "other" way. ^^
07:37:33 <kallisti> (the optimization is to avoid unecessary conversion to string when the string is just going to be converted back into the previous type)
07:37:59 <kallisti> currently I use a typeclass hack to make that happen.
07:38:12 <kallisti> and I'd rather not.
07:38:20 <kallisti> but it seems to work. whereas so far nothing else is.
07:38:58 <navaati> does alloca set the memory to 0 ? if not, is tehre something like memset ?
07:39:42 <kallisti> navaati: yep
07:40:05 <navaati> yep it does zeroes the memory ? perfect, thanks
07:40:11 <kallisti> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Internal.html
07:40:12 <Saizan> EvilMachine: anyhow my way of thinking is that longer names obscure the structure of the type which is what matters most to me, and i deduce what type variables stand for by how they are used (e.g. LabGraph n e tells me a lot about n and e if i know what LabGraph is)
07:40:15 <kallisti> no I mean "yep there is a memset"
07:40:37 <kallisti> I think whether or not alloca zeroes the memory is implementation specific
07:40:56 <kallisti> why do you need to zero it exactly?
07:41:15 <Saizan> EvilMachine: conventions also help
07:41:32 <kallisti> navaati: ^
07:41:40 <EvilMachine> Saizan: see, i think that having to deduce things, instead of seeing them directly, is wasting me mental energy. everything becomes harder.
07:41:49 <navaati> kallisti: ah, and where is this memset function ? can't find it in Foreign.Marshall
07:41:57 <kallisti> I sent you a link above
07:42:03 <kallisti> it's in Data.ByteString
07:42:07 <kallisti> .Internal
07:42:35 <mauke> kallisti: don't use internal bytestring functions :-[
07:42:43 <navaati> hum, having to link to bytestring just for that…
07:43:07 <kallisti> well, it /is/ a bytestring you're dealing with. :P
07:43:20 <kallisti> the big bytestring of RAM. :P
07:43:22 <navaati> i need to memset because it's less cumbersome than to manually put to 0 every field of my struct
07:43:31 <kallisti> er
07:43:34 <EvilMachine> Saizan: but yeah, i noticed how people who think your way focus more on the structure. makes sense, i guess, but to me that’s so orthogonal to my thoughts, that i can’t even find words for it. :(
07:43:53 <mauke> navaati: what are the types of your struct fields?
07:44:06 <kallisti> navaati: I'm not sure that you want to muck around with the internal representation of structs by setting everything to 0
07:44:17 <kallisti> but you might be able to get away with it.
07:45:13 <EvilMachine> Saizan: (it’s hard not to sound offensive like “you people, i can’t even find words for it!” right now. of course it’s not meant that way. it’s just really complicated for me right now. :)
07:45:38 <navaati> mauke: just a few numbers, it's not worth linking to bytestring just for that, i'll do it by hand
07:46:30 <mauke> navaati: well, you can always do something like pokeArray ptr (replicate n 0)
07:46:37 <navaati> kallisti: i do, i'm preparing an ioctl argument
07:46:45 <mauke> ah, fun
07:46:55 <EvilMachine> XD
07:46:57 <kallisti> mauke: that would require a ptr cast, no?
07:47:02 <mauke> ioctl isn't even directly FFiable
07:47:19 <navaati> mauke: what do you mean ?
07:47:27 <mauke> kallisti: yes, if it's not already a chunk of bytes
07:47:40 <mauke> navaati: ioctl is a varargs function
07:47:56 <kallisti> it is possible to get at varargs functions.
07:48:12 <kallisti> via libffi
07:48:18 <mauke> what is libffi?
07:48:24 <kallisti> http://hackage.haskell.org/packages/archive/libffi/0.1/doc/html/Foreign-LibFFI.html
07:48:26 <hpc> @hoogle libffi
07:48:26 <lambdabot> package libffi
07:48:26 <lambdabot> package bindings-libffi
07:48:30 <kallisti> good question. I'm not sure. but there's a binding to it.
07:48:32 <navaati> mauke: ah, the call convention is not the same ? heck…
07:48:49 <kallisti> I've used it in another project that required calling a varargs function and it worked.
07:48:59 <navaati> anyway, i use a wrapper around ioctl which is not vararg, so it should be ok
07:49:06 <mauke> kallisti: I'd just write a C wrapper for that
07:49:23 <navaati> but it explains why i got strange results when i tired to call directly ioctl…
07:49:27 <kallisti> sure, that works too.
07:49:35 <mauke> ah, libffi is for runtime imports
07:49:36 <kallisti> my goal was to write as little C as possible.
07:49:46 <kallisti> though in a "real" project I'd write C wrappers.
07:50:32 <mauke> and it reifies types as values
07:53:58 <mauke> kallisti: libffi only added support for variadic functions 3 days ago
07:55:44 <mauke> and indeed Foreign.LibFFI has no bindings to ffi_prep_cif_var
07:56:35 <mauke> kallisti: your code only worked by accident and probably would've  worked the same way with a normal 'foreign import' declaration
08:01:26 <Fermat618> #haskell
08:02:09 <c_wraith> Fermat618: you have identified your location
08:04:32 <luite_> hm, what's the usualy way to create a new storable MVector?
08:11:59 <wli> I've been out of the loop too long to know, sorry.
08:13:36 <hpc> luite_: what package is it in? hoogle is not helping
08:13:39 <luite_> wli: oh I think i missed the new function the first time i read the docs
08:14:26 <luite_> hpc: in vector, but i think I already have it :)
08:14:46 <hpc> glad i could help ;)
08:17:13 <EvilMachine> by the way: is there a tool that allows you to generate a Haskell wrapper module from any C header file (plus compiled library?)?
08:18:06 <hpc> there's tools
08:18:12 <hpc> probably not ANY header
08:20:04 <mysticc> Not a haskell question , but what do you use to draw textual diagram like this http://www.w3.org/2006/02/woa/#(9) .. I dont think you'll have to manually manipulate all space alignment
08:21:33 <ClaudiusMaximus> mysticc: istr emacs having a box drawing mode (but i don't use emacs myself)
08:21:52 <hpc> mysticc: basically, imagine each character is a pixel
08:21:58 <hpc> with row/col number being the coordinates on screen
08:22:07 <mcstar> why is it easy to put something in a monad, but it is hard to get it out?
08:22:24 <hpc> and you don't have color, but you do have some "is it going up/down, left/right, corner piece" information
08:22:43 <mysticc> ClaudiusMaximus: hpc: Is there a vim version of something similar
08:22:51 <hpc> mcstar: because there's no (m a -> a) function that's polymorphic in m
08:22:56 <Cale> mysticc: I would just do it by hand :P
08:23:21 <mauke> mcstar: because "a monad" could be any monad and there's no general function for it
08:23:23 <Cale> Though it can help to make a bunch of spaces first and then use overwrite mode
08:23:28 <Rotaerk> mcstar, monads by definition have a function for constructing a monadic type from an underlying type
08:23:36 <Rotaerk> but don't necessarily have the reverse
08:23:56 <hpc> mcstar: it's a feature of some monads that you can't get pure values out at all
08:24:17 <mauke> mcstar: also, why is it easy to put something in a list, but it is hard to get it out? :-)
08:24:18 <mcstar> hm, ill try to comprehend this
08:24:37 <Cale> mcstar: Many specific monads have some function you can use to execute the composed action that the monadic value represents, but typically more information is required than just the action itself.
08:24:37 <mcstar> it isnt particularly hard with a list, is it?
08:24:44 <mauke> mcstar: I think it is
08:24:57 <mauke> mcstar: you have to somehow deal with the case where the list is empty or has more than one element
08:25:08 <mcstar> true
08:25:21 <mcstar> some people criticise list for that
08:25:24 <mauke> haha
08:25:27 <mcstar> head []
08:25:27 <Cale> ?
08:25:40 <Cale> Oh, that's more of a criticism of head and tail, than of lists.
08:25:47 <mcstar> ah, ok
08:25:57 <mauke> mcstar: and Reader requires a deposit before you get anything back
08:26:00 <mauke> :t runReader
08:26:01 <lambdabot> forall r a. Reader r a -> r -> a
08:26:13 <mauke> here you have to input an 'r' before you get an 'a' out
08:26:14 <Cale> head and tail are useful in some cases, but they shouldn't be the first thing you run to when deconstructing a list
08:26:48 <mcstar> anyway, when i will have a bette runderstanding of monads, ill draw a picture of them
08:26:56 <mcstar> (i have an idea, but maybe it is flawed)
08:27:00 <Cale> (and I've actually found it better in many cases to write the lambda:  (\(x:xs) -> x)  rather than use head, because if that has a pattern match failure, you get a line number.
08:27:02 <Cale> )
08:27:08 <copumpkin> draw a picture of monads :O
08:27:09 <mauke> mcstar: draw a picture of monoids first
08:27:19 <mauke> and then of functors
08:27:22 <mcstar> mauke: what are those?
08:27:28 * hackagebot variable-precision 0.1.1 - variable-precision floating point  http://hackage.haskell.org/package/variable-precision-0.1.1 (ClaudeHeilandAllen)
08:27:30 <mcstar> i heard the name but...
08:27:33 <mauke> @src Monoid
08:27:33 <lambdabot> class Monoid a where
08:27:33 <lambdabot>     mempty  :: a
08:27:34 <lambdabot>     mappend :: a -> a -> a
08:27:34 <lambdabot>     mconcat :: [a] -> a
08:27:47 <copumpkin> here's a photography of a monad: http://bit.ly/az9sOJ
08:27:53 <copumpkin> -y
08:27:54 <Cale> There are a number of pictures one could draw for monads...
08:28:08 <Cale> But the nicest one I've seen is the string diagram picture. :)
08:28:13 <c_wraith> copumpkin: I was expecting a dot
08:28:14 <mcstar> that monad is tasty
08:28:17 <copumpkin> :)
08:28:40 <mauke> why is it easy to put something in a burrito, but it is hard to get it out?
08:28:47 <mcstar> lol
08:28:52 <mcstar> thats an apple pie
08:29:01 <copumpkin> mauke: because it's wrapped so tightly
08:29:10 <mcstar> mauke: because you ate the vurrito?
08:29:28 <EvilMachine> > let x = x
08:29:29 <lambdabot>   not an expression: `let x = x'
08:29:37 <EvilMachine> > x = x
08:29:38 <lambdabot>   <no location info>: parse error on input `='
08:29:41 <Saizan> the problem is that the burrito might taste like something but you can't be quite sure what's really there
08:29:42 <EvilMachine> ^^
08:30:25 <EvilMachine> mauke: because using analogies with monads only makes understanding them harder. ^^
08:30:32 <mcstar> is it like pouring water into water, and trying to get back the original water?
08:30:57 <Cale> If you have a diagram in the category of categories, involving some categories, functors between categories, and natural transformations between parallel functors, it's possible to "dualise" the diagram, representing the categories as 2-dimensional regions, the functors as 1-dimensional boundaries between those regions ("strings"), and the natural transformations as 0-dimensional points (usually bubbles so that you can
08:30:58 <Cale>  write a label in them) where those boundaries meet.
08:31:32 <mauke> why is it easy to make an analogy of something, but it is hard to get something out of it?
08:31:45 <EvilMachine> why does ghci allow this: data XD funny = XD funny | BOO funny; isFunny age joke = if (age > 100) then False else isJust $ (find (=="Haskell")) $ words $ joke; tell joke = tell' 0 joke where tell' age joke = if isFunny age joke then (XD joke) : tell' (age+1) joke else [BOO joke]
08:32:02 <Cale> and you can draw the diagrams for the monad laws, and they have a nice topological quality to them
08:32:24 <byorgey> well, really it's the diagrams for adjunctions that have a nice topological quality to them
08:32:30 <wli> Trying to figure out how to download stuff via http.
08:32:33 <Cale> Yeah, those do as well :)
08:32:45 <EvilMachine> looks like a bug in ghci, to allow functions after a data declaration, without let even, but not to use them.
08:32:56 <byorgey> and it becomes topologically obvious why composing adjoint functors gives you a monad
08:33:09 <EvilMachine> wli: a cURL analogon for Haskell?
08:33:25 <Cale> yeah
08:33:40 <wli> EvilMachine: I've already got one, but supposedly the HTTP module is more typically used.
08:33:46 <EvilMachine> ah
08:33:56 <fuzzy_id> I'm trying `:list last' in ghci but I get ‘cannot list source […] GHC.List is not interpreted’
08:34:19 <fuzzy_id> is there some way to provide the code to ghci, so that it can look it up?
08:34:39 <mcstar> theres the online doc
08:35:13 <mcstar> anyway, my understanding of monads increased 10 fold
08:35:20 <mcstar> 10 foldl'
08:35:50 <hpc> > 10 foldl'
08:35:51 <lambdabot>   10
08:35:58 <azaq23> EvilMachine: what do you mean: "to allow functions after a data declaration, without let even, but not to use them"
08:36:17 <EvilMachine> azaq23: open ghci
08:36:28 <EvilMachine> azaq23: put this in: data XD funny = XD funny | BOO funny; isFunny age joke = if (age > 100) then False else isJust $ (find (=="Haskell")) $ words $ joke; tell joke = tell' 0 joke where tell' age joke = if isFunny age joke then (XD joke) : tell' (age+1) joke else [BOO joke]
08:36:33 <EvilMachine> azaq23: ghci doesn’t complain
08:36:43 <EvilMachine> azaq23: but you can’t use any of the defined functions
08:38:28 <fuzzy_id> mcstar: could you hint me to the docs/source for GHC.List? Still quite new to haskell… :/
08:38:51 <EvilMachine> fuzzy_id: http://www.haskell.org/ghc/docs/latest/html/ and from then on…
08:38:57 <mcstar> fuzzy_id: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
08:39:11 <mcstar> choose the module, choose the definition, click source
08:39:25 <mcstar> btw, you can have that doc offline too
08:39:28 <EvilMachine> exactly. fuzzy_id: in every page for a module, there is a link to the source.
08:39:28 <azaq23> EvilMachine: oh, that makes the issue clearer. though other people will need to comment on this, as I still command a version of ghci where you cannot declare an algebraic data type.
08:39:41 <EvilMachine> azaq23: lol.
08:40:09 <EvilMachine> azaq23: i think it’s a good feature, and serves the purpose of ghci: to interactively try things out.
08:40:16 <EvilMachine> azaq23: why limit that for no reason?
08:41:03 <fuzzy_id>  allright, got it; GHC.List doesn't appear per se; but List does. that was where I got confused
08:42:06 <azaq23> EvilMachine: I agree, and I did not state it was a bad feature; my system is just a little bit too broken so I can't upgrade packages without some effort, for which I was too lazy so far, as well as
08:42:07 <azaq23> for manually installing a new version
08:42:08 <mcstar> once i was trying to find the (:), well it isnt there
08:42:36 <mauke> @src []
08:42:36 <lambdabot> data [] a = [] | a : [a]
08:42:37 <mcstar> :i (:)
08:42:40 <mauke> there it is
08:42:48 <mcstar> > :i (:)
08:42:49 <lambdabot>   <no location info>: parse error on input `:'
08:42:52 <mcstar> bah
08:43:03 <mcstar> @i (:)
08:43:03 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
08:43:09 <mcstar> yes
08:43:22 <EvilMachine> mcstar: : is not really a function. It’s a data constructor
08:43:42 <mcstar> yeah, but ghci said it is defined in GHC.Types, and it wasnt tehre
08:44:02 <Cale> http://cale.yi.org/share/monadlaws.png
08:44:12 <Cale> ^^ the diagrams that I mentioned
08:44:40 <mcstar> Cale: whic axis is space, and which is time?
08:44:42 <Cale> μ = join
08:44:52 <Cale> η = return
08:44:58 <EvilMachine> Cale: seems to be missing some kind of direction arrow on those lines (?)
08:45:00 <mauke> mcstar: x = math; y = math
08:45:05 <Cale> The diagrams go from bottom to top
08:45:17 <EvilMachine> Cale: ah
08:45:25 <mcstar> im joking, from far away they look like space-time diagrams
08:45:53 <EvilMachine> they reminded me of Feynman diagrams
08:45:58 <Cale> There's a sense in which they are the same diagrams which physicists draw to indicate subatomic particle interactions
08:45:59 <mcstar> ^^^
08:45:59 <EvilMachine> turned 90°
08:46:03 <Cale> (Feynman diagrams)
08:46:15 <Cale> But I don't know the details of that connection
08:46:32 <Cale> There's apparently some weak-2-category which Feynman diagrams inhabit
08:46:51 <mcstar> really, these arent just feynman diagrams
08:46:57 <EvilMachine> they would describe fusions of particles ^^
08:46:58 <mcstar> there are all kinds of diagrams
08:47:02 <Cale> and this notation applies to any weak-2-category, including the category of categories which these are in
08:47:08 <mcstar> like calculating in perturbation theory
08:47:29 <Cale> (which is actually a strict 2-category
08:47:30 <Cale> )
08:47:41 <mcstar> should i save that picture? is it important?
08:47:52 <EvilMachine> mcstar: we’re talking about fuzzy human associations here. go away with your evil strict math! :D
08:48:32 * mcstar tilts his head like a dog does
08:48:52 * EvilMachine ’s heart warms, and he can’t say no.
08:48:52 <Cale> mcstar: It's not too important, but you can save it if you like
08:49:23 <Cale> Who is talking about fuzzy human associations?
08:49:50 <EvilMachine> Cale: Yeah, I know… How disgusting, right? :P
08:52:36 <mcstar> im done browsing your pictures
08:52:56 <Cale> heh
08:53:14 <mcstar> Cale: that picture of me, isnt really me
08:53:23 <Cale> lol
09:07:00 <skirmis> Does anybody know how to run cabal-install bootstrap with --global --root-cmd=sudo?
09:07:25 <skirmis> Getting: unrecognized option `--root-cmd=sudo'
09:08:10 <skirmis> When I add --root-cmd=sudo into bootstrap.sh.
09:10:03 <Saizan> --root-cmd is a cabal-install flag, not a Cabal one
09:10:25 <Saizan> you want to add a sudo around the call to Setup install
09:10:48 <skirmis> Thanks, will try it.
09:10:57 <Saizan> (though i'd stick to an user install)
09:11:51 <skirmis> I know everybody does user installs but I need to share packages across several accounts.
09:12:56 * wli grabs sqlite since it's not a good idea to reinvent databases.
09:16:57 <wli> Hmm, HTTP returns the result as a String. Is that safe for binary data?
09:17:28 <luite_> you could use http-conduit to get a binary conduit or a lazy ByteString
09:18:44 <wli> luite: I've got that installed. Checking docs.
09:18:46 <luite_> string decodes the data into characters, doesn't soun ideal
09:18:49 <kallisti> luite_: HTTP doesn't require you to use String
09:18:52 <kallisti> you can use Bytestring
09:19:14 <wli> Let me see what zip-archive wants out of it.
09:19:18 <luite_> ok, in that case use that :)
09:19:30 <luite_> unless you need streaming, then conduit is probably still better
09:19:33 <kallisti> wli: make sure you're using the latest version if you plan to license under BSD3
09:19:36 <kallisti> as before that it's GPL
09:19:41 <kallisti> (zip-archive that is)
09:20:06 <kallisti> wli: it uses lazy bytestrings
09:22:15 <kallisti> luite_: wli: http-conduit also does keepalive stuff, which is a bit trickier to set up with HTTP IIRC.
09:22:18 <wli> kallisti: I'm trying to do traveling salesman stuff from GTFS data for my own personal planning purposes so I'm not very concerned about the license (or releasing publicly at all).
09:22:52 <kallisti> if you're making multiple repeated requests then keep-alive will give you substantial performance improvements.
09:24:36 <wli> It's periodically refreshed stuff on an infrequent basis so keepalive's irrelevant. Sounds like normal HTTP's bytestring bits are all that's needed.
09:24:40 <luite_> and http-conduit does https
09:26:57 <kallisti> wli: oh it also requires 0 use of conduits
09:27:03 <kallisti> so there's pretty much no reason not to use it. :P
09:27:23 <wli> http://hackage.haskell.org/packages/archive/zip-archive/0.1.1.8/doc/html/Codec-Archive-Zip.html <— hmm, no obvious bytestring there
09:28:14 <kallisti> wli: look harder
09:30:08 <kallisti> wli: see "toEntry"
09:30:37 <kallisti> for creating zip archives.
09:30:42 <kallisti> fromEntry for the inverse.
09:32:07 <wli> toArchive looks like it
09:36:36 <kallisti> wli: where are you getting the bytestring from?
09:37:30 <wli> kallisti: Downloading URL's probably with simpleHTTP from e.g. http://www.mta.info/developers/data/nyct/subway/google_transit.zip and other similar URL's
09:37:42 <kallisti> ah okay
09:37:50 <kallisti> I thought you want to programatticaly construct an archive or something.
09:37:59 * kallisti does this for one of his projects.
09:38:08 <wli> kallisti: The reverse, really.
09:39:51 <wli> kallisti: The intent is to do something traveling salesman -like from the data I'm grabbing this way and plan my days out.
09:40:44 <Tinned_Tuna> Hi, is using QuickCheck like this reasonable? https://github.com/TinnedTuna/Haskell-Binary-Search/blob/master/binarySearchTests.hs
09:41:00 <Tinned_Tuna> QuickCheck is failing to generate reasonable test data for it, hence giving up regularly
09:44:14 <saml> > quickcheck
09:44:14 <lambdabot>   Not in scope: `quickcheck'
09:47:58 <ClaudiusMaximus> Tinned_Tuna: i'd take a different approach to avoid generating masses of test data and then discarding almost all of it because it doesn't meet the precondition - i'd do:   prop_contains :: [Int] -> Property ; prop_contains xs = let ys = sort xs in all [ binarySearch ys y | y <- ys ]
09:49:06 <ClaudiusMaximus> Tinned_Tuna: there is probably a way to split it up into something more like your original code, but i'm n00b at quickcheck
09:49:53 <Tinned_Tuna> ClaudiusMaximus: thanks, I'll give it a go :-)
09:50:02 <ClaudiusMaximus> :t all -- oops
09:50:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:50:09 <ClaudiusMaximus> :t and -- should work
09:50:10 <lambdabot> [Bool] -> Bool
09:54:47 <Tinned_Tuna> ClaudiusMaximus: that's worked great, thanks :-D
09:57:29 <ForSpareParts> Hey, guys, quick Parsec question:
09:57:32 <hpaste_> ForSpareParts pasted “parsec?” at http://hpaste.org/66958
09:57:52 <eph3meral> is there an algorithms channel? like for machine learning? lcs?
09:57:53 <ForSpareParts> first and third lines work, second won't compile
09:57:57 <ForSpareParts> anyone know why?
09:58:05 <eph3meral> are there any/many machine learning libs for haskell?
09:58:12 <kallisti> > ['a'..'z']
09:58:12 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
09:58:33 <kallisti> ForSpareParts: is that the entire file?
09:59:07 <ForSpareParts> No, there's a lot more. Part of an "implement Scheme" assignment for my languages class. hold on a sec...
09:59:18 * kallisti sees nothing wrong with that line.
09:59:34 <kallisti> I suspect it has to do with something else.
10:00:34 <hpaste_> ForSpareParts pasted “everything” at http://hpaste.org/66959
10:01:09 <ForSpareParts> that's the whole thing -- I'm honestly really confused.
10:01:30 <kallisti> type error would help,
10:01:47 <ForSpareParts> Most of that came from the assignment, but I've added to it slightly -- originally the file only had definitions for a single digit, digits together, and the ability to parse one digit
10:01:47 <cwl> Is there a safe version of read
10:01:53 <kallisti> cwl: yep. see reads
10:02:02 <kallisti> > reads "2" :: ReadS Int
10:02:02 <cwl> kallisti: thanks
10:02:03 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
10:02:03 <lambdabot>           ...
10:02:09 <kallisti> er
10:02:17 <cwl> ...
10:02:39 <kallisti> > reads "2" :: Text.Read.Reads Int
10:02:40 <lambdabot>   Not in scope: type constructor or class `Text.Read.Reads'
10:02:43 <kallisti> hm
10:02:43 <cwl> String -> Maybe a
10:02:46 <kallisti> > reads "2" :: Text.Read.ReadS Int
10:02:47 <lambdabot>   Not in scope: type constructor or class `Text.Read.ReadS'
10:02:53 <kallisti> cwl: not wuite
10:02:56 <kallisti> *quite
10:03:22 <kallisti> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Text-Read.html
10:03:36 <kallisti> > reads "2" [(Int, String)]
10:03:37 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `String'
10:03:42 <kallisti> ...wat
10:03:48 <hayashi> @l \(x,y) -> (y,x)
10:03:48 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . ? @ pl v
10:03:48 <kallisti> > reads "2" :: [(Int, String)]
10:03:49 <lambdabot>   [(2,"")]
10:03:56 <hayashi> @pl \(x,y) -> (y,x)
10:03:56 <lambdabot> uncurry (flip (,))
10:04:11 <cwl> > reads "2"
10:04:11 <lambdabot>   []
10:04:29 <kallisti> lambdabot defaults ambiguous types to () for some reason.
10:04:29 <cwl> > :t reads "2"
10:04:30 <lambdabot>   <no location info>: parse error on input `:'
10:04:35 <kallisti> :t reads
10:04:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:04:39 <cwl> @type reads "2"
10:04:39 <lambdabot> forall a. (Read a) => [(a, String)]
10:05:03 <kallisti> cwl: the list is always size 0 or 1
10:05:04 <cwl> > reads "2" :: [(Int, String)]
10:05:05 <lambdabot>   [(2,"")]
10:05:08 <kallisti> which is why it should really be a Maybe
10:05:32 <cwl> kallisti: good, that is what I want
10:05:41 <kallisti> yep!
10:07:28 <cwl> > reads "2xxx" :: [(Int, String)]
10:07:29 <lambdabot>   [(2,"xxx")]
10:08:17 <zhulikas> c_wraith, are you here?
10:08:23 <c_wraith> yeah, I'm around
10:08:40 <zhulikas> remember the problem I was struggling with yesterday?
10:08:58 <c_wraith> only vaguely. That was right before I suddenly slept for 10 hours :)
10:09:05 <zhulikas> that non-existent function... takeWhile + scanl as you described it (or someone else)
10:09:09 <c_wraith> ah, yes
10:09:12 <c_wraith> I do remember that
10:09:21 <wli> Having trouble with http-conduit:
10:09:22 <wli> command line>: cannot satisfy -package-id text-0.11.1.5-c38e02e7e9ae20e85e18db674dc25026:
10:09:22 <wli>     text-0.11.1.5-c38e02e7e9ae20e85e18db674dc25026 is shadowed by package text-0.11.1.5-06781a638835fee88eff5d48c0d8e125
10:09:23 <wli>     (use -v for more information)
10:09:52 <hpaste_> zhulikas pasted “lazy fold until some point (or whatever)” at http://hpaste.org/66960
10:10:04 <zhulikas> here it is
10:10:25 <zhulikas> works perfectly
10:10:38 <c_wraith> hlint, you're terrible.  case on boolean is usually cleaner than an if
10:11:03 <zhulikas> with memoized list I didn't find a result in 10 seconds... now I find it in 1.3 :)
10:11:17 <c_wraith> zhulikas: that doesn't need to be a do block.  It's just a let/where
10:11:18 <zhulikas> call to it might be optimized, but that's fine.
10:11:27 <zhulikas> I am not a big fan of let/where
10:12:02 <hpaste_> “Mark Needham” pasted “flood fill with state monad” at http://hpaste.org/66962
10:12:41 <c_wraith> zhulikas: you're still using a let, but you're also using a do to add syntactic noise.  The general use is "don't use do blocks unless you're actually using the sugar for >> or >>="
10:12:47 <zhulikas> I never use let/where, therefore I don't even know the correct syntax for it :(
10:12:49 * zhulikas ashamed
10:13:00 <zhulikas> ok
10:13:26 <zhulikas> well
10:13:30 <zhulikas> let ... in
10:13:32 <zhulikas> works as well
10:13:36 <zhulikas> and removed do
10:14:02 <zhulikas> and it's time to start saving the snippets somewhere
10:14:17 <zhulikas> does anyone know a good cloud service where I can save my code pieces?
10:14:23 <kallisti> github.
10:14:26 <zhulikas> heh:)
10:14:33 <zhulikas> true.
10:14:47 <kallisti> it's even version controlled!
10:16:38 <hayashi> @pl \f a -> a == f a
10:16:38 <lambdabot> ap (==)
10:17:18 <c_wraith> err, general *rule*
10:17:18 <kallisti> hayashi: awwww yeah
10:17:21 <kallisti> S combinator
10:17:27 <kallisti> good stuff.
10:17:45 <c_wraith> that's kind of amusing.
10:18:01 <c_wraith> the @pl command assumed the commutativity of == there
10:18:13 <kallisti> it did?
10:18:15 <c_wraith> Err, oh, no, it didn't
10:18:28 * kallisti thinkins c_wraith is trippin'
10:18:36 <c_wraith> I commuted things in my head desugaring it.  heh
10:18:56 <ForSpareParts> kallisti: I tried removing parts of my assignment source until it wouldn't compile, and as far as I can tell none of the definitions (adigit, digits, aletter, etc.) will compile unless they're used in a parser definition somewhere else. Do you know why that is?
10:18:57 <kallisti> the machines are infallible
10:19:15 <kallisti> ForSpareParts: like I said a type error message would be most helpful to me.
10:19:33 <ForSpareParts> Oh. Oops. Missed that.
10:19:34 <ForSpareParts> ...
10:20:00 <kallisti> ForSpareParts: my guess is that the monomorphism restriction is at work with your top-level bindings, but I'm not sure how.
10:20:22 <kallisti> ForSpareParts: otherwise it's a type inference thing
10:20:33 <kallisti> you're using the definitions incorrectly, for example.
10:21:13 <ForSpareParts> kallisti: I did my best to mirror what my prof did, as far the definitions. But that thing about the monomorphism restriction sounds familiar...
10:21:36 <ForSpareParts> it broke some of his sample code in a lecture once, until he added something in the file to turn it off, I think?
10:22:26 <kallisti> yes probably
10:22:33 <kallisti> {-# LANGUAGE NoMonomorphismRestriction #-}
10:22:40 <kallisti> at the top
10:25:56 <ForSpareParts> kallisti: Okay, so adding that appears to fix everything. I still don't really understand why, or what it does, though -- I was hoping you could explain.
10:26:01 <ForSpareParts> Here's an error I get without it
10:26:15 <ForSpareParts> http://hpaste.org/66963
10:26:27 <kallisti> ForSpareParts: the monomorphism restriction simply makes top-level bindings monomorphic.
10:26:30 <kallisti> so for example
10:26:32 <kallisti> x = 2
10:26:38 <kallisti> is forced to be an Integer
10:26:43 <kallisti> instead of a (Num a) => a
10:27:20 <ForSpareParts> So without them, x=2 could evaluate to some other kind of Num given the right context?
10:27:25 <kallisti> yes
10:27:28 <ForSpareParts> OK.
10:27:31 <kallisti> but only one.
10:27:41 <kallisti> er... well
10:27:45 <kallisti> nevermind. ignore that. :P
10:28:06 <ForSpareParts> Alright!
10:28:47 <ForSpareParts> So, then, is what was happening that by using the definitions inside of other Parser definitions, I was removing ambiguity about their type?
10:28:55 <kallisti> ForSpareParts: it's a stupid arbitrary rule. if you can spot then just turn it off.
10:29:30 <kallisti> ForSpareParts: I'm guessing it was being used in 2 different ways
10:29:31 <kallisti> or something
10:29:33 <kallisti> I don't really know
10:29:38 <ForSpareParts> Alright.
10:29:49 <ForSpareParts> And thanks.
10:29:59 <kallisti> the Parsec monad itself is actually just a synonym for a more general parser thing
10:30:25 <hpc> a better solution to the monomorphism problem is to put type signatures on things where you notice it
10:30:34 <kallisti> oh yes, that too.
10:30:58 <hpc> for some cases, the monomorphism restriction can change the asymptotic complexity of an algorithm
10:30:59 <kallisti> the monomorphism restriction only applies to /inferred/ types
10:31:03 <kallisti> on top-level bindings.
10:31:20 <kallisti> an example of where you'd want NoMonomorphismRestriction is a simple config file.
10:31:33 <kallisti> to avoid putting (Num a) => a  on all of your integer configuration stuff.
10:33:23 * kallisti wonders if anyone is using his webdriver code yet.
10:33:38 <Day_dreamer>  /ignore -channels #haskell * JOINS PARTS QUITS NICKS
10:34:16 <kallisti> Day_dreamer: nicks seems like a bit much
10:34:23 <Day_dreamer> ho sorry
10:34:43 <Day_dreamer> bad paste (but thanks)
10:34:53 <kallisti> unfortunately gooling "selenium haskell" still points to the obsolete selenium package.
10:34:56 <wli> http://stackoverflow.com/questions/6877872/help-with-cabal-install-package-shadowing-errors doesn't seem to have actual answers as to what to do about all this.
10:35:01 <kallisti> *googling
10:37:26 <alpounet> Day_dreamer, with proper training, the eye actually can do the filtering
10:37:26 <alpounet> :P
10:40:41 <kallisti> http://stackoverflow.com/questions/8974798/any-purely-functional-language-bindings-available-for-selenium2-webdriver  also you guys should bump my answer to this question. kthx.
10:44:25 <Day_dreamer> alpounet: screen pollution is bad for your health
10:47:31 * hackagebot curlhs 0.0.1 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.0.1 (KrzysztofKardzis)
10:49:04 <c_wraith> huh.  a new set of curl bindings.
10:49:13 <c_wraith> Wonder if these ones will segfault all the time
10:50:36 <wli> mapM (simpleHTTP . getRequest) urls :: IO [Network.Stream.Result (Response String)] <— hmm, how do I do all those in parallel?
10:51:55 <c_wraith> throw in a forkIO and an mvar write
10:52:05 <c_wraith> or use one of the existing packages that do things like that for you :)
10:52:28 <wli> c_wraith: Package sounds good, I can't name one, though.
10:52:36 <c_wraith> I can't either, offhand
10:52:55 <c_wraith> maybe http://hackage.haskell.org/package/parallel-io
10:53:00 <c_wraith> the author list is promising
10:55:04 <tgeeky__> c_wraith: edward kmett, dons, and jesus?
10:55:16 <c_wraith> heh.  none of them
10:58:21 <ClaudiusMaximus> @hackage spawn   -- wli
10:58:21 <lambdabot> http://hackage.haskell.org/package/spawn   -- wli
11:00:21 <cheater_> hi
11:00:24 <wli> ClaudiusMaximus: That would be what I'm looking for.
11:00:39 <cheater_> is there a standard way to implement a ring, group, or groupoid in haskell?
11:02:26 <wli> parMapIO (simpleHTTP . getRequest) seems to be what I want.
11:02:59 <c_wraith> oh, that is what you're looking for
11:03:09 <c_wraith> sorry I couldn't remember the package name
11:07:22 <haskkitten> how can I do eg. product of tail [1,2,3] please ?
11:08:12 <mauke> > product (tail [1,2,3])
11:08:13 <lambdabot>   6
11:08:29 <djh_> product $ tail [1,2,3]
11:08:58 <haskkitten> awesome thanks
11:09:11 <haskkitten> both works
11:09:28 <mekeor> or: product $ drop 1 [1,2,3] -- maybe that's better if the list can be [] (empty), too.
11:10:07 <haskkitten> ok and how is the $ called in haskell ?
11:10:11 <kallisti> > foldl (*) 1 . (\x-> case x of (_:xs) -> xs) $ [1,2,3]
11:10:13 <lambdabot>   6
11:10:15 <kallisti> hope that helps.
11:10:19 <haskkitten> haha
11:10:41 <kallisti> f $ x = f x
11:10:58 <kallisti> it has the lowest operator precedence possible.
11:11:14 <kallisti> it exists mostly to avoid parentheses
11:11:19 <kallisti> but you can also use it with higher-order functions.
11:11:28 <haskkitten> i see
11:11:39 <kallisti> (well it's probably "mostly" for higher-order functions. the parentheses thing is its common use. :P )
11:11:40 <BMeph> haskkitten: Also, we usually just call it "dollar". :)
11:11:47 <kallisti> oh, right.
11:11:54 * kallisti doesn't actually attempt to pronounce haskell code.
11:11:59 <kallisti> so I don't call it anything.
11:12:29 * BMeph likes answering questions as they're asked, much more than answering questions he thinks someone wants to know.... :)
11:13:03 <kallisti> well "how is it called" can mean different things.
11:13:09 <reinoud> @hoogle fromIntegral
11:13:09 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:13:16 * BMeph is also just a leeeeeeetle bit of a smart-ass, too
11:13:23 <mcstar> when an import in ghci didnt succeed, why doesnt it tell me?
11:13:31 <kallisti> it should.
11:13:44 <mcstar> me?
11:13:47 <haskkitten> well I just gonna play around with all this and try to connect it together
11:13:57 <BMeph> mcstar: Maybe it doesn't want to hurt your feelings? ;)
11:14:27 <mcstar> BMeph: it lies to me,pretends its ok
11:14:32 <mcstar> this hurts much more
11:14:56 <kallisti> maybe things just aren't working out for you and ghci.
11:15:20 <mcstar> now come on, try to import something, that isnt there, and you get no reply
11:15:21 <reinoud> euuhh silly Q maybe but how do i change an Int into a float?
11:15:21 <kallisti> (but seriously it should give you an error or something)
11:15:24 <mcstar> no
11:15:33 <mauke> reinoud: fromIntegral
11:15:39 <mcstar> it just doesnt prepend the prompt with the module name
11:15:41 <reinoud> oh...
11:15:49 <mcstar> not prepend, but affix
11:15:54 <mcstar> or suffix or whatever
11:16:13 <ktosiek> same here, version 7.4.1
11:16:31 <ktosiek> there's no message, it's like that line never happened
11:16:31 <mcstar> i can import Shit even
11:16:47 <mcstar> needs to begin with capital letter
11:17:08 <reinoud> mauke: it compiles now but what really happens is puzzling. The result looks like it divides by zero
11:17:19 <kallisti> BMeph: but yeah sometimes I answer questions on autopilot. :P
11:17:22 <mauke> o_O
11:17:34 <haskkitten> how do I sum tail and init of list ?
11:17:37 <mcstar> avoid the autopilot at all costs!!!
11:18:12 <kallisti> > let xs = [1,2,3] in tail xs + init xs
11:18:13 <lambdabot>   No instance for (GHC.Num.Num [a])
11:18:13 <lambdabot>    arising from a use of `e_1123' at <int...
11:18:20 <kallisti> oh
11:18:27 <kallisti> :P
11:18:31 <kallisti> BMeph: like that. see?
11:18:36 <reinoud> i guess the list is null length  :-S
11:18:36 <kallisti> haskkitten: what do you mean by that?
11:18:48 <kallisti> sum what exactly?
11:18:49 <haskkitten> why product( tail [1,2,3] + init [1,2,3]) does not work ?
11:18:57 <kallisti> because you can't add lists together.
11:19:00 <kallisti> it doesn't mean anything.
11:19:12 <mcstar> you cant + two lists
11:19:21 <haskkitten> [1,2,3] ++ [3,4,5]
11:19:27 <kallisti> that should work.
11:19:35 <haskkitten> let a = [1,2,3] ++ [3,4,5]
11:19:36 <haskkitten> a
11:19:40 <haskkitten> sorry ;(
11:19:46 <mcstar> > let a = [1,2,3] ++ [3,4,5] in a
11:19:48 <lambdabot>   [1,2,3,3,4,5]
11:19:52 <haskkitten> ah :)
11:19:54 <ktosiek> haskkitten: that's concatenating them
11:20:12 <haskkitten> yea, but I wanted to do sum of the numbers in the list
11:20:14 <mauke> > ((*) `on` product) [1,2,3] [4,5,6]
11:20:16 <lambdabot>   720
11:20:28 <ktosiek> haskkitten: sum [1,2,3,4]
11:20:30 <mcstar> magic
11:20:35 <kallisti> product . sum $ xs ++ ys
11:20:37 <wli> product (tail [1,2,3]) + product (init [1,2,3]) or product (zipWith (+) (tail [1,2,3]) (init [1,2,3])) or product (tail [1,2,3] ++ init [1,2,3]) ?
11:21:24 <mcstar> "to do sum of the numbers in the list" is pretty undefined
11:21:32 <mcstar> list or lists?
11:21:55 <haskkitten> great, I meant what wli wrote
11:22:11 <haskkitten> thanks
11:24:01 * haskkitten about zipWith
11:24:12 <haskkitten> this language is like some Lego
11:24:50 <mcstar> it has not much to do with Logo, that was lisp based
11:25:16 <haskkitten> i mean lego like the kid toy
11:25:26 <mcstar> oh
11:25:31 <haskkitten> i feels like putting it together in small pieces
11:25:44 <haskkitten> *it
11:26:41 <ktosiek> well, it sure is a better feeling than making all the pieces from scratch ^_^
11:27:10 <mcstar> i dont get the analogy, in every language you build up your program similarly
11:27:14 <mcstar> afaik
11:27:38 <mauke> but some languages only have shapeless blobs
11:27:45 <regua> beginner question: I have a function like this: remove a xs = (map $ filter (/=a)) xs. I was wondering if it was possible to get rid of the brackets around the expression?
11:27:55 <regua> as in, use the ($) or perhaps (.) operators.
11:27:56 <mcstar> so what feels like lego, is the functional composition?
11:28:15 <haskkitten> well Im from java land so
11:28:23 <haskkitten> this is awesome
11:28:33 <mcstar> im told in java everything is a class
11:28:39 <mcstar> that didnt feel like lego?
11:28:43 <haskkitten> no
11:28:50 <haskkitten> it felt like blop
11:29:00 <kallisti> ha
11:29:03 * mcstar tries to imagine
11:29:16 <Nimatek> Java feels kind of squishy.
11:29:22 <dolio> Not everything is a class, really.
11:29:25 <dolio> Or an object.
11:29:42 <mcstar> i guess some things are just object-able
11:29:46 <kallisti> Java is objectifying like that.
11:29:55 <haskkitten> well the compiler is clever form what i see sofar
11:29:58 <ktosiek> mcstar: "everything" doesn't include methods
11:29:59 <hayashi> Nngh, Java
11:30:16 <ktosiek> nor some types
11:30:38 <hayashi> My university pushes Java massively as an introductory language.  It's introduced me to the concept of boilerplate burnout alright >>
11:30:53 <dolio> More things are first class and uniformly handled in Haskell (and numerous other languages) than Java, really.
11:31:23 <barrucadu> regua: remove a = map $ filter (/=a)
11:31:48 <hayashi> ohai barrucadu, didn't see you there
11:32:20 <regua> barrucadu: thanks... now I feel stupid though for not thinking of that.
11:33:05 <wli> It's pathetic how little progress I've made on my traveling salesman bit, but on the other hand, I have mitigating circumstances.
11:33:57 <hayashi> @pl \a -> map $ filter (/=a)
11:33:58 <lambdabot> map . filter . (/=)
11:34:06 <hayashi> I was expecting that to be absolutely horrendous
11:34:13 <hayashi> I don't know why
11:34:22 <hayashi> Maybe my brain's gone into sleep mode
11:34:30 <Nimatek> Because pointless, erm pointfree style often is?
11:34:38 <hayashi> ^~^
11:34:38 <mcstar> ktosiek: can you have a class-less method? i dont know, but i'd guess you cant, and everything you can instantiate are classes, am i wrong?
11:35:47 <hayashi> I can't remember what my utmost worst result from @pl is
11:35:57 <NamelessOne> I have some foreign code with a constant of a known type in C. How can I import this constant in Haskell without havin to define in C a constant function returning this constant ?
11:36:02 <hayashi> but it involved about 10 compositions
11:36:08 <AimHere> mceier, Everything in Java is inside a class; I can't remember if everything IS an object though
11:36:25 <AimHere> mceier, the first I mean all your code is in classes
11:36:34 <mauke> NamelessOne: what do you mean by "constant"?
11:36:34 <hayashi> well, there are static methods, so you don't always need to have objects to use class code
11:36:35 <mceier> AimHere: tabfail, I guess :P
11:36:36 <hpc> NamelessOne: what type do you want the haskell to have?
11:36:39 <mcstar> hello AimeeHere!
11:36:46 <Nimatek> The primitive data types are not objects. Methods are not objects either.
11:36:47 <AimHere> mceier, oops. Too many MCs
11:37:03 <AimHere> All you Scottish people look alike to me
11:37:14 <hayashi> in fact, one could completely abuse the system by just having a Main class with nearly everything as static methods ;_;
11:37:57 <hpc> hayashi: it's easy to get bad @pl code
11:38:03 * mysticc comes to rescue system from getting abused.
11:38:07 <hpc> @pl \a b c d e f g -> g e a d c b f e a
11:38:10 <lambdabot> join (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((ap . ((flip . (flip .) . flip) .)) .)) .)) .) . flip . ((flip . (flip .)) .) . (((flip .
11:38:10 <lambdabot> ) .) .) . flip . (flip .) . ((flip .) .) . flip . (flip .) . flip (flip . flip id))
11:38:10 <lambdabot> optimization suspended, use @pl-resume to continue.
11:38:14 <hayashi> dramatic pause!
11:38:16 <elliott> @pl-resume
11:38:18 <lambdabot> flip =<< ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . (liftM2 (flip . (flip .) . flip) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) .
11:38:18 <lambdabot> flip . ((flip . (flip .)) .) . flip . (flip .) . flip (flip . flip id)
11:38:22 <elliott> much better
11:38:24 <NamelessOne> Ok, to make things simple, assume I have a "int foo;" in a .h file, and I want to have it in a Haskell binding. I know the Haskell type will be a CInt, but how can I inform it has to be imported. I know how to do it with functions, but not with simple data.
11:38:24 <hpc> lol
11:38:38 <yihuang> I want to parse some raw ip packets in haskell, can any package help me with that?
11:38:55 <hpc> NamelessOne: same process, different type
11:39:14 <hpc> make your haskell side have type CInt and you should be done, i think
11:39:29 * hpc hasn't ever FFI'd
11:39:36 <mysticc> yihuang: attoparsec ?
11:39:37 <mcstar> hayashi: so you could call all these functions, like they had some global definition?
11:39:42 <mauke> NamelessOne: foreign import ccall "&" foo :: Ptr CInt
11:39:43 <monochrom> no, it is a foreign pointer on the haskell side
11:39:45 <liyang> You never forget your first FFI.
11:39:57 <monochrom> err, pointer
11:40:04 <mekeor> liyang: i will never forget only one thing: the fifth of november.
11:40:09 <hpc> monochrom: oh
11:40:18 <mcstar> for free inter...
11:40:19 <NamelessOne> mauke: Thanks, that is strange to provide a ccall if it is not a function.
11:40:42 <yihuang> <mysticc>: I mean is there some packages already did that parsing for me ;-)
11:40:43 <mauke> NamelessOne: yeah, but it's still a C variable
11:40:44 <monochrom> on haskell side, both CInt and IO Cint refer to on C side "int x(void)"
11:40:49 <hpc> i think "ccall" says what language it is, not "it's a function"
11:40:51 <elliott> you can omit the ccall, can't you?
11:40:53 <hayashi> mcstar: unless I'm tripping, which is very likely given how tired I am at the moment, yeah, though you'd have to invoke them as Class.method(args) so they end up namespaced and stuff
11:41:21 <mcstar> hayashi: yeah, thats what i thought the benefit would be, namespacing
11:41:37 <regua> another question about getting rid of brackets / simplifying: func2 xs = map snd (func1 $ map head xs ). I can't get my head around it yet, any help will be appreciated.
11:41:44 <monochrom> well CInt refers to unsafePerformIO on IO CInt, and IO Cint refers to int x(void)
11:41:51 <NamelessOne> but an "int x(void);" and a "int x;" are not the same thing, aren't they?
11:41:52 <hayashi> of course, anyone with even a passing interest in object theory would screech loudly on seeing that
11:42:22 <DanielDiaz> Hi! Given a monad 'm', is it possible to get a function of type m (a -> b) from a function of  type (a -> m b) ?
11:42:33 <elliott> DanielDiaz: No. Consider putStrLn :: String -> IO ()
11:42:34 <any-key> I'm having a bit of trouble working with Data.ByteStream. Here's an example program and the associated error: http://pastebin.com/wBuhMfyD
11:42:36 <mauke> The paste wBuhMfyD has been copied to http://hpaste.org/66965
11:42:47 <elliott> DanielDiaz: If you could turn that into IO (String -> ()), then you could use (>>=) to get an impure (String -> ()).
11:42:47 <DanielDiaz> how fast!
11:42:57 <DanielDiaz> mmm
11:43:00 <elliott> DanielDiaz: The effects of an (a -> m b) function depend on its input, so you can't isolate them by going the other way.
11:43:06 <DanielDiaz> read well: I said (m (a -> b))
11:43:07 <mauke> any-key: String -> BS.ByteString is wrong
11:43:08 <hayashi> one of the things I hate about OOP is that there are about 9001 arbitrary "laws" that are not only very easy to break, but so often broken that even if your program is pure object poetry in motion you'll invariably then have to interact with something that's confusing what an object is and what it isn't
11:43:08 <elliott> DanielDiaz: You can, however, go from m (a -> b) to (a -> m b).
11:43:16 <hayashi> You can't really go that wrong with functions ^^
11:43:19 <elliott> DanielDiaz: Eh? I know what you said.
11:43:28 <DanielDiaz> ahá
11:43:33 <any-key> mauke: should it be String -> IO BS.ByteString ?
11:43:42 <liyang> yihuang: did you find anything on http://hackage.haskell.org/package/ ?
11:43:53 <mekeor> @package
11:43:54 <lambdabot> http://hackage.haskell.org
11:43:57 <DanielDiaz> that's right
11:44:01 <mauke> any-key: yes
11:44:04 <mcstar> ill find higher ground for the flood
11:44:09 <hpc> hayashi: yeah, the only common example in haskell i can think of where laws are broken is ListT
11:44:15 <DanielDiaz> thanks, elliott
11:44:18 <hpc> (ListT m) isn't a monad unless m is a commutative monad
11:44:21 <hpc> which isn't enforced
11:44:25 <any-key> mauke: thank you :)
11:44:35 <any-key> it works!
11:44:37 <elliott> DanielDiaz: np
11:44:45 <hpc> so it's easy to not notice that rule and break the laws
11:44:58 <hpc> (might not break code, depending on what you are doing)
11:48:09 <yihuang> liyang: Yes, I've browsed the Network category, but don't find anything relevant.
11:51:30 <liyang> if it's not on Hackage then it probably doesn't exist (at least not publically.)
11:53:54 <regua> sorry to repeat the question, but I was wondering if anyone could help me simplify this function: func2 xs = map snd (func1 $ map head xs). I've tried to use the ($) and (.) operators but have been unsuccessful.
11:54:39 <mysticc> regua: what are the types of func1 and func2
11:55:01 <shachaf> regua: func2 = map snd . func1 . map head ?
11:55:07 <shachaf> Although "head" is an evil function. :-(
11:55:16 <nyingen> weird, why would listenOn from Network only listen on ipv6 by default?
11:55:22 <nyingen> and how do I fix that in my code?
11:55:33 <hayashi> @pl \xs -> map snd (func1 $ map head xs)
11:55:33 <lambdabot> map snd . func1 . map head
11:56:02 <regua> shachaf: that works, thank you.
11:56:25 <mysticc> regua: Try using @pl
11:56:25 <hayashi> the code obfuscator agrees with shachaf!
11:56:26 <Tinned_Tuna> Heya, quick question, you know that Data.List provides genericLength and such? I've had a quick look at Data.Vector, and I can't seem to spot anything that is similar.
11:57:12 <hayashi> shachaf: out of interest, what's wrong with head?
11:57:24 <liyang> Tinned_Tuna: why would you want genericLength? :-/
11:57:26 <ktosiek> hayashi: it's partial
11:57:34 <ktosiek> so it can throw an undefined at you
11:57:36 <regua> mysticc: yeah I've just realised what hayashi did, I wasn't aware of how lambdabot worked.
11:57:41 <geekosaur> I think those functions are mostly considered warts, since dropping a fromIntegral into the coe is just as good and there's no good reason to build it in
11:57:44 <Hexmind2> For some reason, no matter what I do with indenting the following code gives "parse error on input `=': http://pastebin.com/6qU5Fdgy
11:57:46 <mauke> The paste 6qU5Fdgy has been copied to http://hpaste.org/66966
11:57:51 <liyang> Tinned_Tuna: would (fromIntegral . V.length) suffice?
11:58:06 <hayashi> I mainly came in here just to play with pl, and stayed for the actually helpful discourse =P
11:58:10 <Tinned_Tuna> It's more because the Int version can overflow.
11:58:28 <shachaf> hayashi: It's an evil function for the reason ktosiek mentioned.
11:58:29 <geekosaur> but the fromIntegral is the entire difference
11:58:34 <mauke> Hexmind2: I get irc.hs:1:15: Not in scope: type constructor or class `Page'
11:58:36 <liyang> Tinned_Tuna: if the Int is overflowing, chances you've got other problems.
11:58:40 <shachaf> hayashi: Often (not always) it indicates that you're doing something wrong.
11:58:42 <geekosaur> it doesn't actually use Integer in the impkementation
11:58:54 <geekosaur> @src genericLength
11:58:55 <lambdabot> genericLength []    = 0
11:58:55 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:59:00 <liyang> Tinned_Tuna: like memory.
11:59:10 <geekosaur> huh, ok, maybe it does
11:59:37 <Tinned_Tuna> liyang: I know that memory would be a problem in that case, but I'm trying to build something which can be formally correct.
11:59:47 <eci> How can it be rewritten? http://hpaste.org/66967
11:59:55 <Hexmind2> mauke: Sorry here's the full snippet https://groups.google.com/forum/#!topic/hakyll/vYtcOAceIks
12:00:05 <mcstar> is there something lfor ghci like ipython's magic command %paste?
12:00:22 <ktosiek> mcstar: how does it work in ipython?
12:00:37 * geekosaur thinks about it, realizes he needs coffee or something
12:00:42 <mcstar> you have text on the clipboard, and it pastes that into the interpreter
12:00:48 <mauke> Hexmind2: irc.hs:4:8: Could not find module `Hakyll'
12:00:50 <geekosaur> (if only coffee worked)
12:00:51 <mcstar> and it will work correctly
12:01:00 <Tinned_Tuna> liyang: as part of an extended tutorial on going from a potentially buggy, slow implementation to a (hopefully) bug free, well tested, implementation
12:01:01 <dysoco> so I'm reading "Learn you a Haskell" and I'm trying to come up with a program that returns all the posible combinations of a list of Chars, like ['a','b','o'] would return "abo", "oba", "bao", etc. .. any ideas ?
12:01:31 <mauke> > permutations "abo"
12:01:32 <lambdabot>   ["abo","bao","oba","boa","oab","aob"]
12:01:37 <dysoco> oh...
12:01:40 <haskkitten> haha
12:01:51 <Hexmind2> mauke: Yeah it requires Hakyll, I'm surprised the let = syntax is screwing up GHC
12:01:53 <ktosiek> mcstar: I don't think ghci talks with X11
12:01:57 <ktosiek> at all
12:02:03 <monochrom> Data.Vector length always fits in a machine address word. in fact, due to most OS limitations, Data.Vector length likely fits in a machine address word minus 1 bit, so GHC Int is enough
12:02:09 <geekosaur> not directly, there is xclip though
12:02:19 <parcs`> mcstar: shift-insert
12:02:36 <ktosiek> parcs`: "<mcstar> and it will work correctly"
12:02:39 <Hexmind2> mauke: sid has packages libghc-hakyll-prof, libghc-hakyll-dev, libghc-hakyll-doc
12:02:45 <monochrom> if you're doing formal methods, add an axiom about Data.Vector length upper bound
12:02:50 <mauke> Hexmind2: ok?
12:02:54 <parcs`> works great for me
12:02:54 <ktosiek> parcs`: shift-insert will brake on normal multi-line code
12:03:04 <reinoud> hmpf
12:03:04 <parcs`> {: shift-insert :}
12:03:07 <reinoud> Stack space overflow: current size 8388608 bytes.
12:03:07 <reinoud> Use `+RTS -Ksize -RTS' to increase it.
12:03:23 <mcstar> i take it, ghci can parse 1 line at a time?
12:03:31 <parcs`> :{ \n shift-insert \n :} \n
12:03:58 <liyang> Tinned_Tuna: well, a Vector stores the length in the constructor rather computes it, so you're going to have to make do with fromIntegral . Vec.length. And what monochrom said.
12:04:26 <Hexmind2> Maybe I should use a "do" block
12:04:38 <Tinned_Tuna> liyang: But what about if you take two indicies near the top of the Vector, and try to determine what the midpoint of them.
12:04:49 <mauke> Hexmind2: what's the error message?
12:05:03 <Tinned_Tuna> You're then going to get two fairly large Ints, which will overflow, even if the length operation itself does not overflow? :-(
12:05:08 <Hexmind2> mauke: test.hs:36:29: parse error on input `='
12:05:12 <haskkitten> how do I sum a number of elements in two lists ?
12:05:20 <haskkitten> why this doesnt work product (zipWith (+) (length[1,2,3]) (lenght[1,2,3]))
12:05:25 <monochrom> (b+a)/2 = (b-a)/2 + a  no overflow
12:05:29 <merijn> Hexmind2: Paste the code producing the error on hpaste?
12:05:35 <merijn> haskkitten: Typo in second length
12:05:36 <liyang> Tinned_Tuna: so use fromIntegral . Vec.length, compute the midpoint, then fromIntegral back to an Int!
12:05:46 <haskkitten> merijn: yea, but even when  Icorrect it
12:05:48 <mcstar> parcs`: i see, that introduces multiline commands
12:05:51 <mauke> Hexmind2: line 36 is "     compile $ readPageCompiler" in that file
12:06:04 <merijn> haskkitten: length doesn't return a list
12:06:17 <merijn> haskkitten: zipWith expects two lists as input
12:06:35 <haskkitten> length return a number
12:06:43 <haskkitten> so if I do
12:06:52 <haskkitten> let a = length[1,2,3] in a
12:06:54 <merijn> haskkitten: Yes, which is a type error in the code you showed
12:07:25 <merijn> :t zipWith (+)
12:07:26 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
12:07:50 <mauke> > zipWith (+) [a, a, b] [c, d, d]
12:07:51 <lambdabot>   [a + c,a + d,b + d]
12:07:53 <merijn> "zipWith (+)" expect two numerical lists, you are passing the result of "length [1,2,3]", which is an int
12:08:22 <yihuang> To answer my own question, HaNS seems to have code to parse ipv4 packet.
12:08:45 <haskkitten> I see and this is the same product (length [1,2,3]) + product (length [1,2,3]) ?
12:08:57 <cheater_> <kallisti> but you can also use it with higher-order functions. << how?
12:09:02 <mauke> haskkitten: product requires a list. length returns a number.
12:09:03 <merijn> :t product
12:09:04 <lambdabot> forall a. (Num a) => [a] -> a
12:09:15 <liyang> yihuang: I found the network-data package. Does that do what you want?
12:09:16 <kallisti> cheater_: erm?
12:09:26 <parcs`> mcstar: and potentially multiple multi-line commands
12:09:42 <kallisti> > zipWith ($) (cycle [recip, negate]) [1..]
12:09:43 <lambdabot>   [1.0,-2.0,0.3333333333333333,-4.0,0.2,-6.0,0.14285714285714285,-8.0,0.11111...
12:09:47 <kallisti> cheater_: ^
12:10:02 <haskkitten> mauke: ok so how do I sum the amount of all elements in different lists ?
12:10:10 <mauke> haskkitten: with +
12:10:21 <cheater_> kallisti: cute
12:10:27 <cheater_> really like it
12:10:39 <Tinned_Tuna> monochrom: I don't see how (b-a)/2 + a aleviates the problem, it only makes it occur later, as far as I can tell.
12:10:43 <merijn> haskkitten: You mean you want to sum multiple lists together or just sum each list?
12:10:43 <kallisti> I'm sure there are other uses.
12:11:07 <haskkitten> merijn: I mean eg [1,2,3] is list with free entries
12:11:17 <geekosaur> haskkitten, maybe you could explain what you think the "length" in your code is supposed to be doing
12:11:17 <merijn> > sum [1,2,3]
12:11:18 <lambdabot>   6
12:11:18 <haskkitten> and [1,2,3,4] is four entries thus sum is 7
12:11:35 <haskkitten>  4 + 3 = 7
12:11:39 <cheater_> hey guys, is there a standard way to implement a ring, group, or groupoid in haskell?
12:11:44 <geekosaur> ...ok, nemmind, I see I'm behind
12:11:46 <haskkitten> no the sum of list numbers
12:11:49 <yihuang> liyang: it seems to be exactly what i want, don't know how i missed that, thank you very much.
12:12:06 <merijn> oh...that's a bit trickier
12:12:20 <Tinned_Tuna> liyang, monochrom: Don't worry about it thought, I'll pretend there's an equivalent to genericLength in Data.Vector for the moment and get on wit hthings :-p
12:12:21 <geekosaur> :t (+) `on` length
12:12:22 <lambdabot> forall a. [a] -> [a] -> Int
12:12:38 <merijn> haskkitten: I would first write a function to split your one list into two lists and then use "zipWith (+)" to sum the two resulting lists
12:12:47 <haskkitten> I must admit i dont understand the notation quite yet
12:12:54 <mauke> merijn: why sum the lists?
12:12:56 <haskkitten> like [a] -> [a]
12:13:13 <merijn> mauke: Because that's what he asked?
12:13:16 <mauke> merijn: no, it isn't
12:13:28 <kallisti> > (+) `on` length $ [1,2,3] [1,2,3,4]
12:13:29 <lambdabot>   Precedence parsing error
12:13:29 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
12:13:43 <kallisti> > ((+) `on` length) [1,2,3] [1,2,3,4]
12:13:44 <lambdabot>   7
12:13:50 <haskkitten> yes
12:13:52 <haskkitten> ^^
12:13:57 <mauke> > length [(), (), ()] + length [(), (), (), ()]
12:13:58 <lambdabot>   7
12:14:00 <merijn> mauke: Oh yeah, I guess you could interpret it that way too
12:14:12 <merijn> mauke: misparse of his example I guess
12:14:18 <mauke> merijn: "number" means length and "free" means "three"
12:14:47 <kallisti> > length $ (replicate 3 undefined) <*> (replicate 4 undefined)
12:14:48 <lambdabot>   12
12:14:54 <haskkitten> thats great that notation ((+) `on` length)
12:15:00 <merijn> :t on
12:15:01 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:15:10 <hayashi> BBC
12:15:12 <kallisti> haskkitten: welcome to Haskell! :D
12:15:16 <haskkitten> so basically when  Icant sum something I can use on
12:15:16 <ktosiek> where is on from?
12:15:17 <haskkitten> :)
12:15:29 <mauke> @index on
12:15:29 <kallisti> haskkitten: you can use to apply a binary function to the result of applying a unary function on 2 arguments.
12:15:29 <lambdabot> bzzt
12:15:32 <mauke> @hoogle on
12:15:32 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:15:33 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
12:15:33 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
12:15:33 <kallisti> *use on
12:15:35 <mcstar> Data.Function
12:15:36 <merijn> ktosiek: I usually just search hoogle to figure those things out
12:16:04 <ktosiek> merijn: thanks, I figured it would be faster to ask when someone just used it here :-)
12:16:08 <hydo> maybe I should be using hoogle more... my knee-jerk is to always use my search shortcut to hayoo
12:16:11 <kallisti> haskkitten: f `on` g = (\x y -> f (g x) (g y))
12:16:18 <any-key> I'm having some more issues with ByteString...I'm trying to check to see if the contents of a ByteString are equal to "\202\254\186\190"
12:16:29 <merijn> ktosiek: It's faster, but if everyone does that it becomes quite noisy here :p
12:16:54 <kallisti> haskkitten: f `on g  produces a function that takes 2 arguments. the (\x y -> ...) is notation that defines a function as an expression/
12:16:57 <mauke> any-key: bs == BS.pack [202, 254, 186, 190]
12:16:58 <kallisti> *`on`
12:17:14 <kallisti> haskkitten: so for example
12:17:17 <monochrom> Tinned_Tuna: I disbelieve your claim on "later". I have memory and OS limitations such that vector indices are at most 2^k - 1, and they fit in Int without sign error. let a,b be such indices and a<=b. then (b-a) does not exceed the bound, (b-a) `quot` 2 does not either, and (b-a) `quot` 2 + a does not either. now tell me under what circumstance your "later" happens.
12:17:21 <kallisti> > (\x y -> x + y) 2 2
12:17:22 <lambdabot>   4
12:17:31 <haskkitten> wow
12:17:34 <kallisti> haskkitten: see? the (\... -> ...)  defines a function
12:17:46 <haskkitten> I see
12:17:50 <hydo> hehe
12:17:59 <any-key> mauke: thanks, I feel kind of dumb now :\
12:18:00 <haskkitten> thats really cool
12:18:02 <kallisti> haskkitten: so do you see what on does?
12:18:05 <any-key> it makes sense though
12:18:16 <ktosiek> ohh, there's no IsString ByteString instance :-C
12:18:22 <elliott> ktosiek: ByteStrings are not strings.
12:18:26 <hydo> I wonder if I'd get this level of help if I changed my nick to 'sexahhax0rgirlnorlyimagirl'
12:18:27 <elliott> ktosiek: If you're storing textual data, use Text.
12:18:29 <mauke> ktosiek: I bet there is somewhere
12:18:47 <Tinned_Tuna> monochrom: There's the difference, I was assuming a>b.
12:18:49 <elliott> (If you know for sure you're using pure-ASCII, and need performance, then you can use Data.ByteString.Char8.)
12:18:50 <elliott> (But only then.)
12:18:55 <elliott> (And that has an IsString instance.)
12:18:56 <merijn> Am I the only one that thinks the name bytestring is confusingly misleading?
12:18:59 <elliott> (But you should really use Text.)
12:19:07 <ktosiek> elliott: I know, I look for nice way to put some binary data in code :-)
12:19:13 <kallisti> haskkitten: oh btw I don't know how much you know about Haskell already:  the ` notation lets you write any function as an operator.
12:19:18 <ktosiek> (simple tests)
12:19:27 <ktosiek> (nicer than packing a list, if possible)
12:19:28 <kallisti> > 5 `mod` 2
12:19:29 <lambdabot>   1
12:19:45 <haskkitten> kallisti: well my first day
12:19:50 <haskkitten> of practicing
12:19:52 <merijn> haskkitten: Alternately, () lets you write any operator as prefix
12:19:56 <merijn> > (+) 1 5
12:19:57 <lambdabot>   6
12:20:15 <liyang> Tinned_Tuna: if you must… why not define genericVecLength = V.foldl' (const . (1 +)) 0 ? It'd be O(n) instead of O(1), that's all. ;p
12:20:49 <haskkitten> I have to think about the function a bit
12:21:16 <dysoco> what was the Funcion to return the result of Adding all the numbers in a List ?
12:21:26 <mauke> sum
12:21:48 <dysoco> thanks
12:22:03 <kallisti> haskkitten: the important thing to realize is that it's a function that returns another function.
12:22:38 <Tinned_Tuna> liyang: I know I could do that, but I'm that's the extact performance bottle neck I'm trying to avoid :-p
12:22:53 <kallisti> > zipWith ((+) `on` abs) [-5..5] [-10..10]
12:22:54 <lambdabot>   [15,13,11,9,7,5,5,5,5,5,5]
12:23:24 <liyang> Tinned_Tuna: wait… you want correctness *and* performance?!
12:23:26 <haskkitten> kallisti: so the 'on' helps you connect functions to get more compelx results ?
12:23:35 <haskkitten> because in haskell all is functions
12:23:40 <kallisti> haskkitten: the on takes 2 functions and produces a new function
12:23:47 <mauke> > (f `on` g) x y
12:23:47 <kallisti> on is just a regular function itself.
12:23:48 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:23:48 <lambdabot>    `GHC.Show.Show b'
12:23:48 <lambdabot>      a...
12:23:54 <ktosiek> Tinned_Tuna: Vector stores its own length as Int, you can't run away from that
12:24:03 <merijn> > (f `on` g) x y :: Expr
12:24:04 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:24:05 <ktosiek> well, maybe by making your own vector
12:24:05 <lambdabot>    `SimpleReflect.FromExpr ...
12:24:16 <haskkitten> ok,  I think I got it
12:24:29 <Tinned_Tuna> ktosiek: you have no idea how sad that makes me :-p.
12:24:29 <kallisti> haskkitten: a simpler example is function composition
12:24:34 <mauke> > let f_ = f :: Expr -> Expr -> Expr in (f_ `on` g) x y
12:24:35 <lambdabot>   f (g x) (g y)
12:24:40 <Tinned_Tuna> liyang: and I know it's asking quite a lot :-p
12:24:40 <kallisti> (f . g) x =  f (g x)
12:24:42 <haskkitten> the 'on' is like throwing the stuff on someone else(other function)
12:24:47 <dysoco> Well, so I'm trying to solve the Problem N1 of ProjectEuler, I need to get the Sum of all the multiples of 3 or 5 below 1.000, I tried this, but the result is wrong, any ideas ? "sum [x+x | x <- [1..1000], rem x 3==0 || rem x 5==0]"
12:24:55 <Tinned_Tuna> but what else am I to do with my Saturday evenings?
12:25:03 <liyang> Tinned_Tuna: you should switch to Agda. :)
12:25:08 <mauke> dysoco: x+x isn't x,
12:25:13 <mauke> dysoco: it's twice as big as x
12:25:14 <kallisti> haskkitten: well, it's a higher-order function, if that's what you mean.
12:25:27 <Tinned_Tuna> liyang: thought about it, but I'm not a fan of emacs
12:25:35 <haskkitten> yep like in math when you the f circle g
12:25:38 <mcstar> i wonder if it would be hard to write a compiler for lisp in haskell, that could translate all of maxima, into haskell code, and have a full featured CAS in haskell...
12:25:42 <kallisti> haskkitten: yep
12:25:43 <haskkitten> thing ?
12:25:47 <dysoco> mauke, what do you mean ? I know the result must be bigger, but I don't understand what I'm doing wrong
12:25:55 <dysoco> I think the error is there, in x + x
12:26:08 <merijn> mcstar: Well, there's a tutorial called "write yourself a scheme in 48 hours" for haskell :p
12:26:10 <mauke> wtf
12:26:11 <kallisti> > (unwords . map reverse . words) "hey guys how's it going?"
12:26:12 <lambdabot>   "yeh syug s'woh ti ?gniog"
12:26:21 <reinoud> hmpgf... running out of memory again.... is ++ really that expensive? is there an easy way to just append the stuff a function is generating?
12:26:29 <kallisti> > (unwords . reverse . words) "hey guys how's it going?"
12:26:31 <lambdabot>   "going? it how's guys hey"
12:26:51 <haskkitten> kallisti: thanks a lot for explanation
12:26:53 <Tinned_Tuna> liyang: And besides, I hadn't heard anything about agda being a speed demon :-p
12:26:55 <haskkitten> that fun
12:26:59 <haskkitten> *thats
12:27:24 <mcstar> dysoco: why would you double the numbers?
12:27:38 <ktosiek> reinoud: ++ is plenty of expensive, it's making a copy of the first argument...
12:27:49 <dysoco> mceier, yes, that's true, I'm doubling them... :S ... so what should I do ? How do I add all those bunch of numbers ?
12:27:56 <mauke> dysoco: don't do x + x
12:28:02 <mceier> dysoco: mhm :)
12:28:35 <ktosiek> dysoco: well, that "sum" is doing all the adding you need
12:28:54 <dysoco> OK that's true
12:29:21 <dysoco> then if I delete the x+x I'm with a "parse error on input `<-'"
12:29:33 <ktosiek> change x+x to x
12:29:40 <mcstar> > sum [x | x <- [1..1000], rem x 3==0 || rem x 5==0]
12:29:42 <lambdabot>   234168
12:29:57 <mcstar> btw
12:30:01 <dysoco> oh yes, I forgot the pipe
12:30:02 <dysoco> thanks
12:30:02 <mcstar> below 1000 is not 1000
12:30:11 <mauke> you can test this in pieces
12:30:19 <mauke> > [ x | x <- [1 .. 10] ]
12:30:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:30:27 <mauke> > [ x | x <- [1 .. 10], rem x 3 == 0 ]
12:30:28 <lambdabot>   [3,6,9]
12:30:34 <mauke> > [ x | x <- [1 .. 10], rem x 3 == 0 || rem x 5 == 0 ]
12:30:35 <lambdabot>   [3,5,6,9,10]
12:30:39 <mauke> > sum [ x | x <- [1 .. 10], rem x 3 == 0 || rem x 5 == 0 ]
12:30:40 <lambdabot>   33
12:31:25 <dysoco> YAY, it's OK !
12:31:35 <dysoco> I just added a "x < 1000" at the end
12:31:44 <mauke> > sum [ x | x <- [1 .. 999], rem x 3 == 0 || rem x 5 == 0 ]
12:31:44 <mcstar> [1..999]
12:31:45 <lambdabot>   233168
12:31:58 <dysoco> though, 1..999 would be the same
12:32:05 <zhulikas> how can I force evaluation of something?
12:32:30 <mcstar> $!, !, seq, deepseq?
12:32:42 <zhulikas> thanks
12:32:54 <elliott> zhulikas: Stare at it really hard.
12:33:00 <zhulikas> :)))
12:33:10 <mcstar> i mean it is subtle, so this wont be enough
12:33:49 <mcstar> i realized throwing around symbols in s haskell like a monkey is not the solution
12:34:23 <reinoud> what does it mean with: Use `+RTS -Ksize -RTS' to increase it.
12:34:23 <reinoud>  ??
12:34:31 <rasfar> i'm in type constraint hell, can anyone help?!...
12:34:42 <reinoud> the stack size only seems to be 8Mb and apparently my recursive functions consume a lot
12:34:45 <mcstar> reinoud: you must compile with -rtsopts
12:34:46 <kallisti> http://sprunge.us/ScTa what's up with mueval?
12:34:51 <reinoud> oh!
12:34:55 <rasfar> reinoud: you supply an option at runtime (when you run the compiled executable)
12:35:10 <kallisti> Peaker: I don't seem to actually understand conduits.
12:35:40 <rasfar> (yeah, since about GHC 6.10 you need to compile with -rtsops as well as supply the runtime option)
12:35:57 <rasfar> *-rtsopts
12:36:24 <reinoud> I currently use a Setup.hs:
12:36:36 <reinoud> import Distribution.Simple
12:36:36 <reinoud> main = defaultMain
12:36:42 <reinoud> that does all the compilation work for me
12:37:01 <rasfar> you use runhaskell Setup?
12:37:06 <kallisti> you can supply options to ghc via Setup
12:37:27 <reinoud> i normally use ./Setup :)
12:37:28 <reinoud> hmmm
12:37:31 <reinoud> lets see
12:37:44 * kallisti usually uses cabal
12:37:48 <rasfar> oh yeah, there's a shebang in Setup isn't there
12:38:09 <kallisti> there can be. ;)
12:38:15 <rasfar> so today i wrote my first type class
12:38:20 <rasfar> i thought it was going well...
12:38:39 <rasfar> for the love of haskell, pls help me :/
12:38:52 <elliott> Typeclasses are overrated.
12:39:13 <rasfar> well ... my situation was, i have a polymorphic initialiser function
12:39:22 <merijn> rasfar: Code + error pasted somewhere would be a good start :p
12:39:23 <rasfar> over Double and Complex
12:39:45 <rasfar> merijn: it's really too big for that, let's just see if can do it with some questions first...
12:40:29 <rasfar> i wrote a class Initable with one method, init
12:40:58 <rasfar> the Complex instance has init = signum (normalise the complex number to unit norm)
12:41:04 <rasfar> the Double instance just init = id
12:41:39 <Saizan> can you give the class declaration at least?
12:41:56 <rasfar> that much worked out, but now ... argh, i'm getting ... okay, hpaste on the way, thank you
12:42:06 <kallisti> sound a lot like Default.
12:42:18 <kallisti> but with an argument?
12:43:19 <hpaste_> rasfar pasted “Initable class” at http://hpaste.org/66970
12:44:28 <rasfar> kallisti, I didn't know about Default.  I could look at that... but a typeclass is the only sane way to branch behaviour like that, right?
12:44:50 <kallisti> rasfar: it's one way to do.
12:44:58 <kallisti> there are other ways.
12:45:02 <kallisti> for example, using a regular algebraic data type.
12:45:11 <kallisti> the difference there is that the typeclass is extensible
12:45:12 <rasfar> the trouble is (as shown in the excerpt of error messages at top of paste), all kinds of complaints ....
12:45:15 <kallisti> while the ADT is static.
12:45:22 <rasfar> basically, I have a data type Config a
12:45:43 <rasfar> now it seems I have to give expression type sig ( config :: Config Double ) etc. to not get the errors.
12:45:51 <rasfar> but of course this defeats my polymorphism
12:46:59 <rasfar> right, i see, i could have data Initable = InitableComplex Complex | InitableDouble Double and pattern-match
12:47:06 <kallisti> rasfar: did you ever paste anything?
12:47:10 <rasfar> (maybe i will end up doing that...)
12:47:26 <rasfar> kallisti, yes, about 15 lines up (not including join/part messages)
12:47:32 <rasfar> http://hpaste.org/66970
12:48:08 <kallisti> well, I'm not sure what you were trying to do with the multiple class declarations
12:48:11 <kallisti> but that's not how they work.
12:48:19 <rasfar> i've been making my best effort to keep the types as general as possible, so functions have tight constraints
12:48:33 <rasfar> there should be only one class declaration
12:48:44 <kallisti> yes, and I'm not sure you actually need the Fractional constriant there.
12:48:50 <rasfar> and two instances.  the rest are commented out attempts
12:48:51 <kallisti> what purpose does it serve?
12:49:07 <kallisti> secondly, the explicit annotation is only necessary if it's ambiguous.
12:49:07 <rasfar> i need it because one of the functions using these values takes an average
12:49:13 <kallisti> if it can be /inferred/, then you don't need it
12:49:16 <kallisti> here's an example:
12:49:20 <kallisti> > read "2" + read "2"
12:49:21 <lambdabot>   4
12:49:25 <kallisti> this works fine. the types are inferred
12:49:33 <kallisti> > read "2" :: Int
12:49:34 <lambdabot>   2
12:49:37 <reinoud> NFI what went wrong,
12:49:41 <kallisti> here, however, the annotation is needed.
12:49:57 <kallisti> because otherwise it doens't know what you want to read.
12:50:01 <rasfar> kallisti: you helped me before by suggesting to remove unnec. constraints in data decls, thanks again for your help now.
12:51:10 <kallisti> rasfar: in larger programs, types tend to be less ambiguous, though there are still cases where they appear.
12:51:15 <kallisti> for example:
12:51:16 <rasfar> interesting.  the truth is, it's a rather complicated program, and there are a lot of constraints flying around.  but it was working without, for example, "config :: Config Double" until I added the class.
12:51:19 <kallisti> > show (read "2")
12:51:20 <lambdabot>   "*Exception: Prelude.read: no parse
12:52:01 <kallisti> rasfar: I don't see any reason that this class should be a subclass of any of those.
12:52:11 <kallisti> it's perfectly generic.
12:52:14 <rasfar> i have definitely experienced more relief from removing constraints than from adding them, although some constraints are of course needed...
12:53:07 <rasfar> yes, but if I use a class declaration with no constraints, ... oh, I see, then I need a "Fractional a" constraint on the function that needs it.
12:53:22 <kallisti> rasfar: yes
12:53:24 <rasfar> similar problem to before with constraining my datatypes
12:53:30 <kallisti> just put constraints on functions when you need the typeclass methods
12:53:46 <rasfar> but you see at the top of the paste the list of "ambiguous type variable" -- most of those are not in my constraints list
12:53:47 <kallisti> (though making classes superclasses of other classes /is/ useful, unlike doing it with data decls)
12:54:09 <kallisti> I just don't see a reason for it to be a subclass here.
12:54:26 <kallisti> rasfar: more code would be helpful
12:54:45 <rasfar> you are very probably right; i will at least make that change and see where it leaves me.  thanks so much for your help.
12:54:52 <kallisti> no problem. :)
12:55:24 <kallisti> so uh...
12:55:27 <rasfar> it's a bit of a secret project, and the total lines of code is ... already over 4000, so more code is tricky.
12:55:30 * kallisti has no idea what's going on with his conduit stuff.
12:55:42 <kallisti> rasfar: the offending code would be the most helpful
12:56:06 <kallisti> but it looks like you're calling a printConfig which uses a Show instance to print stuff, yes?
12:56:07 <rasfar> okay, i'll make the recommended change, then see where it leaves us...
12:56:12 <rasfar> yes
12:56:21 <kallisti> is the thing you're passing in polymorphic?
12:56:28 <rasfar> in fact all Show are derived
12:56:50 <rasfar> yes, Config a
12:56:56 <kallisti> ah, so the a is unknown
12:56:57 <rasfar> where a can be, at least, Double or Complex
12:57:13 <rasfar> but I have a Show a => constraint in printConfig
12:57:13 <kallisti> yes, if the compiler can't infer what a polymorphic type is, it won't compile
12:57:27 <kallisti> a constrained type variable is still polymorphic.
12:57:47 <rasfar> basically, I have the specific constraints on a at all the methods that are mentioned in the error, that's what floored me
12:57:59 <kallisti> rasfar: that's not the problem
12:58:00 <rasfar> yes
12:58:04 <kallisti> the problem is that it has no clue what "a" is
12:58:10 <kallisti> (most likely. I need more code..)
12:58:31 <rasfar> okay, first the change re. Fractional then right back with more code
12:59:43 <reinoud> hmmm its eating > 3Gb ... there must be something very fishy
13:01:16 <haskkitten> how do I create random list of 5 elements?
13:01:42 <qq_> Hey, guys. I am working through Learn You a Haskell and I've got a question.
13:01:46 <glguy> replicateM 5 randomIO
13:01:54 <rasfar> > let g = mkStdGen 123
13:01:54 <lambdabot>   not an expression: `let g = mkStdGen 123'
13:02:03 <rasfar> (what glguy said)
13:02:15 <kallisti> haskkitten: randomness is a bit tricky for a beginner..
13:02:29 <qq_> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]       What is the purpose of the "x <- xs" term?
13:02:32 <rasfar> i got rid of Fractional from the class decl
13:02:47 <kallisti> qq_: it binds elements of xs to the name x
13:02:56 <qq_> Why won't this work? boomBangs x = [ if x < 10 then "BOOM!" else "BANG!" | odd x]
13:02:58 <KingOfKarlsruhe> qq_: for all x elements in xs
13:03:06 <haskkitten> ok thanks
13:03:08 <glguy> qq_: it names each of the elements of the list "x" and runs the rest of the computation
13:03:12 <barrucadu> qq_: Because it doesn't know what x is in that case
13:03:14 <rasfar> qq_: you need at least one "generator" in a list comprehension
13:03:15 <kallisti> qq_: because x is a list
13:03:19 <rasfar> those are the <- parts
13:03:29 <kallisti> barrucadu: it does
13:03:30 <qq_> Ahh, okay. That makes sense now.
13:03:30 <kallisti> check the argument
13:03:36 <glguy> qq_: that would work if x wasn't a list
13:03:37 * barrucadu fails at reading
13:03:41 <qq_> Thanks!
13:04:12 <glguy> >  let x = 9 in [ if x < 10 then "BOOM!" else "BANG!" | odd x]
13:04:12 <lambdabot>   ["BOOM!"]
13:04:38 <rasfar> okay, you don't need at least one generator
13:05:06 <haskkitten> well replicate 5 2 works
13:05:09 <kallisti> > let x = 2 in [ |odd x]
13:05:10 <lambdabot>   <no location info>: parse error on input `|'
13:05:19 <kallisti> haskkitten: correct!
13:05:20 <haskkitten> list of 5 2'
13:05:22 <glguy> > let x = 2 in [() |odd x]
13:05:23 <lambdabot>   []
13:05:27 <qq_> So it is iterating over the input xs and assigning the current one to x, correct?
13:05:34 <rasfar> yep!
13:05:36 <haskkitten> but I get not in scope random IO
13:05:53 <qq_> Cool, thanks.
13:06:05 <rasfar> > let x = 2 in [() | even x]
13:06:06 <lambdabot>   [()]
13:06:26 <hpc> because it desugars to (guard (even 2) >> return ())
13:06:36 <kallisti> haskkitten: Haskell has a notion of purity. a value is "pure" if evaluating it always produces the same result. There are no hidden side-effects that go on.
13:06:42 <kallisti> haskkitten: obviously this doesn't apply to random numbers.
13:07:45 <rasfar> i'm also very interested in random numbers in Haskell at the moment, this program uses them all over the place
13:08:01 <hpc> (random numbers can be pure if you consider IO actions to be pure, but that argument is mostly pedantery)
13:08:09 <kallisti> rasfar: if you want to avoid using IO you may want to try using RandT
13:08:12 <copumpkin> random numbers can be pure
13:08:51 <kallisti> copumpkin: but probably not in the way haskkitten would expect.
13:08:54 <rasfar> it somehow "seems okay" to have non-determinism where random numbers are used.  i'm not convinced it's unpure, somehow.
13:09:08 <haskkitten> ok got it import System.Random
13:09:11 <rasfar> StdGen gives pure random numbers
13:09:12 <kallisti> it's the opposite of referentially transparent..
13:09:15 <elliott> rasfar: It is not referentially transparent.
13:09:24 <elliott> Practically by definition.
13:09:31 <rasfar> no, but that is somehow ... acceptable
13:09:33 <elliott> StdGen is fine because you supply the seed.
13:09:44 <haskkitten> hah
13:09:45 <rasfar> because you have chosen to use them.
13:09:46 <kallisti> rasfar: what you really want is a way to abstract the notion of a "random variable"
13:09:50 <haskkitten> thats awesome
13:09:51 <kallisti> rasfar: which is what RandT does for you.
13:09:52 <elliott> rasfar: Not being able to replace "let x = y in z" with z[x --> y] is not acceptable.
13:10:07 <elliott> In fact, it destroys pretty much any property you might desire from referential transparency.
13:10:38 <glguy> rasfar: You wouldn't be able to distinguish from passing a thing that generates random numbers from passing something that is a chosen, unchanging random numbr
13:10:39 <rasfar> i know i should agree with you, but ...
13:10:59 <elliott> Yes, you should.
13:11:15 <rasfar> all i know is, my programs are still pure and would be even if I plugged them into a physical entropy source
13:11:39 <rasfar> but it requires principled programming on the human part to keep it pure
13:11:40 <glguy> rasfar: the compiler would have to guess when you wanted the random number chosen
13:11:48 <glguy> it'd be a mess
13:12:15 <kallisti> rasfar: lazy evaluation breaks down quickly without some notion of referential transparency.
13:12:21 <glguy> let x = randomInt in (x,x)   vs    (randomInt, randomInt)     did that change the meaning?
13:12:56 <rasfar> good example, thank you
13:12:59 <glguy> map (\_ -> randomInt) xs
13:13:03 <kallisti> rasfar: with the right abstractions, keeping code pure is not a tedious effort.
13:13:07 <glguy> doesn't that make a list of one random number or many?
13:13:41 <reinoud> @hoogle ceiling
13:13:42 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:14:23 <rasfar> fair enough.  but that depends on the way the syntax is interpreted, which is static
13:14:42 <regua> hey, I'm a beginner playing around with point-free functions and was wondering if there's a simple way to simplify a function like this: func2 xs = func1 . map ( \f -> (count f xs, f) ) $ xs. lambdabot's solution makes the whole thing unreadable:
13:14:46 <regua> @pl \xs -> func1 . map ( \f -> (count f xs, f) ) $ xs
13:14:46 <lambdabot> (func1 .) =<< map . join . ((,) .) . flip count
13:14:48 <elliott> rasfar: You might want to use ML.
13:15:11 <rasfar> no no, trust me, when Miranda disappeared I tried LML and I don't care for the syntax.  thanks for the advice though.
13:15:21 <glguy> rasfar: the point isn't that you can't know what it would do, its that you don't get to pick
13:15:50 <rasfar> i see (sort of)
13:16:21 <rasfar> well, random numbers are so important, maybe the behaviour vis a vis lazy evaluation should be specified separately
13:16:48 * elliott does not see why random numbers are more important than any other kind of supply, a reader monad, state, etc.
13:17:05 <glguy> rasfar: here's where it starts to fall apart, suppose you write a function and I pass "randomInt" as a parameter. Do you know if that argument is going to keep having the same value every time you use it?
13:17:07 <elliott> (Apart from "rasfar's problem involves lots of random numbers and not those" :P)
13:17:12 <rasfar> i would think a person would want as many different calls to a random source as possible (no sharing)
13:17:34 <rasfar> if sharing is intended, it should be syntactically explicit, never default, with random variates
13:18:06 <rasfar> glguy: i want it to have a different value every time i use it.
13:18:12 <elliott> rasfar: Now it really sounds like you want ML.
13:18:23 <rasfar> i'm willing to dispense with reproducibility with stochastic functions
13:18:26 <glguy> rasfar: so now you can't use it as an array index
13:18:34 <glguy> because you can't test its value and index with it
13:18:49 <rasfar> i probably do not want ML, i've been using Haskell and Miranda for over 20 years -- but maybe I will look at ML just in case you are right.
13:18:54 <rasfar> god knows i struggle with haskell, hahaha
13:19:49 <rasfar> when you say i'd like ML, do you mean non-lazy, or what?  or are you just saying "leave"? ;)
13:20:23 <elliott> Well, it's impure, and therefore practically by necessity strict.
13:20:25 <rasfar> i'd have to like ML a great deal, as i must really love Haskell to keep struggling with it as I do.
13:21:12 <rasfar> (i have some idea of how ignorant i am, but there's potential)
13:23:07 <rasfar> why can't i use it as an array index, if i've constained the range of the generator?
13:23:18 <rasfar> or use modulus prior to use?
13:24:12 <rasfar> random numbers are wild things, they need some constaining to use effectively of course
13:24:30 <elliott> rasfar: Why not just use RandT with Applicative style?
13:24:44 <elliott> Instead of (f randomInt randomInt), you can just write f <$> randomInt <*> randomInt.
13:24:55 <rasfar> and i'm not saying they're more important than other data sources, but they are very important, and by nature stochastic (or trying to simulate stochastic), which may justify special treatment in the language spec, that's what i meant
13:25:10 <elliott> Or mapM (const randomInt) xs to map all elements of a list to a random integer, etc.
13:25:20 <glguy> rasfar: You could probably build a language around the concept that your variables are all constantly changing at every step, but it just would be a new language
13:25:29 <rasfar> to me, they are actually the most important data source, but that may be personal opinion
13:25:46 <glguy> It would certainly require a whole focus across all the libraries
13:26:08 <glguy> Your view is colored by the kinds of programs you are writing, I think
13:26:11 <rasfar> it's really moments like this where i wish i had more knowledge
13:26:28 <rasfar> especially the kind of program i'm currently writing, indeed
13:26:38 <elliott> "You could probably build a language around the concept that your variables are all constantly changing at every step" -- http://esolangs.org/wiki/Entropy
13:27:10 <hiptobecubic> elliott: wow.
13:27:20 <rasfar> but it relates to testing as well.  QuickCheck depends on "arbitrary" and such testing should really be part of any program, so it's pretty darn important :)
13:27:42 <glguy> QuickCheck is a good example of how the current techniques work well
13:27:58 <glguy> as far as random generation goes, I'm not convinced about actually testing anything :)
13:28:15 <elliott> hiptobecubic: :)
13:28:36 <rasfar> elliott: i sounds like something i could appreciate.  but seriously, i don't have a problem with mixing stochastic variables with pure code.  theoretically it probably breaks everything, but for me in practise it still feels pure.  i don't know...
13:29:14 <rasfar> i like to use random numbers to discover things, it works astonishingly well
13:29:35 <hiptobecubic> elliott: i think i have new favorite language
13:29:52 <hiptobecubic> elliott: i wonder though, if one could come up with a real use for it
13:29:53 <rasfar> but, the search space is big so you need to constain things with determinism
13:30:01 <elliott> rasfar: I assure you, you would not share this feelings if you spent a few weeks with such a Haskell dialect.
13:30:09 <elliott> *these
13:30:45 <nart> hi
13:31:07 <rasfar> hi nart
13:31:56 <rasfar> yes, i really dig Entropy, nice page, I'll read it later, but during my precious online time i hope i can solve my ambiguous type variables issue.
13:32:01 <nart> this has to be the most boring evening ever ... anything new in the haskell world worth noticing ?
13:33:12 <rasfar> it's urgent because otherwise i'm going to end up refactoring the f*k out of my code trying to get it to compile, and make a real mess
13:33:46 <mcstar> ive been here for a couple of days now, and nobody mentioned xmonad all along, so i now do
13:33:54 <rasfar> kallisti, if you're still around, if you're not too terribly busy....
13:34:37 <mcstar> how can you be programming in haskell for 20 years, and cant solve that?
13:35:17 <rasfar> well, 20 years on and off...  also, i'm not that clever unfortunately, just really inspired, if that makes any sense?
13:35:23 <nart> i'm curios, solve what ? can you repost the code ?
13:35:55 <rasfar> the code is over 4000 lines long it seems
13:36:07 <nart> ah ok, nvm
13:36:10 <rasfar> the problem is probably 20 characters or so :(
13:36:17 <mcstar> nart likes challenges
13:36:58 <rasfar> well, nart -- i wrote my first type class today (yes, 20 years and i think this was my first)
13:37:15 <glguy> rasfar: What language do you usually program in?
13:37:16 <rasfar> and i think it is the proper solution to the problem that motivated it
13:37:56 <rasfar> 10 million chars of C or so, so mostly C.  A quantity of Java also.  And Haskell.  Know about 20 other languages in a passing way, but those are the top 3.
13:37:58 <mcstar> i was kidding, i dont know Mr. nart at all
13:38:34 <nart> 4000 lines type class ?? Challenge Accepted ahaha
13:38:35 <rasfar> I'd do everything in Haskell if I could, but I still turn to C when I seriously need to get results in the short term.
13:39:13 <rasfar> heehee, no the type class is almost as small as possible:  http://hpaste.org/66970
13:39:15 <kallisti> rasfar: back
13:39:46 <rasfar> hi kallisti.  so i got rid of Fractional constaint of the typeclass, and got things compiling again.
13:39:58 <rasfar> still get those errors for printConfig etc.
13:40:11 <rasfar> (not that I expected otherwise of course, but that's where it's at)
13:40:23 <kallisti> cool
13:40:43 <rasfar> if i were to post the code for (thanks) printConfig, I may as well disclose the whole program.
13:40:47 <saffron-city> @pl (\g f -> (\ a b -> g (f a b) ) )
13:40:47 <lambdabot> (.) . (.)
13:41:10 <rasfar> and if i do that, a dozen people will tell me how it's already been done, cannot be done, and shouldn't be done, so that's why i keep things secret
13:41:28 <rasfar> because in the end it always works, or something even more interesting comes out of it
13:41:36 <saffron-city> @pl (\f g -> (\ a b -> g (f a b) ) )
13:41:36 <lambdabot> flip ((.) . (.))
13:41:37 <rasfar> (so there!)
13:41:52 <mcstar> too much secret
13:42:06 <rasfar> ya think?
13:42:10 <lispy> hello
13:42:17 <rasfar> hi lispy!
13:42:17 <haskkitten> what is the shortcut for ` sing on us keyboard please ?
13:42:27 <mcstar> i cant even quote movies anymore, it is "too many secrets"
13:42:33 <lispy> We can has types?
13:42:37 <mcstar> 0
13:42:40 <ajg> hi. using parsec, is there a way to extract the token sequence that a parser matched, independently of what the parser itself returns?
13:42:46 <nart> haskkitten: Alt-9 ?
13:42:47 <rasfar> kallisti, i wonder what i should do to best benefit from your presence?
13:42:49 <mcstar> i mean key on top of tab
13:42:56 <nart> hi lispy
13:43:16 <reinoud> hmmm its too quiet with the -B ... it should beep quite a lot but i dont think its even garbage collecting other than the 1st time on start up
13:43:19 <lispy> ajg: Um...I don't think so. Sounds more like what a lexer should be doing.
13:43:21 <haskkitten> nart: does not work for me
13:43:34 <mcstar> haskkitten: key above tab
13:43:38 <reinoud> 7.4.1 is not working well / tested well
13:43:40 <nart> haskkitten: eh sorry, i've a italian keyboard :S
13:43:49 <haskkitten> mcstar: oh thanks!
13:44:01 <haskkitten> np nart
13:44:13 <lispy> travis-ci just keeps getting better. Did you see they are working on a thing to test your pull requests _before_ you accept them?
13:44:33 <glguy> haskkitten: Can you rephrase your question? The US keyboard has a backtick key on it: `
13:44:34 <lispy> If you have code on github and you're not using travis-ci there better be a good reason :)
13:44:51 <elliott> lispy: Can they test the pull requests before they're written?
13:44:54 <lispy> (I don't have a good reason...)
13:44:54 <nart> lispy: mmm, i think i should really check it out
13:45:23 <lispy> elliott: I think the neural implant for that is a bit bugger so far
13:45:29 <haskkitten> mcstar: actually not that one
13:45:34 <haskkitten> the opposite direction
13:45:42 <lispy> buggy*
13:45:48 <haskkitten> 4 `elem` [3,4,5,6]
13:45:49 <rasfar> can someone pls type my nick to see if i get a beep?
13:45:50 <reinoud> if i run a ghc function with -B -c it would beep every time it gc's shouldn't it?
13:45:55 <lispy> rasfar: hello
13:45:56 <vodik> rasfar: no
13:45:58 <haskkitten> glguy: like this ^^
13:45:59 <ajg> lispy: what I had in mind was something like do { a <- getPosition; someParser; b <- getPosition; return $ calculateRange a b }
13:46:01 <rasfar> crap, no beep
13:46:02 <kallisti> rasfar: uh....
13:46:13 <glguy> haskkitten: the backtick you use in that case is above the tab key
13:46:17 <rasfar> once more please?....
13:46:19 <haskkitten> ``
13:46:24 <haskkitten> hmm
13:46:36 <kallisti> > 5 `mod` 2  -- yay examples
13:46:37 <lambdabot>   1
13:46:41 <rasfar> okay, kallisti, we left off with:
13:46:44 <lispy> ajg: and what does getPosition return? character position?
13:46:57 <kallisti> > map (`mod` 3)  -- yay integers modulo 3.
13:46:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
13:46:59 <lambdabot>    arising from a use ...
13:47:03 <haskkitten> glguy: ok sorry for confusion
13:47:08 <hpc> > map (`mod` 3) [1..]
13:47:09 <lambdabot>   [1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,...
13:47:10 <haskkitten> I probably made some typo
13:47:11 <kallisti> > map (`mod` 3) [0..]  -- yay natural numbers modulo 3.
13:47:13 <ajg> it returns a SourcePos
13:47:13 <lambdabot>   [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,...
13:47:25 <rasfar> i added the class, and it caused me to need to constrain variables of type Config a
13:47:37 <rasfar> like (config :: Config Complex)
13:47:55 <lispy> > nub $ map (`mod` 3) [0..] -- I think this is a better set of "represnetatives" of the nats modulo 3
13:47:56 <ajg> lispy: which has line + column numbers
13:47:58 <rasfar> the only thing (almost) that changed was adding the class
13:47:59 <lambdabot>   mueval-core: Time limit exceeded
13:48:14 <elliott> rasfar: It's really impossible to help you without seeing code.
13:48:25 <rasfar> and adding Initable a => constaints in some places where there were none before...
13:48:35 <rasfar> i see.  hmm.
13:48:35 <lispy> ajg: hmm...that sounds do able (modulo backtracking quirks).
13:48:50 <rasfar> can i share the code with you privately?
13:48:54 <hpaste_> Reinoud pasted “gargage collection issue?” at http://hpaste.org/66972
13:49:07 <mcstar> `hashkitten` still `using` the $ same
13:49:11 <rasfar> i can put it up on my server and msg you a link, but it's not small.  it's fairly clean though.
13:49:22 <elliott> rasfar: It is also much easier for people to help if everyone can see the code, so that those who can identify the problem can chip in.
13:49:24 <lispy> ajg: oh, getPosition already exsits: http://cvs.haskell.org/Hugs/pages/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html
13:49:24 <ajg> lispy: yeah, it feels clunky but it's for a quick hack. i was just wondering if something like it already existed
13:49:31 <elliott> Why are you determined to keep it secret? You don't have to hpaste it all.
13:49:38 <elliott> Just a representative snippet that is causing errors.
13:49:43 <ajg> lispy: yeah, getPosition and getInput exist
13:49:52 <lispy> ajg: oh, I've been misunderstanding what you said.  I thought you wanted to know if that pseudocode was possible, but you alreday have that version working?
13:49:54 <nart> rasfar: i wanna see the code too :)
13:50:09 <rasfar> elliott, i know.  but it's ... well, representative snippet... but the thing is, the ambiguous variable errors pop up like weeks when i mess with the types
13:50:22 <ajg> lispy: in theory it's possible :). i haven't tried it.
13:50:26 <mcstar> haskkitten: the backtick is not used in haskell afaik, and there is ' which is 2 keys from Return
13:50:35 <elliott> rasfar: Well, the solutions will probably be mechanical in nature, and have one root cause.
13:50:36 <rasfar> it's almost ready to be disclosed anyway.
13:50:37 <kallisti> > foldr (\x (a,b,c) -> case x `mod` 3 of 0 -> (x:a,b,c); 1 -> (a,x:b,c); 2 -> (a,b,x:c)) ([],[],[]) [1..10] -- they form equivalences classes,  you say?
13:50:38 <lambdabot>   ([3,6,9],[1,4,7,10],[2,5,8])
13:50:47 <elliott> So if you post one example of the error, you may be able to figure out how to solve the rest.
13:51:48 <rasfar> i could start by posting Main.hs along with the error message; if more code is needed we can go from there?
13:51:54 <haskkitten> mcstar: but 4 `elem` [3,4,5,6]  does not work with ''
13:52:07 <kallisti> "backtick is not used in Haskell" what?
13:52:08 <mcstar> no ofc not
13:52:19 <haskkitten> map (recip . negate) [1,4,-5,0.1]
13:52:19 <mcstar> is this a tick or a backtick `
13:52:26 <reinoud> am i right to conclude that in  http://hpaste.org/66972 there is only ONE gc performed and that somehow fails? or is not done often enough?
13:52:26 <nart> backtick
13:52:27 <mauke> there are no ticks
13:52:33 <mcstar> ok, then ticks arent used in haskell
13:52:41 <haskkitten> lambdabot does not speak with me :(
13:52:45 <mcstar> i have it on my keyboard
13:52:46 <elliott> mcstar: what is a tick
13:52:51 <kallisti> haskkitten: need a >
13:52:53 <mauke> haskkitten: you're not speaking with lambdabot
13:52:57 <haskkitten> oh
13:52:59 <monochrom> haha, that's like saying salt isn't used in haskell
13:53:06 <mcstar> ´
13:53:10 <haskkitten> > map (recip . negate) [1,4,-5,0.1]
13:53:11 <lambdabot>   [-1.0,-0.25,0.2,-10.0]
13:53:15 <haskkitten> :)
13:53:21 <elliott> preflex: hey you do unicode right what's ´
13:53:23 <kallisti> haskkitten: awwww yeah
13:53:25 <elliott> preflex: unicode ´
13:53:28 <elliott> preflex: u ´
13:53:29 <mauke> U+00B4 (c2 b4): ACUTE ACCENT [´]
13:53:34 <mcstar> this sint unicode
13:53:34 <elliott> thanks preflex
13:53:37 <mcstar> isnt(
13:53:39 <elliott> yes it is
13:53:39 <mauke> mcstar: yes, it is
13:53:43 <mcstar> no, it ascii
13:53:45 <elliott> no
13:53:47 <kallisti> incoming pedantry
13:53:51 <monochrom> haha
13:53:55 <elliott> no, it's not even ascii though
13:53:59 <mauke> mcstar: it's not ascii
13:53:59 <elliott> might be latin-1? it's definitely not ascii
13:54:01 <mauke> mcstar: ascii is unicode
13:54:08 <hpc> U+0060    (96): GRAVE ACCENT [`]
13:54:08 <nart> kallisti: ahahah i was going to say it
13:54:10 <hpc> there is no backtick
13:54:16 <monochrom> it began as latin-1 and got merged into unicode
13:54:21 <merijn> mcstar: unicode is a superset of ascii
13:54:23 <lispy> kallisti: yeah, but i would say 〖0〗= {3,6,9}, 〖1〗= {1,4,7,10}, 〖2〗= {2,5,8}
13:54:34 <mauke> elliott: http://mauke.hopto.org/stuff/javascript/unicode.html?q=%C2%B4
13:54:42 <monochrom> and yes, ascii got merged into unicode, too
13:54:46 <elliott> mauke: thanks, preflex!
13:54:59 <mauke> elliott: it can search by character, number, or name
13:55:00 <ion> In fact, UTF-8 is a superset of ASCII.
13:55:05 <monochrom> do not underestimate how unicode-ready your keyboard is
13:55:36 <lispy> kallisti: Where, 〖0〖0〗means the numbers equal to 0 mod 3 in the range [0..10] :)
13:55:45 <mcstar> hah, it isnt in ascii
13:55:45 <lispy> kallisti: oh boy, cut and paste doesn't like me
13:55:49 <nexion> is it possible to have both forall and a typeclass specified? like: unpackMessageParams :: forall b . (MessageType a) => a -> ByteString -> Maybe b
13:55:49 <mcstar> i thought it was
13:55:57 <lispy> so much for being pedantic about equivalence classes
13:56:00 <kallisti> lispy: wat
13:56:00 <elliott> nexion: you forgot "a"
13:56:03 <elliott> "forall a b. ..."
13:56:05 <hayashi> @pl \x -> Just (x,a)
13:56:05 <lambdabot> Just . flip (,) a
13:56:20 <nart> @help pl
13:56:20 <lambdabot> pointless <expr>. Play with pointfree code.
13:56:31 <nexion> perhaps I misunderstood what forall does
13:56:37 <nexion> wouldn't "MessageType a" specify what a is?
13:56:42 <elliott> there is no "a"
13:56:44 <kallisti> lispy: are you just making up notation
13:56:49 <elliott> "a -> b -> c" is shorthand for "forall a b c. a -> b -> c" generally
13:56:57 <lispy> kallisti: I was just noticing that in your output you were showing not the equivalence class resperetatives, but the equivalance class members. The distinction is kind of asinine.
13:57:00 <elliott> but if you specify it explicitly you must list all variables you want to quantify over
13:57:00 <nexion> ah
13:57:07 <nexion> so specifying forall means I am overriding the default
13:57:13 <kallisti> lispy: oh yes. well I did say equivalence classES
13:57:14 <hayashi> wait a sec
13:57:17 <nexion> I see
13:57:17 <lispy> kallisti: yes I am, and I was trying to provide the definition but my attempt to cut and paste failed
13:57:17 <nexion> ty
13:57:21 <hayashi> this is a maybe with the default set to Nothing
13:57:25 <hayashi> why oh why didn't I just use >>=
13:57:38 <kallisti> lispy: it's the partition of equivalence classes, whatever that's called.
13:57:55 <hpaste_> rasfar pasted “a complete Main with error” at http://hpaste.org/66973
13:58:11 <rasfar> i was able to delete most of Main, as there were many alternative routes
13:59:06 <ajg> lispy: in case you ever need it, turns out what I want exists: http://hackage.haskell.org/packages/archive/pandoc/1.9.2/doc/html/src/Text-Pandoc-Parsing.html#withRaw
13:59:40 <rasfar> sorry if there's still embarrassing comments in there
14:00:59 <rasfar> actually i now see that my old code had "Config Double" in the type sigs, so I am bidding for higher polymorphism and shouldn't be surprised there are errors
14:01:01 <lispy> ajg: cool.  What do you use it for, unparsing? Later analysis? Error reporting?
14:01:06 <hayashi> Hmm.  I'm trying to do an operation on the fst of a pair that returns a Maybe, and propagate that Maybe out into the entire pair
14:01:24 <hayashi> I don't think there's going to be any fundamentally nice way to do this
14:01:25 <lispy> hayashi: can you write down the type?
14:01:53 <lispy> hayashi: something like this? (Maybe a, Maybe b) -> Maybe a
14:02:03 <qnikst> hello, I have next problem I want to parse special matrix of expressions here is full problem: https://gist.github.com/2387857
14:02:20 <hayashi> Unfortunately, it's currently looking like (Maybe a, b) -> Maybe (a,b)
14:02:26 * lispy suspects it's haskell class season :)
14:02:34 <hayashi> This whole thing probably needs knocking out and rewriting
14:02:50 <rasfar> if the #if 0's are offensive I can post again with the dead code removed...
14:04:06 <lispy> ?hoogle Monad m => (m a, b) -> m (a,b)
14:04:07 <lambdabot> No results found
14:04:21 <ajg> lispy: i need to parse a blob of text making sure it's valid (using a TokenParser), but then need to include it verbatim in the output.
14:04:22 <hayashi> @pl \x y -> (f x) >>= \a -> (a,y)
14:04:23 <lambdabot> (. flip (,)) . (>>=) . f
14:04:28 <hayashi> no thanks
14:04:35 <lispy> ajg: ah
14:04:55 <elliott> hayashi: \(a,b) -> fmap (,b)
14:04:56 <elliott> hayashi: \(a,b) -> fmap (,b) a
14:05:01 <elliott> @pl \a b -> fmap (,b) a
14:05:02 <lambdabot> (line 1, column 15):
14:05:02 <lambdabot> unexpected ","
14:05:02 <lambdabot> expecting lambda abstraction or expression
14:05:04 <elliott> @pl \a b -> fmap (flip (,) b) a
14:05:05 <lambdabot> flip (fmap . flip (,))
14:05:11 <elliott> uncurry (flip (fmap . flip (,))) :P
14:05:25 <ajg> lispy: anyway, thanks for the help. cheers.
14:06:00 <rasfar> (actually there's not much preprocessor in there)
14:06:36 <qnikst> elliott: maybe you'll give some advices about my problem, you are always giving good ideas ^)
14:07:57 <rasfar> anyhow, i hope i didn't paste that for nought ... if there's anything i can do to improve the presentation etc. just let me know.
14:08:17 <buzzone> hello everyone. i was using xmonad with gnome 2 for quite some time. then i tried gnome 3 but didn't like it. no i switched to xfce+xmonad. everything is great except that fullscreen windows don't work anymore. i'm quite desperate right now...
14:08:31 <lispy> buzzone: you probably want to ask in #xmonad
14:08:40 <buzzone> lispy: ok. thank you
14:09:31 <lispy> rasfar: wow, that's a lot of code to help with
14:09:44 <lispy> rasfar: Maybe you can make a smaller example?
14:11:13 <lispy> rasfar: have you tried what the error messages suggests?
14:11:15 <rasfar> i could pare it down more, but ... there are other source files too
14:11:42 <gloucester> Beginner question: Is it possible to import functions that are not included in a module's export list?
14:11:58 <byorgey> gloucester: no
14:12:06 <qnikst> impossible
14:12:11 <rasfar> lispy: okay, i think i panicked but i see what happened how.
14:12:28 <gloucester> Thanks byorgey. So is the only work-around to use your own version of the module that exports what you want?
14:12:34 <lispy> rasfar: Need to parse getArgs before using them?
14:12:36 <rasfar> i thought my code was polymorphic in a before, but i had explicit "Config Double" all over the place (it was polymorphic until recently)
14:12:48 <lispy> ah
14:12:57 <rasfar> then when I needed to generalise due to introducing a typeclass, all hell broke loose.
14:13:04 <byorgey> gloucester: yes.
14:13:10 <merijn> gloucester: Why do you need this?
14:13:20 <byorgey> gloucester: or get whoever maintains the module to add stuff to the export list.
14:13:32 <rasfar> i was freaked out by the messages, because i didn't know if i could believe the suggestions would solve my problem, and it will mean a significant amount of refactoring
14:13:49 <rasfar> becasue when i fix those ones, the next 10 compilation attempts i'll get new ones...
14:13:56 <rasfar> (been through this a number of times)
14:14:21 <lispy> rasfar: if you're doing a lot of type refactoring, sometimes type aliases help
14:14:27 <rasfar> since i was trying to use a custom class and instances for the first time, i thought i better see if there wasn't some more isolated cause of the troubles
14:14:31 <lispy> creates just a bit on indirection
14:14:34 <merijn> Type aliases are great :)
14:15:07 <nexion> Is it possible for a function to specify only a typeclass as its return type and be able to return anything that matches the typeclass? I'm trying to write a wrapper for MsgPack's unpack which can return anything of the type class "Unpackable", but I get "Could not deduce" errors as soon as I tag the return value with a type
14:15:10 <merijn> In fact, I think my entire development approach would be impossible without them :p
14:15:23 <rasfar> really? i used to use them a lot, but started shying away from them because they aren't distinguished by the compiler.  i can't recall exactly the problems that caused me, but i remember swearing off aliases several times.
14:15:35 <lispy> nexion: read works this way, if I understand you
14:15:36 <lispy> :t read
14:15:37 <lambdabot> forall a. (Read a) => String -> a
14:15:39 <merijn> nexion: Yes, (if I parsed your question correctly)
14:15:43 <rasfar> (took me a while to learn my lesson and keep off them; my old Miranda code had lots and lots)
14:15:50 <lispy> > read "1234" :: Int
14:15:51 <lambdabot>   1234
14:15:52 <nexion> unpackMessageParams packedParams = MP.unpack packedParams <-- works, but
14:15:57 <nexion> unpackMessageParams packedParams = MP.unpack packedParams :: (Int, String) <-- errors
14:16:15 <lispy> nexion: what is the type of unpackMessageParams?
14:16:24 <david> hey guys, I'm trying to install snap and I'm failing on a package called "Network" and it says this: * Missing (or bad) header file HsNet.h
14:16:24 <merijn> rasfar: I don't see how that would cause problems?
14:16:28 <nexion> unpackMessageParams :: (MP.Unpackable b) => ByteString -> b
14:16:36 <hpc> lemme guess
14:16:43 <david> any ideas why?
14:16:48 <hpc> "no instance for Unpackable (Int, [Char]) at ..."?
14:16:51 <rasfar> merijn: i wish i could remember, but there must have been trouble or i wouldn't have stopped using them!
14:16:59 <lispy> nexion: That type looks good. Depends now on what instances you have
14:17:06 <gloucester> byorgey, merijn: I need/want access to type constructors that are not exposed. The module writers intend you to use some constructor functions, but that doesn't work for my purposes (and makes life more difficult because I can't use pattern-matching)
14:17:29 <rasfar> i think the trouble (and this might have been when i was still using the HBC compiler) is, that the compiler errors didn't name the type aliases in the errors.
14:17:37 <nexion> (Int, String) should be a valid Unpackable
14:17:37 <hpc> gloucester: a workaround might be view patterns
14:17:46 <rasfar> the expanded them.  which i found really confusing.
14:17:47 <nexion> same with just Int -- http://hackage.haskell.org/packages/archive/msgpack/0.7.1.4/doc/html/Data-MessagePack-Unpack.html#t:Unpackable
14:17:49 <merijn> rasfar: An example, in my latest code I have "type Task a b = Info a -> Chan b -> Chan b -> IO ()" just so I can write all my code using "Task a b" as input/output types without taking into account the (constantly changing) arguments a task needs
14:17:52 <Peaker> kallisti: why do you say that you don't understand conduits?
14:17:57 <lispy> rasfar: I don't think using type aliases often is good either, FWIW
14:18:15 <gloucester> hpc: I looked at that briefly, maybe I will go look more
14:18:15 <lispy> rasfar: but they can have strategic value
14:18:24 <rasfar> merijn: but then the compiler errors are hard to read because you never see those types in practise.
14:18:24 <byorgey> gloucester: out of curiosity, what package is this from?
14:18:50 <gloucester> byorgey: Data.Typeable and Data.Dynamic
14:18:58 <rasfar> i think that must have been my reason for shying away from them, at any rate
14:19:10 <merijn> rasfar: I haven't run into any problems with that yet. And writing them out completely makes the actual code unreadable anyway
14:19:15 <nexion> I'll paste the function I'm trying to write; that should make it clearer. one sec
14:19:18 <rasfar> while understanding that i'm using them all the time with libraries :)
14:19:36 <merijn> (Since "Task a b -> Task a b -> Task a b" easily fills up four lines for no good reason if you expand it)
14:20:07 <rasfar> maybe GHC (at least now; the time i'm thinking of when i quit them was about 2003) now shows the alias in the error message.  that would be nice.  i can't think whether it deos or not at the moment.
14:21:17 <rasfar> i used them a whole lot, back before i learned about alg. datatypes -- after started using those, it seemed less pressing.
14:21:47 <rasfar> but i agree that writing out the types in full in the code is a tradeoff.
14:22:29 <rasfar> however, i can format my code to be more readable and familiar, but if i only ever see those types in compiler error messages -- already notoriously difficult to read -- then it freaks me out.
14:22:48 <nexion> http://hpaste.org/66974 <-- is it possible to do something like this?
14:22:57 <rasfar> (probably i'll experiment with using them more again, after having had this conversation, thank you)
14:23:13 <rasfar> thanks lispy also
14:23:33 <mauke> nexion: why is there a 'return' in there?
14:23:34 <merijn> rasfar: You just shouldn't let yourself be scared so easily by errors ;)
14:23:56 <rasfar> alright, i'm diving into this refactoring.  no type aliases needed; aliases for long lists of type variable constraints might be nice though.
14:24:11 <gloucester> byorgey, merijn, hpc: Thanks for the help. Must run.
14:24:25 <dropdrive> Did anyone see the "make for haskell values" on reddit?  I'm really curious if something similar exists for other languages.
14:24:26 <rasfar> maybe i can use my new class for that, but i guess it's better to constrain on a per-method basis?
14:24:57 <nexion> mauke, I'm still a bit unclear on whether or not I need it for Maybe
14:25:00 <hpc> dropdrive: link?
14:25:31 <nexion> I know it puts the value in the monad
14:25:32 <dropdrive> hpc: http://www.reddit.com/r/haskell/comments/s7it0/make_for_haskell_values_alpha/
14:25:42 <lispy> :t return (eitherToMaybe (Right 1))
14:25:42 <lambdabot> Not in scope: `eitherToMaybe'
14:26:00 <hiptobecubic> dropdrive: i didn't really understand what it was doing
14:26:02 <nexion> lispy: it's a custom function.. takes an Either and returns Maybe
14:26:02 <rasfar> merijn, yeah sure, but you must admit, if in the code you only see "Task a b" and in the errors you never see it, and see instead ... whatever was that long thing you typed, then that is disconcerting.
14:26:17 <nexion> lispy: eitherToMaybe :: forall a b . Either a b -> Maybe b
14:26:20 <lispy> nexion: sure, I was just trying to help clarify your situation
14:26:42 <lispy> :t return (Just 1)
14:26:43 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m (Maybe t)
14:26:50 <dropdrive> hiptobecubic: I guess maybe "make :: files" :: "??? :: haskell values" ?
14:26:52 <lispy> nexion: where, m in your case is Maybe
14:26:55 <hpaste_> stj pasted “cabal install darcs” at http://hpaste.org/66975
14:27:04 <lispy> nexion: so you're creating a Maybe (Maybe Int)
14:27:07 <stj> I can't install darcs (cabal install darcs) because there is a dependency mess -- any idea what may be wrong?
14:27:37 <nexion> I've removed the returns
14:27:37 <lispy> stj: Let me guess, you want to use ghc 7.4.1?
14:27:50 <stj> yes
14:28:01 <nexion> I still get: Couldn't match type `Bool' with `Int'
14:28:14 <lispy> stj: I'd try the darcs version of darcs then. I doubt a hackage release has been made
14:28:20 <nexion> it seems it's expecting a single return type
14:28:29 <mauke> nexion: it is
14:28:56 <mauke> nexion: what could a caller do with a function whose return type is unknown?
14:29:16 <lispy> nexion: Oh yeah, I feel silly for not seeing the error sooner.
14:29:19 <kallisti> Peaker: oh, nevermind.
14:29:21 <kallisti> I solved that issue
14:29:24 <hpc> heh, yo dawg i heard you like darcs
14:29:24 <td123> stj: try darcs-beta
14:29:25 <kallisti> but now I'm confused once again. :P
14:29:32 <lispy> nexion: just because Int and Bool are instances of Eq doesn't allow you to put Int and Bool in a list
14:29:37 <td123> stj: it's in hackge
14:29:38 <lispy> nexion: this is a very similar problem
14:29:40 <stj> wow, is darcs gone from the archlinux extra repository?
14:29:46 <kallisti> Peaker: the forever thing that we came up with causes a huge memory leak, btw.
14:30:02 <kallisti> so far I've been using fix to do loops, but I end up repeating myself a lot. there's probably a better way.
14:30:05 <nexion> yeah.. those are just the example types too
14:30:20 <nexion> I was going to have stuff like (Int, Text, Text, [(Int, Text)])
14:30:43 <nexion> I'm not sure how to achieve this
14:30:56 <lispy> nexion: one simple thing you can do is make a sum type for all the response types and return values sof that
14:31:12 <lispy> data Response = IntResp Int | BoolResp Bool ...
14:31:42 <nexion> based on the message type, I know what type to expect from tryUnpack and would like to pass it to a handler function
14:32:05 <nexion> perhaps instead of returning that type, I can instead take the handler as the parameter and call it with the parameter being the unpacked version of the message
14:32:17 <lispy> Yes, that will get you closer to a solution
14:32:33 <lispy> But this handler needs to be sufficiently polymorphic for it to work
14:32:36 <mauke> that sounds like a manually fused pattern match
14:32:48 <mauke> oh, I thought you'd have multiple handlers
14:33:00 <nexion> one handler for each message
14:33:11 <lispy> Oh, then what mauke said
14:34:03 <rasfar> kallisti, elliott, lispy: can we look at that code a bit together?  if i follow the advice of the compiler, it still gives the same messages.
14:34:17 <lispy> You can of course use a type class to make a family of handler functions, although that strikes me as a solution of dubious quality.
14:34:23 <rasfar> that's http://hpaste.org/66973
14:34:31 <nexion> I could just do: handleMessage :: MessageType a => a -> ByteString, pattern-matching on a and doing the unpack inside each handler
14:34:39 <nexion> but it seems more natural to call the handler with the typed parameters
14:34:55 <lispy> nexion: You can't pattern match on something of type forall a. a
14:35:17 <lispy> Or even Foo a => a
14:35:37 <nexion> true
14:37:05 <nexion> I could add handleMessage to the MessageType class
14:37:23 <rasfar> people ask for more code, which i'm reluctant to paste, i paste it, and nobody stays around, great!
14:38:08 <stj> anyone here using archlinux? I'm having a hard time installing it
14:38:12 <stj> installing darcs
14:38:40 <lispy> rasfar: I'm looking at it, but I'm regret to say that I can't make much sense of it. What is "config" and where does it come from?
14:38:53 <kallisti> lispy: is it the same ambiguous error you were having before?
14:38:55 <kallisti> er
14:38:58 <kallisti> rasfar: ^
14:39:10 <rasfar> ( config :: (Random a, Initable a, RealFloat a, Num a) => Config a ) doesn't work...
14:39:10 <lispy> nexion: yes, but I think that's a dubious solution. How can people using your API change the handler?
14:39:11 <hayashi> stj: I'm running arch, but I probably won't be of much help =/
14:39:25 <rasfar> no it's a "skolem" error (never seen that before!)
14:39:33 <ursthegiz> question: i have one haskell type, let's say a Vector3 (3d vector), which I in general want to use in a game lib. I have sub-libraries for graphics from C++, where I need to marshall the Vector3 to a c-struct cvect3-one. Then I use another library, lets say for phyiscs and here also ANOTHER c-struct with same semantics is used, named cvect3-two. I want to marshall the SAME Haskell type Vector3
14:39:33 <ursthegiz> to both different structs ... But ... -> marshalling structs -> with :: Storable a ... -> Storable is a instatiation of a typeclass -> this is GLOBAL in Haskell, -> I cannot use it for both c-structs, only for one ??? What to do?
14:39:34 <rasfar> thanks kallisti for coming back
14:39:51 <rasfar> i really have a feeling i need help with this; i don't ask very often :)
14:40:08 <kallisti> I haven't been paying attention so I'll need more info
14:40:15 <kallisti> if it's the same ambiguous type thing you just need to add an annotation somewhere
14:40:20 <kallisti> because it can't infer the type you want.
14:40:28 <rasfar> lispy: I used to pass all parameters as arguments, but thought I should refactor to use a Config structure.
14:40:45 <rasfar> seemed like a good idea, but turns out record syntax of nested datatypes is rather hairy
14:40:46 <nexion> lispy, I agree.. it's not the best place to have those implementations
14:41:07 <hayashi> barrucadu: Have you installed darcs on arch at any point?
14:41:13 <rasfar> kallisti, it seems to be a fine balance between under-constraining and over.
14:41:16 <nexion> trying to think of a better way to organize this
14:41:30 <lispy> nexion: I would create a struct with a handler for each message type and pass that in
14:41:34 <barrucadu> hayashi: No
14:41:43 <nexion> I could drop the type classes and instead have a different version of each of the instance methods
14:41:45 <lispy> nexion: then users can provide a different struct if they want or use the default
14:41:51 <rasfar> one thing you may be able to explain easily -- when I have a type sig (top-level), and -- typically during debugging -- i add a type sig to a function in a where clause, i get an error.
14:41:55 <mrBG> isit possible to program for any mobile phone with haskell?
14:41:56 <lispy> nexion: this is simple a manual encoding of what type classes give you.
14:42:08 <rasfar> Can't unify a ~ a1 sort of errors.
14:42:23 <lispy> mrBG: Not sure about android, but yes with iphone
14:42:26 <rasfar> if you have a type variable, can't you reuse it in local declarations?
14:42:35 <merijn> mrBG: I believe some people are using haskell to develop a game for iOS
14:42:41 <kallisti> rasfar: I really think you're taking that advice too far.
14:42:42 <lispy> rasfar: only if you turn on lexically scoped type vars
14:42:43 <kallisti> and overthinking it.
14:42:45 <rasfar> or is there any syntax to link them??
14:42:45 <kallisti> everywhere
14:42:55 <nexion> lispy, actually just thought of that too :)
14:43:08 <kallisti> rasfar: it's an ambiguous type. meaning the compiler cannot infer the /specific/ /monomorphic/ type you want.
14:43:09 <rasfar> what advice?
14:43:30 <kallisti> rasfar: I don't think it has anything to do with too many or too little constraints.
14:43:41 <kallisti> assuming it's the same ambiguous type error.
14:43:55 <rasfar> yeah, it's amazing how errors can be made to go away by enabling recommended language extensions, but i always have this feeling that it's the wrong way out...
14:44:07 <kallisti> what does this have to do with language extensions?
14:44:26 <rasfar> well, okay, basically in the hpaste, on line 233
14:44:44 <lispy> ursthegiz: make types that correspond to the C++ types (cvect-one, cvect-two) and make storable instances for those and two functions Vector3 -> CvectOne and Vector3 -> CvectTwo
14:44:58 <rasfar> the compiler errors (from the top of the paste) occur, so i add the recommended constraints to the doit11 function
14:45:03 <kallisti> rasfar: link
14:45:19 <rasfar> http://hpaste.org/66973
14:45:33 <rasfar> the constraints are already in "doit11" function
14:45:49 <kallisti> what is the type you're putting there
14:45:52 <rasfar> so I thought maybe the compiler means I need constaints at the point of the application of doit11
14:46:00 * lispy goes off to do other things
14:46:02 <lispy> cheers
14:46:03 <kallisti> it does not need any more constraints.
14:46:03 <ursthegiz> lispy: I thought on that, for the conversion functions, can I CAST the types or do I need to copy them (would be a lot of copying)
14:46:08 <kallisti> it's asking "what type is this"
14:46:09 <rasfar> lispy, cheers.  sorry if
14:46:20 <rasfar> i wasn't fully responsive, i'm juggling a lot of windows here
14:46:26 <kallisti> lispy: oh wait.
14:46:34 <kallisti> er
14:46:38 <kallisti> werjiwetjoiwjeroijwertoijweorijqeotijqwr
14:46:44 <kallisti> rasfar: don't use undecideable instances.
14:46:50 <kallisti> whenever GHC suggests you turn it on, ignore it.
14:46:54 <rasfar> i want to keep it polymorphic, so i prefer constraints
14:47:07 <kallisti> ...you don't understand.
14:47:08 <rasfar> (oh thanks for reminding me; i'll comment out those extensions, i don't think they helped)
14:47:24 <luite_> kallisti: undecidable instances aren't that bad
14:47:26 <rasfar> okay i'll avoid that extension
14:47:32 <kallisti> luite_: they are if you don't know what you're doing.
14:47:35 <any-key> I'm back with more ByteString annoyances... http://pastebin.com/hFWn3zay
14:47:38 <mauke> The paste hFWn3zay has been copied to http://hpaste.org/66978
14:47:46 <rasfar> or maybe ... oh, whatever.  i'm sure i don't need more tha H98 to write this program!
14:48:04 <any-key> I'm trying to figure out how to get a vanilla ByteString out of this
14:48:06 <kallisti> rasfar: this code is ridiculous
14:48:10 <luite_> if you're getting overlapping instances you should be getting a bit worried, incoherent instances, better run ;p
14:48:10 <rasfar> kallisti, yes i don't understand, this is key.
14:48:13 <kallisti> you should use version control instead of comments everywhere.
14:48:39 <any-key> Since it's from a file it gets wrapped up in IO, but none of the ByteString functions will take an IO ByteString
14:48:43 <rasfar> kallisti, no, #if switches are much more efficient.  i'm sorry if it looks like hell, but usually only i see it.
14:48:46 <merijn> luite_: Depends on your type hack-fu ;)
14:49:08 <rasfar> the code isn't so bad as all that, surely?
14:49:43 <luite_> merijn: hmm, IncoherentInstances really is scary though
14:49:49 <merijn> rasfar: Depends, I torture all my colleagues that commit code that has "#if 0" statements until they promise to change their wicked ways
14:50:17 <ursthegiz> How can I cast one record type into another with same fields, without loosing performance (no copy)?
14:50:17 <hpc> merijn: you torture them by deleting all their dead code and committing again?
14:50:21 <rasfar> if i was working with other programmers i might need to change, but for solo development i've found it best for me.
14:50:26 <luite_> merijn: unless you truly don't care which instance is picked
14:50:36 <rasfar> kallisti: i really do need to understand this
14:50:46 <kallisti> rasfar: "" ++ ...
14:50:47 <kallisti> what
14:50:49 <merijn> hpc: And by removin their commit access to the main branch :D
14:50:56 <kallisti> why would you concatenate "" to the front of something
14:51:00 <hpc> ursthegiz: do they have the same fields in the exact same order?
14:51:09 <hpc> kallisti: performance
14:51:11 <hpc> ;)
14:51:12 <rasfar> so if I don't constrain the "config" at line 233, i get an error.  if I tell it it's a Config Double, I'm fine.
14:51:19 <ursthegiz> hpc: yes, reason see above answer from lispy
14:51:19 <kallisti> hpc: whut
14:51:26 <rasfar> If I constrain it more gently with Rational a, etc. I get a new error.
14:51:31 <hpc> ursthegiz: unsafeCoerce
14:51:48 <kallisti> rasfar: an ambiguous type error occurs because a variable is too polymorphic
14:51:53 <rasfar> kallisti: "" ++ ... on separate lines so I can comment them out with a few keystrokes.  it happens many many times per day.
14:51:55 <ursthegiz> hpc, lispy: thanks a lot, I check that
14:52:01 <kallisti> rasfar: at some point in the compilation process GHC needs to know the specific type being used.
14:52:12 <rgr> is http://learnyouahaskell.com/ considered a good starting point for Haskell? Seems competently written and progresses well.
14:52:15 <rasfar> without the initial "" ++ you get syntax errors if you comment out the first part
14:52:16 <kallisti> rasfar: here's an example of where a type is ambiguous
14:52:16 <elliott> rgr: yes
14:52:19 <hpc> (it's obviously unsafe, but if the types are identical it won't break things)
14:52:20 <rasfar> that should be self-evident
14:52:21 <qnikst> is there a simple way to parse string expression writen in haskell syntax?
14:52:23 <merijn> rgr: Yes, very
14:52:25 <elliott> rgr: probably the most commonly-used introduction
14:52:30 <kallisti> rasfar: show (read x)
14:52:35 <rgr> great. Thanks. Very well presetned and written. kudos.
14:52:38 <kallisti> rasfar: what type do you want me to read? what type do you want me to show?
14:52:39 <rasfar> okay, back to show/read, good
14:52:47 <kallisti> rasfar: the only things that we know are these constraints...
14:52:51 <kallisti> we don't know what type is being used
14:52:56 <hpc> qnikst: what do you want to do with it? evaluate it?
14:53:00 <kallisti> we need to know the type to call the right method.
14:53:02 <hpc> @hackage mueval
14:53:03 <lambdabot> http://hackage.haskell.org/package/mueval
14:53:06 <qnikst> i.e. I've got smth like "1+3*2" and I want to evaluate it with TH
14:53:16 <rasfar> but ... all the functions are (trying to be) polymorphic, that's my objective here.
14:53:18 <hpc> oh, with TH
14:53:21 <hpc> no clue
14:53:31 <kallisti> rasfar: yes. that's fine. there's just one place where it can't be.
14:53:32 <qnikst> hm.. it seems I can use libs in TH
14:53:35 <qnikst> thanks )
14:53:42 <rasfar> but you are saying, in actually executing the code, the types have to be monomorphic?
14:53:47 <kallisti> of course.
14:53:53 <merijn> rgr: After finishing LYAH I can recommend Real World Haskell for some useful real world examples and things. It's also freely available online
14:53:55 <rasfar> so something needs instantiation at a monomorphic type to prime everything?
14:53:58 <merijn> @where rwh
14:53:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:54:06 <rgr> I have real world haskell in hardcopy.
14:54:09 <kallisti> rasfar: not by the coder, no. the types just have to infer it.
14:54:18 <kallisti> rasfar: what is result of this code:  read "2"
14:54:20 <kallisti> can you tell me?
14:54:27 <merijn> rgr: Then you're all set :p
14:54:34 <hpc> > read "2"
14:54:35 <lambdabot>   *Exception: Prelude.read: no parse
14:54:36 <rasfar> no i suppose not.
14:54:41 <hpc> well, that was easy ;)
14:54:43 <rgr> I learnt some ages ago when I set up xmonad but decided to come back to it.
14:54:43 <kallisti> lambdabot is bad.
14:54:44 <rasfar> you can't even be sure it's a Num
14:54:48 <kallisti> don't pay attention to it.
14:55:03 <kallisti> rasfar: that's because the type is ambiguous. all we know about the result of read is that it's some (Read a) => a
14:55:03 <rasfar> > read "2" :: Num
14:55:04 <lambdabot>   Class `GHC.Num.Num' used as a type
14:55:09 <rasfar> oops, right
14:55:16 <kallisti> rasfar: in order to actually call read, we need to know its type
14:55:18 <rasfar> that is rather to the point, actually, isn't it :)
14:55:19 <kallisti> so we can use the right code.
14:55:35 <kallisti> with just the code read "2"
14:55:37 <kallisti> we have no idea what that is.
14:56:04 <rasfar> yeah, i do know that about read specifically; it's the first thing i ever needed an expression type sig for
14:56:10 * kallisti can't figure out where the bug is in your code though, because it's a mess.
14:56:30 <rasfar> kallisti, it's not really such a mess considering it's > 4000 lines in 2 weeks time.
14:56:36 <ClaudiusMaximus> any-key: try replacing the $ with `liftM` or `fmap` or <$> depending on taste (they all do the same thing, but some might require imorting Control.Monad or Control.Applicative)
14:56:42 <rasfar> it is in a major state of flux
14:56:55 <rasfar> i stand by my coding conventions for the pace i'm working at
14:57:23 <any-key> ClaudiusMaximus: heh I just got it to work by invoking it from ghci with:
14:57:23 <any-key> (Main.getContents "Test.class") >>= (\bytes -> let (valid, rest) = checkMagicNumber bytes in (do print valid))
14:57:42 <rasfar> but i admit i have a lot to learn, maybe that stance was a too strong.  but really...
14:57:51 <kallisti> rasfar: what happens hen you use a WW_Config with a Method_LCPM
14:58:22 <kallisti> oh nevermind
14:58:30 <rasfar> great question.  the Config and "subtypes" (or whatever you call nested types) need some ironing out.
14:58:55 <rasfar> is that "oh nevermind" it's hopeless, or nevermind you figured it out?
14:59:10 <kallisti> I misread the code.
14:59:29 <kallisti> rasfar: the Method type looks completely useless.
14:59:36 <rasfar> oh i see; thanks.  i'm sure the Config etc. has some stupidities, it's fairly new.
14:59:41 <kallisti> it serves absolutely no purpose.
14:59:54 <rasfar> okay, tone it down, it's alright.
15:00:07 <rasfar> let me see what the idea was there...
15:00:50 <rasfar> well, there are different "techniques" ("methods") i'm trying, and i need to select between them.
15:01:07 <rasfar> how else to do it?
15:01:27 <rasfar> so I pattern match on the Method datatype, and dispatch the appropriate function.
15:01:54 <kallisti> right, I meant that the *_Configs don't really need to be there it seems.
15:02:00 <rasfar> i suppose the function itself could be a member of the datatype (being first-class), but this seemed simpler as a starting point.
15:02:03 <kallisti> you can just directly substitute them into Method
15:02:15 <rasfar> the Config's are overkill/stupid, and on their way out probably.
15:02:16 <kallisti> unless you need them seperate for some reason  (you could use a GADT in that case...)
15:02:27 <rasfar> I mean the indiv. method configs of course
15:03:03 <rasfar> but the initialisation methods, and the (iteration) methods, are really key, and deserve prominent treatment in the Config
15:03:58 <rasfar> on the whole i'm satisfied with the Config as it brought together all my concerns into one place (the set of datatypes), whereas at first they were ad hoc and all over the place.
15:04:10 <rasfar> that's how experimental coding happens over here
15:04:40 <rasfar> but what disappointed me is how hard it is to modify a Config variable, so there was a tradeoff there
15:05:01 <kallisti> I mean
15:05:02 <rasfar> still need to deconstruct down to where the record selector is
15:05:06 <kallisti> why not just take the fields of each *_Config
15:05:09 <kallisti> and dump them directly into Method
15:05:19 <kallisti> and remove the extra boilerplate nonsense.
15:06:21 <Peaker> kallisti: why was the forever thing leaking?
15:06:31 <rasfar> right, it was overkill.  it was a mistake.  maybe later they would be justified, but at this point it's vacuous boilerplate, true.
15:06:35 <kallisti> Peaker: I'm honestly not sure.
15:07:29 <rasfar> but while i have you here, let's talk a bit more about the type problem please.  this code was not intended for sharing and would be a lot more trim when published.
15:08:06 <rasfar> i guess there's some constant somewhere that needs a type constraint, similar to the read "2" example?
15:08:25 <rasfar> it works to constraint ( config :: Config Double ) at line 233
15:09:27 <rasfar> but that seems strange and indirect -- yet maybe not; maybe that is the best way to state that "this route through the code is dealing with a ~ Double"
15:09:52 <kallisti> rasfar: if it can't be inferred
15:09:54 <kallisti> by something else.
15:09:55 <rasfar> s/constraint/constrain/ -- sorry i make a lot of typos in irc
15:10:02 <kallisti> for example
15:10:06 <kallisti> > read "2" + read "2"
15:10:07 <lambdabot>   4
15:10:09 <kallisti> here the type is inferred
15:10:15 <rasfar> yeah, that was a nice example.
15:10:30 <rasfar> that also shows how refactoring code can introduce unexpected type ambiguity errors
15:11:18 <rasfar> i feel like i'm lost in a soup of partially-constrained types, trying to hold out for generality, and not sure where to push the tack in.
15:11:35 <hayashi> @pl \x y -> f x >>= \a -> return (a,y)
15:11:35 <lambdabot> flip (fmap . flip (,)) . f
15:11:59 <rasfar> maybe the config variables are the most sensible place to pin the type down, after all
15:12:13 <rasfar> in which case i must hand it to the compiler for pointing me to it
15:12:36 <rasfar> or maybe i just think it's the best place because my attention is focused on it, and writing :: Double makes it work...
15:12:44 <kallisti> your problem just looks like a really complicated case of show (read x)
15:13:48 <Peaker> kallisti: hmm.. the forever thing is not an identity for (=$=) because it doesn't do early termination
15:14:04 <rasfar> right. ok, i suppose i should take a deep breath and try again.  i just felt i needed help because i was experimenting with a custom typeclass for the first time, and things got ugly.
15:14:18 <mietek> Is it possible to pattern match on the result of a function?
15:14:20 <kallisti> rasfar: you should use version control
15:14:23 <kallisti> and not name your functions doit11
15:14:28 <mietek> As in, use a function in the pattern?
15:14:33 <kallisti> even if it is just experimental code
15:14:37 <kallisti> you still need to make sense of it.
15:14:55 <kallisti> mietek: you may be interested in view patterns
15:15:03 <kallisti> I think that's what you mean, anyway
15:15:04 <rasfar> kallisti, in my version of main, there are doit4, and 6-11 inclusive.
15:15:09 <rasfar> others have come and gone.
15:15:18 <kallisti> k
15:15:31 <rasfar> i do use version control in some projects, but i like to see mod times preserved
15:15:39 <rasfar> and various other issues
15:15:44 <kallisti> mietek: f (view -> Pattern x) = ...
15:15:50 <rasfar> but, yeah, i believe in version control in general
15:15:53 <mietek> kallisti: aha, thanks
15:15:55 <kallisti> mietek: the view is a function that gets called on the argument before pattern matching
15:16:49 <rasfar> actually i don't want to seem at all ungrateful by being defensive; i really appreciate the advice and it does make a difference, it does change my practises (as well as helping me fix my bugs).
15:17:21 <hpaste_> Peaker pasted “forever conduit passthrough” at http://hpaste.org/66979
15:17:41 <rasfar> i have lots of bad habits, but some other things that look strange, there is a method to my madness.  anyhow, enough! back into the fray...
15:17:43 <Peaker> kallisti: Passing /dev/null through this identity conduit seems to work
15:18:34 <kallisti> Peaker: I'm not sure that we're even supposed to be doing passthrough stuff
15:18:56 <Peaker> I get "36,272 bytes maximum residency" no matter how many bytes I pass thru
15:19:07 <Peaker> kallisti: I thought that's what you meant by the "forever" thing leaking though?
15:19:12 <kallisti> Peaker: yes, it is.
15:19:21 <kallisti> I was saying besides that. maybe there's a better way
15:19:32 <Peaker> kallisti: pass-thru isn't very useful, indeed, but it is pedagogical about how to compose conduit primitives correctly
15:19:47 <Peaker> (without using the constructors directly, which is very low-level'ish)
15:21:34 <gintasm> hi, I am trying to install cabal-install with ghc 7.4.1 on a MacOSX, and I am running into serious trouble. The Haskell platform only has ghc 7.0.x, so that does not work for me, and if I try to build and install cabal-install myself (using https://gist.github.com/1169332), it requires a lot of massaging of dependency versions in the cabal-install.cabal file, and even then fails with a compilation error in Tar.hs. What are my
15:21:35 <gintasm> options?
15:22:01 <elliott> gintasm: use the darcs cabal-install
15:22:09 <elliott> gintasm: btw, you will have many similar problems with ghc 7.4.1
15:22:14 <elliott> if you aren't adventurous, best to downgrade
15:22:17 <luite_> not the HEAD version though, since it doesn't work
15:22:26 <elliott> anyway, darcs get --lazy http://darcs.haskell.org/cabal-branches/cabal-1.14/
15:22:31 <gintasm> I see.
15:22:33 <elliott> luite_: yeah but there is a branch specifically for ghc 7.4's version of cabal.
15:22:47 <lispy> for 7.4.1 I just had to rebuild cabal-install. I didn't actually need the newer Cabal or cabal-install.
15:22:53 <luite_> I hope a version will be released soon
15:23:03 <gintasm> I'm not adventurous at all, but I would like to get EclipseFP to run properly.
15:23:18 <luite_> elliott: I think they're planning to change to policy to release a cabal-install shortly after a ghc, even if it's an experimental one
15:23:21 <elliott> lispy: the newer cabal-install is nice, though. modular solver etc.
15:23:26 <elliott> luite_: thank god.
15:23:31 <Peaker> It's a bit annoying, so far, that it seems that conduit pipelines generally need their own IO thread. This means passing generalized-monad actions as args isn't that useful, because you can't use convert these args to IO actions in these threads
15:23:52 <lispy> elliott: what does the modular solver gain me?
15:24:01 <lispy> (eg., what am I missing out on?)
15:24:08 <Peaker> i.e: if I forkIO some conduit pipeline execution, I'm forcing the "m" of the Conduit in that thread to be a concrete monad, otherwise I have no way to make an IO computation out of it (after the ($$))
15:24:13 <elliott> lispy: it makes the dependency solver much less stupid
15:24:19 <elliott> so cabal package breakage gets much rarer
15:24:27 <elliott> and it stops doing things like randomly reinstalling things for no reason
15:24:28 <lispy> ah, I already use cabal-dev
15:24:37 <elliott> lispy: right, but you can still have local problems
15:24:41 <elliott> if you have a ton of dependencies
15:24:45 <gintasm> Judging from http://jpmoresmau.blogspot.de/2012/03/eclipsefp-223-released.html, it looks like EclipseFP works well only on 7.4.1. Oh well. Thanks for the heads up.
15:24:56 <elliott> gintasm: well, it's not *that* bad
15:25:05 <elliott> gintasm: but some packages still don't work OOTB
15:25:16 <lispy> 7.4.1 is getting easier to use everyday as people upload things to hackage fixing breakages
15:25:21 <Peaker> I don't think EclipseFP works very well.. multiple eclipse users I know have tried it and given up when it was really brittle and the completions blocked the whole IDE for long whiles
15:25:55 <monochrom> you can use ghc 7.0 to build cabal-install, then use it with ghc 7.4.1. it's just a standalone executable
15:25:58 <elliott> lispy: IMO it should be explicitly acceptable to make a non-maintainer upload for trivial new-GHC fixes, like when it's just updating a dependency or adding an import
15:26:09 <lispy> eclipse makes sense for java, but with Haskell I use hoogle/hayoo, ack, vim, and cabal-dev and I don't feel like I'm missing anything. YMMV.
15:26:18 <rasfar> kallisti: yeah, you're absolutely right, if I give a constraint on pretty much any literal when setting up the Config, there are no errors.  Thanks for the support, I was just freaked out and needed some reassurance.  Cheers.
15:26:28 <qnikst> how to use parsec-3.1, I've created lexer with makeTokenParser haskellDef, and now don't know how to use it on expr
15:26:45 * lispy is meaning to try ghc-mod too
15:26:59 <Peaker> elliott: or fixing unqualified open imports (damn those)
15:27:06 <lispy> ?hoogle runParser
15:27:06 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
15:27:06 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
15:27:06 <lambdabot> Text.Parsec.Prim runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
15:27:16 <luite_> lispy: I think a lot could be improved, like getting the type of the thing pointed at, completion that really knows what things are in scope and what fits, documentation as popups or similar directly in the editor
15:27:23 <Peaker> lispy: I feel like I miss a Haskell IDE so much.. I use emacs.
15:27:26 <lispy> qnikst: I think you call one of thes runParser functions now
15:27:37 <rasfar> ah, and thanks to you too lispy, for your good advice cheerfully offered.
15:27:49 <elliott> Peaker: how often are those actually a problem in practice? just curious, I've never seen any troubles with them
15:28:00 <Peaker> Haskell makes an IDE much more useful than a language like Java, because you can do so much more with the static information
15:28:01 <luite_> eclipsefp is at least trying to offer those, but it's lots of work
15:28:12 <qnikst> lispy: seems Text.ParserCombinators.Parsec.Prim runParser will suite for me, thanks
15:28:16 * elliott wants luite_'s ide thing
15:28:38 <lispy> Peaker: what do you think of yi?
15:28:41 <luite_> elliott: it's not much of an ide yet, but I'll get back to it in the near future
15:28:43 <Peaker> elliott: Yeah. I had a long breakage with the "bitmap" package that I very-indirectly depend on, and the maintainer refused to take a trivial patch for quite a while.  It used "unsafePerformIO" from two open unqualified imports.  Then one became a deprecation wrapper, so it became ambiguous
15:28:54 <luite_> elliott: got sidetracked by some yesod stuff
15:29:03 <lispy> rasfar: yw
15:29:13 <elliott> luite_: hehe, no pressure :P
15:29:24 <Peaker> lispy: I tried it a while ago and it seemed to be too incomplete and non-reflective. I don't have a very informed opinion about it.
15:29:37 <elliott> Peaker: hmm, why did they reject the patch, if the code wouldn't compile?
15:29:41 <Peaker> lispy: I was missing something like describe-function from emacs/etc
15:29:57 <Peaker> elliott: because he said "Soon I intend to release a major new version.. wait till then"
15:30:08 <blackdog> Peaker: i think i still have haskell-src-meta-mwotton floating around hackage - was under time pressure and couldn't wait. The ruby model is much nicer - just refer to a git repo in the (equivalent of) the cabal file.
15:30:09 <lispy> You know, I probably just don't think of editing in terms of editor operations.
15:30:11 <Peaker> elliott: and nobody could "cabal install" in my package because of that :-(
15:30:12 <luite_> elliott: nah I'm quite unhappy myself that I haven't made any progress on it int the last week, partly due to some mysterious GHC problems
15:30:31 <Peaker> blackdog: the problem is that the dependency on the broken package was in a dep of a dep of a dep
15:30:35 <Peaker> blackdog: not mine directly
15:30:58 <elliott> blackdog: you could get that marked as deprecated
15:31:08 <blackdog> ah, so you'd have to have cloned all the way up
15:31:53 <blackdog> elliott: yeah, but i'm lazy. it's not an automatic process, i think..?
15:32:02 <lispy> blackdog: In the ruby model can you also so what commit hash you are compatible with?
15:32:03 <luite_> oh blackdog = mwotton?
15:32:07 <Peaker> lispy: I'm (very slowly, recently, intend to speed up soon :-) ) working with yairchu on https://github.com/Peaker/bottle which is a structural editor for a Haskell-like language. Very preliminary work, though
15:32:08 <elliott> blackdog: yeah, i don't think so
15:32:10 <blackdog> luite_: yep
15:32:23 <luite_> blackdog: ah good to know :)
15:32:38 <Peaker> lispy: the idea is that text is used as a presentation layer only, everything in the backend is structural, including the revision control
15:32:45 <blackdog> lispy: yep: http://gembundler.com/git.html
15:32:47 <kallisti> Peaker: uh, my input appears to be the things I'm yielding as output...
15:32:52 * elliott thinks the correct solution is something like "packages specify the names of packages they depend on, and a default location to use to find that package"
15:32:55 <kallisti> once again pretty sure I don't understand conduits. :P
15:32:58 <blackdog> luite_: just merged two nodes in your head? :)
15:32:59 <elliott> but packages that depend on those packages can override where they get dependencies
15:33:00 <Peaker> kallisti: where's the code?
15:33:22 <lispy> elliott: you can effecitvely do that with cabal-dev
15:33:31 <lispy> elliott: as it uses deps out of your sandbox first
15:33:36 <luite_> blackdog: something like that :)
15:33:54 <lispy> So when you need to override a dep's location you just install it into the sandbox first as a separate step.
15:33:54 <elliott> lispy: yeah but it's still based on a centralised hackage :P
15:34:07 <elliott> so people wanting to make derivatives of packages still have basically no option
15:34:11 <elliott> since they can't create another package with the same name
15:34:14 <luite_> it took me like two years to find out who JaffaCake was, so I'm not that fast :p
15:34:18 <lispy> You can list alternative hackages (in priority order) in your cabal settings.
15:34:20 <elliott> so instead you have to manually patch all your dependencies' cabal settings recursively
15:34:35 <elliott> lispy: yeaah but nobody is going to set up an alternative hackage just to host $fork_of_abandoned_package_X_with_bug_fixed
15:35:09 <lispy> Something like the debian system could work though
15:35:26 <lispy> unstable hackage could be for porting to 7.4.1
15:35:42 <lispy> testing hackage could be things that mostly work after being vetted in unstable hackage
15:35:52 <lispy> and stable hackage could work against the HP
15:35:59 <elliott> meh
15:36:00 <elliott> still centralised :P
15:36:07 <glguy> There is a reason that everyone moved off debian
15:36:37 <Peaker> it would be nice if dependencies in cabal were on something other than package implementations. ideally, the actual interface/semantics you depend on. Since that's hard, a "virtual package" could be a proxy/approximation of that notion
15:36:41 <elliott> everybody moved off debian?
15:36:46 <luite_> elliott: one of the problems with releasing a cabal-install shortly after ghc, was that users with an older ghc might get the new, unstable cabal-install
15:36:49 <lispy> glguy: because dons was on archlinux? ;)
15:37:13 <elliott> luite_: meh
15:37:19 <elliott> luite_: i've never had darcs cabal-install do anything funny
15:37:25 <Peaker> so if you depend on "monad-trans-maybe", you could get it from mtl, or from transformers, because both provide this "virtual package"
15:37:34 <rasfar> dons was on OpenBSD I'm fairly sure.
15:37:36 <kallisti> Peaker: pushed to github.
15:37:46 <Peaker> kallisti: link to specific file?
15:37:48 <glguy> rasfar: That time has long since passed
15:37:54 <Peaker> kallisti: I'm lazy, like Haskell :)
15:37:55 <rasfar> oh yeah?
15:37:57 <lispy> rasfar: He was definitely on arch when he lived in Portland
15:38:09 <Peaker> that way, when somebody fails to maintain a package, someone else could upload a different implementation of his "virtual package"
15:38:10 <elliott> once an OpenBSD user...
15:38:14 <rasfar> right then
15:38:22 <kallisti> Peaker: https://github.com/kallisti-dev/irc-conduit/blob/master/Network/IRC/Conduit/Raw.hs
15:38:55 <rasfar> i'd be on Arch now if i could have got the network install to work over wifi...
15:39:33 <kallisti> Peaker: oh ircHost should be "irc.freenode.net"
15:39:35 <rgr> how come repeat doesnt repeat lists? e.g whats wrong with trying repeat 5 (take 10 (cycle [1,2,3]))
15:39:59 <rasfar> you want replicate i think
15:40:08 <monochrom> > repeat [1,2,3]
15:40:08 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
15:40:09 <rasfar> :r repeat
15:40:11 <monochrom> works
15:40:15 <rasfar> :t repeat
15:40:16 <lambdabot> forall a. a -> [a]
15:40:24 <rasfar> :t replicate
15:40:25 <lambdabot> forall a. Int -> a -> [a]
15:40:31 <Peaker> kallisti: I find the arbitrary ($$) placement of conduit so awkward
15:40:45 <Peaker> kallisti: could be much nicer, IMO to fuse the entire pipeline and just execute the result
15:41:03 <rgr> now Im even more confused
15:41:13 <Peaker> unless there's a difference between: a $$ b =$ c     and    a $= b $$ c
15:41:20 <rasfar> rgr: repeat always results in an infinite list
15:41:28 <rasfar> it doesn't take an Int arg
15:41:43 <Peaker> @src replicate
15:41:43 <lambdabot> replicate n x = take n (repeat x)
15:41:43 <rasfar> > repeat ()
15:41:44 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
15:41:45 <rgr> og of course
15:41:48 <rgr> thanks
15:41:50 <rgr> silly me
15:41:56 <rasfar> np
15:42:35 <Peaker> kallisti: why don't you use "sourceIRC" and "sinkIRC" in "runIRCClient"?
15:43:16 <kallisti> Peaker: because runTCPClient does nice things for me.
15:43:27 <kallisti> Peaker: this stuff is basically just added onto network-conduit
15:43:38 <kallisti> so for sourceIRC I use sourceSocket, for runIRCClient I use runTCPClient, etc.
15:44:21 <Peaker> kallisti: ah, I see, didn't see that it differed w.r.t the socket
15:48:38 <Peaker> kallisti: you use Either in IRCMsg, I have no idea what Left/Right supposed to represent. Any chance to make specialized ADTs?
15:49:09 <Peaker> kallisti: don't be so cheap :)  Maybe (Either UserInfo ServerName)   could get its own ADT too
15:49:16 <kallisti> Peaker: nah. should be clear with documentation, and either already had code associated with it.
15:49:19 <kallisti> later I might make my own.
15:49:38 <kallisti> the Either is either a command name or a numeric
15:49:56 <kallisti> I might change that representation though
15:50:29 <kallisti> but typically you want to handle numerics differently from other commands so I think the distinction is useful.
15:50:41 <Peaker> kallisti: what code associated? Like the "either" function? IME/IMO the re-use of such code is not worth the lesser clarity
15:50:58 <Peaker> kallisti: also, why not re-use IRC libs for the parsing/serialization part?
15:51:13 <kallisti> what libs?
15:52:11 <kallisti> Peaker: I'll probably change those representations, yes.
15:53:23 <kallisti> Peaker: also apparently the problem with my code was that I was stopping too early.
15:53:29 <kallisti> if I add printOutput to the end of my bot code it works fine.
15:53:49 <Peaker> kallisti: "cabal list irc" shows a bunch of irc libs
15:54:14 <rasfar>     No instances for (Random (Complex Double),
15:54:14 <rasfar>                       RealFloat (Complex Double))
15:54:23 <Peaker> kallisti: I think your "test" conduit early-terminates before your whole IRC pipeline can do anything
15:54:40 <rasfar> why would that be?  this is actually the last error i was getting before i came online today.
15:55:24 <Peaker> kallisti: I think you have a problem similar to my chatserver's -- where you probably want an independent from-IRC and to-IRC threads
15:55:42 <kallisti> yes. one step at a time though. :P
15:56:25 <kallisti> for an IRC client I'm not sure that threading is needed though
15:56:26 <rasfar> because the Report tells me:   data (RealFloat a) => Complex a = !a :+ !a
15:56:38 <kallisti> but it could be nice to have
15:56:46 <rasfar> surely Double is a RealFloat?
15:57:06 <glguy> rasfar: do you know how to check if it is?
15:57:09 <Peaker> kallisti: I guess it could work without it, but then your conduit between the irc src/sink will be synchronous and not receive input while outputting
15:57:23 <kallisti> Peaker: that's pretty typical for bots at least.
15:57:25 <Peaker> kallisti: and it mustn't early-terminate
15:57:27 <mauke> rasfar: Double is a RealFloat, yes
15:57:54 <rasfar> how can I be missing an instance for RealFloat (Complex Double) ?
15:58:05 <hpc> because Complex isn't real?
15:58:08 <hpc> it's... complex
15:58:21 <rasfar> right. ugh
15:58:35 <hpc> that blasted math getting in the way of working programs
15:58:41 <rasfar> this could be awkward in consequence...
15:58:47 <hayashi> @pl \(x,y) -> x y
15:58:47 <lambdabot> ap fst snd
15:58:48 * kallisti thinks there's no particular reason for the RealFloat constraint to exist on the type parameter of Complex.
15:59:05 <lispy> kallisti: correct
15:59:13 <qnikst> @hoogle Int -> Double
15:59:13 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:59:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:59:13 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
15:59:18 <qnikst> :/
15:59:18 <lispy> kallisti: both mathematically and in terms of haskell
15:59:34 <lispy> kallisti: complex integers are a thing too
15:59:39 <kallisti> yes
15:59:40 <rasfar> I still think if I have Random a constraint, I shouldn't need an instance for Random (Complex a)
15:59:43 <lispy> And data type constraints are just broken
16:00:01 <glguy> That constraint doesn't exist in the latest base library (the only one I checked)
16:00:35 <rgr> org-mode users using ob-haskell, whats the story with illegal bangPatterns?
16:00:59 <rasfar> should i seriously write my own Random instance for Random a => Random (Complex a) ?
16:01:36 <hpc> rasfar: shouldn't be hard
16:01:41 <any-key> I'm trying to convert a two byte ByteString into an integer...is there a good way to go about doing this?
16:01:50 <hpc> (will be annoying i bet though)
16:02:08 <Peaker> kallisti: I think I may have found an interesting real-world use for conduits
16:02:10 <any-key> sorry for all of the ByteString questions, this has all thrown me for a loopo
16:02:19 <rasfar> i'm wondering why it's necessary; i'm just very edgy about the type relationships in my code at the moment. :)
16:02:23 <glguy> How are you going to implement the Random class methods that take a range?
16:02:24 <Peaker> "cabal update" is super slow because it serially does download, then decompression, then extraction
16:02:39 <Peaker> I think I can use conduits to easily stream/concurrentize the first two and speed it up almost by 2
16:02:40 <rasfar> glguy, good point
16:02:47 <blackdog> any-key: hey, are you the any-key i was talking to in the tamu chat?
16:02:56 <rasfar> i suppose ((,),(,))
16:02:57 <any-key> blackdog: yup :)
16:03:12 <blackdog> i see i sold you on haskell at least a little way, then :)
16:03:48 <any-key> heh I like writing haskell most of the time, this project with the ByteString stuff has been driving me insane though :(
16:04:12 <any-key> I'm used to the C way of doing things with binary data :\
16:04:29 <rasfar> er, no, (Complex,Complex) but there's a choice to be made i guess.
16:05:04 <rasfar> which explains why i should need to write an instance...
16:05:23 <glguy> rasfar: You probably shouldn't write an instance because it doesn't make sense to
16:05:26 <qnikst> Peaker: take a look at https://github.com/qnikst/chat-server it rather straightforward but uses old-style conduit now it can be written even better
16:05:29 <glguy> Just write a function that give you the behavior you wanted
16:05:32 <rasfar> wow does this language ever make a lot of sense
16:06:19 <rasfar> okay, but the thing is, the compiler is demanding it be an instance, so i'll have some changes to make.  hope there's not more than a dozen sites...
16:06:52 <glguy> The compiler is demanding an instance because you used the wrong function somewhere. YOu'll just have to change that
16:08:15 <rasfar> i think it makes sense, anyway (but other instances are possible).  the simplest would be a random in the unit circle on the origin in the complex plane I think.
16:08:30 <rasfar> s/random/random point/
16:09:02 <tertl6> hello
16:09:15 <rasfar> the wrong function? i have several functions with a "Random a" constraint on a type var.
16:10:02 <rgr> if I have a list of chars e g ["h","e","l","l","o"] how do I cleanly print it (e.g "hello") in the interpreter?
16:10:07 <rasfar> that's why i'm tempted to write the instance; otherwise i'll have to dispatch Complex instantiations to different functions.  Or would that be preferable?
16:10:16 <DrSyzygy> rgr: putStrLn
16:10:16 <shachaf> rgr: That's a list of strings.
16:10:22 <rgr> oh right
16:10:30 <DrSyzygy> rgr: If you have exactly what you wrote, try concat
16:10:31 <rgr> but a string is a list of chars
16:10:35 <glguy> rasfar: it would be a hack to invent an instance that only makes sense in the way you are using random complex numbers in that exact spot
16:10:46 <rgr> some old habots are hard to lose
16:10:49 <rgr> habits
16:10:52 <DrSyzygy> > concat ["a","b","c"]
16:10:53 <lambdabot>   "abc"
16:10:55 <Peaker> qnikst: wrote one too (no kick or channel support, though :)
16:10:59 <rgr> ah right
16:11:01 <glguy> In this case it would be more appropriate to make a function "randomUnitCircleComplex" or something
16:11:12 <Peaker> qnikst: https://github.com/Peaker/conduit-chatserver/blob/master/chatserver.hs
16:11:43 <rasfar> okay, i can agree with the hack bit; it's just that doing a separate function would seem to subvert the polymorphism i'm trying for.
16:11:55 <wli> I've got some kind of package shadowing issue keeping me from cabal installing http-conduit, though I think conduit proper is fine.
16:12:16 <Peaker> qnikst: I am making an effort to avoid any data constructors from conduit. I think that snoyman should have emphasized that style (could allow more forward-compatibility, too)
16:12:19 <qnikst> Peaker: I know, I've give a link just to convinience, I use such a way in one reallive project =)
16:12:42 <qnikst> Peaker: seems reasonable
16:12:55 <rasfar> how do i even dispatch that -- how do I know the program is dealing with a Complex value?
16:13:14 <rasfar> can't branch on a type test can i?
16:13:35 <Peaker> qnikst: you also use Either in there.. could be nice to replace Left/Right with meaningful constructors? :)
16:13:52 <qnikst> Peaker: just curious, why you are not using STM, insted of Mlock
16:13:56 <glguy> rasfar: it sounds like you want "class RasfarsRandomNumbers a where" which provides numbers using whatever arbitrary pattern you are interested in
16:13:59 <Peaker> rasfar: You can, in compile-time, using type-classes. But you very most likely do not want to
16:14:25 <qnikst> Peaker: I've written that server in 30 mins, just to show proof-of-concept :)
16:14:33 <rasfar> glguy, Peaker: are you talking about the same thing, and just expressed opposing views?
16:14:34 <glguy> That why you can decide things like Complex numbers are chosen on a unit circle
16:14:54 <Peaker> qnikst: I use STM too.. I am not sure it matters that much in that case
16:14:56 <rasfar> well yeah, i mean most things can be given a variety of possible instances
16:14:57 <glguy> rasfar: Peaker and I suggested the same thing
16:15:09 <rasfar> that shouldn't deter me or make it a hack, should it?
16:15:25 <glguy> rasfar: since I'm never going to use your code, I'm OK with you making a jack
16:15:26 <rasfar> Peaker said I most likely don't want to.
16:15:27 <glguy> hack*
16:15:46 <Peaker> rasfar: type-classes tend to be over-used/abused by beginners. A good guideline for beginners in Haskell is that if you think you need type-classes, you probably don't :)
16:15:48 <rasfar> i don't really see the hack.
16:16:07 <qnikst> Peaker: as I think STM will lose IO channels but for more complicated things it will win, so if you are using stm its a good idea to use it in most of all communication vars
16:16:07 <rasfar> well i've been using Haskell for ages and this is my first, so i think i'm not in that particular demographic
16:16:09 <Peaker> It's quicksilver's first rule of type-classes "You don't need them"
16:16:19 <rasfar> i needed my first one today
16:16:40 <qnikst> btwm I'll fix Either type ^)
16:16:45 <rasfar> i think it was the proper solution, but i may be mistaken
16:16:48 <Peaker> qnikst: yeah, it's probably a better way to do it. It took me much longer than 30 mins to write mine :( But I was learning conduits along the way...
16:17:37 <rasfar> it would seem my alternative is an ADT, something like Either, with Double on one side and Complex Double on the other.
16:17:43 <Peaker> qnikst: you really hate do notation? :)
16:17:56 <rasfar> which is the opposite approach to what I've been going for, and will mean a lot of changes.
16:18:04 <Peaker> qnikst: I see your "clientEnter" function, and yikes :)
16:18:27 <Peaker> rasfar: why do you need to support multiple types?
16:18:29 <rasfar> how is it a hack to define an instance of Random for Complex, just because there are multiple possible ways to define it?
16:18:33 <qnikst> Peaker: your variant seems more straight forward
16:18:49 <rasfar> because I began supporting Double, but it turns out Complex will probably work better?
16:19:14 <rasfar> Actually I began polymorphic with the expectation that both would be of interest.
16:19:27 <any-key> Is there a good way to convert a two byte ByteString to an integer?
16:19:57 <rasfar> But I'm only really trying Complex now, so it's a bit ugly here at the moment.
16:20:05 <Peaker> rasfar: I've not followed your earlier explanations.. What's the grand context here?
16:20:46 <luite_> any-key: binary or cereal have getWord16xx where there are various xx for endinanness
16:20:55 <rasfar> grand context? i have some algorithms which use a number field.
16:21:08 <any-key> luite_: I'm not allowed to use external libraries like that, it's a school project
16:21:12 <any-key> otherwise those would be perfect
16:21:26 <rasfar> i've explored the reals in some detail, now i'd like to see what happens with complex numbers, that about sums it up.
16:21:26 <Peaker> rasfar: and you want them generalized for multiple types? maybe the existing type-classes around complex/double already work for you?
16:21:55 <rasfar> may...be
16:22:01 <luite_> any-key: in that case you can just [a,b] <- B.toList bs, fromIntegral a + 256 * fromIntegral b
16:22:09 <luite_> uh make that <- an =
16:22:20 <Peaker> kallisti, qnikst: It seems "resourcet" of conduit fame could probably immitate oleg's regions libraries
16:22:30 <rasfar> i wrote a class today because i needed an "init" method which took the signum of a Complex Double, but did identity to a Double.
16:22:53 <any-key> luite_: heh, that makes sense
16:22:55 <any-key> thanks
16:23:25 <rasfar> it just seemed like the right moment to write a class declaration, but as it's my first, my intuition may be wrong
16:23:53 <qnikst> Peaker: interesting idea with withForkIO_
16:23:54 <rasfar> but i don't understand how to dispatch to separate functions based on the type; the typeclass is the only way i could think of.
16:24:06 <rasfar> that's more or less what they're all about, no?
16:24:11 * qnikst never thing of such approach
16:24:14 <qnikst> *thought
16:26:02 <rasfar> glguy: why is it a hack to write that Random instance for Random a => Complex a ?  i'm really curious how to draw the line.  should an instance always be "canonical"?
16:27:07 <rasfar> i can understand why no default instance has been provided, but why would it be bad practise to define one in one's code? (anyone?)
16:29:24 <lispy> rasfar: I missed a lot of the conversation, but wasn't there something to do with not being able to fully satisfy the existin interface?
16:30:07 <lispy> rasfar: I would say, if you just need one method of a type class and you can't implement the rest, then don't export that instances. Others may not know that you couldn't implement it fully and then you have trouble.
16:30:08 <rasfar> well, i didn't look at the Random interface just now, but the example raised was randomR which takes a range.
16:30:36 <rasfar> so there are multiple possible interpretations, but the same can be said for other instances, including some in base no doubt.
16:31:11 <lispy> Yeah, not all of the type classes/instances in base are ideal
16:31:22 <lispy> (Yeah, Num, I'm looking at you)
16:31:27 <Peaker> dcoutts: you here, by any chance?
16:31:31 <rasfar> yes, right -- not being experienced with classes/instances, i didn't even remember that it's possible to give an incomplete instance.
16:31:39 <glguy> rasfar: instances are global, modules will be incompatible if they each make up their own hack instances
16:31:46 <Peaker> qnikst: thanks :) I'm always missing a proper forkIO that cleans up after itself
16:31:50 <rasfar> oh!
16:32:39 <rasfar> glguy: how the heck will i reorganise my code to branch depending on whether a value is of type Double or Complex Double?
16:33:19 <rasfar> you did suggest a new typeclass RasfarsComplex or so?
16:33:49 <rasfar> then you avoid the problem of clashing global-scope instances, since they're in different classes?
16:34:40 <rasfar> that would work I guess.  i can even make it a subclass of Complex, then add the Random instance to the subclass, correct?
16:35:06 <rasfar> i'll take a "yes" or "no" at this point
16:35:12 <Peaker> qnikst: it's funny your function called "server" is mine called "client" :)
16:36:10 <rasfar> okay, well i'll try it because i know of no other way, short of refactoring to use an extra layer of ADT wrapper
16:39:00 <qnikst> )
16:40:39 <elliott> (
16:40:55 <Yarou> hello all, does anyone know of a production-grade neural network library written in haskell? i don't need anything significantly complex, just enough to implement a feedforward network
16:43:11 <hpc> http://hackage.haskell.org/package/HaskellNN -- this perhaps?
16:43:28 <lispy> Yarou: I don't work in that area so I don't know, but I would start looking for one by searching hackage. FWIW
16:44:14 <Yarou> i'll check it out, thx guys
16:45:20 <hpc> all i know about it is that the types don't suck too bad, and it's not a whole lot of modules to read through
16:46:40 <Yarou> well, the system i have in my mind is more complex, but for now i only need to create a proof of concept for my term paper
16:47:06 <HannesP> i have -- like many others, i believe -- problems wrapping the canonical fibs generator around my head. could anybody please provide me with an explanation that makes sense to me? i've tried to summarise my problem here: http://pastebin.com/XHUswmaa
16:47:24 <elliott> mauke: what happened to that paste-copying?
16:47:36 <HannesP> i should add that i'm very new to haskell and quite unadapted to its way of thinking
16:47:56 <mauke> elliott: http://hpaste.org/new - 500 Internal Server Error
16:47:57 <mauke> A web handler threw an exception. Details:
16:48:02 <mauke> Language/Preprocessor/Cpphs/Position.hs:(88,0)-(90,51): Non-exhaustive patterns in function cpp2hask
16:48:26 <elliott> heh
16:48:46 <elliott> HannesP: gimme a minute, let me write a hpaste that might help you
16:48:55 <HannesP> thanks in advance, elliott
16:49:26 <hpc> mauke: wat
16:49:29 <hpc> it works fine here
16:49:39 <mauke> my script disagrees
16:49:41 <hpc> http://hpaste.org/66983
16:49:45 <hpc> just made that
16:49:57 <hpc> edit the script :P
16:50:12 <mauke> hpc: what do I change?
16:50:19 <hpaste_> elliott pasted “fibs” at http://hpaste.org/66984
16:50:22 <elliott> HannesP: ^
16:50:30 <hpc> no clue; i don't have your script
16:50:45 <elliott> HannesP: here, "..." means "we don't know yet", but it doesn't matter if we don't know what the ... is yet, because we never look that far until we spit out a new element
16:51:02 <elliott> so, basically, as the zipWith produces more elements of the list, it gets more elements to consume itself
16:51:08 <elliott> and discards earlier elements
16:51:30 <mauke> argh, new language list again
16:51:41 <elliott> HannesP: take a look at the answer to this question, too, about the same code snippet: http://stackoverflow.com/questions/9864137/using-symbol-before-it-is-definied
16:51:43 <HannesP> haha i'll need a minute or two do stomach this... hmm
16:51:59 <elliott> HannesP: and this one too http://stackoverflow.com/questions/6186664/corecursion-and-codata
16:52:04 <hpc> mauke: are you using LWP?
16:52:13 <HannesP> i realise i should've googled...
16:52:13 * hpc assumes this is an irssi script
16:52:19 <mauke> hpc: yes
16:52:22 <elliott> HannesP: nah, it's fine :)
16:52:33 <hpc> odd; it shouldn't be panicing over just a different list
16:52:56 <elliott> HannesP: actually, ignore my hpaste; Daniel Fischer's answer to the first question I linked is a much better version of the same
16:52:59 <mauke> especially because my list only contains haskell and ruby
16:53:45 <mauke> hahahaha, there's a </html> tag in the middle of the page
16:53:56 <mauke> "good" job
16:54:21 <elliott> @tell chrisdone bad! bad chrisdone!
16:54:21 <lambdabot> Consider it noted.
16:54:57 <hpc> mauke: huh? i don't see it
16:55:05 <HannesP> elliott: i think i get it now, after staring at the three explanations for a while. massive thanks for your help and helpfulness
16:55:30 <elliott> HannesP: it's a pretty tricky example if you haven't come to terms with non-strict evaluation yet :)
16:55:37 <HannesP> this still feels a bit like magic to me, though :)
16:55:44 <elliott> yeah, it does
16:55:46 <mauke> hpc: oh, someone misspelled <head> as <html>
16:55:55 <elliott> HannesP: after a while it'll seem less confusing :)
16:55:58 <hpc> oh lol
16:56:00 <hpc> now i see it
16:56:14 <elliott> HannesP: you might also enjoy http://r6.ca/blog/20081116T213644Z.html... or it might make you as confused as you were to start with :)
16:56:15 <HannesP> i've been programming for many years but i've never encountered something like this... which is the reason to why i decided to look into haskell
16:56:38 <HannesP> hahaha
16:56:46 <elliott> (N.B. that's not actually a good algorithm for generating/checking primes, but it sure is elegant)
16:57:12 <hpc> @tell chrisdone http://hpaste.org/66985 -- where did you learn to type!
16:57:12 <lambdabot> Consider it noted.
16:57:34 <mauke> there's also an unbalanced </p> before </form>
16:58:15 <elliott> @tell chrisdone <mauke> there's also an unbalanced </p> before </form>
16:58:15 <lambdabot> Consider it noted.
16:58:17 <elliott> that poor guy
16:58:25 <elliott> joins, lambdabot: you have 10 new messages!
16:58:32 <elliott> "ooh, what could it b-" "YOUR HTML IS BROKEN AND YOU'RE TERRIBLE"
16:59:01 <hpc> @tell chrisdone it's okay, we still love you
16:59:02 <lambdabot> Consider it noted.
16:59:07 <elliott> @tell chrisdone I don't
16:59:07 <lambdabot> Consider it noted.
16:59:10 <hpc> lol
16:59:30 <kallisti> @tell chrisdone chrisdone is the latest Haskell trend.
16:59:31 <lambdabot> Consider it noted.
16:59:36 <kallisti> inform reddit.
17:00:28 <mauke> @flush
17:00:46 <kallisti> lambdabot is not a toilet.
17:00:57 <elliott> there go the messages down the toilet, where they belong
17:00:58 <elliott> dammit
17:01:14 <kallisti> haha!
17:01:16 <beepbot> @tell chrisdone beep
17:01:16 <lambdabot> Consider it noted.
17:01:33 <elliott> wat
17:01:48 * elliott tries to find beepbot's nick change
17:02:06 <Cale> HannesP: Basically, the new thing to get used to is that values of any type, even types like Integer or [Integer], can at runtime still be unevaluated expressions (whose physical representation in memory is called a "thunk").
17:04:39 <HannesP> Cale: it seems to be a very useful concept, as soon as i turn it into a tool rather than an obstacle :P
17:05:06 <HannesP> but i think i'm slowly getting it
17:05:21 <Cale> In GHC, all ordinary values are represented as pointers to code which is expected to return (the location of) a data constructor. When that code runs for the first time and computes the value, the pointer is updated to point at code which just returns the already computed value immediately.
17:05:41 <HannesP> ah
17:05:49 <Cale> (Though, this is a slightly lower level than you'd normally ever need to think at)
17:05:59 <hpc> ((it's still awesome))
17:06:12 <HannesP> no, it's good, i like to think of it at implementation level as well
17:06:18 <Cale> Usually I just think about expressions being rewritten
17:06:48 <Cale> Or, if that's not fine enough, directed expression graphs
17:07:21 <Cale> (which you could draw by following those pointers around, sort of)
17:08:13 <HannesP> :)
17:08:27 * lispy waves at Cale
17:08:32 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html -- I wish this language implementation was downloadable
17:09:46 <Cale> (but have a look at the animations to get a sense for what I mean :)
17:10:26 <HannesP> that's very cool :)
17:10:36 <elliott> Cale: those animations are awesome
17:11:04 <HannesP> ohhh i just got a much more profound understanding on my original question by simply writing it down in "maths form" using pencil and paper
17:11:13 <HannesP> now it seems much clearer
17:11:20 <Cale> yeah
17:12:28 <any-key> I feel really dumb for bugging everyone here about the same stupid code but I'm really stuck on this one... http://pastebin.com/PXrgaci1
17:12:29 <Cale> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   is an equation that uniquely defines the Fibonacci sequence, in a way that makes it possible to calculate, because enough elements of the sequence are always determined by the time you need them, more or less.
17:12:30 <mauke> The paste [2;17r[2;1H[1M[17;1H[1L[1;19r[?25l[19;12H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m $VAR1 = [[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;30H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'title',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;39H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m
17:12:37 <mauke>  [1mIrssi:[m[24m[27m[23m           'pastebin.com/PXrgaci1',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;55H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'author',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;40H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m
17:12:42 <hpc> wow, nice
17:12:42 <mauke>  'anykey',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;40H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'language',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;42H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'haskell',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;41H[17;1H15/02:12
17:12:44 <Cale> mauke: FAIL
17:12:48 <mauke>  [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'channel',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;41H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           '',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;34H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m
17:12:54 <mauke>  'email',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;39H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           '',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;34H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m           'paste',[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;39H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m
17:12:57 <hpc> gadzooks
17:12:59 <monochrom> yikes, mauke, you have a software bug
17:12:59 <hpc> @where ops
17:12:59 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:13:00 <mauke>  [1mIrssi:[m[24m[27m[23m           'import qualified Data.ByteString as BS[7mM[m[24m[27m[23m[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;71H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m import Data.Bits[7mM[m[24m[27m[23m[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;38H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m import
17:13:01 <any-key> what the hell happened :|
17:13:06 <mauke>  Data.Word[7mM[m[24m[27m[23m[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;38H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m [7mM[m[24m[27m[23m[K[2;17r[2;1H[1M[17;1H[1L[1;19r[17;22H[17;1H15/02:12 [38;5;12m-[38;5;15m![38;5;12m-[m[24m[27m[23m [1mIrssi:[m[24m[27m[23m checkMagicNumber :: BS.ByteString -> (Bool,
17:13:07 --- mode: ChanServ set +o Cale
17:13:10 <hpc> @ops
17:13:10 --- kick: mauke was kicked by Cale (mauke)
17:13:10 <lambdabot> Maybe you meant: docs oeis pl
17:13:17 --- mode: Cale set -o Cale
17:13:28 <any-key> sorry about that
17:13:29 <Cale> It was his paste copier script gone haywire
17:13:34 <Cale> Not your fault
17:13:42 <elliott> haha wow
17:14:18 <elliott> that's what pastebin.com does to innocent #haskellers, folks
17:14:30 <any-key> the whole IO ByteString versus ByteString thing has been driving me insane
17:14:33 <lispy> pastebin.com not even once
17:14:34 <Cale> any-key: checkMagicNumber is not an IO action, so you can't run it with <- in that do block
17:14:45 <any-key> Cale: ah, okay
17:14:49 <Cale> any-key: you probably just want  let (valid, rest0) = checkMagicNumber bytes
17:15:00 <any-key> Thanks, I'll try that
17:15:26 <any-key> Cale: heh, it works
17:15:28 <any-key> wow
17:15:30 <any-key> it works
17:15:32 <elliott> hi mauke!
17:15:35 <mauke> hi
17:15:49 <any-key> hello mauke
17:15:50 <Cale> mauke: I'm assuming you saw what happened there?
17:15:58 <mauke> yes
17:16:19 <mauke> I'm going to stand in the corner and think about what I've done
17:16:21 <hpc> looks like a missing quote
17:16:46 <mauke> I think I've crossed the streams
17:16:49 <HannesP> Cale, elliott: once i realised that "tail" applied to an infinite series is simply a shifting operation, it all got much clearer: http://pastebin.com/RTEpM8BD
17:16:53 <any-key> should I paste that URL again? :)
17:17:12 <mauke> my script is (or should be) currently unloaded
17:17:19 <any-key> http://pastebin.com/PXrgaci1
17:17:27 <any-key> worth a shot
17:17:40 <elliott> HannesP: right
17:17:55 <elliott> HannesP: (except that, here, the +s between elements are actually :s)
17:18:01 <Cale> HannesP: right :)
17:18:06 <monochrom> "crossed the streams" may end up being a pretty accurate description :)
17:18:10 <HannesP> what does :s denote?
17:18:13 <elliott> > 1 : [2,3,4]
17:18:14 <lambdabot>   [1,2,3,4]
17:18:19 <Cale> HannesP: as in conses?
17:18:21 <HannesP> more than a puzzled face, rotated 90°
17:18:25 <elliott> (:) :: a -> [a] -> [a]
17:18:27 <elliott> prepends a value to a list
17:18:32 <elliott> so "fibs" is actually the list of all fibonacci numbers
17:18:34 <mauke> monochrom: yes, stdout/stderr
17:18:35 <HannesP> ahh
17:18:48 <HannesP> yeah
17:18:48 <elliott> the magic is that haskell can evaluate all this despite not knowing the full values of the arguments to zipWith, since it only looks as far as it needs to generate each element
17:19:07 <Cale> and moreover, it doesn't have to do O(n) seeking down the list :)
17:19:21 <Cale> (to recover the elements it needs to add in each case)
17:19:38 <Cale> because of the way that zipWith walks down both lists simultaneously
17:19:53 <Cale> (there are no list indexing operations involved)
17:20:02 <lispy> memoization is fun!
17:20:03 <HannesP> elliott: oh of course, those +'es were intended to be commas (if maths notation, : if haskell)... i get you now
17:20:11 <elliott> HannesP: right, i guessed
17:20:13 <elliott> :)
17:20:13 <Cale> right
17:20:42 <HannesP> :)
17:20:45 <HannesP> this is getting fun
17:20:56 <elliott> \o/
17:21:08 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
17:21:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:21:15 <mauke> restarted script
17:21:24 <Cale> http://pastebin.com/PXrgaci1
17:21:26 <mauke> The paste PXrgaci1 has been copied to http://hpaste.org/66999
17:21:30 <Cale> hooray
17:22:13 <elliott> \o/
17:22:20 <elliott> hmm, did it used to say "PXrgaci1"?
17:22:25 <elliott> I thought it used to put the URL there
17:22:34 <mauke> @tell chrisdone hpasting "#3" as Haskell source causes Language/Preprocessor/Cpphs/Position.hs:(88,0)-(90,51): Non-exhaustive patterns in function cpp2hask
17:22:35 <lambdabot> Consider it noted.
17:22:45 <mauke> it wasn't even my bug
17:23:13 <mauke> elliott: that's to prevent bot loops
17:23:46 <Cale> HannesP: ^^ have you ever seen that primes implementation? :)
17:24:19 <Cale> HannesP: A prime number is either 2 or an odd number n which is not divisible by any primes p with p*p <= n
17:24:48 <ero> boop
17:24:48 <HannesP> no, i've only been a haskell user for a couple of hours :)
17:24:57 <elliott> but I just linked HannesP to that implementation! :P
17:25:06 <HannesP> but i'm highly interested as i intend to use haskell for solving project euler problems
17:25:08 <HannesP> oh :D
17:25:11 <HannesP> then i've seen it
17:25:25 <elliott> HannesP: project euler is generally considered a bad beginner's project for haskel
17:25:26 <elliott> *haskell
17:25:33 <HannesP> i just don't... decipher haskell code that quick, yet
17:25:51 <elliott> since the majority of it is numeric code, and you tend to run into some strictness and optimisation issues that are not familiar to the haskell beginner
17:25:59 <HannesP> elliott: thing is, i've solved 60 problems or so using mostly procedural methods (C, python etc)
17:26:03 <Cale> There are much faster implementations of the infinite list of primes, but that one is reasonably quick if you don't need too many of them.
17:26:22 <mauke> my implementation of the list of primes involves wget
17:26:26 <Cale> lol
17:26:34 <mauke> ~HARDCORE~
17:26:38 <HannesP> so i thought they'd provide good exercises, since i'm already familiar with the procedural way to solve them
17:26:48 <Cale> @oeis 2,3,5,7,11
17:26:50 <elliott> HannesP: it's just probably better to get accustomed to haskell before trying project euler with it, because you'll run into specific problems that are easy to solve once you're familiar
17:26:52 <lambdabot>  The prime numbers.
17:26:52 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:26:56 <elliott> but that are likely to be stumbling blocks if you're not
17:27:02 * monochrom invents Meta Project Euler. Meta Project Euler #1: list the Project Euler problems whose solutions are odd numbers
17:27:03 <Cale> > extendSequence [2,3,5,7,11]
17:27:07 <lambdabot>   mueval-core: Time limit exceeded
17:27:10 <Cale> aww
17:27:21 <Cale> OEIS has been slow to respond lately
17:27:21 <HannesP> elliott: okay, thanks for your advice
17:28:53 <HannesP> i learnt a lot just by solving the first two problems, though :)
17:29:00 <dibblego> newtype Compose f g a = Compose (f (g a)) allows me to compose functors e.g. (Functor f, Functor g) => Functor (Compose f g), but where is the data type for binary functors?
17:29:03 <Cale> monochrom: But the solution can't be a *list*! Surely you mean "Calculate the sum of the indices of the Project Euler problems whose solutions are odd numbers"
17:29:18 <HannesP> (a lot for a beginner, that is, not in absolute terms)
17:29:21 <elliott> hehe
17:29:31 <monochrom> I want all those indices, not their sum
17:29:35 <elliott> dibblego: (btw, Compose is in transformers)
17:29:46 <Peaker> It's also in TypeCompose (:.)
17:29:51 <dibblego> elliott: is Bicompose?
17:29:57 <elliott> dibblego: i doubt it
17:30:19 <monochrom> perhaps embed them into some factorial-base number system so one number contains the list
17:30:50 <monochrom> or take the list and MD5 it
17:31:18 <monochrom> yeah, let's go MD5, it is the most frustrating :)
17:31:45 <elliott> monochrom: no no no
17:31:57 <elliott> monochrom: "calculate the string whose MD5 is the sum of the indices of the project euler problems whose solutions are odd numbers"
17:32:13 <elliott> (submitted as the decimal form of its interpretation as a base-256 integer)
17:32:17 <HannesP> i'm quite a fan of the $ syntax already
17:32:30 <monochrom> that is too repelling
17:32:47 <Cale> Little known fact: For any positive integer n, the infinite sequence of Project Euler problems has only finitely many elements whose solution is not divisible by n.
17:33:26 <elliott> @remember Cale Little known fact: For any positive integer n, the infinite sequence of Project Euler problems has only finitely many elements whose solution is not divisible by n.
17:33:26 <lambdabot> I will never forget.
17:33:35 <jmcarthur> dibblego: like this? http://hackage.haskell.org/packages/archive/monad-products/0.2.1/doc/html/Control-Monad-Product.html
17:34:01 <jmcarthur> oh i misunderstood i think'
17:34:07 <dibblego> don't think so
17:34:11 <jmcarthur> i mean type like  f a b?
17:34:36 <dibblego> newtype Compose2 x f g a b = Compose2 (x (f a b) (g a b)) -- something like that I think
17:35:15 <jmcarthur> i see
17:35:20 <jmcarthur> err
17:35:23 <dibblego> not sure if that is quite right actually
17:35:32 <jmcarthur> that doesn't seem similar to Compose
17:35:57 <jmcarthur> i could see doing something like composing a functor with a bifunctor
17:35:59 <dibblego> (Bifunctor f, Bifunctor g) => Bifunctor (X f g)
17:36:30 <Peaker> dibblego: there are so many potentially interesting variants, and relatively little interest in Bifunctors...
17:36:41 <dibblego> there are variants?
17:37:01 <Peaker> dibblego: I mean, different ways of composing Bifunctors
17:37:17 <dibblego> you mean with unary functors?
17:37:46 <Peaker> dibblego: that too, and with other binary functors
17:38:07 <dibblego> well I like bifunctors and I will give them love
17:38:24 <Peaker> dibblego: you seem to be talking about a generalization here, but it's usually useful to explore a bunch of specific examples first.. what examples do you have in mind?
17:38:55 <dibblego> actually I am bitraversing, both Either and (,)
17:39:07 <jmcarthur> newtype Compose2 f g a b = Compose2 (f (g a b) (g a b))
17:39:14 <jmcarthur> err
17:39:31 <jmcarthur> still not the most interesting one to me
17:45:13 <nart> @helo oeis
17:45:13 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
17:52:46 <adu> oeis 1,2,3
17:53:01 <elliott> @oeis 1,2,3
17:53:08 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
17:53:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:53:18 <ion> hah
17:53:27 <shachaf> #haskell and OEIS are clearly meant to be.
17:53:32 <adu> @oeis 1, -1, -4, -21, -160, -1505
17:53:32 <lambdabot>  det(I - M) where M_jk = (j*x)^k/k!
17:53:32 <lambdabot>  [1,1,4,21,160,1505,17136,226093,3334528,53031105,864640000,12957006821,10732...
17:53:40 <adu> :)
17:53:53 <HannesP> what does @oeis do? identifies a sequence from a sample?
17:54:02 <hpc> yes
17:54:09 <hpc> http://oeis.org/
17:54:11 <HannesP> haha wicked
17:54:18 <Twey> It just submits it to the OEIS & sees what it gets back
17:54:20 <adu> @oeis A157503
17:54:20 <lambdabot>  det(I - M) where M_jk = (j*x)^k/k!
17:54:20 <lambdabot>  [1,1,4,21,160,1505,17136,226093,3334528,53031105,864640000,12957006821,10732...
17:54:21 <hpc> it's just a bit of HTTP POST stuff
17:54:27 <adu> or identifier
17:54:35 <theorbtwo> @oeis 1 2 4 8
17:54:41 <lambdabot>  Powers of 2: a(n) = 2^n.
17:54:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
17:54:56 <ion> @oeis 89,-55,34,-21,13
17:54:56 <lambdabot>  Triangle read by rows: row n contains first n nonzero Fibonacci numbers in d...
17:54:56 <lambdabot>  [1,1,1,2,1,1,3,2,1,1,5,3,2,1,1,8,5,3,2,1,1,13,8,5,3,2,1,1,21,13,8,5,3,2,1,1,...
17:55:03 <HannesP> @ 2 4 12 48
17:55:13 <nimred> can someone help?
17:55:14 <nimred> http://sprunge.us/fYDJ
17:55:17 <HannesP> @oeis 2 4 12 48
17:55:18 <lambdabot>  a(0) = 0; a(n+1) = 2*n! (n >= 0).
17:55:18 <lambdabot>  [0,2,4,12,48,240,1440,10080,80640,725760,7257600,79833600,958003200,12454041...
17:55:25 <HannesP> fantastic
17:55:28 <nimred> http://sprunge.us/Zjbf?haskell
17:56:29 <adu> @oeis A004231
17:56:30 <lambdabot>  Ackermann numbers: n^n^n^...^n (with n n's).
17:56:30 <lambdabot>  [1,4,7625597484987]
17:58:05 <hpc> lol
17:58:14 <hpc> think they'll ever get a 4th number?
17:58:23 <ion> heh
17:58:27 <hpc> or is it proven larger than the universe?
17:59:12 <adu> hpc: yes, but it's 8.0723E153 digits long
17:59:18 <elliott> The fourth Ackermann number is pretty big: http://en.wikipedia.org/wiki/Ackermann_function#Ackermann_numbers
18:00:47 <HannesP> O_O
18:00:49 <TSC2> The wikipedia page is wrong?
18:01:04 <TSC2> It has 16 as second Ackermann number
18:01:29 <adu> TSC2: no Ackermann numbers is like "natural number" it means different things to different authors
18:01:58 <adu> some people say n refers to number of arrows, some say n referes to the number of n's
18:02:14 <TSC2> Ah, but OEIS and wikipedia do coincide for the third number
18:02:25 <TSC2> Just a coincidence?
18:02:43 <TSC2> Oh, no they don't
18:02:44 <HannesP> the one on wikipedia has 3↑↑ in it
18:02:44 <TSC2> I can't read
18:02:45 <adu> TSC2 no, the third number on wikipedia is 3^^7625597484987 on OEIS it's just 7625597484987
18:02:55 <adu> indeed
18:02:59 <elliott> oh, didn't realise they differed there
18:03:26 <tromp> goodstein's sequence grows much faster
18:04:39 <adu> OEIS A004231 is just n^^n Wikipedia Ackermann numbers is n^(with n arrows)...^n
18:05:00 <adu> tromp: which is probably why they weren't added to OEIS
18:05:19 <tromp> it is in OEIS of course
18:06:04 <adu> tromp: nope
18:06:48 <tromp> oh, you're right; only goodstein-related sequences
18:07:40 <tromp> @let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
18:07:41 <lambdabot>   Float with missing exponent
18:07:59 <lispy> lambdabot doesn't afraid of any haskell
18:08:00 <adu> but actually, Wikipedia is wrong, 2^^2 = 2^2 = 4, not 16
18:08:33 <tromp> @let g b 0=b;g b n=g c$s 0 n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
18:08:34 <lambdabot>   Float with missing exponent
18:08:44 <nemetroid> nimred, it seems to me you have to pass the string to be executed directly to spawnOn
18:08:45 <tromp> @let g b 0=b;g b n=g c$s 0 n-1where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
18:08:46 <lambdabot>  <local>:3:14:
18:08:46 <lambdabot>      Ambiguous occurrence `g'
18:08:46 <lambdabot>      It could refer to either `L...
18:08:48 <HannesP> does #haskell often mutate temporarily into a #numbertheory? :P
18:09:03 <tromp> @let gs b 0=b;gs b n=gs c$s 0 n-1where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
18:09:04 <lambdabot>  Defined.
18:09:13 <tromp> map (g 2) [0..]
18:09:16 <tromp> > map (g 2) [0..]
18:09:17 <lambdabot>   Ambiguous type variable `b' in the constraints:
18:09:17 <lambdabot>    `SimpleReflect.FromExpr ...
18:09:20 <tromp> > map (gs 2) [0..]
18:09:24 <lambdabot>   mueval-core: Time limit exceeded
18:09:50 <tromp> > map (gs 2) [0..2]
18:09:51 <lambdabot>   [2,3,5]
18:09:57 <tromp> > map (gs 2) [0..3]
18:09:58 <lambdabot>   [2,3,5,7]
18:10:10 <lispy> gs for Great Scott!
18:10:12 <byorgey> HannesP: yes, and sometimes #categorytheory
18:10:15 <tromp> gs 2 4 is the tough one:(
18:10:31 <HannesP> byorgey: :)
18:10:42 <tromp> gs 2 4 = 3 * 2^402653211 - 1
18:12:49 <nimred> nemetroid: which way?
18:13:37 <elliott> more often #categorytheory than #numbertheory, no?
18:13:53 <elliott> > gs 2 4
18:13:57 <lambdabot>   mueval-core: Time limit exceeded
18:13:59 <elliott> silly lambdabot
18:14:57 <nemetroid> nimred: like `spawnOn wsTV "VLCPlayer 201"`
18:15:03 <lispy> I wish we turned into #someonefixingcabal more often
18:16:31 <nimred> nemetroid: no doesn't work
18:16:51 <nimred> nemetroid: http://sprunge.us/DQXQ
18:17:03 <nimred> myFR2      = do spawnOn wsTV safeSpawn "VLCPlayer" ["201"]
18:17:59 <nemetroid> nimred: myFR2 = spawnOn wsTV "VLCPlayer 201"
18:21:31 <singpolyma> I'm seeing some weird behaviour with System.Directory.renameFile -- the target is properly replaced, but the source is not gone.  It's *mostly* gone...  this is in a concurrent (but not -threaded) setup
18:22:07 <hashbrowncipher> singpolyma: what do you mean by "mostly"?
18:22:25 <vodik> singpolyma: the file is gone but its hasn't actually been released by the os yet?
18:22:33 <singpolyma> hashbrowncipher: I mean, there is still a file by that name, and the start of the file is the same, but the end is gone
18:22:45 <hashbrowncipher> weird, I thought it was what vodik is talking about
18:22:53 <hashbrowncipher> but it sounds like you have a different issue
18:23:10 <hashbrowncipher> actually, if you try to access the file from a process other than your haskell program
18:23:15 <hashbrowncipher> are you able to?
18:23:23 <vodik> what platform?
18:23:29 <singpolyma> Ubuntu
18:23:48 <singpolyma> I am diffing the file against the target, that's how I know it's partly gone
18:24:52 <vodik> wait, is the original file still on the os?
18:25:03 <vodik> or do you just have an old filedescriptor open from before the rename?
18:25:36 <singpolyma> no, I'm catting/diffing from shell.  there is a file there
18:26:11 <vodik> okay, thats weird
18:27:16 <singpolyma> oh.. hmm, maybe that's not it
18:27:25 <singpolyma> I think I might be creating new temp files when I don't think I am
18:27:30 <singpolyma> which makes more sense
18:27:49 <vodik> heh
18:29:21 <nimred> ok nemetroid. thanks :)
18:29:40 <singpolyma> man, I seriously thought I was going crazy
18:30:15 <tazjin> singpolyma: On *nix Haskell's renameFile is just a call to C's rename, afaik. And I think rename is proven to work correctly, so something involving crazy temp files is more likely :p
18:37:39 <vodik> yup
18:38:43 <singpolyma> ok, I found it :P
19:07:47 * hackagebot ekg 0.3.0.5 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.0.5 (JohanTibell)
19:18:10 <wli> Ugh, I can't get Network.Stream.Result to stack with IO.
19:19:22 <elliott> wli: stack howso?
19:19:43 <wli> Monad stacking, runErrorT etc.
19:19:51 <elliott> well, it's Either, not EitherT
19:20:02 * elliott mumbles something about http-conduit's API being nicer :p
19:20:17 <luite_> Add an ErrorT in front
19:20:31 <wli> elliott: http-conduit falls to package shadowing errors.
19:20:43 <luite_> in that case you should make a cabal project
19:20:49 <wli> luite_: In front of what?
19:21:37 <luite_> wli: e <- ErrorT someIOEitherresult
19:22:22 <elliott> wli: eh?
19:23:45 <hpaste_> wli pasted “attempt to download GTFS” at http://hpaste.org/67003
19:24:43 * elliott wonders what wli means by package shadowing errors
19:25:22 <luite_> probably that http-conduit depends on x that exports module y, while he gets another module x' if he imports y in his source file
19:25:31 <elliott> ah
19:25:35 <wli> command line>: cannot satisfy -package-id text-0.11.1.5-c38e02e7e9ae20e85e18db674dc25026:
19:25:35 <wli>     text-0.11.1.5-c38e02e7e9ae20e85e18db674dc25026 is shadowed by package text-0.11.1.5-06781a638835fee88eff5d48c0d8e125
19:25:35 <wli>     (use -v for more information)
19:26:05 <elliott> that's when you start using cabal-dev :p
19:26:13 <luite_> wli: if you make it a cabal project, cabal will take care of exposing the correct packages for you (and hiding the rest)
19:26:21 <xil> hey everyone. Does reverse take O(n)? What about concatenating a single element to the end of a list? If so, is there a doubly linked list for Haskell?
19:27:05 <dibblego> xil: yes, yes, see DList
19:27:21 <dibblego> @where DList
19:27:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
19:27:42 <xil> dibblego: thank you so much =D
19:27:45 <dibblego> DList a = Endo [a]
19:27:47 <dibblego> np
19:28:13 <djahandarie> I like Sequence more than DList
19:28:16 <luite_> wli: you still need a runErrorT btw
19:28:33 <elliott> Seq and DList aren't really comparable, are they?
19:28:44 <luite_> wli: probably before the first do on line 28
19:28:49 <elliott> xil: note that DList is not really "doubly-linked"
19:28:57 <elliott> xil: in fact, DList is more a means for constructing lists than a proper structure
19:29:05 <elliott> you have to force the whole thing, producing a normal list, to examine it
19:29:11 <elliott> and you can't really modify it without doing that
19:29:17 <djahandarie> elliott, they both have O(1) snoc.
19:29:21 <wli> luite_: Put one there, still gettimg a mismatch
19:31:51 <xil> it might coincidentally be exactly what I need though. The only thing that would be nice to know is what the "list" function does for DList. The docs aren't clear
19:32:22 <elliott> that's a weird function
19:33:09 <xil> the limited docs almost make it sound like it could remove from one DList all of the elements in another
19:33:28 <dibblego> yes, DList is not what you might call a "typical double-linked list" -- it has some differences
19:33:47 * elliott wishes DList was generalised to any monoid
19:33:58 <elliott> in fact, all you'd need is (Monoid a) => Monoid (Endo a) etc.
19:33:59 <dibblego> elliott: as in m [a]
19:34:04 <dibblego> right
19:34:10 <elliott> dibblego: no, as in (a -> a) for monoid a
19:34:13 <elliott> of which [b] fits
19:35:09 <elliott> ...I also wish Endo was parameterised on the category, but I can't think of a good application of that to DList stuff ;)
19:35:11 <dibblego> isn't that Dual?
19:35:20 <elliott> dibblego: hm?
19:35:32 <elliott> Endo a is a -> a
19:35:41 <dibblego> maybe I am thinking of the wrong language/library, but I think Dual is what you just wrote
19:35:49 <dibblego> yes Dual a is a -> a too iirc
19:35:57 <dibblego> but with that different monoid instance
19:36:02 <elliott> -- | The dual of a monoid, obtained by swapping the arguments of 'mappend'.
19:36:02 <elliott> newtype Dual a = Dual { getDual :: a }
19:36:02 <elliott>         deriving (Eq, Ord, Read, Show, Bounded)
19:36:05 <elliott> nope
19:36:13 <elliott> Dual (Endo a) would be (a -> a) with a different Monoid instance
19:36:17 <dibblego> oh sorry
19:36:22 <elliott> Endo a's monoid instance is composition
19:36:23 <dibblego> yes I take it all back
19:36:28 * dibblego back to scala
19:36:32 <elliott> which provides appending of DLists
19:36:40 <elliott> dibblego: hehe
19:36:52 <dibblego> fwiw, DList in Scala requires some "jumping around" (c.f. Trampolining in the free monad)
19:37:02 <dibblego> so my head jumped around too in sympathy!
19:37:18 * elliott [generic scala snark]
19:38:10 <wli> It was throwError
19:38:23 <wli> throwError . ErrorMisc was needed.
19:40:09 <wli> throwError . strMsg really
19:41:28 <hpaste_> wli annotated “attempt to download GTFS” with “attempt to download GTFS (annotation)” at http://hpaste.org/67003#a67004
19:45:18 <mk> what's the right way to deal with degeneracy in types? For example, if I have a 2d point, and add a radius to it, this is a circle...
19:46:07 <mk> but if the radius is 0, should the circle count as a point?
19:46:32 <parcs`> no
19:46:44 <parcs`> yes
19:46:54 <elliott> maybe
19:47:57 * glguy wonders what "count as" means
19:48:06 <mk> glguy: yeah, me too.
19:48:35 <mk> there are other cases. A cursor, for example, is a degenerate selection (a highlight)
19:49:16 <mk> (where the start and end cursor positions are the same)
19:49:35 <mk> what's the right way to handle cases like this?
19:49:42 <glguy> No, I meant that it isn't clear what you are asking for
19:49:50 <mk> ^
19:50:15 * elliott wonders what "handle" means
19:50:31 <parcs`> mk: define points in terms of 0-radius circles
19:51:50 <mk> parcs`: I think you just have
19:53:02 <mk> should I put, for example, both points and circles into the "circle" typeclass?
19:53:23 <elliott> you shouldn't use typeclasses at all
19:54:25 <mk> elliott: why not? I was suspecting that points would return a radius of 0 (and area), for example, though this seems strange
19:54:26 <luite_> wli: do you have a working version now?
19:54:27 <wli> Okay, now I've got to convert a String to a ByteString or something.
19:54:28 <glguy> You should put whatever types in the type class that make sense for the operations and rules you've chosen
19:54:41 <shachaf> wli: "pack"
19:54:43 <wli> luite_: To the extent I had anything written.
19:54:48 <shachaf> @hoogle String -> ByteString
19:54:48 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
19:54:48 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
19:54:49 <lambdabot> Data.String fromString :: IsString a => String -> a
19:55:25 <mk> glguy: right - I suspect as much, but how do I know when I'm about to do something stupid, like making my points have an area?
19:55:29 <elliott> mk: because typeclasses have a very specific use - ad-hoc polymorphism
19:55:34 <elliott> you don't need typeclasses for generality or abstraction
19:55:48 <elliott> (and this is a very, very, very, very common mistake beginners make with haskell - using typeclasses for many things they're not useful for)
19:55:59 <hpaste_> luite annotated “attempt to download GTFS” with “attempt to download GTFS (annotation) (annotation)” at http://hpaste.org/67003#a67006
19:56:02 <elliott> cf. e.g. http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
19:56:28 <mk> elliott: could you explain? I was thinking to use them because I have two types, and the two types can behave like circles do
19:56:50 <luite_> wli: see annotation, that one typechecks, only problem is that it's a String result, that's due to getRequest forcing it to be String, I don't know HTTP well envough to make ByteString reqs
19:57:03 <shachaf> wli: By the way, you shouldn't actually use "pack".
19:57:20 <elliott> mk: the "existential typeclass antipattern" link might help there.
19:57:21 <shachaf> wli: You should encode the String. A String is a sequence of characters, a ByteString is a sequence of bytes.
19:57:38 <elliott> mk: if you have ellipse and circle types, then what you want is a function Circle -> Ellipse
19:57:42 <luite_> wli: no pack should be necessary if you find a good alternative for getRequest
19:57:51 <elliott> to express the weakening of the more tight constraint of a Circle to the common interface
19:59:18 <mk> elliott: I see. So this would need a Point->Circle function, and it is wrong to treat circles of radius 0 as equal to a point?
19:59:29 <mk> elliott: thanks for the links
19:59:43 <elliott> mk: Well, circles of radius 0 are points. But that isn't really relevant.
19:59:59 <mk> why not? Shouldn't the type system track that?
19:59:59 <elliott> mk: But why do you have separate Point, Ellipse and Circle types?
20:00:05 <elliott> No, it shouldn't. There's no reason for it to.
20:00:20 <hpaste_> luite annotated “attempt to download GTFS” with “attempt to download GTFS (annotation) (annotation) (annotation)” at http://hpaste.org/67003#a67007
20:01:56 <mk> elliott: because I want to either distinguish between degenerate and non-degenerate things, or expand "degenerate" things into something that is (sometimes) more complex
20:02:19 <hpaste_> wli annotated “attempt to download GTFS” with “attempt to download GTFS (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/67003#a67008
20:02:47 <wli> That complains a bit about Data.ByteString.Lazy.pack vs. Codec.Archive.zip.toArchive
20:04:17 <luite_> wli: oh guess you have more code than i have, could be that it should be a lazy ByteString, change the ByteString import by adding .Lazy
20:06:34 <wli> fromJust?
20:06:45 <luite_> yeah yeha, I'm sorry :p
20:06:55 <luite_> I'll annotate with a version without fromJust
20:06:56 <elliott> you should be!
20:07:38 <hpaste_> luite annotated “attempt to download GTFS” with “attempt to download GTFS (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/67003#a67009
20:10:44 <shergill> what do haskellers use for debugging their programs?
20:11:21 <luite_> gdb
20:12:45 <zzing> ghci works for me :-)
20:13:00 <elliott> @quote roconnor pure
20:13:00 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
20:13:00 <lambdabot> isn't pure.
20:13:08 <zzing> Is there any package that would allow me to play a sound at a certain frequency for a certain length of time?
20:14:31 <luite_> zzing: apfelmus has been working on some synth package, i forgot the name, but I guess it should be possible with that :)
20:15:17 <luite_> zzing: http://apfelmus.nfshost.com/blog/2012/03/22-tomato-rubato-raw-audio.html
20:16:54 <zzing> luite_, it is certainly a start, thank you
20:17:55 <zzing> I think I can make good use of that, its testSine actually is exactly what is necessary because I can 'hack' it
20:20:50 <hpaste_> wli annotated “attempt to download GTFS” with “attempt to download GTFS (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/67003#a67010
20:21:39 <wli> Once it got as far as ByteString the rest wasn't so bad.
20:24:10 <wli> zip-archive now insists on having a FilePath
20:24:19 <luite_> that is a String
20:24:27 <wli> Ergh, gtfs now insists on having a FilePath
20:24:55 <wli> luite: No, the zip archives need to be unpacked (not bytestring -related) into some path, and then the gtfs lib pointed at it.
20:25:18 <luite_> yeah I mean that FilePath is a type synonym for String
20:25:53 <wli> That's a bit of a different issue.
20:27:49 * hackagebot hedis-pile 0.5.0 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.5.0 (AlexanderDorofeev)
20:37:46 <luite_> does anyone know where to find an instance Lift ByteString?
20:40:07 <mm_freak> it's funny how the acme-* packages have the most comprehensive documentation
20:40:40 <monochrom> because the joke has to be told through the doc
20:41:10 <mm_freak> i think the joke should be told through names and types
20:41:16 <mm_freak> like in acme-missiles
20:41:20 <glguy> luite_: What about using [| |] brackets to get the Q Exp?
20:41:22 <mm_freak> launchMissiles :: IO ()
20:41:26 <glguy> (I don't know the answer to your question)
20:42:24 <hborders> I'm a haskell newb. I'm just going through the real-world haskell tutorial, and my code fails to compile with "ghc: could not execute: /Developer/usr/bin/gcc"
20:42:37 <hborders> I'm on OSX 10.7.3 with Xcode 4.3
20:42:43 <hborders> I have the command line tools installed
20:42:51 <chioque> hborders: put in this command
20:43:02 <luite_> glguy: yes that requires the Lift instance I was asking for :p
20:43:12 <elliott> luite_: you can just turn it into [Word8] then lift that + wrap it in a "pack"?
20:43:14 <hborders> I installed 64-bit haskell from here: http://hackage.haskell.org/platform/mac.html
20:43:17 <glguy> Prelude Data.ByteString Language.Haskell.TH> :t [| Data.ByteString.empty |]
20:43:17 <glguy> [| Data.ByteString.empty |] :: Q Exp
20:43:18 <elliott> not helpful, I know :)
20:43:29 <elliott> glguy: that is not what Lift instances do
20:43:32 <wli> Now I need unique temporary directories.
20:43:39 <glguy> lift :: t -> Q Exp
20:43:42 <chioque> sudo ln -s /Applications/Xcode.app/Contents/Developer ?developer
20:43:54 <chioque> sudo ln -s /Applications/Xcode.app/Contents/Developer /Developer
20:44:05 <luite_> elliott: that's possible, but doesn't sound terribly efficient for larger files
20:44:17 <elliott> luite_: well, you could generate a ""# instead
20:44:21 <hborders> chioque: are there plans for a better fix? I just hoped there was an option somewhere so I wouldn't have to do that
20:44:22 <elliott> and use ByteString's unsafe Addr-packing functions
20:44:30 <mhy_> hborders: is gcc in ur path?
20:44:45 <hborders> chioque: thanks! :)
20:45:14 <hborders> mhy_: Xcode 4.3 doesn't use /Developer. It puts all developer tools inside Xcode.app/
20:45:15 <chioque> hborders: u can edit the ghc script in /usr/bin
20:45:40 <hborders> chioque: yeah, I found that, too. I just hoped there was an official fix that would work out of the box
20:45:40 <luite_> you can also symlink /Developer/usr to /usr
20:46:05 <johannes__> hi
20:46:14 <wli> withTemporaryDirectory
20:46:48 <hborders> chioque: your symlink fixed my problem. I guess I'll just whine about it more vigorously when I'm a more experienced haskellite
20:46:55 * chioque is also a Haskell newb, only been learning it a week or so :)
20:47:02 <luite_> elliott: hm let's see
20:48:44 <luite_> elliott: yuck StringPrimL String
20:50:02 <elliott> luite_: :)
20:51:58 <luite_> elliott: oh michael snoyman has tried this before, StringPrimL unsuitable for binary data, so he wrote something that patches the executable afterwards, or something
20:54:03 <elliott> luite_: ew, disgusting :)
20:54:09 <elliott> why unsuitable?
20:54:38 <luite_> because it requires a string, which is chars, not every byte sequence is a valid list of chars
20:55:48 <elliott> luite_: well, that doesn't really matter
20:55:58 <elliott> you can stuff anything into a String, it isn't checked for validity
20:56:09 <elliott> or does GHC parse it somehow after it comes out of TH?
20:57:08 <wli> The error handling in all this is atrocious.
20:58:41 <luite_> elliott: GHC encodes the String to bytes when storing it
20:59:51 <elliott> luite_: ok, so? just only store chars '\0' to '\255' in it
20:59:58 <elliott> that's what ByteString's function expects anyway
21:01:52 <luite_> hmm, maybe that'd work
21:03:43 <elliott> well, that's what it's meant for
21:03:54 <elliott> you can just use Data.ByteString.Char8's unpack
21:03:56 <elliott> to get the Strign
21:03:57 <elliott> *String
21:04:12 <elliott> then http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Unsafe.html#v:unsafePackAddressLen
21:04:16 <elliott> to turn it into a ByteString on the other side
21:04:36 <elliott> (oh, you'll need an unsafeDupablePerformIO, but that should be OK)
21:05:07 <elliott> luite_: i think this is what bytestring literals end up getting turned into by RULES etc. btw
21:12:15 <luite_> elliott: ah sounds plausible :) I have some code that compiles now, but I'll test it tomorrow, first sleep. tnx for the help
21:12:30 <elliott> luite_: yw :)
21:12:51 * hackagebot acme-missiles 0.3 - Cause serious international side effects.  http://hackage.haskell.org/package/acme-missiles-0.3 (JoeyAdams)
21:13:22 <wli> At some point I can start populating the sqlite3 database with GTFS data.
21:14:15 <wli> Once that's done I have to bridge a few more gaps to get the traveling salesman trip planning problem going.
21:16:00 <wli> I have a feeling there may not actually be that much curiosity as to what I'm up to.
21:16:17 <xil> I'm wondering if I could get some advice. So I'm trying to code Euler's sieve and I came up with this http://hpaste.org/67011 but as you can see I never actually return the DList I'm building up in makeprimes, so this code is useless. Anyone have any ideas for how to fix this?
21:17:41 <mm_freak> what's a good opposite for "concurrent"?
21:18:02 <gzmask> I tried to use hackage to install some games/engines and all I got is errors with dependency hell :(
21:18:04 <elliott> mm_freak: serial?
21:18:07 <elliott> serialised?
21:18:10 <elliott> serialisedificated?
21:18:36 <mm_freak> "serial" or is "sequential" a better word?  something short would be great
21:19:08 <elliott> Both seem fine to me.
21:19:15 <JoeyA> "Serial" seems better.
21:19:15 <elliott> "Serial" seems stronger somehow.
21:19:24 <elliott> But "sequential" seems more obvious out of context.
21:19:35 <elliott> (OTOH, "serial" nearby to "concurrent" is obvious.)
21:19:43 <elliott> (So probably "serial" or "serialised".)
21:21:01 <JoeyA> I should point out that, in SQL (PostgreSQL, at least), transactions aren't completely isolated by default (you can see changes made in other commits).  If you set the transaction isolation level to "serializable", then each commit sees a consistent picture of the database, but there's a chance the transaction will fail with a "serialization failure".
21:21:36 <JoeyA> That is, if you use the serializable isolation level, you have to do an STM-style retry loop yourself.
21:24:16 <JoeyA> I'm just pointing out choice of terminology here.  When a set of transactions are "serialized", that means they're run one at a time (more precisely, you're creating the illusion that they're run one at a time).
21:24:57 <elliott> mm_freak: Actually...
21:25:08 <elliott> mm_freak: Maybe "serial" is the opposite of "parallel", and "sequential" is the opposite of "concurrent".
21:25:22 <JoeyA> elliott: Good point.
21:25:42 <elliott> Yes, I think that's better.
21:30:39 <gzmask> why lots of the haskell projects are outdated and leave to rot?
21:31:43 <elliott> why lots of the C projects are outdated and leave to rot?
21:31:49 <copumpkin> gzmask: because people aren't paid to write them and lose interest, like any other language
21:31:55 <JoeyA> Because not enough people send threatening emails to maintainers of such packages.
21:32:00 <mm_freak> i wouldn't expect the percentage of bitrot to be any worse for haskell than for other languages
21:32:12 <elliott> it might be due to the shiny factor of haskell
21:32:14 <elliott> but w/e w/e
21:32:18 <mm_freak> just check sourceforge
21:32:25 <shachaf> > w/e w/e
21:32:26 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
21:32:26 <lambdabot>                           ...
21:32:31 <shachaf> > (w/e w)/e
21:32:32 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
21:32:32 <lambdabot>                           ...
21:32:35 <shachaf> Phooey.
21:33:20 <mm_freak> > w/f w/e
21:33:21 <lambdabot>   w / f w / e
21:33:48 <shachaf> > w/0
21:33:48 <lambdabot>   w / 0
21:33:52 <shachaf> > w/0 * 0
21:33:52 <lambdabot>   w / 0 * 0
21:34:26 <JoeyA> > so i don't have to use already-defined functions in lambdabot?  interesting
21:34:27 <lambdabot>   <no location info>: parse error on input `in'
21:34:58 <mm_freak> JoeyA: those are already-defined
21:35:05 <mm_freak> :t w
21:35:06 <lambdabot> Expr
21:35:07 <mm_freak> :t f
21:35:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
21:35:21 <JoeyA> > let me put = words in where i want = to
21:35:22 <lambdabot>   <no location info>: parse error on input `where'
21:35:27 <JoeyA> blach
21:35:31 <JoeyA> Ah
21:37:03 <mm_freak> would be quite funny if lambdabot emitted shadowing warnings
21:37:53 <mm_freak> > let f x = x^2 in f 3
21:37:54 <lambdabot>   9
21:37:55 <mm_freak> two shadows
21:46:26 <wli> Okay unixutils is unusable, need to find an alternative temporary directory lib.
21:47:19 <elliott> wli: I believe System.Directory can do that.
21:47:26 <elliott> Erm
21:47:29 <elliott> I mean System.IO
21:47:35 <elliott> Oh, it only does files.
21:50:23 <geekosaur> temporary files/directories are a remarkably nonportable mess
21:50:34 <wli> Crap, it's later than I expected.
21:50:35 <geekosaur> once you bring the notion of security into it, at least
21:52:46 <wli> I give up on route planning for now, maybe longer. My Haskell is preposterously rusty anyway.
21:54:32 <wli> Getting something I can use out of this is not only not near term but flat out unlikely anyway.
21:59:36 <db81> Is it possible to declare an instance with Oxford brackets or I have to use InstanceD?
21:59:51 <Nisani201> hi everyone. i am trying to cabal install wxc on arch linux but i am getting an error <command line>: cannot satisfy -package Cabal-1.14.0:
22:02:10 <JoeyA> Nisani201: What version of ghc?
22:02:41 <Nisani201> 7.4.1-2
22:04:02 <JoeyA> I think it's because the cabal-install (application) package hasn't been updated in over a year, but the Cabal (library) package has been.
22:04:30 <Nisani201> JoeyA: so what do you suggest i do?
22:04:32 <elliott> Nisani201: Your packages sound broken.
22:04:33 <JoeyA> This might be bad advice, but you could fetch Cabal and cabal-install from the darcs repository: darcs get http://darcs.haskell.org/cabal/
22:04:39 <elliott> Don't ever reinstall Cabal!
22:04:51 <elliott> (And you need the 1.14 branch for 7.4, anyway)
22:04:54 <JoeyA> Listen to elliott.  Probably has better advice.
22:05:01 <elliott> Nisani201: Do you have ~/.ghc or ~/.cabal from a previous GHC install?
22:05:04 <elliott> e.g. have you upgraded this GHC?
22:05:12 <Nisani201> erm. i'm not sure
22:05:19 <Nisani201> i think so
22:05:25 <elliott> Right, then they'll have to go.
22:05:34 <elliott> Wipe ~/.ghc and ~/.cabal (but keep ~/.cabal/config around).
22:05:42 <Nisani201> erm. will this mess up xmonad?
22:05:45 <Nisani201> i'm using that right now
22:05:50 <elliott> Not while it's running.
22:05:59 <Nisani201> ok good
22:06:01 <elliott> You'll need to "cabal install xmonad xmonad-contrib" afterwards before next reboot,t hough.
22:06:10 <elliott> Anyway, then if you have cabal-install installed via your package manager, "cabal update", and move the config back in; otherwise it's a bit trickier.
22:06:26 <JoeyA> Or just keep .cabal/bin ...
22:06:39 <elliott> (Specifically, you'll have to darcs get http://darcs.haskell.org/cabal/cabal-branches/cabal-1.14/, cd cabal-install, and sh bootstrap.sh)
22:06:44 <Nisani201> ok so i just removed the folders
22:06:49 <Nisani201> what do i install first
22:06:51 <Nisani201> ?
22:07:01 <elliott> does running "cabal" still work?
22:07:18 <Nisani201> yea
22:08:05 <elliott> Nisani201: Okay, then "cabal update", move your config back in (if any), then "cabal install xmonad xmonad-contrib"; after that you can try installing wxc again.
22:08:15 <elliott> Hopefully your problem was just with stale packages.
22:08:23 <Nisani201> should i remove xmonad from pacman?
22:08:37 <elliott> oh, you have xmonad installed via pacman?
22:08:39 <elliott> you can keep that, then
22:08:40 <Nisani201> yeah.
22:08:43 <Nisani201> ok.
22:08:47 <elliott> no need to cabal install it
22:08:59 <elliott> (unless your config uses xmonad-contrib modules and you don't have that installed via pacman)
22:09:02 <Nisani201> alright, i'm installing wxc
22:11:51 <Nisani201> hmm... got a different error this time
22:12:10 <Nisani201> http://sprunge.us/eKjG
22:12:50 <elliott> sounds like a compatibility error with your version of wx
22:13:15 <Nisani201> oh. i think i might have installed something from the aur
22:13:23 <Nisani201> that could be messing it up
22:22:53 * hackagebot representable-functors 2.2.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.2.1 (EdwardKmett)
22:25:25 <xil> hey everyone. Is there a function for finding the index of the first instance of a substring of a String?
22:27:53 <ForSpareParts> Could anybody take a look at this for me? I'm trying to pull a value out of a Maybe inside a do, and return a different monadic type...
22:27:55 * hackagebot adjunctions 2.2.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.2.1 (EdwardKmett)
22:27:56 <hpaste_> ForSpareParts pasted “Maybe to something else?” at http://hpaste.org/67012
22:27:57 * hackagebot representable-functors 2.2.1.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.2.1.1 (EdwardKmett)
22:30:13 <edwardk> ForSpareParts, why 'do' and return?
22:30:22 <edwardk> the result isn't in a monad
22:30:43 <edwardk> eval (SymExp s) env = case lookup s env of Just x -> x; Nothing -> ErrorVal
22:30:43 <ForSpareParts> Hrm. I swear it made perfect sense at the time...
22:31:09 <ForSpareParts> it's part of a Scheme repl, so at some point I need an error message as a side effect
22:31:11 <edwardk> :t fromMaybe
22:31:12 <lambdabot> forall a. a -> Maybe a -> a
22:31:26 <ForSpareParts> but I could perhaps do that at the level above, if it detects an ErrorVal?
22:31:33 <edwardk> eval (SymExp s) env = fromMaybe ErrorVal $ lookup s env
22:32:17 <ForSpareParts> OK. What does fromMaybe do?
22:32:39 <edwardk> you can change eval :: Exp -> [(String,Val)] -> M Val -- for some monad, which may include your error type, and consider removing ErrVal from Val
22:32:53 * hackagebot adjunctions 2.2.1.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.2.1.1 (EdwardKmett)
22:32:56 <edwardk> fromMaybe _ (Just b) = b; fromMaybe a Nothing = a
22:35:58 <mm_freak> are there any resources on learning how to write a programming language implementation?
22:36:14 <edwardk> mm_freak: depends on the kind of language
22:36:39 <edwardk> there is a short 'kaleidoscope' example for LLVM which gets you through the boring parts of writing a simple imperative language compiler
22:36:40 <mm_freak> edwardk: a complex language like haskell, not like lisp
22:36:56 <ForSpareParts> edwardk: thanks, I think I get it now.
22:36:56 <edwardk> ah, for that, hrmm, there is SPJ's old book
22:37:18 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
22:37:28 <mm_freak> thanks
22:37:28 <edwardk> "Implementing Functional Languages"
22:37:53 * hackagebot representable-tries 2.2.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.2.1 (EdwardKmett)
22:38:04 <db81> how do I represent C t in Template Haskell?
22:38:08 <mm_freak> are there resources about implementing powerful type systems like agda's or coq's?
22:38:29 <tomprince> There is edwinb's paper on idris.
22:38:48 <mm_freak> tomprince: thanks, that should do it
22:38:58 <mm_freak> i just need an entry point =)
22:39:17 <tomprince> Also 'Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus)'
22:39:30 <edwardk> if you want to go more dependent there is some stuff by hongwei xi
22:39:55 <edwardk> but in general the decisions you need to make for dependently typed languages differ considerably from more conventional languages
22:41:58 <mm_freak> edwin points out that idris is a "language with dependent types" as opposed to a "dependently typed language"…  is this actually meaningful?  i mean, what is the difference between idris and agda?
22:42:31 <edwardk> mm_freak: his focus is on a language you can program in, rather than on proving theorems
22:42:44 <sordina> Hi guys. I'm getting some segfaults in ghci. Can anyone help me track down what is going on? I just installed GHC-7.4.1-x86_64.pkg for OS X 10.6.8 and built cabal from source.
22:42:45 <mm_freak> so this has no technical meaning?
22:42:48 <edwardk> its more a matter of emphasis
22:43:04 <edwardk> its more a statement that he reserves the right to let in unsound terms ;)
22:43:13 <mm_freak> hehe ok
22:44:50 <sordina> I don't seem to be getting much feedback besides fish: Job 1, 'ghci hello.hs ' terminated by signal SIGSEGV (Address boundary error)
22:44:59 <sordina> On startup, and it's intermittent.
22:46:41 <edwardk> sordina: #ghc might be more help. i've never seen that probem
22:47:04 <edwardk> and i've built ghc from scratch several times on a mac
22:48:47 <sordina> Thanks edwardk. I've been having rotten luck getting everything running the last 24 hours so it could be anything really.
22:48:51 <sordina> I'll try ghc
22:49:49 <edwardk> @tell zzo38 i pushed a new kan-extensions with the Applicative instance for Density
22:49:49 <lambdabot> Consider it noted.
22:50:41 <shergill> as per simon marlow here http://hackage.haskell.org/trac/ghc/ticket/4862, to get ghc 7.4.1 to work with the gold linker reinstalling the binary should be all that's needed. can anyone confirm if they've gotten 7.4.1 to work on debian (using the debian repository package)?
22:51:03 <Nisani201> hi. i am trying to install wxc and i'm getting this error: http://sprunge.us/FcOW . any ideas?
22:52:54 * hackagebot gitit 0.9.0.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.9.0.1 (JohnMacFarlane)
22:52:56 <edwardk> Nisani201: what version of wxwidgets do you have installed?
22:53:19 <Nisani201> i have 2.8. but it looks like the latest version
22:54:04 <edwardk> i've actually had to install 2.9 to get wxhaskell to work in 64 bit on a mac, so its not the latest version available overall, just perhaps the latest available from your distribution
22:54:22 <Nisani201> actually
22:54:27 <Nisani201> i might be wrong
22:54:45 <Nisani201> yeah nvmd i'm looking at the wrong thing. i'm geting the right package now
22:57:56 * hackagebot kan-extensions 2.3 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.3 (EdwardKmett)
23:09:52 <wo0kie> can someone recommend me an in-depth explanation of currying and partial application?
23:10:02 <wo0kie> I'm trying to wrap my head around it
23:10:06 <wo0kie> and at a high-level it makes sense
23:10:27 <wo0kie> but I'm trying to understand it fully and having a bit of a hard time
23:10:51 <glguy> There isn't a lot to say about it. Do you have specific questions, perhaps?
23:12:53 <wo0kie> hmm
23:13:02 <glguy> :t curry
23:13:03 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:13:47 <glguy> let f (a,b) = a + b in f (10,20)
23:13:52 <wo0kie> map :: (a -> b) -> [a] -> [b]
23:13:53 <glguy> > let f (a,b) = a + b in f (10,20)
23:13:54 <lambdabot>   30
23:14:02 <glguy> > let f a b = a + b in f 10 20
23:14:03 <lambdabot>   30
23:14:05 <wo0kie> map :: (a -> b) -> ([a] -> [b])
23:14:10 <wo0kie> how are those the same?
23:14:24 <glguy> -> is "right associative
23:14:36 <glguy> if you ever see more than one in a row, they group on the right first
23:15:03 <wo0kie> so ([a] -> [b]) gets evaluated first?
23:15:15 <glguy> Do you understand that:     a / b / c   is the same as (a / b) / c  ?
23:15:34 <wo0kie> I think so
23:16:26 <wo0kie> follows order of operations
23:16:36 <wo0kie> if / means divide like I think it does
23:17:18 <glguy> When you define an operator you get to decide if it is left/right/neither associative,
23:17:22 <glguy> -> just happens to be right
23:17:37 <wo0kie> so stuff on the right gets evaluated first?
23:17:45 <glguy> yeah
23:17:47 <wo0kie> a -> b -> c
23:17:49 <wo0kie> ==
23:17:53 <wo0kie> a -> (b -> c)
23:17:53 <wo0kie> ?
23:17:55 <glguy> yeah
23:17:59 <wo0kie> ok cool
23:18:11 <wo0kie> oooohhhh
23:18:13 <wo0kie> wait a minute
23:18:15 <wo0kie> that makes sense
23:18:30 <wo0kie> converting a function that takes 2 arguments into a function that takes a single argument
23:18:56 <glguy> The trick is that functions only ever take one argument
23:19:04 <wo0kie> ahhh
23:19:12 <glguy> argument -> result
23:19:16 <wo0kie> it just appears that they can take more than one
23:19:26 <glguy> well, they can return a function
23:19:36 <glguy> and then you apply the next argument to that function
23:19:45 <wo0kie> hmmmm
23:20:04 <glguy> function application is left associative
23:20:11 <glguy> so:    f a b   is actually   (f a) b
23:20:34 <glguy> f a returns a function and you apply it to b
23:20:44 <wo0kie> hmm
23:20:52 <wo0kie> how can that be if -> is right associative?
23:20:59 <wo0kie> maybe I'm just confusing two things together
23:21:09 <glguy> -> is used in the type of the function
23:21:38 <glguy> f :: A -> (B -> C)
23:21:45 <glguy> so (f a) :: (B -> C)
23:21:52 <glguy> (f a) b :: C
23:21:56 <wo0kie> true
23:22:08 <wo0kie> ahhh
23:22:12 <wo0kie> that makes more sense :)
23:23:02 <dmwit> (There's nothing fundamental about (->) being right-associative and function application being left-associative. It's just more convenient that way because parentheses usually go on the right of an (->) and parentheses usually go on the left of a function application whitespace.)
23:23:32 <wo0kie> hmmm
23:23:46 <wo0kie> I'm trying to come up with a concrete example to illustrate this
23:23:57 <glguy> The whole system would work just fine if you always had to provide the parentheses, it would just be less convenient
23:24:04 <dmwit> right
23:24:04 <wo0kie> (this isn't hw btw, I'm studying for a midterm on monday :))
23:25:22 <shergill> i'm getting a cryptic "/usr/bin/ghc returned ExitFailure 11" error during compilation. any ideas on how to get more information? i already tried with verbosity set to 3
23:26:52 <dmwit> What command do you run? Paste your output somewhere for us to see (with verbosity 0 to begin with, I think).
23:28:19 <wo0kie> I think currying/partial application makes more sense, thanks glguy and dmwit :)
23:30:19 <dmwit> Anyway, usually if you see something like that but not some complaints by GHC itself it means you're installing lots of things with cabal-install, something in the middle failed, and you haven't scrolled up past all the successes in your terminal yet.
23:31:13 <hpaste_> shergill pasted “cabal install (exitfailure 11)” at http://hpaste.org/67014
23:32:14 <shergill> dmwit: that's the output of running cabal install in the app for my blog
23:32:48 <shergill> i'll try and dig through the verbose output and see if i can locate more information
23:33:28 <dmwit> uh
23:33:32 <dmwit> Is that the whole output?
23:34:02 <shergill> with verbosity 0, yes
23:35:08 <dmwit> No, like, "Resolving dependencies..." or "Configuring blog-0.0.4" or anything like that...?
23:35:48 <shergill> i ran 'cabal clean && cabal configure', right before calling cabal install. but that is the entire output of 'cabal -v0 install'
23:36:14 <shergill> the default is verbosity 1, so perhaps that's what you're confused about?
23:36:19 <dmwit> probably =P
23:40:13 <shergill> yay non-deterministic compilation. now it succeeds =/
23:40:54 <dmwit> \o/
23:41:22 * dmwit consults his GHC user guide
23:41:39 <dmwit> Yep, says it right here! Error 11: quantum mechanical observation error
23:41:56 <Veinor> haha
23:41:57 <shergill> heisenbeeeeerg!!!
23:42:20 <dmwit> Suggested debugging process: retry in another universe.
23:43:24 <shergill> in other words, retry. and yep, now it failed
23:44:20 <hpaste_> shergill pasted “cabal install - exitfailure 11 (verbosity 1)” at http://hpaste.org/67015
23:45:17 <dmwit> yowza
23:45:33 <dmwit> Are you using some TH or some similar extension to ask GHC to do tricky things?
23:45:49 <shergill> it's yesod, so yes
23:46:09 <dmwit> Also, it's a bit odd that it has the "Resolving dependencies..." line after building 6 of 8 files.
23:46:47 <shergill> i have two executables, so that's probably the cause of that
23:47:22 <dmwit> It should have separate countdowns for each executable, I'm pretty sure.
23:47:33 <shergill> ah ok
23:47:57 * hackagebot conduit 0.4.1.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.4.1.1 (MichaelSnoyman)
23:48:01 <dmwit> ...is your TH calling out to cabal-install??
23:49:04 <shergill> not any that i wrote =/
23:49:29 <dmwit> hm
23:49:43 <shergill> and i doubt the default one is. looking at the -v3 output, it seems to choke while -dcore-lint is spewing some stuff
23:50:44 <hpaste_> shergill pasted “cabal install - exitfailure 11 (verbosity 3)” at http://hpaste.org/67016
23:58:18 <shergill> lines such as "wired-in package ghc-prim mapped to ghc-prim-0.2.0.0-bd29cb1ca1b712d64e00ac9207f87d0a" seem suspicious, right?
