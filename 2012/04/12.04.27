00:00:03 <ski>     fmap f (MkF a0 a1) = MkF (f a1) (f a0)
00:00:13 <ppilate> c_wraith: Well, it's an excercise from http://www.haskell.org/haskellwiki/Typeclassopedia#Laws
00:00:25 <ppilate> *exercise
00:00:57 <ski> (one can also make another example, using multiple data constructors instead)
00:01:10 <mauke> ski: I don't see how that is valid
00:01:21 <c_wraith> mauke: the point is to make something that isn't valid
00:01:28 <c_wraith> But I don't think that qualifies
00:01:56 <c_wraith> I don't think fmap f . fmap g == fmap (f . g) with that definition
00:02:01 <mauke> ski: fmap id . fmap id = id, but fmap (id . id) isn't
00:02:01 <ski> hm, right, it fails the associativity law as well
00:02:25 <ppilate> Actually, would something like this do:
00:02:26 <ppilate> instance Functor Maybe where fmap _ _ = Nothing
00:02:29 <ppilate> ?
00:02:39 <mauke> fails fmap id = id
00:02:39 <c_wraith> heh
00:02:43 <c_wraith> that would qualify
00:02:49 <ppilate> mauke: yeah, that's the point :]
00:02:51 <c_wraith> mauke: are you paying any attention. the point is to be invalid
00:02:59 <c_wraith> and yes, that example works
00:03:06 <mauke> shit
00:03:09 <mauke> sorry
00:03:20 <ski> yeah, that's "copyable", but not "discardable", so works
00:03:25 <hpaste_> dan pasted “Typeclassopedia :: functors” at http://hpaste.org/67688
00:03:25 <mauke> c_wraith: I am, but somehow I managed to consistently mix up "first" and "second"
00:03:26 <Apes> Which is considered better style in the Haskell community? [ inc n = n + 1 ] or [ inc = (+1) ] ?
00:03:32 <c_wraith> mauke: ah.  oops.
00:03:45 <mauke> inc = succ :-)
00:04:06 <Apes> This is true, but it avoids the question
00:04:07 <ski> Apes : in the general case, it depends
00:04:12 <ppilate> Sorry for bothering you, but if anybody have 2-3 minutes of free time, could you check my solutions: http://hpaste.org/67688 ?
00:04:43 <Apes> ski: So there is no real tendency to use one over the other?
00:05:20 <ski> Apes : in some cases the point-free version is nicer and readable, and would then usually be preferred over the pointful version
00:05:35 <mauke> ppilate: instance Functor A where fmap f (A x) = fmap f x
00:05:40 <ski> Apes : in other cases the point-free version would be clumsy and/or hard to read
00:05:53 <mauke> hmm, no
00:05:58 <ski> Apes : in some cases, it's up to the reader's preferences which is the more readable version
00:05:58 <mauke> ppilate: instance Functor A where fmap f (A x) = A (fmap f x)
00:06:35 <ski> Apes : if you have any real example, we could give a subjective judgement for it
00:07:25 <ski> @pl perLine f s = unlines (map f (lines s))
00:07:25 <lambdabot> perLine = (unlines .) . (. lines) . map
00:07:37 <ski> here the pointless version isn't that readable
00:07:41 <ppilate> mauke: but I fail to see how it would work. Won't it loop forever?
00:07:46 <ski> but the "halfway"-pointless version
00:07:51 <mauke> ppilate: yes, but so what?
00:07:53 <ski>   perLine f = unlines . map f . lines
00:07:57 <ski> is quite readable
00:08:12 <ski> @pl \s -> unlines (map f (lines s))
00:08:13 <lambdabot> unlines . map f . lines
00:08:16 <ski> Apes : ok ?
00:08:34 <ppilate> hm, ok, so then I am not sure if there exists a * -> * type which cannot be made into a functor
00:08:52 <ski> ppilate : `IORef', e.g.
00:09:01 <mauke> data A' a = A' (a -> Int)
00:09:16 <ski> ppilate : `data Bar a = MkB (a -> Bool)' is another example
00:09:22 <Apes> ski: Okay, that makes sense
00:09:50 <Apes> ski: Thanks for your help, this tryhaskell.org tutorial doesn't really cover much that isn't in Python. I was getting bored with it.
00:10:41 <ppilate> mauke, Can't we just use fmap f (A' g) = A' (f . g) with that?
00:11:13 <ppilate> oh
00:11:15 <ppilate> sorry
00:11:36 <Apes> ski: What about the alternative [ \s -> unlines . map f . lines s ] ?
00:11:50 <mauke> Apes: type error
00:11:56 <ppilate> thanks mauke, ski
00:11:57 <mauke> unless your . is fmap
00:11:58 <ski> Apes : though, using SEC, one could write it like `perLine = (res unlines . arg lines) . map' or `perLine = (lines ~> unlines) . map', which are somwwhat more readable, assuming one knows the SEC primitives `arg',`res',`(~>)'
00:12:02 <ski> @where SEC
00:12:02 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
00:13:38 <ski> Apes : well, it's have to be `perLine f s = (unlines . map f . lines) s' or `perLine f s = unlines . map f . lines $ s' then (it doesn't matter if the `s' is on the left of the `=', or if you have `\s ->' to the right of `=' instead)
00:14:23 <ski> Apes : however, i think usually one'd want to simplify these to `perLine f = unlines . map f . lines' then (unless `s' was named inside the "pipeline" `unlines . map f . lines' -- which isn't the case in this example)
00:14:37 <Apes> I can see how it is a forced thing to have include the s rather than simply use the partially applied function in that situation
00:15:48 * ski nods
00:16:34 <Apes> Thanks for the help, ski
00:16:39 <MostAwesomeDude> .seen ekmett
00:16:44 <MostAwesomeDude> @seen ekmett
00:16:45 <lambdabot> Unknown command, try @list
00:16:58 <MostAwesomeDude> Oh, whatever. I'll wait for him. I am patient~
00:17:18 <ski> preflex: xseen ekmett
00:17:18 <preflex>  ekmett was last seen on freenode/#haskell-blah 39 days, 7 hours, 1 minute and 17 seconds ago, saying: * ekmett waves hello
00:17:25 <ski> preflex: xseen edwardk
00:17:25 <preflex>  edwardk was last seen on freenode/#haskell-blah 1 day, 8 hours, 30 minutes and 7 seconds ago, saying: http://comonad.com/reader/2008/linear-bloom-filters/
00:17:47 <MostAwesomeDude> ski: Thanks. I need to bug him about trifecta, but it can wait.
00:18:04 <ski> you could use `tell' or `ask', if you want to
00:18:07 <ski> @help tell
00:18:07 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:18:09 <ski> @help ask
00:18:09 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
00:18:40 <MostAwesomeDude> I'll have to phrase my complaint in the form of a short, innocent message first. :3
00:19:04 * ski grins
00:19:53 <ski> @type \f s -> unlines . map f . lines s  -- ho, hum
00:19:54 <lambdabot> (Char -> String) -> String -> [String]
00:23:41 <ski> > (\f s -> unlines . map f . lines s) (\c -> if isSpace c then [c,c] else [c]) "a b\nc d e\n"
00:23:42 <lambdabot>   ["a\n  \nb\n","c\n  \nd\n  \ne\n"]
00:25:04 * mauke cries
00:27:34 <Twey> Haha
00:30:51 <Apes> Haskell seems very terse
00:31:23 <Twey> It generally is
00:31:58 <Apes> (\s -> unlines s)(\f s -> unlines . map f . lines s) (\c -> if isSpace c then [c,c] else [c]) "a b\nc d e\n"
00:32:09 <hpaste_> charliesome pasted “read ints from file, output again” at http://hpaste.org/67689
00:32:18 <Apes> I have no power over lambda bot
00:32:27 <charliesome> ok so I have that code that hpaste_ so helpfully announced
00:32:36 <charliesome> that reads a bunch of integers from a file and prints them back out again
00:32:50 <charliesome> is there any way to make that code better/more concise?
00:32:57 <mauke> :t words
00:32:57 <charliesome> haskell beginnner here
00:32:58 <lambdabot> String -> [String]
00:33:17 <charliesome> mauke: oh cool!
00:34:00 <charliesome> map read $ words "1 2 3 4 5" :: [Int]
00:34:02 <charliesome> kickass
00:34:28 <Twey> charliesome: You could start with the ones hpaste suggested ;)
00:34:54 <charliesome> Twey: ooh that's cool
00:35:26 <charliesome> Twey: so it's suggested 'not . null' rather than '\x -> not $ null x'
00:35:31 <charliesome> Twey: what does that . operator do?
00:35:47 <mauke> @src (.)
00:35:47 <lambdabot> (f . g) x = f (g x)
00:35:47 <lambdabot> NB: In lambdabot,  (.) = fmap
00:36:26 <charliesome> nice!
00:36:30 <charliesome> thanks
00:37:25 <hpaste_> Twey annotated “read ints from file, output again” with “read ints from file, output again (annotation)” at http://hpaste.org/67689#a67690
00:37:42 <Twey> charliesome: Function composition
00:38:03 <Twey> f . g = \x -> f (g x)
00:38:13 * hackagebot Frank 0.1 - An experimental programming language with typed algebraic effects  http://hackage.haskell.org/package/Frank-0.1 (ConorMcBride)
00:38:43 <ski> Apes : you need to start the line with `> ' (or `@run '), otherwise lambdabot won't execute it
00:40:25 <Twey> charliesome: (also see hpaste_'s link)
00:40:50 <ski> > (\f -> unlines . map f . lines) reverse "Hello\nthere"
00:40:52 <lambdabot>   "olleH\nereht\n"
00:40:59 <ski> Apes : you can e.g try something like that
00:50:19 <ppilate> I was wondering, is there a way to redefine an instance of some type class?
00:52:31 <hpaste_> ski annotated “read ints from file, output again” with “guards” at http://hpaste.org/67689#a67693
00:52:38 <ski> charliesome ^
00:55:43 <ppilate> anyway, is this a correct instance of Applicative for Maybe: http://hpaste.org/67695 ?
00:57:09 <ski> "is there a way to redefine an instance of some type class?" -- no, the best you can do is not importing it
00:57:22 <ski> (or making a `newtype' and define the instance(s) you want for that one)
00:58:24 <ski> ppilate : not well-typed
00:59:42 <ski> ppilate : also, you could say `Just f <*> ... = ...' instead of `(Just f) <*> ... = ...'
00:59:44 <t7> can i get ghc to dump stg code?
01:01:27 <ppilate> ski: sorry, forgot to remove the "Just $" part
01:02:31 <ski> ppilate : then it's well-typed, and also correct
01:03:08 <ppilate> thanks ski :]
01:03:09 <ppilate> ski++
01:03:14 <srhb> I'm unfamiliar with low level stuff, does SIMD support mean (basically) that Haskell (repa, data parallel?) will be better suited to numeric array manipulations? For, say, large matrices and scientific numeric stuff.
01:03:46 <t7> yeah SIMD can do vector math
01:04:12 <t7> it can apply the same operation to multiple data
01:04:20 <srhb> Ah, then I understood it correctly.
01:04:58 <srhb> That'll be nice, perhaps it can displace some of the Fortran for astrophysics and what not - so painful.
01:12:45 <Skola> what's a tree called where each node has 2 parents?
01:13:11 <Apes> A graph
01:13:21 <elliott> "he authored the first Haskell compiler, hbc, which remains competitive with the Glasgow Haskell Compiler to this day." — really?
01:13:21 <t7> how do i get ghc to output core?
01:13:29 <elliott> t7: -ddump-simpl
01:14:08 <Skola> thanks Apes
01:14:08 <t7> do i need to compile with debugging support or something?
01:14:20 <Maxdamantus> Skola: it's not a tree if every node has two parents.
01:14:29 <danr> elliott: I remember reading that quote somewhere too, and I also remember not getting hbc to work
01:14:36 <Maxdamantus> (unless you consider there to be such a thing as an empty tree)
01:14:43 <Lemmih> elliott: When was it written?
01:14:47 <elliott> Lemmih: post-2011
01:14:55 <elliott> CUFP 2011 workshop report
01:15:08 <Skola> Maxdamantus: I was wrong, the outer nodes have 1 parent
01:15:36 <Maxdamantus> Trees have one node with no parents.
01:16:04 <Skola> yes
01:16:44 <Maxdamantus> But you still can't have any nodes other than the root have two parents.
01:16:47 <ski> @where hbc
01:16:47 <lambdabot> The Chalmers Haskell-B Compiler by Lennart Augustsson (augustss) at (darcs get) <http://www.cse.unsw.edu.au/~dons/code/hbc>,<http://darcs.augustsson.net/Darcs/hbc> -- Alternatively, the Hierarchical
01:16:47 <lambdabot> Bayes Compiler <http://www.cs.utah.edu/~hal/HBC/>
01:17:12 <Skola> okay
01:17:17 <Maxdamantus> Maybe with a rooted unidirectional acyclic graph.
01:17:37 <t7> ghc --ddump-simpl test.hs     doesnt do anything different that ghc test.hs
01:18:22 <Skola> Maxdamantus: project euler has a problem with a similar structure @ http://projecteuler.net/problem=18
01:18:26 <Skola> this is the kind I mean
01:18:54 <Apes> That's a graphing problem, skola
01:19:00 <Skola> okay
01:19:10 <Lemmih> elliott: Who wrote it?
01:19:21 <Maxdamantus> Yeah, it's not exactly a tree.
01:19:40 <elliott> Lemmih: One of Anil Madhavapeddy, Yaron Minsky, and Marius Eriksen. Or maybe all three.
01:19:42 <elliott> Or two!
01:19:45 <Maxdamantus> Just think of it as a rooted unidirectional acyclic graph.
01:19:47 <elliott> http://anil.recoil.org/papers/2011-cufp-scribe-preprint.pdf
01:20:08 <Apes> Skola: I think I solved that problem using Dijkstra's algorithm
01:20:27 <rekado> I have this type: type Conn = ErrorT ConnError (StateT Connection IO) ()
01:20:31 <Maxdamantus> Apes: seems unnecessary.
01:20:42 <Apes> Dijksta's algorithm is really simple
01:20:45 <rekado> and a runner function: runConn = runStateT . runErrorT
01:20:52 <Maxdamantus> Apes: it'd be simpler to do something else though.
01:21:09 <Maxdamantus> Apes: just maintain a map of the maximum costs for each node.
01:21:19 <rekado> this returns IO (stuff), but I want to just have it return IO ().
01:21:34 <rekado> background: I want to use runConn with forkIO.
01:22:01 <rekado> I don't understand how to unwrap the type. Any ideas?
01:22:55 <Lemmih> rekado: yourAction >> return ()
01:23:06 <Apes> Maxdamantus: That's Dijksta's algorithm
01:23:15 <Lemmih> rekado: Or: do yourAction; return ()
01:23:17 <Apes> Or at least I feel it's close enough to be a variant
01:23:25 <ski> rekado : you could start by using `evalStateT' (alternatively `execStateT' i suppose) instead of `runStateT'
01:23:46 <rekado> Lemmih: right, forgot about >>
01:24:00 <Spockz> blegh, dreaming of overlapping instances and cyclic dependencies … blegh
01:24:00 <ski> rekado : do you want to do anything specific if the `runErrorT' indicates an error ?
01:24:05 <rekado> ski: I thought I played with all possible combinations already.
01:24:10 <prabuinet> hi #haskell
01:24:11 <ski> @type Control.Monad.void
01:24:12 <lambdabot> Not in scope: `Control.Monad.void'
01:24:15 <ski> hello prabuinet
01:24:26 <prabuinet> ski, hello
01:24:28 <rekado> ski: I have an application that starts server threads with forkIO.
01:24:28 <ski> @hoogle m a -> m ()
01:24:28 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
01:24:28 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
01:24:29 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
01:24:29 <prabuinet> i'm a newbie here
01:24:31 <Maxdamantus> Apes: hmm .. I guess so.
01:24:37 <rekado> the error is handled inside the thread.
01:24:52 <ski> prabuinet : if you have any (haskell-related) question, just ask
01:25:16 <Lemmih> elliott: I definitely think it's a mistake. The authors are only marginally involved in the Haskell world.
01:25:28 <elliott> Lemmih: Right.
01:25:30 <ski> prabuinet : do you have a tutorial or book to read, yet ?
01:25:33 <Lemmih> Or oversight, rather.
01:25:42 <danr> it seelms like hbc supported renamings of supports; http://www.augustsson.net/Darcs/hbc/hbc_library/Option.hs
01:25:42 <elliott> I expected as much. But I'm still baffled as to how they came to write that sentence.
01:25:56 <elliott> supports?
01:26:03 <prabuinet> ski, i start with lyah and rwh
01:26:09 <ski> sounds good
01:26:35 <prabuinet> i'm keep switching between the two
01:26:46 <prabuinet> i*
01:27:43 <prabuinet> ski, i'm planning to write a web application in haskell, when i will be able to start (I mean after completing how many chapters?)
01:28:21 <ski> rekado : so you could use something like `runConn = void . runStateT . runErrorT' or `runConn = evalStateT . liftM (either (error . ("an error occurred : " ++)) id) . runErrorT', or something along those lines
01:28:22 <rekado> prabuinet: web application -- do you know yesod?
01:28:47 <rekado> ski: thanks, I'll try the first.
01:28:54 <ski> rekado : it depends on whether you want `runConn :: Conn a -> IO a', or only `runConn :: Conn () -> IO ()'
01:29:02 <prabuinet> rekado, i'm new to haskell, just started learning a few books. i want to make myself comfortable before jumping into web
01:29:14 <prabuinet> i just want to know when i can think i'm comfortable...
01:29:42 <ski> prabuinet : as soon as you got any questions, be sure to ask them here
01:30:10 <prabuinet> ski, ok, so you say i straightaway go start the webapp?
01:30:29 <ski> prabuinet : i'm not saying that, no
01:30:37 <rekado> ski: I just need to fork off a thread, so the latter is sufficient I think.
01:30:39 <Go_Apple> I need to formalize some data, and use the network, what things you think these models.
01:30:57 <ski> prabuinet : probably it would make more sense if you first familiarie yourself with the basics of the language
01:31:45 <ski> rekado : yeah .. i was more thinking about whether the more general version was sensible in your case or not ..
01:31:48 <rekado> prabuinet: once you have the basics with lyah you can check out the yesod book (available online) to see what you are missing to get started with yesod.
01:32:41 <rekado> ski: I don't know if I'm doing this right...
01:32:45 <prabuinet> rekado, is there a list which says these are the basics?
01:33:28 <rekado> ski: main forks off threads that deal with the connection in the Conn monad transformer stack.
01:33:37 <ski> (relatively often, a more general "building-block" version is easier to understand and grasp than a specific function made to only accept the input which currently needs to be passed to it ..)
01:34:27 <prabuinet> rekado, or the whole book is mandatory (lyah)
01:34:29 <rekado> prabuinet: I don't think so. But as soon as you run into something you don't understand well enough you know what to research next.
01:34:41 <rekado> prabuinet: I think reading all of lyah is a good idea.
01:34:55 <rekado> prabuinet: you will be less surprised then.
01:35:15 <prabuinet> rekado, ok
01:35:20 <ski> rekado, ok
01:37:15 <rekado> hmm, I still don't get it.
01:37:35 <rekado> _ <- forkIO $ runConn f initialState
01:37:35 <Go_Apple> I must find out the correct words, calculate sciences
01:37:50 <rekado> that's where runConn should fit in.
01:38:04 <rekado> so it takes a function and a state.
01:38:21 <rekado> and it should return IO ()
01:38:53 <rekado> f is a function that lives in the Conn monad.
01:39:16 <ski> actually, `f' is an action in the `Conn' monad
01:39:26 <rekado> ok.
01:39:41 <rekado> should f have the type Conn then?
01:40:00 <rekado> (I'm currently refactoring my application that did everything without the monad)
01:40:06 <ski> (it has type `Conn Blah', for some type `Blah' .. to be a function, it would have to have a type that looks like `... -> ...' -- since the type doesn't have a `->', it can't be a function)
01:40:30 <Go_Apple> Function, this word, or other word, find out, I using search, then determine. Function, let me think, I should find a way to determine the functin word.
01:40:31 <rekado> ski: I see.
01:41:36 * ski idly wonders whether Go_Apple has any haskell-related question
01:43:10 <Go_Apple> I know little about haskell, calculating, a little
01:44:10 <rekado> so then runConn should have this type signature: Conn :: Conn -> Connection -> IO ()
01:44:35 <rekado> er, I mean:  runConn :: Conn -> Connection -> IO ()
01:44:48 <rekado> where Connection is the state that's passed around
01:44:54 <ski>   runConn :: Conn Blah -> Connection -> IO ()  -- more probably
01:45:03 <ski> where `Blah' might be `a'
01:45:25 <rekado> type Conn = ErrorT ConnError (StateT Connection IO) ()
01:45:36 <rekado> Conn doesn't take a type variable.
01:45:40 * Cale notes that Go_Apple's IP address is from China
01:45:42 <ski> (the type constructor `Conn' takes an argument (it has kind `* -> *'), so you can't write just `Conn -> ...', you must write `Conn (...) -> ...')
01:46:35 <ski> rekado : oh, i missed the ending `()' there before
01:46:42 <ski> so you're correct, `Conn -> ...' it is
01:46:46 <prabuinet> ski,rekado, thanks
01:47:08 <rekado> ski: oh, good. I thought I was very confused. Now I'm only confused.
01:47:56 <Cale> Go_Apple: your English is hard to understand :(
01:48:05 <ski> (i thought you had defined `Conn' so that it could possibly be a monad, which would mean it having kind `* -> *' instead of `*' as it has now)
01:48:12 <rekado> Go_Apple_: 你是中国人吗？
01:48:28 <ski> preflex: xseen ManateeLazyCat
01:48:28 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 44 days, 18 hours, 14 minutes and 2 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
01:48:40 <t7> who down voted me on stackoverflow?
01:48:55 <t7> meany
01:49:08 * ski stares blankly
01:49:16 <ion> blankly stares back.
01:49:19 <rekado> ski: how would I call `Conn'? Is it a monad transformer stack?
01:49:25 <Go_Apple_> haskell very hard, harder than I thought.
01:49:52 <rekado> Go_Apple_: do you have a book to learn?
01:50:21 <ski> rekado : no, it's just a specific action type (a type of actions yielding `()', in the `ErrorT ConnError (StateT Connection IO)' monad, which is a monad transformer stack)
01:50:32 <ski> @where LYAH
01:50:32 <lambdabot> http://www.learnyouahaskell.com/
01:50:36 <t7> i wanted to make a core to javascript translator but i cant output core :(
01:50:37 <Go_Apple> I view the book on haskell website, but now nearly forget.
01:50:42 <ski> Go_Apple : try that link ^
01:50:47 * Arafangion highly recommends "Haskell for the real world".
01:50:56 <ski> @where RWH
01:50:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:51:34 <rekado> ski: okay.
01:51:56 <Arafangion> The mistake I made with haskell was trying to learn about monads *first*.
01:52:36 <rekado> ski: maybe my definition for `Conn' is wrong then.
01:53:06 <ski> why ?
01:53:25 <rekado> I understand this transformer business well enough when there is one transformer only; with two of them I'm quite lost.
01:53:31 <ski> (not saying it's right, mind, just asking :)
01:54:04 <Go_Apple> I read some contents some chapters on haskell website, but I can't read the next, no use in actual works, real works.
01:54:11 <womb> guys what do you do if you try 4-5 times and still don't win ?
01:54:16 <ski> the general pattern is `TransformerA (TransformerB (TransformerC BaseMonad))', which is a monad type
01:54:42 <ski> and then `TransformerA (TransformerB (TransformerC BaseMonad)) Blah' would be the type of actions for that monad, yielding results of type `Blah'
01:54:49 <danr> t7: did you ask about -ddump-simpl ?
01:54:59 <ski> womb : try what ? win what ?
01:55:11 <Go_Apple> Mathemetics, I must prepare exams.
01:56:16 <rekado> ski: when more than one transformer is applied, are all functions of all transformers available/
01:56:19 <rekado> ?
01:56:20 <ski> rekado : in your case, the monad transformers are `ErrorT ConnError' and `StateT Connection', and the base monad is `IO'
01:56:45 <ski> rekado : no, only the ones of the outermost transformer is (directly) available
01:56:53 <rekado> the rest has to be lifted?
01:56:58 <ski> in many cases you can use `lift' to access the "inner layers", though
01:57:03 <rekado> ok
01:57:12 <t7> danr: it doesnt do anything different for me
01:57:13 <ski> also, many of the monadic operations are overloaded, so that they "auto-lift", where needed
01:57:44 <ski> e.g. `get',`gets',`put',`modify',`ask',`asks',`local',&c.
01:57:57 <t7> do i need to turn on debugging or somethign?
01:58:02 <danr> t7: did you do both -ddump-simpl and -fforce-recomp ?
01:58:07 <t7> no
01:58:10 <danr> try it!
01:58:11 <rekado> ski: I see.
01:58:39 <alpounet> t7, i opened a new file, wrote some simple haskell code, did ghc -fext-core foo.hs
01:58:43 <alpounet> and i have the .hcr file
01:59:02 <alpounet> on a Windows 7 machine, with the latest platform
01:59:15 <t7> omg it must have been because it had no changes since last build
01:59:24 <womb> i'm solving problem and i'm running out of ideas how to do it in a way that will scale and will not require me thinking about it everytime i do it.
01:59:41 <t7> ok im an idiot, sorry all
02:00:49 <danr> t7: np it's a bit annoying that ghc silently ignores your wishes if it already has up-to-date interface files
02:01:11 <danr> did you remove your question from SO?
02:01:43 <rekado> `void . evalStateT . runErrorT' gives me this type:  Conn -> Connection -> ()
02:01:54 <rekado> where has the IO gone?
02:02:23 <rekado> (I know I could wrap it in a return, but it should be there after stripping off StateT, no?)
02:06:56 <ski> rekado : hm, which `void' are you using
02:07:07 <ski> @hoogle m a -> m ()
02:07:07 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
02:07:07 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
02:07:07 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
02:07:17 <ski> the one mentioned above, from `Control.Monad'
02:07:39 <rekado> I use the one from Control.Monad
02:07:40 <ski> if you want to, you could write `liftM (const ())' (or `fmap (const ())') instead of `void'
02:07:55 <rekado> but I suspect that my Conn type is just wrong
02:08:19 <mauke> :t void . evalStateT . runErrorT
02:08:20 <lambdabot> Not in scope: `void'
02:08:33 <mauke> :t (fmap (const ())) . evalStateT . runErrorT
02:08:33 <lambdabot> forall s (m :: * -> *) e a. (Monad m) => ErrorT e (StateT s m) a -> s -> ()
02:08:40 <mauke> there we go
02:08:57 <ski> oh, right ..
02:08:59 <mauke> :t runErrorT
02:09:00 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
02:09:05 <mauke> :t evalStateT
02:09:06 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
02:09:14 <ski> yeah, this is because `evalStateT' takes an extra argument
02:09:33 <ski>   runConn s = void . (`evalStateT` s) . runErrorT
02:09:36 <ski> should work
02:09:47 <rekado> yes! that must be it
02:10:18 <t7> maybe llvm is the best way to go
02:17:59 <rekado> thanks ski and mauke; that compile error is now gone.
02:38:43 <womb> > 7*7
02:38:44 <lambdabot>   49
02:38:45 <womb> :t map
02:38:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:50:25 <danr> womb: (*) is a pure function so the result is not going to change :)
02:53:18 <statusfailed> What's the "fix" function?
02:53:22 <statusfailed> I totally don't get it
02:53:23 <mauke> @src fix
02:53:24 <lambdabot> fix f = let x = f x in x
02:53:34 <statusfailed> Right- but what is it for?
02:54:22 <JesusIsLord> fixed points
02:54:24 <JesusIsLord> > fix (1:)
02:54:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:54:32 <bitonic> statusfailed: it encodes recursion
02:54:56 <bitonic> statusfailed: a clearer declaration is `fix f = f (fix f)'
02:55:02 <JesusIsLord> > fix (\f -> ..  use f to "recurse" ..)
02:55:03 <lambdabot>   <no location info>: parse error on input `..'
02:55:26 <mysticc> > fix (1:2:)
02:55:26 <lambdabot>   The operator `:' [infixr 5] of a section
02:55:27 <lambdabot>      must have lower precedence th...
02:55:29 <bitonic> statusfailed: as you can see it'll apply a chain of fs: `f (f (f ...))'
02:55:31 <ion> let foo = something foo something else in foo
02:55:37 <ion> fix (\foo -> something foo something else)
02:55:45 <ion> Those are equivalent.
02:55:51 <JesusIsLord> > fix ((1:).(2:)) -- mysticc
02:55:52 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
02:56:00 <ion> > let ones = 1:ones in ones
02:56:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:56:03 <JesusIsLord> or, > fix (\f -> 1:2:f)
02:56:03 <ion> > fix (1:)
02:56:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:56:56 <JesusIsLord> it's also called the "y combinator"
02:57:08 <bitonic> JesusIsLord: no, it's not, the Y combinator is a way to write fix
02:57:13 <statusfailed> fix (:1) doesn't work for me
02:57:22 <mauke> statusfailed: what did you expect it to do?
02:57:37 <statusfailed> oh whoops
02:57:38 <statusfailed> hah
02:57:39 <JesusIsLord> statusfailed: what would the type of (:1) be?
02:57:40 <bitonic> statusfailed: that won't typecheck
02:57:46 <statusfailed> I meant to type (1:)
02:57:49 <JesusIsLord> :)
02:58:04 <statusfailed> ok, so what might I use it for?
02:58:10 <JesusIsLord> mainly golfing
02:58:16 <bitonic> statusfailed: anyways fix is pretty mindblowing, you should read something better about it, I expect this conversation to be incredibly confusing if you've never met it before
02:58:27 <statusfailed> bitonic: yes, it is :P
02:58:28 <bitonic> it has a great significance when studying recursion
02:58:47 <statusfailed> so it's mostly a pedagogical tool? :)
02:58:53 <mysticc> statusfailed: One use here .. http://stackoverflow.com/questions/3208258/memoization-in-haskell
02:59:07 <bitonic> statusfailed: there are various resources, most books about type systems start off with an explanation of lambda-calculus and subsequently fix
02:59:20 <bitonic> statusfailed: the favourite book here seems to be "types and programming languages"
02:59:22 <bitonic> @where TaPL
02:59:22 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
02:59:39 <statusfailed> I could definitely use some formal education in this regard
02:59:39 <statusfailed> thanks :)
03:01:18 <bitonic> statusfailed: well more than a pedagogical tool is a very important concept when studying recursion in general. the fact that you can define it in the lambda-calculus but you can't in consisent type systems is very important
03:02:06 <bitonic> statusfailed: but yeah IRC is not the best way to learn about this things, since as I said they're pretty mind blowing ehe
03:03:02 <bitonic> anyway yes, TaPL is the gateway drug to type systems, so I highly reccomend it :P
03:03:19 * hackagebot planar-graph 1.0.0.0 - A representation of planar graphs  http://hackage.haskell.org/package/planar-graph-1.0.0.0 (IvanMiljenovic)
03:04:50 <t7> bitonic helps to have a phd in math and theorem proving when reading it though ...
03:05:12 <statusfailed> dammit
03:05:14 <bitonic> t7: I disagree. I have little formal education in maths and I still read it
03:05:20 <statusfailed> undammit
03:05:26 <bitonic> the good thing about TaPL is that is very accessible
03:05:48 <t7> the first section was warping my brain
03:05:58 <t7> I didnt know much abotu set theory etc back then
03:06:11 <bitonic> TaPL doesn't juggle much with set theory
03:06:20 <t7> i still know eff all about proving things
03:08:39 <bitonic> t7: cmon most proofs in TaPL are not hard
03:13:20 * hackagebot Frank 0.2 - An experimental programming language with typed algebraic effects  http://hackage.haskell.org/package/Frank-0.2 (ConorMcBride)
03:13:26 <bitonic> ohoh!
03:14:02 <bitonic> I didn't know about this Frank.
03:15:32 <bobry> does anyone know if there's a HaXR version which supports 64-bit ints?
03:16:55 <t7> how do i represent ADTs....
03:17:02 <t7> i can do Sum and Product types
03:17:21 <t7> but these can be implemented in ADTs
03:17:34 <liyang> bitonic: the version number doubled in a matter of hours!
03:17:57 <hayashi> Applicative Parsec.  Oh my giddy aunt.
03:17:58 <bitonic> liyang: yes, so much progress.
03:18:17 <bitonic> hayashi: a strict subset of Monadic Parsec :P
03:19:10 * hayashi watches lines fall off his parsing code
03:23:49 * liyang wonders if pigworker's Frank is at all related to http://www.talktofrank.com/
03:24:31 <quicksilver> pigworker is fond on puns, so who knows.
03:26:21 <merijn> Wasn't his latest thing to see how many Shakespeare references he could sneak into paper titles?
03:28:01 <tdammers> quick question: how do I get cabal (or cabal-dev) to recognize quoteFile source files as dependencies?
03:28:42 <tdammers> that is, I do [myquoter|foobar.txt|] in Main.hs, and I want Main.hs to depend on foobar.txt so that it gets recompiled when I change foobar.txt
03:29:00 <elliott> you can't
03:29:05 <elliott> and it's ghc that does that, not cabal
03:29:09 <tdammers> hmm, right
03:29:10 <elliott> it's a template haskell feature that should be coming some day, iirc
03:29:16 <elliott> it's on the trac somewhere
03:29:20 <tdammers> pretty annoying
03:29:30 <elliott> solution: don't use TH :)
03:29:34 <tdammers> meh
03:30:10 <tdammers> how is situation typically handled with hamlet?
03:30:51 <dcoutts> elliott: yeah and annoyingly the recomp feature is going to be implemented in such a way that it's not usable by external build managers, only ghc --make
03:31:14 <elliott> don't worry, I assume anything related to building haskell programs is annoying by default :P
03:31:23 <elliott> tdammers: -fforce-recomp, probably.
03:31:23 <tdammers> ghc --make is rather comfy, really
03:31:32 <elliott> tdammers: or using their development server
03:31:36 <elliott> which handles hamlet dependencies, iirc
03:31:41 <tdammers> their, as in yesod?
03:31:46 <tdammers> I'm not using yesod
03:32:00 <tdammers> I'm playing around with my own template language, running in happstack
03:32:25 <tdammers> hamlet was just an example, as it somehow seems to work in yesod
03:32:41 <elliott> yes
03:32:46 <elliott> they do funky things with their development server
03:32:56 <tdammers> it's also way too heavy for my taste
03:33:31 <tdammers> compiling yesod and then the scaffolded default site took me about an hour
03:34:02 <t7> whats mu abstraction in type theory?
03:34:31 <bitonic> t7: equi-recursive types?
03:34:36 <quicksilver> generally recursion
03:34:44 <bitonic> (saying that because there's a mu in that, iirc)
03:35:16 <quicksilver> u X . (1 + (A * X))
03:35:21 <quicksilver> ^^ the list type
03:35:22 <bitonic> t7: mu is also used to indicate the least fixed point operator
03:35:53 <bitonic> well, which is what it is in that case.
03:37:02 <quicksilver> it's not really an operator, in my syntax. But yes, type recursion would normally be given by least fixed point.
03:37:31 <bitonic> t7: again, TTFP has a chapter on that. I can't believe that it is the only book that covers this stuff, but it seems to be.
03:37:54 <t7> ah i still havnt printed that out
03:38:10 <bitonic> well on why we take the least fixed point
03:38:21 <bitonic> it's towards the end
03:39:09 <mysticc> @where ttfp
03:39:09 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
03:39:16 * hayashi shudders at his sudden mix of monadic bind and applicative combinators
03:39:31 <tdammers> looks like I'll go with cabal-dev build --ghc-options -fforce-recomp
03:40:06 <tdammers> if I use this kind of setup in a real project, I'll need a better solution, but for now it will work
03:40:43 <tdammers> maybe I'll write a little utility that parses the filenames out of quasiquotes and keeps its own list of dependencies... ugh...
03:43:10 <edsko> @pf  \rc -> return (rc - 1, rc - 1)
03:43:10 <lambdabot> Maybe you meant: bf pl
03:43:18 <edsko> @pl  \rc -> return (rc - 1, rc - 1)
03:43:18 <lambdabot> return . ap ((,) . subtract 1) (subtract 1)
03:43:23 * hackagebot network-interfacerequest 0.0.1 - Haskell bindings for the ifreq structure  http://hackage.haskell.org/package/network-interfacerequest-0.0.1 (AndrewMiller)
03:44:09 <bitonic> @type return . (-1) *** (-1)
03:44:10 <lambdabot> forall a (m :: * -> *) (a1 :: * -> * -> *) b b' c'. (Monad m, Num (a1 b a), Functor (a1 b), Num (a1 b' c'), Arrow a1) => a1 (b, b') (m a, c')
03:44:45 <bitonic> > let f = return . (-1) *** (-1) in f 2
03:44:45 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:44:46 <lambdabot>    arising from a use of `M1612655178...
03:45:07 <bitonic> ah, no
03:45:53 <bitonic> > let f = return . (-1) &&& (-1) in f 2
03:45:54 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:45:54 <lambdabot>    arising from a use of `M2056227054...
03:46:04 <bitonic> for some reason the arrow operators don't stick to my mind
03:46:58 <JesusIsLord> (&&&) is "and", so it copies its input
03:47:18 <quicksilver> (***) looks like a tensor product, which is what it is.
03:47:29 <JesusIsLord> \otimes
03:47:31 <JesusIsLord> oh well
03:48:52 <bitonic> ah, my thing didn't work because of -1...
03:49:04 <bitonic> > let f = return . (+1) &&& (+1) in f 2
03:49:04 <JesusIsLord> yeah, use subtract
03:49:05 <lambdabot>   No instance for (GHC.Show.Show (m t))
03:49:05 <lambdabot>    arising from a use of `M4461137348...
03:50:04 <bitonic> > ((subtract 1) &&& (subtract 1)) 1
03:50:04 <lambdabot>   (0,0)
03:50:05 <JesusIsLord> is (|||) like a coproduct?
03:50:06 <ClaudiusMaximus> wow.. Alloc rate    18,446,744,068,329,454,031 bytes per MUT second
03:50:24 <JesusIsLord> ClaudiusMaximus: that is almost 2^64, 18446744073709551616
03:50:53 <JesusIsLord> surely not a coincidence..
03:51:29 <mysticc> >  2^64
03:51:30 <lambdabot>   18446744073709551616
03:54:06 <ClaudiusMaximus> seems to be something related to profiling, +RTS -p -h -s -xc  reports negative productivity, i think it's mishandling the different timings for INIT/MUT/GC/RP/PROF/EXIT
03:54:51 <ClaudiusMaximus> > 2^64 - 18446744068329454031
03:54:52 <lambdabot>   5380097585
03:55:27 <ClaudiusMaximus> probably got a negative time, then wrapped around
03:58:25 * hackagebot alsa-core 0.5.0.1 - Binding to the ALSA Library API (Exceptions).  http://hackage.haskell.org/package/alsa-core-0.5.0.1 (HenningThielemann)
04:30:37 <statusfailed> Hmm. [1..] is a list of Enum?
04:30:54 <statusfailed> I just want Num, is there a better way to do this? `xs = 1 : map (+1) xs`
04:31:25 <shachaf> iterate (+1) 1?
04:31:28 <statusfailed> oh cool.
04:31:29 <statusfailed> hehe
04:31:53 <shachaf> @ty map fromInteger [1..]
04:31:53 <lambdabot> forall a. (Num a) => [a]
04:31:58 <shachaf> Also that. :-)
04:32:25 <statusfailed> choices, choices :)
04:43:34 <merijn> Hmmm, I find myself needing to write some "imperative" pure code and it's a bit of a pain. I essentially have a "[(a,b)]" and need to do a sequence of lookups/updates. The code to this becomes really awful looking however. Any suggestions?
04:44:03 <shachaf> Can you show some awful code?
04:44:07 <ment> merijn: Data.Map?
04:44:07 <merijn> update (update (update l key1 val1) key2 val2) key3 val3)
04:44:30 <shachaf> runUpdates [key1 ==> val1, key2 ==> val2, key3 ==> val3] l
04:44:37 <ion> update key3 val3 . update key2 val2 . update key1 val1
04:44:39 <shachaf> Where runUpdates is just a fold.
04:44:58 <shachaf> Basically what ion said.
04:45:18 <shachaf> If you use Data.Map you can probably get away with using union or fold with insert or something.
04:46:03 <merijn> hmm, yeah. That works for sequences of updates, but not really for (for example) looking up two keys and then exchanging their values
04:46:19 <elliott> You could use State (Map a b).
04:46:23 <shachaf> Well, you can use State pretty easily.
04:46:26 <ion> Yes, that.
04:46:26 <shachaf> Right, what elliott said.
04:46:28 <merijn> Hmm
04:46:34 <merijn> That might be a better idea actually
04:46:35 <shachaf> Or a simple wrapper around State that only supports key-value operations.
04:46:39 <elliott> But, OTOH, Map a b -> Map a b might be just fine.
04:46:40 <ion> what shachaf said about what elliott said
04:46:41 <merijn> I wonder why I didn't think of that
04:46:48 <elliott> If you don't have any auxiliary results, then you can just use (>>>) rather than (>>).
04:47:14 <shachaf> The equivalent of [Action] when some actions get input from the results of other actions is pretty much a monad.
04:47:27 <elliott> FSVO pretty much equal to more or less exactly.
04:47:35 <shachaf> Right.
04:47:42 <merijn> shachaf: I know, which is why I thought do notation would be nice
04:47:42 <elliott> That's the most difficult-to-parse thing I've ever said.
04:47:55 <merijn> shachaf: It just didn't occur to me to use the state monad :p
04:47:58 <shachaf> elliott: Untrue.
04:48:11 <shachaf> merijn: Don't use the State monad! It's too powerful.
04:48:28 <ion> The power will corrupt you.
04:48:58 <shachaf> newtype KV k v a = KV (State (Map k v) a)
04:49:32 <shachaf> getKV :: Ord k => k -> KV k v v
04:49:42 <shachaf> setKV :: Ord k => k -> v -> KV k v ()
04:49:46 <shachaf> Something like that, I don't know.
04:50:17 <shachaf> Except it's not a Monad. :-(
04:50:21 <shachaf> Oh, wait, it is.
04:50:31 <ion> deriving (Functor, Applicative, Monad)
04:50:34 * shachaf is just plain confused these days.
04:50:51 <shachaf> ion: Hmm, that'll just work?
04:51:13 <ion> IIRC it does with GenersomethingNewtypeDeriving
04:51:21 <ion> Generalized
04:51:21 <JesusIsLord> Generalized
04:51:58 <shachaf> General Ized
04:52:53 <ion> The British should have their own fork of GHC Haskell which has GeneralisedNewtypeDeriving.
04:53:56 <JesusIsLord> isn't GHC british? the traitors
04:54:19 <elliott> JesusIsLord: The OED uses -ized too.
04:54:33 <elliott> It's not an Americanism in origin.
04:54:36 <ion> elliott: The traitors.
04:54:45 <JesusIsLord> heretics, all of them
04:54:47 <elliott> Well, it's true that Oxford are traitors.
04:54:51 <t7> Scotland doesnt want to be british anymore. But SPJ and marlow are in Cambridge so....
05:05:46 <codingtales> sumSink :: Resource m => Sink Int m Int as per the Conduit Appendix in the Yesod book won't work. What should I replace Resource with?
05:06:53 <shachaf> A bug report, sent to the authors.
05:07:09 <codingtales> shachaf: It's not a bug report
05:07:20 <codingtales> Resource has been replaced with ResourceT
05:07:24 <ion> Preferably with more details than “won’t work”.
05:07:35 <shachaf> codingtales: That sounds like a bug to me.
05:07:43 <codingtales> Resource is not available in Data.Conduit
05:07:55 <shachaf> (In the book, I mean, not in Conduit. Or maybe in Conduit. Or maybe both. Who knows.)
05:07:57 <codingtales> ResourceT m a is available
05:08:05 <m3ga> codingtales: the whole conduit API changed quite radically form 0.2 to 0.4.
05:08:26 <shachaf> Except ResourceT is a type, not a class.
05:08:26 <codingtales> m3ga: yes. The book is on 0.2.
05:08:43 <m3ga> codingtales: check to wen site for the book and see if the web version has been updated.
05:08:48 <codingtales> shachaf: Resource is a class too
05:09:46 <ion> class Resource; data Resource = Resource; instance Resource Resource
05:13:31 <fmap> @hoogle (<<)
05:13:32 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
05:13:32 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
05:13:32 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
05:14:21 <codingtales> ion: http://www.snoyman.com/haddocks/conduit-0.2.0/Data-Conduit.html#t:Resource It's in Conduit 2.0
05:19:10 <Wooga> hi, can someone recommend good parser/parser generator for haskell? preferably with PEG grammar
05:19:28 <JesusIsLord> the only parser generator i know of is happy/alex
05:19:46 <codingtales> Found it, it's been replaced with MonadResource
05:19:55 <JesusIsLord> in Haskell a lot of people prefer parser combinators
05:20:04 <codingtales> https://github.com/snoyberg/conduit/blob/master/resourcet/Control/Monad/Trans/Resource.hs#L148
05:20:07 <JesusIsLord> Parsec, or attoparsec are good libraries
05:20:53 <bitonic> Wooga: there is a peg parser generator by the guy that did pandoc, but it's not actively developed iirc
05:22:11 <ion> I’d begin by looking whether Parsec matches your needs. I suppose Trifecta is still mostly undocumented. :-\
05:22:28 <bitonic> there's also polyparse
05:23:13 <t7> i bet SPJ gets so sick of haskell. i bet some days hes like 'if i see another monad today im gonna...'
05:23:49 <kallisti> heh. I somehow doubt that.
05:24:18 <ion> If he does, he certainly fakes enthusiasm well in talks.
05:25:52 <kallisti> I'm tempted to apply for this position that was posted on haskell-cafe, fully realizing that I'm completely underqualified by about 2 years of Haskell experience and many years of experience in everything else. Where are all the entry-level Haskell positions? :P
05:26:21 <Botje_> kallisti: you want to report to the monad factory and functor mines, then.
05:26:50 <codingtales> t7: That's going into the quotes section of the next Haskell Weekly News issue
05:27:49 <kallisti> Botje_: is that where large groups of people laborious define monad transformer instances, so that the rest of us can code happily?
05:27:54 <kallisti> +ly
05:28:35 <Botje> kallisti: yes, that :P
05:29:42 <kallisti> I guess I'll just spend the next 2 years working on some amazing personal project.
05:29:56 <kallisti> whatever that may be.
05:30:49 <kallisti> oh I know. Haskell -> ActionScript compiler.
05:30:56 <kallisti> Educational flash games written in Haskell. :P
05:31:40 <hpc> kallisti: "Ridiculously Complicated Trivial Pursuit"?
05:32:38 <ion> Good luck, since Adobe is finally killing Flash. :-)
05:33:02 <kallisti> hpc: well we use many ridiculously complicated things for very trivial means.
05:33:28 <kallisti> these kinds of complicated libraries would serve other people as well. Except that I didn't realize Adobe was killing Flash. :P
05:34:19 <kallisti> it's almost like you guys know about HTML5.
05:34:28 <kallisti> strange.
05:34:44 <ion> They’re starting with Linux support, but they’re probably just going to make HTML5 authoring tools in the end.
05:35:04 <t7> i wish i could go back in time and change javascript into a statically typed language
05:35:06 <kallisti> yeah I noticed the drop of Linux support.
05:35:15 <t7> that is more important than anything else in history
05:35:39 <kallisti> t7: you could continue moving forward in time and do that.
05:35:51 <kallisti> just make a simple javascript dialect with static typing, that compiles to Javascript.
05:36:51 <kallisti> though it's a shame that you even need to do things like that to begin with.
05:37:08 <t7> yeah but i will still have to maintain huge messes of spaghetti code
05:37:48 <bitonic> t7: types alone are not enough to avoid spaghetti code.
05:38:26 <t7> your right... we need dependantly types javascript
05:38:44 <JesusIsLord> first typed javascript, ty
05:41:03 <kallisti> I should spend some time learning about the inside of GHC.
05:41:12 <kallisti> I should spend time learning a lot of things, but that would be a good one.
05:41:38 <bitonic> kallisti: you can read those two papers
05:41:47 <bitonic> that'd be more useful than learning about GHC specifically
05:42:22 <kallisti> I've already read how to make a fast curry.
05:42:36 <kallisti> oh, no, not that one.
05:42:51 <bitonic> I mean the STG paper and the other one I can't remember :P
05:42:55 <bitonic> the eval/apply one? maybe
05:43:03 <kallisti> yeah I've read the STG paper.
05:43:08 <kallisti> but GHC doesn't work like that anymore.
05:43:09 <t7> i just saw that on microsoft research...
05:43:18 <bitonic> kallisti: it doesn't?
05:43:30 <mog_> I wonder, how would one go about combining count and sepBy in Parsec? ie if I want to parse exactly 5 instances of something separated by a space, what's the idiomatic way to do it?
05:44:26 <kallisti> bitonic: well I don't think it does push/enter anymore
05:44:43 <bitonic> mog_: '[one, two, three, four, five] <- sepBy blah' will work but it's not what you want (the error message will be ugly)
05:45:24 <mog_> oh through pattern matching with the receiver?
05:46:02 <bitonic> mog_: so the easiest thing is probably '(:) <$> p <*> count 4 (sep <* p)'
05:46:05 <kallisti> replicateM is good
05:46:06 <Botje> nSepBy n item sep = liftM2 (:) item (count n (sep >> item))
05:46:11 <bitonic> mog_: yes, which will call fail
05:46:34 <bitonic> yeah my solution and Botje  are the same but I'm more Applicative than him.
05:46:45 <mog_> ok ok : d
05:46:50 <bitonic> and it should be '*>' and not '<*' :P
05:47:08 <mog_> I didn't manipulate Aplicative yet so I don't quite get the subtle things going on here ;(
05:47:13 <mog_> Applicative*
05:47:37 <Botje> mog_: do you know liftM2?
05:47:49 <Botje> liftM2 f a b = f <$> a <*> b
05:47:58 <bitonic> mog_: well, '(:) <$> p <*> count 4 (sep *> p)' is the same as 'do first <- p; rest <- count 4 (sep >> p); return (first : rest)'
05:48:27 <mog_> oh ok, I see
05:48:30 <kallisti> liftM2 (:) p (replicateM 4 (sep >> p))   -- does this differ from count?
05:48:52 <bitonic> kallisti: no, count is replicateM
05:49:01 <kallisti> ah
05:49:04 <bitonic> afaik.
05:49:18 <Botje> sequence (replicate n ...)
05:49:19 <Botje> so yes
05:50:04 <mog_> well thanks guys with all that I'll sort it out in a way less uglier fashion than previously :)
05:56:06 <nand`> What's the best and most straightforward way to implement (toBase64 :: Integer -> String)?
05:56:20 <nand`> or; alternatively, :: Integer -> [Char8] or even :: Integer -> ByteString
05:56:26 <nand`> s/Char8/Word8/
05:56:30 <hpc> :t showIntAtBase
05:56:31 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
05:57:49 * Botje wonders if nand`s code contains a comment "This is the deadliest number in the world. One person accidentally saw a factor and had to be hospitalized. BE CAREFUL"
05:58:30 <hpc> http://hackage.haskell.org/packages/archive/base64-string/0.2/doc/html/Codec-Binary-Base64-String.html -- try this
05:58:39 <nand`> Botje: hehe; nothing that fancy unfortunately
05:58:41 <hpc> maybe
05:58:47 <quicksilver> nand`: http://hackage.haskell.org/package/base64-bytestring-0.1.1.1 ?
05:59:34 <hpc> @src Integer
05:59:34 <lambdabot> data Integer = S# Int#
05:59:35 <lambdabot>              | J# Int# ByteArray#
05:59:42 <hpc> @src ByteString
05:59:42 <lambdabot> Source not found.
05:59:52 <nand`> quicksilver: I already have toBase64 :: ByteString -> ByteString; the problem would be formatting Integer -> ByteString (treating the whole thing as binary; I don't want to output to human-readable numerals)
05:59:55 <bitonic> ByteString = (ForeignPtr Word8, Size)
06:00:17 <shachaf> HELP I accidentally installed an edwardk package and now my Control.Monad. tab completion doesn't fit in a screen anymore.
06:00:32 <hpc> haha
06:01:21 <quicksilver> nand`: well, Integer->[Word8] is just a simple unfold.
06:01:29 <quicksilver> nand`: you do have to choose endianness though.
06:02:23 <t7> someone should make something like coqide for agda. emacs is a pain in the bum
06:02:43 <nand`> quicksilver: I suppose I'll just define it as little endian and stick to that
06:02:51 <hpc> little-endian makes the math nice for (Integer -> [Word8]), then big-endian is just reversing the list
06:03:01 <nand`> I'm the one writing the protocol so I have the power to do that
06:03:08 <Wooga> hi, is it a correct way to parse a double in Parsec terms: http://paste.pocoo.org/show/587929/ ?
06:03:25 <bitonic> t7: no. emacs is great.
06:03:40 <bitonic> hpc: not reall, is reversing every 4 word8s
06:03:48 <hpc> Wooga: should work
06:03:52 <hpc> bitonic: ah, true
06:04:01 <Wooga> hpc: the problem is: i can't make .dot part optional
06:04:14 <bitonic> well, if you're on a 32bit machine
06:04:22 <statusfailed> I want to generate a list the same length as another list, what's the best way to do it? using length would evaluate the list twice, so I used "zipWith"- is there a better way?
06:04:34 <quicksilver> bitonic: no it's not.
06:04:44 <quicksilver> bitonic: that's a totally different question
06:05:00 <sajith> people, anyone have seen "<command line>: cannot satisfy -package Cabal-1.14.0" error message before?
06:05:03 <quicksilver> but normally there would be no need to arrange the Word32 clusters
06:05:12 <bitonic> quicksilver: what's not?
06:05:14 <Wooga> in PEG parser generators i am able to refer to whole matched string of current subexpression
06:05:20 <nand`> hpc: what would the math look like? toWord8 num = let (d,m) = num `divMod` 256 in m : toWord8 d
06:05:25 <Wooga> is there a way to perform same here?
06:05:46 <mysticc> sajith: Yes I think ..
06:05:47 <bitonic> quicksilver: I'm not sure what you're referring to, I was replying to hpc comment on endianness
06:05:54 <sajith> mysticc: http://hpaste.org/67702
06:06:09 <sajith> mysticc: do you know a solution? :)
06:06:28 <mysticc> sajith: what does ghc-pkg check gives ?
06:06:51 <quicksilver> bitonic: yes. When representing an arbitrary integer as a stream of word8s
06:06:56 <hpc> Wooga: make a parser that tries to get the decimal part
06:07:02 <sajith> mysticc: says process-1.0.1.5 is broken
06:07:02 <quicksilver> bitonic: there would be no reason to permute the word32 clusters
06:07:06 <hpc> if it doesn't get one, return "0" or something
06:07:07 <hpc> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:try
06:07:14 <mysticc> sajith: Then correct it .. :P
06:07:29 <bitonic> quicksilver: hpc said "to change endianness reverse the list", which sounds wrong. that's what I was replying to
06:07:40 <bitonic> I don't know what the background is
06:07:52 <Wooga> hpc: and what it should return upon failure? () ?
06:07:55 <quicksilver> bitonic: OK. So I'm telling you that I know the background, because I was part of the conversation, and you were wrong.
06:08:11 <sajith> mysticc: well, there's a build error from process-1.0.1.5...
06:08:12 <quicksilver> bitonic: you are welcome to read that background and make amore informed comment.
06:08:15 <sajith> mysticc: sigh, let me see.
06:08:29 <bitonic> quicksilver: ... wrong where? if you have a stream of bytes and you want to change the endianness, you should reverse the ordering for each word
06:08:41 <quicksilver> bitonic: read the conversation. or shut up.
06:09:03 <bitonic> quicksilver: first, calm down. secondly if you tell me "you're wrong", I'd like to know why
06:09:26 <bitonic> that comment was unrelated to the discussion, it was just related to the endianness bit
06:09:40 <mysticc> sajith: Also check "ghc-pkg list Cabal"
06:09:46 <quicksilver> your comment cannot claim to be unrelated to the conversation, it was part it of.
06:09:58 <quicksilver> we were discussing how ot represent an arbitrary integer as a stream of Word8s
06:10:04 <quicksilver> I said you have to make a choice of endianness to do that
06:10:17 <quicksilver> groups of 4 Word8s (32 bits) are not relevant in this case.
06:10:25 <bitonic> quicksilver: it had no relation to the discussion whatsoever, hpc remark sounded wrong and I told him, that's it.
06:10:31 <quicksilver> an arbitrary Integer is represented in base 256 in precisely one way.
06:10:32 <nand`> bitonic: it was not necessarily wrong; it was just unwarranted in this scenario
06:10:44 <nand`> of course you could encode an Integer as [Word8] by grouping four of them together; but it'd make no sense
06:10:45 <quicksilver> bitonic: hpc was absolutely correct.
06:10:54 <romildo> Is there a function to merge to ordered lists in any library?
06:10:58 <quicksilver> bitonic: in this case, endianness would be precisely a case of reversing the whole list.
06:11:20 <quicksilver> an arbitrary Integer is represented in base 256 in precisely one way, and all that remains to decide is the order you convey those bytes
06:11:27 <quicksilver> most significant byte first or least significant
06:11:31 <quicksilver> and that's a question of reversing the list
06:11:38 <quicksilver> as hpc correctly remarked.
06:12:05 <bitonic> quicksilver: ok, then my mistake is only not knowing that they you were talking about something beyond the usual meaning of endianness. I thought hpc was making a general remark
06:12:30 <bitonic> in any case, I don't understand why you always have to be so harsh when correcting people
06:12:35 <mysticc> hpc gone and you two are arguing :)
06:12:56 <sajith> mysticc: "ghc-pkg list Cabal" know of Cabal-1.14.0
06:12:59 <quicksilver> bitonic: I corrected you several times in a more polite way.
06:13:09 <quicksilver> bitonic: and each time you refused to read back to comprehend the context
06:13:22 <quicksilver> bitonic: and just asked for more clarification.
06:13:23 * mysticc thinks bitonic and quicksilver should get a room :P
06:13:27 <quicksilver> that made me pretty cranky.
06:13:59 <bitonic> quicksilver: I didn't refuse to do anything, I just explained that my comment was related to hpc comment specifically. anyway we can stop here
06:14:01 <mysticc> sajith: Welcome to cabal hell :)
06:14:10 <nand`> @hoogle (a,b) -> (b,a)
06:14:11 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
06:14:11 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:14:11 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:14:29 <mysticc> romildo: What do you want ?
06:14:52 <quicksilver> bitonic: you apparently did not read the context, because you did not alter your approach in any way or ask any qustions about the context.
06:15:04 <quicksilver> bitonic: that's what I meant by "refused to read the context"
06:15:16 <sajith> mysticc: well, thanks, I guess. :)
06:16:40 <mysticc> sajith: I think the best way is to first correct all ghc-pkg check errors ..
06:17:06 <mysticc> sajith: unregister the pkgs which you can not fix .. and then try ..
06:18:39 <quicksilver> nand`: something like this
06:18:40 <tsanhwa> @pl \x -> x
06:18:41 <lambdabot> id
06:18:42 <quicksilver> > map fst . takeWhile (/=(0,0)) $ unfoldr (\q -> let (q',r') = (q `divMod` 256) in Just ((r',q'),q')) 123456789
06:18:44 <lambdabot>   [21,205,91,7]
06:18:46 <Wooga> how do i properly perform optional bindings with Parsec ?
06:18:55 <quicksilver> nand`: I have a feeling there was a way to make that slightly neater but I forget it :)
06:19:19 <tsanhwa> @pl  \ma fab fac = ma >>= \a -> return (fab a, fac a)
06:19:19 <lambdabot> (line 1, column 13):
06:19:20 <lambdabot> unexpected "="
06:19:20 <lambdabot> expecting pattern or "->"
06:19:28 <tsanhwa> @pl  \ma fab fac -> ma >>= \a -> return (fab a, fac a)
06:19:28 <lambdabot> (. (((return .) .) . liftM2 (,))) . (.) . (>>=)
06:19:49 <nand`> quicksilver: unfoldr f where f 0 = Nothing; f n = Just . swap $ n `divMod` 256
06:19:57 <Wooga> i want something like http://paste.pocoo.org/show/587936/ ; only working
06:20:12 <Wooga> or maybe a clue how to glue this combinations properly
06:20:16 <tsanhwa> @pl \fab fac a -> return (fab a, fac a)
06:20:16 <lambdabot> ((return .) .) . liftM2 (,)
06:21:03 <quicksilver> nand`: doesn't that get incorrectly stuck if one digit happens to be 0 ?
06:21:19 <romildo> bitonic, I want to merge two ordered lists. I have defined my own version of merge :: Ord a => [a] -> [a] -> [a], but if one can be found in a library, maybe I would use it instead.
06:21:28 <quicksilver> nand`: e.g. try it on 256*256 + 1, whose expansison should be [1,0,1]
06:21:41 <hpc> @hoogle merge
06:21:41 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
06:21:41 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
06:21:42 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
06:21:44 <nand`> quicksilver: I don't see why it would; the argument to f is num/256; if num/256 = 0 then num=0
06:22:05 <hpc> romildo: i am not sure, but i think maaaaaaaybe you can unsafePerformIO .: mergeIO?
06:22:06 <nand`> or rather; num < 256 due to rounding down
06:22:14 <nand`> in which case that would be the termination
06:22:43 <nand`> quicksilver: returns [1,0,1]
06:22:52 <saml> that's good
06:22:54 <quicksilver> nand`: then I'm probably confused
06:23:04 <quicksilver> nand`: I was sure there was a shortcoming with the simple approach
06:23:10 <quicksilver> nand`: but I'm probably thinking of something else :)
06:23:16 <nand`> maybe :)
06:23:24 <hpc> also, whoever wrote Control.Concurrent really hates do-notation
06:23:33 <hpc> mergeIO ls rs
06:23:33 <hpc>  = newEmptyMVar                >>= \ tail_node ->
06:23:34 <hpc>    newMVar tail_node           >>= \ tail_list ->
06:23:35 <hpc> ...
06:24:02 <nand`> I just took it as a literal unfold representation of the following: f 0 = []; f n = fromIntegral (n `mod` 256) : f (n `div` 256)
06:24:10 <romildo> hpc, I prefer using my own version of merge then using unsafePerformIO .: mergeIO.
06:24:37 <hpc> romildo: i think i would too :P
06:25:17 <hpc> oh wait, mergeIO doesn't do what i think it does
06:25:28 * hpc learns to read types
06:25:35 <mysticc> Wooga: Your optional type is wrong ..
06:25:39 <hpc> yeah, stick with your merge
06:26:03 <nand`> hmm.. fromWord8 [] = 0; fromWord8 (x:xs) = x + fromWord8 xs * 256  -- can this more elegantly be expressed as a fold?
06:26:40 <romildo> hpc, I just thought that merge use is common enough to be in a library.
06:26:52 <hpc> yeah, oh well :P
06:27:20 <Wooga> mysticc: may you show me how to correct it?
06:28:05 <mysticc> Wooga: something like "n <- option "" decimal"
06:28:11 <Clint> last clint
06:28:14 <Clint> dammit
06:28:53 <Wooga> mysticc: thank you!
06:28:59 <nand`> ah
06:29:08 <nand`> fromWord8 = foldr (\a b -> a + 256*b) 0
06:29:14 <nand`> @pl \a b -> a + 256*b
06:29:14 <lambdabot> (. (256 *)) . (+)
06:29:17 <nand`> ew
06:31:07 <bitonic> oh, romildo left. I'm surprised there isn't a merge in Data.List actually
06:31:25 <mysticc> Does map and zip fuse ?
06:32:04 <mysticc> romildo : Data.List.Utils.merge ?
06:32:21 <mysticc> bitonic ^^
06:32:56 <bitonic> mysticc: oh, where's that?
06:32:59 <bitonic> @hayoo Data.List.Utils.merge
06:32:59 <lambdabot> Unknown command, try @list
06:33:02 <bitonic> ehe
06:33:12 <bitonic> MissingH
06:33:12 <mysticc> bitonic http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/Data-List-Utils.html
06:33:31 <nand`> What's a straightforward way to implement f :: Double -> [Word8]
06:33:40 <hpc> nand`: const []
06:33:41 <quicksilver> nand`: haha.
06:33:51 <quicksilver> nand`: now you want IEEE-something?
06:34:07 <bitonic> mysticc: yeah, I'd probably define my own rathar then depending on something
06:34:28 <quicksilver> I wonder if merge should be in Data.Ord really
06:34:29 <nand`> quicksilver: yes; that's something I'd consider straightforward. It just has to be “cross-implementation”, which the IEEE standard does well
06:34:33 <bitonic> since Data.List already has functions for ordered lists, I don't think a `merge' would be too inappropriate
06:34:37 <quicksilver> but it does seem a strange omissions
06:34:41 <quicksilver> nand`: http://hackage.haskell.org/package/data-binary-ieee754-0.4.2.1
06:34:43 <nand`> quicksilver: I'm just trying to avoid something like some library-specific serialization format
06:35:10 <quicksilver> nand`: well ascii decimal expansion is pretty portable :)
06:35:14 <nand`> yeah
06:35:17 <bitonic> nand`: well you can always convert to a string...
06:35:17 <quicksilver> but there is a package for ieee floating point
06:35:19 <nand`> that's something I was considering; using show and read
06:35:23 <bitonic> eh, quicksilver beat me
06:36:02 <nand`> but show and read have too many intricacies; eg. special syntax for “scientific notation”
06:36:09 <fliiipy> How would I go about comparing two strings in Haskell? Recursion?
06:36:21 <Botje> or use the == operator
06:36:21 <bitonic> nand`: also, if you want to stay in Haskell world, you can always use Binary (maybe they've already suggested that)
06:36:28 <nand`> > compare "Hello" "World"
06:36:29 <lambdabot>   LT
06:36:37 <mysticc> fliiipy: ^^
06:36:45 <bitonic> nand`: which is library-specific, but pretty accepted
06:36:45 <fliiipy> Ah ok cheers! =)
06:38:43 <nand`> Data.Binary.IEEE754 looks good; thanks quicksilver
06:38:43 <fliiipy> What about counting the number times a word appears in another string?
06:38:57 <mysticc> quicksilver: I was reading ttfp which you mentioned earlier today .. looks interesting but theory is too abstract for me ..
06:40:06 <quicksilver> mysticc: don't think I mentioned it, although I was here
06:40:22 <quicksilver> think it was bitonic or t7
06:40:23 <mysticc> quicksilver: Ohk .. but you have read it I think ?
06:40:36 <bitonic> mysticc: yeah I probably did, it happens a lot recently
06:41:08 <ppilate> Why is non-deterministic computations modelled by lists? Wouldn't it be more appropriate to use sets?
06:41:11 <mysticc> mysticc: I am still undergrad .. so I think I will pass it for sometime later :)
06:41:18 <bitonic> since afaik it's the best resource to learn intuitionistic TT from a programming perspective. I still hope that someone will pop up and prove me wrong :)
06:41:35 <mysticc> bitonic: ^^
06:41:47 <bitonic> since TTFP doesn't use any of the tools that are popular now.
06:42:03 <mysticc> bitonic: And what are those books ?
06:42:04 * quicksilver hasn't read it
06:42:05 <bitonic> simon thompson actually mentioned that he wanted to make an Agda version of TTFP, but maybe he was joking :P
06:42:10 <mysticc> I mean tools ..
06:42:25 <bitonic> mysticc: Agda & Coq afaik
06:42:33 <quicksilver> ppilate: it's a debatable question, but yes probably sets would be better
06:42:44 <quicksilver> ppilate: lists are used because the haskell language copes better with lists.
06:42:48 <bitonic> well more Coq than Agda, but I got there because of the latter
06:43:41 <bitonic> (and I'm still very confused ehe)
06:44:50 <nand`> > length . filter (== "hello") . words $ "hello world hello" -- fliiipy
06:44:52 <lambdabot>   2
06:45:29 <bitonic> mysticc: to answer your fusion question, they should, but you might want to check reading the core output
06:46:13 <nand`> that's odd; could not find Data.Binary.IEEE754 (I just installed dev-haskell/ieee754-0.7.3)
06:46:38 <bitonic> nand`: stupid question, did you enable the package?
06:46:53 <quicksilver> did you type the right number of es? :)
06:46:54 <nand`> what do you mean, “enable the package”? I've never done this before
06:47:07 <bitonic> actually sorry, that shouldn't matter.
06:47:20 <nand`> bitonic: three E’s, and it doesn't tab complete in ghci
06:47:25 <nand`> err quicksilver
06:47:42 <bitonic> nand`: for some reason I was thinking packages were hidden by default, which is false ofc :)
06:47:51 <nand`> `ghc-pkg list | grep ieee754` is successful
06:47:53 <bitonic> nand`: what does ghc-pkg list say?
06:47:55 <bitonic> ah.
06:48:11 <bitonic> nand`: can you try 'ghci -package ieee754'?
06:48:35 <nand`> bitonic: same thing
06:48:48 <bitonic> nand`: but it successfully loads the package?
06:48:49 <quicksilver> nand`: is your ghci still running from before?
06:48:53 <nand`> quicksilver: no
06:48:58 <quicksilver> hrmph
06:49:01 <nand`> bitonic: yes.
06:49:04 <nand`> I'm thinking maybe the module name changed
06:49:08 <bitonic> nand`: that's odd then. I don't know
06:49:21 <nand`> the hackage entry is outdated
06:49:41 <quicksilver> ghc-package describe
06:49:45 <quicksilver> will show you what modules it exposes
06:49:50 <quicksilver> (exposed-modules: )
06:49:57 <quicksilver> sorry, typo
06:50:00 <quicksilver> ghc-pkg describe
06:50:07 <nand`> Aha, Numeric.IEEE
06:50:28 <nand`> maybe I have the wrong package
06:50:41 <nand`> oh; I have http://hackage.haskell.org/package/ieee754
06:50:43 <nand`> my bad
06:50:49 <quicksilver> yeah, you have... what you said :)
06:50:53 <elliott> Is there a colist comonad?
06:51:00 <mysticc> nand`: http://hackage.haskell.org/package/data-binary-ieee754-0.4.2.1
06:51:02 <elliott> i.e. a comonad that is the dual of the nondeterministic choice list monad?
06:51:07 <elliott> Like store is costate.
06:51:21 * quicksilver waits for edwardk to appear in a puff of cologic
06:51:29 <nand`> `emerge data-binary-ieee754` there we go :)
06:51:29 <bitonic> elliott: what does a Colist look like?
06:52:01 <elliott> bitonic: Beats me.
06:52:08 <elliott> quicksilver: I tried to start that line with his name.
06:52:12 <elliott> But the tab-complete failed. :(
06:53:20 <Wooga> hi, isn't there a way to refer to whole match of Parsec expression?
06:53:29 <mysticc> Whats the best book to read about category theory from fp point of view .. is there any such book ?
06:53:50 <bitonic> mysticc: there's Pierce book, CT for computer scientists or something like that. The title fits, I haven't read it.
06:53:59 <Wooga> like, get all what was hard-coded with stirng "s" and char 's'
06:54:11 <mysticc> bitonic: From where did you read ct then ..
06:54:17 <bitonic> mysticc: I didn't
06:54:27 <imi> hi
06:54:31 <bitonic> mysticc: I read the first 2 chapters of Awodey book and then I died of boredom.
06:54:42 <parcs`> Wooga: what?
06:54:44 <mysticc> @where awodey
06:54:44 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
06:54:58 <bitonic> @google category theory awodey
06:55:00 <lambdabot> http://www.andrew.cmu.edu/~awodey
06:55:00 <lambdabot> Title: Steve Awodey
06:55:04 <imi> can I somehow create a nameless function like f x | condition = something ?
06:55:18 <bitonic> imi: you mean putting guards in lambdas? no
06:55:18 <JesusIsLord> imi: yes
06:55:20 <Wooga> parcs`: look, here i have to manualy re-construct decimal part by consing '.' to it: http://paste.pocoo.org/show/587941/
06:55:23 <bitonic> not syntactically anyways
06:55:33 <imi> yes. guards in lambdas. is it possible?
06:55:35 <quicksilver> imi: you can bury the guard inside a case
06:55:39 <JesusIsLord> (\x -> case () of _ | condition -> something)
06:55:41 <Wooga> parcs`: and then concating two parts - decimal and main
06:55:45 <bitonic> imi: you can use if/case expressions
06:55:45 <quicksilver> but if there is only one guard it might be easier to read an if
06:56:06 <JesusIsLord> or
06:56:16 <bitonic> imi: but you can't have multiple patterns/guards "directly" when using lambdas
06:56:31 <JesusIsLord> assert :: Bool -> a -> a; assert True x = x; assert _ _ = undefined;  (\x -> assert condition ...)
06:56:34 <Wooga> parcs`: can't i just do something like this: http://paste.pocoo.org/show/587946/?
06:56:58 <bitonic> lambda patterns/guard would be a nice language extensions, Erlang and Agda already do that
06:57:04 <quicksilver> Wooga: well, string and char both return the thing they parsed
06:57:16 <mysticc> Somebody should write a book on CT from haskell and fp point of view ....
06:57:17 <hpc> agda's lambda patterns are how they implement case, even
06:57:17 <quicksilver> Wooga: if you have a parser which *doesn't* return the thing they consumed there is no easy way to get it back AFAIK.
06:57:56 <bitonic> yeah if you have lambda patterns you can implement case nicely... if you have mixfix operators :)
06:58:07 <quicksilver> Wooga: you can write (liftM2 (:) (char '.') (many digit))
06:58:18 <quicksilver> Wooga: which will work since char '.' returns '.' if it succeeds
06:58:29 <quicksilver> if that's actually nicer than what you wrote is a matter of taste I think
06:59:19 <quicksilver> or (:) <$> char '.' <*> many digit
06:59:31 <quicksilver> again, questions of taste apply.
06:59:55 <Wooga> quicksilver: thank you!
07:00:47 <bitonic> why aren't lambda patterns lazy by default?
07:00:57 <bitonic> there was probably some reason but I forget
07:01:07 <imi> JesusIsLord: bitonic: quicksilver: actually what I want is this function with lambda: nextIR (b,c) | (b==c)&&(c<a) = (0,b+1)             nextIR (b,c) = (b+1,c)
07:01:09 <bitonic> since you can't have more than one
07:01:09 <JesusIsLord> you mean like (\~(T x) -> ... ) ?
07:01:14 <bitonic> JesusIsLord: yes
07:01:32 <fliiipy> How can we specify when we dont care what an input is?
07:01:33 <hpc> bitonic: consistency, i bet
07:01:34 <JesusIsLord> imi: i would really write that in a named function.
07:01:38 <JesusIsLord> fliiipy: _
07:01:42 <fliiipy> thanks!
07:01:44 <JesusIsLord> fliiipy: e.g. f _ = 37
07:01:56 <imi> ok
07:02:06 <bitonic> hpc: I guess, but I maybe there's some more compelling reason
07:02:20 <imi> but is there a way to write it as a lambda? :)
07:02:31 <saml> yes  \ x -> x
07:02:34 <bitonic> imi: \ x -> case x of ...
07:02:38 <JesusIsLord> imi: sure; (\(b,c) -> if b == c ** c < a then (0,b+1) else (b+1,c))
07:02:43 <JesusIsLord> err, &&
07:02:54 <bitonic> JesusIsLord: he has an n+k pattern in the second case
07:02:54 <akahn> I'm trying to remember the name of a paper. it's something like "freedom from ____ syntax" where ____ is the syntax of C-like languages. can anyone point me in the right direction
07:03:04 <JesusIsLord> bitonic: ??
07:03:08 <Botje> akahn: algol?
07:03:12 <JesusIsLord> akahn: ALGOL ?
07:03:14 <bitonic> JesusIsLord: ah no, sorry.
07:03:19 <bitonic> misread
07:03:55 <JesusIsLord> i guess it's not so bad as a lambda
07:04:08 <quicksilver> I think one 'if' is fine in a lambda
07:04:12 <akahn> Botje, JesusIsLord: do you know the paper I'm thinking of?
07:04:29 <quicksilver> the OCD in me mourns the two totally different syntaxes for the same thing (guards vs if)
07:04:35 <JesusIsLord> akahn: no.
07:05:17 <bitonic> akahn: what you said makes me think of "can programming be liberated from the von Neumann style?", but it's a wild guess
07:05:23 <akahn> yes!!!
07:05:26 <bitonic> since it has to do only marginally with syntax
07:05:36 <merijn> Is there a common name that's used when one of the where-clause functions implements the majority of the functionality of a function? Or do you just name the "helpers"?
07:05:36 <bitonic> akahn: coolio :)
07:06:03 <JesusIsLord> merijn: i've seen "go"
07:06:14 <Clint> i use "go" a lot
07:06:16 <bitonic> `loop' is another popular one
07:06:18 <JesusIsLord> me too
07:06:22 <hpaste_> ClaudiusMaximus pasted “bitarray pbm fun” at http://hpaste.org/67705
07:06:23 <nand`> I use f and f'
07:06:47 <bitonic> but `go' and `loop' are usually used for recursive function that consume something
07:07:06 <bitonic> so I'd use them in that - common - case only
07:07:27 <quicksilver> I general avoid that style unless the purpose is micro-optimisation
07:07:38 <ClaudiusMaximus> i didn't end up using repa, or any existing array library - couldn't figure it out - so it's just a ForeignPtr Word64 that gets bits poked into it
07:07:44 <saml> what's good haskell vs. ocaml web page?
07:07:44 <quicksilver> (you sometimes get better code from GHC if you transform recursive functions that way)
07:08:18 <merijn> quicksilver: In this case I'm doing it because otherwise the function gets uselessly cluttered
07:08:38 <bitonic> merijn: then you probably don't want `go' and `loop', but something more informative
07:08:48 * hackagebot weather-api 0.0 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.0 (PeterGoncharov)
07:08:58 <hpaste_> merijn pasted “helper example” at http://hpaste.org/67706
07:09:05 <merijn> That sorta thing
07:09:17 <ClaudiusMaximus> and then the aggregate operations like BitArray.map and BitArray.zipWith compile the operator to something that works on whole Word64 at a time
07:09:31 <bitonic> merijn: that is a good candidate for `go'.
07:10:09 <teneen> Can someone please explain why these 2 seemingly identical functions act differently?
07:10:12 <hpaste_> teneen pasted “fix” at http://hpaste.org/67708
07:10:56 <quicksilver> merijn: you know you have a typo?
07:11:04 <merijn> quicksilver: Multiple :p
07:11:08 <hpc> teneen: ff is strict in (f,g)
07:11:10 <merijn> I forgot a Just and a prime
07:11:16 <quicksilver> good :)
07:11:20 <hpc> so even when it evaluates (x == 0, then true)
07:11:21 <merijn> That's what I get for pasting before typechecking
07:11:25 <hpc> it still matches on the tuple
07:11:35 <hpc> let ff ~(f,g) = ... -- will work the same
07:11:42 <merijn> It should still be readable I think :p
07:11:57 <sclv> anyone done anything with Reagents in Haskell?
07:12:01 <sclv> http://www.ccs.neu.edu/home/turon/reagents.pdf
07:12:04 <quicksilver> merijn: also lookup' is a prelude function
07:12:10 <quicksilver> merijn: unless I'm missing something
07:12:17 <teneen> hpc: It's clear now. Thanks a lot :)
07:12:44 <quicksilver> merijn: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#v%3Alookup
07:14:12 <merijn> quicksilver: I know, but it's a pain to make changes to it if you have to have sequences with updates so I want it to be in State + [(a,b)] is only temporary until I can move to a better datatype or maybe start using Data.Map
07:15:42 <bitonic> merijn: I'm not sure what you're trying to do, but you can still define that function with the Data.List.lookup: foo k l = (lookup k l, l)
07:16:24 <bitonic> or `foo k = lookup k &&& id' :)
07:16:38 <bitonic> @type \k -> lookup k &&& id
07:16:39 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> (Maybe b, [(a, b)])
07:17:17 <bitonic> now, I didn't understand why you want something like this in the first place
07:18:49 * hackagebot weather-api 0.0.1 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.0.1 (PeterGoncharov)
07:18:55 <aristid> @pl \k -> lookup k &&& id
07:18:55 <lambdabot> (&&& id) . lookup
07:18:57 <quicksilver> merijn: I meant, in particular, that your "auxiliary" function lookup' is just Prelude.lookup
07:19:05 <aristid> lambdabot: that @pl is almost sensible!
07:19:14 <dekuked> hey, why is template haskell so demonized?
07:19:22 <aristid> dekuked: it is?
07:19:27 <dekuked> if that's the right phrasing...
07:19:37 <dekuked> uh, well I was looking into yesod and warp
07:19:38 <quicksilver> merijn: I also share bitonic confusion about your general intention, it's not difficult to chain pure functions in with state actions... you just need to use the write combinators.
07:19:40 <merijn> Yeah, I realised that. But then I was to lazy to change it since I'd already typed it anyway
07:19:56 <quicksilver> *right* combinators.
07:20:08 <quicksilver> homonymic typos are my psychopathology.
07:20:23 <merijn> quicksilver: Yes, but I didn't have those yet
07:20:34 <sclv> dekuked: nobody really dislikes template haskell as such.
07:20:49 <Botje> it's the things people do with it!
07:20:53 <quicksilver> template haskell has some drawbacks, like breaking dependency generation
07:20:57 <sclv> it's just that some people think that it should only be used when it makes a huge difference.
07:21:00 <dekuked> oh sorry
07:21:04 <elliott> sclv: Huh?
07:21:05 <quicksilver> its strict top-to-bottom order
07:21:07 <dekuked> and I meant snap instead of warp
07:21:07 <elliott> No, I dislike Template Haskell.
07:21:12 <elliott> Register me up for that lis.
07:21:12 <elliott> t
07:21:19 <sclv> :-P
07:21:22 <aristid> i think TH makes a fairly obvious difference in yesod
07:21:23 <dekuked> I just remember people said that template haskell was overused in yesod
07:21:36 <dekuked> and it seemed like an awesome macro system to me, so I didn't really get the complaints
07:21:42 <quicksilver> metaprogramming, in general, is bad because it breaks equational reasoning
07:21:50 <sclv> right. the argument is basically that you can do what yesod does with th (and the attendent drawbacks) *without* th with only slightly more work.
07:21:54 <bitonic> dekuked: I think it is, yes. TH for me is one of those "use it if you tried everything else and didn't work" things
07:21:55 <sclv> so the tradeoff seems wrong.
07:22:02 <quicksilver> so you lose something that haskell programmers quite like
07:22:06 <elliott> TH slows compilation down awfully and it's ugly as heck to write.
07:22:07 <aristid> i guess one problem is that those TH mini-languages are not easy to extend with new combinators
07:22:08 <elliott> And the syntax is awful.
07:22:10 <dekuked> quicksilver: what do you think of lisp macros then?
07:22:16 <elliott> And it's not very well typed.
07:22:17 <merijn> quicksilver: It's all reasonably obvious in hindsight. But I haven't written *that* much actual production haskell before. Not everything people here consider obvious is obvious yet :p
07:22:19 <elliott> Yeck.
07:22:21 <quicksilver> dekuked: lisp doesn't have equational reasoning.
07:22:27 <quicksilver> dekuked: so there is nothign to lose :)
07:22:30 <sclv> elliott: do you oppose TH for, e.g., type-level number libraries and the like too :-)
07:22:36 <dekuked> I guess I don't even know what that means...
07:22:36 <bitonic> dekuked: given a TH macros, is not clear what it'll do. To make matter worse, you can stick whatever IO you want in it.
07:22:38 <quicksilver> dekuked: ...and lisp needs macros; lisp without macros is too inexpressive.
07:22:48 <sclv> elliott: or for deriving custom data types?
07:22:52 <bitonic> also, TH code tends to be fairly obscure, given the richness of Haskell's syntax
07:22:54 <aristid> we should all just use copumpkin's agda web framework :D
07:22:55 <hpc> @remember quicksilver lisp doesn't have equational reasoning so there is nothing to lose :)
07:22:55 <lambdabot> I will remember.
07:23:01 <aristid> no TH there :D
07:23:04 <sclv> i mean there are usages where we don't have anyhting better ath the moment.
07:23:23 <bitonic> sclv: like? I really can't think of many things
07:23:24 <elliott> sclv: I'd prefer we just had a nicer mechanism for doing those things.
07:23:27 <quicksilver> sclv: TH is great for automating large chunks of haskell code which coulud be written in principle.
07:23:27 <elliott> I don't know what that would be.
07:23:31 <elliott> But honestly I just avoid TH like the plague.
07:23:31 <sclv> bitonic: i just gave two examples
07:23:37 <elliott> I'll let it derive lenses for me, but only begrudgingly.
07:23:38 <sclv> quicksilver: preicisely.
07:23:39 <quicksilver> sclv: i.e. as a glorified text macros system.
07:23:41 <bitonic> sclv: ops, sorry :)
07:23:49 <elliott> I'd rather use CPP.
07:23:51 <elliott> At least it's fast.
07:24:12 <aristid> elliott: have you ever done any metaprogramming in CPP? i have. don't recommend it :P
07:24:12 <quicksilver> TH for the kind of thing sclv is talking about isn't slow, I don't think?
07:24:16 <bitonic> sclv: you could argue that the case for deriving custom data types is pretty narrow. Most of the times is just a matter of having a concise syntax to do so
07:24:33 <sclv> actually i think metaocaml-style systems are quite principled. th is a bit of everything though.
07:24:35 <elliott> aristid: Yes.
07:24:50 <quicksilver> bitonic, sclv: with a sufficiently good 'generics' library you can derive custom classes.
07:24:50 <elliott> aristid: Not quite as far as the chaos-pp stuff, though.
07:25:01 <aristid> elliott: some people came up with hilarious hacks to get around the recursion restriction
07:25:04 <quicksilver> the one in the latest GHC is a big step forward in that respect.
07:25:08 <sclv> quicksilver: right, and we're moving towards that now. but in the past it was much less so the case.
07:25:21 <sclv> hah, beat me to it.
07:25:24 <bitonic> quicksilver: I'm talking about generating *datatypes*, which is what  yesod does heavily
07:25:42 <quicksilver> bitonic: yeah. that's rather different
07:25:44 <bitonic> for what concerns classes instances, I agree
07:25:57 <sclv> I also really like quasiquoting for what its supposed to do -- embedding entirely different syntaxes to entirely different languages.
07:26:27 <quicksilver> I'd like somethiing a bit more staged.
07:26:32 <bitonic> sclv: still, TH is a strange intersection between all these things.
07:26:35 <quicksilver> and a bit more typed.
07:26:40 <quicksilver> in other words, a bit more like a meta-ml
07:26:45 <quicksilver> although not necessarily exactly the same.
07:27:13 <aristid> meta-ml should be called m2l :P
07:27:25 <quicksilver> the speed problem might be alleviated if you could only re-run the TH parts when those parts had changed, which is a bit tricky under the current system I think?
07:27:29 <elliott> aristid: Yeah, chaos-pp does such tricks.
07:27:35 <sclv> as i recall, th is moving in both directions -- one that's more metaml ish, and one that's more lispish do-whatever.
07:27:37 <elliott> Have you seen order-pp? It's a functional language. With lambdas. In cpp.
07:28:04 <sclv> but after spj posted his plan, i don't know how much work has been done on it.
07:28:45 <quicksilver> I'd also like something less ugly but I'm really not sure how to do that
07:28:48 <quicksilver> syntax is hard.
07:29:05 <sclv> the worst part of th is that we add new syntax to the language, but it takes a while for th to catch up.
07:29:06 <aristid> elliott: i've only used boost.preprocessor
07:29:11 <quicksilver> dekuked: actually the thing that bother me most about lisp macros is that, when reading code, you can't tell which is which.
07:29:12 <sclv> its a red-headed stepchild.
07:29:15 <aristid> elliott: i assume order-pp is more ambitious
07:29:41 <quicksilver> dekuked: in (funky-trick a b c) it would be nice to know if funky-trick was a function, whose arguments will be evaluated, or a special form, where anything might happen to the arguments.
07:29:55 <quicksilver> (without having to read the docs for funky-trick)
07:29:57 <bitonic> tbh I think that having a more limited way to simply embed different syntaxes in Haskell code would cover a good percentage of the practical uses that I've seen of TH
07:30:10 <elliott> aristid: chaos-pp is a derivative of boost preprocessor, right.
07:30:18 <elliott> And order-pp is a related project.
07:30:19 <quicksilver> bitonic: isn't that what QQ was supposed to be for, or is that not what you meant?
07:30:34 <sclv> qq does that but you still have to mess around with th directly.
07:30:51 <bitonic> quicksilver: well yes, but QQ are tied to TH, I'd like a more specialised and separated environment
07:31:11 <sclv> a direct mechanism for parse and produce data structure and then lift and splice all in one swoop would be very elegant.
07:31:35 <aristid> elliott: i don't understand how you can postulate that CPP is better than TH, then. you _know_ how evil CPP is :D
07:31:43 <sclv> so you just plug in a function from, e.g. String -> Either Error a
07:31:49 <bitonic> quicksilver: my principal worry is that with TH compiling haskell source code can do arbitrary IO
07:31:52 <sclv> and everything else is taken care of.
07:32:01 <elliott> aristid: CPP is evil. TH is just a pain.
07:32:02 <sclv> but then you lose all the neat bits of qq w/r/t pattern matching.
07:32:02 <bitonic> quicksilver: that just doesn't sound right
07:32:06 <elliott> Why go for the lesser evil?
07:32:16 <sclv> not that I've ever done quasiquoters for the left hand side, nor seen anyone else put them to serious use :-)
07:32:32 <bitonic> sclv: yeah, exactly
07:32:36 <aristid> elliott: uh
07:32:52 <aristid> elliott: i always go for the lesser evil :)
07:33:54 <bitonic> elliott: well CPP and TH have incredibly different feature sets, you wouldn't be able to do most things people do with TH with CPP
07:34:10 <aristid> bitonic: are you sure? :)
07:34:51 <aristid> bitonic: you can do things with CPP that you don't want to know you can do
07:34:57 <bitonic> aristid: the most heavy user of TH I've seen is yesod, and you wouldn't be able to do what they do with CPP
07:35:11 <bitonic> I don't know if you technically *can* but it'd be insane.
07:35:12 <aristid> are you sure?
07:35:16 <aristid> yes.
07:35:20 <aristid> it would be insane
07:35:35 <elliott> You could.
07:35:40 <elliott> Well, most of it, anyway.
07:35:49 <bitonic> yes but you wouldn't.
07:36:00 <bitonic> wait. how do you write a parser in CPP?
07:36:18 <bitonic> actually I don't even want to know, but hopefully you get my point :P
07:36:29 <aristid> :D
07:36:50 <aristid> bitonic: i abused CPP in the past. i like to think that was one of the reasons why i started going to Haskell.
07:37:03 <bitonic> aristid: you wrote parsers in CPP?
07:37:13 <Botje> bitonic: and they *liked* it!
07:37:16 <aristid> Botje: not parsers, no
07:37:27 <bitonic> also, CPP is a pure language. TH isn't
07:37:30 <aristid> Botje: i wrote a DSL in CPP, which is kinda similar i guess
07:37:37 <bitonic> well, the Q monad isn't
07:38:42 <bitonic> so you definitely can't read files at compile time like yesod does
07:38:47 <bitonic> (with CPP)
07:39:05 <quicksilver> you sort-of can
07:39:28 <aristid> bitonic: beware the evilness: https://github.com/Flusspferd/flusspferd/blob/master/plugins/xml/node.hpp#L41
07:39:33 <quicksilver> #define BLAH MAGIC; #include 'file'; #define BLAH DIFFERENT_MAGIC; #include 'file'
07:39:45 <quicksilver> that kind of trickery is used in some quite neat CPP idioms
07:39:58 <bitonic> quicksilver: oh right, damn.
07:40:02 <quicksilver> read the same file multiple times with different macro defns to set up multiple related things.
07:40:20 <bitonic> but can you *delete* files? ehe
07:40:32 <quicksilver> i dont think so :)
07:41:02 <Botje> just make them not typecheck.
07:41:17 <aristid> bitonic: and this is how CPP metaprogramming code itself looks like: https://github.com/Flusspferd/flusspferd/blob/master/include/flusspferd/class_description.hpp#L40
07:41:30 <bitonic> imagine, a small TH snippet that silently installs a keylogger. the first virus with Haskell as a carrier
07:41:58 <fliiipy> How would I take "helloWorld" and make it ["He", "el", "ll" ... "ld"]?
07:42:07 <bitonic> aristid: what the hell is that
07:42:16 <aristid> bitonic: that's the point.
07:42:25 <Lemmih> fliiipy: Data.List.Split.chunk 2 "helloWorld"
07:42:35 <fliiipy> thanks.
07:42:40 <mauke> Lemmih: "He", "el"
07:42:43 <quicksilver> aristid: so, the short story is you were writing a javascript/C++ bridge and the effort broke your mind, haskell was the only salve?
07:42:45 <Lemmih> Oh :(
07:42:57 <mauke> > ap zip tail "helloWorld"
07:42:58 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o'),('o','W'),('W','o'),('o','r'),('r'...
07:43:02 <quicksilver> > map (take 2) . tails @ "helloWorld"
07:43:03 <mauke> hmm, not quite
07:43:03 <lambdabot>   Pattern syntax in expression context: tails@"helloWorld"
07:43:07 <quicksilver> > map (take 2) . tails $ "helloWorld"
07:43:09 <lambdabot>   ["he","el","ll","lo","oW","Wo","or","rl","ld","d",""]
07:43:15 <mauke> needs "He", not "he"
07:43:23 <fliiipy> That works. Cheers!
07:43:35 <aristid> quicksilver: no, but i recognised that my thinking "you can do anything you want in C++, you just have to use template metaprogramming and preprocessor metaprogramming to extend the language" to be misguided?
07:43:53 <quicksilver> aristid: :)
07:44:17 <quicksilver> aristid: C++ plus template metaprogramming plus preprocess metaprogramming is a very powerful thing for some applications.
07:44:36 <Wooga> whoa
07:44:40 <quicksilver> aristid: for example, if you want to produce humungous and mind-blowing error-messages, it's great :)
07:44:41 <aristid> quicksilver: yes, but also evil
07:44:42 <mauke> shoot all the feets!
07:44:48 <aristid> quicksilver: haha
07:48:06 <mauke> http://codepad.org/K4NlIk3c
07:50:57 <frigga1> > withSystemRandom . asGenIO $ genContVar (normalDistr 100 1)
07:50:57 <lambdabot>   Not in scope: `withSystemRandom'Not in scope: `asGenIO'Not in scope: `genCo...
07:51:20 <frigga1> Anyone know why the above line returns negative numbers?
07:51:47 <saml> mauke, what is that?
07:52:05 <mauke> saml: fibonacci numbers, at least in g++
07:52:25 <saml> doesn't output anything
07:52:41 <mauke> impossible
07:53:13 <bitonic> frigga1: is 100 the mean and 1 the standard deviation?
07:53:14 <saml> oh yah it does
07:53:22 <saml> it gives me lots of warnings
07:53:35 <quicksilver> negative numbers should be possible but pretty unlikely
07:53:38 <bitonic> yeah
07:53:47 <quicksilver> 100 SDs under the mean is very rare indeed
07:53:47 <bitonic> like *very* unlikely :)
07:54:05 <bitonic> frigga1: are you getting them consistently?
07:54:18 <Botje> one in a million events happen nine times out of ten.
07:54:39 <imi> is there a filter-variant which stops rearching when found the first one not matching (so filter (<10) [1..] would terminate)
07:54:49 <c_wraith> takeWhile
07:55:07 <imi> thanks :)
07:56:34 <frigga1> bitonic: Yes, 100 is the mean and 1 is the standard deviation.
07:56:44 <frigga1> bitonic: And yes, I'm getting them consistently.
07:57:35 <frigga1> Every single time
07:58:18 <bitonic> frigga1: I don't know where those function are from, but if they do what they sound like they should, something is wrong.
07:58:40 <quicksilver> I think they're from : http://hackage.haskell.org/package/statistics-0.10.1.0
07:58:45 <quicksilver> and something sounds busted to me :(
08:03:04 <frigga1> Aha: https://github.com/bos/statistics/issues/30
08:03:32 <ppilate> Hi! I am trying to write a simple applicative parser, however, my Applicative instance looks like crap: http://hpaste.org/67711
08:03:50 <ppilate> Is there anyway to make it look better? Maybe use the Functor instance?
08:03:55 <bitonic> frigga1: woah, I'm surprised that such a big bug made it in a bos package :P
08:04:07 <frigga1> Yeah, me too
08:04:30 <frigga1> Just goes to show...we're all human. :)
08:04:55 <merijn> Can I still use the old State monad? Rather than the StateT based one?
08:05:04 <statusfailed> Does a function with this type signature exist? hoogle says no, but it seems useful to me:  state' (a -> s -> a) -> (a -> s -> s) -> a -> State s a
08:05:11 <Mathnerd314> @unmtl StateT String Maybe a
08:05:12 <lambdabot> String -> Maybe (a, String)
08:05:14 <statusfailed> basically- one function to compute output, one to compute state transition
08:05:24 <bitonic> merijn: you mean a plain `newtype State = State (s -> (a, s))', and not the type synonym?
08:06:09 <statusfailed> woah, double state monad question :D
08:06:10 <Saulzar> ppilate, I'd start by using the maybe monad rather than matching against Nothing directly
08:06:16 <statusfailed> merijn: what's wrong with just the "state" function?
08:06:21 <merijn> bitonic: I dunno what I mean. I mean the one that just lets me string "s -> (a, s)" functions together without complaining that lord knows what isn't an instance of monad
08:07:01 <ppilate> Saulzar: using isNothing/isJust?
08:07:02 <bitonic> merijn: no you can't just use those functions like that, because the functions are going to be wrapped in a newtype, since you need that to define a monad instance
08:07:13 <merijn> oh, hmm. Actually I think I know what my problem is
08:07:27 <bitonic> @hoogle (s -> (a, s)) -> State a
08:07:27 <lambdabot> Did you mean: (s -> (a, s)) -> State a s
08:07:27 <lambdabot> No results found
08:07:39 <bitonic> @hoogle (s -> (a, s)) -> State a s
08:07:39 <lambdabot> Control.Monad.Trans.State.Lazy state :: (s -> (a, s)) -> State s a
08:07:40 <lambdabot> Control.Monad.Trans.State.Strict state :: (s -> (a, s)) -> State s a
08:07:40 <lambdabot> Control.Monad.State.Lazy state :: (s -> (a, s)) -> State s a
08:07:46 <quicksilver> merijn: that one never existed.
08:07:59 <quicksilver> merijn: plain "s -> (a,s)" functions have never been a monad instance.
08:08:02 <merijn> quicksilver: Yeah, I figured out my problem
08:08:04 <mauke> copumpkin: this is where an official haskell/* cloak would come in handy
08:08:13 <Saulzar> ppilate, Using >>=     e.g...
08:08:17 <merijn> quicksilver: confusing error message + wrong code problem :p
08:08:21 <quicksilver> they can't be, due to boring facts about haskell type constructors
08:08:22 <quicksilver> :)
08:08:55 <copumpkin> mauke: yep! apparently they're working on it :)
08:09:12 <bitonic> life would be a lot more fun with unrestricted type level functions.
08:09:25 <hpaste_> Twey annotated “Applicative 'parser'” with “Do-Notation” at http://hpaste.org/67711#a67712
08:09:54 <Twey> ppilate: ^ I think using the Monad instance of Maybe is probably the clearest way to express that.
08:10:06 <ppilate> Saulzar: ah, I haven't got to Monads yet, so I am not feeling confident about this
08:10:32 <ppilate> I found these lectures notes online and just trying to do the excercise:http://www.cis.upenn.edu/~cis194/static/hw10.pdf
08:10:40 <ppilate> exercise*
08:10:56 <Saulzar> ppilate, Hm - well the Maybe monad is pretty simple, basically it just does some plumbing that if any value is Nothing the whole computation is Nothing
08:11:04 <ppilate> http://www.cis.upenn.edu/~cis194/lectures.html monads comes after the applicative functors so idk
08:11:07 <Saulzar> I annotated your hpaste
08:11:20 <ppilate> oh thanks nice
08:11:22 <fliiipy> Is there a way to count the index of a recursive function without passing an int?
08:11:23 <ppilate> thank you Twey, Saulzar
08:11:27 <hpaste_> Oliver annotated “Applicative 'parser'” with “Applicative 'parser' (annotation)” at http://hpaste.org/67711#a67713
08:12:05 <Saulzar> Twey beat me to it :)
08:12:15 <quicksilver> fliiipy: no.
08:12:20 <fliiipy> ok. thanks.
08:12:23 <ppilate> So, basically, the whole chain of (>>=) fails if at some step parser returns Nothing, right?
08:12:25 <quicksilver> well, not a general one.
08:12:29 <Saulzar> Yeah
08:12:34 <Mathnerd314> @src Maybe (>>=)
08:12:34 <lambdabot> (Just x) >>= k      = k x
08:12:35 <lambdabot> Nothing  >>= _      = Nothing
08:12:47 <quicksilver> some specific techniques have obvious ways to splice some ints along
08:12:55 <quicksilver> (zip [1..]) is a fairly common idiom
08:13:02 <quicksilver> > zip [1..] "hello"
08:13:02 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
08:13:21 <fliiipy> Ah ok thanks.
08:14:02 <quicksilver> and since all linear recursion is, really, a long a list you can normally do that
08:14:19 <quicksilver> for other shapes of recursion (like depth-first trees) it's not quite as simple
08:14:47 <fliiipy> But wont it apply the zip every time the recusive function runs?
08:16:04 <hpaste_> Twey annotated “Applicative 'parser'” with “No Lambda” at http://hpaste.org/67711#a67714
08:16:40 <Twey> ppilate: Note that the ‘pure’ I gave requires TupleSections.
08:17:07 <Twey> ppilate: Otherwise you can write it as Parser $ Just . (,) a
08:18:17 <sp> Hi
08:18:23 <parcs`> > comparing length "\_->1" "const 1"
08:18:24 <lambdabot>   <no location info>:
08:18:24 <lambdabot>      lexical error in string/character literal at chara...
08:18:35 <sp> "Hi"
08:18:41 <fmap> fliiipy: zip is used instead of explicit recursion
08:19:18 <quicksilver> fliiipy: or alonside whichever recursion you wre planning on doing
08:19:26 <quicksilver> 'threaded through' the list it operates on
08:19:41 <Saulzar> Twey: That much pointfree is a bit scary..
08:21:38 <fliiipy> fmap: Ah ok.
08:22:07 <Twey> Saulzar: I did say do-notation was probably clearest.  :þ
08:22:50 <c_wraith> hmm.  I've never checked to see how good @undo actually is
08:23:27 <rwbarton> combine with @pl for "best" results
08:23:32 <c_wraith> @undo do { Right x <- m ; return x }
08:23:32 <lambdabot> m >>= \ a -> case a of { Right x -> return x; _ -> fail ""}
08:23:40 <hpaste_> Twey annotated “Applicative 'parser'” with “Do-Notation and A Little Point-Free” at http://hpaste.org/67711#a67715
08:23:50 <c_wraith> that's pretty close
08:23:51 <Twey> Oh!  I'm an idiot anyway
08:23:59 <c_wraith> It just skipped the fail message
08:24:21 <hpaste_> Twey annotated “Applicative 'parser'” with “Do-Notation and A Little Point-Free (fixed)” at http://hpaste.org/67711#a67716
08:25:44 <merijn> Is there an example of the State monad anywhere? Because apparently I'm just not smart enough to figure out WTF the damn thing expects from me...
08:26:10 <singpolyma> I want to put all my types in one module/package, and then have two different packages, each depending on that one, which define an instance for that type (in this case one will be a Binary instance and one a Serialize instance).  Is there any way to do this that doesn't invoke the Orphan Instance warning / problem ?
08:26:18 <bitonic> merijn: this is decent: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
08:26:36 <merijn> bitonic: Yeah, that one was completely unhelpful
08:26:47 <merijn> All I get is compiler errors complaining about missing MonadState instances
08:26:59 <mauke> merijn: what are you doing?
08:27:06 <bitonic> merijn: the mtl type classes are not even mentioned there
08:27:23 <bitonic> you shouldn't touch MonadState if you're trying to understand the State monad on its own
08:27:35 <bitonic> the best thing is defining it yourself and play with it
08:27:44 <quicksilver> but that wikibook does define things named 'get' and 'set'
08:27:47 <quicksilver> which are the names from the typeclass
08:27:53 <quicksilver> so if you try to copy and paste that code
08:27:57 <quicksilver> you might get that kind of error
08:28:02 <quicksilver> (if MonadState is in scope)
08:28:25 <quicksilver> that wikibook is written more along the 'define it yourself and play with it' line
08:28:34 <fliiipy> How do I use tails in winhugs?
08:29:13 <aristid> @hoogle tails
08:29:13 <lambdabot> Data.List tails :: [a] -> [[a]]
08:29:13 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
08:29:13 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
08:29:21 <bitonic> fliiipy: if it's not in scope, try loading the Data.List module, I forget how you do that in Hugs, but :help should help.
08:29:22 <Eduard_Munteanu> > tails [1,2,3,4]
08:29:23 <aristid> fliiipy: is it not available in Data.List there?
08:29:23 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
08:29:44 <merijn> mauke: All I want to do is have a bunch of functions update some state using get/put. But how the hell I get there is completely opaque as everything related to State seems to use the same names but differing types for them
08:29:50 <hpaste_> Twey annotated “Applicative 'parser'” with “No Lambda (fixed & neater)” at http://hpaste.org/67711#a67717
08:29:55 <fliiipy> Im not sure. How do I see if it is?
08:29:59 <Twey> That's much nicer
08:30:05 <mauke> merijn: what do you mean?
08:30:08 <Eduard_Munteanu> Hugs is quite old, mind. Dunno if that can be an issue there, but you should probably avoid it.
08:30:21 <merijn> It's completely opaque to me what is already defined in libraries and what I have to define for myself
08:30:27 <mauke> ah
08:30:36 <fliiipy> Ok. =) thanks.
08:30:38 <Philonous> Is there a way to distinguish between synchronous and asynchronous exceptions when catching them?
08:30:38 <bitonic> fliiipy: well, type `tails' into the prompt and press enter, and see if it says "out of scope", or something along those lines.
08:30:41 <aristid> fliiipy: do you use hugs because it's required in a course, or because you stumbled upon it?
08:30:53 <fliiipy> It says undefined variable tails
08:30:56 <merijn> Everyone uses all the relevant names without specifying where they're from and which I can just use and which I have to do myself
08:31:04 <fliiipy> Its required as a course.
08:31:06 <bitonic> fliiipy: there's nothing wrong with Hugs if you want to learn Haskell, but you probably want to move to GHC if you want to write real applications
08:31:08 <merijn> The result is that I'm completely bewilderd trying to do something that should be trivial
08:31:30 <quicksilver> merijn: get/set are from MonadState. That is the only place they have ever come from. That is the only place they ever *should* come from.
08:31:39 <merijn> I can't even define manage to get "id" working (i.e. just return the input state directly)
08:31:49 <quicksilver> merijn: it is unfortunate that an (otherwise good) tutorial reuses the same names.
08:31:54 <merijn> s/define manage/manage
08:32:01 <bitonic> fliiipy: try `:load Data.List'
08:32:09 <mauke> quicksilver: did you mean: get/put
08:32:17 <bitonic> or maybe :import Data.List? who knows
08:32:26 <fliiipy> Ah ok thanks.
08:32:28 <quicksilver> mauke: I did :)
08:32:34 <mauke> merijn: id isn't a valid State value thingy
08:32:38 <mauke> merijn: are you thinking of Reader?
08:33:02 <merijn> mauke: I don't know what the fuck I'm thinking beyond completely bewilderment
08:33:15 <fliiipy> Can I define that in my file so it automatically loads it?
08:33:32 <Eduard_Munteanu> fliiipy: import Data.List
08:33:33 <bitonic> fliiipy: you can write `import Data.List' in your file
08:33:33 <mauke> merijn: ok, then where is 'id' coming from?
08:33:34 <merijn> All I know is that I have some functions of type "s -> s" and some stuff "s -> (a, s)" that I want to conveniently combine
08:33:43 <fliiipy> Thanks bitonic.
08:33:54 <bitonic> merijn: you can't, quicksilver and I already told you why. You'll have to manually lift them into State
08:34:09 <bitonic> fliiipy: btw, may I ask which uni are you in?
08:34:11 <merijn> bitonic: I know, but how the fuck do I do that?
08:34:30 <mauke> :t State
08:34:31 <lambdabot> Not in scope: data constructor `State'
08:34:35 <merijn> I just want a list of "you need to instantiate/lift this stuff"
08:34:36 <c_wraith> :t state
08:34:37 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:34:41 <mauke> ah
08:34:44 <bitonic> merijn: it depends how you constructed the State datatype. if the data constructor is called `State', then `State f' will do
08:34:44 <quicksilver> :t modify
08:34:45 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:35:07 <mauke> wait, what
08:35:17 <mauke> bitonic: State is a library thing, not user defined
08:35:44 <bitonic> mauke: I think he's trying to define State himself, since he was reading that tutorial
08:35:51 <merijn> mauke: This interaction between you and bitonic is pretty much identical to the interaction between varying tutorials
08:35:54 <merijn> bitonic: No
08:35:56 <mauke> bitonic: that seems unlikely
08:36:19 <bitonic> merijn: in that case, go back and read that so you understand how State works first :)
08:36:39 <bitonic> and use the State from transformers anyways, which is free of type classes
08:36:46 <Eduard_Munteanu> If you're defining a bunch of State s a functions, you could just reuse the existing interface.
08:37:03 <bitonic> well, they're all the same State really. But transformers doesn't have the typeclasses
08:37:31 <bitonic> merijn: so, `import Control.Monad.Trans.State' instead of Control.Monad.State. That will make error messages clearer
08:37:34 <merijn> No offense, but you people are making me want to through my laptop through a window and curse like a sailor
08:37:49 <bitonic> but I strongly suggest to understand how State, and monads in general, work first
08:37:53 <merijn> And possibly murder kittens
08:38:01 <merijn> bitonic: I already know how it works in general
08:38:04 <bitonic> don't murder kittens please.
08:38:19 <merijn> Which is why it's so fucking infuriating that its so opaque how to just get it to working
08:38:45 <bitonic> merijn: it's infuriating because you don't know what's going on. So take the typeclasses out of the question and import what I told you first
08:40:39 <merijn> See, all I wanted to know is "import Control.Monad.Trans.State; type Foo = State Whatever"
08:40:51 <merijn> Which seems to work
08:41:07 <mauke> then why didn't you just ask that?
08:41:27 <merijn> mauke: Because I didn't know that that was what you need to do?
08:41:40 <mauke> well, you don't *need* to do that
08:42:21 <bitonic> merijn: the most important thing is that you understand everything that you're using. specifically, I don't think you understood the type sig of the `get' and `set' you were using
08:42:34 <mauke> there is no set
08:42:55 <merijn> All the tutorials discuss how to implement state, how it works, etc. Nothing tells you "these simple steps let you use State for your own state datatype"
08:43:20 <bitonic> mauke: sorry, put
08:43:22 <aristid> :t runState
08:43:23 <lambdabot> forall s a. State s a -> s -> (a, s)
08:43:34 <merijn> :t put
08:43:36 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
08:43:51 <merijn> Seems pretty obvious to me
08:43:51 <bitonic> merijn: if you actually understood what State does it'd be quite natural, I can understand that mtl typeclasses can be confusing on their own
08:43:52 * hackagebot yesod-platform 1.0.3.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.3.4 (MichaelSnoyman)
08:43:56 <fryguybob> @instances MonadState
08:43:57 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWST r w s m), s (ReaderT r m), s (StateT s m), s (WriterT w m)
08:44:02 <quicksilver> merijn: well, I must admit I don't know what you mean by "your own state datatype"
08:44:17 <quicksilver> if you mean the type of state being stored, you don't need to take any steps at all
08:44:22 <quicksilver> you just use that type...
08:44:23 <bitonic> quicksilver: I guessed he means "what you put in the state"
08:44:24 <quicksilver> (State Foo blah)
08:44:25 <bitonic> yeah
08:44:26 <Eduard_Munteanu> You could write a newtype wrapper and use generalized newtype deriving to quickly get a State-like monad from it.
08:44:48 <Eduard_Munteanu> (if you want it more opaque than a type synonym)
08:45:08 <merijn> quicksilver: I meant "the type of your state"
08:45:17 * quicksilver nods
08:45:27 <quicksilver> well I'd be interested to know what you think the answer is :)
08:45:38 <quicksilver> because it seems to me there are no specific steps, you just use it.
08:45:47 <merijn> quicksilver: Yes, but I didn't know how
08:45:53 <quicksilver> do { x <- get; return (f x) }
08:45:56 <merijn> Yeah
08:46:03 <quicksilver> ^^ this works for any type x which happens to be the argument type to f
08:46:11 <merijn> That part I knew, I just got completely confused by the various tutorials
08:46:20 <quicksilver> tutorials can do that
08:46:32 <quicksilver> especially when they don't make it clear which library they are using
08:46:43 <quicksilver> or if (as with the wikibook) they're using their own first-principles data types
08:46:53 <quicksilver> which just happen to have some of the same names as the library ones.
08:47:53 <merijn> I mean no one says "you need Monad.Trans.State instead of Monad.State" and use "State MyState Result" as type
08:48:10 <merijn> The end resulting is confusing typeclasses errors and extreme confusion
08:48:32 <bitonic> merijn: maybe that tutorial could be augmented with a section with directions to the libraries yes
08:48:48 <mauke> merijn: but you don't need Monad.Trans.State
08:48:55 <quicksilver> merijn: well that's not true.
08:49:02 <mauke> and State MyState Result is obvious
08:49:12 <quicksilver> Control.Monad.State should define a type called 'State' for which 'State MyState Result' is perfectly valid
08:49:26 <quicksilver> there are reasons to prefer the transformers one
08:49:41 <quicksilver> bitonic was trying to steer you away from typeclass confusion
08:49:45 <quicksilver> but the mtl one should work also.
08:50:11 <bitonic> yeah, from what you say it looks like everything would be perfectly valid in both cases
08:50:29 <bitonic> but still, I think that as your first application using State, you should first try to write it with a state you defined
08:50:32 <quicksilver> mtl and transformers are very similar.
08:50:33 <bitonic> where everything is in plain sight
08:50:36 <merijn> Maybe I typo'ed something initially
08:50:40 <merijn> anyhoo
08:50:47 <Eduard_Munteanu> You could do something like    newtype MyState a = MS (State Bool a) deriving (Monad, MonadState Bool)    if you want a newtype
08:50:52 <bitonic> mtl is built on top of transformers, so...
08:50:59 <bitonic> the datatypes are the same
08:51:04 <bitonic> it's just typeclasses on top
08:51:17 <ppilate> http://hpaste.org/67719 is this the correct way to use identation? (in parseSExpr)
08:51:44 <Eduard_Munteanu> s/Bool/YourStateType/
08:52:08 <quicksilver> ppilate: that's reasonable. It doesn't matter how you indent parseSExpr since it isn't using a layout-sensitive keyword (do/case/let)
08:52:28 <quicksilver> ppilate: apart from, each continuation line must be indented at least one space otherwise it starts a new definiotin.
08:52:30 <ppilate> yeah, but it looks a little bit weird
08:52:50 <quicksilver> I tend to put combinators like <|> at the start of lines, not the end
08:52:56 <quicksilver> but that's just taste
08:53:36 <ppilate> quicksilver: like this? http://pastebin.com/rgvmU3HE
08:53:41 <mauke> The paste rgvmU3HE has been copied to http://hpaste.org/67720
08:53:52 * hackagebot hexpat 0.20.1 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.1 (StephenBlackheath)
08:55:06 <quicksilver> ppilate: well in general yes. In this specific case no because that suggests (to my eyes) that <|> and *> have equal precedence.
08:55:27 <ppilate> ah
08:55:30 <ppilate> indeed
08:55:34 <quicksilver> In fact, since I personaly wouldn't remember the relative precedence of *> and <* to <|> I'd use parentheses to disambiguate
08:56:09 <ppilate> o
08:56:16 <ppilate> yeah, i actually forgot the parens :S
08:56:17 <ppilate> thanks
08:56:36 <quicksilver> perhaps like this : http://hpaste.org/67720
08:56:54 <ppilate> that looks nice
09:08:53 * hackagebot hexpat-pickle 0.6 - XML picklers based on hexpat, source-code-similar to those of the HXT package  http://hackage.haskell.org/package/hexpat-pickle-0.6 (StephenBlackheath)
09:09:01 <ppilate> fmap == return . bind, right?
09:09:10 <ppilate> erm, bind . return
09:11:52 <rwbarton> @type (>>=) . return
09:11:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> (a -> m b) -> m b
09:12:05 <quicksilver> ppilate: fmap f x = x >>= return . f
09:12:35 <quicksilver> ppilate: which is not entirely unlike what you said but, not actually what you said.
09:12:49 <ppilate> hm
09:12:57 <rwbarton> @pl \f x -> x >>= return . f
09:12:57 <lambdabot> fmap
09:13:02 <rwbarton> curse you lambdabot
09:13:07 <rwbarton> @pl \f x -> x >>>= return' . f
09:13:07 <lambdabot> (line 1, column 24):
09:13:07 <lambdabot> unexpected "."
09:13:07 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
09:13:07 <lambdabot> ambiguous use of a right associative operator
09:13:12 <rwbarton> @pl \f x -> x >>>= return1 . f
09:13:13 <lambdabot> (line 1, column 24):
09:13:13 <lambdabot> unexpected "."
09:13:13 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
09:13:13 <lambdabot> ambiguous use of a right associative operator
09:13:27 <quicksilver> @pl \f x -> x >>= honestly_not_return . f
09:13:27 <lambdabot> (=<<) . (honestly_not_return .)
09:13:27 <rwbarton> sigh
09:13:51 <quicksilver> so, fmap is (flip bind) . (return .)
09:13:54 <Eduard_Munteanu> @pl \f x -> bind x (ret . f)
09:13:54 <lambdabot> flip bind . (ret .)
09:14:01 <quicksilver> if you take bind to be >>= at least.
09:14:11 <rwbarton> @pl \f x -> x >>>= (return1 . f)
09:14:11 <lambdabot> flip (>>>=) . (return1 .)
09:14:21 <kallisti> quicksilver: why so pointfree?
09:14:56 <quicksilver> kallisti: well because that was the question ppilate asked :)
09:14:56 <rwbarton> kallisti: you entered after < ppilate> fmap == return . bind, right? < ppilate> erm, bind . return
09:14:57 <womb> > 7*7
09:14:58 <lambdabot>   49
09:15:06 <womb> > ord 'i'
09:15:07 <lambdabot>   105
09:15:12 <mauke> womb: why do you keep doing that?
09:15:16 <kallisti> oh context, right.
09:15:43 <quicksilver> mauke: he's trying to evaluate the consistency of arithmetic by a longitudinal study?
09:15:54 <womb> mauke: nobody knows, but i'm a cat. I'm checking if 7 * 7 === 49
09:16:09 <womb> mauke: one day i will become type checker
09:16:19 <quicksilver> all the best type checkers used to be cats.
09:16:24 * Clint squints.
09:16:49 <jfischoff>  I've been reading teh wrong books
09:16:54 <mauke> womb: it looks like spam
09:17:13 <womb> mauke: about spam, i'm hungry
09:17:19 <womb> mauke: feed me
09:17:36 <kallisti> can someone help me find the best hash function for newtype T = T (HashMap T T)
09:17:55 <womb> mauke: http://bit.ly/JFaQ8i
09:18:43 <kallisti> I'm pretty sure there's no way to avoid collisions.
09:18:49 <kallisti> should I just... count layers?
09:20:11 <bitonic> kallisti: `newtype T = T (HashMap T T)'? that doesn't make much sense.
09:20:32 <kallisti> sure it does.
09:20:34 <quicksilver> well it's a  bit like newtype L = L (L -> L)
09:20:36 <bitonic> unless I'm missing something
09:20:37 <quicksilver> except weirder
09:20:41 <kallisti> it makes sense for this completely nonsensible purpose.
09:20:47 <quicksilver> because no sane person would use hashmaps for their model of L
09:20:51 <bitonic> kallisti: well it typechecks, and you can construct things of that type
09:20:53 <kallisti> which is to create a parody programming language in which everything is hash tables
09:20:57 <kallisti> as in, there is no other data structure.
09:20:57 <bitonic> but I don't see why you would do that
09:21:20 <kallisti> see? perfectly good reason.
09:21:21 <bitonic> ah. then yeah it makes perfect sense.
09:21:29 <quicksilver> kallisti: it does rather depend on the internals of hashmap.
09:21:42 <quicksilver> kallisti: btu I would suggest you can hash all the keys and all the values.
09:21:46 <quicksilver> and combine that.
09:22:02 <kallisti> hm, that's still pretty collisiony
09:22:06 <kallisti> oh well.
09:22:27 <kallisti> I am deeply concerned about the efficiency of my parody language.
09:23:43 <bitonic> kallisti: I think things might be easier if you do `newtype T t = T (HashMap t t)', and then use `Mu t'
09:23:47 <bitonic> at least easier to reason about
09:23:56 <bitonic> sorry, `Mu T'
09:24:39 <kallisti> I find that equally reason-about-able.
09:24:58 <kallisti> but slightly less straightforward.
09:25:00 <bitonic> kallisti: well, a hashing function is more easily defined imho.
09:25:58 <bitonic> but I guess you already have that since you were already worrying about collisions :P
09:26:26 <kallisti> yes, I would never optimize prematurely.
09:26:27 <kallisti> >_>
09:26:58 <bitonic> I like this idea, after the semicolon-only language and parens-only language, an HashTable language. You can advertise it as a "amortised constant access" language
09:27:39 <kallisti> well it's my opinion that languages such as Lua, Python, and Perl don't go far enough in their use of tables.
09:28:02 <kallisti> for example, they use sequences of characters to represent variable names! how absurd!
09:28:08 <kallisti> thosecan just be tables too.
09:28:34 <mauke> tables are so last century
09:28:41 <mauke> people prefer css these days
09:28:59 <barrucadu> Turing-complete CSS? :P
09:29:19 <mauke> yeah, someone's done that
09:29:29 <mauke> a cellular automaton in html5/css
09:29:59 <womb> scumbag css
09:34:27 <Mathnerd314> kallisti: I'm curious; how do you represent an integer using tables?
09:35:54 <quicksilver> Mathnerd314: [] is 0, [[] => []] is 1, [[] => n] is n+1 for all n, perhaps?
09:36:11 <quicksilver> slight variant on standard ways of encoding numbers in set theory
09:36:36 <mauke> why the special case for 1?
09:36:49 <quicksilver> mauke: that's not a special case
09:36:49 <kallisti> Mathnerd314: similar to sets. except now it's sets of ordered pairs.
09:36:59 <quicksilver> mauke: 0 is rpresented as []
09:37:07 <mauke> yes, that's what I mean
09:37:08 <quicksilver> so 1 is [[] => 0] which is [[] => []]
09:37:25 <quicksilver> why did I write it that way? just to show it concretely
09:37:45 <quicksilver> and because [[] => n] is clumsy, it should really be [[] => <n> ] or some notation for 'denotation of n'
09:37:59 <kallisti> and since there's a bijection to the natural numbers, strings, and integers, well... you just get a lot of stuff for free! all from the power of tables.
09:38:55 * hackagebot hbayes 0.1 - Inference with Discrete Bayesian Networks  http://hackage.haskell.org/package/hbayes-0.1 (alpheccar)
09:38:57 <kallisti> representing Unicode strings as tables should be pretty, uh, efficient.
09:41:24 <kallisti> for strings you could even index each character by a natural number
09:41:32 <kallisti> {natural => character, natural => character, ... }
09:41:36 <kallisti> for subscripting.
09:42:15 <kallisti> so strings are somewhat like a sparse array. So that means I can market it as PHP-like. yesss.
09:42:45 <kallisti> (oh wait actually I think strings are different from arrays in PHP. yes.. nevermind)
09:43:55 * hackagebot hflags 0.1 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.1 (GergelyRisko)
10:02:06 <hpaste_> bitonic pasted “numbers as hashtables” at http://hpaste.org/67725
10:02:36 <bitonic> would that work?
10:03:59 <bitonic> should be good
10:08:05 <Mathnerd314> @hoogle fromList
10:08:06 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
10:08:06 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
10:08:06 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
10:08:53 <fliiipy> How would you go about replacing a list item at a given index with another item?
10:10:53 <cg_morton`> something like:  (take n xs) ++ [newitem] ++ (drop (n+1) xs)   would work
10:10:56 <hpaste_> bitonic annotated “numbers as hashtables” with “numbers as hashtables - with operations” at http://hpaste.org/67725#a67726
10:11:08 <fliiipy> Thanks morton.
10:11:18 <bitonic> kallisti: ^^^
10:11:20 <bitonic> this is a great idea
10:12:07 <codekoala> just curious, what would be the best way to "tail" a file (such as an access log from Apache or Nginx) with Haskell?
10:12:37 <codekoala> have a co-worker who is trying to do some magic with stuff in an access log (parsing, categorizing, reporting, etc)
10:12:56 <codekoala> I'm just getting into haskell, so it seems like a fun exercise
10:13:03 <codekoala> but I don't know where to start :)
10:14:07 <cg_morton`> what do you mean by "tail"?
10:14:21 <codekoala> well, let's say he's doing something like
10:14:24 <jfischoff> maybe this http://hackage.haskell.org/package/ztail
10:14:33 <codekoala> tail -F /var/log/apache/access.log | my_haskell_magic
10:15:05 <codekoala> jfischoff: ztail looks interesting, thanks!
10:15:42 <jfischoff> codekoala: I haven't used it, but the source might be informative
10:15:57 <codekoala> jfischoff: definitely :)
10:20:55 <nand`> Is there any solution to nesting state monads? In my calculations, I have an over-arching “global state” and I want to also access sub-computation specific “context states”. Right now I simply have a “context” field in my global state that I make sure to manually reset between every sub-computation
10:21:26 <bitonic> nand`: you can, but you won't be able to use the MonadState methods proficiently
10:21:42 <nand`> maybe something like a LocalStateT with localPut and localGet
10:21:47 <bitonic> but if you do the manual lifting, no problem
10:21:59 <nand`> and MonadLocalState
10:22:22 <bitonic> there's nothing wrong with `StateT Foo (State Bar)'
10:22:48 <bitonic> but you'll have to lift the computations manually, you can't rely on the generic functions
10:22:58 <bitonic> I'd argue that you want to avoid that situation
10:23:06 <bitonic> but you *can* do that
10:23:30 <MostAwesomeDude> Hm. Cabal can't uninstall a package? I wanted to switch from a homebrewed version of terminfo to my distro's version.
10:24:34 <bitonic> MostAwesomeDude: correct, it can't. you have to unregister it manually. also, mixing your distro's packages and cabal's is going to cause confusion
10:24:52 <MostAwesomeDude> bitonic: Better than the alternative. terminfo doesn't link right on Fedora.
10:25:44 <bitonic> uhm, I'm not a cabal expert, but when I tried a long time ago, it was a mess. good luck ehe
10:26:59 <kallisti> bitonic: oh nice.
10:27:11 <bitonic> kallisti: I was going to define integers but I got bored
10:27:31 <kallisti> bitonic: so you skip the hash table representation entirely.
10:27:37 <kallisti> ?
10:27:46 <bitonic> kallisti: what do you mean?
10:28:35 <kallisti> bitonic: well you're using HashSet instead of HashMap.
10:28:52 <bitonic> kallisti: ah yeah, you don't need HashMap anyways
10:29:06 <bitonic> to represent integers
10:29:16 <kallisti> oh right
10:29:24 <bitonic> and thus, to represent whatever you want :P
10:29:31 <kallisti> I can refit it to hashmap easily. I was just curious why you chose hashset instead of hashmap
10:30:51 <kallisti> how would you represent integers? I know of bijections but I don't know how to define addition and multiplication
10:31:14 <kallisti> I would probably do something gross and use the key as a sign.
10:31:16 <bitonic> kallisti: data Integer = Positive Nat | NegativeMinusOne Nat
10:31:42 <kallisti> er, that's not a hash table. perhaps we have different purposes here. :P
10:32:24 <bitonic> kallisti: Nat is defined in terms of hash tables
10:32:28 <bitonic> ah you want hash tables all the way
10:32:32 <kallisti> of course. :P
10:32:53 <kallisti> aren't tables the best way to represent anything?
10:33:14 <kallisti> I think the easiest way would be to have a sign as a key
10:33:43 <kallisti> though it's not ideal.
10:33:58 <kallisti> there are many more possible keys than there are signs.
10:34:07 <dmwit> nand`: Use lenses.
10:34:21 <bitonic> kallisti: you can have the first hashset to hold either [] or [[]], and the wanted number
10:34:27 <dmwit> As was discussed yesterday (though I think with another nick, not you).
10:34:32 <bitonic> if it's [] it's +, otherwise -
10:34:39 <nand`> dmwit: I've never used lenses before; this may be interesting
10:34:44 <bitonic> ofc natural would have to start from [[], [[]]]
10:34:45 <dmwit> There's a foo :: Lens a b -> StateT b m () -> StateT a m ()
10:35:52 <dmwit> kallisti: Use the Grothendieck construction to turn the non-negative naturals into the integers.
10:35:58 <dmwit> Addition is easy, it's pairwise addition.
10:36:10 <nand`> so I would write something like a “Lens globalState (localState, globalState)” ?
10:36:10 <dmwit> The only trick is that equality isn't structural.
10:36:22 <dmwit> nand`: No, just Lens globalState localState
10:36:34 <nand`> I still need to access the globalState from within my local computations
10:36:48 <dmwit> nand`: Then you write your local action as if it only had access to the local state, and use foo to embed that in your global-state-aware computations.
10:37:04 <dmwit> nand`: In that case, what justifies the name "local state"?
10:39:12 <kallisti> dmwit: so something like (a,b) in N+ x N+ where a - b is in Z?  (excuse my lack of Unicode)
10:39:14 <nand`> dmwit: I'll elaborate somewhat further; I have a global state containing lots of persistent data like my own private key, public key, address and so on; in addition to this I have a “local context” which contains data on the packet I'm currently parsing; and is used to dump stuff like the author of the packet, the author's location, the author's agreed upon AES key, a cache to store the last decoded
10:39:15 <nand`> field (for signature purposes) and so on
10:39:21 <dmwit> kallisti: precisely
10:40:27 <nand`> (the nature of the packet is out-of-order and chunk-wise, analogous to a [Section] so I don't know in which order the Sections are; ergo my solution to sequence a [MyMonad Section]
10:41:22 <nand`> I want each “packet parsing computation” to have its own local context used to dump information about the packet as it is discovered; which needs to be later accessed and also rewritten (which cuts out Writer and Reader)
10:42:04 <kallisti> dmwit: yeah that's some very non-structural inequality.
10:42:20 <nand`> I'll note that my current solution “works” fine; it's just somewhat ugly
10:42:28 <kallisti> you'd have to stipulate something like x > b or a = b = 1
10:42:28 <dmwit> (a,b) + (c,d) = (a+c,b+d); (a,b) * (c,d) = (a*c + b*d,a*d + b*c)
10:42:38 <dmwit> kallisti: Oh, what?
10:42:49 <dmwit> (a,b) == (c,d) = a+d == b+c
10:43:01 <kallisti> I mean, to ensure uniqueness
10:43:22 <kallisti> so that all the equivalece classes are singletones, basically. :P
10:43:26 <kallisti> -e
10:43:33 <dmwit> You can ensure uniqueness by stipulating that one or the other of them is exactly zero.
10:43:39 <dmwit> But why ensure uniqueness?
10:43:44 <kallisti> oh, right. that works too
10:43:48 <kallisti> no reason.
10:44:01 <dmwit> So if there's no reason... why add headaches? =)
10:44:10 <kallisti> I wasn't really considering it as a problem
10:44:26 <kallisti> more or less just thinking about how you would do that.
10:44:50 <dmwit> Just think about the individual operations rather than thinking about choosing a canonical element in each equivalence class.
10:44:56 <dmwit> The operations are remarkably simple.
10:45:08 <lucasterpin> ciaooo
10:45:20 <kallisti> they remind me of dual numbers uses in automatic differentiation.
10:45:25 <kallisti> at least addition and multiplication does.
10:45:29 <kallisti> *used
10:45:35 <dmwit> yeah
10:45:42 <lucasterpin> !list
10:45:50 <dmwit> lucasterpin: Perhaps you want ?help.
10:46:21 <lucasterpin> yes
10:46:47 <lucasterpin> !list
10:47:00 <dmwit> ...
10:47:15 <dmwit> Oh!
10:47:18 <dmwit> ?list
10:47:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:47:19 <dmwit> =)
10:47:25 <lucasterpin> ?list
10:47:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:47:29 <kallisti> dmwit: integer division? :P
10:47:35 <dmwit> kallisti: hah!
10:47:57 <dmwit> let's see...
10:48:01 <kallisti> come on, we've go to have a divMod.
10:48:06 <kallisti> this is for real world programming.
10:48:54 <jfischoff> ?vixen
10:48:54 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
10:49:21 <lucasterpin> !list
10:49:38 <dmwit> lucasterpin--
10:49:53 <kallisti> dmwit: basically you need to turn (a - b) `div` n  into something where you divide both a and b.
10:50:18 <nand`> I need to find “hash :: (Integer, Integer, Integer) -> Double” where the codomain is [0..1]; any tips?
10:50:28 <kallisti> I think you need to handle remainders somehow.
10:50:34 <dmwit> kallisti: You might have to add this one as a primitive.
10:51:40 <nand`> ((if it helps; the first integer is on the scale 256..512, the second integer is on the scale 2^256 .. 2^512 and the third integer is ~2^16)
10:51:46 <tromp> hash x y z = x*a+y*b+z*c mod 1
10:52:19 <tromp> for randomly chosen a,b,c in (0.5,1)
10:52:39 <nand`> that could work
10:53:09 <dmwit> with your constraints,
10:53:10 <nand`> my only goal is that randomly distributed (x,y,z) within their given ranges will also result in a randomly distributed hash (x,y,z) in 0..1; it's for a “fair share” distributed hash table
10:53:24 <nand`> reasonably randomly distributed*
10:53:46 <nand`> though I could probably ignore x and z completely
10:53:54 <dmwit> hash x y z = (x-256) / 768 + (logBase 2 x - 256) / 768 + y / (3 * 2^32)
10:53:56 <tromp> you're 9 bits short of avoiding collissions seems...
10:54:04 <nand`> tromp: collisions are fine
10:54:25 <tromp> so i figured
10:55:03 <nand`> dmwit: why 768?
10:55:07 <dmwit> > 3 * 256
10:55:08 <lambdabot>   768
10:55:34 <dmwit> But my distribution isn't very flat.
10:56:27 <dmwit> tromp: 9 bits short can't be right
10:56:49 <dmwit> tromp: a number between 2^256 and 2^512 already has 256 bits of entropy, right? and Double has 64 bits?
10:57:03 <tromp> only 53 bits in mantissa though
10:57:16 <dmwit> Right, I'm just saying 256 - 64 >> 9
10:57:34 <tromp> he doesn't have 2^256
10:57:45 <dmwit> He said the second integer is on the scale 2^256 .. 2^512
10:57:51 <kallisti> dmwit: this is going to be impossible to program
10:57:57 <tromp> oops
10:58:07 <cg_morton`> so that's closer to 2^512 anyway
10:58:09 <nand`> tromp: the arguments are all Integer :)
10:58:26 <tromp> then my suggestion is useless
10:58:33 <kallisti> because I've decided that there will be no identifiers other than tables. so functions are named as tables, parameter names are tables, builtins are named as tables, etc.
10:58:37 <tromp> y*b mod 1 === 0 then
10:59:52 <Twey> kallisti: "abc" ⇒ { 0: "a", 1: "b", 2: "b" }
11:00:12 <dmwit> Twey: -3 => { ...?... }
11:00:18 <tromp> replace y by (y mod p) for some 9 bit prime then
11:00:28 <kallisti> Twey: yes that's the representation for strings
11:00:48 <tromp> or just a 64 bit prime
11:01:04 <sclv> there are newer better tools than hp2ps for viewing heap profiles, right?
11:01:18 <Twey> dmwit: http://en.wikipedia.org/wiki/Quater-imaginary_base
11:01:59 <nand`> hash (_,y,_) = (fromIntegral $ y `mod'` 2^64) / 2^64
11:02:00 <roha> holy shit, i just shortened a module to read and write account data to files from something like 50 lines of code to 4. total beginner fail :D
11:03:22 <dmwit> roha: Sounds like total beginner win to me!
11:03:48 <jfischoff> Twey: Are there advantages to quater base?
11:04:00 <Twey> jfischoff: For practical purposes?  Not really
11:04:03 <Twey> jfischoff: It's cool though!
11:04:12 <jfischoff> Twey: yep :)
11:04:52 <Twey> (and, relevantly, it would allow you to represent negative and complex numbers as tables of { digit_position : digit_value, … }, where both can be naturals)
11:05:24 <jfischoff> ah
11:06:28 <dmwit> I don't see that div is any easier with this representation than with the Grothendieck one.
11:06:49 <dmwit> Still seems like you'd need a built-in for it.
11:07:16 <copumpkin> Grothendieck in my #haskell?
11:07:58 <dmwit> Z = N x N / (\(x1, y1) (x2, y2) -> x1 + y2 == y1 + x2)
11:08:14 <copumpkin> http://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Alexander_Grothendieck.jpg/220px-Alexander_Grothendieck.jpg vs, http://madamenoire.com/wp-content/uploads/2011/04/malcolm-xs-sexuality1.jpg
11:08:20 <jfischoff> whenever I see his name I think "important"
11:08:40 <jfischoff> but I no so little of algebraic geometry
11:09:02 <Twey> copumpkin: Hehe
11:09:56 * JuanDaugherty thinks "basis"
11:10:16 <alpounet> his """biography""" is a pretty cool read
11:14:35 <JuanDaugherty> he apparently hates humongs so bad he wishes they'd remove all his works
11:14:59 <JuanDaugherty> (from libraries and what not (according to wikipedia))
11:15:51 <JuanDaugherty> Apparently he was overcome with neuroticism. Understandable.
11:19:03 <nand`> Was he a logician?
11:19:26 <hayashi> @pl \x -> f (g x) (h x)
11:19:26 <lambdabot> liftM2 f g h
11:20:27 <hayashi> Had a feeling that'd be liftM2, but wanted to be sure
11:26:36 <hayashi> @pl \a b -> a >>= (\c -> b >>= (\d -> f c d) )
11:26:37 <lambdabot> (. ((. f) . (>>=))) . (>>=)
11:26:38 <hayashi> No
11:27:09 <hayashi> though I have to say, (>>=) . (>>=) is my new favourite emoticon
11:29:23 <parcs`> what emotion does it represent?
11:29:48 <tgeeky_> laser beam eyes
11:30:06 <timthelion> double unibrow with rabit teath
11:31:17 <cg_morton`> (>>=    is a duck, cleasly
11:31:28 <cg_morton`> *clearly
11:31:50 <tgeeky_> i thought that might be a monty python reference
11:32:48 <cg_morton`> nah, it just looks like a duck
11:32:53 <alpounet> nand`, nope
11:33:15 <alpounet> JuanDaugherty, yeah he kinda felt his fellow didn't understand him
11:33:20 <alpounet> and he's living in mountains now
11:34:17 <cg_morton`> oh, Grothendieck.  I thought nobody knew where he's living?
11:34:54 <tgeeky_> cg_morton`: "in the mountains" is an indicator of that
11:36:50 <cg_morton`> and what makes you say he doesn't live in a forest, or on a beach?  He could be fooling us all, living in New York City with a fake moustache so nobody will recognize him
11:37:26 <kallisti> why is functional forms not on hackage?
11:38:35 <nand`> is it possible to write:  “catch :: MonadError m => (a -> b) -> a -> m String b” ?
11:39:10 <kallisti> no
11:39:20 <kallisti> or well, I'm not sure what m String b means
11:40:51 <kallisti> MonadError has 2 parameters
11:41:24 <kallisti> instance (Monad m, Error e) => MonadError e (ErrorT e m)
11:42:18 <hayashi> @pl \f -> a f <|> b f
11:42:18 <lambdabot> liftM2 (<|>) a b
11:42:25 <hayashi> oh my giddy aunt.
11:42:33 <copumpkin> :t \a b -> a >>= (\c -> b >>= (\d -> f c d) )
11:42:34 <lambdabot> forall (m :: * -> *) a a1 b. (Show a, Show a1, SimpleReflect.FromExpr (m b), Monad m) => m a -> m a1 -> m b
11:42:51 <copumpkin> :t \f a b -> a >>= (\c -> b >>= (\d -> f c d) )
11:42:52 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
11:43:15 <copumpkin> :t \f x y -> join (liftM2 f x y)
11:43:16 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:43:24 <copumpkin> hayashi: ^
11:43:38 <hayashi> Ah
11:43:47 <kallisti> nand`: if you meant MonadError e m => (a -> b) -> a -> m b; then that's just f g x = return (g x)
11:43:48 <hayashi> I need to figure out what join does at some point.
11:44:00 <kallisti> join (fmap f m) = m >>= f
11:44:02 <kallisti> there you go
11:44:24 <aristid> hmm, join (liftM2 ...) might even be a useful idiom
11:45:08 <nand`> kallisti: err; I meant to catch runtime exceptions (eg. head [])
11:45:18 <kallisti> oh, that's very different then.
11:45:25 <nand`> yeah, forgot to specify
11:45:32 <kallisti> nand`: do you want to catch runtime exceptions and put them in a MonadError
11:45:37 <nand`> kallisti: basically, yes
11:45:56 <kallisti> http://hackage.haskell.org/package/spoon  check this out then. It's for Maybe but it's the same idea.
11:45:57 <mauke> > join f x :: Expr
11:45:58 <lambdabot>   f x x
11:46:34 <jfischoff> ?hpaste
11:46:34 <lambdabot> Haskell pastebin: http://hpaste.org/
11:46:41 <nand`> kallisti: interesting; thanks
11:46:49 <kallisti> nand`: you would just have (MonadError SomeException m) => m a   instead of Maybe a
11:47:40 <nand`> What does “WHNF” mean in “Like 'spoon', but only evaluates to WHNF.”?
11:47:54 <jfischoff> hand`: I pasted something close I think: http://hpaste.org/67728
11:48:13 <mauke> http://www.acronymfinder.com/Weak-Head-Normal-Form-(lambda-calculus)-(WHNF).html
11:48:16 <mauke> nice
11:48:27 <kallisti> nand`: s `seq` a only evaluates s to WHNF
11:48:30 <kallisti> do you know about seq?
11:48:38 <kallisti> WHNF = weak head normal form
11:48:41 <nand`> oh
11:48:49 <nand`> I know some things about seq, deepseq and thunks
11:48:51 <nand`> but not in depth
11:49:40 <kallisti> teaspoon will only catch errors in evaluating the topmost constructor
11:49:56 <nand`> figured
11:50:00 <kallisti> (I think)
11:51:33 <hayashi> When using LiftMn, are the monads guaranteed to be executed in left-to-right order, or would I need an explicit monadic bind to get that?
11:51:53 <kallisti> the binds are guaranteed to be in left-to-right order.
11:51:58 <nand`> hayashi: I think so; since function application is left-associative
11:52:02 <kallisti> but evaluation is non-deterministic as usual.
11:52:20 <hpc> @src liftM2
11:52:20 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:52:29 <hayashi> Well there I go
11:53:15 <hpc> incidentally, the liftMs carry side-effects in the same direction as the liftAs
11:53:25 <hpc> which are defined in terms of (<*>)
11:54:22 <dekuked> what's a modern example of equational reasoning in haskell?
11:54:40 <kallisti> any Haskell function..
11:55:02 <hpc> what would an "old" example be? :P
11:55:14 <dekuked> well I'm very new to haskell
11:55:29 <dekuked> I don't understand if standards/practices have changed recently...
11:55:35 <dekuked> I know haskell has been becoming more popular
11:55:51 <kallisti> equational reasoning just means that you can more or less reason about evaluation of code in terms of syntactic substition, with some exceptions.
11:56:19 <dekuked> so it's not a specific property of haskell, but instead of functional programming?
11:56:20 <kallisti> so if you have f x = y
11:56:35 <kallisti> then anywhere you see "f something"  you can syntactically replace it with y
11:56:54 <kallisti> it's a property of referential transparency.
11:56:56 <fliiipy> How do I go about applying every element in a list to a function?
11:57:02 <kallisti> not all functional languages have that.
11:57:21 <fliiipy> I dont want to apply the function to the list, I want it the other way around.
11:57:23 <kallisti> but yeah it's a property of pure functional programming.
11:57:59 <kallisti> given the same inputs, a function application will always evaluate to the same result.
11:58:16 <hayashi> @src liftA2
11:58:16 <lambdabot> liftA2 f a b = f <$> a <*> b
11:58:17 <cg_morton`> fliiipy: so it's a list of functions?
11:58:53 <fliiipy> No, its hard to explain...
11:59:00 <cg_morton`> you'll probably want a fold of some sort
11:59:08 <kallisti> fliiipy: the first statement sounds exactly like map.
11:59:14 <kallisti> but the second one doesn't..
11:59:38 <kallisti> > map negate [1,2,3]  -- not like this?
11:59:39 <lambdabot>   [-1,-2,-3]
11:59:54 <fliiipy> I want to apply a list of numbers to this ((take n xs) ++ [newitem] ++ (drop (n+1) xs))
12:00:16 <fliiipy> each number replaces a section of the list with some other elements.
12:00:27 <stilgart> listOfNumber -: f ?
12:00:37 <fliiipy> ?
12:00:57 <stilgart> Do you have an example of what you want ?
12:01:20 <cg_morton`> so that's a function that takes a list and replaces the nth element, presumably you want to apply that to a list?
12:01:25 <kallisti> fliiipy: you want to insert an element into the list?
12:01:33 <kallisti> oh replace
12:01:45 <fliiipy> I want to replace an element in a list from a list?
12:01:53 <fliiipy> Like, there may be more than one replace?
12:01:59 <fliiipy> So its a list of ints.
12:02:10 <kallisti> how do you know what to replace?
12:02:14 <kallisti> the ints only give you an index.
12:02:15 <fliiipy> I might be confusing myself. I may have to write two functions.
12:02:19 <kallisti> not a replacement element.
12:02:28 <fliiipy> Yeh, I have a list of ints that represent the index's
12:02:39 <cg_morton`> and at each index you do what?
12:02:55 <cg_morton`> replace with the same value every time?
12:03:03 <kallisti> so some constant parameter
12:03:09 * hayashi checks something
12:03:09 <hayashi> @pl \f -> ( a f ) <|> ( b f )
12:03:10 <lambdabot> liftM2 (<|>) a b
12:03:14 <hayashi> ah
12:03:25 <kallisti> f indexList replaceValue list = ...
12:03:27 <kallisti> right?
12:03:28 <nand`> Huh; I'm getting some odd behavior: My program terminates with what seems to be a runtime exception (“Test: newCtx: IV has wrong length: 13”) but the confusing bit is that the error occurs *after* the program terminates, and all output seems correct
12:03:34 <startling> so in do notation, the <- in "x <- y" is just something equivalent to >>= or >>, depending on whether the variable is used or not?
12:03:36 <hayashi> :t \f -> ( a f ) <|> ( b f )
12:03:37 <lambdabot>     Couldn't match expected type `t -> f a'
12:03:37 <lambdabot>            against inferred type `Expr'
12:03:38 <lambdabot>     In the first argument of `(<|>)', namely `(a f)'
12:03:42 <hayashi> Nnn
12:03:45 <nand`> how would I best debug this to figure out what's causing it?
12:03:58 <kallisti> startling:  the <- form is always equivalent to >>=
12:03:59 <fliiipy> Sorry, im lost.
12:04:07 * hackagebot soxlib 0.0.1 - Write, read, convert audio signals using libsox  http://hackage.haskell.org/package/soxlib-0.0.1 (HenningThielemann)
12:04:14 <cg_morton`> kallisti: if the indexList isn't sorted, then you'd have to apply the function fliiipy gave above for each number n in indexList
12:04:32 <nand`> startling: “>>” is equivalent to just “y” (without any “x <-”) in do notation
12:04:34 <startling> kallisti: right, and x >>= \_ -> whatever is equivalent to >>
12:04:35 <kallisti> startling: if there's 2 line side by side with no <- in either, then that's equivalent to placing a >> between them.
12:04:40 <kallisti> startling: yes
12:04:46 <jfischoff> hand`: you try printing the stack trace if you have base 4.5
12:05:11 <startling> okay, cool. I was just trying to reconcile my do-notation knowledge with my monad knowledge, and that occured to me
12:05:12 <jfischoff> s /hand`/nand`
12:05:16 <kallisti> fliiipy: it may be better to start from your overall goal.
12:05:39 <dekuked> what's some good haskell code to learn from?
12:05:43 <nand`> jfischoff: I have base-4.5; how do I go about doing that?
12:05:56 <kallisti> dekuked: Real World Haskell has some pretty good examples.
12:05:58 <dekuked> I'd like something that handles udp networking and indexing
12:06:03 <kallisti> dekuked: large examples, that actually do things.
12:06:08 <kallisti> if that's what you're looking for.
12:06:25 <dekuked> the reviews of real world haskell on amazon made me think it wasn't that good
12:06:34 <dekuked> I'll have to check it out at the bookstore :P
12:06:38 <kallisti> I think it's somewhat underrated.
12:06:56 <kallisti> it does move fast however
12:06:59 <dekuked> I couldn't tell if the reviews were from people who knew what they were talking about or not
12:07:02 <kallisti> I recommend reading LYAH first as an introduction
12:07:11 <xraycat> dekuked: http://book.realworldhaskell.org/read/
12:07:12 <jfischoff> nand`: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/GHC-Stack.html
12:07:17 <startling> lyah is good, as is "a gentle introduction to haskell"
12:07:43 <jfischoff> I haven't used it but that's what I would try if I had the same problem
12:08:30 <nand`> jfischoff: I'm not sure how I'd work that into my code; since I don't even know where and when the exception occurs
12:08:37 <jfischoff> ah
12:09:09 <jfischoff> hand`: yeah, I would start by searching the source and find the error and then inject the stacktrace
12:10:19 <kallisti> runtime error reporting is seriously neglected.
12:10:59 <jfischoff> for realz
12:11:39 <hayashi> @src liftA3
12:11:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:12:33 <kallisti> that's probably why Haskell programmers are so afraid of them.
12:13:17 <jfischoff> well real haskell programmers prove all their programs correct
12:14:08 <Quantumplation> Hi all :)
12:14:12 <kallisti> I can't prove my programs correct for all possible strings that I'm parsing as JSON. :P
12:15:21 <jfischoff> monad fail FTW!
12:15:26 <Quantumplation> I'm wondering if anyone can help me think of a way to cut down on the computational complexity of this algorithm I'm working on.
12:15:26 <kallisti> >_>
12:15:33 <kallisti> maybe.
12:15:40 <kallisti> paste the algorithm and we'll see.
12:15:55 <jfischoff> ?hpaste
12:15:56 <lambdabot> Haskell pastebin: http://hpaste.org/
12:16:04 <Quantumplation> It's in the design stages, so there's no code to paste.
12:16:24 <kallisti> oh. okay.
12:16:58 <Quantumplation> I just received a research fellowship from my university to work on this, but my initial guess at the algorithm places it growing at something like (n^3)!
12:17:27 <luite> is that a factorial? :p
12:17:42 <Quantumplation> yes... lol
12:17:45 <luite> ouch...
12:19:03 <Quantumplation> So I've got these "tiles", which have certain "glues" on the 4 (or 6 in 3D) faces.  two tiles can stick together if they have the same glues.  They can't rotate, so having an A glue on the left is different from an A glue on the top.
12:19:38 <nand`> jfischoff: now I'm very confused; my main looks something like this: main = runErrorT foo >>= print; I changed it to main = runErrorT (foo >> throwError "bar") >>= print and I get the “Left: "bar"” output (after all of my normal program output). Removing it; I get the usual exception
12:20:33 <Quantumplation> So, I build up a tree of these tiles/macrotiles, and the algrorithm for finding valid merges is rather expensive (n^3 in 3D). It gets worse though.
12:20:46 <timthelion> How hard would it be, to import something from GHC that would parse "start@(Cell foo bar baz)" to ["start","foo","bar","baz"]<- the list of values brought into scope by including that pattern in a function deffinition..
12:21:06 <Quantumplation> I have an initial set of tiles, and I check each pairing of these tiles for valid merges.  I then check each new tile against the tiles that existed previously, and so on, until the state of the system stops evolving
12:21:24 <luite> Quantumplation: what is the goal?
12:21:44 <Quantumplation> given a set of initial tiles, determine the possible superstructures they can form.
12:22:26 <luite> hmm, can't that be infinite?
12:23:06 <Quantumplation> Sure.  It turns out this is actually a turing complete model, so I am not bothering trying to detect for infinite cases.  But, the tile sets my research is dealing with are going to be terminating
12:23:16 <andrei_> Hello!
12:23:26 <nand`> jfischoff: ah! I figured it out
12:23:41 <jfischoff> hand`: tell me
12:23:52 <luite> Quantumplation: what exactly is a superstructure?
12:24:01 <jfischoff> autocorrect is really messing with your name
12:24:33 <nand`> jfischoff: the >>= print was the error; the ErrorT was returning a PublicKey and show on that PublicKey was causing the exception; this is why it occurred at the very end of the program.
12:24:47 <Quantumplation> two sets of tiles merged bonded together.
12:24:51 <nand`> It was a regression because in the last revision, the last test didn't return a PublicKey but something else; so it outputted the end result fine
12:25:08 <Quantumplation> So, it's essentially a tree, where the interior nodes are supertiles and the leaf nodes are individual tiles.
12:25:10 <jfischoff> nand`: cool
12:25:15 <hpaste_> “Popescu Andrei” pasted “identation error” at http://hpaste.org/67729
12:25:21 <Quantumplation> so, [a,b,c] evolves to [a, b, c, ab, bc, ac], and then I check the "new ones" against eachother nd the old ones, so [a, b, c, ab, bc, ac, aba, abb, abc, bca, bcb, bcc, bcab, aca, acb, acc, acab, acbc] (of course, that's just the maximal case, since not all pairings are valid, but you can see how fast this grows)
12:26:00 <Quantumplation> It's a long shot, I was just wondering if anyone had any common practices for dealing with factorial complexity
12:26:26 <Quantumplation> my rough initial implementation in C# took 16 hours to complete for a 5 bit binary counter.
12:26:48 <Quantumplation> I just wanted to make a proof of concept before I tackled it with more formality in Haskell
12:27:02 <honza> I have this tutorial and it says to compile code with -threaded. Is it as simple as doing ghci -O -threaded --make myFile.hs ?
12:27:03 <andrei_> could someone please tell me where is my identation error , or what is wrong in my implementation? Thank you in advance :)
12:27:57 <andrei_> this is my code : http://hpaste.org/67729
12:28:20 <mauke> andrei_: what's the error message?
12:28:30 <andrei_> Robot.hs:28:1: parse error (possibly incorrect indentation)
12:28:32 <andrei_> make: *** [mine] Error 1
12:28:43 <mauke> andrei_: there is no line 28 in that paste
12:29:05 <andrei_> it s an empty line
12:29:19 <andrei_> I ll post the whole code, but the line is empty
12:29:26 <hpaste_> “Popescu Andrei” pasted “identation error 2” at http://hpaste.org/67730
12:29:34 <andrei_> http://hpaste.org/67730
12:29:37 <andrei_> there
12:29:49 <mauke> you don't have to repeat every url
12:30:06 <andrei_> oh sorry, I thought I refreshed it
12:30:08 <andrei_> my bad.
12:30:49 <hayashi> @pl \lhs -> ( lhs :->: ) <$> ( stringGap ">" *> idString )
12:30:49 <lambdabot> (<$> (stringGap ">" *> idString)) . (:->:)
12:31:04 <mauke> andrei_: missing 'else'
12:31:31 <nejucomo> I just discovered mask, and realized I have no idea what asynchronous exceptions are, or how exceptions interact with pure code...
12:31:42 <nejucomo> A quick scan of the ToC of the report lead me here: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1480007.3
12:32:01 <c_wraith> nejucomo: an asynchronous exception is (more or less) one that comes from another thread
12:32:09 <nejucomo> Ah, okay.
12:32:20 <nejucomo> Wait, how can an exception "come from another thread" ?
12:32:28 <andrei_> mauke : thank you very much, it is working now. Sorry for the bad paste and lack of knowledge.
12:32:38 <c_wraith> @hoogle throwTo
12:32:38 <lambdabot> Control.Exception.Base throwTo :: Exception e => ThreadId -> e -> IO ()
12:32:38 <lambdabot> GHC.Conc.Sync throwTo :: Exception e => ThreadId -> e -> IO ()
12:32:38 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
12:32:43 <c_wraith> With that function
12:32:45 <nejucomo> Also, are there any exceptional conditions which can be triggered while evaluating pure code?  (What about out-of-memory?)
12:33:07 * nejucomo is quite confused what purpose throwTo serves.
12:33:24 <nejucomo> Can you use throwTo to implement "pre-emptive multitasking" ?
12:33:25 <c_wraith> many exceptional conditions can be triggered by pure code. failure to pattern match, evaluating a call to error, etc, etc
12:33:54 <c_wraith> no, throwTo destroys the evaluation context.
12:33:59 <c_wraith> And it's not pre-emptive either
12:33:59 <nejucomo> c_wraith: For all of those cases, can the exceptions be handled?  Can they only be handled in IO?
12:34:03 <mauke> nejucomo: by the time you have more than one thread, you already have multitasking
12:34:07 <c_wraith> throwTo is actually cooperative
12:34:27 <b52> any good book recommendations covering monads exclussivly?
12:34:31 <nand`> :t (>=>)
12:34:32 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:34:33 <nejucomo> So what purpose does throwTo serve?  -some sort of synchronization primitive?
12:34:34 <c_wraith> threads have to check for pending asynchronous exceptions every once in a while
12:34:46 <c_wraith> nejucomo: primarily, killing threads that are no longer necessary
12:35:14 <dcoutts> c_wraith: well, semi-cooperative, they have to not block async exceptions
12:35:23 <nejucomo> Ok.
12:35:32 <c_wraith> dcoutts: my point was that it's certainly not pre-emptive :)
12:36:16 <dcoutts> c_wraith: I'd say it is pre-emptive, though you can block them
12:36:26 <dcoutts> it's much like unix signals
12:36:37 <dcoutts> they're quite async and pre-emptive
12:36:42 <dcoutts> though you can block them
12:36:47 <c_wraith> dcoutts: it's only at safe points though. If you never allocate, you'll never receive an async signal, even without blocking them
12:36:58 <luite> but that's considered a bug in the implementation
12:37:07 <nejucomo> I got on this whole tangent by reading MVar source.  I was surprised there's no pureModify such as :: (a -> (a, b)) -> MVar a -> IO b
12:37:46 <c_wraith> But the model is cooperative with occasional checks inserted by the compiler. (sometimes it doesn't insert enough, that's the bug)
12:37:49 <dcoutts> c_wraith: right, as luite says, the thread model certainly is pre-emptive, even if in practice in ghc you can avoid pre-emption
12:37:52 <nejucomo> -but now that I realize pure code can be the source of exceptions, I suppose that makes sense.
12:38:26 <mauke> (⊥)
12:38:31 * nejucomo hunts for more detail on exceptions in the report.
12:38:46 <dcoutts> c_wraith: from the point of view of the thread, and the semantic model of the thing, it's pre-emptive. The implementation does of course do it using checks in the scheduler.
12:39:20 <dekuked> what's the fastest way to become a super competent haskell person?
12:39:33 <mauke> download haskell into your brain
12:39:34 <otters> do a lot of work in haskell
12:39:37 <otters> oh
12:39:38 <luite> dekuked: you eat a dons, an SPJ and a dcoutts
12:39:39 <otters> or that
12:39:41 <c_wraith> dekuked: write programs that do useful things
12:39:43 <cg_morton`> dekuked: write haskell probably
12:39:50 <mauke> write a haskell compiler
12:39:51 <mauke> in haskell
12:39:59 <cg_morton`> mauke is correct
12:40:10 <Mathnerd314> memorize Haskell report
12:40:20 <dcoutts> dekuked: read a lot of papers, do a masters degree
12:40:37 <cg_morton`> dcoutts: he said fastest
12:40:53 <c_wraith> hmm.  I don't remember this sentence in the docs: "However, in GHC a foreign call can be annotated as interruptible, in which case a throwTo will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details. "
12:40:56 <Mathnerd314> dekuked: what exactly are you trying to accomplish?
12:40:56 <dcoutts> cg_morton`: he said super competent :-)
12:41:00 <c_wraith> Is that a new feature?
12:41:04 <timthelion> Dons doesn't hang out here anymore :(
12:41:23 <dcoutts> timthelion: sadly he's far too busy
12:41:37 <dcoutts> c_wraith: yeah, and not necessarily a nice feature imho
12:41:54 <parcs`> c_wraith: what is the syntax for that?
12:42:08 <timthelion> dcoutts: a few years ago, he had enough free time to teach me haskell while maintaining a rapidly developing xmonad.  Now ...  perhaps I wasted his time.
12:42:10 <nejucomo> dekuked: Solve real world problems with Haskell.
12:42:10 <c_wraith> parcs`: I haven't got a clue. there's no link to the relevant docs, and I haven't gone looking
12:42:19 <cg_morton`> I think, strictly speaking, the fastest way to become super-competent at haskell is to start of super-competent in haskell
12:42:21 <c_wraith> timthelion: nah, he just changed jobs
12:42:30 <cg_morton`> dt = 0
12:42:35 <dcoutts> c_wraith: it uses something a bit dubious iirc, like trying to wake up blocking syscalls, or maybe it was just posix kill thread
12:42:49 * nejucomo fetches coffee.
12:43:03 <dcoutts> timthelion: you're still here :-)  so not a waste of his time
12:44:13 <c_wraith> dcoutts: I can see reasons to want the feature, but..  There's really no way to implement it that will work across all kinds of ways a foreign call can block
12:45:39 <c_wraith> maybe it has a sane implementation on some awesome OS no one uses :)
12:46:44 <dcoutts> c_wraith: right, indeed I think it's an unpleasant hack
12:52:26 <captWheeto> Is there any good documentation for vty out there? It's a little hard to find on google
12:53:48 <hayashi> @pl \x -> x <$> a <*> b
12:53:48 <lambdabot> (<$> a <*> b)
12:56:11 <hayashi> except that doesn't work due to precedence fun, and bracketing caused even more fun.
12:58:57 <keseldude> I know this is really simple, but is there a better way to do this? (specifically comparing numGs and numBs) http://hpaste.org/67731
13:00:26 <acowley> keseldude: pull out the part that's different in the two functions as an extra argument
13:00:35 <Ngevd> Hello!
13:00:36 <Quantumplation> Hrm.  trying to install Snap with Cabal, keep getting a bunch of "Use -XRecordWildcards to permit this" errors when trying to compile.
13:00:49 <keseldude> okay
13:00:51 <Ngevd> Favourite Haddock tutorial, anyone?
13:00:58 <keseldude> I should also probably do length . filter instead of sum . map
13:01:37 <cg_morton`> both of those traverse twice, a fold would be more efficient
13:01:37 <acowley> Quantumplation: Is it possible you're using an older GHC than the developers?
13:01:52 <acowley> keseldude: is this homework?
13:01:58 <keseldude> no
13:01:59 <cg_morton`> keseldude: also more idiomatic
13:02:08 <keseldude> I was just going through some competition problems for fun
13:02:19 <keseldude> yeah, I'll probably just do fold
13:02:34 <keseldude> http://www.acmicpc-pacnw.org/results.htm
13:02:44 <Quantumplation> acowley: How do I check the installed GHC version? I installed it just today, but I'll double check.
13:02:57 <Quantumplation> er, nvm, i'm dumb.  It says when i start up ghci =P
13:03:04 <cg_morton`> wow, that is one heck of an acronym
13:04:49 <acowley> > let f c = length . filter ((== c) . toUpper) in f 'G' "Green Lantern"
13:04:50 <lambdabot>   1
13:04:55 <hpaste_> keseldude annotated “problem a” with “problem a (annotation)” at http://hpaste.org/67731#a67733
13:05:04 <Quantumplation> Using 2011.4.0.0, which is newer than the Snap 2011.2.0.1 version.
13:05:06 <hpaste_> “Popescu Andrei” pasted “Conflicting Types” at http://hpaste.org/67734
13:05:11 <nand`> is there any builtin function “between :: (Ord a) => a -> a -> a -> Bool” such that (5 `between`) 3 10 evaluates to True?
13:05:46 <acowley> Quantumplation: You're using the Haskell Platform, then? The HP is somewhat behind with compiler versions, which leads to some rather unfortunate fragmentation.
13:05:47 <nand`> or will I have to write it myself (trivial; between x a b = x >= a && x <= b)
13:06:08 <andrei_> Could someone please tell me what causes the error in get_pos function ? Here is the code http://hpaste.org/67734
13:06:15 <Quantumplation> Acowley: yea.  Should I install a newer one?
13:06:24 <andrei_> this is the error
13:06:26 <andrei_>    Conflicting definitions for `c'
13:06:27 <andrei_>     Bound at: Robot.hs:7:17
13:06:29 <andrei_>               Robot.hs:8:9
13:06:30 <andrei_>     In an equation for `get_pos'
13:06:44 <acowley> Quantumplation: It would be good to get confirmation that it's the GHC version that is giving you those errors and not something else, but I don't have Snap installed here so we'll need someone else to chime in.
13:06:58 <andrei_> instead of 'c' it's poz :) , I haven't updated the code  :(
13:07:18 <Quantumplation> alrighty.  Is there a way to tell Cabal to compile with that flag?
13:07:40 <keseldude> cg_morton`: is that better?^
13:07:48 <mauke> andrei_: your code says 'get_pos dir poz poz = ...'
13:07:51 <ozataman> Quantumplation: which file is giving you that error during the compilation?
13:08:13 <Quantumplation>  Snap.Snaplet.Auth.AuthManager
13:08:25 <acowley> keseldude: did you see the version I wrote above?
13:08:26 <Quantumplation> er, that's not a file ^.^
13:08:28 <cg_morton`> keseldude: looks good to me.  But I'm hardly an expert
13:08:30 <andrei_> mauke , I forgot to update the code. This is the error now :
13:08:32 <andrei_>     Conflicting definitions for `poz'
13:08:33 <andrei_>     Bound at: Robot.hs:7:13-15
13:08:35 <andrei_>               Robot.hs:8:9-11
13:08:36 <andrei_>     In an equation for `get_pos'
13:08:42 <Quantumplation> src\Snap\Snaplet\Auth\AuthManager.hs
13:08:46 <mauke> andrei_: my answer still applies
13:08:51 <keseldude> acowley: yeah, but then it traverses the list twice, right?
13:08:58 <acowley> keseldude: no
13:09:19 <keseldude> well if there are n items in the list, all of which are character c
13:09:20 <andrei_> so I should erase the "poz" from the parameters, right?
13:09:22 <ozataman> Quantumplation: That's very bizarre. the said file has the flag set at the top: https://github.com/snapframework/snap/blob/master/src/Snap/Snaplet/Auth/AuthManager.hs
13:09:30 <keseldude> then length will go through the entire list again
13:09:39 <mauke> andrei_: one of them, yes
13:09:58 <andrei_> the function is intented to reviece a direction and a tile and to provide  the tile according to the direction
13:10:05 <andrei_> will it's functionability remain ?
13:10:09 <acowley> keseldude: Non-strict evaluation means that the filter does not walk the list before the length. Instead, they both walk the list hand in hand.
13:10:09 <Quantumplation> ozataman: odd.  Is there a chance that cabal is pulling an older version of the code or something?
13:10:10 <Ngevd> Why is Data.Text marked as GHC-only, but Data.Aeson, which relies on it, marked as Portable?
13:10:13 <ozataman> Quantumplation: what's your GHC version?
13:10:19 <andrei_> recieve*
13:10:24 <ozataman> Quantumplation: have you done a "cabal update" before doing cabal install?
13:10:24 <mauke> andrei_: then why did you write it with 3 parameters?
13:10:31 <Quantumplation> 2011.4.0.0
13:10:42 <ozataman> Quantumplation: that may be the haskell platform version. can you do ghc -V
13:10:43 <Quantumplation> Yea, I did cabal update just a few minutes ago
13:10:53 <keseldude> acowley: oh that's cool. is that more idiomatic than fold then?
13:10:55 <Quantumplation> ozataman: righto, lemme check
13:10:55 <basti_> hey people. I'm trying to compile ghc, but apparently my libre is of a newer version than expected.
13:11:16 <basti_> I would have to use "libpcreposix" instead of "libre"
13:11:18 <basti_> or "libpcre" i think
13:11:28 <Quantumplation> 7.0.4
13:11:40 <kallisti> ..why is it so hard to find good wxHaskell documentation
13:11:47 <acowley> keseldude: yes. The multiple traversal issue usually crops up when you ask for the results of, say, two folds. You might write: avg xs = sum xs `div` length xs
13:11:48 <ozataman> Quantumplation: that should be fine
13:11:50 <basti_> i replaced the #include commands, and then I'm using LDFLAGS=-l
13:11:57 <basti_> -lpcreposix
13:12:05 <basti_> but there's always errors
13:12:23 <Quantumplation> here, running the command again, I'll paste the whole output
13:12:35 <keseldude> ok great, thanks
13:12:41 <acowley> keseldude: That function traverses xs twice, and non-strict (or lazy) evaluation won't help. In that case, a single foldl' that updates *both* accumulators is more efficient.
13:13:10 <hpaste_> Quantumplation pasted “Errors” at http://hpaste.org/67735
13:13:20 <acowley> keseldude: Doing a bunch of maps and filters before a fold is the height of Haskell idiom.
13:14:33 <dino-> Can somebody help? Why would this be happening:
13:14:35 <dino-> Prelude System.IO> readFile "ratings.dat"
13:14:35 <dino-> "4\n"
13:14:35 <dino-> Prelude System.IO> withFile "ratings.dat" ReadMode hGetContents
13:14:37 <dino-> ""
13:15:07 <ozataman> Quantumplation: would you mind trying to upgrade ghc?
13:15:29 <ozataman> Quantumplation: which platform are you on?
13:15:42 <keseldude> acowley: just to clarify, when you say update both accumulators, you mean that the initial value would be (0,0) for example?
13:16:13 <acowley> keseldude: exactly! One element would tally the sum, while the other would just be incremented for each element to compute the length.
13:16:17 <keseldude> (and then you can update with (***) or something)
13:16:19 <ozataman> Quantumplation: you can get the latest from: http://www.haskell.org/ghc/download_ghc_7_4_1
13:16:21 <Quantumplation> which OS? Windows 7.  Haskell Platform 2011.4.0.0, GHC 7.0.4.  I'll try upgrading GHC, do I need to uninstall the platform first?
13:16:33 <ozataman> Quantumplation: typically, no. but I have no experience on Windows
13:17:16 <ozataman> the RecordWildCards pragma is definitely there
13:17:22 <ozataman> and it compiles for all of us
13:17:29 <honza> I have a simple script that reads a newline separated list of integers, quicksorts it and writes it to a different file. I understand that quicksort should be easily run on multiple cores. However, compiling with threaded and running -N4 makes it slower. What am I doing wrong?
13:17:34 <ozataman> I wonder if the problem is with Windows for some reason
13:18:54 <ski> b52 : there's an "All About Monads" tutorial which maybe helps
13:19:02 <ski> @google All About Monads
13:19:04 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
13:19:04 <lambdabot> Title: All About Monads - HaskellWiki
13:19:12 <hpaste_> “Popescu Andrei” pasted “execution error” at http://hpaste.org/67736
13:19:54 <Quantumplation> ozataman: The FAQ said it has been known to work with HP 2011.2.0.1... could my version be too new?  I thought it might be backwards compatible.
13:21:13 <andrei_> I have edited the get_pos function and now it compiles succesfuly however, the execution crashes with error :  Non-exhaustive patterns in function contains  http://hpaste.org/67736. How should I corectly call the function ? As I have said I want to pass parameters : direction and curent_tile and to return the new tile according to the direction.\
13:23:39 <Quantumplation> I love haskell, I just find it really hard to think about how I would program my problems lol
13:25:25 <keseldude> I find that a bottom-up approach works well in haskell
13:27:12 <Quantumplation> keseldude: Yea, that's usually how I approach it, but then I get like, 20 minutes in and end up starting over because I don't like how I structured the data or something.
13:29:09 <Quantumplation> Ozataman: Updating GHC didn't help =/ is there any way to get cabal to keep the src files on my computer so I can open it up and check if the compiler flag isn't there?
13:29:43 <c_wraith> Quantumplation: cabal unpack <package>
13:32:21 <Quantumplation> Yea, weird.  if I unpack it and look at the actual file, it doesn't have that flag...
13:32:59 <Quantumplation> It only has ExistentialQualification and OverloadedStrings
13:33:08 <Quantumplation> Quantification*
13:33:20 <c_wraith> Well, did you check what the .cabal file might set globally?
13:35:10 <Quantumplation> c_wraith: hm? when I cabal install snap, the code it's using is different from https://github.com/snapframework/snap/blob/master/src/Snap/Snaplet/Auth/AuthManager.hs the code in the repository.  and ozataman was saying it compiles fine for him.
13:36:41 <Quantumplation> it's not set in the .cabal file
13:36:55 <c_wraith> Well. I have no clue what error you're actually seeing...
13:37:47 <Quantumplation> Righto, here's the build I posted earlier: http://hpaste.org/67735
13:39:34 <c_wraith> huh. That syntax certainly requires that extension.
13:40:12 <parcs`> is there an ST monad transformer?
13:41:01 <c_wraith> parcs`: that's approximately equivalent to an IO transformer. Despite that, I think there's an experimental one on hackage.
13:41:24 <Ngevd> STT? ha
13:42:16 <c_wraith> Quantumplation: I'm not sure what you're getting. if I cabal unpack that version, I see five LANGUAGE pragmas at the top of the file
13:44:01 <Philippa> c_wraith: STT isn't /as/ screwed up as IOT
13:44:22 <Quantumplation> =/ does Cabal switch which code it's using based on OS?
13:44:24 <Philippa> I mean, obv. it needs implementation hacks
13:44:37 <c_wraith> Philippa: it's true, you'd only need to be able to undo mutation, rather than being able to undo all possible IO. :)
13:47:30 <Philippa> c_wraith: so if you can implement (modulo performance characteristics) ST purely...
13:48:10 <c_wraith> Isn't it pretty easy if you use something like Dynamic?
13:48:25 <nks> is a getChar function without echo to stdout  in ghc
13:48:52 <nks> sorry Is there a getChar function without echo to stdout  in ghc ?
13:49:54 <c_wraith> nks: haskeline has a function that gets a line of input without echoing it...
13:50:26 <c_wraith> nks: I wouldn't expect more than that functionality unless you start using a curses or vty wrapper
13:51:45 <parcs`> nks: hSetEcho
13:51:45 <nks> Thanks
13:52:04 <nks> I tried doing getCh :: IO Char getCh  = do hSetEcho stdin False 	        c <- getChar 	        hSetEcho stdin True 	        return c
13:52:10 <c_wraith> You probably will need to turn offline buffering, too
13:52:19 <c_wraith> err, turn off line buffer
13:53:00 <nks> how can I do that
13:53:15 <nks> also i'm getting  Parse error in pattern: hSetEcho
13:53:57 <c_wraith> nks: sounds like your formatting your code wrong
13:56:42 <nks> thanks, that fixed the error
13:57:53 <statusfailed> If I don't export a constructor for a GADT, I can't pattern match on it, right?
13:58:09 <c_wraith> correct
13:58:14 <statusfailed> coolbeans, thansk
13:59:13 * hackagebot ztail 1.0.2 - Multi-file, colored, filtered log tailer.  http://hackage.haskell.org/package/ztail-1.0.2 (DylanSimon)
14:00:48 <Quantumplation> weird.  the hackagedb source seems to differ from the git source / source that everyone else gets when they cabal unpack: http://hackage.haskell.org/packages/archive/snap/0.8.1/doc/html/src/Snap-Snaplet-Auth.html
14:01:37 <Luke> could you say that a partially applied function is a continuation?
14:01:50 <c_wraith> Quantumplation: that's a different file
14:02:05 <bitonic> Luke: why would you say that?
14:02:48 <Luke> bitonic: because some control state's been reified
14:03:01 <c_wraith> Quantumplation: the module giving you the compile errors, according to that paste, is Snap.Snaplet.Auth.AuthManager
14:03:11 <bitonic> Luke: I'm not sure I follow you
14:03:24 <Luke> bitonic: how about this: why isn't a partially applied function a continuation?
14:04:56 <nand`> is SHA-256 safe to apply to its own output?
14:05:22 <c_wraith> nand`: "safe"?
14:05:33 <nand`> by “safe” I mean “won't carry the risk of finding the output of the first iteration from the output of the second iteration”
14:06:24 <nand`> in other words; is it just as secure when hashing its own output for every single iteration?
14:06:44 <Luke> bitonic: "a continuation is an abstract representation of the control state of a computer program."
14:06:49 <Luke> from wikipedia
14:07:17 <c_wraith> nand`: secure? against what?
14:07:18 <bitonic> Luke: a "continuation" is a very abstract idea. let's say that is something that encodes the state of a computation and can be resumed by passing in some value
14:07:31 <bitonic> at least, that's the abstract notion I have associated with the word "continuation"
14:08:02 <ZettaShark> what does the operator "$=" do?
14:08:07 <Luke> bitonic: i'm thinking call/cc style continuations if you want a definition
14:08:16 <parcs`> ZettaShark: where do you see that
14:08:21 <c_wraith> honestly, I think it's a philosophy question to ask "is X a continuation?"
14:08:21 <parcs`> OpenGL?
14:08:27 <bitonic> so I guess I see where you're coming from, but it's out of the usual use of the word "continuation". but again my idea of continuation is pretty vague, so
14:08:34 <ZettaShark> yes
14:09:03 <Luke> bitonic: thanks - was just looking to bounce ideas off someone
14:09:23 <acowley> ZettaShark: see http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
14:09:29 <nand`> c_wraith: let me formulate it this way: given sha (sha x) is it feasible to find sha x
14:09:30 <bitonic> Luke: don't take that as a "yes". I definitely wouldn't call closures continuation, because that'd be confusing
14:09:32 <parcs`> ZettaShark: it's like an overloaded writeIORef
14:09:41 <bitonic> Luke: it's a matter of terminology really
14:09:45 <nand`> in particular when compared to the feasibility of finding x given sha x
14:09:57 <c_wraith> Continuation Passing Style? That has a solid definition. You can say "this code was written in continuation passing style." But when you look at the types associated with that, the value passed in as the continuation is just a function. Any function with the correct type is "a continuation".
14:10:23 <bitonic> c_wraith: no, not continuation passing style, continuations in general
14:10:24 <Luke> c_wraith: yeah - that's exactly what i'm thinking
14:10:33 <Luke> so maybe I mean CSP specifically?
14:10:40 <c_wraith> It's a continuation of *some* calculation
14:11:04 <bitonic> I'd say partial applications are definitely not CPS. CPS is when you explicitly pass functions in to process the result
14:11:07 <bitonic> it's a specific case
14:12:03 <bitonic> and in fact you wouldn't call normal Haskell code "CPS", otherwise the term CPS would lose its meaning :P
14:12:13 <ZettaShark> thanks!
14:12:42 <parcs`> nand`: wouldn't the input be guaranteed to be 32 bytes in the former case
14:13:01 <Luke> bitonic: I don't know if that's true: http://en.wikipedia.org/wiki/Continuation-passing_style
14:13:08 <Luke> bitonic: check out the example code of CSP style
14:13:11 <nand`> parcs`: yes
14:13:18 <Luke> bitonic: they're making everything into lambdas to delay evaluation (make it lazy)
14:13:36 <Luke> bitonic: since haskell's lazy, it is effectively building that same code in a thunk, no?
14:13:50 <bitonic> Luke: yeah but does that look like code you'd write normally? anyways this is a terminology argument and I don't want to get deep in it :P
14:14:15 <c_wraith> ShowS is CPS...
14:14:23 <c_wraith> sort of
14:14:25 <c_wraith> backwards
14:14:33 <Luke> "A function written in continuation-passing style takes as an extra argument: an explicit "continuation" i.e. a function of one argument."
14:14:36 <c_wraith> I guess that's entirely wrong :)
14:14:40 <Luke> just like c_wraith said
14:14:40 <bitonic> Luke: yeah
14:15:06 <Luke> you take a function of one argument, possibly with some state which you previously bound into the function when you partially evaluated it
14:15:35 <nexx> ShowS is DList, isn't it?
14:15:36 <parcs`> nand`: so in the case of brute forcing it the former would be less secure
14:15:45 <c_wraith> yeah, ShowS is DList
14:15:57 <bitonic> Luke: CPS is a way of writing code that is convenient somethimes, in which instead of returning the value directly, you pass a function that will process it
14:16:02 <parcs`> smaller search space, less collisions
14:16:06 <Luke> bitonic: so I guess I'd have to never return from the function I was in after calling the function of one argument which was passed in (the continuation)
14:16:18 <ski> Luke : CSP is Communicating Sequential Processes, which is different from CPS
14:16:24 <Luke> bitonic: which happens all the time in haskell
14:16:31 <Luke> ski: typos =)
14:16:37 <ski> just making sure
14:16:41 <nand`> parcs`: I'd assume so as well; I just asked since a hashing function f where f.f = f could exist
14:16:43 <Luke> yeah - thanks =)
14:17:06 <bitonic> Luke: if you're talking about continuations in general, maybe. it's not important anyway
14:17:23 <Luke> bitonic: no not important at all... just thinking about it
14:17:33 <Luke> anyway you've helped me clear up my ideas a ton. thanks guys
14:17:35 <Luke> afk
14:17:46 <ski> Luke : passing in functions as arguments to process stuff doesn't automatically make the code being written in CPS
14:17:58 <ski> @src map
14:17:58 <lambdabot> map _ []     = []
14:17:58 <lambdabot> map f (x:xs) = f x : map f xs
14:18:04 <ski> isn't in CPS, e.g.
14:18:34 <Luke> ski: that's not CPS because it depends on the return value of map =)
14:19:02 <Luke> "4:15 PM <Luke> bitonic: so I guess I'd have to never return from the function I was in after calling the function of one argument which was passed in (the continuation)"
14:19:13 <ski> it's not in CPS because not every (except "primitive") call is a tail call
14:19:14 <Luke> i agree with that for sure
14:20:57 <ski>   mapCPS f [    ] k = k []
14:20:58 <ski>   mapCPS f (a:as) k = f a (\b -> mapCPS f as (\bs -> k (b:bs)))
14:21:02 <ski> however, is in CPS
14:21:49 <ski> (the (non-tail) call to `(:)' here counts as a "primitive" call)
14:24:14 * hackagebot storablevector 0.2.8 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.8 (HenningThielemann)
14:24:17 * hackagebot synthesizer-core 0.5.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.5.1 (HenningThielemann)
14:24:18 * hackagebot split-record 0.1.1 - Split a big audio file into pieces at positions of silence  http://hackage.haskell.org/package/split-record-0.1.1 (HenningThielemann)
14:37:30 <hayashi> @pl \x -> f *> g x
14:37:31 <lambdabot> (f *>) . g
14:39:17 * hackagebot tfp 0.4 - Type-level programming library using type families  http://hackage.haskell.org/package/tfp-0.4 (PeterGavin)
14:46:19 <ClaudiusMaximus> why are file format designers so totally insane?  "a comment can actually be in the middle of what you might consider a token" http://netpbm.sourceforge.net/doc/pbm.html
14:48:03 <merijn> ClaudiusMaximus: Have you ever seen the specs for OpenType/TrueType fonts? Or worse, PDFs...
14:49:14 <ClaudiusMaximus> merijn: nope.  but if "the simplest lowest common denominator monochrome image format" is that bad, i can't imagine the horror :)
14:50:23 <Botje> ClaudiusMaximus: it's not just file formats.
14:50:37 <Botje> case in point, please look towards the "email hates the living" presentation that can be found on youtube.
14:51:20 <Botje> the quality is very bad, unfortunately
14:52:34 <ClaudiusMaximus> i think i'll just label my parser as "having bugs", it's not like i intend to use it for "loading every .pbm that exists", and if someone cares enough they'll fix it for me :)  (or one rainy day, when i'm bored enough and lonely enough i might give it a go)
14:53:33 <acowley> ClaudiusMaximus: That is usually written as "Welcome to Hackage" if being honest, or "Experimental" if we're being formal.
14:54:09 <Quantumplation> Gah, I have no clue why snap won't compile.  On closer look, my copy of the source code DOES have the proper language flags, I just opened the wrong file on accident. >.<
14:54:32 <ozataman> Quantumplation: just unpack the tar.gz, cd to the folder and type "cabal install"
14:54:35 <ozataman> see if that does it for you
14:54:45 <ClaudiusMaximus> acowley: heh
14:54:47 <Quantumplation> alrighty
14:55:13 <efie> http://hpaste.org/67739 is the second version faster because there is no && operation?
14:57:07 <Quantumplation> ozataman: yea, no dice =/
14:57:18 <ozataman> wow
14:57:44 <Quantumplation> is there something I need to do to make GHC actually use the language flags?
14:57:50 <ozataman> Quantumplation: ok, see the "extensions" part in snap.cabal?
14:57:56 <ozataman> add RecordWildCards to it
14:58:10 <ozataman> Quantumplation: not at all - I have never seen/heard this problem you're having before
14:59:03 <acowley> inexplicable build failures are sometimes addressed by nuking GHC/Cabal.
14:59:58 <LeNsTR> efie, nope
15:00:37 <efie> so they are equivalent regarding effiency?
15:01:09 <LeNsTR> I guess
15:01:21 <Quantumplation> that worked ozataman, but it installed in a weird location, can I change the install path?
15:01:49 <ozataman> Quantumplation: there are some cabal flags, but it should install to where your cabal install command always installs to
15:02:01 <mog_> I'm trying to define a new operator &&& that is the conjunction of two boolean functions but I can't get it right: http://hpaste.org/67740 any help appreciated!
15:02:27 <acowley> efle: they have different strictness
15:02:28 <sajith> People! Can alex be a build dependency?
15:02:29 <Quantumplation> ozataman: This is the first time I'm using cabal =P  i've used haskell before, but always just playing around with the compiler, never had to work through dependencies
15:02:53 <ozataman> Quantumplation: I would not mess with where it installs to unless it's real important
15:02:54 <acowley> > let f v1 v2 | v1 && v2 = True | otherwise = False in f False (error "Boom!")
15:02:55 <lambdabot>   False
15:03:06 <ozataman> it'll install to somewhere common for your current user
15:03:13 <acowley> > let g True True = True in g False (error "Boom")
15:03:14 <lambdabot>   *Exception: <interactive>:3:4-21: Non-exhaustive patterns in function g
15:03:35 <acowley> well that's not quite what I wanted
15:04:57 <parcs`> sajith: no but it can be a build tool. instead of adding it to the build-depends field add it to the build-tools build
15:05:00 <parcs`> field*
15:05:33 <sajith> parcs`: thanks!
15:09:17 * hackagebot happstack-lite 7.2.0 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.2.0 (JeremyShaw)
15:09:42 <acowley> I hope there's a UselessStuff package to complement that
15:09:56 <stepcut> acowley: :)
15:11:31 <fliiipy> whats the opposite of tails?
15:11:42 <acowley> fliiipy: inits
15:11:45 <fliiipy> thanks.
15:12:22 <parcs`> :t ?a `min` ?b `max` ?c -- this is neat
15:12:23 <lambdabot> forall a. (?a::a, ?b::a, Ord a, ?c::a) => a
15:12:40 <stepcut> I wonder how inits / tails made it past the bike shedding committee
15:13:13 <stepcut> ...but only in a rhetorical way
15:14:27 <acowley> Let's propose a name change!
15:19:18 * hackagebot synthesizer-core 0.5.2 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.5.2 (HenningThielemann)
15:19:33 <hpaste_> statusfailed pasted “Data Lens Example Compilation Failure” at http://hpaste.org/67742
15:19:41 <statusfailed> Can anyone help me with that error ^
15:19:41 <statusfailed> ?
15:19:54 <statusfailed> I think it's something to do with packages, but I can't figure it out
15:20:20 <eviltwin_b> an error like that means you have dependecies on multiple versions of the same package
15:20:55 <statusfailed> Ah ok, should I unregister and re-register?
15:21:15 <eviltwin_b> fixing it is harder, you need use cabal install -v to see what is pullling in what versions and rebuild stuff to get it all using the same version
15:22:00 <statusfailed> eek
15:22:00 <statusfailed> ok
15:25:19 <statusfailed> eviltwin_b: -v seems only to list dependencies of data-lens on other things?
15:26:51 <statusfailed> I tried `ghc-pkg unregister `data-lens`, and then reinstalling, but that hasn't helped :\
15:33:29 <tromp> > 1814400/2**21
15:33:29 <lambdabot>   0.86517333984375
15:34:49 <Ngevd> A thought occurs
15:34:56 <Ngevd> My family tree program
15:35:07 <Ngevd> ...nah
15:36:50 <clintm> Suddenly, a wild Thought appears!
15:37:04 <clintm> It uses Distract!  It's super effective!
15:37:38 <Ngevd> I'm annoyed that text and aeson have conspired to render my library GHC-only
15:38:22 <bitonic> Ngevd: the chances or writing a even medium sized GHC-and-Hugs program that actually does something are quite slim these days.
15:38:33 <bitonic> it's not too hard but pretty hard
15:38:38 <Ngevd> Especially as I'm only using them for Serialization?
15:39:11 <bitonic> Ngevd: if you really care about you you could fork aeson. do you need Hugs for some reason?
15:39:13 <byorgey> what about GHC-and-UHC?
15:39:30 <bitonic> byorgey: never tried that combination
15:39:32 <Ngevd> I could use binary, which is GHC-and-Hugs
15:39:41 <Ngevd> But I lust for universality
15:39:52 <bitonic> byorgey: the only times I had to be compatible is because my uni generally uses Hugs
15:40:01 <Ngevd> How compatible is cereal?
15:40:25 <bitonic> Lemmih usually writes pretty portable programs
15:40:40 <bitonic> iirc lemmih wrote cereal
15:41:14 <bitonic> mhm it uses MagicHash
15:41:49 <bitonic> Ngevd: why do you need Hugs? I'm curious
15:42:01 <Ngevd> I really don't.
15:42:18 <bitonic> ah. then stop worrying :P
15:42:29 <byorgey> Ngevd never said anything about Hugs.
15:42:49 <byorgey> making portable programs is a fine goal.
15:42:53 <bitonic> byorgey: <Ngevd> I could use binary, which is GHC-and-Hugs
15:43:00 <Ngevd> I kinda want to release this library, and would like it to work on as many compilers as possible
15:43:38 <bitonic> Ngevd: the problem is that what's on hackage is very often GHC dependent, or relying on later versions of base/other stuff in the HP
15:43:45 <bitonic> or incompatible namespaces
15:43:49 <bitonic> it's pretty tricky
15:44:37 <bitonic> that said, it is a nice thing, and you can probably get a lot of programs working with Hugs if you don't have many depedencies
15:44:42 <bitonic> I don't know about other compilers
15:45:16 <nand`> After a day of coding Haskell: 30 open tabs. 1 on github, 1 on the project page and 28 opened to hackage.haskell.org
15:47:24 <Quantumplation> Wow, reading about how Snap is organized, this is really cool.
15:47:51 <bitonic> byorgey: is UHC usable with hackage programs, in your experience? because UHC isn't on hackage, so I've never actually installed it
15:50:39 <bitonic> there's also jhc, which is impressive considering it's a one-man project
15:52:32 <DukeDave> : 3 + 4
15:53:18 <Ngevd> But yeah, I'm not using any extensions to Haskell, and the trickiest thing I'm using is the curly-bracket thing that may be called record syntax
15:54:13 <bitonic> Ngevd: that's standard haskell
15:54:21 <Ngevd> Yeah, exactly
15:54:25 <bitonic> oh ok :)
15:54:47 <Ngevd> I really, really want this to work across as many compilers as possible
15:55:24 <Ngevd> (is it bad that I found record syntax harder to grasp than both monads and zippers?)
15:55:27 <bitonic> Ngevd: I guess the usual `json' library is not good enough for some reason?
15:55:42 <Ngevd> I don't think I saw the json library
15:55:43 <ski> record syntax is a bit counter-intuitive
15:56:07 <bitonic> Ngevd: oh, is the one that comes with the HP. it's quite portable iirc.
15:56:25 <bitonic> (btw, you can use cabal with Hugs using the flag --hugs, in case you didn't know)
15:56:28 <DukeDave> Are there any FieldTrip people around?
15:56:31 <Ngevd> HP?
15:56:33 <timthelion> Ngevd: do you have a lot of imperitive programming experience?
15:56:41 <startling_> so if I wanted to define >>= in terms of >=>, would ax >>= b = (a >=> b) x be valid?
15:56:46 <Ngevd> timthelion, not very much
15:57:08 <Ngevd> timthelion, I did a bit of Python, but I found functional programming easier?
15:57:27 <Ngevd> Well, Haskell at least. Never actually tried ML or Lisp or anything
15:57:27 <timthelion> Ngevd: Well you're going to have very different learning curves from the rest of us.
15:57:33 <Ngevd> Aaaaaah
15:57:59 <timthelion> Ngevd: it is probably easier to learn haskell if you don't know C...
15:58:03 <ski> startling_ : no, `ax' is unused, and `a' and `x' is unbound
15:58:15 <Ngevd> timthelion, trying to learn C off-and-on at the moment
15:58:17 <Ngevd> It's quite hard
15:58:40 <Ngevd> Anyway, is there a way for Cabal to create the documentation of an installed package without installing it?
15:58:45 <timthelion> Ngevd: C is a very hard language.  Most people who write in C don't understand it.
15:58:53 <Ngevd> *reinstalling
15:59:26 <ski> startling_ : though i suppose `ma >>= amb = ((\() -> ma) >=> amb) ()' would be fine
15:59:57 <ski> or `ma >>= amb = (const ma >=> amb) anything_here', if you prefer
16:00:14 <Ngevd> cabal install mtl --reinstall --enable-documentation --dry-run?
16:00:34 <startling_> ski: Hm, okay, thanks
16:00:46 <Ngevd> nopw
16:00:59 <bitonic> timthelion: I disagree, but ok ehe
16:01:13 <bitonic> actually C programmers usually understand what's going on more than other programmers, in my experience
16:01:26 <startling_> ski: I'm not sure what you mean by unbound and unused. care to explain?
16:01:29 <ski> (startling_ : in short, no you can't pattern-match on `a x', and expect to get two separate values `a' and `x' to use in the definiens)
16:01:41 <timthelion> bitonic: I didn't say "C programmers" I said "most people who write C" ;)
16:01:47 <startling_> oh okay. yeah, that makes sense
16:02:05 <bitonic> timthelion: wouldn't those be C programmers? anyway,  it's not important
16:02:26 <ski> startling_ : if you write `f x y = ..x..y..', then this function definition bounds the variables `x' and `y', so that they can be used in the definiens `..x..y..' (and also in any `where' clause attached to the defining equation of `f')
16:02:47 <ski> startling_ : if you write `f (x:xs) = ..x..xs..', then this binds `x' and `xs'
16:02:54 <ski> (s/bounds/binds/)
16:03:19 <startling_> right, okay. thanks for your help!
16:03:24 <ski> startling_ : similarly, if you write `ax >>= b = ...', this is basically just another way of writing `(>>=) ax b = ...'
16:03:43 <ski> and `ax' is a variable name that is different from `a' and `x'
16:03:44 <Ngevd> Oh, hey, it's tomorrow
16:03:56 <ski> it doesn't (in any sensible sense) consist of `a' and `x'
16:04:32 <ski> > let tomorrow d = d + 1; today = tomorrow today in today
16:04:36 <lambdabot>   mueval-core: Time limit exceeded
16:05:44 <Quantumplation> What's "Literate Haskell"?
16:06:09 <Ngevd> An alternative style for writing Haskell code that encourages a lot of comments
16:06:19 <QinGW> hi, all
16:06:28 <Ngevd> Comments are default, and actual code lines begin with a '>'
16:06:33 <Ngevd> Hello, QinGW
16:07:16 <nand`> Quantumplation: regular Haskell except everything is a comment by default, with codelines either prepended by “> ” or surrounded by “\begin{code}” and “\end{code}” tags
16:07:44 <Quantumplation> Ah ok
16:08:07 <nand`> it's great for writing LaTeX documents; since you can simply keep the code and report in the same file
16:11:17 <QinGW> hi ngevd
16:11:35 <Ngevd> Is it bad that when I'm writing code dealing with a lot of tuples, I end up with functions called "unvindaloo" and "madras" ?
16:11:54 <Ngevd> (these generally mean something like uncurry5 and curry4
16:11:56 <Ngevd> )
16:12:19 <nand`> at that point I'd stop using tuples and start using specialized types
16:12:25 <bitonic> Ngevd: yes
16:12:40 <Ngevd> This is just when I'm playing around, mainly
16:12:47 <Ngevd> I can't recall them in a finished program
16:13:04 <zomg> What exactly does a ~ mean in a type signature? I don't recall seeing it ever mentioned in RWH or anywhere else I've looked
16:13:18 <bitonic> zomg: type equality, in the context of type families
16:13:26 <burbul> @hoogle (.:)
16:13:26 <lambdabot> No results found
16:13:36 <nand`> (.:) = (.).(.)
16:13:44 <bitonic> well, in general actually, but you need TypeFamilies
16:13:57 <burbul> Thanks
16:14:00 <burbul> Do you know where it is defined?
16:14:02 <jfischoff>  Quantumplation: The algo you described early, with the tiles. Maybe if you think of the primitives as forming a graph, you can trace paths to find the compound objects. That might be faster then trying every combo
16:14:17 <zomg> bitonic: I see.. found the docs regarding that now. Thanks
16:14:20 * hackagebot tfp 0.5 - Type-level programming library using type families  http://hackage.haskell.org/package/tfp-0.5 (PeterGavin)
16:14:29 <nand`> burbul: in lambdabot as far as I am aware
16:14:44 <burbul> @pl (.).(.)
16:14:44 <lambdabot> (.) . (.)
16:14:47 <burbul> @pf (.).(.)
16:14:48 <lambdabot> Maybe you meant: bf pl
16:15:01 <burbul> @pl (.:)
16:15:01 <lambdabot> (.:)
16:15:04 <nand`> @unpl (.).(.)
16:15:05 <lambdabot> (\ i b c f -> i (b c f))
16:15:14 <burbul> @unpl (.:)
16:15:14 <lambdabot> (.:)
16:16:35 <Ngevd> Well, goodnight
16:17:44 <Quantumplation> jfischoff: Hrm... That sounds promising.  Can you elaborate a bit more? I'm having trouble working through it in my mind.
16:19:21 * hackagebot highlighting-kate 0.5.0.6 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.6 (JohnMacFarlane)
16:20:56 <jfischoff> Quantumplation: Imagine that each tile just has two sides for simplicity. Each of your nodes have connections to other nodes if their output matches a node's input. (I think that case you have a category).
16:22:49 <jfischoff> Quantumplation: does that make sense?
16:22:49 <Quantumplation> oh hey woa
16:22:55 <Quantumplation> that actually does
16:23:26 <Quantumplation> sort of
16:23:30 <Quantumplation> at least it did for a minute
16:23:53 <jfischoff> Quantumplation: Well I'm not sure if I totally understand your problem ;)
16:24:11 <Quantumplation> hehe, the idea is as a sort of super abstract simulation of chemistry
16:24:21 <hpaste_> “Eduard - Gabriel Munteanu” pasted “Adjunctions from monads” at http://hpaste.org/67745
16:24:37 <Eduard_Munteanu> Ok, so I managed to automatically get an adjunction from a monad... http://hpaste.org/67745
16:24:57 <Eduard_Munteanu> Any idea if I can get a corresponding comonad in Hask from a monad this way?
16:25:00 <jfischoff> Quantumplation: generalizing to the six sided case just means each tile is actually several nodes
16:25:39 <EvanR> chemistry per se is already abstract
16:26:10 <Eduard_Munteanu> I can get the monad back from the adjunction from the monad, to say so, but the comonad will land in Hask_M if I go that way, it seems.
16:27:14 <Quantumplation> jfischoff: suppose I specify tiles as "AB" where A is the left glue and B is the right node.  say I start with the tileset [AB, BC, DB, CE].  The resultant tile set should be something like [AB, ABBC, ABBCCE, BCCE, DB, DBBC, DBBCCE, CE]
16:28:15 <Quantumplation> so, what you're saing is that [AB, BC, DB, CE] each become nodes, then I draw directed edges when the left matches the right and look for paths in the resultant structure?
16:29:14 <burbul> @pl f x = g . h x
16:29:15 <lambdabot> f = (g .) . h
16:29:38 <burbul> @pl f g h x = g . h x
16:29:39 <lambdabot> f = (.) . (.)
16:30:31 <jfischoff> Quantumplation: I think so yes. Build the graph of how the initial parts connect. Then to find the compound structures trace paths in the graph. That way you are not continuously checking if the nodes compose.
16:30:46 <Quantumplation> yes yes
16:30:58 <Quantumplation> it definitely works in the 1D case
16:31:38 <stepkut> how can I include > {-# LANGUAGE QuasiQuotes #-}, in my haddock documentation. It gets stripped out and every trick I have tried to use to escape it has failed me
16:32:10 <jfischoff> Quantumplation: It works in the six side case too. Your representing a hypergraph with a graph. Its not a problem
16:32:20 <ski> Eduard_Munteanu : yes, the comonad will appear in the kleisli category, i think
16:32:49 <burbul> @src fmap
16:32:49 <lambdabot> Source not found. :(
16:32:55 <burbul> Why does that happen?
16:33:08 <EvanR> fmap is a class method
16:33:21 <burbul> oh, of course
16:33:21 <EvanR> implementation is different for each instance of Functor
16:33:22 <burbul> sorry
16:33:47 <burbul> The thing I actually tried first was
16:33:47 <burbul> @src (:.)
16:33:48 <lambdabot> Source not found.
16:33:56 <burbul> Then I started putting in random functions...
16:34:01 <EvanR> :t (.:)
16:34:02 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:34:07 <EvanR> :t (.) . (.)
16:34:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:34:09 <Quantumplation> jfischoff: how would I detect overlaps in this case?
16:34:21 <Eduard_Munteanu> ski: hm, so I guess there's no way to get a comonad on Hask from a monad on Hask, at least via the Kleisli construction? I guess C and C_T aren't equivalent or isomorphic, no?
16:34:31 <jfischoff> Quantumplation: not sure what those would be
16:34:33 <burbul> Thanks!
16:34:43 <burbul> Is there a way  of finding what file it's defined in?
16:34:47 <burbul> hoogle doesn't help
16:34:54 <Eduard_Munteanu> s/C/Hask/ in this case
16:35:01 <EvanR> burbul: .: isnt in any file, that i know of
16:35:06 <EvanR> because you havent put it there yet
16:35:07 <burbul> oh i see
16:35:24 <burbul> That's what nand` meant by saying it's defined in lambdabot?
16:35:25 <Quantumplation> say you have some tile graph constructed as above, but in 2D (or 3D).  If you follow a path that takes you "bottom glue", "right glue", "top glue", you can then follow "right glue", as that would case you to bump into the first time.
16:35:26 <burbul> I misunderstood
16:35:43 <burbul> I assumed it would be from a standard library
16:35:44 <Quantumplation> i'd have to accumulate some position over the path
16:35:51 <Quantumplation> to see if the same position occured twice
16:35:54 <Quantumplation> right?
16:35:57 <EvanR> see also .::
16:36:00 <EvanR> and so on
16:36:03 <burbul> :t (.::)
16:36:03 <EvanR> :t (.::)
16:36:04 <lambdabot> Not in scope: `.::'
16:36:04 <lambdabot> Not in scope: `.::'
16:36:07 <Eduard_Munteanu> Or hm... wait a minute...
16:36:11 <EvanR> :t (.) . (.) . (.)
16:36:11 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
16:36:13 <jfischoff> Quantumplation: Yeah if that is problem.
16:37:30 <hpaste_> DukeDave pasted “Problem cabal install'ing reactive” at http://hpaste.org/67746
16:37:45 <DukeDave> Has anyone seen this before ^
16:37:50 <ski> Eduard_Munteanu : for the first question, i think the answer is no. what is `C_T' here ? the kleisli category of the monad `T' over `C' ?
16:37:59 <Eduard_Munteanu> ski: yeah.
16:39:07 <Quantumplation> jfischoff: hrm, wait, this might not work.  Suppose you have this graph structure for a tileset that never terminates.  That would be equivalent to the graph containing a cycle.  However, as this is a turing complete model, that would imply that finding a loop in the graph solved the halting problem.
16:39:07 <Eduard_Munteanu> Hm, what if I have Y -| F -| U... starting with a monad T = UF, maybe I can get a comonad W = YF.
16:39:22 <Eduard_Munteanu> Though it's not from the same pair of adjunctions.
16:39:28 <parcs`> gah working with stateful nested records sucks
16:39:38 <parcs`> even with fclabels
16:39:48 <jfischoff> Quantuplation: You can find cycles up to so max path limit
16:40:09 <Eduard_Munteanu> And I probably can't get an Y easily anyway.
16:40:16 <burbul> So (.).(.) f g h x = (.)((.) f g) h x = (.) (f.g) h x = ((f.g).h) x -- is that right>
16:40:19 <burbul> ?
16:40:32 <jfischoff> Quantuplation: if you graph is finite (enough) you will be fine
16:41:14 <parcs`> :t fmap fmap fmap
16:41:15 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:41:16 <Quantumplation> Well, no i mean, there are algorithms for finding cycles within graphs.  Hence, the implication being that if this system could be expressed as a graph, you could simply apply one of those algorithms and solve the halting problem.
16:41:26 <parcs`> burbul: (.).(.) f g x y = f (g x y)
16:41:53 <dmwit> burbul: The first equation doesn't look right.
16:41:55 <Quantumplation> So, since that can't be true, would it be true to say that this can't be expressed as a graph?
16:42:04 <nand`> > head cake
16:42:06 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
16:42:14 <ski> parcs`/burbul : it should be `((.) . (.)) f g x y'
16:42:26 <parcs`> yeah, oops
16:42:26 <jfischoff> you can find cycles in graphs
16:42:27 <dmwit> burbul: (.).(.) f g x = (.) (f .) g x
16:42:45 <Quantumplation> I know.
16:42:49 <ski> dmwit ^
16:42:56 <burbul> Ah -- I applied it on two arguments when I shouldn't have. Thanks.
16:43:07 <dmwit> ski: oh, quite right
16:45:24 <hpaste_> nand` pasted “lambdabot imports” at http://hpaste.org/67747
16:45:35 <nand`> burbul: with any luck (.:) should be somewhere there ^
16:45:53 <Quantumplation> You can express a universal turing machine in this tile system.  From there, express this construction as a graph as you described.  From there, find cycles within the graph.  If a cycle exists, the tiles evolve infinitely.  If there is no cycle, the tiles do not evolve infinitely.  This is a contradiction since you cannot determine whether a turing machine would halt.
16:46:50 <burbul> thnaks
16:47:01 <burbul> But I don't understand why Hoogle doesn't index if it's in one of those files...
16:47:27 <nand`> burbul: oh; nvm, .: isn't in lambdabot by default; it must have been added to this particular lambdabot's L.hs
16:47:44 <burbul> i see
16:50:20 <fiacre> \join xmonad
16:50:53 <burbul> (.).(.) f g x y = (.) (f .) g x y = ((f.) . g) x y = ((f.)(g x)) y = f (g x y)
16:51:00 <burbul> That looks right! Thank you, everyone.
16:51:45 <parcs`> > fmap fix return 3
16:51:46 <lambdabot>   3
17:12:53 <jfischoff> anyone used the new GHC.Generics?
17:13:23 <jfischoff> for some reason my selector name is blank, even though I am using record syntax
17:27:50 <randomclown> hey what's the equvalent for enum flags in haskell?
17:28:08 <dmwit> data MyWackyEnum = R | G | B
17:28:37 <randomclown> that can't do flags though
17:28:44 <dmwit> I have no idea what you mean.
17:28:47 <dmwit> What are flags?
17:29:07 <Eduard_Munteanu> What sort of flags, the stuff you can combine using bitwise ops?
17:29:12 <randomclown> yeah
17:29:23 <jfischoff> just write a function that returns the flags
17:29:26 <dmwit> data MyWackyEnum = R | G | B
17:29:27 <Eduard_Munteanu> You can just use lots of Bools.
17:29:40 <dmwit> type SetOfMyWackyEnum = Set MyWackyEnum
17:29:57 <wli> Is there a memo idiom / "pattern" for things like binomial coefficients, where f(n+1, k) = a(n,k) * f(n, k) + b(n, k) * f(n, k-1) ?
17:30:00 <dmwit> optionally
17:30:07 <dmwit> type SetOfMyWackyEnum = MyWackyEnum -> Bool
17:30:29 <randomclown> ah ok
17:30:32 <wli> (There are two kinds of Stirling numbers and two kinds of Eulerian numbers of the same sort of pattern.)
17:30:37 <Eduard_Munteanu> data Flagz = Flagz { hazMoney :: Bool; hazFood :: Bool; ... }
17:31:02 <brisbin> defaultFlags = Flagz False False -- :(
17:31:22 <dmwit> instance Default Flagz where def = Flagz def def -- :)
17:31:48 <dmwit> I wonder if there's a bit of TH somewhere for deriving Default instances.
17:32:08 <brisbin> i love Data.Default
17:32:20 <dmwit> It's like the best three lines of code on Hackage.
17:32:25 <brisbin> exactly!
17:35:19 <jfischoff> dmwit: making the generic verison would be very straight forward
17:37:13 <dmwit> jfischoff: DO EET!
17:37:24 <dmwit> I'll give you sweet, sweet karma on reddit or lambdabot, your choice.
17:37:26 <jfischoff> dmwit: I'm gonna!
17:37:48 <jfischoff> dmwit:okay lets go
17:40:56 <dmwit> Using Set MyWackyEnum or MyWackyEnum -> Bool have the advantages that there's already a Default instance.
17:41:46 <BMeph> (RE: Frank) So, is Conor just super-bored, or what? :)
17:42:37 <jfischoff> BMeph: it looked cool
17:43:18 <copumpkin> Cale: I haz new question about that wonky fingertree I was asking about the other day. If you remember, it had three monoids, two sums and one last. What if I wanted to add a fourth, priority-like (max) one, but have it behave like an independent priority queue per "key" of the map? Do I need to use nested fingertrees for that, or is there a way I can keep it flat?
17:44:28 <dmwit> copumpkin: Use a (Map k (MaxPriority v)) as the monoid.
17:44:46 <copumpkin> hmm
17:44:51 <dmwit> m `mappend` m' = unionWith mappend m m'
17:44:58 <dmwit> Dunno if that instance exists already or not.
17:45:08 <copumpkin> that's a complicated monoid! seems like it'd be easier just to nest them fingertrees
17:45:11 <hpc> mappend = unionWith mappend?
17:45:17 <dmwit> hpc: yes
17:45:27 <hpc> (looks less silly that way)
17:45:32 <dmwit> I'm quicker at thinking pointfully, though.
17:46:09 <dmwit> copumpkin: Wait, do you really mean it when you say it seems easier to nest fingertrees than write this two-line monoid instance?
17:46:37 <copumpkin> well, maybe not easier, but not much more difficult :)
17:46:46 <dmwit> huh
17:46:48 <copumpkin> but I'll try your approach out :)
17:47:05 <dmwit> Well, I mean, you're the one writing the code, use your judgment. =P
17:47:11 <copumpkin> :D
17:55:07 <copumpkin> dmwit: using that Map as a monoid feels very nonlocal, though
17:55:29 <copumpkin> oh, I guess I see
17:56:30 <dmwit> Nonlocal in what sense?
17:56:43 <copumpkin> nah, I was thinking of it wrong :)
17:58:23 <copumpkin> gah, map already has a monoid instance, but it's a stupid one
17:58:33 <dmwit> Boooo.
17:59:08 <dmwit> Oh, that is a stupid one.
17:59:56 <dmwit> That's not the kind of thing that you'll ever convince libraries@ to delete or replace, either.
18:00:03 <copumpkin> yeah, but I'm gonna try anyway
18:00:03 <copumpkin> :P
18:00:23 <dmwit> \o/
18:00:31 <dmwit> People like you make the world better.
18:02:10 <magicman> http://hackage.haskell.org/trac/ghc/ticket/1460
18:02:13 <hpaste_> “Jonathan Fischoff” pasted “GenericDefault” at http://hpaste.org/67750
18:02:28 <jfischoff> dmwit: check it out
18:02:50 <copumpkin> magicman: ah, thanks! I'll link that to the email and try to get discussion going again
18:03:27 <scooty-puff> i had heard of an extension that allowed a subclass to define default methods for a parent class
18:03:30 <scooty-puff> is this already in ghc?
18:03:52 <Quantumplation> Um, wow.  I just realized how fast (n^3)! grows...
18:04:20 <Quantumplation> http://www.wolframalpha.com/input/?i=%28n%5E3%29%21
18:04:25 <dmwit> jfischoff: needs DeriveGeneric here
18:04:35 <dmwit> jfischoff: but awesome!
18:04:42 <jfischoff> yeah, sorry I copied the test into it
18:04:43 <tnzr> "The greatest shortcoming of the human race is our inability to understand the exponential function"   -- Albert Bartlett
18:04:46 <jfischoff> for the paste
18:04:49 <jfischoff> cool
18:04:53 <jfischoff> got to run
18:04:58 <tgeeky> tnzr: is that the Boulder guy?
18:05:07 <hpc> Quantumplation: not so bad; still computable for n up to 4
18:05:08 <tgeeky> yep
18:05:09 <hpc> :P
18:05:12 <tnzr> tgeeky: yah
18:05:25 <tgeeky> tnzr: one of the most convincing video series ever
18:06:44 <dmwit> jfischoff++
18:07:15 <tnzr> tgeeky: indeed, we live in an interesting time
18:07:46 <dmwit> ?ask jfischoff Will you package up data-default-generic, or shall I? =)
18:07:46 <lambdabot> Consider it noted.
18:08:15 <tgeeky> dmwit: are you going to be communicating with semaphores next? That's a little indirect, isn't it? :o
18:08:38 <dmwit> tgeeky: Well, he just said he was leaving.
18:08:39 <jfischoff> dmwit: go for it!
18:08:39 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:03 <dmwit> alrighty!
18:09:08 <tgeeky> dmwit: hehe. true enough. and technically correct. which is the best kind of correct!
18:09:29 <thiagomds_> Hello people my name`s Thiago, I`m from Brazil - Rio de Janeiro, it`s my first time here
18:09:57 <dmwit> Welcome, thiagomds_!
18:10:06 <dmwit> What are you doing with Haskell?
18:10:08 <thiagomds_> thank you
18:11:25 <thiagomds_> my friend send a email to say about Haskell and I want to know what is it.
18:11:42 <dmwit> http://www.haskell.org/ has plenty of information.
18:13:00 <thiagomds_> I`m student computer science in Brazil and i`m beginning to program language C
18:13:05 <smop> thiagomds_: basically learning it makes you a better programmer than someone who doesn't know it
18:13:40 <ion> That applies to most languages.
18:13:59 <ion> assuming it’s not the only language you learn
18:15:31 <dmwit> mkdir should default to -p
18:16:20 <ion> mkdir -p defaults to -p. :-P
18:17:02 <kekimmo> alias mkdir="mkdir -p"
18:19:06 <Wizecoder> ugh yesod is a long install :(
18:22:26 <brisbin> Wizecoder: yeah it is
18:24:35 <lars_> any FP events around New York recently?
18:35:57 <wli> Okay, and there are Bernoulli numbers.
18:46:58 <hpaste_> wli pasted “Special numbers” at http://hpaste.org/67752
18:50:34 <fiacre> Thanks wli, Had never eard of hpaste.org
18:50:40 <dmwit> Can I pprint a Q Exp somehow?
18:50:52 <dmwit> To inspect the result of [e|3+3|], for example?
18:50:58 <Enigmagic> -ddump-splices
18:51:27 <rwbarton> runQ [e|3+3|]
18:51:51 <rwbarton> well that may not meet your "pprint" request
18:51:57 <rwbarton> Prelude Language.Haskell.TH> runQ [e|3+3|]
18:51:57 <rwbarton> InfixE (Just (LitE (IntegerL 3))) (VarE GHC.Num.+) (Just (LitE (IntegerL 3)))
18:52:06 <dmwit> Oh, I missed the instance Quasi IO.
18:52:15 <dmwit> No, no, that's just what I wanted. Thanks.
18:53:25 <rwbarton> Alternatively,   Prelude Language.Haskell.TH Control.Applicative> $(LitE . StringL . show <$> [e|3+3|])
18:53:28 <rwbarton> "InfixE (Just (LitE (IntegerL 3))) (VarE GHC.Num.+) (Just (LitE (IntegerL 3)))"
18:53:46 <dmwit> cute
18:54:00 <rwbarton> why you might prefer one over the other is left as an exercise to the reader
19:01:43 <dmwit> Why not instance MonadIO Q?
19:03:19 <nabil`> hi, total irc noob here, correct me if i'm in the wrong place or doing something wrong
19:03:36 <nabil`> i have a question about command line hoogle
19:04:09 <nabil`> i've run 'cabal install hoogle' and it seems to have worked just fine but when i run 'hoogle' nothing executes
19:04:24 <nabil`> everything online seems to indicate that it should, and i can't find anything on google about anyone else having the same problem
19:05:37 <rwbarton> cabal probably installed it to a place (~/.cabal/bin/) that's not on your $PATH
19:06:28 <penelope> I like to try and reproduce the standard file system in my home directory.
19:06:30 <penelope> So
19:06:55 <penelope> I move/link so that ~/.cabal/bin lives in ~/bin
19:07:36 <nabil`> yes, that's exactly it
19:07:38 <nabil`> thank you so much!
19:11:33 <wli> Let's see how to use GMap
19:14:26 * hackagebot hmatrix-repa 0.1.1 - Adaptors for interoperability between hmatrix and repa  http://hackage.haskell.org/package/hmatrix-repa-0.1.1 (VivianMcPhail)
19:21:46 * BMeph questions whether it's tactically wise for a package to be written by a "MacPhail"...
19:23:56 <geekosaur> if it requires Windows libraries... :p
19:30:30 <fiacre> Any one here uses xmonad?
19:31:33 * Saizan does
19:31:34 <brisbin> i do. there's also #xmonad
19:32:11 <fiacre> I know but I thought that there was not much activity...
19:32:34 <brisbin> there might be if you ask your question ;)
19:32:54 <fiacre> Ok I'll go there instead!
19:33:37 <brisbin> unfortunately, i'll probable answer quickets and i'm here too anyway...
19:33:45 <brisbin> quickest*
19:34:55 <fiacre> I ran into a wird problem today when compiling my config file on freebsd
19:36:03 <fiacre> I am using http://www.haskell.org/haskellwiki/Xmonad/Config_archive/Nnoell%27s_xmonad.hs
19:36:32 <fiacre> It was compiling great on Arch linux but on freeBSD I get a
19:37:29 * brisbin is on the edge of his seat
19:37:40 <fiacre> Context reduction stack overflow; size = 21
19:37:40 <fiacre>     Use -fcontext-stack=N to increase stack size to N
19:37:42 <monochrom> http://www.vex.net/~trebla/haskell/module.xhtml \∩/
19:37:51 <yan_> hm i'm operating inside a "Maybe IO String" monad and i'm trying to use the do notation to receive a "Maybe String" value from a pure function, what would be the right way to do that?
19:38:20 <fiacre> So I tried using the compilation flag mentioned
19:38:28 <yan_> i.e. do {  foo <- func1; foo2 <- func2 }, and func1 returns a Maybe IO String, which is fine, but func2 returns Maybe String
19:38:48 <fiacre> It then compiles by I suspect xmonad's compiling my hs file at login
19:39:18 <fiacre> therefore it always crash.
19:40:04 <brisbin> fiacre: did you google "Context reduction stack overflow"
19:41:23 <fiacre> To be honest no... (shame on me). I will do this right now.
19:41:30 <magicman> @hoogle (a -> Maybe a) -> Set a -> Set a
19:41:30 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:41:30 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
19:41:30 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
19:41:54 <fiacre> I just thought it is bizard that it works on arch and not on bsd.
19:42:32 <brisbin> how did you install xmonad on bsd?
19:43:17 <fiacre> Using the ports.
19:43:36 <fiacre> Note: A basic config file works.
19:44:13 <fiacre> Also, Noels config file works when commenting the line: ", layoutHook         = myLayoutHook"
19:44:38 <fiacre> So it's some problem with the layout hook causing a overflow at compile time.
19:44:57 <brisbin> i don't know what Noels config is. but the best thing to do to test-compile your config in stages and isolate the issue
19:45:07 <brisbin> to do is to *
19:45:52 <fiacre> ?
19:46:15 <brisbin> the config you pasted compiles if you comment myLayoutHook?
19:46:28 <Brolapse> data Bla = Bla { username :: Username , score :: Score }
19:46:41 <Brolapse> i dont understand how you use this
19:47:15 <Brolapse> if it was a tuple (username,score) can just do (s1,s2) <- bla
19:47:32 <brisbin> b = Bla "Steve" 10; main = hPutStrLn $ userName b
19:47:38 <fiacre> Yes it does. The I tried to go into the code called by myLayoutHook but it seems that every line is important to the function (which Im not sure to understand by the way)
19:48:16 <brisbin> fiacre: it looks fine to me except for (!!) and mkToggle, those look custom
19:48:50 <Brolapse> brisbin, so you can access fields by "userName b"
19:49:00 <brisbin> Brolapse: if b is :: Bla
19:49:33 <randomclown> how would one typically split a data declaration across multiple lines
19:49:41 <fiacre> Does xmonad recompiles xmonad.hs every time one launches xmonad?
19:49:47 <Brolapse> so to assign things to it b = Bla "Steve" 10, "Bad luck Brian" -99
19:49:55 <randomclown> i.e. data lotsoftypes = type 1 { lots of stuff } | type 2 { lots of stuff }
19:49:57 <randomclown> ...
19:49:58 <brisbin> fiacre: if M-q is xmonad --recompile which does.
19:50:34 <brisbin> randomclown: data X = X<enter><tab>{ foo :: Foo<enter><tab>, bar :: Bar (aligned with :: Foo) ...
19:50:44 <fiacre> Well I meen at boot time
19:50:54 <randomclown> where does the pipe go?
19:50:58 <randomclown> :brisbin
19:51:03 <ski>   data Blah a = Con0 {...}
19:51:08 <brisbin> fiacre: if a valid binar is still there it won't recompile at start up
19:51:09 <ski>               | Con1 {...}
19:51:10 <ski>                 deriving (...)
19:51:18 <randomclown> ah ok
19:51:25 <brisbin> randomclown: data A = A<enter>| B (aligned with | A) ...
19:51:30 <ski> randomclown : like that, aligned under the `=', i think looks prettiest
19:51:34 <brisbin> yes, as ski did
19:51:41 <brisbin> and i broke (sorry)
19:52:10 <Brolapse> brisbin, how do you assign multiple peices of data to the data type
19:52:38 <brisbin> Brolapse: Bla "username" score
19:52:48 <brisbin> or b { userName = "new username" }
19:52:50 <fiacre> I will be busy for the next few minutes (Im compiling and relaunching xmonad and might crash my comp)
19:52:51 <brisbin> if b is :: Bla
19:53:06 <Brolapse> how to do multiple assignments
19:53:13 <ski>  Bla { userName = "username" , score = 13 }
19:53:28 <ski> that constructs a new `Bla'
19:54:06 <ski> you can also use any expression `b' instead, as brisbin suggested, which will then create a new record from the old one, overriding the specified fields
19:55:22 <brisbin> ski is better than i at speaking in "documentationese"
19:56:04 * ski grins
19:56:24 <ski> you just need some practice, my friend ;)
19:58:27 <cg_morton> what's the easiest way to coerce an Int to a Double?
19:58:37 <mauke> fromIntegral
19:58:45 <cg_morton> ah great, thakes
19:58:57 <cg_morton> (that's like 'thanks')
19:59:09 <fiacre> My bad! I actually modified Noels configuration (the actual workspace code) and I was doing "myWorkspaces !! 0". So I guess that there is something wrong with the !! 0. If I comment out this line all works.
19:59:23 <fiacre> (In theory)
20:00:13 <fiacre> At least in practice xmonad does not crash (and compiles).
20:00:38 <ZettaShark> What is "!! 0"?
20:01:01 <brisbin> isn't that array index access
20:01:14 <brisbin> that's basically, head
20:01:38 <mauke> s/array/list/
20:02:01 <fiacre> Yes but for some reason (will look into it in one moment) there may be nothing at position 0.
20:02:50 <cg_morton> so this apparently doesn't work:   map ( read :: Double ) ( words some_double_strings )     anyone know a syntax that will work?
20:03:09 <mauke> the syntax is fine
20:03:16 <mauke> the problem is that read is not a number
20:03:19 <mauke> it's a function
20:03:42 <cg_morton> ah, of course!
20:03:47 <cg_morton> thanks
20:04:02 <ion> > map (reads :: ReadS Double) (words "1 2 3")
20:04:03 <lambdabot>   [[(1.0,"")],[(2.0,"")],[(3.0,"")]]
20:04:14 <mauke> > read (words "1 2 3") :: [Double]
20:04:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:04:15 <lambdabot>         against inferred type...
20:04:18 <mauke> > map read (words "1 2 3") :: [Double]
20:04:19 <lambdabot>   [1.0,2.0,3.0]
20:05:23 <mauke> the nice thing about type inference is that you're free to annotate pretty much any use of an ambiguous value
20:05:39 <ion> > map (\s -> listToMaybe [ x | (x,"") <- reads s ]) (words "1 2 3") :: [Maybe Double]
20:05:40 <lambdabot>   [Just 1.0,Just 2.0,Just 3.0]
20:06:10 <brisbin> > let ns = map read (words "1 2 3") in foldl (+) 0 ns
20:06:11 <lambdabot>   6
20:06:17 <brisbin> or just let your usage tell the story
20:06:36 <mauke> > let ns = map read (words "1 2 3.0") in foldl (+) 0 ns
20:06:37 <lambdabot>   *Exception: Prelude.read: no parse
20:06:43 <mauke> > let ns = map read (words "1 2 3.0") in foldl (+) 0.0 ns
20:06:44 <lambdabot>   6.0
20:07:04 <brisbin> nice
20:07:05 <ion> > (Data.Traversable.sequenceA . map (\s -> listToMaybe [ x | (x,"") <- reads s ])) (words "1 2 3") :: Maybe [Double]
20:07:07 <lambdabot>   Just [1.0,2.0,3.0]
20:07:24 <ion> > (Data.Traversable.sequenceA . map (\s -> listToMaybe [ x | (x,"") <- reads s ])) (words "1 foo 3") :: Maybe [Double]
20:07:26 <lambdabot>   Nothing
20:13:33 <fiacre> Well thanks a lot brisbin. I will now reboot to test my changes. At least now it compiles.
20:13:59 <brisbin> haskell: if it compiles, it works (tm)
20:14:11 <copumpkin> dmwit: so what are my new asymptotics with maps as monoids!?
20:14:23 <copumpkin> I have a feeling they might stay the same
20:14:52 <fiacre> Well at the moment with Mod-q the workspace bar is blank when it should contain text.
20:15:35 <fiacre> Some times Mod-q is not sufficient to solve these artefacts
20:20:34 <cg_morton> say, what module is foldl' in?
20:20:42 <cg_morton> I can't seem to find it
20:20:48 <copumpkin> Data.List
20:20:55 <cg_morton> cool, thanks
20:20:58 <copumpkin> @hoogle foldl'
20:20:59 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
20:20:59 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
20:20:59 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
20:33:50 <dmwit> > delete 3 [3,3,3]
20:33:51 <lambdabot>   [3,3]
20:33:57 <dmwit> copumpkin: I dunno!
20:35:22 <aristid> > filter (/= 3) [3,3,3]
20:35:23 <lambdabot>   []
20:36:49 <dmwit> copumpkin: inserting a new element will involve merging two 1-sized maps, two 2-sized maps, two 4-sized maps, two 8-sized maps, ... two O(n)-sized maps in the worst case.
20:37:29 <dmwit> I guess merging costs O(m) where m is the number of map entries.
20:37:36 <copumpkin> scary
20:37:49 <dmwit> So inserting might be O(n).
20:38:11 <dmwit> ...but that price gets you a really lot of statistics about the data you're keeping.
20:38:18 <mysticc> dmwit: Where is this thing ??
20:38:27 <dmwit> mysticc: ask copumpkin!
20:38:35 <mysticc> copumpkin: Where ?
20:38:43 <copumpkin> on my computer? but I don't have it yet
20:38:49 <copumpkin> I'm thinking of just using nested structures :P
20:38:56 <copumpkin> since this kind of scares me
20:38:58 <dmwit> copumpkin: This is the worst case, though, where we're assuming every single entry in your data structure has a different key in this map.
20:39:15 <dmwit> copumpkin: If you expect to have a lot of values that share only a small number of keys, you'll do much metter.
20:39:18 <dmwit> ...better.
20:39:40 <dmwit> e.g. if there are only, say, 10 keys total, then you're back at O(log n) insertion already.
20:39:54 <copumpkin> yeah, but I don't have any such guarantee
20:40:06 <copumpkin> in fact, there will likely be many distinct keys
20:40:13 <copumpkin> :/
20:40:14 <dmwit> Are they dense?
20:40:23 <dmwit> Sorry, that doesn't matter.
20:40:40 <dmwit> (I was going to suggest using an Array instead of a Map, but the salient point is merging, not lookup.)
20:40:43 <mysticc> I still dont understand what actually you are trying to do ?
20:40:49 <ion> Hmm. Why is deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a] instead of (a -> Bool) -> [a] -> [a]?
20:41:04 <mysticc> @src deleteBy
20:41:04 <lambdabot> deleteBy eq x []        = []
20:41:04 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
20:41:27 <mysticc> ion
20:41:31 <ion> mysticc
20:41:48 <mysticc> :) read the source :)
20:42:13 <ion> mysticc: deleteBy pred [] = []; deleteBy pred (y:ys) = if pred y then ys else y : deleteBy pred ys
20:44:26 <mysticc> @src deleteBy
20:44:27 <lambdabot> deleteBy eq x []        = []
20:44:27 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
20:44:37 <mysticc> ion: I meant this ^^
20:44:48 <ion> mysticc: Yes, and my question is “why”.
20:45:29 <rwbarton> I think because it's more parallel to all the other *By functions
20:46:06 <ion> true
20:46:40 <rwbarton> but yeah, in isolation it is more complicated than it need be
20:46:41 <mysticc> ion: Read the source of Data.List .. every By function is defined that way
20:54:57 <ion> mysticc: No need to read the source, just looking at the type signatures validates what rwbarton said.
20:59:28 * hackagebot foreign-storable-asymmetric 0.0.1 - Types and instances for implementing a Storable with different peek and poke  http://hackage.haskell.org/package/foreign-storable-asymmetric-0.0.1 (AndrewMiller)
21:04:18 <dmwit> Anyone know the right incantation to include
21:04:28 <dmwit>     > {-# LANGUAGE Whatever #-}
21:04:28 * hackagebot network-netpacket 0.0.1 - Haskell bindings for low-level packet sockets (AF_PACKET)  http://hackage.haskell.org/package/network-netpacket-0.0.1 (AndrewMiller)
21:04:38 <dmwit> in my cabal package's "description" field?
21:19:29 * hackagebot template-default 0.1 - declaring Default instances just got even easier  http://hackage.haskell.org/package/template-default-0.1 (DanielWagner)
21:26:45 <nyingen> @quote
21:26:46 <lambdabot> goundoulf says: I've been reading a very good tutorial on haskell, because the [XMonad] config file was too obscure for me
21:27:25 <hpaste_> “Sondre Bakken” pasted “Hakell” at http://hpaste.org/67754
21:27:30 <Sondre_B> I am pretty new to haskell. I am currently trying to make a typesafe datastruct called Term, but as I understood it I have to return f.ex a Term Int, which then I can't seem to compute with.
21:27:35 <Sondre_B> http://hpaste.org/67754
21:28:59 <dmwit> I'd be surprised if that type for And was really what you wanted.
21:29:57 <mauke> shouldn't Term be recursive?
21:30:20 <dmwit> Oh, yeah. Basically all those types look wrong.
21:30:33 <dmwit> Con and Name are probably okay though.
21:30:58 <Sondre_B> yeah, the other ones are the ones I have just started looking into.
21:33:15 <dmwit> ?tell jfischoff I ended up rewriting the thing in TH, so that it was robust to data type definition changes and had less syntactic boilerplate to write. http://hackage.haskell.org/package/template-default
21:33:15 <lambdabot> Consider it noted.
21:33:26 <Sondre_B> making them recursive would mean writing term t on input. I see that in some cases that would make sense, but when would I then define wether it should only take int or bool?
21:33:42 <dmwit> Yes, you should define whether it takes an Int or Bool.
21:33:48 <rwbarton> that's what the t is for.
21:35:32 <Sondre_B> Could you write me an example on f.ex how Smaller would look?
21:36:11 <mauke> Smaller :: Term Int -> Term Int -> Term Bool
21:37:08 <Sondre_B> Thanks Mauke. Sorry my inexperience when it comes to Haskell.
21:37:33 <dmwit> I find it a bit... weird... that whatever instructor this is seems to be using GADTs in introductory Haskell material.
21:37:42 <dmwit> There's been a few SO questions about the same assignment.
21:37:57 <dmwit> What is the class description?
21:38:09 <shachaf> What's wrong with GADTs?
21:38:10 <mysticc> dmwit: Is it a class assignment ??
21:38:22 <dmwit> shachaf: Nothing is wrong with them!
21:38:24 <dmwit> I like them a lot.
21:38:29 <dmwit> They're just not introductory material.
21:38:32 <shachaf> Why not?
21:38:41 <mauke> I've never used them
21:38:49 <shachaf> GADT syntax makes more sense than regular ADT syntax in many ways.
21:38:53 <mysticc> shachaf: You can have a debate over that
21:38:56 <dmwit> Well, it took me long enough to get used to regular old ADTs.
21:39:16 <shachaf> dmwit: It took so long because they have this weird syntax?
21:39:26 <dmwit> Now, I'm certainly not the smartest crayon in the shed, but I like to tell myself I'm at least average.
21:39:37 <dmwit> shachaf: No, I don't think so.
21:39:40 <shachaf> data Foo a = Bar Int a | Baz a Char
21:39:41 <dmishe> Hello, what is the best way to install platform on mac: brew or installer from site?
21:39:44 <dmwit> I think it's just a novel way of thinking about programming.
21:39:51 <shachaf> That syntax confuses msot beginners.
21:39:59 <shachaf> Bar is a constructor, but Int is a type?
21:40:13 <mauke> foo bar baz = 42
21:40:23 <mauke> foo is a function, but bar is a parameter?
21:40:24 <shachaf> mauke: Those are all values.
21:40:25 <dmwit> dmishe: Good question! I don't know the answer, but hang around. Somebody else might.
21:40:40 <dmishe> :)
21:40:45 <shachaf> The confusing part of ADTs is how they mix types up with values. Beginners do that enough without any help.
21:42:14 * glguy prefers installing GHC 7.4.1 and just cabal installing the things he wants
21:43:35 <dmwit> shachaf: That may be one confusing thing. But I do not think it is the only confusing thing, nor even the most confusing thing.
21:56:59 <lambdacurry> Hi
22:00:49 <dmwit> Hello, lambdacurry.
22:03:21 <lambdacurry> Hi dmwit... This is  my first time in #haskell, can you suggest some good collection of practice problems for picking up Haskell and FP
22:03:40 <frontendloader> haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
22:03:57 <frontendloader> 99 problems and a monad ain't one.
22:04:41 <JoeyA> I got started solving Google Code Jam practice problems.  These might be good if you want to get a quick ramp-up.
22:04:57 <JoeyA> You'll bump up against advanced features pretty quickly, though.
22:05:22 <MaskRay> this is a option parser written in applicative http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/  how is his `Parser a' type defined?
22:05:45 <JoeyA> Then again, I had a lot of enthusiasm for Haskell going in, since I was coming from C/C++ and various BASICs.
22:07:40 <dmwit> MaskRay: via the "data Parser a where ..." declaration
22:09:34 <MaskRay> dmwit: sorry, i confess my obscure description. could you kindly point out to me what NilP and ConsP mean in this article?
22:10:33 <lambdacurry> thanks JoeyA.
22:15:18 <danielsmw> Does anyone have much experience with Repa? Cabal's having trouble installing it and I'm baffled as to why.
22:15:50 <dmwit> MaskRay: They are (newly defined) constructors of the Parser type.
22:16:15 <scooty-puff> what is the advantage of using Free.Church over Codensity, or vice versa?
22:16:44 <dmwit> I'm not sure I can answer "what do they mean", for the same reason I can't tell you what (:) and [] mean or what True and False mean or what Nothing and Just mean.
22:17:09 <dmwit> scooty-puff: Whoa, deja vu. Didn't we discuss this last night?
22:19:25 <MaskRay> i have a little though not decent knowledge on GADTs and know that they are data constructors
22:19:31 <scooty-puff> i hope not - i may have dropped off by then
22:19:43 <MaskRay> but can hardly understand the design concept beneath
22:19:54 <scooty-puff> going through this: http://comonad.com/reader/2011/free-monads-for-less-2/
22:20:08 <scooty-puff> i see that both give the expected improvement
22:20:21 <scooty-puff> i guess i don't really understand what "smaller" means in this context
22:20:35 <scooty-puff> F is described as being smaller than Codensity
22:20:36 <glguy> scooty-puff: The church encoding ends up being more efficient in many sitations
22:21:12 <dmwit> MaskRay: It might help you to see a few normal ADTs declared as GADTs:
22:21:19 <scooty-puff> for: newtype Codensity m a = Codensity { runCodensity :: forall b. (a -> m b) -> m b }?
22:21:29 <scooty-puff> or do you mean versus Free?
22:21:30 <dmwit> data List a where Nil :: List a; Cons :: a -> List a -> List a
22:21:54 <dmwit> MaskRay: data BinaryTree a where Leaf :: BinaryTree a; Branch :: a -> BinaryTree a -> BinaryTree a -> BinaryTree a
22:22:24 <scooty-puff> (where the Asymptotic Improvement paper I believe describes C equivalent to Codensity)
22:22:38 <dmwit> MaskRay: Now, the exciting thing about GADTs is that the final return type isn't restricted to always have bare type variables as the arguments to the type, so you could write
22:23:18 <dmwit> data Expr a where Lit :: a -> Expr a; Plus :: Expr Int -> Expr Int -> Expr Int
22:23:48 <dmwit> then, if you're handed an Expr Bool, you know (and the *compiler* knows) it's not a Plus
22:23:59 <scooty-puff> (relevant links: http://hackage.haskell.org/packages/archive/kan-extensions/2.4/doc/html/Control-Monad-Codensity.html and http://hackage.haskell.org/packages/archive/kan-extensions/2.4/doc/html/Control-Monad-Free-Church.html)
22:24:08 <nejucomo1> What is the difference between mtl and transformers ?
22:24:19 <scooty-puff> mtl uses transformers
22:24:29 <JoeyA> (that didn't used to be the case)
22:24:46 <MaskRay> dmwit: thank you for your suggestions but i actually meant that i want know how the `Parser' and its constructors are designed to parse options...
22:24:53 <kallisti> nejucomo1: transformers is Haskell 98
22:24:53 <nejucomo1> scooty-puff: Thanks.
22:25:38 <MaskRay> dmwit: `NilP a' seems like a parser that consumes nothing but holds a single value `a'
22:25:39 <scooty-puff> so (imo) transformers if you have to be Haskell 98, mtl otherwise
22:26:16 <MostAwesomeDude> Hey, I have an AST. I'd like to make it Traversable so I can do visitor-style operations on it, but I don't think it makes sense for an AST to be Foldable.
22:26:26 <dmwit> I suppose you'll have to read the rest of the blog post to understand what NilP is supposed to represent.
22:26:36 <MostAwesomeDude> Any opinions on what I should do here?
22:26:43 <dmwit> The data type itself doesn't tell you anything more than what types the constructors expect.
22:26:53 <kallisti> MostAwesomeDude: just define your own traversal functions
22:26:58 <kallisti> it doesn't have to be part of Traversable
22:28:18 <MostAwesomeDude> kallisti: I just wanted to do things in a reasonable way.
22:28:53 <nejucomo> What is ~(a, b) in a pattern?  (What is the tilde?)
22:29:07 <kallisti> it just doesn't make sense to do Traversable on an AST because you need the constructor.
22:29:18 <kallisti> unless your tree is parameterized on the constructor
22:29:39 <kallisti> in which case you could just use an existing tree implementation.
22:29:50 <dmwit> nejucomo: It's an irrefutable pattern. It always matches (without first forcing any thunks).
22:29:55 <kallisti> but I don't know if that even makes sense for an AST. :P
22:30:12 <dmwit> It's your fault if it turns out later that the damn thing wasn't actually a (,) constructor applied to two things.
22:30:27 <dmwit> For tuples, this is pretty benign; sum types, less so.
22:30:52 <MostAwesomeDude> kallisti: Well, no, it's all concrete types.
22:31:00 <kallisti> right
22:31:01 <scooty-puff> (if you have a space leak filled with (,), try the strict versions of the monads)
22:31:02 <MostAwesomeDude> So I guess custom visitors will work.
22:31:06 <scooty-puff> (writer and state?)
22:31:38 <MaskRay> thank for you tip. i'll invest another several minutes into understanding its design
22:32:49 <kallisti> MostAwesomeDude: are design patterns even applicable to Haskell?
22:32:55 <kallisti> I've never tried to do it.
22:33:05 <scooty-puff> dmwit, the deja vu, do you mean related to church and non-church encoded free, or codensity vs. church-encoded free?
22:33:15 <MostAwesomeDude> kallisti: Well, I only know one way to do ASTs without losing my mind.
22:33:34 <kallisti> MostAwesomeDude: just pattern match on the constructors.
22:33:34 <dmwit> scooty-puff: Yeah, you're probably right. Slightly different.
22:33:41 <kallisti> MostAwesomeDude: and evaluate the result.
22:33:53 <kallisti> possibly by recursively calling your eval function
22:34:05 <scooty-puff> k
22:34:25 <nejucomo> I still get fairly confused about the order in which to combine monad transformers...
22:34:41 <kallisti> the outermost monads are ran first.
22:34:48 <kallisti> it's like an onion. :)
22:34:56 <kallisti> (an onion of burritos)
22:35:08 <nejucomo> :-)
22:35:49 <kallisti> in several combinations the order doesn't matter much at all.
22:35:50 <scooty-puff> @unmtl StateT s (Writer w) a
22:35:51 <lambdabot> s -> (a, s, w)
22:36:15 <kallisti> @unmtl Writer w (StateT s)
22:36:15 <lambdabot> Plugin `unmtl' failed with: `StateT s' is not applied to enough arguments, giving `/\A B. s -> A (B, s)'
22:36:16 <nejucomo> So I want to combine a ReaderT, StateT, and IO…  What is the effect of swapping the order of the ReaderT and StateT?
22:36:22 <scooty-puff> ErrorT e (Writer w) a
22:36:24 <kallisti> @unmtl Writer w (State s)
22:36:24 <lambdabot> Plugin `unmtl' failed with: `State s' is not applied to enough arguments, giving `/\A. s -> (A, s)'
22:36:28 <kallisti> oh
22:36:29 <scooty-puff> @unmtl ErrorT e (Writer w) a
22:36:29 <lambdabot> (Either e a, w)
22:36:34 <kallisti> @unmtl WriterT w (State s)
22:36:34 <lambdabot> Plugin `unmtl' failed with: `WriterT w (State s)' is not applied to enough arguments, giving `/\A. s -> (A, w, s)'
22:36:36 <kallisti> nevermind
22:36:46 <scooty-puff> @unmtl WriterT w (Either e) a
22:36:46 <lambdabot> Either e (a, w)
22:37:16 <JuanDaugherty> The repa thing does cabal install on NixOS in a 7.4.1 environment
22:37:16 <glguy> nejucomo: reader writer and state commute. the result will behave the same however you order those
22:37:21 <kallisti> nejucomo: the main difference is the order in which they're ran
22:37:40 <nejucomo> glguy: Thanks.  That makes me feel more sane.
22:37:46 <kallisti> so, for example, WriterT w (State s) a  allows you to run the WriterT part within a StateT
22:38:10 <JuanDaugherty> (which is what its hackage page says it's targeting )
22:39:07 <kallisti> but StateT s (Writer w) a  lets you thread multiple state computations within a larger and independent Writer computation.
22:39:25 <kallisti> but usually that doesn't matter.
22:56:52 <JoeyA> @remember <JoeyA> One thing I like about Haskell versus C++ is that abusing language features tends to give more satisfying results.  <monochrom> that seems to be a criterion for drugs rather than languages :)
22:56:52 <lambdabot> Done.
22:57:01 <JoeyA> (that's from January 12)
22:58:55 <nyingen> @quote
22:58:55 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:58:57 <nyingen> @quote
22:58:57 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
22:58:57 <lambdabot> trigger.
22:59:08 <nyingen> ...AND??
23:02:01 <dmwit> ?quote AND
23:02:02 <lambdabot> drhodes says: We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run. Now go away before I call the garbage collector.
23:18:15 <ski> nyingen : <http://www.toodarkpark.org/computers/humor/shoot-self-in-foot.html>
23:19:33 <Sondre_B> When pattern matching. How can I check if a var is a bool. Do I need to make another struct?
23:20:28 <dmwit> isBool :: Bool -> Bool
23:20:31 <dmwit> isBool _ = True
23:20:41 <ion> @quote isBool
23:20:41 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
23:20:47 <dmwit> ...maybe I should ask a bit about context.
23:20:53 <ion> err, the quote was about isTrue. Never mind.
23:21:12 <ppilate> Hello, is this the correct way to implement >>= in terms of join and liftM: http://hpaste.org/67755 ?
23:21:29 <ski> Sondre_B : by the types you already know if something is a `Bool' or not
23:21:43 <dmwit> ppilate: yes
23:21:44 <ion> ppilate: Looks right.
23:21:45 <ski> Sondre_B : except if you're talking about polymorphic operations, where you can't know
23:21:47 <MostAwesomeDude> Does a no-constructor pattern match anything and still bind? e.g. case expr of x -> someFunc x
23:21:54 <hpaste_> Ceasar pasted “RegexParser.hs” at http://hpaste.org/67756
23:22:04 <ceasarbautista> Can someone help me build a regex to parse tree function? I already have most of it, but I'm having trouble figuring out how concatenation works and have been unable to find any good resources online.
23:22:06 <dmwit> MostAwesomeDude: yes
23:22:31 <ski> Sondre_B : in that case, you probably want to rephrase your code
23:22:33 <ski> Sondre_B : (or maybe use `Typable' or `Dynamic', but this is probably not what you want)
23:22:38 <ion> ppilate: Btw, you can have the default implementations of both join and (>>=) defined in a single Monad class.
23:22:43 <ion> Which i would prefer.
23:23:03 <dmwit> Sondre_B: Wait, were you the person asking about GADTs earlier?
23:23:06 <ski> Sondre_B : do you have any concrete code we could look at ? or maybe you could tell us the context of this ?
23:23:13 <dmwit> If so, your question suddenly makes a lot more sense.
23:23:28 <hpaste_> Sondre pasted “Haskell” at http://hpaste.org/67757
23:23:37 <ski> hm, yeah, with GADTs, it might be more sensible
23:23:39 <MostAwesomeDude> dmwit: Excellent.
23:23:52 <MostAwesomeDude> I need to have a default match in my case.
23:24:05 <dmwit> Sondre_B: That's the point of GADTs. You know p :: Term Bool, and eval :: Term t -> t, so eval p :: Bool.
23:24:06 <Sondre_B> dmwit and ski: http://hpaste.org/67757
23:24:09 <dmwit> You don't need to check.
23:24:13 <dmwit> Sondre_B: Nice, right?
23:24:43 <Sondre_B> yeah, I wrote b1 :: Bool, b2 :: Bool, but that didn't compile
23:24:58 <ppilate> thanks ion, dmwit
23:25:29 <dmwit> The "case/of" thing is a bit redundant, though.
23:25:41 <dmwit> Just "eval (And p q) = eval p && eval q" seems simpler.
23:25:49 <ski> Sondre_B : annotate the paste with the error message ?
23:26:14 <dmwit> Annotate with both the error and the wrong thing you tried, if you're going to follow ski's advice.
23:27:04 <Sondre_B> I get illegal signature in pattern when setting b1 :: Bool
23:28:31 <dmwit> Yes, type signatures go on expressions, not patterns.
23:28:46 <Sondre_B> but if doing this: eval (And p q)     = (eval p) && (eval q)
23:29:06 <Sondre_B> Do i have any control if it returns the right type, or do I because my struct is type safe?
23:29:39 <dmwit> Did you see my explanation earlier?
23:29:53 <dmwit> The type of your GADT determines what type the function returns.
23:30:05 <Sondre_B> so yes
23:30:31 <dmwit> "yes" is kind of a weird answer to an "A or B" question
23:31:13 <shachaf> Try #prolog
23:32:17 <ion> :-D
23:32:23 <ski> Sondre_B : `PatternSignatures' (or `ScopedTypeVariables' i think) can be used to enable type ascriptions in patterns
23:32:24 <Sondre_B> yes, because my struct is typesafe I don't have to check wether my arguments are bool or my result. Correct?
23:33:18 <ski> Sondre_B : yeah, they *must* be `Bool', no checking requirted
23:34:01 <ski> (all the checking that is required is done statically, by the type checker, if it doesn't work out, you'll get a type error)
23:34:57 <Sondre_B> then I don't really see the point of having this evaluate terms thing. But I am afraid I am missing something since our lecturer asked us to implement it
23:37:57 <dmwit> Sondre_B: Have you ever written your own language?
23:38:15 <dmwit> If so, then you should read the Expr things as ASTs for a new language.
23:39:11 <dmwit> When you write a language, there's a few steps in implementing it. First step is to parse (that is, turn a String into a structured type representing the terms in the language). The second step is to typecheck, and the third is evaluate.
23:39:15 <Sondre_B> No I haven't. How come?
23:39:39 <dmwit> The cool thing about what you're doing is that you never have to do the second step: you get to use GHC's type checker to check the types of your language for you.
23:40:02 <dmwit> You don't have to write all the things that walk over your parse tree comparing types, doing type variable unification, etc.
23:40:05 <Sondre_B> I see. Thanks for taking the time explaining me all this. Much appreciated! :)
23:40:32 <dmwit> Of course, there's a price to pay (there always is). In this case, the price you pay is that writing your parser is a bit harder, because you have to guarantee that anything the parser returns will typecheck.
23:40:49 <dmwit> Convincing the compiler that this is true can be quite difficult if the language is exciting.
23:41:01 <dmwit> Since you're not writing a parser (yet?), you get to skip the hard part. =)
23:43:52 <Sondre_B> ok, I see. :)
23:45:30 <Sondre_B> but saying it is a statically type-safe evaluator is only true because the struct is type safe. hmm
23:47:39 <dmwit> I can try to help more if you can phrase that as a question.
23:48:26 <lambdacurry> what are the options for creating RESTful web services in haskell
23:49:07 <dmwit> Dunno much about web-dev, but snap, yesod, and happstack seem popular now.
23:57:24 <mysticc> lambdacurry: I prefer yesod ..
