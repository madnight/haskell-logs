00:00:05 <gdeest> Yes, but it might still be visible if your sphere is semi-transparent
00:00:32 <gdeest> in this case do you cast another ray from your intersection ?
00:01:01 <zzing> No, this is only interested in the angles at the intersection points
00:01:08 <zzing> To go ray tracer, I would though
00:01:12 <zzing> But this is only ray caster
00:01:38 <zzing> The idea is to render a grayscale sphere
00:01:49 <zzing> I also have code in c++ for a triangle that i haven't ported over yet
00:01:50 <gdeest> OK :)
00:01:59 <gdeest> Without proper shading, I guess
00:02:02 <gdeest> Hence the theta
00:02:05 <zzing> exactly
00:02:26 <zzing> It took me about 3 weeks to form the concept of how this stuff worked tbh
00:02:38 <zzing> That was back in march
00:02:49 <zzing> I do want to move this to a real ray tracer this time
00:02:52 <zzing> But first thing is first
00:03:50 <gdeest> Is it your first big project with Haskell ?
00:04:06 <zzing> First one I have a chance at going anywhere with
00:04:21 <zzing> I have done haskell on and off for a few years, but never really got anywhere
00:04:28 <zzing> It was usually monads that killed me
00:04:59 <zzing> The other day I did a simple parsec thingy, and yesterday I figured out typeclasses, so I am not doing too badly
00:06:28 <gdeest> I think getting used to monads takes a lot of times
00:06:38 <gdeest> Actually I think /designing/ one might help
00:07:12 <zzing> Probably
00:07:31 <gdeest> Typeclasses are probably my favorite Haskell feature
00:07:51 <zzing> I have considered doing a linear algebra library (porting over the stuff from c++), because I don't like hmatrix being gpl and the others I can't get to compile
00:08:34 <gdeest> Monads are... well, okay ; you can do clever things with them, but all in all, it still feels like "we need to craft something that somehow works in our paradigm"
00:08:55 <gdeest> But I might be wrong, I probably lack "Hakskell maturity" ;)
00:09:00 <gdeest> -k
00:11:01 <zzing> For some reason I keep wanting to write lists without commas, where do I get that from
00:11:13 <zzing> I can probably blame matlab
00:11:28 <sridatta> is there any special way you all go about reading other people's haskell code? with the whole custom types and typeclasses, I find jumping into Haskell codebases to require different than imperative code
00:11:48 <sridatta> almost like I'm reading a DSL more than Haskell I'm familiar with
00:12:21 <gdeest> Well, I read type signatures, but you already probably do
00:13:12 <TSC> I find myself using ":t" in GHCi a lot, trying to figure out how the types go together
00:13:17 <Veinor> ^^^
00:13:25 <Veinor> using :t and :i helps immensely
00:13:28 <TSC> e.g. take an expression I don't understand and give it to :t
00:14:30 <sridatta> hmm, :i is pretty nifty
00:14:35 <sridatta> thanks for that tip
00:15:13 <zzing> sounds like in c++:   decltype(s + t)
00:15:26 <zzing> Useful when you don't know the types
00:36:53 <osa1> I'm trying to calculate integer power of an integer and get the result as integer, how can I do that?
00:39:02 <BMeph> How are you not doing that? :)
00:39:30 <BMeph> :t (2::Integer)^3
00:39:31 <lambdabot> Integer
00:44:34 <TSC> Easy to muck up if you use the wrong operator (I do it all the time):
00:44:37 <TSC> > 2**3
00:44:38 <lambdabot>   8.0
00:47:36 <womb> hi
00:47:42 <womb> > 7*7
00:47:43 <lambdabot>   49
00:51:13 <nand`> :t (^^)
00:51:14 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
00:51:34 <nand`> that's the third operator
00:51:57 <nand`> (^) allows positive integers only, (^^) allows negative exponents as well, and ** allows floating point types
01:05:34 <womb> :t (^_^)
01:05:34 <lambdabot> parse error on input `)'
01:05:49 <nand`> :t (.).(.) -- actually used in Haskell, don't call the cops on me!
01:05:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:06:01 <womb> hahahahha
01:06:07 <womb> you rock
01:06:10 <alistra> lol
01:06:26 <womb> let me twit this
01:06:28 <womb> awesome
01:06:29 <alistra> nand`: the question is can you infer its type without ghc
01:06:57 <nand`> alistra: It's much easier if you look at its other form
01:07:01 <nand`> :t fmap `fmap` fmap
01:07:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:07:09 <nand`> note that (.) = fmap
01:07:36 <alistra> :t fmap
01:07:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:07:44 <alistra> :t (.)
01:07:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:07:58 <nand`> :t (Prelude..)
01:07:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
01:08:06 <alistra> Prelude> :t (.)
01:08:07 <alistra> (.) :: (b -> c) -> (a -> b) -> a -> c
01:08:15 <nand`> ^- the same thing, but lambdabot's (.) is more general
01:08:27 <nand`> note that ((-> a) is a functor
01:09:06 <alistra> i don't know what ->a means
01:09:13 <womb> :t fap
01:09:14 <lambdabot> Not in scope: `fap'
01:09:21 <womb> @hoogle fap
01:09:21 <lambdabot> No results found
01:09:44 <nand`> so to compare those two; (.) :: (a -> b) -> (s -> a) -> (s -> b) is the same as (a -> b) -> f a -> f b when f is (s -> )
01:10:13 <nand`> alistra: I meant ((->) a) which is just the “prefix” application of (->)
01:10:21 <nand`> (a -> b) is the same as ((->) a b)
01:10:35 <alistra> oh
01:10:54 <nand`> so basically; “f b” is the same as “a -> b” when f = ((->) a)
01:11:02 <alistra> i get it
01:11:31 <nand`> (it's actually not just a functor but also a monad, and it's called the reader monad)
01:12:01 <alistra> the (->) a thing?
01:12:31 <t7> wow i just got about 20 Lines of messages in one go
01:14:08 <nand`> alistra: ((->) s), yes
01:15:00 <alistra> :t gets
01:15:01 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
01:15:14 <liyang> > join (*) 3
01:15:15 <lambdabot>   9
01:15:31 <liyang> join in the ((->) Integer) reader monad.
01:15:32 <alistra> > join [1,2,3] [2,3,4]
01:15:33 <lambdabot>   Couldn't match expected type `[t1] -> t'
01:15:34 <lambdabot>         against inferred type `[a]'
01:15:47 <alistra> :t join
01:15:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:16:15 <alistra> Join (Just) 3
01:16:20 <alistra> > join (Just) 3
01:16:21 <lambdabot>   Couldn't match expected type `a -> a'
01:16:22 <lambdabot>         against inferred type `Data.M...
01:17:17 <nand`> if you look at the join (*) example; for the sake of simplicity let's assume (*) :: Integer -> Integer -> Integer; so that's ((->) Integer) (Integer -> Integer), which is in turn ((->) Integer) ((->) Integer) Integer, or m (m a) with m = ((->) Integer)
01:17:34 <alistra> yeah
01:17:36 <alistra> i got this one
01:17:40 <nand`> so m (m a) -> m a means: (Integer -> Integer -> Integer) -> (Integer -> Integer)
01:17:41 <nand`> alright
01:17:46 <alistra> just still
01:17:56 <alistra> can't think of a comfortable use of a reader monad
01:18:01 <nand`> > join [[1, 2], [3, 4, 5], [5, 6]]
01:18:02 <lambdabot>   [1,2,3,4,5,5,6]
01:18:03 <nand`> alistra: constants
01:18:16 <nand`> alistra: eg. say you have some calculation that depends on a global constant which is not known at compile time
01:18:36 <nand`> so you define your calculation as a Reader MyConstant
01:18:46 <nand`> and simply pass that in when it is known
01:18:57 <alistra> in yesod some session things are kept there
01:19:01 <alistra> i think
01:19:13 <alistra> so it's basically read-only state?
01:19:41 <nand`> yeah
01:19:55 <nand`> you take two functions that rely on some input and compose them to a function that relies on some form of input
01:20:27 <t7> very descriptive
01:21:21 <nand`> > ((+5) >>= (*)) 3
01:21:22 <lambdabot>   24
01:21:39 <nand`> > (3+5) * 3
01:21:40 <lambdabot>   24
01:21:43 <alistra> :t (>>=)
01:21:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:22:21 <alistra> (d -> a) -> (a -> (d -> b) -> (d -> b)
01:22:31 <t7> Int -> Int is a monad
01:22:35 <t7> who knew
01:22:40 <nand`> t7: no
01:23:00 <alistra> monads have * -> * kinds
01:23:05 <nand`> exactly
01:23:08 <nand`> Int -> Int has kind *
01:23:12 <alistra> ^
01:23:17 <nand`> it's just the “Int ->” part that is the monad
01:23:29 <t7> :t (+5)
01:23:30 <lambdabot> forall a. (Num a) => a -> a
01:24:06 <nand`> t7: look closely at the type: (Monad m) => m a   is no longer a monad, since the monad itself is only “m”
01:24:09 <alistra> :t (\x -> x + 4) :: Reader Int
01:24:11 <lambdabot>     Expecting an ordinary type, but found a type of kind * -> *
01:24:11 <lambdabot>     In an expression type signature: Reader Int
01:24:11 <lambdabot>     In the expression: (\ x -> x + 4) :: Reader Int
01:24:16 <nand`> and that “Int -> Int” type is “m a”
01:24:18 <t7> (Int ->) Int
01:25:12 <nand`> :t (\x -> x + 4) :: Reader Int Int
01:25:13 <lambdabot>     The lambda expression `\ x -> x + 4' has one argument,
01:25:13 <lambdabot>     but its type `Reader Int Int' has none
01:25:13 <lambdabot>     In the expression: (\ x -> x + 4) :: Reader Int Int
01:25:35 <nand`> wait what
01:25:47 <liyang> :t reader (4 +)
01:25:47 <lambdabot> forall t. (Num t) => Reader t t
01:25:53 <nand`> oh, right
01:25:56 <nand`> reader is a newtype
01:26:05 <liyang> ((->) s) is not the only reader.
01:26:18 <liyang> :t reader
01:26:18 <lambdabot> forall r a. (r -> a) -> Reader r a
01:26:37 <alistra> what are the other readers
01:28:24 <nand`> well
01:28:26 <nand`> :k Reader
01:28:27 <lambdabot> * -> * -> *
01:28:58 <liyang> There's ReaderT r m too.
01:29:35 <alistra> @class Reader
01:29:35 <lambdabot> Unknown command, try @list
01:29:41 <alistra> @instance Reader
01:29:41 <lambdabot> Maybe you meant: instances instances-importing
01:29:43 <alistra> @instances Reader
01:29:44 <lambdabot> Couldn't find class `Reader'. Try @instances-importing
01:29:52 <alistra> @instances-importing Reader
01:29:52 <lambdabot> Couldn't find class `Reader'. Try @instances-importing
01:29:55 <nand`> Reader isn't a typeclass
01:29:57 <liyang> @instances MonadReader
01:29:57 <lambdabot> r ((->) r), r (ErrorT e m), r (RWST r w s m), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
01:30:40 <alistra> cont it the continuation monad?
01:30:56 <liyang> That command doesn't really help when it doesn't give you the contexts...
01:31:29 <alistra> ok need to go to work
01:31:37 <liyang> If you layer another transformer on top of a MonadReader, the result is still a MonadReader.
01:36:00 * hackagebot spreadsheet 0.1.3 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.3 (HenningThielemann)
01:41:00 * hackagebot spreadsheet 0.1.3.1 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.3.1 (HenningThielemann)
01:45:42 <osa1> what's are differents between Integer and Int?
01:46:15 <shachaf> @google haskell what's are differents between Integer and Int?
01:46:16 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-May/009906.html
01:46:17 <lambdabot> Title: [Haskell-cafe] Int vs Integer?
01:46:20 <quicksilver> Int is a machine word, in GHC it's either 32 or 64 bit
01:46:34 <quicksilver> Integer is arbitrary precision limited only by your memory.
01:46:39 <shachaf> That answer of Cale's is good. :-)
01:49:11 <merijn> osa1: Int is a machine integer (and thus bounded size), Integer is unbounded (well, unless you run out of RAM and swap :D)
01:49:36 <merijn> quicksilver: Isn't Int slightly smaller than a machine word, because it uses some bits for tagging?
01:50:05 <shachaf> Int's exact size isn't specified by the standard, only that it's at least 29 bits or so.
01:50:08 <shachaf> > maxBound :: Int
01:50:09 <lambdabot>   9223372036854775807
01:50:15 <shachaf> > 2 ^ 63 - 1
01:50:16 <lambdabot>   9223372036854775807
01:50:30 <quicksilver> merijn: no.
01:50:31 <shachaf> @src Int
01:50:32 <lambdabot> data Int = I# Int#
01:50:42 <quicksilver> merijn: where by "No" I mean "not in GHC, no"
01:50:49 <shachaf> Right.
01:50:54 <quicksilver> which is why I said carefully "In GHC it's either 32 or 64 bit"
01:51:02 <macobo> Why 29 bits instead of [-2^31, 2^31-1]?
01:51:22 <quicksilver> the standard permits you to reserve some bits for tagging
01:51:26 <quicksilver> GHC opts not to do that.
01:51:27 <merijn> Curses, foiled by careful formulation
01:51:40 <macobo> tagging?
01:52:03 <merijn> macobo: Using some of the high bits to carry typing information
01:52:18 <merijn> Or low bits, I forgot which is easier
01:52:25 <gnoi> > maxBound :: Integer
01:52:26 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
01:52:26 <lambdabot>    arising from...
01:52:34 <gnoi> > maxBound :: Char
01:52:35 <lambdabot>   '\1114111'
01:53:01 <quicksilver> Integer's max bound is a hard to determine statically
01:53:11 <gnoi> Why?
01:53:18 <quicksilver> it rather depends on how much memory your OS is prepared to allocate to GHC
01:53:24 <quicksilver> and how the GC behaves
01:53:28 <merijn> gnoi: Because it depends on the amount of available swap/RAM and ulimits :p
01:53:35 <mcstar> morning
01:53:45 <shachaf> Integer doesn't have a max bound.
01:53:48 <quicksilver> yes it does
01:53:52 <shachaf> Your computer can fail while computing some large Integers.
01:53:55 <shachaf> But they still exist.
01:54:09 <quicksilver> well that's a peculiar way of looking at it
01:54:14 <merijn> Speak for yourself, non-ultrafinitist...
01:54:27 <quicksilver> if you can't use them in a computer program in what sense are they values of the type?
01:54:44 <quicksilver> hmm mind you my rhetorical quesiton is also peculiar
01:54:50 <shachaf> You can use them in a computer program.
01:54:57 <quicksilver> since they *are* values of the type, so it's not what I meant
01:55:00 <gnoi> > maxBound :: [Int]
01:55:01 <lambdabot>   No instance for (GHC.Enum.Bounded [GHC.Types.Int])
01:55:01 <lambdabot>    arising from a use of...
01:55:07 <shachaf> You just can't run it on *your* computer.
01:55:12 * quicksilver nods
01:55:34 <shachaf> If I have a computer with 4 bytes of memory, does that mean that Integers are limited to 32 bits?
01:55:50 <shachaf> Anyway Haskell the language isn't defined in terms of any computer.
01:55:58 <merijn> shachaf: No, they're limited to less, because you need to store program text somewhere :p
01:55:59 <shachaf> So I don't see why values in Haskell ought to be.
01:56:16 <shachaf> merijn: No one says that the program text is stored in the computer's memory...
01:56:22 <quicksilver> well, on a machine where Int is 2^32 (in GHC) then GHC is certainly incapable of handling Integers of size 2^(2^32)
01:56:26 <mcstar> he talks about his new quantumcomputer
01:56:29 <kallisti> there is definitely a distinction on values whose memory is constrained to a particular size, and values whose memory is unbounded. In much the same way that having bounded memory or unbounded memory can be the difference between Turing incompleteness and Turing completeness.
01:56:34 <quicksilver> shachaf: well it's not part of the haskell definition, no.
01:56:34 <bitonic> shachaf: integer has a max bound apart from the memory available
01:56:55 <quicksilver> shachaf: just as the value "maxBound :: Int" is not part of the haskell defintion.
01:57:02 <shachaf> Right.
01:57:10 <shachaf> Some people are very unhappy with that.
01:57:10 <quicksilver> shachaf: so, when we discuss "maxBound :: Int" we are talking about a particular implementation.
01:57:17 <liyang> Harvard memory architecture has separate program and data memories.
01:57:34 <quicksilver> shachaf: ... and we might then also discuss what the largest Integer you can use in that implementation is.
01:57:40 <merijn> liyang: He didn't specify 4 bytes of data memory, he specified 4 bytes total :p
01:57:59 <shachaf> quicksilver: OK, that's true. I would still put these at two different classes of implementation-defined.
01:58:11 <liyang> 2 bytes for program, 2 bytes for data?
01:58:16 <shachaf> One is, let's say, just the source code of GHC, and another involves the computer my program runs on as well.
01:58:20 * quicksilver nods
01:58:23 <liyang> There's a few ways you can split that.
01:58:33 <shachaf> merijn: I wouldn't consider the program to be stored in "memory".
01:58:36 <shachaf> bitonic: Which is that?
01:58:58 <osa1> can anyone help me with this parser http://paste.pocoo.org/show/580621/ it matches only one character after "#b"
01:59:04 * kallisti decrees that Haskell Integers are not unbounded because he cannot compute them on the memory available to his giraffe.
01:59:24 <kallisti> in fact, they don't even exist.
01:59:28 <bitonic> shachaf: mhm? gmp integers have an upper bound since the int that stores the size is limited precision, iirc
01:59:32 <liyang> giraffes have terrible memory. elephants are much better.
01:59:41 <shachaf> bitonic: Oh, that. OK.
01:59:54 <shachaf> quicksilver: Of course, GHC *does* have a hard limit on Integer size as well.
02:00:05 <shachaf> This is all rather silly.
02:00:11 <bitonic> shachaf: yes!
02:00:13 <bitonic> :)
02:00:13 <liyang> This is IRC.
02:00:19 <shachaf> I think conal has a point when he talks about the meaning of programs, though. :-)
02:01:01 * hackagebot gloss-examples 1.7.3.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.3.1 (BenLippmeier)
02:02:45 <quicksilver> shachaf: conal has lots of good points; which one did you mean?
02:03:19 <shachaf> The one where he talks about the meaning of types and values.
02:04:16 <shachaf> Where e.g. Integer means ℕ, but Int or IO don't really have any meaning.
02:04:19 <quicksilver> osa1: I suspect that, from that paste, it may be that no one can help you. A good way to help someone to help you you would be to show how you ran the program, against what data, what result you got and what result you were hoping to get.
02:04:36 <quicksilver> shachaf: Int is an unpalatable tradeoff, certainly.
02:04:45 <bitonic> shachaf: more like Z :P
02:04:46 <shachaf> Er, not ℕ, ℤ.
02:04:56 <quicksilver> "Integers modulo 2^N for unknown N (although at least N is >= 29)"
02:05:05 <quicksilver> is not *theoretically* a very useful system to work in.
02:05:13 <quicksilver> funnily enough *practically* it works out ok.
02:05:29 <shachaf> Lots of things work out OK practically.
02:05:31 <bitonic> who needs big numbers.
02:05:36 <Ngevd> Is there a way for my friend to program in Java and me to program in Haskell, and us to work on the same thing?
02:05:44 <quicksilver> (does the standard even prescribe overflow behaviour as module 2^N? I suspect not)
02:06:04 <bitonic> Ngevd: it depends what you need to do
02:06:11 <mcstar> i found an SO article dealing with *exactly* my problem
02:06:17 <earthy> Ngevd: not *really*, no
02:06:19 <mcstar> birthday attack on sha256
02:06:30 <shachaf> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
02:06:31 <kallisti> does anyone feel like breaking some code?
02:06:35 * kallisti is a lazy lazy tester.
02:06:51 <earthy> kallisti: write quickcheck properties
02:07:02 <Ngevd> Hmm
02:07:07 <kallisti> I'm not sure of the utility of quickcheck here.
02:07:11 <mcstar> kallisti: break this code: http://i.imgur.com/1rpit.jpg
02:07:15 <merijn> Ngevd: That depends on whether "the same thing" means the same problem or the same code base, nothing stopping you from implementing the same problem in two languages :p
02:07:21 <kallisti> I think I basically need to test it "in the wild" on a real IRC server.
02:07:37 <quicksilver> shachaf: I suppose that's slightly worse, even, than mod 2^N for unknown N.
02:07:54 <kallisti> because I can't anticipate every non-standard idiosyncracy of common IRC servers.
02:07:56 <shachaf> Right.
02:08:00 <kallisti> and IRC clients.
02:08:10 <shachaf> kallisti: Would an oracle that tells you whether or not your program has bugs in it suffice?
02:08:19 <kallisti> yes that would be great. thanks.
02:08:25 <kallisti> https://github.com/kallisti-dev/irc-conduit/blob/master/Network/IRC/Conduit/Raw.hs
02:08:49 <shachaf> @ty oracle
02:08:49 <lambdabot> String -> Bool
02:08:58 <kallisti> > oracle "what"
02:09:00 <lambdabot>   True
02:09:00 <shachaf> The String you give it is a sha1sum of your source code.
02:09:08 <shachaf> The Bool is whether your code has bugs.
02:09:48 <shachaf> Anyway, why am I awake?
02:10:03 * merijn is guessing that "oracle = const True" :>
02:10:17 <shachaf> @time quicksilver
02:10:18 <lambdabot> Local time for quicksilver is Fri Apr 13 10:09:55 2012
02:10:19 <bitonic> check \s -> oracle s == True
02:10:23 <bitonic> @check \s -> oracle s == True
02:10:24 <lambdabot>   "OK, passed 500 tests."
02:10:31 <bitonic> merijn: good guess
02:10:48 <shachaf> bitonic: That's not likely to generate many sha1sums of IRC programs with no bugs in them.
02:10:55 <kallisti> in fact I often find that quickcheck isn't very helpful for these kinds of programs.
02:10:58 <kallisti> but maybe I'm just a bad tester.
02:11:01 * kallisti is a bad tester.
02:11:02 * hackagebot gloss-examples 1.7.3.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.3.2 (BenLippmeier)
02:11:08 <merijn> Testing is overrated...
02:11:31 <merijn> The TDD crowd's definition of testing anyway
02:11:33 <mcstar> hah? "768MB of storage for just the data, at most probably around 3 gigabytes with actual overhead for storing bytestring"
02:11:37 <bitonic> shachaf: you're saying that most random strings are sha1sums of valid IRC programs? but but
02:12:01 <kallisti> I guess one method of testing
02:12:06 <kallisti> would be to upload it to Hackage and wait for people to complain
02:12:11 <kallisti> sounds like good practice.
02:12:19 <shachaf> bitonic: No, that they have bugs.
02:12:24 <bitonic> kallisti: yes. mark it as "stable".
02:12:25 <shachaf> The Bool is whether it has bugs or not.
02:12:28 <merijn> kallisti: That's just lazy evaluation for testing :p
02:12:36 <bitonic> shachaf: ah. I thought it was the opposite.
02:13:13 <kallisti> I guess I'll just test it by... writing IRC bots.
02:13:16 <kallisti> sounds good.
02:13:18 * shachaf wonders whether there exists a sha1sum such that only one value hashes to it.
02:14:02 <merijn> kallisti: No
02:14:03 <merijn> Er
02:14:06 <merijn> shachaf: No
02:14:33 <merijn> I don't have a concrete proof for that, but I'd still bet quite a lot of money
02:14:39 <bitonic> merijn: why not? it's an interesting question
02:14:51 <bitonic> but yeah, probably not.
02:15:05 <merijn> bitonic: Infinite input domain, finite output domain that's hopefully somewhat uniform random with respect to input
02:15:15 * quicksilver reflects that "probably not" is a funny thing to say about facts.
02:15:21 <quicksilver> (although I say it myself)
02:15:34 <shachaf> quicksilver: That's the whole point of probability.
02:15:36 <bitonic> merijn: yeah you'd guess so :P
02:15:43 <merijn> If it's not then input will be clustered around certain set of output values, making them much more likely to colide, which defeats the purpose of a hash
02:15:44 <kallisti> quicksilver: it might be funny if you're an omniscient being.
02:15:57 <shachaf> Probability is about your knowledge, not about "reality".
02:16:10 <quicksilver> I don't think that's how I'd put it.
02:16:14 <merijn> kallisti: Depends, omiscient being in a gnostic or agnostic universe...
02:16:19 <quicksilver> probability is a model of random events.
02:16:33 <quicksilver> are random events a good model for unknown facts?
02:16:34 <shachaf> quicksilver: Let's say I flip a coin and hide it.
02:16:44 <shachaf> What's the probability it landed on its head?
02:16:48 <merijn> quicksilver: If you believe in a deterministic universe there is no such thing as random facts, only unknown information
02:16:58 <merijn> Making probability a statement of your knowledge
02:17:05 <quicksilver> merijn: random events are a platonic notion, merijn
02:17:13 <quicksilver> it's not relevant if "there is any such thing".
02:17:23 <shachaf> "either 0% or 100%" is true, in one perspective, but completely useless; that's not what probability is about.
02:17:24 <quicksilver> they're a mathematical abstraction.
02:17:36 <shachaf> The fact that the coin has already landed doesn't change anything about your knowledge of what side it landed on.
02:17:43 <merijn> quicksilver: Mathematical abstractions are not "knowledge"?
02:17:43 <quicksilver> you can ask if they are a good model of things.
02:18:15 <quicksilver> merijn: I mean, it's not relevant whether or not the universe is deterministic; you can still discuss abstractions
02:18:30 <merijn> quicksilver: You use these abstractions to model your expectations of the universe, not the actual universe
02:18:39 <quicksilver> you may do, yes.
02:18:41 <kallisti> in other news, I may have broke interpolatedstring-perl6 completely with my recent patch to it.
02:18:44 <merijn> As such they model your knowledge of the universe and not the universe itself
02:18:44 <kallisti> only time will tell.
02:18:48 <quicksilver> but it's permitted to ask the question whether or not it's a good model.
02:19:06 <quicksilver> anyhow this is very much off-topic :)
02:19:18 <merijn> In other words, the probabilities say something about your knowledge of the universe, rather than about the universe itself
02:19:53 <merijn> quicksilver: If you want to get back on topic, point to some good examples using Data.Functor.Compose/Data.Functor.Identity for my first type hacking attempts? :p
02:20:25 <kallisti> merijn: no don't do that attempt to break https://github.com/kallisti-dev/interpolatedstring-perl6
02:20:29 <kallisti> break all of my code kthx
02:20:54 <merijn> kallisti: I'm getting paid (well, indirectly) for the typehackery, not for breaking your code :p
02:21:38 <kallisti> merijn: it will be a learning experience for why you shouldn't use IncoherentInstances.
02:21:59 <kallisti> (or perhaps a learning experience for how they're occasionally permissible)
02:21:59 <mcstar> can i expect that bytestring append will be efficient?
02:22:25 <quicksilver> lazy bytestring append is almost O(1)
02:22:29 <mcstar> im thinking about using 1 gigantic bytestring, and storing indexes in it, in the hashtable, instead of the bytestrings itself
02:22:51 <quicksilver> strict bytestring append does involve a memory copy but it's a fairly fast efficient copy.
02:23:00 <kallisti> mcstar: you can expect reasonable efficiency from strict bytestrings, and efficiency from lazy bytestrings.
02:23:01 <ChristianS> mcstar: that sounds strange
02:23:01 <mcstar> ill try then
02:23:20 <mcstar> ChristianS: what is strange?
02:23:53 <earthy> mcstar: indexing into lazy bytestrings is not truly fast
02:24:29 <earthy> taking (and keeping) substrings from strict bytestrings *is* however... the underlying memory storage is shared
02:24:29 <mcstar> lets make them strict then
02:24:30 <ChristianS> and multiple appends on strict bytestrings are quite slow (every new append has to copy both strings)
02:24:52 <quicksilver> mcstar: if you produce your little bytestrings as substrings of a big one *they* are actually implemented as indices underneath the hood.
02:24:58 <ChristianS> mcstar: strict is good if you don't modify the bytestring
02:25:22 <mcstar> i dont modify them once they are created with .pack
02:25:26 <earthy> lazy is good if you're happy with not needing to look at the entire string in one go
02:26:07 <mcstar> well, i store 32 byte bytestring in a hashtable, and it is very space inefficient, thats what im trying to overcome
02:26:42 <earthy> then I don't get what you're doing. :)
02:26:58 <ChristianS> mcstar: if you say hashtable, do you mean HashMap from the unordered-containers package?
02:27:07 <mcstar> same as this guy http://stackoverflow.com/questions/10001917/suggestion-for-a-large-hash-table-225-elements
02:27:42 <mcstar> ChristianS: all of them, i tried Data.Map, Data.IntMap, Data.HashTable, and the mutable ones from hashtables
02:28:02 <ChristianS> mcstar: all the wrong packages
02:28:27 <mcstar> really, why?
02:28:50 <mcstar> Data.HashTable.IO is not ok?
02:29:04 <ChristianS> mcstar: http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashMap-Strict.html <- that's the best one, if you want pure code
02:29:19 <ChristianS> HashTable.IO is impure but still not better in my experience
02:29:30 <hpaste> mbuf pasted “Not in scope: `eval'” at http://hpaste.org/66903
02:29:38 <mcstar> ChristianS: speed seemed ok for me, i had space leak problem
02:30:41 <ChristianS> mcstar: not to sure about that, but i think that other solutions may have problems with space as well as time
02:30:46 <sipa> j
02:31:07 <ChristianS> mcstar: if you want an awesome impure solution, try the http://hackage.haskell.org/package/judy package (interface to c code)
02:31:51 <liyang> Is Judy in any way related to Patricia?
02:32:14 <mbuf> trying to follow http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot, and get the 'Not in scope: eval' error http://hpaste.org/66903
02:32:23 <mcstar> they both do adult films
02:32:31 <mcstar> ChristianS: k, thank will take a look
02:33:01 <kallisti> mbuf: now would be an excellent time to consider the irc-conduit package for rolling your own IRC bot. Available on github!
02:33:16 <mbuf> kallisti: will have a look; thanks!
02:33:38 <ChristianS> liyang: for judy, see http://en.wikipedia.org/wiki/Judy_array . patricia trees are used for some pure "hashmap"-like solutions in haskell (since a real hashmap is by definition impure) but i don't remember which ones.
02:33:41 <kallisti> mbuf: ..well, I haven't tested it at all. I was hoping to find (un)willing testers.
02:34:05 <liyang> ChristianS: I was just being silly.
02:34:11 <kallisti> the parsing code appears to work correctly though
02:35:11 <kallisti> mbuf: also eval is defined further down
02:36:03 <mbuf> kallisti: okay, forgot to include that
02:36:17 <mbuf> kallisti: thanks
02:36:57 <kallisti> mbuf: how would you describe your experience with Haskell?
02:37:10 <kallisti> if you have a solid understanding of the fundamentals, then irc-conduit maybe the library you seek!
02:37:27 <mbuf> kallisti: just starting actually; will have a look at it
02:37:39 <mbuf> *it == irc-conduit
02:37:52 <kallisti> well, that might be a bad idea. but okay! thanks. :D
02:39:18 <mysticc> what are these called {-# INLINE intercalate #-}
02:39:25 <kallisti> inline pragmas
02:39:25 <earthy> pragmas
02:39:48 <mcstar> are the #'s necesssary?
02:39:53 <kallisti> yep
02:39:58 <earthy> or pragmats, if you're using oldskool terminology
02:40:33 <ChristianS> mcstar: if you want to use them as values or especially keys in hashmaps, you should really prefer strict over lazy bytestrings (the latter have an additional level of indirection and take more space, also they are much slower to hash)
02:41:15 <kallisti> here's a library I was looking at earlier http://hackage.haskell.org/package/stringtable-atom-0.0.6.1
02:41:19 <kallisti> might be relevant here? I don't know
02:41:30 <mcstar> ChristianS: im using them, stricts
02:41:32 <kallisti> I think it uses hashing but I don't know what kind.
02:43:00 <mysticc> what do [1] means here ? {-# INLINE [1] foldl #-}
02:43:16 <kallisti> the compilation stage to inline at
02:43:35 * kallisti doesn't remember the details of what it means exactly
02:43:40 <kallisti> but that's the short version.
02:44:30 <mcstar> ChristianS: http://imgur.com/gDoaz you see, i have this enormous amount of ARR_WORDS
02:45:34 <cheater> hi, is there a list of all possible pragmas that can be used with ghc?
02:46:03 <bitonic> cheater: GHC manual
02:46:24 <bitonic> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
02:46:35 <cheater> ah, i thought this was defined by modules too
02:47:06 <bitonic> what do you mean?
02:47:27 <cheater> never mind, i was wrong
02:48:09 <ChristianS> mcstar: that's with HashMap?
02:48:55 <mcstar> ChristianS: yes, now if i insert BS.empty's  i get this: http://imgur.com/YVx4z
02:49:03 <mcstar> btw, its the same with all containers
02:49:08 <mcstar> i tried so far...
02:49:45 <cheater> is there a good place to learn about monad transformers?
02:50:37 <gdeest> Hum, I remember about a nice PDF tutorial
02:51:03 <Saizan> RWH has a chapter on them
02:51:09 <gdeest> focused on the "How to /use/ monad transformers" aspect
02:51:36 <gdeest> Écoute, tu vas vivre avec
02:51:39 <gdeest> Oups sorry
02:51:50 <gdeest> www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
02:51:56 <t7> guys how can i store a UTCTime
02:52:01 <quicksilver> a nice practical tutorial which builds up from a 2-3 stack to hiding it behind a newtype and writing custom primitives on it
02:52:05 <quicksilver> would be a really good thing.
02:52:05 <t7> it has no binary instance or anything
02:52:11 <gdeest> Here is the one without c&p fail
02:52:35 <ChristianS> mcstar: did you try judy for comparison? though there it might be harder to determine the actual memory usage since the actual work is in foreign code...
02:52:52 <ChristianS> mcstar: also, what are your keys?
02:53:02 <mcstar> Word64
02:54:35 <mcstar> ChristianS: hah, the most annoying part is, the same ARR_WORDS appears, even if i only insert (BS.take 1 inbytes), where inbytes is 32bytes long bytestring
02:55:16 <ChristianS> what's ARR_WORDS?
02:55:33 <mcstar> there is an SO answer, it says the internal representation of ByteString
02:57:03 <mysticc> t7: write one
02:57:15 <cheater> gdeest: amazing, thanks
02:57:16 <t7> i cant because they dont export the fucking field
02:57:20 <t7> fuuuccckkk
02:58:09 <cheater> mcstar: are you profiling your haskell code?
02:58:18 <gdeest> cheater: I remember stumbling on some API change, though
02:58:21 <mcstar> cheater: all those images are from the profiler
02:58:33 <mcstar> i didnt draw them by myself
02:58:34 <mysticc> t7: I think there is Data.Time.Format
02:59:09 <ChristianS> mcstar: and what exactly goes wrong, do you ran out of memory?
02:59:40 <t7> mysticc: is that only for human readable?
02:59:42 <Saizan> it's weird though, i thought bytestring's contents didn't show up in the profiler because they are malloc'ed ForeignPtr, but i guess it might have changed
02:59:58 <gdeest> cheater: On page 4, it is said that Map.lookup is defined to work within any Monad by simply calling the monad's fail function
03:00:01 <gdeest> this isn't true anymore
03:00:24 <gdeest> (I wonder why, BTW: I think it was quite clever)
03:01:07 <mcstar> ChristianS: well, for a problem size of 10M, c++: 16%, F#: 28%, HS: 77%, this is how much memory each one uses, now i have to solve a problem size 3-4 times of this
03:01:28 <mcstar> ChristianS: c++ and f# managed to do it, i run out of memory with haskell way earlier
03:01:30 <liyang> fail was kind of an epic fail.
03:01:49 <Saizan> http://www.haskell.org/pipermail/cvs-ghc/2011-July/063646.html <- ah yes, from ghc-7.2
03:01:59 <gdeest> liyang: may you explain ?
03:02:00 <liyang> It's also invoked when you have a pattern match failure to the left of a <- bind.
03:02:12 <cheater> gdeest: i'll make sure to watch out
03:02:16 <cheater> thanks
03:02:17 <liyang> gdeest: it doesn't really belong in the Monad class.
03:02:29 <cheater> mcstar: what images? sorry let me scroll up
03:02:59 <t7> aha posix time :D
03:03:13 <liyang> gdeest: or at least, most people never even think about the fail method until it bites them.
03:03:15 <mysticc> t7: I think there is something to parse time with which you can convert time to string and back .. Dont know If I am wrong .. you can look into it .
03:03:27 <kallisti> mcstar: strict bytestrings right?
03:04:01 <kallisti> a lack of sharing could be involved
03:04:02 <mcstar> right
03:04:10 <gdeest> Yes, but I feel like the lookup's use of fail was quite in the spirit of monads
03:05:14 * kallisti nukes his cabal lib so he can enable profiling on everything
03:05:20 <kallisti> fun stuff
03:05:27 <mcstar> SHA256 needs a bytestring as its input, and i need to store that bytestring, but maybe ill try a vector or something, and pack it into a bytestring for sha, but store the vector instead
03:05:37 <cheater_> mcstar: what are you using to profile?
03:05:46 <mcstar> -prof
03:05:47 <liyang> only because fail in Maybe was Nothing and [] in lists.
03:07:02 <cheater_> mcstar: i believe that only generates .prof files, how do you later change them into images?
03:07:18 <mcstar>  hp2ps -e8in -c week3p2.hp
03:08:04 <cheater_> ahh hp2ps
03:08:07 <cheater_> let me look that up
03:08:09 <mcstar> cheater_: there is an RWH chater on profiling, i was directed to it yesterday
03:08:14 <cheater_> thanks
03:08:17 <cheater_> i'll check it out
03:08:19 <liyang> When you write e.g. do Just () <- return Nothing that looks like an unmatched pattern (as if you had written let f (Just ()) = ... and left out the Nothing case), but noooo, it actually calls fail.
03:08:40 <gdeest> liyang: it probably makes sense only in the MonadPlus typeclass, true
03:08:40 <bitonic> liyang: that's actually a nice feature of 'do' notation
03:09:07 <liyang> bitonic: I've abused it before, and I felt dirty afterwards.
03:09:07 <kallisti> er okay...
03:09:11 <bitonic> while I agree that fail shouldn't be in Monad, it's nice to be able to fail nicely on failed matches
03:09:12 <kallisti> so nuking my cabal directory broke cabal
03:09:40 <bitonic> liyang: mah if you know how to use it is nice. btw, it's the same with 'let' in a 'do' block
03:09:42 <cheater_> speaking of books, has anyone tried this? http://www.amazon.co.uk/Haskell-Intensivkurs-Kompakter-Funktionale-Programmierung-Xpert-Press/dp/3642047173/ref=sr_1_7?s=books&ie=UTF8&qid=1334311706&sr=1-7
03:09:45 <mysticc> t7: you can look here.. They have defined Serialize instance of UTCTime http://hackage.haskell.org/packages/archive/happstack-data/6.0.0/doc/html/src/Happstack-Data-Serialize.html ..
03:09:56 <gdeest> liyang: what do you think the correct behaviour should be ?
03:10:03 <gdeest> (in your pattern-matching example)
03:10:06 <kallisti> it seems to think the packages still exist
03:10:10 <kallisti> how do I unregister all of them?
03:10:23 <liyang> gdeest: same as writing f (Just ()) = .. without a Nothing case.
03:10:23 <bitonic> imho the correct behaviour would be to have a "MonadFail" and a "dofail", or whatever.
03:11:16 <gdeest> interesting ; I wasn't aware of the fail controversy
03:11:22 <bitonic> the only way to fail a pattern match as usual in 'do' is to use 'case'
03:11:58 <liyang> (ooh earthquake!)
03:12:30 <bitonic> and with lambdas
03:12:49 <benmachine> bitonic: once upon a time there was a separate typeclass for do failures
03:12:54 <benmachine> they removed it, I don't know why
03:12:57 <benmachine> but I agree that it's useful
03:13:36 <t7> POSIXTime enum is broken
03:13:37 <bitonic> benmachine: really? when?
03:13:48 <t7> toEnum $ fromEnum
03:13:56 <t7> returns a different result than its arg
03:14:25 <benmachine> bitonic: some version of haskell pre-haskell98, I'm vague on the details
03:14:29 <benmachine> there was a MonadZero class I think
03:14:51 <bitonic> benmachine: boh ok
03:14:53 <merijn> I have a typeclass with functions that are defined using Compose and Identity, but this (of course) doesn't give me functions that are actually runnable. I need to use getCompose and runIdentity to get my actual function and I don't want to litter the code using this typeclass to have to call getCompose/runIdentity all the time. Any clues/help? Am I just screwed?
03:15:14 <bitonic> benmachine: how did 'do' work? it behaved like this when you had a MonadZero constraint?
03:15:37 <bitonic> if there was even a do
03:16:33 <bitonic> *like it does now
03:16:43 <benmachine> bitonic: using do with patterns that could fail produced a MonadZero constraint
03:17:02 <bitonic> benmachine: ah. but that would be overly annoying. I think that a separate 'do' is better.
03:17:07 <benmachine> bitonic: if you wanted to use do with just a Monad, you had to use patterns that couldn't fail (e.g. irrefutable patterns)
03:17:12 <benmachine> see http://www.mail-archive.com/haskell@haskell.org/msg03002.html
03:17:26 <benmachine> I don't think it would be *that* annoying
03:17:39 <bitonic> benmachine: nice digging up :)
03:17:52 <bitonic> nice aged haskell-cafe post, class -98
03:17:55 <bitonic> *'98
03:18:02 <benmachine> bitonic: well, it's not the actual report or anything :P
03:18:14 <benmachine> I just searched for "monadzero"
03:18:22 <bitonic> ehhh we should have listened to Huges!
03:18:47 <benmachine> (oh man, ever since I started using a different search engine, I've found it really weirdly awkward to refer to the process of searching)
03:18:52 <benmachine> (I didn't google for something :O)
03:21:04 <bitonic> wth? from that ML post it seems clear that most people wanted to retain MonadZero
03:21:08 <bitonic> spj, what have you done!
03:21:35 <quicksilver> the notion of "unfailable" was what broke it.
03:22:00 <benmachine> quicksilver: I get that it's complication but it doesn't really seem *that* bad
03:22:13 <benmachine> quicksilver: I mean, if you add constructors, you have to change your code anyway, right?
03:22:16 <quicksilver> benmachine: 14 years of hindsight is an amazing thing :)
03:22:19 <bitonic> anyways, I'll read the whole thing later :P. I'd have voted for option 1).
03:23:35 <bitonic> but yes, the hindsight bias lurks in this discussions :P
03:23:48 <merijn> Where are all the ridiculous type hacking people when I need them? >.>
03:24:07 <kallisti> for what?
03:24:17 <kallisti> nevermind
03:24:37 <kallisti> code plz
03:24:38 <mysticc> merijn: type hacking :P
03:25:06 <merijn> mysticc: Yeah, but normally they're here overcomplicating simple questions and now that I have a non-simple question they're all missing :p
03:25:10 <kuribas> What is the best way to convert String to Maybe Float?
03:25:16 <bitonic> merijn: ? did you even as a question?
03:25:19 * kallisti is too busy breaking perfectly good code with typeclass hacks.
03:25:21 <bitonic> @type reads
03:25:22 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:25:42 <merijn> bitonic: <merijn> I have a typeclass with functions that are defined using Compose and Identity, but this (of course) doesn't give me functions that are actually runnable. I need to use getCompose and runIdentity to get my actual function and I don't want to litter the code using this typeclass to have to call getCompose/runIdentity all the time. Any clues/help? Am I just screwed?
03:25:44 <bitonic> @type fmap fst . listToMaybe . reads
03:25:45 <lambdabot> forall a. (Read a) => String -> Maybe a
03:25:51 <bitonic> kuribas: ^^^
03:26:10 <kuribas> bitonic: great, thanks!
03:26:14 <Saizan> merijn: moar code pls
03:27:02 <benmachine> merijn: you're probably a little bit screwed, but see also the newtype package
03:28:38 <hpaste> merijn pasted “type hackery” at http://hpaste.org/66907
03:29:13 <merijn> The problem is that using foo would require you to constantly use "runIdentity . getCompose" etc. on the result
03:29:19 <merijn> Which kinda defeats the purpose
03:29:33 <merijn> I'm wondering if I can hack something similar without having to go through that step...
03:30:38 <mcstar> whoa, Data.Sequence is SLOW
03:30:50 <bitonic> mcstar: no it's not. what are you doing with it?
03:31:22 <merijn> I simply refuse to believe that what I want is not possible to implement with the type system >.>
03:31:44 <mcstar> just replaced my bytestrings with sequence, and make a bytestring from them for sha, and storing the seq in a hashtable
03:32:01 <mcstar> and uses 3x as much memory, and still hasnt finished, while i was out
03:32:21 <quicksilver> well Seq Char is a fairly hideous way to use memory, certainly.
03:32:31 <bitonic> mcstar: ByteString and Sequence erve entirely different purposes
03:32:36 <quicksilver> and you've lost the nice compact sharing you had before with the bytestring
03:32:44 <mcstar> Seq Word8
03:33:01 <mcstar> now ill try some vector
03:33:34 <liyang> Perhaps a lazy ByteString or Seq ByteString?
03:36:00 <kallisti> mcstar: the purpose of Seq is similar to that of a linked list, except that it supports other operations more efficiently.
03:36:08 <kallisti> it's a sort of well-rounded structure
03:36:18 <kallisti> but not memory efficient, no.
03:36:21 <dp_wiz> Is there a http server skeleton which i can use to embed in my IO to grab one request and spit out result? somthing like `netcat -l`...
03:36:22 <liyang> It goes both ways.
03:36:48 <mcstar> it certainly seems less memory efficient than bytestrings
03:36:52 <bitonic> seq is basically a double ended queue
03:36:55 <bitonic> mcstar: oh, definitely.
03:37:04 <kallisti> mcstar: correct. 2-3 finger trees use more memory than arrays.
03:37:20 <bitonic> a bytestring has almost no overhead when storing your Word8s :P
03:37:38 <bitonic> you can thing of ByteString a something similar to char*
03:37:47 <bitonic> in C
03:37:59 <kallisti> with an attached length
03:38:05 <mcstar> bitonic: i hoped for that too, but profiling shows otherwise
03:38:08 <bitonic> Sequence uses a fairly complicated data structure
03:38:16 <bitonic> mcstar: what did profiling show?
03:38:43 <bitonic> I mean what's the operation that you're having trouble with when using bytestrings
03:38:46 <mcstar> bitonic: http://imgur.com/gDoaz for 1M of 32byte long bytestrings
03:39:44 <mcstar> actually, it doesnt matter if i store 32byte or 1byte long bytestring in the hashtable
03:40:00 <mcstar> i tried with a BS.singleton somenumber, had the same output
03:40:23 <bitonic> mcstar: wait, what are you doing exactly there?
03:40:31 <mcstar> ill give code
03:40:32 <kallisti> mcstar: how do you produce those graphs?
03:40:36 <mcstar> let me get muself together
03:40:44 <mcstar> hp2ps
03:42:10 <kallisti> mcstar: what's a good non-GNOME postscript viewer?
03:42:25 <liyang> mcstar: if they're fixed at 32 bytes long, you can use an unboxed Vector (Word64, Word64, Word64, Word64) …
03:42:28 <bitonic> kallisti: gv!
03:42:36 <kallisti> ah okay.
03:42:42 <kallisti> yes if it works similarly to xpdf then that's good
03:42:53 <bitonic> gv is a frontend to ghostscript iirc
03:43:43 <liyang> I don't think gv supports nice things like hyperlinks. Maybe that's exactly what you want.
03:44:03 <mcstar> kallisti: best anything reader is okular
03:44:17 <mcstar> pdf, djvu, chm, whatever
03:44:20 <mcstar> eps, ps
03:44:22 <mcstar> ps.gz
03:44:36 <kallisti> can I install it on a DE-less system without insane KDE dependencies everywhere?
03:44:53 <mcstar> Arch has a very modular kde packaging
03:44:56 <bitonic> I only read my pdfs with a genuine Adobe Acrobat Reader(tm). Anyways, this is -blah material.
03:44:57 <mcstar> i dont know about others
03:45:01 <merijn> The only value for which I can make "(->) x y" come out as "y" is Identity, which forces me to use runIdentity on the result, right?
03:48:39 <Tinned_Tuna> Hello, I'm trying to write a very simple tutorial of how to use the plugin module, however, the package has diverged from that defined by Dons' paper "Plugging in Haskell". It's not a big divergence, but enough to make me get slightly stuck
03:49:04 <Tinned_Tuna> The code so far is at https://github.com/TinnedTuna/Haskell-Plugin-Tutorial
03:49:33 <kallisti> mcstar: hmmm, produces empty graphs for me. maybe I'm not using any memory. :P
03:50:08 <Tinned_Tuna> My makePlugin function (in pluginTest.hs) works, but fails compiling the plugin "Hello.hs". I've written the plugin in a similar fashion to that used in the paper, but I'm slightly unstuck.
03:50:14 <mcstar> kallisti: how long does the program run? maybe you need to increse sampling with -i
03:50:20 <mcstar> increase*
03:50:46 <kallisti> mcstar: not very
03:50:53 <mcstar> kallisti: you need heap profiling for that
03:51:03 <mcstar> (but i guess you knew that, you need a .hp file)
03:51:10 <kallisti> but longer than the default
03:51:44 <kallisti> ah tere we go
03:52:09 <kallisti> it's all grayscale...
03:52:23 <Tinned_Tuna> The make failure error I'm getting is: '"Hello.hs:4:21: `greet' is not a (visible) constructor field name'
03:53:26 <bitonic> Tinned_Tuna: you're not importing the constructor
03:53:30 <bitonic> import GreetAPI (plugin)
03:53:31 <mcstar> bitonic: here is the code http://sprunge.us/GVPI
03:54:33 <liyang> kallisti: do you know about hp2any-manager? (and hp2any-graph)
03:54:49 <bitonic>  Tinned_Tuna you have to import 'greet' as well
03:55:00 <kallisti> liyang: nope
03:55:46 <liyang> hp2any-graph takes an executable and does a live plot. (Though it's a bit funny about that. You'll see when you run it.)
03:56:19 <Tinned_Tuna> bitonic: Thank you very much!
03:56:44 <liyang> hp2any-manager is a GTK UI for looking at .hp outputs.
03:57:12 <bitonic> Tinned_Tuna: yw :)
03:58:19 <bitonic> mcstar: I don't have time to read that now, maybe in a bit, or maybe someone else
03:59:38 <mcstar> bitonic: i understand, though im a bit sad :)
04:00:40 <merijn> Dammit, every thing I try runs into a wall because I lack proper type level composition :<
04:01:16 <merijn> (or type level partial application, I guess)
04:06:41 <mcstar> Alloc rate    18,446,744,073,633,737,110 bytes per MUT second
04:06:48 <mcstar> i have no idea what that means XD
04:07:15 <mcstar> 18M TBytes per second sounds fantastic though
04:16:48 <kallisti> http://dl.dropbox.com/u/16495819/2012-04-13_07-13-08_1366x768.png
04:16:52 <kallisti> is that top one a linked list?
04:17:00 <kallisti> or an unknown type?
04:17:36 <ChristianS> mcstar: did you already try judy, or would that be "cheating"?
04:17:38 <mcstar> []
04:17:45 <mcstar> ChristianS: ill do
04:17:51 <mcstar> no, it isnt cheating
04:18:20 <mcstar> kallisti: thats the constructor you see there, so its a simple list
04:19:19 <kallisti> mcstar: and ->[] is... pointers?
04:19:45 <kallisti> ->>>>>Identity must be mtl stuff.
04:19:52 <mcstar> sry i have no idea
04:27:56 <Ste1891> Hi. I've been using winGHCi for a while and it always used to switch from the "Prelude>" to "Main>" prompt when I loaded source files including a "Main" module.  Now, it switches to "Prelude Main>".  I haven't knowingly changed anything.  Can anyone advise whether A: The universe is logically inconsistent or B: I am going mad?
04:29:11 <liyang> Ste1891: Everything is fine. Nothing to worry about.
04:29:56 <liyang> The modules to the left of > are those that are in scope.
04:30:39 <Tinned_Tuna> Ste1891: The universe is logically inconsistent.
04:31:12 <liyang> Ste1891: also, you're going mad.
04:32:34 <Ste1891> OK, I was being a bit over dramatic.  I just can't see why it's behaviour has changed.
04:38:28 <statusfailed> Is there a case when one would have to use pattern matching instead of guards?
04:38:30 <quicksilver> Ste1891: it behaves subtly differently if Main is compiled vs interpreted.
04:38:39 <quicksilver> Ste1891: could that be the change you're noticing?
04:39:19 <ktosiek> why does something like this:
04:39:21 <ktosiek> runST $ do { mem <- (newListArray (0, 64*1024) [0..]) :: (ST s) (STUArray s Word16 Word16); freeze mem } :: UArray Word16 Word16
04:39:30 <ktosiek> give me "array (0,0) [(0,0)]"?
04:39:51 <liyang> If the module is interpreted it usually has a * next to it.
04:39:52 <ktosiek> it works if I use Int for indexing
04:40:02 <navaati> hi
04:41:00 <bitonic> > 64 * 1024 :: Word16
04:41:01 <lambdabot>   0
04:41:05 <bitonic> ktosiek: ^^^
04:41:08 <bitonic> you're overflowing
04:41:08 <ktosiek> ouch
04:41:10 <Ste1891> quicksilver: Oh yes.  It seems you're right.  I'm not sure why it's sometimes compiling and sometimes interpreting though.
04:41:21 <ktosiek> bitonic: thanks :-D
04:41:27 <bitonic> np
04:41:28 <statusfailed> ktosiek: building a DCPU-16?
04:41:42 <ktosiek> statusfailed: yet another, yes :-)
04:41:46 <statusfailed> hahaha
04:41:47 <statusfailed> awesome :D
04:41:59 <bitonic> is that arch actually interesting or is it just because it's going to be in some game?
04:42:13 <statusfailed> bit of both I guess?
04:42:16 <ktosiek> bitonic: because it's in-game, the arch is a bit strange
04:42:42 <bitonic> strange how?
04:42:44 <ktosiek> and there's no information about I/O except for one screenshot that shows char output
04:42:57 <quicksilver> Ste1891: if there is compiled code present in the directory, and the timestamp is newer than the source, it uses that
04:43:00 <bitonic> well, I guess there is going to be IO at some point
04:43:05 <quicksilver> Ste1891: otherwise it uses the source and interprets.
04:43:08 <statusfailed> bitonic: I thought it was memory mapped?
04:43:28 <bitonic> statusfailed: oh, ok. so there is IO.
04:43:34 <statusfailed> I don't think it's even been implemented in the game though
04:43:47 <Ste1891> quicksilver: Well, you've solved the mystery.  Thanks for that.
04:43:54 <ktosiek> bitonic: only 16 instructions, no flags
04:44:06 <ksf> uuagc is great, we should have that as a language extension.
04:44:20 <ksf> ...or at least something that supports it easily.
04:44:27 <ktosiek> bitonic: no interrupts :-C
04:44:47 <ksf> open typeclasses might work, or a sane heterogenous record system.
04:44:58 <bitonic> well it definitely generated a lot of hype. ktosiek btw there an haskell implementation already
04:45:39 <navaati> is there a common solution to the problem "i need to assign precise values to my Enum instance but it's f*ucking tiresome to write "fromEnum Const = value" and then "toEnum value = Const" with exactly the same values and Consts mirrored each time" ?
04:46:01 <ktosiek> I know, but I barely know any Haskell so I'm using it to learn some :-)
04:46:32 <bitonic> ktosiek: writing emulators for simple architectures is actually a great exercise
04:47:08 <statusfailed> bitonic: the best exercise :D
04:47:34 <statusfailed> I think designing your own is more fun, but DCPU-16 will end up being useful if you get into that game
04:50:53 <srhb> If I do hPutStr clientHandle >> sClose socket -- why is there a wait before the client (telnet) disconnects? Do I need to send some special terminating character?
04:54:24 <kallisti> srhb: it has to timeout most likely
04:54:30 <ment> hi, any ideas for portable, preferably c99-compliant haskell interpreter?
04:54:53 <kallisti> sounds like Hugs
04:55:15 <kallisti> if you want a Haskell /compiler/ that's completely independent of c99, you want GHC. ;)
04:55:28 <kallisti> (though I'm not sure what you mean by "c99-compliant")
04:55:40 <TSC2> navaati: you could write put the mapping in a Data.Bimap and then use lookup and lookupR to implement from/toEnum
04:55:41 <srhb> kallisti: Indeed, I guess so. But if I let the server just die, telnet aborts immediately. Not sure how this works really.
04:56:10 <navaati> TSC2: interesting, i'll take a look at thet, thanks
04:56:18 <kuribas> Is there a function to merge two lists with ascending numbers?
04:56:26 <ment> kallisti: something that would be compilable just with "ordinary" C compiler (on non-linux platform)
04:56:46 <kallisti> ment: GHCs backend can target native assembly
04:56:54 <kallisti> there is no C compilation
04:57:27 <navaati> kuribas: maybe you can do something with zipWith
04:57:42 <kallisti> ment: the C backend is actually deprecated now
04:57:50 <ment> kallisti: as for hugs, i wasn't able to get rid of the dlopenish package system (cabal etc)
04:58:16 <kallisti> dlopenish?
04:58:31 <ment> kallisti: i'm not sure GHC targets that particular architecture (mainframe)
04:58:50 <Y_Less> kuribas: merge how?
04:58:59 <hpc> kuribas: the sort function defined in base is mergesort, so it should have that operation already
04:59:03 <kallisti> ment: if it doesn't there's also a LLVM backend which might
04:59:13 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sort
04:59:14 <kallisti> but I don't know which architecture you're referring to
04:59:16 <hpc> somewhere in there
04:59:19 <kallisti> or what cabal has to do with dlopen. o_O
04:59:32 <kuribas> Y_Less: merge it so the numbers are still ascending.
04:59:49 <ment> kallisti: http://en.wikipedia.org/wiki/Z/Architecture
05:01:36 <Y_Less> http://en.literateprograms.org/Merge_sort_%28Haskell%29
05:02:17 <kallisti> ment: not natively, I don't think. perhaps through LLVM?
05:03:55 <kuribas> I wish something like this was in the prelude: "(?) a b c = if a then b else c"
05:04:14 <kuribas> like COND in lisp/scheme.
05:04:30 <kuribas> or the ternairy operator from C
05:04:52 <Y_Less> I wrote a ternary operator a while ago:
05:05:42 <Tinned_Tuna> bitonic: Do you know the plugins library very well?
05:06:04 <kallisti> > let (??) a b = const in 2 ?? 3
05:06:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
05:06:05 <lambdabot>    arising from a use...
05:06:14 <kallisti> > let (??) = const in 2 ?? 3
05:06:15 <lambdabot>   2
05:06:39 <ion> I’d find bool :: a -> a -> Bool -> a more useful.
05:06:41 <kallisti> data ThenElse a b = a :? b
05:06:52 <kallisti> er
05:06:58 <kallisti> data ThenElse a = a :? a
05:07:06 <kallisti> (??) :: Bool -> ThenElse a -> a
05:07:07 <gdeest> I was wondering yesterday wheter there was a way to write this function in pointless style: f x = (pred1 x) || (pred x)
05:07:12 <kallisti> make :? bind one precedence level above ??
05:07:17 <navaati> gdeest: yes
05:07:20 <gdeest> Maybe it's obvious to some of you ; if it is, I like to know ;)
05:07:25 <kuribas> > let (?) a b c = if a then b else c in (5 > 4) ? 5 $ 4
05:07:25 <lambdabot>   5
05:07:34 <statusfailed> what's wrong with just defining > if' x y z = if x then y else z
05:07:43 <bitonic> Tinned_Tuna: I don't know the plugins library at all
05:07:45 <kallisti> $ doesn't have ideal precedence though
05:07:54 <navaati> :t on
05:07:55 <kallisti> and using :? allows you to do fun currying tricks
05:07:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:07:57 <gdeest> navaati: how would you do it ?
05:08:20 <quicksilver> gdeest: liftM2 (||) pred1 pred
05:08:42 <navaati> ^^^ that :)
05:08:42 <quicksilver> gdeest: which is using the ((->)e) monad for that liftM2
05:08:47 <gdeest> Hmmm cool :)
05:08:51 <ion> liftA2! :-P
05:09:02 <navaati> :t liftA2
05:09:03 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:09:03 <kallisti> statusfailed: nothing
05:09:04 <quicksilver> I considered that but that is no real point.
05:09:06 <navaati> :t liftM2
05:09:07 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:09:21 <quicksilver> ((->)e) is a Monad, it's false generalisation to pretend it might only be Applicative.
05:09:43 <kallisti> the main benefit of if' is partial application. I think the thing I came up with works better for that purpose
05:09:48 <kallisti> because you can curry the "then" with the "else
05:09:49 <kallisti> "
05:09:50 <ion> In this case the applicative instance suffices. It’s a false idea to pretend you need the monad instance. ;-)
05:10:12 <kallisti> on the other if' works better for certain kinds of partial application
05:10:14 <kallisti> +hand
05:10:22 <navaati> ((->)e) is the Reader monad, right ?
05:10:25 <ion> if' mosly sucks for partial application, though. bool :: a -> a -> Bool -> a tends to be better.
05:10:42 <kallisti> or
05:10:49 <kallisti> data ThenElse a = a :? a
05:10:50 <kallisti> :D
05:10:53 <gdeest> Anyway, thanks !
05:10:54 <TSC2> navaati, that's right
05:12:12 <kallisti> (?|?) a b p = p ?? a :? b
05:12:31 <kallisti> map (x ?|? y) listOfBools
05:15:58 <gdeest> quicksilver, ion : so this would be equivalent to : f = (||) <$> pred1 <*> pred2, right ?
05:16:15 <mcstar> hah! if i dont just store the vector slices in a hashtable, but recursively concatenate them up, into a bigg-ass vector, performance goes up like 4-5x
05:16:15 * hackagebot rvar 0.2.0.1 - Random Variables  http://hackage.haskell.org/package/rvar-0.2.0.1 (JamesCook)
05:16:37 <gdeest> (I think I like applicative style better ; relying on some special arity function like liftM2 feels awkward)
05:16:58 <kallisti> I use liftM2 when I don't want to imply Applicative
05:17:57 <gdeest> granted, in this example, f x = (pred1 x) || (pred2 x) is both shorter and clearer... at least to the non haskellian
05:18:05 <navaati> would be cool if Applicative was added to the Prelude, after all Functor and Monad are, and Applicative is very often usefull
05:18:41 <navaati> gdeest: yes but non haskellian don't read haskell code
05:19:00 <gdeest> navaati: beginners haskellian do ;)
05:19:52 <Ptival> I thought haskellers was en vogue :o
05:19:53 <navaati> yes, but thet they'll never learn the existence of the (-> r) instance, which is damn useful
05:20:48 <navaati> s/thet/then/
05:21:00 <gdeest> Ptival: perhaps
05:21:09 <gdeest> people-who-program-in-haskell :P
05:21:37 <quicksilver> gdeest: yes.
05:21:38 <gdeest> people-who-brag-about-thinking-in-monads-and-applicative-functors
05:23:05 <kallisti> people who use imperative languages think in applicative functors, they just don't realize it.
05:23:37 <navaati> kallisti: would be interested by an example of what you mean…
05:23:58 <liyang> kallisti: you can use f `fmap` a `ap` b when you don't want to imply Applicative. :)
05:24:09 <kallisti> liyang: true
05:24:25 <kallisti> well a regular function call in an imperative language is essentially the same as using the applicative idiom.
05:24:45 <navaati> wtf…
05:24:49 <navaati> ah, for IO ?
05:24:53 <kallisti> specifically, yes.
05:24:54 <gdeest> kallisti: you see sequencing as combining functions by passing state, something like that ?
05:25:27 <gdeest> not sure I see what you mean
05:25:32 <kallisti> me neither. :P
05:25:38 <Y_Less> Because the documentation on applicative functions is gibberish to them (me)! If there is some magical documentation on how to get from basic Haskell to advanced Haskell, I've not found it yet, instead there are papers that start talking about "catamorphism combinators" in the second paragraph - there's a reason more people don't use Haskell!
05:26:06 <kallisti> Y_Less: those are not the things you should be reading
05:26:16 <kallisti> there are very simple tutorials out there, and very nice references for intermediate programmers.
05:26:23 <navaati> what you should be reading is source code
05:26:28 <kallisti> the most important thing is that you get familiar with the language itself.
05:26:37 <gdeest> Y_Less: I think in Haskell, there is no way but immersion, and figuring out things with ghci and looking at small examples
05:26:39 <kallisti> which involves, as navaati says, reading source code, but also writing it.
05:27:02 <liyang> @quote kmc histomorphic
05:27:02 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
05:27:18 <gdeest> Things about metaprotocatamorphism are interesting, but can be read afterwards
05:28:03 <navaati> liyang: hahaha, is this real ?
05:28:14 <kallisti> gdeest: StateT for example is very similar to an instance of an object in the OO way.
05:28:30 <TSC2> I think "arrow calculus of php scripts" is unlikely (:
05:29:12 <kallisti> *class
05:29:12 <liyang> navaati: ¯\(°_0)/¯
05:29:36 <gdeest> kallisti: which is why some people think that using  monad and monad transformers is a way to embed imperative programming into functional programming, and should be avoided
05:29:59 <kallisti> -shrug- it's useful.
05:30:08 <kallisti> there are other things wrong with OO, that is not one of them.
05:30:35 <gdeest> Agreed
05:30:42 <navaati> gdeest: there is nothing bad in using imperative style in haskell
05:30:52 <kallisti> my webdriver library makes heavy use of StateT  and IO, because it's speaking a protocol designed for object-oriented languages.
05:30:59 <dgpratt> gdeest: are you saying "people think...it should be avoided"? or you think it should be avoided?
05:31:07 <liyang> It's the best language for imperative style programming!
05:31:36 <gdeest> Just quoting other people, I am not religious over these kind of things
05:31:43 <dgpratt> gdeest: ah
05:32:29 <quicksilver> haskell is the best imperative programming language I've used
05:32:51 <quicksilver> because it applies a sound type discipline to imperative program and makes "procedures" or "actions" first class, you can pass them to functions etc.
05:33:40 <quicksilver> which, in practice, means you get to write less repetitive code because you have more abstraction tools to factor out the repetition. Haskell is DRYer than Ruby.
05:33:46 <gdeest> dgpratt: I think the only danger with this style is that beginners in Haskell might see "imperative style" as traditional sequencing, without understanding that some complex binding is happening behind the hood
05:34:30 <kallisti> any IncoherentInstances experts around? I'd like to make sure https://github.com/kallisti-dev/interpolatedstring-perl6/blob/master/src/Text/InterpolatedString/Perl6.hs isn't horribly broken.
05:35:05 <kallisti> (I added Text and ByteString support to interpolatedstring-perl6, but it uses some darkness)
05:35:31 <gdeest> quicksilver: I wouldn't bet on the "Haskell being DRYer than Ruby" bit. Ruby can do some really magic metaprogramming things, but those are also completely unsafe and error prone
05:36:03 <gdeest> I'd say it's an excellent compromise between DRY and safety
05:36:22 <gdeest> well, not even a compromise actually :)
05:36:29 <kallisti> checking all possible code paths for runtime errors is repeating yourself. ;)
05:36:34 <gdeest> 'cause you don't really have to abandon anything on the safety side
05:36:45 <dgpratt> gdeest: I think some Haskell folks would worry that a person from a mainstream programming language background would possibly miss out on all that Haskell has to offer [if it is easy for them to continue to solve problems in the way that they always have]
05:36:55 <gdeest> that's not the language, actually ;)
05:37:43 <gdeest> dgpratt: I am not sure whether it's actually possible to miss how different Haskell is from other languages
05:38:11 <gdeest> the first time the compiler yells at you becaue you forgot to lift a value into a Monad, you have to understand the differences
05:39:03 <kuribas> right, haskell kind of forces you to think logically :)
05:39:06 <dgpratt> gdeest: http://augustss.blogspot.com/2009_02_01_archive.html
05:39:19 <quicksilver> gdeest: Haskell, Safely-DRY
05:39:21 <kallisti> it forces you to think in terms of burritos, actually.
05:39:34 <quicksilver> someone should make a T-shirt like the superdry fashion logo.
05:39:38 <gdeest> dgpratt: love it :D
05:40:09 <liyang> kallisti: is it just the instance Show a => ShowQ a ?
05:40:15 <kallisti> no that was already there
05:40:20 <kallisti> the problem is the QQ typeclasses instances
05:40:26 <kallisti> which is where the IncoherentInstances comes in.
05:40:27 <dgpratt> gdeest: yeah, I was quite impressed by that :)
05:40:44 <dgpratt> impressed and also horrified
05:40:59 <kallisti> liyang: the idea is that there's no need to needly convert to/from string if you're interpolating bytestrings into another bytestring
05:41:06 <kallisti> liyang: so I just use id in that case.
05:41:13 <gdeest> I'd love to see the code
05:41:16 * hackagebot wxdirect 0.90 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.90 (JeremyODonoghue)
05:41:18 * hackagebot wxc 0.90 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90 (JeremyODonoghue)
05:41:53 <liyang> kallisti: oh I see. I think you're in Rebecca Black territory there.
05:41:59 <mcstar> hm, i reached a problem size of 20M, the double that of before, and it is 3x as fast as c++
05:41:59 <kallisti> liyang: as a modicum of safety I've included a law to the ShowQ that requires all ShowQ instances that are also instances of IsString to satisfy: fromString (showQ s) == id s
05:42:14 <kallisti> liyang: the only time you'd get unpredictable results is if that law doesn't hold.
05:42:44 <liyang> kallisti: considered getting rid of the first instance and adding some rewrite {-# RULES #-} instead? :)
05:42:46 <gdeest> Language.BASIC it seems
05:43:07 <kallisti> liyang: if I get rid of the first instance then the whole typeclass is meaningless
05:43:24 <kallisti> liyang: the problem is that fromString is overloaded
05:43:32 <kallisti> so I'm not sure there's an actual rewrite rule..
05:44:02 <kallisti> unless you can specify type signatures in rewrite rules. can you do that?
05:44:08 <liyang> RULES only fire when all the types match.
05:44:20 <kallisti> oh
05:44:25 <liyang> You can give as many as you like for "toQQ".
05:44:35 <kallisti> so a rule from fromString . showQ  to id would only work if both have the same type.
05:44:48 <kallisti> liyang: at that point toQQ just becomes fromString . showQ
05:44:49 <liyang> something like that, yes.
05:45:11 <kallisti> the sole purpose of toQQ is to perform that optimization
05:45:36 * kallisti will try rewrite rules instead
05:45:40 <kallisti> thanks for the help. :)
05:46:10 <kallisti> also to what degree does the syntax matter in rewrite rules?
05:46:16 * hackagebot wxcore 0.90 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.90 (JeremyODonoghue)
05:46:18 * hackagebot wx 0.90 - wxHaskell  http://hackage.haskell.org/package/wx-0.90 (JeremyODonoghue)
05:46:26 <liyang> kallisti: *nod* So {-# RULES "toQQ/id" forall s. toQQ s = s #-} or something.
05:46:46 <kallisti> for example is rewriting fromString . showQ  going to be different from fromString (showQ s)  ?
05:47:12 <liyang> kallisti: there's a whole bunch of them in base.
05:48:10 <ktosiek> hmm, is there any way to test a program with vs. without using rewrite rules?
05:48:27 <liyang> They get applied at various stages, but in the case of (.) I think it gets inlined pretty early, so you can't match on "fromString . showQ" reliably.
05:49:07 <liyang> Read the core. And maybe criterion.
05:50:00 <liyang> ghc -ddump-simpl , or install the ghc-core package.
05:50:09 <kallisti> okay cool.
05:50:51 <liyang> Thre are various flags to control those output dumps, which I recommend looking up. (They can make it a lot more readable.)
05:52:17 * kallisti thinks having Text and ByteString support for interpolation will make that package way more useful. :D
05:52:27 <kallisti> I can't wait to use the final version.
05:52:38 <wunki> with the haskellmode (emacs) setup from chrisdone, is it possible to start a REPL without cabal?
05:53:13 <navaati> wunki: sorry i don't answer, but… how do you start a repl with cabal ?
05:53:29 <kallisti> I think he's referring to cabal-dev
05:53:35 <wunki> excuse me, cabal-dev indeed
05:53:43 <womb> hi
05:54:00 <Zariel> How in parsec would you recursivly parse a string into differnet value constructors?
05:54:43 <Zariel> i have something like, typeA|typeB|typeC (string), and i want to get [ typeA, typeB, typeC ], i figured I want to use sepBy to get a list of the strings
05:55:12 <ion> data Foo = Bar | Baz; bar :: Parser Foo; bar = Bar <$ string "bar"
05:55:14 <Zariel> but then im a bit stuck, I could map over the list
05:55:31 <ion> foo :: Parser Foo; foo = bar <|> baz
05:56:02 <womb> > 7*7
05:56:03 <lambdabot>   49
05:56:06 <ion> foos :: Parser [Foo]; foos = foo `sepBy` something
05:56:08 <Zariel> ahh right i see, just try each parser for each type untill one works?
05:57:04 <ion> Also note that you may need to use “try” with (<|>).
05:57:44 <navaati> wunki: i don't know about how to do it with haskellmode, but i personally use "ghci -package-conf dist/package.conf.inplace"
05:58:42 <Zariel> ion thanks very much
05:59:13 <ion> np
06:01:57 <gienah> wunki: I think: (setq haskell-program-name "/usr/bin/ghci")
06:03:09 <gienah> wunki: or maybe its: (haskell-process-type 'ghci)
06:03:31 <wunki> navaati: is this in Emacs?
06:04:01 <navaati> wunki: no, i launch it in a terminal
06:04:37 <navaati> emacs C-c C-l is ok for trivial files, but not for projects with libs etc.
06:04:51 <wunki> gienah: let my try that. Are you also using the 'new' haskellmode?
06:05:08 <wunki> navaati: that's the problem right now, C-c C-l says my Haskell process died because there is no cabal-dev
06:05:20 <gienah> wunki: yeah like you grab of copy of https://github.com/haskell/haskell-mode/blob/master/examples/init.el and hack it for those changes or something like that
06:05:41 <navaati> there is a "new" emacs-mode ? ah… need to check that…
06:05:56 * gienah yes me uses a live ebuild of haskell-mode from github using ghci, no cabal-dev
06:06:17 * hackagebot hspec 0.9.2.2 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.2.2 (SimonHengel)
06:06:36 <gienah> navaati: yeah screencast here: http://www.youtube.com/watch?v=E6xIjl06Lr4
06:07:05 <wunki> in the post on reddit he shortly mentioned it could be done without cabal-dev, but for a reason, all his comments are deleted now
06:07:30 <gienah> wunki: me runs it wihtout cabal-dev
06:07:45 <gienah> wunki: and it works fine :]
06:08:20 <wunki> ok, just by adding `haskell-program-name`
06:09:09 <gienah> wunki: well I have  (haskell-process-type 'ghci) as well
06:11:08 <wunki> gienah: you are right, that's all it took. Running now.
06:11:29 <gienah> wunki: no worries :]
06:11:35 <wunki> would be nice if it would switch automatically when there is no .cabal file in the CWD though
06:12:21 <navaati> grmbl, i *always* forget, which one is the fastest, foldl or r ?
06:12:53 <gienah> wunki: it still seems to want the cabal files somewhere, it looks in .. directories for it, I guess it sort of reluctantly works without the .cabal file
06:13:28 <wunki> gienah: If you are online, I will let you know what reply I got from chrisdone
06:13:46 <gienah> wunki: ok, thanks
06:14:43 <dibblego> navaati: neither is "fastest"
06:15:44 <ChristianS> navaati: the usual recommendation is to either use foldl' or foldr, but foldl
06:15:55 <ChristianS> whether l' or r depends on what you want to do
06:16:08 <ChristianS> but NOT foldl*
06:17:00 <navaati> dibblego: iirc one process the elements in a constant space where the other entirely deconstruct the list and then process the elements
06:17:19 <dibblego> navaati: yes foldl' is constant space, but that doesn't make it faster
06:17:36 <dibblego> navaati: they quite different functions and cannot be compared for speed
06:17:46 <navaati> yeah, by faster i meant "the most straightforward way"…
06:17:50 <dibblego> so different, that it depends on what you want to do in determining which to use
06:17:56 <dibblego> neither is "most straightforward"
06:18:02 <navaati> i don't really see the usecase for foldr, actually…
06:18:11 <dibblego> how would you write map?
06:18:18 <dibblego> going to use foldl'?
06:18:46 <dibblego> try this http://blog.tmorris.net/haskell-exercises-for-beginners/
06:21:38 <navaati> hum… i think i'd use unfoldr, actually
06:21:55 <dibblego> unfoldr is the dual of foldr
06:25:37 <quicksilver> foldr is useful when you are producing a value which can be consumed gradually
06:25:47 <quicksilver> taking advantage of lazy evaluation and garbage collection
06:26:06 <quicksilver> the most common example *by far* is when the foldr involves (:) directly or indirectly.
06:26:31 <navaati> dibblego: and with foldl', "map f = foldl (\acc e -> (f e):acc) []" seems quite natural.
06:26:45 <dibblego> navaati: that is incorrect
06:27:22 <quicksilver> :t \f -> foldl (\acc e -> f e : acc) []
06:27:23 <lambdabot> forall b a. (b -> a) -> [b] -> [a]
06:27:31 <fmap> i don't really see the usecase for foldl actually
06:27:33 <navaati> dibblego: ah yes, order is reversed…
06:27:33 <quicksilver> ^^ there are two things wrong with this.
06:27:39 <quicksilver> firstly the order is reversed
06:27:41 <dibblego> navaati: and more
06:27:50 <quicksilver> but more seriously, it can't do any work until it gets to the end of the list
06:27:58 <quicksilver> map (+1) won't work on infinite lists any more
06:28:04 <dibblego> > let map' f = reverse $ foldl (\acc e -> (f e):acc) [] in head (map (+1) [1,2,3])
06:28:05 <lambdabot>   Couldn't match expected type `[a]'
06:28:05 <lambdabot>         against inferred type `[b] -> [a...
06:28:19 <dibblego> > let map' f = reverse . foldl (\acc e -> (f e):acc) [] in head (map' (+1) [1,2,3])
06:28:21 <lambdabot>   2
06:28:28 <dibblego> > let map' f = reverse . foldl (\acc e -> (f e):acc) [] in head (map' (+1) [1..])
06:28:29 <quicksilver> and "take 5 . map (+1)" will take time proportional to the size of the list even though it only cares about the first few items.
06:28:35 <lambdabot>   mueval: ExitFailure 1
06:28:35 <lambdabot>  mueval: Prelude.undefined
06:28:56 <dibblego> navaati: I encourage you to do the exercises above
06:29:42 <navaati> fmap: i use it way more often than foldr : each time i need to "flatten" a list, like with sum
06:30:44 <navaati> so in the end foldl' is for flattening whereas foldr is for more "map-ish" behaviours ?
06:31:56 <fmap> > foldr (+) 0 [1..10]
06:31:59 <lambdabot>   55
06:32:13 <dibblego> foldr is for when you'd like to replace every cons element in a list, which is quite a lot
06:32:38 <navaati> fmap: yeah but it will run in space proportional to the length, won't it ?
06:35:32 <navaati> foldr (+) 0 [0..10000000000]
06:35:39 <navaati> > foldr (+) 0 [0..10000000000]
06:35:41 <lambdabot>   *Exception: stack overflow
06:35:50 <navaati> > foldr' (+) 0 [0..10000000000]
06:35:51 <lambdabot>   Not in scope: `foldr''
06:35:54 <merijn> The only way to have f :: * -> * equal identity for types is using Data.Functor.Identity, which requires me to use runIdentity, right?
06:35:57 <navaati> > foldl' (+) 0 [0..10000000000]
06:36:01 <lambdabot>   mueval-core: Time limit exceeded
06:36:10 <dibblego> navaati: it is best to not think of foldr and foldl' as similar in any way, because they are not
06:36:23 <navaati> yeah
06:36:24 <parcs`> lambdabot can't count that fast
06:36:40 <dibblego> foldr f z x replaces every (:) in x with f and every [] with z
06:36:53 <dibblego> foldl f z x does something quite different, similar to a loop
06:37:02 <navaati> yeah
06:37:25 <navaati> so the thing is i use more often loops, and that's why i rarely use foldr :)
06:37:40 <ion> Use foldr when your f isn’t strict on its second argument. Use foldl' when you want to iterate over the list updating an accumulator.
06:37:40 <dibblego> foldr = []
06:42:03 <ment> is there anything like manpages available for haskell base modules?
06:42:27 <merijn> ment: Hoogle and http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
06:42:36 <merijn> @where hoogle
06:42:37 <lambdabot> http://haskell.org/hoogle
06:43:05 <ment> merijn: any option to have that installed locally?
06:43:23 <merijn> Probably, but I'm not aware of it
06:43:28 <navaati> ment: yes
06:43:34 <merijn> I would actually wager the docs come with GHC
06:43:38 <navaati> in debian, <package>-doc
06:43:43 <ment> let's see
06:43:48 <navaati> in arch, it's here already
06:43:57 <navaati> in gentoo, USE=doc
06:44:10 <navaati> (not sure for debian…)
06:44:21 <Clint> ghc-doc has the base packages, libghc-<package>-doc for addons
06:44:30 <Clint> fsvo "base"
06:44:47 <navaati> (rather big value, these days)
06:45:03 <merijn> I like how everyone blindly assumes everyone uses some form of linux :p
06:45:15 <navaati> i spoke about manpages
06:45:26 <navaati> s/i/he/
06:45:31 <merijn> And linux is the only OS using manpages?
06:46:07 <navaati> ah, you were thinking about bsds or something like that ?
06:46:12 <merijn> BSD, OSX and Solaris immediately spring to mind as alternatives
06:46:19 <Clint> haddocks are nothing like man pages anyway
06:46:36 <navaati> i thought you were thinking about windows
06:47:01 <ment> heh, i installed ghc-doc and got 300MB worth of htmls in /usr/share/doc
06:47:10 <merijn> (It's just a pet peeve of mine when people answer my generic unix questions with horribly unportable linux answers :p)
06:47:44 <navaati> merijn: our answer were not linux-specific but distro-specific, because the question is
06:48:03 <ment> any other (relevant) unixes are linux distros with different kernel anyway
06:48:10 <merijn> navaati: Distro specific is a subset of linux specific :p
06:48:16 <navaati> no
06:48:19 <merijn> ment: Ha! Boy are you wrong
06:48:32 <merijn> I get tripped up every single time I log into a linux box
06:48:41 <merijn> Slightly different flags/names, etc.
06:49:03 <navaati> it just happens that i only know linux distros and no bsd distros
06:49:41 <hpc> navaati: the big one is FreeBSD, i think
06:50:11 <merijn> GNU userland is unambiguously different from BSD or solaris userland. It's the superficial posix similarity that actually makes things worse. Since it tricks you into thinking things are the same :p
06:50:42 <navaati> hpc: i'm not sure it's the most used one, in term of number of machines running it, though
06:50:44 <merijn> hpc: Yeah, FreeBSD's userland is the one that got forked into the Darwin world
06:51:00 <navaati> ah, regarding this info, well, yeah
06:51:12 <hpc> merijn: really? i thought windows posix was the superficial one
06:51:13 <hpc> ;)
06:51:19 <Clint> oh snap
06:51:27 <merijn> Windows posix is non-existent :p
06:51:28 <mekeor> FreeBSD, OpenBSD and NetBSD are the biggest BSD-distros.
06:51:37 <merijn> There is no such thing as a BSD distro
06:51:38 <mekeor> And, sort of, Mac OS, too =)
06:51:48 <mekeor> merijn: how do you call it?
06:51:58 <navaati> (makes me think that it could be useful to learn freebsd just to be able to efficiently use a mac…)
06:52:08 <Clint> not really
06:52:09 <mekeor> heh
06:52:10 <merijn> mekeor: They're BSD OS's
06:52:16 <navaati> distro = os
06:52:17 <Clint> macos is only superficially similar to unix
06:52:31 <merijn> Clint: Not really, its pretty identical to FreeBSD
06:52:37 <Clint> dear lord, no
06:52:41 <navaati> it just happen that there are a lot of OSs using the same kernel and sharing a big part of their userland
06:52:43 <Clint> just look at dyld
06:52:48 <merijn> (I say this as FreeBSD user and current OSX user)
06:53:13 <hpc> merijn: windows kinda has a posix module
06:53:21 <mekeor> maybe it's both? both similar and different?  i mean, there are certainly many differences and similarities.
06:53:32 <merijn> hpc: Yeah, but I was mostly talking about the userland :p
06:53:39 <merijn> Which I guess is more SUS than posix?
06:53:57 <Clint> sus and posix are virtually the same thing
06:54:06 <hpc> ah
06:54:39 <merijn> navaati: But what problems were you having with OSX in the first place? The commandline is pretty solid out of the box
06:55:03 <Clint> it's gotten a little better since the beginning
06:55:36 <merijn> (And I would argue that the linker alone is a drastic quality of life improvement, although that problem might disappear as more distro's switch to the gold linker)
06:55:49 <navaati> merijn: "I get tripped up every single time I log into a MacOSX box, slightly different flags/names, etc." ;)
06:55:50 <merijn> The old linux linker was just plain terrible
06:56:07 <merijn> s/was/is/
06:57:58 <Ragnaroek> anyone there with serious experience with createProcess?
06:58:28 <merijn> The only way to have f :: * -> * equal identity for types is using Data.Functor.Identity, which requires me to use runIdentity, right?
06:59:06 <navaati> merijn: i think so
06:59:18 <merijn> Well bollocks :\
06:59:37 <navaati> where do you need to do that ?
06:59:48 <merijn> So I can get the typeclass I want to actually work :p
07:00:50 <merijn> I want the following two type signatures to match the same function "(a -> m b) -> m a -> m a" and "(a -> c -> m b) -> m a -> c -> m a"
07:01:18 * hackagebot hspec 1.0.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.0.0 (SimonHengel)
07:03:10 <merijn> The only way I can think of doing this is "class Hack m f where foo :: (a -> f b) -> m a -> f a" and then providing an instance for "(Monad m) => Hack m m" and "(Hack m f) => Hack m ((->) a f)", but since f is not yet applied I need to either use Compose or hack around it using Identity. Both will force me to use getCompose or runIdentity on the result, which is what I want to avoid
07:04:51 <merijn> navaati: I guess you just missed my answer?
07:05:16 <navaati> maybe
07:05:27 <merijn> I want the following two type signatures to match the same function "(a -> m b) -> m a -> m a" and "(a -> c -> m b) -> m a -> c -> m a"
07:05:32 <merijn> The only way I can think of doing this is "class Hack m f where foo :: (a -> f b) -> m a -> f a" and then providing an instance for "(Monad m) => Hack m m" and "(Hack m f) => Hack m ((->) a f)", but since f is not yet applied I need to either use Compose or hack around it using Identity. Both will force me to use getCompose or runIdentity on the result, which is what I want to avoid
07:05:38 <navaati> hum, yeah, i missed it
07:05:38 <icemanDNA> /list-min 50
07:05:56 <merijn> The second instance would be "(Hack m m) => Hack m (Compose ((->) a) f)", which works, or alternately I use something based on Identity which I just thought of but immediately forgot just now...
07:06:27 <merijn> If there was proper type level composition or identity than this would just work :(
07:06:56 <navaati> hum, yeah, go agda :)
07:07:14 <merijn> I don't think I can easily write the rest of my simulation in agda...
07:08:53 <Ragnaroek> my process dies after a few seconds, and I have NO idea why
07:09:02 <Zariel> ion: hm, how would I add a case to skip the input when i cant parse it? <|> (optional ..) doesnt work because the type is () not Foo
07:09:11 <navaati> that's the problem. Well, one day i found myself limited by Java's type system and discovered haskell, so it's the same situation, but… agda has perfs problem, i think
07:10:42 <merijn> @quote edwardk dependent.types
07:10:43 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
07:11:39 <navaati> is this an unresolvable problem, or is it just that state of the art compilers are not yet advanced enough ?
07:11:49 <merijn> Bit of both probably
07:13:03 <t7> roconner... where art tho
07:14:04 <ksf> http://hpaste.org/66913
07:14:07 <ksf> which one is better?
07:14:20 <t7> 2
07:14:29 <navaati> "proper type level composition" would make monad transformers trivial, wouldn't they ?
07:15:01 <merijn> ksf: Combination of both
07:15:07 <merijn> ksf: /\ is better than ^
07:15:09 <ksf> there's no such thing.
07:15:15 <navaati> type MyMonad = StateT . ErrorT . ReaderT \o/
07:15:23 <ksf> unless you allow the lines to have different width.
07:15:31 <merijn> But the bracket of the first is better (so without the ())
07:16:00 <_mpu> Hi, I have a package providing an executable and a library with separate dependencies in one cabal file, but when loading my lib, all the executable dependencies are loaded. How can I fix it?
07:16:01 <ksf> the first one has the = lined up
07:16:09 <navaati> 1st is better : the '^' feels a bit alone in 2nd one
07:16:21 <benmachine> ksf: Λ? :P
07:16:22 <ksf> but somehow my eyes seem to think that the sharp > is more important.
07:16:28 <Zariel> is it posible for a functiont o return nothing at all?
07:16:35 <ksf> well, the ^ looks way better on my console.
07:16:44 <Botje> Zariel: then you might as well not call it.
07:16:49 <JoeyA> > let f _ = () in f "Yes, Haskell can do that!"
07:16:50 <lambdabot>   ()
07:17:06 <dcoutts> _mpu: specify that your .cabal file uses the cabal-1.8+ semantics, which fixed this quirk, use cabal-version: >=1.8
07:17:28 <Ptival> can someone emphasize the difference between type constructors and type operators?
07:17:37 <hpaste> merijn annotated “lambda-bind” with “lambda-bind (annotation)” at http://hpaste.org/66913#a66914
07:17:45 <navaati> Ptival: there is no ?
07:17:49 * merijn cheated
07:17:58 <ksf> that's different stem widths.
07:18:09 <merijn> ksf: Yes, but that's less noticeable :p
07:18:16 <ksf> if you want to do that, then the left leg of the lambda should be the smallest one.
07:18:18 <merijn> Or just widen the first thing?
07:18:42 <Zariel> what I ment was, if i have a list of Maybes, I want to discard all the Nothing values
07:18:43 <ksf> also, the stems should have approx. the same width as the =
07:19:22 <t7> anyone implemented Elliptic curve crypto in haskell?
07:19:25 <navaati> Zariel: Data.Maybe.maybeToList
07:19:29 <t7> roconner has but hes not here
07:19:37 <merijn> :t maybeToList
07:19:39 <lambdabot> forall a. Maybe a -> [a]
07:19:47 <merijn> navaati: Naah, that's now what you want
07:19:52 <_mpu> dcoutts, super, thanks!
07:19:55 <merijn> :t isNothing
07:19:56 <lambdabot> forall a. Maybe a -> Bool
07:19:58 <Zariel> navaati: thanks
07:20:01 <merijn> :t filter isNothing
07:20:02 <lambdabot> forall a. [Maybe a] -> [Maybe a]
07:20:23 <merijn> @hoogle [Maybe a] -> [a]
07:20:24 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:20:25 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:20:25 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:20:33 <merijn> catMaybes is probably what you want
07:20:48 <navaati> ah, yes, sorry ><
07:20:55 <navaati> read too fast
07:21:05 <JoeyA> > foldr (.) id [showString "one, ", showString "two, ", showString "three, "] "four"
07:21:10 <lambdabot>   mueval: ExitFailure 1
07:21:10 <lambdabot>  mueval: Prelude.undefined
07:21:22 <JoeyA> > 2+2
07:21:23 <lambdabot>   4
07:21:30 <JoeyA> > foldr (.) id [showString "one, ", showString "two, ", showString "three, "] "four"
07:21:33 <lambdabot>   "one, two, three, four"
07:21:45 <JoeyA> > mconcat [showString "one, ", showString "two, ", showString "three, "] "four"  -- mistake I made yesterday
07:21:46 <lambdabot>   "one, fourtwo, fourthree, four"
07:22:46 <navaati> how does work lambdabot ? using GHC API ?
07:23:33 <merijn> navaati: https://github.com/seliopou/lambdabot
07:23:43 <navaati> :D
07:25:13 <navaati> http://hackage.haskell.org/package/mueval, actually
07:26:05 <navaati> (btw, i want this in everybody's browser, javascript sucks)
07:26:11 <merijn> :p
07:26:21 <navaati> > putStrLn "lol"
07:26:22 <lambdabot>   <IO ()>
07:26:32 <merijn> I will settle for python in the browser instead of JS
07:26:51 <navaati> (sucks too)
07:26:57 <ksf> something like llvm
07:27:01 <navaati> yeah
07:27:14 <benmachine> merijn: hey you know what's better than one language implemented inconsistently across a variety of browsers?
07:27:14 <ksf> not the raw stuff but slightly restricted.
07:27:51 <navaati> actually llvm is what google's nacl missed
07:27:59 <merijn> benmachine: Lots of languages implemented inconsistently?
07:28:01 <ksf> pnacl doesn't miss it.
07:28:10 <benmachine> merijn: what could possibly go wrong?
07:28:39 <ksf> nacl is build on top of llvm, too. needs some effort to generate code nacl accepts.
07:28:42 <merijn> I think it's annoying that google's nacl is taking the name of the crypto libs, I have high hopes of the NaCl crypto libs...
07:28:59 <navaati> ksf: never heard about this pnacl, great great great !
07:29:11 <merijn> But if the name keeps directing everyone to the Google native client then it'll never catch on...
07:29:33 <ksf> imagine how many chemists are annoyed with the name..
07:29:58 <merijn> ksf: Actually, the crypto library is named that because its salt :p
07:31:21 <navaati> when i think that in the other hand mozilla are pushing to implement a whole OS api layer trough javascript… *sigh*
07:32:24 <merijn> The entire Web 2.0 movement is reinveting the X remote protocol, but instead of one slightly inconsistent protocol in the tech stack we now have a pile of inconsistent protocols and implementations to fake everything
07:32:28 <mcstar> if i have a data.vector.unboxed.mutable, can i use a data.vector.generic.mutable operation on it?
07:32:53 <merijn> Also, links, but I'm pretty sure adding inter server links to X would have be a lot less work than the combined effort put into the web...
07:34:15 <merijn> (Anyway, since I mentioned it earlier and feel more people should know about this: http://nacl.cr.yp.to/)
07:34:56 <merijn> I will definitely be using this before openssh if I can help it...
07:37:59 <dolio> I doubt you will be able to help it, considering it doesn't appear to have anything to do with remote shells.
07:38:20 <merijn> Oh, damn
07:38:24 <merijn> I meant to type openssl
07:38:54 <merijn> Also, pssh we've all switched to mosh for our remote shells, right? :p
07:39:26 <timvisher> hey everyone
07:39:48 <Botje> hallo
07:40:05 <timvisher> could someone point me to an explanation of why haskell considers full currying of functions to be so important, preferably in comparison to languages that support partial application?
07:40:17 <dolio> You can't avoid using ssh by using mosh, because mosh uses ssh to initiate the connection. :)
07:40:42 <merijn> dolio: tbh I haven't even really looked at mosh yet :p
07:40:42 <flux> dolio, just uninstall ssh after doing that ;)
07:41:02 <dolio> flux: And never turn off either machine, I guess.
07:41:17 <flux> sure, why would you!
07:41:47 <dolio> I guess there's no reason if you're a client of ksplice.
07:42:54 <dolio> Although, I've been having to turn my laptop off lately, as sleep/suspend is broken.
07:43:29 <timvisher> i'm a clojure guy but I'm trying to explain why you might want true function currying in a post and I'm not understanding the benefit
07:43:57 <timvisher> best I can come up with is that partial application is automatic and invisible in the syntax, which doesn't seem that strong
07:44:21 <timvisher> or perhaps that it enables infix partial application, which is of course irrelevant in clojure but could apply to other languages
07:44:26 <navaati> timvisher: it makes all conceptually cleaner
07:44:36 <JoeyA> Well, it allows for tacit programming, but only to an extent...
07:44:48 <merijn> timvisher: Also, it makes pointfree programming easier
07:44:49 <navaati> functions in haskell takes only one argument and return only one argument
07:44:52 <JoeyA> map fst [('a', 1), ('b', 2), ('c', 3)]
07:44:55 <JoeyA> > map fst [('a', 1), ('b', 2), ('c', 3)]
07:44:56 <lambdabot>   "abc"
07:45:24 <dolio> What do compositions of partially applied functions look like in Clojure?
07:45:40 * kowey wonders if this discussion could be used to help improve http://www.haskell.org/haskellwiki/Currying
07:46:00 <timvisher> navaati: fully understood, i'm trying to understand what you get beyond partial application by going that route
07:46:40 <navaati> errr… no parens ?
07:46:43 <dolio> If I want to write, say, 'show . sum . map (^2)'
07:47:18 <merijn> timvisher: I often define functions which are just partial applied other functions, how would you do that in clojure?
07:47:27 <benmachine> timvisher: the instance Monoid b => Monoid (a -> b) is interesting
07:47:51 <benmachine> timvisher: as a demonstration of how understand functions as functions returning functions, the added regularity that gives you, can be used
07:47:58 <benmachine> *understanding
07:48:07 <benmachine> so I can say
07:48:22 <timvisher> navaati: that's the conclusion I've come to, but that seems like a… weak(?) answer.
07:48:22 <benmachine> :t  mconcat [comparing snd, comparing fst]
07:48:23 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
07:48:32 <merijn> As an example from my code for yesterday, I have "(-->) = liftA2 (<=<)" which, without currying would have to be written as "a --> b = liftA2 (<=<) a b", for more complex functions it becomes more annoying
07:48:34 <timvisher> especially when it removes the ability to do variadic function arguments
07:48:46 <benmachine> timvisher: ah but it doesn't, see Text.Printf
07:48:53 <benmachine> using essentially the same trick I just described
07:49:23 <navaati> timvisher: why weak ? there is no drawbacks to currying, so even a "weak" is sufficient
07:49:26 <dolio> I think the real answer to that is that most people here don't find variadic functions compelling.
07:49:26 <merijn> You can use typeclasses to hack together all sorts of complicated variadic function argument schemes if you want
07:49:31 <benmachine> combining the uniformity of function types with type classes can lead to some interesting magic
07:49:34 <rwbarton> also... you can pass the function a list
07:49:45 <mauke> yeah, there's a reason sum isn't variadic
07:49:46 <benmachine> dolio: this is also true, but it's interesting that it can be done
07:49:55 <geeksaw> and the debate goes on and on
07:50:04 <dolio> We don't care that f and fold z f are not the same function.
07:50:11 <navaati> :t liftA2 (<=<)
07:50:11 <lambdabot> forall b (m :: * -> *) c a (f :: * -> *). (Monad m, Applicative f) => f (b -> m c) -> f (a -> m b) -> f (a -> m c)
07:50:30 <dolio> Or, foldr f z, I guess.
07:50:46 <gdeest> benmachine: about your Monoid b => Monoid (a -> b) example, I think there is a similar example in Serge Lang's Algebra, but with groups (and functions from a given set to a group)
07:50:52 <merijn> dolio: I do, hence my terrible type hackery attempts of the past two days. Unfortunately no success yet. I've postponed my quest until later since I have to do some actual work, but I will hack this together if it kills me!
07:50:55 <timvisher> dolio: ((comp (partial / 2) (partial + 1)) 9) works fine
07:51:03 <timvisher> obviously it's more verbose
07:51:07 <benmachine> gdeest: yeah, it works in a lot of circumstances
07:51:17 <dolio> That looks awful.
07:51:56 <merijn> timvisher: Verbosity is of critical importance in how useful these functions are
07:52:03 <womb> :type foldr
07:52:08 <womb> :t foldr
07:52:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:52:11 <merijn> Do you think anyone would use function composition if it was called "compose" instead of "(.)"?
07:52:17 <timvisher> i 'think' this is the core of it
07:52:26 <womb> :t $
07:52:27 <lambdabot> parse error on input `$'
07:52:35 <womb> :t ($)
07:52:36 <lambdabot> forall a b. (a -> b) -> a -> b
07:52:44 <dolio> Yeah, (comp f g) is already pretty awful.
07:53:00 <bondar> hey guys started learning haskell today..it's awesome!!!!
07:53:01 <womb> it could be c
07:53:04 <timvisher> the clojure folks seem to really appreciate the 'beauty' of variadic functions, whereas haskell wants to do partial applications with no syntax whatsover, which leads to arguably more concise and readable function definitions
07:53:06 <timvisher> sound about right?
07:53:07 <womb> (c b a)
07:53:24 <dolio> It's not just "comp".
07:53:32 <timvisher> merijn: i use it all the time
07:53:41 <timvisher> but then again i'd never seen function composition before clojure
07:53:42 <dolio> It's (c f (c g h)) vs. f . g . h
07:53:52 <merijn> timvisher: A lot of functions become very unreadable that way
07:54:12 <womb> you could use some $ to make it nice
07:54:20 <dolio> I suppose if composition is variadic, it's (c f g h), but you're still delimiting things.
07:54:33 <womb> c f $ c g h ?
07:54:43 <womb> i'm trolling sorry
07:54:52 <dolio> This isn't Haskell.
07:55:01 <benmachine> (it intrigues me that people are saying here basically that the simplicity of composition syntax is part of what makes haskell great, yet all the TDNR people want to steal . for records)
07:55:12 <benmachine> (keep your hands off my . >:[)
07:55:19 <timvisher> dolio: meaning?
07:55:38 <womb> > 77
07:55:39 <lambdabot>   77
07:55:42 <womb> > 7*7
07:55:43 <lambdabot>   49
07:55:43 <rasfar> syntax is vitally important for guiding and pacing thought
07:55:56 <merijn> timvisher: Example, can you imagine this being readable rewritten using compose and partial as you typed it from clojure? "foo f = map (unlines . map f . lines)"
07:56:32 <dolio> timvisher: I like to get rid of as many parentheses as possible, usually.
07:57:12 <merijn> Something like (excuse my lack of clojure knowledge: (partial map (comp unlines (comp (partial map f) lines)))
07:57:16 <timvisher> merijn: not having any knowledge of what those functions do, I do find (comp unlines (partial map f) lines) to be quite readable. not saying that's right, and it's probably more because i'm used to reading clojure than anything else, but I don't find it to be difficult or ugly
07:57:34 <rwbarton> a better question is what would it look like in haskell if you didn't curry functions
07:57:47 <timvisher> dolio: of course. :) I've settled my relationship with parens at this point and I'm cool with them but I get where you're coming from
07:57:49 <rwbarton> since the question was not about clojure afaik
07:57:58 <merijn> Actually, I guess "foo f = map $ unlines . map f .lines" is even nicer
07:58:02 <bondar> > take 10[1..100]
07:58:03 <timvisher> rwbarton: it's not about clojure specifically
07:58:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:58:13 <rwbarton> I thought it was specifically about Haskell.
07:58:40 <rwbarton> foo f = partial (map, unlines . partial (map, f) . lines)?
07:58:42 <timvisher> i know that rich hickey specifically made the decision to not support full currying, and the answer I got from the clojure folks was because it allows for the definition of variadic functions, which I use all the time
07:58:49 <timvisher> so i'm trying to understand the other side of the story
07:59:05 <merijn> timvisher: I cannot really imagine what Lisp would look like with currying...
07:59:08 <mauke> what are variadic functions good for?
07:59:15 <dolio> It'd look like foo (f, x) = map ((\y -> unlines (map (f, lines y))), x)
07:59:15 <rwbarton> how do you type a variadic function
07:59:27 <timvisher> rwbarton: as in defining it or calling it?
07:59:30 <rwbarton> (yes I know about printf)
07:59:32 <merijn> rwbarton: Typeclass hacks :p
07:59:36 <rwbarton> as in what type does it get
07:59:38 <timvisher> (defn f [a & as] ...)
07:59:44 <rwbarton> there's no upside here in haskell
07:59:45 <timvisher> (f a b c d e f g h ...)
07:59:58 <timvisher> lol, well, it's just a fn
08:00:05 <timvisher> like every other function
08:00:08 <rwbarton> well, Haskell does not know about this "lol" idea.
08:00:16 <timvisher> i'm also not used to thinking about types much coming from clojure
08:00:24 <timvisher> i get that too
08:00:30 <merijn> timvisher: Yes, but a function of what to what?
08:00:42 <timvisher> not exactly the difference i'm looking to explore at this time
08:00:49 <rwbarton> um...
08:00:52 <merijn> it's relevant
08:01:03 <rwbarton> yes
08:01:05 <merijn> Because in haskell that is a very tight restriction on your functions
08:01:19 <rwbarton> perhaps haskell doesn't have variadic functions because they would not fit nicely into the type system
08:01:28 <timvisher> as i understand it (and i don't), haskell very much wants to be type constrained where clojure wants you to not think about types, if that's relevant to this understanding then enlighten me. :)
08:01:30 <merijn> You can't say that a function magically returns something unknown, because how would you type check it?
08:01:31 <rwbarton> then, there is no downside to not currying everything because you have no variadic functions anyways
08:01:36 <rwbarton> so it is relevant
08:01:41 <rwbarton> er
08:01:42 <rwbarton> remove a "not"
08:01:48 <timvisher> hah, which one? ;)
08:01:57 <rwbarton> then, there is no downside to currying everything because you have no variadic functions anyways
08:02:23 <timvisher> merijn: you don't type check it. that's how.
08:02:31 <ksf> I don't think shallow use of type families counts as "type-level hackery"
08:02:33 <dolio> Types are not merely constraints.
08:02:35 <merijn> timvisher: Then you wouldn't be writing haskell...
08:02:43 <t7> http://en.wikipedia.org/wiki/Elliptic_Curve_DSA in here n is an 'order of G'
08:02:46 <timvisher> true
08:02:47 <t7> wtf does that mean
08:02:59 <dolio> For many Haskell programmers, they are fundamental to thinking about their programs.
08:03:18 <timvisher> so another aspect of why currying is important in haskell is that it allows for tighter type checking?
08:03:29 <rwbarton> it means you should read a book on elliptic curves
08:03:32 <merijn> So fundamental in fact that I'm now extremely annoyed that the type system is not expressive enough to express all constraints I want :p
08:03:51 <timvisher> hmm...
08:03:52 <rwbarton> timvisher: no
08:03:53 <mauke> I'm pretty sure SML isn't pervasively curried
08:04:01 <rasfar> t7: probably http://en.wikipedia.org/wiki/Order_%28group_theory%29
08:04:02 <merijn> timvisher: Rather, the reverse. Type checking rules out variadic functions so you don't lose anything by currying
08:04:06 <timvisher> i definitely don't understand that yet but is there something i could read on that more?
08:04:06 <rwbarton> yes
08:04:19 <mauke> I don't think variadic functions pose a problem to type checking
08:04:41 <mauke> I suspect variadic functions only make sense if you have parameter lists
08:04:41 <merijn> mauke: Depends, compile time variadic, no
08:04:43 <rwbarton> we could also ask, what variadic functions from clojure do you miss in haskell
08:04:45 <merijn> Runtime probably yes
08:04:57 <mauke> ML/Haskell don't have parameter lists
08:05:20 <timvisher> merijn: the way variadic functions are implemented in clojure is that the arguments beyond the variadic arity are passed in automatically encapsulated in a seq
08:05:41 <merijn> timvisher: In haskell you'd just have to wrap them in a list before calling
08:05:44 <timvisher> so in that sense, you could type check it, but you'd need to 'auto-box' the arguments beyond a certain point
08:05:46 <mauke> yeah, it's syntactic sugar for lists
08:05:48 <merijn> And then it magically works
08:05:56 <navaati> timvisher: this would need heterogeneous lists
08:05:57 <timvisher> exactly, another difference in the sense of beauty
08:06:01 <mauke> f x y z ==> f [x, y, z]
08:06:14 <Younder> What are the mathematical problems with checking varadic functions? I mean The CALLS are defined at compile time..
08:06:23 <merijn> timvisher: Problem, what if the return value is a function?
08:06:26 <timvisher> navaati: not necessarily, if your functions deal with many different kinds of inputs
08:06:28 <timvisher> but ordinarily yes
08:06:31 <Younder> I don't get it.
08:06:32 <Zariel> If I have a string like this, "typeA|typeB|typeC" and using parsec I want to parse to [typeA, typeC] and skip over typeB
08:06:38 <merijn> timvisher: How do I know which arguments go to the variadic one and which go to the result?
08:06:38 <navaati> f 1 True 'a' ==> f [1, True, 'a'] -- OOPS
08:06:52 <Zariel> currently i have sepBy setup with parseTypeA <|> parseTypeB
08:06:54 <timvisher> for instance, + is defined variadically so you can apply it to a seq rather than having to reduce over the list
08:06:57 <benmachine> haskell has variadic functions, but the problem is that flexibility means it's no longer an error to supply the wrong number of arguments
08:07:01 <Zariel> but it seems to miss the typeC
08:07:06 <merijn> timvisher: You can't have non-homogenuous lists in haskell
08:07:07 <Zariel> parseTypeC i mean
08:07:08 <timvisher> merijn: i don't follow that question
08:07:16 <benmachine> we *like* that being an error
08:07:20 <mauke> merijn: er, by looking at the calls
08:07:21 <benmachine> it means we don't make so many mistakes
08:07:35 <timvisher> the arguments question
08:07:36 <Younder> So ALLOW it WHEN the inputs are defined. I am really annoyed by the lack of a variable number of argumants
08:07:47 <mauke> timvisher: what if you already have a seq and want to sum it?
08:08:00 <merijn> mauke: That only works if you add braces to the call syntax
08:08:16 <navaati> btw, Text.Printf is unsafe at runtime regarding the format string, but the format string is very often known at compile time. Is there a TH version of this module ?
08:08:18 <mauke> merijn: or some other marker, yes
08:08:26 <merijn> Anyhoo, time to go home
08:08:26 <benmachine> navaati: yes, there is a TH version
08:08:36 <timvisher> mauke: two options off the top of my head 1) (apply + seq) or 2) (reduce + seq)
08:08:37 <benmachine> but I think it's kind of old, it may not be updated
08:08:37 <mauke> navaati: there's at least Text.Printf.Mauke.TH, probably others
08:08:44 <xivix> oh hi, mauke
08:08:49 <Younder> There is NO reason in FUNCTIONAL logic NOT to..
08:08:55 <navaati> benmachine, mauke: great, thanks
08:09:09 <timvisher> applying uses the variadic function arity, and reducing using the two arg arity
08:09:33 <navaati> Younder: if you are annoyed by the lack of variadics, you're not programming in Haskell
08:09:37 <Zariel> i think the problem is that im not consuming all of the string which is being split, hmm
08:09:42 <mauke> timvisher: looks like you don't lose much by making the list explicit
08:09:52 <mauke> timvisher: (sum (list 1 2 3)) and (sum seq)
08:10:04 <mauke> vs. (+ 1 2 3) and (apply + seq)
08:10:16 <Younder> navaati, True. I come from Lisp. And I am just learning Haskell
08:10:35 <kowey1> uhm, how big an obstacle should I consider it that there isn't a Generic instance for Text, nor an exposed constructor which would allow me to use standalone+auto deriving?
08:10:50 <benmachine> Younder: what sort of type would a variadic function have?
08:11:03 <kowey> (kind of just trying to use QC or SmallCheck here)
08:11:06 <timvisher> mauke: agreed. it's only slightly different and at this point does seem to come down to an issue of aesthetics, rather than technical differences which is what i was hoping to find
08:11:15 <Younder> navaati, You would determine it on call
08:11:32 <rwbarton> how
08:11:39 <Younder> benmachine, , You would determine it on call
08:11:52 <navaati> Younder: haskell is *statically* typed
08:11:58 <benmachine> Younder: but then you don't get the sort of verification that we like in haskelland
08:11:59 <navaati> that's the whole point
08:12:03 <Younder> Because you knew what types it was called with
08:12:05 <benmachine> Younder: it would be easy to write wrong calls
08:12:13 <timvisher> thanks so much everyone. plenty to chew on.
08:12:44 <Younder> benmachine,  so you disallow those and only allow the ones you can define
08:13:19 <Younder> Which would be most
08:13:35 <Younder> Look at CreateWindowEx ..
08:13:36 <benmachine> Younder: but it seems to me that if you have a variadic argument list
08:13:37 <navaati> Younder: you need to know a number of arguments to determine the number of args
08:13:40 <sclv> kowey: for qc/smallc you can just wrap it in a newtype and write yr. own generic instance?
08:13:55 <benmachine> Younder: the argument list needs to be uniform in some way, in which case there's a strongly-typed i.e. non-variadic solution to the problem
08:14:04 <Younder> You could easelly bind keywords to types
08:14:11 <quicksilver> kowey: isn't it Arbitrary you need?
08:14:32 <Younder> And make arguments optional
08:14:36 <quicksilver> kowey: anyhow you can pass specific 'Gen' values instead of using instances
08:14:43 <quicksilver> using 'forall'
08:14:45 <Younder> The Lazy bit is what bothers me
08:14:45 <benmachine> Younder: making some arguments optional is something you can do with a Maybe
08:14:53 <kowey> quicksilver and sclv: hmm, thanks
08:14:58 <quicksilver> erm, forAll
08:15:01 <rwbarton> pass a list of your custom option type
08:15:02 <benmachine> Younder: if that's too verbose, you could define a record type and corresponding value
08:15:05 <benmachine> etc.
08:15:14 <kowey> context is I'm just trying to make sure a prog that builds with GHC 7.0.4 also builds with 7.4.x
08:15:31 <rwbarton> ultimately variadic functions are not magic in languages that have them
08:15:39 <kowey> and somewhere in my Arbitrary instances, am getting a complaint about Text and Generic
08:15:41 <kowey> looking into it
08:15:49 <rwbarton> so you can do the same thing you do in those languages in Haskell
08:15:54 <Younder> benmachine,  which is cumbersome and tedious as you need to create a whole ste of monads to deal with it.
08:16:09 <benmachine> Younder: monads don't come into it at all
08:16:33 <zeiris> Where is the cabal build directory on Windows?
08:16:37 <kowey> (sorry, that's sort of an unhelpful characterisation of my problem, still at the random head-scratching stage)
08:16:46 <navaati> Younder: if you don't like to have statically enforced invariants, don't use haskell…
08:16:57 <Younder> benmachine,  They did in chapter 10 in Practical Haskell.
08:17:10 <benmachine> Younder: it just seems to me like e.g. python's variadic arguments are made completely redundant by the data structures
08:17:19 <Younder> For exactly those reasons. To avoid Maybe and Either
08:17:24 <benmachine> in haskell, the redundancy is not quite so immediate or obvious, but it's still there
08:17:30 <benmachine> Younder: oh, that's a different sort of context
08:17:32 <rwbarton> they're pretty close to being redundant in python also
08:17:42 <benmachine> rwbarton: that's what I meant
08:17:49 <rwbarton> i get to save typing a [ and a ], woohoo
08:17:52 <benmachine> :P
08:18:01 <rwbarton> oh i see, yes
08:18:13 <dcoutts> zeroz: ./dist/  same as on other platforms
08:18:31 <womb> random question, while processing files using lazy I/O have you seen the difference between ssd and hdd ?
08:18:38 <dcoutts> oops, zeiris ^^
08:18:56 <Younder> benmachine, I see where you are coming from. But it is in cat UGLY to have to specify a UNION beforehand. The data might change. And the the function too must change
08:19:23 <Younder> s/cat/fact/
08:19:34 <ion> zariel: Perhaps make it :: Parser (Maybe Foo).
08:19:43 <dcoutts> womb: there should be no difference due to lazy io
08:19:49 <JoeyA> womb: hGetContents and the like read the file sequentially
08:19:58 <ion> zariel: And combine such parsers with catMaybes <$> (foo `sepBy` something)
08:19:59 <benmachine> Younder: well, it's a tradeoff, given that with variadic arguments you lose the ability to detect some errors
08:20:01 <Younder> ROOM for improvement there Haskellers
08:20:11 <womb> yeah you read like 64kb chuncks and hdd do sequential read so should be none
08:20:29 <womb> thanks i will test it after work
08:20:47 <rasfar> Zariel ^ (or does case matter?)
08:21:13 <navaati> mauke: is your Printf the one shipped with GHC ?
08:21:19 <mauke> navaati: no
08:21:45 <navaati> ah. what's the difference ?
08:22:01 <mauke> I know that mine works
08:22:12 <navaati> hahaha
08:22:37 <mauke> I wrote mine after finding some bugs in Text.Printf and not getting a response
08:22:49 <Younder> benmachine, OK nested chains are UGLY and pattern matching get's you some of the way but still.
08:22:51 <mauke> and also because I wanted support for perl-style %b and %v
08:23:16 <Younder> s/chains/cases
08:23:18 <kowey> ah, I stand corrected, it's smallcheck I'm trying to “make work”, not QuickCheck and I'd done https://gist.github.com/2377626
08:23:46 <kowey> I guess I'm actually just as happy to turn off my smallcheck stuff for now and flip everything back to QC
08:24:04 <Younder> benmachine, There are times though when I HATE my solutions.
08:24:24 <navaati> mauke: ah yeah ! i remember now that the bundled one can't show binary numbers and it annoyed me a lot, great, thanks for your package :D
08:24:55 <Younder> benmachine, But then I am only a beginner. I would expect as much.
08:26:18 <benmachine> Younder: keep at it :D you'll be able to complain with more authority
08:29:13 <mzhang> Hi there, I am a totally beginner in haskell. I am about to start PhD study on network security. Do you think haskell is a good choice for research in network? Especially dealing with binary numbers and network packages.
08:29:49 <navaati> mzhang: it is, there are powerful package available
08:30:07 <navaati> but if you need to do realtime network packet processing, it isn't
08:30:36 <mzhang> any reason? performance?
08:30:49 <mcstar> space leaks
08:31:11 <Botje> mzhang: there's also cryptol
08:31:53 <navaati> mzhang: garbage collected
08:32:19 <navaati> haskell can be f*cking fast, but not really suited for RT
08:32:49 <womb> RT ?
08:32:52 <navaati> because the garbage collector can popup and make you wait when you need to react quickly
08:32:59 <navaati> (RT = realtime)
08:33:00 <mzhang> real time, womb
08:33:02 <Younder> benmachine, Perhaps there IS a way to define varadic arguments with Haskell, I'll look (probably the wrong idea, but I like exploring)
08:33:09 <womb> soft real time
08:33:13 <mcstar> cant you run GC on a parallel thread?
08:33:18 <womb> it is not able to perform RT at all because of GC
08:33:25 <benmachine> Younder: Text.Printf shows one way
08:33:54 <benmachine> mcstar: if you move your data around during a GC, probably pain happens
08:34:00 <benmachine> err I mean
08:34:02 <navaati> Younder: but it would be way better to find a more haskellish solution to your problem rather that hack to do lisp in haskell
08:34:08 <benmachine> if you do computation on your data when you're trying to analyse it
08:34:20 <benmachine> navaati: it can be enlightening to do both
08:34:34 <benmachine> mcstar: not that I'm an authority
08:34:43 * benmachine doesn't know much about GC
08:35:04 <navaati> benmachine: enlightening to see how it's awkward :D ?
08:35:32 <benmachine> navaati: sure
08:36:54 <Younder> navaati, Enlightening to explore. Clearly it is not a good solution in Haskell. I need to know why.
08:37:10 <mzhang> navaati, thank you! I'll do some check on RT problem.
08:37:13 <navaati> hum… python has been the worst thing that happened to programming… spreading wildly the dynamic typing paradigm…
08:37:34 <benmachine> navaati: python's done some things wrong but others right
08:37:42 <hiptobecubic> navaati, it could be worse. python does somethings right
08:37:49 <benmachine> it's got a syntax that isn't C-like :O
08:37:53 <navaati> oh, python is not bad
08:38:00 <hiptobecubic> yeah, significant whitespace :D
08:38:09 <navaati> what is bad is schools teaching python to beginners
08:38:11 <hiptobecubic> the most important thing since compilers
08:38:16 <Younder> navaati, I love Python. It let's me express what I think and have it work the first time.
08:38:17 <mcstar> benmachine: i just read it has some copying gc or whatever, and i have the feeling there is some work going on for a parallel gc
08:38:20 <benmachine> navaati: I dunno. it's better than teaching them C imo
08:38:20 <HugoDaniel> how do i read haddock for a function with ghci ?
08:38:23 <mcstar> (but i could also be wronger)
08:38:28 <mcstar> -er
08:38:42 <benmachine> mcstar: I think there *is* a parallel GC, but the idea is that being parallel means it works faster
08:38:51 <benmachine> not that it works in parallel with stuff actually going on
08:38:56 <benmachine> parallel not concurrent :)
08:38:57 <Younder> navaati, It is pretty much the only language that does that. (for me)
08:39:21 <mzhang> is it possible to turn off auto gc?
08:39:23 <mcstar> benmachine: yeah, sry 2 different things, i probably wanted concurrent
08:39:33 <navaati> HugoDaniel: you can't, but it's an interesting idea…
08:39:33 <benmachine> Younder: the bit where I get bitter is when it doesn't work the hundredth time because I made a typo in the error handling code
08:39:40 <hiptobecubic> I think python is a good choice for a first language in a practical sense. At least it has proper first class functions, list comprehensions, and generators.
08:39:45 <benmachine> Younder: I misspelled a variable name and it *didn't notice*
08:40:07 <rwbarton> right and you still had to wait 10 seconds for it to run to that point
08:40:37 <navaati> HugoDaniel: however if all you want if the type of a function, there is this :
08:40:40 <navaati> :t filter
08:40:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:40:44 <Younder> benmachine, Tat DOESN'T  happen. That is Perl. (Which I also program)
08:40:44 <HugoDaniel> navaati: i know
08:40:54 <womb> > map \ x -> x [1..]
08:40:54 <HugoDaniel> i also like browse
08:40:55 <lambdabot>   <no location info>: parse error on input `\'
08:41:00 <benmachine> Younder: this is a true story
08:41:06 <HugoDaniel> now a command to read haddock would be great :D
08:41:18 <benmachine> Younder: I mean, it's my fault for making a typo and not noticing, but we all do that occasionally
08:41:26 <Younder> benmachine, strict takes the 'mean' out of perl
08:41:50 <navaati> mzhang: you could be *very* interested by a thing called http://www.haskell.org/haskellwiki/Netwire
08:42:08 <benmachine> Younder: https://github.com/benmachine/tremulous-master/commit/4e0eaf496e82631a8986462c88fc4e5dd09ed9a6
08:42:29 <benmachine> Younder: that was the mistake I made, and I made it in the deserialisation code that it runs when it starts back up after it crashes
08:42:33 <td123> tremulous!
08:42:37 <benmachine> so it's never normally encountered
08:42:49 <benmachine> td123: yes, I wrote the master server in python
08:42:53 <benmachine> still better than the C one :P
08:42:59 <td123> how does it perform?
08:43:05 <benmachine> okayish?
08:43:12 <benmachine> I never really profiled
08:43:20 <benmachine> it's not really stressed very hard
08:43:44 <benmachine> I think it might have a memory leak, but if so it takes months to manifest and it's designed so you can kill it and restart it and almost no-one will notice
08:43:46 <td123> gotcha, anyways, tremulous was an awesome game :P
08:43:48 <Younder> benmachine, python should not allow you to use a variable before declaring it.
08:43:52 <t7> roconnor !
08:43:58 <womb> python lambdas are broken
08:44:12 <benmachine> Younder: are you saying that's what you think is true, or that's how you think python should be changed
08:44:14 <hiptobecubic> womb, they are so close to being good enough that it hurts me
08:44:22 <Younder> womb How true. But then they are rarely used
08:44:26 <navaati> td123: "was" ?
08:44:48 <womb> personally i think ruby is much better fitted for 1 language then python.
08:44:57 <benmachine> Younder: also, it depends what you mean by "use" - if you only access that code in a rarely-used codepath, it'll only crash in that codepath
08:45:03 <womb> because there is insane amount of tutorial
08:45:22 <benmachine> Younder: whereas a language like haskell will tell you straight away that if you ever used that codepath it would break
08:45:23 <womb> my first language was C and i loved it :) but i was not able to do everything fast.
08:45:33 <Younder> One usually uses List comprehensions. A concept borrowed from Haskell.
08:45:45 <benmachine> I liked C until I knew better :P
08:45:54 <mzhang> navaati: that is really interesting!
08:46:04 <Younder> benmachine, I still like C ;)
08:46:27 <benmachine> Younder: I still enjoy it sometimes
08:46:33 <rwbarton> C is a good language but not for writing programs in
08:46:38 <benmachine> but I usually feel like I can do better
08:46:51 <womb> C is like high level asm
08:47:04 <navaati> which, sometime, is great
08:47:39 <benmachine> womb: it's been said that if you genuinely wanted a portable assembly, you could probably design a better one than C
08:47:47 <benmachine> (I think this is what C-- was originally for?)
08:48:05 <womb> but portable assembly is oxymoron ?
08:48:21 <benmachine> womb: well, you know what I mean
08:48:25 <benmachine> a portable low-level language
08:48:30 <navaati> but yeah C is neither a good language to begin because when you begin you usually don't know how computers and OSs work, so C is useless anyway
08:48:37 <srhb> I made a funkction foo f a b = f a == f b with the signature foo :: Eq b => (forall a. [a] -> b) -> [c] -> [d] -> Bool -- and I was wondering why the Eq b constraint is necessary - isn't it implied in the == operator?
08:48:37 <srhb>  
08:48:59 <Younder> benmachine, C is a language that 'goes away'. That is let's you focus entirely on the problem. There are not many languages like that.
08:49:07 <navaati> srhb: the constraint is propagated
08:49:13 <womb> NetBSD is example of portable C
08:49:15 <mauke> srhb: you just answered your own question
08:49:23 <benmachine> srhb: well, it's needed for the == operator – the idea is that you can tell by looking at a type signature whether or not it uses ==
08:49:26 <srhb> Damn, I'm too smart for even myself to understand!
08:49:32 <mauke> srhb: the constraint is necessary because it is implied by ==
08:49:38 <srhb> Oh duh!
08:49:40 <HugoDaniel> i love C
08:49:42 <srhb> Haha. Yes, of course.
08:49:58 <rasfar> i don't feel constained by C, still quite like it.  i spend a lot more time trying to understand how to write Haskell code but part of that is where I'm at on the Haskell learning curve.  Love both languages...
08:50:01 <srhb> I can't lie to it. I was thinking of leaving out the type signature as the alternative, of course, not leaving out a constraint. Stupid me.
08:50:01 <Nimatek> Starting with C you get used to doing everything manually and after switching to a productive language you always find yourself trying to fiddle the little bytes. It makes you the programming equivalent of a pedophile.
08:50:02 <womb> and Facebook engineers c++ gwon to be almost 50% of full engineering team :) ( i know c and c++ are not same )
08:50:08 <Younder> benmachine, I like Haskell because I can focus on the specification
08:50:13 <HugoDaniel> C (ANSI, C89) > Haskell > x, where x = your favourite programming language
08:50:33 <mauke> HugoDaniel: ANSI C is C11, though
08:50:45 <HugoDaniel> no
08:50:51 <benmachine> istr C11 made me want to throw up
08:50:58 <benmachine> but that might have just been a bad first impression
08:51:05 <Younder> I am developing a language I call Formula.
08:51:29 <mauke> will you also make a ``translator'' for it?
08:51:31 <mysticc> HugoDaniel: How Haskell > Haskell
08:51:33 <HugoDaniel> mauke, i mean ANSI C89, sorry i dont knwo much about how to refer to a spec
08:51:39 <womb> C++11 has lambda that doesn't work :D
08:51:52 <womb> and its not same lambda that is defined in Boost
08:51:57 <Younder> I am using Haskell as that booter for a metacircular compiler
08:51:59 <HugoDaniel> :D
08:52:00 <navaati> srhb: btw, "foo f = (==) `on` f"
08:52:01 <womb> while Boost is TR for it
08:52:29 <srhb> :t on
08:52:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:52:34 <Younder> Still 10 000  of lines of code
08:52:34 <srhb> ah
08:53:02 <mauke> srhb: that made me smile
08:53:07 <srhb> mauke: What did? :P
08:53:09 <mauke> types as documentation :-)
08:53:16 <abizern> :t (>>)
08:53:16 <srhb> It is awesome!
08:53:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:53:27 <Leo_> hello, I'm a newbie ^_^.  I'm usint mac OS (Lion), I installed xCode from the app store, but when I try to install haskell, I get told "Please install xCode developer tools first"... Does anyone know how to resolve?
08:53:32 <womb> i'm learning haskell because it makes me think more and learn interesting things :)
08:53:33 * gdeest had a look on the draft spec of  "lambdas" and "closures" in the next Java the other day. He's still making nightmares.
08:53:40 <abizern> Oh. I didn't know I could get type signatures in here.
08:53:49 <womb> Leo i have solution for it
08:53:55 <mauke> > "abi" ++ "zern"
08:53:56 <Leo_> yah&
08:53:57 <lambdabot>   "abizern"
08:53:58 <zhulikas> gdeest, what are the news on Java8?
08:54:05 <abizern> Lea_: Have you installed the command line tools?
08:54:09 <zhulikas> when it will be released?
08:54:13 <womb> https://gist.github.com/2309766
08:54:19 <abizern> I'm running GHC on Lion FWIW
08:54:24 <Leo_> will try
08:54:30 <gdeest> zhulikas: I think it was the Java 8 draft, yes. But I don't know when it'll be out, and honestly, I don't care
08:54:40 <womb> it helps you install GHC 7.4.1 on 10.7
08:54:41 <zhulikas> hm :)
08:54:50 <zhulikas> it would be awesome to have lambdas in Java
08:55:04 <womb> Java 7 has support for lambdas ?
08:55:05 <gdeest> In the Java world, "lambdas" will just be syntactic sugar around objects with an "apply()" method
08:55:15 <zhulikas> it doesn't, womb
08:55:18 <abizern> Leo_: You still have to tweak you ghc settings, Hang on I'll see what I did.
08:55:30 <Pilipo> hy
08:55:50 <geekosaur> might be easier to remove the app store xcode, geta free developer account, and download xcode 4.2.1 from connect.apple.com
08:56:08 <abizern> What would happen if I tried to run an infinite list in here (I'm scared to try) Some of you must have tried it.
08:56:24 <mauke> > [0 ..]
08:56:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:56:27 <navaati> abizern: try, it's safe
08:56:27 <td123> > [1..]
08:56:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:56:34 <Nimatek> > last [1..]
08:56:38 <td123> lol
08:56:39 <lambdabot>   mueval-core: Time limit exceeded
08:56:45 <mauke> we eat infinite lists for breakfast
08:57:04 <navaati> mauke: you have infinite belly ?
08:57:10 <navaati> lucky boy !
08:57:13 <mauke> no, lists are very small
08:57:24 <womb> > last [1..]
08:57:28 <lambdabot>   mueval-core: Time limit exceeded
08:57:30 <wunki> anyone an idea why I get 'Failed to extract GHC build arguments' when doing `cabal-dev ghci` ?
08:57:46 <mysticc> navaati: He eats lazily ..
08:58:15 <abizern> Nice one.
08:58:37 <womb> > [1..3] ! 2
08:58:38 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
08:58:38 <lambdabot>         against inferred t...
08:58:50 <womb> > 2 ! [1..3]
08:58:51 <lambdabot>   No instances for (GHC.Arr.Ix [t],
08:58:51 <lambdabot>                    GHC.Num.Num (GHC.Arr.A...
08:58:53 <mauke> > [1 .. 3] !! 2
08:58:55 <lambdabot>   3
08:59:00 <womb> > [1..3] !! 2
08:59:01 <lambdabot>   3
08:59:35 <Younder> Maybe some Haydn 'Der Schaphung' will set things right. I love that one
08:59:53 <mauke> Schaphung?
09:00:00 <singpolyma> Hmm... I'm doing Data.Map.adjust to get a value and return a new map, but now I want to print the new value, but there's no Data.Map.adjustM
09:00:14 <abizern> Now I can't think what to write in here.
09:00:30 <mauke> did you mean: Schöpfung, Schäferhund
09:01:20 <Zariel> is there a tidyier way of doing this https://gist.github.com/2377930
09:01:25 <Zariel> maybe functors ?
09:01:58 <mysticc> singpolyma: You are doing it wrong ..
09:02:06 <srhb> navaati: Hmm, I see that they should be equal, but I get a deduce error when using foo = (==) `on` f.. What does that mean?
09:02:07 <Younder> mauke, 'Haydn: Die Schopfung' sorry
09:02:20 <singpolyma> mysticc: maybe.  what would you suggest?
09:02:35 <mcstar> is there something like foldM, but one, which lets me stop before the end of the list?
09:02:36 <mauke> srhb: what do you mean by "deduce error"?
09:02:36 <mysticc> singpolyma: show me some code ..
09:03:09 <macobo> quick check - if I use variables that are defined in a where block, they won't be evaluated in guards that don't use them? (they are lazy)
09:03:14 <quicksilver> Zariel: parseSegments sep = fmap (catMaybes) ((parseSegment sep) `sepEndBy` segSep)
09:03:35 <mauke> that's a lot of parens
09:03:37 <Younder> mauke, Woff, woff
09:03:46 <quicksilver> if you prefer you can write fmap infix as <$>, so it becomes catMaybes <$> (parseSegment sep) `sepEndBy` segSep
09:03:48 <singpolyma> mysticc: http://pastie.org/3781313
09:03:56 <Younder> mauke, ROTFL
09:03:59 <quicksilver> mauke: I put them in to emphasise, but I don't remember what.
09:03:59 <Leo_> I'll try the xcode 4.2.1 thing,
09:04:04 <srhb>     Could not deduce (c ~ d) from the context (Eq b)
09:04:04 <srhb>  
09:04:06 <srhb> Oops.
09:04:08 <macobo> quick check - if I use variables that are defined in a where block, they won't be evaluated in guards that don't use them? (they are lazy)
09:04:16 <srhb> I'll mess with it some more..
09:04:18 <navaati> srhb: it's "foo f =", not "foo ="
09:04:28 <singpolyma> macobo: yes
09:04:34 <abizern> Leo_: There are two kinds of problems you will have IIRC
09:04:36 <macobo> singpolyma: thank you. :)
09:04:49 <singpolyma> macobo: easy way to test if something is lazy: set it to undefined.  If it doesn't crash, it's lazy ;)
09:04:57 <srhb> navaati: Yes, I have the f parameter explicitly on the left hand side.
09:05:31 <abizern> Leo_: firstly, you might have to tweak the ghc setting that tells it where to find GHC, and the other is telling Xcode not to look in /Developer but in /Applications/Xcode.app/ for stuff.
09:05:33 <macobo> singpolyma: :) Thanks for the pointer. Appreciate it.
09:05:53 <navaati> now that i think about it, you could also do "foo = on (==)"
09:05:58 <abizern> Stick the error message in Google and you'll find the fixes for those.
09:06:02 <navaati> can you show again the type signature you given ?
09:06:29 <srhb> navaati: The one that works (without on): -- foo :: Eq b => (forall a. [a] -> b) -> [c] -> [d] -> Bool
09:06:29 <srhb>  
09:06:53 <navaati> srhb : why the fuck do you use a forall here ?
09:06:58 <Leo_> I've tried the google approach ^_^, bah, now downloaging cxode cmd tools
09:07:04 <navaati> and why do you use a rank2 type ?
09:07:11 <rwbarton> maybe because he wants a rank 2 type
09:07:24 <eacameron> Data.String.Utils has a `startswith` function. That's awesome. But its arguments are in "prefix, string" order. That means using it as an infix operator doesn't make sense. It would be nice to use it like "abc" `startswith` "a"...is there a way to mark issues or make comments on hackage packages?
09:07:28 <srhb> What I'm doing is foo length "bar" [1,2,3], say...
09:07:38 <womb> anyone uses vertica from you guys ?
09:07:45 <abizern> > [a] -> [[a]]
09:07:45 <srhb> Didn't see a way of avoiding the forall.
09:07:46 <lambdabot>   <no location info>: parse error on input `->'
09:07:51 <womb> we have big problems with tihs db it breaks all the time.
09:07:56 <navaati> srhb: hum, interesting
09:07:59 <singpolyma> eacameron: email the maintainer?
09:08:13 <navaati> srhb: maybe you need NoMonomorphismRestriction
09:08:17 <srhb> navaati: Why?
09:08:52 <mysticc> singpolyma: Its bad to mix something impure with a pure code .. I thing the best you can do it to lookup the value again ..
09:09:00 <srhb> ah wait.. 'on' is not sufficiently polymorphic in itself.
09:09:10 <Younder> MonoMorphism is cool
09:09:11 <Leo_> Ah, thanks for the tips guys, havint installed the "
09:09:14 <singpolyma> mysticc: yeah, I didn't really want to have to do that, but I guess I could
09:09:22 <Leo_> "command line tools" thing, now haskel installs
09:09:34 <eacameron> signpolyma: I guess that works...just curious if there were other/better ways
09:09:37 <srhb> That explains.
09:10:20 <navaati> ah, yeah… mindblowing, i must be tired
09:10:32 <Younder> Homomorphism is vital to Topology. Haskell goes a step further and uses Isomorphism.
09:10:42 <ksf> hmmm. some hackage packages have links to the wiki for comments.
09:11:03 <ksf> ...probably a matter of when the docs were generated.
09:11:08 <singpolyma> I usually link to the Github issues page for my Hackage packages
09:11:16 <singpolyma> so, if they have a similar link you could use that too
09:11:46 <ksf> eacameron, import qualitified, foo = flip Bar.foo
09:11:56 <ksf> "qualified", even.
09:13:22 <eacameron> ksf: yeah...that would work too, but then I have to define my own version of it... just wondering, it's not a big deal. Unfortunately it's not a backwards-compatible change :(
09:14:44 <ksf> :t isPrefixOf
09:14:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:15:03 <ksf> > "foo" `isPrefixOf` "foobar"
09:15:04 <lambdabot>   True
09:15:45 <womb> "bar" `isSuffixOf` "foobar"
09:15:51 <womb> > "bar" `isSuffixOf` "foobar"
09:15:52 <lambdabot>   True
09:17:31 <quicksilver> eacameron: how is it different from the standard isPrefixOf ?
09:18:09 <quicksilver> eacameron: hmm I was scrolled up a bit, ksf already made that point by example.
09:18:50 <womb> isn't it a way ofr calling functions with 2 args to make it read better ? using ` foo `
09:19:04 <womb> nice syntax feature
09:19:26 <mysticc> Can I convert f :: a -> m b to m ( a -> b) ?
09:19:39 <quicksilver> mysticc: no
09:19:46 <mysticc> quicksilver: why
09:19:54 <quicksilver> mysticc: the former, in general, can inspect 'a' before decide what action to do.
09:20:02 <rwbarton> why does Data.String have all this stuff
09:20:05 <hpc> mysticc: that's converting from monad to applicative, essentially
09:20:09 <rwbarton> oh never mind
09:20:10 <quicksilver> mysticc: the latter can only perform an action and then return a pure function (a -> b)
09:20:31 <quicksilver> quite a lot of CosmicRay's MissingH has been obsoleted by more recent libraries
09:20:58 <quicksilver> and a little of it he simply missed what was already there, I think :)
09:21:11 <rwbarton> I was actually looking at Data.String from base
09:21:36 <MrFenix> I tried to install opengl, but it failed because of https://github.com/haskell-opengl/OpenGL/issues/26
09:21:44 <MrFenix> what is the best way to go on now?
09:21:50 <MrFenix> git clone & manual installation?
09:22:16 <benmachine> so guys I wrote a function
09:22:50 <benmachine> /specifically/ I wrote a function that uses TH to supply a class instance only if it doesn't already have one
09:22:57 <mysticc> quicksilver: I have a function f:: (a->b) -> c .. and I want a function g:: (a-> m b) -> m c .... which is monadic version of f ... is this possible to do ?
09:23:01 <benmachine> it's a tiny little bit evil but I suspect it will sometimes be helpful
09:23:09 <benmachine> however I don't know what to call it :(
09:23:49 <zhulikas> call it makeEvil
09:24:07 <mysticc> zhulikas: makeDevil looks much cooler :P
09:24:09 <quicksilver> mysticc: no, because there really isn't an (a->b) inside there for you to use.
09:24:14 <zhulikas> yeah, or that
09:24:26 <rwbarton> there is precedent already with reallyUnsafe, so you can go with slightlyUnsafe
09:24:31 <mysticc> quicksilver: Yeah .. I thought so ..
09:24:35 <mysticc> thanks
09:27:57 <benmachine> rwbarton: it's not unsafe though, it's just unsavoury
09:28:06 <benmachine> and anyway I want to actually describe what it does in the name :P
09:30:21 * Mathnerd314 waits impatiently for next Haskell platform
09:30:48 <abizern> Mathnerd314: You too, huh?
09:32:00 <Mathnerd314> maybe they could move to a rapid-release process...
09:33:12 <mcstar> this is my (probably) final code http://hpaste.org/66917
09:34:27 <mcstar> im not sure why it consumes more memory on the way, since afaik the 'problem' vector is generated in the beginning
09:34:38 <mcstar> which takes time, and uses like ~1G of memry
09:35:22 <abizern> Mathnerd314: It's been over a year IIRC.
09:40:47 <mcstar> http://imgur.com/0fxpU a most interesting profiling
09:41:16 <mcstar> my damn vector, which holds 32x1M bytes stays constant
09:41:59 <mcstar> but the hashmap will grow beyond its size, which holds 16 bytes per value/key pair
09:45:14 <rwbarton> a HashMap isn't a hash table
09:45:37 <eacameron> quicksilver: yeah, it makes sense for isPrefixOf...but not startswith. that's my point
09:46:16 <rwbarton> how many entries are you putting in the HashMap? looks like 20M?
09:46:51 <mcstar> rwbarton: now that i rewrote it, so that that long random vector stays the same size, and it is generated initially, i can finally measure the hashtable hashmap hashwhaever's size
09:46:57 <mcstar> 1M
09:47:17 <hpaste> srhb pasted “Is bar a rank-3 type?” at http://hpaste.org/66918
09:47:33 <edwardk> mcstar; a hash map is n log n with a high fanout, but there is still a log factor overhead
09:47:35 <mcstar> rwbarton: on the picture, 1Mx32bytes in the vector, thats ok, but the hashtable got to store 2*8*1M bytes
09:47:41 <srhb> I left out the Eq which seems to tell me "yes"
09:47:49 <rwbarton> why wouldn't it
09:47:57 <rwbarton> is this a 32-bit or a 64-bit system
09:48:00 <mcstar> 64
09:48:10 <rwbarton> pretty amazing that it only uses that much space
09:48:12 <dolio> srhb: Yes, I think it's rank 3.
09:48:23 <mcstar> ah, say what? amazing?
09:48:27 <mcstar> ridiculouys
09:48:29 <mcstar> -y
09:48:33 <rwbarton> come on
09:48:41 <rwbarton> you are storing 1 million (key, value) pairs
09:48:51 <mcstar> yeah? thats nothing
09:48:52 <rwbarton> each of those keys and values takes 1 word to store
09:48:57 <rwbarton> so 2 * 8 * 1M bytes
09:48:58 <rwbarton> tada
09:49:27 <elliott> yeah that space usage looks totally reasonable to me
09:49:59 <mcstar> the dark blue and green stripes are the values that are supposed to be stored in the hashmap
09:50:19 <rwbarton> well it's not unboxed
09:50:20 <edwardk> srhb: yes. you can even confirm it by tryng to compile with Rank2Types instead of RankNTypes
09:50:45 <rwbarton> you can't currently have an unboxed and yet polymorphic HashMap
09:50:48 <mcstar> rwbarton: as i said, now that i isolated the hashtable usage, ill try different ones
09:50:50 <mcstar> again
09:50:57 <dolio> Someone should write a @rank plugin for lambdabot.
09:50:59 <srhb> edwardk: Oh neat, I did not know that!
09:51:22 <dolio> There's no Rank3Types to check that it's only rank-3, though.
09:51:29 <dolio> So it'll just give you a lower bound.
09:51:46 <rwbarton> I'm not sure what the green stuff is
09:51:59 <rwbarton> I imagine it is some HashMap-related overhead
09:52:42 <srhb> dolio: OK, it's a nice start though. I don't imagine I will be producing a lot of rank 4, 3 or even 2-functions anytime soon O:-)
09:53:42 <mcstar> rwbarton: ah yeah, sry i meant to say blue and black
09:58:51 <mcstar> this is with IntMap instead of HashMap http://imgur.com/9QeVD
09:58:59 <srhb> Why was it that I could leave out forall on c and d in this one? foo :: Eq b => (forall a. [a] -> b) -> [c] -> [d] -> Bool
09:58:59 <srhb>  
09:59:34 <mcstar> rwbarton: do you think people would be interested in this stuff? shall i blog about this?
09:59:39 <benmachine> srhb: some foralls are implicit
09:59:50 <mcstar> (feels a tiny bit important to me, but im not sure)
09:59:54 <dolio> srhb: You can leave out any foralls that go all the way at the front.
10:00:11 <sipa> that's equivalent to Eq b => forall c d. (forall a. [a] -> b) -> [c] -> [d] -> Bool
10:00:21 <srhb> Ohh..
10:00:28 <sipa> oh, and b
10:00:31 <dolio> And 'T -> forall a. U' is the same as 'forall a. T -> U' as long as 'a' doesn't appear in U.
10:00:42 <dolio> Er, doesn't appear in T.
10:01:02 <srhb> Wow, okay, can I look up these rules somewhere or do I have to infer them? :P
10:01:28 <dolio> Probably a book on logic or something.
10:01:45 <zhulikas> forall. gives you ability to use types as variables inside your function
10:01:46 <dolio> Although you have to be a bit careful.
10:01:49 <elliott> That one is pretty easy to understand.
10:01:50 <zhulikas> if you don't need it, don't use it
10:02:06 <elliott> zhulikas: Erm, isn't that just with ScopedTypeVariables?
10:02:08 <elliott> That's more of a side-effect.
10:02:16 <elliott> forall is primarily there for higher-rank polymorphism.
10:02:21 <zhulikas> ahh
10:02:24 <zhulikas> sorry then
10:02:25 <zhulikas> my bad.
10:02:39 <zhulikas> I thought forall a. is only for ScopedTypeVariables
10:02:40 <dolio> ScopedTypeVariables requires you to explicitly quantify the variables you want to be scoped.
10:02:51 <elliott> (which is annoying)
10:03:06 <rwbarton> mcstar: well sure, as long as you don't express too much surprise that a HashMap of 1M entries uses 2*8*1M bytes :P
10:03:17 <rwbarton> it looks like in the end, the IntMap uses about the same amount of space?
10:03:35 <rwbarton> since it doesn't have to store the keys
10:03:49 <rwbarton> or rather it can unbox the keys
10:04:59 <mcstar> that hashmap used 2*2*8*1M bytes at least(more, cause it went above ARR_WORDS, which was 32*1Mbytes)
10:05:25 <mcstar> (and there were still Int and Word64 values there, plus the green stuff)
10:06:05 <rwbarton> i suggest you try implementing your program in java or something as well
10:06:15 <mcstar> i have it in c++ and f#
10:06:26 <mcstar> they use a fraction of the memory
10:06:36 <rwbarton> C++ cheats
10:06:40 <rwbarton> what do you mean by "fraction"
10:06:48 <rwbarton> like, half?
10:07:22 <c_wraith> mcstar: are you still using the hashmap we told you is horribly inefficient?
10:07:23 <elliott> (Obligatory note that you cannot compare mutable and persistent structures.)
10:07:24 <mcstar> i cited this many times, c++ 16%, f# 28%, HS 77% or my total memory
10:07:39 <elliott> c_wraith: HashMap is fine?
10:07:42 <elliott> It's unordered-containers.
10:07:45 <elliott> It's HashTable that sucks.
10:07:50 <mcstar> c_wraith: im doing comparisons among all of them
10:08:10 <mcstar> rwbarton: now, this numbers are from an earlier version, where i dont cheat
10:08:10 <rwbarton> hmm
10:08:12 <rwbarton> > 77/16
10:08:13 <lambdabot>   4.8125
10:08:24 <rwbarton> your numbers are obviously impossible
10:08:30 <mcstar> haha
10:08:33 <mcstar> no
10:08:34 <rwbarton> since you have a vector of 32 M
10:08:45 <rwbarton> are you telling me that in C++ you don't need 32M to store 32M of data
10:08:45 <mcstar> yeah?
10:08:52 <mcstar> ofc i do
10:09:03 <mcstar> i mean sry, i dont
10:09:15 <mcstar> 32m bytes needs at least 32m bytes of memory
10:09:27 <rwbarton> okay
10:09:38 <rwbarton> your hash table needs another 16M of data right
10:09:38 <mcstar> anyway, the probelem size is 10M in the benchamrk
10:09:53 <rwbarton> if you are using a 100% full hash table which is insane
10:09:54 <mcstar> but my profiling are done with 1M to be manageable
10:10:08 <rwbarton> > 48 * 4.8125
10:10:09 <lambdabot>   231.0
10:10:12 <c_wraith> this seems like you're using a persistent structure but not allowing the old ones to be collected
10:10:20 <rwbarton> where is the 231 MB of Haskell usage
10:10:57 <c_wraith> Or else you're counting allocation, rather than resident
10:11:07 <rwbarton> or maybe you are counting gc overhead
10:11:31 <mcstar> you can see the command i used to generate those images
10:11:38 <mcstar> -p -hy
10:11:48 <mcstar> im counting what that counts
10:11:48 <rwbarton> I can also see that the top of the graph ends well before 231 MB
10:12:41 <mcstar> rwbarton: i said that that benchmark between the languages i from an earlier version
10:12:57 <mcstar> since then, i managed to bring down space by 2x
10:12:59 <rwbarton> then why did you bring it up
10:13:00 <rwbarton> okay
10:13:10 <mcstar> because it is still too much
10:13:29 <mcstar> and i have to store the vector at once, and i cant store chunks as values in the hashtable
10:13:41 <rwbarton> so basically you quoted a bunch of irrelevant numbers at me
10:13:47 <mcstar> not at all
10:14:20 <mcstar> it shows what is the bare minimum, the problem can be solved
10:14:27 <rwbarton> anyways, I already explained where the space is going, HashMap is polymorphic in the keys and values so they cannot be unboxed
10:14:30 <rwbarton> C++ cheats in this regard
10:14:37 <rwbarton> I have no idea what F# does
10:14:49 <mcstar> it uses .net collections
10:14:58 <rwbarton> .net is some fairy tale to me
10:15:09 * elliott wishes GHC did polymorphic unboxing
10:15:10 <mcstar> i dont know what that means, but nvm
10:15:23 <mcstar> so now ill try other hashthings
10:15:36 <mcstar> with IntMap it is a bit better
10:15:52 <rwbarton> anyways "i cited this many times, c++ 16%, f# 28%, HS 77% or my total memory" when you are talking about some unspecified old version does not tell me anything
10:16:07 <liyang> elliott: me too. ISTR there's a ticket for it.
10:16:29 <c_wraith> polymorphic unboxing seems...  problematic.
10:16:30 <mcstar> rwbarton: i just recently did this rewrite
10:16:30 <elliott> i saw augustss say that it's known how to do it, just nobody's bothered yet
10:16:41 <elliott> if not for that, i'd probably say it's almost impossible :)
10:16:43 <mcstar> and i thin you have the code
10:16:46 <mcstar> from yesterday
10:16:50 <rwbarton> what
10:16:52 <mcstar> but maybe that wasnt you
10:16:53 <rwbarton> I have never seen your code before
10:16:59 <mcstar> ok, dont be angry
10:17:21 <elliott> c_wraith: (obviously it'd only work if the type was known at compile-time)
10:17:28 <c_wraith> I mean...  boxing is necessary for the way ghc handles multiple constructors - so only things with a single constructor can be unboxed, too
10:18:01 <c_wraith> I guess it's just a relative of specialization when you know the type at compile time.
10:18:06 <elliott> c_wraith: sure, so? the applies to {-# UNPACK #-}
10:18:21 <elliott> c_wraith: it's annoying that if you want, e.g. an unboxed list type, you have to code the exact same type again for every element type
10:18:26 <elliott> but with s/a/TheType/
10:18:40 <liyang> c_wraith: I have an Unbox instance (in the vector sense) for Maybe...
10:18:47 <elliott> and with mcstar's code, if HashMap could unbox its keys, it'd save lots of memory
10:18:54 <edwardk> elliott: BitC, c++ and a couple of other ATS-like languages do various forms of 'polymorphic unboxing'
10:19:07 <elliott> edwardk: C++ cheats by not really having polymorphic containers :)
10:19:08 <rwbarton> keys and the values
10:19:10 <edwardk> yeah
10:19:19 <elliott> I think BitC does too, but I'm not sure
10:19:25 <edwardk> c++ is the least convincing of those, given that templates just get specialized down
10:19:57 <edwardk> but as i recall BitC and whatever the language that Eli who worked here for a while was working on deal with the polymorphic unboxed variables by parameterizing them on their sizes
10:20:06 <elliott> ah, that's clever
10:20:36 <edwardk> Ultimately I don't have to care what I unboxed as long as I know how big it is ;)
10:20:51 <liyang> wrt multiple constructors, you could union them in the C sense.
10:21:19 <rwbarton> don't you also have to track where pointers are
10:21:23 <edwardk> liyang: i've been able to get away with unboxing multiple constructors by abusing unsafe coerce and (#'#)'s
10:21:36 <elliott> what rwbarton said
10:21:41 <edwardk> rwbarton: only if you have gc
10:21:47 <rwbarton> yes.... :)
10:21:48 <elliott> ghc has gc :P
10:21:56 <rwbarton> but fair enough
10:21:57 <liyang> edwardk: got an example handy?
10:22:09 <elliott> well, we could get ghc to put all pointers first, or all pointers last, or such
10:22:13 <edwardk> rwbarton: if you use region based allocation, you can avoid that, which is what the bitc guys and eli were doing
10:22:15 <elliott> then it'd just be parametrised on (# of pointers, # of data)
10:22:21 <edwardk> but that doesn't play well with laziness
10:22:31 <edwardk> elliott: which is baically unpackClosure# ;)
10:22:45 <edwardk> liyang: one sec. i stackoverflowed a response with something kind of like that
10:22:51 <elliott> hmm, never heard of that one
10:23:03 <elliott> oh, is that the thing that vacuum uses?
10:23:27 <edwardk> http://stackoverflow.com/questions/8164998/what-is-the-fastest-error-monad-in-haskell/8498078#8498078
10:23:54 <edwardk> liyang: in that I use r -> (# Bool, a #) with some unsafeCoerces to model r -> Maybe a
10:23:54 <liyang> polymorphic unpacks http://hackage.haskell.org/trac/ghc/ticket/3990
10:24:13 <edwardk> liyang: but i've also done so with more complicated error monads
10:24:49 <elliott> edwardk: oblig. http://hpaste.org/56368
10:25:25 * edwardk throws up on elliott's shoes.
10:25:42 <elliott> blame kmc, not me
10:25:51 <elliott> hey, what's the "r ->" in that M?
10:25:57 <elliott> oh, because you can't just have (# Bool, a #) on its own
10:25:58 * edwardk dry heaves on kmc's shoes.
10:26:18 <edwardk> elliott: usually i use that kind of construction inside of a more complicated monad with state, etc.
10:26:22 <edwardk> i needed something
10:26:26 <edwardk> so i just gave it an environment
10:26:28 <elliott> "If you are feeling daring you can smuggle an unsafeCoerced error through in the 'a' slot on failure as well and extract it at the end" this is why we need data Maybe a = Nothing (forall b. b) | Just a
10:26:52 <elliott> Nothing (error "flux capacitor overheated")
10:27:02 <liyang> edwardk: ah, I've been using the example at the bottom of http://hackage.haskell.org/packages/archive/vector-th-unbox/0.1.0.0/doc/html/Data-Vector-Unboxed-Deriving.html
10:27:13 <liyang> But I like elliott's version.
10:27:43 <elliott> It's kmc's!
10:27:45 <elliott> I'm innocent!
10:27:51 <rwbarton> it looks like just# nothing# = nothing#
10:28:07 <rwbarton> so that means join# is easy to write
10:28:08 <dolio> Yep.
10:28:10 <rwbarton> join# = unsafeCoerce#
10:28:14 <elliott> rwbarton: yes, also <kmc> it works except sometimes nothing# segfaults  <kmc> but that's just the price you pay for SPEED
10:29:02 <dolio> Or you could switch to JHC.
10:29:15 <edwardk> clearly you should just replace nullAddr# to some other random sentinel
10:29:18 <edwardk> and then you're fine
10:29:30 <edwardk> data Null = Null
10:29:33 <elliott> edwardk: I told him he should allocate a new sentinel if just# gets passed the current one.
10:29:36 <edwardk> nothing# = unsafeCoerce# Null
10:29:47 <elliott> That would still make just# nothing# be nothing#.
10:31:40 <edwardk> elliott: the crashing problem appear's to be the kind change, so if you swap to a singleton sentinel of kind * like Null, it should fix the crashing at least
10:32:03 <elliott> that might make it slower!
10:32:05 <edwardk> then you can just use reallyUnsafePtrEquality on the forced version of a
10:32:10 <edwardk> there is that
10:32:12 <liyang> magic hash *and* join(t)s for free. waheeee!!
10:33:26 <elliott> anyway, someone write Either#
10:33:36 <nyingen> Do people usually bring hash to these haskell meetups?
10:34:25 <liyang> We hide it with GHC until you say the magic word.
10:35:11 <edwardk> elliott: box the left hand argument only and then run down to the info table to see if you have a left constructor?
10:35:36 <edwardk> erm, strictness problems, nevermind
10:35:38 <liyang> elliott: sure. Use the LSB of the address as a tag.
10:36:11 <edwardk> liyang: nah, on 64 bit, use the msb, by switching to the other canonical pointer representation
10:36:12 <elliott> liyang++
10:36:31 <elliott> i like how x86 requires the implementation to not let you stuff things in the extra bits
10:36:35 <elliott> to stop people abusing them for tag bits
10:36:37 <elliott> or something
10:36:40 <edwardk> yeah
10:36:42 <elliott> like it checks them on dereference
10:36:45 <elliott> er by x86 i mean x86-64
10:37:18 <mcstar> why does the profiler generate only 18 seconds of profiling? my program runs for 62 seconds o.O
10:37:32 <edwardk> i do like the fact that you can still manage to smash pointers into a form where they are NaNs as a double though
10:38:21 <edwardk> clearly we need to just do unboxing by representing the unboxed values as illegal pointers
10:38:31 <edwardk> like lua
10:38:51 <edwardk> it'll be so much more efficient to plumb special cases everywhere
10:39:09 <fmap> is there some shortcut for (f <$>) <$> ?
10:39:36 <keep_learning> mcstar, probably rest time will be GC
10:39:37 <elliott> (fmap.fmap) f
10:39:44 <rwbarton> fmap: fmap fmap fmap
10:39:52 <elliott> with that name you shouldn't have to ask!
10:39:55 <fmap> very nice
10:39:56 <keep_learning> mcstar, see the MUT time ( I think it should be 18 second )
10:40:16 <mcstar> MUT     time   18.02s
10:40:22 <mcstar> you are my hero !
10:40:54 <mcstar> what does MUT stand for?
10:41:27 <keep_learning> mcstar, its time which program did the productive work
10:41:34 <keep_learning> mcstar, and rest is GC
10:41:38 <mcstar> i get it, i want the acronym
10:41:44 <jix> mcstar: MUT is short for mutator IIRC
10:41:59 <mcstar> thanks
10:55:00 <Clint> how would i do something like | fmap (==5) x = "guard expression is true"?
10:55:37 <hiptobecubic> Clint, does that not work?
10:56:03 <Clint> hiptobecubic: no, because it returns f0 True
10:56:58 <elliott> Clint: I don't understand what you want, but the answer is probably:
10:57:09 <elliott> = do { b <- fmap (==5) x; if b then ... else ... }
10:58:19 <hiptobecubic> elliott, does that require x to be monadic?
10:58:46 <keep_learning> > fmap
10:58:47 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> f a -> f b)
10:58:47 <lambdabot>    arising...
10:58:52 <hiptobecubic> instead of, say, just a tuple?
10:59:23 <elliott> hiptobecubic: Tuples have a perfectly cromulent Monad instance.
10:59:27 <elliott> hiptobecubic: But, err...
10:59:38 <elliott> hiptobecubic: How do you want to treat a tuple as a boolean?
10:59:39 <Clint> elliott: that gets me     Couldn't match expected type `Bool' with actual type `m0 b0'
10:59:44 <hiptobecubic> elliott, oh. I didn't know
10:59:48 <elliott> Clint: What is the type of the function you are trying to write?
10:59:51 <elliott> hiptobecubic: Well, it's not in base, alas.
10:59:58 <elliott> hiptobecubic: Despite the corresponding Applicative being.
11:00:03 <elliott> hiptobecubic: It's just Writer.
11:00:09 <elliott> Clint: I suspect you're trying to write an impossible function.
11:00:22 <Clint> elliott: Hash ctx d => B.ByteString -> Int -> d
11:00:32 <Clint> where d is what i'm trying to fmap
11:01:02 <elliott> Okay. Why are you trying to use guards?
11:04:22 <Clint> elliott: i suppose i have no good answer to that
11:04:50 <elliott> I mean, I don't understand what you're trying to do at all :)
11:05:13 <mcstar> it is supposed to be obvious from the type signature
11:05:37 <hpaste> Clint pasted “impossible function” at http://hpaste.org/66919
11:05:43 <Clint> elliott: does that help?
11:05:57 <elliott> Okay, well, you can't use a monadic action as a guard!
11:06:04 <elliott> I meant that you would have to skip the guard entirely.
11:06:10 <Clint> right
11:06:12 <elliott> What is Hash?
11:06:19 <elliott> As in, can I see the definition of the typeclass Hash?
11:06:28 <Clint> elliott: http://hackage.haskell.org/packages/archive/crypto-api/0.6.4/doc/html/Crypto-Classes.html
11:06:54 <mcstar> Clint: what are you doing this for?
11:06:55 <elliott> Okay. Why are you using fmap on values of type d?
11:07:06 <elliott> You don't know that d is f a for some Functor f.
11:07:09 <elliott> So you can't do that in the first place.
11:07:10 <Clint> mcstar: rfc4880 implementation
11:07:29 <Clint> elliott: because i failed at having that function return a bytestring and still be able to deduce the hash instance
11:07:58 <elliott> Well, the answer is that you can't use fmap. You'll either have to work with what Hash gives you, or make your function more monomorphic.
11:08:49 <osoleve> hi! long time no pester. i'm trying to do a frequency count of items in a list, and i want to be able to sort by value (not item) afterwards. what container would be most suited to this?
11:09:08 <osoleve> i can't figure out if it is possible to sort a map by value
11:12:07 <jfischoff> osoleve: how many items do you have?
11:12:25 <Clint> elliott: well, i'm not sure what to do here.. if i convert to bytestring before appending i lose the ability to use the hash instances
11:12:50 <osoleve> jfischoff, potentially a lot, high hundreds to low thousands
11:13:17 <glguy> osoleve: You could use a finger tree with two measures, one to sort the elements by key and one to find the minimum value
11:14:28 <osoleve> glguy, hmm, okay. looking into that, thanks
11:14:42 <jfischoff> osoleve: Have you tried a naive implementation? Might be performant enough.
11:14:44 <elliott> Clint: Sorry, I don't know enough about the library you are using to offer specific advice.
11:14:54 <Clint> elliott: alas
11:15:05 <glguy> osoleve: or look at the PSQueue library
11:15:05 <osoleve> jfischoff, as in, a list of tuples?
11:15:38 <jfischoff> osoleve: yes, using sort and groupBy
11:16:17 <osoleve> jfischoff, I hadn't considered it, I assumed that for a large data set it might be slow
11:16:28 <osoleve> but i'll give it a shot, it might be okay :)
11:16:32 <osoleve> thanks
11:16:40 <jfischoff> good luck
11:19:49 <mcstar> judy arrays are nice http://imgur.com/K6b0l
11:20:01 <ezyang> GHC linker is annoying
11:20:09 <elliott> mcstar: they're not persistent
11:20:32 <mcstar> i thought it allocated in c, and that wasnt visible to the profiler
11:20:41 <mcstar> what do you mean not persistent?
11:20:53 <mcstar> or rather, how?
11:21:01 <elliott> http://en.wikipedia.org/wiki/Persistent_data_structure
11:21:07 <elliott> just pointing out you can't compare it to HashMap
11:22:26 <mcstar> so non-persistent means, it gets overwritten?
11:22:37 <mcstar> thats fine with me
11:23:00 <elliott> It may be fine with you, but it means you can't really compare it to persistent structures like HashMap, because they're fundamentally different.
11:23:21 <mcstar> sure i can compare
11:23:48 <mcstar> i can compare a car and an airplane
11:24:03 <mcstar> and i decide which one i choose for the ride
11:24:25 <elliott> Yes, but you can't then say that cars > aeroplanes.
11:24:36 <mcstar> no, ofc not
11:24:48 <monochrom> people compare programming languages with guns all the time
11:24:57 <mcstar> but from a specific point of view you can say, hm now im gonna choose this over that
11:25:30 <mcstar> elliott: i never heard of judy arrays before someone pointed them out ro me here
11:25:35 <mcstar> that was yesterday
11:26:21 <vhd> Hey all, im developing a shogi (slightly bigger chess) game but finding difficulty in dealing with the ai, I was advised to switch from using list to data.sequence to gain optimisation, but it runs slower now. Any tips/advice would be appreciated in getting the AI to at least look 2-3 ply ahead?
11:26:43 <mcstar> damn plies
11:27:00 <mcstar> i abandoned tham totally for aichallenge
11:27:01 <monochrom> switch back to list :)
11:27:24 <vhd> but problem is I can barely look ahead
11:27:35 <elliott> Seq is strct, so
11:27:45 <vhd> I was really hoping seq would have helped.
11:27:48 <elliott> *strict
11:28:37 <vhd> mcstar what do you mean?
11:28:54 <hpc> vhd: if you just don't care about niceness, IOUArray
11:28:55 <hpc> :P
11:29:09 <vhd> nah thats the catch, I have to keep it functional.
11:29:12 <mcstar> vhd: well, it was too costly, so i went with a different approach
11:29:13 <hpc> :(
11:29:26 <vhd> mcstar, what was your approach?
11:29:28 <mcstar> (in hindsight, i should have left there 1 ply lookahead at least)
11:29:28 <hpc> immutable arrays might still help
11:29:40 <vhd> random selecting a certain amount of moves?
11:29:42 <monochrom> it is wise to keep it functional because of backtracking
11:29:46 <hpc> might perform better than list
11:29:58 <mcstar> vhd: i calculated vulnerable tiles and attacked those
11:30:25 <vhd> hpc dont arrays copy on each change?
11:30:29 <elliott> yes
11:30:39 <elliott> perhaps IntMap? (but also spine-strict)
11:30:53 <elliott> or restructure your algorithm entirely as opposed to just swapping out a data structure :p
11:31:01 <mcstar> elliott: now the HS version runs *exactly* in the same space/time as the c++ one, now i wonder if they use judy arrays in their unoredered_map
11:31:08 <jfischoff> would the Logic monad be applicable for the backtracking?
11:31:17 <monochrom> yes
11:32:51 <monochrom> though, just for 2-3 plies you still don't need the speed of Logic yet
11:33:23 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html
11:33:51 <kallisti> mueval-core: GhcException "You  can't call compileExpr in a  profiled compiler"
11:33:55 <kallisti> any idea what this is about?
11:34:09 <monochrom> it merely uses the list monad for backtracking. try throwing some n-queen problem at it. it is not slow.
11:35:01 <monochrom> I am saying that if you can't even get to 2 plies, you have a terrible algorithm
11:35:12 <jfischoff> that's cool
11:36:18 <vhd> monochrom, I suspect this to be the case, but having trouble identifying what I may be doing wrong.
11:36:41 <monochrom> so, my first advice is: do you even know what lazy evaluation means? http://www.vex.net/~trebla/haskell/lazy.xhtml
11:36:56 <vhd> I know what lazy evaluation is
11:37:21 <monochrom> after knowing lazy evaluation, my second advice is: then design your algorithm based on lazy evaluation
11:37:41 <jfischoff> monochrom: keep posting links
11:38:00 <elliott> http://google.com
11:38:10 <elliott> http://purple.com
11:38:20 * elliott is a link-posting experr
11:38:21 <elliott> t
11:38:29 <jfischoff> elliot: amazing
11:38:31 <parcs`> zombo.com
11:38:33 <monochrom> I can't be more specific, since I haven't seen your current algorithm for critique, and I am not willing to see it, it is going to be tl;dr
11:39:05 <vhd> yeah, I understand.
11:39:06 <jfischoff> the purple.com really captures my emotional state
11:39:49 <mcstar> elliott: this is totally awesome, i reached a problem size of 40M, in half my memory, and found 2 SHA256/50bit hash collisions
11:40:15 <mcstar> now i just need to make this parallel
11:41:03 <liyang> Back to Either#… Wait. This makes no sense. Is GHC already using the LSB for something? http://hpaste.org/66924
11:41:21 <elliott> liyang: btw, "M# . unsafeCoerce#" is so wasteful, just unsafeCoerce# would do
11:41:48 <elliott> liyang: GHC does pointer tagging
11:41:50 <elliott> I forget what for
11:42:00 <elliott> you might have to tag some other bit instead :)
11:42:41 <liyang> Oh: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
11:43:05 <elliott> pointers are only 48 bits in practice
11:43:08 <elliott> so you have a lot of bits you can tag
11:43:25 <elliott> assuming you're on 64-bit
11:43:34 <elliott> it has more registers and thus more SPEED, so i assume you are
11:43:52 <liyang> If I'm on 32, then I'm out of options?
11:44:04 <elliott> well, not necessarily!
11:44:27 <elliott> liyang: just use the most significant bit and hope the pointers don't end up that big in practice
11:44:31 <elliott> iirc linux reserves that space for the kernel anyway
11:45:15 <monochrom> but I can be specific about my own work. my ForwardConstraint there uses the list monad for "multiple solutions and backtracking", and this use is based on knowing what happens to lists in lazy evaluation. as a result, if you just asking for k answers, the majority of the computation is for those k answers, only a minority of the computation is for some answers you don't ask for
11:45:30 <liyang> I thought Linux reserved like the top 1GB or something. It's not evenly split.
11:45:45 <elliott> liyang: oh well, just risk it ;)
11:45:51 <liyang> True.
11:46:13 <monochrom> now suppose someone blindly replace my list with sequence based on random advice from IRC. the result is going to be disaster.
11:46:40 <liyang> This is getting pretty stupid already.
11:51:31 * hackagebot hobbits 1.1 - A library for canonically representing terms with binding  http://hackage.haskell.org/package/hobbits-1.1 (EddyWestbrook)
11:52:07 <liyang> OMG. Try unsafeCoerce# (plusAddr# nullAddr# 2#) :: Bool
11:53:02 <elliott> cute
11:53:15 <elliott> Prelude GHC.Prim> unsafeCoerce# (plusAddr# nullAddr# 2#) :: Bool
11:53:15 <elliott> True
11:53:15 <elliott> Prelude GHC.Prim> unsafeCoerce# (plusAddr# nullAddr# 1#) :: Bool
11:53:15 <elliott> False
11:53:15 <elliott> Prelude GHC.Prim> unsafeCoerce# (plusAddr# nullAddr# 0#) :: Bool
11:53:15 <elliott> False
11:53:17 <elliott> Segmentation fault
11:53:20 <elliott> ah, so that's how you represent FILE_NOT_FOUND in Haskell
11:53:30 <liyang> =)
11:54:17 <monochrom> because of pointer tagging, unsafeCoerce# (plusAddr# nullAddr# a_small_number_here) :: My_Algebraic_Data_Type works most of the time. in short, pattern matching is compiled to merely checking lower bits of the address
11:55:56 <nyingen> for Haskell', I suggest we eliminate all array types except 1, or pass a law that any author of an array library has to provide methods for conversion of his array type to all other array types
11:56:14 <nyingen> of course, the latter solution raises the question of enforcement. How about a haskell secret police force
11:56:33 <dolio> The haskell report doesn't standardize any array types.
11:56:42 <dolio> Unless I'm mistaken.
11:56:53 <monochrom> there is 1 bit that says, "I am / am not in WHNF". if that bit says WHNF, there are a few more bit that says, "I am the 1st / 2nd / 3rd ... constructor", so you already know True vs False, or Nothing vs Just, etc
11:57:03 <dolio> Oh, I guess it does have the one.
11:57:12 <dolio> Immutable arrays.
11:57:27 <elliott> @quote ddarius isJust
11:57:28 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
11:57:30 <elliott> @quote shachaf isTrue
11:57:31 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
11:57:39 <nyingen> trying to get different C libraries to work together via haskell seems to be unnecessarily difficult much of the time
11:58:05 <monochrom> right, this is why ddarius's isJust works
11:58:07 <dolio> So, Haskell already only has one array type.
11:58:45 <elliott> monochrom: also shachaf's isTrue!
11:59:16 <mekeor> isTrue??
11:59:22 <dolio> isTrue should work regardless of the implementation.
11:59:24 <elliott> @quote shachaf isTrue
11:59:25 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
11:59:25 <mekeor> isTrue = id -- ?
11:59:34 <monochrom> that one is a bit of unnecessary complication
11:59:50 <mekeor> hehe
12:00:06 <ion> elliott, monochrom: Heh, cool (the unsafeCoerce# stuff)
12:00:59 <ion> I also like how the last one managed to print “False” before crapping itself.
12:01:28 <monochrom> isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
12:01:44 <liyang> ion: GC just kicked in yo'. (Probably.)
12:03:41 <mcstar> can i pattern match in a lambda?
12:03:47 <mcstar> damn no
12:03:48 <elliott> (\(Yes x) -> ...)
12:03:50 <c_wraith> yes
12:03:52 <mcstar> can i use guards?
12:03:57 <elliott> (\(No x) -> ...)
12:03:58 <c_wraith> You just can't provide multiple alternatives or guards
12:04:03 <elliott> Oh, you can use guards?
12:04:05 <mcstar> ok thanks
12:04:06 <elliott> Well, guard.
12:04:10 <elliott> I didn't know you could even use one.
12:04:14 <c_wraith> hmm.
12:04:14 <mauke> > (\x | otherwise -> x) 1
12:04:15 <lambdabot>   <no location info>: parse error on input `|'
12:04:23 <elliott> @remember monochrom isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
12:04:24 <lambdabot> Okay.
12:04:40 <monochrom> hehehe, shachaf will be proud
12:05:11 <c_wraith> that's utterly pointless.  Also, pointless. :)
12:05:15 <Bytter> does anyone know of a standard operation for Monoid a -> Monoid b -> Monoid (a, b)
12:05:34 <c_wraith> Bytter: I really don't know what that means.
12:05:45 <c_wraith> Bytter: Monoid is a class, not a type constructor
12:06:28 <Bytter> c_wraith: yeah, i'm a noob :-\ basically i have two monoids, and I want to create a third monoid with a tuple, with the values of the first and second...
12:06:41 <c_wraith> > ("foo", [4]) `mappend` ("bar", [7])
12:06:43 <lambdabot>   ("foobar",[4,7])
12:06:53 <elliott> There is already an instance (Monoid a, Monoid b) => Monoid (a,b) if that is what you mean.
12:06:57 <elliott> As c_wraith demonstrates :)
12:06:58 <ion> isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: IO (Maybe a) -> Either String a) . (unsafeCoerce :: Bool -> IO (Maybe Double))
12:07:09 <elliott> ion: Does that... work?
12:07:23 <c_wraith> elliott: it's still just id underneath.  so yes
12:07:29 <elliott> It does.
12:07:33 <elliott> :D
12:07:34 <Bytter> hmmm, not the same thing i was looking for
12:07:41 <elliott> Bytter: What are you looking for?
12:07:50 <elliott> If you just want to put two values in a tuple, and they happen to be monoids... uh, (a,b).
12:07:59 <c_wraith> :t (,)
12:08:00 <ion> Types disappear when compiling and unsafeCoerce just changes what Haskell (FSVO “Haskell”) thinks the type is.
12:08:00 <lambdabot> forall a b. a -> b -> (a, b)
12:08:05 <liyang> $ ghci -XMagicHash
12:08:06 <liyang> Prelude> :m + GHC.Prim System.Mem
12:08:06 <liyang> Prelude GHC.Prim System.Mem> unsafeCoerce# (plusAddr# nullAddr# 1#) :: Bool
12:08:06 <liyang> False
12:08:06 <liyang> Prelude GHC.Prim System.Mem> performGC
12:08:08 <liyang> Segmentation fault
12:08:21 <elliott> liyang: I bet that's because of "it"
12:08:27 <liyang> Damn it!
12:08:28 <elliott> Try evaluating () in the middle
12:08:54 <monochrom> hehe damn "it"
12:08:58 <Bytter> elliott: yeah... it's a little more complicated than that... basically I have a typeclass Timeline a that is a kind of (sorted) map from Int -> A
12:09:04 <ion> liyang: I see what you did there.
12:09:39 <Bytter> elliott: inside, I have an operation that gets two Timelines, and produces a third with the values in a tuple, when the key is the same
12:09:45 <liyang> elliott: evaluating () didn't help. :(
12:09:53 <elliott> liyang: hmm, maybe there's an it' or something
12:10:03 <Bytter> elliott: this operation seemed so elementar, that I was just thinking if it wasn't basically something that already existed
12:10:29 <parcs`> speaking of performGC, it's a cool trick to make sure all foreign pointers get finalized before calling an ffi quit-like command
12:11:00 <parcs`> i wonder if that was its intended purpose
12:12:43 <elliott> Bytter: I still don't understand what you want, alas.
12:12:51 <ion> An FFI quit-like command? Like _exit/abort?
12:13:32 <parcs`> like TTF_Quit from SDL_ttf. if you have a foreign pointer pointing to an sdl font, attempting to free it after calling TTF_Quit will cause a segfault
12:14:35 <ion> Ah, a more like a misnamed finalizer. :-)
12:14:43 <liyang> mcstar: instead of pattern matching in a lambda, there are destructor functions like 'maybe' and 'either' that take arguments corresponding to their constructors. You can write your own.
12:15:10 <parcs`> ion: yeah :P
12:15:21 <liyang> :t maybe Nothing Just
12:15:22 <lambdabot> forall a. Maybe a -> Maybe a
12:16:10 <mcstar> liyang: i used a case-of instead
12:16:17 <Mathnerd314> liyang: on Windows, I get a segfault without the performGC
12:16:32 * hackagebot synthesizer-core 0.5.0.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.5.0.1 (HenningThielemann)
12:17:38 <liyang> Mathnerd314: immediately? Here it eventually segfaults after a few seconds. I was just calling performGC to see if it was indeed the GCtor.
12:18:27 <Mathnerd314> Prelude GHC.Prim System.Mem> unsafeCoerce# (plusAddr# nullAddr# 1#) :: Bool
12:18:28 <Mathnerd314> False
12:18:30 <Mathnerd314> Segmentation fault/access violation in generated code
12:18:46 <liyang> Maybe it's a bit more eager under Windows.
12:19:49 <elliott> liyang: mine segfaulted immediately after printing False
12:19:53 <elliott> with nullAddr#
12:20:50 <liyang> Mine doesn't immediately, only after a short delay.
12:21:16 <rwbarton> mine segfaulted after 5 seconds just by me looking at it
12:21:40 <rwbarton> seems pretty consistent
12:21:43 <Mathnerd314> which versions of GHC are we using? I'm using 7.0.4
12:21:46 <rwbarton> 7.0.4
12:21:46 <liyang> Do you like to stare at goats?
12:21:47 <monochrom> recall that with the threaded runtime, essentially there is GC when idling
12:21:52 <rwbarton> but x86_64
12:21:57 <rwbarton> linux
12:22:06 <zzing> > 2 + $ 3 - 5
12:22:07 <lambdabot>   <no location info>: parse error on input `$'
12:22:20 <liyang> Cyber psy-ops.
12:22:29 <mekeor> > (2+) $ 3 - 5
12:22:30 <lambdabot>   0
12:22:34 <monochrom> it also explains why certain "too many files open" states suddenly disappear by just idling
12:22:44 <zzing> hmm, so it has to be that way
12:22:49 <monochrom> (and ghci uses the threaded runtime)
12:22:52 <zzing> merci mekeor
12:22:55 <mekeor> np
12:22:55 <zzing> Just trying to avoid brackets
12:23:16 <mekeor> yep. i don't know of a way here. monochrom, you?
12:24:05 <geekosaur> section syntax requires parentheses, yes.  you can shift them around by changing syntax and using intermediate names but you're going to have some somewhere, I suspect
12:24:06 <mekeor> zzing: btw, (2+(3-5)) == (2+3-5) ;)
12:24:45 <monochrom> x ^-^ y = x - y
12:24:54 <monochrom> infixl 1 ^-^
12:24:59 <mekeor> heh
12:25:00 <monochrom> 2 + 3 ^-^ 5
12:25:19 <mcstar> what is ^ ^ here?
12:25:23 <elliott> <Mathnerd314> which versions of GHC are we using? I'm using 7.0.4
12:25:24 <elliott> 7.4.1
12:25:24 <geekosaur> or getting realy stupud like
12:25:25 <mcstar> wings?
12:25:27 <monochrom> user-defined operator
12:25:53 <geekosaur> > let twoplus in succ . succ in twoplus $ 3 - 5
12:25:54 <lambdabot>   <no location info>: parse error on input `in'
12:25:55 <mekeor> monochrom: actually `(^-^) = (-)' is shorter than you did.
12:25:55 <monochrom> yeah, wings, to raise precedence level. level-up wings
12:26:02 <geekosaur> oops
12:26:17 <rwbarton> 2 + subtract 5 3
12:26:18 <monochrom> and more vulnerable to monomorphism restriction
12:26:18 <geekosaur> > let twoplus = succ . succ in twoplus $ 3 - 5
12:26:20 <lambdabot>   0
12:26:28 <elliott> that's not twoplus!
12:26:32 * hackagebot fix-imports 1.0.1 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-1.0.1 (EvanLaforge)
12:26:32 <elliott> > 2 + maxBound :: Int
12:26:32 <mekeor> heh, nice work-around
12:26:33 <lambdabot>   -9223372036854775807
12:26:33 <liyang> mcstar: http://simple.wikipedia.org/wiki/Smiley#Vertical
12:26:36 <elliott> > (succ . succ) maxBound :: Int
12:26:37 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
12:26:58 <mekeor> liyang: lol :D
12:27:02 <geekosaur> maxBound succs :p
12:27:12 <mekeor> :D :D
12:27:53 <mcstar> liyang: half of those arent smiles
12:28:05 <mcstar> ;_; is crying, i was told
12:28:34 <mcstar> i see, if i can run through this wall, right here, lets stare at it
12:29:00 <pqmodn> mcstar: the other half are parsec combinators?
12:29:35 <mcstar> pqmodn: if it sounds funny, then yes
12:29:44 <pqmodn> JOKE FAIL
12:29:50 <mcstar> (im not done with scheme in 48 hours)
12:30:08 <elliott> haskell 2012 wishlist: Applicative as superclass of Monad. fold in GHC's Num change. allow Enum+Bounded to be cyclic, make numeric instances cyclic
12:30:27 <elliott> am i missing anything?
12:31:40 <Mathnerd314> ConstraintKinds :-)
12:32:01 <elliott> oh! FlexibleInstances and FlexibleContexts should be folded in to the language standard
12:32:03 <rwbarton> i think that will be in haskell 2042
12:32:06 <elliott> Mathnerd314: thanks for reminding me about language extensions
12:32:10 <elliott> ok, I think that's enough for 2012
12:32:29 <elliott> later we can try and fix the Enum mess wrt Double etc. by splitting out the typeclasses
12:33:07 <elliott> (oh, TypeSynonymInstances too)
12:33:24 <elliott> in 2013, how about NoMonomorphismRestriction + MonoLocalBinds
12:34:04 <kallisti> is there a way to select an unused port?
12:35:46 <geekosaur> kallisti, you mean network port?  typically 0 but check the underlying API docs
12:36:05 <kallisti> ah okay
12:36:23 <kallisti> the "underlying API" being...? the Haskell lib in question, or?
12:37:29 <geekosaur> system services (sockets on unix)
12:38:28 <kallisti> ah
12:39:05 <geekosaur> manpages may not be enough for this, btw, you may need to find a copy of Stevens or something...
12:43:53 <zzing> While there is a problem when comparing two floating point numbers for equality because of the possibility of being off by a ulp or two, does the same issue come up with <= ?
12:44:12 <statusfailed> Has anyone done a socket.io library?
12:44:24 <parcs`> what is that
12:44:53 <statusfailed> parcs`: socket.io?
12:47:31 <geekosaur> zzing, it comes up in every language with floating point
12:47:55 <geekosaur> there is occasional discussion about ti ont he list, it's not a problem amenable to solutions
12:48:15 <zzing> geekosaur: I know the issue comes up, does it apply to < and <= etc.?
12:48:56 <elliott> Isn't there a canonical web page on "how to compare floating point numbers"?
12:49:17 <elliott> zzing: Well, obviously if you have a number that's just slightly too big, then (<=) will do "the wrong thing".
12:49:25 <elliott> But that may be the "right thing" in your opinion :P
12:50:57 <jfischoff> how to Haskell's double differ from ieee754 or are they the same?
12:51:50 <zzing> I think they are the same
12:52:14 <zzing> Does anyone use anything but IEEE754?
12:53:12 <bgamari> I don't know that the report specifies that Double has to be ieee754 however
12:53:25 <bgamari> so I believe it's implementation dependent
12:53:32 <ikeg> well, I found a short phrase in the Haskell 98 report : "Double should cover IEEE double-precision"
12:53:42 <bgamari> although I don't know of any implementations that don't just use whatever the host provides
12:54:10 <liyang> Java mandates IEEE-754 I think.
12:55:01 <elliott> jfischoff: Not enough, is the answer.
12:55:40 <jfischoff> elliot: was this the web page you were thinking of http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
12:56:47 <elliott> Looks familiar, yes.
12:56:52 <zzing> jfischoff: I used that guy's page as the basis for my c++ feq().
12:56:59 <zzing> But I think he only addresses direct equality
12:57:12 <elliott> jfischoff: "This article is obsolete. Its replacement - which will fix some errors and better explain the relevant issues - is being crafted as a multi-part series here. Please update your links."
12:57:16 <geekosaur> it's not a problm that can only apply to equality, it applies to any comparison
12:57:18 <elliott> "I mean it. Some of the problems with this code include aliasing problems, integer overflow, and an attempt to extend the ULPs based technique further than really makes sense."
12:57:30 * elliott decides to link http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ instead :p
12:58:46 <lispy> hi
12:58:59 <zzing> If we could define a 'correct' floating point comparison (<) could we then define all other comparisons correctly?
12:59:10 <jfischoff> god I hate IEEE-754
12:59:25 <geekosaur> zzing, please read some of those references
12:59:37 <elliott> zzing: From a falsehood, whatever you please.
12:59:47 <lispy> The thing about approximate reals is that you should treat them as approximate
13:00:13 <lispy> The problem with approximate is that people don't always know how fuzzy they want to be
13:00:34 <jfischoff> and it changes by scale
13:01:29 <zzing> What field of math would the study of these things be under?
13:01:38 <jfischoff> fields
13:01:44 <jfischoff> hopefully
13:01:56 <rwbarton> "none"
13:02:00 <rwbarton> numerical analysis
13:02:00 <jfischoff> haha
13:02:11 <lispy> what rwbarton said
13:02:28 <lispy> numerical analysis is actually really cool
13:02:35 <lispy> I think a lot of people mistake it for a boring subject
13:03:50 <liyang> It's dirty. ;_;
13:04:45 <lispy> I think it's a bit like type theory. We need to understand the substrates of our programming
13:05:18 * elliott is happy his programming does not have a floating point substrate
13:05:36 <lispy> I should have said computing
13:05:56 <mcstar> it WAS boring
13:05:59 <Clint> so what does "Could not deduce (d1 ~ BC8.ByteString)" mean exactly?
13:06:08 <mcstar> the lecturer was a total boredom
13:06:09 <elliott> Clint: It means you are using d1 as if it is a BC8.ByteString.
13:06:14 <elliott> You don't know d1 is a BC8.ByteString.
13:06:26 <lispy> mcstar: That's unfortunate. I had an awesome math prof for it.
13:06:31 <mcstar> anyway, NA has too much black magic
13:07:05 <Clint> elliott: ah, seems i am
13:07:19 <lispy> mcstar: http://www.math.oregonstate.edu/people/view/murphy
13:07:41 <hpaste> keep_learning pasted “outer matrix multiplication of sparse matrix ” at http://hpaste.org/66926
13:07:56 <keep_learning> Hello all
13:08:28 <keep_learning> I am developing code for two sparse matrix multiplication using outer matrix multiplication
13:08:54 <lispy> keep_learning: go on :)
13:08:55 <mcstar> http://www2.mta.hu/fileadmin/2009/12/Horvath_Miklos.JPG
13:09:13 <keep_learning> I am representing the sparse matrix as [ ( Int , U.Vector ( Int , Double ) ) ]
13:09:22 <lispy> mcstar: looks like a gentleman and a scholar :)
13:10:00 <mcstar> actully he isnt bad, but didnt try to make the subject a bit interesting either
13:10:02 <keep_learning> I developed the following code http://hpaste.org/66926
13:10:13 <lispy> keep_learning: I haven't looked at our code yet, are you using a fancy parallel algo?
13:10:25 <keep_learning> lispy, no
13:10:42 <keep_learning> Its simple outer matrix multipiication
13:10:52 <lispy> keep_learning: doesn't look so bad.
13:11:22 <lispy> keep_learning: I would make [ ( Int , U.Vector ( Int , Double ) ) ] into a type. Porbably with a newtype
13:11:35 <ezyang> How poor form is it not to add hs_exit calls to my application?
13:11:36 <hpaste> keep_learning annotated “outer matrix multiplication of sparse matrix ” with “outer matrix multiplication of sparse matrix  (annotation)” at http://hpaste.org/66926#a66927
13:12:05 <keep_learning> It has some big GC time
13:12:16 <keep_learning> which I want to reduce
13:12:26 <lispy> ezyang: IIRC, you need that for the runtime to finish doing any lazy IO
13:12:38 <lispy> ezyang: but what does the ghc manual say?
13:13:12 <lispy> keep_learning: Have you read chapter 25 of Real-World Haskell? http://book.realworldhaskell.org/read/profiling-and-optimization.html
13:13:13 <twomashi> lambdabot
13:13:29 <twomashi> How do I use the bot to search for functions
13:13:35 <twomashi> given a type sig
13:13:37 <lambdabot> twomashi
13:13:38 <lispy> ?hoogle a -> b
13:13:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:13:39 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:13:39 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:13:43 <twomashi> excellent thanks
13:13:46 <ezyang> "we can call hs_exit"
13:14:04 <twomashi> ?hoogle a -> b -> Maybe b
13:14:05 <lambdabot> Prelude seq :: a -> b -> b
13:14:05 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
13:14:05 <lambdabot> GHC.Conc par :: a -> b -> b
13:14:14 <elliott> twomashi: what would you want that to do?
13:14:18 <keep_learning> lispy, yes
13:14:26 <keep_learning> lispy, Heap profiling ?
13:14:29 <twomashi> return Just b if a is true else Nothing
13:14:33 <Dodek> is unsafeCoerce actually useful?
13:14:43 <lispy> ezyang: looks like finalizers won't run if you don't hs_exit(): http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
13:14:47 <elliott> twomashi: Well, that's not the type it'd have, then.
13:14:50 <elliott> twomashi: It'd be Bool -> a -> Maybe a.
13:14:52 <Dodek> i mean, are there any real uses of it?
13:14:54 <elliott> Dodek: Yes.
13:14:56 <twomashi> toMaybe
13:14:57 <lispy> Dodek: yes
13:15:06 <elliott> Dodek: It's useful when you want to do something the type system can't quite manage itself.
13:15:09 <elliott> But only rarely.
13:15:12 <lispy> Dodek: but if you need it, you better be able to justify it :)
13:15:20 <twomashi> ?hoogle Bool -> a -> Maybe a
13:15:21 <elliott> twomashi: You can write (a <$ guard myBool).
13:15:21 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
13:15:21 <lambdabot> Control.Exception assert :: Bool -> a -> a
13:15:21 <lambdabot> Control.OldException assert :: Bool -> a -> a
13:15:26 <elliott> But there isn't anything for it built-in.
13:15:37 <twomashi> elliott: thank you!
13:15:45 <lispy> twomashi: if you need to use ?hoogle a lot, it also works when you /msg lambdabot
13:15:53 <lispy> twomashi: Or hoogle.haskell.org
13:15:56 <elliott> twomashi: (Requires Control.Monad + (Data.Functor or Control.Applicative) imports)
13:15:58 <twomashi> lispy: thanks too
13:16:04 <ezyang> OK. I bet this might be less of a problem if these are long lived processes.
13:16:15 <elliott> twomashi: Hayoo is also useful, it searches all of Hackage
13:16:16 <elliott> @where hayoo
13:16:16 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:16:39 <lispy> ezyang: how are you these days? Are you in graduate school these days?
13:17:01 <ezyang> Not yet, that starts next year :-)
13:17:05 <lispy> awesome
13:18:29 <copumpkin> ezyang: where you going?
13:18:34 <lispy> Anyone here doing the Google Code Jam this year?
13:19:45 <ezyang> Stanford, strangely enough.
13:20:16 <copumpkin> oho
13:21:19 <lispy> ezyang: cool
13:23:42 <tgeeky__>  ezyang why is that strange? Stanford is an institution for higher learning. Or some kind of learning, anyway.
13:24:34 <kallisti> what happened to -ddump-rule-rewrites?
13:24:35 <ezyang> It is a little unlikely if you thought I wanted to do PL theory
13:24:52 <jfischoff> they have a great sandwich spot
13:26:13 <kallisti> liyang: I'm having trouble getting my RULES to fire.
13:26:24 <kallisti> (re: interpolatedstring-perl6)
13:26:45 <kallisti> if there were an error in the rule it would give a compilation error, yes?
13:27:52 <kallisti> perhaps some other rule is firing.
13:31:32 <hpaste> Clint pasted “messy success” at http://hpaste.org/66928
13:31:34 <zzing> Is there any problem in having birdtracks in a literate source file being broken up in the middle of the function to provide explanation?
13:31:36 * hackagebot notcpp 0.0.1 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.0.1 (BenMillwood)
13:31:41 <Clint> elliott: ^ in case you're curious
13:33:28 <elliott> Clint: looks reasonable to me, just use more (.)s and wrap those lines :p
13:33:59 <kallisti> Rule fired: Class op fromString
13:34:02 <kallisti> what does this mean
13:34:11 <kallisti> is there a rule with that name somewhere?
13:36:00 <Clint> elliott: sure thing ;)
13:36:18 <lispy> ezyang: Do you know what you will study?
13:37:16 <ezyang> Not quite, but I have some ideas. I certainly know who I'll be studying with.
13:37:32 <ezyang> (or, in the case of Stanford, who my first year rotations will be)
13:41:42 <kallisti> I'm confused... the GHC manual doesn't include function bodies with its SPECIALIZE examples.
13:41:45 <kallisti> do they go after the pragma?
13:41:58 <elliott> they can go before or after
13:42:06 <elliott> whatever makes you happy
13:42:24 <kallisti> great. I love happiness.
13:45:27 <kallisti> oh, you don't actually write code for the specialized version..
13:45:34 <kallisti> what does it even do then.
13:46:06 <geekosaur> it says pregenerate code with hard references to the types instead of lookups in the typeclass dictionary
13:46:17 <kallisti> oh..
13:46:31 <kallisti> I thought GHC did stuff like that anyway..
13:46:45 <geekosaur> it does sometimes, SPECIALIZE is for when it doesn't figure out itself
13:47:05 <kallisti> okay so I want RULES then, but I can't seem to get it to type correctly..
13:47:28 <geekosaur> ...sometimes it may choose to do it after the point when having it would enable some other optimization to work, I think
13:47:50 <kallisti> oh, hmm
13:48:39 <kallisti> with a SPECIALIZE I can tell it to delay that explicitly, so that another rule can take effect?
13:48:58 <TML> So...I'm working my way through "Learn You a Haskell", and - since I'm just starting - I realize I'm probably missing something fundamental here, but is there a way to make an infinite range that gets depleted as a 'take' things from it?
13:49:24 <kallisti> > [1..]
13:49:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:49:26 <geekosaur> I was thinking theother direction, it can miss a possibility for fusion if it hasn't worked out yet that specializing for a particular type would be a useful optimization
13:49:26 <kallisti> TML: like this?
13:49:32 <thoughtpolice> you can control when RULES fire in terms of inlining etc. sometimes it makes more sense for some rules to fire early, and others later
13:49:44 <elliott> > take 10 [1..]  -- ?
13:49:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:49:53 <thoughtpolice> you can also give the same directives on INLINE/INLINEABLE pragmas too
13:50:04 <nicholisd> hey
13:50:07 <kallisti> my rule is:  forall s. fromString (showQ s) = s
13:50:13 <elliott> TML: your question is kinda vague though :)
13:50:21 <kallisti> it's either not typing the way I'm expecting it to, or the fromString and showQ are getting specialized too early.
13:50:28 <kallisti> or.. something else.
13:50:38 * elliott is sceptical of this rule, given showQ's name.
13:50:42 <dgpratt> TML: when you say it "gets depleted", that sounds like mutable state, which is not how things are usually handled in Haskell
13:51:16 <kallisti> elliott: I'm patching interpolatedstring-perl6
13:51:30 <kallisti> to see if I can get it to support Text and Bytestring
13:51:42 <kallisti> so far I can, but it's probably not very safe (it uses IncoherentInstances)
13:51:55 <kallisti> so I'm trying rewrite rules instead.
13:52:19 <ezyang> Hmm. I wonder if hs_init(NULL,NULL) is Ok.
13:52:21 <TML> dgpratt: Yes, that's why I say "Maybe I'm missing something fundamental" - I'm having trouble wrapping my brain around how to get things done without mutable state. Even in the lisp and scheme that I've written in the past, the "functional purity" is a little more hand-wavy.
13:52:22 <kallisti> (actually none of this is even necessary for the implementation, I'm just trying to optimize the case where you don't need to convert needlessly to/from a String)
13:52:47 <elliott> kallisti: I don't see why you'd need any of those things at all.
13:52:58 <elliott> ByteString and Text already have optimisations for fromString.
13:52:59 <dgpratt> TML: ah, that's the fun part :)
13:53:16 <kallisti> oh, let me go find those then.
13:53:19 <kallisti> and see how they work.
13:53:40 <kallisti> I'm not sure they'll fire in this case, but they might.
13:53:42 <TML> let xs = [1..]; take 5 xs: [1,2,3,4,5]; take 5 xs: [6,7,8,9,10] # how would you do something *like* that without mutable state?
13:53:56 <elliott> TML: You wouldn't.
13:53:58 <elliott> Except perhaps
13:54:08 <elliott> > let xs = [1..]; xs' = drop 5 xs; xs'' = drop 5 xs' in xs''
13:54:09 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35...
13:54:26 <elliott> You can thread state by using recursion. But even that isn't always necessary.
13:54:42 <shachaf> ezyang: Well, the definition of it in GHC's RTS checks "if (argc != NULL && argv != NULL) {"
13:54:55 <ezyang> OK, handy.
13:55:18 <TML> Ok, so "take 5 (drop 5 xs)" recursively?
13:55:19 <dgpratt> TML: it's usually better to start from a higher level concept of the problem you are trying to solve; simply translating an imperative algorithm/process will usually yield suboptimal results
13:55:30 <elliott> TML: Probably not.
13:55:32 <kallisti> elliott: Data.Bytestring sure has beautiful code.
13:55:33 <elliott> Probably (drop 5 xs).
13:55:39 <elliott> take n xs just returns the first n elements of xs.
13:55:45 <elliott> If you want to "take" the five off and then do something with the rest,
13:55:47 <elliott> > splitAt 5 [1..]
13:55:48 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
13:55:58 <elliott> But yes, I agree with dgpratt.
13:56:12 <elliott> It's best to avoid thinking about how to translate some imperative idea into functional code at all.
13:56:13 * kallisti can't find the IsString instance..
13:56:22 <elliott> That means you have to relearn everything, of course :)
13:56:25 <Clint> it's in .Char8
13:56:26 <TML> Yeah, I don't have a "problem to solve" yet, I'm just trying to get my brain around purely functional :)
13:56:35 <elliott> kallisti: that's because ByteStrings aren't strings
13:56:55 <kallisti> *Unicode
13:57:19 <thoughtpolice> there's an IsString instance in Data.ByteString.Char8
13:57:27 <kallisti> yes I'm looking at it now. Thanks.
13:57:34 <thoughtpolice> if of course you only expect ASCII. otherwise, you should just use text for real textual data
13:57:50 <thoughtpolice> (which i'm sure you may have already heard but i'll throw it out there)
13:58:02 <kallisti> yes
13:58:46 <kallisti> elliott: if there are rewrite rules, I'm not finding them. Do you mean something else?
13:59:04 <TML> Here's an example - how do you implement an LCG without mutable state?
13:59:06 <lispy> ?quote infinite
13:59:06 <lambdabot> ghc says: Occurs check: cannot construct the infinite type
13:59:11 <lispy> ?quote lispy.infinite
13:59:12 <lambdabot> No quotes match. Where did you learn to type?
13:59:19 <lispy> query lambdabot
13:59:21 <lispy> oops
13:59:29 <dgpratt> TML: pmi, what's LCG?
13:59:40 <lispy> ?quote lispy infinite
13:59:40 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'infinite' datastructures
13:59:41 <TML> dgpratt: Linear congruential generator
13:59:46 <kallisti> TML: LCGs are defined by a recurrence relation, so....
13:59:49 <TML> a pseudorandom number generator algorithm
14:00:07 <lispy> TML: ^^ that's something I learned when learning Haskell :)
14:00:43 <elliott> TML: what kallisti said, take a look at http://en.wikipedia.org/wiki/Linear_congruential_generator
14:00:54 <elliott> you can implement that as, e.g. a function returning an infinite list
14:01:14 <kallisti> > randoms (MkStdGen 12398359812378791725)
14:01:15 <lambdabot>   Not in scope: data constructor `MkStdGen'
14:01:19 <kallisti> > randoms (mkStdGen 12398359812378791725)
14:01:20 <lambdabot>   [-4598240902047266443,8488688204983287093,-3382966893633395885,-87737507430...
14:01:20 <lispy> You can think of haskell lists as sreams
14:01:22 <TML> elliott: An LCG increments 'a' on successive calls
14:01:23 <lispy> streams*
14:01:28 <elliott> kallisti: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/src/Data-ByteString-Char8.html#line-322
14:01:32 <elliott> TML: No, forget about "successive calls".
14:01:35 <TML> Sorry, I mean 'c'
14:01:35 <elliott> Look at kallisti's example.
14:01:45 <elliott> An LCG really just generates an infinite sequence.
14:01:58 <elliott> The "changing on each call" thing is just an artefact of how it's often exposed in imperative languages :)
14:02:37 <TML> Let me think on that :)
14:02:58 <kallisti> elliott: -scratches head-
14:02:59 <elliott> > let lcg m a c x0 = iterate (\xN -> ((a*xN) + c) `mod` m) x0 in lcg (2^32) 22695477 1 1234
14:03:00 <lambdabot>   [1234,2236414843,4056779384,3589159641,1770671342,4139675975,904336820,3871...
14:03:17 <elliott> TML: that's literally a direct translation of the recurrence relation from http://en.wikipedia.org/wiki/Linear_congruential_generator
14:03:36 <elliott> or, with explicit recursion:
14:03:49 <elliott> > let lcg m a c x0 = x0 : lcg m a c ((a*x0) + c) `mod` m) in lcg (2^32) 22695477 1 1234
14:03:50 <lambdabot>   <no location info>: parse error on input `)'
14:03:52 <elliott> argh
14:03:57 <elliott> > let lcg m a c x0 = x0 : lcg m a c (((a*x0) + c) `mod` m) in lcg (2^32) 22695477 1 1234
14:03:58 <lambdabot>   [1234,2236414843,4056779384,3589159641,1770671342,4139675975,904336820,3871...
14:04:10 <lispy> ?let lcg m a c x0 = x0 : lcg m a c (((a*x0) + c) `mod` m)
14:04:10 <elliott> (where (x:xs) is the list with first element x, and rest of list xs)
14:04:12 <lambdabot>  Defined.
14:04:18 <lispy> > lcg (2^32) 22695477 1 1234
14:04:20 <lambdabot>   [1234,2236414843,4056779384,3589159641,1770671342,4139675975,904336820,3871...
14:04:36 * elliott wonders what lispy is doing
14:04:39 <kallisti> psh, you call that random? ;)
14:04:51 <TML> kallisti: No. :)
14:04:53 <lispy> elliott: trying to help by makeing it persist :)
14:04:58 <TML> pseudorandom, sure
14:04:58 <elliott> Right.
14:05:38 <cookie__> hi
14:05:45 <elliott> hi
14:06:16 <TML> elliott: The thing I'm still stuck on is that in imperative implementations, rand() remembers where I am in the recurrence, and I'm trying to figure out how to do that without mutable state.
14:06:50 <kallisti> elliott: perhaps I'm dense, but I'm not seeing the connection with this rule and what I'm doing. does that mean if I directly call unpack followed by pack (fromString), it will be a no-op?
14:06:51 <elliott> TML: The answer is that you just don't do that.
14:07:15 <elliott> TML: I mean, sure, we have methods that let you thread state in an imperative manner, but they have specific uses.
14:07:25 <elliott> TML: Random number generation is one of the cases where it's often useful to do that -- but you don't have to.
14:07:34 <elliott> (And it's all implemented on top of the normal pure-functional stuff, anyway.)
14:08:14 <elliott> TML: You can process an infinite list of random numbers just like any other list, for instance.
14:11:11 <kallisti> TML: later you'll learn how to write imperative Haskell code, but when starting off it's important to focus on how things are done in pure code.
14:11:14 <kallisti>  Firstly, because it's necessary to truly learn the imperative bits, and secondly because you might find that problems you thought required side-effects can be easily written without them.
14:11:54 <kallisti> and that knowledge carries into the imperative world.
14:13:01 <TML> Yeah, I understand the value behind functional purity, or I wouldn't be spending time learning Haskell. But I've always had to descend into side-effects at SOME point to figure out how to get certain classes of things done, and I'm just trying to get over that.
14:13:46 <kallisti> the tools are there. the difference with Haskell is that you don't learn them immediately, because they require some basic understanding of the rest of the language first.
14:13:52 <jfischoff> TML: have you written the equivalent of a double loop? I found that really tricky when I started
14:13:57 <kallisti> whereas in C, Python, etc, you can dive right into side-effects and IO.
14:14:40 <glguy> :t runCont . mapM cont
14:14:41 <lambdabot> forall r b. [(b -> r) -> r] -> ([b] -> r) -> r
14:15:38 <TML> jfischoff: You mean an inner and an outer loop, where the inner loop can "advance" the outer one?
14:16:58 <kallisti> elliott: I guess the best way to find out is to run some tests and see if those rules are firing.
14:16:58 <twomashi> How do I compose 2 functions that return a Maybe such that the second is only called if the first returns Nothing?
14:17:20 <elliott> twomashi:
14:17:21 <elliott> :t (<|>)
14:17:22 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
14:17:28 <elliott> > Nothing <|> Just 123
14:17:29 <lambdabot>   Just 123
14:17:33 <elliott> > Just () <|> undefined
14:17:34 <lambdabot>   Just ()
14:17:46 <jfischoff> TML: just two loops. No communication. simple stuff. Like iterating over the pixels in a image
14:18:03 <twomashi> excellent thanks
14:19:00 <twomashi> elliot what module is that
14:19:08 <kallisti> twomashi: if you think of Maybe as handling exceptional cases, <|> is like your exception catching construct. ;)  if you think of Nothing as being false and Just _ being true, <|> is a logical or.
14:19:15 <elliott> twomashi: It's from Control.Applicative.
14:19:30 <zzing> Is there a way I can get ghci to print the actual escape in this? "\964: 2.625"    I need to be able to tell if it is ς or τ. The output is from my own function if there is a way to do that...
14:19:59 <kallisti> zzing: you could do a trace via Debug.Trace
14:20:09 <zzing> kallisti: this is using that
14:20:32 <zzing> >            ς = debug "ς: " $ (dot w $ cross n v) / (dot u $ cross n v)     where debug is debug s a = traceShow (s ++ show a) a
14:20:33 <lambdabot>   <no location info>: parse error on input `='
14:20:41 <kallisti> don't use traceShow
14:20:43 <kallisti> just use trace
14:21:07 <geekosaur> it's show that does that conversion, by the way, not trace
14:22:35 <keep_learning> Hello all
14:22:48 <twomashi> kallisti: is there a version of <|> that allows to compose functions? ie compose 2 functions that return a maybe
14:22:51 <zzing> Sweet changing it to trace fixed it complete,y thank you
14:22:56 <elliott> twomashi: What type signature do you want?
14:23:06 <twomashi> good question, let me get it
14:23:20 <kallisti> depends on what you mean by "compose"
14:24:20 <keep_learning> If i pass a list to function and at function definition , I added bang patterns ( fun !xs ) so will the xs will evaluate first and then go for processing
14:24:47 <kallisti> keep_learning: only the first constructor is evaluated
14:24:53 <kallisti> which, in a list, is a single (:)
14:25:04 <twomashi> elliot: :: [(a -> Maybe b)] => Maybe b. It should take a list of functions and call until one of them does not return nothing
14:25:04 <HNSZ> Hey! What was the very quirky and interesting prime sequence that was discussed a week ago?
14:25:09 <HNSZ> in here
14:25:21 <elliott> twomashi: Well, that's an invalid type, but I'll assume you meant -> :)
14:25:26 <elliott> twomashi: Where does it get the "a" from?
14:25:35 <twomashi> elliot: sorry that should be [(a -> Maybe b)] -> a -> Maybe b
14:25:40 <elliott> Right.
14:25:45 <elliott> Well, it's easier to think of
14:25:47 <keep_learning> kallisti, For complete evaluation  deepseq ?
14:25:51 <elliott> (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
14:25:51 <kallisti> keep_learning: yes
14:25:57 <elliott> because you can just fold that to produce the former
14:26:02 <elliott> :t \f g x -> f x <|> g x
14:26:03 <lambdabot> forall t (f :: * -> *) a. (Alternative f) => (t -> f a) -> (t -> f a) -> t -> f a
14:26:05 <elliott> hmm
14:26:07 <elliott> :t \f g -> f <|> g
14:26:08 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
14:26:15 <elliott> :t (\f g -> f <|> g) (const Nothing)
14:26:16 <lambdabot> forall a b. (Alternative ((->) b)) => (b -> Maybe a) -> b -> Maybe a
14:26:18 <elliott> aw
14:26:30 <elliott> twomashi: Right, so (\f g x -> f x <|> g x) ::  (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
14:26:39 <elliott> twomashi: So we can say: foldr (\f g x -> f x <|> g x) (const Nothing)
14:26:47 <elliott> If all of them fail, it'll fall back to the const Nothing case
14:26:50 <elliott> :t foldr (\f g x -> f x <|> g x) (const Nothing)
14:26:51 <lambdabot> forall a b. [b -> Maybe a] -> b -> Maybe a
14:26:58 <keep_learning> kallisti, If I process  only head element in function so adding strictness will be sufficient ?
14:26:59 <elliott> This can be written shorter, as
14:26:59 <twomashi> Nice
14:27:04 <elliott> :t foldr (liftA2 (<|>)) (const Nothing)
14:27:05 <lambdabot> forall a b. [b -> Maybe a] -> b -> Maybe a
14:27:11 <elliott> but only use that one if you understand it ;)
14:27:27 <kallisti> keep_learning: generally using a bang pattern on a list is useless
14:27:29 <twomashi> I shall use the former :) thanks!
14:27:34 <elliott> twomashi: Another approach that might be preferable is to write [Maybe a] -> Maybe a instead, as foldr (<|>) Nothing.
14:27:40 <elliott> twomashi: Then, you can simply pre-apply the functions to the argument:
14:27:43 <kallisti> keep_learning: if you pattern match on the list and extract the head, you're already forcing it to evaluate
14:27:46 <elliott> :t \fs x -> map ($ x) fs
14:27:47 <lambdabot> forall a b. [a -> b] -> a -> [b]
14:27:47 <kallisti> keep_learning: so a ! does nothing for you.
14:27:49 <elliott> and then use that on it.
14:28:01 <elliott> twomashi: Probably best to do it that way, to keep the concerns of "supplying an argument" and "selecting the first Just" separated.
14:28:16 <keep_learning> kallisti,  Thank you
14:32:57 <TML> Does ghci have an equivalent to ~/.bash_profile, where I store all my ":set" stuff and it will be re-read on each start?
14:33:29 <nyingen> is it possible to forcibly import a data constructor that's not exported?
14:33:37 <fmap> ~/.ghci
14:34:13 <kallisti> is there no way to see the source after rules fire?
14:34:15 <TML> perfect
14:34:20 <TML> thanks, fmap
14:34:33 <Yetikov> hellow
14:34:35 <Yetikov> ow
14:35:52 <elliott> kallisti: -ddump-simpl
14:35:56 <elliott> nyingen: no
14:37:34 <mekeor> unlines ["foo","bar"] == "foo\nbar\n";  unwords ["foo","bar"] == "foo bar";  -- that's stupid.   (the former is 'concatMap (++"\n")', the latter is 'intercalate "\n"'.
14:37:34 <nyingen> :(
14:37:55 <mekeor> )
14:38:27 <mekeor> > unlines ["foo","bar"]
14:38:28 <kallisti> elliott: I have left the world of decency.
14:38:28 <lambdabot>   "foo\nbar\n"
14:38:32 <mekeor> > unwords ["foo","bar"]
14:38:33 <lambdabot>   "foo bar"
14:38:52 <kallisti> now there exists only IO's and #'s and ptrs
14:38:58 <kallisti> pages of them
14:40:09 <glguy> mekeor: It's pretty crazy how word separators can be different from line *endings* :)
14:40:10 <elliott> cabal install ghc-core to elide some of the mess
14:40:32 <elliott> mekeor: what glguy said.
14:40:43 <elliott> unlines ["foo","bar"] == "foo\nbar" would be wrong
14:40:44 <elliott> esp. on Unix
14:40:49 <mekeor> why?
14:40:59 <elliott> because they terminate lines, not separate them
14:41:04 <elliott> all lines must end with \n
14:41:13 * mekeor dislikes "what XYZ said" messages, btw.
14:41:26 <elliott> i said it to give context to my elaboration.
14:41:56 <glguy> elliott: a simple glguy++ will do ;-)
14:42:03 <kallisti> elliott: was the ghc-core thing directed at me?
14:42:06 <elliott> kallisti: yes
14:42:09 <elliott> glguy: what?! you don't get karma for being quicker than me!
14:42:14 <elliott> ;)
14:42:16 <Peaker> I'm toying around with a chat server built with conduits. Each client is handled by: "input =$= decode utf8 =$= process =$= encode utf8 $$ output"
14:42:33 <kallisti> Peaker: does it happen to be an /IRC/ server
14:42:38 <kallisti> because, boy, do I have a great library for you.
14:42:38 <Peaker> kallisti: not yet :)
14:42:40 * mekeor is impressed how fast elliott types.
14:42:54 <Peaker> I'm wondering what "process" should be so that: A) Incoming messages are relayed to a central thingie  B) messages from central thingie are sent to the socket
14:43:10 <elliott> Peaker: you might want that conduit-stm thing?
14:43:14 <elliott> to use a TChan
14:43:37 <kallisti> Peaker: while you're at it, you could add it to irc-conduit, since that's a thing that it will eventually do.
14:45:45 <kallisti> Peaker: but yeah, essentially you'd spawn a thread for each incoming piece of data of sufficient size (say, a line perhaps), passing the thread a channel. meanwhile you have a thread reading from the channel and yielding to the sink.
14:46:08 <Peaker> elliott: looks good :)
14:46:30 <Peaker> kallisti: Why not a thread per client?
14:46:36 <kallisti> Peaker: that works.
14:46:52 <kallisti> why not per line? :P
14:47:16 <kallisti> I guess per client makes more sense given that the source must change
14:47:26 <kallisti> er, sink
14:47:50 <kallisti> there's one sink per client
14:49:59 <notthemessiah> What's the quickest way to turn a list of lists of rgb tuples to a bitmap image?
14:49:59 <lambdabot> notthemessiah: You have 1 new message. '/msg lambdabot @messages' to read it.
14:51:49 <kallisti> elliott: uh, this is for reading Core, right?
14:52:01 <kallisti> I guess that's what I need..
14:52:25 <kallisti> alternatively I could go read Text and ByteString source until I understand every rule pragma
14:53:34 <qnikst> hello, how can I use nameDeriveLenses from data.Lenses package
14:53:55 * elliott suggests not to use Data.Lenses.
14:54:00 <qnikst> I've got data Foo a = Foo { f::a, g::a}
14:54:08 <elliott> it's quite an ugly representation and not maintained
14:54:20 <elliott> perhaps you're confusing it with the data-lens package, which *is* maintained (and quite popular)?
14:54:26 <qnikst> ok, what's better to use?
14:54:39 <elliott> data-lens or fclabels are the popular lens packages; I prefer the former
14:54:48 <elliott> there's data-lens-template for Template Haskell deriving of data-lenses
14:54:54 <kallisti> elliott: how do mere mortals make sense of this output?
14:54:58 <elliott> (fclabels can do it too)
14:55:12 <elliott> kallisti: Core is simple, it's just a tarpit Haskell with a lot of coercion noise
14:55:39 <kallisti> if you say so
14:55:56 <elliott> as I said, ghc-core elides some of the non-coercion noise
14:56:07 <qnikst> elliott: thanks will check
14:56:13 <kallisti> yes I'm looking at it.
14:56:14 <navaati> do you think a module binding to the DRM kernel interface should belong to Graphics. or System. ?
14:56:33 <kallisti> the problem is I can't tell what's relevant to me..
14:56:40 <elliott> navaati: probably System., IMO
14:56:51 <kallisti> oh, I should just make a seperate file.
14:56:52 <kallisti> that works.
14:56:57 <elliott> I don't think anything lower-level than SDL or OpenGL or X11 belongs in Graphics.*, but that's just my opinion
14:57:03 <navaati> elliott: hum… i think the same, but X11 is in Graphics…
14:57:08 <navaati> ah, ok
14:57:19 <navaati> let's go to System, then
14:57:32 <elliott> navaati: well, I don't know much about DRM
14:57:51 <elliott> navaati: can you summarise basically what the binding will offer?
14:58:29 <Peaker> hmm.. I've got a bunch of "chat clients", I represent each with a TBMChan, but the list of TBMChans is dynamic as clients are added/removed.  Whatever conduit/sink I make for the clients is thus dynamic too, but apparently when I compose the conduits I must do it statically
14:58:57 <kallisti> you're no longer dealing with one conduit.
14:58:59 <hpaste> Mathnerd314 pasted “Missing MonadIO instance?” at http://hpaste.org/66931
14:59:06 <kallisti> you have one conduit per client
14:59:20 <navaati> elliott, at the beginning : modesetting, buffer creation, you'll be able to draw on them using an MArray interface
14:59:21 <Mathnerd314> ^ I did import System.Console.Haskeline, but for some reason it isn't picking up the MonadIO instance defined for InputT
14:59:32 <navaati> (mmaping, basically)
14:59:38 <Peaker> kallisti: but the incoming data from the client conduit needs to somehow be piped to all other conduits
14:59:58 <Peaker> kallisti: in that sense I need to send that data to a dynamic set of sinks
15:00:14 <kallisti> Peaker: you could send to concurrent channels
15:00:25 <elliott> navaati: hmm...
15:00:25 <Peaker> kallisti: also, I'm figuring I need a different chain/pipe for the from-socket side and the to-socket side, as they're not really related, so I have 2 threads for each client
15:00:32 <elliott> navaati: I'd be inclined for something like System.Graphics
15:00:40 <elliott> navaati: but it's up to you
15:00:41 <qnikst> elliott: but my questions still remains I have data Foo, and lensFoo :: String -> Maybe String lensFoo = Just; and i want to $(nameMakeLens ''Foo lensFoo)
15:00:43 <kallisti> Peaker: yes
15:00:58 <elliott> qnikst: ok, well if you have
15:01:00 <qnikst> and I don't know how to write ..lensFoo) part
15:01:01 <Peaker> kallisti: what is a "concurrent channel"?
15:01:03 <navaati> i thought about it, but module names will be long as hell ^^. I'll go to System.Drm…
15:01:07 <Peaker> kallisti: TBMChan?
15:01:14 <elliott> data Foo = Foo { _a :: Int, _b :: String }
15:01:16 <elliott> then you can just do
15:01:16 <kallisti> Peaker: a queue. of some kind. if that fits the bill, then sure.
15:01:19 <elliott> makeLens [''Foo]
15:01:28 <Peaker> kallisti: I could send to multiple chans with an IO action, but I'm trying to learn the conduit way
15:01:30 <elliott> qnikst: you can't use lensFoo like that, because you'd have two conflicting a definitions
15:01:35 <elliott> a :: Foo -> Int and a :: Lens Foo Int
15:01:55 <Peaker> kallisti: i.e: use the sinkTBMChan thingie
15:02:00 <elliott> (gah, data-lens-template still has the outdated data-lens dep!)
15:02:08 <qnikst> elliott: hm..
15:02:11 <kallisti> Peaker: I dunno I haven't looked at stm-conduit
15:02:47 <elliott> gah, the git history of the base package is impossible to sift through
15:02:59 <qnikst> I can to lensFoo s = Just $! "foo"++s
15:03:04 <Peaker> Ok, I think I'll try a centralized entity everyone synchronizes against, instead of sending each other directly
15:03:12 <qnikst> question is about TH syntax
15:03:27 <elliott> qnikst: well, why not just use the defaults?
15:03:35 <elliott> which just lens anything with a _ prefix
15:03:37 <elliott> and remove the _ prefix
15:03:52 <kallisti> Peaker: yes that would work well
15:03:59 <navaati> unrelated : how do i massively search-replace over all files in a folder ?
15:04:14 <kallisti> navaati: in... Haskell? or, in shell?
15:04:15 <elliott> navaati: find . -name '*.hs' -exec sed -i 's/.../.../g' '{}' \;
15:04:25 <qnikst> elliott: to learn how to use lenses for custom types e.g. Time etc
15:04:34 <elliott> qnikst: look at the makeLenses doc http://hackage.haskell.org/packages/archive/data-lens-template/2.1.3/doc/html/Data-Lens-Template.html
15:04:47 <Peaker> kallisti: it may inhibit parallelization..
15:04:51 <elliott> qnikst: oh, you want to derive lenses for a third-party type?
15:04:56 <qnikst> yes
15:05:17 <elliott> qnikst: try nameMakeLenses ''Blah (\s -> Just ("lens_" ++ s)) or such
15:05:20 <qnikst> or know when I should not do them
15:05:55 <qnikst> inline version works, thanks
15:06:08 <elliott> btw, you can omit the $() in ghc 7 onwards
15:06:18 <Peaker> kallisti: I'll do it first for pedagogical purposes, but I don't think it's necessarily a good real-world approach
15:06:57 <elliott> gah, i'm going to have to resort to downloading ancient ghc tarballs
15:07:06 <Glor> hello i know this is not a prolog channel but noone is in prolog and im wondering if i could ask a question about prolog in here
15:07:10 <elliott> no
15:07:15 <hpaste> Mathnerd314 annotated “Missing MonadIO instance?” with “Missing MonadIO instance? (annotation)” at http://hpaste.org/66931#a66932
15:07:18 <Glor> :)))
15:07:18 <elliott> try ##c :P
15:07:23 <Glor> damn
15:07:25 <elliott> or #rubyonrails!
15:07:33 <Glor> i dont think they know prolog
15:07:38 <Glor> haskell is the closest to prolog
15:07:42 <bitonic> Glor: what? no
15:07:42 <elliott> haskell is nothing like prolog
15:07:59 <Mathnerd314> ##prolog ?
15:08:06 <fgomez> lol
15:08:27 <lispy> Haskell has some parts that are prolog-like. The relations formed by type classes comes to mind.
15:08:27 <shergill> well tbf, both languages had hurdles they had to overcome to get io to work
15:08:38 <shergill> i'm also being somewhat facetious
15:09:03 <copumpkin> [18:08:37] <nolyc> I tried to buy a Renault in a Renault shop, but there were no salesmen available, so I came into this Ford shop. Why won't you sell me a Renault?!
15:09:04 <elliott> Glor: maybe try #haskell-blah if you want to ask haskellers a non-haskell question? :P
15:09:12 <joe-generic> Glor: maybe try #erlang
15:09:12 <lispy> Both languages have pattern matching, although prolog's pattern matching is far more powerful
15:09:17 <elliott> joe-generic: *g*
15:09:24 <copumpkin> @where+ renault I tried to buy a Renault in a Renault shop, but there were no salesmen available, so I came into this Ford shop. Why won't you sell me a Renault?!
15:09:24 <lambdabot> Good to know.
15:09:27 <Glor> . /join #c does not work :(
15:09:32 <elliott> Glor: you have to register your nickname
15:09:34 <Glor> im on the web irc platform
15:09:36 <elliott> /msg nickserv help register
15:09:48 <elliott> joining #c is also not haskell-related ;)
15:09:55 <elliott> btw, my recommendation of #c was not serious.
15:10:10 <elliott> i think if you ask ##c a prolog question you will be dead within the hour...
15:10:26 <shergill> Glor: you may like #emacs. contrary to #haskell, pretty much everything is emacs-related :P
15:11:06 <lispy> Glor: disguise your prolog question as a question about Curry and then people here might get interested
15:11:20 <kallisti> elliott: yeah this isn't helping me (because I can't read gh234eegweet_mangled2_zznamez
15:11:24 <kallisti> )
15:11:31 <elliott> kallisti: preflex can decode those
15:11:51 <lispy> zenc on hackage does z-encoding and z-decoding, FWIW
15:12:01 <lispy> ?where zenc
15:12:02 <lambdabot> I know nothing about zenc.
15:12:06 <elliott> ?hackage zenv
15:12:06 <lambdabot> http://hackage.haskell.org/package/zenv
15:12:06 <elliott> ?hackage zenc
15:12:07 <lambdabot> http://hackage.haskell.org/package/zenc
15:12:11 <lispy> thanks
15:12:16 <kallisti> elliott: preflex?
15:12:18 <Peaker> with conduits, whenever the set of sinks I need to write is dynamic, I'm not sure what to do
15:12:25 <elliott> kallisti: preflex.
15:12:28 <Peaker> I need some sort of broadcast
15:12:30 <elliott> preflex: quote
15:12:31 <preflex>  <b3> we need to make it work on any system, so we need to get the win api running on Linux systems, and Macs as well if possible
15:12:36 <lispy> preflex: decode ZMZN
15:12:45 <copumpkin> preflex: zdec ZMZN
15:12:45 <preflex>  []
15:12:49 <elliott> preflex: zdec asdjsad
15:12:49 <preflex>  asdjsad
15:12:51 <elliott> preflex: zdec ZmZCMKAZCMLK
15:12:51 <preflex>  Zm:MKA:MLK
15:12:56 <kallisti> elliott: no I mean I can't recognize what the code is doing anymore
15:13:03 <kallisti> the z-encoding isn't really a problem.
15:13:08 <kallisti> the names are meaningless now
15:13:16 <elliott> shrug
15:13:20 <kallisti> there's a lot of ptr magic going on because I'm reading bytestring core..
15:13:33 <elliott> i'm too much of a rockstar ninja jquery wizard to have ever had the problem of not being able to read core
15:13:38 <qnikst> Peaker: you can make a store of receivers and send message to all of them in one transaction
15:13:58 <kallisti> elliott: surely there's a better way to figure out if these bytestrings are being needlessly converts to string and back..
15:14:42 <qnikst> assume t::TVar [Chan M];  ... later atomically $ readTVar t >>= mapM_ (flip writeTChan msg)
15:15:16 <Peaker> qnikst: well, in IO it's easy :) I'm wondering what the conduits approach is
15:15:48 <qnikst> I've used it in conduits when I was making simple chat server
15:15:51 <Peaker> (for handling forking/merging of conduit data flow)
15:16:02 <elliott> Peaker: I don't think they do that.
15:16:07 <elliott> Peaker: (Though it would be interesting if they did.)
15:16:13 <kallisti> Peaker: you know that conduits have access to IO right?
15:16:21 <qnikst> it can be done easily
15:16:21 <Peaker> Yeah, but it seems to defeat the purpose?
15:16:23 <elliott> Only if their base monad is IO.
15:16:31 <elliott> Peaker: Not really, it still handles the IO for you.
15:16:35 <elliott> It's the internal logic that it doesn't do.
15:16:36 <kallisti> Peaker: streaming data =/= routing data concurrently everywhere
15:17:00 <kallisti> you need to write your own code for that (until "someone" devises an amazing concurrency abstraction over some streaming data library)
15:17:10 <qnikst> Peaker: for forking you can create a sink with TVar in it and store outputs there
15:17:14 <qnikst> then just send message to all as above
15:17:17 <ezyang> Man, I could sure use some monadic view patterns right now.
15:17:27 <qnikst> merging is in stm-chan already
15:17:40 <kallisti> Peaker: conduits are not a magic tool to write your server logic for you.
15:17:40 <qnikst> mergeSources or >< afaik
15:17:49 <elliott> ezyang: hmm, what would that be?
15:17:53 <Peaker> qnikst: then I think i'll just use an MVar of all clients, and have each client have a sink that sends to all other clients
15:18:10 <Peaker> (And not STM at all)
15:18:10 <Mathnerd314> ezyang: would that require specifying an evaluation order?
15:18:14 <kallisti> Peaker: you should not do that and instead write an IRC server using irc-conduit.
15:18:19 <elliott> Peaker: why avoid STM?
15:18:33 <Peaker> elliott: I don't see what I'm gaining from it in this case
15:18:37 <qnikst> Peaker: then plz create source and sink for boundary chans
15:18:40 <ezyang> Mathnerd314: Yep.
15:18:49 <qnikst> I've failed with simple IO Chan =)
15:18:51 <Peaker> I don't want a centralized STM thread that broadcasts, it'd be a bottleneck
15:18:57 <elliott> Peaker: well, with TChan you can easily handle many consumers without duplicating the chan
15:19:03 <ezyang> Something for the pattern, "run these commands in order until one htis go". But with pattern matching too.
15:19:03 <elliott> which is convenient for a chat server
15:19:07 <elliott> also, it's less pain than MVars ;)
15:19:17 * elliott didn't suggest centralised anything
15:19:46 <qnikst> elliott: for forking/merging there will be some central points
15:20:00 <kallisti> Peaker: did I mention there's an irc-conduit library that already parses and serializes IRC for you?
15:20:03 <kallisti> because that's totally a thing
15:20:05 <Peaker> elliott: I need all of the consumers to read their own thing, so I need to duplicate anyway
15:20:05 <kallisti> that exists
15:20:06 <gdeest> Someone pointed out to me that ((->)e) was a Monad, actually it looks to me that it's only an applicative functor ; am I missing something ?
15:20:18 <elliott> gdeest: well, if it's an applicative functor, all you need is join to prove it's a monad
15:20:20 <Peaker> kallisti: I'm just doing an exercise here :)
15:20:22 <elliott> gdeest: join :: m (m a) -> m a
15:20:26 <elliott> gdeest: join :: (e -> (e -> a)) -> (e -> a)
15:20:30 <elliott> gdeest: can you write this function?
15:20:42 <elliott> (of course, it has to obey laws too, but you can accept that it does on faith ;) )
15:20:43 <qnikst> Peaker: you can use naïve aproach with BoundedChan assuming it will never close before client exit
15:21:05 <qnikst> anyway for chat servers I'd sujest using STM =)
15:21:26 <qnikst> for simple merging data maybe IO Chans will be good too
15:21:38 <qnikst> *for static merging
15:21:43 <elliott> gdeest: (in fact, the ((->) e) monad is useful and has a fancy name: the Reader monad. it lets you carry around a common environment)
15:22:05 <qnikst> but you'll track clients, so there should be some transactions guarantees
15:22:31 <gdeest> elliott: where is this instance declared ? doesn't seem to be in the Prelude
15:22:41 <Mathnerd314> ezyang: so what would e.g. readInput (getLine -> x) (getLine -> y) = putStrLn $ "you said " ++[x,y] print?
15:22:49 <elliott> gdeest: oh, Control.Monad.Instances
15:22:51 <edwardk> gdeest: f >>= r = \e -> f (r e) e
15:22:57 <edwardk> its in Control.Monad.Instances for now
15:23:00 <elliott> gdeest: sorry, I interpreted your question as "is it a monad", not "is it a Monad in Haskell" :)
15:23:12 <kallisti> Peaker: well you don't have to write a whole IRC server..
15:23:15 <edwardk> I pushed a libraries proposal through last year to move them out of there and into something more central
15:23:22 <elliott> can we put it in Prelude pls
15:23:23 <edwardk> as a prelude to getting it fixed in Haskell'
15:23:27 <gdeest> elliott, edwardk : it was kinda both, actually :)
15:23:57 <kallisti> Peaker: if it's "just an exercise" why are you worried about bottlenecks?
15:24:25 <hpaste> monoidal pasted “kind polymorphism in a GADT” at http://hpaste.org/66933
15:24:42 <monoidal> http://hpaste.org/66933 - should this compile? I think yes
15:24:52 <edwardk> gdeest: that monad is rather nice because it is a canonical form for any representable functor ;)
15:25:04 <ezyang> Mathnerd314: desugars to readInput = do x <- getLine; y <- getLine; putStr ...
15:25:13 <copumpkin> monoidal: I wouldn't expect it to
15:25:14 <Peaker> kallisti: because the purpose of the exercise is knowing how to write stuff that don't have such silly bottlenecks :)
15:25:27 <ezyang> Pattern match failure results in moving onto the next case.
15:25:32 <ezyang> Admittedly, this isn't so good for IO.
15:25:56 <copumpkin> monoidal: edwardk has played plenty with the polykinds stuff though, so he can give you a better answer
15:26:04 <copumpkin> or byorgey, who wrote a lot of it :)
15:27:54 <edwardk> monoidal: the polykinds code only infers mono kinds for multiple constructor ADTs
15:28:05 <monoidal> my use case was data Equal a b where Refl :: Equal a a, H :: Equal f g -> Equal (f x) (g x)
15:28:17 <monoidal> edwardk: Do you think it will be changed later?
15:28:31 <Mathnerd314> ezyang: ok, what about f (getLine -> _) [] = ..., f (getLine -> _) (x:xs) = ... ? does it do getLine twice?
15:28:55 <copumpkin> Mathnerd314: it doesn't do the getline at all
15:29:09 <edwardk> monoidal: data Equal a b = Refl :: (forall f. f a -> f b) works btw the a and b are polykinded
15:29:10 <ezyang> copumpkin: Oh you sly bastard! :-)
15:29:11 <edwardk> as does
15:29:18 <edwardk> data Equal a b where Refl :: Equal a b
15:29:20 <copumpkin> first of all because getLine doesn't take arguments
15:29:21 <edwardk> er Equal a a
15:29:25 <edwardk> that also gets a polykind
15:29:36 <edwardk> its that extra H constructor screwing you up
15:29:39 <monoidal> Yes
15:29:49 <edwardk> Why do you need H?
15:29:59 <kallisti> Peaker: you essentially want "router" threads that can associate an identifier with a channel of some kind
15:30:01 <copumpkin> second of all, because the monadic action doesn't get run just by evaluating the value
15:30:22 <edwardk> h :: Equal f g -> Equal (f x) (g x) -- should be definable
15:30:53 <kallisti> Peaker: for IRC, you could have routers per channel. this avoids having a ceneralized bottleneck. for privmsgs to individual nicks I think you would need to centralize it.
15:31:00 <monoidal> edwardk: I wanted to embed simple "reasoning logic" so that types will be statements to prove, and values will be proofs
15:31:01 <edwardk> monoidal: in practice, we'll be getting a syntax for writing polymorphic kinds eventually which will make this work a lot better
15:31:16 <Peaker> is there a bracket'd forkIO somewhere that kills the thread when going out of the bracket?
15:31:27 <edwardk> e.g. class Category (k :: a -> a -> *) where
15:31:29 <kallisti> Peaker: unless you do something fancy like make assumptions about privmsg "conversations" and how long they last.
15:31:50 <Peaker> kallisti: the centralization can be via a shared mvar or such
15:31:54 <monoidal> For example, I would like to write the proof (f.g).h = (f.g).h as a composition of several rules (extensionality of functions, definition of composition)
15:32:14 <Mathnerd314> copumpkin: ok, s/getLine/const getLine/, and secondly ezyang was suggesting monadic view patterns
15:32:17 <edwardk> monoidal: yeah you're out of luck for now
15:32:20 <copumpkin> Mathnerd314: oh
15:32:30 <edwardk> monoidal: there are a lot of things i want to do with polykinds that are stuck waiting for 7.6.1
15:32:37 <ezyang> OK, let's be a little more serious about this.
15:32:41 <kallisti> Peaker: why mvars. I don't understand.
15:32:54 <Peaker> in Conduit's "runTCPServer" I get a thread per client, but in it, I want a data-flow-thread for the tx side, and another thread for the rx side, but I want to kill any extra threads when the client dies
15:32:56 <ezyang> monoidal: "Here's a nickle kid, get yourself a real dependently typed language"
15:33:12 <copumpkin> :D
15:33:19 * copumpkin ushers monoidal over to #agda
15:33:23 <elliott> <monoidal> edwardk: I wanted to embed simple "reasoning logic" so that types will be statements to prove, and values will be proofs
15:33:23 <nart> hi :)
15:33:29 <elliott> undefined :: HaHa SucksToBe You
15:33:29 <Peaker> kallisti: to minimize serialization, maybe (though I haven't thought this through)
15:33:35 <ezyang> So, the idea behind monadic view patterns is we want to pattern match on the result of a monadic computation
15:33:36 <kallisti> Peaker: ...serialization of what?
15:33:41 <Peaker> kallisti: of work, in a thread
15:33:49 <Peaker> kallisti: work can be spread out to more threads, perhaps
15:33:50 <ezyang> So maybe we don't actually want monadic view patterns; we just what monadic case.
15:33:55 <ezyang> *want
15:33:59 <Peaker> (unless the mvar lock over-serializes, in which case I might be wrong about it)
15:34:00 <edwardk> elliott: great serialize that representation and i'll check it later ;)
15:34:11 <kallisti> for example, when a user joins a channel, you can lookup the chanenl in a map that associates it with a channel.
15:34:16 <edwardk> ezyang: i would love a monadic case
15:34:28 <kallisti> that channel points to a thread that handles commands pertinent to that channel and that channel alone
15:34:37 <kallisti> that decentralizes your thread traffic, essentially.
15:34:50 <ezyang> I feel like there's gotta be a proposal for this somewhere. Did it fizzle because allocating new keywords is hard?
15:34:56 <elliott> edwardk: wat
15:35:01 <edwardk> ezyang: probably
15:35:15 <kallisti> case lambdas are better.
15:35:37 <ezyang> oh yeah, that proposal has been in the works for a while
15:35:37 <Philippa> I suspect it fizzled because nobody could be bothered to hack up a GHC patch
15:35:47 <ezyang> Wait, really?
15:35:49 <edwardk> elliott: the idea being that if the proof terms aren't obliviously erased i can force the whole term and crash out before i do anything that depends on the proof
15:35:53 * ezyang thought there are lots of GHC hackers these days 
15:35:59 <monoidal> if I understand correctly, Haskell/Omega have "staging": first check kinds, then types, then values, and at runtime we have values only. In dependent typing, is this gone?
15:36:11 <Philippa> monoidal: not necessarily
15:36:22 <elliott> edwardk: right
15:36:25 <ezyang> monoidal: Dependently typed languages still have a notion of erasure.
15:37:10 <Philippa> ezyang: maybe, but there's still no "beginner's guide to adding a new language feature" for it that I know of :-)
15:37:15 <Mathnerd314> any advice on this error? http://hpaste.org/66932
15:37:15 <dolio> You always check types before evaluating things. In dependently typed languages, you sometimes evaluate during checking, though.
15:38:03 <ezyang> "beginner" -- "adding a new language feature" : I think there is an oxymoron here!
15:38:09 <kallisti> Peaker: if you have only one channel then there is no bottlenek..
15:38:11 <kallisti> +c
15:38:23 <Philippa> ezyang: beginner to hacking GHC, not coding in Haskell
15:38:34 <Philippa> I'd be in the target audience, for example
15:39:00 <dolio> Beginners to coding in Haskell have so many more language feature proposals, though. :)
15:39:00 <kallisti> one can always write TH hacks
15:39:01 <ezyang> hmm, I can't find any tickets about lambda case
15:39:25 <Philippa> kallisti: sure, you can code in brainfuck too
15:39:31 <kallisti> the best syntax I've come up with is:
15:39:39 <kallisti> \case x -> ...
15:39:41 <kallisti> \case y -> ...
15:39:43 <kallisti> etc
15:40:15 <kallisti> but the "case" may not be needed, I don't know
15:40:24 <kallisti> I figured it would make it easier to parse (and for editors to indent, etc)
15:40:41 <ezyang> hmm, wouldn't (\case x -> | y ->) stll be parseable?
15:41:57 <Saizan> Agda has \{ p1 -> ...; p2 -> ..}
15:42:26 <ezyang> Philippa: Anyway, the first step to adding a language extension like this is figuring out how to adjust the parser to accept the syntax you want.
15:43:32 <ezyang> So you wanna look at compiler/parser/Parser.y.pp
15:44:22 <ezyang> If you've ever worked with a parser generator before, it works basically the way you'd expect it to. Have some fun with it; it's touchy, but in the right sort of way.
15:44:23 <Philippa> ezyang: I'm not about to do it, but yes, a sequence of steps like that is the sort of thing I had in mind (only tracing through until you've typechecked and spat out Core at the least, I guess)
15:44:39 <ezyang> Aww :-)
15:45:12 <ezyang> I find a healthy dose of overconfidence helps make projects like these actually happen.
15:45:58 * ezyang goes off to find out what's going on with SYB 
15:46:07 <ezyang> (or do people like using something else these days? I never know.)
15:46:33 <elliott> There's the uniplate/multiplate stuff?
15:46:51 <ezyang> In this particular case, I don't feel like writing an instance for JSON which handles a 20-variant.
15:47:00 <ezyang> so, has someone written down what the difference is?
15:47:20 <elliott> uniplate is meant to be simpler, I think
15:47:40 <ezyang> OK.
15:47:48 <elliott> ...in design, that is
15:47:49 <elliott> dunno about use
15:48:04 <Enigmagic> ezyang: there is a JSON instance for Generic, if that suits your needs..
15:48:04 <elliott> GHC can derive Data, at least, so if multiplate or whatever doesn't use Data that's an advantage for syb
15:48:11 <elliott> sorry, i don't really know :)
15:48:20 <ezyang> oh ho, really?
15:49:04 <kallisti> aeson's default JSON parsing stuff is really strict
15:49:24 <kallisti> strict meaning that it complains very easily
15:49:31 <kallisti> if the JSON is not just so-so
15:50:06 <ezyang> Oh, right, I'm supposed to use aeson, not json. Oops.
15:50:06 <Enigmagic> i mostly produce with aeson and consume in javascript so i've not had any issues
15:51:52 <Peaker> doh! stm-conduit is built on some old conduit version :-(
15:52:14 <Peaker> oh, not from github
15:55:20 <kallisti> elliott: if I showed you some Core could you show if it's converting Bytestrings needlessly into Strings?
15:56:03 <qnikst> Peaker: there is stm-conduit-0.4
15:56:21 <qnikst> I've patched in on last weekend =)
15:57:03 <elliott> kallisti: dunno
15:59:18 <fmap> can lambdabot show sources for instances?
15:59:40 <Axman6> @src Maybe fmap
15:59:41 <lambdabot> fmap _ Nothing       = Nothing
15:59:41 <lambdabot> fmap f (Just a)      = Just (f a)
15:59:56 <fmap> @src Either fail
15:59:56 <lambdabot> fail msg      = Left (strMsg msg)
16:00:06 <fmap> hmm, thanks
16:01:10 <kallisti> well if you want to find out you can check my fork of interpolatedstring-perl6. there's a test program called TestRewrite.hs
16:02:38 <elliott> fmap: that's wrong
16:02:41 <elliott> as of mtl 2 or so
16:02:46 <elliott> fail is now error
16:08:44 <fmap> elliott: yes, my ghci thinks it's error. very sad :(
16:09:32 <elliott> fmap: not sad
16:09:38 <elliott> fmap: it removes the junk Error constraint
16:09:40 <elliott> just don't use fail
16:09:49 <elliott> or use ErrorT if you really want the silly Error stuff
16:12:01 <kallisti> elliott: based on -ddump-rule-firings there's no rule named "ByteString pack/packAddress" being fired
16:14:25 <kallisti> there is a rule called "unpack"
16:14:28 <kallisti> time to figure out what that's about
16:15:29 <wut> what does the >> operator do? i.e. (>>) :: m a -> m b -> m b
16:15:42 <wut> how is it used with >>=?
16:15:47 <kallisti> m >> n = m >>= (const n)
16:16:34 <elliott> a >> b is just shorthand for a >>= \_ -> b
16:16:37 <elliott> i.e. do a then b, ignore a's result
16:16:51 <wut> ah, thanks
16:17:22 <wut> why would you ever need to do that?
16:17:41 <Tinned_Tuna> wut: if a is an action, like writing to a log
16:17:53 <Tinned_Tuna> tell "About to perform action b" >> b
16:17:55 <elliott> wut: when you don't care about a's result, but only its effects
16:17:59 <td123> wut: it's just a cleaner way of writing it
16:18:06 <elliott> for instance, any time you have an action (m ())
16:18:08 <wut> i see now, thanks
16:18:10 <elliott> you probably don't care about its result :)
16:18:23 <elliott> putStrLn "hi" >> getLine >> putStrLn "bye" -- ignores the line it reads
16:19:20 * kallisti can't find a rule called "unpack" anywhere
16:19:32 <kallisti> oh it might just be an inline.
16:19:48 <ezyang> Ewww, handing off a Haskell allocated bytestring to another memory system is not fun. (As far as I can tell, I need to do it in a C callback.)
16:20:22 <kallisti> ezyang: hmm? you can just pass the pointer
16:20:32 <kallisti> or a pointer to a copy of the bytestring, if you need safety
16:20:55 <ezyang> kallisti: How do I make sure the bytestring doesn't get GC'd?
16:21:10 <kallisti> pass it to C
16:21:10 <kallisti> :P
16:21:20 <mauke> wat
16:21:21 <ezyang> That requires me to StablePtr it.
16:21:32 <ezyang> I guess I can destroy the stable ptr from C land later...
16:21:40 <Peaker_> kallisti: https://github.com/Peaker/conduit-chatserver/blob/master/chatserver.hs <-- ended up with this. works ok :)
16:21:57 <elliott> ezyang: Can't you just use the withBlahBlahs?
16:22:01 <kallisti> ezyang: well if you don't plan on using the bytestring again
16:22:05 <kallisti> you can just copy it.
16:22:11 <kallisti> via the aforementioned withBlahBlahs
16:22:22 <ezyang> elliott: I can. However, the inner function needs to be in C.
16:22:39 <Peaker> wut: do you know the Applicative class?
16:22:47 <kallisti> ezyang: so what's the problem?
16:22:48 <ezyang> ...or I guess I could foreign import the malloc function I need. I wonder if that works.
16:23:13 <ezyang> kallisti: Then I have to dredge up a funptr and invoke from Haskell land and the calls end up looking like C -> Haskell -> C
16:23:14 <kallisti> there are already allocation bindings for Haskell
16:24:23 <ezyang> Custom memory manager. Haskell doesn't know about it.
16:24:23 <kallisti> I feel as though you're overcomplicating this...
16:24:24 <ezyang> I'm hooking up two runtime systems, of course it's going to be complicated :-)
16:25:19 <kallisti> ezyang: are you aware of useAsCString?
16:25:26 <kallisti> and related functions?
16:26:10 <ezyang> Yes. As I said, the devil is what you put in the callback
16:26:15 <wut> Peaker: i don't but i'll look into them now
16:26:19 <kallisti> ezyang: what callback
16:26:41 <ezyang> you pass useAsCString (CString -> IO a)
16:26:46 <kallisti> yes
16:26:59 <ezyang> but this function needs to use a malloc function which Haskell doesn't know about.
16:27:58 <kallisti> ??
16:28:03 <kallisti> the string is freed afterwards
16:28:36 <kallisti> in fact it's stack allocated
16:29:13 <ezyang> No, as in, what I want to do with the string involves copying it to the heap of a non-Haskell runtime.
16:29:34 <kallisti> I understand what you're trying to do.
16:30:03 <ezyang> OK, what am I trying to do/
16:30:34 <kallisti> you want to pass a bytestring to another runtime system. you want it to appear as though it was allocated by that runtime
16:30:52 <kallisti> so why don't you just pass the ByteString pointer unsafely, then allocate a copy in the runtime?
16:31:10 <ezyang> "pass the ByteString pointer unsafely" -> what do you mean by that?
16:31:17 <kallisti> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Unsafe.html
16:31:23 <kallisti> unsafeUseAsCString
16:31:34 <kallisti> no copying occurs
16:31:38 <kallisti> no null termination occurs
16:31:47 <navaati> how do i do the equivalent of when, in C, you declare a static variable in a function, initialize it the first time it's called and reuse it the other times ?
16:32:16 <kallisti> navaati: there isn't a direct equivalent to that.
16:32:23 <kallisti> it could be simulated with the State monad though.
16:32:36 <elliott> navaati: Initialise it how?
16:32:39 <elliott> Do you want to mutate this variable?
16:32:41 <elliott> If not, then
16:32:48 <elliott> f = let x = ... in \y -> ...
16:32:51 <elliott> will work fine.
16:32:51 <navaati> kallisti: i don't want to simulate it, i interface to a C lib that need that
16:33:02 <kallisti> erm
16:33:08 <elliott> If you're interfacing with a C lib, you're probably going to have to do things in IO.
16:33:12 <navaati> yeah
16:33:20 <navaati> i know, that's not a problem
16:33:25 <elliott> So... what is your question, exactly?
16:33:40 <kallisti> you can't make Haskell functions with static variables, no
16:33:41 <ezyang> kallisti: OK. How do I write the function that I pass to unsafeUseAsCString?
16:33:41 <kallisti> you need to do that in C
16:33:55 <navaati> but i still don't know how to do it, because even in IO you can't get an IORef from nowhere…
16:33:56 <ezyang> dammit, why is Aeson lazy bytestrings. Annoying :-(
16:33:58 <kallisti> ezyang: presumably it's C code, right?
16:34:08 <kallisti> ezyang: the only thing you might want to do is null-terminate it
16:34:14 <elliott> navaati: But you're interfacing with C code.
16:34:19 <elliott> navaati: It'll handle the static variable itself.
16:34:25 <elliott> Why do you need a global on the Haskell side?
16:34:49 <navaati> elliott: it means that i'll have to make C wrappers around every function… cumbersome
16:35:01 <elliott> navaati: I don't understand why.
16:35:19 <navaati> wait a min, i write a quick C sample to show you
16:35:35 <kallisti> is it even possible for other C code to sanely get at a C functions static variables?
16:35:42 <kallisti> (keyword sanely)
16:36:19 <Enigmagic> no
16:36:42 <jfischoff> extern wouldn't help?
16:37:28 <Enigmagic> marking a function scoped static variable extern?
16:37:59 <hpaste_> navaati pasted “looks like OOP in C, yeah” at http://hpaste.org/66935
16:38:05 <ezyang> kallisti: The other trouble is there is no useAsCString variant for lazy bytestrings
16:38:33 <kallisti> concat . fromChunks $ lazyByteString
16:38:34 <jfischoff> If I had a function static variable, and I declared a extern variable somewhere else that my other function had access to, would the linker be able to find the function static variable and link it to my extern reference
16:38:37 <navaati> see ? i don't want to have the users of my lib to create the driver once and pass it to every function like in C, it's ugly
16:38:37 <jfischoff> ?
16:39:18 <elliott> navaati: they should
16:39:20 <elliott> for thread-safety
16:39:22 <jfischoff> I guess you would have to name it with an underscore :)
16:39:29 <elliott> navaati: you _don't_ want to do that globally
16:39:34 <elliott> the C lib is designed like that for a reason
16:39:36 <kallisti> ezyang: or maybe it was toChunks
16:39:38 <Enigmagic> jfischoff: no
16:39:38 <kallisti> I can't remember
16:39:53 <jfischoff> alright then
16:40:26 <navaati> elliott: the C lib is designed like that because the driver handles different implementations that are choosen during the lib_get_driver() call, it's actually OOP in C…
16:40:47 <elliott> navaati: Okay. So you still want to expose it like that to Haskell.
16:40:51 <elliott> navaati: You could also try a Reader monad...
16:40:56 <navaati> but if it's not possible, well… sad
16:41:12 <elliott> It is *possible* to create a top-level global like that, but it's totally not what you want, and I refuse to tell you how :)
16:41:33 <elliott> You probably want to either mirror the structure of the C library, or define your own monad encapsulating the context.
16:41:48 <navaati> yeah, i heard about some d4rk magic doing that but i neither want to do it, i was more looking for a more haskellish way
16:42:01 <kallisti> ezyang: did you see the part where I converted a lazy bytestring into a strict one?
16:42:07 <kallisti> ezyang: also I really don't understand your problem.
16:42:22 * elliott agrees. kallisti really doesn't understand ezyang's problem
16:42:53 <navaati> "define your own monad" like a Reader with runMyMonad calling lib_get_driver() and feeding it to the reader ? could work, yeah
16:43:20 <kallisti> elliott: do you?
16:43:26 <elliott> navaati: more or less
16:43:35 <elliott> kallisti: more than you, I think :P
16:43:42 <elliott> navaati: you'd likely want your own MonadMylib typeclass so that it can be transformed easily, etc.
16:43:47 <elliott> navaati: but tbh I'd bind it just like the C interface
16:43:51 <elliott> navaati: and build the monad on top
16:44:33 <kallisti> ezyang: assuming your alocator is similar in interface to malloc. you just pass the CString to the C code, allocate the amount of memory you need in your fancy allocator, then copy the memory over.
16:45:19 <ezyang> that requires two copies.
16:45:26 <kallisti> not with unsafeUseAsCString
16:45:29 <navaati> ah ! found an easier and cleaner way ! i could create a simple C function initializing the stuff the first time it's called and re-using it the other times, import it into haskell with the type "IO Driver" and use it in every haskell wrapper around C functions
16:45:30 <kallisti> because it doesn't copy
16:45:36 <navaati> would that be very nasty ?
16:46:13 <kallisti> you said that you need to call it on each function invocation
16:46:29 <kallisti> will that do that?
16:46:35 <ezyang> yes, for the CString pointer I'm returning
16:46:42 <ezyang> uw_malloc won't copy, but I do need a copy.
16:47:25 <navaati> elliott: can you explain the thread safety stuff ?
16:47:38 <elliott> navaati: well
16:47:45 <elliott> navaati: if two threads want to use your library
16:47:47 <elliott> and you're using a global
16:47:52 <elliott> then they'll conflict, using the same driver
16:48:02 <kallisti> ezyang: yes you will need to copy on each transfer to different memory systems, to avoid hell.\
16:48:07 <elliott> navaati: and yes, that will be nasty in the exact same way
16:48:09 <ezyang> But I should only do one copy.
16:48:14 <elliott> navaati: but do what you wish
16:48:15 <ezyang> If I use the safe version, there will be two copies.
16:48:23 <kallisti> ezyang: yes and I said don't use the safe version
16:48:31 <kallisti> because you copy it in the C code
16:48:33 <kallisti> using your allocator
16:48:36 <kallisti> and then never touch it again
16:48:38 <kallisti> so it's safe.
16:49:32 <kallisti> it's only unsafe if the C code does unsafe things with it.
16:49:53 <ezyang> But there's no convenient function for doing this on lazy bytestrings...
16:49:59 <kallisti> correct
16:50:17 <elliott> ezyang: well, lazy bytestrings aren't really C-friendly, are they?
16:50:20 <elliott> with all those thunks and the like
16:50:29 <kallisti> so you do:  concat . toChunks $ lazyByteString
16:50:35 <kallisti> and now it's strict
16:51:02 <ezyang> elliott: Yes, but if I know the length, blitting them to something should be pretty easy to do.
16:51:08 <ezyang> kallisti: "So much copying!"
16:51:19 <navaati> hum… i still don't really understand the problem, but well… atm i'll simply mirror the C interface, no monad needed
16:52:05 <kallisti> ezyang: not really
16:52:07 <elliott> ezyang: well, just use toChunks, and turn that list into a C pointer
16:52:10 <navaati> bye
16:52:14 <elliott> then access each one unsafely
16:52:15 <elliott> to avoid most of the copying
16:52:25 <kallisti> ezyang: if you'd prefer to think about it less, there's a fromJSON instance for strict bytestrings
16:52:58 <ezyang> kallisti: In Aeson?
16:53:02 <kallisti> yes
16:53:11 <ezyang> where is it?
16:53:21 <elliott> ezyang: what language runtime btw?
16:53:22 <kallisti> it's an instance
16:53:23 <kallisti> it's just there.
16:53:44 <kallisti> it comes with Aeson. you get it for free!
16:53:49 <ezyang> I don't think that is, uh, quite what I want.
16:53:59 <ezyang> Isn't that "turn this Bytestring into a JSON string, representing the same thing"
16:54:03 <ezyang> as opposed to parsing it?
16:54:20 <kallisti> no
16:54:30 <kallisti> FromJSON turns parsed JSON structures into other things
16:54:48 <kallisti> ToJSON to takes other things and converts them into JSON structures.
16:55:02 <kallisti> the serialization/parsing of to/from text is done to said JSON structure.
16:56:17 <kallisti> it probably just does the concat . toChunks  thing I just described
16:56:53 <ezyang> No, I think the correct thing to do is to create a Parser, use the attoparsec API on strict bytestrings, and then apply the generic low level transformer
16:57:04 <kallisti> wat
16:57:08 <kallisti> what are you doing?
16:57:25 <kallisti> and what is "the generic low level transformer"
16:57:53 <elliott> im really confused ezyang is this related to the bytestring runtime stuff
16:58:40 <kallisti> ezyang: using Aeson does not require you to ever think about attoparsec
16:59:07 <kallisti> ezyang: are not using Aeson already? I thought you were.
16:59:46 <ezyang> In particular, use Data.Aeson.Parser.json, and then run the parser (using attoparsec? Maybe there's a utility function somewhere in aeson), and then do Data.Aeson.Generic.fromJSON
16:59:51 <ezyang> I am using Aeson.
17:00:12 <kallisti> yes the json and json' stuff is using attoparsec
17:00:14 <ezyang> Recall that JSON is a two step process: string -> JSON -> Haskell value
17:00:22 * kallisti is well-aware.
17:00:31 <ezyang> the typeclass you referenced only trests the JSON -> Haskell value step, so I don't think it is correct.
17:01:09 <kallisti> I didn't mean "you only get to use that one typeclass method"
17:01:47 <ezyang> Irrelevant.
17:02:02 <ezyang> I don't care about strict bytestrings in "Haskell value", I care about strict bytestrings in "string". Do you see?
17:02:15 <kallisti> no
17:02:25 <elliott> i understand nothing :(
17:02:59 <kallisti> just describe what you're attempting to do.
17:03:32 <ezyang> I mean, at this point I understand what I should be doing. But I'm trying to clear up misunderstanding on the channel.
17:03:49 <elliott> ezyang: did you say what runtime it was?
17:05:00 <ezyang> Urweb.
17:05:11 <ezyang> It uses regions to do memory management :-)
17:05:37 <elliott> oh, ur!
17:05:39 <elliott> ok
17:06:07 <dolio> It does?
17:06:29 <kallisti> ezyang: you're encoding to JSON right?
17:06:31 <dolio> I thought it just didn't do any management and let the fact that everything only ran for seconds at a time handle it.
17:06:33 <kallisti> not decoding?
17:06:50 <ezyang> kallisti: Yeah
17:06:58 <ezyang> dolio: "Well, I didn't say how precise the regions were"
17:07:07 <kallisti> then you're not parsing at all
17:07:08 <ezyang> kallisti: I need to do both. It's the most convenient way of shipping data between the two runtimes
17:07:17 <kallisti> ah
17:07:27 <elliott> there must be a more convenient way than going via json
17:07:31 <elliott> i mean come on :)
17:07:42 <dolio> ezyang: Oh. I guess that technically counts.
17:08:29 <ezyang> I think, though, that there is some modest cleverness in it.
17:08:51 <dolio> Well, the splitting the program into bite-sized chunks probably takes a little cleverness.
17:10:27 <Enigmagic> ezyang: unless you're doing omething more complex, Data.Aeson.decode will work without having to run the attoparsec stuff yourself
17:10:58 <kallisti> but think of all the copying!
17:11:17 <JoeyA> Is there a name for the set of libraries that are installed with GHC?  base, bytestring, time, etc. ?  I think it's a subset of the Haskell platform.
17:11:27 <JoeyA> Do people call these the "bootstrap libraries" ?
17:12:33 <elliott> JoeyA: Boot packages.
17:12:45 <JoeyA> Thanks
17:13:02 <elliott> JoeyA: Although that might technically just be the ones GHC depends on?
17:13:03 <elliott> Not sure.
17:13:22 <ezyang> Enigmagic: Yeah, the big brouhaha was over the fact that it's for lazy bytestrings
17:13:29 <JoeyA> I'm looking at the set of packages installed by the ghc-doc package in Ubuntu
17:13:56 <JoeyA> (By the way, Ubuntu 12.04 LTS ships with GHC 7.4.1.  Hip hip, hurray!)
17:13:57 <Enigmagic> ezyang: i see.
17:15:44 <ezyang> "Haskell programmers: we're a very lazy bunch"
17:24:50 <wut> how do you desugar do { stmnt1; stmnt2 }?
17:25:13 <dolio> stmnt1 >> stmnt2
17:25:40 <dolio> @undo do { stmnt1 ; stmnt2 }
17:25:40 <lambdabot> stmnt1 >> stmnt2
17:26:41 <wut> @undo do { stmnt1 ; stmnt2 ; foo <- stmnt3; stmnt4 }
17:26:41 <lambdabot> stmnt1 >> stmnt2 >> stmnt3 >>= \ foo -> stmnt4
17:26:45 <wut> nice, thanks
17:27:11 <wut> @undo stmnt1 >> stmnt2 >> stmnt3 >>= \ foo -> stmnt4
17:27:11 <lambdabot> stmnt1 >> stmnt2 >> stmnt3 >>= \ foo -> stmnt4
17:27:15 <wut> @do stmnt1 >> stmnt2 >> stmnt3 >>= \ foo -> stmnt4
17:27:15 <lambdabot> do { foo <- do { do { stmnt1; stmnt2}; stmnt3}; stmnt4}
17:31:09 <lispy> hey
17:31:14 <wut> hey
17:31:20 <lispy> How's it going?
17:31:35 <elliott> that @do output is silly
17:31:37 <elliott> should use the monad laws
17:31:44 <wut> kinda stressed... exam tomorrow... gotta learn monads tonight
17:31:56 <lispy> elliott: what do you mean?
17:32:29 <elliott> <wut> @do stmnt1 >> stmnt2 >> stmnt3 >>= \ foo -> stmnt4
17:32:30 <elliott> <lambdabot> do { foo <- do { do { stmnt1; stmnt2}; stmnt3}; stmnt4}
17:32:32 <dgpratt> wut: wut?
17:32:42 <lispy> I said wut wut
17:33:11 <lispy> elliott: I read that, but I still don't know what you want it to do differently
17:33:12 <dgpratt> lispy: when?
17:33:31 <wut> is it possible to master monads in 12 hours?
17:33:47 <elliott> lispy: erm... the obvious do { stmnt1; stmnt2; foo <- stmnt3; stmnt4 }?
17:33:54 <lispy> wut: Yes, if you're name is Simon or Oleg :)
17:33:56 <dgpratt> wut: it seems like it should be, but it usually isn't
17:34:09 <lispy> your*
17:34:17 <shachaf> _Teach Yourself Monads in 24 Hours_
17:34:31 <dgpratt> shachaf: 12 hrs too long
17:34:51 <ion> Now with extra food-related analogies!
17:35:22 <lispy> elliott: Ah, I guess I don't really think of that as an application of the monad laws. It's just changing the nesting. I guess I think of the monad laws in terms of (>>=)/return and not do/(<-)
17:35:30 <wut> is the State monad one of the most difficult monads to understand or are there harder ones?
17:35:43 <shachaf> wut: Your approach is not going to be fruitful.
17:35:57 <dgpratt> wut: I find Cont and Reader a little mind-bendy
17:36:01 <shachaf> wut: I recommend stopping to care about monads right now. You can always start caring again later.
17:36:05 <lispy> Cont is a great one
17:36:07 <shachaf> dgpratt: Reader? What?
17:36:27 <wut> does anyone know of some good monad exercises for beginners that get progressively more difficult?
17:36:31 <lispy> wut: this should help your head hurt: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
17:36:45 <elliott> lispy: Well, it only works because of the monad laws.
17:36:48 <lispy> wut: this http://www.haskell.org/haskellwiki/All_About_Monads
17:36:58 <wut> thanks for links
17:37:20 * elliott thinks reading the sigfpe link will leave one far more confused than one was to start off with
17:37:26 <wut> lispy: damn... that's a lot of reading
17:37:35 <lispy> wut: the all about monads links is IMO one of the best documents to learn them.  The first link, save it for later.
17:37:49 <dgpratt> shachaf: you are surprised I find that one mind-bendy? otherwise I don't know what what means
17:38:08 <shachaf> wut: The best link for learning "about monads" is the FAQ:
17:38:10 <shachaf> @where faq
17:38:10 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:38:17 <shachaf> wut: That has a good explanation of what you should be doing.
17:38:23 <shachaf> dgpratt: Well, it's just functions.
17:38:28 <lispy> I think Reader (->) is a bit bendy at times, but other instances of Reader are pretty vanilla
17:38:31 <ion> wut: State is trivial compared to Cont for me, but YMMV.
17:38:39 <shachaf> dgpratt: Presumably you're used to functions by the time you're looking at Reader.
17:38:46 <elliott> lispy: wat
17:39:04 <dgpratt> shachaf: I spent probably more than an hour staring at "ap zip tail"
17:39:10 <shachaf> I like vanilla.
17:39:12 <shachaf> Mmm.
17:39:37 <shachaf> dgpratt: If you were doing that, then staring was probably not a productive approach to figuring it out. :-)
17:39:42 <ion> Actually, i was grouping the Cont monad with callCC in my mind. Cont itself isn’t that bad.
17:39:51 <dgpratt> shachaf: lol, touche
17:39:59 <shachaf> Anyway, that's (r ->), not (Reader r).
17:40:01 <shachaf> @src ap
17:40:01 <lambdabot> ap = liftM2 id
17:40:04 <shachaf> @src liftM2
17:40:04 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:40:12 <otters> @unpl ap zip tail
17:40:12 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
17:40:29 <shachaf> ap zip tail === do { x1 <- zip; x2 <- tail; return (x1 x2) }
17:40:33 <lispy> But, the function instance of Reader is one of the coolest
17:40:40 <lispy> Even if it takes practice to grok
17:40:46 <otters> oh wait, unpl is useless for (->)
17:40:51 <elliott> i have no idea what lispy is talking about
17:40:51 <shachaf> Where doing "<- function" is the same as "applying that function to the Value".
17:40:53 <elliott> Reader is not a typeclass
17:40:53 <lispy> otters: that is correct :(
17:40:57 <ion> @@ @djinn @type as `asTypeIn` \ap -> ap zip tail
17:40:57 <lambdabot>  Cannot parse command
17:41:04 <otters> I should write a patch :D
17:41:22 <ion> @@ @djinn @type as `asTypeIn` \ap -> ap (undefined :: a -> b -> c) (undefined :: a -> b)
17:41:23 <lambdabot>  Cannot parse command
17:41:54 <ion> @@ @djinn @type as `asTypeIn` \ap -> ap (undefined :: a -> b -> c) -- ffuuu
17:41:55 <lambdabot>  Cannot parse command
17:42:09 <ion> Duh! A stupid typo.
17:42:11 <dgpratt> shachaf: when I've asked in the past if (r ->) has a name, I've been told it was 'reader'
17:42:16 <lispy> elliott: I guess it's called MonadReader in mtl
17:42:22 <shachaf> dgpratt: Oh. I just call it (r ->).
17:42:25 <otters> @pl \x -> zip x (tail x)
17:42:25 <lambdabot> ap zip tail
17:42:42 <shachaf> dgpratt: Anyway, it's trivially @djinn-able, even by hand, unlike a bunch of other monads.
17:42:56 <shachaf> You can work the whole thing out just by the types without thinking or understanding anything.
17:43:18 <ion> @@ @djinn @type ap `asTypeIn` \ap -> ap (undefined :: a -> b -> c) -- hopefully typo-free.
17:43:18 <lambdabot>  f a b c = a c (b c)
17:43:47 * elliott claps
17:43:51 <lispy> ?unmtl Reader ((->) r)
17:43:52 <lambdabot> Plugin `unmtl' failed with: `Reader ((->) r)' is not applied to enough arguments, giving `/\A. (->) r -> A'
17:44:20 <dgpratt> I admit I only have a tenous grasp of what @djinn is good for
17:44:23 <elliott> That's a kind error.
17:45:23 <dgpratt> I read "Theorems for Free" a while back; it would probably benefit me to read it again
17:45:43 <shachaf> dgpratt: @djinn gets a type and gives you a value which has that type.
17:45:50 <shachaf> If it can. Otherwise it tells you it can't.
17:46:30 <elliott> @djinn Int
17:46:31 <lambdabot> Error: Undefined type Int
17:46:35 <elliott> Stupid bot!
17:46:50 * hackagebot friendly-time 0.2 - Print time information in friendly ways  http://hackage.haskell.org/package/friendly-time-0.2 (PatrickBrisbin)
17:47:54 <ion> @djinn a
17:47:55 <lambdabot> -- f cannot be realized.
17:48:36 <lispy> dgpratt: The kind of proofs that djinn can create are a bit trivial...
17:49:12 <dgpratt> lispy: well, they're free, what more do you want? :)
17:49:25 <lispy> a pony!
17:49:30 <sipa> @djinn ((a -> b) -> c -> a -> b -> c
17:49:30 <lambdabot> Cannot parse command
17:49:48 <dgpratt> @faq can Haskell give lispy a pony?
17:49:49 <lambdabot> The answer is: Yes! Haskell can do that.
17:49:54 <lispy> ?djinn ((a -> b) -> c) -> a -> b -> c
17:49:54 <lambdabot> f a _ b = a (\ _ -> b)
17:50:01 <sipa> @djinn ((a -> b) -> c) -> (a -> b) -> c
17:50:02 <lambdabot> f a = a
17:50:18 <shachaf> dgpratt: "Theorems for Free" doesn't refer to @djinn, by the way.
17:50:26 <shachaf> It's more like @free. :-)
17:50:57 <dgpratt> shachaf: I thought @djinn was based on that paper; I'm probably mis-remembering
17:51:27 <byorgey> nope, @djinn is just an intuitionistic theorem prover
17:51:34 <ezyang> Hmm. fd:8: hGetContents: user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:89:3-10)
17:51:39 <byorgey> it has nothing to do with parametricity.
17:51:50 <lispy> I can never remember the syntax for @free
17:51:50 * hackagebot gravatar 0.5.1 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.5.1 (PatrickBrisbin)
17:51:52 * hackagebot friendly-time 0.2.1 - Print time information in friendly ways  http://hackage.haskell.org/package/friendly-time-0.2.1 (PatrickBrisbin)
17:51:54 * hackagebot yesod-comments 0.7 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.7 (PatrickBrisbin)
17:52:08 <shachaf> @free hi :: a -> a
17:52:08 <lambdabot> f . hi = hi . f
17:52:42 <hpc> @free compose :: (b -> c) -> (a -> b) -> (a -> c)
17:52:42 <lambdabot> g . k = p . f => f . q = f1 . h => g . compose k q = compose p f1 . h
17:52:55 <lispy> @free map :: (a -> b) -> [a] -> [b]
17:52:55 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
17:53:25 <lispy> I also seem to have forgotten what $foo means
17:53:31 <lispy> I guess that's Prelude.map?
17:53:35 <hpc> it means... that
17:53:37 <hpc> iirc
17:54:02 <ion> @free map :: (a -> b) -> z a -> a b
17:54:02 <lambdabot> Extra stuff at end of line
17:54:05 <ion> @free map :: (a -> b) -> z a -> z b
17:54:05 <lambdabot> Extra stuff at end of line
17:54:23 <ion> @free map :: (a -> b) -> Maybe a -> Maybe b
17:54:24 <lambdabot> g . h = k . f => $map_Maybe g . map h = map k . $map_Maybe f
17:54:37 <lispy> $map_Maybe == fmap, I guess
17:54:52 <ion> $map* == fmap, i guess
17:54:58 <lispy> Yeah
17:55:04 <hpc> specific uses of fmap, at least
17:55:12 <lispy> I didn't mean that quite as literally as it may have looked :)
17:55:43 <lispy> I wonder why the author chose to use that $ syntax
17:56:24 <hpc> i would suggest checking the source, but...
17:56:28 <zhulikas> is there a way to stop in the middle of fold?
17:56:44 <zhulikas> let's say I only care counting until specific number inside [Int]
17:56:50 * hackagebot posix-filelock 0.1 - Nice wrapper around POSIX fcntl advisory locks  http://hackage.haskell.org/package/posix-filelock-0.1 (StephenWeber)
17:57:20 <zhulikas> oh, maybe takeWhile could do it
17:57:23 <hpc> zhulikas: yes; just don't use the "rest of the list" parameter in the function you give it
17:57:35 <hpc> :t foldr -- lemme try and construct an example
17:57:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:57:52 <ion> > foldr (\x xs -> if x == 42 then x:[-2] else (x:xs)) [-1] [5,6,7,42,8,9,10]
17:57:53 <lambdabot>   [5,6,7,42,-2]
17:58:04 <hpc> yes, that
17:58:29 <lispy> This is also much easier with foldr than foldl
17:58:57 <zhulikas> :t foldr (\x xs -> if x == 42 then x:[-2] else (x:xs)) [-1] [5,6,7,42,8,9,10]
17:58:57 <lambdabot> forall a. (Num a) => [a]
17:59:00 <zhulikas> damn
17:59:05 <zhulikas> aaa ok
17:59:06 <hpc> > foldr (\x sum -> if sum > 100 then x else x + sum) 0 [50, 20, 44, 100000000]
17:59:07 <lambdabot>   114
17:59:19 <zhulikas> b is Num a => [a]
17:59:29 <hpc> > 50 + 20 + 44
17:59:30 <zhulikas> ok, I see. Thanks
17:59:30 <lambdabot>   114
17:59:40 <hpc> huh, i didn't expect that
17:59:53 <hpc> i blame the time
17:59:55 * hpc away
18:00:26 <zhulikas> hmm
18:00:30 * lispy should probably "away" also. There are places to be and mixfix parsers to play with.
18:00:55 <zhulikas> > foldl (+) [1..]
18:00:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
18:00:56 <lambdabot>    arising from a us...
18:01:06 <zhulikas> > foldl (+) 0 [1..]
18:01:15 <lambdabot>   mueval: ExitFailure 1
18:01:16 <lambdabot>  mueval: Prelude.undefined
18:01:32 <zhulikas> > foldr (\x xs -> if x == 42 then x:[-2] else (x:xs)) [-1] [1..]
18:01:35 <zhulikas> ok
18:01:36 <lambdabot>   mueval-core: Time limit exceeded
18:01:40 <zhulikas> so that's definitely not what I need
18:01:49 <zhulikas> because I have infinite list
18:01:57 <zhulikas> I will try to make it with takeWhile
18:02:04 <ezyang> OK, looks like GHC 7.0.3 is buggy. 'Upgrade upgrade'
18:02:11 <zhulikas> > takeWhile (<5) [1..]
18:02:13 <lambdabot>   [1,2,3,4]
18:02:21 <zhulikas> it works with infinite lists
18:04:27 <cwraith> zhulikas: that foldr is terminating, also
18:04:39 <cwraith> zhulikas: lambdabot is just running slow right now
18:04:56 <zhulikas> @hoogle (a -> b -> b) -> (b -> Bool) -> b -> [a]
18:04:58 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
18:04:58 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
18:04:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:05:02 <zhulikas> I need that.
18:05:21 <zhulikas> because takeWhile takes and returns [a]
18:05:34 <elliott> That looks like a fold + a post-procesing step.
18:05:37 <c_wraith> I don't see how that type can do anything except return [] or bottom
18:05:39 <elliott> @hoogle (a -> b -> b) -> b -> [a]
18:05:40 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
18:05:40 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
18:05:40 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
18:05:42 <zhulikas> but I need to return single result from a list and process list until I find my result
18:05:43 <elliott> Oh, wait.
18:05:44 <elliott> That's nonsense.
18:05:49 <elliott> Are you sure you don't mean
18:05:51 <elliott> @hoogle (a -> b -> b) -> b -> [a] -> b
18:05:52 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
18:05:52 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
18:05:52 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:06:07 <zhulikas> I'll explain what I need
18:06:21 <c_wraith> zhulikas: why not just provide the correct type signature?
18:06:30 <zhulikas> how is this incorrect?
18:06:37 <zhulikas> it would do exactly what I need :)
18:06:41 <c_wraith> zhulikas: it has no way to generate values of type a
18:06:49 <c_wraith> zhulikas: so it can only return [] or undefined
18:06:56 <zhulikas> oh man
18:07:00 <zhulikas> sorry, my bad
18:07:22 <miguel> hi to all
18:07:26 <zhulikas> (a -> b -> b) -> (b -> Bool) -> b -> [a] -> b
18:07:28 <zhulikas> more like it
18:07:35 <zhulikas> anyhow, 2mins for explanation
18:08:05 <c_wraith> that looks a lot like foldr with a filter
18:08:15 <zhulikas> hmm, it would be easier to figure it out by looking at the original text
18:08:16 <zhulikas> http://projecteuler.net/problem=112
18:08:23 <zhulikas> now I don't ask for a solution
18:08:24 <c_wraith> or maybe a takeWhile
18:08:49 <Guest11109> i'm i want to use Quickcheck with Winghci is that possible?
18:09:06 <zhulikas> but I want to fold [1..] to some specific value until my value is equal to a function parameter
18:09:49 <c_wraith> zhulikas: I suspect brute force is going to be *way* too slow for this, but let's ignore that for now. (I think the real solution lies in combinatorics)
18:10:03 <zhulikas> right now I fold it to (current number, count of bouncy numbers, percentage between these two numbers)
18:10:13 <zhulikas> and when I reach correct percentage, I want to return that (,,)
18:10:35 <zhulikas> it's not plain brute force
18:10:41 * zhulikas at least used memoization!
18:12:12 <c_wraith> I'd just write the recursive loop directly.
18:12:16 <zhulikas> the problem is that I need to carry these two extra numbers when iterating a list
18:12:42 * BMeph_ detected a problem once he read the word "iterating"... ;)
18:12:49 <zhulikas> oh, man :)
18:13:55 <c_wraith> come to think of it, "I think the real solution lies in combinatorics" is one of the dumbest things I've said today. of course it's combinatorics. The problem is explicitly about counting things.
18:14:16 <Guest11109> anyone can help me, i just want to know if i can run quickCheck on windows usin Wingchi?
18:15:07 <zhulikas> I expect the answer to be quite a big number... so probably need to find smarter ways finding the answer than going all the way to the correct number
18:17:13 <dgpratt> Guest11109: yes
18:17:14 <zhulikas> damn euler, brute force doesn't work on #50 and up ;)
18:17:23 <zhulikas> ok, thanks anyway
18:17:31 <zhulikas> time to sleep
18:17:32 <mauke> zhulikas: that sounds wrong
18:17:40 <mauke> because I've solved a few of those
18:17:42 <zhulikas> what exactly
18:17:53 <ezyang> time to REBUILD THE WORLD (7.0.4-time)
18:18:02 <mauke> I've got euler programs in the 60s and 70s here
18:18:13 <zhulikas> I still think I might solve it with a correct function
18:18:23 <zhulikas> hmm, maybe I can create one
18:18:26 <zhulikas> @src takeWhile
18:18:26 <lambdabot> takeWhile _ []                 =  []
18:18:26 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
18:18:26 <lambdabot>                    | otherwise =  []
18:18:36 <zhulikas> ah yes, of course
18:19:06 <zhulikas> I will make my (a -> b -> b) -> (b -> Bool) -> b -> [a] -> b tomorrow! :))
18:19:52 <elliott> zhulikas: Isn't it just foldr + post-processing step?
18:19:58 * zhulikas is still not sure if it's correct type
18:20:02 <elliott> Wait, no.
18:20:06 <zhulikas> elliott, not post-processing
18:20:39 <zhulikas> but processing while folding and stopping to fold when (b -> Bool) returns True. And works on infinite lists!
18:20:50 <zhulikas> that's how awesome this function will be
18:21:15 <zhulikas> and I bet nobody came up to it because it's useless and things can be done in an easier way
18:22:07 <c_wraith> actually, it just doesn't mean much in the context of foldr
18:22:12 <c_wraith> if you make it a foldl, though
18:22:23 <c_wraith> it becomes scanl with takeWhile
18:22:41 <zhulikas> @hoogle scanl
18:22:41 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
18:22:41 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
18:22:41 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
18:23:02 <c_wraith> > scanl (+) 0 [1..5]
18:23:03 <lambdabot>   [0,1,3,6,10,15]
18:23:37 <zhulikas> almost :)
18:23:49 <zhulikas> I will show you if I will have what to show tomorrow
18:24:18 <zhulikas> actually true, scanl with takeWhile
18:24:20 * BMeph is annoyed that he's solver #112, but cannot find the program for it.
18:24:25 <zhulikas> but instead of returning [a], it should be just a
18:24:38 * BMeph meant that he's solveD #112.
18:24:42 <zhulikas> ah
18:24:56 <zhulikas> well, I lost most of my solutions for the euler problems :|
18:25:01 <Guest11109> how
18:25:07 <zhulikas> never saved them :D
18:25:10 <c_wraith> well.  last on the result of the takeWhile :)
18:25:17 <zhulikas> just piled down to a Main module bottom
18:25:37 <mauke> :t all
18:25:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:26:09 <Guest11109> ???????
18:26:22 <Guest11109> anyone can help me, i just want to know if i can run quickCheck on windows usin Wingchi?
18:26:41 <elliott> Yes, you can.
18:26:52 <Guest11109> how
18:26:53 <dgpratt> Guest11109: do you have QuickCheck installed?
18:26:53 <monochrom> (not just "if", but also "how")
18:27:06 <zhulikas> ok, good night
18:27:08 <elliott> Guest11109: Import QuickCheck, then use the API.
18:27:17 <elliott> Test.QuickCheck is probably the module you want.
18:27:25 <Guest11109> yes
18:28:10 * BMeph apologizes, but he doesn't know any chinese martial arts. Or chinese arts of any sort. Actually, he feels lucky to know some chinese....
18:29:57 <BMeph> I don't recall if I used scanl or iterate, but I remember takeWhile was involved...oh, he left. Never mind then; he can read the logs. :)
18:30:17 <dgpratt> Guest11109, at the prompt> :m +Test.QuickCheck.Test
18:30:43 <Guest11109> ok
18:30:46 <dgpratt> Guest11109: then something like> quickCheck True
18:39:25 <wli> So, what's a good way to learn what's happened in Haskell since the late 90's?
18:39:54 <elliott> "lots"
18:40:08 <elliott> might be easiest to reboot your knowledge from scratch if you're that far out of date
18:40:18 <heatsink> Maybe look at the list of GHC extensions
18:40:22 <wli> Well, at some point I learned monad transformer stacks, and suspect there's a lot more to things now.
18:40:31 <heatsink> since most of what's happened in Haskell since the late 90s is a GHC extension
18:40:36 <elliott> We still have monad transformer stacks! \o/
18:40:39 <heatsink> (aside from the libraries)
18:40:42 <elliott> "Haskell" itself hasn't changed much.
18:41:04 <elliott> It has hierarchical modules and an FFI now, plus PatternGuards and a minor syntactic tweak to match implementations and we dropped n+k patterns.
18:41:10 <wli> Aren't there type families or something? GADT's? Template Haskell?
18:41:20 <elliott> wli: Yep, by "Haskell" I mean "standard Haskell".
18:41:26 <elliott> The report moves at a glacial pace.
18:41:41 <wli> I think I learned pattern guards at some point.
18:42:10 <heatsink> Are you interested in compiler implementation stuff?
18:42:19 <wli> Anything like springschool95.ps for the new language parts?
18:42:41 <wli> heatsink: Probably way too deep. Just the language extensions sound plausible.
18:43:09 <Guest11109> ok....got it thanks a lot for the help
18:43:21 <elliott> wli: The extensions are rather disparate. It might be best to simply pick one that interests you and learn that; then repeat until there's nothing left to learn.
18:43:51 <heatsink> Oleg's type-indexed trees are a good demonstration of type families
18:44:00 <wli> elliott: Hmm, no lists of them?
18:44:08 <elliott> wli: The GHC manual has one :P
18:44:12 <wli> elliott: Or survey papers?
18:44:19 <elliott> There might be.
18:45:51 <heatsink> http://www.haskell.org/haskellwiki/Research_papers/Type_systems depending on what topic you're looking for
18:46:51 <wli> I'm basically shooting for something like getting up to date with C99 after only knowing C90 or something.
18:47:03 <elliott> wli: That would be tricky.
18:47:09 <elliott> A lot more has happened than that.
18:48:42 <wli> I personally probably can't take on the task of defining the task in much more detail than that.
18:48:55 <heatsink> Here's the paper I'd recommend with an example of type families. www.cs.ox.ac.uk/ralf.hinze/publications/GGTries.ps.gz
18:49:15 <wli> Maybe that means I just can't take on what's new in Haskell.
18:49:51 <monochrom> I think you can quickly pick up all the extensions from just the GHC manual
18:50:19 <wli> I'll give it a shot.
18:51:13 <monochrom> on the library and abstraction side, there are Monoid and Applicative. actually Monoid is pretty easy, just group minus requiring inverse
18:51:43 <wli> Applicative is a monad minus join, no?
18:51:50 <elliott> Not quite.
18:51:54 <ezyang> Does anyone know under what circumstances the GHC event manager can be made unhappy by FFI code?
18:51:56 <elliott> A monad minus join would be... Functor + Pointed.
18:52:06 <elliott> Applicative is Functor + pure (return) + (<*>) (ap).
18:52:18 <elliott> pure :: a -> f a; (<*>) :: f (a -> b) -> f a -> f b
18:52:24 <elliott> Importantly, the structure of the effects are static.
18:52:44 <elliott> i.e., you can't, e.g. "print the input", or "only do this effect if this previous result met some criteria".
18:52:51 <mauke> huh. I've just solved euler 112
18:53:01 <mauke> looks like brute force works just fine
18:53:16 <monochrom> yeah, Applicative is "keep the return, liftM, ap parts of Monad"
18:53:32 <mauke> spoilers: http://hpaste.org/66940
18:53:39 <wli> ap is not very intuitive to me.
18:54:02 <elliott> wli: Well, you can think of Applicative like this: it lets you simplify lifting multiple-argument pure functions.
18:54:05 <elliott> For example,
18:54:15 <elliott> do { a <- getLine; b <- getBlah; c <- computeSomeStuff etc; return (foo a b c) }
18:54:16 <elliott> -->
18:54:19 <gienah> ezyang: I think callbacks from C/C++ code to Haskell require operating system threads
18:54:20 <elliott> foo <$> a <*> b <*> c
18:54:25 <elliott> ((<$>) is just another name for fmap.)
18:54:41 <elliott> wli: (Indeed, this is now one of the most idiomatic ways to lift multiple-argument functions.)
18:54:51 <monochrom> um, you want: foo <$> getLine <*> getBlah <*> computeSomeStuff
18:54:55 <elliott> Er, right.
18:54:57 <elliott> Sorry :)
18:55:09 <elliott> wli: Another way to define Applicative is Functor, plus unit :: f (), plus pair :: f a -> f b -> f (a,b).
18:55:29 <elliott> So you can think of it as "Functors where you can combine two computations".
18:55:33 <ezyang> gienah: Are you talking about the forkOS distinction?
18:55:36 <monochrom> ooohhh, that one looks interesting
18:55:42 <zeiris> How do I get a Fractional from an Integer?
18:55:53 <monochrom> fromIntegral will do
18:55:55 <mauke> zeiris: fromInteger
18:55:57 <wli> zeiris: fromIntegral
18:55:59 <elliott> (Then pure a = fmap (const a) unit; ff <*> fx = fmap (\(f,x) -> f x) (pair ff fx).)
18:56:04 <elliott> monochrom: Which one?
18:56:09 <monochrom> @quote monochrom fromIntegral
18:56:09 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
18:56:25 <fryguybob> Is there a way to get `cabal-dev ghci` to load a specific ghc?
18:56:30 <zeiris> > fromInteger (5::Int) / 2
18:56:31 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
18:56:31 <lambdabot>         against inf...
18:56:32 <monochrom> the formulation of Applicative as Functor, unit, pair
18:56:32 <elliott> fryguybob: --with-ghc=...?
18:56:38 <elliott> monochrom: right
18:56:39 <zeiris> > fromIntegral (5::Int) / 2
18:56:39 <lambdabot>   2.5
18:56:40 <fryguybob> didn't seem to like that
18:56:50 <elliott> wli: Actually, the easiest way to pick up Applicative is just to read the paper.
18:57:08 <elliott> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
18:57:43 <elliott> Meh, is that down?
18:58:13 <monochrom> not responding to me either
18:58:24 <gienah> ezyang: sort of yes, I'm not real sure about it, I think if there are lots Haskell threads using callbacks to FFI code, then the need for operating system threads is more heavy weight than if lightweight haskell threads could be used (if it wasn't using FFI code)
18:58:52 <ezyang> Yeah, that's not what I'm referring to.
18:58:54 <elliott> Here: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.22
18:58:56 <elliott> It has a download link.
18:58:57 <wli> There's a polytypic extension in ghc? (reading Hinze's trie paper)
18:59:00 <elliott> wli: ^
18:59:55 <monochrom> I don't think there is a polytypic extension in ghc
19:00:26 <ezyang> My question is something like, if I have C code that calls bind/listen, will this interfere with the GHC event manager?
19:01:07 <mauke> it may block the haskell runtime
19:01:35 <ezyang> I don't really care about that.
19:02:02 <JoeyA> ezyang: If your program is compiled with -threaded and you use a safe FFI call, it'll only block the thread calling those.
19:02:06 <gienah> ezyang: which would need operating system threads to call the C code to avoid blocking the other haskell threads (but it seems you don't care about that anyway)
19:02:08 <heatsink> Type families work by induction on type expressions, wli
19:02:10 <elliott> ezyang: Should avoid any blocking if you do it in another thread?
19:02:11 <JoeyA> (block the OS thread, that is)
19:02:37 <JoeyA> By OS thread, I mean one of those scary uses-8-MB-of-address-space things.
19:02:41 <ezyang> Like, blocking is not my problem: GHC's RTS keeling over and dieing is what I'm worrying about right now...
19:02:52 <elliott> ezyang: Should be fine as long as it's a safe call.
19:03:16 <mauke> elliott: how does it break unsafe imports?
19:03:26 <elliott> ...huh?
19:03:28 <ezyang> OK, sounds like a boog
19:03:33 <elliott> I am talking about safe vs. unsafe FFI calls.
19:03:38 <mauke> yes
19:03:38 <elliott> FFI imports, I mean.
19:03:44 <mauke> so am I
19:03:45 <elliott> mauke: unsafe imports aren't meant to block.
19:03:55 <elliott> That's one of the things you're promising they won't do when making an unsafe import.
19:04:03 <elliott> It won't block for long and it won't call back into Haskell.
19:04:36 <monochrom> if you use unsafe, I think the worst is still just blocking. so, I don't think there is interference.
19:04:43 <mauke> elliott: I don't see that in the FFI spec
19:04:53 <elliott> mauke: I'm talking about GHC. I forget where I read it.
19:04:57 <ezyang> How about if my external C uses pthreads?
19:05:47 <monochrom> I have done that. there is still no problem.
19:05:59 <ezyang> Hm :-(
19:06:02 <morty_cas> @pl (\f g h -> (\x -> h (f x) (g x)))
19:06:02 <lambdabot> flip . (ap .) . flip (.)
19:06:07 <gienah> ezyang: maybe you could try to obtain a C level stack trace if its crashing
19:06:18 <ezyang> Maybe I should try 7.2. But that's annoying because I have to rebuild the universe sans platform
19:06:32 <ezyang> gienah: the error is this /dev/null: hClose: user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:83:3-10)
19:06:39 <ezyang> I don't know why it thinks its /dev/null...
19:06:50 <monochrom> have you seen my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml ? may answer some of your questions
19:07:08 <elliott> ezyang: 7.2?
19:07:15 <elliott> 7.4.1 is the latest. Or are you using 7.4.1?
19:07:30 <notthemessiah> Anyone have experience with Data.Array? I can't figure out how to get the type right with Prelude Data.Array.IArray> listArray (1,24) ([1..24])?
19:07:43 <ezyang> I'm on 7.0 8)
19:07:45 <mauke> > listArray (1,24) [1..24]
19:07:46 <morty_cas> @pl (\h -> (\f g -> (\x -> h (f x) (g x) )))
19:07:48 <lambdabot> liftM2
19:07:50 <lambdabot>   array (1,24) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)...
19:07:54 <ezyang> :t listArray
19:07:55 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
19:08:02 <mauke> notthemessiah: which type?
19:08:33 <wut> can someone please help me identify the types here: http://pastebin.com/KZ7cdy2Q
19:08:35 <mauke> The paste KZ7cdy2Q has been copied to http://hpaste.org/66941
19:08:38 <gienah> ezyang: maybe strace and looking at the threads, open, close and looking at the handle number
19:09:15 <mauke> wut: that looks like several syntax errors
19:09:30 <notthemessiah> mauke: for some reason GHCI is spitting out that there's no instance for (IArray a0 Int)
19:09:56 <mauke> notthemessiah: ah, you're using the generic listArray
19:09:58 <wut> mauke: but ignoring the syntax errors, what should the types of those two be?
19:10:02 <mauke> notthemessiah: what result type do you want?
19:10:11 <mauke> wut: why don't you ask ghci?
19:10:21 <fmap> :t getLine
19:10:25 <lambdabot> IO String
19:10:27 <fmap> :t putStrLn
19:10:31 <lambdabot> String -> IO ()
19:10:34 <notthemessiah> oh, just an Array or UArray
19:10:48 <notthemessiah> where the a0 should be
19:10:49 <wut> damn, we have ghci in here?
19:10:53 <ezyang> ohhhhh
19:10:56 <ezyang> I see what the bug is
19:11:05 <gienah> ezyang: yah!
19:11:22 <mauke> notthemessiah: for Array you can just use Data.Array instead of IArray
19:11:24 <ezyang> but I need to test, because sometimes I see wrong
19:11:32 <ezyang> nope, wasn't it :-(
19:11:34 <wut> :t 1
19:11:35 <lambdabot> forall t. (Num t) => t
19:12:26 <notthemessiah> mauke: thanks that works
19:13:25 <wut> :t interact
19:13:25 <lambdabot> (String -> String) -> IO ()
19:13:31 <ezyang> I wonder if the C fd manipulation and the HAskell fd manipulation is racing
19:15:33 <gienah> ezyang: (me has no idea, wild guess anyway) I wonder if ghc garbage collected a handle that the C code was using?
19:16:54 <ezyang> Nope, they're not sharing handles
19:18:28 <ezyang> Is there a way to hide re-exported modules?
19:18:39 <gienah> ezyang: maybe threadscope might give some hints or more understanding of what the program is doing
19:18:58 <ezyang> Hmm, I wonder if I can get threadscope to install now.
19:19:24 <ezyang> gtk2hs is always so finicky
19:24:25 * wli takes a stab at cabal install threadscope
19:26:22 <ezyang> ...well, forcing ensureIOManagerIsRunning appears to have fixed it. *shrug*
19:29:26 <gienah> ezyang: neat!
19:39:02 <mysticc> ezyang: What is the problem
19:39:40 <ezyang> mysticc: event manager doesn't seem to get loaded in some circumstances
19:49:07 <ezyang> copyBytes dest src, not src dest. How silly.
19:49:17 <elliott> ezyang: Welcome to C!
19:49:27 <cwl> The GADT wiki introduces an example of *EDSL* for simple arithmetical expressions http://en.wikibooks.org/wiki/Haskell/GADT
19:49:42 <cwl> Why is it an *EDSL*
19:49:59 <elliott> Because it's an embedded domain-specific language.
19:50:06 <cwl> It is a normal program in my eye
19:50:09 <ezyang> embedded cuz it's in Haskell
19:50:13 <elliott> EDSLs are normal prorgams.
19:50:18 <elliott> That's basically what defines them.
19:50:19 <elliott> *programs
19:50:24 <elliott> In this case, the DSL is the arithmetic expression type.
19:50:30 <cwl> what kind of normal program is a DSL
19:51:02 <geekosaur> the distinction is that a DSL could be any language, not necessarily the host language.  regexes are a good example of a DSL
19:51:11 <danharaj> is IEEE 754 equality non-transitive?
19:51:12 <geekosaur> embedded in random languages.
19:51:18 <geekosaur> an EDSL is in the syntax of the host language
19:51:30 <cwl> *DSL* is mentioned a lot by functional language community
19:52:20 <elliott> cwl: An EDSL is a sublanguage embedded in the language your program is in.
19:52:22 <elliott> It is not a precise term.
19:52:33 <elliott> In fact, basically all Haskell programs use EDSLs (e.g. IO is an EDSL).
19:53:50 <cwl> elliott: how to judge what is EDSL what isn't?
19:53:55 <zzing> Why is map specifically for lists and not generalized for any container where the author wants to implement??
19:54:01 <wli1> Darwin's unhappy with threadscope's C library dependencies.
19:54:09 <wli1> zzing: It is generalized cf. fmap
19:54:25 <elliott> cwl: There is no formal procedure.
19:54:37 <elliott> cwl: If there's some kind of mini-language being defined in the program, it's an EDSL.
19:54:48 <elliott> zzing: historical reasons
19:55:20 <wli> (Annoying ones at that; I'd say H98 damage.)
19:55:44 <dmwit> danharaj: yes
19:55:50 <cwl> elliott: In that example, where is the mini-language?
19:56:02 <elliott> cwl: Expr is the EDSL.
19:56:07 <dmwit> danharaj: For basically all good properties P, IEEE 754 is not P.
19:56:28 <elliott> cwl: It is an embedded (defined and used in the Haskell language itself, rather than having a separate parser, etc.), domain-specific (for the purpose of simple expression evaluation) language.
19:56:41 <zzing> @src fmap
19:56:41 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:56:44 <elliott> eval is its interpreter.
19:56:46 <cwl> elliott: I have to build up intuition
19:56:48 <geekosaur> cwl, you could say a DSL is a programming style
19:56:52 <zzing> :t fmap
19:56:53 <elliott> zzing: class Functor f where fmap :: (a -> b) -> f a -> f b
19:56:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:56:58 <dmwit> zzing: You have to tell which instance you want the source for.
19:57:00 <dmwit> ?src fmap []
19:57:01 <lambdabot> Source not found. That's something I cannot allow to happen.
19:57:03 <wli> danharaj: For an opposing view there's why Java floating point hurts everyone everywhere all the time, but anyhow.
19:57:04 <dmwit> ?src [] fmap
19:57:04 <lambdabot> fmap = map
19:57:20 <zzing> I am not sure how that compares to map
19:57:20 <glguy> zzing: fmap has one implementation per instance
19:57:22 <zzing> :t map
19:57:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:57:32 <wut> what is the space and time complexity of foldr (+) 0 xs and foldl (+) 0 xs?
19:57:39 <elliott> zzing: "Compares"?
19:57:52 <dmwit> wut: Depends on what type 0 has, and what you ask about the fold.
19:57:52 <wut> is it O(1), O(n) for both?
19:57:53 <zzing> generalizes
19:57:53 <cwl> geekosaur: I cannot recognize the programming style
19:57:55 <glguy> zzing: map is how you implement fmap for []
19:58:10 <wut> dmwit: let's assume they are integers and we are just summing them
19:58:10 <elliott> cwl: You don't have to call things EDSLs.
19:58:31 <elliott> But what an EDSL is is fully-encapsulated by the name.
19:58:38 <wut> because of lazyness they are both O(1), O(n) for space and time, respectively?
19:58:46 <dmwit> wut: for Integer, they are both O(n) in time and O(n) is space
19:59:09 <dmwit> wut: (though "just summing them" is not an answer to "what you ask about the fold")
19:59:21 <zzing> Is there anything that I could generalize this with a typeclass? > innerProduct (Vec3 x1 x2 x3) (Vec3 y1 y2 y3) outer inner =    outer (x1 `inner` y1) (x2 `inner` y2) (x3 `inner` y3)   wwhere Vec3 is something like  data Vec3 a = Vec3 a a a   (where a is often a float or double)
19:59:49 <wut> dmwit: oh, probably "take 1000 $ ..."
20:00:02 <wut> err
20:00:05 <wut> nevermind, that doesn't make sense
20:00:08 <dmwit> right
20:00:16 <dmwit> perhaps "print $ ..."
20:00:23 <dmwit> Then the answer I said is true.
20:00:34 <dmwit> compare "const 0 $ ...", where the answer I said is false.
20:00:58 <JoeyA> @remember dmwit For basically all good properties P, IEEE 754 is not P.
20:00:58 <lambdabot> It is forever etched in my memory.
20:00:59 <dmwit> However, the GHC optimizer will almost certainly turn both of those into foldl' (+) 0 xs, which is O(n) in time and O(1) in space.
20:01:24 <shachaf> The GHC optimizer will turn foldr (+) 0 into foldl' (+) 0?
20:01:33 <dmwit> wouldn't surprise me
20:01:40 <dmwit> at type Integer
20:01:44 <ion> % unicode 'for basically all'
20:01:46 <ion> %
20:01:48 <ion> :-(
20:02:30 <elliott> shachaf: I bet there's a RULE for it.
20:03:04 <shachaf> Doesn't seem to be happening here.
20:03:08 <shachaf> I get a stack overflow.
20:03:18 <shachaf> @quote is.coming.from
20:03:18 <lambdabot> copumpkin says: <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
20:03:25 <ion> ∀̰
20:03:29 <shachaf> elliott: It was attributed to copumpkin, not kmc!
20:03:33 <shachaf> That explains it.
20:04:11 <dmwit> Me, too.
20:04:18 <wut> @quote bill.gates
20:04:18 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:04:25 <wut> @quote php
20:04:25 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
20:04:42 <dmwit> wut: I take it back. The GHC optimizer isn't as amazing as I thought.
20:04:49 <dmwit> (Though it's still pretty amazing.)
20:05:13 <wut> is lambdabot written in haskell?
20:05:17 <dmwit> yes
20:06:04 <zzing> Would an inner product (eg. dot product) be simply an map followed by a fold?
20:06:42 <dmwit> A zip, I would think.
20:06:56 <cwl> Is there any map implementation which agnostic value?  I might see one in google search's result, it seems make use of GADT, I forget.
20:07:15 <cwl> Map
20:07:24 <danharaj> > NaN == NaN
20:07:25 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
20:07:29 <dmwit> cwl: I don't understand the question.
20:07:38 <dmwit> > (1/0) - (1/0) == (1/0) - (1/0)
20:07:40 <lambdabot>   False
20:07:54 <geekosaur> sounds like a Data.Map that has an untyped/polymorphic value
20:07:56 <mauke> > join (==) . join (/) $ 0
20:07:57 <dmwit> ?let infty = 1/0
20:07:59 <cwl> dmwit: Map <Key, Object>
20:08:00 <danharaj> On what set is the equality actually an equivalence relation?
20:08:00 <lambdabot>   mueval-core: Time limit exceeded
20:08:00 <lambdabot>  Defined.
20:08:01 <monochrom> inner product seems to be zipWith and fold
20:08:03 <geekosaur> which, well, this is Haskell, that's not a thing so much
20:08:06 <dmwit> ?let nan = infty - infty
20:08:08 <lambdabot>  Defined.
20:08:10 <glguy> cwl: Data.Map provides Map
20:08:12 <dmwit> > join (==) nan
20:08:13 <zzing> Is there a generalization of fold like fmap generalizes map?
20:08:15 <lambdabot>   False
20:08:16 <cwl> dmwit: a Map contains any type of Value
20:08:16 <mauke> > join (==) . join (/) $ 0
20:08:18 <lambdabot>   False
20:08:35 <glguy> zzing: Data.Foldable
20:08:46 <zzing> zipWith looks nice
20:08:49 <dmwit> cwl: Yes, we have a Map.
20:09:02 <cwl> glguy: Data.Map can store only one type of Value
20:09:13 <ion> > join (==) . join (==) . join (/) $ 0
20:09:14 <lambdabot>   True
20:09:15 <geekosaur> if you want Perl, use Perl
20:09:24 <dmwit> cwl: Store something of type Dynamic. But don't, really.
20:09:44 <geekosaur> if you want Haskell. use Haskell.  strog typing and "can store any kindof Value" are contradictory
20:09:55 <zzing> Does this sound right? dot a b = sum $ zipWith (*) a b
20:09:57 <geekosaur> (well, you can do it, just ugly)
20:10:03 <glguy> cwl: Do the values you are storing have anything in common?
20:10:05 <cwl> dmwit: but sometimes we need it, for example, we want a server-side session
20:10:22 <mauke> cwl: huh?
20:10:22 <dibblego> zzing: FYI zipWith generalises to liftA2
20:10:23 <shachaf> "strong typing" is a pretty meaningless term. :-)
20:10:25 <glguy> cwl: create a type of server-side sessions and store that
20:10:39 <dmwit> cwl: Why would that require dynamic typing?
20:10:43 <dmwit> zzing: yes
20:11:39 <elliott> cwl: perhaps see
20:11:44 <zzing> Curious: Has anyone taken a haskell compiler and redesigned the libraries?
20:11:45 <ion> dibblego: Not with the standard [] instance it doesn’t.
20:11:47 <elliott> @hackage vault
20:11:48 <lambdabot> http://hackage.haskell.org/package/vault
20:12:10 <glguy> zzing: maybe rephrase that question?
20:12:59 <zzing> glguy, observation prelude (et al) have many things that generalize other things and as mentioned above some is historical. Has anyone just thrown all that out and redid the library.
20:13:25 <glguy> zzing: Yes, people have come up with alternative preludes
20:13:30 <dmwit> There are a few alternative Preludes available on Hackage.
20:13:55 <zzing> Interesting.
20:13:59 <glguy> zzing: There is a language extension "NoImplicitPrelude" that is worth knowing about if you find yourself going down that path
20:14:13 <zzing> glguy, appreciated.
20:14:24 <zzing> Might be educational at some point.
20:14:53 <zzing> Also, if I wanted to make an opaque data type that is implemented in C behind the scenes, is there any resources that would be worth my while to look into?
20:15:18 <geekosaur> FFI / the Foreign hierarchy
20:15:40 <geekosaur> see in particular Ptr (or ForeignPtr if you need a finalizer)
20:16:09 <mauke> @where ffi
20:16:09 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:19:22 <zzing> Can the FFI interface be very efficient? (low over head in my case)
20:20:18 <geekosaur> that depends on what you're doing with it
20:20:56 <zzing> Primarily it will be to interact with SSE4 instructions
20:21:19 <zzing> The opaque datatype will implement that datatypes needed away from haskell
20:21:39 <elliott> someone should update that ffi link
20:21:49 <elliott> since it's in H2010 now...
20:22:02 <geekosaur> I suspect that would largely be low overhead, since they should be largely pure
20:22:21 <elliott> one ffi call per instruction sounds slow
20:22:28 <ezyang> zzing: That won't work
20:22:31 <elliott> unless they're doing lots
20:22:34 <ezyang> You need to build that into the codegenerator.
20:22:47 <geekosaur> that was what I was trying to figure out how to phrase
20:23:06 <geekosaur> primops if necessary, code generator
20:24:38 <Enigmagic> geekosaur: you want something that can be optimized together, ffi even with primops won't (easily) allow for that
20:24:38 <tgeeky__> haskell98? that's so (2012 - 1998) years ago
20:24:52 <wli> I'm at a loss as to what to do with type families.
20:25:30 <mauke> @where+ ffi http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
20:25:30 <lambdabot> It is forever etched in my memory.
20:25:50 <geekosaur> Enigmagic, I was perhaps unclear there, primops would be part of the codegen solution, not an alternative to it
20:25:55 <elliott> mauke++
20:26:01 <zzing> thank you all
20:26:12 <shachaf> @wiki FFI
20:26:12 <lambdabot> http://www.haskell.org/haskellwiki/FFI
20:26:18 <shachaf> Maybe it should link to that?
20:26:28 <elliott> why not both
20:26:41 <elliott> huh
20:26:46 <elliott> that wasn't a netsplit
20:26:48 <geekosaur> was going more for that a codegen-only solution is less intrusive on the compiler guts
20:27:59 <Enigmagic> geekosaur: what are you trying to build?
20:28:00 <wli>  I see vaguely what type families are, but not how to use them.
20:28:17 <geekosaur> huh?
20:28:21 <geekosaur> I was responding to someone else
20:28:24 <wli> Checking http://www.haskell.org/haskellwiki/GHC/Indexed_types
20:28:27 <Enigmagic> geekosaur: oh, i missed that :_)
20:28:32 * Enigmagic just sat down
20:29:19 <Enigmagic> doh i totally responded to the wrong person :P
20:29:58 <copumpkin> wli: they're functions (that can pattern match, openly) at the type level
20:31:12 <wli> So you could have hash functions implemented differently for strings and machine integers?
20:31:45 <wli> Sounds a little like typeclasses or some extension thereof.
20:31:48 <heatsink> You can relate types in a non-structural way
20:32:25 <heatsink> It's only useful when combined with type classes
20:33:38 <heatsink> For example, a normal algebraic array type has exactly the same implementation for every data type
20:34:20 <wli> Okay, sounds like a good place to start.
20:35:16 <shachaf> Well, not "only" useful.
20:35:17 <heatsink> Indexed array types are one of the uses of type families.
20:36:02 <heatsink> I forgot what the array type was called
20:36:06 <heatsink> but let's say it's A
20:36:14 <mauke> @where dph
20:36:14 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:36:29 <heatsink> The data type A Word8 is an array of bytes
20:37:04 <heatsink> The data type A (a, b) --that is, an array of tuples-- is (A a, A b) -- that is, a tuple containing two arrays
20:38:10 <heatsink> Which is nice for efficiency reasons
20:38:55 <heatsink> You need indexed types to say, "if the argument type is a tuple, then do this; if it's a Word8, then do that"
20:44:36 <wli> I think I'm having a general failure of imagination.
20:44:55 <wli> Maybe I'll just try to use some Haskell libs.
20:44:57 <shachaf> tuples++
20:46:58 <wli> They're bound to introduce new Haskell stuff along the way.
20:51:40 <nyingen> so let's say I'm using a FFI library, for example for SDL, that exposes some raw data as a MArray, and the elements in that array are members of Storable
20:51:59 <nyingen> is there some standard way to get a Ptr to that data, or is it only possible if the library exposes a function that does so
20:52:24 <mauke> :t alloca
20:52:25 <lambdabot> Not in scope: `alloca'
20:52:29 * wli snags gtfs and curl.
20:52:37 <mauke> @hoogle alloca
20:52:37 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
20:52:37 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
20:52:37 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
20:52:38 <iFire_> How difficult is it to have a c++ abi for clang?
20:52:48 <mauke> @hoogle with
20:52:49 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
20:52:49 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
20:52:49 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
20:52:50 <iFire_> before I embark on this problem
20:53:49 <nyingen> mauke: So I would use such a function on the first element of the MArray?
20:56:54 <elliott> hSDL exposes ptra
20:56:58 <elliott> ptrs
20:57:19 <wli> http://www.mta.info/developers/data/mnr/google_transit.zip needs at least curl, zip-archive, and gtfs to interpret usefully.
20:57:59 <elliott> HTTP and http-conduit are mre commn than curl
20:58:01 <elliott> *more
20:58:14 <wli> elliott: Okay, grabbing those.
20:59:45 <nyingen> elliott: is that a different binding than the one called 'SDL' on hackage?
20:59:50 <elliott> nyingen: no
20:59:56 <elliott> wli: you already have HTTP
21:00:03 <nyingen> elliott: where are you seeing this?
21:00:10 <elliott> cabal-install depends on it
21:00:26 <wli> elliott: I do? cabal installing it downloaded and compiled something.
21:00:44 <wli> Hmm, I guess calendrics may also come up.
21:00:46 <elliott> nyingen: bit busy, i'll look in a minute (i'e done it before)
21:00:55 <elliott> wli: probably upgraded i
21:01:00 <elliott> t
21:01:11 <nyingen> elliott: oh, derp. I don't mean SDL, I mean Cairo
21:01:24 <nyingen> I'm trying to marshall pixel data from Cairo to SDL
21:01:38 <nyingen> it's easy in C, but haskell's array zoo is very confusing on these matters
21:09:24 <kizzo> Can someone help me solve this: http://pastebin.com/ueBimyMz
21:09:26 <mauke> The paste ueBimyMz has been copied to http://hpaste.org/66943
21:09:39 <elliott> nyingen: ah
21:09:49 <kizzo> I'm not sure of what to add (and why).
21:10:08 <mauke> kizzo: did you write this code?
21:10:20 <kizzo> I'm thinking maybe replace "x"  with "(x :: SomeException)"
21:10:22 <kizzo> mauke: Yes.
21:10:48 <wli> I guess I might need something for geographic stuff.
21:10:49 <mauke> trivial solution: don't import Control.Exception.catch
21:10:56 <mauke> :t Prelude.catch
21:10:57 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:11:02 <elliott> that's a bad solution
21:11:05 <elliott> it won't even catch async exceptions
21:11:14 <mauke> that may be a good thing
21:11:38 * elliott doesn't think using the old exceptions system is ever a good thing :p
21:11:44 <kizzo> mauke: My compiler gave me a warning saying not to use Prelude's catch anymore, and instead to use Control.Exception's.
21:11:54 <mauke> oh, great
21:11:54 <kizzo> A depreciation warning, more like.
21:12:07 <mauke> pfft, it's in the standard
21:12:17 <elliott> so are head and tail
21:12:27 <mauke> and they're not going anywhere
21:12:30 <elliott> kizzo: but yes (:: SomeException) should do it
21:12:38 <elliott> mauke: yep, so unfortunately /they/ don't have warnings
21:13:02 <mauke> kizzo: `catch` (\SomeException{} -> putStrLn "blah")
21:15:33 <augur> sup peeps
21:15:39 <augur> teach me something cool
21:17:51 <hpaste_> kizzo pasted “catch” at http://hpaste.org/66944
21:18:31 <mauke> …
21:19:24 <wli> At some point I'll get to where I can try to do some kind of graph algorithm.
21:19:37 <kizzo> Yeah I'm not sure what is the problem there.
21:19:49 <kizzo> http://hpaste.org/66944
21:19:50 <elliott> kizzo: the problem is that you annotated some random other variable as being a SomeException.
21:19:53 <nyingen> mauke: can you elaborate on the meaning of your earlier hoogling for Storable/Array stuff?
21:20:08 <mauke> kizzo: and you ignored my advice
21:20:11 <elliott> like mauke said, `C.catch` (\SomeException{} -> putStrLn "Connection forced closed.")
21:20:24 <nyingen> mauke: I don't see how that stuff applies to my issue of the Cairo binding exposing a MArray of pixel data, and needing to get a Ptr to that array to pass to SDL
21:20:34 <mauke> nyingen: me neither
21:20:44 <nyingen> ok
21:21:44 <NemesisD> anyone know of any good tutorials on arrows. do people still use those
21:21:54 <elliott> igotnolegs: you have N Olegs?!
21:22:07 <elliott> how do you keep the place from exploding?
21:22:18 <parcs`> NemesisD: the paper is pretty accessible
21:22:23 <elliott> NemesisD: they're falling out of style
21:23:00 <NemesisD> elliott: in favor of what?
21:23:00 <heatsink> Did too many people take them to the knee?
21:23:06 <parcs`> wait, is arrow truly applicative + category?
21:23:51 <elliott> NemesisD: Category + Applicative, in part
21:23:57 <wut> @undo do { x <- m; do { y <- f x; g y } }
21:23:58 <lambdabot> m >>= \ x -> f x >>= \ y -> g y
21:24:00 <elliott> or just Applicative in general
21:24:14 <elliott> parcs`: modulo some laws, yes
21:24:23 <parcs`> are the laws significant?
21:24:38 <kizzo> With "`C.catch` (\SomeException{} -> putStrLn "Connection forced closed.")" I got "Not in scope: data constructor `SomeException'"
21:24:46 <kizzo> But with "`catch` (\(x :: SomeException) -> putStrLn "Connection forced closed.")" everything was fine.
21:24:52 <wut> @do m >>= \ x -> f x >>= \ y -> g y
21:24:52 <lambdabot> do { x <- m; y <- f x; g y}
21:24:53 <kizzo> [ thanks a lot for the help ]
21:25:12 <NemesisD> hmm, im just looking for some interesting library or topic to learn in haskell
21:25:12 <elliott> hmm, I thought SomeException's constructor was exported
21:25:41 <kizzo> Ah ok.
21:25:49 <kizzo> All I had at the top was "import Control.Exception (catch, SomeException)"
21:27:04 <elliott> right, you didn't import the constructor
21:36:23 <wut> :m putStrLn
21:36:52 <_Autumn> hi everyone, i'm having a problem with redirecting standard input with a haskell program
21:37:00 <wut> :t putStrLn
21:37:00 <_Autumn> when i execute `runghc program.hs < text`
21:37:01 <lambdabot> String -> IO ()
21:37:03 <wut> :t getLine
21:37:04 <lambdabot> IO String
21:37:13 <_Autumn> i get `program.hs: Prelude.read: no parse`
21:37:21 <_Autumn> i'm using getLine in the program
21:37:32 <_Autumn> it works fine when stdin is the keyboard
21:37:43 <wut> oh, i got that error before
21:37:53 <wut> i forget what i did to fix it though :\
21:37:59 <_Autumn> :(
21:38:05 <wut> i think it might have something to do with reading in values
21:38:14 <wut> it doesn't know what type to read in
21:38:16 <_Autumn> i changed the text in the file to have enclosing quotes
21:38:26 <_Autumn> but it didn't change anything
21:38:34 <wut> yeah
21:38:47 <_Autumn> if i try putting a type signature :: String
21:38:51 <_Autumn> on the getLine
21:38:53 <_Autumn> would that change?
21:39:05 <wut> maybe
21:39:11 * wut is a haskell newbie
21:40:30 <wut> are you using read anywhere?
21:40:47 <_Autumn> hang on
21:40:53 <_Autumn> yeah...i just realised
21:40:57 <_Autumn> my file wasn't the correct format
21:41:00 <_Autumn> how embarrasing
21:41:02 <_Autumn> >.<
21:41:03 <wut> D:
21:42:00 <_Autumn> als
21:42:02 <_Autumn> alas*
21:42:02 <_Autumn> thanks!
22:17:54 <hayashi> Has there ever been a code style popularised for Haskell?  I've noticed a few common things like putting commas after newlines in multiple-line lists, but haven't seen anything like the C indent religions of old when it comes to where to newline and how much whitespace to use in between things
22:18:31 <shachaf> Oh no, not enough religious arguments in #haskell?!
22:18:41 <nyingen> let's argue about commas after newlines
22:18:48 <nyingen> which are the mark of a shrivelled brain
22:20:30 <hayashi> personally I think they look ugly as all get out put over there, but it seems (seemed) like everyone else does it so I've caved in
22:23:11 <parcs`> hayashi: do whatever looks best
22:35:15 <glguy> Is there any way in quick check to characterize random inputs so that quick check will run until it actually covers a few different cases?
22:35:54 <lispy> glguy: Yeah, but I'd have to re-read the docs
22:36:16 <glguy> I wanted to show that two functions return the same value :: Bool
22:36:22 <glguy> but they almost always return False
22:36:34 <glguy> I want to run it until at least a few "True" cases are accidentally reached
22:37:12 <lispy> You can either use a custom generator or put constraints on the generated values.  I think there is every a way to say how big the pool of sampled values should be
22:37:43 <lispy> I think that a custom generator is probably your best bet
22:38:56 <glguy> Test.QuickCheck.Property.cover looks relevant :)
22:40:07 <ghorn_> anybody know what the status of HODE (open dynamics engine bindings) is?
22:42:00 <glguy> +++ OK, passed 100 tests (only 3% Matched; not 50%).
22:42:14 <glguy> bah, it knows it didn't try hard enough but didn't bother trying more
22:42:49 <lispy> glguy: I think that issue is discussed in the original QC paper or the manual
22:43:04 <lispy> My memory is foggy
22:50:14 <samd_> Can anyone recommend a good book or online resource for Haskell? I don't have much functional programming experience, but I'm interested in learning.
22:51:19 <shachaf> samd_: LYAH is often recommended around here.
22:51:23 <shachaf> @where lyah
22:51:23 <lambdabot> http://www.learnyouahaskell.com/
22:51:40 <shachaf> samd_: If you're OK with a physical book, I'd recommend Hutton's _Programming in Haskell_ as a good introduction.
22:51:43 <shachaf> Also see the FAQ:
22:51:45 <shachaf> @where faq
22:51:45 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:51:51 <samd_> Thank you!
22:53:19 <samd_> Wow. LYAH looks impressive. Thanks again shachaf and lambdabot.
22:55:07 <glguy> @bot
22:55:08 <lambdabot> :)
22:55:27 <nyingen> @quote
22:55:27 <lambdabot> nikki93 says: After a bit more delving, I've come to see the power of haskell at last. You have to treat functions like crap, forget about the C idea that they're 'big things'. They're not.
23:00:27 <nyingen> @quote
23:00:27 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:00:29 <nyingen> @quote
23:00:29 <lambdabot> AshleyYakeley says: If anyone gives you any lip, ask them how to find the square-root of a string. Everything else follows on from that.
23:01:49 <nyingen> jag förstår inte
23:25:26 <mysticc> What is the status of vector-bytestring ?
23:25:35 <nyingen> it's people
23:25:40 <nyingen> vector-bytestring is people
23:25:57 <mysticc> nyingen: ??
23:26:35 <nyingen> sorry, I thought you said 'secret' not 'status'
23:27:35 <mysticc> Is it any good ..
23:28:00 <mysticc> @quote
23:28:00 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:28:03 <mysticc> @quote
23:28:03 <lambdabot> shergill says: silver bullets don't respect eta equivalency. it needs to be made of silver, and not simply *act* like one :P
23:28:26 <mysticc> @quote
23:28:26 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
23:28:44 <mysticc> @quote
23:28:44 <lambdabot> mama says: The time to sleep!
23:28:48 <mysticc> @quote
23:28:48 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
23:28:58 <mysticc> @quote
23:28:58 <lambdabot> butt says: i want a cat fuck
23:29:49 <mysticc> @quote
23:29:50 <lambdabot> camccann says: I think it's more just that Haskell occasionally beats up category theorists and steals their l̶u̶n̶c̶h̶ ̶m̶o̶n̶e̶y̶ useful terminology.
23:29:57 <NemesisD> anyone know of some interesting libraries/topics i can look into more in haskell? i've recently played around with chans, io refs and some of the other parallel primatives
23:30:39 <mysticc> NemesisD: stm ?
23:30:56 <hayashi> @pl \f g h (x,y) -> ( f x ) `h` ( g y )
23:30:56 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip . ((flip . ((.) .)) .) . flip (.)
23:31:02 * hayashi passes
23:31:19 <mysticc> hayashi: :D
23:31:27 <hayashi> that's an impressive amount of compositions though
23:31:43 <mysticc> Can you do it by hand
23:32:11 <mysticc> @quote
23:32:11 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
23:32:14 <hayashi> I'm currently very bad at deriving pointfree combinators from lambda expressions =(
23:33:10 <mysticc> hayashi: that is lambdabot's food .. you dont need to eat it
23:33:44 <mysticc> @quote
23:33:44 <lambdabot> Eduard_Munteanu says: * Eduard_Munteanu considers coining "Sufficiently advanced category theory is indistinguishable from trolling" <geheimdienst> @remember Eduard_Munteanu [snip] <geheimdienst> ...
23:33:44 <lambdabot>  coined <Eduard_Munteanu> Aw.. but I paraphrased shachaf on some other stuff. <Eduard_Munteanu> @forget Eduard_Munteanu [snip]
23:33:53 <hayashi> This one's probably going to be a trainwreck too...
23:34:17 <hayashi> if I can express it in a form lambdabot's comfortable with to begin with
23:34:17 <mysticc> @quote
23:34:18 <lambdabot> FunctorSalad says: I think the "asks", "gets" etc family of names is sort of cute, like the program is talking about itself in the third person
23:34:20 <hayashi> @pl \f g h ( a `i` b ) ->  ( f a ) `h` ( g b )
23:34:21 <lambdabot> (line 1, column 12):
23:34:21 <lambdabot> unexpected "`"
23:34:21 <lambdabot> expecting operator or ")"
23:34:27 <hayashi> >_>
23:34:41 <hayashi> you win
23:34:43 <hayashi> @pl \f g h a b ->  ( f a ) `h` ( g b )
23:34:44 <lambdabot> flip . ((flip . ((.) .)) .) . flip (.)
23:34:50 <hayashi> I'd rather not
23:35:24 <mysticc> @quote
23:35:24 <lambdabot> tromp says: > let x = "hello, world" in x \\ nub x
23:35:44 <mysticc> @quote
23:35:44 <lambdabot> ksf says: Confusion is the first step to enlightenment
23:36:16 <hayashi> @pl \f a -> f a a
23:36:17 <lambdabot> join
23:38:36 <hayashi> @pl \f a b c -> a ++ b ++ c
23:38:37 <lambdabot> const ((. (++)) . (.) . (++))
23:42:21 <hayashi> @pl \f x y -> [f x, g y]
23:42:21 <lambdabot> flip flip (return . g) . (((.) . (:)) .)
23:42:41 <hayashi> @pl \(x,y) -> [x,y]
23:42:41 <lambdabot> uncurry ((. return) . (:))
23:42:48 <hayashi> bleh
23:43:34 <nyingen> @quote
23:43:34 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:43:36 <nyingen> @quote
23:43:36 <lambdabot> everbody says: is hackage down?
23:48:16 <hayashi> @pl \fs a -> map (\f -> f a) fs
23:48:17 <lambdabot> flip (map . flip id)
