00:11:14 <mekeor> > let _ = "wouldn't it be nice if _ was just a valid identifier?" in _
00:11:15 <lambdabot>   Pattern syntax in expression context: _
00:11:43 <mekeor> > let __ = "__ works." in __
00:11:43 <lambdabot>   "__ works."
00:13:06 <paddymahoney> anyone located in the Waterloo/ON/Canada area?
00:13:43 <shergill> paddymahoney: to what end?
00:14:37 <paddymahoney> just curious about the local Haskell scene, no immediate plans. I'd like to get more involved in real life conversation.
00:15:21 <shergill> i'm in montreal atm. with plans to move to ontario
00:17:01 <paddymahoney> nice, I have family in the Lachine area. Are you in school?
00:17:52 <Lemmih> mekeor: Then you couldn't do, say, let X a _ _ = y.
00:18:26 <mekeor> Lemmih: oh, that's right‚Ä¶
00:20:23 <Lemmih> Yes, that's right. (:
00:21:33 <shergill> paddymahoney: finished gradschool (masters); took a year off traveling. currently on the lookout for jobs
00:25:22 <ketil> Any idea on how to turn off hlint for ghc-mod and Emacs flymake?  It falsely report things as error, which is visually annoying.
00:26:02 <ketil> For all its glory, ghc-mod seems vastly undocumented...at least within Emacs.
00:27:54 <mekeor> ketil: that's why i removed it afterwards‚Ä¶ it was just annoying‚Ä¶ -- but let me know if you got it working nicely ;)
00:33:00 <ketil> mekeor, I'm simply unable to find *any* information on how to configure this.  Is there a flymake variable?  ghc-something?  Usually, Emacs is pretty good for working out these things...
00:33:12 <ketil> I guess I can just uninstall hlint.
00:33:27 <ketil> GHC is more sensible about what is an error and what is a warning.
00:34:16 * hackagebot authenticate 1.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.2.1 (MichaelSnoyman)
00:34:18 * hackagebot repa 3.1.2.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.2.1 (BenLippmeier)
00:36:13 <ketil> WTF!? Removing hlint isn't enough, it still runs it.  Must I kill /&%§ Emacs to make it stop?
00:37:27 <earthy> yes
00:37:53 <earthy> removing hlint only removes the directory entry
00:38:00 <mekeor> ketil: you can switch between hlint and ghc with C-c C-c.
00:38:06 <earthy> any open files *stay* open after removal.
00:38:18 <mekeor> http://www.mew.org/~kazu/proj/ghc-mod/en/
00:38:21 <earthy> including 'running' programs
00:42:26 <ketil> mekeor, Ah, OK.  there's also ghc-flymake-toggle-command, which after reading the Elisp source, I realized did this.
00:42:55 <ketil> earthy, yes, I know.  I thought perhaps flymake reran it each time - especially, since list-processes didn't show anything.
00:43:06 <ketil> Sigh.  Wouldn't it be great if this stuff was documented?
00:43:12 <ketil> mekeor, thanks, anyway.
00:43:20 * mekeor hates undocumented stuff!
00:44:16 <ketil> Now: why would hlint claim that e.g. foo x y = \z -> expr is an *error*?  Whatever.
00:44:59 <mekeor> ketil: because "foo x y z = expr" is easier_to_read/better?
00:46:41 <qnikst> sometime it's easier to read foo x y = \z notation, for example when it creteFunction a b = \z ->
00:47:14 <mekeor> true‚Ä¶
00:50:59 <kamatsu> hi all
00:51:14 <mekeor> hi
00:51:19 <kamatsu> i'd like to have a cabal file where i can select options from several possibilities
00:51:26 <kamatsu> i know cabal has flags
00:51:53 <kamatsu> but is it possible to set, for example, a variable?
00:52:15 <kamatsu> e.g cabal install -fplatform=arm-qemu or something
01:10:15 <mekeor> isn't it funny to see that constructors are just defined through their type signature? (:), for instance, is just defined as "(:) :: a -> [a] -> [a]"... that's cool.
01:12:24 <yogsototh> Hi, I remarked that importing more modules while not modifying the code make a bigger executable (I used -O2). Could someone point me a good reason why GHC don't optimize this? Thanks.
01:13:01 <osa1> what is the "streaming data problem" mentioned in conduit package documentation? where can I learn about it?
01:13:52 <ChristianS> yogsototh: don't know, but if you run ghc with -Wall it warns about unused imports
01:16:11 <Phlogistique> yogsototh: http://www.haskell.org/haskellwiki/GHC_optimisations#Dead_code_elimination
01:17:13 <yogsototh> Thanks!
01:18:44 <Phlogistique> yogsototh: and the option is http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/options-phases.html#options-linker -split-objs
01:25:45 <yogsototh> Phlogistique: Thanks for -split-objs, it is a nice option and resolve all import problems. But from the warning it appears to slow down compilation a lot.
01:26:20 <yogsototh> luite: Are you luite stegeman?
01:34:09 <mekeor> yogsototh: /whois luite
01:52:45 <covi> Hi all. Is 'Just' a data constructor or a type constructor? Can I pattern match against it?
01:53:23 <zhulikas> you can pattern match it
01:55:03 <flamingspinach> hi guys, I am learning emacs and haskell at the same time and am wondering what stuff I should be installing - I've got emacs 23.4.2, and ghc 7.4.1... is there a separate haskell plugin for emacs that I should download?
01:55:44 <fmap> covi: Just is data constructor
01:55:56 <hpaste_> asdfasdf pasted ‚Äúsaggy‚Äù at http://hpaste.org/67320
01:56:01 <kamatsu> hm
01:56:07 <kamatsu> i run cabal configure, it's fine
01:56:11 <kamatsu> i run runhaskell Setup.hs configure
01:56:11 <covi> fmap: it seemed that I could not pattern match against it
01:56:14 <kamatsu> it can't see mtl
01:56:22 <Brolapse> i just pasted that thing, can somebody help me with my problem?
01:56:31 <srhb> flamingspinach: Yes, haskell-mode for instance.
01:56:39 <fmap> covi: you should be able do pattern match
01:56:42 <Brolapse> addFilm just isn't changing the testDatabase list
01:58:01 <fmap> > (\(Just n) -> print n) (Just 7)
01:58:02 <lambdabot>   <IO ()>
01:58:35 <fmap> > (\(Just n) -> show n) (Just 7)
01:58:36 <lambdabot>   "7"
01:58:42 <flamingspinach> srhb: right but I see a couple of things - which is the "correct" one? There is a haskell-mode on github, one on projects.haskell.org, and something else called "haskell-emacs"...
01:59:01 <covi> fmap: http://hpaste.org/67321
01:59:36 <srhb> flamingspinach: There are quite a few developments. I'm using the one from github.com/pheaver
01:59:47 <Brolapse> http://hpaste.org/67320 can anyone help me?
01:59:50 <covi> fmap: tofu (Just 1) :: Frank Int Maybe works. But that's only valid with 'tofu x', not 'tofu (x y)'. Why?
02:00:02 <covi> fmap: this is an example in lyah
02:00:31 <flamingspinach> srhb: that one says it's deprecated, and points to github.com/haskell/haskell-mode
02:00:44 <srhb> flamingspinach: Follow that lead then. :-)
02:00:58 <srhb> flamingspinach: Where does it say deprecated though?
02:01:02 <kamatsu> Brolapse, you're trying to mutate variables
02:01:07 <flamingspinach> srhb: in the project description on github
02:01:35 <srhb> flamingspinach: Can you pinpoint it further? I can't seem to find it.
02:01:56 <srhb> flamingspinach: Oh, got it.
02:02:32 <kamatsu> yep, it seems like locally-installed packages are only seen when I run cabal, not Setup.hs
02:02:35 <kamatsu> any ideas on how to fix?
02:03:35 <Brolapse> kamatsu, how do I just add something to a list then? or is that not the problem
02:03:37 <flamingspinach> srhb: hmm, I also found this: http://mid.gmane.org/CAAJHNPDufgYPXfM3B-MANYdMZezcJAP47NS=gBGEJ2XxS1ruLw@mail.gmail.com
02:03:46 <flamingspinach> so apparently everything is converging to haskell/haskell-mode on github
02:03:51 <flamingspinach> I guess I should use that :)
02:04:08 <srhb> flamingspinach: Yep, just updated mine as well. All the basic functionality appears to be the same though, so don't worry too much about it.
02:04:35 <flamingspinach> OK, sounds good, thanks for your help :)
02:07:52 <fmap> covi: well, you can't use (x y) to match all possible data contructors with 1 argument
02:07:55 <cdupont> hi everybody
02:08:04 <cdupont> @djinn a -> [a] -> [a]
02:08:04 <lambdabot> Error: Undefined type []
02:08:10 <cdupont> strange?
02:08:32 <fmap> covi: on the other hand x itself matches everything
02:10:32 <Brolapse> http://hpaste.org/67320 how to fix
02:10:40 <covi> fmap: is there a way to get around with this? It's not guaranteed that a 'Just 7' will be inputed.
02:11:10 <fmap> covi: (Just n)
02:11:26 <covi> fmap: I see. Haskell is interesting.
02:11:29 <covi> ty
02:13:04 <cdupont> @djinn type C a = (a -> Ans) -> Ans
02:13:04 <lambdabot> Cannot parse command
02:13:19 <mm_freak> can a C/assembler function running concurrently somehow communicate /directly/ with a haskell thread?
02:13:22 <cdupont> @djinn a -> C a
02:13:23 <lambdabot> Error: Undefined type C
02:13:28 <mm_freak> like:  can i make it update an IORef atomically?
02:14:47 <mm_freak> background:  i'm going to write a tight loop in assembler that performs a search with possibly many results
02:15:00 <mm_freak> i'd like to communicate the results to haskell without having to leave the loop
02:15:36 <danr> does djinn have a void/empty type?
02:15:56 <mm_freak> @djinn Void -> ()
02:15:56 <lambdabot> f = void
02:16:54 <danr> @djinn (((a -> Void) -> Void) -> Void) -> (a -> Void)
02:16:54 <lambdabot> f a b = void (a (\ c -> c b))
02:17:33 <danr> @djinn ((Either a (a -> Void)) -> Void) -> Void
02:17:33 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
02:17:38 <danr> Right.
02:18:32 <Brolapse> how do i add an entry to a list with structure string,string,int,[string,int]
02:19:04 <Brolapse> so [String, String, Int, [(String, Int)]]
02:19:39 <danr> do you mean [(String,String,Int,[(String,Int)])] ?
02:19:46 <qnikst> it can't be
02:19:53 <danr> i.e a list of quintuples
02:19:57 <Brolapse> yes
02:19:58 <qnikst> lists are not heterogenus
02:20:00 <danr> uh, quadruples
02:20:38 <qnikst> then just (String,String,Int,[(String,Int)]) : list?
02:20:53 <Brolapse> that's what i thought i was doing here
02:20:54 <Brolapse> http://hpaste.org/67320
02:21:06 <Brolapse> but the list never gets updated it seems
02:21:47 <qnikst> how are you using it?
02:21:53 <qnikst> : - produces new list
02:22:16 <Brolapse> so it'd be returning a new list?
02:22:29 <qnikst> so it should me smth like let database' = addFilm database title ...
02:22:43 <Brolapse> yeah I tried to do that in prelude and it was erroring
02:22:50 <Brolapse> even though that's not really what I want to do in the long run
02:23:50 <qnikst> it's normal that lists is new, because : just add new item that's tail 'points' to old list
02:24:15 <qnikst> Brolapse: can you paste place it code there list it not updated?
02:24:15 <Brolapse> let testDatabase = addFilm testDatabase "foo" "boop" 2006
02:24:16 <Brolapse> that worked
02:25:06 <qnikst> great
02:25:27 <Brolapse> however that's not how I wanted it and now I gotta figure out how to do it
02:25:49 <qnikst> depends on what you want to
02:26:20 <Brolapse> i want to be able to add things directly to testDatabase
02:27:01 <qnikst> thats not you want to :), it's implementation but not your target
02:27:28 <qnikst> anyway you can use TVar or IORef to make mutable things
02:28:44 <fmap> Brolapse: i may be wrong but seems your let x = f x defines infinite database of foos
02:30:34 <qnikst> we lost him :/
02:30:56 <Brolapse> fmap, it doesn't seem to add infinite foos, but it may be creating infinite databases
02:31:57 <qnikst> you are not right
02:32:07 <qnikst> or..
02:33:41 <Brolapse> so is having mutable things the best option, or is there another way I could do it?
02:34:26 <qnikst> you can use State if you have only one 'worker'
02:35:01 <Brolapse> it's supposed to be a simple program
02:36:24 <dobblego> roconnor_: ping
02:37:57 <barrucadu> Brolapse: You could use State, as mentioned, or pass around the database between functions
02:38:09 <Brolapse> barrucadu, that's what I was trying to do
02:38:18 <qnikst> it's the same
02:38:19 <Brolapse> (passing the database around functions)
02:39:01 <Brolapse> if i do pass the database around functions imma have to just go with let x = f x right?
02:39:06 <qnikst> but if you want to learn you can implement passing database between functions, and then take a look at state
02:39:25 <qnikst> let x' = f x -- would be much better
02:39:59 <qnikst> let x = f x -- will not be resolved in case on not spesial f
02:40:18 <Brolapse> let x/let x' different things?
02:41:11 <qnikst> when haskell resolves 'f x' it looks for closes x definition, and finds one in left hand side, so it resolved to f (f x) and so on
02:41:43 <qnikst> x' is another variable, everything resolved correctly
02:41:52 <merijn> > fix ("The first rule of fix club is " ++)
02:41:54 <lambdabot>   "The first rule of fix club is The first rule of fix club is The first rule...
02:42:06 <merijn> Ah, damn. Missed a colon there
02:42:19 <Brolapse> i'm thinking about how i'd use x'
02:42:27 <danr> > 'T':fix ("he first rule of fix club is t" ++)
02:42:28 <Brolapse> implement*
02:42:29 <lambdabot>   "The first rule of fix club is the first rule of fix club is the first rule...
02:43:18 <merijn> Brolapse: Do you plan to mutate the database that you're passing around?
02:43:29 <qnikst> Brolapse: you can use contination aproach
02:43:41 <merijn> (I think I missed the start of the question)
02:43:46 <qnikst> f :: a -> (a -> b) -> b
02:44:26 <merijn> Or you use the ((->) r) monad/functor/applicative (if you don't need mutability)
02:44:52 <qnikst> seems mutability doesn't needed because there is only one thread working with data
02:45:03 <Brolapse> merijn, i was trying to mutate it in the first place, which i realised was my problem
02:45:32 <Brolapse> this is a small uni assignment anyway so i don't think i wanna dip into monads etc
02:45:45 <qnikst> no, you want :)
02:46:13 <merijn> Monads aren't hard, they're just so vaguely abstract that it's hard to see their use in general. Specific monad uses are easy
02:46:22 <merijn> Same for functors/applicative.
02:46:56 <qnikst> Brolapse: CPS style: addFilm database film next = next (addFilm' database film) where addFilm' d f  = d : Film f
02:47:12 <qnikst> I don't know full task, so..
02:47:22 <merijn> > let f = (+) <$> (*2) <*> (+10) in f 1 -- Unreadable applicative example for passing values around
02:47:23 <lambdabot>   13
02:47:52 * qnikst have not managed to undestand applicative (
02:48:25 <merijn> Applicative is easy, it's the instances for "(->) r" which are a bit confusing
02:48:32 <Brolapse> yes i will stay with non mutability :P
02:49:02 <dnangel> > printLn "Haha"
02:49:03 <lambdabot>   Not in scope: `printLn'
02:49:05 <qnikst> Brolapse: State is the simpliest thing, maybe StateT IO in your case
02:49:29 <merijn> dnangel: lambdabot doesn't execute IO actions
02:49:32 <qnikst> it you need communication with IO
02:49:35 <dnangel> oh
02:49:42 <Brolapse> i do need IO
02:49:46 <merijn> (for obvious security reasons)
02:50:12 <dnangel> if i have ghc and know a little about haskell, what should i poke next?
02:50:24 <roconnor_> dibblego: ack
02:50:29 <merijn> dnangel: What do you mean?
02:51:13 <dnangel> most of the example in lyahfgg are boring. i want to get down to the heavy stuff.
02:51:42 <qnikst> Brolapse: then you have to options make a loop in IO and runState on each step, or make StateT IO, again it depends on requirement
02:51:43 <merijn> dnangel: Real World Haskell has some harder and/or more practical examples. How far did you get in LYAH?
02:51:59 <dnangel> i skipped the functional parts that i already knew from other languages.
02:52:03 <merijn> dnangel: btw, printLn is non-existent. You probably want putStrLn or print
02:52:20 <dnangel> stopped around monads because i have an inner language war ;- )
02:52:24 <merijn> dnangel: Ah, you know ML or something similar already?
02:52:31 <dnangel> lisp/scheme
02:53:14 <merijn> I would say the Functor/Applicative/Monad stuff is pretty important still
02:54:23 <certainty> is there a naming convention for predicates?
02:54:33 <t7> > return 1 :: (->) Int
02:54:34 <lambdabot>   Expecting an ordinary type, but found a type of kind ? -> *
02:54:39 <merijn> Anyhoo, RWH is pretty good, but especially skips some of the more advanced, but common, stuff like I just mentioned
02:54:39 <merijn> @rwh
02:54:40 <lambdabot> Maybe you meant: rc run wn
02:54:44 <merijn> @where rwh
02:54:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:54:50 <t7> > return 1 :: (->) Int Int
02:54:51 <lambdabot>   Overlapping instances for GHC.Show.Show
02:54:51 <lambdabot>                              (GHC.T...
02:55:16 <dnangel> ty i'll take a look
03:24:23 * hackagebot gloss 1.7.3.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.3.1 (BenLippmeier)
03:36:00 <vit> hi there
03:40:17 <kamatsu> hi
03:41:06 <efie> is there a way to write my solve function nicer? it is pretty ugly.. http://hpaste.org/67323
03:42:23 <merijn> efie: Why use both let and where?
03:42:24 <kamatsu> consider avoiding explicit recursion
03:42:26 <merijn> That's pretty ugly
03:44:25 * hackagebot QuickAnnotate 0.4 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.4 (ShayanNajd)
03:45:56 <efie> ok, thanks
03:47:20 <qnikst> btw, what are semantical difference between let and where, if there is some?
03:47:35 <int-e> there is none
03:50:16 <merijn> Well, there is one
03:50:24 <int-e> they have different scoping behaviour -- 'where' is useful for defining values used in guards:  foo x | a == 1 = x   | a == 42 = y   | otherwise = z   where a = g x   works; doing this with  let  requires an extra 'case'.
03:50:25 <merijn> You can use let in more places than where
03:50:58 <merijn> Since you can only define where in the top level of a function, whereas let is just an expression you can have anywhere you could have an expression
03:51:26 <int-e> well, you can also use 'where' inside a let binding.
03:51:57 <int-e> > let f x = a where a = 42+x in f 23 -- I'm not saying that you should do that, though.
03:51:58 <lambdabot>   65
03:52:50 <qnikst> )
03:52:52 <qnikst> ok
03:52:53 <qnikst> thanks
03:53:57 <qnikst> and let k = long compulation in f k k ; and f k k where k = long computaion, will work exactly the same?
03:54:20 <merijn> qnikst: yes
03:54:55 <qnikst> ok.
03:55:45 <qnikst> we remembered that there was tight difference in 'memoization' behavior, (memoization is not exactly correct term but anyway)
03:57:53 <efie> qnikst: is let oder where faster?
03:58:49 <qnikst> I've heard smth that let giver better guarantees that binded thing will not compute twice
03:59:04 <qnikst> but it seems it was not true
04:09:13 <Saizan> you can see where as syntactic sugar over let
04:34:29 * hackagebot blaze-html 0.4.3.4 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.3.4 (JasperVanDerJeugt)
04:35:08 <FightDegeneracy> I am a Debian user. What is a better idea, install the Haskell platform version that comes as a Debian package, or install the latest version?
04:41:23 <Tinned_Tuna> FightDegeneracy: it depends what you want to do, all told. It is invariably easier to start off with the haskell-platform from the repos. But it can make it harder to use the very latest GHC features and libraries from Hackage.
04:46:13 <fmap> FightDegeneracy: I personally prefer cabal-install on my debian but that depends.
04:47:39 <FightDegeneracy> Tinned_Tuna, fmap: Thanks. I personally do not mind installing from source, as long as it is easy (e.g. installing gcc from source is okay, installing glibc from source is not okay).
04:48:14 <FightDegeneracy> Is installing the Haskell platform from source easy (i.e., just mindlessly following some instructions from a text file).
04:50:16 <efie> can I use If inside of a do-block?
04:50:21 <efie> if*
04:51:20 <efie> ah, I was missing the "in" from "let..." before the if
04:51:23 <t7> what is the second symbol from the right called? http://upload.wikimedia.org/wikipedia/en/math/b/7/4/b7417eb256e44acc930b81b48dbcf71b.png
04:53:37 <ehamberg> \sqsubseteq according to http://detexify.kirelabs.org/classify.html :)
04:53:41 <ehamberg> you could google that :)
04:54:29 * hackagebot hashtables 1.0.1.4 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.4 (GregoryCollins)
04:54:59 <t7> x \sqsubseteq y means x is no more defined that y
04:55:04 <t7> thanks ehamberg
04:57:37 <t7> why cant browsers render latex
04:57:38 <byorgey> t7: I don't think that's what it means here
04:58:17 <byorgey> t7: where did you see this formula?
04:58:36 <t7> hindley milner
04:58:39 <hpaste_> ment pasted ‚Äúcycle length‚Äù at http://hpaste.org/67325
04:59:40 <ment> how to make the count function run faster?
05:00:03 <ment> (it calculates length of a cycle in permutation)
05:00:07 <byorgey> t7: it's defined at the beginning of the section "Polymorphic type order"
05:00:24 <t7> aha
05:00:31 <byorgey> t7: it expresses that one type is more specialized than another
05:00:37 <merijn> ment: You probably want to eliminate !!
05:00:45 <byorgey> i.e.  forall b. Int -> b  is more specialized than  forall a b. a -> b
05:00:46 <merijn> ment: It has O(n) complexity
05:01:13 <ment> merijn: i do, i know that, but i have no idea how to do it differently
05:01:30 <t7> i dont remember seeing that checked in any implementations. Is that just a result of some other algorithm ?
05:01:46 <t7> (part of the algorithm)
05:02:06 <merijn> ment: It's counting cycles like 1,2,3,2,1, right?
05:02:31 <merijn> Or did I misunderstand your description
05:07:14 <ment> merijn: it takes a permutation and computes length of the first cycle
05:07:54 <ment> merijn: imperative solution would be do { i = perm[i]; len++; } while(i != 1)
05:09:16 <merijn> ah
05:09:17 <nomeata> When looking at GHC produced assembly code, I see a stack overflow check before every function. Couldn‚Äôt that be avoided by having an invalid page below the stack and catch the execption in the RTS? What would go wrong?
05:09:24 <aristid> ment: and i is initialised with 1?
05:09:41 <merijn> nomeata: Maybe more of a topic for #ghc?
05:10:10 <nomeata> merijn: probably...
05:10:50 <hpc> nomeata: ooh, sneaky trick
05:10:53 <merijn> ment: And you only want to do this for fixed size permutations?
05:11:25 <merijn> ment: Might be worth using an array instead of a list, then. Those have O(1) accesses for indexing
05:12:59 <ment> aristid: yeah
05:13:51 <ment> merijn: the function doesn't modify the permutation, but the permutation itself is read from input and can vary in size
05:15:07 <merijn> ment: Maybe read in, permute, convert to array (or just read in directly as an array and then permute that)
05:15:15 <merijn> Anyhoo, take a look at Data.Array, I guess?
05:15:24 <ment> ok, thanks
05:25:31 <kallisti> where was the implementation of base64 bytestring encoding for lazy bytestrings?
05:29:31 * hackagebot skein 0.1.0.6 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.6 (FelipeLessa)
05:41:40 <frontendloader> I'm trying to write fizzbuzz using a list comprehension. Am I barking up the wrong tree if I'm starting with [(x,s), | x <- [1..15], s <- ???]
05:42:12 <kallisti> the second value shouldn't be necessary
05:42:19 <kallisti> there's no state that needs to be passed along to do fizzbuzz.
05:42:23 <frontendloader> can s know what x has pulled? Generating all permutations and filtering seems awful
05:42:29 <kallisti> each number has a single independent test.
05:42:36 <merijn> kallisti: I think his problem is returning x when it is a string/int
05:42:59 <kallisti> just always use strings
05:43:02 <kallisti> for this problem
05:43:04 <kallisti> unless you want Either
05:43:06 <merijn> Yes
05:43:10 <merijn> String or Either
05:43:11 <kallisti> but the s isn't needed.
05:43:41 <kallisti> frontendloader: why do you need the elements of [1..15]?
05:43:43 <frontendloader> I was trying to do it without doing the x%5==0 && x%15!=0 type notation as well, where you just append Buzz to a string containing either Fizz or empty
05:44:03 <kallisti> oh
05:44:22 <kallisti> that still requires a mod test somewhere. >_>
05:44:35 <kallisti> to be efficient, anyway
05:44:36 <frontendloader> just some base numbers to start off with, that'd get generalized out to let xs = [x | x <- xs]
05:44:47 <frontendloader> let fizzbuzz xs = [x | x <- xs]
05:45:08 <frontendloader> I meant removing the need to test for mod 15
05:45:56 <kallisti> you could just use a let with ifs
05:46:12 <merijn> frontendloader: I would probably write this as map + a function rather than a list comprehension, though
05:46:13 <kallisti> > [x | x <- [1,2,3], let str = "this is allowed"]
05:46:14 <lambdabot>   [1,2,3]
05:46:30 <byorgey> note that [x | x <- xs] == xs
05:46:53 <frontendloader> Doing it with ifs is too procedural
05:47:02 <merijn> > let foo :: Int -> String; foo = show in map foo [1..10]
05:47:02 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
05:47:12 <kallisti> frontendloader: you could use a parallel list comp
05:47:13 <frontendloader> also do resist the urge to spoiler me with the solution please
05:47:49 <merijn> frontendloader: Yeah, I decided not to give any real implementation for foo for that reason :p
05:48:03 <frontendloader> thanks
05:48:20 <merijn> frontendloader: But splitting it into "foo :: Int -> String" and map separates the problem into two separate parts
05:48:29 <mel-> Hi. when i use cabal to install a package -- are there integrity checks (e.g. signatures) done?
05:48:35 <merijn> Which I think is conceptually easier than doing it in one list comprehension
05:49:43 <kallisti> frontendloader: using "procedural" conditions is going to be the best way.
05:50:20 <kallisti> the problem is centered around a conditional.
05:50:59 <merijn> frontendloader: And you can implement "foo" using guards then, which should be fairly easy
05:51:31 <kallisti> but I have thought up one way to do it without those
05:53:58 <frontendloader> I suppose it is a boring problem anyway
05:53:59 <kallisti> but it does require an if.
05:54:23 <merijn> frontendloader: Probably, but if your absolutely new than it's a nice example of guards
05:55:36 <frontendloader> I just did it with guards a bit ago and wanted to see if I could do it another way.
05:56:11 <merijn> frontendloader: You probably can, but I don't think it will be an improvement (you'd have to use multiple if's inside the list comp)
05:58:04 <kallisti> > [if null (fizz++buzz) then show x else fizz++buzz | x <- [1..] | fizz <- cycle ["", "", "Fizz"] | buzz <- cycle ["","","","","Buzz"]]
05:58:06 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
05:58:12 <kallisti> this is the one I was thinking of..
06:01:08 <kallisti> which uses -XParallelListComp
06:03:47 <kallisti> I kind of gave away a solution, but it appeared that you gave up.
06:09:32 * hackagebot IntervalMap 0.2.3.2 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.3.2 (ChristophBreitkopf)
06:10:37 <frontendloader> yeah I don't quite understand what your solution is yet
06:11:56 <merijn> frontendloader: He's walking two lists in parallel, one which has Fizz every three entries, the other having Buzz every five entries. He then concatenates those two and if the resulting string is empty he returns the Int turned into a String
06:12:38 <frontendloader> that's a good one then.
06:13:21 <merijn> > (zipWith (++) `on` cycle) ["", "", "Fizz"] ["", "", "", "", "Buzz"]
06:13:23 <lambdabot>   ["","","Fizz","","Buzz","Fizz","","","Fizz","Buzz","","Fizz","","","FizzBuz...
06:14:34 * hackagebot skein 0.1.0.7 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.7 (FelipeLessa)
06:20:15 <fmap> > zipWith3 (\fizz buzz x -> if null $ fizz ++ buzz then show x else fizz ++ buzz) (cycle ["","","Fizz"]) (cycle ["","","","","Buzz"]) [1..]
06:20:17 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
06:22:15 <fmap> @pl \fizz buzz x -> if null $ fizz ++ buzz then show x else fizz ++ buzz
06:22:15 <lambdabot> ap (ap . (flip .) . flip flip show . (((.) . if' . null) .) . (++)) (++)
06:27:39 <fmap> i wish there was Pointfree Class at coursera or something
06:27:51 <xraycat> :-)
06:34:00 <t7> byorgey: whats more specialized: a -> Int  or Int -> b
06:35:39 <eacameron> is there a way to import multiple libraries on the same line?
06:38:22 <fmap> eacameron: import A; import B
06:39:45 <eacameron> fmap: simple enough..thanks
06:41:39 <byorgey> t7: neither.
06:42:02 <byorgey> t7: they are incomparable with respect to the specialization order.
06:50:37 <dgpratt> what is the definition of 'void' as used by @djinn?
06:51:07 <merijn> @src void
06:51:07 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:51:52 <merijn> dgpratt: In Control.Monad: void :: Functor f => f a -> f ()
06:52:10 <quicksilver> I don't think that' what @djinn means
06:52:16 <kallisti> :t foldr
06:52:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:52:18 <quicksilver> I think @djinn just means data Void;
06:52:19 <merijn> No?
06:52:41 * merijn was just guessing
06:52:50 <quicksilver> @djinn a -> ((a -> Void) -> Void)
06:52:50 <lambdabot> f a b = b a
06:53:18 <quicksilver> hmm, not an interesting example that one
06:53:28 <dgpratt> @djinn (a -> Not (Not b)) -> Not (Not a) -> Not (Not b)
06:53:29 <lambdabot> f a b c = void (b (\ d -> void (a d c)))
06:53:40 <dgpratt> ^that 'void'
06:53:55 <kallisti> is there difference in efficiency between foldl and foldr when using composition?
06:55:16 <quicksilver> dgpratt: http://www.haskell.org/pipermail/libraries/2006-October/005985.html
06:55:23 <parcs`> dgpratt: void :: Void -> a
06:55:43 <dgpratt> ah
06:55:50 <dgpratt> thanks, quicksilver, parcs`
06:56:49 <kallisti> I'm guessing foldl would be faster..?
06:57:37 <kallisti> actually maybe foldr is better..
06:59:06 <quicksilver> kallisti: it actually doesn't matter, which is what makes DList magical.
06:59:23 <kallisti>  oh, well good..
07:01:44 <kallisti> yeah I guess either way it doesn't matter..
07:01:49 <kallisti> I see that
07:02:07 <kallisti> in (f . g) x = f (g x)  you're either unreaveling a composition in g or in f
07:02:26 <kallisti> the direction shouldn't really matter.
07:02:51 <kallisti> *unraveling
07:05:18 <efie> hello, I got an efficiency problem: http://hpaste.org/67328 maybe anyone can tell me how to improve my code?
07:10:56 <earthy> efie: profiled it yet?
07:12:02 <efie> earthy: you mean the computation ended? I stopped it after ~ 5 minutes
07:12:52 <earthy> I mean: have you compiled with --enable-profiling and run it with +RTS -p
07:12:59 <earthy> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/profiling.html
07:13:21 <Cale> You're enumerating all the permutations of [1..16]
07:13:30 <Cale> > product [1..16]
07:13:30 <lambdabot>   20922789888000
07:13:36 <Cale> that's a lot of things to go through
07:13:54 <efie> earthy: I haven't done this yet, I will check it out thanks
07:13:57 <Cale> The problem isn't so much with your Haskell code as the algorithm :)
07:14:18 <earthy> yah... generate only valid permutations, to start with
07:14:51 <scooty-puff> are the package transformers treated specially by ghc?
07:15:04 <parcs`> i think this line is the culprit "filteredPermuts = filter (permIsValid ((pos,value):xs)) permuts"
07:15:07 <scooty-puff> the source doesn't show any INLINE, etc. pragmas, which i would expect
07:15:18 <scooty-puff> *is the package ...
07:15:56 <mikeplus32> http://hpaste.org/67329 how do I execute this function at compile time?
07:16:19 <mikeplus32> for functions that are Q Exp, I can use $(...), but this is Q Html, so I'm not sure
07:16:28 <mikeplus32> (<- bad at TH)
07:16:39 <efie> earthy: well what do you mean by valid permutations? I have to creat them and after that I can see by appling the isInOrder  function if they are valid or not
07:17:01 <Cale> efie: For example, you could find the first clue in the grid, say it's labelled with n, such that n-1 or n+1 are not already in the grid, and enumerate ways to place those.
07:17:23 <Cale> efie: rather than enumerating all permutations, make only valid extensions of the board.
07:18:23 <Cale> You might even be able to get away with being more naive...
07:19:34 <Cale> hmm
07:20:21 <efie> I am trying to understand :D
07:20:59 <Cale> efie: Think about how you solve one of these puzzles as a human. You don't just enumerate all possible permutations of 1..16 and see if each one solves the puzzle.
07:21:21 <Cale> That's an infeasible thing for even a computer to do.
07:21:38 <Cale> There are just way too many permutations to try.
07:22:57 <efie> Cale: 4! permutations does not sound much
07:23:43 <earthy> efie: but it's 16!
07:23:59 <earthy> what you're generating
07:24:06 <efie> oh
07:24:12 <Cale> > product [1..16]
07:24:13 <lambdabot>   20922789888000
07:24:15 <efie> true
07:24:18 <efie> :D
07:24:22 <Cale> ^^ your program is always going to try to search through a list that long
07:24:36 <efie> hm ok
07:24:54 <Cale> So you can't do that
07:26:07 <Cale> Instead, you want to pick a clue which is in the partially-filled grid, and which doesn't yet have n-1 and n+1 next to it, and enumerate the ways in which you could place those.
07:27:36 <Cale> Any solution of the puzzle will have n-1 and n+1 on cells adjacent to n.
07:27:46 <adamt> which puzzle is it you're trying to solve? :)
07:27:57 <Cale> http://www.janko.at/Raetsel/Hidoku/
07:28:39 <efie> cale: thanks, I will think now about it now
07:28:56 <Cale> (apart from the lowest and highest number of course, which only need to be next to one thing)
07:34:40 <cdh473> What's the fastest portable Windows Haskell compiler?
07:34:52 <cdh473> fastest as in `produces fastest programs`
07:34:55 <Cale> cdh473: GHC
07:35:01 <efie> cale: anyway I'm wondering, because the task was to write a function which puts all the information about the possibilities of neighbouring numbers into one big DNF (which is in my case the isInOrder function which tells if a given list of numbers is a modell for the propositional logic model) So not its strange to me to select intelligently a possbile list of numbers before .. but yes, thats the only way how its can be done
07:35:01 <cdh473> not portable afaik
07:35:11 <Cale> cdh473: What do you mean by portable?
07:35:20 <cdh473> Cale, doesn't make registry changes
07:35:20 <Cale> GHC works on multiple platforms...
07:35:29 <Cale> What?
07:35:35 <Cale> GHC makes registry changes?
07:35:35 <cdh473> like i can install it on a thumb drive
07:36:02 <Cale> cdh473: There's really no option other than GHC for practical Haskell work.
07:36:16 <Cale> There are other compilers, but they're mostly toy implementations of the language.
07:36:25 <cdh473> i know, but i'd like the next best thing for experimenting while i'm away
07:36:37 <quicksilver> cdh473: there is no next best thing.
07:36:42 <cdh473> hugs is the only other one i know of (it works)
07:36:44 <quicksilver> Cale: "toy" is too harsh.
07:36:48 <adamt> have you tried installing ghc on a flashdrive?
07:36:51 <cdh473> but it's unbelievably slow thing
07:37:05 <quicksilver> Cale: but they have different objectives  and/or states of completeness.
07:37:13 <Cale> quicksilver: I mean it in the same sense as toy models in physics :)
07:37:15 <quicksilver> Cale: (uhc and jhc are not toys...)
07:37:31 <cdh473> adamt, i'm trying to install it on my harddisk space on a public computer
07:37:35 <quicksilver> I can't imagine that it would be hard to get GHC running on a flash drive.
07:37:43 <quicksilver> then again I've never used windows
07:37:45 <quicksilver> so I could be wrong.
07:38:09 <cdh473> GHC installation on these machines won't work as it asks for an admin login
07:38:18 <cdh473> which is why i need something portable
07:38:48 <Cale> Well, that's BS. GHC will install fine into a user directory on Linux. I don't see why it would need any more permissions on Windows.
07:38:58 <quicksilver> the installer is probably catering to the common convenience.
07:39:19 <quicksilver> I'm sure someone who knows what they're doing can get it running from a home directory or removable media.
07:39:19 <t7> someone clever: Can polytypes contain free variables?
07:39:22 <cdh473> Cale, it's on a public computer where i'm not allowed to install non-portable apps
07:39:57 <td123> cdh473: did you try http://www.haskell.org/ghc/download_ghc_7_4_1#windows
07:40:01 <cdh473> as a matter of fact, i JUST tried ghc, so it is most definitely not bs
07:40:20 <quicksilver> Cale doesn't mean you're lying cdh473 ;)
07:40:28 <quicksilver> he means the situation is BS - i.e. it shouldn't be like that.
07:40:34 <cdh473> oh, right
07:40:36 <cdh473> i agree
07:40:41 <sm> +1
07:40:42 <Cale> cdh473: I'm saying that the installer is lying to you :)
07:40:56 <Cale> cdh473: GHC doesn't really need admin permissions to run
07:40:56 <cdh473> td123, i'm trying that one right now
07:41:05 <Cale> cdh473: Perhaps you could build it yourself.
07:41:21 <td123> cdh473: install it to a user folder like ~/ghc
07:41:37 <td123> err ~/desktop/ or whatever windows uses now
07:42:03 <cdh473> td123, i'm installing it on H:\ghc\... as the system wipes the C:\ drive on logout
07:42:23 <td123> oh right, ur usb
07:42:38 <cdh473> no, it's a server
07:42:59 <cdh473> but yes it should act like a usb
07:43:44 <cdh473> ok thanks td123
07:43:52 <cdh473> this one works :) just didn't know of this download
07:50:50 <sm> out of interest what other one were you trying ?
07:54:36 * hackagebot webdriver 0.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.2 (AdamCurtis)
08:02:25 <hpaste_> killy9999 pasted ‚ÄúType inference ‚Äù at http://hpaste.org/67331
08:03:08 <killy9999> why doesn't haskell infer the type to be [Char], but uses polimorfic [a0] insted?
08:03:43 <Cale> killy9999: Because 'A' isn't a list
08:04:01 <killy9999> yes, but "An error" is
08:04:05 <Cale> killy9999: `isPrefixOf` wants its first parameter to be a list, but you've given it a Char
08:04:12 <Cale> The error isn't talking about that :)
08:04:25 <killy9999> an based on the second list it could be infered that 'A' should be a list of Char
08:04:27 <Cale> Try "A" `isPrefixOf` "An error"
08:04:38 <rwbarton> but it doesn't even need to infer that to see an error
08:04:39 <killy9999> yes, I know
08:04:48 <Cale> It hasn't gotten that far in unification
08:05:01 <killy9999> so it stops as soon as it realizes that the first argument is wrong?
08:05:04 <Cale> yes
08:05:06 <killy9999> ok
08:08:24 <cwl> I solved the substract function for Church Number without adding newtype for (a->a)->(a->a). http://stackoverflow.com/questions/6595749/subtraction-of-church-numerals-in-haskell/10248765#10248765
08:08:27 <cwl> :-)
08:08:36 <cwl> Now the code is clean
08:08:53 <twomashi> Hi
08:09:19 <twomashi> anyone know how to implement get and set for a newtype without GeneralizedNewtypeDeriving?
08:09:28 <twomashi> to derive MonadState
08:09:36 * hackagebot chalmers-lava2000 1.2.0 - Hardware description library  http://hackage.haskell.org/package/chalmers-lava2000-1.2.0 (EmilAxelsson)
08:09:45 <quicksilver> get = lift get
08:09:48 <quicksilver> set = lift . set
08:09:55 <quicksilver> no that's not true at all
08:09:57 <quicksilver> ignore that
08:10:32 <quicksilver> get = MkNewtype get
08:10:51 <quicksilver> set = MkNewtype . set
08:13:29 <twomashi> quicksilver: I get: Can't make a derived instance of `MonadState MyType
08:14:52 <quicksilver> twomashi: that suggests you *are* trying to use GeneralizedNewtypeDeriving, you said you were trying *not* to use it?
08:14:56 <quicksilver> which do you want?
08:15:34 <twomashi> quicksilver: I want to use get and set inside my state transformer without the language extension
08:16:08 <twomashi> ah sorry, i gave you the wrong error message
08:16:38 <twomashi> No instance for (MonadState MyState MyType)
08:16:50 <quicksilver> and that suggests you haven't written the instance at all?
08:17:13 <quicksilver> if "newtype X a = X (State Foo a)"
08:17:13 <twomashi> instance MonadState MyType
08:17:39 <quicksilver> then X :: State Foo a -> X a
08:17:49 <quicksilver> so you can just use X (the constructor) to wrap simple actions
08:18:00 <quicksilver> hence get = X get
08:18:02 <twomashi> hm.. Not sure how to place that in the code
08:18:15 <rwbarton> I think you should ask your question again
08:18:19 <quicksilver> it would be easier if you would paste your code on hpaste
08:18:29 <quicksilver> maybe you're writing the instance wrong?
08:18:35 <quicksilver> MonadState has two parameters
08:18:38 <mm_freak> i'm implementing a dependently typed core language and found that the type checker effectively has to be a complete language interpreter‚Ä¶  is that right or am i doing something wrong?
08:18:42 <mm_freak> it feels right
08:18:49 <quicksilver> in "instance MonadState MyType" there is only one
08:18:59 <mm_freak> but it also raises the question whether it makes sense to compile dependently typed languages
08:19:07 <twomashi> quicksilver: yes, I've seen that error.. but not sure how to define the instance :/
08:19:07 <quicksilver> (but you should have got a different error message, i fyou wrote an instance with the wrong number of parameters)
08:19:15 <twomashi> * -> *
08:19:28 <quicksilver> instance MonadState MyState MyType where get = X get
08:19:42 <twomashi> aaahaa
08:19:44 <twomashi> lets see
08:28:53 <parcs`> twomashi: how does your 'deriving (MonadState ...)' declaration  look like/
08:29:20 <twomashi> im not using deriving at the moment because I want to avoid the language extension (rather understand the issue first)
08:29:29 <parcs`> okay
08:29:32 <twomashi> im trying to declare the instance: instance MonadState SudokuState Sudoku
08:29:42 <twomashi> Illegal instance declaration for `MonadState SudokuState Sudoku'
08:29:42 <twomashi>       (Only one type can be given in an instance head
08:29:54 <hpc> parens
08:29:59 <twomashi> aha..
08:30:18 <hpc> er
08:30:18 <hpc> no
08:30:40 <hpc> multiparametertypeclasses maybe
08:30:55 <twomashi> yes but want to avoid language extensions
08:31:03 <rwbarton> no
08:31:08 <rwbarton> you cannot
08:31:15 <rwbarton> which MonadState are you using?
08:31:35 <rwbarton> oh never mind, you just need to turn on MPTCs yeah
08:31:53 <twomashi> ok so given my type
08:31:54 <twomashi> Illegal instance declaration for `MonadState SudokuState Sudoku'
08:31:54 <twomashi>       (Only one type can be given in an instance hea
08:31:57 <twomashi> ack
08:32:00 <twomashi> newtype Sudoku a = Sudoku { runSudoku :: StateT SudokuState IO a }
08:32:11 <twomashi> I wont be able to implement get and set without the langauge extension?
08:32:24 <rwbarton> MonadState is a multiparameter type class
08:32:28 <hpc> ^
08:32:28 <TheLemonMan> hrm, i defined a typeclass constraint of (Num a) but ghc keeps saying "Could not deduce (a ~ Int)"
08:32:35 <rwbarton> if you want to write an instance for MonadState you need multiparameter type classes
08:32:43 <hpc> you can implement get/set, with different names
08:32:43 <twomashi> ahaa..
08:32:45 <TheLemonMan> i'd like to understand what that error means
08:32:51 <hpc> but you can't get an instance of MonadState
08:32:52 <twomashi> gotcha. Ok thanks!
08:33:09 <hpc> "class MonadState s m where" -- just with this one line you're stuck in extensionland
08:33:10 <twomashi> hpc, how would i implement get / set?
08:33:10 <byorgey> TheLemonMan: can you paste your code on hpaste.org?
08:33:18 <rwbarton> (the "multiple parameters" are SudokuState and Sudoku)
08:33:25 <twomashi> yes
08:33:32 <hpc> getSudoku = Sudoku get
08:33:37 <hpc> setSudoku = Sudoku . set
08:33:46 <byorgey> TheLemonMan: probably you are somehow specifically using an Int, but your instance is supposed to work for any numeric type
08:33:54 <quicksilver> as I told twomashi about 20 minutes ago, hpc :)
08:34:12 <quicksilver> 16:10 < quicksilver> get = MkNewtype get
08:34:12 <quicksilver> 16:10 < quicksilver> set = MkNewtype . set
08:34:13 <twomashi> uuh wtf it worked
08:34:18 <twomashi> quicksilver indeed you did..
08:34:24 <hpc> extensions aren't something scary to be avoided
08:34:34 <quicksilver> except for OverlappingInstances
08:34:48 <byorgey> TheLemonMan: more specifically, the error means that type inference has figured out that 'a' must be equal to Int (the ~ means equality of types), but GHC has no reason to believe that
08:35:01 <hpc> yeah, some of the *Instances stuff is scary, and some of it is downright evil
08:35:11 <twomashi> i know, but i prefer to get a better understanding of the issues before I take advantage of extensions
08:35:13 <ben> Isn't type inference having figured that out a fairly good reason to believe it? ;)
08:35:17 <hpc> MPTCs, newtype deriving, GADTs, type families, those are all totally safe
08:35:38 <TheLemonMan> byorgey: yep, i added an additional cast too but didnt work
08:35:41 <ben> (ScopedTypeVariables best extension)
08:35:44 <TheLemonMan> heres the snippet http://hpaste.org/67332
08:35:52 <byorgey> TheLemonMan: "cast"?  Haskell does not have casts
08:36:04 <ben> unsafeCoerce!!
08:36:13 <ben> TheLemonMan: We call those type annotations
08:36:20 <hpc> i kinda want to see the return of GlasgowHaskell
08:36:27 <hpc> as a simple alias for all the cool extensions
08:36:31 <byorgey> TheLemonMan: right, that type says that toRegister can be given any numeric type
08:36:43 <byorgey> TheLemonMan: but you are assuming it is an Int.
08:36:53 <TheLemonMan> but toEnum definition wants an int
08:37:00 <hpc> :t toEnum
08:37:00 <lambdabot> forall a. (Enum a) => Int -> a
08:37:06 <byorgey> TheLemonMan: adding  :: Int  does convert to Int, it just says "this must be an Int"
08:37:20 <hpc> *doesn't
08:37:27 <ben> :t toEnum . fromEnum -- is there a name for this?
08:37:28 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
08:37:39 <hpc> @hoogle (Enum a, Enum a1) => a1 -> a
08:37:39 <lambdabot> Prelude pred :: Enum a => a -> a
08:37:40 <lambdabot> Prelude succ :: Enum a => a -> a
08:37:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:37:55 <hpc> ben: betweenEnums, perhaps
08:38:01 <byorgey> TheLemonMan: are you sure you want a Num constraint?  What if someone passes (3.5 :: Double) as an argument to toRegister?
08:38:07 <ben> coerceEnum?
08:38:12 <ben> safeCoerce? ;)
08:38:12 <rwbarton> enumToEnum
08:38:17 <byorgey> s/does convert to Int/does NOT convert to Int/
08:38:26 <byorgey> critical missing 'not' failure
08:38:26 <hpc> heh, coerceEnum is a decent name actually
08:38:39 <hpc> it's a safe operation, but potentially an unhelpful one
08:38:42 <epsil> is it possible to generate a test case on the basis of a function definition?
08:38:47 <epsil> say I have a function foo which is correct but slow, and I want to write foo' which is the same but faster
08:38:49 <TheLemonMan> the argument is the result of some bit ops on a Word32 so the result is a Word32
08:38:52 <epsil> so to test foo', just feed a lot of values into foo, write down the results as the holy truth, and verify that foo' doesn't deviate from it
08:38:53 <byorgey> TheLemonMan: perhaps you want an Integral constraint instead?  then you can call 'fromIntegral' to convert to Int
08:38:57 <TheLemonMan> but wanted to make it a bit more flexible
08:38:57 <epsil> I could do this by hand, but is there an automatic way?
08:39:10 <ben> quickCheck $ \x -> foo x == foo' x?
08:39:31 <ben> give or take some @pl applications
08:39:32 <hpc> :t quickCheck
08:39:33 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
08:39:48 <byorgey> epsil: yes, use QuickCheck
08:39:49 <byorgey> http://hackage.haskell.org/package/QuickCheck
08:39:51 <hpc> > quickCheck $ \x -> abs x == x
08:39:52 <lambdabot>   Not in scope: `quickCheck'
08:39:55 <hpc> :(
08:40:02 <hpc> oh right, because IO
08:40:17 <ben> Even ##c++ has a bot that can evaluate things that do IO safely ;)
08:40:57 <byorgey> @check \x -> abs x == x
08:40:58 <lambdabot>   "Falsifiable, after 2 tests:\n-3\n"
08:41:24 <epsil> regarding quickcheck, would I need to give it both the old and the new definition of the function I'm writing, or is it possible to "convert" the old function into (editable) tests?
08:41:50 <epsil> (so that I can throw away the old function, but keep the tests)
08:43:54 <byorgey> epsil: no, quickcheck works by generating random input data.  you have to give it both the old and the new definition.
08:44:11 <epsil> byorgey: I see
08:44:21 <byorgey> but why would you want to throw away the old function?  keeping a slow but more obviously correct implementation around is great for documentation/specification purposes.
08:44:28 <byorgey> just don't export it from the module.
08:45:03 <byorgey> unless it's so slow that you don't want to run it every time you want to test.
08:45:18 <epsil> precisely
08:47:26 <byorgey> epsil: hrm, I see.  well, I'm not sure of any good (automatic) way to do that.
08:47:51 <mm_freak> i'm currently deciding what type of recursion to allow in my language‚Ä¶  i'd like to have guarded coinduction‚Ä¶  how to implement this correctly?  is there a paper?
08:48:52 <danr> mm_freak: you might want to have a look at Nils Anders Danielssons publications
08:49:00 <danr> Danielsson's
08:49:40 * hackagebot Hipmunk 5.2.0.8 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.8 (FelipeLessa)
08:49:42 * hackagebot HipmunkPlayground 5.2.0.7 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.7 (FelipeLessa)
08:50:06 <epsil> byorgey, ben: okay, thanks for the tips, I'll look into QuickCheck :)
08:51:19 <dylukes> okay so... this may be the height of heresy but...
08:51:28 <dylukes> is there possibly a way to reify a string into a function AT RUNTIME?
08:51:38 <dylukes> unsafeCallFunctionNamed or something like that
08:51:39 <byorgey> dylukes: yes. See the hint package.
08:52:04 <byorgey> dylukes: wait, you mean reify a string into the *name* of a function?
08:52:13 <dylukes> Well say I have a lisp interpreter...
08:52:14 <byorgey> oh, never mind, same thing.
08:52:22 <dylukes> and I want it to be able to transparently use HASKELL functions.
08:52:27 <byorgey> yep
08:52:32 <byorgey> use hint
08:52:35 <dylukes> (yes, this will involve a lot of unsafe/Dynamic)
08:52:49 <dylukes> I need to write a work sample for CMU so I'm going to throw together a lisp interpreter.
08:52:55 <dylukes> It's classic, I can do it quick enough.
08:53:04 <dylukes> And there's room to do cool/unique stuff.
08:53:14 <dmwit> byorgey: You surprise me. Reifying a string into the name of a function is the same as reifying it into a function?
08:53:30 <thoughtpolice> http://paste.lisp.org/display/42132 <- turn string into function
08:53:39 <thoughtpolice> courtesy of mauke
08:54:37 <byorgey> dmwit: I don't think I said that very clearly.  I just mean that  unsafeCallFunctionNamed is just a more restricted variant of unsafeEvaluateExpression
08:54:48 <RyanN1> Anybody know who the haskell.org GSOC admin(s) are?
08:54:55 <dmwit> byorgey: Is it really, though?
08:54:58 <RyanN1> I think the deadline is in an hour and it looks like we need an update...
08:55:04 <dmwit> The former gets access to your scope magically, it seems.
08:55:25 <byorgey> dmwit: I was assuming the latter had access to your scope as well.
08:55:34 <dmwit> oh
08:55:38 <dmwit> Is that true in hint?
08:55:40 <byorgey> or to whatever scope in which the function in question has been defined.
08:55:48 <byorgey> you can add imports to the hint context
08:56:36 <t7> vim takes like 10 secs to start on my windows
08:56:39 <dmwit> So, to say what I expected: I would expect you have to explicitly interpret a function of type (Environment -> Result).
08:56:42 <t7> i thought its supposed to be super light
08:56:54 <dmwit> And then you would have to pass hint the values that are in scope that you want to be available.
08:57:15 <dmwit> So implicitly getting access to all the things in scope would be quite different to just being able to interpret code.
08:57:24 <kallisti> anyone want to test unsafe-promises for me? I promise it's super safe to use.
08:57:50 <byorgey> dmwit: well, you might have to do it that way if you want to get access to things in the *current* scope, as opposed to some other module which has already been compiled
08:57:56 <byorgey> I'm not really sure
08:58:19 <byorgey> anyway, heading to school now
09:01:25 <dgpratt> t7: vim starts in a split second here (on Win7)
09:01:39 <parcs`> t7: gvim or vim
09:01:46 <t7> err gvim
09:01:55 <parcs`> meh
09:02:13 <dgpratt> t7: same goes for gvim
09:02:27 <parcs`> you should use cygwin+openssh+putty+vim for windows development :)
09:02:37 <adamt> 1 sec for gvim here. Not windows though.
09:02:47 <dgpratt> parcs`: O_o
09:03:21 <t7> i just ssh into my arch box most the time :)
09:04:28 <t7> am i right in thinking the following means 'free variable in environment = the union of all the free variables in each polytype'? http://upload.wikimedia.org/wikipedia/en/math/1/3/6/136aebbd25951472d4bc410a058e686b.png
09:04:41 * hackagebot fb 0.8 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.8 (FelipeLessa)
09:04:43 * hackagebot yesod-auth-fb 1.0.0 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.0 (FelipeLessa)
09:04:46 * hackagebot tls 0.9.5 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.5 (VincentHanquez)
09:04:48 * hackagebot yesod-auth-zendesk 0.2 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-0.2 (FelipeLessa)
09:04:54 <parcs`> bad hackagebot
09:05:33 <t7> wtf is U with crap under it? a forall or something
09:05:55 <danr> t7: probably union
09:06:08 <adamt> why would the union symbol have crap under it?
09:06:17 <luite> union over things
09:06:21 <danr> adamt: it's a union over sets
09:06:25 <luite> similar to the big sigma, sum, sumbol
09:06:27 <adamt> t7: for all is a A flipped on the x-axis.
09:06:28 <luite> symbol
09:06:37 <adamt> danr: Aha.
09:07:12 <danr> adamt: the join in the monad of sets
09:07:23 <t7> so union of all the free vars in every type in environment?
09:07:59 <danr> t7: that's how I would interpret it too
09:09:42 * hackagebot yesod-recaptcha 1.0 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.0 (FelipeLessa)
09:14:00 <sm> why, parcs` ?
09:14:24 <t7> i dont see why env would have any free vars anyway... there are all supposed to be poly types
09:19:42 * hackagebot fb-persistent 0.1.1 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.1.1 (FelipeLessa)
09:22:10 <t7> it does not help they use t for MonoType and a polytype with no foralls :(
09:29:43 * hackagebot aws 0.4.0.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.4.0.1 (FelipeLessa)
09:45:20 <mm_freak> thanks danr
09:46:45 <mm_freak> is there an implementational difference between type parameters and type indices?
09:47:07 <mm_freak> to take agda as an example:  data Vec (X : Set) : Nat -> Set
09:47:20 <mm_freak> there is a type parameter X and a type index of type Nat
09:49:18 <mm_freak> put differently:  do i /need/ type indices?
09:49:35 <mm_freak> do they add some expressiveness that i can't get with type parameters?
09:54:41 <hpc> mm_freak: without indices, you lose even GADTs i think
09:54:43 * hackagebot digestive-functors 0.3.0.2 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.3.0.2 (JasperVanDerJeugt)
09:57:05 <mm_freak> nevermind, i just figured it out
09:57:10 <mm_freak> thanks though
10:04:44 * hackagebot crypto-conduit 0.3.2 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.3.2 (FelipeLessa)
10:05:35 <sidux> http://onibushacker.forum-livre.com/
10:06:54 <Cale> sidux: ?
10:08:34 <eacameron> so there are two decent redis bindings in hackage...how would I go about seeing which one is best to use (more actively maintained, more usage in the community, etc.)?
10:08:58 <lispy> mm_freak: I'm struggling with understanding that distinction right now too.  What did you learn?
10:09:45 * hackagebot monad-control 0.3.1.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.1.2 (BasVanDijk)
10:10:41 <mm_freak> lispy: just try to write the nil constructor for Vec without the index
10:11:07 <mm_freak> as a type parameter the Nat argument is type-bound, not constructor-bound
10:12:17 <hiptobecubic> Has anyone tried using accelerate to do anything substantial?
10:14:33 <lispy> mm_freak: ah, so it's about "scope"
10:14:53 <lispy> hiptobecubic: no, but I wish I had more freetime to explore it :)
10:14:55 <mm_freak> basically
10:15:06 <lispy> mm_freak: yeah, that makes sense
10:23:29 <ment> @hoogle (a -> a) -> a -> a
10:23:29 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:23:29 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:23:30 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:30:20 <copumpkin> ment: it's a natural number!
10:31:07 <nart> hi
10:31:36 <adamt> hello nart
10:33:50 <edwardk> re ryan newton trying to get in touch with me the other day, everything has been taken care of
10:35:28 <hayashi> @pl \f g a b c -> g (f a b ) c
10:35:29 <lambdabot> flip ((.) . (.))
10:39:46 * hackagebot regex-applicative 0.2 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.2 (RomanCheplyaka)
10:44:46 * hackagebot unsafe-promises 0.0.1.1 - Create pure futures using lazy IO.  http://hackage.haskell.org/package/unsafe-promises-0.0.1.1 (AdamCurtis)
10:47:45 <kallisti> edwardk: are all the "unsafe" warnings warranted here?
10:47:52 <kallisti> (in the package above)
10:48:48 <edwardk> kallisti: they are as unsafe as unsafeInterleaveIO, so, yes
10:49:35 <Yohanskell> Hello World of Haskell !!! I love you !!! :P
10:49:44 <kallisti> then why not rename all of the Prelude lazy file IO functions to unsafe*
10:50:31 <kallisti> I suppose it's different when you're executing arbitrary IO computations?
10:50:45 <rwbarton> well the obvious reason is that the names of the Prelude lazy file IO functions are specified by the report
10:51:13 <kallisti> yes, there is that.
10:51:18 <Yohanskell> kallisti: "Are you Greek?""
10:51:30 <kallisti> nope.
10:51:43 * kallisti is American.
10:51:46 <rwbarton> unsafeInterleaveIO is in a gray area unsafety-wise
10:52:08 <Yohanskell> kallisti: "I am Greek nice to meet you :) '
10:52:16 <kallisti> hi. :)
10:52:27 <luite> edwardk: i applied as mentor for gsoc yesterday because i realized that shaprs proposal is far closer to what i already have than i thought (he showed me the proposal). don't know if it's still possible to add me, or if it would be useful, but if it is, can you accept my application?
10:52:33 <ion> ‚ÄúHello‚Äù
10:52:35 <kallisti> rwbarton: I am inclined to agree.
10:52:54 <edwardk> luite: checking
10:53:13 <edwardk> accepted
10:53:19 <luite> edwardk: otherwise I'll just informally help him on irc :)
10:53:34 <edwardk> luite: this way you'll likely at least get a t-shirt for your time ;)
10:53:34 <Yohanskell> kallisti: i am new to haskell , but i know  python i wish it will be so easy as python was for a newcomer... What do you think ?
10:53:51 <luite> edwardk: yay t-shirt!
10:54:01 <kallisti> rwbarton: I don't really see how waiting on an IO thread to produce a result is much different from waiting on any other computation to complete; in either case there's a possibility of non-termination
10:54:53 <kallisti> it does require you to be a little more careful, but that's the extent of the unsafety.
10:55:19 <edwardk> Yohanskell: i'd expect you'll find haskell to be a bit different experience than picking up yet another imperative language, but that is a good thing =)
10:55:42 <kallisti> Yohanskell: Python is easy to learn because there's not much to it.
10:55:49 <kallisti> Haskell has a lot to it.
10:55:51 <nart> is it possible to connect 2+ sources to a single sink using Data.Conduit ?
10:56:04 <kallisti> nart: how do you expect that to behave?
10:56:08 <edwardk> With most languages you're just learning a few new quirks of syntax and semantics. Haskell turns everything on its head
10:56:40 <mm_freak> i have the following constructor in my Expr type for the type of types:  Typ :: Integer -> Expr
10:56:52 <mm_freak> Typ 0 corresponds to Set 0 in agda, etc.
10:57:13 <mm_freak> what would i do to allow universe polymorphism?  just turn the Integer into an Expr itself?
10:57:13 <nart> kallisti: i would expect that it pulls one piece of data at time
10:57:15 <Yohanskell> edwardk: i have heard that haskell has features from the future
10:57:26 <mm_freak> sounds reasonable to me
10:57:33 <nart> kallisti: i know that it's not possible, to do but i don't know how to solve my problem :S
10:57:44 <rwbarton> well, what is your problem
10:57:47 <adamt> Yohanskell: I think that claim has some logic flaws to it. :)
10:58:12 <edwardk> Yohanskell: it at least has some features that I hope will still be around in languages in the future ;)
10:58:24 <nart> i have 4+ threads downloading different part of a file, i need to write the data pulled in a single file
10:58:29 <kallisti> nart: it's possible to alternate between the 2 as sources, but I don't think you can pull from both whenever they have data. it might be possible though
10:58:44 <Yohanskell> edwardk: That's more precise :)
10:59:46 <Yohanskell> kallisti: If Haskell has a lot to it... Does it have a lot (long) learning curve ??? Wil i have to bleed to make a usefull programm in other words...?
11:00:36 <byorgey> Yohanskell: it does have a long learning curve.
11:00:43 <Yohanskell> kallisti: Sorry for the As most programmers i tend to be more lazy than my language of choice :P
11:00:45 <byorgey> Yohanskell: as for the second part, it depends what you mean by "useful".
11:00:50 <kallisti> depends on what you mean by useful. It takes a long time to really learn though.
11:00:57 <kallisti> ...er, yes.
11:00:58 <td123> Yohanskell: if you're coming from the imperitive world, you will have to change the way you think about problems, which makes it hard but worthwhile imo
11:01:03 <kallisti> everyone beat me to it. :P
11:01:05 <mm_freak> Yohanskell: while it pays off, it takes some time to learn
11:01:15 <adnauseam> Yohanskell: yes
11:01:30 <Yohanskell> I see
11:01:35 <adamt> It has to get worse, before i can get better. ^^
11:01:45 <adnauseam> the benefits of fp become apparent only after you master it
11:01:50 <nart> kallisti: how would you do this "i have 4+ threads downloading different part of a file, i need to write the data pulled in a single file" ?
11:02:09 <nart> kallisti: using conduits
11:02:19 <kallisti> nart: by using existing concurrency abstractions.
11:02:24 <mm_freak> the evolution of the average haskell programmer undergoes these three stages:  1. fighting with the type system, 2. knowing how to satisfy the type checker, 3. using the type system to make your life easier (you won't notice that in the haskell world, but you will notice it when you go back to other languages)
11:02:25 <adamt> adnauseam: That's a bit black/white. There's no reason why people should be able to understand (at least some) fp-benefits, before starting out.
11:02:29 <kallisti> that feed into a conduit.
11:03:13 <Yohanskell> Thank you guys , I assume that i will need aaround a year or a little more to become fluent in haskell, i hope that is corrent while having in mind that i come from a python background
11:03:24 * kallisti understood the benefits of functional programming after reading SICP and learning Scheme, before mastering much of anything.
11:03:57 <mm_freak> adnauseam: i missed folding in imperative languages quite early
11:04:12 <mm_freak> and quite early i started to develop a hate of for loops
11:04:51 <mm_freak> but i never missed the type system in my early days
11:04:53 <adnauseam> adamt: aye, most introductions include the obvious beneifts, i assumed he's already read a few :p
11:04:54 <mm_freak> now i do
11:05:27 <adnauseam> mm_freak: yeah man, maybe "mastering" wsn't the word, but you know what i mean
11:05:56 <adamt> adnauseam: I wouldn't be here if i didn't think FP would give me any benifits. Hehe. :)
11:08:56 <adnauseam> :> aye, most cases it's just encouragement that we come looking for, especially when it gets dark and cold as you enter the woods of FP
11:09:14 <xraycat> rasfar: do you have a minute?
11:09:18 <adnauseam> mm_freak: i'm still trying to grasp folding o_0 i come from java :|
11:11:13 <gabor> template haskell question... is it possible to write a quasiquoter that does not receive a string, but a non-typechecked expression?
11:11:34 <kallisti> adnauseam: folding takes a function that accumulates a parameter by iterating over every element of a list.
11:12:17 <kallisti> gabor: the haskell-src-meta package can parse a string into a Haskell syntax tree.
11:12:26 <kallisti> among other things.
11:13:15 <gabor> I know, but you lose the benefits of GHC's error reporting for syntax errors
11:14:09 <kallisti> what do you mean?
11:14:20 <gabor> kallisti: I am thiking along the lines of [e| a b c |]
11:14:34 <kallisti> okay, and a b and c are haskell terms?
11:14:39 <gabor> yes
11:15:34 <gabor> [e| a b -> |] is a syntax error and would be reported as usual
11:16:19 <kallisti> there's report from template-haskell that does error reporting.
11:16:51 <gabor> [e| ... |] would only suppress type checking, otherwise behave like [| a b c |]
11:16:53 <kallisti> so when you use parseExp, if you get an error, you pass the error message to TH.report
11:17:21 <gabor> kallisti: thanks I'll have a look
11:17:36 <kallisti> gabor: I'm not sure how to suppress typechecking in the way you describe though.
11:17:45 <Yohanskell> I think Haskell has not syntactic sugar , it has syntactic diabetes... :P
11:18:05 <kallisti> heh
11:18:09 <kallisti> the sugar is delicious though.
11:18:21 <moonstone> @type map
11:18:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:19:38 <mm_freak> adnauseam: think of folding as putting an operator between list elements
11:19:51 <moonstone> @pl \x y -> x y
11:19:51 <lambdabot> id
11:20:00 <mm_freak> foldr (+) z [a, b, c] = a + (b + (c + z))
11:20:15 <mm_freak> foldl (+) z [a, b, c] = ((z + a) + b) + c
11:20:33 * adnauseam saves your lines to a file 
11:20:37 <kallisti> gabor: I'm not sure if it's relevant to your problem, but you can look at interpolatedstring-perl6 for an example of how to deal with Haskell source. That's the code I'm going off of.
11:22:35 <hpaste_> zaphix pasted ‚Äúfresh ghc 7.4.1 install problems‚Äù at http://hpaste.org/67338
11:23:06 <zaphix> Yeah, I'm not having any luck with a fresh ghc 7.4.1 install and some basic package management :(
11:24:56 <stj> I can't install darcs through cabal, there is weird dependency mess... how can I sort this out?
11:24:57 <jonkri> how come, even though i have stm-2.3 installed, i cannot import "Control.Concurrent.STM.TVar (modifyTVar)"? http://hackage.haskell.org/packages/archive/stm/2.3/doc/html/Control-Concurrent-STM-TVar.html
11:24:59 <hpaste_> stj pasted ‚Äúcabal install darcs‚Äù at http://hpaste.org/67339
11:25:03 <jonkri> ghc 7.0.4
11:25:07 <rwbarton> zaphix: cabal update maybe?
11:25:36 <zaphix> rwbarton: yeah, tried that already =(
11:25:37 <stj> I did cabal update
11:25:56 <zaphix> rwbarton: the errors at the end of my paste are also quite strange to me, since I can't even build cabal-install normally
11:26:48 <TheLemonMan> hrm, i have a large-ish list of tuples and i access it by index, is Data.List the best structure for this task ?
11:26:57 <rwbarton> hmm I don't know. haven't tried 7.4.1 myself. your two issues look very similar though
11:27:19 <zaphix> rwbarton: yeah, there are a couple of tickets about things potentially related, but they say they've been fixed
11:27:40 <zaphix> if i don't do this cabal stuff and try to just install other packages, I get old versions of the array package showing up :(
11:27:53 <byorgey> stj: the version of 'darcs' on Hackage does not build under ghc 7.4.
11:28:09 <byorgey> stj: you can try 'darcs-beta' instead.  Or install darcs through your OS's package manager, perhaps.
11:28:15 <rwbarton> right, i think a certain amount of this is expected due to 7.4 but shouldn't cabal-install 0.14.0 work
11:28:59 <byorgey> zaphix: are you trying to install the newest version of cabal-install?
11:29:14 <stj> byorgey: I'll go with beta, thanks!
11:29:19 <zaphix> Yes, although that's not my primary goal =), I just happened to get stuck at that point
11:29:23 <byorgey> zaphix: if so, you must specifically request that version, since 0.10.2 is still marked on Hackage as the "preferred" version
11:29:26 <KitB> Can anyone point me at a sensible place to ask questions about pandoc?
11:29:36 <byorgey> zaphix: cabal install cabal-install-0.14.0
11:29:41 <zaphix> byorgey: right -- but even if i snag the cabal-install tarball, I can't build it by hand
11:29:54 <byorgey> KitB: there is a pandoc mailing list which is quite active.  It should be linked from the pandoc website.
11:30:18 <KitB> byorgey: Thanks
11:30:24 <KitB> Should've checked really, eh?
11:30:48 <zaphix> byorgey: explicitly selecting that version does seem to be working; let's see if a new cabal-install actually does anything to fix the other issue =)
11:30:57 <zaphix> byorgey: (thanks))
11:35:54 <kallisti> hm, if you add an (orphan) IsString instance for Builder you can actually use it with the new interpolatedstring-perl6
11:36:27 <rasfar> hey xraycat, yeah i have even several minutes; i got your code from the paste in our private chat.  checking it out now...
11:37:01 <maurer> I'm trying to figure out how to convince a haskell program to load an STG node as a string input.
11:37:28 <maurer> unsafeCoerce doesn't seem to do the trick, because a Ptr is still boxed
11:40:51 <scooty-puff> is there a predefined data type with a a Data instance that is a noop?
11:41:06 <scooty-puff> looking for: newtype NoData a = ...; instance Data (NoData a) where ...
11:41:13 <scooty-puff> forall a (not requiring Data a)
11:41:32 <hpaste_> scooty-puff pasted ‚ÄúNoData‚Äù at http://hpaste.org/67340
11:41:46 <scooty-puff> have that right now, but not sure about so many of the error calls
11:41:53 <nexion> I'm a little confused about specifying the port in Network.Socket's SockAddrInet. The type is newtype PortNumber = PortNum Word16 deriving ( Eq, Ord ), and I if I specify the port as (PortNum 9800), it sets it incorrectly (not sure how yet), but if I just enter 9800, then it works. What could it be?
11:44:45 <frigga> Would it be worthwhile to refactor hmatrix to use vectors from the vector package under the hood?
11:45:23 <rwbarton> nexion: yes, it is very confusing. the argument to the PortNum constructor is supposed to be adjusted for host/network byte order difference
11:45:38 <fmap> iirc PortNum assumes port is already converted to network byte order while it's Num instance does not
11:45:41 <rwbarton> but PortNumber has a Num instance which takes care of this for you
11:45:55 <nexion> makes sense
11:45:56 <nexion> ty
11:47:42 <timthelion> is there a data Null = Null or something similar?  I have a Maybe that I don't need, and it looks kind of strange in the type defs to write like (Maybe Bool) when the value will ALWAYS be Nothing...
11:48:34 <qnikst> Void?
11:48:40 <abernstein> timthelion: or ()
11:48:50 <gabor> kallisti: I am interested in a non-typechecked expression AST because some DSLs may have a different type-checking discipline but would share the Haskell expression syntax. As such I'd like to employ "Plus :: Arith Int (Arith Int Int)" in a function position into the AST, which makes sense for my DSL but the haskell type checker rejects it. I believe wiring up a non-typechecked quoter in TH would be easy (technically, albeit not so politically).
11:49:27 <timthelion> abernstein: I can do Maybe ()?
11:49:31 <kallisti> yeah it sounds like you may want to use your own parser.
11:49:40 <srhb> :t ()
11:49:41 <lambdabot> ()
11:49:44 <srhb> :t Maybe ()
11:49:45 <lambdabot> Not in scope: data constructor `Maybe'
11:49:52 <srhb> Oh, of course
11:50:11 <timthelion> :i Data.Maybe :t Maybe ()
11:50:17 <timthelion> hmmph
11:50:30 <srhb> :i Maybe () -- though :-)
11:50:33 <srhb> At least in your ghci.
11:50:46 <qnikst> :t Just ()
11:50:46 <lambdabot> Maybe ()
11:50:51 <srhb> Right.
11:51:03 <monochrom> Maybe (Maybe (Maybe (Either () ())))
11:51:14 <srhb> But why do you need this? Seems super quirky to have a Maybe that is in fact always Nothing.
11:51:31 <srhb> Even if you wanted to always return the exact same value, () on its own would make more sense.
11:52:02 <timthelion> srhb: because I have a set of functions that can send a signal through an object, but in this set of functions they don't.  In another set of functions using the same object type, they do...
11:52:14 <srhb> Aha.
11:53:06 <monochrom> you can use undefined too
11:53:32 <qnikst> unless smth force it
11:53:33 <zaphix> (or error)
12:04:15 <sclv_> any #yesod devels around?
12:25:28 <rs46> how would one do a parallel filter using the Haskell strategies ?
12:30:10 * hackagebot filestore 0.4.2 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.4.2 (JohnMacFarlane)
12:30:37 <hpc> rs46: parallelize by chunks, then concat
12:31:45 <hpc> rs46: dunno if that's a useful operation; the filter would have to be expensive enough to counter the extra cost of chunking and joining
12:32:00 <rs46> hpc: ok..
12:32:10 <rs46> thanks.
12:44:29 <kallisti> @hoogle showq
12:44:29 <lambdabot> No results found
12:44:33 <kallisti> @hoogle ShowQ
12:44:34 <lambdabot> No results found
12:47:47 <timthelion> I remember when I was in grade school, my dad was lead developer for MS Works, and my best friends dad wrote printer drivers...  When he explained to me that his dad made the printer button in word, I asumed his father must be stupid, because "his dad just added one button, while my dad wrote the whole thing";)  ... now I'm implementing an Undo function, and simple things turn out to be surprisingly hard :D
12:50:43 <Fly_> Hi
12:50:48 <Fly_> Im noob and I need help
12:50:55 * Clint nods.
12:51:45 <timthelion> Fly_: 400mg asprin, 3 weeks in a cruise on the carabiean, ample bed rest and fluids.
12:53:12 <adamt> Fly_: Well the best start would probably be to ask a question then. ;)
12:54:52 <timthelion> adamt: perhaps he's not a native english speaker, and that was his question.  Perhaps he wants to know how to interact with gnomes documentation window in GTK, or how to find the docs on haskell.org, or how to implement a man page using cabal.
12:56:11 <adamt> timthelion: And all that is mighty fine, but if he can't communicate a question to us, what does it matter than we try explaining random answers to him? :)
12:57:11 <timthelion> adamt: ach jo, the great questions of life. to be or not to be, to talk to random trolls on the internet, or get up and go pee.
12:58:32 <hpaste_> kallisti pasted ‚Äúwhat?‚Äù at http://hpaste.org/67341
12:58:38 <kallisti> ^ ...what?
12:59:28 <Cale> kallisti: Which version of ghc do you have?
12:59:33 <kallisti> 7.0.4
12:59:34 <geekosaur> you have multiple versions of pretty, which is a bootlib
12:59:34 <timthelion> kallisti: cabal sucks, you need cabal-dev in order to install two pretties at the same time
12:59:44 <geekosaur> and a diamond dependency
12:59:48 <int-e> kallisti: I would guess that you reinstalled some boot package.
12:59:51 <kallisti> did this happen because I installed pretty by hand?
12:59:54 <kallisti> yes
13:00:01 <kallisti> silly me.
13:00:11 * hackagebot recursion-schemes 2.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.0.1 (EdwardKmett)
13:00:25 <geekosaur> I think the new cabal-install does a better job of telling you about this kind of thing
13:00:33 <kallisti> how do I fix it?
13:01:05 <geekosaur> ghc-pkg unregister pretty-1.1.1.0
13:01:56 <kallisti> ah right
13:03:17 <Grayshen> What is wrong? import Data.List
13:03:17 <Grayshen> encode :: [a] -> [[(b,a)]]
13:03:18 <Grayshen> encode x = let y = map head . group x
13:03:19 <Grayshen>                z = map length . group x
13:03:20 <Grayshen>            in  zip z y
13:03:23 <burbul> @pl do pf <- pform ; many $ noneOf ",]" ; return $ CombinesPForm pf
13:03:23 <lambdabot> (line 1, column 16):
13:03:24 <lambdabot> unexpected ";"
13:03:24 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
13:04:06 <burbul> do do pf <- pform ; (many $ noneOf ",]") ; (return $ CombinesPForm pf)
13:04:07 <geekosaur> @. pl undo do { pf <- pform ; many $ noneOf ",]" ; return $ CombinesPForm pf; }
13:04:07 <lambdabot> many . (noneOf ",]" >> return) . CombinesPForm =<< pform
13:04:07 <rwbarton> Grayshen: the type signature is wrong in two ways
13:04:24 <rwbarton> if you delete it you can ask ghci for the correct one, or you can try to work it out yourself
13:04:27 <burbul> @pf do pf <- pform ; (many $ noneOf ",]") ; (return $ CombinesPForm pf)
13:04:27 <lambdabot> Maybe you meant: bf pl
13:04:52 <rwbarton> @undo do { pf <- pform ; many $ noneOf ",]" ; return $ CombinesPForm pf }
13:04:52 <lambdabot> pform >>= \ pf -> many $ noneOf ",]" >> return $ CombinesPForm pf
13:04:57 <burbul> geekosour: thanks!
13:05:06 <rwbarton> @. @pl @undo do { pf <- pform ; many $ noneOf ",]" ; return $ CombinesPForm pf }
13:05:07 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
13:05:11 <rwbarton> bah you fooled me
13:05:24 <burbul> I was trying to see if there was a nice way of doing it without a lambda-expression
13:05:26 <rwbarton> @. pl undo do { pf <- pform ; many $ noneOf ",]" ; return $ CombinesPForm pf }
13:05:27 <lambdabot> many . (noneOf ",]" >> return) . CombinesPForm =<< pform
13:06:15 <burbul> When you want to parse a fixed expression and then the thing you're interested in, the syntax works really nicely:
13:06:20 <burbul> string "*" >> whites >> string "<-" >>  liftM AllFrom int
13:06:42 <rwbarton> @. pl undo do { pf <- pform ; many $ noneOf ",]" ; return (CombinesPForm pf) }
13:06:43 <lambdabot> many . (noneOf ",]" >>) . return . CombinesPForm =<< pform
13:06:45 <burbul> but when you want to parse the thing you're interested in and then a string to throw away, there doesn't seem to be anything comparably nice...
13:07:08 <rwbarton> @type (*>)
13:07:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:07:13 <rwbarton> @type (<*)
13:07:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:07:49 <parcs`> "zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Cofree (Base t)) a) -> a) -> t -> a"
13:07:55 <parcs`> wow there actually is such a thing
13:07:58 <byorgey> burbul: you can use <* for that
13:08:01 <burbul> @rwbarton: That looks interesting. thanks!
13:08:01 <lambdabot> Unknown command, try @list
13:08:18 <parcs`> i always though zygohistomorphic prepromorphisms were some kind of joke
13:08:43 <rwbarton> Just because they are a joke doesn't mean they can't also exist.
13:08:47 <rwbarton> Or vice versa.
13:09:23 <doc123> dadasd
13:09:26 <fmap> Grayshen: btw you can write it clearer with (&&&) from Control.Arrow: map (length &&& head) $ group x
13:10:29 <parcs`> by joke i mean the name didn't refer to anything meaningful, that someone just combined a bunch of latin prefixes
13:11:06 <burbul> liftM CombinesPForm pform <* many (noneOf ",]")
13:11:11 <burbul> Looks really nice -- thanks !
13:12:16 <hpaste_> ‚ÄúJake Bruenker‚Äù pasted ‚ÄúIndentation in where?‚Äù at http://hpaste.org/67342
13:12:49 <`Jake`> my question is in the code
13:13:13 <kallisti>     Cabal-1.10.2.0-28687902dc4d94596b240bed96059ef8 is unusable due to missing or recursive dependencies:
13:13:16 <kallisti>       pretty-1.0.1.2-450dd354ad97e58d9fc4b0e19894ef62
13:13:47 <rwbarton> you mean should you indent the comment?
13:13:59 <adamt> That is some nice version-numbers.
13:14:07 <kallisti> how do I fix this..
13:14:31 <`Jake`> no, the comment is just to ask the question, and it's just about style, obviously, it compiles either way
13:14:45 <rwbarton> I don't understand what the question is though
13:14:56 <rwbarton> I don't see any empty lines
13:15:09 <kallisti> ghc-pkg: unregistering pretty-1.0.1.2 would break the following packages: template-haskell-2.5.0.0 (use --force to override)
13:15:16 <rwbarton> you mean, if line 3 is empty should you make it be a bunch of spaces instead?
13:15:18 <kallisti> should I unregister this anyway, and then reinstall template-haskell?
13:15:28 <`Jake`> yeah, exactly
13:15:38 <`Jake`> because of good coding behaviour or something
13:16:26 <byorgey> kallisti: no, that is unlikely to help.  Looks like your global package database is hosed.
13:16:43 <rwbarton> personally I would leave it empty because tools like git will warn when I have lines ending in whitespace
13:16:49 <rwbarton> I wouldn't expect any strong opinions on the matter though
13:16:52 <`Jake`> ok, thanks
13:17:08 <kallisti> byorgey: ...why does this keep happening
13:17:51 <fmap> can't remember any code style which encourages trailing whitespaces
13:17:55 <jeff_s_> Someone suggested to me a while ago that I should put common imports into one file, like Imports.hs, and then import just that file's module. However, that doesn't seem to be exporting the type constructors. for instance, `Text' is not in scope, but I have "import Data.Text" in my common import file.
13:18:02 <jeff_s_> How do I do this properly, or it not possible?
13:18:12 <byorgey> kallisti: probably because cabal-install breaks things too easily. However, the new version of cabal-install which just came out does a much better job.
13:18:49 <byorgey> jeff_s_: if module A imports module B, anything that imports A does not automatically get B.
13:18:50 <jeff_s_> I'm not sure it's exporting anything at all.
13:18:57 <byorgey> jeff_s_: module A has to explicitly re-export module B.
13:19:15 <jeff_s_> byorgey - Can I re-export everythign in B without typing every name?
13:19:16 <byorgey> jeff_s_: module A ( module B, ... ) where  import B
13:19:21 <jeff_s_> OK excellent!
13:20:19 <kallisti> byorgey: cabal install world perhaps?
13:20:39 <byorgey> kallisti: hmm? what about cabal install world?
13:20:49 <kallisti> maybe it would fix things? I don't know.
13:21:03 <shachaf> Hmm. Could C errno in an unbound thread cause problems?
13:21:05 <byorgey> kallisti: I really doubt it.
13:21:16 <byorgey> kallisti: sadly it sounds to me like you need to reinstall the Haskell Platform.
13:21:30 <shachaf> E.g. checking errno after making a libc call, but having that end up happening in a different OS thread.
13:24:22 <jeff_s_> Hm, so is it possible to export qualified module names? EG something like "module Imports where (module Text) import Data.Text as Text". I'm getting an error that Text.null isn't in scope, so the way I'm doing it isn't quite right (or it's not possible)
13:24:55 <byorgey> not that I know of
13:24:57 <jeff_s_> Er, put the "where" after the exports.
13:25:03 <jeff_s_> OK, thanks anyway.
13:25:30 <jeff_s_> Strangely, it doesn't give an error.
13:25:39 <jeff_s_> using the qualified name in the export doesn't.
13:26:06 <byorgey> jeff_s_: well, I think the qualified name can be used to refer to Data.Text anywhere in the Imports module.
13:26:41 <byorgey> jeff_s_: but the Imports module now exports the *module* Data.Text.  The way you imported it into Imports makes no difference.
13:26:43 <adamt> I have a question that might get religious. I understand how python people can have a preference for mercurial, since plugins can be written in python. Is there a similar reason for a haskeller to use Darcs?
13:27:17 <byorgey> no, I've never heard of anyone writing darcs plugins in Haskell.
13:27:40 <jeff_s_> byorgey - so I would need something like "module Text (export everything from Data.Text) where import Data.Text".
13:28:08 <jeff_s_> er, hm, maybe I'm still misunderstanding. I'll figure it out.
13:28:08 <adamt> byorgey: Thanks. Was just wondering.
13:28:46 <byorgey> jeff_s_: honestly, this whole idea of having an "Imports" module for common imports sounds silly to me.  Just list the imports separately in each module where they are used.  It's not that big of a deal.
13:29:06 <byorgey> and much easier than the contortions you are already having to go through to make the idea work.
13:29:08 <jeff_s_> byorgey - It is becoming a big deal when I am approaching 50 imports.
13:29:27 <byorgey> and you need ALL of those 50 imports in every single one of a large number of modules?
13:29:27 <jeff_s_> Maybe 30, but 50 wouldn't be surprising.
13:30:06 <byorgey> it's still not that big of a deal if you have good tool support, like what the new haskell emacs mode has.
13:30:10 <jeff_s_> No, but I need enough of them that keeping track is a pain in my ass. I'd rather have most of them in one place, because many of them are repeated, such as "import qualified Data.Text as Text".
13:30:18 <dmwit> Is there a way to control what command cabal uses to compile Setup.hs?
13:30:33 <jeff_s_> I'm using Emacs, but I'm unaware of any special assistance for imports.
13:30:56 <jeff_s_> That is, I'm using haskell mode for emacs.
13:30:59 <byorgey> jeff_s_: ok, yeah, I understand.  I just don't think there's a way to do the one imports module and preserve qualifications.
13:31:05 <dmwit> Not having read back; can't you just have a module that re-exports whatever 50 modules you need everywhere?
13:31:13 <dmwit> One line of "import AllTheThings" doesn't seem bad.
13:31:19 <jeff_s_> dmwit - kind of yes, but not with qualified names.
13:31:27 <dmwit> Yes, not with qualified names.
13:31:30 <dmwit> That's annoying.
13:31:51 <jeff_s_> I think this would be a great Haskell prime suggestion. I'll work on it.
13:32:26 <jeff_s_> At least I can factor out 10 or so imports. It'll clean up my source quite a bit.
13:32:59 <adamt> Doesn't ghc warn about unnessecary imports?
13:33:14 <jeff_s_> I've seen it complain about redundant imports.
13:33:16 <burbul> @. pl undo do { r <- rule; whites1; fc <- flow_constraint; return (r, fc) }
13:33:16 <lambdabot> (`fmap` (whites1 >> flow_constraint)) . (,) =<< rule
13:33:17 <dmwit> Like, I want to add -DUsingTheNewVersionOfHaXml or something to the ghc --make Setup.lhs; is that possible?
13:33:43 <burbul> Hmmm.. that's pretty cryptic
13:33:56 <burbul> I want to combine a Parser a and a Parser b into a Parser (a,b)
13:34:14 <navaati> hi
13:34:15 <dmwit> burbul: What's wrong with the do-block you wrote?
13:34:23 <dmwit> That's what I would write.
13:34:25 <burbul> Is there any monad/functor/applicative *thing* which does that?
13:34:46 <dmwit> liftM2 (,) rule (whites1 <* flow_constraint), probably
13:34:56 <dmwit> But I wouldn't say that's necessarily better.
13:35:01 <burbul> dmwit: there's nothing wrong with it, but I'm trying to make myself use higher order methods where possible -- it seems like an important part of learning Haskell.
13:35:02 <dmwit> :t (<*)
13:35:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:35:14 <navaati> if i store a ForeignPtr in an IORef, even if the reference to the ForeignPtr himself goes out of scope, the finalizer won't be executed, right ?
13:35:16 <burbul> liftM2 -- thanks!
13:35:18 <byorgey> jeff_s_: chrisdone has been doing a bunch of hacking on haskell-mode recently.  He had a screencast showing off some of the new features, but I can't seem to find it at the moment.
13:35:46 <byorgey> jeff_s_: one of the features was auto-formatting and auto-sorting for import lists, along with a keybinding to quickly move to the import list and back from elsewhere in the file
13:36:57 <jeff_s_> byorgey - that sounds great! I'll watch it if you find it, definitely.
13:38:01 <byorgey> jeff_s_: this might be it: http://www.youtube.com/watch?v=E6xIjl06Lr4
13:38:12 <byorgey> I'm not sure though because I'm blocked from youtube during the day =)
13:38:46 <jeff_s_> Hah, that's practical, actually.
13:39:06 <jeff_s_> I'll watch it later; I don't have sound at work.
13:39:10 <zuserm> Hello. Anyone have experience with HaRe?
13:40:48 <zuserm> I keeps complaining that it can't find Prelude, and I don't seem to be able to add files.
13:43:27 <timthelion> is there a way to search hoogle for a list of currently unused infix opperators?
13:43:54 <kallisti> byorgey: after unregistering and install enough stuff I seemed to have fixed it.
13:44:53 <byorgey> kallisti: oh, wow, congrats!
13:45:39 <byorgey> zuserm: is it saying something about how Prelude is in both base and haskell98?
13:46:06 <byorgey> timthelion: there are an infinite number of currently unused infix operators.
13:46:21 <zuserm> byorgey: no, it just says source files missing
13:46:37 <byorgey> zuserm: ok, I don't know then.  I think HaRe is somewhat old and bitrotted.
13:47:01 <zuserm> it's too bad, it looks like it could be a nice tool
13:47:03 <timthelion> byorgey: what about unused bellow length x?
13:47:23 <byorgey> timthelion: I don't know of a way to do that.
13:47:32 <lispy> I just realized that pattern guards made it into Haskell2010.  That makes my day :)
13:48:58 <mgsloan> timthelion: here's a bunch of used ones: http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers.html
13:50:00 <zuserm> byorgey: hackage lists the last update to HaRe as Feb 10, 2012, which is fairly recent
13:50:54 <timthelion> It seems to me, that when assigning new ones, it's enough to be able to search for them and see if they are used. but neither hoogle, nor hayoo, give me a result for +-+, does that mean I can use it?
13:51:11 <byorgey> zuserm: oh! so it does.
13:51:41 <byorgey> zuserm: can you paste the exact error output you are getting on hpaste.org?  I am curious
13:51:52 <zuserm> timthelion: hayoo says it's in HaskellForMaths, but feel free to use it anyway
13:52:17 <byorgey> timthelion: you can use it even if another package is using it too.  It doesn't really matter.
13:52:49 <hpaste_> zuserm pasted ‚ÄúHaRe error‚Äù at http://hpaste.org/67344
13:52:54 <byorgey> It only matters if people will want to use your operator together with a same-named operator from somewhere else.
13:53:30 <kallisti> > description <$> lookupSequence [1,1,2,3,5,8]
13:53:33 <lambdabot>   Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1."
13:54:16 <kallisti> pretty "referentially transparent"
13:54:30 <byorgey> zuserm: oh, hmm, looks like HaRe is using some sort of custom build system
13:54:48 <byorgey> zuserm: are you following some sort of README/instructions?
13:55:45 <zuserm> http://www.cs.kent.ac.uk/projects/refactor-fp/hare/README_28062010.txt
13:56:05 <byorgey> ok.
13:56:16 <byorgey> we've reached the limit of my knowledge then, sorry
13:56:19 <zuserm> hmm, I'm using neither the ghc version or the vim version it recommends
13:57:18 <zuserm> yeah, I guess I should probably just try with the recommended versions and see if things work out
14:04:43 <nart> i'm using conduits to build a multi part threaded file downloader
14:04:57 <nart> i have 4+ threads that pull different parts of the file
14:05:22 <nart> i'm connecting these 4+ source to a sink that pull the data and push it into a channel
14:05:39 <nart> with this format, (position, bytestring)
14:05:54 <nart> then i have a thread that read the channel and seek the file and write the data
14:06:08 <nart> do you think this approach is correct ?
14:06:50 <causative> what's wrong with ftp
14:07:20 <nart> causative: ?? what do you mean ?
14:07:52 <causative> why are you making a new file downloader instead of re-using an existing one?
14:08:18 <nart> learning purpose
14:10:07 <nart> it does work, but i would like to know if there is a better approach
14:14:14 <Grayshen> I am getting the feeling haskell is one of those learning curves; where you struggle for a while but one day, it all clicks
14:14:31 <EvanR> meh
14:14:56 <int-e> oh to be young and optimistic again ...
14:16:04 <byorgey> Grayshen: Almost, except there is no one single "click".  There are many clicks of varying sizes, arranged in a fractal pattern over time. =)
14:17:50 <burbul> I've become a bit confused about what's going on with a specific monad transformer -- I'd be grateful if whoever has a moment could look at http://hpaste.org/67345 . (thanks in advance!)
14:18:05 <JoeyA> If I move my jaw from side to side, I get a clicking sound in my head.
14:18:27 <hpaste_> dzhus pasted ‚Äúencoding package broken?‚Äù at http://hpaste.org/67346
14:18:43 <burbul> Actually wait... the lift must be lifting into the IO monad
14:18:56 <burbul> if you have ErrorT String IO Int
14:19:25 <burbul> The first lift would push you  into the IO monad, and the next one into the ErrorT String IO Int monad, right?
14:19:25 <JoeyA> dzhus: Are you on Fedora?  My first guess is that SELinux is being a jerk.
14:19:31 <geekosaur> dzhus, your /tmp may be mounted noexec
14:19:33 <qnikst> dzhus: there is prebuild stuff in encoding
14:19:34 <JoeyA> (and not letting you execute binaries in /tmp)
14:19:52 <byorgey> burbul: liftM :: (Bytestring -> [Text]) -> IO Bytestring -> IO Text
14:20:15 <byorgey> burbul: and yes, the outer lift takes you from IO to ErrorT String IO
14:20:24 <nart> gosh, the code i have written feel so imperative
14:20:34 <byorgey> burbul: note that liftM has nothing to do with monad transformers, it just lifts a non-monadic function to work over a monad.
14:20:45 <qnikst> dzhus: rm -rf dist/ ; will help
14:21:03 <byorgey> burbul: whoops, I meant  ... -> IO [Text]  of course
14:21:12 <burbul> thanks!
14:21:39 <dzhus> qnikst: nope
14:22:56 <burbul> One related question... is there any difference between these?
14:22:57 <burbul>        l1 <- lift (liftM (T.lines . decodeUtf8) . B.readFile $ file)
14:22:57 <burbul>        let l2_lines = liftM (T.lines . decodeUtf8) . B.readFile $ file
14:23:11 <JoeyA> Can you try creating an empty file in the same directory as the offending binary, chmod +x ing it, and executing it?
14:23:25 <byorgey> burbul: yes
14:23:28 <JoeyA> (just to rule out not being able to execute binaries in that directory).
14:23:45 <byorgey> burbul: in the first one, l1 has type  [Text].  In the second, l2_lines has type  IO [Text].
14:23:57 <eacameron> I don't understand the example in this documentation http://hackage.haskell.org/packages/archive/hedis/0.4.1/doc/html/Database-Redis.html - what does the `liftIO` do? (I'm still trying to grapple with liftIO!)
14:24:42 <burbul> Hmmm... I'm a bit confused. I thought that the do block was in the (ErrorT String) monad
14:25:10 <JoeyA> eacameron: liftIO lets you perform IO computations (like printing to standard output) in other monads.
14:25:15 <serialhex> you know, i havnt done much programming in haskell, but just *learning* to program in haskell i feel smarter....
14:25:19 * hackagebot sgf 0.1.2 - SGF (Smart Game Format) parser  http://hackage.haskell.org/package/sgf-0.1.2 (DanielWagner)
14:25:30 <JoeyA> Only some monads let you do that, namely those with a MonadIO instance.
14:25:44 <burbul> Why does l1 not have type IO [Text]? is the do block actually in the ErrorT String IO monad? (and is there an easy way to check)
14:26:35 <eacameron> JoeyA: ok so liftIO is a function of generic monads that operates in IO. So any monad that is an instance of Monad can use it?
14:27:08 <otters> any instance of monadIO
14:27:08 <JoeyA> Any monad that is an instance of MonadIO lets you use it.
14:27:10 <otters> MonadIO
14:28:15 <eacameron> JoeyA: otters: I get it! thanks!
14:28:39 <otters> how does lambdabot's instances feature work? cause I cannot for the life of me get GOA to install and I wonder if there's an easier way
14:34:55 <byorgey> burbul: ErrorT String  is not a monad.  ErrorT String IO  is a monad.
14:46:07 <burbul> thanks
14:46:29 <burbul> But is there a way to check which monad a particular do block is in?
14:46:49 <burbul> hmmm.. actually, I can just read it out of the type signature, can't I.
14:47:57 <dmwit> yuuuup
14:48:47 <TheLemonMan> i guess overloaded data constructors are forbidden in haskell
14:49:56 <rasfar> i'm trying to use a Haskell binary on my shared hosting webserver
14:50:00 <Cale> burbul: or if you know which monad any of the actions in the block are in, it's got to be the same monad as that
14:50:15 <rasfar> (i realise this is probably a bad idea given the large size of the executable, but...)
14:51:04 <rasfar> it is the minimal CGI code, putStr "Content-Type: text/html\n\nHELLO!\n"
14:51:16 <kallisti> > sort [(),(),()]
14:51:17 <lambdabot>   [(),(),()]
14:51:19 <rasfar> i have a C program for comparison, and there is no diff in the outputs
14:51:23 <acowley> rasfar: it's a fine idea if you compiled and linked the executable on a very similar OS
14:51:40 <rasfar> both stripped 32-bit binaries (on a 64-bit server), linux
14:52:06 <rasfar> funny thing is I have an older test case (also compiled from GHC), the only difference being it was compiled on 64-bit linux
14:52:19 <rasfar> (also, i've get hSetBuffering set to NoBuffering)
14:52:52 <rasfar> just wondering if gcc by default inserts some code which makes 32-bit binaries 643-bit friendly, that GHC maybe doesn't include?
14:53:02 <eacameron> This line doesn't work (obviously), what am I missing? `(first:rest) <- getLine >>= words`
14:53:03 <rasfar> s/643/64/
14:53:25 <rwbarton> should be   fmap words getLine
14:53:35 <rwbarton> since words does not return an IO action
14:54:00 <eacameron> rwbarton: but getLine doesn't return a list
14:54:17 <JoeyA> > getLine
14:54:18 <lambdabot>   <IO [Char]>
14:54:21 <JoeyA> :t getLine
14:54:22 <lambdabot> IO String
14:54:23 <acowley> rasfar: I may have missed it, but have you actually told us what problem you're encountering? Is it that a 32-bit GHC's executable won't run on a 64bit shared host?
14:54:24 <rasfar> strange...  i'll have to try to find the source code for my old 64-bit example, maybe I'm forgetting something, can't imagine what it would be though.
14:54:42 <JoeyA> eacameron: It returns a list of Chars
14:54:48 <JoeyA> :t fmap words getLine
14:54:49 <lambdabot> IO [String]
14:54:54 <rwbarton> @type fmap
14:54:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:54:57 <rwbarton> fmap applies with f = IO
14:55:00 <rasfar> acowley, sorry, it's error 500 (end of script headers)
14:55:24 <rasfar> the output is an exact match however, and "file" on the hosting server shows exactly the same info
14:55:26 <eacameron> JoeyA: interesting, I don't quite understand why that works
14:55:33 <rasfar> (as for the equivalent C program)
14:56:01 <rasfar> i'd suppose it was to do with the massive size of the binary, but the older example compiled from GHC is still working and is even bigger
14:56:14 <acowley> rasfar: So Apache is giving a 500 with the GHC-produced CGI program, even though your executable runs properly when invoked manually?
14:56:21 <kallisti> > True == True == True
14:56:22 <lambdabot>   Precedence parsing error
14:56:22 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
14:56:32 <eacameron> rwbartin: thanks
14:56:39 <eacameron> rwbarton: thanks
14:56:43 <rasfar> acowley, yes -- the executable produces the same output as the C program, char-for-char
14:56:59 <JoeyA> I'm thinking of starting (well, resuming) a programming blog.  What's a good blogging platform with support for Haskell syntax highlighting?
14:57:19 <rwbarton> rasfar, maybe it is being run with options that the ghc runtime system doesn't like?
14:57:23 <rasfar> both are stripped; the old 64-bit GHC one is not stripped, that's my last hope (besides looking at the old source if I can find it, in case i forgot something)
14:57:26 <rwbarton> s/options/command-line arguments/
14:57:54 <acowley> rasfar: Hm, well I don't know what I'm talking about in this area so hopefully someone more knowledgeable can chime in. My understanding of CGI is that the 32 / 64bit distinction wouldn't matter, and it must be however the executable is being run.
14:57:58 <rasfar> no options or command-line args, just prints the standard content-type and the HELLO
14:58:40 <rwbarton> but cgi will run your program with some arguments or some weird environment or something
14:58:41 <rasfar> hmm... i'll track down the old code, and give an update if i figure it out
14:58:57 <acowley> rasfar: is there anything else in the apache error log?
14:59:00 <nsxt> JoeyA: why not give something like jekyll a shot?  you can then use prettify to highlight the syntax...
14:59:02 <rasfar> rwbarton, aha! right, it will try to pass args or stdin or something
14:59:17 <rwbarton> i don't remember exactly how it works, but possibly something to look into
14:59:26 <rasfar> acowley, thanks that's also a good idea, i forgot to check (fairly new to web programming)
14:59:31 <nsxt> JoeyA: if jekyll is too lightweight for your needs, check out octopress.
14:59:55 <rasfar> i know how to check it (have to use a web interface the hoster provides).  thanks, i'll look into these things...
15:00:29 <nsxt> JoeyA: there's also http://softwaremaniacs.org/soft/highlight/en/, if prettify isn't up to par.
15:00:41 <Clint> can hakyll not use highlighting-kate through pandoc?
15:05:43 <JoeyA> sorry, I had a phone call.  Thanks for the answers
15:06:26 <JoeyA> I guess my best bet is to host the blog on my own server, rather than using a public hosting service?
15:06:41 <JoeyA> Though I have seen people use github for blogging.
15:08:03 <nsxt> JoeyA: yeah, that's where jekyll would come into play.
15:10:36 <JoeyA> I guess I could try pages.github.com
15:11:01 <JoeyA> (which uses Jekyll, right?)
15:15:05 <nart> hi
15:15:14 <nart> how do i solve this ? Could not find module `System':
15:15:14 <nart>       It is a member of the hidden package `haskell98-1.1.0.1'.
15:15:14 <nart>       Perhaps you need to add `haskell98' to the build-depends in your .cabal file.
15:15:42 <shachaf> Perhaps you need to add `haskell98' to the build-depends in your .cabal file.
15:17:29 <luite> probably not though, doesn't it clash with base?
15:18:06 <geekosaur> nart, you probably need to find out which modern module it needs
15:18:25 <geekosaur> "System" as a module has been deprecated for something like 10 years, although it's only recently ghc enforced it
15:19:01 <nart_> shachaf: mmm, but shouldn't System be a member of base ?
15:19:05 <geekosaur> no
15:19:06 <shachaf> Ah, right, the module "System".
15:19:08 <shachaf> Don't use it.
15:19:14 <geekosaur> System is not a module any more
15:19:30 <geekosaur> it was a module in haskell98
15:19:46 <shachaf> geekosaur: How can it be deprecated for 10 years if it was a module in Haskell 98?
15:20:05 * Twey notes we are now in 2012
15:20:28 <shachaf> Right. But there was no Haskell 2002.
15:20:46 <rwbarton> shachaf: thanks for the tip, I added an instance declaration for (Num [t0]) and my program works much better now
15:20:52 <Twey> But one can deprecate parts of a standard without deprecating the whole standard.  The standard option is provided as a fallback.
15:21:06 <geekosaur> because h98 has a number of standard extensions
15:22:01 <nks> I'm trying out the following example from Graham Hutton's book programming in haskell on GHCI
15:22:01 <shachaf> rwbarton: Point taken.
15:22:06 <nks> predk :: Int -> Int predk 0 = 0 predk ( n + 1 ) = n
15:22:21 <nks> each of those in separate lines
15:22:32 <shachaf> nks: That ("n+k patterns") is deprecated these days.
15:22:35 <geekosaur> would be nice if I could say mor than a brief comment betweeen network outages here
15:22:37 <shachaf> And also that's not how ghci works.
15:22:38 <rwbarton> oh, it was just a joke ;)
15:22:44 <geekosaur> so forget it
15:22:49 <shachaf> You would say "let predk :: Int -> Int; predk 0 = 0; ..."
15:23:07 <shachaf> But in particular in this case you'd say "let predk :: Int -> Int; predk 0 = 0; predk n = n - 1"
15:23:18 <nks> ok thanks
15:23:31 <nks> I will use the predk n = n -1
15:24:16 <rasfar> it seems AwardSpace has at least an hour lag on the access/error logs
15:24:40 <rasfar> however (and i had thought you couldn't do it, but seems you can), if i run the binary from the shell on the server
15:24:58 <rasfar> i get ./test4.cgi: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
15:25:52 <rasfar> aha! and my old 64-bit GHC binary says "statically linked" (the file command), so i must have figured out how to statically link
15:26:46 <rasfar> although -static to GHC seems not to be doing it at the moment ("file" still reports dynamically linked)
15:27:23 <rasfar> and i cannot seem to find the old source code for the 64-bit version.  how do i get GHC to produce a statically-linked executable again?  hmm....
15:27:50 <aszlig> ah, when i hear static... any nice way to statically link gmp and ffi, like so: -Bstatic -lgmp -lff -Bdynamic without using -no-link and liking manually?
15:28:27 <aszlig> rasfar: -optl-static -optl-pthread
15:28:37 <rasfar> aszlig, thank you.  i'm 100% certain i didn't do that before, but it might work
15:28:50 <rasfar> linker options, okay, thank you!
15:29:25 <gienah> rasfar: ghc is dyn linked to libgmp, you will need to create a symlink to point to in in /usr/lib64 or whatever that dir is called on your system
15:29:25 <aszlig> it might _not_ work... only if you have the same version of libc on both machines
15:29:27 <rasfar> (i went through this before, and got it working, and a week later my netbook died and i lost track of where the files were kept)
15:30:12 <rasfar> well, my machine is 32-bit linux and theirs is 64-bit, so i'll hope for the best.  the C program i compiled on my 32-bit machine works fine over there as a CGI though
15:31:17 <rasfar> thanks gienah.  i can't believe, if i went through this before, that: 1) i've forgotten (maybe less surprising), and 2) i didn't keep the files someplace prominent *sigh*
15:31:27 <gienah> rasfar: I guess then you have 32 bit ghc, and the dir is probably /usr/lib32 or just /usr/lib
15:32:07 <aszlig> rasfar: you'll probably get lots of linker warnings about libc
15:32:47 <aszlig> so your executable might not work on older libc versions
15:33:11 <acowley> I thought in the past GHC was more likely to statically link everything
15:33:39 <aszlig> acowley: yep, but not libffi and libgmp
15:33:51 <acowley> Ah, well that's annoying
15:33:52 <aszlig> escpecially not gmp, because it's (l)gpl
15:33:58 <acowley> I wish it were easier to leave out gmp
15:34:18 <rasfar> alright, thank you azlig and gienah.  I don't really understand why the C program works but not the Haskell program, but I suppose they depend on different dynamic libs
15:34:29 <acowley> There's a BSD3 haskell version of Integer somewhere, isn't there? A lot of code doesn't even use Integer, so fussing with libgmp is really unfortunate.
15:34:36 <aszlig> there is something called integer-simple (or was it simple-integer?) which could replace gmp
15:35:04 <aszlig> rasfar: how did you link the c program?
15:35:33 <gienah> you can see which libs it wants with something like: scanelf -n /usr/lib64/ghc-7.4.1/ghc
15:36:52 <rasfar> gcc test.c -o test
15:37:13 <aszlig> so it might be a good idea to have a ghc-option for -Bstatic ... libs ... -Bdynamic
15:37:13 <aszlig> or use ldd
15:37:39 <aszlig> rasfar: okay, that's dynamically linked then
15:38:03 <rasfar> i'm annoyed with myself that i cannot track down the files from the last time i went through this, i remember it was a struggle and i was well-pleased when i got it to work!
15:38:52 <rasfar> yeah, the C binary works dynamically-linked, but I see that my only successful use of a Haskell binary as CGI was statically linked.  and it's coming back to me that figuring out how to do it was somewhat of a struggle.
15:39:51 <gienah> rasfar: the commands to use to figure it out are: 1) to obtain the needed library list from the exe or shared lib: scanelf -n file
15:39:55 <rasfar> (though the specific advice so far isn't ringing a bell) ... i must track down my old source file and compile script.  i'll do it by the timestamp.
15:40:10 <acowley> rasfar: I always do that. You hack your way through some system configuration issue and are so scarred by the experience that you say, "Well, I'll never forget how to do *that*." Two weeks later, you're saying, "How did I get those scars?"
15:40:10 <gienah> 2) to see which libs it finds: ldd file
15:40:31 <rasfar> (yes, gienah, thank-you i'll note these things...)
15:40:36 <gienah> 3) to find a complete list of files it wants, and check it can resolve the symbols: ldd -r file
15:41:23 <Ralith> Anyone familiar with THIH alone? I'm having trouble following the predicate handling in tiExpl (the explicit function binding inference implementation).
15:41:25 <rasfar> as easy as 1,2,3! okay!
15:41:26 <Ralith> er
15:41:27 <Ralith> around*
15:42:03 <t7> Ralith: what specifically ?
15:42:12 <rasfar> acowley, :-D  no doubt
15:42:47 <Ralith> t7: I don't understand why all predicates that aren't entailed by the declared scheme get dropped; that seems like exactly the opposite of the correct behavior.
15:43:32 <aszlig> rasfar: i guess the machine where he wants to put the cgi has only libc6 installed
15:43:38 <t7> Ralith: brb in 15
15:43:43 <Ralith> :/
15:43:58 <aszlig> rasfar: so i think a 32bit libffi is missing there
15:44:17 <aszlig> and probably 32bit libgmp, too
15:56:46 <qnikst> how to define 'Foo bar' value in TH?
15:56:52 <qnikst> value = pattern
16:00:09 <rasfar> sorry, I've been struggling with AwardSpace all this time, trying to reopen a support ticket.  Anyone considering using AwardSpace, do not do it.
16:01:03 <rasfar> aszlig: maybe i can install the 64-bit libs on my local machine and cross-compile?
16:01:49 <rasfar> (more likely I won't be using Haskell CGI anyway, the binaries seem a bit large for that)
16:05:56 <Ralith> t7: you there?
16:06:50 <aszlig> rasfar: try stripping them
16:06:53 <t7> yup
16:06:58 <t7> looking now :)
16:07:49 <rasfar> aszlig, yeah, i do that -- they're still a minimum of 5 MB as compared to the stripped C at 5 KB
16:08:49 <rasfar> but i always look at that with scepticism since, in the case of C, there's probably loader overhead behind the scenes to compensate?
16:09:35 <aszlig> rasfar: you mean with ghc?
16:09:35 <rasfar> no, i'm mistaken, the Haskell is about 500 KB, not 5 MB
16:09:53 <rasfar> so only a 100x difference
16:10:31 <geekosaur> C's runtime overhead is much lower.  designing the GHC runtime so unused parts could be easily omitted is probably a Hard Problem
16:10:32 <t7> Ralith: where is it throwing away preds?
16:10:37 <rasfar> yeah, that's ghc --make with no options.  i'm about to get the boot from this cafe
16:10:55 <Ralith> t7: ps = filter (not . entail ce qs ) (apply s ps)
16:11:13 <Ralith> plus some 's that didn't copy out of the pdf properly
16:12:12 <rasfar> thanks again for your help.  i'll probably try again later, otherwise it'll bug me! byw
16:12:19 <rasfar> (bye)
16:17:34 <stj> I have sum [rec i | i <- [1..n]], rec i is of type ST s Int, now this obviously won't work, but how can I do something like this? sum [value | i <- [1..n], let x <- rec i]
16:18:36 <Ralith> t7: you there?
16:18:53 <t7> yeah, i never implemented that bit before
16:19:08 <t7> i wont be much help :(
16:19:20 <Saizan> :t fmap (sum . concat) (mapM ?rec [1..?n])
16:19:21 <lambdabot> Not in scope: `..?'
16:19:24 <Ralith> it doesn't make sense in-context to you?
16:19:24 <Saizan> :t fmap (sum . concat) (mapM ?rec [1.. ?n])
16:19:25 <lambdabot> forall a a1 (f :: * -> *). (Num a, ?rec::a1 -> f [a], Num a1, ?n::a1, Enum a1, Monad f, Functor f) => f a
16:19:49 <Saizan> :t fmap sum (mapM ?rec [1.. ?n])
16:19:50 <lambdabot> forall a a1 (f :: * -> *). (Num a, ?rec::a1 -> f a, Num a1, ?n::a1, Enum a1, Monad f, Functor f) => f a
16:20:09 <Saizan> stj: ^^^
16:20:29 <Ralith> t7: just another opinion on that section of the paper would be nice
16:20:31 <stj> thank you, I must admit I don't understand all this but let me see if I can work it out
16:21:28 <Saizan> stj: the ?rec and ?n are just a trick to not have to define those
16:21:45 <Saizan> stj: fmap and mapM are the interesting parts
16:22:05 <yescalona> why i could choose learning haskell than clojure???
16:22:46 <t7> Ralith: im not sure it throws the preds away...
16:22:47 <Saizan> yescalona: we don't know :)
16:22:54 <yescalona> :S
16:23:15 <qnikst> how to use ADT data insice TH?
16:23:27 <t7> ok yeah thats weird
16:23:35 <qnikst> e.g. I want to pattern match (Maybe foo)
16:24:18 <Ralith> t7: ps is the inferred preds; qs is the declared preds; ps has no references other than ps' which filters out things which aren't entailed.
16:25:03 <Ralith> (by qs', which is the list of fully typed declared preds)
16:25:22 * hackagebot ixset 1.0.3 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.3 (JeremyShaw)
16:25:24 * hackagebot happstack-server 7.0.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.1 (JeremyShaw)
16:25:52 <Ralith> it seems like it should be filtering out the ones that *are* entailed
16:26:02 <Ralith> in which case it, and the rest of the function, make perfect sense
16:27:38 <shachaf> Is there a standard nice Haskelly way to express what's normally expressed as a bitmask in C?
16:27:46 <shachaf> Set Property seems a little excessive.
16:28:12 <hpc> shachaf: you can use Bits
16:28:13 <qnikst> you can use data.bits
16:28:14 <hpc> @hoogle Bits
16:28:14 <lambdabot> Data.Bits class Num a => Bits a
16:28:15 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
16:28:15 <lambdabot> Data.Bits module Data.Bits
16:28:24 <qnikst> or LargeWord
16:28:36 <shachaf> Sure, but that's not particularly nice.
16:30:22 * hackagebot happstack-lite 7.1.0 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.1.0 (JeremyShaw)
16:30:24 * hackagebot happstack-lite 7.1.1 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.1.1 (JeremyShaw)
16:33:56 <EvilMachine> is there a tool, that can scan a C header file, and generate a Haskell module that uses FFI to access the library the header file corresponds to?
16:34:16 <EvilMachine> so that you don‚Äôt have to write it all yourself
16:35:22 * hackagebot happstack-jmacro 7.0.1 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.1 (JeremyShaw)
16:35:43 <byorgey> EvilMachine: yes, several I think
16:36:47 <EvilMachine> well, will you also tell me which ones? ;) (i have no idea what to enter into google for this. :/)
16:37:22 <byorgey> c2hs, hsc2hs
16:37:30 <byorgey> sorry, I had to google them myself =)
16:37:34 <EvilMachine> ah. okay.
16:37:37 <byorgey> I've never actually used them
16:37:39 <EvilMachine> what did you enter?
16:37:50 <EvilMachine> into google
16:38:08 <byorgey> oh, well, I thought one was named hsc2hs so I googled for that
16:38:11 <byorgey> kind of cheating =)
16:38:14 <EvilMachine> ah. lol
16:38:17 <EvilMachine> okay
16:39:11 <EvilMachine> well,it seems hsc2hs is what GHC uses itself. (i saw that name while compiling it, but thought it was only for that ‚Äúspecial‚Äù C that GHC generates.
16:39:19 <byorgey> I don't think you can actually just take a C header file and generate Haskell, you have to do a bit of work specifying how the interface will actually work
16:39:34 <byorgey> but those tools cut down the boilerplate you have to write.
16:39:43 <EvilMachine> byorgey: uuum, isn‚Äôt that the whole point of a C header file?
16:39:55 <EvilMachine> (to be an interface definition)
16:40:27 <byorgey> EvilMachine: but I think you have to specify what Haskell types the C types will get translated to, and there are other sorts of choices you have to make
16:40:38 <byorgey> I don't know, like I said, I've never actually used any such tools =)
16:41:21 <EvilMachine> byorgey: as far as i know, there is a special type in haskell‚Äôs FFI for every C type. Like CInt, and CBool, etc.
16:41:29 <EvilMachine> oh well, thanks anyway. :)
16:41:46 <byorgey> but what about structs?
16:42:00 <shachaf> EvilMachine: CUIntPtr? :-(
16:42:27 <EvilMachine> byorgey: they would create special data contructs, and use those. obviously.
16:42:36 <EvilMachine> +s
16:42:37 <acowley> I think c2hs does more in the realm of code generation, whereas hsc2hs is more for easing Haskell FFI definitions.
16:43:58 <parcs`> bindings-DSL + hsc2hs make it very easy to write FFI boilerplate
16:44:23 <byorgey> oh good, people who actually know what they are talking about
16:45:22 * hackagebot hsx-jmacro 7.0.1 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.0.1 (JeremyShaw)
16:46:31 <parcs`> c2hs seems to be for interleaving ffi code and haskell code
16:47:12 <EvilMachine> parcs`: nice one. bindings-dsl seems to be what i‚Äôm looking for.
16:47:47 <EvilMachine> parcs`: hsc2hs seems to be like hsc2hs too.
16:47:53 <EvilMachine> oops. lol
16:48:00 <EvilMachine> parcs`: c2hs seems to be like hsc2hs too.
16:48:13 <EvilMachine> anyway. problem: solved. :D
16:48:41 <parcs`> bindings-DSL sits on top of hsc2hs-
16:48:55 <EvilMachine> i know. :)
16:51:52 <djoyner> is there a concise list of non-IO functions that are prone to throw exceptions? i know about head, read and obvious things like / 0.  worried about not so obvious cases.
16:52:46 <acowley> pigworker's answers on SO over the past day are outstanding.
16:54:10 <EvilMachine> djoyner: smart-grepping over all the libraries‚Äô code files for calls that create exceptions (like "error") would give you a complete list.
16:54:23 <EvilMachine> djoyner: but of course there are smarter ways. :)
16:54:39 <EvilMachine> djoyner: it‚Äôs just my quick-and-dirty thought. :)
16:55:11 <djoyner> EvilMachine: actually not a bad thought, just thought a list might exist somewhere
16:56:26 <djoyner> EvilMachine: especially given the "don't let pure functions throw exceptions" advice
16:57:01 <acowley> Great, my broken code now diverges much more violently than before. This is very helpful.
16:57:53 <hpaste_> stj pasted ‚Äúany idea how to speed this up? It's more than 10 slower than eqivalent C++ code‚Äù at http://hpaste.org/67359
16:58:07 <nart_> mmm i think i'm missing something, the executable compiled has a size of 17 MB, is there a way to shrink it ?
16:58:24 <nart_> (few libraries and 130 lines of code)
16:59:13 <byorgey> djoyner: tail, init, last, maximum, minimum, fromJust...
17:05:23 * hackagebot happstack-hamlet 7.0.1 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-7.0.1 (JeremyShaw)
17:05:25 * hackagebot happstack-hsp 7.0.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.0.2 (JeremyShaw)
17:05:27 * hackagebot happstack-hstringtemplate 7.0.1 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-7.0.1 (JeremyShaw)
17:06:29 <clsmith> hey all. does anyone know if fingertrees have been implemented in C anywhere?
17:06:56 <clsmith> i need one; google suggests not, but i don't want to waste all that time writing one if it already exists
17:10:23 * hackagebot happstack-plugins 7.0.1 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-7.0.1 (JeremyShaw)
17:12:36 <mikeplus32> trying to get yesod-test installed, I get this:  http://hpaste.org/67358
17:12:39 <mikeplus32> any ideas?
17:13:22 <luite> mikeplus32: try --constraint=mtl==2.0.1.0
17:14:40 <mikeplus32> ok, thanks
17:29:34 <Dread> bop :: (q -> a) -> (a -> (q -> b)) -> (q -> b) bop f1 f2 = f2 . f1
17:32:52 <Dread> Could a kind person tell me what I'm doing wrong with this func?
17:32:56 <Dread> bop :: (q -> a) -> (a -> (q -> b)) -> (q -> b) bop f1 f2 = f2 . f1
17:33:36 <any-key> Is there a reasonable way to convert a Word16 to a ByteString?
17:35:07 <byorgey> Dread: well, f1 takes q as input and outputs a; f2 takes a as input and outputs  (q -> b).  Therefore their composition has type  q -> (q -> b).
17:35:17 <glguy> Probably the most reasonable way to convert a single Word16 is to use a combination of fromIntegral, mod, and pack
17:35:27 <glguy> if you have a bunch to do you could use Data.Binary
17:35:42 <glguy> not mod, but div
17:39:55 <acowley> Darnit, what happened to stj who had that 10x slower than C code?
17:41:16 <Dread> byorgey: I'm not following what I'm doing wrong. It seems that f1 would return an 'a', then f2 would take the 'a' and return (q -> b) which is what the function is supposed to do.
17:41:40 <byorgey> Dread: no, the function is supposed to take a q and return a b.  What you have written takes a q and returns a (q -> b).
17:42:24 <byorgey> q --f1--> a --f2--> (q -> b)
17:42:51 <byorgey> does that make sense?
17:42:57 <shachaf> The type of what you wrote is just (q -> a) -> (a -> b) -> (q -> b)
17:43:10 <shachaf> Same as (flip (.)), because all that function does is flip (.).
17:47:50 <Dread> that makes sense, but I'm having trouble making it work.
17:48:09 <nart_> when should i prefer the use of TVar TChan over MVar and Chan ?
17:48:41 <byorgey> Dread: try starting like this:  bop f1 f2 = \q -> ...
17:49:06 <byorgey> now you have a value of type q, and you need to write an expression of type b in the ...
17:49:27 <luite> nart_: basically when you need transactions. also there's some comment in the Chan haddock that say that for some things Chan is unsafe
17:49:29 <glguy> nart_: when you want to use transactions to write computations that need to manipulate more than one TVar at a time
17:50:30 <nart_> luite glguy: thanks and what are the differences between IORef MVar TVar ?
17:50:46 <glguy> You'll also want to use tvars if you want to only block on things for a certain amount of time
17:51:06 <glguy> IORef doesn't have a notion of "block while empty"
17:51:07 <luite> an IORef is a mutable reference, an MVar is more like a box where you store something, and take something out
17:51:35 <glguy> TVar is a transactional IORef
17:52:02 <nart_> if i have two threads that tries to access to a MVar at the same time, would the program crash ?
17:52:10 <nart_> shoud i use TVar in that case ?
17:52:11 <glguy> nart_: no, one would block
17:52:19 <luite> nart_: no, if they both try to get a value, only one would get it
17:52:37 <luite> the Mvar would then be empty so the second thread would block until someone else puts in some value again
17:52:37 <glguy> MVars are specifically for when you have more than one thread accessing a shared value
17:52:44 <byorgey> there's also tryTakeMVar if you don't want to block
17:53:35 <nart_> mmm ok, the same applies to Chan right ?, if i have two thread that try to put a value inside a chan at the same time
17:53:56 <glguy> both threads will succeed and both elements will be added to the channel
17:54:11 <nart_> thanks
17:54:57 <luite> yes, but the nonblocking isEmptyChan (similar but not quite tryTakeMVar) is unsafe
17:55:01 <glguy> the channel will always take on additional elements until you run out of memory or read them out the other end
17:55:16 <nart_> so last question, can you make me an example on when is preferred to use the TVar, i really don't understand when i would have to use "transaction"
17:55:18 <glguy> isEmptyChan will block if someone is already waiting on the empty channel
17:55:25 * hackagebot wai-middleware-cache-redis 0.3.0 - Redis backend for wai-middleware-cache  http://hackage.haskell.org/package/wai-middleware-cache-redis-0.3.0 (AlexanderDorofeev)
17:55:43 <glguy> nart_: suppose you wanted to wait for either one of two TVars to have a certain value, you could do that with a transaction
17:56:43 <luite> keep in mind that transactions will be aborted and restarted when necessary, there is no fairness
17:57:03 <glguy> another case is where you have a mostly read situation with occasional update, the threads won't block each other while they are both reading
17:57:05 <luite> someone else who started later might get the values first
17:57:59 <Dread> bop f1 f2 = \q -> f2 (f1 $ q) q                     Thanks Haskell for making me feel like an idiot and thanks byorgey (& shachaf) for helping me out.
17:58:10 <byorgey> Dread: you got it!
17:58:12 <nart_> mmm ok, thanks again
17:58:19 <byorgey> Dread: note the $ is not needed
18:00:40 <Dread> Thanks again
18:01:07 <byorgey> sure
18:18:43 <nks> I'm trying to create a function multe1 that can multiply 3 numbers . I want to use lamba expression. But I'm getting the error   No instance for (Show (a0 -> a0 -> a0 -> a0)) when calling multe 2 2 2
18:18:47 <nks> multe1 x y z = \x -> (\y -> (\z -> (x * y * z)))
18:19:06 <nks> can some one point to the error in my function pls
18:19:40 <byorgey> nks: you are taking the arguments twice, once on the left of the = and once on the right
18:19:52 <byorgey> nks: if you want to define it using lambda, just write  multe1 = \x -> ...
18:20:17 <byorgey> nks: multe1 x y z = ...  is just special notation for multe1 = \x -> \y -> \z -> ...
18:20:21 <nks> ah, thanks
18:20:27 * hackagebot happstack-clientsession 7.0.0 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.0.0 (JeremyShaw)
18:30:27 * hackagebot web-routes-hsp 0.22.1 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.22.1 (JeremyShaw)
18:42:18 <periodic> This C++ project has given me a renewed love of Haskell.
18:42:45 <periodic> Things seem to work exactly the way I want them to‚Ä¶ except when they don't..
18:42:51 <periodic> Which is often.
18:46:54 <twomashi> :t (>>=)
18:46:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:47:41 <twomashi> How do you represent the function (a -> m b) in a list, given you know the signiture?
18:47:51 <twomashi> ie i want a list of [(a -> m b)]
18:48:09 <shachaf> Just like that.
18:48:54 <twomashi> Not in scope: type variable `a'
18:49:47 <geekosaur> more details as to what you're trying to do?
18:50:03 <twomashi> store continuations
18:50:17 <twomashi> using a custom binder
18:50:19 <shachaf> hi continuations
18:50:28 * hackagebot TV 0.4.9 - Tangible Values -- composable interfaces  http://hackage.haskell.org/package/TV-0.4.9 (ConalElliott)
18:55:45 <byorgey> oh, a new version of TV!
18:56:01 <byorgey> cool
18:56:16 <sipa> NTSC!
19:00:15 <hpaste_> aids annotated ‚ÄúConcurrent echo server‚Äù with ‚ÄúConcurrent echo server (annotation)‚Äù at http://hpaste.org/52742#a67362
19:18:37 <t7> @pl (\s -> instantiate s >>= return . (,) nullSubst)
19:18:37 <lambdabot> ((,) nullSubst `fmap`) . instantiate
19:23:40 <boccato> Can anyone point me to a github or something like that of a good library for me to copy its file organization, specially the test files?
19:24:56 <kallisti> boccato: believe conduit has tests
19:24:58 <kallisti> it's on github
19:26:33 <boccato> thanks
19:30:29 * hackagebot cabal-meta 0.1.1 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.1.1 (GregWeber)
19:35:15 <nyingen> @quote
19:35:15 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:35:19 <nyingen> @quote
19:35:19 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
19:35:22 <nyingen> @quote
19:35:22 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
19:35:57 <nyingen> I don't get the hate for the Gentle Introduction. I found it quite excellent
19:36:15 <tgeeky_> nyingen: just relativity of difficultness
19:38:04 <nyingen> Well, I think a weakness of haskell tutorials in general is that authors like to be overly chatty. "Hey presto! A functor! Bet you didn't see that coming." etc
19:38:13 <nyingen> whereas the gentle introduction is very concise and doesn't patronize the reader
19:38:38 <tgeeky_> nyingen: right, but you are smarter than that pet rock I tried to teach haskell to
19:38:47 <nyingen> heh
19:39:04 <gdoteof> i think that functional programming is what is hard to get
19:39:13 <nyingen> yeah, that may be true
19:41:33 <nyingen> at any rate, with most haskell tutorials -- not the big ones, like RWH, I mean blog fodder -- the authors would do better to emulate the Gentle Introduction's style and just get to the point. Probably half the text can be cut from those posts and they'd be better for it
19:42:44 <tgeeky_> nyingen: one thing I've learned in my years studying CS, mathematics, and physics, is that the style of learning (and self-teaching) that I do, does not work for many other people.
19:42:59 <tgeeky_> If this is generally true, maybe the goal is just to expose as many resources as possible and wait
19:43:44 <gdoteof> i found  http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies to be good, and http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
19:43:59 <nyingen> Perhaps, but a case can be made that concise exposition is always better than a familiar, conversational tone that beats around the bush and constantly pulls up tired jokes and similes
19:44:47 <monochrom> apparently, people love to read chatty blogs
19:45:38 <tgeeky_> nyingen: I have been thinking lately, that the best solution would be an IDE/dev environment that follows along while you do a tutorial
19:46:03 <tgeeky_> nyingen: that is, say, if you were to use this magicIDE, and go to LYAH, it would hide all of the prelude functions. Then, as you complete the tutorial, more of them are exposed.
19:46:03 <boccato> gdoteof: Wasn't for me, but thanks for the pointers :)
19:46:24 <tgeeky_> Then, when you're done, it says "Turning on the Prelude. For homework, see the rest of these functions we didn't talk about"
19:46:43 <boccato> I think Dr. Scheme was a bit like that (for scheme, of course).
19:47:03 <tgeeky_> packages not in the prelude could be similarly displayed
19:47:29 <nyingen> interesting idea
19:47:38 <tgeeky_> nyingen: it's what I want for myself, anyway
19:48:08 <nyingen> gdoteof: The haskell in that "Haskell the Hard Way" tutorial looks solid, but why cruft like "Yeah! Rational numbers FTW!"
19:48:16 <nyingen> just delete that sentence, and the tutorial is already improved
19:48:20 <tgeeky_> I don't like to throw someone into GHCI, have them press tab, and see ~ 480 things that they don't understand
19:48:58 <nyingen> I understand authors are exuberant, but stuff like that adds nothing, and I think detracts by forcing the reader to skim
19:49:49 <nyingen> I guess my complains are really about writing style, rather than the way the tutorials try to teach the concepts
19:51:03 <tgeeky_> nyingen: personally, I feel blessed that so many people are spending their time trying to teach others (and themselves) than say, murdering marsupials
19:51:48 <nyingen> or writing the equivalent Java tutorials
19:53:20 <nyingen> "I killed a wombat today" ugh, good for you. "I wrote a monad tutorial for Java" GTFO
19:53:58 <monochrom> my theory is that readers actually like to skim
19:54:20 <kallisti> hi, what's a software library that we need?
19:54:44 <glguy> how about a decent, cross-platform GUI ?
19:55:02 <nyingen> I second that
19:55:05 <kallisti> do those event exist?
19:55:07 <kallisti> *even
19:55:09 <monochrom> you have to add enough junk so the readers have the joy of skimming. if you don't, readers skim anyway, then start complaining about getting lost. that's my theory.
19:55:15 <nyingen> monochrom: heh
19:55:30 <kallisti> wx is fairly cross-platform
19:55:30 * hackagebot global-config 0.1.0 - Global mutable configuration  http://hackage.haskell.org/package/global-config-0.1.0 (AlexanderDorofeev)
19:55:39 <kallisti> I'm guessing it doesn't fulfil the "decent" bit?
19:57:03 <nyingen> monochrom: It's true that when confronted with any blog post, I skim. But if I notice it's a solid, non-crufty post, I go back and read it carefully. For example, many of sigfpe's posts
19:57:55 <monochrom> yes, but other readers are used to 10 lines per second and not 1 minute per line
19:58:03 <nyingen> monochrom: the irritation comes with things like the Yesod tutorial on iteratees. There are few good tutorials on iteratees, and that one had pretty good information, but oh, the organization was terrible
20:00:37 <kallisti> does GTK+ count as cross-platform?
20:00:44 <monochrom> yes
20:01:13 <kallisti> does it count as decent?
20:01:16 <nyingen> no
20:01:16 <monochrom> haha, why does the "source code analysis and manipulation" conference calls itself SCAM? :)
20:01:26 <monochrom> yes
20:02:10 <any-key> okay, I'm starting to panic now...I can't seem to find a way to convert a String to a ByteString
20:02:28 <tomprince> DONT PANIC
20:02:28 <jmcarthur> any-key: Data.ByteString.Char8.pack
20:02:30 <kallisti> you can use pack from the bytestring library
20:02:31 <tgeeky_> monochrom: hey, their first shot was "source code understanding and manipulation"
20:02:33 <kallisti> there's also fromString
20:02:35 <kallisti> which does the same thing
20:02:42 <kallisti> and yes both are in *.Char8
20:02:56 <monochrom> what conversion? "‰Ω†Â•ΩÂóé" converts to which bytes in your bytestring?
20:02:57 <any-key> there's Data.ByteString.Char8.pack but that returns a Data.ByteString.Char8.ByteString
20:03:15 <kallisti> yes that's the same thing
20:03:19 <kallisti> as a regular ByteString
20:03:22 <hpaste_> tgeeky pasted ‚Äúhelp with ghc 7.4.1 / cabal / windows -- whats going on?‚Äù at http://hpaste.org/67363
20:03:29 <kallisti> there are only 2 kinds of Bytestrings: strict and lazy
20:03:32 <tgeeky_> anyone who can help me figure out what's up, please let me know.
20:03:53 <nyingen> NO
20:04:10 <monochrom> law of excluded middle
20:04:42 <nyingen> import Data.ByteString.Average
20:04:54 <any-key> yeah it turns out there was another issue that made me think something else was wrong
20:04:57 <any-key> but thanks
20:05:34 <any-key> this assignment is due in two hours
20:06:39 <monochrom> tgeeky_: somewhere under C:\Users\tg\AppData\Roaming\cabal\bin, you may find your cabal-dev.exe
20:08:04 <tgeeky_> monochrom: nope!
20:08:07 <monochrom> or maybe c:\msg\home\tg\.caba\.p-user\bin as you requested? I don't know. customized setup is customized
20:08:46 <tgeeky_> monochrom: why didn't it show the compilation of the packages but did show the compilation of the setup.hs?
20:09:28 <monochrom> oh, that one I don't know, I think I never saw it
20:10:24 <tgeeky_> monochrom: what I really want to know is why these C:\Users\tg\AppData things are hardcoded (or where)
20:11:17 <monochrom> C:\Users\tg\AppData\Local\Temp\blahblah is your $TMPDIR
20:11:33 <monochrom> or should I say %TMPDIR%. windows is windows.
20:11:42 <monochrom> I mean msdos is msdos
20:12:06 <tgeeky_> monochrom: ok, I understand one part. the reason it wasn't showing the build info, is becasue I had build-log and build-summary turned on
20:12:19 <monochrom> C:\Users\tg\AppData\Roaming\ghc\i386-mingw32-7.4.1\package.conf.d is essentially a GHC requirement. fork GHC to change it.
20:12:31 <tgeeky_> monochrom: hehe. :(
20:13:08 <tgeeky_> monochrom: yep. confirmed. turning on 'build-log' turns off the STDOUT printing of things
20:13:13 <tgeeky_> monochrom: which is unexpected, but not unreasonable
20:13:57 <wli> cabal: cannot configure text-0.11.1.5. It requires integer-gmp >=0.2 && <0.4
20:13:57 <wli> There is no available version of integer-gmp that satisfies >=0.2 && <0.4
20:15:35 <monochrom> integer-gmp comes with GHC and you are not supposed to override it or lose it.
20:16:12 <anotherone> is it possible build a native code with haskell?
20:16:27 <thoughtpolice_> wli: if you're using GHC 7.4.1, it has integer-gmp 0.4.0.0 it seems, hence why the dependency might fail
20:16:39 <monochrom> if you have lost it, your GHC installation is toasted
20:17:07 <wli> It's 7.4.1, trying to migrate cabal stuff to it.
20:17:30 <thoughtpolice_> yeah, then the dependecy needs to be relaxed
20:17:40 <thoughtpolice_> *dependency
20:17:55 <anotherone> only one question please? what can i do with haskell? everything? as C or better?
20:17:58 <anotherone> =/
20:18:10 <thoughtpolice_> anotherone: GHC compiles to native code, yes
20:18:30 <anotherone> thoughtpolice_: tks
20:18:43 <monochrom> text-0.11.2.0 has the new dependency, integer-gmp >= 0.2 && < 0.5
20:19:39 <monochrom> some text-0.11.1.x have too
20:20:44 <gdoteof> ok.  I have type, called a PlayerSlot. its defined like: data PlayerSlot = Empty | PlayerSlot Player Session
20:21:31 <gdoteof> I have a list of Empty and a list of PlayerSlot _ _
20:21:55 <gdoteof> in each player slot, the session has inside of it a seat number (Int)
20:22:11 <gdoteof> what I want ot do is create a list with each player "in" their spot
20:23:53 <gdoteof> newList = zipWith someMagic emptyList playerSlots
20:25:17 <gdoteof> so it should be true that  getSeatFromSession(newList !! n) == n
20:25:42 <S11001001> gdoteof: are you sure you want a list result, then?
20:28:12 <wli> Looks like threadscope was the big blocking point.
20:31:23 <gdoteof> ok thinking of it differently.  i have two lists.  i want ot make a new list from these two lists in the following way.  I call a function on the head of the first list.  if the result of function == the length of the new list at that point
20:31:24 <gdoteof> then i take the head of the first list
20:31:33 <gdoteof> otherwise, i take the head of hte second list
20:31:48 <gdoteof> and start over until either list is empty
20:31:54 <gdoteof> S11001001: yes
20:32:05 <gdoteof> [a] -> [a] -> [a]
20:33:48 <dmwit> gdoteof: Why bother with the list of Empty's at all?
20:34:00 <dmwit> gdoteof: Just sort the list of PlayerSlot's by their seat number.
20:34:29 <dmwit> sortBy (\(PlayerSlot (Player n) _) (PlayerSlot (Player n') _) -> compare n n')
20:34:50 <monochrom> except you want [Empty, Player x 1, Player y 2, Empty, Player z 3, Empty]
20:34:53 <dmwit> As a second pass, if you like, you can double-check that you haven't got duplicate or missing seat numbers.
20:35:07 <monochrom> err, mistake
20:35:10 <Elemir> @pl (\c -> (a, Just c)
20:35:11 <lambdabot> (line 1, column 19):
20:35:11 <lambdabot> unexpected end of input
20:35:11 <lambdabot> expecting variable, "(", operator or ")"
20:35:15 <Elemir> @pl (\c -> (a, Just c))
20:35:16 <lambdabot> (,) a . Just
20:35:17 <monochrom> [Empty, Player x 1, Player y 2, Empty, Player z 4, Empty]
20:35:26 <gdoteof> monochrom: yes that is what i want
20:35:27 <dmwit> I still don't see how the list of Empty's helps doing that.
20:35:31 <gdoteof> right
20:35:32 <dmwit> Just sort, and then fill in blanks.
20:35:38 <gdoteof> we don't need it
20:35:55 <monochrom> however, I don't know how many Empty's are supposed to appear at the end
20:36:18 <dmwit> But, uh... why aren't you just using an Array in the first place?
20:37:55 <gdoteof> idk
20:39:02 <gdoteof> how do I fill in blanks?
20:40:28 <dmwit> Start with an STArray full of Empty's; in a loop, fill in the player positions as you see them in the list. Then run and freeze the resulting array.
20:40:54 <dmwit> But what I meant was you should use Array's earlier in your program.
20:41:04 <dmwit> Producing a value of type [PlayerSlot] at any point is just a mistake.
20:41:11 <monochrom> you need to initialize arrays anyway
20:41:17 <dmwit> yes
20:43:24 <gdoteof> There are some set number of Emptys
20:46:47 <gdoteof> why does it need to be an array?
20:46:53 <dmwit> It doesn't.
20:47:12 <dmwit> But combining indexing and lists is a code smell.
20:47:41 <dmwit> Code smells don't always indicate bad code -- sometimes they indicate gruyere or durian -- but usually they do.
20:58:19 <glguy> Turns out that turning on MonadComprehensions makes list comprehensions slower
20:59:15 <hpaste_> wli pasted ‚Äúcabal install world errors‚Äù at http://hpaste.org/67368
20:59:17 <glguy> It must cause them to desugar the list comprehensions down to bind instead of the more efficient implementation you typically get with list comprehensions
21:01:40 <dmwit> That sounds plausible.
21:01:42 <geekosaur> IIRC it does
21:01:57 <wli> I'm suspecting takusen might have relatively slow turnaround time on updates for newer ghc/etc. versions.
21:02:22 <dmwit> Doesn't look like Takusen's fault to me.
21:02:34 <dmwit> lifted-base-0.1.0.3 is the newest version of lifted-base available.
21:02:42 <wli> Can I do something about it?
21:02:43 <dmwit> If anything, you should blame lifted-base for having a slow turnaround.
21:02:53 <dmwit> You can cabal unpack lifted-base and try fixing it yourself.
21:03:03 <dmwit> Don't forget to bump the version number in the cabal file.
21:03:14 <dmwit> 0.1.0.3.0.0.0.0.1 ;-)
21:03:29 <dmwit> > map ord "wli"
21:03:30 <lambdabot>   [119,108,105]
21:03:40 <dmwit> 0.1.0.3.119.108.105
21:04:25 <glguy> Given the way that cabal does version numbers, you don't never need the trailing 1
21:04:31 <glguy> you can bump it by adding a few .0
21:05:02 <dmwit> Of course you're right.
21:05:28 <monochrom> "I am pleased to announce awesome-stream 0.0.0.0.0.0.0.0.0.0.0.0"
21:05:32 <glguy> actually, adding a single .0 is probably the smallest bump
21:07:09 <dmwit> I know this is really off-topic, but Weird Al is a freaking genius.
21:08:48 <wli> How do I use cabal to install an unpacked package?
21:08:57 <dmwit> cabal install
21:23:08 <MichaelBurge> Hmmm, I accidentally "ghc-pkg unregister"'d my 'base'
21:23:13 <MichaelBurge> is there an easy way to get it back?
21:24:08 <dmwit> ghc-pkg register <the filename of base's package description>
21:25:25 <dmwit> Try looking around in /usr/local/lib/ghc-<version>/base-<version>
21:26:44 <dmwit> ...or possibly /usr/lib/ghc-<version>/package.conf.d
21:26:46 <dmwit> dunno
21:27:14 <dmwit> If all else fails, now is a good time to upgrade GHC. =)
21:27:21 <hpaste_> wli annotated ‚Äúcabal install world errors‚Äù with ‚Äúcabal install world errors (annotation)‚Äù at http://hpaste.org/67368#a67369
21:28:15 <dmwit> huh
21:28:24 <dmwit> Does that happen after a "cabal clean"?
21:28:37 <dmwit> oh
21:28:39 <dmwit> Never mind.
21:28:43 <wli> Yes.
21:28:52 <dmwit> Yeah, you definitely should not have reinstalled "directory" or "process".
21:29:08 <dmwit> Any package on http://www.haskell.org/ghc/docs/latest/html/libraries/ is sacred.
21:29:37 <wli> I didn't directly do so.
21:29:43 <dmwit> I believe you.
21:30:09 <dmwit> Unfortunately, you have basically no recourse other than starting over with a fresh GHC installation.
21:31:48 <wli> I didn't do it globally. Shouldn't that be cabal? Could it be finding the ghc-7.0.4 libs by accident?
21:33:40 <dmwit> If you didn't do it globally, then you do have some recourse.
21:33:47 <dmwit> It will not find ghc-7.0.4 libs by accident.
21:34:33 <dmwit> ghc-pkg unregister anything that's listed in your local package database when you do ghc-pkg list; that will get you a clean slate to try screwing up again. ;-)
21:35:00 <dmwit> (I do recommend trying out the latest release of cabal-install; it makes it significantly harder to screw up.)
21:35:31 <dmwit> Until you upgrade, do a --dry-run before each real install.
21:35:51 <dmwit> Watch for "(reinstall)" lines and be wary of them.
22:09:08 <dumcoder> hello everyone
22:11:52 <dumcoder> i'm trying to install Leksah on Ubuntu 10.10, and getting error gtksourceview2-0.12.3 failed during the building phase. The exception was:
22:11:55 <dumcoder> ExitFailure 1
22:12:41 <dumcoder> how can i fix this?
22:13:31 <hamishmack> dumcoder: What version of ghc?
22:13:49 <dumcoder> version 7.0.4
22:14:24 <hamishmack> dumcoder: have you installed the gtksourceview2-dev apt package?
22:15:03 <wli> rowrecord trouble now.
22:15:45 <dumcoder> hamishmack: yes, i used this command
22:15:48 <dumcoder>  sudo cabal install --extra-include-dirs=. gtksourceview2
22:17:33 <hamishmack> dumcoder: I mean the C apt dev package for gtksourceview not the haskell one
22:18:30 <dumcoder> hamishmack: i'm new to linux , do u mean this command sudo apt-get install libgtksourceview2.0-dev
22:18:50 <hamishmack> dumcoder: sudo apt-get install libgtksourceview-dev
22:18:50 <hamishmack> I think
22:19:29 <hamishmack> dumcoder: Yes that one
22:20:48 <dumcoder> hamishmack: thanks for helping, same error gtksourceview2-0.12.3 failed to install
22:21:06 <hamishmack> dumcoder: Can you use http://hpaste.org/ to send the log
22:21:49 <dumcoder> hamishmack: u mean the output on screen, or there is a log file somewhere?
22:22:03 <hamishmack> Just what is on the screen
22:23:43 <hpaste_> dumcoder pasted ‚Äúleksah-0.12.0.3 depends on gtksourceview2-0.12.3 which failed to install‚Äù at http://hpaste.org/67370
22:25:57 <hamishmack> dumcoder: When you did "sudo cabal install --extra-include-dirs=. gtksourceview2" I think you need to add --global too if you want to install leksah in --global
22:26:26 <hamishmack> dumcoder: Alternatively leave --global off
22:26:33 <dumcoder> hamishmack : ok trying now
22:27:10 <hamishmack> Also if you "sudo" with out --global I think it might install it for root only
22:28:11 <hamishmack> I normally try not to use sudo or --global for any installs I do myself
22:28:44 <hamishmack> that way I can deleted ~/.ghc and get back to a clean install easily
22:29:44 <dumcoder> hamishmack: k thanks, it worked
22:31:35 <dumcoder> hamishmack: no error, now how do i start it? :)
22:32:04 <hamishmack> dumcoder: just "leksah" should do it
22:32:51 <dumcoder> hamishmack: yup strted, , i was trying 'laksha' , thanks again
22:39:36 <hpaste_> wli annotated ‚Äúcabal install world errors‚Äù with ‚Äúcabal install world errors (annotation) (annotation)‚Äù at http://hpaste.org/67368#a67371
22:39:58 <wli> wtf just hit me?
22:51:31 <Veinor> jaspervdj: hakyll looks pretty neat, not sure why i didn't know about it when i was working on my own engine
23:00:19 <hamishmack> wli: Worked ok for me.  I did have to do cabal install rowrecord --ghc-options='-XFlexibleInstances'
23:06:02 <wli> hamishack: Let me try that instead of editing the package.
23:06:42 <gdoteof> @quote
23:06:42 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
23:15:14 <gdoteof> dmwit: http://hpaste.org/67372 this is the code with the smell you spoke of.  the [PlayerList] is only needing to be indexed this one time when is being built
23:15:29 <gdoteof> in the end i will never be doing something like [PlayerList] !! n
23:15:40 <gdoteof> i will just iterate over it
23:17:57 <wli> It's still getting the mysterious ExitFailure 11
23:19:01 <wli> What are the odds the Linux laptop behaves normally.
23:24:08 <hiptobecubic> wli, depends. Is it mine or yours?
23:25:18 <nus> hmm, there're alike reports for OSX, cf. #777
23:25:22 <wli> hiptobecubic: Mine.
23:25:33 <wli> nus: OS X is where it's happening yeah.
23:25:44 <nus> oh
23:44:57 <gdoteof> i got disconnected before.  I have a (now sorted) [PlayerSlot]  each playerSlot has inside of it a Session and inside each Sesison is a seat number.  you can get the seatNumber from PlayerSlot slot with slotSeat.
23:46:08 <gdoteof> http://hpaste.org/67373  what I am trying to do is get a [PlayerSlot] indexed in such a way that the PlayerSlots are both in order; and there are Empty 's in spots that are empty
23:47:45 <gdoteof> so I have something like [PlayerSlot _ 2, PlayerSlot _ 4, PlayerSlot _ 5] I really want [Empty, PlayerSlot _2, Empty, PlayerSlot _4, PlayerSlot _ 5]
23:48:52 <gdoteof> or more accuratenly [Empty, PlayerSlot _ (Session _ _ 2), Empty, PlayerSlot _ (Session _ _ 4)]
23:49:51 <Enigmagic> one idea: use a Vector instead
23:50:52 <qnikst> problem is that PlayerSlot _ 2 and PlayerSlot _ (Session _ _ 2) is different datatypes
23:51:08 <gdoteof> qnikst: right.  ignore PlayerSlot _ 2
23:51:17 <gdoteof> they are all actually the latter.
23:51:18 <qnikst> I'd advice add another type in player ADT
23:51:41 <qnikst> and then map over the list.
23:52:06 <gdoteof> qnikst: i have constructor, Empty for PlayerSlot
23:52:14 <gdoteof> maybe i don't understand you though
23:52:52 <qnikst> or maybe I missunderstand you
23:53:12 <gdoteof> qnikst: i thought i do zip the [PlayerSlot] with an list of Empty in some magic way
23:53:34 <gdoteof> qnikst: see line 14 http://hpaste.org/67373
23:53:43 <Enigmagic> gdoteof: you can do it with Data.List.mapAccumL
23:54:01 * gdoteof hoogles
23:54:03 <qnikst> aa understood.
23:54:24 <Enigmagic> but if you need to index frequently by the player slot then a Vector or some other array-like thing might be easier
23:55:08 <gdoteof> Enigmagic: no i don't need to do that
23:55:23 <qnikst> it can be done with foldl' I'll make a variant in some mins
23:55:35 <gdoteof> basicaly ever.  i just need to have them in a certain way
