00:03:46 <ski> Sondre_B : it's a statically type-safe evaluator, because of how GADTs work
00:05:16 <NemesisD> anyone know of any good relatively complete virtual build systems. for instance, I'd like to set up some virtual environments to build haskell apps for different architectures/distros
00:06:00 <NemesisD> namely, i develop on 64 bit arch linux (really up to date libraries), most web hosts are savages who run debian/centos with old *everything*
00:16:41 <mysticc> NemesisD: Try vagrant ..
00:17:46 <NemesisD> mysticc: i currently use that, its just pretty ad-hoc. i have a couple makefile scripts that remote in and build it. was jus curious if anyone came up with something more automated
00:17:58 <NemesisD> looks like jenkins may have some virtualbox plugins that could help
00:45:40 <community_chat> Programming to draw, text, style, color, numbers, design web pages
01:03:22 <sebz> is there any way to see what is actually derived when deriving an instance?
01:04:55 <fmap> -ddump-deriv?
01:05:26 <sopvop> I need to decode json with aeson. it takes lazy bytestring, but I have strict one. Is fromChunks the right way to convert strict bytestring to lazy one?
01:05:45 <shachaf> sopvop: Pretty much.
01:06:05 <shachaf> A lazy ByteString is more or less a lazy list of strict ByteStrings.
01:06:40 <sopvop> so It's not gonna copy it?
01:07:21 <ChristianS> sopvop: no
01:08:15 <sopvop> Cool
01:47:53 <mm_freak> yeehaa…  i have found an efficient alpha equivalence method for lambda calculus without de bruijn indices
01:48:20 <mm_freak> where de bruijn alpha eq takes n steps, mine takes n * log n steps =)
01:50:09 <mm_freak> in particular no tree rewriting/substitution needed
02:10:53 <ion> cool
02:14:39 * hackagebot reactive-banana 0.5.0.2 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.5.0.2 (HeinrichApfelmus)
02:22:26 <ski> mm_freak : code, or it didn't happen ;P
02:27:36 <merijn> ski: Dirty constructivist
02:33:06 <Ngevd> Right, I'm changing everything from Aeson and Text to JSON and String
02:33:24 <bitonic> Ngevd: for compatibility reasons?
02:33:30 <Ngevd> Yes
02:34:19 <Ngevd> The json package looks very compiler-cross-y
02:34:24 <MaskRay> issue about cabal-install-0.14.0 and pcre-light-0.4
02:34:30 <MaskRay> dist/build/Text/Regex/PCRE/Light/Base_hsc_make: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory
02:46:23 <burbul> I'm having a bug which I think is caused by a pattern match failure being implicitly caught by some function higher up the call chain. Is that possible?
02:47:49 <bitonic> burbul: that's possible, yes
02:47:55 <bitonic> you can catch pattern match failures
02:48:00 <ski> merijn ;)
02:48:01 <ment> burbul: the only place (AFAIK) pattern match failure can be caugth is inside monad patternmatching
02:48:28 <burbul> I'm not explicitly catching anything
02:48:32 <bitonic> ment: nope, see PatternMatchFail
02:48:38 <ski> it can be caught in `IO' as well
02:48:38 <merijn> ment: Pretty sure you can just catch it in IO too
02:48:51 <burbul> but I am using 'fail in an arbitrary monad' as an errorr-handling strategy
02:48:56 <bitonic> you can do `catch foo (\(e :: PatternMatchFail) -> ...)'
02:49:04 <ment> merijn: as an io exception?
02:49:08 <ski> @undo do [a,b,c] <- getArgs; foo a b c
02:49:09 <bitonic> ment: yes
02:49:09 <lambdabot> getArgs >>= \ d -> case d of { [a, b, c] -> foo a b c; _ -> fail ""}
02:49:17 <ski> is what ment was thinking about
02:49:21 <ski> (i.e. the `fail' call there)
02:49:22 <ment> good to know
02:49:48 <merijn> ment: Yes
02:49:59 <bitonic> it's a really ugly thing to do
02:50:06 <ski> burbul : i think you shouldn't "use `fail' in an arbitrary monad"
02:50:07 <merijn> I think you can catch all exceptions in IO, except maybe out-of-memory
02:50:08 <burbul> thanks
02:50:13 <bitonic> I'd say you should never ever do it, except maybe when setting up some recovery system
02:50:22 <ski> (for specific cases, it can be ok)
02:50:36 <bitonic> fail sucks
02:50:55 <burbul> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors <--- #4 is 'fail in an arbitrary monad'
02:51:02 <bitonic> the "Take `fail' out of `Monad'" movement grows every day
02:51:06 <burbul> & to my mind it seemed the cleanest of the lot
02:51:08 <ski> (but having a refutable matching in a binding command in a `do' really ought to require `MonadZero' or `MonadFail' ..)
02:51:09 <bitonic> burbul: he's wrong
02:51:42 <bitonic> `fail' by default calls `error', which most of the times is a very bad way of "reporting" errors
02:51:50 <bitonic> it'll just crash your program
02:52:13 <ski> (and matching on the single constructor of a data type (like tuples), shouldn't be considered refutable, for the purposes of this -- /me forgets the exact definition of "refutable" according to the report)
02:52:42 <ski> @where report
02:52:42 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
02:52:50 <bitonic> ski: irrefutable = ~ pattern
02:53:01 <bitonic> at least in the report, iirc
02:53:41 <bitonic> ski: are you saying that it should bind lazily?
02:54:56 <bitonic> there was a debate about this
02:55:02 <bitonic> @where being.lazy.with.class
02:55:02 <lambdabot> I know nothing about being.lazy.with.class.
02:55:48 <bitonic> @where+ being.lazy.with.class http://research.microsoft.com/en-us/um/people/simonpj/Papers/history-of-haskell/history.pdf
02:55:48 <lambdabot> Done.
02:55:59 <bitonic> ah. site down.
02:56:24 <bitonic> oh well. msr is all down.
02:56:38 <bitonic> lol they put a screenshot of the site instead: http://research.microsoft.com/
02:56:43 <bitonic> classy
02:57:27 <statusfailed> ahaha
02:57:38 <shachaf> bitonic: Classy but lazy.
02:57:45 <shachaf> Looks like you got what you were after.
02:58:10 <ski> "3.17.2 Informal Semantics of Pattern Matching" <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-600003.17.2> :
02:58:13 <ski>   The irrefutable patterns are as follows: a variable, a wildcard, `N apat' where `N' is a constructor defined by newtype and `apat' is irrefutable (see Section 4.2.3), `var@apat' where `apat' is irrefutable, or of the form `~apat' (whether or not `apat' is irrefutable). All other patterns are refutable.
02:58:32 <bitonic> ski: right.
02:58:55 <statusfailed> Ooh, weird- data-lens-template depends on an older version of data-lens which causes everything to break
02:59:15 <ski> so, that doesn't include patterns like `(x,y)' (because `(\ ~(x,y) -> ()) undefined' isn't the same as `(\(x,y) -> ()) undefined')
02:59:56 <bitonic> ski: right, this is the whole lifted vs. unlifted semantics debate
03:00:39 <ski> so, i want a term for a pattern which is almost like an "irrefutable pattern" as defined above, but which also includes patterns of the form `C apat0 ...' where `C' is the sole constructor of a type defined with `data' and where `apat0',... are all patterns in the same class
03:01:13 <bitonic> ski: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.168.4008 , part 5.4
03:01:13 <ski> (via sugaring, this would also include patterns like `C { field0 = apat0 , ... }', where `C' is the sole constructor)
03:01:23 <bitonic> "Tuples and irrefutable patterns
03:02:25 <ski> bitonic : i'm not saying `do (x,y) <- foo; bar x y' shoudl bind `(x,y)' lazily (though that's something to consider), i'm just saying that this shouldn't expand to code including a call to `fail' (and so shouldn't require `MonadZero' alt. `MonadFail')
03:02:50 <bitonic> ski: ah, ok. which is reasonable.
03:03:42 <burbul> just found:
03:03:44 <burbul> http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
03:03:45 <bitonic> there have been a lot of debates on that subject here anyways. and almost everyone agrees that `fail' shouldn't be in `Monad'. someone dug up the original discussion that led to the includsion, which is interesting. there isn't much agreement on the solution
03:03:57 <ski> (i mean making tuple patterns (maybe for an alternative tuple type) always bind lazily is something to consider -- doing this would make some laws hold which fails otherwise, i think)
03:04:01 <niez> hi, I'm learning haskell and I'm trying to figure out for what can I use it, web development with yesod or happstack looks wired, gui programming looks unnatural, is there an area where I can use haskell and learn more about it? network programming perhaps?
03:04:16 <burbul> " it has been four years since the original publication of the article. Does this affect the veracity of the original article? Some names have changed, and some of the original advice given may have been a bit... dodgy. "
03:04:25 <bitonic> ski: well, it would make currying an isomorphism
03:04:35 <bitonic> ski: but there are problems with `seq', and it'd confuse people
03:04:36 <ski> (or rather, `(a:as,b)' wouldn't bind lazily, since `a:as' is a refutable pattern, but `(x,y)' would, since `x' and `y' are both irrefutable)
03:05:10 <bitonic> and also, you'd want a keyword to revert back to actual pattern matching in various situations. so it'd be awkward.
03:05:35 <bitonic> anyways that paper explains
03:05:40 <bitonic> I loved that paper ehe
03:08:03 <ski> bitonic : interesting section
03:09:02 <ski> i think the answer to the question of whether `P x y' would also be unlifted (given `data Pair a b = P a b') in the same sense as the considered alternative semantics for `(x,y)' is : no
03:10:23 <ski> given this alternative interpretation for tuple types, they wouldn't conceptually be declared like `data (,) a b = (,) a b', but rather something like `codata (,) a b = Fst :: a  &  Snd :: b', with `(x,y)' as syntactic sugar for `let Fst this = x; Snd this = y in this'
03:11:46 <ski> bitonic : anyway, re "you'd want a keyword to revert back ...", note that my suggested semantics for it would have `(a:as,b)' match strictly (because the subpattern `a:as' isn't irrefutable), so there would be no need for reverting back, i think
03:12:35 <ski> (re `seq', i (semi-seriously) think we should reintroduce the `Eval' class)
03:13:32 <ski> (`seq' already doesn't make much (semantic) sense for functions or other ADTs like e.g. `IO'-actions -- though there may be enough pragmatic value still)
03:18:09 <MostAwesomeDude> Okay, if I want to have a stateful map, I have to code the state on the *outside* of the map, right? I can't bring it in from inside?
03:18:16 <hpaste_> “Ertugrul Söylemez” pasted “Efficient alpha equivalence without de Bruijn indices” at http://hpaste.org/67762
03:18:23 <mm_freak> ski: there you go =)
03:18:35 <randomclown> I'm trying to write a small assembly (very small subset) emulator in haskell, and I'm not quite sure how to represent self referential datatypes. So far I have a "data Instruction = Push { Int :: Value } ..." and I just represent the program as a [Instruction] but how would I encode a GOTO instruction?
03:19:15 <mm_freak> randomclown: turn your program type into a monad
03:19:25 <ski> mm_freak : ta :)
03:20:06 <mm_freak> data Program where Push :: Int -> Program (); SetLabel :: Program Label; Goto :: Label -> Program ()
03:20:08 <mauke> randomclown: you could do Goto Int or Goto [Instruction]
03:20:09 <ski> randomclown : you could have `Label Ident' and `Goto Ident' in there
03:20:17 <mauke> or that
03:20:29 <mm_freak> then you can write:  do label <- SetLabel; Goto label
03:20:50 <ski> randomclown : or you could build a cyclic data-structure (say indirected via `IORef's or something)
03:22:05 <randomclown> what if I try and build a control flow graph instead?
03:22:15 <randomclown> what data structure would be more appropiate
03:22:26 <mm_freak> that would basically be mauke's Goto [Instruction]
03:22:39 <mm_freak> but beware of memory leaks there
03:22:55 <ski> possibly you could use
03:23:02 <ski> @hackage ivar-simple
03:23:03 <lambdabot> http://hackage.haskell.org/package/ivar-simple
03:23:04 <ment> why does this remind me of forth so much
03:23:07 <ski> instead of `IORef'
03:23:18 <ski> @hackage data-ivar
03:23:18 <lambdabot> http://hackage.haskell.org/package/data-ivar
03:23:29 <ski> is a bit related, but is not quite what i wanted here
03:23:45 <MostAwesomeDude> ment: Forth is everywhere. :3
03:24:18 <mm_freak> i'd go with the monadic approach
03:24:33 <mm_freak> build a vector of instructions and while evaluating keep a map of jump labels
03:24:48 <mm_freak> your program type is a GADT then
03:25:06 <ski> hm, though i don't see `instance Eq (Ivar a)' anywhere, which is what i wanted (apart from having `read :: IVar a -> a', with no `IO')
03:25:42 <mm_freak> one big advantage of this approach will be apparent when you later choose to compile to actual assembler/machine code
03:27:56 <ski> (the idea being that an `IVar a' could be used as a node which you can detect if you encounter again, regardless of the type of `a' -- but the `write :: IVar a -> a -> IO ()' i'm not interested in here -- something like a generalization of `newCyclicIVar :: (IVar a -> a) -> IO (IVar a)' to handle multiple cycles would be enough)
03:31:27 <nand`> What's a good high level network library to help me create a resilient, asynchronous point-to-point connection; analogous to an exclusive chat session between two users?
03:31:45 <mm_freak> nand`: custom protocol?
03:33:14 <nand`> should handle failure/re-sending, queueing and splitting/joining messages seamlessly. mm_freak: yes, the protocol will be my own; I just need the ability to transfer ByteStrings - but an underlying protocol such as TCP that will handle the session and reliability is fine
03:33:40 <mm_freak> then just go with the 'network' library that is usually preinstalled…  you may want to use a fast parser library (attoparsec) and a stream processing abstraction (conduit), too
03:33:52 <bitonic> ski: yeah, what you say makes sense, but I don't think is something we *need*, and it'd confuse users deeply
03:34:00 <nand`> I have my own ByteString -> Packet and Packet -> ByteString functions
03:34:12 <mm_freak> nand`: also watch this video, which is very relevant:  http://www.youtube.com/watch?v=3kEfedtQVOY
03:34:21 <nand`> mm_freak: will do, thanks
03:36:40 <burbul> If I'm explicitly calling 'error' (as part of debugging, not real code), is there any way the resulting error could ever be caught?
03:37:05 <nand`> mm_freak: can I use network with ByteStrings?
03:37:11 <bitonic> burbul: again, yes, with `catch'
03:37:14 <bitonic> but only from IO code
03:37:32 <burbul> There are no explicit 'catch's in my code
03:37:37 <mm_freak> nand`: sure
03:37:47 <burbul> That must mean that the code is simply not being executed then, right?
03:38:02 <mm_freak> nand`: for maximum throughput you would use Network.Socket together with the network-conduit package
03:38:12 <nand`> oh, I see now, it just returns a Handle that I can write to
03:38:22 <nand`> mm_freak: throughput is not an issue, but noted
03:38:54 <mm_freak> nand`: network-conduit is usually also much more convenient…  generally you want to refrain from managing resource yourself without a proper abstraction
03:39:36 <mm_freak> nand`: and i repeat, watch the video fully…  it will save you from common protocol design mistakes
03:39:47 <nand`> It's downloading, 10.3%
03:41:32 <statusfailed> I'm using a lot of the State monad is some code- calculating average and variance on the fly- but it seems that Arrows have a better way to do this. Are there libraries for stream processing, or is that entirely the wrong direction?
03:41:45 <nand`> “Run an Application with the given settings. This function will create a new listening socket, accept connections on it, and spawn a new thread for each connection.”  <- would it be trivial to, instead of spawning a new thread for each connection; spawn a single “listener” thread that polls on all accepted connections and will only process one message at a time? I don't want multi-threading issues
03:43:19 <merijn> nand`: What multithreading issues? You can run multiple haskell threads as a single-threaded program. The runtime uses epoll/kqueue/select underneath to block/unblock threads
03:43:29 <nand`> merijn: oh, okay
03:43:38 <nand`> that's fine
03:43:45 <mm_freak> nand`: you don't want to do that…  please learn about proper concurrent programming in haskell, before you do this
03:44:24 <nand`> mm_freak: got any good links?
03:44:35 <mm_freak> also as a minor advice, while the server/client functionality of network-conduit is convenient, for a productive application you probably don't want to use it
03:44:45 * hackagebot doctest 0.6.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.6.1 (SimonHengel)
03:44:52 <merijn> nand`: You just need to break away from the old wisdom that multithreaded servers were slow and dangerous. There's no mutable state in haskell, so no race/synchronising issues and since haskell uses lightweight threads there isn't much threading overhead
03:45:16 <mm_freak> nand`: honestly i've learned it by trial and experiment and through the haddocs of the base library…  but i'm sure there are many good resources out there
03:45:28 <merijn> nand`: For example, it's quite possible to have over 100k forkIO threads in a single haskell server
03:45:51 <merijn> (on a normal machine, not some absurd number crunching monster)
03:46:14 <mm_freak> nand`: following merijn's advice you will find that a properly written concurrent haskell server performs better than a fine-tuned multi-threaded C server
03:46:24 <mm_freak> this is because the RTS has options a C program has not
03:47:15 <bitonic> does snap have safe some interface to some safe-routing system?
03:47:19 <bitonic> type-safe
03:47:19 <merijn> nand`: If you're familiar with Erlang or Go you can think of haskell threads more as erlang processes or goroutines than pthread style OS threads
03:47:26 <MaskRay> A second read of http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/ makes it more intelligible to me
03:47:37 <MaskRay> NilP
03:47:43 <nand`> merijn: I'm familiar with goroutines
03:47:56 <mm_freak> nand`: haskell threads are goroutines on steroids =)
03:48:08 <MaskRay> ConsP are well-designed names to make their duties clear
03:48:40 <MaskRay> NilP the data constuctor consumes no arguments but hold a value
03:49:22 <nand`> mm_freak: I'll just give it a shot and see where I get then; works comes to worst I'll git reset --hard. The logic and protocol is already reasonably abstracted away from the networking and doesn't rely on state so it should be compatible with just about any networking topology
03:49:51 <ski> bitonic : re unlifted products or re `IVar' ?
03:49:51 <MaskRay> ConsP is a CPS function and resembles a consumer taking right-folded lists
03:50:42 <mm_freak> nand`: i advice you to write a test project…  start with an echo server
03:50:49 <MaskRay> dmwit: am i right about these humble thoughts
03:50:56 <mm_freak> then extend it into a little line-based chat server
03:51:00 <mm_freak> just to get going with concurrency
03:51:03 <bitonic> ski: unlifted products
03:51:41 <mm_freak> nand`: and at every stage feel free to paste the code for review
03:52:40 <nand`> mm_freak: sure thing; do you recommend I start with network or network-conduit?
03:53:10 <mm_freak> start with network using Handle-based communication
03:53:25 <MaskRay> dmwit: the whold process does not entail checking of intermediate values, so monad is overkill and  applicative is enough
03:53:28 <ski> statusfailed : i suspect there are, but i'm not sure which (you could also look up "FRP", and also the (old) "Fudgets" library) -- in any case, you seem to be asking for "stream processors/transducers"
03:53:33 <mm_freak> when you are comfortable with concurrency (forking threads, communicating, etc.), go to network-conduit
03:53:51 <mm_freak> nand`: also remember that this is wrong:  forkIO (doSomething >> hClose h)
03:54:05 <mm_freak> the correct way to do it is:  forkIO (doSomething `finally` hClose h)
03:54:13 <ski> bitonic : ok. i suspect you may be right, but i'm not sure
03:54:40 <nand`> mm_freak: `finally` ensures the second argument gets evaluated after the first?
03:54:43 <mikeplus64> I'm trying to make a high-ish level interface to System.Plugins.Load (to automatically "hotswap" code), but I'm not sure how to "assert" the type of the loaded function (which System.Plugins.Load says is GHC.Prim.Any *), which is vital for actually using the loaded function later on
03:55:32 <mikeplus64> i'll paste the code I have atm
03:55:54 <ski> nand` : s/evaluated/executed/
03:56:44 <hpaste_> mikeplus64 pasted “hot swap?” at http://hpaste.org/67763
03:57:17 <mikeplus64> line 35 has the naiive doesn't-even-work implementation
03:58:47 <mm_freak> nand`: no, 'finally' is from Control.Exception
03:58:52 <mm_freak> finally :: IO a -> IO b -> IO a
03:59:08 <mm_freak> it makes sure that the second computation is run after the first, even if the first throws an exception
03:59:15 <nand`> ah
03:59:30 <mm_freak> otherwise an exception will prevent your handle from being closed
03:59:59 <mm_freak> this is not much of a problem when you use conduits, because they handle that implicitly, but you'll want to be aware of exceptions in concurrent programming
04:02:04 <Ngevd> Well, my family tree library is now PROBABLY PORTABLE
04:02:56 <fmap> @hoogle (a -> m Bool) -> m b -> m c
04:02:56 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:02:57 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:02:57 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
04:03:01 <fmap> :(
04:03:41 <Ngevd> Is there some better syntax sugar for \n -> n {foo = bar} ?
04:04:04 <merijn> Not really, I think
04:04:23 <mikeplus64> nevermind, "solved" my problem ,I just need to provide explicit type signatures
04:04:27 <merijn> (Well, lenses. But that might be a bit heavy weight if you only want to use this a handful of times
04:05:17 <ion> Not that heavy, really. Just an import and a LANGUAGE pragma and a Template Haskell call. :-)
04:06:01 <ion> A few of lines of simple boilerplate.
04:07:08 <mm_freak> sometimes it's more convenient to write your lenses manually
04:07:19 <mm_freak> after all you really just need a getter and setter for the particular field
04:07:38 <mm_freak> no extensions, sometimes less typing, and you can write haddock docs for your lenses
04:08:41 <Ngevd> I think I'll stick to what I have
04:09:37 <nand`> mm_freak: http://dpaste.com/739213/ <- first attempt at an echo server that only handles a single client
04:10:13 <Ngevd> Wow, now this library only needs base, containers, unordered-containers, hashable, and json
04:10:59 <mm_freak> nand`: looks reasonable
04:11:03 <ski> Ngevd : <http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation> might be interesting
04:11:13 <mm_freak> nand`: now turn this into a multi-client server…  it's really a small change
04:11:19 <nand`> I'm not quite happy with the contents of “echo h”; isn't there a higher order function to “interact as long as not EOF”?
04:12:38 <Ngevd> ski, I don't think it's what I want
04:13:10 <mm_freak> nand`: well, you can use lazy I/O
04:13:17 <mm_freak> nothing wrong with that in such a simple application
04:13:26 <mm_freak> hGetContents h >>= hPutStr h
04:13:33 <mm_freak> that's your 'echo' =)
04:14:39 <nand`> oh right; hGetContents will read until EOF without dying
04:14:42 <ski> well, (the various incarnations of) lenses is a nice abstraction that helps working with `\n -> n {foo = bar}'-type things in general (e.g. nested update, which is ugly with the current record update syntax : `foo { a = (a foo) { b = (b (a foo)) { c = (c (b (a foo))) { ... }}} }')
04:15:10 <ski> nand` : or `hInteract id'
04:15:25 <ski> @src interact
04:15:25 <lambdabot> interact f = do s <- getContents; putStr (f s)
04:16:11 <nand`> EchoServer: <socket: 4>: hClose: resource vanished (Broken pipe) <- what happened here?
04:16:32 <nand`> did hGetContents close the handle when it read EOF, or did the GC do that?
04:16:58 <ski> replace `if eof then return () else do ...' with `unless eof $ do ...'
04:17:09 <mm_freak> nand`: the client disconnected
04:17:12 <nand`> ski: good suggestion
04:17:17 <mm_freak> nand`: catch the SIGPIPE signal
04:17:24 <mm_freak> and ignore it
04:17:34 <nand`> mm_freak: I didn't get that error with the old “if eof” version; which is what has me confused
04:17:38 <mm_freak> this is an old unix artifact nobody wants, but everybody needs to care about
04:17:55 <mm_freak> the new one won't fix the error
04:18:00 <mm_freak> it's just nicer to look at =)
04:18:18 <mauke> installHandler openEndedPipe Ignore Nothing
04:21:57 <nand`> mauke: where am I meant to place that? At the beginning of my main? If so, I still get the same error
04:22:31 <mauke> oh, that makes perfect sense
04:22:39 <mauke> it even said "hClose"
04:23:00 <mauke> this is EPIPE, not SIGPIPE
04:23:10 <mm_freak> indeed
04:23:14 <mm_freak> that's weird
04:23:37 <nand`> I'll just stick to the “unless eof $ do” version, which doesn't error on hClose
04:24:03 <mm_freak> this is the weird part about it
04:24:18 <mm_freak> because the unless version appears to me to be equivalent
04:24:45 <nand`> EchoServer v2, now with handling multiple clients: http://dpaste.com/739220/
04:26:11 <mm_freak> nand`: looks fine to me
04:26:33 <mm_freak> now do the same with network-conduit
04:26:42 <nand`> There's still one thing I want to try
04:27:01 <mm_freak> the funny thing is:  an entire multi-threaded echo server is a short one-liner in network-conduit, but don't worry about that for now =)
04:27:01 <nand`> BroadcastServer, which works like EchoServer but sends what it reads from one client to every single client
04:27:04 <mm_freak> do the threading yourself
04:27:10 <mm_freak> yeah
04:27:15 <mm_freak> that's the chat server i meant
04:27:28 <mm_freak> it's a bit more involved and there are multiple ways to do it
04:27:29 <nand`> how would I go about doing that? I'll need to somehow keep track of all my Handles
04:27:36 <nand`> State [Handle] ?
04:27:41 <nand`> StateT [Handle] IO rather
04:28:02 <mm_freak> a thread with an StateT [Handle] IO computation that takes messages from other threads is the traditional, verbose approach
04:28:10 <mm_freak> another method is to use an MVar
04:28:26 <mm_freak> newMVar []
04:28:31 <mm_freak> it's an MVar of a list of handles
04:29:03 <mm_freak> you can also use a Map, which is probably more convenient and faster
04:29:15 <mm_freak> you need to associate threads with handles
04:29:39 <mm_freak> (you can also use Data.Unique)
04:29:50 <mm_freak> every thread generates itself a unique number…  the ThreadId is fine
04:29:56 <mm_freak> it adds its handle to that map
04:30:04 <mm_freak> and when cleaning up it removes the handle out of the map
04:30:43 <nand`> I'll tell you a bit about my ultimate goal; I have a sorted [Connection] where data Connection contains a uniquely identified “id”; and the [Connection] is sorted by this id. When accepting new peers, I want to insert the new connection into the [Connection] at the “correct place”
04:31:01 <nand`> I can probably use a Map id Handle and Map id Thread for the IO business
04:31:08 <nand`> s/id/Id/
04:31:13 <mm_freak> remove the id from Connection and use Map Id Connection instead
04:32:08 <nand`> hmm
04:32:14 <mm_freak> when you use data-lens-fd a very useful idiom is this:  modifyMVar :: MVar a -> (State a b) -> IO b
04:32:36 <nand`> can I traverse a Map (which I guess is a BST) in “left to right” order, analogous to a sorted list?
04:32:52 <mm_freak> sure
04:32:58 <mm_freak> the primary order is sorted by the key
04:33:01 <nand`> that would make the insert operation even more efficient than my currecnt insert :: Connection -> [Connection] -> [Connection]
04:33:05 <mm_freak> a left fold folds in that order
04:33:18 <nand`> ah; there's one problem
04:33:45 <nand`> they're not directly sorted by “id”, but by “f id”
04:34:04 <mm_freak> write a custom Ord instance for Id
04:34:31 <mm_freak> or use IxSet with an index on f
04:34:32 <nand`> only problem is; f :: Id -> State ProgramState Double
04:34:33 <donri> mm_freak: do you mean Lens
04:34:42 <mm_freak> donri: no, State
04:35:08 <nand`> maybe there's a better way to implement what I'm doing
04:35:13 <mm_freak> nand`: IxSet solves this elegantly while still giving you logarithmic performance
04:35:37 <mm_freak> you have a set of values and can index it by arbitrary indices
04:36:05 <mm_freak> it's basically a database with RDBMS-style indices
04:36:15 <donri> also see HiggsSet
04:36:55 <nand`> in my ProgramState; I have a “myId :: ProgramState -> Id” (type Id = Double), and each connection has a “remoteId :: Connection -> Id”; using “dist :: Id -> Id -> Double” I need to keep a set of Connections in my ProgramState so that I can enumerate them in order of distance
04:38:14 <mm_freak> yeah, really sounds like IxSet
04:38:30 <mm_freak> i don't know HiggsSet, so perhaps check that one out, too
04:39:08 <nand`> wait, I'm being silly
04:39:14 <donri> HiggsSet could use some polish and testing but it is more type safe than ixset and potentially has better performance
04:40:25 <mm_freak> well, on hackage i see a build failure on GHC 7.4
04:41:11 <nand`> instead of trying to write “addConnection :: ProgramState -> Connection -> MyMonad ()” I can simply write “addConnection :: Connection -> MyMonad ()” which uses “insert :: Connection -> ProgramState -> ProgramState”; thus freeing me from the monad
04:41:19 <donri> well it claims a dep is missing which it isn't (now anyway)
04:41:21 <bitonic> mm_freak: well, logarithmic performance if you're indexing once, then you have to rebuild the set
04:42:31 <donri> or actually it might be failing because unpack-funcs is
04:43:14 <bitonic> mm_freak: IxSet is just a list of `Map key (Set value)'
04:46:54 <nand`> mm_freak: IxSet looks like it'll solve scenario perfectly
04:48:03 <mm_freak> bitonic: huh?
04:48:26 <bitonic> mm_freak: once you go one index deep, you have to rebuild the map
04:49:14 <bitonic> in other words, if you're indexing with two indices at the same time, the performance is lb(N) + M*log(M), where M is the number of elememnts that match the first index
04:49:16 <mm_freak> bitonic: are you saying that when i build an IxSet and do two lookups, then the index will be rebuilt once?
04:49:21 <bitonic> mm_freak: yes
04:49:45 <bitonic> if with "two lookups" you mean "indexing with two indices"
04:50:14 <mm_freak> what do you mean by that?
04:50:23 <mm_freak> using two different indices in the same lookup?
04:50:30 <mm_freak> using two different indices one after another?
04:50:48 <donri> indices are built on insertion, not lookup
04:50:52 <bitonic> entries @= (Author "john@doe.com") @= (Id 3)
04:50:57 <bitonic> it'll lookup the Author
04:51:04 <bitonic> and then rebuild the index to lookup the Id
04:52:00 <donri> doesn't it just copy the indices?
04:52:07 <bitonic> donri: what do you mean?
04:52:25 <bitonic> actually the second operation is probably linear, it can take the intersection
04:52:41 <Ngevd> Okay, I suck at writing documentation
04:52:56 <Ngevd> "The 'Sex' type represents the sex of a person"
04:52:59 <donri> "entries" already has the Id indices, so when you @= on Author you get a subset of the entries set; doesn't it just copy over the already built indices of the matching entries?
04:53:09 <mm_freak> hehe
04:53:36 <donri> anyway i think that is one of the things higgsset supposedly does better... maybe.
04:53:38 <mm_freak> data Sex = Missionaire | Oral | …
04:53:54 <bitonic> donri: how do you "copy over"? you have to intersect the things that match @= (Id 3) in the original set with @= (Author "john@doe.com"). That is certainly not a logarithmic operation
04:53:54 <alpounet> deriving Show? uh.
04:54:01 <donri> mm_freak: | [Sex]
04:54:17 <mm_freak> Set Sex
04:54:41 <bitonic> donri, mm_freak: all I'm saying is that IxSet is not some magical data structure in which arbitrary lookup queries are logarithmic
04:54:47 <mm_freak> that's even a weird type for a person's sex when you actually mean gender
04:55:00 <donri> bitonic: i mean it doesn't apply the index building functions all over again does it?
04:55:13 <bitonic> donri: if I reemmber correctly, it does
04:55:18 <Ngevd> I got told off when I used the word Gender
04:55:19 <mm_freak> bitonic: i can totally see how it has to rebuild the index when you use ixGen
04:55:24 <mm_freak> but ixFun should be safe
04:55:34 <mm_freak> Ngevd: Gender is fine
04:55:42 <donri> uh how is ixGen different
04:55:50 <bitonic> mm_freak: no no, it's on how IxSet is defined
04:56:15 <mm_freak> i don't know the internals of IxSet
04:56:15 <bitonic> again, it's just a [Map key (Set a)], where each key is an index
04:56:21 <bitonic> once you eliminate the Map
04:56:24 <bitonic> you have to rebuild it
04:56:26 <mm_freak> honestly i haven't ever done nested queries with it
04:56:31 <mm_freak> so i wouldn't have noticed
04:56:32 <bitonic> (the details might be different)
04:56:52 <bitonic> mm_freak: so you never do stuff like ` entries @= (Author "john@doe.com") @< (Updated t1)
04:57:02 <bitonic> in my experience that's exceedingly common :P
04:57:05 <mm_freak> i haven't done
04:57:08 <bitonic> e.g. paginating a user page, or whatever
04:57:24 <mm_freak> i know, but i haven't happened to use it anyway
04:57:47 <mm_freak> usually i try to avoid IxSet
04:57:53 <bitonic> well then you haven't built actual websites with IxSet :P
04:57:58 <bitonic> IxSet is very nice, but it is what it is
04:58:09 <mm_freak> that's a weird conclusion to draw
04:58:12 <donri> bitonic: have you looked at HiggsSet?
04:58:14 <mm_freak> and a little insulting
04:58:21 <bitonic> mm_freak: to what?
04:58:21 <mm_freak> i don't appreciate that
04:58:41 <mm_freak> i'm back to coding now
04:58:46 <bitonic> mm_freak: what are you talking about :P?
04:59:00 <bitonic> donri: nope
04:59:39 <bitonic> donri: "It also has the potential to be fast, since indizes don't need to be recalculated after each query and since Patricia trees perform quite well for intersection and union". still this doesn't change things, much.
04:59:58 <donri> oh?
05:00:13 <bitonic> also, I don't like the "potential" there
05:00:19 <bitonic> donri: it's from the HiggsSet docs
05:00:26 <bitonic> there was some project using Kd-trees
05:00:31 <bitonic> but I think it died? boh
05:00:36 * bitonic goes to cook something
05:00:37 <donri> well, it does need testing and some benchmarks
05:00:45 <donri> the "this doesn't change things" is not from the docs
05:00:59 <bitonic> donri: yeah, that's outside the quotes :)
05:01:09 <bitonic> I mean that the concept is the same, sets inside maps
05:01:09 <donri> thus the "oh?"
05:01:49 <donri> i think with higgsset you first build up your query and only then "run" it
05:02:26 <roha> i try to read the contents of a file and parse it as a list of some custom data type. i want the file to be created if it doesn't exist. somebody knows why i get: *** Exception: event_list_irg_name.txt: openFile: resource busy (file is locked)
05:02:31 <hpaste_> roha pasted “resource busy (file is locked)” at http://hpaste.org/67765
05:02:43 <Ngevd> More bad documentation: "The 'Person' type represents a Person."
05:02:48 <roha> ^^ the function to read the file
05:03:56 <donri> bitonic: so i don't see how that doesn't change much... also, are you saying kd-trees would change much?
05:09:50 <bitonic> donri: it doesn't change much in regards of the complexity of the operations, maybe rebuilding would go down from N*lb(N) to N, if I understand correctly
05:10:02 <bitonic> donri: Kd-trees work in a completely different way
05:10:05 <randomclown> is there a signed version of Word8?
05:10:09 <bitonic> but are very hard to balance dynamically
05:13:02 <nand`> BroadcastServer.hs; using an MVar [Handle]: http://dpaste.com/739227/ <- critique?
05:16:38 <nand`> cc mm_freak
05:17:55 <roha> thats the best way to read from a file and create the file if it doesn't already exist?
05:18:48 <roha> withFile "filepath" ReadWriteMode hGetContents somehow doesn't read the file
05:22:32 <roha> hGetLine works :O
05:28:10 <donri> bitonic: aha thanks
05:28:13 <nand`> mm_freak: would this work/be wise: in my main thread, keep a [MVar ByteString] in my program state and write to these from the connection threads?
05:28:17 <nand`> wait, that wouldn't work very well
05:28:29 <nand`> since then I'd need to poll the MVars in my main thread; if I'm doing that I might as well poll the Handles
05:33:49 <Ngevd> Is it possible to not export an instance defined in a module?
05:38:26 <jonkri> Ngevd, you can choose specifically what to export, but i guess you already knew that
05:39:04 <jonkri> module MyModule (DataType, function1, function2) where
05:43:59 <joachifm> Ngevd: afaik, all instances in scope within a module are always exported
05:45:18 <Ngevd> So, if I don't want the instance exported, I need to remove the instance?
05:45:50 <Ngevd> Damn
05:45:59 <ion> ngevd: I wonder if this is an XY problem? What instance do you not want exported?
05:46:49 <Ngevd> instance (Eq a, Hashable a, JSON a, JSON b) => JSON (HashMap a b)
05:47:23 <alpounet> you can put this in a "Instances" module
05:47:29 <ion> newtype MyMap … = MyMap (HashMap …)
05:47:33 <alpounet> that people/you would have to import explicitly to get this instance in scope
05:47:35 <ion> instance … => JSON (MyMap …)
05:47:52 <Ngevd> Even better idea
05:47:57 <Ngevd> I don't think I actuallt need it
05:47:59 <Ngevd> I use it once
05:49:55 * hackagebot cryptocipher 0.3.1 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.1 (VincentHanquez)
05:53:40 <Ngevd> How do you install modules for hugs?
05:55:36 <bitonic> Ngevd: you mean packages? cabal install --hugs
05:56:28 <Ngevd> cabal: The program ffihugs is required but it could not be found.
05:57:21 <Ngevd> That's the error
05:57:28 <bitonic> uhm. how did you install Hugs? I definitely have ffihugs
05:58:02 <Ngevd> The windows installer?
05:58:44 <bitonic> Ngevd: oh, I don't know then. I use linux
05:59:36 <Ngevd> Oooh, I know what the problem is
06:00:09 <Ngevd> Cabal's looking for C:\Program Files\WinHugs, but it's in C:\Program Files (x86)\WinHugs
06:00:59 <Ngevd> No, that wasn't the problem
06:01:42 <Ngevd> "cabal: The program hugs version >=2006 is required but the version of
06:01:42 <Ngevd> C:\Program Files\WinHugs\hugs.exe could not be determined."
06:04:38 <flamingspinach> hmm... you can create a polymorphic type with a nullary data constructor?
06:05:03 <alpounet> like data Foo a = Foo  ?
06:05:09 <flamingspinach> i.e. "data Foo a = Bar"
06:05:10 <flamingspinach> yeah
06:05:18 <alpounet> yes
06:05:38 <alpounet> that's often called "Proxy" by the way, it can be useful sometimes
06:05:49 <flamingspinach> oh?
06:06:05 <Ngevd> IxSet uses it
06:06:49 <flamingspinach> sorry, I'm a total newbie still - I can't understand how it could be useful, but I guess I will find out as I keep reading...
06:08:58 <nand`> http://dpaste.com/739249/ <- EchoServer.hs version 4; now with stateful computations
06:09:15 <nand`> I think this is a model I could expand onto my “main program”
06:09:18 <nand`> just looking for critique
06:09:33 <hpaste_> niteria pasted “tiny parser” at http://hpaste.org/67766
06:11:05 <hpaste_> niteria pasted “tiny parser” at http://hpaste.org/67767
06:11:50 <alpounet> flamingspinach, it's as a kind of "tag"
06:11:55 <alpounet> it just carries a type
06:11:58 <alpounet> (the 'a' above)
06:12:13 <niteria> hello #haskell
06:12:33 <niteria> can I do something to improve http://hpaste.org/67767 ?
06:13:06 <alpounet> flamingspinach, there's a package that provides this: http://hackage.haskell.org/package/tagged-0.2.3.1
06:13:37 <alpounet> that lets you pass "a type" to functions, without providing a "useless" value, like undefined
06:13:59 <alpounet> when you really just want to say "hey, i'd like you to know it's that type i'm talking about"
06:14:16 <flamingspinach> alpounet: oh, I see :)
06:19:00 <hpaste_> nand` pasted “EchoServer with MVar and StateT” at http://hpaste.org/67768
06:40:13 <fxr> it seems to me that everyone is stop talking when I join the channel
06:40:42 <ion> Yeah, we’ve all agreed to do that.
06:41:11 <hpc> ion: you talked!
06:41:14 <hpc> i talked!
06:41:15 <fxr> and you just broke the agreement
06:41:18 <hpc> oh god i can't stop talking!
06:41:19 <hpc> :P
06:41:24 <fxr> :)
06:41:45 <hpc> it's generally really quiet in the morning
06:42:21 <fxr> that makes sense
06:43:55 <ion> hpc: I’m already doing the flagellation.
06:44:07 * wli ponders various ways of speeding up http://hpaste.org/67752
06:44:31 <mm_freak> Set 3 → Set 2 → Set 1
06:44:31 <mm_freak> TcResult Set 4
06:44:37 <mm_freak> finally my type-checker works with universes =)
06:44:49 <sopvop> After a whole day of trying to appease type system, and succeeding - it's so warming to see how much you can do with so little lines.
06:44:51 <Botje> niteria: you could use a between parser to clean up the last case
06:44:52 <mm_freak> wasn't as easy as i thought
06:44:57 * hackagebot monad-control 0.3.1.3 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.1.3 (BasVanDijk)
06:45:23 <ion> mm_freak: So far, i’ve found this universe the best.
06:45:24 <Botje> between (char '(') (char ')') $ do ...
06:47:25 <Catnaroek> @src flip
06:47:25 <lambdabot> flip f x y = f y x
06:48:44 <Ngevd> :t foldl (\a b -> 10 * a + digitToInt b) 0
06:48:45 <lambdabot> [Char] -> Int
06:50:53 <nand`> Is there a “hGetAvailable :: Handle -> IO ByteString” that reads whatever data is currently available; or blocks if there is none?
06:51:14 <nand`> or should I use “hGetSome h maxBound”
06:51:44 <hpc> use that, probably
06:52:03 <hpc> it appears to be exactly the behavior you want
06:54:57 * hackagebot lifted-base 0.1.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.1.1 (BasVanDijk)
06:59:03 <jonaskoelker> Hi all.  I want to evaluate an expression tree;  my thought was to write { fold nil lit add Nil = nil \n fold nil lit add (Add l r) = add (fold nil lit add l) (fold nil lit add r) \n ... }, but that's a lot of boilerplate code.  How do I get rid of that?
06:59:23 <hpc> @where hpaste
06:59:23 <lambdabot> http://hpaste.org/
06:59:38 <hpc> jonaskoelker: paste your code there ^
07:01:51 <hpaste_> jonaskoelker pasted “code” at http://hpaste.org/67771
07:01:59 <byorgey> jonaskoelker: I don't know of any better ways. And in any case, it may be a little boilerplate but once you have a fold you can use it for much more than just evaluation
07:02:12 <Ngevd> Is anyone willing to see if this library works with compilers that aren't GHC?
07:02:27 <byorgey> oh, I see, you have more operations.  that is quite a bit of boilerplate, isn't it =P
07:02:35 <jonaskoelker> yes
07:02:38 <jonaskoelker>  ==> :(
07:02:43 <hpc> jonaskoelker: make a record type for your operations
07:02:48 <bitonic> Ngevd: I can try
07:02:52 <parcs`> jonaskoelker: uniplate!
07:03:02 <niteria> Botje: thanks, will use that
07:03:10 <jonaskoelker> !grep uniplate interweb
07:03:13 <jonaskoelker> ^^ ;-)
07:03:23 <hpaste_> Ngevd pasted “FamilyTree” at http://hpaste.org/67772
07:03:31 <Ngevd> bitonic, that one
07:03:45 <bitonic> jonaskoelker: if you want a solution included in the HP, try syb. if you want something cool but GHC >= 7.4, try GHC.Generics
07:03:54 * hpc pastes
07:04:00 <Ngevd> I've marked which packages all the imported modules come from
07:04:03 <jonaskoelker> HP = Haskell proposal?
07:04:09 <byorgey> do those generics libraries really give you folds?
07:04:16 <byorgey> Haskell Platform
07:04:29 <jonaskoelker> ~= ansi standard C library?
07:04:40 <Catnaroek> Hello, people, just an opinion. I am trying to convert all my function definitions to point-free notation. Is that worth seeing the occasional ugly ((,)) in my code?
07:04:50 <bitonic> @type gfold
07:04:50 <Catnaroek> just asking for an opinion*
07:04:51 <lambdabot> Not in scope: `gfold'
07:04:55 <bitonic> @hoogle gfold
07:04:55 <lambdabot> Data.Data gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
07:04:55 <lambdabot> Data.Graph.Inductive.Basic gfold :: Graph gr => ((Context a b) -> [Node]) -> ((Context a b) -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c
07:04:55 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (forall e r. Data e => a -> c (e -> r) -> e -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)
07:04:58 <Ngevd> bitonic, if it compiles it should be fine
07:05:12 <Ngevd> Catnaroek, if point-free makes it unreadable, it isn't worth it
07:05:21 <bitonic> Catnaroek: that's a silly goal, imo. pointed goal is often clearer than pointfree
07:05:22 <byorgey> oh, I guess they do
07:05:27 <hpc> http://hpaste.org/67773 -- jonaskoelker
07:05:29 <rwbarton> do you mean literally "((,))"? that's the same as "(,)"
07:05:56 <hpc> i don't know the type of folde, so i made Ops as general as i could
07:06:05 <hpc> you will probably want to make it more specific
07:06:21 <byorgey> hpc: oh, that's a nice solution
07:06:32 <Catnaroek> rwbarton: Oh, I thought (,) was some sort of special identifier... now I just see it is an infix data constructor.
07:06:34 <hpc> also, if you know that add/mult/etc are never ever going to be different ever
07:06:48 <hpc> you can cut out those parameters entirely and define add/mult/etc at the top level
07:06:49 <bitonic> Ngevd: let's see
07:07:11 <Ngevd> bitonic, the only actually uncommon library is json
07:07:19 <Catnaroek> rwbarton: (,) is much less ugly, thanks!
07:07:22 <bitonic> Ngevd: well, unordered-containers as well
07:07:37 <bitonic> Catnaroek: it's a special data constructor, syntactically
07:07:40 <Ngevd> I always think that's more common than it is?
07:07:48 <bitonic> PointFree: you can't use it without parenthesis around it
07:08:08 <bitonic> Ngevd: also, "recent" versions of hashable require ghc-prim
07:08:14 <rwbarton> it's not actually an infix data constructor
07:08:21 <rwbarton> however, its prefix name is still (,)
07:08:22 <Ngevd> bitonic, do they? crap
07:08:28 <bitonic> as you can see, even the most "standard" libraries require ghc
07:08:49 <rwbarton> and with the TupleSections language extension you can write (a,) instead of (,) a, (,a) instead of flip (,) a, so that makes it look even more like an infix operator
07:08:58 <bitonic> rwbarton: yeah that's what I meant, it doesn't follow normal data constructors syntax rules
07:09:08 <PointFree> Why isn't "," simply an infix operator?
07:09:13 <PointFree> It would make things much easier.
07:09:28 <bitonic> PointFree: no particular reason
07:09:31 <rwbarton> well , is used syntactically in other places
07:09:45 <PointFree> Oh, yeah.
07:09:47 <bitonic> ah, true
07:09:47 <PointFree> Lists.
07:09:50 <PointFree> Dang.
07:09:53 <bitonic> mhm...
07:10:35 <bitonic> PointFree: still, there's no reason why (foo ,) shouldn't work (and in fact there's an extension as rwbarton said)
07:10:48 <Ngevd> Any alternatives to unordered-containers, then?
07:11:28 <bitonic> Ngevd: containers? but really, if you're writing some application to use it, just forget about other compilers
07:11:31 <bitonic> it's a lost battle :P
07:11:41 <bitonic> unless you want reinvent the wheel each time
07:11:44 <rwbarton> portability = compiles with multiple versions of ghc
07:11:52 <bitonic> yeah, and even that is hard
07:12:29 <dobblego> is there a time library specifically for working with the gregorian calendar?
07:13:09 <hpaste_> int-e annotated “Special numbers” with “memoized stirling numbers as list of lists” at http://hpaste.org/67752#a67774
07:13:34 <roha> question: if i import Data.String.UTF8 i get: Ambiguous Module Name Data.String.UTF8, it was found in multiple packages: utf8-string-0.3.7 hxt-unicode-9.0.1. how do i specify which package i mean?
07:13:36 <statusfailed> Is there a function to apply an n-ary function to an n-tuple?
07:13:40 <Ngevd> dobblego, Data.Time.Calendar?
07:13:55 <statusfailed> like a generalized `foo f = (\(x,y) -> f x y)`
07:14:01 <dobblego> Ngevd: was hoping for something a bit more complete
07:14:24 <dobblego> statusfailed: all haskell functions take one argument, you might be looking for Control.Applicative
07:15:05 <rwbarton> also n-tuples for n > 2 don't see much use
07:15:32 <dobblego> ha, was just dealing with (Integer, Int, Int) in Data.Time
07:15:32 <statusfailed> does "foo" exist as something obvious then?
07:15:40 <dobblego> ?"foo" is a String
07:15:41 <tazjin> rwbarton: I'd say for n > 3
07:15:41 <lambdabot> Unknown command, try @list
07:15:48 <statusfailed> dobblego: see above :)
07:16:10 <statusfailed> > foo f = (\(x,y) -> f x y)
07:16:11 <lambdabot>   <no location info>: parse error on input `='
07:16:20 <rwbarton> @pl \(x,y) -> f x y
07:16:20 <lambdabot> uncurry f
07:16:29 <dobblego> uncurry
07:16:45 <statusfailed> oh my god I'm even looking at it in hoogle
07:16:49 <statusfailed> thanks :|
07:16:53 <statusfailed> i'm such an idiot
07:17:28 <int-e> wli: see annotation. I guess you can write eularian numbers in a similar way. to make binomials faster, it's probably best to count prime factors, as done in the exact-combinatorials package.
07:18:13 <wli> int-e: I remember the stuff to make Bernoulli numbers faster was quite hairy.
07:19:38 <int-e> wli: yes but at least you can also memoize the recursive calls to bernoulli 0 ... bernoulli j-1, again by computing a list instead of the function.
07:20:10 <Ngevd> Aha!
07:20:30 <Ngevd> There is a combination of versions that allows the latest version of unordered-containters to work everywhere
07:20:50 <Ngevd> Hashable 1.0.1.1
07:22:02 <bitonic> Ngevd: the latest version of unordered-containers requires base >= 4 anyways
07:22:07 <bitonic> and hugs is base 2 iirc
07:22:09 <wli> int-e: Memoziing the binomial coefs in tandem is the tricky part.
07:23:11 <bitonic> Ngevd: so that's automatically out ehe
07:23:23 <Ngevd> Aaaaaaaaaaa!
07:23:27 <Ngevd> This is stupid!
07:23:43 <bitonic> Ngevd: yeah this is a problem with the Haskell environment. It's more like the GHC environment.
07:31:14 <Ngevd> If I was writing this with the goal of being GHC only, it would be so much different
07:33:16 <bitonic> Ngevd: again, if you're writing an application you're planning to use, it's probably much more convenient to go down that path
07:33:35 <Ngevd> I'm writing it to be used rather than to use
07:34:01 <bitonic> Ngevd: with "used" I mean "used for practical purposes" :P
07:34:03 <bitonic> it's the same
07:34:40 <nand`> is there a way to simplify a >=> (return . f)
07:35:13 <hpc> fmap?
07:35:53 <ion> fmap f . a, i think.
07:36:11 <nand`> (. f) . a might work
07:36:19 <nand`> :t \f a -> (.f) . a
07:36:20 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f a -> f1 (a -> b) -> f1 (f b)
07:36:34 <ion> @type \f a -> fmap f . a
07:36:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:36:41 <ion> @type \f a -> a >=> return .f
07:36:42 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (b -> a1) -> (a -> m b) -> a -> m a1
07:36:49 <nand`> oh
07:36:51 <ion> @type \f a -> fmap f Prelude.. a
07:36:51 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
07:36:52 <nand`> :t \f a -> (f.) . a
07:36:53 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:37:09 <nand`> that's what I was looking for
07:37:11 <hpc> :t \f a -> a >=> (return . f)
07:37:12 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (b -> a1) -> (a -> m b) -> a -> m a1
07:37:49 <hpc> :t \f a -> fmap f Prelude.. a
07:37:50 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
07:38:08 <hpc> don't get confused by lambdabot's (.)
07:38:15 <ion> I just did those two. :-P
07:38:20 <hpc> oh
07:38:25 <hpc> ignore me then :P
07:42:39 <sopvop> (Num v0) arising from the literal `1'. I hate you, defaulting!
07:45:50 <bitonic> sopvop: wat? if anything, you hate the fact that it doesn't default to anything :P
07:48:59 <xian> Hi. I declared a typeclass POrd for partial orders and now I want every instance of Ord to be an instance of POrd as well. Is this somehow possible to do in Haskell?
07:49:24 <Botje> instance Ord a => POrd a where ...
07:49:34 <bitonic> xian: it is, but then any other instance will overlap.
07:49:35 <rwbarton> no
07:49:50 <bitonic> xian: in other words, it's not a good idea
07:49:55 <bitonic> and it's not possible in standard haskell
07:51:04 <dobblego> there is a convention whereby we newtype a polymorphic value and instance that newtype
07:51:49 <bitonic> dobblego: it won't work in xian case, if he wants to use Ord instances seamlessly
07:51:56 <dobblego> right
07:55:08 <xian> But dobblego's suggestion is probably the best I can do now.
07:55:24 <Dodek> hey, is there a monadic version of concatMap, something like (a -> m [b]) -> [a] -> m [b] ?
07:55:36 <dobblego> Dodek: I have one on hackage
07:55:44 <Botje> concat `fmap` mapM f ?
07:55:50 <rwbarton> concatMap isn't exactly the hardest function to write in the first place, yeah
07:56:13 <Dodek> rwbarton: sure, that's why i wanted not to reinvent the wheel.
07:56:13 <parcs`> Dodek: looks like (>>=) for a monad transformer
07:56:23 <dobblego> (.=<<.) :: (Applicative q, Monad m, Traversable m) => (a -> q (m b)) -> m a -> q (m b)
07:56:34 <rwbarton> @hoogle (a -> m [b]) -> [a] -> m [b]
07:56:34 <lambdabot> No results found
07:58:05 <dobblego> @type \f -> fmap join . Data.Traversable.traverse f
07:58:06 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Applicative f, Data.Traversable.Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
08:00:29 <Ngevd> I think I'll redo it GHC only
08:00:32 <Ngevd> And see how it goes
08:01:44 <bitonic> Ngevd: ehe. you gave up!
08:01:55 <Ngevd> No
08:01:59 <Ngevd> I'm working in parralel
08:02:03 <Ngevd> Out of curiosity
08:02:25 <bitonic> I'm going to bet you'll end up with a GHC only program if your program is more than 3k lines
08:02:54 <bitonic> (3k lines is a way of saying "mid-sized")
08:02:56 <Ngevd> Seeing as my "portable" one is 166 lines with a lot of whitespace
08:07:25 <flamingspinach> wow this is so cool! "data Tree a = Leaf a | Branch (Tree a) (Tree a)"
08:13:37 <BMeph> I would have thought that 3k+ lines of Haskell qualifies as enterprise-level huge.
08:14:21 <Ngevd> Oh, I can't be bothered with this
08:23:22 <Botje> 3k lines of haskell is a good-sized compiler :P
08:24:58 <ion> For some reason (being tired might have something to do with it) i read that as “3k lines is a good-sized haskell compiler”
08:25:10 <hayashi> ion: same!
08:33:47 <tarleb> hi *.  I want to get better with haskell and thought about implementing some theoretical stuff, but I need some pointers to get started
08:34:21 <tarleb> I was thinking about implementing some simple graph-rewriting constructs
08:34:42 <tarleb> but have no idea what's the best graph library to use for this
08:35:28 <tarleb> could someone point me to a good graph library to use?
08:36:26 <donri> tarleb: maybe http://hackage.haskell.org/package/diagrams ?
08:36:39 <Ngevd> Wow, your nick is so similar to my alt
08:36:58 <tarleb> Taneb: :)
08:37:02 <Taneb> :)
08:38:27 <tarleb> donri: that looks like it's for visulization? Would be useful later, but not quite what I was hoping for
08:39:19 <tarleb> but thx for the link
08:41:09 <donri> sorry i misread graph as graphics
08:41:49 <donri> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graph you already looked here?
08:42:50 <tarleb> yeah, also nothing
08:43:39 <tarleb> there seem to be plenty of graph libraries (fgl, Data.graph), but I don't get what's the difference, and which one should be used when
08:43:46 <fryguybob> tarleb: What are you wanting in a "good graph library"?
08:44:58 <tarleb> fryguybob: for me, that means "make handling of labeled graphs reasonably easy"
08:45:15 <tarleb> best implement som eisomorphism functions
08:46:26 <tarleb> and be not as exotic as to be unusable by other libraries
08:46:59 <MaskRay> looking for counting algorithm library
08:47:05 <MaskRay> counting sort algorithm
08:51:28 <tarleb> I guess I'll keep experimenting a bit more, thanks for the pointers given
08:52:18 <xarch> hi, I'm trying to do a pure unification algorithm
08:52:20 <xarch> well
08:52:23 <xarch> not really pure
08:52:37 <xarch> I don't care if I use the Error monad
08:52:52 <xarch> but I don't want to use State to store my subsitutions
08:53:00 <xarch> *substitutions
08:53:14 <xarch> so well I cant to use a Map for substitutions
08:53:31 <xarch> and since I'm doing a type checker
08:53:45 <xarch> I sometimes need to unify two things
08:54:09 <xarch> for example unify (TFun a b) (TFun c d) = unify a c <+> unify b d
08:54:27 <xarch> the problem is I don't know what I should use for my <+> function
08:54:47 <xarch> because i can't do an union
08:54:56 <xarch> or unionWith
08:56:06 <xarch> (for example (fromList [("a", TConst "Int")] <+> fromList [("a", TVar "b")]) needs to be fromList [("a", TConst "Int"), ("b", TConst "Int")]
08:56:09 <xarch> )
08:56:20 <xarch> oh well i think I know how I should do
08:56:35 <xarch> instead of Map String Type I'll use Map String [Type]
08:56:41 <xarch> and do unionWith (++)
08:57:01 <xarch> and then when I want to apply my substituion I just take the first non-TVar value
08:57:05 <xarch> does that seem ok?
08:57:12 <xarch> *substitution
08:59:01 <Botje> what if you get errors from that?
08:59:36 <Botje> if you unify, say, a -> a with String -> Int
08:59:52 <Botje> you will get a -> [String, Int], right?
09:02:42 <xarch> hum
09:02:51 <xarch> yeah
09:03:15 <xarch> so I'd have to check that
09:03:34 <xarch> well that doesn't seem to be a nice solution
09:05:59 <Botje> or you run your <+> in the Error monad and verify that you don't create infinite or contradicting types
09:08:20 <xarch> the problem is that if I want an efficient implementation of <+>, I have to use `unionWith` from Data.Map
09:08:37 <xarch> but there's no way to give unionWith a monadic function
09:09:27 <dropdrive> I'm trying to grok (text) parsing in Haskell; which of the many packages should I start with?
09:10:14 <donri> parsec
09:10:16 <rwbarton> @hoogle unionWith
09:10:16 * hackagebot iCalendar 0.0.1 - Parser for iCalendar format (RFC2445)  http://hackage.haskell.org/package/iCalendar-0.0.1 (ClintAdams)
09:10:16 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
09:10:16 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
09:10:16 <lambdabot> Data.IntMap unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
09:11:10 <rwbarton> you can fmap return your Map into the Error monad, then combine with a monadic binary operation, then use Data.Traversable stuff on the result
09:12:56 <xarch> oh
09:13:07 <xarch> ok yes I think I see what you mean
09:13:09 <xarch> thanks!
09:13:17 <statusfailed> What do expressions like this mean? `(| ... stuff ... |)` ?
09:13:47 <xarch> I think that's something related to applicatif functors
09:14:03 <dropdrive> What's a good example of an Applicative to keep in mind while I try to write code that uses Applicative?  (E.g. when I write monadic code I usually think about [].)
09:14:06 <xarch> (|f x1 … xn|) = f <$> x1 … <*> xn
09:14:27 <statusfailed> oh, weird, i've never seen that before!
09:14:33 <xarch> yeah
09:14:36 <statusfailed> I don't suppose there's an article or something written on it?
09:14:40 <xarch> you have to use SHE to do that
09:14:40 <dropdrive> xarch: How is that even defined?
09:14:55 <rwbarton> dropdrive: any monad, in practice just about every Applicative you will use is also a Monad
09:15:00 <xarch> https://personal.cis.strath.ac.uk/~conor/pub/she/
09:15:30 <dropdrive> rwbarton: Really, I see.  Thanks.
09:16:03 <statusfailed> xarch: yeek, thanks
09:27:04 <fxr> statusfailed: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.125&rep=rep1&type=pdf
09:28:27 <parcs`> that is arrow syntax
09:30:09 <fxr> who knows
09:32:14 <parcs`> statusfailed: where did you see that
09:49:18 <niteria> @src foldr
09:49:19 <lambdabot> foldr f z []     = z
09:49:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:49:27 <niteria> @src foldl
09:49:27 <lambdabot> foldl f z []     = z
09:49:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:56:29 <niteria> @pl \a -> \b -> a
09:56:30 <lambdabot> const
09:56:34 <niteria> @unpl const
09:56:34 <lambdabot> (\ a _ -> a)
09:57:53 <niteria> I just found out I don't have to spam you and lambdabot responds to /msg
10:10:52 <hpaste_> xraycat pasted “struggling with data” at http://hpaste.org/67781
10:12:39 <byorgey> xraycat: hmm, but once you apply the patter to the record, the "*" still has some sort of special meaning, right?
10:12:42 <byorgey> *pattern
10:12:55 <byorgey> i.e. in ["*", "bar"] the "*" means something special
10:13:02 <xraycat> yep
10:13:21 <byorgey> introducing the PatternSymbol data type is definitely a good idea no matter what
10:14:06 <byorgey> xraycat: perhaps make a new type  data MatchedField = StarField | TextField String
10:14:32 <byorgey> and then have  match :: [PatternSymbol] -> [String] -> [MatchedField]  ?
10:14:51 <byorgey> there are many possibilities and it's hard to know exactly what the best one is without knowing more about what you're trying to do
10:15:16 <byorgey> but the general principle is that it's bad form to have "special values" that mean something different
10:15:55 <byorgey> e.g. what if some record field actually contained the text "*"?  Then you couldn't tell the difference between that and the special-meaning "*"
10:16:15 <byorgey> so instead of just using String where some strings have special meaning, you make a new data type.
10:18:03 <xraycat> I think I will go with the MatchedField approach
10:22:53 <xraycat> I am going to compare those [MatchedField] lists and I am unable to exclude "*" as a possible entry; e.g.: after applying the pattern to ["foo", "bar"] and ["foo2","bar"], both will be equal
10:36:35 <nand`> if I have an Ord instance do I still need to manually define an Eq instance?
10:36:50 <nand`> or will (==) = (==EQ) .: compare automatically
10:39:58 <rwbarton> how did you get an Ord instance without writing an Eq instance first?
10:41:20 <nand`> instance Ord MyTuple where compare (MyTuple a b c) (MyTuple a' b' c') = compare [a,b,c] [a',b'c']
10:41:58 <fmap> Ord instance requires Eq
10:43:08 <xraycat> byorgey: what would StarField look like? You'd have to wrap Star somehow, would'nt you?
10:43:17 <xraycat> *n't...
10:58:24 <imi> hi
10:58:33 <kemla> hi
10:59:57 <imi> I've seen a haskell interpreter/compiler capable of telling whether an expression can be evaluated in finite time, so actually length [1..] terminated with some message telling that you won't get the result in any finite time
11:01:11 <imi> (timeout at 0% actually)
11:01:21 <jgr> wouldn't be an algorithm deciding that deside the termination-problem? :)
11:01:45 <jgr> *decide
11:02:30 <imi> I don't understand you. however my question is now I have a precompiled ghci, can I somehow make it work this way? or can I somehow compile a ghci myself with the same functionality
11:03:13 <jgr> http://en.wikipedia.org/wiki/Halting_problem
11:03:36 <jgr> so it's called "halting problem". still not gonna happen ;)
11:06:21 <mjo> A compiler can certainly tell you that while (true) {} will not terminate.
11:07:09 <imi> jgr: well, haskell isn't a subset (nor a superset) of "turing completeness"... but since I know that [1..] is infinite (just another field to be populated by the constructor) we know tail [1..] isn't finite either
11:08:27 <jgr> imi: haskell is of course touring complete. touring completeness is an aequivalent to lambda-calculus-expressable.
11:08:41 <imi> but then takewhile (<10) [1..] resolves to proove algorithmically that there is an n so ([1..]!!n) >= 10
11:10:11 <imi> (or maybe just to know you have to prove this you'll have to see first the definition of takewhile)
11:10:29 <azaq23> jgr: the halting problem is about the impossibility of solving it in the general case. this does not mean that you cannot solve it for specific instances. Any such termination checker will fail in
11:10:30 <azaq23> complex enough cases, though. imi: haskell is turing complete in all but the "infinite memory" sense, which is not relevant regarding the halting problem (it still applies)
11:12:01 <Philippa_> imi: being able to print "hello world" makes you superturing, just not /computationally/ so
11:12:28 <Philippa_> azaq23: well, you can solve for any given space bound. It's just slow
11:13:23 <xraycat> byorgey: nevermind, stupid me, but thanks for the help, I'll try to adapt my code, should make it much clearer/ less error-prone
11:13:34 <imi> algorithmically, you can assume you have enough memory to compute the result for the task at hand (there will be 128 bit computers if 2**64 bytes won't be enough)
11:15:58 <imi> so you say it's generally impossible. what if we assume the expression at hand has at most n literals?
11:16:07 <imi> well... anyways
11:16:38 <imi> I'm away for lunch, and will read the wikipedia page you provided after I finished lunch
11:16:48 <imi> brb
11:17:53 <warrenharris> I assume every knows the joke "What does marketing call the halting problem? The halting opportunity."
11:18:25 <kemla> What is the proper way to use the (*>) :: C a v => a -> v -> v function in Algebra.Module? If I write something like 2 *> 3, it complains about 2 having ambiguous type. Since I don't really feel like writing (2 :: Double) *> 3 every time, is writing something like (*') :: C Double v => Double -> v -> v the answer or is the a better way of doing this?
11:18:57 <kemla> ...is there a better way of doing this?
11:22:14 <geofft> @pl \x y -> maybe (fail "didn't match") return (lookup x y)
11:22:15 <lambdabot> (maybe (fail "didn't match") return .) . lookup
11:22:25 <geofft> Huh.
11:22:32 * glguy 's eyes burn
11:23:45 <ion> foo .: bar
11:23:52 <ion> curry (foo . uncurry bar)
11:24:11 <ion> or just keep the damn points. :-P
11:24:59 <geofft> What exactly does that dot before a close paren do?
11:25:09 <glguy_> It's just like (1 +)
11:25:17 <ion> (a +) b = a + b
11:25:20 <ion> (a .) b = a . b
11:25:46 <glguy_> It's called a "section"
11:26:17 <glguy_> http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
11:27:10 <geofft> @type (.)
11:27:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:27:26 <geofft> Er. Really?
11:27:28 <merijn> geofft: Lambdabot lies in this scenario
11:27:34 <merijn> :t (Prelude..)
11:27:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:27:38 <merijn> ^^
11:27:44 <merijn> That's the one you want
11:28:09 <merijn> geofft: In lambdabot (.) == fmap
11:28:21 <geofft> Okay, yeah, I was trying to figure out how (.) turned into fmap and whether it was more abstract math I didn't understand yet
11:29:02 <ion> As for (.:) vs. the uncurry stuff, i dislike the lack of symmetry in a .: (b .: (c .: d)) ≡ ((a . b) . c) .: d. curry (a . b . c . uncurry d) seems somehow nicer in that regard.
11:29:03 <glguy_> It's just so we can make more obscure one-liners in IRC
11:29:38 <merijn> geofft: Well it make sense if you mentally replace f with "(->) f"
11:30:19 <merijn> In which case the type signature becomes the same as (.) (if you don't see it, try substituting by hand)
11:31:02 <ion> geofft: You may or may not find this helpful: http://heh.fi/haskell/functors/#function-instance
11:33:46 <kemla> @type (.:)
11:33:47 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:34:06 <geofft> Oh right, "function that takes a certain type" is a functor
11:34:39 <ion> geofft: Nope
11:34:57 <ion> @type let (.:) = (.).(.); (.) = (Prelude..) in (.:)  -- kemla
11:34:58 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:35:14 <nand`> (a ->) is a functor, (a -> b) is not
11:35:49 <ion> geofft: Haskell’s “Functor” might as well be named “Mappable”. It’s a type class for types for which a “map” function exists.
11:36:00 <ion> > fmap (+1) [0..3]
11:36:01 <lambdabot>   [1,2,3,4]
11:36:07 <ion> > fmap (+1) (Just 42)
11:36:08 <lambdabot>   Just 43
11:36:34 <ion> “fmap (+1) readIO” is an IO action that reads a number and results in it incremented by one.
11:36:51 <nand`> > fmap (+1) (*3) $ 4
11:36:52 <lambdabot>   13
11:37:03 <ion> Sorry, fmap (+1) readLn
11:37:25 <geofft> Hm, I'm not englishing enough. "function that takes a certain type" is an instance of a functor?
11:37:44 <geofft> i.e., is the distinction you're drawing the same as that IO is a monad but IO String is not?
11:39:19 <ion> Indeed. “(->) a”, “[]”, “Maybe” and “IO” are instances of functor and monad, and they take exactly one type parameter.
11:39:27 <ion> such as String
11:40:40 <ppilate> I think people use the word "monad" as a synonym to monadic type, i.e. a type which has a Monad instance
11:41:01 <ppilate> erm
11:41:01 <nand`> I still don't know a more elegant way to express “type X such that (undefined :: Monad m => m a) :: X typechecks”
11:41:19 <nand`> I've thought about “X is monadic” but it's too ambiguous
11:42:23 <nand`> wait, would that even type check
11:42:41 <nand`> yes, it would
11:42:42 <ion> “monad action” for some monads perhaps.
11:42:54 <ion> or “monadic action”
11:43:04 <nand`> “lifted value” maybe
11:43:44 <ion> I wouldn’t call readIO a lifted value, though.
11:44:02 <nand`> :t readIO
11:44:03 <lambdabot> forall a. (Read a) => String -> IO a
11:44:13 <ion> Crap, again, i meant readLn. :-D
11:44:16 <ion> I’m too tired.
11:44:17 <nand`> :t readLn
11:44:18 <lambdabot> forall a. (Read a) => IO a
11:44:30 <mzero> anyone ever build an app where main doesn't come from Haskell?
11:44:33 <nand`> I'd called that a lifted Read a => a
11:44:41 <mzero> trying to figure out how to get cabal to do this for me
11:44:54 <merijn> Hmm, is there a convenient way to deal with Maybe values inside another monad? (in my case IO or State) Or do I just have to use something along the lines of "liftM (>>=)"?
11:45:04 <nand`> mzero: I don't know about how cabal does it but you can link a library using GHC and load it from within, say, a C program
11:45:11 <nand`> using the FFI to interact
11:45:30 <mzero> right - I've coded it up (I just need my C main to do some stuff before the GHC runtime starts...)
11:45:44 <mzero> but I'm having trouble getting cabal to build me the executable
11:45:55 <mzero> I'm trying to avoid adding make to the process!
11:45:56 <nand`> merijn: If I find myself passing around and nesting a lot of monads I use an ErrorT ()
11:46:11 <nand`> together with toMaybe :: Either a b -> Maybe b
11:46:34 <nand`> you could probably write a MaybeT that does the same without passing around the unnecessary ()
11:46:44 <nand`> nesting a lot of maybes*
11:46:59 <mzero> I guess I just want to find some other project that is using the hs_init() thing to have a different main() and see what they did...
11:47:28 <nand`> mzero: I never did manage to actually build a working dynamic library using Haskell to this day
11:47:42 <nand`> not even when invoking GHC manually
11:47:53 <merijn> nand`: I don't really want to pass around anything, though. I just have one or two functions that return Maybe and do something with the value once (not a long string of operations)
11:47:54 <nand`> and I needed about 10 different flags just to get it to compile (it still segfaulted on loading though)
11:48:10 <merijn> I guess I could also use maybe/fromMaybe, but that's not very neat
11:48:55 <merijn> basically I guess I want "if Nothing then return () else ..."
11:49:16 <nand`> when (isJust foo) $ ...
11:49:27 <nand`> but then you still have to unwrap the Just
11:49:35 <merijn> nand`: Yeah
11:49:44 <nand`> oh look, http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html
11:49:48 <merijn> Maybe just write my own combinator for that
11:49:55 <nand`> might as well
11:59:47 * parcs` just wrote unsafePerformIO (newStablePtr =<< newIORef Nothing)
12:02:13 <merijn> Such a pity that monad transformers require the ugly unwrapping functions
12:05:20 <merijn> I guess this makes the most sense? "ifJust :: (a -> m ()) -> Maybe a -> m ()"
12:07:46 <nand`> hmm
12:09:28 <hpaste_> MAD pasted “Stateful traversal?” at http://hpaste.org/67784
12:09:44 <MostAwesomeDude> Hey, ^^ is mine.
12:10:08 <MostAwesomeDude> I'm looking to write a stateful version of traverseExpression which carries state to each visited node, but I'm not sure how to do that.
12:10:13 <nand`> merijn: I would probably name it “onJust” since “ifJust” sounds like “ifJust :: Maybe a -> m () -> m ()”
12:10:17 <MostAwesomeDude> Or, rather, I'm not sure what the *best* way to do it is.
12:11:18 <ment> how to do a random access on large array of bytes?
12:12:18 <ment> or maybe even better, has anyone written a cpu emulator in haskell before?
12:12:23 <merijn> ment: Use an array of Word8's? Or something similar?
12:13:19 <ment> merijn: ghc chokes on 60MB Map (i need it for r/w access)
12:13:46 <merijn> ment: The array package provides random access arrays, both mutable and immutable
12:14:11 <merijn> ment: http://hackage.haskell.org/package/array-0.4.0.0
12:14:29 <ment> let's see
12:15:11 <merijn> ment: Indexing those should be O(1)
12:16:09 <identity1> I need a data-structure that has quick lookup, such as Data.Map, to determine 'paths' I've already visited. But if I were to use a map, I would just be mapping "path" to Bool, or some such, but the mere fact that the path is in there says I've already been there, so it seems redundant. Anyone have a suggestion?
12:16:24 <identity1> Oh, and hello :) It's impolite not to greet someone before asking a question.
12:16:51 <gwern> > let bh (index,pvalue) = pvalue < ((index * 0.05) / 9) in map bh (zip [1..] [0.34, 0.44, 0.48, 0.45, 0.36, 0.78, 0.005, 0.99, 0.65])
12:16:52 <lambdabot>   [False,False,False,False,False,False,True,False,False]
12:17:01 <merijn> identity1: How are paths identified?
12:17:15 <jfischoff> identity1: Set?
12:17:15 <lambdabot> jfischoff: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:17:21 <identity1> merijn: Not sure what you mean.
12:17:31 <identity1> I just need something better than O(n) lookup.
12:17:45 <fmap> identity1: HashMap?
12:17:56 <jfischoff> @messages
12:17:56 <lambdabot> dmwit asked 18h 10m ago: Will you package up data-default-generic, or shall I? =)
12:17:57 <lambdabot> dmwit said 14h 44m 33s ago: I ended up rewriting the thing in TH, so that it was robust to data type definition changes and had less syntactic boilerplate to write. http://hackage.haskell.org/
12:17:57 <lambdabot> package/template-default
12:17:57 <merijn> identity1: Well, I meant are paths Int's, String's, something else?
12:18:26 <identity1> merijn: For the sake of the example, let's just use strings.
12:19:32 <ment> identity1: how do you "visit" a path?
12:19:55 <merijn> That's probably already going to be a bit slow, since comparing those for equality is not very fast. As jfischoff mentioned Set might be a good idea. Do you expect encounter the same paths a lot or is that a rare occurence?
12:20:21 <identity1> Sec
12:20:30 <merijn> And how many paths do you expect to encounter in total
12:21:18 <identity1> I have one manager and a few worker threads. The manager takes the next path to visit from the top of some 'queue-ish' structure and checks if it's already in visited paths. If not, it tells a worker thread to visit it, then it throws it in the visited data-structure.
12:21:30 <identity1> And the same paths may appear frequently
12:22:24 <identity1> Set may work fine if it can tell me whether an element is in it or not fast.
12:22:35 <identity1> (Fast being something better than O(n) preferably)
12:22:42 <merijn> identity1: How large is the number of paths? If the number is very large you might want to have a Bloom filter as intermediate quick check for collision
12:23:08 <merijn> Set's should be O(log n), I think
12:23:12 <merijn> s/'//
12:23:44 <identity1> merijn: It won't be millions of elements. Maybe a few thousand, and I may be able to dump them occasionally
12:24:24 <merijn> I guess I'd just say use Set and reevaluate when you can benchmark if its fast enough
12:25:11 <merijn> Actually, if you can turn the paths into int IntMap might be better
12:25:20 <identity1> Alright, sweet, thanks. I wouldn't have thought of set on my own, I think. You guys happen to have a resource for the various 'typical' data-structures haskell provides with a list of their pros and cons?
12:25:32 <jfischoff> identity1: if you don't care about retrieving the paths, and your just testing membership for a few thousand, you could use some mutable bytestring
12:25:42 <jfischoff> and set bits on it
12:26:09 <merijn> identity1: Checking for membersip in an IntMap is O(min(n,W)). (where W is the number of bits in an Int, so 32 or 64)
12:26:32 <identity1> merijn: Ah, that is fast.
12:26:39 <identity1> Well, thanks guys. I'll try set! :)
12:27:05 <identity1> jfischoff: Probably won't work in my case. In reality, I am using strings, and there's no real way I can change them to anything else, unless I hashed them or something.
12:27:23 <identity1> Hmm, maybe I can do that. A 32-bit hash would even do, I believe
12:27:40 <identity1> crc32 probably
12:27:51 <gwern> > 3.15625 - 2.62069 / 0.7682213
12:27:52 <lambdabot>   -0.255123779925134
12:27:58 <identity1> In which case I could even use IntMap
12:28:06 <gwern> CURSE YOU PEMDAS
12:28:08 <gwern> > (3.15625 - 2.62069) / 0.7682213
12:28:09 <lambdabot>   0.6971428675565229
12:28:14 <ment> identity1: what algorithm are you implementing?
12:29:12 <identity1> ment: It's no algorithm as such. I'd rather not go into detail, but it is a search application of sorts
12:33:13 <ment> how does one prevent values that depend on mutable state from escaping local scope?
12:33:39 <MostAwesomeDude> ment: ST is a possibility.
12:33:53 <merijn> ment: How would they escape local scope?
12:34:25 <ment> what do i know
12:34:34 <ment> i'm trying to figure out ST monad
12:34:54 <ment> and it begins with "... rank-2 type parameter prevents values that depend on mutable state from escaping local scope ..."
12:35:01 <ment> which does not make sense to me at all
12:35:17 <ment> any ideas for a sane ST tutorial?
12:35:24 * hackagebot bitwise 0.1 - fast multi-dimensional unboxed bit packed Bool arrays  http://hackage.haskell.org/package/bitwise-0.1 (ClaudeHeilandAllen)
12:35:29 <ClaudiusMaximus> whew, all done - even works in hugs -98 when i replaced runST $ foo  with runST (foo)
12:37:01 <syao> hello to all, I have a little question... how could I define my own Unboxed array eg. of some C struct(with no pointers). Can't find any example of it..
12:37:39 <kallisti> typically you define a record with a Storable instance that reads/writes to/fromt the C struct.
12:38:03 <kallisti> Real World Haskell has an example, there are some FFI resources online that show examples.
12:38:09 <kallisti> @where FFI cookbook
12:38:09 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
12:38:21 <kallisti> hm, no.
12:38:30 <kallisti> http://www.haskell.org/haskellwiki/FFICookBook
12:38:36 <ClaudiusMaximus> syao: once you have Storable, you can use Data.Array.Storable, http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-Storable.html
12:40:14 <BMeph> ClaudiusMaximus: Surely, you meant Data.Vector.Storable? ;)
12:40:19 <syao> thank you.
12:40:57 <efie> http://en.wikibooks.org/wiki/Haskell/Category_theory#Functors_on_Hask the brackets in the definition of fmap in the Functor class are set wrong, aren't they? This changes the meaning of fmap?
12:41:22 <Cale> efie: what?
12:41:30 <Cale> fmap :: (a -> b) -> (f a -> f b)
12:41:32 <Cale> is the same as
12:41:40 <Cale> fmap :: (a -> b) -> f a -> f b
12:41:48 <Cale> because -> associates to the right
12:42:03 <ClaudiusMaximus> BMeph: well, whatever works!
12:42:18 <efie> ok, I thought it associates to the left .. I mixed it up, sorry
12:42:32 <Cale> e.g. when you write  foo :: Integer -> Integer -> String, this is the same as  Integer -> (Integer -> String)
12:42:47 <Cale> which is why when you write  foo x y = (foo x) y
12:42:50 <Cale> you get a String
12:42:53 <kallisti> function application associates left, e.g. (f x) y = f x y
12:44:13 <efie> ah, that's what I had in mind :) thank you both for clarifying
12:52:17 <otters> > let b :: (->) Int Int; b = (+1)
12:52:18 <lambdabot>   not an expression: `let b :: (->) Int Int; b = (+1)'
12:52:23 <otters> > let b :: (->) Int Int; b = (+1) in b 3
12:52:24 <lambdabot>   4
12:52:28 <otters> oooh snap
12:57:08 <mekeor> @kind (->)
12:57:09 <lambdabot> ?? -> ? -> *
13:00:59 <niteria> (->) breaks automatic deriving for Show, I can understand that, is there a module that provides Show for (->)? I don't care what it does
13:01:35 <mauke> instance Show (a -> b) where show _ = "<fun>"
13:02:07 * BMeph non-sequiturs: Fondue? Fon-Done!
13:02:43 <niteria> mauke: cool, thanks, can I make it show "Int -> Int" ?
13:04:43 <mauke_> instance (Typeable a, Typeable b) => Show (a -> b) where show f = show (typeOf f)
13:07:48 <niteria> cool, didn't know about Typeable
13:10:25 * hackagebot happstack-clientsession 7.1.0 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.1.0 (JeremyShaw)
13:19:25 <Ngevd> What if I submit patches to all the modules I need that only work in GHC?
13:19:29 <Ngevd> That'll make it better
13:19:35 <Ngevd> That'll make everything better
13:20:21 <Ngevd> Hahahahaha
13:21:16 <timthelion> Anyone havea good Num instance for tuples lying arround? I want to be able to do (1,1) + (1,2) == (2,3)
13:21:44 <Cale> timthelion: The vector-space package does, iirc.
13:21:50 <Cale> > (1,1) + (1,2)
13:21:51 <lambdabot>   (2,3)
13:22:14 <Ngevd> > (1,2,3) + (4,5,6)
13:22:15 <lambdabot>   (5,7,9)
13:22:21 <Ngevd> > (1,2,3) * (4,5,6)
13:22:22 <lambdabot>   (4,10,18)
13:22:40 <timthelion> lambdabot has something loaded that normal ghci doesn
13:22:41 <timthelion> t?
13:22:46 <Cale> > 1 :: (Integer, Integer, Integer)
13:22:47 <lambdabot>   (1,1,1)
13:22:47 <shachaf> In most likelihood you don't actually want this.
13:22:49 <timthelion> in ghci it tells me no num instance
13:22:58 <timthelion> shachaf: ???
13:22:58 <Ngevd> > ((1,2),(3,4)) + ((5,6),(7,8))
13:22:59 <lambdabot>   ((6,8),(10,12))
13:23:00 <Cale> timthelion: It has *lots* of stuff loaded
13:23:19 <timthelion> Cale: can we ask it what package it is getting that Num instance from?
13:23:31 <Cale> timthelion: http://hackage.haskell.org/package/vector-space
13:23:34 <timthelion> :src (0,0)+(0,0)
13:23:36 <Cale> I just told you
13:23:36 <jfischoff> > (2,2) * (2, 2)
13:23:37 <lambdabot>   (4,4)
13:23:43 <Cale> before I even did that example :)
13:23:58 <shachaf> timthelion: It's probably a bad idea to add tuples like this for whatever you're doing.
13:24:05 <shachaf> Maybe not. Who knows. But often it is.
13:24:06 <timthelion> Cale: yes, thank you, I know.
13:24:22 <Cale> Oh, apparently Data.NumInstances isn't in the newer versions of that package
13:24:23 <timthelion> shachaf: why in heavens name would it be bad to use tuples for vectors?
13:24:32 <Cale> http://hackage.haskell.org/package/NumInstances-1.0
13:24:36 <Cale> ah, it's moved over here
13:25:22 <timthelion> thanks
13:25:28 <jfischoff> > (2,2) <.> (2,2)
13:25:29 <lambdabot>   No instance for (GHC.Show.Show (Data.VectorSpace.Scalar t1))
13:25:29 <lambdabot>    arising fro...
13:26:05 <timthelion> shachaf: why would it be bad to use tuples for vectors?
13:26:17 <jfischoff> > (2 :: Int, 2) <.> (2, 2)
13:26:18 <lambdabot>   No instance for (Data.VectorSpace.InnerSpace GHC.Types.Int)
13:26:18 <lambdabot>    arising from...
13:27:00 <jfischoff> > (2.0 :: Float, 2.0) <.> (2.0, 2.0)
13:27:01 <lambdabot>   Couldn't match expected type `Data.VectorSpace.Scalar t'
13:27:02 <lambdabot>         against in...
13:27:06 <Cale> > (2,2) * ((1,2),(3,4))
13:27:07 <jfischoff> oh well
13:27:07 <lambdabot>   ((2,4),(6,8))
13:27:27 <jfischoff> hmm
13:27:42 <shachaf> Do whatever you want. I have no idea what you're doing and don't want to argue about it.
13:28:08 <timthelion> shachaf: OK, I just wonder why you said what you said.
13:43:12 <copumpkin> Cale: did you see my question about that weird structure?
13:43:16 <d34df00d> Hi there!
13:43:44 <d34df00d> I need to write a small utility script that'd feed some local service with randomily generated garbage in multiple threads, the faster — the better.
13:43:49 <copumpkin> I actually think it might be easier than I was making it out to be if I'm willing to commit to certain access patterns
13:43:52 <d34df00d> Here's my humble approach → http://hpaste.org/67799
13:44:14 <d34df00d> For some reason it doesn't work, though.
13:44:39 <d34df00d> I get `ghc: connect: unsupported operation (Cannot assign requested address)` in ghci, and the application returns immediately if started in compiled version.
13:46:17 <roconnor> I just noticed that the linear subspaces of an algebra form a Kleene algebra.
13:46:23 <Cale> copumpkin: I think I caught something about it yesterday, but I was distracted by something else at the time
13:46:25 <roconnor> Why don't they teach this at uni?
13:47:00 <d34df00d> An interesting part is that if I put smth like "res `traceShow`" before hGetContents, I get all Trues in console, and app works pretty much indefinitely.
13:47:05 <ppilate> roconnor: hm, with which operations?
13:47:07 <Cale> roconnor: With what operations?
13:47:08 <Cale> yeah
13:47:12 <copumpkin> roconnor: they're trying to hold you back
13:48:13 <ment> roconnor: because it distracts from writing java code
13:48:18 <roconnor> V + U := { x + y | x \in V, y \in U}
13:48:33 <roconnor> V * U := { x * y | x \in V, y \in U}
13:48:44 <roconnor> 0 := {0}
13:49:01 <roconnor> 1 := {x | x \in K} where K is the scaler field
13:49:16 <copumpkin> Cale: basically, I want to prioritize duplicate elements with the same key, so effectively to have a priority queue at each distinct key. dmwit suggested Map k (MaxMonoid v) but that has weird asymptotics and the Monoid instance for Map is broken (I can make a newtype, of course). I think I can do it if I commit to only ever adding/removing things to the top or bottom of every per-key bin just by maintaining sortedness when modifying the tree,
13:49:17 <copumpkin>  was wondering if you had any ideas
13:49:36 <ppilate> wait, 1 is a linear subspace?
13:49:37 <roconnor> U* = the smallest linear subspace containing U closed under multiplication.
13:49:43 <roconnor> ppilate: in an algebra
13:49:46 <roconnor> er
13:50:02 <roconnor> maybe this is only for free-algebras ...
13:50:15 <roconnor> but I think it works for algebras
13:50:26 <ppilate> I don't understand this, subspace must have elements from our algebra -- vectors, right?
13:50:35 <Cale> span(1) is obviously a linear subspace
13:50:36 <ppilate> but elements from K are scalars
13:50:36 <roconnor> I could define 1 := {k1
13:50:45 <roconnor> I could define 1 := {k1 | k \in K}
13:51:09 <roconnor> or 1 := the subspace spanned by 1
13:51:12 <ppilate> ah
13:51:48 <ppilate> I don't think I have enough experience to grasp those kind of abstractions easy enough, but thanks for the interesting thought, roconnor :)
13:51:55 <Cale> ppilate: We're not just building this on a vector space... it's an algebra, right? So there has to be some identity element in it, and we can take the span of that identity element, which will be a natural "copy" of the scalar field.
13:52:21 <ppilate> yeah, got it now
13:53:18 <basti_> hi
13:53:45 <Ngevd> Hello
13:54:17 <Cale> copumpkin: I dunno... it seems like it should be doable in some fashion all in one fingertree, but I'm not sure if you'd actually want to do it that way. It's probably easier to just have one fingertree of priority queues?
13:55:16 <copumpkin> Cale: I was thinking of that, but it kind of bothered me (feels a little inelegant) to have to do nested operations and splitting up the internal trees, but if that's my best bet I'll give it a go :)
13:55:44 <ment> what's the difference between arrays and vectors?
13:55:51 * BMeph remarks: one queue tree... sounds like a drunk trying to count. ;)
13:55:55 <Cale> copumpkin: oh, if you frequently have to split up the internal structures, then maybe it's not the best way to go
13:56:01 <Cale> copumpkin: I don't actually know what you're doing
13:56:47 <copumpkin> Cale: it's for matching orders on an exchange :) people can place multiple orders at the same price point and I need to pick which orders get filled
13:57:04 <copumpkin> but I think the nested structures is probably the simplest way to get it started for now
13:57:14 <copumpkin> then perhaps I can change my internals later once I get the interface sorted out
13:57:31 <hpc> ment: looks like vectors are implemented as arrays, plus fancy loop optimisations
13:57:41 * hpc is unfamiliar with vectors
14:02:52 <dcoutts> ment: arrays can be multi-dimensional and bounds don't need to start at 0
14:03:03 <dcoutts> vectors are 1-dimensional, indexed from 0
14:03:34 <dcoutts> e.g. can have a 2-array with valid bounds from (2,3) to (4,5)
14:03:43 <dcoutts> erm 2-d array
14:04:33 <ment> is one implemented in terms of the other or are they independent?
14:04:37 <dcoutts> ment: then since vectors are always 1-d, they support sequence-like operations such as head/tail etc, which don't really make sense for arrays
14:04:44 <dcoutts> ment: independent
14:04:56 <ment> ok, thanks
14:05:01 <dcoutts> (they're both implemented in terms of something lower level in ghc)
14:05:49 <dcoutts> (ghc's primitive Arr# or ByteArr# type)
14:08:10 <Feuerbach> dcoutts: hi, have you put your thesis online yet?
14:08:53 <dcoutts> Feuerbach: yes, I'd forgotten I had :-)
14:09:07 <dcoutts> http://code.haskell.org/~duncan/thesis.pdf
14:09:30 * dcoutts hasn't uploaded it to the Oxford University library archive yet, naughty.
14:09:32 <Feuerbach> cheers! :)
14:11:15 <k00mi> may i present to you: http://i.imgur.com/lSaKf.jpg, a haskell logo in aluminium :-)
14:12:04 <Feuerbach> k00mi: cool!
14:12:21 <aristid> k00mi: self-made? :D
14:12:49 <k00mi> yes, using this: http://vimeo.com/41205504
14:13:19 <k00mi> then put the styropor in sand and pour hot aluminium over it
14:15:01 <merijn> lenses, fclabels, data-accessor or data-lens?
14:16:54 <roconnor> merijn: data-lens
14:16:57 <merijn> Hmm, edwardk says data-lens, then again I suspect he might be a little biased :p
14:17:09 * roconnor is also biased
14:18:48 <merijn> roconnor: Did you guys at least write some intro docs or is it the usual "stare at haddock and pray for enlightenment" thing?
14:20:08 <roconnor> I haven't got around to writing intro docs yet.
14:20:16 <roconnor> though there is someone's blog entry somewhere
14:20:28 <merijn> Somehow I was afraid of that answer :)
14:21:00 <roconnor> http://www.maztravel.com/haskell/lensExamples.html
14:21:25 <merijn> roconnor: Thanks
14:22:18 <roconnor> merijn: the associativity of (^.) in the recent lens package has changed so that test4 no longer need parentheses.
14:22:37 * BMeph wishes more people would write the docs to their projects FIRST, then one they have a clue as to what their project is supposed to do, code it to match...
14:23:16 <roconnor> BMeph: normally I do that (see Data.Colour) but Data.Lens I have inherited
14:23:49 <roconnor> BMeph: well at least I released Data.Colour with reasonable haddoc documentation.
14:28:17 <sm> BMeph: +1 documentation-driven development!
14:28:25 <roconnor> DDD
14:28:41 * merijn does wishful-thinking driven development
14:28:47 <sm> DDD works really well
14:28:53 <merijn> I must say haskell's code reuse makes me extremely lazy
14:29:10 <merijn> I refuse to write any function without checking hoogle and get disappointed if it doesn't exist yet
14:29:29 <ment> yeah
14:29:54 <ment> @hoogle Int -> (String, Bool) -> [([Int, Int], Bool)]
14:29:54 <lambdabot> Parse error:
14:29:54 <lambdabot>   Int -> (String, Bool) -> [([Int, Int], Bool)]
14:29:54 <lambdabot>                                  ^
14:30:08 <ment> @hoogle Int -> (String, Bool) -> [([(Int, Int)], Bool)]
14:30:08 <lambdabot> No results found
14:30:27 <parcs`> roconnor: do you maintain data-lens-template and data-lens-fd now
14:31:17 <roconnor> I hope not
14:31:22 <roconnor> but I fear I might
14:31:35 <parcs`> because they are in need of a dependency bump :P
14:31:56 <roconnor> parcs`: feel free to do it if you have a hackage account
14:32:11 <parcs`> okay
14:32:30 <BMeph> roconnor: Naugh, see, your situation kind of argues my point; if it had docs with it, it'd be easier to maintain.
14:32:35 <parcs`> also, why do the State operators in data-lens return values?
14:32:56 <roconnor> parcs`: I suspect it is a C-ism
14:33:13 <dropdrive> Random question...is there STM between processes (on different machines)?
14:33:14 <parcs`> it is generally annoying and redundant and caused me to switch to fclabels
14:33:25 <roconnor> parcs`: however I think it works well in the partial-lens framework where the return value is the only way to see if a null reference was assigned to.
14:33:36 <roconnor> parcs`: ah, interesting
14:34:13 <merijn> dropdrive: I would expect not, as that's incredibly hard to implement
14:34:21 <parcs`> you're usually going to wrap all operations with a void (..) to stop ghc from complaining about unused results
14:34:39 <BMeph> sm: I was in charge of documentation for my BS senior project; as much fun as it was to help the team with coding, it was also fun to know when to stop. ;)
14:35:19 <roconnor> parcs`: I guess we are still trying to figure out the best programming API for lenses.
14:35:45 <roconnor> parcs`: presumably _ <- x := y also works.
14:36:20 <scb> return function is basically saying append the type constructor of this monad to the value I'm passing, right?
14:36:21 <parcs`> not when you do something like 'when (blahblahblah) $ modify ....'
14:36:48 <merijn> scb: Sorta-ish
14:37:22 <parcs`> well i am content with the fclabels api for now.. but i like some things about data-lens, like the simple representation and the 'focus' operator
14:37:29 <merijn> scb: That notion starts breaking down for stuff like the "(->) a" monad instance
14:37:40 <scb> Moments like this is when I realized I am not very smart. I have been reading up on Monads for like 3 hours and still don't wrap my mind around it.
14:37:53 <roconnor> @hoogle when
14:37:53 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
14:37:54 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
14:37:54 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
14:38:11 <roconnor> parcs`: Thanks for the feedback
14:38:21 <merijn> scb: Meh, the biggest problem is your mind making it more complicated than it is. They're very easy, so easy you think "that can't be it...", even
14:38:45 <scb> merijn: I mean I get the general structured code idea, I'm just having a hard time.
14:38:48 <merijn> scb: They're just a bit to abstract to explain, unless you generalise from examples
14:39:24 <merijn> scb: What are you reading now? Most tutorials are abysmal...
14:39:41 <scb> Combination of Real World Haskell and google.
14:39:45 * merijn glares at the monads are like burritos disaster
14:39:50 <BMeph> scb: I agree with merijn. It sounds kind of Zen-like, but you'll know you "get" Monads, when you see that there's not much to "get" in the first place.
14:40:07 <merijn> Learn You a Haskell has some nice examples, building up from Functor and Applicative
14:40:19 <brutax> Real World Haskell tends to do things more complicated than they really are imo
14:40:26 <merijn> RWH is a bit...terse
14:40:47 <BMeph> merijn: My go-to analogy is: "A Monad is like colour."
14:41:45 <merijn> Maybe "You Could Have Invented Monads (And Maybe You Already Have!)" will help? It has some actual exercises to play with
14:41:55 <merijn> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:42:11 <merijn> scb: I also recommend looking up the Maybe, list and Either instances of Monad
14:42:21 <roconnor> grr. Kleene defined too many different notions of algebra :/
14:42:36 <wli> I need a LYAH for GADT's, generics, type/data families, template Haskell, and other new-ish features (constraint kinds?).
14:42:47 <merijn> scb: Manually specialising the type signatures of the monad functions (i.e. substituting the relevant specific monad in there by hand) can also help
14:42:48 <Botje> scb: the best way to learn it is just to bash your head against the typechecker.
14:42:57 <dropdrive> I'm trying to figure out how to define data that "knows" when it was last known to be valid.  (It's vague, I know.)  Is there anything out there that is kind of like this?
14:43:08 <Botje> once you understand why you're getting type errors, you're done
14:43:16 <scb> Let me check all of that.
14:43:43 <dropdrive> BMeph: Can you elaborate on your analogy...
14:45:00 <merijn> scb: You Could've invented monads lists the solution directly after the exercise, so scroll carefully if you don't want to spoil them
14:45:09 <BMeph> dropdrive: "Colour" is an abstract way to talk about individual colours. The colours themselves, though, are easier to grasp, mentally, but are really just an abstraction dealing with how different things look.
14:45:11 <scb> merijn: i just googled that but seems to be down.
14:45:24 <scb> nvm
14:45:28 <merijn> scb: I just linked it, seems to work for me
14:45:33 <scb> Apparently it was my internet.
14:46:51 <BMeph> dropdrive: Similarly, different actions of the same Monad act (or are acted on by functions) the same way, and all of those in-common ways to act on an action are what makes them Monads.
14:47:38 <merijn> Well...that explains...
14:48:02 <merijn> "cabal: command not found", turns out I don't have Platform installed >.>
14:48:07 <merijn> @where platform
14:48:08 <lambdabot> http://hackage.haskell.org/platform/
14:48:38 <merijn> Should I uninstall GHC and nuke ~/.ghc before installing?
15:05:42 <ion> For me, uninstalling GHC and nuking ~/.ghc are the same thing. :-)
15:21:27 <copumpkin> what's a good name for a type that takes another type and adds two distinguished elements to it, a Top and Bottom, that compare as you might expect
15:22:35 <sm> Terminator !
15:22:59 <copumpkin> I was thinking Bounded, but that's already a typeclass (one that I'd probably want to make an instance) :/
15:24:04 <copumpkin> perhaps I don't want that type after all
15:24:09 <sm> OrdLimit
15:24:48 <sm> Sandwich
15:24:50 <aristid> copumpkin: copy the name from Data.AVL?
15:24:51 <copumpkin> :)
15:24:52 <sm> I shall stop
15:24:56 <copumpkin> aristid: lol
15:25:48 <aristid> copumpkin: ah, Data.AVL uses Key⁺
15:25:52 <copumpkin> yeah, I know :)
15:26:00 <copumpkin> that isn't a valid haskell identifier though
15:26:08 <aristid> oh.
15:26:16 <copumpkin> anyway,
15:26:20 <copumpkin> I don't actually need one
15:26:23 <aristid> copumpkin: ExtendedKey?
15:27:30 <copumpkin> hmm
15:28:13 <copumpkin> I don't think I actually need it
15:29:24 <aristid> ok
15:29:30 <copumpkin> thanks :)
16:00:35 * hackagebot hotswap 0.1.8.0 - Simple code hotswapping.  http://hackage.haskell.org/package/hotswap-0.1.8.0 (MikeLedger)
16:05:25 <sm> hotswap.. nice
16:09:06 <ion> Too bad the examples directory doesn’t contain an example of how have a running “main” loop to jump to a new version of itself. I’d have liked to see that.
16:11:18 <ion> I suppose it’s just a recursion to usePlugin newLoop 1 instead of just loop, but i wonder if that handles the freeing of the old code properly?
16:12:28 <ion> Actually, usePlugin newLoop myState
16:22:54 <yan_> i understand that the functor instance on ((->) e) can be also thought of as a reader monad, but i don't get why. i understand that e is 'fixed', but don't see how it acts as a reader
16:26:31 <jfischoff>  has anyone tried to use agda input mode on emacs with haskell so you can more easily use unicode symbols?
16:27:02 <bitonic> jfischoff: yes, works great
16:27:10 <bitonic> with any mode really
16:27:28 <bitonic> if you have needs similar to the ones you have with agda, in terms of symbols
16:27:44 <jfischoff> bitonic: Great! Is there much setup?
16:27:47 <bitonic> yan_: a "reader monad" is simply some computation using some starting value
16:27:57 <bitonic> jfischoff: zero setup, M-x set-input-mode Agda
16:28:09 <jfischoff> sweet
16:28:11 <jfischoff> thanks
16:28:29 <bitonic> yan_: so in (e ->), `e' is the thing being read, and the result can be whatever
16:29:22 <yan_> bitonic: and 'e' is fed through each invocation of fmap or bind?
16:29:25 <bitonic> when using do notation, e.g. do { x <- foo; y <- bar; quux }, `foo' and `bar' will be applied to the value being read (the one of type `e') and the value returned
16:29:30 <bitonic> so `id' simply gets it
16:30:06 <bitonic> yan_: I'm not sure what you mean with "fed through", but yeah, I guess
16:30:45 <yan_> bitonic: hm i thought i understood this before but hmm. what is 'foo' being applied to? i.e. where does the initial 'e' come from in the above example?
16:30:56 <bitonic> yan_:  you have to supply it at some point
16:31:06 <bitonic> to run the computation
16:31:25 <bitonic> you're basically building a function of type `e -> a'
16:31:43 <bitonic> yan_: define the instance yourself, and play with it
16:31:50 <yan_> ooh! the 'e' becomes the implicit parameter to each function
16:32:37 <bitonic> yan_: yeah, in the do notation thing yes
16:32:55 <yan_> in your case foo, is "e -> a".. and it's bind just passes 'e' through
16:33:01 <bitonic> yes
16:33:22 <yan_> hmm i think i get it, but i'm going to need to implement an instance to fully grok it
16:33:33 <bitonic> yan_: definitely do that :)
16:34:12 <yan_> bitonic: in your case, you were showing the monad instance of ((->) e), not the functor, right?
16:44:54 <nand`> mm_freak: I watched the video you sent me earlier, it's great
16:50:14 <pl3> I create an unix time using getPOSIXTime on the server and I wanted to parse it to a readable date in the cliente with javascript. Shouldn't unix time be an integer ?
16:51:06 <nand`> pl3: depending on the precision it can include a fractional part for representing sub-seconds
16:52:49 <pl3> nand` is there  something I can do for it be compatible with javascrip Date constructor
16:55:35 <nand`> you could use “floor” or “round” to convert it to an Integer or Int or whatever
16:55:51 <nand`> I don't know how the javascript Date constructor works
16:55:54 <pl3> rounding always give a wrong date
16:56:19 <nand`> pl3: and working with integers doesn't?
16:56:46 <nand`> what you're rounding off is the sub-second precision, which integer unix time doesn't have either way
16:59:06 <nand`> hmm
16:59:15 <pl3> no, it does not. it seems to be 'missing' some number in comparision with getTime
17:00:52 <nand`> pl3: not for me
17:01:08 <nand`> “getPOSIXTime” and “round <$> getPOSIXTime” give very similar results for me
17:01:44 <pl3> yes, but in the client it does not construct the original date
17:02:52 <rwbarton> pl3, you obviously have some particular expectation that is not being met but we have no way to know what it is
17:04:58 <nand`> pl3: then it's your client's fault and not getPOSIXTime's
17:05:36 <dmwit> Just at a guess: did you know that all numbers in Javascript are Double?
17:05:51 <dmwit> Is it possible that more than 53 bits of precision are required for today's date?
17:06:14 <bitonic> yan_: yes
17:06:18 <nand`> 1335657698.534362s
17:06:26 <nand`> ^- what I get from getPOSIXTime
17:07:13 <nand`> Gives me “Sun, 29 Apr 2012 00:01:38 GMT”
17:07:22 <nand`> according to http://www.onlineconversion.com/unix_time.htm
17:07:24 <dmwit> Double seems to have enough precision to hold that number in its entirety.
17:20:38 * hackagebot Level0 1.0 - A Snake II clone written using SDL.  http://hackage.haskell.org/package/Level0-1.0 (MikeLedger)
17:21:31 <augur> preflex: seen edsko
17:21:31 <preflex>  edsko was last seen on #haskell 1 day, 13 hours, 38 minutes and 13 seconds ago, saying: @pl  \rc -> return (rc - 1, rc - 1)
17:21:57 <augur> @tell edsko do you know of anything else like the catsters videos?
17:21:58 <lambdabot> Consider it noted.
17:24:06 <pl3> the problem is that getPOSIXTime is in seconds but Date wants miliseconds. so only multiplying by 1000 did the trick
17:29:09 <Eduard_Munteanu> preflex: seen edwardk
17:29:09 <preflex>  edwardk was last seen on #haskell-blah 3 days, 1 hour, 41 minutes and 51 seconds ago, saying: http://comonad.com/reader/2008/linear-bloom-filters/
17:32:08 <hpaste_> stj pasted “mandelbrot fractal” at http://hpaste.org/67808
17:32:11 <stj> apparently this simple function 'next' takes a lot of memory (is it not tail recursive?) -- any idea on how to fix it?
17:33:10 <stj> oh, I should probably say that argument 'a' is of type Complex Double
17:37:08 <Eduard_Munteanu> stj: it's not just about tail recursion, (lack of) strictness can get in the way
17:38:23 <stj> Eduard_Munteanu: could you suggest how to write it in a strict fashion?
17:38:53 <BMeph> stj: Type ANGRY! ;þ
17:39:06 <parcs`> stj: how do you figure that the function consumes a lot of memory?
17:39:14 <parcs`> it looks like it shouldn't
17:39:26 <stj> parcs`: I looked at .prof file
17:39:45 <rwbarton> probably you are just calling this function a lot of times
17:39:47 <parcs`> does it consume a lot of memory or does it do a lot of allocations
17:39:47 <stj> anyway, looks like there were unnecessary Integers where all I wanted is just Int
17:39:48 <rwbarton> and retaining the results
17:39:54 <stj> and that fixed it :/
17:40:45 <stj> parcs`: allocations, I think
17:43:00 <Eduard_Munteanu> rwbarton: hm, since you're around... I did manage to get an adjunction from a monad, and a monad back from that. Now I'm wondering if getting a comonad on Hask from that is possible.
17:43:48 <Eduard_Munteanu> http://hpaste.org/67745
17:44:12 * Eduard_Munteanu was going to ask edwardk but he doesn't seem to catch him around.
17:44:51 <rwbarton> you'll get a comonad on Hask_M
17:45:00 <Eduard_Munteanu> Yeah, but that kinda sucks :)
17:45:33 <Eduard_Munteanu> Can one map Hask_M back to Hask somehow? I'm not sure if they're equivalent as categories or anything.
17:45:49 <rwbarton> they aren't
17:46:40 <Eduard_Munteanu> Ah, so this isn't really possible I guess, so much for automatically getting a comonad from a monad. Thanks.
17:47:20 <rwbarton> I mean you can do something strange like take the cofree comonad on (the underlying functor of) your monad, but I don't think the kind of thing you want to do is possible
17:47:41 <rwbarton> normally a monad won't have a left adjoint
17:47:58 <Eduard_Munteanu> I only had a vague idea of getting a comonad related to a given monad.
17:49:08 <rwbarton> do you have an idea what you want to produce for, say, the list monad?
17:49:31 <Veinor> i need a name idea: a haskell markdown parser that's not GPL-licensed
17:51:44 <dmwit> Veinor: harkness
17:51:59 <Veinor> haha
17:52:01 <Veinor> sure
17:52:04 <Eduard_Munteanu> rwbarton: not really, though I figure there might be monads where the adjoints are endofunctors (so you get back a comonad in the same category). For the general case I was hoping for a structure "similar" to the same monad on the opposite category.
17:52:54 <Eduard_Munteanu> I'm not even sure what that is for the list monad... Stream?
17:54:37 <Eduard_Munteanu> It probably doesn't make much sense for monads arising from functors to/from categories wildly dissimilar to Hask.
17:55:52 <rwbarton> well the list monad comes from the adjunction between Hask and {monoid objects in Hask}
17:56:44 <rwbarton> so I guess you can look at the adjunction between Hask and {comonoid objects in Hask}, but depending on what monoidal structure you pick on Hask the latter is either just Hask again or trivial in some other way
17:57:18 <Eduard_Munteanu> Free/forgetful for Set -> Mon, but more like Hask sets/monoids, I guess.
17:57:39 <rwbarton> I just tend to assume Hask = Set. :)
17:57:52 <rwbarton> Makes a lot of things easier
17:58:13 <Eduard_Munteanu> Yeah, it is quite similar to Set.
17:58:30 <Eduard_Munteanu> (at least the well-behaved subset of Haskell)
18:00:28 <MaskRay> i'd like to find out actual URLs of huge amounts of tinyurl. could you please point out the idiomatic approach via conduit?
18:01:50 * Eduard_Munteanu should write the adjunction for lists as an exercise though
18:01:57 <mm_freak> nand`: it is =)
18:09:46 <Hail_Spacecake> so I'm going through learn you a haskell
18:10:09 <Hail_Spacecake> specifically, http://learnyouahaskell.com/higher-order-functions#curried-functions <- the section on finding the largest number under 100000 divisible by 3829
18:10:20 <Hail_Spacecake> and I understand that function and how it works
18:10:27 <Hail_Spacecake> but, I can't type it directly into ghci
18:10:55 <Hail_Spacecake> filter p [1000000,999999..0] where p x = x `mod` 3829 == 0 has a parse error on 'where'
18:10:57 <Hail_Spacecake> and I'm not sure why
18:13:02 <geofft> Hail_Spacecake: you can do it by first saying "let p x = ..." on a separate line, instead of with where
18:14:31 <nyingen> where clauses don't work in ghci?
18:14:40 <nyingen> I don't think I've ever tried it, but I'm surprised
18:16:13 <rwbarton> where clauses are attached syntactically to declarations
18:16:16 <rwbarton> not expressions
18:16:37 <Hail_Spacecake> what's the difference between a declaration and expression?
18:17:11 <rwbarton> well in this case the declarations are equations
18:17:14 <rwbarton> like "x = 1"
18:17:30 <rwbarton> or "f (Just x) = x + 1"
18:17:46 <rwbarton> whereas an expression is just, say, "filter p [1000000,999999..0]"
18:18:44 <Hail_Spacecake> okay
18:18:55 <rwbarton> but you can write
18:19:13 <rwbarton> "let p x = x `mod` 3829 == 0 in filter p [1000000,999999..0]" because let ... in ... attaches to an expression
18:20:37 <Hail_Spacecake> why do let and where need to be two different things?
18:21:36 <Saizan> to allow different styles of presentation
18:21:40 <rwbarton> they don't need to be, but it is nice to have both
18:22:13 <nyingen> well, 'where' clauses also don't see bindings in the upper function, do they?
18:22:38 <Guest25355> hey quick question: how come toUpper "Chris" doesn't work? and what does the map function do?
18:22:53 <rwbarton> they see everything bound by the LHS of the equation they are attached to
18:23:09 <hayashi> :t toUpper
18:23:09 <lambdabot> Char -> Char
18:23:17 <hayashi> thought so
18:23:22 <dobblego> Guest23437: toUpper works on a Char while "Chris" is a list of Char. To run a function on every element on a list, to produce a new list, you use map
18:23:30 <hayashi> Guest23437: toUpper works on a... yeah, what dobblego just said =P
18:23:44 <dobblego> > map toUpper "Chris"
18:23:45 <lambdabot>   "CHRIS"
18:24:02 <Guest25355> ok so the map helps with running toUpper on every character in the string?
18:24:07 <hayashi> Yeah
18:24:17 <Guest25355> hmm so what does map exactly do?
18:24:37 <dobblego> map runs a function on every list element to produce a new list
18:24:50 <jmcarthur> :t map
18:24:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:24:52 <Guest25355> ah
18:24:52 <Guest25355> ok
18:24:55 <geofft> > map (const 3) "Chris"
18:24:56 <lambdabot>   [3,3,3,3,3]
18:24:57 <Guest25355> got it thanks :D
18:25:06 <jmcarthur> ^^ it transforms a function to work on the elements of a list
18:25:18 <Guest25355> thanks everyone ^^
18:25:46 <gentleben> Is there a way to make a State Transformer where the State has a type parameter ?
18:25:52 <shachaf> > map 3 "Chris" -- Please ignore this line.
18:25:53 <lambdabot>   [3,3,3,3,3]
18:25:58 <jmcarthur> i was about to do that :P
18:26:11 <parcs`> > 3<$"Chris"
18:26:12 <lambdabot>   [3,3,3,3,3]
18:26:14 <dobblego> gentleben
18:26:20 <dobblego> StateT takes three type parameters
18:26:57 <jmcarthur> gentleben: check out parameterized (or is it indexed? i always confuse those...) monads
18:27:13 <geofft> shachaf: How did you do that
18:27:24 <parcs`> > 3."Chris"
18:27:26 <lambdabot>   [3,3,3,3,3]
18:27:32 <jmcarthur> geofft: there is a Num instance for functions
18:27:33 <gentleben> dobblego: right, my state type is like MyState a, so I need something like newtype CoordinatorT m a = CoordinatorT{unCoordinatorT :: StateT (Coordinator b) m a}
18:27:46 <jmcarthur> geofft: literals are constructed with const
18:27:48 <gentleben> jmcarthur: indexed types?
18:27:56 <jmcarthur> gentleben: no, monads
18:28:04 <geofft> what do I need to import to get this silliness?
18:28:12 <jmcarthur> it's not in the standard libraries
18:28:33 <jmcarthur> the type would look something like this:   StateT i j m a
18:28:37 <liyang> instance Num b => Num (a -> b) where fromInteger = const . fromInteger
18:28:38 <Eduard_Munteanu> geofft: it's just in lambdabot
18:28:40 <jmcarthur> i and j are the input and output types of the state
18:28:55 <Eduard_Munteanu> Like...
18:28:58 <Eduard_Munteanu> :t (.)
18:28:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:29:07 <geofft> how do I start using lambdabot instead of haskell? it sounds like tons more fun
18:29:10 <gentleben> jmcarthur: thanks. I will look into it
18:29:24 <Eduard_Munteanu> geofft: heh, not really
18:29:35 <Eduard_Munteanu> You can install lambdabot locally though.
18:29:35 <jmcarthur> Eduard_Munteanu: it's not just in lambdabot
18:29:51 <jmcarthur> Eduard_Munteanu: it's provided as an orphan instance in some package
18:29:52 <JoeyA> > map (*2) (+1) 123
18:29:53 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
18:29:54 <lambdabot>  but its type `[a]' has none
18:30:00 <Eduard_Munteanu> jmcarthur: well, yeah... it's a vectory thingy, or something like that
18:30:02 <jmcarthur> Eduard_Munteanu: probably one by conal
18:30:20 <jmcarthur> vector-space?
18:30:30 <Eduard_Munteanu> Mm, maybe. I recall someone mentioning that.
18:30:36 <JoeyA> > (*2) . [1..5]
18:30:36 <jmcarthur> i think it might have been moved out of that by now
18:30:37 <lambdabot>   [2,4,6,8,10]
18:30:55 <jmcarthur> ugh, that terrible (.) = fmap in lambdabot ...
18:31:37 <JoeyA> > [1..5] >>> (*2)
18:31:38 <lambdabot>   Couldn't match expected type `cat a b' against inferred type `[a1]'
18:31:39 <jmcarthur> > [1..5] * 2
18:31:40 <lambdabot>   No instance for (GHC.Num.Num [t])
18:31:40 <lambdabot>    arising from a use of `e_1152' at <int...
18:31:42 <jmcarthur> :(
18:32:12 <JoeyA> :t (.)
18:32:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:32:47 <jmcarthur> :t (*) + (*)
18:32:48 <lambdabot> forall a. (Num a) => a -> a -> a
18:32:55 <jmcarthur> > (*) + (*) $ 5
18:32:56 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:32:56 <lambdabot>    arising from a use of `...
18:33:18 <Eduard_Munteanu> (*) + (*) $ 5 $ 2
18:33:21 <jmcarthur> > ((*) + (*)) 5 5
18:33:21 <Eduard_Munteanu> > (*) + (*) $ 5 $ 2
18:33:22 <lambdabot>   50
18:33:22 <lambdabot>   can't find file: L.hs
18:33:31 <Eduard_Munteanu> Bah :
18:33:32 <Eduard_Munteanu> )
18:33:38 <liyang> http://hackage.haskell.org/package/applicative-numbers
18:33:42 <jmcarthur> that's it
18:34:07 <jmcarthur> geofft: ^^ that's the package you want for this "silliness"
18:34:41 <liyang> While looking for that package, I also came across: http://hackage.haskell.org/package/mtl-evil-instances
18:35:36 * Eduard_Munteanu expected to see some STT thingy in there.
18:36:20 <rwbarton> instance MonadIO Identity where liftIO = Identity . unsafePerformIO
18:36:30 <geofft> Uhhhh.... I'm sorry I asked
18:37:44 <shachaf> rwbarton: Might as well unsafeCoerce . unsafePerformIO
18:38:11 <liyang> Right, because double-unsafe makes it safe again!
18:38:23 <shachaf> foldr (.) id . map unsafe [coerce, performIO]
18:40:27 <Eduard_Munteanu> I guess unsafeCoerce works fine for newtype wrappers, at least, no?
18:40:36 <Eduard_Munteanu> (for peeling them off, that is)
18:40:50 <shachaf> Eduard_Munteanu: For an individual value, yes.
18:41:18 <shachaf> (unsafeCoerce :: [New] -> [Old]) is probably also correct, and maybe more efficient than map unNew.
18:41:32 <shachaf> But (unsafeCoerce :: Set New -> Set Old) is probably wrong.
18:44:45 <copumpkin> Eduard_Munteanu: only works if the structure is fully parametric in the type
18:47:17 <Eduard_Munteanu> copumpkin: parametric as in parametricity? Interesting way to put it. (Although I guess it is implementation-dependent after all.)
18:47:38 <copumpkin> well, newtypes don't change representation, but they can and often do change instances
18:47:50 <copumpkin> so if your structure cares about a particular instance on that type, it might be unsafe
18:48:00 <Eduard_Munteanu> Ah.
18:48:02 <copumpkin> so unsafeCoerce on the value type of a Map is fine
18:48:05 <copumpkin> on the key type, it isn't
18:48:38 <rwbarton> unsafeCoerce on a GADT is also a bad plan
18:48:57 <copumpkin> or a data family (which is very non-parametric)
18:49:08 <Quantumplation> does snaplet-mongodb work with snap-0.8.1?
18:50:11 <Eduard_Munteanu> On a related note, I kinda wonder why DatatypeContexts is deprecated, coming from Agda. Sure, it is kinda useless and ugly in some contexts.
18:50:42 <shachaf> Eduard_Munteanu: Agda doesn't have an equivalent of DatatypeContexts, does it?
18:51:12 <Eduard_Munteanu> shachaf: it kinda has, if you add instance arguments to a data declaration
18:51:20 <shachaf> data Foo a where Foo :: Context a => ... is valid and does a different thing from DatatypeContexts
18:52:44 <Eduard_Munteanu> But that doesn't really prevent you from saying Foo A for some non-Context A. (I'm not saying it doesn't do its job though.)
18:53:53 <geekosaur> the problem with DatatypeContexts is you can never brong the dictionary implied by them into scope
18:54:53 <tazjin> > let g = mkStdGen (42*1337); d = [".se", ".me", ".net"] in d !! (fst $ randomR (0, length(d)) g)
18:54:54 <lambdabot>   ".se"
18:55:16 <Eduard_Munteanu> Hm? You can say   foo :: (Context a) => Foo a -> ...
18:55:52 <Eduard_Munteanu> Oh, if you mean it doesn't save you from typing that, yeah.
18:55:54 <geekosaur> you can provide a smat constructor, yes.  and that means there's no point to the datatyp context; put it on the smart constructor you're going to need anyway
18:57:37 <Eduard_Munteanu> But I find it reasonable for stating certain mathy things... say   newtype (Monad m) => Kleisli m a b = ...
18:58:08 <Eduard_Munteanu> And it does prevent you from applying that to a non-Monad, AFAICT.
18:58:34 <geekosaur> you also need to explicitly propvide a context when using it in a pattern match, and erx[perience has shown the reason people try to use datatype contexts is to tery to implicitly provide those contexts
18:58:52 <geekosaur> which does not work and never will beause of the way contexts are implemented
19:01:30 <Eduard_Munteanu> AFAICT, if you use a GADT, the problem is you will only get an indication something is wrong when you actually construct such a value (you don't have the dictionary). But you can keep applying it to irrelevant stuff in the meanwhile.
19:02:17 <shachaf> "applying it to irrelevant stuff"?
19:02:34 <Eduard_Munteanu> Types that aren't instances of that typeclass.
19:03:13 <Eduard_Munteanu> e.g. Kleisli NotAMonad a b will work just fine until you actually try doing something with it.
19:03:32 <rwbarton> that happens with datatype contexts too doesn't it?
19:05:47 <Eduard_Munteanu> rwbarton: hm, you're right. That is strange.
19:06:20 <Eduard_Munteanu> I somehow expected that to work (i.e. complain), or at least be doable.
19:26:43 <Quantumplation> What's [| func |] in haskell?
19:27:34 <dmwit> It's a quasiquote.
19:27:54 <dmwit> It turns a bit of Haskell syntax into a value of an algebraic data type that can represent all Haskell terms and declarations.
19:28:15 <nejucomo> I am using :load in ghci on a module which collides with the Prelude.  How can I tell ghci to hide the Prelude names?
19:28:17 <dmwit> You can then do anything you like with that -- traverse the data structure, inspect it, mangle it, etc.
19:28:28 <dmwit> :set -XNoImplicitPrelude
19:28:34 <dmwit> or :m -Prelude
19:28:45 <nejucomo> Thanks!
19:28:55 <dmwit> hm
19:28:59 <dmwit> Not actually sure if either of those work.
19:29:02 <dmwit> They don't seem to here.
19:31:50 <dmwit> You can import Prelude (), but you'll still get type class instances.
19:31:54 <dmwit> Dunno if that's going to be a problem.
19:36:25 <nejucomo> I keep failing to understand typeclasses…  I often want to say: "Any instance of class A is an instance of class B with this implementation of B using A's interface".  Is this possible?
19:37:23 <nejucomo> For example, I just defined a new type class, and there should be an instance for every instance of Integral.
19:37:42 <hpaste_> stj pasted “mandelbrot again” at http://hpaste.org/67811
19:37:44 <stj> is there anything that could be done about this short code to speed it up significantly? I've tried everything and still, equivalent java code is about 3.5 faster -- should I just accept this as a fact?
19:39:17 <dmwit> stj: Why not just use Complex Double.
19:39:22 <dmwit> s/\./?/
19:39:54 <dmwit> You might also like trying a worker-wrapper transform.
19:40:01 <stj> I used it before, then dropped it to see if there is any difference in speed -- there isn't :)
19:40:43 <dmwit> Are you compiling with -O2, by the way?
19:40:53 <dmwit> That's usually the simplest way to speed things up by a factor of 10 or so.
19:40:57 <dmwit> =P
19:41:19 <Eduard_Munteanu> vs no -O
19:43:00 <stj> dmwit: yes, I'm using -O2
19:46:20 <stj> dmwit: where do you think worker wrapper transform would apply?
19:46:43 <dmwit> in next
19:47:11 <dmwit> I tried mandlebrot' v = not . null . dropWhile ((<2) . magnitude) . take 4096 $ iterate (*v) 1
19:47:16 <dmwit> I thought that would be pretty good.
19:47:19 <dmwit> But it wasn't. =P
19:48:43 <stj> dmwit: magnitude calculates sqrt, then you compare it to 2, which is slower than simply comparing to 4
19:49:18 <dmwit> Yeah, Data.Complex doesn't have a magnitude^2 function, which is a bit annoying.
19:51:12 <dmwit> Also, there seems to be some other bug, since it doesn't produce the Mandlebrot set.
19:52:38 <dmwit> ah, yes
19:52:41 <dmwit> iterate (*v) is wrong
19:55:56 <dmwit> stj: A cheating way to go faster is to parallelize it. =)
19:56:37 <stj> dmwit: sure, but I'd still like to catch up with java :)
19:57:14 <hpaste_> wli annotated “Special numbers” with “memoized stirling numbers as list of lists (annotation)” at http://hpaste.org/67752#a67812
19:59:37 <wli> That appears to be a way to memoize subcomputations of isolated Stirling numbers of the first kind without memory growth, which may be perhaps unnecessary.
20:06:46 <jfischoff> how do you leave messages for people?
20:07:28 <dmwit> Use ?tell or ?ask.
20:07:31 <dmwit> ?help ?tell
20:07:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:07:37 <dmwit> ?help tell
20:07:37 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
20:07:46 <jfischoff> hey dmwit
20:07:59 <dmwit> howdy
20:08:27 <jfischoff> no like the Generics?
20:08:47 <dmwit> no
20:09:08 <dmwit> Part of the reason I wanted a TH solution was because I didn't want to have to change the instance declaration when the data type changed.
20:09:19 <dmwit> e.g. when the type got more type arguments
20:09:32 <jfischoff> I don't see why you would have to do that with Generics?
20:09:33 <dmwit> ...and I didn't want to have to figure out what context to give.
20:09:58 <dmwit> jfischoff: You'd have to change, e.g. "instance Default a => Default (MyType a)" to "instance (Default a, Default b) => Default (MyType a b)
20:10:01 <dmwit> "
20:10:19 <jfischoff> ah yeah that's true
20:11:04 <dmwit> Or maybe, depending on how the type changed, "instance Default a => Default (MyType a b)"
20:11:39 <dmwit> Also, I couldn't get the generic to derive an instance for
20:11:44 <dmwit> data Foo a = Foo (a -> a)
20:11:50 <jfischoff> right
20:11:56 <dmwit> ...which the TH can do. =)
20:12:32 <jfischoff> Sure, I'm frustrated with both TH and Generics right now, although compared to other languages they are both awesome
20:13:27 <jfischoff> Generics is good because if it type checks it will in general works. But I don't like how the sum and product types are representing using binary trees
20:13:35 <jfischoff> balance binary trees
20:13:47 <jfischoff> s /balance/balanced
20:14:01 <dmwit> Generics seems nice, but it's just too much boilerplate, especially for this stupid thing which is practically all boilerplate anyway.
20:14:13 <dmwit> Replacing one kind of boilerplate with another isn't really a win.
20:14:14 <jfischoff> Not with default signatures
20:14:22 <jfischoff> then it is better I think
20:14:33 <dmwit> What are default signatures?
20:15:06 <jfischoff> opps default implementations
20:15:29 <dmwit> How does that help?
20:15:40 <dmwit> I mean, the boilerplate here is the line declaring that you want an instance.
20:15:45 <jfischoff> you only have to say instance FromJSON Blah
20:16:01 <jfischoff> I'm assuming, because the TH was longer
20:16:20 <dmwit> Oh, you mean that it eliminates the "where whatever = to gDefault; whateverElse = to gDefault"?
20:16:23 <dmwit> I see.
20:16:27 <jfischoff> yeah
20:16:48 <jfischoff> you don't have to learn a special TH method for every class
20:17:10 <dmwit> yes
20:17:18 <dmwit> Presumably, in time, we'll develop some convention.
20:17:38 <jfischoff> Or add  a way to use TH for default implementatios
20:18:05 <dmwit> that would be the best, yeah
20:18:43 <jfischoff> Although if I had my way I would also change the AST of TH
20:20:10 <jfischoff> ?seen EnglishGent
20:20:10 <lambdabot> Unknown command, try @list
20:20:27 <jfischoff> how do you check when someone was last seen?
20:24:45 <nyingen> jfischoff: ask preflex?
20:25:05 <nyingen> preflex: seen EnglishGent
20:25:06 <preflex>  EnglishGent was last seen on #haskell 3 days, 15 hours, 36 minutes and 57 seconds ago, saying: hi quicksilver :)
20:25:07 <eviltwin_b> yeh, preflex is the bot for seen stuff (had answered that but notwork sucky here, was talking to dead air)
20:25:21 <nyingen> heh, 'notwork'
20:25:40 <nyingen> network? more like notwork, amirite
20:25:43 <eviltwin_b> used with malice aforethought
20:25:56 <nyingen> oh, I thought maybe you were a dvorak typist
20:26:00 <dmwit> stj: Well, I've found a lot of ways to make your code slower.
20:26:23 <eviltwin_b> neh.  notwork / nyetwork comon snarky references to bad network
20:26:52 <jfischoff> ?tell EnglishGent Here is the haskell source an early version of the Pi reversible language http://www.cs.indiana.edu/~sabry/papers/Pi.hs
20:26:52 <lambdabot> Consider it noted.
20:27:36 <stj> dmwit: me too :/
20:29:10 <dmwit> Aha! I made it faster!
20:29:19 <dmwit> Down from 5.22s to 4.52s.
20:29:40 <stj> not impressive, but cool :) what did you do?
20:30:20 <hpaste_> dmwit pasted “slightly faster” at http://hpaste.org/67813
20:30:43 <dmwit> compile with -fllvm
20:31:15 <stj> dmwit: I've been playing with haskell and optimizing programs (although I'm still a beginner) ... so I came with this conclusion in cases of programs that do a lot of computation: if you write beautiful code in haskell, it's going to be about 10 times slower than C code, although you can optimize it to be around 5 times slower with a lot of effort by making code horribly ugly.... (for comparison, python is about 100 times slower)
20:32:08 <dmwit> I don't know, I think the code I just pasted is quite beautiful, and faster than your ugly version.
20:32:12 <dmwit> So what lesson do you take from that?
20:32:19 <copumpkin> lol
20:33:51 <stj> dmwit: wow, this is pretty good... this code is now comparable to java, and that makes me happy
20:34:23 <stj> dmwit: I should learn about vectors
20:34:45 <hpaste_> yan_ pasted “MonatTrans” at http://hpaste.org/67814
20:35:41 <yan_> can anyone check the paste? i'm not sure how to 'lift' a maybe string into a MaybeT
20:36:19 <Saizan> maybe mzero return
20:36:24 <dmwit> MaybeT . return
20:36:38 <rasfar> dmwit: have you seen http://fremissant.net/portackage and is it to your liking?  (seeing as you approved of the idea...)
20:37:18 <rasfar> if anyone else has suggestions i'd be glad to have 'em
20:37:45 <rasfar> the slowness is not so much the download, as the client-side javascript processing as it's a fair chunk of data
20:37:46 <dmwit> yan_: Mine's cheaper than Saizan's, won't unpack and repack. But that cost is going to be negligible next to network access costs... =P
20:38:26 <dmwit> rasfar: I just typed "Maybe" into the exposed-modules text box and it hung my browser...
20:38:35 <yan_> dmwit: thanks, makes sense
20:38:59 <rasfar> it'll come around ;)
20:39:34 <rasfar> you may get a "script not responding" but it's the best i could do so far
20:39:48 <rasfar> (paging is worse in any case)
20:40:08 <dmwit> Dunno what it does, but if it's a filter, perhaps you could do some memoization...
20:40:17 <yan_> dmwit: i guess i'm not getting why.. why is return return lifting Maybe String to IO String?
20:40:18 <dmwit> Some kind of prefix trie or so?
20:40:31 <rasfar> indeed; optimisations are in the works.
20:40:32 <dmwit> yan_: return turns Maybe String into IO (Maybe String).
20:40:47 <dmwit> rasfar: When it finishes thinking, I'll let you know whether it's useful... =P
20:40:50 <dobblego> :t liftIO
20:40:51 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:40:57 <dobblego> :t unliftIO
20:40:58 <lambdabot> Not in scope: `unliftIO'
20:41:39 <rasfar> =D thanks.  i'm surprised it's still working, that's a long time.  on my netbook it's never more than a minute (still horrid, but for what it gives you it's worth it)
20:42:41 <dmwit> Seems useful.
20:42:44 <yan_> dmwit: hmm isn't the 'do { .. }' operating in the MaybeT monad transformer, not the IO monad?
20:42:45 <dmwit> Thanks for working on it!
20:42:54 <dmwit> yan_: Yes, that's why you also need the MaybeT bit.
20:43:05 <dmwit> MaybeT :: IO (Maybe String) -> MaybeT IO String
20:44:08 <yan_> dmwit: i guess what i'm asking is how does "return (Maybe "foo")" infer that i want to lift to the IO monad?
20:44:33 <stj> dmwit: what's the magic behind -fllvm?
20:44:45 <dmwit> stj: The LLVM framework is the magic behind -fllvm.
20:44:51 <dmwit> (Plus an LLVM code generator in GHC.)
20:44:58 <dmwit> yan_: type inference is truly an amazing thing, no?
20:45:22 <stj> dmwit: if it is so great, why isn't it default option?
20:45:34 <dmwit> yan_: Not much to say except that it observes the type of the do block is MaybeT IO a, and concludes that if you write "MaybeT (return x)", then x must be a Maybe a and return must be going into the IO monad.
20:45:34 <rasfar> on my asus netbook, with the page fully loaded, if I *paste* Maybe into the filter box of exposed-modules and press return, I get the list in about 3 seconds
20:45:45 <yan_> dmwit: i agree, but being not familiar with HM type inference, but how does return know to lift into the right monad?
20:45:48 <yan_> dmwit: ahh
20:45:50 <rasfar> but if try to type it in, it's horrible.  i'll try to hack it to require pressing enter.
20:45:51 <dmwit> stj: Because it's new, and because it sometimes loses to the native codegen.
20:46:00 <yan_> dmwit: damn.
20:46:53 <rasfar> (the JS code it's using is not mine generally, but can still hack it i guess)
20:47:01 <dmwit> rasfar: Alternately, use a short timeout, and reset the timeout every time the user hits a key.
20:47:13 <rasfar> dmwit: i like it!
20:47:13 <dmwit> A few milliseconds should be enough -- just enough time that a fast typist will hit something.
20:47:23 <copumpkin> is it possible to have a fingertree with two independent map-like key lookups where the keys are not monotonic with one another? :P
20:47:26 <rasfar> sweet
20:47:27 <copumpkin> I'm leaning towards no
20:47:40 <dmwit> I don't think so, but you can have two fingertrees.
20:47:45 <dmwit> Same asymptotics as one fingertree.
20:47:47 <copumpkin> dmwit: the horror!
20:47:57 <copumpkin> what about the asymptotic elegance
20:48:01 <dmwit> =)
20:48:39 <yan_> dmwit: sorry, one more question: so I am calling that function via the 'do { var <- func }' syntax, and var receives a String from MaybeT IO String. i would assume <- would strip away the MaybeT but not IO, how come the String is derived from IO?
20:48:53 <copumpkin> so it seems like you can have as many commutative monoids as you want, but only one meaningful non-commutative one at a time (for efficient monotonic lookups, that is)
20:49:39 <copumpkin> does that sound about right?
20:49:50 <dmwit> yes
20:50:01 <copumpkin> I see
20:50:03 * copumpkin strokes chin
20:50:30 <copumpkin> this is unfortunate!
20:50:39 <dmwit> yan_: I'm not sure I understand the question yet.
20:50:50 <dmwit> But var <- func unwraps *the whole monad*, whatever that is.
20:51:08 <dmwit> For example, "MaybeT IO" is a monad.
20:51:21 <copumpkin> two fingertrees doesn't quite do it either
20:51:25 * copumpkin ponders
20:51:31 <dmwit> Really? Why not?
20:51:32 <yan_> dmwit: ah. it's just parameterized. hm.
20:51:41 <yan_> dmwit: (this will take a lot of toying around) thank you though!
20:52:40 <copumpkin> dmwit: well, I have the primary lookup structure by the fancy monoids and then the "by-id" lookup structure. The primary lookup structure can carry an id in its value, but the id can't really refer to any unique attribute of the primary lookup structure
20:53:10 <dmwit> um
20:53:16 <dmwit> That is somewhat annoying, yes.
20:53:30 <copumpkin> I normally wouldn't care about identity in the primary lookup
20:53:35 <copumpkin> except for the fact that orders have priority
20:53:37 <dropdrive> I feel like I've read about using the type system to tag, say, strings as user-inputted and unquuoted possibly "dangerous".  Are there any good links about this?
20:53:57 <copumpkin> so I don't want to accidentally remove the wrong one
20:54:03 <dmwit> dropdrive: There's not much to understand.
20:54:14 <dmwit> dropdrive: "newtype" creates a new type that's identical to another one, but with a different name.
20:54:18 <dmwit> the end
20:54:33 <dropdrive> dmwit: fair enough, I guess
20:54:47 <copumpkin> dropdrive: importantly, it does not unify with the underlying type
20:55:02 <jfischoff> dropdrive: you can also inherit the type class instances with new type deriving
20:55:05 <copumpkin> so if you try to use one where the other belongs, you'll get an error
20:55:10 <dmwit> So, to use an example I'm familiar with, you might write "newtype WindowId = WindowId Word32" and "newtype ButtonId = ButtonId Word32". Now there's no change of mixing up your buttons and your windows.
20:55:24 <dropdrive> dmwit: I'm trying to figure out how to tag data with a "time computed" and rejecting data that is sufficiently stale.
20:55:41 <dropdrive> dmwit: So I was hoping to find something along those lines...
20:55:43 <dmwit> You can't create new types at runtime, sorry.
20:56:19 <copumpkin> well, you sort of can simulate types that are unknown at compile time
20:56:19 <dmwit> ...actually, that's sort of half a lie.
20:56:23 <dmwit> yeah
20:56:30 <dmwit> I doubt it will be worth the effort, though.
20:56:39 <dmwit> It might be more convenient in a language with a better type system.
20:56:42 <dmwit> like Agda
20:56:53 <copumpkin> yeah, but it isn't terribe in Haskell either
20:56:59 <dropdrive> copumpkin: "type" unifies, right?
20:57:10 <copumpkin> you need lots of rank-2 continuations or existential wrappers on the outermost layer though
20:57:23 <copumpkin> dropdrive: ?
20:57:52 <dropdrive> copumpkin: hrm, nvm.
20:57:56 <ski> dropdrive : yes, given `type String = [Char]', the type `String' unifies with `[Char]' (they're the same type)
20:58:16 <dropdrive> ski: Yes, I guess that's what I meant.
20:58:27 <dmwit> copumpkin: I can't really think of a good, functional data structure that would do what you want, which is a bit frustrating.
20:58:40 <dmwit> copumpkin: I mean, the way you do it imperatively is you have a function which deletes an element by pointer.
20:58:44 * copumpkin places his fist to his forehead and ponders harder
20:58:53 <copumpkin> yeah, ick :P
20:59:03 <dmwit> copumpkin: Then you have two data structures, and store in each one a pointer to the corresponding value in the other.
20:59:31 <copumpkin> still seems hard to do persistently
20:59:38 <copumpkin> because you need a path into the structure more than a pointer
20:59:55 <Saizan> you can always emulate pointers with IntMap
21:00:04 <dmwit> To support a deletion-by-pointer operation, your structure must include sufficiently many pointers to recreate a path from a pointer.
21:00:07 <dmwit> e.g. parent pointers in a tree
21:00:21 <copumpkin> Saizan: I'm not sure that works very well here, even
21:00:39 <copumpkin> let me write up a quick blurb explaining what I want to do
21:00:43 <copumpkin> and see if you guys have any ideas
21:00:48 <copumpkin> (if you' care enough)
21:01:36 <Saizan> i guess measure gets complicated
21:02:38 <Saizan> a bit less if each pointer is write-once
21:03:14 <jfischoff> what's the best way to parse latex with haskell?
21:04:08 <dmwit> In short: don't.
21:04:38 <dmwit> You might look into pandoc if you want something that parsers subsets of latex.
21:04:49 <jfischoff> cool
21:05:52 <dmwit> TeX (and, by extension, LaTeX) is a pretty horrible language, though. It can't really be done properly short of a full implementation.
21:05:57 <rasfar> the idea of writing a parser for latex makes my flesh crawl
21:07:08 <dmwit> The horrible thing about TeX is that you can change how the parser is supposed to behave *with TeX commands*.
21:07:45 <rwbarton> and that this is actually a normal thing to do
21:07:54 <jfischoff> he, yeah I just want to write math expression that look pretty and I can evaluate. I'm open to alternative suggestions.
21:10:04 <nyingen> what is Data.Dynamic for?
21:10:46 * hackagebot hoauth2 0.1 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.1 (HaishengWu)
21:11:16 <dmwit> can't think of a use
21:11:26 <jfischoff> deserialization is my guess
21:11:51 <nyingen> I was under the impression that I could use it to deal with dynamic typing, in the interpreter I'm writing for such a language
21:12:08 <dmwit> Sure, that seems reasonable.
21:12:20 <nyingen> couldn't figure out how to use the package for that purpose, though
21:12:25 <copumpkin> dmwit, Saizan: http://hpaste.org/67816
21:12:39 <dmwit> nyingen: type Environment = [(Variable, Dynamic)] -- ?
21:12:49 <nyingen> sure
21:13:05 <nyingen> but what are the particulars? I need to be able to "coerce" an Int into Double and vice versa
21:13:17 <dmwit> No, no, that's separate from dynamic typing.
21:13:22 <dmwit> Dynamic is not for coercions.
21:13:29 <nyingen> it isn't?
21:13:31 <dmwit> No.
21:13:59 <copumpkin> it forgets the type and then lets you pull a value out if you remember what type it was
21:14:04 <copumpkin> if you don't, you don't get the value out again
21:14:05 <nyingen> So in the interpeter, I have something like: data XValue = XString String | XDouble Double | XInt Int ...
21:14:05 <dmwit> Dynamic is basically *only* a tag telling what type a thing is together with a value of that type.
21:14:05 <rwbarton> dynamic is basically to save you from writing   data U = Int Int | Bool Bool | Double Double | Object String [(String, U)] | ...
21:14:31 <nyingen> hm
21:14:55 <dmwit> nyingen: Yes, and you have something like "coerceToDouble (XDouble d) = XDouble d; coerceToDouble (XInt i) = XDouble (fromIntegral i)" or some such thing, right?
21:15:17 <nyingen> I thought there would be some other way to do that
21:15:30 <nyingen> is that the best way?
21:15:37 <rwbarton> making e.g. + promote its argument is special logic that is part of the semantics of your language
21:15:44 <nyingen> right
21:15:47 <ceasarbautista> Is there anyway to force a number to be an int instead of an integer in ghci?
21:15:47 <dmwit> So instead, you write "coerceToDouble d = case fromDynamic d :: Maybe Double of Just d -> toDynamic d; Nothing -> case fromDynamic d :: Maybe Int of Just i -> toDynamic (fromIntegral i); Nothing -> d"
21:15:57 <ceasarbautista> *NFA> let n = NFA (fromList [0, 1]) (singleton (Move 0 'b' 1)) 0 (singleton 1)
21:15:58 <ceasarbautista> *NFA> :t n
21:15:58 <ceasarbautista> n :: Nfa Integer
21:16:03 <nyingen> dmwit: hm, ok
21:16:22 <rwbarton> looks better already
21:16:26 <dmwit> lol
21:16:57 <nyingen> The main problem I'm struggling with is having the functions in the interpreter's library (both system-defined and user-defined) check their "types". A function of 2 values, for example, should be able to be annotated with something like "requires a string and a number"
21:17:19 <dmwit> Yes, Dynamic provides that ability.
21:17:19 <nyingen> obviously that's checked at runtime, and I want to throw an exception if the (dynamic) types are infeasible
21:17:19 <rasfar> :t fromInteger
21:17:20 <lambdabot> forall a. (Num a) => Integer -> a
21:17:53 <rasfar> caesarbautista ^ might help
21:18:12 <nyingen> dmwit: Ok, I'll try working with it some more, if you say that's a reasonable approach. Any hints in that regard?
21:18:13 <dmwit> e.g. the scheme-like "int?" could be converted to something like "isJust . (fromDynamic :: Dynamic -> Maybe Int)".
21:18:18 <rwbarton> can't you do that easily enough with XValue, where you implement the function?  myFunc (XString s) (XInt i) = {- do something with s and i -}; myFunc _ _ = raise "invalid arguments to myFunc"
21:18:38 <rwbarton> or myFunc (XString s) (coerceToDouble -> XDouble d)
21:18:53 <nyingen> rwbarton: hm, that looks plausible
21:19:13 <dmwit> ceasarbautista: Welcome to the Monomorphism Restriction.
21:19:22 <dmwit> ceasarbautista: :set -XNoMonomorphismRestriction and try again.
21:19:37 <rwbarton> basically you think of all your functions that put requirements on the type of their arguments as being partial functions
21:20:32 <ceasarbautista> dimwit: Awesome, thanks! I'll have to look into that more closely.
21:20:42 <ceasarbautista> *dmwit
21:24:43 <PointFree> @hoogle join
21:24:43 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
21:24:43 <lambdabot> package join
21:24:43 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
21:24:52 <PointFree> @type Monad
21:24:53 <lambdabot> Not in scope: data constructor `Monad'
21:24:57 <PointFree> @instance Monad
21:24:57 <lambdabot> Maybe you meant: instances instances-importing
21:25:00 <PointFree> @instances Monad
21:25:01 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
21:25:30 <PointFree> @kind (->)
21:25:30 <lambdabot> ?? -> ? -> *
21:25:49 <Eduard_Munteanu> PointFree: looking for something in particular?
21:26:22 <nyingen> rwbarton,dmwit: so should I bother with Data.Dynamic? I'm sorry if I'm missing something, but it seems like your respective approaches are basically the same, and I'm still not sure what Data.Dynamic is supposed to be for
21:26:32 <PointFree> Eduard_Munteanu: A means to convert all my functions definition to point-free versions, except when pattern-matching is needed.
21:26:53 <Eduard_Munteanu> PointFree: there's @pl
21:27:02 <Eduard_Munteanu> @pl f x y = x
21:27:02 <lambdabot> f = const
21:27:15 <ceasarbautista> That's cool
21:27:41 <ski> @help pointless
21:27:41 <lambdabot> pointless <expr>. Play with pointfree code.
21:27:49 <Eduard_Munteanu> It doesn't make much sense to convert *everything* to pointfree though, from a practical POV.
21:28:21 <ceasarbautista> @pl f x y = x + y
21:28:22 <lambdabot> f = (+)
21:28:28 <rwbarton> nyingen: personally i wouldn't. i think Data.Dynamic is for situations where it is impractical to list all the possible types. for instance, when dynamically loading a function
21:28:33 <PointFree> @pointless { loop 1 = id ; loop x = (div  2) . succ }
21:28:33 <lambdabot> (line 1, column 1):
21:28:34 <lambdabot> unexpected "{"
21:28:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:28:48 <dmwit> nyingen: "go with your heart"
21:29:02 <PointFree> @pointless let { loop 1 = id ; loop x = (div  2) . succ } in loop
21:29:03 <lambdabot> (line 1, column 5):
21:29:03 <lambdabot> unexpected "{"
21:29:03 <lambdabot> expecting "()", natural, identifier or "in"
21:29:17 <PointFree> @pointless let { loop 1 = id ; loop x = (div  x 2) . succ } in loop
21:29:17 <lambdabot> (line 1, column 5):
21:29:18 <lambdabot> unexpected "{"
21:29:18 <lambdabot> expecting "()", natural, identifier or "in"
21:29:24 <nyingen> dmwit: well, I couldn't really figure out Data.Dynamic, so I guess I'll leave it alone :)
21:29:24 <dmwit> PointFree: stop
21:29:27 <ski> it doesn't understand the full syntax
21:29:31 <nyingen> rwbarton: sounds reasonable
21:29:31 <PointFree> Never mind, I will try a private conversation with lambdabot.
21:29:35 <PointFree> Sorry,mç people.
21:29:42 <PointFree> I will not spam anymore.
21:29:42 <dmwit> PointFree: ?pl doesn't do braces. It's telling you that.
21:29:47 <PointFree> Also, I am not fully sober.
21:29:53 <ceasarbautista> @pl shunt o p [] = (reverse o) ++ p
21:29:54 <lambdabot> (line 1, column 14):
21:29:54 <lambdabot> unexpected "="
21:29:54 <lambdabot> expecting variable, "(", operator or end of input
21:30:10 <dmwit> PointFree: You might like "iterate", though.
21:30:23 <ski> PointFree : if you remove the `{' and `}', it accepts it
21:30:25 <dmwit> :t \f n -> take n . iterate f
21:30:26 <lambdabot> forall a. (a -> a) -> Int -> a -> [a]
21:30:42 * PointFree hates lambdas.
21:30:46 <dmwit> :t \f n -> (!!n) . iterate f
21:30:47 <lambdabot> forall a. (a -> a) -> Int -> a -> a
21:30:52 <ceasarbautista> @pl shunt o p = (reverse o) ++ p
21:30:52 <lambdabot> shunt = (++) . reverse
21:31:09 <ceasarbautista> shunt o p x = (reverse o) ++ p
21:31:35 <ski> ceasarbautista : .. reading "Haskell: The Craft of Functional Programming" ?
21:32:11 <ceasarbautista> ski: No, why?
21:32:34 <ski> just that use of `shunt', i think it's used in that book
21:32:53 <ceasarbautista> Oh, it looks like I was reading some other paper but the author.
21:33:15 <ski> ok
21:33:40 <ceasarbautista> He wrote a paper on how to convert RegExs to NFAs. So I implemented his paper and then wrote a function to build a parse tree for the RegExs so I can go straight from String to NFA.
21:33:49 <ceasarbautista> Does he do the same in the book?
21:34:20 <ski> at least not in the edition i have
21:34:34 <ski> (maybe in 3rd edition)
21:38:49 <copumpkin> dmwit, Saizan: I think I have an ugly solution :P
21:42:26 <dmwit> ?unmtl StateT Int (WriterT Constraints [])
21:42:27 <lambdabot> Plugin `unmtl' failed with: `StateT Int (WriterT Constraints [])' is not applied to enough arguments, giving `/\A. Int -> [(A, Int, Constraints)]'
21:42:31 <dmwit> ?unmtl StateT Int (WriterT Constraints []) a
21:42:31 <lambdabot> Int -> [(a, Int, Constraints)]
21:50:48 <nyingen> unmtl?
21:52:29 <copumpkin> it's expanding the MTL newtypes, basically
21:53:53 <nyingen> interesting.
21:54:29 <nyingen> haskell is full of surprises like that. So are C++ and Java, but in a bad way
21:57:13 <dmwit> bleh
21:57:17 <dmwit> I'm confusing myself.
21:57:28 <dmwit> Can Writer (Sum Int) be used as a unique-id supply?
21:57:38 <mikeplus64> does cabal have a command to remove packages?
21:57:49 <dmwit> no
21:57:49 <hpaste_> yonahw pasted “store_credit” at http://hpaste.org/67817
21:57:51 <mikeplus64> there is ghc-pkg unregister but that does not remove documentation if it exists
21:58:25 <dmwit> yonahw: Needs more "in"
21:58:29 <dmwit> or less let
21:58:33 <dmwit> likely both
21:58:46 <yonahw> is let the way I should be declaring a value?
21:59:05 <hpaste_> dmwit annotated “store_credit” with “store_credit (annotation)” at http://hpaste.org/67817#a67818
21:59:52 <dmwit> You might prefer "where", according to personal aesthetics.
22:00:00 <yonahw> dmwit:  thank you very much for your assistance
22:00:26 <yonahw> I don't really have preferences yet as I'm really just getting to know the language. This was from a google code jam question
22:00:48 * hackagebot hotswap 0.1.9.2 - Simple code hotswapping.  http://hackage.haskell.org/package/hotswap-0.1.9.2 (MikeLedger)
22:04:25 <hpaste_> yonahw annotated “store_credit” with “store_credit (annotation)” at http://hpaste.org/67817#a67819
22:05:11 <yonahw> solved the issue with let but I must not have closed it correctly or something. getPrices should be a new function
22:08:30 <dmwit> yonahw: read my annotation more carefully.
22:09:15 <dmwit> Or ask your computer to read it carefully for you, e.g. by using "diff".
22:09:28 <dmwit> bleh, I must be feeling grumpy
22:09:34 <dmwit> You're missing an "in" after the bindings.
22:10:03 <yonahw> oh duh! thank you so much
22:10:15 <mikeplus64> if anyone is interested i recently uploaded this http://hackage.haskell.org/package/hotswap
22:10:26 <mikeplus64> which is a simple interface to plugins for hotswapping code
22:10:44 <yonahw> I was completely missing that, thought you were referring to the indentation of "Case #".. which caused another compiler error
22:11:08 <jfischoff> mikeplus64: I will be :)
22:11:24 <mikeplus64> ive got an example here: https://github.com/mikeplus64/hotswap/blob/master/examples/Main.hs
22:11:25 <No1BadGrl> Greetings
22:12:10 <jfischoff> mikeplus64: very cool
22:12:18 <mikeplus64> thanks :)
22:16:57 <jfischoff> is there an easy way to tell if a Char is a greek lower case letter?
22:18:56 <geekosaur> not in the base libraries; there are several wrappers for icu on hackage though
22:19:33 <jfischoff> geekosaur: what is icu? and which packages?
22:21:20 <geekosaur> ICU is the library pretty uh everyone uses for unicode conversion and analysis (including the various code blocks and attributes)
22:22:03 <geekosaur> for the other, it's easy enough to search for
22:23:26 <yan_> i'm using hxt to parse something similar to: "<entry><tag1 id="foo">a</tag1><tag2>b</tag2></entry>", how would i go about selecting tag2 if tag1's id matches something (like "foo")
22:24:08 <yan_> i understand i need an arrow combinator that decides based on another arrow, but i'm not sure how to apply it
22:25:48 * hackagebot hotswap 0.1.9.3 - Simple code hotswapping.  http://hackage.haskell.org/package/hotswap-0.1.9.3 (MikeLedger)
22:26:16 <yonahw> woot! just successfully wrote my first Haskell program. Thank you dmwit for your help there with the let syntax.
22:32:10 <MostAwesomeDude> Okay, has anybody else done ASTs in Haskell? I'm having a hell of a time getting my head around how to do operations on my trees.
22:32:53 <jfischoff> MostAwesomeDude: trees are haskell's forte
22:33:18 <jfischoff> MostAwesomeDude: post some code, also look at Uniplate
22:35:08 <hpaste_> MostAwesomeDude pasted “Tree” at http://hpaste.org/67820
22:35:22 <MostAwesomeDude> jfischoff: ^^ Suggestions welcome.
22:35:48 <dnm> jfischoff: This Uniplate?: http://community.haskell.org/~ndm/uniplate/
22:36:02 <jfischoff> dnm: yes
22:36:32 <jfischoff> MostAwesomeDude: what are you trying to do with your Expression?
22:38:14 <MostAwesomeDude> jfischoff: Apply transformations to it, eventually yielding a simplified tree.
22:38:45 <MostAwesomeDude> jfischoff: Things like turning Music [Drums expr] into Music [expr] and so forth.
22:39:20 <MostAwesomeDude> I used the visitor pattern in other languages, but it's proving difficult to implement. I was going to implement Traversable, but it's non-obvious how to do that since Expression is certainly not a Functor or Foldable.
22:40:25 <jfischoff> MostAwesomeDude: Start simple.
22:41:01 <jfischoff> for a transformation you are going to write a recursive function and just cover all your cases
22:41:15 <jfischoff> then move to use the transform function of Uniplate
22:42:10 <jfischoff> Visitor came from an OO attempt to emulate functional programming
22:45:34 <jfischoff> MostAwesomeDude: Does that make any sense?
22:46:10 <MostAwesomeDude> jfischoff: uniplate looks too generic TBH.
22:46:17 <MostAwesomeDude> jfischoff: Data.Tree looks helpful though.
22:47:39 <jfischoff> MostAwesomeDude: ok
22:48:46 <MostAwesomeDude> jfischoff: Maybe I'm just not seeing it yet. I feel more comfortable when I can actually understand what a library's doing, and uniplate is just...yeah. But thank you for the suggestion; it's interesting.
22:49:45 <jfischoff> MostAwesomeDude: after you recurse many different AST you will understand what Unicode gives you.
22:50:40 <MostAwesomeDude> jfischoff: Well, it's just this one AST, and I wouldn't be complaining normally but some of these transformations are *stupid* hard.
22:51:07 <jfischoff> post an example of a hard one
22:53:43 <MostAwesomeDude> Okay. Those Durations need to be carried forward when they don't have default values. It's like a stateful map, or something.
22:54:59 <jfischoff> MostAwesomeDude: don't follow.
22:55:03 <MostAwesomeDude> jfischoff: http://bpaste.net/show/ewlCjQ3RqdvqAn372zTt/ line 68 is where things start getting stupid hard.
22:55:26 <MostAwesomeDude> And it only gets worse from there.
22:56:18 <jfischoff> so are you offset the durations?
22:56:29 <jfischoff> s /offset/offsetting
22:58:26 <MostAwesomeDude> Well, sometimes the durations don't exist. So we use the previous duration in the AST. But if there's a duration, we need to save it for the next time there's a missing duration.
22:58:41 <MostAwesomeDude> It's like filling in default values, but statefully.
22:59:00 <yan_> with HXT examples, what exactly does 'proc' do? i can't get info on it within ghci?
22:59:26 <jfischoff> MostAwesomeDude: You will just recurse with a Reader monad I think, maybe a state monad.
22:59:33 <yan_> ahh proc is roughly a lambda of an arrow
22:59:45 <Saizan> yeah, proc is part of the arrow notation
23:00:17 <yan_> Saizan: why can't i do a :t on it in ghci?
23:00:24 <yan_> is it part of syntax?
23:00:35 <yan_> hm yeah i'm assuming it is
23:00:48 <Saizan> yep, it's a keyword
23:01:54 <MostAwesomeDude> jfischoff: Yeah, I was working with State. I just was getting really frustrated and figured that I was Doin' It Wrong.
23:02:40 <jfischoff> MostAwesomeDude: I don't fully understand the task, but my ini tuition is that Reader + local is what you want
23:03:17 <MostAwesomeDude> jfischoff: Reader doesn't work, because I need to modify the state too. State is right, but getting that controllable recursion right was giving me a headache.
23:03:35 <MostAwesomeDude> What I really wanted to be able to do was traverse using Traversable, but that's a non-trivial thing to achieve.
23:03:55 <jfischoff> Reader plus local lets you modify state for the children only
23:23:28 <jonaskoelker> > 2 + 2 == 4
23:23:29 <lambdabot>   True
23:27:10 <hpaste_> yan_ pasted “misguided attempt at HXT/Arrows” at http://hpaste.org/67822
23:27:32 <yan_> can someone take a look at the above, (i explained my problem in longer form with a sample)
23:28:09 <Veinor> design question, i have a module that essentially is a small wrapper around a C library that exports a function of type String -> String
23:28:51 <Veinor> should I change that so that it's Text -> Text, or provide a parseText :: Text -> Text?
23:31:58 <geekosaur> Veinor, if it treats the string as bytes the most idiomatic would be ByteString, if as UTF-8 then Text.  String is actually a poor choice for a C API because it's a boxed linked list in Haskell
23:34:19 <geekosaur> (linked list of boxed characters, that is; ByteString is the closest Haskell equivalent to C's (char[]))
23:38:23 <Veinor> ah, ok
23:40:51 * hackagebot hamlet 1.0.1.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.1.2 (MichaelSnoyman)
23:41:48 <Sondre_B> how to pattern match on only one value left in list?
23:41:55 <Sondre_B> x:[]?
23:42:00 <danharaj> (x:[])
23:42:01 <danharaj> yes
23:42:23 <Sondre_B> but that gives me overlapping with x:xs. That is what I don't get
23:42:42 <Saizan> xs could be []
23:43:00 <yan_> ah got it! the 'guards' function in XHT was what i needed
23:43:20 <Saizan> ovelapping patterns aren't that bad btw
23:43:47 <Sondre_B> so could changing the order help? Checking x:xs if x can be [] and then x:[] will give overlap, but the other way around won't because [] cannot be xs?
23:44:29 <Saizan> if two patterns overlap they do so in any order
23:44:37 <Saizan> the meaning won't be the same though
23:44:44 <liyang> You could write x : xs@(_ : _)
23:44:48 <Saizan> putting (x:xs) before (x:[]) doesn't make sense
23:45:21 <yan_> hm spoke too soon
23:45:47 <Sondre_B> well, changing the order removed the warning in Ghci and it runs now, so it worked to just change the order
23:46:21 <Sondre_B> not it is x:[] and then x:xs :)
23:46:30 <Sondre_B> *not = now
23:49:42 <Saizan> ah, i guess the warning is more specific then i assumed
23:49:47 <Saizan> *than
23:58:32 <dmwit> Sondre_B: You can also use [x] as a pattern.
