00:01:27 <geekosaur> why?
00:01:47 <shergill> i wondered if ghc-prim was being shadowed. it doesn't look like it
00:02:11 <shergill> anyway i need sleep. if anyone has any insights, feel free to pm me
00:04:20 <geekosaur> wired-in means it can't be shadowed, I think
00:27:58 * hackagebot HGamer3D-Data 0.1.5 - Library to enable 3D game development for Haskell - Data  http://hackage.haskell.org/package/HGamer3D-Data-0.1.5 (PeterAlthainz)
00:32:58 * hackagebot HGamer3D-Ogre-Binding 0.1.5 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.5 (PeterAlthainz)
00:33:00 * hackagebot HGamer3D-OIS-Binding 0.1.5 - Library to enable 3D game development for Haskell - OIS Bindings  http://hackage.haskell.org/package/HGamer3D-OIS-Binding-0.1.5 (PeterAlthainz)
00:38:02 * hackagebot HGamer3D-API 0.1.5 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-API-0.1.5 (PeterAlthainz)
00:38:04 * hackagebot HGamer3D-CAudio-Binding 0.1.5 - Library to enable 3D game development for Haskell - cAudio Bindings  http://hackage.haskell.org/package/HGamer3D-CAudio-Binding-0.1.5 (PeterAlthainz)
00:53:04 <asdfasdf> pl (\x= x+1)
00:53:16 <asdfasdf> pl \x -> x+1
00:53:24 <Elemir> @plt \x -> x + 1
00:53:25 <lambdabot> (1 +)
00:53:53 <asdfasdf> pl \x -> x+2
00:54:03 <rgr> using the hs interpeter, would it be normal or even "ok" to somehow remove the need to use "let" when assigning variables (total noob here btw)
00:54:28 <shachaf> rgr: There's some ambiguity from doing it, I think.
00:54:36 <shachaf> rgr: It's just for ghci, anyway.
00:54:54 <rgr> as opposed to? (using it from inside emacs using haskell-mode btw)
00:58:02 <rgr> Whats the standard way to see if an element is contained in a list?
01:00:17 <geekosaur> :t elem
01:00:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:01:15 <rgr> thanks. was looking here : http://www.haskell.org/haskellwiki/How_to_work_on_lists#Testing_various_conditions
01:03:40 <rgr> as I said, just getting started and having trouble navigating the help - but to quick start, whats the syntax/method for "not" in this example - or would I even do it that way? e.g if x is NOT an element of that list : [ x | x <- [10..20], ! x `elem` [13,15,19]]
01:03:55 <rgr> (obviously the ! is wrong here)
01:04:26 <shachaf> "not"
01:04:36 <rgr> lol. thanks.
01:04:38 <shachaf> Alternatively, in this case, use `notElem`
01:04:49 <shachaf> Mind your parentheses.
01:05:06 <rgr> I need to load something for notElem?
01:05:12 <shachaf> Maybe?
01:05:35 <rgr> oh sorry, no I dont. I left the "!" in. thanks.
01:05:38 <Axman6> not (x `elem` [12,13,14])
01:06:11 <shachaf> rgr: My usual recommendation would be just to not use list comprehensions while you're still learning the basic syntax.
01:06:11 <rgr> what would be favoured or are they the same? not(blah) or notElem?
01:06:29 <shachaf> It's not "not(blah)", it's "not blah".
01:06:36 <Axman6> they're the same
01:06:44 <rgr> list comprehensions are easy enough and I'm just using them generate data to understand the syntax. learnyouahaskell brings them in pretty early.
01:06:51 <rgr> thanks guys.
01:06:53 <shachaf> Sigh, LYAH.
01:06:54 <Axman6> @src notElem
01:06:54 <lambdabot> notElem x =  all (/= x)
01:07:00 <Axman6> huh
01:07:13 <Axman6> ok, thats more efficient
01:07:25 <shachaf> Axman6: It is?
01:09:22 <Axman6> maybe not
01:22:12 <vodik> @src elem
01:22:12 <lambdabot> elem x    =  any (== x)
01:23:20 <vodik> which one is more efficient depends on which is more likely, a match is found or a match isn't found
01:23:33 <vodik> err
01:23:53 <shachaf> vodik: Why?
01:24:55 <vodik> shachaf: because you have to search first if 12 is in the list, then 13, then 14
01:25:20 <vodik> while if you used notElem, the first element that isn't right, it can stop checking
01:25:23 <shachaf> What?
01:25:24 <vodik> any vs all
01:25:51 <shachaf> Look at it again.
01:25:55 <vodik> okay
01:27:04 <vodik> right, first false with all renders it false
01:27:09 <vodik> first true with any renders it true
01:32:29 <mysticc> @src map
01:32:30 <lambdabot> map _ []     = []
01:32:30 <lambdabot> map f (x:xs) = f x : map f xs
01:32:42 <mysticc> @src foldl
01:32:42 <lambdabot> foldl f z []     = z
01:32:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:32:50 <mysticc> @src intercalate
01:32:51 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
01:33:01 <mysticc> @src intersperse
01:33:01 <lambdabot> intersperse _   []     = []
01:33:01 <lambdabot> intersperse _   [x]    = [x]
01:33:01 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
01:33:12 <mysticc> @src sort
01:33:12 <lambdabot> sort = sortBy compare
01:33:17 <mysticc> @src sortBy
01:33:18 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
01:35:02 <Phlogistique> ...seriously?
01:35:39 <Phlogistique> @src insertBy
01:35:39 <lambdabot> insertBy _   x [] = [x]
01:35:39 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
01:35:39 <lambdabot>                                  GT -> y : insertBy cmp x ys'
01:35:39 <lambdabot>                                  _  -> x : ys
01:35:50 <mysticc> Not a haskell question , but which irc client do u use ?
01:35:58 <Phlogistique> mysticc: irssi
01:38:00 * hackagebot toolshed 0.13.0.0 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.13.0.0 (AlistairWard)
01:39:07 <vodik> mysticc: weechat
01:39:15 <Axman6> irssi here too
01:39:31 <vodik> mysticc: use what you like best, try some out
01:41:35 <bitonic> Phlogistique, mysticc: lambdabot @src are just examples
01:43:00 * hackagebot regexdot 0.11.0.0 - A polymorphic, POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexdot-0.11.0.0 (AlistairWard)
01:43:02 * hackagebot regexchar 0.9.0.9 - A POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexchar-0.9.0.9 (AlistairWard)
01:48:04 * hackagebot factory 0.2.0.2 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.2 (AlistairWard)
01:48:06 * hackagebot squeeze 1.0.2.2 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.2.2 (AlistairWard)
01:59:38 <rgr> in list comprehensions are the conditions evaluated left to right in typical "lazy" order ie last arent evaluated if first fails.
02:00:10 <rgr> so here it would be better to do the addition ==24 check first, right? let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2,a+b+c==24]
02:02:32 <shachaf> What does that mean?
02:02:45 <Rmx> every application compiled with ghc using opengl result in "Segmentation fault/access violation in generated code"
02:02:57 <Rmx> anyone experienced this before.
02:03:00 <Rmx> ?*
02:03:00 <lambdabot> Maybe you meant: . ? @ v
02:03:03 <rgr> Im not sure I could explain it any other way. the conditions, are they evaluated left to right.
02:03:39 <rgr> e.g the ^2 checks before the a+b+x check?
02:03:58 <rgr> ie guarenteed that way.
02:04:13 <shachaf> Oh, I misread.
02:04:20 <rgr> some languages abort when the first "and" condition fails but the conditions can and do update other vars.
02:04:34 <shachaf> I don't know whether it would be "better".
02:04:48 <shachaf> But it would be checked in the order you described.
02:05:03 <shachaf> There is no "updating vars" going on anywhere.
02:05:13 <rgr> you must remember Im trying to get a feel for how to "think" in Haskell since its clearly more than syntactic irregularity ;)
02:05:15 <shachaf> I think using list comprehensions will just confuse you. :-)
02:05:42 <rgr> so you said before, but Im not sure why. Its not a list comprehension issue.
02:06:00 <shachaf> Try writing the same thing without a list comprehension.
02:06:22 <rgr> Im happy with list comprehensions, the Q was about how haskell works. Thanks anyway.
02:08:01 * hackagebot sundown 0.4.1.2 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.4.1.2 (FrancescoMazzoli)
02:23:01 * hackagebot xchat-plugin 0.0.3 - XChat  http://hackage.haskell.org/package/xchat-plugin-0.0.3 (CedricAuger)
02:28:02 * hackagebot JuicyPixels 1.2.1 - Picture loading/serialization (in png, jpeg and bitmap)  http://hackage.haskell.org/package/JuicyPixels-1.2.1 (VincentBerthoux)
02:35:12 <execat> xmonad.hs:143:36: Not in scope: `xmproc' on http://paste.pocoo.org/show/581742/
02:35:17 <execat> What is that supposed to mean/
02:35:33 <execat> XMonad is my first experience with Haskell, BTW.
02:36:07 <timthelion> One comes to a point in a C function, where there is some bug that causes random buffer over-writes, and you're not quite sure if you've reused that flag in the wrong place.  And there comes a point in a haskell program, where your data's and IO's are written, and you add 3 new features in one morning without introducing a bug :)
02:36:27 <timthelion> execat: looking...
02:37:23 <timthelion> execat: it means that the value xmproc doesn't exist...
02:37:40 <execat> timthelion, geez. What do I do now? :-|
02:38:11 <timthelion> execat: I presume you copy and pasted from somewhere?
02:38:31 <execat> timthelion, multiple sources. They were working almost fine individually.
02:39:12 <timthelion> you need something like     xmproc <- spawnPipe "xmobar /home/kivutar/.xmonad/xmobarrc" somewhere according to google
02:39:22 <vodik> execat: you need to pass xmproc into that function
02:39:35 <wli> timthelion: Sadly I'm getting plenty of nasty surprises in Haskell.
02:39:39 <vodik> xmonad (defaults xmproc)
02:39:46 <timthelion> ah, wli is right
02:39:54 <timthelion> you already have the xmproc defined in main
02:40:03 <vodik> execat: 151: xmonad (defaults xmproc)
02:40:16 <vodik> execat: 153: defaults xmproc = defaultConfig {
02:40:19 <wli> PID     COMMAND            STATE      %CPU        CSW         RSIZE    RPRVT
02:40:19 <wli> 6671    ghc                sleeping   1.1         152294+     3699M+   3836M+
02:40:32 <vodik> execat: 173: startupHook = myStartupHook xmproc
02:40:54 <vodik> execat: 142: myStartupHook xmproc = dynamicLogWithPP xmobarPP
02:40:59 <vodik> execat: FIN
02:41:54 <execat> vodik, I have no idea how you did that. But it compiled :o
02:42:19 <vodik> execat: xmproc is a variable
02:42:23 <execat> Are we just adding xmproc as a parameter to the functions?
02:42:23 <vodik> you have to pass that around
02:42:30 <vodik> it isn't some magic gloabl
02:42:36 <vodik> there are no gobals in haskell
02:42:40 <vodik> yes
02:42:52 <timthelion> vodik: functions are global :)
02:43:08 <vodik> well, an technically you can have globals too
02:43:13 <vodik> with the right extension
02:43:26 <timthelion> vodik: that sounds like a terrible sin
02:43:32 <vodik> kinda is
02:44:24 <vodik> execat: 150: xmproc <- spawnPipe "xmobar /home/atm/.xmobarrc"
02:44:31 <vodik> there really is no need for full paths
02:44:51 <execat> vodik, you mean '~ or
02:44:55 <execat> ?
02:45:05 <vodik> well you could do that too
02:45:10 <vodik> i mean the /usr/bin part
02:45:39 <execat> Right. So it searches the PATH for executables?
02:45:43 <vodik> yes
02:46:26 <execat> I could put .xmobarrc in my ~/.bin (which is in my path) and then cut out the need for specifying the path?
02:46:47 <vodik> execat: btw, there's a #xmonad channel
02:47:07 <execat> vodik, I was there yesterday. No one replied. Maybe my question was too noobish.
02:47:17 <vodik> execat: no, you just didn't wait long enough
02:47:18 <execat> I played around more and did stuff by myself.
02:47:28 <execat> vodik, no. I was there for like 6+ hrs :P
02:47:28 <vodik> its a very good channel
02:47:50 <vodik> execat: bad timing then, im usually there
02:48:02 * hackagebot profunctors 0.1.2.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.2.1 (EdwardKmett)
02:48:04 * hackagebot trifecta 0.50.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.50.1 (EdwardKmett)
02:48:06 * hackagebot profunctor-extras 0.3.2.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.2.1 (EdwardKmett)
02:48:07 * vodik shrugs
02:48:08 * hackagebot representable-profunctors 0.4.2.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.2.1 (EdwardKmett)
02:48:57 <execat> vodik, thanks for the help. I'll restart (I am in Xfce4) and let you know how it went :)
02:49:13 * edwardk cheerfully spams the channel
02:57:13 <wli> I'm just taking a stab at utilities for my own use.
02:57:58 <wli> Partly as a sort of refresher as to what's been going on with Haskell for the past 6-8 years. Maybe even longer.
02:58:02 * hackagebot algebra 2.1.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.1.1 (EdwardKmett)
02:58:43 <wli> It'd be nice if it got to where I could use it, if not, the attempt probably refreshes me a bit on Haskell.
03:00:45 <edwardk> wli: i mostly start projects and then write libraries that would be useful in the writing of those projects. ;) i usually don't finish the main project until the second iteration as a result, because by then iterative deepening has let me work on the problem i originally wanted to
03:01:28 <hpaste_> wli pasted “fetch, unzip, and parse GTFS feeds” at http://hpaste.org/67021
03:03:54 <wli> edwardk: I'm not very concerned about this going anywhere. There's a real-life problem behind it, but I'm not seriously taking it on, just using it as some way to get ideas of what to try to do in Haskell.
03:06:10 <hiptobecubic> everytime someone talks about wanting a haskell project, i always suggest adding uninstall to cabal :)
03:07:06 <wli> I seem to have hit a number of different libraries trying to fetch the data.
03:07:41 <wli> I guess I can randomly stuff it into a database to pick up one of those libs.
03:10:18 <hpaste_> aib pasted “(.)” at http://hpaste.org/67022
03:10:34 <aib> how can I compose these two functions together? http://hpaste.org/67022
03:13:15 <aib> @pl (\x y z -> toWeekDate $ fromGregorian x y z)
03:13:16 <lambdabot> ((toWeekDate .) .) . fromGregorian
03:13:28 <aib> eugh
03:13:49 <aib> is this latter form supposed to be readable?
03:13:53 <geekosaur> no
03:14:01 <aib> so use the lambda then?
03:14:02 <geekosaur> we often call @pl the obfuscator
03:14:07 <aib> ahahaha
03:14:39 <hayashi> @pl (\f g x y z -> f $ g x y z)
03:14:39 <lambdabot> (.) . (.) . (.)
03:14:49 <hackkitten_> why this does not exclude 40 ?    [x*y |  x <- [2,5,7], y <- [8,10,12], x /= 40 ]
03:14:55 <hayashi> yay, it's our friend the extended Martian prostitute combinator
03:15:05 <hayashi> @lambdabot
03:15:06 <lambdabot> Unknown command, try @list
03:15:06 <aib> hackkitten_: x is never 40.
03:15:21 <aib> hayashi: lol
03:15:27 <geekosaur> perhaps you meant x*y /= 40?
03:15:40 <hackkitten_> oh yea, sorry ;)
03:15:43 <aib> I'm kinda annoyed that "lol" now means "mildly amusing statement, I'm an idiot". I actually laughed out loud there!
03:18:04 * wli picks HaskellDB
03:18:55 <hayashi> if this doesn't produce a massive row of boobs, then I'm disappoint
03:19:08 <hayashi> @pl (\f g a b c d e f g h i j -> f $ g a b c d e f g h i j)
03:19:12 <lambdabot> const (const ((((((const . const . ap ((.) . (.))) .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . flip
03:19:12 <lambdabot> flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((flip .) .) .) . ((flip .) .) . (flip .) . flip . flip id))
03:19:12 <lambdabot> optimization suspended, use @pl-resume to continue.
03:19:20 <hayashi> I'm disappoint
03:20:53 <hayashi> oh you silly hayashi, you used f and g twice
03:21:02 <bogwonch> .ª¬
03:21:09 <Cale> @pl (\スモクチーズ -> スモクチーズ)
03:21:09 <lambdabot> (line 1, column 4):
03:21:09 <lambdabot> unexpected "\130"
03:21:09 <lambdabot> expecting letter or digit, operator, pattern or "->"
03:21:16 <Cale> にょろん～
03:21:50 <hayashi> no smoked cheese for you
03:22:22 <hayashi> @pl (\x y a b c d e f g h i j -> x $ y a b c d e f g h i j)
03:22:23 <lambdabot> (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
03:22:40 <hayashi> That's better~
03:25:03 <hackkitten_> what predicate ot use if I woud like to filter out every third output of  [x*y |  x <- [2,5,7], y <- [8,10,12] ]
03:26:37 <Cale> hackkitten_: I guess you could use a parallel list comprehension, but it's probably just easier to nest, and zip the thing with a list of indices
03:27:10 <Cale> > [n | (k,n) <- zip [0..] [x*y |  x <- [2,5,7], y <- [8,10,12] ], k `mod` 3 == 0]
03:27:11 <lambdabot>   [16,40,56]
03:27:36 <Cale> then again, in this specific case, y == 8 would work :P
03:28:13 <Blue-Jeans_> Hello everybody
03:29:29 <Cale> hello Blue-Jeans
03:29:32 <Blue-Jeans_> I'm newbie and I have a small question. Can sombody answer it?
03:29:35 <Cale> sure
03:29:53 <Blue-Jeans_> I'd like to define type for a playing cards
03:29:57 <Cale> okay
03:30:16 <Blue-Jeans_> with a Suit type is ok: data Suit = Spade | Heart | Diamond | Club deriving (Eq, Show)
03:30:22 <Cale> right
03:30:41 <Blue-Jeans_> but is seens its is not possible to define Rank type as an enumeration like this:
03:30:52 <Blue-Jeans_> data Rank = 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | Jack | Queen | King | Ace deriving (Eq, Show)
03:31:05 <ktosiek> Blue-Jeans_: that would redefine 2
03:31:06 <DrSyzygy> Blue-Jeans_: Well, the digits are already occupied, right?
03:31:11 <ktosiek> and you don't want that :-)
03:31:15 <wli> derive Bounded and Enum also
03:31:20 <Blue-Jeans_> is it not possible because ot the mix of nubers and enums
03:31:30 <Cale> Blue-Jeans_: yeah, you can add R (or some other capital letter) to the start of those numbers if you want
03:31:40 <DrSyzygy> Try: data Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | Jack | Queen | King | Ace deriving (Eq, Show, Bounded, Enum)
03:31:45 <Cale> Blue-Jeans_: in order to keep them separate from actual numbers
03:32:01 <Blue-Jeans_> he-he ... that what I did : data Rank = R2 | R3 |  ...
03:33:01 <Cale> Blue-Jeans_: another option is to be looser about your type discipline and just use Integer to represent Ranks (this would allow invalid ranks, but might be more convenient to work with in some cases depending on the card game you're implementing)
03:33:02 <Blue-Jeans_> with Bounded and Enum I'm not quit sure, because Ace can play a  "1"  as well
03:33:05 * hackagebot soxlib 0.0 - Write, read, convert audio signals using libsox  http://hackage.haskell.org/package/soxlib-0.0 (HenningThielemann)
03:33:07 * hackagebot split-record 0.1 - Split a big audio file into pieces at positions of silence  http://hackage.haskell.org/package/split-record-0.1 (HenningThielemann)
03:33:14 <Cale> Though Enum also serves that purpose well enough
03:33:39 <Cale> Blue-Jeans_: yeah, you may want to put Ace at the other end, depending on the order you want
03:33:51 <Blue-Jeans_> Cale: yep, it may be the option
03:34:28 <wli> Blue-Jeans_: Two copies of the type, one with aces high, the other with aces low, distinguish with a prefix.
03:35:47 <niez> hi, I'm reading 'Learn You a Haskell for Great Good', I see that : is a value constructor for lists and it can be used in pattern matching, I see also that , can be used for mattern match a tuple, is , a value constructor for tuple? am I right?
03:36:27 <ktosiek> :t (,)
03:36:28 <lambdabot> forall a b. a -> b -> (a, b)
03:36:29 <Cale> niez: The [a,b,c] style of list syntax is just syntactic sugar for a chain of :'s
03:36:30 <Blue-Jeans_> Thx a lot guys!
03:36:45 <Cale> niez: [a,b,c] means literally a:(b:(c:[]))
03:37:15 <Cale> (and the compiler makes that translation early on in compiling the program)
03:38:05 <niez> yes, but how about tuples? thanks ktosiek, I see that , is a function that takes 2 parameters and returns a tuple
03:38:06 * hackagebot alsa-seq 0.6 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6 (HenningThielemann)
03:38:33 <aib> @pl (\x y -> x >>= (return . y))
03:38:33 <lambdabot> (. (return .)) . (>>=)
03:38:56 <Cale> niez: , itself isn't
03:39:02 <Cale> But (,) is
03:39:14 <Cale> (the parens are not optional)
03:39:19 <niez> i see
03:39:26 <Cale> You can't write x,y on its own, but you can write (x,y)
03:39:34 <Cale> and (,) x y
03:39:40 <ktosiek> yup, the parens mean "treat this operator as a function"
03:39:45 <Cale> normally
03:39:47 <niez> so (,,) would be a value constructor for three-element tuple
03:39:47 <wli> I wonder if LYAH has any new material since last I checked.
03:39:58 <Cale> but in this case, the comma is not an operator symbol
03:40:06 <ktosiek> and special syntax for touples is (a, b, c, ..)
03:40:13 <Cale> niez: yes
03:40:26 <Cale> > (,,) 1 2 3
03:40:27 <lambdabot>   (1,2,3)
03:40:28 <ktosiek> Cale: oh, thanks, I was sure it was
03:41:10 <Cale> commas appear in too many other places in the Haskell syntax to let them be proper operators
03:41:17 <niez> they are all predefined or the compiler makes them on the fly? If I want to make very long tuple...?
03:41:27 <ktosiek> niez: the compiler makes them
03:41:39 <ktosiek> but you won't want long tuples :-)
03:42:08 <Cale> niez: They're special syntax, and the compiler makes them, and is required by the standard to have instances of some typeclasses for them up to certain sizes
03:42:15 <Cale> (I think it was 16 or so)
03:42:32 <Cale> I think GHC has instances up to 63 or 64-tuples or something
03:43:00 <Cale> But in practice, you should never need a tuple that large
03:43:06 <ktosiek> where would you need a touple much longer than 4?
03:43:06 * hackagebot midi 0.2 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2 (HenningThielemann)
03:43:16 <Cale> In fact, larger than 2 is iffy.
03:43:33 <Cale> You should seriously consider defining a proper datatype if you're using anything larger than a pair
03:44:03 <niez> I see, I don't need them to be that large, I've just been interested on 'how this is implemented'
03:44:11 <niez> many thanks, it's clear now
03:47:13 <Cale> ktosiek: as for where you'd need larger tuples, I think some people writing tools which generate Haskell code can find it useful in some cases to be able to make use of longer tuples in the generated code rather than needing to generate data declarations.
03:47:30 <Cale> But I don't know of any specific case.
03:48:07 * hackagebot midi-alsa 0.2 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.2 (HenningThielemann)
03:49:07 <niez> Is there a way to make classical double-linked list or similar data structure?
03:49:43 <ktosiek> niez: double-linked lists are problematic in Haskell
03:49:45 <shachaf> Immutable doubly-linked lists are kind of tricky because you can't do much with them.
03:50:04 <ktosiek> you can't change them without a full copy
03:50:10 <shachaf> Right.
03:51:28 <ktosiek> and there's the problem of tying the knot on (recursive? self-refering?) data structures
03:51:55 <niez> and the compiler doesn't optimise that? as far I can see, anything must be copied in order to get new value in haskell
03:52:11 <niez> when data structures are involved
03:52:42 <shachaf> niez: *Something* must be copied.
03:53:07 <ktosiek> niez: it's _really_ hard for non-obvious cases to optimize out this copying
03:53:26 <shachaf> But if you have the singly-linked list 'a':'b':'c':[] -- call it 'a':xs -- and you make 'b':xs, they can share the xs.
03:53:26 <ktosiek> and I don't know if GHC would do much even for the simplest ones
03:53:48 <shachaf> In the doubly-linked list they can't, because the 'b' points back to the 'a' as well as forward to the 'c'.
03:54:07 <wli> Fortran pointers.
03:55:06 <ktosiek> wli: and what are they?
03:55:13 * ktosiek has never seen fortran
03:55:20 <niez> shachaf, I think, that this example is just list, not linked, values are embedded in a container
03:55:28 <wli> ktosiek: Array indices used in lieu of genuine pointers.
03:55:38 <shachaf> niez: ?
03:55:57 <niez> 'a' doesn't point on 'b'
03:56:13 <niez> am I wrong?
03:56:41 <shachaf> (:) points to 'a' and it also points to (:) 'b' ((:) 'c' [])
03:56:52 <geekosaur> niez, Haskell lists are linked lists (cons cells, like in Lisp)
03:57:34 <niez> so the cons hold the value and points on next value, right?
03:59:02 <aib> is there a function MAP f x n = take n [x, f x, f f x, f f f x, ...] ? I'm only asking because it looks lambda-calculus-y
03:59:43 <ktosiek> niez: more or less, IIRC they hold a pointer to value and a pointer to rest of the list
04:00:04 <Peaker> aib: iterate f x generates [x, f x, f (f x), f (f (f x)), ...]
04:00:12 <aib> iterate. thanks!
04:00:19 <Peaker> aib: take n    on that was not given a name
04:00:54 <vhd> how can I be sure my function is being evaluated in a lazy fashion?
04:01:37 <Peaker> vhd: why?
04:01:49 <niez> so lists and tuples are simple and fun in haskell, what about complex data structures like graphs, linked custom data?
04:01:53 <Peaker> vhd: you could try adding Debug.Trace in your program to get a glimpse of evaluation order
04:02:37 <vhd> Peaker, my function calls other functions and uses `++` from the lists that the other functions produce
04:02:48 <vhd> I assume that it would still be lazy
04:02:48 <sipa> niez: typically, all data structures you write yourself are lazy, and are only evaluated when pattern mathced upon
04:03:54 <Peaker> vhd: yes, it generally will be, unless ghc's strictness analyzer decided that your function is strict anyway, in which case it will try to convert it to use eager evaluation which has less overhead
04:04:14 <sipa> built-in types like integers are different, these are evaluated when arithmetic operators are applied
04:04:27 <niez> I have an object/graph database written in c++ and I'm interested in porting it to haskell or make some bindings, I have for example a list and a dictionary so I can find an object by id or index, I can't figure out how can I make this in haskell
04:04:47 <vhd> Peaker, under what conditions may the ghc compiler decide it is strict?
04:07:06 <Peaker> vhd: f is strict if   x=_|_   implies f x = _|_ too
04:07:48 <Peaker> vhd: so if ghc can infer that f has no useful output when its argument is bottom, it may eagerly evaluate its argument before the function
04:08:21 <aib> @pl -> (\y x -> take y . iterate x)
04:08:21 <lambdabot> (line 1, column 1):
04:08:21 <lambdabot> unexpected "-"
04:08:21 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:08:24 <aib> @pl (\y x -> take y . iterate x)
04:08:24 <lambdabot> (. iterate) . (.) . take
04:08:27 <aib> bah
04:08:49 <Peaker> vhd: the terminology is often mixed up, which confused me for a long time.    "lazy/eager" are evaluation strategies.  "strict/non-strict" are about the semantics of the function
04:09:05 <shachaf> Peaker: "eager" is an evaluation strategy?
04:09:18 <shachaf> Ah, hmm.
04:09:24 <shachaf> I guess so.
04:09:37 <Peaker> yeah, eager/strictness are related and often mixed up
04:09:42 <shachaf> There exist more evaluation strategies than "lazy" and "eager", though.
04:09:51 <vhd> Peaker, I understand, thanks for the explanation. I was wondering on how ghc decides what will be needed or not, but I saw the haskell wiki and seems like it may not be perfect.
04:09:53 <Peaker> yeah, just talking about the laziness context
04:10:14 <Peaker> vhd: I think a perfect strictness analyzer in a turing complete language would solve the halting problem
04:10:24 <Peaker> but I think it doesn't have false positives, only false negatives
04:10:29 <vhd> I see
04:10:57 <shachaf> Keep in mind that (const undefined) is strict function.
04:11:05 <shachaf> But operationally it doesn't force its argument.
04:28:35 <aib> @pl (\x -> not . (any x))
04:28:36 <lambdabot> (not .) . any
04:30:26 <nart> what are the stToIO case of uses ?
04:32:35 <gdeest> @pl (\x -> (x > 4) || (x <= 0))
04:32:35 <lambdabot> liftM2 (||) (> 4) (<= 0)
04:32:43 <gdeest> Fascinating
04:43:52 <aib> hmm, http://hpaste.org/67030 isn't compiling in GHC while it looks like it should
04:44:33 <arossouw> do you have to unpack bytestrings to extract parts of it from textfile?
04:45:30 <aib> also, it looks unreadable to me. is it? can I make it more readable if it's not perfect as such?
04:48:25 <fmap> and the error message is..?
04:50:18 <fmap> aib: all is bad name for binding
04:50:57 <aib> sorry, http://hpaste.org/67031
04:51:37 <aib> fmap: hmm, it's supposed to be Prelude.all
04:52:44 <aib> and there's a minor whitespace issue, fixed now
04:53:04 <aib> oh
04:53:13 <aib> oh oh oh. I have a binding called "all"
04:53:27 <aib> /headdesk
04:53:35 <Botje> arossouw: bytestrings support take, drop, split, etc ..
04:53:52 <Botje> arossouw: depends on what you're after
04:54:43 <aib> and any comments about the readability? looks absolutely horrible to me, but I'm new to Haskell
04:55:32 <Botje> aib: that \(x,y) -> ... after all can be written using Data.Ix.inRange
05:00:25 <hpaste_> aib pasted “lines2D v1” at http://hpaste.org/67032
05:03:37 <fmap> aib: did you really need filterting with constraints on startPoints generators?
05:04:58 <aib> well if I was only going right, down and right-down, it would've sufficed to constrain the starting points to an upper-left subsquare
05:05:58 <aib> but there's that reverse diagonal with y-1 which forces me to use the full y range for starting points
05:06:59 <arossouw> Botje: ok
05:07:23 <aib> and at that point I said I might as well use the full x and y ranges for symmetry
05:08:24 <foobar__> Hi all. I'm trying to merge two functions into a single type-class operation but somehow get the feeling that I'm running in circles.. (#) :: Object a -> (a -> c) -> c and (#2) :: a -> (a -> c) -> c . Is this possible at all?
05:08:25 <aib> I actually could've restricted the x range to [0..width-len+1] and done away with the bounds checking on the x direction
05:08:36 <aib> in* in the x direction*
05:11:20 <aib> does that make sense?
05:12:49 <Yrogirg> hi! module links in http://hackage.haskell.org/package/factory-0.2.0.2 are unclickable, so I can't access the docs. Is that because it was uploaded today and i shall wait?
05:14:02 <dschoepe> Yrogirg: Either wait, or build the documentation locally (cabal unpack factory && cd factory-0.2.0.2 && cabal haddock should suffice).
05:14:35 <dschoepe> You can also instruct cabal-install to build and install the documentation for each package you install with it.
05:18:16 <Yrogirg> btw, what are the packages for multivariate polynomials?
05:28:04 <aib> fmap: sorry, forgot to "ping" you earlier in my response. or if you were ignoring, that's fine, too. we're all busy in some way or another.
05:29:20 <teneen> Why does GHC not check the contexts in an instance, and considers any two instances with the same head the same?
05:30:10 <hpaste_> timthelion pasted “how might I simplify this?” at http://hpaste.org/67033
05:32:53 <ktosiek> Can I get (a -> b) from (a -> IO b) without unsafe* ?
05:33:13 <timthelion> Hello, how might I simplify update, so that I can make an update 4, 5,6,7,8 ect reasonably? http://hpaste.org/67033
05:34:58 <teneen> Is it possible to define a datatype like this: data Foo m a = Foo (Monad m => a -> m a)?
05:35:28 <teneen> ktosiek: no!
05:36:16 <ktosiek> teneen: that's sad :-C I wanted to make some simple mnemoization with limited number of remembered results
05:36:29 <ktosiek> But I don't trust myself with unsafe* ;-)
05:37:26 <teneen> ktosiek: there are several pure ways to do memoization
05:37:27 <Axman6> teneen: yes, but you shouldn't. put the constraints on the functions you're using, not the type itself
05:37:55 <Axman6> ktosiek: is this a -> IO b function pure?
05:38:09 <Axman6> (does its results only depend on its inputs)
05:38:18 <ktosiek> Axman6: yes
05:38:35 <dibblego> by yes you mean no right?
05:38:53 <timthelion> Axman6: nope
05:38:58 <teneen> Axman6: but the constraint I'm putting is on the right hand side not on the left. It's not the same as datatype contexts? is it?
05:38:59 <ktosiek> I mean "yes, b only depends on a (on the outside)"
05:39:08 <dibblego> ktosiek: then why is it in IO?
05:39:20 <dibblego> teneen: put the constraint on operations, not the data type
05:39:28 <ktosiek> to have a mutable cache of results
05:39:44 <ktosiek> and mutable, not lazy, because I want to limit the number of results I remember
05:40:18 <dibblego> yes, but you don't want your function in IO because of this
05:40:21 <dibblego> you want your cache in ST
05:40:25 <dibblego> and your function in nothing at all
05:40:29 <timthelion> ktosiek: why not trust GHC, ghc is supposed to be rather smart about that :)
05:40:44 <dibblego> @google simon peyton jones weak pointers
05:40:46 <lambdabot> http://research.microsoft.com/~simonpj/papers/weak.htm
05:40:47 <lambdabot> Title: Simon Peyton Jones: papers
05:43:07 <ktosiek> dibblego: but cache in ST would disappear when I get out of ST?
05:43:13 <ktosiek> or not?
05:43:23 <Axman6> timthelion: what makes you say that? ghc doesn't do memoisation by default
05:43:33 <Axman6> well, at all, unless you tell it to
05:43:42 <dibblego> ktosiek: I recommend the above paper if you truly want to memo, although chances are you probably don't
05:43:50 <dibblego> I believe this is a library on hackage already
05:43:55 <ktosiek> ok
05:44:06 <ktosiek> I'll look for the libraries
05:44:08 <ktosiek> gotta go now
05:44:15 <hpc> memoization and "remembering what values thunks have" are different things, btw
05:44:30 <timthelion> Axman6: really?  I thought that was "one of the advantages of purely functional programming" what memoisation can be handled automatically with no risk
05:44:33 <hpc> ghc does the latter, and memoization is more or less tricks that put those thunks in the global scope
05:44:47 <hpc> timthelion: there's risk because you don't know how much memory the memoization will take up
05:44:56 <timthelion> s/what/that/
05:45:00 <Axman6> timthelion: it can, but it's more often than not more costly than just running the function again
05:45:12 <hpc> also that
05:45:25 <timthelion> Axman6: depends on the function...
05:45:37 <hpc> timthelion: and that's something the compiler can't figure out on its own
05:45:57 <hpc> computing how long it takes to run a function is halting problem stuff
05:46:17 <hpc> or a whole lot of get-the-time-at-the-start, subtract-from-time-at-the-end overhead
05:46:20 <timthelion> Then why doesn't haskell have a "memory" flag, for functions like one which creates a lazy list of prime numbers, or searches a tree...?
05:46:51 <hpc> timthelion: the rules are simple
05:46:55 <hpc> 1. evaluation of thunks
05:47:05 <hpc> 2. if a thunk leaves scope, it gets garbage collected
05:47:10 <dibblego> timthelion: memoisation is not an improvement; it's a space for time trade
05:47:21 <hpc> so memoization is what you do by hand, to keep thunks in scope
05:47:23 <hpc> more or less
05:47:42 <hpc> either through top-level CAFs, closures, whatever
05:48:29 <timthelion> hpc: OK, that seems reasonable...
05:48:37 <aib> http://hpaste.org/67034 - here at line 8, how can I use pattern matching so "n" looks more like my node declaration at line 1?
05:48:41 <hpc> so for instance
05:49:01 <fmap> aib: actually i think my initial guess is wrong, for example you need start points for very bottom horizontal lines which implies x should be from 1 to N. Same (but for vertical lines) for y.
05:49:05 <hpc> fibs = pick your infinite representation here -- at the top level, this thunk of "all the fibs" never leaves scope
05:49:30 <hpc> fib n = calculate the nth fib -- all the calculation leaves scope every time, not memoized
05:50:24 <hpc> fib = let fibs = ... in \n -> (fibs !! n) -- fib closes over fibs, THEN returns a function - for all values of n you pass, fibs is still the same fibs and it's memoized
05:51:12 <dibblego> > let fibs = 0:1:zipWith (+) <*> tail $ fibs in take 10 fibs -- "memoisation"
05:51:13 <lambdabot>   Couldn't match expected type `[t]'
05:51:13 <lambdabot>         against inferred type `[a] -> [a...
05:51:17 <dibblego> oh boo
05:51:23 <aib> fmap: hmm, you're right. the starting points can't be constrained at all. (also consider the trivial case where line length = 1, you need _all_ the elements)
05:51:28 <dibblego> > let fibs = 0:1:(zipWith (+) <*> tail $ fibs) in take 10 fibs -- "memoisation"
05:51:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:53:19 <ClaudiusMaximus> hm, what happens in this scenario:  cd foo-0.1 && cabal install && cd .. ; cd bar-0.1 && cabal install && cd .. ; ghc-pkg unregister bar-0.1 ; ghc-pkg unregister foo-0.1 ; cd foo-0.1 && modify-src-without-bumping-version && cabal install && cd .. ; cd bar-0.1 && cabal install
05:54:14 <ClaudiusMaximus> i seem to notice bar-0.1 not being recompiled even when foo-0.1 has changed - do i have to explictly "cd bar-0.1 && cabal clean" to get sane behaviour?
05:54:45 <hpc> ClaudiusMaximus: cabal has a --reinstall flag or something like that
05:55:39 <ClaudiusMaximus> hpc: hm
05:56:01 <rgr> looking at type constraints, how do I query ghci as to what types belongs to a certain class? e.g what types are covered by the Eq typeclass?
05:56:13 <ClaudiusMaximus> rgr: :info Eq
05:56:16 <rgr> thanks
05:58:11 <ClaudiusMaximus> hpc: i think what i'm seeing (profiling results of bar-example not changing significantly after i modified foo to make it go faster) might be caused by the previous foo-0.1 having been inlined into bar-0.1 during cabal build...
05:58:49 <ClaudiusMaximus> hpc: ...and cabal configure sees that foo's version number is unchanged, or something?   (either that or i suck at making foo go faster...)
05:59:30 <hpc> ClaudiusMaximus: so, bar includes foo, and you changed foo?
06:00:09 <hpc> ClaudiusMaximus: you want to --reinstall foo, then --reinstall bar
06:00:18 <hpc> or something like that
06:03:50 <abizern> I'm going to ask a couple of beginner's questions in here.
06:03:57 <abizern> Please jump in if you have an ansnwer.
06:04:01 <Cale> abizern: sure
06:04:06 <hpaste_> “Abizer Nasir” pasted “SpeakingInTongues.hs” at http://hpaste.org/67035
06:04:36 <abizern> This was my solution file for Google Code Jam I got the correct outputs. But…
06:05:28 <abizern> I'm not sure about the functional bit. In particular - rather than passing a map (hash-table) I'm passing around the function that produces the hash-table. Is this correct?
06:05:56 <Cale> abizern: passing where?
06:06:29 <Cale> keyMap looks like an appropriately constructed Map datastructure
06:06:32 <abizern> decrypt x = fromJust $ Map.lookup x keyMap
06:06:51 <abizern> So that is the way to do it?
06:06:53 <Cale> (It's not actually a hash table -- it's internally represented using a binary balanced tree structure)
06:07:12 <Cale> Yeah, so decrypt is a function, if that's what you mean
06:07:13 <abizern> Cale: Yeah. I'm thinking of it as a Dictionary.
06:07:16 <Cale> right
06:07:21 <ivy_leafy> the "error" function is really useful; is there some way I can create a "warning" function?
06:07:36 <Cale> ivy_leafy: Debug.Trace.trace?
06:07:43 <abizern> So, am I correct that It's not calculating the structure everytime I am calling it?
06:07:52 <hpc> @quote oasis
06:07:59 <hpc> :(
06:08:08 <Cale> abizern: because keyMap is a top-level constant which isn't going out of scope
06:08:08 <ivy_leafy> Cale: ok, that's exactly what I had in mind, thanks!
06:08:19 <Cale> abizern: it'll remain computed as long as there are references to it
06:08:37 <abizern> ooh. hpaste is suggesting corrections.
06:09:16 <Cale> abizern: yeah, those are just style suggestions according to hlint
06:09:48 <abizern> Cale: Thanks for clearing that up. Learning to think functionally is a stretch after so long programming imperatively.
06:10:35 <abizern> The lack of state is a challenge.
06:11:15 <hpc> abizern: you seem to be handling it well
06:11:46 <aib> data Tree a = Node a (Tree a) (Tree a) | Empty -- can this be an instance of Functor? if so, how do I implement the fmap f Empty case?
06:12:15 <Cale> fmap f Empty = Empty
06:12:31 <aib> hmm? oh!
06:12:31 <Cale> fmap f (Node x l r) = Node (f x) (fmap f l) (fmap f r)
06:12:58 <aib> right, fmap maps a Functor into a Functor
06:13:10 <mekeor> i wanna write a function such that e.g. 'f [[True,False],[True,False]] = [[True,True],[True,False],[False,True],[False,False]]' -- that is, it returns all possible "paths". why does this implementation not work?
06:13:11 <hpaste_> mekeor pasted “all paths -- doesn't work. (but compile.) why?” at http://hpaste.org/67036
06:13:53 <abizern> Another one:
06:13:57 <hpaste_> abizern pasted “RecycledNumbers.hs” at http://hpaste.org/67037
06:14:28 <abizern> I'm sure that the `sublists` function could be written more elegantly.
06:15:12 <mekeor> abizern: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#subsequences
06:15:20 <abizern> It's supposed to rotate the digits of a number. 123 -> 231, 312
06:15:25 <mekeor> there's already "subsequences"-function in Data.List
06:15:57 <mekeor> > let rotateNumber = read . reverse . show in rotateNumber 1234
06:15:59 <lambdabot>   *Exception: Prelude.read: no parse
06:16:03 <ahihi2> mekeor: isn't that just "sequence"?
06:16:16 <mekeor> ahihi2: OH
06:16:30 <mekeor> > sequence [[True,False],[True,False]]
06:16:31 <lambdabot>   [[True,True],[True,False],[False,True],[False,False]]
06:16:38 <mekeor> ahihi2: you're righr
06:16:38 <abizern> mekeor: I actually found that by searching for the type signature, but it creates more results than I need.
06:16:39 <mekeor> t
06:18:27 <mekeor> > let rotateNumber = read . reverse . show in rotateNumber 1234 :: Integer
06:18:28 <lambdabot>   4321
06:18:33 <mekeor> abizern: :P
06:19:53 <abizern> mekeor: That reverses the number, but it doesn't make the list [4123, 3412, 2341] which I what I'm trying to make.
06:20:14 <mekeor> ah
06:20:32 <mekeor> abizern: only those three numbers??
06:21:01 <abizern> mekeor: for a 4 digit number, yes.
06:21:23 <mekeor> aaah, i got it.
06:21:30 <abizern> The problem is stated here http://code.google.com/codejam/contest/1460488/dashboard#s=p2
06:23:27 <TSC2> > (\xs -> let n = length xs in (take n . map (take n) . tails . cycle) xs) "abcde"
06:23:28 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd"]
06:24:07 <abizern> TSC2: Oh - nice one
06:24:41 <mekeor> > tails "abcde"
06:24:42 <lambdabot>   ["abcde","bcde","cde","de","e",""]
06:25:29 <mekeor> TSC2: cool.
06:25:36 <abizern> TSC2: I tried to use cycle, but I didn't know how to get subsequences of the output. Thanks.
06:26:02 <TSC2> Using "tails" with infinite lists is a lot of fun (:
06:27:06 <abizern> TSC2: Yeah - but it's going to take me some time to get my head around it. I'm still trying to parse your (excellent) example. I'm going to have to work it out on paper.
06:27:24 <abizern> Which, I hasten to say, is not a bad thing.
06:27:27 <mekeor> hehe.
06:32:04 <reinoud> @hoogle first
06:32:05 <lambdabot> Data.Monoid First :: Maybe a -> First a
06:32:05 <lambdabot> Data.Monoid newtype First a
06:32:05 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
06:32:31 <reinoud> @hoogle filter
06:32:32 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
06:32:32 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
06:32:32 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
06:33:21 * hackagebot comonad 1.1.1.4 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-1.1.1.4 (EdwardKmett)
06:33:22 * hackagebot charset 0.3.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.1 (EdwardKmett)
06:33:47 <haskkitten> how come I get parse error on input `=` on this line length' xs = sum [1 | _ <- xs] ?
06:33:54 <haskkitten> in the interactive shell
06:33:57 <kallisti> edwardk: what are some practical uses of comonads
06:34:01 <kallisti> I've never quite figured that out.
06:34:13 <Botje> haskkitten: you can't define functions like that in ghci.
06:34:19 <Botje> haskkitten: either put them in a file
06:34:24 <Botje> haskkitten: or use a let
06:34:27 <edwardk> kallisti: the trick is to look for rather completely different usecases than for monads ;)
06:34:31 <Botje> let length' xs = sum [...]
06:34:33 <kallisti> edwardk: yes I figured as much
06:34:36 <haskkitten> I see, thanks Botje
06:34:42 <reinoud> if i got [4,56,2,6,7,8,4,35,5] and i want to have a check if the list has A value is bigger than say 8 , will it then autooptimize if i do `(not . null $ filter (check) list) ?
06:34:46 <Botje> haskkitten: but you can't define functions with multiple clauses that way -- you'll need to use a file
06:34:53 <edwardk> kallisti: a good example of a comonad is for something like image filters
06:35:09 <abizern> TSC2: I just ran through it. Wow!
06:35:11 <edwardk> kallisti: a comonad has a notion of extract :: f a -> a    and extend :: (f a -> b) -> f a -> f b
06:35:11 <Botje> reinoud: it will return true at the first such value; yes.
06:35:21 <edwardk> if we let 'f' be an array and an index into that array like
06:35:32 <haskkitten> Botje: so  I cant wirte same line even with let lenght in
06:35:34 <reinoud> > not. null $ filter (>5) [1,2,3,5,6,7,8,9]
06:35:35 <lambdabot>   True
06:35:40 <edwardk> data Pointer i a = Pointer (Array i a) i
06:35:43 <kallisti> edwardk: a product type of an array -- yes that
06:35:49 <abizern> TSC2: I only wrote out 6/7 terms for each expansion, which is, I suppose, what Haskell itself does.
06:35:56 <reinoud> but can it be written smarter?
06:35:56 <haskkitten> like let length' xs = sum [1 | _ <- xs] in "ABC"
06:35:57 <edwardk> kallisti: then we can extract by grabbing the current element out,
06:36:05 <kallisti> aha
06:36:13 <edwardk> extract (Pointer arr i) = arr ! i
06:36:21 <kallisti> what about extend though?
06:36:23 <TSC2> abizern: yes, it's a nice example of laziness too
06:36:41 <kallisti> extend would have to rewrite every element, no?
06:37:13 <edwardk> kallisti: and extend is the result of having applied that function at every position in the array, and stitching together a new array from the individual answers
06:37:13 <edwardk> kallisti: so you feed the function modified pointers, trying out each position in turn.
06:37:33 <kallisti> oh
06:37:34 <kallisti> right
06:37:43 <kallisti> you don't have to call the function just once. :P
06:37:47 <niklasb> has anyone here running darcs on Arch Linux? :/
06:37:51 <kallisti> you can call it for each element, passing in the pointer
06:37:54 <edwardk> when you use a monad you can only 'see' a little piece, (the 'a') but you build a whole thing (m b). here you can see everything (w a), but only build a little piece 'b'.
06:37:56 <kallisti> the only context given is the pointer.
06:38:07 <abizern> TSC2: As I said - I thought I could use cycle to get a long list and then take bits of it, but I didn't know about tails. It's perfectly clear once you write it out.
06:38:19 <kallisti> edwardk: would the pointer be changed for each element?
06:38:27 <edwardk> now, if we get rid of the underlying array, and just allow an arbitrary function, then you get the state comonad
06:38:29 <edwardk> er store comonad
06:38:34 <edwardk> (aka costate comonad)
06:38:35 <kallisti> in other words, would the function know "which element it is"
06:38:48 <kallisti> based on the index in the pointer?
06:38:50 <edwardk> data Store s a = Store (s -> a) s
06:38:56 <kallisti> or would they all share an index?
06:38:59 <edwardk> extract (Store f s) = f s
06:39:07 <edwardk> kallisti: yeah you can see where you are
06:39:11 <kallisti> right okay
06:39:16 <edwardk> kallisti: so you can choose to do different things at the edges
06:39:19 <TSC2> abizern: I think it takes some getting used to, the idea of building an infinite list of infinite lists, and then just taking the first few elements (:
06:39:27 <kallisti> edwardk: yeah it wouldn't be very useful otherwise..
06:39:31 <edwardk> and your function is of course free to modify the position and ask for the value at that position, etc.
06:39:41 <edwardk> well, there is a version where you can't ;)
06:39:47 <edwardk> and it does have uses but its pretty obscure
06:39:57 <kallisti> that's interesting.
06:40:11 <kallisti> comonads in some sense can see more than they can change.
06:40:21 <edwardk> anyways the Store comonad works very similarly to that image pointer comonad
06:40:31 <edwardk> you have a function from positions s to answers a.
06:40:54 <abizern> TSC2: I worked through the fibonacci example and saw how you could add terms from an infinite list together, but this is even freakier.
06:41:20 <edwardk> kallisti: this is the idea that 'the dual of substitution is redecoration'. monads are fundamentally about substituting and renormalizing. (fmap and then join)
06:41:30 <mcstar> mekeor: http://sprunge.us/QEiS
06:41:34 <edwardk> comonads are about changing some kind of annotations without changing the shape
06:41:34 <kallisti> edwardk: hm, you could use a comonad to update cells of a board game.
06:41:43 <kallisti> same idea
06:41:50 <mcstar> (i know its late, but had to do it)
06:41:52 <TSC2> abizern: If you understand the fibonacci you're doing well
06:42:00 <edwardk> in fact, you'll always wind up with the same number of elements in a comonad after an extend
06:42:02 <mekeor> mcstar: that's tail-recursive. neat.
06:42:05 <edwardk> kallisti: yep
06:42:17 <edwardk> kallisti: in fact, you can model parallel play games with them quite nicely
06:42:30 <kallisti> CA would be fit perfectly as well.
06:42:32 <edwardk> kallisti: where you give each player a copy of the board and resolve their moves at the same time
06:42:39 <edwardk> CA?
06:42:42 <kallisti> cellular automata
06:42:45 <edwardk> oh yes
06:43:00 <edwardk> you can make a nice zipper list representation
06:43:20 <edwardk> and then the ceullar automaton is just evaluated by extending the function that looks at the neighboring cells
06:43:28 <kallisti> yep
06:43:29 <hpaste_> “missing something with GADT's” pasted “wli” at http://hpaste.org/67040
06:43:57 <edwardk> kallisti: there are strictly fewer things you can do with comonads than monads though
06:44:00 <kallisti> extend extract w = w  ?
06:44:01 <edwardk> kallisti: at least in haskell
06:44:03 <abizern> TSC2: I wrote it out as two infinite and offset list, summed the terms and backfilled them into the lists to see how  the numbers were generated  lazily.
06:44:10 <edwardk> yep
06:44:22 <edwardk> just like m >>= return = m
06:44:22 <abizern> TSC2: It was only after I did that that I finally understood Haskell's laziness.
06:44:31 <kallisti> what is the analogue of fmap and join here?
06:44:41 <edwardk> fmap is still fmap
06:44:44 <edwardk> join become duplicate
06:44:49 <edwardk> duplicate :: w a -> w (w a)
06:44:53 <kallisti> oh
06:44:55 <kallisti> right
06:44:56 <edwardk> consider the product comonad
06:45:04 * wli is unclear on what GADT's accomplish.
06:45:06 <edwardk> duplicate :: (e, a) -> (e,(e, a))
06:45:13 <kallisti> wli: they accomplish type safety, mostly.
06:45:29 <kallisti> you can create a single ADT that can represent many different types.
06:45:30 <edwardk> wli: they give you type refinement when you pattern match on them
06:45:48 <kallisti> edwardk: ah
06:45:51 <wli> kallisti: I still had to do typechecks when I wrote that trivial straight line expression evaluator.
06:46:14 <Peaker> wli: pattern-matching gives you extra type information, and type information can allow you to safely not-match some patterns
06:46:20 <Jacco> is this the most efficient way to get both the init and the last of a list? (beginner question) http://pastebin.com/9gNknLT0
06:46:22 <mauke> The paste 9gNknLT0 has been copied to http://hpaste.org/67041
06:46:23 <TSC2> abizern: I think it's also worthwhile to do the reductions by hand -- pretend you are a Haskell interpreter and evaluate the expression by substituting definitions
06:46:24 <edwardk> kallisti: duplicate :: Store s a -> Store s (Store s a); duplicate (Store f s) = Store (Store f) s
06:46:52 <kallisti> the product comonad is just Store right?
06:46:58 <Peaker> wli: take a look at: https://github.com/yairchu/red-black-tree
06:46:58 <wli> Peaker: So the pattern matching I did there was in some of the case alternatives unnecessary?
06:47:26 <edwardk> kallisti: no, the product comonad is (,) e
06:47:40 <abizern> TSC2: tbh, it's the only way I can understand them. I suppose eventually I'll be able to see them, but I've only been messing about with Haskell for a couple of weeks.
06:47:41 <Peaker> wli: perhaps.. for example: data T a where A :: T () ; B :: T Int      case (x :: T Int) of ... only needs to match B, not A
06:47:44 <kallisti> er, well I meant are they semantically equivalent?
06:47:46 <edwardk> kallisti: the store comonad is given rise to by composing the adjunction that makes state the other way.
06:47:53 <edwardk> data Store s a = Store (s -> a) s
06:48:08 <kallisti> no clue what an adjunction is. :P
06:48:15 <edwardk> the product comonad acts like a comonadic 'Reader'
06:48:23 <kallisti> right
06:48:24 <edwardk> the Store comonad acts like a comonadic 'State'
06:48:33 <edwardk> you can run the Store with different s's
06:48:41 <kallisti> ah okay.
06:48:41 <Peaker> wli: in https://github.com/yairchu/red-black-tree/blob/master/AvlTree.hs  if you've got a (Node Zero a) you don't need to pattern-match against constructors other than Nil
06:48:43 <TSC2> abizern: All you need to do is practise, read and write
06:48:43 <edwardk> just like you could look at the pointer comonad with different positions
06:49:10 <kallisti> edwardk: okay I see.
06:49:10 <mcstar> 'need to do' or 'need do' ?
06:49:24 <edwardk> there is also an analogue to writer. because, given a monoid, you can even make a comonad out of (->) e
06:49:35 <wli> Peaker: I can't keep up with Oleg or neo-Olegs; I don't come remotely close to writing this stuff every day.
06:49:52 <kallisti> edwardk: extract is function application yes?
06:50:11 <kallisti> or...?
06:50:12 <Peaker> wli: I don't think it's "neo-Olegism" heh :) It's expressing the invariants of AVL/RB in types.. Do you know the invariants of AVL or RB trees?
06:50:34 <kallisti> no
06:50:38 <edwardk> wli: part of your problem is your Val type isn't a GADT
06:50:43 <edwardk> wli thats why you had to typecheck =P
06:50:43 <wli> Peaker: I would probably have to look them up.
06:51:16 <abizern> TSC2: It's why I'm doing GCJ - an excuse to use Haskell. it's just weird learning to think differently about a problem, rather than just new syntax for concepts that transfer from languages that I already know.
06:51:18 <Peaker> wli: AVL tree invariants are simple: The maximal depth of the left-child-tree is always the same as the right-child-tree, up to a difference of 1 (1 less or 1 more)
06:51:20 <kallisti> edwardk: don't spoil the answer. :P
06:51:45 <kallisti> do you mean that e is the Monoid, or is "a" the Monoid?
06:51:47 <edwardk> kallisti: extract :: Monoid m => (m -> a) -> a
06:51:53 <kallisti> ah okay.
06:52:02 <TSC2> abizern: That's a good idea; lots of people seem to use Project Euler problems as exercises too
06:52:03 <edwardk> has to be m, can't constrain a at all
06:52:03 <kallisti> you apply mempty
06:52:07 <kallisti> and then apply a
06:52:09 <edwardk> kallisti: yep
06:52:13 <kallisti> or...
06:52:16 <edwardk> er just apply mempty giving a
06:52:18 <kallisti> you just apply mempty
06:52:19 <kallisti> yeah
06:52:21 <edwardk> extract f = f mempty
06:52:25 <Peaker> wli: I can explain the AVL types in there: "Node" represents a tree where the maximal tree depth is represented as its first type parameter
06:52:30 <abizern> TSC2: Thanks for the tip. I didn't think of that.
06:52:32 <wli> Peaker: My vague memory of what was called the invariant was more complicated. I remembered that as a property.
06:52:34 <edwardk> extend is a damn sight trickier, but uses mappend
06:52:49 <edwardk> you turn (m -> a) -> m -> m -> a
06:52:52 <edwardk> where you mappend the two arguments
06:53:05 <Peaker> wli: "Tree" is a "Node" whose depth is unknown (i.e:  Tree a = Node (exists n. n) a)
06:53:05 <kallisti> you mappend the 2 m arguments
06:53:10 <kallisti> and then apply it to (m -> a)
06:53:11 <edwardk> yep
06:53:24 <Peaker> wli: hmm.. that code certainly treats it as the invariant
06:53:33 <Peaker> wli: in RB trees the invariants are more complicated
06:53:35 <kallisti> :t extend
06:53:36 <lambdabot> Not in scope: `extend'
06:53:38 <edwardk> kallisti: thats http://hackage.haskell.org/packages/archive/comonad-transformers/2.1.1/doc/html/Control-Comonad-Trans-Traced.html
06:54:24 <edwardk> kallisti: So far we have the environment comonad (,), the store comonad, and the traced comonad.
06:54:50 <Peaker> wli: anyway, a Node of height Zero can only be the Nil tree. a Node of height (Succ n) has two children,  left-child Node of height l, and right-child Node of height r. And a proof that (Succ n) >= max(l, r). That proof is expressed in the HeightRule type
06:54:54 <kallisti> environment = product right?
06:55:00 <edwardk> kallisti: you can make a comonad out of the (logically) uninhabited data type as well. newtype Initial a = Initial Void
06:55:05 <edwardk> kallisti: yeah
06:55:17 <edwardk> oh, and i guess we started with the pointer comonad
06:55:20 <Peaker> wli: oops, a proof that n >= max(l,r),  not (Succ n)
06:55:57 <edwardk> kallisti: so with that you now have everything you need to understand the comonad-transformers package. the only difference is that the versions in there are comonad transformers, rather than the simple comonads
06:56:19 <kallisti> extract w = undefined   ???
06:56:20 <wli> My vague memory had to do with the balancing factors in the system of 5 nodes.
06:57:05 <Peaker> wli: the actual balancing is more complicated, the simple stuff is interesting though: how the simple balance between left/right children of tree nodes is expressed with GADTs
06:57:08 <kallisti> I'm not sure I see how Initial is a comonad.
06:57:25 <edwardk> kallisti: Void is uninhabited, so you can extract from it, since it doesn't exist
06:57:31 <Tinned_Tuna> Yey, just under 1000 words so far, and I'm only like a third of the way through my article. https://github.com/TinnedTuna/Haskell-Binary-Search/tree/master/blog-post
06:57:40 <edwardk> extract (Initial v) = absurd v
06:57:49 <Tinned_Tuna> I should really put a blog up on my server...
06:57:53 <edwardk> fmap _ (Initial v) = Initial v
06:58:00 <edwardk> duplicate (Initial v) = Initial v
06:58:02 <kallisti> what is absurd?
06:58:08 <Tinned_Tuna> DinnLunch
06:58:11 <Peaker> absurd :: Void -> a ?
06:58:15 <edwardk> data Void;  absurd :: Void -> a
06:58:21 * hackagebot comonads-fd 2.1.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.1.1 (EdwardKmett)
06:58:24 <kallisti> ha. okay.
06:59:25 <kallisti> the only definition I can see for absurd is  absurd = const undefined
06:59:37 <edwardk> its 'ex falso quodlibet' -- from falsehood, whatever pleases, the principle of explosion from logic in haskell form.
06:59:42 <edwardk> well
06:59:49 <edwardk> you can avoid that by making a nastier Void
06:59:55 <edwardk> newtype Void = Void Voi
06:59:57 <edwardk> er Void Void
07:00:08 <edwardk> then absurd (Void v) = absurd v
07:00:16 <kallisti> same thing.
07:00:18 <rasfar> Voivod!
07:00:19 <edwardk> yep
07:00:39 <edwardk> the only thing that newtype buys you is Haskell 98 (since empty data decls aren't)
07:00:49 <rasfar> (that's as nasty as you could wish for)
07:01:04 <Peaker> wli: anyway, I think it's all about the relationship between the actual types in type parameter positions, and the data constructors inside, which without GADTs cannot be expressed (afaik)
07:01:10 <kallisti> interesting.
07:01:16 <edwardk> kallisti: are you familiar with free monads?
07:01:20 <kallisti> nope
07:01:33 <edwardk> data Free f a = Pure a | Free (f (Free f a))
07:01:45 <edwardk> its a fun exercise to prove that if f is a Functor, Free f is a Monad
07:02:18 <edwardk> elements look like a + f (a + f (a + …))))
07:02:22 <kallisti> one sec
07:02:26 <edwardk> return = Pure
07:02:30 <kallisti> yes
07:02:33 <edwardk> i leave the >>= to you =)
07:03:00 <edwardk> if you want to peek i have a free package on hackage
07:03:35 <hpaste_> rasfar pasted “tiny typeclass problem” at http://hpaste.org/67042
07:04:00 <rasfar> i have a very small bit of code there, can anyone shed light?
07:04:23 <edwardk> rasfar: you can do one of two things
07:04:31 <rasfar> ok
07:04:33 <edwardk> {-# LANGUAGE FlexibleInstances #-}
07:04:43 <edwardk> which will permit Initable (Complex Double)
07:04:47 <edwardk> or we can reason differently
07:05:00 <rasfar> i didn't work for me GHC 7.0.4 i thought; will try again.
07:05:02 <edwardk> instance Initable a => Initable (Complex a)
07:05:28 <edwardk> You may need some other constraints on a, i didn't bother to actually try to understand the use case i confess
07:05:46 <rasfar> sorry, you are correct, -XFlexibleInstances allows the Complex Double instance
07:06:10 <rasfar> what other option did you have in mind?
07:06:17 <kallisti> Pure a >>= f = f a; Free aaaah >>= f = Free (fmap (>>= f) aaah)
07:06:23 <kallisti> *aaaah
07:06:34 <rasfar> although one solution is enough; just curious :)
07:06:36 <edwardk> instance Initiable a => Initable (Complex a)  -- possibly with a RealFloat instance or something constraining a
07:06:40 <kallisti> edwardk: how's that?
07:06:43 <edwardk> kallisti: =)
07:06:47 <edwardk> kallisti: you got it
07:06:51 <kallisti> awww yeah
07:07:14 <edwardk> kallisti: this is the most obvious way to see that monads are about substitution, because here we do no renormalization during a join
07:07:16 <edwardk> we just keep the structure
07:07:48 <edwardk> the is a way to make a monad that only satisfies the monad laws and nothing more
07:07:59 <edwardk> useful when you go to build interpreters and what not later
07:08:04 <edwardk> the reason i brought it up though
07:08:08 <edwardk> is there is a comonad just like it
07:08:17 <kallisti> for Free?
07:08:21 <edwardk> data Cofree f a = a :< f (Cofree f a)
07:08:27 <kallisti> oh
07:08:49 <kallisti> extract (a :< _) = a
07:08:52 <edwardk> instance Functor f => Comonad (Cofree f)
07:08:52 <edwardk> extract (a :< _) = a
07:09:00 <edwardk> then extend I leave to you =)
07:10:10 <edwardk> when f is Maybe you can verify that this is just a non-empty list
07:10:25 <kallisti> extend (a :< f aaah) = a :< fmap (>>= f) aaah
07:10:27 <kallisti> edwardk: oh cool
07:10:29 <kallisti> yeah I see that.
07:10:39 <edwardk> extend rather than >>= but yeah
07:10:44 <kallisti> oh right
07:10:55 <edwardk> when f is [] you get a rose tree
07:11:01 <edwardk> which is Data.Tree from containers
07:11:07 <rasfar> no luck with the second option yet so I'll embrace -XFlexibleInstances, thank you edwardk
07:11:15 <edwardk> rasfar: no problem
07:11:34 <kallisti> edwardk: a rose tree is just a generic tree?
07:11:36 <edwardk> rasfar: there are a lot of stream comonad variants in the 'streams' package
07:11:46 <edwardk> its a tree where you can have an arbitrary number of children
07:11:48 <kallisti> right
07:11:54 <kallisti> no rules or anything.
07:11:55 <kallisti> about that.
07:12:01 <edwardk> yeah
07:12:15 <kallisti> it could actually be a cyclic graph I guess.
07:12:19 <edwardk> the cofree comonad of 'f' is also sometimes called an 'f-branching stream'
07:12:21 <kallisti> and not an actual tree.
07:12:35 <edwardk> could, but maps tend to destroy sharing ;)
07:13:01 <kallisti> for reference is "the cofree comonad" just the Cofree thing?
07:13:06 <edwardk> yeah
07:13:26 <kallisti> what is a "cofree monad"
07:13:31 <kallisti> and a free comonad
07:13:33 <edwardk> there are different ways to make stream like comonads, you can make them causal, anticausal, etc.
07:13:40 <edwardk> they don't exist (per se)
07:13:55 <kallisti> ah okay.
07:14:05 <edwardk> technically the ADT i gave for Cofree _does_ admit a monad, but its not actually cofree
07:14:19 <edwardk> you need more out of 'f' as well
07:14:45 <edwardk> in terms of my semigroupoids package you'd need an instance of Plus f, not just Functor f
07:14:48 <kallisti> so yeah cofree comonad is a kind of "stream"
07:14:52 <edwardk> yep
07:14:55 <wli> edwardk: So a GADT would be more appropriate for representing a normalized result?
07:15:18 <edwardk> well, if you had a GADT based value type, then you wouldn't have to deal with the bad cases, they just woudn't be matchable
07:15:39 <kallisti> all of these fancy CT terms are reminding me that I need to do my math homework.
07:15:45 <kallisti> and learn the basics before I do any of that stuff.
07:15:45 <edwardk> data Val a where CharVal :: Char -> Val Char; IntVal :: Int -> Val Int; ...
07:15:56 * kallisti is currently talking about functions. we just finished equivalence relations.
07:16:18 <wli> edwardk: So a GADT would be a result of a typechecker or expression normalizer (ratio of sum of products) etc.?
07:16:40 <edwardk> wli: then when you are working eval :: … -> Expr a -> Val a  -- you know you are getting the well typed argument for the next thing you want to do
07:17:01 <wli> edwardk: I was at a loss for polymorphism in the result type there.
07:17:34 <edwardk> its not polymorphic in it in the end
07:17:53 <edwardk> there is a type variable there, but you can't make a Functor instance for that Val for instance.
07:18:08 <Gracenotes> hm, okay... just to sanity-check myself: seq can't make anything which is bottom non-bottom, yes? Only the other way around.
07:18:28 <edwardk> Gracenotes: correct
07:18:39 <Gracenotes> I'm doing STG-level stuff
07:18:45 <edwardk> Gracenotes: you need spoon for that ;)
07:18:56 <Gracenotes> >.>
07:19:05 <edwardk> http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html
07:19:33 <rwbarton> there is no spoon
07:19:35 <edwardk> teaspoon a = unsafePerformIO $ (Just `fmap` evaluate a) `catches` handlers
07:19:39 <edwardk> rwbarton: wise
07:19:49 <kallisti> LogicT is more efficient that [] for concatenation (logical or)  yes?
07:19:54 <kallisti> *than
07:20:01 <Gracenotes> hm doesn't do so well on nonterminating bottoms I suppose
07:20:13 <edwardk> kallisti: yeah
07:20:15 * kallisti uses LogicT in his chess variant code, but really only uses it in the same way a list would be used.
07:20:16 <Gracenotes> but those are sort of operational anti-patterns
07:20:23 <kallisti> is there something else I should be using?
07:20:33 <edwardk> kallisti: Nope. LogicT is pretty clean
07:20:41 <kallisti> alright cool
07:20:50 <edwardk> LogicT is just Codensity Endo ;)
07:20:58 <edwardk> there isn't much that can be done to simplify it
07:21:02 <kallisti> actually I think I used ifte somewhere
07:21:06 <kallisti> I'm not sure what is in []
07:21:28 <edwardk> data [a] = a : [a] | []
07:21:39 <edwardk> (effectively)
07:22:08 <kallisti> :t ifte
07:22:09 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b -> m b
07:22:29 <kallisti> oh nevermind I don't use ifte
07:22:31 <reinoud> @help
07:22:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:22:35 <edwardk> newtype LogicT m a = LogicT { runLogicT :: forall r. (a -> m r -> m r) -> m r -> m r }
07:23:30 <edwardk> if you drop the 'm' then you get forall r. (a -> r -> r) -> r -> r, and Endo r = r -> r, so forall r. (a -> Endo r) -> Endo r = Codensity Endo a
07:24:33 <edwardk> then the ability to concatenate lists follows immediately from the easiest way to make a MonadPlus out of Codensity
07:25:27 <edwardk> Yoneda Endo gives you a cps'd Maybe, which is very similar
07:25:41 <edwardk> forall r. (a -> r) -> r -> r
07:25:54 <kallisti> since the logic to determine movesets for pieces is somewhat complex (you have to follow portals) I made a sort of DSL for describing movesets with type WalkT m = LogicT (RWST WalkInfo (DList Char) (Set Move) m)
07:25:54 <edwardk> is you passing it a 'just continuation' and a 'nothing continuation'
07:26:03 <kallisti> (I don't actually use the Writer part of RWST though..)
07:26:21 <edwardk> what game?
07:26:34 <kallisti> it's a chess variant I made up called "portal chess", I'm still working out the rulset.
07:26:39 <edwardk> ah
07:26:41 <kallisti> *ruleset  but you can kind of guess how it might work.
07:26:56 <edwardk> *nods*
07:27:36 <kallisti> ifPiece = asks wSquare >>= guard . isJust >> asks wMove
07:27:39 <edwardk> now you just need to play it with this chess set http://www.youtube.com/watch?v=dav9OyEORk4
07:27:44 <kallisti> so then if you do  ifPiece >> someMove
07:28:01 <kallisti> someMove will only happen if ifPiece doesn't evaluate to mzero
07:28:02 <edwardk> one side really needs Chell as the queen though
07:28:23 <kallisti> ifBlocked = lnot (followPortal) >> ifPiece
07:28:38 <kallisti> which basically reads as "if we can't follow a portal, and there's a piece in our way, we're blocked"
07:29:35 * kallisti wonders if there's a better way to do this kind of stuff though.
07:29:39 <rasfar> It's a bit difficult to achieve polymorphism between Double and Complex Double in Haskell?  I seem to be working against the grain somehow.
07:29:54 <kallisti> rasfar: what shared characteristics do you want?
07:30:20 <rasfar> Basically, the whole program can be polymorphic in those two types, in principle.
07:30:28 <Cale> rasfar: It's not that difficult, there are a fair number of typeclasses which those both fall into.
07:30:32 <kallisti> note that "polymorphism for the sake of polymorphism" is likely not going to turn out well.
07:30:38 <rasfar> There are maybe 6 places where differences are required.
07:30:40 <kallisti> unless you have a specific goal in mind.
07:31:24 <rasfar> Cale, I'm just starting to try to properly understand typeclasses.  Maybe there is a simple solution using an existing class that unifies them?
07:31:45 <kallisti> I mean, in your case. where you have this large program and you're having multiple type issues and you don't really seem to know what to do about them.
07:31:49 <Cale> Well, as kallisti asked, what operations do you need?
07:31:52 <rasfar> This is an application where maintaining polymorphism between Double and Complex Double makes good sense.
07:31:55 <Cale> Fractional might be enough
07:32:34 <Cale> or maybe Floating
07:32:37 <rasfar> I might be able to get rid of one or two problematic operations that I took for granted when using only Double (like Ord stuff).
07:32:55 <edwardk> rasfar: this is why i recommended the harder instance
07:32:56 <rasfar> Fractional I need, as I do divisions (averages, normalisation, ...)
07:32:57 <Cale> Actually, probably Floating is what you want.
07:33:06 <kallisti> does it make mathematical sense to do what you're doing with both types?
07:33:20 <rasfar> Floating -- I don't think I tried that anywhere yet.
07:33:40 <rasfar> edwardk: what do you mean by "harder instance" -- was that the second solution you proposed to my hpaste?
07:33:46 <edwardk> yeah
07:34:07 <edwardk> rasfar: but i didn't look close enough at what you were doing to know everything you'd need to constrain it to have
07:34:15 <kallisti> edwardk: do you think there's a better way to traverse a board and determine a moveset for a piece? I think this one is pretty solid but maybe there's something I haven't considered.
07:34:23 <rasfar> I'd like to get that to work, as now (with the Complex Double instance instead of Complex a), I'm getting asked to have Double a lot of places downstream which were happily polymorphic before.
07:34:49 <nand`> seeing as Double has a RealFloat instance that automatically gives Complex Double a Floating, Fractional and Num instance so I don't see what more you might want to need
07:34:51 <edwardk> kallisti: there are plenty of faster ways, the trick is whether ot not they are flexible enough to allow easy changing of the rules, etc. the current design you have seems pretty flexible
07:34:51 <rasfar> Let me try again the second solution you proposed, and I'll prepare another hpaste if I continue to have problems...
07:35:14 <kallisti> edwardk: yes I was thinking eventually I could extend this to other games.
07:36:03 <kallisti> one thing I had to avoid was infinite loops. since it's perfectly permissible that walking around the board to determine moveset results in an infinite loop as you follow portals around.
07:36:20 <edwardk> rasfar: in practice its hard to get good polymorphism between double and complex double especially when you want to use abs in some places
07:36:40 <rasfar> nand`, thanks ... i don't know, it's a pretty complicated program already so it's hard to give consise answers to "what constraints do you need" etc.
07:37:01 <rasfar> edwardk, no doubt!
07:37:02 <edwardk> what do you place the portals on? squares? or the edges between squares?
07:37:16 <kallisti> portals are an actual piece.
07:37:19 <kallisti> with a direction
07:37:21 <edwardk> ah
07:37:23 <kallisti> pieces have directions in this game.
07:38:17 <edwardk> hrmm, so pieces can move through the portals?
07:38:21 <kallisti> yep
07:38:31 <kallisti> fun times ensue.
07:38:32 <edwardk> this means you can get your bishops on the same color?
07:38:33 <rasfar> seems like my options are: 1) typeclasses (I'm hoping for),  2) wrap in Either and pattern match (inefficient), or  3) fork as much code as necessary to have explicit Double and Complex Double versions (very bad).
07:38:42 <kallisti> edwardk: well all of the pieces are different, but yes.
07:38:48 <edwardk> fair nuff
07:39:01 <edwardk> rasfar: what is the domain?
07:39:09 <rasfar> labelled graphs
07:39:16 <kallisti> edwardk: it's not really supposed to be as simple or elegant as chess. it's more of an experiment on the idea "what if there was a board game like chess with portals?"
07:39:22 <rasfar> network flow and such
07:39:23 <edwardk> rasfar: the weights on the graph are the numbers you want?
07:39:29 <rasfar> yes indeed
07:39:38 <edwardk> ok, so you want to be able to have complex flow
07:39:44 <edwardk> then you'll probably be fine
07:39:45 <rasfar> more or less
07:40:02 <rasfar> gosh i hope so, but it's pretty hectic at the moment lol
07:40:59 <nand`> edwardk: you mentioned abs can cause problems with polymorphism between Double and Complex Double; I'm not sure I follow why
07:41:20 <hpc> :t abs
07:41:21 <lambdabot> forall a. (Num a) => a -> a
07:41:30 <kallisti> > abs (1 :+ 3)
07:41:31 <lambdabot>   3.1622776601683795 :+ 0.0
07:41:39 <nand`> do you need to substitute another function instead of abs for complex numbers in some places?
07:41:41 <edwardk> nand`: well, often when I work with abs what I really want is a norm or quadrance
07:41:47 <hpc> nand`: it could be that you are using abs as a "give me magnitude" function
07:41:51 <edwardk> nand`: so i often want to get a real number out of it
07:41:57 <hpc> and really want the Double answer instead of the Complex Double answer
07:42:06 <edwardk> whereas with the Num typeclass on Complex i'm forced to get another complex number
07:42:29 <edwardk> The abs and signum in Num are one of the things that make me sad
07:42:56 <nand`> hpc: but then that would be realPart . abs; which is no longer in the domain of polymorphism either way
07:42:57 <rasfar> nand`: i think signum is the equivalent
07:43:18 <rasfar> nand`: that's exactly the expression i'm trying to use right now
07:43:28 <nand`> > signum $ 1 :+ 3
07:43:29 <lambdabot>   0.31622776601683794 :+ 0.9486832980505138
07:43:39 <rasfar> it's no longer polymorphic at that point, but in other parts of the code the polymorphism is upheld usefully
07:43:44 <edwardk> nand`: well, it could be. if you had an type family relating your numeric type to its metric type
07:44:01 <edwardk> rasfar: you can of course cheat in some ways
07:44:07 <kallisti> Typeable!
07:44:12 <kallisti> just what he needs, more typeclasses.
07:44:22 <hpc> @src Double
07:44:22 <lambdabot> data Double = D# Double#
07:44:25 <edwardk> class HasDoubleRealPart a where myRealPart :: a -> Double
07:44:26 <hpc> just use unsafeCoerce
07:44:27 <rasfar> look, i'm not one of the typeclass-happy types okay?!?
07:44:37 <kallisti> > typeOf 2
07:44:38 <lambdabot>   Integer
07:44:39 <hpc> and... Complex Double#
07:44:42 <hpc> ;)
07:45:03 <rasfar> hpc: that might actually be a good idea, once the code is really solid without unsafe stuff.
07:45:07 <edwardk> instance HasDoubleRealPart Double where myRealPart = id; instance HasDoubleRealPart a => HasDoubleRealPart (Complex a) where myRealPart = myRealPart . realPart
07:45:14 <hpc> rasfar: no, don't use it :P
07:45:18 <kallisti> hpc: look at what you've done.
07:45:24 <edwardk> rasfar: that was very very very cynical advice
07:45:42 <rasfar> hey, i know, but performance may be an issue eventually...
07:45:53 <edwardk> rasfar: this isn't a performance sensitive issue here ;)
07:45:54 <rwbarton> it also wouldn't work
07:46:03 <hpc> hint: "just use unsafeCoerce"
07:46:04 <rasfar> no, i'm willing to do this the Right Way if it kills me.
07:46:07 <kallisti> edwardk: https://github.com/kallisti-dev/portalchess/blob/master/PortalChess.hs  here's the completely untested, undocuemnted, and somewhat old code with poor naming. enjoy!
07:46:07 <edwardk> if you need unsafeCoerce for this sort of thing then you're doing it wrong ;)
07:46:30 <nand`> I would be thinking along the lines of realPart :: (RealFloat b, NumConvert a b) => a -> b; together with some instance RealFloat a => NumConvert a a where realPart = id
07:46:34 <rasfar> i only use unsafe in one place -- my own version of Debug.Trace(trace)
07:46:49 <edwardk> kallisti: have you looked at doing any sort of alphabeta/negascount/MTD(f) style move trimming?
07:47:25 <edwardk> nand`: the level of polymorphism there almost damns him to have to put type signatures _everywhere_
07:47:33 <kallisti> edwardk: I know absolutely nothing about any of that.
07:47:36 <edwardk> nand`: thats why i went with HasDoubleRealPart as a cheat
07:48:08 <edwardk> kallisti: start from http://en.wikipedia.org/wiki/Negascout
07:48:15 <edwardk> or http://en.wikipedia.org/wiki/Alpha-beta_pruning
07:48:21 <kallisti> edwardk: I'm a self-taught computer scientist going to a sub-par tech university.
07:48:28 * kallisti will check it out.
07:48:33 <rasfar> edwardk: HasDoubleRealPart cheat noted
07:48:33 <edwardk> kallisti: basically you score the game, right?
07:48:55 <edwardk> kallisti: and when you do so you have two players, one trying to maximize the score, and one trying to minimize it
07:49:17 <edwardk> so if you look at the final board score its a max(min(max(min(max(….)))))
07:49:52 <edwardk> turns out that once you work out one of those answers you can use it to prune some of the branches early
07:50:04 <kallisti> edwardk: oh this is for the AI right?
07:50:08 <kallisti> I haven't even touched that.
07:50:12 <edwardk> yeah
07:50:17 <hpc> http://upload.wikimedia.org/wikipedia/en/7/79/Minmaxab.gif
07:50:33 <kallisti> so far the LogictT stuff exists solely to determine what the moveset for a piece is
07:50:58 <edwardk> kallisti: ah fair nuff
07:51:24 <kallisti>  but once I get into AI (if ever) I'll look into these techniques.
07:51:32 <kallisti> I suspect a portal chess AI is a bit trickier to work out.
07:51:49 <edwardk> kallisti: naive alphabeta is pretty easy to get running, negascout is just a slight shift in encoding of that
07:52:29 <edwardk> MTD(f) with iterative deepening is a nice improvement on that if you have an integer board scoring function and want lots of plys and are willing to encode scary looking transposition tables, etc.
07:53:30 <kallisti> edwardk: oh I have code that derives Enum and Bounded instances from product types of Enums and Boundeds. Does that already exist on Hackage, because if not I might upload as its own thing.
07:53:32 <edwardk> in chess its overhead seems to be too high these days, but its nice in that you use the answer for a smaller number of moves to compute your initial guess for the next number, so your AI is always ready to make the next move with a fully thought out answer, even if you force it to abort early
07:54:14 <kallisti> essentially an Enum for a product type is a mixed base number system.
07:54:24 <edwardk> its not up there. partially because the toEnum/fromEnum for it quickly runs out of room
07:54:31 <kallisti> yes I considered that
07:54:31 <edwardk> silly language designers using Int
07:54:48 <edwardk> also there are lots of illegal enums for things like float/double
07:55:02 <kallisti> I might also include a) (an Enum typeclass that doesn't run out of room)  b) maybe a way to detect overflow
07:55:42 <kallisti> edwardk: well I was thinking I could add a typeclass that's something like "Enum, but with more information about what that means"
07:55:47 <kallisti> so that I can sanely derive instances.
07:56:04 <edwardk> well, there is the more principled http://hackage.haskell.org/packages/archive/enumerable/0.0.3/doc/html/Data-Enumerable.html
07:57:14 <kallisti> edwardk: not quite as efficient though
07:57:26 <edwardk> yeah, but it won't crap out because of Int ;)
07:57:46 <edwardk> and it can do other things like enumerate functions for certain types
07:57:47 <kallisti> but yeah I didn't know about this. so I'll take that into consideration as well, if this even becomes a thing.
07:58:18 <edwardk> if nothing else, ping copumpkin for ideas
07:59:51 <kallisti> the code is used to write a Storable instance for my board square type.
08:00:05 <kallisti> so that I can represent each square as a (if I recall correctly) Word16
08:00:32 <rgr> I'm having trouble understanding the statement "everything before the => is a class constraint" in case of "(==) :: (Eq a) => a -> a -> Bool  " ... surely a->a is the class constraint since its saying they must be of the same type. Can you spell out how I should be reading this please.
08:01:18 <kallisti> rgr: do you know what a class is?
08:01:45 <kallisti> Eq a =>  ...  is the class constriant because it's constraining the polymorphic type "a" to be an instance of "Eq"
08:02:46 <kallisti> the a -> a is just a regular type signature.
08:02:49 <rgr> aha right. Ok. I read it now.
08:03:02 <edwardk> Eq a tells you that you know how to compute (==). the two arguments both having a as their type just says that they have the same type, not that you can compare values
08:03:05 <merijn> rgr: Imagine this, what should "(==)"do for a's that cannot be compared?
08:03:37 <merijn> (And how would (==) know how to compare?)
08:03:41 <edwardk> i should sleep
08:03:46 * edwardk &
08:03:49 <kallisti> edwardk: nah sleep sucks
08:04:56 <rasfar> bye edwardk, thanks for your help, i'm chewing on it
08:05:13 <edwardk> rasfar: i'm sure i'll be around =)
08:05:19 <kallisti> edwardk: also what should I call this package? I was thinking product-enums but then I realized it would also have code for sum enums. So maybe like derive-enum or something? but then if it also s an improved Enum class then that's not accurate either.
08:05:25 <navaati> hi
08:05:33 <kallisti> oh, nevermind, if you're leaving.
08:05:39 <kallisti> hello
08:05:40 <wli> How sharply limited are the EDSL's expressible via GADT's?
08:05:50 <edwardk> kallisti: dunno. its awkward because the instances would be orphans and not at all canonical
08:06:13 <edwardk> wli: not very. i've built dependently typed DSLs this way
08:06:34 <wli> I must be missing some techniques, then.
08:06:34 <hpc> edwardk: orly?
08:06:46 <edwardk> hpc: some cheating necessary =)
08:07:10 <kallisti> edwardk: oprhan instances? where?
08:07:14 <edwardk> hpc: but not much, i'll dig up an example, but i'm really going to leep now =)
08:07:26 <edwardk> kallisti: if you use this to define instances for (a,b) etc
08:07:34 <kallisti> edwardk: oh, no I was going to newtype it.
08:07:45 <edwardk> oh then go right ahead ;)
08:07:54 <johnnowak> hello all. if I get warnings when using -dcore-lint, is that anything to worry about?
08:08:12 <kallisti> actually it may not be a real newtype
08:08:21 <kallisti> since I'd rather have a constructor operator of some kind.
08:08:41 <edwardk> kallisti: there are pros and cons to each.
08:09:25 <edwardk> i find it sad that a newtype Foo a b = Foo { runFoo :: (a, b) } -- can be faster than data Foo = Foo a b =(
08:09:40 <edwardk> (when you go to convert back and forth to (a,b) a lot)
08:09:53 <kallisti> edwardk: what are the disadvantages of a newtype?
08:09:55 <edwardk> the newtype can convert for free with perfect sharing
08:10:05 <edwardk> the data type is less verbose and more haskelly
08:10:28 <edwardk> and you can't put existentials on a newtype
08:10:30 <kallisti> well, how about a newtype with an operator constructor?
08:10:34 <kallisti> oh. hm
08:10:39 <kallisti> I doubt that will be important.
08:10:45 <hpc> what's sad is ghc only needs to notice that Foo = (a, b) and slip in some unsafeCoerces
08:10:54 <edwardk> and the constructor doesn't help coz you need a tuple
08:11:09 <kallisti> er I mean
08:11:13 <hpc> or i suppose you could cheat and write your own conversion coercion
08:11:15 <kallisti> an operator "constructor"
08:11:15 <edwardk> hpc: and it works right up until some smartass looks at the infotable of the target
08:11:48 <edwardk> and yes, you can make unsafeCoerce based casting ;)
08:12:01 <edwardk> but its sad that you have to
08:14:59 <kallisti> :t maxBound
08:15:00 <lambdabot> forall a. (Bounded a) => a
08:16:28 <hpaste_> wli pasted “GADT's not quite right this time” at http://hpaste.org/67043
08:18:20 <kallisti> I think if typeclass laws were somehow encforceable then IncoherentInstances would be less of a problem, in cases where the overlapped instances are proveably equivalent.
08:19:03 <wli> data Expr ident t where LetExpr :: Ord ident => { bindings :: Map ident ([ident], Expr ident t), body :: Expr ident t } -> Expr ident t appears troublesome.
08:19:36 <kallisti> wli: are you sure that's where you want your class constraints?
08:19:43 <hpc> kallisti: at that point you might as well use the dictionaries directly ;)
08:20:10 <wli> kallisti: No, but it has more trouble with the parameter not matching in the Map
08:20:16 <hpc> data Eq a = Eq {(==) :: a -> a -> Bool, ...}
08:22:03 <kallisti> wli: try removing the constraint and only applying it in functions where it's needed.
08:22:23 <kallisti> I'm not sure if that helps your actual problem (since you weren't too specific on what the actual problem is) but that should help in general.
08:22:30 <wli> kallisti: The constraint is needed for Map
08:22:46 <wli> kallisti: It's complaining about the other type variable anyway.
08:23:10 <kallisti> it is?
08:23:24 <kallisti> from Hackage docs: data Map k a
08:23:28 <kallisti> I don't see anything about a constraint there
08:24:32 <hpc> kallisti: every function on Map constrains the key
08:24:38 <hpc> because you have to be able to look shit up
08:24:46 <kallisti> yes, so it's not needed in his data declaration
08:24:51 <kallisti> it's needed in his function declarations.
08:25:09 <kallisti> also null and size don't require Ord constraints. :)
08:25:20 <kallisti> or empty. or singleton
08:25:27 <hpc> oh i see; missed the original question
08:25:40 <hpc> yeah, get rid of the Ord constraint and just put it on all the functions
08:25:52 <hpc> you still need the constraint on the functions anyway, so it's no big loss
08:25:59 <wli> The Ord constraint is irrelevant.
08:26:17 <wli> The mismatch is on the other type variable.
08:28:13 <kallisti> wli: type errors are always helpful
08:29:53 <wli> It looks like a heterogeneous collection issue but shouldn't be.
08:29:56 <kallisti> hm interesting, since there's no Ord constraint on those functions, Map doubles as a tagged Maybe. :P
08:30:14 <wli> kallisti: There's no function, it's a GADT decl.
08:30:22 <kallisti> wli: that was an unrelated thought
08:30:26 <kallisti> but uh
08:30:35 <kallisti> type errors are helpful, like I said. otherwise I've got no help
08:30:48 <TheLemonMan> is Int64 a standard type ?
08:31:01 <hpc> @hoogle Int64
08:31:01 <lambdabot> Data.Int data Int64
08:31:01 <lambdabot> GHC.Constants iNT64_SIZE :: Int
08:31:41 <kallisti> TheLemonMan: it is as of Haskell 2010
08:31:44 <kallisti> I don't know about 98
08:33:23 <TheLemonMan> i really hate strict typing when it comes to numbers heh
08:33:30 <TheLemonMan> too many casts for me
08:34:06 <Rc43> Hi, guys.
08:34:21 <kallisti> TheLemonMan: technically you mean monomorphic and not strict. strict means something else entirely.
08:34:27 <kallisti> but yes it's annoying.
08:34:33 <kallisti> hello
08:34:34 <Rc43> Is type inference really a kind of data flow analysis?
08:35:14 <rwbarton> I suspect he means "strong"
08:35:24 <rasfar> TheLemonMan: you'll notice places where it pays off though, where the typechecker shows you why something doesn't really make sense.
08:35:29 <hpc> Rc43: kind of
08:35:39 <hpc> Rc43: the term you might want to look up is "unification"
08:36:49 <TheLemonMan> err yep, i meant strong
08:36:54 <Rc43> hpc, hmm, `unification` is too common word to google it.
08:36:57 <hpc> in very vague terms, it infers the type of one thing by unifying it with stuff it uses / stuff that uses it
08:37:06 <hpc> https://duckduckgo.com/Unification_%28computer_science%29
08:38:26 <Rc43> hpc, would it correct to say that unification solves the system of equations like in data-flow analysis (out_some_node = transfer (in_some_node) and in_some_node = join (states_of_all_predecessors)) ?
08:38:41 <Rc43> and states here are types
08:39:22 <TheLemonMan> anyway im in a deadlock, i have to truncate the int64 in any case
08:39:39 <hpc> i suppose 'join' could be unification
08:39:49 * hpc isn't really qualified to do much more than point you to good links
08:41:13 <wli> http://www.cs.indiana.edu/~adamsmd/talks/mhaskell/mHaskell.pdf has slightly more dirt
08:41:13 <Rc43> hpc, join doesn't seem to be unification; I mean it is just combines types of arguments like join ('x is Int', 'y is String') = 'x is Int and y is String'
08:41:19 <kallisti> ah so the difference between the cofree comonad and the free monad is that one is a recursive product type and the other is a recursive sum.
08:41:56 <hpc> Rc43: ah
08:42:31 <navaati> is there an "understanding comonad" somewhere ?
08:42:31 <navaati> (inb4 "comonads are like coburritos")
08:42:32 <hpc> yeah, unification is more "x is the union of (Int, a) and (b, String), so a = String, b = Int, x = (Int, String)
08:42:37 <rasfar> kallisti, i wish i was you, getting initiated into these arcana but my time hasn't come yet =)
08:42:46 <kallisti> navaati: not that I found. there's edwardk but he's gone now.
08:42:56 <merijn> Comonads are like burritos, it's almost impossible to keep something in
08:42:58 <kallisti> navaati: if this channel is logged you could go up a bit and see my conversation with edwardk.
08:43:00 <hpc> haha
08:43:09 <kallisti> where he explained comonads.
08:43:16 <navaati> kallisti: when ?
08:43:26 <kallisti> navaati: not too long before you joined today
08:43:32 <hpc> see the topic:
08:43:33 <edwardk> merijn: you can extract the filling from the burrito, and you can always wrap a burrito in another tortilla
08:43:34 <hpc> "Logs: http://bit.ly/5mwtRQ "
08:43:50 <navaati> thanks
08:43:56 <rwbarton> this sounds like a significantly better analogy than the monad analogy
08:44:15 <hpc> "comonads are like monads"
08:44:16 <merijn> I mentally just translate "co" to "opposite world" :p
08:44:21 <hpc> yeah i can see how that might be a problem ;)
08:44:22 <rasfar> and btw, my code now works with Complex Double !! thanks all around
08:44:30 <edwardk> rasfar: gratz =)
08:44:42 <edwardk> kallisti: it is
08:44:58 <wli> The way I'm doing variable binding doesn't fit in with GADT's.
08:45:00 <edwardk> http://tunes.org/~nef/logs/haskell/
08:45:29 <wli> The STLC examples have something I don't quite grok to do it.
08:45:42 <kallisti> edwardk: what's the significance behind Cofree being a product and Free being a sum?
08:46:39 <edwardk> kallisti: it has to do with being left or right adjoint to the diagonal functor, and all sorts of fun stuff
08:47:01 <kallisti> that does indeed sound fun.
08:47:40 <Gracenotes> hm. porting old code. Map and IntMap NFData instances went away? :x
08:48:03 <Gracenotes> hm, no
08:48:17 <edwardk> 'free' just means left adjoint to a forgetful functor, whereas cofree is right adjoint to one
08:48:34 <rasfar> edwardk: did you take a cat theory course, and if so do you mind me asking who taught it?  i don't know why i'm assuming you are (or recently were) a student.
08:48:45 <rwbarton> kallisti: "free monad on a functor f" means, among other things, we have a map   f a -> m a
08:48:59 <rwbarton> also we know since m is a monad we have  return :: a -> m a
08:49:02 <edwardk> rasfar: nah, my college was one of those places that viewed category theory as generalized abstract nonsense
08:49:21 <rasfar> so self-taught then?
08:49:22 <rwbarton> so putting these together we have Either a (f a) -> m a and you can already see how m is going to look like an Either
08:50:02 <rwbarton> for a cofree comonad, instead we assume  w a -> f a  and  extract :: w a -> a  so putting these together gives  w a -> (a, f a)
08:50:05 <edwardk> rwbarton: yeah, but that just takes you to ideal =)
08:50:05 <rasfar> maybe "self-taught" isn't the right term; i'm sure you had a lot of interactions with people.
08:50:17 <kallisti> edwardk: where did that Either come from.
08:50:46 <edwardk> kallisti: Pure a | Free (f (Free f a))    ~ Either a (f (Free f a))
08:50:51 <kallisti> yes I see that
08:51:05 <kallisti> but, I don't see how you put those facts together to get a sum type.
08:51:06 <merijn> Hmm, is it possible to have a typeclass "class Foo a b c" and enforce that c == (a b)?
08:51:20 <rwbarton> "class Foo a b"
08:51:27 <rwbarton> s/c/a b/g
08:51:39 <hpc> merijn: class Foo a b where type c = a b; ...
08:51:42 <hpc> perhaps?
08:51:49 <hpc> or what rwbarton said
08:51:58 <edwardk> rasfar: i picked up category theory by going back and repeatedly banging my head against categories for the working mathematician, and serge lang's algebra while i learned haskell
08:52:11 <hpc> don't parameterize over something that can be exactly one thing
08:52:27 <merijn> hpc: Maybe? I considered rwbarton's obvious suggestion, but somehow arrived at the conclusion I couldn't write the instances I want
08:52:35 <rasfar> (thanks; i find it interesting how people get into it)
08:52:35 <edwardk> rasfar: merijn: class (c ~ a b) => Foo a b c
08:52:36 <Gracenotes> wait, the instance of IntMap and Map were *removed* from deepseq? :| I'm sure there was a good reason for that...
08:53:12 <Gracenotes> yay orphan instances
08:53:23 <merijn> Basically I want to write "instance (Foo a b c) => Foo a b (d -> c)", I don't think I can enforce that if I write c directly as "(a b)"?
08:53:48 <rwbarton> uh
08:54:07 <merijn> edwardk: oh! Interesting, lemme see if I can figure out the proper typeclass using that.
08:54:11 <rwbarton> < merijn> Hmm, is it possible to have a typeclass "class Foo a b c" and enforce that c == (a b)?
08:54:14 <edwardk> rasfar: anyways, since then i've largely been immersed in it, because I've now got something like 40 packages worth of Haskell stuff that is all category theory oriented
08:54:18 <rwbarton> if c == a b then (d -> c) /= a b
08:54:26 <edwardk> merijn: you may need 7.4.1
08:54:29 <merijn> rwbarton: Ok, so my original question was wrong
08:54:38 <rwbarton> did you mean instance instead of class?
08:55:21 <merijn> rwbarton: My point is that the only way I could think to construct the type I want is using Data.Functor.Compose/Data.Functor.Identity which would force users to always use getCompose/runIdentity when using it. Which defeats the purpose
08:55:38 <edwardk> rasfar: and for me the risk of public embarassment is a huge motivator to make sure i have things encoded right ;)
08:56:08 <rwbarton> if there was any context before "is it possible to have a typeclass "class Foo a b c" ..." I missed it
08:56:16 <rasfar> edwardk: I think you do.  After adding -XMultiParamTypeClasses and -XTypeFamilies ...
08:56:22 * kallisti is apparently leaning toward the "practical" spectrum of package uploads.
08:56:31 <rasfar> it still says:      Alas, GHC 7.0 still cannot handle equality superclasses: c ~ a b
08:56:40 <rasfar> that's GHC 7.0.4
08:56:43 <edwardk> rasfar: yeah, 7.4.1 fixed that
08:57:34 <edwardk> there exist workarounds in 7.0.4 with explicit witness members in the dictionary, but its ugly
08:57:50 <martin3z> hi, how to start?
08:58:07 <edwardk> martin3z: http://learnyouahaskell.com/
08:58:13 <martin3z> ok thx
08:58:25 <rasfar> confirmed; but you still need both those extensions.
08:58:26 <hpc> martin3z: you have to insert two quarters
08:58:46 <hpc> :P
08:59:55 <martin3z> just very first q: if apps are portable between linux and windows? libraies are similar?
09:00:02 <rasfar> edwardk: no doubt, once you start the snowball rolling, you have to watch it.  especially when you're in the snowball.
09:00:24 <hpc> martin3z: you can compile the same code on linux and windows, usually
09:00:39 <hpc> but you can't run the same binary on both OSs
09:01:03 <rasfar> public embarrassment with me is a given, so i'm somewhat less constrained :)
09:01:03 <martin3z> hpc: what about API and visual libraries?
09:01:42 <merijn> rwbarton, edwardk: I want to construct a type that will both match "(a -> b -> m c) -> m a -> b -> m a" and "(a -> m c) -> m a -> m a" which could be written as "class Hack x where foo :: (Monad m) => (Compose ((->) a) x (m b)) -> Compose ((->) (m a)) x (m a)" and then have instances for "instance Hack Identity" and "instance (Hack a) => Hack (Compose ((->) b a)", but that suffers from the previous mentioned problem of having to use
09:01:42 <merijn> getCompose/runIdentity when using foo...
09:01:50 <martin3z> hpc: if i write code for app with windows, events and such, it will be possible to recompile?
09:02:08 <hpc> if you use windows APIs, your code is stuck on windows
09:02:11 <edwardk> merijn: you're screwed
09:02:17 <hpc> if you use linux APIs, your code is stuck
09:02:21 <edwardk> merijn: you need overlapping instances at least
09:02:28 <hpc> if you use C libs that have shitty windows ports, you might be stuck
09:02:30 <hpc> it varies
09:02:40 <edwardk> since you need to overlap b -> m c  which has an -> on the outside, with m c which is polymorphic on the outside
09:02:58 <martin3z> hpc: so how to write common code?
09:03:52 <merijn> edwardk: Yeah, but even with OverlappingInstances you still can't do it (or rather, I haven't figured out how) without getCompose and runIdentity. It'd work if only GHC supported first class composition/identity on types, rather than hacks using newtype...
09:04:08 <hpc> martin3z: stick to stuff that uses base or other pure-haskell code
09:04:26 <t7> good luck drawing anything to screen
09:04:32 <hpc> or libraries that use C code that works on both OSs
09:04:38 <hpc> @hackage base
09:04:39 <lambdabot> http://hackage.haskell.org/package/base
09:04:43 <hpc> (comes with ghc)
09:04:58 <hpc> and i gotta do other things now, later
09:05:02 <edwardk> merijn: there may be levels of survival you could be willing to accept
09:05:10 <edwardk> merijn: that would let you survive without overlap
09:05:25 <edwardk> merijn: do you _need_ m to be polymorphic? or are you only instantiating it for a few types?
09:06:18 <t7> to anyone who uses haskell at work; doy ou get sick of it?
09:06:26 <merijn> edwardk: I'd prefer it to work for arbitrary m's that are monads, but in practice I will probably only need a handful of monads
09:06:38 <edwardk> t7: i do use it at work, i don't get sick of it
09:07:27 <merijn> edwardk: In reality I could probably do it the ugly way without this function. But out of sheer stubbornness I've made it a personal type hacking quest to try and get it to work :p
09:07:48 <edwardk> merijn: i have two similar examples i can think of
09:08:08 <edwardk> I use 'vgrad' in my 'ad' package using a similar scheme
09:08:37 <edwardk> so you can say vgrad (*)     and get a function from Num a => a -> a -> [a]
09:08:45 <edwardk> since (*) wants two arguments
09:09:19 <merijn> edwardk: Thanks, I'll take a peak at the sources of that (and bug you if I get confused! :p)
09:09:19 <edwardk> and there is the considerably more complicated fun in https://github.com/ekmett/grid/blob/master/Grid/Exp.hs
09:10:42 <edwardk> both of them rely on the fact that ultimately i'm doing case analysis on types, matching on either an 'AD'/'Exp'-like constructor or an '(->) b' constructor
09:10:47 <shapr> preflex: seens dons
09:10:50 <shapr> preflex: seen dons
09:10:51 <preflex>  dons was last seen on #haskell 90 days, 21 hours, 56 minutes and 50 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
09:10:59 <shapr> bah 90 days
09:11:15 <edwardk> i swear those tweeted pictures are a cry for help
09:13:41 <merijn> edwardk: :D
09:14:14 <edwardk> merijn: Fun is the most complicated identity function I've ever had to write ;)
09:15:00 <merijn> GitHub needs a search function for repo's...
09:15:13 <edwardk> (it provides 'observable application', rather than just 'observable sharing')
09:15:14 <merijn> (Inside the repo, I mean. Not for finding repo's)
09:15:39 <edwardk> what are you looking for?
09:16:37 <edwardk> that package is mostly that module and https://github.com/ekmett/grid/blob/master/Grid/Symantics.hs
09:16:38 <merijn> Where vgrad is inside ad, but I just found it :)
09:16:42 <edwardk> ah
09:16:52 <edwardk> Numeric.AD.Internal.Reverse
09:17:08 <edwardk> there is a vgrads in Numeric.AD.Internal.Sparse as well
09:17:57 <edwardk> that one returns a cofree comonad of all of the tower of partial derivatives of the function rather than just one level
09:18:17 <navaati> is there something like cofunctor ?
09:18:31 <edwardk> navaati: See the contravariant package
09:18:38 <edwardk> http://hackage.haskell.org/package/contravariant
09:18:56 <edwardk> technically a 'cofunctor' is a functor, but there exist contravariant functors
09:19:05 <navaati> (because it's easier to understand monads when you have understood functors, so… maybe it works the same for comonads)
09:19:21 <edwardk> nah, both comonads and monads are covariant
09:19:35 <edwardk> so contravariant functors have nothing to do with comonads
09:19:45 <edwardk> navaati: one sec. i have some slides that talk to this point
09:19:53 <kallisti> a "cofunctor" in this sense is just a functor right?
09:19:58 <edwardk> http://comonad.com/haskell/Comonads_1.pdf
09:20:04 <navaati> ok, so they both build on top of regular functors… easier
09:20:08 <rwbarton> cofunctor is an old-fashioned word for contravariant functor
09:20:24 <edwardk> rwbarton: yes, but it was bad terminology even then ;)
09:20:29 <rwbarton> indeed
09:21:40 <edwardk> rwbarton: so i tend to show people that if you reverse the arrows in (a -> b) |--> (f a -> f b)  you get (b -> a) |--> (f b -> f a)   -- which is alpha equivalent to where you started, to try to wean them off of cofunctor ;)
09:22:51 <edwardk> navaati: those slides should go through the derivation of the comonad class, and why cofunctor = functor fairly slowly.
09:23:20 <edwardk> (the reason for the title was the author of "All About Monads" was in the audience that day)
09:23:26 <navaati> edwardk: ah, great slides, i did not understand the link beteen category and functors before, now i do ! just one question though : the class Functor in haskell only describes functors on Hask, right ?
09:23:45 <edwardk> navaati: yeah, they are endofunctors on the category of haskell types
09:24:42 <navaati> so endofunctor = functor from C to C, and class Functor = functor from Hask to Hask… yeah, makes sense
09:25:18 <navaati> iirc there are rfunctors that are functors on subset of Hask, eh ?
09:26:48 <edwardk> navaati: more or less, the whole restricted functor thing is a bit of a mess at present
09:28:14 <edwardk> navaati: you might want to look at the 'categories' package, which has more refinements of the category class
09:28:25 * hackagebot factory 0.2.0.3 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.3 (AlistairWard)
09:28:31 <edwardk> and the categorical functor, etc mentioned in those slides
09:31:29 <navaati> contravariant == ¬ covariant ?
09:34:03 <edwardk> covariant: (a -> b) -> f a -> f b    contravariant :: (a -> b) -> f b -> f a
09:34:41 <navaati> *nod*
09:35:07 <navaati> hahaha, i was just thinking "arg, fundeps", and then on the next slide : "As an aside if you prefer type families..."
09:35:18 <edwardk> newtype Prop a = Prop (a -> Bool) would be contravariant
09:36:08 <mcstar> cabal: cannot configure scion-browser-0.2.8. It requires ghc >=7
09:36:14 <mcstar> but i have ghc 7.4.1
09:36:48 <navaati> ah ! if you do "Prop a r = Prop (a -> r)", you get the comonad version of the reader monad ?
09:36:57 <edwardk> navaati: nope
09:37:14 <edwardk> the comonadic version of the reader monad is (,) e
09:37:22 <edwardk> extract :: (e, a) -> a
09:37:35 <edwardk> extend :: ((e, a) -> b) -> (e, a) -> (e,b)
09:37:36 <navaati> isn't this the writer monad ?
09:37:59 <edwardk> it is, but its the 'coreader' comonad called the environment comonad in comonad-transformers
09:38:22 <edwardk> it supports an 'ask' operation that gets the 'e' out
09:38:34 <navaati> aaaah, i see
09:39:13 <edwardk> ask :: (e, a) -> e is a cokleisli arrow
09:40:29 <edwardk> i provide a construction on my blog that explains the connection in more detail, and how to derive the monad from the comonad.
09:40:52 <rasfar> let _ = config :: Config (Complex Double)  -- actually works in a do to constrain the type!
09:41:14 <kallisti> edwardk: are there any cellular automaton libraries on Hackage that already use comonads?
09:41:20 <kallisti> it seems almost trivial.
09:41:20 <rasfar> (saves me worrying about which statement to sully with the type sig)
09:41:32 <edwardk> kallisti: i have a couple of toy examples, lets see if one is bundled on hackage
09:41:55 <kallisti> rasfar: you can annotate literally any expression with a type.
09:42:01 <kallisti> with ScopedTypeVariables you can annotate patterns.
09:42:13 <edwardk> i don't have one that is explicitly for cellular automata, i do have a http://hackage.haskell.org/packages/archive/comonad-extras/2.1/doc/html/Control-Comonad-Store-Zipper.html
09:42:19 <navaati> the true question is : what about a comonad syntax :-°
09:42:24 <edwardk> which allows you to walk around in any traversable
09:42:37 <edwardk> navaati: you can define a 'codo' sugar
09:42:45 <edwardk> navaati: but its not in any haskell compiler ;)
09:42:45 <rasfar> yeah, and the fact that the let may come late in the do sequence doesn't upset the unification at all
09:42:52 <edwardk> navaati: its less useful though
09:43:02 <rasfar> i've used ScopedTypeVariables recently iirc
09:43:04 <kallisti> rasfar: I'm not sure why that would matter.
09:43:22 <rasfar> well, it obviously wouldn't; but for values it does of course
09:43:26 * hackagebot regexdot 0.11.0.1 - A polymorphic, POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexdot-0.11.0.1 (AlistairWard)
09:43:28 <edwardk> fib = 1 `fby` 1 `fby` codo a :< b :< _ <- fib; a + b
09:43:47 <edwardk> syntactically its the same sugar as do, just the types change
09:44:11 <kallisti> rasfar: "when" values are sequenced has nothing to do with how their types unify.
09:44:16 <edwardk> navaati: but notice that when you pattern match you wind up needing to look at a lot of structure
09:44:30 <rasfar> it's just nice to be able to do it in a vacuous let, since otherwise i have to make an arbitrary decision about which expression in particular to annotate
09:44:34 <edwardk> which means it really really wants some kind of (co)monadic case expression that is less horrible to use
09:44:42 <rasfar> kallisti, okay i realise that
09:45:00 <rwbarton> fby?
09:45:20 <kallisti> then I'm not sure what you were surprised by.
09:45:21 <edwardk> rwbarton: followed by, common example from dataflow programming languages like lucid
09:45:29 <rasfar> nothing, let it go!
09:45:44 <rwbarton> oh, the cofree comonad constructor...?
09:46:18 <rasfar> i'm surprised a bit that "let _ = ..." worked actually, since it's hard to think of what it could be good for -- except what i used it for.
09:46:22 <ciaranm> i looked at that and tried to work out what a "nstructor" is so i could dualise it
09:46:43 <kallisti> rasfar: you probably don't want that.
09:46:51 <kallisti> and you're still selecting an "arbitrary" expression to annotate
09:46:57 <kallisti> it's just seperated from everything else.
09:47:05 <kallisti> and isn't used.
09:47:05 <rasfar> i disagree
09:47:18 <kallisti> it would be more constructive to define an actual variable with a type
09:47:22 <kallisti> and then use the variable in the expression
09:47:26 <rasfar> it is used, precisely to constraint the type; so it is not arbitrary anymore
09:47:26 <edwardk> @hpaste
09:47:26 <lambdabot> Haskell pastebin: http://hpaste.org/
09:47:42 <hpaste_> edwardk pasted “tiny dataflow programming example with comonads” at http://hpaste.org/67050
09:47:51 <edwardk> rwbarton: that should have fby in it
09:48:02 <rasfar> there are a lot of variables to choose from otherwise
09:48:31 <kallisti> as opposed to a binding to _, where there are still equally many values to choose from.
09:48:31 <tsou> edwardk: dataflow as in lucid..?!
09:48:32 <rasfar> and they occur in multiple places, sometimes lexically inconvenient places
09:48:56 <edwardk> tsou: http://en.wikipedia.org/wiki/Lucid_(programming_language)
09:49:30 <rasfar> true, i still have to choose which variable to constrain; but at least i get to choose where to do it, and in a nice clean way instead of a type blob in an expression
09:49:37 <tsou> edwardk: i know lucid, i meant when you say 'dataflow programming' do you mean the same thing or just a coincidence?
09:49:37 <edwardk> tsou: Tarmo Uustalu and Varmo Vene showed that you can provide nice semantics for dataflow programming languages using comonads
09:49:45 <edwardk> tsou: http://cs.ioc.ee/~tarmo/papers/essence.pdf
09:49:46 <kallisti> rasfar: what I'm saying is... why not give a value a name?
09:49:51 <edwardk> tsou: same thing
09:49:52 <tsou> edwardk: thanks for that link
09:49:56 <kallisti> rasfar: break part of the expression away, give it a name, give it a type.
09:50:00 <rasfar> what value? the underscore?
09:50:01 <kallisti> instead of this ugly _ = ... thing
09:50:06 <edwardk> tsou: mind you, their approach in the end of that paper is a bad idea
09:50:17 <kallisti> rasfar: any value
09:50:22 <kallisti> that needs the annotation
09:50:33 <rasfar> the value is named, let _ = **config** :: ...
09:50:33 <edwardk> tsou: i keep meaning to write up a 'real essence of data flow programming' post describing how to fix the horrible time and space leaks their representation has
09:50:53 <kallisti> rasfar: nevermind. you're clearly not listening.
09:50:56 * kallisti does something else with his time.
09:50:59 <edwardk> tsou: but overall it was a great way to introduce people to comonadic semantics
09:51:08 <rasfar> kallisti i'm listening well enough, you are being beligerent
09:51:27 <edwardk> rasfar: when do you make config?
09:51:42 <edwardk> rasfar: do config <- … ?
09:51:54 <rasfar> i make it once at the top of my Main, but it gets modified at various points with selectors
09:52:12 <edwardk> rasfar: you can do (config :: Config (Complex Double)) <- whatever then
09:52:19 <rasfar> i didn't mean to put a bee in anyone's bonnet, geeze
09:52:23 <edwardk> rasfar: that bypasses the need for the let constraint
09:52:38 <kallisti> @let e = 2
09:52:39 <lambdabot>  Defined.
09:52:43 <kallisti> > let e :: Int in e
09:52:43 <lambdabot>   The type signature for `e' lacks an accompanying binding
09:52:44 <lambdabot>    (The type signa...
09:52:49 <edwardk> i think the main reason why so many people are worried for you is if you floated than out of your main that feature would stop working
09:52:51 * kallisti was wondering if that would work or not. :P
09:52:55 <edwardk> er floated that
09:53:02 <kallisti> but it's treating the e as a new binding
09:53:07 <kallisti> rather than the one it's actually shadowing.
09:53:12 <rasfar> edwardk, yeah -- i was celebrating the fact that i didn't have to choose *where* to put the type annotation, i could introduce it wherever was convenient with the "let _ =".  maybe that's not a nice thing to do it seems.
09:53:40 <kallisti> it's pointless
09:53:46 <rasfar> as well as making the other expressions that really do something less ugly
09:54:01 <edwardk> *nods*
09:54:07 <rasfar> kallisti, it is not pointless, it is necessary to make the constraint, and i amply described my motivation for doing what i did
09:54:31 <edwardk> rasfar: i think he meant the let e :: Int trick he tried
09:54:39 <rasfar> if it's a bad idea, i don't mind hearing why and if i agree (as i probably will as i respect you more or less), so ...
09:54:48 <kallisti> no I mean there's absolutely no reason to use a _ = ... strictly for a type annotation
09:55:08 <rasfar> i gave reasons already, so "absolutely" is just cant
09:55:21 * edwardk decides he has better things to do.
09:55:23 <rasfar> it may be bad style, but reasons were given!
09:56:30 <rasfar> edwardk, kallisti: i missed that particular thing, it might be better than using let _, although it's longer and just as perfunctory.  thank you both, sorry if i put you off.
09:57:32 <kallisti> :t deriv
09:57:33 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
09:57:45 <rasfar> (actually "let e :: Int in e" would not work as it is not of the right type to be a statement in the do)
09:57:56 <kallisti> rasfar: what I meant
09:58:04 <kallisti> is that you should, when using a let
09:58:10 <kallisti> actually bind names...
09:58:14 <kallisti> and give those names types.
09:58:18 <hayashi> @pl \(x,y) -> x y
09:58:19 <lambdabot> ap fst snd
09:58:20 <kallisti> like, something you actually use.
09:58:27 <kallisti> not just a throwaway equation
09:58:56 <rasfar> kallisti, yes, i mean, anyone could say that.  yet "let _ = " is accepted.  and it turned out to also be useful to me.
09:59:05 <navaati> hayashi: oO great stuff !
09:59:21 <rasfar> it's the most concise way to give my type constraint
09:59:34 <hayashi> Not working atm though >_<
10:00:12 <kallisti> it's obviously not the most concise. but I don't think I can beat any sense into your head.
10:00:52 <rasfar> it is about as concise, because in other places where "config" appears, I would need parentheses (and it would be uglier)
10:01:19 <rasfar> can you offer any explanation why the syntax is accepted in the first place?
10:01:41 <rasfar> (if i'm the only one remotely enjoying this debate, we can drop it)
10:02:39 <kallisti> I'm not really interested anymore, since I can't convince you with words. If you provide the offending function I will show you a better way to write it.
10:02:45 <kallisti> without question.
10:03:17 <rasfar> you're far too smug methinks.  let's drop it, since we're not giving each other any satisfaction.
10:12:51 <Catnaroek> Is there any kind composition operator, just like (.) is a function composition operator?
10:13:42 <kallisti> Catnaroek: what would that mean exactly?
10:14:22 <Catnaroek> kallisti: It means I am toying with @kind.
10:15:16 <navaati> i'm reading about the data kind promotion and i wonder : i can imagine that haskell is still not a full-fledged dependently-typed language, so what remains as a difference between haskell and them ?
10:15:29 <Catnaroek> kallisti: And I wanted to do something like "@kind Maybe ??? Maybe", where "???" a type constructor composition operator.
10:18:14 <hpaste_> twomashi pasted “cabal install transformers base failure” at http://hpaste.org/67051
10:19:04 <twomashi> im getting the above ^ error, throws: "Duplicate instance declarations:       instance Applicative (L.ST s) Defined at src/Control/Monad/Base.hs"
10:19:16 <parcs`> Catnaroek: the kind of 'newtype Compose f g a = Compose (f (g a))' is (* -> *) -> (* -> *) -> * -> * ie it's a type-level 'composition' operator
10:19:50 <parcs`> your example would be @kind Compose Maybe Maybe
10:20:02 <twomashi> any guesses as to why this might be happening? i think i might be getting into a mess wtih ghc6/7/ubuntu/etc package management
10:20:38 <kallisti> navaati: well I think we're restricted in the ways we can pattern match on types.
10:21:12 <kallisti> but I'm not dependent typing expert.
10:21:14 <kallisti> *no
10:21:17 <navaati> kallisti: the "let's pattern match on types" feature is precisely the point of type families, right ?
10:21:19 <Catnaroek> parcs`: Oh. Nice.
10:22:28 <kallisti> navaati: yes
10:22:33 <parcs`> :t Compose
10:22:34 <lambdabot> Not in scope: data constructor `Compose'
10:22:59 <parcs`> :k Data.Functor.Compose
10:23:00 <lambdabot>     Not in scope: type constructor or class `Data.Functor.Compose'
10:23:05 <parcs`> boooo
10:23:32 <dolio> Pattern matching on types isn't a usual feature of dependently typed languages.
10:23:47 <tertl6> how is the VS add on for GHC?
10:23:56 <navaati> dolio: yep, it's what i was thinking atm : even in agda you can't do that
10:26:16 <navaati> ah, i found the difference between ghc haskell and dependently typed languages : in haskell datatypes are lifted to the kind world, but functions are not
10:27:03 <dolio> There's still a stronger divide than exists in real dependently typed languages.
10:27:59 <navaati> and that "we do not allow equality constraints between kinds, nor kind coercions" (from the paper ghp.pdf)
10:28:02 <dolio> Data types may be automatically replicated into data kinds, but you can't parameterize a type by a value of a type, only a value of a kind.
10:28:59 <dolio> You have to establish a connection between the value and type level by construction, and prove things about the value level by that means.
10:35:08 <cwl> What does the symbol `rec` mean in the paper <Why dependent types mater> http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
10:35:23 <rasfar> twomashi, i hear you and i've been looking for something that could help, but unfortunately have nothing to offer
10:35:23 <cwl> let x , y : Nat order x y : Order order x y ⇐ rec x
10:36:21 <cwl> let {x , y : Nat | order x y : Order}  order x y ⇐ rec x
10:37:46 <merijn> For more info see "http://www.kotha.net/ghcguide_ja/latest/equality-constraints.html", wow...that's a useful informational link >.>
10:38:31 <merijn> cwl: Blind guess: It's recursive in x
10:38:36 <twomashi> is it better to install haskell/cabal/etc via operating system or other means?
10:38:41 <rasfar> cwl: looking at Figure 1, order is defined recursively
10:38:42 <twomashi> im getting in a mess with packages
10:39:10 <bgamari> Is there a reason that Data.Sequence doesn't have a delete function?
10:39:39 <merijn> twomashi: The best approach is to install the Haskell Platform and install everything else using cabal
10:40:02 <rasfar> twomashi: i think the best is to install a Haskell Platform, and use its cabal-install for getting any additional packages.  haha, merijn, we're overlapping
10:40:33 <twomashi> merijn: but for example ubuntu provides haskell platform with ghc6, i need ghc7 for some packages so i get it via a PPA, this leaves inconsistencies in the system
10:40:51 <twomashi> then i need base-4.5 but base-4.4 was already provided ...
10:41:00 <fmap_> gentoo-haskell overlay is good enough to use instead of cabal-install
10:41:29 <cwl> merijn: rasfar: Figure 1, merge function, recursive in xs and ys, why write rec xs and rec ys seperately
10:41:34 <merijn> twomashi: I dunno, I always get the latest version from the Haskell Platform site. Ubuntu repo's tend to lag behind quite a bit
10:41:42 <fmap_> but that
10:41:51 <fmap_> 's not about ubuntu :(
10:42:16 <twomashi> you guys use ghc 6 or 7?
10:42:16 <rasfar> twomashi: if you have two versions of haskell tools installed, you may only need to perform cabal-install with the newer version.
10:43:04 <tertl6> where can I get visual haskell?
10:43:18 <rasfar> i use the Platform that comes with GHC version 7.0.4 and that's enough for most of the packages i've tried installing.
10:45:00 <navaati> tertl6: what is this ?
10:45:00 <twomashi> rasfar where did you download that?
10:45:21 <timthelion> When I have a tree structure of data Foo = Foo Int String [Foo] | NoFoo and it's stacked up like (Foo 1 "hi" [(Foo 2 "bye" NoFoo)]) and I want to create a new structure with the seccond Foo's string being different, how can I?
10:45:52 <rwbarton> that's a pretty vague question
10:45:54 <rasfar> twomashi: http://hackage.haskell.org/platform/contents.html or so
10:46:53 <hpaste_> timthelion pasted “My full data type” at http://hpaste.org/67052
10:46:54 <rwbarton> what do you know about the input Foo, how do you decide which string to replace, etc.
10:47:04 <tertl6> navaati for visual studio
10:47:11 <rasfar> timthelion, you have to deconstruct/reconstruct it afaik
10:47:21 <twomashi> GHC and Haskell platform download pages are mutually recursive
10:47:44 <timthelion> rwbarton: see my paste, I managed to make cellPutCell, which relies on being able to place a cell at a point.  But now I want to change the point(move the cell), and so my cellPutCell function doesn't work.
10:48:01 <twomashi> "For most users, we recommend installing the Haskell Platform instead of GHC." - "You need GHC 7.0.4 installed before building the platform"
10:48:13 <rwbarton> > "building" == "installing"
10:48:14 <lambdabot>   False
10:49:14 <timthelion> rwbarton: is that less vague enough?
10:50:44 <rwbarton> yes but it's also 200 more lines of code than I have the time to look at
10:50:58 <timthelion> rwbarton: that's fine
10:51:36 <timthelion> it seems to me, like it's a fairly standard problem.  But I cannot think of an aproach, that works for functional programming
10:51:51 <merijn> timthelion: It'd help if you could construct a minimal example roughly resembling what you want to do and then tell what you want the example to do and what it seems to be doing
10:52:27 <rwbarton> anyways the answer in general if you want to "update" something in a tree-like structure is that you have to make new nodes along the path to that something and share the rest of the tree
10:52:30 <merijn> In general for updating trees you just recurse and construct a new tree from the old one
10:53:03 <rasfar> hence the deconstruct/reconstruct
10:54:18 <rasfar> (it is not as convenient in Haskell as it is in, say, Java, that's for sure)
10:54:30 <merijn> I disagree
10:54:47 <rasfar> i thought maybe someone would ;)
10:54:48 <merijn> It's far easier/less lines than Java code which does the same
10:54:57 <blackdog> anyone remember that method for installing a couple of libs at the same time so cabal knows how to constrain versions?
10:55:01 <merijn> The Java code might be a bit more efficient, but not quite a lot
10:55:06 <blackdog> neither are released on hackage, just got git checkotus.
10:57:12 <rasfar> blackdog, you're not talking about the --constraint option to cabal install, to constrain versions? (could be put in the config i suppose)
10:58:13 <blackdog> rasfar: don't think so. it looks like if i run "cabal install foo/foo.cabal bar/bar.cabal it does the right thing"
10:58:28 * hackagebot hakyll 3.2.7.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.7.2 (JasperVanDerJeugt)
10:59:27 <hpaste_> timthelion annotated “My full data type” with “My full data type (annotation)” at http://hpaste.org/67052#a67054
10:59:56 <rasfar> merijn, what i'm thinking of is, if you already have a pointer/reference to a node you want to mutate, you can do it very easily.  i'm not speaking of tree traversal generally.
11:00:12 <timthelion> That should be a simple enough example
11:01:11 <timthelion> rasfar: that's the problem, is that I've set my thinking to "Lets mutate this" and I cannot for the life of me figure out another way...
11:02:12 <timthelion> Perhaps I need to make it so each Cell has an UUID that I can search for, instead of searching by point...  Or I can pass the old point(since I know the points are unique),,, I guess that's how I should do it.
11:02:45 <timthelion> I should have the cellPutCell function take an originalPoint and a newCell...
11:03:46 <timthelion> merijn: is that simple enough for you?
11:04:32 <hpaste_> merijn annotated “My full data type” with “My full data type (annotation) (annotation)” at http://hpaste.org/67052#a67055
11:04:49 <merijn> timthelion: Not 100% whether I got the indentation of where correct, but you get the idea
11:05:20 <parcs`> blackdog: cabal install path-to-lib1 path-to-lib2
11:05:40 <parcs`> oh
11:05:56 <parcs`> looks like you already figured it out :)
11:06:08 <timthelion> merijn: thanks
11:06:28 <blackdog> parcs`: yeah. it's a bit of a pain, though, at least for dev
11:06:31 <blackdog> looking into cabal-meta
11:06:37 <merijn> timthelion: You can probably write it in some cleaner way depending on context (I don't really like the helper for example...)
11:06:43 <blackdog> (yay, concentric scar tissue :/)
11:07:03 <timthelion> merijn: that's basically the approach I used before,  it doesn't work, if the Diagram has two bubbles with the same string... which is where I got stuck...  So I have to re-write it to use the original point...
11:07:23 <kallisti> mueval-core: GhcException  "You can't call  compileExpr in a profiled  compiler"
11:07:25 <merijn> timthelion: If you have two bubbles with the same string it will update both
11:07:26 <kallisti> what is this about?
11:07:37 <merijn> timthelion: How would you distinguish between both bubbles?
11:07:47 <kallisti> when I try to compile mueval without profiling I get compile errors.
11:09:32 <timthelion> merijn: My diagram looks like this http://imageshack.us/f/94/gridediteditcell.jpg/  I'm moving the cells on the screen.  So I have to have some way.  But points are unique... So I'll have to tell it to "replace the cell with point a with the new cell of point b...
11:10:05 <timthelion> Since the strings are haskell commands, certainly I don't want my program to break if someone uses the same command twice in a program...
11:10:31 * timthelion appologises for using an ad ridden free image hosing service...
11:10:48 <merijn> If your strings are not unique you probably don't want to use them as ID's
11:11:07 <rasfar> timthelion, that's pretty cool
11:11:31 <timthelion> rasfar: It will be open source when I'm done. but right now it doesn't do much...
11:15:19 <rasfar> you might want to look into zippers or lenses for traversal/update
11:18:46 <rasfar> or something mutable; take a peek at http://stackoverflow.com/questions/2233409/haskell-mutable-map-tree
11:20:15 <timthelion> rasfar: I don't really want to use mutable, as right now I'm not in the IO monad for movement...  I mean, I could, but....
11:21:15 <timthelion> luckly I don't need much speed.  This is drag and drop, not mutating every third fold in a large protien...
11:21:25 <rasfar> well, as merijn suggested, adding a field which is guaranteed to uniquely identify a node would help
11:22:13 <rasfar> and you could use a zipper or lens (i think ... i've looked into them, but not used them yet) -- you'd have to write some instance declarations for your datatypes, but after that traversal and update would probably be easier
11:22:55 * timthelion remembers when he was 9 years old and learning to use LOGO, he had a game, and he wanted to create new turtles automagically, but there was no way to name a turtle arbitrarilly.  And he said "daddy, I need to make a turtle without a name" and he said "Tim, you need pointers!"
11:23:29 <rasfar> aw, sweet memory!
11:23:41 <rasfar> i gotta split; bye for now
11:25:17 <timthelion> Perhaps I was a few years older than that, probably 12...
11:25:32 <merijn> timthelion: Why do oy need pointers for that? >.>
11:26:01 <merijn> You could just have an incrementing counter and name them "turtle0", "turtle1", etc
11:27:06 <timthelion> merijn: that would have worked too.  But in logo, you have to write turtle1.goforward,,, there is no way to do "turtle1".goforward.
11:28:29 * hackagebot postgresql-libpq 0.7.2 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.7.2 (LeonSmith)
11:28:31 <ment> i remember when my father used to get drunk and beat me with k&r's c language
11:28:54 <blackdog> ment: jesus. lucky it's a slim volume.
11:30:05 <c_wraith> was there ever a hardcover edition?
11:30:54 <geekosaur> yes
11:31:03 <geekosaur> it was a very slim hardcover :)
11:31:06 <timthelion> How does the rule of thumb come in to that?  All text books used for beating wives and children must be thiner than your thumb?  Or is it outright wrong, since they are almost certainly wider?
11:33:30 * hackagebot live-sequencer 0.0.3 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0.3 (HenningThielemann)
11:40:13 <ajg> hi. anyone know a way to have all of a module's type constructors derive a set of classes automatically -- maybe using TH?
11:47:42 <kallisti> is there anything like a "changeset" structure on Hackage?
11:48:06 <kallisti> essentially a set that stores a sequence of operations to be applied to another set
11:53:12 <hpc> kallisti: what operations would you want on the sequence?
11:53:34 <hpc> there's Cont, which gives you "everything after the current operation" as a single function
11:55:21 <kallisti> hm
11:55:39 <kallisti> and that would be general to any structure, yes?
11:55:54 <hpc> @unmtl Cont r a
11:55:54 <lambdabot> (a -> r) -> r
11:56:13 <hpc> yes
11:56:21 <hpc> :t runCont id
11:56:23 <lambdabot>     Couldn't match expected type `Cont r a'
11:56:23 <lambdabot>            against inferred type `a1 -> a1'
11:56:23 <lambdabot>     In the first argument of `runCont', namely `id'
11:56:25 <hpc> er
11:56:30 <hpc> :t \act -> runCont act id
11:56:31 <lambdabot> forall a. Cont a a -> a
11:56:39 <hpc> :t \act -> runContT act return
11:56:40 <lambdabot> forall r (m :: * -> *). (Monad m) => ContT r m r -> m r
11:56:42 * kallisti was thinking about transactional operations on data structures in pure code.
11:57:10 <c_wraith> With any persistent structure, you kind of get that for free
11:57:31 <kallisti> hm, right
11:57:31 <c_wraith> Assuming the structure is efficient (doesn't copy a lot between versions), anyway
11:57:57 <hpc> kallisti: if you want to detect that a transaction fails and try something else, there's the Maybe monad/alternative
11:58:02 <kallisti> yeah
11:58:03 <hpc> @src Maybe (<|>)
11:58:03 <lambdabot> Nothing <|> p = p
11:58:03 <lambdabot> Just x  <|> _ = Just x
11:58:06 <kallisti> that's probably what I want.
11:58:23 <kallisti> I was thinking of the case of an IRC bot. You dispatch to some function, which has access to state structures.
11:58:44 <kallisti> if the function changes the structure, you'd want to update some persistent store (perhaps a database)
11:58:58 <kallisti> but otherwise you wouldn't want to do anything at all.
11:59:16 <hpc> i did that with (StateT BotState IO), myself
11:59:50 <hpc> and just wrote things at the right level of abstraction and lifted where needed
12:00:06 <MHD0> The pure-fft is a really poor package
12:00:45 <diPython> hello all, i need to extract the layout of a llvm bytecode file using the binding library llvm. does anyone worked with the library and did a similar task?
12:00:50 <tgeeky_> sure, insult other people's packages!
12:01:20 <MHD0> tgeeky_: When I can make several improvements to the code in about 20 minutes?
12:01:21 <hpc> it looks simple enough
12:01:54 <tgeeky_> MHD0: make improvments, add your name, replace package!
12:02:06 <tgeeky_> MHD0: but I was just being goofy.
12:02:16 <MHD0> heh
12:02:24 <tgeeky_> there are tons of crumby packages on hackage, mine included
12:02:38 <hpc> i think the worst i can say about it is the indentation is kind of odd in places
12:02:48 <hpc> with the insistence on < 80 chars, no matter the cost
12:03:20 <hpc> but it's one short module and does exactly what it says on the tin, with reasonable asymptotic complexity
12:04:13 <MHD0> well, for one, it uses exp instead of cis
12:04:36 <MHD0> exp (... * i) is a lot slower than cis (...)
12:04:37 <merijn> If I have "istance Foo (x -> y) (x -> z)"then x is the same for both, yes?
12:04:49 <parcs`> yes
12:05:20 <MHD0> and the fft function errors out for single element lists
12:06:09 <MHD0> and it defaults to the dft on list lengths of two, instead of using the ludicrously simple formula for it directly
12:06:13 <MHD0> etc.
12:06:31 <tgeeky_> MHD0: seriously. make patches, and update the project in your own name
12:07:02 <MHD0> I don't actually know how to operate Cabal and other stuff
12:07:16 <MHD0> Got any tutorials?
12:07:42 <tgeeky_> MHD0: when you have the package like you want it, cabal sdist -> upload to test. if it works, upload to update
12:08:59 <hayashi> What's the most Haskell-y way of ensuring that a list in a constructor is at least one item long?  Currently I've got the rather ugly workaround of having the head and tail of the list as separate items, and the only other way my limited Haskell knowledge knows about wrt doing it at type level is making new constructors to represent an item or a combination of an item and a recursion
12:09:58 <tgeeky_> hayashi: http://hackage.haskell.org/package/NonEmpty
12:10:13 <hayashi> I'd do the latter but then it's not really a list anymore, so I'd lose all the flexibility of using standard Haskell lists (whereas with the other I can just cons head back onto tail)
12:10:16 * hayashi investigates
12:10:41 <tgeeky_> I think there are several more implementations
12:10:54 <tgeeky_> i just didn't find them first when googling "haskell non-empty list"
12:11:03 <parcs`> hayashi: it's kinda inconvenient to do this in haskell
12:11:21 <parcs`> so i suggest you pretend that the list always has at least 1 item
12:11:22 <hpaste_> merijn pasted “Type hackery” at http://hpaste.org/67058
12:11:39 <merijn> I'm not sure I understand the type error I get in that paste
12:12:27 <hayashi> NonEmptyList seems like a better package
12:13:13 <hayashi> but thanks tgeeky_
12:14:28 <parcs`> merijn: b is not mentioned in the signature of foo, so ghc doesn't know which instance of foo to use. it looks like you need functional dependencies
12:14:29 <hayashi> The main reason I wanted to do it at the type level was, more important aspect of safety notwithstanding, so (being lazy) I didn't have to do anything special to make QuickCheck not start testing empty lists and screeching madly =P
12:14:36 <hpc> merijn: foo t x y = foo (t y) x y?
12:14:37 <hayashi> I'll give a nonempty package a whirl
12:14:43 <hpc> or foo (t y) x, perhaps
12:14:43 <geekosaur> merijn, foo's type doesn't constrain b at all; you constrain it in individual instances but that doesn;t allow it to typecheck
12:15:42 <parcs`> :t (==>)
12:15:43 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
12:15:53 <merijn> hpc: No, because "foo t x" gets x out of the monad and stuffs it in t, y is just the remaining arguments
12:16:36 <parcs`> @check \xs -> length xs /= 0 ==> head xs * 0 == 0
12:16:37 <lambdabot>   Not in scope: `==>'Precedence parsing error
12:16:37 <lambdabot>      cannot mix `GHC.Classes./=...
12:16:47 <parcs`> @check \xs -> (length xs /= 0) ==> head xs * 0 == 0
12:16:48 <lambdabot>   Not in scope: `==>'
12:16:51 <parcs`> :(
12:16:55 <merijn> parcs`: So I put a fundep that says that b is uniquely determined by f, I guess?
12:17:02 <hpc> parcs`: what's (==>)?
12:17:24 <parcs`> hpc: implies
12:17:39 <parcs`> True ==> x = x; False ==> x = True
12:17:59 <hpc> @check let True ==> x = x; False ==> x = True in \xs -> length xs /= 0 ==> head xs * 0 == 0
12:18:00 <lambdabot>   Precedence parsing error
12:18:00 <lambdabot>      cannot mix `GHC.Classes./=' [infix 4] and `GH...
12:18:10 <hpc> @check let True ==> x = x; False ==> x = True in \xs -> (length xs /= 0) ==> head xs * 0 == 0
12:18:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
12:18:11 <lambdabot>    arising from the literal `0'...
12:18:24 <hpc> @check let True ==> x = x; False ==> x = True in \xs -> (length xs /= 0) ==> (head xs * 0 == 0)
12:18:26 <lambdabot>   "OK, passed 500 tests."
12:18:39 <parcs`> merijn: i'm not sure
12:19:03 <hayashi> The fun thing being that NonEmptyList is exactly what I'm doing in the type constructor already, just abstracted nicely.
12:19:29 <merijn> parcs`: I don't really care about a and b anyway, but without them I can't constrain f and g in the first instance to be m a and m b
12:19:41 <tgeeky_> hayashi: you're half welcome.
12:19:58 <tgeeky_> hayashi: you and the author of said package deserve the other half :O
12:20:03 <parcs`> merijn: yeah, that seems like a good idea
12:21:33 <hayashi> tgeeky_: it's fine, I'm lazy for not hoogling "non empty list" in the first place
12:22:13 <merijn> Which I need to do because I can't specify type level identity/compose, otherwise I could define foo as "(a -> f (m b)) -> m a -> g (m a)" and define the first instance as "(Monad m) => Hack m Id Id"and the second as ("Hack m f g) => Hack m (c -> f) (c -> g)"
12:22:20 <hayashi> Probably why I like haskell -- both myself and haskell evaluate lazily.
12:22:24 <merijn> Well, I'll just add a fundep and see if GHC magically swallows it :p
12:22:40 <hayashi> I'll do stuff, but only begrudgingly if I really really have to or want to
12:23:46 <merijn> Bah, "Coverage Condition fails for one of the functional dependencies"
12:27:04 <merijn> I think I will need to await the advice of experts to solve this one >.>
12:28:04 <merijn> Because I don't think it's possible to sensibly annotate the second instance :\
12:28:10 <wli> There are infix constructors, no?
12:28:28 <merijn> Yes, prefix with colon
12:28:31 * hackagebot live-sequencer 0.0.3.1 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0.3.1 (HenningThielemann)
12:28:58 <wli> The guy should be happy, then.
12:29:41 <wli> I've still not gained an intuitive understanding of GADT's.
12:30:00 <tgeeky_> wli: oh, that's becuase A stands for anti-intuitive!
12:30:04 <wli> Took a while to build that up for monads, too.
12:36:37 <wo0kie> wow monads are pretty sweet
12:38:26 <MHD0> woOkie: Yes they are
12:38:35 <MHD0> wo0kie: ^
12:38:44 <sipa> it depends a bit, some are rather salty
12:38:53 <wo0kie> I'm new to haskell and learning about monads
12:38:57 <wo0kie> mostly from here: http://ertes.de/articles/monads.html
12:38:57 <sipa> and the List monad can have several tastes at once
12:39:26 <wo0kie> at a high level, monads allow generalization of function implementations?
12:39:32 <wo0kie> does that sound correct?
12:41:26 <MHD0> monads allow you to specify what assignment and statement separation means
12:41:39 <MHD0> if you compare it to say, C
12:41:54 <nomeata> I find this error message confusing. Can someone enlighten me:
12:41:58 <nomeata>     The lambda expression `\ patch_ps -> ...' has one argument,
12:42:00 <nomeata>     but its type `forall x. a0 x -> c0' has none
12:42:57 <tgeeky_> nomeata: monomorphism restriction? (guessing?)
12:43:37 <nomeata> tgeeky_: it is not in ghci, so I don’t think so. anyways, I found a work around already :-)
12:44:34 <TheLemonMan> when i call lenght over a lazy bytestring am i shooting myself in the foot ?
12:44:59 <tgeeky_> nomeata: I never thought of that restriction as being a ghci-related thing? Should I?
12:46:14 <nomeata> ah, I might be confusing it with defaulting. And you might be right..
12:49:04 <tgeeky_> nomeata: please, let me know. It happens so rarely these days.
12:49:08 <parcs`> TheLemonMan: probably
12:49:17 <parcs`> you may as well just use a strict bytestring
12:50:39 <nomeata> tgeeky_: no, same error with {-# LANGUAGE NoMonomorphismRestriction #-}
12:53:31 * hackagebot sentry 0.1.0 - Process monitoring tool written and configured in Haskell  http://hackage.haskell.org/package/sentry-0.1.0 (VoMinhThu)
12:55:15 <merijn> What does "Type indexes must match class instance head" mean?
12:56:13 <Ptival> are you defining a method with a type that does not match its instance expected type?
12:56:54 <merijn> I don't think so? I have no clue, I barely understand what I'm writing :p
12:57:15 <Ptival> haha
12:57:41 <Ptival> does the error message come with a line maybe? :)
12:57:44 <rwbarton> that means you had something like   class A t where type Foo t; instance A X where type Foo Y = Int
12:58:17 <merijn> I was trying to use typeclass specific type declarations to find an alternative implementation of the typeclass I wanted, as I don't know how to fix the previous attempt and no one online seemed to know either
12:58:55 <hpaste_> merijn pasted “Type index error” at http://hpaste.org/67059
12:59:00 <merijn> That's what I had
12:59:43 <Ptival> f -> () ?
12:59:57 <Ptival> line 6
13:00:26 <Ptival> I mean s/f/()/
13:00:37 <merijn> I was trying to have a base type for f, I figured that was the simplest
13:00:46 <Ptival> shouldn't have used "->" in a FP channel :D
13:01:18 <merijn> Hmmm, I think I'm misunderstanding how type works...
13:03:05 <rwbarton> it's sort of odd the way you have f appear only as an argument to F
13:03:22 <rwbarton> in fact that means your type class is unusable
13:03:31 * hackagebot ipatch 0.1.1 - interactive patch editor  http://hackage.haskell.org/package/ipatch-0.1.1 (JoachimBreitner)
13:03:42 <merijn> rwbarton: It's half a class as I was still trying to work things out
13:05:21 <merijn> rwbarton: What I had originally was http://hpaste.org/67058 but I can't figure out how to fix the ambiguous type variable there. So I'm trying to see if I can somehow find another implementation via type or something
13:06:21 <rwbarton> uh... what is b for
13:06:49 <rwbarton> I don't have to read past line 4 to know this won't work
13:06:54 <qnikst> hello, where can I find best proctices of using TH, I want to write smth like let k = f (t+c*h) (y+h * (sum . (uncurry (+)) . zip ks as)..)
13:07:08 <merijn_> m b is the return value of the input t (which gets discarded, but still needs to be run)
13:07:22 <qnikst> but if I'm using raw types it becase hell
13:07:23 <qnikst> =)
13:07:39 <merijn_> rwbarton: Line 6 restricts f to be "m b"
13:07:46 <rwbarton> line 6 is irrelevant
13:07:59 <rwbarton> imagine you use 'foo' somewhere in your program
13:08:15 <rwbarton> let's say the compiler knows foo has some specific type (A -> F) -> M A -> G
13:08:28 <rwbarton> how can it ever know what instance of Hack to use
13:09:01 <rwbarton> it cannot ever know, because the choice of 'b' is free
13:09:57 <rwbarton> can't you just delete the variable b?
13:10:48 <merijn_> rwbarton: b probably, but I need to specify that whatever is returned is inside m
13:11:15 <rwbarton> line 6 becomes instance (Monad m) => Hack a m (m b) (m a) where
13:14:54 <merijn_> rwbarton: Hmm, that seems to compile :)
13:15:01 <merijn_> Not sure why that didn't occur to me...
13:17:25 <davidecruger> hi all
13:18:24 <merijn_> rwbarton: No wait, that doesn't seem to do what I want...
13:20:01 <merijn_> ":t foo (undefined :: a -> b -> m c)" infers "foo (undefined :: a -> b -> m c) :: Hack a m (b -> m1 c) g => m a -> g" rather than "Hack a m (b -> m c) (b -> m a) => m a -> b -> m a"
13:24:44 <merijn_> Or, more concrete "foo return ['c']" says "No instance for (Hack Char [] (m0 Char) g0)", which should be impossible as m0 should always infer to be [] and g0 should always infer to be [Char] in this context
13:24:50 <rwbarton> can you paste the current code
13:25:51 <jeff_s_> #ghc
13:25:56 <hpaste_> merijn annotated “Type hackery” with “Type hackery (annotation)” at http://hpaste.org/67058#a67060
13:27:39 <merijn_> Hmm, the second implementation is probably wrong, now that I look at it again...
13:27:55 <rwbarton> yes
13:28:41 <merijn_> But that's a different problem, as the simple case doesn't work either atm
13:29:18 <kallisti> if a chess AI algorithm with no stochastic behavior plays a game against itself
13:29:29 <kallisti> will it always draw?
13:29:35 <kallisti> I guess since white has an advantage it might not
13:30:01 <ment> no
13:30:59 <ment> imagine an algorithm that just jumps around with knight if he's white and plays normally if he's black
13:32:02 <merijn_> I guess the implementation I actually want is "foo t x = \y -> foo (\z -> t z y) x"
13:32:24 <rwbarton> your "foo return ['c']" example should work if you annotate the return type
13:32:45 <rwbarton> currently it has no other way to determine g
13:33:27 <merijn_> "foo return ['c'] :: Char" complains "No instance for (Hack Char [] (m0 Char) Char)"
13:34:05 <merijn_> Which is odd, since the base case instance should fix that value of m, no?
13:34:25 <merijn_> oh, wait
13:34:45 <merijn_> I guess the return type should be [Char], but then it still does not work
13:35:57 <rwbarton> oh, right, you also have to annotate return
13:37:25 <merijn_> Ah, yes. This returns, but also renders the entire typeclass completely useless with the amount of annotation it needs... "foo (return :: Char -> [Char])  ['c'] :: [Char]"
13:38:47 <henry622> hello :)
13:38:53 <henry622> why do i get this error? http://ideone.com/xvPd7
13:40:42 <Jacco> 67 is not a [Int] ?
13:40:46 <merijn_> henry622: First argument of compute is a list, but 67 is not a list
13:41:17 <henry622> sorry guys for this
13:41:35 <merijn_> henry622: btw, "print = putStrLn . show", so you can write "print (compute [67] 34)"
13:41:38 <henry622> i dont want to learn haskell. i just need to understand a code extract to use it in C
13:41:53 <merijn_> (Or even "print $ compute [67] 34")
13:42:09 <hayashi> Is there a generic way of, given a set of constructors that accept one variable, returning that variable if an input was constructed by a member of that set"?
13:42:13 <hayashi> *-"
13:42:19 <merijn_> henry622: Are you familiar with python?
13:42:40 <merijn_> henry622: If yes, maybe this is helpful if you only want to read haskell: http://blog.ezyang.com/2011/11/how-to-read-haskell/
13:43:08 <henry622> thanks merijn_
13:43:23 <henry622> no not familiar with python
13:44:24 <henry622> the code is not long. maybe someone here to sacrifice 5 mins for telling me the little algorithm? =)
13:45:34 <henry622> if not i'll read :D
13:47:31 <monochrom> where is the code?
13:49:27 <monochrom> if you refer to "compute = mod . sum", it takes a list parameter (call it xs) and a number (call it m). it sums up xs, then do mod m. compute [2,5,1] 10 = (2+5+1) `mod` 10
13:49:38 <merijn_> oh well, I'll postpone this typeclass implementation until I can bug edwardk again, he seemed to have an idea how to make it work...
13:50:17 <monochrom> and "compute 67 34" is nonsense, i.e., type error
13:51:35 <monochrom> (it may be not so clearly nonsense for people coming from perl or php, in retrospect)
13:52:27 <henry622> thanks
13:52:31 <henry622> now i understand it ;)
13:57:47 <henry622> ok i just post the whole code =)
13:57:59 <henry622> too hard to understand it on my own
13:58:34 <henry622> http://ideone.com/KIcW3
13:58:57 <henry622> i "just" don't understnad line 9 and line 12
13:59:10 <henry622> dunno why compiling fails
14:00:53 <copumpkin> how can I tell cabal to run a configure build for me?
14:01:05 <copumpkin> I know there's build-type: Configure but I also have a Custom Setup.hs
14:03:43 <copumpkin> looks like it's in the autoconfUserHooks but it assumes the configure script is in the root, which would make things quite ugly for me. dcoutts: is there some way to override that?
14:05:19 <rasfar> henry662, as for compilation failing, you need all of lines 9--13 to be indented 4 spaces less; layout is part of syntax in Haskell.
14:06:07 <henry622> @rasfar thanks
14:06:07 <lambdabot> Unknown command, try @list
14:06:33 <rasfar> in fact, this is probably due to use of tabs.  you might be better off using spaces only for the moment.
14:06:55 <merijn_> s/for the moment.//
14:06:56 <thoughtpolice_> copumpkin: worst case scenario, write a dummy shell script that just cd's to the right path and invokes ./configure and make or whatever
14:07:07 <thoughtpolice_> that's what i ended up doing for salt since it has to build an out-of-band library first
14:07:08 <henry622> btw. nice people in this chat =)
14:07:18 <rasfar> line 9 (ignoring whatever sp does for the moment) is just parsing strings into integers
14:07:38 <henry622> sp: split a string into i parts n times
14:08:14 <rasfar> well, yeah.  and line 12 is similar to line 9 of course
14:08:29 <copumpkin> thoughtpolice_: hmm
14:08:56 <henry622> yeah
14:09:00 <rasfar> randomRIO produces random numbers within the indicated range (including endpoints)
14:09:19 <henry622> yeah that a thing i already knew :D hehe
14:09:27 <henry622> *s
14:09:39 <rasfar> can you pinpoint anything that's still troubling you?
14:10:05 <thoughtpolice_> copumpkin: yeah, i ended up having ./configure do a build of nacl, copying the library/header files to somewhere under $HOME (in ~/.haskell.salt for me) and then configure spits out a pkg.buildinfo file that contains extra-library-dirs/include-dirs directives
14:10:10 <henry622> what is exactly done in the sp function?
14:10:19 <copumpkin> thoughtpolice_: eww :P
14:10:33 <thoughtpolice_> copumpkin: yeah, but it's the best solution i had, because this library doesn't exist in package managers :P
14:10:43 <thoughtpolice_> it works remarkably well though, and the logic is pretty simple
14:10:47 <henry622> sp gives an error too
14:10:47 <henry622> prog.hs:21:0: parse error (possibly incorrect indentation)
14:11:16 <rasfar> acc is a standard name for an "accumulator" parameter.  sp is recursive, and builds up its results in acc.  when the recursion finishes, sp returns acc.
14:11:53 <rasfar> sp xs i n acc = sp (drop n xs) (i-1) n (acc ++ [(take n xs)])
14:11:54 <xil> > take 20 $ (\(a:b:_) -> Data.List.union a b) [[p*p,p*p+2*p..] | p <- [3,5]]
14:11:55 <lambdabot>   [9,15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123]
14:11:58 <xil> I am very confused. Can someone help me figure out why the number 25 is missing from that?
14:13:11 <kallisti> copumpkin: I've got some code I might to derive Enum instances from product and sum types of Boundeds and Enums. I was thinking about turning it into a package. And perhaps also including an Enum typeclass that uses Integer instead of Int?
14:13:18 <kallisti> copumpkin: edwardk told me to ask you for ideas about all of that.
14:13:39 <kallisti> -I might
14:13:52 <henry622> yeah. the hardest part will be to understand the recusrive sp function
14:14:24 <|Steve|> @src sp
14:14:24 <lambdabot> Source not found. My pet ferret can type better than you!
14:14:35 <henry622> got an idea why it fails? http://ideone.com/hAZDL
14:14:45 <rasfar> indeed.  [(take n xs)]  is the same as [take n xs]  so might as well get rid of the cruft.
14:15:11 <rasfar> "drop n" and "take n" drop/take the first n elements of a list
14:15:28 <copumpkin> kallisti: did you look at that enumerable package of mine? I intentionally avoided the Enum typeclass altogether because its behavior isn't ever well defined
14:15:32 <rasfar> ++ concatenates lists
14:15:55 <rasfar> from there, i'm certain you can figure out what it does :)
14:15:59 <kallisti> copumpkin: yes I did. But it's not very efficient, though much is gained from the generality.
14:16:26 <kallisti> copumpkin: I was going for efficiency instead. For example, I use it to define Storable instances for my types, so that they can be represented in memory as arrays of Word16s or what have you.
14:16:33 <copumpkin> kallisti: fair enough :) I don't really have many ideas otherwise. I do a lot of stupid stuff in that package (it was one of the first things I wrote)
14:16:47 <henry622> yeah tahnks rasfar :D i ll try ;)
14:17:00 <rasfar> yw
14:17:06 <henry622> but one last question: http://ideone.com/hAZDL why do this fail again?
14:17:09 <henry622> *does
14:17:56 <Cale> henry622: You have what appears to be a comment without -- or {- -} in the middle of the code
14:17:57 <rasfar> b/c line 19 should be in a comment
14:18:09 <xil> my own union function seems to work more reliably than Data.List.union for ascending lists. Wat?
14:18:31 <kallisti> xil: what do you mean by reliably?
14:18:36 <henry622> oh thanks :D
14:19:04 <xil> > take 20 $ (\(a:b:_) -> Data.List.union a b) [[p*p,p*p+2*p..] | p <- [3,5]]
14:19:05 <lambdabot>   [9,15,21,27,33,39,45,51,57,63,69,75,81,87,93,99,105,111,117,123]
14:19:11 <xil> kallisti: 25 should be in that list
14:19:15 <xil> no?
14:19:26 <henry622> failed again =(
14:19:35 <henry622> http://ideone.com/QbKQx
14:19:58 <Jacco> xil: the list comprehension creates a list of 2 infinite lists, taking the first 20 items of the union is equivalent to taking the first 20 items of the first of the 2 lists
14:20:01 <rasfar> line 26 by any chance?
14:20:04 <Cale> henry622: indentation
14:20:06 <rasfar> indentation again
14:20:11 <henry622> oh
14:20:30 <Cale> henry622: the p in putStrLn should line up with the n in num
14:20:49 <xil> Jacco: ah, that would explain it then. Thank you =]
14:21:14 <Jacco> No problem :)
14:21:18 <henry622> thanks again !!!!
14:21:30 <rasfar> you're welcome; good luck!
14:21:39 <henry622> result:  Runtime error
14:21:43 <henry622> =/
14:21:58 <rasfar> hahaha -- okay, keep the pastes coming then
14:22:14 <henry622> http://ideone.com/EtPaZ
14:22:49 <rasfar> what do you think?
14:23:09 <rasfar> as for what input you should actually supply, i've no idea
14:23:44 <henry622> hm
14:23:46 <rasfar> oh sorry, i guess it doesn't require input
14:24:08 <Cale> break it down into smaller parts
14:24:12 <rasfar> ah, "no parse" i didn't scroll that far :)
14:24:15 <nexion> how bad is String for performance? I use Text where possible, but Text.JSON works with String
14:25:57 <Cale> define (sp (inp ++ "00000") 4 5 []) separately, for instance, and check that its elements for various values of inp look readable.
14:27:11 <rasfar> >  read "00000-6" :: Int
14:27:12 <lambdabot>   *Exception: Prelude.read: no parse
14:27:12 <alpounet> nexion, have you checked out 'aeson'?
14:28:08 <rasfar> the first number your code tres to "read" (line 12) looks like "00000-6" which is not an Int
14:28:17 <nexion> cool
14:28:23 <nexion> thanks a lot :)
14:28:50 <rasfar> (henry622: i know what that first number looks like because I added some debugging code)
14:30:13 <henry622> and how to fix it? the problem is that i don't know the algorithm and the language :D maybe that is a liittle bit too much ;)
14:30:24 <henry622> -i
14:30:59 <rasfar> Do as Cale suggests; break the code down a bit.  You'll learn a bit about Haskell and about the algorithm! :)
14:31:17 <henry622> yeah i'll try :)
14:31:41 <henry622> tomorrow . it is late here in germany ;)
14:32:49 <henry622> thank you very much guys!!! cya tomorrow or so :) maybe i got it till then =D
14:32:49 <rasfar> you might also find the function "error" (no quotes) useful.  if you want to see the value of some expression, call it <EXP>, put (error (show ( <EXP> ))) in place of <EXP> and run again.
14:33:20 <rasfar> laters
14:33:33 <henry622> thanks, useful tip,
14:34:18 <henry622> good night !
14:38:33 * hackagebot logic-classes 1.4.1 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.1 (DavidFox)
14:38:40 <kallisti> is there anything like time that performs hundreds of tests and computes an average?
14:39:01 <Cale> criterion
14:39:14 <kallisti> isn't that Haskell specific?
14:39:17 <Cale> does statistical analysis of the time performance of Haskell code
14:39:18 <Cale> ah
14:39:25 <Cale> you want a unix tool
14:39:27 <Cale> hmm
14:39:29 <kallisti> yes
14:39:31 <kallisti> something simple.
14:39:41 <kallisti> I feel like this should already exist
14:39:42 <Cale> I wonder if criterion could be made to work with system :)
14:40:02 <thinker341> Hi, Do we have good "learn by example" book for Haskell ?
14:40:22 <merijn_> kallisti: bash for loop + time and a quick python script tp add everything together? :p
14:40:39 <kallisti> meh
14:40:44 <kallisti> s/python/perl/ but yeah I could
14:41:48 <kallisti> oh wait I can just format the output of time
14:41:56 <Cale> thinker341: have you already looked at "Learn You A Haskell" and "Real World Haskell"?
14:41:59 <Jacco> thinker341: I've just ordered "Real World Haskell", I think it's not really for the very beginner, but it should contain many (real world) examples. You could read the reviews about it'
14:42:37 <Jacco> The Real World Haskell book is also available online
14:42:53 <Jacco> http://book.realworldhaskell.org/read/
14:43:31 <thinker341> Cale: No not yet, they are on my list tho:), I have started reading "Yet another Haskell Tutorial". Kind of lost when it came to "Advanced features"
14:43:51 <thinker341> Jacco : Thank you. I will start reading it
15:09:30 <shapr> Yay yesod?
15:09:41 <shapr> At least I spent all day trying to figure out Haskell code. That's a good day.
15:14:18 <gzmask> I tried to install frag from hackage with cabal install frag. It compiles but when I run it within its bin folder with './frag leveleg', then it reports 'bus error'. anyone know how do I properly run the program?
15:15:20 <gzmask> or is it just bitrotted? Usually what kinds of error will casued 'bus error' ?
15:15:57 <c_wraith> gzmask: the most common cause of bus errors is dereferencing an invalid (but not null) pointer
15:16:57 <gzmask> c_wraith: hmm, so I guess it's caused by the 'leveleg' arg since it probably don't know where the level file is
15:17:30 <c_wraith> oh, I mean invalid as in "it doesn't point to a word boundary for a word data type"
15:24:17 <kwos> hi all
15:24:48 <kwos> I have this function that rounds a number to a given number of decimal places: round_to n x = fromIntegral ( round ( x * 10.0^n ) ) / 10.0^n
15:25:05 <kwos> if I do this: round_to 3 (-0.405), I get a segfault
15:25:10 <kwos> which is a bit worrying
15:25:19 <kwos> any suggestions how to debug this?
15:25:20 <aib> I want to build a simple DAG and enumerate all paths from node A to node B. what [standard or cabal] library should I look into using?
15:25:45 <kt> hi guys,
15:25:51 <kt> i have a question
15:26:36 <kt> which is the better way for error handling on bindings?
15:26:50 <lemmalemmasatz> aib: fgl is a graph library, you could look into that
15:27:05 <aib> lemmalemmasatz: I'd suspected as much. thanks
15:27:39 <lemmalemmasatz> aib: is it not good enough? :D
15:28:09 <boccato> If I were to buy one Haskell book, Real World Haskell would be a good choice?
15:28:35 <lemmalemmasatz> boccato: you can read it online and decide for yourself
15:29:05 <aib> lemmalemmasatz: nah, just a bit underdocumented for my newbie eyes. or maybe the built-in adjacency lists would've sufficed, in which case it's an overkill
15:29:12 <aib> still, this is the nth time it's come up; time to dig in
15:29:13 <hayashi> turns out I can't have nonemptylist, cabal goes into dependency hell
15:29:41 <lemmalemmasatz> aib: there are papers by martin erwig about the design, if that helps
15:29:43 <boccato> thx
15:29:54 <lemmalemmasatz> aib: but he doesn't maintain the library anymore
15:30:02 <hayashi> I'll just keep with my handrolled one them
15:30:13 <kallisti> hmmm lazy bytestring is quite a bit faster in my wc program than strict
15:31:49 <rasfar> kt: i'd definitely check the online version first. also, quite a few of the examples won't work with current versions of the libraries...
15:32:12 <rasfar> sorry kt, I meant boccato
15:32:48 <aib> is it me or is the typesetting way off here? http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.pdf oh well, looks kinda funny
15:33:17 <aib> *must*resist*the*urge*to*dance*as*I*read*
15:34:44 <glguy> Yeah, the letters are struggling to stay with-in the base and midlines
15:36:05 <hayashi> @pl \x -> if ( count x ) == 0 then Nothing else Just ( head x, tail x)
15:36:05 <lambdabot> ap (flip if' Nothing . (0 ==) . count) (Just . liftM2 (,) head tail)
15:36:08 <hayashi> Yow
15:36:46 * hayashi hugs his points
15:40:32 <endoself> hi
15:41:05 <endoself> I'm trying to install lambdabot, but the build fails
15:41:48 <endoself> Can someone help me?
15:42:37 <kt> endoself: which version are you using
15:42:44 <endoself> of cabal?
15:42:55 <endoself> 0.10.2
15:45:02 <kt> endoself: where it fails?
15:45:23 <hpaste_> endoself pasted “lambdabot build” at http://hpaste.org/67065
15:53:53 <endoself> Is that enough information
15:55:02 <kt> endolf: Im tracing your build, but my build fails at another place
15:55:22 <kt> endoself: it also is in the pl plugin
15:56:01 <endoself> Is it also an assembler error?
15:57:23 <kt> endoself: no is not, im thinking it should be in some depency but cant find anything yet
15:57:54 <rasfar> aib: i suspect it was originally a .ps file, and the PDF it was converted to doesn't have the proper fonts embedded.  i have a (rather expensive) textbook in which all lines containing corrected errata are about a point size smaller than the other lines, really disconcerting!
15:58:05 <kt> endoself: could be a compiler issue, because in hackage says there are build fails in ghc7 and 7.4
15:58:38 <endoself> I have 7.0.4, so that's possible
15:59:21 <endoself> People must be using lambdabot in ghc7, though, right? Isn't it a popular package?
15:59:51 <kt> yes it is, but i think must are running on 6.12
16:00:09 <kt> however send an email to Cale Gibbard <cgibbard@gmail.com> the maintainer
16:00:24 <endoself> ok
16:00:49 <hayashi> @pl \f g a b c d e x y -> f a d b (g x e c) y
16:00:49 <lambdabot> (. (flip . (flip .) . flip)) . flip . ((flip . (((.) . flip . (((.) . (.)) .)) .) . flip) .)
16:01:59 <hayashi> aww, not as messy as I was hoping
16:02:13 * hayashi was trying to get a deliberately horrifically obfuscated pointfree out
16:02:36 <endoself> @pl \a b c d -> a (b d) (c d)
16:02:36 <lambdabot> liftM2
16:02:52 <lemmalemmasatz> @pl \flip -> (. (flip . (flip .) . flip)) . flip . ((flip . (((.) . flip . (((.) . (.)) .)) .) . flip) .)
16:02:52 <lambdabot> ap ((.) . ap ($ (.)) (ap (.) ((.) =<< (.)))) (ap (.) ((.) . ap (.) ((.) =<< (.) . ((.) .) . (. (((.) . (.)) .)))))
16:03:26 <lemmalemmasatz> @pl \ap -> ap ((.) . ap ($ (.)) (ap (.) ((.) =<< (.)))) (ap (.) ((.) . ap (.) ((.) =<< (.) . ((.) .) . (. (((.) . (.)) .)))))
16:03:26 <lambdabot> ap id (((.) .) . ap ($ ($ (.))) (flip ($ (.)) ((.) =<< (.)))) `ap` ap ($ (.)) (((.) .) . flip ($ (.)) ((.) =<< (.) . ((.) .) . (. (((.) . (.)) .))))
16:04:01 <hayashi> lemmalemmasatz ^5
16:04:19 <ion> :-D
16:05:07 <hayashi> but how about...
16:05:24 <hayashi> @pl \ap id -> ap id (((.) .) . ap ($ ($ (.))) (flip ($ (.)) ((.) =<< (.)))) `ap` ap ($ (.)) (((.) .) . flip ($ (.)) ((.) =<< (.) . ((.) .) . (. (((.) . (.)) .))))
16:05:25 <lambdabot> ap (flip . ap (.) (ap flip ((((.) .) .) . flip ($ ($ ($ (.)))) (flip ($ (.)) ((.) =<< (.)))))) (flip ($ ($ (.))) (((.) .) . flip ($ (.)) ((.) =<< (.) . ((.) .) . (. (((.) . (.)) .)))))
16:05:35 <hayashi> aw, I was expecting cthulhu to appear
16:05:49 <Taslem> You're going to give it a heart attack.
16:06:00 <hayashi> so much pointfree~~
16:06:20 * hayashi expects that pointfree will appear on his death certificate as cause thereof
16:06:42 <Cale> kt: maintainer of what?
16:06:54 <Cale> endoself: I am not the maintainer of lambdabot
16:07:18 <endoself> oh, hi
16:08:17 <Cale> Someone who uploaded that package to hackage was confused by the fact that I run an instance of lambdabot here
16:08:26 <Cale> I don't actually maintain lambdabot's code
16:08:58 <Cale> I haven't run into the assembler error that you're seeing
16:09:43 <JoeyA> Is it possible to turn a data type consisting of nullary data constructors into types for each constructor?  In my case, I have: data HtmlTag = BR | DIV | FORM | ...
16:09:50 <endoself> Were you using 7.0.4?
16:10:05 <Cale> The lambdabot which I'm running for #haskell is using GHC 6.12.3, but I also have one locally on my machine which runs on 7.4.1
16:10:32 <tgeeky_> Cale: gimme!
16:10:34 <JoeyA> I'd like to be able to parameterize variables referring to DOM nodes by the node type, e.g. Node BR.
16:10:34 <Cale> (which I sporadically join to some channels on other IRC servers)
16:10:51 <Cale> tgeeky_: give you what exactly?
16:10:54 <JoeyA> I'm wondering if one of GHC 7.4.1's magical new features will let me do this sort of thing.
16:11:10 <tgeeky_> Cale: the patches or whatever you needed to get it to compile?
16:11:14 <Cale> I didn't do anything special to the code in order to get it running on 7.4.1
16:11:22 <Cale> I just built it and it ran
16:11:26 <tgeeky_> Cale: aha! gimme request withdrawn. have a nice day!
16:11:30 <endoself> Is there any information about my configuration that could reveal why it's failing?
16:11:31 <Twey> JoeyA: I think you'd need dependent types for that
16:12:04 <Twey> Since you can't tell from the types alone what node you will get e.g. if you search for a particular ID
16:12:07 <alpounet> JoeyA, GADTs?
16:12:20 <JoeyA> alpounet: That's a thought
16:12:48 <JoeyA> data HtmlTag a where BR :: HtmlTag BR; DIV :: HtmlTag DIV, ...
16:12:49 <Twey> Are GADTs enough?
16:13:25 <endoself> Do you think I should try installing 7.4.1?
16:13:28 <JoeyA> If I do that, I'll probably want to learn Template Haskell so I can generate these constructors without having to repeat myself so much.
16:13:52 <alpounet> heh
16:14:32 <ajg> hi. anyone know a way to have all of a module's type constructors derive a set of classes automatically -- maybe using TH?
16:15:06 <hpaste_> aib pasted “error” at http://hpaste.org/67067
16:15:17 <JoeyA> Though I'd probably want to put them all in type class instances.  If I'm really aggressive, I could even create type classes indicating whether a node can be a child of another node (e.g. <tr> can't be a direct descendant of a <span>, I don't think).)
16:15:39 <JoeyA> Maybe another day.
16:16:07 <aib> I'm not very good with types, where's the ambiguity at http://hpaste.org/67067 ?
16:17:18 <henry544> hey it's me again
16:19:29 <Twey> aib: You need to use a specific instance of Graph g => g
16:20:49 <Twey> You've got instructions for creating an arbitrary Graph g => g (Int, Int) () in ‘graph’, but in order to actually create one that graphviz' can use, you need to tell it what g is
16:20:53 <henry544> how can i send a highlighted message to a nick?
16:20:59 <Twey> henry544: Like this
16:21:06 <henry544> twey: ok
16:21:08 <aib> Twey: so Graph g => g Int Int isn't a concrete type?
16:21:09 <henry544> doesnt work
16:21:11 <henry544> ^^
16:21:28 <Axman6> henry544: yes it does, it hilights on their client, not yours
16:21:29 <henry544> Twey: test
16:21:30 <blackdog> is there a good way of getting ghc 7.4 onto debian stable?
16:21:33 <henry544> ah ok
16:21:36 <blackdog> 6.12 is a bit ancient
16:21:44 <henry544> thx
16:22:06 <henry544> rasfar: got it ! =)
16:22:20 <luite_> blackdog: i'd say installing the ghc binaries in your home dir
16:22:29 <donri> JoeyA: you're better of doing types by their context; see the xhtml-combinators package, it has types like "HeadContent" for tags that go in <head/>
16:22:38 <henry544> Cale: thanks for your help too :)
16:22:43 <blackdog> luite_: really? :/ alright. better than nothing i guess.
16:22:48 <rasfar> henry544, for goodness get some sleep!!
16:23:20 <Twey> aib: No, it's not
16:23:32 <henry544> yeah. had to do it before going to sleep =D
16:23:51 <Twey> aib: It looks like you probably want to fix g = Gr from Data.Graph.Inductive.Tree
16:24:02 <rasfar> i appreciate your coming back to thank me, man
16:24:15 <luite_> blackdog: it's still relatively simple to do and at least your package manager will never mess up your cabal packages
16:24:27 <aib> Twey: ah, so Graph is a class like Monad, not an actual type but a list of restrictions/functionalities for that type
16:24:37 <Twey> Right
16:24:41 <Twey> That's what the double arrow means
16:24:42 <henry544> yeah but i think i will not return here
16:24:42 <blackdog> luite_: yeah, i guess so. i always cabal install with --user anyway, though.
16:25:01 <Twey> Things before a => symbol are typeclasses
16:25:13 <aib> Twey: yeah, sorry. I've already been over the tutorials. impossible to learn until you hit a noob wall like I just did. thanks :)
16:25:19 <Twey> If it were a concrete type, the type of ‘graph’ would look like Graph (Int, Int) ()
16:25:36 <luite_> blackdog: perhaps there are better options, but I've always installed them in my homedir in ~/haskell/ghc-version, works fine, and you can easily keep multiple versions installed
16:25:37 <henry544> i study computer engineering, but we don't learn something like haskell
16:26:28 <henry544> just java and c
16:26:54 <rasfar> i was taught functional programming by an electrical engineer (also a computer scientist).  they can synergize, don't give it up...
16:27:22 <blackdog> luite_: right. hm, then i could just edit the PATH and not have to deal with update-alternatives
16:27:41 <rasfar> Haskell is like "executable specifications" -- ought to appeal to the engineer in you
16:27:54 <luite_> blackdog: or a symlink
16:29:05 <copumpkin> ohai edwardk
16:29:10 <edwardk> ohai
16:29:19 <edwardk> i can haz precision? =)
16:29:26 <rasfar> henry544: the possibility of provable correctness is also a Good Thing
16:29:36 <copumpkin> struggling with annoying build issues but the code changes are in and I don't see reason for it to be broken when I get it to build :P
16:31:04 <nexion> http://hpaste.org/67068 <-- if the "DAN.I outSequence" pattern-match fails, will it move on to the next case statement? it looks like it doesn't throw a pattern-match fail exception, but I'd like to make sure the code does what's expected
16:31:20 <copumpkin> edwardk: do you know how to force cabal to statically link a library?
16:31:27 <henry544> yeah maybe in future i will deal with it . got no time now for another language
16:31:39 <copumpkin> I tried throwing the lib into ld-options but it didn't like it
16:31:46 <copumpkin> or rather, it seemed to have no effect
16:31:47 <edwardk> copumpkin: not off hand
16:31:58 <henry544> so thanks again rasfar and cya (maybe) ;)
16:32:04 <rasfar> i do understand that.  i was a student over the last 6 years, and had to basically give up Haskell during that time, I was so busy using other langs
16:32:12 <rasfar> cya, be well
16:32:51 <copumpkin> oh, it's just ignoring my mpfr request in ld-options
16:33:57 <edwardk> http://stackoverflow.com/questions/5131182/how-to-compile-haskell-to-a-static-library ?
16:34:03 <edwardk> er no thats not it
16:34:15 <copumpkin> I think I'd be fine if it didn't ignore my parameter
16:35:21 <Peaker> anyone knows if Network.HTTP can be used in a streaming fashion?
16:35:29 <Peaker> and same w.r.t zlib?
16:35:44 <Peaker> I am wondering if I can parallelize "cabal update", which downloads and unzips
16:37:51 <copumpkin> gah
16:39:33 <Peaker> someone on haskell-libs mailing list suggested using StreamHooks with HTTP but it seems too low-level
16:39:48 <Peaker> I was thinking of using conduits inside cabal-install, but that would incur a bunch of extra dependencies
16:50:02 <lemmalemmasatz> is there something like a guide through code literature (in Haskell)? I liked reading bos' attoparsec code (the Parser monad implementation specifically)
16:50:11 <copumpkin> edwardk: alright, build issues aside, it doesn't seem to crash at least, and produces real results when compiled :P not working in ghci yet only because of the build issues so far (not because I think it'll crash or produce bogus data)
16:50:16 <copumpkin> no real hacks in the code anymore
16:50:24 <Peaker> If Network.HTTP doesn't support streaming at all, it's a bit sad.. or maybe happy that it can finally be replaced with conduits
16:51:36 <copumpkin> Peaker: streaming in what sense?
16:51:43 <copumpkin> oh, HTTP
16:51:46 <copumpkin> yeah, I don't think it does
16:51:59 <Peaker> http://hackage.haskell.org/package/http-conduit <-- dependency list is really large for cabal-install :-(
16:52:03 <copumpkin> I'm really not a huge fan of Network.HTTP, although its browser thing is kind of cute
16:54:50 <Peaker> what's with the weird version numbers?
16:55:25 <monochrom> version numbers are like currency
16:55:54 <luite_> the HTTP version numbers?
16:56:06 <hayashi> @pl \(x:xs) -> reverse (( reverse x ):xs)
16:56:06 <lambdabot> ap ((reverse .) . (:) . reverse . head) tail
16:56:12 <hayashi> no thanks lambdabot
16:57:15 <Peaker> luite_, yeah, 3000, 4000, etc
16:57:38 <copumpkin> Peaker: I think the project was started before there was a prescribed versioning scheme anywhere
16:57:59 <copumpkin> it's ancient isn't it?
16:58:13 <monochrom> isn't that reverse . map reverse ?
16:58:13 <Peaker> I donno
16:58:27 <monochrom> err, no, nevermind
16:58:51 <monochrom> HTTP was before PVP
16:59:01 <monochrom> before hackage, too
16:59:37 <hayashi> monochrom: literally just trying to reverse the head (which is itself a list), then reverse the entire list
17:00:23 <Peaker> oh, it seems HTTP does support streaming!
17:00:27 * Peaker is gonna test it
17:00:28 <hayashi> admittedly the fact that that's necessary is a bit worrying, but it saves on having to append lists to ends of lists in the preceding algorithm, unless I'm doing something VERY wrong.
17:00:29 <edwardk> copumpkin: nice =)
17:00:44 <Peaker> "simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))" <-- "ty" can be a streamer type
17:00:48 <edwardk> copumpkin: when you load ghci with some static linking flags for mpfr does it work then?
17:01:13 <copumpkin> edwardk: hmm, the main issue is that ghci loves .o files and I don't have any for mpfr
17:01:20 <copumpkin> I have a .a file which I haven't unpacked yet
17:01:38 <edwardk> ah
17:02:31 <Peaker> I wonder why the "ty" has to be the same in the Request and Response
17:03:03 * copumpkin tries to think of how best to do this
17:03:17 <edwardk> hrmm, http://hackage.haskell.org/trac/ghc/ticket/3345
17:03:33 <monochrom> right, it's probably an oversight back then
17:04:33 <copumpkin> edwardk: ah, nice
17:04:40 <copumpkin> it still seems to ignore the .o files when I lump them into the .a though
17:04:49 <copumpkin> so either it isn't in 7.4.1 yet or I'm doing something wrong
17:11:29 <Peaker> "darcs pull" on the cabal repo is taking sooo long, they should just migrate cabal to github :-(
17:12:57 * Eduard_Munteanu wishes git could handle darcs repos (like with SVN) :D
17:14:07 <Eduard_Munteanu> Though it's probably a mess to handle some of the stuff darcs does, like equivalence up to reordering certain commits.
17:18:26 <copumpkin> edwardk: what do you think of having the build script download the mpfr tarball, unpack it, and patch it, rather than checking in all the code?
17:20:15 <edwardk> copumpkin: if you think it can be done fairly portably
17:20:30 <edwardk> copumpkin: in practice its probably easier to just bundle the whole mess
17:20:40 <copumpkin> hmm, probably
17:20:52 <copumpkin> makes me feel so icky though :P
17:20:53 <copumpkin> but ah well
17:21:06 <copumpkin> still gotta figure out how to make it build without a bunch of manual hacks
17:21:51 <mm_freak> when you have no experience with writing language implementations, what should you begin with?  untyped lambda calculus?
17:22:13 <copumpkin> mm_freak: it's about as simple as you can get, so I'd probably start there
17:22:19 <aib> is there a way to produce two elements per list comprehension combination? e.g. [(x+1,y) | ...] ++ [(x,y+1) | ...]
17:22:21 <copumpkin> no need to worry about a type system
17:22:21 <mm_freak> ok
17:22:41 <copumpkin> aib: concat [[x+1,y] | …]
17:22:54 <aib> yeah I was just typing that as an alternative.. concat then? ok
17:23:05 <jfischoff> mm_freak: have you written a simple expression parser/evaluator? That's even easier.
17:23:27 <mm_freak> jfischoff: yes, but that's nowhere near a programming language
17:23:45 <copumpkin> all it's missing is missing abstraction and application :)
17:23:52 <copumpkin> which boil down to two new constructors in your ADT type
17:24:07 <copumpkin> (and a variable type, I guess)
17:24:17 <copumpkin> it really isn't that much more
17:24:28 <jfischoff> what copumpkin said
17:24:37 <copumpkin> if you represent your syntax as HOAS, the whole thing will probably fit in a screenful of code
17:25:05 <mm_freak> yeah, the ADT is extended minimally, but the rest?  suddenly i have to deal with variable scoping, etc. =)
17:25:14 <copumpkin> HOAS does that all for you
17:25:23 <mm_freak> i specifically want to do it myself
17:25:26 <copumpkin> oh
17:25:35 <copumpkin> well, if you use de bruijn indices, you also don't have to deal with it much at all
17:25:44 <copumpkin> scoping sort of happens by construction
17:25:59 <copumpkin> if you really want to use string variable names, you're on your own :)
17:26:11 <mm_freak> copumpkin: well, i have to at least differentiate between free and bound while beta-reducing
17:26:19 <mm_freak> i'll start with a simple λ calculus interpreter, then move on to a compiler
17:26:27 <copumpkin> cool
17:26:35 <mm_freak> when that works, i'll try to add a type system
17:26:41 <copumpkin> augustss has a paper on doing LC four different ways I think
17:26:49 <jfischoff> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
17:26:52 <jfischoff> that's the link
17:27:00 <mm_freak> thanks
17:27:05 <jfischoff> np
17:27:08 <mm_freak> that should get me started =)
17:27:33 <jfischoff> the rest of his blog is good too :)
17:27:44 <copumpkin> it's a pity he's stopped blogging
17:27:57 <jfischoff> is he just busy?
17:28:06 <copumpkin> I'd assume so
17:28:11 <Peaker> so if you use Network.HTTP with lazy bytestring, it does lazy I/O. Yuck, but good enough
17:30:49 <jfischoff> speaking of little languages, has anyone else checked out BNFC-meta?
17:34:24 <Peaker> cabal-install seems to thread arguments manually over the place (like Verbosity) instead of using a nice little monad
17:41:53 <Peaker> why is <.> needed for extension cat'ing? </> is for portability, but what is <.> useful for?
17:42:50 <copumpkin> homogeneity, possibly?
17:43:52 <parcs`> conciseness
17:44:05 <parcs`> a ++ "." ++ b vs a <.> b
17:44:23 <Peaker> in cabal they do "blah" <.> "tar" <.> "gz"
17:44:42 <copumpkin> lol
17:44:47 <parcs`> that is silly
17:44:51 <Peaker> I want to see how much I sped up "cabal update", so I want to go back to before my latest patch
17:44:53 <Peaker> how can I do that?
17:45:17 <Peaker> I think I drastically sped up "cabal update" with a relatively simple patch :-D
17:46:13 <parcs`> isn't most of the time spent downloading the index?
17:46:20 <parcs`> iirc that takes like 20 seconds
17:47:41 <Peaker> it takes considerable time to decompress it
17:48:10 <shachaf> The amazing thing about cabal update is that it takes 20 seconds to download the index no matter how fast or slow your connection is.
17:48:35 <monochrom> that's communism for you!
17:48:51 <monochrom> and also "no child left behind"
17:49:10 <Peaker> it actually takes 53 seconds overall here :-(
17:49:29 <shachaf> On my home connection I would measure the time it takes in minutes. :-(
17:49:46 <Peaker> at work, I scripted bootstrapping of haskell env -- wanted to make progress report for cabal update, so I poll the files it writes
17:50:01 <Peaker> and I saw it spends a lot of time downloading, then a lot of time decompressing, then a bit of time doing more stuff
17:50:06 <rwbarton> for me it just took 37 s
17:50:19 <parcs`> shachaf: what are you on dialup
17:50:20 <rwbarton> but nearly 27 s of user time so it does seem like it is doing a lot of work
17:51:03 <shachaf> Why is it doing so much work?
17:51:18 <rwbarton> maybe "String"?
17:51:24 <rwbarton> I don't really know what it does
17:51:30 <shachaf> Did they write the decompression code in Haskell or something crazy like that?
17:51:54 <rwbarton> I was more thinking maybe it parses all the package descriptions or whatever is in the file
17:52:04 <Peaker> shachaf, it's just all serialized unnecessarily
17:52:05 <parcs`> the tar decompression is in haskell, but i think zlib uses bindings
17:52:18 <parcs`> er, tar extraction
17:53:19 <Peaker> wow. what a mistake mentioning it in #haskell !
17:53:32 <Peaker> now everybody's downloading the damn tar.gz and ruining my benchmarks!
17:56:41 <TSC> here I get: cabal update  8.76s user 0.28s system 45% cpu 20.055 total
17:57:22 <TSC> A progress report would be great!
17:58:00 <luite_> shachaf: yeah the hackage server limits the download speed :(
17:58:18 <Peaker> it could be nice to have a corrupt identity function for lazy bytestrings that yielded progress reports somewhere.. I could pipe the lazy bytestring through it to also have cabal update show progress
17:58:29 <stulli> Peaker: I'm not (yet?) a darcs expert, but maybe something like this?:  darcs get ./myRepo --to-patch previousPatch --repo-name myTempRepo
17:58:55 <Peaker> stulli, thanks.. I hacked it via "rollback" and then "unrecord" and "revert"
17:58:56 <stulli> Peaker: Or simply rollback the last patch and obliterate the rollback afterwards
17:59:22 <shachaf> You know how people always say that e.g. instead of "data S = forall a. Show a => S a" and then [S], it's more sensible to just use [String]?
17:59:29 <shachaf> What would be a reasonable equivalent for Read?
17:59:30 <Peaker> stulli, obliterate is probably unrecord+revert?
18:00:26 <aib> I'm trying to get a list of all paths from A to B in a graph in fgl. any ideas on what I should use? DFS/BFS iterators get very little context information - only the current node - I should use some kind of fold or map?
18:00:41 <Peaker> I think the idea behind that is that: (exists a. (a -> String, a)) = String (Show is not exactly (a -> String) but close enough).   For   (exists a. (String -> a, a)) there's nothing useful to simplify?
18:01:10 <Peaker> shachaf, what's the existential you consider using for Read?
18:02:04 <Peaker> woah! there's bytestring-progress, exactly as I need
18:02:39 <shachaf> Peaker: Well, I have a String which I want to call "read" on in one place and put it in a record etc., and only use its value in a much later place.
18:03:31 <rasfar> aib: that's a whole lotta paths in general.  and you are acyclic i hope...
18:04:29 <aib> rasfar: yeah it's a DAG. I might just do with the number of paths too
18:05:11 <nexion> if I have data MyType = Number a | String b and a list [Number 3, String "hello", Number 5], how can I convert that to the tuple (3, "hello", 5) :: (Integer, String, Integer)?
18:05:36 <nexion> I understand that this is not possible for variable length lists
18:05:49 <nexion> but I'm looking to only support lists as long as 9
18:06:36 <aib> http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-BFS.html - there's a bfsWith function, but the context information "Context a b" is not enough. Can I do some trickery so that my function (Context a b -> c) works with extra context? something along the lines of (Context a b -> ExtraContext -> c) where I get to update ExtraContext for subsequent calls?
18:06:43 <jfischoff> aib: check out Graphalyze. There are few methods in that package for getting paths like pathTree, leafMinPaths that might be helpful
18:06:57 <Orclev_> with fclabels, if you have a type like "data Foo = Bar { _a :: Int } | Baz { _b :: String }" and you use the TH mkLabels is that going to cause problems? I'm getting a weird error about no instance of ArrowZero and I suspect that's the underlying cause
18:07:19 <aib> jfischoff: roger
18:08:53 <stulli> Peaker: Looking at the code, i doubt that obliterate is defined as unrecord+revert. At least it lives in the same module as unrecord.
18:09:37 <ByronJohnson> Orclev_: I'd ask yourself, "how would I define a lense for this type manually?"
18:10:02 <stulli> Also i'm answering in the wrong channel, time to go to bed :)
18:10:27 <hpaste_> vhd pasted “shogi” at http://hpaste.org/67070
18:11:14 <vhd> anyone help me out with this bug, the minimax algo works
18:11:31 <vhd> but randomly decides to evaluate everything to infinity.
18:11:38 <vhd> and I have no idea why :|
18:11:58 <hpc> vhd: randomly as in, sometimes the same input gives different results?
18:12:13 <vhd> no, its this one input
18:12:17 <hpc> ah
18:12:18 <rasfar> nexion, are you quite sure you want that?  each tuple will (mostly) have a different type, for every possible choice of component types.  so for the data type you gave, it's on the order of 2^L distinct types where L is the list length.
18:12:20 <hpc> @quote oasis
18:12:20 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:12:21 <vhd> bugSet
18:12:24 <hpc> vhd: ^
18:12:38 <hpc> Debug.Trace.trace is your friend here, i think
18:12:48 <Orclev_> ByronJohnson: I'm not sure... something like "getB (Baz b) = b"
18:12:58 <vhd> how would I use that, the haskell wiki didnt make much sense.
18:13:19 <rasfar> good quote; i'm just experiencing those benefits myself this month.
18:13:32 <hpc> trace a b -- when b is evaluated, also print a to the screen
18:13:58 <hpc> put in a few opportunistic places with strings like ("xs = " ++ show xs)
18:14:12 <vhd> does that require IO?
18:14:12 <rasfar> @src trace
18:14:12 <lambdabot> trace string expr = unsafePerformIO $ do
18:14:13 <lambdabot>     hPutStrLn stderr string
18:14:13 <lambdabot>     return expr
18:14:17 <hpc> vhd: no
18:14:38 <vhd> ok, ill give that a shot thanks.
18:14:39 <hpc> it deliberately breaks the rules to be useful for debugging
18:14:56 <vhd> I actually thought it was to do with IO when I saw it
18:15:24 <hpc> a refreshing desert in the oasis of referential transparency ;)
18:16:00 <nexion> rasfar: yeah.. I'm going to pass it to MessagePack.pack and the receiver knows the correct type to use for unpacking
18:16:05 <zachk>  "Ambiguous module name `Control.Monad.Reader':", how does one disambiguate?
18:16:22 <zachk> hpc: mayhaps a refreshing dessert :9
18:17:02 <lemmalemmasatz> zachk: maybe this is a case for the PackageImports pragma?
18:17:31 <zachk> lemmalemmasatz: how do avoid that, or use that, because I wish to play around within ghci
18:18:10 <lemmalemmasatz> hm, good question, I always used the radical solution :D
18:18:31 <lemmalemmasatz> that is removing the package I didn't  want
18:18:36 <Orclev_> so, is it impossible to use lenses for types that have multiple constructors?
18:20:37 <lemmalemmasatz> zachk: but until someone provides *the* solution, you could just load a Haskell file into ghci, which just contains the pragma and imports the stuff you need
18:21:01 <zachk> lemmalemmasatz: too much work, how do I just remove a package?
18:21:19 <jfischoff> Orclev_: that seems like a use case for partial lenses
18:21:21 <lemmalemmasatz> ghc-pkg unregister? :)
18:23:51 <rasfar> nexion, i don't know a good way to do that; but couldn't you just stay with the lists for the message type?
18:24:06 <Orclev_> jfischoff: so I found a partial lens package on haskell... looks like it's just a lens that returns the type wrapped in Maybe?
18:24:22 <dibblego> Orclev_: data-lens supersedes it
18:24:52 <dibblego> Orclev_: also, yes, partial lenses are suitable for sum types (e.g. Either)
18:25:16 <zachk> lemmalemmasatz: there is another possible solution here  http://stackoverflow.com/questions/2048953/control-monad-state-found-in-multiple-packages-haskell
18:25:43 <Orclev_> hmm... I'm thinking I'm just going to abandon lenses entirely, they've not really gained me anything at all and they're introducing all kinds of dependencies and weird errors
18:27:01 <lemmalemmasatz> zachk: ah, so it is ghc-pkg hide :) good to know
18:27:49 <zachk> hide doesn't break your build system, though your solution seems more generally applicable
18:27:49 <jfischoff> Orclev: I wouldn't. There are not that many dependencies and they are not actually that complicated. Lenses with effects are still be worked out though.
18:29:35 <Orclev_> jfischoff: I had decided to use fclabels because it seemed like the simples one of the group, I just needed to toss in a TH call and then use them, but now I'm running into edge cases
18:30:08 <jfischoff> Orclev_: data-lens I think is the simplest.
18:30:46 <jfischoff> Orclev_: what sort of edge cases?
18:30:49 <nexion> rasfar: I'm basically converting from JSON to the MessagePack format -- the proper way to do this would be to pattern-match on the message type and then encode the parameters since their types are known given the message type, but I'm trying to avoid doing that and just convert Number to Int and String to Text
18:31:22 <Orclev_> jfischoff: essentially, I've got a type with multiple constructors and apparently it doesn't work for that, keeps complaining about no ArrowZero instance
18:32:22 <Peaker> cool! I've got "cabal update" with progress report too
18:33:00 <Peaker> a bit quick&dirty, I use '\r' : progressStr ++ replicate 20 ' '         to generate progress lines that overwrite each other
18:33:13 <Peaker> (as well as assume stdout is suitable for progress reports such as that)
18:33:21 <nexion> is there an easy way to add an extra parameter to a tuple? (Int, String) -> a -> (Int, String, a)
18:33:50 <jfischoff> Orclev_: I can't help you there, never used fclabels
18:33:55 <Peaker> cabal update --> "56% (13 seconds left, 2342880 bytes read)" :)
18:34:22 <Peaker> @pl f (x, y) z = (x, y, z)
18:34:23 <lambdabot> f = uncurry (,,)
18:34:34 <Peaker> ;-)
18:35:03 <nexion> ah
18:35:17 <nexion> ty
18:38:07 <Orclev_> ok, guess I'll try data-lens-template and see if it fairs better
18:38:40 * hackagebot hedis-pile 0.5.1 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.5.1 (AlexanderDorofeev)
18:40:04 <Peaker> Do the lens libs solve the polymorphic record problem? i.e: update field in   Record a     that turns it into a    Record b ?
18:40:15 <Peaker> I gave up on fclabels because of that problem
18:43:34 <Orclev_> Peaker: I guess you might be able to hand craft one that does that, but the ones that auto-derive for you just act as cleaner replacements to record syntax
18:44:39 <Peaker> record syntax can do the polymorphic update
18:45:11 <Peaker> the problem with fclabels, for example, is that the type of the setter looks like:   Label record field -> field -> record -> record
18:46:11 <Peaker> and "record" is thus forced to be the same type, whereas with record update syntax it can change
18:47:25 <Peaker> https://github.com/Peaker/bottle/blob/master/bottlelib/Data/AtFieldTH.hs   <--    using this instead. It generates SEC lifters for each record field
18:48:04 <Peaker> It will happily do: (a -> b) -> Record a -> Record b
18:48:36 <rwbarton> what if I have   data Record a = Record { x :: a, y :: a, z :: Int }
18:48:46 <rwbarton> or  data Record a = Record { x :: Bool, y :: [a] }
18:49:01 <Orclev_> Peaker: well, it's not really the same thing is it? You're talking about something that's conceptually closer to Functor
18:49:24 <Orclev_> FunctorLens?
18:50:57 <Peaker> rwbarton, the former is a problem with the AtFieldTH thing
18:51:15 <Peaker> rwbarton, the latter is OK:   atY :: ([a] -> [b]) -> Record a -> Record b
18:52:13 <Peaker> Orclev_, it's just record field access, with some more complex interaction with the types
18:56:33 <copumpkin> anyone know the way to find out the full path of the "dist" directory in a cabal package in Setup.hs?
18:56:39 <shepheb> if I'm piping input to a Haskell program, but want to ignore the rest, and reopen stdin to the terminal, is that possible?
18:56:39 <copumpkin> using Distribution.Simple
18:57:48 <copumpkin> oh, it might be in that localBuildInfo thing
19:00:33 <Peaker> BAH! Sending a patch to cabal requires making patches via darcs's slow interface and then sending them to a mailing list that needs manual approval!
19:00:35 <Peaker> just move to github, damnit!
19:00:55 <copumpkin> Peaker: dcoutts might be open to suggestions if you address them at him :)
19:01:23 <Peaker> blocking user contributions is frustrating. Contributors want to spend time solving real world problems, not fight bureaucratic machinery :(
19:01:42 <Peaker> dcoutts, please read this when you are back :-)
19:01:43 <copumpkin> I'm sure it wasn't an intentional decision
19:02:09 <Peaker> it's no wonder that when people switch to github they get a huge surge of contributions
19:03:41 * hackagebot hedis-pile 0.5.2 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.5.2 (AlexanderDorofeev)
19:05:20 <shepheb> any ideas on my input stream issue? I'm not sure if it's possible to reopen stdin that way.
19:06:29 <Peaker> shepheb, maybe you can try opening /dev/tty ?
19:08:41 * hackagebot ghc-mod 1.10.14 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.14 (KazuYamamoto)
19:09:13 <Peaker> @tell dcoutts Can cabal development be moved to github? Sending patches to cabal-devel@haskell.org which auto-rejects you and forces you to spend lots of time dancing around instead of a simple github pull request is probably sending contributors away...
19:09:13 <lambdabot> Consider it noted.
19:11:53 <Rodrigo> hi
19:21:32 <edwardk> Peaker: yeah, I get about 20x as many patches sent now that I'm on github
19:22:15 <thoughtpolice_> hell, the last time I tried to clone the Cabal repo I got some nasty getSymbolicLink error from darcs. it's not even using the darcs2 hashed format :(
19:22:27 <shachaf> That's nothing. When I moved something to GitHub I got A BILLION TIMES as many patches sent as before.
19:22:39 <copumpkin> edwardk: the Setup.hs is turning quite fancy :P
19:22:44 <copumpkin> but I'm making progress :D
19:22:46 <Peaker> edwardk, awesome
19:22:53 <edwardk> copumpkin: oh?
19:22:59 <shachaf> (Actually, that might not be true. I don't remember whether I got patches or not anymore...)
19:23:06 <thoughtpolice_> copumpkin: a fancy Setup.hs is never fun :P
19:23:13 <JDog> sup
19:23:20 <edwardk> yeah that is starting to look fancy
19:23:21 <JDog> how is it goin
19:23:35 <edwardk> well, right now it just has the constants file
19:23:39 <copumpkin> well, I need to do a lot of stuff, including configure/make/make install into my local dir, then I get the mpfr.h and can build our make derived constants from that, then the make derived constants generates the .h file, then I can actually build things. After building, I need to mangle the output to statically link mpfr back into it, and then we're done
19:23:54 <edwardk> *nods*
19:24:56 <aanari> Hey is there an online repository for xmonad configurations?
19:25:48 <Veinor> i have no darcs experience, but i like github just because everybody's using it
19:25:50 <zachk> arch linux has something called xmonad-contrib(s), it may be a general package
19:26:03 <shachaf> aanari: Some people put their configurations on the wiki.
19:26:14 <shachaf> You can probably find a lot there.
19:26:15 <geekosaur> xmonad-contrib is part of the xmonad distribution
19:26:30 <geekosaur> http://www.haskell.org/haskellwiki/Xmonad/Config_archive
19:26:37 <aanari> shachaf: Yeah I saw that so I'll just use bits and pieces from that list
19:26:46 <aanari> geekosaur: Thanks I"ll keep working off of this
19:29:02 <geekosaur> there is also the #xmonad IRC channel btw
19:35:01 <aanari> exit
19:38:42 * hackagebot simple-sendfile 0.2.3 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.3 (KazuYamamoto)
19:41:17 <ForSpareParts> Can anyone tell me how to pattern match on a List of a certain type and also bind it to a name? Like, "match a list of Strings and give it the name strList in the expression to follow," that sort of thing?
19:42:12 <BMeph> ForSpareParts: Yes. Next question? ;)
19:42:48 <tgeeky__> ForSpareParts: "at patterns" I think
19:42:48 <ForSpareParts> BMeph: Heh. Fair enough. Would you please?
19:42:50 <td123> for type, you would probably just have to create a type signature for it to restrict it
19:43:00 <boccato> strList@(x:xs) ?
19:43:06 <boccato> or something like that?
19:43:12 <tgeeky__> ^^^ that-s an "at pattern"
19:43:41 <dibblego> s/at/as
19:43:47 <tgeeky__> yeah.
19:43:53 <tgeeky__> that's annoying. since it's an "at" symbol.
19:43:57 <ForSpareParts> Ah, okay. So, in the expression following the at pattern, (x:xs) could also be referred to as strList?
19:44:15 <boccato> yes
19:44:33 <ForSpareParts> So, could I do something like strList@[String]?
19:44:41 <tgeeky__> not quite
19:44:46 <tgeeky__> ForSpareParts: http://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns
19:45:11 <rwbarton> you could if you happen to have a data constructor named String, it's probably not what you meant though
19:47:14 <ForSpareParts> Actually, the real problem I'm trying to solve does involve a list of a custom data type...
19:47:39 <ForSpareParts> so if I had a constructor DataType Integer String, say...
19:48:14 <ForSpareParts> could I do nameForList@[(DataType i str)] ?
19:48:22 <ForSpareParts> er
19:48:30 <ForSpareParts> hrm, I guess that doesn't make much sense
19:48:40 <ForSpareParts> nameForList@[DataType]?
19:48:59 <Eduard_Munteanu> ForSpareParts: that'd match a list containing "DataType i str" as its only element
19:49:00 <rwbarton> it sounds like you are confused
19:49:13 <ForSpareParts> I am, yeah.
19:49:14 <Eduard_Munteanu> I mean, the former.
19:49:43 <rwbarton> nameForList@[DataType] matches whatever [DataType] matches
19:49:49 <Eduard_Munteanu> ForSpareParts: it's plainly name@pattern, where 'pattern' is a normal pattern.
19:49:55 <rwbarton> it is a pattern! not a type!
19:50:03 <ForSpareParts> OK.
19:50:08 <Eduard_Munteanu> e.g. xss@(x:xs)
19:50:13 <rwbarton> so it matches the list [DataType] and nothing else
19:50:28 <rwbarton> Also, it names that value 'nameForList'.
19:50:39 <Eduard_Munteanu> In that case, xss is another name for x:xs
19:50:56 <ForSpareParts> So, what I really need is some way to guarantee that an incoming list contains only some type of data -- to match on something else if the list isn't pure. Is there a mechanism for that?
19:51:39 <blackdog> what would "not being pure" mean?
19:51:39 <rwbarton> well by definition the list only contains data of the *type* that it's a list of
19:51:52 <Eduard_Munteanu> foo (SomeConstructor a b) = ...   ?
19:51:52 <rwbarton> you probably have some other half-baked notion in mind
19:52:26 <zachk> blackdog: usually pure means no IO
19:52:34 <Eduard_Munteanu> You can use guards to check for various conditions, or view-patterns.
19:52:41 <ForSpareParts> rwbarton: You're right, I wasn't being clear.
19:52:47 <Eduard_Munteanu> Do you have an actual example?
19:52:53 <ForSpareParts> blackdog: thanks for telling me that, sorry for the confusion
19:53:24 <ForSpareParts> I do. It's a Scheme implementation for class...
19:53:24 <mikeplus32> > pure 1 :: IO Int
19:53:25 <lambdabot>   <IO Int>
19:53:28 <mtbeedee> Hey, IO question... I have a function like "do c <- readFile fileName ; words c" where the type is IO [String] but ghc says the 'actual type is [String].  Now, that doesn't work either nor does it make sense because it is words'ing the thing read from the file so it is inside IO, right?
19:53:30 <mikeplus32> what a silly name
19:53:39 <Eduard_Munteanu> :t words
19:53:40 <lambdabot> String -> [String]
19:53:41 <ForSpareParts> and I'm trying to implement define
19:53:51 <Eduard_Munteanu> mtbeedee: the problem is words isn't an IO action.
19:54:04 <ForSpareParts> I have an Exp data type with multiple constructors.
19:54:40 <ForSpareParts> I need to make sure that the list of arguments for the define is only a set of symbol expressions -- no numbers or primitive operations.
19:55:01 <blackdog> zachk: *grin* yes, I know that. Original gangsta since 2001.
19:55:20 <rwbarton> You can't express that with a pattern
19:55:23 <mtbeedee> Eduard_Munteanu: yea, I get that, but how can you apply that to some file contents?
19:55:38 <ForSpareParts> OK. Is there a good way to express it?
19:55:38 <Eduard_Munteanu> ForSpareParts: you can write a function that returns true if that's alright, or something in Maybe
19:56:05 <mikeplus32> mtbeedee: so you need to return words c as IO
19:56:05 <mikeplus32> ie, return (words c)
19:56:08 <Eduard_Munteanu> mtbeedee: it's not about applying it, it's about the result
19:56:33 <blackdog> ForSpareParts: ore you parsing that out of a list of strings, for instance, or do you have a bunch of datatypes floating about and you want to make sure that the list contains only a few?
19:56:33 <Eduard_Munteanu> What is your function supposed to do with "words c"?
19:56:36 <rwbarton> probably write a helper function like  Expr -> Maybe [String]
19:56:39 <Eduard_Munteanu> "do" in the IO sense.
19:56:55 <rwbarton> which returns Just [x, y, z, ...] if those are the symbols that appear in the list, otherwise Nothing
19:57:45 <ForSpareParts> I have a bunch of datatypes -- I need to make sure the last has only one of them.
19:57:48 <mtbeedee> Eduard_Munteanu: well, it actually "returns" it... the caller function uses it to print something and then get a response
19:58:02 <mikeplus32> mtbeedee: you could rewrite your function as fmap words (readFile fileName), btw
19:58:24 <ForSpareParts> So I would... map that helper function onto my [Expr], then?
19:58:42 * hackagebot cab 0.1.12 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.12 (KazuYamamoto)
19:59:04 <Eduard_Munteanu> ForSpareParts: as far as rwbarton's variant is concerned, you'd be applying it, not mapping it per se.
19:59:17 <rwbarton> I am a little fuzzy on the exact details
19:59:23 <ForSpareParts> Or make a helper function that takes a [Expr] as an argument and returns a Maybe [SymExpr], perhaps...?
19:59:34 <ForSpareParts> (where SymExpr is the constructor for a Symbol)
19:59:50 * BMeph mutters something like: "all <checkingFunction> <ExprList>"
20:00:47 <ForSpareParts> BMeph: Thank you, that would work, too.
20:01:12 <ForSpareParts> Actually, thanks everyone. You've given me good ideas.
20:01:26 <rwbarton> probably you want to extract some data from the symbol at the same time, though
20:01:44 <rwbarton> like what symbol it is :)
20:06:12 <BMeph> rwbarton: How...symbolic of you! :)
20:09:53 <any-key> can you not mix guards and where like this? http://pastebin.com/Yw6ThAQr
20:09:57 <mauke> The paste Yw6ThAQr has been copied to http://hpaste.org/67071
20:15:15 <Axman6> any-key: what error are you getting?
20:15:48 <any-key> Axman6: http://pastebin.com/3yKci15b
20:15:50 <mauke> The paste 3yKci15b has been copied to http://hpaste.org/67073
20:16:01 <any-key> I should just use hpaste.org, shouldn't I?
20:16:08 <rwbarton> that's a totally different kind of error
20:16:16 <rwbarton> syntax is fine
20:16:22 <any-key> whew good
20:16:39 <rwbarton> (if you paste the error originally, it will be easier for people to answer your questions)
20:16:50 <Axman6> any-key: time to learn to read error messages ;) that's a type error, nothing to do with syntax
20:17:37 <any-key> I've been looking for a type mismatch but I can't find anything obvious
20:17:47 <geekosaur> you have athinko in the type signature
20:17:59 <rwbarton> it sounds like the type signature you wrote (not included in the paste) is wrong
20:18:32 <Axman6> accessFlags :: ByteString -> (AccessFlag, rest) is the same as saying accessFlags :: ByteString -> (AccessFlag, a). you're saying it can return something of any type at all
20:18:56 <rwbarton> oh oops it was in the paste
20:19:00 <any-key> oh wow
20:19:07 <rwbarton> (put the error message in an annotation on the original paste :P)
20:19:09 <any-key> that was dumb, sorry about that
20:19:25 <any-key> rwbarton: I'm usually pretty good about that, as you can see I'm not on my game at the moment :\
20:19:34 <any-key> perhaps I should take a break...
20:19:38 <any-key> thanks guys
20:36:59 <sizz> how do i take all list elements below a certain number, and none above that number?
20:37:15 <c_wraith> sizz: probably with filter
20:38:14 <copumpkin> anyone know how to programmatically hook the ghc invocation in Setup.hs and pass extra arguments to ghc before running it (in addition to the ones already being passed to it)?
20:38:21 <shachaf> (sizz forgot to mention: "and exactly half of the elements equal to that number?")
20:38:32 <copumpkin> looks like I need buildHook in the UserHooks structure, but I can't seem to find a way to pass args through to ghc
20:39:34 <shachaf> copumpkin: BuildFlags isn't it?
20:40:13 <copumpkin> yeah, but there's no documentation about what the list of args in it means (String, [String])? and glancing at the build function, it doesn't seem to do anything with those args anyway
20:42:35 <shachaf> copumpkin: Looks like the first String is the program name and the other Strings are the arguments for that program?
20:42:39 <shachaf> That's a bit of a weird interface.
20:42:50 <shachaf> I'm not sure this is what you're after anyway, though, indeed.
20:43:05 <shachaf> After all it runs GHC even with the defaultBuildHooks, which just has an empty list.
20:43:17 <copumpkin> yeah
20:43:28 <copumpkin> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/Cabal/src/Distribution-Simple-Build.html#build
20:43:34 <copumpkin> look at what it does with the Flags there
20:43:43 * hackagebot logic-classes 1.4.2 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.2 (DavidFox)
20:44:17 <shachaf> copumpkin: Well, buildProgramArgs is used in Distribution/Simple.hs
20:45:05 <shachaf> And it uses the (String,[String]) in Distribution/Simple/Program{.hs,/Db.hs}
20:45:56 <copumpkin> hmm, I see
20:47:14 <copumpkin> this is all so convoluted :P
20:56:01 <copumpkin> shachaf: it ignored them
20:56:02 <copumpkin> gah
20:56:34 <shachaf> Ignored what?
20:56:41 <copumpkin> the args I passed in that way
20:56:45 <shachaf> Oh.
20:56:47 <shachaf> Did you make it work?
20:56:55 <copumpkin> no
20:57:03 <copumpkin> I mean the invocation of ghc didn't have any extra flags on it
20:57:08 <copumpkin> but I did change the flags before passing them through
21:01:43 <copumpkin> ARGH
21:09:56 <gienah> copumpkin: wxc Setup.hs does lots of stuff with flags to build a C++ shared library, I guess messing with ghc flags would be similar
21:10:19 <copumpkin> well, it looks like even when I can pass flags through to ghc, ghc ignores them
21:10:23 <copumpkin> so I'm going to have to do something more hackish
21:10:56 <gienah> copumpkin: did you do that in the confHook?
21:11:20 <copumpkin> nope, I kind of changed my approach once I hardcoded ghc flags in there and it ignored them
21:11:30 <copumpkin> not much point trying to pass arguments in if it doesn't do anything with them
21:12:31 <copumpkin> I hate build crap :P
21:13:38 <gienah> a list of evil Setup.hs files on hackage: http://www.moonloop.net/haskell/docs/cbs-custom.html
21:13:59 <copumpkin> thanks :) that looks handy
21:24:11 * copumpkin shudders
21:45:33 <ezyang> Hyo folks. Weird version mismatch error:  Couldn't match expected type `attoparsec-0.10.1.0:Data.Attoparsec.Internal.Types.Parser                                     Data.ByteString.Internal.ByteString Value'                 with actual type `attoparsec-0.9.1.2:Data.Attoparsec.Internal.Types.Parser                                     Value'
21:45:54 <ezyang> But! In my command line, I have  -hide-all-packages ... -package attoparsec-0.10.1.0 -package aeson
21:46:27 <shachaf> ezyang: Maybe you're using a package that uses attoparsec-0.9.1.2?
21:46:42 <ezyang> -package base -package attoparsec-0.10.1.0 -package aeson -package xml -package transformers -package bytestring -package containers -package QuickCheck -package unordered-containers -package vector -package text-0.11.1.9 -package syb-0.3.6 -package split -package process -package parsec-3.1.2 -package mtl
21:46:46 <ezyang> I think aeson is the only one!
21:47:29 <shachaf> Hmm.
21:47:44 <shachaf> You could try hiding 0.9.1.2 temporarily and seeing what happens?
21:48:15 <ezyang> No dice. So I do think it's the package thing.
21:48:43 <shachaf> Do you even need attoparsec-0.9.1.2? You could try unregistering it. :-)
21:48:54 <ezyang> I think it came with HP?
21:48:58 <shachaf> Oh.
21:49:01 <shachaf> Does ghc-pkg have a way to list packages that depend on a package?
21:49:40 <ezyang> not in that direction, no.
21:50:53 <JoeyA> This might be helpful: http://packdeps.haskellers.com/  (googled 'hackage reverse dependencies')
21:50:56 <ezyang> oh wait, I'm wrong, attoparsec is not in HP
21:51:57 <ezyang> wtf. It doesn't show up in my package database. /usr/local/lib/ghc-7.0.4/package.conf.d /home/ezyang/.ghc/i386-linux-7.0.4/package.conf.d    attoparsec-0.10.1.1
21:52:27 <ezyang> ...oh.
21:52:46 <ezyang> LOL
21:52:56 <ezyang> I was picking up the wrong version of GHC; restarting my terminal fixed it.
21:53:00 <shachaf> Ah.
21:55:26 <Elemir> @hoogle String -> Maybe a
21:55:27 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
21:55:27 <lambdabot> Prelude fail :: Monad m => String -> m a
21:55:27 <lambdabot> Control.Monad fail :: Monad m => String -> m a
21:55:37 <JoeyA> I hate when I try a bunch of different things and nothing changes, only to find that I'm compiling a different file than I'm changing.  Not just because it wastes time, but because I "learn" things that aren't true about the language.
21:55:45 <Elemir> Network.CGI.Protocol?
21:56:19 <Elemir> WHY???
21:57:00 * Elemir wants maybeRead in base or another general-purpose package
21:57:09 <JoeyA> I agree
21:57:30 <JoeyA> It can be implemented it in terms of reads, but there's a lot of confusion surrounding what to do with ambiguous cases.
21:57:39 <JoeyA> Look at the source of readIO, for example.
21:57:50 <Elemir> @src readIO
21:57:51 <lambdabot> Source not found. You type like i drive.
21:58:02 <Elemir> Hem
21:58:17 <JoeyA> In particular: ... (x,t) <- reads s ; ("","") <- lex t ...
21:58:18 <JoeyA> lex???
21:58:28 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#readIO
21:59:02 <JoeyA> > reads "  3.14  "
21:59:03 <lambdabot>   []
21:59:09 <Elemir> Hem
21:59:13 <JoeyA> > reads "  3.14  " :: ReadS Int
21:59:14 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
21:59:14 <lambdabot>           ...
21:59:33 <Elemir> reads doesn't ignore starting symbols
21:59:41 <Elemir> > read "3.14" :: Int
21:59:42 <lambdabot>   *Exception: Prelude.read: no parse
21:59:46 <Elemir> > reads "3.14" :: Int
21:59:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:59:47 <lambdabot>         against inferred type ...
21:59:51 <JoeyA> > (reads :: ReadS Int) "  3.14  "
21:59:52 <lambdabot>   []
21:59:56 <JoeyA> > (reads :: ReadS Int) "3.14  "
21:59:57 <lambdabot>   []
21:59:59 <Elemir> Ah
22:00:00 <JoeyA> > (reads :: ReadS Int) "3"
22:00:01 <lambdabot>   [(3,"")]
22:00:03 <JoeyA> > (reads :: ReadS Int) "3 "
22:00:04 <lambdabot>   [(3," ")]
22:00:17 <JoeyA> > (reads :: ReadS Int) "3.14"
22:00:17 <lambdabot>   []
22:00:27 <Elemir> ReadS a === [(a, String)] ?
22:00:41 <JoeyA> type ReadS a = String -> [(a, String)]
22:00:46 <JoeyA> Pretty much
22:00:49 <Elemir> Ah, ok
22:01:43 <Liskni_si> does that lex part do anything else than all isSpace?
22:02:18 <Liskni_si> I thought it might tolerate comments, but it doesn't
22:03:12 <Elemir> @src reads
22:03:13 <lambdabot> reads = readsPrec minPrec
22:03:18 <Elemir> @src readsPrec
22:03:18 <lambdabot> Source not found. Maybe you made a typo?
22:03:38 <Elemir> lambdabot: You're stupid peace of code
22:03:58 <tgeeky__> lambdabot: oh yeah... well you're a stupid peice of human!
22:04:01 <JoeyA> What's worse: read is implemented differently than readIO, and I don't know why.  http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Read.html#read
22:04:51 <Elemir> O! ReadEither!
22:04:55 <Elemir> *readEither
22:05:35 <JoeyA> readEither isn't exported :(
22:05:48 <Elemir> Hem
22:06:27 <Elemir> Why base-writers love exceptions and errors?
22:13:15 <refold> Does anyone know why an empty declaration list is allowed in the let expression? E.g. 'let in 1' == '1'.
22:14:25 <Elemir> Why should it be disallowed?
22:14:32 <Elemir> > let in 100500
22:14:33 <lambdabot>   100500
22:15:58 <tgeeky__> i'm curious about this too
22:16:13 <zzing> Is there any guides on how to reason about programs by data flow in the fashion required by a purely functional language? I am thinking about a game as simple as the game of memory (the card version where you flip over two cards in hopes of matching them), and I can think about how it is done in imperative destructive update style, but not really in pure functional.
22:16:45 <refold> Elemir: Because empty let is redundant. Ocaml, for instance, makes 'let in 1' a syntax error.
22:18:19 <Elemir> Empty let is useful if you think about adding some declarations latter
22:18:56 <zzing> Elemir, premature optimization in the root of all evil.
22:19:09 <tgeeky__> zzing: this isn't premature optimization
22:19:24 <zzing> tgeeky_, It is optimizing your source code for something you might do
22:19:24 <Elemir> Optimization?
22:19:26 <refold> Elemir: Why an empty 'where' is not allowed then?
22:19:33 <copumpkin> …
22:19:35 <copumpkin> that's ridiculous
22:19:39 <tgeeky-> zzing: I don't see it. It's about syntax, or semantics, or both
22:19:59 <zzing> Optimization is not only about performance, it can also be about runtime structure too.
22:20:43 <zzing> Is there an implemenation of push-pull FRP for haskell?
22:20:52 <tgeeky-> zzing: several, I think
22:21:04 <copumpkin> the root of all evil is blindly adhering to maxims like "premature optimization in the root of all evil" and stretching them to encompass random shit
22:21:05 <Elemir> Ok, why do you use typed language?
22:21:20 <copumpkin> :P
22:21:43 <tgeeky-> Elemir: well, ignoring that it's redundant -- I think here "let in xxx" is always "xxxx" whatever the function? -- could it be useful in any way?
22:22:09 <copumpkin> @let the = const id
22:22:12 <lambdabot>  Defined.
22:22:14 <copumpkin> @let dogs = text "woof"
22:22:15 <lambdabot>  Defined.
22:22:17 <copumpkin> > let in the dogs
22:22:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
22:22:18 <lambdabot>    arising from a use of `...
22:22:21 <copumpkin> :(
22:22:44 <Elemir> :t let in the dogs
22:22:45 <lambdabot> forall a. a -> a
22:22:48 <copumpkin> :(
22:22:50 <Elemir> :t the dogs
22:22:51 <lambdabot> forall a. a -> a
22:22:56 <copumpkin> I messed up
22:23:07 <copumpkin> @undef
22:23:09 <copumpkin> @let the = id
22:23:10 <lambdabot>  Defined.
22:23:12 <copumpkin> @let dog = text "woof"
22:23:13 <lambdabot>  Defined.
22:23:15 <copumpkin> > let in the dog
22:23:16 <lambdabot>   woof
22:23:21 <zzing> sweet
22:23:21 <Elemir> > the dog
22:23:23 <lambdabot>   woof
22:23:35 <lemmalemmasatz> :D <3
22:23:40 <lemmalemmasatz> :t text
22:23:41 <lambdabot> String -> Doc
22:23:47 <tgeeky-> Elemir: copumpkin has demonstrated usefulness. Feature stays!
22:24:38 <tgeeky-> > let in dog
22:24:40 <lambdabot>   woof
22:25:56 <ski> > case let in () of () -> () where
22:25:57 <lambdabot>   ()
22:27:58 <ski> refold : ^ empty declaration list after `where' is allowed
22:28:26 <copumpkin> > case let in let 1 = 2 in () of () -> let in () where inlet = let in In
22:28:27 <lambdabot>   ()
22:29:00 <copumpkin> I guess I lost the emtpy where
22:29:45 <ski> also, i think that `<expr>' being equal to `let in <expr>' is a nice counterpart to `let <decls_0> in let <decls_1> in <expr>' being equal to `let <decls_0>; <decls_1> in <expr>' (assuming the variables bound by `<decls_0>' and the variables bound by `<decls_1>' are disjoint)
22:30:33 <monochrom> > let in (:[])0
22:30:34 <lambdabot>   [0]
22:30:47 <monochrom> ("let in the monkey robot" :) )
22:39:59 <refold> ski: thanks for the correction.
22:40:33 <twomashi> if I have  a type Maybe Maybe a
22:40:42 <twomashi> how do I apply (+1) to it
22:40:46 <copumpkin> fmap (fmap (+1))
22:40:59 <copumpkin> assuming you mean Maybe (Maybe Int)
22:41:02 <copumpkin> or something like that
22:41:03 <twomashi> I do
22:41:08 <ski> @type (fmap . fmap) (+ 1)
22:41:09 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 a)
22:41:17 <shachaf> @ty fmap fmap fmap (+1)
22:41:18 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Functor f, Functor f1, Num b) => f (f1 b) -> f (f1 b)
22:41:25 <shachaf> @ty fmap fmap fmap ((+) 1)
22:41:26 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Functor f, Functor f1, Num b) => f (f1 b) -> f (f1 b)
22:41:32 <copumpkin> I knew this would happen
22:41:33 <ski> @type (fmap . fmap) (+ 1) `asAppliedTo` Just (Just (42 :: Int))
22:41:34 <lambdabot> Maybe (Maybe Int) -> Maybe (Maybe Int)
22:42:17 <shachaf> copumpkin: It's the best thing about Haskell!
22:42:20 <shachaf> @ty fmap (fmap fmap fmap) (+) 1
22:42:20 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Functor f, Functor f1, Num b) => f (f1 b) -> f (f1 b)
22:42:24 <ski> @type \f -> (fmap . fmap) f `asAppliedTo` Just (Just undefined)
22:42:25 <twomashi> (fmap (fmap (+1))) (Just (Just 1))
22:42:25 <lambdabot> forall b a. (a -> b) -> Maybe (Maybe a) -> Maybe (Maybe b)
22:42:29 <twomashi> like that?
22:42:50 <ski> twomashi : yeah, or just `fmap (fmap (+1)) (Just (Just 1))'
22:42:53 <shachaf> @ty fmap fmap fmap fmap fmap fmap fmap (+) 1
22:42:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a. (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 a)
22:42:56 <shachaf> There we go.
22:43:03 <shachaf> No grouping-parentheses left.
22:43:04 <ski> .. or `(fmap . fmap) (+1) (Just (Just 1))'
22:43:29 <twomashi> ah i like that
22:43:37 <twomashi> what about using <$>
22:43:53 <twomashi> is a double infix even possible
22:44:18 <shachaf> > 1 :: (`Double`)
22:44:18 <ski>   ((1 +) <$>) <$> Just (Just 1)
22:44:19 <lambdabot>   <no location info>: parse error on input ``'
22:44:32 <ski> twomashi ^
22:44:45 <twomashi> ok, great
22:45:06 <shachaf> Of course, you don't gain much from that.
22:45:58 <twomashi> its not fair, im just starting with monads and i have 2 of the fuckers to deal wtih
22:46:34 <dibblego> twomashi: the point that is being shown-off here is that Functor composes, so if you have Functor f, Functor g, then you can get Functor (f . g)
22:46:50 <twomashi> I know that
22:46:54 <dibblego> twomashi: there are libraries for doing this
22:47:10 <dibblego> this is not true for Monad
22:48:26 <glguy> twomashi: This is a family-ish channel
22:49:24 <twomashi> ah, excuse me..
22:51:22 <TSC> The type families might have little type children
23:14:35 <OODavo> Is there a way to "fill in" type variables in GHCi's type printout? For example, :t join → join :: Monad m => m (m a) -> m a. Is it possible to specify :t join where m = [], and hence get the type :: [[a]] -> [a]?
23:15:04 <twomashi> define type signitures?
23:15:18 <twomashi> you hint ghc as to your intentions
23:16:37 <OODavo> I know I can do :t join :: [[a]] -> [a], but that requires me to write out the entire type signature myself. The functionality I mean is the ability to give a specific type variable (such as m) a value.
23:16:56 <Saizan> OODavo: sadly it's not possible to specify types for type variables like that, though it'd be nice to have in code too
23:16:58 <mzero> twomashi: I'm wondering if you had perhaps wanted to "collapse" the double Maybe there... did you really want Maybe Int, but ended up with Maybe (Maybe Int) ??
23:17:48 <mzero> :t join `asAppliedTo` [[undefined]]
23:17:49 <lambdabot> forall a. [[a]] -> [a]
23:17:57 <mzero> uhm, like that, OODavo ?
23:18:16 <OODavo> Ooh, yes, pretty much like that. What's this asAppliedTo function?
23:18:23 <copumpkin> it's const
23:18:24 <mzero> beats me - lambdabot has it
23:18:30 <copumpkin> :t asApplied to
23:18:31 <lambdabot> Not in scope: `asApplied'
23:18:31 <lambdabot> Not in scope: `to'
23:18:33 <copumpkin> :t asAppliedTo
23:18:34 <lambdabot> forall t b. (t -> b) -> t -> t -> b
23:18:37 <mzero> @src asAppliedTo
23:18:37 <lambdabot> Source not found. My mind is going. I can feel it.
23:18:37 <copumpkin> oh it's new
23:18:41 <copumpkin> but you see what it is
23:18:50 <copumpkin> the old one was asTypeIn
23:19:06 <Saizan> asAppliedTo :: (t -> b) -> t -> t -> b; asAppliedTo f x = f
23:19:19 <Saizan> it's still const with a different type :)
23:19:25 <copumpkin> yep
23:20:23 <OODavo> Perfect. Thanks. ^_^
23:40:33 <Saizan> @remember TSC The type families might have little type children
23:40:33 <lambdabot> Nice!
23:40:45 <copumpkin> preflex: seen kmc
23:40:45 <preflex>  kmc was last seen on ##c 30 days, 2 hours, 42 minutes and 11 seconds ago, saying: how so?
23:41:21 <shachaf> copumpkin: He's pretty active in some non-preflex channels.
23:45:09 <sordina> edwardk: Some other folks have been having that ghci segfault too. I just rebuilt ghc from the source dist of the same version and my problem went away.
23:45:28 <edwardk>  sordina : good to know
