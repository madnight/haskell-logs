00:00:40 <tkahn6> dmwit: i swear that parsec document has errors in the code _and_ in the EBNF given
00:01:30 <elliott> tkahn6: the parsec "tutorial" is actually docs for a very old version
00:01:44 <tkahn6> elliott: yeah but look at this: http://i.imgur.com/PwIxt.png
00:01:45 <elliott> zzo38: You can do that with a GADT.
00:01:52 <tkahn6> produkt and product?
00:02:01 <tkahn6> how does that last so long?
00:02:26 <edwardk> tkahn6: probably a translation
00:02:45 <tkahn6> edwardk: ah maybe
00:03:25 <tkahn6> elliott: do you know of a better resource?
00:05:43 <elliott> tkahn6: nope
00:05:46 <elliott> i just use the haddocks
00:05:52 <zzo38> elliott: I know what you can do with a GADT; but in this case what I mean is to make it an instance tag belonging to the type, so the type (Set Int) then would automatically contain the constraint (Ord Int) or (Set ((x ~ Int, Ord x) => x)) and functions would use the constraint contained in the type itself, not in the type of its constructors. GADT you can do that with the constructors but not the types themself
00:06:33 <tkahn6> elliott: do you use Text.ParserCombinators.Parsec or Text.Parsec?
00:08:58 <zzo38> See? It is different. Which means  (Set Int) becomes not even a valid type without (Ord Int), since there is no instance tag; and that two (Set Int) with two different instances (Ord Int) are two different types
00:10:42 <zzo38> Another problem occurs when a function inherits multiple instances, but that can be solved by using ~ in the constraints
00:11:59 <zzo38> Now what is wrong with this?
00:13:20 <elliott> tkahn6: latter
00:13:33 <tkahn6> elliott: thanks
00:17:41 <shergill> in ghci, is there a way to see all the variables/bindings/entities in scope?
00:18:27 <Cale> shergill: :browse ?
00:18:55 <Cale> maybe :browse *   specifically
00:19:51 <adnap> shergill: :show bindings
00:21:23 <shergill> Cale, adnap: thanks
00:22:17 <zzo38> Datatype contexts don't work. And, they are *not* the same as GADTs; so don't say use GADTs instead. Datatype contexts would be useful in the example edwardk gave with (Set Int) when you are overriding instances
00:25:46 <zzo38> Existing overlapping instances extension probably already has this problem so why don't you fix it by making datatype contexts to work?
00:31:58 <zzo38> GHC's DatatypeContexts are just GADTs but that is a stupid way, I think.
00:33:08 <Cale> zzo38: what? How is it not the same thing as using the GADT syntax?
00:33:49 <zzo38> Cale: Read the stuff I have written above.
00:34:26 <Cale> Oh, you want some kind of kinding restriction based on typeclasses?
00:34:48 <Cale> Typeclasses don't really exist at the level of kinds presently.
00:34:56 <zzo38> Cale: No.
00:35:57 <Cale> Then perhaps I don't understand what you're after.
00:36:37 <Cale> Presently, using GADT syntax will let you discharge class constraints on the parameter type simply by matching on the constructor.
00:36:41 <elliott> You're in good company
00:37:07 <zzo38> Cale: What I do mean, is:    data Ord x => X x = X x;  compareX :: X x -> X x -> Ordering;  compareX (X x) (X y) = compare x y;    Now, if you have a different instance of (Ord Int) in one module than another, the type (X Int) is a *different type* than (X Int) is in the other module with the different (Ord Int) instance.
00:37:14 <Cale> If you want to bind a variable for the whole structure, you can simply use @ then
00:38:04 <Cale> If you have two incompatible Ord instances, then you shouldn't be able to import both.
00:38:05 <zzo38> (You cannot currently do that very well (there is -XOverlappingInstances and so on but they have some weaknesses); I was suggesting another way to specify explicit priorities and local module instance overriding imported ones)
00:39:27 <zzo38> Cale: But sometimes you need to import two modules defining two different instance for the same thing; and that can cause a problem. Also, you might want to use a different instance than is in other module.
00:41:11 <Cale> Sure, but instances don't have names, so there's no way to avoid importing them. You're meant to use typeclasses and instances when the implementation for the typeclass operations is reasonably canonical anyway. So if that occurs, you pick an instance, and move it up the module hierarchy, and if you need another instance, then you make a newtype.
00:42:18 <elliott> Cale: zzo38 is suggesting a modification to change all that.
00:42:21 <elliott> If that helps.
00:43:25 <zzo38> Cale: I know; but sometimes the existing instance is wrong. And there is a way to invent syntax to avoid importing them:   import X.Y.Z hiding (instance Ord Int);   But there now is another problem: What if you have the (X Int) type and you want access to the other (X Int) type? Well, be able to perhaps do something like this:   (module X.Y.Z => X Int) to refer to the other (X Int) type if you need to do so
00:45:06 <Cale> The problem with not importing instances and replacing them with others, is that there may be code in the already-compiled module which uses the instance which you hid and replaced.
00:45:30 <Cale> Maybe that's okay, maybe it's not.
00:46:01 <zzo38> Cale: Well, that one then uses the instance in the already-compiled module, not your own (unless the instance is mentioned in the constraint of the function which uses the instance)
00:46:05 * hackagebot alpino-tools 0.2.0 - Alpino data manipulation tools  http://hackage.haskell.org/package/alpino-tools-0.2.0 (DanielDeKok)
00:46:25 <zzo38> And there is another reason I wanted instances with explicit priorities (like -XOverlappingInstances except that the priorities are explicit instead of implicit): To completely redefine the typeclasses while keeping them compatible with existing programs. So that I can define my own Functor, Applicative, Monad, etc, and have it be compatible both ways with existing programs.
00:47:28 <Cale> I think that's harder and probably more problem-inducing than just recompiling everything against the new version and making necessary refactorings.
00:47:58 <elliott> Wouldn't that require people to agree with zzo38's proposed changes?
00:50:31 <zzo38> Cale: How is that harder? (Anyways, I think existing extensions already do that; the problem is that you cannot explicitly control priorities and that the (Set Int) problem still exists (my new way of making datatype contexts work, by being instance tags, would solve this problem).)
00:53:47 <zzo38> Why did they implement -XIncoherentInstances if it will cause these problems, while they don't like my idea even though it will solve these problems?
00:55:20 <Cale> IncoherentInstances is really problematic too.
00:58:41 <zzo38> Cale: I know. That is why I ask, why is it implemented? My idea would solve some of its problems, but is still not implemented even though the one with problem does implemented.
00:59:13 <napping> IncoherentInstances was probably very easy to implement, just by skipping a check
00:59:24 <Cale> yes
01:01:22 <zzo38> napping: Yes, my idea is probably a bit more difficult to implement. There is -XOverlappingInstances which can select the most specific one. My idea you would need to add: * explicit priorities * instance tags * instance hiding
01:01:35 <napping> It sounds like that would take more than 10 minutes
01:02:10 <zzo38> And I do not know how difficult these three things are to implement; but I know the syntax for instance tags (which will reuse the datatype contexts syntax, but it now has a different meaning), and instance hiding (use hiding (instance ...)).
01:02:20 <zzo38> napping: I believe you.
01:02:46 <zzo38> (But just because it will take more than 10 minutes does not necessarily mean it will take a really long time too much)
01:03:13 <napping> incoherentinstances isn't meant to be used to have two different instances for the same thing in different parts of the program
01:04:22 <elliott> (*cough* reflection can do that *cough*)
01:05:51 <zzo38> One thing I tried to do once, using -XIncoherentInstances, when I defined     instance A x => B x; instance B x => A x;    that caused it to have instances for all types, which isn't what I intended.
01:06:06 * hackagebot reflection 0.9 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.9 (EdwardKmett)
01:06:09 <elliott> \o/
01:06:18 <edwardk> elliott's speed improvements are in =)
01:06:36 <elliott> also my portability impediments and ugliness amplifiers
01:06:56 <edwardk> its actually a lot easier to read now ;0
01:07:32 <shachaf> Does that mean Haskell is fast now?
01:07:40 <elliott> No.
01:07:45 <elliott> I wrote it in Ruby and used the FFI.
01:07:46 <edwardk> No, it means elliott is
01:08:18 <shachaf> edwardk++
01:09:06 <edwardk> shachaf: for an interesting result, check out https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs#L22
01:09:35 <edwardk> mgsloan: still around?
01:09:45 <zzo38> I could define my own Monad class but it would not be compatible with existing stuff using Monad. How to solve this problem?
01:10:07 <edwardk> zzo38: by building your own language where you don't have these backwards compatibility issues
01:10:24 <shachaf> edwardk: Is (<>) mappend?
01:10:28 <edwardk> shachaf: yeah
01:10:35 <Cale> Or by just replacing the Monad class in your GHC implementation and rebuilding everything against that, if push comes to shove.
01:10:37 <shachaf> I must be missing something. Why isn't it 2?
01:10:46 <edwardk> er it is =)
01:11:14 <elliott> Lift 2 <> Lift 2 might be a better example :p
01:11:20 <elliott> oh
01:11:27 <elliott> edwardk's result is wrong, heh
01:11:27 <edwardk> elliott: yeah but i want to show off mempty
01:11:33 <elliott> -- > ghci> with (Monoid (+) 0) $ mempty <> Lift 2
01:11:33 <elliott> -- > 0
01:11:34 <zzo38> Cale: I expect it will break *all* programs if I do that...
01:11:45 <Cale> zzo38: yep
01:12:07 <Cale> zzo38: But you want them to break so that you can fix them to work against the new version of Monad
01:12:19 <elliott> I wish unsafeCoerce could coerce away contexts.
01:12:20 <Cale> The compiler is being helpful and telling you what to fix :)
01:12:25 <edwardk> shachaf: the version in examples/Monoid.hs gets that right =)
01:12:44 <napping> elliott: can it coerce between contexts and normal arguments?
01:12:49 <shachaf> I have a theory that Haskell is a plot by the government to get programmers to depend on mechanical crutches and to stop being able to think about programs on their own.
01:12:54 <elliott> napping: no -- that's what I want
01:13:02 <elliott> you get an error about the context not being satisfied
01:13:03 <napping> I think I got that working oce
01:13:07 <elliott> because you "use" it, in your argument to unsafeCoerce
01:13:10 <elliott> oh hmm
01:13:14 <elliott> maybe I can put it in an existential
01:13:16 <sanjoyd> shachaf: I think that was Java.
01:13:21 <napping> it was a while ago, and broke after updates
01:13:22 <zzo38> Since everything will define an instance using >>= and some things might not have a Functor instance. Since I would have:   class Functor f => Monad f where { return :: x -> f x; join :: f (f x) -> f x; };    then all programs will break unless there is a way to define the compatibility somehow
01:13:34 <napping> yeah, you have to put an existential wrapper around it, and coerce the wrapped thing
01:13:42 <shachaf> sanjoyd: Java doesn't save you from thinking about your program!
01:13:57 <Cale> zzo38: That's right, you'll just have to fix all the instances.
01:14:12 <Cale> (Is that a problem?)
01:14:13 <elliott> napping: alas, i can't stuff it in such a wrapper because of a universal quantification
01:14:16 <napping> and read the RTS commentary a lot to be sure they are compatible
01:14:18 <sanjoyd> zzo38: why would you want to make all Functors Monads?
01:14:20 <elliott> (gives ambiguous type variable error)
01:14:34 <Cale> sanjoyd: That would make all monads functors
01:14:47 <zzo38> sanjoyd: That isn't what I am doing...
01:14:47 <Cale> sanjoyd: It's a superclass constraint on the class declaration of Monad
01:15:09 <napping> elliott: what is the type?
01:15:15 <elliott> napping: aha... wait... i think i've got it
01:15:19 <elliott> thanks for the idea!
01:15:35 <napping> if you search for unsafeAddressOf you might find what I did
01:15:48 <sanjoyd> I missed the first part of the discussion, but why not do a direct Monad m => Functor m if you want all Monads to be Functors?
01:16:05 <napping> hmm, that one might not actually involve context arguments
01:16:09 <shachaf> sanjoyd: That says "class", not "instance".
01:16:19 <elliott> <interactive>: internal error: stg_ap_p_ret
01:16:20 <elliott> woot!
01:16:29 <elliott> sanjoyd: That doesn't work.
01:16:30 <mgsloan> edwardk: yup!
01:16:42 <napping> elliott: this is where reading the commentary comes in
01:16:46 <elliott> yeah
01:16:53 <elliott> i haven't yet managed to get a data type that's compatible though
01:16:53 <sanjoyd> Oh, okay.
01:16:58 <edwardk> you had expressed some interest in using reflection to reify dictionaries right?
01:16:58 <elliott> and i've tried quite a few times
01:17:00 <sanjoyd> More theory I'll have to read.
01:17:05 <napping> perhaps a second level of boxing as well
01:17:14 <elliott> edwardk: me? well i'm wondering if it can't be used to implement reflection
01:17:18 <zzo38> I am redefining the class methods too so what you specify won't work
01:17:24 <elliott> edwardk: unsafeCoercing the (Reified s a) => ... into Reified_ s a -> ...
01:17:30 <elliott> where Reified_ is an explicit data-type representation of the dictionary
01:17:38 * mgsloan is currently writing haskell in the middle of a house party.. oh the devotion ;)
01:17:44 <elliott> i thought it was impossible because of RTS object layout, but if napping's got it working... might as well try
01:17:51 <edwardk> was that you? i had thought it was mgsloan =)
01:18:09 <napping> had it working many GHC releases ago
01:18:10 <elliott> oh, well, might have been both of us :)
01:18:13 <edwardk> ah
01:18:34 <edwardk> mgsloan: i reduced the amount of coded needed quite a bit
01:18:40 <elliott> napping: "unsafeAddressOf" turns up nothing, alas
01:18:49 <edwardk> https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs#L39
01:19:53 <elliott> edwardk: if i can't get this working I might actually try the foreign import prim thing, i've never written any Cmm
01:20:02 <edwardk> ah
01:20:15 <napping> http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/11071
01:20:26 <napping> here's the code I was thinking of, which doesn't involve contexts
01:20:31 <elliott> but it'd be nice if you could arrange a data type _just so_ and it'll look like a dictionary to the RTS
01:20:52 <elliott> napping: ah, that actually got turned up by the search, in an IRC log
01:20:55 <elliott> but i assumed it was unrelated
01:21:39 <mgsloan> yeah, we both expressed interest.  I'm interested in making a nice TH library for deriving dictionary instances, and maybe a library for dealing with dictionaries / doing OOP quasiquoters on top of that.  I'm not really a supporter of OOP or prototype based programming as a paradigm, but I do think the abstractions have their value
01:21:49 <elliott> oh!
01:21:52 <elliott> edwardk is thinking of mgsloan
01:21:56 <elliott> my reflection dictionary stuff was way back
01:22:29 <edwardk> mgsloan: well, if you see there, thats a way to get it down to only seven or so lines of stuff being generated by TH
01:22:45 <elliott> edwardk: what if I constructed a heap object with the FFI then accessed the pointer as a StablePtr?
01:22:55 <elliott> think *that* has any chance of working? :D
01:23:08 <edwardk> good luck
01:23:49 <mgsloan> edwardk: beautiful!
01:24:59 <mgsloan> There's been lots of talk of performance.  Will common-sub-expression stuff reduce a the overhead?  Is it at all possible to apply memoization to this?
01:25:30 <elliott> the performance was mostly in the low-level details, once per reify
01:25:37 <elliott> nothing particularly relevant to the performance of the dictionary stuff i don't think
01:25:49 <edwardk> mgsloan: these things get built once per reify, you can reflect it for free after that
01:26:00 <zzo38> Surely, yes; I did have idea, many idea, making up a new programming language, currently called Ibtlfmm. But the document is incomplete, I do not know everything about the document, some of my idea incomplete, possibly someone else can help too, I do not know how to make the implementation; so we should make up the "Ibtlfmm working group" so that everyone can discuss.
01:26:03 <edwardk> quite literally, because it just becomes an evaluated thunk
01:26:07 <mgsloan> edwardk / elliot: fantastic!
01:26:25 <dilinger> 23~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~3~5~5~5~5~5~
01:26:47 <elliott> zzo38: i suggest #ibtlfmm
01:27:06 <zzo38> elliott: You can suggest what you want; but IRC does not have documents on it
01:27:25 <zzo38> I do have an IRC service on my computer so I can put whatever channel I need but it won't help because IRC does not have documents on it.
01:27:31 <elliott> is ee
01:27:32 <elliott> *i see
01:29:04 <zzo38> But part of it can be an IRC channel (I can put it in my computer); the other part needs to be document, though; such as a git repository or wiki or something else
01:29:56 <elliott> whoa
01:29:58 <elliott> edwardk: it works
01:30:04 <edwardk> elliott: ?
01:30:17 <napping> the evil works again?
01:30:21 <edwardk> elliott: oh the foreign alloc stuff?
01:30:36 <elliott> edwardk: nope, just plain unsafeCoerce
01:30:45 <edwardk> what are you coercing?
01:30:47 <edwardk> the dictionary?
01:30:47 <napping> unsafeCorce# between contexts and arguments? Show a paste?
01:30:55 <elliott> edwardk: lemme hpaste
01:31:12 <elliott> one sec
01:31:35 <edwardk> elliott: this may make that constraints module a lot nicer =)
01:31:43 <hpaste> elliott pasted “whoa” at http://hpaste.org/66547
01:31:51 <elliott> now let me try it with the type family version
01:32:34 <edwardk> elliott: cute =)
01:33:00 <elliott> doesn't work with the type family version, gonna need some more wrangling
01:33:12 <elliott> edwardk: i guarantee that's about 5000x faster than the current impl
01:33:17 <edwardk> yeah
01:33:24 <edwardk> benchmark!
01:33:25 <edwardk> =)
01:33:31 <elliott> gotta make it work with TFs first!
01:33:46 <edwardk> =)
01:34:28 <elliott> weird "untouchability" errors
01:35:16 <edwardk> oh, yeah i guess you're going to get equality constraints that get witnessed as extra 0-width arguments, etc.
01:35:24 <elliott> no, not at runtime
01:35:25 <elliott> at compile-time
01:35:34 <elliott> it won't let me put the k in the Ctx box
01:35:54 <hpaste> elliott annotated “whoa” with “whoa (broken)” at http://hpaste.org/66547#a66548
01:36:11 <hpaste> elliott annotated “whoa” with “whoa (broken) (error)” at http://hpaste.org/66547#a66549
01:37:17 <elliott> really strange
01:37:18 <edwardk> clearly you need to replace those data types with newtypes for efficiency ;)
01:38:06 <elliott> even making the "a" and "w" existential doesn't help
01:38:12 <elliott> since when were there values you couldn't fit in boxes?
01:38:49 <elliott> it's the ~ messing things up... hmm
01:39:01 * elliott tries passing it as an equality GADT instead
01:40:06 <DijkstraGroupie> @hoogle bool xor
01:40:06 <lambdabot> No results found
01:40:20 <DijkstraGroupie> Does Haskell have no standard Boolean xor?
01:40:27 <shachaf> It's called (/=)
01:40:32 <edwardk> elliott: thats what i was talking about being passed as a 0 width argument
01:40:33 <DijkstraGroupie> oh, lol yeah
01:40:35 <DijkstraGroupie> stupid me
01:40:44 <elliott> edwardk: right, but why would that be a _type_ error?
01:41:03 <edwardk> you could probably pass it a State# RealWorld ;)
01:41:14 <elliott> aha
01:41:16 <elliott> got it!
01:41:28 <edwardk> (Proxy s -> a) -> State# RealWorld -> Proxy s -> w  -- or something evil
01:41:29 <jfischoff> shachaf: is there a bitwise xor?
01:41:29 <edwardk> ?
01:41:46 <shachaf> jfischoff: Yes. It's called "xor".
01:41:52 <shachaf> @ty xor
01:41:52 <lambdabot> forall a. (Bits a) => a -> a -> a
01:41:53 <jfischoff> hehe
01:41:59 <edwardk> elliott: paste?
01:42:11 <hpaste> elliott pasted “whoa 2” at http://hpaste.org/66550
01:42:21 <shachaf> Is there a function :: Bits a => (Bool -> Bool -> Bool) -> a -> a -> a?
01:42:29 <elliott> edwardk: anyway, I really don't understand your State# RealWorld suggestion -- the problem is not in the coercing
01:42:34 <elliott> the problem is that I can't even get it inside a data type
01:42:38 <edwardk> hrmm
01:42:39 <elliott> even if I completely ignore the value it's a type error
01:42:42 <elliott> but that whoa 2 paste works
01:42:48 <elliott> at the expense of being more involved than the fundep version
01:42:50 <edwardk> working on your new one for a sec
01:43:22 <napping> it was an error just to write Ctx?
01:43:36 <elliott> napping: No, undefined (Ctx k) as the definition gave an error
01:43:57 <elliott> see http://hpaste.org/66549 for the error
01:44:36 <elliott> edwardk: btw, an additional mystery (as if we didn't have enough)
01:44:47 <elliott> example :: Int; example = reify 42 (\p -> reflect p + reflect p) -- works with fundeps
01:44:52 <elliott> example :: Int; example = reify (42 :: Int) (\p -> reflect p + reflect p) -- works with type families
01:45:03 <elliott> example :: Int; example = reify 42 (\p -> reflect p + reflect p) -- doesn't work with type families, says it can't match Integer with Int(?!)
01:45:30 <elliott> i guess it's defaulting 42 to Integer and it doesn't realise that Reflected s determines w
01:45:33 <edwardk> thats because it defaulted the 42
01:45:35 <elliott> yeah
01:45:48 <elliott> starting to prefer the fundep interface at this rate :p
01:45:55 <edwardk> this was the complaint i had about the type family version
01:45:56 <edwardk> yeah
01:46:37 <elliott> i dunno
01:46:49 <elliott> i'd be happier if i could figure out wtf was causing that type error
01:47:04 <edwardk> technically one should probably seq the function before coercing it
01:47:23 <edwardk> just from a correctness standpoint since dictionaries are always forced
01:47:26 <elliott> oh yeah
01:47:53 <elliott> edwardk: doesn't work
01:47:55 <elliott> I can't do "k `seq`"
01:47:58 <napping> I think things can go wrong more easily if it's an unevaluated thunk as well
01:48:02 <edwardk> not k
01:48:05 <elliott> because you can't talk about k unless it's shoving it in a Ctx
01:48:12 <elliott> edwardk: oh that function
01:48:13 <elliott> right
01:48:16 <edwardk> (k $! const a) Proxy
01:48:32 <elliott> *(unsafeCoerce Refl) Proxy for the tf version, yeah
01:49:48 <edwardk> oooh
01:49:51 <edwardk> @hpaste
01:49:51 <lambdabot> Haskell pastebin: http://hpaste.org/
01:50:08 <hpaste> edwardk pasted “evil reflection” at http://hpaste.org/66551
01:50:50 <elliott> edwardk: oh, that's great
01:51:02 <elliott> edwardk: any luck TF-wise? :(
01:51:09 <edwardk> haven't tried
01:51:24 <elliott> i can't believe nobody's thought of this enough to get it working before
01:51:32 <elliott> oh have you checked whether this works compiled? I haven't
01:51:52 <edwardk> i'd probably {-# NOINLINE the heck out of it #-}
01:52:03 <edwardk> not that there is much heck to NOINLINE
01:52:11 <elliott> actually I think inlining reify should be perfectly safe
01:52:20 <gspr> The functioins in the mmap interface in System.IO.MMap all seem to operate on FilePaths. If I've already opened the file in question using System.Posix.IO (or FFI), can I still use the MMap interface?
01:52:36 <gspr> (Alternatively: Is there a version of the mmap interface that operates on file descriptors?)
01:52:49 <gspr> *functions
01:52:59 <elliott> edwardk: "p s -> a" in the typeclass doesn't break it btw
01:53:03 <edwardk> it works with -fobject-code
01:53:17 <edwardk> oh yeah
01:53:32 <elliott> what was the benefit to the type family-based interface again?
01:54:06 <edwardk> mostly that it was possible ;)
01:54:13 <elliott> edwardk: btw, you can rewrite reify's body as unsafeCoerce (Ctx k) $! const a $ Proxy
01:54:15 <elliott> looks a bit nicer :p
01:54:28 <edwardk> is that correct here?
01:54:54 <elliott> oh!
01:54:54 <elliott> oops
01:54:59 <elliott> that's the thing about unsafeCoerce...
01:55:02 <edwardk> yeah
01:55:12 <oleiade> Hi everyone :-)
01:55:18 <edwardk> you'd need the $! and $ with flipped fixities that don't exist
01:55:18 * elliott suggests renaming Ctx -> Box, since there's only one data type now...
01:55:20 <edwardk> heya oleiade
01:55:28 <oleiade> edwark :-)
01:55:34 <edwardk> well its a newtype, not even a Box
01:55:45 <elliott> newtype Facade a w = ...
01:55:47 <elliott> newtype Trick a w = ...
01:55:49 <gspr> Come to think of it, I guess my question isn't really a Haskell one afterall. Somewhere, some place, I guess all the functions that open files using FilePaths call the open() system call at some point... thus I guess I'm fine -- I'm just open()ing the same file multiple times
01:55:49 <elliott> newtype Evil a w = ...
01:56:00 <edwardk> Magic
01:56:06 <elliott> yes :)
01:56:23 <elliott> so uh... is this reflection 0.10? :P
01:56:45 <oleiade> I'm tryin to map a Data constructor over a list of strings in an IO monad, but can't get it to work, anyone can help please? :-) https://gist.github.com/2321024
01:56:53 <elliott> edwardk: oh! i'll benchmark it
01:57:02 <oleiade> I'd like to replace mapM_ print by mapM_ mkNode ideally
01:57:15 <oleiade> but there seems to be a monadic problem
01:57:32 <oleiade> and as the newbie I am I don't understand it
01:57:35 <edwardk> benchmark away
01:58:32 <elliott> hahahahaha
01:58:37 <elliott> edwardk: 130ms vs 6ms
01:58:42 <edwardk> elliott: nice
01:58:53 <edwardk> i'm willing to give up portability and sanity for that ;)
01:58:53 <elliott> it's literally free, it's just a function call
01:59:03 <edwardk> or at least make an option for it
01:59:14 <oleiade> anyone can help ? :P
01:59:17 <edwardk> flag Turbo
01:59:20 <elliott> edwardk: it's not like the current code will work on anything but GHC in the next five years
01:59:25 <edwardk> oleiade: yeah, one minute
01:59:37 <elliott> edwardk: and it doesn't support 128-bit archs either :P
01:59:45 <mauke> oleiade: what would that do?
01:59:50 <oleiade> edwardk: no prob thank BTW!
02:00:06 <edwardk> can't remember Data.List.Split =)
02:00:15 <oleiade> mauke: ideally, I'd like to replace the print call in mapM_ with the mkNode constructor :-)
02:00:19 <mauke> oleiade: what would that do?
02:00:30 <edwardk> splitOn is giving you a list of strings there right?
02:00:40 <oleiade> edwardk: absolutly :-)
02:01:05 <edwardk> map (splitOn "\t") (lines f) is giving you a list of lists of strings
02:01:32 <edwardk> now if we map (MkNode . splitOn "\t") (lines f) -- we'd be getting a list of nodes
02:01:39 <edwardk> but your problem is Node holds the wrong things
02:01:48 <edwardk> Source Property, Destination Value
02:01:49 <edwardk> oh
02:01:53 <edwardk> you have them as strings
02:02:07 <oleiade> edwardk: yes it's just convinience types :-)
02:02:15 <oleiade> edwardk: to keep it readable in the end :-)
02:02:17 <edwardk> @hpaste
02:02:17 <lambdabot> Haskell pastebin: http://hpaste.org/
02:02:35 <mauke> :-[
02:03:04 <edwardk> mapM_ (print . mkNode . splitOn "\t") (lines f)
02:03:34 <edwardk> will take the lines and for each one, split it, make a node and print it to show you it
02:03:56 <oleiade> edwardk: you solution seems to perfectly make the trick!
02:04:07 <edwardk> if you want to do more with it after that, do something like let nodes = map (mkNode . splitOn "\t") (lines f)
02:04:21 <edwardk> then you can use the nodes as a list of nodes in subsequent statements in the do block
02:04:21 <oleiade> edwardk: even if I'm not sur I understood the usage of function composition here
02:04:56 <oleiade> edwardk: thank you very much :-)
02:05:00 <edwardk> oleiade: splitOn "\t" takes a strings and gives you a list of strings, mkNode takes that list of strings and gives you a node
02:05:04 <edwardk> print prints that node
02:05:31 <edwardk> mapM_ … (lines f)  repeats the … part for every line of f
02:05:46 <oleiade> so it's just like I to made the return of splitOn "\t", the param of mkNode in the end?
02:05:56 <edwardk> yeah
02:05:59 <edwardk> :t (.)
02:06:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:06:08 <edwardk> gah
02:06:09 <oleiade> but how splitOn \t nows that it's second parameter is (lines f) here? :-)
02:06:11 <zzo38> Please tell me in case of anything you like/dislike/question/complain about dvi-processing package. It is now work the Haddock document; so you can read it. Also in case you have suggestion. I already added vertical alignment (not yet posted), and I intend to add mathematical typesetting, and drawings, and other paragraph typesetting. Any other idea please tell to me
02:06:20 <edwardk> (.) :: (b -> c) -> (a -> b) -> a -> c
02:06:24 <oleiade> *knows*
02:06:37 <edwardk> in haskell we curry functions
02:06:44 <edwardk> :t (+)
02:06:44 <lambdabot> forall a. (Num a) => a -> a -> a
02:06:47 <edwardk> :t (+) 1
02:06:48 <lambdabot> forall t. (Num t) => t -> t
02:06:52 <edwardk> :t (+) 1 2
02:06:52 <lambdabot> forall t. (Num t) => t
02:07:07 <edwardk> if you under apply a function you get a function that wants more arguments
02:07:09 <oleiade> edwardk: yes I remember that, but every functions are naturally currified?
02:07:17 <edwardk> oleiade: yes
02:07:23 <edwardk> :t split
02:07:23 <elliott> edwardk: oh, there is a drawback to fundep based api
02:07:23 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:07:24 <elliott> instance (Reifies s (Monoid_ a)) => Monoid (M a s) where
02:07:26 <oleiade> edwardk: I wasn't aware, thanks! :-)
02:07:26 <edwardk> :t splitAt
02:07:26 <elliott> requires undecidableinstances
02:07:27 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:07:43 <edwardk> elliott: oh?
02:07:47 <elliott> edwardk: or, hmm
02:07:50 <elliott> maybe it does with the original too
02:07:51 <edwardk> we didn't have any instances
02:07:53 <elliott> does Monoid.hs work for you?
02:07:57 <elliott> i mean the example
02:08:03 <elliott> with current reflection, not this unsafeCoerce thing
02:08:28 <edwardk> compiles for me
02:08:29 <edwardk> hrmm
02:08:32 <zzo38> Does *anyone* in here can tell me about the dvi-processing?
02:08:40 <elliott> edwardk: right
02:08:50 <elliott> edwardk: meh, UndecidableInstances isn't really a big deal
02:09:03 <edwardk> i'm not using it in here
02:09:09 <edwardk> not sure i see what you're saying
02:09:18 <elliott> edwardk: I mean that the fundep-based API requires UndecidableInstances for that example
02:09:25 <elliott> whereas the TF-based API doesn't
02:09:32 <edwardk> oh yeah
02:09:36 <edwardk> that was one difference
02:10:00 <elliott> I actually prefer the user code look of the fundep API
02:10:17 <edwardk> yeah but then i need to change the names back to Reifies ;)
02:10:53 <edwardk> it is scary that its a 4 line module
02:10:57 <elliott> yeah but that restores compatibility with yesterday!
02:11:05 <elliott> i actually just made the changes here and updated the examples to test out
02:11:17 <zzo38> Does anyone interest in typesetting in Haskell?
02:14:53 <roconnor__> merge :: (CA a b) -> (CA b c) -> (CA (Either a b) c)  appears to be definable for any coalgebra CA.
02:15:17 <mauke> putting the coal into coalgebra
02:15:18 <roconnor__> so what is the dual algebra version?
02:15:54 <edwardk> hopefully something with fewer prophylactic parens ;)
02:16:49 <elliott> edwardk: i pushed it to https://github.com/ehird/reflection/commits/master :p
02:16:58 <elliott> I think the Constraints example won't work without UndecidableInstances but I don't have the necessary deps to check it
02:17:49 <edwardk> i kinda want to get the TF version wrking
02:18:11 <edwardk> eg. using Data.Eq.Type for the Equal
02:18:12 <elliott> edwardk: well i did get it working
02:18:15 <elliott> yes, doing that
02:18:17 <elliott> except i rewrote my own
02:18:18 <elliott> did you not see?
02:18:20 <edwardk> well, i mean suitably streamlined
02:18:23 <edwardk> i saw it
02:18:25 <elliott> right
02:18:36 <elliott> i'll try and streamline it, we know the Fun isn't necessary at least
02:18:59 <elliott> oh the Data.Eq.Type suggestion is clever
02:19:12 <elliott> introduces groupoids + semigroupoids deps though :P
02:19:25 <edwardk> oh yeah
02:19:32 <edwardk> meh
02:19:54 <edwardk> wonder if i can mangle the version with the ~ in it
02:20:12 <elliott> well my version's interface has a ~ in it
02:20:16 <elliott> it's only the internals that don't
02:20:42 <edwardk> ah
02:20:49 <edwardk> and it require a GADT =/
02:21:15 <elliott> yeah, I'm trying to fix that now
02:21:23 <elliott> but I'm not sure there's any other way to get a ~ in
02:21:25 <edwardk> i wonder how bad this hack will work
02:21:28 <edwardk> i have an idea ;)
02:21:33 <elliott> oh boy
02:21:42 <elliott> if this works, you have to call the result 1.0 :P
02:21:55 <edwardk> i was planning on it =)
02:23:50 <gspr> Vague question: Is there something in particular I should think about or do when calling ioctl from haskell?
02:25:59 <edwardk> elliott: i at least now get the untouchable errors, hrmm
02:27:01 <elliott> edwardk: yes, it's very strange
02:27:14 <elliott> edwardk: it's almost like it thinks the (Reflected s ~ a) constraint is on the constructor
02:27:19 <elliott> not something the function inside gets
02:27:30 <elliott> what is your ide?
02:27:31 <elliott> *idea
02:28:18 <edwardk> i was trying to convert it to other things of the appropriate width
02:29:10 <elliott> like i keep saying, it's not the conversion that's the problem, it's getting it into something that you can convert in the first place :p
02:29:15 <edwardk> sure
02:29:52 <edwardk> hence why i was trying for other things that had the right size but wouldn't complain about touchability ;)
02:30:35 <elliott> right... wouldn't that mean the exposed API would be wrong, though?
02:30:43 <elliott> because you couldn't have the ~, just something with the same width
02:31:08 * hackagebot repa 3.1.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.0.1 (BenLippmeier)
02:31:10 * hackagebot repa-algorithms 3.1.0.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.1.0.1 (BenLippmeier)
02:31:12 * hackagebot repa-io 3.1.0.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.1.0.1 (BenLippmeier)
02:32:13 <roconnor__> comerge :: (f (Either a b) -> c) -> (f a -> c, f b -> c)
02:32:26 <roconnor__> I think this is the algebra version
02:34:18 <elliott> edwardk: btw, where does the "w" name come from?
02:34:29 <edwardk> i don't remember =)
02:34:41 <edwardk> i usually use 'r' for that sort of thing now
02:35:20 * elliott too
02:35:44 <elliott> i wonder if this mightn't be a ghc bug
02:35:53 <gimm> CIAO A TUTTI
02:36:53 <edwardk> 'hey ghc devs can you fix this thing that might or might not be a bug so we can break a huge pile of invariants in your compiler to put go faster stripes on something nobody uses? k thx'
02:37:23 <shachaf> @remember edwardk 'hey ghc devs can you fix this thing that might or might not be a bug so we can break a huge pile of invariants in your compiler to put go faster stripes on something nobody uses? k thx'
02:37:23 <lambdabot> Nice!
02:37:27 <shachaf> Ah, the Haskell spirit.
02:37:38 <shachaf> (I thought the Haskell spirit was not caring about performance at all.)
02:40:47 <elliott> edwardk: what if you moved the ~ constraint right of the Proxy s ->?
02:40:54 <roconnor__> edwardk: use speed holes
02:40:56 <edwardk> didn't work for me
02:41:08 * hackagebot gloss 1.7.2.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.2.1 (BenLippmeier)
02:41:10 * hackagebot gloss-raster 1.7.2.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.2.1 (BenLippmeier)
02:41:12 * hackagebot gloss-examples 1.7.2.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.2.1 (BenLippmeier)
02:42:41 <elliott> :(
02:49:09 <Taneb> Hello!
02:49:59 <Taneb> If I have an IOUArray Int Word8, and I want some form of FooArray Word16 Word16 by combining the Word8's, how would I go about doing this
02:50:28 <elliott> edwardk: so does it look like the TF-based implementation is a dead end without GADTs?
02:50:34 <edwardk> nah
02:50:42 <edwardk> oh
02:50:42 <edwardk> yeah
02:50:46 <edwardk> i have the GADTs turned on
02:50:55 <edwardk> thats fine i suppose
02:51:09 <edwardk> for 50x performance i'm willing to sell off my grandmother ;)
02:51:25 <elliott> i wonder if the gadt one can be simplified... hmm
02:51:40 <edwardk> i have a flag for compiling with the 'slow' version we had before
02:52:08 * roconnor__ wonders if it is time to push data-lens 2.9.0
02:52:43 <elliott> edwardk: if you want to maintain that mess, be my guest :P
02:52:52 <elliott> I doubt it'll work on any compiler that isn't GHC in the next 5 years
02:53:16 <edwardk> hah
02:53:22 <Taneb> I wish I knew anyone who was interested enough in programming genealogy software to discuss an API with me
02:53:55 <hvr> roconnor__: what's planned for 2.9.0?
02:54:00 <Taneb> Then I'd be confident enough to maybe eventually put this thing on Hackage
02:54:58 <elliott> edwardk: i removed GADTs dep
02:55:04 <elliott> oh darn not quite
02:55:04 <elliott> hmm
02:55:14 <edwardk> so close
02:56:07 <roconnor__> hvr: incorporating partial-lenses
02:56:25 <hpaste> elliott pasted “as it stands” at http://hpaste.org/66553
02:56:27 <elliott> here's what i have so far
02:58:10 <edwardk> thats more or less exactly what i have modulo formatting
02:58:29 <elliott> edwardk: with that def of Equal? I was trying to get something that would de-GADT itself more easily
02:58:31 <edwardk> if you nest reify' like that you can probably avoid passing it a
02:58:39 <elliott> oh, indeed
02:58:40 <elliott> ooh an idea
02:58:41 <edwardk> thats the same thing a GADT desugars to
02:59:16 <elliott> edwardk: actually removing a breaks it
02:59:18 <elliott>     Cannot deal with a type function under a forall type:
02:59:28 <hvr> edwardk: btw, I was missing a 'conditional update' operator in the data-lens API, i.e. something along ':: Lens a b -> (b -> Maybe b) -> a -> a'
02:59:31 <edwardk> when you have Equal :: Equal a a ?
02:59:48 <elliott> edwardk: untouchable error
02:59:50 <edwardk> hvr: talk to roconnor__ =) he owns it now =)
02:59:56 <edwardk> elliott: interesting
03:00:09 <hvr> roconnor__: btw, I was missing a 'conditional update' operator in the data-lens API, i.e. something along ':: Lens a b -> (b -> Maybe b) -> a -> a' :-)
03:00:12 <edwardk> oh you don't unsafeCeroce your Refl
03:00:14 <elliott> oh
03:00:17 <elliott> that explains it
03:00:23 <edwardk> thats about the only difference we have
03:00:29 <elliott> nope
03:00:31 <elliott> still untouchable
03:00:33 <elliott> can you hpaste your code?
03:00:38 <elliott> i have an idea for removing the gadt
03:00:44 <edwardk> @hpaste
03:00:44 <lambdabot> Haskell pastebin: http://hpaste.org/
03:00:59 <hpaste> edwardk pasted “this works” at http://hpaste.org/66554
03:01:44 <elliott> edwardk: shadowing Prelude.Eq I see :P
03:01:55 <edwardk> er Equal
03:02:00 <edwardk> i edited it at the last second
03:02:03 <elliott> heh
03:02:21 <elliott> my idea is
03:02:23 <elliott> newtype Equal a b = Equal (forall r. ((a ~ b) => r) -> r)
03:02:30 <elliott> and constructing a magicEqual :: Equal a b
03:02:33 <elliott> that passes the dummy argument in
03:02:37 <elliott> oh wait
03:02:46 <elliott> that's the same thing we're trying to do in the first place!
03:03:13 <qnikst> does smb has experience with conduit-0.4? I have some troubles rewriting code from conduit-2 to conduit-4
03:03:27 <edwardk> if you have type families, you have GADTs, so i'm not too worried about the extension
03:03:54 <elliott> fair enough
03:03:59 <hvr> qnikst: asking snoyman directly usually results in quick responses...
03:04:40 <edwardk> besides i can take the 'slow' flag off of manual: true
03:04:44 <edwardk> and it'd just do the right thing
03:04:53 <roconnor__> hvr: that seems reasonable
03:05:13 <killy9999> what do I need to do to build Haddock documentation using cabal?
03:05:27 <elliott> edwardk: manual: true?
03:05:32 <qnikst> hvr, I know but I don't want to annoy him, if I can get answer from community )
03:05:32 <edwardk> for the flag
03:05:39 <elliott> you mean making slow the default?
03:05:43 <elliott> that would be silly
03:05:43 <edwardk> so it'll allow it to be considered when you don't have GADTs
03:05:47 <elliott> ah
03:05:50 <edwardk> no default: false; manual: false
03:05:58 <elliott> right
03:05:59 <qnikst> killy9999: run cabal[-dev] haddock?
03:06:16 <hvr> roconnor__: my motivation btw is to achieve zero-copy for large records, and increase data-sharing potential (as the (^!%=) operator /always/ copies the constructor)
03:06:24 <roconnor__> I wonder if we need a function (a -> Maybe a) -> (a -> a)
03:06:28 <killy9999> qnikst: I tried, but I get "cabal: buildTypeAction UnknownBuildType"
03:06:30 <roconnor__> in Data.Maybe
03:07:24 <hvr> roconnor__: or does the (^!%=) use some unsafe-pointer-compare trick?
03:07:47 <roconnor__> then hvr's request would be a compostions of (^%=) and that
03:07:49 <roconnor__> er
03:07:56 <hvr> roconnor__: to check whether the (b -> b) operation was 'id'
03:08:01 <roconnor__> my client ate an % sign
03:08:07 <roconnor__> % % %% %%
03:08:14 <roconnor__> then hvr's request would be a compostions of (^%%=) and that
03:08:16 <elliott> %
03:08:27 <sipa> hungry client
03:08:29 <roconnor__> hvr: there is no unsafe anything
03:09:01 <roconnor__> BTW, what sort of name is (^%%=) ?
03:09:14 <elliott> edwardk: btw i bet that this implementation would work on a hypothetical UHC with type families + gadts
03:09:21 <elliott> i think jhc too although i'm not sure when it uses dictionary passing
03:09:33 <roconnor__> @hoogle (a -> Maybe a) -> (a -> a)
03:09:34 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
03:09:34 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
03:09:34 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
03:09:44 <edwardk> elliott: well the slow one is safe everywhere at least
03:09:55 <roconnor__> @type fromMaybe
03:09:56 <lambdabot> forall a. a -> Maybe a -> a
03:09:57 <edwardk> i know nhc would flip out, heck even casting a newtype
03:09:57 <timthelion> Is there a function that looks like filterToTuple isEven [1,2,3,4] == ([2,4], [1,3])?
03:10:16 <roconnor__> @type join fromMaybe
03:10:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
03:10:17 <lambdabot>       Expected type: a -> a -> a
03:10:17 <lambdabot>       Inferred type: a -> Maybe a -> a
03:10:26 <elliott> edwardk: not true!
03:10:29 <edwardk> i love how the thing we spent all day on is now the 'slow' version
03:10:35 <elliott> edwardk: it won't work on platform with pointers above 64 bits
03:10:38 <elliott> platforms
03:10:43 <edwardk> ok, every place that exists ;)
03:11:01 <elliott> does the slow version really work on nhc? i'm not convinced any implementations other than GHC exist that will run it :P
03:11:07 <roconnor__> @pl (\f a -> f . fromMaybe a)
03:11:08 <lambdabot> (. fromMaybe) . (.)
03:11:10 * hackagebot gloss-examples 1.7.2.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.2.2 (BenLippmeier)
03:11:11 <edwardk> me neither
03:11:13 <roconnor__> @type (\f a -> f . fromMaybe a)
03:11:15 <lambdabot> forall a b. (a -> b) -> a -> Maybe a -> b
03:11:32 <roconnor__> er
03:11:44 <roconnor__> @type (\f a -> fromMaybe a (f a))
03:11:45 <lambdabot> forall a. (a -> Maybe a) -> a -> a
03:11:49 <roconnor__> @pl (\f a -> fromMaybe a (f a))
03:11:49 <lambdabot> ap fromMaybe
03:11:59 <roconnor__> Mmm S.
03:13:12 <adnauseam> would anyone have an idea as to how to go on to fixing this issue http://pastebin.com/mcNX4DJS
03:13:14 <mauke> The paste mcNX4DJS has been copied to http://hpaste.org/66556
03:13:25 <adnauseam> i'm still stuck
03:14:27 <MagneticDuck> Hey there wonderful citizens of #haskell
03:14:35 <MagneticDuck> Have a question about Haskell style
03:14:56 <timthelion> adnauseam: you seem to have the wrong version of cabal, which do you have?
03:15:17 <MagneticDuck> Here it is: if I want to make a function like readTable that takes a FilePath and gives you [[String]] (csv format) I should encapsulate the result in IO, right?
03:15:31 <MagneticDuck> readTable :: FilePath -> IO [[String]]
03:15:35 <MagneticDuck> But do I have to?
03:16:08 <adnauseam> timthelion: i have apt-get purged my cabal install
03:16:08 <MagneticDuck> I could write it so it just gives you [[String]] without IO?
03:16:10 <bitonic> MagneticDuck: if you want to read a file, you have to do it in a IO action.
03:16:14 <MagneticDuck> Yeah I know
03:16:18 <MagneticDuck> However...
03:16:26 <MagneticDuck> Oh wait
03:16:31 <adnauseam> timthelion: when i do install the apt-get version, it throws an array of different errors
03:16:34 <timthelion> adnauseam: but it's still detecting a cabal.
03:16:38 * killy9999 is also interested in finding answer to MagneticDuck's question
03:16:40 <bitonic> MagneticDuck: you can, of course, write a function 'String -> [[String]]'
03:16:47 <MagneticDuck> Yeah
03:16:48 <timthelion> adnauseam: Cabal is already installed and the version is ok.
03:16:52 <bitonic> and feed that function the contents of the file
03:16:54 <adnauseam> strange :/
03:17:02 <MagneticDuck> And isn't there just a function that FilePath -> String?
03:17:05 <MagneticDuck> Is it possible?
03:17:08 <killy9999> I was thinking about it came up with a conclusion that
03:17:09 <MagneticDuck> To make one?
03:17:19 <bitonic> MagneticDuck: you can with GHC, but you don't want to.
03:17:29 <killy9999> if that would possible you would be able to transparently hide impure code within pure code
03:17:30 <MagneticDuck> Okay
03:17:36 <MagneticDuck> Yeah
03:17:39 <MagneticDuck> It's seems weird
03:17:50 <killy9999> and that would be dangerous :)
03:18:05 <MagneticDuck> Because a function should ALWAYS RETURN THE SAME RESULT WITH THE SAME PARAMETERS. Doing that would be treason to Haskellness
03:18:12 <adnauseam> timthelion: cabal doesn't seem to be installed. i'll try installing it again from the repos, and then see if that resolves this strange ghost
03:18:12 <MagneticDuck> *otherwise
03:18:23 <MagneticDuck> Okay thanks.
03:22:41 <elliott> edwardk: typo: "knowledge GHC's" :P
03:22:49 <edwardk> ah
03:23:04 <elliott> and you misspelled my name, too
03:23:07 * elliott just noticed the commit
03:23:27 <edwardk> wondered if you'd notice ;)
03:23:48 <timthelion> > let f (x:xs) (trues,falses) condition = if condition == 0 then f xs (x:trues,falses) condition else f xs (trues,x:falses) condition; f [] result _ = result in f [1,2,3,4] ([],[]) (\n -> (mod n 2) == 0)
03:23:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
03:23:49 <lambdabot>    arising from a use of `f' at...
03:23:52 <elliott> edwardk: btw, you can gut out the __GLASGOW_HASKELL__ sections of the slow impl now
03:23:53 <edwardk> was so careful with it the other 5 places
03:23:57 <elliott> which means you can drop the MagicHash
03:24:05 <edwardk> erm, not presently
03:24:14 <elliott> why not?
03:24:14 <edwardk> i fall back to slow when !impl(ghc)
03:24:19 <elliott> yes
03:24:21 <elliott> gut out the GHC-specific bits
03:24:25 <elliott> they're just optimisation
03:24:28 <edwardk> oh
03:24:30 <elliott> and it's the slow impl
03:24:34 <edwardk> you mean remove the ghc specific hacks
03:24:37 <edwardk> nah
03:24:37 <elliott> yeah
03:24:40 <edwardk> slow can still be fast ;)
03:24:45 <elliott> heh
03:24:55 <edwardk> slow is relative
03:25:03 <elliott> i think it probably ends up the same speed, i would be very surprised if that pattern-match didn't become a jump table later down the optimisation chain
03:25:05 <roconnor__> hvr: maybe it is best to transform your (b -> Maybe b) into a (b -> b) (using ap fromMaybe) before passing it into set
03:25:20 <roconnor__> hvr: I mean before passing it into modify
03:25:28 * elliott just wasn't sure how other-extensions: MagicHash would interact with a non-GHC compiler
03:25:51 <edwardk> oh
03:25:54 <edwardk> i mucked that up
03:25:55 <edwardk> one sec
03:27:09 <gspr> Are there any resources on the net on how to deal with C structs with FFI without using hsc2hs? I'd rather learn the details first, and then use hsc2hs for convenience later.
03:27:48 <gspr> Or is it just as simple as: Make the corresponding Haskell type an instance of Storable?
03:28:10 <elliott> gspr: it's not really so much details vs. convenience
03:28:15 <elliott> hsc2hs is the *only* way to do it portably
03:28:24 <gspr> elliott: Oh, I see.
03:28:24 <edwardk> gspr: making it storable is a pretty good start, tricky to deal with all the native alignment issues by hand in haskell though
03:28:25 <elliott> otherwise you just have to guess about sizes, alignment, etc.
03:28:32 <elliott> hsc2hs talks to the C compiler to find that stuff out for you
03:28:46 <elliott> and lets you access fields by actual name rather than guessing at a byte offset
03:28:51 <gspr> Ah, right, I see. I've misunderstood what hsc2hs does then.
03:29:02 <gspr> I probably mixed it up with Greencard and that bunch.
03:29:08 <elliott> it actually turns your hsc2hs-adorned program into a C program that prints out a haskell program
03:29:09 <elliott> seriously
03:29:14 <timthelion> > let f (x:xs) (trues,falses) condition = if condition x then f xs (x:trues,falses) condition else f xs (trues,x:falses) condition; f [] result _ = result in f [1,2,3,4] ([],[]) (\n -> ((mod n 2) == 0))
03:29:15 <lambdabot>   ([4,2],[3,1])
03:29:18 <gspr> elliott: Yikes :P
03:29:20 <elliott> then it compiles and runs that and compiles its output
03:29:28 <gspr> Greencard and friends are more about convenience, right?
03:29:35 <timthelion> Is that function really not in Prelude?  I cannot find it.
03:29:54 <elliott> gspr: i don't think greencard has worked in a decade.
03:30:01 <gspr> elliott: Oh :P
03:30:02 <elliott> timthelion:
03:30:03 <elliott> :t partition
03:30:04 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:30:04 <elliott> ?
03:30:13 <timthelion> elliott: probably :)
03:30:20 <gspr> elliott: Thanks. I'll work with hsc2hs then
03:30:29 <elliott> gspr: right. c2hs may interest you if you want something more powerful
03:30:50 <gspr> elliott: Nah, I'm wrapping just a couple of relatively managable structures, so I think I'm fine.
03:32:11 <edwardk> elliott: look more sane?
03:32:37 <elliott> edwardk: looks right to me
03:33:07 <edwardk> it only needs 2 unsafeCoerces on one line, nowhere near my record
03:33:44 <killy9999> if I have a module that defines some data types how do I export the value constructors?
03:33:54 <elliott> killy9999: module Foo (MyDataType(..))
03:34:00 <elliott> or module Foo (MyDataType(Cons1,Cons2))
03:34:23 <killy9999> elliott, thanks, I missed the (..)
03:35:02 <MagneticDuck> Sorry for my newbieness but what actually happens if you don't say anything about the value constructors?
03:35:05 <mnieminen> hmm.. how to use maybe in my own records.. I have a record and I want to allow some of the values to be Nothing
03:35:11 <elliott> edwardk: is 5 major versions in a day a record for you?
03:35:17 <mnieminen> If i define my values as Maybe String, it won't work
03:35:18 <edwardk> no
03:35:19 <elliott> mnieminen: ..., myField :: Maybe MyType, ...
03:35:22 <elliott> edwardk: aw
03:35:29 <edwardk> its a pretty slow day actually ;)
03:35:58 <mnieminen> elliott: does not work.. can't create records like that
03:36:04 <MagneticDuck> Three questions up at once!
03:36:16 <killy9999> mnieminen: paste your code to hpaste.org
03:36:19 <elliott> mnieminen: no, it does work -- you have made some other error
03:36:24 <killy9999> It works for me
03:36:27 <MagneticDuck> Yap
03:36:38 <elliott> MagneticDuck: It doesn't export them.
03:37:08 <MagneticDuck> elliott: So what DO you export? The type itself... ?
03:37:15 <MagneticDuck> I guess
03:37:26 <MagneticDuck> I could see how that could be nice sometimes.
03:37:33 <killy9999> MagneticDuck: as elliott says, the name of the type constructor seems visible, the value constructor is not
03:37:44 <killy9999> I don't see any use for it...
03:37:49 <MagneticDuck> Yeah. Okay.
03:38:10 <MagneticDuck> killy9999: what if you wanted to make some type of data structure that the program had to generate?
03:38:20 <hpaste> mnieminen pasted “using Maybe String” at http://hpaste.org/66558
03:38:28 <elliott> killy9999: There's plenty use.
03:38:36 <elliott> You can create a function that creates your data type but checks a precondition first.
03:38:40 <mnieminen> there's the paste
03:38:44 <elliott> Smart constructor, it's called.
03:38:52 <elliott> mnieminen: You need (Just value) when you have a value.
03:38:54 <MagneticDuck> The value constructor is "Maybe "John""
03:38:56 <MagneticDuck> Yeah
03:38:56 <MagneticDuck> \
03:38:57 <elliott> address = Just "The address"
03:39:17 <mnieminen> isn't that a little compilicated? no other way?
03:39:22 <MagneticDuck> Nope
03:39:32 <MagneticDuck> > @type "John"
03:39:33 <lambdabot>   <no location info>: parse error on input `@'
03:39:36 <MagneticDuck> Grr
03:39:45 <MagneticDuck> > @t "John"
03:39:46 <lambdabot>   <no location info>: parse error on input `@'
03:40:01 <killy9999> > :t "John"
03:40:02 <lambdabot>   <no location info>: parse error on input `:'
03:40:06 <mnieminen> I'd just like to be able to create records where all values must not necessarily to be given
03:40:06 <MagneticDuck> Anyway, it's String, not Maybe String
03:40:17 <MagneticDuck> Yap
03:40:21 <MagneticDuck> That's the only way
03:40:26 <killy9999> mnieminen: you are :)
03:40:41 <killy9999> you type Just "Joe" or Nothing
03:41:02 <killy9999> I'm doing the same thing at the moment :)
03:41:12 <killy9999> and I have a different question about records
03:41:14 * hackagebot reflection 1.0 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-1.0 (EdwardKmett)
03:41:47 <killy9999> I have a record that is supposed to have a filed representing its hash generated from two other fields
03:41:55 <mnieminen> okay.. thanks.. I'll do that
03:42:01 <killy9999> s/filed/field
03:42:16 <killy9999> is there an ellegant way to encapsulate that?
03:42:25 <MagneticDuck> I wouldn't do that.
03:42:35 <killy9999> why not?
03:42:35 <MagneticDuck> I'd just generate the hash as I go
03:42:43 <MagneticDuck> Because it's not actually information
03:42:50 <killy9999> what do you mean?
03:42:59 <MagneticDuck> You can generate from what you already have
03:43:10 <elliott> No, that's perfectly reasonable to do.
03:43:12 <elliott> It functions as memoisation.
03:43:20 <killy9999> that's redundancy, I agree
03:43:21 <MagneticDuck> I guess...
03:43:29 <elliott> edwardk: \o/
03:43:41 * killy9999 didn't know it has such a smart name
03:43:43 <elliott> the changelog is now longer than the docs :P
03:43:48 <edwardk> elliott: =)
03:43:58 <killy9999> hah
03:44:22 <killy9999> I just figured ut the way to encapsulate that... and found a practical application for not exporting the value constructor of a type :)
03:44:34 <elliott> killy9999: yep
03:44:37 <edwardk> i was going to try to show it up with the changelog from 'ad' but it looks like reflection is longer
03:45:04 <elliott> i like how the vast majority of it is only relevant to someone who started using reflection half-way through today
03:45:13 <edwardk> =P
03:45:24 <hpaste> MagneticDuck pasted “This doesn't look right...” at http://hpaste.org/66559
03:45:32 <MagneticDuck> So this code works...
03:45:42 <MagneticDuck> but I'm used to using "return" at the end of IOs.
03:45:47 <MagneticDuck> Is this good style?
03:46:02 <MagneticDuck> StringGrid is just [[String]]
03:46:08 <edwardk> elliott: well, the majority of the changelog covers the most recent half of the major versions, right? =)
03:46:13 <elliott> MagneticDuck: that does not do what you think
03:46:19 <MagneticDuck> No?
03:46:25 <elliott> MagneticDuck: you can replace "table" with its definition there and remove the let line
03:46:26 <elliott> equivalent
03:46:33 <elliott> "let" just gives something a name, doesn't cause anything to "happen"
03:46:39 <elliott> edwardk: hehe
03:46:42 <elliott> yay, I now have reflection 1.0 installed
03:46:44 <elliott> time to play with it
03:46:45 <MagneticDuck> But handle is already closed at the end...
03:46:49 <MagneticDuck> That's the problem.
03:46:58 <MagneticDuck> I have to return AFTER handle closes.
03:47:09 <MagneticDuck> Solution?
03:47:16 <edwardk> i do love the fact that there are no instances for Reified ;)
03:47:16 <MagneticDuck> Oh
03:47:19 <MagneticDuck> Gotcha.
03:47:23 <elliott> yeah :)
03:47:24 <elliott> edwardk: you broke the examples, btw
03:47:27 <elliott> because the kind changed
03:47:29 <edwardk> doh
03:47:40 <elliott> oh wait
03:47:48 <elliott> were they already updated for that?
03:47:48 <elliott> dunno
03:47:56 <MagneticDuck> Okay wait... that means that I can use a handle after it closes? 0.o
03:48:00 <edwardk> oh they are already updated i think
03:48:07 <elliott> ok
03:48:14 <elliott> i just went back to the code i was writing earlier today, haha
03:48:17 <elliott> MagneticDuck: No, you can't.
03:48:22 <elliott> MagneticDuck: That means your code doesn't work.
03:48:23 <MagneticDuck> elliott: I thought so.
03:48:28 <MagneticDuck> elliott: Oh
03:48:32 <edwardk> thats ancient history man ;)
03:48:35 <elliott> MagneticDuck: Note that hGetContents closes the file for you.
03:48:42 <MagneticDuck> Ah okay.
03:48:45 <elliott> But only once you evaluate the entire string it returns. It's an icky thing called "lazy IO".
03:48:59 <elliott> You can probably just remove the hClose and use the readString <$> ... directly.
03:49:06 <hpaste> MagneticDuck annotated “This doesn't look right...” with “This doesn't look right... (annotation)” at http://hpaste.org/66559#a66560
03:49:16 <MagneticDuck> Okay
03:49:17 <MagneticDuck> Thanks
03:49:22 <MagneticDuck> I'll try it.
03:50:18 <hpaste> MagneticDuck annotated “This doesn't look right...” with “This doesn't look right... (annotation) (annotation)” at http://hpaste.org/66559#a66561
03:50:25 <MagneticDuck> One liner... I think?
03:52:08 <MagneticDuck> Debugging it.
03:52:51 <elliott> That's not quite right.
03:52:55 <MagneticDuck> Yeah
03:52:57 <elliott> You have a (<$>) where you mean a (=<<).
03:53:05 <MagneticDuck> See it now
03:55:22 <elliott> (Reified p, Reflected p ~ q) is such a mouthful :(
03:57:22 <edwardk> elliott: yeah
03:57:36 <edwardk> clearly it needs a constraint kinded type family
03:57:40 <edwardk> Reifies p q
03:57:49 <elliott> I was thinking that
03:57:53 <nomeata> Hi. Does someone know why there is no cabal-install 0.14 on hackage?
03:57:59 <elliott> edwardk: but then I wondered why it uses TFs in the first place :P
03:58:07 * elliott continues restructuring code
03:58:11 <edwardk> because no undecidable instances ;)
03:59:21 <elliott> pah
04:02:37 <edwardk> elliott: anyways with the TF version there is an option to make a type like https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs#L10 not mention the 'a' with the MPTC version the users of the library are more constrained
04:02:55 <elliott> yeah
04:03:00 <DijkstraGroupie> One question. Does ghci sometimes get type inference wrong or something?
04:03:05 <elliott> DijkstraGroupie: no
04:03:09 <elliott> edwardk: ugh, the inference has broken
04:03:21 <edwardk> reify 6 reflect -- you mean?
04:03:29 <elliott> (10 `modulo` 3) in this case
04:03:42 <DijkstraGroupie> elliott: I defined pascal as "pascal = iterate (loop 0 []) [1] where { loop n acc [] = n:acc ; loop n acc (x:xs) = loop x (x+n:acc) xs }"
04:03:44 <elliott> i need ugly asProxyTypeOf type things -- with the unsafe impl it defaulted to Integer properly
04:03:48 <edwardk> does the MPTC version work?
04:03:51 <elliott> or was the FD impl bad at that too?
04:03:56 <elliott> edwardk: that's the thing, dunno, i'll check
04:03:58 <DijkstraGroupie> elliott: And it says its type is [[Integer]]. Why so overspecific?
04:04:05 <edwardk> at least its short
04:04:18 <edwardk> @hpaste
04:04:18 <lambdabot> Haskell pastebin: http://hpaste.org/
04:04:19 <elliott> DijkstraGroupie: monomorphism restriction
04:04:40 <elliott> edwardk: oh, wait, I can just embed the FD impl in my code to test it
04:04:40 <elliott> heh
04:04:45 <elliott> one sec
04:04:49 <edwardk> http://hpaste.org/66562
04:04:51 <edwardk> yeah
04:04:53 <elliott> right
04:04:57 <elliott> that could fit into a sig
04:05:01 <edwardk> yep
04:05:39 <elliott> yes
04:05:44 <elliott> it works, (10 `modulo` 3) works with FDs
04:05:45 <edwardk> that one infers?
04:05:47 <elliott> yep
04:05:48 <elliott> perfectly
04:05:48 <edwardk> damnit
04:05:56 <elliott> and the constraints are so much smaller too
04:06:02 <elliott> are you sure UndecidableInstances is so bad? :P
04:06:03 <edwardk> want to change your 'slow' version to MPTCs?
04:06:13 <elliott> yeah ok
04:06:23 <elliott> rename it back to Reifies again?
04:06:27 <edwardk> i'll change fast over and prep the rest
04:06:27 * elliott pulls
04:06:28 <edwardk> yeah
04:06:35 <edwardk> and we go to 1.1
04:06:57 <elliott> you should just version your packages sequential naturals :P
04:08:05 <elliott> edwardk: can i kill the GHC specific bit while i'm at it? it's so ugly to modify
04:08:20 <edwardk> *twitch* ok
04:11:09 <elliott> ha, the non-GHC build of the fast thing was broken anyway
04:11:11 <elliott> forgot to import Word8
04:11:20 <bitonic> is there some documentation for the GHC api?
04:11:42 <elliott> bitonic: sort of.
04:11:53 <edwardk> condensed the changelog
04:12:07 <bitonic> elliott: ok, where do I find it?
04:13:00 <elliott> edwardk: one sec
04:13:02 <adnauseam> is it ok to use ghc 7.4 to build the haskell platform, even though it asks for 7.0 ?
04:13:10 <elliott> bitonic: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html
04:13:17 <elliott> adnauseam: probably not
04:13:36 <adnauseam> we'll see then :/
04:13:49 <bitonic> elliott: oh ok, the Haddock API, I had that already. Given the number of modules I was hoping for something describing what does what
04:14:33 <elliott> bitonic: ghc trac might help
04:15:12 <elliott> edwardk: pullrequest'd
04:15:21 <edwardk> cool
04:15:25 <edwardk> fixed up examples
04:15:30 <elliott> edwardk: can rebase after you push the chances to the fast one if you'd like
04:15:43 <edwardk> k
04:16:02 <elliott> you can get rid of the default extension CPP stuff btw
04:16:22 <edwardk> yeah i did
04:17:13 <elliott> elliott's official list of things you need fundeps for: TypeCast, Reifies
04:18:08 <edwardk> you can live without it, you just need to make a ConstraintKinded type alias
04:18:22 <elliott> and you lose inference :P
04:18:22 <killy9999> why does cabal complain about this in .cabal file: "tested-with : ghc-7.0"
04:18:24 <killy9999> ?
04:18:24 <edwardk> type Reifies s a = (Reified s, Reflected s ~ a)
04:18:26 <edwardk> yeah
04:18:42 <elliott> just like you can technically rewrite the entire prelude classes to plumb an environment instead
04:18:58 <edwardk> =P
04:19:58 <bitonic> is it possible, with the GHC api, to get the type of sub-expressions?
04:20:00 <mnieminen> how can i cast String to Just String?
04:20:23 <elliott> :t Just
04:20:23 <lambdabot> forall a. a -> Maybe a
04:20:26 <bitonic> mnieminen: Just is not a type constructor
04:20:31 <bitonic> you probably meant Maybe String
04:20:32 <killy9999> mnieminen: you have to construct it's value usin Just
04:20:51 <killy9999> if x is use string then: Just x
04:21:00 <killy9999> s/use/your
04:21:10 <killy9999> "cabal: gtd.cabal:16: Parse of field 'tested-with' failed." WTF? :/
04:21:12 <mnieminen> killy9999: thanks.. seems to work
04:21:51 <elliott> killy9999: Perhaps your Cabal version is too old to support that field.
04:22:16 <elliott> edwardk: you should make "Reifies arbitrary Haskell terms into types that can be reflected back into terms" the synopsis, more useful than what it currently is :p
04:22:30 <killy9999> elliott: I;m using latest Haskell Platform
04:22:31 <edwardk> yeah
04:22:43 <killy9999> using version 1.10.2.0 of the Cabal library
04:22:48 <killy9999> that's too old?
04:22:52 <elliott> killy9999: dunno.
04:22:56 <nomeata> killy9999: maybe you need to specify a higher Cabal-version in the cabal file.
04:23:13 <killy9999> nomeata: I tried
04:23:15 <nomeata> Cabal 1.10.2.0 is new enough
04:23:27 <nomeata> killy9999: can you paste your cabal file somewhere?
04:23:42 <killy9999> yeah
04:24:23 <MagneticDuck> Hey I have a little question about exporting things...
04:24:33 <hpaste> killy9999 pasted “cabal file” at http://hpaste.org/66563
04:24:49 <MagneticDuck> What's the syntax for exporting typeclasses and instances?
04:24:51 <hvr> roconnor__: the problem with that, is that it doesn't achieve zero-copying
04:24:59 <elliott> MagneticDuck: instances have no export control, they are always exporting
04:25:04 <elliott> for typeclasses it's TypeClass(members)
04:25:04 <MagneticDuck> Okay
04:25:07 <nomeata> killy9999: try "ghc ==7.0"
04:25:07 <elliott> e.g. TypeClass(..)
04:25:27 <nomeata> killy9999: or rather "GHC ==7.0"
04:25:46 <MagneticDuck> members?
04:25:49 <nomeata> killy9999: see http://www.haskell.org/cabal/users-guide/#package-descriptions for the official syntax documentation
04:26:13 <elliott> MagneticDuck: methods
04:26:16 <hvr> roconnor__: I want the resulting lens-operation to be operationally the same as 'id' in case of a no-op update
04:26:17 <MagneticDuck> Okay.
04:26:20 <MagneticDuck> ty
04:26:20 <elliott> class TypeClass a where method :: ...; method :: ...
04:26:24 <elliott> s/ $//
04:26:35 <nart> ciao :)
04:26:35 <killy9999> nomeata, doesn't work... Yeah, I followed the official documentation
04:26:39 <MagneticDuck> btw does EVERYONE use vim?
04:26:58 <killy9999> MagneticDuck: no, I use emacs
04:27:05 <nart> MagneticDuck: emacs here too
04:27:13 <elliott> me too
04:27:17 <MagneticDuck> killy9999: but everyone uses the replacement syntax.
04:27:18 <killy9999> I've also experimented with EclipseFP and Leksah
04:27:24 <MagneticDuck> Leksah...
04:27:29 <MagneticDuck> Heard about it
04:27:48 <Twey> MagneticDuck: That syntax is significantly older than vi, let alone vim.
04:27:52 <killy9999> MagneticDuck: replacement syngtax is *nix specific I guess
04:27:58 <MagneticDuck> Ah
04:28:19 <nomeata> killy9999: if I put in "tested-with        : GHC ==7.0" I get a different error (cabal: buildTypeAction UnknownBuildType)
04:28:23 <Twey> If it were vim syntax we'd have to type the obligatory annoying colon before each replacement ;)
04:28:31 <MagneticDuck> yeah
04:28:34 <MagneticDuck> :P
04:28:40 <tech2> hah, for a moment I thought I was in #vim and people were just toying with MagneticDuck :)
04:28:44 <Twey> Haha
04:28:46 * killy9999 thinks using emacs syntax while chatting using irssi wouldn't be a good idea...
04:29:05 <elliott> MagneticDuck: That syntax originates from QED or something.
04:29:07 <killy9999> nomeata, yes, your right
04:29:11 <elliott> Probably the exact syntax is from ed or sed.
04:29:16 <elliott> Very old; ex then vi copied it.
04:29:25 <Twey> M-5 good RET bad
04:29:31 <MagneticDuck> QED? What did that have to do with what?
04:29:31 <nomeata> killy9999: and simple need to be Simple
04:29:39 <killy9999> nomeata: I get either of these two errors
04:29:40 <edwardk> elliott: pull
04:29:45 <elliott> MagneticDuck: http://en.wikipedia.org/wiki/QED_(text_editor)
04:29:49 <MagneticDuck> Ah
04:29:53 <nomeata> killy9999: btw, "cabal-init" greats a valid cabal file for you
04:30:22 <killy9999> changed simple to Simple
04:30:29 <MagneticDuck> I thought you meant the quantum electrodynamic theory.
04:30:30 <killy9999> cabal: Run the 'configure' command first.
04:30:36 <killy9999> I hink that was it :)
04:30:42 <elliott> edwardk: woot
04:31:04 <elliott> edwardk: you might want to remove "Haskell" from "arbitrary Haskell terms"... yeah, I'm just saying this 'cuz I couldn't find anything wrong with it :P
04:31:12 <nomeata> s/"cabal init"/"cabal-install init"/
04:31:13 <edwardk> sure
04:31:31 <killy9999> I thought they meant quod erat demonstrandum :)
04:31:43 <edwardk> pushed
04:31:59 <killy9999> nomeata: thanks
04:32:11 <killy9999> so far I'm trying to build haddock documentation
04:32:16 <elliott> edwardk: go for it
04:32:38 * elliott notes that 0.9 hasn't even been haddocked yet
04:33:32 <adnauseam> elliott: haskell platorm install with ghc 7.4 broke on happy :/ intalling ghc 7.0 now and trying again
04:34:00 <elliott> adnauseam: generally if you want the bleeding edge you have to abandon the platform and start hacking stuff yourself
04:38:46 <MagneticDuck> Bleeding edge. heh heh
04:39:01 <MagneticDuck> Never heard that expression
04:39:16 <elliott> "One unsafeCoerce seems to be enough"
04:39:18 <elliott> edwardk: blasphemy!
04:39:41 <edwardk> its probably his compiler version
04:40:05 <elliott> oh, that's irrelevant. it's just that one unsafeCoerce is never enough
04:41:23 * hackagebot reflection 1.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1 (EdwardKmett)
04:41:25 * hackagebot eq 0.3.5 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.5 (EdwardKmett)
04:41:28 <Cale> Hi MagneticDuck!
04:41:51 <elliott> woooo \o/
04:41:56 <elliott> happy reflection 1.1, everybody
04:42:29 <MagneticDuck> Hey!
04:42:31 <MagneticDuck> lol
04:42:33 <MagneticDuck> I have to go
04:42:34 <MagneticDuck> >_<
04:42:36 <Cale> haha
04:42:42 <MagneticDuck> Just a few minutes
04:43:19 <Cale> Well, good to catch you for a moment anyway. I somehow always see your messages in #magnets too late.
04:43:45 <MagneticDuck> My parents are dragging me off into the country to spend the rest of the day looking at real estate. Weeeeee.
04:43:49 <elliott> there's a #magnets?
04:43:56 <MagneticDuck> elliott: Yap
04:44:00 <MagneticDuck> Zen Magnets
04:44:06 <Cale> elliott: struggling to stay alive, but yes :)
04:44:06 <bitonic> elliott: lol in 1 day it went through .5 .6 .7 .8 .9 and 1!
04:44:29 <elliott> bitonic: You forgot 1.1!
04:44:40 <bitonic> right
04:44:41 <elliott> edwardk actually just has a post-commit hook that releases to Hackage.
04:44:48 <edwardk> i wish
04:45:13 <edwardk> bitonic: the code shrank quite considerably
04:45:32 <MagneticDuck> Cale: I'll be back in about 6 hours... hopefully.
04:45:35 <bitonic> edwardk: but now it runs "purely on black magic"
04:45:40 <MagneticDuck> I'll tell you on flickr.
04:45:44 <edwardk> bitonic: thats the best kind of magic
04:45:48 <elliott> i think if you sum up the fast and slow impls it might still be only the same length
04:45:58 <Cale> MagneticDuck: probably best to just send me a private message here
04:46:03 <elliott> bitonic: It uses unsafeCoerce to turn a function requiring a certain constraint into a function that takes the typeclass dictionary for that constraint.
04:46:07 <MagneticDuck> Once I figure it out.
04:46:08 <Cale> If I'm around, I tend not to miss those
04:46:10 <MagneticDuck> Bye
04:46:13 <MagneticDuck> Okay
04:46:17 <elliott> bitonic: Then it forces the compiler to accept that two types are the same.
04:46:23 * hackagebot semigroups 0.8.0.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.0.1 (EdwardKmett)
04:46:27 <bitonic> elliott: wow. I guess that works with GHC
04:46:34 <bitonic> how do you get the dictionarified typeclass?
04:46:47 <edwardk> https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs is pretty sexy compared to https://github.com/ekmett/reflection/blob/3cf0d3613432cfc1fe52a21873b2701d66c7f5c1/Data/Reflection.hs
04:46:50 <elliott> It only has one method, so the dictionary is simply the type of the single method
04:46:58 <elliott> In this case (const a)
04:47:00 <elliott> :: p s -> a
04:47:25 <bitonic> elliott: right... and doing this has considerable advantages?
04:47:34 <elliott> bitonic: yes, 130ms -> 6ms
04:47:41 <edwardk> bitonic: its a couple orders of magnitude faster than the sped up version
04:47:48 <mekeor> > 5 :: ()
04:47:48 <lambdabot>   No instance for (GHC.Num.Num ())
04:47:48 <lambdabot>    arising from the literal `5' at <intera...
04:47:53 <elliott> (which we spent the day optimising)
04:48:41 <adnauseam> elliott: all i'm trying to do is get lamdabot up and running, but getting it running seems to be a mix of both old and new :p
04:48:59 <elliott> adnauseam: oh. that's a "give up" type situation
04:49:15 <elliott> lambdabot is... ... ...yeah
04:49:25 <bitonic> elliott: ok, I'm having trouble to understand what that does reading the very short haddock interface.
04:49:40 <elliott> bitonic: take a look at https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
04:49:51 <elliott> basically it lets you transform a regular value into a type
04:49:56 <elliott> and then turn that type back into the value from within that context
04:49:59 <elliott> without having to pass anything around
04:50:32 <elliott> you can, e.g. have a type for modular or fixed-precision arithmetic, which carries a token identifying the modulus/precision in its type, and is an instance of all the typical numeric typeclasses, and specify the modulus/precision at runtime
04:50:32 <adnauseam> elliott: i got it working on my mint12 box
04:50:55 <bitonic> elliott: whoa, ok. I guess the 'reflected' values can't be used in any ways
04:51:02 <bitonic> otherwise we'd have dependent types
04:51:05 <elliott> no, they can
04:51:09 <elliott> they're the real values, real deal
04:51:16 <elliott> it's not quite dependent types
04:51:24 <adnauseam>  elliott: now i'm trying on my debian virtual server and since it's a bare installation, with debian's repos being "stable" and not really having anything new on them, it's just causing alot of frustration, i think i'm slowly crawling towards a solution though
04:51:24 * hackagebot repa-examples 3.1.0.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.1.0.1 (BenLippmeier)
04:51:28 <elliott> the type you get will never unify with anything, it's like the "s" in runST
04:51:30 <elliott> it's just "some type"
04:51:36 <elliott> all you can do with it is turn it back into the value
04:51:41 <bitonic> elliott: yes that's what I mean
04:51:46 <elliott> right
04:51:58 <elliott> adnauseam: yeah
04:52:03 <elliott> adnauseam: don't install any haskell packages from debian
04:52:41 <edwardk> bitonic: it actually is a form of dependent types
04:52:45 <adnauseam> elliott: yep, i've purged everything, and installing the haskell platform myself
04:52:49 <edwardk> bitonic: you can only use them in nested contexts though
04:53:06 <bitonic> edwardk: yes I guess it is... what do you mean with "nested contexts"?
04:53:37 <edwardk> the forall in reify :: a -> (forall s. Reifies s a => Proxy s -> w) -> w means you can only introduce the in a stack discipline
04:53:44 <elliott> Cale: these zen people sure do take their magnets seriously
04:53:53 <edwardk> you can't make up a new name that escapes from a context in which you made up another
04:53:57 <Cale> elliott: :)
04:54:06 <Cale> elliott: They also give away a lot of magnets :)
04:54:20 <bitonic> edwardk: ok, I'll take a closer look later
04:54:31 <Cale> (More than half of my current collection of magnets were free)
04:55:01 <Cale> (well, I guess you could also think of them as payment for photography work :)
04:55:15 <elliott> edwardk: aaand inference works once again!
04:55:20 <Cale> Has anyone here looked at QML?
04:55:26 <edwardk> elliott: \o/
04:56:22 <Cale> http://fop.cs.nott.ac.uk/qml/compiler/
04:56:23 <elliott> edwardk: now when can we start lifting types into kinds?
04:56:24 * hackagebot cabal2nix 1.31 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.31 (PeterSimons)
04:56:58 <edwardk> just take a polymorphic kind and do the same coerce magic or something
04:57:19 <elliott> type-level unsafeCoerce... good god
04:57:36 <mokus> kind-level MPTCs...
04:58:08 <elliott> edwardk: i hate to do this to you
04:58:14 <elliott> but you didn't update
04:58:14 <elliott> -- Portability : non-portable (rank-2 types, type families, scoped type variables)
04:58:28 * elliott runs away
04:58:29 <edwardk> gah
04:58:32 <nomeata> adnauseam: try happy 1.18.9, that should build with GHC-7.4.1
04:59:11 <nomeata> adnauseam: also, the debian packages of lambdabot are already built with GHC-7.4.1, so it is definitely possible
05:00:00 <edwardk> elliott: and i emailed oleg and ken the trick
05:00:24 <elliott> yay
05:00:47 <elliott> btw, i think doing it for multiple-element typeclasses is a lot harder, because they actually have a representation
05:00:53 <elliott> and it differs in the fiddly RTS bits
05:00:57 <elliott> so it's lucky that we don't need it here
05:01:00 <adnauseam> nomeata: debian packages of lamdabot ? :o i've been trying to compile it from source ;p
05:01:07 <edwardk> i wasn't sure how much different it was
05:01:18 <edwardk> if it just looks like a forced record or not
05:01:36 <elliott> well i tried it a while back and i kept getting the GHC internal panics about entering closures it shouldn't and so on
05:01:38 <elliott> that was with Show
05:01:47 <edwardk> did you force it first?
05:01:51 <elliott> yes
05:01:55 <edwardk> damn
05:02:06 <elliott> eventually i looked at the commentary and decided that there's no way to write a haskell term representing such a multi-part dictionary
05:02:10 <elliott> without FFI hacks
05:02:11 <elliott> at least
05:02:22 <elliott> but i never thought to try one-method classes
05:02:53 <elliott> anyone running GHC 6?
05:03:47 <bitonic> elliott: I have GHC 6
05:03:58 <bitonic> I can try reflection with 6.12 if that's what you need
05:04:05 <elliott> it'd be nice to know it doesn't segfault :p
05:04:08 <mekeor> (epigram(2) even requires GHC6 ;()
05:04:41 <elliott> epigram 2 requires a time machine
05:04:42 <edwardk> bitonic: the examples folder contains a examples/Monoid.hs that should work
05:04:58 <bitonic> cabal: The package reflection-1.1 requires the following languages which are
05:05:00 <bitonic> not supported by ghc-6.12.3: Haskell2010
05:05:11 <edwardk> bah, i can change that
05:05:18 <edwardk> 1.1.2 coming up
05:05:20 <elliott> heh
05:05:22 <elliott> .2?
05:05:23 <elliott> isn't it .1?
05:05:35 <edwardk> nah there was a doc change ;)
05:05:39 <elliott> lol
05:05:50 * elliott didn't realise it was one increment per change
05:06:25 * hackagebot reflection 1.1.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.1 (EdwardKmett)
05:06:27 * hackagebot yesod-auth-zendesk 0.1.0.1 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-0.1.0.1 (FelipeLessa)
05:06:39 <edwardk> well i'd already just pushed
05:06:44 <elliott> oh, haha
05:06:48 <bitonic> ok, let's see
05:06:50 <elliott> post-commit hook in action
05:06:52 <elliott> bitonic: nope, too early
05:06:55 <elliott> gotta wait for 1.1.2
05:07:01 <bitonic> ah.
05:07:24 * kallisti wonders what sleep is.
05:08:54 <edwardk> uploaded
05:08:59 <elliott> that poor haddock server
05:09:16 <elliott> you have to be reaching some kind of record by now :)
05:09:17 <edwardk> *shrug* it has survived far worse abuses by me than this
05:09:29 <bitonic> oook updating
05:09:33 <elliott> 9 releases in a 24 hour period
05:09:33 <edwardk> i've been known to push ~100+ packages a day ;)
05:09:34 <bitonic> why is cabal update so slow anyways
05:09:38 <elliott> of the same package
05:09:43 <elliott> bitonic: because it downloads the list of every package ever
05:09:54 <edwardk> i've been pretty slow for the last few months though
05:10:08 <bitonic> elliott: really? it's not some kind of repo? then thousands of people 'cabal update'ing every day is a far greater abuse :D
05:10:31 <elliott> bitonic: no, my understanding is that the cabal devs want to have an absolutely perfect solution before they do anything about how many years it takes
05:10:45 <elliott> so when I'm in a cynical mood, it will probably never happen
05:11:12 <bitonic> elliott, edwardk: the example works with 6.12.3
05:11:17 <elliott> bitonic: \o/
05:11:20 <edwardk> bitonic: nice
05:11:26 * hackagebot reflection 1.1.2 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.2 (EdwardKmett)
05:12:04 <bitonic> edwardk, elliott: well good job, I'll read the paper & the source after lunch, this looks interesting
05:12:07 <edwardk> around 6.10 type families break down, but we don't use them in there any more
05:12:25 <elliott> edwardk: hugs does fundeps right
05:12:35 <elliott> bitonic: i haven't actually read the paper yet - probably i should :P
05:12:37 <bitonic> I can try with hugs as well lol
05:12:40 <edwardk> bitonic: basically if you accept that i can turn a number into a type then it follows
05:12:54 <edwardk> bitonic: because i can serialize a stable ptr by converting it to a number
05:13:03 <bitonic> edwardk: yeah but I don't see how you can easily generalise that in haskell
05:13:15 <elliott> because you can put any value in a StablePtr (FFI thing)
05:13:19 <bitonic> ah. ahahah.
05:13:19 <elliott> and StablePtrs can be converted to integers
05:13:22 <elliott> and back
05:13:32 <bitonic> so that's what you did before? you converted Ptr to type-level naturals?
05:13:36 <elliott> (however it does not use this trick any more unless you ask for the slow implementation)
05:13:40 <elliott> bitonic: yes (except integers, not naturals)
05:13:45 <bitonic> ahahahah
05:13:57 <elliott> (and it was actually packed into 8 type parameters which each contained one T0, T1, ..., T255)
05:14:03 <edwardk> bitonic: along with some chicanery to free the stable ptr
05:14:04 <elliott> (which were generated with cpp -- this is the same "slow" implementation still in there)
05:14:17 <bitonic> ok she's been bugging me to get lunch for 30 mins now, later :)
05:15:10 <edwardk> bitonic: originally it would serialize a list of bytes represented as type level nats, but elliott showed it was ~40% faster to use a fixed sized array of bytes with one constructor per byte
05:15:32 <edwardk> then we converged on this horrible horrible hack
05:17:25 <elliott> well there's two good things about this
05:17:30 <elliott> 1. it can't get any faster
05:17:36 <elliott> 2. we can't remove anything else from the interface
05:17:40 <edwardk> hah
05:17:48 <elliott> theoretically, you should never have to increment the major version again :P
05:18:25 <nart> wha are your thoughts about Qi/Shen ?
05:21:27 * hackagebot yesod-auth-zendesk 0.1.0.2 - Zendesk remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-zendesk-0.1.0.2 (FelipeLessa)
05:21:55 <hpaste> elliott pasted “modular” at http://hpaste.org/66565
05:21:56 <elliott> tada
05:22:23 <edwardk> elliott: thats not as good as the one in the paper ;)
05:22:32 <elliott> guess i should read the paper then :)
05:22:36 <elliott> howso?
05:22:49 <edwardk> they do some nice chinese remainder theorem tricks
05:23:17 <elliott> pfft, operational details
05:23:42 <edwardk> well, it guides you to make other structural decisions in how you implement it
05:24:08 <elliott> kidding
05:24:20 <elliott> i wasn't trying to do anything serious, just play around with stuff
05:25:21 <edwardk> well, one example is they'd peel off all the factors of 2 into one term pretty easily
05:25:24 <roconnor__> hvr: in that case you will have to run that ^%%= horribly named command followed by (ap fromMaybe).
05:25:28 * elliott wonders if you could do funny business by defining instances of Reifies
05:25:47 <edwardk> elliott: well, defining instances is quite handy
05:25:59 <elliott> so you can supply constant inputs/
05:26:00 <elliott> ?
05:26:04 <edwardk> yep
05:26:12 <elliott> i was thinking along the lines of trying to trick reify into breaking the open world assumption like your applicative-for-monad stuff does
05:26:15 <edwardk> i use it to reify mantissa sizes, etc.
05:26:22 <elliott> but i guess that since there is actually *no* s type they are associated with, that's impossible :)
05:26:42 <elliott> ...ok, an instance without a type is a really scary thing
05:26:53 <elliott> even with runST I can pretend it just picks () or something
05:27:23 <edwardk> well, there is always
05:27:27 <roconnor__> interestingly (l ^%%= (ap fromMaybe g)) === ap fromMaybe (l ^%%= g) follows from the natural transformation laws.
05:27:28 <edwardk> class Closed a | -> a
05:28:07 <roconnor__> or more generally (l ^%%= (k g)) === k (l ^%%= g) for suitably nice k (which might be simply any k).
05:28:29 <elliott> edwardk: you can give one instance for that, can't you?
05:28:34 <edwardk> yeah
05:28:39 <elliott> hm
05:28:44 <elliott> doesn't *that* violate the open world assumption?
05:29:03 <edwardk> don't think so
05:29:17 <edwardk> class Foo a; instance Foo a -- look there is only one non-overlapping evil instance
05:29:34 <elliott> fair enough
05:30:00 <edwardk> there are nice uses for that Closed class, to fake closed worlds
05:30:49 <edwardk> http://hackage.haskell.org/packages/archive/type-int/0.5.0.1/doc/html/src/Data-Type-Boolean.html see the Closed def at the top and its use below
05:31:00 <elliott> yeah
05:31:06 <edwardk> basically its how i faked custom kinds before now
05:31:22 <elliott> i've done similar things
05:31:26 <elliott> except i just didn't export the superclass
05:31:47 <edwardk> yeah i don't bother exporting Closure, then you can't make new instances of TCBool
05:32:01 <elliott> right, you don't need the fundep then though :)
05:32:30 <elliott> did anything happen with that mpfr binding? i only remember it because it used reflection
05:32:40 <edwardk> what'd you expect. this was like the second thing i wrote ;)
05:33:04 <edwardk> elliott: still working on it. copumpkin said he'd have the garbage collector hook for me before christmas ;)
05:33:21 <elliott> he's got many months then :P
05:33:37 <elliott> how often does it reify? just wondering if it'll see a noticeable speed improvement (had it fully existed before this change)
05:33:49 <edwardk> i need to go just accept the fact that i need to force the hook installer using a dirty trick in an unsafeCoerce myself
05:33:56 <edwardk> not very often at all
05:34:07 <edwardk> well, the version that is there works now
05:34:17 <edwardk> it just crashes the moment you access pi
05:34:27 <edwardk> or logBase or ...
05:34:28 <elliott> a very liberal definition of "works"
05:34:41 <elliott> "it... compiles!"
05:34:52 <edwardk> well it works for everything except the constant cache
05:34:58 <edwardk> which uses the custom allocator incorrectly
05:35:15 <edwardk> all the other combinators work fine
05:35:41 <edwardk> to fix the constant cache we need to replace the custom allocator ghc installs into gmp
05:35:53 <edwardk> and make it figure out if its being called from the constant cache
05:36:01 <edwardk> and treat those specially
05:36:15 <edwardk> copumpkin got that to work actually
05:36:19 <edwardk> but ghci doesn't install it
05:36:23 <edwardk> so it craps out in ghci
05:36:45 <edwardk> i can fix it, but it hasn't been at the top of my TODO heap
05:37:09 <edwardk> the idea is to make an IO action that installs the handler idempotently
05:37:19 <edwardk> by invoking a custom foreign prim
05:37:41 <elliott> :D
05:38:03 <edwardk> and then take any call that would access the constant cache and wrap it in a seq makeSureTheHandlerIsInstalled
05:38:21 <edwardk> where that unsafePerformIOs the installer
05:38:34 <roconnor__> hvr: I'm adding the horrible ^%%= command to partial lenses (but restricted to applicative instead of functor).
05:38:49 <edwardk> so those ops would pay for an extra is-evaluated check but thats about it
05:39:52 <elliott> roconnor__: can you rename all the data-lens operators?
05:46:03 <navaati> hi
05:47:22 <navaati> just to check : is all this "continuation passing style" stuff actually just the with<Blah> kind of fonction ?
05:47:34 <deech> Hi all, is there a comparison of the various FRP implementations in Haskell? I've read the Wiki page, I'm looking for more of a comparison of implementations (eg. arrow based vs. push-based, etc)?
05:47:58 <navaati> deech: i don't think arrow based is opposed to push-based
05:48:52 <navaati> iirc the last versions of Yampa are push-based (not sure, though), and the interface is arrow-based
05:48:57 <deech> navaati: Possibly not, I'm a newbie. These are merely the tag lines I see on the descriptions of the implementations.
05:49:10 <elliott> it's more "regular" FRP vs. arrow-based
05:49:14 <elliott> i don't think there's an up-to-date comparison
05:49:26 <elliott> reactive-banana and netwire are the "big ones", plus i guess that fork of yampa, animas
05:51:05 <deech> elliott: So as far as you know there isn't a document talking about the pros and cons of each.
05:51:27 <elliott> afaik.
05:51:34 <elliott> i use reactive-banana personally.
05:51:38 <navaati> well, the interface of yampa is easy to understand, at least (but it seems a bit out of date)
05:52:18 <navaati> elliott: ah, interesting. It's applicative-based, right ? I just can't get how it works…
05:52:27 <elliott> yes, applicative-based
05:52:29 <deech> elliott: Well if there is a person who would know it would be you :) so I'm going to assume it doesn't exist and dig into the implementations myself.
05:53:00 <mm_freak> animas is really just yampa with better docs and direct access to the stepping function (because yampa's reactimate sucks)
05:53:46 <elliott> afaict yampa and animas are both completely horrific :p
05:53:50 <navaati> yampa's interface was easy : IO a -> (a ~> b) (b -> IO ()) -> IO () and that's all
05:54:12 <mm_freak> deech: there is no good comparison…  my suggestion is to go with reactive-banana, when you want to write GUI applications
05:54:50 <mm_freak> netwire is more suitable for reactive networking applications or other high speed stuff…  it's not exactly easy to get into
05:55:01 <navaati> mm_freak: why does reactimate sucks ?
05:55:40 <mm_freak> navaati: because for serious applications you really don't want the library author to write the main loop for you
05:56:21 <mm_freak> i always considered yampa to be a proof of concept, although i did try to use yampa and later animas for serious stuff…  it's just not ready and too opaque
05:56:31 * hackagebot ircbot 0.3.2 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.3.2 (JeremyShaw)
05:56:44 <navaati> ah. i should try this "serious application" thing that everyone is talking about one day, then :)
05:57:30 <deech> My applications aren't serious, they have a sense of humor.
05:59:20 <elliott> edwardk: actually, i bet the "slow" impl works with hugs
05:59:30 <elliott> ...not gonna test it :P
06:08:54 <Younder> Is it just me or is Steve Awodey's book on Category Theory difficult to follow?
06:10:34 <gspr> When making a data type that needs to mirror a C struct, what type should one use for a void* field?
06:10:59 <zenzike> Younder: I've got that on my pile of things to read ... what are you finding difficult about it?
06:12:08 <Twey> gspr: a, generally
06:12:40 <Twey> Depending on how you're going to use it, you may need to use Data.Dynamic &c.
06:12:48 <mm_freak> gspr: (forall a. Ptr a -> b) -> b
06:13:14 <mauke> Ptr Void
06:13:31 <mm_freak> or any type with no Storable instance
06:14:00 <mm_freak> Void is probably a good choice
06:14:09 <gspr> Interesting -- thre different answers :)
06:14:32 <gspr> *three
06:14:41 <mauke> that's what happens with vague questions
06:14:48 <gspr> very true :)
06:16:12 <lotus20151> hello
06:16:23 <lotus20151> :)
06:16:38 <gspr> I'll try to elaborate on the story. I'll call a C function that allocates a struct with a few fields. One field has type void*, and is essentially "pointer to a chunk of data". My Haskell program should keep this struct, and every now and then it should copy "the data" pointed to by the mentioned pointer into a ByteString.
06:16:59 <gspr> (The data pointed to will change due to calls to another C function)
06:18:31 <gspr> This being my first attempt at FFI, I'm a bit confused about how to deal with void pointers.
06:18:54 <mauke> how do you know the size of the data?
06:19:24 <gspr> mauke: Another field in the struct tracks that
06:21:05 <mauke> I'd go with Ptr CChar then
06:21:51 <gspr> So in essence, I just want Haskell to know enough about the structure to do three things: 1) Read the size_t length field from the struct (done, works fine). 2) Pass a pointer to the struct back to C. 3) Use the length field to turn the data pointed to by the void pointer into a ByteString of "just data".
06:22:08 <gspr> mauke: Alright, that makes sense.
06:22:44 <gspr> mauke: Thanks
06:26:42 <mauke> (size_t is CSize)
06:27:14 <mauke> BS.packCStringLen (ptr, size)
06:29:01 <gspr> mauke: Thanks. I was a bit confused on whether I should treat it as a char array or not. But I guess it's what I'd do in C, and so it makes sense :)
06:29:07 <ski> Younder : you might find "Conceptual Mathematics: A First Introduction to Mathematics" by F. William Lawvere,Stephen H. Schanuel easier going
06:29:16 <gspr> I find it hard sometime to think about C and Haskell at the same time.. they're so very, very different
06:29:18 <ski> (disclaimer : i haven't read Awodey's book)
06:29:19 <mauke> gspr: array? huh?
06:29:59 <gspr> mauke: Well, isn't that what you're doing with packCStringLen? Treating ptr as a char array of length size?
06:30:04 <gspr> (in a sense)
06:30:08 <mauke> no
06:31:26 <mauke> in C think, you can't really treat anything as an array because arrays do so little
06:31:58 <Taneb> IxSet is confusing
06:32:07 <mauke> C pointers always point into arrays (they're like tuples of (array, index))
06:32:13 <mauke> at an abstract level, that is
06:32:48 <gspr> By an "char array in C" I did really mean "a pointer to a place in memory after which a number of chars reside consecutively"
06:33:07 <gspr> (remove that first "an")
06:33:16 <mauke> that describes all (object) pointers :-)
06:33:24 <gspr> true :)
06:33:52 <mauke> the only problem is binary compatibility in the presence of different internal pointer types
06:34:04 <gspr> right
06:34:09 <mauke> but I don't think ghc runs on any such platforms
06:34:24 <mauke> and what's more important, C guarantees that char * and void * have the same internal representation
06:34:34 <mauke> so that's pretty much perfect
06:35:58 <hpaste> inetic pasted “cabal installing yi” at http://hpaste.org/66568
06:36:03 <gspr> mauke: Ah, of course -- here we get to the core of my confusion. Thanks
06:39:48 <kallisti> can quickcheck be used to test impure code?
06:41:23 <bitonic> kallisti: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Property.html
06:41:39 <bitonic> 'morallyDubiousIOProperty'
06:41:48 <bitonic> you shouldn't do that
06:42:00 <bitonic> since yu're testing non-deterministic stuff
06:42:17 <kallisti> ah
06:42:23 <kallisti> so stick to HUnit for the IO stuff?
06:42:41 <bitonic> you should just just yourself, I'm sure there are instances where it's appropriate
06:43:03 <mekeor> kallisti: there's QuickCheckM, too. see http://www.cse.chalmers.se/~rjmh/QuickCheck/ .  but i just read of it… so idk it…
06:43:32 <kallisti> yeah what I'm seeking to test may not benefit from a testing framework.
06:44:00 <roconnor__> elliott: eventually.
06:45:44 <inetic> hi there, I'm new to caball installing, I'm trying to install the yi editor, but I'm getting this error: http://hpaste.org/66568 , as I understand it, the system complains that my ghc is old, but 'ghc --version' says that it's newer than the system expects. Or am I missing something?
06:46:15 <ski> navaati : a variant of `product' written in CPS might look like `{-# LANGUAGE ScopedTypeVariables #-} product :: Num a => [a] -> a; product (ns :: [a]) = loop (\p -> p) ns where loop :: [a] -> (a -> a) -> a; loop [] k = k 1; loop (0:_ ) _ = 0; loop (n:ns) k = loop ns (\p -> k (n * p))' -- note how the list traversal is aborted as soon as a zero is found (and nothing is then multiplied) -- the pragma is only needed if you want the explicit type
06:50:58 <elliott> roconnor__: good enough :p
07:06:41 <zenzike> ]
07:07:04 <navaati> edwardk: i don't see how your reflection package enables to achieve the modular calculus example in the paper "Functional Pearl: Implicit Configurations", would you have a quick example ?
07:10:15 <elliott> navaati: I can show you some code:
07:10:21 <elliott> http://hpaste.org/66565
07:10:47 <elliott> Independent implementation, but the same idea (none of the fancy stuff though).
07:10:59 <elliott> (You can ignore modulo', look at the commented out implementation of modulo instead)
07:11:14 <elliott> (That's the modulus-specifying function, I forget what it's called in the paper, withIntegralModulus or something I think.)
07:11:28 <navaati> elliott: thx a lot
07:11:45 <elliott> You can build the separate typeclass on top of that if you want. But it doesn't really buy you anything AFAICT
07:13:01 <elliott> navaati: Basically there's no ReifiesNum or whatever, just Reifies that can reify anything
07:18:04 <Taneb> Well, it's proving harder than I thought to add shared attributes to my family tree library
07:18:16 <bitonic> oh well, getting the type of a sub-expression is quite easy with the GHC API... adding that to ghc-mod shouldn't be too hard
07:18:48 <Taneb> HashMap (Text, Maybe Int) Text doesn't Aeson
07:19:50 <Taneb> HashMap Text (Text, Maybe Int) doesn't allow for people to be married more than once
07:20:37 <Taneb> Unless I do HashMap Text [(Text, Maybe Int)]
07:20:46 <Taneb> Or similar
07:28:14 <navaati> "modular n = r where r = <blah>", is this black magic oO ?
07:28:25 <mauke> why magic?
07:29:14 <navaati> because i don't see any reason of not writing "modular n = <blah>"
07:29:44 <mauke> that is a weird definition of "magic"
07:29:47 <elliott> navaati: because I use r in <blah>
07:29:57 <elliott> it's just a silly trick to avoid ScopedTypeVariables
07:30:05 <elliott> i fish the proxy for the modulus out of r's type
07:30:34 <navaati> ok, dark magic :)
07:30:41 <elliott> not really
07:31:05 <elliott> navaati: basically, i need to `mod` the modulus
07:31:09 <elliott> so i need to get the modulus
07:31:19 <elliott> i have a handy function for doing that, modulus :: (Reifies p n) => n `Mod` p -> n
07:31:23 <elliott> so I need to get my hands on an n `Mod` p
07:31:33 <elliott> it just so happens that modular's return type is n `Mod` p
07:31:49 <elliott> so I just assign the result to a varaible, and pass that same result into modulus as an (ignored) value of the right type
07:32:50 <wutt_> hi guys
07:33:31 <wutt_> im dont now haskell, thinking about learning it. th GHC produces native code?
07:33:35 <wutt_> -m
07:33:42 <elliott> yes.
07:34:08 <wutt_> i need need nothing to run the compiled programs? or do i need a runtime sys like .net?
07:34:40 <alpounet> the runtime is linked to your program
07:34:47 <mauke> well, you'll probably need libc and libgmp
07:34:52 <elliott> you need libc and the GMP number library.
07:34:54 <elliott> yes.
07:34:57 <elliott> but you can statically link those in.
07:35:04 <wutt_> thats nice.
07:35:06 <elliott> and integer-simple is an alternative to integer-gmp when GMP's licensing causes issues with static linking.
07:36:53 <wutt_> im trying to get this whole functional programmin concept, how does it feel? i code in C since i was 12 years old (22 now), but im kinda tired of expressing every nuance of alrogithms and stuff on a very detailed low level, does functional programming allows me to use higher abstractions?
07:37:16 <navaati> wutt_: much, much higher
07:37:40 <mauke> yes, but nearly any other language is "better" than C for this
07:38:05 <wutt_> my field is mostly either causal web programming, or database management systems
07:38:22 <mauke> in C? o_O
07:38:27 <wutt_> no, in Node.js
07:38:28 <wutt_> :D
07:38:31 <wutt_> the web part
07:38:33 <wutt_> :D :DD :D
07:38:39 <wutt_> but the DBMS thingies i write in C
07:38:50 <mauke> ouch
07:39:09 <wutt_> C++ in the last few years
07:39:22 <navaati> hum, i don't know if DBMS is what haskell shines the most at, but i'm sure a lot of people will prove me wrong
07:39:23 <wutt_> im not an OOP fan though
07:39:48 <mauke> I'd probably use Perl for that stuff because 1) I know Perl, 2) it has all the libraries, and 3) I don't know the state of the art libraries in Haskell
07:40:30 <elliott> wutt_: you will likely find that a large part of learning haskell is unlearning your habits from C
07:40:34 <elliott> that said, check out learn you a haskell
07:40:35 <wutt_> i dont mean something like Phpmyadmin, but MySQL itself, to be more precise i write NoSQL dbs for something like 5-6 years
07:40:36 <elliott> @where lyah
07:40:36 <lambdabot> http://www.learnyouahaskell.com/
07:41:14 <gspr> LYAH has the added bonus that if you find out that Haskell is not for you, you've still been entertained :)
07:41:23 <wutt_> :DDDDDDD
07:41:28 <wutt_> im checkin it right now
07:41:44 * hackagebot arbtt 0.6.2 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.6.2 (JoachimBreitner)
07:43:54 <wutt_> also what concerns me - altough i now next to nothing about FP i feel that the incoming architectural changes in computing will match functional programming more than imperative practices.
07:45:23 <wutt_> the "lazyness" bugs me though.
07:46:10 <navaati> wutt_: you're not forced to be lazy everywhere in your programm, it's only a default
07:46:38 <wutt_> i see.
07:47:18 <navaati> "incoming architectural changes" → are you talking about "big phat massive parallelization everywhere" ?
07:47:26 <kallisti> navaati: I've used Haskell for DB stuff and it works fairly well.
07:47:33 <kallisti> I haven't compared it with other libraries in other languages though.
07:47:58 <kallisti> HDBC could certainly be better..
07:48:16 <kallisti> I think for my next project that uses a database I'll try out Takusen.
07:51:06 <wutt_> navaati yepp, my mate does some coding on fpgas and oh boy, its sure as hell different than coding in an imperative language
07:51:46 <wutt_> mutex locks take you nowhere when there are 5000 cores...
07:52:55 <navaati> wutt_: hum, then i think a nice example to show you is this GPipe library
07:53:28 <wutt_> navaati link?
07:53:31 <navaati> it enables you to create GPU shaders (which is the usual example of massive parallel stuff) in a very abstract way
07:54:10 <navaati> http://www.haskell.org/haskellwiki/GPipe/Tutorial
07:54:32 <navaati> but i'd have a nicer example that i can upload, wait a minute
07:56:12 <wutt_> navaati also can you show me some familiar data structs/algos like a balanced binary tree to get the grasp of the lang?
07:57:07 <navaati> wow wow, ask to more knowledgeable people then, "balanced binary tree" = WTF for me :)
07:57:37 <navaati> (hurm, lost my example, sorry…)
07:57:57 <wutt_> :DDDD thats basically just a sorted set created in a way so you dont have to continously reallocate memory for your array of values
07:58:26 <gspr> wutt_: Check out Data.Map
07:58:28 <navaati> i think the Set type in the standard library is this
07:58:48 <wutt_> gspr googling it...
07:59:21 <gspr> wutt_: You should check out hackage: http://hackage.haskell.org
08:01:18 <mauke> wutt_: http://www.haskell.org/ghc/docs/7.0.4/html/libraries/containers-0.4.0.0/Data-Set.html
08:01:21 <mauke> wutt_: http://www.haskell.org/ghc/docs/7.0.4/html/libraries/containers-0.4.0.0/Data-Map.html
08:02:16 <wutt_> mauke reading. syntax is so alien :D
08:26:45 * hackagebot statethread 0.1.1 - The ST monad and STRefs  http://hackage.haskell.org/package/statethread-0.1.1 (HenningThielemann)
08:28:46 <navaati> hum… i really don't see the interest of the reflection package over the reader monad…
08:30:59 <JuanDaugherty> it's ninja
08:31:22 <JuanDaugherty> rockstar or what have you
08:33:05 <elliott> navaati: you can't write the modular arithmetic thing with Reader
08:33:07 <elliott> or the monoid example
08:33:48 <navaati> the monoid example resolves the "let's create instances at runtime" problem
08:34:08 <elliott> (also, the Reader monad forces you to write in a much uglier style)
08:34:17 <elliott> (even with applicative combinators it's much less nice than direct functional style)
08:34:49 <navaati> well, the disadvantage of the reader monad is that every of your value is wrapped in a damn Reader stuff
08:35:02 <navaati> but the same happen with this lib !
08:35:20 <elliott> no it doesn't
08:35:36 <elliott> you can make your own Proxy anywhere, so long as you have the token in the _type_
08:35:46 <elliott> which is much less restrictive
08:35:55 <navaati> ah ? in the example i see "ghci> withMonoid (+) 0 $ mempty <> M 2", you wrap 2 in M
08:36:30 <navaati> argh, i feel there is something that i don't understand, but…
08:36:36 <elliott> erm that's not like the reader monad
08:36:40 <elliott> that's just because our instance is defined on M
08:36:49 <elliott> consider mempty there
08:36:52 <elliott> it's not in any kind of wrapper
08:36:56 <elliott> no context is being passed to it
08:37:04 <elliott> it reflects the value solely from its type
08:38:21 <elliott> navaati: anyway if your impression is solely based on the monoid example, that's misleading, it uses a newtype so that it can give an instance that has the type attached to it
08:38:35 <elliott> the modular arithmetic stuff has no such things that look like wrapping/unwrapping
08:38:51 <navaati> let's take an example : in a programm i need to pass a file descriptor everywhere, and that's damn annoying
08:39:39 <navaati> so in the end i use "(?fd :: Fd) ⇒ " before the functions and it works fine
08:40:23 <elliott> you actually *use* implicit params?
08:40:37 <navaati> well, yeah, and that's not the first time
08:40:40 <elliott> anyway, did you read the paper? it's got some good examples and a lot of explanation
08:40:47 <navaati> yeah, yeah, i read it
08:40:51 <navaati> how the reflection lib is supposed to replace this (because implicit params are considered ugly) ?
08:42:52 <elliott> well you *do* need to have the magic type in your signatures, as argument *or* result (the latter being important, because you don't necessarily have to fish it out of anywhere, you can just produce it from thin air)
08:43:02 <navaati> for example i've got a function "currentRes :: (?drm :: Drm) ⇒ IO (Connector,Encoder,Crtc,ModeInfo)" (Drm is a newtype for Fd), that use a function of type "(?drm :: Drm) ⇒ IO Resources"
08:43:05 <elliott> but that's a good thing, because it statically ensures you're using things within the right context, not mixing them
08:43:10 <elliott> and lets you use multiple contexts simultaneously
08:43:17 <navaati> what will my function's signature look like with reflection ?
08:43:49 <elliott> well, you'd structure it differently... hard to say without knowing anything about your program, but as a first guess I'd give Connector/Encoder/Crtc/ModeInfo/Resources a type parameter to use as a "session" type
08:44:02 <elliott> (drm `Reifies` Drm) => IO (Connector drm, Encoder drm, Crtc drm, ModeInfo drm) or such
08:44:13 <elliott> (you shouldn't have tuples that big, pack them into one data type: then the repetition of "drm" is gone)
08:44:22 <elliott> edwardk probably has better suggestions than me though :)
08:45:23 <navaati> (the big tuple is intended here, it's only used once)
08:45:55 <elliott> doesn't matter :p
08:48:35 <hpaste> navaati pasted “whole main” at http://hpaste.org/66573
08:49:09 <navaati> for example will the code for currentRes stay the same ?
08:49:31 <rurufufuss> ahem, is there a tutorial/article somewhere that can blow my mind about why monads are good?
08:49:46 <mauke> monads aren't good
08:49:53 <rurufufuss> trying to find a good intro on it, along with examples
08:49:59 <navaati> (Connector, Encoder, etc are regular records with numbers and enum in them)
08:50:02 <rurufufuss> mauke: ah right, do explain?
08:50:03 <mauke> functors are much better
08:50:56 <Cale> rurufufuss: mauke is being slightly trolly, in case it's not clear :)
08:51:30 <mauke> I'm finding it hard to imagine a monad article that would blow my mind
08:51:36 <Cale> rurufufuss: Monad is just an interface that some libraries happen to satisfy, and when they satisfy it, you get a bunch of definitions for free.
08:51:52 <Cale> rurufufuss: at least, from the programming perspective
08:51:54 <rurufufuss> Cale: ah, that helps in my understanding
08:52:01 <mauke> "definitions for free" is a technical term
08:52:07 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
08:52:08 <mauke> it means "library functions"
08:52:17 <Cale> right
08:52:28 <rurufufuss> as I understand so far, it is about flow control
08:52:33 <rurufufuss> and breaking out when things go wrong?
08:52:35 <mauke> not really
08:52:43 <Cale> Well, not the latter so much, perhaps?
08:52:52 <navaati> elliott: anyway I guess that "(drm `Reifies` Drm) => IO (Connector drm, Encoder drm, Crtc drm, ModeInfo drm)" was the bit i was missing, thanks
08:52:56 <Cale> In general, it's hard to say a lot which would apply to *all* monads
08:53:13 <Cale> but check out that article :)
08:53:18 <mauke> rurufufuss: it's like normal computation + superpowers
08:53:22 <rurufufuss> Cale: will do, thanks
08:53:24 <mauke> every monad has a different power
08:53:32 <Cale> The things which all monads have tend to be kinda like "control structure" sort of things
08:53:33 <mauke> aborting stuff is one of them
08:53:36 <ski> rurufufuss : one of the "good" things about monads is that we can use them to express effects, thereby gaining referential transparency -- as opposed of not knowing whether arbitrary functions can have side-effects, and therefore assuming the worst
08:53:55 <mauke> "effect" means super power
08:54:04 <Cale> but as for more powerful control (like jumping out of the middle of something), that takes specific cases usually
08:54:10 <rurufufuss> ski: that is quite interesting
08:54:27 <ski> rurufufuss : yeah, common "effects" being state, exceptions, continuations, concurrency, parsing, more
08:54:38 <mauke> all these "effects" are not part of the common Monad interface, though
08:54:56 <mauke> that is, Monad contains the common boring stuff that everyone does
08:54:58 <ski> rurufufuss : so, in a sense, one good point of monads is when we *don't* have to use them (and still can be side-effect-free)
08:55:13 * ski nods
08:55:30 <mauke> but then every type also provides extra functionality outside of Monad, and that's where the super powers come in
08:55:48 <rurufufuss> I feel like I have to see it for myself to truly understand all this
08:55:58 <mauke> I think I just explained something to myself
08:56:14 <mauke> the reason I find it hard to blow my mind just with Monad is because Monad is only the boring stuff
08:56:28 <rurufufuss> so the usage of monads, would be the mind blowing stuff?
08:56:35 <ski> rurufufuss : *nod*, the best way is to see the common monads, and see what they have in common, which is the monadic interface embodied by the `Monad' type class
08:56:45 <mauke> rurufufuss: not necessarily :-)
08:56:52 <mauke> e.g. [] is a monad (that's lists)
08:57:11 <mauke> most people aren't surprised that lists can contain multiple values. at the same time!
08:57:15 <rurufufuss> mauke: well, coming from someone who does mainly imperative programming, I hope this will be mind blowing!
08:57:22 <ski> rurufufuss : one common use of monads is to hide ugly "plumbing" code which just detracts from the main point of the code
08:57:44 <rurufufuss> ski: ah yeah, I will take a look at some examples if possible
08:57:46 <navaati> what people do that has a monadic interface is the mind-blowing stuff
08:57:50 <mauke> I wouldn't expect too much
08:58:41 <rurufufuss> hmm, sometimes I wish I did more haskell back in my first semester :/
08:58:43 <ski> "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is a short, somewhat old, monadic tutorial that is still good to get a first idea, imo
08:59:17 <rurufufuss> ski: you have my thanks
08:59:19 <navaati> rurufufuss: try to understand how work : 1/ the Maybe monad 2/ the Reader r monad 3/ the (r ->) monad (nearly the same) 4/ the State monad, and it should be a good start
08:59:45 <navaati> and "understand how work" means reading Prelude's source code
08:59:47 <mauke> you can probably squeeze [] in there somewhere
08:59:56 <mauke> after all, Maybe is just a list with at most one element
08:59:58 <ski> rurufufuss : you will want to read more info on it, as that one just skims the surface, but i do think it gives some basic idea of some important points
09:00:06 <navaati> (mauke, yeah, just after Maybe)
09:00:06 <rurufufuss> awesome, I'll check those out
09:00:26 <ski> elliott : you don't like `ScopedTypeVariables' ? :)
09:00:39 <rurufufuss> awesome thanks haskelliers
09:01:43 <ski> @google all about monads
09:01:45 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
09:01:45 <lambdabot> Title: All About Monads - HaskellWiki
09:02:04 <ski> rurufufuss : that ^ one might be a good one to look at, afterwards
09:02:21 <elliott> back
09:02:24 <rurufufuss> well, looks like I'll have enough to read today, besides game of thrones
09:02:24 <elliott> ski: who says?\
09:02:27 <ski> rurufufuss : and if anything is unclear, don't hesitate to ask us
09:02:32 <elliott> navaati: np
09:02:33 <ski> elliott : says what ?
09:02:34 <rurufufuss> ski: will do, thanks
09:02:41 <elliott> sorry for being away while you had questions :)
09:03:10 * ski is sorry for having questions while elliott away
09:04:04 <elliott> that was to navaati!
09:04:08 <elliott> but i suppose you can keep the apology :P
09:04:14 <elliott> ski: who says I don't like ScopedTypeVariables?
09:04:37 <navaati> elliott: err, i run into a problem : let's say i want a function that returns the current resolution of the current screen, let's call it currentResolution. With implicit-params it's type would be "(?drm :: Drm) => IO (Int,Int)"
09:04:37 <navaati> how do i encode this with reflection (there is no one of my own datatype to thread the drm parameter) ?
09:05:16 <elliott> navaati: (drm `Reifies` Drm) => Proxy drm -> IO (Int,Int) -- or (drm `Reifies` Drm) => IO (Tagged drm (Int,Int)) etc.
09:05:29 <navaati> aaaaaah !
09:05:30 <elliott> you _must_ mention it in the types of the relevant values -- that's how it all works together, propagating throug htypes
09:05:34 <elliott> *through types
09:05:43 <elliott> but the plumbing through types is a lot less overhead
09:05:49 <elliott> since here, you can just say blah (Proxy :: Proxy drm)
09:06:01 <elliott> (assuming you have ScopedTypeVariables done appropriately and are in a reifying-drm context already)
09:06:32 <dmwit> This is a bit off-topic, but... usually when I build a think, I try make, then ./configure if that fails, then autoreconf if that fails; is there a next dependency to try? (autoreconf complains that it's missing some files)
09:06:48 <navaati> ok, i'll try this (it's a luck that my code is still tiny enough to refactor  things like that \o/)
09:07:02 <dmwit> I seem to be having trouble with g's and k's; last night I kept saying thing instead of think and now I'm doing the opposite.
09:07:18 <elliott> dmwit: perhaps autogen.sh or similarly-named shell script in the source tree
09:07:28 <elliott> dmwit: (btw, you would optimise better for the common case by trying ./configure first)
09:07:46 <dmwit> elliott: Thanks, autogen.sh exists and seems to be doing something.
09:07:55 <elliott> yw :)
09:07:57 <dmwit> And yeah, I actually don't usually do that chain; I start with ls. =)
09:08:24 <dmwit> But I didn't know a clearer way to phrase the question.
09:11:46 <ski> elliott : hm .. i dunno ? :)
09:11:59 <ski> <elliott> it's just a silly trick to avoid ScopedTypeVariables
09:12:03 <ski> 'twas a response to that
09:12:35 <ski> .. hm, i wonder whether one could use instead `modulus :: Reifies p n => Either (n `Mod` p) n' or `modulus :: Reifies p n => Const (n `Mod` p) n'
09:12:43 <ski> (maybe that's what `Tagged' does ?)
09:14:32 <elliott> ski: well, yeah, since it was only used in one place there
09:14:38 <navaati> i've got the strong impression that as time goes, haskell is becoming more and more "the coolest and most powerful language in the world" but is also becoming more and more difficult for beginners
09:14:49 <elliott> ski: Tagged a b ~ b
09:14:57 <ski> ok, so `Const'
09:15:01 <elliott> no
09:15:02 <elliott> flip const
09:15:06 <elliott> ski: but in this case it's p you want to tie it to
09:15:09 <ski> er -- right
09:15:10 <elliott> p is the lifted modulus
09:15:23 <ski> ok
09:15:25 <elliott> oh, wait, i see
09:15:28 <elliott> modulus :: (Reifies p n) => Const n (n `Mod` p)
09:15:29 <elliott> right
09:15:38 <elliott> but you don't need the "n" there, because it's already in the type, you only want to tie it to p, so
09:15:42 <elliott> modulus :: (Reifies p n) => Const n p
09:15:42 <elliott> thus
09:15:46 <elliott> modulus :: (Reifies p n) => Tagged p n
09:15:48 <elliott> which is the same as
09:15:53 <elliott> modulus :: (Reifies p n) => Proxy p -> n
09:15:59 <elliott> and that's reify!
09:16:06 <elliott> erm
09:16:07 <elliott> reflect :)
09:16:13 <elliott> reflect :: (Reifies s a) => p s -> a
09:16:19 <elliott> fill in p = Proxy, s = p
09:16:22 <elliott> a = n
09:16:32 <elliott> so, modulus is just a convenience wrapper around reflect
09:16:38 <tredontho> navaati: I think that's like saying that math is more difficult for beginners.  Just because the people on the bleeding edge are doing things that are more incomprehensible doesn't mean that the early stuff is more difficult.
09:16:45 <elliott> ski: because there's a lot of (n `Mod` p)s in abundance, but we'd generally have to construct a Proxy ourselves
09:17:10 <elliott> ski: (of course, with ScopedTypeVariables this wouldn't be necessary -- but modulus *also* serves a useful function, namely, getting the modulus from an (n `Mod` p) in other, non-internal code)
09:17:17 <elliott> (so the fact that we can use it to get at the modulus internally is a happy coincidence)
09:17:53 <navaati> tredontho: well, for example i said to rurufufuss to look at the source of the Reader monad, but nowadays type Reader r a = ReaderT r Identity a (or something like that), not newtype Reader r a = Reader (\r -> a)
09:18:02 <elliott> ski: (Proxy s ~ (), in case that wasn't clear too)
09:18:18 <navaati> which is not good when you begin
09:18:45 <tredontho> navaati: Ah... fair point.
09:19:05 <navaati> also, let's dream that one day rmonads become standard and replace monads in the prelude
09:19:33 <rurufufuss> is that yet another thing?
09:19:41 <rurufufuss> or just a better version of monad
09:19:49 <navaati> rurufufuss: pshht, don't listen !
09:19:58 <captWheeto> exit
09:20:02 <captWheeto> Whoops ;)
09:20:03 <hpaste> erkin pasted “Is this a common failure?” at http://hpaste.org/66574
09:20:26 <erkin> The compiler exists when it comes to that.
09:20:35 <navaati> rurufufuss: it's a slightly more general version, but don't bother with that now :)
09:20:43 <rurufufuss> navaati: heh, ok
09:20:50 <erkin>  /lib $ find /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.0/../../../../lib/libncurses.so
09:20:51 <erkin> <e> /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.0/../../../../lib/libncurses.so
09:21:26 <navaati> well if it happens, it would be more interesting and powerful for everyone, but more difficult for beginners (it involves type families, etc.)
09:22:00 <ski> elliott : hm .. assuming `modulus :: Reifies p n => Either (n `Mod` p) n', i think one could say something like `modular n = Modular (either id (\r -> n `mod` r) modulus)'
09:22:20 <ski> elliott : ok (and *nod*, re `Proxy')
09:23:22 <ski> elliott : .. i.e. say that without your syntactically cyclic `r' nor `ScopedTypeVariables'
09:23:35 <ski> @pl either id
09:23:35 <lambdabot> either id
09:23:57 <navaati> :t either
09:23:58 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
09:24:43 <elliott> ski: yeah
09:24:56 <elliott> ski: well it's possible to construct the Proxy without ScopedTypeVariables too
09:25:03 <elliott> just irritating
09:25:24 <elliott> In the Real World(tm) you should just use scoped type variables like the original paper
09:25:33 <ski> elliott : i'm not saying doing this would necessarily be better, just that it would be possible to do it without the unused input & without the cycle
09:25:42 * ski nods
09:25:48 <navaati> hum, why aren't things like ScopedTypeVariables just… activated by default
09:26:06 <earthy> because they're not haskell'98
09:26:37 <navaati> does it breaks haskell98 (98 guys ? like 14 years ago ? lol ?) compat ?
09:26:47 * hackagebot leveldb-haskell 0.0.3 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.0.3 (KimAltintop)
09:26:55 <navaati> (isn't 2010 the default now, btw ?)
09:27:01 * ski would probably have written it like `modular n :: n `Mod` p = Modular (n `mod` reflect (Proxy :: Proxy p))'
09:27:57 <rata_> hi
09:28:01 <ski> lo
09:28:57 <rata_> is there a function [a] -> [(a,[a])] that returns each element of the list along with the rest of the list?
09:29:05 <sipa> :t tails
09:29:05 <rata_> I'd like to use it in the list monad
09:29:06 <lambdabot> forall a. [a] -> [[a]]
09:29:10 <elliott> ski: yes, that's reasonable
09:29:23 <elliott> ski: i copied the trick from edwardk's monoid example
09:29:23 <rata_> sipa, tails is not
09:29:37 <elliott> ski: https://raw.github.com/ekmett/reflection/master/examples/Monoid.hs
09:29:42 <elliott> the mempty trick
09:29:51 <rata_> I'd like to use it instead of the delete x xs
09:30:04 <elliott> ski: (the nice thing about "proxy s -> ..." is that sometimes you don't need your own wrapper if the types work out :p)
09:30:07 <copumpkin> delete doesn't do the right thing, anyway
09:30:58 <navaati> rata_'s problem makes the word Zipper blink in my head, but i'm not that sure…
09:31:21 <rata_> copumpkin: why delete doesn't?
09:31:36 <rwbarton> what does "the rest of the list" mean
09:31:49 <ski> @type delete
09:31:49 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
09:31:56 <ski> > delete 'a' "abac"
09:31:57 <lambdabot>   "bac"
09:32:02 <copumpkin> rata_: first of all, it asks for Eq, which the function doesn't need. Second, it'll delete only the first occurrence of the element from the list
09:32:28 <ski> @type (\(a:as) -> (a,as)) . init . tails
09:32:28 <lambdabot> forall a. [a] -> ([a], [[a]])
09:32:37 <rata_> copumpkin: that's ok, Eq is not a problem and I want to delete the first ocurrence only
09:32:38 <ski> @type map (\(a:as) -> (a,as)) . init . tails
09:32:38 <cheater__> > delete 'b' "abac"
09:32:39 <lambdabot> forall t. [t] -> [(t, [t])]
09:32:39 <lambdabot>   "aac"
09:32:51 <copumpkin> rata_: then you don't care about order?
09:33:04 <ski> elliott : ok -- though i don't recall the type of `proxy'
09:33:08 <rata_> [1,2,3] -> [(1,[2,3]), (2,[1,3]), (3,[1,2])]
09:33:24 <copumpkin> rata_: yeah, but do you care about the list's order?
09:33:49 <rata_> copumpkin: hmmm... I get you point, but yes, I don't care about order
09:33:50 <copumpkin> or are you just assuming the list doesn't contain duplicates?
09:34:13 <rata_> no, the list could contain duplicates
09:34:40 <ski> @let select :: MonadPlus m => [a] -> m (a,[a]); select [] = mzero; select (a:as) = return (a,as) `mplus` liftM (fmap (a :)) (select as)
09:34:41 <lambdabot>  Defined.
09:34:48 <ski> > select "abcd" :: [String]
09:34:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:34:49 <lambdabot>         against inferred ty...
09:34:56 <ski> > select "abcd" :: [(Char,String)]
09:34:57 <lambdabot>   [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
09:35:23 <elliott> ski: it's quantified
09:35:33 <ski> meaning ?
09:35:34 <elliott> ski: reflect :: (Reifies s a) => proxy s -> a
09:35:50 <ski> elliott : oh, 'twas a type
09:35:59 <reinoud> Ugh... implementing cubic marching squares is not an easy thing to do in Haskell
09:36:05 <elliott> meaning that since (mempty :: M a s) in edwardk's monoid example, he can apply reflect directly to it to get the proxy out, without having to write a wrapper :P
09:36:06 * ski was thinking elliott was talking about a value `proxy'
09:36:09 <elliott> right
09:36:18 <elliott> there is such a value
09:36:25 <elliott> proxy :: Tagged s a -> Proxy s -> a
09:36:33 <Rmx> is there an extention to express  nested pattern guards like here : http://www.haskell.org/pipermail/haskell-prime/2006-July/001571.html
09:36:59 <ski> elliott : i was assuming your `proxy s -> ...' was a typo for `proxy $ \s -> ...' :)
09:37:27 <ski> rata_ : does `select' above do what you want ?
09:37:39 <elliott> ski: ah
09:38:25 <ksf_> *grmbl* *unsafe*TouchForeignPtr
09:38:50 <rata_> ski: yes, it seems it does, I'm trying to understand how does it do it though
09:38:56 <Cale> reinoud: why?
09:39:39 <elliott> Rmx: haskell does not have that
09:39:42 <elliott> you can use where and &&
09:39:51 <elliott> or
09:39:56 <elliott> | predicate1 = case () of _
09:39:59 <elliott>   | ... more guards ...
09:40:26 <Rmx> oh, second version looks great
09:40:30 <Rmx> thanks
09:40:46 <rata_> s/does it do/it does/
09:41:03 <reinoud> Cale: lots of points, references and in general lots of administration going on :) Nice list work though
09:41:16 <Cale> However, that won't "backtrack" in the case that all the inner guards fail.
09:41:35 <Rmx> is any time lost for using such construction, or is this syntax free of inconvenients ?
09:41:50 <Cale> reinoud: hmm, I would probably be using Map datastructures
09:42:35 <Cale> Rmx: Using case to introduce guards like that shouldn't have any performance penalty
09:42:54 <reinoud> if i say insert some tuples [(a, intersect a b), (intersect a b, b)] will `intersect a b' be evaluated twice?
09:43:05 <Cale> If you write it like that, yes
09:43:15 <elliott> Cale: neither do nested guard
09:43:15 <elliott> s
09:43:17 <elliott> according to that thread
09:43:28 <Cale> elliott: oh
09:43:40 <elliott> Rmx: I cannot imagine any conceivable performance cost -- at least not one that would matter in the slightest
09:43:45 <reinoud> ok... i'll make it a subfunc then to generate the tuples
09:43:51 <Cale> elliott: Backtracking would be the only reason I could think of to actually want nested guards
09:43:54 <ski> rata_ : specialized to the list monad, it becomes `select :: [a] -> [] (a,[a]); select [] = []; select (a0:as0) = (a0,as0) : [(a1,a0:as1) | (a1,as1) <- select as0]'
09:43:58 <Rmx> thanks!
09:44:19 <elliott> Cale: yeah, go figure
09:44:29 <ski> ksf_ : hm, reminds me of Riastradh's "Proposal for Ephemerons in Scheme" <http://mumble.net/~campbell/tmp/ephemeron.txt>
09:44:58 <ski> rata_ : does that help explain it ?
09:45:10 <Cale> reinoud: If you write let x = intersect a b in [(a,x),(x,b)], that's another matter :)
09:45:25 <rata_> ski: yes, the specialized version I can understand it
09:46:50 <ski> rata_ : `[]' generalizes to `mzero', `(a0,as0) : ...' is the same as `[(a0,as0)] ++ ...', where `(++)' generalizes to `mplus' and `[...]' to `return ...'
09:46:53 <navaati> :i Monoid
09:47:15 <navaati> (damn, no :i in lambdabot ? how do i know the instances it has, then ?)
09:47:45 <ksf_> ...all I need to avoid is running a finaliser of a substructure if the top finaliser already ran. I don't even need to order them, just nuke the running of the subfinaliser
09:47:51 <fryguybob> @instances Monoid
09:47:51 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:47:55 <ksf_> (because that's a segfault)
09:48:03 <navaati> fryguybob: thx
09:48:46 <ski> rata_ : `[(a1,a0:as1) | (a1,as1) <- select as0]' is `map (\(a1,as1) -> (a1,a0:as1)) (select as0)' where `map' generalizes to `liftM' (or `fmap'), and `\(a1,as1) -> (a1,a0:as1)' is `fmap (a:)' for the functor `(a,)' (mapping over the right component of the pairs)
09:49:10 <Rmx> can't figure out how to do what you told me. http://hpaste.org/66576
09:49:16 <ksf_> freetype, alas, only has deep finalisers.
09:49:50 <MagneticDuck> Rmx: You can't use guards inside a case...
09:50:16 <reinoud> Cale i did that now yes :)
09:50:23 <reinoud> hmmm feels imperative ;)
09:50:42 <Rmx> ok, so one leven of patternguards, then case
09:50:46 <Rmx> no mixed notation
09:50:53 <Cale> reinoud: Note that you can make recursive definitions inside of let though ;)
09:50:57 <MagneticDuck> Yeah. Guards are special.
09:51:02 <Cale> > let xs = 1 : xs in xs
09:51:02 <Rmx> any other way to make such  http://www.haskell.org/pipermail/haskell-prime/2006-July/001571.html
09:51:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:51:16 <Rmx> case are too ugly for nested stuffs
09:51:19 <Cale> MagneticDuck: you can use guards inside case
09:51:31 <MagneticDuck> Oh?
09:51:44 <MagneticDuck> I thought guards were only for function declarations, one level.
09:51:48 <Cale> In fact, it's common to introduce a case on () just to be able to use guards
09:52:01 <Rmx> what's wrong with my code so ?
09:52:19 <Cale> > let x = 5 in case () of _ | x < 0 -> "a" | x > 0 -> "b"
09:52:20 <lambdabot>   "b"
09:52:38 <MagneticDuck> hm
09:52:42 <Cale> Rmx: ?
09:52:44 <Rmx> nothing
09:52:49 <Rmx> indentation was wrong
09:52:54 <Rmx> here
09:52:55 <Cale> oh
09:52:55 <Rmx> http://hpaste.org/66576
09:53:02 <Cale> yeah, just found your link
09:53:20 <Cale> If you put the _ on the same line just before the first |
09:53:22 <Rmx> ok, all's working now, thanks :)
09:53:23 <Cale> it should work
09:53:31 <ski> navaati : there's also `instances-importing'
09:53:45 <rata_> ski: but the functor for tuples is normally the other one (,b), right?
09:54:20 <navaati> > select [1,2,3,4]
09:54:21 <lambdabot>   No instance for (GHC.Show.Show (m (t, [t])))
09:54:21 <lambdabot>    arising from a use of `M459...
09:54:32 <navaati> :t select
09:54:33 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m (a, [a])
09:54:51 <navaati> > select $ map Sum [1,2,3,4]
09:54:52 <lambdabot>   No instance for (GHC.Show.Show
09:54:52 <lambdabot>                     (m (Data.Monoid.Sum a, [...
09:55:01 <navaati> select "abcd"
09:55:27 <MagneticDuck> I really don't see how those guards on cases work.
09:55:32 <MagneticDuck> Cale
09:55:40 <navaati> > select $ map Sum [1,2,3,4] :: [Int,[Int]]
09:55:41 <lambdabot>   <no location info>: parse error on input `,'
09:56:00 <ksf_> saying stuff like "finalisers are almost always the wrong solution, so it's ok that they've got insane semantics" is a rather curageous stance, I'd say.
09:56:02 <navaati> > (select $ map Sum [1,2,3,4]) :: [(Int,[Int])]
09:56:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:56:03 <lambdabot>         against inferred type ...
09:56:30 <navaati> (humpf, i'm tired, sorry for the noise)
09:56:37 <navaati> > (select $ [1,2,3,4]) :: [(Int,[Int])]
09:56:39 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
09:57:01 <Cale> MagneticDuck: The same way that guards on function and pattern bindings work
09:57:02 <navaati> > (select $ map Sum [1,2,3,4]) :: Maybe (Int,[Int])
09:57:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:57:04 <lambdabot>         against inferred type ...
09:57:49 <navaati> > (select $ map Sum [1,2,3,4]) :: Maybe (Sum Int,[Sum Int])
09:57:50 <lambdabot>   Just (Sum {getSum = 1},[Sum {getSum = 2},Sum {getSum = 3},Sum {getSum = 4}])
09:57:51 <Cale> MagneticDuck: the pattern is matched, and then each guard is tried successively. The first one to produce True has its right hand side picked. If none do, then the case proceeds with the next pattern.
09:59:00 <MagneticDuck> I know how guards work...
09:59:23 <MagneticDuck> Hm.
10:01:33 <MagneticDuck> Okay, so case statements usually take a variable and test it over a series of possible values... with each one assigned a value. But in this weird use of a case statement, where are the "possible values"???
10:01:48 <MagneticDuck> There's something I'm missing here.
10:01:49 <monochrom> take an expression
10:01:53 <elliott> MagneticDuck: case a of Pattern a b c | blah -> ... ; Pattern2 -> ...
10:01:54 <elliott> compare:
10:02:01 <elliott> f (Pattern a b c) | blah = ...; f Pattern2 = ...
10:02:11 <elliott> it's just the same as function pattern-matching
10:02:15 <elliott> only you specify a value to pattern-match on
10:02:18 <t7> whats the operation to turn 0x1200 into 0x12 and 0xff00 into 0xff ?
10:02:31 <t7> i thought it was shiftL
10:03:09 <t7> shiftR
10:03:24 <MagneticDuck> Oh, guards are used with patterns... anywhere. Gotcha
10:03:27 <MagneticDuck> Understand now
10:03:27 <Rmx> I find this very practical : http://hpaste.org/66578
10:04:11 <MagneticDuck> I still think it's a silly use for case statements... but there you go.
10:04:38 <MagneticDuck> Feels like a hack. I see how it's useful though.
10:04:49 <monochrom> yesterday I said that recursion in the grammar is underappreciated. another underappreciated idea is uniformity in the grammar.
10:05:35 <Rmx> huh.. why should we use if then else, with such syntax ?
10:05:51 <MagneticDuck> What do you mean?
10:05:58 <Rmx> to my point of view, it's more practical and beatifull, except when I want to write everything on one line
10:06:09 <Rmx> I mean that's jsut equivalent, no?
10:06:15 * elliott rarely, if ever, uses if then else
10:06:24 <monochrom> for example if the grammar allows "a+b" for expression, then it allows "a+b" everywhere you can write an expression. there is no limitation like "you can use a+b for definitions but not when passing parameters"
10:06:44 <MagneticDuck> Yeah. See what you mean.
10:07:18 <monochrom> there was such limitations over the whole industry in the 1960s
10:07:42 <Rmx> great, so I'll just drop those 3 words from my vocabulary for this pattern :3
10:07:50 <MagneticDuck> I wish I could spend time in #haskell instead of in math class. Learn more anyways.
10:08:27 <MagneticDuck> Sometimes though I prefer simplicity and beauty to usability.
10:08:30 <MagneticDuck> For instance...
10:09:03 <MagneticDuck> taking something that we do all the time in SPECIFIC routines and abbreviating it.
10:09:17 <MagneticDuck> ...if you see what I mean?
10:09:34 <mrBG> so haskell for android?
10:09:38 <MagneticDuck> I prefer more broad things like for instance applicative style.
10:09:48 <MagneticDuck> mrBG: Hm?
10:12:13 <Rmx>  '|' is ideal, easy to align code, super readable, and the use of case is even great, because we can Type match stuff if needed without breaking order and readability of our code
10:12:50 <MagneticDuck> Yeah. However until it becomes a real feature it feels like a hack to me...
10:13:03 <Rmx> really, I don't think so
10:13:11 <Rmx> it's even better than the proposal on the website
10:13:17 <Rmx> the use of case should not be remove
10:13:36 <MagneticDuck> My point is it's not doing what case was intended for.
10:13:44 <MagneticDuck> Although I agree it's very useful.
10:13:55 <Rmx> example, update a date (year, month, day) from 1 days, according to bissextil years and stuff
10:14:10 <Rmx> if you have a data Month = January | ..
10:14:25 <MagneticDuck> Hm?
10:14:42 <Rmx> you want to increment your date to the next day
10:14:50 <Rmx> you can do all in one function
10:15:01 <ksf_> that's one of those things you should never do yourself.
10:15:16 <Rmx> using matching on types, and all patterns for bissextils cases
10:15:20 <Rmx> in a very elegant way
10:15:27 <ksf_> just like charset detection, calendars are *messy*.
10:15:48 <Rmx> it's just to give an example of practical utility of having case fitting directly in this way to write code
10:16:11 <MagneticDuck> You couldn't just use a function with guards?
10:16:21 <ksf_> e.g., do you handle the lack of days in september 1752, when the georgian calendar was introduced?
10:16:25 <Rmx> gards for types?
10:16:25 <Rmx> no
10:16:54 <ksf_> ...and that's just scratching the surface of special cases.
10:17:02 <MagneticDuck> Don't quite understand what you were trying to do.
10:17:17 <Rmx> I mean, that in lots of situation you need both Type matching and boolean tests
10:17:19 <ksf_> you might find that in year X, date Y existed in one country but not in the other.
10:17:33 <Rmx> here, it's concise, clean, and understandable, and easy to align
10:17:43 <MagneticDuck> Rmx: You mean pattern matching?..
10:18:05 <Rmx> nested guards with case () of _
10:18:10 <MagneticDuck> Oh I see what you mean now.
10:18:25 <MagneticDuck> Yeah... the predicates and the pattern match.
10:18:29 <MagneticDuck> All in one.
10:18:34 <MagneticDuck> That's not a hack.
10:18:58 <ksf_> what I'd like to have is "caseof".
10:19:02 <MagneticDuck> What I think IS a hack is when they include the dummy var ().
10:19:11 <ksf_> which is a case switch that takes an argument.
10:19:20 <ksf_> useful for monadic stuff.
10:20:11 <Rmx> merge with PatternView, you got universall notation for tests :3
10:20:16 <MagneticDuck> caseof... btw somebody's rewriting prelude. See if you can get it in. :P
10:20:34 <ksf_> can't be done as a function.
10:20:42 <ksf_> TH would work, though.
10:21:09 <ski> rata_ : no, if you start with `fmap :: (b0 -> b1) -> (f b0 -> f b1)' and replace `f' with `(a,)', then you get `fmap :: (b0 -> b1) -> ((a,b0) -> (a,b1))'
10:21:16 <monochrom> ksf means "(caseof [] -> 0 | x:xs -> 1) my_list_here"
10:21:51 <ksf_> yep. it's another form of lambda in a sense.
10:22:03 <MagneticDuck> I see
10:22:10 <monochrom> a merge of lambda and case. a much dreamed construct
10:22:23 <MagneticDuck> Someday... maybe...
10:22:37 <MagneticDuck> Who develops the standard haskell language itself?
10:22:44 <MagneticDuck> Maybe that sounds naive.
10:22:46 <MagneticDuck> Just wondering
10:22:54 <ksf_> the h' committee.
10:23:15 <Rmx> MagneticDuck, would you say something in C such as while (True) {..} is a hack ?
10:23:20 <elliott> that's not C
10:23:29 <ksf_> yep.
10:23:31 <MagneticDuck> !speak C, sorry
10:23:33 <ksf_> it's called for(;;)
10:23:45 <MagneticDuck> Oh, while True? Well...
10:23:49 <MagneticDuck> maybe
10:23:51 <MagneticDuck> depends
10:23:54 <monochrom> #define True 0
10:23:58 <Rmx> ..
10:23:58 <MagneticDuck> but it's usually the only way
10:24:09 <ksf_> #define 1 0
10:24:15 <Rmx> okay, anyway, stupid discussion ^^
10:24:35 <MagneticDuck> I programmed in Pascal back in the day. We had sometimes called the Forever keyword. ^^
10:24:41 <rata_> ski: thanks for the code and the explanation =)
10:24:57 <Rmx> I won't even try to say I hesitated to write 1 because no Bool in C.. ;)
10:25:13 <MagneticDuck> C is weird.
10:25:19 <Rmx> why ?
10:25:23 <glguy> C99 has a bool, at least
10:26:05 <Rmx> not so illogical not to have Bool
10:26:12 <Rmx> C was to do operating system work
10:26:15 <elliott> C99 has bool.
10:26:19 <elliott> but true is not True
10:26:24 <MagneticDuck> Rmx: Well... I can't say much because I never really learned it... but it's a kind of hacked together language. As we know I'm a purist when it comes to programming and math...
10:26:33 <glguy> What are we talking about?
10:26:52 <ski> ksf_ : .. in O'Caml, it is `(function [] -> 0 | x::xs -> 1) my_list_here'
10:26:53 <MagneticDuck> for instance, to test the equality of two strings, you have to use a specialized function.
10:27:22 <monochrom> we are talking about C2014 getting an FFI to Haskell :)
10:27:35 <ski> MagneticDuck,Rmx : i think in Ada, if you write `loop' with no qualifiers, then you get an "inifinite" loop
10:27:36 <MagneticDuck> glguy: We were talking about using guards with cases, and I said that case () of _ |... was a hack... and then we progressed from there.
10:28:12 <ski> monochrom ?
10:28:28 <MagneticDuck> FFI?
10:28:38 <ski> Foreign Function Interface
10:28:49 <MagneticDuck> Ah.
10:29:00 <glguy> MagneticDuck: not having an overloaded == is hacked?
10:29:09 <MagneticDuck> glguy: Overloaded?
10:29:41 <ski> Rmx : re using `case' instead of nested guards, note though : <Cale> However, that won't "backtrack" in the case that all the inner guards fail.  <Cale> elliott: Backtracking would be the only reason I could think of to actually want nested guards
10:29:51 <MagneticDuck> glguy: I don't see how Int == Int is any different then string == string in the world of logic.
10:30:19 <ski> you can compare `(char *)'s just fine with `=='
10:30:39 <MagneticDuck> all I know is that in Objective C it's not like that.
10:30:40 <glguy> MagneticDuck: One of the problems in logic is that people get hand-wavy about what == they mean, actually
10:31:11 <MagneticDuck> glguy: At least in Haskell they give it a solid definition-- it's an instance of the Eq class, leave it at that.
10:32:32 <ski> (`==' in Haskell corresponds more to `equal?' in Scheme -- i.e. structural or observable equality)
10:33:10 <MagneticDuck> glguy: My point is that Haskell is better organized. In C it looks like they made a language, and then kept on slapping things on (with bad glue) until it fit their demands. No "great logic". At least that's what I see. Again, never actually learned it, but read code and heard about it via my friends.
10:33:19 <Rmx> ski : what would you write there? http://hpaste.org/66578
10:33:22 <glguy> ok
10:33:55 <elliott> MagneticDuck: C is generally considered to have a very coherent and "tight" design philosophy, actually, at least as of C89 or so.
10:34:06 <Rmx> I think so too
10:34:12 <elliott> It's not a very good design (in my opinion). But if you're looking for "bag of stuff mixed with glue", that's C++.
10:34:12 <MagneticDuck> Huh
10:34:15 <Rmx> haskell looks much more disorganised than C ^^
10:34:22 <Rmx> to my opinion
10:34:26 <MagneticDuck> Could be wrong
10:34:31 <MagneticDuck> Rmx: O.o
10:34:45 <MagneticDuck> Rmx: I guess everyone has their opinion...
10:35:14 <MagneticDuck> Well, C is more "down to earth".
10:35:28 <MagneticDuck> Which makes it great for system work...
10:36:12 <MagneticDuck> In haskell it's so high you don't even have pointers!
10:36:27 <MagneticDuck> ...don't think...
10:36:33 <glguy> You're taking them away from us??
10:36:41 <MagneticDuck> Hm?
10:37:01 <Rmx> we're speaking about organisation. really, I'm curious to know what more experienced user think, but Haskell's fondations have not so great names, sometimes illogical classes according to original mathematical definition, no highway to format code
10:37:22 <glguy> MagneticDuck: Are you counting Foreign.Ptr as Haskell FFI and not Haskell 98?
10:37:38 <Rmx> maybe sometimes "too much" ways to get things done, not speaking about choice of algorithm
10:38:29 <monochrom> a uniform, recursive grammar must imply many ways to do the same thing
10:38:34 <MagneticDuck> glguy: Well, yes I guess that you do have pointers... to an extent. But you don't really use them in your own code. You don't deal with temp variable memory management etc...
10:38:47 <Rmx> sure, I prefer haskell by far
10:38:58 <Rmx> but it looks much more disorganised than C to my opinion
10:39:35 <Rmx> brackets banana is a typical example of what I want to say
10:39:35 <MagneticDuck> Rmx: Well, I like Haskell because I like math. It's easy to think mathematically in haskell
10:39:49 <MagneticDuck> brackets banana?
10:40:02 <hpaste> ski annotated “patterns test 2” with “reversing order” at http://hpaste.org/66578#a66579
10:40:07 <Rmx> working with arrow, to combine some arrows in rec patterns
10:40:08 <ski> Rmx ^
10:40:16 <Rmx> extensions built on top of other extensions
10:40:23 <Rmx> becoming sort of standard,
10:40:28 <Rmx> illogical as hell ^^
10:40:44 <Rmx> even "=>" is stupid!! in constraints.. oO
10:40:52 <Saizan> are we using Spock's sense of the word logical?:)
10:40:52 <ski> Rmx : sorry, s/> 10 />= 10/
10:41:01 <Rmx> how is it still here ? or please, someone , explain to me why isn't it "<="
10:41:10 <MagneticDuck> Rmx: Yeah. Don't agree with you about => though.
10:41:15 <MagneticDuck> Rmx: What do you mean...
10:41:50 <Rmx> well, "=>" means "implies" in math.. but in haskell "=>" means "is implied by"
10:41:51 <MagneticDuck> Where would you propose to use <=?
10:41:52 <monochrom> sometimes <= is right and some other times => is right
10:41:55 <Rmx> sure!
10:42:04 <Rmx> monochom : ah ?
10:42:05 <MagneticDuck> Ah
10:42:09 <Rmx> can you give me an exemple ?
10:42:13 <shachaf> For Bools (<=) means "is implied by".
10:42:16 <shachaf> > True <= False
10:42:16 <geekosaur> if you were raised ona  steady diet of Algol-family languages, something like Haskell may well look peculiar
10:42:16 <lambdabot>   False
10:42:22 <shachaf> Er, no, it means "implies".
10:42:25 <shachaf> > False <= True
10:42:26 <lambdabot>   True
10:42:33 <shachaf> > (False <= False, True <= True)
10:42:34 <lambdabot>   (True,True)
10:42:42 <Rmx> I mean..
10:42:42 <monochrom> instance (Eq a) => Eq [a]
10:42:51 <ski> Rmx : are you talking about `foo :: Blah a => ..a..' or `instance Foo a => Bar (Zot a)' or `class Foo a => Bar a' ?
10:42:52 <Rmx> ok
10:43:01 <Saizan> (==) :: Eq a => a -> a -> Bool
10:43:06 <Rmx> ok
10:43:19 <monochrom> f :: (Eq a) => [a] -> [a]
10:43:35 <Rmx> I was speaking about class requirements
10:43:50 <Rmx> but I see there is some counter examples
10:43:51 <Rmx> ok
10:44:01 <ski> Rmx : i agree that the super-class requirements appears to have the arrow in the wrong direction
10:44:14 <monochrom> in the interest of reducing the number of reserved words, one of <=, => was chosen, and the other let free
10:44:20 <Rmx> that's what I was speaking about
10:44:32 <Rmx> and now I see it's still true
10:44:38 <Rmx> examples are not about this case
10:44:55 <shapr> Rmx: I'd like to see a table of comparisons where C is sensible and easy to understand compared to Haskell.
10:45:01 <MagneticDuck> LOL I was getting all mixed up.
10:45:02 <Rmx> I don't say so
10:45:08 <Rmx> and anyway it depends
10:45:09 <shapr> It seems to me that C is very close to the hardware, and Haskell is close to the math.
10:45:10 <ski> Rmx : however, it's not fully clear whether to interpret `class Foo a => Bar a' as an implication, or interpreting the `Foo a' part as a presupposition
10:45:16 <Rmx> for many stuff, C is more readable
10:45:24 <MagneticDuck> shapr: Exactly.
10:45:26 <ski> (which is how it is used in type signatures)
10:45:32 <MagneticDuck> Rmx: Like for instance interface...
10:45:38 <leino> I lost my connection. Did anyone respond to my question, like 4 minutes ago?
10:45:49 <MagneticDuck> Nope. Don't think so.
10:45:53 <Rmx> ski, to me, it's rather clear that the arrow is more confusing than anything else
10:45:56 <leino> ok
10:45:58 <shapr> Rmx: So, I agree with your viewpoint if you are looking from the low level CPU behavior.
10:46:13 <Rmx> I prefer haskell
10:46:22 * mekeor , too.
10:46:31 <Rmx> but I did enough C to appreciate some points of this language
10:46:31 <Saizan> leino: which was your question?
10:46:32 <ski> leino : afaics, no question came through
10:47:27 <ski> Rmx : you're still talking specifically about the `class' case, yes ?
10:47:37 <Rmx> yes
10:48:17 <leino> Saizan: Not so much a question as soliciting advice: I am using Data.Set, which has many functions requiring the elements of the set to be of the Ord typeclass. My datatype doesnt fit naturally into Ord, so I dont want to export the instance declaration.
10:48:40 <ski> on one hand, if we know `Ord a', then `Eq a' must also be the case, so `Ord a => Eq a' (or `Eq a <= Ord a') would seem to be more appropriate in the `class' definition
10:49:40 <ski> on the other hand, one could attempt to claim that `Ord a' isn't even (semantically) well-formed unless `Eq a' -- thereby interpreting the `Eq a =>' part as stating `Eq a' as a presupposition for the well-formedness of `Ord a'
10:50:01 <Rmx> ski
10:50:06 <Rmx> I changed my mind
10:50:07 <Saizan> leino: ah, you could use a newtype wrapper and have the instance only for that, or the newtype wrapper could be the type you are exporting
10:50:22 <Rmx> ski, it should be equivalent for any requirements
10:50:31 <ski> so then `=>' shouldn't be interpreted as an implication, but rather as a presupposition, just like in `sort :: Ord a => [a] -> [a]'
10:50:48 <ski> Rmx : what should be equivalent for any requirements of what ?
10:50:49 <Rmx> we don't really care, just anyone can put the symbol he prefers according to logic
10:51:10 <Rmx> "=>" == "<=" in constraints declarations before types
10:51:26 <Rmx> for anything, I think we should let people shower wich one do they prefer
10:51:42 <glguy> If you wanted the arrow the other way but to use the same number of operators you could flip the arguments
10:51:46 <glguy> Ord a => Eq a
10:51:49 * ski isn't quite sure what Rmx is claiming, here
10:52:08 <ski> glguy : *nod*, which would possibly be preferable (and more `grep'abble)
10:52:27 <ski> (preferable since the defined thing comes before the constraints)
10:53:06 <zoo> I'm trying to cabal install llvm. Why am I getting "not in scope" errors?
10:53:47 <Saizan> if class S a <= C a; really meant that C a implies S a i'd expect that giving an instance of C a would give me an instance of S a
10:53:54 <Saizan> which is not quite true
10:54:29 <ski> Saizan : aye, which supports the presupposition position
10:54:45 <Saizan> we'd need a symbol for "'s interface is a subset of the interface of"
10:54:52 <geekosaur> zoo, that;s nowhere near enough information for anyone to guess as to why
10:54:56 <Rmx> Saizan  you're right.
10:55:17 <leino> Saizan: thanks, I'll consider it in case I can't re-define my data types.
10:55:19 <Rmx> Saizan, totally right
10:55:19 <ski> (Rmx : btw, do you know what i mean by "presupposition" ?)
10:55:32 <hpaste> zoo pasted “cabal install llvm” at http://hpaste.org/66581
10:55:38 <Rmx> ski, yes..?
10:55:48 <ski> ok, just wanted to make sure
10:55:52 <Rmx> yes,yes, I do
10:56:14 <ski> Saizan : would that be distinct from an implication ?
10:56:24 <Rmx> yes
10:56:34 <geekosaur> interesting, that sounds like Cabal library version skew
10:56:53 <navaati> hey, is there a real difference between data Blah = Blah Lol and the corresponding newtype, or is it strictly the same ?
10:56:54 <Saizan> ski: not sure, the catch is that instance C a is really instance (C \ S) a
10:57:03 <Saizan> ski: i.e. you provide code only for the difference
10:57:07 <geekosaur> zoo: what version of ghc is this?
10:57:17 <zoo> I'm using ghc from macports, which is ghc 6.10.4
10:57:26 <ski> Saizan : i suppose one way to think about `class Eq a => Ord a' is as expressing an integrity constraint (or law) that `Ord a' ought to imply `Eq a', and if the language processor can't prove that, it rejects the program
10:58:12 <ski> navaati : `case undefined of Blah _ -> ()'
10:58:15 <Saizan> ski: ah, that'd make sense too
10:58:15 <glguy> navaati: data adds an additional bottom element, but as newtypes compile away, they don't
10:58:19 <geekosaur> hrm
10:58:55 <geekosaur> (also on OS X you would need to install a full LLVM, unless you have the latest Xcode *and* Apple fixed it, it's an incomplete LLVM --- but you're not getting anywhere ner where you'd notice that)
10:58:55 <navaati> ah, i was more thinking about a perf difference but there is even a semantic one…
10:58:57 <ski> Saizan : yea, there's several alternate views here, and i'm not clear on what is the correct way of thinking here ..
10:59:32 <ski> navaati : the `Blah' data constructor in the `newtype' case is strict, but the `data' one isn't
10:59:50 <navaati> yeah, yeah…
11:00:02 <navaati> err, but maybe i can still use newtypes, actually !
11:00:09 <ski> navaati : note that there's also a difference between the `newtype' case, and the `data Blah = Blah !Lol' case (even if both data constructors are strict)
11:00:31 <zoo> I think I have the latest xcode, but I also tried installing llvm-2.9 from macports.
11:00:50 <navaati> i need to transform "newtype FbId = FbId Word32" to add a phantom parameter to it
11:01:23 <navaati> but maybe newtype "FbId drm = FbId Word32" is legal atually
11:01:30 <ski> navaati : which you can see if you consider the code `case Blah undefined of Blah _ -> ()'
11:01:41 <geekosaur> right, as I said, you're not actually reaching there yet.  `generateRegistrationInfo` is from the Cabal library, it should be defined if the compuler exists
11:02:12 <monochrom> perhaps newtype Fbld a = Fbld Word32 ?
11:02:18 <Saizan> zoo: ghc-6.10.4 is most likely too hold to build it, it seems in particular you've the wrong Cabal version
11:02:21 <ski> navaati : re `newtype' and operational semantics, the idea is to represent `Blah' values in exactly the same way as `Lol' (no run-time wrapper)
11:03:20 <zoo> ok, so I should remove what I have with macports, and just install the latest ghc?
11:04:06 <Saizan> zoo: or the latest that comes with the haskell platform
11:04:06 <navaati> ok. and will the internal representation stay the same even with the phantom parameter ? 'cause i pass them straight trough the FFI
11:04:22 <monochrom> yes
11:04:26 <zoo> right, ok, I'll try that, thanks
11:05:31 <t7> is there binary literals in ghc?
11:05:38 <t7> for numbers
11:06:02 <navaati> > 0xBEEF
11:06:03 <lambdabot>   48879
11:06:04 <zzo38> Why does     instance A x => B x; instance B x => A x;    cause everything to have those instances, and is there a way to stop that from happening?
11:06:56 <geekosaur> t7, no, there are no binary literals
11:07:25 <glguy> zzo38: when you write "instance SUPERCLASS => A x where" you are saying
11:07:43 <glguy> that anything that matches "x" (everything) is an instance of A and must satisfy SUPERCLASS
11:07:55 <zzo38> I made up a preprocessor, one of its functions is binary number literals such as 0b1001101 and character code number literals such as 0'm'
11:08:32 <sanjoyd> What is the haskell equivalent of bitwise or'd flags?
11:08:49 <zzo38> glguy: What I was trying to do, is that if you define an instance of class A it automatically becomes B as well and vice versa
11:08:50 <glguy> .|.
11:08:54 <elliott> zzo38: impossible
11:09:01 <elliott> you can't even do "define an instance of class A it automatically becomes B"
11:09:04 <elliott> never mind vice-versa too
11:09:19 <elliott> admittedly, in this case it doesn't violate the open world assumption because of the bidirectionality
11:09:28 <elliott> doesn't mean you can do it, though :p
11:11:13 <geekosaur> sanjoyd, idiomatically it'd be a list of a flag ADT, but if you need compatibility with C or etc. you may want (Data.Bits..|.)
11:12:26 <zzo38> elliott: Actually I once used -XIncoherentInstances and other extensions, it allowed such a code but caused everything to have those instances, resulting in infinite loops, instead of what is intended
11:12:40 <elliott> that's what happens when you use -XIncoherentInstances
11:12:48 <monochrom> that's incoherent instances for you
11:13:26 <monochrom> if the compiler is in an infinite loop, I wouldn't say your code is therefore allowed
11:13:30 <zzo38> I know, I don't really like -XIncoherentInstances because you cannot specify implicit priorities
11:13:37 <zzo38> s/implicit/explicit/
11:14:27 <iihavetoes26> starting to learn haskell
11:14:33 <iihavetoes26> it looks so elegant
11:14:36 <zzo38> monochrom: The compiler is not in an infinite loop, it results in an infinite loop at runtime.    instance A x => B x where { bbb = aaa; }; instance B x => A x where { aaa = bbb; };    results in an infinite loop at runtime
11:15:18 <navaati> elliott: hey, your idea of using types like "Connector drm" is actually *great* since it'll enable me to enforce that i don't use a connector ID from a graphic card onto another one !
11:15:38 <qnikst> hello, is there any idea how to make communication throw channel that can finish, thats already done in stm-chans, but I'm interested in non stm version
11:15:50 <elliott> navaati: yep, it keeps all your contexts tied together as well as letting you associate data with them
11:15:58 <elliott> :)
11:15:58 <MagneticDuck> Hey a question: if I want to make a function that deals with a file (readonly) and returns some pure results from it, should I use a function that takes a FilePath and gives the results, or should it take a handle? What's the best style?
11:16:02 <qnikst> one idea is to use Maybe a as basic type
11:16:23 <qnikst> and stop receiving new data until there will be one Nothing
11:17:02 <MagneticDuck> Just a style question.
11:17:42 <MagneticDuck> Everyone typing their answers...
11:17:46 <elliott> MagneticDuck: probably Handle? depends what you're doing
11:17:47 <navaati> MagneticDuck: a handle, and it's not only a style question
11:17:57 <elliott> i mean you can keep the Handle open, so
11:18:00 <navaati> because you don't want to open the file many times
11:18:09 <MagneticDuck> Okay
11:18:11 <monochrom> if I give you a Handle, you do not know who else is using it, you do not know what is interfering you and what you are interfering
11:18:26 <navaati> ah… fair point
11:18:38 <zzo38> You could make both functions if you want to
11:18:39 <elliott> true, concurrent access is a problem there
11:18:46 <navaati> forgot that a handle keeps context…
11:18:53 <monochrom> if I give you a FilePath, you open your own Handle and you have total control over that Handle, no one else is interfering, and you are interfering no one
11:19:07 <navaati> definitely not a style question, then :p
11:19:14 <monochrom> so this is not style. this is correctness
11:19:32 <MagneticDuck> Yeah
11:20:01 <MagneticDuck> However with a FilePath you couldn't work on stdin... just sayin'...
11:20:19 <navaati> MagneticDuck: you can
11:20:21 <zzo38> You can have both if you want to; such as in dvi-processing there is one function loadFont which takes FilePath, and readFont which takes Handle
11:20:27 <navaati> there is this /dev/stdin stuff
11:20:30 <monochrom> this is why a self-respecting operating system provides a filepath for stdin, too
11:20:45 <MagneticDuck> navaait: O.o Wow. Never knew that existed...
11:20:53 <monochrom> an example of a non-self-respecting operating system is msdos
11:21:05 <MagneticDuck> I use Linux
11:21:08 <MagneticDuck> Go Linux
11:21:14 <navaati> it's not portable, though
11:21:20 <MagneticDuck> What isn't?
11:21:25 <MagneticDuck> *nixes?
11:21:49 <navaati> i guess it's possible to do something similar with windows NT, but it's surely not via /dev/stdin
11:22:06 <geekosaur> even in DOS you have CON:
11:22:25 <monochrom> actually, it is called con: in msdos, but msdos has some other non-self-respecting things
11:22:30 <zzo38> geekosaur: That isn't stdin though
11:22:36 <Enigmagic> monochrom: windows supports opening stdin/stdout handles too
11:22:41 <geekosaur> not eactly the same thing, but that's the least of the differences
11:22:42 <Enigmagic> CONIN$ CONOUT$
11:23:05 <zzo38> geekosaur: CON: accesses the console
11:23:09 <MagneticDuck> Never have used msdos. I'm of the new age.
11:23:13 <navaati> a more important question is : is /dev/stdin portable to other unixes
11:23:25 <monochrom> such as obviously copying ideas from unix such as filepaths, but they must change / to \ just to be different, so as to break more portability
11:23:33 <geekosaur> (anyway /dev/stdin /dev/fd/0 etc. are not 100% portable, indeed; you'll find older programs detect "-" as a path and dup stdin/out as appropriate)
11:23:54 <geekosaur> the above speaking solely of unixlikes
11:23:56 <navaati> s/older/a lot of/
11:23:59 <otters> :t (>)
11:23:59 <lambdabot> forall a. (Ord a) => a -> a -> Bool
11:24:04 <otters> :t let gt = (>) in gt
11:24:05 <lambdabot> forall a. (Ord a) => a -> a -> Bool
11:24:40 <MagneticDuck> Btw, can't people just USE GHCI TO DO THEIR BIDDING WITH TYPES??
11:24:42 <zzo38> Usually I prefer in UNIX programs, a filepath is not given at all and it just uses stdin/stdout; some do not do this, though.
11:25:09 <MagneticDuck> *ahem* otters, you can use ghci to do that.
11:25:16 <monochrom> if you take 3 input files, they can't all be stdin
11:25:26 <otters> MagneticDuck: yeah, but in ghci, ":t let gt = (>) in gt" gives me () -> () -> Bool
11:25:46 <MagneticDuck> O.o
11:25:47 <MagneticDuck> weird
11:26:00 <zzo38> That is because () is a default type in GHCi
11:26:03 <Saizan> otters: that's the MonomorphismRestriction + extended defaulting
11:26:06 <timthelion> monochrom: You can have multiple pipes though.
11:26:12 <otters> ohhh
11:26:14 <otters> okay, neat
11:27:03 <MagneticDuck> monochrom: BTW how often do people really use pipes? That is, having a program that they just pipe input to?
11:27:11 <MagneticDuck> A whole separate compiled program>
11:27:17 <MagneticDuck> s/>/?
11:27:25 <zzo38> MagneticDuck: I use pipes a lot in UNIX, and sometimes in Windows too
11:27:45 <elliott> I think Igloo is plotting something
11:27:47 <geekosaur> MagneticDuck, I use pipes and "filters" (programs designed mainly to be used in pipelines) a lot
11:27:49 <monochrom> I often do. cat *.log | grep magneticduck | less
11:28:09 <MagneticDuck> grep? less?
11:28:14 <geekosaur> although that last shoyld be grep magneticduck *.log | less
11:28:21 <geekosaur> "useless use of cat"
11:28:50 <zzo38> monochrom: Yes, sometimes there are program with multiple input and/or multiple output; you would need filenames in that case. But in some cases I don't like it. For example, dvilj4 requires - to use stdin and without a filename is an error; and the record optical disc should also take the .iso on input but it doesn't work
11:28:50 <elliott> no
11:28:57 <elliott> useless use of cat is like useless use of temporary variable
11:29:05 <MagneticDuck> I know very little about actually writing full programs in Haskell... where do you actually use pipes?
11:29:09 <elliott> useless use of "actually writing a pipeline in a consistent order"
11:29:25 <monochrom> grep magneticduck *.log includes filenames in the output, and I don't want that
11:29:54 <monochrom> the actual filenames involved are long and uninformative
11:29:56 <MagneticDuck> what is grep?
11:30:00 <ski> > (id . length) "abcd"
11:30:02 <lambdabot>   4
11:30:06 <Clint> grep -h magneticduck *.log
11:30:12 <geekosaur> ^^ that
11:30:18 <geekosaur> MagneticDuck, it finds patterns
11:30:25 <monochrom> grep is line-by-line search for lines matching a regex
11:30:28 <geekosaur> in this case a literal string but it also speaks regyular expressions
11:30:31 <crutex> SHORYUKEN
11:30:58 <zzo38> For example, sometimes a pipe command will be used like this:     dvilj4 - < paper.dvi | lp      and     zcat < files.tar.gz | tar x
11:31:10 <elliott> MagneticDuck: i think you are confused
11:31:14 <elliott> what do pipes have to do with haskell specifically?
11:31:17 <MagneticDuck> yap
11:31:24 <MagneticDuck> Wait...
11:31:58 <MagneticDuck> I know that pipes are used to pipe a stdin handle to a program that takes a stdin and gives a stdout... or somethin' like athat
11:31:59 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html :)
11:32:30 <MagneticDuck> :P
11:32:55 <ski> monochrom : not `grep -i magneticduck *.log | less', then ?
11:33:03 <MagneticDuck> Okay, let's get this straight... you run commands like that in a real program from a shell file.
11:33:12 <monochrom> thank you for -h, I may use it more
11:33:33 <zzo38> I think the printer accepts PCL, PostScript, PDF, and HTML; no printer accepts DVI (as far as I know) so instead it can be converted using dvilj or dvilj4 from DVI to PCL to be able to print it
11:33:54 * ski looks up `-h'
11:34:09 <monochrom> however, I often switch between "cat *.log | less" and "cat *.log | grep blah | less", eliminating cat and fitting grep -h there is less natural
11:34:10 <elliott> monochrom++ for that webpage
11:34:25 <MagneticDuck> Huh. This is interesting... so programs are like functions... but with files. And | is just composition, in a way.
11:34:34 <geekosaur> yep
11:34:43 <MagneticDuck> BLINDINGLY SIMPLE REVELATION MOMENT
11:34:45 <monochrom> of course, unix programs have side effects, too
11:34:47 <zzo38> MagneticDuck: Yes, it is like a category
11:35:05 <zzo38> The category with side effects. In Haskell, the category with side effects is (Kleisli IO)
11:35:24 <ski> zzo38 : one could also say `< paper.dvi dvilj4 - | lp' respectively `< files.tar.gz zcat | tar x'
11:35:29 <MagneticDuck> Wait, a category...?
11:35:39 <monochrom> but the point of my post is to poke at some profound hypocrisy in some programmers. see the sarcasm part
11:36:02 <zzo38> MagneticDuck: It is OK if you do not understand a category, to program in Haskell, but it helps a bit
11:36:15 * ski . o O ( THE CATEGORY TERRORISTS ARE OUT TO GET YOU ! )
11:36:18 <t7> using Data.Binary to disassemble :)
11:37:05 <avpx> http://en.wikibooks.org/wiki/Haskell/Category_theory
11:37:08 <avpx> This is a fairly good resource
11:37:34 <MagneticDuck> Ah, category theory. AHHHHHH! RUN!!!!
11:37:40 <MagneticDuck> ty
11:37:47 <monochrom> don't run. fly.
11:37:50 <hpaste> timthelion pasted “Why oh why is indentation such a pain?” at http://hpaste.org/66582
11:38:03 <MagneticDuck> monochrom: Good advice. :)
11:38:06 <timthelion> Hello, can anyone explain to me why I get that error?
11:38:08 <monochrom> indentation is supposed to be painful
11:38:13 <elliott> timthelion:
11:38:13 <timthelion> No matter what I put after the where statement.
11:38:13 <elliott> >        if
11:38:14 <elliott> >         case cell of
11:38:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:38:15 <lambdabot>   can't find file: L.hs
11:38:18 <elliott> indentation is irrelevant
11:38:24 <elliott> syntax is relevant
11:38:30 <elliott> oh, wait
11:38:38 <elliott> i see what you're trying to do... i'm not sure that will work
11:38:41 <ski> <http://plato.stanford.edu/entries/categories/> -- this is a fairly irrelevant resources, regarding categories in Haskell
11:38:49 <elliott> you should really just make that case a separate function :p
11:38:53 <zzo38> You can use non-layout mode and the compiler will ignore the indentation, in case that helps. But note that the "possibly incorrect indentation" error message is not always a mistake in indentation
11:39:01 <timthelion> elliott: why should it not work?
11:39:09 <elliott> timthelion: it's weird
11:39:11 <byorgey> timthelion: I think 'then' and 'else' need to be indented more than the 'if'
11:39:12 <elliott> i didn't say "should" anyway
11:39:16 <elliott> i said "will"
11:39:22 <elliott> byorgey: huh, I thought they fixed that?
11:39:42 <monochrom> this is an interesting part of the grammar I haven't thought of
11:39:45 <timthelion> elliott: OK, I'll try that.  But there's no obvious error in what I've written?
11:39:55 <zzo38> And the mistake in hpaste where Literate Haskell is highlighted as a Visual Basic code still exists and has not been corrected
11:40:08 <monochrom> this is not a do-block, so the positions of "then" and "else" are more lax
11:40:26 <byorgey> monochrom: ah, true
11:40:27 <timthelion> byorgey: that has no effect on things unfortunately
11:40:28 <byorgey> timthelion: also, I think the 'if' needs to be indented more than path_points
11:40:33 <byorgey> s/also//
11:40:42 <monochrom> yes, that must be corrected
11:40:51 <byorgey> 'where' does introduce a block
11:40:59 <elliott> it'll be more readable with a separate function too
11:41:01 <byorgey> the first thing following 'where' determines the indentation level for the block
11:41:05 <timthelion> byorgey: thanks.  I told you indentation was a pain :)
11:41:08 <byorgey> the first thing indented less than that, ends the block
11:41:14 <timthelion> byorgey: must be indented more than the name of the function
11:41:22 <monochrom> yeah
11:41:57 <zzo38> Unlike Python, Haskell does not require you to use indentation; you can use explicit {;} instead in case that is easier for you. I know for me it is better to use {;} but not everyone is, so use what you prefer
11:42:01 <timthelion> elliott: readability is a matter of taste.  I want to make it clear, that the case is used there and only there.
11:42:22 <zzo38> And then with explicit {;} you can use your own indentation and the compiler won't care
11:42:25 <ski> timthelion : i think the `case' is fine
11:42:26 <monochrom> > if case () of {_ -> True; _ -> False} then "hi" else "ho"
11:42:27 <lambdabot>   "hi"
11:42:37 <elliott> timthelion: that's what where clauses are for
11:42:42 <monochrom> that part should work fine
11:42:42 <t7> is there a way to decode a byte string and return the rest
11:42:47 <timthelion> zzo38: I'll consider it, but I have a few thousand lines of code without the {}'s and I like consistency for asthetic reasons
11:42:52 <t7> like decode a single Int from the string
11:42:56 <t7> and return the result
11:43:15 <ski> > if case () of _ -> True; _ -> False then "hi" else "ho"  -- monochrom, even this
11:43:15 <lambdabot>   "hi"
11:43:18 <timthelion> zzo38: I wouldn't like to reformat everything
11:43:41 <zzo38> timthelion: It is probably a good idea to be consistent in a single module with {;} or indentation, but if you have separate modules you can make some modules different
11:43:53 <timthelion> zzo38: true
11:44:05 <Saizan> t7: look at runGet and similar
11:44:09 <zzo38> Mixing {;} and layout in the same module would probably make it even more pain
11:44:16 * monochrom will not enter the debate of "you should inline the expression" vs "you should move the expression to a local definition and now invent a 'meaningful' name for it". oh wait, I just did.
11:44:45 * monochrom would just suggest the name see_below
11:45:11 <ski> > if let b = True in if b then b else b then let b = "hi" in if null b then b else b else let b = "lo" in if all isLower b then b else b
11:45:11 <lambdabot>   "hi"
11:45:20 <MagneticDuck> Hello lambdabot!
11:45:55 <gspr> Can one take an MVar (or a TChan) and present it to a function as a read-only such? (I guess what I'm asking: Are there read-only version of MVar and TChan?)
11:46:00 * timthelion points out, that his code would be much nicer if case wasn't stupid, and allowed me to assign many to one casing
11:46:07 <timthelion> s/me/him
11:47:19 <ski> timthelion : yeah, disjunctive patterns would be useful in Haskell
11:47:22 <zzo38> I don't like the way case blocks work in Haskell either; I would have \{...} where the cases are within the {} after \ but Haskell has it one way is the way you will work it
11:47:37 <monochrom> oh, "or-patterns"? case cell of Action{} "or" Dest{} "or" Jump{} -> xxx; _ -> yyy ?
11:47:51 <timthelion> monochrom: yes
11:48:36 <Saizan> gspr: you can pass (takeMVar mvar) to the function instead of mvar directly
11:48:39 <ski> gspr : i'm not sure whether there is any defined, but you could define one as `data ReadMVar b = forall a. RMV (MVar a) (a -> b)' e.g.
11:49:07 <gspr> Saizan: Ah, obviously! Thanks
11:49:14 * ski sneakingly attempts to seduce innocent people with category theory
11:49:31 <mekeor> timthelion: i think you have to use if-then-else then, right?
11:49:45 <timthelion> mekeor: that's another way to do it.
11:50:06 <Saizan> Category Theory: corrupting our youth since 19something
11:50:07 <mekeor> timthelion: so, you currently use several cases, okay, i see.
11:50:14 <ski> zzo38 : yes, multi-armed lambdas would be useful as well
11:50:18 <mekeor> Saizan: lol
11:50:41 <monochrom> lambda octopus
11:50:46 <timthelion> Saizan: isn't it more like categorizing our youth?
11:51:08 <zzo38> Due to the layout rules in Haskell, though, it should require of after \ but in the new one Ibtlfmm my idea, there is no layout so a multi lambda you can use \{} without of
11:52:19 * ski notes the use of "passion" in "● Passion (e.g., being cut, being burned)"
11:52:34 <cheater__> ski: wat
11:52:46 <Saizan> timthelion: tbf i don't have any youth so it could be anything
11:52:47 <ski> <ski> <http://plato.stanford.edu/entries/categories/> -- this is a fairly irrelevant resources, regarding categories in Haskell
11:52:53 <ski> cheater__ ^
11:53:43 <cheater__> why would you link to something that is irrelevant?
11:54:54 <ski> as a humorous response to : <avpx> http://en.wikibooks.org/wiki/Haskell/Category_theory  <avpx> This is a fairly good resource
11:55:21 <avpx> We were talking about categories in Haskell...
11:55:46 <avpx> Bringing up category theory during a conversation on categories doesn't strike me as irrelevant
11:56:39 <ski> avpx : except that my link wasn't about CT (but <http://plato.stanford.edu/entries/category-theory/> on the same site it) :)
11:56:53 <ski> (/s/it/is/)
11:57:16 <avpx> Oh, I see.
11:58:10 <cheater__> ski: ohh, ok
11:58:16 * ski is pondering how to interpret the aristotelian categories in the former link in terms of category theory ..
11:58:43 <cheater__> ski: try #haskell-blah ?
11:59:08 <ski> could do so
12:02:34 * timthelion wonders what would happen preformance wise, if he made a program which started a haskell green thread for every pixel on the screen.
12:04:48 <timthelion> Does anyone know what the memory requirement per green thread is?
12:06:37 <ChristianS> timthelion: not really, but i think it should be pretty low.
12:07:19 <elliott> timthelion: you can have thousands upon thousands of threads with no problem
12:07:24 <elliott> ("green thread" is dubious terminology here)
12:08:15 <MagneticDuck> Does anybody know a "maxby" function that returns the element of a [] with the highest return value to a given function?
12:08:25 <MagneticDuck> Any included in Prelude?
12:08:26 <elliott> :t maximumBy
12:08:27 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
12:08:38 <elliott> :t maximumBy . comparing
12:08:38 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
12:08:51 <t7> @pl get >>= \op -> fmap (op:) go
12:08:52 <lambdabot> flip fmap go . (:) =<< get
12:09:01 <timthelion> elliott: millions :) ?
12:09:36 <MagneticDuck> Ah thanks
12:10:25 <elliott> timthelion: perhaps, sure.
12:13:10 <hpaste> t7 pasted “Disasm DCPU-16” at http://hpaste.org/66585
12:13:41 <MagneticDuck> Hey what's the idea with the order of operations of "::"? Can I say sum $ map read str :: [Integer]?
12:14:05 <MagneticDuck> > sum $ map read "12345" :: [Integer]
12:14:05 <t7> MagneticDuck: yes
12:14:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:14:06 <lambdabot>         against inferred ty...
12:14:19 <MagneticDuck> ?
12:14:20 <t7> in ghci :: binds last
12:14:46 <MagneticDuck> > sum (map read "12345" :: [Integer])
12:14:47 <zzo38> I think you can have a monad for a final object, and a comonad for an initial object, in any category. In Haskell you have:  data Finalize x = Finalize; data Initialize x;   Now Finalize is a monad and Initialize is a comonad (some disagree).
12:14:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:14:48 <lambdabot>         against inferred ty...
12:15:01 <t7> > (+ 1) $ (+ 2) 123 :: Int
12:15:02 <lambdabot>   126
12:15:52 <megajosh2> Uhh
12:15:54 <MagneticDuck> The big akward thing is telling read how you want to read it.
12:16:00 <MagneticDuck> My code up there didn't work...
12:16:05 <megajosh2> Can anybody possibly explain this ghci session I just had?
12:16:14 <megajosh2> Prelude> let gt = (>)
12:16:14 <megajosh2> Prelude> :t gt
12:16:14 <megajosh2> gt :: () -> () -> Bool
12:16:27 <megajosh2> ...why is it taking two units?
12:16:32 <MagneticDuck> We were talking about that just earlier today!
12:16:34 <geekosaur> megajosh2, that is defaulting
12:16:36 <zzo38> megajosh2: Because () is default in GHCi
12:16:52 <megajosh2> I don't get it, defaulting?
12:16:56 <geekosaur> you used a name without parameters ("let gt ="), which triggers the monomorphism restriction
12:17:13 <MagneticDuck> bb everyone
12:17:33 <geekosaur> which forces ghc to look for a single type to assign it.  defaulting akes that type to be () because none of the other types available for defaulting (mostly members of the Num typeclass) are acceptable
12:17:50 <elliott> <t7> in ghci :: binds last
12:17:53 <elliott> incorrect.
12:17:56 <geekosaur> in general turning off the monomorphism restriction is  less confusing
12:17:58 <zzo38> Do you know if this Finalize and Initialize is the case in all categories having final/initial objects to make a monad/comonad? I would think so but don't proof
12:18:06 <geekosaur> (:set -XNoMonomorphismRestriction)
12:18:08 <t7> thanks dwight
12:18:08 <elliott> megajosh2: (sum $ map read str :: [Integer]) is ((sum $ map read str) :: [Integer])
12:18:25 <megajosh2> I thought that caused a compile time error
12:18:40 <elliott> megajosh2: not in ghci, since it has _extended_ defaulting
12:18:42 <elliott> if all else fails it just picks ()
12:19:14 <megajosh2> Strange... I'll try to remember this because that completely stumped me
12:24:28 <gspr> Are MVars a good tool when you have multiple threads that all want to "turn on or off" a producer thread?
12:24:36 <gspr> (warning: vague question, I guess)
12:25:42 <cheater__> yes
12:25:45 <ski> zzo38 : hm, how would you do `extract :: Initialize a -> a' ?
12:26:15 <cheater__> if you have n threads that want to communicate with another thread, mvars are good.
12:26:43 <gspr> great
12:27:17 <ksf_> http://hackage.haskell.org/package/Extra-1.42
12:27:23 <ksf_> that's an extremely broken package.
12:27:33 <geekosaur> megajosh2, just turn off the monomorphism restriction, you'll be much happier
12:27:38 <ksf_> not only the idea and concept is broken, but it doesn't compile without nuking half of it, either.
12:27:48 <ksf_> luckily, ipprint doesn't need that half.
12:27:50 <elliott> geekosaur: until it causes a nasty sharing bug
12:27:55 <elliott> better: just give things type signatures
12:28:00 <enquora> a few questions from someone who has no experience programming in haskell for a production system but is ready to do so...
12:28:28 <enquora> what is the state of xslt support - xslt 1 only as far as I can tell?
12:28:44 <ski> (answer : `extract i = case i of { }')
12:29:34 <navaati> elliott: you cannot give type signatures everywhere (except if you activate ScopedTypeVariables)
12:30:17 <ski> navaati : (nitpick) except that those would be type *ascriptions* :)
12:30:49 <navaati> ski: uh ?
12:31:41 <ski> a type signature is a declaration, a type ascription is an expression (or a pattern, with `ScopedTypeVariables' (or earlier `PatternSignatures'))
12:32:19 <elliott> no, in this case navaati is referring to where-clause declarations
12:32:55 <ski> .. oh, i see
12:32:55 <navaati> and let, yeah
12:33:48 <navaati> (where the fuck do you take this word "ascription" from… /me go check his dictionnary)
12:34:27 <mm_freak> is there a way to let cabal create Paths_XXX such that i can ask for the package name?
12:34:36 <mm_freak> as far as i see there is only a version number
12:34:53 <mekeor> mm_freak: so, yes, there's a way :P
12:35:22 <roconnor> I'm tempted to add terminal :: c x () to the type class containing (&&&) :: c x y -> c x z -> c x (y, z)
12:35:24 <mm_freak> mekeor: ?
12:36:17 <mm_freak> i'd like to have a runtime version of that name
12:36:52 * hackagebot texmath 0.6.0.5 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.0.5 (JohnMacFarlane)
12:36:56 <gridaphobe> does anyone know a way to compile for x86 on ubuntu-64bit? i really don't want to setup a vm just to compile for my tiny ec2 instance :(
12:37:02 <Zamarok> Do these functions that I just wrote exist somewhere in the library already?
12:37:04 <elliott> roconnor: does that obey the lens laws?
12:37:06 <hpaste> Zamarok pasted “mapEvery and applyAll” at http://hpaste.org/66588
12:37:31 <roconnor> elliott: there exists such a terminal lens
12:37:34 <elliott> hmm, i guess so as long as you ignore _|_
12:37:34 <Zamarok> Those functions ^. Seems like they would exist somewhere
12:37:47 <navaati> gridaphobe: should not be too hard with llvm. check if your llvm installation has a backend for i686
12:37:55 <elliott> applyAll = foldr (.) id
12:38:58 <Zamarok> elliott: oh true, I didn't think of that one.. thanks
12:39:21 * roconnor isn't into semigroups as much as edwardk is
12:39:46 <ski> navaati : the term is commonly used in the MLs (and apparently also Scala)
12:40:07 <roconnor> oh wait, lenses have a terminal but don't have an (&&&)
12:40:10 <roconnor> hmm
12:40:21 <ski> navaati : hm, i can find it used in <http://www.cs.washington.edu/education/courses/cse341/04wi/lectures/09-ml-modules.html> .. and also <http://stackoverflow.com/questions/7657827/fun-with-impredicative-polymorphism-and-type-ascription> (in a Haskell context)
12:42:25 <navaati> ski: eh, thanks to you i'll be able to look like a brilliant-guy-who-speak-clever-english
12:43:03 <ski> @type \fs a -> map ($ a) fs  -- Zamarok, `applyAll'
12:43:04 <lambdabot> forall a b. [a -> b] -> a -> [b]
12:43:15 <ski> navaati ;)
12:43:41 <ski> Zamarok : actually, that's wrong
12:43:49 <ski> your `applyAll' is actually `compose'
12:43:58 <ski> @type foldr (.) id
12:43:58 <lambdabot> forall b. [b -> b] -> b -> b
12:44:04 <elliott> <elliott> applyAll = foldr (.) id
12:44:33 <Rmx> mm_freak, when do you plan to release your "next" or FRP oriented version of netwire ?
12:44:42 <ski> @type flip (foldr ($))
12:44:42 <lambdabot> forall b. [b -> b] -> b -> b
12:45:07 <magicman> @type flip . foldr . flip $ id
12:45:08 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
12:45:09 <lambdabot>     Probable cause: `id' is applied to too many arguments
12:45:09 <lambdabot>     In the second argument of `($)', namely `id'
12:45:14 <magicman> @type flip . foldl . flip $ id
12:45:15 <lambdabot> forall b. [b -> b] -> b -> b
12:45:35 <Zamarok> ski: yes elliott told me that same thing a few mins ago ^^
12:45:50 <ski> Zamarok : oh, i didn't notice
12:45:57 <navaati> > (flip (foldr ($))) [(+1),(*2)] 5
12:45:58 <lambdabot>   11
12:46:08 <ski> > foldr (.) id [(10 +),(2 *)] 1
12:46:10 <lambdabot>   12
12:46:16 <ski> > flip (foldr ($)) [(10 +),(2 *)] 1
12:46:17 <lambdabot>   12
12:46:34 <ski> > (flip . foldl . flip) id [(10 +),(2 *)] 1
12:46:35 <lambdabot>   22
12:46:41 <magicman> Order matters :p
12:46:47 <ski> (:
12:46:50 <hpaste> Zamarok pasted “toggles” at http://hpaste.org/66590
12:46:56 <Zamarok> That's what I was doing ^
12:47:17 <ski> meaning that you are doing the reverse composition
12:47:31 <elliott> foldr (>>>) id then
12:47:32 <Zamarok> From this: http://www.reddit.com/r/dailyprogrammer/comments/ruiob/452012_challenge_36_easy/
12:47:47 <navaati> :t Endo
12:47:48 <lambdabot> forall a. (a -> a) -> Endo a
12:48:01 <navaati> hurm, #haskell just kills my productivity, bye
12:48:17 <ski> (Zamarok : fyi, it would have been possible to annotate the original paste instead)
12:48:47 <Zamarok> oh ok, noted
12:48:47 <ghaiaheah> hellooo
12:58:41 <ique> What's the standard package to use for making HTTP requests? "HTTP" on hackage keeps popping up but it lists stability as experimental
12:58:52 <elliott> ignore stability field
12:59:00 <ique> But the version number is 4000, what's up with that?
12:59:00 <elliott> it means less than nothing, everybody sets it to something random then forgets it forever
12:59:11 <elliott> HTTP is part of the haskell platform, cabal-install depends on it -- basically every single haskell user has it.
12:59:13 <ique> elliott: ah i see, thanks
12:59:20 <elliott> there is also http-conduit, which is a bit nicer but not as ubiquitous
12:59:24 <ique> oh i see , doh :P
12:59:35 <elliott> the versioning scheme is weird yeah i don't know what's up with it
13:00:12 <mm_freak> Rmx: i'm not really sure…  currently i'm not really getting around to coding it
13:00:19 <monochrom> people have long stopped updating the stability field
13:00:28 <ique> elliott: thanks
13:00:40 <elliott> as we all know, the stability fields on hackage are proof that haskell has avoided success at all costs
13:00:42 <elliott> ;)
13:06:53 * hackagebot hscd 0.0.1 - Command line client and library for SoundCloud.com  http://hackage.haskell.org/package/hscd-0.0.1 (SebastianMagri)
13:10:22 <qnikst> hello I've got next problem
13:10:32 <qnikst> i'm using Data.Concurrent.Chan
13:10:49 <qnikst> and I want to make it closable
13:11:23 <qnikst> so I have got 2 options, either make it Chan (Maybe a) and send Nothing at the end of stream
13:11:57 <qnikst> or use exceptions, so I should track all listeners and send them StreamEndException
13:12:06 <qnikst> is there any other good solutions?
13:12:18 <qnikst> (I really don't need STM here)
13:16:36 <roconnor> @hoggle a (b,c) d
13:16:36 <lambdabot> No results found
13:16:40 <roconnor> @hoggle a (b,c) b
13:16:41 <lambdabot> No results found
13:16:53 * hackagebot git-annex 3.20120406 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120406 (JoeyHess)
13:16:55 * hackagebot file-embed 0.0.4.2 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.2 (MichaelSnoyman)
13:17:42 <magicman> @ludo a (b,c) b
13:17:42 <lambdabot> Maybe you meant: do todo undo
13:17:47 <magicman> Oh, well.
13:18:09 <rwbarton> @ogle a (b,c) d
13:18:09 <lambdabot> Maybe you meant: google hoogle
13:18:11 <Luke> I'm getting: Couldn't match expected type `B8.ByteString' with actual type `ByteString' -- B8 is Data.ByteString.Lazy.Char8
13:18:28 <Luke> is there a way to decode Word8 to Char8 bytestrings?
13:18:44 <rwbarton> they are the same, however you may have a strict v. lazy issue
13:19:03 <Luke> ah - thanks
13:19:05 <Luke> i'll try that
13:19:42 <parcs`> qnikst: another solution is to pass around an IORef (Maybe (Chan a)) instead of a Chan a
13:20:34 <parcs`> but i like the Chan (Maybe a) one
13:21:43 <qnikst> parcs`: IORef (Maybe .. doesn't work, if I'm closing channel then all messages in channel will be lost
13:22:25 <qnikst> Chan (Maybe a) gives some overhead, and I should do smth like sending N Nothing, where N = number of listeners
13:22:36 <qnikst> so isEmptyChan will not work
13:23:28 <elliott> qnikst: http://hackage.haskell.org/package/stm-chans
13:23:36 <elliott> specifically http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TMChan.html
13:23:48 <elliott> "really don't need STM" is silly
13:23:57 <elliott> it provides the tools you need here, efficiently and simply
13:23:58 <Luke> rwbarton: thanks - is there a way to get a better error there?
13:25:04 <elliott> sure, don't import strict bytestring into your main scope
13:25:07 <elliott> import it qualified so that ghc qualifies its name
13:25:30 <ksf_> is there a way to figure out the SCC of the tvar block that I'm crashing on?
13:25:51 <navaati> elliott: err, sorry to bother you but… i still can't get reflection working -_-
13:25:55 <rwbarton> yeah, I usually do that anyways since otherwise don't you get loads of name clashes with the Prelude/Data.Lit?
13:26:03 <navaati> i've got a function "getResources :: (Reifies drm Drm) ⇒ IO (Resources drm)" where i need to actually use the Drm object
13:26:28 <elliott> navaati: mhm
13:26:37 <elliott> navaati: well by far the easiest way is: turn on scopedtypevariables
13:26:38 <elliott> then do:
13:26:55 <navaati> so i tried to get it using "reflect (Proxy :: Proxy drm)" in the body of the function, hoping that thanks to ScopedTypeVariables unifies the "drm" parameter
13:26:59 <elliott> getResources :: forall drm. (Reifies drm Drm) => IO (Resources drm); getResources = ... where drm = reflect (Proxy :: Proxy drm)
13:27:06 <elliott> navaati: you need the "forall drm."
13:27:11 <elliott> otherwise ScopedTypeVariables doesn't do anyting
13:27:14 <elliott> for backwards-compatibility
13:27:15 <elliott> *anything
13:27:19 <elliott> (yeah it's kinda stupid)
13:28:13 <navaati> ah… it's my fault, i should have read the doc of the extension, though
13:28:15 <navaati> thanks
13:28:19 <elliott> meh, it's really unintuitive :)
13:30:48 <navaati> yay, it works
13:30:55 <elliott> \o/
13:31:26 <navaati> well… it works in ghci : when i try to build with ghc, i get a nice Could not find module `Data.Proxy'
13:31:26 <navaati>     Perhaps you haven't installed the "dyn" libraries for package `tagged-0.2.3.1'?
13:31:36 <navaati> aka "the package system is crap"
13:31:46 <elliott> yeah, time to reinstall some libraries :P
13:31:54 <navaati> not, i just installed it
13:31:55 * elliott wishes we had shorthand for (Proxy :: Proxy T) for some T
13:32:08 <elliott> so we could say (reflect ~drm) or such
13:32:22 <elliott> navaati: well, you need to enable dyn in your cabal config then
13:32:23 <elliott> or something
13:32:30 <elliott> or just don't try and build dyn
13:32:35 <navaati> i don't use cabal
13:32:54 <rwbarton> so you are the package system eh
13:33:15 <qnikst> elliott, I need IO :)
13:33:19 <elliott> as terrible as cabal is, *not* using cabal has got to be slightly worse
13:33:30 <qnikst> without additional STM blocks
13:33:30 <davidd___> I'm trying to run a haskell program but I am getting: Could not find module `Control.Monad.Error'
13:33:34 <elliott> qnikst: STM interacts with IO: you do your IO to get a value, atomically write to the queue
13:33:48 <elliott> you atomically read from a queue (letting you do stm things like "first queue with available value"), then do your IO with the result
13:33:48 <keep_learning> hello all
13:34:02 <qnikst> I know about STM and how it works
13:34:19 <qnikst> but it's overhead can be too big, for some task
13:34:24 <elliott> well, i don't understand your objection then :)
13:34:27 <elliott> what overhead?
13:34:29 <keep_learning> I am trying to profile a Haskell code which involves  library and code from Main ( IO )
13:34:47 <keep_learning> I don't want to profiling result for Main ( IO ) functions
13:34:55 <elliott> if you don't like writing "atomically $", then you can write five lines of wrappers around the operations you use precomposed with atomically (but sacrifice nice things like orElse)
13:35:30 <keep_learning> How to get the profiling results for functions only from library
13:35:46 <qnikst> elliott, it's model has some overhead agains plain chans
13:35:48 <keep_learning> not from Main ( IO ) function in profiling report
13:36:46 <davidd___> anyone know why I can't import Control.Monad.Error? I keep getting an Could not find error.
13:36:47 <qnikst> elliott: I can profile when I'll finish
13:36:48 <qnikst> =)
13:37:03 <elliott> qnikst: Performance-wise, you mean? My understanding is that i depends on your use-case, but STM will generally be competitive with Chan in most scenarios.
13:37:04 <elliott> But okay.
13:38:14 <qnikst> elliott: afaik I should use it when i really need transaction model. with additional guarantees retrying, aborting etc
13:38:27 <qnikst> then is the best thing I can choose
13:39:27 <elliott> People use STM all the time in Haskell. It's not really heavyweight at all.
13:39:42 <elliott> There's no reason not to use it if it has what you offer unless you have a really pathological use-case.
13:40:35 <wo0kie> hello (づ｡◕‿‿◕｡)づ
13:40:48 <DijkstraGroupie> What problems does the monomorphism restriction solve?
13:41:27 <rwbarton> it prevents a value (like a number) being recomputed every time it is used when it would appear from the source to be computed just once and shared
13:42:40 <rwbarton> e.g. if I have a top-level definition x = 2 + 2, and then I write main = print $ x + x, the addition 2 + 2 is liable to be computed twice
13:43:02 <rwbarton> if i didn't have the monomorphism restriction
13:43:41 <ksf_> is there *any* way to get at the cost centre that blocked indefinitely on a tvar?
13:44:06 <DijkstraGroupie> rwbarton: Is that not what seq is for?
13:44:11 <rwbarton> huh?
13:44:21 <rwbarton> seq is irrelevant
13:44:21 <elliott> no, the problem is the overloading
13:44:31 <elliott> it ends up hidden behind a lambda taking a dictionary
13:44:32 <rwbarton> the problem is x is secretly a function that takes a Num dictionary as parameter
13:44:35 <elliott> right
13:44:58 <rwbarton> x numDict = (+) numDict (fromInteger numDict 2) (fromInteger numDict 2) -- or so
13:45:25 <rwbarton> where now (+) and fromInteger are field extractors of the numDict record
13:45:57 <DijkstraGroupie> What is that Num dictionary even?
13:46:34 <rwbarton> well, main becomes   main = print $ (+) numDictForInteger (x numDictForInteger) (x numDictForInteger)
13:46:56 <rwbarton> and numDictForInteger is given by the instance Num Integer where ...
13:47:25 <rwbarton> basically "instance Num Integer where ..." <-> "numDictForInteger = NumDict { ... }"
13:49:23 <DijkstraGroupie> Is it possible to see the source code for Haskell's basic types?
13:49:27 <rwbarton> this is just one way to implement type classes of course
13:50:58 <elliott> DijkstraGroupie: that's implementation-specific
13:50:59 <rwbarton> for GHC, there is an actual "instance Num Integer where ..." in GHC.Prim or GHC.Int or something, but eventually it comes down to machine operations and gmp functions that are exported as primitive operations
13:51:08 <elliott> you can check out the Report for the parts of the standard Prelude that are defined in Haskell
13:51:21 <elliott> or GHC source for the parts of GHC's Prelude that are implemented in (unportable, GHC-specific) "Haskell"
13:51:32 <elliott> well, base source I guess... same thing
13:51:49 <rwbarton> @src Integer
13:51:50 <lambdabot> data Integer = S# Int#
13:51:50 <lambdabot>              | J# Int# ByteArray#
13:52:05 <DijkstraGroupie> Yes, I performed that query a few hours ago.
13:52:19 <DijkstraGroupie> And I want to know what Int# and ByteArray# are.
13:52:22 <rwbarton> ^ more GHC-specific internals, the S# is used for small integers and the J# is used to store gmp's data for large integers
13:52:31 <navaati> "No (or multiple) ghc rts package is registered!!"… f*cking cabal…
13:52:34 <DijkstraGroupie> gmp?
13:52:41 <dmwit> DijkstraGroupie: J# n arr records the n-bit number with bits as stored in arr.
13:53:00 <DijkstraGroupie> Ah.
13:53:07 <ksf_> #-types are magic unboxed types.
13:53:17 <danharaj> also unlifted
13:53:17 <rwbarton> gmp is a C library for arbitrary precision arithmetic
13:53:55 <elliott> navaati: i thought you didn't use cabal
13:53:59 <elliott> sounds like your packages are completely broken anyway
13:54:00 <ksf_> they are a) always strict, that is, never thunks and b) never bottom
13:54:03 <rwbarton> "S# Int#" means the runtime representation of the value looks like a word identifying that this is a value built with the S# constructor, and then literally 4 (or 8) bytes that store an integer
13:54:32 <rwbarton> as opposed to "X Int" which means there is a word identifying the constructor, and then a pointer to either an Int or a thunk
13:55:18 <navaati> elliott: i had decided to not use it because i had not enough ram for it, but i've bought ram so now it should be ok, and maybe using it would fix that package problem
13:55:30 <elliott> navaati: erm, cabal-install doesn't take up much ram
13:55:31 <elliott> ghc does
13:55:48 <DijkstraGroupie> Whoa, and I thought Haskell types were constructed using type sums / products only...
13:55:58 <navaati> linking ./Setup.hs used to full my ram…
13:55:58 <ksf_> rarely if ever significantly more than 1G, though.
13:56:05 <ksf_> even 1G needs some massive files.
13:56:06 <elliott> DijkstraGroupie: you're not talking about haskell any more, you're talking about GHC
13:56:16 <ksf_> linking is another issue, that's not ghc, but ld.
13:56:18 <navaati> i had got 512M
13:56:19 <elliott> navaati: well cabal (not cabal-install) is a core ghc component, you can't really do without it :p
13:56:22 <elliott> but yes, what ksf_ said
13:56:23 <elliott> try gold linker
13:56:40 <navaati> no, now it's ok i bought some (ugly solution, i know :)
13:56:53 <elliott> since you have broken packages, I suggest rm -rf ~/.{cabal,ghc}, install cabal-install, turn on variants (like profiling) you want in ~/.cabal/config and start anew
13:57:00 <elliott> if you've installed globally... whoops
13:57:01 <ksf_> projects like chromium and firefox have massive problems with linking.
13:57:06 <elliott> actually i have no idea how you could be installign without cabal but whatever :P
13:57:10 <byorgey> DijkstraGroupie: Haskell types are also constructed from some specified base types such as Int, Char, and Double, which are not algebraic, and the standard does not specify how they are to be implemented.
13:57:13 <ksf_> as in needing >64G and such.
13:57:28 <elliott> ksf_: firefox is just >2 or >4 gig i think
13:57:40 <navaati> elliott: all the package i needed were in my distro
13:57:59 <ksf_> elliott, before or after splitting everything in .so's?
13:58:27 <navaati> ksf_: on my gentoo box i used to build firefox and chromium with 8G of ram, and i think it didn't fill it
13:58:41 <elliott> navaati: ah
13:58:45 <navaati> but maybe they switched to gold
13:58:54 <elliott> navaati: uninstall all distro haskell packages (apart from ghc and cabal-install, those are OK)
13:59:01 <elliott> see http://www.vex.net/~trebla/haskell/sicp.xhtml for why
14:00:09 <elliott> navaati: (you might also want to consider using cabal-install only to install cabal-dev, then doing everything from inside cabal-dev sandboxes)
14:00:17 <elliott> (which protects you from the horrible mess of throwing away + reinstalling everything when packages break)
14:00:52 <navaati> elliott: oh, i think it's the --user side that is broken, not the --system side
14:01:04 <elliott> navaati: doesn't matter
14:01:09 <elliott> http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
14:01:34 <krawczyk> elliot: If I remember correctly the problem with linking Firefox is that in order to compile the 32Bit FF you need a 64Bit machine...
14:01:42 <elliott> krawczyk: yeah
14:03:58 <navaati> krawczyk: ahahah, funny thingh :D
14:04:00 * ski . o O ( `class Dict c where withDict :: (c => o) -> o' )
14:04:20 <navaati> hum, i'll check this cabal-dev thing
14:04:56 <elliott> ski: take a look at edwardk's constraints package :p
14:05:18 <elliott> navaati: basically it keeps a separate package repository for each project -- so any disasters are localised
14:05:39 <krawczyk> @type (:)
14:05:39 <lambdabot> forall a. a -> [a] -> [a]
14:05:45 <elliott> don't use distro packages, use cabal-install only to install programs + cabal-dev, and use cabal-dev for everything else --> far mitigated chance of package disasters
14:07:00 <elliott> navaati: anyway, I've gotta go now... hope you get things working :)
14:07:41 <navaati> elliott: thanks a lot again for your help, now that i understood how this reflection thing work, it should be mostly ok
14:08:05 <mhitza> hey guys, how whould I write a function for this type: Int -> [a] -> [[a]] ?
14:08:15 <mhitza> where int is the length of the sublists
14:08:40 <mhitza> ex, f1:: Int -> [a] -> [[a]]
14:08:55 <mhitza> f1 2 [1,2,3,4] = [[1,2], [3,4]]
14:09:09 <edwardk> mhitza: break down the problem into something recursive, the base case is a list of the empty set, then go one step up
14:09:47 <navaati> i would say it's an unfold job
14:09:52 <navaati> :t unfold
14:09:53 <lambdabot> Not in scope: `unfold'
14:09:56 <navaati> :t unfoldr
14:09:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:13:04 <ski> mhitza : are you trying to code it, or are you just looking for a library function ?
14:13:46 <edwardk> mhitza: you want ghci> f 2 [1,2,3,4,5]
14:13:46 <edwardk> [[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5]] ?
14:13:48 <mhitza> ski, I'm thinking of the way to write it, but if there it is already somewhere awaylable I'm rather have my time with something else :)
14:13:56 <mhitza> edwardk,
14:13:58 <ski> lookup `chunk' in `Data.List.split'
14:14:00 <mhitza> ex, f1:: Int -> [a] -> [[a]]
14:14:01 <mhitza> <mhitza> f1 2 [1,2,3,4] = [[1,2], [3,4]]
14:14:01 <ski> @hackage split
14:14:01 <lambdabot> http://hackage.haskell.org/package/split
14:14:05 <ski> mhitza : then ^
14:14:19 <edwardk> lets break it down. you need a base case for induction
14:14:41 <edwardk> f 0 xs = [[]] -- gives you the fact that no matter what the list has left in it, you can always extract a 0 length subset exactly once
14:14:42 <mhitza> ski, wierd I hoogled it before :|
14:14:47 * ski is sorry if he's ruining the fun
14:15:08 <edwardk> f n [] = [] -- gives you the fact that you can't take elements from an empty list
14:15:16 <edwardk> then you just need the inductive step
14:15:20 <edwardk> f n (x:xs)
14:15:27 <edwardk> there are two things you want to do
14:15:40 <edwardk> you need f n xs -- so you evaluate what happens if you don't include the x
14:15:54 <edwardk> and you need to cons x onto each of the results returned from f (n - 1) xs
14:16:00 <edwardk> so
14:17:02 <edwardk> f n (x:xs) = f n xs ++ map (x:) (f (n - 1) xs)
14:17:02 <edwardk> > let f 0 xs = [[]]; f n [] = []; f n (x:xs) = f n xs ++ map (x:) (f (n-1) xs) in f 2 [1,2,3,4,5,6]
14:17:03 <lambdabot>   [[5,6],[4,6],[4,5],[3,6],[3,5],[3,4],[2,6],[2,5],[2,4],[2,3],[1,6],[1,5],[1...
14:17:19 <edwardk> > let f 0 xs = [[]]; f n [] = []; f n (x:xs) = map (x:) (f (n-1) xs) ++ f n xs in f 2 [1,2,3,4,5,6]
14:17:21 <lambdabot>   [[1,2],[1,3],[1,4],[1,5],[1,6],[2,3],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6],[4...
14:17:29 <edwardk> and the latter gives you them in order
14:17:34 <edwardk> > let f 0 xs = [[]]; f n [] = []; f n (x:xs) = map (x:) (f (n-1) xs) ++ f n xs in f 8 [1,2,3,4,5,6]
14:17:36 <lambdabot>   []
14:17:48 <edwardk> and you can see there are no 8 element subsets of a list of 6 elements as well
14:18:45 <edwardk> mhitza: that make sense?
14:18:57 <krawczyk> what about? f n xs = take n xs : f n $ drop n xs
14:19:18 <krawczyk> Ah wait, that will not work...
14:19:23 <edwardk> krawczyk: the problem there is you are only computing runs of that length
14:19:41 <mhitza> edwardk, was with the prior response but ski told me the exact one I wanted was actually the chunk function
14:20:43 <edwardk> oh, you didn't want lengths of subsets, you wanted to break it up on regular intervals
14:21:06 <mhitza> edwardk, yes, wrong wording from me when asking
14:21:29 <krawczyk>  
14:21:32 <krawczyk> -- | split at regular intervals
14:21:34 <krawczyk> chunk :: Int -> [a] -> [[a]]
14:21:36 <krawczyk> chunk _ [] = []
14:21:38 <krawczyk> chunk n xs = y1 : chunk n y2
14:21:40 <krawczyk>   where
14:21:42 <krawczyk>     (y1, y2) = splitAt n xs
14:21:44 <krawczyk> Can be found at http://www.haskell.org/haskellwiki/Data.List.Split.
14:21:55 * hackagebot darcs-beta 2.7.99.2 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.7.99.2 (GaneshSittampalam)
14:21:56 <edwardk> > chunk _ [] = []; chunk n xs = ys:chunk n zs where (ys,zs) = splitAt n xs in chunk 2 [1,2,3,4,5]
14:21:57 <lambdabot>   <no location info>: parse error on input `='
14:23:49 <krawczyk> > take 5 "lkasdjflkajsdkfj"
14:23:50 <lambdabot>   "lkasd"
14:24:01 <krawczyk> > drop 5 "1234567890"
14:24:02 <lambdabot>   "67890"
14:24:21 <krawczyk> > chunk 5 "alskdjflaksjfklasjlfkajsfjakl"
14:24:22 <lambdabot>   Not in scope: `chunk'
14:25:08 <hpaste> navaati pasted “mhitza, your stuff done with unfoldr” at http://hpaste.org/66594
14:27:33 <thinker341> take 1 "abc"
14:27:42 <thinker341> > take 1 "abc"
14:27:43 <lambdabot>   "a"
14:28:00 <ezyang> I have a stream of data containing XML. Do I want to use xml light for this, or is there a better, stream based parser?
14:28:11 <ezyang> parseXML does OK at lazyIO, although not super well.
14:33:46 <mhitza> navaati, Yeah I've tried that way as well but didn't think of splitAt, or have tried to search for that type
14:34:35 <ski> > (\n as -> uncurry (:) (foldr (\a i_as i -> let (bs,bss) = i_as i'; (i',res) | i == 0 = (n-1,([a],bs:bss)) | otherwise = (i - 1,(a:bs,bss)) in res) (\_ -> ([],[])) as (n - 1))) 3 "abcdefgh"
14:34:36 <lambdabot>   ["abc","def","gh"]
14:35:16 * ski wonders how to make that behave sanely when the chunk size divides the length
14:35:31 <navaati> welcome to #masochist :)
14:35:46 <krawczyk> ski: use pattern matching?
14:36:09 <ski> krawczyk : well, i am using pattern matching :)
14:36:41 <ski> (even mutually cyclic value definitions)
14:36:47 <krawczyk> Argl, yes, you know... :-/
14:36:52 <krawczyk> I think it is late...
14:37:04 <ski> aye, i think i know what you meant ;)
14:37:33 <krawczyk> @type splitAt
14:37:33 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:37:49 <krawczyk> @type foldr
14:37:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:38:41 <krawczyk> BTW, is there anything nicer than "liftM2 (:)"?
14:38:52 <ski> it might be fun to figure out a not-too-bad way to do it, using `unfoldr', as navaati suggested ..
14:39:02 <ski> @type liftM2 (:)
14:39:02 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
14:39:10 <navaati> ski: i posted the answer with unfoldr
14:39:27 <navaati> grep hpaste backlog | tail :)
14:39:36 <ski> @type \ma mas -> return (:) `ap` ma `ap` mas
14:39:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m [a] -> m [a]
14:39:37 <krawczyk> http://hpaste.org/66594
14:39:55 <ski> @type \ma mas -> pure (:) <*> ma <*> mas
14:39:56 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f [a] -> f [a]
14:40:01 <ski> @type \ma mas -> (:) <$> ma <*> mas
14:40:01 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f [a] -> f [a]
14:40:04 <navaati> nicer version btw : http://hpaste.org/66596
14:41:48 <ski> ah, didn't notice hpaste
14:42:24 <ski> (navaati : fyi, you might want to annotate the original paste with related pastes like this, instead of making a new paste)
14:42:48 <krawczyk> ski: thanx! Now, I need to wrap by brain around this.
14:42:49 <rwbarton> > let chunks n = unfoldr $ \l -> guard (not $ null l) >> Just (splitAt n l) in chunks 3 "abcdefghi"
14:42:50 <lambdabot>   ["abc","def","ghi"]
14:43:11 <ski> navaati : heh, ok. well that's cheating, since it uses `splitAt' ;)
14:43:43 <rwbarton> arguably if-then-else would be better
14:43:47 <navaati> it uses 2 functions of the stdlib for a minimal code, i think it's the best definition of "nice" :)
14:44:30 <navaati> rwbarton: i think that your version fails in some cases
14:44:37 <ski> krawczyk : `pure' and `(<*>)' are basically the same operations as `return' and `ap', but using `Applicative' instead of `Monad' (if `Applicative' was a superclass of `Monad' we wouldn't need the name duplication)
14:44:37 <navaati> > let chunks n = unfoldr $ \l -> guard (not $ null l) >> Just (splitAt n l) in chunks 3 "abcdefghij"
14:44:38 <lambdabot>   ["abc","def","ghi","j"]
14:44:43 <navaati> ah, no
14:45:04 <navaati> i thought it would discard j…
14:45:10 <rwbarton> i just simplified your code a little
14:45:11 <ski> krawczyk : and `<$>' is just a synonym for `fmap', which corresponds to `liftM' in `Monad' (see previous parenthetical comment here)
14:46:00 <navaati> yeah, yeah, i said that because i was checking for both composants of the output of splitAt to be null, but… well yeah
14:46:00 <ski> krawczyk : if someone haven't forgotten to make an instance of `Monad' into an instance of `Applicative' as well, you can use the `pure' and `(<*>)' (and often `(<$>)' as well) in the monadic case
14:46:20 <krawczyk> Hold on, still reading doku...
14:46:32 <ski> rwbarton : or possibly a monad comprehension
14:47:23 <ski> > let chunks n = unfoldr $ \l -> [splitAt n l | not (null l)] in chunks 3 "abcdefghi"  -- alas
14:47:24 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, b)'
14:47:24 <lambdabot>         against infe...
14:47:45 <navaati> <$> should really really be in the prelude
14:47:59 <krawczyk> ski: OK, back to the books... Thank you for the hint!
14:48:05 * ski thinks `<*>' would be better named `<$>'
14:49:42 <navaati> rwbarton: just to be sure : you use guard in the maybe monad, here, right ?
14:49:57 <ski> navaati : yes
14:53:08 <mikeplus32> where is the sort function for Text?
14:54:33 <ique> Does forkIO distribute the threads across cores automatically?
14:54:49 <ique> Maybe I'm just missing a compile flag, because mine doesn't?
14:55:19 <gspr> ique: Did you compile with -threaded?
14:56:09 <ique> gspr: Ah.. nope.. sorry.. I thought I did but I was looking at an old .cabal file >.<
14:56:32 <gspr> ique: Happens :)
14:59:47 <navaati> grrrr, i can't resolve this "cabal: No (or multiple) ghc rts package is registered!!" problem…
15:00:02 <navaati> all my --user stuff are cleaned
15:00:13 <navaati> i just don't understand -_-
15:04:11 <navaati> (ok, my Build-depends: line was commented out…)
15:07:00 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; lpf n = head [p | p <- primes, n `mod` p == 0]; euclidMullin = map (lpf . (+1)) . scanl (*) 1 $ euclidMullin in take 7 euclidMullin
15:07:02 <lambdabot>   [2,3,7,43,13,53,5]
15:08:18 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; lpf n = head [p | p <- primes, n `mod` p == 0] in take 7 . fix $ map (lpf . (+1)) . scanl (*) 1
15:08:19 <lambdabot>   [2,3,7,43,13,53,5]
15:09:26 <navaati> result if out of order while in the end all you do is a filter ? oO
15:09:43 <Cale> hm?
15:10:04 <monochrom> that sentence itself is out of order :)
15:10:29 <navaati> lambdabot outputs [2,3,7,blahblah,5]
15:10:39 <Cale> The nth term of that sequence is the least prime factor of 1 plus the product of the first n-1 terms
15:11:30 <Cale> It's a sequence of distinct primes, but it is an open problem as to whether it contains every prime
15:11:37 <navaati> ah, i didn't see the last part of the expression (after the "in")
15:11:45 <Cale> 2, 3, 7, 43, 13, 53, 5, 6221671, 38709183810571, 139, 2801, 11, 17, 5471, 52662739, 23003, 30693651606209, 37, 1741, 1313797957, 887, 71, 7127, 109, 23, 97, 159227, 643679794963466223081509857, ...
15:12:33 <navaati> i'd better stop talking, now, too tired to do it…
15:13:15 <hnsz> Cale: The question is if there are an inf amount of those?
15:14:07 <Cale> hnsz: No, there is definitely an infinite number of distinct primes in the sequence
15:14:15 <Cale> The question is whether every prime occurs
15:16:27 <hnsz> cale: Oh right I see it now.
15:17:30 <hnsz> Cale: That is a weird sequence
15:17:36 <Cale> Indeed :)
15:17:39 <ski> Cale : hm, that's called Euclid-Mullin ?
15:17:41 <Cale> yeah
15:17:56 * ski remembers using that to prove there were infinitely many primes on an exam
15:18:10 <ski> (by proving it is injective)
15:18:25 <Cale> ski: After Euclid's proof that there are infinitely many primes, and a guy who asked about it in 1963 :)
15:19:17 <ski> Cale : *nod*, i had seen the idea floating around .. i defined the function using total/strong induction
15:19:43 <hnsz> Cale: wait why does 13 come before 5?
15:20:02 <Cale> hnsz: Well, that's a hard question to give a meaningful answer to
15:20:25 <Cale> > 1 + product [2, 3, 7, 43]
15:20:26 <lambdabot>   1807
15:20:42 <Cale> 1807 doesn't have a factor of 5, but it has a factor of 13
15:20:53 <hnsz> Cale: 2 = 3; 2,3 = 7;2,3,7=43;
15:20:53 <ski> hnsz : mathematically, we are basically defining `a_n = the_least_prime_factor_of (1 + (product i < n. a_i))'
15:21:26 <ski> > 1 + product []
15:21:26 <lambdabot>   2
15:21:32 <ski> gives `2' as `a_0'
15:21:49 <ski> hnsz : do you get the idea ?
15:23:52 <hnsz> ski: you take all the factors in the sequence so far multiply by factor(s) X and add 1 to get a new prime number. then add the new factors and the new resulting prime in order to the sequence.
15:23:54 <hnsz> ?
15:24:58 <Cale> You multiply together all the elements of the sequence so far and add 1. The result may not be prime, but its least prime factor is an element not already in the sequence, because it can have no factor in common with them.
15:26:16 <hnsz> so S= {2}, S={2, 2+1}, S={2,3,2*3+1}, S={2,3,7,2*3*7+1}, S={2,3,7,43,etc}
15:26:40 <Cale> > 2*3*7+1
15:26:41 <lambdabot>   43
15:26:43 <ski> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; lpf n = head [p | p <- primes, n `mod` p == 0]; a n = lpf (1 + product (map a [0 .. n-1])) in map a [0 .. 6]
15:26:44 <lambdabot>   [2,3,7,43,13,53,5]
15:27:04 <Cale> > 2*3*7*43+1
15:27:05 <lambdabot>   1807
15:27:28 <ski> hnsz : you don't always get a prime number when you add one here
15:27:30 <Cale> > (2*3*7*43+1) `mod` 13
15:27:31 <lambdabot>   0
15:27:40 <hnsz> Iski: I realise _that_
15:27:42 <hnsz> :p
15:28:03 <hnsz> That is why you start trialing 5 again.
15:28:21 <ski> hnsz : you said "then add the new factors", but you only add the least prime factor, not all the prime factors
15:28:28 <hnsz> Maybe it's better you tell me what this is called so I can read it for myself :p
15:28:33 <Cale> http://en.wikipedia.org/wiki/Euclid%E2%80%93Mullin_sequence
15:29:19 <hnsz> Though my theory works untill 43 (atleast :p)
15:29:38 <ski> hnsz : see Cale's `1807' above :)
15:30:48 <hnsz> ski: yes but then you start trialing in order all the primes you haven't had and had not included yet untill you get something that works
15:31:42 <hnsz> ski: According to my thing. But that was just inference, which could be falsificationism :p
15:31:44 <Cale> hnsz: Well, that's how I do it there, but it's just computing the least prime factor however you want to do it -- doesn't need to be by trial division of course.
15:31:44 <ski> hnsz : yes
15:32:00 <ski> but each step only constructs a single new (prime) number in the sequence
15:32:17 <Cale> (in fact, if you want to compute a few more terms, you're going to need something better than trial division pretty quickly)
15:33:15 <Cale> especially once you hit 87991098722552272708281251793312351581099392851768893748012603709343  :D
15:34:28 <JoeyA> > log 87991098722552272708281251793312351581099392851768893748012603709343
15:34:29 <lambdabot>   156.44785179608903
15:34:42 <hnsz> cale: But you had already skipped 5. You had to include all the primes in the sequence so far and start doing trials with 5,11,13; including a subset of those in the product and add one in order to get a prime. Take the first that works and add the subset and the new prime.
15:34:52 <ski> @let depProd 0 f = 1; depProd n f = f m * depProd m f where m = n - 1
15:34:54 <lambdabot>  Defined.
15:35:09 <ski> @let depSum 0 f = 0; depSum n f = f m + depSum m f where m = n - 1
15:35:10 <lambdabot>  Defined.
15:36:08 <hnsz> Cale: I'm going to try and write it in some psuedocode .
15:36:11 <Cale> hnsz: hmm, the way you're describing it is weird
15:36:19 <Cale> hnsz: I didn't skip 5
15:36:23 <Cale> hnsz: I just didn't hit it
15:36:34 <hnsz> cale: Let me try and put it on paper :)
15:36:50 <ski> > map (((^ 2) . (`depSum` \i -> i)) &&& (`depSum` \i -> i^3)) [0 ..]
15:36:52 <lambdabot>   [(0,0),(0,0),(1,1),(9,9),(36,36),(100,100),(225,225),(441,441),(784,784),(1...
15:37:45 <ski> > logBase 2 87991098722552272708281251793312351581099392851768893748012603709343
15:37:46 <lambdabot>   225.70653994394914
15:39:23 <ski>   a 0  =  lpf (1 + product (map a [0 .. 0-1]))
15:39:39 <ski>        =  lpf (1 + product [])
15:39:48 <ski>        =  lpf (1 + 1)
15:39:50 <ski>        =  2
15:39:55 <ski>   a 1  =  lpf (1 + product (map a [0 .. 1-1]))
15:40:05 <ski>        =  lpf (1 + product [a 0])
15:40:13 <ski>        =  lpf (1 + 2)
15:40:16 <ski>        =  3
15:40:21 <ski>   a 2  =  lpf (1 + product (map a [0 .. 2-1]))
15:40:26 <ski>        =  lpf (1 + product [a 0,a 1])
15:40:35 <ski>        =  lpf (1 + 2 * 3)
15:40:40 <ski>        =  7
15:40:46 <ski>   a 3  =  lpf (1 + product (map a [0 .. 3-1]))
15:40:52 <ski>        =  lpf (1 + product [a 0,a 1,a 2])
15:41:00 <ski>        =  lpf (1 + 2 * 3 * 7)
15:41:06 <ski>        =  43
15:41:11 <ski>   a 4  =  lpf (1 + product (map a [0 .. 4-1]))
15:41:22 <ski>        =  lpf (1 + 2 * 3 * 7 * 43)
15:41:27 <ski>        =  lpf 1807
15:41:32 <ski>        =  13
15:41:44 <ski> hnsz : ^ that's basically how it is computed
15:42:13 <ski> note how we haven't "hit" `5' yet in the sequence, even though we've reached `13' and `43'
15:42:36 <zzo38> I think Free isn't a proper monad transformer. But a monad transformer FreeT could be made up   newtype FreeT f m x = FreeT (m (Either x (f (FreeT f m x))));
15:42:41 <ski> whether we have tried dividing `43' and `1807' by `5' to see if they are non-primes is irrelevant here
15:43:16 <ski> zzo38> :i Free
15:43:28 <zzo38> And, Cofree is not a proper comonad transformer either
15:43:51 <hnsz> ski: THanks :) I'm trying get down what I meant.
15:43:58 <zzo38> ski: http://hackage.haskell.org/package/free
15:44:04 <ski>   data Free m a = Return m a
15:44:05 <ski>                 | JoinLift (m (Free m a))
15:44:06 <ski> ?
15:44:31 <zzo38> ski: No, that is a kind mismatch it isn't valid
15:44:58 <ski> er, s/Return m a/Return a/, of course, yes
15:45:12 <zzo38> ski: Yes, like that.
15:46:32 <Cale> zzo38: Which monad axiom does  Free m  fail to satisfy when m is a monad?
15:46:33 <ski> zzo38 : so (a) why isn't `Free' a monad transformer; and (b) why is your `FreeT' above a monad transformer ?
15:47:10 <ski> hm
15:47:20 <ski>   Free :: (* -> *) -> (* -> *)
15:47:35 <zzo38> ski: Because return is not the same as lift . return
15:47:36 <ski>   FreeT :: (* -> *) -> (* -> *) -> (* -> *)
15:47:50 <zzo38> (Same with Cofree; extract is not the same as extract . lower)
15:47:51 <ski> zzo38 : so, are you claiming `FreeT f' is a monad transformer for every `f' ?
15:48:25 <zzo38> ski: I don't know, but I think so (if f is Functor)
15:49:06 <navaati> what is The Right Way to build a binary in order to test a library i'm coding ?
15:49:09 <ski> zzo38 : with `lift ma = JoinLift (liftM Return ma)' ?
15:49:12 <zzo38> ski: At least I know it is a monad transformer if f is a Store comonad
15:49:23 <navaati> (that is, a library that i don't want to "cabal install")
15:49:47 <zzo38> navaati: I use GHCi for that purpose
15:49:57 <zzo38> (But I don't know if that is The Right Way)
15:50:27 <zzo38> ski: That isn't a proper monad transformer
15:50:56 <ski> zzo38 : ok, so i think your criticism of `Free' is that it, interpreted concretely, is in fact not a monad transformer -- otoh if interpreted abstractly (i.e. if the constructors were hidden), then it would be a monad transformer
15:51:09 <ski> zzo38 : "that" being ?
15:51:26 <zzo38> ski: `Free' itself is not wrong; the only thing is it isn't a monad transformer. `Free' makes a monad from any functor
15:51:32 <DijkstraGroupie> What does * -> * mean exactly?
15:51:43 <zzo38> ski: "that" being `lift ma = JoinLift (liftM Return ma)'
15:52:11 <zzo38> (There is no way to make it a proper monad transformer)
15:52:24 <ski> zzo38 : ok, but do you agree with my "i think your criticism ..." ?
15:54:00 * ski patiently waits for zzo38's answer
15:54:02 <zzo38> ski: OK, that might be true; but, I don't think Free would be very useful if the constructors are hidden. Also, that doesn't apply to Cofree not being a proper comonad transformer
15:55:10 <Cale> DijkstraGroupie: * is the kind of all ordinary types (the ones with values in them)
15:55:11 <ski> zzo38 : well, you could export functions wrapping the constructors -- it's only the pattern-matching on them which is bad in this context
15:55:24 <Cale> DijkstraGroupie: * -> * is the kind of all type constructors which have a parameter of kind *
15:55:28 <ski> DijkstraGroupie : aka "the kind of all concrete types"
15:55:32 <Cale> (and produce a type of kind *)
15:55:45 <Cale> For example, Maybe :: * -> *
15:55:58 <ski> `Int' and `[Int]' and `Maybe (Bool,Int)' are all concrete types
15:56:01 <DijkstraGroupie> :O
15:56:13 <zzo38> (Although as far as I know, Cofree should have ComonadHoist)
15:56:20 <ski> `Maybe',`[]',`IO',`Either String',`Either' are not concrete types
15:57:05 * ski notes that O'Caml allows one to export constructors in such a way that you can match on them, but not call them -- this can be useful when you need to check invariants when constructing
15:57:21 <Veinor> ski: dang that's neat
15:59:17 <hnsz> Are you ready?
15:59:26 <hnsz> Cale, Ski: http://codepad.org/SkUcSn5o
15:59:46 <hnsz> That is my brainfart (lot's of ethanol)
15:59:48 <zzo38> (FreeT f is also monad transformer if f is the indexed store comonad)
15:59:51 <hnsz> lots*
16:00:19 <hnsz> it's one iteration
16:01:05 <ski> Veinor : see "Language Extensions - 7.9 - Private types" <http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc76>
16:01:55 <ski> zzo38 : isn't that kind-incorrect ?
16:02:34 <zzo38> ski: Yes it is; I mean something like (FreeT (IxStore x y))
16:03:58 <ski> zzo38 : anyway, your complaint is similar to the one about `data InitialMonad a where Return :: a -> InitialMonad a; Bind :: InitialMonad a -> (a -> InitialMonad b) -> InitialMonad b' not really being a monad
16:05:09 <ski> zzo38 : similarly, if you have a definition of a type `Foo a', and add an alternative `forall b. FMap (b -> a) (Foo a)', that doesn't properly make it into a `Functor'
16:05:49 <ski> (er, `forall b. FMap (b -> a) (Foo b)' i meant -- the point being that `FMap :: (b -> a) -> (Foo b -> Foo a)')
16:07:38 <zzo38> ski: Yes I guess it is similar to that; it is correct that is not really being a monad and a functor
16:07:46 <ski> zzo38 : the "proper" way to turn `Foo' into a `Functor' is to *wrap* it in a new type instead, like `type FooFunctor = CoYoneda Foo' (where `data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)')
16:08:16 <ski> or directly as `data FooFunctor b = forall a. FMapIncl (a -> b) (Foo a)'
16:08:47 <strager> @pl \e -> A <$> t (d e)
16:08:47 <lambdabot> (A <$>) . t . d
16:09:53 <ski>   fmap A . t . d  -- or `liftM' or `liftA' instead
16:10:31 <ski> zzo38 : i'm still not clear on why your `FreeT f' would be a monad transformer, though ..
16:10:40 <zzo38> ski: I said I am not sure
16:11:31 <ski> yea, i'm just wondering why you suspect it to be a monad transformer, why it is a "fix" for the brokenness of `Free', in this regard
16:11:47 <zzo38> I do know about Yoneda lemma and how they make a functor from anything; and I can see how CoYoneda does too
16:12:15 <zzo38> ski: I did not say Free is broken; it isn't broken. It simply is not a monad transformer, that's all.
16:15:42 <ski> zzo38 : yeah, ".. brokeness of `Free', in this regard" -- referring to how it's "almost", but not quite a monad transformer
16:16:15 <ocaml> hello, I have a question. What is the most efficient way to peek/poke a Pointer with a strict ByteString of finite length?
16:17:53 <zzo38> (Free f) still makes a monad if f is monad but that doesn't make it a transformer
16:18:24 <ocaml> for peek I am thinking something along the lines of: create 8 (\p-> memcpy p ptr 8) ..thoughts?
16:19:20 <nyingen> why would a package install fine with 'cabal install', but fail to build due to a dependency version problem when I do 'cabal fetch' and then try to build it myself?
16:19:47 <ocaml> ptr is the pointer we wish to poke and 8 is the length of the ByteString in the example above..
16:20:52 <ocaml> nyingen what is the name of the package?
16:21:14 <zzo38> nyingen: Possibly due to a hidden package, or different versions of packages?
16:27:19 <clintm> How do you add typeclass constraints to a data definition?  data A = A { a_thing :: <i dont care as long as it can TypeClass>}  or is this one of those instances where, if I get to this point, I need to rethink my problem?
16:28:17 <zzo38> lift = FreeT . fmap Left; join (FreeT x) = FreeT (x >>= either runFreeT (fmap join));
16:28:32 <zzo38> O no, wait, that isn't correct
16:28:52 <nyingen> ocaml: this would be mueval
16:29:09 <nyingen> It depends on mtl > 2, but several of its other dependencies depend on mtl-1.1.1.1
16:29:57 <nyingen> the strange thing is that it installed fine via cabal install, but i need to add some ghc options and recompile, and that generates errors about the versions
16:30:09 <nyingen> so what is cabal install doing differently than 'cabal configure; cabal build'
16:31:40 <rwbarton> clintm: if you really intend to "forget" the type of a_thing, then you're talking about an existential type
16:32:28 <dmwit> nyingen: cabal install may choose an older version of mueval, while cabal configure; cabal build must work with the version that's lying there in front of it.
16:32:38 <clintm> rwbarton: I was just about to look up gadts to refresh myself and see if that might not work.  I'll read up on extistentials first though.  Thanks!
16:32:49 <rwbarton> you can also write the existential type nicely using gadt syntax yes
16:32:53 <DijkstraGroupie> Where are cabal packages installed?
16:32:57 <dmwit> There are other differences, I think, but that's the most likely cause of what you're seeing.
16:33:17 <dmwit> DijkstraGroupie: Libraries go in ~/.ghc, executables and other things go in ~/.cabal.
16:33:43 <dmwit> DijkstraGroupie: You may ask for other locations (or a global installation, in which case you need some more privileges) in ~/.cabal/config.
16:34:47 <nyingen> dmwit: I see. I got the source code via 'cabal fetch mueval'. Why wouldn't that be the same version chosen by 'cabal install' ?
16:35:26 <dmwit> nyingen: Because cabal fetch doesn't run the constraint solver, it just fetches the most recent version.
16:36:03 <dmwit> ...I think.
16:36:48 <dmwit> nyingen: Also: you might like the "cabal unpack" command in the future.
16:37:00 <dmwit> This does a fetch followed by a tar xzf.
16:37:50 <gdoteof> http://hpaste.org/66603 <- line 92  what is the right way to use variables bound with `<-` in a where clause
16:38:19 <dmwit> you can't
16:38:25 <dmwit> Pass them as arguments to the things that need them.
16:38:50 <dmwit> e.g. where sessionMinutes end session = ...
16:38:51 <ski> zzo38 : you can also wrap `m' into a `Monad' using `newtype CoDensity m a = JorpDnib { bindProj :: forall b. (a -> m b) -> m b}' -- and `w' into a `CoMonad' by `data Density w b = forall a. InclPreserve (w a -> b) (w a)'
16:39:19 <ski> zzo38 : i'm wondering if something similar to this would be possible to transform things into monad transformers ..
16:39:29 <dmwit> JorpDnib is a hilarious but also horrible name. (And yes, I get the joke.)
16:39:43 <dmwit> For the same reason fi and esac are horrible names...
16:42:07 <nyingen> dmwit: gotcha
16:42:29 <hnsz> dmwit: rotfl
16:42:47 <ski> @tell clintm maybe you're looking for something like `data Foo a where Blah :: Bar a => ..a.. -> Foo a; ...' .. or maybe you're looking for an existential (with context), which could be written as `data Foo = forall a. Bar a => Blah (..a..) | ...', or in GADT syntax as `data Foo where MkFoo :: Bar a => ..a.. -> Foo; ...'
16:42:47 <lambdabot> Consider it noted.
16:43:19 <zzo38> ski: I know about codensity monads
16:43:28 <ski> zzo38 : first i was thinking you wanted your `FreeT' to look more "even" than "odd" .. but i'm not sure about that
16:43:51 <ski> hm, what are the monad transformer laws ?
16:44:05 <ski>   lift . return = return  -- is one
16:44:28 <zzo38> ski: I think it is that the same thing applies to the base monad as the new monad
16:44:34 <ski>   lift . amb =<< lift ma = lift (amb =<< ma)  -- should be another
16:44:38 <zzo38> So that includes   lift . return = return
16:44:53 <zzo38> ski: And yes that too
16:44:57 <ski> any more ?
16:45:09 * ski guesses not
16:45:31 <zzo38> Well,   f <$> lift x = lift (f <$> x)   would have to hold too
16:45:38 <ski> probably you can rephrase the second one as `join . lift . liftM lift = lift . join'
16:45:41 <hpaste> Derp pasted “Herp” at http://hpaste.org/66604
16:46:10 <monochrom> hahaha
16:46:14 <ski> zzo38 : yes, but that's obvious, because `lift' is a natural transformation
16:46:37 <zzo38> ski: Yes
16:46:45 <ski> (it is impossible to define `lift' in such a way in Haskell that that law does not hold)
16:47:14 <dmwit> ?wiki ListT
16:47:15 <lambdabot> http://www.haskell.org/haskellwiki/ListT
16:47:15 <zzo38> Yes, I think you are correct
16:47:33 <dmwit> Is there a canonical reference explaining what's wrong with the naive ListT?
16:47:37 <zzo38> Some laws are implied, and that is one
16:47:46 <ski> hm, probably the laws in terms of `return' and `join' is the interesting formulation here
16:48:10 <ski> (since `Free' as well as your `FreeT', looks "`join'y" :)
16:48:41 <ski> (hm, well, at least `Free' .. your `FreeT' possibly would need an additional distribution law)
16:49:59 <hnsz> say Eratosthenes five times
16:51:03 <ski> @. read run (unwords . replicate 5) "Eratosthenes"
16:51:04 <lambdabot>  Eratosthenes Eratosthenes Eratosthenes Eratosthenes Eratosthenes
16:52:42 <Veinor> am i the only one that reflexively distrusts packages with version numbers in the thousands
16:52:46 <djahandarie> read run riverrun
16:53:26 <Mathnerd314> Veinor: which package might this be?
16:53:28 <Veinor> rss
16:53:43 <Veinor> ew it uses Strings too :(
16:55:44 <Zamarok> How would one evaluate a Rational value into a [] of its decimal digits? Is there a Decimal library or something?
16:56:05 <Mathnerd314> Veinor: you'd prefer Text?
16:56:50 <Veinor> yeah
16:57:08 <Veinor> really i wish there was like
16:57:10 <Veinor> a StringLike interface
16:57:39 <dmwit> Zamarok: There's the "digits" library, but I don't think it's general enough to work on Rationals, so you may have to write it yourself. The usual div/mod approach ought to work.
16:57:52 <dmwit> > mod' (1%2) (1%10)
16:57:52 <lambdabot>   0 % 1
16:57:56 <fryguybob> > show . fromRational $ (4 :: Rational)
16:57:56 <dmwit> > mod' (1%20) (1%10)
16:57:56 <Mathnerd314> @hoogle toDigits
16:57:57 <lambdabot>   1 % 20
16:57:57 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
16:57:57 <lambdabot>   can't find file: L.hs
16:58:04 <dmwit> > mod' (1%7) (1%10)
16:58:05 <lambdabot>   3 % 70
16:58:15 <ski> > mod' 5 0 :: Rational
16:58:16 <lambdabot>   *Exception: Ratio.%: zero denominator
16:58:19 <ski> :(
16:58:37 <dmwit> > mod' 5 2 :: Rational
16:58:38 <lambdabot>   1 % 1
16:58:40 <Mathnerd314> :t mod'
16:58:41 <lambdabot> forall a. (Real a) => a -> a -> a
16:59:18 <Mathnerd314> @instances RealFloat
16:59:18 <lambdabot> Double, Float
16:59:35 <dmwit> ?instances-importing Data.Ratio RealFloat
16:59:35 <lambdabot> Double, Float
16:59:40 <dmwit> uh
16:59:45 <dmwit> Oh.
16:59:49 <dmwit> ?instances-importing Data.Ratio Real
16:59:49 <lambdabot> Double, Float, Int, Integer, Ratio a
16:59:54 <dmwit> phew, I'm sane again
17:00:21 <zhulikas> @hoogle Integer -> Double
17:00:22 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
17:00:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:00:22 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
17:00:28 <Zamarok> dmwit: Oh, I didn't know about Data.Digits. In fact, I did write the functions that are in there already and have been using them for a while lol
17:00:58 <dmwit> I only found out about it a few days ago. =)
17:01:26 <Zamarok> But the ones in Data.Digits only work on Integral values :( just like my functions
17:05:23 <honza> My first program in Haskell (that I came up with on my own, not from a book) --- cipher.hs --- https://gist.github.com/2333021
17:06:12 <dmwit> honza: Not bad!
17:06:20 <dmwit> honza: You might like to use pattern matching a bit more at the end.
17:06:52 <honza> dmwit: thanks --- yeah, i feel like the indentation is all wrong
17:06:54 <dmwit> case args of ["--encode"] -> putStr $ encode file; ["--decode"] -> putStr $ encode file; _ -> putStrLn "error"
17:06:57 <dmwit> for example
17:07:16 <honza> dmwit: ah! cool
17:07:30 <rwbarton> as for indentation, I would remove all the line breaks after "then" and "else", then it will look ok
17:09:01 <shachaf> Also, there's much less of a reason for the "0 == x" idiom in Haskell, since there's no assignment expression. :-)
17:09:49 <shachaf> Also, your program crashes on certain inputs. :-)
17:11:18 <dmwit> No harm in 0 == x.
17:11:37 <dmwit> I believe in a world where someday, we might have (==) implementations that can specialize on their first argument.
17:12:03 * hackagebot cereal-conduit 0.0.5 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.0.5 (MylesMaxfield)
17:12:05 * hackagebot hscd 0.0.2 - Command line client and library for SoundCloud.com  http://hackage.haskell.org/package/hscd-0.0.2 (SebastianMagri)
17:12:27 <honza> dmwit rwbarton updated with pattern matching
17:13:03 <dmwit> Very pretty!
17:13:19 <dmwit> I look forward to your second Haskell program. =)
17:13:54 <shachaf> case args of ["--encode"] -> interact encode
17:14:09 <rwbarton> interact $ case args of ...
17:15:06 <dmwit> Oh, cool idea.
17:15:49 <rwbarton> I don't think it ever occurred to me that you could use interact other than in the form "main = interact ..."
17:19:15 <honza> shachaf rwbarton I like those!
17:19:24 <honza> Thanks for the encouragement everyone
17:19:39 <shachaf> honza: Really, though, that program is too small for people to be able to give you much advice as far as idioms and such.
17:20:05 <honza> shachaf: yeah --- I gotta start somewhere though
17:20:51 <honza> shachaf: I've been going through Learn you a haskell. Good reading but a bit lengthy at times.
17:20:54 <shachaf> Sure.
17:21:05 <shachaf> honza: In a real program I would certainly say to write out type signatures.
17:21:44 <honza> shachaf: Like String -> String for the [en|de]code stuff?
17:22:08 <shachaf> Yes.
17:23:00 <honza> cool
17:28:43 <t7> roconnor_: how do i design a block cipher for your scheme :)
17:29:10 <shachaf> I think the usual answer to "how do i design a block cipher" is "you don't".
17:29:57 <t7> can i just plug another block into a function that works on integers
17:32:46 <t7> this stuff is hard
17:34:14 <nart> ciao :)
17:34:47 <hnsz> ciao bello
17:38:02 <navaati> bye
17:49:53 <t7> i need a padding scheme
17:53:39 <thinker341> > 1--3
17:53:40 <lambdabot>   1
17:54:01 <thinker341> why we get 1 here?
17:54:18 <geekosaur> -- is a comment
17:54:43 <thinker341> Ah, thx :). Just starting with Haskell
17:54:52 <geekosaur> (unary (-) is a massive pain; you must parenthesize)
17:54:52 <pcavs> Does anyone use the Alex lexer? I was wondering if there was an easy way of dynamically changing the lexer token dispatch without creating my own monolthic function dispatch?
17:55:12 <pcavs> Oh wait, is that what start codes are for?
17:55:59 <thinker341> <geekosaur> i will keep it in mind,thx
17:59:17 <knapper_tech> where are macro docs?
18:04:27 <parcs`> i would like to know too
18:06:40 <t7> anyone know a nice way to serialize data from a network without having to keep track of much other than a socket/handle
18:07:40 <t7> something like a channel
18:07:46 <t7> so i can just pull a value
18:07:58 <t7> not have to keep track of any extra data read
18:08:17 <t7> how are others doing this
18:08:27 <BrianHV> sounds sort of like what conduits were designed for
18:08:31 <t7> this is a real pain compared to librarys in other languages
18:08:52 <t7> BrianHV: i tried this but i have to make the whole program in a conduit else it closes my handles
18:09:18 <t7> and i need bi directional communication so its not really an option
18:09:32 <BrianHV> I haven't worked with conduits myself, but from reading the docs I wouldn't expect it to close anything unless you ask it to
18:09:48 <t7> me neither :( but it does
18:10:25 <BrianHV> are you passing a function that closes the handle into your ResourceT?
18:10:48 <t7> http://stackoverflow.com/questions/10045262/using-cereal-to-send-data-through-a-handle
18:10:59 <t7> this code is wrong but i tried using $$+ too
18:11:26 <byorgey> knapper_tech: macro docs? what do you mean?
18:11:29 <knapper_tech> is there code templating or somthing like that?
18:12:05 <knapper_tech> i was told haskell has the ability to build up the functionality of a function at compile time --- pray at runtime as well
18:12:06 <byorgey> http://www.haskell.org/haskellwiki/Template_Haskell ?
18:12:39 <byorgey> well, since functions are first-class objects, building a function at runtime is easy
18:12:54 <BrianHV> t7: your findings puzzle me, especially if you're using $$+. the functions you're using are specifically documented as not closing the handle.
18:13:00 <byorgey> but if you really need the ability to generate *source code* at compile time, Template Haskell is what you want.
18:13:26 <byorgey> knapper_tech: if you need to evaluate/interpret source code at runtime there are tools for that too.
18:13:29 <t7> BrianHV: it only says it doesnt close the source
18:13:32 <knapper_tech> byorgey, not that inerested in source.  i'm relatively green in functional programming.
18:13:33 <t7> not the sink
18:13:43 <byorgey> knapper_tech: what is it you're trying to do?
18:13:55 <BrianHV> t7: the 0.4.0.1 docs say the same for sinkHandle
18:13:57 <knapper_tech> byorgey, what i need is something like overriding the body of a method from OOP
18:14:18 <byorgey> knapper_tech: ah, ok, you don't want template haskell for that.
18:14:31 <byorgey> knapper_tech: perhaps you want a type class.
18:14:36 <BrianHV> t7: however... it also says it'll stream all of the data
18:15:48 <byorgey> knapper_tech: you may be interested in http://www.haskell.org/haskellwiki/OOP_vs_type_classes
18:15:53 <knapper_tech> byorgey, what idioms do i use to replace ducktyping and other dynamic features in functional programming?
18:16:18 <t7> ah this is such a fucking pain :(
18:16:27 <t7> maybe i will write this little thing in cpp or something
18:16:33 <thinker341> >(1,2,3,4,5,6)
18:16:33 <byorgey> knapper_tech: higher order functions and type classes.
18:16:51 <byorgey> knapper_tech: but sometimes you also just organize things differently so you don't need those features.
18:17:06 <thinker341> > (1,2,3,4,5,6)
18:17:07 <lambdabot>   (1,2,3,4,5,6)
18:17:32 <byorgey> knapper_tech: I don't recommend trying to port particular features to Haskell.  Just start learning Haskell from the ground up and figure out how to express things idiomatically.
18:17:49 <byorgey> idiomatic Haskell is very different in style from idiomatic code in an OOP or dynamically typed language.
18:38:39 <t7> oh got binary-communicator package to the rescue :D
18:48:02 <wo0kie> I must be retarded when it comes to haskell
18:48:27 <Cale> wo0kie: what's wrong?
18:48:30 <Slashsfan> Hello how are you doing?
18:48:40 <wo0kie> well I'm trying to understand IO in Haskell
18:48:45 <wo0kie> (this is hw)
18:48:45 <Cale> wo0kie: okay
18:48:59 <wo0kie> I can read in inputs just fine
18:49:20 <wo0kie> but when it comes to printing out a list of all words entered, I can't figure out how to store the running list of words entered
18:49:36 <wo0kie> so I can print it out after an empty line is given as input
18:49:56 <Cale> wo0kie: Try making a function with a parameter for the list of words
18:50:20 <wo0kie> a helper function could prove useful haha
18:50:27 <Cale> (You could also use an IORef)
18:50:33 <wo0kie> ? :o
18:50:48 <Cale> r <- newIORef []
18:50:54 <Cale> x <- getLine
18:51:11 <wo0kie> oh
18:51:16 <Cale> xs <- readIORef r
18:51:22 <Cale> writeIORef r (x:xs)
18:51:35 <Cale> etc
18:51:44 <wo0kie> :o
18:51:47 <wo0kie> interesting
18:52:04 <Cale> But you don't actually need that, you can just use a function parameter here :)
18:52:35 <wo0kie> the parameters of the helper function would be the running list and the new word to add, no?
18:53:44 <lispy> hello
18:55:29 <Cale> wo0kie: Just the running list, I think
18:55:50 <wo0kie> hmm
18:56:14 <Cale> wo0kie: It'll get a word and then apply itself to a new list.
18:57:21 <hpaste> “Rowan Katekar” pasted “FFT” at http://hpaste.org/66606
18:57:28 <pcavs> Does anyone know if haskell regex negated character classes match newlines (\n) ?
19:00:21 <wo0kie> *sigh*
19:00:45 <wo0kie> I'm too used to imperative programming lol
19:02:23 <Zamarok> Does anyone know if there is a function that works like Foreign.C.Math.Double(modf), but for Rational or Fractional values?
19:04:46 <byorgey> Zamarok: yes, properFraction
19:05:52 <Zamarok> byorgey: yep that's it, thanks
19:06:33 <wo0kie> hey Cale, how would I convert an IO String to a String?
19:06:40 <wo0kie> using the <- symbol?
19:06:41 <Cale> wo0kie: by running it
19:06:43 <Cale> yes
19:06:48 <wo0kie> http://pastebin.com/tpYb3SM7
19:06:51 <mauke> The paste tpYb3SM7 has been copied to http://hpaste.org/66607
19:06:57 <Cale> an IO String is like a program which if you run it, will produce a String result
19:07:06 <wo0kie> hmm
19:07:23 <Cale> wo0kie: Don't use where
19:07:40 <Cale> you need to run getLines, because getLines isn't a list
19:07:53 <wo0kie> but the last expression in a do can't be a bind no?
19:08:22 <Cale> so in what you wrote,  line : newLines and newLines = getLines, so you have  line : getLines  there, which is a type error, yeah?
19:08:40 <Cale> So instead, you need to run getLines
19:08:55 <Cale> else do xs <- getLines; return (line : xs)
19:09:16 <wo0kie> I can use a semicolon :OO
19:09:38 <wo0kie> or is that just your way of saying new line? lol
19:09:44 <Cale> Both
19:09:51 <wo0kie> intereeeestttting
19:09:56 <Cale> You can write semicolons and braces, or you can use layour
19:09:59 <Cale> layout*
19:10:07 <wo0kie> :D
19:10:12 <wo0kie> forgot you could nest dos
19:10:20 <wo0kie> <-- pro
19:10:45 <wo0kie> makes so much more sense
19:10:54 <wo0kie> getLines returns an IO
19:10:59 <wo0kie> so I couldn't just use = in a where
19:11:05 <wo0kie> since it wouldn't execute it
19:11:27 <wo0kie> so by doing a nested do, I can bind a name inside the else to getLines
19:11:37 <wo0kie> and then return the current line ++ newLines
19:11:42 <wo0kie> thank you Cale :D
19:12:07 <Cale> to the result of getLines, yeah
19:12:19 <Cale> actions are not the same things as their results
19:12:42 <wo0kie> result of getLines
19:12:44 <wo0kie> correct :)
19:13:02 <wo0kie> by doing newLines = getLines I was binding a name to the action
19:13:04 <wo0kie> not the result
19:13:08 <wo0kie> which gave me an error
19:13:32 <Cale> right
19:13:35 <wo0kie> :D
19:13:47 <wo0kie> think I understand this a bit better now
19:13:56 <wo0kie> Learn You Haskell for Great Good is also helping hehe
19:14:52 <wo0kie> thank you again sir
19:16:17 <BrianHV> is it normal for one to code up some functions in haskell, then to spend an hour going back over them and finding ways to reduce the line of code count?
19:17:09 <brisbin> golfing is fun times
19:17:25 <brisbin> BrianHV: http://pbrisbin.com:3000/
19:18:23 <BrianHV> nice. :)
19:18:56 <brisbin> someone posted thesmallestrailsapp.com in a work chat, and i'm like, yesod can do that smaller...
19:21:15 <BrianHV> the rails app looks smaller, but in fairness, the yesod code actually runs an http server.
19:22:25 <BrianHV> I wonder if you could make it smaller (if slightly absurd) by using a built-in type like Int instead of defining Small yourself.
19:22:36 <Zamarok> byorgey: that function, Numeric.floatToDigits, would be perfect if it used infinite lists for the fractional part. Is there a function like that?
19:22:59 <Zamarok> I guess it would have to use the Rational type, or similar.. which is fine
19:23:50 <Zamarok> > floatToDigits 10 (1 / 3)
19:23:51 <lambdabot>   ([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],0)
19:24:27 <Zamarok> A function where therer would be infinite threes
19:24:34 <Zamarok> there*
19:24:46 <brisbin> BrianHV: fork the gist, do it to it :)
19:25:36 <brisbin> BrianHV: whoa, the rails app got a lot smaller since i last looked :(
19:25:46 <brisbin> we need to up our game
19:27:58 <iihavetoes26> i just started learning haskell, but am wondering what its best uses are. anyone care to explain?
19:28:01 <BrianHV> brisbin: maybe tomorrow. after solving a type puzzle in my code I'm pretty done for the day.
19:28:44 <zomg> iihavetoes26: programming
19:28:59 <brisbin> nice
19:29:49 <brisbin> iihavetoes26: use xmonad as your WM, customize it to hell
19:30:05 <brisbin> that's the best introduction to haskell i can recommend
19:30:19 <iihavetoes26> ok
19:30:33 <iihavetoes26> i was planning on switching to a tiling wm when i get a new computer
19:30:37 <iihavetoes26> in like a month
19:31:06 <brisbin> read about haskell and try to apply what you learn in your xmonad.hs
19:31:10 <brisbin> worked for me, anyway
19:31:28 <iihavetoes26> so that's a great start. but are there any other uses? haskell is a compiled language...so what can it do that C/C++ cant
19:32:03 <brisbin> iihavetoes26: it compiles to C. the benefit is you can program at a higher level of abstraction to capture the problem domain
19:32:18 <brisbin> but still get near-C performance due to purity and ghc optimizations
19:34:18 <iihavetoes26> ok cool. thanks!
19:34:26 <BrianHV> what I love is that a large class of errors is impossible to create in haskell.
19:34:31 <BrianHV> also, quickcheck is pretty cool.
19:34:32 <Cale> Um, compiling via C is no longer the default
19:34:41 <Cale> GHC normally compiles to native code directly
19:35:04 <brisbin> my bad
19:35:36 <Sgeo> Is Haskell more TC than C is?
19:35:47 <Sgeo> (Given the limitation of pointer size.... or something)
19:36:04 * Sgeo pokes the not here right now elliott
19:36:23 <parcs`> BrianHV: s/impossible/harder/ :P
19:37:55 <BrianHV> parcs`: fair enough. ;)
19:38:05 * BrianHV steps afk to turn his brain off.
19:40:22 <nyingen> hm, there used to be a script packaged with lambdabot to run it under ghci
19:40:36 <wo0kie> is there a relatively easy way to sort a list of strings lexicographically?
19:40:38 <nyingen> but that, and some other stuff like the README, seem to have disappeared from the distribution on hackage
19:40:45 <wo0kie> tried using sort
19:40:52 <wo0kie> but it keeps telling me not in scope :o
19:41:04 <kallisti> @hoogle sort
19:41:04 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
19:41:04 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
19:41:04 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
19:41:21 <wo0kie> wait
19:41:23 <wo0kie> I might be an idiot
19:41:24 <wo0kie> lol
19:41:46 <wo0kie> hmm
19:41:50 <wo0kie> nope, still not in scope
19:41:54 <wo0kie> sec, I'll show a pastebin
19:42:00 <kallisti> you imported Data.List and it's not in scope?
19:42:12 <wo0kie> omg
19:42:17 <wo0kie> I didn't even import it
19:42:18 <kallisti> ;)
19:42:19 <wo0kie> you're right
19:42:20 <wo0kie> LOL
19:42:49 <BMeph> wo0kie: If you're in ghci, you can also do "let sort = Data.List.sort"
19:43:03 <wo0kie> oh cool!
19:43:05 <wo0kie> didn't know that :D
19:43:12 <wo0kie> thanks kallisti and BMeph :)
19:43:17 <smithw> what are the best practices to sysadmin haskell installations? I have a very simple install here I've been using to learn, but I want to try yesod, and I've heard of the dependency hell. should I try virthualenv/cabal-dev/capri/something else?
19:43:20 <kallisti> you should try using sortBy
19:43:31 <BMeph> wo0kie: In case you have some reason not to want to import the whole List module in.
19:43:51 <wo0kie> ooo
19:44:30 <wo0kie> I still have to import Data.List?
19:44:33 <Cale> smithw: I can't say anything about yesod specifically, but I recommend keeping your GHC installation (and the packages which come with GHC) separate from the stuff you install using cabal
19:44:44 <wo0kie> because when I remove that from the top of my file it tells me not in scope :(
19:45:44 <smithw> Cale, well... that ship has already sailed :( do I have to reinstall everything, or can I save my installation?
19:45:54 <Cale> (i.e. don't install things globally, because this makes it easy to blow away your local packages in case they get messed up by deleting ~/.ghc without having to reinstall ghc)
19:46:30 <abizern> Does't cabal install locally by default?
19:46:35 <kallisti> wo0kie: yes in a Haskell program you have to import modules
19:46:41 <kallisti> what BMeph was describing is a ghci feature.
19:46:50 <Cale> abizern: yes
19:47:16 <wo0kie> oooooh ok
19:47:21 <wo0kie> thanks for clearing that up haha
19:47:33 <BMeph> Cabal: Install locally. Program globally. ;)
19:47:36 <kallisti> wo0kie: you should take a look at sortBy. :>
19:47:47 <wo0kie> yup, just did (sortBy compare list)
19:47:48 <wo0kie> :)
19:47:54 <abizern> Ah, okay. Looking at my (Mac) system it stores them under ~/Library/Haskell/ghc-xx/lib/
19:48:07 <kallisti> :t comparing
19:48:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:48:18 <kallisti> > comparing abs 2 (-2)
19:48:19 <lambdabot>   EQ
19:48:36 <kallisti> > sortBy abs [1,4,-3,-1,4,5-2]
19:48:37 <lambdabot>   Occurs check: cannot construct the infinite type:
19:48:37 <lambdabot>    a = a -> GHC.Ordering....
19:48:44 <kallisti> > sortBy (comparing abs) [1,4,-3,-1,4,5-2]
19:48:46 <lambdabot>   [1,-1,-3,3,4,4]
19:49:05 <smithw> abizern, I'm on a mac too, and that's where I what have installed on cabal ended up (currently it's just the hashable package)
19:49:15 <wo0kie> hmmm
19:49:40 <wo0kie> how would I use comparing for sorting a list of strings alphabetically?
19:49:56 <wo0kie> is there something like abs? or can I just use < ?
19:50:02 <kallisti> > sort ["hello", "goodbye"]
19:50:04 <lambdabot>   ["goodbye","hello"]
19:50:13 <kallisti> > sortBy (flip compare) ["hello", "goodbye"]
19:50:15 <lambdabot>   ["hello","goodbye"]
19:50:23 <wo0kie> ooooooo
19:50:24 <BMeph> wo0kie: 1) Use 'mappend' from Monoid; 2) Ask Cale. ;)
19:50:27 <kallisti> wo0kie: you just flip the comparison function
19:50:32 <wo0kie> so using compare was correct
19:50:35 <wo0kie> ah ok :D
19:50:41 <kallisti> wo0kie: sort = sortBy compare
19:50:49 <wo0kie> OH
19:50:59 <wo0kie> that would explain it :D
19:51:23 <kallisti> but if you want "alphabetical order" then you want flip compare
19:51:27 <Cale> > sortBy (comparing length `mappend` compare) (words "here are some words to sort by length and then alphabetically")
19:51:28 <kallisti> so that it starts with a
19:51:28 <lambdabot>   ["by","to","and","are","here","some","sort","then","words","length","alphab...
19:52:05 <wo0kie> sortBy compare ["for","score","and","seven","years","ago"]
19:52:05 <kallisti> Cale: is that Monoid instance in base?
19:52:13 <Cale> yes
19:52:28 <nyingen> Cale: is it still possible to run lambdabot under ghci?
19:52:30 <wo0kie> gives me back ["ago","and","for","score","seven","years"]
19:52:35 <wo0kie> which is what I wanted :)
19:52:37 <BMeph> Unfortunately, Cale sn't, not even in the Platform...yet. ;)
19:52:53 <BMeph> *isn't
19:53:11 <Cale> wo0kie: for that, you can just use sort
19:53:19 <wo0kie> ok :)
19:53:27 <Cale> nyingen: I have no idea
19:53:38 <kallisti> > sort ['a'..'z']
19:53:39 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
19:53:47 <kallisti> oh. right.
19:54:11 <nyingen> Cale: ok, I'll see if I can figure it out. There once was a script called 'ghci' packaged with the distro, but no more it seems
19:56:11 <kallisti> > sortBy (comparing reverse) . words $ "four score and seven years ago"
19:56:13 <lambdabot>   ["and","score","seven","ago","four","years"]
20:28:40 <diracdelta> Suppose I have a Color data structure, data = Color Int Int Int
20:28:41 <diracdelta> http://pastebin.com/PddBm373
20:28:44 <mauke> The paste PddBm373 has been copied to http://hpaste.org/66610
20:30:30 <diracdelta> is there a way to alter changeRed so that by default, the new Color is the same as the old color without explicitly saying so?
20:34:33 <brisbin> diracdelta: you mean you want newred to be an optional argument?
20:35:01 <lispy> diracdelta: with records yes
20:35:05 <diracdelta> ah, no, I mean that new red is the only argument
20:35:23 <diracdelta> cool, I'll google that, thanks :)
20:36:01 <lispy> data Color = Color { redColor :: Int, blueColor :: Int, greenColor :: Int }, changeColor c r = c { redColor = r}
20:36:06 <lispy> diracdelta: ^^
20:39:33 <diracdelta> thanks lispy, my googling didn't reveal that variation on the use case. That's exactly what I needed.
20:39:42 <diracdelta> er, variation of syntax
20:43:12 <diracdelta> Correct me if I'm wrong, but if I wanted to do something like changeRGB oldColor which new = oldColor{which=new}, I'd need to use template haskell?
20:44:13 <dmwit> Yes, we don't have first-class record labels.
20:44:18 <dmwit> You can do this with lenses, though.
20:44:50 <dmwit> My favorite explanation: http://twanvl.nl/blog/haskell/overloading-functional-references
20:44:59 <xxx-man> f(t1,...,tk)\=f(s1,...,sn)  iff k\=n or k=n and there is a i such that ti\=si. instead of this if I say f(t1,...,tn)\=f(s1,...,sn)  iff  there is a i=< max(m,n) such that ti\=si. are they same things?
20:45:00 <diracdelta> awesome! thank you
20:46:48 <dmwit> xxx-man: No.
20:46:57 <xxx-man> why?
20:47:06 <dmwit> xxx-man: Because you're being sloppy about which variables are defined.
20:47:25 <dmwit> If there are i between min(m,n) and max(m,n), those i have either ti or si undefined.
20:48:10 <xxx-man> dmwit, i was thinking same
20:48:23 <xxx-man> but in this case
20:48:40 <xxx-man> we have ti \= undifiened
20:48:52 <xxx-man> and everything is ok
20:48:56 <dmwit> No, we have that "ti \= si" is not a well-formed term.
20:49:11 <dmwit> Because it references a variable that doesn't exist.
20:49:18 <xxx-man> formaly yes, right
20:49:26 <dmwit> s/variable/metavariable/ possibly, I've never been able to keep track of how many meta's to use.
20:49:32 <xxx-man> but in meta level we can write like this
20:49:47 <xxx-man> i am speaking about meta level
20:49:51 <xxx-man> not in object level
20:50:14 <dmwit> You can be sloppy if you want. Reading sloppy math is frustrating. Do you want your reader to be frustrated?
20:50:43 <xxx-man> dmwit: I want to have somehow in coherant form
20:51:22 <xxx-man> dmwit: thanks
20:54:55 <Treyvon> wth is wrong with this code?
20:54:59 <Treyvon> here is a screenshot of the error!
20:55:00 <Treyvon> http://i.imgur.com/AJWVC.jpg
20:55:06 <Treyvon> no matter what I do, I get this
20:55:13 <dmwit> ?where ops
20:55:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:55:30 --- mode: ChanServ set +o copumpkin
20:55:39 --- mode: copumpkin set +b *!~PenisSujo@201.170.67.45.dsl.dyn.telnor.net
20:55:39 --- kick: Treyvon was kicked by copumpkin (no thanks)
20:55:43 <shachaf> dmwit: Is that a link better left unclicked?
20:55:43 --- mode: copumpkin set -o copumpkin
20:55:47 <dmwit> It is.
20:58:13 <xxx-man> dmwit: have you ever refer scientific paper?
20:58:22 <thoughtp0lice> copumpkin comes out of nowhere, attacks with grace, and leaves
20:59:21 <copumpkin> :)
20:59:41 <dmwit> xxx-man: I have. I probably wouldn't complain about either definition of inequality. But I'd be thinking the complaint. =)
21:01:28 <xxx-man> hehe :)
21:01:48 <xxx-man> you are to strict :)
21:02:18 <thoughtp0lice> i like how edwardk describes the new reflection as "50 times faster than 0.9 and which runs on purely black magic." implementation is neat
21:02:19 <rwbarton> if I saw your second definition in a serious math paper I'd be really confused
21:03:13 <xxx-man> dmwit: if it is not to private, how many papers you rrefer each year?
21:03:45 <dmwit> I've refereed three papers total and have been a student four years.
21:04:06 <xxx-man> rejected all of them :)?
21:04:15 <dmwit> Now that is a bit private.
21:04:22 <xxx-man> ok
21:04:46 <xxx-man> do you have a template how to refer?
21:06:01 <xxx-man> dmwit: do you make attention about english, latex and with such minors ?
21:07:25 <dmwit> Hm. I usually give roughly three sections: a quick summary of what I understood the paper to be about; a section intended for the committee with a clear recommendation about acceptance, together with the criteria I used to arrive at the decision; and a section intended for the authors collecting comments on improving the paper (including English and typesetting, but clearly marking which comments are minor and which I think are ov
21:08:51 <shachaf> "which I think are ov"
21:09:01 <dmwit> ...overarching and important).
21:09:04 <dmwit> irssi--
21:09:38 <xxx-man> clear
21:13:33 <dmwit> The top answer here looks to be high quality:
21:13:35 <dmwit> http://cstheory.stackexchange.com/questions/1893/how-do-i-referee-a-paper
21:15:39 <xxx-man> interesting
21:16:15 <xxx-man> popl is a top conference is not?
21:17:00 <xxx-man> or ETAPS is top?
21:17:24 <xxx-man> err
21:17:26 <xxx-man> esop
21:18:54 <mnsh> hiii freinds
21:18:57 <dmwit> Well, I think POPL has excellent taste. I am probably quite biased. ;-)
21:19:07 * dmwit shamelessly advertises dmwit.com
21:19:13 <ikeg> FLOPS is not popular, but you may have interesting in. (and, please visit Japan) ;-)
21:20:09 <ikeg> uh. /is not/maybe not/
21:20:47 <mnsh> is there any good IDE for haskell
21:21:08 <dmwit> vim =)
21:21:20 <byorgey> mnsh: If you are comfortable with Eclipse, EclipseFP is nice.  There is also Leksah.  But many people just use vim or emacs.
21:21:27 <dmwit> Seriously, though, vim and emacs are both quite popular, and leksah and yi are less popular but have spawned good reports.
21:22:00 <mnsh> I am new to vim and emacs so the other options will be better
21:23:02 <xxx-man> ikeg: deadline passed already
21:23:53 <ikeg> xxx-man: sorry. could you keep your attention until the next year?
21:24:14 <xxx-man> ok
21:28:06 <ikeg> mnsh: off topic. you know, it is always nice to write your idea, datatype which is needed, etc on a paper (not use computer/IDE). Then write a code with your favorite editer
21:28:44 <ikeg> miss there seems no great IDE for Haskell
21:31:30 <tkahn6> is there a 'plain' quasiquoter? like i just a multiline string. i don't care about parsing and stuff
21:32:16 <tkahn6> i would think that would be in a standard library somewhere
21:33:45 <dmwit> http://www.haskell.org/haskellwiki/Poor_man's_here_document
21:33:58 <dmwit> See solution three.
21:34:03 <dmwit> There's probably a library with that in it somewhere.
21:34:46 <dmwit> http://hackage.haskell.org/packages/archive/Interpolation/0.2.6.0/doc/html/Data-String-Interpolation.html
21:35:02 <tkahn6> dmwit: thanks i'll look
21:35:14 <irene-knapp> the problem with that solution is that it happens at runtime
21:35:21 <irene-knapp> typically, you can't find your owns source files at runtime
21:35:26 <irene-knapp> it needs to use TH :)
21:35:31 <dmwit> irene-knapp: keep reading
21:35:33 <irene-knapp> then it will be sufficiently evil to work properly!
21:35:34 <irene-knapp> oh!
21:35:38 * irene-knapp scrolls down
21:36:08 <irene-knapp> yes, a quasiquoter, cute.  not bad.
21:40:32 <zzo38> LogicT is like a list, isn't it?
21:40:53 <zzo38> It says it is for backtracking but it seem like a list to me
21:40:53 <dmwit> Something like it, yes.
21:42:08 <dmwit> It's better than a list in many ways. The paper discusses why.
21:42:35 <tkahn6> the cool thing about haskell is that the papers are usually really readable
21:42:37 <zzo38> Well, one thing, it can make a transformer, and with the transformer you can put stuff in between, too.
21:52:13 <zzo38> The papers can be readable; and the program I make in Haskell are also printout! (I have made up new commands in the .cabal file for this purpose) One such program is "dvi-processing" so possibly it can make itself printout too
21:53:02 <zzo38> (There are currently no programs that understand the new commands in .cabal file for printouts; but I have written a specification document for it, so it could be done.)
21:54:13 <zzo38> The parts of the specification relating to "LaTeX", "ConTeXt", "XeTeX", "XeLaTeX", and "RFC", are not yet written, so if you know about these things then please help to write these parts of the specification
21:58:50 <zzo38> (The corresponding operations of observe,observeMany,observeAll for lists is head,take,id I think so)
22:00:42 <zzo38> Here is current specification of the new commands I have added to appear in .cabal file for printout:   http://sprunge.us/efTG
22:07:11 * hackagebot hscd 0.0.2.2 - Command line client and library for SoundCloud.com  http://hackage.haskell.org/package/hscd-0.0.2.2 (SebastianMagri)
22:14:12 <zzo38> What is the algorithm to split a polygon into triangles?
22:15:30 <Rotaerk_> tessallation?
22:15:42 <pcavs> what's the Haskelly way to do simple String replacement?
22:16:55 <Veinor> what kind?
22:18:31 <pcavs> capital S String from the Prelude
22:18:40 <Veinor> no i mean
22:18:43 <Veinor> what kind of replacement
22:20:07 <zzo38> One way would be like this:   f ('x' : 'y' : 'z' : 'z' : 'y' : t) = "plugh" ++ f t; f (h : t) = h : f t; f [] = [];   If that is what you want. But if you just want to replace all '*' with "Hello" then like this:   (>>= \x -> case x of { '*' -> "Hello"; _ -> [x]; })   And if you only want to replace a first one then you can change the "++ f t" in first example to just "++ t" and so on
22:20:18 <dmwit> ugh
22:20:27 <zzo38> But maybe none of these are what you want
22:20:37 <dmwit> pcavs: Some input/output pairs would help us nail down what you want to do.
22:20:56 <zzo38> I agree
22:21:54 <pcavs> like so
22:22:06 <pcavs> \" -> "
22:22:08 <pcavs> \' -> '
22:23:06 <Veinor> @type splitOn
22:23:07 <lambdabot> Not in scope: `splitOn'
22:23:17 <pcavs> Is there seriously not a agreed upon regexp replace library?
22:23:31 <Veinor> you could use something like intercalate '"' . splitOn "\\\""
22:23:46 <Veinor> where splitOn is in Data.List.Split and intercalate is in Data.List
22:25:09 <zzo38> read . ('"' :) . (++ "\"")    if the string contains no " by itself and also \\ to \ and nothing else with \ at first
22:25:29 <dmwit> There is an agreed-upon regex-replacement library.
22:25:44 <pcavs> dmwit: which is?
22:25:55 <dmwit> However, the use of regex-replacement is usually a sign that you're using String as a datatype.
22:25:56 <pcavs> Veinor: thanks that would work, but seems like unnecessary second passes
22:26:04 <dmwit> String is a lousy datatype, and Haskell is so good at making good ones.
22:26:17 <zzo38> Parsec
22:26:24 <pcavs> dmwit: When I'm trying to lex, yes, it may be so.
22:26:44 <dmwit> If you want to lex, you should say so. We have excellent lexers that are not regex-based.
22:26:54 <Veinor> i recommend using Data.Text in non-toy programs
22:26:58 <dmwit> e.g. alex, parsec, etc.
22:27:02 <pcavs> Using alex
22:27:09 <pcavs> still uses regexes though.
22:27:15 <Veinor> (or ByteString if you're dealing with a string of bytes, not necesarily a list of characters)
22:27:48 <zzo38> I happen to like Parsec (which can actually work with any list and not only a string)
22:27:53 <pcavs> dmwit: Any reason you can't just tell me what the regexp library is?
22:27:59 <dmwit> Anyway, for the immediate question, see the collection of packages prefixed regex- here: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:text
22:28:22 <dmwit> pcavs: Forgive me for typing slowly.
22:28:36 <pcavs> thanks dmwit
22:29:16 <Veinor> regex-compat does what you want
22:29:18 <Veinor> using subRegex
22:29:41 <Veinor> the order of arguments to subRegex is weird :/
22:31:06 <pcavs> Veinor: thank you kindly
22:32:03 <Veinor> i wonder if there are any regex-helper quasiquoters
22:42:12 * hackagebot text 0.11.2.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.2.0 (BryanOSullivan)
22:43:07 <Veinor> anybody have any experience with rss vs feed for rss generation?
22:48:52 <tkahn6> pcavs: there be dragons in the regex library
22:49:41 <tkahn6> dmwit: thanks for pointing me to Data.String.Interpolation, exactly what i was looking for
22:50:24 <diracdelta> Is there anyway to evaluate the result of template haskell expressions like [|1+2|]?
22:51:33 <tkahn6> diracdelta: have you looked at this yet? http://www.haskell.org/haskellwiki/Quasiquotation
22:52:27 <diracdelta> Sorry, I meant just simply display the AST that is the result.
22:54:14 <tkahn6> diracdelta: apparently [expr|1+3|] yields the AST
22:54:23 <Veinor> i wonder what the analogy for the conduits vs iteratees vs whatever in, say, python would be
22:54:36 <diracdelta> is that showable?
22:54:50 <tkahn6> u have to specify your data type to derive Show
22:55:18 <Veinor> tkahn6: no, that only works if you define expr
22:56:16 <Veinor> i think haskell-src-exts-qq might have what you want
22:56:24 <tkahn6> Veinor: i see
22:56:38 <Veinor> (be warned: building haskell-src-exts is memory-intensive)
22:57:23 <diracdelta> Veinor thanks
22:57:30 <diracdelta> i'll check that out
23:18:52 <nyingen> @uote
23:18:52 <lambdabot> Maybe you meant: quote vote
23:18:54 <nyingen> @quote
23:18:55 <lambdabot> MissPiggy says: iPad...? apples gone into santiary products
23:19:00 <nyingen> @quote
23:19:00 <lambdabot> arcatan says: ManagerManager works in FactoryFactory
23:19:23 <Veinor> @quote Veinor
23:19:23 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
23:19:35 <Veinor> @quote Veinor
23:19:35 <lambdabot> Veinor says: I write austere haskell. all of my variables are named a, a', a'', a''', etc.
23:19:39 <nyingen> AbstractGenericManager works in AbstractGenericWorkableFactory
23:20:29 <nyingen> unfortunately Erlang doesn't allow ' as part of a variable name
23:21:26 <nyingen> so you get various conventions for bindings. X1, X2, ... or sometimes X, NewX
23:22:00 <nyingen> @quote
23:22:00 <lambdabot> [31d1] says: Linux Is Nice Under Xmonad
23:22:05 <bd_> > let t' = 42 in t'
23:22:06 <lambdabot>   42
23:22:10 <bd_> nyingen: yes it does :)
23:22:18 <Veinor> i just realized i have yet to see an identifier with ' in the middle (that doesn't precede other 's)
23:22:23 <Veinor> bd_: erlang is not haskell
23:22:24 <nyingen> I said Erlang, not Haskell
23:22:28 <bd_> oh
23:22:29 <bd_> right
23:22:33 <bd_> nevermind then!
23:22:36 <nyingen> :)
23:22:39 <nyingen> @quote
23:22:39 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
23:22:52 <nyingen> @quote lambdabot
23:22:52 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
23:23:11 <Veinor> @quote lambdabot
23:23:11 <lambdabot> lambdabot says: @quote lambdabot
23:23:15 <Veinor> >:|
23:23:22 <Veinor> @quote lambdabot
23:23:22 <lambdabot> lambdabot says: No Result Found.
23:23:25 <Veinor> @quote lambdabot
23:23:26 <lambdabot> lambdabot says: lambdabot says:  lambdabot hasn't said anything memorable
23:23:38 <Veinor> @quote lambdabot
23:23:38 <lambdabot> lambdabot says: mUEv4L-CORE: Tim3 li/\/\IT 3xcE3dEd
23:23:46 <Veinor> @quote lambdabot
23:23:47 <lambdabot> lambdabot says: I know nothing about wadler.
23:23:58 <NihilistDandy> No knowledge for free!
23:25:43 <nyingen> that l33tspeak quote is hilarious
23:26:57 <nyingen> @quote
23:26:57 <lambdabot> AlanPerlis says: It is easier to write an incorrect program than understand a correct one.
23:27:02 <nyingen> @quote
23:27:02 <lambdabot> Phyx- says: is @where ops the equivalent of displaying a bat signal in the sky?
23:27:43 <Veinor> @quote php
23:27:44 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
23:27:46 <Veinor> @quote php
23:27:47 <lambdabot> sieni says: python, like php, is just training wheels without the bike
23:27:49 <Veinor> @quote php
23:27:50 <lambdabot> _Ray_ says: the difference in mathematical/CS knowledge of the average haskeller, and the average PHPer, is likely similar to that of the average PHPer and a banana
23:28:18 <nyingen> that's actually pretty funny
23:35:32 <hpaste> qnikst pasted “io chan vs stm chan, on producer-consumer only” at http://hpaste.org/66616
