00:07:05 <tkahn6> is there a way to get hlint to just output code with all its corrections?
00:11:01 <ChristianS> tkahn6: i don't think so
00:11:18 <kaitocracy> can someone tell me why this doesn't work? do { name <- newName "Something"; [d| data $name = $name }
00:12:05 <ChristianS> kaitocracy: is that haskell or perl?
00:13:01 <kaitocracy> that's haskell
00:13:06 <kaitocracy> template haskell
00:13:12 <edwardk> can some folks try pulling and installing https://github.com/ekmett/mtl to make sure i didn't make any obvious errors in it?
00:13:38 <ChristianS> kaitocracy: oh. can't help there...
00:13:49 <edwardk> i've updated it to use the new transformers and to include the generalized state, reader, and writer definitions from transformers 0.3
00:16:10 <reppr2> I have a function compile :: String -> [[Token] -> [[Token]]]  (as in https://gist.github.com/1062472).  Is there any sensible way to pretty print the resulting function so that I could start to understand how it works? Tried my luck with Data.PPrint.pprint $ compile "^a*.b" but no
00:18:46 <Veinor> ... i think i just accidentally reinvented typeclasses
00:20:32 <reppr2> modifying the 'compile' function to use Writer monad or something to trace the output is not something I can easily do.  (and then I'd have to modify the match function as well, and the solution would not scale to other situations like this anyway)
00:21:08 <Veinor> reppr2: in situations like this you can use Debug.Trace.trace
00:21:35 <reppr2> Veinor: cool, will take a look at that right now
00:23:56 <kaitocracy> anyone know any template haskell?
00:24:52 <kaitocracy> examples in the API documentation don't work
00:26:24 <edwardk> kaitocracy: what do you need?
00:27:20 * hackagebot mtl 2.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.1 (EdwardKmett)
00:28:41 <kaitocracy> edwardk: let v = mkName "T" in [d| data $v = $v |]
00:28:46 <kaitocracy> edwardk: that straight up doesn't work
00:30:01 <edwardk> then don't quasiquote it ;)
00:30:18 <kaitocracy> edwardk: but it should work
00:30:44 <kaitocracy> edwardk: and I can't not quasiquote it because I need to throw that into a situation where I don't know what $v will actually be
00:31:03 <edwardk> what i mean is you can make the DataD the hard way
00:31:27 <B_> ?
00:31:42 <kaitocracy> edwardk: oh yeah I can, but why isn't it working? what am I doing wrong?
00:32:01 <edwardk> dunno. i don't quote names much or really at all that way
00:33:06 <edwardk> let v = mkName "T" in DataD [] v [] [NormalC v []] []
00:33:45 <edwardk> its probably that its a name and not a Con or something in the second case
00:34:05 <kaitocracy> oh
00:34:25 <edwardk> hrmm, nope thats not it
00:37:16 <kaitocracy> oh hey
00:37:16 <kaitocracy> http://stackoverflow.com/questions/5722523/local-variables-in-template-haskell-declarations
00:39:14 <kaitocracy> well apparently you can't do that, someone should update the docs
00:56:20 <kaitocracy> what is the function that puts something in a list?
00:56:30 <kaitocracy> as in func 1 should equal [1]
00:56:45 <shachaf> (:[])
00:56:46 <shachaf> pure
00:57:03 <kaitocracy> ahh got ig
00:57:06 <kaitocracy> makes sense
00:57:57 <xterm5443> Hello.
00:58:03 <shachaf> G'day.
00:58:09 <Taneb> Hello!
01:00:01 <xterm5443> I have question. How I can read Char from IO String?
01:00:14 <shachaf> xterm5443: You can't.
01:00:16 <shachaf> See the FAQ.
01:00:18 <shachaf> @where faq
01:00:18 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:01:03 <Taneb> You can read an IO Char
01:01:07 <Taneb> Ish
01:01:51 <shachaf> Taneb: You can turn an IO String into an IO Char. I wouldn't call that "reading".
01:02:08 <Orclev_> depends on what you mean by read a char... first thing to understand is that String is just a type alias for [Char]
01:02:08 <shachaf> Taneb: And at any rate xterm5443 is best off understanding how IO works in Haskell before doing this sort of thing.
01:02:31 <Orclev_> also, as shachaf said, best to understand IO as well
01:02:31 <Taneb> shachaf, true, but I think that's whats closest to what he meant
01:02:41 <Taneb> but yeah
01:02:44 <Taneb> xterm5443, learn IO
01:03:08 <Orclev_> read the learn you a haskell tutorial, will probably answer most of your questions
01:03:24 <shachaf> Taneb: I think it's pretty far from what xterm5443 meant. :-)
01:03:27 <shachaf> But anyway, what I said.
01:03:34 <shachaf> Orclev_: I think the FAQ is better for this.
01:04:14 <Orclev_> shachaf: I wouldn't know, I haven't read the faq, but when I first started learn you a haskell helped me understand IO better than just about anything
01:04:49 <Taneb> Hmm...
01:04:59 <shachaf> Orclev_: Was it after you had already tried a bunch of other things?
01:05:00 <shachaf> @where burrito
01:05:00 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
01:05:01 <Taneb> Oh yeah
01:05:07 <Taneb> I just remembered why I'm here
01:05:43 <Taneb> Data.Text is GHC only, and I'm trying to make this as portable as possible.
01:05:54 <Taneb> What are the differences between ByteString and Text?
01:07:41 <Orclev_> shachaf: not really, I tried to read a bunch of different tutorials but most of them jumped into the deep end of category theory first thing, learn you a haskell was one of about 3 that I could actually understand and the one that helped the most
01:08:25 <xterm5443> I would like filter hidden files on UNIX OS. I have IO [FilePath] ... and I would like filter this list - only files without '.' first char. I will read IO in Haskell :).
01:12:40 <wo0kie> hey everyone
01:12:43 <wo0kie> quick question
01:12:48 <wo0kie> if I'm doing list comprehension
01:13:03 <wo0kie> is there a way to completely change the value being produced based on a conditional?
01:13:06 <ChristianS> Taneb: bytestring is for bytes (binary data), Text is for textual data (strings, character sequences).
01:13:18 <tkahn6> wo0kie: can u give an example of what you mean?
01:13:28 <wo0kie> for example [x | x <- [0..10], x mod 2 then x = "|"]
01:13:32 <wo0kie> not sure if that's possible
01:13:55 <tkahn6> the types don't match up
01:14:06 <tkahn6> so you'd have to do something ugly to get that
01:14:10 <wo0kie> hmm
01:14:18 <wo0kie> (this is hw btw)
01:14:21 <tkahn6> what is your overall goal?
01:14:26 <wo0kie> but I'm trying to build a simple tic-tac-toe board
01:14:30 <shachaf> wo0kie: The answer is pretty much "no".
01:14:42 <shachaf> The type of all the elements of the list has to be the same.
01:14:46 <wo0kie> hmm
01:14:57 <wo0kie> well I want all elements to be a string
01:15:05 <wo0kie> so there should be no numbers
01:15:15 <wo0kie> but I need the numbers to calculate where to put the strings I need
01:15:17 <shachaf> If you're representing strings and numbers in the same list, maybe what you're after is neither strings nor numbers.
01:15:22 <shachaf> You sound confused.
01:15:23 <tkahn6> you should probably define a record
01:15:38 <tkahn6> and make it an instance of Show
01:15:51 <tkahn6> and then define how it's displayed
01:15:54 <shachaf> Your list comprehension is also completely invalid syntax as well as semantics.
01:16:00 <tkahn6> shachaf: dude chill
01:16:00 <wo0kie> hmm
01:16:07 <wo0kie> guess there's no easy way to do it then with lc
01:16:08 <wo0kie> :\
01:16:10 <Taneb> ChristianS, I think Text is definitely better for what I want, just it says it's GHC only. All the other modules I'm using are portable, and I don't want one thing to make the entire library non-portable
01:16:16 <wo0kie> I'm new to haskell too
01:16:20 <shachaf> wo0kie: I recommend thinking about what you want to do and then asking questions about that. :-)
01:16:20 <wo0kie> if that makes any difference
01:16:25 <shachaf> tkahn6: Huh?
01:16:36 <tkahn6> shachaf: you're being kind of abrasive
01:16:36 <wo0kie> can I show you the question?
01:16:44 <shachaf> tkahn6: ?
01:16:44 <tkahn6> wo0kie: sure
01:16:47 <wo0kie> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework04/homework04.pdf
01:16:49 <wo0kie> #5
01:17:02 <wo0kie> got everything up until that point
01:17:09 <shachaf> tkahn6: The "invalid syntax" part?
01:17:23 <wo0kie> tkahn6, no worries, he didn't offend me lol
01:17:23 <tkahn6> shachaf: nah like "You sound confused"
01:17:34 <wo0kie> I'll be honest
01:17:37 <wo0kie> maybe I am lol :D
01:17:39 <shachaf> tkahn6: Oh. wo0kie does sound confused.
01:17:58 <wo0kie> I'm trying to think of an easy way to do this, that's all :\
01:18:14 <wo0kie> but I don't think list comprehension will do it for me
01:18:19 <shachaf> I tell that to a lot of people who sound confused -- I don't think of it as abrasive, just as a "you should take a step back and think about what you're actually trying to do" sort of thing.
01:18:23 <shachaf> wo0kie: List comprehensions are overrated.
01:18:38 <shachaf> First figure out what you're trying to do. It's always possible without a list comprehension.
01:18:38 <tkahn6> shachaf: i misunderstood your tone, my bad
01:18:50 <ChristianS> Taneb: well, you could try bytestring together with the utf8-string package, but the api of the latter is extremely limited compared to Text.
01:19:46 <Taneb> I'll give it a look, ChristianS
01:23:58 <Taneb> ChristianS, is a Data.ByteString.UTF8.Bytestring able to be used as a Data.ByteString.ByteString
01:23:59 <Taneb> ?
01:24:41 <ChristianS> Taneb: yes, it's actually the same type.
01:24:53 <Taneb> Oh, cool
01:25:00 <Taneb> That's pretty much perfect
01:25:04 <Taneb> Thanks!
01:27:34 <ChristianS> Taneb: ByteString.UTF8 lacks basic functions like map, but if you can live with that limitation you should be fine...
01:33:30 <Taneb> Crap, I need Data.Text for more things than I thought...
01:34:37 <Taneb> Looks like I'm gonna have to stick to Text or switch from Aeson
01:37:07 <Taneb> So first I need to switch from Aeson.
01:37:29 <Taneb> Seeing as I'm just using Aeson for converting to and from a text format, this should be doable
01:40:51 <wo0kie> is there an easy way to determine if the index in a given list is odd or even?
01:40:55 <wo0kie> perhaps using a filter?
01:40:58 <wo0kie> or map?
01:41:11 <shachaf> wo0kie: A common idiom is to zip the list with [0..]
01:41:16 <shachaf> Or, in your case, with cycle [False,True]
01:41:24 <wo0kie> hmmm
01:41:30 <shachaf> > zip "hello" (cycle [False,True])
01:41:30 <lambdabot>   [('h',False),('e',True),('l',False),('l',True),('o',False)]
01:43:56 <wo0kie> oooo
01:44:05 <wo0kie> not sure we're allowed to use cycle though :X
01:45:06 <wo0kie> I'll ask another question
01:45:30 <wo0kie> if I have a list of 3 elements (for example [1,3,5])
01:45:36 <shachaf> wo0kie: You're best off figuring out how cycle works.
01:46:05 <wo0kie> is there a way to add an element between [1,3] and [3,5] ultimately creating [1,_,3,_,5]?
01:46:06 <wo0kie> ok
01:46:26 <shachaf> wo0kie: Also, instead of looking at what functions happen to exist in the standard library, you should just think about what you're trying to do in more detail. :-)
01:46:45 <wo0kie> in java this would be simple lol :P
01:46:50 <wo0kie> trololol
01:47:14 <shachaf> Man, you sure showed us!
01:47:19 <wo0kie> <-- noob
01:47:30 <wo0kie> I have an idea of how to do it
01:47:46 <wo0kie> any position mod 2 == 0 should have a space in it
01:48:03 <wo0kie> anything else (effectively an odd index) should have a pipe ("|")
01:48:25 <wo0kie> but the list I have has only 3 elements
01:48:42 <wo0kie> when I need to add (length list - 1) elements
01:49:05 <shachaf> wo0kie: You should try to figure out a way of doing with without using length. :-)
01:49:15 <wo0kie> hmm, good point
01:49:18 <shachaf> (I have no idea what you're doing, but length usually indicates that it's the wrong thing.)
01:49:25 <wo0kie> haha ok :)
01:50:23 <wo0kie> I could use a merge ;D
01:52:23 * hackagebot reflection 1.1.3 - Reifies arbitrary terms into types that can be reflected back  into terms  http://hackage.haskell.org/package/reflection-1.1.3 (EdwardKmett)
02:16:02 * ksf thinks exceptions should be barfed to stderr with greater prejudice.
02:16:23 <ksf> forkIO, for example, only has reason to hide KillThread, but nothing else.
02:21:08 <Rmx_> hey, is there any performance cost to use identity monad everytime we're not in any other monad?
02:21:30 <ksf> nope.
02:21:45 <Rmx_> does it leads to something good ?
02:22:01 <ksf> nope.
02:22:07 <ksf> newtype Identity a = Identity { runIdentity :: a }
02:22:12 <PehnisSujo> why do I keep getting this strage error message?
02:22:14 <PehnisSujo> http://i.imgur.com/TtGok.jpg
02:22:20 <PehnisSujo> I checked my code
02:22:25 <PehnisSujo> and I still keep getting this
02:22:26 <ksf> @ops
02:22:26 <wo0kie> can someone tell me why this is throwing an error of "Couldn't match expected type 'Char' with actual type '[Char]'"?
02:22:26 <lambdabot> Maybe you meant: docs oeis pl
02:22:27 <wo0kie> http://pastebin.com/nPTTuwpB
02:22:29 <mauke> The paste nPTTuwpB has been copied to http://hpaste.org/66625
02:22:40 <ksf> @where ops
02:22:40 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:22:54 <Rmx_> ksf, ok, thanks, my question was to know if code looks more coherent, and patterns more easilly identifiable,
02:23:00 <wo0kie> I was under the impression that strings were repesented as [Char]
02:23:03 <wo0kie> or perhaps I'm wrong
02:23:04 <Rmx_> because if I suddenly want to add new functionalities
02:23:12 <Rmx_> to have a base monad to do it is quicker
02:23:50 <Rmx_> to allow debug, is just one or 2 lignes more
02:23:52 <ksf> If you do that a lot, I think you're not avoiding monads hard enough.
02:24:09 <Rmx_> should I avoid monads?
02:24:10 <ksf> Rmx_, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
02:24:17 <PehnisSujo> http://i.imgur.com/TtGok.jpg
02:24:18 <Rmx_> yeah, sure)
02:24:19 <PehnisSujo> so?
02:24:26 <PehnisSujo> nobody have a reason why I get this error?
02:24:41 <Rmx_> well, ok-ok
02:26:55 <ivanm> I'm looking at adding svg color support to graphviz; can anyone suggest a way I can have x11 and svg color names interoperate nicely?
02:27:21 <Rmx_> ivanm, are svg font fast enough for real time use?
02:28:04 <Rmx_> and sorry, no idea about your question
02:28:33 <theorbtwo> ivanm: Easy: x11 and svg color names are defined the same way for the same name -- svg colors are based on x11 colors -- so it doesn't matter whithem.
02:28:41 <Ragnaroek> why doesn't popen work in ghci?
02:29:43 <geekosaur> ?
02:30:26 <ivanm> Rmx_: ... this has nothing to do with fonts
02:30:39 <Rmx_> yes yes, I know ^^
02:30:43 <ivanm> http://graphviz.org/content/color-names
02:30:45 <Rmx_> it was totally unrelated
02:30:49 <ivanm> theorbtwo: they clash actually
02:30:51 <Rmx_> but I assumed you could have any clues
02:30:57 <ivanm> especially since graphviz uses non-standard x11 colors
02:31:06 <theorbtwo> ivanm: Hm.  Could have ... yeah, well, that would do it.
02:31:11 <Ragnaroek> ghci just crashes without an error
02:32:24 <roconnor_> preflex: seen t7
02:32:25 <preflex>  t7 was last seen on #haskell 7 hours, 53 minutes and 44 seconds ago, saying: oh got binary-communicator package to the rescue :D
02:37:14 <Jules> is a univesal quantifier like lambda abstraction but at the type level?
02:37:22 <pharaun> is it possible to override a function in a library that i don't want to run at all in haskell?
02:38:15 <tkahn6> pharaun: yes, you would do: import Prelude hiding (map)
02:38:20 <Jules> in other words: is forall T. [...] a type, or is it a function of type -> type?
02:38:36 <tkahn6> import <Package.Name> hiding (function)
02:39:18 <pharaun> tkahn6: yeah i've done that before, however its not exported :\ i don't want to have to make a copy of that package and edit it cos then i would need to edit several other package to point to my edited version
02:39:51 <tkahn6> pharaun: can you do an hpaste of what you're talking about?
02:39:59 <pharaun> sure a sec
02:40:20 <pharaun> tkahn6: basically - http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Hooks-EwmhDesktops.html - setActiveWindow, i want this to die
02:40:43 <pharaun> i was hoping to replace it with an empty function forcefully so that when its being called in the package it will do nothing
02:43:06 <navaati> hi
02:44:29 <tkahn6> pharaun: i'm pretty sure you can't do that
02:45:08 <pharaun> tkahn6: bah guess i'll just have to fork or rewrite a large part of the avail lib, that function is braindead
02:45:32 <pharaun> tkahn6: ok alternative, can i just write my own copy of that package and have it override the one available on the system?
02:46:38 <hpaste> “Alexander Yuriev” pasted “Dijkstra for words” at http://hpaste.org/66628
02:46:45 <tkahn6> pharaun: yeah you could probably do that
02:46:54 <pharaun> tkahn6: hm k
02:46:57 <tkahn6> make a copy, update the version in the cabal manifest
02:47:05 <Ragnaroek> popen anyone?
02:47:17 <pharaun> tkahn6: hmm i'll try that
03:04:33 <xmonadnewbie> hi, I have a xmonad question that I'm hoping someone can help with.... is anyone here familiar with xmonad and xmonad.action.tagwindows in particular?
03:05:06 <shachaf> xmonadnewbie: There's a #xmonad channel.
03:05:19 <shachaf> But either here or there, you should ask your question instead of asking if someone is familiar.
03:06:39 <xmonadnewbie> ok, will check that channel also.  My question is, is there anything wrong with the following:  , ((modm .|. controlMask, xK_3     ), tagPrompt defaultXPConfig (\s -> withTaggedP s (W.shiftWin "3:Sierra"))
03:07:48 <xmonadnewbie> I want to move tagged windows into a specific workspace, but get compilation errors with the above line.
03:08:58 <geekosaur> what compilation errors?
03:08:58 <shachaf> In that case, there probably is.
03:09:07 <shachaf> That would be useful information.
03:09:17 <gspr> Is there a way to take a  Ptr a  and say "look, I promise I'm keeping track of stuff, I want to turn this pointer into a ByteString *without* copying"?
03:09:51 <navaati> is there a bugtracker for the language itself ? (extensions, sytax, etc.)
03:10:09 <navaati> gspr: yes
03:10:15 <shachaf> gspr: There's one for ForeignPtrs.
03:10:26 <shachaf> Which is probably what you want anyway.
03:10:58 <gspr> shachaf: I've never used ForeignPtr... but if I understand them correctly, they're like Ptr, only you instruct the runtime that certain functions should be called when it's time to garbage collect the pointer?
03:11:10 <geekosaur> navaati, for the language or for some implementation?  ghc has its own bug tracker; there is also a wiki and a discussion list for the language standard, although I don't recall their being a specific bug tracker for it (but there may be a section in the ghc trac?)
03:12:06 <shachaf> gspr: Right.
03:12:27 <ivanm> if I want to have a bunch of colour names correspond to constructors of two different types, am I correct in assuming that only way to do so is to have a *really* big type class with every single common name being a method?
03:13:21 <pharaun> tkahn6: got it :) with some pointer from #xmonad i was able to make a local copy of those package and hacked them apart, thanks for suggesting that idea
03:13:32 <shachaf> gspr: If you're really completely sure about the Ptr, you can turn a regular Ptr into a ForeignPtr with no finalizer, too.
03:13:38 <tkahn6> pharaun: i'm glad you got it working
03:13:44 <shachaf> gspr: Anyway, the functions of interest will be in Data.ByteString.Interal.
03:13:51 <navaati> geekosaur: for the language (i just want to see if there is a proposition to add λ to the UnicodeSyntax)
03:13:57 <gspr> shachaf: Right.. I just found them :) Thanks
03:14:01 <pharaun> tkahn6: would had preferred not to, because now i'll need to be aware of upgrades but it'll work for the time being :)
03:14:44 <geekosaur> navaati, there is not, because it is a perfectly valid Unicode ;etter
03:14:49 <geekosaur> letter
03:15:16 <navaati> geekosaur: and ? ins't → a valid unicode letter ?
03:15:21 <geekosaur> and the language committee is not at all happy about the idea of deciding that Greek is not a legitimate alphabet such that lambda can be taken as an operator
03:15:42 <navaati> ah
03:15:50 <navaati> yeah, there are greek people…
03:15:51 <shachaf> geekosaur: → also isn't a letter.
03:16:05 <geekosaur> that is an operator character, indeed.
03:16:16 <shachaf> I meant navaati:
03:16:18 <geekosaur> "letter" has a specific meaning in Unicode
03:16:19 <navaati> grumpf… iirc, Agda Does It ®
03:16:36 <navaati> but yeah, i understand
03:16:38 <navaati> sad
03:16:42 <geekosaur> Agda decided not to take the Unicode definitions as a basis
03:16:49 <shachaf> Agda's syntax is quite different.
03:17:17 <pharaun> maybe just me but i would prefer to stick with plain ascii for language feature, i don't want it to turn into APL :)
03:17:52 <navaati> pharaun: it's an extension
03:18:01 <navaati> you'll never be forced to use it
03:18:06 <pharaun> as long as i don't need to use it then fine with me :)
03:18:13 <geekosaur> at some point it would be nice if the Unicode committee accepted a math-lambda operator; it certainly has more of an argument going for it than some of the things in the most recent version of the standard, even if getting support for astral plane characters in real world fonts is a pain
03:18:52 <navaati> fonts usually have a fairly complete support of math operators
03:18:57 <pharaun> not always
03:19:13 <pharaun> i was looking into math fonts a bit ago for web-rendering and it was still a bit sketchy in some area
03:20:05 <navaati> i've already missed oriental characters, but never a math stuff, in DejaVu, but well…
03:20:20 <pharaun> not everyone is going to have it installed :)
03:21:02 <navaati> oO
03:21:29 <navaati> it's the most widely spread font, isn't it ?
03:22:02 <pharaun> for what platform? :)
03:22:20 <pharaun> i may be out dated, but i didn't think windows packed it by default ?
03:22:35 <geekosaur> basic math stuff is there, but not all the upper stuff.  I just checked DejaVu Sans and there are large gaps in the "Mathematical Alphanumeric Symbols" block
03:23:01 <pharaun> i certainly do have DejaVu installed :) but i was just pointing out that it might not always be
03:23:08 <navaati> ah, windows…
03:23:46 <pharaun> i guess its dependent on what/who you are targeting on if that matters or not, but there's still a large amount of folks on windows you know :)
03:23:46 <navaati> hum, i hope that for the price of their OS they have good quality commercial fonts packed in :]
03:23:55 <mekeor> why does haskell not allow to write higher functions, i mean functions that get a *type*, not a *value*? -- that'd be awesome!
03:23:58 <pharaun> arial? :)
03:24:27 <navaati> mekeor: you mean parametric polymorphism ?
03:24:38 <mekeor> navaati: possibly. what's that?
03:24:50 <navaati> id :: a → a takes a type parameter, called 'a'
03:24:51 <sipa> mekeor: Maybe is a function that takes a type, and returns a new type
03:25:01 <mekeor> sipa: yep, i know.
03:25:07 <pharaun> a -> b ?
03:25:08 <navaati> sipa: ah, yeah, there is that, too
03:25:16 <mekeor> sipa: but can i write a function that takes a type and returns a value?
03:25:27 <geekosaur> mekeor, types are not values in haskell
03:25:43 <navaati> mekeor: you want to pattern match on types ? that doesn't exist even in agda
03:26:40 <mekeor> navaati: in Idris, e.g., you can write a function like 'function : Set -> Integer -> Float', idk.
03:26:58 <mekeor> geekosaur: so, what i said is not possible, right?
03:27:04 <geekosaur> not in haskell
03:27:12 <navaati> mekeor: and what can you do with your Set parameter ?
03:27:16 <mekeor> geekosaur: why didn't they implement this in haskell?
03:27:37 <geekosaur> why are you asking me?  I'm not the language committee, nor smart enough to be on it
03:27:39 <mekeor> navaati: "Set" means "Type", so, the function takes a type! that's cool!
03:27:59 <geekosaur> but, well, what would you do with it?
03:28:05 <mekeor> geekosaur: i just mean, is there a reason why that's not possible in haskell... maybe you know why...
03:28:12 <navaati> mekeor: yeah, yeah, but what can you do with this type parameter ?
03:28:37 <MagneticDuck> What's the type of a type?
03:28:41 <mekeor> geekosaur: i could write a function 'readableAs : Set -> String -> Bool'.
03:28:49 <mauke> MagneticDuck: *
03:28:59 <mekeor> :k Integer
03:29:00 <lambdabot> *
03:29:03 <MagneticDuck> mauke: Right. But that's not a concrete type. A kind.
03:29:24 <navaati> A kind is a haskell-specific term that means "the type of a type"
03:29:37 <navaati> (or of a type function)
03:29:50 <MagneticDuck> One could have a function that took any value and returned its type as a string... or return "I don't know that type." If you really wanted to...
03:30:02 <geekosaur> mekeor, to some extent you can do that in haskell, by means of type classes.
03:30:14 <navaati> MagneticDuck: check the class Typeable
03:30:19 <navaati> Data.Typeable
03:30:25 <MagneticDuck> navaati: Huh.
03:30:27 <geekosaur> you'd have to specify your type with (undefined :: Type) though, or use Data.Typeable hacks
03:30:40 <mekeor> ... such that 'readableAs Double "foo"' is 'False' while 'readableAs Double "1.2"' is 'True'!  that's soo cool!!
03:30:56 <geekosaur> on the other hand, it would fit poorly with the rest of the language
03:31:07 <geekosaur> it's more dynamic typing than static typing
03:31:29 <mekeor> geekosaur: so, what i am talking about is not static typing anymore??? really? oO
03:32:16 <navaati> when you go at such a high order, the difference is fuzzy, i think…
03:32:24 <geekosaur> Set is not a specific type, it is what amounts to a type variable.
03:32:33 <MagneticDuck> Having trouble understanding TypeRep... and the source doesn't exactly help. (Looking at documentation for Typeable.)
03:32:36 <geekosaur> variables are not static
03:33:04 <geekosaur> also, the only point of that function example is to *support* dynamic typing
03:33:26 <sipa> static typing and dynamic typing are two independent things
03:33:31 <sipa> they don't contradict
03:33:35 <navaati> :t typeRep
03:33:36 <lambdabot> Not in scope: `typeRep'
03:33:51 <MagneticDuck> :t TypeRep
03:33:52 <lambdabot> Not in scope: data constructor `TypeRep'
03:33:59 <MagneticDuck> How do I import?
03:34:07 <MagneticDuck> In lambdabot of course
03:34:09 <geekosaur> :t Data.Typeable.TypeRep
03:34:10 <lambdabot>     Not in scope: data constructor `Data.Typeable.TypeRep'
03:34:11 <navaati> Real dynamic typing in haskell is possible with Data.Dynamic
03:34:27 <geekosaur> it is.  it also introduces runtime type mismatches
03:34:28 <shachaf> FSVO "Real dynamic typing"
03:34:44 <geekosaur> when the point of static typing is to *not* have such things
03:34:58 <navaati> shachaf: FSVO ?
03:35:11 <shachaf> "For Some Values Of"
03:35:23 <geekosaur> yes, you can force the issue if you want to, but arguably it's not something you should really want to do ecept as a last resort
03:35:48 <navaati> shachaf: haha :D
03:35:56 <geekosaur> :t Data.Typable.TypeRep
03:35:57 <lambdabot> Couldn't find qualified module.
03:36:00 <MagneticDuck> Okay I'm getting confused... what's the type Fingerprint and what does ! do before a type?
03:36:02 <geekosaur> oh well
03:36:09 <geekosaur> ! makes it strict
03:36:14 <MagneticDuck> strict?
03:36:38 <MagneticDuck> :t Fingerprint
03:36:39 <lambdabot> Not in scope: data constructor `Fingerprint'
03:36:42 <MagneticDuck> ah
03:36:48 <geekosaur> a value used there must be fully evaluated, instead of being lazy as usual
03:37:19 <MagneticDuck> Ah hah. So ![a]?...
03:37:25 <MagneticDuck> Would that work...?
03:38:54 <MagneticDuck> :P
03:41:36 <MagneticDuck> I just scared everyone...
03:41:39 <geekosaur> ![a] would work but not do what you probably intended
03:41:56 <MagneticDuck> Ah hah. What would it do?
03:42:31 <navaati> it means "The outermost (:) is not a thunk
03:42:46 <geekosaur> ^^ that
03:42:56 <navaati> the tail of the list can be, and the head, too
03:43:12 <MagneticDuck> Ah I see.'
03:43:38 <shachaf> navaati: The outermost constructor is not a thunk.
03:43:42 <shachaf> It could be []!
03:44:05 <navaati> of course
03:44:14 <wo0kie> is there a way to map over a list of [Nothing, 'X', 'X'] to convert it to something like [' ', 'X', 'X']?
03:44:24 <keep_learning> How to reduce the GC time ?
03:44:53 <MagneticDuck> But one could integrate ! into the declaration itself and make a byte string? Right? That's how bytestrings were made?....
03:44:59 <navaati> your input list doesn not typecheck
03:45:30 <navaati> MagneticDuck: no, bytestring can be lazy
03:45:36 <geekosaur> MagneticDuck, ByteString is a bit more involved than that
03:45:41 <MagneticDuck> Wo0kie: Yes there certainly is. But you can't do it in a lambda.
03:45:50 <wo0kie> :(
03:45:53 <MagneticDuck> geekosaur, navaait: Okay.
03:45:53 <geekosaur> using ! everywhere does not turn a linked list into an array
03:46:02 <navaati> and there internal representation is based of chunks of (usually) 64kB
03:46:18 <navaati> their*
03:46:21 <wo0kie> how would you do it without using a lambda MagneticDuck?
03:46:24 <MagneticDuck> Ah.
03:46:26 <jabirali> wo0kie: Every element in a list has to be the same type, so it would have to be a list of [Nothing, Just 'X', Just 'X'] or a tuple of (Nothing, 'X', 'X').
03:46:35 <MagneticDuck> wo0kid: helper function.
03:46:44 <MagneticDuck> jabirali: Yeah.
03:46:46 <navaati> :t maybe
03:46:46 <wo0kie> should be [Nothing, Just 'X', Just 'X']
03:46:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:46:48 <wo0kie> you're right
03:47:11 <navaati> MagneticDuck: nop, no helper needed :)
03:47:18 <wo0kie> :o
03:47:28 <MagneticDuck> Ah yes a case.
03:47:32 <MagneticDuck> A case statement.
03:47:35 <MagneticDuck> Sometimes I forget.
03:47:36 <navaati> > map (maybe ' ' id) [Nothing, Just 'X', Just 'X']
03:47:37 <lambdabot>   " XX"
03:47:46 <navaati> no case statement
03:47:48 <MagneticDuck> Hm?
03:48:02 <MagneticDuck> :t maybe
03:48:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:48:08 <wo0kie> http://pastebin.com/51UmcFYJ
03:48:09 <mauke> The paste 51UmcFYJ has been copied to http://hpaste.org/66631
03:48:14 <wo0kie> I tried that
03:48:27 <wo0kie> but I get an error with respect to types
03:48:32 <MagneticDuck> Never knew about that function.
03:49:13 <MagneticDuck> bb everyone! Have to go!
03:49:21 <geekosaur> if you have a type error, it;'s not reflected in that snippet
03:49:38 <geekosaur> although the (x:xs) makes me wonder what exactly you were doing there
03:50:22 <wo0kie> (x:xs) is the head of a double list that's passed in
03:50:23 <navaati> "but I get an error with respect to types" real question : are there errors that are NOT with respect to types ?
03:50:35 <wo0kie> of Maybe elements
03:50:46 <navaati> (x:xs) is certainly not a head, it's a list
03:50:52 <wo0kie> [[Nothing, Just 'X', Just 'X'], [Nothing, Nothing, Nothing]]
03:51:00 <navaati> ah, errr, sorry
03:51:04 <wo0kie> I represent this as ((x:xs):ys)
03:51:10 <wo0kie> so yes, it is the head here :P
03:51:10 <dixie> :t Nothing
03:51:11 <lambdabot> forall a. Maybe a
03:51:11 <wo0kie> in a way
03:51:29 <navaati> yeah it is, i was saying garbage
03:51:36 <wo0kie> no worries
03:52:35 <wo0kie> I'll show you the code I'm using
03:52:52 <navaati> wo0kie: again, use the "maybe" function rather that reinventing it
03:53:11 <wo0kie> what do you mean?
03:53:14 <navaati> and you may be interested by named patterns (is this the right name ?)
03:53:16 <navaati> :t maybe
03:53:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:53:20 <navaati> this function
03:53:28 <navaati> does exactly what you want
03:54:23 <wo0kie> not sure we're allowed to use forall
03:54:25 <wo0kie> :O
03:54:31 <navaati> ignore the forall
03:54:42 <navaati> maybe :: b -> (a -> b) -> Maybe a -> b
03:54:49 <navaati> it's defined in Data.Maybe i think
03:55:45 <navaati> this function take an argument to replace the Nothings and an argument which is a funtion to apply to the content of Justs
03:56:08 <navaati> here you want to replace the Nothings by ' ' and to take the content of Justs as they are
03:56:23 <navaati> so your function is "maybe ' ' id"
03:58:03 <navaati> is there a way to automatically import a module in every file of a project the same way you can activate an extension in every file with the cabal directive "Extensions: " ?
03:58:06 <wo0kie> hmm
03:58:11 <wo0kie> still something I'm doing wrong
03:58:28 <wo0kie> it's saying it couldn't match expected type 'Char' with actual type 'Player'
03:58:37 <navaati> the error is somewhere else
03:58:47 <navaati> we need to see the whole code
03:59:02 <wo0kie> http://pastebin.com/kwbnP1ex
03:59:04 <mauke> The paste kwbnP1ex has been copied to http://hpaste.org/66632
03:59:39 <navaati> mauke: are you a bot ?
03:59:41 <mekeor> :k (->)
03:59:42 <lambdabot> ?? -> ? -> *
03:59:52 <mekeor> navaati: no, he isn't.
03:59:59 <mekeor> actually, he's both.
04:00:24 <navaati> he looks very botish, we should submit him to the Turing Police
04:00:43 <mekeor> :k (->) -- can someone explain this?
04:00:44 <lambdabot> ?? -> ? -> *
04:01:11 <navaati> mekeor: i can't but i know your answer is in the GHC user guide
04:01:27 <mekeor> lol
04:01:50 <mekeor> IMO, ':k (->)' should be '* -> * -> *'.
04:01:53 <ChristianS> mauke is half-human, half-bot, and half-operator. or something like that...
04:02:20 <albel727> so, it's 1,5 total?
04:02:27 <navaati> he is legion
04:02:47 <mekeor> he is a legend
04:03:38 <navaati> wo0kie: the 2nd field of your Board type is a list of list of Maybe Player
04:03:46 <wo0kie> yeah
04:03:59 <geekosaur> mekeor, in Haskell per se yes, in GHC no.
04:04:12 <navaati> and in your openRow function you are pattern matching against Char, not Player
04:04:20 <mekeor> geekosaur: ?  so, it's like a GHC-bug or so?
04:04:20 <geekosaur> ? and ?? have to do with unboxed types
04:04:28 <geekosaur> it is not a bug, it is an extension
04:04:32 <mekeor> geekosaur: what are unboxed types?
04:04:47 <wo0kie> would I do a case of Player e then?
04:05:14 <geekosaur> the way laziness is implemented is by boxing a type, which pretty much means that instead of using a value directly you always use a pointer to the value.
04:05:30 <mekeor> ah
04:05:35 <geekosaur> (it's not just haskell, or lazy languages, that have the concept either; compare Int vs. int in Java --- the latter is unboxed)
04:05:51 <mekeor> ah, cool
04:06:39 <navaati> wo0kie: the type of "(map (\e -> case e of                                                                                  Nothing -> ' '
04:06:39 <navaati> Just e -> e)" is [Maybe Char] -> [Char]
04:06:46 <geekosaur> as a general rule, boxed is more flexible, unboxed is faster.  boxed is also necessary (but not sufficient) for laziness.
04:06:59 <wo0kie> hmm
04:07:03 <navaati> and the type of "(x:xs)" is [Maybe Player]
04:07:28 <mekeor> geekosaur: so, anyway. i should just interprete "?" and "??" as "*", right? then everything is fine. good. thanks.
04:07:37 <navaati> so there is a type mismatch : you can't apply a function of type [Maybe Char] -> [Char] to a [Maybe Player] argument
04:08:03 <geekosaur> pretty much, yes.  the distinction matters more when you dive into ghc internals (such as how it implements IO)
04:08:08 <wo0kie> isn't there a way to apply a function of type [Maybe Player] -> [Char]?
04:08:19 <geekosaur> but if you don;t care about internals then ?? and ? are effectively *
04:08:37 <mekeor> perfect
04:08:43 <navaati> wo0kie: oh, there is, but you need a way  to transform a Player into a Char
04:09:10 <wo0kie> hmm
04:09:15 <wo0kie> sounds like a helper function
04:09:16 <wo0kie> :)
04:09:24 <navaati> not especially
04:09:36 <wo0kie> what were you thinking?
04:10:15 <mekeor> geekosaur: are there types of kind '(* -> *) -> *' or so? i mean, like "high-order types"... hehe =)
04:10:27 <hpaste> navaati annotated “pastebin.com/kwbnP1ex” with “pastebin.com/kwbnP1ex (annotation)” at http://hpaste.org/66632#a66633
04:10:39 <navaati> let's take this less bloated version
04:11:11 <wo0kie> (maybe ' ' id)
04:11:12 <wo0kie> :O
04:11:20 <navaati> well you want to replace the "id" which transform a Char into a Char by something which transform a Player into a Char
04:12:12 <wo0kie> hmm
04:12:33 <wo0kie> so that id is where I'd place a call to my helper to convert a maybe player into a char?
04:12:48 * mekeor just discovered -XKindSignatures -- neat.
04:12:52 * hackagebot sodium 0.3.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.3.0.0 (StephenBlackheath)
04:13:21 <navaati> wo0kie: to convert a Player, not a Maybe Player : the maybe function handles the Maybe stuff
04:13:44 <wo0kie> oh, hmm
04:13:49 <geekosaur> mekeor:
04:13:53 <geekosaur> @kind StateT
04:13:54 <lambdabot> * -> (* -> *) -> * -> *
04:14:06 <mekeor> cool
04:14:06 <zenzike> mekeor: Fix : (* -> *) -> *
04:14:24 <hpaste> navaati annotated “pastebin.com/kwbnP1ex” with “pastebin.com/kwbnP1ex (annotation) (annotation)” at http://hpaste.org/66632#a66634
04:14:27 <navaati> like this
04:14:43 <wo0kie> ohhhhhhhh
04:14:56 <wo0kie> that makes a lot of sense actually :)
04:15:01 <mekeor> data HolyShit (a :: * -> *) = HolyShit (a Int) -- works, too
04:15:11 <navaati> haskell makes a lot of sense
04:15:15 <mekeor> can i define new data-types in lambdabot?
04:15:26 <mekeor> @data -- ?
04:15:27 <lambdabot> Unknown command, try @list
04:15:36 <wo0kie> haha navaati
04:15:40 <wo0kie> thanks for your help sir :)
04:16:27 <geekosaur> not in lambdabot, no
04:16:30 <wo0kie> I've been up all night, however, and must now get some sleep
04:16:43 <wo0kie> but thanks again navaati  and thanks for bearing with a noob hehe
04:16:57 <navaati> NP
04:17:47 <zenzike> mekeor: you might be interested to know that the datatype Fix, where 'data Fix f = f (Fix f)' can be used with base functors to define types that are equivalent to recursive types, like List
04:18:08 <navaati> btw, you maye want to use "replicate (n - 1) '|'" instead of "['|' | i <- [0..(n-2)]]"
04:18:40 <mekeor> zenzike: wow. awesome. cooool greatta O_O
04:18:43 <navaati> zenzike: interesting, what would be the definition of List ?
04:19:00 <zenzike> mekeor: eg. if we have data ListIntF x = EmptyF | ConsF Int x
04:19:10 <zenzike> and give that an instance of Functor
04:19:26 <zenzike> then a list of Ints is just Fix ListIntF
04:19:29 <mekeor> @hoogle Fix
04:19:30 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
04:19:30 <lambdabot> Data.Fixed module Data.Fixed
04:19:30 <lambdabot> Data.Function fix :: (a -> a) -> a
04:19:34 <navaati> ah, yeah
04:23:24 <danilo_b> hi. is there some construct like the python generators in haskell? i want it to return the next character of a sequence each time i call it.
04:23:57 <gspr> I'll bet the answer to this is "hehe, no", but I'll try: Is there a function (in IO, of course) that, given an MVar and a Unix file descriptor, executes an action whenever *either* the MVar is available or a select() system call on the fd returns? :)
04:24:03 <navaati> danilo_b: in haskell, a function *always* produces the same result for the same input
04:24:26 <danilo_b> navaati: ok, makes sense... i'll have to solve my problem in another way :)
04:24:59 <gspr> Followup question: Is there a nice Haskell interface to select()?
04:26:01 <byorgey> danilo_b: note that Haskell's laziness usually makes that kind of thinking unnecessary.
04:26:04 <byorgey> danilo_b: just use a list.
04:29:20 <geekosaur> gspr, select() is not exposed in general, you're expected to use threads
04:31:18 <gspr> geekosaur: Yeah I know, but I'm ioctl'ing a FD, and as far as I know I have to use select() to know when it's time for me to do that
04:33:36 <navaati> gspr: does the ioctl package work well for you ?
04:34:13 <gspr> navaati: Not using it... it looked sort of unmaintained. Since I'm only making a few calls, I just made a C function that does what I need, and I call that from Haskell.
04:36:01 <navaati> gspr: hum, yeah, sounds reasonable
04:37:05 <danilo_b> byorgey: my goal wasn't the laziness, but instead the fact that generators remember their position in a string :) i need something like "itertools.cycle('MyString')" in python.
04:38:15 <byorgey> danilo_b: just use the 'cycle' function and 'map'.
04:38:23 <byorgey> > map succ (cycle "ABC")
04:38:24 <lambdabot>   "BCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBCDBC...
04:38:50 <dixie> :t succ
04:38:50 <lambdabot> forall a. (Enum a) => a -> a
04:39:14 <navaati> > succ 'Z'
04:39:15 <lambdabot>   '['
04:39:26 <byorgey> danilo_b: if you describe in a bit more detail what you are trying to accomplish we can probably help suggest a more Haskell-y way to do it.
04:39:26 <dixie> succ -1
04:39:31 <dixie> > succ -1
04:39:32 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:39:32 <lambdabot>    arising from a use of `...
04:39:35 <navaati> > ['Z'..]
04:39:36 <lambdabot>   "Z[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135...
04:39:46 <navaati> > ['z'..]
04:39:47 <lambdabot>   "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\...
04:39:50 <byorgey> dixie: -1 needs parentheses, since otherwise it parses as succ - 1
04:39:56 <dixie> > succ (-1)
04:39:57 <lambdabot>   0
04:40:02 <dixie> byorgey: thanks
04:40:26 <danilo_b> byorgey: it's a code golf problem (http://golf.shinh.org/p.rb?Switzerhegg+2012). i'm using the "assignment" to learn haskell :)
04:40:59 <danilo_b> byorgey: in python i created a cycle generator and looped over a bit matrix. but that's not possible with pure functional programming, so i'll have to find another way of solving it.
04:42:10 <navaati> ooh, i see. well if really you want to use the same way as in python, you could use the ST monad, but there must be a more idiomatic way to do it
04:42:47 <byorgey> nono, don't use the ST monad!
04:43:17 <navaati> :D
04:43:21 <danilo_b> navaati: that's what i thought too :)
04:43:57 <danilo_b> i'll probably try to find a way of getting the character for a specific x/y coordinate.
04:44:01 <navaati> ah, maybe you could thread a fonction trough your loop
04:44:11 <byorgey> danilo_b: note you can still create 'generator-like' things in Haskell; instead of calling a function that mutates it, you have a function that gives you the next value along with a *new* generator
04:44:38 <danilo_b> byorgey: oh, that sounds nice :)
04:45:05 <byorgey> so it might still be possible to solve it in a similar way.
04:45:14 <byorgey> though I suspect there are even nicer ways to do it.
04:45:24 <byorgey> I'm trying to think how I might solve it.
04:46:56 <danilo_b> can i return several values from a haskell function, or do i explicitly have to create a tuple from the values?
04:47:12 <byorgey> you have to create a tuple
04:47:37 <byorgey> but note you can bind a tuple to the result of a function, like so:
04:47:55 <gspr> danilo_b: If you think about it, you actually don't even pass "several values" *to* functions either :)
04:48:07 <byorgey> > let f x = (x+1,x+2) in  (  let (a,b) = f 3  in  show a ++ " " ++ show b )
04:48:09 <lambdabot>   "4 5"
04:48:19 <danilo_b> gspr: yeah
04:48:21 <byorgey> so it's really not that different tan returning multiple values
04:48:52 <byorgey> functions in Haskell all take only one argument and return only one argument =)
04:49:10 <byorgey> it's just that sometimes the one result is a function or a tuple =)
04:49:15 <shachaf> > let f x r = r (x+1) (x+2) in f 3 (\a b -> show a ++ " " ++ show b)
04:49:17 <lambdabot>   "4 5"
04:49:17 <danilo_b> byorgey: i understood that so far :) thanks
04:49:24 <shachaf> Look, ma, no tuples!
04:49:35 <danilo_b> shachaf: :)
04:49:44 <Skola> can this be written more succinctly? (it's a code from a Parsec parser): abbr = do a <- many1 letter; b <- string "."; return (a ++ b)
04:49:51 <Skola> -a
04:50:02 <shachaf> Skola: liftMa (++) (many1 letter) (string ".")
04:50:12 <shachaf> s/Ma/M2/
04:50:20 <byorgey> or    (++) <$> many1 letter <*> string "."
04:50:29 <shachaf> Or that.
04:50:33 <Skola> thanks!
04:50:47 <shachaf> Skola: Not so fast!
04:50:49 <shachaf> You have entered The Land of a Thousand Synonyms.
04:51:06 <byorgey> let's not forget liftA2
04:51:10 <shachaf> You may not make it out of here alive. Here, take this Typeclassopedia. It's the only thing that can save you.
04:51:43 <mekeor> :D
04:51:47 <Skola> while we're on the subject, what are the pro's and cons of both styles?
04:52:19 <navaati> cons of applicative style is that you must import Control.Applicative, whereas Control.Monad is often already imported
04:52:23 <mekeor> i guess:  see the typeclassopedia. (written by byorgey, afaik.)
04:52:50 <byorgey> afaik too
04:52:55 <mekeor> :)
04:52:56 <shachaf> Skola: It's pretty much everything you can infer from those samples.
04:53:02 <shachaf> byorgey: But what do *you* know?
04:53:15 <byorgey> not much, in the grand scheme of things
04:53:27 <mekeor> that's wise.
04:53:42 <Skola> and deep
04:54:13 <danilo_b> shachaf: how does the "in" in your example work? (sorry, i'm haskell beginner :))
04:54:42 <shachaf> danilo_b: It's just regular let ... in ...
04:55:14 <shachaf> danilo_b: f takes a function that takes two arguments. It computes (x+1) and (x+2) and calls that function with the two arguments.
04:55:50 <byorgey> danilo_b: let x = y in blah  means that the definition x = y is available to be used locally in the expression 'blah'
04:55:51 <danilo_b> shachaf: ah ok :) thanks!
04:58:34 <Phlogistique> :t (***)
04:58:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:59:11 <navaati> waw, lambdabot gives the kinds oO
04:59:17 <danilo_b> shachaf: byorgey: so "let x=y in blah" would be "with x=y: blah" in python.
04:59:34 <shachaf> danilo_b: Not really.
04:59:44 <shachaf> "with" in Python is completely different.
04:59:51 <Skola> 1 more; how could I write tok = do try abbr <|> do try $ many1 letter <|> do try $ many1 space
05:00:06 <shachaf> Unless Python 3 lets you do variable scope with "with"?
05:00:31 <danilo_b> variable scope?
05:00:37 <fuzzy_id> it doesn't
05:00:43 <navaati> Skola: hairy… try the magical point-free command of lambdabot (i can't remerber the syntax, though)
05:00:59 <fuzzy_id> variables defined inside 'with' are also available outside of it
05:01:05 <Phlogistique> @pl tok = do try abbr <|> do try $ many1 letter <|> do try $ many1 space
05:01:06 <lambdabot> tok = do try abbr <|> do try $ many1 letter <|> do try $ many1 space
05:01:15 <navaati> fail
05:01:33 <shachaf> danilo_b: "with" is for something like "with open(path) as f:" and so on.
05:01:38 <shachaf> danilo_b: "let" just gives a name to a value.
05:01:46 <Phlogistique> @pl \a b c -> do try a <|> do try b <|> do try c
05:01:47 <lambdabot> flip flip (do try) . (((.) . (<|>)) .) . (. do try) . (<|>) . do try
05:01:59 <Phlogistique> Skola: here you go.
05:02:07 <Skola> hahaha yes thanks a bunch ;p
05:03:16 <byorgey> Skola: note that you don't need those 'do's
05:03:38 <byorgey> Skola: so you can just write  try abbr <|> try (many1 letter) <|> ...
05:03:43 <shachaf> Also, they're not doing what you think they are. :-)
05:03:59 <shachaf> do (trye a <|> do (try b <|> do (try c)))
05:04:05 <shachaf> s/e//
05:04:08 <byorgey> Skola: note also that $ has lower precedence than <|>, so do try abbr <|> do try $ many1 letter <|> do try $ many1 space  parses as  try abbr <|> do try (many1 letter <|> ... )
05:04:15 <Phlogistique> Skola: choice $ map try [abbr, many1 letter, many1 space]
05:04:15 <byorgey> which might not be what you intended.
05:04:27 <byorgey> Phlogistique: oh, very nice =)
05:05:08 <Skola> yes that's much better :}}
05:05:20 <Phlogistique> Skola: you might want to define choicetry = choice . map try
05:05:21 <stepcut> anyone here developed Haskell + Cocoa apps? I'm trying to figure out the best way to do that these days..
05:05:36 <Phlogistique> if you have this more than once in your parser
05:05:58 <Skola> very likely yeah, thanks
05:07:16 <Skola> this channel is a goldmine :}}
05:12:07 <timing> Hi all, I'm trying to to ':1 baby' from this book: http://learnyouahaskell.com/starting-out However ghci says the command ':1' is not found. I run version 7.0.3
05:12:28 <shachaf> timing: I think that's an 'l'. Lowercase 'L'.
05:12:35 <shachaf> (As in "load".)
05:13:10 <geekosaur> yes
05:13:25 * geekosaur uses a font which makes the differences between 1, l, and I clear --- because so many do not
05:13:29 <timing> hahaha! really, thanks :-)
05:14:48 <timing> I already thought the 1 was weird, but maybe it was 'The First Module'
05:16:22 <byorgey> yeah, you only use :1 the first time you load anything into ghci.  after that you use :2, :3, and so on ;)
05:17:34 <timing> yeah, sweet!
05:23:14 <geekosaur> that distinction actually exists, but it's :l (load) vs. :m (module) and in particular :m +module
05:23:59 <byorgey> well, the distinction isn't exactly between first and second time loading something =)
05:30:33 <Axman6> @where lyah
05:30:33 <lambdabot> http://www.learnyouahaskell.com/
05:30:52 <navaati> @where lyaa
05:30:53 <lambdabot> I know nothing about lyaa.
05:34:47 <byorgey> ah yes, the classic Learn You An Aardvark
05:38:37 <amtal> I'm confused. cabal claims that template-haskell-2.5.0.0 requires both pretty-1.0.1.2 and pretty-1.1.1.0. But it doesn't have any version restrictions on pretty at all.
05:39:06 <Axman6> probably two of its deps need it
05:40:20 <amtal> That version depends only on base, containers, and pretty. And containers doesn't depend on pretty.
05:40:43 <geekosaur> are you trying to install template-haskell?
05:40:55 <geekosaur> if so, STOP.  it must be installed with the compiler.
05:41:00 <amtal> No, I have it installed and it appears to work.
05:41:13 <byorgey> probably template-haskell was compiled with one version of pretty, and now you are trying to install something that requires a different version
05:41:16 <amtal> I'm trying to compile my cabal package, with a fairly simple list of dependencies. Trouble started when I added cmdargs.
05:41:47 <byorgey> the trouble *manifested* when you added cmdargs.  that is not necessarily when it started =)
05:42:25 <amtal> No smoke, no fire/out of sight, out of mind.
05:42:29 <amtal> I just want to build an executable :p
05:43:24 <byorgey> amtal: can you paste the complete output of  cabal install -v --dry-run  ?
05:44:03 <hpaste> amtal pasted “cabal dep hell” at http://hpaste.org/66638
05:44:06 <byorgey> amtal: also, http://www.vex.net/~trebla/haskell/sicp.xhtml is recommended reading
05:45:18 <timing> guys, is this HSP thing still the way to go for html templating? http://blog.uncommons.org/2008/12/03/generating-html-with-haskell/
05:45:25 <byorgey> amtal: hmm, very strange.  cmdargs does not require template-haskell...
05:46:00 <hpaste> amtal annotated “cabal dep hell” with “cabal dep hell (annotation)” at http://hpaste.org/66638#a66639
05:46:04 <geekosaur> I thought it did
05:46:23 <byorgey> timing: probably not.  use something like http://hackage.haskell.org/package/hamlet
05:46:24 <geekosaur> one of the argument parser packages uses TH to avoid the global state issue
05:46:37 <timing> byorgey: thanks
05:47:44 <amtal> byorgey: the output of --dry-run is in the annotation I posted. No clue what to make of it, reading sicp...
05:47:59 <byorgey> cmdargs 0.9.5 depends on base, filepath, process, transformers
05:48:19 <byorgey> amtal: can you also paste your .cabal file?  and what version of GHC do you have?
05:50:06 <hpaste> amtal annotated “cabal dep hell” with “cabal dep hell (annotation) (annotation)” at http://hpaste.org/66638#a66642
05:50:22 <amtal> ^ GHC and .cabal deps.
05:51:06 <amtal> I take it this isn't a typical kind of error message: my GHC+cabal install may be broken?
05:51:27 <byorgey> amtal: hmm, sorry, one more thing, can you paste the output of  ghc-pkg list  ?
05:51:36 <byorgey> I think something about your package database is broken.
05:51:51 <byorgey> which is much less sever than your GHC or cabal  install being broken.
05:51:54 <byorgey> *severe
05:52:22 <navaati> hum, totally HS but… how do i tell to make "for this target, i want that this prerequisite exist, but not that it is up to date", that is if it already exist, even out of date, don't rebuild it ?
05:52:44 <hpaste> amtal annotated “cabal dep hell” with “cabal dep hell (annotation) (annotation) (annotation)” at http://hpaste.org/66638#a66643
05:52:45 <amtal> Ooh, a warning about broken passages!
05:53:18 <amtal> CoreErlang-0.0.1 is the broken one. Probably not interesting, don't think it uses th :\
05:53:30 <navaati> (uh, sorry, HS doesn't exist in english, i meant "wrong channel")
05:53:58 <geekosaur> "off topic", abbreviated OT
05:54:12 <navaati> geekosaur: ah, thanks
05:54:54 <byorgey> amtal: yeah, you have two different versions of pretty installed, one in your global package DB and one in your local DB
05:55:08 <byorgey> amtal: in general you don't want that to happen
05:55:20 <byorgey> though cabal is not (yet) very good at preventing it
05:55:47 <amtal> Ahah. I see it now - and thanks to sicp, know the difference between global and user.
05:56:15 <byorgey> amtal: you have two options: (1) unregister the version of pretty in your user DB and also unregister anything that breaks, etc. (2) delete the contents of your local package DB and start over.
05:56:41 <navaati> there is still no cabal uninstall ? is it planned one day ?
05:57:02 <byorgey> navaati: no, and I don't know
05:57:27 <byorgey> navaati: cabal is essentially just a wrapper for ghc-pkg, and neither one keeps track of info about where installed things went
05:57:31 <JuanDaugherty> you just remove the files don't you (from .cabal)?
05:57:45 <amtal> Well, gonna unregister the non-latest version of pretty and see what happens.
05:57:50 <byorgey> no, you use  ghc-pkg unregister
05:57:54 <amtal> Re-downloading a big pile of packages on wifi doesn't sound fun.
05:57:56 <JuanDaugherty> ah
05:58:11 <byorgey> amtal: no, unregister the version in your user DB
05:58:26 <byorgey> amtal: do not unregister the version in your global DB, that is sure to break things
05:58:53 <navaati> if the distro doesn't do sh*t, the global DB is usually clean…
05:59:05 <amtal> For the userdb one: ghc-pkg: unregistering pretty-1.1.1.0 would break the following packages: template-haskell-2.5.0.0 cmdargs-0.9.5 (use --force to override)
05:59:25 <amtal> My goal's to unregister those and re-install them from scratch?
05:59:28 <byorgey> yeah, the usual advice is to install the Haskell Platform stuff in the global DB, then don't touch it, and also don't try to install newer versions of anything there in your user DB
05:59:36 <byorgey> amtal: yep
05:59:48 <kallisti> is there such a thing as negative port numbers?
05:59:58 <kallisti> I don't think there is, but what do I know.
05:59:59 <navaati> kallisti: would be fun, but no
06:00:22 <byorgey> it's funny though, it doesn't look like either one of those packages should depend on pretty
06:00:25 <navaati> iirc port numbers are Word16
06:00:48 <byorgey> amtal: ah, notice you have two copies of template-haskell installed too
06:00:56 <byorgey> amtal: so just remove the one in your user DB
06:01:13 <amtal> Ack. I'm trying to remember how this happened.
06:01:39 <amtal> The pretty one in the user db was a lower version. The TH in both dbs are identical versions.
06:01:56 <byorgey> amtal: cabal install let you down, is how it happened
06:02:39 <byorgey> amtal: The latest version of cabal-install is much more conservative about this sort of thing, but that doesn't help you at the moment
06:03:18 <byorgey> oh, template-haskell does depend on pretty, OK.
06:08:04 <amtal> byorgey: thanks for the information. As my first runin with large dependency list shenanigans, that was okay... I think I've been extremely lucky in my projects thus far :p
06:09:23 <hpc> preflex: seen Cale
06:09:24 <preflex>  Cale was last seen on #haskell 10 hours, 15 minutes and 56 seconds ago, saying: nyingen: I have no idea
06:10:46 <nart> ciao
06:30:04 <EvilMachine> Hmm… I wonder… When creating an interface between two modules, there is a large analogy between creating a class, and creating a record data type MyInterface { function1: SomeType, function2: SomeOtherType, … }.
06:30:33 <EvilMachine> so i wonder if it makes sense to make a data type.
06:32:22 <EvilMachine> it sounds especially sensible, when you want to make something like event “callbacks", where you add your functions to a list inside a global state monad.
06:32:57 <EvilMachine> i still feel unsure about how do do this in the proper haskell style.
06:33:34 <timing> What is the shortest NaNaNa batman in haskell?
06:33:42 <timing> (take 32 (cycle "Na")) ++ " Batman" ?
06:34:16 <Lemmih> A little shorter: take 32 (cycle "Na") ++ " Batman"
06:34:41 <timing> a ofcourse
06:35:43 <Philippa> > foldl ("Na"++) " Batman" [1..32]
06:35:44 <lambdabot>   Couldn't match expected type `b -> [GHC.Types.Char]'
06:35:44 <lambdabot>         against inferr...
06:37:04 <Philippa> missed a const out, amongst other things
06:38:18 <burbul> Is it the case that using a smart constructor (and not exporting the 'raw' constructor) then means you can't use pattern matching?
06:38:23 <Philippa> yes
06:38:35 <hpc> burbul: try pattern-matching on IO
06:38:40 <burbul> Damn. Thanks!
06:38:43 <Philippa> at least, in Haskell2010. With GHC Haskell, you can use view patterns
06:38:48 <burbul> Sorry, pattern matching on IO?
06:38:55 <Philippa> does GHC 7.4.x have pattern synonyms? Can't remember
06:39:49 <hpc> burbul: IO in ghc is defined something like newtype IO a = IO (RealWorld# -> (# a, RealWorld# #))
06:39:58 <hpc> that tuple might or might not be unboxed
06:40:03 <burbul> ok
06:40:12 <hpc> but you don't have the constructor in scope :P
06:40:20 <hpc> so yeah, what Philippa said
06:40:20 <burbul> Is there an easy way to determine which version of ghc I have? I can't find a commandline switch to report version...
06:40:26 <hpc> ghc --version
06:40:30 <hpc> or possibly ghc -v
06:40:31 <burbul> thanks
06:40:37 <ion> > take 47([0/0..]>>=show)++" Batman!"   -- by dfletcher, 2012-03-12
06:40:39 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa Batman!"
06:40:39 <burbul> -v is apparently verbosity
06:41:03 <hpc> oh, -V
06:42:45 <EvilMachine> ion: that’s wrong.
06:42:59 * hackagebot concurrent-extra 0.7.0.4 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.4 (BasVanDijk)
06:43:01 * hackagebot levmar 1.2.1.1 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1.1 (BasVanDijk)
06:45:18 <kallisti> is >= 1.6 a reasonable Cabal-version?
06:45:25 <kallisti> that's when the wildcard syntax is supported.
06:51:16 <EvilMachine> does it make sense, to do things like data MyInterface = My { function1: SomeType, function2: SomeOtherType, … } instead of just defining a class?
06:51:56 <mnieminen> is there a way to cast maybe string to or just string to string
06:52:06 <mnieminen> -to
06:52:08 <EvilMachine> i guess while you can pass a value from a class, you can’t pass a class.
06:52:53 <azm> how do I find current folder from where GHCi is running please ?
06:53:01 <EvilMachine> mnieminen: do you mean Maybe String and Just "something"?
06:53:01 <azm> m trying to :load some file
06:53:09 <mnieminen> I have a record that has Maybe String values, and I'd like to use some operators like ++ to those values
06:53:33 <mnieminen> and I can't do that if the values are maybe strings
06:53:59 <EvilMachine> mnieminen: well, you can use the functions in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
06:54:05 <mnieminen> I've already filtered Nothing -types
06:54:11 <zomg> fmap?
06:54:44 <EvilMachine> zomg: that makes sense, if you want them to result in Maybe too.
06:55:08 <mnieminen> thanks.. there is fromJust -function that does the trick
06:55:13 <mnieminen> :)
06:55:30 <EvilMachine> mnieminen: fromMaybe might be better, if you don’t want to throw errors
06:56:10 <mnieminen> true :)
06:56:35 <ksf> how come BS.unpack is messing with the bytes of the underlying bytestring?
06:57:00 <ksf> It's returning the right result once, the rest is butchered at the start and end.
06:59:29 <kallisti> mnieminen: don't use fromJust
06:59:58 <kallisti> EvilMachine: in some designs it makes perfect sense to use function fields in records
07:00:16 <kallisti> in fact, many commonly used monads are simply newtypes over functions.
07:00:52 <ksf> hmmm I'm starting a thread inbetween...
07:01:53 <mekeor> how do you guys indent if-statements within a do-block?
07:02:00 <EvilMachine> kallisti: i thought about how one would implement some kind of event callback registry in haskell. and i thought: a data type of lists of functions of a certain type, inside a state, might do it.
07:02:11 <Xaphiosis> ksf: I can't replicate it... if I do x <- Data.ByteString.readFile "test.asm"; unpack x; unpack x in ghci, I get the same result repeatedly
07:02:25 <kallisti> EvilMachine: depends on how the events work. I doubt a list is the best structure to use.
07:02:40 <EvilMachine> mekeor: in general, i like putting the then and else on new lines, one level more indented that the if.
07:03:13 <ksf> I'm using unsafePackCStringFinalizer
07:04:20 <ksf> there's no other unsafe* anywhere, though, and the original buffer isn't referenced anywhere else.
07:04:30 <ksf> oh, and it's mallocBytes'd.
07:04:31 <EvilMachine> kallisti: the list would be something like mouseHandlers: [MouseEventHandler], so i could for example do something like map (\h -> h x y buttons) (mousehandlers state)
07:04:54 <EvilMachine> kallisti: so why not a list?
07:05:36 <Xaphiosis> hmm, do you have a small example?
07:06:15 <EvilMachine> kallisti: but hey, i’m very unsure about how to implement that system of external events (being threads from my p.o.v.) calling haskell functions that change the program state, and then trigger a redraw event or someting.
07:06:20 <hpaste> mekeor pasted “if in do” at http://hpaste.org/66648
07:06:26 <mekeor> EvilMachine: ^
07:06:30 <mekeor> which one?
07:07:05 * EvilMachine doesn’t know who’s talking to whom anymore…
07:07:20 <Xaphiosis> ksf: on the off chance this is the case, when you malloc'ed, did you take into account the size of bytestring's internal info?
07:07:22 <mekeor> personally, i use (2), but hlint doesn't like that and prints an error (because in former GHC-versions that was illegal, i think)..
07:07:28 * EvilMachine starts mumbling to himself.
07:07:31 * EvilMachine goes mad.
07:08:14 <Xaphiosis> ksf: never mind, just saw the spec, sorry. I don't think I can help here
07:08:51 <mekeor> which layout should i use? which do you prefer? see http://hpaste.org/66648
07:09:28 <EvilMachine> mekeor: which do *you* prefer? be a leader! :)
07:09:35 <Xaphiosis> I have a bit of a vague question regarding using parsec for parsing things... I appear to be missing the point of using parsec. As I parse, I keep track of labels I've seen, then when I see a reference to a label I haven't seen, I want to throw an error
07:09:56 <hpaste> parcs annotated “if in do” with “if in do (annotation)” at http://hpaste.org/66648#a66649
07:10:09 <mekeor> i prefer (2) but hlint doesn't like that. it prints an error using that layout because in former GHC-versions that was illegal, AFAIK.
07:10:11 <Xaphiosis> but when I use "fail" it just fails the current parser and tries for the next thing after the label, resulting in weird errors like "unexpected "_" "
07:10:16 <EvilMachine> mekeor: to me, layout 3 looks the most elegant.
07:10:37 <mnieminen> hmm.. not in scope fromMaybe
07:10:41 <mnieminen> why?
07:10:51 <EvilMachine> mekeor: welll, (2) is wrong too. ^ ^
07:10:54 <Xaphiosis> there appears to be no way to actually abort a parse, which leads me to believe I've got the entirely wrong approach here... and advice?
07:11:04 <EvilMachine> mnieminen: import Data.Maybe (fromMaybe) ?
07:11:29 <Xaphiosis> s/and/any/
07:11:55 <mekeor> parcs`: so, layout (1) is illegal with haskell98 ?
07:11:58 <mnieminen> EvilMachine: thanks!
07:12:04 <mekeor> parcs`: … and (2), too?
07:12:37 <EvilMachine> mekeor: then and else are obviously not on the same level as the "if".
07:12:50 <EvilMachine> mekeor: they are sub-parts of the if construct.
07:13:03 <mekeor> hmm, yep
07:14:03 <mekeor> EvilMachine: my emacs (with haskell-mode's sub-mode haskell-indent) indents like layout 2!!
07:14:04 <EvilMachine> but anyway, if you like something different and have sensible reasons, do it anyway, and just write a small code pre-processor. ;))
07:14:29 <mekeor> hehe
07:14:30 <EvilMachine> mekeor: hmm, ooo-kaaay… feels wrong to me… that’s all i can say
07:14:47 <mekeor> anyway. i'll use layout 3 for now.
07:14:58 <mekeor> DasIch_: http://hpaste.org/66648 ← which one do you prefer?
07:15:09 <mekeor> roconnor__: hi
07:15:17 <mekeor> roconnor__: which layout do you prefer? http://hpaste.org/66648
07:15:24 * mekeor spams
07:16:31 <EvilMachine> i once wrote my favorite compiler. all you had to write in the code file, was: “Do exactly what I want!”. and it compiled it to an awesome program that did exactly what i wanted. the compiler was a big big though *cough*. ;)
07:16:44 <EvilMachine> big big = bit big
07:17:12 <companion_cube> sadly, the compiler source code does not fit in your margin?
07:17:45 <roconnor__> mekeor: 4
07:17:47 <EvilMachine> my margin?
07:18:10 <mekeor> roconnor__: okay… why?
07:18:34 <roconnor__> I like indenting by 2
07:19:20 <mekeor> roconnor__: ah, yep. i agree. that's the most simple way, i think.
07:20:05 <mekeor> hmm... okay. from now on, i'll just indent (nearly) everything by two and everything is nice.
07:20:38 <t7> theres a logic programming language with a nice type system like haskell but i forgot what its called :(
07:20:42 <t7> i was gonna learn it
07:21:01 <mekeor> m…
07:21:10 <mekeor> t7: does it begin with m?
07:21:11 <geekosaur> curry?
07:21:30 <sipa> t7: mercury?
07:21:32 <mekeor> mercury?
07:21:33 <mekeor> ah
07:21:42 <mekeor> i was about to say…
07:21:49 <sipa> actually, you did
07:21:50 <t7> yeah :)
07:21:53 <mekeor> heh
07:22:07 <mekeor> t7: yea, mercury is logical and functional, afaik…
07:22:26 * geekosaur wonders if they;re related
07:22:36 <roconnor__> t7: I thought you didn't need block chains since all your messages are small
07:23:00 * hackagebot blaze-builder-conduit 0.4.0.1 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.4.0.1 (MichaelSnoyman)
07:23:08 <t7> roconnor__: i dont really, but it would be nice have commutative block chain encryption
07:23:53 <t7> i dont think it can work :)
07:25:32 <sipa> afaik, the Ed25519 system allows every 256-bit sequence as a valid public key
07:26:35 <sipa> that means you could do encryption by converting the message to a Ed25519 public key, multiply by the secret key (an integer) using EC arithmetic, and convert back to a bit sequence
07:26:44 <sipa> (sounds like it, ianac)
07:28:32 <t7> roconnor__: i was thinking about using this same scheme to decide a random bit without trusted third party
07:29:22 <t7> works kinda the same way
07:30:23 <t7> and can xor 2 [Bit] together to make a massive random number in only 4 messages
07:30:39 <Cale> @bot
07:30:39 <lambdabot> :)
07:31:03 <sipa> t7: have you looked into EC stuff; that would be commutative, but I don't know if it would be secure
07:31:21 <roconnor__> t7: DH key-exchange will pick a random bit
07:31:33 <t7> elliptic curve?
07:32:02 <hpaste> “Dmitry Matveev” pasted “MaybeT and so on” at http://hpaste.org/66651
07:32:09 <roconnor__> DH works on modular arithmetic too
07:32:21 <dmitrymatveev> Hi
07:32:27 <sipa> t7: http://en.wikipedia.org/wiki/Elliptic_curve_cryptography
07:32:39 * ksf doesn't think he's going to be able to construct a sufficiently minimal minimal example.
07:32:48 <t7> i didnt realize i could use commutative operations with ECC
07:33:08 <sipa> ECC multiplication is commutative (and distributive over ECC addition)
07:33:28 <sipa> no, not commutative, but associative, but that is what you need
07:33:38 <roconnor__> Modular arithmetic and ECC are simply two different ways of scrambling cyclic groups
07:33:39 <dmitrymatveev> I am trying to get familiar with the MaybeT monad transformer. I have a couple of functions with are m (Maybe a) and I would like to build a computation chain that would break when there will be any Nothing
07:33:59 <t7> sipa you mean homomorphic ?
07:34:12 <dmitrymatveev> http://hpaste.org/66651 fails to compile - Couldn't match expected type `[a0]' with actual type `Maybe String'
07:34:31 <dmitrymatveev> could anyone please tell me how to make it right?
07:34:45 <t7> roconnor__: o really
07:34:56 <t7> that will work then
07:35:09 <roconnor__> yes
07:35:22 <roconnor__> but the elliptic curve operations are somewhat more difficult to implement
07:38:50 * mekeor is not sure whether it's his fault that his (haskell-) source code is just ugly, chaotic and difficult to read…  but on the other hand it's always like this (-- no matter who writes the code and no matter which programming language is used --) with code, isn't it?
07:40:02 <mekeor> navaati: hi
07:40:21 <navaati> hi
07:40:59 <t7> roconnor__: not as simple as your one :)
07:41:24 <t7> 'the roconnor cipher'
07:43:01 <ksf> by the volatability of the whole thing I guess it's a bad interaction between inlinePerformIO and the gc.
07:43:20 <ksf> the *scary* thing is that it actually mutates the buffer.
07:51:07 <MagneticDuck> back
07:52:28 <ksf> ha!
07:52:47 <ksf> it's a) the threaded runtime and b) setting -k to low values makes ghc segfault.
07:54:00 <ksf> even hello world segfaults.
08:01:34 <mekeor> is there a way to make __ and ___ and so on synonyms of _ ?
08:04:17 <parcs`> they essentially are
08:04:43 <mekeor> parcs`: O_O
08:04:45 <mekeor> really?
08:04:47 <mekeor> wow
08:04:47 <mekeor> great
08:04:59 <mekeor> cool
08:05:28 <mekeor> my stupid editor didn't highlight __ as _ …
08:05:49 <rwbarton> well of course not
08:05:54 <rwbarton> why are you doing this anyways
08:06:02 <rwbarton> __ is just another identifier name
08:06:34 <rwbarton> but as parcs` suggested, an identifier you never use again is pretty much the same as _
08:07:23 <mekeor> ah
08:07:29 <ClaudiusMaximus> > let f _ _ = 2 in f 0 0
08:07:30 <lambdabot>   2
08:07:37 <ClaudiusMaximus> > let f __ __ = 2 in f 0 0
08:07:38 <lambdabot>   Conflicting definitions for `__'
08:07:38 <lambdabot>  Bound at: <interactive>:1:6-7
08:07:38 <lambdabot>            ...
08:08:42 <ClaudiusMaximus> > let f __ = __ in f 0
08:08:42 <lambdabot>   0
08:08:46 <ClaudiusMaximus> > let f _ = _ in f 0
08:08:47 <lambdabot>   Pattern syntax in expression context: _
08:08:55 <mekeor> but when i do 'f x = inThisDefinitionIDontDoUsageOfX', i get "redundant parameter"-error with GHC using -Wall. with __ instead of 'x' that doesn't happen.
08:09:09 <ClaudiusMaximus> mekeor: try f _x = ...
08:09:30 <mekeor> anyway. thanks
08:09:48 <ClaudiusMaximus> ghc suppresses "unused foo" warnings where foo begins with _
08:09:52 <rwbarton> right, names starting with _ don't trigger the unused variable warning
08:10:00 <t7> @hoogle (a -> b -> c) -> (a, b) -> c
08:10:01 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:10:01 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:10:01 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
08:18:01 * hackagebot live-sequencer 0.0.2 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0.2 (HenningThielemann)
08:18:29 <jabirali> I'm following some examples from "Natural Language Processing for the Working Programmer", and one of them makes ghci eat 700 MB of ram while a compiled program uses 170 MB to perform the same task.
08:19:37 <jabirali> Does ghc perform any particular optimizations that ghci can't do?
08:20:02 <jabirali> I
08:20:53 <Cale> jabirali: yes
08:21:10 <Cale> jabirali: Essentially all of them ;)
08:21:22 <jabirali> :P
08:21:38 <jabirali> Do you know if GHC is a JIT-compiler or a normal interpreter?
08:21:55 <Cale> GHC compiles to native code
08:22:10 <ksf> and it interprets.
08:22:17 <ksf> and its interpreter can link to compiled code.
08:22:18 <Cale> GHCi does bytecode compilation and interprets that
08:22:24 <Cale> and can load compiled code
08:22:34 <Cale> (if there are .o files hanging around)
08:22:50 <sebasmagri> Hi!, what's the best way to define a function with two positional arguments? like a -> b -> c, or like (a,b) -> c?
08:22:52 <jabirali> Aha, thanks.
08:22:56 <Cale> sebasmagri: the first
08:23:12 <ksf> sebasmagri, the former.
08:23:32 <ksf> unless you know that you're going to pass a and b simultaneously, often.
08:23:49 <Cale> sebasmagri: The reason being that you can supply one of the arguments easily, and the result will be a function of the second argument
08:24:03 <ksf> that is, you often chain f :: (a,b) -> c and g :: d -> (a, b)
08:24:15 <Cale> sebasmagri: For this reason, you also want to order the parameters in increasing expected frequency of change.
08:24:39 <Cale> That is, put the parameters which you expect to be the same in most applications of the function first
08:25:02 <ksf> ...or so that infix application makes sense.
08:25:11 <sebasmagri> Cale: ksf got it...
08:25:34 <ksf> :t curry
08:25:35 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:25:36 <ksf> :t uncurry
08:25:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:25:46 <ksf> if in doubt, use those.
08:26:02 <sebasmagri> what it basically does is a http get request to an url given as the first arg, if the second is True, it will follow redirections until it finds a 2XX response...
08:26:38 <ksf> I'd say Bool -> URL -> Result
08:26:39 <sebasmagri> I could define two different functions for that, as it would be more predictable...
08:26:45 <Cale> yeah, I'd reorder that too :)
08:26:53 <Cale> or yes, split it up
08:27:17 <ksf> then you can do simpleHttp = swissArmyKnife False
08:27:19 <Cale> If it's easier to use the Bool to define for some reason, then put the Bool parameter first, and define the two specialisations by partial application :)
08:28:11 <sebasmagri> Cale: that seems to be the best option...
08:28:16 <ksf> you can probably implement recursiveHttp in terms of simpleHttp, though.
08:28:45 <ksf> that'd be proper separation of concerns.
08:29:04 <sebasmagri> exactly...
08:29:49 <Cale> Bool parameters can be a symptom of unnatural code.
08:30:07 <Cale> Or Bool in general
08:30:41 <Cale> (I wouldn't say always, but quite often Bool gets used superfluously)
08:30:47 <sebasmagri> Cale: well I'm getting used to the functional/haskellian jargon...
08:30:51 <Cale> Yeah
08:31:47 <Cale> The issue with Bool is that it represents some condition being true or false while discarding any evidence of why that condition was true or false in the first place.
08:31:47 <sebasmagri> It's hard to stop thinking imperatively or OOP'ly, but when it starts to happen everything is easier...
08:32:05 <Cale> (It's not necessarily a functional thinking thing here)
08:32:29 <sebasmagri> yeah it's true for other paradigms too...
08:32:43 <ksf> just that it's harder to pass witnesses, or tests, in those.
08:32:54 <sebasmagri> Cale: do you think it's better to use guards in such cases?
08:34:57 <Cale> For example, you can apply the null function to a list to decide if it's empty, but you could also have pattern matched, and when you pattern match, in the nonempty case, you get an element of the list (and a tail), which provide evidence which proves that it's nonempty (and which in many cases you're going to need anyway)
08:35:33 <Cale> :t null
08:35:34 <lambdabot> forall a. [a] -> Bool
08:36:50 <Cale> But of course, there are cases where this Bool is really all you care about, like inside of filter.
08:37:58 <Cale> and then on the other side of things, Bool as a parameter to a function is often less expressive than it probably ought to be (you basically have to look in the documentation to discover what the Bool means)
08:40:40 <sebasmagri> Cale: so in general it's a good idea to provide as much evidence as possible of what a thing is...
08:43:13 <Cale> sebasmagri: Yeah, or just realise that usually when you're deciding whether or not some condition is true, that's usually not the end of the story. So types like Maybe and Either are often better at providing some context.
08:44:42 <sebasmagri> actually I've found Maybe very useful for many cases in which gettign a result is not possible.
08:45:57 <Cale> Yeah, so that's much nicer than providing a Bool (to determine if getting a result is possible), and separately providing something which gets the result and just fails if it's not :)
08:46:51 <sebasmagri> it makes a lot of sense...
08:58:53 <gspr> Can I treat threadWaitRead/threadWaitWrite from Control.Concurrent as essentially select() (for a single FD) on Linux?
09:00:30 <gspr> (... rather, single-FD select()s without a timeout ...)
09:02:10 <nart> ciao
09:03:34 <monochrom> yes, it's a single-fd select, the thread blocks, consumes little or no cpu
09:03:43 <zeroz> hey so im trying to installs eclipsefp to work with haskell and it prompts for scion-browser and buildwrapper? anyone know if this is assuming i already have GHC and cabal?
09:03:53 <gspr> monochrom: Right, good. Is there a version with a timeout?
09:04:03 <monochrom> I don't know
09:04:16 <gspr> monochrom: OK, thanks. Can't be too hard to cobble together anyway.
09:04:45 <zeroz> or would leskah be a better starting point?
09:04:55 <zeroz> leksah rather.
09:05:50 <erisco> I trying to work with FRP. I am a little held up right now. Say that I want an object to follow my mouse with a smooth motion. To define this smooth motion, I feel that I need two things: the object's current position, and the mouse's current position. The confusing part is that I am defining the object's position already
09:06:04 <erisco> how can I define the position of the object if it requires its own position?
09:09:16 <Rmx> you define its position as the integral of it's movements?
09:10:11 <Rmx> or for sweet pure beatifull code, you can try forking an other process that writes mouse position in IORef :3
09:10:33 <Rmx> but first solution sounds better
09:11:11 <erisco> how do I define the object's movement?
09:11:39 <erisco> I'd understand this as being the delta between the object's position and the position of the mouse
09:12:39 <kallisti> is there any reason not to include -O2 in ghc-options of my cabal file?
09:12:51 <kallisti> I notice other packages don't.
09:13:03 * hackagebot threads 0.5 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5 (BasVanDijk)
09:13:24 <Saizan> kallisti: compilation gets slower
09:13:34 <Saizan> kallisti: so you should check that it really matters
09:14:46 <kallisti> I would actually prefer that all packages be compiled with -O2
09:14:52 <erisco> Rmx: my approach seems all wrong
09:14:53 <vodik> i recall reading somewhere that cabal may actually compile with -O2 by default
09:14:55 <kallisti> perhaps I should configure cabal that way.
09:15:11 <erisco> Rmx: since it requires updating the position of the object for the position definition to work
09:15:13 <vodik> idk
09:15:26 <kallisti> I think -O is probably a reasonable middle ground.
09:15:48 <erisco> Rmx: and the whole point is to define the position once and only evaluate it
09:15:50 <erisco> hmm
09:15:51 <kallisti> at the very least I'd want things to inline..
09:16:05 <Saizan> i think cabal uses -O by default
09:16:38 <erisco> Rmx: I can trivially set the object's position to be exactly the mouse's position. I can set it to be the mouse's position minus some fixed offset. I seem to struggle once time is introduced
09:16:39 <kallisti> yeah I don't think my code would really warrant -O2
09:17:16 <kallisti> it's almost entirely IO bound, anyway.
09:17:27 <elliott> -O is default with cabal, yes
09:17:28 <vodik> maybe thats what i read
09:17:37 <t7> @hoogle Num a => [a] -> a
09:17:38 <lambdabot> Prelude product :: Num a => [a] -> a
09:17:38 <lambdabot> Data.List product :: Num a => [a] -> a
09:17:38 <lambdabot> Prelude sum :: Num a => [a] -> a
09:19:10 <Rmx> why ?
09:19:27 <Rmx> if you already have position as an imput
09:19:49 <Rmx> just update position, without taking care of precedents values
09:19:55 <Rmx> don't really understand your problem
09:20:38 <Rmx> Saizan, usually, -O2 isn't so much slower
09:20:54 <elliott> -O2 is more important these days I think
09:21:07 <kallisti> yes it's good for breathing. :)
09:21:07 <Rmx> I use it all the time, and I almost never wait except when it's about wx stuff
09:21:20 <stepcut> hClose seems to block if hGetLine is blocked on input.. is there a work around for that ?
09:21:24 <Rmx> but be carefull, too much and you can get Blind ;)
09:24:26 <erisco> Rmx: my problem likely is that I am missing some core concepts with FRP. Are you expected to keep a mutable state? Also, as you mentioned too, I've read mention of history of previous values. Is it a case-by-case basis how they are best aggregated?
09:24:43 <Rmx> noooo
09:24:49 <Rmx> no mutable state
09:24:54 <Rmx> it was mostly a joke :)
09:25:19 <erisco> okay ;)
09:25:55 <vodik> stepcut: sounds like normal unix behaviour. man 3p close says close shall wait until all operations are completed
09:25:58 <Rmx> then, I think you should better play without other librairies, to try to get the feeling of frp
09:26:20 <Rmx> you look a little bit confused, try to do normal small tasks using frp, in console
09:26:28 <stepcut> vodik: hmm. I'm trying to hClose the handle to force the pending operations to fail
09:26:37 <stepcut> time for a new plan I guess
09:26:43 <Rmx> even finding task to be solve in frp paradigm by yourself will be a good training, I think
09:26:57 <erisco> Rmx: am I really trying something too complex?
09:27:05 <Rmx> don't really know
09:27:17 <erisco> Rmx: I have accomplished other tasks. for example, I can draw the object directly under the mouse
09:27:31 <erisco> Rmx: or at an offset away from the mouse. I have done a text example too
09:27:41 <Rmx> wich library ?
09:27:42 <vodik> stepcut: im sure there's a way to explictly cancel operations
09:27:58 <erisco> Rmx: um, okay, C#
09:28:03 * hackagebot blaze-markup 0.5.0.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.0.0 (DeepakJois)
09:28:05 * hackagebot blaze-svg 0.2.0.0 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.2.0.0 (DeepakJois)
09:28:08 <Rmx> c#..?
09:28:17 * erisco is rofling
09:28:18 <Rmx> not haskell ? ^^
09:28:27 <erisco> Rmx: yeah, well, see
09:28:45 <erisco> same concepts though right? I am writing in a functional style
09:29:22 <Rmx> huh..
09:29:24 * stepcut checks something
09:29:39 <vodik> stepcut: targeting linux or is it cross platform?
09:29:40 <Rmx> I don't really understand the problem of creating a constant behaviour
09:29:54 <stepcut> vodik: cross platform would be nice
09:30:27 <Rmx> listen, maybe try with someone with better understanding than me
09:30:30 <vodik> stepcut: idk about cross platform but SIGALARM can be used to stop blocking syscalls after a timeout
09:30:37 <vodik> idk how well this plays into haskell
09:30:39 <Rmx> I'll be away for a while, and can't really help you more :)
09:30:41 <Rmx> good luck
09:30:44 <erisco> Rmx: thanks
09:32:24 <stepcut> vodik: I think I just need to refactor my code so I can kill the thread that is doing the hGetLine and restart the thread
09:32:38 <vodik> stepcut: probably makes more sense
09:38:04 * hackagebot diagrams-svg 0.3.3 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3.3 (DeepakJois)
09:43:04 * hackagebot ircbot 0.4.0 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.4.0 (JeremyShaw)
09:51:08 <Rmx> should I spend hours to understand well Logic Monad?
09:51:28 <Rmx> I have the impression it's a really effective tool for lots of tasks
09:51:32 <Rmx> is it really ?
09:53:29 <gspr> Is there a keyword one can put in a hsc or hs file that tells GHC to link to a specified object file without having to explicitly list that object file as an argument to GHC?
09:54:26 <elliott> why not use cabal?
09:55:24 <gspr> elliott: I have a bad habit of not using nice build systems until I feel that the project is semi-done
09:55:36 <gspr> elliott: I guess this is where you may tell me that I should :)
09:56:31 <monochrom> that's a strange criterion to use a nice build system
09:56:39 <elliott> when you want non-trivial build configurations, that's when you stop not using a build system :p
09:56:50 <gspr> elliott: Hehe
09:57:03 <elliott> gspr: also, since you have to specify all your deps with cabal, it really helps to start using it first thing
09:57:11 <elliott> or you have to track all your dependencies down one by one in one go when you do start using it
09:57:12 <monochrom> I switch to a build system when the project is semi-not-trivial
09:57:15 <gspr> elliott: That's a good point... I'll change my bad habit :)
09:57:28 <elliott> gspr: you might find "cabal init" helpful :)
09:57:38 <elliott> apparently it'll be able to guess dependencies sometime soon...
09:57:52 <gspr> hehe
10:03:37 * mekeor prefers if' over if-then-else.
10:04:32 <HugoDaniel> if' ?
10:04:53 <DMcGill> @src if'
10:04:53 <lambdabot> Source not found. Take a stress pill and think things over.
10:05:06 <DMcGill> if' p t f = if p then t else f
10:05:29 <DMcGill> basically makes it a function, rather than special syntax
10:05:31 <elliott> bool > if'
10:05:37 <elliott> bool t f p = if p then t else f
10:05:49 <elliott> has the right order of arguments for partial application and compared to maybe, either, etc.
10:06:47 <mekeor> elliott: where's bool defined?
10:07:13 <mekeor> or isn't it defined?
10:07:24 <DMcGill> @hoogle bool :: a -> a -> (a -> Bool) -> a
10:07:25 <lambdabot> No results found
10:07:45 <glguy> stepcut: You around?
10:08:12 <mekeor> @hoogle bool :: a -> a -> Bool -> a
10:08:13 <lambdabot> No results found
10:08:24 <mekeor> DMcGill: isn't that the type signature? ^
10:08:31 <DMcGill> ah yes, oops
10:08:35 <mekeor> ;P
10:09:17 <elliott> <mekeor> elliott: where's bool defined?
10:09:20 <elliott> mekeor: The same place as if'.
10:09:24 <elliott> i.e. nowhere standard.
10:09:34 <DMcGill> @hoogle (.:)
10:09:35 <lambdabot> No results found
10:09:51 <DMcGill> that's another function that seems to be in use lots but not defined anywhere standard
10:10:03 <elliott> i don't think many people use (.:) outside of lambdabot golf.
10:10:19 <otters> what is it?
10:10:30 <kallisti> (.) . (.)  of course
10:10:30 <elliott> f g x y = f (g x y)
10:11:19 <kallisti> elliott: I don't use it because it's not standardly defined anywhere, but I would like it to be because it's very easy to remember what it does based on the symbol.
10:11:58 <ski> someone here put it in a package
10:11:58 <kallisti> also the lack of its definition doesn't prevent me from being a bad person and using (f .) . g in its place. :P
10:12:08 <stepcut> glguy: yup
10:12:15 <DMcGill> > let (.:) = (.).(.) in (succ .: add) 3 5
10:12:16 <lambdabot>   Not in scope: `add'
10:12:21 <DMcGill> > let (.:) = (.).(.) in (succ .: (+)) 3 5
10:12:23 <lambdabot>   9
10:12:45 <glguy> stepcut: Have you considered adding any outgoing rate limiting to your ircbot library?
10:12:47 <DMcGill> and kallisti: that's what I kept doing but it's not very readable imo
10:12:55 <DMcGill> not as readable*
10:13:07 <glguy> I've been playing with my bot this weekend and I say hackagebot announce your update and wondered how you'd handled that
10:13:14 <glguy> but I looked and didn't see any
10:13:16 <stepcut> glguy: no.. but shouldn't be hard
10:13:27 <ski> @let cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b); cond p t e a | p a = t a | otherwise = e a
10:13:27 <lambdabot>  Defined.
10:13:46 <elliott> ski: that's just liftA3 if'
10:13:48 <kallisti> not as a readable, yes, but anything that becomes an idiom is basically readable by my standards.
10:14:06 * ski nods
10:14:08 <gspr> D'oh... is there no InterruptibleFFI in GHC 7.0.3?
10:14:11 <stepcut> glguy: starting at line 85, http://patch-tag.com/r/stepcut/ircbot/snapshot/current/content/pretty/Network/IRC/Bot/Core.hs
10:14:34 <glguy> OK, I was in the right stop, then :)
10:15:03 <stepcut> glguy: that is the output loop -- all messages are queued up in a Control.Concurrent.Chan, and that loop reads them and sends them so that is where a rate-limiter would be added
10:15:48 <stepcut> glguy: really I would like to rewrite the bot to be based around FRP..
10:16:15 <stepcut> glguy: it seems like a good fit somehow.. but I won't know until I try it :)
10:16:27 <hpaste> glguy pasted “rate limiter” at http://hpaste.org/66654
10:17:01 <glguy> I know you can do that without involving threads, but that was the quickest way I oculd think to implement the IRC rate limiting schemee
10:17:32 <stepcut> glguy: in ircbot perhaps all that is needed is a threadDelay after the hPutStrLn  in line 98 ?
10:17:49 <glguy> stepcut: A thread delay would be sufficient, but not necessary
10:18:06 <glguy> you are allowed to burst messages, but you recover that burst at a rate of 1 message per 2 seconds, typically
10:18:26 <erisco> in FRP, time is stateful... for example, how could a get an object to follow my mouse cursor with a delay? that is, once I move my mouse, the object does not respond until 2 seconds later
10:18:30 <stepcut> glguy: not sure what that means..
10:18:35 <erisco> how could I possibly avoid state?
10:19:01 <glguy> You you a counter of how many messages you can send. it starts at 5
10:19:19 <glguy> if your counter is less than 5 a timer runs for 2 seconds and increments the counter
10:20:06 <stepcut> glguy: so, you can send up to 5 messages at full speed, and then the limiter kicks in ?
10:20:10 <glguy> yeah
10:20:15 <stepcut> makes sense
10:20:38 <stepcut> I could add that
10:20:45 <mekeor> @pl lambdabot \x -> map (map foo) x
10:20:46 <lambdabot> (line 1, column 11):
10:20:46 <lambdabot> unexpected "\\"
10:20:46 <lambdabot> expecting variable, "(", operator or end of input
10:21:02 <mekeor> sorry guys, i wanted to PM hehe :)
10:21:41 <mekeor> is there a shorter way for (map (map func) list) ?
10:21:44 <gspr> What's the canonical way to convert a [CInt] into a contiguous memory block of CInts and obtain a Ptr CInt to the first element?
10:21:44 <stepcut> glguy: is your Limiter code BSD3?
10:21:59 <gspr> (I can see several ways, but I'm sure there's a canonical one)
10:22:01 <glguy> stepcut: Yes
10:22:08 <glguy> stepcut: unless you need it to be something else
10:22:16 <stepcut> glguy: nope. BSD3 is perfect
10:23:18 <elliott> mekeor: (map.map) f xs
10:23:26 <elliott> :t map . map . map . map
10:23:27 <lambdabot> forall a b. (a -> b) -> [[[[a]]]] -> [[[[b]]]]
10:23:35 <mekeor> oh, okay, neat. thanks
10:24:04 <kallisti> I'm enjoying how easy it is to document Haskell code. :)
10:24:08 <mekeor> well, actually that's not much better anyway…
10:25:29 <rwbarton> fmap fmap fmap
10:25:48 <elliott> mekeor: map (map f) xs is not exactly the longest thing in the first place.
10:25:55 <elliott> try eta-reducing?
10:26:03 <mekeor> what's that?
10:26:09 <stepcut> is there someplace that documents the fancy header you can put in haddock docs that includes things like Stability, Portability, etc ?
10:26:11 <elliott> f x = g x --> f = g
10:26:15 <elliott> foo xs = map (map f) xs
10:26:16 <elliott> -->
10:26:20 <elliott> foo = map (map f)
10:26:27 <elliott> stepcut: no, see here:
10:26:34 <elliott> stepcut: http://stackoverflow.com/questions/9012640/how-are-the-haddock-module-fields-portability-stability-and-maintainer-used
10:26:35 <mekeor> pointless notation, you mean.
10:26:39 <elliott> stepcut: they have to be in a specific order. nobody knows why.
10:26:41 <mekeor> (or point-free)
10:26:45 <elliott> mekeor: no, not the same thing
10:26:48 <mekeor> oh
10:26:53 <elliott> eta-reduction is one process that can produce point-free code
10:27:09 <elliott> but it doesn't necessarily ("f x y = g x y" --> one step of eta-reduction --> "f x = g x"), and it's not the only thing used in constructing point-free code
10:27:19 * mekeor reads http://www.haskell.org/haskellwiki/Eta_conversion
10:27:19 <jtrucks> Is the hpaste bot code available? I can't seem to find it..
10:27:35 <mekeor> elliott: okay..
10:27:51 <sebasmagri> -j #haskell-ve
10:27:51 <stepcut> elliott: ah..
10:27:54 <rwbarton> for example you can't eta-reduce "f x = g x y" or "f x = g x x"
10:27:54 <dmwit> jtrucks: It's probably built into the hpaste.org code.
10:27:57 <sebasmagri> sry
10:28:16 <elliott> stepcut: http://www.haskell.org/haskellwiki/Programming_guidelines#File_Format can guide you in selecting values for the fields, though
10:28:16 <jtrucks> dmwit: oooh. okay. I can dig around on it's git repo. thanks.
10:28:18 <mekeor> rwbarton: ah
10:28:32 <mekeor> rwbarton, elliott: so, @pl uses eta reduction?
10:28:38 <elliott> mekeor: yes, among other things
10:28:45 <mekeor> elliott: which else?
10:28:53 <elliott> well, it's mostly based on a huge rules database
10:28:57 <elliott> check the code if you want the gory details
10:29:06 <stepcut> elliott: thatks.. that template is mostly what I was lookingfor
10:29:09 <rwbarton> @pl f x = g x y
10:29:09 <lambdabot> f = flip g y
10:29:10 <rwbarton> @pl f x = g x x
10:29:10 <lambdabot> f = join g
10:29:11 <elliott> eta reduction cannot turn "f x = g (h x)" --> "f = g . h"
10:29:29 <elliott> because "f x = g (h x)" does not match the form "f x = i x" (for some i)
10:29:35 <stepcut> i wonder if there is some way in haskell-mode already to insert that template
10:29:55 <mekeor> elliott: i see. thanks again. :)
10:29:55 <elliott> doubt it
10:29:58 <elliott> stepcut: i'd just omit it :p
10:30:11 <elliott> i don't think anybody really looks at that box
10:30:28 <elliott> stepcut: and cabal already has maintainer + stability fields
10:30:32 <Modius> Is understanding of stuff like iteratee widespread in the haskell world?
10:30:38 <stepcut> elliott: I mostly want a place to put the Copyright attribution for the code I just got from glguy
10:30:55 <elliott> stepcut: that should probably go in your LICENSE/COPYING file
10:31:18 <elliott> stepcut: if you want to put it in the file you'll probably need to include the full license anyway, I think, so the maintainer field would only replace one line
10:32:21 <stepcut> elliott: it will go there as well. The code is BSD3 all around, so I think I can just add him to the maintainer list in .cabal and LICENSE
10:32:40 <RubyRedGirl> Hi haskell room… functional n00b here trying to install Haskell-platform on my mac os x (home brew.  don't hate, i'm a web developer) and I could _not_ get it to work, anyone have the same setup and was able to get haskell-platform up and running?\
10:33:02 <elliott> stepcut: author list, not maintainer, surely? :p
10:33:24 <stepcut> elliott: that's what I meant
10:33:25 <RubyRedGirl> http://pastie.org/3751047
10:33:39 <RubyRedGirl> I only copied and pasted the latter half of the error message
10:33:56 <elliott> RubyRedGirl: the heck?
10:34:00 <elliott> RubyRedGirl: ' is a valid character in identifiers
10:34:05 <elliott> are you sure you're compiling with gcc? :)
10:34:10 <elliott> please paste the whole error
10:34:19 <RubyRedGirl> the whole error?
10:34:25 <elliott> yes
10:34:35 <RubyRedGirl> yeah and the weird thing is it has issues with _Ruby_, so weird!  Ruby has nothing to do with haskell!
10:34:51 <elliott> however I think homebrew likes to mix new ghc and old haskell platform
10:34:58 <elliott> you might want to just use the OS X haskell platform installer instead
10:35:14 <kallisti> I have a type called Cookie. I feel "a cookie" is probably a poor way to document it, but I really don't know what else to say about it.
10:35:19 <parcs`> Modius: yes, now go and understand it :P
10:35:40 <elliott> kallisti: -- | Cookies are delicious delicacies.
10:35:50 <elliott> (http://upload.wikimedia.org/wikipedia/commons/e/e3/Firefox_Delicacies.png)
10:35:59 <RubyRedGirl> elliott: i think i will have to do platform installer, because i am only pasting 1/100th of my error message to you :)
10:36:02 <RubyRedGirl> ;( i meant
10:36:07 <elliott> RubyRedGirl: well, just paste the start of it then
10:36:19 <RubyRedGirl> here is it slightly longer
10:36:25 <kallisti> elliott: I might actually do that..
10:36:26 <mekeor> elliott++
10:36:31 <parcs`> ghc seems to be worse on mac than even on windows
10:36:41 <RubyRedGirl> Regarding the start of it, sadly, it will take me probably 5 minutes of scrolling upward to find it
10:36:45 * ksf is starting to believe that you have to be both a ph.d in maths and a ph.d in artistery to get an rgba value out of data.colour
10:36:57 <kallisti> also I have a problem with capitalizing the first word of sentence fragments,  but it seems to be the norm in documentation.
10:37:05 <ski> `(forall a. f a = g a) -> f = g' is actually extensionality ..
10:37:07 <dmwit> RubyRedGirl: command | head -100
10:37:13 <ski> .. but it's related to eta-reduction
10:37:17 <elliott> RubyRedGirl: brew blah 2>&1 | tee log
10:37:27 <elliott> Edit log in $FAVOURITE_EDITOR, copy first hundred lines
10:37:27 <dmwit> ksf: Plus, you have to have a ph.d in British to even find the package!
10:37:43 <elliott> ksf: Huh?
10:37:53 <dmwit> ksf: Anyway, toSRGB24 is probably your friend.
10:37:57 <dmwit> http://hackage.haskell.org/packages/archive/colour/2.3.3/doc/html/Data-Colour-SRGB.html
10:37:57 <RubyRedGirl> dmwit: and elliott awesome commands!  i forgot about head! :) :) :)  will brb with the results
10:38:05 * hackagebot histogram-fill 0.6.2.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.6.2.0 (AlexeyKhudyakov)
10:38:12 <elliott> toSRGB24 :: (RealFrac b, Floating b) => Colour b -> RGB Word8
10:38:13 <ksf> as far as I can tell from the docs, I have to get hold of a gamut which will give me an rgbspace which will allow me to convert.
10:38:16 <elliott> ksf: Where's the Ph.D. there?
10:38:27 <ksf> I've got no idea what to put into a gamut, though.
10:38:38 <dmwit> ksf: I made the same complaint. Those stuff are supposed to be internal, but they're too useful to actually hide.
10:39:04 <dmwit> ksf: But see both elliott's and my suggested tool. =)
10:39:46 <mekeor> preflex: elliott++
10:39:52 <mekeor> preflex: karma elliott
10:39:52 <preflex>  elliott: 14
10:39:55 <dmwit> ksf: There's also toRGB in D.C.S.Linear module.
10:40:03 <abizern> I've got a .hs module in the parent directory of a source file. if I compile with -i.. it compiles fine. Without the -i.. it doesn't work even though I have {-# OPTIONS_GHC -i.. #-} at the top of my source file. Any idea what I'm missing?
10:40:25 <dmwit> ksf: The comment at the top of http://hackage.haskell.org/packages/archive/colour/2.3.3/doc/html/Data-Colour.html tells how to choose between them.
10:40:26 <gspr> If I have multiple  (Storable a) => Vector a  , let's say two by the names x and y, how do I send them to a C function imported with signature  Ptr a -> Ptr a -> IO () ? I can only see unsafeWith, which confuses me... do I need to uncurry the FFI function or something?
10:40:54 <gspr> (I don't know why I bound these vectors to names x and y in what I said... overlook that :) )
10:41:45 <RubyRedGirl> before i start attempting to use the Mac os X haskell installer, here is the top of the error…. don't know if it's the top 1% of the error or the top 10% ;)
10:41:46 <ski> gspr> :t unsafeWith
10:41:47 <RubyRedGirl> http://pastie.org/3751079
10:42:12 <dmwit> abizern: OPTIONS_GHC doesn't support all flags.
10:42:28 <dmwit> abizern: Check the flags reference and compare "dynamic" and "static" flags.
10:42:40 <dmwit> abizern: I don't recall off the top of my head which of those OPTIONS_GHC supports, but it's only one.
10:44:08 <dmwit> yes, only dynamic flags, and -i is static
10:44:26 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/static-dynamic-flags.html
10:45:05 <gspr> ski: Yeah, I see unsafeWith, but I'm confused... do I simply nest it twice?
10:45:20 <ski> gspr : .. i was asking you what type it had
10:45:21 <kallisti> "screen orientation"  "a mouse button"   man I'm just providing some essential facts in this documentation.
10:45:23 <abizern> dmwit: Thanks. At least I know I'm not being stupid!
10:45:38 <gspr> ski: Ahahaha, sorry
10:45:43 <kallisti> without this, someone may have gotten confused about what a MouseButton is.
10:45:44 <elliott> RubyRedGirl: i'll take a look
10:45:45 <gspr> unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
10:45:57 <elliott> RubyRedGirl: ok, we need the part _after_ all the ld muck
10:46:00 <elliott> those are just ignorable warnings
10:46:11 <elliott> RubyRedGirl: if it's a few thousand lines, just paste it all
10:46:20 <ski> gspr : so, `unsafeWith x $ \px -> unsafeWith y $ \py -> c_function px ys' should probably work
10:46:30 <RubyRedGirl> elliott: okay
10:47:05 <gspr> ski: Alright... had a scary feeling about it, so that's why I asked. I guess I'm confused with regards to how FFI functions are partially applied.
10:48:00 <gspr> I feel that they're very very special, but I guess that's not true... they're just ordinary functions with IO-return, right?
10:48:16 <gspr> They look sorta scary because of that whole "foreign import..." thing
10:48:48 <abizern> Ah - I see I can use cabal-dev to install libraries that are only used in some projects. That might make compiling easier
10:49:21 <ski> gspr : something like `let unPtr = ContT . unsafeWith; cFun = lift .: c_function in (evalContT . join) (cFun <$> unPtr x <*> unPtr y)' would also probably work, but i think the former options is probably nicer here
10:49:22 <RubyRedGirl> (paste is processing as best as it could…) :) i will stay tuned
10:49:33 <elliott> RubyRedGirl: if pastie doesn't work you can try our pastebin, http://hpaste.org/
10:49:39 <gspr> ski: OK
10:50:18 * kallisti really needs more bug testing of his Selenium library.
10:50:36 <ski> gspr : sorry, s/ys/py/
10:50:46 <companion_cube> what is .: ?
10:50:50 <ski> gspr : well, partial application works just as usual -- if you want to do that, you can turn it into `unsafeWith x $ \px -> unsafeWith y (c_function px)' first, and then `unsafeWith x (unsafeWith y . c_function))'
10:51:04 <elliott> companion_cube: \f g x y -> f (g x y)
10:51:07 <ski> companion_cube : `infixr 9 .:; (.:) = (.) . (.)'
10:51:23 <companion_cube> oh, a kind of binary composition, thanks
10:51:32 <RubyRedGirl> elliott: 413 Request Entity Too Large
10:51:32 <RubyRedGirl> nginx/0.7.65
10:51:33 <DMcGill> let (.:) = (.).(.) in (succ .: (+)) 3 5
10:51:34 <RubyRedGirl> lol!
10:51:37 <RubyRedGirl> it wouldn't allow me to paste
10:51:42 <elliott> RubyRedGirl: how big is the file?
10:52:08 <parcs`> ouch, nginx 0.7
10:52:22 <RubyRedGirl> oh. my. go*
10:52:26 <ksf> \o/
10:52:26 <RubyRedGirl> i just saw it was...
10:52:33 <ksf> I SUCCEEDED PASSING RGBA
10:52:33 <RubyRedGirl> 23 megs!!!!!!!!!!!
10:52:38 <elliott> RubyRedGirl: oh. heh.
10:52:48 <elliott> RubyRedGirl: are you _sure_ there's no obvious point at which things start erroring out?
10:52:50 <ksf> AND IT TOOK ME A MERE 20 MINUTES
10:53:51 <RubyRedGirl> elliott: I am using the auto-installer… it should work alright?  too bad i'm not so excellent w/ manually compiling packages
10:54:00 <RubyRedGirl> will i be able to run ghci as usual from my command line?
10:54:09 <RubyRedGirl> last summer i was able to install Haskell to my debian virtual machine
10:54:15 <elliott> yes, it'll work fine
10:54:19 <elliott> you should probably uninstall homebrew ghc first
10:54:22 <elliott> so that you don't accidentally run it
10:54:24 <RubyRedGirl> but right now I am installing this to my work computer which has homebrew
10:54:42 <pozic> Can someone tell me why functional programming is a good idea, since updating a record requires time linear in the size of the structure?
10:55:08 <domenico> #haskel11
10:55:19 <elliott> dominikh: ?
10:55:20 <elliott> erm
10:55:21 <elliott> domenico: ?
10:55:35 <elliott> pozic: What?
10:56:02 <elliott> pozic: If you have records big enough that that means anything, you're doing something very wrong. Sharing means that you can modify large tree structures without copying much at all.
10:56:12 <elliott> (And without having to throw away the old/modified versions, as imperative programming forces you to.)
10:56:13 <pozic> elliott: f x = x{a=b} where x is a structure with 100 million members takes more than constant time.
10:56:25 <elliott> That's ridiculous, GHC probably won't even compile a structure with 100 million members.
10:56:45 <elliott> I doubt gcc will either.
10:56:54 <pozic> elliott: instead of 100 million take, 100.
10:57:00 <pozic> elliott: still a factor 100 slowdown.
10:57:08 <elliott> By the way, "f" there is still constant time.
10:57:20 <pozic> elliott: not in the way I specified it.
10:57:37 <rwbarton> i tried so hard to avoid using /ignore in #haskell...
10:57:41 <abizern> Is there an updated version of the Haskell Platform? For Mac OS X the last update was April 2011, it seems.
10:57:41 <elliott> And that "100x" is silly, because it'll still be basically free. (And a record with 100 members are a bad sign anyway.) But you're clearly just trolling if you start with a line like that, so whatever.
10:57:43 <elliott> So begone.
10:57:55 <elliott> rwbarton: Apologies.
10:58:00 <pozic> elliott: basically free?
10:58:05 <pozic> elliott: free because?
10:58:11 <dmwit> pozic: Man, why should I bother with imperative languages? Copying a single struct with 1000000 elements takes time 1000000 instead of O(1) time!
10:58:29 <pozic> elliott: AFAIK, it needs to hit memory around 100 times more.
10:58:35 <pozic> elliott: not exactly free.
10:58:41 <dmwit> I mean, I can't even trust a pointer copy because somebody might change what's behind the pointer on me later without my knowledge.
10:58:43 <elliott> Wait, haven't you trolled in here before? I recognise your name.
10:58:49 <pozic> dmwit: that is incorrect.
10:59:01 <kallisti> dmwit: yes, pointers are always trustworthy, as we know.
10:59:10 <dmwit> And it's even worse if the struct is a recursive data type like a tree!
10:59:26 <dmwit> Then it could very well be unbounded even if there's only a few fields in the struct!
10:59:27 <elliott> dmwit: I'm sure you'll convince them in no time!
10:59:29 <dmwit> DANG
10:59:45 <int-e> dmwit: come on, who's trolling now?
10:59:51 <pozic> elliott: you are going into the trolling argument, because you don't have an answer that doesn't involve waving hands?
11:00:03 <abizern> As an Objective-C developer I wholly concur with elliott: and dmwit: even copying pointers is not safe unless you write your own deep copy.
11:00:06 <elliott> I agree with int-e though, it'll just encourage them.
11:01:01 <dmwit> More pragmatically: yes, modifying one field in an n-field record takes O(n) time. But that rarely matters, because for all n, n < 30.
11:01:46 <pozic> dmwit: that's just an unfounded statement.
11:01:58 <pozic> dmwit: show me an application written in Haskell vs one written in C and show it.
11:02:08 <dmwit> Okay!
11:02:11 * dmwit picks xmonad
11:02:17 <kallisti> good choice
11:02:19 <dmwit> No records with more than 30 fields in there. Done!
11:02:23 <pozic> xmonad doesn't have large structures.
11:02:24 <elliott> dmwit: Arguing with them is not going to make them go away.
11:02:30 <elliott> Ignoring them will.
11:02:45 <pozic> Because you say n < 30, I pick n=29.
11:02:55 <int-e> in Haskell if you have such a large structure, you better nest it, so that it becomes a flat tree.
11:02:57 <dmwit> Great! 29 < 30, so it's proved. =)
11:02:59 <pozic> Your candidate 'xmonad' doesn't match.
11:03:05 * hackagebot hscd 0.0.3 - Command line client and library for SoundCloud.com  http://hackage.haskell.org/package/hscd-0.0.3 (SebastianMagri)
11:03:31 <dmwit> Wait, what? What I meant (though perhaps my joke wasn't clear on this) was that nobody creates a record with more than 30 fields.
11:03:32 <kallisti> so you want a Haskell structure with 29 fields?
11:03:34 <kallisti> that might be difficult.
11:03:54 <pozic> There are plenty of applications that have much more fields.
11:03:57 <dmwit> So it doesn't matter that copying a record depends on the number of fields, because there are O(1) fields in all programs.
11:04:03 <int-e> usually that happens automatically, since nobody can keep 30 fields apart without some properties that group them into different classes.
11:04:05 <dmwit> pozic: Name one.
11:04:06 <pozic> Also non-nested ones.
11:04:22 <kallisti> I hit 16 in my current project, for a configuration record. The performance impact is beyond negligible.
11:04:30 <pozic> dmwit: any complicated GUI for example.
11:04:32 <rwbarton> at the benefit of going off-topic, you might actually want a 30+-field record for a tree-like structure
11:04:35 <elliott> pozic: You're right, Haskell is unusably slow and we spend all our day working around the unintuitivity of functional programming and the slowness of laziness by splitting our records up into multiple fields, because assigning a field in a 1,000-element record takes about 10 seconds on a good day. In fact, this is why Haskell is usually slower than Ruby. Please let reddit know we're charlatans.
11:04:41 <rwbarton> doesn't clojure use 32-ary trees?
11:04:46 <dmwit> pozic: No, name a real program whose source I can inspect which has a record with 30 fields.
11:04:54 <dmwit> pozic: Otherwise, it is *your* argument which is unfounded.
11:04:55 <int-e> pozic: the point is really that if you progam in Haskell like it is C then it will come back and bite you.
11:05:13 <rwbarton> for its built-in/base library Map structure
11:05:15 <companion_cube> rwbarton: then won't you use an array?
11:05:35 <rwbarton> array might have more overhead I suppose
11:05:36 <elliott> You guys realise that every troll turns #haskell into a distributed self-denial of service, right?
11:05:49 <int-e> yes :)
11:05:57 <int-e> we're all trollers at heart
11:06:05 <companion_cube> rwbarton: even a kind of unboxed array of pointers?
11:06:18 <companion_cube> (assuming you want some kind of b-tree)
11:06:20 <rwbarton> hmm
11:06:23 <rwbarton> yeah
11:06:38 <cheater_> i think in this case the troll is in fact a worm rather than a DOS
11:06:45 <rwbarton> well, if you can unpack the array into a constructor
11:07:13 <ksf> hmmm I don't think AlphaColour does what I want.
11:07:19 <rwbarton> but likely you want something like Leaf | Node Child1 Child2 ... ChildN, and then using an array instead of the children introduces an extra indirection (at least)
11:07:43 <rwbarton> and I don't think unpacking an array there is very realistic
11:07:59 <elliott> rwbarton: If N=32, it still won't matter one bit.
11:08:09 <elliott> And it's, again, impossible to compare the imperative and functional cases because they *don't* *do* *the* *same* *thing*.
11:08:18 <elliott> Haskell has mutable arrays too, that can assign without copying.
11:08:27 <kallisti> pozic: actually to avoid the performance impact of copying my 1000-field records, I prefer to use mutable hash tables with string keys and dynamically typed values throughout all of my code.
11:08:32 <elliott> To compare it with imperative programming, you need to write an imperative program that doesn't forget data when updating it.
11:08:35 <rwbarton> suppose I only care about minimizing the number of pointers I go through to look up something in my tree
11:08:37 <pozic> elliott: except the GC doesn't really work well with them.
11:08:42 <rwbarton> within reason, so no 1024-ary trees
11:08:44 <elliott> One that makes multiple small modifications to a single peice of data and operates on them all, simultaneously.
11:08:47 <elliott> *piece
11:08:48 <companion_cube> it would be interesting to be able to say "Leaf | Node (UArray myrecursivetype)" with the Node and the contained Array allocated contiguously
11:08:51 <Rmx> am I right to say IO monade is pure ?
11:08:53 <elliott> It'll end up doing the exact same thing as Haskell, naturally.
11:08:54 <rwbarton> companion_cube: right
11:08:56 <companion_cube> so you don't have any cache penalty
11:09:00 <elliott> Rmx: IO lets you do impure things. It doesn't make Haskell impure, though.
11:09:13 <Rmx> so IO is pure
11:09:13 <rwbarton> and not just the UArray constructor but the actual ByteArray# or whatever primitive
11:09:15 <Rmx> ok
11:09:16 <pozic> Purity has no meaning.
11:09:22 <dmwit> ?quote roconnor pure
11:09:22 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
11:09:22 <lambdabot> isn't pure.
11:09:24 <cheater_> pozic: haskell is just a wrapper around an STG. your point is invalid.
11:09:27 <kallisti> Rmx: expressions that evaluate to type IO a are pure
11:09:29 <pozic> Rmx: purity is a wonderfully useless concept.
11:09:47 <Rmx> IO = GADT ?
11:09:49 <dmwit> Rmx: See that quote, and ignore pozic's posturing.
11:09:52 <kallisti> Rmx: no
11:09:54 <int-e> Rmx: IO also doesn't *do* anything until the IO action returned by main is run.
11:10:05 <Rmx> I mean, how are side effects allowed
11:10:11 <Rmx> without GADT
11:10:15 <elliott> Rmx: It's a primitive.
11:10:18 <pozic> What is sort of useful is the abstraction of actions.
11:10:20 <elliott> It's an abstract type; you don't know the implementation.
11:10:25 <Rmx> ok
11:10:42 <pozic> Still, Haskell is not special in that.
11:10:53 <cheater_> Rmx: IO is a way of constructing programs by composing programs together. those programs are stored in values. you run a program stored in such a value by "running" it.
11:10:57 <pozic> Also, stacks of monad transformers don't make code simpler to understand.
11:11:41 <cheater_> pozic: last i checked bash with set -x was just the error monad, so you're right, it's all been done before.
11:11:57 <rwbarton> 'you run a program stored in such a value by "running" it'? :)
11:12:15 <danharaj_> I hope so.
11:12:26 <kallisti> Rmx: the side-effectful bits of IO are not actually implemented in Haskell, so the question of how they're represented in Haskell isn't important.
11:12:26 <int-e> rwbarton: yes, using an interpreter for a language that isn't haskell but tailored to doing IO.
11:12:29 <cheater_> rwbarton: i was just trying to say, that you need to explicitly invoke an operation which you call "running" in order to execute :)
11:13:15 <kallisti> Rmx: it's a primitive of the language, basically.
11:13:18 <danharaj> that operation isn't defined within Haskell.
11:13:28 <danharaj> (unsafePerformIO notwithstanding)
11:13:28 <elliott> indeed
11:13:37 <Rmx> ok
11:13:38 <rwbarton> in Haskell that operation is "main = ..." or FFI to C or unsafePerformIO
11:13:42 <rwbarton> mostly the first
11:13:55 <Rmx> just look at implementation of hGetChar
11:13:56 <pozic> unsafePerformIO having no meaning.
11:14:01 <int-e> unsafePerformIO is part of the FFI spec for a reason :)
11:14:02 <Rmx> understood
11:14:15 <Rmx> so why so much blabla about unsafePerformIO
11:14:15 <pozic> Yes, to fill up space, because it has no meaning.
11:14:15 <elliott> Rmx: hGetChar is also a primitive.
11:14:26 <elliott> You looked at GHC's (unportable, not actually Haskell) implementation.
11:14:27 <Rmx> I see
11:14:36 <elliott> unsafePerformIO is useful to implement things that are externally pure.
11:14:37 <pozic> You cannot prove anything with programs involving unsafePerformIO.
11:14:39 <elliott> It lets you extend the language, basically.
11:14:44 <Rmx> ok
11:14:54 <Rmx> because it's not always unsafe, to what I understand
11:14:54 <pozic> That's because the FFI spec uses weasel language.
11:14:55 <elliott> pozic: Please just go away. unsafePerformIO has explicit guarantees.
11:14:57 <elliott> Oh!
11:15:11 <elliott> You're the person who spent hours arguing about unsafePerformIO having no meaning, despite being quoted the spec being really plain on it.
11:15:16 <elliott> I remember now.
11:15:19 <plat0> unsafePerformIO is analogous to fromJust
11:15:20 <cheater_> pozic: if weasels are enemies to the reptilions, then i'm all for weasels.
11:15:38 <Rmx> plat0, yeah, I understood
11:15:44 <pozic> elliott: I don't think that's how it went.
11:15:54 <pozic> elliott: but you are free to change history.
11:16:08 <Rmx> hm.. maybe stupid question, but now, I have the impression we should have 2 differents IO monads
11:16:21 <Rmx> like a safe IO from wich fromIO is safe
11:16:26 <elliott> Rmx: That's ST.
11:16:31 <elliott> It lets you use mutable variables in a safe way.
11:16:37 <elliott> (But nothing else.)
11:16:45 <Rmx> ok
11:17:01 <pozic> elliott: have you ever even written anything in Haskell?
11:17:09 <danharaj> @ops
11:17:10 <lambdabot> Maybe you meant: docs oeis pl
11:17:19 <mekeor> @where ops
11:17:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
11:17:20 <danharaj> (This troll needs to go)
11:17:20 <Rmx> great, thanks
11:17:21 <mekeor> danharaj: ^
11:17:27 --- mode: ChanServ set +o copumpkin
11:17:29 <danharaj> thank you.
11:17:36 <kallisti> nah, elliott is a poser.
11:17:40 <int-e> pozic: I know who elliott is. Who are you?
11:17:55 <cheater_> i heard of pozic before
11:17:57 <elliott> danharaj++ mekeor++
11:17:59 <plat0> unsafePerformIO and fromJust are also analogous to \[x] -> x
11:18:03 <cheater_> never seen him contribute anything
11:18:06 <pozic> int-e: not as stupid as elliott.
11:18:09 <elliott> ha
11:18:13 <elliott> copumpkin: plz
11:18:15 <cheater_> i'm not sure but i think he was referred to as a troll in the conversation
11:18:16 <elliott> plat0: only unsafePerformIO violates referential transparency
11:18:19 <elliott> fromJust and head don't
11:18:25 <int-e> pozic: you're not doing a good job at demonstrating it.
11:18:25 <copumpkin> pozic: please be nice :) people have asked before
11:18:40 <pozic> copumpkin: before? I just got here.
11:18:42 <copumpkin> pozic: if you're pissed off, take a chill pill and do something else
11:18:43 <plat0> elliott: that's not head!
11:18:48 <elliott> plat0: yeah yeah, it's close enough
11:18:50 <plat0> plat0: they do violate totality though
11:19:00 <elliott> copumpkin: this isn't the first time he's wasted a lot of time with frivolous arguments about Haskell, fwiw
11:19:01 <plat0> which is basically the point
11:19:11 <pozic> elliott: your opinion is worth nothing.
11:19:16 <cheater_> pozic: be nice
11:19:18 --- mode: copumpkin set +b pozic!*@*
11:19:22 --- mode: copumpkin set -o copumpkin
11:19:28 * dmwit pays elliott 0.02 BTC just to prove pozic wrong
11:19:29 <vhd> I have a structure, (listA,listB), I need to traverse listA and put values into listB, can this be done with a single walk of listA?
11:19:43 <plat0> You can map a value of type m a to a when you know it's equal to return x for some x of type a.
11:19:53 <copumpkin> back to haskell talk
11:19:53 <elliott> dmwit: Just gotta wait for the inflation ;)
11:20:16 <dmwit> vhd: yep, though you won't be changing either listA or listB
11:20:31 <dmwit> vhd: Kind of depends on which values you want to transfer, I guess.
11:20:50 <dmwit> vhd: But show us a version that uses multiple walks and we'll try to come up with a single-walk version. =)
11:21:00 <sizz> What code changes do I need to make to make this ghci code run from a file?:   fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
11:21:01 <elliott> plat0: unsafePerformIO lets you do much more than that within its guarantees
11:21:07 <elliott> for instance, maintaining a memoisation table
11:21:21 <dmwit> sizz: No changes that I can see.
11:21:26 <vhd> dmwit, hmm ok I will return when I have something then.
11:21:28 <vhd> thanks
11:21:52 <elliott> sizz: You might need to remove or add a "let" at the start.
11:21:58 <kallisti> elliott: any idea why TypeFamilies is making GHC stupid about resolving class constraints?
11:21:59 <elliott> Add if you want to run it in GHCi, remove if you want to run it from a file.
11:22:07 <elliott> kallisti: That question is too vague to answer.
11:22:24 <ben> optionally add "main = print $ 20 fib" or whatever to the file if you want to actually, you know, print it <:)
11:22:35 <int-e> what exactly do you mean by "run"? you may have to add a suitable  main  function, ... what ben just saidd
11:22:40 <kallisti> elliott: it seems as though any named function that returns an overloaded type needs an explicit type signaure and can't simply be inferred.
11:23:03 <elliott> kallisti: Monomorphism rsetriction?
11:23:06 <dmwit> kallisti: Show us some code!
11:23:18 <int-e> ah. fibs :: [Integer] -- but it should default to that.
11:23:54 * int-e mixed up two threads of the discussion, sorry.
11:24:19 <mekeor> @src (->) -- is (->) defined in haskell itself?
11:24:20 <lambdabot> Source not found. Wrong!  You cheating scum!
11:24:28 <heatsink> No, it's built-in
11:24:37 <mekeor> bummer. that'd be awesome.
11:25:07 <heatsink> How would you define the type of functions?
11:25:17 <gspr> Am I reading the docs correctly if I interpret  throwTo t  as blocking forever if the thread corresponding to t has terminated?
11:25:25 <mekeor> heatsink: maybe a bit like Arrow or so? idk
11:25:31 <kallisti> dmwit: elliott: oh wait nevermind it wasn unrelated error.
11:25:38 <kallisti> s/wasn/was an/
11:25:50 <kallisti> I was having issues with it earlier though
11:25:55 <sizz> dmwit: elliott: we it runs in ghci, but when I do 'runhaskell fibs.hs I get Not in scope: `main'
11:26:07 <elliott> sizz: what ben said
11:26:12 <elliott> you need to specify an actual program to run
11:26:18 <elliott> it doesn't know what to do with a pile of definitions :)
11:26:23 <danharaj> (->) is the right adjoint to product :3
11:26:38 <elliott> (btw, the not in scope: main error is really bad, it should say "main not defined in module Main" or such)
11:26:55 <sizz> okay
11:27:17 <danharaj> But no you can't define (->) in Haskell because you need to define function application, and that's a primitive of lambda calculus.
11:27:56 <mekeor> danharaj: wow. cool. neat. nice. great.
11:28:29 <ski> you can define it in Charity ..
11:28:40 <danharaj> yes because in Charity adjunctions are a primitive :)
11:28:53 <danr> What is Charity?
11:28:56 <ski> (.. and morphisms)
11:28:59 <ski> @where Charity
11:29:00 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
11:29:04 <hpaste> kallisti pasted “type inference?” at http://hpaste.org/66660
11:29:12 <danharaj> Category theory that you can run in an interpreter.
11:29:16 <kallisti> here's the error I get with the type signatured commented out.
11:29:17 <danr> thank you
11:29:18 <mekeor> ski: O_O
11:29:34 * ski stares blankly at mekeor
11:29:48 * mekeor stares back (with really really big eyes!)
11:29:51 <kallisti> before I needed TypeFamilies this code worked fine, but now it gives me that type error unless I include the commented out type signatures.  (note: type families are not actually used in this code)
11:30:00 * mekeor still
11:30:02 <elliott> god, i love that charity picture
11:30:09 <elliott> http://pll.cpsc.ucalgary.ca/charity1/www/wofm/wofm2.html
11:30:16 <dmwit> gspr: Seems you are not reading the docs correctly.
11:30:26 <elliott> it takes a special kind of person to think charity is /midway/ between esoteric and practica
11:30:34 <hpaste> dmwit pasted “throwTo test” at http://hpaste.org/66661
11:30:53 <gspr> dmwit: I'm happy to hear that, because the behavior I described is certainly not what I want :)
11:31:00 <Saizan> kallisti: i think TypeFamilies implies MonoLocalBinds
11:31:16 <kallisti> does NoMonomorphismRestriction not correct this?
11:31:40 <kallisti> I guess NoMonoLocalBinds would.
11:31:50 <rwbarton> it looks like req is only used once anyways...?
11:31:56 * ski idly wonders what mekeor started staring at
11:31:56 <rwbarton> wait
11:32:08 <Saizan> opt is the problem i guess
11:32:10 <rwbarton> why did you comment out the definition of opt
11:32:12 <kallisti> rwbarton: well, yes.
11:32:17 <kallisti> I have similar code elsewhere
11:32:21 <kallisti> the req is just a shorthand.
11:32:22 <rwbarton> i'm supposed to imagine you commented out the type signature?
11:32:34 <kallisti> rwbarton: yes, please do.
11:32:37 <kallisti> imagination is good for you.
11:32:38 <rwbarton> okay cool
11:32:38 <elliott> kallisti: oh, yes, typefamilies turns on monolocalbinds
11:32:42 <elliott> but monolocalbinds is nice, away
11:32:51 * elliott wants NoMonomorphismRestriction + MonoLocalBinds for Haskell 201X
11:32:51 <rwbarton> that makes sense with opt then and MonoLocalBinds, yeah
11:33:11 <danharaj> boo monolocalbinds
11:33:16 <rwbarton> I assumed the problem was with req because opt's type signature wasn't commented out! then I kept reading :)
11:33:16 <kallisti> NoMonoLocalBinds seems to remove the issue, yes.
11:33:25 <elliott> kallisti: just give it a type signature
11:33:28 <elliott> MonoLocalBinds is a good thing
11:33:34 <mekeor> ski: at the screen =)  -- no, it was the link and the Charity. the language is really cool!
11:33:37 <heatsink> I thought let-bindings were monomorphic by default since GHC 7.something
11:33:40 <elliott> otherwise tons of things don't share that you'd expect to
11:33:46 <elliott> heatsink: only with certain extensions (like TypeFamilies)
11:33:49 <heatsink> ok
11:34:02 <elliott> oh, and you need MonoLocalBinds for: (a, g) = randBlah g
11:34:03 <elliott> to work properly
11:34:08 <rwbarton> isn't the monomorphism restriction exactly what prevents lack of sharing
11:34:12 <elliott> because you want the type of "a" to decide the type of "g"
11:34:14 <gspr> dmwit: Nice, I should've just tried what you did. Thanks :)
11:34:21 <elliott> rwbarton: yes, but at the top-level it's less unintuitive
11:34:24 * mekeor thinks that his last message was not good english…
11:34:37 <elliott> rwbarton: you want local bindings to be monomorphic by default, and global bindings not to be (since you generally _like_ polymorphism there unless you've said otherwise)
11:34:53 <rwbarton> MonoLocalBinds also monomorphises type variables that don't have class contexts though, right?
11:34:53 * kallisti likes polymorphism everywhere. :(
11:35:03 <elliott> rwbarton: yeah
11:35:10 <elliott> kallisti: anyway, you'll almost certainly want req/opt in more than one place
11:35:12 <elliott> so put them at the top-level
11:35:29 <kallisti> no it's a shorthand to curry an existing function to a local variable.
11:35:34 <kallisti> so it can't be a top-level thing.
11:35:44 <danharaj> I feel like there should be a monomorphic "=" and polymorphic "=" so you don't have to write the type signature when you want a polymorphic local bind
11:36:18 <heatsink> case e1 of x -> e2 is monomorphic let
11:36:28 <mekeor> ski: does Charity have an IRC-channel? where can/should i discuss it?
11:36:42 <danharaj> Is Charity even actively developed anymore?
11:36:43 <elliott> kallisti: oh, i see.
11:36:48 <elliott> mekeor: #haskell :p
11:36:53 <elliott> danharaj: i don't think so.
11:36:54 <kallisti> elliott: the purpose is kind of lost in the above code, but I have instances where there are over a dozen fields..
11:37:01 <elliott> latest news from 2000
11:37:04 <mekeor> elliott: :)
11:37:05 <elliott> oldest news from 1996 :p
11:37:08 <kallisti> elliott: so I just adopted a consistent style across all of them.
11:38:19 <mekeor> so, is Charity still actively developed? apparently not… but anyway. do some people still use it? was it an experiment? are there programming languages which took over ideas from Charity?
11:38:28 <danharaj> It was a PhD thesis.
11:38:30 <mekeor> ah
11:38:35 <mekeor> by ski?
11:38:38 <danharaj> No
11:38:39 <ski> mekeor : vaguely related, i think esap was attempting to define the core typechecker for a language based on CT, in Haskell
11:38:40 <mekeor> :)
11:38:43 <danharaj> By Hagino in the 80's.
11:39:00 <mekeor> ski: esap?
11:39:19 <ski> (basically `typeCheck :: UntypedExpr -> Maybe (exists t. TypedExpr)')
11:39:24 <danharaj> But since it seems modern PL applications lag 40 years behind research, maybe in a few decades Charity will be the inspiration for a practical language.
11:39:26 <ski> preflex: xseen esap
11:39:26 <preflex>  esap was last seen on freenode/#haskell 78 days, 23 hours, 25 minutes and 11 seconds ago, saying: elliott: heh, you mean every paradigm must resort to unsafe coercions?
11:39:37 <mekeor> danharaj: PL?
11:39:40 <mekeor> prog-lang, okay
11:39:41 <danharaj> programming language
11:40:16 <elliott> ski: TypedExpr t surely
11:40:19 <mekeor> ski: cool.
11:40:31 <ski> elliott : er. yes
11:40:42 <elliott> ski: anyway, surely it should be Either (forall t. TypedExpr t -> Void) (exists t. TypedExpr t) :p
11:41:34 <ski> elliott : interesting idea :)
11:42:09 <elliott> kind of pointless in haskell though
11:42:18 <kallisti> elliott: I'm still struggling with performance issues due to copying such large numbers of fields upon record updates. Any suggestions would be much appreciated.
11:42:38 <elliott> heh
11:42:47 <elliott> use C
11:42:51 <heatsink> Wouldn't an 'exists t. s' type be useless since you'd want to match 't' against some other type?
11:43:07 <elliott> heatsink: you can use it with anything universally quantified on t
11:43:10 <elliott> it's just an existential
11:43:13 <heatsink> Right
11:43:18 <elliott> data SomeTypedExpr = forall t. SomeTypedExpr (TypedExpr t)
11:43:31 <elliott> heatsink: it's true that it's usually not useful in haskell, but consider if the constructors of TypedExpr let you find out t
11:43:32 <heatsink> But lots of contexts expect a specific t, or at least a t in a specific kind
11:43:39 <elliott> like NumLiteral :: Int -> TypedExpr Int
11:43:46 <elliott> Pair :: TypedExpr a -> TypedExpr b -> TypedExpr (a,b)
11:43:50 <elliott> then you can find out the "t" through case analysis
11:43:54 <heatsink> Oh I see
11:44:04 <elliott> in a dependently-typed language, you can actually look at the t of an exists t
11:44:21 <elliott> which makes it more useful (but gets rid of the "hiding" property haskell uses for things like runST)
11:45:55 <heatsink> I suppose types would not be inductively defined, because you can extend them with new type definitions
11:45:59 <heatsink> So you can't case-analyze them
11:46:01 <int-e> @type Control.Monad.ST.runST
11:46:02 <lambdabot> forall a. (forall s. ST s a) -> a
11:46:05 <heatsink> And that would preserve the hiding property, right?
11:46:51 <stepcut> glguy: if you set the burst length to 1, then it delays every message I think?
11:47:09 <glguy> correct
11:47:22 <stepcut> hmm
11:47:30 <stepcut> what happens if you set it to 0
11:47:36 <stepcut> nothing ever gets sent?
11:47:55 <elliott> <heatsink> And that would preserve the hiding property, right?
11:48:00 <glguy> stepcut: correct
11:48:06 <stepcut> I guess I expected that with a rate limit of 1, I could send 1 message before being limited
11:48:07 <elliott> heatsink: not quite -- though i forget how you can use it to defeat it, sorry
11:48:27 <glguy> with a burst of 1 you can send 1 message and then you must wait
11:48:45 <stepcut> no..
11:49:03 <stepcut> that is what I expected.. but not what I observed
11:49:26 <stepcut> though, maybe my observations are wrong
11:49:28 <stepcut> oh..
11:49:29 <glguy> I think they are
11:49:33 <stepcut> I know what happened
11:49:50 <stepcut> when the bot connects, it talks to the server a bunch to register the nick, etc
11:49:55 <stepcut> those messages also got rate limited
11:50:10 <stepcut> so that pushed me over the threshold for a while
11:50:44 <stepcut> glguy: do you think all messages should be rate limited ? or just privmsg and notice ?
11:50:47 <stepcut> shapr: boing
11:51:02 <ski> mekeor : i think <http://www.kotiposti.net/epulkkin/test1.cifl> was supposed to be an example of the syntax
11:51:13 * shapr hugs stepcut
11:51:16 <glguy> stepcut: I think all, but I'm not sure exactly what Freenode implements or when rate limiting goes into effect
11:51:19 * stepcut licks shapr
11:51:20 <shapr> stepcut: Dude, we gotta hang out sometime!
11:51:35 <stepcut> shapr: yup! Would be easier if we were in the same locality sometime!
11:51:42 <glguy> stepcut: I think that you accumulate bad points if you  go over your rate limit but that that doesn't necessarily kill you right at that moment
11:51:47 <shapr> stepcut: I agree.
11:51:49 * ski bounces shapr
11:51:56 <kallisti> elliott: also, it's urgent that you responsd to my pull requests for acme-strfry. There are critical updates at stake.
11:51:59 <stepcut> shapr: are you going to ICFP this year?
11:52:21 <shapr> stepcut: Unlikely, I'm on student loans.
11:52:26 * shapr skis ski
11:52:34 <stepcut> shapr: are you coming to Chicago anytime soon ?
11:52:39 * djahandarie shapes shapr
11:52:44 * shapr handles djahandarie
11:52:50 <elliott> kallisti: I was too busy doing useful things to look at them yet :p
11:52:55 <elliott> I'll do so in the next few days.
11:53:06 * hackagebot knob 0.1.1 - Memory-backed handles  http://hackage.haskell.org/package/knob-0.1.1 (JohnMillikin)
11:53:09 <shapr> stepcut: Nothing comes to mind. Someday though.
11:53:19 <stepcut> shapr: where are you these days?
11:53:38 <shapr> Northwest Alabama, far away from most things interesting.
11:53:45 <stepcut> ?get-shapr
11:53:45 <lambdabot> shapr!!
11:53:53 <shapr> Well, except Huntsville, Graceland, Fame Studios, and other music related things.
11:54:05 <heatsink> Any programming related things?
11:54:16 <kallisti> elliott: I don't think you take your job as acme-strfry maintainer as seriously as you should.
11:54:27 <kallisti> this is important security software.
11:54:29 <gspr> If I told you that I don't see why one would ever use MVars over TMVars, am I stupid? :)
11:54:36 <stepcut> shapr: how far is that from apalachicola ?
11:54:53 <elliott> gspr: MVars have less overhead... they're useful if you just need the basic functionality they provide, and don't need to synchronise on more than one
11:54:55 <elliott> they're more primitive
11:55:00 <stepcut> gspr: I just switched code from MVar to TMVar today before realizing the bug was somewhere else :p
11:55:50 <heatsink> Is there any reason to prefer IO (Maybe a) over MVar a in non-threaded code?
11:55:54 <heatsink> uh
11:56:01 <heatsink> IORef (Maybe a)
11:56:40 <gspr> elliott: Right. OK, I see. But can I do the following with plain MVars? Block until an MVar is full, and be interruptible by while blocking. But, *if* I *do* get the MVar, then I *must not be interrupted* until I can do some IO action with the content of said MVar.
11:56:51 <gspr> elliott: I feel I need a TMVar and  atomically  to do that
11:57:14 <gspr> gah, remove "by" after interruptible
11:57:18 <dmwit> heatsink: Is that a joke playing on gspr's question, or a real one?
11:57:24 <rwbarton> interruptible?
11:57:34 <rwbarton> as in, by exceptions?
11:57:45 <heatsink> dmwit, a real one.  I sometimes use MVar for convenience in non-threaded code.
11:57:55 <gspr> rwbarton: yes... but now that I think of it, I can't do that with TMVars either
11:58:00 <dmwit> heatsink: I suppose MVar has some locking overhead that IORef doesn't have.
11:58:03 <gspr> damnit!... OK, time to rethink this :)
11:58:08 <rwbarton> indeed
11:58:13 <gspr> elliott: Scratch my question
11:58:39 <rwbarton> hmm
11:59:31 <elliott> heatsink: Yes.
11:59:39 <elliott> Erm, or rather, anti-no.
11:59:41 <elliott> They're very different.
11:59:44 <elliott> heatsink: You can't write "block until Just" on that IORef, for instance.
11:59:53 <elliott> MVar = IORef + emptiness + locking.
12:00:48 <dmwit> elliott: I feel like blocking would be dangerous in a non-threaded app.
12:01:01 <elliott> Yeah, it is.
12:01:04 <shapr> stepcut: Further research shows that YES, I am in Appalachia, though the Appalachian trail only extends to Georgia. I am here: http://en.wikipedia.org/wiki/Florence,_Alabama
12:01:09 <heatsink> Yeah, blocking isn't useful without threading.
12:01:10 <elliott> Non--threaded, that is.
12:01:12 <stepcut> glguy: I am just going to rate limit NOTICE and PRIVMSG for now
12:01:17 <elliott> *-(-threaded).
12:01:22 <elliott> Even forkIO'ing without -threaded wouldn't help.
12:01:31 <mekeor> shapr: how did you make #haskell successful?
12:01:40 <mekeor> i read that you lead #haskell to success.
12:01:40 <dmwit> eh?
12:01:43 <shapr> mekeor: I convinced people that it was successful.
12:01:53 <gspr> Am I overlooking something, or is it hard/impossible to write a function that tries to take two  MVar a  and blocks until either one is full?
12:01:53 <dmwit> That's not true, if it's a threaded app but not using the threaded runtime, blocking can be quite useful.
12:02:02 <mekeor> shapr: ah. so that they join the channel or what?
12:02:04 <elliott> dmwit: Oh, sorry -- I was thinking of blocking FFi calls
12:02:07 <elliott> *FFI
12:02:19 <elliott> mekeor: Did you know that #haskell was founded by John Resig?
12:02:22 <elliott> I was all "whoa" when I found that out.
12:02:25 <shapr> mekeor: Yes. There wasn't another real-time forum for discussion of Haskell.
12:02:35 <shapr> elliott: He didn't tell me that :-(
12:02:40 <stepcut> shapr: heh. No I was asking how close are you to  Apalachicola, Florida, not Appalachia
12:02:43 <dmwit> gspr: Yes, it's hard. MVar's are not composable. That's why STM was invented.
12:03:05 <stepcut> shapr: my parents have a beach house there, which is probably the closest I would normally get to Alabama
12:03:07 <shapr> elliott: I thought I founded #haskell... when did this Resig guy start?
12:03:21 <mekeor> elliott: whoa
12:03:22 <shapr> elliott: What's his irc nick?
12:03:27 <gspr> dmwit: Hmm, interesting. So I should be able to do something like that with TMVars?
12:03:30 <elliott> shapr: "The #haskell channel appeared in the late 90s, and really got going in early 2001, with the help of Shae Erisson (aka shapr)."
12:03:36 <elliott> jeresig, I think? I'm not convinced he uses IRC any more.
12:03:43 <heatsink> gspr, in C, that's what select() was invented for.  There's probably something analogous in Haskell
12:03:43 <elliott> He said he started #haskell on reddit once.
12:03:43 <dmwit> gspr: Yes: takeTMVar foo <|> takeTMVar bar
12:03:48 <elliott> When somebody noticed he was an /r/haskell mod.
12:03:50 <dmwit> gspr: pretty easy, right? =)
12:04:02 * shapr checks his nickname
12:04:04 <elliott> shapr: Perhaps the channel got dropped before you vitalised it?
12:04:23 <gspr> heatsink: Yeah, I know. I'm actually writing some glue to be able to wait for an MVar (or TMVar) *or* a select() at the same time at this very moment :P
12:04:28 <shapr> elliott: Could be... but I founded this channel.
12:04:32 <dmwit> gspr: Likely it's not necessary to do this, though; just spawn two threads that each wait for one of the MVars.
12:04:40 <gspr> dmwit: That's... pretty :)
12:04:44 <stepcut> shapr: are you going to have a party when #haskell breaks 1000 ?
12:04:50 <elliott> stepcut: I believe it has
12:04:52 <shapr> stepcut: That's a great idea!
12:04:53 <elliott> shapr: Well, ok. Maybe you should update the wiki?
12:04:59 <stepcut> elliott: oo
12:05:03 <Philippa> heatsink: you send all the messages down the same pipe (or equivalent) and let the target thread see what happens. It's all done with concurrency, select() sits in the RTS
12:05:04 <elliott> Though technically: -ChanServ- Information on #haskell:  -ChanServ- Founder    : dons :p
12:05:20 <gspr> dmwit: But by doing that, won't there be a race after one of them has returned? During the return, might not the other also be able to take its MVar?
12:05:25 <heatsink> Oh, i see
12:05:28 <shapr> elliott: Yah, I transferred it to him when I had other stuff to do for awhile.
12:05:36 <heatsink> So then you'd design things so that each thread has one input channel
12:06:09 <dmwit> gspr: Spawn two threads that each read from their MVar and write to a Chan. Spawn a third thread that reads from its Chan once and does something with it, then reads from it again and puts the second value it read back in an MVar.
12:06:15 <mekeor> preflex: xseen dons
12:06:15 <preflex>  dons was last seen on freenode/#haskell 84 days, 52 minutes and 15 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
12:06:16 <gspr> dmwit: Although I am changing my specs now... I said "wait for either MVar"... I really mean wait for one MVar, but if one goes through, then no other must
12:06:36 <dmwit> gspr: Great, then you just want a single MVar.
12:06:43 <dmwit> gspr: No need to have two different ones.
12:07:03 <shapr> I should probably bug dons to transfer founder-ness to some other people who are here more often.
12:07:08 * shapr sends an email
12:07:13 <dmwit> gspr: You just have all your threads race to write to that MVar, and only read from it once.
12:07:52 <Philippa> heatsink: bingo. Start to resemble any well-known paradigms?
12:07:58 <gspr> dmwit: Right... damn, my lies come back to haunt me. You see... one of the MVars isn't really an MVar, it's my crazy FFI function doing select() and stuff.
12:08:03 <Philippa> (this, incidentally, is a /good/ thing)
12:08:06 <gspr> dmwit: That's what I get for lying ;)
12:08:11 <gspr> dmwit: I need to think some more I guess
12:08:35 <Philippa> should your crazy FFI function be living in the same process as the RTS?
12:08:37 <heatsink> Philippa: Erlang? The actor model?
12:08:52 <Philippa> heatsink: yep. Or if you squint a little, just plain old OO
12:08:53 <gspr> Philippa: It's in an OS thread
12:09:08 <heatsink> hmm
12:10:01 <Philippa> (for Kay values of OO: things like inheritance were never much the point)
12:11:01 <hpaste> gngdhr pasted “Compilation error for (Random GLfloat)” at http://hpaste.org/66664
12:11:26 <stepcut> glguy: rate limiter added
12:11:33 <gngdhr> Can someone explain why I am getting this error - No instance for (Random GLfloat)
12:11:33 <gngdhr>       arising from a use of `randomRIO'
12:12:07 <gngdhr> from what I understand, the compiler is complaining that there is no constructor for Random GLfloat
12:12:22 <rwbarton> it's complaining that there is no instance for Random GLfloat
12:12:25 <gngdhr> ghc version 7.0.4
12:12:28 <dmwit> gspr: Perhaps you'd better tell us what you're really doing so we can cut through all the XY crap.
12:12:28 <roconnor__> gngdhr: there is no declared way to pick a random number for GLfloats
12:12:30 <rwbarton> in other words, it doesn't know how to produce random GLfloats
12:12:50 <gngdhr> Thank you for the reply folks
12:12:58 <gngdhr> That is what I am trying to figure out
12:13:07 * hackagebot ircbot 0.5.0 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.5.0 (JeremyShaw)
12:13:08 <gspr> dmwit: You're absolutely right, but I'll try a bit more to solve it myself first (the learning is the only reason I'm writing what I'm writing anyway)
12:13:24 <rwbarton> gngdhr: adding some realToFrac should help out
12:13:24 <gngdhr> if the GLfloat (declared in the opengl library) is a type synonym, why would this error occur?
12:13:28 <rwbarton> it's not
12:13:43 <gngdhr> rwbarton: Thanks for that, I tried that too. And when I do I get a different error
12:13:49 <rwbarton> (also it is confusing because it used to be, I think)
12:14:46 <gngdhr> No instance for (Random (a0 -> b0))
12:14:47 <gngdhr>       arising from a use of `randomRIO'
12:15:36 <dmwit> Well, if you show us the code generating that error we can certainly help.
12:15:41 <gngdhr> from what I understand, the -1.0 is being considered as GLfloat (instead of float) and the compiler can't find a random function for GLfloat
12:15:54 <rwbarton> guess: (-1.0)
12:16:05 <rwbarton> no
12:16:09 <gngdhr> dmwit: http://hpaste.org/66664
12:16:09 <rwbarton> well, sort of
12:16:55 <rwbarton> easiest way will be to generate random Floats or Doubles, and then convert them to GLfloats
12:16:56 <hpaste> gngdhr pasted “Compilation error for (Random GFloat) using realToFrac” at http://hpaste.org/66665
12:17:25 <dmwit> gngdhr: You put the realToFrac in the wrong place.
12:17:26 <rwbarton> yeah that's not where you want realToFrac
12:17:47 <dmwit> gngdhr: x <- randomRIO (-1, 1); y <- randomRIO (-1, 1); return (Vector2 (realToFrac x) (realToFrac y))
12:18:21 <dmwit> gngdhr: Probably better to just declare a Random instance for GLfloat that calls realToFrac like that, though.
12:18:27 <dmwit> ?src Random
12:18:27 <lambdabot> class Random a where
12:18:27 <lambdabot>   random    :: RandomGen g => g -> (a, g)
12:18:27 <lambdabot>   randoms   :: RandomGen g => g -> [a]
12:18:27 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
12:18:27 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
12:18:29 <lambdabot>   randomRIO :: (a,a) -> IO a
12:18:30 <rwbarton> FLOATING_TYPE(GLfloat,tyConGLfloat,"GLfloat",CFloat) -- well that's helpful
12:18:31 <lambdabot>   randomIO  :: IO a
12:19:33 <dmwit> Hm, maybe not. Might be more roundtrips.
12:19:39 <dmwit> bleh, gotta run
12:19:56 <rwbarton> yeah, you'd need to convert the input
12:19:58 <rwbarton> as well
12:20:15 <gngdhr> dmwit: thank you. Will try this out. Am still getting some more errors
12:30:13 <elliott> has anyone used cabal with hugs?
12:30:23 * elliott wants a way to ping all haskellers of sufficient vintage
12:30:55 <dmwit> But, but... cabal didn't even exist until GHC was the One True Implementation.
12:31:07 <elliott> @ping-everyone-who-remembers-Hugs, @ping-everyone-who-remembers-when-Monad-didn't-have-fail, @ping-everyone-who-remembers-"where"-being-an-expression
12:31:08 <lambdabot> Unknown command, try @list
12:31:23 <rwbarton> try #haskell-fogies
12:31:25 <elliott> the last one is just @ping-augustss
12:31:39 <elliott> dmwit: hmm, really?
12:31:45 <elliott> dmwit: I know cabal at least used to make some effort to support hugs.
12:31:49 <elliott> that's what dcoutts said anyway
12:32:04 <dmwit> Not sure how that contradicts what I said.
12:32:17 <dmwit> really leaving now
12:32:39 <elliott> dmwit: well, fair enough :)
12:32:46 <parcs`> @hoogle touch
12:32:47 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
12:32:47 <lambdabot> System.Posix.Files touchFile :: FilePath -> IO ()
12:32:47 <lambdabot> Data.Array.Storable touchStorableArray :: StorableArray i e -> IO ()
12:32:59 <elliott> parcs`: reading unsafe GHC code?
12:33:07 <elliott> that uses touch# i think
12:33:32 <parcs`> no, i want to touch a file
12:33:39 <elliott> oh
12:33:42 <parcs`> is that posix only?
12:33:45 <elliott> there's no such thing as "touch" even in libc
12:33:52 <elliott> do you want to create it or update its access time?
12:34:02 <parcs`> update its modification time
12:34:28 <elliott> ok
12:34:35 <elliott> (FWIW, the corresponding c is utime(blah, NULL))
12:34:48 <elliott> parcs`: http://hackage.haskell.org/packages/archive/unix/2.5.1.0/doc/html/System-Posix-Files.html#g:12
12:38:14 <parcs`> what is touch# btw?
12:40:07 <rwbarton> don't quote me on this but I think basically it means that its argument is being used by something outside the scope of the garbage collector
12:40:46 <rwbarton> its purpose is just to retain a reference to that argument that is visible to the GC until the touch# action completes
12:41:32 <elliott> parcs`: nothing
12:41:37 <elliott> parcs`: it's just there so that its argument doesn't get GC'd
12:41:40 <elliott> yeah what rwbarton said
12:41:47 <elliott> the touch# x code holds a reference to x
12:41:48 <elliott> so it won't get GC'd
12:41:54 <elliott> just like touchForeignPtr stops the Ptr getting collected
12:42:03 <rwbarton> so your FFI or primop or whatever can use x without worrying about it going away
12:42:48 <rwbarton> (you put touch# x after whatever uses x)
12:42:55 <gspr> dmwit: Suppose that it is given that I have to deal with an MVar a and an MVar b, and there's no way I can merge them into a single MVar (Either a b) (for the sake of discussion). Do you have any hints how I may go about making a function :: MVar a -> MVar b -> IO (Either a b)  that returns when one of the MVars can be taken, *but* makes sure that once one of them is taken, the other will nto?
12:43:01 <gspr> *not
12:43:04 <gspr> I've got everything up until the final but :)
12:43:46 --- mode: ChanServ set +o glguy
12:43:55 <elliott> uh oh
12:44:00 --- mode: glguy set +b damn3d!*@*
12:44:07 <gspr> (the point of the function is obviously to return a Left a  if the MVar a  was taken, or a Right b if the MVar b was)
12:44:13 --- mode: glguy set -o glguy
12:44:25 <rwbarton> gspr: does "use STM / TMVar" count as an answer?
12:44:36 <elliott> <gspr> dmwit: Suppose that it is given that I have to deal with an MVar a and an MVar b, and there's no way I can merge them into a single MVar (Either a b) (for the sake of discussion). Do you have any hints how I may go about making a function :: MVar a -> MVar b -> IO (Either a b)  that returns when one of the MVars can be taken, *but* makes sure that once one of them is taken, the other will nto?
12:44:39 <elliott> this is exactly what STM is designed for
12:44:54 <elliott> takeMVar v1 `orElse` takeMVar v2
12:45:09 <elliott> erm
12:45:11 <elliott> *takeTMVar
12:45:33 <gspr> elliott / rwbarton: Aaaah damnit, WHY wouldn't my brain think of that 40 minutes ago?
12:45:33 <parcs`> what is the type of touch#?
12:45:42 <gspr> thanks again guys :)
12:45:50 <elliott> parcs`: touch# :: o -> State# RealWorld -> State# RealWorld
12:46:13 <elliott> parcs`: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:touch-35-
12:47:38 <glguy> stepcut: Freenode counts JOIN commands in the flood detection (and probably others), you might want to turn it on for all messages after a certain initialization point
12:48:10 <stepcut> glguy: where did you find this information?
12:48:37 <glguy> stepcut: in the ircd source code it counts all messages, but concretely copumpkin was talking about it in -ops
12:48:41 <stepcut> glguy: unfortunately, there is no simple way to turn it on / off like that in the current structure.. one of the reasons why I want FRP
12:48:53 <stepcut> glguy: what is the limit ?
12:49:00 <netogallo> z
12:49:12 <glguy> stepcut: they wouldn't tell me the hard numbers they use in their config
12:49:28 <stepcut> did they suggest any recommended settings?
12:49:30 <glguy> stepcut: freenode, apparently, factors message length in, too
12:50:05 <glguy> stepcut: the settings I was told to use are 2 second delay 5 message burst, but that wasn't necessarily an official answer but form someone in #freenode
12:50:06 <stepcut> this is sounding a bitch catch 22-ish
12:51:33 <stepcut> glguy: the current code takes the delay in microseconds.. perhaps that is too much precision?
12:52:43 <glguy> probably. I didn't make a design choice there, I just passed through what threadDelay used
12:53:17 * elliott wishes threadDelay used Data.Fixed
12:54:47 <elliott> hmph, #hugs is not about Hugs
12:54:57 <stepcut> is it about hugs ?
12:54:57 <Ke> awww
12:56:05 <tech2> Does anyone still use Miranda?
12:56:16 <elliott> i very much doubt it
12:56:20 <hiptobecubic> What is it?
12:56:20 <elliott> stepcut: i'm not sure it's about anything
12:56:40 <elliott> a channel with no topic and like 5 people in it
12:57:05 <elliott> maybe I need to get a time machine back to 2004 to ask my hugs question
12:57:09 <rwbarton> maybe they are the last 5 hugs users
12:59:45 <Tinned_Tuna> @src lift
12:59:45 <lambdabot> Source not found. Maybe you made a typo?
12:59:49 <Tinned_Tuna> @src liftM
12:59:50 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:01:56 <qnikst> elliott: hi, about STM vs IO chans, for plain comminication 1 produces 1 consumer STM is 1.5 times slower then IO
13:01:57 <lambdabot> qnikst: You have 1 new message. '/msg lambdabot @messages' to read it.
13:02:23 <elliott> TChan vs. Chan, right?
13:02:30 <qnikst> yes
13:02:37 <rwbarton> that's pretty good
13:02:43 <elliott> i can believe that. that's not a very significant difference,
13:02:44 <elliott> *.
13:02:54 <rwbarton> of course it is hard to do this kind of microbenchmark
13:02:55 <qnikst> it's interesting to test many producers to one consumer
13:03:07 <elliott> did you use criterion to measure this, btw?
13:03:18 <elliott> anyway, 1:1 is a pretty boring use-case -- note that if you increase consumers, TChan and Chan's semantics differ
13:03:26 <qnikst> I failed to test with criterion properly
13:03:49 <elliott> qnikst: not sure i trust your results then :p
13:04:05 <elliott> but they're believable.
13:04:11 <qnikst> I can paste code
13:04:23 <elliott> well, it's more about timing differences.
13:04:28 <qnikst> I've used time from http://www.gnu.org/directory/time.html
13:04:30 <elliott> what went wrong with criterion, anyway?
13:04:37 <elliott> that link is broken, btw
13:05:02 <qnikst> mean: 13.82494 s to mean: 8.699792 s
13:05:10 <qnikst> hm now they are realistic
13:05:28 <qnikst> last night I've got some ns results, while I should have seconds
13:06:19 <gspr> elliott: I'm sure my questions are getting stupider and stupider... but with your example from earlier (takeTMVar v1 `orElse` takeTMVar v2), we need both v1 and v2 to have type TMVar a
13:06:32 <gspr> in my case, one is TMVar a, the other TMVar b
13:06:48 <gspr> sure, I can make a TMVar (Either a b) out of both...
13:06:55 <qnikst> you should have STM a ction
13:07:09 <gspr> but then I'll have trouble making sure that not both values are taken, won't I?
13:07:13 <qnikst> i.e. TMVar a and TChan a will work
13:07:55 <elliott> gspr: ((Left <$> takeMVar v1) `orElse` (Right <$> takeTMVar v2))
13:08:06 <elliott> gspr: STM Just Works -- you don't have to wonder about atomicity at all
13:08:19 <elliott> anything you do inside an atomically block will be perfectly atomic and isolated; only one branch of an orElse will ever actually happen, etc.
13:08:29 <qnikst> elliott: really I should test only namy-producers to one consumer, that task I need Chan, for smth that is more difficult I'll definatelly use stm
13:08:30 <qnikst> =)
13:08:33 <gspr> damnit! It's just... just too brilliant!
13:08:46 <elliott> gspr: oh, you might find:
13:08:57 <gspr> really... how come the world doesn't run around drooling over this STM stuff? It seems too good to be true
13:09:05 <elliott> it only works if immutability is the convention
13:09:15 <elliott> microsoft spent years trying to do STM in C#
13:09:18 <elliott> but there's just too much mutation
13:09:21 <elliott> join . atomically $ (process1 <$> takeTMVar v1) `orElse` (process2 :: takeTMVar v2)
13:09:23 <elliott> erm
13:09:25 <elliott> join . atomically $ (process1 <$> takeTMVar v1) `orElse` (process2 <$> takeTMVar v2)
13:09:31 <elliott> gspr: process1 :: a -> IO b
13:09:33 <elliott> process2 :: c -> IO b
13:09:38 <elliott> assuming v1 :: TMVar a, v2 :: TMVar c
13:09:49 <elliott> that's equivalent to:
13:10:03 <elliott> do { e <- ((Left <$> takeMVar v1) `orElse` (Right <$> takeTMVar v2)); case e of { Left a -> process1 a; Right a -> process2 a } }
13:10:05 <elliott> lets you skip the Either
13:10:28 <gspr> I...oh... no words... mind... blown :)
13:14:26 <manuranga> this may sound very stupid, but I am new, what is the difference between type `Num` and  type` Num a => a` ?
13:14:40 <elliott> manuranga: `Num` is not a type.
13:14:44 <elliott> Num is a typeclass.
13:14:49 <elliott> foo :: Num -- this is not valid
13:14:55 <elliott> perhaps you are thinking of Int?
13:18:24 <manuranga> thanks elliott,
13:18:25 <manuranga> ahh, what i was wondering was, isn't saying something is of type Num, is equal to saying something is of type `a` where type `a` is Num
13:19:11 <elliott> manuranga: Well, not really. Nobody says the former, and the latter is an incorrect translation.
13:19:21 <elliott> It means: "Something is of type 'a', where type 'a' is an instance of Num".
13:19:28 <elliott> There are many instances of Num -- Int, Integer, Float, Double, Rational, etc.
13:19:32 <elliott> They're not all the same.
13:19:58 <manuranga> ok, thanks , i'll read into this
13:20:13 <manuranga> Num -> Int
13:20:14 <manuranga> Num a => a -> Int
13:20:23 <manuranga> so thay are not same
13:20:30 <rwbarton> The first is invalid.
13:20:40 <gspr> manuranga: Although you should be careful with taking advice from a newbee like myself, I found thinking of typeclasses like "OO interfaces" helped at first (then it helped less and started feeling wrong, but hey...)
13:20:41 <rwbarton> The second is valid, so yes, they are not the same.
13:21:12 <elliott> gspr: It works OK as an introductory analogy, but taking it too far is dangerous.
13:21:17 <elliott> That can't explain fromInteger, for example.
13:21:29 <gspr> elliott: Yeah, I agree.
13:21:38 <rwbarton> also it's confusing since e.g. java lets you declare variables as a "type" which is an interface (right?)
13:22:34 <elliott> rwbarton: yeah
13:22:37 <elliott> they act like existentials
13:22:44 <elliott> except you can cast them out to the implementation type
13:23:15 <kallisti> :t puts
13:23:16 <lambdabot> Not in scope: `puts'
13:23:17 <manuranga> rwbarton, ya i thinks that’s where my confusion stems form
13:23:29 <kallisti> :(
13:24:00 <elliott> kallisti: ?
13:24:40 <manuranga>  kallisti, vi user?
13:25:33 <elliott> (What's the relevance of vi?)
13:25:51 <zzo38> I think I have found out the way, there is way to make up a datatype that can make a comonad from any MonadLogic
13:26:04 <zzo38> duplicate (x :| y) = (x :| y) :| (msplit y >>= maybe empty (uncurry pairHT)) where { pairHT h t = pure (h :| t) <|> (msplit t >>= maybe empty (uncurry pairHT)); };
13:26:07 <zzo38> Is it the right way?
13:33:10 * hackagebot ncurses 0.2.1 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.1 (JohnMillikin)
13:47:26 <vhd> Say if I have a data structure as ([Int], [Int]) where if I take something from one list I place it in the other, how would I search this structure and move values efficiently?
13:48:32 <qnikst> use Vector instread of [] ?
13:48:39 <qnikst> *instead
13:49:38 <qnikst> it depend on how you would access values, by index, by value, or you'll take only head of array
13:49:42 <vhd> I actually have something else instead of [Int]
13:50:39 <DrSyzygy> vhd: still depends on what you want to do to it
13:50:52 <DrSyzygy> different data structures in the two halves have different tradeoffs
13:51:08 <vhd> its a board game, so I want to access by index ideally
13:51:25 <vhd> left list contains pieces on the board, right captured pieces
13:51:31 <vhd> are*
13:53:47 <DrSyzygy> access by index is a good indicator you'll want a vector.
13:54:11 <DrSyzygy> ... though wait. not necessarily
13:54:21 <DrSyzygy> this is where data structures get hard for me.
13:54:34 <DrSyzygy> you want fast random access reading, removal and insertion.
13:54:39 <hpaste> vhd pasted “Shogi Types” at http://hpaste.org/66669
13:54:47 <vhd> these are my types
13:55:05 <vhd> I need to manipulate the Board type everytime a piece is moved
13:55:59 <vhd> before I had all the board as one list, so it was pretty simple
13:56:14 <vhd> but slow
13:58:10 * hackagebot options 0.1.1 - Parsing command-line options  http://hackage.haskell.org/package/options-0.1.1 (JohnMillikin)
13:58:18 <qnikst> I'd use (Mutable?) Vector but I'm not very experienced
13:58:39 <vhd> neither am I, and I never heard of vectors before
14:01:57 <qnikst> try them, they are very effective :) at least you'll know what a beast are they
14:01:59 <elliott> vhd: Try having all the board in one Seq.
14:02:04 <elliott> Or one IntMap (IntMap a).
14:02:13 <elliott> Vectors are a bad idea; you'll copy on every modification.
14:02:27 <vhd> one sequence?
14:02:29 <qnikst> unless they are mutable
14:02:52 <hiptobecubic> doesn't ghc secretly mutate them behind your back?
14:03:00 <vhd> thats what I had before, but I thought having smaller arrays for p1, p2 would speed up, though it seems like more hassle now
14:03:19 <vhd> or do you mean something else whith Seq.
14:03:24 <vhd> with*
14:03:25 <zzo38> Is this proper algorithm for drawing a filled triangle?   http://sprunge.us/XEKK   (It does work; I just want to know if you think is best or not; since I made up this algorithm myself because I don't know any other ones)   And how to make draw arbitrary polygons? Possibly to split polygon into triangles?
14:03:34 <elliott> vhd: Lists are not arrays.
14:03:37 <elliott> I mean Seq from Data.Sequence.
14:03:39 <elliott> It's a finger tree.
14:03:44 <elliott> (It's not a list /or/ an array.)
14:03:47 <vhd> ah ok, ill have a look at it.
14:04:02 <vhd> yeah sorry poor choice of wording on my half
14:04:18 <elliott> But isn't the board two dimensional?
14:04:27 <vhd> can do it that way
14:04:34 <elliott> In which case (Map (Int,Int) a) or (IntMap (IntMap a)) might be more convenient.
14:04:38 <elliott> Or (Seq (Seq a)), even.
14:04:42 <vhd> but im choosing to store only pieces and locations
14:04:44 <hpaste> keep_learning pasted “list laziness” at http://hpaste.org/66670
14:05:16 <qnikst> 2d can be translated to 1d, by simple rules
14:05:20 <zzo38> I posted two different questions already today. Does nobody know answer?
14:05:53 <zzo38> qnikst: Yes, and I have made a chess variant like that.
14:06:18 <qnikst> and I think \(a,b) -> a*n+b will be more effective then 2d variants
14:06:39 <elliott> More effective how?
14:06:54 <zzo38> qnikst: Yes I would think of so. (For Shogi, you should have n=9)
14:06:57 <elliott> Seq (Seq a) has the advantage that it's quicker to access whichever axis you make major in the middle.
14:07:12 <zzo38> elliott: O, I didn't know that.
14:07:57 <qnikst> elliott: it's memory from mutable world
14:07:58 <qnikst> =)
14:08:01 <hpaste> keep_learning annotated “list laziness” with “list laziness (annotation)” at http://hpaste.org/66670#a66671
14:08:18 <keep_learning> Hello all
14:08:27 <elliott> For vectors it's probably true.
14:08:29 <zzo38> And, Seq is also a monad which mean you could use join with it too, if it becomes necessary to do so
14:08:51 <keep_learning> I have written a algorithm using lists but its taking too time in GC
14:09:01 <pcapriotti> does anyone else have problems with haskell's ftplugin in vim? mine (the default) doesn't get run and I don't understand why. I think it used to work before, not sure what changed...
14:09:11 <t7> anyone in here working on nixos?
14:09:20 <keep_learning> Could some one please tell me how to make these two statements strict
14:09:22 <keep_learning> http://hpaste.org/66670
14:11:48 <keep_learning> Any one please
14:14:32 <elliott> t7: #nixos
14:18:11 * hackagebot hs-logo 0.5 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.5 (DeepakJois)
14:19:48 <hpaste> timthelion pasted “Is this possible without an preformUnsafeIO?” at http://hpaste.org/66672
14:19:56 <stepcut> I think a purely functional logo like language/environment would be cool
14:19:57 <hiptobecubic> keep_learning, i'm no wizard, but last time i came in here with bang patterns flying around and trying to use deepseq, it turned out my program actually performed better if i just left it maximally lazy
14:20:12 <stepcut>  though even cool would be if the turtle could be an actual robot that you control
14:20:17 <timthelion> Hello, can anyone give me an idea about how to write the "updateScrwin" function without using preformUnsafeIO?
14:20:25 <timthelion> Is it possible?
14:20:28 <hiptobecubic> keep_learning, not that you will have the same situation, but food for thought.
14:20:46 <elliott> Hugs? Anyone used hugs? Anyone?
14:20:51 <elliott> timthelion: it's unsafeperformIO
14:21:01 <keep_learning> hiptobecubic, I tried both way , with and without deepseq
14:21:02 * stepcut hugs elliott
14:21:02 <timthelion> elliott: thanks, but you know what I mean :)
14:21:07 <elliott> *Perform
14:21:11 <elliott> stepcut: :(
14:21:14 <keep_learning> hiptobecubic, and there is no improvement
14:21:17 <elliott> timthelion:     updateScrwin :: ScrolledWindow -> IO ScrolledWindow
14:21:22 <elliott> timthelion: Add "do" after the =.
14:21:37 <elliott> And change the type of the MVar appropriatel.
14:21:37 <timthelion> elliott: that can't be... I cannot have that function return an IO.
14:21:38 <elliott> *appropriately.
14:21:53 <elliott> timthelion: Tough. If you could turn (a -> IO b) into IO (a -> b), you could have getLine :: IO (String -> ()).
14:21:56 <elliott> And the function inside would be impure.
14:21:57 * stepcut ghcis elliott
14:22:03 <elliott> You have to change your design.
14:22:16 <stepcut> elliott: I used hugs many years ago
14:22:24 <elliott> stepcut: with Cabal, by any chance?
14:22:26 <stepcut> elliott: like 2003 or something
14:23:30 <timthelion> elliott: You see what I'm doing, right?  I'm passing the function through the mvar in order to get(and set) the value of scrwin.
14:23:52 <elliott> I don't understand what you're trying to do. But you cannot put an action that does IO inside that MVar, full stop.
14:25:00 <stepcut> elliott: alas, not with Cabal
14:25:07 <timthelion> elliott: I think you're right :(  back to the drawing board.
14:26:16 <elliott> stepcut: to be honest, i'm not sure cabal even works with hugs any more...
14:27:29 <stepcut> elliott: yeah.. I'm think I am ok with that. Now that ARM suppport for GHC and JHC is on the upswing, hugs is not very interesting
14:27:45 <hpaste> keep_learning annotated “list laziness” with “list laziness (annotation)” at http://hpaste.org/66670#a66673
14:28:00 <elliott> stepcut: I have a very specific reason to care about Hugs :)
14:28:09 <elliott> (one which does not apply to jhc or UHC)
14:28:28 <stepcut> elliott: I'm sure.. and a little surprised  :)
14:28:29 <heatsink> keep_learning, probably should write your own merge function instead of using mergeWith
14:28:37 <heatsink> *unionsWith
14:28:40 <heatsink> @src unionsWith
14:28:41 <lambdabot> Source not found. You type like i drive.
14:28:55 <elliott> stepcut: it's not a very *practical* reason
14:28:57 <elliott> but it is a reason
14:31:08 <keep_learning> heatsink, So its unionsWIth which is making the whole code performing so much GC time ?
14:31:32 <stepcut> elliott: :)
14:32:04 <heatsink> I don't know
14:32:23 <heatsink> However, it is clear that unionsWith is creating a new IntMap Double
14:32:27 <heatsink> and then toList turns it into a list
14:32:38 <heatsink> so the map will be garbage collected
14:32:53 <elliott> heatsink: (only once the whole list is forced)
14:32:54 <heatsink> Also, I think (+) is executed lazily, so it builds thunks
14:34:28 <heatsink> You should probably not use IntMap (IntMap Double) as your input type
14:34:57 <heatsink> It depends on what the algorithm is supposed to do
14:37:01 <keep_learning> heatsink,  Should I change the representation ?  This is the best data structure for the given algorithm
14:38:35 <heatsink> If the algorithm is multiplying sparse matrices together, I think CRS for the first matrix and CCS for the second (with sorted elements in each row/column) will be faster
14:38:48 <heatsink> Because then each dot product requires no memory allocation
14:40:29 <keep_learning> heatsink, yes its for multiplying two hyper sparse matrices ( nnz is very much less than dimension of matrix )
14:40:56 <keep_learning> heatsink, so CRS/CCS is bit memory consuming
14:41:27 <keep_learning> heatsink, I am storing only non zero elements of matrix thats why I chose this
14:41:48 <koninkje> ugh. hackage is down again?
14:41:51 <timthelion> is hackage down?
14:42:00 <timthelion> koninkje: hehe,
14:42:04 <timthelion> same time...
14:42:20 <heatsink> What fraction of rows is empty?
14:42:50 <lelf> Is there hackage mirrors?
14:43:19 <koninkje> there was http://hackage2.uptoisomorphism.net:8080/ but I don't think it's been updated recently
14:43:39 <heatsink> That is the best synonym for "mirror"
14:44:08 <keep_learning> heatsink, number of non zero elements are asymptotically zero wrt dimension of matrix
14:44:26 <heatsink> That doesn't answer my question
14:44:29 <elliott> koninkje: there's
14:44:31 <elliott> hackage.factisresearch.com
14:44:38 <elliott> which is full and updated daily
14:44:41 <elliott> and also runs on hackage 2
14:44:46 <elliott> that's the "official" hackage 2 dev instance
14:45:01 <keep_learning> heatsink, more than 50% are empty row/col
14:45:47 <keep_learning> in sparse matrix we assume nnz  is O(n)
14:45:48 <heatsink> Okay
14:45:56 <keep_learning> while this is not holding here
14:46:15 <koninkje> elliott: thanks. I thought there was another one, just couldn't remember its name
14:48:48 <vyom> is hackage down?
14:48:50 <Heffalump> is hackage having problems?
14:48:52 <Heffalump> doh :-)
14:48:58 <heatsink> You want to compute smm xs ys such that smm xs ys ! (x, y) = sum (\z -> xs!(y, z) * ys!(z, x))
14:49:02 <heatsink> ze system is down
14:49:04 <vyom> that was some timing!
14:49:59 <koninkje> too bad hackage.factisresearch.com doesn't do Haddock
14:50:02 <heatsink> So you should focus on making that inner loop efficient
14:50:05 <dmwit> gspr: To be fair, my brain *did* think of it long ago, and I even typed it long ago.
14:50:07 <koninkje> I was hoping to see what was new in mtl 2.1
14:51:30 <heatsink> Actually, is there any correlation between the distributions in the two input matrices?
14:52:05 <dmwit> 15:03 < dmwit> gspr: Yes: takeTMVar foo <|> takeTMVar bar
14:52:17 <keep_learning> heatsink, I am not sure about this but for testing we take two random matrices
14:53:01 <dmwit> I also proposed an MVar version.
14:54:07 <keep_learning> heatsink, Will this library will help ( http://www.johantibell.com/files/containers/Data-IntMap-Strict.html )
14:54:18 <keep_learning> heatsink, no released yet
14:54:29 <timthelion> dcoutts: are you here?
14:54:41 <keep_learning> heatsink, not*
14:55:02 <heatsink> Using strict IntMap wil make unionsWith (+) and map (* val) faster
14:55:15 <Heffalump> vyom: looks like the machine is down, I'm not sure anyone can do anything about it until someone at Galois pokes it
14:55:50 <keep_learning> heatsink, is there no way to make strict now ?
14:56:05 <heatsink> If you're using random, nearly empty matrices, then the majority of your matrix data is not used
14:56:24 <heatsink> Which means that probably the majority of your execution time is creating the inputs
14:56:53 <keep_learning> heatsink, yes but when I am multiplying two same files then its creating hugh GC time
14:57:30 <keep_learning> heatsink, I just wanted to reduce the GC time
14:57:42 <heatsink> Do you force the inputs to be evaluated before sparseMult, and touch the inputs after sparseMult?
14:58:56 <keep_learning> heatsink, Yes , I am forcing them before sending to sparseMult  ( I used deepseq in Main )
15:00:14 <keep_learning> heatsink,Should I post the whole code
15:00:51 <heatsink> Well, I think the first thing to try is rewriting the dot product operation with explicit indexing
15:01:34 <t7> brb in 5 hours building mercury compiler
15:01:39 <heatsink> I just noticed, that sparseMult is creating the IntMaps
15:01:57 <koninkje> @seen edwardk
15:01:57 <lambdabot> Unknown command, try @list
15:04:06 <ChristianS> preflex: seen edwardk
15:04:06 <preflex>  edwardk was last seen on #haskell 14 hours, 29 minutes and 40 seconds ago, saying: hrmm, nope thats not it
15:04:29 <keep_learning> heatsink, I am creating IntMap from list of SpMat
15:04:31 <heatsink> keep_learning, change sparseMult so that it returns (xs', ys', ret) and see if the GC time in sparseMult
15:04:37 <heatsink> decresases
15:04:54 <heatsink> That will show if the GC time is because you are using IntMap
15:05:28 <keep_learning> heatsink, Thank you for your valuable comments and time :)
15:05:48 <BrianHV> > array (0,5) []
15:05:49 <lambdabot>   array (0,5) [(0,*Exception: (Array.!): undefined array element
15:06:04 <BrianHV> oh
15:06:50 <BrianHV> there's no way to tell if an array element is undefined, is there...
15:07:02 <keep_learning> heatsink, Are we not currently returning the ret
15:07:25 <keep_learning> heatsink, and ret is calling all the inner functions
15:09:11 <heatsink> The current version of sparseMult returns 'ret'
15:09:24 <heatsink> I don't understand what you are asking about
15:10:29 <keep_learning> heatsink, you told me to return "change sparseMult so that it returns (xs', ys', ret) and see if the GC time in sparseMult decrease"
15:10:42 <heatsink> yes
15:10:51 <keep_learning> heatsink, so currently we are already returning ret from sparseMult
15:11:15 <keep_learning> heatsink, so how the ( xs' , ys' ) return will help to decrease the GC time
15:11:38 <elliott> koninkje: i think edwardk is resting after 10 reflection releases in one-and-a-half days :P
15:12:31 <heatsink> I suppose it won't
15:12:56 <keep_learning> heatsink, yes
15:13:45 <heatsink> What object types are on the heap?  Use the -hy flag
15:13:53 <heatsink> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
15:14:21 <heatsink> It's probably some combination of function closures and IntMap nodes
15:14:25 <heatsink> and list nodes
15:15:32 <keep_learning> heatsink, Thanks
15:15:36 <heatsink> I think it's -hd actually
15:19:35 <koninkje> elliott: I was just trying to guage how long til he's back online is all
15:19:45 <mekeor> hackage is down
15:19:48 * elliott was kidding
15:19:53 <elliott> mekeor: hackage.factisresearch.com
15:20:10 <mekeor> elliott: mirror?
15:20:25 <elliott> yes
15:24:39 <heatsink> .
15:25:15 <keep_learning> heatsink, its running
15:27:34 <heatsink> ikeg, any relation to oleg?
15:27:47 <mekeor> elliott: where's the f**king base on hackage.factisresearch.com ?   i can't find it...
15:28:00 <gspr> I've been wondering... how good and/or useful should something be before one throws it up on Hackage?
15:28:01 <mekeor> i mean, the prelude.
15:28:14 <mekeor> elliott: specifically, i'm looking for Control.Monad.
15:28:18 <heatsink> mekeor, if you're looking for prelude docs, they're on GHC website
15:28:22 <gspr> Is it anything-goes, or should one be careful?
15:28:28 <mekeor> heatsink: link, pls
15:28:32 <glguy> carefuller than that
15:28:39 <heatsink> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:28:42 <ikeg> heatsink: ? I remember that I talked oleg-san at Japan Sendai FLOPS workshop
15:28:50 <elliott> mekeor: http://hackage.factisresearch.com/package/base
15:28:53 <mekeor> heatsink: neat, thanks
15:28:55 <elliott> just append /package/BLAH
15:29:01 <elliott> it doesn't have docs though
15:29:11 <elliott> gspr: careful, but not too careful
15:29:12 <mekeor> lol
15:29:26 * heatsink thought maybe "ikeg" was misspelled "oleg".  The keys are nearby on an ASCII keyboard.
15:29:35 <elliott> gspr: if it has no conceivable use to people other than you, don't put it up; if it's really really messy/in flux, don't put it up yet
15:29:38 <stepcut> elliott: possibly because base is not actually a buildabale cabal package
15:29:51 <elliott> but if you can imagine someone else using it and it's "reasonably" stable (i.e. at least pre-alpha), then go for it
15:30:12 <koninkje> gspr: In general, it should (a) be useful for someone else, and (b) something you'll actually maintain
15:30:18 <elliott> stepcut: no
15:30:21 <gspr> elliott: I'd say it's not messy, although possibly not very good, and could be useful to a tiny few people.
15:30:21 <elliott> stepcut: that server just doesn't do docs
15:30:28 <gspr> Alright, I get the picture I think.
15:30:28 <stepcut> ah
15:30:30 <kallisti> how do I escape haddock markup?
15:30:32 <elliott> stepcut: (btw, are you sure you can't build base? haddock uses the ghc api)
15:30:39 <elliott> gspr: there aren't any quality controls or anything
15:30:39 <heatsink> kallisti, backslash
15:30:45 <kallisti> also the "hyperlink to names out of scope" isn't really working.
15:30:57 <koninkje> kallisti: Depending on what you mean, backslash
15:30:58 <keep_learning> heatsink, 1600M is SpMat 800M is :
15:31:00 <elliott> gspr: just ask "am i adding crap to hackage?", if the answer is no, upload away :p
15:31:13 <kallisti> elliott: define crap.
15:31:14 <koninkje> kallisti: e.g., -- | This function prints \"hello world\"
15:31:19 <keep_learning> heatsink, These two are main elements in graph
15:31:19 <gspr> elliott: I've essentially just wrapped select(2) so that one can treat it as a TMVar, and it was useful to one person (me), so I guess that's a no :p
15:31:33 <kallisti> koninkje: yep
15:31:41 <ikeg> heatsink: well, what's do you mean? :)
15:31:42 <heatsink> Hmm, okay
15:31:43 <elliott> gspr: that sounds useful enough for hackage -- however, why use select(2)?
15:31:57 <elliott> gspr: if you just use forkIO and regular IO, GHC will use select under the hood (or kqueue/epoll if you use the -threaded runtime)
15:31:58 <monochrom> because epoll is not enough :)
15:32:03 <gspr> elliott: Because I was interfacing with some things where that was my only option :)
15:32:04 <heatsink> keep_learning, what is the maximum matrix dimension?
15:32:05 <kallisti> gspr: there are plenty of packages that do equally small, useful things.
15:32:07 <elliott> and haskell uses lightweight threads
15:32:09 <elliott> gspr: ah, ok then
15:32:13 <elliott> gspr: sure, put it up
15:32:21 <gspr> OK
15:32:28 <kallisti> gspr: for example there's literally a package that serves no other purpose except to provide a typeclass for types with a default value.
15:32:32 <elliott> gspr: you might want to follow the package versioning policy
15:32:33 <keep_learning> heatsink, 10^6 X 10^6
15:32:34 <heatsink> nm ikeg
15:32:43 <koninkje> Small doesn't mean non-useful. We believe in small packages in Haskell
15:32:47 <stepcut> elliott: dcoutts knows the real answer.. but in my haddock builder I have to start with copies of base, integer-gmp and (????) because they are not really built as .cabal packages (even though they have .cabal files)
15:33:03 <elliott> gspr: and run with -Wall (and add some haddock docs etc.) to polish it up... but yep, sounds hackage-quality to me
15:33:18 <elliott> stepcut: fair enough, but if haddock can doc them then the GHC API can parse them at least
15:33:25 <gspr> The reason I asked was mostly due to namespace pollution. It seems it can get annoying when stupid small packages take up very nice names which other, better packages might fill later
15:33:47 <gspr> elliott: I'll do those things. Thanks, and thanks also for all the help tonight in general
15:33:53 <heatsink> keep_learning, because your matrix data is that big, you can reduce GC time by using UArray
15:33:53 <koninkje> Well, be sure to give it a specific enough name :)
15:33:55 <ikeg> heatsink: what does 'nm' stand for? (i'm a newbie on IRC)
15:33:59 <elliott> Control.Concurrent.STM.Select? Foreign.STM.Select?
15:34:01 <kallisti> module system makes this (mostly) a non-issue, though it does become more complicated when packages introduce new names to their API that conflict with other packages.
15:34:06 <elliott> there are lots of possible package names that seem unlikely to step on things :P
15:34:10 <koninkje> that way you won't be taking a name from anyone else (unless they're doing the same thing!)
15:34:13 <kallisti> the solution there is to use explicit import lists.
15:34:17 <elliott> gspr: but btw cabal can handle that
15:34:20 <heatsink> http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.4.0.0/Data-Array-Unboxed.html
15:34:24 <kallisti> oh, module names. nevermind.
15:34:28 <gspr> elliott: Ah, didn't know
15:34:34 <elliott> gspr: if someone makes a package using the same module name and everyone switches to it, then it's fine
15:34:41 <heatsink> ikeg: "nevermind"
15:34:44 <elliott> gets tricky when people use both
15:34:50 <gspr> right
15:34:57 <elliott> *cough* mtl vs. monads-tf *cough8
15:35:06 <elliott> but it's still ok if your dependencies depend on them both
15:35:10 <keep_learning> heatsink, Thanks
15:35:11 <elliott> as long as a package doesn't directly depend on both
15:35:16 <elliott> (without using the PackageImports extension at least)
15:35:27 <kallisti> gspr: there's an extension that allows you to qualify modules by the package they reside in.
15:35:32 <kallisti> yes, that.
15:36:12 <heatsink> keep_learning, data SpMat = SpMat !(UArray Int Int) !(UArray Int Int) !(UArray Int Double)
15:36:30 <heatsink> It is somewhat inconvenient to use arrays, though
15:36:41 <heatsink> You will have to modify the algorithm a lot
15:36:54 <elliott> gspr: additionally, if you upload the package and later decide it's a bad idea, you can get it marked deprecated
15:37:04 <elliott> which marks it as such on the package page and removes it from the list
15:37:10 <keep_learning> heatsink, Yes but then I will have performance
15:37:58 <kallisti> I could probably upload my code to Hackage right now, but I want to wait until I have absolutely everything documented.
15:38:05 <kallisti> right now it's about 50%
15:39:46 <heatsink> keep_learning, the change should make the program faster because the garbage collector doesn't scan or copy unboxed arrays of Int and Double.
15:40:31 <keep_learning> heatsink, IntMap ( UArray Int ( Int , Double ) )
15:40:49 <keep_learning> heatsink, What do you think about this
15:41:24 <heatsink> What would be the average array size?
15:41:43 <heatsink> average number of nonzeros per non-empty row
15:41:47 <keep_learning> heatsink, It will be small
15:41:57 <keep_learning> because elements are very less
15:42:00 <mekeor> which fixity does function application have?
15:42:05 <keep_learning> almost 50% are empty
15:42:57 <hpaste> thinker341 pasted “function overlapping” at http://hpaste.org/66676
15:43:02 <keep_learning> heatsink, I think it won't be more than 100 in case of ( 10^6 X 10^6 )
15:43:41 <heatsink> You currently have 800M of list data on the heap
15:43:53 <thinker341> Is there any feature in Haskell , that would avoid this from happening ; http://hpaste.org/66676
15:44:04 <mekeor> 9 ?
15:44:13 <dmwit> thinker341: Yes, promote your pattern match up a level. =)
15:44:18 <heatsink> If each array is small, then using IntMap will transform that into at least 800M of other data
15:44:24 <elliott> thinker341: what dmwit said, write one line for each case
15:44:36 <elliott> f 0 = 1; f 1 = 6; f 2 = 2; f _ = -1
15:44:44 <elliott> then adding f 1 = 5 will give a warning (or an error? not sure)
15:44:48 <thinker341> Is it a good practise ?
15:44:55 <heatsink> To reduce heap use, you have to combine many sparse matrix elements into a single array
15:45:03 <elliott> thinker341: yes, "f x = case x of ..." is rarely good practice
15:45:16 <kallisti> elliott: I do that. But I'm a bad person. :)
15:45:24 <mekeor> which fixity does function application have? 9?
15:45:27 <kallisti> because I don't like the redundant function names.
15:45:33 <elliott> kallisti: what?
15:45:40 <elliott> oh
15:45:42 <kallisti> mekeor: just a little higher. 10
15:45:43 <elliott> that's silly
15:45:47 <elliott> mekeor: 10
15:45:57 <elliott> mekeor: it binds tighter than any operator
15:46:00 <heatsink> elliott, what if you want to add a "where" clause later?
15:46:05 <thinker341> Thanks elliott and dmwit
15:46:10 <kallisti> elliott: it saves me typing for large pattern matches, so I think it's worth it.
15:46:17 <mekeor> kallisti, elliott: ok, thanks
15:46:18 <keep_learning> heatsink, Yes , great :)
15:46:24 <elliott> heatsink: that's why i said rarely
15:47:24 <kallisti> I can only tolerate about 2-3 equations max, for function definitions..
15:47:31 <kallisti> when writing code.
15:47:59 <kallisti> at that point I break out case.
15:49:02 <elliott> C-k C-y
15:49:14 <ikeg> Good morning, forks. I come up against a dilemma. It is difficult to hold a hackathon for developing Yesod Web Application.
15:49:25 <ikeg> There is a seating capacity. Yesod becomes popular in Japan. There are not only Haskell programmers but also programmers who has their own skill in other languages (for example, Clojure/Erlang/OCaml, Perl5/Python/Ruby, etc.)
15:49:36 <ikeg> The seating capacity is critical. I'm eager to succeed at the meeting. Any idea?
15:50:17 <ikeg> nm between l and r. it's common japanese-english
15:50:29 <kallisti> elliott: that counts as keystrokes. :P
15:51:31 <elliott> meh
15:53:11 * heatsink has never attended a hackathon before
15:53:13 * kallisti might have a slightly non-standard layout style.
15:53:29 <kallisti> but I think there's a lot of variation in Haskell layout styles anyway.
15:54:14 <Saizan> ikeg: maybe you could ask the organizers of this haskell hackathon in japan in 2011 http://www.haskell.org/haskellwiki/HakkuTaikai
15:54:28 <kallisti> zzo Haskell looks a lot different from Oleg Haskell, which looks a lot different from GHC-core Haskell.
15:54:50 <elliott> There is not that much variation nowadays.
15:55:07 <elliott> GHC is ancient, Oleg and zzo38 are outliers.
15:56:35 <BrianHV> > [10..0]
15:56:35 <lambdabot>   []
15:56:45 <kallisti> > [10, 9 .. 0]
15:56:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:56:49 <BrianHV> thanks
15:56:58 <kallisti> for whatever reason you have to give it a hint.
15:56:59 <heatsink> > [10,11..0]
15:57:00 <lambdabot>   []
15:57:19 <elliott> for consistency
15:57:26 <BrianHV> > [10, 9, .. 10]
15:57:26 <lambdabot>   <no location info>: parse error on input `..'
15:57:31 <BrianHV> > [10, 9 .. 10]
15:57:32 <lambdabot>   [10]
15:57:33 <heatsink> > [10,11..0] `mod` 12 == [10, 11, 0]
15:57:33 <lambdabot>   No instance for (GHC.Real.Integral [t])
15:57:34 <lambdabot>    arising from a use of `GHC.Real....
15:57:34 <arnoldas> how do i write this function in haskell: f(1) = 1, f(2) = 1, f(3) = 1, f(x+3) = f(x)+f(x+1)+f(x+2)
15:57:34 <BrianHV> good
15:57:37 <arnoldas> ?
15:58:05 <elliott> f 1 = 1; f 2 = 1; f 3 = 1; f x = f (x-3) + f (x-2) + f (x-1)
15:58:07 <elliott> or
15:58:09 <elliott> f n
15:58:11 <byorgey> arnoldas: in fact, if you just turn the commas into newlines, what you wrote will work.
15:58:12 <elliott>   | n <= 3 = 1
15:58:19 <elliott>   | otherwise = f (x-1) + f (x-2) + f (x-1)
15:58:24 <elliott> erm s/n/x/g
15:58:34 <elliott> byorgey: erm, it will?
15:58:37 <elliott> n+k patterns are gone
15:58:40 <byorgey> oh, right
15:58:51 <kallisti> :_(
15:58:55 <elliott> i think ghc turned them off by default in 7.2 or 7.4? maybe it didn't
15:58:58 <heatsink> x+k patterxs are goxe
15:59:16 <elliott> :D
15:59:25 <elliott> xot fair!
15:59:34 <kallisti> ixdeed
16:01:28 <cheater_> kallisti: http://www.youtube.com/watch?v=XtPgr94VYA4
16:03:19 <BrianHV> is there a function like   succThatLoops :: (Bounded a, Enum a) => a -> a
16:03:31 <dmwit> no =/
16:03:44 <dmwit> You could consider writing one yourself, though.
16:03:50 <BrianHV> I might just do that
16:03:54 <dmwit> succLoop x | x == maxBound = minBound | otherwise = succ x
16:03:56 <elliott> BrianHV: succThatLoops x | x == maxBound = minBound | otherwise = succ x
16:03:58 <hpc> you need Eq in there too
16:04:01 * elliott hi5 dmwit
16:04:08 <elliott> hpc: doesn't Enum imply Eq?
16:04:09 <dmwit> me o/
16:04:13 <elliott> i believe it does
16:04:13 <dmwit> eh
16:04:17 <elliott> the Eq got moved to Enum iirc
16:04:18 <elliott> from Num
16:04:30 <BrianHV> I know it's not hard to write. but I've written a lot of functions that aren't hard to write that later turned out to be in the library somewhere.
16:04:51 <koninkje> nope. Enum doesn't require Eq
16:04:54 <hpc> hackage seems to be down
16:05:09 <heatsink> Hackage status: http://www.youtube.com/watch?v=ILVfzx5Pe-A
16:05:15 <hpc> yeah, hoogle says there's no constraints on Enum or Bounded
16:05:36 <hpc> so Enum, Bounded, Eq
16:06:14 <elliott> annoyin
16:06:15 <elliott> g
16:06:22 <elliott> oh maybe it's Real the Ord got moved to
16:06:24 <elliott> yeah i think so
16:06:26 <koninkje> We do have Ix a <= Ord a <= Eq a; but Enum and Bounded stand alone
16:06:31 <elliott> @src Real
16:06:31 <lambdabot> class  (Num a, Ord a) => Real a  where
16:06:31 <lambdabot>     toRational      ::  a -> Rational
16:06:41 <elliott> wait, someone updated @src for 7.4?
16:06:54 <koninkje> Integral requires Enum, IIRC
16:07:31 <koninkje> Besides, there's no need for Eq on Enum; just use fromEnum and then use Eq Int
16:08:26 <koninkje> I don't recall if the contract for Enum requires that you can get Ord that way too; but Eq is clearly free
16:09:28 <elliott> koninkje: that's risky, I think
16:09:33 <elliott> what if maxBound exceeds Int maxBound?
16:09:47 <elliott> consider IntWithNineThousandTrillionBits
16:09:58 <elliott> Bounded, Enum, but partial fromEnum
16:10:02 <mekeor> > (maxBound :: Int) + 1
16:10:03 <lambdabot>   -9223372036854775808
16:10:34 <tsuraan__> so I have a string with unicode chars (e.g. a char with the numeric value 24195).  how can I convert that into a utf-8 string?  having trouble with hackage being down :(
16:10:39 <koninkje> Is that permissible? (Bounded, Enum, but partial fromEnum)
16:10:44 <timthelion> lordy, using threads, and gtk2hs I've managed to make a program who's behavior is entirely non deterministic.
16:10:48 <heatsink> There's a utf8-string package that does that I think
16:11:02 * koninkje dislikes partial functions for the Prelude type classes
16:11:18 <elliott> koninkje: Integer has partial fromEnum.
16:11:23 <elliott> Bounded says nothing about invalidating that.
16:11:24 * koninkje ...especially the ones the Report mandates partiality for
16:11:32 <tsuraan__> heatsink: thanks for the pointer
16:11:40 <elliott> koninkje: Don't hate the player (instances), hate the game (the awful typeclasses).
16:11:58 * kallisti has some code that makes 2-element product types of Enums into Enums
16:12:03 <koninkje> that's what I said :)
16:12:05 <kallisti> maybe if I fixed it up I could put it on Hackage.
16:12:25 <koninkje> requiring that succ and pred throw exceptions if the underlying type is bounded is a nightmare
16:12:30 <BrianHV> Either isn't a monad?...
16:12:37 <elliott> BrianHV: Yes, it is.
16:12:38 <koninkje> kinda defeats the whole point of pred and succ, ne?
16:12:40 <elliott> Import Control.Monad.Instances.
16:12:50 <elliott> koninkje: Yes, I think succ and pred should be legislated to be cyclic on maxBound/minBound, if anything.
16:12:54 <BrianHV> I see.
16:13:00 <elliott> koninkje: But I think it's for data DaysOfWeek = Mon | ... | Sat.
16:13:05 <elliott> koninkje: succ Sat / pred Mon are arguably errors.
16:13:20 <koninkje> I'd prefer to distinguish between bounded and unbounded enumerations
16:13:23 <elliott> But the cyclic behaviour has meaning - "what will the day be, if it is the day after Sunday?" - so meh.
16:13:30 <tsuraan__> heatsink: that's perfect.  thanks!
16:13:36 <kallisti> I wonder how I would generalize the code to arbitrary product types.
16:13:43 <koninkje> Cyclic behavior could be had from having an "unbounded" albeit finite instance
16:13:48 <elliott> kallisti: How do you do toEnum/fromEnum?
16:14:05 <elliott> Don't put orphan instances in packages of their own on Hackage. I'll cry.
16:14:21 <koninkje> unbounded doesn't mean infinite; nor does infinite mean unbounded
16:14:41 <mekeor> why is "when :: Monad m => Bool -> m () -> m ()" but not "when :: Monad m => Bool -> m a -> m ()" ?  i mean like, "when condition function = if condition then function >> return () else return ()"...
16:14:58 * dmwit shrugs
16:14:59 <Peaker> is hackage down again?
16:14:59 <elliott> mekeor: why mix concerns?
16:15:04 <elliott> use Control.Monad.void
16:15:09 <elliott> Peaker: yes; hackage.factisresearch.com
16:15:16 <mekeor> :t void
16:15:17 <lambdabot> Not in scope: `void'
16:15:27 <koninkje> mekeor: it simplifies concerns. It makes you be explicit about discarding the output
16:15:38 <Peaker> mekeor: I hate when functions discard values in addition to their job
16:15:51 <koninkje> Though it'd be valid to do, when :: Monad m => Bool -> m a -> m (Maybe a)
16:16:02 <koninkje> but that's a bit different
16:16:06 <mekeor> koninkje: ah, ok.
16:16:34 <kallisti> elliott: like this sprunge.us/LfCO?haskell  it does however make assumptions about the Enum instances
16:16:43 <kallisti> IIRC, they have to start at 0
16:16:48 <Peaker> elliott: thanks
16:17:00 <elliott> > fromEnum (-1)
16:17:01 <lambdabot>   -1
16:17:08 <elliott> > fromEnum minBound :: Int
16:17:09 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:17:09 <lambdabot>    `GHC.Enum.Enum a'
16:17:09 <lambdabot>      a...
16:17:11 <elliott> wtf
16:17:15 <elliott> oh
16:17:17 <elliott> > fromEnum (minBound :: Int)
16:17:18 <lambdabot>   -9223372036854775808
16:17:21 <kallisti> but you could easily modify it to work with any consecutive range of integers.
16:17:43 <kallisti> or even Enums that skip a number of integers between each integer.
16:17:48 <kallisti> just add some more typeclass variables
16:17:55 * koninkje wonders that there isn't a Maybe version of when/unless
16:18:37 <elliott> koninkje: join (m <$ boolToMaybe b)
16:18:41 <elliott> where boolToMaybe :: Bool -> Maybe (0
16:18:42 <elliott> )
16:18:47 <elliott> @hoogle Bool -> Maybe ()
16:18:47 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
16:18:47 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
16:18:47 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
16:18:50 <elliott> ah
16:18:53 <koninkje> Well sure, it's easy enough to implement
16:19:08 <elliott> join . (<$ guard b) $ do ... -- ok, it's not very pretty
16:19:19 <heatsink> quit
16:19:23 <koninkje> I'm just surprised that it hasn't been found useful enough to be included in common libraries yet
16:19:39 * elliott doesn't see an immediate use-case
16:19:51 --- mode: ChanServ set +o glguy
16:20:02 --- mode: glguy set -b damn3d!*@*
16:20:03 <koninkje> well I haven't needed it yet either...
16:20:11 <koninkje> though I could imagine it being useful enough
16:20:25 <mikeplus32> is there a getArgs for Text?
16:20:40 <elliott> no
16:20:45 <mikeplus32> ok
16:20:49 <elliott> command-line arguments aren't very long, though :)
16:21:08 <mikeplus32> there is System.Posix.Env.ByteString at least
16:21:32 <kallisti> elliott: I guess to support more than 2 fields I could just make an Enum instance for tuples and then use "linked tuples" to define enum instances
16:21:40 <mikeplus32> I just have a horrible burning sensation whenever I use a list of Char as a string :)
16:21:58 <kallisti> instance Enum T where toEnum (T a b c) = toEnum (a, (b,c))
16:22:06 <elliott> mikeplus32: yeah, i thought there might be something in unix for it
16:22:10 <elliott> but that's not very portable :p
16:23:27 <koninkje> kallisti: Orphan instances are no fun
16:23:32 <mietek> Hackage?
16:24:03 <elliott> mietek: .factisresearch.com
16:24:15 <elliott> kallisti: yeah, define an EnumProduct type at least
16:24:27 <kallisti> sure
16:24:34 <kallisti> I'll use an operator or something
16:24:36 <mietek> elliott: cool.  How do I tell Cabal to use it?
16:25:01 <kallisti> I was also going to use an EnumInfo class to specify characteristics of the Enum instance.
16:25:02 <elliott> mietek: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
16:25:05 <elliott> change that in ~/.cabal/config
16:26:16 <mietek> Thanks
16:26:20 <kallisti> actually I could just call it BoundedEnum
16:26:22 <kallisti> as that's what I need.
16:28:12 <kallisti> unfortunately with the Enum using Int it won't take long before a product type wraps around.
16:29:42 <timthelion> well this sucks.  My program works perfectly 40% of the time.  And SIGSEGV's 40% of the time, and the other 20% of the time it SIGABRT's...
16:29:57 <ikeg> Saizan: thanks for your advice. I will think it over carefully. Books "Art of the Event" and "Event Planning Made Easy" may help me.
16:30:27 <arnoldas> why this don't work: list = [f x| x <- [1..10]]
16:30:27 <arnoldas>     where f (x+3)
16:30:27 <arnoldas>         | x <= 3 = 1
16:30:27 <arnoldas>         | otherwise = f x + f (x+1) + f(x+2)
16:30:27 <arnoldas>     
16:30:53 <mikeplus32> a+b patterns are deprecated
16:31:23 <rwbarton> what happened to f 1
16:31:48 <rwbarton> x has to be nonnegative in the pattern (x+3)
16:31:57 <elliott> arnoldas: because you used +
16:32:01 <elliott> oh
16:32:03 <elliott> right
16:32:07 <elliott> arnoldas: do not use (x+3) as a pattern
16:32:10 <elliott> they are removed in the latest standard
16:32:13 <elliott> instead, use x as the pattern
16:32:15 <elliott> and subtract when needed
16:32:20 <rwbarton> or if you insist
16:32:24 <rwbarton> f x | x <= 3 = 1
16:32:30 <rwbarton> f (x+3) = f x + f (x+1) + f (x+2)
16:32:57 <elliott> (or put the last case first and use f _ in the second -- but **just don't use n+k patterns!**)
16:34:42 * kallisti feels that n+k patterns could be included within a more generalized pattern matching system.
16:34:53 <kallisti> but it would be a rather complex extension
16:35:04 <kallisti> because you have to enforce that one of the operands is a constant literal.
16:35:17 <kallisti> among other things.
16:35:44 <rwbarton> you can sort of emulate them with view patterns if you really want to
16:35:51 <elliott> btw, are all the old hpaste pastes lost forever?
16:36:05 <elliott> from the moonpatio days
16:37:51 <bitonic> how do I set the "portability" in a cabal fine again?
16:38:17 <bitonic> *file
16:38:32 <elliott> bitonic: isn't that a haddock thing?
16:38:44 <elliott> yes, it is
16:38:51 <elliott> see http://stackoverflow.com/questions/9012640/how-are-the-haddock-module-fields-portability-stability-and-maintainer-used
16:39:00 <bitonic> elliott: oh, right. thanks.
16:47:51 <Hexmind> a
16:48:23 <Hexmind> Sorry I have a quick question because hackage is down.  Does (_:xs) perform slicing on a List?
16:48:47 <irene-knapp> the list is inherently already sliced, it's stored as cons cells
16:49:22 <irene-knapp> so I guess the answer is yes-ish except that there's nothing to perform
16:49:56 <Hexmind> Ok, this is what I am executing:   myFunction (_:xs) = myFunction xs
16:50:02 <elliott> Hexmind: not slicing, really
16:50:09 <elliott> (x:xs) is the list with first element x and rest of list xs
16:50:10 <elliott> > 1 : [2,3,4]
16:50:11 <lambdabot>   [1,2,3,4]
16:50:17 <elliott> so that ignores the first element
16:50:33 <Hexmind> Ah okay
16:50:45 <monochrom> [1,2,3,4] is syntax sugar for 1:(2:(3:4:[]))
16:51:07 <Hexmind> I find that a lot nicer than Python slicing syntax. Thanks for the help
16:52:13 <elliott> Hexmind: it can't "slice" in the same way as python syntax
16:52:18 <elliott> it's just how the data is actually constructed
16:53:10 <Hexmind> Got it
16:54:34 <mietek> Does citeproc-0.3.4 install for anyone?
16:54:42 <mietek> citeproc-hs-0.3.4*
16:55:48 <mietek> Seems like there's some weird syntax issue related to apostrophes in identifier names
16:57:40 <elliott> those are legal! you are the second person today to have a problem with apostrophes in identifiers
16:57:44 <elliott> please paste the full error
16:57:49 <cesar_pinera> Hi. I'm just starting to learn Haskell, and I was wondering why I'm not being able to connect to hackage.haskell.com. Is it down, or am I doing something stupid?
16:58:11 <elliott> it's down
16:58:13 <elliott> sorry :(
16:58:18 <elliott> try http://hackage.factisresearch.com/
16:58:25 <elliott> you can use that to install packages if that's what you're trying too
16:58:33 <mietek> elliott: I know they are legal...
16:58:36 <cesar_pinera> Perfect! Thanks so much!
16:58:40 <elliott> mietek: yeah, i was just amazed
16:58:43 <Hexmind> cesar_pinera: Same thing happened to me! I'm learning and it's down =/
16:58:45 <elliott> since someone else had a problem with them earlier too
16:58:51 <mietek> One sec
16:59:14 <Hexmind> 99 Haskell Problems is a great place to start
16:59:16 <kanox21> hi
16:59:21 <kanox21> hi guys
16:59:24 <elliott> hello
16:59:26 <applicative> hi kanox21
16:59:26 <kanox21> somebody can help me
16:59:30 <mietek> elliott: http://hpaste.org/66684
16:59:47 <mietek> GHC 7.0.4
17:00:23 <elliott> mietek: yeah. it's compiling that haskell with gcc.
17:00:29 <elliott> i have no idea why.
17:00:48 <hpaste> Hexmind pasted “Test” at http://hpaste.org/66685
17:01:02 <Hexmind> sorry ignore that
17:01:12 <mietek> elliott: huh
17:01:30 <rapanovela> hi all
17:02:32 <kanox21> Someone can help me?
17:03:12 <elliott> mietek: hpaste the cabal file?
17:03:16 <elliott> kanox21: ask a question
17:03:19 <elliott> then the help will come
17:06:22 <kanox21> I'm new in Haskell, and i have to make a "easy project", that consist in this: You introduce a word and you are suppose to change that word. How?, if you find a vowel, you just add P+ The vowel. Example:if you have the word Hello, your new word will be Hepellopo
17:06:45 <kanox21> I was trying to make it with list but i dont have any idea, of how to check all the elements of the list, etc.
17:07:08 <kanox21> i was reading from here: http://learnyouahaskell.com
17:08:00 <monochrom> instead of thinking of "change", you should think of "get input, produce output"
17:08:43 <kanox21> Any idea?
17:09:27 <Hexmind> I'm curious what the solution would be as well.  You have to use the IO function type, then use a conditional with a vowel checking function?
17:09:30 * hackagebot enumerator 0.4.19 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.19 (JohnMillikin)
17:09:41 <monochrom> you get an input string of the form 'H':xs. what should you output? answer: 'H' is not a vowel, so you have to copy it verbatim to the output, but then you still have to go over the rest (xs)
17:09:58 <elliott> the "IO function type"?
17:10:04 <monochrom> f ('H':xs) = 'H' : f xs
17:10:19 <Hexmind> SOrry, IO monad
17:10:23 <monochrom> no IO is needed
17:10:31 <elliott> you can just use interact for this, if you really need to make a full program
17:10:33 <elliott> :t interact
17:10:33 <lambdabot> (String -> String) -> IO ()
17:10:39 <elliott> IO is a distraction here
17:11:27 <monochrom> otoh, you get an input string of the form 'e':xs. what should you do? answer: 'e' is a vowel, so you have to output "Pe", and you still have to process the rest (xs)
17:11:39 <monochrom> f ('e':xs) = "Pe" ++ f xs
17:11:50 <Hexmind> Ok interact looks perfect, saves having to compile a separate file too because GCHi only implements a subset of Haskell and it's not equatable to python or irb
17:12:30 <elliott> huh?
17:12:37 <elliott> no, ghci evaluates arbitrary haskell expressions
17:12:38 <monochrom> now these are very tailored to 'H' and 'e'. you have to generalize to other vowels and non-vowels. maybe you can't hardcode 'H' and 'e' right in the patterns.
17:12:44 <elliott> it can also do declarations, as of GHC 7.4.
17:13:12 <Hexmind> alright I'm on 7.4.1 which is good
17:13:13 <elliott> but you can do declarations of values even in ghci < 7.4: "let value = ..."
17:13:26 <elliott> (also GHCi can load full files into the REPL)
17:13:44 <Hexmind> Any way to get syntax highlighting into the terminal ghci?
17:13:50 <kanox21> wait
17:14:02 <kanox21> Lets suppose i have a list that contain this "hello"
17:14:09 <monochrom> maybe you have to do: f (x:xs) | is_vowel x = 'P' : x : f xs  | otherwise = x : f xs
17:14:15 <kanox21> I i have check the first element, then the second, then the third.
17:14:28 <monochrom> and of course I still haven't talked about what f [] should be
17:14:37 <kwos> hi guys, what's the easiests way generate test cases of the form ( x, y ) where x < y using quickcheck?
17:14:55 <elliott> Hexmind: not that i know of
17:15:12 <monochrom> no, you're thinking imperatively. when thinking functionally, you just worry one element, and let recursion worry the rest
17:16:06 <kanox21> hmmm that's the problem i really don't know how this work functionally
17:16:25 <Hexmind> thanks elliot
17:16:28 <Hexmind> elliott*
17:16:32 <kanox21> i just trying reading etc, trying to get it.
17:16:33 <applicative> kanox21: you can also map each character to a string, 'a' -> "Pa", 'N' -> "N", then concatenate... for example
17:17:31 <kanox21> Hmm let me see
17:24:04 <BrianHV> hackage is back!
17:24:11 <Hexmind> Yes!
17:24:20 <elliott> yay
17:30:44 <ikeg> phew
17:34:31 * hackagebot filesystem-enumerator 0.1.1 - Enumerator-based API for manipulating the filesystem.  http://hackage.haskell.org/package/filesystem-enumerator-0.1.1 (JohnMillikin)
17:34:33 * hackagebot chell 0.2.2 - A quiet test runner  http://hackage.haskell.org/package/chell-0.2.2 (JohnMillikin)
17:40:00 <elliott> glguy: ^ it's bad
17:40:01 <elliott> *back
17:40:13 <elliott> (the flooding client)
17:40:13 <glguy> so it is
17:40:22 <sizz> Are there any good tutorials on text processing using Haskell? I'm coming from a Perl background, where 95% of my programs simply involved processing files line-wise (removing/modifying/adding fields, changing formatting, etc.) using pattern matching.
17:40:26 <sizz> It'd be useful for me to learn if I could translate these types of programs into Haskell.
17:41:10 <andkerosine> sizz: Better to start from the ground up, surely.
17:43:05 <Cale> sizz: You might want to look into parser combinator libraries like Parsec
17:43:24 --- mode: ChanServ set +o monochrom
17:43:26 <JoeyA> I'd like to know the answer to that question, too.  Haskell makes some string tasks easy, but simple regex type stuff isn't always easy in Haskell.
17:43:42 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- this tutorial is a little bit out of date (the module names have changed), but otherwise is rather good.
17:44:03 <Cale> The answer to regex stuff is not to use regex, for the most part :)
17:44:08 --- mode: monochrom set +b *!*@unaffiliated/morpheus/x-0931003
17:44:15 --- mode: monochrom set -o monochrom
17:44:28 <monochrom> I hope it helps him too, not just us
17:45:01 <koninkje_away> lambdabot: ping
17:45:03 <Cale> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. -- jwz :)
17:45:34 <monochrom> @quote monochrom some.people
17:45:34 <lambdabot> No quotes match. You speak an infinite deal of nothing
17:45:47 <hpc> @quote some.people
17:45:47 <monochrom> @quote monochrom confront
17:45:48 <lambdabot> No quotes match. Where did you learn to type?
17:45:48 <lambdabot> <mapreduce> says: Some people just find programming with types hard, because they're still learning to program.
17:45:56 <hpc> haha
17:45:59 <monochrom> @quote monochrom faced
17:45:59 <lambdabot> No quotes match. Do you think like you type?
17:46:01 <elliott> @forget <mapreduce> Some people just find programming with types hard, because they're still learning to program.
17:46:01 <lambdabot> Done.
17:46:03 <elliott> @remember mapreduce Some people just find programming with types hard, because they're still learning to program.
17:46:03 <lambdabot> Done.
17:46:21 <monochrom> @quote monochrom facing
17:46:21 <lambdabot> No quotes match. Are you on drugs?
17:46:29 <monochrom> @quote monochrom
17:46:30 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
17:46:52 <BMeph> @quote monochrom.facing
17:46:52 <lambdabot> No quotes match. The more you drive -- the dumber you get.
17:47:06 <Cale> @quote <monochrom>
17:47:07 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
17:47:32 * BMeph plays a "sad trombone" sound
17:48:26 <JoeyA> @quote javascript
17:48:27 <lambdabot> Jafet says: Javascript is pretty much a DSL for making your web browser take up more CPU
17:48:33 <elliott> @remember lambdabot Plugin `quote' failed with: getRandItem: empty list
17:48:34 <lambdabot> It is stored.
17:48:40 <sizz> Thanks. It looks like LYAH and RWH cover text processing a bit too.
17:48:48 <thinker341> @remember no, you're thinking imperatively. when thinking functionally, you just worry one element, and let recursion worry the rest
17:48:48 <lambdabot> I will never forget.
17:49:00 <elliott> thinker341: no, said that?
17:49:02 <hpc> @quote no,
17:49:03 <lambdabot> no, says: you're thinking imperatively. when thinking functionally, you just worry one element, and let recursion worry the rest
17:49:09 <elliott> @forget no, you're thinking imperatively. when thinking functionally, you just worry one element, and let recursion worry the rest
17:49:09 <lambdabot> Done.
17:49:12 <elliott> @remember monochrom no, you're thinking imperatively. when thinking functionally, you just worry one element, and let recursion worry the rest
17:49:12 <lambdabot> Done.
17:49:47 <thinker341> elliott, thx
17:49:54 <JoeyA> @quote DSL
17:49:55 <lambdabot> Jafet says: Javascript is pretty much a DSL for making your web browser take up more CPU
17:50:10 <JoeyA> Nobody else has made a DSL quote?
17:50:18 <hpc> @quote DSL
17:50:18 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
17:50:28 <JoeyA> hahaha
17:50:40 <JoeyA> @quote windows
17:50:40 <lambdabot> windows says: Keyboard doesn't found. To rescan - press any key
17:50:54 <hpaste> amtal pasted “Trifecta double warn” at http://hpaste.org/66686
17:51:16 <amtal> I've got a Trifecta puzzler. A warn diagnostic is being evaluated twice... But I swear the parser isn't being evaluated twice :o
17:52:12 <amtal> dylukes: help :D
17:52:23 <dylukes> Hm
17:52:28 <JoeyA> Heh, I thought you ran into some obscure compiler bug.  Then I noticed the error message was part of the program :D
17:52:32 <dylukes> remember, `try'
17:52:52 <dylukes> trifecta can and will back track if you're using try and such.
17:52:56 <dylukes> So that's a possibility.
17:52:59 <amtal> Ah. Hm.
17:53:02 <dylukes> Alternatively,
17:53:15 <dylukes> edwardk messed up w/ unsafe stuff... though I don't think he used any.
17:53:24 <monochrom> I was actually going for http://article.gmane.org/gmane.comp.lang.haskell.cafe/81075/ :)
17:58:24 --- mode: ChanServ set +o glguy
17:58:31 --- mode: glguy set -q dbelange!*!@*
17:59:17 --- mode: glguy set -qq *!*@c-24-0-71-119.hsd1.nj.comcast.net *!*@ool-18b87a54.dyn.optonline.net
18:02:16 <ClaudiusMaximus> is there a matrix somewhere showing which implementations support which language extensions?
18:04:29 <hpc> don't think so
18:05:02 <hpc> iirc, the current state of compilers is "GHC supports almost everything, except some strange awesome stuff YHC does"
18:05:18 <elliott> yhc is dead, so that's not very "current" :)
18:05:23 <hpc> oh :(
18:05:30 <elliott> ghc does everything, jhc and uhc do iirc rank-2 polymorphism and precious little else
18:05:35 <elliott> uhc does more than jhc though i believe
18:05:41 <elliott> neither do MPTCs or anything to my knowledge
18:06:28 <koninkje> last I heard, JHC is hoping to be able to avoid MPTCs
18:06:48 <koninkje> though JHC is going to implement type families & associated types
18:06:53 <elliott> right
18:06:57 <elliott> hpc: see http://yhc06.blogspot.co.uk/2011/04/yhc-is-dead.html
18:07:16 <elliott> koninkje: probably for the best, I'm just biased because type families didn't work out for reflection and it had to go back to FDs
18:07:29 <liyang> How do you avoid MPTCs?
18:07:42 <koninkje> Well, even with TFs you still need MPTCs
18:07:53 <ClaudiusMaximus> i don't need anything special, but i'd like to share some code with someone new to haskell and it seems ghc is quite daunting...
18:08:08 <koninkje> liyang: by hoping that your users won't need them ;)
18:08:14 <ClaudiusMaximus> ...and my code uses GeneralizedNewtypeDeriving quite a bit, which hugs doesn't support
18:08:40 <koninkje> You could always hand-implement that boilerplate
18:08:42 <elliott> koninkje: You do?
18:08:49 <elliott> I've never really found a use for MPTCs without FDs.
18:08:54 <elliott> It's too awkward in practice.
18:09:10 <koninkje> I've used them without FD or TF all the time
18:09:13 <elliott> Also, with type families, you can do: type family Fst a; type instance Fst (a,b) = a; type family Snd a; type instance Snd (a,b)
18:09:19 <elliott> and then do
18:09:24 <ClaudiusMaximus> koninkje: i know, but i have at least 5 numeric types, which is a lot of boilerplate
18:09:24 <koninkje> e.g., class RealToFrac a b where realToFrac :: a -> b
18:09:26 <elliott> class MPTC foo where both :: (Fst foo, Snd foo)
18:09:36 <elliott> class RealToFrac ab where realToFrac :: Fst ab -> Snd ab
18:10:13 <koninkje> ...for using the efficient implementations of conversion from Real types to Fractional types, rather than the slow and non-bijective version in the Prelude
18:10:20 <elliott> (doesn't that work?)
18:10:55 <koninkje> I suppose you could make that work; but that's a whole lot of extra boilerplate that obscures what's going on
18:11:18 <elliott> it is, yes
18:11:29 <elliott> i would be happy if TFs just inferred better
18:11:39 <koninkje> e.g., every MPTC has to be written as: class Foo abdce where Foo1 abcde = a; Foo2 abcde = b; ...
18:12:20 <koninkje> ClaudiusMaximus: so it goes if you want to avoid GHC-specific dependencies, alas
18:13:36 <koninkje> Well, the whole point of fundeps was to improve inference. So we just need to talk someone into figuring out how to get the TF inference to work better
18:13:46 <elliott> koninkje: no, not true
18:13:50 <elliott> type family Fst a; type instance Fst (a,b) = a; type family Snd a; type instance Snd (a,b)
18:13:54 <elliott> class RealToFrac ab where realToFrac :: Fst ab -> Snd a
18:13:59 <elliott> instance RealToFrac (Double, Rational) where ...
18:14:05 <elliott> i don't know if this actually works, though
18:14:08 <elliott> but i don't see why it wouldn't
18:15:39 <rwbarton> you can't infer (Double, Rational) from realToFrac :: Double -> Rational, can you
18:15:43 <rwbarton> or rather, the compiler can't
18:16:00 <elliott> hmm, right
18:16:15 <elliott> you could with a data family, but then the usage would be ugly
18:16:15 <elliott> bah
18:16:42 <rwbarton> you could with DataKinds or whatever it's called
18:16:43 * koninkje thinks realToFrac :: Fst ab -> Snd ab is already ugly
18:16:51 <elliott> rwbarton: DataKinds without MPTCs is impressive.
18:17:21 <koninkje> mmm higher-order tarpit
18:17:32 <rwbarton> it would be a bit odd yes
18:18:50 <vhd> how would you create a function which takes a list and returns two lists? Rather, how can you construct two lists at once? Impossible no?
18:19:39 <vhd> e.g say I have [1,2,4,5,6,7,8,9] and I wanted to produce ([1,2,4,5],[6,7,8,9])
18:19:49 <vhd> the constraint is that all numbers above 5
18:19:58 <glguy> :t partition
18:19:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:20:03 <koninkje> > splitAt 4 [1..9]
18:20:04 <lambdabot>   ([1,2,3,4],[5,6,7,8,9])
18:20:27 <glguy> ?src partition
18:20:28 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:20:28 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:20:28 <lambdabot>                               | otherwise = (ts, x:fs)
18:21:10 <vhd> yes, partition is what I was looking for, thank you.
18:34:55 <vhd> why would anyone use Data.Sequence over Vectors, considering Vectors index access is O(1) while sequences is O(log(min(i,n-i)))
18:35:33 <rwbarton> Sequence lets you do a lot of things Vector doesn't
18:35:33 <Axman6> because appending to a vector is O(n) and appending to a Seq is O(log n)
18:35:41 <rwbarton> appending to a Seq is O(1)
18:35:50 <Axman6> there's more to life than indexing
18:36:02 <rwbarton> inserting/removing elements in the middle is O(log n)
18:36:06 <shachaf> Why would anyone use Data.List over vectors, considering Vectors index access is O(1) while sequences is O(n)?
18:36:11 <rwbarton> or what you say actually
18:36:12 <Axman6> is it O(1)? my mistake then
18:36:33 <elliott> vhd: because Seq is a functional, shared tree structure
18:36:38 <elliott> Vector has to copy for every modification
18:36:51 <vhd> so vectors is slower?
18:37:10 <Axman6> vhd: it really depends on what you're doing
18:37:25 <rwbarton> even if you never want to reuse a Seq it is still faster for operations like inserting/removing elements and concatenating two Seqs together
18:37:45 <shachaf> chd: Data structures don't have speeds.
18:37:47 <Axman6> if you need to insert into the middle of a data structure, then there's no way you'd choose a Vector over a Seq, because of the O(n) cost.
18:38:00 <shachaf> Except for FastPackedString
18:38:02 <shachaf> Which is fast.
18:38:04 <shachaf> (And packed.)
18:38:11 <Axman6> but if you need to look up things by index, then Vector is preferable, since it has, as you said, O(1) index time)
18:38:22 <liyang> Vectors *are* faster, except for the operations where it's slower.
18:38:46 <rwbarton> I interpreted it as "vector's <unspecified operation> is slower"
18:39:01 <monochrom> that's a nice tautology there :)
18:39:20 <shachaf> liyang: Vectors aren't faster for operations where it's the same!
18:40:30 * monochrom adds more tautologies
18:40:51 <monochrom> naïve comparisons are naïve
18:40:56 <liyang> Damn those trichotomous relations!
18:41:24 <Catnaroek> ?
18:42:13 <liyang> Anyway, if you're concerned about relative performance, criterion will settle your questions definitively.
18:43:45 <koninkje> Unless they're close enough that Criterion just highlights the confusion
18:55:35 <byorgey> preflex: seen edwardk
18:55:36 <preflex>  edwardk was last seen on #haskell 18 hours, 21 minutes and 10 seconds ago, saying: hrmm, nope thats not it
18:56:15 <otters> anybody had this problem with installing lambdabot? https://gist.github.com/2340793
18:57:51 <geekosaur> otters, it's a known issue with ghc and a hack thats used on some linux systems (libncurses.so was merged with libncursesw.so; they dropped a linker script in its place instead of making a symlink, and the linker script is broken or possibly not understood)
18:58:03 <otters> sooo what do I do
18:58:13 <otters> symlink?
18:58:16 <elliott> you can make it a symlink
18:58:21 <elliott> but you should feel bad about it :p
18:58:29 <geekosaur> fix is to remove  /usr/lib/libncurses.so and symlink /usr/lib/libncursesw.so to it
18:58:38 <elliott> erm
18:58:42 <elliott> don't remove /usr/lib/libncurses.so
18:58:48 <elliott> that's not a linker script, that's the actual library
18:59:12 <otters> haha, removing it would make linking to it pointless
18:59:43 <geekosaur> at east until whoe
18:59:50 <geekosaur> oops
18:59:57 <byorgey> @ask edwardk what's new in mtl 2.1 and transformers 0.3?
18:59:57 <lambdabot> Consider it noted.
19:00:06 <geekosaur> at least until whoever has the bug fixes it
19:00:45 <otters> okay wait, what?
19:00:50 <otters> libncurses.so exists
19:01:07 <otters> so what exactly is it looking for
19:01:20 <luite> is it acceptable to overwrite a package on hackage if it hasn't been updated to build with recent compilers for a year, the author knows about it, but doesn't seem to fix it?
19:01:33 <parcs`> ghc uses dlopen to dynamically load stuff and that doesn't handle linker scripts
19:01:50 <elliott> otters: ncursesw.so
19:01:55 <elliott> remove libncursesw.so
19:01:58 <elliott> link it to libncurses.so
19:02:00 <otters> I see
19:02:01 <byorgey> @tell edwardk also, others of your packages like contravariant, comonad, semigroupoids require transformers < 0.3 but I assume you're going to fix that
19:02:02 <lambdabot> Consider it noted.
19:02:02 <geekosaur> other way around
19:02:24 <geekosaur> libncurses.so is a linker script:  a text file containing:  INPUT(-lncursesw)
19:02:47 <otters> oh fuck
19:02:51 <parcs`> i recommend not messing with your filesystem and instead editing the readline package to link ncursesw
19:03:10 <Guest32898> I'm messing with lambdabot a bit. What's the yhjulwwiefzojcbxybbruweejw command? seems pretty useless to me
19:03:16 <parcs`> @yhjulwwiefzojcbxybbruweejw
19:03:16 <lambdabot> Exception: <<loop>>
19:03:23 <parcs`> @yhjulwwiefzojcbxybbruweejw blah blah blah
19:03:23 <lambdabot> "\"#$%&'()*+,\""
19:03:25 <otters> wait
19:03:46 <Guest32898> the unpronounceable command
19:03:47 <rwbarton> @v
19:03:47 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:04:04 <parcs`> otters: edit ~/.ghc/*/package.conf.d/readline-*.conf and replace instances of ncurses with ncursesw
19:04:10 <koninkje> > fix error
19:04:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:04:20 <koninkje> bah, bad lambdabot
19:04:24 <otters> parcs`: thanks
19:04:27 <koninkje> you used to be able to do that
19:05:03 <geekosaur> Guest32898, it's a joke based on lambdabot history.  it stored the current expression in "v".  someone found that and made self-refs out of it, so it was renamed to a random name (that one).  someone discovered that, since it is open source...
19:05:19 <geekosaur> these days it rolls a new name and makes sure it's not mentioned in the expression
19:06:00 <elliott> It does?
19:06:05 <elliott> I thought mueval just interpreted it directly, without any wrappers.
19:06:30 <geekosaur> hm, actually mueval is more recent and that might be true
19:06:36 <otters> parcs`: same error
19:07:09 <Guest32898> geekosaur: it's not quite clear to me that about the self-refs, but I guess the whole topic is pointless so I'll leve it at that. Thanks for the reply though :-)
19:07:19 <rwbarton> > fix show
19:07:20 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:07:28 <parcs`> otters: run ghc-pkg recache
19:07:45 <parcs`> ghc-pkg recache --user
19:07:53 <glguy> > fix error
19:07:54 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:07:54 <elliott> Vulpyne: i.e. lambdabot turned your code into "let yhjulwwiefzojcbxybbruweejw = CODE in print yhjulwwiefzojcbxybbruweejw"
19:07:56 <elliott> erm
19:08:00 <elliott> Guest32898: i.e. lambdabot turned your code into "let yhjulwwiefzojcbxybbruweejw = CODE in print yhjulwwiefzojcbxybbruweejw"
19:08:03 <elliott> so if you wrote
19:08:06 <elliott> "show yhjulwwiefzojcbxybbruweejw"
19:08:07 <elliott> you'd get
19:08:10 <elliott> > let yhjulwwiefzojcbxybbruweejw = show yhjulwwiefzojcbxybbruweejw in yhjulwwiefzojcbxybbruweejw
19:08:10 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:08:40 <geekosaur> what those commands do now is print out static examples of the kinds of things people did when they discovered the self-referencing capability
19:09:01 <Guest32898> I see
19:09:45 <Guest32898> yhjulwwiefzojcbxybbruweejw would make a good password. Shh, don't tell anyone
19:11:09 <andkerosine> ㄆ would make a good password.
19:11:48 * Guest32898 would have to get a complete console font in order to see that symbol
19:12:17 <amtal> dylukes: how do I print warnings in the presence of try? :\ If I do it at the lowest level, integer parser... It prints 10x warnings in some cases.
19:12:23 <amtal> Does that mean I'm trying too hard (often)?
19:12:41 <dylukes> hmm
19:12:50 <dylukes> Perhaps push the error out to the top level
19:12:55 <dylukes> and then emit the warning there
19:13:08 <dylukes> er, the error code or whatever
19:13:09 <dylukes> so basically
19:13:20 <geekosaur> also recognize that "try" is expensive; you may want to refactor your grammar so it isn't needed
19:13:34 <geekosaur> (I think it's less expensive than it used to be, but.)
19:14:07 <dylukes> myParser = do r <- mainParserShit; case r of { Nothing -> <ok!>; Just w -> <emit warning> }
19:14:21 <dylukes> amtal: seem reasonable?
19:14:35 <elliott> geekosaur: this is trifecta, not parsec
19:14:38 <elliott> is try expensive in trifecta?
19:14:44 <amtal> dylukes: only thing I know of that works, though I don't look forward to either piping additional error data up a big stack of functions.
19:15:05 <dylukes> hmmm...
19:15:05 <amtal> I also don't know how to save the position and caret.
19:15:11 <dylukes> oh, that's easy
19:15:25 <dylukes> mark/release
19:15:40 <dylukes> er, well, they're for saving the location in the input
19:15:49 <dylukes> Really, I would ask edwardk.
19:16:08 <dylukes> Use @tell to leave a message for him, and intercept him the next time he shows :P. He's on pretty often.
19:16:26 <amtal> I'll bug him if I see him. For now, warning spam is acceptable.
19:16:43 <amtal> If you use >16bit constants in a 16-bit architecture, you deserve seeing 10 warnings for one literal :D
19:17:21 <luite> dcoutts: is there anything holding back a new release of cabal-install on hackage, one that works with ghc 7.4?
19:17:53 <elliott> i've had no problems with darcs cabal-install
19:18:00 <elliott> it'd give us the modular solver too
19:20:09 <luite> elliott: yeah I wonder why it's not on hackage... it's arguably one of the most important packages, and one of the worst maintained in this respect
19:20:47 <otters> http://pastebin.com/VPZhA1Q1
19:20:50 <mauke> The paste VPZhA1Q1 has been copied to http://hpaste.org/66688
19:20:55 <otters> now I'm getting that ^
19:21:01 <otters> however, readline worked, so we're getting somewhere
19:21:18 <elliott> luite: as I understand it dcoutts is *very* busy :p
19:21:27 <sizz> how do people pronounce >>= in conversation?
19:21:32 <otters> bind
19:21:35 <luite> yes I understand, but maybe he isn't such a good choice as a maintainer for this then
19:21:48 <elliott> luite: others have expressed the same sentiment. i can't say i disagree.
19:21:55 <elliott> luite: i bet nobody qualified has volunteered, though.
19:23:07 <luite> how about moving the source repository to somewhere where more people can work on it/fix it, like the haskell janitors organization on github, or the regular haskell one?
19:23:42 <luite> dunno if the former still exists
19:24:58 <dmwit> The former still exists.
19:27:20 <otters> can you pass ghc options to cabal
19:27:31 <elliott> --ghc-options="X"
19:27:45 <elliott> luite: Well, the repository version works just fine.
19:27:58 <elliott> I don't think moving the source repo would do much if no releases ever get done.
19:28:44 <luite> elliott: at least if there's a repository where people can commit fixes, they'd know that they can fix the problem if something's wrong with the package they uploaded
19:29:27 * elliott hardly thinks choice of VCS is the biggest problem cabal's dev process has
19:30:29 <luite> well, not just the VCS, but who has commit access? if it takes him 6 months to review a patch, no one's going to bother
19:33:00 <elliott> luite: more than him, I believe
19:33:48 <otters> installing goa is a pain in the ass
19:34:04 <elliott> cf. http://darcs.haskell.org/cabal/_darcs/hashed_inventory
19:34:26 <koninkje> goa's abandonware by this point
19:34:53 <otters> anything else that lets me use lambdabot stuff in ghci
19:35:17 <elliott> koninkje: it had a release recently
19:35:27 <luite> elliott: ah does that mean that they have committed directly to the repository?
19:35:29 <elliott> http://hackage.haskell.org/package/goa-3.1
19:35:30 <elliott> may last year
19:35:41 <otters> that's pretty recent
19:35:55 <koninkje> dunno. Depends on what you want exactly. Some of the functionality (e.g., Djinn) can be used by adding ghci commands
19:35:55 <elliott> luite: not *necessarily* but there seems sufficient activity that I'd guess multiple people can
19:36:08 <elliott> "If you have access to darcs.haskell.org, and are in the darcs group, then you can push to the repository."
19:36:10 <elliott> luite: so yes
19:36:21 <luite> ah
19:36:31 <koninkje> As I recall, the author said that they're no longer maintaining it, in part because they no longer use it
19:36:43 <elliott> koninkje: well, the last release before may last year was in 2008
19:36:47 <elliott> it was dead but i think it got revived
19:36:52 <koninkje> could be
19:36:56 <elliott> so it's probably easier to get working now than it was a year or two ago
19:58:39 <koninkje> @tell edwardk What did you have in mind about using newtypes to avoid UndecidableInstances for Show Fix and the like?
19:58:40 <lambdabot> Consider it noted.
20:01:28 <elliott> hm, that sounds interesting
20:10:19 <tupacshakur> Hoppy Easter friends & allies
20:10:39 <monochrom> heh
20:12:59 <elliott> thanks, tupac
20:16:34 <byorgey> wow, I've never been wished a Hoppy Easter by a famous dead rapper before
20:18:38 <rwbarton> Are you sure you're a friend or ally?
20:21:36 <byorgey> I guess not
20:22:07 <elliott> Wow, Hugs is really slow.
20:23:38 <byorgey> elliott: and what, pray tell, has given you the opportunity to investigate the speed of Hugs?
20:23:51 <elliott> proving a point :)
20:24:19 <elliott> (it's secret! for now)
20:26:29 <byorgey> MYSTERIOUS
20:26:40 <elliott> don't worry, it's not very exciting
20:27:13 <koninkje> Well, Hugs was never particularly concerned with optimization; portability was more their thing
20:27:18 <byorgey> I wasn't *worried* exactly.
20:28:06 <elliott> koninkje: yeah, but this file compiles in under a second on GHC, but takes like a minute+ with Hugs!
20:29:06 <koninkje> oof. what're you up to?
20:29:14 <elliott> <elliott> (it's secret! for now)
20:29:21 <elliott> i'm making some code work on Hugs
20:29:26 <koninkje> curses! foiled again!
20:29:41 <koninkje> nice
20:29:43 <monochrom> I know. elliott is running ghc source code through hugs
20:29:49 <koninkje> I've always been keen on Hugs support
20:29:50 <elliott> monochrom: haha
20:29:55 <elliott> monochrom: that would be quite a mammoth task
20:30:15 <elliott> koninkje: well, hugs wasn't my first choice, but none of the other implementations implement what i need!
20:30:23 <elliott> so i've had to resort to archeology.
20:30:34 <koninkje> so MPTCs and fundeps then. interesting
20:30:51 <monochrom> you need to store your programs on cassette tapes to claim archaelogy
20:31:25 <monochrom> no, I think he wants extensible records. that's a hugs exclusive.
20:31:26 <geekosaur> .oO { hughcs? }
20:31:29 <elliott> koninkje: hey, you're keeping notes, that's cheating
20:31:36 <elliott> yes, let's go with what monochrom said
20:31:57 <koninkje> Part of the reason I like(d) supporting Hugs is that it succinctly captured a nice stable point in the development of Haskell. MPTCs, fundeps, rank-N; back before all the new craziness with gadts and type families
20:32:06 <geekosaur> monochrom, BAUDOT paper tapes :p
20:32:18 <elliott> i like how hugs' last version, from 2006, has a copyright of 1994-2005
20:32:21 <elliott> even they forgot hugs wasn't dead yet
20:34:21 <elliott> ok, my work is done. now i just need someone who has used cabal and hugs
20:34:47 <koninkje> yo dawg
20:34:59 * elliott tries to figure out the implicit joke
20:34:59 <koninkje> what do you need to know?
20:35:08 <monochrom> I think cabal is compatible with hugs
20:35:28 <byorgey> we heard you like hugs, so...
20:35:42 <elliott> monochrom: well -- let's put it this way
20:35:45 <koninkje> tis, mostly
20:35:59 <elliott> hugs ships with cabal 1.1.5.9.2
20:36:03 <koninkje> cabal has some bugs wrt using ffihugs
20:36:10 <elliott> the earliest version of cabal on hackage is 1.1.6 from 2006
20:36:20 <elliott> does the latest cabal really compile on hugs?
20:36:27 <elliott> I'd be shocked if anyone has actually bothered to test in the last half-decade
20:36:51 <salam> hi
20:36:52 <elliott> (also, is compiling your own cabal as disastrous on hugs as it is in ghc (being a boot package?))
20:36:56 <byorgey> hi salam
20:37:07 <monochrom> oh, I don't mean building cabal by hugs. I mean taking an existing cabal executable and using it to call up hugs
20:37:24 <salam> i can't install Haskell in my win
20:37:36 <salam> my Antivirus detct it and delete it
20:37:37 <monochrom> at any rate there is no "compile cabal by hugs" but we know what we mean
20:38:00 <koninkje> Well, if cabal uses the ffi then there is compilation there
20:38:34 <salam> Brent Yorgey ?
20:38:36 <byorgey> salam: Haskell is a virus! it's true. ;)
20:38:41 <byorgey> salam: yes, that's me
20:38:55 <byorgey> salam: when you say "install Haskell", do you mean the Haskell Platform?
20:39:01 <salam> so do u have gmail we can contact directly ?
20:39:10 <salam> i want your help  please
20:39:22 <byorgey> I'd rather not.  there are lots of other people here who can help as well.
20:39:31 <salam> yes haskell platform
20:39:36 * hackagebot pointed 2.0.3.2 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0.3.2 (EdwardKmett)
20:39:39 <parcs`> why can't there be cycles in an import graph?
20:39:49 <elliott> because that's complicated
20:39:52 <dmwit> parcs`: There can be. Google hs-boot.
20:40:01 <elliott> monochrom: ah, you mean use my new cabal-install?
20:40:12 <elliott> monochrom: that'll work -- it'll compile Setup.hs with GHC, right?
20:40:21 <parcs`> i mean why is an hs-boot file needed? can't ghc figure out the dependencies?
20:40:28 <elliott> monochrom: the question is... how do I make cabal use another compiler, and can I install the dependencies with hugs in a separate location?
20:40:28 <salam> so what is ur advice ?
20:40:37 <salam> it is wins7 64bit
20:40:44 <elliott> salam: it's hard to offer advice without more specific information
20:40:44 <dmwit> parcs`: Because separate compilation.
20:40:48 <byorgey> salam: isn't there some way you can add an exception to your antivirus software or something like that?
20:40:50 <elliott> like the exact error the antivirus gives
20:40:56 <elliott> but yes, try disabling it for the installation
20:41:05 <koninkje> parcs`: The H98 report says that cycles must be supported, but it doesn't say how; GHC takes the easy route and requires users to explain cycles to it
20:41:16 <salam> let me try
20:41:22 <rwbarton> type inference in particular would be a bit of a pain
20:41:23 <monochrom> elliott: I have not actually tried, so I don't know. sorry.
20:41:39 <mikeplus32> salam: if you can verify the integrity of your installer
20:42:10 <elliott> monochrom: ok, well I'll look into it
20:42:12 <salam> how to do that ?
20:42:14 <rwbarton> (also the other answer to your question is "because no one has wanted it badly enough to implement it yet")
20:42:16 <elliott> hey, edwardk woke up, I see
20:42:35 <mikeplus32> they don't seem to provide a md5 or whatever on the HP page, so I don't think you can salam :(
20:42:55 <elliott> salam: it should be safe just to disable your antivirus and install it
20:43:00 <elliott> note: if you get a virus I accept no responsibility
20:43:12 <koninkje> elliott: as I mentioned, you can use precompiled cabal to install for Hugs (modulo ffi issues); though I haven't tried "compiling" cabal with Hugs recently, s'true
20:43:14 <elliott> monochrom: thanks for the advice anyway
20:43:26 <elliott> koninkje: right -- how can I do that in a way that doesn't tread on my GHC packages?
20:43:30 <mikeplus32> salam: what AV are you using though?
20:43:32 <elliott> do I need a separate installation of cabal-install?
20:43:33 <monochrom> I think the problem is that when you turn on antivirus later, things get deleted
20:43:47 <elliott> ah, there is a --hugs option I see
20:44:04 <koninkje> elliott: use cabal to install Hugs code? Just pass --hugs. It puts it in a different place (last I checked)
20:44:09 <mikeplus32> salam: because maybe you should contact them, as well as add an exception, that there is a false positive
20:44:57 <koninkje> elliott: You may be interested in: http://community.haskell.org/~wren/logfloat/INSTALL
20:45:47 <koninkje> vanilla Haskell code is easy to do, but if you use the FFI or CPP then things get messier because cabal doesn't support Hugs properly
20:46:34 <koninkje> Oh yeah, Cabal 1.8 officially broke Hugs support. Forgot about that
20:46:35 <elliott> koninkje: thank you. I got cpp to work with -F"cpphs-hugs --noline"
20:46:44 <elliott> ugh!
20:46:48 <elliott> that's a problem.
20:46:52 <elliott> the cabal file wants 1.10.
20:47:07 <koninkje> er, well, "officially" as in that's the case. Not sure how intentional it was
20:47:24 <koninkje> the ticket number is mentioned in that url
20:47:25 <elliott> i suppose i'll try and simplify the cabal file
20:47:31 <elliott> thanks for this link though!
20:47:54 <djahandarie> Hmm, is there a way to control the outbound IP used when using Network's connectTo?
20:47:54 <koninkje> Sure thing. Feel free to email me if you need further help
20:48:00 <elliott> OK, so hopefully I should be able to use cabal-install to install the dependencies...
20:48:18 <koninkje> it's been a while since I've messed with it, but I used to be an old hand at getting Cabal to like Hugs
20:49:16 <elliott> koninkje: a further question... how does this interact with base?
20:49:28 <elliott> does it use Hugs' (incomplete) base, or the one from hackage, which has a bunch of ifdef __HUGS__es in place?
20:49:41 <elliott> for instance, Unsafe.Coerce has ifdef HUGS, and is in base on Hackage, but not in the base Hugs ships with...
20:50:12 <koninkje> Initially it uses the one that ships with Hugs
20:50:52 <koninkje> ISTR you can't install a new version of base very easily, hence the workaround code at: http://community.haskell.org/~wren/logfloat/src/Hugs/RealFloat.hs
20:51:08 <mikeplus32> do people use hugs nowadays?
20:51:16 <elliott> koninkje: good grief
20:51:24 <mikeplus32> for things other than pointing out how slow hugs is? (ala elliott :))
20:51:24 <elliott> koninkje: you are more determined than I :)
20:51:28 <elliott> mikeplus32: no
20:51:34 <elliott> except university students who are told to use it
20:51:39 <monochrom> djahandarie: is connectTo "192.168.1.1" enough control?
20:51:39 <mikeplus32> ah
20:51:43 <elliott> and who get their profs yelled at in #haskell and SO for it
20:51:43 <koninkje> N.B., the __HUGS__ CPP isn't actually something that Hugs does, it's something I added in just in case the future made it work :)
20:51:55 <elliott> koninkje: huh?? but base uses that!
20:52:23 <djahandarie> monochrom, huh? I mean control the source IP
20:52:24 <elliott> cabal: cannot configure tagged-0.2.3.1. It requires base ==4.*
20:52:25 <koninkje> cf the bottom of http://community.haskell.org/~wren/logfloat/logfloat.cabal
20:52:38 <monochrom> oh, then it can't
20:52:45 * elliott isn't sure how you can install anything that has a dependency on base
20:52:45 <koninkje> You have to pass it yourself
20:52:47 <djahandarie> Yeah, so it seems.
20:52:51 <elliott> since cabal doesn't think base is installed
20:53:07 <monochrom> you have to use the low-level Network.Socket stuff and do your manual bind etc
20:53:15 <djahandarie> Yeah, in process of doing that.
20:53:21 <djahandarie> Annoying. :p
20:53:24 <koninkje> elliott: that's odd. I've gotten it to insall logfloat and other things before
20:53:50 <elliott> koninkje: oh, maybe it's only complaining because base 3 is installed
20:53:55 <elliott> i don't suppose there's something like ghc-pkg list for hugs?
20:54:08 <elliott> yeah, this is base 2.0(!)
20:54:12 <koninkje> elliott: also, the standard use of __HUGS__ just makes it defined; doesn't give it an actual value based on version numbers
20:54:13 <elliott> going by Paths_base.hs
20:54:50 <elliott> so... time for the cabal unpack + hack cabal file + repeat dance
20:56:14 <koninkje> I don't recall a ghc-pkg equivalent, but then it's been so long
20:56:31 <koninkje> ...I forget where Hugs remembers its paths to things
20:57:58 <elliott> koninkje: yep, works if I relax the base constraint \o/
20:58:06 <koninkje> :)
20:58:37 <elliott> and that builds!
20:58:42 <elliott> now on to the next package
20:59:03 <koninkje> now I'm really curious what you're trying to backport
21:00:31 <elliott> i'll tell you if you don't tell edwardk :p
21:00:49 <koninkje> hee hee
21:00:53 <elliott> did you hear about reflection's new implementation?
21:01:03 <koninkje> nope
21:01:09 <elliott> did you hear about reflection in the first place?
21:03:26 <koninkje> I don't think so; of if I have it's been lost among similar sounding things
21:03:41 <elliott> basically, it turns any value into a type, which you can then turn back into a value
21:03:56 <elliott> which means you can propagate values through type signatures, and access configuration values without plumbing them around
21:04:09 <koninkje> Is this different from Oleg and Ken's trick about reifying/reflecting?
21:04:14 <elliott> that's exactly the same trick!
21:04:18 <elliott> the reflection package is an implementation of that
21:04:24 <koninkje> ah
21:04:45 <elliott> now, the original implementation is pretty elaborate, as you might know -- starts with integers and then does lists of integers and then does stableptrs through that
21:04:57 <koninkje> yep
21:05:11 <elliott> with GHC, you can do something much simpler: unsafeCoerce the value with a typeclass context to a function expecting the dictionary
21:05:18 <elliott> making the impl ~10 lines: http://hackage.haskell.org/packages/archive/reflection/1.1.3/doc/html/src/Data-Reflection.html
21:05:33 <elliott> this works because GHC represents a one-method typeclass' dictionary as just that method; the same trick doesn't work for bigger typeclasses
21:05:48 <elliott> not only is this a lot simpler, it's also ridiculously faster, since reify becomes basically free
21:06:10 <koninkje> hmm, interesting
21:06:26 <elliott> i.e. it literally just constructs its own dictionary and passes it
21:06:31 * koninkje nods
21:06:47 <elliott> i got that working with edwardk a day or two ago; he kept around the old version hidden by a cabal flag for portability, and I joked that no other compiler would be able to do the MPTC+fundeps+rank-2 types required for the interface anyway
21:06:49 * koninkje has been using some hand-rolled reify/reflect code recently
21:06:55 <elliott> but then I realised, hey, Hugs can do that!
21:07:06 <koninkje> yep :)
21:07:14 <koninkje> I think I can see where this is headed :)
21:07:18 <elliott> as it turns out, /both/ implementations work on Hugs (which is astonishing, I wouldn't expect it to use the same dictionary representation like that!)
21:07:19 <elliott> but!
21:07:27 <elliott> the unsafeCoerce implementation actually requires much _less_ hacking to get working with Hugs
21:07:37 <koninkje> que interesante
21:07:56 <elliott> because hugs doesn't do ScopedTypeVariables, and has troubles with ($) combined with rank-2 types
21:08:05 * koninkje nods
21:08:26 <elliott> so I'm hacking it up so that hugs can actually build it without modification
21:08:38 <elliott> and then nobody can accuse it of being totally unportable black magic :)
21:08:41 <elliott> only mostly-unportable black magic
21:08:46 <koninkje> hee hee
21:09:08 <elliott> (this is the thing which doesn't infer properly if you use TFs instead, btw)
21:10:31 <Catnaroek> @src gcd
21:10:31 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
21:10:31 <lambdabot> gcd x y = gcd' (abs x) (abs y)
21:10:31 <lambdabot>    where gcd' a 0  =  a
21:10:31 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
21:10:48 <Catnaroek> gcd 2 4
21:10:55 * koninkje thought we fixed that (gcd 0 0) being undefined 
21:10:55 <Catnaroek> > gcd 2 4
21:10:56 <lambdabot>   2
21:10:59 <Catnaroek> > gcd 2 0
21:11:00 <lambdabot>   2
21:11:07 <elliott> @src is kinda old
21:11:07 <lambdabot> Source not found. You speak an infinite deal of nothing
21:11:12 <elliott> hmm
21:11:20 <elliott> after "cabal install --hugs"ing a package, a later "cabal install --hugs" can't find it
21:11:25 <elliott> I wonder why?
21:11:32 <elliott> perhaps I need to tell hugs about the ~/.cabal/lib/hugs dir
21:11:41 <koninkje> probably
21:14:15 <koninkje> elliott: cf the -P flag
21:14:34 <elliott> yep, i tried -P'{Home}/.cabal/lib/hugs:' but same error -- -v3 time i guess
21:15:09 <elliott> nope, it's giving up before even running hugs... looks like it's looking at my ghc package database instead
21:15:34 <koninkje> strange
21:15:37 <monochrom> um, that's strange and funny :)
21:16:53 <elliott> yet it can't be doing that because it rightly rejected a base 4.* dependency because hugs only has base 2 here
21:17:24 <elliott> edwardk!
21:17:29 * edwardk hides
21:17:29 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
21:17:29 <elliott> I was just talking about you(r packages).
21:17:46 <elliott> edwardk: Remember how you kept the slow implementation of reflection for portability?
21:18:00 <elliott> And I joked that no non-GHC compiler will run that anyway?
21:18:16 <edwardk> byorgey: the main thing was the generalization of 'state'
21:18:25 <edwardk> yeah
21:18:47 <elliott> edwardk: The fast implementation works on Hugs. I have witnessed it with my own two eyes. So does the slow implementation, but that one requires *more* hacking to get working.
21:19:09 * elliott had to actually compile Hugs for this. In 2012.
21:19:24 <edwardk> hah
21:19:37 <edwardk> so i could add impl(ghc) || impl(hugs)
21:19:42 <edwardk> and allow the fast path there
21:20:04 <elliott> I think seeing the Hugs patch for the slow path will make you want to axe it altogether :P
21:20:21 <elliott> edwardk: BTW, can you move the Semigroup instances for Proxy and Tagged to semigroups?
21:20:36 <edwardk> no
21:20:39 <elliott> :(
21:20:40 <elliott> Why not?
21:20:47 <edwardk> because there are many many more packages that use semigroups than use proxy/tagged
21:21:03 <edwardk> someone has to sit on the bottom
21:21:12 <edwardk> and i inverted it once to go THIS way
21:21:14 <edwardk> and it was hell
21:21:14 <elliott> semigroups depends on containers >= 0.3, which depends on base >= 4.2
21:21:20 <djahandarie> Can we move all your packages into base?
21:21:29 <elliott> so unfortunately that means reflection can't work on hugs
21:21:37 <elliott> because of the dependency on tagged
21:21:42 <edwardk> oh
21:21:52 <elliott> would it still be a problem if tagged didn't have the Default instances? then it'd depend on nothing but base
21:22:13 <monochrom> so the secret is reflection
21:22:23 <elliott> (though thankfully data-default itself has lax constraints)
21:22:31 <edwardk> i can live with removing instances from tagged all together
21:22:46 <edwardk> i need to sell myself on it, but i think it'd be acceptable
21:22:56 <elliott> just the Semigroups would need to go, data-default seems OK
21:23:12 <elliott> oh, and it works with base 2, so the base constraint can be relaxed too
21:23:32 <edwardk> yeah, there comes a point at which trying to support that kind of crap becomes a huge burden to keep track of though
21:23:38 <elliott> yeah, but Hugs, man!
21:23:47 <elliott> edwardk: i don't quite understand why semigroups depending on tagged would be painful, btw -- can you enlighten me? is it because it'd pull in data-default and dependencies?
21:23:57 <edwardk> in order to support hugs all i have to do is destroy useful functionality for everyone else. awesome!
21:24:17 <edwardk> its because everyone who depends on semigroups now picks up an even longer install chain
21:24:21 <elliott> right
21:24:26 <edwardk> i get enough shit from people over the fact that it uses containers
21:24:29 <djahandarie> Apparently in this world, even Hugs aren't free.
21:24:29 <elliott> if you removed the Default instance, there'd only be one extra dependency, total ;)
21:24:46 <edwardk> i mean i get some serious end-of-the-world complaining from folks
21:24:54 <elliott> edwardk: well you could also hide the Semigroup and Default instances behind a flag
21:25:00 <elliott> but that'd be ugly and break compatibility randomly
21:25:11 <edwardk> i inverted it because this wound up with the shortest aggregate dependency chains
21:25:18 <edwardk> i even measured it and stuff
21:25:28 <elliott> meh
21:25:38 * elliott wants you to have your instances, but also wants it to work on Hugs
21:25:48 <edwardk> and i don't really want to revert that decision, because to do so, i have to go and spend roughly 40 hours patching packages
21:26:08 <edwardk> thats a lot of work to bikeshed for little margin gain and all i'll have to show for it is more complaining in my inbox
21:26:13 <edwardk> and working hugs reflection
21:26:14 <koninkje> edwardk: Didn't you say that the Tagged approach turned out not ot be nice in practice?
21:26:23 <elliott> koninkje: it uses Proxy from the tagged package
21:26:27 <elliott> edwardk: i've said it before and i'll say it again, you need an automated tool
21:26:33 <koninkje> Couldn't you just fold Proxy into reflection, and then do away with the tagged package
21:26:38 <elliott> edwardk: anyway, do people really email you whining about your dependencies? that's amazing
21:26:46 <edwardk> koninkje: proxy is haskell 98
21:26:50 <edwardk> reflection is decidedly not
21:26:52 <elliott> koninkje: tagged has tons of revdeps
21:26:56 <elliott> well "tons" http://packdeps.haskellers.com/reverse/tagged
21:27:04 <koninkje> elliott: Well I'm constantly whining about the non-portable language extensions :)
21:27:51 <edwardk> koninkje: now, a potentially acceptable solution to me would be to remove the semigroup instances from tagged
21:28:06 <edwardk> this only requires a couple of hours of my time
21:28:31 <edwardk> and would actually make about half of the users of tagged happier
21:28:31 <djahandarie> And then make a new package, semigroup-tagged, for those who want semigroup instances for tagged!
21:28:37 <edwardk> djahandarie: no
21:28:38 * elliott pledges to update all of edwardk's packages to move the instances to semigroups
21:28:40 <edwardk> no orphans
21:28:44 * elliott immediately regrets this pledge
21:28:45 <edwardk> elliott: not happening
21:28:50 <djahandarie> We all love orphans
21:29:16 <djahandarie> Don't kill my orphans
21:29:17 <edwardk> i can bring myself to remove the instances, but not to make the chain through semigroups any longer than it already is
21:29:25 <edwardk> well
21:29:32 <edwardk> i'm not even sure i can do that =)
21:29:41 <elliott> does anyone actually use those instances
21:29:42 <edwardk> void is in a similar situation
21:29:46 <elliott> they seem kinda pointless to me
21:29:46 <edwardk> and has a critical semigroup ;)
21:29:48 <elliott> same for the void ones
21:29:50 <edwardk> =P
21:29:59 <edwardk> they exist because they should exist. =P
21:30:22 <monochrom> I said it first. every file becomes its own package eventually
21:30:35 <elliott> bah
21:30:40 <elliott> things were better in the days of category-extras
21:30:44 <edwardk> i can take this super pragmatic approach
21:30:53 <elliott> before all those annoying portability freaks got a hold of edwardk ;)
21:30:54 <monochrom> perhaps I should extend it to: every declaration becomes its own package eventually. there, I said it first :)
21:31:00 * elliott stares pointedly at koninkje
21:31:01 <edwardk> in the end, I wind up programming with all the same classes as everyone else
21:31:07 <edwardk> and the well dries up because there is nothing new to say
21:31:35 <elliott> edwardk: ok, how about this
21:31:41 <edwardk> and then i wind up having to make special case versions of everything because i wasn't able to put the instances in the right place
21:31:45 <elliott> edwardk: make the containers dependency of semigroups optional, and just omit the instances if it isn't there?
21:31:51 <edwardk> nope
21:31:53 <elliott> that still breaks api compatibility with the same version
21:31:53 <elliott> sigh
21:32:04 <edwardk> thats not the way you should do things, because if you do that then there is no safe way to use those instances
21:32:11 <elliott> yeah
21:32:14 <edwardk> i can't depend on a version of a package with a feature
21:32:17 <elliott> edwardk: do you think containers will work with base 2?
21:32:28 <edwardk> try it
21:32:28 <elliott> it has a specific >= 4.2 so i guess not
21:32:34 <elliott> oh wait
21:32:39 <elliott> edwardk: can't you just relax your containers dependency? hugs has containers
21:32:52 <elliott> well
21:32:52 <edwardk> thats possible
21:32:54 <elliott> no it doesn't, it seems
21:32:56 <elliott> but it has Data.Map
21:32:58 <elliott> so it's gotta be somewhere
21:33:03 <edwardk> try it and see what version its compatible with
21:33:04 <elliott> ah, it's in base
21:33:09 <elliott> there's IntMap too
21:33:10 <koninkje> just try an older version of containers if possible. Containers is surprisingly resiliant to changes in base (until recently)
21:33:10 <elliott> OK, i'll try it
21:33:29 <elliott> koninkje: well the thing is, hugs base already has the same modules
21:33:31 <elliott> so maybe I don't need it
21:33:39 * koninkje nods
21:33:44 <monochrom> well, I have a great solution for "the well dries up and there is nothing new to say". you can say it all over again in Agda
21:34:05 <edwardk> i'm willing to put in some effort on this since i need to go through and update almost everything i have written to allow mtl 2.1
21:34:22 <edwardk> so mangling some other version #'s while i go through isn't that big of a burden
21:34:39 <elliott> hey, edwardk just successfully slippery-sloped me and I didn't even realise!
21:34:49 <edwardk> ?
21:34:58 <elliott> i got convinced that removing a Semigroup instance for Proxy would destroy edwardk's innovation :P
21:35:05 <edwardk> =P
21:35:11 * elliott attempts to hack up semigroups
21:35:25 * elliott wipes ~/.cabal to clear his mind
21:35:53 <edwardk> well, the thing is i get absolutely stopped in some code when i go to reach for a semigroup instance and its not there
21:36:05 <elliott> wait, if I wipe ~/.cabal I have to reinstall xmonad
21:36:06 <elliott> hmph
21:36:13 <edwardk> i wind up having to backtrack and insert it, in order to make progress on other things
21:36:29 <edwardk> because remember semigroups wind up being used for bind and apply instances
21:36:32 <elliott> yeah
21:36:47 <edwardk> and apply instances get used with comonads because many comonads are strong lax semimonoidal
21:36:53 <elliott> if i fix the deps for all your packages in the chain required by reflection, can I convince you to ditch the slow instance that doesn't even work on hugs ootb? :p
21:37:04 <elliott> (the only thing that changes in the fast one is the import of Unsafe.Coerce, which needs to be replaced with Hugs.IOExts)
21:37:49 <edwardk> what is the status of yhc/lhc/jhc/uhc with regards to mptcs and fundeps?
21:38:05 <elliott> jhc - doesn't do mptcs, is trying to avoid doing them in favour of tfs sez koninkje
21:38:13 <edwardk> oh
21:38:16 <elliott> uhc - doesn't do MPTCs, doesn't do TFs, I have no idea what they plan
21:38:17 <koninkje> yeah, unfortunately Hugs' base is before the Unsafe.Coerce compatibility layer
21:38:28 <elliott> lhc - dunno, will look into it
21:38:30 <elliott> yhc - ditto (but yhc is dead!)
21:38:41 <elliott> edwardk: well lhc is a backend for GHC these days
21:38:47 <elliott> so I guess they support everything GHC does, more or less
21:38:55 <edwardk> elliott: yes, but they implement it quite differently
21:39:03 <edwardk> elliott: which was kind of the issue
21:39:05 <elliott> OK, I'll try it out later
21:39:11 <koninkje> JHC is actively avoiding/despising fundeps; hoping to avoid MPTCs as long as possible; does have or in the near future will have type families
21:39:26 <elliott> [[
21:39:27 <elliott> Q) What extensions does it support?
21:39:27 <elliott> A) Very few. Existentials and pattern guards are supported. Rank-2 types, multiparameter type classes and most other extensions are not.
21:39:27 <elliott> ]]
21:39:31 <elliott> -- http://www.haskell.org/haskellwiki/Yhc/FAQ
21:40:05 <edwardk> anyways, i kind of want to keep the illusion that it might be portable if not the practice ;)
21:40:28 <edwardk> what was there before was sound across anything that actually implemented those language features
21:40:36 <edwardk> the current system is a complete and utter hack
21:40:40 <elliott> + and the FFI
21:40:49 <edwardk> the FFI is part of the language
21:40:53 <edwardk> its in Haskell 2010
21:40:57 <elliott> yeah, but if you're going for platonic ideal, the FFI is hardly it :p
21:41:06 <edwardk> FFI is part of 2010
21:41:09 <elliott> yes, agreed
21:41:13 <edwardk> its not going away =P
21:41:32 <elliott> if it works on lhc, will that convince you? :P
21:41:33 <koninkje> And it was very nearly in H98 too
21:41:39 <edwardk> no
21:41:54 <elliott> :(
21:42:23 <edwardk> you are really obsessed about this right now ;)
21:42:37 <elliott> it all started with downloading the hugs compiler source
21:42:48 <elliott> then i ended up unreasonably invested in it by the time i was reading hugs' base code
21:43:28 <elliott> alias cabalhugs='cabal install --hugs --with-cpphs="$(which cpphs-hugs)" --hugs-options="-98 +o"' # hugs is a mess
21:43:41 <edwardk> i'm going to strip the dependencies out of tagged
21:43:45 <edwardk> both of them
21:43:55 <edwardk> since data-default picked up some other crazy dependencies as it went
21:44:06 <elliott> edwardk: you can keep semigroups
21:44:15 <elliott> but data-default just ran me into a wall with its containers dependency
21:44:33 <edwardk> semigroups also depends on containers
21:44:36 * koninkje cheers
21:44:41 <elliott> edwardk: yes, but you can modify semigroups to depend on base for hugs
21:44:49 <elliott> since base 2 has Data.{Map,IntMap,etc.} in it
21:44:53 <elliott> you can't modify data-default :P
21:45:11 <koninkje> I like semigroups and all, just wish it wasn't such a large investment
21:45:15 <edwardk> just email lukas, and see if he'd take hugs patches =P
21:45:25 <elliott> i already have one maintainer to convince!
21:45:36 <edwardk> koninkje: i got nothing. there is no way i can make you happy and everyone else at the same time
21:45:37 <qfr> have people come up with a new language standard that addresses the problem of having "member collisions" in datatypes? Consider Vector2D and Vector3D, both having properties x, y, z. In Haskell people were using C style prefix naming patterns for these (Vector2Dx, Vector3Dx) when I last checked because this leads to collisions within the same module otherwise.
21:45:45 <edwardk> and still build a package
21:45:50 <elliott> koninkje: huh? the only dep is containers
21:45:51 <koninkje> edwardk: no no, I know that. I'm just lamenting is all
21:46:04 <edwardk> semigroups requires base and containers
21:46:06 <qfr> I know there have been numerous language extension suggestions over the past years but I'm nto sure if any of them ever made it into the standard since I haven't touched haskell in ages
21:46:14 <edwardk> because there is no way i can invert that dependency
21:46:19 <elliott> qfr: we have no good solution to that for now
21:46:22 <edwardk> because its used inside ghc
21:46:23 <qfr> :'(
21:46:26 <elliott> and no language exts have really become official except PatternGuards
21:46:33 <elliott> qfr: put them in different modules, import qualified
21:46:34 <qfr> elliott how do you deal with it personally?
21:46:37 <etpace> Does GHC optimise "foo :: Bool -> String; foo = show" to a known function call?
21:46:37 <qfr> I see
21:46:37 <elliott> that's one way
21:46:50 <elliott> qfr: or else put x & y in a typeclass
21:46:59 <elliott> edwardk: how do you specify those multiple dependency alternatives/
21:47:00 <elliott> ?
21:47:06 <elliott> i.e. base 3 or greater plus containers, or base 2
21:47:10 <edwardk> koninkje: i'm not sure how i could shrink that investment for you, even in a perfect world
21:47:13 <etpace> or does it still use a vtable like "foo :: (Show a) => a -> String; foo = show"
21:47:15 <edwardk> elliott: make a flag
21:47:19 <koninkje> edwardk: My only complaint is that when I'm trying to make standalone libraries, that means I can't use all the goodness in semigroups. I'm fine requiring it for large packages or for executables
21:47:21 <elliott> edwardk: ugh, ok
21:47:28 <elliott> edwardk: i was thinking the things that show up as "deps OR deps" on hackge
21:47:30 <elliott> *hackage
21:47:42 <edwardk> elliott: yes, you make a flag, and you say manual: False
21:47:44 <elliott> ah
21:47:44 <monochrom> yes, they can be caused by flags
21:47:53 <edwardk> and give it the more sensible alt as its default
21:47:58 * koninkje just hopes it catches on more; because then it won't be a burdensome requirement :)
21:48:09 <edwardk> koninkje: i'm not sure how i could make it less burdensome
21:48:24 <edwardk> its down to being a semigroup and the stuff you need to talk about semigroups!
21:48:45 <elliott> edwardk: btw, your DeriveDataTypeable flag doesn't work
21:48:52 <elliott> cabal: The package semigroups-0.8.2 requires the following language extensions
21:48:53 <elliott> which are not supported by hugs-2006.9: DeriveDataTypeable
21:48:55 <elliott> i have to manually disable it
21:49:05 <edwardk> ah, i'll have to look at what i broke
21:49:34 <koninkje> er, it's not semigroups I'm thinking of, it's semigroupoids
21:49:41 <edwardk> koninkje: whew
21:49:51 * elliott was thinking koninkje was being a little unreasonable :p
21:49:55 <elliott> edwardk: yep, semigroups works with base 2
21:50:02 <elliott> shockingly
21:50:04 <koninkje> yeah no, base and containers are perfectly fine in my crazy world ;)
21:50:24 <edwardk> so figure out a way to make the flags for it work with hugs and ghc at the same time
21:50:44 <elliott> edwardk: i did
21:50:44 <edwardk> koninkje: well, there you're hosed
21:50:45 <koninkje> qfr: most language extensions haven't made it into the standard. Though many are actively supporded by GHC
21:50:49 <elliott> modulo DeriveDataTypeable
21:50:51 <elliott> which I don't know how to fix
21:50:55 <qfr> koninkje I see
21:51:15 <monochrom> does hugs have Typeable?
21:51:38 <edwardk> koninkje: semigroupoids needs semigroups, and you need extend and transformers for it
21:51:38 <elliott> aargh, i ran into the same cabal problem again!!!
21:51:53 <edwardk> contravariant is about the only thing there i could drop
21:52:39 <koninkje> ooh, looks like the semigroupoid deps got simpler than I remember
21:52:45 <edwardk> elliott: you'll probably need to perster dcoutts
21:52:56 <koninkje> I really should follow the packages more closely
21:52:58 <elliott> edwardk: i've cunningly pinged him in the last few hours
21:53:00 <edwardk> koninkje: yes as a result of the last wave of complaining, i moved the instances into void and tagged
21:53:09 <elliott> edwardk: but the problem is basically that it doesn't recognise the package i installed with hugs!
21:53:14 <edwardk> which led to a different set of complainers ;)
21:53:15 <elliott> it's just looking at my ghc packages, bizarrely...
21:53:29 <elliott> edwardk: have you considered just ignoring all the complaints?
21:53:33 <edwardk> yes
21:53:55 <edwardk> which is an instinct i'm actively suppressing long enough to have this current conversation
21:53:57 <edwardk> =P
21:54:05 <monochrom> you don't ignore complaints until you have counted them
21:54:22 <elliott> edwardk i want to depend on trifecta in my hello world program. but it has too many dependencies, can you make it just use base and acme-realworld please?
21:54:31 <edwardk> actually what _is_ the contravariant stuff used by semigroupoids
21:54:39 <glguy> Is there a race in "System.Timeout.timeout n (readChan chan)" which could result in a lost element on the channel? Suppose readChan was killed just after reading from the channel...
21:54:42 <koninkje> (base, containers, transformers + semigroups, comonad, contravariant) is quite reasonable actually. I may have to switch some of my code over that way
21:54:50 <elliott> glguy: i suspect it uses mask
21:54:54 <elliott> which will stop async exceptions
21:55:19 <glguy> but isn't there a moment between readChan finishing and the timeout occuring?
21:55:38 <koninkje> edwardk: Do you have a class for internal Hom functors?
21:55:51 <elliott> glguy: i doubt it. async exceptions are processed on allocation
21:56:09 <koninkje> edwardk: (preferably in a way that allows constraints on the type parameters)
21:56:21 <edwardk> not as such
21:56:35 <edwardk> did you look in categories?
21:56:38 <elliott> argh! how does it know that it has base 2 installed, but also think that it has those versions of semigroups installed, and not the one i just installed for hugs?!
21:56:40 <koninkje> not yet
21:57:38 <koninkje> essentially I want Bifunctor, except contravariant on the first position
21:57:57 <koninkje> I guess I could use Dual...
21:58:14 <edwardk> ah found it
21:58:21 <edwardk> there is a semigroupoid for Op from contravariant
21:58:37 <edwardk> in theory i should invert the relationship between semigroupoids and contravariant as well
21:58:52 <edwardk> koninkje: or profunctor
21:59:13 <koninkje> edwardk: exactly.
21:59:17 <edwardk> http://hackage.haskell.org/packages/archive/profunctors/0.1.1/doc/html/Data-Profunctor.html
21:59:23 <koninkje> ah, excellent
22:00:04 <edwardk> ah, now i remember why i left the dependency flowing this way
22:00:11 <edwardk> contravariant requires almost nothing
22:00:25 <koninkje> no luck on being able to constrain the quantifiers of the maps though
22:00:57 <edwardk> nope, those start to lean on extensions, which you seem to believe are evil ;)
22:01:35 <edwardk> i've decided for the most part that i'll try to keep my existing '98 friendly packages '98 friendly, but that its more of a pain than its worth for new stuff
22:01:37 <koninkje> not evil, just sadly non-portable
22:01:55 <edwardk> when something comes along worth porting to, i'll consider that complaint ;)
22:02:13 <elliott> koninkje: you should write a haskell compiler that supports all that wonderful stuff
22:02:22 <koninkje> I should
22:02:23 <elliott> then it'll be portable!
22:02:30 <koninkje> give me a few hours ;)
22:02:32 <edwardk> but in the meantime the cost is pretty ridiculously high for a largely theoretical benefit
22:03:09 <koninkje> well, for most of my work the cost isn't very high. Doing type/category theory is another matter however
22:03:55 <edwardk> and when even the simplest of these packages comes up for discussion or standardization, someone's kneejerk reaction of 'i don't even know what a semigroup is' is enough to quash any further consideration.
22:04:14 <koninkje> srsly?
22:04:18 <edwardk> yep
22:04:22 <koninkje> lame.
22:04:58 <elliott> edwardk: is that "someone" as in someone on the committee, or some moron in -cafe? :p
22:05:08 <koninkje> Of course I run into the same problem whenever I try explaining to people working on numeric preludes that semirings (and the like) are important too
22:05:13 <elliott> (no offence to any of the non-moronic posters in -cafe -- psst, dear reader, I mean you, you're okay)
22:05:21 <edwardk> on the libraries mailing list
22:05:35 <rwbarton> pretty silly since Monoid is in base already
22:05:43 <elliott> it's kind of amazing that haskell is so reviled for "zomg monads and monoids are such complex mathematics"
22:05:53 <elliott> and somehow there's a culture mimicking exactly that inside the haskell community too
22:06:36 <koninkje> it's human nature mostly
22:07:14 <elliott> edwardk: DeriveDataTypeable broken on tagged to obtw
22:07:15 <koninkje> it didn't used to be that bad when Haskell was less popular; but these days many of those revilers have been converted to using Haskell, so...
22:07:15 <elliott> *too btw
22:07:24 <elliott> i solved my cabal problem by moving the installed semigroups to the global path
22:07:26 <elliott> go figure
22:07:37 <edwardk> elliott: well, thats because somewhere along the way cabal became dumb and stopped dispatching using those extensions as part of the requirement
22:08:05 <edwardk> elliott: that was the whole point of manual i thought
22:08:07 <edwardk> gah
22:09:35 * edwardk leaves this here. http://haskell.1045720.n5.nabble.com/Proposal-3339-Add-gt-as-a-synonym-for-mappend-tt3178183.html#a4698292
22:10:25 <elliott> edwardk: there there :P
22:10:34 <elliott> we understand you here!
22:10:37 <edwardk> =P
22:11:22 <elliott> ok, i've updated all of your bloomin' packages to get reflection working OOTB with hugs
22:11:26 * geekosaur would not mind having proper numeric classes; fie on those who grump about it.  but the real bikeshed is dealing with Eq vis-a-vis Floating
22:12:00 <edwardk> geekosaur: the real issue is to get decent numeric types you really need MPTCs
22:12:02 <geekosaur> (...*the*?  actually several others come to mind, but strictly numerically that will do.)
22:12:05 <koninkje> Perhaps someone should explain that you have to click on the module links to see the documentation...
22:12:32 <edwardk> geekosaur: we removed Eq from Num already
22:12:41 <edwardk> so that issue is nicely side-stepped ;)
22:12:45 <geekosaur> edwardk, I am now of the opinion that type families have proven themselves insufficient to replace fundeps
22:12:51 <elliott> no!
22:12:52 <elliott> stop!
22:12:54 <edwardk> geekosaur: likewise
22:12:58 <elliott> reflection needs them!
22:12:59 <elliott> :(
22:13:02 <elliott> oh
22:13:06 <elliott> _in_sufficent
22:13:08 <elliott> ignore me :)
22:13:22 <elliott> edwardk: ok, I'll now compile LHC
22:13:29 <geekosaur> inly in terms of the basic class structure.  users will want some form of Eq at some point :)
22:13:39 * elliott has a mission, dammit!!
22:13:50 <edwardk> geekosaur: you can implement MPTCs and fundeps behind the scenes with type families, but you'll have a hard time convincing me to give up the convenience of MPTC sugar
22:13:50 * koninkje really wishes that TFs and fundeps were unified in the implementation, with one just being sugar for the other
22:13:52 <elliott> first i gotta install darcs though.
22:14:19 <geekosaur> um, MPTCs can be done in terms of either
22:14:29 <geekosaur> see the old monads-tf package
22:14:39 <koninkje> How do you implement MPTCs with only fundeps?
22:14:40 <elliott> what the hecking hecking heck
22:14:40 <edwardk> geekosaur: that is a trivial case
22:14:48 <geekosaur> but the original plan was MPTCs were held out because it was thought that type families would replace fndeps
22:14:48 <elliott> installing darcs wants to break my install
22:14:52 <koninkje> fundeps don't make any sense without MPTCs
22:14:55 <elliott> i think cabal thinks it's installed all my darcs packages to ghc
22:15:01 <geekosaur> that doesn't seem to be possible at this point
22:15:17 <elliott> erm
22:15:19 <elliott> all my hugs packages
22:15:37 <edwardk> elliott: rm -rf .cabal again? =)
22:15:42 <elliott> i didn't do it the first tme
22:15:42 <elliott> time
22:15:44 <elliott> because of xmonad
22:15:58 <elliott> unfortunately my days of care-free spring-cleaning went when i actually started using a haskell program as a core system facility
22:16:02 <koninkje> elliott: mv .cabal .cabal-bakup ?
22:16:08 <elliott> bah
22:16:10 <elliott> that's for weaklings
22:16:16 <koninkje> hah!
22:16:21 <elliott> oh i can just install lhc from hackage
22:16:54 <elliott> oh god
22:17:09 <edwardk> ?
22:17:10 <elliott> ok --solver=modular --avoid-reinstalls saved me
22:17:28 <hpaste> elliott pasted “oh god” at http://hpaste.org/66691
22:17:29 <elliott> edwardk: ^
22:19:29 <elliott> edwardk: btw, since none of this actually changes the interface, if everyone depends on reflection correctly, then removing the slow implementation will make no difference, since anyone could just install the old version... just sayin' ;)
22:19:56 <elliott> (and you aren't quite right about it running on any haskell 2010 + MPTCs + fundeps + FFI impl...)
22:19:59 * elliott continues compiling LHC
22:20:09 <edwardk> i really don't see why you have a bee in your bonnet about wanting to remove working code ;)
22:20:42 <edwardk> the reason i want to keep the slow flag around is so that if it breaks someone has somewhat less drastic recourse than stopping cold
22:21:15 <koninkje> Which is a good idea since it relies on black magic
22:21:19 <elliott> i'm not really *that* bothered by it :P
22:21:27 <elliott> edwardk: wouldn't installing the old version accomplish that just as well?
22:21:36 <elliott> since the interface hasn't actually changed, nothing will require the new version
22:21:37 <koninkje> Even if it only works on GHC, what happens if GHC changes its internal representation?
22:21:50 <edwardk> except that you may start depending on things that depend on specific versions, so no
22:21:58 <elliott> but those packages would be wrong :P
22:22:01 <edwardk> well
22:22:14 <edwardk> one path gives you recourse, another makes you complain to a whole bunch of people
22:22:23 <elliott> fwiw, the old version works on anything haskell 2010 + MPTCs + fundeps + pointers of eight bytes or less -- that last one is the one you won't find in any spec
22:22:36 * elliott has an updated version of the slow impl anyway, so it doesn't really matter
22:22:54 <elliott> it's just so ugly, that's all :( (and takes over a minute to compile with hugs)
22:23:01 <elliott> er s/compile/interpret/ I suppose
22:23:10 <edwardk> the pointer thing is a 'meh' kind of issue given the fact that the only reason that restriction exists is because you didn't like the slower slow version =P
22:23:12 <koninkje> Why does the slow version require 8-byte pointers?
22:23:30 <edwardk> koninkje: it requires a maximum of 8 bytes because elliott is lazy
22:23:30 <elliott> koninkje: because i modified it to, for speed
22:23:36 <elliott> hey!
22:23:38 <elliott> i specifically said i'd fix that
22:23:45 <edwardk> =)
22:23:46 <elliott> but you said not to bother because you weren't concerned about hypothetical implementations
22:23:50 <elliott> that was the _old_ edwardk! :D
22:24:13 <koninkje> so, then we can compile it with -ffast, -fslow, and -freallyslow?
22:24:19 <edwardk> i'm not concerned about hypothetical 128 bit pointer machines
22:24:36 <edwardk> you can compile it with --flags=slow and it'll work, the older implementation is gone
22:25:34 <edwardk> for much the same reason why elliott is harping on about wanting me to kill the slow version, because it was a lot of code to keep around in a timecapsule and patch whenever ghc changes
22:26:04 <edwardk> right now i see the slow version as the correct version and the fast path as an interesting hack that currently seems to work
22:26:35 <edwardk> but if we discover something like the fast path fails under high load, etc. i want to keep the option to revert handy and less bitrotted than it would be in old branch
22:26:46 <elliott> i shall have to appeal the matter to the high court of oleg ;)
22:27:04 <elliott> ugh, why is haskell-src-exts so slow to compile?
22:27:45 <edwardk> well, as it now contains pretty much none of the original oleg code i think his veto is gone ;)
22:27:58 <elliott> oleg has jurisdiction over _everything_
22:28:08 <elliott> even things completely unrelated to haskell, computers, or electricity
22:28:21 <elliott> we're all just a simulation he's running in the type system, after all
22:28:41 <elliott> edwardk: ok, how about this compromise: I'll make the slow code more beautifully pure (and slow), by making it work with any pointer size
22:28:55 <edwardk> list of bytes?
22:28:57 <djahandarie> Matrix: Return of the Oleg
22:29:16 <elliott> edwardk: pretty much, but actually I'll just extend B to not be byte-specific, and define an instance for (a, b)
22:29:23 <edwardk> *shrug*
22:29:28 <edwardk> if you feel the need.
22:29:43 <edwardk> i have pretty bunch blown out my give-a-crap on reflection.
22:29:48 <edwardk> it works, its faster, yay
22:30:05 <edwardk> at this point the return on investment of further work until there is a problem is pretty low
22:30:17 <elliott> it works, but does it *work*?
22:30:45 <edwardk> i would be comfortable shipping code with it right now, its got decent enough defense in depth between 3 viable implementations
22:31:27 * elliott makes a totally unreasonable prediction that will be hilarious if true: the fast code will work with LHC, the slow code will break due to an obscure compiler code
22:31:31 <elliott> *compiler bug
22:32:08 <edwardk> anyways while you obsess over that i'm going to go change other stuff in other packages =P
22:32:57 <elliott> shall i throw you my semigroups + tagged patches while you're at it? they're pretty trivial
22:33:10 <edwardk> sure, if you can get that flag to work correctly
22:33:30 <elliott> the flag works
22:33:33 <elliott> DeriveDataTypeable's doesn't
22:33:41 <edwardk> thats the flag i mean
22:33:45 <elliott> oh
22:33:48 <elliott> but I didn't break that one!
22:33:51 <edwardk> yes
22:33:52 <edwardk> ;)
22:33:56 <elliott> can I just set manual: True?
22:34:02 <edwardk> i'm just extorting labor
22:34:24 <edwardk> ideally not
22:34:39 <edwardk> send them to me
22:34:47 <edwardk> and i'll just tell it not to DeriveDataTypeable on Hugs
22:35:00 <elliott> ok
22:35:07 <elliott> surely if !ghc would be more practical, though :p
22:35:07 <edwardk> if flag(DeriveDataTypeable) && !impl(hugs)
22:35:18 <edwardk> other compilers do DeriveDataTypeable
22:35:24 <edwardk> and i check for __GLASGOW_HASKELL__ in there
22:35:27 <elliott> fair enough
22:35:35 <edwardk> in order to guard the Typeable1 instances i build by hand
22:35:43 <elliott> lovely, test-framework-quickcheck is broken
22:35:56 <elliott> (lhc depends on it)
22:36:07 <elliott> why the heck is it building array 0.3?!
22:39:31 <edwardk> its the hugs change just
22:39:39 <edwardk> if !impl(hugs) build-depends: containers ...
22:39:40 <edwardk> ?
22:39:48 <elliott> i already pull requested
22:39:54 <edwardk> and the removal of the DeriveDataTypeable?
22:39:55 <edwardk> k
22:40:06 <elliott> oh, I didn't do the DeriveDataTypeable thing since you said you would :P
22:40:32 <edwardk> kk
22:41:36 <elliott> > 1 `shiftL` 1 :: Int
22:41:37 <lambdabot>   2
22:44:03 <edwardk> i'm prepping myself for a long night
22:44:38 * hackagebot semigroupoids 1.2.6.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.6.2 (EdwardKmett)
22:44:40 * hackagebot comonad 1.1.1.2 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-1.1.1.2 (EdwardKmett)
22:44:42 * hackagebot semigroups 0.8.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.2 (EdwardKmett)
22:46:52 <elliott> edwardk: Proxy is Applicative, right?
22:47:06 <edwardk> the yeah
22:47:06 <edwardk> should be nigh everything
22:47:21 <elliott> hmm, that means all these silly type-signatured Proxy manglers can just be uses of applicative notation instead
22:47:29 <edwardk> elliott: that was the idea
22:47:41 <elliott> e.g. fstP :: proxy (a,b) -> Proxy a is just fmap fst
22:47:46 <elliott> edwardk: right, I just didn't think of it, since the old code didn't
22:47:48 <elliott> do that
22:47:52 <edwardk> yeah
22:48:03 <edwardk> i had forgotten about that feature by the time i reverted to proxy
22:48:30 * elliott actually managed to remove the additional typeclass here
22:48:44 <elliott> i'll put the fast-path for people with 8-byte-pointer systems in
22:48:46 <elliott> because I'm kind
22:49:04 <elliott> edwardk: oh, does FlexibleContexts bother you?
22:49:07 <elliott> it already uses FlexibleInstances
22:49:12 <edwardk> ?
22:49:16 <elliott> in the slow impl
22:49:18 <edwardk> for what?
22:49:29 <elliott> is it ok if i add i
22:49:29 <edwardk> not terribly, but it was kinda nice lacking it
22:49:31 <elliott> *it
22:49:39 * hackagebot tagged 0.3 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.3 (EdwardKmett)
22:49:39 <elliott> edwardk: alright, but that means I have to deunify the typeclasses :P
22:49:51 <edwardk> ?
22:50:02 <edwardk> oh for the pointer silliness
22:50:17 <elliott> because i can do
22:50:18 <elliott> instance (Reifies a IntPtr, Reifies b IntPtr) => Reifies (a, b) IntPtr where
22:50:21 <elliott> and B just disappears
22:50:47 <edwardk> or you can just keep B, because its not a bad approach and it was the whole reason why we switched =P
22:51:11 <elliott> huh? not the whole reason: this keeps the byte-based stuff
22:51:16 <elliott> it just does it with Reifies instead
22:51:23 <elliott> since B s ~ Reifies s IntPtr
22:51:34 <edwardk> oh, that i'd rather not do
22:51:39 <edwardk> because then it'll show in the haddock
22:51:54 <elliott> fair enough
22:51:55 <edwardk> and thats 256 instances
22:51:59 <edwardk> +1
22:52:04 <elliott> oh, right
22:52:30 <elliott> meh, I'll get lhc working then come back to this
22:53:03 <elliott> argh
22:53:05 <elliott> i need darcs
22:53:18 <edwardk> clearly what you should do is exploit the fact that on x64 it only needs 48 bits to store the pointer, and save yourself a byte and a half
22:53:22 <edwardk> ;)
22:54:51 <elliott> what the heck, arch removed darcs
22:55:00 * elliott cries and downloads a binary
22:59:39 * hackagebot comonad 1.1.1.3 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-1.1.1.3 (EdwardKmett)
23:00:44 <elliott> what I'll do is, convince GHC to add the create-an-instance stuff as standard
23:00:48 <elliott> then it isn't a hack any more :P
23:01:00 <gienah> elliott: there are darcs 2.5.2 ghc 7.4.1 patches here (upstreamed months ago) https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-vcs/darcs
23:01:34 <elliott> yeah i just used a binary though
23:01:40 <elliott> since all i need it for is to get cabal-install
23:04:41 * hackagebot contravariant 0.2.0.1 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.2.0.1 (EdwardKmett)
23:04:43 * hackagebot semigroupoids 1.3 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.3 (EdwardKmett)
23:04:45 * hackagebot distributive 0.2.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.2.1 (EdwardKmett)
23:06:13 * elliott really thinks edwardk needs a program for this
23:06:22 <edwardk> good luck with that
23:06:50 <edwardk> i'm sitting here making a lot of required changes in the cabal files as i go about seemingly unrelated but blocking things
23:07:08 <edwardk> its not like im just changing a couple of numbers and going on
23:07:19 * elliott really thinks edwardk needs a medal for this
23:08:18 <edwardk> e.g. transformers 0.3 added a bunch of missing instances
23:08:18 <edwardk> and i'm currently trying to figure out the least crappy way to silence all the warnings from the mkTyCon3 change in comonad-transformers
23:08:49 <elliott> #if __GLASGOW_HASKELL__ < ? :p
23:09:24 <edwardk> yeah
23:09:39 <edwardk> but the trick is reverse engineering the precise version of ?
23:09:49 <elliott> 7.2, isn't it?
23:10:06 <edwardk> somewhere around then
23:10:14 <edwardk> i can use 704 for that i guess
23:10:43 <elliott> oh it was 7.4 i think
23:10:45 <elliott> argh i forget
23:10:54 <edwardk> see? =)
23:12:59 <elliott> whoa, edwardk didn't start category-extras?
23:13:03 <elliott> my whole worldview is torn apart
23:13:11 <edwardk> menendez
23:13:14 <edwardk> then dolio
23:13:28 <edwardk> then i just kept trying to force feed dolio patches faster than he wanted to reinvent them
23:13:49 <elliott> Configuring cabal-install-0.15.0... Setup: At least the following dependencies are missing:
23:13:50 <elliott> Cabal >=1.15.0 && <1.16
23:13:52 <elliott> what the heck
23:14:23 <edwardk> i'm about 3 seconds away from stripping the ".Lazy" versions of the comonads out of comonad-transformers
23:14:30 <edwardk> bringing a little bit of sanity to my universe
23:14:49 <elliott> i'm about 3 seconds away from how is it complaining about Cabal
23:15:11 <gienah> elliott: the tarball I gave earlier builds with version 1.14.0 of the Cabal library
23:15:13 <edwardk> since they "aren't really Functors"
23:15:40 <elliott> gienah: i'm not using that
23:15:43 <elliott> this is about cabal-isntall
23:15:56 <elliott> edwardk: next you will be saying that Reader is not a monad
23:16:01 <elliott> because of _|_
23:16:06 <edwardk> =P
23:16:39 <elliott> how did category-extras go from 0.2 to 0.44.1
23:16:41 <gienah> elliot: it is a cabal-install tarball that is taken from the ghc 7.4.1 source code
23:16:56 <edwardk> because i had a _lot_ of intermediate work on it
23:17:23 <elliott> gienah: huh? ghc 7.4 doesn't ship cabal-install
23:17:31 <elliott> I'm using the darcs cabal-install, like i was for months
23:17:40 <edwardk> elliott: notice the content jump
23:17:49 <gienah> elliott: I don't know why people keep saying that, it is included
23:17:54 <edwardk> elliott: in the meantime i'd been adding those things more or less one at a time
23:18:06 <edwardk> just not pushing to hackage
23:18:18 <edwardk> as hackage was fairly new
23:18:51 <elliott> Thu Mar 29 02:46:53 BST 2012  Duncan Coutts <duncan@community.haskell.org>
23:18:51 <elliott>   * head cabal-install requires head Cabal
23:18:54 <elliott> aw c'mon man
23:18:59 <gienah> elliot: cabal-install is included in the ghc-7.4.1 source code in the directory: ghc-7.4.1/libraries/Cabal/cabal-install
23:19:03 <elliott> I can't just reinstall Cabal
23:19:11 <elliott> gienah: ok then. i prefer darcs cabal-install since it has the modular solver
23:19:26 <gienah> elliott: ok
23:23:19 <elliott> heh
23:23:22 <elliott> it actually needs the darcs cabal
23:23:27 <elliott> is there any way to get darcs cabal without using ghc head?
23:23:32 <elliott> (not -install)
23:25:11 <gienah> elliott: you could get Cabal library with darcs, then install it with: runhaskell ./Setup.hs configure; runhaskell ./Setup.hs build; runhaskell ./Setup.hs install
23:25:22 <gienah> (or it might be Setup.lhs)
23:25:46 <elliott> yeah, but Cabal is a boot package
23:25:52 <elliott> isn't it?
23:26:09 <elliott> yes, it is
23:27:02 <gienah> elliot: yes it is (so you would not want to install it in the global package db as that would break everything)
23:27:56 <gienah> elliot: oh but maybe my suggestion might try to install it in the global db (which would break everything)
23:27:56 <elliott> right, eurgh
23:28:09 <elliott> you know what
23:28:16 <elliott> i'm just gonna roll back to the version before dcoutts did that :p
23:28:45 <elliott> oh, there's a 1.14 branch
23:28:45 <elliott> ok
23:29:41 * hackagebot comonad-transformers 2.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.1 (EdwardKmett)
23:31:14 <gienah> elliott: maybe it might work with the --user configure option:
23:31:31 <elliott> gienah: i just used the 1.14 branch instead
23:31:32 <elliott> all is calm
23:31:50 <elliott> lucky too, as I was a few minutes away from abandoning haskell and going to live in the woods
23:32:00 <elliott> i have these issues with broken computers
23:32:04 <gienah> elliott: ok, great :]
23:32:47 <edwardk> are you planning on building a machine with 128 bit pointers out there in the woods?
23:34:03 <elliott> edwardk: the earth, man
23:34:11 <elliott> the earth has wind-bit pointers
23:34:20 <elliott> addressing river megs of ram
23:34:41 <elliott> if i need to do reflection
23:34:43 <elliott> i'll use a mirror
23:34:45 <edwardk> ah, elliott cracked. reflection tends to do that to a man
23:35:02 <elliott> hey!! you haven't seen what a deer coprocessor can do
23:35:14 <edwardk> my deer coprocessor is shot
23:35:34 <elliott> extract :: Coprocessor a -> a
23:35:55 <elliott> if compute :: Processor a -> Input a -> Output a, cocompute :: Coprocessor a -> ?
23:36:43 <edwardk> its just mpute
23:37:45 <ClaudiusMaximus> > let v.@__ = v ++" "++ __ in "zomg" .@ "snails"
23:37:47 <lambdabot>   "zomg snails"
23:42:26 <elliott> lhc time!
23:43:06 <monochrom> I see that elliott has indeed gone crazy :)
23:43:42 <elliott> i'm not crazy. haskell 2010 is crazy
23:44:00 <elliott> ok this time i'll install lhc in a cabal-dev sandbox so it can't get out
23:44:37 <monochrom> and I have gone crazy too, trying to determine whether "timeout n (readChan c)" will read a channel message and lose it due to perfect timing of the kill-thread.
23:44:41 * hackagebot comonads-fd 2.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.1 (EdwardKmett)
23:45:15 * elliott thinks not
23:45:22 <elliott> since it won't allocate between retrieving and returning
23:46:03 <monochrom> the answer is yes, it can. kill-thread happens at allocation points only, yes, and there is an allocation point right after "readChan c" but before the killer dies
23:46:49 <edwardk> monochrom: ick
23:46:53 <ClaudiusMaximus> i'm implementing something like  (.@) :: (NaturalNumber p, HasPrecision t, RealFloat (t p)) => t p -> p -> t p ; (.@) = const ; data SlowFloat p = SlowFloat !Integer !Int  -- going well so far, except for all the unimplemented methods of Floating :)
23:47:19 <elliott> monochrom: where's that point?
23:47:27 <monochrom> the source code of timeout reads: handleJust blahblah (\e -> return Nothing) (to be revealed next). so far so good?
23:47:34 <elliott> and ugh, async exceptions are out of control
23:47:46 <elliott> starting to think timeout is a bad thing
23:48:25 <edwardk> this reminds me of all the reliability contract checking stuff in c#
23:48:37 <monochrom> ok, here is the rest: bracket (forkIO (threadDelay n >> killThread blahblah)) (killThread) (fmap Just (readChan c))
23:48:54 <edwardk> [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)] blah blah
23:48:56 <elliott> fmap Just
23:48:58 <elliott> sigh
23:49:03 <monochrom> see the "fmap Just" there? it will allocation a Just cell. allocation point!
23:49:14 <elliott> what if we somehow allocated the Just beforehand?
23:49:29 <monochrom> here is the fix: fmap Just (bracket (...) (...) (readChan c))  :)
23:49:30 <edwardk> can you suck it out of the bracket?
23:49:36 <elliott> do { m@(Just x) <- fmap Just (unsafeInterleaveIO (readChan c)); evaluate x; return m }
23:49:38 <elliott> oh that works to
23:49:39 <elliott> *too
23:49:46 <edwardk> there you go
23:49:49 <elliott> actually needs an evaluate m first
23:49:57 <elliott> monochrom: you should submit a patch so i can sleep at night
23:53:08 <monochrom> I am actually not sure that it is enough
23:53:43 <elliott> can we have
23:53:56 <elliott> unmask :: IO a -> IO a
23:54:00 <elliott> yield :: IO ()
23:54:08 <elliott> so that async exceptions are only allowed when we explicitly say they are?
23:54:09 <elliott> that would be nicer :(
23:54:18 <elliott> (unmask is for e.g. unmask $ hugeLongIOOperation)
23:54:31 <shachaf> I think that would be the devil.
23:54:41 * hackagebot comonad-extras 2.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.1 (EdwardKmett)
23:54:43 * hackagebot bifunctors 0.1.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3 (EdwardKmett)
23:54:58 <shachaf> elliott: Doesn't an equivalent interface exist right now?
23:55:04 <elliott> yes, except it's mask
23:55:06 <elliott> instead of unmask
23:55:12 <elliott> which means we get bugs like the above
23:57:28 <danharaj> huh
23:57:36 <danharaj> I never knew about top-level default declarations.
23:59:19 <monochrom> if GHC.Prim.catch# does not add its own allocation points, factoring out "fmap Just" may be enough.
23:59:41 * hackagebot data-lens 2.0.3 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.3 (EdwardKmett)
