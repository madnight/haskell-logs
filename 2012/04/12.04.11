00:00:04 <edwardk> erm what is the return of ConstM?
00:00:33 <edwardk> and >>=
00:01:00 <edwardk> since i'd expect you to need a right seminearring rather than a monoid to get what you want
00:01:13 <zzo38> return = const $ ConstM mempty; fmap _ (ConstM x) = ConstM x; join (ConstM x) = ConstM x; empty = ConstM mempty; ConstM x <|> ConstM y = ConstM (mappend x y);
00:02:57 <zzo38> And I think this is even the only possible implementation of join for this type!
00:03:06 <edwardk> so you are implicitly using the 'First' monoid for the monad
00:03:11 <dp_wiz> How to prevent hslogging messages from appearing twice in http://dumpz.org/194888/ ?
00:03:39 <edwardk> and using the fact that you can build a right seminearring over that for any monoid
00:05:20 <edwardk> but then return a >> Const b  = Const mempty != Const b
00:06:03 <zzo38> O, yes, you are correct. I forgot about that
00:06:32 <edwardk> hence why you need a real seminearring
00:06:56 <zzo38> Which means that it cannot be a monad at all due to the implementation of join I gave being the only possible one as far as I can tell
00:07:08 <edwardk> yeah
00:07:22 <edwardk> it can be an instance of 'Plus' from semigroupoids but thats it
00:08:12 <edwardk> mind you thats enough to use the corrected instance you want
00:08:34 <zzo38> OK
00:09:48 <edwardk> it probably should be one of the Data.Semigroup.* data types in reducers
00:10:02 <edwardk> I've added it to my TODO list for that package
00:11:09 <edwardk> actually i don't really have seminearrings anywhere any more
00:13:49 <edwardk> bah. 'precision' is frustrating me
00:13:55 <zzo38> I think it is Plus even without seminearrings, and if the AltCofree I mentioned is Monad instance based on Plus, then I think you do get the things I have mentioned
00:14:08 <edwardk> Plus works fine, its easy to make a plus
00:14:20 <zzo38> Yes
00:15:29 <edwardk> ok, i have a pretty much complete rewrite of 'free' planned
00:15:34 <dropfatdiva> how can one update the "base" version? I am having install issues because "base" version seems to be quite old. I have done cabal update many times but that doesn't help
00:16:05 <edwardk> dropfatdiva: base is tied to your haskell install, as a rule, you'd install the new version of the haskell platform or ghc, which comes with a version of base more appropriate to modern haskell code
00:16:14 <edwardk> dropfatdiva: what version of ghc are you using?
00:16:21 <zzo38> edwardk: Should you update the leftmost version number in that case of complete rewrites?
00:16:31 <edwardk> (or of any haskell compiler for that matter)
00:16:46 <edwardk> zzo38: i usually do ;)
00:17:15 <edwardk> in this case i need to add the transformer versions of everything while i'm in there
00:17:30 <dropfatdiva> edwardk: I am not sure. I am using ubuntu and had installed haskell-platform a few months back
00:17:43 <edwardk> dropfatdiva: what wants a newer base?
00:18:03 <edwardk> dropfatdiva: type 'ghc -V'
00:18:17 <dropfatdiva> edwardk: while installing leksah. I also saw the same error while trying to install hoogle
00:18:43 <dropfatdiva> edwardk: ghc 6.12.3
00:18:54 <edwardk> dropfatdiva: you are a bit behind the current platform then
00:18:58 <zzo38> Possibly you could call the AltCofree I have suggested to something else if you don't like that name, however. Also, Free and Cofree is not monad/comonad transformers, but you can make FreeT and CofreeT. And then you could have Initialize, Finalize, and the constant functor with Plus (I suppose it can be with Applicative as well; the Plus and Applicative won't contradict each other as far as I can tell)
00:19:07 <dropfatdiva> edwardk: certainly
00:20:05 <edwardk> zzo38: yeah i'm already breaking out a separate FreeT and CofreeT. I'd wanted to avoid them, because if i took the usual transformers approach of just making the transformer versions of everything they _really_ muddle the presentation, but I have to add them.
00:20:22 <dropfatdiva> edwardk: although I had started work with a new "sudo apt-get install haskell-platform" and it informed me that its the latest platform. So probably debian package is not updated. Should I install platfrom from haskell site now without uninstalling this?
00:20:48 <edwardk> dropfatdiva: yes
00:20:58 <edwardk> dropfatdiva: the installer on the platform site works pretty well
00:21:13 <zzo38> edwardk: You are not required to do it that   type Free = FreeT Identity   probably
00:21:46 <edwardk> zzo38: i'm not required to, and i intend to keep Free as a separate type, even though it breaks the convention established with transformers and mtl 2
00:22:11 <edwardk> mostly because its awkward enough pedagogically and with free monads you spend a lot of time pattern matching on them
00:22:15 <edwardk> unlike most monads
00:22:49 <edwardk> plus the infix cofree is a LOT nicer to work with than the CofreeT abomination ;)
00:23:00 <zzo38> Yes, and fix the Alternative and MonadPlus instances for Free.
00:23:09 <zzo38> And I agree with the infix cofree as well
00:23:11 <edwardk> zzo38: i used to have a CofreeT in comonad-transformers
00:23:43 <edwardk> http://hackage.haskell.org/packages/archive/comonad-transformers/1.2.1/doc/html/Control-Comonad-Trans-Stream.html
00:24:39 <edwardk> but i dropped it at some point
00:25:00 <edwardk> so i'll probably just update that code
00:25:27 <edwardk> anyways, i'm going to hunker down and work on some other stuff for a bit
00:25:40 <zzo38> I think I read you wrote somewhere that callCC doesn't work with codensity monad; in (Codensity f) what is the requirement of f such that callCC works?
00:26:47 <zzo38> OK what are you working on now?
00:28:57 <edwardk> i have a package full of colorimetry and photometry data that i'm finishing up
00:31:02 <edwardk> i wound up needing the data with derivatives, and didn't like the GPL license some folks had put on the stuff in PBRT, so I went back to the original sources, found the source spectral density curves, found a bunch of more recent observer models that consider cone distributions in the eye, and have been spline fitting to 1nm resolution data wherever possible to get a rather physically accurate lighting model
00:32:08 * hackagebot splice 0.3 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.3 (CetinSert)
00:32:16 <zzo38> I like GPL, and I use it for standalone programs; for libraries I use public domain to make it compatible with everything
00:33:31 <edwardk> that way i can take standard illuminants with their real spectral densities measured in real wavelengths, deal with BRDF-style reflections off of surfaces, get the response at the camera/scene, and fit it to the photopic and scotopic luminous efficiency functions for different observers, then adjust the scale for the monitor working space and provide various gamut correction styles
00:33:49 <augur> edwardk: my motivation for asking about "cofunction" types is that, in chomskyan style theories, there are occassionally these ideas that when an object combines with another object, it's because the "non-primary" one has some need that is satisfied by the primary one
00:34:03 <edwardk> I go out of my way to release under BSD rather than GPL, but I don't begrudge folks the right to release their code under the GPL
00:34:38 <augur> for instance, if you have the question "who did john see", the idea is that "who" might have raised from its underlying position to the left only because "who" has some property that needs to be discharged
00:34:47 <edwardk> augur: could it just be a function family of some sort so unification is what you need nothing fancier?
00:34:52 <augur> not because the "did john see who" structure has one that needs to be discharged
00:35:28 <augur> edwardk: eh.. maybe, i dont know. but the idea is that the "needer" doesnt end up controlling the behavior of the whole thing that results, in these cases
00:36:03 <edwardk> sounds like a typeclass =P
00:36:11 <zzo38> edwardk: I don't mind GPL especially if later versions are also permitted; and I like to use GPL for standalone programs. So if some libraries are LGPL or GPL I may use them, but I don't like to use them in codes of other libraries because I want to post library codes in public domain (possibly for the same reason you prefer BSD? If you have reason then tell me; maybe it is like my reason too)
00:36:14 <augur> edwardk: how so
00:36:14 <zzo38> Do you (or anyone) has suggestions/complaints about my "dvi-processing" package?
00:37:08 * hackagebot atomo 0.4.0.2 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.4.0.2 (AlexSuraci)
00:37:38 <CQ> zzo38: the debian-legal mailing list (or on irc.oftc.net #debian-devel ) are helpful for license discussions...
00:38:48 <glguy> edwardk: Which Codensity module is the one we are supposed to use?
00:38:56 <glguy> It seems like there are a few of them on hackage
00:39:07 <edwardk> glguy: The one in kan-extensions
00:39:20 <edwardk> The one from category-extras has been subsumed by that
00:40:28 <edwardk> mmtl has one, but mmtl is incompatible with everything, so its kind of a nonstarter ;)
00:41:56 <augur> edwardk: ?
00:43:03 <zzo38> CQ: I just wanted to know, if you like GPL, LGPL, BSD, public domain, etc, in making a Haskell program/library
00:43:04 <edwardk> zzo38: my main reasons for choosing BSD licensing over GPL involve a complicated rant involving second order consequences of the GPL favoring large organizations with high Coase ceilings, and the fact that I do a lot of consulting for companies that choose to bring my software in-house, explicitly because they can, since I work almost entirely in BSD.
00:43:23 <edwardk> That and I'm not on speaking terms with Stallman any more ;)
00:44:28 <edwardk> So I choose not to allow him any say over the legal status and disposition of my code.
00:44:52 <edwardk> But this goes pretty far off topic
00:45:46 <edwardk> augur: just strikes me that you have a function that depends in some way on properties of the types of its arguments, so its not really a function, but a family of them, other than that i have no insights for you
00:46:21 <augur> ok
00:46:54 <zzo38> edwardk: Do you know suggestion/complain for "dvi-processing" package? I already added some stuff not posted yet, including the function to draw a filled triangle on a page; but I have nothing for arbitrary polygons. (Triangle is easy simply split the top part and bottom part)
00:47:11 <edwardk> zzo38: i don't tend to use dvi files for much, so i'm not much use there.
00:49:13 <zzo38> Well, it can still be compared to other typesetting libraries such as HPDF (which is LGPL licensed)
00:49:51 <zzo38> One difference is that HPDF is limited to only a few fonts; dvi-processing can use any TFM font
00:50:44 <earthy> you could take knuth's approach
00:52:32 <earthy> open the source to take as people please, but disallow changes to it while keeping the same name
00:52:36 <zzo38> Still, dvi-processing is not finished; I intend to also add more complicated and better quality line breaking and page breaking and mathematical typesetting and stuff for certain diagrams and so on too. But, I don't know how to make it draw an arbitrary polygon
00:53:26 <zzo38> earthy: I understand you but, I am making it fully public domain; I am not taking that approach
00:54:07 <zzo38> (I do not consider Knuth to be wrong for taking the approach he did, though.)
01:13:33 <earthy> why would you do your own linebreaking when TeX can do that for you?
01:15:27 <zzo38> earthy: Well, I can implement TeX's algorithms; but regardless, this is Haskell package, and it include many things (not on writes DVI files, it can also read DVI files too).
01:15:44 <zzo38> In case you want typesetting with Haskell too
01:27:31 <Liskni_si> nand`: the post is very old, that may be a reason too
01:30:18 <Younder> To prove the correctness of a program is to demonstrate, through impeccable mathematical techniques, that it has no bugs; to test a program is to run it with the expectation of discovering bugs. The two techniques seem contradictory: if you have proved your program, it's fruitless to comb it for bugs; and if you are testing it, that is surely a sign that you have given up on any hope to prove its correctness.
01:30:50 <Younder> what a load of crap
01:31:16 <Younder> from TAP 2012
01:31:20 <danr> Younder: where is that from?
01:31:28 <danr> Which article?
01:31:38 <Younder> http://lifc.univ-fcomte.fr/tap2012/
01:34:24 <gdeest> The number of people in this chan is simply frightening :|
01:34:33 <gdeest> Never knew Haskell was so popular :P
01:35:09 <Twisol> Heh. Haskell blows my mind every time I read more about it.
01:35:32 <Twisol> (In a very, very good way)
01:35:38 <zhulikas> it's not popular. IRC is the only place where haskell people hang out :D
01:35:56 <gdeest> Waiting for a job ? ;P
01:35:56 <bombel8> hi
01:36:09 <zhulikas> some time ago I came across programming language statistics
01:36:10 <gdeest> Hi everyone
01:36:13 <Younder> gdeest, get used to it. We are more than just a prof language now we are getting into industry
01:36:17 <gdeest> (I mean, all 829 of you)
01:36:30 <zhulikas> so haskell is #1 programming language in IRC by popularity
01:36:30 <Starfire> There are many people in this channel, but most of them don't say anything because Haskell programmers are lazy.
01:36:45 <Younder> lol
01:36:51 <Twisol> Starfire: Can't tell if serious or pun
01:36:51 <dp_wiz> `eager = B.pack . L.unpack` is the only way to convert bytestrings from lazy to "normal"?
01:36:53 <gdeest> Younder: I actually love Haskell
01:37:02 <zhulikas> but that doesn't mean anything, because in total it's like #30 or somehting
01:37:04 <gdeest> I was kidding, not trolling
01:37:27 <zzo38> Haskell is good I like it too; but I prefer Ibtlfmm over Haskell, but Ibtlfmm is not completely invented yet so I cannot use that one instead
01:37:38 <Younder> gdeest, I haven't made up my mind yet.
01:38:00 <zhulikas> what the hell is ibtlfmm?
01:38:20 <gdeest> rot13 haskell ?
01:38:21 <shachaf> > map pred "ibtlfmm"
01:38:22 <lambdabot>   "haskell"
01:38:41 <Younder> zhulikas, try hoogle
01:38:49 <zzo38> zhulikas: Some of my idea of making up the new programming language based on Haskell but other things too, to improve things I think are not as good in Haskell (and some other people too)
01:39:05 <zhulikas> why not improve Haskell instead?
01:39:19 <gdeest> Or implementing yet another GHC extension :P
01:39:28 <zhulikas> well, why not :)
01:39:31 <zzo38> zhulikas: There are so many different thing in the design that it has to be made an entirely new one instead
01:39:34 <Starfire> The good news is, the hard-working people who make GHC are already improving things all the time!
01:40:05 <zzo38> Starfire: And, yes; some of their things I disagree, and even then, things that simply cannot be changed also exist in Haskell we cannot fix those
01:40:50 <Starfire> I seriously cannot think of a language that gets so many new features so fast. Whether that's good or not is a matter of opinion, of course.
01:41:07 * gienah is not really sure, is guessing haskell ranking is about 12th on http://redmonk.com/sogrady/2012/02/08/language-rankings-2-2012/
01:41:36 <zzo38> One difference in Ibtlfmm is to minimize the number of special purpose types and classes reserved by the compiler; many can implement using macros and/or other features of the programming language. For example, Ibtlfmm has no do-notation, but something like that can be implemented using macros if you want to have it anyways.
01:41:37 <Younder> Like I prefer mathemaica syntax. Names in Haskell seem arbitrary. Mathematica scores much better on those terms.
01:42:05 <shachaf> zzo38: Does Ibtlfmm have more-notation?
01:42:11 <zhulikas> Starfire, so criteria is stackoverflow. Yet it does not tell much about overall popularity :)
01:42:18 <zhulikas> oh, also github
01:42:20 <Younder> Mathematica is more 'lispy'
01:42:28 <quicksilver> dp_wiz: concat . fromChunks
01:42:58 <zzo38> shachaf: No but you can do WEB-chunks and can implement things like the more-notation and those things by using macros too
01:43:56 <gdeest> I actually like Haskel as it is, but I must say I'm quite afraid of the number of GHC extensions (look at the Yesod framework: it's great and powerful, but it doesn't feel like Haskell anymore)
01:44:01 <gdeest> *Haskell
01:44:02 <Younder> With all respect Monads are usedfor the same things that macr's are in Lisp
01:45:07 <Starfire> And for the same things that inheritance in Java!
01:45:43 <Younder> Hidden state makes parallelism all that more difficult
01:46:55 <zzo38> Other differences to Haskell would be, in Ibtlfmm, we can have, Nat32 instead of Word32, Succ (for successor) instead of Maybe, map instead of fmap; classes can be differences too, so Monad is Functor + return + join, and Monad is really a specialization of MonadC (which itself is a specialization of MonadCR), ...
01:46:55 <Starfire> Does anyone know if the GSoC project to improve Haskell interop with C++ is going to happen?
01:47:16 <gdeest> Younder: you don't *have* to use Monads. Well, except the IO monad. But actually, I don't see how not using monads would help you to parallelize more. Do you have an example or something ?
01:49:10 <Younder> well I'll give you a book title 'Optimizing compilers for moder computers' also 'The art of multiprocessor programming'
01:49:37 <Younder> I cant go into detail because there is way to much of it
01:50:18 <zzo38> And in Ibtlfmm, even the IO monad, you do not necessarily have to use; the main can be any type, although to make standalone programs only certain types can be used for main; IO is one of them, but (unsafe "c_int(c_int,c_char**)") can also be used as the type of main
01:51:16 <gdeest> Younder: thanks for the references, I'll sure have a look at it
01:52:10 <zzo38> The typeclasses are extremely messed up in Haskell so this new one I do differently, they even work differently too in many ways but can still do something similar to the Haskell typeclasses
01:52:25 <Younder> Micro-threading as pascell does is fine for GPU's but is shit for I7
01:52:44 <zhulikas> zzo38, when do you plan to make a first release?
01:55:29 <zzo38> zhulikas: Well, first, we should make up the "Ibtlfmm working group" everyone can discuss/argument to properly make the document
01:56:41 <zzo38> So for now I just have some ideas, some on computer some on my mind. Another difference is semantics of 'undefined' are different in interpreted programs than in compiled programs; in interpreted programs it stop and show the error message like in Haskell, but in compiled programs it results in undefined behaviour instead
01:56:51 <gdeest> Thread 1 on the group will be: what better name should we give it ? :P
01:57:01 <zzo38> (Some people might hate it; if they do, I suppose a compiler option can be available to change this)
01:57:12 <zhulikas> true :D
01:57:14 <zzo38> gdeest: Yes, that is one question too
01:57:35 <zhulikas> zzo38, is Haskell the only language where you get ideas for improvements from?
01:57:50 <Younder> no
01:58:26 <zzo38> zhulikas: No; also Lisp, Forth, LLVM, WEB, etc, and even some mathematical ideas
01:58:42 <gdeest> I would suggest Curry, but as it already exists, I would suggest "Paprika" or "Chili" (...)
01:58:58 <zhulikas> will it be purely functional, lazy and all the other goodies included?
01:59:14 <Younder> One thing I HATE about Haskell is the lack of generalized boolean.
01:59:19 <zzo38> And some ideas based on Magic: the Gathering even though that isn't a programming language either; but it allow some macro to do it
01:59:29 <zzo38> Younder: Yes; then let's post that so we can improve that too
02:00:04 <zzo38> zhulikas: Yes, unless you use the "unsafe" command to make LLVM codes (actually a superset of LLVM with a few new commands to use direct C types and so on)
02:00:07 <cheater_> zzo38 is the person you talk to if you want a lang based on the pokemon card game logic, crossed with chess.
02:00:27 <Younder> Comming fromLisp. I realize it has a weakness. You can't distinguish between fail and empty
02:00:44 <cheater_> what is a generalized boolean Younder?
02:00:47 <zhulikas> :D
02:00:53 <gdeest> It's using an object as a truth value
02:00:54 <gdeest> I think
02:01:08 <gdeest> Not sure I'd really want that in Haskell
02:01:12 <dp_wiz> what's simplest RE package? i need to just extract substring like this: "enct\(p, '([a-z0-9]+)', '\w+'\)"
02:01:15 <zhulikas> I don't see any problems with current Boolean
02:01:16 <gdeest> it's quite ugly / C-ish
02:01:19 <cheater_> that is not "a boolean", that's just an automatic instance
02:01:34 <cheater_> of a typeclass
02:02:25 <zzo38> cheater_: Yes, that is what it would be
02:02:26 <gdeest> It would be something like OverloadedStrings, but for booleans ?
02:02:29 <zhulikas> zzo38, I am not sure about your success in creating a new language. There are too many out there already
02:03:20 <cheater_> gdeest: either way, what you're really talking about is just exception support, and that exists in haskell.
02:03:21 <Younder> cheater_,  well every class is under true except nothing which is null. So if you return 5 ist is true. If you return "true" it is true. The only way to fail is to return nil
02:03:31 <cheater_> er that's for Younder
02:04:06 <cheater_> this autocasting is just an ancient way of doing exceptions, that's all
02:04:15 <zzo38> zhulikas: That is why to make up the "Ibtlfmm working group"; I already started writing a bit of document using Plain TeX but we can improve it as a group together, including to make up the compiler/interpreter
02:04:18 <cheater_> so it's not like you're missing a huge paradigm here
02:04:50 <cheater_> it's more like you're missing a fringe, wrong implementation of a paradigm which is stupid in the first place
02:06:06 <gdeest> it's not stupid, it just comes from very low-level layers I don't want to deal with
02:06:07 <Younder> There is however a HUGE problem with this system. It doesn't distinguish between 'fail' and 'empy'ty.
02:06:16 <gdeest> (assembly's jnz ...)
02:06:54 <gdeest> Either Maybe a ?
02:07:04 <Younder> sorry for the digression
02:08:38 <Younder> gdeest, I design languages, I am looking for a replacement pattern which is more pleasant to work with.
02:08:53 <quicksilver> > Text.Regex.matchRegex (Text.Regex.mkRegex "enct\\(p, '([a-z0-9]+)', '[a-zA-z_]+'\\)") "enct(p, '123', 'abc')"
02:08:54 <lambdabot>   Not in scope: `Text.Regex.matchRegex'Not in scope: `Text.Regex.mkRegex'
02:08:57 <quicksilver> Just ["123"]
02:08:58 <quicksilver> dp_wiz: ^^
02:09:15 <quicksilver> dp_wiz: (\w is a perl extension, I think, and Text.Regex is posix)
02:09:45 <zzo38> I do have currently idea of the kinds of Ibtlfmm: * for normal types (having values), # for low-level types, ? for * or # types, + which is a subkind of * and is the kind of natural numbers, & for constraints, @ for program modules, {} for types lifted to kinds (and values of that type lifted to types), -> for parameters, and capitalized names for user-defined datakinds.
02:09:55 <Younder> quicksilver, so use the Perl regex system istead and always
02:11:46 <Younder> quicksilver, Perl SET the new standard
02:12:57 <zzo38> You might want to mention the type given as one of the * parameters inside of a {} kind so currently I have thought of the syntax () afterward with the lowercase name inside which is referred to in {} but other syntax can be suggested if you have a better idea
02:15:31 <zzo38> If you have the ability to override instances and hide instances, but can cause problems with certain parts of the program, a way to solve this is that datatype declarations can include a constraint on them; these are entirely different from the constraints on datatype declarations in Haskell. (Constraints on the constructors, however, are the same as in Haskell.)
02:17:48 <zzo38> For example, let's say, there is some type X and there is an instance Ord X in some module; in another module you have a different instance Ord X which overrides that one. Now we have    data Ord x => Z x = ... ;    This means that (Z X) is a different type in the different modules since their (Ord X) instances differ.
02:19:07 <zzo38> Do you understand what I mean (whether you agree or disagree)?
02:20:07 <gdeest> Yup I understand
02:20:33 <gdeest> This is messy
02:20:59 <zhulikas> overrides? can't you differentiate them and make both available?
02:22:01 <zzo38> zhulikas: I suppose you can if they are qualified (for example, it would be needed if you have a value of type (Z X) from another module which is not compatible with your own (Z X); then you need to import it qualified)
02:23:00 <zzo38> (The Z are the same, and the X are the same; but Z X is different due to the implicit instance tag which the declaration of Z declared it to have)
02:35:30 <sajith> anyone i can bug with Repa questions here?
02:36:19 <sajith> How do you force a delayed array to manifest array?  Repa 2 had a "force" function, but Repa 3 doesn't have that.
02:37:56 <srhb> sajith: Isn't that "now"? I can't remember really.
02:44:35 <t7> now :: (Shape sh, Repr r e, Monad m) => Array r sh e -> m (Array r sh e)
02:44:37 <t7> yar
02:46:08 <sajith> t7: hmm, that doesn't say anything about representation, does it?
02:46:30 <sajith> t7: not that I know what I'm talking about...
02:46:59 <t7> it doesnt look like it turns a D into anything else :|
02:47:08 <t7> i give up
02:48:00 <sajith> me too, I guess..
02:48:05 <ClaudiusMaximus> hm, ouch.. gmp: overflow in mpz type
02:48:05 <ClaudiusMaximus> Aborted
02:48:21 <sajith> been up all night. :)
02:48:57 <sajith> all Repa documentation basically talks about Repa 3, and it's been a struggle figuring out the differences..
02:49:29 <sajith> err, I mean, documentation talks about Repa 2, not Repa 3..
02:50:19 <sajith> srhb, t7: thanks for helping though. :)
03:08:28 <nozim> Hello gentleman :)
03:08:35 <nozim> Hello gentlemen :)
03:09:24 <sipa> main screen turn on
03:09:53 <danr> what you say!?
03:11:00 <nozim> Hi therre!
03:15:58 <liyang> you have no chance to typecheck make your time
03:27:18 * hackagebot splice 0.3.1 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.3.1 (CetinSert)
03:28:34 <t7> anyone know how to give a user permission to edit a folder
03:28:42 <t7> i made a folder as root by accident
03:29:56 <quicksilver> chown
03:30:02 <quicksilver> chown it to the user you want to own it.
03:31:25 <t7> ah thanks
03:35:55 <t7> anyone know about x86 in here. can i do this: mov [char], [SP + 1] ?
03:36:18 <mauke> what are you trying to do?
03:37:50 <quicksilver> perhaps he's trying to think of the most random non-haskell questions to ask in here and see if people answer?
03:38:25 <t7> lets say i push 123, push 321, i wanna make 123 into [char]
03:38:39 <kallisti> quicksilver: oh I've got one.
03:38:41 <mauke> a list of chars?
03:38:43 <mauke> huh?
03:39:06 <t7> no [] means indirection
03:39:14 <kallisti> how can I rewrite a + 2c = 2(m - n + 2c)    as the equation  a + 2c = 3k, for some integer k.
03:39:16 <t7> (x86)
03:39:19 <kallisti> all other variables are integers as well.
03:39:29 <kallisti> quicksilver: thanks for the opportunity.
04:05:42 <ClaudiusMaximus> mm, so bit (2^37) -> gmp aborts horribly; bit (2^36) -> gmp tries to allocate 8GB and crashes - now i need to find where in my code it's happening :/
04:06:17 <roconnor> @type bit
04:06:17 <lambdabot> forall a. (Bits a) => Int -> a
04:06:35 <roconnor> > 2^36
04:06:36 <lambdabot>   68719476736
04:06:38 <osager> hi all how to run external command "ls " and get results into a list of strings
04:06:40 <osager> ?
04:06:43 <roconnor> > 2^(2^36)
04:06:48 <lambdabot>   mueval: ExitFailure 1
04:06:48 <lambdabot>  mueval: Prelude.undefined
04:06:57 <kallisti> osager: first you should consider if you want your code to be portable or not.
04:07:06 <osager> no
04:07:08 <bombel8_> 2^36
04:07:14 <osager> not portable
04:07:16 <bombel8_> > 2^36
04:07:18 <lambdabot>   68719476736
04:07:27 <bombel8_> > 36^36
04:07:28 <lambdabot>   106387358923716524807713475752456393740167855629859291136
04:07:33 <kallisti> osager: anyway the portable solution is likely simpler, try http://hackage.haskell.org/packages/archive/directory/1.1.0.1/doc/html/System-Directory.html
04:07:39 <kallisti> specifically getDirectoryContents
04:07:49 <osager> yeah that's better
04:07:50 <osager> thanks
04:08:10 <kallisti> no problem.
04:08:39 <kallisti> osager: some things to note:  . and .. are included. you need the directory package installed (which you probably do)
04:09:36 <kallisti> I often want something like:  filter (not . (`elem` [".",".."])) <$> getDirectoryContents blah
04:11:25 <danr> @type notElem
04:11:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:12:24 * hackagebot liblastfm 0.0.2.2 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.2.2 (MatveyAksenov)
04:27:26 * hackagebot splice 0.3.2 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.3.2 (CetinSert)
04:28:02 <arossouw> wonder what i'm doing wrong there
04:29:30 <kallisti> does anyone know of a library on Haskell that does Agda mixfix parsing?
04:31:35 <liyang> Yes, you can find it in the Agda package.
04:31:53 <quicksilver> kallisti: I'm not aware of anything apart from agda itself.
04:32:05 <merijn> arossouw: Which "there" are you referring to?
04:32:26 <kallisti> oh, Agda is written in Haskell?
04:32:29 <danr> kallisti: yes
04:32:36 <kallisti> cool.
04:32:49 <merijn> It compiles to haskell too, doesn't it?
04:33:10 <arossouw> http://hpaste.org/66804
04:33:37 <quicksilver> it compiles to not-haskell, AFAIR :)
04:33:43 <quicksilver> compile to GHC you might call it?
04:35:24 <liyang> With lots unsafeCoerces that destroy performance last I heard. (GHC doesn't optimise through them.)
04:35:32 <liyang> (Which was a while ago.)
04:35:35 * kallisti wants to play around with language syntax for defining DSLs, and figured mixfix would be a good starting point.
04:36:25 <danr> merijn: there is a c backend via epic too
04:37:57 * kallisti see no reason not to have extensions for overloading every bit of literal syntax in Haskell.
04:38:15 <kallisti> except maybe tuples, since that would be somewhat tedious.
04:39:38 <kallisti> overloaded characters, yeaaaah.
04:40:19 <kallisti> just imagine, you could overload characters and convert them Words. who cares about runtime errors, I want Haskell to be more like C.
04:43:21 <kallisti> these equivalence relation proofs are brutal.
04:43:34 <kallisti> 20 homework problems assigned. each proof covers about 3/4ths of a college ruled sheet of paper.
04:45:50 <hpaste> osager pasted “variable scope” at http://hpaste.org/66805
04:45:53 <ClaudiusMaximus> found it (thanks to a useful trace from +RTS -xc) - was some unchecked malconvergence in my Newton's method implementation shooting off to infinity...
04:46:13 <osager> hi anyone take a look at my code why the variable files not in scope ?
04:46:20 <mcstar> is it possible that System.Random.Mersenne is still much much slower than rand() of C, or System.Random of .net?
04:46:25 <kallisti> osager: sure
04:47:00 <merijn> Anyone got a link to some nice examples of the reader monad?
04:48:09 <ClaudiusMaximus> osager: use 'let' instead, the 'where' only sees things that are in scope before the start of the 'do' blcok
04:48:30 <mcstar> the doc of System.Random.Mersenne says something about compiling it with -fuse_sse2, ghc has only -msse2, and the doc also says, cabal install -fuse_sse2 , wth is that?
04:48:53 <kallisti> mcstar: it's likely a cabal option
04:48:59 <osager> thanks claudiusmaximus
04:49:03 <kallisti> mcstar: well, maybe.
04:49:07 <kallisti> let me check
04:49:11 <osager> do you mean before the start of do black ?
04:49:19 <kallisti> no, within it
04:49:23 <ClaudiusMaximus> mcstar: it's probably a flag specific to that package's .cabal file
04:49:26 <kallisti> nothing you bind within the do block is in scope outside of it.
04:49:41 <osager> so where starts a new scope then ?
04:49:44 <kallisti> only within preceding lines of the do block.
04:49:53 <kallisti> do {x <- y; ...}
04:49:56 <kallisti> x is now in scope within ...
04:50:02 <kallisti> but nowhere else
04:50:03 <liyang> osager: within a do-block, you can write let foo = bar, without 'in'.
04:50:29 <sanjoyd> do { let foo = bar; x } == let foo = bar in do { x }, I think.
04:50:30 <kallisti> mcstar: http://hackage.haskell.org/packages/archive/mersenne-random/1.0/mersenne-random.cabal  yeah it's a cabal build flag
04:50:56 <ClaudiusMaximus> osager: do { f <- blah; let { a = b f ; g = c f ; ... } ; theRest a g }  (but with layout instead)
04:50:59 <osager> so how should i correct my code ?
04:51:08 <kallisti> do {x <- y; let z = f x; return g z}
04:51:09 <mcstar> my F# code runs a bit faster than my c++ one, and much faster than the haskell one, it uses a hastable, a random number generator, and SHA256
04:51:19 <dropfatdiva> I am facing an error similar to http://hackage.haskell.org/packages/archive/cairo/0.12.2/logs/failure/ghc-7.2 Does any remedy exist for this? I am using Ubuntu
04:51:19 <kallisti> is the same as putting the rest of the do block inside a let expression
04:51:32 <kallisti> so  do {x <- y; let z = f x in return (g z) }
04:51:35 <mcstar> and i dont think the hashtable is the problem
04:51:39 <kallisti> (oops I meant return (g z) in the first snippet)
04:51:52 <mcstar> (and no, i didnt profile the haskell code, since im a noob)
04:52:05 <kallisti> did you compile with -O2?
04:52:10 <mcstar> O3
04:52:15 <mcstar> and tried fllvm too
04:52:17 <kallisti> I don't think that actually does anything, but okay.
04:52:25 <kallisti> (it's going to be equivalent to O2 at least)
04:52:32 <mcstar> mono + llvm is very fast in this case
04:54:00 <kallisti> osager: anything that refers to files must preceed its definition within the do block.
04:54:15 <kallisti> I'm not going to give you answer :P
04:54:19 <kallisti> +the
04:54:21 <osager> ok
04:54:24 <osager> i get it
04:54:28 <osager> so i'll use let instead
04:54:32 <kallisti> yes
04:54:55 <mcstar> if i dont do the SHA256 hashing, it gets a bit faster, but not much, and a hashtable insert/find test shows it is as fast as c++'s unordered_map, so thats why i think the random number generations is the bottleneck
04:55:17 <kallisti> mcstar: are you using some sort of SHA package? it may not have been compiled with -O2
04:55:34 <kallisti> by default cabal uses -O2. I would think a SHA package would specify -O2 though.
04:55:38 <mcstar> but as i said, probably it isnt the problem
04:55:46 <mcstar> i want to optimize the mersenne package
04:56:04 <kallisti> well mersenne-random uses -O2 it seems
04:56:32 <dropfatdiva> nobody has seen that error?
04:56:57 <bitonic> dropfatdiva: did you try to install gtk2hsC2hs ?
04:57:05 <bitonic> well, the more recent version
04:57:33 <dropfatdiva> i installed gtk2hs-buildtools
04:57:50 <kallisti> this is a hackage-side build error so I don't think that would matter.
04:58:08 <kallisti> dropfatdiva: can you relax that dependency and still build?
04:58:29 <dropfatdiva> kallisti: I am seeing this error while trying to install leksah
04:58:41 <kallisti> oh
04:59:50 <kallisti> hm I don't even see a 0.12.4 or 5 on Hackage...
05:00:01 <kallisti> er, let alone 13..
05:03:42 <osager> hi i have 6 list of string, i want to concact each element of the 6 and finally get 1 list
05:04:05 <osager> how do i do it ? i know i can ust zip concat list1 list2 ...
05:04:11 <osager> but zip only support 5
05:04:51 <osager> by concat i mean element 1 of list1 concat with element 1 of list 2 ...etc
05:06:28 <osager> ok list comprehension
05:06:30 <osager> ...
05:08:39 <kallisti> osager: also zipWith
05:11:23 <quicksilver> osager: map concat . transpose ?
05:11:25 <mcstar> kallisti: i think i reinstalled mersenne with sse2, but seems not to make a difference
05:11:53 <quicksilver> > transpose $ [[1,2,3],[4,5,6],[7,8,9]]
05:11:54 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
05:12:01 <quicksilver> or maybe just transpose
05:12:04 <quicksilver> depends what you meant
05:12:45 <hiptobecubic> edwardk, ping
05:12:53 <edwardk> pong
05:13:56 <mcstar> stupid question probably, but is there a compatibility layer for .net from haskell?
05:14:27 <edwardk> mcstar: not currently. there was a .net bridge project a few years ago though
05:16:10 <mcstar> i have a list of random Word8's, but sha needs a bytestring, so it B.pack (take n list), can this be a performance hit?
05:16:21 <mcstar> it->i do
05:17:17 <Botje> not if the pack can be fused with the process that generates your random numbers
05:17:40 <Ragnaroek> my process, creates with createProcess dies after a few secons with "interrupted system call" (MacOS)
05:17:43 <mcstar> sha expects a lazy bytestring though
05:20:22 <merijn> Ragnaroek: Your process is getting signalled while inside a system call
05:20:44 <merijn> And whatever haskell code you are using apparently does not gracefully handle the error return
05:21:14 <mcstar> http://sprunge.us/aWOd http://sprunge.us/IbVN here are the codes, if anyone is interested
05:21:23 <Ragnaroek> but what could cause that, starting the process on the terminal works perfect
05:21:37 <edwardk> hiptobecubic: any particular reason for the ping? =)
05:21:44 <merijn> Ragnaroek: Depends on what signal it's getting
05:25:20 <Ragnaroek> im running the program in ghci
05:28:20 <Michael_b> Hi, can anybode here help me with a piece of code or at least point me to some relevant learning material?
05:28:44 <merijn> Michael_b: Depends, how big is this piece of code?
05:30:35 <Michael_b> https://gist.github.com/2359042
05:30:57 <Michael_b> I probably don't quite get working with monads yet..
05:30:59 <Ragnaroek> I'm trying to execute mpg321
05:31:22 <Michael_b> Right, and the error is: Couldn't match expected type `IO b0' with actual type `Tree a0'     In the return type of a call of `Node'
05:31:29 <hiptobecubic> edwardk, yes. I was hoping you knew something about Asian style options based on your background because I am having trouble seeing how they work in practice. But i think i may have figured it out? Sorry to perturb you hard at work :)
05:31:39 <quicksilver> Michael_b: you can't just "line" the call to scanDir in the constructor
05:31:50 <quicksilver> Michael_b: calls to monadic actions have to be "explicit"
05:32:18 <mauke> quicksilver: that sounds complicated
05:32:18 <edwardk> Fair enough. lemme know if i can help. going afk for a bit though
05:32:38 <quicksilver> Michael_b: do subdir <- scanDir (path++file); return (Node file subdir)
05:32:39 <mauke> I think looking at the types is much simpler
05:32:45 <quicksilver> mauke: I probably didn't say it well.
05:32:46 <Ragnaroek> and that's the code: http://pastebin.com/hmAaY9X4
05:32:48 <mauke> The paste hmAaY9X4 has been copied to http://hpaste.org/66808
05:32:59 <Ragnaroek> for testing
05:33:44 <mauke> Michael_b: why does pathsAndFiles exist?
05:35:06 <mekeor> Michael_b: mauke means that you could just write "tree <- forM (zip (repeat path) files) $ \(path, file) -> do", right, mauke ?
05:35:15 <Michael_b> mauke: From a previous version of that code, I forgot to edit it out
05:35:21 <mauke> mekeor: no
05:35:22 <mekeor> ah
05:35:25 <mekeor> mauke: oh.
05:35:37 <mauke> mekeor: tree <- forM files $ \file -> do
05:35:49 <mekeor> ah, okay.
05:35:56 <mauke> repeat path ... -> path makes no sense
05:36:05 <mekeor> oh, yea, of course :)
05:37:07 <Michael_b> quicksilver, mekeor, mauke: Ok, thanks for the nudge
05:42:53 <mcstar> kallisti: now, when i use the mersenne random gen. and am not hashingg with sha256, it becomes much much faster, so this generator is actually faster than System.Random, but data.digest.pure.sha is slow, as promised in the dock
05:43:13 <mcstar> unfortunately crypto doesnt build with ghc 7.4
05:43:34 <mcstar> this concludes my testing
05:44:26 <kallisti> mcstar: aha
06:01:04 <osager> how to print a type of something
06:01:21 <gnoi> :t "pisya"
06:01:22 <lambdabot> [Char]
06:01:28 <osager> i'm debugging my program and i want to see the type of a foo
06:01:39 <osager> i'm not in ghci
06:01:48 <osager> can i use print type foo
06:01:55 <osager> is there such a thing ?
06:02:24 <Ragnaroek> at runtime?
06:02:39 <osager> yes at runtime
06:05:04 <byorgey> osager: if it has a Typeable instance you can  import Data.Typeable and then  print (typeOf foo)
06:05:26 <Axman6> there aren't really types at runtime, part of having a static type system is that all types are known at compile time, and do not need to be known at runtime
06:05:34 <byorgey> osager: that's kind of an odd thing to want to do though =)
06:06:36 <byorgey> osager: there won't be any surprises.  it won't be different from run to run.  Presumably you should already know what the type is.
06:25:34 <osager> hi all how can i run this long terminal command in haskell: echo "1order  " | mailx foo@gmail.com -s "1order "-a brit_bubbles_grey.png
06:25:51 <osager> i know rawSystem, but doesn't work
06:26:14 <osager> what i tried is to put echo "1order  " | mailx dawei.atwork@gmail.com -s "1order "-a brit_bubbles_grey.png inside a haskell string
06:26:23 <osager> and then use rawSystem on that string
06:26:31 <osager> but doesn't work
06:26:38 <mauke> "doesn't work" is meaningless
06:26:40 <osager> i understand why but
06:27:03 <osager> doesn't work means that rawSystem's first argument should be a system command
06:27:48 <mauke> why are you using rawSystem and not system?
06:28:01 <osager> there's system ?
06:28:11 <mauke> how did you find rawSystem?
06:28:49 <osager> i read it from realworld haskell, the book
06:29:56 <mauke> http://book.realworldhaskell.org/read/systems-programming-in-haskell.html#ftn.id664371
06:34:12 <merijn> I have some (mostly IO based) code which needs access to some global state (it would probably be sufficient to just hand everything an MVar from which it could access that state, I know that this is supposedly what the Reader monad is for, but I'm not really sure how to adapt my existing code to this...
06:35:00 <zomg> You could use a ReaderT IO
06:35:22 <zomg> So you get Reader and can use lift to get IO
06:37:38 <merijn> zomg: I'm sure that's 100% correct, it's however also completely useless to me as it doesn't help me understand how to best retrofit my existing code to support this...
06:38:02 <zomg> Hehe yeah I guess
06:38:27 <zomg> Not that much of a Haskell pro myself so I would say it might be correct though ;)
06:38:40 <zomg> Wouldn't say 100% tho :D
06:39:28 <quicksilver> merijn: what part of your existing code do you imagine needs "adapting"?
06:39:42 <quicksilver> without knowing much about how the existing code works it's hard to advise on how to change it.
06:42:00 <quicksilver> ReaderT IO is just a funny way of adding an extra parameter to everything that needs it. You can switch between the two styles by judicious use of ReaderT/runReaderT
06:42:36 * hackagebot deepseq-th 0.1.0.3 - Template Haskell based deriver for optimised NFData instances  http://hackage.haskell.org/package/deepseq-th-0.1.0.3 (HerbertValerioRiedel)
06:43:26 <merijn> quicksilver: I'm hacking together a simulation where we have separate nodes communicating over channels (nodes are currently implemented as "Chan a -> Chan a -> IO ()"), the IO () part needs to update some global MVar with some state. The setup process recursively setups a graph of connected nodes. So I want to create a single MVar at the start and pass that throughout the creation process so that every nodes becomes "MVar State -> Chan a 
06:43:26 <merijn> Chan a -> IO ()"
06:46:05 <quicksilver> merijn: ok.
06:46:29 <merijn> Preferably this shouldn't involve explicitly passing the MVar in every function call, 'cause that would kinda suck rewriting wise
06:47:03 <quicksilver> dunno.
06:47:07 <quicksilver> there are trade-offs
06:47:27 <quicksilver> ReaderT certainly handles the "implicitly passing MVar to called actions" part.
06:47:49 <quicksilver> on the other hand it forces you to explicitly lift all your IO
06:48:03 <Zariel> is there a better way to define many value constructors for a data type?
06:48:29 <Cale> Zariel: define fewer constructors? ;)
06:48:56 <Zariel> Cale: :)
06:49:02 <byorgey> Zariel: "better" = ?
06:49:03 <Cale> Zariel: often it's possible to break up a type with lots of cases into simpler datatypes
06:49:25 <Zariel> these are distinct values of a type
06:49:35 <Zariel> so i guess the only way will be use many | .. | ..
06:49:35 <byorgey> define more constructors!
06:49:43 <Cale> But yeah, the best way to do that is application-specific
06:49:48 <byorgey> if your goal is to define many value constructors, then more is better! ;)
06:49:58 <Cale> byorgey: lol
06:50:18 <merijn> quicksilver: I'm open to alternatives, just not really sure what the options are, if any
06:50:42 <quicksilver> merijn: there is no good way to do it totally "magically"
06:50:50 <quicksilver> merijn: totally "magical" global mutable state is evil.
06:51:00 <Cale> Zariel: for example, if you have a type for playing cards, you wouldn't define 52 separate constructors -- you'd define a card in terms of a suit and rank
06:51:02 <quicksilver> merijn: so, it's going to come out somewhere in your types and/or calling convention
06:51:14 <osager> is mapM lazy ? i mean i'm using mapM system listOfCmd to run a series of external command, will the external command run one by one ?
06:51:29 <Cale> Zariel: and your Suit type would have only 4 constructors, and Rank might either be a numeric type, or one with 13 constructors.
06:51:36 <quicksilver> merijn: within those constraints there are some trade-offs and the best point will depend on the details of your coding style and what API you plan to present.
06:51:50 <Zariel> Cale: yeah, these are more distinct, hl7 messages, segments and fields and datatypes
06:51:50 <Cale> osager: they will all run
06:52:02 <osa1> does anyone here know a brainfck interpreter written in haskell? I've just written one for learning purposes and I want to see more idiomatic ways https://gist.github.com/2358925
06:52:03 <Zariel> so there are a quite a few segments
06:52:09 <merijn> quicksilver: I'm tempted to just do unsafePerformIO newEmptyMVar at the top level
06:52:38 * hackagebot test-shouldbe 0.2.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/test-shouldbe-0.2.0 (SimonHengel)
06:52:48 <Cale> osager: Executing mapM f xs will execute every action in map f xs in sequence before producing a result (which will be a list of all the results of the actions)
06:52:59 <quicksilver> merijn: I can't really be expected to deal with your sinfulness. That's between you and your god.
06:53:04 <merijn> quicksilver: I don't plan to represent anything, in good academic style I plan to throw away the code the second I have enough measurements to argue for an actual implementation :p
06:54:14 <quicksilver> merijn: so you have to weigh the practical constraints of (1) whether GHC will do the wrong thing and inline your mvar in some cases but not others leading to hard-to-debug errors (2) whether some practical experience in how ReaderT works would be good for your long-term evolution as a programmer.
06:55:36 <byorgey> @remember quicksilver <merijn> I'm tempted to just do unsafePerformIO newEmptyMVar at the top level <quicksilver> I can't really be expected to deal with your sinfulness. That's between you and your god.
06:55:36 <lambdabot> I will never forget.
06:57:26 <mekeor> lol
06:57:49 <merijn> Oh well, I'm a sinful person. Making other programmers cry is one of my main hobbies
06:58:01 <merijn> Which is one of the reasons my colleagues won't let me learn C++...
06:58:17 <quicksilver> there should be a kickstarter
06:58:29 <quicksilver> "donate to prevent merijn from learning C++ - FOR THE GOOD OF HUMANITY"
06:58:36 <byorgey> hehehe
06:58:47 <merijn> So for now I'm restricted to template programming in CPP
06:59:12 <byorgey> ow my brain
06:59:20 <byorgey> I think you sprained it
06:59:25 <mekeor> what is about C++ ?  why shouldn't merijn learn it?
06:59:37 <hpc> mekeor: for one, the grammar is turing-complete
06:59:41 <hpc> pick a feature, any feature
06:59:47 <hpc> and C++ can have it at compile-time
07:00:00 <mekeor> hmm
07:00:05 <merijn> mekeor: Fear of horrible template voodoo
07:00:05 <hpc> dependently-typed C++? why the hell not!
07:00:15 <mekeor> :D
07:00:22 <hpc> oh man, someone should do that
07:00:36 * mekeor doesn't really know C++-templates..
07:00:39 <merijn> I have about 800 lines of template CPP in my current codebase
07:00:40 <osager> hi how to remove all spaces from a string
07:00:49 <hpc> :t filter
07:00:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:00:53 <mekeor> :t isSpace
07:00:54 <lambdabot> Char -> Bool
07:01:07 <hpc> > filter (not . isSpace) "something like this"
07:01:11 <lambdabot>   "somethinglikethis"
07:01:12 <osager> ok
07:01:14 <osager> thanks
07:01:32 <byorgey> > filter (not . isSpace) "note\tthis\nremoves\rother things too"
07:01:34 <lambdabot>   "notethisremovesotherthingstoo"
07:01:43 <hpc> (the predicate is true for stuff you want to keep, which can be hard to remember from just the name)
07:01:51 <mekeor> osager: or, do you only mean ' ' by "space" ?  if so, you should do:  filter (/=' ') "foo bar baz"
07:02:02 <osager> i meany any space
07:02:05 <mekeor> ok
07:02:07 <Hexmind> Hey I have a question, for some reason I keep getting:  cannot find input file: `base.buildinfo.in, depends on base-4.5.0.0 which failed to install. I am running GHC 7.4.1
07:02:43 <byorgey> Hexmind: nothing should be trying to install base.
07:02:59 <byorgey> Hexmind: base comes with and is intimately tied to GHC.  Reinstalling it is Bad (tm)
07:03:10 <byorgey> Hexmind: what exactly are you trying to do?
07:03:44 <Hexmind> byorgey: I understand, and the package unix-2.4.2.0 is having an issue because it requires base >=4.2 && < 4.4 and I have 4.5 installed
07:04:09 <byorgey> Hexmind: well, you cannot use that version of unix with GHC 7.4.
07:04:14 <byorgey> Hexmind: why do you need that version of the unix package?
07:04:44 <Hexmind> byorgey: I am just trying to install Hakyll and it's dependencies like pandoc
07:04:46 <byorgey> the latest version is 2.5.1.0, and it works with base-4.5
07:04:50 <dmwit> (You shouldn't try to reinstall any of the packages listed here: http://www.haskell.org/ghc/docs/latest/html/libraries/, which includes unix.)
07:05:14 <byorgey> Hexmind: I have installed hakyll and pandoc on ghc-7.4 with no problems.  What version of hakyll are you trying to install?
07:05:21 <byorgey> Hexmind: also, have you done a 'cabal update' recently?
07:05:28 <mcstar> what is 'forall'? i keep seeing in some signatures, but not others
07:05:42 <quicksilver> not all packages on hackage are ready for GHC 7.4, Hexmind
07:05:48 <byorgey> hakyll and pandoc are, though.
07:05:52 <hpc> mcstar: it's not important, most of the time
07:05:52 <quicksilver> although byorgey says hakyll worked for him...
07:05:53 <dmwit> mcstar: It's a piece of explicit syntax for bringing type variables into scope.
07:05:58 <hpc> just lists the type variables
07:06:02 <hpc> :t map
07:06:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:06:06 <hpc> :t id
07:06:07 <lambdabot> forall a. a -> a
07:06:09 <hpc> :t const
07:06:10 <lambdabot> forall a b. a -> b -> a
07:06:11 <Hexmind> byorgey: Yes I have tried that several times, maybe I need to upgrade cabal as well. I went with haskell-platform from sid on Debian
07:06:17 <hpc> :t runST -- here's a case where it does matter
07:06:18 <lambdabot> forall a. (forall s. ST s a) -> a
07:06:24 <quicksilver> mcstar: lambdabot is using an extension which always displays foralls
07:06:26 <byorgey> Hexmind: you shouldn't need to upgrade cabal.
07:06:29 <Hexmind> using version 1.10.1.0 of the Cabal library
07:06:34 <mcstar> thanks
07:06:34 <Clint> Hexmind: there is a working hakyll in debian sid
07:06:35 <byorgey> yes, that's fine.
07:06:54 <dmwit> Hexmind: If you're using the Platform... are you sure you're on GHC 7.4?
07:06:57 <quicksilver> mcstar: in standard haskell foralls are implicit (and, the keyword doesn't exist at all)
07:07:11 <osager> hi all how can i use mapM renameFile oldlist newlist ?
07:07:15 <dmwit> The latest Platform has GHC 7.0.4.
07:07:20 <Clint> dmwit: it's temporarily skewed from the platform
07:07:24 <osager> or isthere some other way to rename a list of filenames ?
07:07:34 <Hexmind> byorgey: You are right there were packages on sid, I am trying those now.
07:07:41 <osager> because mapM renameFile oldlist newlist is not correct
07:07:50 <dmwit> Clint: If you're using GHC 7.4, you're not using the Platform.
07:08:00 <byorgey> osager: try zipWithM instead of mapM
07:08:06 <Clint> dmwit: right, what i'm saying is that the debian haskell-platform package is not truly the platform
07:08:08 <osager> thanks
07:08:10 <osager> but why
07:08:12 <rwbarton> currently he has claimed "cannot find input file: `base.buildinfo.in, depends on base-4.5.0.0 which failed to install." and "I have 4.5 installed"
07:08:17 <dmwit> okay
07:08:20 <quicksilver> osager: look at the types of zipWithM and mapM
07:08:22 <byorgey> osager: because mapM takes a function of one argument and a single list.
07:08:30 <byorgey> osager: you are trying to use a function of two arguments and two lists.
07:08:38 <osager> got it
07:08:41 <dmwit> Yeah, something isn't adding up here.
07:08:43 <osager> thanks everyone
07:09:19 <byorgey> Hexmind: can you run the following and paste the output to hpaste.org: 'ghc-pkg list', 'cabal install --dry-run -v hakyll'
07:09:28 <quicksilver> the debian haskell platform is a meta-package which contains the same packages as the platform
07:09:32 <quicksilver> *but not the same versions*
07:09:36 <byorgey> aha
07:09:43 <quicksilver> so the sid haskell-platform is ghc 7.4
07:09:46 <quicksilver> http://packages.debian.org/sid/haskell-platform
07:10:01 <Clint> hopefully fixed with the next platform release
07:11:53 <Hexmind> byorgey: I think the debian package may have fixed things as it added a long list of libghc-* which were previously missing
07:12:11 <byorgey> ah, ok
07:12:15 <arossouw> whats the fastest way to manipulate and read data from plain-text?
07:12:23 <byorgey> overeager package splitting, eh? =)
07:12:41 <byorgey> arossouw: readFile ?
07:12:51 <arossouw> from what i've read bytestring's normally when you have integers
07:12:57 <arossouw> byorgey: ok
07:13:00 <byorgey> arossouw: oh, wait, by 'fastest' do you mean 'fastest for the programmer' or 'fastest run time' ?
07:13:12 <arossouw> fastest run time
07:13:15 <byorgey> oh, then I don't know
07:13:23 <arossouw> k
07:13:37 <dmwit> Also, is it really plain text or are you actually planning on doing some parsing?
07:13:46 <arossouw> parsing
07:13:58 <arossouw> from file output text/plain; charset=us-ascii
07:14:37 <dmwit> I would recommend using Text if it's supposed to contain text in some bits, and ByteString if it's a binary format.
07:14:48 <arossouw> example : http://hpaste.org/66812
07:14:56 <arossouw> ok
07:20:45 <scooty-puff> is there a paper or other that illustrates HM(X) and normalization for a few X's, with explicit substitution application?
07:21:17 <zhulikas> how can I easily return all possible subsets of given size of set?
07:21:22 <scooty-puff> when writing a module to perform type inference over a data structure, the biggest source of bugs i have is not applying subsitutions, or doing it too often, or whatever
07:21:23 <zhulikas> (combinatorics)
07:23:18 <tbg-tech> ello
07:24:05 <companion_cube> > liftM2 (++) (inits [1,2,3,4]) (tails [1,2,3,4])
07:24:06 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[],[1,1,2,3,4],[1,2,3,4],[1,3,4],[1,4],[1],[1,...
07:24:22 <companion_cube> hmmm, maybe too many combinations
07:24:27 <zhulikas> http://hackage.haskell.org/package/HaskellForMaths-0.4.3
07:24:30 <zhulikas> I will use this one
07:24:33 <dmwit> scooty-puff: Substitution is hard, use http://hackage.haskell.org/package/unbound
07:24:38 <dmwit> =)
07:24:45 <zhulikas> it has combinatorics module
07:26:58 <scooty-puff> k
07:27:00 <merijn> What exactly does modifyMVar_ not being atomic when there are multiple producers imply? That it's not atomic if some other thread happens to do putMVar while modifyMVar_ is running?
07:27:37 <quicksilver> yes
07:27:39 <dmwit> yes
07:27:41 <quicksilver> it's worse than that, in fact
07:27:52 <quicksilver> some other thread can have done putMVar 5 minutes earlier
07:27:57 <quicksilver> then that thread is blocking on the put
07:28:07 <merijn> quicksilver: Ah, right
07:28:11 <quicksilver> and it's guaranteed to go through when the take-half of modify goes in
07:28:16 <quicksilver> which blocks the put-half
07:28:30 <quicksilver> MVars are perfectly safe to use but you need to adopt a protocol.
07:28:44 <quicksilver> "always take before put" is one possibility
07:28:46 <merijn> All threads only using modifyMVar_ presents no problem then, right?
07:28:50 <quicksilver> correct.
07:29:01 <quicksilver> modifyMVar is quite self w.r.t other people using 'always take before put'
07:29:25 <quicksilver> (another possible protocol is "thread A always puts, thread B always takes")
07:29:54 <ffwacom> YOU MENA HASKELL??
07:32:05 <gdeest> ffwacom: ?
07:43:09 <Ngevd> Why is Data.Text.Internal.Text an instance of Data.SafeCopy.SafeCopy, but Data.Text.Text isn't?
07:44:23 <Axman6> are you sure they're not the same type?
07:46:46 <merijn> @pl \m f -> modifyMVar_ m $ return . f
07:46:46 <lambdabot> (. (return .)) . modifyMVar_
07:50:01 <merijn> @pl \f -> return . f
07:50:02 <lambdabot> (return .)
07:52:41 <Ngevd> Why is Data.Text.Internal.Text an instance of Data.SafeCopy.SafeCopy, but Data.Text.Text isn't?
07:52:43 <Ngevd> Anyone?
07:54:00 <soiamso> Ngevd: lazy  and strict version text problem, you should  import qualified one (lazy or strict)
07:55:33 <hayashi> @pl \(a,b) -> f b a
07:55:33 <lambdabot> uncurry (flip f)
07:55:41 <hayashi> thought so
07:55:50 <Ngevd> soiamso: it's not that, neither Data.Text's Text nor Data.Text.Lazy's Text are SafeCopy, but both internals are
07:56:07 <zhulikas> how can I take a list of a
07:56:13 <zhulikas> and convert it to pairs of (a,a) ?
07:56:25 <zhulikas> pair up the elements
07:56:38 <Ngevd> zhulikas, so [1,2,3,4] would become [(1,2),(3,4)]?
07:56:40 <Axman6> > zip `ap` tails $ [1..10]
07:56:40 <rwbarton> um... Data.Text.Text *is* Data.Text.Internal.Text
07:56:41 <lambdabot>   [(1,[1,2,3,4,5,6,7,8,9,10]),(2,[2,3,4,5,6,7,8,9,10]),(3,[3,4,5,6,7,8,9,10])...
07:56:47 <Axman6> > zip `ap` tail $ [1..10]
07:56:48 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:56:54 <zhulikas> thank you!
07:57:00 <zhulikas> @hoogle ap
07:57:00 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:57:00 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:57:00 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:57:11 <Ngevd> rwbarton, doesn't compile?
07:57:17 <rwbarton> what
07:57:37 <popx> > zip `ap` tail $ [1..9]
07:57:38 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
07:57:41 <Axman6> zhulikas: if you couldn't figure it out, i would strongly advise you to write the function that does what you want by hand
07:57:51 <Axman6> > zip `ap` (tail.tail) $ [1..10]
07:57:53 <lambdabot>   [(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10)]
07:58:03 <Axman6> hmm
07:58:06 <Ngevd> No instance for (SafeCopy Text)
07:58:06 <Ngevd>       arising from a use of `getSafePut'
07:58:06 <Ngevd>     Possible fix: add an instance declaration for (SafeCopy Text)
07:58:06 <hayashi> is there any form of shorthand for saying that a group of functions all have the same type signature, or would I just have to declare that type as a type alias and use that
07:58:19 <zhulikas> Prelude zip :: [a] -> [b] -> [(a, b)]
07:58:32 <zhulikas> so I imagine it takes a list [1..10]
07:58:34 <quicksilver> > let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)  in map (\[x,y] -> (x,y)) . groupsOf 2 $ [1..10]
07:58:36 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
07:58:36 <zhulikas> and splits it into two lists
07:58:40 <Axman6> hayashi: foo, bar, baz :: a -> IO b
07:58:40 <zhulikas> by taking every second element
07:58:47 <quicksilver> ^^ that might be what zhulikas meant.
07:58:58 <zhulikas> yeah, every solution works :D
07:58:58 <Ngevd> rwbarton, this happens with Data.Text and Data.Text.Lazt
07:59:01 <Ngevd> *Lazy
07:59:47 <rwbarton> ...
07:59:53 <rwbarton> so what
08:00:10 <Ngevd> So what what
08:00:14 <rwbarton> before you were talking about Data.Text.Text versus Data.Text.Internal.Text
08:00:17 <rwbarton> you're not making any sense
08:00:30 <quicksilver> zhulikas: no, every solution doesn't work.
08:00:38 <quicksilver> zhulikas: what I did is quite different from Axman6.
08:00:52 <zhulikas> yet I am positive it will be an even number of numbers
08:01:00 <zhulikas> even amount*
08:01:04 <quicksilver> zhulikas: [(1,2),(3,4),(5,6)] is not [(1,2),(2,3),(3,4),(4,5),(5,6)]
08:01:18 <zhulikas> wow
08:01:21 <zhulikas> I didn't notice that :o
08:01:30 <hayashi> @pl \a -> (a,a)
08:01:31 <lambdabot> join (,)
08:01:41 <Ngevd> Hmm...
08:01:49 <Ngevd> Nah, the Internals don't work either
08:02:02 <Ngevd> This is trickier than hackage is saying it should be
08:02:09 <Ngevd> haddock, rather
08:02:48 <quicksilver> as far as I understand it, happstack wouldn't work if Text wasn't an instance of SafeCopy
08:02:54 <quicksilver> ergo, Text *is* an instance of SafeCopy
08:02:59 <quicksilver> and you are doing something wrong :)
08:03:08 <quicksilver> unfortunately I can't tell you what. Wrong versions of something?
08:03:24 <Ngevd> I'm gonna reinstall both Text and Safecopy, see what happens
08:03:34 <hayashi> Axman6: cheers
08:05:21 * byorgey bakes balambdanana bread
08:06:07 * magicman thinks of http://www.flickr.com/photos/warhead/69003/
08:06:14 <Ngevd> Aaaaah now my entire Haskell system is crumbling away
08:06:22 <Ngevd> I have no idea what's going on
08:06:34 <Ngevd> It's complaining it can't find Data.IxSet or Data.Acid
08:06:47 <Ngevd> Which definitely used to be there
08:07:42 <quicksilver> Ngevd: you are being bitten by the big happstack reorganisation perhaps?
08:08:08 <quicksilver> Ngevd: http://www.happstack.com/C/ViewPage/6
08:08:13 <quicksilver> lots of stuff got renamed and moved around packages
08:18:57 <bombel8_> guys, if real world haskell is not intended for "newbies" what is ?
08:19:10 <roconnor> @where LYAH
08:19:11 <lambdabot> http://www.learnyouahaskell.com/
08:19:41 <bombel8_> thanks
08:27:13 <liyang> I'm not sure who RWH is aimed at anymore. It's kind of been made obsolete by a lot of new packages uploaded to Hackage in the intervening years. (Many of which were written by the book's main author, in fact.)
08:28:05 <hpc> perhaps RWH is aimed at people who still use 6.12.1?
08:28:07 <hpc> :P
08:28:54 <quicksilver> programming books go out of date; those which focus on real libraries and real examples go out of date faster :-(
08:29:43 <liyang> My bash scripts from >10 years ago mostly still work.
08:30:38 <hayashi> Programming books based on PL/1 and FORTRAN IV.  They're the best sort.
08:31:25 <augur> Philippa: can we talk about constraint satisfacton in about 30 minutes?
08:31:41 <River> Hi
08:33:08 <byorgey> wasn't there talk of a revised + updated version of RWH?
08:33:12 <eacameron> When should I use ByteString vs. Text?
08:33:14 <byorgey> I don't know what's happening with that
08:33:28 <byorgey> eacameron: use Text if you have text.  Use ByteString if you have a sequence of bytes.
08:33:53 <quicksilver> liyang: my haskell programs from 10 years ago still work.
08:33:57 <quicksilver> liyang: (not sure what your point is)
08:34:03 <byorgey> if you don't know the difference, read http://www.joelonsoftware.com/printerFriendly/articles/Unicode.html
08:34:16 <eacameron> byorgey: simple enough
08:36:43 <quicksilver> byorgey: it's hard to imagine that the book sells well enough to form a commercial basis for a revised edition.
08:36:48 <quicksilver> byorgey: I'd love to be wrong, of course.
08:38:03 <byorgey> quicksilver: yeah, I just seem to recall one of the authors saying they were working on a second edition.  But that was a while ago and I haven't heard anything about it since.  I could also be remembering incorrectly.
08:39:16 <kallisti> are change logs typically maintained manually, or are there utilities that people use?
08:39:39 <tromp__> :t Sum
08:39:40 <lambdabot>     Ambiguous occurrence `Sum'
08:39:40 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
08:39:40 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
08:40:05 <tromp__> :t Control.Monad.RWS.Sum
08:40:05 <lambdabot> forall a. a -> Control.Monad.RWS.Sum a
08:40:41 <tromp__> @instances Control.Monad.RWS.Sum
08:40:43 <lambdabot> Couldn't find class `Control.Monad.RWS.Sum'. Try @instances-importing
08:42:08 <dmwit> ?instances-importing Control.Monad.RWS Sum
08:42:08 <lambdabot> Couldn't find class `Sum'. Try @instances-importing
08:42:13 <dmwit> Oh, right.
08:42:15 <dmwit> Backwards.
08:42:19 <byorgey> kallisti: if there are utilities for managing them I would love to know about it
08:42:28 <dmwit> tromp__: Anyway, critically, no Num instance. All the other ones you would expect, though.
08:45:03 <Mathnerd314> ?instances-importing Control.Monad.RWS Monoid
08:45:03 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:45:21 <kallisti> byorgey: well they appear to exist, but I don't know if any of them are good.
08:45:58 <kallisti> byorgey: could be something we could pioneer. ;)
08:46:18 <kallisti> also I note that cabal doesn't appear to have a way to list changelog in the same way that it allows you to list the license.
08:47:00 <byorgey> kallisti: yeah, it doesn't.  I think this is something that gets discussed every now and then.  Maybe eventually something will happen. =)
08:47:10 <kallisti> byorgey: maybe I'll submit a patch. :)
08:47:52 * kallisti is suddenly realizing the ease at which he can contribute small changes to software projects.
08:49:00 <dmwit> Cabal files do, however, have a known, clear extension mechanism: the x-field-name block.
08:49:22 <dmwit> Just start putting an x-changelog: block in your cabal files. =)
08:51:15 <byorgey> kallisti: =D
08:54:53 <Clint> is there a handy mechanism to do algebraic rearranging of haskell functions?
08:55:08 <eacameron> This is what I have: [putStrLn word | word <- splitOneOf " \t\r\n" line, length word > 0]. But I want to do further processing on each `word`, like `trim word`. I also want the `length word > 0` use the trimmed word. How can I efficiently do more processing of `word` in the list comprehension?
08:55:18 <bgamari> Is there no good way to write a state-ful attoparsec parser?
08:55:23 <bgamari> Given it's not a transformer
08:55:32 <bgamari> I can lift it into RWST
08:56:02 <bgamari> but then if I have something like myAction :: StateT MyState Parser ()
08:56:10 <bgamari> I can't do, try myAction
08:57:03 <gdeest> eacameron : why putting the putStrLn word in the list comprehension ?
08:57:21 <eacameron> gdeest: it's prefixed with `sequence_ [...`
08:57:37 <eacameron> Basically I'm looking for "where" clause inside of a list comprehension
08:57:42 <quicksilver> eacameron: let word' = trim word, length word' > 0
08:57:51 <quicksilver> eacameron: you can put lets into list comps.
08:58:03 <eacameron> quicksilver: no way!
08:58:07 <quicksilver> yes way.
08:58:26 <quicksilver> or you could just fmap the trim over the split
08:58:38 <quicksilver> word <- trim <$> splitOneOf "\t\r\n" line, length word > 0
08:58:51 <bgamari> Is the only solution to this to use a different library (e.g. parsec)
08:59:03 <eacameron> quicksilver: you are blowing my mind... what is "<$>" ?
08:59:09 <eacameron> :t <$>
08:59:09 <lambdabot> parse error on input `<$>'
08:59:11 <mcstar> applicative something
08:59:15 <quicksilver> <$> is fmap
08:59:17 <hayashi> :t (<$>)
08:59:18 <eacameron> :t (<$>)
08:59:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:59:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:59:21 <hayashi> >_>
09:01:09 <bombel8_> :t map
09:01:10 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:01:21 <bombel8_> :t (map)
09:01:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:01:44 <eacameron> what's the difference between `fmap` and `map`
09:01:44 <eacameron> ?
09:01:51 <quicksilver> in this case, nothing.
09:01:59 <quicksilver> in the general case, fmap applies to any functor
09:02:02 <quicksilver> map is the special case for lists
09:02:11 <quicksilver> but you were using a list, so map would have been fine.
09:02:35 <mcstar> quicksilver: you used it instead of prenthesizing?
09:05:15 <ique> Is there anyone here who has worked with ZeroMQ? I'm trying to do a ventilator/worker pattern but one client receives all the messages every time: http://pastebin.com/n8rR8DXe
09:05:17 <mauke> The paste n8rR8DXe has been copied to http://hpaste.org/66817
09:09:15 <andkerosine> filter (<50) [1..]
09:09:18 <andkerosine> What is it that prevents Haskell from being able to reason about this?
09:09:49 <zhulikas> @hoogle [a] -> [a] -> Bool
09:09:49 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
09:09:50 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:09:50 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
09:10:06 <hpc> andkerosine: in general, how does (filter (< 50)) know when the list is over?
09:11:12 <andkerosine> When it reaches the end of the list.
09:11:23 <bgamari> Perhaps I'll rephrase the question; Am I insane to want to use a Writer in a parser?
09:11:55 <hpc> andkerosine: and does it ever find the end of [1..]?
09:11:56 <bgamari> I have an input format which needs to collect some state before producing a value (an SVG path, to be exact)
09:12:00 <andkerosine> Thus "reason". Haskell will never "see" the end of the list, but would it not be feasible to allow it to assume it's done filtering given that it knows it's increasing by 1?
09:12:05 <hpc> yeah
09:12:13 <hpc> it doesn't know the input list is monotonic
09:12:18 <bgamari> Is RWS the best way to accomplish this or am I missing an obvious alternative?
09:12:21 <hpc> nor that the filter function is monotonic
09:12:29 <hpc> (i think that's the right term)
09:12:44 <hpc> andkerosine: what you would want there is takeWhile
09:12:56 <hpc> which stops at the first dropped value
09:12:56 <byorgey> andkerosine: however, that wouldn't be allowed since it would not give the correct semantics.
09:13:03 <andkerosine> Mm-hmm, I was mostly asking from a theoretical standpoint.
09:13:15 <quicksilver> hpc: technically (<50) is anti-monotonic
09:13:17 <quicksilver> I think
09:13:23 <hpc> yes, that
09:13:26 <quicksilver> which happens to be the property you want in this case.
09:13:50 <quicksilver> or, more generally, that "\n -> P(a_n)" is anti-monotonic
09:14:07 <quicksilver> which you don't necessarily have to decompose into a property of 'a_n' and a property of 'P'
09:14:10 <quicksilver> (but you can in this example)
09:14:38 <quicksilver> this is far beyond the kind of reasoning that the haskell compiler does, though.
09:15:11 <hayashi> It's easy, I guess, to forget that the haskell compiler is not a god
09:15:55 <andkerosine> Yet.
09:16:10 <mcstar> monads are deities
09:16:46 <quicksilver> hmm maybe the normal term would be "monotonically non-increasing"
09:17:09 <quicksilver> or "monotonically weakly decreasing"
09:17:53 <mcstar> so with two <$>, i can replace 2 maps and a $
09:19:03 <hayashi> one of these days, I shall have to figure out what functors and monoids are
09:19:12 <Luke> ozataman: I've been using your csv enumerator library - i'm a fan
09:19:26 <byorgey> @where typeclassopedia
09:19:27 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:19:31 <byorgey> hayashi: ^^^
09:19:34 <ozataman> luite: cool - happy to hear that!
09:19:39 <ozataman> ops MT
09:19:44 <Axman6> hayashi: they're both extremely simple. monoids are just twpes that have some binary operation (say (+)) and an identity (say 0)
09:19:49 <ozataman> Luke: the "cool - happy to hear that!" was meant to you :-)
09:20:27 <Axman6> so, numbers are monoids in two ways, with (+) and 0, and (*) and 1. lists are monoids with (++) and [], etc.
09:20:32 <Luke> ozataman: if I want to read from multiple files and write to one or read from one and write to many, I have to implement my own iteratee?
09:20:35 <ozataman> Luke: just ported it to conduit too, if you're interested. http://hackage.haskell.org/package/csv-conduit
09:20:58 <Luke> ozataman: nice =)
09:20:58 <hayashi> mhm
09:21:18 <Axman6> functors are just things that you can map a function onto, like map for lists. Maybe is a functor because we can easily write fmap :: (a -> b) -> Maybe a -> Maybe b
09:21:40 <ozataman> Luke: that sort of flexibility is where I thought conduit might help. in the conduit version, I just export one Stream -> CSV and one CSV -> Stream Conduit
09:21:47 <hayashi> ah
09:22:00 <ozataman> it's then up to you to decide where you want to get your stream and where you want to write it to
09:22:17 <ozataman> and as a bonus, it now supports Text as well as ByteString
09:22:33 <Luke> ozataman: i'll take a look - haven't used conduits before. also looks like they docs aren't on hackage yet?
09:22:40 <hayashi> Haskell's use of posh, formal mathematical terms for simple concepts scares me sometimes.  =P
09:22:51 <ozataman> weird, it's been a while since I uploaded
09:23:09 <ozataman> Luke: maybe give me a concrete use case and I'll see if it's immediately possible?
09:23:12 <Axman6> hayashi: you'd prefer Combinable and Mappable?
09:23:20 <quicksilver> hayashi: it is something of an image problem, yes
09:23:32 <hayashi> Axman6: ick, now that just reminded me of Java interfaces.
09:23:33 <quicksilver> hayashi: on the other hand, the alternative - just making up words - isn't really better
09:23:44 <Enigmagic> Luke: the docs show up for me .. http://hackage.haskell.org/packages/archive/conduit/0.4.0.1/doc/html/Data-Conduit.html
09:23:51 <Axman6> hayashi: exactly ;)
09:24:11 <mekeor> how can i write <body onload="javascript:document.getElemByID('q').focus();"> in blazeHtml ? -- i mean, the single quotes are always converted to HTML...
09:24:22 <Axman6> hayashi: what about CombinableWithIdentity, which is probably a more accurate name. many things are combinable but not functors
09:24:52 <Luke> Enigmagic: http://hackage.haskell.org/package/csv-conduit
09:25:06 <mcstar> :t (***)
09:25:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:25:19 <mcstar> yeah, correct, just checking
09:25:26 <hayashi> My university moved from teaching Scheme to freshmen to teaching them Java, and stopped running its functional programming course a year back due to lack of lecturer time, so the only exposure to functional programming here is a bit of doing code generation in Haskell and one lesson each in Racket and Haskell
09:25:29 <Enigmagic> Luke: oh
09:25:47 <hayashi> I've grown to steadily absolutely hate Java as a result
09:25:54 <Luke> ozataman: just trying to read from many files, do some calculation to collapse the input files into rows of one output file
09:26:12 <ozataman> Luke: gotcha. gimme a sec
09:26:24 <Luke> ozataman: np thanks =)
09:26:59 <hayashi> Axman6: ok, give me Monoid any day =P
09:29:58 <quicksilver> mekeor: they shouldn't be, inside the value of an attribute.
09:30:06 <quicksilver> mekeor: (I say this, having never used blazehtml in anger)
09:30:22 <OwnWaterloo> @pl (\a b -> f0 (f1 a b) (f2 a b))
09:30:23 <lambdabot> ap (ap . (f0 .) . f1) f2
09:30:59 <quicksilver> mekeor: body ! onload "javascript:document.getElemByID('q').focus();" ?
09:31:13 <hayashi> @pl \f g h a b -> f (g a b) (h a b)
09:31:14 <lambdabot> (liftM2 ap .) . (.) . (.)
09:31:16 <hayashi> ick
09:32:23 <mekeor> quicksilver: well, yes, i tried that. doesn't work.
09:33:36 <quicksilver> mekeor: this seems like a bug in blaze then?
09:33:41 * quicksilver can't see what else it could be.
09:34:29 <quicksilver> mekeor: oh, http://www.haskell.org/pipermail/web-devel/2011/002281.html
09:34:44 <hpaste> ozataman pasted “Collapse multiple CSV files into one” at http://hpaste.org/66821
09:34:49 <ozataman> Luke: if you can just map over rows, there happens to be a function specifically for that case "mapCSVFiles". if not, with csv-enumerator you'd need your own iteratees, yes. however with conduit, I think it'll be much cleaner.
09:34:52 <mekeor> quicksilver: i just wanted to paste that link, too.
09:34:55 <ozataman> Luke: see above for the example
09:36:24 <Luke> ozataman: awesome - i'll start hacking my stuff in there and see how it goes - thanks
09:36:27 <ozataman> Luke: just need to implement a conduit that pops off MapRows from incoming pipe, does something with that (potentially statefully) and pushes the result, also MapRows, into the downstream pipe. run the collapse function with a runResourceT at the end
09:37:15 <Luke> yeah that hard part is i'm doing stateful collapsing so I need accumL or some trickery in the accum of fold
09:37:38 <hpaste> kallisti pasted “webdriver REPL” at http://hpaste.org/66822
09:37:48 <ozataman> might be easier to use "conduitState" in Data.Conduit to make your conduit
09:38:32 <Luke> I'm trying to do some quick scripts for work so I don't know how much time I'll have to learn conduits =)
09:38:38 <Luke> probably have to wait til tonight or something
09:40:50 <Enigmagic> Luke: would Data.Conduit.List.concatMapAccumM work?
09:41:14 <Luke> Enigmagic: probably - yeah
09:43:45 <Luke> thanks =)
09:44:53 <mcstar> byorgey: is the ML history of types similarly complicated as the one shown in typeclassopedia?
09:45:09 <mcstar> or this is very much haskell specific
09:45:54 <bitonic> mcstar: in SML world there isn't such a widespread use of those abstractions
09:46:02 <bitonic> but they are language-agnostic really
09:46:19 <bitonic> mcstar: the typeclassopedia gives an haskell view since it uses type classes to illustrate them
09:46:22 <mcstar> well, the idea is, but the implementation might not be
09:46:57 <bitonic> mcstar: yeah the interfaces are going to be expressed differently depending on the language, in SML you'll have signatures instead of type classes
09:48:52 <mcstar> can you explain this: list can be thought of as representing a single value which is nondeterministically chosen from among several possibilities
09:49:07 <mcstar> i dont get the nondeterministic part
09:49:28 <mekeor> quicksilver: fyi: it's like this:  ... A.onload (preEscapedTextValue "javascript:...") ...
09:49:46 <mekeor> quicksilver: jaspervdj told me.
09:51:07 <hpc> mcstar: suppose you wanted to add a number that might be either 0 or 1, and a number that might be 10 or 20
09:51:27 <hpc> > do {x <- [0,1]; y <- [10,20]; return (x + y)}
09:51:29 <lambdabot>   [10,20,11,21]
09:51:59 <augur> er
09:52:17 <mcstar> i see the result, but dont know what happened there
09:52:20 <augur> for Cont, is (>>=) just ($)?
09:52:31 <mcstar> but still dont understand why would it be nondeterministic
09:52:56 <augur> mcstar: the computation that haskell does is not non-deterministic
09:53:03 <hpc> mcstar: a list of stuff can be thought of as "every value this thing might be"
09:53:23 <deech> Hi all, this article (http://www.i-programmer.info/professional-programmer/i-programmer/3892-the-functional-view-of-the-new-languages.html) which states that lazy-by-default is a weakness is going around. To back it up it uses the SPJ quote "The next version of Haskell will be strict".
09:53:26 <bitonic> mcstar: the computation of the list itself is deterministic ofc, if that's what you're asking
09:53:30 <hpc> mcstar: and you can write computations that try all of those possibilities
09:53:34 <deech> Is this a valid use of that quote?
09:53:35 <augur> mcstar: you just use this to simulate the non-deterministic properties
09:53:36 <bitonic> deech: that's probably a joke by spj
09:53:36 <xivix> Is there an implementation of JavaScript in JavaScript yet?
09:53:41 <mcstar> ok, so for every a in A; for every b in B do a+b
09:53:45 <bitonic> xivix: wrong channel
09:53:51 <xivix> lol whoops
09:53:51 <ion> > let sqrt' x = [y, -y] where { y = sqrt x } in do a <- return 16; b <- sqrt' a; return (a+b)
09:53:52 <lambdabot>   [20.0,12.0]
09:53:53 <augur> mcstar: sure, thats one way to think about it
09:54:03 <augur> mcstar: but perhaps a better way is to think of it like this:
09:54:09 <xivix> well, substitute haskell for that, I'm curious now
09:54:48 <augur> if nondet-x is a variable with non-deterministic value
09:54:48 <deech> People seem to bring up that quote and this (https://plus.google.com/107890464054636586545/posts/T9c7GuoAS4r) pretty often.
09:55:13 <bitonic> deech: yes reasoning about lazy program is harder.
09:55:23 <augur> then x <- nondet-x is like saying "assume x is a value that nondet-x might be"
09:55:38 <ion> 16 + √16 is either 12 or 20.
09:55:49 <augur> where nondet-x happens, in practice, to be defined to be lists of x-like things
09:56:06 <mcstar> but i can do this with, say a tree
09:56:23 <mcstar> or anything that is an instance of Functor
09:56:26 <augur> then when you do return (x + y) what you're saying is, ok, since x + y is a value that nondet-x and nondet-y might be, its a value that nondet-(nondet-x + nondet-y) might be
09:56:36 <augur> mcstar: different functors give you different monads
09:56:42 <augur> the list monad is the non-determinism monad
09:56:57 <mcstar> hm, so it wouldnt work
09:57:04 <augur> or more accurately, the non-determinism with possibly-duplicated ordered alternatives
09:57:22 <ion> Well, anything you can toList can be used with the list monad. :-)
09:57:22 <hpc> if "non-determinism" is the only thing holding you up, replace it with "tries-every-possibility"
09:57:33 <hpc> "the list monad is the tries-every-possibility monad"
09:57:34 <augur> mcstar: what are you trying to do?
09:57:35 <mcstar> yeah i get it
09:57:42 <mcstar> and i thinkg it is somewhat of a misnomer
09:57:50 <mcstar> (but maybe im just noob)
09:57:56 <mk> the list monad has nothing to do with how you usually use lists
09:57:57 <augur> mcstar: nondetermism is a fact about computers
09:58:16 <augur> mcstar: all computers we program for are deterministic, so you can only simulate true non-determinism
09:58:49 <mcstar> depends on your operating system though
09:58:53 <augur> mk: well it does if you use it that way!
09:58:54 <mk> I'm not even sure why it's a list monad, rather than a set or bag monad
09:58:56 <augur> mcstar: no, it really doesnt
09:59:00 <mcstar> augur: joke
09:59:06 <augur> mcstar: your chip does things in a deterministic fashion
09:59:40 <augur> mk: because lists are easier to implement? im sure there IS a set and bag monad
09:59:41 <mcstar> if you average over the un-observable degrees of freedom, you get at least unpredictability
09:59:50 <mk> augur: well, there's io etc.
09:59:55 <augur> lists are just really useful for certain things
10:00:13 <augur> mk: no what i mean is im sure if you go into the set and bag sources, youll find monad instances
10:00:22 <hpc> what's set and bag?
10:00:30 <mk> augur: my point is that in describing the nondet computation, I can't think of a reason to use a list over a set, especially when one is explaining it
10:00:43 <augur> mcstar: sure but that's an epistemic view. non-determinism is an *ontological* matter
10:00:53 <mk> hpc: a set is unordered and has no duplicates, while a bag is unordered but has duplicates
10:00:55 <augur> we CAN build genuinely non-deterministic machines, however
10:00:55 <mcstar> so, noobie question again, but how does this happen? do is for the IO monad right? so what is the thing that's meaning is changed? the 'return' ?
10:00:58 <mk> hpc: both of them are collections
10:01:02 <mokus> the "list monad models nondeterminism" idea isn't an explanation of nondeterminism, it's an explanation of the list monad
10:01:05 <hpc> Set isn't a monad
10:01:14 <hpc> (in haskell at least)
10:01:20 <augur> mcstar: do is for anything monadic
10:01:30 <augur> its just sugar for (>>=)
10:01:30 <mcstar> ok
10:01:36 <augur> return is core to the definition of monad
10:01:42 <augur> hpc: isnt it? thats a shame
10:01:45 <mux> it could be though, now that we have ConstraintKinds
10:02:05 <mk> mokus: it should be the explanation of the set monad (if there is one)
10:02:12 <mux> (and the "null" constraint (), and the ability to have constraints associated with a class)
10:02:16 <augur> i dont see why it couldnt be without constraint kinds
10:02:26 <mokus> mk: if there were a Set monad in haskell, that would also be how you explain it
10:02:36 <mux> augur: because Set has an Ord constraint on its values
10:02:50 <mcstar> augur: but you see, something must change its meaning, when it encounters lists, to support the generation of these possible outcomes, so is this thing 'return"?
10:02:59 <augur> mux: oh i see, ok
10:03:07 <CubeZero> Good evening. I'm new to haskell and have a question. Where may I ask?
10:03:23 <mk> CubeZero: here, and welcome
10:03:29 <mokus> mk: currently there can't be due to a quirk of the type system, but mathematically sets do form a monad and it does model nondeterminism in the same way - but my point is just that the reason it comes up in context of the list monad is because people are trying to explain the list monad, which is one that comes up very early in learning Haskell
10:03:31 <augur> mcstar: right, so think of it like this
10:03:36 <CubeZero> I just implemented an in place mergesort
10:03:50 <CubeZero> I have a function
10:04:01 <augur> mcstar: if m is your monad (ie your "style of thinking" about values), then return takes a non-m-y value and lets you think about it in an m-y fashion
10:04:02 <CubeZero> cmp                                            :: (Int, Int) -> ST s (STUArray s Int Int) -> ST s Bool
10:04:29 <CubeZero> defined by: cmp (i, j) array                                = do arr <- array                                                      a   <- readArray arr i                                                      b   <- readArray arr j                                                      return (a <= b)
10:04:43 <mcstar> augur: aham, because i defined 'return' for my specific monad
10:04:45 <augur> mcstar: for instance, if your monad is NonDeterministic (which is usually just defined as List), then return x is that way of thinking about x as a NonDeterministic value
10:04:56 <CubeZero> defined by: cmp (i, j) array    = do arr <- array ;  a   <- readArray arr i ;  b   <- readArray arr j ;   return (a <= b)
10:05:03 <mk> CubeZero: use pastebin
10:05:11 <mcstar> ok, thanks for the explanations
10:05:11 <CubeZero> :mk ok
10:05:17 <augur> mcstar: which one? well, that depends on the definition of the monad, but in this case, it's that NonDeterministic value which *happens* to have only one value
10:05:49 <mk> mokus: yeah, the explanation confuses people, because they suppose that nondet is somehow intrinsic to lists in particular, or has something listlike in it. It doesn't. And it's seldom non-determinism, anyway
10:06:23 <mk> I can't see at all why many of the examples aren't merely examples of functions that return sets or multiple return values
10:06:32 <mk> that doesn't mean that the function is non-deterministic
10:07:15 <augur> mcstar: so it's sort of the opposite of what the <- is doing in do notation -- where <- lets you think of an m-y version of an a-y value as if it were an a-y value, return lets you think of an a-y value as an m-y version of an a-y value
10:07:40 <augur> mk: even that isnt true non-determinism tho
10:07:41 <mk> augur: by m-y do you mean ma-y?
10:07:45 <mcstar> yeah, <- unpacks, return encapsulates
10:07:50 <augur> thats deterministic modelling of non-deterministic
10:07:51 * hackagebot splice 0.4 - Socket to Socket Data Splicing (supports all operating systems)  http://hackage.haskell.org/package/splice-0.4 (CetinSert)
10:08:08 <augur> mk: no, i mean m-y, but not in any formal way :)
10:08:28 <mokus> no, but in "do x <- xs; y <- ys; ...", it is useful to think of "x" and "y" as nondeterministic values - the calculation is only _simulating_ nondeterminism, but when you're inside the "do" it's useful to think about the thing being simulated rather than the fact that it's only a simulation
10:08:44 <mk> augur: sure, but the explanation of all of that is too ugly, when all you need to say is "it's a function that returns a set/group"
10:09:23 <mk> mokus: define nondet value?
10:09:23 <mokus> in particular, I don't agree with the interpretation that says the list itself is somehow nondeterministic - it's the locally-bound names that are
10:09:39 <augur> mk: well it depends on who you're explaining it to tho. its just as well to say it's a function that returns a list, since lists are the typical implementation in programming languages
10:09:46 <augur> mk: whereas sets are the typical implementation in math
10:10:05 <mokus> mk: an identifier that can simultaneously refer to any number of concrete values
10:10:32 <mokus> such as the "x" in "do x <- [1..100]; ..."
10:10:51 <mokus> the [1..100] is not "nondeterministic", but the "x" is
10:10:54 <mk> augur: sets are just as common in programming, and are more fundamental. All maps, for example, have a set component, and not a list component
10:10:59 <mk> (the keys)
10:11:22 <augur> mokus: eh. i prefer to think of it as "thinking of it as" where the list is the as-a-nondeterministic-value and the inner variable is the as-a-nondeterministic-value
10:11:32 <mk> mokus: do you mean that you're thinking of it in parallel?
10:11:49 <augur> mokus: mostly because then you can thin of non-deterministic values as being combinable in appropriately non-deterministic ways at a higher level
10:11:56 <mokus> mk: i usually don't think about it in terms of the nondeterminism context at all, but when I do that's how I think of it
10:12:32 <augur> mokus: eg, you might want to think of liftM2 (+) or whatever it is as just the "nondeterministic" version of addition
10:12:48 <mokus> augur: when using lists in a combinatorial/applicative style rather than monadic, I generally just think about it as taking cartesian products - i.e, manipulating lists, not doing something "nondeterministic"
10:13:09 <augur> hm. well, to each his own i guess :)
10:13:17 <augur> whatever works best for the task, i imagine
10:13:21 <mokus> augur: I don't claim the other viewpoint is "wrong" or anything, just explaining how I prefer to think about it
10:13:25 <mokus> yup
10:14:27 <mk> I'm not sure. If non-determinism implies that a function can have different values each time, then it probably is a wrong view
10:14:32 <mokus> and when I do want to think about somethnig in terms of nondeterminism, I often prefer to use a monad designed for the task, such as LogicT
10:15:34 <augur> the way i prefer to think about non-determinism is from an automata perspective
10:15:38 <mokus> mk: it's not really about "different values each time", it's about "different values _at the same_ time"
10:16:11 <augur> the result of a non-deterministic computation is a superposition of results
10:16:17 <mk> mokus: it's about "all possible return values" at the same time, actually - but that's not non-deterministic, according to most people's familiar definitions
10:16:23 <augur> all of them simultaneously, but not collectively
10:16:47 <mokus> according to the mathematical perspective (i.e., what augur is describing), that actually is the common interpretation
10:16:47 <augur> another way of thinking of it is if you think of "eval" as being a function
10:16:57 <mekeor> which fixity does :: have ?
10:16:57 <augur> then you should stop doing that, and start thinking of eval as a relation :)
10:17:51 <mekeor> 0 ?
10:18:19 <Veinor> so
10:18:38 <augur> interestingly, there's a view of second order logic called plural logic due to boolos which has "nondeterministic" variables, in this sense, so that your plural variables are not _assigned_ values but are merely _related_ to values
10:18:51 <Veinor> how easy would it be to use ghc-api to load .o files on a system without ghc?
10:19:11 <augur> and this lets you do standard second order proofs of a certain sort, but without requiring sets in your domain of quantification
10:19:27 <scooty-puff> i imagine on an out of memory error, its impossible to get ghc to print gc info, etc.?
10:19:30 <augur> so you can state a lot of interesting, important properties about mathematics without running up against paradox
10:19:53 <augur> but it's not really non-determinism, it's just a similar shift to a relational view
10:20:10 <mekeor> Veinor: i'd rather say "how hard would it be to ...".
10:20:22 <Veinor> sure
10:20:26 <mekeor> :)
10:20:29 <mokus> in any case I do tend to agree with mk that it's not the best pedagogical approach for people who don't already have that kind of background
10:20:55 <augur> mokus: i think its hard to have any pedagogical approach that you cant write a program for
10:20:58 <mk> I don't know. There's a difference between proper functions, things like methods (where the language doesn't control the function/arg state), and then multi-output functions
10:22:01 <mk> in these "multi-output" functions (which we're calling non-deterministic for some reason), the output is deterministic, and the language exercises full control over the way that values emerge
10:22:42 <mroman_> Has anybody successfully compiled hmp3 lately?
10:22:43 <mokus> the output is deterministic but it is (in this view) considered to represent a non-deterministic value
10:22:51 <mokus> by listing all its possible concrete values
10:23:01 <augur> mk: right, the computation is indeed deterministic
10:23:08 <mroman_> hmp3/cbits/utils.h redefines getline from stdio which results in a compiler error.
10:23:12 <augur> which is what my point was earlier -- you're using determinism to SIMULATE non-determinism
10:23:44 <mk> mokus: that might make more sense to me if it also assigned a probability distribution across the values, or something
10:23:55 <augur> mk: dont forget tho, even for non-deterministic automata, there is a STANDARD, and rather trivially-defined (tho not computationally simple) way to simulate non-determinism
10:24:24 <mk> augur: but you're not, most of the time. In lyah, and many other places, there's a very nice "chess moves" explanation of the list monad
10:24:51 <augur> mk: oh i see, you mean the pedagogy of teaching about the list monad
10:24:59 <mokus> mk: you can do that too, and it forms a monad again - but the simpler one is valid too, it's just saying which ones are possible without caring which ones are likely
10:25:00 <mk> I have no idea how one plans to fit that into non-determinism, unless one wants to treat the player as a non-deterministic function, but that seems silly to me
10:25:04 <augur> not the pedagogy of teaching about simulating non-determinism
10:25:05 <augur> ok
10:25:47 <augur> mk: i wonder if that view of the list monad actually hints at a nice, deeper connection between chess and non-deterministic computation :)
10:26:09 <mk> augur: well, I'm also not sure if there are any common cases of truly simulating non-det, though I can think of cases where we try to draw an analogy between what we do, and non-det, but why we draw this analogy to an even more complicated thing is beyond me
10:26:12 <augur> mk: brb going to find the lyah chess analogy
10:27:01 <augur> mk: im pretty sure we just draw analogies in so far as the simulation has no less information that what we want
10:27:03 <mk> http://learnyouahaskell.com/a-fistful-of-monads ctrl-f knight's quest
10:27:47 <augur> mk: er...
10:28:18 <augur> so im not seeing how this is not a non-determinism analogy
10:28:44 <mk> which part of "all the knight's possible moves" is non-deterministic?
10:28:59 <gzmask> where are the package location installed by cabal in OSX?
10:29:05 <augur> mk: the part where you think in terms of monadic application?
10:29:46 <augur> you think of "making a move" as a way of going from board configuration to board configuration, with no specific outcome but only a superposition of possible outcomes
10:29:49 <mk> augur: only if you're thinking of monads as strange deterministic simulations of non-determinism
10:30:07 <augur> mk: sure, and unsurprisingly, that's what lyah says its doing quite explicitly
10:31:27 <augur> mk: but it's perfectly natural to think of the moveKnight function as being a function that "randomly" picks a place for the knight to move
10:31:40 <mk> augur: I'm totally fine with superimposition, but that's not non-determinism. All of this can be explained in full, and properly conceived in full, without reference to non-determinism
10:32:06 <augur> mk: of course it can -- all non-determinism, except quantum non-determinism, can
10:32:08 <mk> augur: no, because there's no guarantee that this sort of random function will even terminate
10:32:23 <augur> mk: thats irrelevant
10:32:42 <augur> you're writing a program to encode how you think about a problem
10:33:02 <augur> if the problem you're thinking about is unsolvable, there's no reason to think your program should somehow let you solve it
10:33:19 <augur> and that transcends whether you're thinking about something deterministically or non-deterministically
10:33:32 <mk> augur: not really. The list monad isn't a case where you surrender your understanding of how the operation unfolds, but one where you exercise full control of the operation, and output
10:33:54 <augur> MK_FG: im not saying it IS a case where you surrender your understanding. im saying it's one where you CAN surrender your understanding
10:33:58 <augur> er, mk*
10:34:27 <augur> which is one of the purposes of viewing monads as styles of computation, rather than as fancy data structures
10:35:11 <augur> monads let you think of things in the terms you find most natural for the problem, even if the computer can't do that, because the definition of the monad hides the details
10:35:22 <mk> augur: when I surrender my understanding, I start worrying about if the function will even terminate. The only reason you say that this is irrelevant is that you choose to remain aware that in this case, it will. You shouldn't do that, and a novice won't be able to do that.
10:36:27 <augur> mk: ive not found a case where thinking of the problem outside the monad leads to an inability to tell if it terminates or not
10:36:28 <mk> right, I'm just saying it shouldn't be called non-determinism. This confused me greatly as I was learning about it, and I see no reason for it now
10:37:07 <augur> indeed, the cases where we expect non-determinism when thinking of these things as lists are exactly those of thinking of them as non-deterministic values
10:37:21 <rwbarton> other people do see reason for it. it is perfectly legitimate to call it (modeling) non-determinism
10:37:21 <mk> augur: I'm imagining that the monadic "non-deterministic" function is attempting to find all of the knight's moves via 1000 iterations, and using a flawed random generator
10:37:23 <augur> namely, when there are an infinite number of superposed values
10:37:43 <augur> mk: i said nothing about a random number generator
10:38:28 <mk> augur: you don't have to. That's a permitted interpretation of a non-deterministic function. You can think of an "arbitrary state assigner" if you'd like.
10:38:46 <CubeZero_> Hello everyone
10:38:48 <rwbarton> nondeterminism is as in "nondeterministic finite automaton" or "nondeterministic Turing machine". it has nothing to do with probability
10:38:50 <CubeZero_> (again xD)
10:39:07 <mk> augur: "infinite number" does not guarantee that all of the knight's moves will be found
10:39:11 <mokus> rwbarton: that's true, but is it perfectly reasonable to call it that when teaching to a non-mathematically-inclined audience?
10:39:11 <augur> mk: it seems to me that you're complaining about a particular view of simulating non-determinism that has nothing to do with monads at all
10:39:19 <CubeZero_> I have a question in the pastebin: http://pastebin.com/wTfv0Ctb. I am new to haskell
10:39:21 <mauke> The paste wTfv0Ctb has been copied to http://hpaste.org/66828
10:39:30 <mokus> rwbarton: (I'm not saying it's not, but that's the issue at hand)
10:39:38 <rwbarton> oh
10:39:49 <rwbarton> I didn't get the sense that mk was trying to argue that, but ok.
10:39:54 <CubeZero_> i am still here
10:40:01 <CubeZero_> the old one timed out xD
10:40:08 <mokus> rwbarton: it's been a while since the thesis statement ;)
10:40:13 <augur> mk: which is irrelevant to the point. even if you simulate nondeterminism explicitly, without monads, without surrendering your understanding of the structure of the problem and its execution (with the exception of the definition of the random number generator), you're STILL not guaranteed what you want
10:40:27 <augur> mk: essentially you're just worried that code you cant read might be wrong
10:40:31 <augur> well no shit it might be wrong
10:40:52 <augur> but that's got nothing to do with thinking of [0,1,2] as "just" a non-deterministic number
10:41:20 <mk> augur: no, I'm assuming code correctness. When I think of a non-deterministic function, it is correct for it to not find all the answers
10:41:22 <augur> rwbarton: some non-deterministic processors are stochastic!
10:41:57 <augur> mk: then you're just thinking of non-determinism wrong
10:42:42 <mk> augur: en.wikipedia.org/wiki/Deterministic_algorithm
10:42:49 <augur> noone except you, as far as i know, thinks of non-determinism that way. either they view it as finding one random answer, or as finding all answers superposed
10:42:59 <CubeZero_> Could someone please help me drawing a Bool out of ST s Bool using runST ?
10:43:24 <mk> augur: I think of it as finding all answers superimposed, but "random" has nothing to do with it
10:43:24 <glguy> CubeZero_: Do you have some code that should work but doesn't?
10:43:28 <mauke> :t runST
10:43:29 <lambdabot> forall a. (forall s. ST s a) -> a
10:43:38 <mauke> CubeZero_: runST x
10:43:44 <augur> mk: there's a reason i put "random" in quotes
10:43:59 <CubeZero_> :mauke the code in the pastebin works but i want to use  my cmp function in a guard
10:44:13 <CubeZero_> :mauke and it has type ST s Bool
10:44:17 <augur> mk: namely, because you shouldn't put too much weight on that particular word choice
10:44:42 <augur> mk: usually when people talk about randomness in this context, it means precisely "unknown to the outside"
10:44:55 <CubeZero_> mauke: i will report the error, give me a second please
10:45:08 <rwbarton> CubeZero_: you can't use a guard here
10:45:19 <rwbarton> you can't run actions from guards
10:45:25 <augur> mk: or perhaps more like "have no expectations", etc.
10:45:55 <CubeZero_> rwbarton: ah ok. Shouldn't it be possible to use runST to get out the bool?
10:46:01 <rwbarton> no
10:46:11 <mk> augur: if you have a function that returns a special value, called a "superimposition of all possible values", this is not non-deterministic, by any stretch that I can see. Perhaps I'm wrong, but I don't see it.
10:46:13 <CubeZero_> rwbarton: oh, why not?
10:46:27 <augur> mk: it's like saying, "i'll give you a value, but i wont tell what it is just yet"
10:46:32 <CubeZero_> rwbarton: Is it because of the threads?
10:46:47 <augur> mk: what about "as" do you not understand?
10:46:51 <CubeZero_> the code is in the pastebin mentioned above
10:47:04 <CubeZero_> rwbarton: the code is in the pastebin mentioned above
10:47:07 <rwbarton> well the typechecker's reason is because cmp (l, r) arr has type ST s Bool where s is the same s as in the type signature of mergesort
10:47:14 <rwbarton> it's not an unconstrained s
10:47:15 <mk> augur: which "as"?
10:47:18 <augur> mk: there's a difference from "xs is a list" and "xs thought of as a non-deterministic value"
10:47:46 <mk> augur: you can't think of it that way unless it has certain features. It doesn't. It's fully deterministic.
10:47:50 <CubeZero_> rwbarton: ok so can i constrain the other somehow?
10:47:56 <rwbarton> mk: you can play the same game with other monads. "if you have a function that takes a parameter of type s and returns a pair (a, s), this is not state, by any stretch that I can see"
10:48:06 <augur> mk: uh, you certainly CAN think of it that way
10:48:09 <augur> and that's precisely what people do
10:48:39 <mk> augur: no, I think of it as a superimposition of values. But I think it's confused to call that non-determinism.
10:48:46 <CubeZero_> rwbarton: is there a way to use cmp in a guard?
10:49:03 <CubeZero_> rwbarton: is there any way to get out the bool?
10:49:03 <augur> mk: it's not non-determinism, it's a SIMULATION of non-determinism
10:49:12 <rwbarton> CubeZero_: no you can't do this, you would need a function of a type like STUArray s Int Int -> Bool but that's nonsensical
10:49:15 <mk> rwbarton: not really. Anyway, it isn't a state, it's a pair with a state in it ;)
10:49:29 <rwbarton> mk, it is exactly the same situation
10:49:29 <augur> mk: that doesn't mean you can't think of the underlying non-deterministic values when you write xs
10:49:36 <augur> i dont see why this is so hard for you to grasp
10:50:04 <rwbarton> if you can see s -> (a, s) as state but not [a] as nondeterminism then that is a sort of blind spot which eventually you will see
10:50:11 <CubeZero_> rwbarton: so the only way to write the second guard with cmp is with a lambda and >>= ?
10:50:30 <rwbarton> CubeZero_, that's what I would do anyways (or do-notation)
10:50:34 <augur> mk: what the thing IS is not the same as what you're thinking of it AS
10:51:02 <CubeZero_> rwbarton: i had it in do notation but wanted it to make it shorter and "sweeter" somehow
10:51:17 <mk> augur: you can't call a chair a simulation of a duck unless the chair is in flight. A list monad is deterministic, so while I'm a big fan of the "parallel values" mental model, the non-deterministic one doesn't do it for me, and I still don't see what you're getting at when you call it non-deterministic
10:51:29 <CubeZero_> rwbarton: using in place modifications are perfectly possible in haskell
10:51:36 <augur> for instance, the person mk is whatever mk is -- but certainly people will think of the person mk AS something or other at any given time -- as a child, as a parent, as a sibling, as an employee, as an employer, as a programmer, as a painter, ...
10:51:36 <rwbarton> wait I just noticed your code is sort of odd
10:51:38 <CubeZero_> rwbarton: but it creates so much lines of code
10:51:52 <augur> mk: i can certainly call a chair a duck
10:51:54 <c_wraith> mk: it's actually a perfect way to understand the NP class
10:51:57 <CubeZero_> rwbarton: * so many
10:51:59 <augur> for instance, im sitting on a duck right now
10:52:09 <augur> mk: but noone's calling chairs ducks
10:52:29 <augur> noone is saying the list monad is non-determinism
10:52:31 <augur> so stop saying tha
10:52:35 <CubeZero_> rwbarton: ok well then it's fine how it is
10:52:38 <rwbarton> CubeZero_: don't you want mergesort             :: (Int, Int) -> STUArray s Int Int) -> ST s (STUArray s Int Int)
10:52:40 <mk> augur: I'm not saying that
10:52:42 <rwbarton> oops
10:52:46 <Miglani> her
10:52:53 <rwbarton> hit some weird key, delete that mismatched close paren
10:52:54 <augur> mk: let me quote you:
10:52:55 <augur> "I still don't see what you're getting at when you call it non-deterministic"
10:52:57 <augur> you are saying it
10:53:13 <CubeZero_> rwbarton: Can i use STUArrays as parameters?
10:53:21 <mekeor> when i do `map id someListHere', does haskell really map over that list, or does it know that it's `id' and thus not necessary to do anything? (using GHC.)
10:53:22 <augur> you're apparently crazy, and don't even know what you've said in the very last message you've sent
10:53:26 <CubeZero_> rwbarton: is it a constructor and therefore a function ?
10:53:36 <rwbarton> I don't understand
10:53:39 <augur> so i dont see any profit in continuing to talk to a crazy person who doesn't understand the difference between "is" and "think of as"
10:53:40 <rwbarton> STUArray is a type constructor
10:53:43 <rwbarton> STUArray s Int Int is a type
10:53:43 <mk> me saying I don't understand how you in particular are thinking about it as non-deterministic" doesn't mean I'm calling it non-determinism in and of itself...
10:53:53 <augur> ...
10:53:54 <augur> oh
10:53:54 <rwbarton> you can have a parameter of type STUArray s Int Int
10:53:54 <augur> my
10:53:56 <augur> god
10:53:57 <CubeZero_> rwbarton: ah ok then i can drop the ST s before it
10:54:01 <augur> do you speak english, mk
10:54:02 <rwbarton> well it means something different
10:54:07 <augur> because you're completely failing at it right now
10:54:08 <augur> anyway
10:54:19 <augur> im done with this absurd conversation
10:54:22 <augur> Philippa!
10:54:33 <rwbarton> STUArray s Int Int is an actual array that can be referenced from an ST computation identified by s
10:54:36 <CubeZero_> rwbarton: Ok thank you very much rwbarton !
10:54:36 <mk> augur: play nice, just because someone doesn't understand what you're trying to communicate doesn't mean that the person can't speak english
10:54:47 <rwbarton> ST s (STUArray s Int Int) is a computation that returns such an array
10:54:48 <CubeZero_> rwbarton: thanks for helping a noobie :)
10:54:57 <mk> if you're frustrated with being unable to get your point across, as I am too, keep it to yourself
10:55:01 <augur> mk: in my professional capacity as a linguist i judge you to be incapable of speaking english.
10:55:07 * mekeor points on his question.
10:55:26 <augur> @tell Philippa ill bug you about constraint solving in an hour :x
10:55:26 <lambdabot> Consider it noted.
10:55:29 <CubeZero_> rwbarton: yes i will change it. I just didn't want it to push such an array on the stack or something
10:56:06 <CubeZero_> rwbarton: i know haskell is lazy but i will use mergesort on an unboxed int array with 188 million elements and it gets close to my RAM
10:56:50 <CubeZero_> rwbarton: so haskell will not put this array of type STUArray s Int Int on the stack anyway?
10:56:51 <mk> augur: I'm surprised more people aren't letting you know that this isn't an appropriate way to talk, given the reputation of the haskell community
10:57:35 <mcstar> haskell ate up all my ram for a couple million element hastable+x32 element bytestring
10:57:47 <mcstar> <10M i think
10:58:01 <mekeor> any ideas or guesses or speculations or knowledge or opinions or comments on my question?
10:58:22 <CubeZero_> rwbarton: i wanted to compose the calculations together, because i was afraid of copies of the array
10:58:22 <rwbarton> it's never going to put the actual array storage on any kind of stack
10:58:36 <CubeZero_> rwbarton: this is the reason i did not remove the ST s of the array
10:58:38 <rwbarton> well the way you actually did it, i am more concerned about the computation being done more than once
10:58:41 <mcstar> mekeor: noob here, but yeah, i think it does unless you optimize
10:58:53 <CubeZero_> rwbarton: so it puts only a pointer to the heap on the stack?
10:58:55 <zhulikas> what is the fastest way of taking specific amount of elements from an end of a list
10:58:56 <zhulikas> ?
10:59:08 <rwbarton> since you pass the computation around, possibly you may end up executing it many times, it's hard to tell without examining the code closely
10:59:22 <rwbarton> CubeZero_: yes, basically everything is done through pointers
10:59:40 <mekeor> mcstar: ah. thank you very much!!!! you proved me that my IRC-client works. thanks. -- i though my IRC-client was striking... but it's rather #haskell which is ignoring me ;(
10:59:53 <mcstar> mekeor: you can measure it
11:00:00 <CubeZero_> rwbarton: so it is better to pass STUArray s Int Int as a parameter instead of ST s (STUArray s Int Int) ?
11:00:05 <rwbarton> well
11:00:07 <rwbarton> do you know C?
11:00:10 <mekeor> yes.
11:01:13 <mekeor> #haskell freezed.
11:01:23 <zhulikas> it did not.
11:01:35 <mcstar> dont mess with #haskell pls!
11:01:35 <zhulikas> or did it?
11:01:46 <CubeZero_> rwbarton: where have i introduced the possibility of evaluating the array several times
11:02:34 <augur> mk: that should tell you something.
11:02:49 <mk> augur: hmm?
11:03:15 <rwbarton> CubeZero_: well... everywhere
11:03:19 <CubeZero_> rwbarton: oO
11:03:28 <rwbarton> it is a sort of global property of your program
11:03:34 <rwbarton> do you know C?
11:03:41 <mcstar> for real nondeterminism you need quantum computers, thats what i read
11:03:42 <CubeZero_> rwbarton: i wanted to do the exact opposite
11:03:43 <rwbarton> or what other programming languages do you know
11:03:50 <CubeZero_> rwbarton: yes, c, c++, java
11:03:52 <rwbarton> okay
11:04:07 <rwbarton> passing a STUArray s Int Int is basically like passing an int [] (or int *)
11:04:25 <rwbarton> passing a ST s (STUArray s Int Int) is basically like passing a pointer to a function that returns an int []
11:04:44 <byorgey> mcstar: re: ML history, I don't know.
11:05:03 <rwbarton> since you do the latter there is the possibility that you call the function several times
11:05:28 <mcstar> byorgey: nvm, it is answered, i just asked you cause you linked it in
11:05:52 <rwbarton> it's not that you are duplicating the array, it's that you are possibly repeating the steps used to create the array
11:06:28 <CubeZero_> rwbarton: ah i understand. i will use STUArray s Int Int instead. Then i will pass the result as a parameter, right?
11:07:02 <rwbarton> the "result"?  yes, i think s
11:07:02 <rwbarton> o
11:07:04 <CubeZero_> rwbarton: instead of the calculation definition of how to get to the array
11:07:07 <byorgey> mcstar: ok.
11:07:08 <rwbarton> right
11:08:09 <CubeZero_> rwbarton: thank you very very much ! Thank you for your time !
11:08:41 <CubeZero_> I <3 haskell  :)
11:08:56 <CubeZero_> goodbye and thank you
11:10:13 <mcstar> hm, why dont functions derive Show?
11:10:33 <dervall> I'm looking for a library from which I can do _simple_ screen drawing. I.e. setting pixels in a window. Any easy options?
11:10:36 <mekeor> mcstar: how do you mean?
11:10:40 <rwbarton> derive? they don't even have a Show instance at all. how would you show a function?
11:10:51 <c_wraith> dervall: SDL might work for you.
11:10:57 <mcstar> in the lisp family there is a string replresentation of a function
11:11:22 <dervall> c_wraith: if it would install, then yes. On windows that is apparently very hard
11:11:25 <mekeor> mcstar: in haskell, there's not. (AFAIK.)
11:11:26 <mcstar> porbably it doesnt make much sense in a pure word
11:11:30 <mcstar> world*
11:11:38 <mcstar> i know
11:11:39 <mauke> mcstar: like "#<SYSTEM-FUNCTION SQRT>"?
11:11:44 <mcstar> yeah
11:11:49 <mauke> how is that useful?
11:11:51 <c_wraith> dervall: oh. well, yeah, windows is like a third-class citizen.
11:11:59 <rwbarton> in general Haskell people expect that if f x = g x for all x then f = g and then show f = show g
11:11:59 <mcstar> mauke: im thinking about the same thing XD
11:12:08 <mauke> instance Show (a -> b) where show _ = "#<some function>"
11:12:25 <mekeor> mcstar: you can make functions ':: Bool -> Bool -> Bool' an instance of Show. that's fun.
11:13:05 <mcstar> mauke: maybe it coult print the function's type signature?
11:13:18 <mroman_> Seems like the hmp3 package is completely broken.
11:13:28 <dervall> c_wraith: I'm quite new at this haskell thingie, and I time spend installing things is time not developing. OpenGL works out of the box but is pretty lousy for drawing pixels
11:13:54 <dervall> trying to do the raytracer thing for learning, a usual go-to option for me :)
11:13:59 <c_wraith> dervall: can you just draw pixels on a texture, then render a square with that texture taking the whole window?
11:14:03 <mroman_> I fixed the getline issue but there are plenty of other issues.
11:14:48 <dervall> c_wraith: I could, if there was a way to find out the haskell bindings for it.
11:14:59 <lispy> dervall: I wrote a haskell raytracer that doesn't use opengl. I can share code with you if you like
11:15:08 <lispy> dervall: in fact, it has no dependencies other than pure Haskell
11:15:21 <dervall> lispy: what does it draw with?
11:15:39 <lispy> dervall: originally I just wrote my own png files. Now I use juicypixels to write the png
11:15:40 <hpaste> mekeor pasted “was this predictable  (mcstar, look!)” at http://hpaste.org/66829
11:15:59 <lispy> dervall: I can also help you with opengl (I'm the maintainer)
11:16:03 <mekeor> was this ^ predictable?
11:16:08 <rwbarton> did you build with optimizations?
11:16:12 <mekeor> no
11:16:16 <mekeor> oO
11:16:22 <mekeor> should i?
11:16:26 <mekeor> i'll try that.
11:16:30 <rwbarton> you shouldn't even bother running 'time' on a program compiled without optimizations
11:16:35 <dervall> lispy: I think I can do that, though it would be great if I could get it to the screen. Easier for me to see things that way
11:16:44 <mekeor> rwbarton: -On  n == ?
11:16:46 <rwbarton> -O2
11:16:48 <mekeor> ok
11:17:00 <lispy> dervall: I would highly recommend using GLFW-b to get your opengl context
11:17:05 <lispy> dervall: I have example code...
11:17:22 <dervall> lispy: what's GLFW-b?
11:17:26 <lispy> dervall: https://github.com/dagit/nehe-tuts  also on hackage by the same name
11:17:54 <dervall> lispy: Oh! Thanks!
11:17:58 <lispy> dervall: it's a binding to GLFW
11:18:07 <lispy> dervall: You might find this blog entry helpful: http://blog.codersbase.com/2011/03/picking-gui-library-to-use-with-opengl.html
11:18:20 <dervall> lispy: I got something out of the box with the platform, used that for my first program
11:18:34 <lispy> dervall: what platform are you currently developing on?
11:18:36 <mcstar> mekeor: and still, there is IO, i think it takes a lot of time to print that string
11:18:41 <lispy> dervall: I mean, osx, windows, linux?
11:18:44 <rwbarton> mekeor: you could also try "map id . map id . ..."
11:18:52 <hpaste> mekeor annotated “was this predictable  (mcstar, look!)” with “new version -- with optimization” at http://hpaste.org/66829#a66830
11:18:57 <dervall> lispy: windows
11:19:17 <rwbarton> but yeah, the IO is going to kill you
11:19:18 <zhulikas> what is the fastest way of taking specific amount of elements from an end of a list?
11:19:19 <mekeor> mcstar: but both main-functions print the same string.
11:19:25 <mekeor> rwbarton: ^
11:19:36 <mcstar> i dont see a problem
11:19:40 <lispy> dervall: ah okay. THen yes, the HP is probably the least painful way to go, but you can safely upgrade OpenGL and install GLFW-b (actuall, GLFW-b works equally well on all platforms)
11:19:42 <rwbarton> but... the difference in times is going to be dwarfed by the cost of printing the string
11:19:43 <mcstar> id is optimized away
11:19:48 <dervall> lispy: I think I used GLUT.. https://github.com/Dervall/HetaBalls
11:19:53 <mekeor> mcstar: yep. that's nice.
11:20:07 <lispy> dervall: yeah, GLUT is a common choice, but I really try to discourage it.
11:20:10 <dervall> lispy: Will that install with cabal?
11:20:12 <rwbarton> I guess you may also have list fusion going on
11:20:19 <lispy> dervall: yes, cabal install GLFW-b
11:20:24 <mekeor> rwbarton: can -O2 cause any problems/issues/bugs ?
11:20:34 <lispy> dervall: and you don't have to worry about a glut32.dll
11:20:40 <rwbarton> it can make your program slower/use more memory
11:20:46 <mcstar> it can cause SO if you dont -O
11:20:56 <rwbarton> it takes longer to compile
11:21:00 <mekeor> mcstar: SO ?
11:21:07 <mekeor> rwbarton: ah
11:21:09 <dervall> lispy: woop! it installed
11:21:11 <mcstar> stack overflow
11:21:26 <mcstar> at least i run out of stack space with recursion with no -O flag
11:21:29 <lispy> dervall: BTW, you might like #haskell-game. Quite a few people in there dabble in opengl
11:21:32 <mekeor> mcstar: if i DONT -O .. okay..
11:21:43 <mekeor> rwbarton: why that? why more memory / slower ?
11:21:48 <fmap> zhulikas: take n . reverse?
11:21:56 <mekeor> fmap: nice name.
11:22:02 <zhulikas> hmm not sure...
11:22:03 <mekeor> i mean, nickname.
11:22:05 <zhulikas> reverse is not lazy
11:22:11 <lispy> dervall: anyway, if you poke around my github page you'll find my raytracer, but I don't want to ruin the experience so I won't link you to it directly :)
11:22:11 <dervall> lispy: I'm not really out for making games. Graphics are just my goto thing for coding in new languages for some reason. Old habits y'know
11:22:18 <zhulikas> isn't it the same as drop n list?
11:22:42 <mcstar> dervall: qbasic graphing rings a bell? XD
11:22:52 <lispy> dervall: I have a binding to freetype2 that I started for adding a font library, but I didn't get very far yet
11:22:53 <zhulikas> hmm, what about pattern matching the end of the list?
11:23:00 <zhulikas> number of elements never change
11:23:07 <zhulikas> so maybe (_:a:b:c:[]) ?
11:23:10 * lispy should disappear for a bit
11:23:17 <zhulikas> would it be fast?
11:23:30 <dervall> mcstar: modifying the monkey game in qbasic instead of doing actual schoolwork rings bells...
11:23:55 <mcstar> ok, you won!
11:24:12 <dervall> mcstar: Am I old now? :(
11:24:15 <byorgey> haha, I implemented so many cheat modes for the monkey game, it was awesome
11:24:20 <mekeor> zhulikas: that doesn't do waht you expect it to do, i think.
11:24:29 <byorgey> I also turned the snake game into 4-player
11:24:38 <zhulikas> hmm
11:24:44 <byorgey> we would sit in science class with four people crammed around one keyboard playing snake
11:25:06 <dervall> lispy: The tutorials you have there, are those for the GLFW-b bindings?
11:25:10 <lispy> dervall: one thing to watch out for, ghci + opengl doen't mix well. You have to start ghci with -fno-ghci-sandbox otherwise you'll get random crashes due to the OS libraries using thread local storage and ghci not respecting that without the special flag
11:25:17 <mekeor> zhulikas: rather (_:_:_:_:_:_:_:_:x:y:z:[]) .  but attention! you have to be sure that the length of the list is always the same!!!!
11:25:19 <mcstar> i guess its a different generation, we played Carmageddon in school
11:25:29 <zhulikas> length is not the same. Selection is the same
11:25:42 <lispy> dervall: They are a mixture of glfw-b and opengl-raw. I have some older versions that use the higher level opengl api
11:25:45 <dervall> lispy: I compile, haven't interpreted much :)
11:25:53 <zhulikas> > let t (_:a:b:[]) = a:b:[] in [1..10]
11:25:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:25:57 <lispy> dervall: I have to run
11:26:02 <zhulikas> > let t (_:a:b:[]) = a:b:[] in t [1..10]
11:26:03 <lambdabot>   *Exception: <interactive>:3:4-24: Non-exhaustive patterns in function t
11:26:03 <lispy> dervall: feel free to /msg me
11:26:06 <zhulikas> hm :|
11:26:18 <dervall> lispy: thanks for your help :)
11:26:44 <mcstar> zhulikas: ive never seen anything like that
11:27:01 <nand`> > let t = tail in t [1..10]
11:27:02 <lambdabot>   [2,3,4,5,6,7,8,9,10]
11:27:35 <zhulikas> I have a list of few thousands of elements and need to select last 5 as fast as possible
11:27:41 <mcstar> > let t (_:a:b:[]) = a:b:[] in t
11:27:42 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
11:27:43 <lambdabot>    arising from a use ...
11:28:00 <zhulikas> this is not one-time selection
11:28:07 <nand`> > let t = take 5 . reverse in t [1..1000]
11:28:07 <zhulikas> I will have hundreds of these lists
11:28:09 <lambdabot>   [1000,999,998,997,996]
11:28:09 <zhulikas> (project euler)
11:28:27 <mcstar> > let t (_:a:b:[]) = a:b:[] in  I dont get what this means
11:28:28 <lambdabot>   Not in scope: data constructor `I'Not in scope: `dont'Not in scope: `what'N...
11:28:41 <mekeor> in x:xs, the type of `x' is `a' and the type of `xs' is `[a]'. remember that.
11:28:46 <mekeor> zhulikas: ^
11:28:48 <zhulikas> mcstar, supposed to ignore beginning of a list and return only two last elements :))
11:29:08 <mcstar> zhulikas: i dont uderstand that 't' there
11:29:19 <mekeor> zhulikas: (:) adds exactly ONE element in front of a list.
11:29:21 <nand`> :t (:) -- zhulikas
11:29:22 <lambdabot> forall a. a -> [a] -> [a]
11:29:29 <nand`> ^- it can only match a single a
11:29:42 <alpounet> zhulikas, you can't know what the last 5 elements are without going until the end of the list
11:29:45 <mcstar> oh, t was defined before?
11:29:50 <nand`> so your code would work in turning [1,2,3] into [2,3] but not anything of a different length
11:29:56 <alpounet> can't you instead build your list the other way around?
11:30:00 <mekeor> zhulikas: (x:xs) is a list whose first element is (x) and the rest is (xs) !
11:30:06 <zhulikas> ok, I see
11:31:16 * mekeor believes zhulikas is gonna become a powerful haskeller.
11:31:26 <zhulikas> dude :|
11:31:33 <mcstar> zhulikas: wth is going on with that let???
11:31:47 <mcstar> i dont want to sound like a nagging ass, but i really dont get it
11:32:01 <fmap> zhulikas: perhaps you are using a wrong data structure
11:32:10 <Guest13213> let villain = ((28, "chirs"), (99, "effie")) in fst villain - How to get LAST villain?
11:32:18 <Guest13213> lst dosen't work
11:32:20 <zhulikas> snd villain
11:32:35 <Guest13213> what does "snd" stand for?
11:32:38 <mekeor> second
11:32:39 <zhulikas> second.
11:32:48 <zhulikas> (a,b) -> b
11:32:52 <nand`> :t snd
11:32:53 <lambdabot> forall a b. (a, b) -> b
11:32:54 * hackagebot hecc 0.3.2 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.3.2 (MarcelFourne)
11:32:55 <mekeor> (there's also fst, like first)
11:33:19 <Guest13213> but if I dont know the number of items and want to get the last one. How do I do that?
11:33:19 <mcstar> ah damn, ok, it is wrong, but it doesnt get evaluated?
11:33:48 <mcstar> let t (_:a:b:[]) = a:b:[] in [1..10]this:
11:33:54 <mekeor> Guest13213: (x,y) is a TUPLE with the length two. x and y can have different types.
11:34:08 <mcstar> since a:b:[] doesnt have a constructor 't'
11:34:09 <mekeor> Guest13213: maybe you are looking for LISTs?
11:34:21 <zhulikas> mcstar, just non-exhaustive patterns
11:34:29 <mcstar> so the pattern cannot match, but nothing in the let bind is referenced after 'in'
11:34:30 <zhulikas> when you run it
11:34:36 <zhulikas> ok, whatever
11:34:42 <Guest13213> uhm, what is the different... (I just laneded here from wikipedia, Im a PHP programmer)
11:34:51 <zhulikas> that was just an idea of how (maybe) it could be achieved
11:34:52 <mekeor> > last [(28, "chirs"), (99, "effie"), (123, "foo"), (234, "bar")] -- Guest13213
11:34:53 <lambdabot>   (234,"bar")
11:34:58 <Guest13213> In php arrays, list and objects are like the same thing
11:35:04 <zhulikas> @src last
11:35:04 <lambdabot> last [x]    = x
11:35:04 <lambdabot> last (_:xs) = last xs
11:35:04 <lambdabot> last []     = undefined
11:35:11 <zhulikas> hm :|
11:35:20 <mcstar> zhulikas: you really confused me, i thought it DID something, i didnt notice it just returned the list [1..10] XD
11:35:27 <Guest13213> Thx :)
11:35:42 <k00mi> zhulikas: you might want to think about using an array instead of a list
11:35:43 <mekeor> Guest13213: as i said. TUPLEs have a certain, unchangeable length. the elements of a tuple can have different types.
11:35:45 <zhulikas> mcstar, so I will not become a powerful Haskeller after all? :(
11:35:52 <rwbarton> Guest13213: list can be of unknown length but the elements must all be of the same type. tuple has a fixed length, the components can have different types.
11:36:02 <mcstar> i would bet on you!
11:36:04 <zhulikas> oh, that wasnt you who said that
11:36:07 <mcstar> no
11:36:48 <mekeor> Guest13213: LISTs have a "changeable" length but the elements have all the same type... -- but anyway, you seem to have solved your problem...
11:36:56 <CubeZero> rwbarton: and if i wanted both - a changeable length with several types ?
11:37:08 <CubeZero> rwbarton: like variadic templates in c++ ?
11:37:10 <rwbarton> what would you do with that
11:37:15 <Guest13213> @mekeor ok
11:37:15 <lambdabot> Unknown command, try @list
11:37:17 <mcstar> define your algebraic type
11:37:22 <mekeor> heh
11:37:22 <Guest13213> @list
11:37:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:37:41 <CubeZero> ah algebraic type - solved thx
11:37:48 <mekeor> @faq Can Haskell solve Guest13213's problem?
11:37:48 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:55 <Veinor> i wonder if there's a nice way to do default arguments using arrow
11:37:57 <Veinor> s
11:38:12 <mcstar> @faq Can haskell self-destruct?
11:38:13 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:25 <mcstar> @faq Can haskell harm a human being?
11:38:25 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:35 * nand` wonders if a [Dynamic] would make any sense
11:38:41 <CubeZero> rwbarton: can you give me one more tip please ? i dont know how i can prevent my functions carrying the ST s around in parameters
11:38:42 <Veinor> probably not if the goal is 'make code shorter', because you'd need to do some kind of runDefault
11:38:43 <nand`> in solving CubeZero's predicament
11:38:45 <Guest13213> @faw Can haskell learn me haskell?
11:38:45 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:50 <Guest13213> cool
11:39:07 <zhulikas> @faq Can haskell be a bad programming language?
11:39:07 <lambdabot> The answer is: Yes! Haskell can do that.
11:39:19 <zhulikas> s/do/be
11:39:33 <CubeZero> rwbarton: should i use runSTUArray to get a UArray and then unsafeThaw it to STUArray again when i need to change it in the next function?
11:39:40 <rwbarton> no
11:39:43 <nand`> zhulikas: very easy, all you have to do is add IO to all of your functions and use an imperative style
11:39:50 <alpounet> mcstar, asimov fan uh?
11:39:59 <mekeor> @faq Is Haskell able to not be able to do something?
11:39:59 <lambdabot> The answer is: Yes! Haskell can do that.
11:40:40 <mokus> @faq Can Haskell create a rock so large that Haskell can't move it?
11:40:41 <lambdabot> The answer is: Yes! Haskell can do that.
11:40:46 <byorgey> CubeZero: you can't prevent your functions from carrying the ST s around.  That's the point.  The type system is *helping* you by forcing you to declare which functions can modify your array.
11:41:25 <mcstar> alpounet: i wouldnt say that, the 3 laws are common knowledge :)
11:41:29 <zhulikas> @faq Can haskell do this? \o/
11:41:29 <lambdabot> The answer is: Yes! Haskell can do that.
11:41:37 <zhulikas> awesome.
11:41:40 <zhulikas> No more questions.
11:41:41 <rwbarton> but before he had every function taking an ST s (STUArray s Int Int) as a parameter, which is not what he wanted
11:41:48 <byorgey> oh, I see
11:42:00 <CubeZero> so how can i do better ?
11:42:13 <byorgey> so something like   STUArray s Int Int -> ... -> ST s foo   is wanted instead?
11:42:23 <mcstar> @faq Can haskell create a rock so large, that even Haskell cant create?
11:42:23 <rhapsodhy> o/
11:42:24 <lambdabot> The answer is: Yes! Haskell can do that.
11:42:40 <rwbarton> unsafeCreateRock
11:43:01 <CubeZero> :t unsafeCreateRock
11:43:02 <lambdabot> Not in scope: `unsafeCreateRock'
11:43:04 <mokus> and then unsafeCoerceRockToMove
11:43:06 <CubeZero> ^.^
11:43:08 <rhapsodhy> how come cabal works as root but not as user?
11:43:12 <alpounet> mcstar, doh! not *that* common actually :/
11:43:55 <byorgey> rhapsodhy: you should never use cabal as root.
11:43:59 <CubeZero> so if i carry ST s (STUArray s Int Int) around in parameters there exists the possibility, that the array is constructed several times ?
11:44:08 <byorgey> rhapsodhy: but once you do, it will likely create files with root permissions, so from then on it will only work as root.
11:44:09 <rhapsodhy> byorgey: didn't work, anyway
11:44:23 <rhapsodhy> funny thing is
11:44:31 <rhapsodhy> i purged all haskell packages from my system
11:44:35 <rhapsodhy> and reinstalled them
11:44:41 <rhapsodhy> and cabal still doesn't work
11:44:49 <rhapsodhy> it does tho on a virgin debootstrap
11:44:52 <ion> Did you rm -fr ~/.cabal/ ~/.ghc?
11:44:54 <byorgey> rhapsodhy: did you delete ~/.cabal  and ~/.ghc  ?
11:45:07 <byorgey> those are more likely to be the issue
11:45:43 <CubeZero> rwbarton: how would you transport this array around?
11:45:44 <rhapsodhy> ok, i'll try it again
11:46:23 <mcstar> "(ignoring ⊥, which is a party pooper)"
11:46:33 <rwbarton> you just pass the array around and use it where you need it
11:46:42 <CubeZero> as UArray ?
11:46:43 <rwbarton> hard to be more specific
11:46:44 <rwbarton> no
11:46:48 <rwbarton> as STUArray s Int Int
11:47:11 <Guest13213> why can't I write map (-3) [1..3]?
11:47:24 <Guest13213> How to subtract?
11:47:25 <CubeZero> so how do i get it from ST s (STUArray s Int Int) to STUArray s Int Int without using runSTUArray ?
11:47:32 <rwbarton> > map (subtract 3) [1..3]
11:47:33 <lambdabot>   [-2,-1,0]
11:47:46 <byorgey> Guest13213: (-3) parses as a negative number, not an operator section of (-), unfortunately
11:47:54 <byorgey> Guest13213: the 'subtract' function is provided for this purpose
11:48:04 <Guest13213> aha, ok.
11:48:11 <dcoutts> or you could use (\x -> x-3)
11:48:12 <mcstar> i think that is very clear from LYAH
11:48:43 <byorgey> CubeZero: using the fact that ST s  is a monad.  i.e. using (>>=) or something in a do-block like    array <- thingy; ... do something with array...   where thingy :: ST s (STUArray s Int Int)
11:48:55 <mcstar> > map ((-)3) [1..10]
11:48:56 <lambdabot>   [2,1,0,-1,-2,-3,-4,-5,-6,-7]
11:49:14 <Veinor> every time i try to use cabal-dev ghci I get
11:49:14 <Guest13213> wtf
11:49:17 <Veinor> "Failed to extract GHC build arguments"
11:49:37 <mcstar> > (-) 3 <$> [1,2]
11:49:38 <lambdabot>   [2,1]
11:50:01 <mekeor> > (subtract 3) <$> [1,2]
11:50:02 <lambdabot>   [-2,-1]
11:50:09 <Guest13213> haskell is cool
11:50:58 <CubeZero> rwbarton: then i will use >>= ok thank you very much. Enjoy!
11:51:08 <mcstar> >flip (-) 3 <$> [1..10]
11:51:10 <mekeor> > 5 4 -- don't look at that, Guest13213; that might confuse you (since it's not usual haskell (but a lambdabot-feature)):
11:51:11 <lambdabot>   5
11:51:27 <mcstar> >flip (-) 3 <$> [1..10]
11:51:34 <mcstar> hm
11:51:35 <Guest13213> filter (>5 && <40) [1..99] - How do I write AND in haskell?
11:51:37 <mekeor> > flip (-) 3 <$> [1..10]
11:51:39 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
11:51:40 <mcstar> where is my output?
11:51:40 <CubeZero> > print "hi"
11:51:40 <lambdabot>   <IO ()>
11:51:54 <mcstar> lambdabot is slow today
11:52:01 <CubeZero> > map (+1) [1..3]
11:52:02 <lambdabot>   [2,3,4]
11:52:17 <ion> > filter (liftA2 (&&) (>5) (<10)) [1..99]
11:52:18 <byorgey> mcstar: a space following the >  is required
11:52:18 <lambdabot>   [6,7,8,9]
11:52:28 <mcstar> oh
11:52:37 <c_wraith> flip (-) is the same as subtract
11:52:39 <CubeZero> bit and is .&. from the Data.Bits package
11:52:44 <CubeZero> logical and is &&
11:52:54 <CubeZero> and can be used as infix
11:52:59 <CubeZero> @src &&
11:53:00 <lambdabot> True  && x = x
11:53:00 <lambdabot> False && _ = False
11:53:24 <CubeZero> i start to like the lambdabot :D
11:53:30 <rwbarton> "(>5 && <40)" has several problems
11:53:37 <rwbarton> that you used && is not one of them
11:53:38 <ion> (>5) is sugar for (\x -> x > 5). You can’t just “&&” two functions.
11:53:45 <mekeor> CubeZero: you won't end liking lambdabot then.
11:54:14 <mekeor> s/end liking/end to like/
11:54:25 <CubeZero> how about (\x -> x > 5 && x < 99) ?
11:54:36 <mcstar> there is function that makes that possible
11:54:39 <mcstar> i forgot its name
11:54:43 <Guest13213> okay..
11:54:53 <CubeZero> rwbartons ?
11:54:57 <ion> cubezero: Yeah, that would work.
11:55:52 <Guest13213> what does \x do?
11:55:53 <Clint> how do i do the inverse of \c -> (16 + (fromIntegral c .&. 15)) `shiftL` ((fromIntegral c `shiftR` 4) + 6) ?
11:56:05 <verement> > filter ((&&) <$> (>5) <*> (<10)) [1..10]
11:56:06 <lambdabot>   [6,7,8,9]
11:56:11 <CubeZero> creates a function that waits for a parameter x and does what comes behind the ->
11:56:40 <CubeZero> \x -> x + 1 is a function that takes a x and adds 1 to it
11:56:53 <CubeZero> (\x -> x + 1) 3
11:57:01 <CubeZero> > (\x -> x + 1) 3
11:57:02 <lambdabot>   4
11:57:09 <Guest13213> if I want many parameters and optional parameters?
11:57:30 <zzo38> I want to use Plus even if something is not Functor, such as Endo (from Data.Monoid).
11:57:39 <CubeZero> many parameters goes like so: \ a b c ... -> use a b c etc.
11:57:49 <Guest13213> ok
11:57:49 <CubeZero> > (\ a b -> a + b) 1 2
11:57:50 <lambdabot>   3
11:58:00 <Guest13213> (\a b -> a + b) 1 2
11:58:02 <CubeZero> optional i dont know
11:58:10 <Guest13213> (\ a b -> a + b) 1 2
11:58:13 <CubeZero> write "> " bevore it
11:58:19 <Guest13213> aha
11:58:19 <Guest13213> :P
11:58:22 <ion> Use Maybe for optional parameters.
11:58:27 <CubeZero> then lamdbabot will kindly calculate ;)
11:58:50 <CubeZero> @src Maybe
11:58:50 <lambdabot> data Maybe a = Nothing | Just a
11:59:05 <mcstar> what is the name of the function that takes 2 functions, and an argument, and combines the 2 functions over the same argument?
11:59:10 <mcstar> maybe it takes 3 functions
11:59:26 <CubeZero> twice ?
11:59:26 <zzo38> mcstar: Is liftA2 what you are looking for?
11:59:31 <CubeZero> @src twice
11:59:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:59:37 <mcstar> zzo38: no
11:59:40 <zzo38> Or perhaps (<*>) is it?
11:59:42 <CubeZero> twice f x = f (f x) ?
11:59:48 <mcstar> it has a name
11:59:49 <zzo38> Or maybe you want (&&&)
11:59:55 <mcstar> not symbols
11:59:59 <CubeZero> :t &&&
12:00:00 <lambdabot> parse error on input `&&&'
12:00:07 <Clint> what do you mean "combines"?
12:00:07 <CubeZero> :t (&&&)
12:00:08 <mcstar> i think i saw it in LYAH
12:00:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:00:12 <verement> @src (<*>)
12:00:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:00:26 <mcstar> ill figure it out
12:00:30 <ion> Are you perhaps thinking of (.)?
12:00:37 <mcstar> no :)
12:00:45 <CubeZero> :t (.)
12:00:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:00:50 <verement> :t (<*>)
12:00:50 <zzo38> mcstar: Can you explain better what it is you were looking for?
12:00:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:01:15 <zzo38> Since neither myself nor other people know what it is you want
12:01:32 <CubeZero> can you give us an example of its behaviour ?
12:01:52 <mcstar> combinator f g h x = (f (g x) (h x))
12:01:54 <Guest13213> > let square x = if x>1 then x * square(x-1) else 1 in square 5
12:01:55 <lambdabot>   120
12:01:56 <mcstar> something like this
12:02:06 <Guest13213> :D
12:02:21 <zzo38> mcstar: I think that is liftA2 isn't it?
12:02:29 <c_wraith> yeah, that's liftA2/liftM2
12:02:37 <c_wraith> with the function monad/applicative instance
12:02:40 <Guest13213> What do you use haskell for?
12:02:47 <mcstar> im sure i never heard of liftA2/M2 before
12:02:49 <c_wraith> Guest13213: writing progreams
12:02:58 <Guest13213> ofc, but what type of programs
12:03:00 <mcstar> it was something simpler, possibly im just imagining something
12:03:00 <CubeZero> isnt it just the faculty function?
12:03:09 <otters> @pl \f g h x -> f (g x) (h x)
12:03:09 <lambdabot> liftM2
12:03:15 <otters> oh
12:03:15 <CubeZero> fac n = n * fac (n - 1) ?
12:03:16 <Guest13213> CubeZero: yes, i made i by my own *proud*
12:03:32 <CubeZero> ^.^
12:03:35 <zzo38> Guest13213: And  fac 0 = 1
12:03:46 <Guest13213> huh
12:03:47 <zzo38> s/Guest13213/CubeZero/
12:03:50 <Guest13213> > fac 0 = 1
12:03:51 <lambdabot>   <no location info>: parse error on input `='
12:04:03 <CubeZero> > fac 0
12:04:03 <lambdabot>   Not in scope: `fac'
12:04:17 <zzo38> > let { fac 0 = 1; } in fac 0
12:04:17 <lambdabot>   1
12:04:20 <CubeZero> > let fac n = n * fac (n - 1) in fac 0
12:04:21 <lambdabot>   *Exception: stack overflow
12:04:38 <CubeZero> oO was it me ?
12:04:39 <Guest13213> u need an IF
12:04:52 <CubeZero> > let fac n = n * fac (n - 1) in fac 0
12:04:53 <lambdabot>   *Exception: stack overflow
12:05:20 <verement> > let { fac 0 = 1; fac n = n * fac (n - 1); } in fac 5
12:05:21 <lambdabot>   120
12:05:38 <Guest13213> this is like code golf
12:05:44 <CubeZero> > let fac n | n <= 0 = 1 | n * fac (n - 1) in fac 0
12:05:45 <lambdabot>   <no location info>: parse error on input `in'
12:05:53 <CubeZero> > let fac n | n <= 0 = 1 ; | n * fac (n - 1) in fac 0
12:05:53 <lambdabot>   <no location info>: parse error on input `|'
12:05:59 <mcstar> zzo38: i was thinking of Data.Function.on
12:06:41 <CubeZero> let fac n = if n <= 0 then 1 else n * fac (n - 1)
12:06:48 <CubeZero> > let fac n = if n <= 0 then 1 else n * fac (n - 1)
12:06:48 <lambdabot>   not an expression: `let fac n = if n <= 0 then 1 else n * fac (n - 1)'
12:06:51 <zzo38> mcstar: O, that is what you wanted. Then use that one OK
12:06:53 <CubeZero> > let fac n = if n <= 0 then 1 else n * fac (n - 1) in fac 0
12:06:54 <lambdabot>   1
12:06:58 <CubeZero> > let fac n = if n <= 0 then 1 else n * fac (n - 1) in fac 10
12:06:58 <lambdabot>   3628800
12:07:00 <mcstar> let you apply a function to 2 arguments before it passes them to a 2-ary function
12:07:27 <mcstar> zzo38: lol, ok i was just trying to remember
12:07:52 <CubeZero> :t Data.Function.on
12:07:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:09:00 <mcstar> CubeZero: i thought it would be good for your && example, but it isnt
12:09:25 <otters> @unpl liftA2 (&&)
12:09:25 <lambdabot> liftA2 (&&)
12:09:43 <CubeZero> :t liftA2
12:09:44 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:11:51 <otters> @unpl liftM2 (&&)
12:11:51 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b && a))
12:11:53 <otters> there we go
12:12:33 <Guest13213> <?PHP function fac($n) {return ($n > 1) ? $n * fac($n-1) : 1;} echo fac(5); ?>
12:12:42 <Guest13213> fac in PHP
12:13:36 <CubeZero> is php lazy ?
12:13:54 <Guest13213> What do you mean?
12:13:54 <otters> no
12:13:56 <zzo38> CubeZero: No but it is tail recursive
12:14:15 <otters> so it's more advanced than python is
12:14:19 <CubeZero> :)
12:14:27 <rwbarton> stackoverflow says php doesn't have tail recursion
12:14:30 <zzo38> Actually PHP is full of much dumb things
12:14:31 <rwbarton> er TCO
12:14:34 <Guest13213> *don't understand a shit*
12:14:44 <zzo38> True; it doesn't have TCO
12:14:52 <rwbarton> so why do you mention tail recursion
12:15:02 <rwbarton> in response to "is php lazy"
12:15:08 <zzo38> I thought it does but I am unsure
12:15:16 <CubeZero> > liftM2 (&&) True True
12:15:17 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
12:15:17 <lambdabot>         against inferred typ...
12:15:37 <CubeZero> > liftM2 (&&) (return True) (return True)
12:15:38 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
12:15:38 <lambdabot>    arising from a use of ...
12:16:16 <ejpbruel> hi
12:16:27 <CubeZero> and what ist TCO ?
12:16:28 <ion> I’d have been sincerely surprised if PHP had TCO.
12:16:30 <ejpbruel> can i ask a random question?
12:16:40 <ion> ejpbruel: You already did.
12:16:50 <Clint> it wasn't random
12:16:52 <ejpbruel> ion: ill take that as a yes ;)
12:17:05 <rwbarton> tail call optimization
12:17:12 <Guest13213> What is TCO? Wikipedia sais "Total cost of ownership" and I think you talk about something else
12:17:13 <CubeZero> ah kk thx
12:17:14 <Guest13213> aha
12:17:16 <Guest13213> thx
12:17:45 <ion> guest13213: You’re still one “kk” short.
12:17:48 <ejpbruel> it just occured to me: in theory we can represent data as functions (the Church integers for example), so why does Haskell include data constructors?
12:17:48 <CubeZero> @unpl liftM2 (&&)
12:17:48 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b && a))
12:17:57 <Flatlander> Guest13213, Tail Call Optimization
12:18:17 <Guest13213> huh KK short?
12:18:24 <ion> ejpbruel: For convenience and pattern matching.
12:18:46 <zzo38> And make Alt/Plus classes not have Functor as a superclass (Endo from Data.Monoid is one example); I think this makes (Codensity Endo) to be a list monad
12:18:54 <CubeZero> > let true = return True :: IO True in liftM2 (&&) true true
12:18:55 <lambdabot>   Not in scope: type constructor or class `True'
12:19:02 <otters> IO Bool
12:19:04 <otters> is what you want
12:19:06 <ejpbruel> ion: pattern matching can be compiled into simple case expressions, which can *also* be expressed as simple functions, right?
12:19:11 <CubeZero> > let true = return True :: IO Bool in liftM2 (&&) true true
12:19:12 <lambdabot>   <IO Bool>
12:19:21 <rwbarton> also don't you lose sharing horribly if you try to use church numerals etc.
12:19:40 <CubeZero> > let true = return True :: IO Bool in do bool <- liftM2 (&&) true true ; print bool
12:19:41 <lambdabot>   <IO ()>
12:20:07 <zzo38> lambdabot will not run I/O actions; it can only display the type
12:20:14 <ejpbruel> rwbarton: yeah, so thats a performance argument. it seems to be that thats the only reason to want data constructors in your language. you *could* do it with pure functions alone, but it would be much much slower
12:20:49 <Veinor> oh god
12:20:59 <Veinor> i figured out a way to implement arbitrary amounts of leading default arguments
12:21:15 <CubeZero> share your secret ;)
12:21:34 <Guest13213> What does u guys use Haskell for? In your job? To automate things? For websites?
12:21:49 <zzo38> Guest13213: Just look at Hackage see the programs that are there
12:22:00 <Guest13213> ok
12:22:01 <ion> To compute the first few Fibonacci numbers on IRC.
12:22:11 <ejpbruel> oh well, thanks for the feedback, rwbarton + ion :)
12:22:11 <CubeZero> have you ever heard of neo-layout ?
12:22:27 <rhapsodhy> okay, i rm -rf'd .ghc and .cabal and still no luck
12:22:39 <zzo38> Guest13213: I use Haskell since I enjoy mathematics and computer programming
12:23:01 <CubeZero> sudo apt-get purge cabal?
12:23:03 <Guest13213> ok. Can we draw things with Haskell?
12:23:10 <ion> yes
12:23:14 <zzo38> Guest13213: Yes, there are some packages for such things
12:23:15 <rhapsodhy> CubeZero: done that
12:23:18 <ion> @faq Can Haskell draw things?
12:23:18 <lambdabot> The answer is: Yes! Haskell can do that.
12:23:25 <Veinor> http://hpaste.org/66831
12:23:33 <mcstar> Guest13213: i use it for PE
12:23:39 <Guest13213> PE?
12:23:40 <Veinor> it only works with monomorphic functions, i think
12:23:42 <CubeZero> PE  ?
12:23:49 <mcstar> but since i dont do pe nowdays, i dont use haskell
12:24:00 <mcstar> but its good for crytoclass
12:24:06 <mcstar> project euler
12:24:26 <Veinor> rhapsodhy: what happens when you try to run cabal as nonroot?
12:24:43 <rhapsodhy> i've tried as root as a last resort
12:24:46 <mcstar> Guest13213: if you want to draw, i recommend gloss
12:24:49 <rhapsodhy> i can't compile vector
12:24:50 <Veinor> also, there are haskell web frameworks: yesod, snap, and happstack are the three that come to mind
12:25:00 <Veinor> could you paste the error message?
12:25:01 <rhapsodhy> then if i install vector from package, something else breaks
12:25:18 <zzo38> There are a few things not as good with gloss but it does work and it is still pretty good despite a few things not as good
12:25:42 <zzo38> Is (Codensity Endo) a list monad?
12:25:55 <CubeZero> Veinor: interesting...
12:25:59 <mcstar> zzo38: what is not so good about it?
12:26:19 <rhapsodhy> http://hpaste.org/66832
12:26:19 <rwbarton> mcstar, you've walked into something here I fear :P
12:26:30 <Veinor> CubeZero: don't ever use this
12:26:31 <mcstar> o.O
12:26:37 <Veinor> this was purely an exercise in 'is it possible'
12:27:18 <Flatlander> speaking of drawing, how easy it's to get GTK and/or Cairo working? On Windows..?
12:27:19 <ion> rhapsodhy: I don’t think the output started at [2 of 2].
12:27:20 <zzo38> mcstar: Just in my opinion (and some others too), Picture should be a class instead of a exposed type, and the things such as playIO should support a return value at the end
12:27:48 <CubeZero> Veinor: it's still interesting ;)
12:27:48 <dcoutts> Flatlander: it's possible but you have to follow the instructions carefully
12:28:10 <rhapsodhy> ion: shit, sry
12:28:21 <dcoutts> Flatlander: once you've got it working, it's fine, I've used both on windows quite a bit
12:28:31 <zzo38> I also dislike that in gloss you specify a window location; that should be decided by the operating system instead
12:29:12 <Flatlander> dcoutts, what about distributing applications that use those? Is it enough to just pack the required .dlls among the executable?
12:30:04 <dcoutts> Flatlander: again, possible. You need to distribute the full set of gtk runtime files (more than just dlls) but the .zip files of them all are available.
12:30:19 <rhapsodhy> https://rhapsodhy.hu/cabal.log
12:30:51 <Flatlander> dcoutts, so it's not different from distributing a C program that uses those
12:31:07 <dcoutts> Flatlander: right, see e.g. http://code.haskell.org/~duncan/threadscope-0.2.1.zip
12:31:13 <crntaylor> @pl (\(n,(a,_)) -> (n,a))
12:31:13 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,))
12:31:34 <crntaylor> @unpl (\(n,(a,_)) -> (n,a))
12:31:34 <lambdabot> (\ (n, (a, _)) -> (n, a))
12:31:35 <Flatlander> neat, I'll check it :)
12:31:39 <rhapsodhy> Loading package primitive-0.4.1 ... ghc: mmap 192512 bytes at (nil): Operation not permitted
12:31:39 <dcoutts> Flatlander: yes it's really the same as C since ghc compiles to native code .exe and links to .dll files in the usual way
12:31:51 <Sawny> haskell feels like brainfuck
12:31:52 <rhapsodhy> wtf
12:32:47 <Flatlander> how's the licensing of the GHC runtime these days, wasn't there something about statically compiled libgmp forcing a GPL etc. few years back?
12:32:53 <mcstar> so return is to monad what fmap is to functor?
12:32:56 <rwbarton> cool error
12:33:06 <crntaylor> @unpl uncurry ((`ap` snd) . (. fst) . (const .) . (,))
12:33:06 <lambdabot> uncurry (\ g -> (\ p _ -> ((,)) g (fst p)) >>= \ u -> snd >>= \ t -> return (u t))
12:33:16 <td123> Flatlander: libgmp is linked dynamically i think
12:33:19 <dcoutts> Flatlander: yes by default it links to gmp and on windows the default for that is static linking
12:33:42 <gzmask> mcstar: like what touch is for boobs
12:33:49 <Veinor> mcstar: not really
12:33:57 <Veinor> return puts a value in the monad, so to speak
12:33:59 <dcoutts> Flatlander: for commercial projects I've handled it by providing my app as a big .o file so the customer can relink if they want to (this satisfies the LGPL)
12:34:02 <Veinor> fmap lets you manipulate values insid e afunctor
12:34:24 <mcstar> but here i read, that monad could be a functor
12:34:44 <hpc> :t liftM
12:34:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:34:47 <Flatlander> dcoutts, right, got it
12:34:48 <hpc> :t fmap
12:34:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:34:50 <rwbarton> rhapsodhy: out of memory possibly? looks really weird to me
12:34:51 <Veinor> @src liftM
12:34:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:34:51 <timthelion> does anyone know of a write up on State, from an author who approaches state from a functional rather than impertitive perspective?  All of the article's I've seen so far start with something like "so you're a C programer, and you don't know how to keep a buch of global values in Haskell?  Use this hackish State workaround"
12:34:52 <dcoutts> rhapsodhy: I'd be happy to look at that log but the https complains and the http redirects to the https version
12:35:15 <rhapsodhy> dcoutts: https is cacert
12:35:30 <mcstar> ah sry, i think i confused functor with applicative
12:35:44 <rhapsodhy> you should have their root3 ca cert installed anyway
12:35:44 <hpc> timthelion: there is a section of lyah
12:35:46 <dcoutts> rhapsodhy: nevertheless, you'll get the same reaction from most people, they'll just trust what their browser says.
12:35:48 <niklasb_> timthelion: i haven't seen such a tutorial yet. check http://learnyouahaskell.com/for-a-few-monads-more#state
12:35:58 <rwbarton> my browser didn't complain
12:36:01 <niklasb_> hpc: haha, same thought :)
12:36:08 <CubeZero> dcoutts: so you did your customer not give the full sourcecode ?
12:36:11 <Veinor> rhapsodhy: could you paste the output of ghc-pkg list?
12:36:15 <rhapsodhy> rwbarton: debian has it installed by default
12:36:17 <CubeZero> dcoutts: or you gave both?
12:36:18 <Ngevd> Hello.
12:36:28 <dcoutts> CubeZero: oh sure, but they wanted to distribute to their customers
12:36:32 <CubeZero> dcoutts: may i ask why ?
12:36:50 <Ngevd> I've got instance ToJSON (IxSet Source) where...
12:36:55 <CubeZero> dcoutts: so the could not compile it on their own ? xD
12:37:03 <Ngevd> And it's saying to use -XFlexibleInstances
12:37:06 <Ngevd> Is this what I want?
12:37:13 <elliott> Ngevd: yes
12:37:19 <dcoutts> CubeZero: we did give our client the source, they didn't want to give the source to their customers
12:37:19 <Ngevd> elliott, thanks
12:37:43 <dcoutts> CubeZero: but obviously we and the client have to comply with the BSD and LGPL
12:37:49 <CubeZero> dcoutts: ok thats their decision then
12:37:55 <rhapsodhy> Veinor: https://rhapsodhy.hu/ghc-pkg
12:38:01 <CubeZero> dcoutts: so you are a freelancer?
12:38:26 <dcoutts> CubeZero: no
12:38:49 <dcoutts> CubeZero: well-typed.com
12:39:05 <CubeZero> dcoutts: do you know where i can find a comparision / explanation on LGPL / GPL / BSD etc ?
12:39:08 <zzo38> Do you know codensity?
12:39:45 <zzo38> CubeZero: Maybe, Wikipedia has some things like that?
12:39:50 <Veinor> rhapsodhy: try nuking /var/lib/ghc/ and reinstalling the haskell platform (i assume that's what you used)
12:39:56 <dcoutts> CubeZero: a good place to start is reading the licenses themselves, they're not that hard. Apart from that, I don't have any specific references, just google.
12:40:07 <zzo38> I suggest GPL for standalone programs and public domain for libraries; but do what you want
12:40:40 <rhapsodhy> Veinor: will try that tomorrow
12:40:43 <rhapsodhy> thanks
12:40:43 <CubeZero> kk thx
12:41:45 <zzo38> ?tell edwardk to make Plus not require Functor (an example of such thing would be Endo from Data.Monoid)
12:41:45 <lambdabot> Consider it noted.
12:42:01 <zzo38> ?ask edwardk if (Codensity Endo) is like a list monad
12:42:02 <lambdabot> Consider it noted.
12:45:18 <timthelion> CubeZero: BSD = almost public domain can use for comercial purposes without releasing source, LGPL, can compile a closed sourced program with this library, GPL, all programs that are based on a GPL program must be open source.
12:46:26 <c_wraith> LGPL has a bizarre way of limiting its scope.  It's not clear at all what contexts it actually is valid in.
12:46:35 <CubeZero> timthelion: thank you
12:47:20 <elliott> Isn't LGPL = GPL w/ GHC?
12:47:21 <timthelion> c_wraith: there are many legal problems with GPL.
12:48:15 <c_wraith> So I usually suggest ignoring its existence. GPL if you want it, BSD/Apache/MIT otherwise. Not that the differences between them are obvious.
12:48:33 <mekeor> the haskell community is great. #haskell+cabal+hackage+ghc+hlint+hoogle+hayoo+haskellwiki+... make it haskell just brilliant.
12:48:47 <timthelion> the most obvious one, is the question "who has copyright?" does every single person who ever added a line of code have copyright?  That would make GPL quite the same as public domain.   Or do the various contributors have to agree upon themselves in a democratic maner on comercial use? that would make it like a worldwide democracy, since there's no rule that you cannot edit the source and fork...
12:49:09 <elliott> erm
12:49:15 <elliott> timthelion: you realise that BSD/MIT require attribution, too?
12:49:17 <zzo38> I use GPL for standalone program and pubic domain for libraries. But you use what you prefer; you can learn by reading licenses themself and Wikipedia and so on
12:49:18 <elliott> and so have the same problem
12:49:49 <timthelion> elliott: I didn't say it was public domain, just almost...
12:50:04 <koala_man> timthelion: having each line owned by a different person does not make a GPL work anything like public domain
12:50:32 <timthelion> koala_man: have you ever seen a source file where every line of code was commented with a copyright signature?
12:50:33 <ChristianS> timthelion: everybody can edit the source and fork a gpl-licensed program, but only if you use the same license for your fork.
12:51:01 <mauke> timthelion: does it matter?
12:51:05 <timthelion> ChristianS: but the "copyright owner" has special comercial privliges.  The question is, who owns it...
12:51:20 <mauke> why commercial?
12:51:30 <koala_man> timthelion: no, and that's not necessary for having copyright, and it's not necessary for that line to be specifically licensed as gpl
12:51:42 <ChristianS> timthelion: all the copyright owners together
12:52:12 <timthelion> mauke: for example, microsoft releases the ASPX stack as GPL, THEY can still package that in a closed source project without any source release requirements, since they are the copyright holder.
12:52:48 <mauke> timthelion: yes but I don't think that has anything to do with commerce
12:52:55 <timthelion> but if every copyright holder has such a privelage, then anyone can edit the file, add themselves to the copyright line, and then claim the right to package binarry as well.
12:53:12 <mauke> timthelion: no, you only own the copyright for your own stuff
12:53:16 <timthelion> mauke: if you aren't the "copyright holder" you must release the source...
12:53:26 <ChristianS> timthelion: the copyright owners are never bound by their own license (that's true for any license)
12:53:27 <mauke> timthelion: I never have to release anything
12:53:39 <timthelion> mauke: but then, as soon as microsoft accepts one patch, they are no longer "the copyright holder"
12:54:00 <c_wraith> timthelion: that's only true if they'll accept patches without a copyright attribution.  many companies will not.
12:54:07 <mauke> timthelion: yes, they're bound by the license of the patch
12:54:29 <timthelion> c_wraith: aka, in the case of Sun Microsystems and open office...
12:54:52 <mcstar> what if the path is trivial, and they have to replicate it literally?
12:54:56 <mcstar> patch
12:54:57 <ChristianS> timthelion: possibly, but many project have a license that every contributor has a hand copyright over to a specific entity. than that entity becomes single copyright owner and could relicencse, if necessary
12:54:59 <c_wraith> GNU requires a copyright attribution for all patches, too.  (They'd go crazy if they didn't)
12:55:18 <ChristianS> s/have a license/have a policy/
12:55:43 <mauke> I think Linux doesn't do this
12:55:50 <timthelion> c_wraith: I've never written a copyright transer agreement with them :P
12:56:37 <dcoutts> only some GNU projects use copyright transfer
12:56:50 <dcoutts> and then only for changes that they think are copyrightable
12:58:47 <Palmik> Hi guys, is there some version of System.Process that would facilitate some sandbox like functionality?
12:59:07 <timthelion> Palmik: what kind of sandbox functionality?
12:59:13 <dcoutts> sndboxing is pretty OS-specific
12:59:52 <timthelion> Palmik: I'm doing a project right now, that can sandbox code which it has the source code too... It simply uses the haskell type system...
13:02:03 <nart> ciao :)
13:07:20 <hpaste> timthelion pasted “This code is turning out to be so usefull that I wonder if I shouldn't put it on hackage...” at http://hpaste.org/66833
13:07:41 <singpolyma> What is the best way to run an IO action every N seconds?
13:07:56 <timthelion> Do any of you think it's worth sharing that?  Or is there another library that does this same thing?
13:08:21 <timthelion> singpolyma: forkIO do { myIOAction; sleep 10;}
13:08:34 <timthelion> singpolyma: wait, make that recursive ...
13:08:35 <nand`> if I want to write [x | x <- xs, x < 5] in monadic form; what do I replace the “x < 5” by?
13:08:37 <c_wraith> timthelion: you forgot a forever
13:08:45 <Palmik> dcoutts, yeah, I do not mind being OS-specific.
13:08:48 <c_wraith> nand`: guard (x < 5)
13:08:48 <singpolyma> timthelion: is sleep in prelude?
13:08:51 <Palmik> timthelion some cgroups like functionality (limiting, ram usage, disk usage, access, time, etc.) would be neat.
13:08:53 <timthelion> c_wraith: I realized that imediately
13:09:05 <ion> singpolyma: threadDelay . (*1000000) or something
13:09:10 <nand`> c_wraith: that gives me a [()]
13:09:19 <nand`> since guard :: Bool -> m ()
13:09:31 <nand`> (MonadPlus m =>)
13:09:33 <ion> nand: Indeed.
13:09:53 <ion> > do x <- [0..4]; [()]; return x
13:09:54 <lambdabot>   [0,1,2,3,4]
13:09:58 <singpolyma> ion: oh, ok, found threadDelay
13:10:19 <timthelion> Palmik: and what do you want to happen when it uses too much ram?
13:10:23 <nand`> ion: oh, right
13:11:25 <Palmik> timthelion, it would be ideal to be able to specify course of action (kill, give more memory, etc.)
13:12:02 <timthelion> singpolyma: sleep is in like System.Utils.Posix if I recall correctly, it's on Hayoo...
13:12:03 <lispy> glguy and iavor just gave a nice talk about the free package
13:12:18 <ion> lispy: URL?
13:12:19 <lispy> Free Monads are awesome
13:12:42 <lispy> ion: This talk was very informal so we don't have a video, but the library is here http://hackage.haskell.org/package/free
13:12:48 <timthelion> Palmik: and did you write the thing you wish to sandbox, or is it some evil scarry unknown binarry blob?
13:12:53 <ion> lispy: :-(
13:13:55 <lispy> ion: this looks like the same material: http://comonad.com/reader/2011/free-monads-for-less/
13:14:03 <timthelion> Did anyone look at my ThreadObjects?
13:14:11 <ion> lispy: Thanks
13:14:24 <Palmik> timthelion, well, possibly something scary. Think like uva contest site or aichallenge running 3rd party code (C, C++, Haskell, etc.) -- the aichallenge guys compile it and then run it in chroot jail.
13:14:25 <ion> Thispy
13:14:36 <elliott> thispy :D
13:15:31 * timthelion would use a rasberry pi, or qemu in Palmik's case.
13:15:51 <t7> safe haskell was built for this
13:17:11 <Palmik> timthelion, not sure how is that related. :)
13:17:46 <timthelion> Palmik: well, if you're running third party, and potentially dangerous code, then why not run it in a throw away VM?
13:17:48 <Palmik> t7, that would let me execute Haskell code sfely indeed, not so much for code written in other languages, or would it?
13:17:57 <t7> no
13:18:44 <timthelion> Palmik: just install linux on a VM, copy the VM, install the third party code, test it, delete the copy, copy the VM, install the next bit of 3rd party code...
13:18:47 <timthelion> no risk
13:19:15 <Palmik> timthelion, yes, VM would make sense (minus the overhead), I was talking about the Rasberry idea. :)
13:19:51 <timthelion> Palmik: same thing, just dd the SD card each time you tried a new entry
13:20:08 <Palmik> Well quick search found me some Haskell + chroot related stuff. :)
13:20:09 <timthelion> it would also make a cheep way of standardizing the runtime environment for the contest.
13:20:13 <augur> Philippa!
13:20:58 <acowley> copumpkin: I ported your Agda proof of Nichomacus's theorem to Coq. I have great time management skills!
13:21:05 <Palmik> timthelion, I do not think I explain the purpose of this clearly -- if you are not familiar with the uva onlinejudge site (or aichallenge), they let people upload their own code (in varias languages), compile it and execute it. :)
13:21:10 <copumpkin> acowley: excellent! I bet it's nice and short
13:21:37 <Palmik> s/I explain/I have explained
13:21:46 <acowley> copumpkin: I'm sure it could be much shorter. I am not at all expert at that.
13:22:17 <copumpkin> is it online?
13:22:42 <timthelion> Palmik: sorry, I wasn't so familiar with those paticular challenges...
13:23:18 <Palmik> timthelion, no problem, thanks for your time. :)
13:23:54 <scooty-puff> so i have a space leak, i have a .prof and .hp/.ps i used to narrow it down to a shortish function, and now have no clue what to do
13:23:55 <timthelion> Palmik: when I think challenge, I think obfuscated C...
13:24:05 <scooty-puff> i went ahead at added ! to every new named value, just for fun i guess
13:24:07 <timthelion> scooty-puff: hpaste
13:24:10 <Philippa> augur: ... do I want to know?
13:24:10 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
13:24:15 <niklasb_> timthelion: it's not a challenge to write obfuscated C :P
13:24:30 <niklasb_> it almost produces itself
13:24:34 <Philippa> aha
13:24:37 <Palmik> timthelion, that does not sound challenging at all (just joking, I know these exist :))
13:24:37 <acowley> copumpkin: https://gist.github.com/2362200
13:24:49 <scooty-puff> timthelion: theres a bit to go with it, but here it is
13:24:55 <acowley> copumpkin: at least my line lengths are under control :)
13:24:59 <augur> Philippa: can you point me towards something i can read that talks about constraint solving where the constrained values are things like trees, etc.?
13:25:07 <augur> Philippa: or just where the values are not numerica?
13:25:15 <timthelion> niklasb_: I don't know, I think I've written some pretty clear and obvious C code in my time.
13:25:19 <copumpkin> acowley: omg coq is so hardcore
13:25:26 <niklasb_> timthelion: of course ;) I think the same applies to me
13:25:27 <ion> Numerica? The new America?
13:25:30 <Philippa> augur: a lot of that stuff comes under things like unification and its relatives
13:25:44 <hpaste> scooty-puff pasted “Space leak” at http://hpaste.org/66834
13:25:45 <Philippa> Mostly I haven't trawled that directly
13:25:45 <niklasb_> timthelion: but i've also looked at some of the linux kernel's macros..
13:25:53 <scooty-puff> timthelion: i doubt there is enough there to help
13:26:06 <acowley> copumpkin: One thing that I've really come to like about Coq is the ability to do something like that match goal business I do in the lemma. Being able to refer to things syntactically -- "all that stuff over there" -- is nice.
13:26:13 <copumpkin> acowley: you should respond to my post with that link to show everyone how much better coq is :)
13:26:43 <acowley> To prove to the world that I can type "ring" with the best of them!
13:26:50 <dmwit> acowley: ring. ring. ring. ring. ring. BANANAPHONE
13:26:50 <copumpkin> :)
13:27:14 <acowley> (I actually did the algebra mostly manually before realizing just how good ring is)
13:27:17 <acowley> (I am ashamed)
13:27:19 <dmwit> Notation "BANANAPHONE" := Qed.
13:27:25 <acowley> Yes, this is bananaphone.
13:27:29 * copumpkin shakes his head at acowley 
13:27:30 <acowley> hahahaha
13:27:31 <copumpkin> acowley: I am disappoint
13:28:22 <acowley> dmwit: that is glorious. I really need to try to work that into a paper at some point.
13:29:03 <acowley> dmwit: I can get away with it because my audience doesn't care about the Coq stuff, so they'd just assume it was a French thing.
13:29:13 <dmwit> hehe
13:29:29 <timthelion> scooty-puff: Sorry, I don't think I'll get anywhere with that.  I can't even figure out the types...
13:29:49 <sclv> is a bananaphone like a jaundiced francophone then?
13:29:50 <elliott> @remember acowley <dmwit> Notation "BANANAPHONE" := Qed.  <acowley> dmwit: that is glorious. I really need to try to work that into a paper at some point.  <acowley> dmwit: I can get away with it because my audience doesn't care about the Coq stuff, so they'd just assume it was a French thing.
13:29:50 <lambdabot> I will remember.
13:30:02 <dmwit> I'd be surprised if that actually worked...
13:30:29 <parcs`> is `Eq a => a` isomorphic `(a -> Bool)`? i think it is, but i don't trust myself and don't know how to prove these things
13:30:39 <acowley> copumpkin: What happened is that I realized today that, when last I wrote something in Coq, I ended by quitting in anger. Your proof prompted me to begin the healing process with that relationship.
13:30:47 <copumpkin> :)
13:31:20 <acowley> sclv: that sounds like a reasonable explanation if somebody asks
13:31:37 <dmwit> parcs`: Eq a => a doesn't look inhabited, but (a -> Bool) looks inhabited.
13:31:42 <dmwit> parcs`: So I'd say they're not isomorphic.
13:31:48 <elliott> dmwit: fix (join (=+))
13:31:50 <elliott> argh
13:31:51 <elliott> dmwit: fix (join (==))
13:31:56 <elliott> oh wait
13:31:58 <dmwit> :t fix (join (==))
13:31:59 <lambdabot> Bool
13:31:59 <elliott> never mind
13:32:01 <dmwit> =)
13:32:06 <Veinor> > fix (join (==))
13:32:10 <lambdabot>   mueval-core: Time limit exceeded
13:32:19 <elliott> > fix (join ((==) :: () -> () -> Bool))
13:32:20 <lambdabot>   Couldn't match expected type `()'
13:32:20 <lambdabot>         against inferred type `GHC.Bool.B...
13:32:27 <elliott> huh?
13:32:31 <scooty-puff> timthelion: the project is here: https://github.com/sonyandy/glyph/blob/develop/src/Language/Glyph/HM/InferType.hs
13:32:33 <elliott> oh
13:32:35 <dmwit> parcs`: (e.g. "const True :: a -> Bool")
13:32:42 <byorgey> parcs`: also, there is no guarantee that a function (a -> Bool) corresponds to a valid (i.e. law-abiding) equality test against some chosen element.
13:32:43 <dmwit> elliott: It's (==) :: Bool -> Bool -> Bool
13:32:47 <elliott> right
13:32:51 <scooty-puff> if you care to look, but i am probably building too large a substitution
13:33:05 <byorgey> parcs`: wait, never mind, ignore me
13:33:22 <hpaste> Clint annotated “logic error” with “logic error (annotation)” at http://hpaste.org/66835#a66836
13:33:29 <Clint> anyone see what i'm doing wrong there?
13:35:36 <parcs`> dmwit: inhabited?
13:35:38 <dmwit> Clint: Eh, high calls go n 0 which immediately throws an error; that kind of logic error?
13:35:46 <dmwit> parcs`: There are no values of type Eq a => a.
13:35:53 <dmwit> parcs`: (Other than bottom, of course.)
13:36:03 <Clint> dmwit: no, i'm trying to reverse
13:36:03 <Clint> decodeIterationCount c = (16 + (fromIntegral c .&. 15)) `shiftL` ((fromIntegral c `shiftR` 4) + 6)
13:36:10 <dmwit> Clint: Eh, ignore me, I'm an idiot.
13:36:23 <Clint> but it doesn't work for numbers that aren't 65536
13:36:35 <copumpkin> you might be thinking of existential a values there :)
13:36:39 <copumpkin> parcs`/dmwit
13:36:46 <dmwit> Perhaps, yes.
13:36:54 <copumpkin> in which case they're almost equivalent
13:36:55 <byorgey> yeah, I was just going to say maybe parcs` means  (exists a. Eq a => a)
13:37:11 <parcs`> yeah, i think so
13:37:17 <parcs`> what if then
13:37:54 <acowley> Clint: what is that function supposed to do?
13:37:55 <dmwit> parcs`: Can you say exactly what (non-typeclass-polymorphic) type you mean?
13:37:55 <c_wraith> if you have that inside a container with only one value of that type, it buys you approximately nothing.
13:38:20 <zzing> I have a raytracer written in c++, and I want to convert some of it over. What would be a good linear algebra library for this?
13:38:44 <dmwit> (exists a. (a -> a -> Bool) -> a)?
13:39:20 <copumpkin> nope
13:39:34 <copumpkin> (exists a. ((a > a -> Bool), a))
13:39:44 <copumpkin> or technically two functions
13:39:48 <dented42> zzing: there's a Vec package that might have what you want?
13:39:49 <copumpkin> but they're supposed to determine each other
13:40:08 <elliott> zzing: you might be interested in vector/vector-algorithms or hmatrix
13:40:10 <Clint> acowley: encode a number into a Word8 (4 bits for exponent, 4 bits for "mantissa"), kind of like floating point
13:40:11 <parcs`> dmwit: no, because i'm not sure how to represent Eq a => a without the type class. is it (a, a -> a -> Bool, a -> a -> Bool), or can it be simplified to (a, a -> Bool, a -> Bool), or even just (a, a -> Bool) ?
13:40:17 <gspr> zzing: hmatrix is nice, imho
13:40:26 <Clint> or decode it, depending on which one you're talking about
13:40:34 <dmwit> copumpkin: That doesn't really look isomorphic to (exists a. a -> Bool), either, does it?
13:40:44 <acowley> hmatrix will do it, but it is more than you need and carries the GPL baggage
13:40:45 <copumpkin> sure it does
13:40:48 <copumpkin> sort of :)
13:40:49 <parcs`> er, (a -> Bool, a -> Bool) then (a -> Bool)
13:40:55 <copumpkin> if you assume the function is commutative/symmetric
13:41:27 <copumpkin> I guess it isn't iso
13:41:40 <copumpkin> it just gives you an injection in one direction
13:41:49 <dmwit> from (a :: *, f :: a -> Bool) = ?
13:42:51 <dmwit> parcs`: I don't think they're isomorphic.
13:43:25 <parcs`> this question was inspired by my comment that when given 'Eq a => a -> b', hoogle should also look for '(a -> Bool) -> b'
13:43:46 <parcs`> someone hoogled Eq a => a -> [a] -> ([a], [a]) and got nothing
13:43:49 <parcs`> yet
13:43:56 <parcs`> :t (partition, break, span)
13:43:57 <lambdabot> forall a a1 a2. ((a -> Bool) -> [a] -> ([a], [a]), (a1 -> Bool) -> [a1] -> ([a1], [a1]), (a2 -> Bool) -> [a2] -> ([a2], [a2]))
13:44:04 <parcs`> :t [partition, break, span]
13:44:05 <lambdabot> forall a. [(a -> Bool) -> [a] -> ([a], [a])]
13:44:38 <dmwit> Well, changing Eq a => a -> [a] -> ([a], [a]) into (a -> Bool) -> [a] -> ([a], [a]) is clearly wrong.
13:44:55 <parcs`> why?
13:45:04 <dmwit> How do you know it's going to apply (==) to the first argument and none of the arguments in the list, instead?
13:45:13 <dmwit> I mean, what's stopping our hypothetical function from doing
13:45:28 <dmwit> f a (a1:a2:as) = if a1 == a2 then blah else blah
13:45:41 <dmwit> ...which it wouldn't be able to do in the (a -> Bool) version.
13:45:47 <elliott> dmwit: not if you scope the => properly?
13:46:01 <parcs`> oh, i see
13:46:13 <elliott> i.e. ((Eq a) => a) -> [a] -> ([a], [a])
13:46:20 <elliott> admittedly haskell is bad at this
13:46:22 <dmwit> elliott: That type is also very different.
13:46:29 <zzing> I will look at hmatrix if it compiles :-)
13:46:30 <ksf> haddock should support jsmath or such.
13:46:41 <ksf> so that we all can be cromulently egg-heady.
13:46:42 <dmwit> elliott: Or I may have misunderstood what you meant by that.
13:47:05 <elliott> dmwit: well, how is ((Eq a) => a) on its own different from (a -> Bool)? (where a is *not* universally quantified)
13:47:24 <ksf> elliott, you can't redefine an instance.
13:47:35 <elliott> ksf: i am aware
13:47:36 <elliott> dmwit: oh, wait
13:47:40 <dmwit> elliott: (forall a. Eq a => a) is not inhabited, but (forall a. a -> Bool) is.
13:47:40 <elliott> dmwit: I mean (Eq a *> a)
13:47:44 <dmwit> elliott: So that's pretty different.
13:47:53 <dmwit> elliott: What is (*>) at the type level?
13:47:59 <elliott> ask ski :P
13:48:54 <dmwit> Oh, where a is not universally quantified?
13:49:00 <dmwit> You want it existentially quantified, then?
13:49:18 <elliott> No. I think what I want is not expressible in Haskell.
13:49:31 <dmwit> Then the difference is that not every (a -> Bool) function is the partial application of an equality function, so the other direction of type subsumption doesn't hold.
13:49:58 <elliott> Right, I'll grant that much.
13:50:14 <elliott> But ((Eq a) => a) doesn't give you any *more*.
13:51:41 <dmwit> I'd be interested in seeing a more careful characterization of what you (rhetorical you here) would want Hoogle to do with typeclass-polymorphic types.
13:53:35 <dmwit> Clint: Instead of logic, why not just build a lookup table? There's only 256 Word8's, after all.
13:53:36 <zzing> Apparently I need GSL
13:54:20 <zzing> Is there another linear algebra library that doesn't require a GPL library?
13:55:33 <acowley> dmwit: I didn't think his function was injective
13:56:02 <elliott> zzing: vector-algorithms has no C deps
13:56:09 <Clint> dmwit: i have no response
13:56:19 <elliott> zzing: repa may also interest you, raytracing-wise
13:56:26 <elliott> n-dimensional arrays with automatic parallelisation
13:57:34 <acowley> zzing: or do it in OpenCL and use my CLUtil package on github to make the application shell look functional while the meaty mutation happens behind closed doors!
13:59:33 <dmwit> acowley: If it's not, building a lookup table will tell exactly where it isn't injective. =)
14:00:12 <gspr> elliott: Incidentally, talking of Repa, do you know of a good source to follow news from that project? I find it very interesting, but I seldom have time really play around with the new versions released
14:00:42 <elliott> gspr: perhaps one of the mailing lists? dunno
14:00:50 <zzing> elliott: vector-algorithms seems to be vector in the sense of c++ vector
14:00:52 <gspr> elliott: Yeah probably a good idea
14:01:04 <dmwit> > scanl1 max []
14:01:05 <lambdabot>   []
14:01:09 <dmwit> ...
14:01:24 <dmwit> once again, a ten-line function is a one-liner once you figure out what the *#$@ you're doing
14:01:40 <dmwit> :t map head . group . scanl1 max
14:01:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:01:52 <elliott> zzing: I'm sure there was a vector-based library that did linalg stuff... but I don't remember it, sorry :(
14:02:08 <parcs`> vextor-space?
14:02:11 <parcs`> c
14:03:05 <timthelion> dmwit: tell me about it, I'm going through my code deleting lines right now.
14:04:35 <acowley> The vector-space package has nothing to do with the vector package.
14:04:48 <acowley> We ran out of names a long time ago.
14:06:40 <timthelion> acowley: we should start multilingualizing hackage if we've run out of names.  Then we can make the vektor(czech) package, different from the vector package, and then add a Вектор package as well.
14:07:10 <acowley> As I understand it, yesod is already a step in that direction.
14:07:11 <dmwit> The functions in AffineSpace are hilarious. Little smilies throughout your code.
14:07:19 <dmwit> P v1 .-. P v2 = v1 ^-^ v2
14:07:25 <dmwit> P v1 .+^ v2   = P (v1 ^+^ v2)
14:07:37 <c_wraith> why is that first operator so glum?
14:07:44 <Saizan> vectors are soo cheerful
14:07:55 <acowley> dmwit: … and now I can't not see the faces, you have changed the character of my code.
14:08:01 <elliott> ^-^
14:08:09 <elliott> .+^ is a weird face.
14:08:12 <acowley> .-. really is a sad operator
14:08:14 <Clint> dmwit: ok, the table works well enough, thanks
14:08:21 <acowley> we shouldn't sue it, it probably needs to rest
14:08:23 <timthelion> elliott: I think it's a cat with a black eye
14:08:27 <acowley> s/sue/use
14:08:28 <parcs`> we just need to allow duplicate package names and implement package-contents-name-resolution
14:08:38 <elliott> s/$/\// (fixed your regexp syntax)
14:08:45 <acowley> thank you
14:10:54 <mauke> elliott: vi doesn't require the third /
14:12:17 <elliott> mauke: sed does!
14:12:23 <elliott> That's the Standard EDitor.
14:13:03 <mauke> ed! ed! is the standard editor!
14:17:01 <mekeor> hehe
14:17:30 <c_wraith> ed is the Streaming EDitor
14:17:34 <c_wraith> err *sed is
14:17:52 <elliott> No.
14:17:54 <shachaf> "sed" is "super ed". I refuse to hear otherwise.
14:17:56 <elliott> It's definitely Standard.
14:18:01 <elliott> shachaf: Standards are super!
14:18:40 <ion> shachaf: Just like shit.
14:20:04 <companion_cube> and I thought it was Substitution Ed
14:20:14 <Clint> the s stands for mister
14:22:01 <dmwit> Clint++ for best joke in thread
14:23:52 <mekeor> Is there something like BlazeHtml for CSS ?
14:27:18 <mm_freak> mekeor: well, there is shakespeare-css, but i don't think it uses another abstraction, just blaze-builder
14:28:06 <mekeor> hmm
14:28:56 <mekeor> ah: language-css is fine
14:30:51 <mekeor> it does not use monads like blazeHtml but lists (which are monads, too, though).
14:31:48 <ksf> @slap mekeor
14:31:48 * lambdabot karate-chops mekeor into two equally sized halves
14:32:01 <ksf> lists *form* a monad under concatMap and singleton.
14:32:18 <mekeor> oh. i am sorry. :D
14:32:43 <mekeor> ksf: with singleton, you meant [], right?
14:32:48 <ksf> (:[])
14:32:54 <mekeor> ah, ok
14:32:54 <ksf> ie. return
14:32:59 <mekeor> ah, of course, yes.
14:33:00 <byorgey> <^(+)^>
14:33:00 <clintm> the monkey operator!
14:33:05 <clintm> ooo
14:33:10 <mekeor> ??
14:33:12 <dmwit> I wonder, how sloppy does your math have to be before #haskell will correct you?
14:33:21 <mekeor> @hoogle (<^(+)^>)
14:33:21 <lambdabot> Parse error:
14:33:21 <lambdabot>   (<^(+)^>)
14:33:21 <lambdabot>      ^
14:34:05 <mm_freak> mekeor: there are two operators
14:34:06 <geekosaur> looks mre like a bat to me
14:34:16 <mm_freak> (<^) and (^>)
14:34:28 <dmwit> > let v <^ f = liftM2 f v; f ^> v = f v in [5,6,7] <^(+)^> [10,20,30]
14:34:29 <lambdabot>   [15,25,35,16,26,36,17,27,37]
14:35:48 <dmwit> Haskell combos: v<^ performs a midair kick, ^>v performs a helicopter move.
14:36:35 <mekeor> dmwit: wow.
14:37:02 <byorgey> v<^ is hard because it doesn't work if you don't hold the < for exactly 0.2 seconds
14:37:50 * mokus never could get the hang of playing Haskell with a joystick... the SNES pad is so much easier to enter the combos with ;)
14:38:28 <c_wraith> pft.  Real players use joysticks.  (I have something of a collection going)
14:39:15 * ksf has one of those: http://www.tweak3d.net/reviews/gravis/xterm/images/2.jpg
14:39:27 <ksf> gameports are hard to come by nowadays, though.
14:39:49 <ksf> (not to mention that I somehow *never* got any gaming control working under linux)
14:40:18 <ksf> the analogue shoulder buttons are perfect for racing games.
14:40:26 <ksf> pinball games of course, too.
14:40:33 <ksf> mechwarrior is also a great fit.
14:40:59 <ksf> torso rotation, there.
14:42:31 <hiptobecubic> I love my logitech rumblepad 2
14:42:53 <hiptobecubic> best 13 dollars i've ever spent on ebay
14:44:20 <elliott> dmwit: unnecessarily restrictive
14:44:52 <elliott> > let (<^) = flip fmap; (^>) = (*>); test a b c = a+b+c in [5,6,7] <^test^> [10,20,30] ^> [1,2,3]
14:44:53 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
14:46:50 <Veinor> elliott: what is that computing?
14:47:24 <elliott> no bloody idea :P
14:47:34 <elliott> it's liftA3 test [5,6,7] [10,20,30] [1,2,3]
14:47:58 <mekeor> @type liftA3
14:47:59 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
14:48:12 <mekeor> so, liftA3 is like liftM3 ?
14:48:20 <copumpkin> yeah
14:48:23 <mekeor> ok
14:48:33 <elliott> liftA3 f x y z = f <$> x <*> y <*> z
14:49:56 <Veinor> elliott: no, it's liftA3 (\x y z -> z)
14:50:20 <elliott> oh the precedence must be broken
14:50:30 <elliott> > let (<^) = flip fmap; (^>) = (*>); test a b c = a+b+c in ([5,6,7] <^test^> [10,20,30]) ^> [1,2,3]
14:50:31 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
14:50:34 <elliott> nope
14:50:38 <mokus> you just have a typo
14:50:42 <elliott> oh!
14:50:44 <byorgey> elliott: you don't want (*>)
14:50:48 <mokus> (*>) should be (<*>)
14:50:50 <elliott> > let (<^) = flip fmap; (^>) = (<*>); test a b c = a+b+c in [5,6,7] <^test^> [10,20,30] ^> [1,2,3]
14:50:51 <lambdabot>   [16,17,18,26,27,28,36,37,38,17,18,19,27,28,29,37,38,39,18,19,20,28,29,30,38...
14:50:53 <elliott> there we go
14:50:58 <elliott> isn't it beautiful :D
14:51:27 <c_wraith> I like the extra wing
14:55:42 <gdoteof> can someone help me thinking about how to do something functionally/haskelly?  I have a list say, a = [1,3,5,7,9], and another b=[0,0,0,0,0,0,0,0,0,0] i want to sort of zip the lists together and end up with [0,1,0,3,0,5,0,7,0,9,0]
14:55:58 <elliott> > zip [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0]
14:55:59 <copumpkin> :t interleave
14:55:59 <lambdabot>   [(1,0),(3,0),(5,0),(7,0),(9,0)]
14:56:00 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
14:56:07 <elliott> interleave isn't standard
14:56:11 <copumpkin> hrrmpf
14:56:20 <elliott> > zip [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0]
14:56:21 <lambdabot>   [(1,0),(3,0),(5,0),(7,0),(9,0)]
14:56:30 <copumpkin> > concat . transpose $ [[1,3,5,7,9], [0,0,0,0,0,0,0,0,0,0]]
14:56:31 <lambdabot>   [1,0,3,0,5,0,7,0,9,0,0,0,0,0,0]
14:56:46 <elliott> gdoteof: actually zipWith is likely to be more helpful here
14:56:46 <copumpkin> too many zeroes?
14:56:54 <gdoteof> too many zeroes yes
14:56:57 <elliott> > zipWith (\x y -> x+y) [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0]
14:56:58 <lambdabot>   [1,3,5,7,9]
14:57:01 <elliott> > zipWith (\x y -> [x,y]) [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0]
14:57:02 <lambdabot>   [[1,0],[3,0],[5,0],[7,0],[9,0]]
14:57:13 <elliott> that's the right list, it just has nesting you don't care about
14:57:19 <elliott> how do you think you can get rid of it? :)
14:57:26 <shachaf> > concat . takeWhile (not . null . drop 1) . transpose $ [[1,3,5,7,9], [0,0,0,0,0,0,0,0,0,0]]
14:57:28 <lambdabot>   [1,0,3,0,5,0,7,0,9,0]
14:57:32 <scooty-puff> is there a tool that can find all the uses of a data constructor in haskell code?
14:57:41 <scooty-puff> i have the result of +RTS -hd, but a major thing is (,)
14:58:11 <gdoteof> oh man.  i have been thinking about this for hours and you guys bust out multiple solutions like nothing
14:58:34 <shachaf> > (\xs -> concat . takeWhile (not . null . drop (length xs - 1)) . transpose $ xs) [[1,3,5,7,9], [0,0,0,0,0,0,0,0,0,0]]
14:58:36 <lambdabot>   [1,0,3,0,5,0,7,0,9,0]
14:58:36 <scooty-puff> hmm, actually maybe its from Lazy.State
14:59:00 <elliott> gdoteof: I was trying to lead you to a solution but shachaf went and ruined it ;)
14:59:09 <elliott> That isn't the solution I was trying to laed you towards, though (and it's not as nice).
14:59:11 <shachaf> copumpkin started it!
14:59:16 <shachaf> Sorry elliott. Selliott.
14:59:26 <elliott> Yeah, but copumpkin is too incompetent to succeed at it!
14:59:34 <shachaf> elliott: This solution scales to an arbitrary number of lists!
14:59:50 <shachaf> (While losing some type-safety, maybe.)
15:00:34 <elliott> Let's try this again :P
15:00:48 <elliott> gdoteof: zipWith takes two lists, and a function to combine an element from both lists.
15:00:49 <elliott> :t zipWith
15:00:49 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:00:57 <elliott> So we can do
15:00:58 <elliott> > zipWith (\x y -> [x,y]) [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0]
15:00:59 <lambdabot>   [[1,0],[3,0],[5,0],[7,0],[9,0]]
15:00:59 <gdoteof> elliott: i am with you on zipwith
15:01:13 <elliott> to get a list of pairs-as-lists.
15:01:32 <elliott> We want to go from that, which is, say, [[Integer]], to [1,0,3,0,5,0,7,0,9,0], which would be [Integer].
15:01:37 <elliott> @hoogle [[a]] -> [a]
15:01:37 <lambdabot> Prelude concat :: [[a]] -> [a]
15:01:37 <lambdabot> Data.List concat :: [[a]] -> [a]
15:01:37 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:01:46 <gdoteof> concat
15:01:46 <elliott> > concat (zipWith (\x y -> [x,y]) [1,3,5,7,9] [0,0,0,0,0,0,0,0,0,0])
15:01:47 <gdoteof> nice
15:01:47 <lambdabot>   [1,0,3,0,5,0,7,0,9,0]
15:02:06 <elliott> So: interleave xs ys = concat (zipWith pair xs ys) where pair x y = [x, y]
15:02:38 <gdoteof> i feel like i just cheated.  thanks a lot
15:02:48 <gdoteof> i wonder if one something will click in my brain
15:03:05 <gdoteof> more likely a slow trickle i guess
15:04:32 * gdoteof wonders if people are thinking 'actually he'll proabbly never get it' 
15:04:32 <gdoteof> :)
15:05:24 <elliott> naw
15:05:26 <shachaf> Man, when I started learning Haskell I already knew all of Haskell.
15:05:34 <mokus> > zip [1,3,5,7,9] (repeat 0) >>= (return . fst) `mappend` (return . snd) -- my silly overengineered version :)
15:05:34 <elliott> gdoteof: a large part of it is just knowing the standard library functions
15:05:34 <shachaf> I can't believe gdoteof doesn't.
15:05:35 <lambdabot>   [1,0,3,0,5,0,7,0,9,0]
15:05:42 <gdoteof> shachaf: thats what i was going for
15:05:44 <hpc> heh
15:05:49 <elliott> gdoteof: to do that without knowing about zipWith would require a pretty ugly manual recursion
15:05:51 <Clint> i understand less and less every day
15:06:04 <elliott> (even with zip you'd need to use an ugly foldr to deal with the fact that it returns a list of tuples)
15:06:05 <mokus> hey, i just did it without zipWith :)
15:06:05 <hpc> i actually did, funny enough
15:06:11 <mokus> or fold
15:06:16 <elliott> mokus: pah, you did it with zipWith (,)
15:06:21 <mokus> true
15:06:24 <hpc> because it took like 4 reads of lyah for me to be able to write code
15:07:39 <gdoteof> i wonder why everyone in #haskell is so nice.  i always feel like getting berated is the price you pay for getting help on irc
15:07:47 <gdoteof> im not sure what the hidden cost is here
15:07:57 <hpc> gdoteof: haskell is extremely deep
15:07:58 <shachaf> gdoteof: The trick is we're actually teaching you COBOL.
15:08:03 <shachaf> It's a cruel prank.
15:08:12 <hpc> so everyone is still a newbie at something
15:08:13 <c_wraith> shachaf: damn it, that's a much better punchline than I had.
15:08:34 <gdoteof> lol
15:08:39 <hpc> so we know how it feels to not know something
15:11:55 <acowley> Haskell is indeed deep. We want to reduce code size so much that now code itself is a design smell.
15:12:31 <mokus> and whenever your code grows over 100 lines you're expected to invent a new field of math to shorten it ;)
15:13:01 <acowley> I've hacked my haskell-mode in emacs to not even allow for editing beyond 100 lines.
15:13:01 <scooty-puff> is there anyway, if while profiling with +RTS -hd, you get a lot of <module name>.sat_<...> stuff, to find out where it came from?
15:13:09 <scooty-puff> like maybe to have line numbers included, etc.?
15:13:44 <elliott> acowley: 100 *lines*?
15:13:48 <elliott> I don't go over 100 bytes.
15:13:49 <acowley> That may have been a slight exageration.
15:13:52 <elliott> That's mostly because I'm lazy though.
15:13:53 <acowley> haha
15:14:23 <mokus> the highest virtue of a Haskell programmer, of course!
15:14:28 <acowley> Good haskell code is 20 LANGUAGE pragmas, 40 imports, then one line of perl.
15:14:34 <mokus> sounds about right
15:15:04 <scooty-puff> also, would it help much to define an ErrorT that uses a strict Either?
15:15:11 <ion> @remember acowley Good haskell code is 20 LANGUAGE pragmas, 40 imports, then one line of perl.
15:15:11 <lambdabot> Nice!
15:15:25 <hpc> the best haskell code is 30 modules with nothing but class definitions
15:15:37 <hpc> and possibly an Arrow instance
15:16:27 <mokus> just as long as all the classes aren't called "C"... I never did care for that style
15:16:48 <Saizan> scooty-puff: i don't know, but those are usually instance dictionaries iirc
15:16:57 <elliott> mokus: Only one person cares for that sttyle.
15:16:58 <elliott> *t
15:17:11 <mokus> oh, ok - glad I'm not the only one that doesn't :)
15:17:42 <elliott> It's the easiest way to detect a Henning Thielemann library :p
15:19:24 <scooty-puff> yay, my heap profile looks like a black triangle on its side, thats good, right?
15:19:31 <scooty-puff> (it dies with an oom)
15:20:24 <Saizan> ..not quite
15:21:02 <scooty-puff> so return $ <...> is comparable to return (unBox (Box <...>)), return $! <...> is compareable to return (<...>), right?
15:21:14 <scooty-puff> (ok, so thats definitely not quite right..)
15:21:28 <elliott> no, return $ x is return x
15:21:32 <elliott> return $! x is x `seq` return x
15:21:40 <hpc> @src ($)
15:21:40 <lambdabot> f $ x = f x
15:21:48 <hpc> @src ($!)
15:21:48 <lambdabot> f $! x = x `seq` f x
15:22:44 <scooty-puff> so whenever some says return $ <...> is wrong, they really mean relative to $!, not (...)
15:23:03 * hackagebot yesod-markdown 0.4.0 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.4.0 (PatrickBrisbin)
15:23:05 * hackagebot yesod-paginator 0.2.2.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.2.2.1 (PatrickBrisbin)
15:25:07 <mcstar> i try to coerce a Word64 into an Int with fromIntegral, but it doesnt typecheck
15:25:54 <hpc> > fromIntegral (0 :: Word64) :: Int
15:25:56 <lambdabot>   0
15:26:26 <elliott> (Not "coerce", "convert".)
15:27:56 <ion> λ> unsafeCoerce (0 :: Word64) :: Int
15:27:58 <ion> 0
15:28:07 <mcstar> its working in ghci for me too
15:28:18 <mcstar> > (fromIntegral (maxBound :: Word64)) :: Int
15:28:19 <lambdabot>   -1
15:28:57 <mcstar> http://sprunge.us/hNMQ
15:30:06 <mcstar> any clues?
15:30:39 <mcstar> ion: where is unsafecoerce?
15:30:39 <hpc> it's not related to converting between word64 and int
15:30:51 <hpc> mcstar: dont use unsafeCoerce
15:30:56 <mcstar> ok, just asking
15:30:58 <ion> mcstar: sudo forget it exists.
15:31:07 <mekeor> lol
15:31:23 <mcstar> Sorry, try again.
15:31:31 <hpc> [sudo] password forion:
15:31:33 <mcstar> sudo: 3 incorrect password attempts
15:31:35 <Saizan> mcstar: you should show more of the code
15:31:40 <sipa> hunter2
15:31:47 <ion> mcstar: Defaults insults
15:31:57 <mekeor> @hoogle unsafeCoerce -- haha :Þ
15:31:58 <lambdabot> Parse error:
15:31:58 <lambdabot>   unsafeCoerce -- haha :
15:32:02 <deggis> i guess it's the go function that just returns Int's, not Word64's
15:32:04 <ion> haha indeed
15:32:08 <mekeor> nah
15:32:20 <luite> can anyone running a recent GHC STABLE snapshot or HEAD try to build shakespeare-css?
15:32:53 <mekeor> ion: i did that deliberately ;)
15:32:55 <zzing> For the regular user of ghc, is there a reason to run 7 over 6?
15:32:58 <elliott> We should hide unsafeCoerce somewhere where nobody will look for it, like GHC.IO.Encoding.CodePage.Table or something
15:33:05 <ion> mekeor: heh, ok
15:33:08 <hpc> zzing: definitely
15:33:22 <zzing> hpc, what might those be?
15:33:23 <mekeor> ion: not really, actually… howbeit.
15:33:25 <hpc> zzing: new versions of base and other packages
15:33:35 <hpc> and new extensions
15:33:37 <deggis> oh. running GHC HEAD. must try that next week if coffee just someday isn't enough
15:33:51 <trygub> Hi everyone! When reading Haskell compilation errors I often wonder what symbols in braces in type descriptions mean (e.g. {tc ro} ) ... Perhaps someone explain this to me? I am using ghci ...
15:33:59 <hpc> even 6.12.1 is ancient now
15:34:09 <hpc> what with 7.4.1 being out
15:34:23 <ion> zzing: …is there a reason to run 6 over 7?
15:34:26 <elliott> @remember deggis oh. running GHC HEAD. must try that next week if coffee just someday isn't enough
15:34:26 <lambdabot> I will never forget.
15:34:35 <elliott> reasons to run ghc 6 over 7: that old-time feeling
15:34:54 <zzing> ion, my teacher had 6.12 installed so it is a question of replacing it :P
15:37:50 <thoughtpolice> preflex: zdec
15:37:55 <thoughtpolice> preflex: zdec _ZNSsC1EPKcmRKSaIcE
15:37:56 <preflex>  _]SsC1EPKcmRKSaIcE
15:38:22 <ion> That was useful.
15:38:32 <thoughtpolice> indeed
15:41:09 <mcstar> after writing out explicitely the signature of 'go' now the error show up where i used fromIntegral
15:42:09 <mcstar> lol
15:42:12 <mcstar> wait
15:43:05 <mcstar> damn
15:43:24 <mcstar> i used fromIntegral where i inserted a Word64 into an Int hashtable
15:43:33 <mcstar> but didnt, when i tried to look that key up
15:43:38 <mcstar> thanks guys
15:44:25 <deggis> asking helps always :) i've solved few things after typing the question to this channel and before hitting enter
15:46:32 <mcstar> Codec.Digest.SHA is faster than Codec.Digest.Pure.SHA
15:46:37 <mcstar> since it is in C
15:46:51 <mcstar> but i dont see any optimization flags in the .cabal file
15:47:14 <mcstar> should i just download the package and change it and install it?
15:47:23 <dcoutts> mcstar: you can cabal install -O2
15:47:44 <mcstar> so dont have to change the config file? thats nice
15:48:01 <mcstar> im sawpping
15:49:56 <mcstar> damn, it consumed 5.5G memory
15:50:22 <mcstar> 16070000 elements in the hashtable
15:50:43 <mcstar> and x32 bytes of associated bystrings
15:50:54 <mcstar> bytestrings*
15:53:05 <mcstar> thats <800M raw memory
15:53:18 <mcstar> i wonder whats the problem, maybe laziness?
15:53:37 <mcstar> i mean bytestrings doesnt have boxing issues, do they?
15:53:42 <mcstar> dont*
15:53:46 <c_wraith> they do
15:54:11 <mcstar> it still seems a bit too much allocation for me
15:54:11 <c_wraith> furthermore, if you're slicing bytestrings to put tiny keys into the structure, they hold on to their entire source
15:54:36 <mcstar> BS.pack (take n list)
15:54:57 <mcstar> n is 32
15:54:57 <c_wraith> well, that should allocate a fresh structure, anyway.
15:55:25 <elliott> dcoutts: huh, cabal-install takes -O itself?
15:55:40 <dcoutts> yep, -O, -O0, -O2
15:55:54 <elliott> dcoutts: btw, thanks for keeping cabal-install working with hugs! even if it was accidental
15:56:02 <dcoutts> -O0 is particularly handy for dev builds
15:56:03 <elliott> (even if it's weirdly half-broken :( )
15:56:19 <dcoutts> elliott: I did try, but I can't run hugs anymore so it may bitrot
15:56:38 <dcoutts> elliott: patches accepted though
15:56:55 <elliott> it works, i just have to copy files from ~/.cabal/lib/hugs to my global hugs installation dir
15:57:13 <elliott> because otherwise cabal doesn't recognise they're installed, even if I pass --hugs-option="..." with a hugs path option including the ~/.cabal dir
15:57:28 <acowley> Out of curiosity, why are you using hugs?
16:00:57 <elliott> acowley: Er... well...
16:01:04 <elliott> acowley: To prove that I could.
16:02:31 <acowley> elliot: carry on
16:02:47 <mcstar> http://sprunge.us/SaIe here is the code, i cant make this faster
16:03:23 <mcstar> but the space leak prevents me from reaching a sizeable hashtable, and solve the problem
16:03:38 <mcstar> the speed is roughly half of c++, not bad
16:04:57 <mcstar> i know i dont need that :: [Word8] there
16:06:39 <elliott> acowley: Specifically to prove that some (really evil) code would work on Hugs.
16:06:44 <elliott> It did. I wasn't expecting it to.
16:08:48 <zzing> I just did a cabal init on a new project, and using ghc installed from a pkg (mac64), I just built my new project and it said at the end: ld: warning: directory not found for option '-L/opt/local/lib/'
16:08:58 <zzing> I am wondering where that might be specified
16:13:30 <mcstar> %GC     time      62.9%  (63.0% elapsed)
16:13:59 <mcstar> i dont get it, gc is working, yet i run out of ram
16:16:02 <Saizan> mcstar: that usually means you're retaining stuff, try HT.insert ht (fromIntegral tr) $! input
16:16:34 <Saizan> (also, i don't think Data.HashTable has been optimized much recently)
16:16:37 <mcstar> Saizan: with -A500M -H500M i get reversed percentages, gc time drops to 30%
16:16:53 <elliott> don't use Data.HashTable
16:16:53 <mcstar> it is as fast as c++'s from my simle becnhamrk
16:17:01 <elliott> if you want a mutable hash table (do you really?), try http://hackage.haskell.org/package/hashtables
16:17:23 <mcstar> i dont need it for the speed
16:17:25 <mcstar> its ok
16:17:32 <mcstar> the problem is the space leak now
16:17:43 <elliott> it also takes up less space ;)
16:19:01 <mcstar> Saizan: it helped a little bit
16:19:49 <acowley> zzing: I think I've seen that, too, but never tracked it down
16:20:51 <zzing> I suppose I can just create te directory and not worry about it
16:21:05 <zzing> I did used to have one of the package managers there
16:21:24 <Saizan> mcstar: i guess you should do some heap profiling to tell what is consuming memory here
16:22:08 <acowley> zzing: I just ignored it as it's only a warning
16:22:30 <zzing> acowley: warnings are annoying and I treat them as errors when they appear, throwback from previous expeirence
16:23:10 <Saizan> mcstar: or, what happens if you replace randoms gen with return (cycle [1..]) ?
16:23:20 <acowley> zzing: I agree with that approach up to a point, this case was beyond that point for me :)
16:23:43 <zzing> hence, I get rid of it some how :P
16:27:31 <djahandarie> Can anyone think of idomatic/fast/golfed way to do  f 6 9 [0,2,3,7,8] == [0,7,8]  ? f takes a 'start', a 'max' and a list 'xs', then if (start+1)%total is in xs, put that in the output and then see if (start+2)%t is in xs, if it is the put that in the output, and continue until you hit something that is not in xs.
16:28:44 <djahandarie> Naive solution is O(n^2)
16:29:05 <mcstar> Saizan: im tired, i left out the sha256 hashing step even
16:29:10 <djahandarie> I imagine you should be able to get O(n lg n) with lists but I don't yet see how without being really ugly
16:29:52 <djahandarie> Err s/total/max/ in my description there
16:29:54 <Saizan> djahandarie: max is just additional information?
16:29:58 <mcstar> i cant replace it with cycle, the alg. would break down
16:30:21 <djahandarie> Saizan, the addition is modulus max
16:30:36 <djahandarie> That's why 0 shows up in the example output
16:30:38 <elliott> you said t :)
16:30:43 <djahandarie> Yeah, mistake
16:32:23 <djahandarie> If it wasn't for the modulus it'd be O(n) easily
16:32:40 <djahandarie> Hmm, could just replicate the list
16:33:05 * hackagebot semigroups 0.8.3 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8.3 (EdwardKmett)
16:33:21 <aavogt> is n <= max?
16:34:01 <djahandarie> Yeah. The list is unique and its values are bounded by max
16:38:09 <mcstar> 45,803,530,504 bytes allocated in the heap
16:38:16 <mcstar> 5580 MB total memory in use
16:41:02 <mcstar> for the same problem size c++ uses 1GB
16:41:08 <Orclev_> with reactive banana, is there a function like: applyE :: Event (a -> b) -> Event a -> Event b
16:42:50 <elliott> Orclev_: if you want that, you probably want to be using behaviours!
16:43:05 * hackagebot tagged 0.4.2 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.4.2 (EdwardKmett)
16:43:05 <elliott> which have an applicative instance, and thus (<*>) :: Behavior t (a -> b) -> Behavior t a -> Behavior t b
16:43:07 * hackagebot reflection 1.1.5 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.5 (EdwardKmett)
16:43:55 <Mathnerd314> > (\start max xs -> map (\x -> (x + start + 1) `mod` max). catMaybes . zipWith (\x y -> guard (x == y) >> return x) [0..] . sort $ map (\x -> (x - start-1) `mod` max) xs) 6 9 [0,2,3,7,8]
16:43:57 <lambdabot>   [7,8,0]
16:44:49 <djahandarie> > (\start max xs -> map (\x -> (x + start + 1) `mod` max). catMaybes . zipWith (\x y -> guard (x == y) >> return x) [0..] . sort $ map (\x -> (x - start-1) `mod` max) xs) 6 9 [0,1,2,3,7,8]
16:44:51 <lambdabot>   [7,8,0,1,2,3]
16:45:03 <djahandarie> > (\start max xs -> map (\x -> (x + start + 1) `mod` max). catMaybes . zipWith (\x y -> guard (x == y) >> return x) [0..] . sort $ map (\x -> (x - start-1) `mod` max) xs) 6 9 [0,1,2,3,4,5,6,7,8]
16:45:04 <lambdabot>   [7,8,0,1,2,3,4,5,6]
16:45:23 <Orclev_> elliott: I've got two event streams, we'll call them Event A and Event B, and I need Event (A,B), but I can't figure out how to do that
16:46:44 <djahandarie> Interesting way of doing it
16:46:58 <Mathnerd314> :t dropWhile
16:46:59 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:47:39 <elliott> Orclev_: right, the problem is that that's kind of ugly -- you can do it, but wanting something like that is an indication you want to be using Behaviors
16:47:45 <elliott> (and if you do, liftA2 (,) will do it)
16:49:36 <Orclev_> elliott: I guess I'm still stuggling to grasp how you're supposed to use Behaviors, when I asked on stack overflow I was told not to use changes, but I want to react to changes in the behavior values and I'm not really seeing how to do that
16:49:41 <djahandarie> > let f start max = (\(_,x,_) -> x) . foldl (\(current, out, len) x -> if len < 9 && x == ((current+1) `mod` 9) then (current+1, x:out, len+1) else (current, out, len)) (6, [], 0) . concat . replicate 2 . sort in f 6 9 [0,1,2,3,4,5,6,7,8]
16:49:43 <lambdabot>   [6,5,4,3,2,1,0,8,7]
16:49:49 <djahandarie> My ugly solution
16:50:17 <elliott> Orclev_: It's OK to do that -- at the top level.
16:50:23 <elliott> changes is for communicating with the outside world.
16:51:09 <djahandarie> Oops forgot to unhardcore 9
16:51:11 <elliott> Orclev_: The idea is that you structure your code with whichever types make sense, without worrying about how you'll bind them to the outside world, and then use reactimate/initial/changes/etc. to bind it to whatever external IO you're doing.
16:51:12 <djahandarie> code*
16:51:18 <Orclev_> elliott: ok, in that case I think I'm closer to figuring this out than I thought I was, I was trying to avoid changes in the same way I avoid unsafePerformIO
16:51:36 <elliott> Orclev_: (Originally there were two types, Behavior and Discrete, where the latter let you observe changes and the former didn't, but I pushed to get them unified ;) )
16:51:42 <elliott> Orclev_: Right, you'll have to use changes.
16:51:47 <elliott> It's just not something you need to solve "pure FRP" problems.
16:52:59 <djahandarie> > let f start max = (\(_,x,_) -> x) . foldl' (\s@(current, out, len) x -> if len < max && x == ((current+1) `mod` max) then (current+1, x:out, len+1) else s) (6, [], 0) . concat . replicate 2 . sort in f 6 9 [0,2,3,7,8]
16:53:00 <lambdabot>   [0,8,7]
16:54:27 <djahandarie> > let f start max = fst . foldl' (\s@(out, (current, len)) x -> if len < max && x == ((current+1) `mod` max) then (current+1, (x:out, len+1)) else s) (start, [], 0) . concat . replicate 2 . sort in f 6 9 [0,2,3,7,8]
16:54:28 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
16:54:31 <Orclev_> so something like this is ok? changes someUpdateBehavior >>= reactimate
16:54:43 <acowley> > let f start max xs = takeWhile (`elem` xs) $ map (`mod` max) [start+1..] in f 6 9 [0,2,3,7,8]
16:54:43 <lambdabot>   [7,8,0]
16:54:56 <djahandarie> > let f start max = fst . foldl' (\s@(out, (current, len)) x -> if len < max && x == ((current+1) `mod` max) then (x:out, (current+1, len+1)) else s) (start, [], 0) . concat . replicate 2 . sort in f 6 9 [0,2,3,7,8]
16:54:57 <lambdabot>   Couldn't match expected type `([b], (b, b))'
16:54:58 <lambdabot>         against inferred type ...
16:55:14 <byorgey> oooh, what are we golfing?
16:55:21 <djahandarie> > let f start max = fst . foldl' (\s@(out, (current, len)) x -> if len < max && x == ((current+1) `mod` max) then (x:out, (current+1, len+1)) else s) (start, ([], 0)) . concat . replicate 2 . sort in f 6 9 [0,2,3,7,8]
16:55:22 <lambdabot>   No instances for (GHC.Real.Integral [a], GHC.Num.Num [[a]])
16:55:22 <lambdabot>    arising from...
16:55:28 <elliott> <djahandarie> Can anyone think of idomatic/fast/golfed way to do  f 6 9 [0,2,3,7,8] == [0,7,8]  ? f takes a 'start', a 'max' and a list 'xs', then if (start+1)%total is in xs, put that in the output and then see if (start+2)%t is in xs, if it is the put that in the output, and continue until you hit something that is not in xs.
16:55:29 <elliott> except s/t/max/
16:55:36 <djahandarie> > let f start max = fst . foldl' (\s@(out, (current, len)) x -> if len < max && x == ((current+1) `mod` max) then (x:out, (current+1, len+1)) else s) ([], (start, 0)) . concat . replicate 2 . sort in f 6 9 [0,2,3,7,8]
16:55:36 <elliott> I think it's optimgolfing.
16:55:37 <lambdabot>   [0,8,7]
16:55:39 <acowley> also, s/total/max/
16:55:49 <djahandarie> acowley, isn't that n^2 due to the elem?
16:55:58 <acowley> djahandarie: yes
16:56:13 <acowley> djahandarie: but it satisfies idiomatic and (relatively) golfed
16:56:31 <acowley> djahandarie: you could use a set instead
16:57:05 <djahandarie> My challenge was to do it in n lg n with lists :P. But I guess that's not really that fun anyways since you're just using sort
16:57:51 <djahandarie> Hmm, how about this, given an ascending list, do it in O(n). That way Set is still too slow!
16:57:54 <acowley> It seems perverse to aim for logarithmic complexity with lists when other structures get you there more directly :/
16:58:42 <Mathnerd314> djahandarie: then your solution probably works
16:59:21 <djahandarie> Yours does too :P
17:01:01 <djahandarie> I just really hate that I have to accum the length for it not to behavior improperly when the list is "full"
17:01:15 <djahandarie> Yours gets around that
17:01:32 <Mathnerd314> > let f start max = fst . foldl' (\s@(out, len) x -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0)) . concat . replicate 2 in f 6 9 [0,2,3,7,8]
17:01:33 <lambdabot>   <no location info>: parse error on input `)'
17:02:03 <Mathnerd314> > let f start max = fst . foldl' (\s@(out, len) x -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0) . concat . replicate 2 in f 6 9 [0,2,3,7,8]
17:02:05 <lambdabot>   [0,8,7]
17:02:05 <djahandarie> Oh, hah, right.
17:02:10 <sizz> I'm getting errors with this program.. please can someone talk me through the interpreting the error messages?
17:02:15 <hpaste> sizz pasted “from 'Programming in Haskell'” at http://hpaste.org/66841
17:03:13 <sizz> I changed line 23 compared with the book: there doesn't seem to be fromInt anymore, so I'm using fromInteger instead..
17:03:55 <Mathnerd314> > let f start max = fst . foldr (\s@(out, len) x -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0) . cycle in f 6 9 [0,2,3,7,8]
17:03:56 <lambdabot>   Occurs check: cannot construct the infinite type: b = ([b], b)
17:04:14 <Mathnerd314> :t replicate
17:04:15 <lambdabot> forall a. Int -> a -> [a]
17:04:25 <Mathnerd314> :t cycle
17:04:26 <lambdabot> forall a. [a] -> [a]
17:04:57 <Mathnerd314> > let f start max = fst . foldl' (\s@(out, len) x -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0) . cycle in f 6 9 [0,2,3,7,8]
17:05:01 <lambdabot>   mueval-core: Time limit exceeded
17:05:09 <djahandarie> You forgot to switch the params on the foldr
17:05:16 <Mathnerd314> > let f start max = fst . flip foldr (\s@(out, len) x -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0) . cycle in f 6 9 [0,2,3,7,8]
17:05:17 <lambdabot>   The lambda expression `\ (s@(out, len)) x -> ...'
17:05:17 <lambdabot>  has two arguments,
17:05:17 <lambdabot>  but ...
17:05:40 <Mathnerd314> > let f start max = fst . foldr (\x s@(out, len) -> if len <= start && x == ((len+start+1) `mod` max) then (x:out, len+1) else s) ([], 0) . cycle in f 6 9 [0,2,3,7,8]
17:05:42 <lambdabot>   *Exception: stack overflow
17:05:46 <djahandarie> Hah
17:06:45 <zzing> If I have a number n that I must test if it is <0 for one result and >=0 for another, what is the best construct I should use?
17:08:41 <monochrom> if-then-else
17:09:53 <zzing> Can I describe a datatype by typeclass instead of making an absolute data  ... =  a | b  kind of thing?
17:10:17 <monochrom> not sure what that means
17:10:21 <zzing> I want to have a list that contain a shape, but don't want a huge list of types one place
17:10:52 <monochrom> the answer is probably no
17:10:57 <zzing> unfortunate
17:11:00 <Mathnerd314> [forall a. (Shape a) => a]
17:11:34 <mauke> @google existential antipattern
17:11:36 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:11:36 <lambdabot> Title: Haskell Antipattern: Existential Typeclass « Luke Palmer
17:12:09 <monochrom> yeah, that page is relevant
17:13:23 <elliott> @where FAQ
17:13:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:13:35 <elliott> zzing: see also http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
17:13:39 <BMeph> sizz: "fromIntegral" works, for Ints and Integers. :)
17:14:09 <sizz> BMeph: thanks, that did the trick!
17:14:18 * BMeph salutes
17:14:58 <zzing> thank you
17:15:16 <sizz> as soon as I get my caesar cipher working, I should be able to get a job with Sony ;)
17:15:30 <sizz> in their security division
17:17:22 <c_wraith> sizz: not sure.  that might overqualify you
17:17:22 <monochrom> ha ha ha
17:17:30 <Mathnerd314> so it'd just be [Shape]
17:17:39 <zzing> sizz: I think my Quantum Instant Factorizator and Prime Generator will blow that away
17:18:30 <c_wraith> I can factor any prime number fast.
17:18:36 <sizz> we'll see .. I'm writing the cover letter as we speak
17:18:41 <zzing> c_wraith: I can do it faster than you!
17:18:46 <c_wraith> However, my algorithm might return bad results if the input is not prime.
17:19:41 <monochrom> I can do it faster than zzing. however, the answer is always wrong
17:19:44 <zzing> I am finding some haskell things easier now that I have done some more work with c++ and templates
17:19:56 <Mathnerd314> > let c_wraith_factor_algorithm = id in map c_wraith_factor_algorithm [2,3,5,7]
17:19:57 <lambdabot>   [2,3,5,7]
17:20:10 <Mathnerd314> > let c_wraith_factor_algorithm = return in map c_wraith_factor_algorithm [2,3,5,7]
17:20:11 <c_wraith> no, my algorithm isn't id
17:20:11 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:20:11 <lambdabot>    arising from a use of `M3395012271...
17:20:14 <c_wraith> it's robot monkey
17:20:44 <c_wraith> :t (:[])
17:20:45 <lambdabot> forall a. a -> [a]
17:20:56 <monochrom> yeah, id does not even have the right type :)
17:22:39 <NemesisD> hi all. im getting this error: ghc-7.4.1 requires containers == 0.4.0.0 however containers-0.4.0.0 was excluded because ghc-7.4.1 requires containers == 0.4.2.1
17:22:49 <NemesisD> this is highly confusing, what should i do
17:23:51 <elliott> NemesisD: er, whoa.
17:23:53 <elliott> ghc-pkg check
17:24:03 <elliott> you probably have broken packages
17:25:35 <c_wraith> NemesisD: sounds like something installed containers... which is bad.
17:25:36 <NemesisD> how do packages get "broken"
17:25:52 <zzing> When we do ghc-pkg check, when it talks about include-dirs  where is this configured?
17:25:58 <NemesisD> why is that bad. my library requires it in the cabal file because it uses it
17:26:18 <c_wraith> NemesisD: containers comes with ghc. it should not be updated outside of ghc changes
17:27:28 <NemesisD> c_wraith: well im guessing that cabal install --only-dependencies may do that?
17:27:45 <c_wraith> NemesisD: generally, if it happens, you have broken .cabal files somewhere
17:29:42 <monochrom> "ghc-pkg check" is unlikely to show anything wrong. "ghc -v" shows what's wrong
17:30:44 <NemesisD> i found some script on haskell reddit a while ago that would grep the broken packages and remove them
17:30:55 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for how to cause this kind of problems
17:31:39 <elliott> NemesisD: Don't do that.
17:31:48 <elliott> NemesisD: Just wipe everything and don't do whatever you did that broke it :)
17:32:09 <monochrom> solution is a large dose of "ghc-pkg unregister" or cleaning a certain directory inside .ghc
17:32:29 <NemesisD> that being using haskell?
17:32:32 <zzing> How about a lot of warnings related to haddock this or that of packages?
17:32:33 <NemesisD> lol
17:33:05 <elliott> zzing: You mean "can't find link destination for ..."?
17:33:06 <NemesisD> im getting lovely this package indirectly depends on multiple versions of the same package: all are either 1.4 or 1.4.0.1 :|
17:33:08 <elliott> Those are normal and unavoidable.
17:33:12 <monochrom> my page also says what is inside .ghc
17:33:21 <zzing> Warning: haddock-html: /usr/local/share/doc/mtl-2.0.1.0/html doesn't exist or isn't a directory
17:33:28 <zzing> Warning: haddock-interfaces: /usr/local/share/doc/mtl-2.0.1.0/html/mtl.haddock doesn't exist or isn't a file
17:33:39 <zzing> Which they won't exist because haskell isn't there
17:35:27 <nejucomo> What does the haskell-platform give me that I wouldn't have if I install a recent ghc and a recent cabal-install ?
17:35:32 <monochrom> your package database state is confusing cabal. when cabal says "x requires y 0.1, x also requires y 0.2", it does not know what it is talking about, please don't draw conclusions from it
17:35:34 <NemesisD> elliott: i can't run the program with runhaskell becaue of it
17:36:10 <NemesisD> its confusing because mysql-simple, one that claims it requires time 1.4 actually doesn't specify its version
17:36:11 <elliott> NemesisD: rm -r ~/.ghc ~/.cabal
17:36:16 <NemesisD> ugh
17:36:29 <elliott> Use cabal-dev in future... reading the page monochrom linked will help you too
17:36:36 <NemesisD> any time i want to get work done i have to nuke everything and go do something else for half an hour while it compiles
17:36:52 <elliott> That means you keep makingthe same mistake :)
17:36:54 <elliott> * the
17:37:07 <NemesisD> or that the system is unintuitive or defective
17:37:34 <geekosaur> nejucomo, it gives you a set of consistent packages that a majority of haskell programs and packages work with, which can't quite be said of the latest ghc because of some significant core API changes
17:37:44 <monochrom> to some extent, cabal is defective. it's an upgrade whore. that causes the errors.
17:37:58 <geekosaur> (and, don't apologize for cabal-install, the fact that it lets you do this kin of thing is broken)
17:38:16 <NemesisD> the problem with using cabal-dev is that my editor can't check that my types work out in the file because the packages aren't installed since they're all in cabal-dev/
17:39:15 <NemesisD> slows me down horribly to have to both ignore errors in my editor and keep bouncing back to the compiler to see if im doing something dumb
17:40:08 <monochrom> the editor should be extended to be cabal-dev-aware
17:41:27 <elliott> NemesisD: emacs haskell-mode supports cabal-dev as of recently
17:42:05 <NemesisD> elliott: never! vim ;)
17:42:21 <NemesisD> it seems to run ghc-mod
17:43:07 <monochrom> then, ghc-mod should be modded to be cabal-dev-aware
17:43:54 <gwern> > 536 / 123
17:43:55 <lambdabot>   4.357723577235772
17:44:01 <gwern> > 123 / 536
17:44:02 <lambdabot>   0.2294776119402985
17:44:37 <NemesisD> looks like the latest might just do that!
17:45:23 <byorgey> ghc-mod-mod?
17:48:39 <NemesisD> heh
17:53:38 <NemesisD> cabal-dev all the things!
17:57:37 <nand`> the solution to cabal problems was to not use cabal
17:57:42 <nand`> for me
17:58:13 <elliott> I doubt you don't use cabal. cabal-install, perhaps.
18:00:46 <NemesisD> anyone know how to install dependencies for the test suite of a package?
18:01:06 <nand`> elliott: I use Gentoo's build system which iirc does the full “ghc Setup.lhs” thing
18:01:23 <elliott> That's Cabal.
18:01:26 <nand`> I see
18:01:27 <NemesisD> if you do cabal-dev install --enable-tests --only-dependencies it install the test dependencies of *all* your dependencies recursively, which are basically guaranteed not to jive with yours
18:01:33 <nand`> Well, I don't use cabal-install then
18:14:40 <t7> what do i do when i have ambiguous module name?
18:15:18 <t7> ah solved
18:18:45 <t7> cabal uninstall would be amazing
18:20:29 <nejucomo> The haskell platform page says I need ghc 7.0.4, but the ghc 7.0.4 page says ~"stop!  ghc is already in the haskell platform; use that".
18:20:46 <nejucomo> I assume the latter means that the binary distribution of the platform has ghc?
18:21:08 <td123> ya should be
18:21:21 <elliott> nejucomo: yes
18:21:27 <elliott> doesn't apply if you're going the source route
18:21:53 <zzing> I am trying to figure out how to get my haskell source compiled, and I am trying a few new things...  I was wondering if I could get some input on it: https://gist.github.com/90fbbe95db07695e2c6d  and a lot of errors: https://gist.github.com/78b2852bf3436e4bc61b    I am not sure what the best way to reduce the errors I have to deal with and there are some type things that aren't working how I think they would.
18:22:12 <nejucomo> I also assume it would be folly to try to install the haskell platform from source using ghc 7.4.1?
18:22:29 <elliott> nejucomo: don't do that, it'll lead to tears
18:22:34 <td123> the haskell platform doesn't exist w/ ghc 7.4.1
18:22:55 <elliott> nejucomo: if you can deal with and fix the errors you get from packages that haven't been updated yet, then you won't care for the convenience of the platform anyway ;)
18:23:08 <elliott> zzing: mostly errors like "no instance for Num (Ray Double)" mean that you're trying to add Ray Doubles
18:23:12 <elliott> but they're not numbers
18:23:34 <elliott> you appear to be treating Ray Double like it's a Double, and Vector Double like it's a double; "v1 + v2" will not add two vectors
18:23:38 <elliott> you'll need V.zipWith (+) v1 v2 or such
18:24:26 <zzing> oh I missed the functions I need for these
18:24:29 <zzing> changing it
18:25:02 <nejucomo> Whee, here we go again.  (It took about 1 hour to compile ghc 7.4.1 on this vm…)
18:25:42 <luite> use make -j8 or something next time
18:26:02 <elliott> nejucomo: you should just use a GHC binary distro
18:26:06 <elliott> they can install to any directory
18:26:48 <zzing> elliott: I think I have to build this up slowly to figure this out
18:26:51 <nejucomo> elliott: Compiling from source gives me a warm fuzzy feeling.  ;-)
18:26:54 <zzing> I admit to this looking like a mess anyways
18:27:26 <elliott> nejucomo: Hope you never have to use Firefox or OpenOffice :)
18:28:19 <nejucomo> hehe...
18:28:30 <t7> @hoogle replicateM
18:28:31 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:28:31 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
18:28:31 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
18:29:04 <nexion> I'm trying to use Network.HTTP to read HTTP requests, but I don't understand how to get the HandleStream for this -- I'm basically just trying to listen on a host:port and read requests from there
18:29:21 <nejucomo> My stubborn old ways are to install the debian package if it exists; then use a "cross platform package system" like cabal or pip if it exists; else compile from source.
18:29:51 <nejucomo> I've had too many bad experiences with binary packages assuming it's okay to modify the system state and borking things.
18:29:59 <hpaste> teneen pasted “fibonacci” at http://hpaste.org/66843
18:30:01 <teneen> Hey guys, I was surprised to find out that the equivalent python code of this (hpaste) is faster by 4 seconds!
18:30:12 <elliott> Are you compiling with -O2?
18:30:18 <teneen> Any explanation why? I thought the haskell version should be much faster
18:30:24 <teneen> elliott: Yes!
18:30:32 <elliott> Please hpaste the Python code.
18:30:52 <copumpkin> when you compiled with -O2, did you compile without first?
18:30:55 <copumpkin> did you make sure it recompiled?
18:30:57 <nejucomo> Although I have successfully used unionfs + chroot sometimes, but sometimes it fails to allow shared libraries to load, not sure why.
18:31:04 <elliott> Oh, yeah, try -fforce-recomp.
18:31:16 <teneen> Yes
18:31:25 <zzing> When I compile my code while importing Numeric.Container, it seems to compile just fine. But when I :load ray  (my module) in ghci, it says it could not find Numeric.Container. What can do I for this?
18:31:33 <teneen> I used -O2 from the first time
18:31:42 <elliott> zzing: Is Numeric.Container part of your project?
18:31:50 <zzing> no
18:31:55 <elliott> Weird.
18:32:00 <zzing> It is part of hmatrix
18:32:07 <elliott> Hmm, you're on GHC 6, aren't you?
18:32:13 <hpaste> teneen pasted “fibonnaci” at http://hpaste.org/66844
18:32:14 <zzing> Nope, 7.4.1
18:32:18 <elliott> oh, I thought you were
18:32:27 <teneen> elliott: 7.41
18:33:00 <teneen> elliott: the last hpaste is the python version
18:33:40 <hpaste> elliott annotated “fibonacci” with “fibonacci (annotation)” at http://hpaste.org/66843#a66845
18:33:47 <elliott> teneen: How about this? It's a more direct translation of the Python code.
18:33:58 <elliott> teneen: Erm, "fst ." should be "fst $".
18:35:22 <zzing> My ghc -v says it is searching in Numeric/Container.hs and Numeric/Container.lhs, with the full output : https://gist.github.com/1b0b2e46e49019f8dc35
18:35:30 <zzing> *ghci -v
18:35:50 <elliott> zzing: Well, it should be finding Numeric.Container, if it's in a package.
18:35:53 <elliott> How did you install hmatrix?
18:35:58 <zzing> cabal install hmatrix
18:36:33 <zzing> Installed ~/.cabal/lib/hmatrix-0.14.0.1/
18:36:52 <elliott> Hmm.
18:36:55 <elliott> $ which ghc
18:36:56 <elliott> $ which ghci
18:37:03 * elliott isn't convinced they're from the same install.
18:37:07 <teneen> elliott: takes the same time as the first haskell version
18:37:28 <zzing>  both under /usr/bin but they are symlinks: /usr/bin/ghc -> /Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/bin/ghc
18:37:32 <elliott> teneen: Can you "cabal install ghc-core", and then "ghc-core -- -O2 fib.hs" and hpaste what that outputs?
18:37:42 <elliott> For either of the versions.
18:37:46 <zzing>  /usr/bin/ghci -> /Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/bin/ghci
18:37:55 <elliott> It's weird, the code looks fine to me.
18:38:07 <elliott> zzing: Hmmm.
18:38:12 <elliott> zzing: Dunno, then; sorry.
18:38:12 <teneen> elliott: for the first one or the second?
18:38:31 <zzing> elliott: where would the settings for where ghci would look for packages be?
18:39:12 <elliott> teneen: <elliott> For either of the versions.
18:39:16 <elliott> Perhaps the first, since it has less boxing and the like.
18:39:21 <elliott> zzing: GHC's package database.
18:39:27 <elliott> "ghc-pkg list" should list hmatrix in your local database.
18:39:58 <Paradox2000> Is Learn You a Haskell for Great Good a good beginner's tutorial for someone with no functional programming experience?
18:40:03 <zzing>    hmatrix-0.14.0.1   yes
18:40:19 <teneen> elliott: Any help on how to copy this large output from ghc-core?
18:40:27 <lispy> Paradox2000: I haven't read it, but I would say just do it. Come here if you don't understand it.
18:40:50 <Paradox2000> lispy: OK. Thanks :)
18:40:52 <elliott> teneen: Try ghc-core ... >core.
18:40:52 <zzing> ghc -v says: package hmatrix-0.14.0.1-72043674596b05991d312e6bc875e68d is unusable due to missing or recursive dependencies:   process-1.1.0.1-dd810a368ec79f28445811c5f39bd53a
18:40:58 <lispy> Paradox2000: functional programming isn't terribly mysterious, in my opinion
18:41:01 <elliott> Paradox2000: Yes, it's a good tutorial.
18:41:04 <Philippa> Paradox2000: you wouldn't be the first to read it from that position
18:41:08 <Philippa> also, tryhaskell.org ?
18:41:18 <elliott> Paradox2000: In fact, that's its target audience.
18:41:23 <elliott> Paradox2000: (Assuming you have programming experience.)
18:41:43 <Paradox2000> Sorry for my ignorance.
18:42:08 <elliott> I don't see any ignorance.
18:42:27 <lispy> Paradox2000: I think the basics of functional programming are actually more accessible to beginners than the alternatives. Although, if you learn by reducing everything to the basic principles then assembly can be a better place to start.
18:42:35 <zzing> If I remove ~/.cabal, will I be able to fix most package problems I might be having right now?
18:42:42 <teneen> elliott: The output using the (>) operator in terminal is not the same. It seems to have a lot of annotations
18:42:49 <elliott> zzing: Probably not.
18:42:52 <elliott> Your packages don't sound broken per se.
18:43:02 <elliott> teneen: Oh, the ANSI code stuff.
18:43:13 <elliott> teneen: Eh, just do ghc -ddump-simpl -O2 foo.hs >core
18:43:21 <elliott> You might also want to try -fllvm to speed it up, btw
18:43:33 <lispy> Paradox2000: What languages do you have previous experience with?
18:43:58 <Paradox2000> lispy: Java, Python, Ruby
18:44:55 <elliott> Yeah, LYAH should do you good, then.
18:45:01 <lispy> Paradox2000: I see. So, you will probably want to forget what you know of OOP :) Haskell can do OOP, but using it at the start won't help you :)
18:45:08 <elliott> Paradox2000: It does a good job of helping you unlearn the existing imperative paradigm.
18:45:39 <elliott> lispy: Well, actually, I would call records of functions and actions "OOP done right", and that's something you should pick up quickly with Haskell.
18:45:57 <Paradox2000> Thanks. Now I'm going to go read LYAH.
18:45:59 * elliott wouldn't call advanced typeclass hackery to fake "traditional" OOP languages "object-oriented programming" so much as "object-oriented abomination" :)
18:46:29 <lispy> elliott: if that's "OOP done right" then why do we have C++? Shouldn't we just use struct and function pointers? (only half-rhetorical)
18:46:47 <Pseudonym> elliott, Alan Kay would probably disagree with you.
18:47:05 <lispy> Pseudonym: long time no see.  How goes?
18:47:13 <Pseudonym> Except that he'd point out that many "traditional" OOP languages aren't OOP at all.
18:47:14 <Pseudonym> G'day.
18:47:18 <elliott> Pseudonym: Probably not the only thing I'd disagree with Alan Kay on.
18:47:42 <elliott> Pseudonym: But I think "collection of encapsulated behaviour" is a lot closer to Kay OO than many other languages :)
18:48:00 <zzing> What is Kay OO?
18:48:01 <elliott> I mean, it's effectively message-passing, even if it's not called that; "message passing" is kind of a vague term because it's close to an implementation detail.
18:48:12 <elliott> zzing: The original object-oriented programming as invented by Alan Kay.
18:48:24 <elliott> lispy: Well, C++ doesn't abstract over functions very well!
18:48:32 <lispy> zzing: Alan Kay envisioned OOP as little machines that send messages to each other and collaborate to solve problems.
18:48:32 <elliott> lispy: And since it doesn't have closures, your objects couldn't have state.
18:48:34 <hpaste> teneen pasted “fibonacci core” at http://hpaste.org/66846
18:48:38 <Pseudonym> http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en
18:48:41 <teneen> elliott: done
18:48:46 <elliott> lispy: You'd need to stuff a {void *state} and pass that to all the member functions.
18:48:56 <elliott> lispy: Which I've done in C, quite successfully. But it's pretty noisy.
18:48:57 <zzing> lispy: sounds bizarre
18:49:20 <zzing> elliott: replacing my .cabal and .ghc  under ~ and reinstalling hmatrix fixed it
18:49:24 <elliott> teneen: Looks like it's pretty much as good as it gets.
18:49:29 <elliott> zzing: Odd.
18:49:30 <t7> @hoogle (a -> a -> a -> a -> b) -> [a] -> b
18:49:31 <lambdabot> No results found
18:49:48 <lispy> zzing: I think there is a place for it. I don't necessary want it as the foundation of my computing, but I can see building it from a different foundation and having it work well for specific problems.
18:49:56 <teneen> elliott: So python handles large numbers more efficiently?
18:50:19 <teneen> elliott: I wasn't expecting this since python is interpreted and haskell is compiled.
18:50:23 <zzing> If I have data Sphere a = Sphere (Vector a) a   does the Sphere a define the type and Sphere (Vector a) a  define the constructor?
18:51:07 <lispy> zzing: I think the way unix is designed (if you're familiar with it) is very much object oriented (small programs that solve a particular problem well), but it also has functional elements.
18:51:29 <elliott> teneen: No, I don't think that's true.
18:51:29 <zzing> lispy: monadic?
18:51:35 <Pseudonym> Interestingly, if you read that message, Alan Kay would probably think that Erlang is more OOP than Java.
18:51:49 <Pseudonym> Which actually makes sense when you think about it.
18:51:51 <zzing> It might by numpy which means it isn't python, it is fortran or c
18:52:01 <elliott> teneen: I think there's some kind of weird edge-case here. Either an odd GHC performance bug, a regression in 7.4.1 (remember, it just came out!), or Python doing something very tricksy here.
18:52:09 <elliott> Or one of the programs has a bug and nobody's realised it yet :)
18:52:14 <elliott> teneen: Did you try -fllvm?
18:52:23 <elliott> Anyway, you can't make any conclusion based on one microbenchmark.
18:52:27 <lispy> zzing: Yeah, I guess you could say parts of unix are monadic, but for the functional elements I was thinking about the way pipes work
18:52:41 <td123> zzing: he didn't import numpy though (or any other lib iirc)
18:52:54 <zzing> lispy: I remember somebody did a circuit sim with bash and pipes
18:52:55 <teneen> elliott: I tried -fllvm with no non-trivial difference
18:53:10 <lispy> zzing: and there is h4sh that dons made
18:53:26 <zzing> Curious, with -fllvm, would it now be possible do compile stuff from ghc to the ios platform?
18:53:36 <elliott> zzing: There's already iPhone stuff.
18:53:46 <elliott> Some people are making a game with it. Supposedly.
18:53:57 <lispy> zzing: http://article.gmane.org/gmane.comp.lang.haskell.general/12043
18:56:57 <teneen> elliott: Thanks for the help :)
18:57:06 <elliott> teneen: You might want to report it to GHC trac.
18:58:09 <lispy> elliott: Cale would know about that
18:58:16 <lispy> (the iphone thing)
18:58:49 <teneen> elliott: I'm sorry, but how to do this? :)
18:59:18 <elliott> teneen: http://hackage.haskell.org/trac/ghc/
18:59:25 <elliott> lispy: Supposedly :)
19:00:20 <teneen> elliott: this goes under "Create ticket -> New Bug" ?
19:00:44 <elliott> teneen: yeah... it might get closed as WONTFIX though :p
19:00:54 <elliott> but it's certainly odd for that Core to be slower than Python for pure number-crunching
19:02:02 <zzing> Is there any reason why (+) couldn't be implemented for something like a vector library?
19:02:18 <zzing> (or shouldn't)
19:02:28 <lispy> zzing: because Num isn't a ring
19:02:44 <AtnNn> is there a package dealing with types such as `newtype Stack f g r = Stack (f (g r))' and `type Fix2 a b = Fix (Stack a b)' on hackage?
19:03:27 <lispy> zzing: what is the signum of a vector?
19:03:29 <lispy> :t signum
19:03:30 <lambdabot> forall a. (Num a) => a -> a
19:04:03 <zzing> @src signum
19:04:03 <lambdabot> Source not found. My mind is going. I can feel it.
19:04:19 <lispy> zzing: morally, it's the sign of the number
19:04:26 <lispy> > signum (-100)
19:04:28 <lambdabot>   -1
19:04:32 <lispy> > signum (-100.23)
19:04:33 <lambdabot>   -1.0
19:04:45 <Zamarok1> Is there a builtin function like "count x xs" that counts the times x appears in xs? Like "count x = length . filter (== x)".
19:05:41 <zzing> lispy: That is a good question
19:06:07 <zzing> lispy: If you treat a vector as a complex number, it would be the sign of the real part
19:06:16 <ForSpareParts> Can someone help me understand Parsec? I'm still a little shaky on Monads and how they work, and I'm a bit mystified as to why elements of Parsec grammars don't seem to need arguments in their definitions.
19:06:36 <ForSpareParts> For example, this is part of a sample my programming languages professor gave us: http://hpaste.org/66847
19:06:54 <byorgey> Zamarok1: no.
19:07:05 <mauke> ForSpareParts: what kind of arguments would you expect?
19:07:05 <ForSpareParts> If int is a function definition, why doesn't it have an argument specified?
19:07:13 <mauke> it's not a function
19:07:15 <lispy> ForSpareParts: the "parser monad" is responsible for consuming the input, so the machinery for the input is part of the monadic type.
19:07:30 <Zamarok1> byorgey: is there a better way to do it than my example?
19:07:40 <lispy> ForSpareParts: You don't see it as a separate part of the type though
19:07:42 <byorgey> Zamarok1: no, your implementation looks great
19:07:53 <Zamarok1> Ok, thanks.
19:08:26 <lispy> ForSpareParts: I think this aspect is actually kind of hard to illustrate
19:08:33 <ForSpareParts> lispy/mauke: So "int" just returns an integer parser, and you have to chain it onto other parser monads for it to work?
19:08:44 <mauke> ForSpareParts: it doesn't return one, it is one
19:09:14 <mauke> :t runParser
19:09:15 <lambdabot> Not in scope: `runParser'
19:09:36 <lispy> ForSpareParts: The monad has wrapped itself around the normal functions and is then able to "interfer" with what they accept/return. The structure of the monad is then making sure that things that "need" input get it and things that have failures are treated accordingly. The lesson: Monads can hide your plumbing.
19:10:31 <lispy> > do x <- return (Just 1); return x
19:10:32 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe t)))
19:10:32 <lambdabot>    arising from a ...
19:10:33 <ForSpareParts> lispy: How would things that need input get their input?
19:11:03 <ForSpareParts> Is it by virtue of chaining them onto a monad that contains the appropriate input...?
19:11:06 <lispy> ForSpareParts: At some level you will need to call a special "run my monad" function and at that point you give it an input source
19:11:21 <lispy> ForSpareParts: yeah, you can think of it that way
19:11:22 <zachk> anyone have some urls of liquid sunshine online for remotivating onself to code haskell?
19:11:25 <mauke> ForSpareParts: by 'Parser a' containing a function that takes inputs
19:12:10 <lispy> zachk: http://fpcomplete.com/the-downfall-of-imperative-programming/
19:12:25 <zzo38> Is (Codensity Endo) like a list? Maybe edwardk knows. Is edwardk on now?
19:12:28 <lispy> zachk: http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf This link is better than the first
19:12:54 <ForSpareParts> OK. Hrm. So, I want to make sure that I get what's going on, conceptually: would it be correct to say that each line of the do notation creates a new Monad by applying the Monad described by the line to the thing above?
19:13:21 <lispy> ForSpareParts: Have you studied the translation from do-notation to the bind-notation?
19:13:42 <lispy> ?undo do { x <- foo; y <- bar; baz x y }
19:13:43 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz x y
19:13:46 <mauke> ForSpareParts: no, new monads are created by 'instance Monad X ...'
19:14:13 <ForSpareParts> lispy: A little bit. I still don't feel like I completely understand what Monads DO, so the bind notation doesn't make much more sense to me...
19:14:35 <mauke> ForSpareParts: every monad does different things
19:14:39 <lispy> ForSpareParts: monads are a structure and you can attach a semantics, but they don't really DO much
19:14:42 <mauke> so that wouldn't help you anyway :-)
19:14:45 <zzo38> ForSpareParts: A monad is simply something following certain laws; different monads have different purpose
19:15:28 <ForSpareParts> I sort of got that, yeah. I'm having trouble understanding their form, why you'd want to use them
19:15:51 <mauke> in this case, because you can write cool parsers
19:15:56 <ForSpareParts> The use of the abstraction, I guess.
19:16:19 <mauke> the abstraction lets you use helper functions from Control.Monad
19:16:24 <lispy> ForSpareParts: I like to think that monads wrap around the functions I would nornmally call and the monad gets to inspect the input/output of the functions.  Sometimes the monad decides to take some action/side-effect based on what the functions take/return, but this has to happen in a structured way because the monad can't really see the value itself due to polymorphism
19:16:30 <zzo38> For parsers, Applicative is usually better
19:16:51 <zzo38> And all monads on (->) are applicative, too
19:17:30 <lispy> ForSpareParts: if you use the Maybe monad, the bind operation (>>=) can't look at the 'a' (as in Maybe a), but it can see if the previous computation return Just _ or Nothing.
19:18:06 <lispy> ForSpareParts: so then the Maybe monad is able to 'stop early' if it sees a Nothing come by
19:18:09 <zzo38> In addition, all monads are endofunctors.
19:18:19 <elliott> ForSpareParts: You shouldn't worry about "why monads".
19:18:37 <elliott> ForSpareParts: In this case, you have an abstraction modelling parsers.
19:18:43 <zzo38> The Either monad can also "stop early" like Maybe, but there can be a value associated with it
19:18:50 <elliott> ForSpareParts: It just so happens that you can compose these parsers in certain ways.
19:19:00 <ForSpareParts> zzo38: Could you explain what applicative and endofunctors mean?
19:19:02 <elliott> ForSpareParts: These ways happen to be ways that *many* different structures share.
19:19:07 <zzing> If I have a long line that has an operator as a break point (\n) which do I put the \n before or after the operator OR where indentation is the sole issue, how do I not confuse ghc?
19:19:08 <zzo38> elliott: Yes that is the description good
19:19:24 <zzo38> ForSpareParts: See the classes "Applicative" and "Functor" for some description.
19:19:26 <elliott> ForSpareParts: You don't need to care about Monad itself; you just need to care about writing parsers. The only reason it "uses Monads" is because the tools that Monad provide are useful in many different situations.
19:19:38 <elliott> It would be silly to rewrite them from scratch for every structure that can use them.
19:20:02 <ForSpareParts> elliott: Fair enough. I guess if I use enough things that are monadic in nature it'll start to become clear to me what they have in common?
19:20:34 <zzo38> elliott: That is one of the best descriptions yet
19:20:43 <elliott> ForSpareParts: Yes, the best way to get a handle on what a monadic interface provides is to just use as many as you can.
19:20:46 <elliott> zzo38: thanks :)
19:21:06 <ForSpareParts> OK.
19:21:11 <elliott> ForSpareParts: (And it's not the only "composition"-based interface Haskell has; Applicative and Functor, as zzo38 mentioned, are some others.)
19:21:11 <ForSpareParts> A more practical question, then:
19:21:30 <elliott> (In fact, every Monad is an Applicative and every Applicative is a Functor -- it's a progressively more powerful series of abstractions. But again, you don't have to worry about that now.)
19:22:24 <ForSpareParts> Actually, never mind, I think I just answered it for myself, typing it out...
19:22:36 <ForSpareParts> Thank you, guys. You've been a big help.
19:22:42 <elliott> :)
19:28:09 <Zamarok1> Why does Data.List.Take take an Int instead of an Integral like genericTake? What is the purpose of taking and Int instead of any Integral number?
19:28:17 <Zamarok1> an* Int
19:28:31 <elliott> Zamarok1: Mostly because it simplifies the type and errors for newbies.
19:28:40 <elliott> I think.
19:28:46 <elliott> That's what most of the committee's odd decisions come down to.
19:29:14 <Zamarok1> That seems unnecessary.. because now I have calls to "fromIntegral" all over the place, and it makes my code ugly
19:29:35 <elliott> Why not just use genericTake?
19:29:52 <elliott> Anyway, you might be being a bit *too* polymorphic if you're having to do that everywhere :P
19:29:57 <Zamarok1> I just discovered it.. I'm about to change over. I thought I would ask why take uses Int before doing it, incase there is a good reason.
19:31:01 <Zamarok1> Well that's just because I use Int in some places where I only will ever need a single base 10 digit, and Integer in other places where the number might be quite large
19:31:21 <Zamarok1> But genericTake will work
19:31:24 <elliott> Zamarok1: Right. Remember that a list will never be able to store more than Int elements, though.
19:31:45 <elliott> Since Int will generally be able to address as much memory as the machine (OK, the Report doesn't technically require this).
19:31:58 <glguy> > cycle [1]
19:31:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:32:17 <Zamarok1> You mean the maximum capacity of a list is INT_MAX?
19:32:49 <Mathnerd314> edwardk: why does ad require template-haskell-2.6 instead of the template-haskell-2.5 that the Haskell platform comes with? :-/
19:33:19 <elliott> Zamarok1: Well, on GHC, Int is either 32 bits or 64 bits.
19:33:32 <elliott> Zamarok1: If your computer has 32-bit or 64-bit pointers then by definition it can't store more than tha.
19:33:32 <elliott> *that.
19:33:36 <glguy> You don't have to have the whole list in memory
19:34:01 <edwardk> mathnerd: the main issue was that i had to make some breaking changes to support 2.6 and didn't keep a close log of them all
19:34:01 <lambdabot> edwardk: You have 4 new messages. '/msg lambdabot @messages' to read them.
19:34:49 <elliott> glguy: True.
19:35:06 <elliott> If you're careful with your memory usage, you could process a list incrementally beyond the limits of memory.
19:35:30 <Mathnerd314> edwardk: I see. any easy resolutions to the problem?
19:35:31 <elliott> On 64-bit you're unlikely to run up against the limits anyway though :P
19:35:35 <edwardk> if you can come upw ith a patch that adds back th 2.5 support with MIN_VERSION or something but doesn't break 2.6 i'd take it
19:35:44 <Zamarok1> I see, I see
19:36:08 <edwardk> Mathnerd314: probably. though i admit, i don't know what the MIN_VERSION macro turns into for a package with a dash in it
19:36:43 <edwardk> i also don't have 7.0 installed to test
19:37:03 <mekkz> (take 10 $ cycle['na']) ++ [' batman!']
19:37:06 <mekkz> aww
19:37:25 <Mathnerd314> > (take 10 $ cycle['na']) ++ [' batman!']
19:37:26 <lambdabot>   <no location info>:
19:37:26 <lambdabot>      lexical error in string/character literal at chara...
19:37:42 <Mathnerd314> > (take 10 $ cycle["na"]) ++ [" batman!"]
19:37:43 <lambdabot>   ["na","na","na","na","na","na","na","na","na","na"," batman!"]
19:37:57 <zzo38> Maybe you should put join?
19:38:00 <Mathnerd314> > (take 10 $ cycle "na") ++ " batman!"
19:38:01 <lambdabot>   "nanananana batman!"
19:38:02 <aavogt> > replicate 10 "na"
19:38:02 <mekkz> good point
19:38:03 <lambdabot>   ["na","na","na","na","na","na","na","na","na","na"]
19:38:15 <zzo38> That way better
19:38:17 <mekkz> totally worth it
19:38:50 <Orclev_> I'm working on a reactive-banana SDL binding and I'm trying to figure out a style question, namely because SDL is much lower level than most GUI frameworks, at what "level" is it best to exit the FRP network? My initial instinct is to have a data object that gets manipulated by FRP and then ultimately fed to a render function that exists outside it
19:38:51 <Mathnerd314> > (take 10 $ cycle "NA ") ++ " batman!"
19:38:52 <lambdabot>   "NA NA NA N batman!"
19:39:08 <Mathnerd314> :-/
19:39:34 <elliott> Orclev_: well, it depends whether you're trying to bind reactive-banana to SDL, or want to create a higher-level thing on top of that
19:39:46 <zzo38> edwardk: O, you are on, now. I tried and I noticed that, if Plus does not require Functor, then (Codensity Endo) is like a list monad
19:41:03 <edwardk> zzo38: Yes, I worked with dolio to rewrite the LogicT monad transformer effectively as a codensity monad, removing a lot of the oleggy newtype noise
19:41:37 <Orclev_> elliott: I want to use this for writing a game eventually... I've looked at some of the game FRP libraries, but I'm trying not to confine the implementation that much as I'd ideally like the same binding to be useable for any kind of app built on SDL
19:41:37 <edwardk> zzo38: but I'm not in a hurry to weaken Plus. There comes a point at which you have to stop taking things apart ;)
19:41:59 <edwardk> At least if you want people to be willing to build stuff on top
19:42:40 <elliott> Orclev_: Right. Well, it's a bit of a vague question :)
19:42:54 <Orclev_> essentially at this point all I really have is an abstract sort of eventing system on top of SDL, I'm just trying to figure out how much further I can push things without going too far, or if this just demonstrates that FRP is overkill for this
19:43:09 <edwardk> zzo38: you may be interested in the fact that Yoneda Endo is Maybe as well
19:43:14 <zzo38> edwardk: What does "oleggy newtype noise" mean?
19:43:29 <elliott> Orclev_: Does that mean you're supplying your own main loop/
19:43:30 <elliott> *?
19:43:34 <Orclev_> elliott: yeah
19:43:40 <elliott> Orclev_: That's a bad idea, I think.
19:43:40 <edwardk> zzo38: look at the last couple of releases of logict
19:43:48 <elliott> The details of the main loop will vary from game to game to program to program.
19:43:49 <Orclev_> elliott: well, yes and no
19:44:11 <Orclev_> elliott: I've got a event pump function that's provided by the library
19:44:21 <elliott> Right.
19:44:28 <Orclev_> elliott: is just takes all the SDL events and exposes them as a reactive banana event stream
19:44:35 <elliott> Oh.
19:44:39 <elliott> Hmm.
19:44:40 <elliott> I suppose that works.
19:44:44 <edwardk> newtype LogicT m a = LogicT { unLogicT :: forall r. (a -> m r -> m r) -> m r -> m r } vs. newtype LogicT m a = LogicT { unLogicT :: forall ans. SK (m ans) a -> FK (m ans) -> m ans }
19:44:46 <zzo38> O, now I see. But what are FK and SK?
19:44:52 <elliott> Then you can filterJust the ones you care about individually.
19:44:58 <Orclev_> essentially yes
19:45:06 <Orclev_> I also provide some helper functions for common cases
19:45:15 <edwardk> zzo38: they are the continuations oleg used to formulate it in the original paper
19:45:17 <Orclev_> like, filterKey SDLK_q
19:45:51 <edwardk> type SK r a = a -> r -> r ; type FK a = a
19:46:01 <edwardk> oh, i guess they weren't newtypes
19:46:18 <zzo38> edwardk: I do think the new way makes more sense; it is basically the fold, I think.
19:46:25 <edwardk> yes
19:46:32 <elliott> Orclev_: Right. That seems reasonable. The other main thing to address would be actually painting on the screen. But the problem there is that it's hard to provide something general that is declarative/FRPy.
19:46:35 <edwardk> and its obviously a codensity monad
19:46:41 <elliott> Orclev_: So that seems like something that would have to be done at a higher layer, say in a game framework or the like.
19:46:45 <zzo38> And yes that too
19:46:55 <edwardk> so you get return and bind for free, and all the other operations follow suit
19:46:58 <Orclev_> elliott: right, that's exactly what I'm running into now
19:47:04 <elliott> In general, reactive-banana bindings are going to be pretty light; once you start making restricting design decisions and building significant non-equivalent abstraction on top, you're making a framework.
19:47:22 <elliott> Which is fine, but it means you'll have to accept that you're not going to be able to satisfy every single use (unless you're really good at API design).
19:47:35 * Orclev_ is not really good at API design.
19:47:55 <elliott> Orclev_: Well, here's one possible approach:
19:48:10 <elliott> Orclev_: newtype Graphic = Graphic { paintGraphic :: SDL.Screen -> IO () }
19:48:27 <elliott> Orclev_: You can build a combinator library on top of this, and export the Graphic constructor in an "unsafe" module.
19:48:44 <elliott> That way, you can combine graphics in a declarative manner, while having the implementation use SDL's imperative primitives directly under the hood.
19:49:06 <Orclev_> interesting idea, I'll have to roll that around in my head for a little while
19:49:19 <elliott> Then you can have a (Behavior t Graphic), and do:
19:49:50 <elliott> do { initial graphicB >>= liftIO; graphicE <- changes graphicB; reactimate (paintGraphic <$> graphicE) }
19:50:05 <elliott> Of course, that still redraws the whole thing every frame... but it's just a sketch ;)
19:50:14 <zzo38> (Although I don't really like the name "Logic" for this, as well as a bunch of the other names used in Haskell I don't particularly like much; but it works anyways)
19:50:18 <elliott> Orclev_: This code might help inspire you:
19:51:00 <elliott> Orclev_: https://github.com/HeinrichApfelmus/reactive-banana/tree/b8c353bf275ee2c58a05cbc18f33fe481c8e70e4/BlackBoard/src/Graphics
19:51:19 <elliott> Orclev_: It's a wx-based functional graphics library based on the same idea.
19:51:28 <zzo38> Can you tell me, is the "Drawing" and "DrawingNode" too complicated here? Is there better ways? Also, how to draw shapes other than a filled triangle?
19:51:31 <zzo38> http://sprunge.us/MKDJ
19:51:41 <elliott> Erm, sorry.
19:51:49 <elliott> Orclev_: That + https://github.com/HeinrichApfelmus/reactive-banana/blob/b8c353bf275ee2c58a05cbc18f33fe481c8e70e4/BlackBoard/src/Reactive/GraphicOpt.hs, which is the more important thing.
19:52:32 <elliott> https://github.com/HeinrichApfelmus/reactive-banana/blob/b8c353bf275ee2c58a05cbc18f33fe481c8e70e4/BlackBoard/src/Graphics/GUI.hs for the definition of Graphic and https://github.com/HeinrichApfelmus/reactive-banana/blob/b8c353bf275ee2c58a05cbc18f33fe481c8e70e4/BlackBoard/src/Reactive/GraphicOpt.hs for the FRP layer supporting efficient incremental updates
19:53:07 <Orclev_> elliott: thanks, I'll got look those over and play around with your suggestion... I'm sure I'll have more questions at some point in the future, but hopefully this will give me a good amount to chew on for now
19:53:15 <elliott> Orclev_: There, "TimeGraphic" is essentially a custom version of Behavior, with an initial value and update event stream, that uses an incremental update type in the event, rather than replacing the whole thing each time.
19:53:22 <zachk> zzo38: check out Graphics.Gloss on hackage mayhaps
19:53:34 <elliott> Orclev_: (Of course, you shouldn't expose the update event except in NetworkDescription, to stop it being used in pure FRP code, just like Behavior does.)
19:53:42 <elliott> Orclev_: No problem, it's a bit of an infodump :P
19:54:05 <zzo38> zachk: I did see that already. It doesn't help me much, especially the first question
19:54:25 <vodik> !dice: 2d2
19:54:41 <vodik> oops, wrong channel
19:57:10 <byorgey> @dice 2d2
19:57:10 <lambdabot> 2d2 => 2
19:58:43 <ion> You lose
19:59:24 <cwl> :t error
19:59:25 <lambdabot> forall a. [Char] -> a
19:59:28 <zachk> @dice 100d100
19:59:29 <lambdabot> 100d100 => 5065
19:59:34 <cwl> :t catch
19:59:35 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:59:58 <cwl> how to deal with exception throw by `error`
20:00:31 <zzo38> cwl: My suggestion is don't; it causes too many problems if you try
20:00:51 <cwl> zzo38: just let the program crash?
20:01:20 <monochrom> it is best to have never allowed error, than to have allowed error and tried to catch it
20:01:30 <zzo38> cwl: No; just write the other functions so that you won't call "error" if you do not want the program to stop
20:02:17 <cwl> zzo38: just don't call functions like (!!) head ... ?
20:02:20 <elliott> yes
20:02:24 <elliott> (!!) is bad, head is bad
20:02:32 <elliott> in fact (!!) is bad for two reasons, head only one
20:02:33 <cwl> o_0
20:02:36 <elliott> use pattern-matching instead
20:02:40 <zzo38> cwl: Or guard against it
20:02:46 <elliott> much shorter, much easier to read, much less error-prone
20:03:18 <monochrom> I use head. but like this: map head (group blahblah...). when I use head, I know it has no problem, I set up the context to be so.
20:03:19 <zzo38> Here is a file to use Hackage in Mozilla search-engine-plugin:  http://sprunge.us/OBRO
20:03:25 <cwl> `error` is almost every, like Data.Map.(!)
20:03:34 <monochrom> use Intelligent Design, don't use Evolution
20:04:09 <monochrom> Data.Map has lookup
20:04:41 <mekkz> wait what?
20:04:42 <cwl> monochrom: yes, List has GenericIndex
20:04:52 <elliott> cwl: if almost all the calls you use call error, your program is seriously broken
20:04:54 <mekkz> how is intelligent design > evolution?
20:04:57 <zzo38> Instead of head, you could use the convList function I have created
20:05:11 <zzo38> mekkz: Because you use whatever suits the purpose
20:05:21 <monochrom> Intelligent Design of programs you write, of course
20:05:27 <mekkz> ohh
20:05:34 <mekkz> haha didn't see the context
20:05:40 <zzo38> (As opposed to Stupid Design of programs you write)
20:06:34 <monochrom> genericIndex is not analogous to Data.Map.lookup
20:06:41 <monochrom> @type Data.Map.lookup
20:06:42 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
20:06:51 <monochrom> look at the "Maybe" there
20:07:55 <zzo38> I don't really like the genericIndex and that stuff so I wrote my own generalized versions of these functions and of others
20:08:48 <monochrom> anyway this is definitely an XY Problem
20:10:38 <zzo38> *My* version of (!!) looks like this:   (!!) :: (Copeanoid i, Foldable t) => t x -> i -> x;
20:11:56 <zzo38> genericIndex is no good this one better
20:12:23 <monochrom> what is Copeanoid?
20:12:26 <byorgey> Copeanoid?
20:12:41 <zzo38> monochrom:  class Copeanoid x where { predP :: x -> Maybe x; };
20:12:53 <byorgey> sounds like some sort of family of giant deep-sea crabs or something
20:13:29 <zzo38> byorgey: Maybe, but that isn't where the name comes from
20:13:47 <shapr> byorgey: Certainly does sound like a deep-sea crab
20:13:50 <monochrom> I see the light!
20:13:57 <monochrom> co peano oid
20:14:04 <shapr> ohhh
20:14:07 <byorgey> oh, hehehe
20:14:16 <monochrom> predP is a predecessor thing
20:14:17 <elliott> zzo38: If all you know about i is that it's Copeanoid, it's equivalent to [()], or Nat.
20:14:20 <tgeeky_> i got co-peano
20:14:27 * elliott dislikes typeclasses standing in for one representative type.
20:14:34 <elliott> (e.g. readM instead of readMaybe.)
20:14:35 <tgeeky_> i couldn't figure out of its -oid or peano-id
20:14:45 <shapr> Is that like co-dependently-typed and dysfunctional?
20:14:52 <byorgey> elliott: sure, but you can call (!!) with things other than Nat.
20:14:53 <zzo38> tgeeky_: I just omitted the extra "o"
20:15:43 * byorgey prefers Copeanooid
20:16:09 <elliott> Copperannoyed
20:16:20 <elliott> Sounds like a fortress name from Dwarf Fortress.
20:16:37 <magicman> Coparanoid. Feeling like you're following someone.
20:16:47 <byorgey> hehehe
20:16:55 <monochrom> hahaha
20:17:01 <elliott> heh
20:17:05 <rasfar> =D
20:17:13 <zzo38> I also have   class Peanoid x where { zeroP :: x; succP :: x -> x; };   which is used with   length :: (Peanoid i, Foldable t) => t x -> i;
20:17:23 <magicman> Or that may be aponoid. Hrm.
20:18:16 <elliott> zzo38: It should be class Peanoid x where { succP :: Maybe x -> x }.
20:18:17 <elliott> For symmetry.
20:18:22 <elliott> Just like
20:18:23 <elliott> :t unfoldr
20:18:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:18:33 <elliott> foldr should be (Maybe (a, b) -> b) -> [a] -> b.
20:18:47 <deech> Hi all, I'm interested in practical applications of dependent types. I've read "Why dependent types matter" and the compile-time-type-checking-of-array-length type examples and I was wondering someone could point me to any other sources.
20:19:08 <elliott> deech: #agda and #epigram might be able to help
20:19:30 <deech> elliott: Ah yes, good call. Sorry for the OT question.
20:19:45 <elliott> deech: oh, not accusing you of anything
20:19:49 <elliott> just suggesting additional resources
20:20:30 <Veinor> something i've always wondered with dependent types: how do you deal with the case where you don't know the length of the array until runtime?
20:21:16 <glguy_> The same way you do it in any other language
20:21:23 <elliott> Veinor: you just write code polymorphic in the length of the array
20:21:27 <elliott> in fact, you can do that kind of thing in haskell today
20:21:36 <elliott> let's say you have data Z; data S n
20:21:40 <elliott> and a class Nat for it
20:21:48 <Veinor> ah ok
20:21:51 <elliott> natify :: Integer -> (forall n. (Nat n) => Proxy n -> r) -> r
20:22:02 <elliott> natify 0 k = k (Proxy :: Proxy Z) etc.
20:22:46 <hpaste> gngdhr pasted “Indentation error” at http://hpaste.org/66849
20:23:38 <gngdhr> can someone please let me know where is the error in the above code. I am trying to understand how to indent the code and am  not successful :(
20:23:51 <deech> Veinor: My limited understanding is that along with the array you pass in a "proof object" that shows that you've checked the array length. My initial intuition is that it's like phantom types but much more powerful.
20:23:55 <Veinor> gngdhr: what does lcsLength evaluate to? you have two let bindings
20:24:09 <Veinor> but you have no expression that they're bound in
20:24:14 <elliott> deech: I'm not sure that makes sense :)
20:24:26 <zzo38> gngdur: If you want to, there is also non-layout mode in case you want to use your own indentation (or lack of it)
20:24:30 <gngdhr> Veinor: Thanks for the reply. I am trying out the code snippet mentioned here - http://stackoverflow.com/questions/10116466/list-of-lists-in-type-declaration-in-haskell
20:24:47 <elliott> you forgot the rest of the code
20:24:52 <Veinor> yeah
20:27:43 <gngdhr> zzo38: how can I use the non-layout mode? Is it as mentioned here - http://echo.rsmw.net/n00bfaq.html
20:28:09 <cwl> zzo38: what if I want to catch `error` just to show all the errors in an example
20:28:12 <cwl> https://gist.github.com/2364395
20:28:47 <gngdhr> Veinor: So, what you mean is that since the lcslength doesn't evaluate to a value, that is causing an issue?
20:29:09 <zzo38> gngdhr: Yes; although you can still use indentation with non-layout mode (and still should); it is just that you can use the indentation how you want instead of being forced to do it the way the compiler expects you to
20:29:38 <zzo38> You activate non-layout mode by using { ; } in your program
20:29:49 <elliott> gngdhr: I don't suggest using non-layout mode.
20:29:50 <augur> Philippa: i realized that part of the issue i was considering might be obviate by simply ruling it out of the structure of the input for external reasons
20:29:51 <gngdhr> zzo38: thank you. But in the current case, I am trying to understand what the indentation issue is
20:29:52 <elliott> It's not idiomatic.
20:29:53 <zzo38> (You need it in the module ... where declaration as well)
20:30:10 <elliott> gngdhr: You said you were trying out the code snippet.
20:30:13 <elliott> But you only hpasted part of it.
20:30:21 <elliott> You can't just chop bits off the code and expect it to still work :)
20:30:22 <augur> Philippa: or embraced, assuming a richer unstructured data that can give rise to structure in the right way without necessarily needing something special to be done
20:30:25 <gngdhr> elliott: sorry about that, pasting the complete thing
20:30:26 <zzo38> s/ma//
20:31:50 <zzo38> (Haskell even allows you to use layout and non-layout in the same file, but I advise against this. In a single file use only either layout or non-layout and do not mix them in one file)
20:32:02 <elliott> cwl: You may be interested in http://hackage.haskell.org/packages/archive/keys/2.1.3/doc/html/Data-Key.html#t:Indexable, http://hackage.haskell.org/packages/archive/keys/2.1.3/doc/html/Data-Key.html#t:Lookup
20:32:22 <cwl> elliott: thanks
20:32:26 <hpaste> gngdhr pasted “Indentation error” at http://hpaste.org/66850
20:32:46 <gngdhr> sorry, there is a duplicate line of lcslength
20:32:48 <gngdhr> removing it
20:33:25 <hpaste> gngdhr pasted “Indentation error” at http://hpaste.org/66851
20:33:44 <elliott> gngdhr: There's no "else if".
20:33:47 <elliott> Write if expressions like this:
20:33:48 <elliott> if expr
20:33:50 <elliott>   then whentrue
20:33:52 <elliott>   else whenfalse
20:34:01 <elliott> Write them like that consistently, and you won't run into problems with them.
20:34:04 <gngdhr> elliott: ok
20:34:46 <monochrom> the if-then-else there is not in a do-block. layout is rather lax there. no a problem cause
20:35:05 <elliott> Indeed, I was just recommending it on general principles.
20:35:10 <elliott> I'm sceptical of the newline and indentation after that let.
20:35:21 * monochrom doesn't like knee-jerk myths perpetuated about if-then-else
20:35:24 <zzo38> (I don't like if/then/else at all; but you can use it if you want)
20:35:40 * elliott wasn't attempting to spread myths, just attempting to help avoid future problems.
20:35:48 <Veinor> if/then/else can be useful sometimes
20:36:33 <zzo38> Veinor: I prefer    bool :: x -> x -> Bool -> x; bool x _ False = x; bool _ x True = x;
20:36:41 <gngdhr> elliott: will check that
20:36:51 <monochrom> there is no indentation error. there is a type error.
20:37:06 <gngdhr> actually, I found out the reason for the indentation error. Newbie mistake there. I had a let binding but no 'in
20:37:26 * monochrom insists on the scientific method. reproduce the experiment first. down with the opinionative method
20:37:34 <gngdhr> *no in and that was the cause of the indentation error - though I'd have preferred a better error message
20:37:43 <zzo38> (It allows better composition)
20:37:59 <zzo38> monochrom: Yes, the scientific method is better; but it cannot apply to everything
20:38:20 <zzo38> Science isn't perfect, but is the best we have
20:38:40 <gngdhr> monochrom: yes, you are right. Now it is a type error, which was what the OP from Stackoverflow wanted to find out. Now, I will check what the issue is
20:38:44 <monochrom> it bloody applies to programming. I am not talking about the mysteries of love.
20:39:05 <cwl> is hackage down?
20:39:11 <cwl> hackage.haskell.org
20:39:13 <Clint> no
20:39:16 <elliott> no
20:39:20 <zzo38> monochrom: Well, yes it does apply to programming; but sometimes the mathematical method applies better
20:39:26 <elliott> see http://www.downforeveryoneorjustme.com/
20:39:53 <cwl> http://www.downforeveryoneorjustme.com/ is down for me :(
20:40:32 <Clint> maybe your dns is broken
20:40:52 <zzo38> cwl: Are you able to connect to my computer? Or to sprunge?
20:41:46 <cwl> zzo38: how to connect to you computer?
20:42:11 <zzo38> cwl: zzo38computer.cjb.net ports 70, 80, and 194
20:42:32 <zzo38> To connect to sprunge:  http://sprunge.us/
20:42:54 <dented42> @type fmap
20:42:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:43:32 <cwl> zzo38: No, It must be caused by the GFW.
20:43:55 <zzo38> What is the GFW?
20:44:49 <monochrom> oh, China's firewall?
20:44:49 <cwl> zzo38: The Great Firewall of China
20:45:24 <zzo38> OK.
20:45:42 <zzo38> Are you unable to connect to my computer on any of those three port numbers, and also unable to connect to sprunge?
20:45:48 <tgeeky_> re: edwardk: 'hey ghc devs can you fix this thing that might or might not be a bug so we can break a huge pile of invariants in your compiler to put go faster stripes on something nobody uses? k thx'
20:45:58 <tgeeky_> edwardk: they got back to me. It's a no. Nope. No.
20:45:59 <cwl> zzo38: cannot ping your computer
20:46:06 <edwardk> tgeeky_: =)
20:46:26 <zzo38> cwl: That might be due to the router.
20:46:30 <edwardk> did they see the reflection code? =)
20:46:31 <iFire> At what point does faster stripes on your particular program worth it?
20:46:38 <iFire> be worth it*
20:47:01 <monochrom> I want faster strips :)
20:47:04 <cwl> zzo38: yup
20:47:22 <tgeeky_> edwardk: I don't think GHC devs can see reflections. Or maybe it's just their own reflections? No, that's vampires.
20:47:39 <elliott> tgeeky_: haha, you reported it?
20:47:45 <edwardk> tgeeky_: ah, that makes sense. i thought igloo was looking rather pale.
20:48:01 <Veinor> i forgot
20:48:06 <Veinor> did i paste my horrid default argument code in here
20:48:55 <tgeeky_> elliott: not yet. http://hackage.haskell.org/trac/ghc/ticket/5999.
20:48:56 <monochrom> breaking news: ghc devs are found to be vampires. haskell is unlikely to be a dead language, ever. just maybe a zombie language, that is, sustained by zombies
20:49:06 <augur> edwardk: hey you!
20:49:10 * edwardk hides.
20:49:16 <augur> edwardk: nah, just hey :)
20:49:18 <Veinor> http://hpaste.org/66831 ah, here it is
20:49:25 <elliott> tgeeky_: oh, not the same bug, you were just reusing the quote
20:49:25 <elliott> ok :P
20:49:38 <tgeeky_> elliott: what quote?
20:49:40 <tgeeky_> elliott: oh, yes.
20:49:40 <augur> edwardk: unless you want to talk very high level-y about some random things!
20:49:43 <elliott> <tgeeky_> re: edwardk: 'hey ghc devs can you fix this thing that might or might not be a bug so we can break a huge pile of invariants in your compiler to put go faster stripes on something nobody uses? k thx'
20:49:51 <tgeeky_> elliott: re: re: re: yes.
20:50:04 <edwardk> augur: nah i'm kind of in make code work mode ;)
20:50:11 <augur> edwardk: awesome
20:50:12 <augur> code is awesome
20:50:18 <tgeeky_> elliott: do note, that the bug in question produces an infinite lopp
20:50:21 <edwardk> especially when it works
20:50:23 <zzo38> (The address zzo38computer.cjb.net is correspond to the router, not to my computer; and the router redirects port 70, 80, 194, to my computer. So you cannot ping my computer)
20:50:27 <elliott> tgeeky_: FWD: Fwd: Re: Fwd: Most hilarious compiler bug report response ever !!!
20:50:43 <elliott> If you don't forward this to all your friends you will stub your toe within 10 days
20:51:34 <zzo38> What if not all of my friends have email?
20:51:35 <augur> edwardk: i still havent done anything with that tree stuff
20:51:37 <augur> :(
20:51:43 <tgeeky_> zzo38: dooooooomed
20:52:26 <zzo38> (I don't have email either, but I do have a UNIX account at FreeGeek and can use that for electronic mail)
20:52:38 <elliott> zzo38: Sometimes, we can't always avoid stubbing.
20:52:40 <elliott> That's just life.
20:52:48 <tgeeky_> *points and laughs* haha you're old
20:53:25 <zzo38> Old? Is that why you keep stubbing your toe within 10 days?
20:55:37 <zzo38> teeky_: Well, is that why...????
20:55:57 <elliott> tgeeky_: Can I call you teeky?
20:56:03 <tgeeky_> elliott: no
20:56:05 <zzo38> I made a mistake
20:56:05 <elliott> :(
20:56:39 <monochrom> I have a cunning plan. to avoid the stubbing of the toe, just renounce some or all friends, for example those without email addresses
20:57:18 <tgeeky_> zzo38: you're old, because you said you have a UNIX account, and you said "electronic mail"
20:57:33 <monochrom> although I am not sure what is stubbing the toe and whether it is worth avoiding
20:57:42 <tgeeky_> monochrom: it's worth avoiding
20:57:47 <elliott> monochrom: nope, it snapshots your friends before you know of the email
20:57:50 <zzo38> tgeeky_: Really? I am old just because of those things?
20:58:03 <tgeeky_> zzo38: just making a guess
20:58:35 <tgeeky_> zzo38: the weakest version of 'old' means, older than me, so if you're older than 26, then I might be right!
20:58:38 <dmwit> zzo38: No, those things because you are old.
20:58:58 <zzo38> dmwit: But that is not the only possible reason
20:58:59 * dmwit offers a silent prayer up to Bayes
20:59:09 <monochrom> hahaha
20:59:13 * tgeeky_ watches dmwit get struck by lightning
20:59:44 <tgeeky_> the angular momentum of all of those electrons are making him roll in his grave
21:00:08 <zzo38> Because I said I have a UNIX account? Do you not have a UNIX account? Do you not have the electronic mail on the UNIX account?
21:00:13 <monochrom> dmwit: say a prayer to Bayes for me too next time I say things like "the purpose of total languages is to ban more programs" XD
21:00:26 <dmwit> hehehe
21:01:44 <elliott> The purpose of partial languages is to crash
21:03:13 * hackagebot conduit 0.4.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.4.1 (MichaelSnoyman)
21:03:15 * hackagebot http-conduit 1.4.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1 (MichaelSnoyman)
21:03:50 <zzo38> When you are presented with two options, choose the third one.
21:03:51 <monochrom> the first web forum was created because a programmer needed a software project for learning php
21:10:23 <nyingen> @quote
21:10:24 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
21:14:45 <monochrom> haha
21:20:43 <shergill> lol
21:21:45 <nyingen> @quote
21:21:46 <lambdabot> bootslack says: Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them,
21:21:46 <lambdabot> cooked them and ate them.
21:22:08 <monochrom> yikes
21:22:24 <monochrom> unfortunately, haskell is no good for cooking people
21:23:21 <Kynes`> not with that attitude it isn't
21:24:43 <nyingen> @cook Kynes`
21:24:43 <lambdabot> Unknown command, try @list
21:25:07 <dmwit> @protontorpedo
21:25:07 <lambdabot> wil haskell make mroe more money?
21:47:19 <nyingen> @protontorpedo
21:47:19 <lambdabot> some dude called topmind says that oo is bs
21:47:22 <zzing> If I have function with a few where clauses is there a way to get ghc to tell me the individual types ?
21:48:21 <monochrom> no
21:49:05 <dmwit> Yes, actually.
21:49:28 <dmwit> Using the ghci debugger.
21:49:44 <dmwit> http://stackoverflow.com/questions/9987739/what-is-the-best-way-to-test-and-interact-with-inner-functions-defined-inside-a
21:49:44 <zzing> dmwit, how would that be done?
21:49:55 <glguy_> nyingen: if you tell GHC that the term has type (), for example, it will tell you you are wrong and what the real type was :)
21:50:38 <monochrom> darn, that's clever
21:52:06 <prabuinet> hi, i'm working on examples from book `programming in haskell`
21:52:13 <prabuinet> getting parse error on this : m * (n + 1) = m + (m * n)
21:52:22 <prabuinet> i'm using ghci
21:52:36 <dmwit> Use let.
21:52:46 <dmwit> Also, probably n+k patterns won't work.
21:53:05 <prabuinet> but it works fine in hugs
21:53:08 <dmwit> Not sure whether that got dropped from Haskell2010 or not, but it probably will at some point in the future even if it isn't now.
21:53:28 <dmwit> Hugs implements an older version of the Haskell spec.
21:53:43 <prabuinet> dmwit, ok
21:53:54 <prabuinet> dmwit, thanks
21:54:21 <zzing> sweet dmwit, thank you
21:54:22 <glguy_> {-# LANGUAGE NPlusKPatterns #-}
21:54:39 <byorgey> it did get dropped from H2010.
21:54:42 <zzo38> Yes I think n+k patterns are dropped from Haskell 2010
21:55:04 <lispy> Do we miss them? nope.
21:55:05 <zzing> laziness helps a lot in this code
21:55:06 <nyingen> it would be fun if they got reinstated
21:55:07 <Boxo> how can I choose the number of digits to show when turning a number into a string? ie. I want f where 'f 5 21' = "00021"
21:55:12 <nyingen> just for the flame wars on -cafe
21:55:17 <lispy> nyingen: heh
21:55:33 <lispy> Boxo: Text.printf might support that
21:55:57 <zzing> How did the Haskell 2010 process differ from the C++11 process? (if anyone knows)
21:56:42 <Elemir> What means `Haskell 2010 process'?
21:56:55 <lispy> zzing: I think the Haskell 2010 committee is a lot tighter (people know each other better) but probably also bigger (anyone can participate)
21:56:56 <zzing> Elemir, Well the process to go to a released haskell 2010 'standard'
21:57:03 <lispy> zzing: But, I don't know much about the C++ process, TBH
21:57:06 <Elemir> Ah
21:57:35 <zzing> I recall with the C++11 process, they do have a set of guiding principles, one of them required an actual implementation (which is why 'concepts' was dropped)
21:57:55 <monochrom> the committee is smaller. there are more profs and fewer company representatives. there is no ISO or ANSI obligation. Stroustrup is not on the committee.
21:57:58 <lispy> the Haskell' process has a similar guideline
21:58:20 <ion> We should get Stroustrup on the committee.
21:58:25 <monochrom> hehehe
21:58:31 <zzing> They also make sure they don't break anything :P
21:58:39 <lispy> zzing: note that, the next Haskell standard is already in progress. We just always refer to it as Haskell'
21:58:45 <lispy> "haskell-prime"
21:58:52 <zzing> I have heard of the prime
21:58:56 <ion> I wish they broke stuff. The more time passes the more difficult it will be to fix stuff.
21:58:59 <zzing> First time I heard of 2010
21:59:23 <zzing> ion, if they broke stuff, nobody would use it because they have their code bases to consider
22:01:06 <ion> zzing: They already broke working code with the Num typeclass change. Some changes i’d like to see are a bit larger but might as well get done with it.
22:01:49 <lispy> I'd like to see Num get refactored, and I'd like bool overloading like Numeric/String overloading
22:02:01 <lispy> That's my wishlist for Haskell' :)
22:02:25 <zzing> If I have something like // class Intersectable a b where  intersect :: a -> Ray b -> Maybe (Intersection b)   // where a is always going to be a type like Sphere b   or Triangle b but no other relationship between Sphere and Triangle exist, is there a way to reduce the type variables to just b?
22:02:45 <zzing> I want some Num operations for vector types :P
22:03:02 <dmwit> class Intersectable f where intersect :: f b -> Ray b -> Maybe (Intersection b) -- ?
22:03:18 <zzing> hmm, I can do that?
22:03:21 <dmwit> yes
22:03:45 <lispy> zzing: When I had a problem like this I used records
22:03:45 <zzing> thank you :P
22:04:21 <lispy> zzing: data Shape = { intersect :: Ray -> Maybe Intersection }
22:04:30 <zzing> After doing a class on C++11 and coming back to haskell, I find some of the things like typeclasses make much more sense
22:04:42 <lispy> so then you would say, intersect s r :: Maybe Intersection
22:04:56 <zzing> hmm, I think I want to limit what a shape is to a type class
22:05:26 <zzing> This code will likely be before eyes here sooner rather than later so I can learn everything I am doing badly :P
22:05:49 <lispy> zzing: okay, and I have a raytracer that does it with records, so we can compare
22:06:03 <zzing> lispy, although this is simply a ray caster really
22:06:10 <zzo38> There is only one intersection?
22:06:11 <zzing> I am converting code from C++11 that I did
22:06:21 <lispy> one issue you may run into is specializing it for special shapes
22:06:55 <zzing> zzo38, there will only be one intersection and it will be the closest
22:07:14 <zzo38> Well, yes; I suppose if you want more than one intersection you can make up a function to access all of them
22:07:45 <lispy> you can also compute the intersection beyond the first
22:07:50 <zzing> If I have a line such as          t1 = - db + sqrt(descriminant) / da   but / da must be done last, is there a good way to do it without another layer of brackets?
22:07:53 <lispy> Just take the coordinates of the first and find the next
22:08:01 <zzo38> lispy: Yes I know, that is what I was thinking of
22:08:23 <zzing> It was only in March that I really understood this stuff
22:09:19 <zzing> :t 4
22:09:20 <lambdabot> forall t. (Num t) => t
22:09:20 <zzing> :t $
22:09:21 <lambdabot> parse error on input `$'
22:09:28 <zzing> :t ($)
22:09:30 <lambdabot> forall a b. (a -> b) -> a -> b
22:09:35 <byorgey> zzing: no.  but note you don't need parens around descriminant.
22:09:44 <zzing> oh yes
22:10:06 <byorgey> (also, it's spelled "discriminant" =)
22:10:27 <zzing> heh, I spelled it wrong in my original code too
22:17:49 <zzing> I apparently have a thing for constructing infinite types tonight
22:24:19 <zzo38> I suppose you could have dimensional shapes too if you want to, by having the parameter of how many dimensions, for example (Maybe (Maybe (Maybe Zero))) for three
22:25:43 <zzo38> ($) is infix id although I have made a generalization as well as changing it to infixl
22:26:45 <zzing> Now I am running into a problem in my code; https://gist.github.com/90fbbe95db07695e2c6d  line 46. It compiles with ghc fine, but when I go to load and use the 'test' function, it says No instance for (Container Vector e0)
22:26:49 <zzing> I haven't seen this one before
22:27:35 <zzing> I have run intersect before with a Ray and a Sphere exatly as done here without issues
22:29:34 <zzing> I am curious why it says e0 instead of Double
22:30:17 <zzing> I don't know how to break down a definitino like Sphere (fromList [2.0,3.0,4.0]) 4.0  to see what it really thinks is inside it
22:31:16 <zzing> r = Ray (fromList [0, 0, 0]::Vector Double) (fromList [0, 0, 1.0]::Vector Double)  seems to fix it, but it is annoying
22:32:24 <byorgey> zzing: the problem is likely the fact that numeric literals such as 0 are polymorphic
22:32:43 <byorgey> so ghc does not know which type to pick for  fromList [0,0,0]
22:32:52 <dmwit> I was going to say the problem was that instance Intersectable (Sphere Double) (Ray Double) is too monomorphic.
22:33:12 <mjrosenb> you could theoretically write another type that is also a Real that is not an IEEE floating point double, and 0.0 would magically be one of those if you need it to be
22:33:14 <zzing> instance is commented out
22:33:21 <byorgey> oh, if that could be made more polymorphic that might help too.
22:33:24 <dmwit> Yes, I see that now.
22:33:37 <zzing> I was having trouble in the stuff below, so I was building it up slower
22:34:13 <dmwit> zzing: :t intersect ?
22:34:43 <zzing> dmwit, Should be something like intersect  :: (Floating e, Ord e, Product e, Container Vector e) =>     Sphere e -> Ray e -> e
22:34:52 <dmwit> Why not copy and paste from ghci?
22:35:00 <zzing> That is a copy and paste
22:35:18 <zzing> I am just saying should because I modified one definition, but it shouldn't have changed
22:36:00 <zzing> confirmed types
22:36:11 <dmwit> Anyway, what byorgey said is probably the reason.
22:36:14 <zzing> Why does it say 'e' this time, 'e0' other times, and other all sorts
22:36:26 <dmwit> What's in a name?
22:36:31 <byorgey> because it is just a variable it made up.
22:36:33 <zzing> dmwit, a choice I am sure
22:36:59 <zzing> Can this be simplified? (remove brackets some how): normal = scale (1/r) ((shortest point1 point2) `sub` c )
22:37:15 <dmwit> Yes, the brackets around shortest can be removed.
22:37:42 <zzing> How do I know when that can be done?
22:37:47 <dmwit> Also, by the way, you can probably write "r :: Ray Double; r = Ray (fromList [0,0,0]) (fromList [0,0,1])" rather than give two type signatures.
22:37:55 <lispy> function application binds tightest
22:38:01 <dmwit> zzing: Function application binds tighter than anything (except record syntax).
22:38:04 <zzo38> Please tell me what your idea of this type system I have idea of (for Ibtlfmm, not for Haskell; but similar). I will describe some of its features so that you can complain about it properly.
22:38:43 <zzo38> One thing is the kind (*(x) -> {x} -> *) meaning a type taking two parameters, the first is an ordinary type and the second is a value of that type in braces
22:38:45 <zzing> Does the operator $ apply to this kind of use to reduce brackets?
22:39:12 <lispy> zzing: BTW, you can make operators like (+) and (-) for your vectors.  for example ^+^ and <+>
22:39:19 <zzo38> (For example if the type having this kind is called X then the type (X Int8 {15}) is of kind *)
22:39:23 <zzing> lispy, I was considering it
22:39:40 <zzing> But I am using hmatrix right now, it has none, I was thinking about porting some of my own linear algebra library over here
22:40:29 <zzing> Does haskell have any 'metaprogramming' in the fashion that C++ templates have?
22:40:38 <zzo38> A more complicated example is (*(x) -> *(Class1 x y => y) -> {Succ y} -> *)
22:40:57 <traviscline> zzing: http://www.haskell.org/haskellwiki/Template_Haskell might be what you're looking for
22:41:43 <zzing> bookmarked
22:41:48 <zzing> Probably want to stay away right now
22:43:00 <zzing> What does the '~' mean in this? intersect  :: (Floating a, Ord a, Product a, Container Vector a,      RealOf a ~ a) =>     Sphere a -> Ray a -> Maybe (Intersection a)
22:43:16 <dmwit> zzing: It's a type equality assertion.
22:43:29 <zzing> What does that mean here?
22:43:30 <Boxo> Is there some stopIO think that would make do {print "lol"; stopIO; print "heh"} print only "lol"?
22:43:39 <dmwit> zzing: It means the two types RealOf a and a are equal.
22:44:00 <dmwit> (What else could a type equality assertion mean? =)
22:44:07 <zzing> Boxo, Probably the -- operator, and doesn't need the 'stopIO' :P
22:44:07 <ion> boxo: peek nullPtr
22:44:23 <zzo38> Hay! What is the password?
22:44:31 <ion> hunter2
22:44:41 <dmwit> Boxo: You can throw an exception, or call exitWith.
22:44:42 <zzing> dmwit, fair enough with context
22:44:45 <byorgey> Boxo: maybe something like  exitSuccess  from the  System.Exit  module?
22:45:10 <zzo38> What would you think about these type/kind system?
22:45:20 <Boxo> well, I'm trying to "break" a while loop
22:45:49 <ion> Hpaste your code.
22:46:09 <Boxo> ok...
22:46:11 <byorgey> Boxo: oh, in that case the only way would be to throw an exception and then catch it.  But there's probably a better way to do whatever you are really trying to do.
22:46:35 <zzo38> Boxo: You could use Either to break a loop I suppose
22:46:50 <zzo38> Other one is user-defined datakinds, such as:   kind List x = Nil | Cons x (List x);   makes a kind named List with the type Nil of that kind and Cons
22:47:57 <zzo38> (So, (List * -> List *) is a valid kind; (\_ -> Cons (IO String) Nil) is a valid type of that kind)
22:48:25 <zzo38> (So is (\x -> Cons Char (Cons Int x)))
22:49:00 <zzo38> O, and lambda types are allowed but are treated like type synonyms and have the same restrictions
22:49:44 <jetru> Hello. I'm doing this in main: liftM (either (\x -> putStrLn "Error!") (\x -> putStrLn "Done")) $ action args
22:50:00 <jetru> where action args is of type IO (Either StageNotFoundError ())
22:50:44 <jetru> but it doesn't do the printing. If I split it up into a  val <- action args and then pass it without a liftM, it works. What's going on?
22:51:34 <byorgey> jetru: do you know what the type of  liftM (either (\x -> putStrLn "Error!") (\x -> putStrLn "Done")) $ action args  is?
22:51:35 <zzo38> jetru: Perhaps use =<< instead of liftM
22:51:38 <ion> Look at the type of the whole expression. It looks like IO (IO something).
22:52:02 <zzing> Well, I have my thing that compiles and is a typeclass: https://gist.github.com/90fbbe95db07695e2c6d/a4930ade3cb51f42ecf18e5c55f4d31758afe460   But there are a few issues, namely saying a lot about the b parameter seems wrong to me. I could use any thoughts on this code as it is my first serious thing in a while.
22:52:14 <monochrom> right, you're doing the equivalent of main = return (putStrLn "hi")
22:52:20 <zzo38> IO (IO something) means you need join if you want the result action performed too; use >>= to combine fmap (same as liftM) with join.
22:53:12 <ion> The “inner” action is the print action but it never gets executed. Thus use =<< or >>=. Incidentally, f =<< m ≡ join (f <$> m)
22:53:13 <zzing> monochrom, if that is at me, the main program isn't my main thing yet, the support code is
22:53:34 <monochrom> it is not at you
22:54:00 <zzing> ;-)
22:55:05 <dmwit> zzing: You might consider writing something like "class AllOfThem a; instance (Floating a, Ord a, Product a, Container Vector a, RealOf a ~ a) => AllOfThem a; class Intersectable f where intersect :: AllOfThem a => f a -> Ray a -> Maybe (Intersection a)". You might consider not doing that, too.
22:55:06 <zzo38> jetru: Try like this:   action args >>= putStrLn . either (const "Error!") (const "Done")
22:56:04 <zzing> dmwit, I had to put that crap in there because it wouldn't compile without it, I don't want it there
22:56:10 <dmwit> zzing: (Just to make error messages and such a bit shorter.)
22:56:39 <dmwit> zzing: Oh, yes, I believe you need all those instances.
22:56:43 <zzing> I will put it in there for sanity
22:57:03 <zzo38> jetru: Notice that liftM is the same as fmap and (x >>= f) is same as (join (fmap f x)) so that will apply the right side of >>= to the result of action args (the Either StageNotFoundError () type) and then, it has to also be IO it will then join to perform the result action after the one that resulted in that one.
22:57:11 <dmwit> zzing: Also, you might like "guard".
22:57:18 <dmwit> > guard True :: Maybe ()
22:57:19 <lambdabot>   Just ()
22:57:24 <dmwit> > guard False :: Maybe ()
22:57:25 <lambdabot>   Nothing
22:57:40 <zzing> dmwit, where?
22:57:56 <dmwit> > let discriminant = -16 in guard discriminant >= 0 >> return (error "aaaaaack")
22:57:57 <lambdabot>   Couldn't match expected type `m a'
22:57:57 <lambdabot>         against inferred type `GHC.Bool....
22:57:59 <dmwit> blegh
22:58:01 <jetru> zzo38: ion: byorgey: Oh yes! Thanks! *slaps own forehead*
22:58:03 <dmwit> > let discriminant = -16 in guard (discriminant >= 0) >> return (error "aaaaaack")
22:58:04 <lambdabot>   No instance for (GHC.Show.Show (m b))
22:58:05 <lambdabot>    arising from a use of `M3468458276...
22:58:09 <pqmodn> in something like system f + type operators, how could the "sum" type constructor be defined? i'm looking for something analogous to Product = \a:*. \b:*. \f:*->*->*. f a b, i think
22:58:12 <dmwit> > let discriminant = -16 in guard (discriminant >= 0) >> return (error "aaaaaack") :: Maybe Int
22:58:13 <lambdabot>   Nothing
22:58:56 <zzo38> jetru: In addition the type (Either StageNotFoundError ()) isn't very good, so try something like (Maybe StageNotFoundError) in which you use    action args >>= putStrLn . bool "Done" "Error!" . isJust    (assuming the function "bool" is defined)
22:59:06 <zzing> What does this mean? Constraint is no smaller than the instance head
22:59:25 <dmwit> zzing: Yeah, that was the reason you might consider not doing it.
22:59:32 <dmwit> zzing: The wiki has a good page on UndecidableInstances.
22:59:36 <dmwit> ...probably
22:59:40 <zzing> Well, I am playing fast and loose with extensions
23:00:04 <jetru> zzo38: I'm using the error monad and runErrorT, so I need to use Either
23:00:08 <zzing> The version you are looking at uses 6 of them
23:00:32 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
23:00:33 <zzing> ok, I decided to leave it as you have it without the class just for this
23:00:55 <dmwit> The motivating example is exactly the situation you have. =P
23:01:02 <dmwit> But yeah, leaving that out is also perfectly sane.
23:01:05 <zzo38> jetru: OK
23:01:36 <zzo38> jetru: Yes, if you are using Either to make it stop with the StageNotFoundError, that can be the use
23:02:10 <zzing> dmwit, guard is a MonadPlus isn't it? Won't that be incompatible with my Maybe?
23:02:13 <zzing> :t guard
23:02:14 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:02:23 <zzo38> zzing: Maybe is MonadPlus
23:02:33 <dmwit> pqmodn: Your definition of product surprises me.
23:02:36 <zzo38> So you can use it with Maybe
23:02:57 <dmwit> pqmodn: I would have expected something like Product = \a:*. \b:*. \r:*. (a -> b -> r) -> r
23:03:01 <dmwit> (i.e. the Church encoding)
23:03:22 <zzo38> For example:    safeDivide x y = (x / y) <$ guard (y /= 0)
23:03:52 <dmwit> pqmodn: If you buy into that as an alternative, then Sum = \a:*. \b:*. \r:*. (a -> r) -> (b -> r) -> r
23:03:53 <zzo38> I have often used guard and <$ in similar purposes
23:03:56 <pqmodn> dmwit: hmm, can you explain the innermost body? is (->) a type constructor?
23:04:09 <dmwit> pqmodn: Yes, it's the function type constructor.
23:04:22 <zzing> @src (<$)
23:04:22 <lambdabot> (<$) = (<$>) . const
23:04:27 <zzing> ...
23:04:35 <dmwit> pqmodn: (a -> b -> r) -> r is the type of a function which takes a continuation and returns the result of running the continuation on the a and b stored in the product.
23:04:42 <zzing> ok, what does <$ do?
23:05:16 <zzing> is that safeDivide basically  x unless (condition)?
23:05:20 <ion> a <$ f = const a <$> f
23:05:30 <zzo38> zzing: For example, if you have the condition x but want the value to be something such as 1 instead of () then you can have   1 <$ guard x
23:05:42 <zzing> ok, let me check this out
23:05:59 <dmwit> zzo38: You might also like "ensure p x = guard (p x) >> return x"; I use this function all the time.
23:06:27 <ion> > let safeDivide x y = (x / y) <$ guard (y /= 0) in [ safeDivide 1 0, safeDivide 1 2 ] :: [Maybe Rational]
23:06:28 <lambdabot>   [Nothing,Just (1 % 2)]
23:06:28 <pqmodn> dmwit: that's what i intended, let me chew on that for a second...
23:06:48 <zzo38> dmwit: Yes I sometimes do but I write it    x <$ guard (p x)
23:06:54 <zzing> Where does <$ come from?
23:06:59 <dmwit> zzo38: I like that spelling.
23:07:01 <augur> whats a good place to look for theoretical CS papers?
23:07:03 <dmwit> zzing: Control.Applicative
23:07:12 <dmwit> augur: Google Scholar?
23:07:14 <ion> > let safeDivide x y = (x / y) <$ guard (y /= 0) in do a <- return 1; b <- return 2; c <- return 3 in (a `safeDivide` b) `safeDivide` c :: Maybe Rational
23:07:14 <lambdabot>   <no location info>:
23:07:15 <lambdabot>      The last statement in a 'do' construct must be an ...
23:07:20 <augur> dmwit: hmm
23:07:29 <augur> i mean maybe not even published stuff
23:07:31 <ion> > let safeDivide x y = (x / y) <$ guard (y /= 0) in do a <- return 1; b <- return 2; c <- return 3; (a `safeDivide` b) `safeDivide` c :: Maybe Rational
23:07:31 <augur> i guess arxiv
23:07:31 <lambdabot>   No instances for (GHC.Real.Fractional GHC.Integer.Type.Integer,
23:07:31 <lambdabot>            ...
23:07:45 <ion> Err. I’m too tired for this. :-P
23:09:02 <zzing> Updated my paste, https://gist.github.com/90fbbe95db07695e2c6d    now using             Intersection intersection theta <$ guard (discriminant >= 0)
23:09:28 <zzing> Anyway I can fix 'shortest' that uses (<) in an if?
23:09:56 <ion> > let safeDivide x y = (x / y) <$ guard (y /= 0) in do a <- return 1; b <- return 2; c <- return 3; a `safeDivide` b >>= (`safeDivide` c) :: Maybe Rational
23:09:56 <lambdabot>   Just (1 % 6)
23:11:58 <dmwit> zzing: Um, use min or max (whichever that is).
23:12:00 <zzo38> ensure p = (<$) <*> guard . p
23:12:03 <dmwit> min, I suppose
23:12:04 <augur> arxiv is pretty limited in what it will let you browse :(
23:12:42 <zzing> :t min
23:12:43 <lambdabot> forall a. (Ord a) => a -> a -> a
23:13:24 <zzing> dmwit, I should restate, that the return values are not what is being tested (I noticed a problem I had to change the code you would see)
23:14:23 <pqmodn> dmwit: ok, i understand your definition now. but what i don't see the relation to the value-level "pair = \a:A. \b:B. \r:(forall R. A->B->R). r a b". was my definiton of Product ill-defined?
23:15:06 <dmwit> pqmodn: Oh, maybe that's why I was surprised! Was your original definition of Product a value-level definition?
23:15:17 * dmwit scrolls up
23:15:40 <pqmodn> dmwit: no, but i started from a value-level definiton to attempt to construct the type-level def
23:15:40 <zzing> just defined an if' that looks cleaner
23:15:52 <dmwit> ah
23:16:31 <dmwit> I expect you've gotten the value-level thing wrong, too.
23:16:41 <dmwit> (sorry)
23:16:43 <pqmodn> haha
23:16:59 <zzo38> What is an if' that looks cleaner?
23:17:11 <pqmodn> please explain, i'm not surprised that i've misunderstood some crucial insight :)
23:17:23 <glguy_> if' True x _ = x; if' False _ x = x
23:17:34 <dmwit> Perhaps you meant something like pair = /\a:*. /\b:*. /\r:*. \a:A. \b:B. \k:(a -> b -> r). k a b
23:17:34 <zzing> @hoogle nan
23:17:35 <lambdabot> Data.Fixed type Nano = Fixed E9
23:17:35 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Nand :: LogicOp
23:17:35 <lambdabot> package nano-cryptr
23:17:39 <pqmodn> oh
23:17:45 <zzo38> glguy_: That works; I prefer:    bool x _ False = x; bool _ x True = x;
23:18:16 * hackagebot vty-ui 1.5 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.5 (JonathanDaugherty)
23:18:20 <pqmodn> dmwit: i mean "pair = \a:A. \b:B. \r: (A->B->R). r a b" is right, no?
23:18:43 <zzing> vty-ui sounds interesting
23:18:46 <dmwit> That part looks okay if you're willing to have your type arguments be implicit (as they are in Haskell).
23:18:56 <dmwit> pqmodn: Otherwise, A, B, and R aren't in scope.
23:19:08 <zzing> :t pi
23:19:09 <lambdabot> forall a. (Floating a) => a
23:19:11 <zzing> > pi
23:19:12 <lambdabot>   3.141592653589793
23:19:16 <pqmodn> dmwit: sorry, i meant for them to be type variables
23:19:24 <zzing> > tan pi
23:19:25 <lambdabot>   -1.2246467991473532e-16
23:19:38 <dmwit> pqmodn: It's also possible that you meant something like pair = /\a:*. /\b:*. \a:A. \b:B. /\r:*. \k:(a->b->r). k a b
23:19:47 <zzing> @src tan
23:19:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:20:10 <pqmodn> dmwit: ah, yes :)
23:20:23 <dmwit> argh, I'm mixing upper- and lower-case badly
23:20:27 <pqmodn> dmwit: well, /\A:* ... yeah
23:20:30 <dmwit> But hopefully you can see through my errors.
23:20:45 <zzing> > tan (pi/2)
23:20:46 <lambdabot>   1.633123935319537e16
23:21:08 <zzing> I cannot win
23:21:27 <dmwit> > 1/0
23:21:28 <lambdabot>   Infinity
23:21:39 <zzing> That isn't right either
23:21:48 <dmwit> > 1/0-1/0
23:21:49 <lambdabot>   NaN
23:22:03 <zzing> > (1/0 - 1/0) == (1/0 - 1/0)
23:22:04 <lambdabot>   False
23:22:07 <zzing> sweet
23:22:08 <zzing> that works
23:22:29 <zzo38> What is your opinion of the type system idea I wrote?
23:22:32 <dmwit> Oh, was that your question? Double implements the IEEE spec in all its horribleness.
23:22:57 <zzing> Well, why is tan pi/2 any value? it should be NaN
23:23:14 <zzing> Or +Inf / -Inf
23:23:41 <ion> Heh, 1/0 :: CReal seems to be ⊥.
23:23:46 <ion> > 1/0 :: CReal
23:23:49 <lambdabot>   mueval-core: Time limit exceeded
23:24:06 <ion> > tan (pi/2) :: CReal
23:24:10 <lambdabot>   mueval-core: Time limit exceeded
23:24:18 <zzing> What is CReal?
23:24:58 <ion> It computes the supported arithmetic operations exactly to the requested precision.
23:25:37 <dmwit> zzing: Well, it doesn't seem to be Haskell's fault; C also produces a large (non-infinite) number for tan(M_PI/2).
23:25:53 <zzing> > acos -1
23:25:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:25:54 <lambdabot>    arising from a use of `...
23:25:57 <zzing> > acos (-1)
23:25:58 <lambdabot>   3.141592653589793
23:26:17 <dmwit> It even seems to be the same large, non-infinite number.
23:26:28 <zzing> It probably is the thing doing it :P
23:27:24 <ion> > ((acos -1) -1) (-1)
23:27:24 <lambdabot>   1.1415926535897931
23:27:27 <pqmodn> dmwit: ok, after working through a correct definition of pair it makes sense. thanks
23:27:54 <zzing> Well, it has been a wonderful evening doing haskell again. Thank you all for your help, I shall tackle the triangle tomorrow
23:27:58 <dmwit> pqmodn: Great! Now, what have you come up with for Sum, inl, and inr?
23:28:16 <zzing> By the way, what library should I look to to produce images and save to disk?
23:28:16 * hackagebot accelerate 0.10.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.10.0.0 (ManuelChakravarty)
23:28:18 * hackagebot accelerate-examples 0.2.0.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.2.0.0 (ManuelChakravarty)
23:28:20 * hackagebot accelerate-examples 0.2.0.1 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.2.0.1 (ManuelChakravarty)
23:28:54 <dmwit> zzing: diagrams, cairo, sdl, gd, opengl depending on your knowledge and exactly what you mean by "produce images"
23:29:11 <dmwit> In roughly that order of preference, too, by coincidence. (Probably move opengl above gd.)
23:29:12 <zzing> dmwit, place pixels in an image and output it
23:29:17 <dmwit> Oh, ew.
23:29:37 <zzing> that is how my c++ raycaster does it, so I am looking to do a very similar thing
23:29:44 <dmwit> Then DevIL, JuicyPixels, or gd.
23:30:07 <zzing> ok, gd it is, my program already uses that
23:31:05 <zzing> dmwit, when my program reproduces what the c++ version does I will be happy to learn how to properly do it in the setting :P
23:31:49 <zzing> gd is likely to cause my eyes to bleed in another month if I don't change it later :P
23:43:34 <pqmodn> dmwit: at the type level, Sum = \a:*. \b:*. \r:*. (a -> r) -> (b -> r) -> r and the term level, InL = /\a:*. /\b:*. /\r:* \val:a. \left:(a -> r). \right:(b -> r). left val
23:44:23 <pqmodn> dmwit: is that right?
