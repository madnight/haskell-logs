00:07:30 <Peaker> yitz, ?
00:07:49 <elliott> xyzzy
00:07:52 <Peaker> anyone know of a good way to print same-line progress reports?
00:08:23 <Peaker> I'm currently doing it in a hacky way, by putStr ('\r' : str ++ replicate 20 ' ')  but there's some better way, probably?
00:12:56 <elliott> Peaker: something like http://stackoverflow.com/questions/8953636/simple-progress-indication-in-console/8953814#8953814 might work for you
00:14:01 <Peaker> thanks
00:14:42 <Peaker> prepending "\r\ESC[2K" seems to be the magic
00:17:45 <Peaker> doh hIsTerminalDevice apparently is GHC-only
00:18:21 <Peaker> probably don't want that in the cabal package
00:35:31 * timthelion cries.  Has just spent 30 minutes debugging the fact that he forgot to compile with -threaded...  Wonders if there is a way to mark an .hs file as "needing to be compiled with threaded".  Wonders why the hell ghc doesn't make any module importing Controll.Concurrent compile with -threaded by default.
00:36:20 <shachaf> Because concurrency is a perfectly useful thing to have on only one CPU?
00:36:25 <elliott> Control.Concurrent doesn't necessarily imply -threaded at all.
00:36:34 <elliott> Anyway, use Cabal and you won't have such build issues.
00:37:17 <elliott> (You'll have different build issues :))
00:37:23 <timthelion> The logic of a forkIO changes whithout the -threaded flag. Which is just plain wrong.  compiler flags shouldn't change the way your program behaves!
00:37:43 <shachaf> No, forkIO has the same guarantees with and without -threaded.
00:38:07 <timthelion> shachaf: not true, shall I send you my source code and you can see for yourself the divergent behavior?
00:38:25 <shachaf> If your source code is short I can look at it.
00:38:31 <shachaf> Better to @paste it for the whole channel, though.
00:38:42 <timthelion> It's not that short, about 10 files...
00:38:46 <timthelion> 2000LOC
00:39:00 <timthelion> But it hangs without -threaded, and works fine with it.
00:39:04 <bitonic> timthelion: btw, if you really want, you can put {-# OPTIONS_GHC -threaded #-} on top of your file. But you should really have a .cabal build if it's a big project
00:39:20 <shachaf> bitonic: No, that won't do what you want. -threaded is link-time, not compile-time.
00:39:23 <timthelion> bitonic: that's a nice thing to know, thank you, will do
00:39:28 <Peaker> timthelion, forkIO gives you non-determinism in either case, but non-determinism can behave differently due to innocuous factors such as "-threaded"
00:39:28 <bitonic> timthelion: concurrency is not deterministic no matter what. You're probably just being lucky
00:39:31 <bitonic> shachaf: ah, right
00:39:32 <Veinor> the more i use cabal-dev, the more i think virthualenv had the right idea
00:39:37 <elliott> <timthelion> But it hangs without -threaded, and works fine with it.
00:39:42 <elliott> That just means your code expects more than forkIO guarantees.
00:39:48 <elliott> You can exploit undefined behaviour in C, too.
00:39:57 <bitonic> timthelion: forget what I said, see shachaf
00:40:04 <shachaf> In particular, it means that your code has a bug in it. :-)
00:40:16 <elliott> Veinor: in what way is virtualhenv better than cabal-dev? just curious since I've avoided the former like the plague
00:40:22 <timthelion> shachaf: Nope.  My code works flawlessly with -threaded
00:40:32 <shachaf> timthelion: Your code still has a bug in it.
00:40:36 <elliott> timthelion: Your code has a bug in it
00:40:38 <elliott> if it works, it's by accident
00:40:40 <bitonic> timthelion: you have racy code somewhere, and running on multiple cores makes it harder to run into those races.
00:40:45 <elliott> similarly, gcc will compile plenty of undefined behaviour
00:40:46 <elliott> and it might even work
00:40:50 <shachaf> "my code works flawlessly without -O, but it crashes with -O. Compiler bug!"
00:40:50 <elliott> that does not stop the code being buggy
00:41:06 <shachaf> It might also have to do with the FFI or something.
00:41:59 <Veinor> elliott: the idea of 'you run activate, and ghc and ghci and cabal magically work in this new environment'
00:42:13 <Veinor> vs 'you have to prefix everything with cabal-dev'
00:42:24 <elliott> Veinor: well, with the new haskell-mode you can just pretend cabal-dev isn't there :)
00:42:35 <elliott> and get things loaded and built in your session etc.
00:42:52 <Veinor> elliott: yesod's development server requires some hackery to work with cabal-dev sandbox locations that aren't .
00:43:14 <timthelion> elliott: now that I think of it, I remember why I need -threaded.  The problem is, that I use gtk2hs, and postGUIAsync will fail without the -threaded flag.  Does this make MY code buggy somehow????
00:43:35 <Veinor> i like the way virtualenv does it in python: you activate a virtualenv, then use python and pip like normal
00:44:09 <elliott> timthelion: It might mean there's a bug in Gtk2Hs. Or in your code.
00:44:28 <elliott> Veinor: virtualenv probably doesn't contain stuff like https://github.com/Paczesiowa/hsenv/blob/master/src/MyMonad.hs#L31 :p
00:44:57 <elliott> anyway i don't really like the idea of a shell script changing the global meaning of ghc, cabal etc.
00:44:58 <bitonic> timthelion: does it say in the docs that postGUIAsync "fails" without -threaded?
00:45:08 <elliott> it's hidden, global state I'm likely to forget when switching terminals
00:45:10 <Veinor> elliott: you mean 'cabal-dev probably doesn't, i assume
00:45:16 <elliott> Veinor: nope, i meant virtualenv
00:45:21 <Veinor> oh
00:45:31 <timthelion> elliott: well I don't think it's a bug in either.  The reason is quite simple.  GTK runs in a system thread, the same system thread as the main thread of your haskell program.  It is not aware of haskell green threads, and thus NEEDS it's own thread.
00:45:32 <Veinor> also i have my terminal set up to display my virtualenv env in brackets
00:45:42 <timthelion> bitonic: it does somewhere.
00:46:05 <elliott> timthelion: forkOS exists.
00:46:25 <hamishmack> timthelion: Add something like this to the start of your single threaded gtk2hs app… timeoutAddFull (yield >> return True) priorityHigh 10
00:46:54 <timthelion> hamishmack: that doesn't work, and is a nasty hack...
00:46:57 <Veinor> elliott: i suspect this is the same as the whole functional vs mutable philosophy ;)
00:48:09 <timthelion> elliott: aha, that's very nice.  forkOS mainGUI...  Now it tells me I NEED -threaded! :D  Yay!
00:48:12 <timthelion> elliott: thank you
00:48:34 * timthelion is still convinced, that the problem, is in the gtk2hs documentation and not in his code.
00:49:32 <Veinor> also afaik there's no runghc in cabal-dev
00:50:36 <mysticc> @hoogle XMonad.Util
00:50:36 <lambdabot> package utility-ht
00:50:36 <timthelion> hamishmack: The tutorial that sugested the timeout is a bad one.  You SHOULD NOT follow it.  GTK apps SHOULD be done multithreaded, and with postGUIAsync.  Why in heavens name would you want to add an artificial latency???
00:50:36 <lambdabot> package UtilityTM
00:50:36 <lambdabot> package array-utils
00:50:55 <mysticc> @hoogle XMonad.Util.WorkspaceCompare
00:50:55 <lambdabot> No results found
00:52:53 <yitz> timthelion: a long time ago, there used to be bad interaction between multithreaded gtk and the haskell runtime. might be fixed by now though.
00:53:26 <timthelion> yitz: that bad intraction, is the fact that people don't know that they have to wrap all their gtk2hs code in postGUIAsync :)
00:54:11 <timthelion> yitz: without the postGUIAsync, gtk code succedes only about 30% of the time.
00:55:35 <timthelion> yitz: postGUIAsync passes your specific GTK code back to the single GTK thread.  GTK is not thread safe(and the authors are convinced that this is "correct" because "GTK is event based, not thread based") unfortunately.
00:55:48 <Peaker> hmm, maybe I'll just copy the cabal darcs into github. frustrating to have to go back to emailing patches like it's the 1990's
00:58:45 <yitz> Veinor, elliot: i happily use cabal-dev for everything. no problems, simple concept that allows me to totally understand what is happening at all times, no magic behind the scenes.
00:59:07 <yitz> only cost is occasional extra rebuilds of a bunch of packages, which doesn't bother me.
01:02:19 <hamishmack> timthelion: I would rather not, but Leksah seems to be unstable when used with -threaded, despite the use of postGUIAsync (fails in Gtk).  We may be missing some postGUIAsyncs, but I can't work out where.  If anyone knows of a good way to log Gtk calls and what thread they are made on I would love to know.
01:02:33 <yitz> Peaker: what's wrong with emailing a patch?
01:03:15 <quicksilver> I think the GTK authors are probably right, actually
01:03:22 <quicksilver> although the reason above sounds clumsy
01:03:43 <quicksilver> making a GUI library full threadsafe is a serious piece of engineering, the cost/benefit probably isn't worth it.
01:03:57 <quicksilver> (one like GTK, anyway)
01:04:04 <elliott> Peaker: have you tried "darcs send"?
01:04:14 <shachaf> darcs' end
01:04:19 <shachaf> Sounds ominous.
01:05:05 <yitz> quicksilver: does frp tend to be threadsafe? i assume yes.
01:05:25 <merijn> I remember seeing a proposal about implementing instance chains for GHC, but I can no longer find it? Anyone know anything about this?
01:07:19 <mysticc> merijn: Tell me if you find it ..
01:07:47 <Peaker> yitz, A) if it isn't accepted, you've lost your hard work by default.  B) you don't get an easy way to show people your work until it is accepted  C) it is more overhead and more difficult than a pull request
01:07:56 <Peaker> elliott, yes, it says it sent the email, but it apparently didn't
01:08:03 <Peaker> elliott, and it's archaic, in the age of github :P
01:08:15 <yitz> i hate the idea of github, and don't use it.
01:08:21 <Peaker> yitz, what?? why?
01:08:43 <Peaker> yitz, after using github, collaboration by email is so horribly inefficient
01:08:48 <merijn> mysticc: I figured looking at it and checking how hard it would be implement myself is more constructive than waiting and hoping someone else implements it. But I figured I'd first check whether someone else has already done some ground work
01:08:55 <yitz> while code on github is ostensibly open, to me github is a subtle way of achieve proprietary corporate lock-in
01:08:59 <quicksilver> yitz: FRP tends to be in haskell, and haskell tends to use immutable data, and that makes it much easier to be threadsafe.
01:09:13 <Peaker> yitz, how is it locked in?  There's no lock in whatsoever
01:09:20 <elliott> i agree that github is locked-in
01:09:23 <Peaker> yitz, "git clone" takes all your data out of github, pretty much
01:09:27 <elliott> but i'm not sure it matters much, because of the D in VCS
01:09:28 <quicksilver> yitz: it's a huge amount of work to convert an entire framework based on shared mutable state to be threadsafe.
01:09:32 <elliott> Peaker: except for all the pull requests, issues, and wikis
01:09:35 <merijn> Peaker: Well, not your issues
01:09:41 <elliott> the first of which you were just extensively extolling the virtues of
01:09:56 <Entroacceptor> elliott: I think virthualenv allows you to use different ghc versions. you need magic for that. :)
01:10:02 <Peaker> elliott, the wikis can also be taken out, probably.  Pull requests appear in the merge history.   If the issue tracker is lock-in (haven't used it) then don't use it
01:10:05 <elliott> Entroacceptor: not really useful imo
01:10:12 <yitz> Peaker: yes but github is a social environment. it trains people to use a workflow that is design to make it hard to leave.
01:10:15 <elliott> Peaker: pull requests hardly appear in the merge history.
01:10:19 <quicksilver> Peaker: pull requests you haven't accepted are not in the merge history.
01:10:22 <elliott> you don't get any of the details, or comments, or links, or whatever
01:10:24 <elliott> and what quicksilver said
01:10:27 <Entroacceptor> elliott: maybe not for you, now...
01:10:29 <yitz> Peaker: i don't like git itself, either.
01:10:35 <Peaker> quicksilver, why would you want to keep those when migrating?
01:10:41 <elliott> (in fact, pull requests are just a certain kind of issue. so it inherits all the problems)
01:10:48 <Peaker> yitz, I don't like it either, but I like it better than everything else :P
01:10:53 <elliott> oh, and github's forcing of a merge commit even when there's no merge to be done on pull requests is really annoying
01:10:59 <elliott> so the convenient interface does somethign i don't want
01:11:11 <elliott> (that commit being what you consider the pull request itself, even though it contains no info other than it was merged)
01:11:20 <Peaker> elliott, you can just fast-forward via the git interface, instead of using the web interface
01:11:21 <merijn> yitz: I hate git too, but I still use github with Mercurial
01:11:45 <yitz> merijn: yeah mercurial isn't as bad as git.
01:12:19 <Peaker> the git UI is annoying, but I think it is insignificant compared to other factors
01:12:22 <yitz> merijn: do you get full github functionality with hg?
01:12:27 <quicksilver> on the upside github has taught me quite a lot about the power of making forking and merge requests easy primitives.
01:12:45 <quicksilver> the power of making something so cheap/easy that people do it routinely is substantial
01:12:56 <Peaker> yitz, now that I wanted to make a patch for cabal, I wasted probably 10 times more time on overhead just telling them about the patch's existence than I would have to spend in github. And if I want to direct people to my patch, I have no easy way to do it :-(
01:13:01 <quicksilver> and it's just a SMOP to reimplement those ideas in an open hub.
01:13:27 <Peaker> yitz, edwardk moved to github, and said he got 20x more contributions
01:13:30 <merijn> yitz: The webinterface works as normal and I haven't found any problems with the hggit conversion interface when pushing/pulling/cloning. But I don't do very complicated things either, so...
01:13:44 <Peaker> everything else is just not important, compared to this. There's no excuse to remain in the email-patches-era
01:14:33 <yitz> merijn: i see bos himself has been using github. does he use it with hg? i wonder.
01:14:45 <elliott> Peaker: What was wrong with subscribing to the list and posting it there?
01:15:38 <merijn> elliott: I get enough e-mail as is, I don't want to always join every mailing list to submit one patch
01:15:45 <Peaker> elliott, I'll repeat: A) it's more effort, turning contributors down.  B) It means all I have to show for it until it accepted is a private email. I can't direct people to my fork, it isn't auto-hosted anywhere.  C) If it is rejected, I have to put in even MORE work if I want the work to be available to anyone.    All these combine to turning off contributors from doing contributions in the first place
01:16:21 <Peaker> "Why should I put in hours to fix this? Then I'll have to spend hours more to even get a chance at this work seeing the light of day. Nah, let's go shopping"
01:17:08 <elliott> Peaker: no, I didn't meant "what's your general objection"
01:17:13 <elliott> I meant "what went wrong with that"
01:17:18 <elliott> *mean
01:17:27 <Peaker> elliott, I did subscribe to the mailing list, and send the patch email, and get very frustrated
01:17:41 <Peaker> first I tried "darcs send", it send it sent an email, but it probably didn't
01:17:51 <Peaker> then I tried sending an email manually, it was auto-rejected (I didn't know I had to subscribe first)
01:18:07 <Peaker> then I subscribed and sent another mail, and now I'm stuck with another subscription in my mailbox.
01:18:14 <shachaf> Peaker: I never used "darcs send" to send emails back when I was submitting darcs patches.
01:18:20 <shachaf> I just generated a .dpatch file and sent that.
01:18:40 <shachaf> I guess that's what you did too.
01:18:44 <Peaker> I learned about "darcs send -o" but the UI/docs were confusing (unlike what people say about darcs) about whether it will also send an email or not
01:18:52 <Peaker> made a bundle file with that, ya
01:19:12 <elliott> Peaker: I believe you can subscribe to mailman lists without receiving mail.
01:19:20 <Peaker> elliott, how?
01:19:59 <Peaker> elliott, do you disagree that these projects should move to open hubs, instead of the frustrating process for contributors they currently have?
01:20:00 * hackagebot http-conduit 1.4.1.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.1 (MichaelSnoyman)
01:21:12 <quicksilver> merijn: that was a straw man.
01:21:20 * elliott likes convenience, but is wary of moving everything to GitHub wholesale, and doesn't believe the existing process is that frustrating.
01:21:45 <quicksilver> merijn: you don't have to receive email from a mailing list to subscribe to it. (for the most popular mailing list managers that is)
01:22:03 <merijn> quicksilver: Maybe, I'm just lazy and I can't be arsed
01:22:22 <merijn> And that's really my only objection, but it is enough of an objection for me
01:22:51 <merijn> There better be some major incentive for me to invest the time
01:23:01 <quicksilver> I don't disagree that making things easy is good, and github makes things easy.
01:23:25 <quicksilver> however I do wonder how many people who are too lazy to uncheck one box in the mailing list software will contribute large amounts of code.
01:23:59 <merijn> I'm not too lazy to uncheck the box, I'm to lazy to even go to the mailing list site and enter my info :p
01:23:59 <Veinor> quicksilver: you'd be surprised
01:24:05 <Veinor> also... yeah, what merijn said
01:24:16 <Peaker> elliott, I think it is an empiric fact now, that when projects switch from email to github, they get far more contributions.
01:24:26 <Peaker> I'm not sure why anything else matters here...
01:24:26 <quicksilver> I'm sure that's true.
01:25:02 <quicksilver> Veinor: perhaps I would be :)
01:25:20 <Peaker> quicksilver, I have lots of patience for code issues and fighting cabal, ghc, etc. I have much much less patience figuring out how I get to email a patch
01:25:38 <Peaker> I suspect there are many who are the same
01:26:13 <quicksilver> sure. standard ways of doing things are nice; standard, *efficient* ways of doing things are even nicer
01:26:21 <quicksilver> you don't have to work it out once per project and it's quick and easy.
01:26:46 <Veinor> that's an argument in favor of github, isn't it?
01:26:50 <quicksilver> it is, yes.
01:27:12 <Peaker> also, the extra difficulty of sending the patch is annoying but IMO the major issue is the lack of a hosted fork. It means there's a good chance all the work put in will be thrown away. Which is a big reason not to start the work at all
01:27:24 <quicksilver> It doesn't invalidate concerns about putting your workflow inside a proprietary system, though. That's just two things that people have to weigh up.
01:27:59 <Peaker> as long as github is making the data easily accessible (and you can avoid the parts that aren't easily accessible), I don't think we should care
01:28:15 <Peaker> Or at least, we should care that Haskell projects can improve at a much more rapid rate far far more than we should care about that
01:28:22 <quicksilver> Peaker: aren't there systems which let you automatically fork someone else's publically available repo? even converting it to git in the process if you want?
01:28:34 <womb> > let x = x*x in x 6
01:28:35 <lambdabot>   *Exception: stack overflow
01:28:45 <womb> >7*7
01:28:46 <Peaker> Don't know of any.. but now I'm going to upload "cabal" to github so I can host my changes
01:28:52 <Peaker> and it's taking ages, because darcs is so slow.. :(
01:29:05 <merijn> womb: x doesn't take any arguments in that line
01:29:10 <Peaker> (still darcs getting...)
01:29:35 <quicksilver> Peaker: http://vmiklos.github.com/darcs-fast-export/ , I think.
01:30:04 <Tinned_Tuna> The office is leaking! Can I out Haskell the water? No.
01:31:38 <elliott> Peaker: http://hackage.haskell.org/package/darcs-fastconvert
01:32:22 <Peaker> thanks.  I'll upload just the latest snapshot though, I think
01:32:58 <merijn> hmm
01:33:52 <merijn> Anyone have any good naming convention for record syntax? I have a location field, but using that prevents me using the same name anywhere else, which is a bit annoying...
01:34:12 <merijn> And putting "get" in front has a bit of Java taste and looks weird when updating...
01:34:24 <osfameron> ah, naming conventions for variables!  such a good old-fashioned BASIC design pattern
01:34:41 * hs_nab is blown away by list comprehensions
01:34:46 <quicksilver> merijn: I use fooLocation or _fooLocation where foo is the name of the record type or some abbreviation of such.
01:35:18 <quicksilver> merijn: and then I actually use lenses in practice anyway. And if I really want to overload the field names I set up a typeclass for it.
01:35:19 <merijn> hs_nab: I used to be too (mostly when I was writing python), now I find that I almost never use them
01:35:31 <merijn> Aside from the trivial [1..n] format
01:35:38 <hs_nab> merijn thats a pity.
01:36:21 <Peaker> quicksilver, do lenses let you update a polymorphic record? e.g: data Record a = Record { x :: a }  ;  modify show (Record 5) :: Record String ?
01:36:39 <Peaker> oops, modify lensForX show (Record 5) :: Record String
01:36:59 <elliott> no
01:37:09 <elliott> merijn: [1..n] is not a comprehension
01:37:12 <merijn> hs_nab: Mostly I use functions like filter/takeWhile/etc. instead
01:37:40 <merijn> elliott: No? What is it, then?
01:38:13 <hs_nab> merijn Haha, i used filter once in one of the tutorials, i feel so advanced. (No i am not)
01:38:57 <hs_nab> is there something like a struct in Haskell?
01:39:28 <merijn> hs_nab: There is record syntax, which is kinda similar (or at least, usually what people want when asking for structs)
01:39:47 <hs_nab> merijn yepp, records will do fine.
01:39:49 <elliott> merijn: A range, or something, I forget the exact name.
01:39:55 <elliott> A list comprehension has a | in it.
01:40:06 <elliott> [blah | 1..n] and [1..n | blah] aren't valid; it's a totally different form.
01:40:28 <merijn> hs_nab: I dunno which tutorial you are reading, but it should be covered somewhere in the usual data chapter
01:40:38 <quicksilver> Peaker: typical lenses are type-restricted in a way that makes that impossible.
01:40:58 <quicksilver> Peaker: that's normally considered a feature (makes type inference behave better) but it's certainly not an essential feature.
01:41:17 <hs_nab> merijn Maybe I wasnt paying enough attention, it was 2 AM yesterday
01:41:20 <hs_nab> =)
01:41:23 <quicksilver> Peaker: you certainly could define notions of heterogenous lens or polymorphic lense I think.
01:41:37 <Peaker> quicksilver, I think it gets complicated with multiple type variables on your record
01:41:44 <quicksilver> Peaker: yes, it would.
01:41:44 <merijn> hs_nab: Learn You a Haskell seems to cover them in chapter 8, for example
01:42:04 <quicksilver> Peaker: I can't say I have had to face that problem in practice, but it sounds like something I could solve with a bit of programming :) it's an interesting point though.
01:42:09 <quicksilver> I wonder if edwardk has thought of it.
01:42:29 <Peaker> I like https://github.com/Peaker/bottle/blob/master/bottlelib/Data/AtFieldTH.hs which gives me the modifier/setter.. The getter I already have from the field itself.  I miss the grouping of the setter/getter together, but usually I don't need it
01:42:43 <hs_nab> merijn thats where i stopped :D
01:42:46 <elliott> That kinda breaks if you have another field mentioning "a".
01:42:47 <hs_nab> exactly
01:42:52 * elliott thinks it's too much of an edge-case to care about supporting.
01:43:20 <quicksilver> Peaker: I like the ability to compose them to get multi-level ones
01:43:25 <Peaker> elliott, for me it was a common case.. the edge case is needing to compose the getter/setter together.. I usually just need to compose setters or compose getters
01:43:37 <merijn> hs_nab: Record syntax is still immutable and requires copying, just like all other data. But it allows you to name field and simplifies updating just a single field
01:43:37 <quicksilver> Peaker: but I can see that what you have is useful too
01:43:39 <Peaker> quicksilver, well, you can still compose getters/setters separately..
01:43:42 <quicksilver> sure.
01:44:08 <hs_nab> merijn i will look into it
01:45:45 <Peaker> it would be nice if there was a sophisticated record system that could allow an intermediate type for:  data Rec a = Rec { x, y :: a }     atX show . atY show   (intermediate record with different types for x and y)
01:46:56 <merijn> Is there something similar to "(a -> Bool) -> m a -> m a" or "(a -> Bool) -> m a -> m ()"? Hoogle isn't turning up anything, but I remember a similar combinator...
01:47:34 <MasseR> merijn: That looks a bit like when/unless?
01:47:36 <quicksilver> when (p x) (act x)
01:47:45 <quicksilver> a.k.a liftM2 when p act
01:47:52 <quicksilver> erm no
01:47:55 <quicksilver> completely wrong :)
01:48:02 <merijn> quicksilver: I want whileM or something
01:48:10 <merijn> i.e. repeat m a until false
01:48:16 <quicksilver> there are a bunch of variations in Control.Monad.Loops
01:48:17 <fmap> :t mfilter
01:48:18 <lambdabot> Not in scope: `mfilter'
01:48:34 <fmap> oh
01:48:40 <quicksilver> a detailed analysis showed that there are 581 natural variants of whileM and untilM for haskell
01:48:49 <quicksilver> Control.Monad.Loops never has the exact one you wanted.
01:49:27 <merijn> Yeah, I checked Monad.Loops but I didn't see quite what I wanted
01:49:53 <merijn> There's whileM, but that expects m Bool
01:50:18 <merijn> oh wait
01:50:21 <merijn> I overlooked one!
01:50:32 <merijn> :t iterateUntil
01:50:33 <lambdabot> Not in scope: `iterateUntil'
01:50:54 <merijn> iterateUntil :: Monad m => (a -> Bool) -> m a -> m a
01:50:57 <merijn> Close enough
01:51:30 <elliott> quicksilver: 581, eh?
01:57:33 <hpaste_> mbuf pasted “unexpected ';'” at http://hpaste.org/67135
01:57:59 <mbuf> yitz: if you can have a look at ^^
02:01:46 <quicksilver> mbuf: erm, you are calling 'parseCSVFromFile'
02:01:53 <quicksilver> mbuf: which, presumably, is a method from Text.CSV
02:02:02 <quicksilver> mbuf: you're not calling your own 'csvFile' function at all.
02:02:15 <quicksilver> the clue was when it said expecting ","
02:02:18 <quicksilver> your parser could never say that
02:02:26 <quicksilver> your parser never expects ","
02:02:38 <osfameron> NOBODY EXPECTS THE SPANI... oh
02:02:42 <mbuf> quicksilver: yes, I had used csvFile earlier, modified it to use parseCSVFromFile
02:04:00 <quicksilver> mbuf: OK. So what would you like us to do?
02:04:14 <quicksilver> mbuf: you have pasted some code for a function all 'csvFile', which are you not using
02:04:18 <quicksilver> what shall we do?
02:04:29 <hpaste_> mbuf pasted “Using cvsData” at http://hpaste.org/67136
02:04:46 <mbuf> quicksilver: I had used the above earlier, and it works for string input
02:05:09 <quicksilver> mbuf: ok and what is the problem?
02:05:17 <mbuf> quicksilver: just want to read csv file that has quoted strings like "a";"b";"c"
02:05:32 <quicksilver> mbuf: yes, your code looks like it is tryign to do that
02:05:34 <mbuf> quicksilver: and be able to convert use the data
02:05:37 <quicksilver> mbuf: what happens when you run it?
02:06:21 <quicksilver> (that's not CSV though, clearly! ;)
02:06:30 <mbuf> quicksilver: ohh!
02:06:40 <mbuf> quicksilver: so I should build a custom parser?
02:06:47 <quicksilver> you have built a custom parser
02:06:49 <quicksilver> you've written it
02:06:52 <quicksilver> it's in that paste
02:07:00 <quicksilver> however you refuse to tell me what happens when you run it
02:07:03 <quicksilver> so I can't help you fix it
02:07:08 <quicksilver> or even see if it's broken.
02:07:08 <mbuf> quicksilver: run which hpaste?
02:07:15 <quicksilver> !!!!
02:07:31 <quicksilver> you have written a parser call "csvFile"
02:07:35 <quicksilver> does it work?
02:07:37 <mbuf> quicksilver: I have pasted the error in it http://hpaste.org/67135
02:07:50 <quicksilver> mbuf: no, you haven't.
02:08:04 <quicksilver> mbuf: that is the error from running Text.CSV.parseCSVFromFile
02:08:06 <merijn> haskell must be the only language in which people can implement a parser and not even realise it...
02:08:13 <quicksilver> it is not an error from running "csvFile"
02:08:20 <mbuf> merijn: I didn't implement it; just took it from RWH
02:09:19 <mbuf> quicksilver: okay; but parseCSVFromFile expects ',', and hence it shows the error
02:09:41 <mbuf> quicksilver: how can I convert http://hpaste.org/67135 to accept "a";"b";"" syntax?
02:10:05 <quicksilver> mbuf: try actually using 'csvFile'
02:10:13 <quicksilver> and not 'parseCSVFromFile'
02:12:51 <merijn> > maybe -1 (-1) Nothing
02:12:52 <lambdabot>   Overlapping instances for GHC.Show.Show
02:12:52 <lambdabot>                              (b -> ...
02:13:48 <merijn> Is there a nicer way to write ((-) 1)?
02:13:59 <shachaf> (1-)?
02:14:01 <Botje> subtract 1
02:14:08 <shachaf> Botje: That's (flip (-) 1)
02:14:09 <Botje> oh wait, nevermind :)
02:14:20 <merijn> Oh wait
02:14:28 <merijn> See, I even screwed up my example
02:14:41 <merijn> (flip (-) 1) was what I wanted
02:15:03 <shachaf> (subtract 1)
02:15:09 <shachaf> (-1+)
02:34:49 <mbuf> quicksilver: okay; thanks
02:37:47 <merijn> "foo . return $ x" or "foo . Just $ x"?
02:38:08 <quicksilver> I tend to use Just when the type is concrete anyway
02:38:10 <bitonic> merijn: do what's more legible to you
02:38:26 <bitonic> (assuming you don't need a more general type)
02:38:28 <quicksilver> that is, prefer the monomorphic version when the code is actually monomorphic, gives a bit more clue to the reader
02:38:53 <bitonic> yeah I usually prefer Just too
02:39:21 <elliott> quicksilver: even in do blocks?
02:39:25 <elliott> e.g. [x] instead of return x
02:40:18 <merijn> @pl \m -> Just $ maybe (-1) (subtract 1) m
02:40:19 <lambdabot> Just . maybe -1 (subtract 1)
02:40:25 <quicksilver> good question, elliott :)
02:40:40 <quicksilver> in do blocks I probably use return because it matches "do" in my mental model
02:40:45 <quicksilver> I agree that's inconsistent.
02:41:22 <elliott> I'm happy for pure/return in monomorphic situations because it sure beats (:[])
02:41:31 <c_wraith> nothing beats robot monkey!
02:41:48 <merijn> bitonic: Personally I don't have any real legibility preference and it's ugly anyway, since I can't really figure out a nice way to write this :p
02:42:09 <bitonic> uh, pl doesn't know about the unary '-'
02:42:16 <merijn> hmmm
02:42:19 <bitonic> merijn: mah, I don't think 'foo . Just $ x' is ugly :P
02:42:42 <quicksilver> I find (:[]) more attractive than return
02:42:53 <bitonic> I prefer return in that case
02:43:09 <elliott> "I find (:[]) more attractive than" is an excerpt which cannot become a true statement no matter what you follow it with.
02:43:22 <merijn> bitonic out of context, maybe. But inside a helper function indented a few levels the code because a bit ugly
02:43:45 <quicksilver> elliott: humans in having different opinions shocker.
02:43:52 <hpaste_> merijn pasted “loop” at http://hpaste.org/67137
02:44:20 <merijn> Code seems to march to the right to much
02:44:25 <bitonic> merijn: you can take the 'loop' out of the case
02:44:27 <hpaste_> t7 pasted “C with system f... ?” at http://hpaste.org/67138
02:44:36 <bitonic> merijn: I think :P
02:44:40 <merijn> bitonic: How? I tried
02:44:42 <bitonic> (haven't looked at it closely)
02:45:04 <t7> what do ya think guiz ^
02:45:23 <bitonic> merijn: ah right, the last case messes things up
02:45:36 <bitonic> but the first two are painfully similar :P
02:45:39 <t7> i forget to set node value :3
02:45:43 <bitonic> anyways it's not a tragedy imho
02:46:04 <merijn> bitonic: But...but...ugly :(
02:46:29 <adamt> Hello people. Is it possible to install the equivalent of the haskell platform with cabal?
02:46:31 <quicksilver> merijn: if you don't like it marching so far to the right, call "loop" foo_aux or foo' and make it top-level.
02:46:41 <merijn> I wonder if replacing the counter with an IORef would make everything go away?
02:46:48 <merijn> I'm stuck in IO anyway
02:46:53 <merijn> I'll try that after lunch
02:47:00 <quicksilver> merijn: also line up that case on the -> signs will make it more readable
02:47:08 <bitonic> merijn: no don't do that.
02:47:23 <elliott> adamt: no
02:48:10 <quicksilver> merijn: and you can factor out that arithmetic with "let mm = fromMaybe 0 m"
02:48:13 <quicksilver> :t fromMaybe
02:48:14 <lambdabot> forall a. a -> Maybe a -> a
02:48:21 <Peaker> We call (:[]) the monkey operator
02:48:26 <quicksilver> merijn: because you treat nothing as 0 in both cases.
02:48:37 <adamt> elliott: but everything in the platform package can be installed (one-by-one) with cabal?
02:48:38 <Peaker> shorter and more informative than return
02:48:58 <quicksilver> merijn: then it's (loop . Just $ mm-1) and (loop . Just $ mm+i)
02:49:27 <elliott> adamt: sure. but it's easiest to just install stuff as you need it.
02:49:41 <elliott> no need for one-by-one technically, you can say "cabal install a b c d ..."
02:50:16 <adamt> Oh okay. I just want to play with yesod, so cabal install yesod should give me everything i need to begin with i suppose.
02:50:31 <Peaker> btw, if anyone is interested, you can git clone and install https://github.com/Peaker/bytestring-progress  and   https://github.com/Peaker/cabal    to get faster "cabal update" with progress reports
02:51:13 <adamt> elliott: Thank you for your help, much appreciated.
02:51:31 <elliott> np
02:51:35 <elliott> adamt: try cabal install yesod-platform instead?
02:51:39 <elliott> I think it helps solve dependency problems
02:51:43 <elliott> which are rampant with cabal
02:52:00 <adamt> It installed fine already (or so it seems), i just wanted to verify. :)
02:52:07 <elliott> ah, ok
02:52:43 <adamt> One (and a half) question more, i stumpled across "<$>" and "<*>" when looking at yesod, but google wasn't really helpful in telling me what they were. Do they have more search-friendly trivial names?
02:53:18 <bitonic> adamt: hoogle works with operators
02:53:23 <bitonic> @hoogle (<$>)
02:53:23 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
02:53:24 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:53:39 <bitonic> @hoogle (<*>)
02:53:39 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
02:54:08 <hpaste_> timthelion pasted “is there a good way to replace this with some kind of a guard?” at http://hpaste.org/67139
02:54:12 <timthelion> I ask...
02:54:15 <adamt> Oh that's nice. So if i go look up eg. Data.Functor i should be able to find something about <$>, etc.
02:54:40 <bitonic> adamt: well the website (haskell.org/hoogle) includes link as well
02:55:06 <womb> :t (+)
02:55:07 <lambdabot> forall a. (Num a) => a -> a -> a
02:55:32 <rastapastanon> Hi all. Is the wiki-like software running haskell.org/haskellwiki written in Haskell and is it FOSS?
02:55:46 <adamt> bitonic: Oh, it's not just a bot. Thank you for the help, really is much appreciated.
02:56:05 <bitonic> adamt: no problem
02:56:22 <quicksilver> rastapastanon: it's mediawiki I think.
02:56:24 <bitonic> rastapastanon: iirc it's mediawiki
02:56:27 <bitonic> PHP!
02:56:44 <bitonic> some people are not happy about that, but it works decently in the end.
02:56:57 <quicksilver> writing a decent wiki software is surprisingly hard
02:57:00 <rastapastanon> Oh, that's a disappointment. Thanks anyway!
02:57:28 <bitonic> quicksilver: is it? aren't wikis a degenerate form of dvcs?
02:57:50 <quicksilver> that's certainly gitit's view
02:58:01 <quicksilver> http://hackage.haskell.org/package/gitit
02:58:05 <bitonic> yeah
02:58:13 <bitonic> I guess the hard work is in the details
02:58:15 <quicksilver> however I think the hard bits are the boring user interface parts
02:58:24 <quicksilver> and choosing a good mark{up/down} language
02:58:54 <bitonic> well the latter shouldn't be hard
02:59:25 <quicksilver> OK, I will rephrase my initial remark in the light of your observations.
02:59:34 <quicksilver> writing a decent wiki software is a surprisingly large amount of work
02:59:49 <quicksilver> much of it being easy or trivial notwithstanding :)
03:00:07 <bitonic> eheh, ok. but that's true for most user-oriented applications. I was wondering if there was something inherently hard about wikis
03:00:43 <quicksilver> http://gitit.net/Slide%20Show%20Demo is cool though
03:01:05 <adamt> There is: Making the wiki-application aware of the content being added, and being able to determine whether edits will increase or decrease the value of the article.
03:01:47 <adamt> After that is done, it should be a small step to make it able to improve articles automatically.
03:05:10 <bitonic> adamt: wait, you're arguing that the software should asses the quality of the edits automatically?
03:07:08 <bitonic> that would be neat ehe
03:07:20 <bitonic> a nice machine learning exercise
03:10:16 <adamt> bitonic: Yeah. And as a side-effect you would eliminate all the bad spammers. So instead of writing articles, you just need contributors to write fitness-functions.
03:10:37 <adamt> And then you have a recursive problems, since you need to verify that a fitness function can only be improved ^^
03:10:49 <bitonic> adamt: well, you still need content :P
03:11:27 <adamt> No no, because the content would be generated by the software based on the fitness-functions. Anyways!
03:11:42 <adamt> Is there any good reason for cabal not being able to search for packages?
03:11:46 <bitonic> adamt: a fitness function doesn't give you content sadly
03:12:02 <dcoutts> adamt: what kind of search?
03:12:39 <adamt> like, cabal search happy would say "hey presto, here's packages named *happy*" :)
03:12:54 <elliott> adamt: "cabal list foo"?
03:12:55 <dcoutts> adamt: like "cabal list happy" ? :-)
03:13:00 <adamt> Oho. :)
03:13:19 <dcoutts> yes perhaps it should have been named search or find
03:13:21 <elliott> btw, how come the "recent package updates" on http://www.haskell.org/haskellwiki/Haskell are always really old
03:13:57 <adamt> i just read "List packages <stop>" and moved on. But thanks. I should stop rambling now.
03:14:24 <elliott> http://www.haskell.org/haskellwiki/Haskell oh, it's manually updated, hahaha
04:00:13 * hackagebot warp-tls 1.2.0.2 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.0.2 (MichaelSnoyman)
04:01:45 <womb> >7*7
04:01:52 <womb> > 7*7
04:01:52 <lambdabot>   49
04:02:12 <oddraisent> > 2*2
04:02:12 <lambdabot>   4
04:02:16 <oddraisent> GREAT!
04:02:22 <elliott> > 2
04:02:23 <lambdabot>   2
04:02:45 <elliott> > 2 − 2
04:02:46 <lambdabot>   4
04:03:07 <mekeor> elliott: what character is that?
04:03:16 <elliott> MINUS SIGN
04:03:23 <elliott> U+2212
04:03:25 <mekeor> -? –? —?
04:03:26 <elliott> http://www.fileformat.info/info/unicode/char/2212/index.htm
04:03:26 <mekeor> ah
04:03:37 <adamt> unicode <3
04:03:54 * elliott likes how Unicode contains HYPHEN, MINUS SIGN, *and* HYPHEN-MINUS
04:03:59 <elliott> and of course the last one is all anybody ever uses
04:04:16 <mekeor> > 5 × 5
04:04:17 <lambdabot>   Not in scope: `
04:04:30 <elliott> (btw, does anyone know what character set unicode character names are in?)
04:04:30 <mekeor> > 5 ÷ 5
04:04:31 <lambdabot>   Not in scope: `
04:04:36 <adamt> Not really, if you're making reports and wants to make the long nice, it's useful with more than one type of dash. :)
04:04:37 <mekeor> elliott: why does that not work?
04:04:39 <elliott> (I assumed it was just A-Z + SPACES, but clearly it has hyphens too)
04:04:42 <elliott> mekeor: because you didn't define them
04:04:54 * earthy likes how Unicode contains 'PILE OF POO'
04:05:01 <mekeor> > let (×) = (*) in 5 × 5
04:05:02 <lambdabot>   25
04:05:16 <adamt> Sadly rendered as a square [] character instead of said poo, though. :(
04:07:03 * mekeor likes ☠
04:07:31 <elliott> earthy: meh, just imported from emojis
04:07:39 <elliott> see, that one's easy,
04:07:51 <elliott> explain U+23E5 FLATNESS http://www.fileformat.info/info/unicode/char/23e5/index.htm
04:08:07 <mekeor> earthy: cool! :D
04:08:22 <elliott> i like to think they just decided the world needed a symbol signifying flatness itself (but the symbol itself is slanted for some reason)
04:08:41 <mekeor> 💩 – who can read the character there?
04:09:27 <Entroacceptor> it's a 3d view of a flat surface; )
04:09:32 <elliott> I don't have the font for it.
04:09:40 <Entroacceptor> mekeor: I don't see it
04:10:02 <Entroacceptor> if it's not a question mark inside of a diamond
04:10:21 <elliott> can anyone see this?! �
04:10:30 <mekeor> elliott: heh, yes. the only fonts supporting it are "symbolia" and "last resort"..
04:10:38 <mekeor> elliott: for me, it's a question mark..
04:10:39 <elliott> (U+FFFD REPLACEMENT CHARACTER... it's a question mark inside of a diamond :P)
04:10:46 <mekeor> yep
04:10:53 <elliott> mekeor: OS X & iOS do Unicdoe emojis, I think.
04:10:54 <elliott> *Unicode
04:10:58 <elliott> in colour, even.
04:11:17 * mekeor uses Deja Vu Sans inhere/atm.
04:11:26 * elliott too
04:11:39 * mekeor … or, no, actually DejaVu Sans Monospace..
04:12:01 * elliott not too
04:12:01 * bitonic uses Unifont, which has complete unicode 5.1 coverage
04:12:26 <elliott> bitonic: *BMP
04:12:37 <elliott> complete Unicode 5.1 coverage would be a staggering feat.
04:12:45 <mekeor> elliott: so, you are not using a monospace-font here? oO
04:12:45 <bitonic> elliott: right, BMP.
04:12:55 <elliott> mekeor: nope, I use proportional fonts for IRC
04:12:59 <elliott> no reason not to, other than tradition
04:13:24 <mekeor> elliott: well, code is better readable with monospace.
04:13:53 <elliott> mekeor: What do we do with people who paste code blocks on IRC?
04:13:55 <elliott> We yell at them.
04:14:23 <elliott> lambdabot one-liners are fine in a proportional font; there's no indentation or alignment or anything to get confused.
04:14:24 <mekeor> if it's only two lines, it's fine, imo.
04:14:37 <elliott> Two lines probably aren't going to get confused either :)
04:14:46 <bitonic> I love unifont. I'd read books written in unifont.
04:15:17 <elliott> Isn't unifont a low-res bitmap font?
04:15:24 <mekeor> bitonic: is it monospace?
04:15:25 <bitonic> yes
04:15:33 <bitonic> bitmap fonts are the best
04:15:34 <elliott> I can safely say I would not read books written in Unifont, then
04:15:53 * mekeor is trying unifont inhere now.
04:16:12 <mekeor> it's ugly (because fuzzy). BAH
04:16:34 <bitonic> antialiasing sucks.
04:16:42 <mekeor> heh
04:16:43 <bitonic> anyways, back to haskell
04:21:13 <greg`> hi guys, im trying to install a new version of ghc , and im getting the following error when running ./configure: checking for path to top of build tree... utils/ghc-pwd/dist/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
04:21:13 <greg`> configure: error: cannot determine current directory
04:22:42 <mekeor> greg`: maybe you need libgmp-dev or so
04:22:55 <mekeor> greg`: install it with your package manager. (or are you using windows?)
04:27:22 <sipa> greg`: running from a directory that does not exist anymore?
04:35:17 * hackagebot certificate 1.2.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.1 (VincentHanquez)
04:35:19 * hackagebot hsparql 0.1.2 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.1.2 (RobStewart)
04:38:09 <hpaste_> ment pasted “oracle” at http://hpaste.org/67146
04:38:49 <ment> is there a way to fix this so i could write something like
04:39:14 <ment> do { a <- oracle [1..5]; ... } instead of the call/cc-ish $ \x -> ... ?
04:39:40 <elliott> you could wrap it in ContT and do the obvious :p
04:41:40 <ment> how would that help?
04:42:17 <elliott> well, ContT lets you turn anything taking a continuation into a monadic action that doesn't.
04:42:31 <elliott> but, I note that
04:42:32 <elliott> oracle :: [a] -> (a -> BT r b) -> BT r b
04:42:36 <elliott> looks very much like the type of (>>=)
04:42:37 <elliott> :t (>>=)
04:42:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:42:40 <ment> yeah
04:42:44 <elliott> and so you can probably simply build its logic directly into the monad
04:42:54 <elliott> you may be interested in LogicT.
04:43:00 <elliott> http://hackage.haskell.org/packages/archive/logict/0.5.0/doc/html/Control-Monad-Logic.html
04:43:35 <ment> ah, looks like someone already tried to implement prolog-like logic :)
04:44:00 <mekeor> cool
04:44:40 <elliott> ment: well, prolog-like logic is closer to the list monad, I understand it
04:44:48 <elliott> but LogicT is more efficient
04:45:25 <elliott> ment: but, oracle is simply id for the list monad
04:45:39 <ment> now that i think about it, would there be any difference had i used the list monad?
04:45:41 <elliott> > do {x <- [1,2,3]; y <- [2,4,6]; guard (x == y || x == 3); return (x, y) }
04:45:42 <lambdabot>   [(2,2),(3,2),(3,4),(3,6)]
04:45:58 <elliott> (the operator is usually called "amb")
04:47:42 <killy9999> I want to learn how to use Arrays in Haskell. I've found some introduction in A Gentle Introduction to Haskell and I wonder if that will be sufficient to use Arrays effectively?
04:48:09 <elliott> killy9999: the arrays library is pretty unloved these days
04:48:14 <elliott> you should probably look at the vector library
04:48:22 <elliott> the Gentle Introduction is quite out-of-date
04:48:34 <greg`> sorry i am using ubuntu
04:48:53 <greg`> i didnt want to install it with my package manager because i thought it may be too old
04:49:04 <greg`> i'll give the apt-package manager a try
04:49:15 <mekeor> greg`: why sorry? which ubuntu-version?
04:50:01 <ment> :t guard
04:50:02 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:50:09 <elliott> guard b = if b then [()] else [] for lists
04:52:14 <bobry> TH question -- Is it possible to pass a function signature to the splice? ex. $(mkServer [ doSomething :: Foo -> Result Bar, ... ])
04:52:42 <Lemmih> bobry: Sure.
04:52:46 <bobry> how?
04:53:03 <Lemmih> bobry: 'X :: T' is an expression just as much as 'X' is.
04:53:59 <hpaste_> mbuf pasted “unexpected end of input” at http://hpaste.org/67149
04:54:18 <bobry> well, the problem is -- I don't have the function 'doSomething' in scope, it will be auto generated by mkServer
04:54:32 <reinoud> hi
04:54:50 <greg`> version 11.10
04:56:30 <mekeor> greg`: that is fine. btw, please mention the name you are addressing at the beginning of your message.
04:56:38 <reinoud> is there a linear system solver predefined in a package?
04:57:19 <greg`> mekeor sure i will do, sorry
04:57:40 <reinoud> i need to solve [. . . ni . . .]T p = [. . . ni si . . .]  with n is the normal at a sample point s and p is the solution point
04:58:15 <reinoud> @hoogle solve
04:58:15 <lambdabot> package dropsolve
04:58:15 <lambdabot> package incremental-sat-solver
04:58:27 <reinoud> @hoogle linear
04:58:27 <lambdabot> Graphics.Rendering.OpenGL.GL.Fog Linear :: GLfloat -> GLfloat -> FogMode
04:58:28 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters Linear' :: TextureFilter
04:58:28 <lambdabot> package linear-maps
04:58:35 <bobry> Lemmih: can you point me to an example?
05:07:54 <mbuf> does hGetLine also return the newline? how can I test that?
05:08:17 <elliott> you can test it by trying it
05:08:27 <elliott> Prelude> getLine
05:08:28 <elliott> hello
05:08:28 <elliott> "hello"
05:08:31 <elliott> answer: no
05:09:26 <mbuf> elliott: okay
05:09:28 <mekeor> @remember elliott What do we do with people who paste code blocks on IRC? We yell at them.
05:09:28 <lambdabot> It is forever etched in my memory.
05:10:34 <elliott> Two lines of that weren't code. :(
05:10:45 <mekeor> :)
05:11:13 <typoclass> yelling in a somewhat quieter voice, then
05:14:14 <ziman> it was more a polite greeting than code ;)
05:17:03 <mekeor> :D
05:23:38 <mbuf> quicksilver: merijn hGetLine was stripping the \n which was required by csvFile, and parsing "a";"b";"c" now works!
05:26:10 <quicksilver> mbuf: YAY :)
05:26:14 <quicksilver> @tell mbuf YAY!
05:26:15 <lambdabot> Consider it noted.
05:27:06 <elliott> @tell quicksilver yay
05:27:07 <lambdabot> Consider it noted.
05:28:07 <quicksilver> elliott: thanks
05:28:08 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
05:29:09 <kosmikus> is anyone around with the authority to grant me access to haskell.org?
05:31:00 <mekeor> kosmikus: did *you* write to the ML?
05:31:18 <kosmikus> mekeor: no
05:32:44 <mekeor> kosmikus: http://www.haskell.org/pipermail/haskell/2012-April/023260.html -- but there's no answer yet
05:33:58 <Kaidelong> I need to overlay one indexed png with another indexed png and produce a third indexed png
05:34:02 <Kaidelong> hackage is failing me
05:34:13 <Kaidelong> anyone know library-wise where I should look?
05:35:00 <elliott> kosmikus: contact one of the crats? http://www.haskell.org/haskellwiki/Special:Listusers/sysop
05:36:30 <typoclass> kosmikus: what exactly are you planning to do? most of haskell.org is a wiki, which you can edit anyway
05:41:57 <hpc> hmm, i have an interesting problem
05:41:59 <kosmikus> typoclass: I want to change pages that aren't part of the wiki
05:42:13 <hpc> the laptop i am running my IRC bot on is rather slow
05:42:14 <nart> ciao belli :)
05:42:35 <hpc> so mueval takes a while to compile L.hs, and sometimes simple expressions like length [1..100] will timeout
05:42:49 <kosmikus> elliott: yes, I was hoping one of them might be around ...
05:43:10 <hpc> my idea is to modify mueval to be a server-like thing
05:43:21 <elliott> oh, the crats can't help with that, I don't think, unless they're all server admins too
05:43:31 <hpc> it loads L.hs once, then waits on input expressions
05:43:47 <elliott> hpc: why not just put most of L.hs in its own module and compile it?
05:43:50 <hpc> when one comes in, forkIO, and tweak the watchdog to only kill that thread
05:43:59 <hpc> elliott: it's still slow, for some reason
05:44:15 <hpc> elliott: and mueval has some goofy ideas about where it looks for modules
05:44:26 <reinoud> ugh... my math memory is failing: does anyone know if (A-B) x C can be reduced?
05:44:38 <hpc> reinoud: CA - CB?
05:44:57 <hpc> or is that a cross product or something?
05:45:00 <typoclass> kosmikus: you could try this channel again in a few hours when america is awake (6 h from now or so)
05:45:54 <hpc> elliott: actually... that would work if i did that and made it a package
05:46:07 <hpc> and cabal install'd it
05:46:13 <hpc> probably
05:46:16 * hpc tries
05:46:27 <reinoud> :) distributive over addition yes... duh
05:46:29 <reinoud> tnx
05:46:40 <t7> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
05:46:40 <lambdabot> No results found
05:47:30 <typoclass> > (pred &&& succ) 42 -- t7, you might be looking for this
05:47:31 <lambdabot>   (41,43)
05:47:57 <t7> :t (&&&)
05:47:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:48:54 <typoclass> yeah, i guess that's why hoogle can't find it. it's nicely abstract and confusing :)
05:50:10 <typoclass> i seem to recall the trick is to mentally change "a b c" to "b ~> c", where "~>" is usually "->" but it could also be some more exotic thing
05:51:01 <merijn> @hoogle [a b c] -> b -> [c]
05:51:01 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r a -> r -> m a
05:51:01 <lambdabot> Control.Monad.Trans.Reader runReader :: Reader r a -> r -> a
05:51:01 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
05:51:48 <t7> is there a nice way to sort by the second item in a tuple?
05:51:57 <merijn> sortBy?
05:52:01 <merijn> :t sortBy
05:52:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:52:11 <fmap> sortBy (compare `on` snd)
05:52:19 <t7> ah
05:52:22 <t7> :t on
05:52:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:52:43 <t7> @hoogle on
05:52:43 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:52:43 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
05:52:44 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
05:53:50 <elliott> (compare `on`) === comparing
05:53:53 <elliott> so sortBy (comparing snd) works too
05:53:56 <elliott> (from Data.Ord)
05:53:59 <elliott> and is arguably more idiomatic
05:54:23 <mekeor> it'd be cool if there was a way to do "instance c t => c (Maybe t) where"...
05:54:40 <merijn> mekeor: Isn't that possible?
05:54:42 <t7> you cant?
05:54:51 <merijn> Oh wait, requires OverlappingInstances, I guess
05:55:12 <mekeor> i mean, 'c' is general, that is it's not a certain class but ANY class.
05:55:17 <merijn> Or maybe not even, I'm not sure
05:56:01 <mekeor> so, you don't know which function the class "c" defines. so you AFAIK can't make "Maybe a" an instance of "c".
05:56:59 <hpc> how do i resolve this?
05:57:00 <hpc> cabal: There is no installed version of base
05:57:05 <mysticc> I was going through type families .. whats wrong with this http://paste.pocoo.org/show/582961
05:57:25 <t7> hpn ghc-pkg hided it or something?
05:57:33 <t7> hpc*
05:57:47 <hpc> not hidden
05:58:01 <typoclass> hpc, use -v as a first step
05:58:01 <hpc> ghc-pkg list | grep base # shows it just fine
05:58:32 <hpc> typoclass: cabal install -v?
05:58:34 <typoclass> i guess it was excluded due to some .cabal build-depends snafu
05:58:43 <t7> have you tried turning it off and on again?
05:58:46 <mekeor> merijn: am i wrong? is this possible? that'd be awesome. but crazy.
05:59:24 <rwbarton> mysticc, does something make you think there is something wrong with it?
05:59:26 <merijn> mekeor: No, for arbitrary classes it isn't, except maybe with a few tera-olegs of type hackery and depreciation of the entire Prelude :p
05:59:30 <typoclass> hpc: yes, the verbose thingy where cabal tells you explicitly "i'm not considering base-1.2.3.4 because of build-depends: base > 2" etc.
05:59:37 <hpc> ah
06:00:11 <mekeor> merijn: tera-olegs?? whuut?
06:00:34 <mysticc> rwbarton: ghci gives me error : "number of parameters must match family declaration; expected 0"
06:00:49 <rwbarton> type Out a b :: *
06:01:01 <rwbarton> make line 6 that
06:02:01 <mysticc> rwbarton: huh .. it is working now .. whats the difference between the two ?
06:02:04 <hpaste_> hpc pasted “error, and cabal” at http://hpaste.org/67152
06:02:16 <hpc> pasted error message with max verbosity, and the cabal file
06:02:27 <merijn> mekeor: Ah, you don't know Oleg? He does type hackery so scary that has name has become the unofficial unit of type hacking difficulty
06:02:35 <hpc> @quote oleg
06:02:36 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
06:02:48 <merijn> ^^^
06:02:53 <merijn> This quote, so true
06:03:03 <mekeor> :)
06:03:19 <ivan___> This site is awesome
06:03:23 <mekeor> @seen oleg
06:03:23 <lambdabot> Unknown command, try @list
06:03:50 <hpc> i am using base-4.3.1.0, if it matters
06:03:54 <merijn> mekeor: If you want to have nightmares: http://okmij.org/ftp/
06:03:56 <t7> did anyone watch the milner thingy yesterday?
06:04:18 <merijn> mekeor: That's his site, but you've been warned. It is not for the feint of heart :p
06:04:37 <Ptival> t7: some of it (and looking at it today too)
06:04:51 <hpc> oh, here's a more interesting error from Setup.hs build
06:05:02 <mekeor> merijn: oO… okay… actually, that makes me just more excited =)
06:05:07 <hpc>     Could not find module `Prelude':
06:05:08 <hpc>       It is a member of the hidden package `base'.
06:05:13 <hpc>       It is a member of the hidden package `haskell2010-1.0.0.0'.
06:05:26 <t7> i would watch but work :(
06:05:59 <merijn> @quote type.level
06:05:59 <lambdabot> JohnMeacham says: I was just thinking I needed type level naturals last night at the pub.
06:06:05 <merijn> hmm, wrong quote
06:06:19 <merijn> @quote haskell.type.level
06:06:19 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
06:06:20 <aristid> @quote oleg
06:06:20 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
06:06:31 <Tinned_Tuna> @quote dnolen
06:06:32 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
06:06:45 <byorgey> hpc: paste the output of  ghc-pkg list  as well?
06:07:04 <byorgey> hpc: oh, wait, no, you don't have any build-depends listed
06:07:04 <typoclass> hpc: could you have your base installed as --user and unavailable as --global, for some reason? (your paste looks pretty baffling)
06:07:12 <byorgey> hpc: you need to at least list 'base' in the build-depends
06:07:19 <hpc> i did list base
06:07:25 <typoclass> right, it's commented out
06:07:27 <hpc> oh shit, i didn't
06:07:40 <hpc> good catch
06:07:57 <typoclass> let me guess, cabal init generated the file like that?
06:08:11 <typoclass> that's arguably pretty much a bug then ...
06:08:14 <hpc> yeah
06:08:20 <byorgey> fixed in the HEAD!
06:08:35 <hpc> i was editing it as root in vim, so :syntax was off
06:08:43 <byorgey> cabal init now auto-guesses dependencies (based on your code) and lists them in build-depends
06:08:51 <hpc> a bug in the debian package for vim as well, i think
06:08:54 <byorgey> and a new version of cabal is apparently going to be released today!!
06:09:07 <typoclass> byorgey: oh, nice :) sounds good
06:09:20 <byorgey> typoclass: btw, I like you nick =D
06:09:23 <mysticc> what does .. :kind! in ghci means?
06:09:48 <byorgey> mysticc: it means to show a *fully evaluated* type and its kind
06:10:12 <byorgey> mysticc: e.g. if you write something that involves a type family it will reduce it as much as possible
06:10:13 <typoclass> byorgey: thanks :)
06:10:32 <mekeor> merijn: what's oleg's real name?
06:10:40 <byorgey> mekeor: Oleg
06:10:48 <mekeor> huh?
06:10:56 <byorgey> mekeor: that's his real name. Oleg.
06:11:11 <byorgey> Oleg Kiselyov.
06:11:14 <mekeor> ah
06:11:15 <hpc> it installs now, and is much faster
06:11:19 <byorgey> yay
06:11:35 <hpc> not quite the level of immediacy of lambdabot, but pretty good for a core2 1.67GHz
06:11:41 <byorgey> mekeor: as far as I know he's never been on IRC.
06:12:23 <mekeor> byorgey: oh. bummer
06:12:28 <hpc> @quote list oleg
06:12:28 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
06:12:32 <hpc> D:
06:13:09 <byorgey> he just lurks on the mailing lists and occasionally responds to various posts with things like "so-and-so was trying to do X, but such-and-such said X couldn't be done.  In this message I implement X using only types and a piece of string."
06:13:38 <mekeor> lol :D
06:13:39 <Ptival> "using delimited continuations"
06:13:45 <byorgey> "oh, and it is completely Haskell 98"
06:13:59 <yitz> sometimes it requires an eye of newt
06:14:10 <hpc> someone should invite oleg to #agda
06:14:22 <byorgey> Ptival: those too.  But after all, Oleg can implement those using a piece of string.
06:14:33 <mux> Oleg: the MacGyver of the type system
06:14:37 <hpc> "in this messsage i implement X using only Set ω"
06:14:50 <Ptival> byorgey: sure, string is the canonical thing :)
06:15:02 <byorgey> "in this message I prove that Agda is inconsistent using only Set and Bool"
06:15:12 <mekeor> :D
06:15:13 <Ptival> dammit Oleg!
06:15:17 <typoclass> "in this message i implement String using only a bit of string"
06:15:20 <Ptival> trashing the party
06:19:53 <killy9999> elliott: thank for the tip about vector library 1.5 hour ago :) sorry, I wrote the question and was interrupted by someone
06:21:07 <mekeor> byorgey: http://en.wikipedia.org/wiki/Oleg_Kiselyov
06:22:15 <elliott> mekeor didn't know who oleg is? o_O
06:22:20 <elliott> byorgey: woot @ new cabal-install
06:22:55 <saml> hey i want to write a compiler that generates fast code
06:23:04 <ment> me too
06:23:07 <saml> can you instead write it for me?
06:23:13 <mekeor> lol
06:23:14 <elliott> no
06:23:17 <sopvop> I just found what hdbc does not support postgres composite types. Now I have a choice of trying to hack one, or use takusen. Which one would be less painful?
06:23:30 <saml> do i need to come up with a language first?
06:23:46 * elliott wonders if saml is trolling
06:25:23 <sipa> ok, here's a language: the only valid program is "fib10", and the compiler simply checks whether the input is fib10, and then outputs the following C code: int main(void) { printf("1,1,2,3,5,8,13,21,34,55\n"); }
06:25:28 <typoclass> sopvop: maybe use "cabal unpack hdbc" and hack around for an hour, if it doesn't go anywhere, use takusen ...?
06:25:59 <sopvop> Guess so
06:26:27 <elliott> sipa: can't do fizzbuzz - useless
06:26:55 <Guest93757> I'm trying to install leksah with cabal, but gtksourceview2 (dependency) doesn't work since it can't find a header-file. However, i can manually cabal configure/build/install and point it to the missing .h-file, but when i resume install leksah with cabal, it attempts to install gtksourceview2 again, and fails.
06:27:13 <Guest93757> Any ideas?
06:27:49 <dcoutts> Guest93757: with newer cabal-install you can use --constraint='gtksourceview2 installed'
06:28:01 <elliott> (or just --avoid-reinstalls?)
06:28:33 * BMeph thinks the best trolls run on high-grade peTROLL-eum!
06:28:33 <int-e> sipa: see also http://esolangs.org/wiki/HQ9%2B
06:28:46 <Guest93757> (stupid nickserv not letting me change to my normal name..)
06:28:50 <hpc> sipa: why stop at outputting the C code?
06:28:57 <Guest93757> dcoutts + elliott: thanks, i'll try that.
06:29:01 <hpc> you can remove a lot of extraneous headers and stack frame info too
06:29:11 <hpc> if you output the assembly
06:29:50 <sipa> hpc: my assembly foo is weak :)
06:29:59 <sipa> assembly-fu, i guess
06:30:42 <hpc> int-e: http://esolangs.org/wiki/H9%2B -- still able to print a quine :D
06:31:37 <byorgey> dcoutts: ooh, what does that constraint mean?
06:32:35 <int-e> hpc: true. but it's an easy exercise to avoid that :)
06:35:10 <elliott> int-e: HQ9+ is obsolete. http://esolangs.org/wiki/HQ9%2B%2B
06:39:57 <t7> http://esolangs.org/wiki/CHIQRSX9%2B has a command to make the language turing complete
06:40:56 <mysticc> Is it possible to write type family Combine a b .. such that it can combine any tuple .. like Combine (a,b) (c,d) = (a,b,c,d) ?
06:41:39 <hpc> mysticc: feel like writing out all 62**2 combinations of instances? ;)
06:41:45 <quicksilver> mysticc: don't see why not. You'd need to write all the instances by hand
06:41:53 <quicksilver> or write TH to do so.
06:42:03 <hpc> > 62**2
06:42:04 <lambdabot>   3844.0
06:42:14 <quicksilver> presumably you'd make do with fewer ;)
06:42:47 <t7> what is a multiserver operating system?
06:42:49 <hpc> quicksilver: can't; there's no good way to parameterize over the length of a tuple
06:43:09 <hpc> so say, there's no way to shorten Combine (a,b) (c,d,e) and Combine (a,b,c) (d,e) into a single instance
06:43:12 <rwbarton> I think you missed his point.
06:43:53 <hpc> rwbarton: if his point was that you wouldn't write instances for every tuple, i don't want care ;)
06:44:11 <quicksilver> I said you'd need to write the instances by hand, or write TH to do so
06:44:17 <quicksilver> where did I go wrong?
06:46:11 <mysticc> It is foolish to write all the instances .. I meant is there a way to capture that using some type recursion ...
06:47:20 <elliott> no, but with TH, sure
06:47:21 <fmap> what's the point of appending arbitrary tuples?
06:47:59 <txibilis> .
06:48:01 <Botje> SQL projections?
06:48:25 <mysticc> elliott: I meant is something like this not possible for tuples .. http://paste.pocoo.org/show/582986/
06:48:25 <elliott> txibilis: ,
06:48:44 <elliott> mysticc: i am saying what you want is not possible without template haskell or such.
06:48:47 <elliott> each tuple type is new.
06:48:53 <adamt> meh, now i finally got to it, and my cabal doesn't have --avoid-reinstalls at least.
06:49:03 <elliott> adamt: you need a newer cabal-install then :)
06:49:09 <elliott> ...i hear one is coming out today!
06:49:12 <quicksilver> mysticc: tuples are unrelated types, to haskell. It requires TH to see the uniformity.
06:49:16 <adamt> but but but i just took the one in portage. :)
06:49:57 <adamt> and when doing "cabal install leksah --constraint="gtk installed" " it just complains about an expected dependency. Hmm.
06:50:45 <elliott> yeah i and dcoutts are talking about cabal-install from darcs
06:51:52 <adamt> i take it version 0.10.2 of cabal-install is ancient?
06:53:42 <byorgey> adamt: no
06:53:42 <typoclass> adamt, 0.10.2 is what i have installed as well *shrug*
06:54:12 <gdeest> @pl (\x -> (show x, x))
06:54:13 <lambdabot> (,) =<< show
06:54:23 <byorgey> adamt: by "newer cabal install" dcoutts meant "development version"
06:54:32 <adamt> Oh. That's cheating. :)
06:54:35 <byorgey> adamt: however, I am told a new cabal-install is going to be released very soon
06:54:46 <byorgey> like, perhaps even today
06:55:31 <adamt> meh i'll just get the darcs version then.
06:56:41 <adamt> just to clarify, should i unmerge cabal-install or both the cabal framework, and cabal-install?
06:57:54 <elliott> adamt: it's probably not worth bothering
06:58:02 <elliott> but -- just get rid of cabal-install itself
06:58:10 <elliott> what ghc version are you on?
06:58:25 <adamt> 7.4.1
06:58:33 <elliott> ok, darcs get --lazy http://darcs.haskell.org/cabal-branches/cabal-1.14/
06:58:41 <elliott> then cd cabal-1.14/cabal-install && sh bootstrap.sh
06:58:44 <elliott> but if you want profiling libs then
06:58:51 <elliott> EXTRA_CONFIGURE_OPTS=--enable-library-profiline sh bootstrap.sh
06:58:52 <elliott> instead
06:58:57 <elliott> that'll install it into ~/.cabal/bin
06:59:06 <soiamso> adamt: cabal-install have a version for 7.4 series on hackage
06:59:08 <typoclass> "profiline"?
06:59:14 <elliott> soiamso: doesn't have the solver he wants
06:59:21 <elliott> typoclass: er, profiling
06:59:26 <elliott> typoclass: you could say i made a certain class of typo
06:59:33 <elliott> adamt: ...then you can do nice things with --solver=modular --avoid-reinstalls
06:59:42 <t7> why does no one use fast cgi anymore?
07:00:01 <quicksilver> well, lots of people do actually, t7
07:00:13 <adamt> soiamso: a version of what?
07:00:18 <rgr> If someone could help me understand my ghci/cabal setup I would be grateful. I'm a little lost between ghci/cabal/hugs and my default debian libraries.... cant see the wood for the trees! I have a usr/bin/ghci but there is nothing listed to that effect in aptitude. And Im loath to install hugs from aptitude in case it clashes with cabal bits and bobs.
07:00:35 <adamt> elliott: I see you didn't expect my ghc version to be current. :)
07:00:49 <rgr> possibly you could pm me.
07:01:12 <soiamso> t7: cgi function moving to ngnix like thing ?
07:01:43 <hamishmack> adamt: Have you tried this? cabal install --extra-include-dirs=. gtksourceview2
07:01:44 <t7> everyone seems to roll there own webserver in webframeworks
07:02:18 <elliott> adamt: ghc 7.4.1 is recent like new wounds
07:02:46 <adamt> hamishmack: that works great, but when i cabal install leksah afterwards, it pulls in gio, gtk and gtksourceview again, but this time without the extra include path. :)
07:03:21 <adamt> t7: it's much much easier to deploy self-container webservers in large setups, and avoid dealing with too many external dependencies.
07:03:22 <typoclass> t7: i agree, that trend seems to be pretty silly (except maybe that it's cute for development if you can just enter one command and a webserver with your app comes up)
07:03:39 <adamt> *self-contained
07:03:43 <elliott> it's not like fastcgi is all that much lighter-weight than http.
07:04:07 <typoclass> rgr: sure we can help you. what was your problem exactly? if you enter "ghci", it doesn't find the program?
07:04:15 <hamishmack> adamt: Perhaps you have old versions installed?  Have you tried ghc-pkg unregister on those?
07:04:37 <adamt> hamishmack: i just installed everything today, so little point probably.
07:05:12 <rgr> typoclass: no, it does. Im confused as to the interaction betwene cabal, ghci, hugs.  I have nightmare memories of using cabal upgrade to install latest xmonad and am loathe to install hugs from aptitude (repo management in debian) in case it somehow clashes with hugs : I dont know - I really am kind of a newbie.
07:05:21 <hamishmack> adamt: What version is gtk?
07:05:32 <rgr> clashes with hugs was meant to read "clashes with cabal"
07:05:58 <adamt> hamishmack: 0.12.3
07:07:56 <typoclass> rgr, cabal is a tool that can download haskell packages from the internet, compile them, and install them ("cabal install xmonad" or whatever). ghci is a program that lets you interactively try things; you enter a line of haskell code and it prints the result. hugs doesn't seem to be used much anymore, everybody seems to be using ghci these days
07:08:53 <rgr> oh I see. http://www.haskell.org/haskellwiki/Debugging recommended hood which a hugs thing no?
07:09:16 <rgr> Im wondering why ghci doesnt seem to be listed in my aptitude search though!
07:09:44 <typoclass> rgr: ghci is part of the ghc package
07:09:52 <rgr> maybe its experimental only. But somehow down the path I must have built it since its in usr/bin ;)
07:10:21 <rgr> oh of course. doh. stupid "search". I have ghc6 installed.
07:10:31 <merijn> t7: I'm pretty sure quite a bit of people use fast cgi
07:11:05 <hamishmack> adamt: You could try adding the extra-include-dirs to your .cabal/config
07:11:18 <merijn> t7: For example, most(all relevant ones, really) python frameworks use WSGI and most web servers have Fast CGI based WSGI implementations
07:12:18 <typoclass> merijn, what improvements does wsgi offer over fastcgi?
07:12:31 <adamt> hamishmack: the dir is inside a package that is extracted at run-time, so yeah.
07:12:48 <merijn> typoclass: WSGI doesn't offer anything, it's the "web service gateway interface" is just an abstract spec for frameworks to code against
07:13:05 <t7> let f [n] = read n :: Integer; f s = f $ show $ sum $ map (read . return) s in f "123"
07:13:08 <t7> > let f [n] = read n :: Integer; f s = f $ show $ sum $ map (read . return) s in f "123"
07:13:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:13:09 <lambdabot>         against inferred type...
07:13:31 <merijn> typoclass: The advantage is that any framework using WSGI can run on any implementation supporting WSGI, including fast CGI based ones
07:13:56 <typoclass> i see ...
07:14:05 <hamishmack> adamt: just . works for me though
07:15:10 <quicksilver> merijn: it also lets you add another acronym to your list of technologies.
07:15:21 <quicksilver> merijn: tenders and CVs are both judged by weighing the acronyms, you see.
07:15:32 <merijn> quicksilver: Certainly an important factor
07:15:34 <adamt> *shiver* tenders.
07:16:17 <quicksilver> round here we prefer WAI!
07:17:06 <merijn> You know
07:17:23 <merijn> The more I work with them, the more I realise that first class IO actions are the bees knees
07:17:56 <quicksilver> they really are.
07:18:10 <quicksilver> they make haskell the best imperative language around
07:18:30 <merijn> I need to pass around the callback to read from a Chan...oh, wait I can just pass the "readChan input" action around directly
07:19:14 <adamt> "the bees knees"?
07:19:31 <elliott>  http://en.wiktionary.org/wiki/bee's_knees
07:20:27 <rgr> how can haskell be imperative and functional?
07:20:33 <merijn> Easily?
07:20:42 <merijn> imperative haskell == stick everything in IO
07:20:45 <merijn> And it's great
07:20:57 <merijn> Although its probably wise to get used to functional haskell first
07:21:03 <Philippa> rgr: by embedding an imperative language in it
07:21:19 <elliott> haskell is a matryoshka
07:21:26 <Philippa> (I regularly embed logic or constraint languages while I'm writing type inferrers, too)
07:21:39 <adamt> rgr: Most language mix several progamming paradigms, in one way or another.
07:21:51 <Philippa> any programming with nameable functions/procedure/whatever is, but Haskell's a lot better at managing it explicitly
07:21:58 <Philippa> er, any programming language with...
07:22:02 <rgr> its just that a read haskell is a "pure functional language". I guess I need to read up more.
07:22:23 <Philippa> rgr: it's a pure functional language that also gets used as a metalanguage for imperative programs that're then run by the RTS
07:22:38 <Philippa> the imperative programs include lots of pure functional haskell directly as well
07:22:51 <quicksilver> rgr: the great thing about it is that it's imperative support is first-class : you can pass around imperative instructions like any other data object
07:22:58 <merijn> rgr: It is a pure language that produces imperative programs as output. Those imperative programs get executed by the runtime
07:23:02 <Philippa> :t putStrLn "Hello World!"
07:23:03 <lambdabot> IO ()
07:23:04 <quicksilver> collect them in lists, store them for later, execute them multiple times, etc.
07:23:09 <quicksilver> that's what merijn was talking about.
07:23:11 <Philippa> rgr: like that
07:23:37 <Philippa> IO is the type constructor for "IO programs" (or computations or actions, as they're more commonly known)
07:23:39 <quicksilver> (you can do this in LISP too, of course, so perhaps LISP is the 2nd-best imperative langauge)
07:24:07 <Philippa> lisp was the first "serious" pass at hacking a lambda calculus and an imperative lang together, yeah :-)
07:24:12 <merijn> rgr: putStrLn is not a function that prints a string. It is a function that takes a string and returns a "program fragment" that prints said string when executed
07:24:17 <adamt> oho, i think i've actually found the reason for my original problem. version 0.12.2 and 0.12.3 both being required. *sigh*
07:24:18 <rgr> oh cool. cabal install cabal-install followed by xmonad and xmonad-contrib "just worked". A first. Sweet.
07:24:29 <merijn> :t putStrLn
07:24:30 <lambdabot> String -> IO ()
07:25:07 <elliott> adamt: consider using emacs ;)
07:25:57 <adamt> Oh noes. My professor at university is forcing us to learn scheme via emacs, so it just gives me the shivers for the time being :>
07:26:11 <Philippa> rgr: we tell the RTS which IO action to run by binding it to Main.main - simples?
07:26:41 <nand`> unsafePerf--
07:26:42 * nand` hides
07:27:21 <Philippa> per the world-passing model that's telling the entire universe to go fuck itself
07:27:53 <typoclass> @remember Philippa per the world-passing model that's telling the entire universe to go fuck itself
07:27:53 <lambdabot> Done.
07:27:54 <kallisti> adamt: emacs is good
07:28:10 <elliott> Philippa: would you entrust the universe to a *non*-haskell program?
07:28:22 <adamt> kallisti: Yeah i know.
07:28:27 <elliott> all the other languages just poke at pieces of it unsafely
07:28:33 <Philippa> elliott: I'm sure there's a Coq joke in there somewhere, but really...
07:28:33 <elliott> at least haskell works with the whole thing
07:29:07 <Philippa> yeah, the thing I like about the world-passing model is it forces you to accept the risk of your computational substrate getting hit by a meteorite as part of your semantic model
07:29:28 <Philippa> or, y'know, the secondary effect of calling launchMissile
07:29:36 <adamt> meh, screw leksah, depending on an old version of ltk causing all my pains the last 3 hours.
07:30:04 <hpaste_> merijn pasted “imperative haskell sample” at http://hpaste.org/67156
07:30:38 <merijn> rgr: The sample I just posted for example takes an "IO Field" as input, which is essentially a computation that (when run) will read a Field from a Chan
07:30:49 <elliott> Philippa: there's also the reassuring consequence of forkIO existing that universes can be combined safely
07:30:53 * Philippa notes that rgr hasn't actually responded with a "cool, I get it!" or a "WTF?" in a while so we're probably flooding
07:31:35 <Philippa> elliott: eh, you just get two equivalent universes with your focus on different computational processes
07:31:36 <merijn> Philippa: One of the dangers of drinking from the firehose of knowledge
07:31:40 <rgr> no, I'm just marvelling at the keenness ;) Ive a lot to learn, but somehow I feel the "eek, how cool" factor will keep me at it. I hacked a bit of haskell yonks ago for xmonad config but thats about it.
07:32:02 <Philippa> also, it's probably a good idea if we offer to at least explain the joke to rgr re world-passing
07:32:05 <typoclass> oh yes, xmonad, gateway drug to haskell
07:32:12 <merijn> :)
07:32:37 <merijn> Before you know it you're talking about Rank N types and cursing the monomorphism restriction :p
07:32:45 <tdammers> typoclass: so true...
07:32:49 <rgr> xmonad is singularly the best wm/add on to my linux desktop ever. Its simply great.
07:32:58 * Philippa also didn't get a decent chance to roll her eyes re the @remember and note that she always gets @remembered for making snarky, semi-sexual comments about programming languages
07:32:59 <elliott> i think explaining the joke would expose rgr to the world-passing abomination. that would be cruel
07:33:16 <Philippa> it's not an abomination, though! It's just not the most useful model in practice
07:33:20 <rgr> uh oh, "in jokes"... I'll get my cape ....
07:33:39 <Philippa> heh. They're only in jokes in the "needs domain knowledge" sense
07:34:03 <rgr> yeah well, I think emacs "rox" too ;)
07:34:51 <merijn> hmm, is there any canonical wrapping method for long lines?
07:34:57 <Philippa> rgr: one way to do IO/interact with the world in a pure functional setting is this type: TheWholeDamnUniverse -> (TheWholeDamnUniverse {-a little later-}, whateverYouWereComputing)
07:35:25 <merijn> Example, how should I wrap "dupBox min max info output input = boxloop (readStream input) helper (closeStream output)"? (I usually maintain 80 char width max)
07:35:30 <Philippa> so Hello World takes the whole 'verse and gives you one where (for example) you have "Hello World" on your screen
07:35:48 <Philippa> or possibly one where your computer caught fire first
07:36:33 <typoclass> merijn: i'd wrap after the "=" ...
07:36:34 <Philippa> I've used this to get physics students to stop moaning about the philosophical consequences of not shutting up and calculating quantum mechanics
07:37:21 <Saizan> Philippa: i.e. that the future wouldn't get computed?
07:37:35 <merijn> typoclass: Yeah, but is there a styleguide that is commonly used?
07:38:27 <merijn> The "shut up and calculate" model of quantum mechanics is outdated in my (non-physicist) opinion
07:38:37 <Philippa> Saizan: nonono, that's a fundamental misunderstanding of the model :p The function isn't your computational substrate any more, it's a recombination of the world transition function + a projection
07:38:56 <earthy> is_computer_on_fire()
07:39:01 <Philippa> (so your local substrate isn't enough: you have to invoke the rest of the 'verse to work out what happened to it)
07:39:05 <merijn> As far as I can judge the evidence many worlds is the clear winner and Copenhagen is right out, barring any strong new evidence
07:39:12 <typoclass> merijn: not sure. i looked for style guides the other day and didn't really find any. maybe we should make one
07:39:15 <Philippa> earthy: is_computer_nonexistant() !
07:39:51 <adamt> I notice the chat in here being much more philosofical compared to other programming-language channels.
07:40:15 * earthy hinted at https://www.haiku-os.org/legacy-docs/bebook/TheKernelKit_SystemInfo.html#is_computer_on_fire
07:40:17 <merijn> @quote so.passe
07:40:17 <lambdabot> Ethereal says: If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the
07:40:18 <lambdabot> point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
07:40:21 * kallisti wonders about the meaning of life as it relates to monads.
07:40:25 <merijn> adamt: ^^^
07:40:25 <Philippa> adamt: that's because we're closer to the essence of computing - the practical, direct application of philosophy
07:40:48 <Philippa> earthy: I assumed it was historical, yeah :-)
07:41:25 <Philippa> adamt: that, and because the philosophical stuff actually does make us better at what we do in Haskell in the long run
07:41:37 * earthy agrees with Philippa
07:41:46 <merijn> adamt: Also, the quality of the average haskell newbie is higher, allowing for quicker/simpler helping and more time for advanced discussion
07:41:55 <earthy> computer programming is Deep Thinking, and therefore not too different from philosophy
07:42:24 <adamt> earthy: Yeah i know. I like it. Wasn't meant to offend anybodey. :)
07:42:30 <merijn> The python, ruby and php channels are all drowned in newbies. Resulting in angry dictatorial ops or the blind leading the blind, depending on the channel
07:42:32 <Philippa> wasn't taken that way :-)
07:42:37 <adamt> merijn: Damn newbies.
07:42:40 * earthy has actually debunked philosophy students' papers as a pastime back when he was a student
07:42:57 <earthy> adamt: no offense taken :)
07:43:15 <merijn> @quote Cale beginners
07:43:15 <lambdabot> Cale says: Beginners are confusing to beginners. I move that we remove them from the language altogether.
07:43:24 * merijn knows relevant quotes for all scenarios
07:43:40 <Philippa> earthy: I remember being a little cruel to someone about her rendition of the ontological argument - "you just used the universe of universes as a universe. Girard's paradox, your argument proves it doesn't prove anything and we're done"
07:43:58 * earthy grins
07:43:59 <earthy> that too
07:44:05 <Philippa> merijn: whatcha gonna do when the round begins?
07:44:20 <merijn> Huh? What round? Where?
07:44:35 <Philippa> thought you knew all the quotes :-) ("Shoryuken! Shoryuken!")
07:44:38 <adamt> Philippa: He already lost, i think.
07:44:52 <earthy> this stuff was simpler though: 'you're going in circles...' (the basic argument was we need to prove A, so we take A and that leads to B and as we now B leads to C and C proves A, so A is proven...)
07:45:00 <merijn> I downloaded lambdabot's quote file a bit back and stripped all the boring stuff out :p
07:45:17 * ksf_ wants closed type families.
07:45:18 <elliott> so like 90% of the quotes then
07:45:21 <Philippa> earthy: *wince*. At least reducing the ontological argument to Girard's is a fair variant on it
07:45:25 <merijn> elliott: Pretty much
07:45:41 <Philippa> (I should re-read on modal logic sometime, of course)
07:45:48 * earthy nods
07:46:07 * earthy has taken up the more practical side of philosophy though
07:46:25 <earthy> 'sure, it's C#, but SelectMany is Bind and it pays the bills.'
07:46:36 * adamt just learned girard's law is a law firm =/
07:46:38 <Philippa> yeah. Well, one of the reasons I should re-read is to remind myself if it's worth remembering the other side of C-H for it, but still
07:57:50 <luite> does anyone have problems reaching http://yesodweb.com/ ?
07:58:02 <barrucadu> No
07:58:15 <luite> hm bah, I Get DNS lookup failures :(
07:58:21 <merijn> http://www.downforeveryoneorjustme.com/yesodweb.com
07:58:32 <merijn> Says "not just you" for me
07:58:33 <adamt> Aha, your local government has censored yesod!
07:58:47 <merijn> hmm, but going to it works
07:58:53 <gdeest> @pl (\ r -> k (f r) r)
07:58:54 <lambdabot> k =<< f
07:58:54 <luite> merijn: yean for me too, but I could reach it from my server in germany
07:59:02 <gdeest> Of course :P
07:59:13 <zenzike_> http://www.downornot.com/yesodweb says it's up
07:59:17 <merijn> I get forwarded to www.yesodweb.com when visiting
07:59:17 <luite> hehe
07:59:23 <merijn> So some DNS failure?
07:59:35 <luite> probably
08:01:40 <elliott> works for me
08:02:04 <luite> bah annoying, now I can't see the criterion things for michaels new blog post
08:03:17 <luite> oh found them on github
08:09:19 <nand`> luite: what DNs server are you using? yesodweb.com is hosted by ns.phx6.nearlyfreespeech.net and ns.phx7.nearlyfreespeech.net; both of these seem up but nearly dead (16% packet loss, very high ping)
08:10:26 <Y_Less> Anyone know about LANGUAGE CPP? I wrote some macros to generate some repetitive code for some FFI, then discovered that the Haskell CPP doesn't support "...". I tried writing some macros to get around the problem using nested brackets, but I can't quite do it. Is there any way to convince Haskell NOT to use "--traditional" when calling "cpp" (or "hscpp", which has the same behaviour) in order
08:10:27 <Y_Less> to allow variable argument macros?
08:11:40 <lispy> Y_Less: yes
08:12:21 <elliott> Y_Less: don't try to set the fixity of \\, or end a variable name with ', when using cpp, or you're in for a nasty surprise :)
08:12:27 <lispy> Y_Less: there is this: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor
08:12:29 <elliott> it's... a pretty bad extension in general
08:13:28 <lispy> Y_Less: if you can't find an existing ghc flag to control this, you can explicitly pass arbitrary things via this flag
08:13:32 <lispy> -optP option
08:13:34 <lispy> Pass option to CPP (makes sense only if -cpp is also on).
08:14:06 <lispy> Y_Less: A more haskell friendly solution would be template haskell
08:14:35 <Y_Less> lispy: I found those, but the problem seems to be that GHC passes "-traditional" by default and there's no flag to undo it
08:16:18 <lispy> Y_Less: did you try this? http://projects.haskell.org/cpphs/
08:16:22 <quicksilver> or you could run CPP explicitly yourself as part of your build process
08:16:23 <quicksilver> or m4
08:16:29 <quicksilver> or other macro language of your choice.
08:16:40 <lispy> Y_Less: another option (although hackish) is to use a custom cpp program (a script) that filters out --traditional
08:17:34 <Y_Less> Yeah, cpphs is what I meant when I said hscpp sorry. I look in to custom build scripts as I already have a partial one.
08:18:13 <leino_> quick question: how do I wait for threads spawned with forkIO to finish?
08:20:09 <quicksilver> leino_: get them to indicate that they are finished in an MVar or Chan
08:20:24 <quicksilver> leino_: if this is somethiing you do often you can make a nice little utility function to do so, there are a couple floating around
08:22:01 <lispy> ?hoogle threadwait
08:22:02 <lambdabot> Control.Concurrent threadWaitRead :: Fd -> IO ()
08:22:02 <lambdabot> Control.Concurrent threadWaitWrite :: Fd -> IO ()
08:22:02 <lambdabot> GHC.Conc.IO threadWaitRead :: Fd -> IO ()
08:22:33 <luite> nand`: oh just my local isp's dns, they've probably cached failed responses or something
08:23:57 <liyang> leino_: do finished <- newEmptyMVar; forkIO (putStrLn "I'm doing stuff!" `finally` putMVar finished ()); takeMVar finished
08:37:56 <leino_> quicksilver, liyang: thanks!
08:39:37 <kosmikus> any Windows user around who wants to test the cabal-install-0.14.0 binary I prepared?
08:41:46 <ksf_> while type-level symbols are kinda nice, the syntax is killing everything.
08:42:05 <ksf_> compare "foo := Bar" with "foo := (L : L "bar")"
08:42:50 <adamt> So i guess the rumour about a new cabal-install today was right.
08:46:42 <kosmikus> adamt: yes, it's true. but I need a tester :)
08:50:27 * hackagebot cabal-install 0.14.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-0.14.0 (AndresLoeh)
08:52:18 <JoeyA> Yay!  cabal-install finally got updated!
08:52:29 <untitled> how do you read lines in a loop and concatenate the lines you've read?
08:52:48 <quicksilver> concat <$> replicateM 100 getLine
08:52:54 <quicksilver> ^^ read and concatenate 100 lines
08:53:28 <untitled> and what is you don't know how many lines there is going to be?
08:53:32 <untitled> if*
08:53:57 <Eduard_Munteanu> Where do you read them from?
08:54:17 <Eduard_Munteanu> If it's something like stdin, then they should already be in the desired form.
08:54:36 <Eduard_Munteanu> e.g. what hGetContents gives you
08:54:49 <mm_freak> fmap (concat . lines) getContents
08:55:09 <srhb`> I assume the point is "concatenate but strip newlines"
08:55:17 <Eduard_Munteanu> Ah, fair.
08:57:22 <typoclass> untitled: how will you know when to finish reading lines?
08:57:26 <untitled> read a line from stdin, if it's not long enough, continue reading
08:57:32 <untitled> and concat
08:58:00 <mm_freak> untitled: just use getLine
08:58:00 <srhb> Define "long enough" :P
08:58:24 <untitled> with recursion?
08:58:57 <mm_freak> untitled: you should define your problem more exactly, otherwise you will keep getting contradicting answers
08:59:14 <untitled> read a line from stdin, if it's not long enough, continue reading
08:59:19 <untitled> is that not clear?
08:59:21 <srhb> untitled: No.
08:59:26 <srhb> untitled: What is "long enough" ?
08:59:27 <osager> how to get user commandline input infinitely ?
08:59:36 <osager> until user press ctrl+D
08:59:44 <aristid> osager: getContents
08:59:45 <untitled> srhb: that's my problem ;)
08:59:51 <typoclass> untitled: yes, recursion is a goot bet. try to make a function that uses getLine, then does putStr on what getLine gave back, then the function should call itself again
08:59:51 <osager> thank aristid
09:00:03 <srhb> untitled: Er.. Okay.
09:00:16 <mm_freak> untitled: are you a haskell beginner?
09:00:27 <untitled> mm_freak: :)
09:00:39 <mm_freak> is that a "yes" or a "no"?
09:01:14 <aristid> oO
09:01:17 <srhb> ~~
09:01:17 <osager> hi aristid, getContents will combine all user input as a single line
09:01:20 <mm_freak> that was weird
09:01:26 <osager> what if i want to process each line ?
09:01:32 <rwbarton> not as a single line
09:01:32 <aristid> mm_freak: now you scared him away by asking whether he is a beginner
09:01:34 <rwbarton> as a single string
09:01:40 <srhb> osager: use lines.
09:01:41 <aristid> osager: lines . getContents
09:01:47 <aristid> argh i mean
09:01:52 <typoclass> mm_freak: i think he meant "yes, obviously, :)"
09:02:03 <aristid> :t lines . getContents -- evil?
09:02:04 <lambdabot> IO [String]
09:02:06 <osager> what about interactively
09:02:06 <mm_freak> aristid: apparently…  but my choice between "yes, recursion is fine" and "no, use conduits" was dependent on the answer
09:02:10 <srhb> getContents >>= lines
09:02:12 <osager> without terminating the program
09:02:15 <srhb> getContents >>= return . lines
09:02:23 <aristid> mm_freak: ah, that was why you asked
09:02:26 <merijn> :t interact
09:02:27 <lambdabot> (String -> String) -> IO ()
09:02:29 <osager> i understand lines.getContents wait for user to type all lines at the same time
09:02:30 * hayashi needs to find out what these oft-described conduits are
09:02:32 <nand`> aristid: you want lines `fmap` getContents but note that lambdabot's (.) = fmap
09:02:41 <aristid> srhb: fmap lines getContents is nicer IMHO
09:02:54 <srhb> aristid: I agree. :)
09:02:54 <aristid> nand`: i know, that's why i put an "evil?" comment there :D
09:02:58 <mm_freak> hayashi: enumerators, but with better resource control
09:03:09 <mm_freak> hayashi: not the same as enumerators, but with the same purpose
09:03:13 <hpaste_> “Joey Adams” pasted “Get lines and concatenate them in a loop” at http://hpaste.org/67162
09:03:25 <osager> what if i want the user to type one line, i process it then waits for the next line
09:03:39 <hayashi> Not actually sure what an enumerator is either >_>
09:03:41 * hayashi is a derp.
09:03:43 <nand`> osager: getLine?
09:04:06 <aristid> osager: no, lines <$> getContents will _not_ wait for the whole input
09:04:11 * hayashi reads up anyway.
09:04:12 <srhb> osager: That's just buffering you're feeling
09:04:38 <osager> ok. what is <$> ?
09:04:41 <nand`> fmap
09:04:43 <aristid> same as fmap
09:04:45 <osager> ok
09:04:46 <nand`> but with a different type
09:04:50 <osager> thank you all guys for the patience
09:04:51 <JoeyA> :t fmap
09:04:52 <nand`> actually no
09:04:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:04:55 <nand`> it's the same type
09:04:55 <mm_freak> hayashi: iteratees?
09:04:56 <JoeyA> :t (<$>)
09:04:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:04:57 <aristid> nand`: no, i think the type is the same:)
09:05:04 <JoeyA> ap is the one with different types.
09:05:04 <aristid> but (<$>) is an infix op
09:05:09 <JoeyA> :t ap
09:05:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:05:13 <JoeyA> :t (<*>)
09:05:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:05:15 <nand`> I was thinking for a moment that was Applicative f => (a -> b) -> f a -> f b
09:05:34 <aristid> nand`: liftM would be the one that has a different type:)
09:05:42 <typoclass> :t liftM
09:05:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:05:47 <nand`> aristid: well that's yet another type :P
09:06:08 <aristid> liftM actually behaves like fmap, unlike ap :P
09:06:13 <nand`> incidentally all three would work here
09:06:52 <JoeyA> At the same time?
09:06:56 <mn90018> hi. why the following does not work with quickcheck: prop_dateIsBeforeDateNextToIt day month year = day > 0 ==> isDateCorrect (day month year)
09:07:14 <aristid> JoeyA: why not? liftM id (fmap id (lines <$> getContents)
09:07:17 <aristid> )
09:07:27 <rwbarton> "does not work"?
09:07:53 <mn90018> it compiles, but calling it from the prompt says couldn't match expected type with 'Integer' with actual type 't0 -> t10 -> a0'
09:08:12 <typoclass> why would "lines `ap` getContents" work?
09:08:14 <mn90018> Expected type: Integer -> Integer - Integer -> Bool
09:08:19 <aristid> mn90018: what does :t prop_dateIsBeforeDateNextToIt say?
09:08:21 <aristid> typoclass: no
09:08:26 <aristid> :t ap
09:08:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:08:44 <typoclass> yeah that's what i mean, it expects "m something" on its left side :)
09:08:52 <nand`> :t return lines `ap` getContents
09:08:53 <lambdabot> IO [String]
09:09:09 <JoeyA> aristid: Isn't there a nicer way to compose that?  Like: (liftM id `fmap` fmap id) (lines <$> getContents)
09:09:11 <typoclass> oh well, return is cheating
09:09:21 <aristid> JoeyA: sure :)
09:09:31 <nand`> JoeyA: id . id . lines . getContents
09:10:03 <hpaste_> mn90018 pasted “aristid: here” at http://hpaste.org/67163
09:10:07 <aristid> nand`: that doesn't use all three of fmap/(<$>)/liftM. it uses none of them instead :P
09:10:28 <nand`> aristid: indeed; I cheated
09:10:29 <rwbarton> "(day month year)" doesn't sound like what you want
09:10:33 <rwbarton> mn90018: ^
09:10:51 <hayashi> Conduits seem somewhat understandable to me anyway, it's just currently the only I/O I've really done is full stdin > full stdout, which is just usage of interact
09:11:16 <aristid> hayashi: :)
09:11:46 <aristid> hayashi: the conduit I/O model seems quite a bit more conservative than iteratees, which is maybe why it's easier to understand
09:11:51 <mn90018> i have a function isDateCorrect (Integer, Integer, Integer)
09:12:01 <hayashi> It doesn't help that I started getting into haskell at the same time as reading esr's The Art of Unix Programming
09:12:02 <aristid> mn90018: then don't forget the commas :)
09:12:17 <aristid> mn90018: but why does the function take a tuple instead of taking three arguments?
09:12:28 <hayashi> thus any non-toy haskell I've done is piles of small programs that transform stdin to stdout >_>
09:12:30 <hayashi> *are
09:12:41 <henry577> Hi guys
09:13:03 <mn90018> aristid: fixed that.. still complains the same thing.
09:13:07 <henry577> coulkd someone tell me where the parse error happens? http://ideone.com/xNaWC
09:13:12 <henry577> *could
09:13:16 <aristid> mn90018: what exactly did you fix?
09:13:27 <hayashi> actually, it would be is in that case, I blame perennial tiredness
09:14:10 <mn90018> aristid: I changed my isDateCorrect function from taking a tuple to three arguments and changed to property to this: prop_dateIsBeforeDateNextToIt day month year = day > 0 ==> isDateCorrect day month year
09:16:23 <hayashi> henry577: That worked fine for me, though I had to change Random to System.Random and Char to Data.Char to get ghc to like it, and then had to unbreak the really long lines that I think broke when I pasted it...
09:16:54 <mn90018> aristid: i try to run the tests from interactive prompt with command: quickCheck (prop_dateIsBeforeDateNextToIt :: Integer -> Integer -> Integer -> Bool)
09:17:04 <osager> hi with "fmap lines getContents", the program still waits for the user to finish typing all lines before showing the result
09:17:19 <mm_freak> hayashi: conduits are much more ad hoc than enumerators…  no expensive theory, no ingenious unification, etc.
09:17:19 <rwbarton> that's not the type of prop_dateIsBeforeDateNextToIt
09:17:30 <mm_freak> that makes them easy to understand and quick to get the job done
09:17:32 <osager> what i want is that user type a line, push enter, haskell process that line, show the result and then wait for next line
09:17:34 <typoclass> henry577: could you tell us a little more about what you're trying to do? it seems weird to me that you're converting a number to a string, then reading it back again into an Int
09:17:53 <spanner> if I define a function in GHCi, is there a way to subsequently show the function I entered without scrolling back up the console output?
09:17:59 <quicksilver> no.
09:18:21 <mn90018> then how to run that test? if I leave the "day > 0 ==>" part out of my property then it will work..
09:18:39 <mn90018> fails due to function not handling the situation where day is zero, but still...
09:18:51 <henry577> it is a keygen. but only for a very old game :) just wanted to try it
09:19:12 <rwbarton> replace 'Bool' by 'Property' for a start
09:19:18 <rwbarton> @hoogle (==>)
09:19:18 <henry577> so i need this random int
09:19:19 <lambdabot> Test.QuickCheck.Property (==>) :: Testable prop => Bool -> prop -> Property
09:19:19 <lambdabot> Test.QuickCheck (==>) :: Testable prop => Bool -> prop -> Property
09:19:39 <merijn> spanner: Up arrow cycles through previous input, doesn't it?
09:19:39 <henry577> then i convert it into a string to split it for the algorithm
09:19:42 <hpc> :t randomRIO
09:19:43 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:20:40 <mn90018> rwbarton: thanks! it works!
09:20:43 <spanner> merijn: yes I know. But it'd be nice to have a command to show a function definition. Maybe this will happen in the future..
09:20:44 <mm_freak> osager: hSetBuffering stdin LineBuffering
09:20:47 <typoclass> henry577: i'm pretty sure that 10^17 is out of range for an Int. you may want to switch to Integer throughout the program. (unless the truncation is part of the algorithm)
09:21:03 <mn90018> Although I'm a little surprised that real world haskell doesn't mention that it should be changed..
09:21:08 <mm_freak> typoclass: 10^17 is in range for an Int, if you are on 64 bits
09:21:13 <merijn> spanner: Normally I just define my functions in a text editor and have GHCi in a separate window to use it
09:21:15 <rwbarton> normally you wouldn't write the type signature at all
09:21:17 <osager> i'll try mm_freak
09:21:28 <hpc> > 10^17 :: Int
09:21:29 <lambdabot>   100000000000000000
09:21:41 <hpc> > 10^17 :: Int32 -- maybe you have an older CPU?
09:21:42 <lambdabot>   1569325056
09:21:49 <mm_freak> > fromIntegral (10^17 :: Int) == (10^17 :: Integer)
09:21:50 <lambdabot>   True
09:21:50 <henry577> yeah 31 bit cpu
09:21:54 <merijn> > 10^17 > fromIntegral (maxBound :: Int)
09:21:55 <lambdabot>   False
09:21:56 <spanner> merijn: me too. I guess for anything substantial this is the way to go.
09:22:08 <henry577> i start my 64 bit machine
09:22:16 <rwbarton> or you can just use Integer
09:22:20 <rwbarton> or Int64
09:22:37 <hpc> @src Int64
09:22:37 <lambdabot> data Int64 = I64# Int64#
09:22:45 <mn90018> btw. is there a way to use property as filter for another property?
09:22:45 <hpc> ^ should be reasonably performant
09:22:56 <henry577> ok
09:23:29 <henry577> thanks
09:23:33 <hpc> 31-bit CPU? that sounds awkward ;)
09:23:41 <henry577> 32 :D
09:23:45 <merijn> hpc: That extra bit was just to expensive
09:23:51 <henry577> haha
09:23:52 <quicksilver> and how often do you need it, really?
09:23:57 <osager> mm_freak, it doesnt work. still waits for me to type all lines
09:24:01 <typoclass> hpc: i think performance is not the issue for "an old game's keygen". nobody cares if it takes 0.06 seconds more to run. it is however important if the results are correct ... :)
09:24:02 <quicksilver> very rarely do I see all 32 bits used at once.
09:24:03 <rwbarton> it was unreasonably unperformant the last time I tried using Int64 on a 32-bit system, if that matters to you then you might want to go with the 64-bit system after all
09:24:26 <rwbarton> every arithmetic operation was a function call
09:24:31 <rwbarton> maybe it's better now though
09:24:36 <mm_freak> osager: that's weird
09:24:39 <henry577> doesn't matter for this little algorithm
09:24:42 <mm_freak> osager: did you switch to binary mode?
09:24:43 <hpc> rwbarton: i expect it to be less bad than Integer
09:25:01 <hpc> seeing as how they aren't synonyms
09:25:20 <rwbarton> I think it can be faster depending on how often the value actually exceeds the S# range
09:25:23 <rwbarton> Integer I mean
09:25:29 <hpc> true
09:25:44 <sam4> Do you guys know of any good libraries for working with matrices in haskell?
09:25:50 <rwbarton> also they have differing semantics
09:25:57 <hpc> @hoogle matrix
09:25:57 <lambdabot> Graphics.Rendering.OpenGL.GLU.Matrix module Graphics.Rendering.OpenGL.GLU.Matrix
09:25:58 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans class Matrix m
09:25:58 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans matrix :: (Matrix m, MatrixComponent c) => Maybe MatrixMode -> StateVar (m c)
09:26:00 <rwbarton> but yes, one would hope that it is faster than calling gmp
09:26:04 <hpc> @hoogle matrix -package
09:26:04 <lambdabot> Graphics.Rendering.OpenGL.GLU.Matrix module Graphics.Rendering.OpenGL.GLU.Matrix
09:26:04 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans class Matrix m
09:26:05 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans matrix :: (Matrix m, MatrixComponent c) => Maybe MatrixMode -> StateVar (m c)
09:26:17 <hpc> @hoogle matrix +package
09:26:17 <lambdabot> package matrix-market
09:26:17 <lambdabot> package matrix-market-pure
09:26:17 <lambdabot> package hmatrix
09:26:25 <hpc> (there's lots more)
09:26:52 <sam4> hm2026 let me check them out...
09:26:54 <hpc> as i understand it, hmatrix is the most commonly used
09:27:17 <hpc> ...and now as i look through the list, it's the only one
09:27:27 <hpc> matrix-market is unrelated
09:28:21 <sam4> I am mostly concerned about matrix multiplication but it seems that many libraries only support matrix of type Double
09:28:29 <sam4> but I need one for general Num
09:28:49 <bitonic> oh, GHC HEAD has type-level literals!
09:28:51 <bitonic> how did I miss that
09:29:01 <osager> mm_freak, what is binary mode ? you mean my terminal or haskell ?
09:29:08 <hpc> looks like hmatrix does any Storables
09:29:31 <henry577> Int64 doesn't work
09:29:33 <mm_freak> osager: terminal, as in hSetBinaryMode
09:29:35 <henry577> http://ideone.com/Faltv
09:30:23 <quicksilver> henry577: the error there is self-explanatory, no?
09:30:39 <quicksilver> henry577: "prIntf" is a typo caused by an eager search/replace presumably
09:31:03 <sam4> hpc: I looked at LAPACK but it supposed matrix multiplication on type Double
09:31:09 <kosmikus> hi. I'm still looking for someone who'd be willing to quickly test the windows cabal-install-0.14.0 binary.
09:32:09 <henry577> quicksilver: my english is too bad to understand what you wrote =/ how can i correct it?
09:32:48 <rwbarton> compare
09:32:50 <hayashi> That might be why it worked for me- I'm on a 64-bit computer.  To be honest I didn't really look at the code though, just ran it and got results out of it
09:32:50 <rwbarton> printf
09:32:52 <rwbarton> prIntf
09:33:52 <quicksilver> henry577: haskell is case sensitive.
09:33:58 <quicksilver> henry577: "prIntf" is not "printf"
09:34:01 <typoclass> henry577: the compiler is case-sensitive. an "i" is not treated the same as an "I"
09:34:27 * kallisti doesn't really understand the distinction between range and codomain.
09:34:43 <kallisti> it seems if you consider codomain = range then your functions are always surjective.
09:34:48 <quicksilver> range is the elements you can actually produce
09:35:02 <quicksilver> codomain is some nominal set which contains the range but may be larger.
09:35:11 <kallisti> right. that's what I don't understand
09:35:14 <kallisti> isn't that completely arbitrary?
09:35:22 <mauke> kallisti: yes
09:35:35 <quicksilver> yes, it is, but it is sometimes specified.
09:35:35 <rwbarton> some people also use "range" to mean "codomain"
09:35:41 <kallisti> awesome
09:35:52 <kallisti> so I actually do understand. :P
09:35:53 <mauke> all functions are surjective with regard to f(Domain)
09:35:58 <quicksilver> "const 0" considered on Ints has range {0} but codomain Int
09:36:10 <rwbarton> 'function' means different things to a set theorist and a category theorist
09:36:11 <quicksilver> the haskell type-checker checks the codomain, not the range.
09:36:14 <kallisti> ah. so it does become relevant in type systems.
09:36:26 <quicksilver> yes, it becomes relevant in formal theories of composition
09:36:29 <quicksilver> including type systems.
09:36:40 <kallisti> oh right. even regular function composition.
09:36:41 <quicksilver> (formal theories of composition are categories, more-or-less)
09:36:47 <kallisti> it helps if you can expand your codomain to elements other than the range.
09:36:51 <henry577> quicksilver: omg thanks :D
09:36:53 <henry577> http://ideone.com/c0FZ0
09:36:56 <henry577> =(
09:37:12 <quicksilver> henry577: yes, built in functions like "drop" use Int
09:37:30 <quicksilver> henry577: you'll have to use conversion fcuntions to use them on Int64s
09:38:07 <srhb> I thought Int and Int64 was the same on modern systems?
09:38:17 <kallisti> yes, but not in the Haskell type system
09:38:18 <mauke> define "the same"
09:38:32 <kallisti> and it certainly wouldn't make sense to make them equivalent only on such systems
09:38:37 <kallisti> as that would lead to non-portable code.
09:39:10 <mauke> people already complain that Int has different ranges
09:39:29 <mauke> aliasing Int randomly would only make it worse
09:39:36 <quicksilver> rwbarton: (off-topic, but is that true? I would have thought category theorists and set theorists would agree on what a function is?)
09:39:38 <kallisti> Int is saying "platform-neutral int is fine, as long as it satisfies a minimum of (I think) 32-bits"
09:39:46 <hayashi> There are some generic___ functions that take Integrals though, eg for drop there's genericDrop
09:39:47 <srhb> Ah, okay.
09:39:48 <rwbarton> see the first four paragraphs of http://en.wikipedia.org/wiki/Function_(mathematics)#Formal_definition
09:39:48 <mauke> more like 29 or something
09:39:52 <mauke> or 30?
09:40:05 <kallisti> Int64 is saying "no I want 64 bit always"  -- so Int and Int64 are not equivalent types because they represent different things.
09:40:17 <hayashi> whether those just massage to Int, I'm not sure.
09:40:26 <mauke> hayashi: they don't
09:40:49 <rwbarton> traditionally set theory uses the definition of function in the fourth paragraph
09:41:40 <nand`> Int has at least [-2^29 .. 2^29-1]
09:41:56 <Luke> for all of you who were helping me with Conduits yesterday: my basic implementation is working and looks really clean. Thanks so much
09:42:02 <nand`> no further restrictions
09:42:13 <Luke> kallisti: ski: ozataman_ ^
09:42:35 <quicksilver> rwbarton: indeed; in my experience many category theorists recognise that definition too, even if they may occasionally abuse notation they do so self-consciously.
09:43:07 <nand`> on my machine (amd64) “Int” seems to be 64-bit
09:43:25 <parcs`> what is the complexity of pattern matching on a integral value?
09:44:04 <danr> parcs`: pattern matching is constant
09:44:31 <parcs`> what about multiple patterns
09:44:32 <danr> well, the GHC implementation is
09:45:34 <henry577> i give up. int64 is lame
09:45:59 <henry577> i can't find a good conversion
09:47:06 <typoclass> henry577: consider using Integer, i think there's more functions that can handle it
09:47:23 <henry577> ok
09:47:25 <rwbarton> you can use genericLength
09:47:43 <rwbarton> or genericDrop and so on
09:47:45 <parcs`> danr: ghc uses the Eq instance to pattern match on integer literals. i'm not sure how that can be constant with multiple patterns
09:48:30 <danr> parcs`: Oh, maybe not for non-concrete Nums then
09:48:46 <hpc> if you pattern-match on S# or J# it's constant :D
09:48:54 <henry577> parse error again with Integer http://ideone.com/B05MX
09:49:38 <henry577> but line 7 is ok
09:50:01 <mauke> henry577: line 5 is wrong
09:50:05 <rwbarton> okay
09:50:11 <rwbarton> "import"? really?
09:50:17 <henry577> oh
09:55:05 <henry577> thanks!!!! Integer worked.
10:26:08 <mn90018> is there a way to make arbitrary int for my quickcheck tests
10:26:23 <mn90018> I'd like to use numbers from 1 to 31 as input and nothing else
10:26:44 <mn90018> if i filter them in my property i get a lot of rejected test runs
10:27:49 <Saizan> mn90018: you can make a custom Gen Int and use it with forAll
10:27:58 <leino_> mn90018: you want an arbitrary integer in the range from 1 to 31, inclusive?
10:28:04 <joachifm> mn90018: elements [1..31] ?
10:29:16 <Saizan> mn90018: using choose (1,31)
10:29:25 <mn90018> yeah but that's the point.. how to do that exactly
10:29:43 <mn90018> if i try instance arbitrary integer i get errors when compiling
10:29:51 <Saizan> forAll (choose (1,31)) \ i -> <your property using i here>
10:29:53 <mn90018> of course, since that already exists
10:30:10 <Saizan> forAll (choose (1,31)) (\ i -> <your property using i here>) -- actually
10:30:53 <mn90018> I'll try
10:31:22 <leino> > :t forAll
10:31:23 <lambdabot>   <no location info>: parse error on input `:'
10:31:34 <leino> :(
10:31:41 <Saizan> :t forAll
10:31:42 <lambdabot> forall a prop. (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
10:31:58 <leino> thanks
10:32:28 <mn90018> I'm not sure where I should put that..
10:32:37 <mn90018> compiler says it is a naked expression
10:32:50 <leino> mn90018: have you used ghci?
10:33:05 <mn90018> yeah? so i should put that over there?
10:33:22 <leino> yeah, did you put it in a file?
10:33:47 <Saizan> mn90018: your_property_name otherparam = forAll (choose (1,31)) (\ small_int_param -> ...)
10:34:31 <Saizan> you might not have an "otherparam" or have more of them, that's fine
10:34:47 <mn90018> Saizan: seems good for my purposes
10:35:08 <mn90018> just to make sure, there is no way to write "instance arbitrary Int blaablaa..."
10:35:11 <mn90018> ?
10:35:26 <Saizan> there already is such an instance, you can't make another
10:35:36 <leino> mn90018: I think you get the "naked error" when you non-equation stuff into a file
10:36:21 <leino> mn90018: ghci is the best way to try out small lines like the above
10:36:53 <leino> (or by using haskell mode in emacs)
10:37:34 <mn90018> yeah! thanks guys! now my tests run a little longer :)
10:39:33 <mn90018> hmm.. it still skips negative numbers..
10:40:16 <mn90018> I mean that my test will show skipped with values like -5, -46 etc..
10:40:30 <mn90018> I'd like it to run tests with only numbers from 1-31
10:41:04 <mn90018> Oh nevermind! :D
10:43:16 <mn90018> is there a way to have multiple foralls mapped to different variables?
10:45:54 <ksf_> forAll foo \bar -> forAll baz \quux -> ...
10:50:03 <mn90018> ksf_: parenthesis?
10:50:33 <mn90018> I mean the lambda function has already started when the second forall gets called
10:50:43 <Saizan> you need them aroung the lambdas
10:51:06 <Saizan> forAll foo (\bar -> forAll baz (\quux -> ...))
10:51:16 <Saizan> or you could use ($)
10:51:29 <Saizan> forAll foo $ \bar -> forAll baz $ \quux -> ...
10:53:11 <mn90018> prop_fromNextToPreviousDateIsOriginal year  = forAll (choose (1,31)) (\day -> forAll (choose (1,12)) (\month -> ...
10:53:18 <mn90018> complains about incorrect indentation
10:54:42 <rwbarton> ...
10:54:44 <rwbarton> @where hpaste
10:54:45 <lambdabot> http://hpaste.org/
10:55:00 <rwbarton> paste your code there
10:58:43 <hpaste_> mn90018 pasted “Failing property” at http://hpaste.org/67165
11:00:02 <Saizan> hpaste_: you are missing a closing paren at the end
11:00:12 <Saizan> err, mn90018 ^^^
11:00:31 <srhb> I bet hpaste is missing more than one...
11:02:10 <osa1_> does anyone know a way to get ByteString from a Data.Text other than getting String from Data.Text and then calling fromString?
11:02:25 <srhb> gloss is awesome. I made a snake game in no time. Though it's a little hard to break out of it and get the full power of a version just built on OpenGL.
11:04:24 <sm> srhb: let's see!
11:05:54 <sm> can't have too many haskell game demos
11:06:26 <Luke> ozataman_: is there a way to get the current file name in the csv-conduit?
11:08:05 <navaati> erf, there is a drawback in using existentials to make sure that values don't leak out of their scope : you can't use GHCi anymore on them…
11:09:00 <mn90018> yeah works!
11:11:01 <blackdog> navaati: would http://stackoverflow.com/questions/9987739/what-is-the-best-way-to-test-and-interact-with-inner-functions-defined-inside-a help?
11:11:21 <blackdog> works for other things that are hidden by default, haven't tried it with existentials though.
11:12:25 <navaati> my functions are not hidden, but they MUST be run as a parameter of a withBlah function that provides the existentially quantified phantom type
11:13:24 <navaati> ah, debugger… clever…
11:13:56 <navaati> the problem is that what i need to be in scope is not a variable but a type variable… hum… maybe with some proxy stuff…
11:15:52 <blackdog> navaati: perhaps you can extend the technique and write an enlightening blog post :)
11:16:57 <leino> is it possible (by some ugly hack, even) to mix IO () computations in with IO r computations, for a given type r   ?
11:17:15 <blackdog> leino: not even an ugly hack
11:17:31 <leino> how is that?
11:17:32 <rwbarton> mix in what sense
11:17:47 <blackdog> putStrLn "i'm an IO () computation!" >> return "I'm IO String!"
11:18:08 <blackdog> unless i'm missing the point.
11:18:39 <leino> :t putStrLn
11:18:40 <lambdabot> String -> IO ()
11:19:30 <bgamari> Is there any consensus forming on how to incorporate constraint kinds into the standard library's type classes?
11:19:35 <leino> ok, to be more precise
11:19:51 <leino> I need to map IO () things to IO r things
11:20:20 <leino> now that I said it it sounds impossible
11:20:23 <Mathnerd314> :t \r -> fmap (const r)
11:20:24 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => a -> f a1 -> f a
11:20:39 <rwbarton> easy if you have a value of type r
11:20:47 <luite> what's currently the best way to insert a bytestring literal with template haskell?
11:20:52 <rwbarton> "map IO () things to IO r things" still lacks a description of what specifically you want to do
11:21:34 <rwbarton> you can also e.g. make the IO r action never terminate, then it will "return" somethiing of type r
11:21:37 <rwbarton> for any r
11:22:25 <geekosaur> leino, you need to give a practical example.  closest I can come up with to what you're describing, the usual way to deal is that r is a monoid and mempty will work to synthesize one, so <IO action here> >> return mempty
11:22:31 <navaati> bgamari: +1, i was wondering the same : the language evolves, the stdlib have to do the same
11:25:21 <bgamari> navaati: I've been asking this every once in a while
11:25:28 <bgamari> Unfortunately it doesn't seem to be moving forward
11:25:46 <bgamari> Which is unfortunate
11:26:04 <Mathnerd314> bgamari: what would you want to change?
11:26:16 <leino_> did someone write any response to me? my connection lagged out
11:26:36 <bgamari> Mathnerd314: Monad, Functor, Traversable, Applicative, etc. should have an associated constraint
11:26:39 <rwbarton> various responses that amounted to "please be more specific"
11:26:46 <leino_> ok
11:26:49 <blackdog> leino_: http://tunes.org/~nef/logs/haskell/
11:26:53 <leino_> I'll have to think a bit
11:27:12 <bgamari> Mathnerd314: Allowing Data.Vector.Unbox and Data.Set to be Functors, for instance
11:27:57 <navaati> also, using datakind would be great, like heteregoneous lists and lenght-in-the-type lists in base
11:28:48 <Mathnerd314> bgamari: that would have e.g. return :: (Ord a) => a -> Set a ?
11:28:55 <bgamari> Yes
11:30:39 <Mathnerd314> Monad c m where { return :: c a => a -> m a; (>>=) :: (c a, c b) => m a -> (a -> m b) -> m b } ?
11:32:18 <bgamari> Mathnerd314: I think an associated type is generally preferred
11:32:28 <bgamari> Mathnerd314: e.g. http://hackage.haskell.org/packages/archive/rmonad/0.7/doc/html/Control-RMonad.html
11:33:08 <twomashi> Could someone show me a class decleration for a class which inherits Monad and MonadState ?
11:33:30 <bgamari> Inherits may not be the best word to use there
11:33:42 <monochrom> class (Monad m, MonadState s m) => My_class m where ...
11:33:43 <twomashi> Heh.. fair enough
11:33:50 <parcs`> MonadState already implies Monad
11:34:06 <monochrom> oh, heh, then s/Monad m,//
11:34:38 <monochrom> I am not sure whether s should appear on the RHS
11:34:42 <parcs`> i think ghc is smart enough to detect that and complain to you though
11:34:59 <bitonic> monochrom: that won't work
11:35:09 <bitonic> 's' is out of scope
11:35:11 <navaati> rmonad should be updated to use constraint kinds, before talking about updating base…
11:35:11 <mm_freak> is it difficult to write a custom RTS for GHC?
11:35:20 <monochrom> right, that's what I worried
11:35:28 <twomashi> I think i have to define s below
11:35:29 <ezyang> the folks on the House project wrote their own, IIRC
11:35:31 <bgamari> navaati: Point taken
11:35:32 <navaati> mm_freak: yes. a lot.
11:35:34 <monochrom> class (MonadState s m) => My_class s m where ...
11:35:35 <ezyang> but the GHC RTS is a bit of a complicated thing.
11:36:31 <mm_freak> i should rephrase:  given i have already written a custom RTS, is it difficult to use it with GHC?
11:36:52 <ezyang> Ah. You will need to make lots of hooks.
11:37:10 <mm_freak> hmm
11:37:20 <mm_freak> in other words, to make this easy, i have to fork GHC?
11:37:36 <ezyang> Well, you're going to fork GHC anyway. The question is how much.
11:37:45 <mm_freak> i see
11:37:56 <mekeor> heh
11:37:58 <ezyang> For example, think about all of the symbols that the RTS exports? You need to have all of them.
11:43:01 <navaati> do someone know how to find the alignment of a C struct ? the alignment field of Storable bother me…
11:45:21 <mekeor> navaati: what do you mean by alignment? (also ##c would be probably more helpful, wouldn't it?)
11:45:53 <navaati> mekeor: i have no idea of wha it means, i just know that the Storable class want it
11:45:54 <parcs`> navaati: use bindings-DSL to write your ffi code ;)
11:46:29 <navaati> parcs`: hum, why not, yeah, i wanted to take an eye on this
11:48:12 <hpaste_> Mathnerd314 pasted “Proposed Monad class” at http://hpaste.org/67166
11:48:29 <Mathnerd314> bgamari: ^ something like that?
11:49:01 <mekeor> what exactly does Control.Applicative.optional do? the documentation (on hackage) is not very helpful.
11:49:02 <bgamari> Mathnerd314: Yes
11:49:12 <navaati> :t optional
11:49:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
11:49:23 <leino_> I would like to make all of the GLUT calls and callbacks, which are currently of type IO (), into things of type IO r, for any r.
11:49:28 <mekeor> navaati: so, when is it Nothing?
11:49:29 * bgamari wishes the documentation for Applicative were a bit better
11:49:30 <leino_> ideas?
11:49:46 <monochrom> optional is best understood by its use in parsec. optional :: Parser a -> Parser (Maybe a)
11:49:54 <parcs`> mekeor: optional m = fmap Just m <|> pure Nothing
11:50:08 * mekeor is thinking....
11:50:22 <parcs`> i think, anyway
11:50:23 <parcs`> @src optionl
11:50:24 <lambdabot> Source not found. Sorry.
11:50:26 <parcs`> @src optional
11:50:26 <mekeor> @type <|>
11:50:26 <lambdabot> optional v = Just <$> v <|> pure Nothing
11:50:27 <lambdabot> parse error on input `<|>'
11:50:29 <parcs`> yay
11:50:36 <mekeor> @type (<|>)
11:50:37 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:50:47 <navaati> leino_, it is unsound : how can you build an element of type r without knowing which type r is ?
11:50:50 <mekeor> what's <|> again?
11:50:59 <monochrom> <|> is like mplus except for Applicative
11:51:03 <hpc> foo <|> bar = try foo, and if it fails try bar
11:51:14 <hpc> (the notion of failure is specific to each instance)
11:51:52 <parcs`> > Just 3 <|> undefined
11:51:53 <lambdabot>   Just 3
11:51:53 <leino_> navaati: what if I give some other code of type IO r
11:52:05 <parcs`> > Nothing <|> Just 5
11:52:06 <lambdabot>   Just 5
11:52:16 <parcs`> > Nothing <|> Nothing
11:52:16 <lambdabot>   Nothing
11:52:57 <rwbarton> leino_, why not give a concrete example of the line of code you would like to write
11:53:28 <navaati> leino_: different, then. well if you have an "a" of type "IO ()" and a "b" of type "IO r", "a >> b" has type "IO r"
11:53:37 <leino_> rwbarton:  ContT $ \f -> GLUT.idleCallback GLUT.$= (Just $ (GLUT.idleCallback GLUT.$= Nothing) >> f ())
11:53:59 <leino_> the important thing here is that :t f = a -> m r
11:54:03 <leino_> for *any* r
11:54:16 <rwbarton> how about adding ">> return ()"
11:54:17 <leino_> but idleCallback type forces r = ()
11:54:47 <hpc> leino_: add (>> return ()) in there somewhere to discard a value of type r
11:55:05 <hpc> probably after f ()
11:55:09 <leino_> I dont want to discard it
11:55:21 <leino_> I want the type of the above to be ContT r IO ()
11:55:45 <leino_> atm, the GLUT stuff forces r = (), it seems...
11:56:21 <merijn> Where would it return said value to?
11:56:40 <leino_> simpler:  ContT $ \f -> GLUT.idleCallback GLUT.$= (Just $ f ())
11:56:58 <rwbarton> :t ContT
11:56:59 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
11:57:18 <leino_> merijn: beats me :)
11:57:36 <geekosaur> so how exactly areyu expecting it to work?
11:57:54 <rwbarton> this isn't a type issue
11:58:01 <geekosaur> or maybe, what are you expecting it to mean?
11:58:11 <merijn> leino_: (Warning: wild ass guessing as I don't use GLUT) The callback can be called anywhere, so GLUT can't really return anything to you. Because where would it return the data to?
11:58:13 <rwbarton> right this is a "what am i actually doing" issue
11:58:33 <merijn> leino_: As a reminder this is enforced by the current type
11:59:02 <geekosaur> (I am wondering if this is "thread an extra monad through a callback", which can't be solved through a type trick, you need to actually provide code to do the threading)
11:59:04 <merijn> If you don't know where you want the data to be returned *to*, why do you need it in the first place?
12:00:09 <monochrom> ContT $ \f -> GLUT.idleCallback GLUT.$= (Just (f () >> return ()))
12:00:23 <leino_> merijn: Id simply want to take only the "side effecting stuff" of the GLUT calls/callbacks, but I want to lift it  to IO r type and just ignore the return value from the GLUT stuff
12:00:45 * hackagebot haskell-src-exts 1.13.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.1 (NiklasBroberg)
12:00:58 <merijn> leino_: "ignoring the return value" is exactly what ">> return ()" does...
12:01:14 <MarcWeber> nyingen: A hidden module is one which is not exported in the cabal configuration file.
12:01:24 <leino_> merijn: but it ignores the return value of the continuation, which is not really what I want. (I think)
12:02:00 <dmwit_> I really feel like "liftM2 (,)" ought to have a name.
12:02:13 <rwbarton> do you actually use the result of the ContT computation?
12:02:32 <leino_> rwbarton: I'd like to
12:02:55 <rwbarton> the problem is it returns before that idle callback ever happens
12:03:10 <leino_> I use ContT so that I dont have to deal with the callback style of coding imposed by GLUT
12:03:28 <leino_> but I still want my glut programs to be able to return values...
12:03:30 * merijn 's first intuition would be to just stuff whatever state you want to carry over between callback's in an IORef or something...
12:03:42 <leino_> merijn, yeah
12:03:48 <monochrom> has no one seen my "ContT $ \f -> GLUT.idleCallback GLUT.$= (Just (f () >> return ()))"?
12:03:55 <leino_> I could do that before/after calling runContT
12:04:06 <merijn> monochrom: Yes, but I thought it was perl/line noise ;)
12:04:07 <rwbarton> it won't type check
12:04:09 <leino_> (setting the value in the final argument of runContT)
12:04:11 <hpaste_> adamt pasted “TestT-issues” at http://hpaste.org/67169
12:04:19 <adamt> oh sorry, wrong channel
12:04:22 <leino_> :t runContT
12:04:23 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
12:04:41 <hpc> merijn: you're a terrible person if that's your reflex
12:04:43 <byorgey> dmwit: how about runTwoMonadicActionsAndTupleUpTheResults?
12:04:51 <hpc> (it's my reflex too, but don't tell anyone)
12:05:05 <rwbarton> you could use an IVar and hope the idle callback runs before you examine the value
12:05:10 <dmwit> byorgey: enterprisey
12:05:10 <rwbarton> that sounds pretty terrible as well
12:05:17 <merijn> hpc: Meh, I get called a terrible person all the time :p
12:05:22 <merijn> You get over it
12:05:54 <merijn> There is an actual lobby to stop me from ever learning C++ for fear of ununderstandable god awful macro hacks...
12:05:55 <byorgey> dmwit: oh, if you want enterprisey, how about  monadicActionProcessorTupleFactoryFactory?
12:06:03 <merijn> So I make due with hacking templates in CPP :)
12:06:03 <monochrom> actually, whatever f() returns, clearly GLUT is going to ignore it
12:06:11 <leino_> I think something like    newIORef myRetRef >> runContT myLiftedGLUTProgram (\ret -> writeIORef myRetRef ret) >> readIORef myRetRef >>= return   might work
12:06:51 <rwbarton> it won't work because the readIORef will happen before the callback
12:06:58 <merijn> dmwit: You were thinking of something like this?
12:06:59 <merijn> @quote hlint
12:07:00 <lambdabot> lispy says: jkramer> I think since the last update, hlint suggests weird/wrong things <lispy> jkramer: like, "Instead of eta reduction, try a Factory pattern." ?
12:07:51 <identity1> Hey guys. I'm trying to wrap my head around creating a Trie type to store a dictionary(a word dictionary, that is) for fast lookup of words. Basically, given, say, the letter 't', I will be able to walk the trie and get all possible words that start with 't' in my dictionary.
12:08:05 <identity1> I've been looking at this type: http://en.wikipedia.org/wiki/Trie#Algorithms, but I'm not sure how I would 'do that' with that type
12:08:42 <dmwit> identity1: There are several trie libraries on Hackage; maybe you should just use one.
12:09:01 <hpc> data Trie = Fin | Branch Trie Char Trie
12:09:13 <rwbarton> if you use IVar it *might* work as long as the glut idle loop has a chance to run before you examine the value, otherwise you will deadlock
12:09:44 <identity1> What I've been thinking is that I'd have to have a bool or some such in the definition, to determine whether 'where I'm at' in the tree(+ what was stored in nodes leading to current node) is actually a valid word.
12:09:45 <merijn> identity1: Can you be more specific about exactly you get stuck?
12:09:52 <leino_> rwbarton: you mean that the readIORef myRetRef will always return the initial value of myRetRef  ?
12:09:52 <identity1> merijn: I will try.
12:09:56 <rwbarton> yes
12:10:12 <identity1> dmwit: I had looked and seen them, yes, but I'd like to actually do this and not just use someone else's code.
12:10:17 <monochrom> chrisdone should do an April 1st hlint next year on hpaste. "instead of eta reduction, try the Factory pattern" "why use haskell? try php"
12:10:25 <merijn> identity_: In general if the Maybe value is not nothing then start to that node is a valid word
12:10:34 <rwbarton> "missing redundant parentheses"
12:10:42 <typoclass> yes yes, for no reason those imbeciles keep abstracting things into FactoryFactories and whatnot. how ridiculous. i'm off to work on the instance for GeneralCategoryExtraGeneralizedHyloGeneralysis
12:10:50 <rwbarton> "Error: Use prefix syntax for (+)"
12:10:51 <leino_> rwbarton: I dont see why that is. can you help me out?
12:11:05 <merijn> identity1: If you want to find all "valid words" you want to recurse over the entire tree and append the whole word whenever you encounter a Just value
12:11:06 <identity1> merijn: Hmm.
12:11:18 <identity1> And what does that value store, then?
12:11:20 <rwbarton> because it amounts to newIORef myRetRef >> {- set a glut callback -} >> readIORef myRetRef
12:11:32 <merijn> identity1: The Just value you mean?
12:11:36 <identity1> Yes.
12:11:51 <merijn> The Just value stores whatever value you wanted to associate with that key
12:11:52 <identity1> The next letter?
12:11:55 <rwbarton> myRetRef won't be modified until the glut callback runs
12:12:04 <leino_> rwbarton: oh yeah you are right
12:12:08 <rwbarton> which won't be until this code is done running, surely
12:12:10 <merijn> identity1: So if you have a Trie Int, then the value will be Maybe Int
12:12:17 <leino_> rwbarton: and the glut mainloop is missing from my code.
12:12:27 <identity1> I'll whip something up and hpaste it, try to explain what I'm not quite getting better.
12:12:45 <merijn> identity1: If you look at the example picture, the blue integers would be the values stored in the Maybe of that trie data type
12:13:10 <rwbarton> identity1: yeah if you just want to represent a set of words with your trie, you can just use a Bool
12:13:11 <identity1> merijn: But why do I even need some arbitrary values?
12:13:20 <merijn> The labelled branches in the example picture correspond to the "[(Char, Maybe a)]"
12:13:21 <leino_> rwbarton: what if I cause the glut mainloop to exit, somehow, and then read the IORef after that. that ought to work right?
12:13:31 <rwbarton> if you want to associate some data of type a to each word use Maybe a
12:13:37 <merijn> identity1: Because Trie's are dictionary like types that associate keys with values
12:13:44 <rwbarton> leino_: i suppose
12:13:45 <identity1> Ah, of course.
12:14:02 <merijn> identity1: You wanted to find all "valid words" which would usually mean "all keys with an associated value"
12:14:07 <rwbarton> normally when I use a Trie it's for a set not a map
12:14:11 <identity1> The only thing I want to do is be able to walk the tree to construct valid words in the dictionary -- does that then mean I have no need for the key value?
12:14:36 <merijn> identity1: You could replace the Maybe a with Bool and just check for true or false if the key is present
12:15:00 <identity1> I see. And in that case, 'the key being present' would mean that the word is a valid word, not just a partial one?
12:15:10 <merijn> identity1: Yes
12:15:20 <identity1> Alright, thanks.
12:15:37 <identity1> I *think* I've got what I need. You guys have been a big help, as always.
12:16:11 <merijn> identity1: Alternately you could use a different trie "data Trie = ValueNode Bool [(Char, Trie)] | NoValueNode [(Char, Trie)]" or some variation
12:16:16 <geekosaur> leino_, maybe the correct question is "what is the actual problem you are trying to solve?"  you may be thinking about it the wrong way
12:17:15 <leino_> geekosaur:   I am doing GLUT a-la: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
12:17:33 <identity1> Oh, yeah, about that. Why is there a list of chars associated with each children, instead of the char just being a part of the Trie data type itself? Is that because the latter way would require me to store a list of Tries to cover the alphabet?
12:17:36 <leino_> geekosaur:   but I want my GLUT programs to have the ability to return a value and not just be of type IO ()
12:17:46 <identity1> In which case, the NoValueNOde would make sense a root node?
12:17:57 <merijn> identity1: What if there are multiple words starting with the same beginning?
12:18:19 <merijn> identity1: bar baz bax, the "ba" node would have three children
12:18:41 <leino_> geekosaur:   basically, my initial problem is that I really really dislike programming with callbacks, as in glut
12:20:15 <identity1> merijn: Aha, of course!
12:20:27 <identity1> Again, thanks a lot. I think I'll put this to use now.
12:21:32 <andrus> quit
12:21:46 <adamt> No.
12:22:10 <hpc> Lemon: ContT $ \f -> GLUT.idleCallback GLUT.$= (Just (f () >> return ())) -- from monochrom
12:22:34 <hpc> in other news, i like this function at the bottom: https://gist.github.com/1639205
12:22:57 <hpc> it's something ive been thinking of, but never got around to writing
12:24:26 <adamt> Wait, are people doing opengl stuff with haskell, or is this another glut?
12:24:38 <merijn> adamt: It's OpenGL
12:24:51 <adamt> Cool.
12:25:15 <hpc> technically, both
12:25:17 <hpc> OpenGL and GLUT
12:25:24 <hpc> in haskell
12:26:04 <merijn> hpc: I think the question was meant to be parsed as "is that the OpenGL glut or some framework called GLUT I've never heard off" :)
12:26:12 <hpc> oh
12:27:15 <srhb> Is there access to any shorthand a la patternMach pattern that is simply True if pattern matches, otherwise False?
12:27:41 <hpc> srhb: in TH, sure
12:27:47 <hpc> if you wrote it yourself
12:28:07 <leino> (sorry, my connection died again) alternatively, do any of you know of some haskell code doing OpenGL directly, without GLUT?
12:28:15 <srhb> Hm, trying to avoid TH so far. Seems complicated. :P But okay, thanks anyway.
12:28:30 <rwbarton> all you can do with a pattern is pattern match against it
12:28:45 <rwbarton> you can't pass it to a function or anything like that
12:28:49 <hpc> srhb: if you wanted to parameterize over the pattern you would need TH
12:28:53 <hpc> but you could certainly do
12:29:04 <hpc> isFlibble (Flibble {}) = True
12:29:07 <hpc> isFlibble _ = False
12:29:55 <hpc> (empty record patterns are the same as inserting the appropriate number of underscores)
12:30:07 <osa1> is there a way to show an image with gloss? http://hackage.haskell.org/package/gloss-1.7.2.1
12:33:24 <srhb> hpc: Mkay. I guess I'm missing some idiom for doing this. To me it seems like such an obviously useful thing over \x -> case x of pattern -> True; _ -> False, where a "matches" sugar would be helpful.
12:34:13 <rwbarton> "\x -> case x of pattern -> True; _ -> False" is usually not what you want though
12:34:38 <hpc> @quote otherwise
12:34:38 <lambdabot> shachaf says: @let otherfoolish = not otherwise
12:34:42 <hpc> @quote otherwise
12:34:42 <lambdabot> DanWeston says: Bottom has only one value, not two. Otherwise bottom would have been called buttocks.
12:34:47 <hpc> hah
12:35:05 <kallisti> srhb: what do you do with that boolean?
12:35:08 <rwbarton> for example you would never use "case x of pattern -> True; _ -> False" as the condition of an if
12:35:12 <edwardk> hpc: nice
12:35:18 <srhb> No, I guess not. It just seemed very basic, but I'm probably doing something not idiomatic.
12:35:38 <srhb> kallisti: filter, for instance.
12:35:40 <rwbarton> you can pass it as an argument to filter, it's not especially common though
12:35:55 <srhb> I find myself filtering a lot.. but yes. It's not a big deal, just a bit of syntax I wish I had.
12:35:59 <hpc> hmm, there's a quote that's relevant and i can't find it
12:36:10 <rwbarton> particularly if you are going to do any subsequent processing on the list, you would be better off with a list comprehension
12:36:18 <srhb> Yes. Ok. :)
12:37:12 <danr> srhb: do you want to do something akin to what is asked for here: http://stackoverflow.com/questions/10112733/haskell-simple-constructor-comparison-function ?
12:39:41 <mmos> I've been using the --make option with ghc. I want to recompile everything with the -O flag. How do I get it to remake everything? (kind of the equivalent of 'make clean')
12:40:14 <rwbarton> -fforce-recomp
12:40:45 <rwbarton> actually I sort of thought that was supposed to happen automatically but perhaps that's not in yet in whatever version you have
12:42:19 <mmos> I'm on an old version.
12:43:01 <hpc> i don't want --make to imply -fforce-recomp
12:43:18 <rwbarton> I meant if you built with different options.
12:43:25 <hpc> oh
12:43:46 <hpc> that's cool
12:45:37 <srhb> danr: Hmm, I think it is. If I can "poke holes int it"
12:45:50 <jsx> if I pass a function that has an implict parameter to another function, i have to bound the implicit parameter even though the function only will be called inside the other function?
12:46:34 <hpc> jsx: using implicit parameters at all is a red flag, to be honest
12:46:45 <jsx> why is that
12:47:31 <kallisti> typically because there are better ways to do the same thing, and because it makes type signatures more annoying, as you're finding out.
12:49:14 <kallisti> jsx: but not if you explicitly pass an implicit parameter to a function, the called function does not require an implicit parameter in its class constraints
12:49:19 <kallisti> s/not/no/
12:49:38 <jsx> i mean i have this expression:  dir "write" $ H.ifLogged H.write , write use the implicit parameter but ifLogged bounds it. ghc complains there's an unbound parameter
12:50:18 <kallisti> jsx: sure, the parameter isn't in scope for dir
12:51:04 <kallisti> if it's bound in ifLogged
12:51:12 <jsx> but dir does not carry it
12:51:31 <jsx> bound, i mean it 's defined
12:51:37 <kallisti> yes
12:51:45 <jsx> only write has it in its type signature
12:52:06 <kallisti> and dir makes no reference to ?whatever
12:52:14 <jsx> no
12:52:20 <kallisti> and calls nothing that makes reference to ?whatever
12:52:43 <jsx> no
12:52:49 <rwbarton> what are the types of everything involved?
12:54:16 <jsx> ifLogged :: :: ServerPart Response -> ServerPart Response
12:54:33 <jsx> write :: (?usuario :: Maybe Usuario) =>  ServerPart Response
12:54:55 <rwbarton> so ifLogged doesn't "bind" usuario
12:55:17 <rwbarton> try  ifLogged :: ((?usuario :: Maybe Usuario) =>  ServerPart Response) -> ServerPart Response
12:55:32 <mekeor> thanks, parcs`
12:55:48 * hackagebot blank-canvas 0.2.0 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.0 (AndyGill)
12:56:01 <byorgey> oooooh
12:56:45 <kallisti> jsx: are you familiar with the Reader monad?
12:57:10 <jsx> rwbarton, ifLogged has  let ?usuario = loggedOrNot
12:57:46 <rwbarton> try it anyways
12:57:50 <jsx> kallisti, i thought it too cumbersome for just one list
12:57:56 <kallisti> jsx: perhaps
12:58:07 <hpc> implicit params are way more cumbersome
12:58:14 <mekeor> byorgey: what happened?
12:58:17 <kallisti> but your ifLogged is more or less something like runReader loggedOrNot $ ...
12:58:27 <byorgey> mekeor: blank-canvas
12:58:29 <kallisti> perhaps with some other stuff
12:58:47 <mekeor> byorgey: is it cool?
12:58:53 <hpaste_> “Nicolas Frisby (@0nifr)” pasted “my Forall_S is dangerous” at http://hpaste.org/67172
12:59:07 <kallisti> :t runReader
12:59:08 <lambdabot> forall r a. Reader r a -> r -> a
12:59:16 <byorgey> mekeor: I'm looking at it now, it basically gives you a nice way to use HTML5 canvas elements from Haskell
12:59:24 <kallisti> er, flip the parameters of runReader.
12:59:28 <mekeor> byorgey: heh, it's like diagrams for web =)
13:00:11 <jsx> rwbarton, it worked after addin Rank2Types flag. but why
13:00:22 <mekeor> byorgey: well, but there's no real documentation, is there?
13:00:36 <byorgey> mekeor: it's not like diagrams for web.  it's like cairo for web.
13:00:49 <byorgey> mekeor: I'm reading some slides about it right now.  http://ittc.ku.edu/csdl/fpg/Tools/BlankCanvas
13:02:54 <kallisti> byorgey: so it basically just compiles to HTML5 Canvas stuff?
13:03:14 <kallisti> oh I see
13:03:21 <byorgey> kallisti: yeah, but it's a deep embedding, so it tries to do various optimizations etc. before actually sending stuff to the browser
13:08:01 <rwbarton> jsx: i think there is a paper describing implicit parameters that probably explains why
13:30:42 <kallisti> @tell elliott this is an obligatory reminder that you should release that IRC stuff.
13:30:42 <lambdabot> Consider it noted.
13:41:59 <pqmodn> byorgey: "animation is simply a matter of sending draw commands fast enough to the browser" -- does it compile a loop in JS or just continuously stream canvas commands to the browser?
13:42:36 <byorgey> pqmodn: I think the latter.  But I don't really know any more about it than you do.
13:42:49 <kallisti> byorgey is now official blank-canvas expert until the docs generate.
13:42:57 <kallisti> let it be known.
13:42:58 <byorgey> hehe
13:43:04 <zomg> It can't use a loop in JS for that since it would lock up the browser
13:43:26 * byorgey is not sure why no one from KU ever seems to hang out in #haskell
13:43:33 <pqmodn> i'm from KU :)
13:43:36 <byorgey> oh!
13:43:37 <kallisti> yes. that makes the silly assumption that JS would have proper concurrency support.
13:43:44 <byorgey> haha, then what the heck are you asking ME for?
13:43:50 <byorgey> go down the hall and ask Andy Gill.
13:44:01 <pqmodn> but i'm only in touch with andy once in a while. i should say i *was* from there
13:44:06 <byorgey> ah, ok.
13:44:24 <cleardance> so if youre in an interview and you get asked "where do you see yourself in 10 years?" what do you answer? i might want to get some project leader or i just want to be a better developer but i dont know. what do you guys answer to this?
13:44:25 <rwbarton> I wonder why "stroke()"
13:44:36 <pqmodn> i think the larger ambition with this is a browser UI for http://ittc.ku.edu/csdl/fpg/Tools/HERMIT
13:45:18 <byorgey> pqmodn: yeah, maybe so
13:45:51 * hackagebot dpkg 0.0.2 - libdpkg bindings  http://hackage.haskell.org/package/dpkg-0.0.2 (ClintAdams)
13:45:57 <parcs`> cleardance: why are you asking here
13:46:07 <cleardance> <-clever channl->
13:46:49 <parcs`> well, where _do_ you see yourself in 10 years?
13:46:58 <zomg> cleardance: sounds pretty similar to what I answer :p
13:47:03 <lispy> cleardance: I answer "cryptonite" oh wait...wrong question
13:47:11 <zomg> I once jokingly said "I'll be a millionaire"
13:47:19 <zomg> It seemed to go ok as they laughed
13:47:20 <zomg> :P
13:47:43 <kallisti> byorgey: this looks pretty interesting.
13:48:20 <byorgey> kallisti: as the official expert, I accept and thank you for your praise.
13:48:28 <lispy> "I seem myself drifting aimlessly between jobs floating into middle-aged mediocrity until I have an existential crisis, leave my family, and sail around the world.  Why?"
13:48:30 <kallisti> I mean re: HERMIT
13:48:39 <kallisti> which I guess you are also official expert of.
13:48:48 <byorgey> yes, I am now.
13:48:49 <kallisti> apparently they want to write a Haskell-Haskell compiler?
13:48:59 <kallisti> *Haskell->Haskell
13:49:40 <kallisti> ah I see
13:49:43 <pqmodn> kallisti: yeah
13:50:45 <pqmodn> it might be Core -> Core but i think the idea is applying transformations that preserve program equivalence
13:50:52 <kallisti> yes
13:51:09 <kallisti> but this is strictly for a "model"
13:57:12 <lysgaard> When do I want to use Arrows? I understand that they superceed Monads in that they can be "paralellized" in a natural way and that they're usefull for fast parsers. Are there any other areas where they are a natural fit?
13:57:52 <kallisti> lysgaard: I use them to write point-free code on tuples. :P
13:57:56 <dmwit> I guess they're used fairly extensively in FRP.
13:58:12 <dmwit> There's some XML libraries that use arrows, but perhaps that falls under "parsing" for you.
13:59:48 <lysgaard> dmwit: Yeah, the whole reason I stumbled over them was that I was looking at hxt. They seem to let you navigate the XML tree quite nicely.
14:02:14 <Philonous> Does someone now what the status of stream-fusion is? The package is bit-rotted and the associated web site 404s. Is it deprecated, abandoned or is somebody working on it?
14:02:53 <Philonous> know*
14:04:47 <killy9999> is there a particular reason why Data.Complex is not an instanc of Num typeclass?
14:05:34 <shachaf> killy9999: Because it's a module rather than a type. :-)
14:05:40 <shachaf> Data.Complex.Complex is the wrong kind.
14:05:56 <shachaf> However, there's an instance RealFloat a => Num (Complex a)
14:06:14 <mekeor> @info Complex
14:06:14 <lambdabot> Complex
14:06:19 <dmwit> > 3 :: Data.Complex.Complex Double
14:06:20 <lambdabot>   3.0 :+ 0.0
14:06:20 <mekeor> @src Complex
14:06:21 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:06:33 <killy9999> shachf: what do you mean by wrong kind?
14:06:34 <shachaf> whoa, man
14:06:38 <shachaf> Data-type constraint.
14:07:03 <shachaf> killy9999: I mean that the kind of Num instances is * but the kind of Complex is * -> *
14:07:10 <mekeor> killy9999: 'magnitude' needs sqrt
14:07:11 <shachaf> @google what is a kind in haskell
14:07:12 <killy9999> right
14:07:13 <lambdabot> http://www.haskell.org/haskellwiki/Kind
14:07:14 <lambdabot> Title: Kind - HaskellWiki
14:07:19 <killy9999> yes, I know what is kind :)
14:07:38 <shirt> my haskell program is segfaulting. gdb says it's happening in evacuate ()
14:07:53 <killy9999> so I guess that's the reason why it's not an instance of Num
14:08:11 <killy9999> but what does the Num (Complex a) mean?
14:08:35 <shachaf> It means that (Complex a) is an instance of Num.
14:08:36 <dmwit> shirt: Try cleaning and rebuilding from scratch. If that doesn't work, look at which libraries you're using that use the FFI.
14:08:57 <killy9999> shachaf: mhm
14:09:06 <dmwit> shirt: If all else fails, hpaste some code.
14:09:18 <killy9999> and do the exclamation marks in !a :+ !a have any special meaning?
14:09:22 <geekosaur> killy9999, an example is that COmplex Integrer is a useful thing (look up Gaussian integers)
14:09:31 <geekosaur> "strict"
14:09:42 <tektik> Hi. Where are I find some well commented haskell code? I would like to learn the language, and am a complete newbie...
14:09:51 <killy9999> @where LYAH
14:09:51 <lambdabot> http://www.learnyouahaskell.com/
14:09:55 <dmwit> ?hackage xmonad
14:09:55 <lambdabot> http://hackage.haskell.org/package/xmonad
14:10:22 <dmwit> ?hackage sgf
14:10:23 <lambdabot> http://hackage.haskell.org/package/sgf
14:10:42 <mekeor> dmwit: nice; your package :)
14:10:44 <geekosaur> so Complex doesn't presume to make Complex Double the only meaningful Complex datatype
14:10:52 * hackagebot cereal-vector 0.1.0.0 - Serialize instances for Data.Vector types.  http://hackage.haskell.org/package/cereal-vector-0.1.0.0 (AdamFoltzer)
14:11:49 <mekeor> geekosaur: wouldn't Complex CReal or so be also meaningful?
14:11:50 <tektik> dmwit: are these recommendations for me ?
14:12:20 <geekosaur> mekeor, sure, but I chose one for which there are ready examples
14:12:27 <dmwit> tektik: yes
14:12:29 <geekosaur> not many real world examples of Complex CReal
14:12:50 <tektik> thanks.
14:12:58 <edwardk> Does nicholas frisby log in here?
14:13:06 * killy9999 has to think more about Complex to understand all of what was said
14:13:38 <geekosaur> Complex is a type constructor.  Complex Double is probably what you're thinking of when you think of complex numbers
14:13:58 <tektik> Bye.
14:14:10 <geekosaur> this is like Ratio:  Ratio is a type constructor, Ratio Integer is a rational number type
14:14:37 <geekosaur> (there is a convenient shorthand there, "Rational"; Complex admits to no such ready division)
14:14:46 <killy9999> geekosaur: but Complex Double has kind *, right?
14:14:53 <geekosaur> yes
14:15:12 <shirt> dmwit: cleaning and rebuilding seems to have fixed the problem. this experience is a bit worrying, i would hate to have a corrupt build running in production. i'm using cabal.
14:15:17 <eacameron> I'm upgrading to ghc 7.4.1 and this file is giving me trouble: https://github.com/CovenantEyes/Dewhiten/blob/master/FileHelper.hs. It says it can't find `Permissions` which I thought it was importing from System.Directory. Why doesn't it import `Permissions` data type?
14:15:32 <killy9999> so it's...umm can I say "partially applied" in this case?
14:15:52 * hackagebot signed-multiset 0.1 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.1 (StefanHoldermans)
14:15:53 <dmwit> shirt: Don't reuse builds from other versions of GHC or other architectures and you'll be fine.
14:15:57 <geekosaur> Complex Double is fully applied.  Complex is partially (well, not at all) applied
14:16:11 <mekeor> :k Complex Double -- killy9999
14:16:12 <lambdabot> *
14:16:16 <geekosaur> which is more or less saying the same thing as the former being kind * and the latter kind * -> *
14:16:23 <mekeor> :k Complex
14:16:23 <lambdabot> * -> *
14:16:26 <Mathnerd314> hmm, maybe we could s/Complex/Gaussian/
14:16:44 <killy9999> aha, right
14:16:45 <mekeor> heh
14:17:00 <killy9999> I get it now
14:17:20 <edwardk> Mathnerd314: that would require us breaking abs/signum
14:17:38 * killy9999 wonders why did he miss "RealFloat a => Num (Complex a)" instance declaration in the apidoc...
14:17:45 <Peaker> I wonder if (Complex (Complex Double)) is useful :)
14:17:57 <Mathnerd314> :t abs
14:17:58 <lambdabot> forall a. (Num a) => a -> a
14:18:02 <edwardk> clearly we should replace abs with quadrance
14:18:03 <Peaker> preflex, seen dcoutts
14:18:03 <preflex>  dcoutts was last seen on #ghc 5 hours, 20 minutes and 35 seconds ago, saying: well, strictly speaking they're cc linker flags
14:18:07 <shirt> dmwit: thanks, but i definitely wasn't doing that in this case, and i still managed to build an executable that was segfaulting :/
14:18:19 <edwardk> then you can have gaussian integers
14:18:36 <geekosaur> Peaker, if only that were a sensible way to built a quaternion...
14:18:59 <mekeor> :D
14:19:01 <Mathnerd314> edwardk: yeah, that would be best :-)
14:19:11 <Peaker> dcoutts, you there?
14:19:24 <edwardk> geekosaur: it works fine, with a little help
14:19:31 <byorgey> eacameron: apparently System.Directory no longer exports the Permissions constructor.  It still exports the *type* but not its constructor.
14:19:33 <killy9999> OK, thanks for all explanation about Complex
14:19:50 <dmwit> shirt: Odd. Did you by chance reinstall a library that your build depends on with the same version number but a different API?
14:19:57 <killy9999> I have some more newbie questions but they'll have to wait until tomorrow
14:20:00 <dmwit> Can't think of many other things that would hose you that way.
14:20:16 <mekeor> edwardk: why? oh of course! because for Complex numbers abs requires sqrt and thus Floating. but quadrance is also senseless because it's just \x->x*x
14:20:16 <dmwit> In any case, for production builds, perhaps it's safest for you to only push clean builds out into the production world.
14:20:25 <byorgey> eacameron: however, it also now exports something called 'emptyPermissions'
14:20:33 <byorgey> eacameron: so just delete 'noPermissions' and use 'emptyPermissions' instead
14:20:55 <edwardk> mekeor: square the real and imaginary parts separately
14:21:11 <mekeor> oh oops
14:21:19 <edwardk> mekeor: so quadrance works just fine
14:21:19 <shirt> dmwit: nope. but recently i did do a Control-C during a 'cabal build'
14:21:30 <mekeor> edwardk: wait.
14:21:32 <edwardk> and can be defined even for the gaussian integers
14:21:51 <mekeor> edwardk: anyway. quadrance is still = \x -> x*x -- !
14:21:52 <eacameron> byorgey: yeah I noticed the emptyPermissions thing...so there's no way to write my own function that uses the Permissions constructor?
14:22:10 <byorgey> eacameron: not any more.
14:22:28 <mekeor> edwardk: i mean, for complex numbers, too.
14:22:29 <byorgey> eacameron: you can match on or update individual permissions using record syntax.
14:23:04 <byorgey> eacameron: see the example in the documentation, http://hackage.haskell.org/packages/archive/directory/1.1.0.2/doc/html/System-Directory.html#g:5
14:23:06 <eacameron> byorgey: interesting...so it's purely for internal use. interesting. thanks. I guess "No" is an answer, just not the one I was hoping for ;)
14:23:13 <mekeor> edwardk: am i missing something?
14:23:19 <edwardk> mekeor: \(a :+ b) -> a*a + b*b
14:23:22 <rwbarton> mekeor: it's x times the complex conjugate of x
14:23:37 <byorgey> eacameron: what would you want to do with the Permissions constructor that you can't do now?
14:23:58 <byorgey> it's not purely for internal use.  it's just a bit abstract.
14:24:14 <eacameron> byorgey: I was hoping to write a function getPermissionsSafely :: FilePath -> IO Permissions that did the check for existance for me
14:24:35 <byorgey> eacameron: sure, you can do that
14:25:20 <eacameron> byorgey: Ahh..I just can use `Permissions` as the constructor...but I can use the record functions and emptyPermissions - - Got it
14:25:28 <eacameron> byorgey: *can't
14:25:41 <byorgey> eacameron: you can use the Permissions type just fine.  Right, you just can't directly constructor one.
14:25:42 <mekeor> edwardk: quadrate (a :+ b) = (a+b·i)·(a+b·i) = a·a + a·b·i + a·b·i - b·b = (a*a-b*b :+ 2*a*b*i)
14:25:47 <byorgey> *construct
14:27:07 <mekeor> i think i misunderstood something… howbeit.
14:28:03 <edwardk> mekeor: i'm just looking at quadrance in the plane, i is just a basis vector here and has no special properties in the result
14:28:16 <Mathnerd314> quadrate (a :+ b) = (a+b·i)·(a-b·i) = a·a + a·b·i - a·b·i + b·b = (a*a+b*b :+ 0)
14:28:37 <edwardk> Mathnerd314: thanks =)
14:28:58 <mekeor> Mathnerd314: why (a+b·i)·(a-b·i) ??
14:29:03 <mekeor> why minus?
14:29:16 <Mathnerd314> mekeor: because that's how it's defined :p
14:29:25 <edwardk> mekeor: you conjugate the second
14:29:33 <hpc> https://duckduckgo.com/?q=complex+conjugate
14:29:37 <dmwit> mekeor: Conjugating the second one is a trick that gives you back a real number. =)
14:29:44 <rwbarton> it's the squared norm
14:29:46 <rwbarton> not the square
14:29:55 <mekeor> ah
14:30:17 <mekeor> hmmm… i'll never end learning =)
14:30:53 * hackagebot hjsmin 0.1.0 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.0 (AlanZimmerman)
14:31:11 <hpc> and if you take the square root of the conjugate times the original, you get the magnitude
14:31:17 <acowley> Is anyone aware of any work continuing on Michael Spivy's "Algebras for combinatorial search"?
14:31:22 <rwbarton> (to be fair, almost no one uses the word "quadrance")
14:31:26 <acowley> Spivey that is
14:32:24 <edwardk> mind you i still think having abs (or quadrance) in there is a bad idea, but quadrance is less of a bad idea than abs
14:32:35 <acowley> quadrance is fantastic, square roots are grotty and abs is problematic
14:33:26 <edwardk> well, the remaining issue with quadrance is that its scalar, and shouldn't be re-embedded into the larger vector space
14:33:41 <edwardk> but the type signature of abs forces it back up there
14:34:01 <acowley> Why is embedding it into the larger space bad?
14:34:12 <dmwit> H98 can't really do better. You need at least MPTC or TF.
14:34:31 <dmwit> (H2010 can't really do better either, for the same reason.)
14:34:43 <mekeor> dmwit: MPTC? TF?
14:34:50 <mekeor> type families?
14:34:52 <dmwit> multi-parameter type classes, type families
14:34:56 <mekeor> ah
14:35:06 <dmwit> They're interchangeable for many uses.
14:35:08 <edwardk> acowley: may not always exist, what if i don't have any single distinguished vector like that, or i want a classic free module where you can only have finitely many non-zeros, but have an infinite dimensional basis
14:36:18 <eacameron> byorgey: thanks!
14:36:36 <acowley> edwardk: stop working with funny vector spaces and stick to simpler problems?
14:36:38 <acowley> :P
14:36:39 <byorgey> eacameron: sure!
14:36:46 <edwardk> acowley: not everything is a computer vision problem =P
14:36:59 <edwardk> acowley: =)
14:37:18 <byorgey> if only everyone would just stick to simpler problems we could do away with all this silly, wasteful, confusing "research" stuff!
14:37:26 <dmwit> Step 1: shoehorn your hard problem into a computer vision problem.
14:37:29 <edwardk> acowley: but even when playing around with support vector machines you often kernelize to infinite dimensional vector spaces you can't represent directly
14:38:01 <edwardk> acowley: and those come up pretty often even in boring machine learning problems
14:38:17 <hpc> dmwit: step 2: use regexes
14:38:22 <hpc> step 4: fix the off-by-one error
14:38:27 <acowley> edwardk: I suppose, but I'd try to arrange for a situation where the embedding was [q,0,0…..]
14:39:46 <edwardk> well, the embedding there is funny, because i really have a scalar, because I want to be able to multiply it by the elements of my vector space. even if i don't have a multiplication defined _on_ my vector space.
14:40:19 <edwardk> acowley: consider moving from Num to something that lacked (*), you can still define quadrance
14:41:04 <edwardk> acowley: my point is the embedding is an extra property not satisfied by all spaces and its a fairly unnatural wart to bolt it on.
14:41:41 <acowley> s/wart/beauty mark/
14:42:48 <mekeor> why is there no 'instance Enum a => Enum (Ratio a) where' ?
14:42:52 <acowley> I am a bull in a math shop
14:43:11 <mekeor> @remember acowley I am a bull in a math shop
14:43:12 <lambdabot> I will remember.
14:43:35 <monochrom> beauty vs wart: http://spikedmath.com/499.html :)
14:43:58 <dmwit> ghci++ just typed "deriving instance Show Flag" and it actually worked
14:44:28 <mekeor> dmwit: O_O
14:44:54 <dmwit> mekeor: inorite?
14:44:58 <dmwit> ghci is magic these days
14:45:31 <sizz_> how do I pick out all the integers from a list of integers and rationals?
14:45:48 <Mathnerd314> dmwit: all it needs is some way to write out definitions to a file, and we've got a pretty useful IDE... :-)
14:45:54 <dmwit> sizz_: What's the type of the input?
14:46:12 <acowley> Mathnerd314: Idris can do that, maybe the code could be borrowed?
14:46:50 <danharaj> how long until ghci is an interactive theorem prover that outputs haskell code to file?
14:46:51 <Saizan> it's a bit unfair to blame math for the weird value of some function
14:46:51 <danharaj> :p
14:47:48 <Mathnerd314> danharaj: I don't think it'll include a theorem prover for a while
14:47:58 <Mathnerd314> but there's already djinn
14:48:35 <sizz_> dmwit: I'm trying to build an efficient function to get the factors of a number 'n': factor n = [ x | x <- [n,n/2..n/n], mod n x == 0 ]
14:49:13 <monochrom> Saizan: actually I now think the Borwein integrals are beautiful, or at least ok, not ugly. it deviates from pi/2 iff the corresponding harmonic-like sum is below 1, that's nice enough
14:49:21 <monochrom> err, s/below/above/
14:50:04 <dmwit> sizz_: Perhaps you'd better use `div` instead of (/).
14:50:18 <mekeor> sizz_: are you sure you know what [n,n/2..n/n] does?
14:50:28 <dmwit> Also, what mekeor said.
14:50:38 <mekeor> sizz_: also replace n/n with 1
14:50:40 <monochrom> anyway, obtopic: haskell does not need an IDE, haskell needs an IDLE: integrated development lazy environment!
14:51:16 <mekeor> monochrom: haskell first of all needs an 'instance Enum a => Enum (Ratio a)' !
14:51:20 <dmwit> (I know this is a joke, but Python already stole the name IDLE. No need to make things even *more* confusing...)
14:51:41 <monochrom> oh there is a functional pearl for that!
14:52:30 <monochrom> oh, IDLE is already taken? then we can try IDNE: integrated development non-strict environment!
14:54:01 <mekeor> lol. but lazy is more than just non-strict! lazy also has sharing, right?
14:54:05 <monochrom> Enum (Ratio a): http://web.comlab.ox.ac.uk/people/Jeremy.Gibbons/publications/rationals.pdf
14:54:21 <acowley> Can we retroactively acronymize ¯\_(ツ)_/¯
14:54:38 <acowley> because that's what I want my IDE to be referred to as
14:54:40 <mekeor> monochrom: cool.
14:54:58 <monochrom> perhaps ILDE is acceptable
14:55:44 <Mathnerd314> GLIDE = Glasgow Lazy IDE
14:55:45 <mekeor> or HILDE
14:55:59 <mekeor> or HIDE
14:56:06 <acowley> Mathnerd314: those of us who did 3dfx coding will have flashbacks
14:56:08 <hayashi> Mathnerd314: Not to be confused with Glide, the driver stack for 3Dfx graphics cards
14:56:10 <hayashi> ...
14:56:12 <hayashi> Lol
14:56:12 <acowley> hah
14:56:17 <acowley> there's at least two of us!
14:56:39 <Mathnerd314> acowley: it's capitalized, so no possibility of mixing them
14:56:42 <hayashi> I've only ever used voodoos as a consumer, though, never programmed for one >_>
14:56:59 <monochrom> acronyms need namespacing to avoid these clashes. Haskell.IDLE != Python.IDLE etc
14:57:07 <mekeor> :D
14:57:14 <hayashi> any attempt to combine a hayashi with graphics programming reacts to form a horrific mess and a dead project
14:57:33 <acowley> hayashi: You missed out! Manually managing multiple texture memory buffers is very rewarding.
14:57:49 <acowley> Mathnerd314: I would pronounce it "GLIDE" when angry
14:57:56 <acowley> (the 3Dfx API that is)
14:58:01 <monochrom> eventually we're headed for org.haskell.IDE etc :)
14:58:06 <hayashi> LIDL: Lazy Integrated Development Lounge.  Not to be confused with ALDI, or A Lazy Development Integration, or Netto, which is Scandinavian for value.
14:58:27 <hayashi> monochrom: Java package name conventions! They hurt!!
14:58:28 <Mathnerd314> acowley: plus, Glide is dead, killed by OpenGL
14:58:34 <mekeor> hayashi: :D
14:58:35 <monochrom> hehehe
14:59:03 <acowley> Mathnerd314: lots of things have been killed by OpenGL. hayashi's projects, for example.
14:59:17 <shapr> I think someone was once killed by an OpenGL book too.
14:59:25 <monochrom> hahaha
14:59:34 <acowley> Was it the SuperBible? That could do some damage.
14:59:44 <hayashi> I hardly get any further than software SDL, never mind OpenGL (which I've tried once or twice, with similarly failed results) v_v
14:59:45 <Mathnerd314> anyways, does someone have a link to the GHCi source code?
15:00:26 <shapr> Superbible: Shipping Weight: 3.8 pounds from http://www.amazon.com/OpenGL-SuperBible-Edition-Richard-Wright/dp/0672326019
15:00:50 <acowley> Mathnerd314: I presume it's here https://github.com/ghc/ghc/tree/master/compiler/ghci
15:00:56 <hayashi> monochrom: Besides, what you really mean is org.haskell.development.frameworks.providers.ide.GenericIdeFactoryStubProviderFactoryFactory extends org.haskell.development.frameworks.providers.ide.AbstractGenericIdeFactoryStubProviderFactoryFactory
15:01:07 <monochrom> onoes
15:02:18 <Mathnerd314> acowley: more like https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs
15:02:30 <Mathnerd314> but at least it's the right tree
15:04:11 <dmwit> How about DIDE? What it stands for is undetermined until it's necessary for you to know.
15:04:40 <dmwit> Axiom: It isn't yet necessary for you to know.
15:05:11 <hayashi> I think I just DIDE and went to Sovngarde.
15:05:52 <shachaf> I hope "DIDE" is the name of a trigonometry framework.
15:05:54 <shachaf> "DIDE for your SINs".
15:08:52 <jonkri> can emacs with haskell-mode build with cabal? for some reason, emacs only finds my library if i install it with cabal, and not when i build it with C-c C-l. i see something on the wiki about cabal-dev support in inferior haskell mode, but i'm guessing that's not what i'm looking for
15:10:48 <acowley> jonkri: I usually rely on putting GHCi in the right directory, or using :set -isrc (or what have you)
15:14:01 <relation> hi, i'm just wondering, are functions typeable in Data.Typeable sense?
15:14:16 <shachaf> > typeOf (show :: Int -> String)
15:14:17 <lambdabot>   Int -> [Char]
15:14:23 <shachaf> > typeOf (show :: Show a => Int -> a)
15:14:24 <lambdabot>   Couldn't match expected type `a'
15:14:24 <lambdabot>         against inferred type `[GHC.Types....
15:14:26 <monochrom> yes
15:14:31 <shachaf> Er.
15:14:37 <shachaf> > typeOf (show :: Show a => a -> String)
15:14:38 <lambdabot>   () -> [Char]
15:14:50 <relation> good news, thanks
15:17:25 <jonkri> acowley, that did the trick :)
15:17:47 <jonkri> is there some way i can set :set -isrc globally for the project? OPTIONS_GHC?
15:19:02 <acowley> Put a .ghci file in the project directory
15:19:24 <shachaf> echo ':!rm -rf ~' > .ghci
15:19:24 <mysticc> @hoogle symbol
15:19:25 <lambdabot> Text.Read.Lex Symbol :: String -> Lexeme
15:19:25 <lambdabot> Text.Read Symbol :: String -> Lexeme
15:19:25 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
15:19:35 <shachaf> Does ghci really run arbitrary .ghci files?
15:20:19 <johannes___> hi
15:20:34 <jonkri> shachaf, i sincerely hope that command does not execute
15:20:49 <acowley> I sincerely hope nobody tries
15:20:56 <shachaf> You are sincerely wrong. :-(
15:21:04 <acowley> there was some dustup about the issue a while ago
15:21:18 <johannes___> so, is haskell a good AI programming language or am i stuck with lisp
15:21:25 <ion> yes
15:21:29 <acowley> johannes___: yes
15:21:31 <jonkri> shachaf, i could have been a complete unix newbie, just trying to get haskell to work
15:22:07 <shachaf> jonkri: You mean I should've put a bigger warning next to that?
15:22:11 <shachaf> Fair enough.
15:22:18 <shachaf> PEOPLE: DON'T DO THAT
15:22:27 <ion> JUST KIDDING. DO THAT.
15:22:51 <shergill> lol
15:23:28 <companion_cube> echo ':!rm -rf /home/shachaf/' > .ghci, then
15:24:01 <shachaf> companion_cube++
15:24:17 <jonkri> shachaf, yes, that's what i meant
15:25:24 <dmwit> Is there something like "darcs amend-record" that lets you rewrite the description of a patch?
15:28:20 <dmwit> oh, -m still works with amend-record
15:28:23 <jonkri> hmm, i have a .ghci file that contains ":set -isrc" (without quotes) in my project directory, which ghci cd's into in order to load "src/...", but for some reason -isrc is not set. if i set it manually, it works any ideas why?
15:28:45 <kallisti> dmwit: just never make mistakes. that's what version control is all about.
15:29:09 <jonkri> ghc 7.0.4 by the way
15:29:16 <dmwit> Once, I went so far as to *publish* a mistake!
15:29:25 <shachaf> dmwit: darcs amend-record --edit-long-comment?
15:29:42 <geekosaur> so far as I know, just telliing it to load src/foo does not load src/.ghci, just ./.ghci
15:29:51 <dmwit> shachaf: Close, but I wanted to edit the short comment (which can be done with -m, I discovered).
15:30:08 <shachaf> dmwit: The short comment is just the first line of the long comment.
15:30:21 <dmwit> Oh. Well, that's a good tip, then.
15:30:55 <shachaf> git is so much simpler!
15:31:12 <dmwit> ha!
15:31:14 <Mathnerd314> acowley: are you sure Idris can write out files? all I see is addProof
15:32:00 <acowley> Mathnerd314: doesn't that write to the file?
15:32:14 <acowley> Mathnerd314: or is the issue that it's not as much as you wanted?
15:32:29 <Mathnerd314> it doesn't do anything besides proofs
15:32:42 <Mathnerd314> it does write to the file though
15:33:08 <acowley> hm
15:33:35 <acowley> I have to admit, when skimming the Idris docs I assumed he meant basically any term by "proof"
15:35:35 <hpaste_> “Nicolas Frisby (@0nifr)” pasted “subverting Data.Constraint.Forall to coerce between Int  and Char” at http://hpaste.org/67180
15:40:35 <kallisti> ..my math homeworks wants me to prove that f . id = f  and id . f = f
15:40:37 <kallisti> -_-
15:40:59 <Mathnerd314> kallisti: just say "It's a Category" :p
15:41:06 <hpc> lol
15:41:26 <kallisti> unfortunately I only have the basics to work with.
15:41:35 <hpc> kallisti: can you say it's a free theorem?
15:41:58 <kallisti> hpc: nope
15:42:05 <Mathnerd314> kallisti: how did they define id and (.)?
15:42:08 <kallisti> I can just prove it with algebra. :P
15:42:12 <kallisti> actually.
15:42:22 <kallisti> I was going to do a bunch of universal quantification stuff, since that's normally how these proofs go.
15:42:25 <kallisti> but the algebra works too.
15:42:32 <kallisti> ("algebra")
15:42:33 <acowley> Dana Scott, at a talk today, told a story about a prequel to http://www.amazon.com/A-B-Marko-Petkovsek/dp/1568810636/ref=sr_1_1?s=books&ie=UTF8&qid=1334702496&sr=1-1 called A = A that was just a little pamphlet and not that interesting.
15:42:52 <kallisti> as in (f . id)(x) = f (id (x)) = f (x)
15:42:56 <kallisti> QED. :P
15:43:47 <acowley> We prefer the BANANAPHONE notation around here
15:44:48 <kallisti> they don't spell it "id" since it's not universally quantifiied:  f : A -> B  and they use i sub-A and i sub-B to refer to the identitiy functions on those sets.
15:45:24 <acowley> They have big lambdas
15:50:46 <dmwit> NOOOOOO! I had my todo page only set to show me the first 50 things and Dana Scott's talk today was the 52nd thing on the list!!!
15:51:03 <acowley> dmwit: are you going to tomorrow's?
15:51:09 <dmwit> YES!
15:51:12 <acowley> Also, stop doing so many things
15:51:12 <dmwit> And Thursday's, too.
15:51:13 <acowley> that's insane
15:51:27 <dmwit> yes, I need to clean up my list a bit.
15:51:30 <acowley> I'm not sure if I do 50 things in a month
15:51:33 <acowley> much less a day
15:51:42 <shachaf> acowley: This is dmwit's "lifetime todo list".
15:52:02 <dmwit> Many of them have due dates in the past, and many of them have been finished but I haven't marked them so yet.
15:52:35 <tgeeky> dmwit: push http://www.structuredprocrastination.com/; read; laugh!
15:52:59 <dmwit> heh
15:53:03 <dmwit> First line and I already like it.
15:53:19 <irene-knapp> is this a website which deliberately never loads, or is my setup w— oh, it loaded
15:53:54 <tgeeky> it may not apply to you, but if it does, I think it's a surprisingly good piece of philosophy
15:54:12 <tgeeky> for whatever that's worth
15:56:35 <acowley> tgeeky: that is quite awesome
16:05:33 <Mathnerd314> hmm, in Idris f . id = f is just refl
16:07:48 <mysticc> How to capture eof in parsec
16:08:13 <copumpkin> Mathnerd314: really?
16:08:32 <dmwit> mysticc: eof :: Parser ()
16:08:38 <copumpkin> Mathnerd314: oh, I guess that isn't too surprising
16:08:43 <Mathnerd314> copumpkin: I can't really tell, but it seems that way
16:09:01 <dmwit> actually, eof :: (Stream s m t, Show t) => ParsecT s u m ()
16:11:00 <mysticc> dmwit: How to match a newline or eof .. <|> doesn't help
16:11:49 <dmwit> mysticc: This sounds like an XY problem.
16:12:01 <dmwit> Why don't you hpaste some code, say what you tried, what you expected, and what happened instead.
16:12:46 <mysticc> dmwit: statement : anychar newline | anychar eof
16:13:05 <shirt> dmwit: hm... turns out it wasn't related to a bad build... after a clean build i am getting: "internal error: evacuate(static): strange closure type 17732"
16:13:59 <dmwit> shirt: In order of most likely to least likely: 1. You, or one of the libraries you depend on, screwed up using the FFI. 2. You're using an unstable version of GHC. 3. You found a genuine bug in GHC.
16:14:59 <shachaf> dmwit: It's probably more likely that you're unsafeCoercing or something -- no FFI involved -- than that it's a GHC bug. :-)
16:15:02 <Eduard_Munteanu> copumpkin: mm... f . id -> (f . id) x -> f (id x) -> f x -> f ?
16:15:25 <dmwit> Oh, yes, I completely forgot about unsafe*. I'd put that as 1.5, then.
16:15:53 <dmwit> Eduard_Munteanu: That assumes both eta-expansion and eta-contraction. Does Idris really have both of those?
16:16:25 <Eduard_Munteanu> dmwit: I guess it should, I don't mean extensionality though.
16:16:37 <Eduard_Munteanu> (if that's what you're thinking of)
16:17:52 <dmwit> Maybe I am. I'm not an expert.
16:18:36 <Eduard_Munteanu> I mean, it's not like I'm saying f x = g x -> f = g, but eta conversions should be quite orthodox.
16:26:23 <relation> is there a way to guarantee that trace's first argument will be evaluated?
16:26:52 <shachaf> relation: You mean printed?
16:27:11 <relation> shachaf: y
16:27:18 <shachaf> ?
16:27:29 <relation> shachaf: yes, printed
16:27:53 <dmwit> Yes, trace's first argument will be printed as soon as its second argument is demanded.
16:27:56 <shachaf> The string will be printed when the (trace x y) thunk is evaluated.
16:28:54 <relation> and so the second argument do not have to be dependent on the first?
16:29:37 <dmwit> No. In fact it's common for trace's first argument to be a literal String.
16:30:24 <relation> ok, thanks
16:30:32 <dmwit> (here, "no" means "I agree with your negative", not "I contradict you")
16:33:35 <lispy> hi
16:34:05 <shirt> dmwit, shachaf: i disabled an FFI library that i was using, and i'm not using any unsafe* functions... i think this might be number 3 :\
16:34:28 <lispy> Now that type nats are in ghc head, who will be the first to fork data.vector to make it type indexed?
16:34:49 <dmwit> shirt: Well, make the smallest program you can that exhibits the problem and tell GHC Trac about it.
16:35:40 <shirt> dmwit: yeah, i'll see what i can do... thanks for the help
16:37:39 <thoughtpolice_> lispy: a good question! i think it may be worth reviving copumpkin's vector-static library now
16:37:57 <thoughtpolice_> although right now i had a little bit of ugliness when i was playing with it. too much unsafeCoerce for my tastes :P
16:37:59 <copumpkin> yeah, that might be worth doing :) someone should do it
16:38:05 <shirt> dmwit: maybe i am running into the same bug as this: http://hackage.haskell.org/trac/ghc/ticket/5085
16:38:36 <kallisti> while we're at it, "someone" should fork bytestring and parameterize on encoding.
16:38:57 <kallisti> or maybe text? I'm not sure which is more appropriate.
16:39:14 <irene-knapp> eh?  bytestring is what it says, not really meant for text
16:39:17 <irene-knapp> yeah, text
16:39:34 <kallisti> rewrite text to work with arbitrary encodings would be somewhat difficult though
16:40:16 <dmwit> shirt: Well, if you have a more reliable way to reproduce the problem, it sounds like that would be very valuable, even it's the exact same problem as that ticket.
16:40:56 <dmwit> kallisti: There was a GSOC experiment about using UTF8 behind the scenes in Text, but it sounded like it turned out not to be that big of a win.
16:41:59 <thoughtpolice_> dmwit: it was a win, but also a loss. some things got faster, others slower. but jasper did upstream some of his general perf improvements anyway
16:42:16 <thoughtpolice_> AFAIK, text going to utf8 in the future is still a possibility, but the results were somewhat inconclusive, not necessarily bad
16:42:38 <thoughtpolice_> edwardk probably has more to say there
16:43:20 <edwardk> the general performance improvements made it into mainline Data.Text.
16:43:41 <copumpkin> edwardk: did you end up getting the optional exposed internals, too?
16:43:51 <edwardk> Overall the memory utilization didn't change appreciably going to UTF8 and interop with libraries like iconv became a lot more complicated
16:44:16 <edwardk> and the only thing that wound up faster (other than via the performance tuning) was converting back and forth to utf-8
16:44:23 <edwardk> everything else slowed down
16:44:34 <c_wraith> Isn't that the main thing people do, though?
16:44:37 <dmwit> That actually surprises me somewhat. I thought UTF8 was sort of the default encoding to pick; but you seem to be saying that at least iconv chose UTF16 instead.
16:44:39 <copumpkin> this is why we need your ropey representation
16:44:58 <edwardk> dmwit: exactly
16:45:10 <copumpkin> dmwit: I think some of the older unicode projects were created back when unicode _did_ fit into 16 bits
16:45:15 <copumpkin> then were retrofitted with UTF16
16:45:19 <copumpkin> once it didn't anymore
16:45:25 <edwardk> dmwit: you can do a little bit of utf8 stuff with iconv, but most of the stuff needs utf16
16:45:29 <dmwit> copumpkin: aha
16:45:40 <copumpkin> dmwit: much like java's shitty characters
16:46:10 <dmwit> Easy stuff is hard. Text, dates, command-line parameters, names.
16:46:21 <edwardk> anyways, since it didn't help, and it made interop with libraries hard, it was ultimately shelved
16:46:39 <copumpkin> time is the worst
16:46:39 <edwardk> since after it was converted we then would have had to convert text-iconv, and all of the other libraries
16:46:40 <mikeplus32> i dream of a world where type String = Text :)
16:46:44 <thoughtpolice_> dates are basically the worst
16:46:44 * copumpkin never wants to work with time
16:46:53 <copumpkin> mikeplus32: I don't
16:47:07 <edwardk> I don't want to work with time because I want to strangle someone every time I'm forced to use the library
16:47:12 <byorgey> dmwit: colors.
16:47:15 <thoughtpolice_> C# has a great date library from MS, with an awesome API. but jesus, working with dates just sucks so bad no matter what
16:47:16 <dmwit> colors
16:47:28 <mikeplus32> copumpkin: a world where the default string type isn't a linked list of Char?
16:47:35 <byorgey> we can't even agree on the *spelling* of colors.
16:47:47 <edwardk> byorgey: =)
16:48:01 <edwardk> byorgey: i need to finish packaging up my colorimetry package, then you can use it in diagrams ;)
16:48:15 <byorgey> edwardk: what the heck is colorimetry?
16:48:38 <edwardk> who needs 3 colors, just provide the spectral density curve and be unambiguous ;)
16:48:39 <byorgey> I mean, I can vaguely guess from my knowledge of greek, but...
16:49:22 <byorgey> oh, of course, I see now
16:49:25 <dmwit> byorgey: From Wikipedia, it seems to basically be a function from wavelength to reflectiveness.
16:49:25 <byorgey> =P
16:49:48 <copumpkin> LMWTFY?
16:49:55 <copumpkin> dmwit's your wikipediabot
16:49:56 <byorgey> circle 2 # fillColor (\wavelength -> wavelength^2 / pi + ...)
16:50:05 <dmwit> heh
16:50:16 <shirt> One advantage String has over Text is that you can do pattern matching, case str of "foo" -> ...
16:50:41 <thoughtpolice_> doesn't OverloadedStrings enable pattern matching on those types as well?
16:50:45 <edwardk> basically take the visible spectrum, figure out the response of to different light levels, that gives you photopic (normal light level) and scotopic (rods only, very very low light level) response curves, and then you can model the observer's cone responses as well by wavelength. usually done with CIE tristimulus values, but you can actually approximate the real responses by each of the usual 3 cone types
16:51:05 <shirt> thoughtpolice_: nope
16:51:19 <thoughtpolice_> i could have sworn it did, but hm
16:51:34 <byorgey> edwardk: wow, awesome.
16:52:07 <byorgey> edwardk: I see how that would be necessary to accurately model color perception with varying lighting.
16:52:23 <byorgey> edwardk: and you're saying that actually gets used in computer graphics applications?
16:52:53 <edwardk> byorgey: so you have the spectral density curves of different illuminants, the efficiency functions for the rods and cones, and you can model decent spectroscopy of different materials since reflectance and illuminance tends to yield very different curves
16:53:09 <byorgey> ok, now you lost me =)
16:53:18 <thoughtpolice_> shirt: actually i was right, it does
16:53:26 <edwardk> byorgey: some. PBRT has a simple model of what i just described
16:53:35 <edwardk> so does luxrender
16:53:36 <hpaste_> thoughtpolice pasted “overloaded strings shenanigans” at http://hpaste.org/67189
16:54:01 <edwardk> byorgey: but yeah you need it if you want that washed out look under flourescents that people get ;)
16:54:07 <thoughtpolice_> shirt: so that goes for text as well, but i doubt this lets you do partial matches a la "foo" : rest
16:54:11 <thoughtpolice_> so it's not quite as first class
16:54:57 <byorgey> edwardk: hehe, I had quite enough of looking all green and mottled and sickly in 9th grade gym, no need to go modeling it again =P
16:55:06 <edwardk> byorgey: different illuminants have different spectral density curves, they aren't just linear combinations of R G and B, so the same material may look very different under different lighting conditions, even when those lights have the same white point.
16:55:16 <Pseudonym> Colour perception tends to be only coarsely modelled in most entertainment applications, such as movies and games.
16:55:22 <byorgey> edwardk: makes sense
16:55:30 <Pseudonym> But it's important in, say, designing theatre lighting.
16:55:35 <shirt> thoughtpolice_: hm... cool. did not know this. gonna use this in my code right now!
16:56:02 * hackagebot stm-conduit 0.4.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.4.1 (ClarkGaebel)
16:56:10 <Pseudonym> To expand on what edwardk just said, consider why mixing red and blue gives violet, given where they lie on the spectrum.
16:56:57 <Pseudonym> You can't really understand that without considering the spectral response of rods and cones.
16:57:31 <copumpkin> it'd be cool to write software that had automated adjustments for different types of colorblindness
16:57:45 <edwardk> byorgey: so basically what i have is a bunch of piecewise cubic curves for different standard and non-standard illuminants. (i need the interpolation so i can take derivatives with respect to wavelength for AD), and different (non-)standard observer models for what the eye response acts like, and different color working spaces (modeling the output gamut of your monitor)
16:58:04 <Pseudonym> copumpkin: Difficult to do for print.
16:58:29 <Pseudonym> Because two different ink mixes can look the same, but have vastly different spectra.
16:58:37 <copumpkin> ah
16:58:49 <Pseudonym> Think of a pure violet versus a mix of red and blue.
16:59:28 <edwardk> Given the spectroscopy info for your ink you can at least measure perceptual differences for different observers, protanopic, deteranopic, etc.
16:59:37 <shergill> is there such a thing as pure violet which is different from a mix of red and blue?
17:00:10 <Pseudonym> Pure 400nm light is violet.
17:00:19 <shergill> ah ok
17:00:22 <Pseudonym> So is an appropriate mix of 460nm and 700nm.
17:00:32 <geekosaur> shergill, there are chemicals that reflect violet, distinct from mixes of chemicals that reflect red and blue
17:00:41 <dmwit> ccasin and I briefly discussed how one would go about making an HDMI-to-HDMI adapter that corrected for a particular kind of color-blindness. We had significantly less expertise than you people, though. =P
17:01:05 <geekosaur> the resulting spectra differ because the latter also reflect other colors, usually  in a different way
17:01:07 <shergill> so color blindness works on the spectrum level?
17:01:10 <dmwit> Best we thought of was to take a color wheel and just contract it a bit away from one of the colors that they were blind to.
17:01:13 <edwardk> shergill: you have 3 kinds of cones, so even that exact wavelength is perceived by using the red and blue cones though
17:01:28 <edwardk> shergill: no, colorblindness is based on lacking one or more of those kinds of cones
17:02:00 <shergill> edwardk: right, that's what i was wondering. as in believed the perception was limited by the cones, which operated only on rgb values
17:02:14 <shergill> *i believed
17:02:29 <edwardk> shergill: its limited by the cones, but cones don't respond to R G and B precisely
17:02:38 <geekosaur> http://www.visibone.com/colorblind/
17:02:40 <shergill> ah ok
17:02:59 <hpc> cones have sensitivity curves
17:03:16 <hpc> there's in fact a narrow band in the middle of green where both red and blue are sensitive at the same time
17:03:28 <hpc> there is no "true green" that your eyes can percieve
17:03:44 <hpc> unless you cheat and desensitize the other cones with bright purple
17:04:58 <edwardk> ultimately no mixture of a finite number of actually representable colors can cover the entire color gamut. we can choose more source colors, or use imaginary colors that go outside of the physical gamut, but ultilately you have some unrepresentable colors or non-existent colors in the mix
17:05:33 <edwardk> effectively: http://en.wikipedia.org/wiki/File:CIExy1931.png isn't a polygon
17:05:37 <danharaj> Non-lineaaaar spaceesesssss
17:05:43 <danharaj> (or rather nonconvex)
17:05:49 <mgsloan> edwardk: That sounds amazing!  One interesting thought a friend of mine had is that you can use filters in front of your eyes in order to distinguish spectra differences that you aren't typically able to perceive - distinguishing, eg, natural and artificial colors
17:05:49 <lambdabot> mgsloan: You have 11 new messages. '/msg lambdabot @messages' to read them.
17:05:53 <edwardk> its convex
17:05:55 <danharaj> way no it's convex
17:06:00 <danharaj> yes I am very tired.
17:06:02 <edwardk> just not polygonal
17:06:03 <mgsloan> wow, I guess I'm popular!
17:06:33 <edwardk> mgsloan: that works.
17:06:46 <danharaj> you could come up with a sequence of approximating polygons
17:06:49 <Pseudonym> mgsloan: You can do that. In fact, you kind of already have.
17:07:00 <danharaj> and standardize that sequence.
17:07:11 <edwardk> Pseudonym: the pigments in the cones?
17:07:30 <Pseudonym> I was thinking of materials which down-convert UV into the visible spectrum.
17:07:42 <copumpkin> what we really need is a big-ass laser
17:07:44 <Pseudonym> Like "whiter than white" laundry detergents.
17:07:51 <Pseudonym> Or a big ass-laser.
17:08:10 <copumpkin> this will do: http://www.wickedlasers.com/lasers/Spyder_III_Pro_Arctic_Series-96-37.html
17:08:16 <edwardk> Pseudonym: ah the phosphorescent materials used in fluourescent lighting, etc.
17:08:21 <Pseudonym> Yeah.
17:08:24 <edwardk> yeah
17:08:28 <kallisti> big-ass laser or big ass-laser? :P
17:08:44 <Pseudonym> A former boss of mine was working on a material which would up-convert IR into the visible spectrum.
17:08:46 <copumpkin> I'd prefer not to get that thing near any part of my body
17:09:01 <Pseudonym> Obviously the intensity would decrease.
17:09:20 <Pseudonym> But the plan was to make safety vests which glow, powered only by body heat.
17:09:25 <edwardk> sadly they don't tend to use fluorescent colors in printing, due to the fact that they tend to shift in color over time and not age well
17:09:45 <mee> Pseudonym, didn't "HyperColor" do that w/ shirts in the 80s?
17:09:45 <edwardk> Pseudonym: thats hard. mostly it goes the other way
17:09:55 <rasfar> this is hilarious, when i left yesterday the discussion was colour perception!  is this still #haskell or am i dreaming?
17:10:07 <Pseudonym> mee: No, they only changed colour. They didn't glow.
17:10:13 <mee> ah
17:10:22 <Pseudonym> edwardk: Yes. He was also the highest-funded physical chemist at the university.
17:10:31 <Pseudonym> And the dean of research and innovation.
17:10:36 <Pseudonym> If anyone could do it, he could.
17:11:14 <edwardk> its easy to fluouresce down, heck, thats why you can use a little bit of mercury vapor and mix some chemicals to shift into the range of each type of cone and wham ceiling lights.
17:12:08 <edwardk> going up means you need two-photon absorption, etc
17:12:54 <Pseudonym> If I understood the details, I'd explain them to you.
17:13:12 <edwardk> np
17:13:29 <Pseudonym> I understood that it was a nanomaterial and depended on quantum mechanics in some crucial way.
17:13:33 <Pseudonym> I may have misunderstood.
17:13:42 <edwardk> i'd started playing with a simple fluourescence model for a toy raytracer, which is why i bothered to learn the details
17:14:16 <Pseudonym> Semi-classically, you can think of it outputting a higher frequency at lower intensity.
17:14:35 <edwardk> just dealing with the off-axis (inelastic) components in the down-shifting direction, since thats almost all of them in practice
17:15:08 <Pseudonym> Physical chemists often work at ths semiclassical limit of QM.
17:15:13 <edwardk> then you can model human skin as a blackbody emitter at 98.6 degrees fahrenheit in addition to its other properties and do pseudo-color renderings
17:15:22 <edwardk> *nods*
17:15:50 <stephenjudkins> leave #haskell for 15 minutes and people are talking about... optics? quantum mechanics? psycho-optics?  raytracing?
17:16:34 <byorgey> stephenjudkins: fairly typical =)
17:16:40 <edwardk> thats basically whats happening when you get the few flourescent upshifts as well, its absorbing a couple photons and emitting higher wavelengths, just not as reliably
17:17:03 <Pseudonym> Right.
17:17:17 <Pseudonym> You can imagine if you constructed a crystalline structure just right, you could do it far more reliably.
17:17:33 <hpaste_> geo pasted “teste” at http://hpaste.org/67191
17:17:56 <edwardk> *nods* i presume to try to get some better utilization out of incandescents, because you waste so much of the peak on infrared light
17:18:52 <edwardk> heck, even 'infrared cameras' don't pick up the peak wavelength for human body heat
17:19:12 <Pseudonym> I remember one of the thing his postdoc needed a lot of was powdered aluminium.
17:19:18 <edwardk> since that'd ideally be around 12 micrometers, and they stop around 14
17:19:23 <Pseudonym> Which is hard to get, even if you're a chemistry department.
17:19:33 <BrianHV> "The deriving clause on a newtype can list any class. For any class except Read, Show, Typeable or Data, the instance is "the same" as for the wrapped type."   in what way does the Read instance differ from the wrapped type?
17:19:45 <Pseudonym> I've never heard of a terrorist thermite attack, but apparently people worry about it.
17:19:48 <luite> Pseudonym: oh you can make nice explosions with that, lots of light
17:19:54 <edwardk> BrianHV: it includes the wrapper
17:20:47 <edwardk> Pseudonym: i image it'd be a lot harder these days. when I was a kid we destroyed an engine block with thermite in my buddy's backyard.
17:20:51 <shergill> and heat
17:21:23 <Pseudonym> I would imagine that any aluminium product and a micromill would give you the same effect.
17:21:35 <Pseudonym> It'd be a little less pure, especially if the product is anodised.
17:21:59 <edwardk> bbiab
17:22:18 <luite> edwardk: where did you get the powder? I wasn't able to get it when I was in elementary school :(
17:22:24 <theorbtwo> I'd imagine that purity is important when you are trying to get crystiline structures just right to have odd optical products.
17:22:53 <Pseudonym> Thermite is probably fairly forgiving, though.
17:29:36 <BrianHV> is there any way to debug what type is being used in a type variable? I've got a parser that seems to be inferring the wrong type in the tests but not when run from main
17:31:04 * hackagebot blank-canvas 0.2.0.1 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.0.1 (AndyGill)
17:32:46 <shergill> BrianHV: are you sure that's the problem? does giving type annotations fix it?
17:34:43 <BrianHV> shergill: good question. no, it doesn't.
17:34:59 <BrianHV> parseNumber :: (Read a) => Parser a      parseNumber = liftM read (many1 digit)
17:35:48 <BrianHV> I'm getting a parse error for that when I call it like  bufid <- parseNumber :: Parser BufferID,   with newtype BufferID = BufferID Int deriving (Read, Eq)
17:35:56 <BrianHV> but again, only from the tests
17:36:56 <BrianHV> but if I instead do  bufidint <- parseNumber :: Parser Int; let bufid = BufferID bufidint, it works
17:40:01 <geekosaur> wouldn't you need fmap to get the type right?  (or, unsafeCoerce...)
17:41:37 <dmwit> BrianHV: read "1234" won't work for BufferID; it would have to be read "BufferID 1234". So this "many1 digit" isn't the right parser if you want to pass it on to Read.
17:42:04 <dmwit> (But read is a full-blown parser all in itself, so calling read from a Parsec parser is already a code smell.)
17:42:21 <dmwit> > read "(((1234,5678)))" :: (Int, Double)
17:42:21 <lambdabot>   (1234,5678.0)
17:42:29 <BrianHV> dmwit: but it works when I use it from main (inside a conduit, fwiw). I swear it does.
17:42:44 <dmwit> Not if you're asking it to parse a BufferID it doesn't.
17:43:01 <BrianHV> I am! this server is having a full on conversation with the client.
17:43:10 <BrianHV> unless...
17:43:24 <BrianHV> laziness is screwing me.
17:44:05 <BrianHV> read makes me sad.
17:44:11 <blackdog> laziness won't do anything you don't ask it to :)
17:47:11 <shergill> there should be a haskell language extension where laziness isn't the default
17:48:06 <BrianHV> generally I don't mind laziness. I do, however, mind partial functions.
17:48:33 <BrianHV> and I feel like somehow the compiler should have caught what I was doing wrong, but I admit I don't know how it might have.
17:49:05 <hpc> shergill: such an extension would effectively make haskell as computationally weak as marco-less C
17:49:10 <hpc> er, macro-less LISP
17:49:43 <shergill> hpc: just by changing the default behavior?
17:50:30 <hpc> actually no, ignore that
17:50:35 <hpc> evaluation /= execution
17:50:44 <geekosaur> shergill, have you ever checked how many "control structures" in haskell are simply lazy functions?
17:51:02 <geekosaur> strict haskell would be a rather strange beast, and need a lot more syntax to compensate
17:51:11 <otterdam> i do suspect you'd have to rewrite your code considerably in an eager evaluation context
17:51:24 <otterdam> at which point you would be better off simply writing lisp
17:52:33 <shergill> geekosaur:i meant more for user-defined stuff. so stuff in libraries can remain lazy. i guess what i have in mind is like an extension where the user defined stuff has implicit bang-patterns to it
17:52:55 <hpc> shergill: you know how there's a function to make lazy stuff strict?
17:52:56 <hpc> :t seq
17:52:57 <lambdabot> forall a t. a -> t -> t
17:53:06 <hpc> shergill: try writing a function to make a strict thing lazy
17:54:20 <shergill> hpc: well to whnf to be pedantic, but yeah. it's just a pain to write it at times. when i started learning haskell it would trip me up a lot. i wouldn't call myself proficient in haskell by a longshot but laziness doesn't trip me up as much now, if only because i'm paranoid about it doing so
17:54:26 <hpc> (the implication of this is that any method of writing lazy code is going to require syntax; you lose nice things like strategies as a result)
17:54:34 <shergill> *write it every time
17:55:20 <shergill> hence a language extension. think of it as training wheels
17:56:06 * hackagebot lzma-enumerator 0.1.3 - Enumerator interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-enumerator-0.1.3 (NathanHowell)
17:56:24 <hpc> there's a nice (proof? probably something weaker) that goes something like
17:56:55 <hpc> "if a term can evaluate to a normal form in any evaluation strategy, it will evaluate to that same normal form with lazy evaluation"
17:57:53 <otterdam> think you might be looking for the term 'conjecture'
17:58:41 <shergill> hpc: it's an argument, one made in favor of lazy evaluation. in that if the end result doesn't diverge then the evaluation succeeds because lazy evaluation as a rule only evaluates that which is needed
17:59:58 <shergill> in a sense i almost see eager evaluation as a helping hand, like the type system. as in if things are fine and dandy with eager evaluation, they're also likely to be ok with lazy evaluation. because the converse isn't true, lazy evaluation trips newcomers a lot
18:00:18 <Pseudonym> If by "normal form" you mean WHNF...
18:00:24 <blackdog> shergill: even that's not true on a real machine with memory limits
18:00:35 <shergill> blackdog: true
18:01:24 <otterdam> i'm curious as to what you find a pain to write with lazy evaluation, since when I learnt haskell I found it one of the easier concepts to grasp and generally the reason I will use it over other languages
18:02:01 <Pseudonym> Lazy evaluation is much, much easier to write with
18:02:16 <Pseudonym> It's only real problem is that you get fewer performance guarantees.
18:02:20 <Pseudonym> Its
18:02:21 <dmwit> shergill: "if things are fine and dandy with eager evaluation, they're also likely to be ok with lazy evaluation" <- the regularity of tail-recursive stack overflow questions on stackoverflow.com proves this claim wrong
18:02:58 <dmwit> I think I answer one of those about once every week or two.
18:03:34 <shergill> hidden space leaks. though i suppose calling them leaks is contentious for some
18:04:02 <dmwit> I wouldn't say stack overflows are space leaks.
18:04:19 <dmwit> hm
18:04:20 <dmwit> Maybe.
18:04:30 <dmwit> Okay, I'll agree with "contentious". =)
18:04:34 <otterdam> it's a special case of 'out of memory'
18:04:35 <shergill> heh
18:05:21 <shergill> dmwit: not sure i followed the stack overflow questions point you were making. got a link to one?
19:16:09 * hackagebot ekg 0.3.1.0 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.1.0 (JohanTibell)
19:17:00 <sizz_>    *tumbleweed*
19:17:09 <sizz_>                                  *tumbleweed*
19:17:22 <sizz_>                                                                       *tumbleweed*
19:18:51 <Mathnerd314> sizz_: most people are in US / UK and asleep
19:18:58 <Mathnerd314> or doing things other than IRC
19:19:10 <shachaf> Mathnerd314: People in the US are asleep?
19:19:38 <Mathnerd314> shachaf: I guess it depends on their schedule :p
19:20:43 <Mathnerd314> I'm certain there are /some/ people in the US that are sleeping
19:21:24 <sizz_> maybe people who are watching baseball?
19:21:44 <Enigmagic> that would definitely put me to sleep
19:21:48 <AtnNn> watching ghc do it's magic seems more fun than baseball
19:21:56 <shergill> some people have a life. i'm apparently not one of them
19:25:02 <hpaste_> AtnNn pasted “why can ghc not find the instance?” at http://hpaste.org/67192
19:26:03 <AtnNn> it may be a bit contrived :\
19:27:37 <zachk> shergill: once you have a life you would wish you didn't
19:29:55 <adnauseam> works the other way around too.
19:30:01 <adnauseam> balance is best.
19:33:37 <copumpkin> edwardk: oh, I know what's happening I think
19:33:41 <copumpkin> it's stupid
19:33:53 <copumpkin> it's using my system mpfr lib instead of my custom one
19:34:20 <copumpkin> anyway, I'll figure it out some other time
19:36:39 <BrianHV> with parsec, what would be the recommended way to return a result if you're at eof and continue with another parser if not?
19:38:12 <Victor__> test
19:40:06 <Eduard_Munteanu> Victor__: pong
19:40:09 <BrianHV> :t try
19:40:10 <lambdabot> Not in scope: `try'
19:40:16 <byorgey> BrianHV: (eof *> return result) <|> someOtherParser
19:42:08 <BrianHV> byorgey: thanks
19:43:31 <BrianHV> it does work better if I implement someOtherParser correctly
19:56:12 * hackagebot cab 0.1.13 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.13 (KazuYamamoto)
19:56:12 <byorgey> BrianHV: yes, that often helps
20:16:35 <cap10morgan> How would pattern match an empty Data.Map?
20:16:53 <ezyang> cap10morgan: guards or view patterns
20:16:56 <dmwit> cap10morgan: Use null
20:17:03 <dmwit> ?hoogle Map k a -> Bool
20:17:03 <lambdabot> Data.Map null :: Map k a -> Bool
20:17:03 <lambdabot> Data.Map valid :: Ord k => Map k a -> Bool
20:17:03 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
20:17:26 <cap10morgan> dmwit: null in a guard?
20:17:32 <dmwit> Sure.
20:17:45 <geekosaur> the constructors for Map aren't exported, so no pattern matching
20:18:00 <cap10morgan> geekosaur: ok, that makes sense. thanks everyone.
20:18:11 <dmwit> I think it's actually pretty unusual to need to check when a Map is empty, though.
20:25:42 <augur> anyone know of nice attempts at resolving the frame problem in reasoning systems?
20:26:48 <augur> edwardk: dont say statistics
20:27:02 <edwardk> statistics
20:27:05 <augur> :D
20:27:07 <edwardk> what was i not saying that in response to?
20:27:10 * edwardk reads
20:27:35 <augur> i wonder if some sort of epistemic modal logic could help
20:27:50 <augur> with belief updates
20:28:17 <augur> the simplest kind of plausibility ranking schema involves essentially propositional hamming distances
20:28:56 <shergill> augur: machine learning. there.
20:29:12 <augur> that doesnt solve the frame problem :P
20:29:39 <shergill> frame problems aren't ai-complete?
20:29:50 <augur> what?
20:31:44 <adnauseam> what's wrong with statistics ?
20:31:55 <monochrom> situation calculus has a treatment of the frame problem
20:32:25 <augur> "statistics" is not an answer to the frame problem
20:32:57 <adnauseam> *googles the problem*
20:33:05 <augur> http://plato.stanford.edu/entries/frame-problem/
20:34:16 <shergill> ai-complete was my tongue-in-cheek way of referring to things which have solutions entrenched in 'common sense' and/or 'heuristics'
20:34:44 <augur> warning: wall of text incoming
20:34:46 <augur> Now, suppose the robot has to take a tea-cup from the cupboard. The present location of the cup is represented as a sentence in its database of facts alongside those representing innumerable other features of the ongoing situation, such as the ambient temperature, the configuration of its arms, the current date, the colour of the tea-pot, and so on. Having grasped the cup and withdrawn it from the cupboard, the robot needs to update this database.
20:34:46 <augur> The location of the cup has clearly changed, so that's one fact that demands revision. But which other sentences require modification? The ambient temperature is unaffected. The location of the tea-pot is unaffected. But if it so happens that a spoon was resting in the cup, then the spoon's new location, inherited from its container, must also be updated.
20:35:44 <augur> i feel like this has a nice solution if you have lots of purely relative information. like if the location of the spoon is "in the cup" not "in the cupboard" then the global location of the spoon would change but the relative location wouldnt
20:35:50 <augur> i wonder how far this could be pushed
20:37:04 <shergill> augur: you can have position be an inferred fact. one which can be computed at query time, by looking at the location of objects that an object's definition depends on
20:37:27 <augur> shergill: sure, but then you need to sort of remember the whole history of the action just in case
20:37:48 <shergill> for performance you probably want a prolog system with tabling. i believe xsb has decent support for it
20:37:50 <augur> but laziness would be a nice solution to some of it, definitely
20:38:51 <adnauseam> excuse my ignorance; wouldn't the tea cup have state information too? why "spoon", why not object that's "not tea pot" and its then relative position to the tea pot. knowing what the object is, is then an act of semantics and context which can be either learned or ignored
20:39:46 <augur> adnauseam: fair enough. im just saying it might be interesting to see how a minimal, highly relativized knowledge base could get
20:39:52 <shergill> augur: i'm not sure why you would need to store the _whole_ history. only the relevant bits. and deciding what the relevant bits are is part of the design of expert systems
20:40:05 <augur> shergill: "only the relevant bits" is the frame problem :)
20:40:19 <Orclev_> wouldn't "the spoon is in the cup" and the current location of the cup be sufficient to determine the location of the spoon?
20:40:32 <augur> Orclev_: thats what i said! :P
20:40:36 <shergill> augur: exactly. one which is solved in practice using heuristics, and 'common sense'
20:40:40 <adnauseam> as to the state of the robot - isn't each entity responsible for its own state? the state of the robot shouldn't be completely dependant on the state of the tea pot, other than it's just holding it/not holding it. where the tea pot would then hold the state info of what's on/in/over it etc
20:40:58 <adnauseam> augur: i see your point
20:40:59 <augur> shergill: and often solved poorly, and via tedious amounts of human insight. e.g. CYC
20:41:06 <shergill> augur: are you trying to create a robot with no inductive bias which gets that right?
20:41:28 <shergill> *replace robot with whatever automaton noun you please
20:41:34 <augur> no, im not trying to do anything other than get interesting citations!
20:42:09 <augur> the frame problem is one of those notoriously difficult AI/philosophy of mind things
20:42:35 <augur> the kind that has resisted good general solutions for the last 50 or so years
20:42:37 <adnauseam> sounds like it just needs a good state abstraction
20:43:01 <adnauseam> which is probably much more difficult than it sounds
20:43:30 <augur> it sounds pretty difficult to me :)
20:43:39 <shergill> i believe it's telling that off late it has garnered more attention by philosophy researchers than ai researchers
20:44:11 <augur> shergill: mostly, i think, because of the shift towards lower-level AI tasks
20:44:25 <augur> there's not as much big planning kinds of research going on in AI these days
20:44:36 <augur> at least relative to other more mundane things
20:44:46 <shergill> could you better define 'big planning kinds of research'?
20:44:47 <augur> like information retrieval, as in the case of expert systems
20:44:53 <adnauseam> isn't data mining getting big and isn't that AI, basically ?
20:45:16 <augur> by big planning kinds of research i mean things like having systems that can be told "solve this problem"
20:45:38 <augur> vs. systems that can be told "tell me the most likely disease given these symptoms"
20:45:49 <adnauseam> i'd assume that's many years ahead of us
20:46:52 <shergill> augur: because researchers realized that part of the problem is the specification of the problem. english makes a poor specification language. eg. in that sentence alone the ambiguity wrt 'solve' is something which needs further research resolution before such feats can be achieved
20:46:54 <adnauseam> deriving context is crucial to problem solving of dynamic problems that depend on deep knowledge structures
20:46:58 <Orclev_> anyone know of a pre-existing library function to determine if two rectangles intersect each other?
20:46:59 <shergill> you need to be able to walk, then run
20:47:19 <shergill> also, what adnauseam said
20:48:20 <augur> shergill: you're taking my use of quotes too literally
20:48:51 <augur> shergill: most of the frame problem stuff is phrased in terms of well defined formal systems, not english, so the issue of the language being shit is not relevant
20:48:52 <shergill> isn't that the entire purpose of quotes?
20:49:00 <augur> ...
20:49:38 <augur> ok, so shergill is clearly a chatbot :P
20:49:48 <adnauseam> augur: what are "low level" ai tasks ?
20:49:53 <shergill> right, and the definition of that problem isn't well-defined. as i understand it, the problem seeks a good abstraction of state space, without properly defining what it means by good
20:50:20 <augur> adnauseam: image recognition, data mining, etc. the sort of stuff that usually goes under the label "machine learning"
20:50:29 <adnauseam> oh
20:50:38 <augur> the vast majority, if not all, of which is more about information extraction rather than more classical tasks
20:51:07 <adnauseam> that's alright then. i personally don't see a way to run before walking. but it's still good to have theory
20:51:49 <adnauseam> i would go into neuro science if i had the time
20:52:19 <augur> sure, except you dont need to walk before you can swim
20:52:30 <augur> the frame problem is somewhat tangential to the lower-level stuff
20:52:45 <adnauseam> it's fine if you're a fish
20:52:51 <augur> you can bypass the low level stuff by building an AI that interacts with a virtual world about which it has perfect information
20:53:00 <augur> adnauseam: its fine if you're a human, too!
20:53:10 <augur> most human babies seem to actually have an innate swimming instinct
20:53:12 <adnauseam> but if you throw a baby overboard, it aint gonna float for long, despite what those pictures show :P
20:53:28 <augur> "float for long" is not the same as swimming
20:53:40 <adnauseam> babies don't exactly swim though do they
20:53:44 <augur> in fact, floating with your head above water is pretty tricky even for adults!
20:53:46 <augur> adnauseam: sure they do
20:54:07 <adnauseam> i wouldn't call the ability to peddle in water swimming
20:54:27 <adnauseam> surely if an infant is put in water for more than 2-3 minutes without supervision it will drown
20:54:48 <augur> as would most adults who can walk but not swim
20:54:57 <augur> my point is that they're not dependent tasks
20:55:07 <augur> you're taking this metaphor too literally
20:55:18 <augur> maybe you're also a chatbot!
20:55:27 <shergill> adnauseam: children have greater bouyancy and toddlers who don't know how to walk, can learn how to swim first
20:55:32 <adnauseam> babies are comfortable in liquid, having spent some time in it, but since the ambilical chord is cut, and they have no real grasp of what to do when they start suffocating under water, ithink most would just inhale the water and drown rather painfully
20:55:41 <shergill> augur: you're a philosopher?
20:55:45 <shergill> *are you
20:55:46 <augur> no
20:55:58 <shergill> shame. you'd make a good one.
20:56:22 <augur> why? because im good at pointing out that the problem is harder than you think? :P
20:56:39 * adnauseam takes his penis measuring tool out 
20:56:42 <adnauseam> line up
20:56:44 <adnauseam> take`m out
20:56:50 <augur> pff
20:56:52 <augur> sexist!
20:57:00 <mtbeedee> how can I take certain elements from a list... like if i wanted the 1, 2, 5th elements from say [10..20]?
20:57:07 <adnauseam> even women have e-peens these days:P
20:57:23 <augur> a sexist chatbot! whoda thunk it!
20:57:27 <adnauseam> > take 4 [10..20]
20:57:28 <lambdabot>   [10,11,12,13]
20:57:32 <adnauseam> mtbeedee: ^
20:57:40 <mtbeedee> that gets the first 4...
20:57:43 <Clint> > [10..20] !! 0
20:57:44 <lambdabot>   10
20:57:45 <shergill> augur: nope. and i never said the problem is trivial. in fact i believe the problem you're interested in is a lot more complex than you understand and/or give  it credit for. the low-level tasks that you seem to trivialize are being focused on because they are within reach
20:57:47 <Clint> > [10..20] !! 1
20:57:47 <lambdabot>   11
20:57:48 <mtbeedee> I want the first, second and fift or whatever
20:57:48 <Clint> > [10..20] !! 4
20:57:49 <lambdabot>   14
20:57:52 <adnauseam> which elements do youwant totake ?
20:58:02 <adnauseam> you can use then a lambda expression to specify rules
20:58:05 <augur> shergill: im not trivializing low level tasks at all
20:58:23 <augur> shergill: im saying they're different, and easier to solve, and also not relevant to my request for papers to read!
20:58:55 <hpaste_> Chipmonkpyro pasted “Prop” at http://hpaste.org/67194
20:58:56 <shergill> lol
20:58:57 <adnauseam> you've read all of wikipedia's references ? :p
20:58:58 <adnauseam> :o
20:59:23 <Orclev_> there was some discussion the other day as to whether !! should be discouraged in the same fashion as head is
20:59:23 <adnauseam> this seems recent
20:59:26 <adnauseam> http://www.cs.utexas.edu/~vl/papers/jmc.pdf
20:59:58 <augur> its not even about recency, its just about the interestingness of the solution
21:00:13 <Chipmonkpyro> I'm trying to come up with a way to get the above code to do what I want without using Eq. The only issue I have now is that the ps in the top function cant have the p element in it. Been stuck on this for a while, any ideas anyone?
21:00:37 <Orclev_> > let x:y:_:_:z:xs = [1,2,3,4,5,6] in (x,y,z)
21:00:38 <lambdabot>   (1,2,5)
21:00:57 <augur> i should start using the trolls technique.
21:01:19 <augur> theres this anecdote ive read where someone said trying to get simple answers from linux irc channels is like pulling teeth
21:01:22 <adnauseam> trolling will get someone shot one day
21:01:26 <augur> youll get told youre an idiot for trying to do something
21:01:32 <augur> or you'll be told to read the man pages
21:01:33 <augur> or whatever
21:01:34 <adnauseam> augur: too true
21:01:36 <augur> never an answer
21:01:45 <adnauseam> the same applies to haskell too :p
21:01:47 <augur> but if you just say linux sucks because it cant do X
21:01:53 <Orclev_> adnauseam: I'd be surprised if it hasn't happened yet
21:01:57 <augur> you get 50 to-the-point answers
21:02:20 <augur> !faq can haskell solve the frame problem?
21:02:24 <augur> @faq can haskell solve the frame problem?
21:02:24 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:44 <monochrom> the frame problem sucks because it can't keep track of what doesn't change
21:02:54 <adnauseam> Orclev_: considering this meme-crazed generation, i think the rates are about to get higher :p
21:03:05 <augur> monochrom: dont make me murder you
21:03:27 <adnauseam> oo, violence
21:03:35 <augur> Orclev_: its a known fact that all shootings occur because of trolling
21:03:40 <Orclev_> lol
21:04:11 <Orclev_> banhammered from life for trolling
21:04:50 <Orclev_> I know what tomorrows topic of discussion at work is going to be now :P
21:05:17 <augur> shergill: tho, one of my ever-lasting toy projects is to try to build some sort of agent program
21:05:26 <augur> so i guess in SOME sense im trying to build a robot
21:05:54 <augur> but im more interested in exploring the problem, and trying to find interesting solutions
21:06:07 <augur> the robot, such as it is, is merely a test bed for ideas
21:07:04 <augur> SEP does say that the narrow problem has been solved
21:07:12 <augur> which makes me wonder what these solutions are
21:08:14 <shergill> augur: have you tried writing some code?
21:08:32 <augur> shergill: not yet. ive only in the last few days gotten re-interested in the problem
21:08:35 <shergill> starting with some prolog system would be recommended given your interest
21:08:52 <augur> eh. prolog. boring. :)
21:09:11 <shergill> write code. it will help crystallize at least some of the questions/concepts
21:09:57 <augur> http://www.doc.ic.ac.uk/~mpsha/ECExplained.pdf is the "best" solution according to the author that is cited in SEP as stating the problem is essentially solved
21:10:04 <augur> so i guess ill read that
21:10:06 <shergill> or you could even use the pen and paper approach. point is to work with concrete examples. they help
21:10:17 <augur> then again, the author of the SEP article is the author of that paper!
21:10:28 <shergill> oh self-citations
21:10:31 <augur> :)
21:10:39 <augur> thats always fun, innit
21:12:40 <augur> im especially interested in solutions that are symbolic but dont involve pushing around formulae
21:12:45 <augur> tho im not sure how that would work
21:12:50 <augur> its hard to search for that sort of thing
21:13:05 <augur> "reactive frame problem"
21:13:14 <augur> conal: how can FRP solve the frame problem? :D
21:14:41 <shergill> would you also be interested in magic? :P
21:14:47 <augur> im also curious how we might build systems that can learn new frame stuff
21:15:13 <augur> shergill: all the magic i need is the lambda calculus!
21:16:44 <augur> i'd really like to be able to build a program that could do the whole agent-y thing tho. that'd be a fun project
21:18:43 <augur> it seems much of contemporary learning research is focused on the low level problems, using numerical learned things, as opposed to (semi) symbolic learned things
21:19:41 <augur> like, even if you could learn propositional information, its more like the probabilities of the relations of propositions
21:19:53 <augur> not the learning of new propositions whole cloth
21:20:35 <hayashi> @pl \x y -> map (\f -> f y) x
21:20:36 <lambdabot> flip (map . flip id)
21:22:11 <otters> :t zipWith ($)
21:22:12 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
21:23:48 <mtbeedee> how do you map (-1) onto a list... it's complaining about negation
21:24:14 <augur> wto: (-1) is a number
21:24:18 <augur> you want (- 1)
21:24:23 <otters> I don't think so
21:24:24 <augur> > -1
21:24:25 <lambdabot>   -1
21:24:27 <augur> > - 1
21:24:28 <lambdabot>   -1
21:24:31 <otters> oh wait never mind
21:24:32 <augur> > (- 1)
21:24:33 <lambdabot>   -1
21:24:37 <augur> hm!
21:24:39 <hayashi> subtract 1?
21:24:42 <mtbeedee> AAAAAHHH
21:24:42 <mtbeedee> what
21:24:43 <augur> maybe not!
21:24:45 <Rotaerk> > (~ 1)
21:24:46 <lambdabot>   Pattern syntax in expression context: ~1
21:24:51 <Rotaerk> hmm..
21:25:01 <augur> damn haskell
21:25:20 <mtbeedee> ok
21:25:27 <mtbeedee> (subtract 1) works
21:25:47 <liyang> so does (+ negate 1)
21:27:10 <augur> + -1 should too
21:27:20 <augur> > map (-1 +) [0..10]
21:27:21 <lambdabot>   [-1,0,1,2,3,4,5,6,7,8,9]
21:29:02 <hayashi> oh I remember now, last time I wanted to do \x y -> map (\f -> f y) x  I used Control.Applicative
21:29:11 <hayashi> probably cracking a walnut with Mjolnir though
21:30:08 <Orclev_> for more -1 shenanigans you could also do: map (flip (-) 1) [0..10]
21:30:19 <Orclev_> > map (flip (-) 1) [0..10]
21:30:20 <lambdabot>   [-1,0,1,2,3,4,5,6,7,8,9]
21:30:42 <liyang> Or if you know it's going to be Int/Integer that you're working on...
21:30:49 <liyang> > map pred [0..10]
21:30:50 <lambdabot>   [-1,0,1,2,3,4,5,6,7,8,9]
21:31:02 <Orclev_> oooo, I like that
21:31:23 <liyang> Depends on a sensible Enum instance though.
21:31:58 <Orclev_> is there a Integral type without a sensible Enum instance?
21:33:23 <Orclev_> hmm, even the Float instance seems sensible, if anything was going to cause problems I figured it would be the floating points
21:35:36 <liyang> I don't think the Float one is sensible... :(
21:35:48 <fox> Can I "dinamically" pattern match a type constructor? e.g.: f ( d a) = a would match any constructor with one argument
21:35:48 <liyang> (I think it shouldn't exist.)
21:37:00 <Orclev_> liyang: fair enough, I was honestly suprised it worked myself, I expected something like: pred 2.0 == 1.99999999999999999
21:37:24 <Saizan> fox: is f supposed to be a TypeFamily there?
21:38:04 <dmwit> fox: No.
21:38:08 <fox> saizan, no
21:38:14 <dmwit> fox: However, with records, you may write something like this:
21:38:28 <dmwit> data Foo a = Foo { arg :: a } | Bar { arg :: a }
21:38:41 <dmwit> fox: Then you may call "arg" on either a Foo or a Bar.
21:40:06 <fox> dmwit: I'm aware of that, just was tired of manually wrinting the patterns
21:40:41 <dmwit> tough
21:41:08 * liyang would advise against that. When you add a third | Cow {..} without an arg :: a field, you don't get any warnings.
21:41:34 <ezyang> I really quite like Urweb's record system. But it probably would take a lot of work to fit it into Haskell.
21:46:20 <nyingen> @quote
21:46:20 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
21:52:50 <BMeph> Is there a name for the pattern of continually making types as endofunctions of other types?
21:53:38 <Saizan> BMeph: e.g.?
21:54:06 <BMeph> The example I'm thinking of is from Hayo Thielecke (?) using (delimited) continuations:
21:54:48 <BMeph> Ctx :: Value -> Answer; Cont :: Ctx -> Ctx; Func :: Cont -> Cont
21:55:04 <vodik> well that was dumb
21:55:10 <vodik> you know what it actually was?
21:55:17 <BMeph> It's like a tower of transformers, or something.
21:55:20 <vodik> my weechat config got messed up
21:55:30 <vodik> the unicode characters inside it where "?" :(
21:55:40 <Saizan> BMeph: ah, don't know then
21:56:36 <BMeph> Saizan: It sure is clever, though, isn't it? :)
21:56:51 <vodik> ooop, wrong channel :(
21:58:50 <Saizan> BMeph: i'm not sure i'm following it :)
22:01:00 <nyingen> @manatee
22:01:01 <lambdabot> Unknown command, try @list
22:01:07 <mtbeedee> how can I turn a list of strings into a list of ints... like I have ["1","4","12"] and I want [1,4,12]  Is there like an stringToInt function I can map?
22:01:16 * hackagebot postgresql-libpq 0.8 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8 (LeonSmith)
22:01:20 <Cale> map read
22:01:39 <Cale> > map read ["1","4","12"] :: [Int]
22:01:40 <lambdabot>   [1,4,12]
22:01:45 <Cale> > map read ["1","4","12"] :: [Double]
22:01:46 <lambdabot>   [1.0,4.0,12.0]
22:01:52 <mtbeedee> wow, look at that
22:01:53 <mtbeedee> nice
22:02:20 <BMeph> Saizan: Ctx is a context. Cont is a continuation, and Func is a function, although I'm sure you got those ones. Let me poke around, and I might find the paper I was getting this from...
22:07:38 <Saizan> my problem is that i have context ~ continuation
22:10:12 <BMeph> Saizan: Yeah. to Thielecke, a continuation is instead, a context transformer.
22:26:58 * ski peeks up, sees Thielecke mentioned
22:27:58 <ski> BMeph : which paper is this from ?
22:29:24 <ski> it looks like it could be multiple levels of continuations (all delimited, except possibly the "innermost"/"primitive" one)
22:29:47 <ski> preflex: xseen ManateeLazyCat
22:29:47 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 35 days, 14 hours, 55 minutes and 20 seconds ago, saying: applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
22:29:51 <ski> preflex: xseen Manatee
22:29:52 <preflex>  Sorry, I haven't seen Manatee
22:58:02 * ski idly wonders whether maybe the paper BMeph was getting this from what talking about CPS and fusion for stream transducers
23:00:29 <ski> "Transducer Composition and CPS" <http://lambda-the-ultimate.org/node/776>,<http://web.archive.org/web/20060226222531/http://www.cse.ogi.edu/~jl/wg2.8/Harrogate.html#Shivers>
23:00:54 <ski> "Continuations and Transducer Composition" <http://matt.might.net/>,<http://matt.might.net/papers/might2006transducers.pdf> Olin Shivers,Matthew Might
23:03:11 <ski> Express transducers as triple continuation CPS (f x k u d)
23:03:11 <ski>    k = this stage's computation: Value -> CommndCont
23:03:12 <ski>    u = upstream computation    : DownCont -> Ans
23:03:12 <ski>    d = downstream computation  : Value -> UpCont -> Ans
23:03:13 <ski>    CommndCont = UpCont -> DownCont -> Ans
23:03:20 <ski> so
23:04:38 <ski>   CommndCont = UpCont -> UpCont
23:06:11 <ski>   f :: Value -> (Value -> CommndCont) -> CommndCont  -- i think
23:06:24 <blackdog> is it expected behaviour that "cabal test" won't rebuild its test binary, even if it's changed?
23:06:30 <ski>   f :: Value -> Cont CommndCont Value  -- basically, then
23:06:44 <ski> note how `UpCont' and `DownCont' are mutually recursive
23:27:36 * ski is reminded of his "`zipWith' using `foldr'" at <http://hpaste.org/47814> and "`Santa'-based `doubleEveryOther'" in <http://hpaste.org/56909> ..
23:41:28 <nyingen> @quote
23:41:29 <lambdabot> olsner says: a mind won't be enough, you need a comind to go with it
