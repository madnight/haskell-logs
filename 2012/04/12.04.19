00:00:00 <timthelion> Cale: is it not the same kind of undefined as not having sufficient axioms to prove a statement true or false?
00:00:33 <Cale> timthelion: Well, if both a statement P and its negation are provable, I don't like saying that we haven't defined whether P is true :)
00:00:53 <drdo> timthelion: I've always regarded discussing the truth of statements we know are not provable nor disprovable as pointless
00:01:18 <drdo> I don't even know what truth means
00:01:23 <Cale> But I dunno. I guess you can use terminology in a bunch of ways.
00:01:40 <Cale> drdo: But in *which system*
00:02:01 <drdo> Cale: In any system that has the concept of truth and law of the excluded middle
00:02:42 <timthelion> drdo: I have never found that to be the case.  It's always possible to find a way to prove a restricted version of the unprovable statement. I cannot prove for example, that prime numbers form a certain subset of all real numbers, but I can prove that a subset of primes is infinite.
00:03:39 <drdo> timthelion: What does it mean for something of the sort to be true or false?
00:03:40 <Cale> drdo: saying something is "true but unprovable" is shorthand for saying that while P isn't provable in a theory, it is true in every model of that theory.
00:03:51 <drdo> Cale: Give me an example
00:04:09 <Cale> drdo: I would need to set up a bunch of complicated definitions to do it
00:04:24 <drdo> And i mean an honest one, not a contrived example to prove a point
00:04:31 <monochrom> 2nd-order arithmetic has some wacky examples, I heard
00:05:06 <drdo> I've never heard about anything that is regarded as true but is not provable or disprovable
00:05:15 <drdo> (or regarded as false for that matter)
00:06:07 <Cale> It's not about being "regarded as true", it's about the interpretation of that statement being true of every model of the theory.
00:06:48 <opqdonut> since we're looking at the logic from the outside, we can talk separately about truth and provability
00:06:56 <drdo> That doesn't mean much
00:07:09 <opqdonut> (some people don't realize this)
00:07:10 <Cale> It doesn't mean much to you because you haven't had a course in model theory.
00:07:11 <Cale> :)
00:07:26 <opqdonut> indeed :)
00:07:47 <drdo> opqdonut: No we can't
00:07:55 <opqdonut> yes we can
00:07:56 <drdo> That's the whole point of this whole business, not doing that
00:08:01 <Cale> YES WE CAN
00:08:07 <Cale> and we do
00:08:13 <Cale> That's what model theory is about
00:08:28 <Cale> and it's the only sensible way to make statements like that one that you're talking about
00:08:29 <opqdonut> it is a very weird perspective at first
00:08:33 <opqdonut> but it's very powerful
00:08:37 <drdo> The whole point of this mathematics thing is work only within a system
00:08:49 <opqdonut> yes. we work within a system
00:08:54 <opqdonut> then we have another system within that system
00:09:16 <opqdonut> which captures some of the essential features of the (whole) system
00:09:33 <drdo> What you are talking about is basically deciding on the truth of statements on whim
00:09:36 <opqdonut> no
00:09:50 <monochrom> a logic or a theory has a syntax and a semantics. the syntax is not just the grammar of the formulas, but also the proof rules. "provable" uses the proof rules. "true" uses the semantics. once you see this, actually "provable" and "true" have no reason to be related at all a priori. if you want any relation, you have to carefully design the syntax and the semantics to match
00:09:57 <timthelion> opqdonut: Noting, that I have not taken model theory, I would wonder, if that's not breaking one of our rules.  Isn't making a new system inside a system an act of assuming an axiom which we previously did not assume?
00:10:07 <drdo> If you can't prove/disproved it and it matches the intuitive idea you had when you defined it in the system you just decide on it?
00:10:27 <monochrom> screw intuitive idea. no one is talking about intuition here
00:10:30 <Cale> timthelion: nope, don't have to assume anything else if you start with a rich enough system to encode the rules of logic :)
00:10:35 <opqdonut> yeah
00:10:38 <Cale> timthelion: like set theory, say
00:10:40 <opqdonut> it's just sets and induction
00:10:56 <opqdonut> the "which captures some of the essential features of the (whole) system" is kind of a philosophical point, not a rigorous point
00:10:57 <Cale> You can even scrape by with arithmetic if you really need to
00:11:05 <drdo> monochrom: I don't understand truth at all
00:11:39 <drdo> You have this logic system with a bunch of rules for forming expressions and a bunch of rules for inference
00:12:08 <monochrom> not just that, but also a semantics
00:12:25 <drdo> What do you mean with that?
00:12:27 <monochrom> like, have you learned any bit of programming language theory at all?
00:12:58 <drdo> monochrom: Yes, and i don't know what you're talking about
00:13:11 <monochrom> a programming language has a grammar and an operational semantics. that corresponds to syntax for the logic, formulas and proof rules. but that is not the end.
00:13:24 <Cale> drdo: A statement being true in this context means that its interpretation (or every interpretation in a model of the theory at hand) is provable in the outer system which we're using to discuss the logical system in question.
00:13:28 <drdo> operational semantics is analogous to the inference rules
00:13:34 <drdo> It's just a bunch of reduction rules
00:13:38 <monochrom> a programming language also has a denotational semantics. that corresponds to semantics for the logic
00:13:51 <drdo> If that's what you mean by semantics, fine, but what's your point?
00:14:10 <monochrom> <monochrom> a logic or a theory has a syntax and a semantics. the syntax is not just the grammar of the formulas, but also the proof rules. "provable" uses the proof rules. "true" uses the semantics. once you see this, actually "provable" and "true" have no reason to be related at all a priori. if you want any relation, you have to carefully design the syntax and the semantics to match
00:14:13 <monochrom> that is my point
00:15:01 <drdo> monochrom: Oh get what you mean
00:15:19 <drdo> Actually i don't
00:15:22 <monochrom> in particular, operational semantics is still syntax when it comes to logic
00:15:29 <timthelion> monochrom: um, that's a very strange use of a priori.  It's not like we're going to go "experiencing" an abstract system... :)
00:15:38 <drdo> monochrom: Let's take propositional logic
00:15:43 <drdo> What do you mean with semantics there?
00:16:20 <drdo> Cale: What do you mean by outer system?
00:16:29 <monochrom> a model
00:16:55 <monochrom> it has various names. a model. an interpretation. a blah-blah structure
00:17:11 <Cale> drdo: If we're talking about proving that certain statements are not provable, say, then we obviously can't be doing that from inside of the system we're talking about.
00:17:32 <Cale> drdo: We must have constructed it formally as a mathematical object in some other system.
00:17:38 <monochrom> a truth assignment, i.e., a function that maps propositional variables to a two-element set
00:17:40 <drdo> The only related thing i know that goes by the name interpretation is a set of values for the variables
00:17:48 <drdo> and a model is one that makes the statement true
00:18:12 <monochrom> yes, that's a semantics for propositional logic
00:18:32 <monochrom> if you go intuitionistic propositional logic, there is Kripke structure
00:18:42 <drdo> monochrom: That still doesn't mean anything
00:19:03 <drdo> The system doesn't attach any meaning to the symbols, only humans do
00:19:43 <monochrom> ok, remember you asked about "true and not provable"? that means the syntax does not completely match the semantics
00:20:03 <drdo> monochrom: The first thing i said is that i don't know what that means
00:21:13 <drdo> Cale: The obvious question is, why do you care about it then if you have the outer system where you can just prove it?
00:21:41 <drdo> Or do you mean taking the union of the results in a bunch of different systems?
00:21:53 <timthelion> "true and not provable" is meaningless in abstract(semantic free logic), in that drdo is correct.  But whenever we have a system which is not abstract, which HAS a semantic, which has truths which relate to truth in itself, and not only to the axioms which hold the abstract system together, the statements meaning is obvous.
00:22:20 <drdo> timthelion: What does that mean?
00:23:02 <timthelion> drdo: well, if we just have axioms, then there is no semantic(meaning).  There is no conection between that abstract system and reality.
00:23:05 <drdo> As i see it the whole point of logic and mathematics is to talk about well-defined things
00:23:07 <monochrom> actually what kind of answer do you expect?
00:23:45 <timthelion> drdo: but it is possible to talk about things which relate to reality.  And in that case, we have semantics, and many many unprovable truths.
00:23:47 <Cale> It's basically really hard to continue this discussion in a meaningful way without just introducing everyone to model theory and formally defining everything. But as to why model theory is worth doing -- it does give you some fairly powerful tools for constructing models of theories and showing that certain mathematical objects exist. For example, you can use the compactness theorem to construct a nonarchimedean ordere
00:23:47 <Cale> d field.
00:24:31 <drdo> timthelion: The point is to encode in the system every property that you wish the object to have
00:25:01 <drdo> If your idea of the object and what you have actually written don't match then you're just not talking about the same thing
00:26:34 <drdo> Cale: I never quite understood what is meant by "certain mathematical objects exist"
00:26:53 <drdo> Anything i want exists, i just have to define it
00:27:27 <newsham> consistency not an issue for you?
00:28:14 <drdo> newsham: if it's not consistent with the system i'm defining it in then it doesn't exist
00:28:26 <drdo> But that's just a matter of changing the system
00:31:33 <monochrom> @quote monochrom kripke
00:31:34 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
00:32:21 <Cale> drdo: Well, there's a quantifier which explains what that means.
00:32:26 * hackagebot http-conduit 1.4.1.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.1.2 (MichaelSnoyman)
00:32:43 <monochrom> haha
00:34:08 <drdo> Cale: pretty sure you can't prove anything from just that quantifier without assuming anything about what it's quantifying over (other than trivial things)
00:34:56 <Cale> what?
00:36:15 <timthelion> I really think that drdo is correct here.  A mathematical object lives within a system.  "importing" that object into another system doesn't make the truths of the first system apply to the seccond.
00:36:44 <Cale> Well, I'm pretty confused about what he's even talking about
00:37:10 <shachaf> Cale: Knowing what anyone is talking about isn't part of how Internet arguments work!
00:37:31 <drdo> I merely asked you to explain what you meant by "showing a mathematical object exists"
00:37:32 <timthelion> @tickle shachaf
00:37:33 <lambdabot> SHACHAF: 0.00 @ N/A 6:-230pm
00:37:44 <Cale> But when I say that a field exists, for example in ZFC, what I mean is that a set exists which has a bunch of properties.
00:38:05 <timthelion> lambdabot: wtf does that mean?
00:38:15 <drdo> Oh that's just it?
00:39:03 <Cale> drdo: and it translates into the truth of a statement of the form exists F. P(F)
00:39:26 <drdo> Cale: And that's what i said above, the P(F) part :P
00:39:29 <Cale> (for some complicated P encoding the field axioms -- F is probably a tuple here)
00:39:39 <drdo> without the P(F) part you can only prove trivial things
00:40:07 <Cale> You can't leave that P(F) part out and still use the quantifier
00:40:12 <Cale> It's syntactically incorrect :)
00:40:26 <drdo> pff :P
00:41:36 <drdo> Cale: I thought you were talking about exists in some deep way that makes us feel warm and fuzzy
00:42:03 <Cale> I'm a formalist
00:42:12 <drdo> Whatever that means
00:42:20 <drdo> to wikipedia!
00:42:26 <monochrom> it means no warm and fuzzy feeling
00:42:44 <shachaf> "A formalist is one who cannot understand a theory unless it is meaningless."
00:42:51 <Cale> :D
00:42:52 <drdo> oh no
00:42:58 <drdo> religion has invaded mathematics too?
00:43:07 <Cale> haha
00:43:08 <Cale> yes
00:43:14 <Cale> It's been around for a long time
00:43:19 <Cale> Slowly going away
00:43:27 <drdo> religion is the arch enemy of mathematics
00:43:33 <drdo> religion is bottom
00:43:40 <drdo> you can prove anything
00:43:41 <Cale> Religion in the sense of believing in the objective reality of mathematical objects
00:44:05 <drdo> Cale: religion really means bottom to me, i.e. non-sense
00:44:11 <Cale> That there should be a single truth to things and the "right axioms" which we just have to "discover".
00:44:20 <drdo> even discussing what it means for something to exist is non-sense
00:44:25 <drdo> you only do it as a joke
00:44:39 <Cale> But you can still formally discuss semantics
00:45:32 <Cale> Of course, the interpretation of an existential quantifier is going to be another existential quantifier :)
00:45:41 <monochrom> yeah, a semantics is a relation between two theories
00:46:10 <drdo> I can't understand how someone can even have an opinion about anything like that
00:46:19 <Cale> It's not a matter of opinion
00:46:23 <drdo> It's clear we don't understand much at all about the universe
00:46:23 <chu> Nice, formalist ala Curry?
00:46:27 <Cale> It's a branch of mathematics
00:47:53 <monochrom> which universe?
00:48:11 <drdo> monochrom: What's a universe?
00:48:14 <Cale> drdo: We're talking about mathematics here, not the universe :P
00:48:28 <chu> The Herbrand Universe, of course.
00:48:30 <drdo> Cale: the universe still dictates the upper bound
00:48:32 <Cale> We're talking about symbols that we scribble on paper and blackboards :)
00:48:33 <drdo> no way around that
00:48:44 <drdo> by definition!
00:48:57 <Cale> "the upper bound"?
00:48:59 <sanjoyd> I think our conception of the universe ends at the point where we define self reference.
00:49:07 <drdo> Cale: on what can happen
00:49:26 <ClaudiusMaximus> oh wow, got my most bizarre heap profile ever - it's full of what appear to be class instances instead of actual data..
00:49:44 <sanjoyd> A system that can refer to itself is the most complex system we can understand and reason about, I think.
00:50:24 <Cale> I don't believe in an objective reality either.
00:50:32 <drdo> It's clear we humans don't have a clue what we're doing, so i find it weird when anyone makes bold assertions about meaningless things and means it!
00:50:55 <Cale> It always pains me a little to speak of "the universe" for want of a better term :)
00:51:05 <drdo> Cale: I know what you mean
00:51:17 <sanjoyd> More like, our window to the universe.
00:51:32 <drdo> I just define it as "this" or something like that
00:51:39 <Cale> sanjoyd: yeah
00:51:40 <drdo> We know what we mean
00:52:07 <Cale> our collection of subjective realities and mutual agreements :)
00:52:15 <drdo> sanjoyd: I define by way around such things
00:52:22 <drdo> anything you can say it's included!
00:52:26 <drdo> *define my
00:54:05 <ClaudiusMaximus> anyone know what might make my program explode like this? http://claudiusmaximus.goto10.org/g/haskell/Describe2.png
00:55:31 <ClaudiusMaximus> the code is rather huge, but it uses Rank2Types to reify Int to type level NaturalNumber, and has a softfloat implementation with precision tagged by such
00:57:26 * hackagebot signed-multiset 0.2 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.2 (StefanHoldermans)
00:58:55 <Cale> That's the most uniformly proportional profiling graph I've ever seen.
00:59:30 <ClaudiusMaximus> uh, i just realized why - thanks ducks!  the softfloat implementation tries to cache constants like pi and log2, but it also tries to compute them at a higher precision to be more accurate.  but the higher precision implementation tries to cache its constants, computed at still higher precision
00:59:35 <ClaudiusMaximus> oops
00:59:37 <ClaudiusMaximus> :)
00:59:49 <Cale> haha
01:00:44 <ClaudiusMaximus> but i think that means i got the caching working!  (which didn't before, and memory usage was sane and performance was abysmal)
01:09:42 <mm_freak> does (\x -> x y) y reduce to y y?
01:09:59 <mm_freak> in untyped lambda calculus that is
01:11:36 <c_wraith> mm_freak: why wouldn't it?
01:12:49 <danr> mm_freak: well, (\y -> (\x -> x y) y) reduces to (\y -> y y) under full beta reduction
01:13:05 <mm_freak> not sure
01:13:12 <mm_freak> just wanted to make sure
01:13:50 <mm_freak> http://augustss.blogspot.de/2007/10/simpler-easier-in-recent-paper-simply.html
01:14:09 <mm_freak> in this post he moves from the untyped to the simply typed lambda calculus
01:14:24 <mm_freak> but only arguments get a type…  what about the result of a lambda?  is it untyped?
01:14:49 <mm_freak> or is the type inferred?
01:15:46 <Ptival> mm_freak: its type is type_of_argument -> type_of_whats_inside_accorging_to_type_of_argument
01:16:01 <mm_freak> so it's inferred?
01:16:11 <Ptival> an algorithm could infer it
01:16:24 <Ptival> I would rather say that it's inductively defined
01:16:35 <mm_freak> ok, thanks
01:17:13 <Ptival> (I might be wrong)
01:17:44 <sanjoyd> mm_freak: basically TYPE(\a:X->b) == X -> (TYPE b, assuming type of a is X)
01:18:26 <sanjoyd> So it should be easy to calculate it recursively, if you're careful about handling free variables.
01:19:55 <mm_freak> apropos free variables
01:20:25 <mm_freak> there are no literals in the language, so how do you represent constructors?  are those just free variables?
01:20:45 <sanjoyd> What constructors?
01:20:50 <mm_freak> constructors of the base types
01:21:07 <Ptival> you can encode them
01:21:12 <sanjoyd> You can go along by using combinators.
01:21:18 <mm_freak> like:  App (Var "x") (Var "y")
01:21:25 <mm_freak> normally you would get a "not in scope" error
01:21:30 <sanjoyd> For instance, you can define integers using the church encoding
01:21:30 <mm_freak> because x and y are free
01:21:42 <Ptival> oh, wait, you're talking about something else
01:21:54 <sanjoyd> So 2 becomes \f x->(f (f x))
01:22:05 <mm_freak> sanjoyd: i know that, you're misinterpreting my question
01:22:11 <sanjoyd> Oh, okay.
01:22:13 <mm_freak> there are base types like Bool
01:22:15 <drdo> mm_freak: You need to base type to have some name
01:22:27 * hackagebot yesod 1.0.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1.1 (MichaelSnoyman)
01:22:37 <mm_freak> i have defined UnitT and BoolT
01:22:41 <drdo> otherwise what yould you do?
01:22:50 <drdo> you just need to call it something
01:23:06 <mm_freak> now how do i introduce the constructors?  would i just add them to the "global" environment?
01:23:17 <Ptival> you mean, (), true, false ?
01:23:19 <mm_freak> yeah
01:23:50 <mm_freak> like when i typecheck 'Var "true"' i'd like to get BoolT
01:23:55 <shachaf> Ooh, do I get to complain about \f x -> f (f x) again?
01:24:03 <Ptival> you'd encode them somehow, and put them in your typing context
01:24:03 <shachaf> Oh, it's an unrelated discussion.
01:24:24 <mm_freak> Ptival: ok, that was my question =)
01:24:45 <sanjoyd> mm_freak: you should be able to include them in the initial typing context, I think.
01:24:49 <drdo> mm_freak: those values have those types by definition :P
01:25:01 <drdo> typeOf true = Bool
01:25:04 <drdo> not much to it
01:25:11 <Ptival> your typing (inference/checking) should have a notion of context already (for binders), so it's just a matter of not starting in the empty context :)
01:25:23 <sanjoyd> Yeah, exactly what Ptival said.
01:25:27 <mm_freak> drdo: my question is how to /make/ that definition, but i think i have my answer
01:25:35 <drdo> mm_freak: like i wrote
01:25:36 <drdo> exactly
01:25:38 <mm_freak> Ptival: yeah
01:25:57 <mm_freak> i don't have a type checker yet, but yes, it's going to have a context
01:26:04 <mm_freak> i'll write the type checker now =)
01:26:36 <drdo> typeOf (Abs p t b) = Fun t (typeOf b)
01:26:38 <drdo> and so on
01:26:50 <drdo> these 4 lines
01:27:00 <Ptival> drdo: well, typeOf wouldn't take only a term!
01:27:14 <Ptival> you need to extend the context upon crossing abstractions
01:27:20 <drdo> Ptival: What else is there?
01:27:31 <Ptival> a typing context
01:27:32 <mm_freak> i guess i'll also need pattern matching soon
01:27:53 <mm_freak> that isn't covered by the article, but it feels quite straightforward
01:28:18 <Ptival> drdo: if "p" appears free in "b", it must have type "t"
01:28:31 <Ptival> typeOf needs to know that in the recursive call
01:30:56 <drdo> Ptival: yeah nevermind, i'm sleepy, i remember keeping equations and doing unification when doing HM inference
01:34:39 <frontendloader> ' in a variable name isn't actually doing anything right? Just a naming convention.
01:35:00 <shachaf> It's just another character, where it's valid.
01:35:04 <Ptival> frontendloader: yes, it usually denotes a variation of the not ' version
01:35:32 <drdo> the good thing about ' conventions is that there's plenty to choose from
01:36:59 <shachaf> @let x `isn't` y = not (x `is` y)
01:37:00 <lambdabot>  Defined.
01:37:28 * hackagebot yesod-platform 1.0.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.0.1 (MichaelSnoyman)
02:00:39 <mm_freak> the pisigma package is in dependency hell =/
02:11:44 <Zun> Hi all
02:13:48 <shamrock> Wow. 36 dollars for learnyouahaskell *ebook* when its free online anyway. Did someone not think through their marketing? Make it 19.99 and I'd buy it as well as use the free one!
02:14:45 <merijn> meh, if it sells, it sells
02:15:01 <shachaf> 36/0 = 20/0
02:15:26 <shachaf> Also, I have the urge to hate you for saying "19.99" instead of "20".
02:15:33 <shamrock> somewhat strange opinion there is selling and there is selling. I buy a lot of ebooks. And 36$ for an ebook when the real copy is only 10 more is way ott.
02:15:35 <shachaf> I will suppress the urge, but still.
02:15:46 <shamrock> I said it on purpose. Its what they do.
02:15:57 <t7> how do i unpack the source from a package from cabal?
02:16:05 <shamrock> their price is xx.95 btw ;)
02:16:12 <mm_freak> t7: cabal help unpack
02:16:14 <shachaf> shamrock: That's assuming that you consider the ebook to be less valuable than the real book.
02:16:25 <shamrock> Why would I consider that?
02:16:33 <mm_freak> t7: if you have a .tar.gz file, you can unpack it right away, otherwise use the "cabal unpack" command
02:16:34 <shamrock> I consider the hard copy a valuable addition.
02:16:35 <shachaf> "real copy is only 10 more"
02:16:48 <shachaf> I know people who refuse to read physical books and only read ebooks.
02:16:53 <shamrock> sure you do.
02:17:00 <shachaf> I do!
02:17:13 <shachaf> Well, at least one person. But this person also hates Haskell.
02:17:16 <shamrock> as I saud, Im sure you do. I dont.
02:17:34 <shachaf> Anyway, I still hate you because you're not actually selling something, so you're just perpetrating the .99 crime.
02:17:36 <shamrock> IMO if you can prove you have the real book you should get the ebook automatically free ;)
02:17:48 <shachaf> (OK, I don't hate you. Just what you did.)
02:18:15 <shamrock> what are you talking about? I used a real price. Its what people do. But then thats the real world. The haskell book pricing is xx.95 anywy.
02:18:24 <Tinned_Tuna> There are some things I would *prefer* in hard copy. Some time because they have large diagrams, so what our library would call "Quatro" books (oversized) are difficult to reasonably shrink down to ebook format.
02:18:38 <shamrock> great book  and great value for a profi programmers book but well, I think its steep for only the ebook copy.
02:18:41 <Tinned_Tuna> Sometimes, I just want the prestige of having an epic book on the shelf behind me :-p
02:19:22 <shachaf> shamrock: Some people have a different marginal dollar value from you.
02:19:23 <shamrock> and batteries run out, and its nice to turn real pages. Lets not forget that touchy feely and "ownership" thing.
02:19:26 <roconnor> @seen geekzus
02:19:26 <lambdabot> Unknown command, try @list
02:19:34 <roconnor> preflex:seen geekzus
02:19:35 <preflex>  Sorry, I haven't seen geekzus
02:19:59 <Tinned_Tuna> Also, yes, there's the feeling that this is my book, mine, and people can't come along and take it away from me.
02:20:03 <shamrock> shachaf: do you always state the obvious as if only you realised it? Of course people have different values than "me". Including you. And people have different values to you.
02:20:13 <Tinned_Tuna> Whereas, I'm fairly sure that Amazon have deleted ebooks remotely
02:20:13 <shamrock> Anywys..
02:20:21 <Tinned_Tuna> "so, you bought that? NOPE."
02:20:52 <companion_cube> I think Amazon deleted "1984" remotely some time ago
02:21:39 <Tinned_Tuna> Did they not see the irony? o.O
02:21:42 <wunki> companion_cube: that's true
02:22:07 <Tinned_Tuna> 1984: Now redacted for the party of Amazon.com
02:22:28 <t7> i can do cabal install thih but i cant see it on hackage
02:23:20 <typoclass> Tinned_Tuna: lawyers do not see irony ...
02:23:44 <merijn> I think it's unfair to blame Amazon for this
02:24:56 <adamt> companion_cube: maybe they placed an unfortunate portal under the book, with the other portal being in outer space.
02:24:58 <merijn> Someone sold them (over Amazon) without (apparently) a license from the rights holders and Amazon was threatened with a lawsuit. Now, we can wish for a world without IP rights allowing this to happen, but in the mean time what did you expect Amazon to do in "not fairy land"?
02:25:14 <companion_cube> adamt: 1984 in spaaaaaaace?
02:26:15 <geekosaur> merijn is right; it was an illegally sold 3rd party book in the amaxon marketplace
02:27:06 <geekosaur> and *legally* they had to delete it from their servers.  the problem is someone hadn't thought through what happened when something from amazon was on a kindle and the entry for it in the central directory went away
02:27:37 <geekosaur> (kindles use amazon for backing store.  nobody had contemplated the need for copy on write)
02:27:48 <merijn> To be fair it was only illegal in a number of countries. While the copyright of 1984 won't expire until 2044 in the US, it has already expired in some other countries
02:28:17 <companion_cube> copyright nonsense again \o/
02:28:33 <merijn> Kindles don't use/need Amazon as a backing store...they have local storage
02:29:10 <merijn> You're amazon ebooks are licensed to your account and it syncs with your account, that's the problem. Solution don't buy DRMed stuff from Amazon (or at all) and the problem is gone
02:29:28 <Tinned_Tuna> The problem is, that to me it sends a strong message. Don't like a book. See if you can copyright-troll it out of existence. No more do you have to track down physical copies of the book, Amazon'll do it for you! (On the assumption that it was digital distribution-only in the first place...)
02:29:39 <companion_cube> and I assume they deleted the ebook for customers in every country?
02:30:00 <Tinned_Tuna> companion_cube: well, the US seems to think it can impose it's law where ever they feel like it
02:30:00 <merijn> companion_cube: The Kindle store is in the US, so they fall under US law
02:30:07 <Tinned_Tuna> so I would say they did so.
02:30:07 <typoclass> i think it *is* amazon's fault. they wouldn't get blamed so much if they sold more shiny things and had a hypnotic sociopath in black turtleneck shirts strutting around on stage ;)
02:30:07 <companion_cube> -_-
02:30:33 <merijn> companion_cube: I'm deeply disturbed by the fundamental lack of understanding of copyright and IP many programmers seem to have, that's why I try and correct wrong claims when i see them
02:31:04 <merijn> (and many academics for that matter)
02:31:24 <companion_cube> ok, but come on, such copyright on 1984 is obviously a bad thing
02:31:43 <merijn> Yes, but that doesn't exempt you from knowing how things work
02:31:44 <typoclass> merijn, i think that's the chilling effect. people are scared and easily bullied these days when IP is mentioned
02:31:55 <geekosaur> they have limited local storage, and are designed to copy stuff to/from amazon as needed to keep that local space available for non-amazon-sourced content
02:32:15 <geekosaur> I dont know how tight they keep that but I know they often store purchases nonlocally
02:32:16 <companion_cube> merijn: it's 70 years after the author dies, now, isn't it?
02:32:34 <Tinned_Tuna> companion_cube: I agree, George Orwell is long dead. It should be public domain by now
02:33:08 <adamt> Mr. Orwell probably sold the copyright to a publisher.
02:33:11 <Tinned_Tuna> (as in, not legally, but I think it should be.)
02:33:31 <Tinned_Tuna> adamt: or the estate did when it became their property.
02:33:42 <merijn> companion_cube: Depends on the country
02:33:52 <companion_cube> merijn: in the US, I meant
02:34:40 <merijn> I think Disney was trying to or maybe even succeeded in prolonging it, since the copyright on mickey mouse was/is about to expire
02:35:14 <typoclass> merijn: yeah, repeatedly. larry lessig tells that story, iirc
02:35:45 <adamt> Maybe copyright shouldn't work the same for ongoing things (such as Mickey Mouse) and the actual works (such as a Mickey Mouse movie.
02:36:37 <companion_cube> maybe it just doesn't make sense to last so long after the work is published
02:37:07 <adamt> That is orthogonal to my statement. Not that we disagree :)
02:37:11 <typoclass> maybe there should be less people lobbying for corporate interests and more people lobbying for the little man and the common good
02:37:23 <Tinned_Tuna> My stance: Copyright is broken. Currently, no viable solution springs to mind (for me). This makes me sad.
02:37:58 <adamt> I heard many people find p2p a viable alternative, hehe.
02:39:37 <shirt> let applyN 1 f = f; applyN n f = f . (applyN (n-1) f)
02:39:46 <shirt> how can i improve this?
02:42:06 <jgr> shirt: iterateN?
02:42:28 <jgr> http://www.haskell.org/hoogle/?hoogle=Int+-%3E+%28a-%3Ea%29+-%3E+%28a-%3Ea%29
03:07:56 * hackagebot pem 0.1.1 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.1.1 (VincentHanquez)
03:12:18 <ketil> Is logBase 2 much more expensive than log?  And is there a difference between Double and Float instances?
03:12:37 <ketil> (After a small change, my program is suddenly a lot slower)
03:20:08 <geekosaur> logBase default implementation calls log twice (as would be expected)
03:20:29 <geekosaur> dunno about float vs. double but the naive implementation would have Double be faster
03:22:53 * geekosaur is, per usual, lost in a twisty maze of primops
03:25:39 <liyang> Watch out for grues.
03:48:03 <merijn> Style question, if I want to wrap a function to ignore its first argument: "const foo" or "\x -> foo"?
03:48:58 <jonkri> how can i use these instances to generate random bytes (like Word8)? http://hackage.haskell.org/packages/archive/random/1.0.0.0/doc/html/System-Random.html#t:Random
03:49:37 <shirt> merijn: let ignoreFirst = const in ignoreFirst foo
03:49:48 <t7> http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html at section 7.2 they define class environment using a partial function rather than a map or lookup list. Why is this?
03:49:49 <mekeor> merijn: const, imo.
03:49:55 <mekeor> merijn: and if you want to use a lambda, then '\_ -> foo', imo.
03:49:59 <mekeor> merijn: uncurry fst
03:50:05 <mekeor> @type uncurry fst
03:50:05 <lambdabot> forall b b1 c. ((b1 -> c, b), b1) -> c
03:50:16 <mekeor> nah
03:50:46 <mekeor> @type curry fst
03:50:46 <lambdabot> forall a b. a -> b -> a
03:51:00 <typoclass> merijn: i write \_ -> foo, i somehow find it clearer in the sense that "const" is a word i have to read whereas punctuation is something graphical that makes sense even when glancing
03:51:23 <rtharper> typoclass: I agree, actually =p
03:52:34 <mekeor> i'd argue with "i prefer functions over syntax" for "const".
03:54:01 <hpaste_> mcstar pasted “worked for the first try” at http://hpaste.org/67267
03:54:54 <mekeor> t7: cool link, thanks =)
04:01:06 <typoclass> t7: i feel there is a lot of overlap between Data.Map, an assoc list like [(key, value), ...], and a partial function. in this case, any of the three choices seems fine. not sure if there's any strong reason.
04:01:32 <t7> well they use a [(key, vaule)] for other things above
04:01:48 <t7> seems harder than it needs to be
04:03:25 <merijn> I don't suppose there's a variant of (&&&) for three functions? :p
04:04:17 <t7> you would need agda style infix notation for that
04:04:32 <t7> i think?
04:04:49 <merijn> Naah, you could just have a prefix function
04:06:36 <t7> Type classes are too hard :3 in my language you will have to pass around dictionary's explicitly
04:06:39 <typoclass> > (\x -> (pred x, succ x, odd x)) 42
04:06:40 <lambdabot>   (41,43,False)
04:06:58 <mekeor> t7: your language?
04:07:07 <typoclass> i don't think a hypothetical (&&&&) would really save many keystrokes :)
04:07:13 <t7> yeah im gonna write a hacky extension to C
04:07:24 <mekeor> t7: cool. oO
04:07:28 <merijn> typoclass: It's not about keystrokes, it's about looking better :p
04:07:48 <mekeor> i.e., elegance.
04:08:18 <merijn> But yeah, haskell should get Agda like mixfix. That'd be awesome
04:08:28 <merijn> Imagine the insanely neat DSLs you could make with that
04:08:51 <typoclass> > map ($ 42) [succ, pred, (*2)] -- if they all output the same type
04:08:52 <t7> merijn: yeah but you cant partially apply infix operators anymore :(
04:08:52 <lambdabot>   [43,41,84]
04:09:19 <mekeor> t7: really?
04:09:19 <fmap> > sequence [succ, pred, (*2)] 42
04:09:20 <lambdabot>   [43,41,84]
04:09:30 <merijn> t7: For technical reason or did agda just not invest the effort to support that?
04:09:45 <t7> they said the parser was complicated enough
04:09:50 <mekeor> t7: ah, oh. you're talking about agda, aren't you?!?
04:09:51 <t7> in some video i watched a while ago
04:10:19 <merijn> t7: Lousy reason, you only need to implement the parser once to save all programmers time forever
04:10:22 <Saizan> there is actually a prototype that allows sections
04:11:26 <merijn> You only want slicing for binary infix operators anyway, I think. It doesn't make much sense for mixfix (maybe it does, but just infix alone without slicing would be awesome enough)
04:12:11 <mekeor> additionally, the naming-conventions in agda are neat, too; i mean, isn't 'foo->bar' are cool function-identifier?
04:12:48 <mm_freak> haskell could use many features of agda
04:12:50 <mekeor> s/are/a/
04:13:17 <merijn> If I have a datatype  (record syntax) and I only export some field names + a default value, that would allow people to take the default and set the exported fields but prevent them from touching unexported fields, right?
04:13:19 <mm_freak> i wonder why we'll get -XDependentTypes
04:13:26 <mm_freak> why → when
04:13:36 <mekeor> mm_freak: :D
04:13:50 <mekeor> mm_freak: do you think that'd be backwards-compatible?
04:14:00 <Saizan> i guess so, but you should test
04:14:23 <t7> also why the fuck do they design their own State monad. Is State newer than this document?
04:14:24 <mm_freak> mekeor: well, the dependent function arrow is an additional feature
04:14:28 <mm_freak> if you don't use it, nothing changes
04:14:41 <mm_freak> except that you don't need :k anymore, you'll just have :t
04:14:48 <mekeor> yea
04:15:05 <Saizan> t7: maybe they just want to be self-contained
04:15:29 <mm_freak> and error messages would get a little weirder
04:15:48 <t7> im having a moany old day today
04:16:05 <mm_freak> Maybe 3 would be a type error, not a syntax error, and "Maybe -> Int" would be a type error, not a kind error
04:16:43 <mekeor> mm_freak: ah yes right…
04:24:36 <Ptival> mm_freak: how do you know about dependent types, but still have questions about ULC/STLC? :D
04:26:27 <ClaudiusMaximus> @djinn ((Maybe a -> b) -> b) -> ((a -> b) -> Maybe b)
04:26:27 <lambdabot> f _ _ = Nothing
04:26:49 <Ptival> haha
04:26:52 <mekeor> :D
04:27:13 <ClaudiusMaximus> @djinn ((a -> b) -> Maybe b) -> ((Maybe a -> b) -> b)
04:27:13 <lambdabot> f a b =
04:27:14 <lambdabot>     case a (\ c -> b (Just c)) of
04:27:14 <lambdabot>     Nothing -> b Nothing
04:27:14 <lambdabot>     Just d -> d
04:27:16 <Ptival> djinn has the laziness spirit :D
04:27:21 <sanjoyd> @djinn Int -> Maybe Int
04:27:21 <lambdabot> Error: Undefined type Int
04:27:26 <sanjoyd> @djinn a -> Maybe a
04:27:26 <lambdabot> f = Just
04:27:41 <sanjoyd> @djinn a -> Maybe b
04:27:42 <lambdabot> f _ = Nothing
04:27:59 <sanjoyd> @djinn Maybe (a->b) -> a -> b -> b
04:28:00 <lambdabot> f a b c =
04:28:00 <lambdabot>     case a of
04:28:00 <lambdabot>     Nothing -> c
04:28:00 <lambdabot>     Just d -> d b
04:28:03 <sanjoyd> Not bad.
04:28:22 <sanjoyd> @djinn Maybe (a->b) -> (a -> b) -> a -> b
04:28:22 <lambdabot> f a b =
04:28:22 <lambdabot>     case a of
04:28:22 <lambdabot>     Nothing -> b
04:28:22 <lambdabot>     Just c -> c
04:32:25 <byorgey> sanjoyd: ISTR it has some heuristics so that it tries to use all the arguments
04:34:17 <merijn> @pl f a >> f b
04:34:18 <lambdabot> f a >> f b
04:34:26 <merijn> @pl \a b -> f a >> f b
04:34:27 <lambdabot> (. f) . (>>) . f
04:34:55 <mekeor> merijn: (>>)`on`f
04:34:58 <mekeor> @type on
04:34:59 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:36:04 <merijn> mekeor: That doesn't really increase readability though.
04:36:24 <t7> @hoogle (a -> b) -> (a, c) -> (b, c)
04:36:24 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
04:36:24 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:36:25 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
04:36:29 <mekeor> merijn: it's more readable than '(. f) . (>>) . f', imo.
04:36:36 <t7> whats the arrow function for that?
04:36:45 <merijn> "(>>) `on` closeStream $ stream1 stream2" vs "closeStream stream1; closeStream stream2" (inside a do block atm)
04:36:53 <typoclass> > first succ (42,37) -- t7
04:36:54 <lambdabot>   (43,37)
04:37:02 <mekeor> merijn: ah, okay. nevermind then.
04:37:06 <typoclass> there's also, badum-ching, "second"
04:37:08 <merijn> t7: first?
04:37:12 <mm_freak> Ptival: i'm having questions about /implementing/ those calculi =)
04:37:16 <mm_freak> this is my first time
04:37:31 <mm_freak> i'm trying to make my own toy programming language to learn how to write compilers for functional languages
04:37:46 <mm_freak> dependently typed ones in particular =)
04:37:50 <merijn> @hoogle (a -> b) -> (a, a) -> b
04:37:51 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
04:37:54 <mekeor> mm_freak: boah O_O
04:38:03 <merijn> @hoogle (a -> b) -> a -> a -> b
04:38:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:38:04 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:38:04 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:38:33 <mm_freak> mekeor: ?
04:38:54 * mekeor is just impressed.
04:39:17 <mm_freak> uhm…  by what?  i'm a beginner in that area
04:39:46 * mekeor is just impressed by your plan/project/idea/goal/aim.
04:40:27 <mm_freak> i doubt that it will turn into a real programming language, but if i'm successful you can at least expect (yet another) dependently typed core language implementation on hackage =)
04:40:36 <mm_freak> together with an x86 compiler for it
04:41:18 <mm_freak> there is pisigma, but unfortunately it's in dependency hell and i don't feel like fixing it manually
04:41:19 * mekeor is looking forward.
04:41:21 <t7> :t fmap second
04:41:22 <lambdabot> forall (a :: * -> * -> *) b c d (f :: * -> *). (Arrow a, Functor f) => f (a b c) -> f (a (d, b) (d, c))
04:41:40 <t7> wtf
04:42:07 <mm_freak> t7: what did you expect?
04:42:10 <mm_freak> :t fmap snd
04:42:11 <t7> > fmap second (Just (1,2))
04:42:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f b
04:42:12 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
04:42:12 <lambdabot>    arising from a use of `Control...
04:42:20 <t7> oh haha
04:42:22 <mm_freak> > fmap snd (Just (2, 3))
04:42:23 <lambdabot>   Just 3
04:43:58 <mekeor> > fmap ($(1.2,1.4)) (fmap second (Just round)) -- let's try, come on, pls work!
04:44:00 <lambdabot>   Just (1.2,1)
04:44:05 <mekeor> boom!
04:48:14 <merijn> Is there a pointfree way to write "\x -> Foo{bar = x}"?
04:49:04 <hpc> merijn: with lenses, probably
04:51:12 <mekeor> wow; there's even a package called "pointless-lenses".
04:52:07 <Gaffar> Hey guys, iv have been looking at a university to study computer scince. The course content says "Functioning programming in Haskell' what sort of career can i get into once i have the knowledge
04:52:52 <int-e> stay away from that, it'll spoil you for PHP or Java programming forever.
04:53:37 <mekeor> @faq Can Haskell help to make a great career?
04:53:37 <lambdabot> The answer is: Yes! Haskell can do that.
04:53:45 <hpc> Gaffar: https://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/ -- interesting careers, if you also learn the domain-specific stuff you need to be in that field to begin with
04:54:02 <typoclass> merijn: maybe you could turn on that one extension ("RecordWildcards"?) and then say "let x = 42 in Foo{..}" :)
04:54:27 <hewwoleon> hewwo peeps
04:54:59 <hewwoleon> troll la lol
04:55:04 <hewwoleon> wheres my gold leaf?
04:56:05 <Gaffar> Thanks for the link hpc (bookmarked), ill will join back later still at college = ]
04:56:07 <typoclass> Gaffar: many people believe that learning haskell will make you a better programmer, whatever language you use
04:56:07 <merijn> typoclass: Not really worth it, I have one place where I have a function like that :p
04:56:25 <hewwoleon> wow unlucky guys
04:57:06 <hewwoleon> can i ask for some help from someone
04:57:09 <hewwoleon> ?????????????
04:57:12 <Gaffar> ahh okay, something to think about. like i said ill join back later. ill ask my programming teacher
04:57:15 <mekeor> hewwoleon: just ask :)
04:57:45 <hewwoleon> well i want to make a program that can open and save xbox game saves
04:57:50 <hewwoleon> any tips on how to dfo it
04:57:52 <hewwoleon> do*
04:58:26 <merijn> hewwoleon: Opening and saving files is easy. The problem is you need to know the file structure and I'm pretty sure that is different for each game
04:58:42 <merijn> hewwoleon: So for every game you'd want to edit you'd first have to figure out the file format of the save files
04:59:21 <hewwoleon> thanks for the hlep and i will come back to yous in a little bit
05:00:38 <abdulsattar> hello, I noticed a really wierd thing today
05:01:03 <abdulsattar> sequence $ replicate 10 (randomIO :: IO Int)
05:01:15 <abdulsattar> gives me 10 random values
05:01:25 <merijn> Yes
05:01:35 <mekeor> abdulsattar: use replicateM instead. but anyway…
05:01:35 <abdulsattar> If i replace replicate 10 with repeat, it stops execution
05:01:57 <merijn> :t repeat
05:01:58 <lambdabot> forall a. a -> [a]
05:02:18 <merijn> abdulsattar: What's the weird part?
05:02:19 <abdulsattar> I know it does not complaiin
05:02:33 <abdulsattar> but repeat gives me an infinite list
05:02:34 <typoclass> abdulsattar: repeat doesn't just do it 10 times, it keeps going infinitely
05:02:59 <abdulsattar> when i sequence it, it stops
05:03:05 <abdulsattar> doesn't give me any output
05:03:16 <merijn> Do you use the result anywhere?
05:03:22 <abdulsattar> It's as if its trying sequence the whole infinte array
05:03:30 <merijn> Well, yes
05:03:37 <merijn> That's because that's what it is doing
05:04:22 <fmap> @src sequence
05:04:22 <lambdabot> sequence []     = return []
05:04:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:04:23 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:04:40 <abdulsattar> Know it stops execution
05:04:54 <abdulsattar> If I take 10 out of it, it stops
05:05:10 <abdulsattar> Isn't it supposed to work on infinte lists?
05:05:23 <hpc> abdulsattar: what about this?
05:05:25 <hpc> main = do
05:05:35 <abdulsattar> sequence (repeat (randomIO :: IO Int)) >>= return . take 10
05:05:36 <hpc>   make an IORef, x
05:05:46 <abdulsattar> This should work, shouldn't it?
05:05:48 <hpc>   sequence (repeat (increment x))
05:05:51 <hpc>   read and print value of x
05:05:55 <hpc> -- what prints?
05:06:13 <hpc> it just keeps incrementing the IORef forever
05:06:48 <abdulsattar> hpc: I know how repeat works. I know how sequence works too, but I don't get this behavior
05:06:52 <abdulsattar> sequence (repeat (randomIO :: IO Int)) >>= return . take 10
05:07:05 <mekeor> abdulsattar: i'm not sure. but i'm sure that ›sequence (take 10 $ repeat (randomIO :: IO Int))‹ should work.
05:07:08 <abdulsattar> ^ doesn't give me 10 elements
05:07:11 <hpc> :t sequence (repeat (randomIO :: IO Int))
05:07:12 <lambdabot> IO [Int]
05:07:24 <abdulsattar> Does it work on your sys?
05:07:40 <abdulsattar> It tries to get the whole array at once.
05:08:17 <mekeor> abdulsattar: as we saw above, sequence is a foldr. so, it won't work with infinte lists.
05:08:18 <abdulsattar> If I replace repeat with replicate 10 it works fine
05:08:19 <hpc> abdulsattar: the side effects of randomIO need to run an infinite number of times before we can pass to the other side of (>>=)
05:08:35 <merijn> abdulsattar: I think what you want instead of "repeat (randomIO :: IO Int)" is "newStdGen >>= randoms"
05:08:52 <merijn> :t newStdGen >>= randoms
05:08:53 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[a]'
05:08:53 <lambdabot>     In the second argument of `(>>=)', namely `randoms'
05:08:53 <lambdabot>     In the expression: newStdGen >>= randoms
05:08:56 <abdulsattar> mekeor: I thought foldr runs on infinte lists
05:09:04 <merijn> :t newStdGen >>= randoms :: IO [Int]
05:09:04 <lambdabot>     Couldn't match expected type `IO [Int]' against inferred type `[a]'
05:09:05 <lambdabot>     In the second argument of `(>>=)', namely `randoms'
05:09:05 <lambdabot>     In the expression: newStdGen >>= randoms :: IO [Int]
05:09:06 <hpc> @src sequence
05:09:06 <lambdabot> sequence []     = return []
05:09:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:09:07 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:09:27 <merijn> abdulsattar: You can, but that doesn't mean it'll stop
05:09:30 <mekeor> abdulsattar: oh fuck. i mixed something up then, sorry =) forgive me =)
05:09:40 <merijn> > foldr (+) 0 [1..]
05:09:41 <lambdabot>   *Exception: stack overflow
05:10:00 <mekeor> merijn: was i right or wrong?
05:10:02 <typoclass> abdulsattar: sequence means basically "here is a list of IO actions -- do them all now". the problem is that the list is infinitely long
05:10:13 <merijn> mekeor: foldr has nothing to with it
05:10:23 <typoclass> abdulsattar: could you tell us more about what you're trying to do?
05:10:25 <abdulsattar> typoclass: I'm taking 10 elements from the list
05:11:09 <abdulsattar> sequence (replicate 10 (randomIO :: IO Int) works fine
05:11:37 <abdulsattar> sequence (replicate 10 (randomIO :: IO Int) >>= return . take 10 is its synonym
05:11:46 <abdulsattar> It fails
05:11:49 <hpc> abdulsattar: lemme hpaste an explanation
05:12:26 <abdulsattar> here's the wierd part: If I run return after replicate and then replicate again, replicate too would fail!
05:12:46 <abdulsattar> hpc: mekeor: typoclass: You there?
05:12:47 <byorgey> abdulsattar: what do you mean "fails"?
05:13:12 <abdulsattar> byorgey: It just stops
05:13:36 <abdulsattar> byorgey: as it would do in length [1..]
05:13:59 <eirqui> I need to map a function over a list. the function should get at as a paramter also the index of the element it is mapped over. how can i do this?
05:14:35 <byorgey> abdulsattar: both work fine for me.
05:14:57 <abdulsattar> byorgey: I'm using Ghc 7.4.1, yours?
05:14:59 <byorgey> sequence (replicate 10 (randomIO :: IO Int))   -- gives me a list of 10 Ints
05:15:00 <byorgey> same
05:15:08 <fmap> > zip [0..] ['a'..'f']
05:15:09 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
05:15:14 <byorgey>  sequence (replicate 10 (randomIO :: IO Int)) >>= return . take 10  -- also gives me a list of 10 Ints
05:15:32 <fmap> eirqui: ^
05:15:40 <typoclass> abdulsattar: i think the short answer is: sequence is one of the functions that don't work on infinite lists (if used as you use it)
05:15:40 <abdulsattar> byorgey: the latter does not give me anything
05:15:51 <abdulsattar> typoclass: sequence works on ifnite lists
05:15:54 <hpc> abdulsattar: http://hpaste.org/67268 -- the terminating version
05:16:00 <hpc> (pasting the non-terminating version)
05:16:05 <byorgey> abdulsattar: if you copy and paste exactly what I wrote into ghci?
05:16:07 <eirqui> fmap: what do you mean?
05:16:11 <abdulsattar> typoclass: sequence $ repeat (putStrLn "hello")
05:17:07 <abdulsattar> byorgey: sequence (replicate 10 (randomIO :: IO Int)) >>= return . take 10
05:17:15 <abdulsattar> byorgey: ^ replace replicate 10 with repeat
05:17:25 <typoclass> abdulsattar: yes, but you're using it differently now. that IO action has a side-effect (something is printed to the terminal). you can see that side-effect. "randomIO" does not have a side-effect like that, therefore you won't see anything
05:17:28 <byorgey> abdulsattar: sequence does work on infinite lists, but for many monads (including IO) the result cannot be returned lazily
05:17:38 <fmap> eirqui: zip list with indeces and then pass it to map
05:17:55 <byorgey> abdulsattar: oh, I am not surprised that if you use 'repeat' it does not give you anything
05:17:57 <eirqui> fmap: thanks, i will try it
05:18:09 <hpc> @src mapM
05:18:09 <lambdabot> mapM f as = sequence (map f as)
05:18:16 <typoclass> abdulsattar: you could do "sequence (repeat (an IO action which does randomIO and then calls print))". that'd work
05:18:26 <hpc> @src mapM_
05:18:26 <lambdabot> mapM_ f as = sequence_ (map f as)
05:18:35 <byorgey> abdulsattar: because the result of an IO computation cannot be returned lazily.  the entire computation must be run before any of the result is returned.
05:18:55 <byorgey> the only way to get the result lazily is to use unsafeInterleaveIO
05:19:00 <abdulsattar> typoclass: byorgey: I get it now
05:19:08 <byorgey> but I am not sure in what circumstances it is safe to use it.
05:20:15 <abdulsattar> byorgey: The funny thing is if I Ctrl-C the repeat operation, the next randomIO wouldn't work
05:21:08 <abdulsattar> hpc: byorgey: typoclass: Thank you for explaining it to me. Much appreciated.
05:21:38 <byorgey> absence: hmm, strange
05:21:50 <byorgey> err, I mean abdulsattar, but I guess they left
05:22:38 <typoclass> > zipWith (\i x -> "at " ++ show i ++ ": " ++ show x ) [0..] "yes yes" -- eirqui, this would be easiest i think
05:22:39 <lambdabot>   ["at 0: 'y'","at 1: 'e'","at 2: 's'","at 3: ' '","at 4: 'y'","at 5: 'e'","a...
05:24:52 <eirqui> typoclass: thanks
05:30:51 <mm_freak> learning haskell will ruin you for PHP…  it won't just make it difficult to program in PHP…  it will make you develop a deep and true HATRED of PHP
05:31:12 <Tinned_Tuna> I remember the days that I programmed regularly in PHP
05:31:18 <Tinned_Tuna> Not fondly, mind you.
05:31:35 <eirqui> i use the sqrt function and i know that the result always is an integer - how can i turn the float into an integer?
05:31:52 <ppseafield> mm_freak: php ruins itself perfectly fine
05:32:06 <Tinned_Tuna> eirqui: floor maybe?
05:32:19 <Tinned_Tuna> :t sqrt
05:32:19 <lambdabot> forall a. (Floating a) => a -> a
05:32:35 <Tinned_Tuna> @hoogle (Floating a) => a -> Integer
05:32:35 <eirqui> tinned_tuna: i thought of this, but i think its ugly, because i dont need the functionality of floor
05:32:35 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
05:32:35 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
05:32:36 <lambdabot> Prelude acos :: Floating a => a -> a
05:33:40 <mm_freak> eirqui: for integer square roots you probably shouldn't use sqrt
05:33:49 <mm_freak> get the arithmoi package and use integerSquareRoot
05:33:53 <fmap> @hoogle (RealFrac a, Integral b) => a -> b
05:33:54 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
05:33:54 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
05:33:54 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
05:34:19 <mm_freak> arithmoi also has a very fast exactSquareRoot function for integers
05:34:24 <nart> how can i create a function that takes a number and return a list of n emptyMVars ?
05:34:37 <mm_freak> nart: use replicateM
05:34:57 <hpc> mvars = flip replicateM newEmptyMVar
05:35:00 <nart> that's it, damn it, i could find it .... thanks for it eheh
05:35:09 <nart> *i couldn't
05:35:41 <typoclass> nart: if you want to write one yourself, recursion would be a good approach. write a function that creates one empty MVar, then calls itself
05:36:08 <mm_freak> well, the evolution of replicateM
05:36:13 <nart> typoclass: i tried, but i get  No instance for (Control.Monad.Base.MonadBase IO m0)
05:36:13 <nart>       arising from a use of `newEmptyMVar'
05:36:26 <mm_freak> createNMVars :: Int -> IO [MVar a]
05:36:27 <hpc> @hoogle newEmptyMVar
05:36:27 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
05:36:40 <mm_freak> doNTimes :: Int -> IO a -> IO [a]
05:36:55 <mm_freak> replicateM :: (Monad m) => Int -> m a -> m [a]
05:37:05 <frontendloader> if you're trying to sqrt an integer you need to fromIntegral it as well
05:37:12 <mm_freak> replicateA :: (Applicative f) => Int -> f a -> f [a]
05:37:25 <hpc> @hoogle replicateA
05:37:26 <lambdabot> Data.Sequence replicateA :: Applicative f => Int -> f a -> f (Seq a)
05:37:34 <hpc> nifty
05:38:33 <mm_freak> nart: createNMVars 0 = pure []; createNMVars n = liftA2 (:) newEmptyMVar (createNMvars (n - 1))
05:38:44 <mm_freak> but really, just use replicateM
05:39:04 <mm_freak> it's exactly the same, but allows you to specifiy the action
05:42:06 <mekeor> > replicateM 5 (*2) 2 -- does that work?
05:42:07 <lambdabot>   [4,4,4,4,4]
05:42:41 <hpc> > replicateM 5 (* 2) <*> [1..5]
05:42:42 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
05:43:09 <hpc> > replicateM 5 (* 2) =<< [1..5]
05:43:10 <lambdabot>   [2,2,2,2,2,4,4,4,4,4,6,6,6,6,6,8,8,8,8,8,10,10,10,10,10]
05:43:12 <hpc> ha!
05:43:46 <mekeor> it works. but it doesn't do what i wanted.  -- is there no prelude/base-function for calling a function N times on something?
05:44:10 <mekeor> @hoogle Int -> (a -> a) -> a -> a
05:44:11 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
05:44:11 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
05:44:11 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
05:44:41 <fmap> > take 5 $ iterate (+2) 7
05:44:42 <lambdabot>   [7,9,11,13,15]
05:45:10 <hpc> > let nTimes = foldr (.) id .: replicate in nTimes 5 (* 2) 1
05:45:12 <lambdabot>   32
05:45:30 <hpc> (.:) = fmap . fmap
05:46:22 <mekeor> cool
05:47:00 <mm_freak> mekeor: take n . iterate f $ x
05:47:21 <hpc> mm_freak: isn't that (!! n)?
05:47:32 <mm_freak> > let applyNTimes n f = take n . iterate f in applyNTimes 3 (^2) 2
05:47:34 <lambdabot>   [2,4,16]
05:47:38 <mm_freak> uhm
05:47:39 <mm_freak> not take
05:47:43 <mm_freak> (!! n) =)
05:47:54 <mm_freak> > let applyNTimes n f = (!! n) . iterate f in applyNTimes 3 (^2) 2
05:47:55 <lambdabot>   256
05:48:11 <hpc> :t (.::)
05:48:11 <lambdabot> Not in scope: `.::'
05:48:47 <hpc> > let (.::) = (.:) . fmap; applyNTimes = flip (!!) .:: iterate in applyNTimes 3 (^2) 2
05:48:48 <t7> bitonic: why does you type inference fresh value (TyVar) start at 1 instead of 0
05:48:48 <pchiusano> is there a name for the algebraic structure with addition and multiplication, but where addition is just a monoid, rather than a group,?
05:48:48 <lambdabot>   The section `GHC.Real.^ 2' takes one argument,
05:48:48 <lambdabot>  but its type `GHC.Types.Int...
05:48:54 <hpc> nooooooo!
05:49:04 <hpc> > let (.::) = (.:) . fmap; applyNTimes = (!!) .:: iterate in applyNTimes 3 (^2) 2
05:49:05 <lambdabot>   The section `GHC.Real.^ 2' takes one argument,
05:49:06 <lambdabot>  but its type `[a]' has none
05:49:25 <hpc> > let (.::) = (.:) . fmap; applyNTimes = (!!) .:: iterate in applyNTimes (^2) 3 2
05:49:25 <lambdabot>   Couldn't match expected type `t1 -> t'
05:49:26 <lambdabot>         against inferred type `[GHC....
05:49:29 <hpc> i give up
05:55:10 <Tinned_Tuna> pchiusano: I can't remember the exact definitions, but that sounds vaguely reminiscent of a ring.
05:55:26 <Tinned_Tuna> (I could be easily wrong though, I can't remember the definitions exactly!)
05:57:55 <Tinned_Tuna> nope, he's gone and I'm wrong.
05:57:57 <Tinned_Tuna> oh well.
05:58:19 * hackagebot graphviz 2999.13.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.13.0.0 (IvanMiljenovic)
05:58:52 <shayan> hi
05:58:55 <shayan> anyone here
05:59:01 <sipa> nope, sorry
05:59:02 <shayan> i like this haskell
06:00:27 <byorgey> shayan: me too!
06:01:01 <shayan> @borgey i am new to programming
06:01:02 <lambdabot> No match.
06:01:34 <shayan> Is There An IDE
06:01:35 <typoclass> shayan, everyone agrees that this is a good textbook on haskell:
06:01:37 <typoclass> @where lyah
06:01:37 <mekeor> is it possible to like haskell more than a person P while you know less haskell than P?
06:01:37 <lambdabot> http://www.learnyouahaskell.com/
06:01:44 <typoclass> it's available for free online
06:02:15 <shayan> this thing looks sweet
06:02:27 <shayan> just like jaffaCAKE
06:02:29 <mekeor> shayan: there's no IDE which most haskellers use. some use emacs, vim, geany, gedit,... actually all editors are fine.
06:02:34 <shayan> If it has sugar
06:02:54 <byorgey> Tinned_Tuna: (for future reference, it's a semiring)
06:03:16 <shayan> so can you make GUI's
06:03:42 <mekeor> shayan: of course you can program GUI-applications with haskell, yes.
06:03:44 <Tinned_Tuna> byorgey: thanks :-)
06:03:56 <Tinned_Tuna> I only studied abstract algebra lightly
06:04:12 <Tinned_Tuna> I kinda want to do another degree, this time entirely in Maths.
06:04:40 <Tinned_Tuna> (and actually do well in it, rather than CS/Maths where I ignored the Maths and did well in the CS :-p )
06:04:40 <shayan> Which One Is Better Python,C++ Or Haskell
06:04:48 <Tinned_Tuna> shayan: .
06:05:05 <sipa> shayan: look at the name of this channel, and wonder whether you can get an objective answer on that question
06:06:34 <Rmx> sipa, that doesn't answer his question, so: what do you prefer between C++ and Python?
06:06:53 <Rmx> shayan, Personally, my choice go for RPG maker t_t
06:06:59 <Zedrikov> makeor, shayan: For IDE, there is also leksah
06:07:13 <typoclass> shayan: after discovering haskell, i did lose interest in python because i so many things are missing and feel awkward. i had only a light interest in c++ to start with, because it's so complicated and ugly
06:07:20 <mekeor> Zedrikov: m E keor. my nick is mEkeor.
06:07:27 <mekeor> Zedrikov: oh right.
06:07:45 <bitonic> t7: hey
06:07:53 <bitonic> t7: I'm not sure there's a particular reason
06:08:00 <bitonic> wait, does it start at 1?
06:08:11 <t7> i thought it needs to start from 0 because of type Schemes
06:08:17 <t7> but i havnt had any errors
06:08:36 <shayan> but has resources
06:08:37 <shayan> C++ is complicated
06:08:42 <Ptival> it's a fresh name generator?
06:09:30 <Zedrikov> mekeor, shayan: and there is also yi, I believe
06:09:39 <mekeor> right
06:10:10 <bitonic> t7: yeah I start them from 1, there might or might not be a reason :P
06:10:16 <bitonic> can't remember right now and I don't have time
06:10:23 <mm_freak> when writing a dependently typed lambda calculus implementation there are two kinds of lambdas:  Lambda and Pi…  i see no difference in the handling of them
06:10:26 <mm_freak> why the distinction?
06:10:33 <mm_freak> reference:  http://augustss.blogspot.de/2007/10/simpler-easier-in-recent-paper-simply.html
06:10:49 <mekeor> Zedrikov: the problem with leksah is that it requires GHC 6.something ..
06:11:19 <PatrickRobotham> How do you create gensyms in haskell?
06:11:39 <dafis> Anybody here with a github account?
06:11:50 <mekeor> yep
06:11:52 <Zedrikov> mekeor, I run it on the 7.4 version
06:12:13 <dafis> I have a bug report for monadcryptorandom and I do *not* want to sign up for github
06:12:26 <mekeor> Zedrikov: oh... okay. https://github.com/leksah/leksah/blob/master/Readme states it requires GHC 6 though…
06:13:01 <mekeor> dafis: so, you want to create an "issue" ?
06:13:01 <dafis> Would somebody do it in my place?
06:13:02 <Rmx> mm_freak, what is the big advange of data family in netwire ?
06:13:03 <Zedrikov> mekeor, maybe I just used cabal, I didn't visit your link.
06:13:09 <dafis> mekeor: yes
06:13:21 * hackagebot Graphalyze 0.13.0.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.13.0.0 (IvanMiljenovic)
06:13:23 * hackagebot SourceGraph 0.7.0.2 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.2 (IvanMiljenovic)
06:13:58 <dafis> mekeor: and when I click on new issue, it takes me to sign up and pricing
06:14:00 <Rmx> mm_freak, and no idea about your question, sorry to ask now, but since I see you there.. :)
06:14:18 <mekeor> dafis: sorry, i won't do it for you. but you could also just write a mail to the maintainer or so… dunno.
06:14:19 <t7> > let fix f = f (fix f) in fix (1:)
06:14:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:14:58 <dafis> mekeor: already done, just wanted it registered at the repo too.
06:15:32 <mekeor> dafis: i suppose the email will be enough. dunno.
06:15:36 <mm_freak> Rmx: efficiency…  the data family made a speedup by a factor of 40
06:15:53 <dafis> mekeor: Well, I hope so.
06:15:58 <t7> :t fix f = f (fix f)
06:15:59 <lambdabot> parse error on input `='
06:16:12 <t7> :t let fix f = f (fix f) in fix
06:16:12 <lambdabot> forall t. (t -> t) -> t
06:16:13 <Rmx> can you point out, or just give me any advice about where to search for explanation?
06:16:37 <mm_freak> Rmx: background:  Wire is an arrow transformer, so without a type family you would write (simplified):  newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
06:17:03 <mm_freak> now you need to pack every monadic computation into the Kleisli arrow and handle tuples everywhere
06:17:51 <mm_freak> to avoid that have Wire be a type family and write:  newtype instance Wire e (Kleisli m) a b = WireM (a -> m (Either e b, Wire e (Kleisli m) a b))
06:18:09 <mm_freak> that way you can just write the underlying wires in the usual monadic style with monadic performance
06:18:48 <mm_freak> now Kleisli just serves at the type level…  at the value level you have monadic computations instead of Kleisli-arrowic computations
06:19:09 <Rmx> oh
06:19:48 <Rmx> hm.. wiki didn't helped me to understand.
06:19:58 <Rmx> thanks
06:20:02 <mm_freak> normally you shouldn't need to know that to use netwire
06:20:10 <mm_freak> but yeah, it helps
06:20:24 <Rmx> I decided to write my netwireCopy librairy ;)
06:20:35 <mm_freak> what would that do?
06:20:45 <keep_learning> hello all
06:20:51 <Philonous> How might one name a package that contains picklers for xml-types?
06:20:51 <mm_freak> hi there keep_learning
06:21:01 <Rmx> exactly the same as you, but it would make me understand everything better
06:21:09 <Rmx> and feel more confident!
06:21:34 <keep_learning> I want to access the value pass with  -N ( +RTS -N8 -RTS )
06:21:49 <keep_learning> mm_freak: Hi
06:22:25 <Rmx> mm_freak, by the way, couldn't it be possible to replace functional dependency by type family?
06:22:27 <keep_learning> How can I get the value passed with N in my program
06:23:07 <Philonous> keep_learning:  http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:numCapabilities
06:23:24 * hackagebot graphviz 2999.13.0.1 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.13.0.1 (IvanMiljenovic)
06:23:38 <Rmx> mm_freak,  is this a choice not to do so?
06:24:07 <keep_learning> Philonous: Thank you
06:27:05 <rasfar> Philonous, keep_learning: that surprised me, as I found http://hackage.haskell.org/trac/ghc/ticket/5364 which says it's a milestone for 7.6.1, hmm...
06:27:06 <aufwind> I am (still) trying to write my first peace of Haskell code, which would be write a lcm which I call kgm (german abbreviation) function with this signature kgv :: (Int, Int) -> Int. Given the gcd which I call ggt function I tried to take advantage of the fact, that kgv(x,y) = (x*y) div ggt(x,y) and implemented it this way: http://codepad.org/0ZMNHhdx But I can't get it to work… I tried for hours now, but I don't seem to be able how 
06:27:07 <aufwind> get this thing to work. Hints are much appreciated. :-)
06:27:31 <aufwind> I hope my gibberish is understandable. :D
06:28:11 <xraycat> isnt it `div`?
06:28:23 <aufwind> xraycat: You mean I need the ` ?
06:28:55 <mm_freak> Rmx: i actually had type families in an earlier version
06:29:03 <mm_freak> but they made the type signatures awfully long
06:29:06 <aufwind> xraycat: Oh dear, the interpreter stopped complaining and loads the file now. :-)
06:29:08 <keep_learning> rasfar: I think that ticket for accessing all the RTS values that can be passed ( Not only accessing the number of processors )
06:29:11 <rasfar> if you want to use a regular function in infix position, you add the backquotes
06:29:15 <mm_freak> so i replaced them by fundeps to save some line noise
06:29:22 <xraycat> aufwind: :-)
06:29:31 <Rmx> oki! :)
06:29:34 <Itkovian> any idea why cabal-dev thinks it's going to overwrite stuff if I provide it the -s option to install?
06:29:46 <rasfar> ah, i see ... the -N was the running example in that ticket
06:30:02 <aufwind> rasfar: Good to know. The syntax really takes some getting used to. :-)
06:30:42 <xraycat> aufwind: its either div (x * y) z or infix: with `div`
06:31:24 <mm_freak> is it fair to call "Set" a universe?
06:31:34 <hpc> mm_freak: in agda? yes
06:31:47 <mm_freak> and it's of type Set1?
06:32:08 <xraycat> aufwind: why are you using tuples anyway?
06:32:54 <rasfar> xraycat, did you sort out the used datatypes and stuff, with your application?  i'd be interested in seeing how the code turned out if you felt like an hpaste, but not if would inconvenience you.
06:33:29 * rasfar finds it really difficult to type a gramattically correct sentence in irc...
06:33:35 <rasfar> s/tt/t
06:33:37 <mm_freak> aufwind: the evolution of a haskell programmer:  first you fight with the type system, then you satisfy the type system and finally the type system becomes your secret weapon =)
06:33:38 <aufwind> xraycat: Sorry, there was someone on the door. Tuple? Do I use them? I just want to fulfill the signature kgv :: (Int, Int) -> Int
06:33:43 <xraycat> rasfar: I haven't done it yet, but I'll and notify you
06:33:49 <rasfar> coolio
06:34:24 <hpc> mm_freak: you forgot the part where the type system is no longer powerful enough and they move on to agda
06:34:31 <mm_freak> lol
06:34:31 <aufwind> mm_freak: I like the "math,magical" nature of this language, but at the moment I it is  really hard for me to get started. I hope it pays off. :-)
06:34:42 <hpc> mm_freak: (or transform into edwardk)
06:34:51 <mm_freak> aufwind: it does =)
06:35:03 <mm_freak> hpc: i never moved to agda =)
06:35:24 <mm_freak> but yeah, my "Default-extensions" field is often 10-15 lines long =)
06:35:36 <mm_freak> and it virtually always includes RankNTypes and ScopedTypeVariables =)
06:35:44 <Rmx> hey, have agda any ambition except research ?)
06:35:53 <aufwind> xraycat: If I may bother you again, do you think the approach is wrong?
06:35:59 <Rmx> or mm_freak, is it enough to always use those extension?
06:36:29 <Rmx> because I start to get use to those type extension, and I think haskell is closer and closer to Agda
06:36:30 <mm_freak> Rmx: agda is amazing as a language…  it beats haskell in many respects
06:36:37 <mm_freak> but for practical purposes haskell is 'enough'
06:36:46 <Rmx> mm_freak, ok
06:36:48 <xraycat> aufwind: I am not in the position to say anything, but you would probably do something like: http://codepad.org/73zMhuEd
06:37:01 <mm_freak> since GHC 7.4 haskell is very close to dependent types, but hasn't quite reached them
06:37:20 <aufwind> xraycat: Thank you very much, but this seems like an other signature, correct?
06:37:23 <Rmx> is it a long term goal ?
06:37:27 <mm_freak> no
06:37:33 <Rmx> arf!
06:37:36 <Rmx> sad :(
06:37:52 <xraycat> aufwind: your input was a tuple
06:37:55 <mm_freak> it if were a goal, GHC would have added -XDependentTypes a long time ago =)
06:38:27 <mm_freak> after all it would simplify the core language
06:38:43 <aufwind> xraycat: Doesn't the required signature kgv :: (Int, Int) -> Int require a tuple?
06:38:45 <mm_freak> the three levels (values, types, kinds) would collapse into a single level
06:38:53 <rasfar> (oops, -N was not any running example on that ticket; too early in the morning for me it seems)
06:39:09 <mm_freak> i'd love that to happen, but i don't expect it to =)
06:39:39 <quicksilver> mm_freak: I don't think that's really true.
06:39:51 <quicksilver> dependent types wouldn't simplify GHC overall
06:39:57 <xraycat> rasfar: I'm still not sure, how I would define a datatype of some kind for my input, the pattern should be straight forward data Pattern = Box | Star (or something like that), but I would need another type later on, in which I could combine Pattern and String (or am I missing something?)
06:40:01 <quicksilver> you'd need a completely different Core
06:40:11 <quicksilver> and whilst dependent types isn't a direct, stated goal
06:40:20 <mm_freak> quicksilver: imagine adding dependent types to the core language without changing haskell
06:40:28 <mm_freak> the core language would be replaced by a simpler language
06:40:37 <quicksilver> I think taking baby steps towards it with things like datakinds polykinds etc is what they are doing
06:40:39 <mm_freak> it would be different and you would have to reimplement many things
06:40:46 <mm_freak> but the new implementation would be simpler, i'm sure
06:40:57 <xraycat> aufwind: actually, I think you do
06:41:12 <byorgey> mm_freak: that depends whether you still want type inference as good as we currently have.
06:41:18 <xraycat> aufwind: you just want a function which takes 2 arguments, right?
06:41:30 <byorgey> mm_freak: if you are willing to throw type inference out the window, then it would probably all get simpler.  otherwise, I am not so sure.
06:41:31 <mm_freak> byorgey: i think you can't have that in CoC anyway
06:41:31 <aufwind> xraycat: This is the requirement of the homework, yes.
06:42:05 <Ptival> not a complete one
06:42:32 <byorgey> also, "dependent types" is not some single, well-defined thing.
06:43:00 <mm_freak> byorgey: but i'm sure type inference would still be decidable as long as you never used the variable in the dependent function arrow
06:43:44 <byorgey> mm_freak: I'm not.
06:43:47 <xraycat> aufwind: (Int,Int) would be one argument and you would then have to extract the components
06:45:20 <mm_freak> byorgey: how come?
06:46:09 <byorgey> mm_freak: I don't have any particular reasons.  Just lots of experience with the fact that these sorts of things are always at least an order of magnitude more complicated than one would naively expect.
06:46:22 <aufwind> xraycat: How do I do that?
06:46:55 <xraycat> aufwind: if you really want to do that, there is fst and snd
06:47:20 <aufwind> xraycat: Ah I read about them. I will try that thanks
06:49:03 <xraycat> aufwind: actually, your attempt was fine too, using pattern matching, sorry for the confusion, but Int -> Int -> Int would usually be the way to go
06:49:59 <aufwind> xraycat: I understand. But since the specification of the homework is (int, int) -> int I have to figure an alternative. :-(
06:50:01 <aufwind> :-)
06:50:06 <aufwind> Wrong parenthesis
06:50:23 <mm_freak> byorgey: i'm asking because just right now i'm trying to implement a dependently typed core language =)
06:50:53 <byorgey> mm_freak: oh, nice =)
06:50:57 <mm_freak> it's a bit weird that the article i'm reading suggests two separate arrows with exactly the same type
06:51:04 <mm_freak> http://augustss.blogspot.de/2007/10/simpler-easier-in-recent-paper-simply.html
06:51:19 <mm_freak> i fail to see the distinction between Lam and Pi in the last Expr type the article defines
06:51:45 <xraycat> aufwind: well, with `div` fixed it's working, at least there is no complain
06:51:55 <mm_freak>     | Lam Sym Type Expr
06:51:55 <mm_freak>     | Pi  Sym Type Type
06:51:58 <mm_freak> where Type = Expr
06:52:12 <xraycat> aufwind: is this for school?
06:52:48 <rasfar> xraycat: i'm just still stuck on your specification, and interpretation of the examples :(  would you care for a private chat about it? (it might sort of flood the channel if we discuss it here)
06:53:14 <xraycat> rasfar: might be the language barrier :-)
06:53:38 <byorgey> mm_freak: You need both because you need something to classify Lam.  In some corners of the lambda cube you might be able to get away with collapsing them, but if you want to implement the whole lambda cube at one go you need both.
06:54:20 <aufwind> xraycat: Jeah, this is homework. But not for school. The only doubt that that remains, is if this solution is acceptable. Since I am using the ggt which was given. But it fulfills the requirement. So I think it is ok. :-)
06:54:48 <mm_freak> byorgey: why exactly?  can't i classify Lam as Lam?
06:55:26 <byorgey> mm_freak: hmm, actually I forget
06:55:43 <mm_freak> i'll just try with Lam : Lam
06:55:50 <nomeata> Hi. I’m searching for research into alternative evaluation strategies for non-strict languages that, for example, try to minimize the heap consumption, but I’m not really finding anything. Am I not searching good enough or is this something that nobody has worked on yet?
06:55:52 <mm_freak> if it's really impossible i'll probably run into problems =)
06:55:59 <mm_freak> might be an interesting experiment
06:56:38 <byorgey> mm_freak: oh, "To cut down on the code you could actually join the Lam and Pi constructors since they are treated identically in many cases.
06:56:44 <byorgey> so I was wrong
06:58:07 <byorgey> mm_freak: it seems the nf function does treat them differently though I don't quite understand why at the moment
07:00:50 <mm_freak> byorgey: yeah…  i'll just try
07:01:17 <mm_freak> i won't need 'nf' now, because i'm planning to write a compiler instead of an interpreter
07:01:27 <mekeor> mm_freak: just a tiny demand: please design your programming language in such a way that functions (i mean (->)) are implemented in the language itself ;)
07:01:47 <byorgey> mm_freak: oh, because there is no reduction rule for Pi.
07:02:12 <mekeor> … ski once said that this is/can_be done in Charity ( http://pll.cpsc.ucalgary.ca/charity1/www/home.html ).
07:02:20 <byorgey> there is beta-reduction for lambda applied to something, but Pi is not computational, so there is no corresponding beta-rule for Pi
07:03:06 <byorgey> I'm not sure what (or if) goes wrong if you just ignore that and beta-reduce applications of Pi anyway.  I guess applications of Pi would not be well-typed anyway.
07:03:56 <byorgey> oh, wait, maybe that's what goes wrong.... eh, I'm not sure.  Try it and see =)
07:06:23 <mm_freak> mekeor: that's not possible
07:06:30 <mm_freak> at least not in the lambda calculus
07:06:37 <mm_freak> functions are a language feature
07:06:38 <mekeor> mm_freak: in charity it is. idk
07:06:50 <mekeor> mm_freak: why?
07:07:00 <mm_freak> mekeor: because everything builds on functions
07:07:09 <mekeor> that's right.
07:08:53 <mekeor> related question i've always had: a type of a type is a kind. what's the type of a kind?
07:09:16 <mm_freak> mekeor: none in haskell
07:09:31 <mm_freak> you only need types for sufficiently complicated systems of values
07:09:56 <mekeor> i see.
07:09:59 <Rmx> mm_freak, byorgey, mekeor, and everyone else ... come on! I'm spending lot of time learning haskell, and many small stuff around, theory, maths, .. but why can't I catch your level yet!? please, tell me you needed lot of time too... -__-"
07:10:00 <mm_freak> kinds in haskell are not sufficiently complicated
07:10:16 <rasfar> somebody knows Charity here! holy cow!
07:10:16 <mm_freak> Rmx: i needed years
07:10:18 <byorgey> Rmx: yes, I needed a lot of time.
07:10:34 <mm_freak> Rmx: it took me two years to understand "forall" =)
07:10:43 <eacameron> noob question: what is the fat arrow for (=>) ?
07:10:46 <Rmx> thanks!
07:10:48 <byorgey> Rmx: how long have you been learning Haskell?
07:10:58 <Rmx> hm, one year, I would say
07:11:12 <Rmx> in parallel with my studies
07:11:16 <byorgey> mekeor: sometimes you hear the word "sort" used for the type of a kind.
07:11:27 <mm_freak> eacameron: it gives a context…  basically it requires type variables to fulfill a certain requirement (like being an instance of a type class)
07:11:36 <byorgey> mekeor: but if you go beyond that you just start saying things like Type 1, Type 2, Type 3, ...
07:11:45 <mm_freak> eacameron: (Num a) => a -> a means that 'a' must be an instance of the Num class
07:12:04 <mekeor> byorgey: cool!
07:12:05 <eacameron> mm_freak: ahh I've seen that before. that makes sense
07:12:41 <EvanR> you dont need parens
07:12:51 <byorgey> Rmx: ok, then don't be discouraged.  I have been at this for five years, I am paid to study it, and I still learn new things =)
07:12:52 <mm_freak> EvanR: i know, i use them anyway =)
07:12:56 <mekeor> Rmx: i'm a noob. i started haskell one year ago =)
07:13:00 <mm_freak> i also always write deriving (Eq)
07:13:02 <eirqui> i have a list of indices. i want to filter another list and to remain only those elements which are at the indices of the other list. is there an elegant way to do this? i have problems trying to realise this with the filter function
07:13:19 * mekeor HATES manually deriving Read!!!
07:13:26 <eacameron> Rmx: I started looking into it a year and a half ago...I am still a noob too...
07:13:28 <EvanR> mm_freak: oh, i always do that cuz i didnt know you didnt need parens xD
07:13:28 <mm_freak> "manually deriving"?
07:13:36 <mekeor> instanciating
07:13:43 <EvanR> instancimitating
07:13:51 <HugoDaniel> mekeor: its not that bad
07:13:54 <byorgey> eirqui: you could do it with filter if you first use  zip [0..]  to pair up the elements of the list with their indices
07:13:55 <mm_freak> EvanR: i find that the parens make the code more readable there
07:14:07 <Rmx> thanks all!
07:15:05 <byorgey> > let selectIndices ixs = map snd . filter ((`elem` ixs) . fst) . zip [0..]  in  selectIndices [1,5,2]  "ABCDEFGHIJKLMNOP"
07:15:06 <lambdabot>   "BCF"
07:15:48 <byorgey> eirqui: however, if you happen to know that the list of indices is sorted you could do it more efficiently by walking through both lists at the same time, but I can't think of a nice way to do that besides just writing an explicit recursive function
07:16:07 <mm_freak> byorgey: use drop
07:16:13 <hpaste_> killy9999 pasted “What does this mean?” at http://hpaste.org/67272
07:16:28 <killy9999> what does "(JSON a) =>" mean?
07:16:41 <ment> @hoogle Int -> Char
07:16:41 <lambdabot> Data.Char chr :: Int -> Char
07:16:41 <lambdabot> Data.Char intToDigit :: Int -> Char
07:16:41 <lambdabot> Data.Text index :: Text -> Int -> Char
07:16:44 <bitonic> killy9999: that's a type class constraint
07:16:45 <byorgey> mm_freak: ah, hmm, some sort of fold with drop, after taking successive differences of the index list?  that could work.
07:16:52 <mm_freak> yeah
07:17:01 <killy9999> bitonic: yes, but what am I constraining in this case?
07:17:12 <killy9999> or perhaps what kind of instance am I making?
07:17:29 <mekeor> killy9999: it means that 'a' is an instance of 'JSON'.
07:17:37 <bitonic> killy9999: you're saying that 'a' is an instance of JSON
07:17:41 <eirqui> byorgey: since efficiency is important, i will do this thanks. however, I'd like to see a one-line version, filter ((fst x) `elem` [1,3])  $ zip [0..] [1,2,3,4] does not work
07:18:05 <rwbarton> what's x
07:18:12 <killy9999> OK, then I don't understand "JSON (JObj a)"...
07:18:38 <bitonic> killy9999: you're defining an instance of JSON for all 'JObj a' where 'a' is an instance of JSON
07:18:42 <killy9999> I'm makind JObj contain a's that are instance of JSON and at the same time JObj becomes an instance of JSON?
07:18:47 <killy9999> aha, ok
07:18:56 <killy9999> That was tricky
07:19:18 <eirqui> rwbarton: ups, i had the weird thoughts that this would be the element to which the function is applied ... do I have to use the pointfree style?
07:20:01 <CQ> how hard is it to write haskell routines that get used from a C program?
07:20:37 <rwbarton> eirqui: no you can just write a function
07:20:46 <rwbarton> \x -> (fst x) `elem` [1,3]
07:20:53 <rwbarton> those parentheses are unnecessary btw
07:21:17 <eirqui> thanks!
07:22:44 <sipa> CQ: you'll have to use the FFI but it's certainly possible
07:22:58 <sipa> I've only done the opposite myself.
07:24:18 <bitonic> CQ: it's not that hard
07:24:24 <bitonic> CQ: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:25:22 <mekeor> wow. it's even very *easy*! cool.
07:27:02 <t7> id (id id) type checks OK but (id id) id doesnt type properly in my thing :( fuck this gay earth
07:27:37 <bitonic> t7: lol you're doing much more testing I ever did, good job
07:27:47 <t7> yours works ok
07:27:52 <bitonic> ah!
07:28:07 <t7> mine doesnt have schemes
07:28:12 <mm_freak> calling haskell from C is easy, but the question is whether you really want to do that
07:28:20 <mm_freak> your C program will depend on the entire haskell ecosystem
07:28:27 <t7> i think thats an issue...
07:28:47 <RenJuan> don't hold up the C
07:28:56 <t7> i wonder if SPJ does private tuition
07:29:00 <t7> or simon marlow
07:29:25 <RenJuan> prolly for enough money
07:29:37 <RenJuan> or what have you
07:32:01 <yitz> @type (id id) id
07:32:02 <lambdabot> forall a. a -> a
07:32:05 <yitz> @check \x -> (id id) id x == x
07:32:06 <lambdabot>   "OK, passed 500 tests."
07:33:32 * hackagebot monadcryptorandom 0.4.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.4.1 (ThomasDuBuisson)
07:35:38 * RenJuan just noticed that Miro Lipovaca assumes at the start of LYAH that the reader is male.
07:37:41 <bitonic> oh this sexism in CS!
07:38:01 <gdeest> @pl \x -> (x > 10) || (x <= 5)
07:38:01 <lambdabot> liftM2 (||) (> 10) (<= 5)
07:38:31 <yitz> RenJuan: where?
07:38:32 <typoclass> RenJuan: where exactly? i can't find it
07:38:55 <yitz> oh, "chap"?
07:39:19 <yitz> not sure that really limits it to males.
07:39:36 <bitonic> yitz: yes
07:39:39 <bitonic> but honestly
07:39:43 <bitonic> complaining about that is going too far
07:39:50 <nomeata> bitonic: it is everywhere. The book I am reading right now write: “Accordingly, computer scientists commonly choose models which have bottoms, but prefer them topless.”
07:39:55 <RenJuan> I'm noticing not complaining.
07:39:55 <bitonic> I mean WHO CARES
07:40:47 <RenJuan> and chap is limited males and really butch females
07:42:00 <yitz> RenJuan: maybe, but it's pretty clear that "a smart chap like you" isn't addressing just males.
07:42:37 <Ptival> LYAH has a lot of small jokes
07:43:13 <yitz> nomeata: that's the kind of thing that got @vixen axed
07:43:19 <RenJuan> i wonder why the wikipedia article lists Linspire as an application of haskell?
07:43:51 <bitonic> RenJuan: they used Haskell?
07:44:11 <rwbarton> i would guess that if you click on "Linspire" you will get your answer
07:44:35 <RenJuan> if I had I wouldn't have asked
07:45:26 <bitonic> RenJuan: there's even a citation, http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html
07:45:37 <typoclass> i think he could avoided "chap" to be really politically correct, but i don't feel it's a particularly bad example of excluding females. if i read a story where the protagonist is called "john", i don't feel excluded because my name is jeff. i think people can easily make that abstraction
07:46:11 <RenJuan> since the linspire article indicates it was discontinued 4 years ago
07:46:52 <bitonic> RenJuan: they still used Haskell
07:46:54 <RenJuan> so guess it was an intent that got axed
07:49:44 <RenJuan> typoclass, agreed, to insist on correctness would be small minded
07:53:59 <Chaze> can someone tell me what wizardry this is:
07:54:05 <Chaze> trace f input = let (output, feedback) = f (input, feedback) in output
07:54:29 <Chaze> trace is used do define the loop function of the ArrowLoop (->) instance
07:54:37 <Chaze> but i don't get it
07:55:21 <efie> when I have something like or [bool1,bool2,...] whereas bool1, bool2 ... have to be calculated (in a vast amount of time) can I assume that due to lazy evaluation bool 2 only is calculated if bool1 is False?
07:55:32 * RenJuan (although a brief look at current stats indicates around 100 of those in this channel should be female)
07:55:42 <quicksilver> efie: yes indeed
07:56:00 <efie> quicksilver: thanks, that's great
07:56:29 <luana> ciao
07:56:49 <cdh473> In Haskell, if I do `[1..1000000000] !! 100000`, is it calculating every number up to the 100001st?
07:57:30 <fmap> > [1,undefined,2] !! 2
07:57:31 <lambdabot>   2
07:57:44 <nomeata> cdh473: yes, but only to see if it has reached 100000
07:57:48 <cdh473> ok
07:58:03 <nomeata> cdh473: but they are not put in the list, though, as you can see in fmap's example
07:58:10 <cdh473> i was just making sure i understood the whole laziness thing
07:58:50 <cdh473> thanks guys
08:01:03 <quicksilver> cdh473: well the answer to your question is something subtle about how .. works
08:01:24 <Tinned_Tuna> fmap: ???
08:01:31 <Tinned_Tuna> @src (!!)
08:01:31 <lambdabot> xs     !! n | n < 0 = undefined
08:01:32 <lambdabot> []     !! _         = undefined
08:01:32 <lambdabot> (x:_)  !! 0         = x
08:01:32 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:01:32 <t7> anyone in here know f# ?
08:01:40 <frontendloader> more or less the same as a generator in python right qs?
08:01:42 <rasfar> efie, not to contradict quicksilver, but it can depend on what you do with that list; if it's something like "and lst" you'd be fine.
08:02:12 <Tinned_Tuna> Ahh, it doesn't look at (and hence, doesn't evaluate) the undefined in that list.
08:02:57 <efie> rasfar: "and lst"?
08:03:31 <rasfar> that's logical and over a [Bool]
08:03:55 <quicksilver> rasfar: he specifically said "or"
08:03:59 <rasfar> @src and
08:03:59 <lambdabot> and   =  foldr (&&) True
08:04:17 <typoclass> > and [True, True, False, True]
08:04:18 <lambdabot>   False
08:04:20 <quicksilver> rasfar: and "or" shortcircuits on the first True, which is what he asked.
08:04:22 <rasfar> oh, sorry; i just returned, didn't scroll up enough perhaps (or read carefully)
08:04:29 <efie> ok :)
08:12:45 <t7> fromMaybe is my favourite function
08:15:52 <adnauseam> are there other bots out there who are like lambdabot ?
08:16:04 <adnauseam> and offer a shared ghci-like interface to be used with others ?
08:17:13 <aristid> adnauseam: yes.
08:17:46 <aristid> adnauseam: for which language? if haskell, lambdabot is open source. you can run your own (it might not be easy to set up though)
08:18:54 <sclv> adnauseam: http://weegen.home.xs4all.nl/eelis/geordi/
08:19:12 <sclv> I think lots of language channels have similar things these days.
08:19:17 <adnauseam> aristid; one for haskell-group learning
08:19:40 <yitz> @where tryhaskell
08:19:40 <lambdabot> http://tryhaskell.org/
08:19:48 <yitz> adnauseam: ^^
08:20:20 <frontendloader> how does it deal with things like
08:20:22 <adnauseam> thanks yitz - my friends aren't here next to me though
08:20:27 <frontendloader> >reverse [1..]
08:20:43 <adnauseam> > reverse . take 5 [1..]
08:20:44 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
08:20:44 <lambdabot>    arising from a use...
08:21:52 <frontendloader> > reverse [1..]
08:21:58 <frontendloader> needs a space I guess?
08:22:00 <lambdabot>   mueval-core: Time limit exceeded
08:22:00 <lambdabot>  mueval: ExitFailure 1
08:22:00 <lambdabot>  mueval: Prelude.un...
08:22:00 <adnauseam> > reverse $ take 5 [1..]
08:22:05 <frontendloader> oh there it goes
08:22:05 <lambdabot>   mueval-core: Time limit exceeded
08:22:39 <adnauseam> reverse $ take 5 [1..] worked in ghci
08:22:45 <hpc> > "lambdabot must be slow"
08:22:48 <lambdabot>   "lambdabot must be slow"
08:22:52 <yitz> > reverse $ take 5 [1..]
08:22:54 <hpc> or something
08:22:54 <lambdabot>   [5,4,3,2,1]
08:22:59 <efie> Imagine you have a matrix with 2 columns and 2 rows and the numbers 1,2,3,4 have to be entered there. I have to check if the entering was valid, which means that neighboring numbers (in refrence to their value) have to be side by side physically in the matrix. So my question: I have a function isNeighbor f1, f2, how can I generate a DNF whereas the conjunction are the ways through the matrix? Like or [ and [isNeighbor p1,p2, is Neighb
08:22:59 <efie> whereas p1,p2 are the field in the matrix. in imerpative languages I would solve this by using while statimes and so on, but I dont know how to do this here using maps and so on
08:23:42 <hpaste_> scooty-puff pasted “Does this already exist somewhere?” at http://hpaste.org/67277
08:23:52 <efie> maybe anyone can give me a hint, sorry if the question is too long and does not really fit here
08:23:55 <scooty-puff> title lists the question
08:24:25 <scooty-puff> are there better naming conventions to use than what i did in the post?
08:25:42 <typoclass> scooty-puff: isJust?
08:25:48 <hpc> scooty-puff: are those DataKind bools or "data True; data False" bools?
08:25:56 <scooty-puff> datakind bools
08:26:06 <scooty-puff> its like whats in hoopl, except datakinds, for th most part
08:26:44 <hpc> yeah, i have no idea what GHC's support for this would be, but in agda you would define just MaybeT, and then not the type param to get MaybeF
08:27:07 <fmap> efie: perhaps you should try stackoverflow.com
08:27:16 <scooty-puff> hpc, k
08:27:44 <yitz> efie: why not just define a function which, given a number, returns the coordinates of where it was placed in the matrix? then it would be easy to check if two numbers are physically adjacent.
08:32:34 <efie> yitz: I have to do it using propositional logic and one big DNF
08:33:50 <scooty-puff> hpc, simplified it to just a Maybe' having Nothing' and Just', and defined a type family Not
08:35:53 <yitz> efie: oh ok
08:37:12 <t7> @pl foldl Set.union Set.empty $ map getTVarsOfType args
08:37:12 <lambdabot> foldl Set.union Set.empty (map getTVarsOfType args)
08:37:27 <yitz> efie: in haskell, you would probably use something like "map f [1..n]" instead of the while loops you are thinking of.
08:37:29 <t7> is that retarded code?
08:38:17 <quicksilver> t7: well you can use Set.unions
08:38:38 <yitz> efie: or you can just write out some recursive function explicitly, with a parameter that starts at 1 and increments on each recursive call.
08:38:38 <quicksilver> which is very much like foldl union empty, but takes some effor to be strict enough
08:38:49 <t7> ah cool
08:38:51 <t7> thanks
08:39:41 <yitz> efie: try starting out with one of the approaches, write some code based on whatever you know. then if you get stuck post what you've got so far on hpaste and get back to us here in the channel.
08:39:45 <yitz> @hpaste
08:39:45 <lambdabot> Haskell pastebin: http://hpaste.org/
08:40:07 <efie> yitz: yes, thanks :)
08:40:39 <luite> in the latest cabal-install, how do you disable the new solver?
08:41:11 <t7> quicksilver: what is a - b in the context of sets ?
08:41:18 <t7> intersection ?
08:41:33 <bitonic> t7: ...difference?
08:41:54 <yitz> t7: the elements of a that are not in b
08:42:21 <mm_freak> regarding a dependently typed language for practical programming (as opposed to proofs), is not having universe polymorphism a problem?
08:42:45 <yitz> t7: it's called \\ in haskell
08:42:46 <yitz> > [1..10] \\ [3..6]
08:42:47 <lambdabot>   [1,2,7,8,9,10]
08:43:10 <t7> ah cool
08:43:16 <parcs`> luite: solver=topdown
08:43:27 <yitz> > [1..10] \\ [3..16]
08:43:28 <lambdabot>   [1,2]
08:43:41 <bitonic> t7: if you're using Set already, it's 'difference'
08:44:03 <luite> parcs`: ugh that also fails, but with a different problem
08:44:39 <parcs`> the modular solver seems to be strictly better than the old solver, so i'm not surprised
08:44:54 <yitz> > S.fromList [1..10] S.\\ S.fromList [3..16] -- bitonic
08:44:56 <lambdabot>   fromList [1,2]
08:45:10 <bitonic> yitz: oh, I didn't know there was an operator for Set as well.
08:45:55 <bitonic> t7: note that [] \\ and Set \\ do different things (and well [] and Set are different structures :P)
08:46:26 <t7> whats the difference?
08:46:37 <bitonic> @check \x y -> (S.fromList (x :: [Int]) S.\\ S.fromList y) == (x \\ y)
08:46:38 <lambdabot>   Couldn't match expected type `Data.Set.Set GHC.Types.Int'
08:46:42 <t7> in a nutshell
08:46:49 <quicksilver> the \\ in [] respects multiple occurrences
08:46:51 <bitonic> t7: well lists may contain duplicate elements
08:46:56 <quicksilver> it's a kind of multi-set \\
08:46:57 <bitonic> and \\ removes the first occurence only
08:47:04 <t7> ah ok
08:47:10 <quicksilver> > [1,2,1,3,1] \\ [1.1]
08:47:11 <lambdabot>   [1.0,2.0,1.0,3.0,1.0]
08:47:13 <quicksilver> > [1,2,1,3,1] \\ [1,1]
08:47:14 <lambdabot>   [2,3,1]
08:47:23 <quicksilver> bitonic: well, each copy removes one occurrence
08:47:36 <bitonic> quicksilver: yes
08:48:00 <bitonic> t7: and of course, [] \\ is *much* more inefficient :)
08:49:31 <yitz> @check \x y -> (S.fromList (x :: [Int]) S.\\ S.fromList y) == S.fromList (x \\ y)
08:49:34 <lambdabot>   "Falsifiable, after 22 tests:\n[-3,1,1,13,-7]\n[-7,-8,4,7,-6,-12,-3,1,0]\n"
09:01:51 <scooty-puff> is there a better way to handle phantom types i don't care about other than with existential quantification?
09:01:59 <adnauseam> > let a =2
09:02:00 <lambdabot>   not an expression: `let a =2'
09:02:03 <adnauseam> > let a = 2 in 2
09:02:04 <lambdabot>   2
09:02:06 <scooty-puff> just don't like the data part of it  - vs. newtype
09:02:08 <adnauseam> > a
09:02:09 <lambdabot>   a
09:02:13 <adnauseam> > a +a
09:02:14 <lambdabot>   a + a
09:02:33 <bitonic> scooty-puff: phantom types don't have much to do with existential quantification
09:02:46 <bitonic> so I'm not sure what you're asking here
09:02:49 <parcs`> > let 2 = a in 2
09:02:50 <lambdabot>   2
09:02:56 <parcs`> hey!
09:03:01 <hpc> newtype TaggedThing a b = Thing b
09:03:23 <hpc> addTaggedThings :: Num c => TaggedThing a c -> TaggedThing b c -> TaggedThing d c
09:04:28 <osfameron> oh, is there a #pandoc somewhere?
09:05:25 <byorgey> > let 2 = 3 in 2
09:05:26 <lambdabot>   2
09:06:10 <byorgey> scooty-puff: can you be a bit more specific? what are you trying to do?
09:07:20 <killy9999> Guys, I have a few simple questions
09:07:44 <killy9999> when I have "case something of ...." what is "something" called? A condition?
09:08:00 <hayashi> > let a = a in a
09:08:01 <byorgey> killy9999: the "scrutinee", perhaps
09:08:04 <lambdabot>   mueval-core: Time limit exceeded
09:08:21 <parcs`> > let 2 = 2 in 2
09:08:22 <lambdabot>   2
09:08:34 <rwbarton> > let !2 = 3 in 2
09:08:34 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
09:08:35 <hayashi> > let (2+2) = 5 in 1984
09:08:36 <lambdabot>   <no location info>: Parse error in pattern
09:08:50 <rwbarton> > let !2 = 2 in 2
09:08:51 <lambdabot>   2
09:09:04 <killy9999> byorgey: perhaps? I though this would hav a name :)
09:09:20 <byorgey> killy9999: I'm pretty sure the Haskell Report does not actually specify a name for the expression being matched in a case
09:09:30 <killy9999> OK
09:09:37 <byorgey> killy9999: but "scrutinee" is one name that you sometimes hear for that sort of thing
09:09:39 <killy9999> so it's simply an expression?
09:09:53 <byorgey> whatever else it may be called, it is certainly an expression
09:09:55 <killy9999> It's just that I have a problem when writing a sentence like:
09:10:04 <hayashi> lambdabot doesn't love the Party enough
09:10:15 <killy9999> The expression in the case-of expression... - this sounds bad
09:10:15 <hayashi> this is clearly a bug
09:10:57 <byorgey> killy9999: how about "The expression being analyzed/matched by the case..."
09:11:12 <killy9999> Well, this sounds better
09:11:13 <quicksilver> the "subject" of the case is one expression
09:11:22 <quicksilver> if you think "Scrutinee" is a little jargonish.
09:12:05 <killy9999> quicksilver: is "subject" a recognized term for that?
09:13:03 <pmade> Trying to `cabal install xmobar` and getting "duplicate instance declarations" with transformers 0.2.  I updated transformers to 0.3 but the xmobar build is still complaining about 0.2.  Any suggestions?
09:13:19 <typoclass> killy9999: "the expression between 'case' and 'of'"?
09:14:03 <killy9999> typoclass: I'm affraid that's a bit to long and doesn't look well in a sentence
09:14:04 <hpc> pmade: xmobar indirectly depends on transformers - flip some verbose switches perhaps and see what's making it want 0.2
09:14:05 <typoclass> pmade: http://hackage.haskell.org/package/xmobar/ seems to suggest that xmobar uses mtl, not the rival transformers
09:14:20 <hpc> possibly
09:15:09 <bitonic> typoclass: mtl and transformers are not rival
09:15:12 <bitonic> s
09:15:14 <bitonic> in fact, mtl depends on transformers
09:15:26 <typoclass> killy9999: i meant to suggest "the expression between 'case' and 'of'" as a replacement for your sentence "The expression in the case-of expression..."
09:15:35 <bitonic> mtl is just typeclass abstractions based on transformers
09:16:14 <quicksilver> killy9999: it's a reasonable term and couldn't really refer to anything else
09:17:02 <EvanR> there could be many independent expressions in a case expression
09:17:17 <pmade> hpc: I don't see it in the dependency list, but in the hsc2hs line I see: --lflag=-L/home/pjones/.cabal/lib/transformers-0.2.2.0
09:17:18 <quicksilver> EvanR: yes but only one would reasonable be termed the "subject"
09:17:23 <quicksilver> EvanR: in my opinion.
09:17:26 <EvanR> yeah
09:17:29 <typoclass> bitonic: istr that for quite a while they caused "duplicate instance" errors
09:17:33 <EvanR> i didnt read that far back
09:17:45 <tomboy64> is there a major software written in haskell?
09:17:56 <EvanR> the c++ bot
09:18:09 <killy9999> tomboy64: GHC
09:18:09 <tomboy64> eh?
09:18:15 <killy9999> Yesod
09:18:25 <tomboy64> EvanR: the c++ bot?
09:18:41 <EvanR> in ##c++
09:18:45 <hpc> tomboy64: it's an IRC bot that executes a safe subset of C++
09:18:53 <quicksilver> geordi, it's called
09:18:56 <tomboy64> killy9999: sweet. i thought it might have been c
09:19:01 <hpc> facebook uses haskell to refactor their horrid PHP code
09:19:03 <tomboy64> cool :-]
09:19:09 * tomboy64 laffs
09:19:28 <hpc> xmonad is written in haskell
09:19:28 <tomboy64> the should refactor their laughable smartphone apps
09:19:29 <rasfar> efie: i think i have something, in case you are still available
09:19:31 <tomboy64> *they
09:19:37 <hpc> (and configured in haskell)
09:19:41 <efie> rasfar: I am!
09:19:41 <tomboy64> yup, xmonad i'm "using"
09:19:44 <EvanR> im surprised people use xmonad who have no interest in haskell
09:20:08 <rasfar> are your matrices [[Int]] ?
09:20:09 <killy9999> tomboy64: no C, GHC uses bootstraping, i.e. to compile a haskell compiler you need a haskell compiler
09:20:11 <efie> (still thinking about, I have nothing new yet)
09:20:37 <quicksilver> other apps written in haskell : darcs, pandoc, gitit
09:20:38 <rasfar> and ... this is homework, right?
09:21:02 <rasfar> (otherwise i'd just hpaste for you, but maybe that would be going too far)
09:21:26 <hpc> how does GHC bootstrap itself?
09:21:32 <thoughtpolice> pandoc is pretty much amazing as far as markup goes
09:21:48 <thoughtpolice> hpc: you can still use the C backend in an unregisterized build, mostly for porting
09:22:07 <pmade> This is the error I'm seeing, this paste is all over google so I'm reusing it: http://hpaste.org/56031
09:22:10 <hpc> thoughtpolice: ?
09:22:22 <efie> rasfar: well a friend of mine wants/has to do this in c++ for a course at university which he visits, I wanted to see if  I could make a haskell version, so not really :)
09:23:10 <rasfar> oh.  well, my code is not that concise, but it seems to work.  i'm just not sure if its logic-oriented enough to satisfy the requirements.  i'll paste it...
09:23:15 <thoughtpolice> hpc: i mean, generally any platform you're going to build GHC on already has GHC. when you need to 'bootstrap' it, generally on a new platform, you have to go the porting route, which is what i was getting at
09:23:45 <typoclass> pmade: did you re-run cabal configure after you installed the new transformers-0.3? if that doesn't help, give the verbose flag to cabal. it will tell you why it is ignoring transformers-0.3
09:23:49 <thoughtpolice> that is, the unregisterized C backend is the way to 'bootstrap' GHC on a new machine where it didn't exist previously. beyond that you just use GHC to compile itself
09:23:56 <scooty-puff> bitonic, i have a data type data Insn a e x, where e and x are O(pen) or C(losed), when folding over all the instructions, i don't care if it is open or closed
09:24:01 <scooty-puff> the Insn's
09:24:10 <pmade> typoclass: I'll try that.  Thanks.
09:24:18 <hpc> thoughtpolice: ah
09:24:23 <scooty-puff> however, it is convenient to use a list of Insn a e x
09:24:34 <scooty-puff> forall e x . SomeInsn (Insn a e x)
09:24:42 <hpc> i half-expected there to be a C "ghc compiler" that worked on a subset of haskell
09:25:07 <thoughtpolice> no, although that's the way ocaml is bootstrapped i believe
09:25:07 <killy9999> There's on ething I still don't get about bootstraping
09:25:23 <killy9999> there are two stages of the build
09:25:37 <hpaste_> asfar pasted “matrix of neighbouring numbersr” at http://hpaste.org/67279
09:25:39 <killy9999> stage 0 is the compiler present in the system
09:25:40 <scooty-puff> bitonic, basically, i didn't want to use rank-n types to represent the function that is used in the fold
09:25:59 <killy9999> stage 1 is a new version of the compiler that has some limited capabilities (and I don''t understand why)
09:26:01 <rasfar> oops, i misspelled my nick
09:26:05 <efie> rasfar: thanks, ill look at it
09:26:13 <killy9999> and stage 2 of the build is the final version of the compiled ghc
09:28:28 <bitonic> scooty-puff: ok, where does existential quantification come into play?
09:29:04 <quicksilver> killy9999: the stage 1 compiler is fully capable, but was compiled against old libraries
09:29:20 <thoughtpolice> killy9999: when running bytecode (ghci/template haskell) ghc must dynamically link packages but the only way to guarantee they are compatible is to use the same version of GHC to build them
09:29:30 <bitonic> scooty-puff: ok I see, you want to have an mixed list
09:29:32 <quicksilver> killy9999: the stage 2 compiler is compiled with the stage 1 libs - i.e. the new versions.
09:29:42 <quicksilver> killy9999: the stage 2 compiler is also compiled with optimisation.
09:29:54 <bitonic> scooty-puff: I'd go for higher ranked types rather than with existential quantification
09:29:54 <scooty-puff> and i don't care about the e or x types at all - no constraints on them, etc.
09:29:57 <bitonic> without a doubt
09:29:58 <scooty-puff> k
09:30:36 <hpaste_> “Peter Jones” pasted “xmobar and transfomers” at http://hpaste.org/67280
09:30:36 <bitonic> I'm not sure how you'd use them here
09:30:39 <thoughtpolice> there's also a stage3 build but that's really only used for sanity to ensure the build process has reached a fixed point, i believe
09:31:11 <pmade> typoclass: it doesn't make sense to me why transformers is being selected.
09:31:13 <killy9999> quicksilver, thoughtpolice: thanks, I start to understand what's going on in stage 1 and stage 2
09:31:26 <bitonic> scooty-puff: I mean RankNTypes won't help you in having an [exists e x. Insn a e x]
09:31:32 <bitonic> which is what you want
09:31:54 <quicksilver> killy9999: there may be transitional cases where #ifdefs mean that the stage 1 compiler actually uses different code
09:32:17 <quicksilver> killy9999: in particular if GHC wanted to take advantage of a specific new feature in the libraries, which don't exist in bootstrapping versions
09:32:25 <quicksilver> to be honest I don't know if that ever happens.
09:32:35 <quicksilver> they tend to limit external deps (and bundle libraries they care about)
09:32:49 <thoughtpolice> several of those repositories are 'lagging' as well behind the official repos
09:32:51 <typoclass> pmade, cabal selects mtl-2.0.1.0, which according to http://hackage.haskell.org/package/mtl-2.0.1.0 depends on transformers 0.2.* (i.e. transformers-0.3 is not possible)
09:33:02 <pmade> Ah.
09:33:14 <pmade> typoclass: so If I update mtl would that resolve this?
09:33:43 <killy9999> quicksilver: mhm, I see
09:33:51 <killy9999> I recently build GHC just for fun
09:34:16 <killy9999> it was a full build and I was a bit affrad that it will take Very Long Time
09:34:43 <pmade> typoclass: nope, updating mtl didn't fix my issue.
09:34:44 <quicksilver> it used to take 8 hours on my iBook
09:34:49 <typoclass> pmade: i think so. xmobar says it can work with any version of mtl, so mtl-2.1 (which works with transformers 0.3) should be ok. and btw sorry for the mess, haskell is a little too much prone to dependency hell
09:34:57 <quicksilver> on a modern machine I think you can do 35 mins or so
09:35:04 <typoclass> pmade, does verbose tell you why it ignores mtl 2.1?
09:35:23 <pmade> It's using transformers 0.3 now, but it has the same issue.
09:36:32 <killy9999> it took 1,5h on my laptop
09:37:51 <pmade> typoclass: verbose shows that it is indeed using mtl 2.1 and transformers 0.3, but I'm still getting the same error (but now with newer versions).
09:38:41 <efie> rasfar: my bad, i should have explained better, two numbers are also side by side physically if they are "diagonal" side by side - http://www.janko.at/Raetsel/Hidoku/ here is a diagram at the right side which shows it well. you have a different approch as I had: http://hpaste.org/67281 this was my first one (in case you are interested) but this only checks if for each number there is adjazent one and not if there is a whole way thourg
09:38:41 <efie> I will look deeper into your code now, I think it will help me, thanks..
09:39:36 <scooty-puff> i am having trouble with a space leak
09:39:56 <scooty-puff> a thunk in the module that defines the main monad is consuming most of the space
09:40:03 <scooty-puff> or rather base monad
09:40:16 <scooty-puff> this base monad is the bottom of the stack for all operations
09:40:28 <qnikst> hello, is it possible to generate 1 instace of structure of specified size using quickcheck?
09:40:28 <scooty-puff> though all other modules do not refer to it directly (instead through type classes)
09:40:51 <scooty-puff> probably not enough informationyet, but anyone else run in to something this sounds like?
09:41:17 <bitonic> qnikst: what's "size"?
09:41:41 <scooty-puff> this thunk consumes the space (+RTS -hd), though many functions cause it (+RTS -hc)
09:41:59 <qnikst> I've got structure created with sized combinator
09:42:26 <qnikst> I've tested it, and now I want to bench data using concrete size
09:42:31 <scooty-puff> i was considering breaking the monad laws and just make the base monad strict
09:42:35 <scooty-puff> just to see if it fixed it
09:43:14 <hpaste_> killy9999 pasted “What is "rigid type value"” at http://hpaste.org/67282
09:43:26 <killy9999> U inderstand why this code is wrong
09:43:35 <killy9999> But I want to understand the error message
09:43:44 <killy9999> what is a "rigid type value"?
09:43:44 <rwbarton> it says "rigid type variable"
09:43:59 <killy9999> right, variable
09:44:08 <rwbarton> rigid basically means it is chosen by the caller, so when typechecking testEq the compiler is not free to unify it with other stuff
09:44:18 <killy9999> and what does (b ~ a) mean?
09:44:34 <rwbarton> "b and a are the same type"
09:45:06 <typoclass> killy9999: what rwbarton said. it's described in the ghc handbook in the chapter "type families"
09:45:41 <rasfar> efie: ah, i see. well, hopefully the code i pasted helps more than it hurts :p  the whole-way tour is quite another matter, indeed
09:45:47 <killy9999> GHC Handbook?
09:46:27 <rwbarton> in older ghc you would get an arguably more helpful error message: "Couldn't match expected type `a' against inferred type `b'" (lines 12-21 the same)
09:46:39 <rwbarton> at least it's more helpful if you don't know what ~ means :)
09:46:47 <killy9999> rwbarton: yes, that would be more comprehensible...
09:47:26 <killy9999> typoclass: where can I find that GHC Handbook?
09:47:54 <typoclass> killy9999: here http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-families.html section 7.7.2.3
09:49:32 <rwbarton> to contrast if you had left out the (erroneous) type signature, ghc would still have assigned type variables a and b to the types of c and d, but because there is no type signature declaring that testEq must be fully polymorphic in both variables, a and b would not be rigid
09:49:57 <killy9999> thanks
09:49:58 <rwbarton> then they would be unified because of the type of (==), with the Eq a constraint produced, resulting in the expected type Eq a => a -> a -> Bool
09:50:58 <killy9999> rwbarton: is there some sort of gentle introductory tutorial on that topic?
09:51:06 <rwbarton> i don't know
09:53:06 <rwbarton> i just figure out what ghc error messages mean from having seen many examples before :)
09:53:54 <hpaste_> killy9999 annotated “What is "rigid type value"” with “What is "rigid type value" (annotation)” at http://hpaste.org/67282#a67283
09:54:02 <killy9999> rwbarton: but you didn;t deduce polymorphism from error messages? :)
09:54:16 <qnikst> that's I've found a solution
09:54:17 <killy9999> the annotated code works
09:55:07 <rwbarton> killy9999, yes and if you now ask ghci for the type of testEq, it simplifies it to the usual one
09:55:28 <killy9999> testEq :: Eq b => b -> b -> Bool
09:55:31 <killy9999> your right
09:55:36 <typoclass> killy9999: note that your "(Eq a, Eq b, a ~ b) => a -> b -> Bool" can be simplified to "(Eq a) => a -> a -> Bool"
09:55:42 <killy9999> yes, I know
09:56:07 <killy9999> I don't know what's the practical use for what I did but it was fun to make this type annotation compile :)
09:57:28 <typoclass> the problem becomes clearer if you look at the (==) function in the Eq class. it's defined as "a -> a -> Bool", that is, it compares 2 values of the same type (String and String or whatever) http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq
09:58:14 <killy9999> typoclass: yes, I was aware of that
09:58:27 <killy9999> in fact I wanted to understand what this error message tells me
09:59:26 <typoclass> your function (Eq a, Eq b) => a -> b -> Bool requested two arguments of *different* types, so it would have been fine to have a=String (because there's an Eq String instance available) and b=Int (because there's an Eq Int instance). then you are using the function (==) on a String and an Int, which isn't possible and isn't defined
10:00:18 <killy9999> OK, another question: what does ShowS function do?
10:00:53 <dmwit> It puts its String argument at the end of the String it produces.
10:00:53 <lambdabot> dmwit: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:00:58 <dmwit> > shows 3 "oeunthoeunthoeunth"
10:00:59 <lambdabot>   "3oeunthoeunthoeunth"
10:01:00 <killy9999> I don;t understand the type signature in the Show typeclass: "showList :: [a] -> ShowS", where "type ShowS = String -> String"
10:01:09 <dmwit> It's a performance hack.
10:01:37 <killy9999> ?
10:01:39 <rasfar> hi dmwit; i'm responsible for one of your new messages :)
10:01:42 <rwbarton> you mean a performance technique!
10:01:53 <rwbarton> a technique is a hack that works more than once
10:01:57 <dmwit> rasfar: thanks
10:01:59 <rasfar> i sent email to the author of explore-hackage but no word yet
10:02:01 <killy9999> dmwit: but shows takes only one string...
10:02:26 <byorgey> :t shows
10:02:27 <lambdabot> forall a. (Show a) => a -> String -> String
10:02:29 <dmwit> killy9999: I'm not sure I understood this final objection.
10:03:01 <dmwit> What previous claim does "shows takes only one string" contradict?
10:03:46 <copumpkin> it's a DList
10:03:50 <dmwit> ?tell tgeeky Yes, I'm reading that paper (Two Dualities of Computation) carefully. Any specific questions?
10:03:50 <lambdabot> Consider it noted.
10:04:15 <copumpkin> shows could easily have type a -> DList Char
10:04:22 <killy9999> dmwit: You applied shows with two parameters, but type signature says it takes only one?
10:04:22 <dmwit> ?remember rwbarton a technique is a hack that works more than once
10:04:22 <lambdabot> Okay.
10:04:43 <dmwit> killy9999: The type signature shows that it takes a showable thing and returns a ShowS... which is a String -> String.
10:04:50 <dmwit> type ShowS = String -> String, remember?
10:05:02 <killy9999> yes, I remember
10:05:04 <byorgey> a -> ShowS  =  a -> (String -> String)  =  a -> String -> String
10:05:11 <killy9999> but somehow can;t put this together...
10:05:24 <killy9999> Ah, OK
10:05:27 <killy9999> now I see
10:05:32 <dmwit> As an alternate explanation, shows 3 "foo" = (shows 3) "foo"
10:06:31 <killy9999> why is it a hack?
10:06:42 <killy9999> I mean how does it improve performance?
10:06:52 <dmwit> Well, the problem is that appending to lists is O(n) in the length of the first list.
10:06:59 <dmwit> But composing functions is O(1)...
10:07:16 <dmwit> So you compose things like (++"foo") instead of directly applying them.
10:07:26 <byorgey> it still seems so magical to me that that actually works.
10:07:27 <copumpkin> composing O(n) functions is O(n)
10:07:27 <killy9999> but in the end appending has to be performed somewhere?
10:07:28 <dmwit> I think there's a good explanation of why this helps on the wiki somewhere.
10:07:55 <byorgey> the real trick is that function composition ends up reassociating everything so the ++'s are right instead of left-nested
10:08:04 <dmwit> http://www.haskell.org/haskellwiki/Difference_list
10:08:38 <dmwit> byorgey: Oh, hey, that explanation is succinct and quite intuitive. Nice!
10:08:40 * hackagebot interpolatedstring-perl6 0.9.0 - QuasiQuoter for Perl6-style multi-line interpolated strings  http://hackage.haskell.org/package/interpolatedstring-perl6-0.9.0 (AudreyTang)
10:08:40 <copumpkin> this is a weird place to put dons's full name
10:08:41 <copumpkin> http://snapplr.com/czbq
10:08:59 <byorgey> ((((x++) . (y++)) . (z++)) . (w++)) foo == x ++ (y ++ (z ++ (w ++ foo)))
10:09:18 <a7x> hi, did someone ever seen this kind of error? http://pastebin.com/raw.php?i=DbdRfDhT
10:09:21 <mauke> The paste DbdRfDhT has been copied to http://hpaste.org/67285
10:09:25 <byorgey> copumpkin: haha, what
10:10:15 <copumpkin> I don't think he goes by the full name anywhere in the community
10:10:25 <copumpkin> so someone was just creepy and looked up his middle name to use it in the wiki?
10:10:37 <dmwit> dolan pls
10:10:57 <rwbarton> a7x: looks like a locale issue (while printing some debugging info amusingly)
10:11:20 <typoclass> copumpkin: i think his hackage account has "donald", which gives you pause as well
10:11:30 <dafis> copumpkin: In the early days, iirc, he posted under his full name to the mailing lists.
10:11:35 <copumpkin> oh, okay
10:11:36 <dmwit> I wish my Hackage account could have been "dmwit".
10:11:51 <rwbarton> a7x: what does "locale -a" print? can you use a utf-8 locale?
10:11:58 <a7x> rwbarton, that's weird, i'm on en_GB
10:12:03 <thoughtpolice> wasn't there some fuss at one point about using psuedonyms on hackage?
10:12:09 <dmwit> probably
10:12:16 <a7x> locale -a    en_GB en_GB.iso88591 en_GB.iso885915
10:12:19 <dmwit> a7x: Maybe you want en_GB.utf8 or so...
10:12:21 <dafis> dmwit: Not necessarily a good idea, I always read it as dimwit.
10:12:22 <rwbarton> actually i meant "locale" not "locale -a"
10:12:23 <thoughtpolice> which i never quite understood, personally
10:12:31 <dmwit> dafis: That's how it's meant to be read! =)
10:12:40 <rwbarton> well, "locale -a" is useful too, looks like you don't have a utf-8 locale installed...
10:12:55 <dafis> dmwit: I'mnot really surprised, but it's a lie.
10:12:57 <rwbarton> can you just ... build the package with a lower verbosity setting?
10:13:32 <a7x> rwbarton: LANG=en_GB LANGUAGE= LC_CTYPE="en_GB" LC_ALL=
10:13:40 <a7x> rwbarton, i'm trying to find out a bug :\
10:13:43 <rwbarton> I assume en_GB is, like, ASCII.
10:14:00 <rwbarton> So it's complaining that it can't print the unicode character in that line of the source code.
10:14:01 <dmwit> iso8859-1 is ASCII + 128
10:14:04 <rwbarton> reasonably enough.
10:14:26 <rwbarton> The one after "import Prelude.Unicode hiding ( ("
10:14:47 <a7x> i'm running dpkg-reconfigure rwbarton
10:14:57 <dmwit> Does your locale affect how GHC attempts to decode the files it reads, too?
10:15:03 <dmwit> I might actually consider that a bug, if true.
10:15:18 <rwbarton> i forget the magic incantation in debian to install a utf-8 locale, but yeah, do that.
10:15:23 <rwbarton> whatever it is
10:15:27 <quicksilver> dmwit: it was a bug decided on after much long and painful debate
10:15:29 <a7x> dmwit, too late i alredy did it
10:15:36 <quicksilver> dmwit: and it's under programmer control.
10:15:52 <dmwit> Ah! I'll look in the user manual, then.
10:15:58 <rwbarton> it seems to have worked fine in this case anyways
10:16:05 <rwbarton> <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
10:16:10 <rwbarton> rather than some error about reading the character
10:17:03 <quicksilver> dmwit: some info in the changelog for base-4.4 : http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/release-7-2-1.html#id567292
10:17:11 <a7x> ok rwbarton, that one looks fixed
10:17:13 <shirt> let applyN n f = foldr1 (.) (replicate n f) in (applyN 100000000 (+1)) 0
10:17:13 <dmwit> quicksilver: thanks
10:17:16 <shirt> how do i make this not crash?
10:18:54 <quicksilver> dmwit: oh, and further changes in 7.4, actually
10:19:19 <a7x> this one looks like a haskell bug too: http://pastebin.com/ZQHU62PS but i'm not sure
10:19:22 <mauke> The paste ZQHU62PS has been copied to http://hpaste.org/67286
10:20:20 <rwbarton> oh they fixed gcd 0 0, nice
10:20:57 <dafis> rwbarton: took a lot of tries
10:22:42 <rwbarton> "The result of minBound `rem` -1 and minBound `div` -1 is now 0, rather than throwing an overflow exception." <-- is div a typo for mod?
10:23:03 <rwbarton> (yes)
10:23:11 <byorgey> must be
10:23:35 <byorgey> also, -1 is a typo for (-1)
10:23:40 * hackagebot signed-multiset 0.2.0.1 - Multisets with negative membership.  http://hackage.haskell.org/package/signed-multiset-0.2.0.1 (StefanHoldermans)
10:23:48 <rwbarton> I noticed that too when I realized I could just test it. :)
10:23:51 <byorgey> > minBound `div` (-1) :: Int  -- overflows
10:23:52 <lambdabot>   *Exception: arithmetic overflow
10:24:01 <byorgey> > minBound `mod` (-1) :: Int
10:24:02 <lambdabot>   *Exception: arithmetic overflow
10:24:24 <byorgey> hmm, what version of base is lambdabot using?
10:24:44 <rwbarton> something fairly old
10:24:46 <hpc> @version
10:24:46 <lambdabot> lambdabot 4.2.2.1
10:24:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:25:02 <hpc> http://hackage.haskell.org/package/lambdabot-4.2.2.1
10:25:49 <a7x> okay rwbarton, i was wrong, i'm stuck at the same error
10:25:59 <a7x> <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
10:26:33 <rwbarton> can you paste the full output including the command line you used
10:26:58 <a7x> before that, i'm gonna change my putty settings to utf-8 is the latest thing i can try :\
10:27:36 <hayashi> @pl \f g a b c d e -> f a b (g c d e)
10:27:36 <a7x> (and login again of course)
10:27:36 <lambdabot> flip . ((flip . (((.) . (.) . (.)) .)) .)
10:27:42 <hayashi> ...nothx
10:30:57 <hpaste_> ayx pasted “Error log” at http://hpaste.org/67287
10:31:12 <a7x> rwbarton: http://hpaste.org/67287
10:31:30 <a7x> i think i fixed that one.. but it's still weird.
10:32:10 <a7x> about the launch command, i did: "cabal  install -v3"
10:32:52 <a7x> ohm looks like that log is not the full one
10:33:43 <hpaste_> ayx pasted “Error log2” at http://hpaste.org/67288
10:35:53 <killy9999> when I do 'read "5"' I get "Ambiguous type variable `a0' in the constraint". Why doesn't this qualify as Overlapping Instance?
10:36:24 <quicksilver> killy9999: what do you imagine overlaps with what?
10:36:39 <quicksilver> this isn't about overlap, it's about GHC not being able to guess which type you mean
10:36:46 <quicksilver> > read "5" :: Int
10:36:47 <lambdabot>   5
10:36:51 <quicksilver> > read "5" :: Word8
10:36:52 <lambdabot>   5
10:37:10 <killy9999> I imagine that there are several possible types that read "5" can mean and that these types overlap
10:37:23 <quicksilver> nope.
10:37:27 <killy9999> I know that's wrong, but I don't know why :)
10:37:28 <quicksilver> Int and Word8 do not overlap
10:37:29 <hpc> :t read 5
10:37:30 <lambdabot>     No instance for (Num String)
10:37:30 <lambdabot>       arising from the literal `5' at <interactive>:1:5
10:37:31 <lambdabot>     Possible fix: add an instance declaration for (Num String)
10:37:35 <hpc> :t read "5"
10:37:35 <quicksilver> they are completely separate types.
10:37:36 <lambdabot> forall a. (Read a) => a
10:37:49 <quicksilver> what overlaps is their textual representation
10:37:55 <killy9999> ok, so I don't understand overlapping instances...
10:37:56 <quicksilver> but that's out of scope for the type system :)
10:38:15 <quicksilver> If you had instances for (Int,a) and (b,Double) those would overlap
10:38:20 <quicksilver> because (Int,Double) matches both.
10:38:40 <quicksilver> simiarly "Int" overlaps with "a"
10:38:41 * hackagebot cabal-debian 1.21 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.21 (DavidFox)
10:38:44 <quicksilver> everything overlaps with "a"
10:39:11 <killy9999> so overlapping occurs only when I have parametrized types and some more specfic ones?
10:39:26 <rwbarton> overlapping instances occurs firstly when you are talking about two instances
10:40:05 <heatsink> A new error happened to me.
10:40:09 <heatsink> What is an untouchable type variable?
10:40:26 <quicksilver> killy9999: yes.
10:40:37 <quicksilver> killy9999: two concrete types can never overlap (unless they are the same!!!)
10:40:48 <quicksilver> killy9999: so, overlap implies some degree or parameterisation.
10:41:08 <killy9999> quicksiler, rwbarton: ok, this makes sense
10:41:23 <killy9999> It seems that everything in Haskell makes sense
10:41:33 <killy9999> well, almost everything
10:43:22 <parcs`> heatsink: i got that error once, but i don't understand it. can you paste the code?
10:44:49 <heatsink> I don't have a small readable example
10:45:01 <heatsink> I fixed it by adding a type signature
10:45:29 <parcs`> oh ok
10:45:43 * heatsink still doesn't understand it though
10:45:43 <scooty-puff> why is the $! in return $! (a, b) redundant? what if return does not deconstruct (,)?
10:46:07 <copumpkin> scooty-puff: it probably isn't particularly important to force the tuple wrapper
10:46:14 <dafis> scooty-puff: you just explicitly constructed a tuple
10:46:29 <dafis> so there's no point verifying that it's a tuple
10:46:29 <killy9999> Tell me if I'mt thinking correctly: trigonometric functions are implemented within a typelcass Floating, because their exact implementation differs between different instances, e.g. sin can be computed more accurately with Double that with Float
10:46:31 <scooty-puff> k, so would that be true for any other single constructor data type?
10:46:38 <rwbarton> in general forcing constructors is not relevant unless they have strict fields
10:46:41 <heatsink> Not if the data type has strict fields
10:46:51 <scooty-puff> rwbarton, k, that was my next question
10:47:07 <byorgey> scooty-puff: the number of constructors is not relevant
10:47:11 <scooty-puff> k
10:48:14 <scooty-puff> is this a place where data constructors should not just be thought of as functions that produce something of a type?
10:48:40 <scooty-puff> or can i just think of them as particularlly simple functions?
10:48:53 <parcs`> return $! ((,) $! a) $! b :)
10:49:19 <rwbarton> they are simple functions, but also a constructor (without strict fields) is sort of the universal example of a function which is lazy
10:49:36 <rwbarton> since by definition, "forcing" means evaluate to the outermost constructor
10:49:58 <qnikst> is it possible to explicitly parralelize such a thing: (map (\xs@(x:_) ->tail $ map (\(v',r') -> v'-x*r')  $ zip xs newR) other)
10:50:33 <qnikst> simply:  map (...) list'
10:50:36 <scooty-puff> k
10:51:15 <killy9999> what does curry and uncurry do? I can't figure it out...
10:51:33 <heatsink> It converts between functions taking two parameters and functions taking tuple parameters
10:51:54 <aristid> :t curry
10:51:54 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:51:59 <aristid> :t uncurry
10:52:00 <heatsink> > let f = (+) in f 3 4
10:52:00 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:52:01 <lambdabot>   7
10:52:14 <heatsink> >let f = (+) in uncurry f (3, 4)
10:52:16 <killy9999> Isn't the name a bit misleading then?
10:52:24 <heatsink> > let f = (+) in uncurry f (3, 4)
10:52:24 <aristid> killy9999: why?
10:52:25 <lambdabot>   7
10:52:35 <aristid> killy9999: did you think it would make delicious curry?
10:52:38 <dmwit> shirt: You ever get an answer?
10:52:46 <killy9999> aristid: :)
10:53:02 <aristid> :D
10:53:11 <killy9999> aristid: no, but I didn't expect tupples to have anything to do with currying
10:54:03 <rwbarton> well if we didn't write functions in the curried style, how would we pass multiple arguments?
10:54:30 <dmwit> :t pseq
10:54:30 <lambdabot> forall a b. a -> b -> b
10:54:43 <quicksilver> with syntax, rwbarton , which we don't have :)
10:54:54 <dmwit> > let elemStrict (x:xs) = x `pseq` (x:elemStrict xs) in elemStrict (iterate (+1) 0) !! 100000000
10:54:56 <aristid> killy9999: it's a traditional term *shrug*
10:54:57 <dmwit> shirt: like that
10:54:58 <lambdabot>   mueval-core: Time limit exceeded
10:55:14 <quicksilver> one of the confusing things with talking about curry in haskell is that we pretend tuples are multiple arguments passed as one because it's convenient for the explanation
10:55:14 <aristid> killy9999: named after haskell curry!
10:55:17 <quicksilver> but they aren't.
10:55:18 <aristid> like haskell
10:55:25 <rwbarton> ... or we could use a tuple
10:55:33 <rwbarton> another way to pretend we have multiple arguments
10:55:40 <quicksilver> but it's only pretending.
10:55:42 <quicksilver> but yes.
10:56:11 <killy9999> aristid: and invented by schonfinkel...
10:56:13 <killy9999> :)
10:56:30 <EvanR> dr schonfinkelstein
10:56:43 <EvanR> created a monster
10:56:46 <shirt> dmwit: hm...
10:56:56 <overlapi> hey guys.can somebody help me with SOE.graphics
10:57:07 <aristid> killy9999: i think there is a website for the glory of schonfinkel
10:57:08 <dmwit> > last [0..100000000] -- or like this, but that's specific to (+1) and 0, whereas mine isn't =)
10:57:11 <lambdabot>   100000000
10:58:16 <heatsink> hmm
10:58:22 <aristid> killy9999: http://www.cynic.net/tsac.html
10:59:15 <killy9999> haha :)
11:03:56 <a7x> rwbarton, actually i got tired, i reinstalled the whole system in a chroot, with debian wheezy without backport and this is the result: http://pastebin.com/Y8dCpr1e
11:03:58 <mauke> The paste Y8dCpr1e has been copied to http://hpaste.org/67289
11:04:42 <rwbarton> do you have libreadline5-dev installed
11:05:02 <a7x>  lol. no rwbarton, i just forgot this is a brand new system
11:05:03 <rwbarton> or whatever seems to be the appropriate version
11:05:06 <zen_> Hello there
11:05:49 <zen_> I haven't been on IRC for 13 years
11:06:13 <a7x> zen_, everything changed in 13 years
11:06:29 <monochrom> we now use UTF-8
11:06:34 <a7x> /whois doesn't work anymore, now it's /Profile user
11:06:50 <zen_> そうですね
11:06:57 <monochrom> yes, like that
11:06:59 <kallisti_> $ cabal install --reinstall --enable-shared base
11:07:00 <kallisti_> Resolving dependencies...
11:07:00 <kallisti_> cabal: internal error: impossible
11:07:00 <zen_> You tell the truth
11:07:17 <edwardk> looks like google has accepted our proposed project list for the summer of code
11:07:33 <luite> what is the list?
11:07:33 <zen_> ok, I have a question
11:07:42 <rmunroe> zen_: You've got an underscore at the end of your nick. Probably just means your session from last time is still connected. Makes sense--they sometimes take 15-20 years to lag out.
11:07:53 <monochrom> haha
11:08:08 <zen_> lol, I don't think I ever visited haskell before
11:08:42 * hackagebot blaze-builder-enumerator 0.2.0.4 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.4 (SimonHengel)
11:09:05 <luite> yay another package that now works with the new transformers
11:09:25 <luite> only 3 more to go if you want to install yesod with it transformers 0.3 :p
11:09:45 <qnikst> luite: hm I'm using yesod with transformers 3
11:09:51 <qnikst> 0.3
11:10:06 <edwardk> luite: In no particular order: Scoutess, concurrent hash tables, patch index optimization for darcs, improvements to ghc to allow multiple instances of a package, sandboxing/isolation in cabal, haskell-type-exts (a type checker for haskell-src-exts), apfelmus's browser based ghci, and a continuous development interface for yesod/happstack
11:11:21 <luite> edwardk: ah quite a lot, and I guess I sort of promised to help out with the last one. is it still possible or useful to register somehow?
11:11:37 <byorgey> edwardk: meaning there are actually students who have proposed to work on each of those?  Or just that the project ideas are approved in general?
11:12:06 <edwardk> luite: you should be able to go to socghop.appspot.com and submit an application to the haskell.org organization on the site
11:12:36 <edwardk> byorgey: meaning real students put in proposals, and out of the ones we received, and the slots we were given by google those are the ones we picked
11:12:40 <luite> and I'm a bit curious about the final proposal by apfelmus
11:12:52 <byorgey> edwardk: ah, excellent!
11:12:53 <edwardk> luite: yeah it seems to overlap a lot with your stuff
11:13:00 <Saizan> haskell-type-exts seems potentially huge
11:13:15 <edwardk> luite: shapr is going to work on it, so you can probably bend his ear ;)
11:13:17 * byorgey will be interested to see gwern's predictions =)
11:13:39 <zen_> So I hope someone can answer this question.  I am developing a program induction algorithm, it is not like genetic programming but requires the same language features.  That is, the ability for form, manipulate and apply functions to values.  I've achieved this in javascript by having a graph based, polymorphically typed program structure, and converting this to a javascript string and using the Function constructor.
11:14:00 <zen_> However I am  interested in finding out what approach, if any, I could take in Haskell
11:14:04 <zen_> any ideas?
11:14:33 <heatsink> If you're "mutating" programs, you would probably define a data structure representing programs
11:14:35 <heatsink> and an interpreter on it
11:14:44 <edwardk> byorgey: i would have been interested in gwerns' feedback before it was too late. alas, he'd rather snipe from the sidelines
11:14:52 <byorgey> edwardk: heh, good point
11:15:07 <zen_> Right, I could write a constructor, but was hoping to just take advantage of the compiler
11:15:24 <zen_> *interpreter not constructor
11:15:35 <EvanR> compile to haskell? ehh..
11:15:51 <zen_> no sorry
11:15:56 <zen_> i mean ignore the javascript
11:16:08 <zen_> I am trying to find out if I could write a new version in Haskell
11:16:09 <heatsink> How would your program edit programs then?  By editing strings?
11:16:35 <luite> edwardk: oh that's cool :) I haven't had a lot of contact with apfelmus yet, at least not about implementation details. of course i'm to blame for not publishing the source code yet
11:16:37 <zen_> IWell possibly, that's part of what I am asking
11:16:50 <EvanR> dont edit strings
11:16:51 <ciaranm> you don't work with strings. you work with functions
11:17:02 <edwardk> byorgey: as i spent months trying to get him to sign up to vote during the ramp up to this point, i finally gave up
11:17:09 <zen_> I would prefer to work directly with functions
11:17:14 <zen_> but I am not sure how I could dynamically compile them
11:17:15 <heatsink> Maybe some pointers to example embedded languages would help
11:17:37 <luite> i do get a feeling that afpelmus wants to set it up completely differently though... yesod is too ugly for him, template haskell and quasiquoters and all
11:17:41 <heatsink> Functions are opaque data.  If you want to do anything to a function other than execute it, you'll have to represent it with a data structure.
11:18:02 <zen_> ok
11:18:17 <edwardk> @tell shapr Congratulations. Body: None
11:18:18 <lambdabot> Consider it noted.
11:18:21 <EvanR> heatsink: you can also compose them
11:18:22 <luite> :)
11:18:34 <ciaranm> zen_: forget compiling etc
11:18:47 <osa1> I want to filter "Just a"s in a [Maybe a], how can I do that?
11:19:03 <shachaf> @ty catMaybes
11:19:04 <lambdabot> forall a. [Maybe a] -> [a]
11:19:19 <shachaf> (Or (filter isJust). But you don't really want filter isJust.)
11:19:37 <osa1> shachaf: which package contains that?
11:19:41 <ciaranm> > (if True then (+) else (*)) 2 3
11:19:41 <lambdabot>   5
11:19:46 <ciaranm> zen_: ^^
11:19:51 <any-key> So, I'm back with another ByteString question...without using Data.Binary, what would be the best way to go about writing an Integer to a ByteString?
11:20:10 <shachaf> @hoogle [Maybe a] -> [a]
11:20:11 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:20:11 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:20:11 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:20:18 <any-key> (it's a school assignment, we're limited to included haskell libraries)
11:20:23 <zen_> I guess I do really need to be able to inspect inside a function.  Effectively  I have created within javascript a simple polymorphically typed functions, where functions are transparent and can be modified.  There is a performance penalty for using javacript though
11:20:35 <zen_> which is why I inquired about Haskell.
11:20:39 <ciaranm> zen_: you don't need to be able to inspect inside a function
11:20:58 <zen_> simple polymorphically typed language*
11:21:06 <ciaranm> zen_: you pass in functions as parameters to your bigger function
11:21:12 <srhb> Yes, he does, but not a Haskell function.
11:21:21 <srhb> Just something that can become a Haskell function.
11:22:24 <heatsink> zen_: Accelerate is an example of an embedded language.  It's one example of representing programs in data structures. http://www.cse.unsw.edu.au/~chak/project/accelerate/
11:22:35 <heatsink> You can also read the implementation http://hackage.haskell.org/package/accelerate-0.9.0.1
11:22:51 <shirt> dmwit: thanks. is pseq required, or will regular seq also work?
11:22:56 <srhb> zen_: Have you Googled "strongly typed genetic programming"?
11:23:06 <zen_> yes I have read that paper
11:23:13 <zen_> heatsink: thanks for the link
11:23:43 <srhb> zen_: How about PolyGP?
11:24:10 <srhb> It has emphasis on limiting the solution space with types, of course.
11:24:22 <zen_> srnb: yes
11:24:35 <zen_> well that is my motivation for using types
11:24:38 <srhb> Alright then. :-)
11:24:44 <zen_> but they say nothing of the implementation
11:25:08 <srhb> No, but I think it's because it's an obvious chance to manipulate an embedded language..
11:26:50 <any-key> Sorry to interrupt again, but can anyone point me in the right direction regarding appending Integers to a ByteString?
11:27:20 <zen_> More generally, why is it that languages don't allow  you to reason about the structure of functions.  I guess LISP does to an extent.
11:27:29 <any-key> Appending strings is just Data.ByteString.Char8.pack, but I can't seem to locate anything regarding integers
11:28:07 <gdeest> > show 123
11:28:08 <lambdabot>   "123"
11:28:19 <gdeest> Well, it does add quotes
11:28:28 <any-key> I guess I can pack that into a char8
11:29:10 <any-key> well, I don't think that accomplishes the same thing
11:29:32 <any-key> I need to write 0x7B rather than "123"
11:30:08 <zen_> hmm
11:30:13 <gdeest> > showIntAtBase 16 123
11:30:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:30:14 <lambdabot>    arising from the literal `1...
11:30:46 <gdeest> Ow it's a bit more complex
11:30:55 <hpc> :t showIntAtBase
11:30:56 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:31:04 <gdeest> You need to provide a function that transforms an Int into a Char
11:31:10 <hpc> (the AtBase functions are ridiculous)
11:31:30 <gdeest> There is this:
11:31:35 <hpc> > printf "%x" 123 :: String
11:31:36 <lambdabot>   "7b"
11:31:36 <gdeest> :t showEx
11:31:37 <lambdabot> Not in scope: `showEx'
11:31:48 <gdeest> :t showHex
11:31:49 <lambdabot> forall a. (Integral a) => a -> String -> String
11:31:56 <gdeest> (sorry)
11:32:05 <srhb> > 123 :: Word8
11:32:05 <any-key> this is a lot closer though
11:32:07 <lambdabot>   123
11:32:12 <gdeest> > showHex 123 ""
11:32:13 <lambdabot>   "7b"
11:32:32 <srhb> Are you sure that what you want is not singleton $ 123?
11:32:36 <any-key> 123 :: Word8 is what I'm looking for I believe
11:32:53 <srhb> :t singleton 123
11:32:54 <lambdabot> Not in scope: `singleton'
11:32:55 <any-key> lets see if this writes it the way I need it
11:33:10 <srhb> > singleton 123
11:33:11 <lambdabot>   Not in scope: `singleton'
11:33:14 <srhb> Baw..
11:37:16 <any-key> okay, stupid question #2: I have "import qualified Data.ByteString as BS"
11:37:25 <any-key> and I can't seem to do BS.Char8.pack
11:37:30 <rwbarton> correct
11:37:38 <any-key> perhaps I'm misunderstanding what import qualified accomplishes
11:37:47 <rwbarton> Data.ByteString and Data.ByteString.Char8 are entirely unrelated
11:37:57 <any-key> ah
11:38:10 <rwbarton> (as far as the module system is concerned that is)
11:38:37 <Saizan> there are no submodules
11:38:48 <shirt> what any-key tried to do wold actually be pretty cool if it worked
11:39:00 <any-key> shirt: which thing?
11:39:04 <any-key> I've tried many things :P
11:39:31 <shirt> BS.Char8.pack
11:39:36 <any-key> yeah
11:41:03 <Saizan> yeah, Haskell's module system is simpler than it should
11:41:04 <any-key> ByteStrings are cool to work with, but type conversions with them are a pain in the ass
11:41:22 <any-key> I wish I could just go about it the C way and cast :'(
11:41:54 <blackdog> any-key: you're using OverloadedStrings, right?
11:42:03 <any-key> blackdog: nope, just stringstrings
11:42:19 <blackdog> will still have to do some conversions, but all literal strings can be read as ByteString of choice
11:42:21 <any-key> in this case I'm trying to turn Integers into ByteStrings
11:42:32 <blackdog> ah, right.
11:45:42 <scooty-puff> yay! memory leak fixed, thanks for the help related to data constructors
11:45:56 <hpaste_> scooty-puff pasted “Fixed memory leak” at http://hpaste.org/67292
11:46:15 <Eelis> is there some way to use a Data.Set directly as a set comprehension generator? in other words, can i avoid the ugly Set.toList in [f x | x <- Set.toList s] ?
11:46:26 <scooty-puff> should have guess it when +RTS -hy listed a bunch of lists on the heap, but only thunk were listed from +RTS -hd
11:46:34 <Eelis> are there Foldable-aware list comprehensions?
11:46:57 <srhb> any-key: I don't really understand the problem. You can append (or cons) any Word8 onto a ByteString. Is that not what you want?
11:47:30 <any-key> srhb: yes, but I'm dealing with Integers, so I'm trying to get those working
11:47:37 <any-key> BUT fromIntegral appears to be what I'm after
11:47:46 <Saizan> Eelis: no, there are MonadComprhensions but they won't help in your case
11:48:07 <any-key> fromIntegral (123 :: Integer) :: Word8
11:48:14 <scooty-puff> for a newtype T a = T a, would T $ <...>
11:48:16 <scooty-puff> produce a thunk?
11:48:23 <rwbarton> no
11:48:29 <rwbarton> well not from the T anyways
11:48:32 <any-key> I always forget how magical fromIntegral is
11:48:36 <scooty-puff> k
11:49:49 <Eelis> Saizan: ok, thanks :)
11:50:47 <zen_> Thanks guys
11:53:43 * hackagebot ImperativeHaskell 0.1.0.0 -   http://hackage.haskell.org/package/ImperativeHaskell-0.1.0.0 (MatthewMirman)
11:55:12 <mekeor> so, what's the easiest way to get updateable variables in haskell? (which monad?)
11:55:28 <aristid> mekeor: State, i guess
11:56:30 <kallisti_> depends on how mutable/global you want them to be.
11:56:41 <kallisti_> but yeah State is the simplest mechanism for that.
11:56:57 <kallisti_> well, I guess the simplest mechanism is just return 2-tuples
11:57:07 <mekeor> hm… cool. nice, thanks. will look at that.
11:57:22 <mekeor> kallisti_: how do you mean?
11:57:29 <arnoldas> why one should use space keys instead of tabs if one has to split the scope (e.g. by using where etc.)?
11:57:49 <DMcGill> if it's for efficiency reasons, note that State isn't true mutibility
11:58:05 <DMcGill> mutability*
11:58:11 <mekeor> arnoldas: just don't use tabs ever. that's best.
11:58:15 <anssik> cabal install scion-browser -> "dependencies conflict: ghc-7.0.3 requires containers ==0.3.0.0 however containers-0.3.0.0 was excluded because ghc-7.0.3 requires containers==0.4.0.0"
11:58:21 <anssik> I don't get this error, what it means?
11:58:27 <arnoldas> mekeor: why they're so bad?
11:58:47 <mekeor> arnoldas: because people often have different tab-widths etc.
11:58:58 <DMcGill> tabs are ambiguous
11:59:05 <mekeor> arnoldas: spaces have a unique width.
11:59:08 <kallisti_> mekeor: well the simplest way to pass state along in a program would be to return a 2-tuple where one value is the result of the computation and the second is the state value
11:59:35 <adamt> anssik: It means cabal is bad at dealing with dependencies. ;)
11:59:37 <mekeor> kallisti_: what is the "state value" ?
11:59:38 <arnoldas> why ambiguity is "bad"?
11:59:49 <kallisti_> mekeor: anything
12:00:12 <kallisti_> mekeor: it would be your "updateable variable"
12:00:18 <anssik> I see..
12:00:19 <mekeor> arnoldas: when you don't have the correct tab-width, your code seem to be fine, but it doesn't compile! because it's ambiguity.
12:00:28 <mekeor> kallisti_: ah!
12:00:36 <rwbarton> tabs aren't ambiguous. your editor is just wrong.
12:00:59 <kallisti_> mekeor: in fact State is just a convenient abstraction over this concept
12:01:04 <mekeor> rwbarton: yea but anyway. you shouldn't use them, imo…
12:01:16 <rwbarton> yes
12:01:18 <mekeor> kallisti_: ah cool. :)
12:01:25 <kallisti_> :t runState
12:01:26 <lambdabot> forall s a. State s a -> s -> (a, s)
12:01:26 <mekeor> rwbarton: how'd you argue?
12:01:33 <mekeor> ah! =)
12:01:34 <timthelion> Todo list:  add undo functionality, est. time. 3 hours.  finish data manipulation code, 4 hours, make the damn text entry dissapear when I press escape, 1 week???
12:01:39 * timthelion loves gtk2hs
12:01:52 <arnoldas> mekeor: "correct" tab-widht? is there a standard or sth. like this that defines the "correctness" of tab-widths?
12:02:16 <mekeor> arnoldas: the correct tab-width is 4 spaces, IIRC.
12:02:17 <parcs`> Eelis: there _is_ a way, but it's quite impractical http://paste.pocoo.org/show/584224/
12:02:39 <mekeor> arnoldas: it's defined in the specification.
12:02:43 <parcs`> hopefully in the future the Monad typeclass will be augmented with a Constraint kind
12:03:46 <kallisti_> mekeor: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Lazy.html#State  see if you can grok this code
12:03:55 <mekeor> :)
12:04:06 <kallisti_> in particular what runState and >>= dp
12:04:07 <kallisti_> *do
12:04:11 <rwbarton> tab means advance (by at least one column) to the next multiple of 8, it is an old convention that is still standard on unix
12:04:32 <rwbarton> and yes you shouldn't use them because many editors have other ideas about tabs
12:04:43 <kallisti_> mekeor: runState, get, put, return, and >>=  are the important ones.
12:05:20 <mekeor> kallisti_: alright. i'll just learn the usage of State first, then i'll take a look at its internals.
12:05:44 <kallisti_> that works.
12:05:57 <kallisti_> the internals tell you everything, though. :P
12:06:06 <arnoldas> rwbarton: but I use just one editor, why should I care about the others?
12:06:21 <rwbarton> because haskell uses the standard notion of tabs
12:06:56 <rwbarton> also because there is no upside to using tabs :)
12:07:00 <zhulikas> are there any svg bindings for haskell?
12:07:18 <mekeor> zhulikas: #diagrams is cool.
12:07:21 <mekeor> @where diagrams
12:07:21 <lambdabot> http://projects.haskell.org/diagrams/
12:07:33 <kallisti_> newtype State s a = State { runState :: s -> (a, s) }
12:07:33 <mekeor> zhulikas: AFAIK, it can export to SVG, too.
12:07:36 <arnoldas> rwbarton: ty, that answers my question :)
12:07:57 <zhulikas> thanks
12:08:12 <kallisti_> mekeor: a State computation is a function that takes an implicit state and returns a result coupled with a new state value.
12:08:36 <kallisti_> get   = State $ \s -> (s, s)
12:08:36 <mekeor> what does "class Monad m => MonadState s m | m -> s where" mean again? i forgot the meaning of "|" …
12:08:50 <kallisti_> | m -> s  is a functional dependency
12:08:58 <kallisti_> all it's saying is that "m uniquely determines s"
12:09:19 <mekeor> what does that mean?
12:09:27 <kallisti_> what do you think it means?
12:09:28 <mekeor> there's only ONE certain s for a m?
12:09:33 <kallisti_> yes
12:09:39 <kallisti_> if GHC knows m
12:09:39 <mekeor> fine :) thanks :)
12:09:42 <kallisti_> it can determine what s is
12:09:47 <mekeor> aah, yea, got it.
12:10:28 <parcs`> there's an imaginary mathematical function that maps 'm's to 's's which the type class depends on, hence functional dependency :P
12:11:25 <kallisti_> mekeor: it basically reduces the number of ambiguous types in State code. it's not required but if it weren't there you would need more explicit type signatures.
12:11:34 <kallisti_> (I think)
12:11:44 <parcs`> or rather, the relation between m to s is a functional one
12:12:06 <mekeor> parcs`: yep :)
12:12:19 <kallisti_> get   = State $ \s -> (s, s)
12:12:25 <mekeor> kallisti_: ah yep :)
12:12:28 <kallisti_> what this state computation does is pretty straightforward, yes?
12:12:40 <mekeor> it… er… wait.
12:12:43 <kallisti_> when you run it, it results in the state value that was passed to it.
12:13:22 <kallisti_> mekeor: the first tuple element is the result, the second one is the state value to pass to future computations.
12:13:33 <kallisti_> get is taking the state value and sticking it where the result goes.
12:13:38 <kallisti_> thus it "gets" the state for you.
12:14:17 <kallisti_> ("result" here meaning "monadic result" meaning "the thing you can refer to with >>=")
12:14:33 <kallisti_> get >>= (\x -> ...)
12:14:42 <kallisti_> x refers to the current state.
12:14:44 <mekeor> actually, the examples on http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html#g:4 are self-explanatory.
12:14:52 <scooty-puff> is f . g . h $! x different from f $ g $ h $! x (in any way)
12:15:14 <parcs`> no
12:15:17 <scooty-puff> k
12:16:08 <kallisti_> mekeor: the important thing is that you eventually call runState, which starts everything.
12:16:19 <kallisti_> by supplying the intial state value.
12:17:08 <kallisti_> mekeor: dunno, I always find it instructive to look at the source code; maybe it doesn't work so well for beginners.
12:17:41 <mekeor> maybe, yes. =)
12:18:33 <gzmask> hello folks, I am trying to install wxhaskell on osx. I got "wx-0.90 depends on wxc-0.90.0.2 which failed to install". the the exception is "ExitFailure 1" . What does this mean?
12:18:45 <kallisti_> gzmask: are you on debian?
12:18:51 <kallisti_> or Ubuntu perhaps?
12:18:55 <parcs`> hehe
12:18:55 <gzmask> I am on OSX 10.6
12:19:06 <kallisti_> oh, well, first I should ask: did you install the wx header files?
12:19:08 <kallisti_> because you need those.
12:19:12 <bitonic> gzmask: so did you install the Haskell Platform?
12:19:26 <gzmask> bitonic: yes, I use brew to install the platform
12:19:40 * kallisti_ doesn't know where the wx dev files are locates in OSX world.
12:20:16 <bitonic> gzmask: does the wxc installation output some more meaningful error? anyways you're probably missing the wx development library as kallisti_ says
12:20:21 <gzmask> is there a way to check the dev files and link them manually?
12:20:48 <kallisti_> if brew is a good package manager it should just have them somewhere
12:20:55 <rwbarton> > (const True $ id $ id $! undefined, const True . id . id $! undefined)
12:20:57 <lambdabot>   (True,*Exception: Prelude.undefined
12:21:01 <kallisti_> and then you install them, and then you try to install wx again, and then you're done. :P
12:21:28 <bitonic> gzmask: you shouldn't need to link them manually
12:21:37 <gzmask> kallisti_: I follow the instructions here:
12:21:44 <parcs`> rwbarton: damn that's sneaky
12:21:47 <gzmask> http://www.haskell.org/haskellwiki/WxHaskell/MacOS_X
12:22:06 <monochrom> "if brew is a good package manager" sounds deja vu to me. once upon a time, someone said "if cabal is a good package manager"...
12:23:01 <kallisti_> 2012-04-14: On MacOS X Lion, to install wxWidgets 2.9 with HomeBrew, you may need to run brew install wxmac --use-llvm --devel
12:23:05 * kallisti_ wonders if this relevant.
12:23:16 <kallisti_> otherwise I don't know what's wrong without more info of some kind. o_O
12:23:18 <parcs`> > const True (id (id $! undefined))
12:23:19 <lambdabot>   True
12:23:34 <parcs`> i thought id was strict
12:23:41 <kallisti_> but const is not
12:23:44 <rwbarton> yes, one is x `seq` f (g (h x)), the other f (g (x `seq` h x))
12:24:07 <parcs`> oh i see
12:24:15 <gzmask> kallisti_: I am using snow leopard so I didn't have the llvm arg
12:24:21 <parcs`> scooty-puff: there is a difference ^
12:25:24 <scooty-puff> k
12:25:26 <frontendloader> is folding quicker than iterating for determining the length of a list?
12:26:06 <parcs`> iterating?
12:26:08 <parcs`> what's that
12:26:16 <rwbarton> I suggest using 'length'
12:26:49 <rwbarton> or examining the source of length
12:27:03 <kallisti_> mekeor: while you're at it you should look at Reader
12:27:10 <kallisti_> which is something like a read-only State
12:28:05 <mekeor> kallisti_: hmmm… ? a read-only state? doesn't make sense for me atm… but okay, yes, i will look at it.
12:28:12 <frontendloader> length uses what I'd call iterating
12:28:37 <kallisti_> mekeor: an implicit value passed to every computation which can be access but not rewritten
12:28:51 <kallisti_> useful for, say, configuration data.
12:28:52 <parcs`> @src length
12:28:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:29:15 <ChristianS> frontendloader: no matter what you do, you won't be able to beat length
12:29:16 <frontendloader> len (_:xs) a# = len xs (a# +# 1#) the meat of it is recursing on this till it hits 0 elements
12:29:34 <mekeor> kallisti_: hm.
12:30:28 <kallisti_> mekeor: with State
12:30:36 <kallisti_> er, with StateT or ReaderT you can put the 2 together
12:30:40 <kallisti_> into one monad.
12:30:42 <timthelion> >fst $ head $ filter (\(a,b) -> b == 'c') $ zip [1,2,3] ['a','b','c']
12:30:52 <timthelion> > fst $ head $ filter (\(a,b) -> b == 'c') $ zip [1,2,3] ['a','b','c']
12:30:52 <lambdabot>   3
12:30:55 <timthelion> if I have two lists of the same length like [1,2,3] ['a','b','c'], what's the best way to "look up" a value in one list given a "key" from the other?
12:31:05 <timthelion> as in the example above?
12:31:19 <kallisti_> :t lookup
12:31:19 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
12:31:37 <kallisti_> lookup key (zip a b)
12:31:51 <timthelion> kallisti_: thanks
12:33:44 <DMcGill> also I've heard to avoid using $ in that manner, using (.) instead although now I think about it I'm not sure why
12:33:48 * hackagebot ImperativeHaskell 0.1.0.1 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-0.1.0.1 (MatthewMirman)
12:35:19 <OvrKilT3rminator> How to define a type on ghci using multi-line feature?
12:35:52 <mekeor> OvrKilT3rminator: AFAIK, you can't.
12:36:05 <OvrKilT3rminator> Is there a good reason?
12:36:22 <DMcGill> the {;} notation doesn't work?
12:36:22 <mekeor> OvrKilT3rminator: think of GHCI as a do-block.
12:36:25 <OvrKilT3rminator> Why allowing it for normal terms, but not for types
12:36:53 <parcs`> OvrKilT3rminator: do you know how to use the multi-line feature?
12:37:04 <OvrKilT3rminator> ":set +m"
12:37:18 <OvrKilT3rminator> but that doesn't work with datatypes definitions
12:37:39 <OvrKilT3rminator> it is ok for terms, though
12:37:52 <Liskni_si> what does it do?
12:37:56 <jathd> Hi. Is there some (standard) typeclass C such that, if f was an instance of C, I could have a function foo :: Functor g => f (g a) -> g (f a) that sort of turns the thing inside out? For instance I'd have foo (x,y) = (x,) <$> y.
12:38:07 <Liskni_si> btw, :{ and :} work with multiline data statements
12:38:08 <mekeor> OvrKilT3rminator: you can't define data-types in GHCI, just like you can't in a do-block.
12:38:14 <qnikst> can I request comments on code it is attept to create gaussian elemination https://gist.github.com/2417365#file_qn_spghetti.hs  (gauss1)
12:38:18 <Liskni_si> mekeor: you can in 7.4
12:38:24 <bitonic> mekeor: you can in 7.4
12:38:27 <bitonic> damn.
12:38:31 <Liskni_si> jinx.
12:38:32 <mekeor> damn.
12:38:46 * mekeor wants 7.4!!
12:39:07 <bitonic> still don't have 7.4? tsk.
12:39:12 <byorgey> jathd: yes, Traversable
12:39:40 <byorgey> except you need g to be Applicative, Functor is not enough
12:39:49 <byorgey> @type Data.Traversable.sequenceA
12:39:50 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:39:58 <byorgey> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Traversable.html
12:40:39 <OvrKilT3rminator> Liskni_si: Thanks, for the :{ tip
12:40:56 <Liskni_si> OvrKilT3rminator: anyway, report the fact that it does not work for data as a bug
12:41:14 <jathd> byorgey: Yeah, my hoogle-fu turned that up, but is there a reason why ((,) a) isn't an instance of Traversable? I guess I can define an instance myself, but I hoped there was something more adapted.
12:41:28 <Liskni_si> althouh... it doesn't work for 5 + \n 5 either :-)
12:41:39 <kallisti> mekeor: oh and while you're at it check out Writer
12:41:39 <jathd> byorgey: (I mean "traversing" a tuple?? :-)
12:41:43 <byorgey> jathd: no, it's just an oversight
12:41:45 <mekeor> kallisti: lol :D
12:42:02 <kallisti> and RandT, and LogicT, and the list monad,.
12:42:11 <Liskni_si> seems like this multiline mode is just a crude heuristic for do :-)
12:42:11 <kallisti> and then ContT
12:42:21 <jathd> byorgey: Ok, thanks.
12:42:33 <mekeor> kallisti: yea, i'm sure i'll check out LogicT sometime. it's from oleg, right?
12:42:39 <kallisti> yes
12:43:02 <kallisti> et al!
12:43:07 <mekeor> et al.
12:43:44 <byorgey> jathd: actually, I'm also surprised there is not a Traversable instance for ((,) a) in Data.Traversable, there ought to be
12:43:49 <mekeor> kallisti: btw, what does the T stand for at the end of the names?
12:43:50 <adnauseam> something's wrong here (\x -> if x == 0 then 1 else 2* x (x-1)) 10
12:43:54 <kallisti> mekeor: transformer
12:43:57 <mekeor> ah
12:44:03 <adnauseam> (should produce 2^10)
12:44:10 <kallisti> (robots in disguise)
12:44:19 <mekeor> adnauseam: the type of 1 and the type of 2* are not equal.
12:44:27 <mekeor> oh wait. i misread, sorry.
12:44:32 <adnauseam> wat :{
12:44:47 <kallisti> mekeor: basically it's a monad with an extra parameter for another monad.
12:44:50 <mekeor> adnauseam: sorry. you're just missing the * between x and (x-1)
12:44:58 <jathd> byorgey: Huh, yeah, I thought it was because there's not much to traverse, but there is an instance for Maybe, so...
12:45:01 <adnauseam> hmm
12:45:01 <kallisti> that allows you to "combine" the 2 monads together.
12:45:07 <mekeor> adnauseam: 2*x*(x-1) instead of 2* x (x-1)
12:45:25 <mekeor> > (\x -> if x == 0 then 1 else 2* x*(x-1)) 10
12:45:25 <lambdabot>   180
12:45:31 <mekeor> adnauseam: there you go.
12:45:36 <adnauseam> hmm, i'm trying to produce 1024 :/
12:45:41 <adnauseam> it's a recursive lambda
12:45:47 <adnauseam> hmm
12:46:07 <kallisti> mekeor: so for example StateT MyState IO  is a monad that threads a value of type MyState through a sequence of IO computations.
12:46:07 <byorgey> adnauseam: oh, you need another argument then
12:46:14 <byorgey> adnauseam: x can't be both a number and a function.
12:46:28 <adnauseam> byorgey: i've seen it done :/
12:46:33 <mekeor> kallisti: wow, cool!
12:46:43 <byorgey> > fix (\f x -> if x == 0 then 1 else 2 * f (x-1)) 10
12:46:44 <lambdabot>   1024
12:46:46 <kallisti> mekeor: there's some lifting involved, but yes.
12:46:55 <adnauseam> oh
12:46:59 <adnauseam> dude, thank you!
12:47:04 <byorgey> sure =)
12:47:08 <kallisti> mekeor: to run an IO action in that monad you have to wrap it in a liftIO call.
12:47:14 <kallisti> :t liftIO
12:47:15 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:47:30 <mekeor> yea, i know liftIO. i had to use it sometimes.
12:47:44 <jathd> byorgey: The thing is it might be kinda weird, because traverse requires f to be Applicative, but to define Traversable ((,) a) you just need it to be a Functor.
12:47:58 <arnoldas> can someone give me a hint on the 9th problem of haskell's 99problem's list? (I don't want to lookup the solution, need just a hint)
12:49:04 <kallisti> :t runStateT
12:49:05 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
12:49:37 <byorgey> jathd: oh, yeah, I see what you're saying.
12:49:48 <kallisti> mekeor: runStateT passes the intiial state value to a StateT computation, and the result is a computation in the underlying monad  (the StateT layer is "peeled" off)
12:50:03 <kallisti> monad transformers are like onions.
12:50:16 <kallisti> onions filled with burritos.
12:50:18 <mekeor> arnoldas: i'd use 'span' (that is, 'takeWhile' and 'dropWhile') or so.
12:50:18 <ciaranm> they're ogres?
12:50:31 <byorgey> jathd: a function of type  (a, f b) -> f (a, b)  is also sometimes called 'strength' because the ability to factor f out of a pair like that corresponds to the notion of a 'strong functor'
12:51:24 <mekeor> @src (,) -- just wanna try that =)
12:51:24 <lambdabot> Source not found. My mind is going. I can feel it.
12:51:28 <mekeor> bummer.
12:52:01 <timthelion> mekeor: I saw a blog post about that.  The source is terrible!
12:52:28 <mekeor> data (,) a b = (,) a b -- ??
12:52:39 <timthelion> mekeor: http://blogs.gnome.org/wjjt/2012/03/29/if-you-like-a-tool-never-look-at-its-headers/
12:52:51 <mekeor> =)
12:52:52 <kallisti> tuples are special citizens of Haskell, they get special syntax you can't really write.
12:52:59 <kallisti> to define them
12:53:00 <kallisti> like lists.
12:53:12 <mekeor> timthelion: irony is difficult to see on IRC :/
12:54:03 <hpaste_> timthelion pasted “ThreadObject” at http://hpaste.org/67299
12:54:04 <jathd> byorgey: Huh, cool. Is there a name for a function f a -> a, that would be right inverse to Applicative's pure?
12:54:16 <mekeor> timthelion: great blog-post! cool! :D hahe
12:54:17 <kallisti> > max () ()
12:54:18 <lambdabot>   ()
12:54:19 <jfischoff> extract?
12:54:34 <ciaranm> jathd: copure!
12:54:38 <timthelion> unfortunately, I've run into this same problem in my own module... see paste, where I have to add update2 update3 update4 ... for each time I want to operate on more ThreadObjects
12:55:00 <mekeor> @info () -- lol :D
12:55:01 <lambdabot> ()
12:55:03 <byorgey> jathd: it's often called 'extract'
12:55:26 <byorgey> jathd: e.g. see http://hackage.haskell.org/packages/archive/comonad/1.1.1.4/doc/html/Control-Comonad.html#g:2
12:55:32 <timthelion> mekeor: so I'd be happy to hear sugestions as to how to get arround it.
12:55:39 <jathd> Ah. But there's not class that defines this kind of thing as a method?
12:55:49 <timthelion> there should be a way to define type macros...
12:55:57 <byorgey> jathd: there is, see my link =)
12:56:00 <ciaranm> jathd: Copointed or Comonad
12:56:03 <jathd> yeah, nevermind :)
12:56:11 <mekeor> timthelion: so, is that your blog?
12:56:28 <kallisti> timthelion: hm? you pasted the code somewhere?
12:56:34 <kallisti> oh I see
12:56:58 <timthelion> mekeor: nope
12:57:14 <timthelion> kallisti: http://hpaste.org/67299
12:57:50 <mekeor> lol. my favorite haskell-source-code: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
12:58:04 <kallisti> timthelion: this is weird code
12:58:32 <timthelion> kallisti: it's a beauty no?
12:59:58 <kallisti> timthelion: why does each update require that you create a new MVar?
13:00:14 <timthelion> kallisti: where?
13:00:25 <kallisti> in the update* functions
13:00:26 <timthelion> kallisti: ah, there, the update2 you mean
13:00:51 <timthelion> because I'm running the action in a different thread, and so to get the value out of that other thread...
13:01:06 <timthelion> kallisti: the idea, is a functional recursive model for mutable state.
13:01:13 <timthelion> using threads.
13:01:22 <timthelion> in practice, it works very well.
13:02:17 <timthelion> because I have the sync functions. and when a button in my gui gets pressed, the event just looks like "update threadObjectx (some pure code)"
13:02:31 <timthelion> and then the sync functions display the new internal state on the screen
13:02:48 * kallisti is still unsure why you need to create new MVars on each update
13:02:51 <kallisti> rather than updating the old ones
13:03:02 <timthelion> kallisti: could also do that.
13:03:24 <timthelion> I didn't yet profile it for extreme preformance.
13:05:03 <timthelion> kallisti: that still doesn't solve the problem of not having some type macro for f :: a -> b -> ... -> *
13:12:23 <parcs`> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1) `seq` ()
13:12:23 <lambdabot>   ()
13:12:59 <parcs`> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1) `seq` ()
13:12:59 <lambdabot>   A 63-tuple is too large for GHC
13:13:00 <lambdabot>    (max size is 62)
13:13:00 <lambdabot>    Workaround: use nest...
13:13:50 <nominolo> I wonder if there's a max record size
13:14:44 <nominolo> I'm pretty sure on x86 if you have a record with more than 65536 pointer fields it either breaks at compile time or at runtime
13:22:33 * kallisti thinks he can use unsafePerformIO to rewrite the futures package in a slightly different way.
13:22:50 <kallisti> while still maintaining referential transparency.
13:23:29 <kallisti> essentially instead of forkPromise :: IO a -> IO (Promise a)  you have  forkPromise :: IO a -> IO (Either SomeException a)
13:25:20 <kallisti> so the wait happens automatically when you evaluate the result of forkPromise.
13:30:07 <mekeor> did you know the keyword 'rec'? -- i just spotted it. it's a language-extension for recursive-do's.
13:30:35 <kallisti> mekeor: yep
13:33:50 * hackagebot tls 0.9.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.4 (VincentHanquez)
13:37:32 <Sgeo> I just did this in GHCi, I assume it didn't need clarification of the type of read due to sum forcing to be a Num and GHCi's defaulting?
13:37:44 <Sgeo> sum . map read . permutations $ "45678"
13:38:27 <joe-generic>  /buffer #erlang
13:42:12 <kallisti> http://hpaste.org/67302  surely these either already exists or I'm doing something horribly wrong here.
13:43:02 <mekeor> Sgeo: exactly. this is called type inference. http://en.wikipedia.org/wiki/Type_inference
13:43:36 <Sgeo> mekeor, I was just surprised about it inferring something more specific than Num a, which I think read would still complain about
13:43:50 * hackagebot tls-extra 0.4.6 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.6 (VincentHanquez)
13:43:54 <geekosaur> that's where defaulting comes in
13:44:12 <kallisti> Sgeo: it should just infer it to be Integer due to Haskell defaulting.
13:44:21 <Sgeo> Ok
13:44:32 <kallisti> (Num is a special case)
13:44:35 <frontendloader> let fn [x:y] = not a valid pattern?
13:44:42 <kallisti> it is
13:44:43 <mekeor> Sgeo: there's also the keyword "default", btw, for exactly this purpose.
13:44:46 <kallisti> but it's probably not what you mean.
13:44:48 <nart> hi
13:44:51 <c_wraith> frontendloader: it is, but it means the argument will be a list of lists
13:44:51 <kallisti> unless you ave a singleton list of lists.
13:44:55 <frontendloader> I want it to mean a list of length 2
13:45:04 <kallisti> then you want [x,y]
13:45:49 <nart> i'm trying to learn conduits & co, i don't understand why in this code http://hpaste.org/67303  if i use the conduitInfo nothing is download, while if i take it out connecting source and sink directly everything works just fine
13:45:58 <nart> *is downloaded
13:47:41 <siracusa> frontendloader: [x:y] matches on a one element list with x being some value and y a list
13:47:53 <mekeor> mm_freak: you're right, btw. "simply typed lambda calculus" requires only one type constructor: (->). see http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus , first sentence.
13:48:39 <mekeor> @let fn [(x:y)] = Nothing
13:48:41 <lambdabot>  Defined.
13:48:44 <mekeor> :t fn
13:48:44 <lambdabot> forall t a. [[t]] -> Maybe a
13:48:50 * hackagebot tls-debug 0.1.1 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.1.1 (VincentHanquez)
13:49:10 <vodik> :t undefined
13:49:11 <lambdabot> forall a. a
13:51:57 <nart> damn, it does work but the url i'm using is unreachable -.-'
13:52:26 <byorgey> mekeor: well, it requires some base type(s) too
13:52:37 <mekeor> so, wait.  has »f (_:_:xs) = xs« the same meaning as »f (__:__:xs) xs« and »f (_:__:xs) = xs« and »f (__:_:xs) = xs« ?
13:52:52 <mekeor> byorgey: oh, okay. =)
13:53:11 <byorgey> mekeor:   data Ty = Arr Ty Ty  doesn't get you very far ;)
13:53:22 <mekeor> byorgey: which?
13:54:04 <byorgey> mekeor: it doesn't really matter.  Say, ().
13:54:20 <mekeor> byorgey: it does not matter?! whuuut?
13:54:43 <byorgey> mekeor: you just church-encode everything =)
13:55:31 <bitonic> byorgey: if you just want to transform terms -> is enough
13:55:48 <bitonic> I mean lc with -> and some fixed point combinator is turing complete
13:55:54 * mekeor still has to learn tons. amongst others, http://en.wikipedia.org/wiki/Church_encoding.
13:56:01 <byorgey> bitonic: if all you have is (->) then you can't write down any finite types.
13:56:34 <bitonic> byorgey: well, -> and type variables.
13:56:45 <bitonic> -> would still be the only constructor
13:57:04 <byorgey> it depends on your definition of "constructor"
13:57:29 <bitonic> well... I wouldn't called a quantified variable a constructor
13:57:31 <byorgey> if you wanted to write them down as a Haskell data type you'd need a second constructor for type variables.
13:57:35 <mekeor> for me, a type contructor it something of kind: * -> *.
13:58:09 <acowley> The only types you need are those constructed with (->), and A. Everything else is shallow and pedantic.
13:58:11 <bitonic> byorgey: what do you mean? how many constructors appear in 'forall a. a -> a'?
13:58:29 <byorgey> bitonic: data Ty = Arr Ty Ty | Var String
13:58:31 <mekeor> byorgey: but anyway, i got your point now.
13:58:41 <bitonic> byorgey: oh well, fair enough.
13:58:51 * hackagebot iterio-server 0.3 - Library for building servers with IterIO  http://hackage.haskell.org/package/iterio-server-0.3 (AmitLevy)
13:59:04 <byorgey> anyway, I agree with everything you said
13:59:05 <bitonic> byorgey: but that's a constructor in the representation of the types. anyways I get what you mean
13:59:30 <mekeor> byorgey: you mean, if i have a 'function :: (->) a b', then a and b have to be constructed with (->), too. but (->) is the only constructor so,... we need a type/contructor that is not (->)
13:59:39 <byorgey> mekeor: right.
13:59:47 <mekeor> =)
13:59:48 <byorgey> perhaps I missed the context of the previous conversation.
13:59:55 <mekeor> nope.
14:08:51 * hackagebot dclabel 0.0.6 - The Disjunction Category Label Format  http://hackage.haskell.org/package/dclabel-0.0.6 (DeianStefan)
14:08:53 * hackagebot lio 0.1.3 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.1.3 (DeianStefan)
14:08:55 * hackagebot hails 0.1 - IFC enforcing web platform framework  http://hackage.haskell.org/package/hails-0.1 (DeianStefan)
14:08:57 * hackagebot hails-bin 0.1 - Dynamic launcher of Hails applications  http://hackage.haskell.org/package/hails-bin-0.1 (DeianStefan)
14:13:39 <parcs`> bad hackagebot
14:14:16 <mekeor> does he understand that?
14:15:04 <acowley> Why does using a constraint alias require UndecidableInstances when the manual expansion of that alias doesn't?
14:16:17 <parcs`> because ghc doesn't care about constraints when determining whether instances are undecidable
14:16:52 <acowley> but I don't see how the syntax even suggests something qualitatively different
14:17:19 <acowley> actually
14:17:22 <Saizan> parcs`: it does
14:17:29 <acowley> that can't be right, because the change I'm talking about *is* a constraint
14:17:29 <parcs`> you mean something like instance (a ~ Foo) => C a right
14:17:46 <acowley> I mean, type C a = (Foo a, Bar a)
14:17:58 <parcs`> oh
14:18:04 <acowley> now replace instance (Foo a, Bar a) => Baz (T a) where
14:18:05 <acowley> with
14:18:13 <acowley> instance C a => Baz (T a) where
14:18:28 <acowley> the change is solely in the constraint, and this raises GHC's UndecidableInstances alarm
14:18:47 <parcs`> perhaps you can make cyclic constraint aliases
14:18:49 <rwbarton> well it would have to inspect C to know that this was okay
14:18:53 * hackagebot iterIO 0.2.2 - Iteratee-based IO with pipe operators  http://hackage.haskell.org/package/iterIO-0.2.2 (AmitLevy)
14:18:57 <rwbarton> type C a = Baz' (T a) ...
14:18:58 <acowley> That's true
14:19:07 <acowley> but I thought type alias expansion happened very early
14:19:40 <parcs`> Saizan: it does? do you have an example with the constraint is significant?
14:19:58 <mm_freak> mekeor: it wasn't about simply-typed lambda calculus, but about calculus of constructions
14:20:12 <Saizan> parcs`: by "constraint" i mean even typeclass ones
14:20:19 <acowley> parcs`: the example I gave demonstrates the issue
14:20:24 <mm_freak> more core language is almost complete…  so far i'm getting along with only a single arrow type
14:20:39 <mekeor> s/more/my/ # ?
14:20:45 <Saizan> so e.g. instance F a => C a; is Undecidable, instance C a isn't
14:20:50 <mm_freak> yeah, sorry
14:20:59 <mm_freak> i will test this thoroughly, and when everything works i will start writing a compiler for it
14:21:10 <mekeor> mm_freak: wow. great work so far.. cool!
14:21:15 <parcs`> Saizan: oh okay. thanks
14:21:20 <mm_freak> right now i'm not convinced that type checking is consistent
14:25:29 <mekeor> mm_freak: so, does it have dependent-types? yes?
14:25:37 <mm_freak> yeah
14:26:37 <mekeor> mm_freak: is it possible to check whether a type is in a type-class? is it possible to write a function which gets a value and returns its type?
14:27:07 <bitonic> mekeor: well. you can get the reified type with Typeable
14:27:14 <bitonic> and no you can't check if a type is in a typeclass
14:27:35 <mekeor> bitonic: i was talking about mm_freak's prog-lang… sorry.
14:27:47 <bitonic> mekeor: oh, sorry
14:27:57 <bitonic> mekeor: but you probably can't in his lang as well!
14:28:00 <bitonic> there are good reasons for that
14:28:41 <mekeor> bitonic: namely? (i suppose this question was predictable.)
14:29:15 <bitonic> mekeor: you break parametricity
14:29:33 <bitonic> the fact that you know that a function can't do much with a polymorphic type (in very poor words)
14:30:02 <mekeor> hmm... interesting. cool. thanks so far.
14:30:34 <mekeor> bitonic: lol: quote from wikipedia: "The principle of parametricity dictates that functions with similar types have similar properties."
14:30:58 <bitonic> mekeor: yeah
14:31:42 <bitonic> @where theorems.for.free
14:31:42 <lambdabot> I know nothing about theorems.for.free.
14:31:45 <bitonic> mh.
14:31:51 <bitonic> @google theorems for free
14:31:55 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
14:31:55 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract From t ...
14:32:16 <bitonic> @where+ theorems.for.free http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
14:32:17 <lambdabot> Good to know.
14:38:54 * hackagebot hails 0.1.1 - IFC enforcing web platform framework  http://hackage.haskell.org/package/hails-0.1.1 (DeianStefan)
14:45:53 <stulli> quicksilver:
14:46:26 <stulli> ups, accidental tab completion
14:48:36 <mm_freak> mekeor: as for haskell type information will be lost after compilation
14:49:07 <mm_freak> so to reify the type you will need special functionality for that
14:49:31 <mm_freak> like a "type class" (the core language won't have type classes, but you can always emulate them using a type)
14:50:13 <mm_freak> it's great stuff…  my core language type has only four constructors and is a full dependently typed language =)
14:50:22 <gentleben> Hi, is there a way to specify a field as optional using arson's TH stuff?
14:51:01 <bitonic> gentleben: you mean aeson?
14:51:17 <gentleben> yeah, stupid auto correct
14:52:14 <gentleben> the generated code calls lookupField which needs the field to be in the schema
14:59:06 <mm_freak> yeehaa…  my core language evaluates arithmetic expressions =)
14:59:32 <mm_freak> byorgey: i'm coming to the conclusion that you really don't need a separate Pi construct
15:03:20 <acowley> mm_freak: are you just using your dependent arrow type in place of it?
15:05:10 <osa1> what is the `->` function described in "learn you a haskell"? http://learnyouahaskell.com/functors-applicative-functors-and-monoids it looks like -> isn't a acceptable function name
15:06:44 <rwbarton> it's not a function
15:07:29 <rwbarton> -> is several things
15:08:44 <mm_freak> acowley: yeah
15:08:56 <mm_freak> hmm
15:12:03 <monochrom> consider this question: in "haskell", what does "s" mean?
15:12:14 <acowley> Geese Louise, I just wrote "<>" when defining a Monoid instance, got an error, replaced it with `mplus`, got an error, finally wrote mappend …. twice!
15:13:03 <monochrom> I heard that <> may be accepted in the future
15:13:19 <acowley> monochrom: that would be awesome!
15:13:37 <acowley> It kind of stinks writing it one way in the instance and differently everywhere else.
15:13:38 <monochrom> as usual, it will take 10 years of debates
15:13:42 <acowley> :(
15:13:45 <acowley> what's to debate?
15:14:14 <monochrom> "someone out there may have already used <> for another thing"
15:14:33 <acowley> Would having them both be class methods defined in terms of each other be offering too much of a foot-shooting window?
15:14:39 <monochrom> "I don't like <>, I prefer <+>", etc
15:14:52 <bitonic> wait, isn't <> already in?
15:14:53 <acowley> Well I figured that <> making it into base put an end to that
15:15:08 <acowley> bitonic: it's just a function, so when defining an instance you have to write mappend
15:15:10 <bitonic> yeah, it is
15:15:14 <bitonic> acowley: yep
15:15:29 <bitonic> monochrom: it's in base, it's ok! ehe
15:15:32 <lispy> > let (->) = (+) in 1 -> 2
15:15:33 <lambdabot>   <no location info>: parse error on input `->'
15:15:44 <lispy> > let (->) = (+) in (->) 1 2
15:15:44 <lambdabot>   <no location info>: parse error on input `->'
15:16:08 <lispy> looks to me like it's no good as a function name (makes sense, it's a type constructor)
15:16:25 <monochrom> but yes, if two names for the same thing are accepted, it is best to admit them both as methods, with a cyclic default implementation
15:16:34 <bitonic> > let (-->) = (+) = 1 --> 2
15:16:35 <lambdabot>   <no location info>: parse error on input `='
15:16:40 <bitonic> > let (-->) = (+) in 1 --> 2
15:16:41 <lambdabot>   3
15:17:08 <bitonic> > let (−>) = (+) in 1 −> 2
15:17:09 <lambdabot>   3
15:17:10 <bitonic> ehe.
15:17:22 <lispy> > case Just 1 of { Nothing -> 1; Just x -> x } -- another reason whyit doesn't work as a function name
15:17:23 <lambdabot>   1
15:17:34 <lispy> bitonic: hmm
15:17:43 <lispy> bitonic: whot did you do differently than me?
15:18:12 <bitonic> lispy: magic
15:18:18 <lispy> unicode magic?
15:18:20 <acowley> bitonic has fancy dashes
15:18:59 <bitonic> > let (→) = (+) in 1 → 2
15:19:00 <lambdabot>   <no location info>: parse error on input `
15:19:03 <bitonic> good.
15:20:20 <monochrom> oh yeah, you weak people with your fixed width fonts can't distinguish - – —
15:20:25 <hayashi> let (+) = \x y -> x + y + 1 in 2 + 2
15:20:26 <gabor> I probably should ask this on SO, but is there a technique "weaving a grid" similar to "tying a knot", i.e. constructing a torus (2-dimensionally) out of nodes with 4 valences?
15:20:27 <hayashi> d
15:20:30 <hayashi> > let (+) = \x y -> x + y + 1 in 2 + 2
15:20:35 <hayashi> oh wait
15:20:40 <hayashi> that's not going to work out
15:20:41 <lambdabot>   mueval: ExitFailure 1
15:20:42 <lambdabot>  mueval: Prelude.undefined
15:20:45 <shachaf> @remember elliott <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go from category theory to unboxed types and unsafeCoerce in a single line of IRC.
15:20:45 <lambdabot> It is stored.
15:21:11 <hayashi> > let (+) = (\x y -> 5) in 2 + 2
15:21:16 <lambdabot>   mueval-core: Time limit exceeded
15:21:18 <hayashi> Aw.
15:22:24 <monochrom> try again, time limit detection is not robust
15:25:13 <edwardk> shachaf: hah
15:26:59 <parcs`> edwardk: what is the name of your reification package?
15:27:04 <parcs`> i tried to find it but failed
15:27:07 <edwardk> reflection
15:27:17 <parcs`> oh right
15:27:41 <acowley> I think the Elsevier boycott is leading to me getting more review requests.
15:28:23 * edwardk continues his boycott of the entire academic publishing community through sheer disinterest ;)
15:29:04 <acowley> edwardk: your tenure review committee will not be amused!
15:29:29 <acowley> They published on stone tablets when they were your age, so, by gum, you better do the same!
15:29:40 <parcs`> acowley: you are a professor?
15:29:59 <acowley> Also, we must always wear our robe and wizard hats.
15:30:07 <acowley> parcs`: No!
15:30:14 <acowley> parcs`: I am the grist in the mill
15:31:06 * parcs` doesn't know what that means; assumes acowley is a professor
15:31:18 <acowley> grad. student
15:31:49 <parcs`> ah
15:33:07 <hpc> thank god he left
15:33:15 <hpc> i can't believe they let a lowly grad student in the channel
15:33:17 <hpc> ;)
15:33:31 <dmwit> shirt: I'm not sure. pseq is safer
15:33:45 <dmwit> ?unmtl StateT s [] a
15:33:45 <lambdabot> s -> [(a, s)]
15:34:19 <dmwit> I suppose s -> ([a], s) is the one that's not really correct, huh?
15:34:36 <hpc> dmwit: yeah, that's State s [a]
15:34:45 <dmwit> ?unmtl ListT (State s) a
15:34:45 <lambdabot> s -> ([a], s)
15:35:26 <dmwit> hpc: Eh, I think (>>=) isn't the same for ListT (State s) a and State s [a].
15:35:38 <dmwit> I mean, it doesn't even have the same type.
15:35:42 <hpc> ListT (State s) isn't a monad, so almost certainly :P
15:35:54 <dmwit> yeah =/
15:35:56 <hpc> @unmtl State s [a]
15:35:57 <lambdabot> s -> ([a], s)
15:36:04 <dmwit> Ah, well, who cares about efficiency, eh? =D
15:36:18 <DijkstraGroupie> One question. Is it possible to bring lambdabot to ##programming?
15:36:58 <dmwit> ?help join
15:36:58 <lambdabot> join <channel>
15:37:10 <mm_freak> i'm trying to find the simplest way to implement pattern matching in a dependently typed core language:  my idea is to implement it as a two-way lambda…  what do you think?
15:37:11 <hpc> DijkstraGroupie: it's possible, but lambdabot can only be invited by someone with the right superpowers i think
15:37:13 <dmwit> You probably need the agreement of at least one lambdabot operator, though.
15:37:26 <DijkstraGroupie> hpc: Oh, okay!
15:37:41 <shachaf> You don't *need* the agreement of anybody... But it might be polite. :-)
15:37:43 <dmwit> mm_freak: My understanding is that there is no simple way to implement pattern matching in dependently typed languages.
15:38:03 <ion> Let’s bring lambdabot to #php.
15:38:11 <dmwit> ?join #dmwit-is-awesome
15:38:12 <lambdabot> Not enough privileges
15:38:13 <shachaf> @listchans
15:38:13 <lambdabot> ##freebsd ##logic ##math ##proggit ##villagegreen #agda #arch-haskell #darcs #esoteric #fedora-haskell #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #happs #haskell #haskell-blah #
15:38:13 <lambdabot> haskell-books #haskell-br #haskell-fr #haskell-freebsd #haskell-in-depth #haskell-overflow #haskell-pl #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.hr #haskell.se #learnanycomputerlanguag
15:38:13 <lambdabot> e #macosx #macosxdev #rosettacode #scala #scalaz #scannedinavian #tanuki #teamunix #unicycling #uscs2010 #xmonad #yi weird#
15:38:18 <dmwit> shachaf: You are wrong, it seems.
15:38:24 <c_wraith> unicycling?
15:38:29 <hpc> haha #functionaljava
15:38:30 <c_wraith> lambdabot unicycles?
15:38:45 <ion> “@@ @leave @listchans”
15:38:54 <shachaf> dmwit: lambdabot and security do not really mix.
15:38:59 <shirt> dmwit: ok thanks. i think i'll take my chances with regular seq though. seems to work.
15:39:28 <dmwit> mm
15:40:02 <dmwit> :t lift
15:40:02 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:41:39 <mm_freak> dmwit: could you elaborate?
15:46:16 <kallisti> @hoogle for
15:46:18 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
15:46:18 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
15:46:18 <lambdabot> Foreign module Foreign
15:47:31 <osa1> what is the "streaming data problem" mentioned in conduit package documentation? where can I learn about it?
15:50:14 <arnoldas> is it possible to learn haskell in few (say 3) weeks?
15:50:51 <arnoldas> nor completely the whole thing, just the basics, so you can program binary trees etc.
15:51:01 <ion> is it possible to learn haskell in a few (say 3) years?
15:51:30 <copumpkin> I feel pretty comfortable in haskell after three years
15:51:43 <c_wraith> You can learn enough haskell to build a binary tree in a few hours.
15:52:04 <shachaf> After three years, copumpkin can program binary trees so well that each node has three children.
15:52:15 <arnoldas> xD
15:52:16 <copumpkin> I've even done four before
15:52:22 <copumpkin> five is impossible
15:52:24 <ion> Blasphemy
15:52:36 <copumpkin> it's like solving nth-degree polynomials
15:52:47 <arnoldas> c_wraith can you teach me? xD
15:52:49 <shachaf> copumpkin: It's like giving someone the dola you promised them.
15:52:55 <ion> arnoldas:
15:52:55 * copumpkin kicks shachaf 
15:52:57 <ion> @where lyah
15:52:58 <lambdabot> http://www.learnyouahaskell.com/
15:53:06 <c_wraith> I once had a homework assignment to factor a 57th-degree polynomial.  That was fun
15:53:26 <Ke> x^57
15:55:08 <arnoldas> I think I can't even read the tutorial mentioned above in few hours, how you thin is it possible to learn haskell in that time
15:56:39 <arnoldas> I mean you can't understand everything in the same second you read it, especially new paradigm (new for me) like functional programming
15:56:47 <c_wraith> arnoldas: the thing is, binary trees are very simple. You don't need to know much about haskell to implement them.
15:57:04 <ion> My binary trees have two children, a wife, a car and a mortgage.
15:57:53 <companion_cube> is that to say that all binary trees are male?
15:58:26 <hpc> the root of the tree has no parents
15:58:34 <hpc> it's the data structure gotham deserves
15:58:39 <hpc> but not the one it needs right now
15:58:45 <arnoldas> c_wraith: may be, but you need everything else, haskell offers if you want to manipulate them, right?
16:01:17 <c_wraith> arnoldas: not at all. A binary tree implementation that includes add, remove, and find doesn't need huge parts of the language.  Like everything about IO.
16:02:47 <scooty-puff> when you create a new bug on ghc, do you just "leave as new"?
16:03:13 <scooty-puff> if only just reporting a bug, not providing a solution or anything like that
16:03:17 <lispy> scooty-puff: I don't change the default status
16:03:35 <lispy> scooty-puff: I leave that for the GHC team
16:06:59 <scooty-puff> k
16:08:19 <dmwit> mm_freak: Sorry, I'm not an expert. But here's my cargo-cult answer: large eliminations cause all kinds of problems with type preservation.
16:08:48 <dmwit> I don't have enough details in my head to elaborate further than that, I'm afraid.
16:09:20 <luite> are there closure serialization implementations that still work with recent ghc versions?
16:09:46 <kallisti> > head [undefined] `seq` ()
16:09:47 <lambdabot>   *Exception: Prelude.undefined
16:10:11 <kallisti> hm
16:10:21 <kallisti> is there a lazy head?
16:10:27 <kallisti> that would just be a lazy pattern yes?
16:10:59 <c_wraith> head *is* lazy
16:11:09 <c_wraith> that's directly related to why it's unsafe
16:11:51 <rwbarton> what? head is strict
16:11:57 <rwbarton> "lazy head" makes no sense
16:12:04 <lispy> Yeah, head has to check that the first element is a cons
16:12:06 <kallisti> [a] -> a without forcing a
16:12:25 <rwbarton> you can't not force your return value because by assumption your return value is being evaluated if you are being evaluated
16:12:27 <lispy> ?src head
16:12:27 <lambdabot> head (x:_) = x
16:12:27 <lambdabot> head []    = undefined
16:12:33 <rwbarton> you could wrap it in a box
16:12:53 <conal> kallisti: head doesn't force evaluation of the head. only of the top-level cons
16:12:54 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:13:07 <kallisti> conal: oh, it was seq that forced the head.
16:13:08 <rwbarton> but evaluating "head xs" evaluates the head of xs
16:13:14 <lispy> kallisti: the problem with the test you just did is that it has to evaluate the undefined.
16:13:15 <kallisti> yes
16:13:15 <rwbarton> because that's what head xs is
16:13:20 <kallisti> right
16:13:25 <rwbarton> ok
16:14:06 <rwbarton> If you define data Box a = Box a and head (x:xs) = Box x; head [] = undefined then you can "test" whether the list is empty without evaluating its first element
16:14:56 <rwbarton> which could conceivably be useful if you want to GC a list before evaluating its first element, I suppose.
16:16:47 <dmwit> ?unmtl StateT s (WriterT c []) a
16:16:48 <lambdabot> s -> [(a, s, c)]
16:17:33 <dmwit> ?unmtl WriterT c [] a
16:17:33 <lambdabot> [(a, c)]
16:17:43 <dmwit> :t lift
16:17:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
16:17:48 <dmwit> hum
16:17:50 <dmwit> magic
16:18:23 <kallisti> dmwit: neat
16:18:36 <kallisti> it apparently flattens tuples. I wonder what it's actually doing there.
16:18:54 <rwbarton> oh weird, yeah
16:19:26 <dmwit> I think ?unmtl is just wrong, maybe?
16:19:50 <kallisti> it's not really wrong. that's probably the nicest representation.
16:20:01 <kallisti> using Prelude stuff, or whatever.
16:20:42 <dmwit> ?hoogle [(a, c)] -> Writer c a
16:20:43 <lambdabot> Control.Monad.Trans.Writer.Lazy writer :: (a, w) -> Writer w a
16:20:43 <lambdabot> Control.Monad.Trans.Writer.Strict writer :: (a, w) -> Writer w a
16:20:43 <lambdabot> Control.Monad.Writer.Lazy writer :: (a, w) -> Writer w a
16:21:34 <dmwit> oh
16:21:44 <dmwit> ?hoogle [(a,c)] -> WriterT c [] a
16:21:44 <lambdabot> Did you mean: [(a, c)] -> WriterT c [a] a
16:21:44 <lambdabot> Control.Monad.Trans.Writer.Lazy WriterT :: m (a, w) -> WriterT w m a
16:21:45 <lambdabot> Control.Monad.Trans.Writer.Strict WriterT :: m (a, w) -> WriterT w m a
16:22:22 <nyingen> I'm using the ghci debugger to set a breakpoint on one of my functions. I want to inspect the function's arguments. But no variables other than _result are shown when ghci hits the breakpoint
16:22:28 <nyingen> why is this?
16:23:05 <kallisti> futures and promises are synonyms, right?
16:23:20 <kallisti> I'm pretty sure they, but I might as well double check.
16:23:23 <kallisti> +are
16:29:52 <dmwit> nyingen: You may have to :step a bit to bring them into scope.
16:33:50 <nyingen> dmwit: ah, thanks. I also found something interesting about this in an issue of the Monad Reader, regarding the way ghci searches for free variables
16:34:30 <s0ro> kallisti: futures and promises are more or less synonyms but sometimes have different semantics, depending on the library
17:02:24 <nks> :t map (*2) (filter (>5) [ 1, 5 ,9]) returns :: (Ord b, Num b) => [b]
17:02:25 <lambdabot> Not in scope: `returns'
17:02:30 <nks> what does the output mean ?
17:02:59 <hpc> nks: it means it returns a list of things of type 'b'
17:03:02 <nks> Can some one help with understanding hte output please ?
17:03:09 <hpc> 'b' can be anything, as long as it's a number that has some kind or ordering
17:03:27 <hpc> *as long as it's a numeric type that has
17:03:38 <hpc> so it can be Int, Double, etc
17:03:45 <hpc> but not Complex Double
17:03:59 <hpc> you can't really compare one complex number to another and get "greater than / less than"
17:04:01 * hackagebot unsafe-promises 0.0 - Create pure futures using lazy IO.  http://hackage.haskell.org/package/unsafe-promises-0.0 (AdamCurtis)
17:04:14 <nks> ok, thanks
17:04:25 <shirt> is there a way to check if a value is fully evaluated (no nested unevaluated thunks) ?
17:04:27 <hpc> :t 5
17:04:28 <lambdabot> forall t. (Num t) => t
17:04:30 <hpc> :t (*)
17:04:31 <lambdabot> forall a. (Num a) => a -> a -> a
17:04:34 <hpc> :t (<)
17:04:35 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:05:18 <hpc> nks: Num and Ord are type classes
17:05:25 <hpc> LYAH covers them in chapter 4 or something
17:11:19 <DanielDiaz> What can I do with an error like "HSnetwork-2.3.0.11.o: unknown symbol `_acceptNewSock`"? It appears each time I try to use the network library. :(
17:11:49 <DanielDiaz> I already tried --reinstall
17:12:05 <monochrom> your ghc command is like "ghc --make etc"?
17:12:06 <c_wraith> DanielDiaz: are you compiling with --make ?
17:13:41 <DanielDiaz> Not, in GHCi. But with --make I got a lot of errors of "unknown symbol".
17:14:18 <monochrom> ghci doesn't need "--make", that's fine
17:16:18 <DanielDiaz> monochrom: I mean: In GHCi I get only one "unknown symbol" error, but with "ghc --make" I get a lot of them.
17:16:47 <monochrom> I get 0 errors both ways
17:17:40 <DanielDiaz> monochrom: yes. In fact, in my other computer I don't have this issue.
17:20:13 <serialhex> hey all, i'm fairly new to haskell, and as a non-trivial exercise i'm trying to implement surreal numbers in haskell, though i'm having a hell of a time getting the *base* data structure down...  anyone have any ideas?  code thus far: https://gist.github.com/2424975
17:20:19 * kallisti wonders if adding unsafe to unsafe-promises is unnecessarily scary.
17:20:43 <kallisti> too late now! :P
17:21:17 <serialhex> kallisti: what would be an unsafe-promise? `i promise not to get you pregnant?`
17:21:23 <rwbarton> serialhex: i think it should just be   data Surreal = Zero | (Set.Set Surreal) `Surreal` (Set.Set Surreal)
17:21:24 <serialhex> :P
17:21:34 <c_wraith> serialhex: you can't specify values in the arguments to a data constructor.  You can only specify *types*
17:21:37 <kallisti> serialhex: you can't put Set.emptye there
17:21:46 <serialhex> ahh, ok
17:21:48 <rwbarton> also you don't need a separate Zero constructor
17:22:02 <rwbarton> or those parentheses I wrote
17:22:11 <c_wraith> I'm not sure you need the l and r type parameters, iether
17:22:14 <rwbarton> so just   data Surreal = Set.Set Surreal `Surreal` Set.Set Surreal
17:22:16 <kallisti> serialhex: heh. part of the reasoning was that unsafe-promises is a good name. :D
17:22:54 <kallisti> I also considered lazy-promises, but promises are kind of implicitly lazy.
17:23:06 <serialhex> ok cool... i'll give it a whirl, thanks rwbarton & kallisti
17:23:34 <mtbeedee> is there a way to do an intersection of two lists by some function?
17:23:39 <serialhex> very true kallisti... `i promise to do X (eventually...)`
17:23:46 <kallisti> :t intersect
17:23:47 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:23:49 <kallisti> mtbeedee: yep!
17:24:01 <mtbeedee> specifically, I have a list of strings and a smaller list of strings and I want to use the smaller one like a filter...
17:24:20 <kallisti> > intersect [1,2,3,4,5] [1,2,6]
17:24:21 <mtbeedee> if any of the strings in the longer list contains all of the smaller ones, then return it
17:24:22 <lambdabot>   [1,2]
17:24:46 <mtbeedee> but by a specific function
17:24:48 <mtbeedee> like...
17:24:48 <kallisti> mtbeedee: "contain all of the smaller ones"
17:24:49 <kallisti> how so
17:25:00 <mtbeedee> say...
17:25:04 <mtbeedee> a=["a","b","c","ab","ac","bc","abc"]
17:25:08 <mtbeedee> b=["a","b"]
17:25:14 <mtbeedee> the "intersection" would return all of them except c
17:25:20 <kallisti> ah
17:25:22 <mtbeedee> wait
17:25:26 <kallisti> :t intersectBy
17:25:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
17:25:29 <TSC> not "ac" either?
17:25:29 <mtbeedee> it would return only the ones that have a and b
17:25:40 <mtbeedee> "a" and "b"
17:25:42 <mtbeedee> so
17:25:48 <mtbeedee> not a, b, c, ac, or ab
17:25:50 <mtbeedee> or bc
17:25:52 <kallisti> > intersectBy isInfixOf ["a","b","c","ab","ac","bc","abc"] ["a","b"]
17:25:54 <lambdabot>   ["a","b"]
17:26:01 <kallisti> hm
17:26:04 <TSC> I reckon filter + all + isInfixOf should do it
17:26:16 <kallisti> > intersectBy isInfixOf ["a", "b"] ["a","b","c","ab","ac","bc","abc"]
17:26:17 <lambdabot>   ["a","b"]
17:26:24 <kallisti> er, yeah don't use intersectBy
17:26:26 <kallisti> just use filter.
17:26:29 <mtbeedee> yea, I tried that already
17:26:34 <mtbeedee> filter, eg?
17:26:35 <kallisti> actually use all
17:26:35 <mtbeedee> e
17:26:41 <mtbeedee> what's this "all"?
17:26:49 <TSC> @type all
17:26:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:27:16 <kallisti> actually any
17:27:17 <kallisti> :t any
17:27:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:27:45 <monochrom> > all (0 ==) [3,1,4,0,2]
17:27:46 <lambdabot>   False
17:27:50 <monochrom> > any (0 ==) [3,1,4,0,2]
17:27:51 <lambdabot>   True
17:27:56 <kallisti> filter (\x -> any (`isInfixOf` x) ["a", "b"]) ["a", "b", "c", "ab", "ac", "bc", "abc"]
17:27:59 <kallisti> > filter (\x -> any (`isInfixOf` x) ["a", "b"]) ["a", "b", "c", "ab", "ac", "bc", "abc"]
17:28:00 <lambdabot>   ["a","b","ab","ac","bc","abc"]
17:28:02 <monochrom> is the meaning of all and any
17:28:13 <TSC> > filter (\y -> all (`isInfixOf` y) ["a", "b"]) ["a","b","c","ab","ac","bc","abc", "acb"]
17:28:14 <lambdabot>   ["ab","abc","acb"]
17:28:38 <mtbeedee> hmm
17:29:38 <mtbeedee> I didnt know about this "all" function
17:29:39 <mtbeedee> awesome
17:30:23 <mtbeedee> why do you need the backquotes on the isInfixOf?
17:30:48 <TSC> To use it as an infix operator
17:31:18 <TSC> > "ab" `isInfixOf` "eabc" && isInfixOf "ab" "eabc"
17:31:19 <lambdabot>   True
17:31:45 <Rotaerk> that's not a good name for that function imo
17:31:46 <mtbeedee> but why does it need to be infix?  calling it like "isInfixOf a b" works too?
17:31:52 <TSC> Yes
17:32:00 <TSC> It's only for style
17:32:08 <TSC> It reads more like a sentence
17:32:09 <Rotaerk> "isInfixOf a b" reads like a is an infix of b
17:32:12 <Rotaerk> not vice versa
17:32:29 <mtbeedee> filter (\y -> all (isInfixOf y) ["a", "b"]) ["a","b","c","ab","ac","bc","abc", "acb"]
17:32:44 <TSC> To do it that way you need to flip
17:32:56 <rwbarton> or write \x -> isInfixOf x y
17:33:05 <TSC> Because you want y to be the second argument to isInfixOf
17:33:29 <mtbeedee> ooooh I get it
17:33:30 <mtbeedee> ok
17:33:47 <monochrom> "f x y" reads like reverse Japanese, "x `f` y" has some chance of reading like European languages
17:33:59 <ion> Japanese is RPN?
17:34:10 <monochrom> yeah, subject object verb
17:34:17 <ion> cool
17:34:54 <mtbeedee> so wait
17:34:58 <mtbeedee> the other way would be like...
17:35:06 <mtbeedee> filter (\y -> all (isInfixOf y) a) b
17:35:07 <mtbeedee> or
17:35:09 <monochrom> Korean too
17:37:19 <monochrom> (`f` y) is (\z -> f z y)
17:38:07 <monochrom> I guess you want to see more steps. (`f` y) = (\z -> z `f` y) = (\z -> f z y)
17:38:47 <monochrom> just like (/ 4) = (\z -> z / 4) = (\z -> (/) z 4)
17:39:22 <shachaf> And (- 4) = (\z -> z - 4) = (\z -> (-) z 4)
17:39:30 <shachaf> Haskell is a very simple language, all in all.
17:40:20 <mm_freak> dmwit: thanks for your effort anyway
17:40:33 <TSC> Isn't - the exception there?
17:40:37 <mtbeedee> so your thing... filter (\y -> all (`isInfixOf` y) ["a", "b"]) ["a","b","c","ab","ac","bc","abc", "acb"]
17:40:57 <mtbeedee> curries isInfixOf against y which comes from that first list
17:41:11 <mtbeedee> and calls it y (lambda) which is curried itself and applied to the second list
17:41:47 <shachaf> TSC: It is.
17:42:16 <TSC> Yeah, so unrolling the all you get the filter predicate as   \y -> "a" `isInfixOf` y && "b" `isInfixOf` y
17:46:24 <mtbeedee> so...
17:46:25 <mtbeedee> [ x | x <- a, (\y -> all (`isInfixOf` y) b) x ]
17:46:30 <mtbeedee> where a is the longer list and b the shorter
17:46:42 <mtbeedee> in list comprehension form
17:46:47 <c_wraith> that's...  indirect
17:46:55 <c_wraith> why not just apply that lambda?
17:47:13 <c_wraith> [ x | x <- a, all (`isInfixOf` x) b ]
17:47:14 <mtbeedee> I am trying to do it differently so I understand what's going on
17:47:20 <mtbeedee> oh
17:47:40 <mm_freak> wow, pattern matching is harder than i thought
17:48:00 <kallisti> mm_freak: lol?
17:48:22 <mm_freak> kallisti: i'm writing a dependently typed language
17:48:29 <kallisti> oh
17:48:34 <kallisti> you mean implementation. :P
17:48:38 <mm_freak> yeah
17:48:59 <wli> I often wish for variant unions.
17:49:10 <JoeyA> Bah, GHC 6.6 doesn't work on Windows 95 after all.  Missing export InitializeCriticalSectionAndSpinCount (according to the MSDN docs, that was introduced in Windows XP).
17:49:54 <nks> Is there a way in ghci command line to see all the keywords of haskell
17:50:05 <monochrom> no
17:51:02 <nks> thanks
17:51:05 <JoeyA> What's that thing you can use to display types of declarations in a module?  I thought it was :explore
17:51:08 <kallisti> nks: you could make a package whose sole export is a list of Haskell keywords, then upload it to Hackage, then cabal install, then import it in ghci, then use the export.
17:51:12 <mm_freak> nks: you can view all symbols a module exports
17:51:12 <kallisti> :)
17:51:18 <mm_freak> nks: see :browse
17:51:18 <monochrom>  :browse
17:51:27 <JoeyA> Ah
17:51:28 <mm_freak> for keywords you should look into the language report
17:51:29 <Grayshen> What does "non-exhaustive patterns in function pack" mean?
17:51:39 <kallisti> it means you didn't cover every case.
17:51:58 <Grayshen> thnx
17:52:20 <kallisti> Grayshen: if that case ever happens, you get a runtime error.
17:54:04 <nks> kallisti: Just started learning haskell, it will be a while before I figure out a way create a package
17:54:44 <kallisti> nks: well I was mostly joking. But you could. :P
17:55:02 <kallisti> there's probably already a list of them somewhere on Hackage.
17:55:15 <kallisti> I'd guess either in the Template Haskell stuff or some kind of Haskell parsing lib.
17:56:07 <nks> :) , Thanks
17:56:59 <JoeyA> let in where do if then else case module type newtype data  <-- I think that's all of them.  Let me know if I missed any.
17:57:18 <JoeyA> import
17:57:25 <kallisti> instance
17:57:28 <JoeyA> clas
17:57:31 <JoeyA> class*
17:57:41 <rwbarton> default
17:57:42 <JoeyA> Don't count extension-requiring keywords like forall
17:57:56 <JoeyA> of
17:58:05 <rwbarton> deriving?
17:58:10 <JoeyA> Yep, that's in there
17:58:15 <kallisti> > let deriving = 2 in deriving
17:58:16 <lambdabot>   <no location info>: parse error on input `deriving'
17:58:21 <rwbarton> I know 'as' isn't
17:58:30 <JoeyA> But "deriving" is not behind the green glass doors.
17:58:32 <rwbarton> even though it is part of import syntax, so I wasn't sure
17:58:47 <JoeyA> "as" isn't a keyword???
17:58:52 <rwbarton> > let as = 2 in as
17:58:53 <lambdabot>   2
17:58:58 <JoeyA> Ah
17:59:02 <JoeyA> As in as, bs
17:59:04 <rwbarton> > let qualified = 2 in qualified
17:59:04 <kallisti> yeah that would actually break a lot of code.
17:59:05 <lambdabot>   2
17:59:15 <rwbarton> > let default = 2 in default
17:59:16 <lambdabot>   <no location info>: parse error on input `default'
17:59:17 <JoeyA> Heh
17:59:17 <ion> > let ass = [[2]] in ass
17:59:18 <lambdabot>   [[2]]
17:59:23 <kallisti> because (a:as) = ls
17:59:51 * kallisti isn't sure why deriving is a keyword.
18:00:06 <JoeyA> > let qualified as deriving = \let' -> let' as
18:00:07 <lambdabot>   <no location info>: parse error on input `deriving'
18:00:32 <rwbarton> I guess it needs to be because it would also be valid as a type variable
18:00:33 <JoeyA> Okey dokey, so there's no straight answer to "what are all the keywords in Haskell"
18:00:42 <kallisti> rwbarton: ah yes
18:00:49 <geekosaur> yeh, seems to me the usual deriving clause could be a tyoe variable otherwise
18:01:11 <kallisti> > let import = 2 in import
18:01:12 <lambdabot>   <no location info>: parse error on input `import'
18:01:15 <kallisti> heh
18:01:19 <kallisti> who knows!
18:01:22 <kallisti> it may have worked.
18:01:36 <kallisti> looks unambiguous to me.
18:01:52 <kallisti> import :: a -> a   -- on the other hand...
18:02:14 <rwbarton> import Prelude -- is this the start of the definition of a function 'import'
18:02:51 <kallisti> > let of = 2 in of
18:02:52 <lambdabot>   <no location info>: parse error on input `of'
18:02:55 <JoeyA> Well, GHC 7.8 is going to have local module imports that use the "let import" syntax... in my dreams.
18:03:32 <geekosaur> "import qualified Foo as F\n  | case qualified of ..."
18:03:33 <wli> Applicative functors might be nice..
18:03:36 <kallisti> I don't know how much use that would get.
18:03:52 <geekosaur> so yeh, having it be a keyword is a good idea
18:04:05 <kallisti> one thing that would be nice is local extension pragmas. similar to what perl allows you to do with use pragmas.
18:04:09 <kallisti> I don't know how feasible it is, though.
18:05:13 <JoeyA> OCaml allows local module imports.  The latest version even provides a concise syntax for it: ModuleName.(... arbitrary expression ...)
18:06:07 <kallisti> (qualified ModuleName as M (a, b, c)).(... arbitrary expression ...)
18:06:08 <kallisti> oh god..
18:07:17 <JoeyA> That is almost valid Haskell syntax
18:07:26 <JoeyA> > (qualified ModuleName as M (a, b, c)).((... arbitrary expression) ...)
18:07:27 <lambdabot>   Not in scope: `qualified'Not in scope: data constructor `ModuleName'Not in ...
18:07:35 <JoeyA> See?  :-)
18:07:48 <kallisti> syntax-wise, local LANGUAGE pragmas could be accomplishes by putting them above whatever function they take effect. That's consistent with the way they currently work; being placed above the module declaration makes them take effect in the whole module.
18:08:28 * kallisti revokes his typing license.
18:08:46 <elliott> That would only work for trivial extensions.
18:09:11 <kallisti> it would only be easy to implement for trivial extensions, yes.
18:13:51 <JoeyA> Would it work for {-# LANGUAGE LocalLanguagePragmas #-} ?  :-)
18:26:35 <adnauseam> alo, in [ n | x <- [2..n-1], n `mod` x == 0 ], what's the state of x in n `mod` x ?
18:26:56 <elliott> the... state?
18:27:02 <adnauseam> is n `mod` x carried out over all of x ?
18:27:03 <elliott> it's each element of the list in order
18:27:09 <elliott> it's equivalent to
18:27:19 <elliott> filter (\x -> n `mod` x == 0) [2..n-1]
18:27:23 <adnauseam> what's x like, what happens to it, is it an iteration ?
18:27:25 <elliott> erm
18:27:30 <elliott> map (\_ -> n) (filter (\x -> n `mod` x == 0) [2..n-1])
18:27:44 <elliott> (are you sure you don't mean [ x | ... ]?)
18:28:10 <adnauseam> bar n = [ n | x <- [2..n-1], n `mod` x == 0 ]
18:28:39 <adnauseam> will produce a list of n's, numbering the elements in x,or []
18:28:55 <adnauseam> i'm trying to understand how n `mod` x works
18:29:12 <adnauseam> since x is a list of numbers [2..n-1]
18:29:13 <kallisti> it's the remainder of dividing those 2 numbers
18:29:19 <kallisti> no
18:29:24 <kallisti> x is an element from the list of numbers
18:29:34 <adnauseam> which element though:o
18:29:37 <kallisti> (all of them, to be more specific)
18:29:49 <adnauseam> o_0
18:29:51 <adnauseam> all of them ?
18:29:57 <kallisti> > [x+1 | x<-[1,2,3]]
18:29:58 <lambdabot>   [2,3,4]
18:29:59 <kallisti> yes
18:30:07 <rwbarton> but not all at the same time
18:30:13 <causative> what's that programming languages oriented forum?
18:30:17 <JoeyA> > let bar n = [ n | x <- [2..n-1], n `mod` x == 0 ] in bar 20
18:30:18 <lambdabot>   [20,20,20,20]
18:30:22 <causative> the good one
18:30:28 <adnauseam> aye, but then where does it stop
18:30:36 <rwbarton> lambda the ultimate?
18:30:38 <JoeyA> lambdatheultimate.org?
18:30:38 <adnauseam> if it's on all numbers
18:30:40 <causative> ah that's it
18:30:41 <causative> thanks
18:30:45 <kallisti> adnauseam: all the elements of the list
18:30:48 <kallisti> it stops.. when the list stops
18:30:50 <adnauseam> since it does stop on say, 3
18:30:53 <adnauseam> and 11
18:30:53 <JoeyA> Err, http://lambda-the-ultimate.org/
18:31:04 <adnauseam> but then not on 20 for example, which 11 is a part of
18:31:26 <adnauseam> > let bar n = [ n | x <- [2..n-1], n `mod` x == 0 ] in bar 11
18:31:27 <lambdabot>   []
18:31:30 <adnauseam> > let bar n = [ n | x <- [2..n-1], n `mod` x == 0 ] in bar 20
18:31:31 <lambdabot>   [20,20,20,20]
18:32:06 <adnauseam> see, since 11 is in 20, why does bar 11 produce [] and bar 20 produce a list of 4
18:32:19 <adnauseam> which algorithm is that :|
18:32:29 <causative> bar none
18:32:38 <wli> d(n)
18:32:49 <rwbarton> because there are no x in [2..10] so that n `mod` x == 0
18:32:53 <rwbarton> for n = 11
18:32:58 <JoeyA> Are you trying to list all numbers from 2 to n-1 that are divisible by n?
18:33:10 <JoeyA> Err, that would be an empty list.
18:33:17 <causative> is there a lambda formalism for the process of compilation?
18:33:23 <kallisti> adnauseam: because none of the elemnets of [2..11-1] are congruent to 0 mod 11
18:33:25 <wli> The number of proper divisors of n, in unary.
18:33:51 <causative> a theoretical lambda calculus based model of translating one computer language into another
18:33:52 <rwbarton> not congruent to 0 mod 11
18:34:00 <kallisti> yes
18:34:00 <rwbarton> such that 11 is congruent to 0 mod them
18:34:26 <adnauseam> kallisti: i think i read something similar to this a few minutes ago
18:34:28 <kallisti> oh I see
18:34:34 <adnauseam> i'm going to go and give it another read
18:34:37 <kallisti> I misread the code. :P
18:34:51 <kallisti> adnauseam: but  yes it "iterates" through the list.
18:34:59 <adnauseam> hrm
18:34:59 <kallisti> and assigns each element to whatever variable
18:34:59 <wli> dgf of zeta^2
18:35:33 <kallisti> > [x + 1 | x <- [1..]]
18:35:34 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:35:37 <adnauseam> rwbarton: that helped man
18:36:06 <ski> wli : `dgf' ?
18:36:27 <wli> Dirichlet generating function
18:37:47 <ski> wli : whence ?
18:38:02 <kallisti> wheretofore
18:38:31 <adnauseam> holy shit, i understand
18:39:16 <kallisti> [ error |
18:39:16 <gwern> hm, these sound like our splittable PRNGS https://dl.acm.org/citation.cfm?id=2063405
18:39:18 <kallisti> er
18:39:31 <kallisti> > [ error "help!" | x <- [1..], False]
18:39:35 <lambdabot>   mueval-core: Time limit exceeded
18:40:02 <wli> > let { d `divides` n = n `mod` d == 0 ; divisors n = [d | d <- [2 .. n - 1[, d`divides` n] } in [length $ divisors n | n <- [2..20]]
18:40:03 <lambdabot>   <no location info>: parse error on input `,'
18:40:06 <kallisti> > [ error "help!" | x <- [1..10], False]
18:40:07 <lambdabot>   []
18:40:24 <causative> I want to design a language where at some point in the code you can demand a value of a specific type and identity, such as "the age of the patient with ID 1235" and the language figures out how to obtain the value (get it from a database, use a cached value, make a function call, etc)
18:40:37 <wli> > let { d `divides` n = n `mod` d == 0 ; divisors n = [d | d <- [2 .. n - 1], d`divides` n] } in [length $ divisors n | n <- [2..20]]
18:40:38 <lambdabot>   [0,0,1,0,2,0,2,1,2,0,4,0,2,2,3,0,4,0,4]
18:40:48 <mmcdermo> How can I create a type that is one of many possible types? ie) something better than Either Text (Either ByteString String)
18:41:12 <mmcdermo> the nesting would get awkard in my situation
18:41:17 <kallisti> data MyType = A Text | B ByteString | C String
18:41:20 <kallisti> use your own type.
18:41:22 <causative> but this means that "the age of the patient with ID 1235" doesn't always compile to a function call, and part of its compilation may add some code elsewhere to gather a block of data about the patient all at once, for example
18:41:32 <mmcdermo> Ty kallisti. I thought there was something like that =D
18:41:32 <wli> Really properDivisors
18:41:39 <kallisti> mmcdermo: out of curiosity what are you doing with such a type?
18:41:43 <causative> is there a theoretical model of compilation that is designed to treat this kind of issue?
18:41:45 <saml> hey, how would you express a circuit made of gates and wires that connect the gates.  wires are typed (Int, Char, Bool, ...)
18:42:09 <saml> data Wire a = InputPort a :-> OutputPort a    -- I have this so far
18:42:27 <mmcdermo> kallisti: I have a bunch of different "disaster event" record types; ie) Earthquake, Tsunami, Flood, Fire
18:42:44 <kallisti> ah okay.
18:42:55 <kallisti> I thought, based on your example, that you wanted to handle many different kinds of strings or something.
18:43:11 <mmcdermo> kallisti: suppose my example was misleading :D
18:50:54 <rasfar> saml, personally i'd either go with a graph library, or express the circuit using matrices (i think it was <ion> had some success doing this with the hmatrix library recently).
18:51:54 <ion> I wouldn’t use matrices as “the” representation of a circuit, only as a method for solving some circuits.
18:52:17 <rasfar> ah (and, hello ion)
18:52:29 <saml> what are graph libraries?
18:52:40 <ion> o hai
18:52:47 <Nisstyre> saml: depends what you mean by "graph"
18:52:56 * Nisstyre scrolls up
18:53:06 <Nisstyre> saml: stuff to do with the branch of mathematics called graph theory
18:53:12 <rasfar> well, there's FGL for instance -- stuff on hackage.org, you know... to be honest, i hack my own graph representations thus far, just looking into the libs now
18:53:42 <rasfar> Nisstyre, no need to scroll in this case ;)
18:53:56 <saml> rasfar, how do you represent your graphs?
18:53:59 <ion> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphs YMMV
18:54:19 <rasfar> sometimes as lists of nodes, and lists of pairs of nodes (the "edges" or "arcs")
18:54:27 <rasfar> sometimes as adjacency matrices
18:54:47 <Nisstyre> saml: look up Dijkstra's shortest path algorithm
18:54:53 <Nisstyre> it's a perfect example of using graphs
18:55:07 <ion> Here’s something by edwardk. I haven’t looked at it before. http://hackage.haskell.org/package/graphs
18:56:04 <saml> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.2.1/Data-Graph.html
18:56:10 <saml> I think containers is part of ghc
18:56:57 <saml> I want edges to be typed though
18:57:10 <saml> since data will be travelled through the edges
18:59:35 <rasfar> Dijkstra's [least-cost] algorithm would still be good to look at, I believe it uses graphs with weighted edges.  I think the weights are required to be non-negative in that case, but it's been a while...
18:59:37 <ion> I’ve been using wxMaxima recently for mitx-6.002 exercises, but i’d love to be able to use Haskell instead. Specifically, i want to be able to input a system of equations (which may have stuff like non-linearity and differentiation) and have them solved as automatically as possible, falling back from symbolic to numerical computation if needed.
18:59:40 <ski> wli : that's basically `[sigma n - 2 | n <- [2 .. 20]]'
18:59:44 <Booyah> Anyone ever attend a speed haskell class?
19:00:08 <Booyah> "FIREHOSE: Lazy Programming With Haskell  Student Organization Event"
19:00:10 <ion> booyah: I’m afraid i haven’t tried amphetamine ever.
19:00:39 <kallisti> lazy speed.
19:00:41 <Booyah> ion: isn't Haskell a form of speed :p
19:01:16 <ski> wli : <http://en.wikipedia.org/wiki/Divisor_function>,<http://en.wikipedia.org/wiki/M%F6bius_inversion_formula>
19:01:42 <Booyah> ion:  λazy amphetamine? :p
19:02:35 <rasfar> Amphetamine Logic (for any revenant Goths who may be lurking)
19:03:07 * ski . o O ( "Make haste, but take heed" )
19:03:21 <saml> where are examples for ghc libraries? for example, examples for Data.Graph usage
19:03:45 <saml> test cases don't include Data.Grap hhttps://github.com/haskell/containers/tree/master/tests
19:04:05 <Booyah> join #reddit-foreveralone
19:04:15 <Booyah> FOREVER ALONE WITH HASKELL
19:05:06 <rasfar> examples? you'll be lucky to find textual descriptions of the API functions...
19:05:23 <saml> why is it like this?
19:05:31 <saml> it's like CQ
19:05:47 <rasfar> partly because the types express so much; partly people can't be assed it seems
19:07:39 <shapr> Yay Google Summer of Code! w00t!
19:08:39 <Booyah> shapr: Got your proposal accepted?
19:08:57 <shapr> Yes!
19:08:58 <rasfar> shapr, hope your appearance at that juncture wasn't a polite language warning :)
19:09:02 <Pseudonym> Woo!
19:09:02 <shapr> My proposal was accepted!
19:09:05 <blackdog> shapr: what was the proposal?
19:09:06 <saml> graphFromEdges :: Ord key => [(node, key, [key])]  ... what does node mean?
19:09:07 <Booyah> Yayaya!
19:09:09 <blackdog> congrats, btw
19:09:15 <Pseudonym> No idea what it is, but congratulations nonetheless.
19:09:18 <shapr> rasfar: I trust you to be nice.
19:09:50 <shapr> My proposal brings all the programmers to the yard... er, irc channel.
19:09:56 <rasfar> oh, /you/ are a student now, right.  yeah i'm nice when nobody pisses me off (kallisti i'm looking at you :-( ) ... =D
19:10:13 <shapr> rasfar: Here on #haskell you get to be nice even when people make you unhappy.
19:10:15 <shapr> Or else.
19:10:21 <shapr> Anyway, here's my proposal: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/shapr/1
19:10:26 <rasfar> hahaha
19:10:37 <shapr> title is: multiuser browser-based interactive ghci, hpaste.org meets tryhaskell.org, for improved teaching of those new to Haskell.
19:11:52 <shapr> I remember when Pseudonym gave credit (or was it blame?) for getting lots of people to join #haskell...
19:11:58 <shapr> er, "gave me credit"
19:12:08 <Pseudonym> I don't remember that.
19:12:15 <blackdog> shapr: looks good mate.
19:12:25 <shapr> Pseudonym: You accused me of having a strong personality.
19:12:28 <Pseudonym> But I must have been right.
19:12:32 <shapr> Pseudonym: Admittedly, that was ten years ago or so.
19:12:38 <Pseudonym> You've mellowed?
19:12:43 <shapr> Not really, no.
19:12:57 <shapr> But I like to think I've learned more tact :-)
19:13:14 <Pseudonym> Or you've developed a jaded cynicism which deters new people now?
19:13:20 <shapr> Hm, I hope not.
19:13:27 <shapr> My classmates call me a nerd's nerd.
19:13:37 <shapr> They think I am *way* too excited about my Discrete Math class.
19:13:39 <Pseudonym> I think that's a compliment.
19:13:58 <Pseudonym> To be fair, they probably don't know how useful it is.
19:14:37 <elliott> saml: It's just a type variable.
19:14:38 <elliott> Like "a".
19:14:38 <rasfar> shapr, i suppose you're aware of luite's work and also ... oh, what's his name, with the visual type annotations? the gnat dances.  could be some cool synergies possible there.
19:14:41 <Pseudonym> Everyone has their moments when they entertain thoughts about what it would be like to go back knowing what they know now.
19:15:02 <Pseudonym> It'd be interesting to do undergrad again knowing what information would be important in the future.
19:15:11 <Pseudonym> I would have paid more attention in statistics classes. :-)
19:15:44 <shapr> rasfar: Yup, rumor has it that luite is my backup mentor.
19:16:04 <ion> shapr: Have you looked at existing editor synchronization protocols? Especially the one Google Wave used to use?
19:16:05 <shapr> luite: Hey, are you my backup mentor?
19:16:10 <shapr> ion: I have not!
19:16:14 <shapr> ion: Got some good urls?
19:16:34 <shapr> apfelmus had suggested keeping a log of all commands and replaying that on join of new users.
19:17:15 <ion> Alas, no. But Google Wave would be the first thing i would… (puts sunglasses on) google.
19:17:20 <tgeeky_> luite: we in #diagrams have kidnapped luite and erased his memory not related to Wolfgang, in order to keep him focused.
19:17:29 <tgeeky_> ion: you're fired.
19:17:30 <ion> There’s also Gobby.
19:17:39 <tgeeky_> errrr
19:17:43 <tgeeky_> shapr: we in #diagrams have kidnapped luite and erased his memory not related to Wolfgang, in order to keep him focused.
19:17:48 <shapr> Right then.
19:18:20 <shapr> ion: I want to focus on "make it work" first, and then upgrade to "make it elegant" later.
19:18:35 <ion> http://martinkou.blogspot.com/2009/09/really-interesting-part-of-google-wave.html
19:19:15 <tgeeky_> ion: mgsloan and I are working on parts of an editor, including difference (Haskell) modules
19:19:17 <serialhex> shapr: why not be excited about discrete math?  i think they're all lamers for *not* being excited about it
19:19:51 <shapr> Ok, I hear rumors that my proposal has NOT been accepted yet, it was a bug in melange! So, not 100% sure now.
19:20:36 <tgeeky_> ion: do you know what happened to the IP behind wave? was it given away?
19:22:15 <ion> tgeeky: AFAIU the imaginary property was given to the Apache Foundation. http://en.wikipedia.org/wiki/Apache_Wave
19:23:21 <kallisti> now accepting hatemail for: http://hackage.haskell.org/packages/archive/unsafe-promises/0.0/doc/html/Control-Concurrent-Promise-Unsafe.html
19:23:44 <tgeeky_> kallisti: I'm sending your address to the Unabomber.
19:23:50 <blackdog> shapr: oh, that's just cruel
19:24:57 <serialhex> kallisti: ok, so being a relative newb i'm going to ask the stupid Q: what is it good for?
19:25:11 <kallisti> creating pure futures using lazy IO
19:25:17 <kallisti> as the synopsis says. :P
19:25:23 <shapr> blackdog: Well, I can hope. I believe the final call is tomorrow.
19:25:39 <elliott> serialhex: nothing
19:25:43 <serialhex> :P
19:26:00 <tgeeky_> elliott: or maybe something... we'll tell you later. we promise.
19:26:32 <serialhex> so basically, i say "get this stuff from over here" that may take a while, do a few other things, and then later ask of it's done, and if it is, then good, but if it's not i wait til it's done, yes?
19:26:46 <kallisti> yep
19:26:50 <serialhex> ok, cool
19:27:12 <kallisti> and this happens implicitly as a result of attempting to evaluate the value. In much the same way that getcontents, readFile, etc couples file IO with evaluation.
19:27:14 <ion> tgeeky: The protocol was always public and there was an open-source reference implementation (which wasn’t the same the actual Google Wave service was running). What Apache got was apparently the actual Google Wave implementation.
19:27:30 <tgeeky_> speaking of lazy programming, I think the Futurama episode where Bender makes two 60% sized clones of himself to avoid doing work, and so on... would be a good programming lesson :o
19:28:21 <luite> shapr: hm, i haven't really promised anything related to this project
19:28:30 <luite> shapr: but congrats on getting it accepted
19:28:32 <shapr> luite: Ok, good to know.
19:28:50 <kallisti> tgeeky_: I'm not sure I know what that lesson is supposed to be..
19:28:52 <tgeeky_> luite: wait. are you a mentor or a mentee?
19:29:13 <tgeeky_> kallisti: oh. you have to "tie the knot" at some point, if you want the sweaters to get folded.
19:29:13 <luite> shapr is the student
19:29:17 <shapr> Yay!
19:30:06 <tgeeky_> kallisti: otherwise, the lazy benders refuse to do work, and just duplicate, generating more thunks, and more benders.
19:30:22 <kallisti> aha!
19:30:38 <serialhex> HA!!  thats pretty cool
19:30:58 <tgeeky_> luite: I'd be happy to help organize / lay plans / do clerical work / make your coffee, if it will help you -- if he gets chosen
19:31:21 <luite> shapr: i don't really know where apfelmus wants to take this, haven't seen the final proposal
19:31:37 <luite> shapr: do you have it somewhere?
19:31:50 <shapr> luite: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/shapr/1
19:33:00 <luite> shapr: oh that's pretty short, short enough for me to understand it :)
19:33:23 <luite> but that's certainly a differnt direction than apfelmus described, is this a different project?
19:33:54 <luite> in particular, it's much closer to wolfgang
19:34:20 <shapr> I agree, I do wish wolfgang were released!
19:34:26 <shapr> Then I could just hack features into wolfgang!
19:34:27 <luite> me too
19:34:28 <luite> :p
19:35:14 <luite> hmm, so who's a mentor for this? or are there no official ones yet?
19:35:49 <shapr> apfelmus, but it's not official yet.
19:36:15 <luite> when does the official coding start?
19:36:28 * shapr digs for the schedule
19:36:50 <luite> wolfgang already loads pasted code of course
19:37:32 <luite> and it does not support gloss-web interactivity
19:37:53 <luite> I was just discussing something in -blah to make that possible
19:37:56 <shapr> http://www.google-melange.com/gsoc/events/google/gsoc2012
19:37:58 <luite> but it's low level hackery
19:38:23 <shapr> Mon April 23rd, upcoming Monday.. that's the official announcement of approved projects.
19:38:56 <luite> ok so if i want to officially mentor, i need to sign up in a few hours?
19:39:01 <ski> > (sum . take 16 . iterate (0.6 *))  1
19:39:02 <lambdabot>   2.499294722523137
19:39:06 <ski> > recip (1 - 0.6)
19:39:07 <shapr> luite: er... I don't know?
19:39:07 <lambdabot>   2.5
19:39:17 <shapr> luite: I hear rumors that #haskell-gsoc is a good place to ask that.
19:39:37 <luite> it says april 20, 7:00 UTC (don't know if that's AM or PM, probably PM?) mentors need to be signed up
19:40:10 <luite> shapr: ok, I'll join
19:40:54 * rasfar thinks it'll be interesting to see how multiuser interactions work out with Wolfgang, if that's at all what we're talking about
19:41:58 <luite> shapr: uh which irc natwork is that? :p
19:42:07 <shapr> um, this one, I thought
19:42:15 <tgeeky_> shapr: rasfar: http://hal.inria.fr/docs/00/44/59/75/PDF/icdcs09-treedoc.pdf
19:42:17 <shapr> edwardk is the guy in charge of haskell.org GSoC, you should check with him
19:42:51 <luite> oh no, he's not here
19:45:25 <tomprince> As long as there is a mentor assigned (and there can be only one at this point), more mentors can be added after, probably. (And in any case, probably isn't so critical. The most significant thing of being offically a mentor is the t-shirt)
19:45:48 <rasfar> thanks tgeeky_; looking...
19:46:07 <Grayshen> f (x:xs) (y:ys) = f x y : zipWith' f xs ys    Please explain what the colon means on the RHS, I must have missed it in the reading
19:46:14 <luite> tomprince: ooh I want a t-shirt
19:46:37 <JoeyA> Grayshen: Cons
19:46:42 <JoeyA> > 3 : []
19:46:42 <rasfar> Grayshen: colon is concatenation of an element onto the head of a list
19:46:43 <lambdabot>   [3]
19:46:52 <JoeyA> > 1 : 2 : [3,4,5]
19:46:53 <lambdabot>   [1,2,3,4,5]
19:46:54 <luite> shapr: has apfelmus already signed up as a mentor?
19:46:57 <kallisti> what's the best way to ensure that evaluating an element of a list forces the previous elements?
19:47:05 <Grayshen> oh thnx
19:47:41 <shapr> luite: I don't know. I don't know anything about the internal workings.
19:47:54 <luite> hm ok
19:48:19 <kallisti> :t scanl
19:48:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:48:55 <kallisti> I think I use scanl or scanlr to accomplish that.
19:50:27 <luite> shapr: i haven't submitted a project idea, so i don't really want to steal apfelmus' projects... on the other hand, he specifically asked for not a website, but a local rich ghci
19:50:32 <ski>      zipWith (+) [0,1,2] [30,40,50]
19:50:36 <ski>   =  zipWith (+) (0:1:2:[]) (30:40:50:[])
19:50:39 <ski>   =  (0 + 30) : zipWith (+) (1:2:[]) (40:50:[])
19:50:44 <ski>   =  (0 + 30) : (1 + 40) : zipWith (+) (2:[]) (50:[])
19:50:48 <ski>   =  (0 + 30) : (1 + 40) : (2 + 50) : zipWith (+) [] []
19:50:53 <ski>   =  (0 + 30) : (1 + 40) : (2 + 50) : []
19:50:56 <ski>   =  [0 + 30,1 + 40,2 + 50]
19:50:58 <ski>   =  [30,41,52]
19:51:02 <ski> Grayshen : like that ^
19:51:21 <kallisti> ski: hi how do I force all previous elements upon forcing a list element?
19:51:26 <kallisti> I'm thinking either scanl or scanlr
19:51:57 <ski> > scanl f z [a,b,c] :: [Expr]
19:51:57 <ski> > scanr f z [a,b,c] :: [Expr]
19:51:57 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
19:51:58 <lambdabot>   [f a (f b (f c z)),f b (f c z),f c z,z]
19:52:17 <kallisti> so scanr
19:52:18 <ski> i think `scanl' is better
19:52:21 <kallisti> ..oh
19:52:33 <kallisti> uh.. are you sure?
19:52:37 <kallisti> scanr seems to fit
19:52:41 <kallisti> if f = pseq
19:53:01 <luite> shapr: how acquainted are you with ghc's internal heap structures? :p
19:53:10 <ski> well, with `scanlr', if you force the first element, it'll force all the rest of the elements as well
19:53:30 <ski> er, with `scanr', i meant
19:53:33 <ski> so i think you want `scanl'
19:53:35 <kallisti> oh nevermind
19:53:42 <shapr> luite: Not at all
19:53:53 <monochrom> @quote monochrom kripke
19:53:53 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
19:53:57 <kallisti> yes I do.
19:54:10 <kallisti> scanl pseq ()
19:54:11 <kallisti> I think
19:54:20 <kallisti> hm
19:54:26 <ski> (imagine `f' above being `seq' in the `scanl' case, and `flip seq' in the `scanr' case)
19:54:33 <kallisti> yeah I see that.
19:54:46 <kallisti> :t scanl1
19:54:46 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
19:55:00 <ski> monochrom : hehe, i wonder what inspired that one :)
19:55:18 <kallisti> > scanl1 []
19:55:19 <lambdabot>   Couldn't match expected type `a -> a -> a'
19:55:19 <lambdabot>         against inferred type `[...
19:55:19 <luite> shapr: hehe aw :( I was thinking that wolfgang and tryhaskell could get resumable computations if you have something that serializes thunks. so you could return something within the cpu limit of 2 seconds, and continue computing if you resubmit the thunk (so you could for example generate a long audio stream in small chunks, with some javascript to pull new chuncks when required)
19:55:33 <ski> > scanl1 f [] :: [Expr]
19:55:34 <lambdabot>   []
19:55:35 <shapr> luite: Oh that would be cool!
19:55:44 <luite> shapr: yes, but rather difficult
19:55:55 <monochrom> Kripke structure means you have multiple worlds, each sentence can have different truth values in different worlds
19:56:17 <monochrom> and a parallel of "there are lies, damn lies, and statistics"
19:56:27 * ski nods
19:56:33 * ski . o O ( "Impossible world semantics" )
19:56:40 <monochrom> hahahaha
19:57:58 <kallisti> @hoogle pseq
19:57:58 <lambdabot> GHC.Conc.Sync pseq :: a -> b -> b
19:57:58 <lambdabot> GHC.Conc pseq :: a -> b -> b
19:57:58 <lambdabot> Control.Parallel pseq :: a -> b -> b
19:58:41 <luite> shapr: looks like there's 4 hours to sign up as a mentor left
19:58:49 <ski> monochrom : see "Impossible Worlds (Stanford Encyclopedia of Philosophy)" <http://plato.stanford.edu/entries/impossible-worlds/> ;)
19:59:10 <monochrom> onoes, it is actually in the stanford encyclopeida
19:59:50 * ski saw in in Creswell's & Hughes' book on modal logic
20:01:01 <luite> shapr: do you have a way to get edwardk here? :)
20:01:07 <shapr> I don't...
20:01:14 <kallisti> sweet.
20:01:21 <kallisti> pseq worked like a charm. :)
20:02:23 <luite> shapr: will you be around for the next few hours?
20:02:42 <shapr> luite: sleep in two hours
20:03:01 <kallisti> > map (+1) [1,2,undefined,3] !! 3
20:03:02 <lambdabot>   4
20:03:06 <luite> shapr: ok
20:04:18 <ion> @summon edwardk
20:04:19 <lambdabot> Unknown command, try @list
20:04:23 <tomprince> According to rumors on #gsoc, as long as some mentor is assigned by 7UTC, additional mentors can sign-up at any time.
20:04:50 <shapr> Clearly there needs to be something like @get-shapr for edwardk
20:05:06 <ion> There’s a @get-shapr? :-P
20:05:08 <elliott> @get-shapr
20:05:08 <lambdabot> shapr!!
20:05:14 <ion> Useful.
20:05:25 <shachaf> It zaps shapr with a little electric shock every time you use it.
20:05:36 <shapr> owie!
20:05:48 <tomprince> luite: You should sign up as mentor on melange, and then go to the haskell page, and apply to be a mentor there. (two steps)
20:09:59 <luite> tomprince: just done that
20:10:42 <luite> is anyone here an admin for the haskell.org organization on gsoc?
20:13:49 <luite> i need to be accepted in 2 hours or so :p
20:14:07 * hackagebot unsafe-promises 0.0.1 - Create pure futures using lazy IO.  http://hackage.haskell.org/package/unsafe-promises-0.0.1 (AdamCurtis)
20:14:21 <twomashi> hpaste down?
20:14:57 <twomashi> seems so
20:15:43 <Clint> it's there but flaky
20:17:06 <twomashi> I have a simple haskell program implementing a do-nothing monad transformer that compiles but stalls on futex_wait_queue_me
20:17:17 <twomashi> ie, the program never returns, it looks like a deadlock
20:17:37 <twomashi> http://simple-paste.com/4f90d533a7b1d84d24000001/
20:18:28 <twomashi> perhaps there is an error in the code but in that case I'd expect it to not compile, or use CPU / grow in memory usage
20:19:02 <JoeyA> twomashi: Well, (>>=) = (>>=) is an infinite loop...
20:19:55 <twomashi> JoeyA: I had the same result implementing a bind function which does the same thing
20:20:09 <twomashi> ie res <- f a; return res
20:20:29 <tgeeky_> copumpkin: do you happen to have edwardk's phone number? if so, tell it to luite. it's an (internet) emergency
20:20:44 <copumpkin> really?
20:20:49 <tgeeky_> yeah, GSoC deadline
20:20:50 <copumpkin> I can get him if you really need him
20:20:57 <tgeeky_> luite: ^^
20:21:02 <luite> hehe, well don't need hime on the phone
20:21:13 <luite> bit I'm not sure if shaes project is properly mentored
20:21:17 <luite> I mean shapr
20:21:31 <shapr> Shae is my legal name, but it's short for shapr, so I'm good either way :-)
20:21:40 <JoeyA> twomashi: If you want it to work, you have to wrap/unwrap Wat so you're using StateT's bind operator.
20:21:46 <copumpkin> oh, so I shouldn't get him?
20:21:48 <tgeeky_> shapr: it's not much short
20:21:55 <luite> yeah, I just didn't want to publish your personal details ;p
20:22:05 <shapr> tgeeky_: That's true
20:22:13 <luite> copumpkin: well if you could get him to accept my mentor signup thingie then it would be ok
20:22:23 <shapr> Internets have emergencies?
20:22:28 <luite> but maybe shapr is already fine :)
20:22:39 <luite> his project i mean
20:22:50 <tomprince> I suspect it is (and any mentor could check)
20:23:38 <JoeyA> Hmm, did GHC recently change what it does when a black hole is encountered?  If I go in GHCi and type let loop = loop in loop, it hangs without burning CPU.
20:23:44 <JoeyA> I think it used to throw an exception.
20:23:56 <Axman6> @pl (\x -> print x >> return x)
20:23:57 <lambdabot> liftM2 (>>) print return
20:24:00 <JoeyA> I guess that's a black hole.  Probably the wrong terminoloty.
20:24:05 <JoeyA> terminology*
20:24:27 <JoeyA> > let loop = loop in loop -- A thousand apologies if this crashes lambdabot
20:24:31 <lambdabot>   mueval-core: Time limit exceeded
20:24:39 <JoeyA> > 2+2
20:24:40 <lambdabot>   4
20:24:54 <byorgey> crashing lambabot is very difficult to do on purpose.
20:25:20 * ski thinks it wasn't JoeyA's purpose to crash lambdabot ..
20:25:28 <JoeyA> But it's very easy to do by accident.
20:25:34 <parcs`> JoeyA: when did it throw an exception?
20:25:36 <byorgey> indeed.
20:25:55 <JoeyA> In GHC 7.0, I think.
20:26:15 <elliott> you have to compile it
20:26:17 <elliott> for it to do that
20:26:19 <elliott> in all versions
20:26:33 <JoeyA> I guess not.
20:26:54 <ski> JoeyA : so, when you want to crash lambdabot, you should make sure to make it an accident (not on purpose), that way the probability of it succeeding will be much higher !
20:26:58 * ski coughs
20:27:25 <JoeyA> So wait, I *want* to crash lambdabot?
20:27:39 <ski> i never said that
20:27:45 <twomashi> JoeyA: implementing >>= with do doesnt fix it...
20:27:51 <twomashi> can you tell me how to do it?
20:28:43 <JoeyA> twomashi: Try this:  m >>= k = runWat m >>= runWat . k
20:28:59 <JoeyA> That way, it uses StateT's >>=
20:29:23 <parcs`> deriving (Monad)
20:30:00 <JoeyA> Or you can use {-# LANGUAGE GeneralizedNewtypeDeriving #-} and just say deriving (Monad), as parcs` suggests.
20:30:54 <twomashi> rather not use this kind of magic yet :)
20:31:13 <kallisti> it's not incredibly magical.
20:31:22 <kallisti> but sure. it would be good to learn how to do it by hand.
20:31:29 <twomashi> ^^ exactly
20:31:30 <kallisti> just let the types guide you.
20:31:47 <twomashi> ah, zen of haskell...
20:39:54 <lispy> uname -a
20:40:15 <lispy> sorry, wrong window
20:45:51 <nyingen> @quote
20:45:51 <lambdabot> luite says: moores law says that the number of things wrong with things doubles every two years
20:48:43 <JoeyA> That's because computers can make mistakes twice as fast.
20:53:28 <nyingen> @quote
20:53:28 <lambdabot> V says: "Remember, remember the fifth of November".
20:54:04 <nyingen> @quote
20:54:04 <lambdabot> c_wraith says: I either just got the most awesome piece of spam ever, or am being secretly recruited into the stargate program
20:54:22 <c_wraith> ... someone remembered that?  huh.
20:55:58 <nyingen> there's all kinds of weird stuff in there
20:56:07 <nyingen> hence the late-night @quote show
20:56:11 <nyingen> @quote
20:56:12 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:56:14 <nyingen> @quote
20:56:14 <lambdabot> Fanael says: yeah, C++ templates are a large step in the right direction, if the "right direction" means back.
20:56:35 <c_wraith> huh.  \bot here doesn't have a fixed version of @quote.  interesting
20:56:56 <ski> fixed version ?
20:57:57 <c_wraith> <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:57:57 <nyingen> fixed not to come up empty half the time?
20:58:10 <c_wraith> That's not actually too hard to fix
20:58:35 <c_wraith> I did it on the custom lambdabot I was running once.  That since died due to too many over-aggressive hacks without version control
20:59:02 <hpaste_> pharaun pasted “recursive directory finder” at http://hpaste.org/67311
20:59:04 <Dilberto> c
20:59:05 <Dilberto> h
20:59:06 <Dilberto> i
20:59:07 <Dilberto> m
20:59:07 <Dilberto> p
20:59:08 <Dilberto> o
20:59:10 <Dilberto> u
20:59:12 <Dilberto> t
20:59:14 <c_wraith> @where ops
20:59:14 <Dilberto> .
20:59:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:59:16 <Dilberto> c
20:59:18 <Dilberto> o
20:59:19 <Axman6> @where ops
20:59:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:59:20 <Dilberto> m
20:59:22 <Dilberto>  /
20:59:24 --- mode: ChanServ set +o Cale
20:59:24 <Dilberto> f
20:59:26 <Dilberto> o
20:59:27 --- kick: Dilberto was kicked by Cale (Dilberto)
20:59:29 <Axman6> shapr: you're about right?
20:59:29 * c_wraith hit the bat signal before Axman6 
20:59:30 <ion> That’s flooding other channels, too.
20:59:42 <copumpkin> it's the usual chipmout assholes
20:59:47 <Axman6> thanks Cale
20:59:54 <tomprince> I had figured that that was a deliberate quote in lambdabot, to throw people off.
21:00:05 <tomprince> @quote
21:00:06 <lambdabot> SteveYegge says: But I'll argue that Accessibility is actually more important than Security because dialing Accessibility to zero means you have no product at all, whereas dialing Security to zero
21:00:06 <lambdabot> can still get you a reasonably successful product such as the Playstation Network.
21:00:08 <pharaun> who's chimpmout?
21:00:13 --- mode: Cale set +b *!*@ip72-207-16-214.sd.sd.cox.net
21:00:13 --- kick: Dilberto was kicked by Cale (Dilberto)
21:00:22 <copumpkin> pharaun: a horrible racist forum that loves to promote itself on IRC
21:00:27 <pharaun> ahh
21:00:33 <pharaun> :(
21:00:39 --- mode: Cale set -o Cale
21:00:52 <elliott> who's the person we're supposed to ping about things like that...
21:00:54 <pharaun> alright i do have a question http://hpaste.org/67311 - I was working on doing a directory finder using system.posix
21:01:03 <elliott> I forget the name :p
21:01:06 <pharaun> but its not seeming to work right so i could use some advice on what part to start poking at?
21:04:33 <pharaun> i've done some basic poking and it seems to be somewhat working but i'm not for sure
21:14:09 * hackagebot hails-bin 0.1.1 - Dynamic launcher of Hails applications  http://hackage.haskell.org/package/hails-bin-0.1.1 (DeianStefan)
21:18:55 <ski> @type maybe False
21:18:56 <lambdabot> forall a. (a -> Bool) -> Maybe a -> Bool
21:19:04 <ski> @hoogle (a -> Bool) -> (Maybe a -> Bool)
21:19:04 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
21:19:04 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
21:19:04 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
21:19:24 <ski> hm, `any' looks good
21:21:35 <rasfar> @get-shapr
21:21:35 <lambdabot> shapr!!
21:22:09 <rasfar> oops, sorry never mind (i thought it was about the summer of code thing, not the spam thing)
21:22:40 <shapr> yes?
21:23:17 <rasfar> sorry man, i just saw Axman6 asking if you were still around and thought it was about the deadline, but it was some spammer.
21:23:39 <rasfar> i'm been over on #diagrams and didn't see the context
21:23:50 <shapr> ah
21:24:02 <rasfar> i'll be more careful; but it was with your best interests at heart :)
21:24:09 * hackagebot hails-bin 0.1.1.1 - Dynamic launcher of Hails applications  http://hackage.haskell.org/package/hails-bin-0.1.1.1 (DeianStefan)
21:24:57 <rasfar> anyhow, i'm offline, g'nite all
21:29:13 <lispy> hello
21:29:24 <lispy> how are people tonight?
21:29:41 <nyingen> I am doing haskelly good
21:41:49 <mzhang> I don't get it, why indentation by tab would cause compilation fail? only because tabstop=4.
21:42:16 <mzhang> I thought haskell would omit all spaces
21:42:29 <danharaj> haskell uses whitespace for layout
21:42:41 <danharaj> don't mix tabs and spaces. it's painful.
21:43:08 <rwbarton> even just using tabs is trouble unless you adopt a particular style
21:43:10 <danharaj> If you do not want to use whitespace you can use {} and ; like C, but that is also painful and ugly and no one does it. It's really just there for automatically generated code.
21:43:12 <elliott> mzhang: To Haskell, tabs are 8 spaces.
21:43:19 <elliott> If you disagree with that, you will mess up.
21:43:27 <elliott> Either set tabs to 8 spaces or use spaces.
21:43:40 <elliott> (Or indent in a very particular way that avoids the width of a tab ever mattering, but that's an acquired taste.)
21:43:51 <danharaj> and/or ask your editor to convert tabs to spaces.
21:44:09 <elliott> danharaj: "No one"?
21:44:17 <elliott> danharaj: You have clearly yet to meet zzo38.
21:44:22 <danharaj> no one I care about :3
21:44:30 <mzhang> elliott and danharaj, thanks
21:44:52 <danharaj> no problem, have fun coding.
21:45:00 <mzhang> I guess I'll convert tab to spaces. I suppose that won't cause any trouble right?
21:45:16 <elliott> Probably not.
21:46:01 <mzhang> i need learn some style...
21:46:53 <danharaj> you can take a library off of hackage and look at its source for style inspiration
21:47:19 <elliott> as long as it's not called uu-parsinglib
21:47:29 <mzhang> danharaj, yes, i agree.
21:47:56 <mzhang> when i learn Perl, the CPAN modules really inspired me.
21:51:38 <mzhang> any recommended practice quizs for haskell? like eulerproject. I guess eulerproject is a little bit too mathmatical. I'd like some routine practices like IO or networking
21:52:02 <shachaf> Write a networked IO server.
21:52:21 <danharaj> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:54:10 <shachaf> mgsloan: Fancy seeing you on SeaFunc@!
21:55:15 <magicman> @hoogle [a] -> [(a,[a])]
21:55:16 <lambdabot> Data.Char readLitChar :: ReadS Char
21:55:16 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
21:55:16 <lambdabot> Prelude reads :: Read a => ReadS a
21:55:23 <magicman> Yeah... no.
22:01:36 <DanBurton> Ok, I have an abombination that I'd like to ask the wise Haskellers about
22:01:48 <hpaste_> DanBurton pasted “State + Cont + Pause Monad” at http://hpaste.org/67313
22:01:56 <mgsloan> shachaf: yeah! I met a few sea-func-ers at Lang.NEXT - didn't know the group existed!
22:02:13 <DanBurton> it's patterned after ehird's answer here: http://stackoverflow.com/a/10237311/208257
22:02:25 <DanBurton> but with continuations thrown in haphazardly
22:03:29 <DanBurton> any ideas about if I am doing this at all right?
22:03:38 <DanBurton> and if so, what goes in the "undefined" slot
22:03:48 <shachaf> mgsloan: Back when I lived in WA I went there a couple of times.
22:04:24 <shachaf> I'm still on the list for some reason.
22:05:57 <mgsloan> shachaf - yeah, the mailing list seems comparatively big!
22:06:14 <mgsloan> (to the meetings / frequency)
22:06:50 <shachaf> mgsloan: Just imagine the meeting frequency if you moved to CA!
22:07:03 <mgsloan> haha
22:07:38 <mgsloan> going to bay-hac?  I was considering it, but it'd be a little last minute to decide to go
22:07:48 <shachaf> mgsloan: Yep.
22:07:50 <shachaf> You should come!
22:08:10 <blackdog> shachaf: you're a seattleite?
22:08:17 <blackdog> i'm here visiting @hydo at the moment...
22:08:19 <shachaf> blackdog: I live in the bay area these days.
22:08:28 <shachaf> Previously I lived nearish Seattle.
22:08:31 <blackdog> ah, right
22:08:44 <shachaf> Are you going to be stopping by here?
22:08:49 <blackdog> already been :/
22:08:49 <shachaf> (You're normally in .au, right?)
22:09:03 <blackdog> tried to meet up with some people but it all fell through, one way or another
22:09:08 <blackdog> yeah, i'm a sydneysider
22:09:32 <lispy> blackdog: oh, did you go through portland? I would have met up
22:09:48 <lispy> blackdog: you could have given a talk about ninja blocks at galois :)
22:10:05 <shachaf> blackdog: Oh, you should've mentioned it!
22:12:11 <blackdog> lispy: nah, just bay area and seattle
22:12:20 <blackdog> lispy: are you a galoisite?
22:12:33 <shachaf> galois.com is a galoisite.
22:12:46 <lispy> blackdog: I'm a galwegian
22:12:59 <blackdog> ha! that's right, i thought i might have misnomenclatured.
22:13:03 <shachaf> I met lispy briefly when I passed through Portland!
22:13:15 <shachaf> I think we talked about B-trees.
22:13:21 <lispy> shachaf: oh yeah
22:13:25 <lispy> shachaf: that was fun
22:13:43 <shachaf> lispy: You should come to BayHac.
22:13:44 <blackdog> man, i love portland
22:13:48 <shachaf> dons came to the last one.
22:13:50 <lispy> shachaf: when is bayhack?
22:13:55 <shachaf> lispy: This weekend.
22:13:56 <blackdog> lispy: i applied to galois a while back
22:13:59 * mgsloan was going to visit Lispy in Portland, but alas, I was there too few days.  Need to visit again soon!
22:14:16 <lispy> mgsloan: acfoltzer's friend?
22:14:23 <mgsloan> lispy: yup!
22:14:31 <lispy> cool, yeah next time you're in town ping me
22:14:46 <mgsloan> though I don't know him very well.  Awesome, will do!
22:15:07 <lispy> blackdog: yeah?  I just recently started paying attention to hiring :)
22:16:15 <blackdog> lispy: i like your hiring process in general :)
22:16:36 <lispy> Right now we're hiring for senior research positions, but we should sound out announcements for more traditional engineering roles soon
22:16:57 <blackdog> (i think melissa didn't like me because of my job history, which is fair enough)
22:17:24 <shachaf> It is a sobering thought that by the time Galois was my age, he had been dead for almost two months.
22:18:42 <mekeor> shachaf: :D
22:18:44 <elliott> @remember shachaf It is a sobering thought that by the time Galois was my age, he had been dead for almost two months.
22:18:44 <lambdabot> Done.
22:18:58 <mekeor> shachaf: actually, he decided himself to die (for his love).
22:19:22 <shachaf> I think that should be @remember TomLehrer or something.
22:19:26 <blackdog> shachaf: better hurry the hell up, brother :)
22:20:21 <elliott> Pfft, "Tom" "Lehrer".
22:20:24 <elliott> Like that's a real person.
22:21:31 <TSC> He did sing a nice song about plagiarism, so he wouldn't mind (:
22:29:11 * hackagebot graphviz 2999.13.0.2 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.13.0.2 (IvanMiljenovic)
22:32:25 <tgeeky_> TSC: i incorrectly told you that arrows are "absolutely" somewhere in diagrams. I was talking shit. They aren't anywhere builtin. I apologize to you and your family. May god have mercy on my soul. Ramen.
22:35:02 <TSC> May the FSM forgive you
22:35:53 <mgsloan> tgeeky_:  I've got an arrow function or two, but yeah, not in diagrams packages
22:39:01 <hpaste_> DanBurton annotated “State + Cont + Pause Monad” with “State + Cont + Pause Monad, tweaked for more headaches” at http://hpaste.org/67313#a67315
22:40:44 <tgeeky_> @quote RickSmalley
22:40:44 <lambdabot> RickSmalley says: [while trying to figure out what 60 carbon atoms would look like]: "So we called the mathematics department, and said: we have this structure for a carbon moulecule, it has 12
22:40:44 <lambdabot> pentagons and 20 hexagons. Get a grad student to figure out which polyhedral this is and call us back. He called right back, saying 'Well, I could explain this to you a number of ways, but what you'
22:40:44 <lambdabot> ve got here boys is a soccer ball.'"
22:46:06 <Axman6> heh
22:50:03 <nyingen> @quote monad
22:50:03 <lambdabot> newsham says: [on esr's blog post about Haskell] could be worse, he coulda wrote a monad tutorial
22:50:14 <ion> hah
22:50:29 <newsham> did i say that?
22:50:34 <shachaf> @quote newsham
22:50:35 <lambdabot> newsham says: i feel like i'm in a roomfilled with philosophy majors who have just read a stephen hawkings book and smoked a big bowl
22:50:45 <shachaf> @quote newsham
22:50:45 <lambdabot> newsham says: now instead of [computers] taking up 3 rooms they just take up your life
22:51:08 <newsham> wow, i'm much smarter on lambdabot.
22:51:28 <nyingen> I'm fine with philosophy majors smoking a bowl. it's when they're snorting meth that the real problems start
22:51:59 <pharaun> @hoogle [Char] -> Char
22:52:00 <lambdabot> Prelude error :: [Char] -> a
22:52:00 <lambdabot> Prelude head :: [a] -> a
22:52:00 <lambdabot> Data.List head :: [a] -> a
22:52:06 <nyingen> @quote ion
22:52:07 <lambdabot> ion says: ddarius: Yeah, abstract concepts absolutely hate being anthropomorphized.
22:52:18 <shachaf> @quote ddarius
22:52:18 <lambdabot> ddarius says: data Python = Scope (Either BaseType (Map String Python))
22:52:38 <shachaf> preflex: seen ddarius
22:52:38 <preflex>  ddarius was last seen on #haskell 42 days, 3 hours, 45 minutes and 4 seconds ago, saying: BMeph: No.
22:52:47 <shachaf> What's going on with ddarius?
22:53:15 <nyingen> rejection, apparently
22:53:37 <nyingen> @quote shachaf
22:53:38 <lambdabot> shachaf says: It's-a me, MonadIO!
22:53:49 <nyingen> lol
22:54:12 * hackagebot wai-middleware-cache 0.3.0 - Caching middleware for WAI.  http://hackage.haskell.org/package/wai-middleware-cache-0.3.0 (AlexanderDorofeev)
22:54:29 <nyingen> I feel guilty for laughing at that
22:54:33 <newsham> monad IO's evil twin == war IO?
22:54:39 <newsham> unsafePerformWarIO
23:07:52 <nyingen> @quote
23:07:52 * lambdabot says: trololololo
23:07:59 <nyingen> @quote
23:07:59 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexadecimal.
23:09:27 <shachaf> @forget /me trololololo
23:09:27 <lambdabot> Done.
23:12:14 <elliott> How does that work?
23:12:17 <elliott> @remember /me abc
23:12:17 <lambdabot> Good to know.
23:12:19 <elliott> @quote /me
23:12:19 * lambdabot says: hahaha
23:12:26 <elliott> There's *special code* for that?
23:12:29 <elliott> @forget /me abc
23:12:29 <lambdabot> Done.
23:14:38 <shachaf> @forget /me hahaha
23:14:38 <lambdabot> Done.
23:14:41 <shachaf> @quote /me
23:14:41 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:15:07 <elliott> @quote lambdabot getRandItme
23:15:07 <lambdabot> No quotes match. You type like i drive.
23:15:08 <elliott> @quote lambdabot getRandItem
23:15:08 <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
23:35:12 <ChristianS> looks like lambdabot could need a little bugfixing
23:37:17 <Orclev_> the quote plugin just needs a more graceful way of handling an empty quote list it seems
23:38:02 <ChristianS> @remember /away down for repairs
23:38:02 <lambdabot> Done.
23:38:11 <elliott> @quote /away
23:38:11 <lambdabot> /away says: down for repairs
23:38:12 <ChristianS> @quote /away
23:38:12 <lambdabot> /away says: down for repairs
23:38:16 <elliott> The /me thing is obviously special-cased.
23:38:22 <elliott> /me is not part of the protocol.
23:38:25 <elliott> @forget /away down for repairs
23:38:25 <lambdabot> Done.
23:38:28 <elliott> So it must be an intentional feature.
23:38:29 <ChristianS> that's good to know :-)
23:38:54 * lambdabot wanted to be able to talk about herself!
23:39:09 <mekeor> oO
23:39:09 <herself> I don't allow it
23:39:25 <mekeor> herself: are you lambdabot herself?
23:39:35 <herself> I'm herself herself
23:39:42 <mekeor> ah i see.
23:39:43 <shachaf> hi herself
23:40:12 <herself> hi :-D
23:40:31 * Orclev_ just loves it when random parts of the internet backbone start acting flaky...
