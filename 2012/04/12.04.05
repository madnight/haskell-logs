00:00:10 <YellowOnion> yeah pythons built in process executer blocked until it had finished excuting so I needed a library that didn't block
00:01:28 <YellowOnion> so I could interpret the data as it came out
00:02:12 <YellowOnion> kallisti: I thought Async IO was a method to handle concurrency problems?
00:02:24 <kallisti> it's a method to avoid concurrency
00:03:42 <kallisti> rather than executing threads simultaneously you use one thread to poll on many events.
00:04:09 <kallisti> of course you can use asynchronous IO /and/ concurrency together as well.
00:09:18 <YellowOnion> kallisti: I see, I was under the assumption that Concurrency was about finding ways to execute data side by side, whether interleaving small bits of code (twisted) or threads of some sort
00:10:00 <kallisti> concurrency refers to simultaneous computation.
00:11:43 <YellowOnion> System threads aren't truly Simultaneous on a Single core, I considered Twisted to be moving the burder up from the OS to the programmer
00:12:00 <Ayvee> Parallelism refers to simultaneous execution.  Concurrency is "logical parallelism", not simultaneity in time.  If an algorithm or program is concurrent, then it CAN be executed on parallel hardware, but it doesn't have to.
00:12:26 <kallisti> right
00:12:52 <YellowOnion> of course Twisted only ran on one core by default
00:13:02 <brownies> hello
00:13:56 <YellowOnion> and I have 6, so that's why I started looking at alternatives, erlang and Haskell caught my eye
00:14:22 <brownies> are you asking about soft real-time for web?
00:14:28 <brownies> because... that's actually what i showed up to ask about.
00:15:37 <YellowOnion> brownies: Kiaora, you name has made me hungry, I'm off to grab some food, and we we're talking about Python's Twisted and Concurrency, and how it wasn't very useful on my 6 core CPU
00:15:58 <Ayvee> A simple way of explaining concurrency to beginners is to say "Concurrency is logical independence.  If an algorithm or program has logically independent parts then those parts can be executed in any order, or at the time time, it makes no difference.  It's then called a concurrent algorithm or program."
00:16:19 <Ayvee> s/time time/same time/
00:17:40 <brownies> is it accurate to say that Erlang and Haskell are similar in the way they handle concurrency? er... the way that they can be concurrent?
00:19:31 <kallisti> the main similarity is that they both use green threads with schedulers built into the runtime system.
00:19:58 <kallisti> the way you write concurrent programs in Haskell and Erlang is fairly different.
00:20:07 <kallisti> because of the differences in the languages themselves.
00:20:09 <Ayvee> Maybe, but it doesn't get you very far.  What's accurate is to say that their pure FP parts both provide a lot of natural concurrency because the meaning of an expression can never change.
00:20:54 * hackagebot wai-app-file-cgi 0.5.8 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.8 (KazuYamamoto)
00:20:56 * hackagebot mighttpd2 2.5.7 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.7 (KazuYamamoto)
00:21:10 <brownies> Ayvee: ok, fair. that's useful.
00:21:26 <brownies> i had initially picked Erlang but the docs are laced with all kinds of warnings about NOT using it for number-crunching
00:23:24 <Ayvee> Well you wouldn't normally use Erlang for number crunching anyway, it's rather slow.  It's very good for highly concurrent apps like web servers not because it's fast, but because it has very low overhead for highly concurrent apps.
00:24:48 <Ayvee> Ie. very little memory overhead and very little process switching overhead.  Pure sequential processing is kinda slow, but it wasn't designed for that, but for concurrency and reliability.
00:25:55 * hackagebot yesod-auth-oauth 1.0.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.0.0 (HiromiIshii)
00:27:07 <brownies> i see
00:27:31 <brownies> what i am looking for (ideally) is a single codebase to handle BOTH realtime message-passing for web, as well as number-crunching to do analytics on those messages
00:27:54 <brownies> it seems Erlang is out, and Scala is... ugly... is Haskell a viable candidate?
00:28:07 <kallisti> yep
00:28:52 <kallisti> brownies: also there are libraries for web development available to you.
00:29:07 <kallisti> and number-crunching, depending on what kind of numbers you seek to crunch.
00:29:12 <Ayvee> Isn't the answer the same for both Erlang and Haskell?  Write a C program to do the innermost loop of the high speed processing, and link it to Erlang or Haskell?
00:29:37 <kallisti> in Haskell that isn't strictly necessary in the vast majority of cases.
00:30:03 <kallisti> but yes, you can.
00:30:05 <Ayvee> Although Haskell ought to be fast enough for the processing, it's only like a factor or 2 or 3 slower than C for most things, an order of magnitude faster than Erlang.
00:30:28 <brownies> well, if the first page of intro to Erlang says "NO NUMBER CRUNCHING" it's enough to make me re-think my plan =P
00:30:56 <brownies> it's... umm... fairly scientific number-crunching. i was going to do it functional-style in Python originally, so doing it in Haskell would be just fine, and probably fun.
00:31:16 <kallisti> "functional-style" and "python" are 2 things that don't go together very well.
00:31:22 <Ayvee> Aye, horses for courses.  There is no "best" language.  There is only "language closest to my requirements".
00:31:42 <brownies> of course
00:31:52 <brownies> kallisti: ehh it's *kind of* functional, plus it has NumPy which is handy
00:32:17 <kallisti> no serious program in Python uses recursion.
00:32:17 <brownies> i'm sure i sound like quite the haskell noob, but... just trying to sanity-check my idea.
00:32:23 <kallisti> because it doesn't optimize for recursion.
00:32:33 <brownies> kallisti: not recursion. but passing around functions is useful.
00:32:45 <kallisti> sure. and then there's the problem of poor lambda syntax.
00:32:54 <Ayvee> Python's even slower than Erlang though, so "Python" and "number crunching" go together even worse.
00:32:56 <kallisti> it just doesn't accomodate that style very well.
00:33:04 <brownies> it's true.
00:33:15 <brownies> Ayvee: ah i didn't know it was *that* slow.
00:34:15 <YellowOnion> brownies: it's rediculously slow, it doesn't have a JIT yet think 100x slower than C
00:34:45 <Ayvee> I benchmarked the main scripting languages a while ago, Python didn't come out well, only Ruby was slower.  At the time, Lua and V8 JS were the fastest of that bunch.
00:35:01 <YellowOnion> python 101 is use C for number crunching
00:35:07 <Ayvee> Yeah
00:35:21 <kallisti> Ayvee: did you test Perl?
00:35:45 <YellowOnion> language shootout?
00:35:52 <kallisti> also I'm guessing you used LuaJIT?
00:35:53 <Ayvee> Yes.  Perl was a fair bit faster than Python, but to my surprise, massively faster to start up.
00:36:09 <kallisti> Ayvee: hm, I'm surprised that perl is faster than CPython
00:36:19 <Ayvee> Lemme see if I can dig up my little table of results.
00:36:21 <kallisti> for... this assuredly very scientific benchmark.
00:36:33 <YellowOnion> http://shootout.alioth.debian.org/
00:36:38 <YellowOnion> this has some interesting stuff
00:37:49 <kallisti> YellowOnion: yes I've seen that.
00:38:56 <YellowOnion> I like how all the JIT based programs use 50-100x more memory than C/C++
00:39:08 <ivanm> preflex: seen copumpkin
00:39:08 <preflex>  copumpkin was last seen on #haskell-blah 23 minutes and 36 seconds ago, saying: * copumpkin squishes them all
00:39:17 <ivanm> you still here copumpkin?
00:39:22 <dnm> ivanm: He's asleep.
00:39:31 <ivanm> fair enough
00:39:34 <clintm> well crap.  Just to confirm before I start using straight cabal for this project, is anyone successfully using cabal-dev with 7.4.1 on a project that doesn't build out of the blocks?  I can't get it to run 'cabal-dev ghci' for anything.
00:39:36 <ivanm> thought that might be the case
00:39:51 <ivanm> clintm: what's the error?
00:39:51 <Ayvee> You have to remember that benchmarks aren't worth much.  At best they only give you a rough idea of speeds, and at worst they mean nothing.
00:40:12 <ivanm> Ayvee: especially microbenchmarks
00:40:15 * kallisti isn't sure why aeson opts to use lazy ByteStrings
00:40:18 <ivanm> @google lies, damn lies and benchmarks
00:40:18 <Ayvee> yeah
00:40:20 <lambdabot> http://en.wikipedia.org/wiki/Lies,_damned_lies,_and_statistics
00:40:20 <lambdabot> Title: Lies, damned lies, and statistics - Wikipedia, the free encyclopedia
00:40:30 <clintm> ivanm: pasting... please hold.
00:40:40 <ivanm> kallisti: so that you can use it without worrying about how big the JSON in question is?
00:41:01 <kallisti> ah yes.
00:41:03 <hpaste> clintm pasted “cabal-dev” at http://hpaste.org/66460
00:41:07 <ivanm> kallisti: also there are builders available for lazy bytestrings (which I think aeson uses, but I could be wrong) but not for strict ones
00:41:10 <kallisti> that doesn't become a problem with attoparsec-conduit
00:41:27 <ivanm> kallisti: yes, but aeson doesn't use attoparsec
00:41:30 <ivanm> it uses a custom parser
00:41:39 <kallisti> ivanm: oh really? it seems to use some attoparsec types.
00:41:57 <kallisti> the json top-level variable is a attoparsec Parser
00:42:13 <ivanm> clintm: can you manually run ghci and fake-ghc-cabal-dev to get them to work?
00:42:13 <YellowOnion> Ayvee: well the good thing is that all the source code for each example is avalible so you can check how each is computed and see if any of these are close to what you'll need it for
00:42:18 <ivanm> kallisti: well, it didn't use to be :)
00:42:25 <ivanm> I admittedly haven't poked in its guts for a while
00:42:26 <kallisti> ivanm: but no there is a custom parser, you're right.
00:42:33 <kallisti> I think it has an attoparsec parser as well.
00:42:41 <clintm> ivanm: hrm... hadn't tried that.  trying now.
00:42:45 <kallisti> because I have to convert results from both into my monad.
00:43:16 <Enigmagic> ivanm: looks like it used attoparsec for it's first release .. http://hackage.haskell.org/packages/archive/aeson/0.1.0.0/doc/html/Data-Aeson-Parser.html
00:43:41 <ivanm> Enigmagic: huh, I recall going through the guts of an early version and finding a custom parsing class there
00:43:45 <clintm> ivanm: hrm, how is that done?  poking at fake-ghc-cabal-dev only gives me back my arguments.
00:43:54 <ivanm> kallisti: it appears to use strict bytestrings in Data.Aeson.Parser
00:43:57 <Ayvee> My last benchmarking was 4 years ago, there's little point looking at it now.  But just for fun ---> http://pastebin.com/fTqW4fwd
00:43:59 <mauke> The paste fTqW4fwd has been copied to http://hpaste.org/66461
00:44:18 <ivanm> clintm: I've never used cabal-dev before, so I'm not sure what it is meant to do :) (the fake-ghc thingy that is)
00:44:29 <Enigmagic> ivanm: *shrug* i just recall having to learn enough attoparsec to try aeson when it came out
00:44:37 <Enigmagic> maybe he used something else before it hit hackage
00:44:45 <ivanm> Enigmagic, kallisti: oh, I think bos does a separate lexing vs parsing stage
00:44:47 <ivanm> or something
00:45:12 <clintm> ivanm: hrm, really... what do you all use?  or do you just use straight cabal and ghc-pkg check/recache/something else when things go all weird?
00:45:15 <kallisti> I think pretty soon I'm going to switch over to http-conduit and then use the strict JSON parser with attoparsec-conduit
00:45:35 <ivanm> clintm: I do, but I typically only work on one project at a time
00:45:38 <ivanm> (or at least related ones)
00:45:45 <clintm> i mean, it happens to me almost once a week, and that's really the only reason I use cabal-dev, virthualenv, or anything else.
00:45:53 <Ayvee> I guess I should benchmarks them again for 2012
00:46:33 <ivanm> Enigmagic, kallisti: or it could be the separate parser is from JSON to Haskell datatypes
00:46:45 <ivanm> whereas aeson is for the actual bytestring -> json
00:46:54 <YellowOnion> Ayvee: python 2 is going to be of more use that 3 at this moment
00:46:56 <clintm> ivanm: well, hrm... I guess I could take the 'make it my problem' and normalize my package versions between projects.  90% of them use snap, persistent, mongodb, and zeromq.
00:47:18 <clintm> which, now that I type that, makes me feel kindof like a whiner.  I guess it would be easy enough to fix if I did that.
00:47:21 <ivanm> clintm: oh, and I don't use web stuff :)
00:47:34 <clintm> no more farting around with making ghc-mod work with cabal-dev, etc.
00:47:35 <ivanm> which makes it much easier
00:47:39 <ivanm> heh
00:47:53 <kallisti> ivanm: the attoparsec parser is for dealing with ByteStrings directly, while the aeson stuff converts to aeson's JSON type.
00:48:38 <ivanm> you mean from aeson's JSON type?
00:49:15 <kallisti> ah, yes.
00:49:41 <Ayvee> There does seem to be a lot of "farting around" to get things to work together, it's unfortunate.  I'm about to delete everything I installed for Haskell using the Gentoo package manager, just because it doesn't play nicely with anything else.
00:50:36 <ivanm> Ayvee: huh?
00:50:46 <ivanm> I used the gentoo stuff for years with no problems
00:50:58 <ivanm> and the only stuff I installed by hand using cabal-install were the packages I was hacking on
00:51:08 <clintm> Ayvee: well, I'm actually talking about shoehorning haskell dev tools to work with other tools, and, judging from the responses here, not at all normal practice for the discerning haskell programmer, fwiw.
00:51:32 <YellowOnion> cmd.exe is so annoying, just found 4 instances of ghc in task manager
00:51:49 <ivanm> clintm: my guess is that ghc-mod does shell level calls to ghc[i], right?
00:51:55 <YellowOnion> cmd.exe somehow loses processes
00:52:50 <clintm> ivanm: yea, that part was actually somewhat easy-ish to fix.  I submitted a patch to ghc-mod to get it to work with cabal-dev last year, it just seems to break for me every time I merge with his master from github.
00:53:31 <clintm> wow... cd ~; find . -name cabal-dev -type d -exec rm -rf {} \; = 2.1g freed.
00:54:03 <clintm> more room for venture bros. episodes on the ssd!  *dance*
00:54:25 <Ayvee> ivanm: not sure what the problem is, but it gets itself totally confused and even goes into install loops with cabal-install upgrades.  So I think I'll go entirely from source outside of Portage tree.  They're too slow anyway with keeping up with releases.
00:55:31 <ivanm> Ayvee: bah, use the overlay
00:55:32 <ivanm> !
00:55:56 <ivanm> the overlay is usually up to date, or you can help bump packages if they're not updated
00:56:12 <ivanm> (when I still used gentoo I used to do a lot of package bumping, but I"m not quite sure how frequent they are with it now)
00:56:20 <Ayvee> I did add the overlay expecting my problems to go away, but they didn't. :-(
00:56:30 <ivanm> not sure how an install loop can happen with cabal-install though...
00:56:32 <clintm> Ayvee: ivanm: that sound like the kind of thing that would happen to me when I started installing cabal packages with --global way back when.
00:56:40 <clintm> s/sound/sounds/
00:56:45 <ivanm> oh, using --global is *bad*
00:56:46 <clintm>  s/sound/sounds/
00:57:03 <Ayvee> clintm: could be, since I use global.
00:57:10 <ivanm> *tsk, tsk*
00:57:10 <clintm> yea, they don't tell you that though... at least not loudly enough.
00:57:18 <clintm> Ayvee: that's your problem.
00:57:20 <clintm> sorry to say.
00:57:24 <ivanm> clintm: I would have figured the fact that it's an extra option would be a big hint
00:57:41 <clintm> ivanm: a lot of things are extra options. :)
00:57:44 <Ayvee> Why though.  Local and global should be identical here, since there is only the one installation.  Mine.
00:57:46 <gnoi> Can I avoid type' in `getByType t xs = [ name | (name, type') <- xs, t == showType type' ]'
00:57:49 <gnoi> ?
00:57:50 <clintm> a lot of safe things
00:59:11 <clintm> Ayvee: I don't know enough about the whole cabal ecosystem to speak on that.  I just know how to get stuff installed and ready to be used in a project.  One of the very first things I learned was that '--global' = bad.
00:59:12 <ivanm> Ayvee: if you're relying on distro packages, then you won't get global problems when updating said system packages
00:59:43 <ivanm> then if you *do* get a problem when using cabal-install for extra stuff that isn't in the overlay (and which you don't bother adding to the overlay for some reason) you can always wipe ~/.ghc without a problem
00:59:50 <ivanm> which won't affect system stuff
01:00:00 <Ayvee> Makes sense, kk
01:00:34 <ivanm> Ayvee: typically, --global is only used when you're provisioning a multi-user environment with specific packages (e.g. uni computer labs where courses require a specific package)
01:01:02 * hackagebot arbb-vm 0.1.1.4 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.4 (JoelSvensson)
01:01:28 <Ayvee> Righto.  I'll delete everything, emerge from overlap, and then install everything else as local
01:01:38 <Ayvee> overlay*
01:02:55 * clintm goes off to make up some 'internet karma' by writing a 'So you want to start learning Haskell - here's the stuff that's not obvious (or wasn't to me)' post.
01:03:19 <ivanm> anyone here interested in reviewing my new-ish planar graph library before I (finally) actually release it on hackage?
01:03:46 <kallisti> hm
01:03:51 * Ayvee gives clintm +1 Internet karma as pump priming :P
01:04:01 <kallisti> so, if my operator is (.), should I be using foldr?
01:04:17 <kallisti> foldl corresponds to how an explicitly written composition chain works
01:04:34 <YellowOnion> clintm you're putting episodes of some description on a ssd, why not get a normal hard disk for non critical files?
01:04:37 <kallisti> (I realize composition is associative)
01:04:52 <kallisti> in this case.
01:05:25 <clintm> YellowOnion: laptop.  Team Venture must follow me on my away-from-the-desk adventuring.
01:06:03 <YellowOnion> external enclosure?
01:07:05 <clintm> YellowOnion: my life is too exciting to carry cables... and.... ermm.... ok, I don't have a good excuse.
01:07:13 <clintm> lazy, I guess.
01:07:23 <YellowOnion> good enough in my book
01:07:45 <clintm> and I'm jaded against anything that isn't on the *sparkle*cloud*sparkle* since my drobo took a major crap and took with it all the things.
01:08:10 <YellowOnion> :/
01:08:46 <clintm> yes, I know, the cloud is an illusion sold to us by people who use the word 'cloud' and 'webinar' in conversation non-ironically, but still...
01:08:59 <YellowOnion> the cost of the cloud for me makes it cheaper to just back several HDD's
01:09:13 <YellowOnion> back up*
01:09:19 <YellowOnion> NZ Internet sucks
01:09:44 <clintm> yea, same here.  I've got four 2t drives sitting on a shelf from said drobo that are fine.  I just have to decide what I'm going to do with them.
01:09:46 <clintm> again, lazy
01:09:57 <YellowOnion> heh
01:10:33 <YellowOnion> when I bought my new 2TB I made sure to get an enclosure for my old one
01:10:57 <YellowOnion> so I wouldn't have to do two orders down the track
01:11:37 <clintm> now that I think on it, the drobo was .... 4 years old?  something like that.  I've had it forever.
01:11:46 <clintm> maybe I should have expected that.
01:12:39 <clintm> still, I don't put anything important on a drive in an enclosure that only holds one drive.  it will make me, on a long enough timeline, burn with the heat of the proverbial thousand suns.
01:13:27 <YellowOnion> heh, my windows install is still sitting on my old 120GB from like 2005 >.>
01:14:07 <YellowOnion> I should really move it, but the 2TB has GPT and booting Windows on a GPT disk isn't easy
01:14:29 <Ayvee> Funny how everyone totally forgets the #1 security mantra of "Disallow physical access to your system" the minute that "cloud" is mentioned.
01:14:46 <YellowOnion> plus it already have about 1TB of crap on it so I cant change back to MBR
01:15:04 <clintm> YellowOnion: rsync!
01:15:07 <clintm> oh, wait.
01:16:03 <YellowOnion> Ayvee: imagine if the RIAA or MPAA got hold my my hard drive >.>
01:16:56 <Ayvee> They'd need a warrant.  To get the same data from the cloud they need nothing.
01:18:15 <clintm> Ayvee: apparently, if recent shenanigans are anything to go by, the warrant part is optional, depending on where you live.
01:18:48 <clintm> then again, I'm in the u.s., though I've been considering very seriously moving to .nz or .au
01:19:11 <clintm> that is, if they'll have me... which I don't really know.
01:19:15 <Ayvee> Don't come to the UK, police state is already largely operational.
01:19:43 <clintm> <joke about us and uk being errily similar>
01:19:50 <YellowOnion> here they need your IP and some relation to p2p and their alleged copyright material
01:20:01 <clintm> eeriellallyyy or something ugh.  it's late.
01:20:02 <YellowOnion> 3 times
01:21:35 <YellowOnion> because of the nature of DHT and the law, downloading a Linux ISO via bittorrent could get you fined for  pirating the latest blockbuster
01:22:38 <YellowOnion> but anyway
01:23:35 <YellowOnion> grass is always greener
01:24:30 <clintm> it's not a matter of politics... I just like a little adventure.
01:24:48 <YellowOnion> can I define data types in ghci?
01:25:24 <YellowOnion> clintm: well in that case
01:26:53 <MasseR> YellowOnion: AFAIK with ghc 7.4
01:28:04 <YellowOnion> MasseR: I have 7.0.4 and I was sure I updated not too long ago
01:46:01 <t7> Ayvee: tell me about it
01:46:07 <t7> im moving to iceland or something
01:47:57 <Ayvee> I think the only solution along emigration lines would require a change of planet.  And even that would only be a temporary solution, until the first lawyer and politician gets there.
01:48:36 <t7> it makes me so mad :(
01:49:24 <Ayvee> It'll keep getting worse and worse.  Then one day people will have had enough, and there will be a bloodbath.
01:49:58 <t7> Ayvee: not really, the married middle class dont give a fuck as long as they have an easy life
01:50:34 <YellowOnion> I like Douglas Adams take on politics
01:50:51 <Ayvee> It's not yet affecting them.  It will in due course, because the greedy parties and corrupt politicians are not going to stop.
01:52:10 <roconnor> t7: hey, I was wondering if there is any point in you using RSA; why not simply work modulo Z_p?
01:52:49 <roconnor> t7: is simply doing x^k mod p a (no-public-key) cryptosystem?
01:53:11 <Ayvee> And don't forget that the married middle classes have kids, and there's a limit to how many of those can be criminalized before the cozy middle classes do start caring.  It's a distraction from their golf, and that's unforgiveable.
01:53:34 <opqdonut> roconnor: AFAIK discrete logarithm is hard
01:53:36 <opqdonut> so yes
01:53:52 <roconnor> that's what I'm thinking
01:54:26 <roconnor> ... granted you don't want x to be 0 or 1, and probably not (-1) either. (RSA would have the same issues).
01:54:43 <roconnor> I wonder if there are any other problematic messages
01:58:31 <roconnor> t7: so to encrypt with key k (with k < p-1) simply compute c = m^k mod p.  To decrypt, compute m = c^(p-k) mod p.
01:59:23 <t7> whats m there?
01:59:31 <roconnor> m is your message you want to encrypt
01:59:37 <opqdonut> c is the cyphertext
01:59:50 <t7> m <= p ?
02:00:01 <roconnor> t7:  yes
02:00:02 <opqdonut> yeah
02:00:23 <roconnor> Although if m = 0 or 1 or (-1) the encryption won't be very secure :D (same with RSA)
02:01:04 <t7> whats that called ?
02:01:49 <roconnor> I'd be inclined to make your "cards" [g, 2*g, ... 52*g] where g is some agreed upon public random number less than p
02:01:57 <roconnor> t7: I don't know what it is called.
02:02:10 <roconnor> let me see if I can find a name for it
02:02:27 <t7> whats the advantage?
02:02:45 <roconnor> t7: simpler, somewhat better properties.
02:02:59 <t7> i like simple
02:03:23 <t7> let me have a play with this then
02:04:10 <t7> i only need (p : large prime) and (k : less than p,  relatively prime with p?)
02:04:48 <roconnor> your k needs to be less than p-1.
02:05:01 <roconnor> and it will be relatively prime with p because p is prime. :D
02:05:14 <t7> so k can be anything
02:05:29 <roconnor> pretty much; though there is no point in exceeding p-1
02:05:50 <roconnor> because k^n = k^((p-1)+n) mod p
02:05:58 <roconnor> er
02:06:00 <roconnor> sorry
02:06:15 <roconnor> because m^k = m^(k+(p-1)) mod p
02:08:10 <t7> hang on
02:08:46 <t7> im not sure how to compute a = b ^ c mod d.
02:09:00 <t7> do i use ext euc gcd again?
02:09:26 <alpounet> there's a trick for that
02:09:31 <alpounet> you decompose c in binary
02:10:30 <roconnor> what alpounet said, you use repeated squaring moduluo d / multiplication by b modulo d.
02:10:48 <alpounet> and then separate b ^ c in: product of b^(2^k)
02:10:54 <alpounet> (mod d)
02:11:01 <t7> oh man i never did maths
02:11:12 <alpounet> but it's even smarter than that
02:11:30 <alpounet> just define A0 = b, A(k+1) = Ak²
02:11:41 <alpounet> then b^c mod d is just the product of Ak²
02:11:49 <alpounet> (mod d, again)
02:14:06 <Tinned_Tuna> I really should re-read my old num thy books. We went over this stuff really early on :-p
02:14:21 <Tinned_Tuna> And I've long since forgotten :-/
02:17:07 <t7> alpounet: A is a function there? a 0 = b; a k = a ((k - 1) ^ 2)
02:17:34 <t7> that will grow....
02:17:50 <alpounet> it's a k = (a (k-1))^2 if you define it as a function
02:17:50 <roconnor> t7: expmod p x e | e == 0 = 1          | even e = (expmod p x (e `div` 2))^2 `mod` p                | otherwise = (expmod p x (e-1) * x) `mod` p
02:18:01 <alpounet> but t7 you'll stop when the binary decomposition of c stops
02:18:04 <roconnor> t7: this isn't tail recursive, ... but optimizations go later
02:19:47 * roconnor also suspsects there is some sort of fast squaring mod p ... but optimizations go later.
02:22:33 <egomes> Is it possible to run "cabal build" with flags?
02:23:06 <egomes> Or only with "cabal install"?
02:25:49 <t7> roconnor: how do those params map to my domain?
02:27:33 <t7> ah ignore that
02:28:12 <roconnor> t7: maybe also add a case at the beginning | e < 0 || p-1 <= e = expmod p x (e `mod` (p-1))
02:28:33 <roconnor> t7: expmod p x e  compute x^e `mod` p
02:29:04 <t7> ah i had it the wrong way round :)
02:29:14 <roconnor> this last bit only works when p is prime
02:31:12 <roconnor> and may or may not work when x is 0 ... depending on what you think the answer for 0^(p-1) `mod` p should be :D
02:34:17 <hpaste> t7 pasted “am i doing something retarded” at http://hpaste.org/66465
02:35:10 <roconnor> t7 my fault
02:35:21 <roconnor> should be ((expmod p x (e `div` 2)) ^ 2) `mod` p
02:35:23 <nru> has anyone compiled a list of every operator and infixness declaration in haskell 2010
02:35:30 <nru> (or something close) ?
02:37:39 <kallisti> no, it would be interesting to see though.
02:37:59 <kallisti> also what do you mean by "haskell 2010"? you mean just the standard modules. There's not going to be many operators in those.
02:39:06 <nru> kallisti: well, my goal is printing an operator list and sticking it next to my desk
02:39:16 <nru> so I expect it to be less than one sheet of paper
02:39:40 <nru> though compiling it throughout the platform would be interesting for reference, but less so for printing
02:42:09 <kallisti> nru: I would go with base then
02:42:32 <kallisti> in fact a perl script could do that very quickly.
02:42:44 <kallisti> assuming no local fixity declarations.
02:43:17 <kallisti> I guess also assuming that every operator has a top-level type signature, otheriwse you'd have to parse the, possibly infix, function definition.
02:43:28 <kallisti> in the case where default fixity is used.
02:44:18 <t7> roconnor: are you sure     c = m ^ k mod p    and     m = c ^ ( p - k) mod p    ? I have tried 2 different expmod algo's and it wont work :(
02:44:24 <nru> kallisti: yep; not that simple to do  automatically in the end
02:44:38 <kallisti> you can likely cut corners though.
02:44:40 <kallisti> for base at least.
02:44:47 <nru> yep
02:45:27 <roconnor> t7: let me try
02:45:33 <roconnor> t7: give me a big prime
02:45:47 <t7> 39301
02:46:41 <Tinned_Tuna> t7 come on man, thing BIG!
02:46:54 <t7> 76419957522373080614012289955070296154865083937261070584974581729653396862519
02:47:00 <Tinned_Tuna> haha :-D
02:47:04 <t7> dont make me go 1024 bit
02:47:47 <merijn> 999999999989
02:47:58 <merijn> Apparently wolfram alpha can produce primes on demand :>
02:49:06 <roconnor> t7: ah I see
02:49:09 <ivanm> merijn: or it has a really big list of them already defined and stored somewhere...
02:49:09 <roconnor> I did mess up
02:49:19 <ivanm> roconnor: :o
02:49:21 <ivanm> zomg!
02:51:37 <roconnor> t7: decryption should be expmod p c d  where (d = e^-1 `mod` (p-1)) ... which reminds me that you will want to pick a prime p such that (p-1)`div`2 is prime
02:53:13 <roconnor>  (d = k^-1 `mod` (p-1))
02:53:47 <roconnor> I gotta go for lunch now;  opqdonut can help you compute k^-1 `mod` (p-1)
02:54:04 <roconnor> but it will be the euclidian algorithm thing again.
02:54:11 <roconnor> like in RSA
02:55:33 <roconnor> t7: BTW primes such that (p-1)`div`2 is prime are Sophie Germain primes, and you find examples are large Sophie Germain primes to use from the internet.
02:55:53 <t7> okey dokey
02:55:55 <roconnor> actually a shophie germain prime is one such that 2*p + 1 is prime ... but whatever
02:56:45 <t7> roconnor: cant i just use expmod again to calc d?
02:58:25 <yitz> nru: maybe not exactly, but: http://cheatsheet.codeslower.com/
03:00:28 <t7> i really dont see how this can work
03:01:01 <t7> nope wait
03:01:06 <t7> ok :)
03:08:18 <t7> still doesnt decrypt :|
03:17:01 <gamowaxaky> pls help me, i can't understand character "!" in this record:
03:17:05 <gamowaxaky> data MP3DataChunk = MP3DataChunk {     chunkBlockType :: !Int,     chunkBlockFlag :: !BlockFlag,     chunkScaleGain :: !Double,     chunkScaleSubGain :: !(Double, Double, Double),     chunkScaleLong :: ![Double],     chunkScaleShort :: ![[Double]],     chunkISParam :: !([Int], [[Int]]),     chunkData :: ![Int]     }deriving (Show)
03:18:02 <gamowaxaky> what "!" for
03:18:24 <MasseR> gamowaxaky: Means that it's a strict data type
03:18:35 <gamowaxaky> ah
03:18:42 <gamowaxaky> thanks
03:21:01 <bitonic> well, it means that that field is strict
03:24:32 <merijn> ivanm: I said wolframalpha produced primes on demand, I didn't imply that it computed them :p
03:27:38 <t7> it works :D
03:32:33 <t7> well sometimes ....
03:37:33 <roconnor> t7: hey I'm back
03:38:13 <t7> roconnor: its non-deterministic at the moment
03:38:20 <roconnor> how so?
03:38:21 <t7> it works 1 in 3 times i guess :)
03:38:43 <roconnor> did you pick a prime based on a SG-prime?
03:38:53 <_mpu> Hi, I'm using Leijen pretty printer to print a language, is there a simple way to print string literals?
03:38:58 <hpaste> t7 pasted “roconner's cipher” at http://hpaste.org/66467
03:39:04 <roconnor> granted using an SG-prime isn't strictly necessary
03:40:01 <_mpu> hum hum, I just remembered show...
03:40:29 <roconnor> t7: can you add a print statment: print $ (k*d) `mod` (p-1)
03:40:51 <roconnor> t7: should always print 1.  If it doesn't then your extEuclGcd is brokenish.
03:41:23 <t7> aha
03:41:26 <t7> you are correct
03:41:40 <t7> wtf...
03:41:58 <roconnor> t7: okay, the thing is that k is not always invertable mod (p-1) (This was also true for RSA)
03:42:28 <roconnor> t7: when you use an SG-prime, it increases the number of available k's
03:42:38 <roconnor> t7: but you still have to check
03:42:46 <t7> oh, whats the restriction on k?
03:43:33 <roconnor> t7: k has to be comprime with (p-1) which is exactly what your extEuclGcd produces
03:43:56 <roconnor> t7: can you print (snd $ extEuclGcd k (p-1))
03:44:10 <roconnor> I think it is the same thing as (k*d) `mod` (p-1)
03:44:32 <roconnor> t7: k has to be comprime with (p-1) which is exactly what your extEuclGcd *can check*
03:44:42 <t7> ah ok
03:45:04 <roconnor> t7: I suspect the check you want to do is that (snd $ extEuclGcd k (p-1)) == 1
03:45:13 <roconnor> t7: but I don't have your code, so i cannot say for sure.
03:46:25 <t7> roconnor: nah i dont think thats the case
03:46:52 <t7> for this function anyway
03:46:54 <merijn> @src pure
03:46:54 <lambdabot> Source not found.
03:46:59 <roconnor> t7: okay
03:47:43 <roconnor> then your check should be that (k*d) `mod` (p-1) == 1
03:47:47 <roconnor> otherwise try k again
03:47:53 <t7> cool
03:48:01 <dobblego> @src pure Maybe
03:48:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:48:05 <roconnor> t7: if you use a prime based on a SG-prime, more k's will work
03:48:10 <dobblego> @src Maybe pure
03:48:10 <lambdabot> pure = return
03:48:16 <dobblego> @src Maybe return
03:48:16 <lambdabot> return              = Just
03:48:24 <roconnor> t7: how big of a prime do you want to use?
03:48:30 <t7> vairable
03:48:49 <t7> enough so all the computers in the world cant break th encryption within an hour
03:49:20 <roconnor> you might as well pick a constant prime
03:51:24 <merijn> @src ((->) r) pure
03:51:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:52:27 <roconnor> t7: rfc 2412 suggests
03:52:29 <roconnor> 24103124269210325885520760221975660748569505485024599426541169419581088316826122288900938582613416146732271414779040121965036489570505826319427307068050092230627347453410734066962460145893616597740410271692494532003787294341703258437786591981437631937768598695240889401955773461198435453015470437472077499697637500843089263392955599688824578724129938101291302945929999479263652640592846472097303849472116814344647144384885209401274598442888593
03:52:30 <roconnor> 36526896320919633919
03:52:56 <osa1> which package for fixed-width arrays? do we have any mutable array-like data structures?
03:52:57 <t7> I dont mind generating
03:53:02 <t7> takes less than a second]
03:53:08 <roconnor> t7: at the moment you are not using sgPrime
03:53:15 <dobblego> merijn: \f g x -> f x (g x)
03:53:18 <merijn> osa1: Multiple even I think uarray or something like that
03:53:22 <t7> yeah i tried it
03:53:35 <dobblego> er sorry
03:53:39 <dobblego> pure = const
03:53:52 <merijn> osa1: Also, Data.Array
03:54:01 <roconnor> t7: BTW you need to use (2*p +1) instead of p
03:54:08 <roconnor> t7: from sgPrime
03:54:20 <t7> i do
03:54:34 <roconnor> t7: ie. the smaller prime is the sophie germain prime; however you want to use the larger prime in your work
03:54:39 <t7> isSGP <- isPrime (2 * p + 1)
03:54:56 <roconnor> t7: ya, but 2*p+1 isn't what you return in the next line
03:54:57 <t7> ok this is taking ages with 1024 key
03:55:13 <roconnor> I don't think sg-primes are that common
03:55:17 <t7> 2 * p + 1   hasnt been checked
03:56:39 <t7> roconnor: is it insecure if i dont use an SG prime?
03:57:19 <roconnor> t7: not exactly.  it is simply as secure as possible with an SG prime.
03:57:54 <roconnor> t7: the security is related to the number of choices of k available and SG-primes produce the maximum choices of values for k.
03:58:32 <t7> im just scared that with a constant p, someone has a long time to calculate all the keys
03:58:39 <Rc43> Hi, guys.
03:58:52 <t7> if p changes every hand then they have less time
03:59:38 <Rc43> Can I use pattern matching by data fields? Like this (pseudo-code): `mouseHandler {eventButton == RightButton} = ...`
04:00:29 <roconnor> t7: the k changes every time; knowing p in advanced is not helpful for an attacker.
04:08:20 <t7> have you just re implemented rsa?
04:08:33 <t7> there is no q
04:10:59 <sipa> roconnor: wait what? are we talking about RSA?
04:11:10 <sipa> an attacker knowing p kinda breaks everything, no?
04:11:19 <t7> sipa not if you change E
04:11:25 <t7> we talked about this yesterday :)
04:11:37 <t7> e and d can be like private keys
04:15:52 <Franciman> hey people, I'm writing a "small" compiler for a language, now I must represent types
04:16:02 <Franciman> what's the best way to do that?
04:16:15 <Franciman> ADT or typeclass with a lot of ADTs ?
04:17:49 <Franciman> for example : data Function =....
04:17:53 <Franciman> data Numeric = ....
04:17:59 <Franciman> class Type where ...
04:18:03 <Franciman> and then a lot of instances
04:18:12 <Franciman> or just Type = Function | Numeric
04:18:13 <Franciman> ?
04:19:33 <t7> @hoogle fromBase
04:24:11 <roconnor> t7 it is like RSA with no q
04:24:35 <roconnor> sipa: we are not doing RSA, we are doing non-public crypto over Z_p
04:24:40 <t7> isnt q important :3
04:25:00 <roconnor> t7: q is only important for public-key crypto
04:26:55 <bombel8> hi
04:27:23 <mekeor> hi, bombel8
04:29:26 <ique> where has lambdabot gone?
04:29:34 <mekeor> oO
04:29:54 <ique> or am I blind?
04:30:02 <mekeor> ique: he's in the toilet…
04:30:15 <ique> Oh well.. I guess even robots have their needs
04:30:34 <Franciman> lol
04:30:49 <osa1> how can I set an index of Data.Array.UArray? // increments the indexes but I just want to set it
04:33:28 <osa1> whatever, I think I just use increment operation
04:33:30 <mekeor> Franciman: i think it depends on whether you have to handle functions and numerics in different ways. and as i think so, i'd personally prefer the ADT-way… are you writing a compiler for a (complex) calculator (prog-lang) or so?
04:33:55 <t7> is there a logBase for Integers?
04:34:06 <Franciman> mekeor yes for a programming language
04:34:34 <mekeor> Franciman: a programming languages only with functions and numerics?? oO
04:34:40 <Franciman> no lol
04:34:57 <Franciman> that was just an example I didn't feel like writing all the types
04:34:58 <t7> back im my day we only had functions
04:35:01 <t7> and we liked it
04:35:06 <mekeor> Franciman: ok
04:35:48 <Franciman> actually using a typeclass would not make much sense to me
04:35:54 <Franciman> but I have a problem
04:36:12 <Franciman> since in a Expression constructor, the FunctionLiteral
04:36:23 <Franciman> I need a FunctionType and a Block
04:36:38 <Franciman> now I should write a new type for that FunctionType
04:37:02 <osa1> does anyone know a function with type of Word8 -> Char ?
04:37:05 <Franciman> and that doesn't sound very nice to me
04:37:26 <sipa> @hoogle Word8 -> Char
04:38:01 <merijn> These two statements are identical, right? (result wise) "(+) <$> (*2) <*> (+10)" "uncurry (+) . ((*2) &&& (+10))"
04:38:05 <Franciman> mekeor, what do you think about this?
04:39:35 <mekeor> Franciman: nothing because i don't understand it. sorry. (but it's probably my fault since i'm not (very) experienced with compiler-programming… (i just once wrote/tried_to_write a calculator (with HOFs). that was cool!))
04:39:50 <Franciman> :)
04:40:00 <Franciman> mekeor, I have this ADT
04:40:07 <Franciman> Type = FunctionType | NumericType
04:40:13 <mekeor> ok
04:41:03 <Franciman> and this : Expression = SomeTypesOfExpr .... | FuncLiteral (Here I Need a Function Type ) Block ( List of Stmts )
04:42:47 <Franciman> mekeor, now Where I need the Function Type, should I create a new type to describe it?
04:43:59 <zeiris> Is anyone familiar with Trifecta? I'm trying to detect two types of assembly-style comments, standalone (on their own line alone) vs end-of line: https://github.com/amtal/0x10c/blob/master/DCPU16/Assembler/Parser.hs
04:44:22 <zeiris> The problem is I'm using a lot of parsers that strip following "whitespace" after they're done... And that apparently includes \n.
04:45:17 <zeiris> So, I tried splitting by \n before those parsers get working - but apparently the lowermost level parser takes priority over top-level "splitBy myParser newline" stuff.
04:45:32 <mekeor> Franciman: why should you?
04:45:59 <mekeor> Franciman: i mean, i don't see any reason to create a new type for the same thing…
04:46:06 <merijn> @src (<$>)
04:46:13 <merijn> @src Maybe (<$>)
04:46:15 <mekeor> fmap
04:46:21 <mekeor> merijn: lambabot is away
04:46:22 <merijn> Oh wait, lambdabot is down >.>
04:46:30 <Franciman> mekeor in fact
04:46:40 <Franciman> oh maybe I found the fault
04:46:50 <merijn> mekeor: It's the same a "(<*>) . pure", right?
04:46:51 <mekeor> nice
04:46:52 <Franciman> yes I have
04:48:06 <Franciman> mekeor, that FunctionType defines the type of the FunctionLiteral, so I'll put it somewhere else, where I put together types with expression
04:48:17 <Franciman> and this makes sense
04:48:39 <Franciman> ( well actually it doesn't lol, but I have gotten the fact )
04:49:46 <mekeor> merijn: you mean:  a <$> b = pure a <*> b -- right? yes, i think so. but actually you are a more experienced haskeller, so you should know better =)
04:50:23 <Franciman> OOP has definetely plagiarized me
04:51:01 <Franciman> and maybe writing a compiler as first haskell program isn't a good idea. Never mind
04:51:32 <t7> @hoogle List a -> Bool
04:53:32 <merijn> mekeor: I never really looked into the whole applicative stuff before :p
04:54:25 <mekeor> Franciman: write a calculator first. then, a calculator with HOFs. and then join #idris and work on Idris' compiler! =)
04:54:35 <Franciman> I'll do
04:54:37 <Franciman> :)
04:55:29 <mekeor> Franciman: there's a chapter in LYAH which shows how to write a RPN-calculator.
04:55:44 <mekeor> Franciman: actually, that syntax is quite cool and especially easy to programm.
04:56:13 <Franciman> yes I read it
04:56:39 <Franciman> that's very cool
04:56:44 <mekeor> indeed
04:58:40 <t7> @hoogle (Num a, Num b) => Int -> Int -> [a] -> [b]
04:58:49 <Franciman> hey I cannot use pattern matching in a constructor, can I ?
04:59:33 <merijn> You can if you use GADTs, I think. But not in general, no
04:59:43 <Franciman> k, thanks
05:00:32 <hpc> merijn: you can pattern match in a GADT constructor?
05:00:52 <zhulikas> there is also a simple concept here: http://www.haskell.org/haskellwiki/Smart_constructors
05:01:01 * quicksilver isn't sure he understand Franciman's question.
05:02:09 <merijn> hpc: You could write custom constructors as normal functions for those, right? Or am I misremembering?
05:02:13 <merijn> Probably the latter
05:02:58 <merijn> Ok, no I'm confusing different things
05:03:02 <merijn> Pretend I didn't say anything
05:03:05 <Franciman> quicksilver forcing one parameter of the constructor to be constructed with a chosen c'tor ( very c++ like yeah )
05:03:06 <mekeor> when you do "data Foo = Bar | Baz" you can do "f :: Foo -> Bool", "f Bar = True", "f Baz = False".
05:03:14 <t7> http://stackoverflow.com/questions/10028213/converting-number-base   get yer karma!
05:03:28 <quicksilver> Franciman: no. When you need to do that you probably want to break that type up
05:03:34 <quicksilver> Franciman: so each constructor is a separate type.
05:03:42 <quicksilver> (this is a pain in some ways, it's a trade off)
05:03:56 <quicksilver> there was a paper written about taking this to its logical conclusion, called "Data Types a la Carte"
05:04:11 <quicksilver> on the other hand GADTs with phantom types do offer a possible workaround
05:04:16 <quicksilver> which might or might not be why merijn said it :)
05:04:32 <Franciman> and what if I then, needed to use this again as an ADT?
05:04:49 <hpc> whoa, GADT record syntax is strange
05:04:49 <quicksilver> you have an 'over-arching' ADT that joins them back together.
05:04:50 <Franciman> oh ok
05:05:09 <Franciman> hmm ok
05:05:22 <quicksilver> data Bar = Bar Int; data Foo = Foo Char; data ADT = BarC Bar | FooC Foo
05:05:31 <quicksilver> it's a pain because you have one more level of unwrapping to do all the time.
05:05:47 <quicksilver> (you might sensibly make those first two datas into newtypes but that doesn't solve the problem)
05:05:50 <Franciman> well that can be arranged with a typeclass
05:06:06 <quicksilver> yes, typeclasses may help do some parts implicitly.
05:06:11 <hpc> usually you can get away with 'type ADT = Either Int Char'
05:06:44 <quicksilver> hpc: well my example was too simple then.
05:06:55 <hpc> :P
05:06:59 <quicksilver> but yess you might make do with anonymous types - like tuples - for the content.
05:07:12 <quicksilver> Franciman: anyhow, read the article linked from http://lambda-the-ultimate.org/node/2700 if you're interested, I think it is an easy read.
05:07:28 <quicksilver> not read it for a long time but I think it discusses some of the alternatives and their trade-offs at least a bit
05:07:50 <Franciman> nooo 303
05:07:52 <Franciman> *404
05:08:35 <hpc> nooooooooooo!
05:08:39 <hpc> i wanted to read it too
05:09:01 <hpc> http://www.cs.ru.nl/~wouters/Talks/DutchHug2011.pdf -- this?
05:09:05 <mekeor> it works fine
05:09:12 <quicksilver> http://scholar.google.co.uk/scholar?cluster=14508320021753284805&hl=en&as_sdt=0,5
05:21:11 <hpaste> killy9999 pasted “How to improve this code?” at http://hpaste.org/66468
05:22:22 <killy9999> is there a way to avoid calling dropWhile twice in my code?
05:26:37 <ivanm> killy9999: use filter? :p
05:27:56 <bombel8> steps i did to install GHC 7.4.1 on 10.7 https://gist.github.com/2309766 did i missed something ?
05:36:30 <mekeor> why does https://github.com/nfjinjing/haskore-guide/blob/master/doc/install.markdown not work for me? (i'm using linux.) in particular, i can't load the module "Haskore" after having installed it with "cabal install haskore". (my $PATH is correct.)
05:46:43 <_mpu> My ghc complains about fields of a record which are not used in my code, can I mute this warning only.
05:47:08 <_mpu> Or is there a way to define a record type with some unnamed fields?
05:48:42 <romildo> Can ghc show the type inferred for each variable when it compiles a module?
05:49:01 <merijn> romildo: You can load it in ghci and use ":t"
05:51:41 <romildo> merijn, yes, but I was thinking that ghc could have an option to do that automatically, without the need to use ghci.
05:52:28 <dixie> great, after reinstalling back to 32bit from 64bit linux on my 2GB RAM machine... I'm again able to compile & link the wxcore :-)
05:53:46 <dixie> thanks for help, #haskell
06:02:05 <dzhus> should I include README for my cabal package as extra-source?
06:03:00 <bitonic> dzhus: I would strive to put most documentation in the form of haddock comments and cabal description
06:03:26 <bitonic> but yeah if you really need a README I guess that would work (but maybe there is a better way)
06:05:06 <ique> I'm getting frustrated with Haskell strings :P There's like 100 different strings..? Anyway.. I need to convert from Data.CompactString.Encodings.UTF8 to Data.Text.Encoding.Text.. anyone has an idea of where to start looking?
06:05:47 <bitonic> ique: yeah it is frustrating
06:06:04 <Saizan> i thought CompactString was obsolete atm
06:06:19 <bitonic> ique: CompactString has an unpack method
06:06:19 <Saizan> anyhow you probably need to go through ByteString for that
06:06:32 <ique> Saizan: it's what mongoDB is using, so I have to use that in order to read from the DB :/
06:06:39 <bitonic> ique: and a toByteString as well
06:06:57 <ique> bitonic: oh really.. well that would be neat!
06:07:40 <bitonic> ique: you probably want to use 'encode' specifying UTF8 explicitly
06:08:02 <ivanm> dzhus: yeah
06:08:25 <ivanm> there really should be (optional) README, ChangeLog, etc. fields
06:09:40 <ique> bitonic: thanks! found all the necessary methods now.. I don't know why I didn't see that, I thought I looked at the docs
06:10:16 <bitonic> ique: yw. but anyways yes haskell "strings" are quite a mess. I wonder why the mongo driver still uses that...
06:10:46 <bitonic> ique: now the situation is more stable, but you still have two "main" types (String and Text)
06:10:57 <bitonic> and ByteString for binary data
06:11:38 <ique> well that's more reasonable I guess.. if you want to optimize one is obviously better than the other for different situations
06:11:58 <ique> but is seems awfully fragmented and some people use the more "optimal" when the situation really doesn't call for it
06:12:35 <ique> but then again I don't know the details of the situation, might be different reasons than I imagine
06:12:59 <bitonic> ique: well tbh you almost never want to have Strings in applications that need to be performant at all
06:13:04 <romildo> How can someone find out which type ghc inferred for a local variable (defined in a let or do expression, or with where, for instance)?
06:13:17 <bitonic> romildo: you mean in a source file? there is no easy way, sadly.
06:14:26 <romildo> bitonic, yes, when it compiles a module (from the source code file).
06:14:30 <bitonic> it's *probably* possible with the GHC API, but even if it is, I don't think there's a tool that makes the process easy
06:17:04 <bitonic> romildo: the easies way is to define the value as a top level function, I'm afraid
06:17:13 <bitonic> *top level value
06:18:52 <romildo> bitonic, but in most cases that is not possible, as it may depend on other variables not available at the top level.
06:19:17 <bitonic> romildo: you can pass those variables as arguments.
06:20:45 <bitonic> romildo: you also need to consider the monomorphism restriction when reasoning about the type of something bound in a let/where
06:36:28 <t7> @hoogle Int -> [a] -> [a]
06:36:41 <t7> lambdabot?
06:46:45 <hpaste> t7 pasted “commutative encryption” at http://hpaste.org/66471
06:46:52 <t7> roconnor: check it out :)
06:47:17 <t7> so simple :)
06:48:17 <roconnor> t7: getKey should be named genKey
06:48:53 <roconnor> encryptBS is dangerous since it doesn't use block chaining
06:50:29 <roconnor> t7: I really recommend using a constant prime.
06:50:41 <t7> yeah i will add some
06:50:44 <roconnor> t7: nice work
06:50:52 <t7> where did you find the ones online?
06:51:14 <roconnor> t7: rfc 2412
06:52:30 <roconnor> also check out rfc 3526 for even larger primes
06:54:18 <roconnor> I beleive all the primes in rfc 3526 are "safe" primes
06:54:30 <roconnor> http://en.wikipedia.org/wiki/Safe_prime
06:54:44 <t7> roconnor: are they sophie g ones?
06:54:56 <t7> yes
06:54:58 <t7> cool
06:54:59 <roconnor> t7: they are the ones related to SG-primes yes
06:55:18 <roconnor> t7: but you can always double check that (p-1)`div`2 is prime yourself
06:55:58 <roconnor> 183027*2^265441-1 is the largest known safe prime ... you could use that :P
06:56:34 <roconnor> that would give you the most safety possible with this method at this point in time.
06:56:56 <roconnor> ... although it would also give you the highest computation time as well.
06:58:08 <roconnor> t7: according to wikipiea the largest discrete log problem ever solved was over a 530 bit prime field.
06:58:31 <t7> does it say the time to solve
06:58:32 <bombel8_> how do you deploy to produciton website written in snap or happstack ?
06:58:48 <t7> bombel8_: deploy what? the executable?
06:59:15 <bombel8_> lets say i developed it on OSX and i have a Linux server and i want to deploy my code to it with all the assets etc
06:59:33 <t7> you need to compile on a linux computer too
06:59:36 <bombel8_> executable + assets, whole package or even source and build it ip on server
07:00:16 <t7> bombel8_: you only need to exe and the public folder i think
07:00:18 <bitonic> bombel8_: you need to compile the binary on the server or on a machine with a similar system
07:00:20 <t7> if your using snap
07:00:21 <bombel8_> actually i could build it on server my question is more, is there a tool that handles the process for you like capistrano for ruby or vlad or any other deployment automation tool.
07:01:05 <bitonic> bombel8_: for example I was able to compile executables on my desktop linux for my linux server
07:02:00 <hpc> why not svn and a makefile?
07:02:08 <bitonic> svn?
07:02:10 <bombel8_> yes i get this part clear, my question is is there a tool that i can configure to do all the junk for me, because i have to build executable, build js from coffee script and then i have to upload it to 2 webfront boxes and restart servers
07:02:16 <bombel8_> i'm using git for source control
07:02:23 <bitonic> bombel8_: I don't think there is a ready made tool
07:02:30 <bombel8_> ok
07:02:43 <bombel8_> i will try to wrapp something, i just started and wrote simple things
07:02:48 <bombel8_> i think snap is nice.
07:03:00 <osa1> is Identity monad only useful for getting monads of monad transformers?
07:03:00 <bombel8_> it is easier for me to learn haskell on real life examples
07:03:27 <hpc> osa1: it's also useful as a teaching tool :P
07:03:46 <hpc> (more seriously, i don't know of any other uses)
07:04:48 <quicksilver> does it add an extra point of laziness maybe?
07:05:02 <hpc> no, identity is a newtype
07:05:07 <osa1> hpc: thanks. I'm wondering if there could be any points using lift inside of State or other monads(but not monad transformers), do you have any ideas?
07:05:07 <hpc> last i checked
07:05:29 <roconnor> t7: it doesn't clearly say.  I think though the issue isn't so much time as it is memory.
07:05:51 <hpc> osa1: instead of writing myPureAction = let..in return foo
07:06:03 <hpc> myPureAction = lift $ do ...
07:06:30 <hpc> assuming "..." is large enough to make it worth the transformation
07:06:34 <mk> what does newtype do?
07:07:08 <roconnor> sipa: what do you think is safer, using a constant safe-prime or picking a new prime every game?  With a constant prime one might set up a seive using a super computer to solve discrete logarithms, but computing a safe-prime each game is time consuming (I think)?
07:07:29 <hpc> mk: defines an "isomorphism"
07:07:42 <mk> hpc: between what?
07:07:43 <sipa> roconnor: i don't think i know enough about it to judge
07:07:56 <hpc> the difference between it and data is in handling bottoms
07:08:13 <hpc> data T = V X
07:08:32 <hpc> V undefined is different from undefined
07:08:38 <yitz> roconnor: picking a safe prime once per run is fast, if you do it right. just annoying to include that extra code.
07:08:39 <hpc> newtype T ...
07:08:47 <dobblego> (IdentityT f a) is helpful for constraining f to instance some type-classes
07:08:48 <roconnor> yitz: is it?
07:08:50 <hpc> now V undefined is undefined
07:08:53 <roconnor> I don't know how rare safe primes
07:08:54 <roconnor> are
07:09:06 <yitz> ah what is the criterion?
07:09:14 <t7> can i get jhc todo multiline?
07:09:18 <roconnor> yitz: (p-1)`div`2 is prime
07:09:21 <t7> ghci*
07:09:27 <bscarlet> mk: one alternate/additional way to think about netype is that it's similar to data, but can get compiled away (so it can be more efficient), but works only for constructors with one argument.
07:09:33 <yitz> roconnor: and a certain size, i assume
07:09:46 <yitz> roconnor: so one of those sophie things
07:09:51 <roconnor> yitz: ya
07:09:59 <mk> I'm looking at the ContT newtype in particular...
07:10:00 <mk> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Cont.html#cont
07:10:11 <roconnor> yitz: size needs to be big enough to be safe
07:10:13 <hpc> GHC does what bscarlet describes
07:10:20 <hpc> but it isnt guaranteed
07:10:24 <roconnor> greater than 530-bits, and probably at least 1024 bits.
07:10:30 <mk> can I roughly treat that as data?
07:10:31 <yitz> roconnor: if you've got a good primality tester handy, it's not hard to check i suppose
07:10:40 <yitz> roconnor: how rare they are
07:10:48 <roconnor> I don't know how rare they are
07:10:52 <hpc> mk: yeah
07:10:58 <roconnor> I kinda think they are quite rare
07:11:09 <bscarlet> hpc: (that was why I limited my statement to "can be")
07:11:10 <roconnor> so much so they produce RFCs with lists of safe primes
07:11:10 <hpc> mk: data and newtype differ only in the number of bottoms
07:11:18 <yitz> roconnor: right, just start generating a whole bunch of big primes and test them for sadiality
07:11:28 <t7> i wonder how many possible keys are in a 2048 bit prime
07:11:32 <yitz> roconnor: see how many you get
07:12:24 <yitz> oh it's sophiality
07:12:28 <yitz> whatever
07:13:12 <mk> what do the {} braces mean? I understand what something like data Something a = Something a does, but this has the much more confusing newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
07:13:13 <roconnor> t7: there are ((p-1)`div`2 - 1)) keys for a safe prime p IIRC.
07:13:30 <roconnor> t7: so about half of them
07:13:32 <bscarlet> mk: the braces work for both data and newtype. It's called record syntax.
07:13:35 <hpc> mk: that's just record syntax
07:14:01 <mk> oh, I see, right. I'll look closer
07:14:09 <hpc> newtype ContT r m a = ContT ((a -> m r) -> m r)
07:14:09 <yitz> roconnor: wikipedia article gives an estimate due to hardy and littlewood
07:14:12 <t7> sounds safe enough
07:14:15 <hpc> runContT (ContT t) = t
07:14:54 <yitz> roconnor: O(n/(log n)^2)
07:15:00 <yitz> not too bad
07:15:23 <mk> I see - thanks
07:15:25 <bscarlet> mk: so that syntax, especially for newtypes, is an idiom for writing a deconstructor function along with a constructor.
07:15:42 <t7> roconnor: whats the smallest e i should allow?
07:15:52 <t7> 2 like rsa?
07:16:33 <mk> bscarlet: deconstructor? A getter?
07:18:19 <roconnor> t7: probably
07:19:28 <bscarlet> mk: in a case where there's only one member (e.g. a newtype), it's the same. I wouldn't actually use "getter" personally ('cause in my brain it's filed under OO languages), but it does apply. I'd use "deconstructor" for taking apart a constructor - i.e. a getter when there's only one member, or for patterns in a case clause which similarly allow access to members.
07:21:30 <mk> bscarlet: right. Deconstructor sounds strange to me because a constructor is simply used to "get to" a value, on the basis of values you already have access to (like primitives)
07:23:48 <mk> ...as opposed to "building" somethin. So I guess there's not much to "deconstruct". Lots of haskell terminology (and the notation) is a somewhat confusing
07:24:24 <bscarlet> mk: a constructor gives you a whole from parts, a deconstructor gives you the parts from the whole.
07:25:29 <mk> bscarlet: yes, though I don't see the constructed value as a whole. Thinking of values as ever being composite is problematic, I think.
07:25:56 <mk> in any case, I do get the analogy you're getting at :)
07:26:00 <bscarlet> mk: problematic how?
07:27:51 <mk> bscarlet: because it's much clearer to think about a value as a single dot that you can put through functions. If you think of some values as containers for other values, you are always thinking about the implementation
07:29:50 <bscarlet> mk: I'm not sure if I should object to the idea that only "single dot"s could go through functions, or to the idea that a composit value isn't a "single dot". :-)
07:30:06 <mk> [1 2 .. 99] seems to "contain" 99 values, but it's really just a dot that when fed to first returns 1 and when fed to rest returns [2 3 ... 99]. It might be implemented as a function, or as an array, but that doesn't matter- you shouldn't think about it
07:30:59 <mk> bscarlet: "single dot" is just meant to get the general idea of an "atom" across without using that terminology ;)
07:31:25 <bscarlet> mk: but functions most definitely do not act only on atoms.
07:31:52 <mk> other functions and so-called composite values are just dots too
07:32:40 <bscarlet> mk: if you leave off the "so-called", there's no problem.
07:33:31 * hackagebot snaplet-redson 0.1.0.0 - CRUD for JSON data with Redis storage  http://hackage.haskell.org/package/snaplet-redson-0.1.0.0 (DmitryDzhus)
07:33:59 <mk> bscarlet: are infinite lists composite?
07:36:05 <merijn> mk: Lists are by definition composite, even finite ones
07:36:16 <merijn> A list is just "a value + remaining list"
07:38:15 <mk> merijn: I don't know about that. I think it's strange to define a value in reference to the particular constructor used. Different constructors might define the same value (though this isn't quite the case in haskell) - even the same constructor might define the same value (Degree 360 = Degree 0)
07:39:05 <bscarlet> mk: I don't think it helps the discussion to bring in more abstract notions of "same".
07:40:20 <mk> bscarlet: all our notions of "same" are abstract, but I think the notion of same on which two values are the same if they produce the same result for all functions is the right one
07:41:47 <quicksilver> and it is certainly possible to define types, mk, in which different constructor arrangements are "the same" by your definition.
07:42:26 <quicksilver> an example of such in the standard libraries is "Data.Map" which may come out slightly differently configured depending which order elements are inserted but is still "the same" via all observations.
07:42:30 <Ptival> mk: is a quick sort the same as a bubble sort?
07:42:43 <quicksilver> that's the point of abstract data.
07:44:53 <mk> Ptival: though there's the point about it being impossible to determine if two functions are the same, if both are stable sorts, then yes they are. Value is distinct from the structure used to represent the value
07:47:13 <bscarlet> mk: why is any one "right"? For that matter, why do we need a notion of same for this discussion? All we're talking about is a point of intuition: whether it does or does not help to _think_ about values as somehow "composit", which in turn got started because I used the term "deconstruct". Reverting to my original term, I'd say I use the term "deconstruct" for anything which could have a pattern with fields, and by analogy would use the term "deconstruc
07:47:15 <bscarlet> tor function" for a function like (\ such-a-pattern -> x).
07:47:15 <Ptival> mk: strange for you to be talking about stable sort while you consider equal values the same :\
07:47:54 <Saizan> observational equality is good, (non-quotiented) algebraic data types have the other cool property that it's the same as intensional equality, so it's fine to talk about how values are constructed
07:48:37 <Saizan> i guess i should add "polynomial" there
07:48:52 <t7> @hoogle replicateM
07:48:54 <mk> Ptival: two list values which return different values when passed to first() aren't the same
07:49:08 <t7> Cale !
07:49:13 <bscarlet> mk: I'll leave out the question of whether I should or shouldn't use the term for patterns without fields, which I think can be a separate question.
07:50:21 <mk> bscarlet: well, you asked me why I thought it was problematic. I do see how the construction/deconstruction analogy works, as I said
07:51:20 <timthelion> The set function of gtk2hs belongs to monadlib?
07:51:37 <dcoutts> timthelion: no it's from glib
07:52:19 <bscarlet> mk: yep, thanks. I confess I don't understand yet what you think is problematic, but neither do I see any major contradictions unless you think I'm somehow failing to see an inconsistency in my own thinking which you do see.
07:53:34 <timthelion> dcoutts: OK, I'm trying to figure out how to get the coordinates of a VBox.
07:53:58 <mk> bscarlet: hmm. If you defined a constructor that took a pair of ints, and a constructor that took an int and a degree (ratio), could those ever produce the same values?
07:54:02 <dcoutts> timthelion: it'll be something generic of widgets
07:54:10 <Ptival> for me construction/deconstruction match the idea that there is a tag attached to the composition of values
07:55:26 <mk> Ptival: a tag?
07:55:50 <Saizan> mk: i think the mismatch is that we typically want to allow a coarser notion of equality only when the datatype is abstract, i.e. the constructors are not exported from the module implementing it
07:56:01 <sipa> > 9 `xor` 4
07:56:24 <Saizan> mk: when the constructors are exported we use the structural equality instead
07:56:42 <Ptival> mk: like "Just", or "Cons"
07:56:46 <bscarlet> mk: you mean something like data Foo = FooA Int Int | FooB Int Rational? I'd no - because case f of FooA _ _ -> ...; FooB _ _ -> ... could distinguish them.
07:56:51 <Saizan> mk: because we can always write functions to distinguish between different constructors via pattern matching
07:56:53 <mk> Saizan: well, I'm not sure why our definition of equality and value should depend on modules...
07:57:05 <Saizan> mk: my last point
07:57:25 <mk> bscarlet: well, they should be indistinguishable for some values
07:57:50 <bscarlet> mk: what determines "should"?
07:58:30 <mk> under some interpretations. For example, xy(0, 10) should equal len-rot(10, 90deg), when we're talking about point values
07:59:25 <Saizan> the problem might be that in typical OO languages data abstraction is kind of enforced by default when you define the type
07:59:41 <Saizan> while in haskell that concern is delegated to modules
08:00:14 <mk> Saizan: if a data abstraction is a value, then I see what you mean
08:00:27 <Saizan> no
08:00:52 <Saizan> by data abstraction i mean the practice of hiding the representation of a type
08:01:12 <mk> is a representation of a type a value?
08:01:30 <bscarlet> mk: there's one level of abstraction at which they are distinguishable, and a potentially useful higher level of abstraction at which it might make sense to keep them from being so. Whether or not a value is composit, and the notion of deconstruction, make sense at the lower level, as concepts about values in the language Haskell - not at the higher level, as concepts about what you're using Haskell to accomplish.
08:01:42 <Saizan> not a particular value, but how such values can be structured
08:02:53 <mk> Saizan: right, so the abstraction itself (getX() or whatever) is taken to be the value, while the implementation (which fields are used) isn't
08:03:11 <Saizan> and, btw, there are plenty of types for which exposing the representation is the right thing to do
08:03:47 <bscarlet> mk: and you might use a module boundary to enforce constraints required by the higher level abstraction in certain code - i.e. code not implementing the higher level in terms of the lower, but rather using the higher to get something else done.
08:03:52 <mk> bscarlet: yeah, I get that, but this mixes up two notions of equality, in the way that java's == and equals() do
08:04:05 <bscarlet> mk: what's equality got to do with it?
08:04:16 <mk> Saizan: interesting - which types?
08:04:42 <Saizan> mk: lists, Maybe, Either, binary trees, etc..
08:04:55 <bscarlet> mk: for the concepts I'm describing, you only need the notion of whether a value matches a pattern.
08:04:57 <mk> bscarlet: tons - values are distinguished based on value equality, while structures are distinguished based on performance equality
08:05:03 <quicksilver> Saizan: but not balanced binary trees, perhaps :)
08:05:14 <Saizan> right
08:06:06 <Saizan> mk: basically all those types which are not maintaining extra invariants on top of what's guaranteed by their representation as haskell allows us to define it
08:06:11 <mk> Saizan: I'm not sure why exposing the representation in, for example, a list, is useful
08:07:31 <Saizan> mk: first of all it's fine, because it's not exposing anything more than what a sensible interface would do, and on top of that it works well with the algebraic style of programming
08:07:53 <Saizan> i.e. with plain data scrutinized by functions
08:08:02 <mk> (unrelated, but I've been meaning to ask for a while) is there any monad that has a return which is not defined essentially as a simple constructor that merely takes the type?
08:08:55 <Saizan> mk: State for example
08:09:28 <mk> Saizan: where can I find that? Control...?
08:10:32 <Saizan> @hoogle StateT
08:10:39 <Saizan> no bot?
08:11:19 <timthelion> > reverse "raeh m'I oN"
08:11:29 <Saizan> mk: anyhow, newtype State s a = S (s -> (s,a)); and return x = S (\ s -> (s,x))
08:11:37 <timthelion> No bot
08:12:12 <mk> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-State-Lazy.html
08:13:26 <Saizan> yes, that
08:14:43 <mk> return a = StateT $ \s -> return (a, s) -- this looks similar or identical to the StateT constructor
08:15:03 <mk> which is s->m(a,s)
08:15:55 <Saizan> the StateT constructor is StateT
08:16:00 * timthelion has now tried google, duckduckgo, clusty, hayoo, hoogle, AND bing.com and still cannot find any information on how to use glib's get.
08:16:49 <mk> Saizan: right - return seems to just be calling it (though using $, I'm unsure why, and it's also recursive?)
08:17:29 <srhb> When I use record syntax I get functions named like fields that pull a specific record out of a data type, but can I also get functions that recreate the datatype only with a specific field changed?
08:17:29 <Saizan> mk: the lambda and the tuple are not part of the StateT constructor, and it's not quite recursive because the inner one is return for the other monad
08:19:07 <quicksilver> srhb: you get syntax for that, but not a function.
08:19:14 <quicksilver> srhb: foo { bar = 3 }
08:19:23 <Saizan> mk: though the idea that return won't do much except store the given value somewhere is not a bad intuition (for a sufficiently wide notion of store), it just doesn't have to be a plain constructor though
08:19:24 <srhb> quicksilver: Oh, that is excellent, thank you!
08:19:26 <quicksilver> srhb: the "function" is then \x -> foo { bar = x }
08:19:44 <srhb> Yes, thanks, the syntax is sufficient :-)
08:19:45 <quicksilver> srhb: it's annoying syntax because it's hard to abstract it. If you make heavy use of records then lenses are worth learning.
08:20:02 <srhb> It will be light usage for now, I'm sure I'll come running if it gets annoying.
08:20:34 <quicksilver> srhb: once you have nested records you get this abhorrence: \x -> foo { bar = bar foo { baz = 3 } }
08:20:46 <timthelion> dcoutts: can you help me out just one more time?  So I found that I need to get the Widget's Rectangle.  Unfortunatly, I cannot find any documentation on how to get such an attribute.
08:20:48 <srhb> Ugh. I don't think I will need that though. Or I hope not.
08:21:34 <mk> Saizan: well, at the very least return *must* store the value (except in the case of Trivial)... I'm just wondering if or why some returns do more than that
08:21:46 <shergill> how do you tell cabal where to find imports? the equivalent of ghc's -i
08:22:40 <shergill> oh i'm dumb
08:22:43 <hpc> shergill: try "cabal configure --help"?
08:23:05 <dcoutts> hpc: that wouldn't help, it's the .cabal file docs he'd want
08:23:30 <Saizan> mk: well, not sure about more, but State does something different because you can't take the "value" out as easily for example
08:24:14 <mk> what do you mean?
08:24:21 <timthelion> anyone have any ideas what I might google to get an example of how to get any kind of attribute of a gtk Widget?
08:24:32 <timthelion> I'm looking for haskell syntax
08:24:53 <mk> I haven't quite looked, but I know that there must be a trivial way to get the value, because bind needs it
08:25:06 <Saizan> not so trivial
08:25:09 <dcoutts> timthelion: gimme a sec...
08:25:27 <mk> Saizan: oh?
08:25:31 <Saizan> you need a "current state" to supply it
08:26:04 <Saizan> so get an 'a' out of (s -> (a,s)) you've to give it an 's'
08:26:13 <Saizan> *to get
08:26:32 <mk> I don't follow (I'm still not sure how many of the monads work - my vague idea for state is that it stores the value in a closure?)
08:26:54 <Saizan> do you know how functions work?
08:27:05 <DanBurton> I've been interested in being a student for gsoc this year, but I thought I might be too late. Are there still mentors that are looking for students?
08:27:18 <mk> Saizan: for some definitions of know and work :)
08:27:58 <Saizan> mk: well, if you have a function (A -> B) and want to get a B you need to supply it an A, right?
08:28:26 <mk> Saizan: sure. Where A and B are arbitrary types, not values
08:28:32 <Saizan> mk: yep
08:29:59 <Saizan> mk: so, since return produced a function from S to (S,A), and we want the value of type A in there, we have to apply it to a value of type S
08:31:09 <dcoutts> timthelion: widgetGetAllocation
08:31:24 <mk> right, but we need to have the specific value of s which returns the specific value of a, otherwise bind can't get the right a out when it needs to
08:31:50 <bscarlet> mk: what does "right" mean?
08:32:11 <timthelion> dcoutts: ok, thank you.
08:32:14 <Saizan> mk: return will actually produce a function (S -> (S,A)) that will produce the same value of A for every value of S
08:32:20 <dcoutts> timthelion: it's confusing because the docs don't say that type Allocation = Rectangle
08:32:58 <mk> bscarlet: if we use return to get the monadic value (a weird function in this case) referencing some value (call it 1), then bind needs to be able to get 1 out
08:33:18 <dcoutts> timthelion: if you were wondering about those Property things,
08:33:18 <mk> Saizan: ah, ok - the "for every value of S" makes sense
08:33:35 <mk> which value of S does bind use?
08:33:53 <dcoutts> timthelion: see the hello world http://projects.haskell.org/gtk2hs/documentation/#examples
08:34:16 <dcoutts> timthelion: it uses 'set' there, and for 'get' it's just: val <- get object property
08:34:28 <Saizan> mk: the result of bind will be a function S -> (B,S) so it uses that S argument
08:35:15 <dcoutts> timthelion: but the allocation is not an ordinary property like that because it's rather dynamic, you can set a request, but what you get allocated varies
08:37:13 <bscarlet> mk: sorry, I was coming at it not reasoning from what bind should to to what the code should be, but the other direction. The code is return a = StateT $ \s -> (a, s). Clearly that build some function. From that perspective the question of whether the input s is "right" is a little weird. Instead, ask what the function (\s -> (a,s)) does, and what the consequence will be.
08:37:16 <timthelion> dcoutts: OK, thank you.  I think I've figured it out.
08:37:33 <dcoutts> great
08:38:35 <bscarlet> mk: e.g. \s -> (a, s) is precisely the function which passes the state along, ignored from the input to the output state, and otherwise produces the "a" which was "return"ed.
08:38:46 <bscarlet> mk: s/e.g./i.e./
08:40:16 <nevrenato> Hello there !! Can someone pls explain to me the meaning of the error of 'No instance for…' and why it doesn't give this error in ghc  6.2, but gives with ghc 7.03  ?
08:42:39 <Drakken> good morning, haskellers.
08:43:32 <zhulikas> hey
08:43:43 <mk> bscarlet: gotcha - I'm still unsure what particular value of S bind will feed into the function in order to get the "a" value out
08:43:54 <Skola> how do I process large amounts of files in Haskell? (i.e. I tokenize them 1 by 1, storing the results in a list)
08:44:16 <Saizan> nevrenato: do you know what typeclasses are?
08:44:42 <Twey> Skola: Sounds like you want iteratees
08:45:03 <Saizan> iteratees might also be overkill though
08:45:04 <nevrenato> Hi Saizan thanks for your interest :)  Yes i have an idea
08:45:29 <Skola> I'll look up iteratees, thanks
08:46:10 <Saizan> nevrenato: well, No instance for (C T) means there isn't an available instance of typeclass C for the type T
08:46:42 <Saizan> nevrenato: and you probably get that error because the libraries have changed between those versions of ghc
08:47:13 <Skola> Saizan what's the alternative for iteratees?
08:47:19 <Saizan> nevrenato: if you give use the whole error on hpaste.org we might give specific help
08:47:35 <quicksilver> mk: bind doesn't feed in any value of S.
08:47:45 <quicksilver> mk: bind just produces a function which accepts an S.
08:47:53 <quicksilver> mk: (and ripples that one through)
08:48:18 <Saizan> quicksilver: i think mk meant feeding to the first argument of bind
08:48:27 <phryk> Hi there. Can someone tell me how to get the default behaviour of ghc to be to use multiple cores?
08:48:34 * hackagebot graph-rewriting 0.6.0 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.6.0 (JanRochel)
08:48:39 <phryk> I haven't found anything that would resemble a config file or simliar…
08:49:28 <nevrenato> Saizan: OK thanks…it's true that the program was built for base  3.* and i'm trying to use the one that comes with ghc 7.*
08:49:47 <nevrenato> Saizan: i will put the error on hpaste.org
08:50:46 <hpaste> nevrenato pasted “Error on HyloRes ” at http://hpaste.org/66473
08:52:40 <nevrenato> Saizan: it's on http://hpaste.org/66473 !
08:53:35 * hackagebot graph-rewriting-layout 0.5.0 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.5.0 (JanRochel)
08:53:39 <Saizan> nevrenato: those classes and types seem application-specific though
08:53:53 <nevrenato> Saizan: yes they are
08:54:35 <nevrenato> Saizan: That's the problem….this application can compile on ghc 6.12.x
08:54:51 <nevrenato> nevrenato: but not on ghc 7.0.3
08:55:07 <nevrenato> Saizan: but not on ghc 7.0.3
08:56:32 <Saizan> i can't think of any changes that would introduce a Neg type constructor out of the blue
08:56:48 <Saizan> though maybe there's some monomorphization going on
08:57:00 <Saizan> nevrenato: are you using GADTs ?
08:58:09 <Saizan> -XNoMonomorphismRestriction -XNoMonoLocalBinds might be worth a try
08:58:23 <nevrenato> Saizan:  maybe =/ i don't know very well…this application is not mine
08:58:32 <nevrenato> Saizan:  ok i will try :)
09:00:05 <mk> (yes I did mean feeding to the first argument of bind)
09:01:32 <maurer> So, is there any way to get the effect one might have hoped for from DatatypeContexts?
09:02:09 <maurer> Um, nevermind, ignore me.
09:04:45 <Saizan> you can put the constraint on the constructor with GADT syntax
09:05:01 <hpaste> timthelion pasted “Type error which I cannot figure out” at http://hpaste.org/66474
09:05:29 <timthelion> can someone please take a look at that type error?  I have no idea where ghc is comming up with the type [[b0]]
09:05:37 <maurer> Saizan: So, in my case there are no constructors
09:06:06 <maurer> Saizan: But looking at it closer, it looks like I can just flow the constraint into a typeclass.
09:08:59 <nevrenato> Saizan: sorry i put the NoMonoLocalBinds NoMonomorphismRestriction on extensions in the .cabal file
09:09:20 <nevrenato> Saizan: but i get unknown extension
09:09:27 <nevrenato> for NoMonoLocalBinds
09:11:08 <hpc> @google NoMonoLocalBinds
09:11:40 <monochrom> @botsnack
09:11:44 <hpc> :(
09:12:01 <monochrom> she is entirely absent
09:12:40 <Tinned_Tuna> > show "love"
09:13:04 <Saizan> nevrenato: i guess it's not supported by your version of Cabal and/or ghc
09:15:13 <nevrenato> Saizan: yes…ghc supports it it appears in the man page….Maybe cabal its the problem
09:18:51 <Saizan> nevrenato: you might have an old cabal-install from your previous installation, try cabal update && cabal install cabal-install
09:19:14 <hpaste> nevrenato pasted “Hylores less errors” at http://hpaste.org/66475
09:19:25 <nevrenato> Saizan: i only get this error now ….http://hpaste.org/66475
09:21:49 <Saizan> ah, so NoMonomorphismRestriction helped
09:22:32 <Saizan> you might additionally try putting {-# LANGUAGE NoMonoLocalBinds #-} at the top of that file
09:22:47 <nand`> in http://code.haskell.org/lambdabot/Plugin/BF.hs why not map non-printable chars to some escape form instead of dropping them?
09:23:28 <quicksilver> possible it was just simpler and they were lazy.
09:23:54 <monochrom> yeah, "it's just a prototype" that persisted
09:25:40 <quicksilver> not much demand for industrial strength brainfuck plugins for lambdabot, perhaps
09:25:52 <quicksilver> it's rather a nice example of how easy it is to write a lambdabot plugin though.
09:26:20 <nand`> I suppose so
09:26:46 <nand`> well, s >>= escape where escape | 31 < ord x && ord x < 127 = return x | otherwise = '\\' : show (ord x) -- wouldn't have been much harder
09:27:43 <quicksilver> indeed not :)
09:28:07 <quicksilver> maybe they had in mind running BF examples which do PC-console colour escapes
09:28:16 <quicksilver> and it looks nicer to strip those than escape them
09:28:24 <quicksilver> although, you'd still see the m13;1 part
09:28:30 <nevrenato> Saizan: yeah :) but I still the get the error http://hpaste.org/66475
09:29:57 <Saizan> nevrenato: not sure then, you'd have to dig into the code
09:30:22 <nevrenato> Saizan: ok thanks anyway you were of great help
09:30:53 <quicksilver> Saizan, nevrenato : complete guess would be that hylores uses overlapping or incoherent instances
09:31:01 <quicksilver> and the new typechecker gets some case slightly different.
09:31:28 <quicksilver> I have no reason to think it does, except that it's obviously doing reasonably fiddly type-level stuff.
09:33:56 <nevrenato> quicksilver: yes i suspect that is some incoherence between 6.12.* and 7
09:34:36 <quicksilver> I don't know what kind of commitment the GHC team make to keep overlapping/incoherent resolution consistent between releases.
09:35:25 <nevrenato> quicksilver: do you know some specific place where i can get more information about this ?
09:36:52 <quicksilver> nevrenato: the glasgow-haskell-users mailing list is the best place for rather specific type checker queries
09:37:08 <quicksilver> nevrenato: (or ask the hylores people, of course, who may already be aware of the issue)
09:37:08 <nevrenato> quicksilver: ok thanks :)
09:40:52 * t7 is wondering how to implement p2p poker with > 2 players... maybe some kinda block chain or something...
09:42:34 <DevHC_> is there a built-in function for calculating factorials and binomials?
09:43:23 <mk> how is it possible to break the monadic associativity law?
09:43:52 <t7> mk return _ = Maybe 2
09:43:56 <t7> or something
09:44:17 <shachaf> t7: What?
09:44:18 <mk> t7: that breaks the other laws
09:44:27 <hpc> instance Monad Maybe where return _ = Nothing; (>>=) = {- whatever (>>=) is normally defined as -}
09:44:38 <hpc> er, oh
09:44:59 <hpc> data Foo a = Foo Int a
09:45:15 <hpc> instance Monad Foo where (>>=) = {- do what Identity does, but increment the Int -}
09:45:19 <mk> the other two laws catch a bunch of bad things already - so what does assoc do?
09:45:50 <mk> hpc: that'll break the identity laws anyway
09:47:18 <Elemir> Hem, why cann't I find a working comonad-based FRP library?
09:47:24 <mk> but the assoc law isn't merely a consequence of the other two laws, so there must be a way to break just it
09:48:56 <Skola> how do I read and process a list of files?
09:49:03 <hpc> mk: oh, how about (Writer Foo), where Foo's Monoid instance has broken associativity
09:49:37 <mk> hpc: hmm- not familiar with that. How does that work?
09:50:11 <Elemir> Skola: mapM_? Or what do you want?
09:50:13 <hpc> (in not actually valid haskell)
09:50:28 <hpc> class Monoid a where 0 :: a; (+) :: a -> a -> a
09:50:43 <hpc> 0, (+) are actually mempty, mappend
09:50:44 <DevHC_> Skola: mapM_ (\f -> readFile f >>= \t -> {- do something -}) ["file1", "file2"]
09:50:50 <Skola> yes Elemir, mapM_ is what I've been trying so far
09:50:55 <hpc> and the laws are (+) is associative, and 0 is the identity over (+)
09:51:03 <mk> (I'm trying to understand the third law on the basis of what it excludes)
09:51:09 <Skola> ah yes DevHC_, thanks!
09:51:39 <mk> hpc: what are mempty and mappend?
09:51:39 <pqmodn> mk: see the note about #3 if you haven't read this yet http://www.haskell.org/haskellwiki/Monad_Laws
09:52:02 * Elemir wants to comonad base :(
09:52:23 <hpc> mk: they're the actual names for the zero/plus operations
09:52:27 <hpc> see what i said above
09:52:37 <pqmodn> mk: i don't know if that answers you question, but it may be informative
09:54:15 <mk> pqmodn: thanks - I'd seen it before when I was looking at the first two laws, and closed the tab when I read "In this notation the laws appear as plain common sense". But I see that #3 is written more plainly :)
09:54:44 <pqmodn> heh
09:55:18 <Twey> Goodness, non-layout Haskell
09:55:21 <hpc> i think there's cases where ListT breaks associativity?
09:55:47 <hpc> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-List.html#t:ListT
09:56:40 <mk> the simplest case/monad possible would be a big help. I've roughly figured out that the first law means "return must maintain a reference to the incoming value (except in the case of trivial), and must push pure values through the arbitrary function"
09:58:01 <mk> the second identity law means, at least, "any pure value given to bind must be pushed through return, and its non-value parts must be preserved"
09:58:28 <elliott> Cale: What's up with lambdabot lately?
09:58:57 <mk> I'm still uncertain about what it means when it comes to non-pure values, but I've left that aside and am trying to figure out the third (assoc) law
09:59:02 <hpc> mk: aha! http://www.haskell.org/haskellwiki/ListT_done_right#Order_of_printing
09:59:16 <hpc> i think that's the simplest example of breaking associativity biting you in the ass
09:59:37 <elliott> mk: see #3 at http://www.haskell.org/haskellwiki/Monad_Laws
09:59:46 <elliott> that shows an obvious program transformation that breaking associativity messes up
10:00:08 <mk> elliott: the fish operator is still not intuitive to me
10:00:09 <hpc> you can read those top lines as a = liftIO (putChar 'a'), b = liftIO (putChar 'b'), ...
10:00:17 <elliott> mk: so? that page does not use it
10:00:20 <mk> hpc: thanks, looking through that now
10:00:22 <elliott> well, it does, but later on
10:00:28 <elliott> just read sections 1 and 2
10:01:11 <mk> elliott: I see. I'm looking at part 3. Part 1 is nonsense to me :)
10:01:32 <elliott> mk: How is it nonsense?
10:01:51 <gdoteof> i sthere anything for 'pretty printing' trace statements?
10:02:13 <mk> elliott: it's very hard to both think about monads, and have to constantly parse unfamiliar notation
10:02:31 <edwardk> mk: if you view the monad laws in terms of (>=>), then the laws are just that (>=>) looks like a monoid with return as its identity element
10:02:56 <Twey> mk: Do you know any imperative, Algol-like programming languages?
10:03:01 <elliott> mk: You don't have to think about monads to understand section 1.
10:03:07 <elliott> mk: Just think of them as imperative programs a la C.
10:03:07 <mk> edwardk: I don't yet get the fish operator
10:03:23 <elliott> (Except for the meaning of "return", anyway.)
10:03:45 <edwardk> f >=> g = \a -> f a >>= g
10:03:50 <edwardk> :t (>=>)
10:04:07 <elliott> psst
10:04:09 <mk> Twey: unsure, effectively "no"
10:04:09 <elliott> lambdabot's not here
10:04:21 <elliott> mk: You don't know any imperative languages?
10:04:27 <elliott> Seriously?
10:05:10 <Twey> mk: Okay, then the easiest way to do it is probably to play around with monads and the fish operator in GHCi until you understand it
10:05:20 * elliott thinks mk might just be misinterpreting "Algol-like".
10:05:21 <Twey> Then you can use section 3 to understand the laws
10:05:26 <elliott> (To mean something less broad than it is.)
10:05:33 <Twey> Perhaps
10:05:39 <gdoteof> and secondly; is it possible/how do i use a trace within a `do` block?
10:05:43 <mk> elliott: I get my terminology mixed up, so I'm not sure. Given your response, yes, I probably am familiar
10:05:53 <elliott> mk: Do you know C? C++? Java? C#? Pascal?
10:05:57 <elliott> Perl? Python? Ruby?
10:05:58 <mk> elliott: yes
10:05:59 <Twey> gdoteof: Have a look for Debug.Trace
10:06:09 <elliott> Well, then you know enough about imperative code to understand section 1 ;)
10:06:22 <Twey> mk: Then you can imagine do-notation in IO to be very similar to a program in one of those languages.
10:07:07 <Twey> (and you can pretend that the generic monad m used there is IO, for initial learning purposes)
10:07:15 <mk> what is the value of do?
10:07:21 <Twey> mk: do is a keyword
10:07:25 <Twey> It simply introduces a do-block
10:07:48 <mk> right, but there's a ≡ symbol in the middle
10:08:13 <Twey> mk: The ≡ means ‘is functionally identical to’ here
10:08:24 <elliott> Right, it's just saying "left is the same as right".
10:08:32 <elliott> And in the case of the last one, "all three of these are the same".
10:08:53 <elliott> Perhaps it should be laid out with a table or such, rather than in a <pre>.
10:08:57 <Twey> Some sort of row-marking would be nice.
10:08:58 <Twey> Yeah.
10:09:19 <edwardk> mk: read that = like a mathematical =, its saying the two sides are equivalent, not like a function definition
10:09:48 <mk> if do has no value, why is it being fed into y using <-?
10:10:08 <elliott> erm...
10:10:25 <elliott> it's do { x <- m; f x } that's being bound to y
10:10:51 <pqmodn> mk: do { x <- m; f x } is syntax sugar for m >>= \x f x
10:11:00 <pqmodn> er, \x -> f x
10:11:08 <mk> right. If it's being bound in the typical imperative way, what's its value?
10:11:17 <gdoteof> Twey: i am looking at Debug.Trace; i see traceIO but that isn't working either.  i am getting a type error on embedding a trace within a yesod widget
10:11:27 <mk> pqmodn: ok, so an anonymous function?
10:11:30 <elliott> no
10:11:36 <gdoteof> which i am sure makes perfect sense
10:11:37 <niklasb__> pqmodn: and \x -> f x is just a more verbose f :)
10:11:45 <elliott> mk: it's binding the result of executing the program do { x <- m; f x }
10:11:45 <elliott> to y
10:11:50 <elliott> so think of it as a "subprogram"
10:12:19 <mk> elliott: how is a subprogram different from a "subfunction"?
10:12:40 <niklasb__> mk: a program is a series of actions
10:13:02 <elliott> mk: because programs are not functions
10:13:14 <gdoteof> the function is like func :: String -> Widget.   func = do ... ; trace (something) ; ..
10:13:15 <gnoi> Oho! Breaking new!
10:13:16 <mk> niklasb__: and actions are functions?
10:13:21 <gnoi> I hope so
10:13:23 <elliott> mk: no
10:13:27 <Rc43> Hi, guys.
10:13:31 <niklasb__> mk: more like statements in imperative languages
10:14:23 <mk> niklasb__: I understand how statements might be turned into functional functions. I'm confused by the suggestion that functional programs have statements.
10:14:27 <mekeor> hi, Rc43
10:15:09 <Rc43> I wanted to ask about type classes with more than one type variable.
10:15:23 <Rc43> But already found extension for multiparametric type classes.
10:15:23 <mauke> permission granted
10:15:29 <mauke> oh
10:15:34 <elliott> mk: again, do not think of them as functional programs
10:15:35 <elliott> forget functional
10:15:38 <elliott> just look at them as imperative programs
10:15:42 <elliott> forget haskell, even
10:15:52 <niklasb__> mk: monads make it possible that you can express imperative style in a functional language :)
10:16:30 <mk> elliott: alright. <- do still doesn't parse for me, because I don't see how do can have a value if it's not a function
10:16:39 <elliott> mk: as i said, it is not <- do
10:16:44 <elliott> it's <- (do { x <- m; f x })
10:16:50 <mk> elliott: sure, do {...}
10:16:53 <elliott> "execute that program, then bind its result"
10:16:57 <elliott> you don't see how programs can have results?
10:17:01 <Rc43> Hm, but now I got that multiparam type classes really isn't what I want.
10:17:03 <elliott> "return x" is the program that does nothing and has result x
10:17:08 <elliott> do { return x } is the same
10:17:13 <mk> so binding isn't the same as value assignment at all
10:17:16 <elliott> do { blah; return x } is the program that does blah and returns x
10:17:18 <elliott> no, it's not
10:17:24 <mk> ok, that makes much more sense
10:17:33 <Rc43> I want to declare type class for type, which are parameterized with two types. Is it real in haskell type system?
10:17:48 <elliott> Twey: mk: I tweaked the page to have a nicer presentation of the do-notation form of the laws: http://www.haskell.org/haskellwiki/Monad_laws
10:17:54 <Rc43> I mean is it real to get type parameters from monomorphic type?
10:18:18 <k0ral> hi, anyone knows when will next cabal-install release happen ?
10:18:49 <Rc43> What I want to do: declare `class X (Something k v) where` and then implement `instance X (Map k v) where ...`.
10:18:59 <mk> elliott: that is nicer, though it might not fit in smaller windows
10:19:17 <geekosaur> Rc43, multiparameter type classes are an extension; note that type checking becomes rather dicey without an additional extension (either functional dependencies or associated types)
10:19:27 <geekosaur> rather type families
10:19:44 <mk> perhaps put the names above the boxes
10:20:03 <elliott> mk: I can wrap the third example onto a new line perhaps, but my browser window can get pretty small before it gets a scrollbar there, so I'm not overly concerned
10:20:22 <elliott> indeed i have to make the top bar with the user options and search bar wrap in an ugly manner before i get a scrollbar down there
10:20:45 <mk> elliott: tiling the window at half on my screen produces the bar
10:20:50 <Rc43> geekosaur, do you know answer to my next question?
10:21:38 <Rc43> geekosaur, I have a type with to parameters (suppose it is Walker k v) and I want to declare class, which instances are convertible to Walker.
10:22:03 <Rc43> geekosaur, so we need to somehow get two types instead one
10:22:23 <geekosaur> I... thought I just answered that
10:22:53 <Rc43> geekosuar, no, multiparam typeclasses cannpt do this (or I dont see how)
10:23:18 * elliott cleans up/clarifies http://www.haskell.org/haskellwiki/Monad_laws some more...
10:23:26 <elliott> mk: ok, i'll play with it later
10:23:31 <elliott> mk: but IMO wrapping would be less clear
10:24:24 <mk> I still don't see that much from the do notation
10:24:28 <Rc43> btw,in `instance Traversable (Map k) where ...` we declare instance for the _function_ ? (I mean type constructor (Map k))
10:24:40 <elliott> mk: Have you written any simple IO programs using do notation yet?
10:24:43 <t7> which will come first: a reasonable build system or strong AI?
10:24:48 <mk> elliott: yep, though you could put the word "associativity" above the boxes for example
10:24:56 <elliott> Get some practical experience first and the laws will become self-evident.
10:25:25 <mk> elliott: yes, I have. I'm not sure that we're going for the same notion of "self-evident"
10:25:51 <mk> elliott: what do the identity laws tell you about what return should do?
10:26:02 <mk> (or, what is self evident in that regard)
10:26:17 <elliott> It tells you nothing about return.
10:26:34 <elliott> do { x' <- return x; f x' } -- "Do (return x), and call its result x'. Then run the action (f x')."
10:26:41 <elliott> Now, "return x" is defined as the action that does nothing, and has result x.
10:26:45 <mk> the identity laws say that return must not lose the reference to the original value
10:26:47 <elliott> So, this is equivalent to: do { f x }
10:26:49 <elliott> "Run the action f x".
10:27:25 <elliott> Do you see it more clearly now? "Do (return x)" -- does nothing -- "call its result x'" -- (return x)'s result is x -- "then run the action (f x')" -- so this is just (f x).
10:27:38 <mk> this is a very important fact about return
10:27:42 <mk> sec, parsing
10:28:05 <nart> ciao :)
10:28:46 <nand`> t7: both at the same time. The AI will become the reasonable build system
10:28:46 <elliott> mk: In fact, that law is what _states_ that return cannot do anything but return its srgument.
10:28:47 <mk> elliott: I'm not sure how return is defined as the action that does nothing
10:28:48 <elliott> *argument.
10:28:53 <elliott> mk: Because of that law.
10:28:56 <elliott> You must be able to replace
10:28:59 <elliott> do { x' <- return x; f x' }
10:28:59 <elliott> with
10:29:02 <elliott> do { f x }
10:29:12 <elliott> Therefore, return cannot do anything and its result must be its argument.
10:29:26 <nand`> (>>= return) = id
10:29:42 <mk> elliott: sure, but return might wrap the value in a closure. It could even, for infinite numeric values, increment them by 1.
10:29:47 <elliott> mk: Once you know that's what return is, the right identity law becomes clear -- doing an action then returning its result is just the action itself.
10:29:53 <elliott> mk: What?
10:29:59 <elliott> That's irrelevant.
10:30:06 <elliott> We're talking about the results and effects of computations here.
10:30:09 <elliott> Not their underlying representation.
10:30:20 <elliott> Again, forget about everything but simple imperative programming, and the laws will make sense.
10:31:10 <mk> elliott: this isn't a matter of underlying representation
10:31:44 <nand`> it makes sense when you look at the definition of (a >>= b) = join (b a); therefore (a >>= return) = join (return a) and join . return = id is another law
10:31:47 <mk> that return must return a monadic value, such that the monadic value has a unique path back to the original value, has little to do with representation
10:31:55 <elliott> "Unique path"?
10:32:10 <nand`> which makes sense because “lifting a value” and “flattening it again” shouldn't change it
10:32:22 <mk> elliott: return cannot yield the same monadic value for any two values given to it (except in the case of Trivial)
10:32:23 <elliott> Monads are just an interface to create and combine certain kinds of computations. The left identity law is stating a requirement of that creation and composition.
10:32:34 <elliott> mk: Sorry, you're not making any sense.
10:32:54 <mk> elliott: which part? Return is a function that yields monadic values, yes?
10:33:08 <nand`> values are not monadic, types are
10:33:08 <elliott> Monadic actions, sure.
10:34:01 <mk> not actions, values.
10:34:11 <elliott> No.
10:34:12 <elliott> Actions.
10:34:13 <mk> if actions are values that is fine
10:34:18 <elliott> Yes, but the values are not monadic.
10:34:21 <elliott> Monadic actions are a type of value.
10:34:34 <elliott> Big integers are a type of value, but "big value" means nothing.
10:35:00 <t7> means its big....
10:35:23 <mk> when we give Maybe's return 1, it yields the *value* Just 1
10:35:35 <mk> Just1 is a monadic value
10:35:36 <elliott> Sure. That's not relevant to the monad laws.
10:35:40 <elliott> And no.
10:35:42 <elliott> Just 1 is a value.
10:35:50 <elliott> It happens to be a value of a monadic type.
10:35:56 <elliott> It also happens to be a monadic action because of that.
10:36:00 <elliott> It's not a "monadic value".
10:36:23 <mk> elliott: ...do you have any reason to object to my calling values of a monadic type monadic values?
10:36:34 <elliott> Yes.
10:36:37 <elliott> It's misleading.
10:37:11 <mk> integers, for example, might be called integer values. Integer list values might be called... precisely that.
10:37:14 <Twey> elliott: I was tweaking it at the same time as you :þ  I added layout to it and tweaked a couple of the other sections for consistency with the new layout, too.
10:37:15 <t7> you're a monadic value
10:37:41 <Twey> mk: The difference is that ‘integer’ and ‘integer list’ are both types
10:37:48 <elliott> Twey: I find the indentation-based presentation much harder to parse, since the "do" is on its own
10:37:52 <Twey> mk: ‘Monad’ isn't a type, it's a typeclass
10:38:16 <elliott> apart from that it's nicer
10:38:36 <mk> Twey: when the values come out of a monad, they have type Monad Foo. That's a "monadic" type, I think
10:38:41 <t7> if you were a monad you would be a IO. Everyone hates you
10:38:45 <Twey> elliott: It doesn't have to be; we could put the first line next to the ‘do’ if you like.  I think it's nicer to have the ‘do’ on its own because it prevents reading errors like mk's where the ‘do’ is assumed to be part of the larger expression.
10:39:25 <elliott> Twey: Well, I think that the explicit braces help for clarity to explicitly delimit what's part of what do block. I don't think mk misinterpreted the "do" as a value on its own, just stated his confusion confusingly.
10:39:51 <Twey> elliott: Do you think the indentation doesn't communicate that clearly?
10:40:23 <Twey> There's also the issue that very few people write real Haskell code using semicolons.
10:40:38 <elliott> Not really. It might do with the "do" on the same line as the first statement, but I'm still uneasy about it. Layout helps when reading and writing real code, but the braces/semicolon style is closer to a typical imperative language IMO
10:41:03 <mk> I'm unsure about the notation, I know the ; were confusing. The worst part of it at the moment is that <- is used for return, which is a function, and then for do, which is something totally different
10:41:44 <nand`> <- isn't used for return
10:41:46 <nand`> it's used for >>= \
10:41:50 <Twey> elliott: I presume most imperative programmers nowadays are familiar with the concept of layout… if we're going for similarity with more common languages, maybe it would be better to use a C-like brace/semicolon style
10:42:16 <elliott> Twey: Oh, putting the first statement on the same line is bad, because "do f x" is confusing.
10:42:19 <elliott> Looks like do being applied to f and x.
10:42:22 <Twey> mk: That's not a notational issue; any value of the appropriate type can be used on the RHS of a <-.
10:42:28 <Twey> elliott: *nod* Agreed
10:42:29 <elliott> I dunno, I really think the braces help for grouping.
10:42:56 <elliott> I think a problem is that "y <- do" doesn't *look* like something that introduces a new indentation block, Python-style.
10:43:30 <mk> you could put a bracket to the left of do itself
10:44:08 <elliott> mk: That would be invalid syntax.
10:44:09 <Twey> elliott: I'm tempted to switch it all to C-like brace-semicolon style (braces on separate lines, semicolons on the line of the previous statement, redundant semicolon at the end of the block) but that's getting even further away from what they're likely to encounter/have encountered elsewhere
10:44:40 <mk> what is the correct term for a value that is produced by a monadic constructor?
10:45:07 <elliott> mk: "Monadic constructor" means nothing.
10:45:13 <nand`> Is there a non-monadic constructor?
10:45:22 <elliott> Twey: I'll give that a try.
10:45:34 <byorgey> mk: you mean a value of type  m a  where m is an instance of Monad?
10:45:34 <nand`> nvm, a constructor with no parameters is not a function and therefore not necessarily one
10:45:53 <nand`> but all type constructors with at least one parameter are functions and all functions are inherently monads
10:45:54 <mk> elliott: in addition to correcting me, it would help if you told me what I meant
10:45:59 --- mode: ChanServ set +o glguy
10:46:02 <byorgey> nand`: no, functions are not monads.
10:46:10 <byorgey> the type constructor ((->) e)  is a monad.
10:46:17 <Twey> elliott: While you're at it, you should eliminate remaining references to ‘law #3’ &c.
10:46:20 <nand`> right, let me rephrase
10:46:26 <mk> byorgey: yes, that's right
10:46:43 <nand`> actually let me not rephrase, can't think of a way to say it in a correct way
10:46:44 <elliott> Twey: After trying it: I think the {}s and ;s generate too much noise there, esp. in the associativity law.
10:46:50 <byorgey> mk: there is no accepted standard term.  common ones include "computation" or "monadic value".  Less common is "mobit".
10:46:52 <Twey> elliott: I thought so, too.
10:46:56 <elliott> With the previous style they're all "out of the way".
10:47:00 <Twey> mk: Or ‘mote’.
10:47:04 --- mode: glguy set -bbb *!*55c89673@gateway/web/freenode/x-rbjcsbkhixgomjeq *!*55c89673@gateway/web/freenode/x-vzqnpwomjyhdyzhw *!*55c89673@gateway/web/freenode/x-vrcevfwgqrdmifac
10:47:07 <mk> ok, I am going to use the term "monadic value"
10:47:07 <shachaf> byorgey: Or "action".
10:47:12 <Twey> elliott: Are they?
10:47:13 <elliott> mk: Don't. It's misleadnig.
10:47:16 <elliott> *misleading
10:47:21 <elliott> Twey: Sure; they're all in one column per do block.
10:47:25 <elliott> So it's easier to scan.
10:47:30 <nand`> if you ask me, the laws are best expressed without do notation
10:47:34 <Twey> elliott: Not for someone used to C-likes
10:47:36 <shachaf> elliott: I think mk already made up their mind to use "monadic value" half an hour ago.
10:47:39 <mk> elliott: I disagree. It's a value, and it's "inside" the monad.
10:47:40 <nand`> (a >>= b) >>= c = a >>= (b >>= c)
10:47:56 <shachaf> nand`: If only that type-checked.
10:48:10 <elliott> mk: No.
10:48:14 <byorgey> (a >=> b) >=> c = a >=> (b >=> c)
10:48:17 <Twey> elliott: Things lining up in columns are not relevant to someone used to C-likes.  OTOH, trailing semicolons are expected and ignored.
10:48:20 <shachaf> mk: "monadic value" is just terminology, and some people use that terminology.
10:48:24 <shachaf> But "inside the monad" is just wrong.
10:48:39 <elliott> mk: I don't know how to convince you otherwise, but I think you should wait until you understand monads before deciding to use terminology based on how you think they work.
10:48:40 * hackagebot cgen 0.0.4 - generates Haskell bindings and C wrappers for C++ libraries  http://hackage.haskell.org/package/cgen-0.0.4 (AnttiSalonen)
10:48:43 <t7> inside the space suit?
10:48:45 <mk> elliott: ok, in any case it's a standard term, and I'd like to use it to be able to say something
10:48:50 <elliott> Twey: Fair enough. I removed law #N refs.
10:48:52 <Twey> (that is to say, the fact that they are in a column is not relevant; they will be parsed as the first thing on the line, and given importance appropriate for that)
10:49:06 <elliott> mk: Just say "monadic action". If it doesn't make sense with "monadic action" instead, what you're trying to say is wrong.
10:49:12 <Twey> elliott: Are we sticking with layout, then?
10:49:42 <elliott> Twey: Perhaps... I still think the earlier form of the third law was a lot easier to read. It would help if the indentation was more pronounced, but then it'd take up even more space.
10:49:58 <Twey> We do have a fair bit of space free
10:50:02 <mk> elliott: getting back to what I wanted to say: return yields a monadic value
10:50:10 <elliott> I definitely don't like the eta-expanded LHS of the (>>=) form of associativity, though; will you hate me if I undo that part? :P
10:50:48 <shachaf> mk: Why do you insist on using words that the people you're asking questions of are directly saying you shouldn't use? :-)
10:51:05 <mk> return cannot yield the same monadic value for any two values given to it
10:51:09 <Twey> elliott: I did it because the other side is expanded
10:51:25 <elliott> mk: It's not clear what you mean by that, but whatever it is, it's misleading in the context of the laws.
10:51:25 <Twey> I think we should expand both or neither; I don't like having one side expanded but not the other
10:51:43 <elliott> Twey: Well, it's not "expanded", it just isn't point-free
10:51:50 <elliott> (>>= g) . f would be incredibly confusing.
10:51:50 <edwardk> mk sure it could. data Trivial a = Trivial; instance Monad Trivial where return _ = Trivial; Trivial >>= _ = Trivial
10:51:55 <shachaf> mk: It's clear what you mean by that, but it's phrased in a misleading way, and it's wrong.
10:52:00 <elliott> I think we should stick with the original form because it's the standard presentation of the laws ni that form
10:52:05 <mk> shachaf: because if I use the term "computation" it will confuse me, and if I use the term "mote" it'll confuse everyone
10:52:08 <shachaf> mk: What edwardk said.
10:52:08 <elliott> edwardk: He said "except for Trivial" last time.
10:52:14 <elliott> mk: "action"
10:52:17 <elliott> That's neither of those terms.
10:52:33 <mk> edwardk: yep, that's right. Trivial is the only example of that being true
10:53:05 <edwardk> Well, there are variations on Trivial
10:53:22 <mk> elliott: action makes no sense to me. I'd like to understand how it could make sense, but I don't want to switch to that topic.
10:53:24 <elliott> it also doesn't apply to Constant a, of course
10:53:27 <Twey> elliott: Oh, I see what you mean.
10:53:40 * hackagebot hogre 0.1.4 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.4 (AnttiSalonen)
10:53:44 <mk> elliott: define Constant a?
10:53:51 <elliott> mk: No offence, but I don't think you understand what you mean when you say "monadic value" either.
10:54:02 <Twey> elliott: Agreed, then.
10:54:03 <elliott> newtype Constant a b = Constant a
10:54:11 <elliott> Twey: OK, done :)
10:54:22 <elliott> The normal presentation of the laws is ugly anyway.
10:55:02 <mk> elliott: I agree, and that's fine. It's a value and it can be produced by a constructor suitably related to Monad
10:55:02 <Twey> elliott: What's your judgement on the wider layout?
10:55:32 <elliott> mk: IO is a monad; it's also an abstract type, and is not defined to have constructors.
10:55:54 <edwardk> elliott: given data Constant a b = Constant a; instance Default a => Monad (Constant a) where return = Constant def; Constant a >>= _ Constant a -- You fail with return a >>= f  because that isn't equal to (f a)
10:56:07 <elliott> Twey: I think it's better, but I still stubbornly prefer the original for now :p -- I'm not sure the more pronounced layout is necessary in the later code examples though
10:56:13 <elliott> edwardk: oh, right, hmph
10:56:15 <mk> elliott: ok. I don't think I said it did.
10:56:33 <elliott> mk: Well, (return x) is a monadic action of type IO a where a is the type of a.
10:56:42 <elliott> It's not produced by a constructor "suitably related to Monad" (no idea what this means, though).
10:57:21 <Twey> elliott: I'll settle for ‘better’ as the original is exceedingly noisy from a C-like point of view
10:58:42 * hackagebot hogre-examples 0.1.4 - Examples for using Hogre.  http://hackage.haskell.org/package/hogre-examples-0.1.4 (AnttiSalonen)
10:58:43 <mk> elliott: look, I don't yet know enough to be able to communicate on your terms. If you're going to pretend to not understand what I'm trying to get at to prove a point about terminology that I don't know, then I don't want to have that conversation :)
10:59:11 <dgpratt> has anyone tried either virthualenv or hsenv on Windows?
10:59:13 <mk> some constructors produce monadic values, or actions, or motes
10:59:51 <mk> what does Constant's return look like?
11:00:10 <elliott> mk: I'm not pretending.
11:00:24 <elliott> You're literally not making any sense; I am trying my best to try and understand what you could mean.
11:00:51 <elliott> Twey: How about this? (Modified the page to demonstrate a possible half-way point)
11:00:53 <elliott> http://www.haskell.org/haskellwiki/Monad_laws
11:01:06 <elliott> That has the clear bracing, while being more conventionally C-like, and not being noisy.
11:01:20 <mk> elliott: what I mean when I say "monadic value", is simply what you mean when you say "action"
11:02:17 <mk> where can I find the definition for Constant?
11:02:17 <Twey> elliott: I think that works
11:02:31 <elliott> mk: Constant was a mistake, it's not a monad.
11:02:37 <Twey> (ugly as hell from my standpoint as a Haskeller, of course :þ)
11:02:50 <elliott> Twey: Yeah, it's ugly. But at least it might be familiar.
11:02:55 <Twey> *nod*
11:03:26 <Twey> elliott: Though C-style would have the ending brace lined up with the start of the keyword, not the opening brace (unless the opening brace is on a separate line)
11:03:49 <mk> elliott: alright. So, as I said - what the first law is saying is that return cannot return the same "action" for *any* two given values
11:04:08 <elliott> Twey: Indeed, but I was trying to make the nested do blocks look better.
11:04:13 <monochrom> please don't bikeshed too much on positions of braces!
11:04:19 <elliott> mk: No. The first law doesn't say that at all.
11:04:48 <elliott> The first law is saying that if you do return x, and then do something else with the result, that's the same as doing something with x.
11:04:49 <maurer> https://gist.github.com/2312891 # Can someone help me figure out how to get the type constraint to resolve on line 36?
11:05:54 <mk> elliott: not quite, because the first "doing something" (which is done by bind) differs from the second doing something
11:06:05 <elliott> monochrom: It's more about the presence of braces at all :)
11:06:10 <elliott> mk: No.
11:06:16 <elliott> mk: The monad law is stating that they *are* the same.
11:06:20 <elliott> It's precisely stating that there is no difference.
11:06:21 <maurer> My hope was that by using a type for the associated type, it would be able to tell that (EQV a) and (Val (SetF a)) are the same
11:06:27 <Twey> mk: There's only one doing-something in the example.
11:07:07 <mk> we're talking about bind(return(x),f) = f(x), yes?
11:07:46 <monochrom> yeah, braces are good for your teeth arrangement
11:07:48 <elliott> mk: Yes.
11:08:01 <monochrom> just kidding! braces are good, period
11:08:23 <niklasb__> say I do liftM2 (++) getLine getLine >>= print, how is it ensured that the getLine's are sequenced in the order I want (from left to right)?
11:08:41 * hackagebot hoogle 4.2.11 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.11 (NeilMitchell)
11:08:58 <nand`> @src liftM2
11:09:06 <Twey> niklasb__: The second argument to liftM2 is guaranteed to be the first argument to (++) and the third to be the second
11:09:08 <mk> bind( Pure 1, f) = f( 1 ) , for example
11:09:10 <nand`> lambdabot?
11:09:12 <Twey> :t liftM2
11:09:12 <elliott> niklasb__: that's do { a <- getLine; b <- getLine; print (a ++ b) }
11:09:12 <nand`> oh
11:09:19 <Twey> Oh, no lambdabot ☹
11:09:20 <niklasb__> elliott: ah okay
11:09:22 <niklasb__> nice thanks
11:09:23 <elliott> niklasb__: the first getLine happens before the second because... it's first!
11:09:24 <elliott> :)
11:09:27 <Twey> niklasb__: Anyway, that's the only way the types match.
11:09:33 <nand`> well, it's liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:09:42 <mk> the way I'm reading it, "doing something" with Pure1 differs from "doing something" with 1, on the right
11:09:42 <Twey> s/be/produce/
11:09:43 <elliott> monochrom: hmm, didn't you write the [[monad laws]] page?
11:09:56 <niklasb__> thanks guys
11:10:14 <nand`> so what happened to lambdabot
11:10:33 <monochrom> I wrote a post to haskell-cafe, another person copied it to that page, and I am pleased
11:10:51 <mauke> preflex: seen lambdabot
11:10:52 <preflex>  lambdabot was last seen on #haskell 7 hours, 19 minutes and 28 seconds ago, saying: Source not found. I can't hear you -- I'm using the scrambler.
11:11:00 <monochrom> and everyone is pleased too, apparently :)
11:11:07 * elliott delegates the responsibility of picking a style to use for the examples to monochrom, then!
11:11:19 <mauke> preflex: seen Cale
11:11:20 <preflex>  Cale was last seen on #haskell 13 hours, 27 minutes and 30 seconds ago, saying: Oh, "Javascript" was, yeah
11:11:26 <Rc43> What is the best way to get all values from map with keys in some set?
11:11:47 <Twey> Rc43: Sets don't have key/value pairs
11:11:51 <monochrom> my post is http://article.gmane.org/gmane.comp.lang.haskell.cafe/14967/
11:11:53 <Twey> Oh, sorry
11:11:55 <Twey> Misread you
11:12:02 <Rc43> Twey, :)
11:12:52 <Rc43> It would be nice If we could to declare custom Eq or something for one operation, but itn't easy in haskell, as I know.
11:12:56 <mauke> Rc43: M.keysSet m `S.intersection` s
11:13:09 <Rc43> mauke, no, I need values
11:13:28 <mauke> map (m M.!)
11:13:39 <Rc43> mauke, is it fastest?
11:13:42 <regularlambda> > putStrLn "Hello everybody"
11:13:43 <mauke> no idea
11:14:30 <mauke> filter ((`S.member` s) . fst) . M.assocs
11:14:43 <Rc43> mauke, oh
11:14:47 <Twey> Rc43: ‘flip M.lookup m `S.map` s’ is the obvious approach.
11:14:49 <Rc43> mauke, it iswhat I want
11:14:52 <nand`> it's O(m log n) where n is the number of values total and m is how many keys you're processing
11:14:53 <mauke> [ v | (k, v) <- M.assocs m, k `S.member s ]
11:15:47 <sebasmagri> Hi people... I'm having an issue with Network.HTTP...
11:15:50 <sebasmagri> The code is http://hpaste.org/66476
11:16:10 <elliott> @hoogle filterWithKey
11:16:18 <elliott> dammit
11:16:47 <monochrom> that is quite a bit more than Network.HTTP
11:17:00 <Elemir> Where is the bot?
11:17:14 <sebasmagri> Network.URI too monochrom
11:17:27 <monochrom> lambdabot is having a second interview with the Pentagon!
11:17:36 <sebasmagri> well and Data.Text heheh
11:17:46 <monochrom> interviewing for position "skynet operator" :)
11:18:10 <Elemir> Skynet monoid!
11:18:13 <monochrom> anyway, I'm referring to getJSONText
11:18:35 <sebasmagri> I guess the previous skynet operator was fired because he didn't kill us on april...
11:19:13 <squark42> Hi. I want to catch sigwinch and then exit my programm, what's the most convenient way to do this? I know how to install the handler, but "installHandler windowChange (Catch (exitFailure)) Nothing" does not work because the handler is invoked in a different thread and then exitFailure does not exit (it's documented)
11:21:14 <Skola> If I am working with large amounts of text (utf-8), what is the most performant type for my data?
11:21:21 <elliott> squark42: try forking off everything into different threads, ending your main thread with "takeMVar quit"
11:21:30 <elliott> squark42: and have the handler put () into the quit MVar?
11:21:38 <elliott> i.e. all the main thread does is wait for someone to tell it to quit
11:23:08 <monochrom> if you work with large amount of utf-8 directly and never need to decode, bytestring. if you work with large amount of Char directly so decoding is hardly relevant, Text
11:24:57 <sebasmagri> monochrom, I'm using Text in other places in the same module, but I'm willing to use aeson, and I've read that aeson requires bytestring and attoparsec
11:25:24 <squark42> that is, I have to communicate this to the main thread? Is it like a pipe() which you would use in C?
11:25:35 <elliott> sebasmagri: yeah but aeson parses the strings into Text
11:25:49 <elliott> squark42: well, just use an MVar -- which is a communication variable that is either empty or has a value in it
11:26:00 <mauke> it's a queue of size 1
11:26:09 <squark42> ok, thx, I will have a look at this
11:26:15 <elliott> do { quit <- newEmptyMVar; installhandler windowChange (Catch (putMVar quit ()) Nothing; ... fork off all your stuff ...; takeMVar quit }
11:28:54 <aluink> is there a good guide to the number types ou there? everytime I have to work with anything apart from Int, my head starts to spin
11:29:39 <aluink> Double, Float, Fractional, RealFrac, Num, etc....nothing compiles easily without LOTS of time reading and disecting docs
11:29:52 <shergill> haskell needs a types zoo
11:30:20 <elliott> aluink: well, two of those are ypes.
11:30:21 <elliott> types
11:30:26 <elliott> the others are typeclasses. very different
11:31:10 <aluink> yeah sure, i get that. but still when I want to do certain operations, they are often not defined on types, but on typeclasses.  so I lump them together...that's not the point of the question
11:31:47 <aluink> http://hpaste.org/66477
11:32:06 <aluink> that's my current little function, and i can't get it to work even though the logic is fine
11:32:53 <aluink> the strange part is if I leave out the type signature and import it into ghci, :t tells me it's of that same type.  yet, if I add the signature and reload, it fails.  what gives?
11:33:25 <elliott> you use truncate on bump
11:33:33 <elliott> :t truncate
11:33:39 <elliott> gah
11:33:39 <DanBurton> lambdabot down?
11:33:53 <elliott> who remembers what typeclass truncate is in? :)
11:34:04 <aluink> (RealFrac a, Integral b) => a -> b
11:34:15 <DanBurton> http://lmgtfy.com/?q=hayoo
11:34:48 <elliott> aluink: right
11:34:57 <elliott> you apply truncate to something that's allowed to be any Num
11:35:00 <elliott> but not all Nums are RealFrac
11:35:06 <maurer> OK, fixed it, I just needed ScopedTypeVariables
11:35:07 <monochrom> bump - this is ill-typed
11:35:13 <elliott> oh, that too
11:35:19 <elliott> but more importantly, "this" is ill-typed
11:35:37 <maurer> Any fans of OCaml or ML may find https://gist.github.com/2312891 interesting. Still looking for a good recursive functor example to finish it off
11:36:18 <aluink> i realize a lof of this is illtyped, stemming from the fact that I don't have a good grasp of the number types and typeclasses
11:36:29 <aluink> hence my original question
11:36:40 <aluink> but if we were to use this as an example, how should this be typed?
11:36:48 --- mode: glguy set -bbbb $x:~g*!*@pool-*.lsanca.fios.verizon.net#*purple* *!~Rapeseed@201.160.243.202 *!*Fifo@*.antik.sk *!*@c-66-30-168-93.hsd1.ma.comcast.net
11:36:51 <aluink> cause I really don't know
11:38:13 <glguy> Please excuse my dust, this will only take a moment
11:38:21 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.92.228.7.110 *!*@*.dsl.dyn.telnor.net *!*n1gg3rs@*.171.0.192.dsl.dyn.telnor.net *!*CornFeces@*.130.154.254.dsl.dyn.telnor.net
11:38:24 --- mode: glguy set -bbbb *!*Yigabu@*.170.67.163.dsl.dyn.telnor.net *!*@201.170.62.60.dsl.dyn.telnor.net *!~JiggyBlkM@201.130.152.147.dsl.dyn.telnor.net *!*ChorizoGr@*.170.169.40.dsl.dyn.telnor.net
11:38:27 --- mode: glguy set -bbb *!*@201.170.83.247.dsl.dyn.telnor.net *!*54c3b2a8@gateway/web/freenode/ip.84.195.178.168 *!*n1gg3rs@*.171.0.192.dsl.dyn.telnor.net
11:38:30 --- mode: glguy set -bbbb *!*CornFeces@*.130.154.254.dsl.dyn.telnor.net *!*c3c3eb72@*.195.195.235.114 *!*Yigabu@*.170.67.163.dsl.dyn.telnor.net *!~cacala@125.129.69.135
11:38:33 --- mode: glguy set -bbbb *!*Lajla@*.speed.planet.nl *!*@201.170.62.60.dsl.dyn.telnor.net *!~JiggyBlkM@201.130.152.147.dsl.dyn.telnor.net *!*emanuel@196.34.164.*
11:38:36 --- mode: glguy set -bbbb *!*jojo@196.34.164.* *!*RandyJan@*.ws *!*@ip72-207-18-160.sd.sd.cox.net *!~stenobot2@c-76-17-84-218.hsd1.ga.comcast.net
11:38:39 --- mode: glguy set -bbbb *!*@182.7.140.129 *!*regnorgs@182.7.102.218 *!*@95.175.151.192 *!*qawdgj@*.bbccable.net
11:38:43 --- mode: glguy set -bbbb *!*@86.120.244.99 *!*Blooop@2001:470:1f08:12e0::* *!~tim@c-76-20-80-170.hsd1.ca.comcast.net *!*@user-jail.underscorepipe.com
11:38:45 --- mode: glguy set -bbbb *!u3625@gateway/web/irccloud.com/x-ovaugyqfyyhqoijp *!*Goodad@*.dyn.as47377.net *!*@cust-21-115-109-94.dyn.as47377.net *!5b87a963@gateway/web/freenode/ip.91.135.169.99
11:38:48 --- mode: glguy set -bbbb *!*tinu@*.nycmny.fios.verizon.net *!112d8769@gateway/web/freenode/ip.17.45.135.105 *!~workstati@adsl-99-44-224-240.dsl.pltn13.sbcglobal.net *!~usuario@189.220.55.78.cable.dyn.cableonline.com.mx
11:38:53 --- mode: glguy set -bbbb *!bddc374e@gateway/web/freenode/ip.189.220.55.78 *!18788ea5@gateway/web/freenode/ip.24.120.142.165 *!*@gateway/web/freenode/ip.178.73.* *!*@79.100.251.47
11:38:56 --- mode: glguy set -bbbb *!*c7d4fa61@*.199.212.250.97 *!*451dd617@*.69.29.214.23 *!~stenobot2@173.247.10.20 *!*@gateway/web/freenode/ip.99.188.94.225
11:38:58 --- mode: glguy set -bbbb *!*bddc1939@*.189.220.25.57 *!*@adsl-84-145-16.gsp.bellsouth.net *!*@75.134.98.150 *!*@*.i-next.psi.br
11:38:59 <elliott> aaaaaaaaaaaaa
11:39:01 --- mode: glguy set -bbbb *!*funny-gir@*.grybow.net.pl *!*@201.102.60.119 *!*@200.57.252.196 *!5859c5b3@gateway/web/freenode/ip.88.89.197.179
11:39:05 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.80.212.72.208 *!*80f315e0@*.128.243.21.224 *!*se@*.bredband.comhem.se *!*miron123@*.pool.ukrtel.net
11:39:05 <elliott> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
11:39:07 --- mode: glguy set -bbbb *!*@174-125-77-19.dyn.centurytel.net *!*@hades.skidsr.us *!*@ip68-98-120-6.ph.ph.cox.net *!*@66-168-255-112.static.mtgm.al.charter.com
11:39:11 --- mode: glguy set -b *!*@c-66-177-245-64.hsd1.fl.comcast.net
11:39:13 <elliott> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
11:39:19 <tdubellz> chill out
11:39:29 <shachaf> glguy: Can I get unbanned too?
11:39:32 <gnoi> ehird ok
11:39:47 <bitonic> what the hell?
11:39:47 <lispy> glguy++
11:39:54 <mauke> major cycle
11:39:59 * aluink doesn't know what that was all about
11:40:12 <elliott> glguy is amassing the hordes of trolls and spammers
11:40:16 <elliott> he's going to wage war on #haskell from inside
11:40:53 <nand`> Anybody know how to have lambdabot not consider ? a trigger for commands?
11:40:55 <nand`> So just @ is used
11:41:24 <Rc43> Hmmm
11:41:27 <Rc43> Shouldn't Data.Set.difference be equivalent to something like `toList $ foldr delete (union f s) $ toList (intersection f s)`.
11:41:44 <Rc43> I.e. just union without intersection.
11:41:59 <Rc43> Data.Set.difference returns something strange.
11:42:06 <byorgey> Rc43: that's usually called "symmetric difference"
11:42:13 <monochrom> you misunderstood the inferred type. the inferred type is f :: (RealFrac a, Num b, Integral a) => a -> b -> [a]
11:42:14 <Rc43> byorgey, oh
11:42:19 <Rc43> byorgey, really, I forgot
11:42:23 <byorgey> x `Data.Set.difference` y  is all those elements in x which are not in y
11:43:02 <byorgey> does Data.Set define a symmetric difference function?  I am not sure
11:43:05 <monochrom> of course, there are very few types satisfying both RealFrac and Integral. I haven't seen one yet
11:43:13 <elliott> @src RealFrac
11:43:13 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
11:43:13 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
11:43:13 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
11:43:26 <Rc43> byorgey, yeah; so single way to get symmetric diff is to use combination of two functions? (union of diffs or union without intersection)
11:43:36 <aluink> yeah, i'm looking at RealFrac on hackage
11:43:36 <byorgey> looks easy enough to make a RealFrac instance for Integer =)
11:43:38 <elliott> monochrom: well, everything but (/) and fromRational is trivial
11:43:41 <elliott> byorgey: nope, because
11:43:42 <elliott> @src Fractional
11:43:42 <lambdabot> class  (Num a) => Fractional a  where
11:43:43 <lambdabot>     (/)             :: a -> a -> a
11:43:43 <lambdabot>     recip           :: a -> a
11:43:43 <lambdabot>     fromRational    :: Rational -> a
11:43:44 <byorgey> oh, Fractional
11:43:49 <elliott> hmm
11:43:51 <elliott> @src Integral
11:43:51 <byorgey> didn't see the superclasses, sorry =)
11:43:52 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:43:52 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:43:52 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:43:52 <lambdabot>     toInteger           :: a -> Integer
11:44:18 <elliott> meh, just generalise quot/rem to a fractional type :p
11:44:22 <byorgey> Rc43: yeah
11:44:22 <elliott> ...oh, toInteger.
11:45:07 <aluink> hey guys! remember me? lol...you left me way back here...i'm lost
11:45:23 <aluink> that was a bit too fast ;)
11:45:36 <monochrom> you could use properFraction. this doesn't change your type problem, but it's two birds in one stone
11:45:56 <aluink> :t properFraction
11:45:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
11:46:04 <monochrom> oh actually, since it spares you from doing your own subtraction, it solves your type problem
11:46:20 <monochrom> that's 3 birds in 1 stone. I'm pleased
11:46:24 <elliott> > properFraction pi
11:46:25 <lambdabot>   (3,0.14159265358979312)
11:46:29 <elliott> right
11:46:37 <aluink> epic! that's exactly what i need!
11:46:46 <glguy> almost done
11:47:21 --- mode: glguy set -bbbb *!*@173-30-206-121.client.mchsi.com *!*c9a0f27e@*.201.160.242.126 *!*soulthief@82.77.166.* *!*@*80.212.75.146
11:47:24 --- mode: glguy set -bbbb *!*Bubby@*.dip.t-dialin.net *!*@gateway/web/freenode/ip.80.212.73.121 *!*@drb81.neoplus.adsl.tpnet.pl *!~ircap@190.189.21.253
11:47:27 --- mode: glguy set -bbbb *!*bddc1619@gateway/web/freenode/ip.189.220.22.25 *!*FusionX@millie.kottnet.net *!*Angelion@*.broadband.corbina.ru *!*@gateway/web/cgi-irc/irc.wikia.com/*
11:47:30 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.60.217.232.41 *!*@221.130.*.* *!*dd82a2e7*@gateway/web/freenode/ip.221.130.162.* *!*@60.217.*.*
11:47:30 <aluink> i'm working on http://bit.ly/I8NZzc btw
11:47:33 --- mode: glguy set -bbbb *!*ae72f893@gateway/web/freenode/ip.174.114.248.147 *!*@gateway/web/freenode/ip.68.39.229.135 *!*@gateway/web/freenode/ip.60.228.242.112 *!*Lajla@*.adsl.xs4all.nl
11:47:36 --- mode: glguy set -bbbb *!~55c89673@* *!*3cd9e854@*.60.217.232.84 *!*@84.79.67.254 *!*afrid*@115.132.185.*
11:47:39 --- mode: glguy set -bbbb *!*Libster@*.bltmmd.east.verizon.net *!*~BjornLop@201.160.239.146.cable.dyn.cableonline.com.* *!*sbpaul@*.twcny.res.rr.com *!*b@*.49.23.98.dynamic.ip.windstream.net
11:47:40 <monochrom> (this, next) = properFraction bump
11:47:42 --- mode: glguy set -bbbb *!*@pool-71-102-81-229.plspca.dsl-w.verizon.net *!*ouple4674@92.37.228.* *!*@189.220.21.241.cable.dyn.cableonline.com.mx *!*@64.134.232.41
11:47:45 --- mode: glguy set -bbbb *!*DLEhelp@117.193.200.* *!*@134.53.180.66 *!*@pool-173-73-27-43.washdc.fios.verizon.net *!*@63.223.127.*
11:47:48 --- mode: glguy set -bbbb *!*opera@91.135.242.* *!*@cpe-76-172-28-85.socal.res.rr.com *!*@ppp*.tis-dialog.ru *!*@201.160.235.225.cable.dyn.cableonline.com
11:47:50 <nand`> glguy: spring cleaning?
11:47:51 --- mode: glguy set -bbbb *!*@203-219-249-173.static.tpgi.com.au *!*Surrador@*.160.235.225.cable.dyn.cableonline.com.mx *!*ce_jago_b@95.66.3.208 *!*@dsl-245-176-142.telkomadsl.co.za
11:47:54 --- mode: glguy set -bbbb *!*@89.242.20.36 *!*@gateway/web/freenode/x-piivytiolffrpmzp *!*@pool-173-70-160-250.nwrknj.fios.verizon.net *!*Daz_*@*.tnyt1.lon.bigpond.net.au
11:47:56 <geekosaur> looks like it
11:47:57 --- mode: glguy set -bbbb *!*ZCDu56cDH@2001:470:c070:ff6a:7a61:210a:c4d:* *!*@ip-134-53-244-195.dhcp.muohio.edu *!*Fvalerius@95.66.38.* *!*@94.122.197.190
11:47:58 <aluink> monochrom: yeah, exactly! that's awesome
11:48:00 --- mode: glguy set -bbbb *!*@201.160.242.20.cable.dyn.cableonline.com.mx *!*@host-84-222-186-23.cust-adsl.tiscali.it *!*weed@*.dnsprincipal.com *!*gav@*.socal.res.rr.com
11:48:03 --- mode: glguy set -bb *!*@ip72-207-23-78.sd.sd.cox.net *!*@64.134.233.103
11:48:22 <aluink> ok...seriously, is he unbanning a bunch of people, or...what's -bb*?
11:48:24 <glguy> nand`: yes, the list is long and stale
11:48:36 <nand`> aluink: yes, he's unbanning a bunch of people
11:48:59 <aluink> ahh
11:49:09 <nand`> -b is the mode change (+b means ban, -b is the opposite); and *!*@ip72-207-23-78.sd.sd.cox.net is the address he's unbanning -> in this case an IP address
11:49:25 <nand`> -bb just means he's unbanning two people at once
11:50:57 <glguy> should be the last set
11:50:58 --- mode: glguy set -bbb *!*@201.171.123.85 *!*@89.31.88.211 *!*@ppp91-76-87-111.pppoe.mtu-net.ru
11:50:59 --- mode: glguy set -bbb *!*@so-12536-x0.essex.ac.uk *!*@78.147.75.157 *!*@bas4-montreal02-1096722726.dsl.bell.ca
11:51:01 --- mode: glguy set -bbb *!*@gateway/web/freenode/ip.193.137.156.* *!*mastermak@*.hsi6.kabel-badenwuerttemberg.de *!*mathnerd3@*.6.28.53.206.cos.dyn.pcisys.net
11:51:04 --- mode: glguy set -bb *!SolarNRG@94-195-174-233.zone9.bethere.co.uk *!~jasonleds@c-68-55-116-174.hsd1.md.comcast.net
11:51:19 <glguy> Thank for your patience!
11:51:33 <bitonic> glguy: so wait, you're unbanning n1gg3rs, CornFeces and Rapeseed?
11:52:05 <glguy> If they come back on that exact same ipaddress/name mask we can reban them
11:52:26 <bitonic> lol ok
11:52:28 <edwardk> bitonic: the bans were painfully specific to single ips they probably aren't on any more
11:52:39 <bitonic> edwardk: that's true
11:52:44 <elliott> I like how unsafeCoerce is banned from #haskell
11:52:47 <elliott> we're a type-safe channel
11:52:59 <bitonic> CornFeces and Rapeseed are creative nicks at list
11:54:05 <nand`> I wonder why *!*@221.130.*.* was blanket-banned
11:54:12 <nand`> or what country/zone that is
11:54:12 <sebasmagri> elliott, actually I'm quite confused about this. What do you suggest me then?
11:54:16 <elliott> nand`: probably persistent spam/trolling
11:54:33 <elliott> sebasmagri: sorry, I've forgotten what i said to you or what your problem was :)
11:54:33 <nand`> elliott: surely that must generate a lot of collateral damage
11:55:05 <sebasmagri> elliott, heheheh, could you please look at this http://hpaste.org/66476?
11:55:08 <glguy> If anyone wants to discuss banning and whatnot they can talk about it in #haskell-ops, let's keep this channel focused :)
11:55:39 <edwardk> nand`: sometimes. its also possible to set up redirect bans when you make big like that
11:55:58 <edwardk> er make something big like that
11:55:59 <elliott> sebasmagri: oh, well HTTP doesn't support Text I guess
11:56:23 <sebasmagri> elliott, yep, Iḿ using unpack because of that...
11:56:24 <elliott> sebasmagri: by my aeson thing (this is the aeson thing right?) i just meant that aeson supports text in that if you have a string in the json it gets parsed as a Text value
11:57:16 <monochrom> oh, getJSONText is a recursive call to itself, sorry
11:59:02 <sebasmagri> elliott, hmmm ok... that shouldn't be a problem...
11:59:30 <sebasmagri> as I'm willing to use encode/decode and my data types already use Text
12:00:15 <sebasmagri> my concern is mainly about
12:00:16 <sebasmagri> result <- simpleHTTP (mkRequest GET (fromJust $ parseURI (Txt.unpack url)))
12:00:38 <sebasmagri> which is the expression that makes the compiler fail
12:00:48 <sebasmagri> *the compilation
12:03:15 <sebasmagri> earlier I was considering the case in which the URI parsing fails, but I removed that code to make things simpler by now.
12:03:31 <pedrobf> can anyone give me a hand here?
12:05:41 <geekosaur> "don't ask to ask, just ask"
12:06:12 <acowley> pedrobf was asking for applause, but I'm not convinced he's earned it yet.
12:08:03 <Lemon> :t newIORef
12:08:04 <lambdabot> Not in scope: `newIORef'
12:08:11 <Lemon> :t newSTRef
12:08:12 <lambdabot> forall a s. a -> ST s (STRef s a)
12:08:23 <Lemon> hm
12:11:24 <dgpratt> I'm looking at this line of code: cabalInstallPath <- liftIO $ which "cabal"
12:11:57 <dgpratt> which :: String -> IO (Maybe FilePath), by the way
12:12:18 <dgpratt> in the event that it returns nothing, I want it to return which "cabal.exe"
12:12:22 <pedrobf> http://pastebin.com/JubbEied how can i convert from `IO a0' to `[String]'?
12:12:25 <mauke> The paste JubbEied has been copied to http://hpaste.org/66478
12:12:42 <elliott> dgpratt: is which x ever expensive?
12:12:49 <dgpratt> I have a feeling there's a clever and concise way to do that; am I right? how?
12:12:52 <elliott> i.e. do you want to avoid doing which "cabal.exe" if which "cabal" works?
12:13:04 <byorgey> dgpratt: cabalInstallPath <- liftIO $ liftM2 mplus (which "cabal") (which "cabal.exe")
12:13:09 <dgpratt> elliott: hmm; could be
12:13:25 <byorgey> well, yeah, my version will always run both calls to which
12:13:26 <Saizan> byorgey: that'd need MaybeT
12:13:26 <dgpratt> byorgey: thanks! will that short circuit?
12:13:44 <copumpkin> Saizan: really?
12:13:45 <byorgey> Saizan: no it doesn't
12:13:54 <elliott> byorgey: that's what i was going to say :P
12:13:58 <elliott> except with (<|>) rather than mplu
12:13:59 <elliott> s
12:13:59 <Saizan> oh, right
12:14:09 <elliott> dgpratt: but no it doesn't short-circuit, here's what you need if you want to avoid that:
12:14:26 <elliott> dgpratt: liftIO . join $ which "cabal" >>= fromMaybe (which "cabal.exe")
12:14:29 <elliott> oh hm
12:14:33 <elliott> dgpratt: liftIO . join $ which "cabal" >>= maybe (which "cabal.exe") return
12:14:37 <elliott> that's ugly :(
12:15:05 <dgpratt> elliott: a bit :) , but if it works, I'm quite satisfied
12:15:11 <dgpratt> elliott: thanks
12:15:14 <elliott> yw
12:17:52 <dgpratt> if you were going to encapsulate that alternate attempt, would you include the 'liftIO' or leave that bit behind?
12:18:16 <acowley> leave it behind
12:18:26 <dgpratt> acowley: that was my instinct, thanks
12:18:48 <elliott> dgpratt: i'd omit the liftIO
12:19:24 <dgpratt> elliott: ok, thanks
12:20:00 <acowley> pedrobf: You can't take a value out of IO altogether, but you can work with it within IO. Perhaps looking over something like this could help, http://learnyouahaskell.com/input-and-output
12:21:20 <fmn> Absolutely newbie. I have the following list: pixels = [[255, 255, 255], [0, 0, 0]], but pixels !! 0 seems to return a double
12:21:54 <fmn> (Actually a list of three Doubles)
12:22:00 <Mathnerd314> @hoogle MaybeT
12:22:00 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:22:00 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
12:22:00 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
12:22:28 <blackdog> fmn: seems to return three Integers here.
12:22:35 <elliott> fmn: Yes, it returns a list of three Doubles.
12:22:43 <pedrobf> acowley, i was studying from that page, but it was 3 in the morning and my english isn't one of the bests
12:22:44 <elliott> The first element of [[255, 255, 255], [0, 0, 0]] is a list of three Doubles.
12:23:49 <fmn> elliott: When I enter the very same line in ghci, I get a list of three Integers
12:23:50 <blackdog> fmn: are you using it in the context of a file?
12:23:55 <fmn> blackdog: Yes
12:24:04 <blackdog> there's some defaulting happening in GHCi
12:24:14 <blackdog> if you do
12:24:14 <blackdog> let  pixels = [[255, 255, 255], [0, 0, 0]] :: [[Double]]
12:24:36 <blackdog> in ghci, it'll come out as doubles. in your file, you're probably using the result as a double, so the type inferencer works backwards to help you out.
12:24:41 <elliott> oh, i see.
12:24:44 <elliott> right
12:24:55 <Mathnerd314> {-# LANGUAGE NoMonomorphismRestriction #-} ftw
12:26:51 <fmn> Oh yes, I see, and this is way ahead of where I want to be right now -- how can I make an List of Integers of it while declaring it?
12:27:16 <blackdog> fmn: attach a typesig
12:27:24 <blackdog> pixels::[[Integer]]
12:27:27 <blackdog> pixels = ...
12:27:42 <elliott> better pixels :: [[Integer]]
12:28:51 <blackdog> elliott: heh. yeah, probably. but what's a little whitespace between friends?
12:29:13 <fmn> Thank you.
12:33:35 <dgpratt> holy crap, I think it kinda worked!
12:35:16 <dgpratt> now I just need to figure out how to translate this bash script into something I can use on Windows...
12:36:54 <osa1> I'm trying to do IO inside of a State monad, I know I should use StateT in this case but my IO functions' return types are different, ie sometimes IO (), sometimes IO Char, is it possible to do this with StateT?
12:37:11 <elliott> yes
12:37:17 <gnoi> How can I substitute all x elems of list with y? like f 1 2 [1,3,1,3] = [2,3,2,3]
12:37:29 <mauke> map
12:37:34 <gnoi> map what?
12:37:39 <mauke> a function
12:37:48 <kaitocracy> hi what does this mean?
12:37:48 <kaitocracy> Cannot use record selector `runConvertor' as a function due to escaped type variables
12:37:51 <gnoi> There is no built-in analogue?
12:38:14 <mauke> @hoogle a -> a -> [a] -> [a]
12:38:15 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
12:38:15 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
12:38:15 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
12:39:21 <Mathnerd314> dgpratt: use MSYS?
12:40:05 <nand`> Hmm.. is there a word for a value which match Monad m => m a
12:40:10 <elliott> better Cygwin; MSYS is just a fork of a really old Cygwin
12:40:17 <nand`> which can match*
12:40:18 <dgpratt> Mathnerd314: does MSYS have a bash interpreter? in any case, I'd prefer something more native, if possible
12:40:24 <sipa> nand`: a monadic action
12:40:32 <elliott> sipa: for all m, I would assume?
12:40:35 <elliott> nand`: "trivial" :)
12:40:40 <dgpratt> elliott: really? Cygwin and MSYS seem quite different
12:40:54 <elliott> MSYS is just Cygwin but stripped down and ancient
12:41:25 <nand`> well, for example, "foobar" can match Monad m => m a with m being [] and a being Char; I wouldn't call "foobar" a monadic action though
12:41:27 <dgpratt> elliott: oh, maybe I'm confusing MSYS with MinGW
12:41:42 <elliott> yeah, MinGW is the compiler
12:41:43 <elliott> native
12:41:54 <elliott> MSYS is just the extra stuff they offer
12:41:57 <nand`> dgpratt: you can use Interix which is probably as native as it gets
12:42:03 <nand`> and also unsupported
12:42:12 <nand`> (Interix is a POSIX API into the windows kernel)
12:42:25 <nand`> (So you can just compile and run bash natively)
12:43:23 <elliott> it's the NT kernel, not Win32
12:43:29 <elliott> it's very much the opposite of native from a Win32 perspective
12:43:33 <elliott> there's a nice Gentoo Prefix installer for it though
12:43:34 <nand`> (You can also run linux executables with LBW)
12:43:35 * geekosaur thinks the better route is rewrite it as a powershell script
12:43:47 * hackagebot yesod-core 1.0.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.0.1 (MichaelSnoyman)
12:43:50 * hackagebot yesod-form 1.0.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.0.0.1 (MichaelSnoyman)
12:43:52 * hackagebot yesod-static 1.0.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.0.0.1 (MichaelSnoyman)
12:43:57 <dgpratt> geekosaur: that was along the lines of what I was thinking
12:44:16 <dgpratt> geekosaur: although probably actually a CMD script, for portability
12:44:28 <nand`> rewrite it as a haskell script
12:44:31 <nand`> cross-platform
12:46:04 <geekosaur> dgpratt, but you'l find powershell is probably closer in terms of capabilities, if it's anything beyond a simple list of commands
12:46:39 <geekosaur> CMD.EXE is better than COMMAND.COM ever was, but still misses a bunch of things bash has; PowerShell is if anything more capable than bash
12:47:15 <dgpratt> geekosaur: agreed on all points; this script is pretty simple, though
12:48:03 <mauke> unfortunately powershell is undocumented
12:48:03 <nand`> you can also use GnuWin32's port of bash
12:48:07 <elliott> i actually agree with nand` wrt haskell
12:48:28 <nand`> #!/usr/bin/runhaskell
12:48:46 <dgpratt> elliott, nand` : an interesting idea, but can a Haskell script modify the local env?
12:48:58 <dgpratt> mauke: eh?
12:49:07 <nand`> I don't know, I've never tried
12:49:14 <nand`> ?faq Can Haskell modify the local env?
12:49:14 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:33 <geekosaur> hah.  sadly no; not because of haskell but because of process environment isolation
12:49:35 <dgpratt> nand`: lol
12:49:44 <elliott> dgpratt: oh, no; technically "the env" just exists inside your shell
12:49:51 <dgpratt> geekosaur: yep, that was my assumption
12:49:52 <elliott> the persistnt, mutable environment is an illusion
12:49:55 <elliott> *persistent
12:50:06 <mauke> dgpratt: eh?
12:50:21 <dgpratt> mauke: powershell is undocumented?
12:50:25 <mauke> yes
12:51:42 <nart> anyone here has written a little game in haskell, like a snake, pong ... ? i would like to see the source
12:52:08 <nand`> nart: there's “Frag”, a 3D shooter
12:52:09 <dgpratt> mauke: well, I have a help file right here; I suppose that's not what you mean?
12:52:13 <nand`> but that's probably not what you're looking for
12:52:23 <nart> nand`: eh i know, but it's too complex
12:52:27 <mauke> dgpratt: does it document the command line syntax?
12:52:42 <nart> nand`: i need something simple and easy to understand
12:53:03 <LambdaMutt> http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
12:53:04 <geekosaur> powershell is "undocumented" because most of the documentation is really that of .net
12:53:33 <dgpratt> mauke: good question, but if not, how do I know what it is? :)
12:53:48 * hackagebot yackage 0.5.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.5.0 (MichaelSnoyman)
12:53:49 <mauke> dgpratt: what do you mean by "it"?
12:53:50 * hackagebot clientsession 0.7.4.3 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.4.3 (MichaelSnoyman)
12:53:52 * hackagebot warp-tls 1.2.0.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.0.1 (MichaelSnoyman)
12:53:54 * hackagebot mime-mail-ses 0.2.0.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.0.1 (MichaelSnoyman)
12:53:56 <geekosaur> powershell's power comes from being a simple command line mechanism for manipulating .net classes; all it need document is the relatively simple glue, all else comes from the clases themselves
12:54:01 <nand`> nart: I don't know if this helps but I'd probably use something like handle :: Input -> State World along with draw :: World -> IO ()
12:54:03 <dgpratt> mauke: the command line syntax
12:54:11 <mauke> geekosaur: no, powershell is undocumented because the developers didn't write any documentation
12:54:18 <mauke> dgpratt: you don't because it's undocumented
12:54:24 <dgpratt> mauke: ah
12:54:49 <dgpratt> mauke: apparently I have been deluding myself
12:55:22 <dgpratt> mauke: 'tis an interesting point you make
12:55:29 <gnoi> How can I define this `f'? f [(+1), (*2), (-3)] 2 == 3
12:55:38 <mauke> geekosaur: f _ _ = 3
12:55:43 <mauke> argh
12:55:46 <mauke> gnoi: f _ _ = 3
12:55:48 <geekosaur> bzzt
12:55:56 <gnoi> mauke: )))))
12:56:18 <elliott> > sequence [(+1), (*2), (-3)] 2
12:56:19 <lambdabot>   [3,4,-3]
12:56:22 <elliott> oh, not sequence
12:56:23 <mauke> geekosaur: at least that's what I read on a microsoft forum
12:56:27 <elliott> > foldr (.) id [(+1), (*2), (-3)] 2
12:56:28 <lambdabot>   -5
12:56:31 <elliott> > foldl (.) id [(+1), (*2), (-3)] 2
12:56:33 <lambdabot>   -5
12:56:40 <elliott> gnoi: i have no idea what your function is meant to do
12:56:41 <gnoi> elliott: -5 is wrong
12:56:49 <elliott> i agree with mauke
12:56:53 <gnoi> -3 os wrong*
12:57:00 <gnoi> is*
12:57:01 <mauke> > let f = const . length in f [(+1), (*2), (-3)] 2
12:57:03 <lambdabot>   3
12:57:31 <elliott> > let f = const . negate . ($ 0) . last in f [(+1), (*2), (-3)] 2
12:57:33 <lambdabot>   3
12:57:35 <elliott> oh, it's (-3) that's wrong
12:57:38 <elliott> you mean subtract 3
12:57:42 <gnoi> uguu
12:57:47 <elliott> caleskell yet a-f'in-gain
12:57:47 <gnoi> Sorry
12:57:56 <elliott> > foldr (.) id [(+1), (*2), subtract 3] 2
12:57:58 <lambdabot>   -1
12:58:01 <elliott> heh
12:58:08 <elliott> > foldr (>>>) id [(+1), (*2), subtract 3] 2
12:58:09 <lambdabot>   3
12:58:12 <gnoi> Great
12:58:22 <nand`> elliott: that one I like
12:59:07 <mauke> > (return . sum . map 1) [(+1), (*2), subtract 3] 2
12:59:09 <lambdabot>   3
12:59:45 <mauke> > (sum . map 1) [(+1), (*2), subtract 3] 2
12:59:47 <lambdabot>   3
12:59:54 <mauke> excellent
13:00:17 <nand`> mauke: perfect
13:00:18 <elliott> mauke: aka length
13:00:32 <mauke> no, just length would be a type error
13:00:37 <elliott> I mean, genericLength
13:00:39 <mekeor> so, when i throw an error in a pure function, like 'head [] = error "foobar"', can i "catch" that error?
13:00:45 <elliott> mekeor: only in IO. don't.
13:00:47 <elliott> just don't use error.
13:00:48 <gnoi> elliott: can I use foldr1 to avoiding id?
13:00:48 <elliott> or head. or tail.
13:00:56 <elliott> gnoi: if you want it to break arbitrarily on the empty list, yes
13:00:58 <elliott> > genericLength [(+1), (*2), subtract 3] 2
13:00:59 <lambdabot>   3
13:01:22 <fmn> Wow, this is wicked! take 8 [x * 2 | x <- [1,2..]]
13:01:37 <mekeor> elliott: head was just an example… anyway, so you say, i should just use Either or Maybe, right?
13:01:50 <sipa> > map (*2) [1..8]
13:01:50 <elliott> mekeor: yes
13:01:51 <lambdabot>   [2,4,6,8,10,12,14,16]
13:02:12 <nand`> mekeor: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
13:02:45 <elliott> that article is (more than) a bit out of date
13:03:01 <nand`> ah, 2007
13:03:06 <fmn> sipa: Yeah, but my way is more fun
13:03:16 <elliott> anyone who uses Monad + fail is living in sin, and I don't think anybody really uses MonadError... I hope
13:03:22 <sipa> fmn: strange definition of fun, but to each their own!
13:03:25 <mekeor> nand`: neat, thanks :)
13:03:27 <elliott> plus the throwDyn/ioError stuff is all irrelevant now
13:03:32 <elliott> since we just have Control.Exception
13:04:04 <mekeor> nand`: wow. but according to your link, i CAN catch pure-errors!
13:04:16 <elliott> mekeor: in IO, yes.
13:04:20 <elliott> <elliott> mekeor: only in IO. don't.
13:04:22 <mekeor> elliott: are you talking to me? would be nice if you could mention my name, if so…
13:04:25 <nand`> fmn: well, that's equivalent to take 8 $ [1,2..] >>= return . (*2); which is equivalent to take 8 $ fmap (*2) [1..] -- which is still a less roundabout way of doing it
13:04:33 <elliott> mekeor: I was talking to the article
13:04:35 <elliott> and indirectly nand`
13:04:36 <mekeor> elliott: "We can catch the error using Control.Exception.catch:"
13:04:44 <mekeor> elliott: see link
13:04:46 <elliott> mekeor: what type do you think Control.Exception.catch has?
13:04:51 <elliott> i know what is at that link, thanks.
13:05:03 <mekeor> :)
13:05:13 <nand`> :t Control.Exception.catch
13:05:15 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
13:05:23 <nand`> ha
13:05:38 <mekeor> ah, he hacks it by using putStrLn on it …
13:06:08 <elliott> mekeor: anyway, if you must do that, use throw rather than error
13:06:10 <mekeor> sorry. i'll just read that link, thanks once more.
13:06:13 <elliott> but don't do that
13:06:16 <elliott> i don't recommend reading that link
13:06:20 <elliott> as i said, it's quite thoroughly out of date
13:06:22 <mekeor> why?
13:06:25 <mekeor> okay…
13:06:43 <mroman_> What is "Void" used for?
13:06:44 <mekeor> elliott: so, i should just use Either and anything is fine (and pure =]), right? okay.
13:06:53 <elliott> mekeor: that's probably the best thing, yes
13:06:59 <elliott> you can use the MonadError functions to create such values if you want
13:07:02 <nand`> unsafePerformIO $ Control.Exception.catch (return $ head []) (const $ return "Oh no!"))
13:07:02 <elliott> throwError/catchError
13:07:06 <elliott> mroman_: it's uninhabited
13:07:16 <elliott> mroman_: it's useful for making sure certain branches of a case can't be picked
13:07:18 <mekeor> nand`: BAH
13:07:22 <nand`> please don't kill me
13:07:23 <elliott> mroman_: for instance if you have Either Void a, you know it must contain an a (ignoring _|_)
13:07:33 <mekeor>  /kill nand`
13:07:37 <mekeor> @kill nand`
13:07:38 <lambdabot> Maybe you meant: keal kind tell
13:07:40 <elliott> @slap nand`
13:07:41 * lambdabot loves nand`, so no slapping
13:07:44 <elliott> what!
13:07:44 <elliott> @slap nand`
13:07:45 * lambdabot will count to five...
13:07:47 <elliott> :|
13:07:48 <elliott> @slap nand`
13:07:48 <lambdabot> I don't perform such side effects on command!
13:07:52 <mekeor> lol
13:07:54 <elliott> such favouritism
13:08:01 <mekeor> @slap me
13:08:01 * lambdabot orders her trained monkeys to punch mekeor
13:08:04 * nand` shrugs
13:08:12 <elliott> @slap nand`
13:08:13 * lambdabot pulls nand` through the Evil Mangler
13:08:13 <Rc43> Is there something more general then Foldable?
13:08:15 <elliott> finally!
13:08:16 <Rc43> I want to process tree-like structure, but instead of using foldMap or foldr I want to combine them.
13:08:22 <tdubellz> elliott: please stop
13:08:22 <elliott> Rc43: Combine them how?
13:08:26 <Rc43> It is like monad may be ...
13:08:34 <elliott> tdubellz: ?
13:08:35 <Rc43> elliott, will describe in few seconds
13:08:49 <tdubellz> elliott: '@slap nand`'
13:09:06 <Rc43> I am walking through tree (Tree h [c]).
13:09:10 <elliott> aw c'mon, mekeor did it almost as much ;)
13:09:26 <nand`> elliott: popularity doesn't justify something
13:09:34 <DanBurton> anyone here participated in the gsoc before?
13:09:52 <Rc43> I want to apply foldMap for result of foldr with h and [c].
13:09:53 <DanBurton> I have a question about the technicalities of something related to gsoc
13:10:08 <Rc43> (By [c] I mean list of type c.)
13:10:25 <mroman_> So... it's kinda like undefined?
13:10:31 <mekeor> elliott: you should join #haskell-blah ! =]
13:10:34 <mroman_> except it never terminates, like undefined does.
13:10:48 <nand`> Rc43: what do you mean “apply foldMap for the result of”?
13:10:56 <elliott> mekeor: no thanks
13:11:15 <Rc43> elliott, more concretely: I want to draw tree; all children should be placed around root, but every in some place relatively to root.
13:11:34 <Rc43> and for relation we need use foldr, but for drawing them all we need to use foldMap
13:11:35 <elliott> Rc43: I don't think that's necessarily something for Foldable, but I'm not sure
13:14:02 <Rc43> nand, suppose we have two substructures in tree: one describes children around root and other describes the one branch, which is going through all tree
13:14:22 <Rc43> nand, and for first we should use foldMap, but for second - foldr
13:14:27 <Rc43> but I can mistake
13:14:57 <mroman_> http://codepad.org/jwDga5b5
13:14:59 <Rc43> the problem is to combine this two substructures into one
13:15:22 <mroman_> with weird' it crashes and with weird it never terminates
13:17:39 <dmwit> mroman_: Nothing quite like a newtype to surprise you, eh?
13:18:05 <kaitocracy> hi I'm writing a little library for myself that lets me chain together 'validators' with >=>, basically functions that are :: Maybe a -> Writer [Message] (Maybe a); problem is that some of the validators need to perform IO, so now they've got to be :: Maybe a -> WriterT [Message] IO (Maybe a); any way I can make it so that my validators that don't need IO use Writer and the ones that use IO
13:18:05 <kaitocracy> use WriterT IO and I can still chain them together easily?
13:18:06 <elliott> this again?
13:18:08 <elliott> so soon?
13:18:11 <dmwit> mroman_: show never evaluates its argument at Void types.
13:18:21 <elliott> oh hmm
13:18:29 <elliott> it's not what i expected, i was expecting (C a) again :)
13:18:48 <dmwit> Actually, it has nothing to do with the fact that Void is a newtype.
13:18:53 * hackagebot pandoc 1.9.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.2 (JohnMacFarlane)
13:18:55 <dmwit> "show never evaluates its argument at Void type" is enough.
13:19:02 <elliott> by the way dmwit I disagree
13:19:07 <elliott> it does
13:19:14 <elliott> it's a derived instance, so show (Void v) = show v
13:19:17 <mroman_> For ghc < 7 data Void is used anyway
13:19:23 <elliott> oh hmm
13:19:27 <dmwit> =)
13:19:29 <elliott> well, show = const _|_ by that definition anyway
13:19:36 <mroman_> #if __GLASGOW_HASKELL__ < 700
13:19:37 <mroman_> data Void = Void !Void
13:19:38 <elliott> but it's an infinite loop, not an error
13:19:42 <elliott> oh wait!
13:19:43 <pedrobf> acowley, i managed to get past that error but now i'm getting a scope error... is there a way define a handle to be global?
13:19:47 <elliott> yes, right
13:19:48 <dmwit> No, show = const _|_ is incorrect.
13:19:59 <elliott> mroman_: left weird' is never evaluated there because of Void's Show instance
13:20:06 <elliott> dmwit: erm are you sure? the derived instance will be show (Void v) = show v
13:20:16 <dmwit> elliott: Not quite.
13:20:27 <dmwit> elliott: It's show (Void v) = "Void (" ++ show v ++ ")" or so
13:20:30 <dmwit> =)
13:20:33 <elliott> Ohhh, right.
13:20:40 <elliott> Constructors! Forgot about those things.
13:20:49 <elliott> For some reason my brain turns off whenever newtypes are being discussed apparently
13:21:29 <mroman_> left weird' is "non exhaustive pattern"
13:21:52 <elliott> mroman_: yep, but you only get that error once it's forced
13:21:58 <elliott> show :: Void -> String never forces its argument
13:22:06 <elliott> putStrLn . show $ (error "NOOOO!" :: Void) would do just the same
13:22:10 <kaitocracy> anyone? do I have to put all of my validators in the IO monad?
13:22:19 <elliott> kaitocracy: uh probably not
13:22:33 <elliott> kaitocracy: you can make them polymorphic
13:22:35 <Rc43> How called such recursion in english, when f calls g and then g calls f?
13:22:46 <nand`> bimutual recursion?
13:22:49 <elliott> needsIO :: (MonadWriter m [Message], MonadIO m) => m (Maybe a)
13:22:51 <nand`> or just mutual
13:22:53 <nand`> I forget
13:22:54 <mroman_> Oh.
13:22:55 <elliott> doesn't :: (MonadWirter m [Message]) => m (Maybe a)
13:23:03 <elliott> kaitocracy: then just use them as the WriterT IO version always
13:23:06 <mroman_> show left weird does never force its argument
13:23:07 <mroman_> ok
13:23:09 <elliott> Rc43: mutual recursion
13:23:10 <kaitocracy> elliott: that's what I tried to do
13:23:12 <Rc43> nand, just mutual recursion; thanks
13:23:20 <elliott> kaitocracy: what went wrong?
13:23:27 <kaitocracy> elliott: but then when I try to do needsIO >=> doesn't
13:23:36 <kaitocracy> then haskell doesn't know what to do
13:23:42 <kaitocracy> because my two m's are different
13:23:58 <elliott> no, that's the point
13:24:00 <elliott> the two ms should be the same
13:24:04 <elliott> <elliott> doesn't :: (MonadWirter m [Message]) => m (Maybe a)
13:24:09 <elliott> use this as WritterT [Message] IO (Maybe a)
13:24:20 <elliott> (by the way, you might want to use MaybeT (WriterT [Message]) IO a instead)
13:24:35 <elliott> (import Control.Monad.Trans.Maybe)
13:24:45 <elliott> oh wait, that would be bad
13:24:51 <elliott> since there's no corresponding typeclass... hmph
13:25:06 <kaitocracy> elliott: I need the Maybe because I have a validator that checks to see if the value is Nothing, if I use MaybeT then when I chain my validators together, that validator is ignored because of MaybeT behavior
13:25:15 <elliott> edwardk: is it transformers or mtl you have control over these days?
13:25:21 <elliott> kaitocracy: ah, ok
13:25:57 <edwardk> mtl
13:26:02 <elliott> edwardk: darn
13:26:34 <elliott> edwardk: i was going to ask you to put { class MonadMaybe m where nothing :: m a } in transformers :p
13:26:36 <edwardk> elliott: speaking of which ross got me the stuff i needed to do a reasonable version of the state patch, so i should do it
13:26:58 <edwardk> thats more or less the old MonadZero
13:27:19 <edwardk> i presume you wanted class Monad m => MonadMaybe m
13:27:29 <elliott> oh, yes
13:27:45 <elliott> all it needs is Maybe and MaybeT instances :p
13:28:17 <edwardk> *shrug* MonadPlus is an awful mess over all but nobody seems to care
13:28:21 <fun2012> Hi everybody, very quick question pls, how can I show any data type that dosent derive show instance, I'm just exploring different libraries from hackage and want to see result w/o having to write code to display it (something like debugging/watch)
13:28:38 <edwardk> its hard enough to get people to see the semantic issue at all let alone to have a conversation about it ;)
13:29:33 <jeff_s_> If I'm incrementing an Int from multiple threads on a multi-CPU computer, do I need MVar, or is modifyIORef safe?
13:30:30 <elliott> edwardk: I wasn't even thinking about MonadPlus, just realised that Maybe/MaybeT is the only monad/transformer pair without a typeclass
13:30:40 <edwardk> jeff_s_ you can probablyget by with an atomicModifyIORef at least
13:30:43 <elliott> which means you can't write stuff polymorphic in "anything with Maybe or MaybeT somewhere" :p
13:30:55 <jeff_s_> edwardk - OK thanks, I'll use that function instead.
13:31:00 <edwardk> elliott: thats because its handled by MonadPlus
13:31:06 <DanBurton> getting ready to submit this gsoc proposal, anyone care to review it? https://github.com/DanBurton/Blog/blob/master/Markdown/Type-safe%20URLs%20for%20Snap.md
13:31:08 <elliott> edwardk: yeah... ew
13:31:46 <mgsloan> has anyone made a class-instance shim generator?  In other words, you'd take one of the class's type variables, and replace it with a concrete datatype which is pretty much the same as the class's method dictionary.  This would work as long as that type is provided as an input once in each function
13:32:14 <edwardk> danburton: you should talk to copumpkin, he did something in agda with those recently
13:32:47 <DanBurton> preflex: seen copumpkin
13:32:47 <preflex>  copumpkin was last seen on #haskell 1 hour, 19 minutes and 3 seconds ago, saying: Saizan: really?
13:32:49 <nand`> instance (Monad a, Monoid b) => Monoid (a b) where mempty = return mempty; mappend = (>>) -- would this make sense?
13:32:51 <copumpkin> ohai
13:32:53 <edwardk> mgsloan: you can make one by hand of course with reflection
13:32:55 <DanBurton> hai
13:33:01 <copumpkin> mine were painfully typesafe
13:33:04 <nand`> oh, never mind
13:33:06 <copumpkin> are you ready for PAIN?
13:33:06 <nand`> it wouldn't
13:33:13 <nand`> because >> return mempty is not the same as id
13:33:25 <DanBurton> copumpkin: as long as it is sexily-typed pain, I'm ready.
13:33:38 <edwardk> nand`: the problem is there exist monads that have a different implementation that have the form something of kind * -> * applied to something of kind *, so that instance would overlap EVERYTHING
13:34:19 <edwardk> nand`: the 'right' way to do it is to make a newtype wrapper
13:34:20 <edwardk> http://hackage.haskell.org/packages/archive/reducers/0.1.8/doc/html/Data-Semigroup-Monad.html
13:34:25 <edwardk> see 'Mon'
13:34:41 <copumpkin> DanBurton: https://plus.google.com/u/0/106318233255980016498/posts/RgpRZgW7JSP and https://plus.google.com/u/0/106318233255980016498/posts/38FBoG9QskC :)
13:34:48 <copumpkin> man, google plus really knows how to make friendly URLs
13:35:00 <elliott> edwardk: oh, thanks, I didn't realise that was in a package
13:35:00 <edwardk> nand`: you can make that work with mappend = liftM2 mappend
13:35:30 <edwardk> elliott: i had an older version in the now-deprecated 'monoids' package as well ;)
13:35:51 <edwardk> nand`, elliott: there is also http://hackage.haskell.org/packages/archive/reducers/0.1.8/doc/html/Data-Semigroup-Alternative.html
13:36:01 <edwardk> er http://hackage.haskell.org/packages/archive/reducers/0.1.8/doc/html/Data-Semigroup-Applicative.html
13:36:42 <nand`> edwardk: indeed, liftM2 mappend works as expected
13:36:48 <DanBurton> copumpkin: that...is...AWESOME <3
13:37:08 <nand`> (the goal here is to have IO () be a monoid)
13:37:14 <copumpkin> DanBurton: thanks :) the belay suggestion was also interesting, from mzero
13:37:48 <copumpkin> https://gist.github.com/2203139
13:37:52 <nand`> so I can use something like foldMap (putStr)
13:38:16 <k0ral> hello, say I have [[ ... [a] ... ]]; how can I apply f to each "a" without concatenating many "map" ?
13:38:56 <mauke> k0ral: why?
13:38:58 <hpc> k0ral: you want fmap'' :: (a -> b) -> [[[a]]] -> [[[b]]]?
13:39:08 <hpc> :t fmap .: fmap
13:39:09 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
13:39:13 <k0ral> mauke: why not ?
13:39:14 <hpc> pah
13:39:18 <hpc> :t fmap . (.:)
13:39:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (g :: * -> *). (Functor f, Functor f1, Functor g) => (a -> b) -> f (f1 (g a)) -> f (f1 (g b))
13:39:24 <hpc> ^
13:39:30 <hpc> (.:) = fmap . fmap
13:39:30 <edwardk> :t fmap `fmap` fmap `fmap` fmap
13:39:31 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
13:39:53 <elliott> :t fmap fmap fmap fmap fmap
13:39:54 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
13:39:56 <DanBurton> :t (fmap `fmap` fmap `fmap` fmap) `asAppliedTo` [[[]]]
13:39:56 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
13:39:56 <lambdabot>     In the second argument of `asAppliedTo', namely `[[[]]]'
13:39:56 <lambdabot>     In the expression:
13:39:57 <elliott> oh lame
13:39:59 <clsmith> D:
13:40:16 <edwardk> the infixed `fmap`'s there were effectively .'s
13:40:36 <k0ral> so, eventually, what's the trick ?
13:40:40 <nand`> :t fmap fmap (fmap fmap fmap)
13:40:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
13:41:34 <edwardk> koral: the fmap . fmap . fmap trick everyone's been spamming. use a number of fmap's = to the number of []'s
13:41:41 <nand`> :t let fmap' = fmap `fmap` fmap in fmap' `fmap` fmap
13:41:42 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
13:41:44 <elliott> "map" also works :P
13:42:04 <clsmith> hm. is there a name for a multi-param type class E a b where, say, f :: a -> [b]? that is, i want to be able to convert this composite into one of a number of types of different 'coarseness'
13:42:06 <nand`> or fmap' `fmap` fmap' for the fmap'''' version
13:43:06 <clsmith> specific context: i have a buffer object and i want to be able to treat it as either a list of chunks or a list of chars or a list of bytes, depending on my mood
13:43:25 <mgsloan> argh, crappy time to lose wifi.  Did anyone respond to my question?
13:43:45 <nand`> edwardk │ mgsloan: you can make one by hand of course with reflection
13:43:55 <k0ral> elliott: doesn't work :p
13:43:57 <mgsloan> edwardk: working on it :)
13:44:21 <mgsloan> gonna call it "class-shim"
13:44:30 <elliott> k0ral: no, i mean
13:44:34 <elliott> map rather than fmap in what edwardk said
13:45:04 <k0ral> oh right
13:45:55 <k0ral> but I said I didn't want to repeat map many times, and every one is doing it with fmap :)
13:46:07 <nand`> :t map . map . map
13:46:08 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
13:46:20 <nand`> I don't think it can get much simple than this
13:46:37 <nand`> hmm... instance Foldable f => Foldable [f] where ...
13:46:43 <nand`> err
13:46:45 <nand`> not Foldable
13:46:47 <nand`> Functor
13:47:01 <edwardk> i wonder if you can abuse reflection with constraints to do something interesting
13:47:04 <nand`> but that would conflict with the existing definition
13:47:12 <k0ral> I expected Haskell to provide a more elegant way to do it
13:47:13 <edwardk> nand`: wrong kinds
13:47:34 <nand`> right, would have to be Functor [] and that again makes no sense
13:47:34 <edwardk> nand`: instance (Foldable f, Foldable g) => Foldable (Compose f g) works
13:47:37 <elliott> k0ral: it is elegant: you can simply compose map up to the depth you want
13:47:48 <edwardk> that can be instantiated for Compose [] f to give you what you want
13:47:57 <nand`> edwardk: that sounds reasonable
13:49:10 <k0ral> let me first read about Compose, didn't know this class
13:49:26 <mgsloan> edwardk: I want to use reflection to enable defining instances for constraint synonyms
13:51:34 <edwardk> newtype M s a = M a; data Monoid# a = Monoid# { mappend# :: a -> a -> a,  mempty# :: a, … } instance (s `Reflects` Monoid# a) => Monoid (M s a) where -- but how to nicely generalize it?
13:52:10 <edwardk> data family Dictionary (p :: Constraint) -> *
13:52:24 <mekeor> is there a tail-recursive variant of map somewhere?
13:52:43 <mauke> mekeor: er. why?
13:53:00 <mekeor> mauke: just interest…
13:53:14 <mauke> what
13:53:15 <edwardk> then you want newtype M s p a; instance (s `Reflects` Dictionary Foo a) => Foo (M s Foo a) where ...
13:54:38 <mgsloan> edwardk: Why is a newtype necessary / what is p? I like the idea of using a data family parameterized on constraints!
13:54:55 <edwardk> mgsloan: p was the class itself
13:55:19 <edwardk> that way the M s p a data type was defined once and for all
13:55:27 <mekeor> mauke: isn't 'map f = foldr ((:).f) []' ?
13:55:36 <edwardk> and you can use it as the argument to any single parameter type class. you just need the instances
13:56:36 <mauke> mekeor: yes, and?
13:56:54 <mgsloan> edwardk: It seems like it should be enough to do "data Monoid# = Monoid# {mappend# :: a -> a -> a, mempty# :: a}", instance Monoid Monoid# where {mappend x = mappend# x x; mempty = uh-oh }
13:58:06 <mekeor> mauke: it could be possible to write map using foldl such that it's tail-recursive… that'd have some advantages as well
13:58:08 <elliott> <edwardk> newtype M s a = M a; data Monoid# a = Monoid# { mappend# :: a -> a -> a,  mempty# :: a, … } instance (s `Reflects` Monoid# a) => Monoid (M s a) where -- but how to nicely generalize it?
13:58:12 <elliott> edwardk: Monoid# ~ Dict Monoid?
13:58:17 <mgsloan> yup
13:58:27 <mauke> mekeor: no, it wouldn't
13:58:30 <elliott> right, so why not just use Dict Monoid?
13:58:57 <elliott> mekeor: foldr is tail recursive modulo cons
13:59:01 <elliott> better than tail recursion
13:59:04 * hackagebot git-annex 3.20120405 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120405 (JoeyHess)
13:59:14 <mekeor> what?
13:59:17 <edwardk> elliott: because i'm asking to be able to supply it based on reflection off of user defined values
13:59:23 <elliott> mekeor: "what?"?
13:59:24 <mekeor> elliott: modulo cons?
13:59:25 <elliott> edwardk: ah, right
13:59:28 <elliott> mekeor: yes
13:59:34 <mekeor> what does that mean?
13:59:34 <elliott> there's a constructor guarding the recursion
14:01:31 <mgsloan> edwardk / elliott: The point of this would be to avoid the existential anti-pattern, and give more compositional construction of instances, at run-time
14:03:04 <edwardk> elliott: reify (Monoid# { mappend# = (+); mempty = 0 }) (...)
14:03:04 <edwardk> mgsloan: Monoid# isn't a monoid.  its a description of a dictionary for a monoid
14:03:04 <edwardk> hence why newtype M s a = M a -- note the a not the monoid is a monoid given instance (s `Reflects` Monoid# a) => Monoid (M s a)
14:03:04 <edwardk> the 's `Reflects` Monoid# a' lets you bring the dictionary into scope using reflection on the phantom type parameter s
14:03:04 <edwardk> but we can do better
14:03:21 <elliott> edwardk: right. i wrote a hack like that once.
14:03:39 <edwardk> mgsloan: i understand the use case. my point is you have the wrong thing as the argument to the monoid ;)
14:03:42 <edwardk> er to Monoid
14:03:49 <mgsloan> edwardk: ahhh, yeah, attempting to make the dictionary an instance would be pretty distasteful
14:04:01 <elliott> edwardk: it barely worked though
14:04:05 <edwardk> the dictionary itself isn't the instance, the dictionary is something you need for the instance
14:04:13 <elliott> edwardk: but it was enough that you could say "run this code with a String instance that omits quotes"
14:04:23 <elliott> and it'd work, as long as you put the code in another top-level definition...
14:04:33 <edwardk> elliott: there is a monoid for tabulating a state machine that needs to be parameterized on a particular state machine.
14:04:47 <edwardk> elliott: this can be used to make a particularly efficient parallel parser for regular expressions
14:04:59 <edwardk> elliott: but you need to reflect a runtime value into a type to make it work
14:05:02 <elliott> neat
14:05:24 <edwardk> which is more or less what led me to using something like that Monoid instance above
14:06:53 <elliott> edwardk: btw does reflection suffer from the "adding a type sig can change value" issue that implicit params do?
14:07:11 <edwardk> elliott: no
14:07:17 <elliott> good :P
14:08:24 <mgsloan> edwardk: I'm a bit confused about your Monoid instance.  How does the dictionary supply a value for mempty?
14:08:45 <elliott> mgsloan: it's in the Monoid# itself
14:08:46 <edwardk> mgsloan: you use reflect on a Proxy
14:08:54 <edwardk> that gives you the Monoid#
14:08:56 <elliott> mgsloan: but the M s a is just an a
14:09:00 <edwardk> then you get mempty# out of it
14:09:06 <elliott> it's just a newtype wrapper so that the s, which is what represents the Monoid#, is in the signature
14:09:43 <mgsloan> ahhh, clever!
14:09:44 <edwardk> mgsloan: http://www.mail-archive.com/haskell-cafe@haskell.org/msg57747.html was a version using the older api
14:10:34 <tsou> Trying to build GHC 7.4.1 on OpenBSD/amd64.  The make process breaks at: make[1]: *** No rule to make target `libffi/build/inst/lib/libffi.so', needed by `rts/dist/build/libffi.so'.  Stop.   any ideas?
14:10:40 <mgsloan> it'll be fun to TH-ify this design pattern
14:12:20 <edwardk> mgsloan: did you read the original reflection paper?
14:12:36 <mgsloan> edwardk: I don't think so
14:12:48 <mgsloan> if I did, it was merely a skim
14:13:13 <edwardk> tsou: hrmm, sounds like it can't figure out how to build libffi. ;) not aware of any particular issues for openbsd though
14:13:23 <edwardk> mgsloan: the idea is pretty simple
14:13:31 <elliott> edwardk: hmm, can you use tricks like that to implement unsafeCoerce with Dynamic? ...wait, you don't need any tricks to do that
14:14:40 <edwardk> more or less, the first thing to realize is we can reflect a term level natural number as a type level Nat. something like reifyNat :: Int -> (forall a. Nat a => Proxy a -> r) -> r
14:14:49 <tsou> edwardk: hehehe thanks ;)  I can't get any version of haskell to properly work on openbsd.. grmf.
14:15:05 <edwardk> then once you accept that we can reify naturals, its pretty easy to get you to buy into the fact that we can reify lists of naturals
14:15:28 <edwardk> tsou: can you get libffi to install directly?
14:15:36 <edwardk> tsou: from github.com/atgreen/libffi?
14:15:53 --- mode: ChanServ set +o mauke
14:15:59 <edwardk> once you accept that we can reify a list of naturals, we can reify anything we can serialize to a list of naturals
14:16:03 <edwardk> so anything storable
14:16:09 <edwardk> and stable pointers are storable
14:16:12 <edwardk> so we can reify anything
14:16:37 <tsou> edwardk: i've got libffi installed from OpenBSD's ports, didn't try to install it 'by hand'..
14:17:13 <edwardk> so basically the idea is, take the term you want to reify, grab a stable pointer to it, break it down to a list of ints, serialize that as a type, and reflect it back down.
14:17:37 <edwardk> tsou: ok, just so long as it installs, hrmm. not sure if the ghc distribution uses the one on the platform or one bundled though
14:17:54 --- mode: mauke set -o mauke
14:18:12 <mgsloan> edwardk: that's pretty awful!  But cool :D
14:18:35 <edwardk> mgsloan: and there is a little bit of magic mixed in so that once I deserialize it, it frees the stable ptr because the dictionary had the only reference, and we just forced the thunk that was looking at it
14:18:36 <tsou> edwardk: it looks that it wants to build it itself, either for some actual reason or because it can't find the system one (for some obscure reason) ;)
14:18:58 <edwardk> tsou: sadly, i think you're stuck trying #ghc
14:19:10 <mgsloan> edwardk: that is truly black magic
14:19:39 <mgsloan> gtg! class is over
14:19:40 <edwardk> mgsloan: the net effect is you can get a form of 'dependent' type so long as your dependencies are organized in a strict nested hierarchy
14:20:06 <tsou> edwardk: ah, thanks.  didn't know about this channel.  I'll pretend I didn't see the "sadly" comment and try my luck there ;)
14:20:23 <edwardk> well, they are helpful, but often afk
14:20:40 --- mode: ChanServ set +o mauke
14:21:19 <tsou> edwardk: nice save :P  (thanks again!)
14:22:41 --- mode: mauke set -o mauke
14:59:16 * hackagebot HsOpenSSL 0.10.2 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.2 (MasatakeDaimon)
15:08:11 <johannes_> hello
15:08:40 <byorgey> hi johannes_
15:09:09 <johannes_> i found out that haskell can replace c for many things
15:09:44 <byorgey> yep
15:10:29 <johannes_> i know. c++ was supposed to faze out c, but they left it up to haskell to do it
15:11:06 <byorgey> =)
15:11:32 <johannes_> is haskell good for system programming
15:11:47 <ion> sure
15:11:48 <johannes_> or should i still learn c?
15:12:00 <LambdaMutt> In what way is Haskell a portable assembly?
15:12:39 <byorgey> johannes_: if you want to do systems programming, learning C is probably useful, if only because it forces you to learn a lot of relevant concepts
15:12:54 <byorgey> johannes_: but Haskell can be used for systems programming too
15:13:22 <ion> I find knowing C very useful. It’s so easy to use Haskell’s FFI and use C when you need to call something for which there are no Haskell bindings yet.
15:13:35 <johannes_> okay thanks guys i guess it was inevitable. i knew i would have to learn C
15:13:41 <pqmodn> johannes_: Haskell is sometimes used to *generate* C or VHDL etc using library code that provides certain assurances
15:14:33 <YellowOnion> johannes_: if you're going to try and write an OS then it's not going to help, but Haskell is useful in other aspects of system programming
15:15:37 <YellowOnion> the more Languages you know the better
15:16:56 <johannes_> i bye guys, thanks for your help.
15:18:26 <YellowOnion> well I say 'not help' as in you'll still need to learn C/Assembly for some of the critical interactions with the computer when making an OS johannes_
15:22:09 <wo0kie> hey guys
15:22:14 <YellowOnion> gah, 245s is 4mins I sent the message 3mins ago >.>
15:22:30 <byorgey> hi wo0kie
15:22:40 <wo0kie> I have a homework problem I'm working on that involves lazy evaluation to find inverse fibonacci numbers :O
15:22:53 <byorgey> wo0kie: sounds fun!
15:22:53 <wo0kie> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework03/homework03.pdf
15:23:00 <wo0kie> number 14 on that homework
15:23:06 <wo0kie> I have a solution that makes sense to me logically
15:23:09 <avpx> I find I use Haskell a lot for my Number Theory homework
15:23:14 <wo0kie> but programmatically, it just infinitely loops :o
15:23:15 <avpx> It's quite good for that sort of thing
15:23:17 <wo0kie> hey byorgey ;D
15:24:01 <wo0kie> this is the solution I have thus far
15:24:02 <wo0kie> http://pastebin.com/WXpB2KMY
15:24:05 <mauke> The paste WXpB2KMY has been copied to http://hpaste.org/66482
15:24:15 <wo0kie> right now all I'm trying to do is print a list of matching fibonacci numbers
15:25:08 <wo0kie> but I can't seem to tell why it's infinitely looping :o
15:25:13 <byorgey> wo0kie: the list comprehension doesn't know when to stop.
15:25:17 <elliott> wo0kie: unrelated to whatever problem you're having, but it might make you happy to know that map (uncurry f) (zip xs ys) has a shorthand name, zipWith f xs ys
15:25:24 <byorgey> > [ x | x <- [1..], x == 3 ]
15:25:28 <lambdabot>   mueval-core: Time limit exceeded
15:25:33 <wo0kie> :O
15:25:35 <elliott> > [ x | x <- [1..], x == 3 ]
15:25:39 <lambdabot>   mueval-core: Time limit exceeded
15:25:41 <elliott> hmph
15:25:45 <elliott> shouldn't it produce [3,...
15:26:03 <byorgey> wo0kie: my code above checks whether 1 == 3, then 2 == 3, then 3 == 3 (oh, it found one! so it includes that in the list), then it checks 4 == 3, then 5 == 3, then 6 == 3, then ...
15:26:11 <wo0kie> it's trying to compare x == n on an infinite list :O
15:26:14 <wo0kie> interesting
15:26:14 <avpx> elliott: No
15:26:21 <avpx> It has to check if every element of the list is equal to 3
15:26:24 <avpx> The list is infinite
15:26:30 <wo0kie> that's what I meant lol
15:26:34 <elliott> avpx: yes, but
15:26:35 <elliott> > [1..]
15:26:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:26:44 <elliott> > [x | x <- [1..], x == 3]
15:26:48 <lambdabot>   mueval-core: Time limit exceeded
15:26:53 <elliott> oh, i guess because it takes N
15:26:56 <elliott> and then fully evaluates that
15:27:00 <elliott> shame
15:27:04 <byorgey> wo0kie: you may find the 'takeWhile' function helpful.
15:27:13 <wo0kie> ok I'll take a look :)
15:27:29 <avpx> If the list is in ascending order, that's one way you can convert an infinite-time operation to a linear one
15:27:49 <wo0kie> the fibs list is in ascending order
15:27:55 <byorgey> if the list is in ascending order AND you have a monotonic guard condition =)
15:27:57 <avpx> wo0kie: I know
15:28:05 <wo0kie> oh sorry avpx
15:28:15 <wo0kie> monotonic guard condition? :OO
15:28:24 <avpx> I'm just saying that this is generally a good technique when you have an increasing list.
15:28:29 <copumpkin> it switches from false to true and never back again
15:28:35 <copumpkin> or vice versa
15:28:41 <copumpkin> can never remember
15:28:56 <wo0kie> what does that even look like in haskell byorgey?
15:28:57 <wo0kie> :O
15:29:02 <wo0kie> (just an example)
15:29:27 <Mathnerd314> > head [x | x <- [1..], x == 3]
15:29:27 <lambdabot>   3
15:29:38 <Mathnerd314> > head . tail $ [x | x <- [1..], x == 3]
15:29:39 <byorgey> copumpkin: it depends which way the arrow goes in your poset of booleans =)
15:29:41 <lambdabot>   mueval-core: Time limit exceeded
15:29:45 <copumpkin> byorgey: zomg
15:29:48 <wo0kie> :o
15:29:50 <elliott> avpx: well, since we have (Nat -> Bool) -> Maybe Nat
15:29:54 <byorgey> wo0kie: sorry, ignore me, it's not really important =)
15:30:06 <elliott> you can actually write a filter that produces a [] on an infinite list
15:30:20 <elliott> assuming the list is "monotonic" in a similar way
15:30:25 <elliott> ...but I digress :)
15:30:58 <wo0kie> :o
15:31:23 <avpx> > takeWhile (<60) $ let s (x:xs) = x:[n | n <- xs, (n `mod` x) > 0] in s [2..]
15:31:24 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:31:37 <avpx> Oops
15:31:44 <wo0kie> so I have it set up like this
15:31:45 <wo0kie> invFib n = head [ x | x <- fibs, x == n]
15:31:57 <avpx> > takeWhile (<60) $ takeWhile (<100) $ let s (x:xs) = x:s [n | n <- xs, (n `mod` x) > 0] in s [2..]
15:31:58 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59]
15:32:10 <wo0kie> seems on invFib (fibs !! 99) I get 218922995834555169026
15:32:11 <wo0kie> :O
15:32:15 <wo0kie> which is huge
15:32:31 <byorgey> wo0kie: that's the 99th fibonacci number
15:32:45 <wo0kie> hmm true
15:33:07 <wo0kie> shouldn't the invFib (fibs !! 99) be 99 though?
15:33:19 <wo0kie> unless I need to check that head value outside the list comprehension
15:33:29 <Cale> wo0kie: are you sure that you actually did invFib?
15:33:32 <byorgey> wo0kie: think carefully about what happens if n is the 99th fibonacci number in your definition
15:33:44 <byorgey> invFib 218922995834555169026 = ...
15:33:53 <Cale> oh
15:33:54 <Cale> right
15:34:18 <wo0kie> equals the same number according to what I have hmm
15:34:26 <Cale> yeah, you're looking for a fib which is equal to n, and then giving that fib
15:34:30 <Cale> not its index
15:34:53 <byorgey> wo0kie: you may also find the 'zip' function useful
15:35:20 <wo0kie> hmm, so I'm returning the fib number, not the index, as I should be?
15:35:29 <byorgey> I've got to go, but I shall leave you in the able hands of Cale
15:35:36 <wo0kie> ok thanks byorgey :D
15:35:40 <wo0kie> have a good one
15:35:45 <Cale> Yeah, the appropriate idiom here is to use  zip [0..]  to pair the elements of your list of fibs with their indices
15:35:45 <byorgey> you too =)
15:35:56 <wo0kie> that's what I was thinking too Cale
15:35:57 <Cale> and then use the list comprehension to find the index
15:36:02 <wo0kie> then I can just return the index
15:36:15 <Cale> Or you could just use findIndex
15:36:28 <Cale> er, or elemIndex, even
15:36:31 <Cale> :t elemIndex
15:36:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
15:36:46 <Cale> :t findIndex
15:36:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
15:37:16 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in elemIndex 218922995834555169026 fibs
15:37:17 <lambdabot>   Just 99
15:37:39 <wo0kie> omg!
15:37:44 <wo0kie> invFib n = head [ i | (i, x) <- zip [0.. ] fibs, x == n]
15:38:26 <wo0kie> it works :DDDDD
15:38:31 <wo0kie> brilliant
15:38:38 <wo0kie> I didn't realize it was looking for an index
15:38:46 <wo0kie> as opposed to the actual fibonacci number
15:38:52 <wo0kie> but then that makes sense
15:38:58 <wo0kie> otherwise I'd just be imitating fibs
15:40:11 <mauke> @hoogle findIndex
15:40:12 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
15:40:12 <lambdabot> Data.ByteString.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
15:40:12 <lambdabot> Data.ByteString.Lazy.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
15:40:19 <copumpkin> wo0kie: you realize that that'll never terminate if you ask for a non-fib
15:40:27 <wo0kie> yup just figured that out lol
15:40:41 <mauke> :t dropWhile
15:40:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:51:45 <wo0kie> still can't get it to terminate correctly
15:51:48 <wo0kie> :o
15:52:25 <wo0kie> val = head [ i | (i, x) <- dropWhile (\ (index,value) -> value > n) (zip [0.. ] fibs), x == n]
15:53:28 <elliott> surely you mean takeWhile (value < n)
15:53:44 <wo0kie> hmm
15:53:47 <wo0kie> that could be it
15:53:54 <byorgey> > dropWhile (\x -> x > 100) [1..200]
15:53:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:54:11 <byorgey> the first value isn't greater than 100, so it stops dropping.
15:54:15 <byorgey> and keeps everything.
15:54:27 <elliott> wo0kie: should probably be <=
15:54:28 <elliott> since fib 0 = 0
15:54:33 <byorgey> oh wait, I'm not supposed to be on here, I'm supposed to be working!
15:54:36 <wo0kie> dropWhile (\x -> x > 10) [0..100]
15:54:46 * byorgey reprimands self
15:55:40 <wo0kie> ah true elliott
15:58:25 <wo0kie> is there a way that I can possibly catch the error returned by head if the list is empty to return Nothing?
15:58:58 <ion> Don’t use head for that very reason.
15:59:04 <wo0kie> :o
15:59:14 <monochrom> case your_list of [] -> Nothing ; x:_ -> Just x
15:59:17 <elliott> wo0kie: listToMaybe
15:59:20 <elliott> :t listToMaybe
15:59:21 <lambdabot> forall a. [a] -> Maybe a
15:59:27 <elliott> that's what monochrom just wrote :P
15:59:36 <wo0kie> oic haha
16:00:22 <monochrom> it is best to have never loved, than to have loved and resulted in an error to catch
16:00:45 <wo0kie> cases was the key!
16:00:52 <wo0kie> never thought to do that, but it makes a LOT more sense lol
16:01:45 <wo0kie> thank you for the help byorgey, elliott, Cale and monochrom :)
16:01:47 <wo0kie> much appreciated
16:01:59 <elliott> yw
16:03:28 <wo0kie> :)
16:05:11 <mk> how can the monadic laws be restated in terms of fmap and join?
16:06:41 <parcs`> well (=<<) = fmap join . fmap
16:06:52 <elliott> join . return = id
16:06:55 <elliott> join . fmap return = id
16:06:59 <elliott> join . join = join . fmap join
16:10:29 <mk> what is the . operator?
16:10:38 <ivanm> @src (.)
16:10:38 <lambdabot> (f . g) x = f (g x)
16:10:38 <lambdabot> NB: In lambdabot,  (.) = fmap
16:10:42 <ivanm> mk: ^^
16:10:46 <ivanm> it's function composition
16:10:48 <mk> thanks
16:11:11 <ivanm> I don't understand a word of the "I Need a Better Functional Language" email on -cafe
16:13:02 * elliott doesn't see such a message
16:13:06 <elliott> though I am using google groups
16:16:55 <Philippa> I don't see such a message either, but I unsubscribed ages back because I needed the time. Is -cafe worth following lately?
16:17:19 <ben> I see it in google mail, hope this helps
16:17:33 <ben> I'm guessing dude basically wants destructuring operations on function values
16:18:12 <elliott> -cafe is worth following if you are really, *really* bored.
16:19:06 <jmcarthur> it would be awesome if i could define local values in an instance
16:19:40 <jmcarthur> ones that are "hidden" by the type class "signature", that is
16:20:10 <jmcarthur> it would basically make type classes a kind of module
16:20:55 <Philippa> elliott: heh. I have enough stuff that's worth it if I'm only really bored...
16:22:13 <elliott> you can't beat the refined ennui that comes from reading a 100-post thread about whether haskell is pure or not
16:26:09 <tech2> elliott: that's gotta leave you almost zen surely, mind a clear and pointless as any great trance-like state could ever achieve?
16:49:26 * hackagebot blaze-html-contrib 0.2.2 - Some contributions to add handy things to blaze html.  http://hackage.haskell.org/package/blaze-html-contrib-0.2.2 (AdityaBhargava)
17:18:52 <dcoutts> @seen phyx
17:18:52 <lambdabot> Unknown command, try @list
17:19:02 <yahrlly> hue hue
17:19:13 <bill```> br?
17:19:14 <yahrlly> @list
17:19:14 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:19:40 <elliott> preflex: xseen phyx
17:19:40 <preflex>  Sorry, I haven't seen phyx
17:20:05 * elliott wonders how long preflex's db goes back
17:21:06 <strager> @yhjulwwiefzojcbxybbruweejw
17:21:06 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
17:21:11 <strager> O_o
17:21:27 <yahrlly> impressive
17:22:46 <tnzr> is it possible to convert 2 base cases like:  'myFunc [] x = x'  and 'myFunc x [] = x'   into a single base case?
17:22:56 <dmwit> ?hackage unamb
17:22:57 <lambdabot> http://hackage.haskell.org/package/unamb
17:23:13 <c_wraith> preflex: seen mmorrow
17:23:13 <preflex>  mmorrow was last seen on #ghc 2 years, 78 days, 21 hours, 25 minutes and 31 seconds ago, saying: * mmorrow is rtfm'ing
17:23:21 <c_wraith> at least that far
17:23:30 <elliott> that's one long manual
17:23:37 <elliott> (I feel like I've said this before in response to the same line)
17:23:46 <c_wraith> yes.  It was an old joke a year ago :)
17:24:38 * elliott is terribly hurt.
17:25:44 <ivanm> elliott: we *all* keep making that same joke!
17:27:02 <elliott> ivanm: Well, you know what they say about great minds.
17:27:08 <elliott> They come up with jokes that other people don't.
17:27:13 <ivanm> heh
17:29:33 <yahrlly> guys.. I did some poor little parser with data constructor MParse (String -> (a,String)) and made it be a monad. but now I'd like to encapsulate it with an error monad, so I'm stuck with the bind operation. how would that look like? Hope it's ok to spam here...
17:29:51 <ivanm> yahrlly: use ErrorT ?
17:30:00 <ivanm> yahrlly: any particular reason for writing a new parser?
17:30:07 <yahrlly> to understand monads XD
17:30:15 <yahrlly> i know about parsec
17:30:15 <elliott> yahrlly: if by spam you mean paste code, then *no* don't, use hpaste
17:30:30 <ivanm> yahrlly: well, parsec isn't the only parser available :p
17:30:41 <ivanm> polyparse, attoparsec, uu-parsinglib, trifecta...
17:30:43 <elliott> yahrlly: but: given a certain string, either it parses, producing the result and the rest of the String, or it fails
17:30:50 <elliott> yahrlly: so, your type should look like (String -> Maybe (a, String))
17:30:57 <dmwit> ?unmtl ErrorT e (State String) a
17:30:57 <lambdabot> String -> (Either e a, String)
17:31:05 <ivanm> elliott: or Either if you want an error message
17:31:14 <elliott> yes, but that makes things more complicated :)
17:31:15 <ivanm> though most parsing libraries define a new "Result" type instead of using Either
17:31:17 <yahrlly> i thought aobut that elliott but then the bind looked really ugly
17:31:23 <ivanm> (though they typically have a third constructor as well)
17:31:28 <elliott> yahrlly: doesn't matter, get it working first and you'll be able to make it elegant
17:31:45 <ivanm> yahrlly: not really: if there's already an error, then just return the error again and don't bind
17:31:47 <elliott> (m >>= f) is a parser that first parses with m; if it fails, then the whole parser fails, otherwise it passes the result to f and continues parsing with that
17:31:51 <yahrlly> i tried, but i got parse errors due to indentation XD
17:31:51 <ivanm> otherwise, do as you'd already done
17:31:59 <elliott> you'll want to use a case statement
17:32:00 <ivanm> then fix your indentation! ;)
17:32:04 <elliott> yahrlly: well, http://hpaste.org/ what you have
17:32:08 <elliott> if you're using tabs, don't
17:32:36 <yahrlly> i don't have much yet. just thought the way to go was to have an inner and out monad?
17:32:43 <yahrlly> since the inner one is relatively simple
17:32:51 <yahrlly> without error, that is
17:32:53 <dmwit> tnzr: (Did you understand why unamb is good, or have you disappeared?)
17:33:15 <elliott> yahrlly: you _could_ structure it with a monad transformer
17:33:20 <elliott> yahrlly: but I'd do it all in one, to start with
17:33:31 <elliott> because that adds additional complexity
17:34:53 <yahrlly> yeah but the problem is that I have to do a lot of pattern matchings due to the inherent structure
17:34:59 <yahrlly> how can i do those in-line?
17:35:07 <yahrlly> as in
17:35:13 <yahrlly> nvm
17:35:52 <elliott> don't bother doing them inline
17:35:56 <elliott> just write it big, you can compact it later
17:36:32 <yahrlly> by big you mean ?
17:36:43 <yahrlly> like when i tried i had a let - statement for the first matchign
17:36:47 <yahrlly> but needed a second one
17:36:50 <yahrlly> oh
17:37:15 <yahrlly> and then i had a let statement and a where statement and they wouldnt like each other
17:37:29 <yahrlly> and things got ugly and i looked for a better solution
17:37:29 <elliott> yahrlly: why not just use "case"?
17:37:34 <yahrlly> ok
17:37:35 <elliott> you need to branch on whether you get Nothing or Just anyway
17:37:42 <elliott> so you should be able to forget about let and where
17:37:42 <yahrlly> i had a let and then a case and then a where :P
17:38:08 <yahrlly> i'd have to nest cases
17:38:12 <yahrlly> or try, at least
17:38:13 <yahrlly> well
17:38:15 <yahrlly> yeah
17:38:33 <elliott> yahrlly: nope
17:38:37 <elliott> in fact you only need one case
17:38:54 <yahrlly> what?
17:39:06 <elliott> yep
17:40:09 <yahrlly> hmm
17:41:27 <hpaste> yahrlly pasted “my ugly parser for elliot to laugh at” at http://hpaste.org/66486
17:41:41 <bill```> haha
17:41:49 <ivanm> if you're dealing with Maybe, you don't need case statements at all! Just use maybe, fromMaybe, etc.! :p
17:41:58 <yahrlly> so
17:42:12 <yahrlly> that true
17:42:29 <ivanm> yahrlly: one fix: rather than using params around (\str -> ... ), you can just do MParser $ \ str -> ...
17:42:39 <elliott> yahrlly: as i said
17:42:47 <elliott> forget about let, and where, and forget about your existing code
17:42:54 <ivanm> also, if you use record syntax to define a runMParser function, then you can avoid the pattern match on line 9
17:43:02 <elliott> as long as you know how it works, just remove it and start typing afresh
17:43:08 <elliott> you can do it in one case, I guarantee it :)
17:43:09 <ivanm> (also on line 7)
17:43:30 <elliott> oh
17:43:40 <elliott> ivanm makes a good point -- actually more than one case because of that
17:43:46 <elliott> if you use the record syntax like he says, it's one case
17:43:50 <yahrlly> I appreciate the input
17:43:59 <elliott> newtype MParser a = MParser { runMParser :: a -> Maybe (a, String) }
17:44:08 <elliott> then use runMParser rather than pattern-matching on MParser
17:44:12 <yahrlly> barely did much with records other than emulating OOP
17:44:13 <elliott> runMParser :: MParser a -> a -> Maybe (a, String)
17:44:27 <elliott> in this case it's just a convenient way to define runMParser (MParser f) = f
17:44:41 <yahrlly> makes sense, seen that somewhere
17:45:24 <yahrlly> I dunno if I do
17:45:32 <yahrlly> i have a good feeling about anything but monads
17:45:48 <elliott> you dunno if you do what? :)
17:46:01 <elliott> don't worry too much about monads -- they are just another abstraction
17:46:12 <elliott> do you understand Applicatives? if so, know that monads are not really any harder than that to understand
17:47:22 <clsmith> i think the only thing which confuses people about monads is io
17:47:28 <yahrlly> ?
17:47:34 <clsmith> as soon as you pretend io doesn't exist it makes sense, and then you just slot that in afterwards
17:48:38 <ivanm> yahrlly: how much Haskell have you done?
17:48:58 * ivanm found RWH's build up to monads the best
17:49:11 <yahrlly> I got an intro to functional programming 2 years ago
17:49:38 <yahrlly> recently I switched my OS to arch linux and stumbled upon xmonad
17:49:39 <ivanm> generally speaking, don't try to "understand" monads
17:49:48 <ivanm> recognise that they're a bunch of types with a similar API
17:49:49 <elliott> does RWH cover applicatives beforem onads?
17:49:52 <elliott> *before monads?
17:49:53 <ivanm> and understand the actual monads you want to use
17:49:56 <ivanm> elliott: no
17:50:00 <elliott> shame
17:50:05 <elliott> I like LYAH's progression since it does
17:50:06 <yahrlly> so now i'm kinda digging for it again
17:50:22 <ivanm> elliott: RWH does monads in the sense of "hey, we've done all this stuff with Maybe, and all this stuff with our custom Parser; waddaya know, they look the same!"
17:50:27 <elliott> fair enough
17:50:43 <ivanm> IIRC, RWH came out before Applicative really became popular (and pre-dated the typeclassopedia)
17:51:22 <sbahra> Who wants an applicative.org e-mail address?
17:52:05 <hpc> sbahra: oooh, ill take one
17:52:14 <elliott> Aw, {functor,monad}.org are taken.
17:52:29 <elliott> Even category.org!!!
17:52:35 <nart> sbahra: i'll take one too
17:53:21 <yahrlly> but yeah thanks for all the input i'll look into it I'm just a bit tired and stuff ;)
17:54:52 <vamega> Hi, I was wondering if someone here could help me with installing Yi.
17:55:18 <vamega> I keep getting this error
17:55:18 <vamega> Loading package terminfo-0.3.2.3 ... <command line>: can't load .so/.DLL for: ncursesw (/usr/lib64/libncursesw.so: file too short)
17:55:41 <ivanm> vamega: which OS?
17:56:16 <luite> hmm that error looks familiar
17:56:19 <ivanm> in linux terms, you need to install something like ncurses-dev for distros like ubuntu, etc.
17:56:26 <elliott> nah, the file exists
17:56:31 <ivanm> I think the "w" on the end means you need the utf8 version
17:56:31 <elliott> I think "too short" usually means it's the wrong architecture
17:56:39 <ivanm> elliott: ahhh
17:56:40 <elliott> it wouldn't be a too short error if the file did not exist afaik
17:56:42 <ivanm> missed that bit
17:56:46 <elliott> vamega: are you on 64-bit perhaps?
17:56:59 <ivanm> and does that file actually exist?
17:57:05 <elliott> oh, /usr/lib64... so i guess yes
17:57:22 <ivanm> elliott: yeah, if I noticed that from the beginning I wouldn't have asked what OS
17:57:25 <sbahra> nart, hpc: E-mail me (sbahra@repnop.org) the address you want me to forward to.
17:57:29 <ivanm> since that precludes it from being Windows or OSX :p
17:58:06 <sbahra> nart, hpc: Please put applicative.org in the subject
17:59:48 <nart> sbahra: you've got an mail :)
17:59:50 <elliott> vamega: fwiw, unless you're just building yi out of curiosity, there's no real reason to use it over emacs or vim or whatever you currently use unless you're really interested in it
17:59:54 <elliott> and it's famously difficult to build ;)
18:01:12 <ivanm> elliott: especially on newer GHC!
18:01:51 <hpc> sbahra: is it going to be forwarding emails, or a proper mailbox?
18:02:12 <ivanm> control@applicative ? :p
18:02:12 <hpc> (also email sent)
18:02:27 <hpc> ivanm: should be the admin account :D
18:02:37 <vamega> Yeah I'm on Fedora64 bit
18:02:43 <sbahra> hpc, forwarded
18:02:54 <vamega> I'm really building yi out of curiosity
18:03:15 <hpc> sbahra: groovy, so no configuring necessary on my part
18:03:16 <sbahra> hpc, if you're using gmail though, you'll be able to send applicative.org e-mails too
18:03:38 <nart> sbahra: tell me when it's ready, and thanks in advance
18:03:47 <vamega> Just trying to see what it looks like and get more immeresed in haskell
18:03:49 <nart> sbahra: ah awesome.
18:03:56 <hpc> sbahra: :D :D :D
18:04:31 <vamega> the /usr/lib64/libncursesw.so file exists
18:04:41 <vamega> when I cat that file I get "INPUT(libncursesw.so.5 -ltinfo)"
18:04:48 <vamega> I've installed ncurses-devel
18:05:50 <elliott> vamega: oh!
18:05:57 <elliott> vamega: yes, that's a known problem with ghc's linker or something
18:06:08 <vamega> I see any idea how I can get around it
18:06:10 <elliott> IIRC, if you replace it with a symlink to libncursesw.so.5, it works, but... it's gross and ugly to do that :)
18:06:14 <ivanm> *groan* not linker scripts...
18:06:21 <ivanm> vamega: which version of GHC?
18:06:32 <ivanm> I thought GHC knew about linker scripts now :s
18:06:33 <vamega> libcursesw.so.5 exists in /lib64
18:06:48 <vamega> 7.0.4
18:06:49 * elliott bets: 6.12
18:06:51 <elliott> aww
18:07:00 <ivanm> huh, I thought 7.4 had the linker script stuff
18:07:07 <elliott> 7.4 isn't 7.0.4...
18:07:21 <ivanm> http://hackage.haskell.org/trac/ghc/ticket/2615
18:07:40 <ivanm> looks like it was included in 7.2.1
18:07:54 <vamega> I'm running the haskell-platform 2011.2.0.
18:08:03 <elliott> there's a newer platform than that, even
18:08:06 <elliott> though it's still on ghc 7.0.4
18:08:24 <vamega> yeah I just grabbed the platform that has a package in fedora
18:09:36 <elliott> serves fedora right for distributing packages without testing them ;)
18:10:20 <vamega> lol
18:10:49 <vamega> So the last comments in that bug say that I should patch linker.c
18:11:24 <elliott> vamega: you'd have to recompile GHC.
18:11:33 <elliott> if you're going to do that, you might as well upgrade GHC which will have the patch integrated
18:11:44 <elliott> but 7.2 and 7.4 aren't the most stable releases so eeeeh
18:11:49 <elliott> maybe try the symlinkt hing
18:11:53 <elliott> *symlink thing
18:12:40 <vamega> will the symlink break other curses based applications?
18:13:55 <hpc> sbahra: when you say i can send from that email too, how do you mean? (ie, what terms should i search for to get gmail's smtp to say emails come from applicative.org)
18:13:56 <geekosaur> vamega, it shouldn't
18:20:20 <dpratt71>  is there a succinct way of describing the relationship between lift and liftIO?
18:21:01 <ezyang> Sure, liftIO is lift specialized for lifting to the IO monad
18:21:48 <vamega> Great geekosaur, I'll try this then.
18:21:50 <elliott> dpratt71: liftIO is just a bunch of lifts composed together
18:21:53 <elliott> as a convenience
18:21:58 <elliott> each instance adds on another lift to the stack
18:22:07 <elliott> so liftIO just zips down to IO at the "bottom" of the stack
18:22:13 <dpratt71> elliott: makes sense
18:33:13 <bottle> Consider a mass-damper-spring system. I dont get how  the forces in each direction can be equal at any given moment. then how could it move? Like My''+by'+ky=F
18:36:04 <dmwit> I don't think the forces are equal in a mass-damper-spring system. But perhaps you meant a different channel? Perhaps #physics (dunno if that exists)?
18:37:52 <elliott> (Try adding "fromIntegral"!)
18:47:32 <hpaste> “Joey Adams” pasted “Why doesn't Julius escape this?” at http://hpaste.org/66488
18:48:05 <JoeyA> This is a basic "Hello world" for Julius (the Shakespearean template generator for JavaScript).  It isn't escaping the string at all!  Why?
18:48:55 <JoeyA> (sorry for the harsh tone, but I think it's suitable for this case)
18:49:27 <ProgramminGeek> Examples for Haskell?
18:50:17 <shergill> all strings are created escaped, but everywhere they are unescaped.
18:50:21 <elliott> ProgramminGeek: that's not a very specific question
18:50:34 <elliott> JoeyA: /me wonders where the harsh tone is
18:50:36 <shergill> ProgramminGeek: hello world?
18:51:08 <Rotaerk> elliott, he used an exclamation mark, duh
18:51:33 <ProgramminGeek> Sure, I'm trying to see whether Haskell is better than Python or not. So, naturally I thought it best to figure out the syntax.
18:52:05 <Rotaerk> ProgramminGeek, just looking at examples will not really tell you much
18:52:09 <JoeyA> ProgramminGeek: What kind of program do you plan on writing?
18:52:19 <elliott> ProgramminGeek: if you want to learn haskell, read a book, like Learn You a Haskell (available online)
18:52:20 <elliott> @where lyah
18:52:20 <lambdabot> http://www.learnyouahaskell.com/
18:52:26 <elliott> it'll be much more productive than having people teach you the syntax over IRC
18:52:36 <Rotaerk> ProgramminGeek, in fact you might find it unreadable because it's probably rather different from what you're used to... and then conclude that it's a bad language
18:52:41 <dmwit> ?where gentle
18:52:41 <lambdabot> http://www.haskell.org/tutorial/
18:52:55 * elliott tries to ascertain dmwit's seriousness
18:53:02 <Rotaerk> ProgramminGeek, so it's difficult to judge without understanding the concepts too
18:53:05 * dmwit is very serious
18:53:12 <elliott> dmwit: well, it worked
18:53:40 <shachaf> I think the Gentle Introduction might be a better introduction than LYAH.
18:53:43 <shachaf> Just unfashionable.
18:53:53 <shachaf> Depends on the audience.
18:54:07 <parcs`> why is it always the choice between python or haskell
18:54:09 <shergill> ProgramminGeek: though you might be tempted, i would recommend against something like http://blog.ezyang.com/2011/11/how-to-read-haskell/
18:54:28 <dmwit> The Gentle Intro gets right to the good stuff.
18:54:29 <elliott> shachaf: For a Python programmer?
18:54:32 <elliott> shergill: Erm, they left.
18:54:36 <dmwit> No funny business.
18:54:49 <shachaf> I would recommend against pressing this button. Here, this big red button right there.
18:55:08 <shergill> elliott: whoa lag. this tor business annoys me at times
18:55:11 * elliott somewhat doubts ProgramminGeek would have learned or liked Haskell whatever anyone said at all.
18:55:23 <elliott> Also, shachaf++
18:56:51 <shergill> shachaf: heh. if the button is in clear view, i feel it's still better to give correct advice. if only to weed out the idiots from the not-so idiotic
18:58:12 <elliott> shergill: It wasn't in clear view, you brought it out of your pocket...
18:58:33 <shergill> elliott: out of google's transparent pocket, sure
18:59:37 <elliott> You're talking about someone who joined the channel to say "Examples for Haskell?". You think they'd use Google? :)
18:59:48 <elliott> Anyway, they've been gone for like 30 messages, so this is silly.
19:01:11 <shergill> *shrug* agreed
19:01:32 <shachaf> *shrugreed*
19:02:22 <scientes> http://www.haskell.org/haskellwiki/Roman_numerals#Oneliner
19:02:30 <scientes> doesn't that not do subtraction roman numerals?
19:02:35 <scientes> i.e. IV for 4?
19:03:04 <elliott> > (fst . foldr (\p (t,s) -> if p >= s then (t+p,p) else (t-p,p)) (0,0) . map (fromJust . flip lookup (zip "IVXLCDM" [1,5,10,50,100,500,1000]))) "IV"
19:03:05 <lambdabot>   4
19:03:21 <scientes> where does it handle that?
19:03:30 <elliott> In the foldr.
19:03:39 <elliott> Specifically look at the conditional.
19:03:56 <scientes> oh i got it
19:04:10 <scientes> why don't we define all those variables however
19:04:18 <scientes> to make it clearer
19:04:34 <shergill> scientes: because oneliner
19:04:36 <elliott> Define howso?
19:04:40 <elliott> But yes, the point is that it's a oneliner.
19:04:49 <scientes> or at least explain what each variable is
19:05:00 <elliott> See http://www.cs.york.ac.uk/ftpdir/pub/haskell/contrib/Roman.hs for a non-oneliner.
19:05:04 <scientes> cause it is clear if you just can grep to context
19:05:08 <scientes> no i like the one-liner
19:05:15 <scientes> the letters are just confusing
19:05:37 <scientes> p,t,s
19:05:52 <scientes> those should be explained
19:06:30 <shachaf> scientes: If you don't like the one-liner, why don't you click on the link to the multiple-liner right next to it?
19:06:42 <shachaf> It uses better letters like "n" and "k".
19:06:49 <scientes> ^^^^
19:07:09 <elliott> scientes: Well, now that you understand it, why not add explanations of the variables to the wiki page?
19:07:12 <elliott> It's a wiki, after all.
19:07:32 <shachaf> It's called a "wiki" because "wi" all edit it.
19:07:39 <scientes> he, i like that one
19:09:30 * hackagebot zip-archive 0.1.1.8 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.1.8 (JohnMacFarlane)
19:11:23 <lispy> shachaf: But "wi" shouldn't sound like "we" unless it sounds like, "wee-kee" when you say "wiki" (which it doesn't for me)
19:11:49 <shachaf> lispy: Apparently wi don't pronounce "we" the same way.
19:12:11 <lispy> shachaf: but english has such well defined rules about pronounciation ;)
19:12:33 <elliott> lispy: "wiki" is Hawaiian.
19:12:39 <elliott> Er.
19:12:41 <elliott> Is it?
19:12:45 <elliott> Yes, it is.
19:12:47 <elliott> Well, "wiki-wiki" is.
19:12:48 <shachaf> "wikiwiki" is.
19:12:53 <lispy> Right
19:12:55 <elliott> How's it pronounced?
19:12:59 * shachaf has the vague feeling that that's a prank or something.
19:13:03 <elliott> I say wee-kee for "wiki".
19:13:09 <elliott> shachaf: What is?
19:13:25 <vodik> i think a lot of people say something closer to "weh-key"
19:13:30 <shachaf> "\"wiki-wiki\" is Hawaiian"
19:13:31 <elliott> "In the Hawaiian language the word "wiki" means quick, and "wiki wiki" implies very quick. The shuttle's name inspired Ward Cunningham to call his new website "WikiWikiWeb".[1] Cunningham's site was designed to allow visitors to the site to edit its content, and this type of website came to be known as a "wiki," a prominent example of which is Wikipedia."
19:13:33 <elliott> -- http://en.wikipedia.org/wiki/Wiki_Wiki_Shuttle
19:13:42 <elliott> Okay, uncited, but you can trust the Internet.
19:14:15 <lispy> So then does it recommend a way to say it?
19:15:03 <lispy> http://en.wikipedia.org/wiki/Wiki
19:15:04 <elliott> http://en.wiktionary.org/wiki/wiki#English http://en.wiktionary.org/wiki/wiki#Hawaiian
19:15:09 <elliott> Former has pronunciation, latter does not.
19:15:13 <lispy> i/ˈwɪki/ wik-ee
19:15:43 <elliott> "Homophone: wicky" -- so I'm right. Well, maybe.
19:15:56 <elliott> It's more "wi-kee" than "wee-kee" for me. Sort of. Oh, to hell with it.
19:15:58 * lispy feels needlessly pedantic and offtopic
19:16:05 <elliott> Yes, me too.
19:18:34 <lispy> I was reading the Applicative paper this morning and I found a gem
19:18:48 <lispy> repeat and zapp are all you need to implement the family of zip functions
19:19:36 <lispy> repeat :: a -> [a] and zapp :: [a -> b] -> [a] -> [b]
19:19:47 <lispy> I tihnk that means we should add zapp to Data.List
19:21:23 <lispy> zapp (f : fs) (x : xs) = f x : zapp fs xs; zapp _ _ = []
19:21:26 <copumpkin> preflex: seen xerox
19:21:26 <preflex>  xerox was last seen on #perl 200 days, 12 hours, 45 minutes and 46 seconds ago, saying: woldrich: do you know how to nuke everything and start over with the perl modules via aur
19:21:43 <lispy> :t zipWith ($)
19:21:44 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
19:21:53 <lispy> (that being an alternate definition)
19:23:46 <elliott> <lispy> repeat and zapp are all you need to implement the family of zip functions
19:23:50 <elliott> lispy: we already have it
19:23:53 <elliott> it's the ZipList newtype
19:23:58 <elliott> > pure 42 :: ZipList Int
19:23:59 <lambdabot>   No instance for (GHC.Show.Show
19:23:59 <lambdabot>                     (Control.Applicative.Zip...
19:24:01 <elliott> argh
19:24:03 <elliott> > getZipList $ pure 42 :: ZipList Int
19:24:04 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
19:24:05 <lambdabot>                  ...
19:24:07 <elliott> ...
19:24:10 <elliott> > getZipList (pure 42 :: ZipList Int)
19:24:11 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
19:24:15 * lispy is not a fan of ZipList
19:24:17 <elliott> > getZipList (pure succ <*> pure 42 :: ZipList Int)
19:24:18 <lambdabot>   [43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43...
19:24:23 <elliott> lispy: well it's repeat and zapp
19:24:26 <elliott> obviously it's ugly :)
19:24:31 <elliott> the original intention was ofc to make that the [] instance
19:24:42 <elliott> but the fact that ZipList isn't a Monad and we have an established [] monad presumably got in the way
19:24:43 <lispy> "ofc"?
19:24:46 <elliott> of course
19:24:49 <lispy> ah
19:24:56 <elliott> since that's what the paper defines it as
19:25:10 <blackdog> would it be a totally stupid thing to have a more or less common "semi-structured datatype"?
19:25:11 <lispy> Yeah, <*> needs a functor
19:25:15 <blackdog> json and messagepack for instance are parsing to basically the same thing
19:25:35 <lispy> And, when you need a functor in Haskell you usually use the same one that comes with the Monad instance
19:25:36 <blackdog> but converting between the two is a hassle..
19:25:53 <elliott> blackdog: data-object package (deprecated)
19:26:07 <elliott> lispy: uh the ZipList and [] functors are the same
19:26:25 <lispy> :t <*>
19:26:26 <lambdabot> parse error on input `<*>'
19:26:28 <elliott> it's just that having pure =/= return, (<*>) =/= ap is generally considered a Very Bad Thing
19:26:29 <lispy> :t (<*>)
19:26:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:26:42 <elliott> explaining why []'s Applicative instance is the less useful one
19:26:42 <lispy> elliott: ah
19:27:00 <elliott> and since ZipList isn't even a monad, there's not much that can be done about it :)
19:27:09 <lispy> Okay, that does make more sense that why I thought they picked the monad functor instead of the natural list functor
19:27:11 <blackdog> elliott: it says to use aeson instead, which is one of the things i'm transalting between :/
19:27:19 <elliott> blackdog: yep
19:27:22 <blackdog> maybe i should just lobby the messagepack guy to change his fundamental data structure :)
19:27:24 <elliott> just sayin' it exists but people don't use it
19:27:33 <elliott> lispy: it would be nice to have a "zap" though
19:27:39 <elliott> with that type
19:27:51 <lispy> :t ap
19:27:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:27:52 <elliott> repeat (+) `zap` xs `zap` ys
19:28:00 <elliott> (zap for Zippy AP)
19:28:05 <lispy> Yeah
19:28:05 <glguy> What's the difference in a monad functor and a natural list functor?
19:28:09 <elliott> nothing :)
19:28:12 --- mode: glguy set -o glguy
19:29:32 <lispy> Well, the list monad gives you a bunch of possibilities right? But I think of fmap as just going over the list.
19:30:05 <lispy> ZipList <*> vs. [] <*> is all I meant
19:30:06 <glguy> you don't get a lot of choices when you make a functor instance
19:30:50 <glguy> I must have come into this too late to know what you are talking about :)
19:30:58 <elliott> lispy: functor instances are uniquely determined as glguy implies
19:31:03 <elliott> it's map for both ZipList and []
19:31:52 <lispy> > [(+1), (*2), subtract 3] <*> [1..3] -- compare that to the ZipList version
19:31:53 <lambdabot>   [2,3,4,2,4,6,-2,-1,0]
19:32:28 <lispy> The ZipList version would be [2,4,0]
19:32:28 <glguy> <*> isn't the functor operation
19:32:47 <lispy> It uses the functor though doesn't it?
19:32:59 <elliott> well... no?
19:33:04 <elliott> Applicative has a Functor superclass, sure
19:34:19 <glguy> The Functor class provides <$> and fmap (synonyms)
19:34:26 <lispy> So, then do you not refer to applicatives as functors?
19:34:46 <glguy> It's like squares are rectangles but rectangles aren't all squares
19:35:51 <glguy> (so to answer your question, no)
19:36:15 <lispy> I thought the difference between ZipList and [] was the functor instance, but I guess both have Applicative instances too
19:36:27 <elliott> > fmap succ $ ZipList [1,2,3,4]
19:36:28 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
19:36:29 <lambdabot>    arising ...
19:36:32 <elliott> uuuugh
19:36:34 <elliott> > getZipList . fmap succ $ ZipList [1,2,3,4]
19:36:36 <lambdabot>   [2,3,4,5]
19:36:39 <elliott> > fmap succ $ [1,2,3,4]
19:36:40 <lambdabot>   [2,3,4,5]
19:36:43 <glguy> The functor instances are unique enough that we have a language extension to derive them for you
19:37:53 <lispy> Well, I mispoke. I haven't actually been able to finish the paper yet.
19:38:56 <kallisti> so some of the attoparsec combinators return lists when I'd rather they return ByteStrings
19:39:10 <kallisti> should use lower-level parsers, or just pack the resulting string into a ByteString?
19:39:13 <elliott> glguy: does that extension always work?
19:40:22 <glguy> afaik
19:40:38 <glguy> Your type has to have the right kind, of course
19:40:39 <ivanm> kallisti: which combinators?
19:40:54 <kallisti> in particular manyTill
19:41:12 <kallisti> basically I want to match the remainder of a line. I suppose I could write that as takeWhile (not.isEndOfLine) instead.
19:41:15 <luite> is it possible to killall forkIO'd and forkOS'd threads in a haskell program, except the current one?
19:41:16 <ivanm> I suspect that there is no efficient way of doing it directly on bytestrings
19:41:50 <ivanm> but yes, using takeWhile would probably be better
19:42:08 <copumpkin> lispy: ZipList gives you a really elegant transpose :)
19:42:51 <kallisti> luite: not that I know of. you'll want to keep track of them yourself.
19:43:02 <ByronJohnson> luite: Haskell provides no means of directly and automatically doing so AFAIK.  You'll probably just have to keep track of each thread that you create
19:43:12 <lispy> ?src transpose
19:43:13 <lambdabot> transpose []             = []
19:43:13 <lambdabot> transpose ([]   : xss)   = transpose xss
19:43:13 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:43:19 <lispy> copumpkin: that one?
19:43:35 <copumpkin> > getZipList . Data.Traversable.traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
19:43:37 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
19:43:41 <copumpkin> that one
19:43:48 <ByronJohnson> luite: You may consider even writing your own thread management module, that provides an action similar to forkIO but automatically updates its own internal STM state to keep track of the threads
19:43:51 <shachaf> > transpose [[1,2,3],[4,5,6],[7,8,9]] -- way shorter
19:43:52 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
19:43:54 <monochrom> luite: no, you have to remember thread IDs when you forked, then kill them one by one
19:44:01 * copumpkin slaps shachaf 
19:44:22 <lispy> copumpkin: so what is traverse doing there?
19:44:37 <lispy> :t Data.Traversable.traverse
19:44:38 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
19:44:44 <blackdog> luite: i may be coming in late here, but i've found the 'threads' package really useful - you can create threads as part of a group, and then wait for them in aggregate
19:44:48 <copumpkin> lispy: it's mapM, so it's just sequencing the effects of the applicative (in this case ZipList) over the input list
19:44:49 <glguy> copumpkin:
19:45:00 <glguy> > transpose [[1,2,3],[4,5,6,10],[7,8,9]]
19:45:01 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9],[10]]
19:45:05 <copumpkin> yeah
19:45:17 <copumpkin> we don't do weird transpositions around here
19:45:22 * copumpkin outlaws glguy's upcoming example
19:46:18 <lispy> ([Int] -> ZipList Int) -> t Int -> ZipList (t Int)
19:47:01 <lispy> Still not sure what Traversable t means, but you said mapM?  So is that the monad instance for []?
19:47:13 <kallisti> lispy: it's mapM with an Applicative instance.
19:47:20 <copumpkin> mapM doesn't need a full Monad
19:47:25 <copumpkin> traverse is what mapM should have been
19:48:01 <kallisti> actually I think Data.Traversal.mapM is what mapM should have been. :P
19:48:06 <kallisti> *traversable
19:48:22 <glguy> traverse is a fancy name for mapA
19:48:55 <lispy> So traversable is something I should look at after I'm comfortable with Applicative?
19:49:07 <copumpkin> lispy: yeah, and Foldable before Traversable
19:49:16 <lispy> (I find it odd that I've been doing haksell for a while and never bother to study applicative/traversable)
19:49:24 <copumpkin> but yeah, for ragged "matrices", the transpose I gave is going to behave differently from the Data.List one
19:49:35 <copumpkin> lispy: we still love you, it's okay
19:49:39 <glguy> > ((:[]) . concat) [[1],[2],[3]]
19:49:41 <lambdabot>   [[1,2,3]]
19:49:46 <glguy> copumpkin: transpose!
19:49:50 * copumpkin slaps glguy 
19:49:54 <lispy> Applicative => Foldable => Traversable, anything else in that sequence?
19:50:07 <glguy> > id [[1]]
19:50:08 <lambdabot>   [[1]]
19:50:18 * glguy amuses himself
19:50:23 <lispy> I like (:[]) as the monkey face emoticon :)
19:50:29 <shachaf> @quote eat.a
19:50:30 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
19:50:40 <lispy> heh
19:50:50 <copumpkin> lispy: oh, Foldable and Traversable are on a different axis
19:51:10 <copumpkin> Traversable interacts with Applicative, and things that are Traversable are typically Applicative too, but they don't have to be
19:51:39 <lispy> ah so {Applicative, Foldable => Traversable} ?
19:51:59 <copumpkin> yeah
19:52:05 <copumpkin> oh, you should check byorgey's typeclassopedia :)
19:52:06 * kallisti doesn't see a reason to learn Foldable before Traversable.
19:52:08 <copumpkin> it coversa ll this and more
19:52:22 <lispy> I think I read about Foldable once a long time ago...
19:52:34 <elliott> yes, http://www.haskell.org/haskellwiki/Typeclassopedia for all your typeclass encyclopedia needs :p
19:52:43 <lispy> I'm thinking of which ever one defines everywhere
19:52:55 <lispy> :t everywhere
19:52:56 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
19:53:43 <elliott> Foldable is unrelated
19:55:31 <lispy> Yeah, I realized that when I read that type sig :)
19:58:19 <lispy> I sometimes feel like I would spend forever learning all the great abstractions we have. Yet, often you can get by without them at the cost of some redundancy or boiler plate.  I think that's the reason I'm still unfamiliar with a bunch of them.
19:58:27 <lispy> It can be easy to get into a rut
19:59:31 <lispy> I'm interested in applicative in part because I'm trying to make a concious effort this year to improve my CT knowledge as it seems increasingly relevant.
20:00:21 <elliott> lispy: that's funny, because Applicative is uninteresting from a CT perspective as i understand it
20:00:34 <elliott> "strong lax monoidal functor" -- doesn't exactly have a ring to it
20:00:42 <lispy> :)
20:00:59 <elliott> the primary benefit of Applicative is making lots of lifting/glue code so, so much simpler
20:01:02 <lispy> But, if something has productive applications it can be interesting even if not theoretically interesting.
20:02:01 <elliott> right, was just saying wrt ct knowledge
20:02:44 <lispy> Okay, I should change scenery.
20:02:47 <lispy> Cheers.
20:05:07 <kallisti> why is Data.Attoparsec.Char8.isEndOfLine :: Word8 -> Bool
20:13:44 <strager> Can I tack on a deriving clause to a data declaration in a separate module?  (I want to add deriving (Typeable, Data) to a few of my own types, but not clutter the data declarations themselves.)
20:14:01 <dmwit> {-# LANGUAGE StandaloneDeriving #-}
20:14:07 <dmwit> deriving instance Class Type
20:14:28 <dmwit> However, if you have control over the module, you should just derive it there.
20:14:33 <dmwit> That will avoid having an orphan instance.
20:14:50 <strager> Orphan instance?
20:15:05 <luite> sorry guys, I missed all of the disgussions about killing threads due to some discussion in another channel
20:15:11 <luite> thanks for the tips
20:15:12 <dmwit> ?wiki orphan instance
20:15:13 <lambdabot> http://www.haskell.org/haskellwiki/orphan_instance
20:15:20 <strager> Thanks.
20:15:44 <luite> the problem is that I don't have thread id's since it's not my program :)
20:16:02 <luite> but I'd be willing to try some low level RTS hacks
20:22:08 <luite> does the options package work for anyone with ghc 7.0.4 on linux or os x?
20:23:50 <strager> Define 'work'.  I can try compiling it (GHC 7.0.3 on Linux)
20:25:08 <slack1256> has somebody gotten working HOpenCV
20:25:13 <strager> options0.1 compiled fine luite
20:25:44 <slack1256> it keeps whinning about libopencv and libhighgui, but i have them installed
20:25:54 <strager> http://slexy.org/view/s2igzFkT4g
20:26:05 <slack1256> the author only installed them on ubuntu, anyone with luck in archlinux (installing from cabal)
20:26:18 <bobo> Hey everyone, I'm a student who is submitting a project for google summer of code. I am going to tackle the project to offer GHCi support for cabal, and would like to know if anyone has any advice for writing proposals. I would also like to know why the orignal implementation was only half completed.
20:26:35 <bobo> here is the ticket I was thinking of working on http://hackage.haskell.org/trac/summer-of-code/ticket/1588
20:27:18 <bobo> here is the partial implementation http://hackage.haskell.org/trac/hackage/ticket/382
20:27:27 <slack1256> bobo: send also a mail to haskell-cafe for submitting advices, irc log tend to get lost
20:30:49 <elliott> bobo: I believe "cabal repl" _is_ fully implemented.
20:30:56 <elliott> It is just not merged into the repository.
20:31:01 <elliott> bobo: But dcoutts will be able to give you a definitive answer.
20:31:04 <elliott> preflex: xseen dcoutts
20:31:04 <preflex>  dcoutts was last seen on freenode/#haskell 3 hours, 12 minutes and 12 seconds ago, saying: @seen phyx
20:31:42 <dcoutts_> elliott: I'm half way done with merging
20:31:48 <dcoutts_> some of the patches are in already
20:32:18 <dcoutts_> bobo: hia
20:32:25 <elliott> oh, that's great
20:32:55 <bobo> dcoutts_: hi :)
20:33:24 <luite> strager: thanks for testing
20:33:27 <dcoutts_> bobo: the impl from last year's GSoC did work but the code wasn't quite up to standard to merge immediately into the upstream repo
20:33:48 <luite> strager: someone else said that it didn't compile on his setup with ubuntu and ghc 7.0.4
20:34:09 <dcoutts_> bobo: the patches then sat around for quite a while and I'm now getting round to hacking on them to get it fixed and merged
20:34:36 <dcoutts_> bobo: but fear not, there's lots of useful cabal things remaining to do
20:35:20 <bobo> dcoutts_: do you have any reccomendations?
20:36:00 <dcoutts_> bobo: what area are you interested in? build systems, package systems, web and hackage?
20:37:46 <bobo> dcoutts_: web and hackage sounds fun to me.
20:37:56 <dcoutts_> well there's loads to do there :-)
20:38:20 <dcoutts_> bobo: are you aware of the new hackage-server implementation?
20:38:38 <dcoutts_> ever worked with web stuff? or Haskell web stuff, snap/happstack etc?
20:39:37 <dcoutts_> bobo: so a good task there might be to work on the migration/switchover process from the old to the new server
20:39:43 <kallisti> is there a good resource on non-standard features of many IRC servers?
20:40:01 <dcoutts_> bobo: or to work on the clients for building packages and docs
20:40:31 <bobo> dcoutts_: I have not heard of the new hackage-server implementation
20:41:38 <kallisti> for example, Freenode allows / in vhosts
20:41:46 <kallisti> but that's not part of the spec
20:41:46 <bobo> dcoutts_: I cannot say I have experience working with Haskell web stuff, but I am eager to get involved
20:42:09 <dcoutts_> bobo: take a look at http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
20:43:29 <bobo> dcoutts_: thanks!
20:47:06 <strager> Why can't I find Distribution.Simple on Hoogle?
20:48:44 <kallisti> hmm attoparsec-conduit can only transform parsers into sinks.
20:49:04 <luite> strager: http://www.haskell.org/hoogle/?hoogle=%2Bcabal+Distribution.Simple
20:49:24 <strager> Thanks
20:49:43 <luite> problem is that you must know which package a module lives in
20:49:45 <kallisti> would it be possible to change a sink into a conduit?
20:50:59 <kallisti> oh perhaps I want $$+ from conduit 0.4
20:51:06 <luite> does your parser give an incremental result?
20:51:24 <elliott> presumably you want sequence
20:51:42 <kallisti> ah yes
20:52:06 <strager> Well, what I really want is to know how to add a custom build step (building source code from a script) in Cabal.  I can do it in Make, but I think that won't work well with the Haskell ecosystem.
20:52:42 <kallisti> luite: not a useful incremental result. why?
20:53:36 <elliott> strager: perhaps look at shake
20:54:00 <dcoutts_> strager: it's possible to call make from a Setup.hs script in a build step
20:54:11 <luite> kallisti: or are you parsing multiple values?
20:54:22 <dcoutts_> strager: see the user hooks, preBuild, postBuild
20:54:36 <kallisti> luite: yes
20:54:37 <strager> dcoutts_: I also think it'd hard portability =]
20:54:46 <luite> kallisti: right then I understand
20:55:15 <dcoutts_> strager: well, you can do what you like in the build hooks
20:55:37 <kallisti> I can paste some code in a minute. I may be going about this the wrong way.
20:55:37 <strager> s/hard/hurt/
20:56:03 <dcoutts_> strager: e.g. happy and alex used to call out to perl to generate some templates, and you're right that can hurt portability. I recently changed those both to do the templates in pure Haskell in the Setup.hs
20:56:28 <strager> The script I'll be calling is in Haskell.
20:56:39 <strager> I was bringing up Make because I happen to know how to do this kind of thing in Make.
20:56:45 <dcoutts_> sounds like you're ok then
20:57:13 <strager> If I have a simple "build X before building Y, Z, or Q, and build X only if files a, b, or c change"
20:57:21 <strager> Is that easily encoded in the setup hooks?
20:57:37 <dcoutts_> strager: you get the IO monad, and a bunch of utils, that's it
20:57:55 <strager> So nothing like Shake or Make
20:58:51 <strager> K, so I see three options:
20:59:08 <strager> 1. Make Makefile the main entry point for building, and define rules there.
20:59:27 <strager> 2. Stick custom build rules into Setup.hs.
20:59:39 <strager> 3. Move to Shake and do things "the right way" (it seems).
20:59:58 <strager> Of those, which do you recommend?  Or do you see another reasonable alternative?
21:00:04 <dcoutts_> strager: right, depends if you want to distribute the code as a cabal package
21:00:23 <dcoutts_> yes, the Cabal "Simple" build system is not really very good
21:00:38 <dcoutts_> because it's not dependency based
21:00:58 <kallisti> luite: here's what I've got so far http://hpaste.org/66490
21:01:16 <kallisti> I wanted to mimic the design of network-conduit
21:01:34 <kallisti> this is basically a very rough draft.
21:02:07 <strager> dcoutts_: Where do you feel the community is going to solve that?
21:02:34 <dcoutts_> strager: eventually I want to have a proper dep based build system in Cabal
21:02:43 <dcoutts_> but doing it properly is hard
21:02:53 <dcoutts_> even shake isn't quite enough for the Cabal use case
21:03:01 <dcoutts_> though it's pretty close
21:03:34 <BigEndian> I have a rather beginner question if anyone feels like fielding it
21:03:58 <strager> What limitations in Shake make it inappropriate?
21:04:18 <BigEndian> http://hpaste.org/66491
21:04:26 <elliott> hi hpaste
21:04:43 <BigEndian> oh nevermind I think I just saw it, obviously.
21:04:58 <kallisti> BigEndian: yes you can't index numbers with !!
21:05:12 <kallisti> > 2 !! 3  --???
21:05:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:05:32 <kallisti> > 2 !! 3  -- ???
21:05:33 <lambdabot>   No instance for (GHC.Num.Num [a])
21:05:33 <lambdabot>    arising from a use of `e_123' at <inte...
21:05:45 <BigEndian> kallisti: sorry, I thought it was a type issue at first
21:05:50 <kallisti> it is.
21:05:59 <dcoutts_> strager: so this is last time I looked, but the issue is that cabal build system needs to read a .cabal file and configure everything based on that, while shake expects a bunch of things encoded into a "oracle" which is hard coded in a per-project .hs file
21:06:00 <BigEndian> Well, a type issue in the sense that it couldn't be properly inferred
21:06:16 <BigEndian> I guess I'll use map instead
21:06:21 <luite> kallisti: ah looks reasonable, but I don't have that much experience with conduit
21:06:29 <dcoutts_> strager: essentially we need one more level of indirection
21:06:31 <kallisti> neither do I. :P
21:06:38 <strager> dcoutts_: What prevents some Haskell code from reading a .cabal file and turning it into Shake rules?
21:06:40 <luite> kallisti: so i'm not sure what happens when parsing multiple lines
21:06:47 <strager> As a "legacy" support step
21:06:49 <dcoutts_> strager: nothing
21:06:51 <BigEndian> yeah, got it this time
21:06:57 <dcoutts_> strager: but that's not the design we want
21:07:03 <luite> kallisti: probably will be ok, I think :)
21:07:04 <strager> Okay
21:07:21 <dcoutts_> strager: we don't want to get rid of the .cabal file, it's a feature not a bug :-)
21:07:43 <strager> I understand
21:07:58 <dcoutts_> strager: e.g. a .cabal file can be edited by an IDE, a .hs file with build rules cannot
21:08:02 <kallisti> luite: I'm actually not sure either.
21:08:12 <kallisti> I don't know if sequence handles that or what.
21:08:23 <strager> Yes.  What I was saying is that a .cabal file can be read and turned into *runtime* rules, not into .hs Shake rules.
21:08:41 <dcoutts_> strager: but the prog that interprets the .cabal file and builds on that basis should be using a dep based build system, even if that set of build rules were not extensible
21:09:39 <dcoutts_> strager: except that then changes in the .cabal file would not be propagated properly
21:09:51 <strager> Why not?  It's as if the rules changed in Shake.
21:10:12 <strager> Every Shake invokation would parse the .cabal file, build the dependency graph (or whatever), and then do the build.
21:10:13 <dcoutts_> strager: because you're saying you're generating the rules based on the .cabal file
21:10:36 <dcoutts_> strager: right, the most important file is not reflected in the dependency graph
21:10:51 <strager> How not so?
21:11:04 <strager> Everything depends on the .cabal file
21:11:26 <strager> (I don't know how Shake works, so I may be wrong in some assumptions)
21:12:09 <dcoutts_> the point is you want one static set of rules that when invoked, read the .cabal file and do the right thing
21:12:36 <dcoutts_> then everything is within the dep framework and you can be confident that you're tracking deps correctly
21:12:53 <strager> Right.
21:13:12 <dcoutts_> and as I understand that, shake lacks the expressiveness to do that
21:13:28 <dcoutts_> it usually doesn't matter because you can encode things into the "oracle"
21:13:36 <dcoutts_> but it bites us here
21:14:09 <strager> Okay.
21:14:16 <strager> And what's wrong with reading the .cabal file, then running Shake?
21:14:44 <dcoutts_> then you're not properly including the dependencies on the .cabal file into the dep framework
21:14:51 <dcoutts_> and so it'll inevitably be wrong
21:15:33 <strager> Well you can do that after the fact, but you're certainly right.  =]  I don't see why that makes it a bad solution, though.  Just idealisms?
21:16:11 <dcoutts_> you really have to include everything into the dep system, otherwise you've got almost no hope of tracking dependencies correctly
21:16:20 <dcoutts_> and if you miss any then you're screwed
21:16:45 <dcoutts_> you get incorrect rebuilds or parallel builds
21:17:30 <strager> I'm still not seeing why { read .cabal file; translate into shake rules; run shake with all rules depending on .cabal file } doesn't satisfy that goal.
21:18:27 <dcoutts_> strager: well that might work but it means you rebuild everything whenever you change anything in the .cabal file
21:18:48 <dcoutts_> it's insufficiently granular
21:18:56 <strager> Okay.
21:19:15 <strager> And if you don't say that all rules depend on the .cabal file, what happens?
21:19:46 <dcoutts_> strager: then you need an ad-hoc way to get things to update when you change the .cabal file
21:19:55 <dcoutts_> aka complex and buggy
21:20:06 <dcoutts_> the right thing is to include it into the system properly
21:20:21 <dcoutts_> then you let the framework handle dep tracking
21:20:29 <strager> Well if you change the rules, doesn't the "oracle" change (?) and cause a proper rebuild?
21:20:55 <dcoutts_> I think the oracle is expected to be static
21:21:32 <strager> I thought rules were recordable for the very reason of being able to detect rule changes.
21:21:34 <kallisti> oh wow, I convinced the maintainer of zip-archive to relicense to BSD3.
21:21:39 * kallisti didn't think that would actually work.
21:22:04 <dcoutts_> strager: the rules cannot be recorded, they're .hs code, only the inputs and outputs
21:22:09 <ivanm> kallisti: why the relicense?
21:22:32 <dcoutts_> strager: which is another reason you want a single static set of rules, but varying data (.cabal file)
21:22:34 <ivanm> did you have a commercial need for it?
21:22:45 <strager> http://hackage.haskell.org/packages/archive/shake/0.2.9/doc/html/src/Development-Shake-Core.html#Rule
21:23:14 <kallisti> ivanm: so that I can use it as a dependency in a BSD3 Haskell package
21:23:16 <strager> Is that not an encoded dependency?  (I haven't used Shake at all)
21:23:35 <ivanm> kallisti: which package? and why is *that* BSD3? (just curious)
21:24:28 <kallisti> ivanm: I'm working on Haskell bindings for Selenium 2. It's mostly done now, but I needed to add some code using zip archives and it has to work cross-platform.
21:24:29 <dcoutts_> strager: that's just a class for validating cached values
21:24:49 <kallisti> ivanm: the project isn't on Hackage just yet, but will be within 2 weeks most likely.
21:24:59 <ivanm> kallisti: as in http://seleniumhq.org/ ?
21:25:01 <kallisti> yes
21:25:02 <dcoutts_> strager: it's like changing the scripts in your Makefile
21:25:36 <ivanm> kallisti: so why did you choose to make it BSD3 ?
21:25:38 <kallisti> ivanm: as far as license choice I just felt that Selenium is likely something that's will see use for commercial purposes.
21:25:43 <ivanm> *nod*
21:25:53 <strager> dcoutts_: If you have one Makefile per rule, and you have the rule depend on its own Makefile, things can become magic (I think; I haven't actually tried it!).
21:25:54 <ivanm> fair enough
21:26:05 <mysticc> Is there something for checking concurrent applications .. like trying possible interleavings and then checking the invariant as in quickcheck ??
21:26:05 <dcoutts_> strager: here's something I wrote on this topic a few years back http://www.well-typed.com/blog/13
21:26:26 <ivanm> though by my understanding of what it is, wouldn't commercial firms just use it in-house rather than having a need to write software *using* it and selling it?
21:26:27 <kallisti> ivanm: I've noticed BSD3 seems to be the norm on Hackage.
21:26:41 <ivanm> kallisti: yeah, the general trend is BSD3 for libraries, GPL for apps
21:26:49 <kallisti> makes sense.
21:27:01 <ivanm> just wondering what package you were writing that you wanted someone to relicense their own code :)
21:27:34 <kallisti> there's likely a workaround, but it would be a shame to duplicate so much effort.
21:27:36 * elliott isn't sure GPL for apps is a trend
21:27:53 <ivanm> elliott: it used to be the norm at least
21:28:21 <elliott> yeah, not sure it applies so much any more
21:28:26 <elliott> everyone seems to go with BSD3 now
21:28:41 <ivanm> kallisti: are you writing actual bindings? if so, are you allowed to link to Apache code in BSD3 licensed stuff?
21:28:43 <dcoutts_> strager: making the rules into data would be plausible, though in the case of make I don't think that scheme would quite work
21:28:55 <ivanm> elliott: I haven't noticed all that many new apps coming out recently
21:29:12 <kallisti> ivanm: Selenium uses a client-server model. I'm just writing a client. so it's not bindings in that sense, no.
21:29:14 <strager> > So before anything else can be done, make has to update deps.mk, even if it turns out in the end that the deps given in the include file are irrelevant to the task at hand.
21:29:15 <lambdabot>   <no location info>: parse error on input `else'
21:29:21 <strager> I don't think this is true.
21:29:27 <ivanm> kallisti: ahhh, right
21:29:30 <kallisti> ivanm: but the selenium devs seem to use the term "bindings" for their clients, and I caught their bug.
21:29:41 <elliott> ivanm: that's true also
21:30:06 <ivanm> kallisti: well, I call my graphviz package to be "bindings" despite it just generating and parsing dot code and feeding it in/out of Graphviz programs ;)
21:30:09 <dcoutts_> strager: unless it changed recently, it is true
21:30:14 <strager> Actually, after thinking about it for a bit, it is true.
21:30:16 <dcoutts_> strager: and for the reason given
21:30:17 * elliott mumbles something about the ludicrousness of talking over TCP/IP differing from linking license-wise
21:30:31 <strager> I didn't read the following paragraph yet =]
21:30:33 <ivanm> (if I actually did bindings to the C library it wouldn't be linkable to GPL apps as it uses EPL)
21:30:43 <kallisti> elliott: peculiar isn't it
21:30:49 <elliott> ivanm: hmm, what's EPL?
21:30:58 <ivanm> Eclipse Public License
21:31:22 <ivanm> it's a free software license, but incompatible with GPL
21:31:33 <danharaj> Is it safe to unsafePerformIO newIORef if the resulting IORef is only ever used in IO code later? What if the IORef must be shared between two pure values?
21:31:50 <elliott> danharaj: it's sort of safe
21:32:00 <elliott> there's a ghc bug meaning such things can duplicate sometimes, IIRC fixed in 7.4
21:32:15 <elliott> see http://hackage.haskell.org/package/safe-globals for a method that avoids that
21:32:26 <elliott> oh, wait... "This library may not work properly on GHC before 7.4, due to a GHC bug"
21:32:32 <elliott> I thought it worked around that too :)
21:33:03 <kallisti> elliott: I guess communicating with a protocol is implicitly open, whereas linking may be violating intellectual property because it's not implied that it was intended to be linked.
21:33:08 <strager> > Amusingly, just to make clean, make has to build half the project.
21:33:08 <lambdabot>   <no location info>: parse error on input `,'
21:33:13 <kallisti> *communicating with an open protocol
21:33:15 <strager> I think somethings wrong if that happens dcoutts_ ^
21:33:18 <mysticc> Is there something for checking concurrent applications .. like trying possible interleavings and then checking the invariant as in quickcheck ??
21:33:21 <strager> I haven't had that happen to me (yet).
21:33:46 <tkahn6> hey guys so i have a record containing a list of Int16s, and there's a function theInts :: TheRecord -> [Int16], and when i call theInts on a record instance, i get *** Exception: Prelude.(!!): index too large
21:33:52 <elliott> danharaj: 'Ere, if you care about GHC < 7.4: http://mainisusuallyafunction.blogspot.com/2011/11/global-locking-through-stableptr.html
21:33:55 <dcoutts_> strager: the thing that's wrong is make's assumption that it's reasonable to construct the full dependency graph
21:34:06 <tkahn6> i have no idea what's going on with that
21:34:38 <elliott> tkahn6:
21:34:42 <elliott> > [0,1] !! 1
21:34:43 <lambdabot>   1
21:34:44 <elliott> > [0,1] !! 2
21:34:45 <lambdabot>   *Exception: Prelude.(!!): index too large
21:34:49 <tkahn6> right but
21:34:50 <elliott> you're accessing too high indices
21:34:50 <dcoutts_> strager: you've been fortunate not to have had multiple levels of "this needs to be built to discover the dependencies of that"
21:34:54 <danharaj> elliott: Thanks for the references.
21:35:08 <strager> dcoutts_: You can include foo.mak iff it's already built.  That's how I do it.
21:35:09 <danharaj> Always get nervous when unsafePerformIO is around.
21:35:10 <tkahn6> elliott: theInts :: TheRecord -> [Int16]
21:35:10 <elliott> danharaj: ...but apart from that bug, yes it's safe. although what does "shared between two pure values" mean?
21:35:20 <strager> dcoutts_: And yes, I haven't needed multiple levels yet.
21:35:21 <elliott> danharaj: oh, and make sure to {-# NOINLINE theRef #-}, even on 7.4
21:35:23 <dcoutts_> strager: no, that's not enough, it has to be up to date
21:35:31 <elliott> tkahn6: yes, so theInts has a bug
21:35:35 <elliott> no wait
21:35:38 <ivanm> @hoogle lookup
21:35:39 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:35:39 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:35:39 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
21:35:41 <elliott> tkahn6: most likely, your creation of the record has a bug
21:35:48 <dcoutts_> strager: and gnu make will rebuild to ensure foo.mak is up to date
21:35:50 <tkahn6> elliott: hmmm
21:35:54 <elliott> tkahn6: you'll be forcing the resulting [Int16], which forces the field of the record, which forces the record
21:36:01 <tkahn6> elliott: that make sense
21:36:03 <tkahn6> thanks
21:36:06 <danharaj> elliott: if I do { let x = unsafePerformIO newIORef in ... } I want to make sure wherever x is referenced refers to the same IORef.
21:36:09 <dcoutts_> strager: it's the only correct thing it can do, given its model
21:36:23 <strager> dcoutts_: I think it's kinda hard to explain what I'm trying to say without examples xD  And examples are hard to understand in this domain
21:37:26 <dcoutts_> strager: yeah, it's not as easy a problem as it looks
21:37:40 * dcoutts_ has to go
21:37:52 <elliott> danharaj: right, you need {-# NOINLINE #-} on it
21:38:01 <elliott> danharaj: and that GHC bug applies to you (I believe)
21:38:15 <danharaj> elliott: I'm on 7.4 fortunately.
21:38:38 <elliott> lucky you :)
21:38:41 <strager> dcoutts_: Bye \o
21:38:43 <dcoutts_> danharaj: and you need to sacrifice a goat and beg for forgiveness for using unsafePerformIO newIORef
21:38:45 <strager> Good talk
21:39:33 <danharaj> dcoutts: I still have a backlog of penance for using unsafeCource.
21:39:47 <elliott> man
21:39:57 <elliott> I gotta start breeding goats if I have any hope of redeeming myself
21:45:38 <brownies> elliott: they do say that kids are the future
21:53:38 <sizz> doe!
21:54:06 * BMeph is delighted to have a legitimate use for the phrase "I love kids, but I could never eat a whole one..." ;)
22:22:55 <zzo38> I know that all applicative are monoid transformer; but I do not know if all monoid transformer are applicative. Give a proof or a counterexample.
22:23:25 <zzo38> And I think many list operation can be generalized to other classes, such as filter to MonadPlus, etc.
22:25:38 <zzo38> filter f = (>>= \x -> x <$ guard (f x));
22:27:33 <OODavo> Is there actually any difference between the typeclasses MonadPlus, Monoid, and Alternative? They all seem to define precisely the same two methods.
22:27:55 <kallisti> the difference between Monoid and the others is in the kind of its typeclass parameter.
22:27:58 <zzo38> OODavo: MonadPlus and Alternative is with an extra type parameter
22:28:25 <kallisti> but yes they're all monoids.
22:29:30 <zzo38> Yes they are all monoids
22:29:38 <geekosaur> although, don't the Monoid and MonadPlus instances for some standard type (Maybe) do equally logical but different things?
22:29:56 <geekosaur> er, "(I think Maybe?)"
22:30:02 <zzo38> But MonadPlus documentation mentions a "right zero law" which does not actually apply for all instance and ought not be the law
22:30:11 <zzo38> geekosaur: Yes
22:30:54 <zzo38> The "left zero law" does apply to all MonadPlus instances though; it is implied by the monad laws.
22:31:26 <zzo38> filter f = (>>= ((<$) <*> guard . f))
22:32:34 <zzo38> I think MonadPlus ought to be just a class synonym for Alternative and Monad together
22:33:16 <kallisti> zzo38: but then there wouldn't be a MonadZero class.
22:36:26 <zzo38> kallisti: Yes; but does there need that?
22:36:40 <kallisti> I think having mzero within its own class would be nice yes.
22:38:26 <zzo38> I think it is just a problem with Haskell in general. The new idea (Ibtlfmm) you can easily split, move, and recombine typeclasses because they are really type synonyms
22:47:32 <kallisti> > 40000000000000000000000000000000000000000000000000000000000 :: Int
22:47:32 <lambdabot>   -8070450532247928832
22:47:36 <kallisti> looks legit.
22:51:29 <dmwit> > 40000000000000000000000000000000000000000000000000000000000 `mod` (2^64)
22:51:29 <lambdabot>   10376293541461622784
22:51:34 <dmwit> > 40000000000000000000000000000000000000000000000000000000000 `mod` (2^63)
22:51:34 <lambdabot>   1152921504606846976
23:01:13 <vyom> are there any Haskell functions to compare equality of Floating and Double types with a tolerance?
23:01:54 <brownies> is camelCasing the convention for Haskell?
23:04:04 <kallisti> brownies: it's by far the most predominant.
23:04:13 <kallisti> you'll see underscores used, and even ' used as a seperator
23:04:52 <kallisti> brownies: types and constructors are amost universally CamelCase though.
23:06:07 <kallisti> vyom: not that I know of. of course you can do the abs difference trick.
23:06:32 <kallisti> > abs (0.5 - 0.5000001)  < 0.0001
23:06:33 <lambdabot>   True
23:06:37 <zzo38> In some cases I have used CamelCase and underscores, such as the "DVI_Binary" constructor in my dvi-processing program.
23:06:49 <brownies> kallisti: ok
23:06:59 <brownies> i feel that underscores are more readable, but i guess it is just bikeshedding =P
23:07:20 * kallisti prefers camelcasing because he finds it easier to type.
23:08:48 <zzo38> I find that we can use either way; in some cases one is better than the other I think
23:08:52 <zzo38> Or in some cases use both
23:09:17 <brownies> heh ok
23:09:36 <brownies> just trying to get some perspective on what coding style i should enforce as multiple people touch the codebase
23:09:39 <BlankVerse> i have a haskell program which has few forkIO calls , the programs hangs after a few secs , no cpu usage , no disk usage , any tips for tracing the bug?
23:09:41 <brownies> good to see everyone's open-minded :)
23:09:42 <zzo38> But use what you prefer.
23:09:45 <kallisti> tHis_Is'theBest_seperate'_
23:10:05 <kallisti> brownies: I'd go with camelcase as a convention.
23:10:17 <kallisti> BlankVerse: yes. more info would help.
23:10:19 <zzo38> For example, I prefer non-layout style without do-notation, and public domain; but other people prefer differently is OK too.
23:10:51 <brownies> zzo38: hm, don't think i've read enough docs to even parse that sentence yet, heh
23:11:18 <kallisti> by non-layout style he means using semicolons and curly brackets instead of indented lines.
23:11:55 <zzo38> kallisti: I usually indent the lines too; but sometimes I might want to indent something in a way which is not compatible with layout
23:12:13 <kallisti> zzo38: I've never encountered that scenario
23:12:20 <kallisti> well, with do notation I do sometimes.
23:12:55 <kallisti> brownies: by "without do-notation" he means using monadic combinators directly rather than using the do syntax.
23:12:59 <kallisti> > do { x <- [1..5]; guard (x > 2); return x }
23:13:00 <lambdabot>   [3,4,5]
23:13:05 <kallisti> instead of this he would write:
23:13:25 <zzo38> Well, I use applicative combinators as well as monadic combinators
23:13:37 <kallisti> > [1..5] >>= \x -> guard (x > 2) >> return x
23:13:38 <lambdabot>   [3,4,5]
23:13:45 <kallisti> I'm sure there's a way to shorten that actually
23:13:59 <brownies> i see, so it results in more dense code
23:14:06 <brownies> thanks for explaining that kallisti
23:14:08 <kallisti> sometimes it's clearer.
23:14:09 <zzo38> kallisti: Yes, that is filter. I have written a generalized filter above, for any MonadPlus
23:15:00 <kallisti> if you know the combinators well enough, then using them over do notation can sometimes result in more concise, clearer code.
23:16:12 <zzo38> kallisti: Especially if you use applicative operations as well as monad operations, I think.
23:18:08 <zzo38> When reading the contents of binary files I will use a lot of applicative stuff, such as like this:   readFont n m h = (map fromEnum <$> (mReadData h 12 :: IO [Word16])) >>= \z -> makeFont n m z <$> mReadData h (z !! 1) <*> mReadData h ((z !! 3) + 1 - (z !! 2)) <*> mReadData h (z !! 4) <*> mReadData h (z !! 5) <*> mReadData h (z !! 6) <*> mReadData h (z !! 7) <*> mReadData h (z !! 8) <*> mReadData h (z !! 9) <*> mReadData h (z !! 10) <*> mReadData h (z !! 11);
23:19:53 <zzo38> But sometimes you can use other existing function without >>= or <*> such as this:   loadFont m n = withBinaryFile n ReadMode $ readFont (fromStr $ takeBaseName n) m;  mReadData h i = sequence . replicate i $ readData h;
23:20:20 <bobry> is it possible to allow matching on a record type, but restrict creating new instances of it?
23:21:32 <zzo38> bobry: I don't think so.
23:21:38 <brownies> zzo38: that does look powerful, although it also makes clear i have a long ways to go, heh.
23:21:42 <zzo38> What are you trying to make?
23:23:44 <brownies> me?
23:23:54 <Twey> zzo38: sequence . replicate i = replicateM i
23:24:11 <zzo38> Twey: OK
23:24:25 <zzo38> brownies: No, I was asking bobry.
23:24:27 <bobry> zzo38: I have a data type, which is extracted from XMLRPC reply, so I don't want the user to be able to create an instance bypassing XMLRPC
23:24:52 <bobry> I guess the only way to achieve this is to export getters
23:24:57 <bobry> making my type abstract
23:25:07 <zzo38> bobry: And what is wrong for the user to be able to create it bypassing XMLRPC?
23:27:38 <bobry> nothing, except that it's "fake" :)
23:28:15 <zzo38> bobry: Unless there is a real problem with it you probably should allow the user to create their own values of that type
23:29:12 <bobry> Thanks, I'll think it over
23:30:14 <zzo38> (Possible problems would be: violating laws of typeclasses, allows values that can crash the program, etc)
23:31:42 <geekosaur> if the point is typesafe generation of valid xml, exposing the constructor might allow bypassing that safety...
23:32:34 <zzo38> geekosaur: Yes, that is the thing that you should try to figure out, if it is capable to bypass that safety of the constructor is exposed
23:36:24 <Twey> bobry: You can create your own destructor functions, and use view patterns or pattern guards
23:43:14 <zzo38> Another thing is I see >>= as a shortcut for using join and fmap together, and often use >>= with lists. However, >>= also has something to do with Kleisli categories
23:44:06 <geekosaur> aren't those directly related?
23:44:14 <kallisti> yes
23:44:46 <brownies> i tried to do the usual simple programming exercise, after this point in the tutorial, and i've run into some syntax issue or something -- could someone take a quick look? https://gist.github.com/5ecdbb328468d793b72d
23:44:49 <brownies> literally 1 line of code
23:45:44 <zzo38> The morphism composition for Kleisli categories is (<=<) so (>>=) is like meaning you add on another Kleisli morphism to the values of the monad
23:46:52 <geekosaur> :t and
23:46:53 <lambdabot> [Bool] -> Bool
23:47:47 <zzo38> But I usually understand it better as >>= being a shortcut for using join and fmap together
23:47:51 <brownies> ah, so i have to give the and operator a list of Bools?
23:48:06 <geekosaur> and even so you're using it wrong.
23:48:14 <brownies> AHA
23:48:17 <geekosaur> but, the operator you really want is one you will probably recognize
23:48:20 <brownies> i think i've got it.
23:48:20 <geekosaur> :t (&&)
23:48:21 <lambdabot> Bool -> Bool -> Bool
23:48:23 <brownies> oh, really?
23:48:25 <brownies> ohhhhh
23:49:13 <brownies> thanks geekosaur
23:49:26 <brownies> i figured out the alternate way too... and [(x `mod` 3 == 0), (x `mod` 5 == 0)]
23:49:42 <geekosaur> right, but that's doing it the hard way :)
23:50:30 <brownies> heh, yea, i like the &&, looks clean and reasonable
23:51:33 <kallisti> brownies: even better you could just write:
23:51:38 <kallisti> x `mod` 15 == 0
23:51:52 <brownies> kallisti: true. how embarassing. =P
23:52:11 <brownies> clearly need to sleep, heh.
23:55:44 <kallisti> so do I.
