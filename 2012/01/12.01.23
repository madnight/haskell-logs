00:01:17 * hackagebot uu-tc 2009.2.2 - Haskell 98 parser combintors for INFOB3TC at Utrecht University  http://hackage.haskell.org/package/uu-tc-2009.2.2 (JurrienStutterheim)
00:02:42 <cy> you know not even IO has side effects once you take time as a parameter.
00:03:01 <srhb> cy: Assuming they work.
00:03:37 <cy> srhb: "they"?
00:03:48 <srhb> cy: Well, the IO.
00:03:59 <srhb> "it" :-)
00:04:18 <cy> Whether it works or not depends on what time it is.
00:04:42 <srhb> cy: Then it's not JUST time, but some composite factor, isn't it?
00:04:52 <cy> At any given time IO produces exactly one value, possibly nothing.
00:05:10 <cy> Only reason we need to account for side effects is our programs cannot time travel.
00:05:34 <srhb> cy: Well, that and quantum mechanics.
00:05:59 <elliott> cy: That's basically just the State RealWorld model, and inherits all its flaws.
00:06:08 <elliott> For instance, time isn't the only parameter you need: consider concurrency.
00:06:17 <elliott> (Time, ThreadId) at the very least.
00:07:00 <elliott> (You might be interested in FRP, though; (Behavior a) conceptually represents (Time -> a).)
00:07:00 <cy> Eh, quantum mechanics...
00:07:29 <cy> Once you get outside of deterministic outcomes, whether you can call it a program at all gets a bit fuzzy.
00:07:37 <srhb> Agreed.
00:07:57 <srhb> Assuming the RealWorld is deterministic in all its actions, we're fine.
00:08:18 <c_wraith> that seems like a huge assumption. We're not sure of that.
00:08:25 <srhb> Actually we're sure it's not.
00:08:39 <srhb> But -assuming-!
00:09:43 <srhb> We could just wrap everything in Probably...
00:09:45 <srhb> :-)
00:09:55 <cy> Assuming the real world is non-deterministic you can actually prove that the past, present and future don't really...exist...
00:10:05 <cy> very weird stuff
00:11:01 <tikhonjelvis> Would it be possible to differentiate a non-deterministic world from one we just can't measure well enough?
00:11:17 <cy> yes
00:11:24 <cy> double slit experiment, for instance
00:11:51 <cy> if deterministic, then two spots of light. if non-deterministic, then an interference pattern.
00:12:21 <srhb> De Broglie modelled it in a purely deterministic fashion, I believe.
00:13:25 <srhb> (This is silly. :-))
00:13:43 <tikhonjelvis> Naturally. This is, after all, IRC.
00:14:27 <frerich> Does anybody have experience with replacing parts of a C++ program with Haskell code? I believe a project I'm working on has quite a few code areas which could be expressed quite nicely in a language like Haskell. I'm considering to try rewriting the code and then providing some FFI bindings so that I can (hopefully) write a drop-in replacement.
00:15:15 <srhb> I was under the impression that the "drop-in" is where it gets hairy.
00:15:51 <tikhonjelvis> srhb: That's true for almost all refactoring :)
00:15:58 <cy> Haskell has a C interface no doubt...
00:16:34 <srhb> tikhonjelvis: Have you seen this? http://www.haskell.org/haskellwiki/Cxx_foreign_function_interface
00:16:48 <cy> https://en.wikibooks.org/wiki/Haskell/FFI
00:18:10 <cy> "converting" C to Haskell gets a lot easier when you realize that it's just a matter of deferring all the C code execution until the Haskell program is all finished, optimized, and ready to roll. It's like IO. Eager stuff goes last.
00:18:31 <tikhonjelvis> I think the issue is with the ++ rather than the C :)
00:19:08 <cy> Yeah I used C++ almost exclusively for a number of years. Then I realized that I could do the same damn thing in C and it's actually less verbose.
00:19:17 <cy> Good times.
00:21:44 <cy> I would assume it possible to produce stuff like Haskell lists from C code, but that'd be a lot more complicated as it'd have to produce data on-demand instead of being able to defer everything to the end.
00:22:03 <cy> Well "a lot" being a relative comparison...
00:51:18 * hackagebot ghc-mod 1.0.7 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.7 (KazuYamamoto)
00:59:50 <NothingMan65> Hey everyone.  Noob here.
01:00:00 <NothingMan65> Having trouble with ambiguous types..
01:00:14 <tikhonjelvis> You should probably just add a type signature to whatever you're doing.
01:00:37 <NothingMan65> See that's the thing.  Whenever, I add a type signature, I suck even moe.
01:00:38 <NothingMan65> more*
01:00:50 <srhb> NothingMan65: Show your code, hpaste it if it's long. :)
01:00:55 <srhb> ie. more than one line.
01:01:19 <elliott> Don't worry if you have trouble writing type signatures, just load your module in GHCi and get them from there! Er... I hope tikhonjelvis has infinite advice loop prevention.
01:01:28 <tikhonjelvis> Also, don't worry about being a noob.
01:02:33 <NothingMan65> Hmm
01:02:33 <NothingMan65> http://pastebin.com/fWLYtMVY
01:02:35 <mauke> The paste fWLYtMVY has been copied to http://hpaste.org/56886
01:03:40 <NothingMan65> I guess that problem3 needs a type signature
01:03:46 <merijn> I'm gonna blindly guess that the problem is a missing "fromIntegral"
01:04:02 <donri> wishlist: haddock should show the type for QuasiQuoter
01:04:17 <merijn> Oh, wait, no literals are always overloaded, my bad >.>
01:04:38 <NothingMan65> Thank for the engagement merijn
01:04:51 <ChristianS> NothingMan65: if you compile with -Wall (maybe -W is sufficient), ghc tells you the signatures of all top-level definitions that don't yet have one
01:04:54 <elliott> The problem is in floor.
01:05:03 <elliott> NothingMan65: You do (n/2) but you also do (n `mod` x)
01:05:04 <elliott> :t mod
01:05:05 <lambdabot> forall a. (Integral a) => a -> a -> a
01:05:14 <elliott> (n/2) means n must be Fractional.
01:05:14 <donri> @where ops
01:05:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:05:20 <donri> please ban ADildeaux
01:05:22 <elliott> (mod n) means n must be Integral.
01:05:28 <NothingMan65> Okay, so the result of floor must be converted to integral
01:05:31 <elliott> No.
01:05:38 <elliott> n must be converted to a Fractional number to pass to (/).
01:05:43 <elliott> You can use fromIntegral to do that.
01:06:05 <elliott> marienz: ping
01:06:10 <NothingMan65> Ohhh, so fromIntegral makes an Integral a general type and then the type signature take care of what to do with it from therE
01:06:11 <NothingMan65> ?
01:06:14 <NothingMan65> If they can.
01:06:17 <ChristianS> i second that: <donri> please ban ADildeaux
01:06:19 <elliott> :t fromIntegral
01:06:20 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:06:21 <donri> http://i.imgur.com/taU6B.png
01:06:27 <elliott> fromIntegral turns any Integral into a Num.
01:06:30 <NothingMan65> And RealFrac is  Num?
01:06:37 <elliott> In this case, you'll be turning n -- an Integer, say -- into (likely) Double.
01:06:40 --- mode: ChanServ set +o mauke
01:06:41 --- mode: mauke set +b $a:ADildeaux
01:06:44 <elliott> NothingMan65: However I would suggest just using (n `div` 2).
01:06:48 --- kick: ADildeaux was kicked by mauke (ADildeaux)
01:06:49 <merijn> Oh, damn. I was right about fromIntegral after all?
01:06:56 <elliott> which is integral division
01:06:58 <elliott> merijn: yep!
01:07:12 <elliott> NothingMan65: It corresponds properly to mod, and you don't need the conversion step.
01:07:26 <NothingMan65> Okay, it basically does the same thing, but returns an Integra?
01:07:31 <elliott> :t mod
01:07:31 <NothingMan65> integral*
01:07:32 <lambdabot> forall a. (Integral a) => a -> a -> a
01:07:35 <elliott> Operates on and returns, yes.
01:07:38 <NothingMan65> Sweet.
01:07:40 <NothingMan65> Thanks elgot
01:07:42 <NothingMan65> Whoops
01:07:43 <NothingMan65> elliott
01:07:49 <donri> thanks mauke
01:08:01 <NothingMan65> Awesme!
01:08:25 <merijn> NothingMan65: Also, you have some redundant parenthesis
01:08:26 <donri> weird place to preach racism
01:08:40 <merijn> You can just write: "isFactor x n = n `mod` x == 0"
01:08:48 --- mode: mauke set -o mauke
01:09:35 <NothingMan65> Excellent merijn,  I'm progressing towards the level of trust in myself to remove redundant parentheses, but I'm not quite there yet (=
01:09:41 <mauke> -!- .quit ADildeaux!~ADildeaux@ip72-207-16-214.sd.sd.cox.net [K-Lined]
01:09:45 <merijn> You can also use the function ($) to avoid some parenthesis, for example "main = do print (problem3 13195)" can be rewritten as "main = print $ problem3 13195"
01:09:59 <tikhonjelvis> NothingMan65: The trick is to trust the compiler rather than yourself :)
01:10:20 <NothingMan65> I don't have much of a choice, tikhonjelvis (=
01:10:56 <NothingMan65> Well, thanks for all the tips fellas/ladies, I'll be back!
01:11:06 <tikhonjelvis> Have fun.
01:11:11 <NothingMan65> No doubt
01:11:14 <merijn> NothingMan65: The basic rule is that function application binds strongest (stronger than operators such as (/), which is why floor needs parenthesis around n/2)
01:11:35 <NothingMan65> Otherwise it would be floor n, only
01:11:40 <merijn> Yes
01:11:47 <NothingMan65> Superb
01:11:59 <NothingMan65> Superfun language
01:12:13 <NothingMan65> Like swedish.
01:12:18 <merijn> NothingMan65: The operator $ in "f $ x", basically just does "f x", but since $ has the lowest priority it can prevent binding (see my example of "main = print $ problem3 13195")
01:13:00 <NothingMan65> That's pretty cool...
01:13:10 <merijn> :t ($)
01:13:11 <lambdabot> forall a b. (a -> b) -> a -> b
01:13:28 <donri> you can often substitute parenthesis-to-end-of-expr with $ - but know that it's *not* syntax
01:13:37 <merijn> Let's see if I can do this example without messing up
01:13:43 <merijn> > f $ x y
01:13:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a'
01:13:44 <lambdabot>         against infe...
01:13:50 <merijn> Aww...
01:13:57 <bartavelle> :)
01:14:11 <donri> and it's often better to use (.): f . g $ x == f $ g x
01:14:41 <NothingMan65> I'm not sure what that entails donri
01:14:49 <NothingMan65> Or why it's more intuitive.
01:14:53 <NothingMan65> Or better
01:14:53 <donri> because then you can refactor it and move (f . g) to its own function etc
01:14:58 <mauke> it's not more intuitive
01:15:06 <mauke> and we're missing an intermediate step
01:15:09 <merijn> NothingMan65: (.) :: (b -> c) -> (a -> b) -> (a -> c)
01:15:18 <merijn> If you know enough of types to understand that
01:15:19 <mauke> consider this code: foo x = f (g x)
01:15:21 <merijn> If not, don't worry
01:15:30 <mauke> we can refactor to: foo x = (f . g) x
01:15:49 <XexonixXexillion> :t ((.) . (.)) abs (-)
01:15:50 <lambdabot> forall a. (Num a) => a -> a -> a
01:15:53 <mauke> now we can either replace the parens by $ or cancel x on both sides
01:15:59 <mauke> yielding: foo = f . g
01:16:19 <donri> @pl foo x = (f . g) x
01:16:20 <lambdabot> foo = f . g
01:16:35 <donri> @pl foo x = f (g x)
01:16:35 <lambdabot> foo = f . g
01:17:05 * frerich really appreciates mauke's ability to put himself in the position of somebody new to Haskell
01:17:18 <Jaak> :t let (.:) = (.).(.) in \f g h -> ((f . g) .: h, f .: (g .: h))
01:17:19 <lambdabot> forall a b a1 (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> (a1 -> a) -> f (f1 a1) -> (f (f1 b), f (f1 b))
01:17:22 <NothingMan65> I'm listening frerich
01:17:44 <srhb> ?type unfoldM
01:17:45 <lambdabot> Not in scope: `unfoldM'
01:17:48 <srhb> ?type unfoldrM
01:17:49 <lambdabot> Not in scope: `unfoldrM'
01:18:45 <mauke> @hoogle unfoldM
01:18:45 <lambdabot> No results found
01:18:48 <NothingMan65> mauke, could you give an example where this would be useful?
01:19:01 <NothingMan65> Or is it simply convention after the beginner stage?
01:19:03 <mauke> NothingMan65: well, it means you don't have to write x twice
01:19:25 <mauke> and it lets you talk about functions directly instead of their arguments
01:19:31 <donri> it can sometimes make the intent of code clearer (and sometimes less clear - use judgement)
01:19:37 <tikhonjelvis> Just making code easier to read is a significant benefit.
01:19:39 <mauke> i.e. you can say stuff like: foo = sqrt . abs
01:19:48 <merijn> NothingMan65: I simple example where this is useful is combined with map
01:19:59 <mauke> that says "foo is the composition of sqrt and abs"
01:20:07 <mauke> oh yeah
01:20:16 <mauke> map (sqrt . abs) [...]
01:20:18 <merijn> You can simply write "map (sqrt . abs)" to perform both functions on a list
01:20:40 <donri> as opposed to map (\x -> sqrt (abs x))
01:20:41 <NothingMan65> What happens if you use two functions which accept different types?
01:21:06 <donri> that works if the left function produces a value of the type the right function takes
01:21:10 <NothingMan65> Okay
01:21:11 <mauke> NothingMan65: irrelevant; but the second function has to return a type that is accepted by the first function
01:21:14 <merijn> NothingMan65: Type error, (.) only accepts functions if the output type of the first matches the input type of the first
01:21:18 <NothingMan65> So that's the crux.
01:21:22 <XexonixXexillion> > (show . abs) (-5)
01:21:24 <lambdabot>   "5"
01:21:39 <donri> @src (.)
01:21:40 <lambdabot> (f . g) x = f (g x)
01:21:40 <lambdabot> NB: In lambdabot,  (.) = fmap
01:21:48 <merijn> NothingMan65: Note that you can (again) leave the actual list out when you write "map (sqrt . abs)" and end up with a function that takes a list and returns a new list
01:23:17 <NothingMan65> > ( fromIntegral . floor (55/2) `mod` 4 )
01:23:18 <lambdabot>   No instances for (GHC.Real.Integral (f a), GHC.Real.Integral (f b))
01:23:19 <lambdabot>    aris...
01:23:46 <mauke> > floor (55/2) `mod` 4
01:23:47 <lambdabot>   3
01:23:59 <mauke> > (55 `div` 2) `mod` 4
01:24:00 <lambdabot>   3
01:24:03 <NothingMan65> Darnit, I was trying to use what I've just "learned"
01:24:12 <mauke> > (fromIntegral . floor) (55/2) `mod` 4
01:24:14 <lambdabot>   3
01:24:21 <mauke> but that's pointless, you're converting Integer -> Integer
01:24:35 <NothingMan65> (  floor . fromIntegral ) (55/2)  `mod` 4
01:24:58 <NothingMan65> Yeah, but often n00bs do pointless shit, eh?
01:25:22 <mauke> not just newbies! we have an entire bot plugin for pointless code :-)
01:25:34 <mauke> @pl foo x = sqrt (abs x)
01:25:34 <lambdabot> foo = sqrt . abs
01:25:38 <mauke> @help pl
01:25:39 <lambdabot> pointless <expr>. Play with pointfree code.
01:25:45 <NothingMan65> Hehe
01:25:51 <NothingMan65> Sweet
01:26:47 <mauke> @pl foo x = sin x / sqrt (abs x)
01:26:47 <lambdabot> foo = liftM2 (/) sin (sqrt . abs)
01:26:56 <merijn> It doesn't always make the code better, but it does help in some cases where you're overlooking the simplification :p
01:27:13 <mauke> basically it tries to rewrite functions into pipelines
01:27:21 <mauke> that don't mention their arguments directly
01:33:26 <elliott> @pl \a b -> a >>= \x -> ap a (liftM ((,) (Just x)) b)
01:33:27 <lambdabot> liftM2 (.) (>>=) ((. flip (fmap . (,) . Just)) . (.) . ap)
01:33:37 <elliott> as you can see, NothingMan65, @pl massively improves readability in all cases
01:33:49 <elliott> that one wasn't as bad as i was hoping for actually :(
01:33:58 <NothingMan65> Seriosly
01:34:28 <donri> @pl \a b c d e f g h = a b c d e f g h
01:34:28 <lambdabot> (line 1, column 18):
01:34:28 <lambdabot> unexpected "="
01:34:28 <lambdabot> expecting pattern or "->"
01:34:36 <donri> @pl \a b c d e f g h -> a b c d e f g h
01:34:36 <lambdabot> id
01:34:48 <XexonixXexillion> @pl \a b c d e f g h -> h g f e d c b a
01:34:51 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (
01:34:51 <lambdabot> flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))))
01:35:01 <donri> massive improvement
01:37:05 <elliott> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)
01:37:09 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
01:37:09 <lambdabot> const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .
01:37:09 <lambdabot> ) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .)
01:37:09 <lambdabot>  .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((
01:37:09 <lambdabot> flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .)
01:37:11 <lambdabot> [24 @more lines]
01:37:13 <lambdabot> optimization suspended, use @pl-resume to continue.
01:37:30 <elliott> (note: expression is not quite a fixed-point combinator)
01:39:09 <Jaak> doesn't type check in haskell?
01:39:35 <XexonixXexillion> @pl \ f -> (\ x -> f (x x)) (\x -> f (x x))
01:39:35 <lambdabot> ap (. join id) (. join id)
01:40:27 <XexonixXexillion> :t \ f -> (\ x -> f (x x)) (\x -> f (x x))
01:40:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
01:40:28 <lambdabot>     Probable cause: `x' is applied to too many arguments
01:40:28 <lambdabot>     In the first argument of `f', namely `(x x)'
01:43:10 <XexonixXexillion> @pl (\y f -> f (y f)) (\f n -> if n == 0 then 1 else n * (f (n-1)))
01:43:11 <lambdabot> ap id (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
01:43:30 <XexonixXexillion> > (\y f -> f (y f)) (\f n -> if n == 0 then 1 else n * (f (n-1))) 5
01:43:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> t
01:43:49 <XexonixXexillion> > ((\y f -> f (y f)) (\f n -> if n == 0 then 1 else n * (f (n-1)))) 5
01:43:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> t
01:44:36 <XexonixXexillion> ... I must be half asleep
01:45:05 <XexonixXexillion> @pl let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * (f (n-1))) 5
01:45:05 <lambdabot> fix (ap id) (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
01:45:14 <XexonixXexillion> > let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * (f (n-1))) 5
01:45:14 <lambdabot>   120
02:03:10 <frerich> At the risk of sounding grumpy (which I'm not): it's possible to use lambdabot's features (such as @pl) in a private /query as well. Just mentioning this given the number of people in this channel.
02:05:20 <XexonixXexillion> frerich: sorry
02:06:40 --- mode: ChanServ set +o mauke
02:06:40 --- mode: mauke set -b $a:ADildeaux
02:07:42 <frerich> XexonixXexillion : No worries, I personally like seeing people tinker with lambdabot (sometimes it's quite inspiring :-)). Just wanted to mention this, I like to use lambdabot in private to avoid embarrasing moments...
02:07:52 <ben> pl is even available as a stand-alone utility :) http://hackage.haskell.org/package/pointfree
02:08:40 --- mode: mauke set -o mauke
02:11:42 <dominikh> hey, I wrote this (primitive) reverse polish notation function but am not really happy with it, code-wise. especially line 16 seems bad to me. I'm happy for all suggestions as to how to improve it! -> https://gist.github.com/56dba0f0b343bf0ec21e
02:12:41 <elliott> dominikh: If you're going to use fromJust, might as well put it in operatorToFunc instead.
02:12:50 <frerich> dominikj: Instead of '(stack !! 1) (stack !! 0) : drop 2 stack' you could use pattern matching on the 'stack' argument.
02:12:53 <parcs`> :t let y f = (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
02:12:54 <lambdabot> forall a. (a -> a) -> a
02:13:06 <elliott> Also, (f x) y = f x y.
02:13:17 <parcs`> > let y f = (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (1:)
02:13:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:13:22 <frerich> dominikh: So isntead of 'process stack val@(op:_)' you could have 'process (x:y:xs) val@(op:_)'
02:13:52 <dominikh> elliott: but in line 14 I am checking if operatorToFunc returned Nothing
02:14:02 <elliott> Oh, wait, I see.
02:14:03 <elliott> Right.
02:14:50 <dominikh> frerich: that'll fail though if there is only one element on the stack, won't it? or will y be [] then?
02:15:15 <frerich> dominikj: Yes, but it will also fail right now if there's only one element on the stack. :-)
02:15:24 <elliott> dominikh: http://hpaste.org/56892
02:15:26 <frerich> Drat, I keep hitting j instead of h. Keyboard, behave!
02:16:09 <elliott> dominikh: That has the interesting side-effect that it'll try to read a function as a float if you don't give it enough arguments on the stack... but yours just failed with an indexing error, so whatever :P
02:16:18 * hackagebot bamstats 0.1 - A program to extract various information from BAM alignmnet files  http://hackage.haskell.org/package/bamstats-0.1 (KetilMalde)
02:16:22 <dominikh> frerich: I don't think so? we do start with an empty stack, after all, then add numbers, eventually apply an operator. the "otherwise" guard pushes the numbers and wouldn't work if "process" required at least 2 elements on the stack
02:16:36 <elliott> dominikh: Also, you don't usually want foldl. Although I think it's fine in this case.
02:17:05 <dominikh> ah, I see
02:17:38 <hpaste_> elliott annotated “RPN” with “RPN (annotation) -- now with error handling” at http://hpaste.org/56892#a56893
02:18:05 <c_wraith> @quote continuation
02:18:05 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
02:18:12 <dominikh> oh, didn't know you could have type declarations in where
02:18:23 <c_wraith> @quote stack_machine
02:18:23 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
02:18:23 <elliott> dominikh: Your code isn't that bad, really. Pattern matching over indexing functions and things like fromJust is the only thing you're missing.
02:18:41 <c_wraith> @quote stack.+continuation
02:18:41 <lambdabot> No quotes match. Sorry.
02:18:44 <c_wraith> hmm.
02:18:46 <elliott> Hum.
02:18:52 <elliott> dominikh: It doesn't type though.
02:18:53 <c_wraith> I can't remember the quote well enough
02:18:59 <elliott> operatorToFunc has to take a String instead.
02:19:06 <elliott> (and the ops table adjusted appropriately)
02:19:22 <elliott> Also, "head" is evil, but there's not really anything you can do to avoid it here.
02:19:33 <elliott> An explicit pattern-match would let you provide a nicer error message if the stack ends up empty, though.
02:19:38 <dominikh> evil because it fails on empty lists?
02:19:57 <frerich> dominikh: A more 'big picture' idea might be to change the program so that each character maps to a *function* which handles the stack. So it would be easier to have a 'sqrt' operator which actually just takes the topmost stack element and then pushes its square root.
02:20:25 <elliott> dominikh: Oh, and my code has a mistake :)
02:20:26 <elliott> And yes.
02:20:35 <elliott> Functions that can error out are, as a general rule, evil.
02:21:08 <elliott> fromJust is evil, head is evil, (!!) is evil, etc. They have their uses, sometimes, but 90% of the time they're misused.
02:22:16 <frerich> dominikh: I don't want to spoil the fun, so click this link on your own risk, but this particular problem (implementing a RPN solver in Haskell) was discussed quite extensively in the 'Learn You A Haskell' book (which I recommend very much!). You can find this at http://learnyouahaskell.com/functionally-solving-problems
02:22:17 <dominikh> at least the fromJust in my case cannot blow up, as far as I can tell ;)
02:22:37 <dominikh> frerich: hah, that's actually where I got that exercise from
02:22:38 <hpaste_> elliott annotated “RPN” with “RPN (annotation) -- better” at http://hpaste.org/56892#a56895
02:22:58 <dominikh> frerich: I just didn't like their solution too much
02:23:01 <hpaste_> elliott annotated “RPN” with “RPN (annotation) -- argh!” at http://hpaste.org/56892#a56896
02:23:17 <donri> can you set flags for dependencies in cabal?
02:23:26 <elliott__> dominikh: http://hpaste.org/56896
02:23:28 <elliott__> there :)
02:23:30 * elliott__ is having connection troubles
02:23:50 <elliott__> aaargh
02:23:53 <elliott__> s/[String]/String/
02:23:55 <elliott__> in the type of process
02:24:01 <dominikh> hah
02:24:01 * elliott__ is terrible at this
02:24:15 <merijn> dominikh: In most cases from maybe/fromMaybe are preferable to fromJust, though
02:24:20 <merijn> :t fromMaybe
02:24:21 <lambdabot> forall a. a -> Maybe a -> a
02:24:23 <elliott__> 02:22:17 <dominikh> at least the fromJust in my case cannot blow up, as far as I can tell ;)
02:24:24 <merijn> :t maybe
02:24:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:24:35 <elliott__> dominikh: yeah it can't
02:24:38 <elliott__> the read blows up instead :P
02:24:59 <elliott__> dominikh: generally you should be wary of using anything that separates your binding or choices from your extraction
02:25:13 <elliott__> like, isJust -> fromJust isn't a good idea, and getting a list and indexing on it isn't a good idea
02:25:23 <elliott__> it basically just boils down to using pattern matching whenever you can
02:26:14 <dominikh> I see
02:26:18 * hackagebot OSM 0.6.0 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.6.0 (TonyMorris)
02:26:21 * hackagebot OSM 0.6.1 - Parse OpenStreetMap files  http://hackage.haskell.org/package/OSM-0.6.1 (TonyMorris)
02:26:39 <dominikh> I'll have to refresh my memory on what <- means, though. Last time I saw it was in the I/O chapter
02:27:02 <merijn> dominikh: Do you know what >>= does?
02:27:05 <merijn> :t (>>=)
02:27:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:27:16 <frerich> dominikh: In LYAH, it's at the end (it's a thing which is applicable to all monads, not just IO)
02:27:17 <rtharper_> lol isJust, fromJust makes me cry
02:27:34 <rtharper_> if isJust x then ... (fromJust x) ... else ?
02:27:49 <dominikh> frerich: oh, monads. yeah, I haven't deal much (knowingly not at all) with them
02:27:52 <dominikh> *dealt
02:28:28 <merijn> dominikh: Read Learn You a Haskell, the explanation there is quite nice and without making things seem overly magic
02:28:30 <rtharper_> also why isn't listToMaybe called something like "headMaybe"
02:28:47 <elliott__> dominikh: it's not related to IO
02:28:54 <elliott__> merijn: it's not being used in a monadic context
02:28:58 <elliott__> it's just a pattern guard
02:29:03 <merijn> Ah
02:29:11 <elliott__> dominikh: basically | Just f <- ... just means "... matches the pattern (Just f)"
02:29:14 * merijn didn't look at the example :p
02:29:31 <elliott__> dominikh: so:
02:29:38 <elliott__> dominikh: foo x | Just blah <- f x = ...
02:29:40 <elliott__> is the same as:
02:29:44 <elliott__> foo x = case f x of Just blah -> ...
02:29:50 <elliott__> except that if the pattern-match fails, it goes on to the next clause
02:30:09 <elliott__> so in this case, it'll go down to the read case
02:30:25 <elliott__> and if the reads fails (due to not matching the pattern), it'll go down to the error case
02:31:20 * hackagebot fb 0.4.0.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.4.0.2 (FelipeLessa)
02:33:23 <dominikh> okay, thanks :)
02:54:29 <parcs`> rtharper_: if isJust x then fromJust x else fromNothing x :P
02:55:21 <Cale> rtharper_: isJust and fromJust aren't meant to be used together.
02:55:21 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
02:55:50 <ben> fromNothing :: Default a => Maybe a -> a?
02:56:30 <merijn> :t fromNothing
02:56:31 <lambdabot> Not in scope: `fromNothing'
02:56:34 <parcs`> fromNothing :: Maybe a -> a
02:56:53 <donri> haha
02:57:24 <donri> ex nihilo nihil fit
02:57:30 <merijn> > let fromNothing :: Maybe a -> a; fromNothing x = error in fromNothing Nothing
02:57:31 <lambdabot>   Couldn't match expected type `a'
02:57:31 <lambdabot>         against inferred type `[GHC.Types....
02:57:57 <merijn> > let fromNothing :: Maybe a -> a; fromNothing x = undefined in fromNothing Nothing
02:57:58 <lambdabot>   *Exception: Prelude.undefined
02:58:16 <donri> > fromJust Nothing
02:58:17 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:58:17 <parcs`> @djinn isTrue :: Bool -> Bool
02:58:18 <lambdabot> Cannot parse command
02:58:26 <parcs`> @free isTrue :: Bool -> Bool
02:58:26 <lambdabot> isTrue = isTrue
02:59:18 <parcs`> "Maybe.fromJust" -- isn't that error message outdated?
02:59:42 <donri> Maybe.
03:00:10 <merijn> *rimshot*
03:01:01 <elliott__> parcs`: Oh, it's nothing. It's just a minor mistake.
03:01:48 <donri> :)
03:02:10 <donri> It's an exception to the convention.
03:03:58 <elliott__> donri: I partially agree.
03:04:06 <elliott__> It's quite the failure.
03:04:46 <paolino> hello, I'm trying HDBC. Which is the right way to go from [SqlValue] to a single constructor datatype ?
03:06:18 <paolino> readFattura [n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14]  =  Fattura         (fromSql n1) (fromSql n2) (fromSql n3) (fromSql n4) (fromSql n5) .... ?
03:26:22 * hackagebot OpenCL 1.0.3.0 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.3.0 (LuisCabellos)
03:37:37 <mm_freak> is there a library for a Set-like data structure that allows intervals or other means to express subsets of continuous sets?
03:38:38 <ChristianS> hm, aren't sets unordered?
03:39:11 <mm_freak> ChristianS: Set is ordered
03:40:30 <Jafet> IntervalTree CReal?
03:41:00 <byorgey> mm_freak: http://hackage.haskell.org/package/splaytree ?
03:45:31 <mm_freak> byorgey: not sure…  i'm basically looking for IntervalSet similar to IntervalMap <http://hackage.haskell.org/package/IntervalMap>
03:46:38 <byorgey> mm_freak: the splaytree package has a "RangeSet" module which might work, though I don't know exactly what you're looking for
03:47:17 <mm_freak> byorgey: yeah, i looked into it, but apparently RangeSet is really just a single range, whereas IntervalMap allows disjoint subsets
03:47:39 <mm_freak> i guess i can just use IntervalMap Double () for now
03:48:01 <derpladee> hey where can i paste some code?
03:48:14 <mm_freak> @where hpaste
03:48:14 <lambdabot> http://hpaste.org/
03:48:19 <mm_freak> @ derpladee
03:48:47 <derpladee> that's not working
03:49:03 <derpladee> is it?
03:49:59 <mm_freak> uh
03:50:00 <mm_freak> indeed
03:50:05 <mm_freak> the domain name as expired
03:50:13 <mm_freak> derpladee: meanwhile use codepad.org
03:50:32 <mm_freak> that one supports haskell, too
03:50:46 <byorgey> mm_freak: no, RangeSet is not just a single range
03:51:09 <byorgey> mm_freak: it coalesces *overlapping* ranges into a single range, but you can have multiple disjoint ranges
03:52:59 <mm_freak> oh, i see
03:53:42 <elliott__> haha, hpaste.org just expired today?
03:54:03 <mm_freak> or yesterday, depending on where you are
03:54:34 <mm_freak> byorgey: the last thing i'd like, but for now i can live without that:  open ranges
03:55:07 <mm_freak> byorgey: do you think i can make splay trees with my own range type that allows open intervals?
03:55:30 <byorgey> mm_freak: probably, I don't know
03:55:54 <mm_freak> ok, thanks for your help
04:02:26 <mm_freak> hmm, i can't find a union operation in splaytree
04:02:43 <mm_freak> and the haddock documentation is poor
04:06:38 <elliott__> mm_freak: (><)?
04:07:33 <mm_freak> thanks
04:14:55 <danr> The data type data Nat = Succ !Nat | Zero cannot possibly be a CPO, right? Since there is no fix Succ value.
04:15:04 <mysticc> I have a datatype which has 3 constructors data X e = A e | B e | C e .. and I am writing a function as f (_ e) = do something ..( I have to otherwise write 3 times the same thing for each constructor) .  Why pattern matching does not occur on constructors or is there any other way ?..
04:15:52 <danr> mysticc: i would define it as a record
04:16:09 <danr> mysticc: data X e = A { unX :: e } | B { unX :: e } | ...
04:16:13 <wjt> mysticc: data X = A | B | C; data Y e = Y X e?
04:16:17 <danr> and then you can use unX, possibly with view patterns
04:16:26 <danr> or what wjt said :)
04:16:35 <danr> f (unX -> e) = ...
04:16:39 <danr> with view patterns
04:17:14 * frerich wonders why so many people go and model natural numbers in the type system
04:17:40 <mysticc> danr: What if I have data X e = E | A e | B e | C e
04:17:57 <merijn> frerich: Because it can be useful to have? :p
04:17:57 <danr> mysticc: then unX would give you a runtime error
04:18:09 <danr> frerich: natural numbers are very useful in the type system
04:18:22 <mysticc> danr: I want to write f E one time and f (_ e) for rest ..
04:18:40 <danr> but I just took Nat as an example above, feel free to think about it as data List a = Cons a !(List a) | Nil
04:18:55 <wjt> mysticc: data Y e = E | Y X e; data X as above; maybe?
04:19:10 <danr> mysticc: yes then you can do it with view patterns, f E = ...; f (unX -> e) = ...
04:19:27 <mysticc> wjt and danr thanks
04:20:03 <danr> but i think wjt's solution is better :)
04:23:00 <cobra-the-joker> Hey there every one ... for loops in haskell ?
04:23:12 <danr> I guess the partial order for data Nat = Succ !Nat | Zero is flat, so it is actually complete. Anyone disagree?
04:23:25 <mm_freak> cobra-the-joker: maps, folds, recursion, etc.
04:23:35 <mm_freak> > map (^2) [1..10]
04:23:36 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
04:23:40 <merijn> cobra-the-joker: They don't really exist, since they're almost never used. People usually use map, folds or explicit recursion
04:24:07 <mm_freak> cobra-the-joker: in the order of increasing genericity
04:24:22 <mysticc> wjt: Can you give example what will be the definition of f in the case data Y e = E | Y X e ...
04:24:41 <wjt> f E = ...; f (Y _ e) = ...
04:25:07 <mysticc> ohh thanks
04:25:36 <cobra-the-joker> mm_freak: map is fine ... but it takes a function with only one argument !! ... how can i use it on a multi argument function ?
04:25:45 <merijn> cobra-the-joker: Please mention if you have a specific problem where you're stuck, makes it easier to help
04:26:02 <merijn> cobra-the-joker: All haskell functions take one argument
04:26:10 <mm_freak> danr: well, you are replacing lazy infinite Nat by bottom
04:26:23 <mm_freak> of course the bottom doesn't go away that way…  haskell is not total
04:26:56 <cobra-the-joker> merijn: i want to recurse on a list but it has another arguemnt ... a number .. how can i ?
04:27:12 <merijn> cobra-the-joker: Do you want to use the same number for each list item?
04:27:15 <mm_freak> cobra-the-joker: folding is very application-specific…  this makes the fold application-aware to improve both performance and correctness, the latter being most significant
04:27:55 <merijn> cobra-the-joker: Maybe write a simple example of what you want to do in a language you already know? (python, ruby, C, Java, whatever)
04:28:04 <cobra-the-joker> merijn: ok
04:28:58 <deggis> ideas on writing Ord instance without writing all constructor members https://gist.github.com/1663080 ?
04:29:19 <danr> mm_freak: yes but there is no value Succ _|_, right?
04:29:22 <cobra-the-joker> merijn: http://pastebin.com/EC5FpAg3
04:29:25 <mauke> The paste EC5FpAg3 has been copied to http://hpaste.org/56897
04:29:30 <cobra-the-joker> merijn: this is what i want to do
04:29:31 <danr> mm_freak: then we shouldn't get any (strict) omega-chains
04:29:39 <Veinor> deggis: a `compare` b = comparing age a b
04:29:43 <mm_freak> danr: correct, Succ ⊥ = ⊥
04:29:44 <Veinor> or even more succintly
04:29:46 <Veinor> compare = comparing age
04:30:20 <merijn> Damn, wrong button >.>
04:30:34 <cobra-the-joker> merijn: i want to recurse on every element on the list  ... like pass the in showEmpty (head list) (arr)
04:30:53 <danr> mm_freak: yes then we get a flat order (like the primitive data types have)
04:31:12 <deggis> Veinor: there's two constructors in animal. i don't know how to declare both that way
04:32:05 <Veinor> deggis: ah
04:32:31 <mm_freak> danr: apparently yes
04:32:37 <Veinor> give me a sec to play around with some things, then
04:33:19 <wjt> deggis: does Cat {age = aa} `compare` Cat {age = bb} = compare aa bb; work?
04:33:35 <merijn> cobra-the-joker: I'm not entirely sure what the arguments to showEmpty are supposed to be?
04:33:48 <cobra-the-joker> merijn: http://pastebin.com/EC5FpAg3
04:33:48 <mauke> The paste EC5FpAg3 has been copied to http://hpaste.org/56897
04:34:00 <elliott__> wait, what?
04:34:02 <deggis> wjt: oh. it's possible to use record syntax in that way too :D let's see
04:34:03 <Veinor> wjt: oh, nice
04:34:05 <elliott__> does that script just make up urls? :P
04:34:05 <mm_freak> cobra-the-joker: could you state on a higher level what you want?
04:34:06 <Veinor> deggis: it works, do that
04:34:26 <elliott__> (the paste-copier)
04:34:30 <merijn> elliott__: mauke dislikes pastebin, so it automatically repastes to hpaste
04:34:34 <mm_freak> elliott__: no, hpaste.org has expired
04:34:38 <cobra-the-joker> mm_freak: i am making a minesweeper ... i want to get the adjacent and recurse on every one of them
04:34:44 <danr> mm_freak: ok great :)
04:34:48 <Veinor> elliott__: it uses the url from the pastebin
04:35:00 <danr> i was a bit afraid that strictness fields would make non complete partial orders
04:35:04 <danr> heh
04:35:10 <mm_freak> danr: let's say i'm unable to construct a counterexample =)
04:35:19 <merijn> cobra-the-joker: Yes, but what mm_freak means is that the code your pasted is a bit hard to follow for someone who has no clue what all the arguments and types are
04:35:20 <elliott__> merijn: mm_freak: Veinor: i know all these things :)
04:35:24 <elliott__> but hpaste expired and it still gave a link
04:35:34 <elliott__> so i'm wondering where it got the number on the end of the url from
04:35:35 <merijn> hpaste works for me...
04:35:40 <mauke> elliott__: what do you mean by "hpaste expired"?
04:35:41 <Veinor> wait, expired? what?
04:35:45 <elliott__> mauke: hpaste.org
04:35:48 <elliott__> godaddy "domain expired" pgae
04:35:50 <elliott__> *page
04:35:50 <mauke> elliott__: what about it?
04:35:51 <cobra-the-joker> merijn: sorry what do you want to know ... adj is a list
04:35:53 <mauke> elliott__: what?
04:35:54 <merijn> elliott__: Eh, what?
04:35:54 <Veinor> Expiration Date:22-Jan-2013 22:06:54 UTC
04:36:00 <elliott__> i'm not the only one seeing it
04:36:07 <mm_freak> cobra-the-joker: that gets us somewhere…  perhaps you want an array there
04:36:07 <merijn> elliott__: Someone is f'ing with your DNS
04:36:16 <elliott__> <mm_freak> uh  <mm_freak> indeed  <mm_freak> the domain name as expired
04:36:19 <ChristianS> looks like at has already been renowed, but it will probably take some time until that change becomes visible in DNS everywhere
04:36:19 <elliott__> <derpladee> that's not working
04:36:19 <deggis> wjt, Veinor: it seems that worked. huge thanks! (i hope i finally remember from now on that record syntax allows that too :D)
04:36:20 <elliott__> etc.
04:36:30 <elliott__> merijn: yes, it's a massive conspiracy :)
04:36:35 <mauke> elliott__: 109.74.197.248
04:36:46 <Veinor> it's expired from one of my machines but not another
04:36:47 <Veinor> weird
04:36:48 <ChristianS> (i only see the "NOTICE: This domain name expired on 01/22/2012 and is pending renewal or deletion" page at the moment, but i guess that will change again)
04:36:58 <cobra-the-joker> mm_freak: i want to put in HERE -> passing every element of the array 'adj' to showEmpty
04:36:59 <elliott__> oh, I bet hpaste was moved from godaddy to some other registrar or the like
04:37:04 <elliott__> and the godaddy domain expired before it fully propagated
04:37:06 <merijn> elliott__: By f'ing I mean "being incompetent"
04:37:09 <cobra-the-joker> HERE at the code
04:37:09 <ChristianS> damn dns -- still not instantaneous...
04:37:09 <mysticc>  http://paste.pocoo.org/show/539241/ .. Why it gives error fn does not have same no. of arguments .. Can't I have partial function applications like this ?
04:37:38 <mm_freak> cobra-the-joker: perhaps the explanation level is still too low
04:37:48 <mauke> mysticc: not in different equations for the same function, no
04:37:49 <elliott__> mysticc: you can't
04:38:02 <elliott__> http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
04:38:18 <mm_freak> cobra-the-joker: haskell beginners often express their problems in terms of their last programming language, which is almost always anything from unfortunate to useless in haskell
04:38:19 <merijn> cobra-the-joker: ok, so adj is a list (i.e. the arr argument to showEmpty) and you need to specify the xml and i arguments too?
04:39:23 <cobra-the-joker> merijn: i need to keep xml with me
04:39:33 <mm_freak> cobra-the-joker: i now have a minesweeper application in mind and my comonadically wired brain thinks of converting an array of bombs to an array of clue numbers =)
04:39:37 <merijn> cobra-the-joker: ok, so the xml from the parent
04:39:50 <cobra-the-joker> mm_freak: thats what i did
04:39:52 <merijn> cobra-the-joker: Where does the i come from?
04:40:03 <cobra-the-joker> mm_freak: arr is the array containing bombs and such
04:40:20 <cobra-the-joker> merijn: i is the index of the button
04:40:53 <merijn> cobra-the-joker: I mean, when you call showEmpty on each of the items in adj, what should i be?
04:40:57 <merijn> The same as in the parent?
04:41:36 <cobra-the-joker> merijn: it should be integer
04:41:46 <merijn> Coming from where? :)
04:41:59 <merijn> Length of the list? The parent function?
04:42:25 <merijn> Or do you just want to call showEmpty with the same arguments, just a different list?
04:42:52 <merijn> (In the latter case, the answer is easy. But I don't think your current code will typecheck)
04:45:27 <derpladee> hey if i want to write an application with a GUI, what would you recommend?
04:45:33 <cobra-the-joker> merijn: from the event of button press
04:45:36 <derpladee> it appears that qtHaskell is pretty good and cross platform and all
04:45:44 <derpladee> but wxHaskell seems like it is more used for some reason
04:45:55 <donri> no love for gtk2hs?
04:46:00 <Chaze> it there a way to see all class instances for a type?
04:46:40 <merijn> cobra-the-joker: If I followed it correctly you could just do "map (showEmpty xml i) adj", but with your current showEmpty implementation that will not typecheck
04:46:54 <donri> Chaze: :info
04:47:04 <Chaze> @info (*)
04:47:05 <lambdabot> (*)
04:47:11 <cobra-the-joker> merijn: ok will try
04:47:12 <Chaze> that was a lot of info
04:47:25 <donri> oh in lambdabot? @instances
04:47:37 <donri> not sure what type you think (*) is though
04:47:45 <merijn> cobra-the-joker: Since Haskell has partial application you can give a function less arguments than it needs and you will get back a new function that takes the missing arguments
04:47:54 <derpladee> i don't know, is gtk2hs good too?
04:48:01 <derpladee> i'm really at a loss here, i have no idea what to use
04:48:02 <Chaze> donri: well, a -> a -> a
04:48:04 <derpladee> they all seem alright
04:48:12 <Chaze> @instances (*)
04:48:13 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
04:48:21 <Chaze> @instances (a -> a -> a)
04:48:22 <lambdabot> Couldn't find class `(a -> a -> a)'. Try @instances-importing
04:48:27 <merijn> cobra-the-joker: "showEmpty x" returns a new function that takes two arguments, the i and arr values. "showEmpty x y" returns a function that takes one argument, the arr value
04:48:48 <cobra-the-joker> aha
04:48:51 <merijn> cobra-the-joker: map can use the results just as any other function
04:49:00 <cobra-the-joker> aha
04:49:23 <vhd> has hpaste been moved?
04:49:40 <merijn> vhd: DNS has moved, some entries haven't updated yet, apparently
04:50:15 <hpaste_> merijn pasted “hpaste DNS info” at http://hpaste.org/56898
04:50:24 <merijn> oh, doh
04:50:27 <merijn> >.>
04:50:30 <merijn> That was pointless
04:51:00 <merijn> http://dpaste.org/PriqI/
04:51:34 <merijn> You can set it in your hostfile or use the IP by hand until the update propagates, I guess
04:52:30 <merijn> cobra-the-joker: Learn You a Haskell has a simple explanation: http://www.learnyouahaskell.com/higher-order-functions
04:52:31 <vhd> http://pastebin.com/vQaTfB2t <-- code for insertion sort. How can I extend it so that I can use streams with it?
04:52:33 <mauke> The paste vQaTfB2t has been copied to http://hpaste.org/56899
04:52:46 <mm_freak> merijn: that was a very graphic instance of the chicken/egg problem =)
04:53:07 <merijn> mm_freak: Yeah, I hit paste and immediately thought "wow, that was dumb"
04:53:55 <mm_freak> vhd: streams as in infinite lists?
04:54:04 <vhd> yes, not the library.
04:54:18 <vhd> I thought it would have just worked, but seems like it does not.
04:54:20 <mm_freak> well, just use a type without the [] constructor
04:54:40 <mm_freak> it should work OOTB with infinite lists
04:54:44 <donri> huh, hpaste domain expired?
04:54:53 <elliott__> donri: <merijn> http://dpaste.org/PriqI/  <merijn> You can set it in your hostfile or use the IP by hand until the update propagates, I guess
04:54:59 <elliott__> yes for some people, no for others
04:55:02 <elliott__> seems it switched registrars
04:55:20 <vhd> nope, doing something like "take 10 $ insertSort [1..]" infinite loops
04:55:37 <mm_freak> vhd: ah, wait
04:55:45 <mm_freak> the insert functions works for infinite lists
04:55:51 <elliott__> @where+ hpaste-dns hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
04:55:52 <lambdabot> Done.
04:55:58 * elliott__ ultimate lazy
04:56:51 <vhd> hmm yeah I guess it would and the reason it does not work for insertSort is cos it does not use a ":" explicitly?
04:57:24 <mm_freak> vhd: i don't think you can have sorting for infinite lists
04:57:30 <mm_freak> but you can have sorted insert for infinite lists
04:57:31 <elliott__> you can't sort infinite lists, no :P
04:57:55 <mm_freak> vhd: yes, that's exactly the reason
04:57:58 <merijn> Sure you can, you just need infinite memory :)
04:58:16 <merijn> Also, infinite CPU time
04:58:18 <mm_freak> vhd: by induction you can see how the first element depends on where the last element ends up
04:58:23 <vhd> grr why would it be an excercise in Purely Functional Data Structures DX
04:58:49 <mm_freak> vhd: you can have a sorted infinite set with a lower bound
04:59:13 <mm_freak> but even that only converges in certain cases
04:59:27 <vhd> theoretically insertion sort should be able to work with an infinite list, as you only sort as you go along the list.
04:59:34 <mm_freak> if the lower bound is 1, then sort [1..] would converge, but sort [2..] would diverge
05:00:04 <mm_freak> vhd: how can it work?  consider this:  sort [-1, -2 ..]
05:00:22 <mm_freak> the first element of the output depends on the last element
05:00:52 <mm_freak> perhaps the exercise is less to write the sorting function, but more to see why it can't be written =)
05:00:53 <vhd> because (unless I misunderstand the sort) you walk the list placing x into the previously sorted list.
05:01:02 <vhd> only the previously sorted list need be finite
05:01:15 <mm_freak> nah, it's the other way around actually
05:01:18 <elliott__> insertion sort =/= sorted insertion
05:01:48 <mm_freak> the previously sorted list can be infinite…  the 'insert' function exposes proper guarded corecursion
05:02:30 <magicman> sort ([1..] ++ [0]), oy.
05:02:46 <elliott__> > sort ([1..] ++ [0]) :: [Word8]
05:02:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:02:51 <elliott__> What now, wise guy?!
05:03:03 <elliott__> Finitism cures all ails :)
05:03:22 <mm_freak> @undef
05:03:33 <mm_freak> ah, it's because of Word8 =)
05:03:40 <magicman> :P
05:03:44 <Jaak> > length ([1..] :: [Word8])
05:03:46 <lambdabot>   255
05:03:48 <merijn> Word8 is hardly infinite :p
05:04:08 <mm_freak> but the result is wrong
05:04:15 <merijn> Why?
05:04:17 <mm_freak> ah, no, it isn't
05:04:24 <mm_freak> it's just that [1..] isn't infinite =)
05:05:10 <mm_freak> > sort [ fromIntegral x :: Word8 | x <- [1..] ++ [0] ]
05:05:15 <vhd> hmm ok for an insertion sort with stream you would have to specify the bound then :|
05:05:20 <lambdabot>   mueval: ExitFailure 1
05:05:20 <lambdabot>  mueval: Prelude.undefined
05:05:29 <vhd> or rather that could be said for any sort then
05:05:36 <mm_freak> vhd: a bound won't suffice
05:05:54 <mm_freak> the example i just wrote wouldn't result in [0, 1 ..]
05:06:04 <mm_freak> it would result in an infinite stream of 0
05:06:44 <_Mikey> hey guys
05:06:57 <vhd> mm_freak, bound wont suffice? Well since the sort recurses till it gets to [] could you not replace that with a counter?
05:07:38 <merijn> vhd: At what value would that counter start?
05:08:10 <vhd> it would just count down to 0, starting at the front of the list.
05:08:18 <mm_freak> vhd: no, the problem is that once you've got the first 0, you can't assume there won't be another one
05:08:22 <vhd> at each recursion n-1
05:08:25 <merijn> vhd: Count down to 0 from which value?
05:08:59 <mm_freak> vhd: consider this list:  [0..] ++ [0]
05:09:05 <mm_freak> lower bound being 0
05:09:16 <jochem1> blah
05:09:17 <mm_freak> the correct answer is [0, 0, 1, 2, 3 …
05:09:37 <mm_freak> but to find the answer your sorting function needs to inspect the last element, which doesn't exist
05:10:06 <vhd> yes but what I am saying is by giving it a bound, that bound would be the last element.
05:10:38 <_Mikey> if I have a list of ints which is sometimes empty and I call head on it I should be able to pattern match out the cases where the list is empty right?
05:11:00 <mm_freak> _Mikey: no, head will crash your program for empty lists
05:11:09 <mm_freak> _Mikey: use pattern matching instead of 'head'
05:11:26 <_Mikey> ahh yea I see
05:11:34 <merijn> head is an abomination :(
05:11:34 <atomicity> hi
05:11:54 <_Mikey> so it is.
05:11:56 <Chaze> @help
05:11:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:12:02 <Chaze> @list
05:12:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:12:23 <atomicity> I'm new to haskell, I've read the Memoization article on the haskell wiki and I still can't figure out how to code this in a way that will be fast:
05:12:43 <niteria> @pl \x -> x + x
05:12:43 <lambdabot> join (+)
05:12:53 <Chaze> @pl \x -> (x,x)
05:12:54 <lambdabot> join (,)
05:13:14 <niteria> @pl \x -> x + 2 * x
05:13:14 <lambdabot> ap (+) (2 *)
05:13:51 <atomicity> f 1 _ = c; f _ 0 = d; f x y = f x (y-1) + f (x-1) (y-1);
05:14:32 <Botje> atomicity: that's from project euler, right?
05:14:50 <atomicity> Botje: no, that's just the general form of a specific function I need to write
05:14:56 <merijn> atomicity: Where do c and d come from? Or are they just arbitrary constants?
05:14:58 <niteria> > :t join
05:14:59 <lambdabot>   <no location info>: parse error on input `:'
05:15:11 <merijn> niteria: No > for colon commands
05:15:13 <merijn> :t join
05:15:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:15:21 <atomicity> merijn: arbitrary constants.
05:15:43 <niteria> this join was for (->) ?
05:15:59 <niteria> :t ap
05:16:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:16:01 <Botje> atomicity: by far the easiest is to use an array or a map
05:16:19 <atomicity> Botje: I'm asking about how to memoize this, there's a ton of crap I didn't write, but the recursion is of the above form.
05:16:46 <atomicity> Botje: ok...
05:18:05 <niteria> @pl \x -> x + 2 * x + x * x
05:18:05 <lambdabot> ap ((+) . ap (+) (2 *)) (join (*))
05:18:17 <dp_wiz> n00b question time! what is n(0) dynamic array object in haskell?
05:18:22 <atomicity> Botje: The only thing I'm not quite sure about is how to populate the array efficiently, could someone write an example or get me a link? I don't even know how to search for this on google.
05:18:24 <Chaze> @pl \ r -> k (f r) r
05:18:24 <lambdabot> k =<< f
05:18:41 <Botje> atomicity: you populate it with thunks and let your evaluation order sort it out.
05:18:57 <niteria> @pl \x -> x x x
05:18:58 <lambdabot> join (join id)
05:19:07 <Botje> hang on, i have a solution for that euler problem i mentioned
05:19:22 <atomicity> Botje: that sentence parses, but I have no idea what a thunk is :)
05:19:49 <Botje> a thunk is an expression that haven't been evaluated yet
05:19:54 <atomicity> oh, ok
05:20:48 <Botje> hpaste is being annoying again :/
05:21:42 <Botje> atomicity: http://pastie.org/3237079
05:21:49 <Botje> which is a solution to http://projecteuler.net/problem=15
05:22:22 <Botje> I create a 20x20 array and populate it with thunks that do the actual computation
05:22:59 <Botje> I then grab the element at (20,20), which starts calculating (19,20) + (20,19), which in turn calculate their neighbors and so on
05:23:49 <atomicity> Botje: ok, so now I know this does what I wanted in the first place
05:23:53 <atomicity> Botje: thanks a lot
05:24:00 <Botje> heh, oops :)
05:24:19 * byorgey loves DP in Haskell
05:24:20 <atomicity> Botje: (no sarcasm there)
05:24:34 <byorgey> you just define the array in terms of itself and the runtime works out what order to do things in! <3
05:25:05 * byorgey makes a note to show this to his Haskell class when talking about laziness
05:25:10 <atomicity> Botje: I'm having trouble understanding line 5 though
05:25:51 <Botje> okay
05:26:09 <vhd> mm_freak, merijn this is what I meant; http://pastebin.com/VJtrFJtH
05:26:12 <Botje> listArray takes a size parameter and a list of values to put in each element of the array
05:26:28 <Botje> this size parameter is something of the shape ((1,1),(20,20))
05:26:38 <atomicity> Botje: yeah, I got the size
05:26:52 <Botje> range turns this into a nice list of indicies [....,(3,4),(3,5),...)
05:26:54 <atomicity> Botje: the list explanation makes a lot of sense though
05:27:05 <atomicity> oh, nice :)
05:27:09 <byorgey> > range ((1,1),(3,3))
05:27:10 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:27:13 <Botje> and map (uncurry f) takes apart the tuple and feeds each part of the tuple to f
05:27:33 <Botje> which generates either a number or a thunk that depends on two other array elements
05:28:06 <atomicity> Botje: oh, so uncurry is the thing that I didn't know existed and that really solves the whole problem of memoizing multi-valued functions
05:28:09 <Chaze> @src liftM2
05:28:09 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:28:16 <byorgey> atomicity: no
05:28:20 <atomicity> Botje: thanks a lot, this really helped and now I understand :)
05:28:28 <Botje> you're welcome
05:28:37 <Botje> NOW GO FORTH AND DO SCIENCE!
05:28:39 <byorgey> atomicity: oh, maybe I see what you're saying, but it doesn't have anything to do with memoization per se
05:28:42 <Botje> or haskell, that's also fine :P
05:28:57 <byorgey> > uncurry (+) (2,3)
05:28:59 <lambdabot>   5
05:29:19 <byorgey> there's nothing magical about uncurry either, you could write it yourself quite easily
05:29:30 <atomicity> byorgey: yes, I know it doesn't, but that was the main problem I wasn't able to translate the examples on haskell wiki
05:29:42 <byorgey> atomicity: OK, fair enough.
05:29:47 <derpladee> hey guys, is there any huge reason to choose gtk2hs, qtHaskell, wxHaskell over one another? i want to make a GUI application but i just can't decide
05:30:14 <atomicity> byorgey: one could write it quite easily if one wasn't a complete n00b :)
05:30:37 <atomicity> :type uncurry
05:30:38 <byorgey> atomicity: hehe =)
05:30:47 <atomicity> > :type uncurry
05:30:48 <lambdabot>   <no location info>: parse error on input `:'
05:30:53 <byorgey> @type uncurry
05:30:54 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:30:58 <atomicity> thanks :)
05:31:02 <byorgey> atomicity: well, try writing it and let me know what you think
05:31:21 <Chaze> @pl \r -> (\x-> \ r2 -> (\y-> return (x y)) (m2 r2) r2) (m1 r) r
05:31:22 <lambdabot> join =<< (. m2) . (return .) . m1
05:31:28 <mmaruseacph2> derpladee: windows or unix?
05:31:39 <mmaruseacph2> i tend to use gtk2hs but only on linux
05:31:47 <atomicity> oh, so uncurry only works on pairs/
05:31:52 <mmaruseacph2> and i just stuck with it, didn't quite decide on what to use
05:32:07 <byorgey> getting gtk2hs to work on windows or OS X is currently something of a pain.  Not sure what the state of the other GUI frameworks is.
05:32:16 <derpladee> uh i kinda want it to be cross platform if possible
05:32:20 <byorgey> but gtk2hs does seem to be the most commonly used.
05:32:33 <byorgey> atomicity: ye
05:32:35 <byorgey> *yes
05:32:39 <atomicity> yeah, I guess you could then write uncurry f (a b) = f a b;
05:32:40 <mmaruseacph2> thus it is reasonable to think that almost all errors are caught
05:32:42 <derpladee> i don't care too much for OS X ;)
05:32:46 <Chaze> :k (->)
05:32:47 <lambdabot> ?? -> ? -> *
05:32:52 <byorgey> atomicity: right, except for the missing comma in the pair
05:32:59 <Chaze> can someone explain me that type constructor syntax?
05:33:05 <Chaze> what are ??, ? and * ?
05:33:07 <atomicity> byorgey: oh, yeah, that :)
05:33:15 <byorgey> atomicity: see, now that wasn't too hard, was it? =)
05:33:25 <mmaruseacph2> there was a post on ezyang's blog about ?? and ?
05:33:26 <mmaruseacph2> iirc
05:33:40 <byorgey> Chaze: those are special kinds used internally by GHC having something to do with unboxing or some crap like that.
05:33:48 <atomicity> byorgey: not really, no. Are pairs instances of comparable?
05:33:48 <byorgey> Chaze: you should just mentally translate both ?? and ?  to  *
05:33:57 <byorgey> > (2,3) < (5,1)
05:33:59 <lambdabot>   True
05:33:59 <Chaze> byorgey: ok
05:34:13 <Guest16113> ok
05:34:16 <atomicity> well that answeres that :)
05:37:05 <_Mikey> guys
05:37:11 <_Mikey> random question..
05:37:28 <Chaze> hhm, what is :: semantically?
05:37:30 <_Mikey> how would one run instructions on a remote machine with haske?
05:37:46 <_Mikey> haskell*
05:37:55 <elliott_> cloudhaskell?
05:38:14 <elliott_> https://github.com/jepst/CloudHaskell#readme
05:38:15 <quicksilver> ssh
05:38:27 <dominikh> elliott_: hm, I was looking over your RPN code again and one pattern match confuses me: [(val,"")] <- reads p  ← what exactly are we matching for here?
05:38:37 <flux> .28
05:39:08 <elliott_> dominikh: a list with one element, a tuple (val,"")
05:39:14 <elliott_> i.e. a tuple where the second element is the empty string
05:39:19 <elliott_> reads returns a list for historical reasons
05:39:26 <elliott_> think of it as matching "Just val" instead
05:39:43 <elliott_> ([] is used for failed parses)
05:39:51 <elliott_> the string is actually the data "left over" -- e.g. reads "1234abc" --> [(1234,"abc")]
05:39:58 <dominikh> oh, I guess I confused read and reads
05:40:11 <_Mikey> ok
05:40:20 <byorgey> Chaze: it means "has type" or "has kind", i.e.  "A :: B" means that A is classified by B
05:40:28 <byorgey> Chaze: not sure what you mean by "semantically"
05:40:47 <Chaze> well, is it like an assignment for types
05:40:57 <byorgey> Chaze: no
05:41:17 <Chaze> i was wondering if the type keyword doesn't, sort of, do the same thing
05:41:43 <Chaze> type (+) = (Num a) => a -> a -> a
05:41:49 <Chaze> would, sort of, make sense
05:42:08 <elliott_> for some values of "sort of" :)
05:42:10 <elliott_> and sense
05:42:23 <byorgey> Chaze: no, type A = B  means that  A  *is*  the type B.   A :: B  means that A *has* type B.
05:42:34 <Chaze> byorgey: right
05:42:40 <Chaze> now its totally obvious
05:50:24 <merijn> Chaze: As an example of the former would be "type String = [Char]"
05:50:52 <Chaze> merijn: yeah, i was aware of both language elements. i was just thinking aloud :)
05:51:36 <Chaze> embarrassingly confusing the definition of equivalence with type instanciation
05:57:00 <McManiaC> is it possible to build darcs with ghc 7.2.2 ?
05:57:21 <McManiaC> it seems to require unix < 2.5, which again depends on base < 4.4 or something
05:58:40 <mysticc> How to re export an imported module from another module ?
05:59:07 <McManiaC> mysticc: module Foo (module Bar) where import Bar
06:01:27 <mysticc> McManiaC: What if also want to export all the top level functions in Foo along with Bar and dont want to explicitly write each of them in export definition \
06:01:54 <McManiaC> dont think thats possible
06:05:42 <elliott_> mysticc: module Foo (module Foo, module Bar)
06:05:53 <Veinor> elliott_: ... does that work?
06:06:13 <elliott_> yes
06:06:17 <Veinor> cute
06:06:27 <McManiaC> nice, didnt know that :)
06:06:38 <elliott_> you'll probably end up spending more time explaining it to people than you'll save not writing out the exports, though
06:06:38 <Veinor> what if you want not to export mySecretFunction ?
06:06:55 <elliott_> Veinor: tough
06:07:08 <Veinor> i wonder if that's possible using TH
06:07:14 <elliott_> you'll either need another .Internal module and reexport it from another (importing it hiding ...) or write the export list like a normal person
06:07:15 <McManiaC> lol
06:07:19 <Veinor> (i know nothing about th)
06:07:28 <McManiaC> if you dont want to export everything, just write a export-list
06:07:30 <elliott_> i think so but you might have to wrap your entire module in a $( ... )
06:07:41 <elliott_> since the module declaration contains the whole file
06:07:47 <Veinor> yeah
06:25:51 <_Mikey> elliott_, I fixed it turned out I was just using the same function name too much everywhere.
06:25:57 <_Mikey> haskell compiled it
06:26:02 <_Mikey> but got confused at runtime.
06:39:12 <tkahn6> is there a way to encapsulate the idea of chaining a function without worrying about the arity? like if i have a function computeSomething :: Int -> Int -> Int and a function formatString :: Int -> String, is there a way to chain them such that formatString only acts on the input from computeSomthing after it has recieved all its arguments?
06:39:50 <dibblego> tkahn6: you might be looking for (<*>)
06:39:54 <shachaf> I think Oleg did something along those lines.
06:40:02 <dibblego> @google Applicative Programming With Effects
06:40:05 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
06:40:05 <lambdabot> Title: Applicative Programming with Effects
06:40:06 <shachaf> But you shouldn't actually use that.
06:40:26 <Jaak> you can define new combinators
06:40:27 <shachaf> But the answer is generally: No, "all its arguments" isn't really a thing that makes sense.
06:41:06 <merijn> shachaf: Well, it can be useful when creating frameworks
06:41:23 <shachaf> merijn: ?
06:41:24 <quicksilver> merijn. No. It might sound useful but it actually doesn't make sense.
06:41:30 <Jaak> > let (.:) = (.).(.) in (abs .: (+)) (-1) (-2) -- but i think not for generic case tho
06:41:32 <lambdabot>   3
06:41:38 <quicksilver> trying to write code like this is evil and will, ultimately, cause the death of kitten.
06:41:42 <quicksilver> s.
06:42:12 <shachaf> quicksilver speaks the truth.
06:42:19 <shachaf> You wouldn't want to cause the death of a kitten, would you?
06:42:51 <merijn> shachaf: I started to design a evolutionary computing framework in haskell a while back. And there you end up specifying a function that creates new individuals by combining existing ones. You'd want to provide a function that selects 1 individual from the population and a function that takes N individuals to produce a new one, then call the first function N times to get the relevant arguments
06:43:59 <shachaf> merijn: I'm not sure this is relevant to tkahn6's problem. :-)
06:43:59 <tkahn6> after giving this a little more thought this doesn't make much sense for composing more than 2 functions
06:44:06 <tkahn6> thanks all
06:44:07 <tkahn6> lol
06:44:33 <merijn> shachaf: It isn't, but you said there was no real usecase for it :p
06:44:39 <merijn> shachaf: Just providing a counter point :p
06:44:50 <shachaf> merijn: Oh, well, "the number of arguments a function have" is still not really a sensible thing to talk about.
06:45:15 <shachaf> And not only because I forgot how to English just then.
06:45:44 <dibblego> merijn: what was said was: "all its arguments" isn't really a thing that makes sense.
06:45:49 <dibblego> this is a true statement
06:46:41 <merijn> dibblego: Only because I don't have dependent types and just can't make the number of arguments part of the typechecking :(
06:46:45 <bertolo> how can i make replicate fuction using compreension
06:46:58 <bertolo> replic :: [a] -> Int -> [a]
06:47:14 <bertolo> replic x a = [ y | y<-x
06:47:15 <bertolo> :S
06:47:17 <bertolo> dont know
06:47:33 <dibblego> bertolo: are you sure that's the correct type?
06:47:38 <Jaak> > [1 .. 10]
06:47:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:48:05 <shachaf> bertolo: Why would you make it using compreension?
06:48:37 <bertolo> just to learn
06:48:41 <Jaak> > [() | _ <- [1..10]]
06:48:42 <bertolo> need to pratice compreension
06:48:43 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
06:48:55 <bertolo> omg
06:48:58 <bertolo> nice tip
06:49:09 <merijn> > replicate ()
06:49:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:49:11 <lambdabot>         against inferred type ...
06:49:16 <merijn> oh, duh
06:49:19 <merijn> > replicate 10 ()
06:49:20 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
06:49:36 <shachaf> merijn: It works in, like, Agda, man.
06:49:48 <merijn> shachaf: Exactly! :p
06:51:05 <bertolo> how can i make replicate using compreension?
06:51:15 <elliott_> bertolo: What are you trying to do?
06:51:20 <quicksilver> I think we just answered that bertolo
06:51:26 <bertolo> i cant make it
06:51:29 <quicksilver> if you didn't get close enough from Jaak's suggestion
06:51:31 <bertolo> cant figure out
06:51:35 <quicksilver> then you need to think of a better question
06:51:37 <bertolo> i do see
06:51:46 <quicksilver> because at the moment it sonds like "I can't do my homework, will IRC do it for me?"
06:51:47 <bertolo> a way to do it using its suggestion, but cant implement :S
06:51:56 <bertolo> pffff you and homework fears
06:52:01 <bertolo> im studying for exam
06:52:13 <elliott_> We don't like doing volunteer work for someone who won't put any in themself.
06:52:18 <bertolo> found this exercise in the book
06:52:25 <quicksilver> Jaak has actually shown you how to do it.
06:52:34 <quicksilver> If you can't make the leap from Jaak's specific replicate to a general one
06:52:41 <quicksilver> then you need to explain *why* you can't make that leap.
06:52:42 <bertolo> il try brb
06:52:46 <niteria> > let repl n a = [a | _ <- [1..n]] in repl 10 ()
06:52:47 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
06:52:52 <bertolo> i why let?
06:52:59 <bertolo> sec google
06:53:20 <quicksilver> or just wait for someone else to answer it I guess.
06:53:29 <quicksilver> I just hope that exact question in your exam, you'll be fine.
06:54:09 <bertolo> ah btw, i cant use replicate while doing it with compreension
06:54:30 <Veinor> aw damn, there goes my idea
06:54:41 <Veinor> > let repl n x = head $ [repl n x | _ <- [1]]
06:54:42 <lambdabot>   not an expression: `let repl n x = head $ [repl n x | _ <- [1]]'
06:54:45 <Veinor> > let repl n x = head $ [repl n x | _ <- [1]] in repl 10 ()
06:54:49 <lambdabot>   mueval-core: Time limit exceeded
06:54:53 <Veinor> > let repl n x = head $ [replicate n x | _ <- [1]] in repl 10 ()
06:54:55 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
06:54:56 <elliott_> bertolo: This really isn't the place to just get handed solutions. If you can't understand one that's been presented so far, tell us what part of it you don't understand, and we can help you.
06:55:19 <bertolo> i need someway to recurse inside compreension generator
06:55:20 <bertolo> i guess
06:55:21 <elliott_> Just repeating your question until someone gives you the answer directly isn't going to help.
06:55:41 <frerich> bertolo: Did you use a list comprehension before, e.g. do you know how they work in principle?
06:55:58 <bertolo> yes i do
06:56:27 <bertolo> func x = [ y | y<-x, even y]
06:56:28 <frerich> bertolo: Excellent! So, as a little brain teaser, how would a list comprehension works which takes each number from 1 to 10 and then yields each number multiplied by two?
06:56:37 <bertolo> ok sec
06:57:11 <bertolo> [ y*2 | y<-[1..10]]
06:57:15 <bertolo> right?
06:57:19 <frerich> bertolo: Looks good!
06:57:23 <bertolo> thanks
06:57:42 <frerich> bertolo: Now, if you don't want each number multiplied by two, but just each number directly (without modifying it in any way), how would that look like?
06:57:51 <frerich> I.e. The list of 1 to 10 should become... the list of 1 to 10
06:58:00 <bertolo> hmmm
06:58:11 <bertolo> [ y | y<-[1..10]]
06:58:15 <bertolo> not sure if i understood
06:58:20 <elliott_> that's correct
06:58:21 <frerich> bertolo: That's exactly it
06:58:27 <elliott_> frerich: that's not replicate, though :P
06:58:30 <bertolo> yes
06:58:34 <elliott_> oh, I guess that's not what "it" meant
06:58:41 <frerich> bertolo: Now, if you don't want each number out of the list, but you want the same number every time. Say, '7'. How would that look like?
06:58:41 <bertolo> anyone has graham hutton book?
06:58:55 <frerich> bertolo: So that 1 to 10 gets translated to a list of ten times '7'
06:59:09 <bertolo> [7 | y<-[1..10]]
06:59:18 <frerich> bertolo: Right!
06:59:18 <bertolo> hmm i start to see your point
06:59:22 <bertolo> but cant leap
06:59:24 <bertolo> lol
06:59:25 <bertolo> too dumb
06:59:42 <elliott_> You've almost written it.
06:59:42 <frerich> bertolo: So, the '10' is the number of times you want to repeat the value, and the '7' is what you want to repeat, right?
06:59:46 <_Mikey> hi guys
06:59:46 <bertolo> as a disclaimer :  graham hutton page 46 exercise 2
06:59:48 <Scriptor> there's also the repeat function :)
06:59:53 <_Mikey> I can't get onto hpaste ;/
06:59:55 <bertolo> yes
06:59:58 <_Mikey> getAntFromNode graphT nd = (ant,nd,adjList)
06:59:58 <_Mikey>                         where (Just ant,nd,adjList) = sndTrip graphT $ (nd-1) -- node-1 = Vertex
06:59:58 <elliott_> @where hpaste-dns
06:59:58 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
07:00:02 <elliott_> _Mikey: ^
07:00:03 <merijn> _Mikey:  ^^
07:00:08 <_Mikey> ohh
07:00:09 <elliott_> _Mikey: ^^^
07:00:14 <Veinor> _Mikey: v
07:00:17 <Veinor> _Mikey: ^
07:00:18 <elliott_> _Mikey: <
07:00:29 <bertolo> frerich,
07:00:29 <frerich> bertolo: Ok, so you have a list comprehension which repeats '7' ten times. Now, if you want a list comprehension which repeats '7' 'n' times. Hoqw would that look?
07:00:31 <bertolo> got it i think
07:00:39 <bertolo> thanks give me a few mins to try
07:00:46 * frerich apologizes to the #haskell audience for doing this in public, just tell me to go into a /query if it's annoying
07:00:54 <elliott_> frerich: nah, it's fine
07:01:08 <frerich> I'm exercising the socratic method :-)
07:01:11 <_Mikey> http://dpaste.org/VQO1W/
07:01:12 <_Mikey> :D
07:01:19 <elliott_> I'd much rather see good teaching like this than just throwing solutions at people :)
07:01:25 <_Mikey> my code just hangs here
07:01:35 <_Mikey> am I pattern matching out right?
07:02:55 <bertolo> frerich, replic (x:xs) b = [ x | y <-  [1..b]]  ,
07:03:04 <bertolo> i guess this is very wrong
07:03:07 <bertolo> :S
07:03:13 <frerich> bertolo: It's pretty close!
07:03:15 <elliott_> @type replicate
07:03:19 <lambdabot> forall a. Int -> a -> [a]
07:03:20 <bertolo> ok let me try again
07:03:27 <elliott_> bertolo: hint: the solution won't involve :
07:03:37 <elliott_> because you don't take any list as a parameter
07:04:05 <bertolo> dont understand what you mean elliott_
07:04:20 <elliott_> Well, (x:xs) matches a list.
07:04:25 <elliott_> Where the first element is x, and the second element is xs.
07:04:35 <bertolo> replic x b = [ z | y<-[1..b], z<-x]
07:04:37 <elliott_> If the argument isn't meant to be a list, then (x:xs) won't work to match it.
07:04:46 <elliott_> bertolo: very close
07:04:50 <bertolo> hmmm
07:04:54 <bertolo> y i saw that mistake also
07:05:02 <elliott_> bertolo: but in z<-x, x has to be a list too :)
07:05:10 <bertolo> ah ok
07:05:12 <bertolo> so its solved
07:05:14 <elliott_> nope
07:05:19 <elliott_> bertolo: hint: what should (replic 7 b) look like?
07:05:23 <bertolo> replic :: [a] -> Int -> [a]
07:05:26 <elliott_> oh
07:05:32 <elliott_> that's a different replicate to Haskell's :P
07:05:38 <bertolo> hmmm
07:05:41 <elliott_> frerich: whoops
07:05:47 <elliott_> bertolo: haskell's replicate is Int -> a -> [a]
07:06:01 <bertolo> oh
07:06:03 <bertolo> you are right
07:06:17 <bertolo> let me think a bit more lol ( STEAM ENGINE) :D
07:08:13 <_Mikey> fixed it again ... I'm making myself feel stupid.
07:09:01 <bertolo> replic a b = [ z | y<-[1..b], z<-a]
07:09:07 <bertolo> got it? o_O
07:09:10 <elliott_> veeeery close
07:09:13 <elliott_> again, a isn't a list :)
07:09:22 <elliott_> it's the value you're trying to replicate, right?
07:09:23 <bertolo> true
07:09:24 <elliott_> like 7
07:09:28 <parcs`> what is the most elegant solution to compute the permutations of a list?
07:09:34 <bertolo> i want to replicate  a
07:09:37 <elliott_> > permutations [1,2,3]
07:09:38 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
07:09:41 <elliott_> bertolo: right! what did you do to replicate 7?
07:09:43 <Veinor> @src permutations
07:09:44 <lambdabot> Source not found. :(
07:09:44 <koeien> @src permutations
07:09:45 <lambdabot> Source not found. Just try something else.
07:09:47 <elliott_> you did: [7 | y<-[1..10]]
07:09:50 <bertolo> yes
07:09:50 <parcs`> elliott_: :P
07:09:52 <bertolo> omg
07:09:53 <bertolo> cant be
07:09:58 <bertolo> 1!!!!!
07:09:59 <parcs`> other than using a predeined permutations function
07:10:01 <bertolo> ARRRRG
07:10:11 * Clint chuckles.
07:10:17 <elliott_> bertolo: i'm confused now :P
07:10:32 <elliott_> parcs`: something with the list monad perhaps?
07:10:43 <bertolo> replic  a b = [ a | y<-[1..b]]
07:10:43 <bertolo> ?
07:10:48 <elliott_> yep!
07:10:50 <bertolo> lol
07:10:51 <elliott_> one teeny last thing
07:10:53 <bertolo> fuck you :D
07:10:54 <Veinor> @type replicate
07:10:55 <lambdabot> forall a. Int -> a -> [a]
07:10:56 <elliott_> a and b should be the other way around, to match the replicate type
07:10:56 <parcs`> elliott_: yeah i came up with something but it requires Eq
07:11:22 <koeien> parcs`: search haskell-cafe, this has come up a gazillion times
07:11:36 <Veinor> or if you want to cheat
07:11:38 <parcs`> > let permutations [] = [[]]; permutations xs = do { a <- xs; as <- permutations (delete a xs); return (a:as) } in permutations [1..3]
07:11:39 <Veinor> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#permutations
07:11:39 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
07:11:43 <bertolo> thanks elliott_  frerich
07:11:48 <elliott_> bertolo: np :)
07:11:53 <bertolo> so simple omg
07:11:55 <elliott_> Veinor: that one's gross
07:12:05 <elliott_> > replicateM 3 [1..3]
07:12:06 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
07:12:12 <elliott_> hmm...
07:12:16 <parcs`> Veinor: that is not elegant at all :P
07:12:20 <koeien> those are all the 3-sets
07:12:29 <ezyang> I wonder if IO (IO a) is isomorphic to IO a
07:12:43 <shachaf> ezyang: In what sense?
07:12:46 <elliott_> ezyang: I'm not sure that question is even well-defined.
07:12:46 <shachaf> It's a very different type.
07:13:00 <elliott_> How do you define equivalence for IO actions like that?
07:13:13 <elliott_> I mean, there are things you can do with IO (IO a) that you can't do with IO a.
07:13:15 <merijn> ezyang: Don't think so
07:13:22 <elliott_> do { print 42; return getLine }
07:13:29 <ezyang> OK, the follow up question is, is "IO (IO a)" a monad?
07:13:36 <elliott_> Yes.
07:13:49 <ezyang> Is it at all interesting?
07:13:51 <merijn> ezyang: Example, using an IO action to dynamically pick an IO
07:14:01 <elliott_> Yeah, they're not isomorphic: do { print 42; return (() <$ getLine) } vs. do { print 42; getLine; return (return ()) }
07:14:20 <byorgey> m (m a) is always a monad whenever m is.
07:14:21 <elliott_> ezyang: I think if you just have IO (IO a) as a monad and the standard IO operations lifted to it, it's identical to IO.
07:14:28 <shachaf> spawn :: IO a -> IO (IO a)
07:14:30 <byorgey> well, m . m
07:14:32 <frerich> bertolo : Glad to see you worked it out
07:14:39 <merijn> The problem is that IO only has operational semantics
07:15:28 <ezyang> elliott_: Right, so now I'm wondering if there's another way of doing it.
07:15:31 <merijn> So it's impossible to define equivalence between any non-trivial IO actions
07:15:44 <elliott_> ezyang: Another way of defining the monad itself?
07:15:46 <merijn> Maybe even between trivial IO actions, just hedging my statements
07:15:51 <elliott_> Or another way of lifting the existing IO operations?
07:15:58 <ezyang> We can do the stupid way: f1 and f2 are equivalent if main = f1 and main = f2 have the same "effect"
07:16:03 <elliott_> Oh.
07:16:06 <elliott_> Another way of doing the isomorphism thing.
07:16:09 <byorgey> merijn: you could define an observational/behavioral equivalence based on the operational semantics
07:16:19 <elliott_> ezyang: That makes IO () and IO Int isomorphic.
07:16:20 <ezyang> It isn't pleasant to reason with, but "works"
07:16:27 <merijn> ezyang: Yes, but then you need a formal definition of effect and equivalence of those :p
07:16:32 <elliott_> main discards its result, so you can prove (IO a) = (IO b).
07:16:42 <ezyang> Right, it isn't modular
07:16:46 <elliott_> (OK, the magic RTS in the sky discards main's result.)
07:17:08 <merijn> byorgey: Sure, but that makes it impossible to find proofs that IO x = IO y except through exhaustive search :p
07:17:39 <byorgey> merijn: what?
07:17:55 <ezyang> This question stemmed from me wanting to write, "MonadIO is a convenience because IO can only ever be at the base of a monad stack." And then I thought, wait, why can't I have IOT?
07:18:10 <elliott_> ezyang: Because IOT (Cont r).
07:18:45 <maurer> Anyone know what the normal turnaround time is on getting a hackage account? It's not urgent, but I'm curious b/c it's been a couple days
07:18:50 * elliott_ has tried to implement IOT with unsafePerformIO before, but it just ends up being a really weird way of writing unsafePerformIO.
07:18:53 <merijn> byorgey: Ok, that line may not have been as logical as it was in my head. Without a model of IO, how do you define observational equivalence unless you just run it and see if the same happens (and that could still be coincidence)
07:19:00 <byorgey> maurer: several days
07:19:16 <elliott_> maurer: I got mine in 5 minutes.
07:19:33 * elliott_ 's experience may not be typical.
07:19:43 <byorgey> merijn: if you've defined equivalence behaviorally, then there's no "coincidence" -- either two actions produce the same effects, in which case they are equivalent, or they don't.
07:19:49 <parcs`> maurer: 24 hours
07:19:59 <parcs`> it depends i guess
07:20:15 <ezyang> IO ((a -> r) -> r) versus ((IO a) -> r) -> r?
07:20:29 <byorgey> merijn: but of course you would need a formal model of the sorts of effects that are possible
07:20:34 <maurer> Hm, OK. I guess I'll reping if I haven't gotten a response by today.
07:20:36 <merijn> byorgey: Program that always prints 42 and a program that reads dev/random and prints whatever it reads. The second can still by coincidence produce the same effect as the former
07:20:51 <ezyang> merijn: Right, so you have to appeal to the operational semantics
07:20:52 <merijn> byorgey: My entire point was that such a formal model is not possible for IO
07:21:12 <merijn> Well, it might be
07:21:16 <byorgey> merijn: there are techniques for doing such proofs such as bisimulation
07:21:16 <elliott_> /dev/random is not really part of IO.
07:21:20 <merijn> But it'll be painful and unwieldy
07:21:23 <elliott_> It's part of the operating system's semantics.
07:21:34 <elliott_> You can easily run IO on an OS without any such pesky things.
07:21:39 <byorgey> merijn: I don't see why.
07:21:41 <merijn> elliott_: I can do it using IO, so any model of IO would need to account for that sorta thing
07:22:05 <elliott_> merijn: Where in the Report does it guarantee access to a device file offering unlimited random bits?
07:22:11 <merijn> byorgey: How would you model it then? Only thing I can think of is a sort of stochastic approach of what kind of input is possible?
07:22:16 <elliott_> You can certainly write non-portable programs that might access such a device if given one.
07:22:22 <elliott_> That doesn't mean they will be.
07:22:24 <byorgey> merijn: not stochastic. just nondeterministic.
07:22:41 <byorgey> merijn: people make nondeterministic semantics and prove things about them all the time.
07:23:09 <merijn> elliott_: You're nitpicking some uninteresting detail of an example I mentioned to illustrate my point
07:23:27 <ezyang> Actually, I can write something for (IO a -> r) -> r as long as I have a restriction on r
07:23:31 <elliott_> merijn: It's not nitpicking -- you're saying there is no way to give IO a deterministic semantics.
07:23:37 <elliott_> That's not true at all.
07:23:57 <imc> mm
07:24:01 <imc> weird scalac output
07:24:05 <ezyang> so, if my monad was (forall r. (IO a -> r) -> r) I could do it...
07:24:11 <byorgey> there are many different possible semantics I could imagine for IO.  All of them are probably approximations to varying extents.  But that doesn't make them not useful.
07:24:28 <imc> uhmm wrong channell too
07:24:58 <elliott_> IO has the problem that it can see beyond the semantics of pure code (observable sharing and whatnot).
07:25:23 <merijn> elliott_: Multiple functions stored in a map based on a string. Read input, pick function based on input. How do you model this deterministically?
07:26:33 <merijn> Without non-determinism the fundamental problem with IO in a pure language disappears...
07:26:44 <elliott_> merijn: The semantics of IO include input, of course.
07:27:04 <elliott_> Semantics =/= giving a single defined program trace to an IO computation.
07:27:30 <merijn> I don't get your point?
07:27:48 <derpladee> hey i'm trying to install qtHaskell and i've followed the guide on the website but ghc-pkg still doesn't list qt as a package
07:27:52 <derpladee> and i can't compile
07:27:56 <derpladee> does anybody know what i did wrong?
07:28:02 <elliott_> merijn: I don't get your point, either. :P
07:28:21 <elliott_> I don't see how the fact that IO programs have an I part makes it impossible to give IO a deterministic semantics.
07:28:28 <merijn> elliott_: My point is that the actual input you receive is non-deterministic and thus any model of IO has to be as well
07:28:55 <merijn> The only way to be deterministic in the presence of different inputs is to ignore the inputs...
07:28:59 <quicksilver> that is not true merijn.
07:29:04 <merijn> Which is certainly a possible model for IO, but a bit useless...
07:29:06 <elliott_> That's a weird view.
07:29:11 <quicksilver> that's not what non-deterministic means.
07:29:12 <elliott_> merijn: Is there a deterministic semantics of the lambda calculus?
07:29:14 <derpladee> i still get "cannot satisfy: -package qt"
07:29:14 <elliott_> (\x.x)
07:29:20 <elliott_> That receives input and can vary its behaviour based on its input.
07:29:26 <atomicity> I think one side of this discussion has a different definition of 'deterministic'
07:29:29 <quicksilver> if your model of IO had behaviour being a function of its inputs
07:29:32 <elliott_> That input is nondeterministic, i.e. not known just from the definition itself.
07:29:34 <quicksilver> then that would be 'deterministic'.
07:29:37 <elliott_> So the lambda calculus must be nondeterministic.
07:29:49 <quicksilver> however, there is nondeterminism in IO
07:29:54 <quicksilver> it's just not coming from where you're looking for it :)
07:29:56 <merijn> quicksilver: Agreed, but then how would you implement readLine?
07:30:02 <quicksilver> I don't have to implement it.
07:30:06 <quicksilver> I have to give it a semantics, that's all.
07:30:20 <quicksilver> you can have a semantics about functions from streams to streams, or whatever
07:30:25 <elliott_> One of the real parts of nondeterminism in IO is asynchronous exceptions.
07:30:35 <quicksilver> formal semantics for systems which do simple text-IO only are fine
07:30:43 <quicksilver> and have certainly been written down for some systems.
07:30:43 <merijn> quicksilver: Agreed
07:31:06 <quicksilver> even non-determinism is not a barrier to a formal semantics.
07:31:19 <quicksilver> you just have (some variant of) a set of possible results.
07:31:36 <merijn> I wish I paid more attention last time I had this discussion >.>
07:31:36 <atomicity> (see the paper for Fx)
07:31:54 <atomicity> formal semantics for a functional, effects based language :)
07:32:02 <merijn> Because I was arguing the opposite side that time and got convinced to this side. But I no longer remember the entire argument that lead to that >.>
07:32:13 <elliott_> haha
07:32:54 <atomicity> non-determinism becomes a problem when a subset of the language no longer satisfies the diamond lemma
07:33:09 <merijn> I feel I got sidetracked from the original discussion anyway
07:33:13 <atomicity> as for instance in pi calculus
07:34:10 <merijn> Because that was whether IO (IO a) and IO a were equivalent or not. And I was right at the start, so somewhere along the path to here I either got confused and was basing my correctness on wrong axioms OR I got confused about what we were arguing :p
07:34:15 <ezyang> is hpaste working?
07:34:20 <merijn> @where hpaste-dns
07:34:21 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
07:34:50 <ezyang> here are three implementations of bind for IO (IO a): http://pastebin.com/pQZTmrXA
07:35:20 <quicksilver> IO (IO a) contains "more information"
07:35:26 <quicksilver> because it stages the computation into two parts
07:35:32 <ezyang> yeah
07:35:39 <quicksilver> if you discard that information by "promising" you'll always run it in one go
07:35:43 <quicksilver> then it is isomorphic to IO a
07:35:53 <ezyang> So the second implementation is promising all of the action happens in the inner IO
07:35:56 <quicksilver> in other words if you always join it, then you recover IO a
07:35:58 <ezyang> The third is promising it happens in the outer
07:36:06 <ezyang> and the first preserves staging
07:36:26 <ezyang> I think...
07:36:43 <atomicity> simple question: I have a Data.Array, I need to print it in such a way that gplot will get it (so, just the values, one value per line). I'm very new to haskell and haven't worked with strings at all yet. Halp please?!
07:37:02 <koeien> what is the type of your array?
07:37:23 <atomicity> Floating values, integer indices.
07:37:28 <Botje> atomicity: mapM print (elems arr)
07:37:40 <Botje> mapM_ even
07:37:46 <koeien> probably  putStrLn . unlines . map show . elems
07:38:14 <ezyang> No, that is not true.
07:38:20 <Ngevd> Hello
07:38:24 <koeien> Ngevd: hi
07:38:49 <quicksilver> ezyang: what you said it not quite true, none of your cases 'join' m
07:38:52 <ezyang> http://pastebin.com/KGugiiwm
07:39:14 <ezyang> quicksilver: Wait, don't all of them join m (by doing two binds on it)
07:39:22 <elliott_> ezyang: You should generalise it! Free IO
07:39:33 <quicksilver> oh maybe they do...
07:39:35 <ezyang> It seems staging is only preserved for the very /last/ action.
07:39:42 <atomicity> Botje: you rock :)
07:39:51 <ezyang> Which makes sense, since you're looking insideo n bind.
07:39:54 <elliott_> Arbitrary nested monadic effectful staging is exactly what Haskell needs to break into the mainstream.
07:40:00 <ezyang> elliott_: What's that...
07:40:19 <elliott_> ezyang: What's what?
07:40:22 <ezyang> The free IO monad?
07:40:29 <elliott_> I just meant literally (Free IO).
07:40:31 <rwbarton> you should be sure to check the monad laws involving return
07:40:38 <elliott_> data Free f a = Var a | Node (f (Free f a)) and all that.
07:40:42 <rwbarton> as in, I would guess that they are not satisfied
07:40:49 <ezyang> oh yeah, I bet some of these violate monad laws
07:40:51 <elliott_> --> Result a | Stage (IO (T a)) :P
07:42:14 * ezyang feels confused right now 
07:42:42 <elliott_> Me too.
07:42:52 <elliott_> I wasn't suggesting actually using (Free IO)-the-monad.
07:43:09 <elliott_> What.
07:43:13 <elliott_> That's not even a netsplit.
07:43:21 <srhb> Nope..
07:43:26 <cmccann> how about (Fix IO) instead, that sounds useful
07:43:26 <Taneb> The internet is going out
07:43:53 <DanBurton> sopa II: the empire strikes back
07:43:55 <elliott_> cmccann: "Infinite monadic staging" is one for the snarkmij.org
07:44:07 <elliott_> (Why doesn't snarkmij.org exist yet?)
07:44:45 <ezyang> Anyway, this all gets a bit more interesting if we admit unsafePerformIO
07:44:52 <elliott_> Doesn't everything?
07:45:04 <cmccann> elliott_, all you can do is pick how many levels you want to bind
07:45:17 <cmccann> like playing russian roulette or something
07:45:22 <cheater_> if you google for "oleg", okmij.org is the third hit
07:45:23 <elliott_> cmccann: Pretty sure Fictional Oleg can write a lambda calculus interpreter with that.
07:46:01 <cheater_> i just did this on an anonymous profile, so no chance of there being any history biasing the search engine
07:46:41 <cmccann> elliott_, depending on what primitives you allow to construct the value, I doubt that would even be too hard
07:47:40 <ezyang> http://pastebin.com/sWrxPF0c
07:47:42 <ezyang> whoo staging!
07:48:01 <ezyang> oh wait, that failed to be interesting at all
07:49:01 <elliott_> looks like IO . IO to me :P
07:49:51 <gwern> > 26 + 16 + 15 + 11 + 6
07:49:52 <lambdabot>   74
07:50:29 <ezyang> lazy Io http://pastebin.com/yKRbSqfF
07:51:32 <elliott_> The InterleaveIO monad that interleaves every action would be fun.
07:51:55 <_Mikey> Hey guys if you want to sqrt an Int
07:52:05 <cmccann> you convert it to something else first
07:52:15 <_Mikey> hmm
07:52:23 <elliott_> sqrt (fromIntegral x)
07:52:25 <_Mikey> can you convert iy back?
07:52:30 <Ngevd> round
07:52:31 <_Mikey> can you convert it back?
07:52:42 <elliott_> round
07:52:43 <cmccann> can you convert a non-integral number to an integer? :P
07:52:44 <elliott_> or truncate
07:52:47 <elliott_> or ceiling
07:52:48 <_Mikey> ahh
07:52:49 <cmccann> or floor
07:52:53 <elliott_> or uh
07:52:56 <elliott_> unsafeCoerce
07:52:57 <ezyang> OK, this all seems uber pointless.
07:53:03 <_Mikey> I see I have options
07:53:03 <cmccann> or (const 42) I mean whatever
07:53:12 <elliott_> or just 42
07:53:14 <elliott_> if you're using caleskell
07:53:32 <elliott_> come to think of it, why not ($)? no reason functions can't be Floating and Integral
07:53:40 <cmccann> ezyang, confusingly reordering IO actions doesn't seem useful to you? :D
07:54:22 <ezyang> OK, I think what I'm really trying to understand is the difference between the left and right IO composition.
07:56:36 <ezyang> Is it the... embedding of the other monad into IO?
07:56:52 <ezyang> (which is why you can't do Cont, because Haskell doesn't support first class continuations)
07:57:08 <elliott_> ezyang: That's not why you can't do Cont.
07:57:15 <elliott_> You can't do IOT (Cont r) because it's the time travel monad.
07:57:37 <Veinor> haha
07:57:39 <ezyang> "Not obvious to me"
07:58:29 <cmccann> depends on how you define IOT, doesn't it?
07:58:30 <elliott_> ContT r IO does what a language with continuations does.
07:58:36 <elliott_> cmccann: Yes.
07:58:52 <elliott_> I don't know of any coherent definitions other than StateT RealWorld where you actually go and replace the universe in (>>=).
07:59:06 <ezyang> StateT RealWorld doesn't really work though.
07:59:19 <cmccann> defining IOT to look like StateT is what makes it get weird
07:59:19 <ezyang> As Conal loves pointing out, forkIO throws a wrench in that framework.
07:59:24 <elliott_> Yes, it does.
07:59:30 <elliott_> Good luck coming up with a reasonable definition of IOT :P
08:01:31 * hackagebot happstack-server 6.5.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.2 (JeremyShaw)
08:03:11 <ezyang> OK, so going back to the staging stuff, I can "wedge" monads between two IO monads. It's like an IO monad sandwich
08:03:30 <ezyang> but it seems like the top IO monad is kind of useless
08:03:33 <elliott_> Doesn't that run into the composition-of-two-monads problem?
08:03:39 <elliott_> You can't necessarily join up the two IOs in IO (m (IO a)).
08:04:12 <ezyang> ah, it's true.
08:04:16 <mm_freak> you can very well have IOT, but it would be totally useless without runIOT
08:04:23 <mm_freak> runIOT :: IOT m a -> m a
08:04:30 <ezyang> "unsafePerformIO"
08:04:56 <ezyang> IOT is, quite literally, IO (m a) -> m a
08:05:06 <ezyang> WE can implement this if m is sufficiently IO-ish
08:05:12 <mm_freak> however, you might be able to get something like this for particular monads m:  liftIOT :: IOT m a -> IO a
08:05:30 <mm_freak> ezyang: what tells you that?
08:06:02 <ezyang> if m = IO, then this function is Join
08:06:33 <ezyang> mm_freak: It's the left-composition/right-composition question
08:06:54 <ezyang> Suppose I have two monads M and N. Then I have two new monads (M (N a)) and (N (M a))
08:07:03 <ezyang> one of these corresponds to MT N, the other NT M
08:07:09 <elliott_> ezyang: You do?
08:07:14 <byorgey> those are not necessarily monads.
08:07:19 <elliott_> You don't have those two new monads.
08:07:23 <ezyang> Assuming that you can commute
08:07:29 <elliott_> Right.
08:07:29 <byorgey> ok.
08:07:43 <mm_freak> i wouldn't know how to write a sensible definition for IOT, even given the GADT-style model of IO
08:07:59 <ezyang> swap :: m (n a) -> n (m a)
08:08:51 <cmccann> a.k.a. sequence
08:09:04 <cmccann> or various other special cases
08:09:11 <elliott_> monads aren't necessarily traversable, are they?
08:09:13 <Ngevd> How would that work with a list of Maybes?
08:09:21 <ezyang> OK, this was a tangent, and I think I want to prune this tangent, personally.
08:09:23 <cmccann> e.g. flip
08:09:29 <elliott_> What's the non-tangent?
08:09:35 <cmccann> arctangent?
08:09:41 <mm_freak> elliott_: (e ->)
08:09:44 <ezyang> elliott_: I was writing an explanation of what MonadIO was
08:09:48 <mm_freak> nontraversable
08:10:08 <elliott_> ezyang: Oh.
08:10:17 <elliott_> ezyang: That's a really bizarre tangent for writing an explanation of MonadIO.
08:10:21 <elliott_> mm_freak: right
08:10:26 <ezyang> Yeah, I'm pretty easily distracted
08:10:46 <mm_freak> ezyang: MonadIO should be explained in terms of 'lift'
08:10:49 <ezyang> The tangent was, "Well, MonadIO is a convenience because there can only ever be an IO at the bottom of the monad stack." "Wait, is that actually true?"
08:10:52 <donri> is there a way to find out what foreign dependencies cabal used [successfully]?
08:10:54 <rwbarton> also Traversable instances don't necessarily satisfy the laws for sequence that you need to make the composition a monad
08:11:15 <mm_freak> donri: effectively no
08:11:31 * hackagebot happstack-server 6.5.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.3 (JeremyShaw)
08:11:33 * hackagebot fb 0.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.5 (FelipeLessa)
08:12:02 <mm_freak> in any case IOT is such a weird concept, i don't think it makes any sense from an intrinsic view of the universe
08:12:36 <mm_freak> on the other hand a monad transformer doesn't necessarily have to provide a running function
08:12:45 <ezyang> But eventually, I want to give a negative result for the ability to write a function (m a -> b) -> (n (m a) -> b)
08:12:55 <mm_freak> runIOT :: (Runnable m) => IOT m a -> IO a
08:13:01 <mm_freak> something like that might actually work
08:13:09 <ezyang> or, in transformer world, (m a -> b) -> (t m a -> b)
08:13:20 <elliott_> ezyang: For all monads m, n that commute?
08:13:28 <ezyang> Yeah.
08:13:34 <elliott_> Right.
08:13:51 <ezyang> But at the moment I don't think I can articulate that properly.
08:14:19 <ezyang> Or, even this restricted version: (m a -> m b) -> (t m a -> t m b)
08:14:54 <ezyang> huh, that's different
08:15:01 <ezyang> (m a -> m b) -> (t m a -> m b)
08:15:22 <mm_freak> ezyang: have you looked into the monad-control package?  it might give you some useful insight
08:15:33 <mm_freak> it basically allows to wrap IO inside-out
08:15:38 <ezyang> I mean, what I'm basically trying to do is argue that monad-control is wrong.
08:16:08 <mm_freak> ezyang: wrong in what sense?
08:16:40 <ezyang> I wish I could articulate that.
08:17:45 * elliott_ wonders if his proposed alternate monad-control design is wrong in the same way... probably
08:17:55 <elliott_> bit hard to say without knowing what "wrong" means :P
08:18:22 <ezyang> As far as I can tell, there is no sound theoretical basis for MonadControl
08:18:40 <srhb> Uh oh. Someone forgot to pay the fee for hpaste.org?
08:18:46 <elliott_> @where hpaste-dns
08:18:46 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
08:18:52 <srhb> Shiny, thanks.
08:18:57 <elliott_> I need a bot to type @where hpaste-dns for me, it's too long.
08:19:04 <elliott_>  @where+ hpd @where hpaste-dns
08:19:55 <mm_freak> you know, there is an esoteric programming language that is designed to allow the shortest possible hello world program
08:20:03 <Rc43> Hi, guys.
08:20:13 <mm_freak> in the same way you could write a bot command language that allows the shortest possible "@where hpaste-dns" query =)
08:20:21 <Rc43> Can anybody tell me what can I use in haskell to play audio?
08:20:29 <ezyang> edwardk suggests that the only time we can do this operation, in general, is for operations which are universally quantified over choice of monad. That is, they plumb the client's monadic effects automatically.
08:20:32 <Rc43> It is simple player, hust play mp3/wav.
08:20:45 <Rc43> And it must work on windows too.
08:20:51 <mm_freak> Rc43: there are multiple options for that…  for the output part i know that SDL works well and is portable
08:21:07 <ezyang> So it seems pretty stupid to expect that we could always do this with monad-control, even in a limited case.
08:21:31 <mm_freak> ezyang: if you can formulate your idea of "wrong", then perhaps we could see what you mean
08:21:36 <mm_freak> i don't see anything wrong about monad-control
08:21:38 <Rc43> nn_freak, it seems fine
08:21:40 <Rc43> thanks
08:21:41 <ezyang> OK, I have one idea. Just a sec.
08:22:26 * elliott_ 's monad-control design is more lenient than the existing one, so I guess if anything it's more wrong.
08:22:50 <mm_freak> ezyang: note that MonadControl is a type class, so it already captures the fact that it might not be possible/sound for all monads
08:22:56 <mm_freak> but it's certainly sound for StateT
08:23:14 <Rc43> mm_freak, it can be used for GUI, too; right?
08:23:16 <ezyang> mm_freak: Consider the case of a wrapped function which calls its argument multiple times
08:23:19 <ezyang> Let me write this up
08:23:27 <Rc43> mm_freak, or it is better to use something like wx?
08:23:32 <mm_freak> Rc43: for graphical applications, not necessarily for GUI
08:23:43 <mm_freak> Rc43: note that with SDL you would have to write your own widget library
08:23:47 <ezyang> I'm /pretty/ sure that it's not sound for all functions you want to wrap over, either.
08:24:26 <Rc43> mm_freak, understood; exactly what I talked about
08:26:33 <Rc43> wxcore building failed =/
08:28:09 <ezyang> What's going to happen is that it'll drop the results of the first invocation on the floor
08:30:31 <etpace> Hmm -- I'm reading the "how to build a fast curry" -- and it specifies with the eval/apply method, then if "f" is a thunk, we push a call continuation -- makes sense, but how do we determine if something is a thunk on the STG? Being tagless, isn't the point being that there is no way to determine if its a thunk or function value, we just enter the closure all the same?
08:31:43 <ezyang> here ya go: http://pastebin.com/S1Uv65qA
08:33:10 <elliott_> ezyang: ouch, does that not DTRT?
08:33:16 <rwbarton> good example
08:33:40 <ezyang> You'll get ((), 1)
08:33:53 <rwbarton> but really, how can it ever do the right thing, imagine we replace IO by Identity, then double is extensionally indistinguishable from id
08:34:08 <ezyang> Right, there's no way for monad-control to do the right thing
08:34:18 <elliott_> mm_freak: ^
08:34:26 <ezyang> In fact, if you look at monad control closely, the only reason it seems to work is we usually return the result of the callback
08:35:00 <ezyang> This, btw, is why you can't do monad-control-ify IO (IO a) -> IO a
08:35:56 <elliott_> now that i think about it, this is _obvious_
08:35:56 <rwbarton> I thought the way this sort of stuff was supposed to work was to go stuff our StateT-state in an IORef
08:36:00 <elliott_> I'm disappointed in myself for not realising this befor
08:36:00 <elliott_> e
08:36:06 <ezyang> Yeah, it is obvious.
08:36:18 <ezyang> But only after the fact :-)
08:37:01 <quicksilver> that lets you tunnel StateT through IO, but not make IO State IO work, rwbarton
08:37:11 <rwbarton> yes
08:37:22 <rwbarton> Sorry, I may have lost track of what we were originally discussing :)
08:37:25 <ezyang> I don't think IORef embedding is a good idea
08:37:32 <Enigmagic> etpace: you can inspect the type at runtime
08:37:39 <ezyang> It means that put s >> get === s law is not obviously true.
08:37:53 <etpace> Enigmagic: So I guess tagless gets kinda fuzzy then?
08:37:57 <ezyang> due to concurrency
08:38:26 <quicksilver> ezyang: I disagree.
08:38:32 <Enigmagic> etpace: i don't know exactly what the definition of 'tagless' is, but the runtime does do some type checking... think about how blackholes/thunks work
08:38:33 <rwbarton> well, there is no forkStateTIO
08:38:36 <quicksilver> ezyang: if your IORef is lexically concealed you're fine.
08:38:44 <etpace> Hmm Enigmagic
08:38:55 <ezyang> quicksilver: Sure, but care must be taken. What if I abuse MonadControlIO to fork?
08:39:10 <quicksilver> ezyang: then I think this is the least of your worries :)
08:39:17 <ezyang> >:-)
08:40:04 <etpace> well Enigmagic, I thought the "tagless" part was that it wasnt the cell model -- we didnt have a bit saying "is a thunk/is a value" -- but I guess its more that instead of never needing the type, we just dont need it often
08:40:05 <rwbarton> that's a good point though
08:40:33 <rwbarton> forkIO :: IO a -> IO a looks like the kind of control operation we might want to "lift" but for say StateT s IO there is just nowhere sensible to send it
08:40:46 <elliott_> ok, i swear off monad-control :P
08:41:26 <rwbarton> (well, maybe you could fork the state?)
08:41:38 <quicksilver> rwbarton: there are several things you can do
08:41:41 <quicksilver> you can fork the state
08:41:47 <quicksilver> you can stick the state in an MVar or a TVar
08:42:00 <quicksilver> but you do end up changing the semantics in an interesting way then
08:42:07 <quicksilver> ...if it's what you need, it's what you want.
08:42:42 <rwbarton> can I really "stick the state in an MVar"?
08:42:53 <ezyang> I think the equational laws of MonadState require you to fork the state.
08:42:53 <rwbarton> I need to write   (s -> IO (s, a)) -> (s -> IO (s, a))
08:43:55 <rwbarton> uh, aside from me having the type of forkIO wrong
08:44:03 <rwbarton> (s -> IO (s, a)) -> (s -> IO (s, ()))
08:44:10 <quicksilver> rwbarton: what I said was not really true
08:44:16 <rwbarton> okay
08:44:17 <quicksilver> or at least, I missed some  important parts.
08:44:27 <rwbarton> I agree you can do "something like that" involving sticking the state in an MVar
08:44:31 <quicksilver> you can *imagine* a class like MonadState, but with weaker guarantees.
08:44:50 <quicksilver> in particuar, it no longer unwraps to s -> m (s,a)
08:44:51 <dcoutts> donri: for a package that was installed successfully, you can use ghc-pkg describe to see what foreign libs it depends on
08:44:51 <rwbarton> right, I meant literally for StateT
08:44:55 <rwbarton> yeah
08:44:55 <manenko> Hi all! What is a best book to start with haskell? I'm a professional developer (C++, C#, .NET -> imperative world). I think I will start with http://learnyouahaskell.com. Is is a good choice?
08:45:02 <quicksilver> because other agents can change 's'
08:45:03 <elliott_> yes
08:45:10 <cheater_> manenko: yes
08:45:11 <quicksilver> you just have  get/put/modify
08:45:16 <cheater_> manenko: also real world haskell is good
08:45:16 <rwbarton> Sure
08:45:20 <rwbarton> That would work
08:46:01 <cheater_> manenko: if you want a short soft intro to some dead simple basics look at my blog, http://cheater.posterous.com/
08:46:43 <cheater_> manenko: i've written this stuff while i was learning it myself, i do a lot of computer programming in my job too
08:46:52 <cheater_> so it might have a similar perspective to yours
08:46:59 <manenko> cheater_, thank you! And what I should read about functional programming? I'm afraid that my imperative background will slow me down during learning.
08:47:38 <cheater_> manenko: functional programming is real simple, plus haskell can do imperative style just fine
08:48:01 <quicksilver> rwbarton: forking the state together with some agreed way of collecting the completed state when the thread finishes is probably more sane though.
08:48:08 <cheater_> you can start out by putting everything into "do" blocks of the IO monad (which basically just means you write your code in imperative style)
08:48:13 <manenko> cheater_, but I want to learn functional style :)
08:48:17 <cheater_> then as you learn you can progress towards more idiomatic code
08:48:18 <cheater_> yeah
08:48:23 <cheater_> just saying it's not a stumbling block
08:48:27 <cheater_> you can take it 1 step at a time
08:48:28 <Scriptor> manenko: stay away from that though, for now just focus on how to do as much functionally as possible
08:48:52 <cheater_> yeah it's a good idea to try and do as much as possible in idiomatic haskell
08:48:54 <Scriptor> start by rewriting some simple functions, like head, take, map, and so on
08:49:05 <cheater_> just that if you have a job to get done, it won't stop you from getting it done
08:49:16 <cheater_> yeah that makes fun
08:49:20 <ski> @where whyfp
08:49:20 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
08:49:22 <cheater_> that is fun
08:49:25 <cheater_> sorry :)
08:49:42 <ski> manenko : that ^ might be interesting
08:49:55 <ski> also, RWH is
08:49:59 <ski> @where RWH
08:49:59 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:50:01 <rwbarton> forking the state and even just throwing away the new thread's final state would be reasonable
08:50:28 <rwbarton> so let me see if I can understand how the MVar thing would work
08:51:00 <manenko> Thanks guys!
08:51:43 <ski> manenko : also (maybe it goes without saying), this channel is usually a good place to lurk in, and ask questions in
08:51:54 <mm_freak> ezyang: good example, thanks for that
08:52:10 <mm_freak> then i wonder what conditions must hold for monad-control to be correct
08:52:19 <manenko> ski, thanks :)
08:52:41 <mm_freak> after all i feel pretty safe only using the exception-handling mechanism of monad-control/lifted-base
08:52:45 <ezyang> So, a tempting first guess is to say we must call the callback only once, and it must return the result of that.
08:53:12 <ezyang> And if an asynch exception is raised, you lose the intermediate monadic effects.
08:55:54 <shergill> does anyone know of a decent tutorial/paper to get a better handle on the memory requirements of haskell programs?
08:56:28 <Lemmih> shergill: Rule of thumb: 3x your actual data.
08:57:57 <shergill> Lemmih: are there any 'best practices' etc? i've heard (and please correct me if this is wrong) that it's hard to reason about the memory usage of haskell programs
08:58:30 <shergill> and that it's 'easy' to make blunders which can increase memory usage
08:58:38 <mm_freak> shergill: it's somewhat easy to reason about the asymptotic memory usage
08:58:48 <mm_freak> it's difficult to reason about the exact memory usage
08:59:13 <mm_freak> there are certain data structures for which you can make safe statements though, for example unboxed arrays and vectors
08:59:26 <mm_freak> also bytestrings, texts, etc.
09:03:30 <rwbarton> So I wrote down what I assume is the standard "stuff your state into an IORef" technique -- http://pastebin.com/n54YDc24
09:04:00 <shergill> mm_freak: and otherwise i guess it would probably help if i were to spend some time understanding how the garbage collector works? i don't have the reference off the top of my head, but i remember seeing a paper where they showed a simple program where memory usage went from constant to linear. changing the function impacted the order of traversal and which symbols the garbage collector felt it could discard and which it couldn't
09:04:08 <ezyang> "but does it fork"
09:04:15 <cmccann> ezyang, http://pastebin.com/NsdC7yMY
09:04:16 <rwbarton> well, sort of but not quite
09:04:28 <cmccann> ezyang, not that I think it's good for anything :P
09:04:30 <cmccann> but amusing
09:04:40 <ezyang> cmccann: Ah, cpsed
09:04:44 <rwbarton> if you use it with forkIO, the state will be forked except that there will be a race condition where the parent thread might see a modification made by the child
09:04:47 <cmccann> and otherwise mangled a bit
09:05:04 <cmccann> it's a ContT with a built-in join basically
09:05:22 <cmccann> which gives the ability to shuffle things around in limited ways
09:05:45 <mm_freak> shergill: you might have been reading a paper about Codensity monads, which can change the asymptotic behavior of certain monadic algorithms
09:05:54 <cmccann> I don't think you can do anything useful with it though
09:05:55 <ezyang> rwbarton: :-(
09:05:56 <rwbarton> cmccann, I think that is definitely good for *something*
09:06:11 <rwbarton> if I want to pair my resource acquisition/release and don't care about exceptions
09:06:16 <mm_freak> shergill: in any case, one intuition about haskell's garbage collector is "as early as possible"
09:06:18 <rwbarton> like bracket, but without lexically nesting the scopes
09:06:34 <cmccann> for example I don't think there's any way to bind the result of a "later" call
09:06:48 <cmccann> only defer something with a type (m ()) until later
09:06:57 <mm_freak> shergill: however, your only way to make sure it to run your application with the -s RTS option and see how it behaves
09:07:29 <rwbarton> ezyang: i think you would need some kind of forked/copy-on-write mutable cell facility in IO to do it (?)
09:09:10 <rwbarton> fundamentally it's a bit hard to distinguish forkIO from id otherwise, when you pass in an IO action that does not block
09:09:21 <shergill> ok this took way longer than it should have. mm_freak: here's the paper in case you were curious: http://dl.acm.org/citation.cfm?id=507669.507667
09:09:58 <rwbarton> Well, maybe not, there is probably a function to get some kind of identifier for your current thread, right?
09:11:07 <mm_freak> shergill: haven't read that one
09:12:34 * ski . o O ( `(∀x. x) ⊢ execStaged test' ? )
09:13:25 <rwbarton> "(∀x. x) ⊢ " is cmccann's ghci prompt
09:14:04 <cmccann> yes
09:14:10 <monochrom> haha
09:14:21 <ski> `∀x. x' struck me as false, and false entails everything, so ..
09:14:43 <rwbarton> :t undefined
09:14:44 <lambdabot> forall a. a
09:15:28 <cheater_> rwbarton> "(∀x. x) ⊢ " is cmccann's ghci prompt
09:15:29 <cmccann> ski, and a REPL prompt entails whatever I want it to
09:15:30 <cheater_> hahaha
09:15:54 <elliott_> cmccann: i like that
09:16:15 <shergill> heh
09:16:32 <elliott_> Staged, that is
09:17:00 <cmccann> a fair number of people started using λ> as their GHCi prompt so I decided I wanted something more ridiculous :P
09:17:00 <ski> cmccann : it never gives an unwanted result ? :)
09:17:19 * elliott_ uses the default but pretends it's GHCi> when talking to other people to seem cooler
09:17:59 <donri> I use ">>> " so it works with haddock/doctest
09:18:09 * ski idly wonders whether one could make GHCi report types in Frege's Begriffschrift
09:18:47 <elliott_> id $ would be a good ghci prompt
09:18:51 <elliott_> because you could copy lines directly
09:18:52 <cmccann> elliott_, rwbarton actually had a decent idea for where something like Staged could be useful
09:18:56 <elliott_> ...except for type annotations :/
09:19:11 <elliott_> const "Prelude Control.Monad" $
09:19:19 <cmccann> haha
09:19:19 <elliott_> cmccann: what was that?
09:19:24 <elliott_> erm
09:19:26 <elliott_> flip const there
09:19:31 <rwbarton> cmccann, oh right, getting back to that, can't you actually convert all the with* functions into exactly this form
09:19:41 <cmccann> possibly!
09:19:53 <elliott_> ezyang: I get the feeling that automatic lifting in general might just be a hack.
09:19:54 <rwbarton> and then you don't need specialised functions like withMany
09:20:00 <rwbarton> it's just sequence
09:20:05 <cmccann> elliott_, using "later" to defer finalizers/cleanup/&c.
09:20:09 <elliott_> I kinda knew automatic lifting of control into near-arbitrary semantics was wishful thinking.
09:20:10 <rwbarton> (note: not tested in any way whatsoever)
09:20:23 <elliott_> cmccann: heh, neat!
09:20:47 <elliott_> cmccann: it's certainly simpler than all these resource allocation monads
09:20:48 <rwbarton> @type withMany
09:20:49 <lambdabot> Not in scope: `withMany'
09:21:02 <rwbarton> withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
09:21:04 <cmccann> elliott_, yes, the question is whether it actually works
09:21:20 <elliott_> cmccann: i suspect you want a forall r. inside that constructor 90% of the time
09:21:49 <cmccann> yeah, probably
09:22:40 <rwbarton> can you write test/staged using just ContT r IO rather than this Staged r IO?
09:22:48 <elliott_> cmccann: hmm, how does now differ from list?
09:22:58 <elliott_> rwbarton: no, the extra m layer is the important part
09:22:59 <elliott_> erm
09:22:59 <elliott_> *lift
09:23:01 <cmccann> rwbarton, possibly, I was just messing around to see what things did
09:23:33 <hey_lu> hi. can you help me with a synthesizer-core package problem?
09:23:34 <cmccann> with a little extra maneuvering you might be able to do something with just ContT, not sure
09:23:58 <marienz> elliott_: pong
09:24:18 <cmccann> elliott_, now has a more restricted type for the sake of matching later
09:24:30 <cmccann> also I wrote that first then added the MonadTrans instance after
09:24:44 <elliott_> marienz: hehe, bit late :P there was a spammer spamming that racist forum that keeps popping up, but they got klined quickly
09:24:46 * cmccann didn't really have a master plan with this :P
09:24:50 <rwbarton> I wish that when I try to load my program in ghci but it doesn't compile, I still get the modules it imports in scope in ghci
09:25:15 <marienz> elliott_: ah, that one. Yeah, if that happens in a channel a bunch of staffers are in it should get picked up pretty quickly.
09:25:17 <rwbarton> so I can :i ContT or whatever to see why my program is wrong
09:27:42 <ezyang> elliott_: Well, there's a reasonably sound basis for when lifting operations is Ok.
09:28:58 <rwbarton> well, this seems to work... http://pastebin.com/cddW7SGv
09:29:14 <chrisdone> rwbarton: you mean like this baby? http://chrisdone.com/hurhur.png
09:30:24 <rwbarton> Well, that looks even nicer--is it using the previous compiled version of the module?
09:30:46 <chrisdone> rwbarton: it's a bit of a hack, i run two ghci sessions
09:30:52 * rwbarton counts which line is the 23rd
09:31:07 <donri> chrisdone: does it has syntax highlighting in the ghci?
09:31:09 <chrisdone> rwbarton: one for checking if the code's gonna compile, and one for loading the ok code and from which :t and :i will work
09:31:14 <rwbarton> Ah
09:31:19 <chrisdone> donri: no that's Kinda Hard in emacs
09:31:22 <cmccann> rwbarton, yeah, I was just thinking that the extra m layer probably isn't doing anything after all
09:31:25 <cmccann> hm
09:31:28 <donri> je'e
09:31:35 <bertolo> http://redd.it/ot3yz
09:31:45 <bertolo> LOL
09:31:52 <donri> i've been wanting something like http://bpython-interpreter.org/ for ghci
09:31:54 <cmccann> kinda disappointing actually, seems like that should allow you to get away with something interesting
09:32:13 <chrisdone> rwbarton: but i think ghci in one of the recent ghc's (7.4 maybe?) will have this built-in… i swear i remember someone (maybe ndm) mentioning they were patching it to not just throw the baby out with the bath water on error. anyone else remember what i'm talking about?
09:32:21 <rwbarton> yeah that sounds familiar
09:33:04 <elliott_> cmccann: hmm
09:33:12 <elliott_> actually yeah, it's just moving stuff into the continuation, isn't it?
09:33:17 <cmccann> elliott_, yeah
09:33:24 <elliott_> how about (a -> m r) -> m (m r) :D
09:33:43 <cmccann> I tried that first and didn't get anywhere
09:33:55 <cmccann> but it does look promising
09:33:57 <cmccann> hm
09:34:42 <elliott_> the idea being that it bundles its finalising stuff into the inner layer
09:34:43 * elliott_ tries it
09:34:48 <rwbarton> I was thinking of something a little different... most compile errors occur after the imports are parsed, so even if I've just written a brand new module that doesn't compile I should be able to query ghci about the things that it imports without having to use the full qualified names
09:35:46 <chrisdone> rwbarton: i suppose a little elisp could sort that out, to :m + all the import lines, esp. with the latest ghc's with full import+qualified support
09:36:07 <chrisdone> (i think scion can provide some more cool stuffs in this area rather than putting lipstick on ghci)
09:36:08 <rwbarton> Yeah, that'd be handy.
09:37:12 <elliott_> cmccann: doesn't seem to work
09:37:17 <elliott_> "later" ends up running immediately because of the (>>=)
09:37:21 <chrisdone> which i can try now i've finally migrated to ghc 7.2 d(*⌒▽⌒*)b
09:37:28 <elliott_> possibly my (>>=) is just broken though :)
09:38:16 <cmccann> elliott_, hm
09:38:33 <elliott_>   Staged f >>= g = Staged $ \k -> f $ \a -> join $ runStaged (g a) k
09:38:40 <elliott_> the problem is that the finalisers end up getting run in the outer layer
09:38:42 <elliott_> thanks to the join
09:39:42 <cmccann> elliott_, couldn't you still defer them the same way rwbarton did with ContT?
09:39:47 <rwbarton> you can also just use WriterT (IO ()) IO with an appropriate newtype wrapper around IO ()
09:41:27 <rwbarton> though it feels unclean somehow
09:42:00 <cmccann> rwbarton, well, it doesn't have to be IO
09:43:27 <elliott_> cmccann: hmm, how was that?
09:44:42 <salisbury> is there a way to check whether something == NaN?
09:44:44 <cmccann> elliott_, http://pastebin.com/cddW7SGv
09:44:55 <cmccann> :t isNaN
09:44:57 <lambdabot> forall a. (RealFloat a) => a -> Bool
09:45:11 <cmccann> nothing == NaN :P
09:45:22 <cmccann> > (0/0) == (0/0)
09:45:23 <lambdabot>   False
09:45:53 <salisbury> argh..
09:46:07 <elliott_> cmccann: no, because this is in (>>=)
09:46:12 <elliott_> so we can't just decide to pass a ()
09:46:15 <ibid> > isNan (0/0)
09:46:16 <lambdabot>   Not in scope: `isNan'
09:46:20 <ibid> > isNaN (0/0)
09:46:21 <lambdabot>   True
09:46:24 <cmccann> ah
09:46:31 <salisbury> yes!!
09:46:34 <salisbury> thanks
09:47:04 <ibid> but of course, as cmccann points out, that's not (== NaN) because that's always false :)
09:48:19 <chrisdone> ლ(ಠ益ಠლ y u no use hpaste
09:48:33 <elliott_> because
09:48:35 <elliott_> @where hpaste-dns
09:48:36 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
09:48:44 <elliott_> it's a godaddy expired page for me
09:48:45 <elliott_> and many others
09:48:46 <chrisdone> whaaat
09:48:51 <elliott_> yep!
09:49:06 <elliott_> mumble mumble TTL something something
09:50:36 <chrisdone> (￣ー￣)
09:51:15 <chrisdone> it's still resolving properly here, but that'll be cache. bos is in control of the domain… i'll email him
09:51:43 <hey_lu> is that a no? (regarding my synthesizer-core problem ;)
09:52:45 <maloi> return . f =<< x == return . x >>= f, right?
09:53:56 <cmccann> maloi,  your types look weird there
09:54:08 <elliott_> chrisdone: oh, i assumed it was just a move from godaddy
09:54:15 <elliott_> that hadn't propagated everywhere yet
09:54:26 <elliott_> since people moving from godaddy is pretty common recently :P
09:54:35 <cmccann> maloi, also, do you just want fmap there?
09:54:47 <chrisdone> elliott_: oh. that might be the case… bryan didn't mention anything to me. emailing anyway
09:55:08 <maloi> cmccann: liftM f x = return . f =<< x i wanna know if this is the same as with >>= and arguments flipped?
09:55:16 <geekosaur> hpaste was fine last night but I'm getting the godaddy "domain deleted" page too
09:55:32 <elliott_> maloi: Yes.
09:55:35 <elliott_> (=<<) = flip (>>=)
09:55:37 <chrisdone> elliott's guess sounds about right then
09:55:40 <elliott_> It's just a notational convenience.
09:55:53 <cmccann> maloi, what you had before wasn't flipping the arguments correctly though
09:56:01 <maloi> i don' see why it's convenient :)
09:56:13 <Eduard_Munteanu> maloi: that parses as    (return . f) =<< (x i)
09:56:46 <maloi> the i did belong to the question
09:56:48 <elliott_> maloi: (=<<) goes the same way as (.)
09:56:53 <elliott_> and ($)
09:57:01 <elliott_> (>>=) goes backwards compared to those
09:57:08 * cmccann doesn't think comparing (=<<) to (.) makes sense?
09:57:11 <elliott_> which one is nicer depends on the situation
09:57:18 <elliott_> cmccann: well...
09:57:22 <elliott_> f =<< g =<< x
09:57:25 <elliott_> f $ g $ x
09:57:26 <elliott_> f . g $ x
09:57:29 <cmccann> yeah
09:57:30 <chrisdone> cmccann: moar liek (.) and >=> amirite?
09:57:31 <cmccann> I guess that works
09:57:40 <rwbarton> it makes sense to me... (=<<) conveys the idea that you are primarily interested in the data flow of monadic results rather than the effects and their sequencing
09:57:42 <cmccann> no, (<=<)
09:57:44 <elliott_> i just mean in terms of pipeline ordering
09:57:56 <chrisdone> cmccann: well, order is details :p
09:58:38 <cheater_> thinking of functional code in terms of pipelines is detrimental
09:58:56 <maloi> Eduard_Munteanu: does return . f =<< x not parse as return . (f =<< x) ?
09:58:56 <cheater_> implies one thing happens before another
09:59:09 <elliott_> maloi: no
09:59:13 <elliott_> (return . f) =<< x
09:59:29 <maloi> ok then i dont understand what it does :)
09:59:42 <Eduard_Munteanu> It's just like  x >>= return . f
10:00:10 <cmccann> also, flipped function application is return for Cont, hence (x >>=) effectively takes a continuation
10:00:13 <Eduard_Munteanu> Except it feels more like function application.
10:00:19 <cmccann> which is why definitions are often written as (m >>= k)
10:00:32 <cmccann> where k stands for kontinuation I guess
10:00:47 <elliott_> maloi:
10:00:59 <elliott_> liftM f m = do { x <- m; return (f x) }
10:01:09 <elliott_> expand do notation: m >>= \x -> return (f x)
10:01:18 <elliott_> make the right-hand side point-free: m >>= return . f
10:01:23 <elliott_> flip: return . f =<< m
10:01:42 <kuznero> Hi All!
10:01:59 <maloi> elliott_: this makes total sense to me but return . f gives me headaches :D
10:02:31 <elliott_> maloi: (return . f) === (\x -> return (f x))
10:03:07 <maloi> ok thank you all very much
10:03:54 <elliott_> ezyang: I do not think it is just MonadBaseControl.
10:03:57 <elliott_> It is MonadControl itself.
10:04:12 <elliott_> MonadBaseControl is just a MonadIO-like sugar, no?
10:05:28 <ezyang> Yes, but there isn't any MonadControl typeclass
10:05:36 <ezyang> I guess I could rename it monad-control is unsound
10:05:37 <rwbarton> AFAICT MonadBaseControl is for lifting control operations on the base monad into the total monad, MonadTransControl is for lifting control operations relating to functionality added in transformers, and MonadControl doesn't exist in the package I'm looking at (monad-control)
10:06:18 <elliott_> ezyang: MonadTransControl
10:06:19 <elliott_> is what you mean
10:06:34 * hackagebot digestive-functors-happstack 0.1.1.3 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.3 (JasperVanDerJeugt)
10:06:38 <ezyang> But no one uses that...
10:06:52 <elliott_> Sure they do, that's how you implement MonadBaseControl instances. No?
10:07:03 <elliott_> Just like nobody uses (lift.lift.lift) to execute IO, but liftIO is implemented like that in the end.
10:07:21 <ezyang> "sure"
10:07:46 <ezyang> ok i'll just rename this to monad-control
10:08:03 <chrisdone> oh man i hate lift.lift.lift code :D
10:08:24 <elliott_> ezyang: it just legitimately threw me off for a second, but I haven't really used monad-control much
10:08:32 <elliott_> so maybe my reaction wasn't typical
10:13:11 <sjmurdoch> Has someone told Bryan O'Sullivan that hpaste.org has expired (yesterday)? It is still in the topic
10:13:36 <mizu_no_oto> hpaste is down?
10:13:48 <elliott_> Yes.
10:13:53 <elliott_> @where hpaste-dns
10:13:54 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
10:14:00 <elliott_> chrisdone has contacted him.
10:14:17 <mizu_no_oto> What should I use in the meantime?
10:14:32 <elliott_> pastie, perhaps?
10:15:01 <chrisdone> http://paste.lisp.org/
10:15:11 <chrisdone> show support for our functional brethren
10:15:37 <sjmurdoch> elliott_: Thanks
10:16:27 <elliott_> chrisdone: traitor!
10:16:39 <MostAwesomeDude> paste.pocoo.org (or any other lodgeit instance) can highlight Haskell.
10:17:09 <chrisdone> elliott_: ☞(ﾟヮﾟ)☜?
10:17:13 <elliott_> I suggest we just paste directly into the channel instead!
10:17:18 <mizu_no_oto> http://paste.lisp.org/display/127245
10:17:24 <elliott_> That way NOBODY has to disagree.
10:18:08 <mizu_no_oto> Why is the type of genEmpties and emptyCoords different?
10:19:14 <mizu_no_oto> The code for both is essentially the same
10:20:13 <elliott_> Looks like the monomorphism restriction.
10:20:29 <elliott_> genEmpties is just a generalised version of the same type.
10:23:28 <lukish> Is there some code style guide about naming functions in haskell? camelCase or underline_style
10:23:57 <chrisdone> almost always camelCase, the underline_style is more exceptional
10:23:58 <ion> lukish: Look at Prelude and the rest of base.
10:24:03 <mm_freak> lukish: camelCase is the common convention
10:24:25 <cmccann> just separate words with apostrophes, like'this
10:24:29 <cmccann> that's clearly the best way
10:24:43 <_Mikey> :)
10:24:48 <chrisdone> things like prop_fooBar is one convention for quickcheck
10:25:04 <cmccann> (n.b.: don't actually use apostrophes)
10:25:18 <mm_freak> myFunction_ is also a common convention for a simplified variant of myFunction
10:25:23 <chrisdone> don'tUseApostrophes
10:25:32 <elliott_> cmccann: <oleg> :(
10:25:47 <_Mikey> yNot'
10:25:49 <mm_freak> and f' is a common convention for variants of f with some additional strictness
10:25:51 <chrisdone> mm_freak: i also see myFunction' (and also for strict versions)
10:25:57 <elliott_> mm_freak: also for helper functions
10:26:05 <mm_freak> yeah
10:26:08 <_Mikey> yea
10:26:10 <elliott_> (i.e. f = g (f' ...) where f' ...)
10:26:17 <elliott_> *e.g. more like
10:26:20 <cmccann> oleg can use whatever style he likes on account of being oleg
10:26:21 <chrisdone> _foo for unused
10:26:36 * hackagebot dingo-core 0.1.0 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.1.0 (BardurArantsson)
10:26:38 * hackagebot git-annex 3.20120123 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120123 (JoeyHess)
10:27:26 * elliott_ will switch to an idiosyncratic and incomprehensible unique indentation style just as soon as he can come up with one
10:27:35 <cmccann> so you can use _foo_' for an unused function that discards some details and does so strictly
10:27:55 <_Mikey> epic
10:27:57 <elliott_> my efforts have been set back by the discovery of Utrecht code, making all my ideas seem quaintly conventional by comparison
10:28:13 <elliott_> cmccann: blasphemy! ' must come before _!
10:28:40 <cmccann> elliott_, the ordering should probably mean something, but I'm not sure what
10:29:11 <elliott_> cmccann: maybe result-value strictness vs. some other kind of strictness? (strictness in the monadic computation type perhaps, since _ usually implies that?)
10:29:14 <chrisdone> bar `_foo_'` zot OH GOD IT'S HIDEOUS
10:29:28 <elliott_> bar `(`_foo_'`)` zot
10:29:30 <elliott_> fixed that for you
10:29:33 <chrisdone> xD
10:29:49 <cmccann> elliott_, sounds plausible, let's go with that
10:29:53 <chrisdone> does `(…)` actually work?
10:30:02 <elliott_> not yet
10:30:04 <chrisdone> > (+1) `($)` 2
10:30:05 <lambdabot>   <no location info>: parse error on input `('
10:30:05 <chrisdone> oh
10:30:12 <elliott_> i have yet to successfully convince the committee
10:30:17 <chrisdone> :)
10:30:40 <elliott_> maybe i can convince someone to hide it in a ghc patch adding something everybody wants like a nice module system
10:30:47 <chrisdone> i've wanted that sometimes, ended up making a separate def. for it
10:30:58 <elliott_> what, `($)`?
10:31:19 <chrisdone> nah, "foo `bar mu` zot"
10:31:23 <rostayob> ...why?
10:31:43 <rostayob> ah
10:31:53 <cmccann> yeah, me too
10:31:56 <lukish> @pl (\c -> (matrix2Int $ row x c) ++ (matrix2Int $ row x c))
10:31:56 <lambdabot> ap ((++) . matrix2Int . row x) (matrix2Int . row x)
10:31:56 <chrisdone> don't recall, really. it seemed legit at the time
10:31:57 <elliott_> yeah, i actually want that :x
10:32:03 <elliott_> as much as it'd break the grammar into tiny little pieces
10:32:06 <elliott_> and then stomp on them
10:32:15 <cmccann> would it?
10:32:18 <lukish> How can I remove doubling a code from (\c -> (matrix2Int $ row x c) ++ (matrix2Int $ row x c)) ?
10:32:21 <rostayob> elliott_: why would you want that?
10:32:26 <rostayob> the `($)`
10:32:28 <cmccann> if you require parentheses
10:32:30 <elliott_> lukish: join (liftM2 (++)) (matrixToInt . row x)
10:32:35 <cmccann> then `( should be unambiguous
10:32:40 <elliott_> rostayob: you wouldn't
10:32:44 <cheater_> @src liftM
10:32:44 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:32:45 <cheater_> @src liftM2
10:32:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:32:48 <elliott_> cmccann: that would break `($)`
10:32:55 <elliott_> you'd have to do `(($))`
10:32:56 <lukish> Wow
10:32:58 <elliott_> and that's just ridiculous
10:33:00 <cheater_> @. undo src liftM2
10:33:00 <lambdabot> ()
10:33:04 <cheater_> huh
10:33:17 <cheater_> @. (undo) (src) liftM2
10:33:17 <lambdabot> Plugin `compose' failed with: Unknown command: "(undo)"
10:33:24 <lukish> @index liftM2
10:33:24 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:33:24 <elliott_> (`mod`) 1 2
10:33:29 <cheater_> @. src undo liftM2
10:35:04 <lukish> @index concatMap
10:35:04 <lambdabot> Data.List, Prelude
10:36:16 <mkscrg> it's known that hpaste.org is down, right? domain name expired
10:36:36 * hackagebot dingo-widgets 0.1.0 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.1.0 (BardurArantsson)
10:36:38 * hackagebot dingo-example 0.1.0 - Dingo Example  http://hackage.haskell.org/package/dingo-example-0.1.0 (BardurArantsson)
10:36:40 * hackagebot fb 0.6 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.6 (FelipeLessa)
10:37:19 <_Mikey> sorry I died for a second
10:37:45 <_Mikey> if I have a pure function and I want to run it in a do block do I need to use liftM?
10:37:54 <chrisdone> _Mikey: did you see lambdas and alonzo church?
10:38:02 <_Mikey> no :(
10:38:28 <chrisdone> ah, so you went to hell and you saw Rasmus Lerdorf
10:38:44 <_Mikey> :p
10:39:05 <chrisdone> pure code doesn't get 'run' like monadic actions do. what's your use case?
10:39:19 <elliott_> chrisdone: At least Lerdorf didn't convince the world his bad language was the most elegant thing in the history of programming.
10:39:26 <elliott_> (I'm looking at you, van Rossum.)
10:39:32 <monochrom> liftM is one choice. there are others
10:39:56 <_Mikey> I'm not sure how to put this I think I'm going about everything backwards
10:40:19 <_Mikey> but I I have a function which needs to call various pure functions in sequence
10:40:27 <monochrom> do { s <- getLine; putStrLn ("the length is " ++ show (length s)) }  do you see the pure function run inside?
10:40:49 <_Mikey> aye
10:40:52 * chrisdone chants use-case, use-case to _Mikey
10:40:58 <_Mikey> hmmm
10:41:05 <_Mikey> @hpaste-dns
10:41:05 <lambdabot> Unknown command, try @list
10:41:08 <_Mikey> ahh
10:41:16 <_Mikey> where is the new hpaste again?
10:41:28 <chrisdone> http://paste.lisp.org until the hpaste domain is fixed
10:41:36 * hackagebot openid 0.2.0.1 - An implementation of the OpenID-2.0 spec.  http://hackage.haskell.org/package/openid-0.2.0.1 (TrevorElliott)
10:41:49 <elliott_> @where hpaste-dns
10:41:49 <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
10:42:00 <elliott_> probably best to use paste.lisp.org or pastie though
10:42:01 <elliott_> @where- hpaste-dns
10:42:01 <lambdabot> Maybe you meant: where where+
10:42:04 <elliott_> @forget hpatse-dns
10:42:04 <lambdabot> Incorrect arguments to quote
10:42:07 <elliott_> oh come on!
10:42:12 <elliott_> how do you make lambdabot forget a where
10:42:33 <Rc43> Guys, who has experience with sdl or wx installing on windows?
10:42:34 <ski> you don't ?
10:42:50 <Rc43> Without haskell platform.
10:42:50 <cmccann> Rc43, I'm trying to repress those memories
10:43:30 <Rc43> cmccann, it was failed?
10:43:33 <chrisdone> @forget
10:43:33 <lambdabot> Incorrect arguments to quote
10:43:39 <chrisdone> @forget hpaste-dns
10:43:39 <lambdabot> Incorrect arguments to quote
10:43:43 <chrisdone> nah, i dunno
10:43:45 <ski> @where hpd
10:43:45 <lambdabot> I know nothing about hpd.
10:43:51 <monochrom>  @forget is for @remember
10:43:52 <_Mikey> http://paste.lisp.org/+2Q6O.
10:44:01 <Rc43> Also, can I compile programms from linux to windows (with same architecture) ?
10:44:03 <cmccann> Rc43, I've gotten both to work at least once, but failed other times
10:44:05 <_Mikey> this is what I'm trying at the moment
10:44:09 <ski> @list where
10:44:10 <lambdabot> where provides: where url what where+
10:44:10 <monochrom> you can, though, set an empty string to your @where+
10:44:21 <elliott_> @where qwlkjsdfjkl
10:44:22 <lambdabot> I know nothing about qwlkjsdfjkl.
10:44:31 <elliott_> @where+ hpaste-dns I know nothing about hpaste-dns. Not any more, at least.
10:44:31 <lambdabot> Nice!
10:44:38 <monochrom> haha
10:45:03 * ski notices elliott_ didn't actually add `hpd' ..
10:45:11 <_Mikey> I'm using return to lift the parameters into the monad.
10:45:13 <Rc43> cmccann, it seems, it is much easier with haskell platform, but I have already installed ghc only and I am afraid that everything will become much more confused.
10:45:15 <elliott_> ski: intentionally :P
10:45:18 <rostayob> elliott_ and lambdabot, it's complicated
10:45:22 <_Mikey> and then liftM to lif the functions
10:45:23 <Rc43> cmccann, with cabal
10:45:31 <_Mikey> but it doesn't compile.
10:45:46 <cmccann> Rc43, it can be a pain, but it is possible
10:45:52 <maloi> is there a working version of Cale Gibbard’s article on how to use monad transformers? the link in the typeclassopedia isn't working anymore
10:46:24 <cmccann> Rc43, I guess the best you can do is try installing them and try to fix any problems that arise
10:47:28 <Rc43> May be it is not very painfull to build windows binaries from linux?
10:47:32 <Rc43> http://www.mail-archive.com/haskell-cafe@haskell.org/msg50702.html
10:47:46 <cmccann> Rc43, I've never tried
10:47:53 <Rc43> It seems, it is possible for C. And ghc can generate C sources.
10:47:55 <rostayob> wait wait, GHC can cross-compile now?
10:48:12 <ski> _Mikey : saying  graphT' <- return graphT  and later using  graphT'  is the same as using  graphT  later instead
10:48:16 <tommd> It can ever since HaLVM was released.
10:48:36 <rostayob> tommd: what does halvm have to do with it?
10:48:40 <frerich_> Hi, I'm currently trying to write a small networking application using Haskell. I wondered - is it true that the 'Handle' which you get via 'connectTo' (from Network) should be closed via hClose, but the 'Socket' you get via e.g. accept should be closed via 'sClose'? Why is there a different type for server sockets and client sockets?
10:48:55 <tommd> Well... halvm is a patch to GHC that allows it to cross compile to the Xen ABI so... a lot.
10:48:55 <ski> _Mikey : also, `_ <- makeDecision pherLevels' is simpler written just as `makeDecision pherLevels'
10:49:26 <elliott_> frerich_: That's just the low-level interface, is it not?
10:49:36 <rostayob> tommd: mhm...
10:49:37 <elliott_> I think you can operate all on Handles for the actual connections with the normal interface.
10:50:01 <frerich_> elliott_: I'm not sure, I never did TCP/IP with Haskell. I only started playing with the Network module about 30 minutes ago :-)
10:50:08 <Saizan> well, the mainline ghc can't cross compile
10:50:13 <_Mikey> ski: okies cheers.. I'll try returning it straight into the lifted function
10:50:22 <tommd> No, not mainline.  They didn't like HaLVM.
10:50:34 <monochrom> clearly, hClose on a Socket is a type error
10:50:46 * cmccann would be willing to entertain the notion that installing a hacked-up GHC on linux and cross-compiling would still be easier than getting some stuff to work on windows
10:51:38 <ski> _Mikey : note that i have no idea what you're trying to do, e.g. i don't know the types of `senseSur',`makeDecision',`setDir',`moveAnt', and i don't know the intended type of `procAntAtNode'
10:53:26 <frerich_> monochrome: Yeah, of course. I was just wondering why the Network module has 'connect' yield an IO Handle (instead of an IO Socket) and 'accept' yields a 'Socket'.
10:53:31 <_Mikey> ski: well, for now makeDecision setDir senseSur are all undefined. They will be pure functions which assist moveAnt to produce a new graph with the ant node moved.
10:54:02 <Rc43> tommd, xen is virtual machine?
10:54:32 <_Mikey> ski: moveAnt is defined and it returns a Data.Graph tuple with a graph and a finding function inside
10:54:53 <_Mikey> ski: its pure
10:56:52 * ski annotated "liftM" with "refactored nonsense" at <http://paste.lisp.org/display/127248#1>
10:57:03 <elliott_> manual hpaste bot :D
10:57:07 <elliott_> these are truly trying times
10:57:58 <monochrom> one benefit is the type distinction. as far as the module Network is concerned, Socket is only good for server-side accept, Handle is the one for real talking
10:58:12 <cmccann> elliott_, fortunately we don't need a manual "elliott has waiting messages" bot yet
10:58:15 <ski> _Mikey : maybe you should actually tell me the actual types, instead of trying to relate them in words ?
10:58:20 <cmccann> that would be far too much work to keep up with
10:58:48 <elliott_> hahaha
10:59:01 <elliott_> cmccann: that's just repeat ("elliott: You have 1 new message. ...\n")
10:59:47 <ski> _Mikey : re `makeDecision',`setDir',`senseSur' being undefined : that is irrelevant, i just want to know their (intended) types, not their definitions
11:00:10 <_Mikey> ski: ok, I'll work them out.
11:01:44 <cmccann> elliott_: You have ℵ₀ new messages.
11:02:40 <monochrom> hahaha
11:03:12 <monochrom> messages are supposed to be ordered. you should use ordinals.
11:03:56 <cmccann> monochrom, hm, that seems wrong in a phrase saying how many are waiting
11:04:43 <monochrom> "you have ϵ₀ messages"
11:06:03 <Rc43> It seems, that jhc can cross-compile http://repetae.net/computer/jhc/manual.html#crosscompilation
11:06:03 <elliott_> elliott: You have Stack space overflow: current size 40000000 bytes.
11:06:04 <elliott_> Use `+RTS -Ksize' to increase it.
11:06:04 <lambdabot> elliott_: You have 1 new message. '/msg lambdabot @messages' to read it.
11:06:12 <elliott_> .
11:06:12 <elliott_> ..
11:06:13 <elliott_> ...
11:06:14 <cmccann> haha
11:06:17 * monochrom proposes the Hilbert Gmail Account
11:06:21 <elliott_> .....................
11:06:29 <elliott_> ski: You will suffer.
11:07:43 <elliott_> @messages-off
11:07:44 <lambdabot> Unknown command, try @list
11:07:48 <elliott_> @list tell
11:07:49 <lambdabot> tell provides: tell ask messages messages? clear-messages
11:07:50 <monochrom> Hilbert's GMail account has infinitely many messages. another infinitely many messages are to arrive. how to accomodate them? :)
11:07:56 <elliott_> Huh, I thought you could get lambdabot to shut up about messages.
11:08:02 <elliott_> monochrom: select all, mark as read
11:08:08 <monochrom> haha
11:08:09 <elliott_> that's how you solve any email overload problem
11:09:10 <_Mikey> ski: I've figured out my types. http://paste.lisp.org/display/127248#2 I'm not sure if its clearer though
11:10:17 <ski> elliott_ : sorry, i couln't resist
11:10:25 <elliott_> @tell ski It's okay. I forgive you.
11:10:25 <lambdabot> Consider it noted.
11:11:16 <OceanSpray> is bryan o'sullivan ever in this channel?
11:11:22 <monochrom> yes
11:11:43 <OceanSpray> got some questions regarding llvm-base-3.0.0.0
11:12:23 <OceanSpray> I import LLVM.FFI.Core, and when I try to build my program I run into a bunch of missing symbols
11:12:50 <rostayob> OceanSpray: bryon o'sullivan is bos here
11:14:17 <ski> @messages
11:14:17 <lambdabot> elliott_ said 3m 52s ago: It's okay. I forgive you.
11:14:48 <elliott_> We need a @messages!.
11:14:56 <elliott_> To go with @messages?.
11:15:13 <ski> preflex: xseen preflex
11:15:57 <elliott_> haha
11:16:01 <elliott_> @seen preflex
11:16:01 <lambdabot> Unknown command, try @list
11:17:29 <ski> _Mikey : you have two unclosed brackets in the type signature for `setDir'
11:18:23 <ski> `targetV == []' is better written as `null targetV'
11:18:41 <tommd> rc43: Xen is a hypervisor, yes.
11:18:41 <_Mikey> ahh sorry,
11:18:45 <ski> `isAntAtNode graphT (head targetV) == False' is better written as `not (isAntAtNode graphT (head targetV))'
11:19:15 <_Mikey> ahh ok
11:19:37 <ski> i suggest you define
11:19:45 <ski>   type Graph = (Array Vertex [Vertex], Int -> (Maybe Ant, Point, [Point]), Point -> Maybe Vertex)
11:20:28 <ski> and use that to shorten the type signtures of `moveAnt' and `senseSur' (and maybe `setDir' as well -- i don't know)
11:21:11 <_Mikey> yea that makes sense
11:21:40 * hackagebot shake 0.2 - Build system library, like Make, but properly supports generated files.  http://hackage.haskell.org/package/shake-0.2 (NeilMitchell)
11:22:07 <ski> (or maybe you want to call it `GraphT' or something else, i dunno)
11:22:54 <_Mikey> calling it graphTuple but yea :)
11:23:02 <_Mikey> GraphTuple*
11:23:20 <ski> btw, i think `liftM moveAnt (return graphT) (return nd)' is probably not what you want -- i.e. the `return's in there are probably inappropriate
11:23:54 <srhb> :t lines
11:23:55 <lambdabot> String -> [String]
11:24:52 <ski> actually, i'm not sure why you're trying to use `liftM' with `moveAnt' here at all -- `moveAnt' doesn't seem very monadic to me
11:25:22 <ski> (i'm assuming you don't want to use the environment monad `(Int ->)' ..)
11:26:36 <ion> > let f !_ = 42 in f undefined
11:26:37 <lambdabot>   *Exception: Prelude.undefined
11:26:42 * hackagebot fb 0.6.0.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.6.0.1 (FelipeLessa)
11:27:19 <_Mikey> ski, yea, moveAnt is pure, my only intention of running it in the do block is to make sure it happens after the surroundings have been sensed and the decision has been made ect..
11:28:11 <ski> why not
11:28:16 <cmccann> _Mikey, "pure" and "happens after" don't really make sense
11:28:23 <ski>   let graphT2 = moveAnt graphT nd
11:28:26 <ski> ?
11:29:02 <_Mikey> could graphT2 then be returned by the do function?
11:29:06 <augur> hpaste is down!
11:29:13 <ski> _Mikey : if you want to, sure
11:29:15 <augur> whoever owns hpaste please renew your domain!
11:29:24 <_Mikey> :)
11:29:44 <elliott_> HEY GUYS I HEAR HPASTE IS DOWN!
11:30:10 <augur> elliott_: shut up :P
11:30:14 <augur> i dont know who knows what ok
11:30:15 <augur> gosh
11:30:24 <elliott_> :P
11:30:25 <ski> <lambdabot> hpaste has changed DNS but it hasn't propagated everywhere yet; you can set http://dpaste.org/PriqI/ in your /etc/hosts file in the meantime
11:30:33 <elliott_> ski: nooo! we eradicated that entry!
11:30:37 * augur beats elliott_ to death
11:30:45 <chrisdone> ¿someone say hpaste is down?
11:30:49 <elliott_> no resurrecting the dead in #haskell
11:30:53 <elliott_> the garbage collector is there for a reason
11:31:54 <tkahn6> what's the correct way to express a computation that takes a list and an initial value and a function such that the function's value is dependent on the result of the last computation?
11:32:04 * ski didn't see any reason for GCing that
11:32:13 <tkahn6> and it builds up a list of the answers
11:32:50 <Palmik> Hi guys, is there some haskell library for calculating syntactical/transitional monoids from given automata?
11:32:50 <cmccann> tkahn6, not entirely sure what you want, some sort of scan maybe?
11:33:07 <ski> > scanl (+) 100 [1,2,3]  -- tkahn6, like that ?
11:33:08 <lambdabot>   [100,101,103,106]
11:33:17 <tkahn6> yes!
11:33:19 <tkahn6> thanks guys
11:33:20 <mm_freak> i suppose splitLookup + maxView are the only way to query the element at index k or smaller in a Map?
11:33:31 <ski> > scanl1 (+) [1,2,3]  -- also this
11:33:31 <lambdabot>   [1,3,6]
11:33:47 <cmccann> > scanl1 (+) []
11:33:48 <lambdabot>   []
11:33:53 <mm_freak> or rather:  i want to query the element with the largest index that is less than or equal to k
11:36:42 * hackagebot yesod-auth-fb 0.0 - [PREVIEW] Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-0.0 (FelipeLessa)
11:40:55 <_Mikey> ski:?
11:41:01 <_Mikey> ski: You saved me!
11:41:04 <_Mikey> thanks man!
11:41:05 <mizu_no_oto> http://paste.lisp.org/display/127250
11:41:34 <ski> _Mikey : huh ?
11:41:42 * hackagebot OpenCLWrappers 0.1.0.0 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.1.0.0 (EmilKarlson)
11:41:57 <_Mikey> it just needed to be inside a let and it was fine.
11:42:14 <_Mikey> I now having a proper moving ant. :)
11:42:23 <mizu_no_oto> I'm trying to generate a list of lists of randomly shuffled elements, but I'm always getting back the same shuffled sequence
11:42:24 <ski> heh, ok
11:42:25 <ski> nice
11:42:27 <_Mikey> just has no idea where its going.
11:42:28 <_Mikey> :)
11:42:58 <ski> isn't that how it usually is with ants ..
11:43:18 <_Mikey> they can sense pheremone levels of their immediate area
11:43:50 <_Mikey> and they use that to make rough decisions on where they'll go next depending on wether they're exploring or looking for food or...
11:44:17 <_Mikey> but I know at some point I'll need to get my head around lift.
11:44:21 <_Mikey> Hey Peaker.
11:44:36 <ski> mizu_no_oto : why did you expect anything different ?
11:45:32 <mizu_no_oto> ski: did you check the paste?
11:45:38 <ski> yes
11:46:09 <ski> mizu_no_oto : to get different results upon subsequent commands in GHCi, you'll need to not use the same PRNG each time
11:46:35 <arcatan> mizu_no_oto: did you inted shufflers' to use randomGens'?
11:46:48 <ski> either by (re)binding a variable in GHCi, or by using one or more of `newStdGen',`getStdGen',`setStdGen'
11:46:48 <mizu_no_oto> arctan: yes
11:47:43 <mizu_no_oto> Ski: shouldn't using unfoldr on split on the PRNG mean I have an infinite list of *different* PRNGs?
11:48:06 <Peaker> _Mikey: hey
11:48:11 <_Mikey> :)
11:48:11 <ski> hm, i suppose i'd expect that (up to some approximation)
11:48:16 <dominikh> *sigh* I have yet another question: http://learnyouahaskell.com/functors-applicative-functors-and-monoids has the following paragraph: „You can view lists as non-deterministic computations. A value like 100 or "what" can be viewed as a deterministic computation that has only one result, whereas a list like [1,2,3] can be viewed as a computation that can't decide on which result it wants to have, so it
11:48:18 <dominikh> presents us with all of the possible results“ – I fail to see what's non-deterministic about lists :/
11:48:22 <_Mikey> It's been along time
11:48:55 <ski> > do "what"; "??"
11:48:56 <lambdabot>   "????????"
11:49:28 <dominikh> (especially because "what" is a list, after all...)
11:49:43 <mizu_no_oto> arctan:  having fixed shufflers', I'm still getting the same problem: *Main Control.Applicative Control.Arrow> take 10 $ shufflers' <*> repeat [1..10]
11:49:45 <mizu_no_oto> [[3,8,10,7,1,9,5,4,6,2],[3,8,10,7,1,9,5,4,6,2],[3,8,10,7,1,9,5,4,6,2] ...]
11:49:48 <ziman> > "four"; "x"
11:49:49 <lambdabot>   <no location info>: parse error on input `;'
11:49:57 <doserj> dominikh: the key is the last part of your quote
11:50:00 <ziman> > do "four"; "x"
11:50:01 <lambdabot>   "xxxx"
11:50:37 <doserj> dominikh: "a computation that can't decide on which result it wants to have, so it presents us with all of the possible results"
11:50:55 <Peaker> > nubBy (((0==).) . mod) [2..]
11:50:55 <monochrom> take this list comprehension: [ x+y | x<-[1,2,3], y<-[4,5,6] ]. if you are outside, you get the list of all answers, nothing non-deterministic about it, sure. if you are inside, x could be one of 3 choices, y could be one of 3 choices, that's non-deterministic.
11:50:58 <elliott_> dominikh: It lets you *model* nondeterministic computation.
11:51:00 <lambdabot>   mueval: ExitFailure 1
11:51:00 <lambdabot>  mueval: Prelude.undefined
11:51:04 <ski> dominikh : there's two main flavours of nondeterminism : (a) angelic (aka all-solutions) nondeterminism, where you get to pick which solution you want out of all of them ; (b) demonic (aka commited-choice) nondeterminism, where the system chooses one solution for you, out of all possible
11:51:16 <elliott_> dominikh: You know Prolog? It's basically Prolog without cut.
11:51:32 <dominikh> oh!
11:51:53 <elliott_> (Well, with different syntax, obviously.)
11:51:55 <monochrom> similarly (\x y -> x+y) <$> [1,2,3] <*> [4,5,6]
11:51:58 <elliott_> And the value of the resulting list is all the possible results.
11:52:08 <mizu_no_oto> Shouldn't either randomGens or randomGens' ensure I have an infinite list of *different* PRNGs, and mapping shufflers over that PRNG list ensure I have an infinite list of *different* shuffling functions?
11:52:13 <ski> dominikh : lists implements the angelic kind, while randomness and (usually) concurrency gives rise to the demonic kind
11:52:36 <ski> elliott_ : well, without the logic variables with unification, as well
11:52:40 <dominikh> doserj, ski, elliott_: thanks :) Weird formulation in the book though, imho
11:54:12 <ski> dominikh : i think the angelic nondeterminism kind isn't that uncommon to call "nondeterminism"
11:54:20 <elliott_> dominikh: it makes more sense if you're already used to it :)
11:54:38 <dominikh> ski: oh, the non-deterministic part makes sense now, but the book kind of mentions it out of context
11:54:49 <ion> IIRC LogicT extends something similar to the list monad with an equivalent to cut.
11:55:48 <ski> ion : and logic variables ?
11:56:22 <ski> (`ifte' (or whatever it was called in `LogicT') is much more well-behaved than cut)
11:56:25 <elliott_> LogicT is also better behaved with infinite lists.
11:56:34 <elliott_> Well, infinite probabawatchits.
11:57:00 <ski> "goals with infinite number of solutions"
11:57:07 <ski> (or something like that)
11:58:42 <ski> mizu_no_oto : btw -- maybe you meant to use  randomGens'  instead of  randomGens  in the definition of  shufflers'  ?
12:00:15 <mizu_no_oto> ski - yes, I mentioned that to arctan a few minutes ago
12:00:56 <ski> sorry, missed that
12:01:08 <mizu_no_oto> ski: no problem
12:02:29 <keep_learning> Hello all
12:02:36 <_Mikey> hey
12:02:58 <keep_learning> when we write +RTS -N -RTS without specifying a number then how many cores it takes ?
12:03:17 <_Mikey> Alllll the cores
12:03:21 <TTimo> ahah
12:03:26 <_Mikey> I have no idea..
12:03:26 <TTimo> AAAALLLL the cores
12:03:28 <monochrom> all
12:03:30 <_Mikey> oh
12:03:35 <_Mikey> maybe I'm right.
12:04:16 <mizu_no_oto> take 3 $ map (show . head . randoms) $ randomGens evaluates to ["5804987072418920256","-7972125262551955815","8638968266971394880"].  So randomGens is a list of different PRNGs.  But somehow, when applying those different PRNGs to shuffle'', we get a shuffle function that seemingly only depends on the initial seed value used to make the initial PRNG.
12:04:53 * ski would start trying  shuffle'  itself directly on various different `StdGen's
12:04:59 <keep_learning> monochrom,  is there any function in haskell to know how many cores i have ?
12:06:12 <Enigmagic> @hoogle numCapabilities
12:06:12 <lambdabot> GHC.Conc.Sync numCapabilities :: Int
12:06:12 <lambdabot> GHC.Conc numCapabilities :: Int
12:06:45 <elliott_> mizu_no_oto: It sounds like shuffle'' is broken somehow, then.
12:06:45 <Enigmagic> keep_learning: that'll tell you how many haskell capabilities are allocated, which might be what you want
12:06:50 <elliott_> I guess that's fairly obvious.
12:06:59 <elliott_> huh @ numCapabilities
12:07:02 <elliott_> isn't that like getArgs :: [String]?
12:07:13 <elliott_> vary-able without even recompilation
12:07:26 <Enigmagic> yes
12:07:33 <Enigmagic> and during runtime
12:08:03 <elliott_> what, seriously?
12:08:05 <Enigmagic> yes
12:08:11 <elliott_> that's horrible, someone kill it
12:08:19 <elliott_> wait how does that even work
12:08:24 <elliott_> numCapabilities is going to be a CAF
12:08:33 <elliott_> so it's not going to be even able to vary
12:08:50 * ski idly wonders about `GHC.Conc.numCapabilities' and mobile code
12:08:59 <Enigmagic> the runtime allows adjusting the number of capabilities
12:09:10 <elliott_> ski: mobile as in "transportable"?
12:09:16 <ski> aye
12:09:17 <elliott_> Enigmagic: yeah, but numCapabilities can't reflect that
12:09:21 <elliott_> ski: don't worry, that's broken without even venturing into GHC.*
12:09:28 <Enigmagic> elliott: yeah well the API is broken :P
12:09:31 <elliott_> ski: first by Int, then by Word, then by the os/platform things that are in some base module
12:09:36 <keep_learning> Enigmagic, it show 1 so it means i have one core for use ?
12:09:48 <Enigmagic> keep_learning: yes, it means that only one core will be used to run haskell code at a time
12:10:40 <keep_learning> Enigmagic, thank you
12:10:53 <Enigmagic> np
12:11:40 <ChristianS> numCapabilities :: Int
12:11:42 * hackagebot wai-middleware-route 0.2.0 - Wai routing middleware  http://hackage.haskell.org/package/wai-middleware-route-0.2.0 (AlexanderDorofeev)
12:11:46 <ChristianS> the value passed to the +RTS -N flag.
12:12:06 <Enigmagic> i guess they've also added: getNumCapabilities :: IO int-- Defined in GHC.Conc.Sync
12:12:16 <Enigmagic> doesn't show up in mah hoogle database though
12:12:28 <ChristianS> getNumCapabilities :: IO Int . GHC notes: this returns the number passed as the argument to the +RTS -N flag. In current implementations, the value is fixed when the program starts and never changes, but it is possible that in the future the number of capabilities might vary at runtime.
12:12:48 <Enigmagic> it's possible in 7.4 to change the number at runtime
12:13:48 <mizu_no_oto> Geh.  I see what my problem was.  I was using <*> to apply those shufflers, and, having assumed that <*> was probably like zip rather than >>= (i.e. rather than giving nondeterminism, it applied the first function to the first value, the second...), called it using shufflers <*> repeat [1..10] rather than shufflers <*> [[1..10]]
12:13:50 <keep_learning> Enigmagic, it means that  for certain part of my code can be run  arbitrary number of processor.
12:14:01 <elliott_> mizu_no_oto: that would be ZipList you are looking for
12:14:03 <keep_learning> Enigmagic, during run time
12:14:07 <elliott_> mizu_no_oto: Applicative instances should agree with Monad instances
12:14:11 <elliott_> (ZipList isn't a monad)
12:14:15 <_Mikey> @hoogle a->b [a]
12:14:15 <lambdabot> Control.Monad.List runListT :: ListT a -> m [a]
12:14:15 <lambdabot> Prelude repeat :: a -> [a]
12:14:15 <lambdabot> Data.List repeat :: a -> [a]
12:14:19 <elliott_> agree as in pure = return, (<*>) = ap
12:14:40 <_Mikey> hmm,
12:14:40 <Rc43> Is cabal-install included in haskell platform on windows?
12:14:48 <_Mikey> guys, what am I looking for
12:14:49 <Enigmagic> keep_learning: if you use threads then multiple threads can be run in parallel
12:14:53 <Rc43> I don't see cabal.exe in .../Haskell/bin
12:15:02 <_Mikey> ahh
12:15:03 <_Mikey> I've got it
12:15:10 <_Mikey> a fold.
12:15:12 <Enigmagic> keep_learning: but you need to enable it by compiling with -threaded and specifying +RTS -N -RTS on the command line when running your program
12:15:15 <dcoutts> Rc43: yes
12:15:18 <keep_learning> Enigmagic, i am interested in dph.
12:15:19 <dmwit> Rc43: Yes, cabal should be included. Where is ghc.exe?
12:15:26 <_Mikey> :t fold
12:15:27 <lambdabot> Not in scope: `fold'
12:15:30 <_Mikey> :t foldr
12:15:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:15:36 <Rc43> dmwit, in ../bin
12:16:02 <Enigmagic> keep_learning: i don't know about dph, sorry
12:16:14 <keep_learning> Enigmagic, sounds promising  :)
12:16:24 <Rc43> dmwit, and there are other related stuff, but without cabal
12:16:39 <keep_learning> Enigmagic, long way to go  in learning haskell
12:17:38 <Rc43> dmwit, but there is Cabal dir in .../lib
12:17:49 <kallisti> mizu_no_oto: oh hi
12:19:09 <mizu_no_oto> One more quick thing:  which one of these is the generally "better" idea?  randomGens = "unfoldr (toMaybe . split) (mkStdGen seed)", "map mkStdGen (randoms $ mkStdGen $ seed)" or "map mkStdGen [1..]"?  It's just for a simple monte-carlo based tic-tac-to AI
12:22:18 <dmwit> Rc43: dunno for sure; maybe check the rest of your PATH environment variable?
12:23:17 <Rc43> dmwit, yeah, you are right, thanks
12:23:30 <Rc43> dmwit, it is in extralibs/bin
12:23:42 <Rc43> * lib/extralibs/bin
12:25:17 <Rc43> haskell platform installs mingw; mingw install cygwin; right?
12:25:26 <Rc43> so how can I launch shell?
12:25:53 <TTimo> mingw doesn't install cygwin
12:26:15 <TTimo> as for your first assertion, I don't know if true or false myself
12:26:49 <Rc43> TTimo, but is uses gcc; gcc works under windows?
12:26:49 <TTimo> there is a mingw shell though, but it's possible the platform doesn't install it ?
12:27:56 <TTimo> generally speaking, yes gcc works under windows
12:30:32 <elliott_> it's msys shell, no?
12:30:34 <elliott_> not mingw proper
12:31:08 <hape01> cheater_: yes i think calibration takes some time.
12:31:16 <hape01> sorry - wrong channel
12:31:33 <Rc43> elliott, where it is?
12:32:31 <Rc43> eliott, I have seen msys and have used it hour before; it was installed with git. But now I have deinstalled git on windows.
12:33:41 <elliott_> Rc43: I doubt the Platform installs it.
12:33:43 <elliott_> It has no reason to.
12:37:01 <OceanSpray> so
12:37:24 <OceanSpray> I heard that GHC has its own little module for generating LLVM IR
12:37:46 <OceanSpray> are there any plans to extract it into its own package?
12:38:40 <danr> OceanSpray: Try mailing on the ghc-dev mailing list
12:40:19 <frerich_> If I'd like to write a chat application (say, an IRC client) which can receive messages as well as allows the user to send messages; so far I figured the reading part as well as the writing part out - but not both at once. Would 'forkIO' be the way to go, one thread for the reading and one for transmitting? If so, should I use a third thread fo writing to the socket handle, or are hGetLine and so on thread safe?
12:40:52 <OceanSpray> frerich, why so many threads?
12:41:01 <elliott_> OceanSpray: that's idiomatic in haskell
12:41:03 <elliott_> threads are very cheap
12:41:13 <elliott_> and blocking thread IO is implemented with non-blocking under the hood
12:41:18 <frerich_> OceanSpray: Well I don't *know* whether I have to us threads, but they seem easy (and I suspect they are easier to reason about in functional languages)
12:41:43 <elliott_> frerich_: you're talking about terminal IO, right?
12:42:02 <elliott_> i.e. one thread receiving from network and printing, the other getLine-ing in a loop and sending
12:42:11 <frerich_> elliott_: Yes; I have a socket connection and I'd like to print incoming messages to the terminal (and at the same time I'm reading a line from the terminal which the user can send)
12:42:20 <elliott_> if so, that sounds reasonable to me. but beware of incoming messages that will overwrite the message so far (you can use a readline-style library to avoid this)
12:42:22 <frerich_> elliott_: That's my current plan, using forkIO, yes. Just wonder whether it's sane.
12:42:28 <elliott_> overwrite as in visually (try ircing from netcat to see what i mean)
12:42:50 <frerich_> elliott_: Yes, of course. I was considering either using ANSI sequences for now to avoid this, or to look for something like ncurses + readline.
12:43:23 <frerich_> elliott_: Ok, so one thread for reading, one for writing. However, do I nede to synchronize accesses to the socket handle somehow?
12:43:45 <elliott_> No.
12:44:06 <elliott_> It should DTRT if you're just reading/writing from separate threads.
12:44:19 <monochrom> multi-threading is unsafe in other languages because mutable state is shared by default. multi-threading is safe in haskell because mutable state is unshared by default; hell, you don't even get mutable state by default
12:44:32 <elliott_> In general, the IO system can handle the locking itself and you don't have to worry about it.
12:45:14 <monochrom> there is no conflict with one thread just reading the Handle and another thread just writing the Handle
12:45:35 <frerich_> Ok, thanks.
12:45:56 <elliott_> frerich_: Another design you might consider: a thread that reads from the network and writes to a TChan (say networkChan); a thread that reads from the console and writes to a TChan (say userChan); the main thread does join $ atomically ((handleNetwork <$> readTChan networkChan) `orElse` (handleUser <$> readTChan userChan)).
12:46:20 <elliott_> handleNetwork would write the line out to the screen, handleUser would write it to the network.
12:46:36 <elliott_> That would make it easier to do "fancy" console things like curses input lines that work when new messages come in.
12:46:38 <Clint> should lambdabot break on this?
12:46:39 <elliott_> And is more flexible in general.
12:46:40 <Clint> @pl \(y,_,_) -> y
12:46:40 <lambdabot> (line 1, column 6):
12:46:40 <lambdabot> unexpected ","
12:46:40 <lambdabot> expecting operator or ")"
12:46:40 <lambdabot> ambiguous use of a non associative operator
12:46:48 <elliott_> pl does not understand tuples
12:46:58 <elliott_> well
12:47:01 <elliott_> pattern-matching, really
12:47:08 <Clint> it seems to understand pairs
12:47:53 <Saizan> it always did, but you can patch it if you want :)
12:48:03 <elliott_> Clint: It's pattern-matching it can't do.
12:48:06 <elliott_> @pl \x -> (x,42)
12:48:06 <lambdabot> flip (,) 42
12:48:09 <elliott_> @pl \x -> fst x
12:48:09 <lambdabot> fst
12:48:14 <elliott_> @pl \(x,y) -> x
12:48:14 <lambdabot> fst
12:48:14 <elliott_> Huh.
12:48:23 <elliott_> OK, I don't know.
12:48:24 <elliott_> @pl \(y,z,a) -> y
12:48:25 <lambdabot> (line 1, column 6):
12:48:25 <lambdabot> unexpected ","
12:48:25 <lambdabot> expecting letter or digit, operator or ")"
12:48:25 <lambdabot> ambiguous use of a non associative operator
12:48:28 <elliott_> @pl \(y, z, a) -> y
12:48:29 <lambdabot> (line 1, column 7):
12:48:29 <lambdabot> unexpected ","
12:48:29 <lambdabot> expecting letter or digit, operator or ")"
12:48:29 <kallisti> @pl \Just x -> x
12:48:31 <lambdabot> ambiguous use of a non associative operator
12:48:32 <elliott_> Okay, tuples only.
12:48:33 <lambdabot> const id
12:48:42 <elliott_> I guess it just treats , like any other binary operator from the looks of it.
12:49:03 * Clint grunts.
12:49:24 <frerich_> eliott_: Hm, I understand the "three threads" suggestion, but you missed me on the last step - how does it make fancy things easier than just having e.g. one thread for receiving and printing to the terminal, and the main thread sits there waiting for input and writes it?
12:49:40 <danr> there are no standard functions operating on triples either
12:50:06 <elliott_> Clint: You probably shouldn't be using triples, anyway.
12:50:39 <elliott_> frerich_: Because it's one loop controlling the whole thing, so you don't have to worry about thread co-ordination. For instance, the "print out new line from server" handler might want to erase the input line, stop the readline stuff, print out the new line, and then restore it.
12:50:58 <elliott_> Which probably won't interact well with the read-input thread still trying to do those things.
12:51:01 <Clint> elliott_: it's Data.Time.Calendar that's using triples
12:51:17 <elliott_> frerich_: OK, I'm lying, that isn't the real reason I'd do it.
12:51:31 <elliott_> I'd just do it because it seems more modular and separates out different UI concerns from plumbing.
12:54:43 <frerich_> elliott_: Yeah I see what you mean. However, maybe there's an even better reason; maybe one of the approaches works better if you consider multiple chat rooms (say: multiple IRC servers), so you have multiple remote systems at the same time. I suspect that the 'one thread to handle incoming data, main thread handles user input/sending' would work quite well in this case?
12:55:09 <frerich_> you somehow have to have a way to change the handle used by the main thread, so that you can redirect the user input to whatever chat server/chat room is "active"
12:55:12 <elliott_> Well, you'd still need another thread to actually do the getLine-equivalent in a loop, since it blocks.
12:55:29 <elliott_> But yes, having a bunch of threads plumbing outside sources into TChans and then coordinating them with a main thread makes sense.
12:55:35 <elliott_> (TChans, not Chans, because you want orElse.)
12:56:07 <frerich_> elliott_: Thanks for your thoughts, I think I'll just try one of those ideas and see how it works out. :)
12:57:35 * ski . o O ( `type TChan = GenChan TVar' )
12:59:17 <elliott_> ski: is there really such a GenChan that also has Chan = GenChan MVar?
12:59:28 <elliott_> that would surprise me since Chans have different semantics
12:59:55 <ski> i know of no such thing
13:00:06 <ski> just idly pondering whether it might be possible
13:00:44 <ski> (possibly with some small inessential semantics modification)
13:01:36 <kallisti> a typeclass would seem reasonable.
13:08:24 <elliott_> ski: ok, Chan a ~ (MVar (Stream a), MVar (Stream a)), where Stream a ~ MVar (a, Stream a)
13:09:12 <elliott_> ski: TChan a ~ (TVar (TVarList a), TVar (TVarList a)) where TVarList a ~ TVar (TList a), TList a = TNil | TCons a (TVarList a)
13:09:16 <elliott_> so, similar... but not quite the same
13:09:27 <elliott_> and i don't know how well the operations themselves match up
13:10:21 <ski> @hoogle newEmpty
13:10:21 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
13:10:21 <lambdabot> Control.Concurrent.SampleVar newEmptySampleVar :: IO (SampleVar a)
13:10:21 <lambdabot> Control.Concurrent.STM.TMVar newEmptyTMVar :: STM (TMVar a)
13:10:26 <ski> @hoogle+
13:10:26 <lambdabot> Control.Concurrent.STM.TMVar newEmptyTMVarIO :: IO (TMVar a)
13:10:55 * ski can't recall seeing `TMVar' before
13:11:34 <Axman6> it's always been there afair
13:11:36 <TTimo> ooh transactional memory
13:11:41 <elliott_> it's just TVar . Maybe
13:13:23 <cmccann> (Stream a) and (TVarList a) should be equivalent
13:14:24 <cmccann> the head and tail MVars in Chan could be empty though, unlike the TVars in TChan
13:16:59 <elliott_> oh right, MVars can be empty
13:17:06 <elliott_> cmccann: i doubt they ever are in Chan(?)
13:17:23 <cmccann> I wouldn't know
13:17:32 <elliott_> i guess you really would need TChan = GenChan TMVar to make it work consistently with MVar
13:17:52 <Rc43> elliott_, > I doubt the Platform installs it. < So how to use cabal?
13:17:55 <cmccann> but I guess it amounts to a Chan can possibly be absent entirely whereas a TChan will always have at least an empty queue
13:21:09 <elliott_> Rc43: cmd.exe?
13:23:36 <Rc43> elliott_, it is ugly
13:28:48 <niteria> I just saw a cool thing, emacs has this mode where it replaces fn in Clojure to nice looking f
13:29:00 <niteria> Is there something similar for Haskell and vim?
13:29:54 * osfameron doesn't understand why people want that sort of thing
13:30:02 <adimit> niteria: haven't looked at Emacs/Clojure, but you might want to check out haskell-conceal.
13:30:11 <frerich_> niteria: Something like http://imageshack.us/photo/my-images/840/unicodehaskell.png/ ?
13:30:59 <niteria> frerich_: Yes, something like that
13:31:05 <frerich_> niteria: If so, https://github.com/frerich/unicode-haskell might be useful to you.
13:31:53 <niteria> frerich_: that's exacly what I'm looking for :)
13:33:07 <ski> frerich_ : what's the empty set doing in `main' ?
13:33:26 <adimit> niteria: there's also https://github.com/Twinside/vim-haskellConceal, which doesn't actully alter the source code, but uses vim's conceal feature.
13:33:30 <elliott_> Rc43: Okay.
13:33:36 <elliott_> Rc43: It's still how to use cabal.
13:34:34 <Rc43> elliott_, msys is a part of mingw, right?
13:35:06 <frerich_> adimit: I think the conceal thing is really nice! IWasn't aware of that
13:35:13 <elliott_> No; as in, the MinGW distribution-thingy does not include MSYS.
13:35:18 <elliott_> MSYS is an optional extra thing.
13:35:32 <frerich_> ski: I just looked for a funky replacement for ()
13:35:57 * ski would rather expect it stood for `Void'
13:36:10 <niteria> feels weird and laggy
13:36:43 <adimit> frerich_: the good thing is tht when you actually hover over the line you're editing, conceal is disabled, so you're not editing symbols, but actualy haskell code.
13:36:44 <ski> (and using `2,3 :: IO ()' seems also weird :)
13:36:44 <ejbs> How come this does not work: (x !! $ length x / 2)  == search. It's complaining about my dollar signs (what should I call them?).
13:36:51 <elliott_> frerich_: that should mean Void, yeah
13:37:16 <rwbarton> ejbs: it's like writing  x + * y
13:37:21 <elliott_> ejbs: Just remove the $.
13:37:28 <rwbarton> and add parentheses
13:37:30 <elliott_> Also, you'll need `div`, not /
13:37:36 <frerich_> adimit: Hm that's pretty nice indeed. Did you write that vim-haskellConceal plugin?
13:37:36 <elliott_> Since you want integer division.
13:37:38 <rwbarton> I assume?
13:37:54 <elliott_> > ([]!!1`div`2)
13:37:55 <lambdabot>   *Exception: Prelude.(!!): index too large
13:37:59 <elliott_> > ([0]!!1`div`2)
13:38:00 <lambdabot>   *Exception: Prelude.(!!): index too large
13:38:01 <adimit> frerich_: no, but I did contribute a bit.
13:38:03 <elliott_> Right.
13:38:20 <adimit> frerich_: you can look at the commit history, there's a pull-req I did a while ago.
13:38:20 <ejbs> Okay, thanks
13:38:22 <niteria> frerich_: everytime I press space it lags
13:38:30 <rwbarton> oh right, I assumed that you wouldn't have tried the $ if you didn't need parentheses :)
13:38:32 <niteria> frerich_: is that expected?
13:39:05 <niteria> I'm not using gvim, just normal vim
13:39:32 <elliott_> ejbs: yeah, ($) is not part of syntax
13:39:38 <elliott_> it is just an operator with a really low precedence
13:39:40 <elliott_> f $ x = f x
13:41:18 <adimit> niteria, frerich_, here's a shot of what i'm working on right now with haskell-conceal enabled: http://imgur.com/F7Xio.png
13:42:23 <frerich_> adimit: I just played with the conceal feature a bit, I think that approach is much nicer than the silly hack I did
13:43:12 <adimit> yeah, it gets rid of all the lagging, but it's a vim 7.3 addition, and it's not even enable by default, i.e. you need to compile with 'huge' or so.
13:43:21 <frerich_> Yeah, but I have that :)
13:43:29 <adimit> granted, most distros' vims are actully compiled with huge.
13:44:17 <adimit> the plugin itself could need some work (it doesn't do well on some lambdas, and I'd like to prettify it a bit more…)
13:44:39 <adimit> but I'm too busy writing actual haskell code instead of fighting the abomination that is vimL
13:46:37 <niteria> adimit: way too cool, doesn't lag and editing makes more sense
13:47:09 <adimit> niteria:  :-)
13:47:43 <niteria> unfortunately unicode arrow doesn't fit in one character
13:47:51 <niteria> it's clipped
13:49:44 <adimit> niteria: that's your font's/vim's fault.
13:50:05 <adimit> it sometimes fucks up boxes
13:50:29 <niteria> I know, maybe I can use shorter arrow
13:51:19 <adimit> niteria: try changing the font and/or dpi or font size.
13:51:53 <niteria> but I like my font ;p
13:52:09 <prof7bit> Sorry for interruption, quick question: I'm just experimenting with records and provoked this problem: http://pastebin.com/mHHyEXBv it cannot declare the functins a and b twice. Although nobody forces me to do this in the same module I wonder why there isn't some kind of function overloading like in other statically typed languages where I can simply use the same function name with different type signatures? Is there some fundame
13:52:09 <prof7bit> ntal restriction in Haskell that would not allow such a thing?
13:53:23 <prof7bit> Multiple declarations of `Main.a'
13:53:24 <elliott_> prof7bit: the record system is uh
13:53:40 <elliott_> less adequate than most people would like
13:53:40 <elliott_> what you're asking for is "type-directed name resolution", a fairly popular proposal
13:53:41 <elliott_> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
13:53:41 <donri> @where tdnr
13:53:42 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
13:53:46 <elliott_> it's definitely not as easy as you probably think
13:54:05 <elliott_> in general, prefixing field names with the record's name (or an abbreviation of it) is the best route; or putting records in their own modules and using qualified imports
13:54:37 <donri> you can always put your accessors in typeclasses ;) ... until their types differ.
13:54:41 <Pseudonym> Records should introduce a namespace. IMO
13:55:16 <Pseudonym> But whether or not you agree with that assertion, this is yet another example of other languages outdoing Haskell when it comes to modules.
13:55:19 <Pseudonym> And namespaces.
13:55:20 <Axman6> there's a raging discussion on the GHC mailing list about what should be done about records
13:55:27 <niteria> it's weird because when I open haskell.vim file arrows overflows the box and renders ok, might be vim bug
13:56:29 <elliott_> Axman6: ooh, it's almost like every single preceding year in the haskell community ever
13:56:53 <Axman6> i've never seen this much discussion about it before
13:57:02 * donri used to be into TDNR but now wonders how well it works with lenses
13:57:27 <prof7bit> i didn't run into this problem accidentally, i intentionally provoked it (while reading the tutorial about records) just to see what would happen.
13:57:54 <Axman6> yeah i'm not sure whether lenses are the answer or not
13:57:57 <donri> well you're essentially defining a :: Foo -> Int; a :: Baz -> Int
13:58:01 <elliott_> prof7bit: now you know!
13:58:03 <elliott_> :p
13:58:41 <donri> and a haskell value can only have one type
13:59:28 <glguy> yesod-form question: Anyone know if you can modify the values of form fields between the time they are submitted and the time they are rendered out? runFormGet generates the widgets at the same time as it returns the previous results. Do I have to make my own forms via direct HTML and use "input form" to read the previous post?
13:59:29 <prof7bit> donri: from my experience with Pascal (another strongly typed language where I do these function overloads all day long) this would have worked
14:00:03 <elliott_> yes
14:00:05 <elliott_> haskell is not pascal
14:00:07 <Axman6> glguy: probably better to ask in #yesod
14:00:09 <prof7bit> yes
14:00:12 <prof7bit> i know
14:00:22 <Pseudonym> It's not even pronounced the same way.
14:00:23 <elliott_> they sound quite similar but they're spelled very differently so it shouldn't be too hard telling them apart :D
14:00:38 <Pseudonym> elliott: Uhm... no.
14:00:44 <glguy> Axman6: OK (I didn't realize there was a whole channel of yesod users)
14:00:44 <Axman6> Pseudonym: they're pretty similar in my mind...
14:00:44 <elliott_> well *vaguely* similar
14:00:51 <elliott_> prof7bit: more seriously, things that work for other languages do not necessarily work for haskell
14:00:58 <Pseudonym> pas-kahl, but hass-hell
14:01:03 <elliott_> uh
14:01:04 <Pseudonym> hasss-kell
14:01:06 <elliott_> the k is silent since wh- ok
14:01:09 <Pseudonym> Anyway.
14:01:10 <elliott_> prof7bit: pascal's type system is pretty close to being the polar opposite of haskell's, for instance
14:01:12 <Pseudonym> Sorry, mistype.
14:01:17 <donri> parseltongue much?
14:01:20 <elliott_> prof7bit: (and pascal doesn't do type inference, of course!)
14:01:29 <Pseudonym> karnt tipe today, i has teh dumb
14:01:31 <elliott_> plus since haskell has first-class functions, overloading gets even more difficult
14:02:13 * monochrom doesn't find pascal type system to be close to polar opposite of haskell type system
14:02:49 <elliott_> well, it's a hell of a lot simpler :)
14:03:09 <prof7bit> yes, its simpler. and easier to understand.
14:03:27 * glguy wonders what the original question was about overloading
14:03:36 <elliott_> prof7bit: why not use pascal, then? :p
14:03:52 <elliott_> glguy: two records with differently-typed, same-name fields in one module
14:04:26 <Axman6> Pseudonym: assembly is pretty easy to understand, might as well use that
14:04:30 <Axman6> uh, prof7bit
14:04:57 <lzsilica> I cannot intall haskell in windows environment
14:04:57 <elliott_> I just program in the SK calculus. Two rules, no complicated type system: the perfect language.
14:05:04 <Axman6> sure, you give up nicities like abstraction almost completely, but you know exactly whats happening
14:05:10 <roconnor> pfft
14:05:13 <roconnor> hpaste is expired
14:05:14 <Pseudonym> lzsilica: Which system are you trying to install?
14:05:15 <prof7bit> elliott_: i have used pascal since the 80's and still use it today (providing patches for Lazarus from time to time), I have spent my entire life with imperative languages, everything is imperative, I even have an imperative girlfriend. I need to learn something different.
14:05:20 <elliott_> @where ghost-of-hpaste-dns-past
14:05:20 <lambdabot> I know nothing about ghost-of-hpaste-dns-past.
14:05:31 <elliott_> roconnor: it's going to get better.
14:05:42 <Axman6> oh no, hpaste got SOPA'd
14:05:42 <elliott_> paste.lisp.org is official replacement until then
14:05:52 <lzsilica> I have win7 system. I wanna intall  official haskell software
14:06:10 <donri> @where hpaste-dns
14:06:10 <lambdabot> I know nothing about hpasta-dns.
14:06:17 <glguy> Brian O'Sullivan owned hpaste.org
14:06:22 <donri> why did you rewrite that to hpasta?
14:06:25 <elliott_> i didn't
14:06:30 <cmccann> mmm hpasta
14:06:34 <elliott_> prof7bit: ok... so when you run into something that haskell does differently, don't try and compare it to pascal, since in 99.9% of cases it'll just end up confusing you -- since the languages are very, very different and even concepts that have the same name are likely to be incomparable in the two
14:06:37 <Pseudonym> lzsilica: GHC, Hugs or something else?
14:06:43 <donri> but lambdabot did
14:06:43 <Axman6> donri: indeed o.O
14:06:48 <elliott_> lzsilica: http://hackage.haskell.org/platform/
14:07:01 <Axman6> @remember  < donri> @where hpaste-dns < lambdabot> I know nothing about hpasta-dns.
14:07:01 <elliott_> donri: someone will have done that in /msg :P
14:07:01 <lambdabot> Done.
14:07:09 <elliott_> Axman6: you just quoted <
14:07:09 <Axman6> @forget  < donri> @where hpaste-dns < lambdabot> I know nothing about hpasta-dns.
14:07:09 <lambdabot> Done.
14:07:17 <Axman6> @remember lambdabot < donri> @where hpaste-dns < lambdabot> I know nothing about hpasta-dns.
14:07:17 <lambdabot> I will never forget.
14:07:22 <Axman6> @quote lambdabot
14:07:22 <lambdabot> lambdabot says: * lambdabot secretly deletes lunabot's source code
14:07:27 <rwbarton> @where hpasta
14:07:27 <lambdabot> I know nothing about hpasta.
14:07:43 <lzsilica> I  did download the package on that page
14:07:48 <elliott_> @where+ hpasta-dns I know nothing about hpaste-dns.
14:07:48 <lambdabot> Okay.
14:08:01 <startling> what's the thing in parsec to get something surrounded by something else?
14:08:02 <elliott_> lzsilica: ok, run the installer then :)
14:08:04 <lzsilica> `````````````````````````````but always installation abortion
14:08:11 <Pseudonym> Clearly lambdabot hasn't been Touched by His Noodly Appendage.
14:08:13 <monochrom> haskell doesn't have a real record story. the record syntax is a fake record story. like the hologram room in Star Trek TNG
14:09:01 <ski> preflex: xseen lunabot
14:09:09 <ski> preflex: xseen preflex
14:09:19 <monochrom> so for example you can't have two "record" types with the same "field" name because "field" name is faked by function names.
14:09:20 <hpc> preflex: seen preflex
14:09:24 <hpc> :P
14:09:33 <ski> @where paste
14:09:34 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
14:09:58 <lzsilica> @elliott_:   installation abortion again.....
14:09:58 <lambdabot> Unknown command, try @list
14:10:09 <prof7bit> elliott_: Do you think my choice of learning Haskell was a good choice? My reasoning was trying to be as far away from imperative and strict as possible, thats why I did not chose scala for example because it would still allow me to escape into my old habits and old ways of thinking.
14:10:33 <monochrom> but records aside, pascal types and haskell types have more in common than in difference, let alone in opposite
14:10:35 <hpc> prof7bit: definitely
14:11:13 <Twey> @where hpaste-dns
14:11:14 <lambdabot> I know nothing about hpasta-dns.
14:11:16 <Pseudonym> prof7bit: Having said that, your language for 2013 should be a declarative logic language.
14:11:18 <Twey> ^ hpasta?  What?
14:11:57 <hpc> prof7bit: which basically means "just prolog" - you might also like to try agda, if you find yourself loving haskell
14:12:07 <elliott_> prof7bit: Sure.
14:12:13 <Pseudonym> Mercury would be my suggestion, but I'm biassed.
14:12:14 <elliott_> Learning Haskell at any point is a good idea.
14:12:23 <elliott_> Twey: Beats us!
14:12:44 <Twey> Pseudonym: Why Mercury?
14:13:08 <Pseudonym> Twey: Unlike Prolog, it's actually declarative.
14:13:33 <Pseudonym> Another good choice for a language to break imperative thinking is Erlang.
14:14:15 <Pseudonym> But I think you should spend some time in pure declarative land first, otherwise the temptation to write imperative code in Erlang is too great.
14:14:20 <elliott_> I think it takes more than a year to learn Haskell.
14:14:23 <monochrom> mercury is certainly more well thought out than prolog
14:14:24 <elliott_> So don't make plans for 2013 too quickly.
14:14:38 <mm_freak> hpc: if you love haskell, don't try agda…  it will ruin you for haskell =)
14:14:44 <Pseudonym> elliott: This is the Pragmatic Programmers "learn a language a year" thing.
14:14:54 * Pseudonym hasn't picked a language for this year yet
14:14:54 <mm_freak> just like haskell ruins you for…  well…  pretty much any other language ;)
14:14:56 <donri> what does it mean to "have learned haskell"?
14:15:02 <Pseudonym> I think it might be Scala.
14:15:08 <monochrom> "learning a new language in IO days" --- a spam
14:15:17 <kallisti> mm_freak: I can program in other languages just fine.
14:15:20 * cmccann had a decent grasp of Haskell within a year, enough to actually use it productively
14:15:32 <elliott_> Pseudonym: Sounds faddish and counterproductive to me.
14:15:41 <elliott_> cmccann: Oh, certainly you can do things in Haskell in a year.
14:15:48 <mm_freak> kallisti: at least if you're an enthusiast to some degree
14:15:56 <elliott_> But to spend a year on it and then go "OK, time for (Mercury|Agda|...)" is a bad decision.
14:16:02 <Pseudonym> elliott_: Do you have a better choice? My other option was Squirrel, which is even more faddish and counterproductive.
14:16:09 <elliott_> Pseudonym: Oh, no, I didn't mean the language choice.
14:16:13 <elliott_> I just meant the language-a-year thing.
14:16:15 <Pseudonym> Ah.
14:16:19 <prof7bit> for me learning Haskell does not feel like learning yet another language. It feels more like learning programming for the first time.
14:16:25 <mm_freak> of course a purely pragmatic programmer won't have problems using other languages…  but on the other hand a purely pragmatic programmer probably never learns haskell anyway
14:16:33 <Pseudonym> Eventually you reach a critical mass of languages where you don't need more than a year to get the idea.
14:16:41 <Pseudonym> Even if you don't attain full fluency.
14:16:50 <Pseudonym> For me, it was somewhere around #45.
14:16:52 <elliott_> I mean, I appreciate the spirit behind it, but it seems both too rigid (i.e. why always a year?) and too lax ("learn a language" isn't a very well-defined task).
14:17:06 <monochrom> I don't think anyone implies "don't use languages you learned" in "learn a language this year"
14:17:07 <ziman> hm, mercury looks interesting
14:17:08 <elliott_> Pseudonym: That's mostly because it's harder to find languages that aren't rehashes of what you already know.
14:17:30 <monochrom> so yes, by the time you're 70, you will be using 50 languages simultaneously that year
14:17:31 * cmccann suggests learning malbolge 
14:17:38 <mm_freak> after learning C++, haskell, scheme, prolog and assembly, i feel that now i can pick up pretty much any language quickly
14:17:38 <elliott_> monochrom: Fair enough -- but if I learned a language as part of an ongoing "language a year" thing, I doubt I'd have the mindset to continue using and learning it quite so actively once I went on to the next one.
14:17:43 <Twey> elliott_: I don't think it takes very long to learn Haskell at all
14:17:44 <ski> Twey : Mercury is statically typed (and moded), with algebraic datatypes, parametric polymorphism and type classes. It uses uniqueness modes (related to, but developed independently from Clean's uniqueness typing) to achieve declarative I/O
14:17:53 <Twey> Some of the crazy stuff people *do* in Haskell, on the other hand…
14:17:54 <mm_freak> cmccann: malbolge isn't difficult, it's just complex
14:17:59 <Twey> ski: Neat
14:18:09 <elliott_> mm_freak: I dunno, anything that requires rudimentary cryptanalysis to program in...
14:18:11 <Pseudonym> mm_freak: You should try one in the Logo/Forth/Joy/Postscript family next.
14:18:15 <monochrom> you need to re-link your brain with the -threaded runtime
14:18:16 <mm_freak> cmccann: to suggest a difficult language, you probably should suggest unlambda or Lazy K
14:18:33 <elliott_> Whaa?? If you know Haskell, Unlambda and Lazy K are really easy in comparison to Malbolge.
14:18:34 <Pseudonym> elliott_: The reason why one a year is it is feasible given the schedule of a typical working software engineer.
14:18:37 <cmccann> mm_freak, with a preprocessor neither of those is all that difficult I'd think
14:18:44 <elliott_> Once you've got abstraction elimination down it's just tedious.
14:18:55 <cmccann> and yes, tedious at best even so
14:19:16 <elliott_> Pseudonym: Right. I guess it has merit if applied sufficiently thoughtfully. I'm just sceptical of things falling under umbrellas like "pragmatic programmer".
14:19:17 <mm_freak> that's true for lazy k, but not for unlambda
14:19:20 <ski> Twey : "The Mercury Project" <http://www.mercury.csse.unimelb.edu.au/>
14:19:43 <Twey> I'm on ATS at the moment, but I'll queue it
14:19:44 <mm_freak> note that unlambda has side effects and is pretty poorly designed in that regard
14:19:46 <elliott_> mm_freak: Lazy K is harder than Unlambda; fewer primitives, interactive IO is difficult.
14:19:55 <elliott_> v and c and their interaction are the hard parts of Unlambda, I would say.
14:20:19 <cmccann> unlambda's c is difficult to use in any language
14:20:27 <Pseudonym> elliott_: There are some languages which take a lifetime to master, and some which don't.
14:20:38 <elliott_> Pseudonym: I'd rather learn the ones that do :)
14:20:39 <mm_freak> elliott_: in lazy k it's much easier to write a decimal counter…  in unlambda the impure nature and non-parametricity of the output function will make your life really hard
14:20:54 <elliott_> mm_freak: fair enough -- I wouldn't say local reasoning is all that productive with unlambda, though :P
14:20:56 <Pseudonym> This is especially true of languages which are fertile ground for programming language research, such as Haskell.
14:21:16 <monochrom> if you want to learn logic programming, skip prolog, go for mercury at least. after all, if you want to learn imperative programming, no one would suggest cobol
14:21:31 <mm_freak> cmccann: c is call/cc, isn't it?
14:21:37 <cmccann> yes
14:21:46 * monochrom would suggest modula-3 for imperative programming
14:21:48 <elliott_> oh, wait
14:21:49 <elliott_> I said v
14:21:49 <elliott_> I meant d
14:21:59 <mm_freak> is it the real call/cc or some obfuscated variant of it?
14:22:01 <elliott_> d and c, and their interaction, is what makes Unlambda truly interesting
14:22:02 <elliott_> mm_freak: real
14:22:16 <elliott_> d has to be seen to be believed: http://www.madore.org/~david/programs/unlambda/#delay
14:22:23 <donri> obviously haskell is the best imperative language
14:22:23 <mm_freak> then it shouldn't be that difficult, if you know how to use call/cc
14:22:34 <cmccann> mm_freak, it's just call/cc like you'd find in scheme as far as I know
14:22:36 <mm_freak> donri: IMO agda beats haskell at that
14:22:38 <elliott_> it's lazy evaluation as kludge taken to perfection to become something completely incomprehensible
14:22:43 <donri> true ;)
14:22:57 <elliott_> probably it has more non-local "semantics-breaking" effects than even c
14:22:57 <donri> just paraphrasing spj
14:23:00 <mjrosenb> the counting function implemented with c and d is kind of amazing.
14:23:22 <tromp> what's a counting function?
14:23:29 <mm_freak> mjrosenb: counting itself isn't difficult in unlambda…  it's /decimal/ counting that really hurts =)
14:23:32 <Pseudonym> lambda: the ultimate kludge
14:23:35 <mm_freak> or any number base for that matter
14:23:38 <mjrosenb> it prints out *\n**\n***\n****\n
14:23:54 <mjrosenb> mm_freak: yes, but the fact that it is like 13 characters long...
14:23:58 <ski> is that a variant of the yin-yang thing ?
14:24:02 <mjrosenb> yes.
14:24:12 <cmccann> anyway, it's not like you have to use d and c in unlambda
14:24:31 <elliott_> cmccann: kind of like you don't *have* to use whitespace in C
14:24:31 * mjrosenb recently added a gc into a C implementation of unlambda :-p
14:24:35 <mjrosenb> it was not sane
14:24:37 <elliott_> everyone will look at you funny if you don't
14:25:02 <ski> monochrom : well, some kinds of (declarative) programming in Prolog are hard to do in Mercury ..
14:25:09 <mm_freak> oh boy…  i even use goto in imperative languages
14:25:17 <elliott_> lambda the ultimate goto
14:25:23 <elliott_> oh, that's an actual paper
14:25:25 <cmccann> haha
14:25:26 * ski is mostly thinking about using structures with lots of logic variable aliases
14:25:39 <elliott_> lambda the ultimate anonymous abstraction syntax
14:25:43 <elliott_> lambda the ultimate greek letter
14:25:46 <mm_freak> especially in languages like C, where you don't get exception handling and setjmp/longjmp will obfuscate your code even more =)
14:25:48 <elliott_> lambda the ultimate lambda
14:25:50 <ski> (i know there's some kind of Herbrand constraint solver, though)
14:26:11 <cmccann> elliott_, anyway, the point remains that programming in unlambda is only as painful as you chose to make it, aside from the tedious aspect of doing anything in combinatory logic
14:26:24 <mm_freak> i've even used goto in haskell =)
14:26:45 * cmccann prefers comefrom
14:26:52 <mm_freak> cmccann: the main difficulty of unlambda for anything nontrivial really lies in the impure input/output functions
14:26:59 <elliott_> cmccann: *sigh* you leave me with no choice
14:27:10 <elliott_> i instead suggest learning http://esolangs.org/wiki/Bitwise_Cyclic_Tag
14:28:52 <cmccann> elliott_, haha, nope, I've tried using variations on that idea before
14:28:57 <cmccann> not gonna go there
14:29:05 <elliott_> fine then! http://esolangs.org/wiki/Slashes :p
14:29:12 <elliott_> those are the two most minimal TC languages I know
14:29:34 <elliott_> well, that one's more complex than something like SK
14:29:38 <elliott_> but much less obviously TC
14:29:47 <mjrosenb> elliott_: iota/jot are pretty cool.
14:30:13 <elliott_> I like iota, but its simplicity is basically syntactic; you still need the semantic baggage of S and K, as they're integral parts of the iota definition
14:30:22 <mjrosenb> yup.
14:30:24 <cmccann> mjrosenb, not much more than an obfuscated SK calculus really
14:30:26 <elliott_> i.e. you can't just give it a bunch of rewrite rules that don't involve the two extra s and k combinators
14:30:31 <tromp> i like binary lambda calculus:)
14:31:06 <monochrom> http://www.vex.net/~trebla/tmp/break.hs
14:32:25 <elliott_> so, speaking of esoteric languages, has anyone heard of this "haskell" thing?
14:32:44 <elliott_> I hear it's like iota, but with lambda expressions and a bunch of syntactic sugar.
14:32:47 <cmccann> haha
14:32:56 <Veinor> :D
14:33:08 <startling> is there a way to do this without `do` notation: http://bpaste.net/show/22313/?
14:33:12 <cmccann> that /// language doesn't actually sound too bad at first glance
14:33:23 <ski> monochrom : `rforever'
14:33:26 <elliott_> cmccann: until you realise that even the most trivial control flow is an exercise in quining :)
14:33:31 <monochrom> I heard it is like camel, because of the camel case
14:33:32 <elliott_> then /recursive/ quining
14:33:37 <c_wraith> startling: you never need do notation.  It's just syntactic sugar.
14:33:43 <donri> @undo do {oneOf chars; n <- p; oneof chars; return n}
14:33:44 <lambdabot> oneOf chars >> p >>= \ n -> oneof chars >> return n
14:33:50 <monochrom> ski: typo, corrected
14:33:52 <donri> also applicative might be better
14:33:53 <elliott_> startling: I think Parsec has that combinator.
14:34:02 <startling> elliott_: I can't find it.
14:34:08 <cmccann> elliott_, yes, but that's still something that might allow building some abstractions
14:34:10 <donri> and yea that there is "between"
14:34:13 <donri> in parsec
14:34:17 <elliott_> http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Combinator.html#v:between
14:34:26 <startling> donri: awesome thanks
14:34:37 <donri> see elliott's link
14:34:41 <mm_freak> startling: oneOf chars *> p <* oneOf chars
14:34:55 <mm_freak> startling: that's more general than 'between'
14:35:01 <monochrom> *>_<*
14:35:16 <mm_freak> startling: import Control.Applicative for the two operators
14:35:18 <elliott_> cmccann: well, it took years to write the first infinite "progressing" loop in it, and that was computer-generated :P
14:35:34 <elliott_> http://oerjan.nvg.org/esoteric/slashes/bct.sss is a bitwise cyclic tag interpreter in ///, just to tie this back around again
14:35:40 <donri> may want to hide <|> from either applicative or parsec
14:35:44 <cmccann> elliott_, ah, hm. maybe it's worst than I thought :T
14:35:53 * frerich_ reads this discussion and now wonders how often he read applicative-style haskell expressions and mistook them for very creative emoticons.
14:36:16 <elliott_> frerich_: *>
14:36:22 <monochrom> :*>
14:36:28 <elliott_> frerich_: <**>
14:36:34 <monochrom> too bad :) is parsed differently
14:36:38 <elliott_> bird + pointy head guy
14:36:39 <cmccann> elliott_, for comparison purposes I once wrote a mandelbrot renderer in GNU make, so my standards for esolang programming are pretty tolerant
14:36:47 <elliott_> cmccann: like, no shell?
14:37:11 <cmccann> elliott_, it used echo, environment variables, and recursive calls to make
14:37:22 <elliott_> awesome
14:37:37 <monochrom> there is a language that uses (: this :) for comments
14:37:39 <elliott_> (I think you could avoid explicit recursive calls to make, by having a conditionally-phony rule for Makefile)
14:38:15 <cmccann> the main reason for the latter, aside from being terrible in the spirit of the whole endeavor, is that I couldn't find any way to loop directly without ruining the output
14:38:21 <cmccann> don't remember the details
14:38:40 <cmccann> the real fun part was doing the arithmetic
14:38:55 <elliott_> i read an article about doing arithmetic in gnu make once ... but, like, it was *dead serious*
14:39:02 <cmccann> what did it do?
14:39:02 <elliott_> talking about how this simplified complex build system rule logic
14:39:07 <elliott_> it used sequences of asterisks or something
14:39:10 <cmccann> oh god.
14:39:16 <donri> monochrom: lolcode? :P
14:39:18 <elliott_> so, moral of the story:
14:39:28 <elliott_> never hack on a project with a build system written by whoever wrote that article
14:39:40 * ski . o O ( <http://en.wikipedia.org/wiki/Simplicial_complex> )
14:39:41 <cmccann> I used a more complicated encoding
14:39:41 <elliott_> (maybe they did ghc's build system)
14:39:51 <cmccann> I think I had p and n for positive/negative values
14:40:04 <cmccann> and then canonicalized it as needed
14:40:34 <cmccann> then extended that to fixed point numbers and then complex arithmetic
14:41:07 <monochrom> (: XQuery comments :)
14:41:14 <monochrom> http://www.w3.org/TR/2010/REC-xquery-20101214/#comments
14:41:44 <monochrom> I was really shocked when I heard of that. then I LOLed seriously
14:42:34 <Sgeo> I think I'll use STM
14:42:41 <rostayob> monochrom: well, SML has (*   *)
14:42:41 <Sgeo> Make my life a bit easier
14:43:07 <monochrom> (* and *) were not considered emoticons back then
14:43:23 <rostayob> ah, so (: :) are notable because they're emoticons
14:43:36 <ski> ("Comments may be used to provide informative annotation for a query, either in the Prolog or in the Query Body." makes me think of logic programming)
14:43:39 <monochrom> XQuery though was conceived way after (: :) had become standard emoticons
14:43:47 <Sgeo> XQuery?
14:44:15 <Pseudonym> Wadler's Law of Language Design is yet again proven.
14:44:22 <rostayob> yes.
14:44:41 <monochrom> I didn't know that Wadler's law covered choosing emoticons
14:45:42 <monochrom> but you can use Godwin's law to avoid reaching Wadler's law
14:46:18 <monochrom> try that next time someone discusses record syntax :)
14:49:33 <niteria> :t (~)
14:49:34 <lambdabot> parse error on input `)'
14:49:50 <niteria> rec~field :D
14:49:51 <koeien> ~ is used for irrefutable patterns
14:49:58 <elliott_> doesn't mean it clashes
14:49:59 <elliott_> ugly though
14:50:53 <niteria> I would expect some regexp library to use ~
14:51:03 <sipa> it cannot
14:51:09 <sipa> ~ is not a valid operator name
14:53:28 <niteria> well, rec->field then, no confusion for everyone with c++'ish background
14:54:25 <niteria> field@rec
14:54:44 <niteria> syntax discussions are fun
14:54:48 <elliott_> rec$-----:>field
14:56:50 <niteria> what's the syntax now?
14:56:55 <elliott_> there is none
14:57:08 <niteria> you have to pattern match?
14:57:11 <elliott_> because our fields are just functions ... special functions that can be used in record update syntax
14:57:13 <elliott_> no, field rec
14:57:27 <niteria> so why special syntax?
14:57:28 <nyingen> hpaste.org domain expired?
14:57:49 <koeien> @where hpaste-dns
14:57:50 <lambdabot> I know nothing about hpasta-dns.
14:58:12 <monochrom> please use another paste bin for the moment. hpaste will be back
14:58:46 <elliott_>  @where+ ghost-of-recently-departed-hpaste-dns http://paste.lisp.org/
14:59:01 <elliott_> niteria: because not being able to reuse field names sucks
14:59:13 <niteria> oh, right
14:59:19 <koeien> i would be satisfied with more namespacing
14:59:38 <koeien> namespace X where ...
15:00:06 <clsmith> 'field rec' is a little jarring
15:01:31 <clsmith> but with an operator for 'flip ($)' i guess that's solved. cept for the namespacing.
15:02:25 <_Mikey> @hoogle [a]->[a]
15:02:26 <lambdabot> Prelude cycle :: [a] -> [a]
15:02:26 <lambdabot> Data.List cycle :: [a] -> [a]
15:02:26 <lambdabot> Prelude init :: [a] -> [a]
15:02:39 <clsmith> "foo"£length? :D
15:02:41 <_Mikey> @hoogle replace
15:02:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
15:02:41 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
15:02:41 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
15:02:49 <niteria> :t tail
15:02:50 <lambdabot> forall a. [a] -> [a]
15:02:54 <koeien> that key is not on my keyboard
15:03:08 <clsmith> "foo"€length ?
15:03:13 <_Mikey> which?
15:03:16 <_Mikey> XD
15:03:18 <koeien> the pound
15:03:23 <_Mikey> #?
15:03:26 <clsmith> £
15:03:26 <Jafet> koeien: Kenneth Iverson glares at you.
15:03:33 <elliott_> "foo"---------------------------->length
15:03:34 <clsmith> pound sterling
15:03:36 <_Mikey> I was thinking it would make for an awesome haskelly symbol.
15:03:39 <_Mikey> 3
15:03:41 <_Mikey> £
15:03:46 <_Mikey> :D
15:03:49 <elliott_> foo:Dlength
15:03:56 <niteria> rec↓↓field
15:04:02 <koeien> 牛 is nicer
15:04:14 <_Mikey> #> super-duper monad
15:04:22 <koeien> but it's not infix
15:04:26 <_Mikey> ;/
15:04:34 <Jafet> The mu operator
15:04:37 <monochrom> try 。
15:04:44 <clsmith> "foo"…length ?
15:04:57 <clsmith> oh, monochrom's might be nice
15:05:02 <koeien> i don't mind the syntax (field rec), but the lack of nested namespacing is the problem imo
15:05:03 <niteria> rec─field
15:05:19 <elliott_> rec 's field
15:05:20 <Jafet> (…) = enumFromTo
15:05:41 <niteria> rec·field
15:06:19 <Jafet> rec "field"
15:06:43 <niteria> anything that encloses field is meh
15:06:56 <niteria> rec{field}, rec|field|
15:07:09 <niteria> :t (|)
15:07:10 <lambdabot> parse error on input `|'
15:08:06 <clsmith> rec|field| isn't too bad
15:08:30 <Sgeo> What does Erlang do?
15:08:35 <elliott_> rec``field''
15:08:36 <Sgeo> I think it requires naming the type
15:08:37 <elliott_> if you can call that a field
15:08:50 <Jafet> rec`s `field
15:09:41 <clsmith> does erlang have fields?
15:10:02 <elliott_> rec... field?
15:12:46 <mm_freak> a good field accessing syntax is:  rec ^. field
15:12:53 <mm_freak> why is it good?  because you can actually use it
15:12:57 <Sgeo> Erlang has records
15:13:02 <mm_freak> @hackage data-lens
15:13:02 <lambdabot> http://hackage.haskell.org/package/data-lens
15:13:17 <elliott_> mm_freak: "use"? As if people actually *use* Haskell.
15:13:20 <clsmith> no namespacing, though
15:13:22 <Sgeo> Expr#Name.Field
15:13:22 <Sgeo> Returns the value of the specified field. Expr should evaluate to a Name record.
15:13:27 <elliott_> Haskell was designed for making jokes about on IRC.
15:14:01 <Axman6> >. is a good name, easy to type
15:14:31 <Axman6> certainly will conflict with other packages, but thats always going to be a problem unless you use something long and annoying to type
15:14:41 <Axman6> or even >?
15:16:17 <Sgeo> >? is an emoticon, clearly
15:16:32 <mm_freak> the funny thing about lenses is that you can actually use (.) for composition =)
15:16:47 <mm_freak> player ^. position . x
15:16:53 <Axman6> Sgeo: the angry tongue poke?
15:17:06 <mm_freak> ah wait, flipping needed
15:17:07 <Sgeo> Angry confusion
15:17:19 <mm_freak> x . position . player ^$ game
15:18:12 <niteria> backwards is that
15:18:36 <Axman6> yoda this language inspired
15:18:41 <Axman6> by*
15:18:58 <_Mikey> @hpaste-where-are-you?
15:18:58 <lambdabot> Unknown command, try @list
15:19:06 <elliott_> paste.lisp.org
15:19:11 <mm_freak> @where hpaste-dns
15:19:12 <lambdabot> I know nothing about hpasta-dns.
15:19:22 <mm_freak> hpasta?!  i typed hpaste…
15:19:22 <_Mikey>  @where+ ghost-of-recently-departed-hpaste-dns
15:19:24 <elliott_> someone set up a bot to say paste.lisp.org whenever anyone says "hpaste"
15:19:32 <elliott_> mm_freak: clearly you made an error
15:19:34 <elliott_> @where hpasta-dns
15:19:35 <lambdabot> I know nothing about hpaste-dns.
15:19:39 <mm_freak> lol
15:19:53 <elliott_> one day someone is going to go through lambdabot's where-db
15:19:53 <mm_freak> @where pasta
15:19:54 <lambdabot> I know nothing about pasta.
15:19:55 <elliott_> and get really really confused
15:20:05 <_Mikey> ok guys
15:20:06 <Sgeo> o.O hpaste wasn't renewed?
15:20:16 <_Mikey> I've been battling with spacing
15:20:19 <_Mikey> allll day
15:20:22 <Sgeo> @where hpaste-dns
15:20:22 <lambdabot> I know nothing about hpasta-dns.
15:20:32 <Sgeo> ...what
15:20:34 <_Mikey> I'll paste and can you tell me what I'm missing?
15:20:39 <mm_freak> apparently hpaste.org is renewed
15:20:41 <elliott_> Sgeo: i like how that just happened 30 seconds ago
15:20:48 <elliott_> we're stuck in a time loop
15:21:01 <rostayob> instance ArrowLoop hpaste-dns ...
15:21:04 <elliott_> hi bos, I bet nobody's told you about hpaste.org yet!
15:21:15 <_Mikey> http://paste.lisp.org/+2Q72.
15:21:27 <bos> elliott_: ha
15:21:47 <elliott_> _Mikey: indent the where less; it just has to be further than the "show"
15:21:50 <elliott_> not past the =
15:22:17 <_Mikey> not past the equals :o
15:22:23 <_Mikey> I've been getting luck all day
15:22:27 <mm_freak> _Mikey: are you sure you want map?
15:22:27 <_Mikey> and not knowing why
15:22:31 <Axman6> um, that show instance shouldn't work
15:22:33 <mm_freak> perhaps you intended to use concatMap
15:22:38 <elliott_> oh
15:22:40 <elliott_> those are probably errors too
15:22:44 <Axman6> there's already a show instance for (a,b)
15:22:45 <elliott_> but the indentation is also wrong! :)
15:22:54 <mm_freak> the indentation isn't wrong
15:22:57 <elliott_> hmm, isn't it?
15:23:01 <elliott_> _Mikey: you should use a data type, not a tuple, anywa
15:23:02 <elliott_> y
15:23:03 <Axman6> not that i can see
15:23:07 <mm_freak> i see a type error there
15:23:11 <Axman6> _Mikey: use 'o' not "o"
15:23:17 <_Mikey> ok ;)
15:23:31 <_Mikey> its a three tuple with a function as the second tuple
15:23:38 <mm_freak> _Mikey: your 'prettify' has result type String
15:23:40 <Axman6> 'o' is a character, "o" is a string ('o':[])
15:23:42 <_Mikey> it won't show nicely without its own instance
15:23:49 <mm_freak> so if you map prettify, your result will be [String]
15:23:59 <_Mikey> ahhh
15:24:08 <_Mikey> good point
15:24:10 <mm_freak> either convert prettify to a Char function or use concatMap
15:24:11 <Sgeo> Should I be worried about STM being slow?
15:24:14 <Axman6> _Mikey: write another function that shows that specific type. don't use show for that
15:24:15 <_Mikey> 'o' it is
15:24:28 <mm_freak> Sgeo: no, STM is pretty mature
15:24:28 <Axman6> Sgeo: not without testing to see whether it is
15:24:42 <Sgeo> Probably better to use STM for my case
15:24:43 <mm_freak> Sgeo: as a general answer to that question
15:24:48 <_Mikey> but.. its convenient Axman6
15:25:01 <Axman6> _Mikey: it's not what Show is desinged for
15:25:10 <_Mikey> when I'm testing in ghci a that horrible tuple falls out all over the place
15:25:24 <_Mikey> and I'm always getting that no instance of show error message
15:25:35 <Axman6> hmm
15:25:35 <_Mikey> it will make my testing alot more pleasant.
15:25:41 <Axman6> fine
15:25:42 <_Mikey> I won't keep it like that.
15:25:50 <Axman6> i'll let you off this time, but don't do it agin!
15:25:53 <_Mikey> wanna get it all up in OpenGL :)
15:25:53 <rostayob> netsplit GO
15:26:00 <_Mikey> :D
15:26:08 <Axman6> i think we just lost a continent!
15:26:15 <_Mikey> looks that way
15:26:49 <Axman6> looks like it's just north america, nothing important
15:28:59 <_Mikey> :)
15:29:20 <mm_freak> just austria…  nothing important =P
15:29:30 <rostayob> here we go agaoin: http://www.rust-lang.org/
15:29:53 <rostayob> i think that haskell has really accomplished something, by bringing so many practices to the attention of programmers
15:30:14 <rostayob> this kind of languages are popping up like crazy recently
15:31:42 <rostayob> my prediction for the future is that one of those languages will go mainstream, but haskell never will
15:31:57 <mm_freak> why do all languages feel obligated to include OO?
15:32:21 <rostayob> mm_freak: because OO is the most common abstraction to organize software nowadays
15:32:26 <Axman6> because ENTERPRISE CLASS READY SCALE!
15:32:42 <mm_freak> most common and most stupid IMO
15:32:47 <cmccann> I'm not sure if most programmers actually use OO to organize anything.
15:32:51 <rostayob> well, it has its advantages
15:33:02 <Jafet> Your predilection for the future
15:33:28 <mm_freak> OO is just a line-noisy excuse for the lack of a proper module system
15:33:28 <cmccann> as opposed to, say, stuffing poorly-designed procedural code into classes in whatever manner they feel like
15:34:22 <Sgeo> mm_freak, so, go SML?
15:34:35 <rostayob> SML is nice but frozen
15:34:39 <rostayob> and annoying syntax imho
15:34:42 <Urchin> OO simplifys doing stuff without any idea as to what one is actually doing
15:34:43 <mm_freak> Sgeo: or include some of the features in haskell
15:34:45 <rostayob> they could have made it more liberal
15:34:54 <mm_freak> Urchin: yes, that's what modules are for
15:35:05 <_Mikey> Axman6, you know you said this isn't what show should be used for?
15:35:08 <rostayob> mm_freak: the only notable feature is the module system, and if you include that in haskell it's a mess imho.
15:35:30 <mm_freak> rostayob: not sure…  i like the idea of parametric modules
15:35:31 * Sgeo wants a Newspeak-like module system
15:35:36 <Axman6> _Mikey: yeah?
15:35:40 <rostayob> mm_freak: yes but then it becomes too much imho
15:35:40 <mm_freak> not that i needed it in haskell, but if we had it, i'd probably use it
15:35:56 <rostayob> there's a huge overlap in functionality between functors and type classes
15:35:56 <_Mikey> did you mean because you must have distinct type variables in your instance parameter?
15:37:38 <Axman6> _Mikey: i mean because the purpose of Show is not to pretty print, but to provide a simple way to serialise types so they can be reread using Read
15:37:56 <Sgeo> rostayob, not an overlap in culture, though. I think Haskellers avoid using type classes if possible
15:38:41 <_Mikey> Axman6, I see because ghci is telling me I need to use -XFlexibleInstances
15:38:58 <c_wraith> _Mikey: FlexibleInstances is harmless. Go for it. :)
15:38:59 <Axman6> yes, because there's already an instance for Show (a,b,c)
15:39:14 <_Mikey> ok
15:39:17 <_Mikey> how do I enable?
15:39:23 <mm_freak> Sgeo: we avoid writing them…  we use them all the time
15:39:28 <rostayob> Sgeo: well but I would be personally often in doubt whether to use a type class or a module functor
15:39:36 <mm_freak> writing type classes is an art
15:40:00 <rostayob> Ur/Web includes both, that language is mad
15:40:14 <Axman6> _Mikey: the easiest thing to do would be to make a new data type that was basically a tuple, and use Show on that type: data Graph = Graph (Array Vertex [Vertex]) (Int -> (Maybe Ant, Point, [Point])) (Point -> Maybe Vertex) (or whatever name makes the most sense)
15:40:15 <mm_freak> i count writing instances to "using" type classes, btw
15:41:20 <_Mikey> Axman6, I like the sound of that.
15:42:06 <Axman6> _Mikey: i tend to think it's better to avoid using extensions where possible. i do use extensions quite a lot, but only when there's not a really nice way to do the same thing without
15:42:15 <Axman6> (I use BangPatterns all the time)
15:42:37 <rostayob> most of the haskell code I read uses extensions
15:42:42 <rostayob> MPTC are everywhere.
15:44:01 <maurer> Whoever owns hpaste knows they need to renew the domain, right?
15:44:15 <rostayob> isn't it chrisdone?
15:44:34 <maurer> When I try to go there now I get a domain parking page from godaddy trying to sell it to me
15:44:37 <Jafet> Whoever uses hpaste knows its IP address, right?
15:44:46 <maurer> Jafet: I certainly don't.
15:45:02 <rostayob> also, it might not work with the ip address only
15:45:04 <rostayob> does it?
15:45:44 <rostayob> maybe it's a virtual host
15:47:41 <niteria> just add it to /etc/hosts
15:48:14 <rostayob> niteria: no I mean, maybe the request is routed depending on the domain on the server that hosts it
15:48:58 <niteria> that's why you add it to /etc/hosts
15:49:06 <rostayob> ah, right
15:50:15 <mm_freak> Axman6: i never use bang patterns, because they are almost always off by one
15:50:32 <mm_freak> f (!n) = … f (n + 1) …
15:51:23 <mm_freak> better use seq:  f n = … (f $! n + 1) …
15:51:43 <Axman6> true
15:51:46 <maurer> Sure, but I don't know what the IP is >_>
15:52:53 <Saizan> 109.74.197.248
15:53:32 <ski> someone mentioned <http://dpaste.org/PriqI/>
15:54:13 <Sgeo> mm_freak, what?
15:54:48 <maurer> Anyone know what could be causeing cabal: dist/src/sdist.-9383/ptrace-0.1: does not exist
15:54:53 <maurer> *causing
15:54:57 <maurer> When I run cabal sdist?
16:03:00 <maurer> Oh, hm, it appears to be a cabal bug, it happens with other peoples' packages too
16:07:39 <nh2> I have a database of things (haskell data types) and want to easy-peasy import/export from/to XML. Package recommendations?
16:09:50 <rostayob> nh2: you mean you want generic functions 'a -> XML' 'XML -> Maybe a'?
16:10:16 <ddarius> toXml (fix (1:))
16:10:20 <Axman6> is XML necessary? there's quite good support for JSON
16:10:50 <rostayob> Axman6, nh2: I was going to say the same, there are already good generic (using both Typeable and GHC.Generic) functions for JSON
16:11:09 * ddarius is pretty sure that there are equivalent XML packages.
16:11:32 * rostayob is pretty sure that the json ones are better and better supported
16:11:48 <Axman6> it's harder to get
16:11:52 <rostayob> yeah
16:11:52 <Axman6> 'JSON wrong too*
16:12:10 <rostayob> with the attribute/tag ambiguity
16:19:03 <kallisti_> http://www.google.com/trends/?q=Hugs,+GHC&ctab=0&geo=all&date=all&sort=0
16:19:13 <kallisti_> interestingly Hugs gets more search volume than GHC. I wonder why.
16:19:44 <_Mikey> cause we're lazy
16:20:05 * ddarius ghcs ghc.
16:20:31 * hackagebot text 0.11.1.13 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.13 (BryanOSullivan)
16:21:10 <Sgeo> kallisti_, how is that interesting?
16:21:32 <kallisti_> it's surprising as I thought GHC was more popular in general.
16:22:31 <rostayob> kallisti_: hugs gets a lot of love in education. i was tought haskell using hugs
16:22:48 <kallisti_> ah
16:22:56 <kallisti_> any particular reason why?
16:23:05 <rostayob> cleared error messages, much lighter
16:23:07 <rostayob> program
16:23:12 <rostayob> very portable
16:23:30 <ddarius> Hugs does not have better error messages.  At best they are shorter and therefore superficially less intimidating.
16:23:45 <rostayob> ddarius: let me rephrase. better error messages for a novice.
16:23:55 <ddarius> rostayob: I don't agree.
16:24:07 <ddarius> The usual reason is Hugs is easier to install and use (for simple things) than GHC.
16:24:22 <nh2> Axman6, rostayob: yep, I'll export to, but XML is required as well
16:24:33 <rostayob> ddarius: most people that approached haskell that i know prefer hugs messages
16:25:01 <rostayob> nh2: wait, do you have an existant XML dataset?
16:25:03 <ddarius> rostayob: Have they actually read the error messages?  Usually they are little better than Prolog's, "No."
16:25:49 <rostayob> Hugs> show (\x -> 4)
16:25:50 <rostayob> ERROR - Cannot infer instance
16:25:52 <rostayob> *** Instance   : Show (b -> a)
16:25:54 <rostayob> *** Expression : show (\x -> 4)
16:25:56 <rostayob> λ> show (\x -> 4)
16:25:58 <rostayob> <interactive>:1:1:
16:26:00 <rostayob>     No instance for (Show (t0 -> a0))
16:26:02 <rostayob>       arising from a use of `show'
16:26:04 <rostayob>     Possible fix: add an instance declaration for (Show (t0 -> a0))
16:26:06 <rostayob>     In the expression: show (\ x -> 4)
16:26:08 <rostayob>     In an equation for `it': it = show (\ x -> 4)
16:26:12 <rostayob> as you said, the first one is much less intimidating.
16:26:17 <rostayob> and more clear, if you are a novice.
16:26:26 <rostayob> there is no Show instance. clear.
16:26:26 <rwbarton> ghc's error messages sometimes get worse as type system extensions are added, for instance the new error messages like (one I got today) roughly "Could not deduce (r ~ ()) from the context (Monad m) in ..."
16:26:40 <rostayob> rwbarton: that's true as well
16:26:48 <nh2> rostayob: yes, though that's in a "legacy" format (I'm talking of the 10K vocabulary I did at school :D)
16:26:54 <kallisti_> I get those without using any type system extensions.
16:26:57 <ddarius> rwbarton: Beginners typically aren't using various type system extensions, particularly in a classroom setting.
16:27:06 <monochrom> I have read both error messages. GHC's shows more excerpts of my own source code.
16:27:07 <rostayob> nh2: well then generic functions won't help you. go write your oen function
16:27:17 <rwbarton> You don't have to enable any extensions to get these new errors though
16:27:32 <rwbarton> at least, I don't think I had any enabled
16:27:51 <rostayob> also, the error that have to do with kinds are clearer with Hugs iirc
16:28:10 <monochrom> yes, GHC shows "a ~ b" and "perhaps you want -XFlexibleInstances" in the classroom setting
16:28:37 <rostayob> ddarius: anyways, I'm saying these things because a lot of people have complained about GHC errors once they switched from Hugs
16:29:06 <rwbarton> well, that just sounds like an issue with experience
16:29:09 <monochrom> I actually have no complaint about GHC messages apart from "perhaps you want -XBlah"
16:29:23 <rostayob> rwbarton: mhm. i'm not sure
16:29:24 <rwbarton> similarly I can't read Hugs error messages when people come here and paste them
16:29:38 <monochrom> like I said, apart from that, the only difference is showing more exceprts or less exceprts of my own source code
16:29:44 <rostayob> i mean even the simple example i posted, the hugs error is more to the point imho
16:29:51 <rostayob> there is now show instance for that
16:30:14 <ddarius> I used to recommend people use GHC just for the better error messages after seeing some of the worse ones.  Now it's not an issue because no one uses Hugs.
16:30:29 <rostayob> ddarius: my uni uses hugs
16:30:47 <nh2> my one as well!
16:30:52 <monochrom> then again, for mediocre humans who have limited bandwidth and working memory, a long message is totally lost on them
16:30:55 <rostayob> nh2: oh realy? L)
16:31:00 <rostayob> *:)
16:31:05 <rostayob> *really. shiat
16:31:05 <ddarius> rostayob: Courses still use Miranda.  It only matters to me if those people come here with their Hugs questions.
16:31:08 <nh2> yeah seems to be quite widespread :D
16:31:28 <rostayob> ddarius: I think that Hugs is a good choice for a course like the one I had
16:31:45 <monochrom> after all, there is a big difference for them between "Int != Char" and "Int != Char <1000-word essay here>"
16:32:00 <rostayob> for the reason I mentioned. and i've got anedoctal evidence to back me up!
16:32:05 <rostayob> anyways, going to bed
16:32:12 <ddarius> rostayob: There are good reasons to use it.
16:32:31 <ddarius> rostayob: But the only one that really matters is that it is much easier to install.
16:32:43 <rostayob> ddarius: possibly
16:32:57 <rostayob> I still prefer Hugs error messages most of the times :P
16:33:10 <monochrom> I am not convinced that ghc is harder to install. unless the platform is an uncommon one like NetBSD
16:33:39 <rostayob> monochrom: well, ghc is several hundreds MBs, hugs is what?
16:33:56 <ddarius> monochrom: It isn't really, especially now.  However, you are more likely to have problems attempting to install GHC and more likely to have tricky problems than you are with Hugs.
16:34:11 <adimit> is cmdargs still the "best" way to parse args canonically in Haskell? Or are there others?
16:34:12 <monochrom> I am not convinced that the bigger size translates into harder to install
16:34:15 <rostayob> anyways, bedtime
16:34:31 <ddarius> adimit: When was it the "best" way to parse args?
16:34:51 <adimit> ddarius: … ok, I missed the memo. What other lib would you suggest?
16:37:16 <adimit> the others I can find are parseargs and ReadArgs…
16:38:16 <monochrom> study their docs and choose one with the behaviour you like
16:39:36 <ddarius> There's a getopt port in base.
16:43:50 <mm_freak> Sgeo: ?
16:47:59 <nh2> oh, concerning xml import/export: Is there something that people have used with safecopy and called it a good idea afterwards?
16:48:26 <_Mikey> Hey guys,
16:48:38 <_Mikey> can you pattern match with guards in a where clause?
16:48:43 <ski> > let foo x = z ++ y where (y,z) = splitAt 3 x in foo "abcdef"  -- patter-matching on `(y,z)' in a `where'
16:48:44 <lambdabot>   "defabc"
16:48:51 <Sgeo> mm_freak, what you mean by bang patterns being off by one
16:49:08 <monochrom> depends on what you mean, but yes
16:50:57 <_Mikey> monochrom, something like this? http://paste.lisp.org/display/127264
16:51:36 <monochrom> yes
16:53:29 <_Mikey> monochrome how can I access the list that I'm mapping over in my guard statements though?
16:53:49 <_Mikey> I tried directionize (x:_)
16:54:10 <monochrom> that can't be done
16:55:43 <_Mikey> :(
16:56:37 <_Mikey> so if I have a list of Ints
16:56:40 <ski> `directionize' will only be passed individual list elements, not the whole list (or tails of it) -- that's what `map' does
16:57:00 <_Mikey> ok
16:57:11 <monochrom> directionize has access to graphT, nd, and siblings in the where-clause
16:57:15 <_Mikey> so I can compare against the value passed in the guards right?
16:57:26 <_Mikey> oww
16:57:38 <ski> "the value passed in the guards" ?
16:57:40 <monochrom> so why don't you put more things in its siblings?
16:58:05 <_Mikey> in the where's siblings?
16:58:16 <monochrom> directionize's siblings
16:58:59 <_Mikey> if I change the line to where directionize x
16:59:01 <ski> (if you want to access the tail of the current element, you could try something like `map directionize ((init . tails) ...)')
16:59:50 <monochrom> you are supposed to write "directionize x = " anyway
17:00:36 <_Mikey> if I add the = I can't use guards though right?
17:01:09 <monochrom> guards go before "=". "directionize x | False = "
17:01:33 <_Mikey> yea
17:01:40 <monochrom> of course, "directionize | False = \x -> undefined" works, too
17:03:07 <_Mikey> http://paste.lisp.org/display/127264#1
17:03:20 <_Mikey> I've fleshed it out a bit more
17:03:43 <monochrom> that works
17:04:02 <_Mikey> :o
17:04:03 <_Mikey> it does
17:04:22 <_Mikey> so I was missing  the x ;/
17:04:49 <_Mikey> well I was missing alot but yea :)
17:04:50 <monochrom> I was thinking you wanted to write like "directionize | False = \x -> undefined"
17:04:53 <_Mikey> thanks monochrom
17:05:25 <_Mikey> actually I probably do.. hmm
17:06:12 <monochrom> you can't. you are conditional-branching based on the parameter. you have to get the parameter first.
17:07:18 <monochrom> "directionize | nd==nd = \x -> East" is legit, but just because the condition doesn't care about the parameter
17:10:02 <_Mikey> I didn't without the lambda
17:10:08 <_Mikey> did it*
17:10:09 <_Mikey> I think
17:10:17 <_Mikey> but another question
17:10:18 <mm_freak> Sgeo: take this sum function for example:  sum n [] = n;  sum n (x:xs) = sum (n + x) xs
17:10:34 <_Mikey> function composition would make this look prettier right fstTrip ((sndTrip graphT) x)))
17:10:39 <mm_freak> Sgeo: if you don't bang the n in both clauses you will be off by one, i.e. the last addition will be unevaluated
17:11:13 <Sgeo> o.O
17:11:24 <mm_freak> Sgeo: seq is only required in the recursive case, making things a bit cleaner
17:11:36 <mm_freak> sum n (x:xs) = (sum $! n + x) xs
17:11:43 <monochrom> that kind of off-by-one is usually harmless
17:12:02 <ddarius> monochrom: Indeed.  Furthermore, that modification makes sum lazy which will impede optimizations.
17:12:03 <Sgeo> Off-by-one as in wrong result, or insufficient strictness?
17:12:17 <mm_freak> Sgeo: the latter
17:12:40 <mm_freak> monochrom: harmless for a large calculation performed only few times, but harmful for a small calculation performed a lot
17:12:41 <monochrom> _Mikey: it's up to you
17:13:09 <ddarius> I'm pretty sure the way bang patterns are compiled and the semantics of Haskell actually make it so that it will evaluate n before doing the pattern match so placing the bang pattern on just the first clause is equivalent to placing on both clauses.
17:13:25 <ddarius> If you changed the order of the arguments, though, you're statement would have been true.
17:13:50 <Sgeo> I have an IO action that ultimately gives a text
17:14:01 <Sgeo> I used return $! T.pack someStrick
17:14:15 <Sgeo> Does that make sense to make strict there, so I end up storing the Text and not the String?
17:14:29 <ddarius> mm_freak: For that example, I'd recommend putting a bang pattern only on the first clause, though systematically using it on all clauses is also reasonable.
17:14:35 <mm_freak> Sgeo: yeah, if it's Data.Text.Text
17:14:43 <ddarius> I find this clearer and simpler than using ($!).
17:14:48 <ddarius> (In this case.)
17:15:01 <mm_freak> ddarius: dunno, i just find seq easier to understand
17:15:28 <_Mikey> monochrom, I'm going to compose, it'll help me understand more code quicker if I start using them myself :)
17:15:57 <mm_freak> with GHC's strictness analysis you probably get along without either bangs or seq
17:15:58 <ddarius> mm_freak: To get sum to be strict in n using just seq or ($!) would be awkward in that case.
17:16:14 <mm_freak> ddarius: why?
17:16:26 <ddarius> mm_freak: sum is not strict in n as you defined it with or without ($!).  Strictness analysis won't make it so.
17:16:37 <ddarius> sum _|_ [] = []
17:16:47 <ddarius> Er, I'm wrong.
17:17:00 <monochrom> heh
17:17:05 <mm_freak> i was wondering
17:17:28 <mm_freak> the seq in the second clause should be sufficient to make sum n-strict
17:17:40 <rwbarton> assuming (+) is strict
17:17:49 <monochrom> I will look at GHC core to be sure
17:17:58 <ddarius> mm_freak: As would a bang pattern in the first clause.
17:18:03 <ddarius> That part was still right.
17:19:29 <mm_freak> ddarius: fair enough…  it's just that the implications of bang patterns seem a bit more twisted to me
17:20:00 <ddarius> GHC should be smart enough to figure out the strictness here (given it knows the strictness of (+)) even though the second case has a subtlety to it.
17:20:02 <mm_freak> i'd probably have put the bang in both clauses
17:20:27 <maurer> Is anyone else having the issue where cabal sdist refuses to generate tarballs?
17:20:41 <ddarius> mm_freak: I often do that even when it's not necessary.  I'm fine with eating the cost of a spurious seq and I assume GHC will optimize out such things when it knows the function is strict.
17:20:47 <mm_freak> maurer: with what error message?  have you used "cabal check"?
17:21:04 <maurer> cabal: dist/src/sdist.-32577/ptrace-0.1: does not exist
17:21:09 <maurer> is the error message
17:21:36 <maurer> cabal check reports No errors or warnings could be found in the package.
17:22:18 <mm_freak> ddarius: perhaps it's my desire to reclaim control over where exactly i force stuff depending on what…  bang patterns can be quite opaque
17:22:29 <zzo38> I have a Map where the keys are a record with two fields, and I want to group on the first field. How to do so?
17:23:23 <maurer> mm_freak: Any ideas?
17:23:38 <mm_freak> maurer: no, sorry
17:23:47 <maurer> It also does this on packages that I pull down from hackage (which I tested to see whether it was my package's fault)
17:23:56 <zzo38> Maybe it has to be convert to list?
17:24:23 <mm_freak> zzo38: write that function's type signature first
17:25:58 <ddarius> mm_freak: If you succeed in making a function strict in a way that GHC understands, then it's rather unlikely things will be forced where you write the annotations.
17:26:30 <mm_freak> ddarius: but …?
17:26:40 <zzo38> mm_freak: What function's type signature?
17:26:41 <mm_freak> earlier?  later?
17:26:52 <lispy> Is there anything in the standard libs that would do this: Nothing <?> Just 1 <?> Just 2 == Just 2, for some operator (<?>)
17:26:53 <mm_freak> zzo38: your grouping function
17:27:10 <mm_freak> lispy: Last, mappend
17:27:17 <mm_freak> Data.Monoid
17:27:20 <maurer> lispy: mplus maybe? Might be backwards though
17:27:47 <zzo38> lispy:  flip (<|>)
17:28:51 <mm_freak> > let (<||>) = flip (<|>) in Just 1 <||> Nothing <||> Just 2
17:28:52 <lambdabot>   Just 2
17:29:50 <lispy> mappend [Nothing, Just 1, Just 2]
17:29:53 <lispy> > mappend [Nothing, Just 1, Just 2]
17:29:54 <lambdabot>   Overlapping instances for GHC.Show.Show
17:29:55 <lambdabot>                              ([Data...
17:30:02 <lispy> > mappend [Nothing, Just 1, Just 2] :: Maybe Int
17:30:02 <ddarius> mm_freak: They would happen earlier or not happen at all because they are completely unnecessary.
17:30:03 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
17:30:03 <lambdabot>         again...
17:30:06 <mm_freak> lispy: that would be mconcat and you have to add the Last constructor
17:30:08 <Axman6> mconcat?
17:30:28 <mm_freak> > mconcat [Last (Just 1), Last Nothing, Last (Just 3)]
17:30:29 <lambdabot>   Last {getLast = Just 3}
17:31:27 <lispy> hmm
17:33:06 <mm_freak> > mconcat [Last (Just 1), Last Nothing]
17:33:06 <lambdabot>   Last {getLast = Just 1}
17:33:32 <mm_freak> lispy: you can also use zzo38's solution flipping (<|>) from Control.Applicative
17:34:57 <nyingen> aha, finally got java and haskell talking via thrift
17:35:01 <nyingen> what an ordeal
17:35:17 <lispy> > let (<||>) = flip (<|>) in Nothing <||> Just 1 <||> Just 2
17:35:19 <lambdabot>   Just 2
17:36:09 <Axman6> nyingen: blogpostnaow!
17:37:02 <nyingen> Axman6: hm, maybe I should. I mostly went off of http://mortenib.wordpress.com/2009/10/29/thrift-and-haskell/, but there was some difficulty on the Java side
17:59:59 <kallisti_> for log output from a MonadWriter do you guys use String or do you prefer a different type?
18:00:33 <lispy> I don't use it for log output, but String is kind of bad because it's quadradic
18:00:44 <kniu> so what is cabal-dev and how do I use it?
18:01:31 <kallisti_> lispy: so should I be using it for logging at all? I didn't really feel a need to log anything but I do want to use Reader and State so I figured RWS would work and then I could add some useful info to writer or something.
18:03:38 <lispy> kniu: search for "reddit cabal-dev psa"
18:03:41 <lispy> kallisti_: hmm
18:04:21 <kniu> okay, semi-unrelated-but-somewhat-related question
18:04:39 <kniu> if I want to use 7.2.2, how do I get the convenience of cabal install?
18:04:48 <kniu> or is it just that I can't?
18:05:56 <kallisti_> if Writer used MonadPlus instead I could output my LogicT results that way. :P
18:36:07 <klfwip> is anyone here familar with running programs in leksah with command line argument?
18:36:20 <klfwip> I have been programming in a text editor with a terminal for a while
18:36:32 <klfwip> so I am not sure how I am supposed to pass info to getArgs
18:40:33 <ski> @type System.Environment.withArgs
18:40:33 <lambdabot> forall a. [String] -> IO a -> IO a
18:40:49 <ski> klfwip : i haven't tried that, but looks like it could be helpful
18:41:19 <klfwip> there is very scarce documentation on it from what I can tell
18:41:52 <klfwip> I mam not sure I understand your answer, where should I type this?
18:42:14 <klfwip> probably just going to go back to using notepad++ if this does not work
18:43:19 <klfwip> okay
18:43:26 <klfwip> its buried, but I figured this out
18:44:38 <ski> klfwip : hm, i suppose i misunderstood your question
18:44:39 <klfwip> rather than specifying args every time you run like in the terminal, it you open package flags-> executable flags
18:44:47 <klfwip> no problem
18:45:04 <klfwip> Leksah seems to not be widely used, so its weird getting answers to anything with it :p
18:51:06 <kallisti_> does anyone else find it annoying that the (run|eval|exec)(State|RWS)T? functions have the monad as the first argument?
18:52:23 <Axman6> not really, you're running them on that argument. but i guess i can see arguments for having them last too
18:52:54 <Axman6> i feel it's more frequent to use map (runState computation) xs
18:53:29 <kallisti_> I'm not having the same experience.
18:55:38 * hackagebot bson 0.1.7 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.7 (TonyHannan)
18:55:59 <Sgeo> kallisti_, I can see that if you're defining the monadic value in place
18:56:19 <Sgeo> But I'm not very experienced with Haskell
18:56:58 <nand`> @type flip runState
18:56:59 <lambdabot> forall a a1. a -> State a a1 -> (a1, a)
18:57:10 <kallisti_> :t flip evalRWS
18:57:11 <lambdabot> forall a w s a1. a -> RWS a w s a1 -> s -> (a1, w)
18:57:31 <kallisti_> runState really isn't annoying.
18:57:45 <Sgeo> :t flip runRWS
18:57:46 <lambdabot> forall a w s a1. a -> RWS a w s a1 -> s -> (a1, s, w)
18:58:14 <CoconutCrab> hello, I am new to haskell and currently learning via material on the web such as wikipedia (for monad part)
18:58:37 <Axman6> @where lyah
18:58:37 <lambdabot> http://www.learnyouahaskell.com/
18:58:41 <Axman6> CoconutCrab: ^^^^^^^^^^^^^
18:58:44 <CoconutCrab> now I think I have some basic knowledge of haskell, could you please give me some real world applications
18:59:03 <Axman6> CoconutCrab: what have you written/learnt so far?
18:59:08 <CoconutCrab> that is simple but can show how haskell feature work
18:59:34 <CoconutCrab> Axman6: written, nothing. But for the basic part, I think I know it
18:59:41 <CoconutCrab> basic knowledge*
18:59:44 <nand`> :t flip . flip evalRWS -- kallisti_
18:59:45 <lambdabot> forall a a1 w a2. a1 -> a -> RWS a1 w a a2 -> (a2, w)
18:59:52 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- demonstrates laziness, recursion, succinctness
18:59:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:59:53 <CoconutCrab> I still need to read more about monad though
19:00:26 <Axman6> CoconutCrab: i highly doubt it, haskell is not considered an easy language to learn and i have extreme doubts you could have learnt it without writing anything
19:00:36 <nand`> > let 2+2 = 5 in 2+2 -- demonstrates pattern matching
19:00:37 <lambdabot>   5
19:00:45 <Axman6> badly :P
19:01:01 <CoconutCrab> Axman6: of course, I haven't be able to 'learn' it yet :) what I meant is that I have accumulated some knowledge and I want to see how those works
19:01:16 <nand`> CoconutCrab: http://learnyouahaskell.com/ has a lot of good examples
19:01:17 <CoconutCrab> Axman6: so I can remember and understand them more
19:01:19 <nand`> with usage case scenarios
19:01:27 <Axman6> also, monads aren't exactly a big part of haskell programming (even if we use them everywhere)
19:01:36 <CoconutCrab> nand` and Axman6: thank for that link
19:01:42 <CoconutCrab> I did not know that existed :">
19:01:50 <nand`> it usually guides you to new features first by showing how you'd solve it “normally” and then introducing the feature X that makes it easier for you afterwards
19:02:04 <nand`> eg. it demonstrates how monads are used by first giving a situation in which you'd define (>>=) manually
19:02:05 <CoconutCrab> okay
19:02:32 <nand`> CoconutCrab: I also recommend just using ghci and going along with all of the examples
19:03:02 <nand`> instead of trying to make a “real program” first, at least until you understand the IO monad (quite a few chapters to go)
19:03:09 <CoconutCrab> yes, I had ghc installed and is going to poke at lambdabot source
19:03:30 <CoconutCrab> nand`: thank for the advices, they are highly appreciated :)
19:04:29 <CoconutCrab> okay, back to reading
19:06:21 <roconnor> @hoolge String -> ByteString
19:06:21 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
19:06:22 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
19:06:22 <lambdabot> Data.String fromString :: IsString a => String -> a
19:06:38 <kallisti_> linearWalker :: (MonadState (S.Set Move) m, MonadPlus m, MonadReader WalkInfo m) => m Move
19:06:41 <kallisti_> linearWalker = stopAtPiece `mplus` followNewPortal
19:06:49 <kallisti_> at this point writing out types is becoming more time consuming than actually writing the code.
19:07:43 <nand`> kallisti_: you can always have the type signatures inserted automatically
19:07:51 <kallisti_> oh? what tool does this?
19:07:57 <nand`> I know of one for emacs
19:08:00 <tikhonjelvis> I think Scion does it for Emacs.
19:08:03 <ezyang> Huh, does the state monad have laws?
19:08:16 <nand`> ezyang: every monad has laws
19:08:25 <ezyang> erm, besides the monad laws :-)
19:08:29 <kallisti_> well it's non-commutative. which is a kind of law I guess. :P
19:09:53 <dolio> ezyang: http://code.haskell.org/~dolio/agda-share/html/StateAlgebra.html
19:10:13 <ezyang> Ooh, excellent!
19:10:17 <ezyang> I was worried we didn't have any laws.
19:10:38 * hackagebot mongoDB 1.2.0 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.2.0 (TonyHannan)
19:10:48 <ezyang> although... how'd you pick those five?
19:11:01 * kallisti_ wonders how people don't go insane when dealing with large records without NamedRecordPuns or fclabels or some other kind of abstraction.
19:11:14 <ezyang> kallisti_: They do :-)
19:11:24 <kallisti_> *NamedFieldPuns
19:11:27 <ezyang> But no one has gone quite insane enough to overhaul GHC's record system.
19:12:20 <dolio> ezyang: They're all pretty sensible, and they're exactly what you need to prove that S -> S x - is the free state monad.
19:12:46 <ezyang> ok, in some sense of "exactly"? :-)
19:13:13 <dolio> You could probably combine them into different sets of equations.
19:13:27 <dolio> But I need all of those together, or something equivalent.
19:17:59 <ski> `law₁',%c. ?
19:25:38 * hackagebot xturtle 0.0.5 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.5 (YoshikuniJujo)
19:45:12 <interiorcrocodil> what's the xk_ constant for [?
19:47:32 <Axman6> interiorcrocodil: what?
19:47:51 <CoconutCrab> for xmonad
19:48:11 <Axman6> oh, thats an Xmonad question then. probably best in #xmonad
19:48:12 <interiorcrocodil> nvm, just realized it's the same as c's xlib
19:48:28 <interiorcrocodil> Axman6: thanks
19:56:28 <lpsmith> I'm confused.  Where did Control.Exception.Control,  previously part of monad-control,  go?
19:59:16 <lpsmith> n/m found it
20:16:52 <Cale> http://www.youtube.com/watch?v=cP5TLk4-rcY
20:19:03 <monochrom> what is that about?
20:19:51 <Cale> Silly properties of ruby and javascript
20:20:11 <drdo> Silly is an understatement
20:20:18 <Cale> and what happens when you do arithmetic on things which are not numbers
20:27:30 <byorgey> does anyone know of any package(s) on Hackage with an implementation of a balanced list fold?
20:28:08 <byorgey> I mean something of type  (a -> a -> a) -> a -> [a] -> a  which uses a balanced binary scheme for combining values
20:29:18 <sbahra> I don't know of any package on hackage, it would be very useful to have.
20:30:36 <Axman6> > let foldb f z (x:y:xs) = foldb $ f x y : foldb f z xs; foldb _ _ [x] = [x]; foldb _ z [] = z in foldb (+) z [a,b,c,d,e]
20:30:37 <lambdabot>   Couldn't match expected type `t -> t -> a'
20:30:38 <lambdabot>         against inferred type `[...
20:30:44 <Axman6> uh
20:30:55 <Axman6> > let foldb f z (x:y:xs) = foldb f z $ f x y : foldb f z xs; foldb _ _ [x] = [x]; foldb _ z [] = z in foldb (+) z [a,b,c,d,e]
20:30:56 <lambdabot>   Couldn't match expected type `[t]'
20:30:56 <lambdabot>         against inferred type `SimpleRef...
20:31:18 <Axman6> hmm, no
20:31:51 <Enigmagic> byorgey: monad-par has one such implementation
20:32:19 <Enigmagic> parMapReduceRange :: NFData a => InclusiveRange -> (Int -> Par a) -> (a -> a -> Par a) -> a -> Par a
20:32:23 <sbahra> :tfoldb
20:32:25 <sbahra> :t foldb
20:32:26 <lambdabot> Not in scope: `foldb'
20:32:37 <sbahra> Oh, sigh Axman6 :)
20:35:05 <byorgey> Axman6: I know how to implement it.  I just wanted to use a standard one rather than sticking it in my package myself.
20:37:03 <byorgey> perhaps I'll make a package.
20:39:01 <tommd> preflex: seen lemmih
20:39:56 <tommd> @tell lemmih FYI - I know it was a stupid mistake, but I was able to get acid-state to unrecoverably throw errors (unless I deleted the state directory and started fresh)
20:39:56 <lambdabot> Consider it noted.
20:40:48 <tommd> @tell lemmih by running an acid-state instance 60 times a second (on every frame for a toy rendering of osm maps, if you care) and eventually killing the process.
20:40:48 <lambdabot> Consider it noted.
20:41:17 <Joe_> how do I learn to program
20:41:25 <Axman6> by starting
20:41:32 <Axman6> 4~where lyah
20:41:37 <tommd> Joe_: Books books and books along with not just _reading_ but _applying_.
20:41:40 <tikhonjelvis> You should try to make something cool on a computer.
20:41:52 <tikhonjelvis> Eh, I prefer online tutorials to books, but that's just me.
20:41:58 <tommd> Joe_: Or you can use tutorials, but it seems if you know Zero programming then a book usually is a good start.
20:42:04 <tikhonjelvis> While you're reading, do cool stuff with it.
20:42:07 <Joe_> isn't this an online tutorial?
20:42:13 <tommd> This is IRC.
20:42:14 <tikhonjelvis> LYAH can be both.
20:42:48 <tikhonjelvis> @where LYAH
20:42:48 <lambdabot> http://www.learnyouahaskell.com/
20:43:07 <tikhonjelvis> This book is awesome. Also: pretty pictures!
20:43:38 <Joe_> thanks
20:43:55 <tikhonjelvis> If you run into concrete problems, ask here: somebody will probably help.
20:46:09 <Joe_> is haskell the best programming language to learn, or should I try Java
20:46:38 <klfwip> Joe, haskell is pretty hard
20:46:44 <klfwip> what do you want to do>
20:46:45 <klfwip> ?
20:46:49 <byorgey> Java is pretty hard too.
20:47:09 <byorgey> if you've never programmed, programming is hard.
20:47:12 <byorgey> but worth learning.
20:47:18 <tikhonjelvis> I would *not* learn Java first.
20:47:43 <byorgey> Joe_: we are biased of course =), but I think Haskell is likely to be a great language to learn.
20:47:46 <tikhonjelvis> SICP is an awesome book for learning programming, but might be considered "hard" too.
20:47:52 <timemage> Joe_, try python maybe.
20:47:53 <byorgey> Joe_: you will also get much better help if you learn Haskell.
20:48:00 <Joe_> I'm just trying to learn basic programming
20:48:04 <tikhonjelvis> I don't think python is the best for just starting.
20:48:07 <tikhonjelvis> Scheme is great.
20:48:17 <byorgey> yes, Scheme would be another good choice
20:48:27 <byorgey> @go How To Design Programs
20:48:27 <lambdabot> Maybe you meant: google googleit do
20:48:33 <byorgey> @google How To Design Porgrams
20:48:35 <lambdabot> http://www.youtube.com/watch?v=IrSSbLszuX8
20:48:35 <lambdabot> Title: How To Make A Simple Program or Software With Notepad (HD) - YouTube
20:48:38 <byorgey> arg
20:48:41 <tikhonjelvis> heh
20:48:50 <byorgey> @google "How To Design Programs"
20:48:52 <lambdabot> http://www.htdp.org/
20:48:52 <lambdabot> Title: How to Design Programs
20:48:58 <tikhonjelvis> I think JavaScript would also be a better choice than Python, but I'm biased.
20:49:03 <byorgey> Joe_: check out that online book
20:49:25 <byorgey> Joe_: that is a great place to start
20:49:33 <tikhonjelvis> Joe_: If you're ambitious, check out: mitpress.mit.edu/sicp/
20:49:52 <tikhonjelvis> It is literally the best book on programming I have ever read.
20:50:39 * hackagebot couchdb-conduit 0.4.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.4.0 (AlexanderDorofeev)
20:50:42 <Joe_> thanks everyone, i appreciate it
20:50:48 <tikhonjelvis> Be sure to have fun.
20:51:17 <ski__> Joe_ : if you want to try Haskell, this is a good place to ask questions. if you want to try Scheme (using e.g. HtDP or SICP), then you can try #scheme (or #racket)
20:51:51 <hpaste_> “John Lien” pasted “cantor pairs ” at http://hpaste.org/56906
20:52:07 <ski__> (Joe_ : do you know how to join other IRC channels ?)
20:56:07 <Joe_> No
20:58:11 <ski> Joe_ : well, in most IRC clients, to join the #scheme channel, you'd type :
20:58:13 <ski> /join #scheme
21:05:44 * hackagebot couchdb-conduit 0.4.1 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.4.1 (AlexanderDorofeev)
21:11:19 <YellowOnion> is there a term like "pythonic" for haskell?
21:12:21 <sbahra> Haskellicious
21:13:33 <YellowOnion> sbahra, if that's not legit it should be
21:14:21 <sbahra> We can make it legit together.
21:14:26 <kallisti_> YellowOnion: "pure" is probably pretty close to being that.
21:14:41 <kallisti_> but I don't think there's a direct equivalent.
21:14:48 <kallisti_> pure actually has something of a definite meaning.
21:15:17 <kallisti_> but it also has the connotation of "good", I would say.
21:15:49 <YellowOnion> usually Pythonic is used for say non python based libraries to compare them to "c with python syntax"
21:16:06 <byorgey> I think the closest term in actual use is "Haskelly"
21:16:21 <byorgey> as in, "but this solution is not very Haskelly"
21:17:05 <monochrom> wait, what? so "pythonic" means "not in python"? so what adjective means "in python"?
21:17:17 <YellowOnion> no bindings
21:17:31 <kallisti_> monochrom: I think you got confused somewhere.
21:17:42 <monochrom> yes I am very confused
21:18:03 <kallisti_> I think he meant pythonic is also used outside of the context of pythons, actually.
21:18:04 <monochrom> but no one refutes my conjecture, so I am right and confused
21:18:48 <YellowOnion> it means a library that is most possibly C or C++ but with bindings that use python's features and not just a bare bones bindings
21:19:53 <monochrom> so you're looking for an adjective for a library written in C but with bindings that use haskell features?
21:20:04 <dmwit> > 250 * 4 / 3
21:20:04 <lambdabot>   333.3333333333333
21:20:41 <sbahra> What's wrong with Haskellicious?
21:21:22 <YellowOnion> it's more of a spectrum, you could have a library that you're require to convert to c types before passing varibles to functions like the OpenGL bindings and you compare it to what it would be like if it was programmed in pure python.
21:21:55 <sbahra> Since we're dealing with ill/un-defined terminology to begin with (pythonic).
21:22:06 <dmwit> > 50 * 4 / 3
21:22:07 <lambdabot>   66.66666666666667
21:22:21 <byorgey> YellowOnion: you could also just say "idiomatic Haskell"
21:22:58 <kallisti_> if anyone has some free time I was hoping to get some opinions on this code and how it could be improved:  http://sprunge.us/BgdM
21:23:07 <monochrom> "idiomatic haskell" refers to haskell code, not c code
21:23:19 <kallisti_> so does pythonic, in most contexts I've ever heard it.
21:23:23 <kallisti_> this C/C++ thing is new to me.
21:23:42 <monochrom> currently, "non-existent" is a correct adjective for a library written in c but with bindings that use haskell features
21:23:47 <ski> in `at', `(StorableSquare square)' could be `StorableSquare square'
21:24:19 <kallisti_> oh really?
21:24:28 <monochrom> and "non-existent" is still correct even if you appeal to the spectrum thing, i.e., 90% c 10% haskell
21:24:33 <kallisti_> I thought patterns always needed parentheses for some reason.
21:24:52 <kallisti_> oh wait
21:24:54 <kallisti_> where clause
21:24:55 <kallisti_> nevermind. :P
21:25:01 <kallisti_> I thinkit used to be a function argument pattern.
21:25:07 <kallisti_> and I didn't change the parens.
21:25:11 <YellowOnion> monochrom, that's what I was afraid of, I'm looking for a GUI toolkit that's Haskellicious
21:25:56 <ski> kallisti_ : i think patterns by themselves never need brackets
21:26:04 <monochrom> kallisti_: you now see my confusion. I would think "pythonic" describes certain python code, too. now suddenly it describes certain c code.
21:26:26 <ski> the brackets you're thinking about is to not make it parse in another unwanted way
21:26:31 <YellowOnion> monochrom, no, it describles the libraries bindings to python
21:26:34 <kallisti_> ski: but as function arguments they do right?
21:26:43 <kallisti_> because otherwise it would be ambiguous...
21:26:49 <kallisti_> or look really bad, at least.
21:27:00 <ski> kallisti_ : no, consider
21:27:01 <ski> @src Either (>>=)
21:27:02 <lambdabot> Left  l >>= _ = Left l
21:27:02 <lambdabot> Right r >>= k = k r
21:27:12 <ski> no brackets around `Left  l' and `Right r', here
21:27:21 <kallisti_> but is this true for only operators?
21:27:43 <kallisti_> > let f Right x = x in f (Right 2)
21:27:44 <lambdabot>   Constructor `Data.Either.Right' should have 1 argument, but has been given 0
21:27:46 <YellowOnion> monochrom, the more pythonic it is the more it hides the nature of the language it is written in.
21:28:26 <ski> yes : *because* the (invisible, syntactic) application "operator" is left-associative, `f Just x' means `(f Just) x', so if you mean `f (Just x)' you'll have to say that
21:33:44 <YellowOnion> The question remains is there a GUI toolkit that is better suited to haskell than another?
21:35:50 <byorgey> @package reactive-banana
21:35:50 <lambdabot> http://hackage.haskell.org/package/reactive-banana
21:35:56 <byorgey> YellowOnion: try that, perhaps
21:36:22 <byorgey> not a GUI toolkit in and of itself, but it makes a nice haskelly wrapper on top of whatever GUI toolkit you want to use
21:37:16 <YellowOnion> byorgey, oh nice. thanks
21:38:01 <slack1256> >0.1 + 0.7
21:38:05 <slack1256> >0.1 + 0.6
21:38:26 <slack1256> > 0.1 + 0.7
21:38:27 <lambdabot>   0.7999999999999999
21:38:32 <slack1256> > 0.1 + 0.6
21:38:33 <lambdabot>   0.7
21:38:38 <slack1256> why does this happend?
21:38:52 <slack1256> or how to avoid it?
21:39:01 <YellowOnion> slack1256, everything is not as it seems
21:39:39 <YellowOnion> > 0.8
21:39:40 <slack1256> YellowOnion: are you saying that that is just it representation (how is showed to the world)?
21:39:41 <lambdabot>   0.8
21:40:03 <adnam> slack1256: floating point operations are imprecise, if you need 0.1+0.7 to be exactly 0.8 you should not be using them
21:40:14 <YellowOnion> slack1256, not 100% sure but IEEE floats aren't 1:1 matching with decimal
21:40:25 <tikhonjelvis> They can't be because math is annoying infinite.
21:40:45 <slack1256> yeah. how can i avoid this?
21:40:52 <slack1256> should i use Data.Ratio?
21:40:56 <tikhonjelvis> Get a computer with infinite memory ;)
21:41:14 * ski wonders about `North' in `noMove    = return $ Move c North'
21:41:17 <YellowOnion> slack1256, you can use decimal/fixed point math, but it'll be really slow
21:41:27 <slack1256> i very near that (i got a whole campus at my disposal xD)
21:41:30 <tikhonjelvis> Haskell also supports rational numbers, doesn't it?
21:41:34 <kallisti_> ski: me too
21:41:36 <tikhonjelvis> > 1/2
21:41:37 <lambdabot>   0.5
21:41:46 <mzero> slack1256: YellowOnion  -- yes, IEEE floats, which you get in almost all languages cannot represent 1/10s exactly
21:41:49 <mzero> none of them do
21:41:58 <pennsp> hey guys
21:42:00 <YellowOnion> slack1256, or you can round which is probably got a 1/10000000 chance of being wrong
21:42:06 <kallisti_> ski: really at that point I probably shouldn't be working with Moves but it's convenient for most of the rest of the code.
21:42:18 <YellowOnion> > 0.8 + 0.0
21:42:19 <lambdabot>   0.8
21:42:29 <kallisti_> ski: I use North because it should be irrelevant there.
21:42:29 <slack1256> which rounding function are Double -> Double?
21:42:31 <mzero> so the question is - what purpose are you using these for, and that determines what to do:
21:42:46 <kallisti_> :t (round,ceil,floor)
21:42:47 <lambdabot> Not in scope: `ceil'
21:42:52 <kallisti_> :t (round,ceiling,floor)
21:42:53 <lambdabot> forall a b a1 b1 a2 b2. (RealFrac a, Integral b, RealFrac a1, Integral b1, RealFrac a2, Integral b2) => (a -> b, a1 -> b1, a2 -> b2)
21:42:57 <mzero> if you are representing, say, 100ths of some currency, then Float or Double are the wrong type
21:43:40 <ski> > 1/2 :: Rational
21:43:40 <lambdabot>   1 % 2
21:43:42 <mzero> if you are representing real world measurements, then Float or Double are fine, what you need is just proper formatting (rounded to n places, where n is usually about 6)
21:44:03 <slack1256> mzero: that! where do i look for that
21:44:12 <mzero> do you want to round the value as you compute for it, or only when you print it?
21:44:27 <slack1256> computing it
21:45:02 <slack1256> i am doing statistics, so certain values should belong to certain ranges
21:45:06 <kallisti_> slack1256: so then you're working with integers?
21:45:08 <kallisti_> ah
21:45:20 <YellowOnion> slack1256, end of the day every language has ends up like this because they all use the same floats
21:45:27 <ski> @type [round,ceiling,floor,truncate]
21:45:28 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
21:45:41 <tikhonjelvis> Is there some easy way to get an upper bound on the error of a set of operations on floating point numbers?
21:45:49 <slack1256> no i am analizing an apacheLog of a website, (specifically the size of the transfer)
21:45:55 <mzero> what? wait, if you are doing statistics, then generally you do NOT want to round intermediate results
21:45:59 <mzero> why would you want to do that?
21:46:10 <YellowOnion> slack1256, and also 0.99999... is the same as 1.0
21:46:16 <adnam> tikhonjelvis: well, it's not trivial, but not very hard
21:46:19 <slack1256> and proving empirically that they represent a pareto distribution
21:46:52 <slack1256> YellowOnion: right. because there isn't a number between 1.0 and 0.999 (a basic propiety of the reals)
21:47:21 <YellowOnion> slack1256, there's a diffrence between 0.999 and 0.999...
21:47:30 <slack1256> yeah. sorry about that
21:47:38 <adnam> tikhonjelvis: see numerical analysis
21:47:40 <kallisti_> slack1256: I'm not entirely sure you want to round anything.
21:47:43 <mzero> in any event - Data.Fixed is where to look
21:48:07 <slack1256> okay, thanks mzero
21:48:09 <ski> (kallisti_ : btw, you seem to have some trailing spaces)
21:48:11 <mzero> use showFixed for nicely printing values
21:48:23 <YellowOnion> slack1256, http://en.wikipedia.org/wiki/IEEE_float
21:48:31 <slack1256> yeah, i should read that too
21:49:00 <kallisti_> ski: at end of file or at end of lines?
21:49:01 <slack1256> I wouldn't like to be discredit because i didn't read the standard.
21:49:21 <tikhonjelvis> I think even if you read the standard, understanding exactly how it behaves is tricky.
21:49:30 <kallisti_> ski: ah
21:49:48 <mzero> it is not all that complex, really
21:50:17 <YellowOnion> slack1256, actually this: http://en.wikipedia.org/wiki/Double_precision
21:50:26 <mzero> and, while some aspects may seem strange at first, it is a very well thought-out and time-tested stanadard
21:50:29 <tikhonjelvis> It isn't that simple either :P. Of course, I only learned about them in depth last semester.
21:50:33 <slack1256> i know about machine representation but even so
21:50:43 <ski> kallisti_ : lines
21:50:50 <YellowOnion> > 1/3 + 1/3 + 1/3
21:50:50 <ski> well, at least one line
21:50:51 <lambdabot>   1.0
21:50:57 <tikhonjelvis> Oh yes, it's very well developed and thought-out; it's still complicated just because there is no good, simple solution.
21:51:02 <kallisti_> ski: nothing a regex won't solve
21:51:02 <YellowOnion> no rounding error :D
21:51:46 <YellowOnion> slack1256, check lambda bot
21:51:53 <ski> kallisti_ : btw, i'm not sure whether you're aware that `(MonadReader WalkInfo m) => ' could be written as `MonadReader WalkInfo m => ' -- a matter of taste, though
21:52:20 <kallisti_> ski: I'm aware of it but I forget about it.
21:52:24 <kallisti_> if that makes sense. :P
21:52:42 <ski> some people write the brackets there anyway, consistently
21:52:52 <kallisti_> ski: I'm not really sure if it's worth having all of those constraints when I'm probably only going to use one monad stack, maybe.
21:52:56 <ski> some other (like me) omit them, in the cases where it's allowed
21:53:21 <ski> (similarly for `deriving')
21:54:02 * ski thinks it looks a little funny to both indent `where', and indent the clauses inside it, more
21:54:11 <ski> (but that's also taste/style)
21:54:24 <kallisti_> ski: I just mash tab in haskell-mode :P
21:54:34 <kallisti_> but yes I thought it was somewhat odd as well.
21:54:46 * ski typically does
21:54:50 <ski>   foo x y = ...
21:54:50 <tikhonjelvis> kallisti_: That is exactly how I indent all programming languages :)
21:54:52 <ski>     where
21:54:56 <ski>     frob z = ...
21:54:58 <ski>     ...
21:55:01 <tikhonjelvis> Eh
21:55:02 <tikhonjelvis> I like
21:55:04 <tikhonjelvis> f x y = ...
21:55:10 <tikhonjelvis> where bar = ...
21:55:18 <tikhonjelvis> Well, with the where indented a bit.
21:55:39 <ski> sometimes (not that commonly) i do that, if the block inside the `where' is only one line
21:55:54 <kallisti_> sometimes I use let when I think it's more clear, actually.
21:56:01 <kallisti_> if it's a few small things.
21:56:12 <kallisti_> it's easier to see those upfront than to track them down later.
21:56:55 <ski> kallisti_ : re constraints -- in some cases the code is more easily understood if you can ignore some aspects of the concrete monadic stack
21:57:17 <kallisti_> ski: yes that's true. I can tell exactly which of my functions can be used with which kinds of monads.
21:57:27 <kallisti_> which is useful if I ever want to use a slightly different stack/monad
21:57:34 <ski> i.e. in case the definition only needs a few of the components, it could be easier to read, getting type guarantees that it can't do anything else ("funny")
21:58:05 <kallisti_> ski: in particular I think chebyshev' needs fixing badly. :P
21:58:32 <ski> in what regard ?
21:59:33 <kallisti_> I don't know something seems... wrong. I feel like there's a better way but I have no idea what it is.
21:59:38 <kallisti_> my current approach seems like a hack.
21:59:45 * ski has only been doing a look-and-feel overview of the code, haven't attempted to understand much of the algorithmics
21:59:58 <ski> (or even what depends on what)
22:00:56 <kallisti_> ski: well it's for a chess variant that I've created. chebyshev' lists all of the squares that are chebyshev distance N from a central point
22:01:19 * ski has no idea what "chebyshev distance" is
22:01:20 <kallisti_> so the 0th  element of the list is all the distance 1 points, then distance 2, etc
22:01:43 <kallisti_> well, in chess, it's the minimum number of steps for a king to get from one square to another
22:01:53 <kallisti_> a knight, for example, can move to any square with a chebyshev distance of 2.
22:02:02 <Sgeo> Uh
22:02:09 <Sgeo> Two in the same diagonal?
22:02:12 <kallisti_> oh...
22:02:13 <kallisti_> no :P
22:02:38 <insertpseudonym> hey quick question
22:02:48 <insertpseudonym> and I'm gonna preface this by noting I'm a complete noob
22:02:56 <kallisti_> Sgeo: two of the same diagonal or cardinal is not allowed.
22:03:00 <Sgeo> Also, I think the squares a knight can hit are chebyshev distance 3 (not that all distance 3 squares are hitable)
22:03:10 <Sgeo> Unless I misunderstood your definition
22:03:11 <insertpseudonym> but what's the best way to debug a "parse error in pattern" error while compiling?
22:03:11 <kallisti_> Sgeo: nope 2.
22:03:51 <kallisti_> Sgeo: oh wait.
22:03:57 <kallisti_> yes 2
22:04:07 <Sgeo> insertpseudonym, find the line, look nearby for any patterns (the arguments, or the things before -> in case of statements), check that it's syntactically correct
22:04:17 <kallisti_> Sgeo: note that it's the minimum number of steps
22:04:35 <kallisti_> Sgeo: so cardinal + diagonal for knights
22:04:46 <Sgeo> Oh, I see
22:04:59 <insertpseudonym> Sgeo: thought so arrite I'll give it a shot thx
22:05:04 <Sgeo> I wasn't thinking diagonal movement
22:09:13 <ski> kallisti_ : hm, so a `max'-based norm/distance thing, then ?
22:09:38 <Nisstyre> like my solution to Project Euler #4? http://codepad.org/j5icjxTK
22:10:05 * Nisstyre is finally getting the hang of monads
22:10:06 <kallisti_> ski: believe so. I don't understand the math as it applies to vector spaces.
22:10:10 <kallisti_> just chess. :P
22:12:38 <kallisti_> one benefit of using LogicT is that mplus is far more efficient
22:12:42 <kallisti_> than lists.
22:12:49 <kallisti_> so I guess my code isn't too bad.
22:14:25 <kallisti_> speaking of efficiency
22:14:37 <tommd> preflex: seen preflex
22:14:51 <kallisti_> I was wondering if there's a significant difference between the access times for function arguments and free variables in STG
22:15:19 <kallisti_> to the extent that it's worth adding a few extra function arguments instead of relying on other variables in scope.
22:15:38 <kallisti_> (in pieces of code that are worth the effort to optimize, of course)
22:17:34 <kallisti_> if I recall correctly the free variables are stored in a table, while the function arguments are stored as offsets from the closure's pointer, which is stored in a special register.
22:18:23 <insertpseudonym> I'm getting a compile time error on a line that looks like <function> [] = []
22:18:31 <insertpseudonym> needless to say, that's probably not the issue right?
22:18:59 <kallisti_> this highly depends on the specific error.
22:19:11 <kallisti_> it could be that it expected a different type other than lists.
22:19:15 <insertpseudonym> (the declaration just before it is <function> :: [Integer] -> [Integer]
22:19:33 <kallisti_> are there other cases?
22:19:36 <kallisti_> do they return the same type?
22:19:43 <Sgeo> insertpseudonym, is the error the same one as before?
22:20:00 <insertpseudonym> yup I gave up for a bit to do some reading now I'm back to it haha
22:20:01 <Sgeo> Note that in general (don't know about GHC), you shouldn't trust things to always find the exact line
22:20:10 <kallisti_> oh it's a parse error.
22:20:15 <insertpseudonym> yea
22:20:17 <Sgeo> The error could be a line above or below it
22:20:22 <kallisti_> yes
22:20:36 <insertpseudonym> well the one below is <function> x:[] = x:[]
22:21:06 <insertpseudonym> the one below that is more complicated (where the action happens) <function> x:(y:zs)
22:21:12 <kallisti_> should be function (x:[]) = x:[]
22:21:17 <kallisti_> parens are required there
22:21:22 <insertpseudonym> oh no way
22:21:27 <insertpseudonym> that explains it obviously
22:21:28 <kallisti_> yep
22:21:36 <insertpseudonym> thx!
22:21:38 <kallisti_> we were
22:21:40 <kallisti_> oddly enough
22:21:42 <kallisti_> just talking about that. :P
22:22:08 <insertpseudonym> clearly I should have paid attention to the chat and not LYAH lol
22:23:24 <ski> kallisti_ : beginning to drift off to sleep here -- wondering whether there'd be a point in factoring out `iterate (>>= oneStep)'
22:25:48 <kallisti_> ski: factor out how?
22:26:13 <insertpseudonym> out of curiosity, since I know a bunch of you are fairly pro at this, how long does it take to become sufficiently adept at haskell? and are any of you using it in industry applications?
22:26:19 <kallisti_> insertpseudonym: I think LYAH shows the parens but maybe doesn't mention them.
22:26:42 <startling> can I have a data type that's "Constructor A | Constructor B | SomeOtherType"?
22:26:52 <kallisti_> startling: no
22:27:12 <ski> there's probably not that much (readability) gain to it -- i just meant giving it a name in the `where' layout-block (or maybe further out)
22:27:39 <ski> startling : no subtyping in Haskell
22:27:47 <ski> @where O'Haskell
22:27:47 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/
22:27:47 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
22:27:53 <ski> @where Timber
22:27:53 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
22:27:53 <startling> hm, okay. I guess I'll use a constructor that wraps this other type, then.
22:28:04 <ski> has subtyping
22:28:22 * ski wonders what startling's actual type is
22:28:27 <kallisti_> startling: yes that's one way to do it.
22:29:10 <startling> oh, i guess I can just put these two types together in the first place.
22:29:34 <kallisti_> insertpseudonym: there's not too many "industry" Haskell jobs out there. How long it takes to become comfortable with Haskell depends on the person and also on how much effort they expend.
22:30:57 <kallisti_> I've known Haskell for at least one and a half years now. At first I just put a little bit of effort at a time, and now I am writing my first somewhat large program.
22:31:45 <insertpseudonym> kallisti_: Yeah that's generally what I hear. I'm studying it more or less to explore the functional paradigm and eventually to use it to expand my understanding of recursion. Also, I figure I might pickup Scala somewhere down the line and especially since it seems to be going mainstream.
22:32:11 <kallisti_> well Haskell has plenty of recursion.
22:34:30 <insertpseudonym> Yup. Out of curiosity, is it optimized well? For example, the earlier function I was writing was a recursive method of iterating on every other element (dependent on length mod 2 of course) since I can't find a more straightforward way to do it.
22:35:06 <startling> wow, a lot of my code just imploded when I realized datatype A was essentially the same type as datatype B. thanks
22:35:10 <startling> (imploded in a good way)
22:35:53 <insertpseudonym> *every other from the right, I should clarify
22:36:50 <ski> startling : great !
22:37:13 * startling has reached enlightenment.
22:37:33 <ski> insertpseudonym : would you care to show it ?
22:37:56 <kallisti_> insertpseudonym: it's not often that you want to iterate every other element.
22:38:18 <kallisti_> er, map over every other element, I should say.
22:39:00 <kallisti_> also using length in any kind of list processing algorithm is usually a bad idea,
22:39:10 <insertpseudonym> kallisti_:  yea, this is for a convoluted problem meant to demonstrate recursion I think.
22:39:13 <kallisti_> because a) you may want an infinite list b) it's O(n)
22:39:29 <insertpseudonym> what?! haskell doesn't store the length in memory?
22:39:31 * ski isn't sure insertpseudonym meant she/he/it actually used *`length'*
22:39:38 <kallisti_> > [1..]
22:39:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:39:46 <kallisti_> insertpseudonym: how do you propose we store the length of this in memory>
22:39:57 <kallisti_> keep in mind, there are other container types. singly linked lists are not the only one.
22:40:01 <kallisti_> those types may store their length in memory.
22:40:10 <ski> e.g. arrays
22:40:23 <insertpseudonym> ah I did read that it's linked-list backed
22:40:32 <ski> @src []
22:40:32 <lambdabot> data [] a = [] | a : [a]
22:40:34 <insertpseudonym> okay I'll look into arrays then
22:40:39 * hackagebot wai-extra 1.0.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.0.0.1 (MichaelSnoyman)
22:40:43 <kallisti_> insertpseudonym: ..not the direction you want to go.
22:40:48 <kallisti_> for this problem.
22:40:51 <startling> I love that you can define linked lists in one line in haskell.
22:40:52 * ski still wonders what insertpseudonym is really wanting to do
22:41:52 <insertpseudonym> ski: haha sorry...so it's a rather ridiculous (read: unlikely) problem of wanting every other element from the last one (so which index values are returned is dependent on length mod 2)
22:42:30 <insertpseudonym> so I wrote the base cases from before and then a third case that breaks any list of size>1 into x:y:zs
22:42:51 <ski> what do you want to use the indices for ?
22:42:56 <insertpseudonym> if that list is even-sized, then recurse as follows x : 2*y : <function> zs
22:43:04 <insertpseudonym> the other case is just backwards
22:43:32 <ski> other case ?
22:43:40 <ski> isn't it just three cases ?
22:43:45 <insertpseudonym> 2*x : y : <function> zs
22:43:48 <insertpseudonym> sorry the second guard
22:43:56 <insertpseudonym> of the third case
22:44:09 <insertpseudonym> | otherwise
22:44:11 <ski> i'm not getting the picture, paste the code ?
22:44:22 <insertpseudonym> is there a way to do it w/ newlines?
22:44:22 <kallisti_> maybe he doesn't mean literally the indices...
22:44:36 <ski> kallisti_ : yeah, i'm trying to determine that :)
22:45:10 <kallisti_> insertpseudonym: describe what you mean by "every other element from the last one"
22:45:14 <ski> insertpseudonym : there is no need to break line for guards, but it's usually nicest to do that
22:45:22 <ski> @where paste
22:45:23 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
22:45:42 <sopvop> Hi there #haskell. Whats the idiomatic way in haskell to build a tree from a list like that http://hpaste.org/56908 ?
22:45:45 <ski> the first paste site is currently unavailable, but you could try the next one
22:46:02 <ski> (hm, or maybe it's up now again (?))
22:46:09 <sopvop> Looks like its up
22:46:14 <insertpseudonym> kallisti_: so, if you have [1,2,3] then only the 2 should be modified; [1,2,3,4] => the 3 and 1 should be modified
22:46:32 <kallisti_> sopvop: http://www.haskell.org/ghc/docs/7.2.2/html/libraries/containers-0.4.1.0/Data-Tree.html#g:3
22:46:37 <kallisti_> check out these functions in Data.Tree
22:46:58 <kallisti_> insertpseudonym: oh...
22:47:01 <sopvop> Ok, thanks
22:47:38 <kallisti_> insertpseudonym: generally basing things on the end of a singly linked list is a bad idea.
22:47:49 <kallisti_> but you can do it with just three cases I believe. maybe even two.
22:47:55 <hpaste_> insertpseudonym pasted “SimpleFunction” at http://hpaste.org/56909
22:48:28 <kallisti_> note that you can use @ to refer to the whole pattern
22:48:40 <kallisti_> ls@(x:(y:(zs))
22:48:51 <insertpseudonym> kallisti_: thx, I was looking for that
22:49:11 <insertpseudonym> and yea I'm still getting the hang of dealing with infinite cases
22:49:23 <insertpseudonym> as you can tell, I'm a noob at this haha
22:50:32 <kallisti_> not every problem can terminate on infinite lists, however many can. I'd say it's preferrable that list code not be concerned with the total length or  the endpoint
22:50:37 <kallisti_> a linked list is best suited for linear processing.
22:50:38 <kallisti_> but
22:50:43 <kallisti_> for educational purposes it's fine I suppose.
22:51:36 <insertpseudonym> I miss my own data structure implementations haha. I wrote an extensive custom library in Java and C. Now I'm back at square one.
22:51:46 <kallisti_> insertpseudonym: this code seems to be fine. you could remove the (x:[]) case however
22:52:00 <kallisti_> by simply taking the length, and if it's odd plug the tail into your processing code
22:52:12 <kallisti_> otherwise process the whole thing.
22:52:15 <kallisti_> if that makes sense.
22:52:25 <kallisti_> but I don't know if that's necessarily any better.
22:52:40 <kallisti_> insertpseudonym: no need to implement most data structures they're already done for you.
22:52:44 <kallisti_> but you can if you want.
22:52:59 <insertpseudonym> kallisti_: yea I see what you mean - good point
22:53:12 <kallisti_> also are you familiar with higher order functions?
22:53:20 <kallisti_> you could instead apply an arbitrary function, instead of simply doubling every number.
22:53:22 <startling> insertpseudonym: why don't you reverse your list and then do every other?
22:53:43 <kallisti_> startling: well he would have to reverse it again if he wants the same order.
22:53:54 <insertpseudonym> I'm aware there's a way involving cycle map filter
22:53:58 <insertpseudonym> still not familiar with them yet
22:54:01 <insertpseudonym> I'll get there
22:54:08 <startling> kallisti_: so?
22:54:14 <kallisti_> well it's easier when you go from the front instead of relying on the length.
22:54:23 <insertpseudonym> reversing links is costly startling
22:54:36 <startling> but so is getting the length.
22:54:42 <startling> wait, is this the same problem as before?
22:54:46 <insertpseudonym> so I now know yea
22:55:04 <insertpseudonym> the code I posted you mean? yup
22:55:20 <insertpseudonym> it's part of a larger problem of implementing a credit-card number checker
22:55:39 * hackagebot zeromq-haskell 0.8.3 - Bindings to ZeroMQ 2.1.x  http://hackage.haskell.org/package/zeromq-haskell-0.8.3 (ToralfWittner)
22:55:47 <insertpseudonym> apparently, verification is done via a specific sequence of applied operations (thus inputs are presumed bounded I should note)
22:55:54 <kallisti_> insertpseudonym: Data.Sequence is a good data type for both forward and reverse traversal.
22:56:03 <kallisti_> of arbitrary length
22:56:09 <kallisti_> Array or Vector would be good for a fixed size.
22:57:09 <insertpseudonym> Data.Sequence is doubly linked?
22:57:17 <kallisti_> not really no
22:57:18 <ski> insertpseudonym : btw, `== True' is useless
22:57:55 <kallisti_> Data.Sequence is a 2-3 finger tree
22:58:00 <insertpseudonym> ski: it's implied?
22:58:18 <kallisti_> ski: True or False are implied by the type Bool, yes
22:58:28 <kallisti_> the == True does nothing
22:58:28 <kallisti_> er
22:58:34 <kallisti_> insertpseudonym: ^
22:58:48 <kallisti_> > True == True
22:58:49 <lambdabot>   True
22:58:59 <insertpseudonym> gotcha
22:59:13 <kallisti_> note that unlike in other languages you may familiar with, you can't do things like:
22:59:16 <kallisti_> > 2 == True
22:59:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
22:59:17 <lambdabot>    arising from the literal `2'...
22:59:20 <kallisti_> but you've probably already learned that.
22:59:39 <insertpseudonym> yea that I've seen
22:59:48 <insertpseudonym> I'll probably end up doing it a few times though
22:59:52 <insertpseudonym> too much C -.-
23:00:02 <kallisti_> one common mistake is thinking that mod returns a true-false value.
23:00:21 <kallisti_> > if 5 `mod` 2 then "odd!" else "even!"
23:00:23 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
23:00:23 <lambdabot>    arising from a use of ...
23:00:24 <kallisti_> doesn't work
23:00:33 <kallisti_> > if 5 `mod` 2 == 1 then "odd!" else "even!"
23:00:34 <lambdabot>   "odd!"
23:01:09 <insertpseudonym> have not seen that error before
23:01:21 <insertpseudonym> that's broadly applicable to languages I think
23:01:36 <kallisti_> many languages have an implicit notion of true and false that they use in booleans
23:01:42 <kallisti_> er
23:01:47 <kallisti_> conditonal statements rather.
23:02:14 <insertpseudonym> ^yup that's definitely true
23:02:28 <insertpseudonym> well I have to say, I'm loving Haskell's terseness so far
23:02:50 <insertpseudonym> the unfortunate tradeoff is that there a lot of ways to do something and the best option usually involves something very specific
23:03:13 <kallisti_> yes but there's often many ways to achieve the same thing
23:03:20 <kallisti_> some better than others, but not all are necessarily the wrong way.
23:03:36 <kallisti_> not all the less effective ways, rather.
23:04:38 <kallisti_> > map (either (+1) id) . zipWith ($) (cycle [Left,Right]) $ [1..100]
23:04:40 <lambdabot>   [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,2...
23:04:48 <kallisti_> > map (either (*2) id) . zipWith ($) (cycle [Left,Right]) $ [1..100]
23:04:50 <lambdabot>   [2,2,6,4,10,6,14,8,18,10,22,12,26,14,30,16,34,18,38,20,42,22,46,24,50,26,54...
23:05:23 <kallisti_> like I said, it's much easier when you're only interested in the front of the list.
23:05:29 <kallisti_> ;)
23:06:05 <insertpseudonym> kallisti_: that's briliant and some day I hope I can make sense of that 0.o
23:07:09 <startling> kallisti_: why is that $ in parentheses?
23:07:17 <kallisti_> I've never actually found a need for such a thing though..
23:07:27 <kallisti_> startling: because I'm passing it as an argument to zipWith
23:07:33 <startling> oh, got it.
23:07:48 <kallisti_> > zipWith (+) [0..] [1..]
23:07:49 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:07:51 <startling> my head parsed it as prefix notation and I was really confused.
23:08:14 <kallisti_> I'm applying an infinite cycle of left and right to each element of the list, basically.
23:08:23 <kallisti_> then I use either to apply two different functions to the lefts and rights
23:08:29 <startling> yeah
23:09:40 <insertpseudonym> startling: kallisti_ is it common to favor prefix notation at a more advanced level?
23:09:51 <kallisti_> not in particular
23:09:55 <startling> > let fib = 1 : 1 : zipWith (+) fib $ tail fib
23:09:56 <lambdabot>   not an expression: `let fib = 1 : 1 : zipWith (+) fib $ tail fib'
23:09:59 <kallisti_> I'm not using ($) in a prefix call.
23:10:04 <tikhonjelvis> Unless you're a lisper :)
23:10:10 <startling> kallisti_: not really, but I was a schemer in a past life
23:10:13 <kallisti_> startling: $ doesn't work like that
23:10:23 <kallisti_> $ has lower precedence than :
23:10:35 <startling> > let fib = 1 : 1 : zipWith (+) fib (tail fib)
23:10:36 <lambdabot>   not an expression: `let fib = 1 : 1 : zipWith (+) fib (tail fib)'
23:11:04 <startling> hm, I can do it with map but not with zipWith
23:11:08 <startling> what am I doing wrong?
23:11:25 <tikhonjelvis> @let fib = 1 : 1 : zipWith (+) fib (tail fib)
23:11:27 <lambdabot>  Defined.
23:11:32 <kallisti_> ($) isn't being used in a prefix call, it's being passed as an argument to another function. It's not a style preference it's just how you do that.. :P
23:11:33 <tikhonjelvis> I think it's fine.
23:11:44 <tikhonjelvis> > fib 10
23:11:45 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
23:11:49 <kallisti_> > fib
23:11:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:12:00 <tikhonjelvis> Heh, I wasn't paying attention to what I was typing :)
23:12:12 <tikhonjelvis> That's why I like statically typed languages.
23:12:15 <tikhonjelvis> usually
23:12:20 <kallisti_> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:12:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:12:43 <kallisti_> what's fun is starting off with different numbers
23:12:47 <kallisti_> > let fibs = 1 : 3 : zipWith (+) fibs (tail fibs) in fibs
23:12:48 <lambdabot>   [1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,...
23:13:01 <insertpseudonym> that's actually really fascinating
23:13:07 <tikhonjelvis> @let fibs' a b = a : b : zipWith (+) fibs' (tail fibs')
23:13:07 <lambdabot>  <local>:2:32:
23:13:07 <lambdabot>      Couldn't match expected type `[a]'
23:13:07 <lambdabot>             against in...
23:13:10 <insertpseudonym> it's such a different way of looking at it, but it's very elegant
23:13:20 <tikhonjelvis> yeah
23:13:59 <kallisti_> > fix (scanl (+) 0 . (1:))
23:14:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:14:06 <kallisti_> what's this makes sense to you.... I'm sorry, I can't help you.
23:14:11 <kallisti_> s/what's/once/
23:14:16 <kallisti_> I need to go to sleep. :P
23:14:35 <startling> how do I make lambdabot tell me what fix does?
23:14:42 <kallisti_> @src fix
23:14:42 <lambdabot> fix f = let x = f x in x
23:14:45 <kallisti_> here lies madness.
23:14:49 <tikhonjelvis> heh
23:14:57 <startling> oh jeeze
23:15:00 <tikhonjelvis> @type fix
23:15:01 <lambdabot> forall a. (a -> a) -> a
23:15:06 <insertpseudonym> wthhhhh
23:15:13 <kallisti_> it's recursion
23:15:19 <insertpseudonym> yea
23:15:21 <insertpseudonym> of some kind lol
23:15:27 <kallisti_> it's literally a recursive primitive.
23:15:42 <kallisti_> it's also known as the Y combinator from lambda calculus and SKI and such.
23:15:43 <insertpseudonym> nah I see it, it just looks like it'd do horrible things used the wrong way
23:15:58 <Enigmagic> @type mfix
23:15:59 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:16:07 <tikhonjelvis> It's just equal to f (f (f (f...x...))), isn't it?
23:16:14 <kallisti_> > fix f
23:16:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:16:15 <lambdabot>    `GHC.Show.Show a'
23:16:15 <lambdabot>      a...
23:16:20 <kallisti_> > fix f :: Expr
23:16:21 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
23:16:29 <startling> huh. that's awesome.
23:16:46 <tikhonjelvis> I think we covered it in SICP too.
23:16:48 <kallisti_> so the argument to the function refers to a recursive call of the entire function
23:16:54 <amiller> i love watching tricks on lambdabot
23:17:22 <startling> is there a way to get a list minus the first n elements?
23:17:23 <insertpseudonym> kallisti is a magician hah
23:17:27 <tikhonjelvis> drop
23:17:27 <kallisti_> ...
23:17:28 <wvoq> :t drop
23:17:29 <lambdabot> forall a. Int -> [a] -> [a]
23:17:37 <startling> wooh
23:17:49 * kallisti is not really doing anything too fancy. 
23:17:52 <startling> > drop 0 [1, 2, 3]
23:17:53 <lambdabot>   [1,2,3]
23:17:55 <kallisti> maybe a little tricky.
23:18:38 <kallisti> I know all the standard tricks. :P
23:18:40 <kallisti> oh here's a good one:
23:18:52 <kallisti> > (`replicateM` "abc") =<< [0..]
23:18:53 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
23:19:16 <kallisti> the sequence function for lists is incredibly useful for combinatorial problems like this.
23:19:23 <insertpseudonym> where was haskell when I was studying grammars haha
23:19:36 <tikhonjelvis> Hah, I was just a lecture about grammars today!
23:19:43 <startling> is replicateM like cycle?
23:19:47 <kallisti> no
23:19:54 <kallisti> @src replicateM
23:19:55 <lambdabot> replicateM n x = sequence (replicate n x)
23:20:07 <startling> @src replicate
23:20:07 <lambdabot> replicate n x = take n (repeat x)
23:20:07 <tikhonjelvis> I love how the cartesian product of two lists is just liftM2 (,)
23:20:15 <kallisti> sequence is a monad function
23:20:26 <startling> yeah, I know sequence
23:20:39 <startling> (just not replicate)
23:20:49 <kallisti> it's odd that you know sequence but not replicate.
23:20:58 <startling> my knowledge is pretty spotty
23:20:59 <kallisti> I learned about replicate way before sequence.
23:21:44 <startling> I haven't read a whole thing, just a bunch of stuff on monads.
23:22:08 <tikhonjelvis> Is the whole thing the Haskell report?
23:22:18 <tikhonjelvis> Or some book?
23:22:26 <startling> any book or long tutorial, really
23:22:34 <tikhonjelvis> ah
23:22:34 <insertpseudonym> well I saw a lot of these in LYAH earlier
23:22:36 <insertpseudonym> http://learnyouahaskell.com/starting-out
23:22:50 <tikhonjelvis> Here's another lambdabot trick:
23:22:53 <tikhonjelvis> @where LYAH
23:22:53 <lambdabot> http://www.learnyouahaskell.com/
23:22:54 <insertpseudonym> lol "starting-out" that's where I am I guess haha
23:24:09 <startling> Yeah, I've read bits and pieces of LYAH but I get bored by the parts I kind-of understand, so I end up missing a lot.
23:24:13 <insertpseudonym> tikhonjelvis: nice. I noticed that one, but didn't think it was backed by that comprehensive a dictionary.
23:24:28 <tikhonjelvis> LYAH comes up. A lot. :)
23:24:31 <kallisti> > filter ((/=1).length.group) . replicateM 5 $ "AKQJT98765432"
23:24:32 <lambdabot>   ["AAAAK","AAAAQ","AAAAJ","AAAAT","AAAA9","AAAA8","AAAA7","AAAA6","AAAA5","A...
23:25:17 <kallisti> list of 5 card hands
23:25:22 <startling> ha.
23:25:42 <startling> maybe I should just read the standard prelude
23:25:46 <kallisti> > S.size . S.fromList . filter ((/=1).length.group) . replicateM 5 $ "AKQJT98765432"
23:25:47 <tikhonjelvis> Really good hands first, of course!
23:25:50 <lambdabot>   371280
23:25:51 <kallisti> startling: LYAH is a good place to start
23:25:56 <insertpseudonym> I'm ashamed for not recognizing the values lol, but I saw what it was doing first
23:26:28 <wvoq> it repays rereading too
23:26:37 <wvoq> I just noticed a Blood Meridian reference in it the other day
23:26:49 <tikhonjelvis> The prelude?
23:26:57 <kallisti> yes being familiar with the prelude is good as well. also data.list, data.char, data.maybe, data.either . . .
23:27:15 <tikhonjelvis> control.monad and control.applicative
23:27:18 <kallisti> yes
23:27:26 <kallisti> eventually
23:27:42 <tikhonjelvis> And then, in the far future, catagories and arrows. What fun.
23:28:03 <startling> I think I'm pretty solid on functions and types, though. and I'm almost there on monads. I just don't know what a lot of the built-ins do.
23:28:25 <tikhonjelvis> Heh, you'll learn, likely by rewriting them yourself.
23:28:32 <wvoq> exactly
23:28:40 <kallisti> I invented ReaderT today. :P
23:28:46 <startling> yeah. >.> I reinvented parsec's between earlier today.
23:28:48 <tikhonjelvis> The real beauty of the standard functions is how simple yet useful they are.
23:29:21 <wvoq> I rediscovered that config files are monoids /self-parody
23:30:39 * hackagebot xournal-types 0.3.1 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.3.1 (IanWooKim)
23:30:41 * hackagebot xournal-render 0.5.1 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.5.1 (IanWooKim)
23:31:42 <kallisti> ......slow netjoin
23:34:02 <insertpseudonym> kallisti: what's the project you said you're working on? Wondering what I should aim to work on down the line as I get better.
23:34:33 <tikhonje`> I suggest writing your own programming language. It's fun!
23:34:40 <startling> wooh that's what I'm doing
23:34:59 <tikhonje`> Grr, my internet problems have eaten half my username :(
23:35:14 * kallisti recently read about conduits and will soon be trying them out once he gets his networked portal chess implementation going.
23:35:15 <insertpseudonym> I might do that. Palantir's Hedgehog inspired me not gonna lie haha.
23:35:24 <kallisti> insertpseudonym: ^  chess server
23:35:29 <tikhonjelvis> Oh, I saw a presentation on hedgehog.
23:35:40 <insertpseudonym> tikhonjelvis: no way! where do u study?
23:35:44 <tikhonjelvis> Berkeley
23:35:53 <insertpseudonym> tikhonjelvis: thought so
23:35:56 * kallisti jealous.
23:35:56 <insertpseudonym> that's awesome
23:36:00 <tikhonjelvis> I wasn't as inspired as you though
23:36:00 <insertpseudonym> I'm at Penn
23:36:03 <tikhonjelvis> ah
23:36:23 <insertpseudonym> tikhonjelvis: and coming to the west coast this summer actually. I can't wait!
23:36:25 <tikhonjelvis> I mean, some of their technology is neat, but I *don't* want to use Java.
23:36:35 <tikhonjelvis> Heh, I'm trying to find a job somewhere else :)
23:36:45 <tikhonjelvis> It's a really nice place, but I've already been here for eight years.
23:36:59 <insertpseudonym> kallisti: very nice. that one's a classic
23:37:10 <insertpseudonym> tikhonjelvis: don't come east lol. just take my word for it
23:37:21 <tikhonjelvis> In a perfect world, I want to go abroad.
23:37:31 <insertpseudonym> tikhonjelvis: what year are you?
23:37:35 <tikhonjelvis> second
23:37:44 <insertpseudonym> ah yea then this is around when you apply
23:37:58 <insertpseudonym> by all means you should! I couldn't escape my curriculum
23:38:03 <tikhonjelvis> I've already had a couple of internships. I hope I can afford being picky :)
23:38:21 <insertpseudonym> tikhonjelvis: very nice! where at?
23:38:26 <kallisti> > foldr1 (flip const)  [1..1000000000]
23:38:30 <lambdabot>   mueval-core: Time limit exceeded
23:38:37 <tikhonjelvis> A company called Guidewire (they have their own language called Gosu)
23:38:43 <tikhonjelvis> and then a tiny startup in SF>
23:38:44 <kallisti> > foldr1' (flip const)  [1..1000000]
23:38:45 <lambdabot>   Not in scope: `foldr1''
23:38:48 <kallisti> tikhonjelvis: nice language name
23:38:51 <kallisti> > foldr1 (flip const)  [1..1000000]
23:38:52 <sopvop> So, I've checked Data.Tree functions, and it's not what I need with http://hpaste.org/56908, funcs there build the whole tree from one element. And shape of my tree is determined by several objects in list. I guess I'll do it with stack, like in any other language. :)
23:38:53 <lambdabot>   1000000
23:39:14 <tikhonjelvis> The sad thing is that there's a Ruby library (or something) with the same name that's more popular :(
23:39:15 <kallisti> sopvop: several objects in a list is a single element.
23:39:26 <insertpseudonym> tikhonjelvis: that's great. Lack of experience was a big problem for me applying this year, but I somehow managed to get employed lol.
23:39:37 <insertpseudonym> tikhonjelvis: which startups are most highly regarded by UCB students?
23:39:38 <tikhonjelvis> where?
23:39:45 <tikhonjelvis> Startups?
23:40:05 <insertpseudonym> tikhonjelvis: coming to MV - I went corporate = P
23:40:08 <tikhonjelvis> I think Ness is pretty well-regarded, but that's probably because I know a bunch of the people ther.
23:40:13 <kallisti> sopvop: that parameter determines the initial value, it changes across the unfold
23:40:19 <insertpseudonym> tikhonjelvis: I do want to work at a shop like Palantir in the long run though
23:40:28 <Enigmagic> if it's big enough to have a reputation it's probably not really a startup anymore
23:40:29 <kallisti> sopvop: so you can pass a list and then deconstruct it as you go.
23:40:34 <tikhonjelvis> I really don't know about Palantir.
23:40:39 * hackagebot hxournal 0.6.3 - A pen notetaking program written in haskell  http://hackage.haskell.org/package/hxournal-0.6.3 (IanWooKim)
23:40:41 * earthy grins
23:40:46 <earthy> ah, the innocence of youth
23:40:48 <tikhonjelvis> The place I'm at now has four people. It's awesome.
23:41:13 <insertpseudonym> Enigmagic: yea fair point; I broadly define it as pre-IPO though I know everyone has a diff opinion
23:41:34 <tikhonjelvis> Ooh, also, FusionIO is really cool. Do they count as a startup?
23:41:36 <Enigmagic> most companies are pre-IPO
23:42:18 <earthy> IPO's are overrated.
23:42:26 <insertpseudonym> Enigmagic: *should clarify, pre-IPO/pre-buyout
23:42:27 <startling> is there something different than `<|>` to use for mutual recursion in parsec?
23:42:46 <insertpseudonym> Enigmagic: you're a startup until you start generating ROI imo
23:43:08 <sopvop> kallisti: so, if I have like [a, group1, b,c,group2,d,ungroup2,ungroup1,blah] and how do I get tree roo [a, group1 [b, c, group2 [d]] blah] going one by one element without stack?
23:43:19 <sopvop> roo -> root
23:43:27 <Enigmagic> insertpseudonym: does that include companies with bad business plans?
23:43:55 <insertpseudonym> tikhonjelvis: just looked at FusionIO, hadn't heard of it somehow; but I am on the wrong side of the country too lol
23:44:28 <tikhonjelvis> Steve Wozniak is either a founder or an early investor there.
23:44:30 <insertpseudonym> Enigmagic: haha that's been debated ad nauseum on HN I'd say
23:44:46 <Enigmagic> lots of "startups" are cash-flow positive
23:45:05 <earthy> I'd say that's goal one...
23:45:16 <insertpseudonym> most are built on flimsy models and buzzwords
23:45:24 <earthy> once you're cash-flow positive you can start worrying about the rest
23:45:35 <insertpseudonym> especially out here with all the wannabe Wharton entrepreneurs who don't actually know jack shit
23:46:15 <tikhonjelvis> Heh, business schools. I imagine it's the same everywhere :)
23:46:21 <Enigmagic> yah
23:46:29 <tikhonjelvis> Wow, Emacs matched my smilie faces' parentheses...
23:46:50 <startling> tikhonjelvis: vim does the same thing with delimitmate. it's annoying.
23:47:11 <insertpseudonym> this is courtesy of the CS kids at Penn - good for some laughs http://whartoniteseekscodemonkey.tumblr.com/
23:47:20 <tikhonjelvis> Heh, they were far enough apart that the matched one showed up below my screen. So it looked like Emacs was talking to me.
23:47:32 <Blkt> good day everyone
23:47:39 <frerich2> I think there's a pretty big cultural difference between startups in different countries. Say, the USA and Germany. I'm working for a small german shop (I was the second guy to join the team, so we were four guys in one room at the start, and now we're 21) which has been self-funded and profitable from the very beginning. I believe it's amatter of attitude whether you go for investment rounds and then expand quickly
23:47:39 <frerich2>  (without being profitable) to cover ground, or whether you go for 'natural' growth.
23:48:13 <kallisti> sopvop: once you hit group1 just advance until you hit group2, then return that list along with the parent node as (parent, children)
23:48:24 <kallisti> sopvop: the unfold handles the recursion.
23:48:38 <kallisti> er
23:48:44 <kallisti> s/group2/ungroup1/
23:48:45 <kallisti> rather
23:49:05 <insertpseudonym> frerich2: did you and your cofounders bootstrap? I've heard both sides, but generally bootstrapping + cost-minimization leads to success here. Of course, you also have to consider the nature of the venture as well.
23:49:51 <everyonemines> I was wondering if there were any other languages target the haskell System F IL.
23:49:52 <NothingMan65> Goood morning erebody
23:49:58 <everyonemines> *targeting
23:50:07 <frerich2> insertpseudonym: Sorry, I didn't want to imply that I'm a cofounder. Two guys foudned the company, worked for two years before they dared hiring somebody and then they hired another guy and me within two months.
23:50:16 <NothingMan65> What's the best way to get the equivalent of a triple nested for
23:50:19 <kallisti> everyonemines: I think STG would be a more likely target
23:50:33 <kallisti> System F is essentially a stripped down Haskell.
23:50:34 <tikhonjelvis> NothingMan65: That depends on exactly what you're doing.
23:50:51 <frerich2> insertpseudonym: I'm not sure what you mean with 'bootstrapping', but we're a company which builds products (unlike e.g. others which provide some sort of service or which just do consulting)
23:50:59 <tikhonjelvis> But if you're trying to use a loop in Haskell, it probably means you're thinking about it incorrectly.
23:51:00 <NothingMan65> for(i = 0 ; i < n -2 ; i++) for(j = i+1 ; j < n -1 ; j++) for(k = j+1 ; k < n-2 ; k++)
23:51:16 <tikhonjelvis> Yes, but what are you trying to accomplish with the loops?
23:51:33 <insertpseudonym> frerich2: ah got it. Still, that's really cool. Seems like you found one of the more solid, stable ones. Oh and bootstrapping just means paying everything out of pocket (the founders' really) when you start off
23:51:43 <NothingMan65> I want an array of i,j,k for all values of i,j,k in the loop
23:52:01 <tikhonjelvis> Does it have to be an array, or would a list do?
23:52:07 <NothingMan65> List is fine.
23:52:21 <frerich2> insertpseudonym: Oh yes, they did. So they had some savings and minimized cost to the point of actually working the first two years from teh living room of one of the founders. :)
23:52:28 <tikhonjelvis> You can probably write it the most clearly using list comprehensions.
23:52:29 <NothingMan65> I tried using a list comprehension, and got the values I wanted, but they were like nested
23:52:54 <tikhonjelvis> Well, you can just use `concat` to flatten lists. But it's probably neater to rewrite the list comprehension.
23:52:57 <everyonemines> OK. Are there any languages targeting STG?
23:53:01 <kallisti> NothingMan65: you didn't want them to be nested?
23:53:04 <kallisti> everyonemines: dunno
23:53:11 <NothingMan65> Not like that =/
23:53:25 <tikhonjelvis> @type concat
23:53:26 <lambdabot> forall a. [[a]] -> [a]
23:53:31 <NothingMan65> I would like to iterate through all of the i,j,k triplets after that and operator on them
23:53:33 <hpaste_> ski annotated “SimpleFunction” with “`Santa'-based `doubleEveryOther'” at http://hpaste.org/56909#a56911
23:53:41 <kallisti> NothingMan65: so just a 1D list?
23:53:45 <NothingMan65> Aye
23:54:04 <kallisti> > liftM3 (,,) [1..10] [1..10] [1..10]
23:54:05 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
23:54:16 <NothingMan65> ...
23:54:33 <kallisti> hope that helps. :>
23:54:36 <NothingMan65> @type liftM3
23:54:37 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
23:54:39 <ski> insertpseudonym,kallisti : ^ just a strange approach to `doubleEveryOther', which i wanted to try :)
23:55:20 <NothingMan65> Wow... how would I figure that out without asking? kallisti?
23:55:28 <tikhonjelvis> Have you read about Monads?
23:55:39 <NothingMan65> Nope, is it time?!
23:55:42 <NothingMan65> (=
23:55:46 <kallisti> NothingMan65: that's a tricky question. I don't know. it takes time.
23:55:47 <tikhonjelvis> Well, liftM is a monad function.
23:56:00 <ski> > [(x,y,z) | x <- [1 .. 10] , y <- [1 .. 10] , z <- [1 .. 10]]
23:56:01 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
23:56:02 <tikhonjelvis> Once you understand how list works as a monad, it would make more sense.
23:56:05 <startling> NothingMan65: this is what finally made it click for me: http://www.haskell.org/haskellwiki/Monads_as_computation
23:56:34 <tikhonjelvis> > (,,) <$> [1..10] <*> [1..10] <*> [1..10]
23:56:35 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
23:56:46 <NothingMan65> Okay, I'll try to comprehend that, and when it makes sense I'll continue coding.
23:56:47 <kallisti> ski: what on earth is Santa.
23:57:03 <ski> kallisti : defined a few lines after
23:57:10 <kallisti> well, I mean... yes.
23:57:15 <tikhonjelvis> @src liftM3
23:57:16 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
23:57:37 <ski> > replicateM 3 [1 .. 10]
23:57:37 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,1,7],[1,1,8],[1,1,9],[1...
23:57:55 <NothingMan65> wow..
23:58:05 <NothingMan65> I guess it's REALLY time to understand Monads.
23:58:15 <kallisti> unfortunately arrows don't generalize well to triplets...
23:58:18 <tikhonjelvis> It's definitely worth it.
23:58:31 <insertpseudonym> ski: it works? I can't interpret it haha.
23:58:51 <tikhonjelvis> Start by reading about Functors though.
23:59:14 <NothingMan65> Okay
23:59:16 <donri> @where typeclassopedia
23:59:16 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
23:59:21 <NothingMan65> Thanks for the help guys, as always
23:59:22 <donri> in case no one mentioned it yet
23:59:36 <NothingMan65> Good link donri, thanks.
23:59:40 <kallisti> :t join (liftM3 (,,))
23:59:42 <lambdabot> forall a2 a3 (m :: * -> *). (Monad m) => m a2 -> m a3 -> m (a2, a2, a3)
