00:08:06 <rostayob> is there a O(n log n) nub somewhere?
00:08:09 <rostayob> with an Ord constraint?
00:09:02 <MaskRay> utilize `sort'
00:09:42 <rostayob> MaskRay: i know how to implement one, i'm asking if there is a library somewhere with those functions efficiently implemented
00:09:42 <opqdonut> hmm, yeah, zip with indices, sort by values, group&head by values, sort back by indices
00:09:55 <opqdonut> I haven't seen an implementation anywhere
00:09:59 <opqdonut> if you want to retain order, that is
00:10:07 <MaskRay> nub = map head . group . sort
00:10:37 <opqdonut> if order doesn't matter I'd just use Data.Set
00:10:43 <Blkt> good morning everyone
00:10:53 <c_wraith> MaskRay: sort of.  except nub works on infinite lists, doesn't change order, doesn't require an Ord constraint, etc
00:11:16 <rostayob> c_wraith: yeah, I wanted an nub with the Ord constraint
00:11:23 <opqdonut> I'm thinking a nlogn nub wouldn't work on infinite lists anyway
00:11:25 <rostayob> MaskRay: thanks anyway, I didn't think it'd be that short.
00:11:41 <c_wraith> opqdonut: it does, if you scan with a Set
00:12:08 <opqdonut> c_wraith: can you retain order then?
00:12:11 <c_wraith> yes
00:12:13 <ddarius> @hackage data-ordlist
00:12:13 <lambdabot> http://hackage.haskell.org/package/data-ordlist
00:12:18 <opqdonut> oh, right, yes
00:12:25 <c_wraith> you just use a Set as an accumulator
00:12:27 <opqdonut> keep a "seen" set and just traverse the list
00:12:37 <c_wraith> it can be written with scanl, but it's probably clearer to do it more directly
00:12:42 <opqdonut> yeah
00:12:48 <rostayob> ddarius: yes, thanks.
00:13:05 <Sgeo> Thoughts on Pipes?
00:13:19 <Sgeo> (Besides the licensing thing)
00:22:26 <c_wraith> @ty let ordNub = on' S.empty ; on' _ [] = [] ; on' s (x:xs) = if x `S.member` s then on' s xs else x : on' (S.insert x s) xs in ordNub
00:22:27 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:22:34 <c_wraith> I just had to do it
00:32:01 <AfC> Where would be the best place to get in touch with the cabal developers? haskell-cafe, or somewhere more targeted?
01:04:55 <Kanisterschleife> hi, when trying to build a package via runhaskell I get the following error: "Could not find module 'list'. It is a member of the hidden package `haskell98-1.1.0.1'. Perhaps you need to add `haskell98' to the build-depends in your .cabal file."  I don't understand what I should do now.
01:06:11 <ion> Build package via… runhaskell?
01:07:10 <Kanisterschleife> I downloaded the xmobar source, wrote I small testplugin and now wanted to recompile everything via "runhaskell Setup.lhs build"
01:09:08 <ion> If there’s a ….cabal file, you usually build with “cabal build”, but perhaps xmobar has some special quirks requiring you to go through Setup.lhs. In any case, try doing exactly what it suggests.
01:10:25 <Kanisterschleife> ion: My problem is that I do not know what "Add 'haskell98' to the build-depends in .cabal file" means
01:11:37 <ion> Open the cabal file in an editor, find “Build-Depends: …”, add “haskell98” to it. It’s a comma-separated field, make sure you add a comma in the proper place.
01:12:46 <frerich> Is anybody aware of efforts to use EDSL embedded into Haskell instead of XSLT for transforming XML documents into something else? Might be quite worthwhile considering how powerful XSLT 1.0 is (not so much) and how widely spread XSLT 2.0 is (not so much) and how beautiful writing programs in XSLT is (well - not so much).
01:13:58 <Kanisterschleife> ion: There is no .cabal file in my home directory. Only ~/.cabal/config - is this what you mean?
01:14:29 <ion> kanisterschleife: There should be a packagename.cabal in the root directory of the project.
01:14:53 <ion> At least the output of Setup.lhs seems to refer to one.
01:16:51 <Kanisterschleife> ion: Ah, sorry, now I got it. Thought you meant a cabal config file, nothing related to the particular project. I found the file in the projects directory now. Thank you!
01:17:59 <ion> np
01:18:10 <The_Journey> hi, I am trying to use C code in Haskell using FFI, how may I pass a Haskell function to a C source code and call it in C?
01:20:43 <ion> lmgtfy http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
01:23:05 <erus`> What is the most minimal statically typed language?
01:28:45 <antonh> erus`, do you mean most loosely typed language?
01:30:41 <donri> i think ey means minimalist language with static typing
01:30:50 <erus`> no, i mean like a very simple language like haskell but taken to the extreme (no sugar etc)
01:32:03 <drdo> Quite a stretch to call haskell very simple
01:39:04 <raek> erus`: Standard ML feels "pretty simple" to me
01:39:20 <raek> YMMV
01:42:26 <erus`> excluding unboxed types, are types allways just like this *, * -> *, * -> * -> * etc
01:42:51 <ski> @kind Mu
01:42:52 <lambdabot> (* -> *) -> *
01:43:21 <danr> @kind StateT
01:43:22 <lambdabot> * -> (* -> *) -> * -> *
01:43:27 <ski> (btw, you can't express a type `mu' in SML)
01:46:11 <ski> erus` : in row-based systems for variants and/or records (e.g. Trex in Hugs, <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex>), there's also a `row' kind
01:47:21 <ski> ("polymorphic variants" in O'Caml is a row-based system for variant/sum types -- they also use rows for object types)
02:01:06 <erus`> what do i call *
02:01:10 <erus`> Nullary?
02:01:30 <ivanm> multiplication?
02:01:32 <ivanm> ;-)
02:01:36 <erus`> Star?
02:01:37 <ion> asterisk?
02:01:45 <donri> "that thing"
02:01:51 <danr> I'd go for star if you're talking about kinds
02:01:57 <ion> U+002A
02:02:12 <erus`> Maybe has kind 'star to star'
02:03:44 <danr> erus`: indeed
02:03:59 <erus`> data Kind = Application Kind Kind | Star
02:04:04 <erus`> is that ok to model kinds?
02:04:34 <Sgeo> "Eq is given kind
02:04:34 <Sgeo> Eq :: forall a . a -> a -> *
02:04:34 <Sgeo> and both Eq Integer Char and Eq [] Maybe are valid types.
02:04:34 <Sgeo> "
02:04:37 <Sgeo> I get it I think
02:04:40 <Sgeo> Not sure, but I think
02:05:28 <danr> erus`: yes that looks like a good model
02:06:28 <ivanm> erus`: there are some new kinds in GHC extensions
02:06:32 <ivanm> so it doesn't cover everything ;-)
02:06:54 <erus`> ivanm: like # ? or something more complex?
02:07:02 <ivanm> also, is "(* -> *) -> (* -> *)" a valid kind?
02:07:14 <ivanm> don't recall; something to do with the new class context stuff
02:07:27 <erus`> (* -> *) -> (* -> *)   =  (* -> *) -> * -> *    ?
02:07:50 <ivanm> oh, duh ;-)
02:07:51 <mgsloan> yeah, that's a valid kind - monad transformers for example
02:07:52 <ivanm> http://hackage.haskell.org/trac/ghc/wiki/KindSystem
02:08:13 <ivanm> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
02:08:19 <ivanm> erus`: ^^
02:08:49 <Sgeo> Ooh, UHC has partial type signatures
02:13:32 <ski> erus` : no, it should be `data Kind = Star | TypeFunction Kind Kind'
02:14:03 <ski> (but `data Type = ... | Application Type Type')
02:15:24 <erus`> ski: i have Kind.Application and Type.Application
02:15:26 <erus`> :)
02:16:22 <ski> erus` : yes, but it's still not the same thing
02:16:47 <erus`> ah i see
02:17:10 <ski> you could have `Application Kind Kind' *as well* as `TypeFunction Kind Kind', if you were doing yet another level
02:17:43 <erus`> good lord
02:18:01 <ski> `not False' is a value-level application, `Maybe Bool' is a type-level application
02:18:53 <ski> `Bool -> Bool' is function type (the type of a value function), `* -> *' is a function kind (the kind of a type function)
02:19:29 <ski> because we have application on the type level, we can write `Bool -> Bool' as `(->) Bool Bool'
02:19:55 <ski> if you had application on the kind level, you could write `* -> *' as `(->) * *' (so that's two applications in there, then)
02:20:53 <erus`> oh i see
02:21:39 <ski> so for the latter, `TypeFunction Star Star' could then be written as `Kind.Application (Kind.Application Kind.KindFunction Kind.Star) Kind.Star'
02:21:52 <ski> or something like that ..
02:58:29 <erus`> whats the stuff before the => in a type called
02:58:35 <mauke> class constraints
02:58:58 <mgsloan> or just constraints (afterall there's equality now)
03:09:33 <The_Journey> hi, I'm reading on how to get callbacks in FFI, but what is this "wrapper" in the tutorial right here? http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
03:12:01 <ion> It’s a special name resulting in a function that converts a Haskell function into a FunPtr.
03:12:35 <KaneTW> there are no fun pointers
03:13:12 <The_Journey> ion: so I don't have to define "wrap"?
03:13:24 <ion> nope
03:13:50 <The_Journey> ion: what if I want to have callbacks with different signatures? Do I still use "wrap"?
03:15:26 <ion> I haven’t studied wrapper imports any deeper than this. If polymorphic types aren’t allowed in the import you’ll probably need to add a separate wrapper import for each signature.
03:23:00 <erus`> im trying to design a simpler language than haskell but its turning into haskell
03:27:11 <erus`> theres nothing i can reduce :(
03:30:35 <ocharles> you can't improve on absolute beauty :)
03:30:46 <ocharles> except maybe allowing circular imports and a better module system
03:30:47 <ocharles> :P
03:30:52 <ocharles> (without hsboot)
03:30:59 * Sgeo wonders what Strongtalk was like
03:31:07 <Sgeo> Strongtalk was statically typed, right?
03:33:33 <quicksilver> ocharles: I remark that the language does allow circular imports.
03:33:38 <quicksilver> indeed it requires them.
03:33:43 <quicksilver> hsboot is a GHC-only workaround.
03:33:54 <The_Journey> if my C function has the signature void f (int foo, int bar, int* fooBar) and it stores its result in the fooBar pointer, how may I get the result in Haskell using FFI calling the function f from C?
03:34:40 <quicksilver> The_Journey: http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Foreign-Storable.html#v%3Apeek
03:35:01 <The_Journey> quicksilver: thank you
03:35:57 <ocharles> quicksilver: oh, interesting
03:36:46 <quicksilver> ocharles: of course, supporting circular imports and separate compilation is not easy, but that's the compiler-writer's problem :)
03:37:34 <ocharles> oh sure, nothing to say about easy, but it's one thing that really does bug me in day-to-day usage
03:37:45 <ocharles> should probably suck it up and learn how to write hsboot files
03:39:51 <hpaste_> keep_learning pasted “compilation error” at http://hpaste.org/56502
03:40:02 <keep_learning> hello all
03:40:14 <keep_learning> could some one please tell me why i am getting this error.
03:41:59 <keep_learning> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell  says that we can vectorise    Data.Array.Parallel.Prelude.Int,
03:49:20 <keep_learning> Could some one please ?
03:52:16 <mysticc> whats the best way to store a matrix so to provide unit access time for in haskell ..
03:54:11 <dmwit> Use one of the many matrix libraries available on Hackage.
03:54:12 <Saizan> array?
03:54:37 <mysticc> dmwit: Can you suggest one or should I use array or vector ?
03:55:35 <dmwit> keep_learning: Presumably Data.Array.Parallel.Prelude.Int is not the same as GHC.Prim.Int#.
03:56:26 <keep_learning> mysticc, something like Array ( Int , Int )  Int  . See wavefront example http://www.haskell.org/tutorial/arrays.html
03:56:42 <Jafet> "Matrix" generally implies considerably more than "unit access time".
03:56:54 <dmwit> mysticc: hmatrix and repa seem popular these days
03:57:41 <mysticc> Jafet: I just need to store a immutable matrix with unit access time for my problem
03:57:43 <dmwit> keep_learning: I lied. In reality I have no idea why you get that error.
03:57:50 <dmwit> (Didn't read carefully enough.)
03:58:33 <keep_learning> dmwit,  thank you for your time
04:01:44 <cheater_> hello
04:02:00 <cheater_> i have this code (this is an excerpt) giving me indentation errors: http://pastebin.com/mf1dVePz
04:02:04 <mauke> The paste mf1dVePz has been copied to http://hpaste.org/56504
04:02:22 <cheater_> the error is at the two last lines, if i indent them further than the "case" above the code works
04:02:39 <cheater_> however, my coding style dictates that every indent level increases by 2 spaces exactly
04:02:45 <cheater_> how can i pull it off with this code?
04:03:23 <dmwit> cheater_: Start your let block on a new line.
04:04:13 <hpaste_> dmwit annotated “cheater” with “cheater (annotation)” at http://hpaste.org/56504#a56505
04:04:18 <dmwit> cheater_: Like that.
04:06:16 <rribeiro> Hi everyone! I have a probably simple question: The ghc extension for rank-n types supress the existencial type extension, or these are completely different things? I'm asking this, because both uses the "forall keyword"
04:06:48 <Saizan> different things
04:07:28 <rribeiro> Saizan: Ok... So, if I write
04:07:42 <rribeiro> data Silly a = forall b .  S a
04:07:45 <rribeiro> data Silly a = forall b .  S a b
04:08:01 <rribeiro> I 'll need existential types, not rank-n types?
04:08:06 <Saizan> yep
04:08:54 <ion> You can also use GADTs for that. data Silly a where { S :: a -> b -> Silly a } i think.
04:08:55 <Saizan> rank-n types is when you have foo :: (forall a. ..) -> ..
04:12:36 <rribeiro> Saizan: Ok, now I've see the difference
04:16:22 <quicksilver> Saizan: isn't that exactly the form of a constructor for an existential?
04:28:36 <wjt> my test-suite sections tend to end up repeating most of the build-dependencies of the sole executable defined in the same file. is there any way to avoid retyping them?
04:31:38 <donri> wjt: make most of it a library instead?
04:34:16 <wjt> donri: can test suites link libraries defined in the same .cabal file?
04:34:22 <mikeplus64> http://hpaste.org/56508
04:34:37 <donri> wjt: seems to for me
04:34:49 <wjt> donri: okay! thanks :)
04:35:29 <donri> wjt: http://hackage.haskell.org/packages/archive/data-lens-ixset/0.1.4/data-lens-ixset.cabal works for me
04:35:45 <mikeplus64> anyone have improvements/something to yell at me about regarding the code I posted above?
04:36:36 <hpc> intToDouble and intToWord32 are not necessary
04:36:39 <mikeplus64> it takes too long in the program I pasted above for a the main loop to stop, I'm not sure why
04:36:51 <hpc> fromIntegral is already polymorphic
04:37:32 <mikeplus64> hpc: it's only there because typing fromIntegral blah :: Double/Int is annoying
04:37:44 <mikeplus64> uh, Double/Word32
04:37:50 <hpc> don't use unsafePerformIO globals; there are better ways to count the time
04:38:05 <donri> yea, just use acme-now
04:38:12 <mikeplus64> ok
04:38:42 <hpc> (oh god don't use acme-now)
04:38:48 <donri> (no, joke)
04:38:52 <hpc> also, mainLoop can be pulled out of the where clause
04:39:37 <hpc> and should be; i would recommend not using where clauses unless it makes your code significantly shorter; in this case it doesn't
04:39:50 <mikeplus64> alright
04:40:00 <hpc> and that's all i have for now
04:41:30 <mikeplus64> thanks
04:45:52 <quicksilver> mikeplus64: the global IORef is completely un-needed
04:45:58 <quicksilver> just newIORef in the normal way inside main
04:46:37 <Saizan> quicksilver: nope, e.g. Silly :: forall a b. (a -> b -> Silly a)
04:46:49 <mikeplus64> quicksilver: I've changed it to just count the number of times mainLoop is run instead, I think that's probably better than using IORef at all
04:46:55 <mikeplus64> I hope so anyway
04:47:18 <quicksilver> good
04:47:23 <mikeplus64> I think I put it there originally because I thought "ooh I wonder what that does" :)
04:59:13 <erus`> does anyone remember where that document was, representing "haskell type system in haskell" or something
05:01:28 <Delia> hi, I have a question regarding the use of infinite streams, can anybody help me?
05:01:39 <cheater_> dmwit: i don't think this will work for me. let me paste in the whole function.
05:02:48 <hpaste_> cheater annotated “cheater” with “cheater (annotation2)” at http://hpaste.org/56504#a56509
05:03:15 <cheater_> dmwit: i would like everything after the "let" to continue on the same indentation level as the "let"
05:03:35 <cheater_> notice it is not a "let ... in" block, it's a "let statement" that you can have in do blocks
05:04:49 <cheater_> actually you are right i can do "let" on its own line
05:05:02 <cheater_> but is there no way to do something like:
05:05:05 <cheater_> let argStr =
05:05:08 <cheater_>   case arg of
05:05:15 <cheater_>     Nothing -> ...
05:05:37 <cheater_> i think this would be most elegant..
05:15:40 <erus`> how can i use type constraints on a constructor?
05:15:54 <erus`> the wiki says i can
05:16:46 <quicksilver> use GADT syntax
05:23:05 <erus`> ah
05:23:33 <erus`> god this is so complex
05:23:54 <cheater_> be calm, son.
05:26:40 <frerich> One criticism which came to my mind after playing with 'Applicative' for some time now (and I suppose the same holds for 'Monad' and others): the concepts of these classes are so generic that the operators (say, <*>) don't tell much about what's going on. You first have to figure out what the types of the arguments are to tell. Makes reading code a bit hard IMHO, but maybe that's just a matter of getting used to it.
05:31:38 <tomh> anyone using lhs2tex knows how to add some margin to code blocks?
05:39:40 <Saizan> frerich: type classes in general can do that, though i guess (==) doing different things for different types is less surprising
05:40:49 <Saizan> frerich: but (<*>),(<$>) and (=<<) are all variations on the concept of "function application" as much as (==) embodies the concept of "equality"
06:17:10 <barrucadu> Does Haskell support dumping an image of the current state of the interpreter (like in Lisp) to disk, and then resume that image later?
06:17:24 <Botje> not really
06:17:37 <Botje> you might want to look at mobile haskell, which did something /like/ that
06:18:53 <irene-knapp> Haskell isn't interpreted, of course, so?  (well, it can be, as with hugs, but with GHC it isn't)
06:19:42 <geekosaur> ghci is but there isn't even saving of bytecode, much less of sessions
06:19:47 <irene-knapp> right
06:20:04 <geekosaur> (or ghc -e/runhaskell)
06:24:09 <Saizan> it's still not a matter of Haskell the language, it's a matter of available tools
06:24:20 <irene-knapp> true
06:50:13 <mahesh> hello
06:54:26 <erus`> whats sum types? :3
06:58:52 <Saizan> Either
07:10:37 <kamatsu> hey all, i have a problem.
07:11:08 <ocharles> there's a cream for it
07:11:10 <kamatsu> I have a type like T a c, and a function a -> b, and I want to get a T b c
07:11:27 <kamatsu> Functor isn't what I want because that would only work on the second type parameter.
07:12:00 <carpi> I did "import qualified Data.Map as M". And now when I try to do |M.Map 3 "SUP"| I get the error "failed to load interface for M"..
07:12:06 <carpi> could someone please tell me what Im missing?
07:12:21 <kamatsu> uh, M.Map is a type, not a constructor
07:12:24 <quicksilver> Map is not a constructor for Map
07:12:46 <quicksilver> try M.fromList [(3,"SUP")]
07:12:50 <donri> try M.fromList [(3,"SUP")]
07:13:04 <donri> don't listen to quicksilver, ey's wrong!
07:13:22 <quicksilver> wrong people who can type fast rule the world
07:13:29 <donri> :D
07:13:29 <carpi> .. thannks that worked.. i was trying to create values using a type constructor. how silly..
07:13:41 <irene-knapp> eh, if you don't know you don't know
07:13:50 <erus`> @hoogle fromList
07:13:50 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
07:13:50 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
07:13:50 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
07:14:11 <ocharles> kamatsu: and I assume writing a specific fmap-like function is not what you want?
07:14:30 <kamatsu> well, i was just wondering if there was some elegant solution that didn't mean doing that
07:14:39 * ocharles would also like to know if that's possible
07:14:42 <kamatsu> otherwise I will probably just do that
07:14:44 <ocharles> but I don't have an answer :)
07:14:55 <ocharles> and T is outside your control I assume, to swap the type parameters?
07:14:57 <donri> applicative?
07:15:12 <kamatsu> not exactly, but I make use of that type parameter order in other places, I think
07:15:16 <kamatsu> actually, let me double check that
07:15:17 <ocharles> well he needs to make T _ b a functor, rather than T b _
07:19:12 <cmccann> kamatsu, "newtype Flip t b a = Flip (t a b)"
07:19:31 <cmccann> then make "Flip T b" a Functor
07:19:39 <cmccann> wrap and unwrap as appropriate
07:21:01 <dmwit> newtype Flip t le ab = Flip (t ab le)
07:21:08 <dmwit> （╯°□°）╯︵ ┻━┻
07:21:57 <roconnor> dmwit: is that guy legal haskell code?
07:22:01 <opqdonut> :D
07:22:16 <dmwit> hehe
07:22:19 <cmccann> no
07:22:26 <cmccann> the paren-looking-things aren't
07:22:26 <dmwit> > map isSymbol "（╯°□°）╯︵ ┻━┻"
07:22:27 <lambdabot>   [False,True,True,True,True,False,True,False,False,True,True,True]
07:22:49 <dmwit> > map isPunctuation "（╯°□°）╯︵ ┻━┻"
07:22:49 <lambdabot>   [True,False,False,False,False,True,False,True,False,False,False,False]
07:22:56 <dmwit> cmccann: Looks legal to me!
07:23:04 <cmccann> dmwit, try it and see
07:23:10 <dmwit> > let x （╯°□°）╯︵ ┻━┻ y = x + y in 3
07:23:11 <lambdabot>   <no location info>: lexical error at character '\65288'
07:23:13 <dmwit> =(
07:23:15 <erus`> let  a °□° b = a `div` 0 in 1 °□° 2
07:23:23 <erus`> > let  a °□° b = a `div` 0 in 1 °□° 2
07:23:23 <lambdabot>   *Exception: divide by zero
07:23:32 <dmwit> So... is GHC just wrong here?
07:23:34 <cmccann> dmwit, GHC doesn't like certain kinds of punctuation symbols
07:23:44 <dmwit> The spec clearly says that symbols and punctuations should be valid.
07:23:50 <cmccann> mostly stuff categorized as brackets, quotes, &c.
07:24:07 <cmccann> no, my reading of the Haskell Report is that GHC is wrong here
07:24:14 <cmccann> but I'm not sure
07:24:59 <dmwit> Yeah, that's my reading, too.
07:25:17 <dmwit> I wonder if I care enough to open a ticket.
07:28:18 <cmccann> dmwit, most of the symbols in question aren't ones you'd often use as infix operators
07:28:28 * dmwit nods agreement
07:28:38 <kqr> ion, right
07:28:57 <dmwit> This feels like solid ground for a well-written joke ticket, though. =)
07:30:02 <geekosaur> somehow I am reminded of the don't-parse-html-with-regexes thing at stackoverflow...
07:30:28 <cmccann> geekosaur, no, I think all that unholy unicode mess would work fine here
07:45:31 <beginner> Hai I am on chapter 2 on "Learn you a haskell". I am having problem understanding type classes
07:46:35 <beginner> Is there somewhere else I can read that explains it clearly (searched the net, but somehow couldn't find one that is less confusing)
07:46:48 * sm notes that virthualenv/hsenv has solved cabal install pains at a stroke
07:47:07 <beginner> I mean it says the definition of class is not the same as in oop languages
07:47:08 <donri> beginner: perhaps first explain what about them confuse you
07:47:16 <benj_> beginner, what is your previous programming experience?
07:47:24 <beginner> but it doesn't even explain the meaning of class and instance in Haskell context
07:47:26 <mysticc> I have a list of n*n size and I want to break into a n lists of n size each .. is it possible by list comprehension
07:47:35 <beginner> I have done some C and python
07:47:48 <benj_> most probably the problem is trying to find an analogy with what you already know which doesn't really hold true (e.g. describing them as interfaces will likely confuse, say, a Java programmer)
07:48:02 <donri> beginner: "class" is similar to an interface or abstract class in OOP; "instance" is similar to a class implementing that interface / a concrete class
07:48:12 <jaspervdj> mysticc: I wouldn't do that using a list comprehension
07:48:26 <mysticc> jaspervdj: Then the easiest way  ?
07:49:08 * Saizan puts donri and benj_ in a cage
07:49:21 <benj_> beginner, a typeclass describes a particular behaviour, and by making an instance of a typeclass, you define how a particular type exhibits that behaviour
07:49:24 <mysticc> jaspervdj: I have done it using a recursive function ..are there any builtin functions which will make it easy
07:50:48 <beginner> ok
07:50:59 <jaspervdj> mysticc: I'd also write a recursive function for that goal, for this case I don't think it's a bad approach
07:51:16 <jaspervdj> There might be a clever trick, but I'm not sure
07:51:34 <mysticc> jaspervdj: Yeah .. I was looking for the clever trick ;)
07:53:31 <cmccann> mysticc, the clever tricks and useful generic functions for that kind of problem are somewhat lacking in the standard libraries
07:54:11 <cmccann> so you can write your own clever generic combinator and then use it, if you want
07:57:09 <^thief^> Does anyone have 5 mins for a quick code review of an assignment I'm working on?
07:57:38 <cmccann> ^thief^, I can take a quick look
07:58:18 <^thief^> cmccann: thanks! are you ok with receiving a zip file?
07:58:25 <Duffman-> Hi guys, I'm looking at this definition of the reader monad here http://monads.haskell.cz/html/readermonad.html#definition Shouldn't definition of >>= be:     (Reader r) >>= f = Reader $ \e -> runReader (f (r e)) e
07:58:31 <Duffman-> instead of the definition displayed on the website?
07:58:44 <cmccann> ^thief^, uploading it somewhere would be easier, how many files is it?
08:00:03 <cmccann> Duffman-, your version looks right to me, yeah
08:00:31 <^thief^> cmccann: well theres quite a few placeholder files/modules with nothing in them - the structure is kind of what I'm concerned about. There's 16 files, about 5 of them have more than 5 lines of code
08:00:54 <cmccann> ^thief^, ok, that's fine I guess
08:01:32 <Duffman-> Thanks cmccann. One of my teachers told me so but I just wanted to double check I'm understanding correctly what he said.:)
08:01:37 <cmccann> ^thief^, email to cam@uptoisomorphism.net I guess
08:02:35 <cmccann> Duffman-, it's a pretty minor issue since newtypes are just a wrapper that only exists at compile-time
08:06:30 <^thief^> cmccann: thats really great thanks - a 5 minute glance over it just to see if I'm on the right track would be a real help. email sent.
08:09:07 <cmccann> ^thief^, what sort of feedback are you looking for--code style, idioms, algorithm, overall design...?
08:10:06 <KorriX> Hello. I am trying to make simple erlang style multiprocessed application
08:10:15 <KorriX> is there any simple method
08:10:30 <KorriX> ?
08:10:54 <^thief^> cmccann: I put a little note in the email: basically 2 questions: 1: am i stuck in an imperative style (it feels like I shouldn't be stuck within a monad so much) & 2: How does the structure of the program look to you (e.g. the way I've structured the command module & submodules)
08:11:03 <angstrom> I'm trying to represent a EBNF grammar as a set of mutually recursive data-types, but the way I'd like to do it would require multiple declarations of type-constructors. introducing "dummy constructors" seems rather meh as well. is there a common way to approach this?
08:11:13 <cmccann> ^thief^, yeah, just noticed that, heh
08:11:16 <^thief^> :)
08:12:08 * cmccann isn't sure he cares for this "indent everything" business
08:12:59 <merijn> KorriX: forkIO combined with Data.Concurrent.Chan?
08:13:42 <^thief^> cmccann: heh, was that directed at me?
08:13:44 <KorriX> also, with solution is `better` - threads or lightweight processes
08:13:45 <KorriX> ?
08:13:45 <merijn> KorriX: The chan gives you a communication channel and forkIO spawns a new (lightweight) thread
08:14:05 <cmccann> ^thief^, yeah, I don't usually see people indenting under "module"
08:14:07 <merijn> KorriX: Haskell's threads are lightweight, similar to Erlang's processes
08:14:32 <^thief^> cmccann: ok - I guess its out of the habit of indenting classes in OOP
08:14:44 <merijn> KorriX: In that you can probably have tens of thousands of threads, hundreds of thousands if you're threads are blocking on IO
08:15:02 <merijn> ^thief^: That drove me stark raving mad in Java programs >.>
08:15:21 <cmccann> ^thief^, but I also use a very different indentation style overall, so you don't have to listen to me here if you don't want to
08:15:45 <nand`> how do haskell's threads compare to goroutines?
08:15:57 <^thief^> cmccann: well I'd like to stick to the community norms where possible
08:16:20 <merijn> nand`: In a sense of how lightweight they are?
08:16:35 <merijn> nand`: I'd say around the same
08:16:39 <^thief^> merijn: yea I guess when you've only got one class per file, but e.g. for private classes it makes sense
08:16:56 <nand`> in a sense of: how fast they are to switch, how many you can reasonably have blocking, and how well they play together when interacting between threads
08:17:29 <mysticc> I have a function which takes a list of distinct integers of length n*n where n is any integer .. Can anyone help how to generate the testcases using quickcheck ?
08:17:31 <merijn> nand`: GHC uses kqueue/epoll/select under the hood for threads blocking on IO
08:18:11 <cmccann> ^thief^, also, are you allowed to use non-standard libraries?
08:18:35 <^thief^> cmccann: anything in the prelude thats not an explicit CSV parser as far as I know
08:19:03 <cmccann> ^thief^, because a "lens" package would make State.hs a lot simpler
08:20:04 <^thief^> cmccann: ok I'll read up on that and also find out if I can use something like it
08:20:13 <KorriX> had anybody problem with compiling threadscope (with treeViewTooltipColumn) ?
08:20:40 <cmccann> ^thief^, it's a nicer, generalized replacement for all those get/set/&c. functions
08:20:51 <cmccann> I usually use fclabels, but there are others
08:21:47 <^thief^> cmccann: reading up on it now, seems useful
08:22:59 * quicksilver recommends data-lens
08:23:26 * cmccann mostly uses fclabels out of habit, so don't take that as a disrecommendation of others
08:23:33 <^thief^> reading a good comparison of the options on stackoverflow
08:23:51 <hpaste_> angstrom pasted “how to get rid of "dummy constructors"?” at http://hpaste.org/56510
08:24:24 <cmccann> ^thief^, a lot of Parser.hs could be tidied up using Applicative notation instead of do blocks, I think
08:24:29 <donri> i too recommend data-lens
08:24:37 <donri> and data-lens-fd if you're doing state
08:24:43 <hpaste_> “Ertugrul Söylemez” pasted “Benchmark for thread switching performance” at http://hpaste.org/56511
08:25:13 <^thief^> donri: thanks, I am doing state so I guess data-lens-fd sounds like the one for me
08:25:25 <mm_freak> nand`: see the paste…  passing 100 messages through 100000 MVars, where for each sequential pair of MVars there is a thread to pass the message to the next thread
08:25:32 <donri> and data-lens-template if you have data records
08:25:39 <mm_freak> nand`: this involves a lot of switching and takes 2 seconds on my machine
08:26:16 <^thief^> cmccann: do you mean the >> and >>= notation rather than do notation?
08:26:22 <donri> ^thief^: are you doing a csv parser?
08:26:28 <^thief^> donri: yes
08:26:32 <cmccann> ^thief^, no, I mean Control.Applicative
08:26:37 <donri> ^thief^: not having seen the code, you might want to consider applicative
08:26:58 <mysticc> hello .. any help here ..how to write a generator to generate a list of distinct integers ?
08:27:15 <^thief^> donri, cmccann: ok reading about it on hackage now, cheers
08:27:17 <merijn> mysticc: What do you mean by distinct integers?
08:27:22 <merijn> > [1..] :: Integer
08:27:23 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
08:27:23 <lambdabot>         against inf...
08:27:26 <merijn> > [1..] :: [Integer]
08:27:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:27:35 <donri> stuff like do { x <- combinator; otherCombinator; return (func x) } becomes: func <$> combinator <* otherCombinator -- with applicative
08:27:50 <donri> so it's like super cute
08:28:25 <mysticc> merijn: I mean I want a generator to generate a random list of integers with no integer occuring twice .. I want to use this in quickcheck
08:28:59 <mm_freak> nand`: i don't think go can beat that, but it doesn't involve waiting for I/O handles, so it's just raw switching performance
08:29:23 <sm> at last: the sound of Haskell. awesome :) http://joaopizani.hopto.org/en/2012/01/haskell-synth/
08:29:48 <sm> check out the mp3s at the end
08:30:01 <^thief^> donri: looks nice, little tight on time though so may stick with "do" for the moment and tidy it up with Applicative if I get a chance to learn it towards the end
08:30:07 <cmccann> ^thief^, here's an example
08:30:10 <hpaste_> “C. McCann” pasted “Applicative conversion” at http://hpaste.org/56512
08:30:13 <donri> certainly
08:30:36 <donri> monad/do is fine; applicative is just prettier / closer to function application
08:31:46 <^thief^> cmccann: your example shows it quite nicely actually, thanks I guess I'll try it
08:33:30 <cmccann> ^thief^, I think the two count* functions in Report.hs would be better written as folds producing the final accumulator, then printing the result of that where they're called
08:33:50 <cmccann> rather than having both just produce a monadic action
08:34:31 <cmccann> also, that output function looks suspiciously like it's 90% reinventing mapM_
08:34:43 <nand`> mm_freak: interesting, I'll give it a try
08:36:10 <^thief^> cmccann: ok that makes sense, I'm making notes here - very helpful
08:36:19 <cmccann> ^thief^, I should probably mention that doesFileExist isn't really the best idea
08:36:33 <cmccann> that function would be better named something like didFileExistLastTimeIChecked
08:36:42 <^thief^> cmccann: yea I couldn't get catch to work for me so I took the easy way out
08:37:05 <cmccann> just noting
08:37:22 <^thief^> cmccann: so a catch would be a better option there right?
08:37:58 <cmccann> yeah, I think opening the file and catching the exception if it doesn't exist is the best way
08:39:03 <donri> or you have a race condition
08:42:30 <cmccann> ^thief^, btw, you might find this interesting for comparison: https://gist.github.com/1494865/a04ad443c1ef3bc4714196327901c1da2d27f94c
08:42:41 <cmccann> something I wrote in a few hours a couple weeks ago
08:43:45 <cmccann> it's not the best code in the world and I was trying to avoid using any "advanced" stuff
08:45:03 <^thief^> cmccann: it looks like it could definitely be useful for me to get an idea of the general approach to handling commands - some similar stuff going on
08:45:21 <cmccann> ^thief^, yeah, that's what I was thinking
08:47:33 <cmccann> ^thief^, it also shows you what my style for indentation &c. looks like, which isn't 100% standard for the entire Haskell community or anything, but isn't too far from the norm either
08:49:02 <funktronic> needs more comments
08:49:26 <cmccann> funktronic, what, that gist I linked? yeah.
08:49:48 <donri> also http://snapframework.com/docs/style-guide
08:50:22 <^thief^> cmccann: yea I'm noticing some differences compared to my indentation/newline style
08:50:30 <^thief^> donri: thanks
08:53:27 <cmccann> ^thief^, anyway, I'm not sure what the benefit of the "Command" type is over just "AppState ()", but that's not a big deal
08:55:05 <cmccann> and there are some places where it might be better to separate out State monad stuff, IO, and pure functions a bit more
08:55:17 <cmccann> "set" in Command.File for example
08:55:34 <^thief^> cmccann: yes I was concerned about that - I'm quite sure I'll lose marks for that as it stands
08:56:00 <^thief^> cmccann: I'm concerned that the State/IO stuff is spread over too much of the code
08:56:47 <cmccann> ^thief^, that "set" function could be split into the pure component ("let recs' = ...", then the pure component of setRecords), and the State part (modifying the state using the pure version of setRecords)
08:57:03 <cmccann> stuff like that
08:57:59 <cmccann> for comparison, note how most of the logic in the code I wrote is pure, operating on the game state record directly
08:58:46 <cmccann> even stuff like handleCmd is mostly pure, and could be converted to use input/output streams of some sort
08:59:22 <cmccann> if you compare the other revision of that gist you can see how little code I needed to change to remove IO entirely and run the game off a command script instead
08:59:24 <Duffman-> :t isLower
08:59:25 <lambdabot> Char -> Bool
09:00:15 <cmccann> ^thief^, anyway, that's probably all I can say from what you've got so far
09:00:37 <^thief^> cmccann: thanks so much - you've been really very helpful
09:00:39 <cmccann> on the whole not too bad, I think
09:00:57 <^thief^> great, I'm glad to hear that - was a bit worried about it
09:01:14 <nh2> OK, how do I send a patch for base?
09:01:46 <hpaste_> mmos1127 pasted “time” at http://hpaste.org/56514
09:01:51 <koral> hi, I would like to use some of XMonad.Actions.Search's functions in another project; does this make sense to import it or should I better replicate it ?
09:01:54 <donri> nh2: http://hackage.haskell.org/trac/ghc/newticket?component=libraries/base perhaps?
09:02:32 <^thief^> cmccann: I'm going to read up on Applicative, Data-lens and study the gists you sent over. Thanks again!
09:02:54 <nh2> uh that thing again: still no HTTPS :(
09:03:05 <mmos1127> http://hpaste.org/56514
09:03:25 <cmccann> ^thief^, no problem, and feel free to ask if you have any questions about those
09:03:26 <mmos1127> ^^ this is an attempt to use threadDelay from Control.Concurrent but the program runs as if there is no delay
09:03:51 <mmos1127> wait is the delay in microseconds?
09:04:05 <cmccann> ^thief^, I doubt anyone else in here will take responsibility for my gist, but on the others you can ask the channel as a whole, heh
09:04:37 <mmos1127> okay got it, microseconds
09:04:45 <donri> :)
09:05:14 <^thief^> cmccann: heh, thanks - I think I can make sense of the gists - just having some example code in a related problem can be more useful than pages of explanations
09:05:32 <KorriX> i written simple code: http://hpaste.org/56515
09:05:43 <KorriX> and ghc say: concurent: thread blocked indefinitely in an MVar operation
09:05:53 <KorriX> inside of ghci works fine
09:06:20 <KorriX> do you have any ideas ?
09:06:33 <cmccann> ^thief^, again, keep in mind that the gist doesn't use some stuff that would be helpful (like lenses, or monad transformers) because I wanted to illustrate doing things in the simplest way possible
09:07:24 <^thief^> cmccann: ok I'll bear that in mind
09:09:30 <nh2> comon people this is idiotic: http://hackage.haskell.org/trac/ghc/register?failed=
09:09:36 <nh2> who shall read that captcha?
09:11:54 <Sgeo> Korrix... dangit
09:12:38 <nh2> donri: thanks
09:15:18 <koral> gwern: hi, I see you're the maintainer of Xmonad.Actions.Search; I would like to use some of its content outside of Xmonad without having to import it (I don't want my project to have the whole xmonad-contrib as a dependency). Do you think the Xmonad.Actions.Search module could be externalized in a dedicated package ?
09:15:41 <gwern> koral: why not just depend on surfraw then
09:16:56 <koral> there is no surfraw package, unless I'm mistaken
09:17:05 <koral> I mean, written in Haskell
09:17:21 <gwern> koral: well, you just said haskell was unacceptable
09:19:14 <koral> gwern: no I didn't, I just want to use your module's Haskell functions in my project (at least some of them)
09:19:48 <gwern> koral: splitting out search as an XMC dep is a non-starter, but there's nothing I can do to stop you from copying what you need
09:21:23 <koral> yeah well basically I would like a dedicated package that would only take a searchEngine as input and return the appropriate URL to use for queries
09:21:56 <gwern> koral: that's a pretty narrow use, why do you want that?
09:22:49 <koral> gwern: you never know when something is of use to anyone :) e.g. I'm working on a browser written in Haskell
09:23:53 <koral> I would like to offer this surfraw-like feature inside the browser rather than using xmonad
09:25:56 <donri> http://www.opensearch.org/Home
09:28:18 <koral> gwern: so do you suggest I extract the aforementioned functions from XMC to make an independent package ?
09:28:47 <gwern> koral: you refuse to depend on xmc, xmc doesn't want to depend on yet another dependency, so you tell me
09:29:27 <koral> I take that as a yes :)
09:30:49 <koral> gwern: I have reasons not to want xmc as dependency since I would use only a tiny part of it
09:34:04 <conal> Is there a way to set up a sort of secondary Hackage (in addition to Hackage), e.g., for use within a company?
09:34:53 <donri> @hackage yackage
09:34:53 <lambdabot> http://hackage.haskell.org/package/yackage
09:35:50 <conal> donri: sweet. thx!
09:36:45 <erus`> do classes have kinds
09:37:01 <erus`> do classes every have more than 1 type arg. or any?
09:37:11 <donri> :k Monad
09:37:12 <lambdabot>     Class `Monad' used as a type
09:37:12 <lambdabot>     In the type `Monad'
09:37:41 <donri> :k Monad m => m
09:37:42 <lambdabot>     `m' is not applied to enough type arguments
09:37:42 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
09:37:42 <lambdabot>     In the type `(Monad m) => m'
09:38:00 <cmccann> that's one way to get an answer
09:38:12 <conal> erus`: see "multi-parameter type classes"
09:39:22 <conal> erus`: the term "type class" is unfortunate, considering this generalization. "type relations" might have been a better fit, though it'd cause confusion with another notion having that name (closely related to parametricity, iirc).
09:40:06 <conal> (in that a set or class is a unary relation.)
09:40:53 <donri> how about "type families"! oh wait
09:42:33 <erus`> Im gonna have a go at implementing algebraic types without classes first
09:42:40 <erus`> this stuff gets insane quickly
09:43:38 <cheater_> is dovetailing a type of fusion?
09:46:47 <erus`> :k Just
09:46:48 <lambdabot> Not in scope: type constructor or class `Just'
09:47:02 <erus`> :k Maybe
09:47:03 <lambdabot> * -> *
09:47:05 <erus`> :t Just
09:47:06 <lambdabot> forall a. a -> Maybe a
10:17:22 * esap writes "1 `div` (1 - z - z*z)" to represent the fibonacci sequence.
10:19:19 * esap also writes "1 `div` (1 - z - z2*z)" for the pascal triangle...
10:23:56 <ski> hiya esap
10:24:02 <esap> ski: hi
10:24:28 <ski> whence "1 `div` (1 - z - z*z)","1 `div` (1 - z - z2*z)" ?
10:25:16 <esap> I just implemented Num and Integral instances for Streams
10:25:23 <esap> except for (==)....
10:28:14 <esap> the tricky part for streams is (*), have to use cauchy product.
10:28:17 <roconnor> hopefully we will remove the Eq precondition on Num next GHC :P
10:31:28 <esap> yea, I think that's very useful. My implementation of the product involves the pairing function, which is cool
10:38:52 <kofron> hi all, i have a beginner question about instance declarations
10:41:58 <ski> kofron : just ask :)
10:42:06 <kofron> is there a way to pattern match a data constructor?  for example, if i have (Num a) => data X a = A a | B a
10:42:44 <ski> that doesn't look like valid syntax -- maybe you just meant `data X a = A a | B a' ?
10:42:54 <kofron> yes, sorry
10:43:02 <ski> yes, you can pattern-match on the data constructors `A' and `B'
10:43:11 <ski>   foo (A a0) = ..a0..
10:43:16 <ski>   foo (B a1) = ..a1..
10:43:27 <ski> will infer something like
10:43:33 <kofron> right.  i'd like to pattern match on A *or* B, to avoid something like this:
10:43:35 <ski>   foo :: X a -> ...
10:43:54 <kofron> instance Num X a where (+) A a1 A a2 = A a1+a2
10:44:03 <ski> oh
10:44:04 <kofron> (+) B b1 B b2 = B b1+b2
10:44:09 <ski> you can write either
10:44:20 <ski>   (+) (B b1) (B b2) = B (b1 + b2)
10:44:21 <ski> or
10:44:27 <ski>   B b1 + B b2 = B (b1 + b2)
10:44:28 <mmos1127> I want to use PortMidi to send real-time midi events to a software synthesizer. I need to time them pretty precisely (within a millisecond). I was looking at threadDelay for this purpose.. putting delays between sending midi events.. but it says the delay is not guaranteed.
10:44:48 <mmos1127> Is there a way to implement a delay that is quite precise?
10:45:06 <ski> kofron : the problem with `(+) B b1 B b2' is that it is parsed in the same way as `((((+) B) b1) B) b2', which is not what you wanted here
10:45:33 <kofron> right, i guess i'm not being very clear.  basically i want the + operation to be defined over any of the data constructors of the X type, provided the data constructor is the same
10:45:37 <ski> kofron : similarly, `B b1+b2' would be parsed as `(B b1) + b2', which is not what you want, so use `B (b1 + b2)' instead there
10:46:17 <ski> kofron : since `X a' has two cases, and you have two arguments matching here, you will get four cases in total
10:46:53 <kofron> exactly, that's what i'm trying to avoid :)
10:47:12 <ski> kofron : what should happen in the case where the two arguments to `(+)' have different data constructors ?
10:47:45 <kofron> that's an error.  maybe it'll be more obvious if i say exactly what i'm trying to do
10:47:53 <ski> that might help :)
10:47:59 <kofron> basically i'm looking at implementing a simple dimensional analysis scheme for my thesis
10:48:06 <kofron> I have quantities which carry units
10:48:15 <kofron> and adding a mass to a velocity, of course, makes no sense
10:48:25 <kofron> mass + mass makes sense, and velocity + velocity make sense
10:49:14 <kofron> the reason i'm looking for the shortcut is that i have these implemented as data constructors of a type.  might not be the right way to do it but at my level of knowledge it makes some sense
10:49:40 <geekosaur> data constructors don't show up at the type level.  you want type witnesses
10:49:46 <ClaudiusMaximus> mmos1127: at a rough glance at portmidi on hackage, events are timestamped, so you can probably send events marked with a future time - naturally that adds latency but might reduce jitter
10:50:30 <ChristianS> kofron: you could use newtype
10:51:06 <kofron> geekosaur: that looks very much like what i'm after
10:51:22 <kofron> i'll check out newtype as well
10:51:26 <ski> kofron : one variant would be to simply use different types, possibly introducing a type class for expressing operations which can act on both masses and velocities
10:51:33 <angstrom> http://hpaste.org/56510 <- any suggestions on how to avoid having these "dummy" constructors?
10:51:51 <ski> kofron : another would be to add some kind of type index / phantom type / use a GADT or a type family
10:52:56 <kofron> i'll check those out.  sounds like plenty to chew on for the moment, thanks ski et al
10:53:01 <barrucadu> I've been stuck trying to fix a type error for over an hour now, could someone possibly have a look at my code? http://misc.barrucadu.co.uk/Utils.hs
10:53:08 <barrucadu> The error is in a comment at the bottom
10:53:33 <ski> angstrom : maybe not make your data types exactly correspond to the BNF categories / non-terminals
10:53:48 <angstrom> ski: that's what I was trying to do, no?
10:54:21 <ski> angstrom : as a first step towards that, e.g. replace `| Expression_ECA Expression Comma AssignmentExpression' with `| Expression_ECA Expression AssignmentExpression', then you can remove `data Comma      = Comma             deriving (Show)'
10:54:31 <angstrom> ah, sorry. skipped the 'not'. hm
10:54:59 <ski> hm, so what are you trying to do ?
10:55:24 <angstrom> I'm basically trying to model a given EBNF grammar with data-types
10:55:53 <geekosaur> barrucadu, your problem is that "vs <- [x | ...]" tells ghc that you're using the list monad.  perhaps you want "let vs = [ x | ... ]" instead
10:56:17 <geekosaur> since "[ x | ... ]" generates a list, not an IO expression
10:56:29 <angstrom> ski: what I'd like to have is data-types like `data A = B Int | B Char | B String'
10:56:45 <waratuman> Sorry for a noob question, but how do I create a data type that is a float ranging from -(pi/2) to (pi/2)?
10:56:55 <ski> angstrom : i thought you possibly were trying to parse according to an (E)BNF, getting some kind of nice parse tree that doesn't have to correspond exactly to the (E)BNF in shape
10:57:11 <geekosaur> waratuman, very painfully.  haskell doesn't support dependent types directly
10:57:35 <angstrom> ski: well. I'd like to have 2 passes. one to construct the parse-tree according to the EBNF, and one to construct a nice syntax-tree from it.
10:57:38 <barrucadu> geekosaur: Same error, unfortunately
10:58:03 <waratuman> geekosaur, should I just not do it and assume the numbers are in the correct range?
10:58:17 <ski> any particular reason for not merging those two passes into one ?
10:58:28 <angstrom> ski: (primarily for learning reasons)
10:58:46 <angstrom> but I could merge them, if it turns out to be too cumbersome
10:59:08 <ski> angstrom : hm, did you mean `data A = B Int | B Char | C String' ?, yes/no ?
10:59:46 <ski> um
10:59:57 <ski> `data ABC = A Int | B Char | B String' i meant ..
11:00:06 <angstrom> no
11:00:23 <ski> i suspect you want either (or both) of refinement types and subtyping
11:01:16 <ski> `B Int | B Char | B String' would be problematic in that if you match on `B x', you don't know what type `x' would have
11:01:37 <ski> in your actual code, something a bit like that could make more sense
11:01:48 <ski> i.e., in O'Haskell
11:02:04 <angstrom> I see
11:02:20 <ski>   data Expression > AssignmentExpression
11:02:20 <ski>                   = Expression_ECA Expression AssignmentExpression
11:02:32 <ski> this would remove the `Expression_A' constructor
11:03:14 <ski> the above says that `Expression' is a supertype of `AssignmentExpression', so every value in the latter type is automatically a value in the former type as well, and in addition, `Expression' also has the `Expression_ECA' constructor
11:03:33 <angstrom> but it's an extension, right?
11:04:14 <ski> i think the language Timber is the currently(?) active thing in the vein of O'Haskell
11:04:19 <ski> @where Timber
11:04:19 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
11:04:23 <ski> @where O'Haskell
11:04:23 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/
11:04:23 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
11:04:47 <ski> angstrom : it's an extension that is not supported by any of the main Haskell implementations
11:05:06 <geekosaur> barrucadu, yes, it's much worse than that actually, you have the first leg of minimalPath' returning a bare empty list and the second wants to be monadic, since the first declared it as a list type it's using the list monad.  You need to rethink that
11:06:27 <geekosaur> barrucadu, changing the first leg to "return []" also isn't sufficient because you try to use minimalPath' in the last expression (return $ [e] ++ (minimalPath' ...) and that will not work if minimalPath' is in IO
11:07:41 <ski> angstrom : anyway, in short : you can't do it (eliding the "unnecessary" inclusion constructors) in Haskell, not even with commonly implemented extensions -- what you want (i think) is either refinement types or subtyping
11:08:38 <hpaste_> geekosaur pasted “for barrucadu, try this” at http://hpaste.org/56516
11:09:30 <ski> angstrom : btw, in case you don't know about it, the BNF Converter at <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/> might be interesting
11:10:05 <mmos1127> I want to use PortMidi to send real-time midi events to a software synthesizer. I need to time them pretty precisely (within a millisecond). I was looking at threadDelay for this purpose.. putting delays between sending midi events.. but it says the delay is not guaranteed.
11:10:07 <mmos1127> Is there a way to implement a delay that is quite precise?
11:10:19 <ski> @where BNFC
11:10:19 <lambdabot> http://www.cs.chalmers.se/~markus/BNFC/
11:10:28 <mmos1127> Or is threadDelay precise in practice in most cases?
11:10:44 <TashBear> what did just happened?
11:11:06 <ski> TashBear : netsplit
11:11:21 <TashBear> ski: what's that
11:11:26 <TashBear> show me the light
11:11:53 <ski> TashBear : it's when the servers on the irc network for some reason get disconnected from each other, in at least two disjoint groups that is
11:12:31 <ski> for every person on a channel in one of the groups, it appears that everyone on the channel in the other groups are quitting at the same time
11:12:55 <_mpu> ski: I like to bo in the group that stays in the channel...
11:12:56 <ski> and then (after the netsplit ends) all those appear to be joining again
11:13:04 <TashBear> but nobody is actually reconecting?
11:13:04 <nand`> TashBear: https://en.wikipedia.org/wiki/Netsplit
11:13:18 <parcs`> mmos1127: in my tests threadDelay has a resolution of 1/800 of a second. and threadDelay doesn't have much of a guarantee wrt the promptness of resumption
11:13:26 <angstrom> ski: thanks for your help
11:13:28 <geekosaur> TashBear, in my case the server I was on was one tht actually crashed, and my client had to reconnect
11:13:30 <barrucadu> geekosaur: Thanks, I have got it working now :)
11:13:38 <ski> TashBear : one part of the network is reconnecting with another part -- no individual users are (necessarily) reconnecting
11:13:52 <ski> angstrom : yw
11:14:02 <geekosaur> but there were likely other people connected through (instead of to) that server, they didn't actually have to reconnect, just wait for the server to do so
11:14:11 <parcs`> mmos1127: one way would be to forego delays and write a busy loop
11:14:40 <mmos1127> parcs': I should mention I'm on Windows xp in case that matters. can you give me a clue how to write a busy loop? do you loop and keep checking the time?
11:14:40 <ski> @where+ BNFC BNF Converter, <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
11:14:40 <lambdabot> I will remember.
11:14:51 <ski> (the old link didn't work)
11:15:01 <mmos1127> parcs`: I guess it's a backquote
11:15:08 <parcs`> bbee: yeah
11:15:44 <parcs`> mmos1127*
11:16:26 <bbee> quite the, fat finger syndrome. you even skipped n
11:16:52 <parcs`> i'm a dvorak fanboy :P
11:17:16 <mmos1127> parcs`: given laziness, does writing a busy loop need a trick to make it execute continuously and immediately?
11:17:37 <parcs`> not in this case
11:18:06 <parcs`> you can write it idiomatically and it will work as expected
11:19:42 <mmos1127> parcs`: so how does one write a busy loop? do you 'sequence' a long list of IO computations that check the time and raise an exception when the time is right?
11:20:08 <parcs`> no
11:21:06 <TashBear> parcs`: as a dvorak user what editor do you use?
11:21:10 <parcs`> something like: loop t = do { t' <- getCurrentTime; when (diffUTCTime t' t > 1000) doStuff; loop t' }
11:21:35 <TashBear> parcs`: aeuaoeuaoeua lol
11:21:49 <parcs`> TashBear: vim, it works surprisingly well on dvorak. i even like it better than vim on qwerty
11:22:21 <TashBear> parcs`: yeah at least we still have the jk next to each other
11:22:28 <mmos1127> parcs`: do you know what precision 'getCurrentTime' has?
11:22:32 <TashBear> plus the spacebar
11:22:55 <parcs`> mmos1127: microsecond
11:23:26 <jmcarthur> well, that's the precision it allows you to specify, but not necessarily the one it uses
11:23:40 <jdavis> I have a complex type that holds an MVar holding a ForeignPtr. What should the type look like? newMVar returns IO (MVar a) and newForeignPtr_ returns IO (ForeignPtr a), so does that mean I need "IO" twice in the type signature?
11:23:42 <jmcarthur> *the precision is reports
11:23:44 <parcs`> it's that precise on linux at least
11:23:44 <jmcarthur> *it
11:24:05 <jmcarthur> i doubt it's actually good to the exact microsecond
11:24:19 <jmcarthur> err
11:24:22 <jmcarthur> maybe it is
11:24:39 <mmos1127> parcs`: thanks!
11:24:58 <parcs`> welcome
11:25:15 <Sgeo> jdavis, any IO (IO a) can be converted into an IO a (although you don't always want to do this)
11:25:21 <Sgeo> :t join
11:25:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:25:36 <jdavis> Sgeo: interesting.
11:26:05 <Sgeo> An IO (IO a) is an action that, when run, gives another action that, when run, will give an a
11:26:21 <Sgeo> join for IO will basically run the action, then run the action obtained
11:26:35 <Sgeo> @src join
11:26:35 <lambdabot> join x =  x >>= id
11:26:39 <jdavis> Sgeo: OK, I think what I want is to combine them with something like join, but I'm struggling a little to understand the implications.
11:26:53 <Sgeo> @do \x -> x >>= id
11:26:54 <lambdabot> \ x -> do { a <- x; id a}
11:27:04 <Sgeo> ^^ a bit lulzy
11:27:57 <jdavis> Well, the definition is simple enough ;)
11:28:16 <Sgeo> It's just the way undo wrote out "id a" that amuses me
11:29:16 <Sgeo> newForeignPtr_ gives an action that lets you obtain a ForeignPtr a when run, and newMVar gives you an action that lets you get an MVar a when run
11:29:39 <jdavis> Sgeo, Oh, hah. I missed your underlining do to the formatting in my IRC client.
11:30:54 <parcs`> :t Foreign.newForeignPtr_
11:30:55 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO (GHC.ForeignPtr.ForeignPtr a)
11:31:07 <parcs`> :t Control.Concurrent.newMVar
11:31:08 <lambdabot> forall a. a -> IO (GHC.MVar.MVar a)
11:31:21 <Sgeo> You can write a function in the IO monad that will, when run, makes the ForeignPtr, and then runs the newMVar with the Foreign.. hmm. I don't quite understand your requirements
11:31:24 <parcs`> :t Foreign.newForeignPtr_ >=> Control.Concurrent.newMVar
11:31:25 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO (GHC.MVar.MVar (GHC.ForeignPtr.ForeignPtr a))
11:31:40 <Sgeo> Oh, I wasn
11:31:45 <Sgeo> Ignore me
11:32:10 <jdavis> Sgeo, the MVar holds the ForeignPtr to prevent concurrent access to the ptr.
11:33:02 <hpaste_> “^thief^” pasted “Having difficulty using catch within the state monad” at http://hpaste.org/56517
11:33:55 <jdavis> Sgeo, So, I think I want the type to be: IO (MVar (IO (ForeignPtr a)))
11:34:16 <parcs`> jdavis: no, you want the type to be IO (MVar (ForeignPtr a))
11:34:42 <jdavis> parcs` how do I construct such a value?
11:34:58 <jdavis> parcs` using newForeignPtr_ and newMVar?
11:35:41 <Sgeo> Make an action that will, when run, run the action to make the Ptr, then run the action to make the MVar
11:35:50 <parcs`> bind the result of newForeignPtr_ then apply it to newMVar
11:35:55 <parcs`> do { fptr <- newForeignPtr_ ptr; newMVar fptr }
11:36:35 <parcs`> or, more succinctly
11:36:39 <parcs`> :t Foreign.newForeignPtr_ >=> Control.Concurrent.newMVar
11:36:40 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO (GHC.MVar.MVar (GHC.ForeignPtr.ForeignPtr a))
11:36:53 <jdavis> Oh, of course. For some reason I was getting confused with the two IO types.
11:36:59 <parcs`> >=> is like function composition for monadic functions
11:37:02 <parcs`> :t (>=>)
11:37:03 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:37:50 <jdavis> parcs` perfect, exactly what I was looking for, I think.
11:38:27 * Sgeo would not have thought to use >=>
11:38:30 <Sgeo> Is that bad
11:38:37 <parcs`> yes u r dum
11:39:39 <parcs`> but seriously it doesn't matter :P either way it's done it does the same thing
11:40:22 * cmccann grumbles that (<=<) can't just be (.)
11:40:40 <cmccann> without newtype wrappers and such nonsense
11:40:52 <parcs`> ambiguities?
11:41:03 <cmccann> yes, and unavoidably so
11:41:06 <cmccann> but still
11:41:17 <cmccann> I know what I meant, why can't GHC read my mind
11:41:19 <parcs`> are you a proponet of TDNR? :P
11:41:23 <parcs`> nent*
11:41:58 <cmccann> this is more like DWIMDNR
11:42:00 <Sgeo> Because of the .. actually, what ambiguities? Is it related to the monad instance for functions?
11:42:09 <cmccann> Sgeo, no, I'm talking Category
11:42:28 <cmccann> You can't have a category instance for (a -> m b) functions because of obvious ambiguity
11:42:43 <cmccann> if you could, you'd be able to just use (.) in place of (<=<)
11:42:49 <cmccann> and "id" for "return"
11:44:10 * DanBurton muses over the tradeoff between using one combinator that can do tons of stuff vs type safety + nice error messages
11:44:19 <jdavis> It looks like >=> is the opposite order of function composition though, right? I searched for it on hoogle, and I came up with <=< which is more like composition, which makes cmccann's grumbling make more sense.
11:44:33 <parcs`> yep
11:44:37 <DanBurton> right-o
11:45:01 <cmccann> jdavis, yes
11:45:17 <cmccann> I prefer ( =<<) and (<=<) because of that
11:45:47 <cmccann> where (=<<) is basically the monadic version of ($)
11:45:54 <cmccann> :t (=<<)
11:45:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:45:58 <cmccann> :t ($)
11:45:58 <lambdabot> forall a b. (a -> b) -> a -> b
11:47:55 * cmccann tends to write stuff like "(foo <=< bar <=< baz) =<< x" to mimic "foo . bar . baz $ x"
11:48:30 <cmccann> the parentheses being sadly required because the fixities for the monadic operators are silly
11:48:33 * DanBurton often succumbs to do notation
11:49:13 <cmccann> I use do notation when I need to bind identifiers and use them in complicated ways
11:49:34 <cmccann> where I'd use lambdas or let/where in pure functions
11:50:22 <Athas> How do I get the version of the package in Setup.hs?
11:55:09 <said_> Can someone explain me how guards in a do-statement work? I don't get how they filter out certain elements,
11:55:13 <said_> ?
11:56:46 <mauke> @src guard
11:56:46 <lambdabot> guard True  =  return ()
11:56:47 <lambdabot> guard False =  mzero
11:56:55 <mauke> @src [] mzero
11:56:55 <lambdabot> mzero = []
11:57:01 <mauke> @src [] return
11:57:01 <lambdabot> return x    = [x]
11:58:33 <carpi> in the module "Char".. there is a function called "readLitChar". Its signature is "readLitChar :: ReadS Char". What I don't understand is that, the signature seems to suggest that it returns a value of type "ReadS Char" and does not take any input. But the example given in the docs shows that it takes one parameter.. Could someone please explain this anamoly to me?
11:59:03 <parcs`> ReadS is a type synonym
11:59:06 <parcs`> @src ReadS
11:59:06 <lambdabot> Source not found. You type like i drive.
11:59:17 <parcs`> type ReadS a = String -> [(a, String)]
11:59:17 <donri> :info ReadS
12:00:19 <donri> (->) is a type constructor, not syntax for "arguments"
12:00:39 <donri> type Function a b = a -> b
12:01:16 <carpi> ah okay.. so in that case the expanded signature for readLitChar is "readLitChar :: String -> [(Char, String)]"
12:01:31 <said_> mauke: i'm trying to figure it out by working out the do with bind. thx for the info :)
12:02:06 <carpi> donri: ah got it.. something like a curried type constructor..or rather a partially applied type construtor?
12:02:29 <donri> the point is that functions are simply values of the (->) type
12:05:46 <said_> mauke: how do i have to work out this: "guard True >> return 1"? I'm already stuck at "return () >> return 1"?
12:15:33 <carpi> is it possible to get the docs for the packages in hackage in the form of frames?
12:15:44 <carpi> like this http://lambda.haskell.org/platform/doc/current/frames.html
12:16:19 <geekosaur> carpi, hackage is using an older version of haddock that doesn't support frames
12:16:46 <carpi> thanks for the clarification
12:17:33 <carpi> do you know when they might change it?
12:17:45 <carpi> because the frames are so very convenient
12:17:47 <geekosaur> said_, perhaps you're under the misapprehension that "return" does something?  in "return () >> return 1", (>>) throws away the () so you end up with (return 1)
12:18:07 <geekosaur> carpi, supposedly there's an upgraded hackage in development, I don't know the status though
12:18:50 <donri> http://code.haskell.org/hackage-server/ for the curious
12:19:25 <said_> i indeed don't really get it, i think, geekosaur. I get "return 1" and "return 'a'", but what does the "()" represent in "return ()"?
12:19:26 <donri> @where+ hackage2 http://code.haskell.org/hackage-server/
12:19:27 <lambdabot> I will remember.
12:20:14 <geekosaur> () is a sort of dummy value, used specifically because it's going to be thrown away anyway
12:20:27 <nand`> () is the only possible value of type ()
12:20:40 <nand`> it's like a void, but not a Void.Void-type void but just a sort of “nothing”
12:20:44 <ion> data () = () | FileNotFound
12:20:47 <geekosaur> there has to be *some* value, we generally use () ("unit") when we don't care about the actual value because it's going to be thrown away
12:21:24 <nand`> ion: not in prelude
12:21:31 <nand`> at least not in my version of ghc
12:21:34 <said_> ok, thx!
12:21:36 <geekosaur> nand`, that's a joke
12:21:40 <nand`> oh
12:21:58 <geekosaur> it's a reference to a moderately infamous dailywtf
12:22:09 <nand`> hmm
12:22:24 <nand`> isn't () technically a zero-tuple
12:22:25 <geekosaur> involving a custom "boolean" value (True, False, FileNotFOund)
12:22:30 <geekosaur> not in haskell it's not
12:22:38 <nand`> geekosaur: why not?
12:22:40 <geekosaur> haskell doesn't really have 0- or 1- tuples
12:22:57 <nand`> well, what's the distinction between () and a 0-tuple?
12:23:19 <ski> `()' is a zero-tuple
12:23:26 <geekosaur> given the lack of 1-tuples, I'm, not sure it makes sense to think of () as an 0-tuple
12:23:35 <tty7> > (1,2)
12:23:36 <lambdabot>   (1,2)
12:23:38 <tty7> > (1)
12:23:39 <lambdabot>   1
12:23:41 <tty7> > ()
12:23:42 <lambdabot>   ()
12:23:51 <nand`> wouldn't technically every value be a 1-tuple
12:24:09 <nand`> unless there's something in the definition of tuples I'm missing, aside from implied plurality
12:24:16 <geekosaur> bottoms
12:25:05 <ski> there are no one-tuples in Haskell
12:25:20 <geekosaur> a 1-tuple would have an additional "bottom" (non)value, that is _|_ and a theoretical 1-tuple (_|_) are distinct
12:25:37 <geekosaur> s/are/would be/
12:26:45 <geekosaur> (more concretely, if the 1-tuple ( _|_ ) existed, it would represent a nonterminating computation that hasn't been evaluated yet
12:27:18 <geekosaur> it's an additional "box" around the value, hence an additional layer of laziness and an additional place that could hold nontermination
12:27:47 <ion> > Identity undefined
12:27:48 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity a))
12:27:49 <lambdabot>    arisi...
12:27:58 <ski> @slap lambdabot
12:27:58 * lambdabot hits lambdabot with a hammer, so they breaks into a thousand pieces
12:28:13 <hunz_brazil> lol
12:29:25 <ski> hm, actually there are *unboxed* one-tuples in GHC
12:29:27 <ski> > case (# 3 #) of (# x #) -> x
12:29:28 <lambdabot>   3
12:29:44 <ski> @type (# False #)
12:29:44 <lambdabot> (# Bool #)
12:29:52 <nand`> oh boy
12:29:55 <ski> @type (# False , "True" #)
12:29:55 <lambdabot> (# Bool, [Char] #)
12:30:13 <nand`> does that have a type constructor or is it just special syntax?
12:30:21 <nand`> value constructor as well
12:30:34 <ski> @type (# #)  -- is the constructor, i suppose
12:30:35 <lambdabot> forall t. t -> (# t #)
12:30:36 <geekosaur> yeh, that inconsistency was brought up on the list recently
12:30:56 <ski> @type (# , #)  -- unboxed two-tuple
12:30:57 <lambdabot> forall t t1. t -> t1 -> (# t, t1 #)
12:31:29 <ski> otoh, there doesn't appear to be an unboxed zero-tuple !
12:31:38 <geekosaur> correct
12:34:43 * ski demands this injustice be redressed immediately
12:36:07 <DanBurton> ...zero...tuple...?
12:36:11 <DanBurton> ()
12:36:31 <DanBurton> serves as boxed *and* unboxed
12:48:15 <Sgeo> Is EclipseFP decent? It sounds good to me, but Eclipse scares me
12:49:08 <shachaf> If you want to use it then use it, if you don't want to use it then don't.
12:49:24 <shachaf> DanBurton: That doesn't look very unboxed to me.
12:49:47 <mrlase_> okay, works for me, thanks
12:50:55 <Sgeo> How ok is EclipseFP with dealing with files that are not in a cabal project?
12:51:37 <hunz_brazil> Sgeo: I use Eclipse for daily Java programming. I'm very newby at Haskell, so I don't know lots of things like Cabal files, etc. And EclipseFP really makes that easy. I just created a Haskell project, added dependencies and the cabal file was ready, the code was loading, etc. It is not as powerful as Eclipse for Java, but it is easier than e.g. VIM. (at least for me)
12:52:16 <Sgeo> Right, but sometimes, I just want to mess with a file without making a cabal file for it
12:52:38 <Sgeo> Admittedly, my doing that for an actual project is getting me in trouble, but it should imo be easy to experiment with stuff without bothering
12:52:43 <hunz_brazil> I guess that's a reason to use GHCi and a simpler text editor like VIM.
12:53:02 <hunz_brazil> just load it, reload, edit, reload, edit...
12:53:22 <hunz_brazil> EclipseFP do the reloading automatically, but it's terminal to GHCi is kinda bad
12:53:29 <Sgeo> Oh :( how so?
12:53:38 <hunz_brazil> you can't press "up" for previous command for example
12:53:51 <Sgeo> Ah
12:53:51 <hunz_brazil> the up key goes a line up, like a log view
12:54:11 <Sgeo> Is there a way to get the previous command with a keystroke?
12:54:19 <nand`> maybe ctrl+up or something?
12:54:24 <nand`> page up?
12:54:24 <hunz_brazil> I didn't find it.
12:54:46 <hunz_brazil> these things are really boring imo
12:55:09 <hunz_brazil> but the dependency management, hiliting a line, poping up the error, offering quick fixes
12:55:21 <hunz_brazil> these are things that we will get in an IDE like EclipseFP
12:55:25 <hunz_brazil> refactorings, etc
12:55:47 <hunz_brazil> don't know how mature all of that is, as I'm really newby at Haskell and my home projects never got more than two moudles
12:55:49 <hunz_brazil> modules*
12:56:30 <hunz_brazil> but, it's easy to try it out. download eclipse, point to the update site for eclipsefp, next, next, next, finish and you are ready to go
12:57:52 <nand`> oh wow
12:58:05 <nand`> new version of Sublime Text 2 beta came out a few days ago, now with massively improved auto completion
12:58:11 <nand`> works perfectly with haskell
12:58:26 <Sgeo> Sublime Text 2?
12:58:33 <nand`> http://www.sublimetext.com/2
12:59:44 <nand`> ah wait, I said it works perfectly but it doesn't have library integration, just shows completion for all names you used in the file
12:59:55 <nand`> there's probably a plugin for that
13:00:49 <parcs`> vim and emacs have had that for a while
13:02:01 <parcs`> how was it massively improved? how did the completion work before?
13:02:09 <nand`> well
13:02:25 <nand`> it shows up automatically depending on context now, sort of like IntelliSense
13:02:35 <nand`> the most annoying thing about it pre-patch was that you had to hit ctrl+space to have it show up
13:02:53 <nand`> and you can hit tab to complete now instead of enter, that was annoying as well
13:03:24 <parcs`> cool
13:10:33 <dgpratt> nand`: yeah, I was quite happy with the update; I'm thinking it may be time to part with some hard earned credits...
13:11:13 <Sgeo> There is a library I need to link to to try IO stuff in my project
13:11:23 <Sgeo> How would that work with EclipseFP's GHCi
13:19:13 <carpi> could someone please give me a hint for an algorithm to produce different permutations of a list? say for instance permutations of [1,2,3]? I know recursion is involved.. but i find it hard to wrap my head around it
13:19:26 <Sgeo> :t permutations
13:19:27 <lambdabot> forall a. [a] -> [[a]]
13:19:30 <carpi> i know there is an inbuilt permutation function.. but id rather not use it
13:19:33 <Sgeo> Oh
13:20:51 <Botje> carpi: pick one element to be in front. permute the list without that element.
13:26:23 <carpi> i have something like "permute [x,y] = [y,x]" and "permute (x:xs) = x:(permute [2,3])" its obvious that code is awfully wrong.. but i can't seem to get past that stage
13:27:05 <carpi> i can't see how to permute all the digits
13:27:17 <Botje> carpi: you have to generate multiple results.
13:27:37 <Botje> so permute [x,y] = [[x,y], [y,x]]
13:28:15 <Botje> you can write it out similarly for three.
13:28:16 <Botje> BUT
13:28:50 <carpi> then.. its not general enough
13:28:54 <Botje> it will look something like permute [x,y,z] = [[x,y,z],[x,z,y],[y,x,z],[y,...],[z...],[z...]]
13:29:28 <Botje> now how, for element in front, you permute the two others.
13:29:33 <Botje> *note how
13:29:49 <funktronic> you're not thinking recursively enough
13:29:55 <Botje> that's what I meant by 'pick one element'
13:30:03 <copumpkin> > permutations [x,y]
13:30:04 <lambdabot>   [[x,y],[y,x]]
13:30:08 <copumpkin> > permutations [x,y,z]
13:30:09 <lambdabot>   [[x,y,z],[y,x,z],[z,y,x],[y,z,x],[z,x,y],[x,z,y]]
13:30:12 <funktronic> @src permutations
13:30:12 <lambdabot> Source not found.
13:30:20 <Botje> okay, that's a lot easier than typing it out :)
13:30:56 <shachaf> carpi: You'll probably gain a lot more from working on this problem for a while and solving it yourself than from asking for hints. It's a good exercise in recursion.
13:30:59 <carpi> but at the most simplest case,, am i correct in assuming permutation is basically swapping?
13:31:14 <Botje> carpi: you have to find *every* possible permutation.
13:31:16 <shachaf> Not in any way that'll help yhoou.
13:31:21 <shachaf> s/ho//
13:31:22 <Botje> carpi: so both swapping and leaving it in place
13:31:26 <Botje> see copumpkin's command above.
13:32:56 <carpi> it so difficlt because i feel like theres multiple levels of recursion. its like standing in between 2 mirrors
13:33:23 <shachaf> It might be helpful to make a helper function.
13:33:27 <carpi> ill be back with a solution.. thanks for the hints
13:34:04 <shachaf> The first step, though, is understanding what you're trying to do. Maybe write out the permutations for "abcd" manually -- there should be 24 of them.
13:35:08 <carpi> i don't get it.. shouldn't it be [[x,y,z[, [y,x,z], [y,z,x] ... and so on and on...
13:35:34 <Botje> carpi: the permutation function really returns a set.
13:35:37 <Botje> so the order doesn;t matter
13:37:13 <carpi> i just thought of the most disgusting ugly alogorithm that will work..but would be awfully slow. randomly generate the permutations and if a certain permutation has already been discoovered then drop it and generate another one randomly..until you have a list that has length n!
13:38:02 <Botje> carpi: !
13:38:09 <Botje> you know how to generate random permutations?
13:38:24 <carpi> using the random module i suppose
13:38:47 <Botje> okay. continue.
13:38:50 <geekosaur> bogopermute?
13:38:56 <Botje> how would you take a random permutation of [1..5] ?
13:39:03 <Axman6> nub . bogopermute
13:39:58 <carpi> pick a random number from [1..5] and then pick another random number from the remaining list and so on until there is only 1 element remaining in which case we simply tack that to the end of the list
13:40:07 <carpi> would that work?
13:40:11 <Botje> yes.
13:40:18 <Botje> but now you have to generate *all* permutations
13:40:36 <Botje> so you have to simulate the random number being each element of your list in turn.
13:40:54 <Axman6> at least you know how many permutations you need to collect
13:41:05 <Botje> so ..
13:41:24 <Botje> (all permutations with 1 in front) ++ (all perms with 2) ++ (... 3) ++ (... 4) ++ (... 5)
13:41:33 <Axman6> @hoogle RandomGen g => [a] -> g -> a
13:41:33 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:41:34 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:41:34 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:41:42 <Axman6> :t randomR
13:41:42 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:41:54 <Axman6> @hoogle RandomGen g => [a] -> g -> (a,g)
13:41:55 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
13:41:55 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
13:41:55 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
13:42:44 <carpi> Botje: thanks. that really helps.. atleast to think in the right direction )
13:42:58 <carpi> now i be back with good solution. i hope
13:43:23 <Axman6> carpi: using random numbers to calculate permutations is really not the right weay to do it
13:44:19 <carpi> Axman6: oh no.. im not doing that. It was just an example of a something that i thought might work.. but i know it would be painfully slow for large values of n
13:44:29 <Axman6> > let select xs = zipWith (\fs (x:bs) -> (x,fs++bs)) (inits xs) (tails xs) in select [1,2,3]
13:44:30 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2]),*Exception: <interactive>:3:25-48: Non-exhau...
13:44:36 <Axman6> bleh
13:44:38 <carpi> noooooooooooo. don't gimme
13:45:02 <Axman6> it's obviously broken :P
13:45:03 <carpi> your answers have been masked.. i put a paper over my screen D
13:45:40 <Axman6> > let select xs = zipWith (\fs x bs -> (x,fs++bs)) (inits xs) xs (tails xs) in select [1,2,3]
13:45:41 <lambdabot>   Couldn't match expected type `[[a]] -> t'
13:45:41 <lambdabot>         against inferred type `[[...
13:45:54 <Axman6> > let select xs = zipWith3 (\fs x bs -> (x,fs++bs)) (inits xs) xs (tails xs) in select [1,2,3]
13:45:55 <lambdabot>   [(1,[1,2,3]),(2,[1,2,3]),(3,[1,2,3])]
13:46:08 <Axman6> > let select xs = zipWith3 (\fs x bs -> (x,fs++bs)) (inits xs) xs (drop 1 $ tails xs) in select [1,2,3]
13:46:09 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
13:46:17 <Axman6> i'm done now
13:46:40 <carpi> still masked
13:46:57 <mokus> most irc clients have a /clear command
13:47:16 <shachaf> It's hardly fair to expect #haskell no to solve a problem when you bring the problem up.
13:47:43 <Axman6> @pl select xs = zipWith3 (\fs x bs -> (x,fs++bs)) (inits xs) xs (drop 1 $ tails xs)
13:47:43 <lambdabot> select = ap (zipWith3 (flip ((.) . (,)) . (++)) =<< inits) (drop 1 . tails)
13:47:49 <Axman6> clear as mud
13:48:06 <shachaf> > let iaep c [] = [[c]]; iaep c (x:xs) = (c:x:xs) : map (x:) (iaep c xs) in iaep 'z' "abc"
13:48:07 <lambdabot>   ["zabc","azbc","abzc","abcz"]
13:48:21 <shachaf> That would be my approach.
13:51:07 <ski> @type ap (zipWith3 (flip ((.) . (,)) . (++)) =<< inits) (drop 1 . tails)
13:51:07 <lambdabot> forall b. [b] -> [(b, [b])]
13:54:23 <ski> @type yourSelect
13:54:23 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m (a, [a])
14:03:50 <hpaste_> “Joey Adams” pasted “Infinite loop in forked thread is not preempted” at http://hpaste.org/56523
14:04:19 <JoeyA> When I run this in GHC 7.2, the program does not return or print anything.
14:04:49 <JoeyA> I get the same behavior if I use forkOS instead.
14:04:58 <JoeyA> Err, GHC 7.2.2
14:05:29 <monochrom> yikes. probably because the busy thread has no "allocation point". the runtime does not (cannot) pre-empt threads outside allocation points
14:05:55 <Axman6> JoeyA: can you paste the link again? something has gone really wrong with irssi and i can't see it >_<
14:06:00 <monochrom> "allocation point" means for example you build a thunk, among other things
14:06:04 <JoeyA> http://hpaste.org/56523
14:06:17 <JoeyA> GHC 7.0.3 preempts it and returns
14:06:44 <monochrom> ah interesting. perhaps 7.2 optimizes more :)
14:06:46 <Axman6> JoeyA: did you compile with -threaded -rtsopts and run with +RTS -N?
14:07:02 <JoeyA> I compiled with -threaded, but not that.
14:07:15 <Axman6> you'll be using the single threaded runtime then
14:08:30 <monochrom> no, not entirely. -threaded already gives you the OS-threads-enabled runtime, but sure, without -N it still uses one OS thread alone
14:08:58 <erus`> how do i give my Type the kind (* -> *) -> *
14:09:05 <erus`> does it have to be  a class?
14:09:44 <Axman6> type Foo m = m Int?
14:11:10 <erus`> i cant do it with data?
14:11:27 <DanBurton> how would you do it with data?
14:11:41 <copumpkin> data Foo m = Foo (m Int)
14:11:46 <Axman6> what do you axtually want to do?
14:11:47 <erus`> like data Foo a b whaetever = Foo
14:11:56 <Axman6> c*
14:12:06 <erus`> i wanna model data declarations
14:12:07 <parcs`> data Foo (a :: * -> *) = Foo
14:12:39 <trinithis> Does anyone know how to get the width of a terminal in haskell?
14:12:44 <monochrom> turn on "KindSignatures", then what parcs` says
14:12:56 <Axman6> trinithis: probably with one of the curses packages?
14:14:16 <DanBurton> @where curses
14:14:17 <lambdabot> I know nothing about curses.
14:14:22 <trinithis> axman6: ah, thanks. I looked at one of them and it ddint have it. Turns out there are multiple ones
14:16:33 <mike-burns> trinithis: http://goo.gl/9V1lj - getWidth
14:17:49 <JoeyA> Axman6: Compiling with -threaded -rtsopts and running with ./forkIO-doesnt-yield +RTS -N2 still blocks.
14:18:18 <JoeyA> Even if I use forkOS, same result.
14:18:32 <JoeyA> I'll go file a bug-suit.
14:19:16 <JoeyA> T'is a shame, since there are no tickets on 7.2.2
14:24:36 <JoeyA> Hmm, doesn't happen without -O2
14:26:05 <Sgeo> If I _think_, but am not certain, that an a -> IO b always gives the same result when executed, can I reasonably use lazy IO on it?
14:26:36 <JoeyA> Does it interact with other parts of the system?
14:26:53 <Sgeo> It shouldn't, I think
14:26:55 <JoeyA> Does it perform IO, or use MVars or TVars or such?
14:27:04 <JoeyA> Is it interruptible?
14:27:08 <Sgeo> It makes a call to a foreign function
14:27:16 <JoeyA> hmm...
14:27:31 <JoeyA> Might the foreign call take a long time?
14:27:48 <JoeyA> Or is it a pure calculation?
14:28:25 <JoeyA> Does the foreign function take a pointer to a buffer?
14:30:05 <Sgeo> Takes two pointers to buffers
14:30:33 <Sgeo> One for input one for output
14:30:36 <Sgeo> It might take a long time
14:32:05 <Sgeo> "This is a wrapper for compress2 which is part of the zlib compression library. The level parameter of the function call is set to 9 by the SDK."
14:34:16 <JoeyA> My guess is that you'll be fine.  Just make sure the buffer doesn't get garbage collected.
14:34:31 <JoeyA> You should have something like unsafeInterleaveIO $ withForeignPtr $ ...
14:34:52 <parcs`> JoeyA: context switches are performed during memory allocation. "forever (return ())" never allocates any memory. at least, it shouldn't
14:35:43 <JoeyA> parcs`: Still, an infinite loop should not cause the whole program to freeze.
14:35:58 <Axman6> that seems like a very odd restriction to a scheduler. why is there not also a timer?
14:36:10 <c_wraith> because that increases complexity a ton
14:36:26 <c_wraith> JoeyA: technically, it is the GC that stops the whole program
14:36:32 <c_wraith> because it's stop-the-world GC
14:36:58 <c_wraith> so when some other thread wants to do run GC, it sends a pause request to all running HECs
14:37:15 <c_wraith> and if one is stuck in a non-allocating loop, the whole program becomes stuck
14:42:10 <parcs`> this is why lambdabot forks a process for @eval and stuff instead of using forkIO -- evaluating something like 'fix id' would cause the entire bot to freeze
14:42:22 <parcs`> > fix id
14:42:25 <lambdabot>   mueval-core: Time limit exceeded
14:42:30 <parcs`> @botsnack
14:42:30 <lambdabot> :)
14:42:36 <sparkleshy> @type map
14:42:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:42:56 <sparkleshy> @pointless cmpBy f = (\a b -> cmp (f a) (f b))
14:42:56 <lambdabot> cmpBy = flip =<< (((.) . cmp) .)
14:43:04 <sparkleshy> o_O
14:43:38 <parcs`> :t comparing
14:43:39 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:48:15 <DanBurton> :t cmp
14:48:16 <lambdabot> Not in scope: `cmp'
14:48:28 <DanBurton> :t compare
14:48:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:48:56 <DanBurton> @pointless \f a b -> compare (f a) (f b)
14:48:57 <lambdabot> flip =<< (((.) . compare) .)
14:49:00 <DanBurton> -_-
14:52:54 <Sgeo> I don't think I can get EclipseFP working
14:53:12 <Sgeo> Oh, it's because I'm missing curses.h headers?
14:53:34 <Sgeo> How do I fix that?
14:54:12 <mrlase> a tad confused about whitespace in haskell: can I just tab the second line of a do block?
14:58:23 <Axman6> mrlase: you should set your editor to only ever use spaces instead of tabs. tabs are the root of all evil in an indentation sensitive language
15:00:53 <tazjin> If anyone feels bored at the moment: How bad is this code on a scale from 1 to 10, considering that I started Haskell a little over a week ago && is there anything I'm doing that I shouldn't be doing? http://pastebin.com/jkdJQZun
15:00:55 <mauke> The paste jkdJQZun has been copied to http://hpaste.org/56528
15:01:08 <mrlase> okay, thanks Axman6 :)
15:01:47 * Sgeo could just use ZLib, I guess
15:02:39 <Axman6> tyou seem to be giving names to things that are already quite small (cdb  = db dbn etc.), any reason to do so?
15:02:43 <Axman6> tazjin*
15:03:58 <tazjin> Axman6: I didn't do that in line 88 … comparing the two I'd say it's a little less confusing with names. Does that cost me a lot?
15:04:59 <Axman6> tazjin: line 88 is indented way too far imo =) anyway, i'd use more descriptive names than you currently are
15:05:44 <JoeyA> do {r <- <stuff>; return r} can be turned into just <stuff>
15:05:46 <Axman6> also, in readFrom, all you need is: readFromDB dbn docn = runCouchDB' $ getDoc (db dbn) (doc docn)
15:06:34 <Axman6> there's no need for the $ in return $ rdoc
15:07:11 <Axman6> queryDB can have the same thing done as i said ti do with readFromDB
15:07:12 <acowley> Axman6: is there a benefit to your way of getting OpenCL to compile on Mac vs. using the framework as I do in my fork?
15:07:26 <acowley> I really want to get some of my changes merged upstream
15:07:32 <acowley> because it's a pain having to maintain my fork
15:07:38 <Axman6> acowley: using the included headers? i'd say no, using whatever is included on the system is preferable
15:07:45 <acowley> yeah
15:08:04 <tazjin> JoeyA, Axman6: Thanks :]
15:08:08 <acowley> okay, now I need to figure out how to diff my repo vs. head and break it into nice sized patches
15:08:14 <Axman6> the changes i made were just a hack to get it to compile really
15:08:28 <acowley> Does anyone have a git tutorial on doing that?
15:09:34 <parcs`> @free comparing
15:09:35 <lambdabot> Extra stuff at end of line in retrieved type "forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering\n"
15:09:48 <Axman6> tazjin: also, learn to use spaces in your type sigs, IO(Maybe(Doc, Rev, JSValue)) is horrible to read, use IO (Maybe (Doc, Rev, JSValue))
15:12:04 <acowley> tazjin: in addition to what the others have said, that's pretty good looking code!
15:15:46 <tazjin> acowley: Ha, thanks I guess :P
15:16:16 <acowley> tazjin: it's good that you're already concerned about aesthetics
15:17:31 <tazjin> acowley: Well, I'm going to use this code as the database handler for a web app. If it turns out unmaintainable I might end up in trouble later on :P
15:18:06 <acowley> tazjin: that's really the point behind caring about aesthetics. It's not all golfing for the sake of golfing, but taking pity on your future self.
15:18:26 <tazjin> acowley: I'm going to steal that line :]
15:25:11 <ddarius> @hoogle randomR
15:25:11 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:25:11 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
15:25:11 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
15:25:16 <ddarius> @hoogle+
15:25:52 <ddarius> :t randoms
15:25:52 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
15:26:08 <ddarius> @hoogle getStdGen
15:26:08 <lambdabot> System.Random getStdGen :: IO StdGen
15:26:14 <Sgeo> What package do I need for curses.h?
15:26:33 <Axman6> @hoogle curses
15:26:33 <lambdabot> package hscurses
15:26:33 <lambdabot> package hscurses-fish-ex
15:26:33 <lambdabot> package nanocurses
15:26:45 <Axman6> oh, you mean in C land?
15:53:41 <Hugglesworth> anyone have experience with cmdargs?
15:53:48 <Hugglesworth> the --help output is pissing me off
15:54:11 <Hugglesworth> if I only have a few sub-commands then it prints the flags and what not for all of them
15:54:32 <Hugglesworth> if I have more than about 5 it just prints the sub-command's name and it's description and nothing more
15:54:49 <Hugglesworth> anyway to make it print more information?
15:57:34 <zeiris> Got any code snippets to reproduce this?
15:58:59 <Hugglesworth> I'd have to strip my code down a fair bit to post on hpaste or sth
16:00:53 <zeiris> It seems like a fairly specific question, so unless someone's run into the exact same problem that's probably the best way to get a response.
16:02:06 <Hugglesworth> *nod*
16:02:25 <Hugglesworth> I'mma just play with my modes for a sec and make sure it's not something weird with a single setting that I didn't pick up on before
16:03:48 <Hugglesworth> seems to make the change if it would make --help print more than a screen worth
16:04:19 <acowley> I tried to use cmdargs once and gave up on it. It seemed a bit rigid and finicky at the time, and writing my one support code wasn't so bad.
16:04:29 <Hugglesworth> or not, doesn't take terminal size into account
16:04:52 <Hugglesworth> maybe my screen size is just a coincidental size
16:04:54 <acowley> But I really like the idea behind it and kind of wish I had stuck with it to get the hang of it
16:05:21 <DanBurton> ReadArgs is an alternative package, though I don't think it has the customizability of cmdargs
16:09:24 <amtal> I'm going to be writing some hardware control/camera control/simple image manipulation software for automating experiments. Take photos, do some averaging and summing, plot a few graphs kinda thing.
16:09:47 <amtal> The obvious thing to do is Python + scipy... But I'm wondering whether this is doable with Haskell.
16:10:13 <amtal> What GUI library would you recommend to try and do a simple prototype, for comparison purposes?
16:11:27 <DanBurton> @wiki gui
16:11:27 <lambdabot> http://www.haskell.org/haskellwiki/gui
16:11:36 <DanBurton> boo
16:11:39 <acowley> amtal: I would use my HOpenCV fork (it's on github) for camera interfacing
16:11:48 <DanBurton> @wiki GUI
16:11:49 <lambdabot> http://www.haskell.org/haskellwiki/GUI
16:11:53 <acowley> amtal: GUI is trickier to recommend as it somewhat depends on your target OS
16:12:05 <amtal> The last time I played with GUIs there was a lot of experimental/incomplete stuff. (wx I think suffered from it.)
16:12:09 <acowley> amtal: For Linux, perhaps gtk2hs. For Mac, wx.
16:12:27 <amtal> True. I'm looking at primarily Windows.
16:12:37 <acowley> amtal: The GUI story still isn't great, but it can work.
16:12:57 <dcoutts> amtal: I've used gtk2hs on windows successfully in commercial projects
16:12:59 <acowley> amtal: I'm partial to wx because I use macs, and I appreciate the mostly native look and feel it provides
16:13:07 <tikhonjelvis> Which test framework should I use? HTF or test-framework?
16:13:09 <acowley> amtal: but gtk2hs is well-supported on Windows
16:13:25 <acowley> tikhonjelvis: test-framework with HUnit and QuickCheck!
16:13:32 <Hugglesworth> QT is really nice to work with, but last I checked the bindings weren't quite ready
16:13:36 <acowley> tikhonjelvis: and make a test suite in your .cabal file
16:13:46 <amtal> I'll try gtk2hs. If not it, there's always just using OpenGL.. For simple GUIs I've had moderate success with it.
16:13:55 <tikhonjelvis> I haven't gotten around to setting the cabal stuff up yet :P
16:14:19 <tikhonjelvis> Ooh, talking about QT, I want to make a QT project in the near future.
16:14:22 <acowley> tikhonjelvis: do that sooner rather than later. It's really not so hard to get started, and it makes life much easier as you go along
16:14:53 <tikhonjelvis> acowley: That's my plan. I've paused actually working on my current project in order to set up the tests and builds and stuff.
16:15:12 <tikhonjelvis> Is there any FRP-type library that supports QT?
16:15:15 <acowley> tikhonjelvis: you can use "cabal init" to get the ball rolling
16:15:50 <acowley> The most actively developed FRP library at the moment seems to be reactive-banana which has wx bindings
16:15:58 <tikhonjelvis> acowley: Ooh, cabal init is neat.
16:16:29 <tikhonjelvis> In a perfect world I really want to use QT because I'm on KDE. If it isn't an option, I'll use reactive-banana.
16:16:30 <acowley> tikhonjelvis: yeah, it pretty much means you don't have to pore over the user guide just to get started
17:26:00 <zzo38> Is there any Haskell-based ephemeris software?
17:26:57 <dmwit> Haven't heard of any.
17:29:43 <zzo38> Do you know how to write any or any other idea about such thing?
17:32:21 <Sgeo> Conduits question:
17:32:31 <Sgeo> When would Data.Conduit.List.head return Nothing?
17:32:41 <Sgeo> If the end of the stream is reached, I guess?
17:33:12 <zzo38> How should I represent a sound synthesis datatype in Haskell?
17:33:34 <zzo38> In a way that other files can have the components, and then be loaded into Haskell.
17:34:06 <zzo38> Such as, additive, subrtactive, etc
17:36:07 <Sgeo> Is sinkNull able to close off a stream?
17:36:21 <Sgeo> That is, somehow tell the source that it's done processing, the source can clean up now?
17:36:32 <Sgeo> Does that happen automatically?
17:39:55 <interiorcrocodil> what does >>= do?
17:40:08 <dmwit> It depends on what type you call it at.
17:40:27 <dmwit> But, generally: it lifts a function that doesn't expect a monadic input into one that does.
17:40:36 <dmwit> (=<<) :: Monad m => (a -> m b) -> (m a -> m b)
17:40:44 <interiorcrocodil> :O
17:40:48 <Sgeo> So, I'm wrapping an event-based API
17:40:52 <interiorcrocodil> is there a list of haskell operators somewhere?
17:41:06 <Sgeo> Does it make sense to wrap the events as conduit Sources?
17:41:09 <dmwit> No, but you can use hoogle to find documentation.
17:41:11 <dmwit> ?where hoogle
17:41:11 <lambdabot> http://haskell.org/hoogle
17:41:14 <Sgeo> From an API design standpoint, I mean
17:41:26 <ddarius> > let x =^.-= y = x ++ y in "con" =^.-= "cat"
17:41:27 <lambdabot>   "concat"
17:41:30 <interiorcrocodil> thanks
17:41:46 <Sgeo> interiorcrocodil, people can define their own operators, as ddarius shows
17:41:49 <tikhonjelvis> Operators are just functions with cute names
17:42:02 <tikhonjelvis> you should think of them the same way as of normal functions.
17:42:16 <tikhonjelvis> Which is nice: you can do stuff like :t (+) in GHCi, for example.
17:42:25 <interiorcrocodil> Sgeo: awesome
17:44:05 <interiorcrocodil> what do you guys think about this
17:44:06 <interiorcrocodil> http://www.youtube.com/watch?v=iSmkqocn0oQ
17:47:27 <Sgeo> ""Error loading local database
17:47:27 <Sgeo> incorrect header check
17:47:33 <Sgeo> When trying to use EclipseFP
17:47:43 <dmwit> interiorcrocodil: The question is too vague to support a meaningful answer.
17:48:17 <interiorcrocodil> agree/disagree?
17:48:28 <interiorcrocodil> i don't understand what he means by useless
17:51:09 <tikhonjelvis> Heh, I love the cabal user-guide: "Chaos will result if two distinct packages with the same name are installed on the same system..."
17:51:16 <tikhonjelvis> At least they're not sugar-coating anything.
18:02:52 <acowley> cabal-dev is very hungry for hdd space
18:29:19 <koninkje> If I want to have a static C-style array with unsafe indexing, what's the cleanest approach these days?
18:30:19 <koninkje> is there a way to declare the backing of a Ptr Foo as a static object?
18:30:41 <copumpkin> koninkje: I'd just use Vector
18:30:53 * koninkje takes a look
18:33:18 <koninkje> er, well, this is for hacking on base, so I can't really have any dependencies...
18:33:57 <koninkje> I can always use the FFI, but I was wondering if there's a cleaner way
18:34:29 <koninkje> doh, wrong project; this one isn't for base, nm
18:36:15 <copumpkin> oh
18:36:48 <koninkje> though I am trying to keep it H98...
18:45:44 <slack1256> guys let suppose i got the following code
18:45:51 <slack1256> func a = sharing a
18:46:51 <slack1256> map (\a -> (a, sharing a)) . filter func
18:47:01 <slack1256> will it share the "sharing a" results?
18:47:35 <monochrom> likely not
18:47:55 <slack1256> mmm i thought that.
18:47:59 <Axman6> i don't even understand the question...
18:48:04 <Sgeo> Is there any way to interleave Sources?
18:48:08 <shachaf> That's not really what "sharing" usually means.
18:48:10 <koninkje> If you (filter func) then (sharing a)==True for all the remaining a
18:48:20 <Axman6> shachaf: Sources? do you mean from Conduits?
18:48:31 <shachaf> Axmna6: shachaf? Do you mean Sgeo?
18:48:34 <Sgeo> Axman6, I think you intended to direct that at me, and yes.
18:48:36 <slack1256> koninkje: is just an example, ( a bad one thought)
18:48:36 <Axman6> uh, yeah Sgeo
18:49:10 <Axman6> Sgeo: what do you mean be interleve? take one input from one, then the next from the other and soforth?
18:49:29 <Sgeo> Something like that, yes
18:49:34 <slack1256> monochrom: then to make sharing happen i would have to define "func" in a where clause on the filter code
18:49:52 <slack1256> to them being on the same scope?
18:50:20 <Axman6> Sgeo: i'm sure it could be implemented, but you might need to dig into the actual implementation in Conduits.
18:50:50 <shachaf> slack1256: That still won't make any difference.
18:51:13 <monochrom> what koninkje says. map (\a -> (a, True)) . filter func
18:51:25 <Axman6> jesus
18:51:30 <Axman6> bloody irccloud
18:51:35 <shachaf> let f = longComputation in (f 5, f 5) -- won't be shared.
18:51:53 <shachaf> let x = longComputation 5 in (x, x) -- will be shared.
18:52:04 <dolio> It will share the work to compute f.
18:52:17 <monochrom> heheh
18:52:52 <slack1256> mmm maybe i should specify my example a little bit more
18:52:57 <slack1256> func a = sharing a
18:53:07 <dolio> let f = countToAMillionThenReturn (\x -> x) in (f 5, f 5)
18:53:10 <slack1256> map (\a -> (a, sharing a)) . filter (isJust func)
18:53:20 <slack1256> note the isJust
18:53:23 <shachaf> dolio: "longComputation" was meant to be a single identifier.
18:53:32 <dolio> :)
18:53:33 <monochrom> or a lambda
18:53:34 <shachaf> slack1256: Everything I said before is still true.
18:53:46 <Axman6> :t isJust
18:53:47 <lambdabot> forall a. Maybe a -> Bool
18:53:55 <shachaf> slack1256: "func a = sharing a" is pretty much the same as "func = sharing".
18:53:59 <Axman6> do you mean isJust . func?
18:54:26 <shachaf> Yes, slack1256 means isJust . func.
18:54:39 <shachaf> But that doesn't really change anything (other than making it type-check).
18:54:43 <slack1256> yes, what i mean there with "func a = sharing a" is that sharing is defined apart from the rest of the code
18:55:02 <shachaf> That's not how sharing works, as I mentioned.
18:55:12 <slack1256> yeah. your are right.
18:55:25 <shachaf> If you call a function twice, the computation will happen twice.
18:55:51 <monochrom> \xs -> [ (a, b) | a <- xs, let b = sharing a, isJust b ]
18:56:02 <dmwit> :t \func -> catMaybes . map func
18:56:03 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
18:56:06 <dmwit> ?
18:56:28 <monochrom> not directly catMaybes because of the extra tuple
18:56:43 <shachaf> All this talk of Maybes and isJusts is completely tangential to slack1256's actual question.
18:56:45 <monochrom> which is why eventually I decided to just list-comprehend it
18:57:11 <Axman6> Sgeo: what sort of Sources do you want to interleve?
18:57:23 <dmwit> [(a, b) | a <- xs, Just b <- [func a]], then
18:57:24 <slack1256> dmwit: i had forgotten about catMaybes (that will simplify another code of my)
18:58:06 <monochrom> actually you want to keep the Just constructor. [(a, b) | a <- xs, b@(Just _) <- [func a]]
18:58:12 <Sgeo> Axman6, a source that ... arrives between other sources
18:58:12 <dmwit> No I don't.
18:58:39 <monochrom> "sharing a" is Just x or Nothing, and the desired tuple is (a, sharing a)
18:58:55 <dmwit> pffft, slack1256 doesn't know what he wants
18:59:09 <dmwit> like most humans
18:59:11 <shachaf> dmwit++
18:59:12 <Sgeo> My plan was to use Sources to represent events in my wrapper
18:59:55 <Sgeo> I wonder if I could use conduits
19:00:08 <slack1256> dmwit: are you some kind of psychologist?
19:00:08 <Sgeo> To combine them
19:01:13 <slack1256> well thanks #haskell, keep enlightening as always.
19:03:23 <msd> Hello all. Looking for xmonad config help. Is there a dedicated channel for xmonad, or his #haskell a good choice?
19:03:54 <monochrom> there is #xmonad IIRC
19:04:14 <msd> Much obliged.
19:16:20 <MaskRay> account add jabber emacsray@gmail.com doyouknowHaskell
19:16:58 <parcs`> hmmm
19:17:25 <geekosaur> already gone, hpe they realize they need to change their password...
19:18:11 <monochrom> strange password :)
19:20:17 <parcs`> at least it's not hunter2
19:21:49 <ivanm> parcs`: what password was that? all I saw was ******* ...
19:21:57 <ivanm> ;-)
19:22:18 * geekosaur *eyeroll*
19:49:11 <JoeyA> I'm writing a library function that spawns two threads, calls a user-supplied action, and cleans up those threads at the end.
19:50:47 <JoeyA> The risk of simply killing these threads in a `finally` block is, if the caller thread receives an asynchronous exception during the cleanup (throwTo is interruptible), there will be zombie threads doing gosh-knows-what.
19:51:10 <OODavo> Is there an inclusive version of takeUntil, that includes in its taken elements the first one that does match the predicate? Conversely, a version of dropUntil that leaves off the first match?
19:51:21 <JoeyA> :t takeUntil
19:51:22 <lambdabot> Not in scope: `takeUntil'
19:51:36 <JoeyA> What's takeUntil?
19:51:55 <geekosaur> I think they meant takeWhile
19:52:07 <OODavo> … I was sure a takeUntil function existed. Huh.
19:52:21 <JoeyA> > takeWhile (<3) [0..10]
19:52:22 <lambdabot>   [0,1,2]
19:52:30 <JoeyA> So like that, except you also want the 3?
19:52:37 <OODavo> Like that, yes.
19:52:52 <JoeyA> What if no items match the predicate?  Return the original list?
19:53:04 <JoeyA> > span (<3) [0..10]
19:53:05 <lambdabot>   ([0,1,2],[3,4,5,6,7,8,9,10])
19:53:21 <JoeyA> You could case match on that.
19:53:31 <OODavo> Hmm.
19:54:20 <JoeyA> hmm, then you'd have to do an expensive concatenation.
19:54:23 <JoeyA> @src takeWhile
19:54:24 <lambdabot> takeWhile _ []                 =  []
19:54:24 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
19:54:24 <lambdabot>                    | otherwise =  []
19:55:38 <OODavo> Hmm. I think what I actually need is span, except including the first match in fst rather than snd.
19:55:59 <JoeyA> @src span
19:56:00 <lambdabot> span _ xs@[]                     =  (xs, xs)
19:56:00 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
19:56:00 <lambdabot>                   | otherwise    =  ([],xs)
19:58:01 <JoeyA> Might be better off just rolling your own function using pattern matching.
19:58:31 <OODavo> True. Doesn't seem it'd be too complex.
19:58:32 <OODavo> Thanks.
19:58:33 <geekosaur> ooks to me like that definition is easily modified to get the behavior you want, although perhaps just pattern matching on the result would be enough dependong on how you use it
20:16:58 <Guest1251255> :wq
20:17:23 <OODavo> When compiling a single file with ghc --make, .o and .hi files are also produced. Is there a flag to ghc I might use to indicate I only require the final executable?
20:18:27 <geekosaur> no
20:31:35 <saiko-chriskun> are there any arrow tutorials besides what's on the wikibooks? I don't see anything even in the '10 specs report
20:39:55 <byorgey> saiko-chriskun: http://www.soi.city.ac.uk/~ross/papers/fop.html, http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
20:42:09 <JoeyA> Is it safe to use the restore callback of mask in a child thread?
20:42:39 <JoeyA> as in, mask $ \restore -> ... forkIO $ restore $ ...
20:43:29 <JoeyA> It looks safe with the current implementation.
20:44:52 <kkrev> total newb. "foldr (\x c -> sqrt (x + c)) 0" gives this error: No instance for (Floating Int) arising from a use of `sqrt'
20:45:04 <kkrev> I don't understand how to add type annotations to fix it?
20:45:07 <JoeyA> > sqrt (0 :: Int)
20:45:08 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
20:45:08 <lambdabot>    arising from a use of...
20:45:16 <JoeyA> > sqrt 0
20:45:18 <lambdabot>   0.0
20:45:25 <shachaf> @ty foldr (\x c -> sqrt (x + c)) 0
20:45:26 <lambdabot> forall b. (Floating b) => [b] -> b
20:45:31 <shachaf> The error isn't where you think it is.
20:45:54 <shachaf> You're applying the function (which type-checks) to a list of Ints.
20:46:01 <shachaf> You can't take the sqrt of an Int.
20:46:50 <kkrev> map sqrt [1,2,3] works ok.
20:46:55 <Axman6> kkrev: there is no built in function to find the square root of integral types in haskell
20:47:05 <Axman6> > map sqrt [1,2,3] :: [Int]
20:47:06 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
20:47:06 <lambdabot>    arising from a use of...
20:47:21 <Sgeo> kkrev, literals like 1 automatically turn into whatever kind of number they need to be
20:47:23 <shachaf> kkrev: Number literals are polymorphic.
20:47:24 <Sgeo> *type of number
20:47:45 <Axman6> :t 1
20:47:46 <Sgeo> :t map sqrt [1,2,3]
20:47:46 <lambdabot> forall t. (Num t) => t
20:47:47 <lambdabot> forall a. (Floating a) => [a]
20:47:54 <Axman6> :t 1.0
20:47:55 <lambdabot> forall t. (Fractional t) => t
20:49:53 <kkrev> well how do you static_cast from integer to floating point in haskell?
20:50:21 <Axman6> >________<
20:50:28 <Axman6> this is not C++
20:50:31 <kkrev> no kidding.
20:50:53 <Axman6> what is it that you actually want?
20:51:15 <kkrev> apparently to construct a floating point number from an integer.
20:51:26 <shachaf> kkrev: fromIntegral will do what you want.
20:51:28 <Axman6> ok, well have at fromIntegral
20:51:41 <Redshift64> lmao
20:53:09 <Redshift64> oh.
21:12:15 <DewdropMaple> Having difficulty installing Pandoc via cabal. Unable to install json-0.4.4 or xhtml-3000.2.0.4 due to ExitFailure 1.
21:14:13 <DewdropMaple> cabal install json worked fine, but gave me json-0.5 and thus did not satisfy the dependency.
21:16:51 <dobblego> is there a nice mechanical way to determine which minimum version of GHC base is required for a particular function?
21:18:08 <ivanm> dobblego: don't think so
21:18:41 <byorgey> DewdropMaple: ah, yeah, I've run into that.  The problem is that several packages (I forget which ones exactly) specify an upper bound  json < 0.5  and haven't been updated since json-0.5 was released
21:18:48 <byorgey> but in fact they work fine with json-0.5.
21:19:03 <DewdropMaple> Oh?
21:19:13 <dobblego> I am binary-searching the GHC docs
21:19:16 <DewdropMaple> Could I force the Pandoc install to use that one, then?
21:20:34 <Sgeo> concatEnums :: Monad m => [Enumerator a m b] -> Enumerator a m b
21:20:44 <Sgeo> Is there anything similar for conduit's Sources?
21:20:55 <yitz> DewdropMaple: yes. do cabal fetch <name> to get the package, edit its .cabal file to change the dependency, then (in that directory) type cabal install.
21:20:57 <byorgey> DewdropMaple: well, you have to figure out which package(s) specify the offending version bound.  Suppose it is package foo.  Then you (1) cabal unpack foo (2) cd foo (3) edit foo.cabal and change the json upper bound to < 0.6, AND increment foo's version number (i.e. append .1 or something), (4) 'cabal install'
21:21:08 <Sgeo> I don't see how, since conduits are pull-based instead of the push-based enumerator
21:21:11 <yitz> oh also unpack, right
21:21:17 <Sgeo> But this is kind of a crucial issue for nme
21:21:20 <Sgeo> *me
21:21:30 <Sgeo> This is _exactly_ the kind of interleaving of Sources that I wanted
21:21:40 <DewdropMaple> Looks like it's citeproc-hs-0.3.3 causing that issue.
21:21:57 <DewdropMaple> Any ideas regarding the other problematic package? xhtml-3000?
21:22:14 <yitz> Sgeo: it shouldn't be hard to do that in conduits
21:22:16 <byorgey> DewdropMaple: no, I don't think so, citeproc-hs does not specify an upper bound on json
21:22:26 <Sgeo> yitz, hmm, how?
21:22:31 <DewdropMaple> > citeproc-hs-0.3.3 depends on json-0.4.4 which failed to install.
21:22:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:22:45 <Sgeo> I mean, can you ask a Source "Is data ready yet, or do I need to wait?"
21:22:55 <hpaste_> mzero pasted “type family and transtformer” at http://hpaste.org/56531
21:22:59 <Sgeo> (I was assuming before this that I'd do blocking if it's not ready, maybe that's the problem)
21:23:00 <dobblego> what is the correlation between GHC version and base version?
21:23:05 <byorgey> DewdropMaple: yeah, cabal's error messages are not super helpful here
21:23:22 <mzero> I have this convoluted situation  with type families and transformers
21:23:59 <mzero> anyone with some experience wanna take a look
21:24:00 <byorgey> DewdropMaple: it seems the problem is the pandoc package itself
21:24:12 <yitz> Sgeo: oh, you want to not block if it's not ready?
21:24:19 <Sgeo> yitz, right
21:24:36 <Sgeo> (Or an option to do so. Otherwise, how would I be able to build a concatSources?
21:24:45 * byorgey ought to figure this out properly and send off some patches to the package maintainers, and post instructions on his blog
21:26:09 <mzero> so, I've got some monad transformer, say Built m,  and I want to "hoist" the instance membership of the inner monad like so
21:26:11 <mzero> instance (PosixLike m) => PosixLike (Built m) where
21:26:27 <Sgeo> I guess I could make my sources be Maybes, then provide a conduit that filters out the Nothings
21:26:37 <mzero> where basically, all the methods are just a whole bunch of     foo x = lift $ foo x
21:26:45 <Sgeo> Or something like that
21:26:49 <Sgeo> But that seems a bit iffy
21:26:56 <DewdropMaple> Ah, so I need to cabal unpack pandoc and alter /its/ .cabal?
21:27:27 <yitz> Sgeo: that actually sounds reasonable. why is it iffy?
21:27:29 <byorgey> DewdropMaple: yes
21:27:50 <byorgey> DewdropMaple: I can't guarantee that will be the end of it, but that's at least where you need to start
21:28:05 <Sgeo> yitz, because I'm not sure if there's a real reason to wrap an event-based API with conduits instead of enumerator
21:28:13 <dobblego> mzero: hoist is a function on MonadTrans that does exactly this iirc
21:28:30 <byorgey> DewdropMaple: remember to increment pandoc's version number when you alter its .cabal, otherwise cabal-install gets confused between your local version and the version on hackage
21:28:36 <mzero> sure - that part works ... BUT the type class has a type family in it
21:29:00 <mzero> so I've got something like      type FileStatus (Built m) = FileStatus m
21:29:10 <yitz> Sgeo: if you're ok with enumerators, then fine. that then spreads over your whole program though.
21:29:33 <Sgeo> yitz, "spreads"? How so?
21:29:36 <DewdropMaple> That fixed the complaint about json, but xhtml-3000 is still complaining.
21:29:40 <yitz> Sgeo: the idea isn't to "wrap" them. conduits replaces them completely.
21:29:44 <mzero> now comes the horror ---- there is a method in PosixLike     isDirectory :: FileStatus m -> Bool
21:29:45 <Sgeo> What is easier to do with conduits than enumerators
21:29:56 <Sgeo> yitz, I'm wrapping a foreign fundamentally event-based API
21:30:00 <mzero> see my hpaste --- I can't write the instance for Built m
21:30:10 <Sgeo> And wrapping events as either conduits or enumerators. Plan until now was conduits
21:30:47 <Sgeo> I don't have enough experience with enumerators to understand the inversion of control complain
21:30:49 <Sgeo> complaint
21:30:51 <byorgey> DewdropMaple: hmm, can you paste the output from cabal install somewhere?
21:31:20 <DewdropMaple> Certainly.
21:31:26 <yitz> Sgeo: what would be the natural structure of your program, apart from what IO library you use?
21:32:09 <hpaste_> DewdropMaple pasted “cabal install of pandoc” at http://hpaste.org/56534
21:32:10 <yitz> Sgeo: does this api work by registering callbacks or something?
21:32:15 <Sgeo> yitz, yes
21:32:20 <DewdropMaple> ^
21:32:38 <yitz> Sgeo: you want to be able to register haskell functions as your callbacks then?
21:33:13 <Sgeo> yitz, I want to be able to choose what to do with the events. e.g. waiting on an event, or waiting for any of several events, etc.
21:33:18 <yitz> Sgeo: so then just do that. what does it have to do with enumerators or conduits?
21:33:22 <Sgeo> or just a normal event handler
21:33:39 <Sgeo> I figured that they would be a nice abstraction for me to provide that makes the things easy to use
21:34:25 <Sgeo> It's easy, with a Source being an event, to wait on it with Data.Conduit.List.head, or wait on several, or fork it and treat it as registering an event, etc.
21:34:32 <yitz> Sgeo: those libraries are for data streaming. i still understand the connection with these events.
21:34:34 <Sgeo> (wait on several of the same event)
21:34:37 <yitz> still don't
21:35:02 <Sgeo> I guess I'm viewing events as streams of data
21:35:22 <Sgeo> Are there better abstractions for events/
21:35:36 <Sgeo> That don't force the entire program into FRP or something, I mean
21:36:19 <yitz> Sgeo: cps sounds like a good style for a callback api.
21:36:58 <Sgeo> yitz, as in, forcing portions of the program that want to wait for an event to occur to use ContT?
21:36:58 <yitz> Sgeo: enumerators happen to be cps style also, but so are a lot of libraries and programs.
21:38:02 <DewdropMaple> Anything in http://hpaste.org/56534 indicative of why Pandoc refuses to compile?
21:38:35 <yitz> Sgeo: you don't have to force them. you just have a provide an api that implements the callback logic you want.
21:39:13 <Sgeo> What I want is an existing library that already provides easy-to-use abstractions for events, I think
21:39:29 <yitz> Sgeo: i would say design the ideal user-facing api that you want, before you decide to use any particular underlying library. then see what tools you need to do that.
21:40:17 <Sgeo> I think my ideal user-facing library uses something like enumerator or conduits.
21:40:19 <Sgeo> >.>
21:40:36 <yitz> Sgeo: i'm lost again :)
21:40:44 * Sgeo needs to go to sleep
21:42:07 <Sgeo> Blargh, Enumerators aren't functors.. well, I guess they are, since they're functions
21:42:48 <Sgeo> > fmap (+1) id 0
21:42:49 <lambdabot>   1
21:43:12 <Sgeo> fmap . fmap is ugly
21:43:20 <Sgeo> Not even sure if that's the right function
21:43:22 <Sgeo> :t fmap . fmap
21:43:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:43:27 <yitz> Sgeo: anyway, snoyberg just told me that since conduit Sources have a Monoid instance, you just use mconcat.
21:43:39 <DewdropMaple> I suspect that this line is the one producing the issue:
21:43:40 <DewdropMaple> >     base:Prelude can't be safely imported! The package (base) the module resides in isn't trusted.
21:43:40 <lambdabot>   <no location info>: parse error on input `module'
21:43:44 <Sgeo> yitz, o.O ty
21:43:58 <yitz> Sgeo: i still don't understand how either enumerators or conduits have anything to do with this, but i hope that helps. :)
21:44:13 <Sgeo> It does
21:44:16 <Sgeo> I think
21:44:29 <Sgeo> Although I don't _quite_ understand how a Monoid instance could possibly work
21:44:40 <Sgeo> ...it might mean something other than what I want :/
21:44:54 <Sgeo> If it means pulling from the first one that's open, it's not what I want
21:45:29 <yitz> Sgeo: i think it means pull from the first one until done, then move on to the next one.
21:45:44 <Sgeo> Yeah, that's not what I want to do
21:47:33 <DewdropMaple> Which means the issue is that I can't install the xhtml library.
21:47:46 <DewdropMaple> Even with just cabal install xhtml, the same error is produced.
21:47:57 <Sgeo> Night
21:48:11 <byorgey> DewdropMaple: aha!
21:48:19 <byorgey> DewdropMaple: just run 'ghc-pkg trust base'
21:48:50 <DewdropMaple>  > ghc-pkg: /var/lib/ghc/package.conf.d/: openBinaryTempFile: permission denied (Permission denied)
21:48:57 <DewdropMaple> Do I need to run that as root, or something?
21:48:57 <byorgey> DewdropMaple: ghc 7.2 shipped with a broken configuration where it doesn't trust itself =P
21:49:11 <DewdropMaple> Usually ghc things should be run unelevated, I thought.
21:49:17 <byorgey> DewdropMaple: oh, you might
21:49:26 <byorgey> DewdropMaple: yeah, because base is in the global package DB
21:49:47 <byorgey> running it as root is OK
21:49:53 <DewdropMaple> Right.
21:50:06 <DewdropMaple> And now the Pandoc modules are compiling. Excellent.
21:50:08 <DewdropMaple> Thanks. ^_^
21:50:17 <byorgey> great! you're welcome. =)
21:50:27 <hpaste_> mzero annotated “type family and transtformer” with “type family and transtformer (annotation)” at http://hpaste.org/56531#a56535
21:51:00 <mzero> okay - let's try this again - line 53 of the updated hpaste --- how can I write that instance method?
21:51:50 <mzero> grr line 55
21:52:19 <mzero> (it was line 53 before I put in the comment at the top!)
21:56:21 <Enigmagic> mzero: what version of GHC are you using
21:56:38 <Enigmagic> it seems to work over here on 7.2.1 with FlexibleInstances enabled
21:58:08 <shachaf> Enigmagic: Will we see you on Wednesday, by the way?
21:58:18 <Enigmagic> shachaf: yeah, Steve and I are coming
22:02:53 <mzero> was trying ideas out ...I'm using 7.0.4
22:03:52 <mzero> same error when FlexibleInstances is added
22:04:48 <Enigmagic> there were a lot of type family bugs fixed in 7.2.x
22:05:03 <Enigmagic> i had to upgrade for a similar reason quite a while back
23:15:53 <kniu> so what are conduits and why should I care?
23:22:28 <yitz> kniu: they are an alternative to the usual lazy io for when you need to control resource allocation and release explicitly
23:57:51 <Duffman-> :t unless
23:57:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:58:55 <Duffman-> what does m() mean in the type?
23:59:24 <shachaf> It's not "m()", it's "m ()".
23:59:35 <shachaf> The type constructor "m" applied to the type "()".
23:59:53 <geekosaur> the context tells you that, it is a type which has a Monad instance
