00:05:55 <luite> EvanR: there are similar libraries for other languages (although I think you usually don't have the same guarantees offered by haskell static types)
00:07:59 <EvanR> one thing im confused about so far is class Migrate a consists of migrate :: MigrateFrom a -> a, and a type MigrateFrom a
00:08:07 <EvanR> type MigrateFrom a means why by itself?
00:08:10 <EvanR> inside a class?
00:08:18 <EvanR> means what*
00:08:44 <elliott> it's a type family
00:08:45 <luite> that's an associated type synonym
00:08:48 <elliott> an instance has to give a definition for it
00:08:55 <elliott> i.e. type MigrateFrom NewType = OldType
00:08:57 <EvanR> interesting
00:09:50 <EvanR> so 'MigrateFrom' depends on each instance?
00:10:03 <EvanR> means something different in each instance
00:11:20 <EvanR> does the compiler make sure that instance Migrate X and type MigrateFrom X = foo is the same X
00:11:29 <EvanR> = Foo
00:11:48 <EvanR> ah yes, a
00:12:06 <EvanR> whacky
00:22:20 <hpaste> srhb pasted “Printing number of zeroes in factorial” at http://hpaste.org/56955
00:22:23 <srhb> I've been looking at the very simple SPOJ problem for the purpose of learning to optimize IO, and in this case my solution is probably not bad, but miles away from the best solution. I was wondering if there are any experts here that would look over my code (very short) and tell me if I'm doing something that could be optimized better.
00:25:09 <elliott> looks basically OK to me; ByteString looks like overkill
00:25:13 <elliott> you're processing sequentially, so lists are fine
00:25:28 <elliott> oh hmm
00:25:30 <elliott> no you're not :)
00:26:01 <srhb> elliott: It's a lot slower without the ByteStrings.
00:26:22 <elliott> try rem instead of mod, anyway
00:26:26 <elliott> also
00:26:30 <elliott> you might need explicit type signatures
00:26:35 <elliott> although I think ByteString's stuff is specialised to Int anyway
00:26:49 <srhb> Not using `mod`, am I?
00:26:51 <elliott> erm
00:26:52 <frerich2> elliott: He seems to be using 'div', not 'mod'?
00:26:52 <srhb> I think not.
00:26:53 <elliott> quot instead of div
00:27:38 <srhb> Ah yes.
00:28:05 <srhb> That's actually slightly worse, funny.
00:28:11 <elliott> weird
00:28:23 <elliott> srhb: share the computationt hough
00:28:31 <elliott> zeroes n = m + zeroes m where m = n `div` 5
00:28:38 <elliott> CSE might catch it but it's conservative
00:28:40 <shachaf> elliott: What's not sequential there?
00:29:41 <elliott> shachaf: Well, readInt is probably more than a simple fold.
00:29:52 <elliott> I thought srhb was counting zeroes in the input, which was silly of me.
00:31:40 <srhb> I've heard that another way to go is read contents lazily and then chunkify it after, but that's way beyond me. :-) Perhaps this is as good as I can make it. Still a factor 10 worse than the best solution, which is surprising.
00:31:41 <srhb> (To me, at least)
00:32:16 <shachaf> If the input is large you could just switch to lazy ByteStrings.
00:32:43 <elliott> How large is the input?
00:32:56 <elliott> (and did you share the computation?)
00:33:05 <srhb> About hundred thousand lines.
00:33:10 <elliott> oh.
00:33:11 <srhb> Sorry, share what computation? The m?
00:33:13 <elliott> Yes.
00:33:19 * shachaf wouldn't even think that sharing the computation would make that big of a difference.
00:33:22 <shachaf> (But I have no idea, of course.)
00:33:23 <srhb> Yes, that seems to make no difference.
00:33:24 <elliott> Also, import .Lazy.Char8 instead like shachaf said.
00:33:31 <elliott> Guess CSE catches it then.
00:33:38 <srhb> Lazy is way worse.
00:33:39 <elliott> Or it's just too minor to have an effect.
00:33:54 <elliott> srhb: Can you use external packages in that SPOJ thing?
00:34:03 <srhb> I think not, no.
00:34:17 <elliott> Hmph.
00:34:41 <srhb> The code should run as is with Lazy bytestrings instead of Strict though, right?
00:34:42 <srhb> Trying it out.
00:35:19 <srhb> Okay, only slightly worse than the strict version. I suppose that would be the other way around with a bigger input.
00:35:34 <shachaf> Do you have a sample input file?
00:35:51 <srhb> Sadly no, only by description.
00:36:13 * hackagebot htrace 0.1 - Hierarchical tracing for debugging of lazy evaluation  http://hackage.haskell.org/package/htrace-0.1 (EugeneKirpichov)
00:36:18 <srhb> Which means I'm only checking the time by SPOJ's own time counter.
00:36:59 * elliott bets they're on ghc 6.8 without optimisations or something.
00:37:18 <srhb> I only know there;s about 100,000 lines of integers below one billion which I assume are randomly distributed.
00:37:23 <srhb> elliott: WOrse, I think. :-)
00:38:10 <srhb> I'm not too dissatisfied by my solution, just surprised that there's one 10 times better than mine.
00:38:10 <srhb> Ah no, 6.10.4
00:38:14 * frerich2 does a mental note to try htrace, it sounds really neat
00:38:52 <elliott> srhb: 10 times better in haskell, or in some other language/
00:38:55 <elliott> *?
00:39:00 <srhb> elliott: In Haskell
00:39:19 <elliott> odd
00:39:27 <elliott> probably using unboxed magic :)
00:39:48 <shachaf> srhb: How long is it taking for a file with 100000 lines?
00:39:50 <srhb> My solutions clocks in at 0.60 cpu time (no idea what that really means, to be honest :P) vs the best at 0.06 (same arbitrary scale)
00:40:23 <srhb> elliott: I agree on the magic part. :-)
00:40:32 <shachaf> It runs in 0.1 seconds here.
00:41:23 <srhb> I am satisfied - especially because there were no obvious improvements that I missed, apparently. :-)
00:41:57 <frerich2> srhb: I'm actualyl disappointed that the #haskell optimization phase didn't yield at least a 100% improvement!
00:42:26 <srhb> frerich2: Perhaps I;ve just magically improved to superstar level in a few days. I prefer believing this. :-)
00:46:06 <elliott> frerich2: Oh, I could optimise that.
00:46:09 <elliott> I'm just too lazy to :P
00:46:20 <elliott> It'd just involve #s everywhere.
00:46:52 <frerich2> elliott: "#" denotes unboxed values in Haskell? Is this a GHC-specific feature?
00:47:10 <elliott> GHC puts # after unboxed types and primops.
00:47:12 <elliott> It's the MagicHash extension.
00:47:28 <shachaf> "unboxed values" don't exist in Haskell.
00:47:49 <frerich2> shachaf: Ah, but values of an unboxed type do?
00:48:18 <shachaf> No.
00:48:22 <shachaf> It's all a GHC extension.
00:49:04 <elliott> Yeah.
00:49:11 <elliott> Haskell doesn't even define boxed types.
00:49:13 <elliott> It's just types.
00:49:20 <frerich2> Oh, ah yes of course. I thought you were picking at my nomenclature of saying "unboxed values".
00:56:49 <NothingMan65> How do I stop a list comprehension based on an infinite list depending on a condition?
00:56:54 <NothingMan65> [x | x <- [1..], x `mod` 5 == 0]
00:56:59 <NothingMan65> I want that to stop when it reaches 5
00:57:02 <NothingMan65> For example.
00:57:05 <NothingMan65> And only have 5 in the list
00:57:15 <NothingMan65> Or some other way which doesn't return a list
00:57:25 <shachaf> You don't use a list comprehension.
00:57:26 <srhb> NothingMan65: You'd have to use a takeWhile instead.
00:57:28 <shachaf> Use takeWhile.
00:57:47 <NothingMan65> so takeWhile on the infinite list? with a mod condition?
00:57:48 <trez> take 1 $ [x | x <- [1..], x `mod` 5 == 0]
00:58:05 <srhb> NothingMan65: Yes
00:58:14 <NothingMan65> and the laziness stops the execution when 1 is found, trez?
00:58:25 <srhb> NothingMan65: No, that solution doesn't really fix anything
00:58:29 <srhb> NothingMan65: It just takes one element.
00:58:44 <NothingMan65> Okay, it still continues list population after 5
00:58:50 <tsutto> heys guys; what are some good resources for learning in somewhat detail about how haskell/ghc work and/or about advanced type system features and stuff
00:59:35 <trez> NothingMan65: try it out. it should work
01:00:45 <NothingMan65> take 1 [x | x <- dropWhile (\y -> y `mod` 5 /= 0) [1..]]
01:01:00 <NothingMan65> Is ok?
01:01:09 <NothingMan65> I mean it works, but is it like, OK
01:01:13 * hackagebot hakyll 3.2.4.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.4.2 (JasperVanDerJeugt)
01:01:47 <srhb> I'd totally do [5,10..]
01:01:57 <srhb> But I'm guessing you have some kind of point.
01:03:27 <srhb> Or if you're trying to do the contrived example, something like takeWhile (<=5) $ filter ((==0) . flip mod 5) [1..]
01:03:35 <NothingMan65> well this finds the first prime factor of a number
01:03:36 <NothingMan65> take 1 [x | x <- dropWhile (\y -> n `mod` y /= 0) [2..]]
01:03:54 <NothingMan65> That was my goal.
01:03:58 <NothingMan65> Thanks a ton for the helpz
01:04:07 <NothingMan65> As usual, you guys/gals rock hard
01:04:14 <NothingMan65> Unlike pumice.
01:04:20 <srhb> Pumice does suck.
01:04:30 <NothingMan65> Blasphemy!! Pumice is holy!
01:04:36 <NothingMan65> *titter*
01:04:36 <srhb> (But only because it's so porous...)
01:05:21 <NothingMan65> Although, floating rocks are pretty cool.
01:21:14 * hackagebot hakyll 3.2.5.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.5.0 (JasperVanDerJeugt)
01:21:16 * hackagebot fclabels 1.1.0.2 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.0.2 (ErikHesselink)
01:25:26 <NothingMan65> Say, numDivisorsDecomp n =  (getDivisorsDecomp n)  returns [2,2,3,3]
01:25:43 <NothingMan65> Why do I get an error saying actual type is [[a0]] with: group (getDivisorsDecomp n)
01:26:04 <elliott> :t group
01:26:05 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
01:26:16 <elliott> Because you're using the return type of group as something other than [[a0]].
01:26:21 <elliott> Or, trying to, rather.
01:26:27 <elliott> The error isn't in numDivisorsDecomp.
01:26:37 <elliott> Oh, I see.
01:26:55 <elliott> NothingMan65: It's because getDivisorsDecomp :: [a], but group getDivisorsDecomp :: [[a]].
01:26:58 <elliott> The two definitions have different types.
01:27:08 <elliott> If you want to use the latter, you'll have to change the type signature (if any) and all the uses.
01:28:01 <NothingMan65> I thought group accepts a [a] and that's what getdivisorsDecomp is
01:28:33 <elliott> The problem isn't what you're giving it.
01:28:36 <elliott> The problem is how you're treating its result.
01:29:22 <NothingMan65> I'm so terrible at this (=
01:39:59 <fredmorcos> I'd like to write a translator as an exercise, takes format A as input and outputs format B (specifically FIG -> JSON). Should I go with Happy or Parsec?
01:40:18 <elliott> Probably Parsec.
01:40:30 <ketil> Hi!  I have a function that is kind of a partially defined bijection (i.e. it is f :: a -> Maybe b, f x == f y => x = y, and with inverse f' :: b -> Maybe a, also injective)  Is there a better name for that?
01:40:38 <elliott> Happy is faster but Parsec is nicer to use, especially when you're not working with a lexer. Also, it's a lot more popular.
01:40:47 <ketil> ...and how do I model this in Haskell? :-)
01:41:28 <fredmorcos> As I understand, Happy is analogous to Bison and Parsec is a library that will help me out, but more analogous to writing the parser manually. Is that correct?
01:41:40 <ketil> I guess a partial(ly defined) injective function is sufficient.
01:42:57 <danr> ketil: the terminology partial is a bit overloaded: in Haskell, functions that return bottom on some inputs can be regarded as partial, but your function only returns Nothing in these cases so in that respect your function is actually total
01:43:03 <elliott> fredmorcos: Yes, but you will probably find Parsec easier to write a parser in than Bison.
01:43:20 <elliott> fredmorcos: You do not really "write the parser yourself" -- it's a full, first-class "DSL".
01:43:40 <elliott> You can just also use the whole of Haskell from inside your parsers, too.
01:45:17 <danr> ketil: you could say that you have an isomorphism on a subset of the arguments (modulo Just constructors)
01:45:18 <fredmorcos> elliott: I already work with Bison, would that change the suggestion to use Parsec?
01:46:14 * hackagebot wai-middleware-catch 0.3.0 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.3.0 (AlexanderDorofeev)
01:46:20 <elliott> fredmorcos: Nope.
01:46:34 <fredmorcos> elliott: alright, thanks!
01:46:48 <elliott> I don't think many people use Happy these days unless they have a really good reason to (e.g. strong performance needs, really complex lexing, ...)
01:47:50 <Philippa> fredmorcos: Parsec's for LL parsing (up to LL(omega)), but expects you to annotate where it might need more than one token of lookahead
01:48:21 <elliott> (Although attoparsec doesn't.)
01:49:13 <Philippa> well yeah, and there's a pile of other related libs too, like polyparse
01:49:41 <elliott> ReadS!
01:49:46 <elliott> The epitome of parsing libraries.
01:51:14 * hackagebot wai-middleware-catch 0.3.1 - Wai error catching middleware  http://hackage.haskell.org/package/wai-middleware-catch-0.3.1 (AlexanderDorofeev)
01:53:26 <fredmorcos> Thanks guys, I think FIG is doable with at most 1 token of lookahead.
01:53:47 <fredmorcos> So I'll go with Parsec :)
02:06:15 * hackagebot persistent 0.7.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.7.0.1 (MichaelSnoyman)
02:13:52 <nh2> git keeps setting g+w permissions for my .ghci file on checkout. How do you people deal with that?
02:14:20 <nh2> of course it results in the WARNING: .ghci is writable by someone else, IGNORING! error
02:17:26 <dominikh> other than +x, git doesn't store any permissions, so it defaults to whatever umask is set I suppose. nh2 you could set up a post checkout hook to change the permissions of your .ghci file
02:18:16 <ketil> danr: Right, wrapping in Maybe makes it a total function, but loses injectivity.
02:18:52 <ketil> danr: How can I model this in Haskell, though?  E.g. [(a,b)] gives no guarantee that the a's and b's are unique.
02:18:58 * ketil has to think some more on this.
02:19:10 <nh2> dominikh: sounds good
02:20:18 <elliott> ketil: (a -> Maybe b, b -> Maybe a)
02:20:33 <elliott> I mean, bijections are just (a -> b, b -> a) and since haskell isn't a proof system you just have to not put invalid values in.
02:20:40 <elliott> (Use a data type, nota  tuple, though>0
02:20:42 <elliott> *though.)
02:22:09 <arcatan> maybe use a data type and only export functions that allow you to use valid values
02:23:35 <elliott> you'll need an unsafeFromTwoFunctions to get anything useful done :)
02:41:54 <hape01> As I learned the dyre package may relaunch a running haskell program after configuration has changed (It think that is an abstraction out of xmonad). On the other side I read about Lambdabot, which runs a a server, and which can relaunch plugins when the code bases changed, without stopping the server. That means, there is an dynamic reolad also, but in the latte case, the dynamic reload seems to be more granular - because reloading 
02:42:05 <hape01> running. Is this possible for dyre, too?
02:43:57 <donri> hape01: not sure if relevant but you might want to look into "cloud haskell"
02:44:09 <donri> which i think aims to bring erlang-like code hot swapping to haskell
02:44:16 <hape01> donri: What is cloud haskell? Is this a package?
02:44:40 <donri> http://www.haskell.org/haskellwiki/GHC/CloudAndHPCHaskell
02:44:41 <rtharper> https://github.com/jepst/CloudHaskell
02:44:53 <hape01> donri, rtharper: thank you both
02:44:57 <hape01> i will have a look
02:45:07 <rtharper> Cloud Haskell is definitely still evolving
02:45:35 <rtharper> The paper (linked from github) describes the interface desired, AFAIK it's still a work in progress, though
02:45:45 <hape01> ok
02:57:11 <ketil> Hm, I guess I'll just accept that, and hide the constructor to keep things sanitary.  Ideally, I'd like to restrict this in the type, but perhaps that's not possible.
02:57:32 <ketil> arcatan, (I guess that's what you suggest, right?)
02:58:11 <arcatan> yeah
03:02:34 <adimit> terminfo has repeatedly barfed on me. GHC usually chokes with Loading package terminfo-0.3.2.2 ... can't load .so/.DLL for: ncursesw (/usr/lib/x86_64-linux-gnu/libncursesw.so: file too short), and said file contains only the line: INPUT(libncursesw.so.5 -ltinfo) — can I fix this somehow for good?
03:04:41 <ClaudiusMaximus> hooray! +++ OK, passed 100 tests.
03:06:22 <ClaudiusMaximus> criterion sure pulls in a lot of deps...
03:12:04 <_Mikey> Hey guys
03:12:28 <_Mikey> I'm writing a program which is going to calculate stuff in parallel.
03:12:47 <_Mikey> do I need to understand Monads to pull it off?
03:12:59 <ClaudiusMaximus> don't think so
03:13:04 <ClaudiusMaximus> @hoogle parMap
03:13:04 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
03:13:50 * mjrosenb has never noticed an advantage from using parMap :(
03:13:50 <ClaudiusMaximus> @hackage repa
03:13:50 <lambdabot> http://hackage.haskell.org/package/repa
03:14:55 <_Mikey> sounds awesome ClaudiusMaximus
03:14:59 <_Mikey> thanks.
03:15:58 <_Mikey> automatic :)
03:16:19 <_Mikey> cool I'll check them both out.
03:20:27 <roconnor> @hoogle Any
03:20:28 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
03:20:28 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
03:20:28 <lambdabot> Data.Monoid Any :: Bool -> Any
03:26:31 <_Mikey> > 1+1
03:26:32 <lambdabot>   2
03:26:56 <_Mikey> > [6,12..6^2]
03:26:57 <lambdabot>   [6,12,18,24,30,36]
03:27:05 <_Mikey> sweet!
03:28:06 <_Mikey> > [38..42]
03:28:06 <lambdabot>   [38,39,40,41,42]
03:31:50 <ClaudiusMaximus> \o/ criterion tells me around 2.2x speedup by implementing dd arithmetic in haskell instead of calling out to libqd, and the quickcheck tests verify that the output matches :)
03:32:15 <ClaudiusMaximus> and if i add -funbox-strict-fields i get another 10% more fasts
03:33:10 <_Mikey> ClaudiusMaximus,  nice!!
03:35:01 <chip2n> q
03:53:45 <_Mikey> Is the data driven approach the norm for Haskell development?
03:57:08 <MaskRay> Is there any function with type signature (a->b,a->b) -> (b->c,b->c) -> (a->c,a->c) ?
03:58:09 <_Mikey> @hoogle (a->b,a->b) -> (b->c,b->c) -> (a->c,a->c)
03:58:09 <lambdabot> No results found
03:58:17 <_Mikey> apparently not on google.
03:58:22 <_Mikey> *hoogle
03:59:39 <MaskRay> maybe i need to define an Arrow instance by myself
04:00:24 <ClaudiusMaximus> :t (>>>)***(>>>)
04:00:25 <lambdabot> forall (cat :: * -> * -> *) a b c (cat1 :: * -> * -> *) a1 b1 c1. (Control.Category.Category cat, Control.Category.Category cat1) => (cat a b, cat1 a1 b1) -> (cat b c -> cat a c, cat1 b1 c1 -> cat1
04:00:25 <lambdabot> a1 c1)
04:01:25 <MaskRay> ClaudiusMaximus: thanks
04:06:07 <MaskRay> any elegant implement of preorder-postorder-eulerian-path tree traversal algorithm?
04:07:37 <sopvop> So, there is mapAccumL, but I need kind of filterAccum for list. Should be something to do with fold, but can't figure that out.
04:08:04 <MaskRay> looking forwad to an approach without ST Monad
04:08:36 <MaskRay> s/forwad/forward/
04:09:08 <arslen> ive got no experience what so ever regarding programming, a friend recomended me haskell to get things rolling, do you agree or is there some "better" way?
04:09:46 <mreh> how do you declare an alias that just defines a context for some polymorphic type?
04:10:01 <mreh> i don't want to write out the whole context every time
04:10:26 <osfameron> arslen: it's worth a try, especially if you have a friend who is willing to give you some help.  Try http://learnyouahaskell.com/
04:10:56 <osfameron> arslen: there are very good online resources for other languages too (javascript, python, ruby in particular, recently)
04:11:08 <sopvop> mreh maybe make empty class with all the context, and then use it as context
04:11:16 <mreh> sopvop: have a cookie
04:11:33 <mreh> i just remember some place that does it, but you beat me to it
04:11:55 <arslen> thanks, ill check the link
04:12:06 <ClaudiusMaximus> mreh: http://hackage.haskell.org/packages/archive/diagrams-core/0.4/doc/html/src/Graphics-Rendering-Diagrams-Transform.html#HasLinearMap
04:13:04 <mreh> doesn't this mean i have to use undecidable types?
04:13:13 <ClaudiusMaximus> i fear so (but i'm no expert...)
04:13:43 <mreh> > "n" ++ cycle "o"
04:13:44 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
04:15:03 <mreh> ah.. fudge, i can't just make a class, the type in question is in fact a compound type, one datatype inhertis a long class name, and the other type another long class name
04:15:29 <shachaf> mreh: In GHC 7.4 you can make constraint aliases.
04:15:35 <mreh> LongClassName in, LongClassName2 out => Object = ABC in out
04:15:48 <mreh> that sounds nice
04:15:58 <shachaf> You can do all sorts of neat things with constraints, in fact.
04:17:26 <mreh> it's either do something like this, or use records that share the same fields
04:17:36 <mreh> the typeclass way seems to be more tasteful
04:17:42 <mreh> more guarantees
04:17:59 <mreh> what happens if you reference a field in a datatype that doesn't exist for that contructor? runtime error?
04:18:12 <mreh> and you have to maintain one massive datatype definition
04:18:16 <mreh> in one file
04:25:31 <mm_freak> > 'n' : repeat 'o'
04:25:31 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
04:27:17 <mreh> > 'n' : fix ('o':)
04:27:18 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
04:28:22 <mreh> lambdabot has a bug
04:28:28 <mreh> those should be equal to bottom
04:28:36 <Axman6> eh?
04:29:00 <mm_freak> > fix (\r c -> c : r 'o') 'n'
04:29:00 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
04:29:09 <mreh> > "they're" ++ cycle " infinite"
04:29:11 <lambdabot>   "they're infinite infinite infinite infinite infinite infinite infinite inf...
04:29:19 <Axman6> so?
04:29:30 <donri> > head [1..]
04:29:30 <lambdabot>   1
04:29:33 <Axman6> doesn't mean they shouldn't be able to produce useful results
04:29:41 <mreh> that's fine
04:30:10 <mreh> i understand the pedagogical merit
04:30:31 <donri> > last [1..]
04:30:35 <lambdabot>   mueval-core: Time limit exceeded
04:30:41 <mreh> i was merely quipping
04:30:57 <shachaf> Quipping?
04:31:18 <shachaf> _ : _ should never "be equal to bottom"
04:31:27 <mreh> @wn quip
04:31:27 <mreh> @botsnack
04:31:28 <lambdabot> *** "quip" wn "WordNet (r) 3.0 (2006)"
04:31:28 <lambdabot> quip
04:31:28 <lambdabot>     n 1: a witty saying [syn: {epigram}, {quip}]
04:31:28 <lambdabot>     2: witty remark [syn: {wisecrack}, {crack}, {sally}, {quip}]
04:31:28 <lambdabot>     v 1: make jokes or quips; "The students were gagging during
04:31:30 <lambdabot>          dinner" [syn: {gag}, {quip}]
04:31:33 <lambdabot> :)
04:34:18 <_Mikey> @hoogle (a->b) -> [a] -> b [c]
04:34:18 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
04:34:18 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
04:34:18 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
04:34:28 <_Mikey> @hoogle (a->b) -> [a] -> b -> [c]
04:34:28 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:34:28 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
04:34:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:36:30 <mm_freak> _Mikey: those type signatures don't make much sense
04:39:39 <alang> @hoogle (a -> b -> a) -> (c -> b) -> (a -> c -> a)
04:39:39 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:39:40 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:39:40 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:42:34 <alang> :t curry . (. second (snd)) . uncurry
04:42:35 <lambdabot> forall c a a1 b. (a1 -> b -> c) -> a1 -> (a, b) -> c
04:46:24 * hackagebot numtype-tf 0.1 - Type-level (low cardinality) integers, implemented  using type families.  http://hackage.haskell.org/package/numtype-tf-0.1 (BjornBuckwalter)
04:46:26 * hackagebot clua 0.1 - C to Lua data wrapper generator  http://hackage.haskell.org/package/clua-0.1 (TomSchouten)
04:51:24 * hackagebot clua 0.2 - C to Lua data wrapper generator  http://hackage.haskell.org/package/clua-0.2 (TomSchouten)
04:56:35 <ville> that's a quicker update interval than firefox and that's saying something!
05:02:35 <Entroacceptor> he, 0.3 is a bit late ;)
05:06:19 <ChristianS> 0.2 is a long-term release -- supported for 20 minutes
05:06:40 <ion> hah
05:24:13 <mobile> hi, login from iPad2
05:24:31 <donri> sent from my iPhone
05:25:18 <mobile> irssi looks cool
05:26:59 <everythingWorks> Im currently trying to install Haskell (-plugin) for Eclipse. Unfortunately, it fails updating "buildwrapper.exe" and "scion-browser.exe".
05:27:11 <funktronic> mobile: excellent, do yo uwant t a cooki ?
05:27:21 <everythingWorks> The whole log can be found here: http://codepad.org/KPipewRF
05:27:49 <everythingWorks> As im new to haskell, im not sure what it actually means :/
05:30:30 <funktronic> everythingWorks: "cabal.exe: permission denied"
05:35:31 <frerich2> Does anybody have a lambdabot binary which runs on Windows? I'd like to run the bot, but I don't have access to a unix machine which has the haskell platform installed.
05:35:55 <shachaf> I doubt it.
05:36:03 <hpc> frerich2: you can install the platform on windows and compile it there?
05:36:19 <frerich2> hpc: I did try, but various things of lambdabot (brainfuck, lambdabot itself, readline) depend on the unix package.
05:36:29 <hpc> ah
05:36:31 <everythingWorks> funktronic: thanks, i'll check..
05:36:40 <joe9> #idris is picking up interest. for anyone interested in using dependent types for general purpose programming.
05:36:49 <hpc> frerich2: you could always use a VM
05:37:37 <frerich2> hpc: True
05:42:31 <everythingWorks> What exactly is the cabal.exe?
05:42:53 <everythingWorks> Is it something like the "package manager" / "database administrator" for haskell? :D
05:43:04 <bartavelle> package manager
05:43:51 <dcoutts> everythingWorks: like autoconf + make + half of a package manager
05:43:51 <hpc> everythingWorks: it's like cpan, or gem, or apt-get, or yum, or...
05:44:15 <bartavelle> true, it is also autoconf + make
05:44:21 <donri> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
05:45:33 <dcoutts> donri: iirc, the summary of that post is that it's not a package manager because it cannot uninstall packages
05:45:46 <dcoutts> which is a fair point
05:45:54 <donri> it doesn't handle external dependencies either
05:45:54 <ChristianS> frerich2: you can also  /query lambdabot  , if you just want to talk to her without disturbing the channel
05:45:57 <dcoutts> hence my "half of a package manager" description :-)
05:46:13 <dcoutts> donri: right, it notices them but cannot automatically install them
05:46:27 <everythingWorks> hpc++dcoutts: thanks :D
05:46:36 <cmccann> unfortunately cabal looks just enough like a package manager to trick some linux users into thinking it will do much more than it's intended to do
05:46:49 <dcoutts> cmccann: yeah
05:47:03 <dcoutts> e.g. I don't think cpan or gems handle C lib deps
05:47:14 <donri> in deed
05:47:33 <_Mikey> is gems a ruby thing?
05:47:33 <cmccann> I recall that at first I expected cabal to handle things like uninstalling and upgrading installed packages (hahaha)
05:47:45 <donri> rubygems, yes
05:47:59 <Saizan> well, upgrading it can, just not with cabal upgrade :)
05:48:01 <_Mikey> donri, cool makes sense I gues
05:48:55 <dcoutts> cmccann: that's the other thing that confuses people, that upgrading involves just installing an extra version, rather than uninstalling the older version
05:49:36 <cmccann> dcoutts, yeah, took me a while to get used to that
05:53:29 <Oxryly> can someone help me with pretty printing this type of data structure: http://pastebin.com/vpi3Bgng?
05:53:31 <mauke> The paste vpi3Bgng has been copied to http://hpaste.org/56961
05:54:15 <Oxryly> ah, hpaste.. that seems better
05:54:57 <frerich2> ChristianS : Oh yes, I do that already (it's very convenient). However, as part of my plan to slowly tease a few colleagues to try Haskell, I wanted to bring lambdabot onto our internal IRC channel.
05:55:30 <frerich2> ChristianS: Just for tinkering a bit, and doing '> cycle "ohmygod"' every now and then.
05:55:58 <ChristianS> sounds like a great plan :-)
05:59:31 <argiopeweb> Has anyone here had an experience with a signal (sigPIPE, specifically) not getting caught even though the proper handler was set to SIG_IGN?
05:59:36 <derpladee> @hoogle **
05:59:36 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
05:59:36 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:59:37 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
06:01:34 <keep_learning> hello all
06:01:49 <argiopeweb>  'Morning.
06:02:11 <keep_learning> I am working on project  in which we are distributing the all the .hi and .o files ( no source code ).
06:03:09 <keep_learning> All these file will be /lib directory.
06:03:40 <keep_learning> If some one wants to export any module to his code , how can he take it from /lib directory on fly.
06:04:08 <keep_learning> One idea to keep all the code in same directory and ghc --make will get all the files
06:04:25 <keep_learning> Any idea ?
06:04:36 <argiopeweb> keep_learning: I assume you've considered the fact that .o files are highly platform specific, yes?
06:04:46 <keep_learning> argiopeweb,
06:04:49 <keep_learning> argiopeweb, yes
06:06:19 <argiopeweb> keep_learning: Well, bearing that in mind, I believe you'll need to have the hi files at least local, unless possibly you can do absolute paths with a .cabal file. I'd have to play with it.
06:06:21 <keep_learning> Its like using our modules for /lib directory and  when he compiles his code using ghc -make , it should take required modules from /lib
06:06:57 <argiopeweb> keep_learning: Wouldn't it be easier just to create a library?
06:08:06 <keep_learning> argiopeweb, yes but it is possible to import modules form that library to custom code without source code ?
06:08:28 <keep_learning> argiopeweb, the issue here is don't distribute source code :(
06:10:43 <everythingWorks> Is there a haskell community/forum where i can ask my questions? :D
06:10:46 <argiopeweb> keep_learning: Library -> C Bindings -> Haskell wrapper which you can cabal install.
06:11:00 <argiopeweb> everythingWorks: This is it. And the mailing list.
06:11:10 <ClaudiusMaximus> hm, can't figure out how to write instance Unbox MyType even though the docs say it is very easy :(
06:11:32 <ClaudiusMaximus> the example is incomplete and i can't seem to find the full source... http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Unboxed.html
06:11:46 <argiopeweb> keep_learning: Or is it an issue with distributing any source code as opposed to proprietary source code?
06:13:53 <everythingWorks> Im trying to use the Eclipse plugin for haskell. Ive loaded the eclipse plugin and installed haskell.  Problem:  buildwrapper.exe and scion-browser.exe cannot be found! :O Where are those?
06:15:37 <argiopeweb> everythingWorks: Can't speak for buildwrapper, but you should be able to cabal install scion-browser from the command line.
06:16:42 <statusfailed> Oh noo, I think I need monad transformers D:
06:16:55 <argiopeweb> everythingWorks:  Appears that buildwrapper is on hackage as well, so it gets cabal installed too.
06:17:38 <everythingWorks> kk
06:18:01 <keep_learning> argiopeweb, its like our project manager just don't want to distribute the source code of software we are developing.
06:18:39 <keep_learning> argiopeweb, he just wants to distribute it in such a way that it works fine and if some one want to write his customise code
06:19:00 <keep_learning> using our software then  user gets enough support.
06:19:30 <keep_learning> one way is giving him source code and he can simply compile ghc --make
06:20:08 <keep_learning> or giving all the .hi and .o codes in /lib directory from where his custom will export the modules
06:20:40 <statusfailed> I'm trying to write a function of type "Data.Set (ParserT s u m a) -> ParserT s u m a" which applies the set of parsers in any order, and returns a parser
06:21:10 <dmwit> There's a function for that.
06:21:16 <statusfailed> you mean "choice"?
06:21:18 <statusfailed> that only does one
06:21:22 <dmwit> No, I don't.
06:21:25 <statusfailed> oh
06:21:30 <statusfailed> what is it?
06:21:34 <dmwit> It's called something weird, like "permutation" or something.
06:21:53 <statusfailed> i'll hoogle it!
06:22:02 <dmwit> ?hoogle [ParserT s u m a] -> ParserT s u m a
06:22:02 <lambdabot> Warning: Unknown type ParserT
06:22:02 <lambdabot> No results found
06:22:06 <keep_learning> @hoogle "Data.Set (ParserT s u m a) -> ParserT s u m a
06:22:06 <lambdabot> Parse error:
06:22:06 <lambdabot>   "Data.Set (ParserT s u m a) -> ParserT s u m a
06:22:06 <lambdabot>   ^
06:22:11 <keep_learning> @hoogle Data.Set (ParserT s u m a) -> ParserT s u m a
06:22:11 <lambdabot> Parse error:
06:22:11 <lambdabot>   Data.Set (ParserT s u m a) -> ParserT s u m a
06:22:11 <lambdabot>       ^
06:22:18 <dmwit> statusfailed: When hoogling, the type will probably use [] instead of Set.
06:22:55 <statusfailed> dmwit: Ok. doesn't appear to be showing up though :(
06:23:17 <_Mikey> Does anyone use the Data.Graph library here?
06:24:01 <argiopeweb> keep_learning: I can't see distribution of .o/.hi pairs to be anything but fraught with peril. YMMV.
06:24:08 <statusfailed> dmwit: Is this it? http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Perm.html
06:24:39 <dmwit> That looks right, yes.
06:24:55 <dmwit> What did you mean by "'choice' only does one"?
06:25:09 <statusfailed> choice picks any of the parsers and gives you the one it used
06:25:19 <statusfailed> I want a function to do all of the parsers, but in any order
06:25:20 <dmwit> What else can you do with that type?
06:25:36 <dmwit> Did you mean the return type to be something like ParserT s u m [a], then?
06:25:52 <statusfailed> ooh, awkward. I guess so
06:26:09 <statusfailed> it probably would've helped to find out what the s u m a parameters are
06:27:50 <PDani> hi
06:27:57 <argiopeweb> keep_learning: Based on the fact that (to the best of my knowledge) --make figures out package dependencies without access to source code, distribution of libraries (.a and/or .so) would be sufficient.
06:29:37 <PDani> i just can't figure out how can i define a function with "where" using let inside a do notation
06:30:17 <statusfailed> PDani: can you paste what you have now?
07:09:29 <statusfailed> Hmm, i'm having a lot of trouble figuring out the "permute" function here: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Perm.html#t:StreamPermParser
07:09:46 <statusfailed> oops, here:
07:09:47 <statusfailed> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Perm.html
07:10:19 <statusfailed> I don't understand why that "tuple" function needs to be declared
07:10:58 <rostayob> statusfailed: because there is no such pre-defined function?
07:11:01 <danr> statusfailed: could have been written (,,) instead
07:11:17 <rostayob> well right, (,,)
07:11:18 <statusfailed> sorry, I meant more why there needs to be any function there at all
07:11:40 <statusfailed> it's not just combining the parsers into a single parser
07:11:45 <rostayob> statusfailed: look at the type sig for <$?>)
07:13:31 <statusfailed> still a bit confused, but that helped a bit :P
07:13:42 <rostayob> statusfailed: maybe it'd help to put parens
07:13:49 <rostayob> in that expression with the operators
07:13:56 <rostayob> and work out the type manually
07:14:04 <startling> is there a way, given a function, list, and integer n, to return the list with the function applied to the nth item?
07:14:28 <startling> sort of like `map` but with a narrower aim
07:14:43 <rostayob> startling: map f . take n
07:14:51 <rostayob> ah then you want the rest
07:14:55 <startling> yeah
07:14:58 --- mode: anthony.freenode.net set +o ChanServ
07:15:10 <byorgey> rostayob: I don't think that does what startling said.
07:15:25 <rostayob> byorgey: yeah I realised afterwards :)
07:15:28 <startling> rostayob: yeah, doesn't that apply the function to the first n items?
07:15:30 <rostayob> startling: check 'splitAt'
07:15:46 <startling> @src splitAt
07:15:47 <byorgey> startling: there's no easy way to do it.  Lists are not designed for random access.
07:16:20 <rostayob> startling: let (l, r) = splitAt n xs in map f l ++ r
07:16:22 <rostayob> if I understand what you're asking
07:16:48 <byorgey> rostayob: startling said "with the function applied to the nth item", not "to the first n items"
07:17:05 <rostayob> byorgey: yeah I read that as "up to the nth item"
07:17:22 <byorgey> let (l, (x:r)) = splitAt n xs in l ++ [f x] ++ r
07:17:27 <rostayob> startling: do you want to apply the function *just* to the nth item?
07:17:32 <startling> rostayob: yeah
07:17:48 <byorgey> startling: however, probably you should either (a) use a different data structure, or (b) rethink your algorithm
07:17:56 <rostayob> oh. then what byorgey said, but please note that the function you're asking to is partial and inefficient
07:18:01 <byorgey> startling: can you give us an idea of why you want to do this?
07:18:24 <Eduard_Munteanu> (!!) is just as bad, for the same reasons.
07:19:07 <startling> I'm writing a little language with a stack of namespaces. It would be cool if a program could explicitly say which namespace to assign an item in.
07:19:30 <ChristianS> Data.Sequence.Seq maybe?
07:20:27 <byorgey> well, if the stack never gets too big doing it with a list shouldn't be a big deal efficiency-wise.
07:20:50 <byorgey> but you do still have to be careful about indexing errors, i.e. if the program references a namespace that doesn't exist
07:21:37 <ChristianS> adjust :: (a -> a) -> Int -> Seq a -> Seq a : O(log(min(i,n-i))). Update the element at the specified position. If the position is out of range, the original sequence is returned.
07:22:03 <startling> Yeah it looks like I'll need to rethink my choice of data structures. Data.Sequence.Seq looks good, thanks.
07:33:59 <CodeWeaver> Okay, here's one.  How do I go about tweaking the build properties of a package that cabal builds where the build is somewhat broken?  I've got stream-fusion apparently building with a flag GHC 7.2.2 doesn't recognize.
07:46:21 <startling> what higher-order functions other than `flip` exist for rearranging arguments?
07:47:48 <parcs`> @pl \f a b c d e -> f e d c b a
07:47:59 <parcs`> startling: (.)
07:48:01 <parcs`> (.) and fli
07:48:02 <parcs`> p
07:48:23 <startling> yeah I guess I just have to use lambdas. Thanks anyway
07:49:13 <parcs`> no you don't
07:49:45 <byorgey> but you should.
07:50:14 <CodeWeaver> grarg.
07:53:33 <byorgey> CodeWeaver: use 'cabal unpack <package>' to get the source, then edit the .cabal file
07:53:48 <byorgey> CodeWeaver: be sure to increment the version number of the package slightly
07:54:07 <byorgey> then just 'cabal install' in the directory with the .cabal file
07:54:21 <CodeWeaver> byorgey!  Excellent!  Where will the .cabal file end up?  In ~/.cabal somewhere?
07:54:44 <byorgey> no, if 'cabal unpack foo' will create a directory like  foo-7.6.3
07:54:48 <CodeWeaver> Got it.
07:54:52 <byorgey> the .cabal file will be in there, along with the rest of the package source
07:55:09 <CodeWeaver> Trying now. :D
07:56:30 <danr> Is there any "first" paper describing HOAS?
07:58:04 <CodeWeaver> Oh very nice byorgey.  I was having trouble finding good documentation on typical cabal hackery and maintenance.
08:15:10 <lukish> @index liftM2
08:48:48 <bertolo> hi :> its me again, the dude with problems in his homework (jk)
08:48:51 <bertolo> resultParc :: (a->b)->[a]->(a->Bool)->[b]
08:49:05 <bertolo> i recieve a function , one list and one condition
08:49:43 <bertolo> the output is a filtered list after applying a fuction to it
08:49:47 <bertolo> i did this: resultParc f a c = filter c (map f a)
08:49:51 <bertolo> but hugs is telling me
08:49:53 <CodeWeaver> Looks like you are receiving three parameters, not two.
08:50:17 <bertolo> i recieve a fuction, a list and a condition
08:50:19 <bertolo> yes
08:50:19 <CodeWeaver> Oh I see.  My bad.
08:50:20 <CodeWeaver> Got it.
08:50:22 <bertolo> *** Expression    : resultParc
08:50:23 <bertolo> *** Expected type : (a -> b) -> [a] -> (a -> Bool) -> [a]
08:50:23 <bertolo> *** Inferred type : (a -> a) -> [a] -> (a -> Bool) -> [a]
08:50:24 <bertolo> i got this
08:50:42 <bertolo> and im like :S
08:51:04 <bertolo> actually im recieving this
08:51:05 <bertolo> *** Expression    : resultParc
08:51:05 <bertolo> *** Expected type : (a -> b) -> [a] -> (a -> Bool) -> [a]
08:51:05 <bertolo> *** Inferred type : (a -> a) -> [a] -> (a -> Bool) -> [a]
08:51:07 <bertolo> ops
08:51:12 <bertolo> you got it
08:51:56 <CodeWeaver> Which is funny cause your prototype is neither of those, although the second is what results when a and b happen to be the same.
08:52:00 <bertolo> yes
08:52:01 <bertolo> lol
08:52:09 <bertolo> *** Expression    : resultParc
08:52:10 <bertolo> *** Expected type : (a -> b) -> [a] -> (a -> Bool) -> [b]
08:52:10 <bertolo> *** Inferred type : (a -> a) -> [a] -> (a -> Bool) -> [a]
08:52:11 <bertolo> real one
08:52:19 <bertolo> my problem is the (a->b)
08:52:47 <bertolo> since im using map, i dont think the output type should be in a different type
08:52:51 <CodeWeaver> I presume the function you're passing in is actually of type (a->a)
08:53:06 <bertolo> shoulnt it be?
08:53:15 <bertolo> im using map
08:53:30 <CodeWeaver> Well, it can be.  You've got (a->b) in the prototype, but that's fine, if a and b happen to be the same.
08:54:25 <CodeWeaver> (I'm not so practiced at this… brighter people will be by momentarily)
08:54:31 <CodeWeaver> (in the meantime I'm looking at it)
08:55:59 <danr> bertolo: try (b -> Bool)
08:56:14 <danr> after the map, you have a list of b:s, so that's what you are filtering
08:56:19 <CodeWeaver> Okay… so the map takes a function (a->b), so generally b and a don't need to be the same.  This means…. yah
08:56:23 <CodeWeaver> Darn you danr, I was nearly there.
08:56:24 <CodeWeaver> :D
08:56:35 <danr> CodeWeaver: ouch, sorry
08:56:38 <CodeWeaver> Hahahahahaha
08:56:51 <CodeWeaver> No worries.  :D  I'm a bit of a newb here.
08:57:40 <CodeWeaver> Yah, so map produces [b] in the general sense, which goes into filter, which has to take a b and produce a bool, because it's processing b's, not a's, in the general sense.
08:57:55 <CodeWeaver> On *usage* of the function, a and b can be the same, but your function can't assume that.
08:58:18 <CodeWeaver> well, unless you make all the b's a's.
08:58:29 <CodeWeaver> Which would be unnecessary.  Danr has it right.
08:58:38 <shergill> danr: or perhaps, filter first and then apply a map?
08:58:56 <CodeWeaver> Oh, good variant.
08:59:56 <CodeWeaver> Especially since that means if the map function is costly to do a transform of all the elements, you're doing fewer of them if the filter's first.
09:00:09 <danr> shergill: if that's what you want, sure
09:00:13 <shergill> yeah
09:00:20 <NothingMan65> How should I fold over a string to operate on to extract each digit to its own integer? Fine people.
09:00:41 <danr> NothingMan65: do you mean map read?
09:00:48 <danr> map (read . pure) i guess
09:00:50 <hpc> NothingMan65: do you want "123" => [1, 2, 3] or [123]?
09:00:57 <danr> or map digitToInt
09:01:06 <NothingMan65> Ah! Digit to int
09:01:08 <NothingMan65> Thank you
09:01:11 <hpc> or if you want the latter, map read . words
09:01:22 <NothingMan65> danr, hpc, thanks.
09:01:50 <hpc> @src digitToInt
09:02:02 <hpc> D:
09:03:19 <ion> > digitToInt 'g' -- :-(
09:04:29 <applicative> bertolo: what are you doing to get this error?  are you supplying a signature to resultParc or using resultParc
09:04:29 <eyebloom> @hoogle $=
09:04:48 <eyebloom> @hoogle $=
09:05:02 <hpc> eyebloom: look in opengl
09:05:20 <bertolo> darn i cant change the fuction header
09:05:35 <eyebloom> Haven't been able to find it with goog or hoog
09:05:56 <Sgeo> eyebloom, it's in enumerator or conduit
09:05:58 <rostayob> eyebloom: look at enumerator
09:05:59 <rostayob> s
09:06:02 <rostayob> Sgeo: damn
09:06:04 <applicative> its in enumerator too
09:06:20 <rostayob> 1 second!
09:06:21 <rostayob> man
09:06:25 <Sgeo> =P
09:09:05 <statusfailed> ok, really dumb question
09:09:12 <statusfailed> how do I modify the field of a "data" object?
09:09:14 <statusfailed> a field*
09:09:44 <Sgeo> data MyData = MyData Int String
09:09:55 <statusfailed> e.g. data Person = Person {name :: String, age :: Int}
09:09:56 <statusfailed> oh
09:09:57 <Sgeo> changeString :: Int -> MyData -> MyData
09:10:08 <Sgeo> Wait, that makes no sense
09:10:15 <Sgeo> statusfailed, oh, recordsa?
09:10:17 <Sgeo> *records?
09:10:19 <statusfailed> yeah sorry
09:10:32 <nyingen> p { age = 31 } will make a new record based on p, with all fields  the same except the age
09:10:37 <statusfailed> ah, brilliant
09:10:40 <CodeWeaver> Only works if the fields are named.
09:10:40 <Sgeo> let newPerson = oldPerson { name="newname" }
09:10:41 <applicative> if you have a person arthur you do arthur{name=45}
09:10:47 <statusfailed> I cannot believe I've never used this before
09:10:50 <CodeWeaver> Also keep in mind that it *does* rebuild the whole object.
09:11:08 <CodeWeaver> It's just shorthand for copying all the fields except the ones you specify.
09:11:12 <statusfailed> CodeWeaver: sure, it's the only way right?
09:11:18 <statusfailed> oh wait
09:11:22 <CodeWeaver> For pure data, yes.  As data is not mutatable.
09:11:25 <statusfailed> you mean it doesn't do any funky pointer stuff
09:11:43 <CodeWeaver> well, every field is likely to be a pointer to a boxed data item.
09:11:49 <CodeWeaver> internally.
09:11:51 <statusfailed> ok, yeah.
09:11:53 <statusfailed> that's cool
09:12:08 <CodeWeaver> But you can't actually *know* that, and shouldn't care, except where performance might be concerned.
09:12:24 <Sgeo> Lenses are pretty cool
09:12:33 <Sgeo> http://hackage.haskell.org/package/data-lens
09:12:36 <CodeWeaver> It doesn't, in a pure data environment, matter if a real value is copied, or a reference to an existing one is copied, as none of it can be changed.  You can just rebuild.
09:12:41 <statusfailed> I've used them in Snap but I don't really get them :D
09:13:13 <Sgeo> setL name "Newname" oldPerson
09:13:31 <CodeWeaver> Okay, okay, in the absence of some clever package like Sgeo is pointing to. :D
09:13:46 <Sgeo> CodeWeaver, I think with lenses it's still rebuilding
09:13:53 <donri> here's some docs for lenses http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
09:13:53 <CodeWeaver> Maybe.
09:14:03 <Sgeo> It's just nicer to use lenses than record syntax
09:14:15 <djanatyn> hey, quick question.
09:14:16 <CodeWeaver> Maybe. I got really used to record syntax. :D
09:14:37 <Sgeo> Especially since lenses work with more than records
09:15:35 <djanatyn> > read "(\\x -> x * 2)" :: Int -> Intnt -> Int
09:15:35 <djanatyn> is that even possible?
09:15:49 <djanatyn> errrrrrm.
09:15:54 <djanatyn> didn't mean to type that.
09:16:06 <djanatyn> > read "(\\x -> x * 2)" :: (Int -> Int)
09:16:13 <djanatyn> can I do something like that?
09:16:15 <donri> @instances Read
09:16:25 <c_wraith> No, that's not possible
09:16:27 <Veinor> it's possible with some ghc hackery, but you really don't want to do it
09:16:27 <djanatyn> I'm trying to have the user input a lambda and use it in my code
09:16:32 <djanatyn> aww. any alternatives?
09:16:35 <byorgey> sure it's possible.
09:16:37 <c_wraith> the hint library
09:16:43 <Veinor> oh well
09:16:45 <byorgey> but there's no Read instance for functions built in.
09:16:46 <Veinor> you can use hint, yeah
09:17:26 <c_wraith> byorgey: any read implementation for -> will end up needing to be a full interpreter
09:17:37 * cmccann creates a Read instance for "IO ()" that passes the input to GHC and returns an action that executes the resulting binary
09:18:21 <hpc> cmccann: you could also use hint
09:18:29 <byorgey> c_wraith: not necessarily.  You can restrict what sorts of expressions you are willing to accept.
09:18:29 <CodeWeaver> Great googly moogly, I made the mistake of starting to read about template haskell.  I haven't gotten my brain wrapped around all the various bits of regular haskell yet!
09:18:32 <CodeWeaver> DOOM
09:18:40 <byorgey> c_wraith: but perhaps you are arguing that in that case it does not deserve to be a Read instance
09:18:46 <c_wraith> byorgey: ok, then you can get away with a limited interpreter. :)
09:18:46 <hpc> CodeWeaver: +1 for saying "great googly moogly"
09:18:53 <CodeWeaver> :D
09:19:00 <hpc> -1 for trying to learn TH at all ;)
09:19:06 <CodeWeaver> Hey now.
09:19:08 <CodeWeaver> :D
09:19:31 <CodeWeaver> Actually this seems kinda cool.  If used sparingly.
09:19:38 <byorgey> indeed.
09:20:00 <byorgey> TH is cool but poorly documented.
09:20:15 <CodeWeaver> Well, I feel that way about most of Haskell packages to be honest.
09:20:37 <c_wraith> after about the 8th time through it, you realize everything in TH *is* documented, but it's so opaque as to be nearly useless unless you already know it and just need a reminder.
09:21:01 <byorgey> that's what I mean by poorly documented.
09:21:05 <CodeWeaver> Well, I thought I'd start by reading the original paper.  The basic idea's pretty straightforward.
09:22:01 <cmccann> most of the TH stuff is pretty primitive anyway, there's not a lot to document anyway
09:22:02 <CodeWeaver> That could be the sound of the oncoming train of "it seems straightforward because you don't really know what you're doing"
09:22:19 <cmccann> you can reify stuff, mangle ASTs, return splices, &c.
09:22:44 <cmccann> not much needs saying there, except for "how do I actually do anything useful without wanting to stab myself in the face"
09:22:57 <CodeWeaver> Once again, I sometimes feel that way about basic haskell packages.
09:22:58 <CodeWeaver> ;)
09:23:20 <hpc> i feel that way about agda
09:23:39 <hpc> mostly because i don't even know all the syntax yet
09:23:48 <hpc> or the module system
09:23:50 <cmccann> with agda it's easy: doing anything useful always makes you want to stab yourself in the face
09:23:53 <cmccann> :D
09:23:53 <hpc> or how the termination checker works
09:23:54 <hpc> or...
09:23:58 <hpc> lol
09:24:03 <erus`> haskell is like the perfect scripting language for games
09:24:25 <erus`> the perfect scripting language for games is a functional language in my head
09:24:39 <CodeWeaver> I've been thinking about that very thing from time to time, erus`.
09:24:40 <erus`> its also perfect for everything
09:24:46 <dainanaki> Haskell is like the perfect thing for... everything
09:24:52 * cmccann thinks a strict total functional language would be better for game scripting to be honest
09:24:56 <hpc> i think a version of lisp would be the perfect scripting language for games
09:25:09 <eyebloom> How can I turn a GLint into an integer and back?
09:25:09 <hpc> smaller runtime requirements than haskell
09:25:16 <donri> https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md
09:25:23 <hpc> @hoogle GLInt -> Integer
09:25:27 <erus`> hpc shame on you
09:25:28 <hpc> pah
09:25:37 <hpc> eyebloom: fromInteger/toInteger
09:25:48 <CodeWeaver> donri, thanks.
09:26:25 <eyebloom> That's great the you can put a type pattern into hoogle like that.
09:26:41 <rostayob> hpc: you just need to strip haskell of the runtime stuff
09:26:59 <CodeWeaver> 'just'?
09:27:04 <dainanaki> lol
09:27:05 <Sgeo> How do I write comments that aren't answers on Stack Overflow?
09:27:07 <rostayob> well of what you want to strip
09:27:14 <rostayob> if you want to use it as a scripting language
09:27:31 <hpc> agda would be perfect for scripting games
09:27:31 <c_wraith> Sgeo: that might require a certain amount of reputation
09:27:31 <danr> Sgeo: there's some minimum reputation required to do so
09:27:33 <applicative> Sgeo, I think you need to get a certain number of upvotes for your 'answers' if I remember
09:27:38 <hpc> you don't have to script anything; just prove that you can
09:27:39 <hpc> :P
09:27:41 <Sgeo> Argh
09:27:56 <rostayob> the runtime is mostly for convenient concurrency, events, etc. if you want to use haskell as a scripting language you can just embed it without those capabilities
09:28:05 <applicative> Sgeo, yes, you'd think it would be the other way round
09:28:09 <rostayob> I'd prefer that to lisp :P
09:28:21 <CodeWeaver> rstayob: Is that easily doable without severe makefile hacking?
09:28:33 <hpc> rostayob: or write your game in haskell too
09:28:33 <rostayob> CodeWeaver: ? makefile hacking?
09:28:36 <hpc> then the RTS is already loaded
09:28:42 <CodeWeaver> I mean how would you strip out those bits.
09:28:47 <CodeWeaver> Maybe I'm missing something.
09:28:51 <applicative> the Data.Lens tutorial on the happstack site is pretty good indeed
09:28:58 <rostayob> CodeWeaver: I meant that you'd write a little haskell interpreter
09:29:02 <CodeWeaver> AH.
09:29:04 <hpc> CodeWeaver: you could also be really gross and use a custom ghc
09:29:16 <CodeWeaver> hpc:  That's what I thought rostayob was suggesting. ;)
09:29:39 <rostayob> I think that if you want a minimal haskell it'd take less time to rewrite your interpreter :P
09:29:50 <CodeWeaver> Fair enough.
09:29:53 <CodeWeaver> No argument.
09:30:16 <cmccann> applicative, the idea is to encourage useful questions/answers and reduce extraneous chatter on SO, so comments are disabled until you (supposedly) demonstrate a useful contribution
09:30:57 <cmccann> not sure how well that really works, but oh well
09:31:25 <Sgeo> I just "answered" a question on SO
09:31:26 <applicative> cmccann: yes it makes sense, but so does the opposite. or the opposite makes sense til you consider the importance of ranking for them
09:31:31 <Sgeo> I don't know if my answer is crap
09:31:52 <cmccann> Sgeo, and yes, it requires 50 rep to comment, which isn't all that much
09:32:12 <Sgeo> But I'm more sure of my ability to ask questions of posters than to actually provide answers
09:32:35 <Sgeo> http://stackoverflow.com/questions/9003765/are-there-default-values-for-record-getters-in-haskell/9008022#9008022
09:32:36 <Sgeo> :/
09:32:51 <cmccann> applicative, well, considering that they want to discourage comments in general and would probably remove them entirely if that wouldn't cause more problems...
09:33:19 <applicative> it's reasonable, it's just surprising at first
09:35:29 <applicative> Sgeo, your answer is equivalent to the previous one, you introduce a specialized Maybe for Necklace
09:35:58 <cmccann> Sgeo's answer does, however, allow sane record accessors
09:36:05 <applicative> yes
09:36:33 <cmccann> better yet would probably be using lenses of some sort
09:37:20 <dainanaki> indeed.
09:37:22 <cmccann> but if the goal is preserving record syntax and not allowing errors Sgeo's approach is probably the sensible way
09:37:38 <applicative> yeah, what I said wasn't right, I was thinking the first answer made invalid necklace into Nothing in Maybe Necklace
09:38:10 * applicative upvote Sgeo's answer
09:38:17 <Sgeo> :D
09:38:17 <applicative> upvotes rather
09:40:24 <cmccann> I think Sgeo can... upvote now
09:40:26 <cmccann> hooray
09:40:39 <Sgeo> "You've earned the "Teacher" badge for Are there default values for record getters in Haskell?. See your profile.
09:40:40 <Sgeo> ×Congrats, you've gained the privilege – talk in chat and 5 other privileges learn more"
09:41:10 <nyingen> achievement unlocked
09:41:56 * cmccann actually got a gold "Great Answer" badge earlier today...
09:44:12 * _Mikey highfives cmccann
09:46:14 <CodeWeaver> Alright, back online later. :)
09:47:41 <dgpratt> cmccann: nice :)
09:47:53 <eyebloom> How do you go from an Integer to a GLfloat. fromIntegral doesn't work because there is no instance of Integral for GLfloat
09:48:41 <byorgey> @type fromIntegral
09:48:42 <timemage> eyebloom, not that i can really help, but what library are you using?
09:49:01 <byorgey> there's not even a Num instance for GLfloat?
09:49:03 <eyebloom> Graphics.Rendering.OpenGL
09:50:32 <eyebloom> not sure
09:50:49 <eyebloom> otherwise I'm finding the OpenGL bindings to be wonderful.
09:50:59 <eyebloom> But the type conversions are tough.
09:51:17 <byorgey> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.2/doc/html/Graphics-Rendering-OpenGL-Raw-Core31.html#t:GLfloat   this?
09:51:24 <byorgey> there is a Num instance
09:51:36 <byorgey> so you should be able to use  fromIntegral to convert from Integer to GLfloat.
09:51:59 <timemage> eyebloom, i was just wondering if it was a scope thing.
09:52:12 <byorgey> converting from GLfloat to Integer presumably requires 'floor' or 'ceiling' or 'round'.
09:53:35 <eyebloom> From Integer -> GLfloat should not need anything.
09:53:51 <Botje> fromIntegral, surely?
09:53:59 <byorgey> what do you mean it should not need anything?
09:54:04 <byorgey> Haskell does not do implicit conversion.
09:54:27 <hpaste> eyebloom pasted “Toy OpenGL” at http://hpaste.org/56965
09:55:19 <eyebloom> It shouldn't need floor ceiling or round
09:55:33 <byorgey> I didn't say it did.
09:55:40 <byorgey> I said  GLfloat -> Integer  requires those.
09:56:39 <byorgey> eyebloom: do you get any errors with that code you pasted?
09:56:58 <eyebloom> src/VisualHoas.hs:37:27:
09:56:58 <eyebloom>     No instance for (Integral GLfloat)
09:56:58 <eyebloom>       arising from a use of `mouseMotion'
09:57:00 <eyebloom>     Possible fix: add an instance declaration for (Integral GLfloat)
09:57:00 <eyebloom>     In the first argument of `Just', namely
09:57:00 <eyebloom>       `(mouseMotion mouseStart figurePosition)'
09:57:00 <eyebloom>     In the second argument of `($=)', namely
09:57:00 <eyebloom>       `Just (mouseMotion mouseStart figurePosition)'
09:57:00 <eyebloom>     In a stmt of a 'do' expression:
09:57:00 <eyebloom>           motionCallback $= Just (mouseMotion mouseStart figurePosition)
09:57:12 <eyebloom> Sorry. I'll not paste like that again.
09:57:42 <timemage> eyebloom, well, that's just the thing.  fromIntegral expects an integer type right?  like GLint maybe.
09:58:07 <rwbarton> it sounds like you tried to use a GLfloat in a context that expected something Integral
09:58:24 <eyebloom> It's getting an integer as it's parameter.
09:59:02 <eyebloom> I'm hoping it's return type will be a GLfloat
09:59:22 <rwbarton> I don't know what "it" is.
09:59:32 <timemage> eyebloom, ok. now i'm confused.   do you have code posted somewhere?
09:59:48 <eyebloom> http://hpaste.org/56965
09:59:50 <byorgey> eyebloom: I think the problem is your use of 'toInteger' in mouseMotion.
10:00:12 <byorgey> toInteger converts Integral types to Integer, which is not what you want.
10:00:32 <cmccann> yeah, toInteger isn't for rounding/truncation/&c.
10:01:09 <byorgey> eyebloom: (fromIntegral $ (toInteger x) + (toInteger (xC - xS))  -- this seems silly.  why not just   x + (xC - xS)  ?
10:01:23 <byorgey> although I don't know exactly what types are involved.
10:01:27 <eyebloom> I got other errors for that.
10:01:41 <eyebloom> It doesn't like combining GLint and Integer
10:01:45 <byorgey> eyebloom: it would probably help a lot if you add type signatures to your top-level functions.  You'll get better (more localized) error messages then.
10:02:30 <byorgey> eyebloom: what are the types of x, xC and xS?
10:02:52 <koeien> eyebloom: GLint is not an unbounded type. Integer is.
10:03:29 <rwbarton> apparently x :: GLfloat while xC, xS :: GLint
10:04:04 <eyebloom> That's a good suggestion.
10:04:15 <eyebloom> Using round, seems to have worked.
10:04:20 <eyebloom> Thank you.
10:04:26 <rwbarton> seems like the wrong thing to do
10:04:35 <rwbarton> how about... x + fromIntegral (xC - xS)
10:04:46 <rwbarton> a la byorgey's earlier suggestion
10:04:50 <mmos1127> I can't remember the syntax for putting a class constraint on a data definition: something like    data Foo = Bar a => Foo a  ???
10:05:08 <byorgey> mmos1127: don't.
10:05:11 <frerich> I recently installed mueval using 'cabal install' but now noticed that I probably should've built it with '-rtsopts'. What's the best way to re-build and re-install the program with that option? I noticed that the source tarball got installed beneath ~/.cabal - I tried unpacking it, tweaked mueval.cabal but then a 'runhaskell Setup.hs configure' doesn't notice some dependencies (whereas the build done by 'cabal install' didn't miss any
10:05:11 <frerich> dependencies). I suspect some global vs. local installation issue so I didn't follow this route further.
10:05:42 <byorgey> frerich: don't do 'runhaskell Setup.hs configure', just run 'cabal install'
10:05:53 <eyebloom> rwbarton: that also works.
10:05:54 <byorgey> frerich: 'cabal install' without an argument will just look for a package in the current directory
10:06:08 <frerich> byorgey: Aaah, interesting, let me try...
10:06:48 <mmos1127> byorgey: oh I guess it's "data Foo a = Foo a" and then when I declare a variable to have type "Foo Something" then Something is an instance of the needed class?
10:06:59 <byorgey> eyebloom: not 'also'. they are quite different.  compare  fromIntegral (round (4.5) + 3)   and  4.5 + fromIntegral 3  .
10:07:42 <byorgey> mmos1127: sure, and you can write functions over Foo a  which require a constraint on a, like   blah :: Constraint a => Foo a -> ...
10:07:53 <frerich> byorgey: Coolness, that did it, thank you!
10:07:59 <byorgey> frerich: great!
10:08:14 <mmos1127> byorgey: thanks, I'll have to write some actual code to reinforce the understanding in brain, so off to do that
10:08:43 <fredmorcos> What is the recommended JSON library? I have an ADT which I would like to transform to a JSON representation (which will eventually be transformed to String).
10:08:47 <cmccann> there are also GADTs for combining constraints with data types, but that's usually not necessary
10:09:18 <frerich> fredmorcos: My impression is that aeson is the alpha and the omega when it comes to JSON handling.
10:09:19 <fredmorcos> I would like the library to provide an ADT deriving Show for JSON structures (and pretty printing as a bonus).
10:09:51 <fredmorcos> frerich: Okay, thank you!
10:10:30 <dainanaki> yeah, aeson is the thing.
10:15:04 <Sgeo> I should get ready to go
10:16:42 <mmos1127> what's wrong with this: class (Foo a, Bar b) => Something a b where  ???
10:17:04 <c_wraith> mmos1127: nothing, but it does require the MultiParameterTypeClasses extension
10:17:19 <rwbarton> for starters
10:18:24 <c_wraith> It's quite possible that depending on the rest of the definition, it could require more extensions
10:19:12 <frerich> Does anybody here have experience with running lambdabot (maybe even as an IRC bot)? I suspect this is quite a specific topic, so I'd like to take my question into a /query instead of this 900 person channel :)
10:21:27 <MarkDBlackwell> Is there anything for finding the longest increasing subset, keeping order?
10:22:31 <monochrom> that will be longest increasing subsequence
10:22:48 <koeien> monochrom: why not subset?
10:22:57 <monochrom> because "keeping order"
10:22:59 <applicative> there needs to be an order
10:23:01 <koeien> right, of course.
10:23:05 <c_wraith> heh.  the longest increasing subset is nub . sort
10:23:12 <koeien> i thought the usual partial order on sets, but that makes no sense
10:23:24 <koeien> (in this context)
10:23:49 <c_wraith> actually, I guess map head . group . sort is more efficient
10:24:29 <monochrom> longest increasing subsequence can also be done in n log n time, n being length of main sequence
10:24:44 <c_wraith> yes, but it's not so simple
10:24:59 <koeien> wikipedia has a nice article about it.
10:26:21 <mm_freak> i'd say map head . group . sort is O(n * log n)
10:26:26 <mm_freak> ah, no
10:26:34 <mm_freak> it's O(n^2), because of sort
10:26:44 <c_wraith> no, it's O( n * log n)
10:26:48 <c_wraith> but it solves the wrong problem
10:26:53 <c_wraith> so it's sort of irrelevant
10:27:03 <monochrom> sort is n^2? that would be too good to be true!
10:27:04 <c_wraith> I can always solve the wrong problem in O(1) time, if I want!
10:27:18 <mm_freak> it's mergesort, isn't it?
10:27:26 <mm_freak> that one should be O(n^2) for haskell lists
10:27:36 <c_wraith> no, mergesort on haskell lists is O(n * log n)
10:27:41 <koeien> erally? hmm
10:27:48 <MarkDBlackwell> E.g., for [5, 100,110,120, 15, 70,80,90, 25, 40,50,60, 35, 10,20,30, 45], the answer (I think) is 5,15,25,35,45?
10:27:50 <c_wraith> but it's not mergesort anymore..
10:27:55 <c_wraith> it's something bizarre, instead
10:28:06 <nicoo> monochrom: Hoogle states that it's stable, so it's probably not mergesort
10:28:18 <MarkDBlackwell> monochrom, but not in sequence: they can be broken. Still subsequence?
10:28:22 <c_wraith> nicoo: mergesort is stable, but it's not mergesort
10:28:59 <c_wraith> well, it is a mergesort, but it's not the really obvious one
10:29:00 <monochrom> please don't try to say "haskell sort is mergesort" or "haskell sort is quicksort" or whatever. wrong analogies.
10:29:00 <c_wraith> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/Data-List.html#sort
10:29:04 <nicoo> c_wraith: My bad; confused heapsort and mergesort for a few moments ...
10:29:52 <c_wraith> the commented-out version is the naive mergesort, which is still O(n * log n).
10:29:55 <MarkDBlackwell> Sorry about the delayed example. Is it a sequence if it scatter-selects?
10:29:56 <mm_freak> oh, sorry
10:30:06 <c_wraith> The new one has better constant factors
10:30:13 <frerich> @google jenkins
10:30:21 <mm_freak> i thought mergesort is an O(n^2) algorithm, because i remember reading somewhere that only probabilistic sorting algorithms can do O(n * log n)
10:30:23 <frerich> err, wrong channel, sorry.
10:30:28 <nicoo> monochrom: We should say "GHC's implementation of Data.List.sort is currently Xsort" for some value of X; but that's being pedantic
10:30:31 <kallisti> mm_freak: um, no.
10:30:39 <c_wraith> mm_freak: this is a case where your lack of CS education is biting you hard. :)
10:30:52 <nicoo> mm_freak: No
10:31:26 <mm_freak> c_wraith: indeed =)
10:31:26 <nicoo> mm_freak: Most usefull sort algorithms are O(n log n) (except quicksort, which is O(n^2) in worst-case)
10:31:29 <koeien> mm_freak: quicksort is O(n^2) worst case
10:31:29 <kallisti> n*log n is the best possible case of a sorting algorithm. as far as I know all of the algorithms that achieve this are fairly nonprobabilistic.
10:31:49 <kallisti> I think n*log n being the best case is also assuming P /= NP
10:31:54 <monochrom> you should quantify all that with "comparison-based"
10:31:55 <c_wraith> kallisti: no
10:32:03 <kallisti> ah okay.
10:32:06 <c_wraith> kallisti: it just assumes you're sorting by comparing elements
10:32:09 <rwbarton> the n log n bound for comparison based sorts just comes from information theory
10:32:17 <kallisti> okay.
10:32:22 <c_wraith> there are ways to sort that aren't based on comparing elements, for limited domains
10:32:22 <monochrom> radix sort breaks the sound barrier. though, radix sort kind of cheats
10:32:43 <nicoo> monochrom: The sorting problem is about comparison; you speak about "integer sorting", or "xyz sorting" if you aren't talking about the generic problem
10:32:47 <kallisti> c_wraith: id is a good sort function for sorted sequences
10:32:53 <kallisti> so I've heard anyway.
10:32:56 <c_wraith> yeah, radix sort is an example of limiting the domain to get faster than O(n * log n)
10:32:58 <MarkDBlackwell> monochrom, I see you're right, longest increasing subsequence is not necessarily contiguous. Thank you, much! It has application for sorted pairs of numbers.
10:33:52 <c_wraith> radix sort is O(k * n), where k is the number of passes required.
10:34:14 <monochrom> subsequence for "does not have to be contiguous" and segment for "has to be contiguous" are standard terminology. see for example maximum segment sum
10:34:14 <c_wraith> if you limit the domain properly, k is a constant not depending on n
10:35:12 <MarkDBlackwell> monochrom, on segment, thanks. :)
10:35:25 <kallisti> mm_freak: it might make more sense if you observe that O(log (n!)) = O(n * log n)
10:36:29 <monochrom> I am now curious about which author wrote that deterministic sorting is n^2 and only probabilistic sorting can go down to n log n
10:36:46 <CodeWeaver> Something known to be clearly not true for decades.
10:36:51 <CodeWeaver> Odd claim.
10:37:34 <mm_freak> kallisti: that helps indeed
10:38:24 <kallisti> and of course a non-natural logarithm is just a natural logarithm with some constant factors.
10:38:44 <koeien> monochrom: maybe it's for quicksort.
10:38:51 <kallisti> believe mergesort and quicksort are logBase 2
10:38:54 <koeien> randomized pivoting will give expected O(n log n) if my memorys erves me well
10:39:34 <CodeWeaver> Pivoting on quicksort you mean?
10:39:38 <CodeWeaver> Sorry I'm coming in late on this. :D
10:40:55 <CodeWeaver> There are two interesting wrinkles I learned over the last few years…
10:41:29 <nicoo> CodeWeaver: Which are ?
10:41:33 <CodeWeaver> 1) There's a way to select the pivot for quicksort so that it guarantees O(n log n) behaviour… in other words, the algorithm using the pivot is the same as quicksort, but the pivot select is more elaborate (without requiring sorting it first by another sorting algorithm which would be a cheat).
10:41:54 <CodeWeaver> It's got a bit of a high constant factor compared to regular quicksort, but it's still interesting.
10:41:55 <koeien> yes, using median pivot
10:42:03 <c_wraith> yeah, median of medians
10:42:11 <CodeWeaver> Quite.  Very good.  I only learned this recently.
10:42:13 <koeien> it's theoretically interesting
10:42:18 <c_wraith> ... Tarjan has created some rather crazy stuff
10:42:21 <CodeWeaver> I've implemented it.
10:42:27 <CodeWeaver> cause I'm loony.
10:42:34 <CodeWeaver> and cause I didn't quite believe it.
10:42:42 <CodeWeaver> Anyway, it *is* interesting.
10:42:53 <nicoo> CodeWeaver: It's not being loony; Sort algorithms are the bedrock of programming
10:43:11 <c_wraith> He was responsible for both median of medians and union-find trees as used by kruskall's algorithm
10:43:13 <CodeWeaver> Nice of you to say, nicoo. :D
10:43:31 * nicoo have implemented plenty of sort algorithms in plenty of languages, from MIPS ASM to OCaml and Haskell ...
10:43:33 <c_wraith> both of which have really theoretically interesting timings
10:43:38 <CodeWeaver> 2) There's a way to do a megesort so that it's in-place (well, constant extra space) while not losing the O(n log n) worst case.
10:44:05 <fasta> c_wraith: yes, Tarjan is/was awesome.
10:44:06 <CodeWeaver> That one was hella ugly to implement.  Some occasionally weird indexing.
10:44:23 <CodeWeaver> But these two special cases are not normal variants.
10:44:59 <monochrom> I thought by now hash tables were the bedrock of programming
10:45:10 <nicoo> CodeWeaver: Yep, but it's so ugly that you usually use heapsort, shellsort, smoothsort or quicksort, which are/seem more adequate when sorting arrays
10:45:22 <CodeWeaver> Indeed.
10:46:08 <nicoo> monochrom: I don't think you can explain hashtables to somebody who has been learning programming for half an hour; you can explain him sorting
10:46:09 <CodeWeaver> Bah, hashtables are so last decade ;)
10:46:11 <monochrom> sorting stays the bedrock of programming contests such as topcoder and acm icpc
10:46:32 * hackagebot highlighting-kate 0.5 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5 (JohnMacFarlane)
10:46:48 <MarkDBlackwell> monochrom, 'longest increasing subsequence can...be done in n log n time, n being length of main sequence', main being per Wikipedia the original input sequence; very nice! :)
10:46:50 <monochrom> "bedrock" as in mentioned in most programs
10:46:55 <CodeWeaver> The new programming is this:  http://blip.tv/open-source-developers-conference/temporally-quaquaversal-virtual-nanomachine-programming-in-multiple-topologically-4466153
10:47:09 <CodeWeaver> I'm thinking of porting it to haskell. :P
10:47:17 <CodeWeaver> In about two decades when I know enough haskell. :P
10:47:24 <mreh> any yampa fans here?
10:47:40 <nicoo> mreh: Yampa ?
10:47:55 <mreh> nicoo: yeah
10:48:17 <nicoo> What is it ?
10:48:17 <mreh> i have a conceptual problem, i can't think how to implement it
10:48:32 <mreh> it being parallel switching with feedback
10:48:40 <MarkDBlackwell> mreh, not YAMBA, yet another micro-blogging app?
10:48:40 <nicoo> Ah, ok
10:48:50 <mreh> MarkDBlackwell: no
10:48:55 <nicoo> Some diligent googling sent me to the HaskellWiki
10:49:49 <MarkDBlackwell> nicoo, mreh, yes, http://www.haskell.org/haskellwiki/Yampa
10:51:12 <nicoo> MarkDBlackwell: Ok; sounds like AFRP
11:04:02 <tommd> ClaudiusMaximus: What did you learn about avoiding Sqlite "ErrorBusy"?
11:18:56 <dfre> hi =)
11:19:04 <Lemmih> Hey.
11:19:13 <CodeWeaver> ho. :)
11:20:52 <dfre> i'm trying to implement this algo with no luck http://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm
11:21:01 <dfre> anyone has a tip for me ? =D
11:21:36 <CodeWeaver> Well, darn, now I have to try implementing that.
11:21:38 <CodeWeaver> *studies*
11:23:05 <tommd> @tell ClaudiusMaximus What did you learn about avoiding Sqlite "ErrorBusy"?
11:23:05 <dfre> CodeWeaver: eheheh
11:23:10 <tommd> huh, no bot.
11:30:22 <MarkDBlackwell> monochrom, after some research, because my main sequence can be converted into 1,2..N, Longest Increasing Subsequence can be found in O(n log log n) time using the Patience algorithm: http://en.wikipedia.org/wiki/Patience_sorting .
11:39:32 <MarkDBlackwell> nicoo, found this nice page on AFRP, interesting Haskell code reading: https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md
11:42:22 <donri> Warning: Unknown extensions: NoNPlusKPatterns  -- wtf?
11:46:25 <ChristianS> donri: maybe your ghc is too old? but i guess you can safely ignore that...
11:51:44 <donri> ChristianS: 7.0.4
11:51:52 <donri> i think the error is from cabal though
11:52:28 <ChristianS> but it's only a warning, does anything bad happen?
11:52:36 <donri> http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Language-Haskell-Extension.html#t:Extension
11:52:38 <donri> don't think so
11:52:53 <donri> just don't like unecessary warnings :)
11:53:49 <donri> looks like cabal doesn't follow the convention of No* and instead randomly listing either the positive or negative variant
11:57:29 <TheLemonMan> hrm, i imported the state monad but ghc keeps giving "Not in scope: data constructor `State'"
11:58:33 <Veinor> that's because State is a type constructor, not a data constructor
11:58:55 <Saizan> there also used to be a data constructor State
11:59:23 <Saizan> but no more, you can use the functions state and runState though, as wrapper and unwrapper
11:59:33 <Veinor> 'return x' will give you a value with 'output' x and undefined state
12:00:04 <Veinor> > runState (return 'hello') 77
12:00:09 <TheLemonMan> sounds easier than using the type constructor
12:00:17 <Saizan> i wouldn't say undefined, i'd say it leaves the state untouched
12:00:23 <Veinor> oh right
12:00:27 <Veinor> > runState (return "hello") 77
12:00:38 <Saizan> no bot
12:00:44 <Veinor> oh :(
12:01:42 <Veinor> Saizan: yeah, you're right
12:03:58 <NothingMan65> Is there a way to get the index/loop-count during a list comprehension?
12:04:26 <copumpkin> ewww indices
12:04:30 <koeien> zip [0..]
12:04:30 <copumpkin> but if you must, just zip with [0..]
12:04:36 <NothingMan65> Ah
12:04:39 <NothingMan65> Hmm
12:04:46 <NothingMan65> I don't want to use indicies either.
12:04:56 <koeien> > [i + n | (i,n) <- zip [0..] [1,2,3,4,37]]
12:05:27 <koeien> @botsmack
12:05:37 <KSkrzet> I have question regaring type resolution/checking in Haskell: is it right to say that type checking in Haskell can be expressed as a 1) set of equations 2) graph reduction / rewriting problem ?
12:05:41 <koeien> ... no lambdabot?
12:05:55 <koeien> , 1 = 1
12:06:37 <ChristianS> lambdabot died in a netsplit :-(
12:06:40 <TheLemonMan> silly question, if i have a do block inside a stateful function does return belong to the IO monad or what ?
12:07:15 <koeien> TheLemonMan: you don't make total sense
12:07:21 <MostAwesomeDude> TheLemonMan: Well, which monad is it in?
12:07:27 <koeien> "stateful function", you mean an IO action?
12:07:30 <elliott> TheLemonMan: If you have a "do" block in the IO monad, then "return x" is operating inside the IO monad, yes.
12:07:46 <koeien> note that IO actions are *not* functions!
12:08:24 <nicoo> KSkrzet: 1) Definitely 2) Mmh, dunno
12:10:20 <mmos1127> what do you have to define to make an instance of Ord?
12:10:38 <koeien> compare
12:10:43 <koeien> or (<=) I think
12:10:47 <elliott> mmos1127: compare, or (<), or (>), or (<=), or (>=)
12:10:52 <elliott> koeien: any works, since it has (==)
12:11:06 <mmos1127> got it!
12:11:10 <koeien> "Minimal complete definition: either compare or <=."
12:11:11 <MostAwesomeDude> "Minimal complete definition: either compare or <=. Using compare can be more efficient for complex types."
12:11:14 <elliott> oh, huh
12:11:14 <koeien> according to the docs.
12:11:16 <monochrom> type-checking is a set of equations and do unification
12:11:21 <elliott> well, it *could* define defaults :)
12:12:27 <koeien> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Classes.html#Ord
12:12:56 <koeien> compare default is in terms of (<=), (<=) in terms of compare, and the rest uses compare
12:12:58 <daniel31415> monochrom: and compute the mgu ^^
12:13:41 <monochrom> clearly, unification includes computing mgu's
12:13:48 <daniel31415> mapM_ print $ repeat " <-- plays the smarty lol"
12:15:28 <srhb> ?src (<$>)
12:15:35 <elliott> srhb: fmap
12:15:38 <monochrom> <$> is infix for fmap
12:15:50 <elliott> for monads, (f <$> m) === do { x <- m; return (f x) }
12:15:54 <monochrom> also, @src fmap won't get you anything either
12:15:55 <srhb> Wow, anthropomorphizedlambdabots! Thanks.
12:16:00 <srhb> :)
12:16:07 <elliott> beep
12:16:22 <arcatan> @botsnack
12:16:23 <srhb> monochrom: It's >@src ?
12:16:25 <monochrom> this can only be attributed to human errors
12:16:37 <Clint> shouldn't lambdabot have reconnected by now?
12:17:18 <elliott> Cale?
12:17:20 <monochrom> she is interviewing for a job at the Pentagon
12:18:42 <otters> no bot?
12:21:12 <niteria> does anyone know the name for binary string that has the most distinct substrings?
12:21:55 <tromp> de bruijn sequence
12:24:03 <shergill> hmm no lambdabot today?
12:25:44 <niteria> tromp: in de bruijin you're only sure that those of length n are distinct
12:26:15 <niteria> tromp: you can do better if you consider substrings of all length
12:26:16 <niteria> s
12:26:23 <shergill> oh i should read up
12:27:08 <tromp> give me an example that does better, niteria
12:27:23 <tromp> of same length as a de bruijn sequence
12:29:48 <niteria> tromp: I'm not entirely sure you can do better, it's just this and de bruijn are different topics on the lecture
12:30:08 <niteria> that gives me a hint they're different things
12:30:56 <tromp> well, you cannot do better
12:31:51 <tromp> it has all strings of length <n, and its substrings of length >= n are all unique
12:32:15 <tromp> which is the best u can do
12:33:39 <niteria> that's a little different from definition I have
12:35:33 <niteria> my definition says it has all strings of length =n
12:35:41 <matthiasgorgens> niteria, if you just want an infinite string, that has all substrings, just join together the the binary representation for the natural numbers.
12:36:06 <niteria> no, I don't need infinite string
12:36:28 <tromp> i didnt gice definition, i just listed some properties
12:37:06 <niteria> still, there are binary sequences of length != k^n
12:37:56 <niteria> I think my problem is to for every n find a binary string that's the best according to the criterion I gave before
12:38:16 <matthiasgorgens> niteria, why do you need that?
12:38:41 <niteria> I'm preparing for an exam
12:38:45 <matthiasgorgens> niteria: ok.
12:39:55 <niteria> I just thought someone might know a name for this
12:40:12 <niteria> de bruijn solves it partially
12:40:27 <niteria> if it has properties tromp gave
12:42:13 <matthiasgorgens> I recently gave a talk about a paper (not my paper) that estimates given a graph and a specific size limit, how many overlapping capies of that graph you can fit within the limit.
12:42:23 <matthiasgorgens> it's dependent on the properties of the original graph, of course.
12:49:58 <limetree> I'd like to give Hipmunk a try, and I noticed it says on its hackage page "Update to Chipmunk 5.3.5 and bump dependencies to match GHC 7.2.1.". does that mean I can't use the latest version with the Haskell platform?
12:50:32 <limetree> I've yet to install anything haskell related on this computer (I'm on windows...), so I thought I'd ask before doing it
12:51:48 <limetree> (since it contains an older version of ghc, I mean)
12:52:25 <luite> it probably just means that GHC 7.2.1 is now supported (bump upper bound for base for example)
12:52:48 <luite> not that 7.0 is unsupported now
12:54:56 <luite> http://hdiff.luite.com/cgit/Hipmunk/commit/?id=25c7643b3abc063e0cb2d1d32370adc519abb2eb <- only dependency change is containers < 0.4 to < 0.5
12:54:57 <limetree> I see. it was the wording "to match" that made me suspect otherwise.
12:55:17 <limetree> sounds good
13:05:00 <limetree> 10 minutes later, I've gone from not having anything haskell related installed, to trying the HipmunkPlayground demos. that's pretty impressive.
13:06:24 <fasta> limetree: install Pharao. Three clicks (all of which can be automated) and you have everything in about 10 seconds.
13:06:58 <fasta> Haskell isn't really impressive in the 'getting up to speed'-part.
13:07:36 <fasta> Or Pharo, whatever :)
13:07:41 <rostayob> fasta: oh cmon, the haskell-platform is a good base
13:07:43 <limetree> fasta: what's pharao?
13:07:54 <fasta> wget https://gforge.inria.fr/frs/download.php/29274/Pharo-1.3-13315-OneClick.zip
13:08:08 <fasta> rostayob: I would say it is mediocre.
13:08:23 <rostayob> fasta: this is #haskell, if you want to talk about smalltalk I'm sure there are other channels
13:08:40 <limetree> mostly I was impressed because I'm using windows. usually, open source stuff is a bit of hassle to get going.
13:09:14 <fasta> rostayob: how long have you been in this channel?
13:09:25 <rostayob> fasta: what do you mean?
13:09:49 <fasta> rostayob: months? Years?
13:09:54 <rostayob> fasta: years
13:09:59 <fasta> rostayob: how many?
13:10:25 <rostayob> mhm. thinking about it, a year and a half. why?
13:10:58 * elliott concurs with rostayob that this channel is not the place to promote Smalltalk when someone talks about their good experiences with Haskell.
13:11:14 <fasta> rostayob: because I can say _whatever_ I want in this channel, because I have been here since basically the beginning.
13:11:32 <copumpkin> lol
13:11:34 <fasta> rostayob: so, no newbie, like you is going to tell me what to do.
13:11:36 <limetree> heh
13:11:41 <elliott> hahaha jesus christ
13:11:59 <shergill> elliott i think you mean 'noah and the flood'
13:12:15 <Ralith> fasta: pretty sure that's not how it works!
13:12:28 <Botje> play nice, kids.
13:12:47 <rostayob> fasta: ahah. i guess this discussion ends up here, at least for me
13:12:48 <shergill> s/mean/meant
13:13:27 <fasta> Ralith: newbies are always overconfident.
13:14:09 <Ralith> if you say so
13:14:13 <elliott> your horse. it's too high
13:14:19 <rostayob> too damn high
13:14:23 <Ralith> far be it from me to disagree with someone who's been in an IRC channel for a long time.
13:14:34 * Clint chokes.
13:14:39 <copumpkin> yeah, same here. He's been around for longer than me so he must be right
13:14:46 <limetree> the hipmunkplayground demo reminds me of across, or elasto mania, if anyone's played those games
13:14:49 <fasta> Also, I think as a community you are just blind if you cannot look outside to what other people are doing. Clearly the Smalltalk installation procedure is _vastly_ superior to how Haskell implementations currently work.
13:14:54 <rostayob> limetree: I love elastomania :)
13:15:08 <elliott> copumpkin: if you tried to kick fasta, it would backfire and kick you insted
13:15:16 <fasta> I am not saying that you should go out and try Smalltalk.
13:15:26 <limetree> rostayob: cool :) I used to be in an across "clan" back in the days, haha...
13:15:33 <Ralith> little-known feature of the freenode ircd, that
13:15:34 <elliott> erm, that's exactly what you said though
13:15:50 <rostayob> limetree: lol I didn't even know there were clans
13:16:05 <limetree> yeah. we even held a world record.
13:16:22 <erus`> :t const
13:16:28 <erus`> @type const
13:16:31 <rostayob> limetree: an open source haskell elastomania clone would please me
13:16:33 <elliott> anyway considering smalltalk gets a huge amount of flack and vastly reduced popularity for its VM-based environment and isolation and the resulting interest in things like GNU Smalltalk because of that, whether you agree it's reasonable or not it's ridiculous to say that we should obviously look to copy Smalltalk's tools
13:16:37 <erus`> > const 1 2
13:16:37 <rostayob> erus`: it's been down for a while
13:16:47 <elliott> erus`: lambdabot is not here
13:16:52 <erus`> lambdabot is as bad as reddit
13:16:59 <fasta> elliott: er no, it is not.
13:17:16 <nand`> [02+1633] * Quits: lambdabot (~lambdabot@li85-105.members.linode.com) (*.net *.split)
13:17:31 <erus`> i have to use ghci now!
13:17:31 <fasta> elliott: I would definitely use a Haskell image based development environment over what there is now.
13:17:39 <elliott> fasta: yes. *you* would.
13:17:49 <fasta> elliott: and _everyone_ with a brain would.
13:18:00 <koeien> could you tone it down a little?
13:18:00 <copumpkin> fasta: that kind of "argument by intimidation" is lazy
13:18:07 <rostayob> elliott: don't feed the troll
13:18:07 <copumpkin> fasta: it's also supremely annoying
13:18:16 <elliott> rostayob: yeah i'm done
13:18:28 <copumpkin> fasta: if you get kicked from this channel, it's because you're a dick, not because you propose using other languages
13:18:32 <fasta> Ok, I will compare the two:
13:18:37 <rostayob> elliott: you too :P
13:18:40 <rostayob> sorry, copumpkin
13:18:46 <rostayob> oh boy here we go
13:19:28 <copumpkin> fasta: keep in mind that there's a long-standing ban on smerdyakov, not because he doesn't know what he's talking about, but because he was an asshole
13:21:29 <fasta> One has logarithmic time lookup for symbols and loads an entire program in mere milliseconds. The other uses archaic tools like grep to find symbols and if the moon is aligned correctly you can know its source code position (but then there are still no good tools to interact with it) after all your files (note that it needs to search the harddisk for those all the time), but then it is still much slower.
13:22:24 <fasta> copumpkin: smerdyakov was banned because he was far ahead of his time.
13:22:32 <copumpkin> oh yes, that was it
13:22:37 <shergill> does smalltalk really care about moon allignment?
13:22:38 <elliott> I feel compelled to point out that nobody at all has said that a Smalltalk-style environment is inferior, only that (a) Smalltalk's popularity is reduced by that environment and (b) none of this is nearly as obvious as you claim.
13:22:38 <shergill> wow
13:22:49 <elliott> ahaha ok
13:22:51 <copumpkin> fasta: you might be too far ahead of your time too, at this rate
13:23:10 <elliott> is that you, wolfram? :)
13:23:38 <nand`> ahead of our time by about -20 years
13:24:16 <frigga> fasta: Hmmm, the obvious download button for Linux on the Pharo site gets me a MacOSX installer.  I'd hardly call that something Haskell should imitate.
13:24:38 <fasta> frigga: it also includes Linux.
13:24:50 <fasta> frigga: PEBKAC, really.
13:25:15 <fasta> frigga: it can do that because it is _small_.
13:25:54 <elliott> take it to -blah if you really have to talk about how much better smalltalk is
13:26:07 <fasta> elliott: I wasn't talking about popularity. You might want to respond to the original point; that installation of one other tool with comparable 'power' is much faster.
13:26:53 * shergill ignores fasta
13:27:04 <elliott> This isn't #haskell-vs-other-languages, so I don't feel compelled to... but obviously trying to tell you this is pointless, so I'll shut up for the benefit of others.
13:27:17 <byorgey> LOOK A MONKEY!
13:27:24 <fasta> elliott: if you point out true statements like 'Smalltalk is not very popular because of its image based development model' and 'the sky is sometimes blue' then it isn't really interesting to discuss anything with you.
13:27:32 <byorgey> and now back to your regularly scheduled #haskell
13:27:44 <morel> which meaning does '#' have at the beginning of lines of literate-haskell-code ?
13:27:56 <koeien> morel: none that I know of.
13:28:01 <byorgey> morel: no special meaning that I know of
13:28:03 <elliott> morel: might be CPP
13:28:12 <morel> ah, okay.
13:28:12 <koeien> yes, preprocessing
13:28:19 <nand`> morel: might be a comment in whatever layer may be around it
13:28:20 <morel> because my editor highlights it; thanks.
13:28:37 <mm_freak> it isn't ignored, hence the big problem with markdown and literate haskell
13:28:41 <shergill> morel: cpp or comment. context might make it clearer
13:28:56 <shergill> um wrapped comment
13:29:01 <elliott> it could also be a shebang
13:29:04 <elliott> i.e. #!/usr/bin/env runhaskell
13:29:47 <shergill> ah true
13:30:13 <mm_freak> it seems to be interpreted
13:30:23 <mm_freak> so it's probably not shebang
13:30:28 <mm_freak> and not CPP either
13:31:00 <fasta> elliott: and again, I wasn't discussing Haskell vs other languages. I was discussing Haskell installation tools vs other language installation tools. So, in short, nothing what I have said was false in any way and in fact can be verified easily. That you made the mistake to discuss obviously true facts is your problem. So, next time, please respond as if you actually have a clue as to what you are talking about. It makes the channel look stupid.
13:31:27 <elliott> someone definitely looks stupid here
13:31:50 <morel> is it fasta ?
13:31:51 <ion> Indeed
13:32:05 <nand`> Haskell installation tools?
13:32:06 <morel> ion: did you response to me? :)
13:32:51 <nand`> I downloaded the haskell platform, clicked a few buttons and it worked out of the box. So does cabal. I don't know what this argument is about though nor do I wish to become more involved
13:33:27 <fasta> Exactly, you don't understand the argument.
13:33:43 <nand`> fasta: then do me a favor and spare me the details
13:33:50 <fasta> nand`: gladly.
13:33:58 <ion> morel: Well, i answered to elliott, but having not read the discussion he’s metadiscussing, i can only tell that elliott’s certainly not the one his tone of discussion causes to look stupid.
13:34:24 <fasta> ion: people that don't know anything always look to the tone.
13:34:42 <elliott> copumpkin: this is getting really old
13:34:43 <qpu> maybe you should change your tone
13:35:17 <alkoma> hello world!
13:35:21 <koeien> hi
13:35:23 <byorgey> hi alkoma!
13:35:25 * shergill reminds people there *is* an ignore button. i'm assuming fasta is still carrying on with his wise ways
13:35:26 <morel> hi
13:35:49 <alkoma> I am on chap10 of real world haskell, and I don't remember anywhere it mention array.  is there such a thing in Haskell.
13:36:01 <koeien> Yes there is. it's not used as often though
13:36:03 <elliott> alkoma: there are, but they're not the most common structure
13:36:04 <byorgey> alkoma: yes, there is.
13:36:04 <rostayob> alkoma: yes
13:36:09 <elliott> because functional structures have advantages like sharing
13:36:09 <morel> it's usually called a "list", afaik,
13:36:10 <koeien> (as in C / Python / whatever)
13:36:12 <morel> but yes.
13:36:13 <nand`> alkoma: if you're new to haskell I recommend considering http://learnyouahaskell.com/ as well
13:36:18 <koeien> morel: no. lists are different.
13:36:19 <elliott> morel: erm...
13:36:21 <elliott> no, [] is a linked list
13:36:26 <rostayob> alkoma: look up the array package (Data.Array). there are both mutable and immutable arrays in the ST monad
13:36:30 <nand`> haskell has a few types to represent what you want
13:36:35 <rostayob> a popular alternative is the vector package
13:36:37 <mm_freak> morel: apparently there is a bug in the unlit program that keeps paragraphs starting with '#'
13:36:40 <byorgey> you don't need a monad for immutable arrays.
13:36:41 <elliott> alkoma: the vector and repa packages are the most commonly-used arrays nowadays; the latter is n-dimensional and has fancy automatic parallelisation and the like
13:36:42 <morel> so, you differenciate between array and list?
13:36:47 <elliott> (repa is built on top of vector)
13:36:50 <koeien> morel: yes
13:36:51 <byorgey> and immutable arrays are stil quite useful, e.g. for dynamic programming
13:36:56 <mm_freak> morel: http://hackage.haskell.org/trac/ghc/ticket/4836
13:36:57 <elliott> morel: [] is a singly-linked boxed list
13:37:02 <elliott> arrays are contiguous regions of memory
13:37:02 <morel> koeien: arrays are mutable?
13:37:03 <nand`> elliott: automatic parallelisation? Now I'm interested
13:37:06 <koeien> morel: no
13:37:12 <nand`> elliott: you mean like folding over the structure in parallel with a combinator?
13:37:12 <alkoma> oh, I see, array automatically implied Imperative, so we don't get there until after Monad.
13:37:15 <koeien> morel: arrays have O(1) access of the n-th element, lists don't
13:37:16 <morel> okay. so [1..5] is a list?
13:37:16 <rostayob> byorgey: yeah I meant to write the other way around (mutable in the ST monad)
13:37:19 <koeien> morel: yes
13:37:20 <byorgey> alkoma: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array.html#t:Array
13:37:24 <elliott> nand`: http://www.youtube.com/watch?v=jBd9c1gAqWs
13:37:31 <rostayob> alkoma: no you don't need any monad to have an array
13:37:32 <rostayob> :t array
13:37:34 <elliott> nand`: real-time raytracing automatically parallelised with repa :)
13:37:35 <rostayob> oh right
13:37:42 <elliott> (source at http://code.ouroborus.net/gloss/gloss-head/gloss-examples/Ray/)
13:37:43 <ion> Lists can be infinite more easily than arrays.
13:37:47 <nand`> elliott: figured from the video title
13:37:55 <morel> koeien: okay. i got it.
13:38:02 <elliott> nand`: hehe
13:38:10 <nand`> that looks neat though
13:38:17 <alkoma> interesting ... i will keep reading ...
13:38:28 <nand`> does it have fancy stuff like global illumination
13:38:34 <alkoma> also thanks for the suggestion about the other haskell book.
13:38:38 <koeien> alkoma: because of laziness we use lists more than arrays typically. but you can use them.
13:38:51 <morel> @src (:)
13:38:52 <alkoma> i am thinking about matrix.
13:38:53 <nand`> alkoma: it's best to decide based on the situation
13:39:20 <nand`> there are a few matrix packages as well
13:39:22 <koeien> morel: lambdabot is down :(. and : is a constructor
13:39:25 <nand`> eg. hmatrix
13:39:44 <arcatan> also lists are often easier to work with. you can use pattern matching with them etc.
13:39:48 <koeien> morel: data [] a = [] | : a [a]
13:39:51 <elliott> repa is nicer than hmatrix if you don't need the specific implementations
13:39:57 <elliott> encodes shape in the type, etc.
13:40:04 <mm_freak> ion: let's say lists can be infinite, arrays can't =)
13:40:26 <koeien> repa doesn't do everything
13:40:46 <koeien> hmatrix has bindings to useful matrix functions
13:40:57 <ion> mm_freak: I keep adding address lines and RAM chips to my computer forever.
13:40:57 <morel> koeien: so, (:) is "hard-coded" ?
13:41:03 <koeien> morel: no
13:41:09 <mm_freak> arcatan: that's not strictly true…  there are use cases of both lists and arrays where one is easier than the other
13:41:19 <eyebloom> does anyone have experience mouse dragging a shape with HOpenGL?
13:41:20 <koeien> morel: you can write your own constructor like that
13:41:26 <mm_freak> ion: is that physically possible?
13:41:33 <rostayob> morel: (:) is actually hard coded, but you can pretend it isn't
13:41:36 <morel> koeien: okay. but (:) is defined through the definition of a list, right? it's a constructor of a list, okay
13:41:36 <alkoma> ... I found the repa and hmatrix doc on hackage - thanks guys!
13:41:39 <koeien> morel:   data Test = Integer :: Integer
13:41:49 <koeien> err
13:41:51 <elliott> alkoma: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial is the best way to get started with repa
13:41:53 <koeien> morel:   data Test = Integer :+ Integer
13:41:58 <morel> :)
13:42:15 <rostayob> morel: you can't define constructors like the list ones manually, but you can get close
13:42:15 <morel> yea, you define (:+) as the constructor of Test, okay, i see.
13:42:26 <mm_freak> alkoma: which GHC version do you have?
13:42:32 <koeien> morel: yes!
13:42:36 <rostayob> mm_freak: yeah
13:42:36 <koeien> morel: [] is special though
13:42:39 <alkoma> mm_freak: i use the latest haskell-package
13:42:39 <morel> rostayob: ah, okay
13:42:41 <rostayob> ops, that was for morel
13:42:47 <koeien> morel: and the list syntax [1,2,3,4], which is sugar for 1:2:3:4:[]
13:42:49 <alkoma> mm_freak: umm i mean haskell-platform
13:42:54 <mm_freak> alkoma: i don't know what GHC version that has…  ghc --version
13:42:55 <rostayob> koeien: well, [..] is sugar
13:42:59 <morel> koeien: yep
13:43:00 <nand`> eyebloom: that makes me think, would it be possible to access the depth buffer or something to figure out which element you clicked on based on some sort of reverse depth lookup?
13:43:05 <rostayob> for a non-existant Nil constructor or something like that :P
13:43:16 <nand`> for a small number of elements it may just be faster to go through a list though
13:43:21 <rostayob> morel: but yeah the answer to "is it hard-coded" is "yes"
13:43:26 <alkoma> mm_freak: it's 7.0.4
13:43:33 <Ralith> nand`: the best route is to do a ray-test on the CPU side
13:43:34 <eyebloom> nand': One would set the depth to zero for the reverse lookup.
13:43:45 <morel> rostayob: okay. koeien: :P
13:43:48 <hpaste> eyebloom pasted “OpenGL Drag” at http://hpaste.org/56972
13:43:55 <eyebloom> See my code
13:44:02 <mm_freak> alkoma: then i'm afraid you won't get the latest repa to work…  and the last version of repa to work with 7.0.* requires vector 0.7, which is also outdated…  i suggest starting with the vector package instead
13:44:12 <eyebloom> It kinda works
13:44:16 <shergill> while we're on the topic, any benefit of hmatrix over repa? i'm more concerned about efficiency
13:44:31 <mm_freak> shergill: hmatrix uses an efficient C library under the hood
13:44:44 <shergill> (this is for a statistics project i want to get started on)
13:44:45 <alkoma> mm_freak: do you think it's better I just build ghc myself?
13:44:50 <shergill> ah k thanks mm_freak
13:44:54 <mm_freak> alkoma: not really
13:45:06 <mm_freak> alkoma: but don't worry…  repa is still very experimental
13:45:09 <nand`> would hmatrix be faster for running lots (millions) of 3x3 matrix calculations, ideally in parallel?
13:45:09 <koeien> shergill: hmatrix does SVD's for example, i don't think repa does
13:45:18 <rostayob> alkoma: the best way is to download the pre-compiled binaries
13:45:19 <nand`> by calculations I mean multiplication
13:45:30 <alkoma> mm_freak: great, i will try that first then.
13:45:30 <elliott> mm_freak: you can just install old repa
13:45:33 <shergill> koeien mm_freak: i'm guessing it relies on lapack?
13:45:36 <mm_freak> nand`: likely a hand-parallelized hmatrix operation is faster than using repa
13:45:44 <elliott> imo the new version should have waited until 7.2 was more widely-installed
13:45:46 <koeien> shergill: yeah and GSL
13:45:48 <mm_freak> elliott: old repa depends on vector 0.7, which is very unfortunate
13:45:58 <rostayob> is lapack the FORTRAN thing?
13:45:59 <mm_freak> elliott: and yes, i agree
13:46:13 <morel> so, having a list with constant length, under which further pre-condition it'd be better to use an array instead of that list ?
13:46:18 <koeien> rostayob: yes.
13:46:25 <mm_freak> morel: not necessarily
13:46:30 <elliott> morel: random access
13:46:41 <elliott> or wanting smaller space usage
13:46:42 <rostayob> koeien: how is it possible that those packages are still the standard?
13:46:44 <elliott> and not processing sequentially
13:46:57 <mm_freak> morel: example:  mapM_ print [1..100000]
13:47:00 <hpc> perhaps the list is infinite?
13:47:03 <mm_freak> here a list is clearly better
13:47:09 <koeien> rostayob: because it works?
13:47:09 <hpc> (infinity is totally a constant)
13:47:10 <morel> elliott: random access, you mean like list!!number ?
13:47:15 <koeien> rostayob: it's well-tested
13:47:20 <rostayob> koeien: yeah but... it's FORTRAN...
13:47:23 <elliott> morel: yes, which is O(n)
13:47:30 <nand`> morel: O(1) random access, under the condition that you need to access elements multiple times
13:47:33 <elliott> if you use (!!) a list is generally the wrong choice
13:47:35 <morel> elliott: yes, and an array is O(1)… yep
13:47:37 <koeien> rostayob: FORTRAN can be compiled to very efficient code
13:47:40 <shergill> rostayob: and it's fast
13:47:43 <nand`> if you just need to access each element once in random order it may be faster to just not store an array at all
13:47:49 <koeien> rostayob: i don't see the problem really.
13:47:58 <morel> elliott: great, thanks :)
13:47:59 <nand`> depending on how it's generated
13:48:00 <mm_freak> morel: it still highly depends on what you want to do
13:48:03 <koeien> rostayob: for matrix multiplications i want very efficient code
13:48:07 <koeien> and other matrix operations
13:48:13 <mm_freak> morel: often even in the constant length case lists are better
13:48:21 <rostayob> koeien: I've had little experiences with those things and they were very nasty to work with. but again not much experience, so ok
13:48:40 <nand`> lists are also bad if you want to append to the end a bunch of times
13:48:42 <morel> mm_freak: hm. i'll think about that.
13:48:44 <koeien> rostayob: hmatrix is a breeze
13:48:49 <rostayob> nand`: you can just reverse at the end
13:48:51 <koeien> it's totally awesome
13:48:54 <rostayob> or use a difference list
13:49:03 <nand`> rostayob: yeah, or use nested lambdas or something
13:49:06 <hpc> or build the list differently
13:49:07 <rostayob> koeien: yeah because it hides the uglyness :)
13:49:15 <koeien> right :) and the memory management
13:49:21 <nand`> how easily are arrays resized anyway
13:49:27 <alkoma> "Contraints on Type Definitions Are Bad"  - that is a section in RWH - it remind me of the dicussion happening here last night.
13:49:35 <hpc> nand`: it involves a copy, iirc
13:49:39 <rostayob> hpc: difference lists = build the list differently :)
13:49:52 <hpc> rostayob: i meant in the "change your algorithm" sense :P
13:50:04 <rostayob> well some algos are append-heavy
13:50:16 <hpc> ie, (foo . bar . baz) vs (foo ++ bar ++ baz)
13:50:41 <elliott> hpc: growing a mutable array /might/ not do a copy, perhaps
13:50:48 <elliott> although I don't know if it's implemented in that way
13:52:33 <rostayob> hpc: yeah that's what difference list appending look like!
13:52:45 <rostayob> *looks
13:52:47 <hpc> rostayob: bad example :P
13:59:43 <nand`> is there ever any incentive to use (!! 0) over head
13:59:56 <koeien> no
14:00:08 <hpc> nand`: obfuscation contests
14:00:22 <nand`> I'm wondering why the write yourself a scheme does it
14:00:38 <elliott> maybe there are other lines close to it that use (!! n) for other n?
14:00:40 <elliott> i.e. consistency
14:01:04 <hpc> perhaps whoever wrote the tutorial got the wrong lesson out of "don't use head if you don't have to"
14:01:07 <nand`> one of the first examples: main = do args <- getArgs; putStrLn (readExpr (args !! 0))
14:01:24 <koeien> yeah, makes no sense
14:01:28 <nand`> could have been so much cleaner as just getArgs >>= putStrLn . readExpr . head
14:01:38 <koeien> yup
14:01:45 <monochrom> you can easily change 0 to 5 for experiments
14:01:52 <koeien> (unless args is used elsewhere)
14:02:03 <nand`> I suppose so
14:02:28 <hpc> nand`: i would flip the bind there, so the line "flows in one direction"
14:02:32 <monochrom> in lisp, you can easily change car to caddddr for experiments
14:02:51 <hpc> monochrom: i think it's a read macro, even
14:02:54 <nand`> hpc: maybe getArgs >>= head >>> readExpr >>> putstrLn
14:03:02 <monochrom> however, you can't easily change head to heeeead for experiments. or is it heaaaaad?
14:03:11 <koeien> whaha
14:03:29 <nand`> good idea. why isn't that a prelude function
14:03:46 <ion> caddddaver
14:03:54 <ocharles> headtaiheataitaihead
14:03:55 <monochrom> because they are still arguing whether it is heeeead or heaaaad
14:04:06 <nand`> heeeaaaaad would be something like the third head of the fifth tail
14:04:19 <nand`> if lisp is to be trusted
14:04:25 <monochrom> like the state of record system. of course everyone wants one. of course everyone wants a different one
14:04:33 <elliott> monochrom: heeeeaaaad
14:04:43 <ocharles> in b4 mappend operator
14:04:50 <CodeWeaver> Wait… isn't this something you could do with template haskell?  Generate some arbitrary but finite list of heeeeead and heaaaaad functions?
14:04:59 <monochrom> yes
14:05:06 <nand`> elliott: and if the e and a aren't equal in length it's undefined, just to make your error searching more difficult
14:05:16 <elliott> :|\/|/-\|-|-|=|\||}: is my preferred mappend operator
14:05:16 <CodeWeaver> *gets evil eye*
14:05:19 <shergill> haha
14:05:21 <elliott> er, without the :
14:05:28 <elliott> hmm, that's too hard to read for a joke :)
14:05:37 <monochrom> haha elliott wins
14:05:40 <nand`> eh personally (++) should be redefined as mappend and the Monoid instance for [] should be pulled into prelude
14:05:45 <elliott> (it says "MAPPEND")
14:06:14 <elliott> monochrom: of course, that's 8. you ask, which distribution of e/a is it for 7?
14:06:19 <CodeWeaver> You're slightly demented.  You know that right elliott? :D
14:06:27 <elliott> the answer is that there is no pattern. they all use their own unique distribution of e anda
14:06:42 <nand`> no no guys
14:06:44 <nand`> e and a are binary bits
14:06:53 <nand`> 7 would be haaad
14:06:54 <nand`> clearly
14:06:56 <elliott> head, heead, heaaad, heeeaad
14:07:06 <nand`> or heaaad
14:07:16 <monochrom> @remember elliott |\/|/-\|-|-|=|\||} is my preferred mappend operator
14:07:19 <elliott> heeeeeeeeeeeeeeeeeeeeeeeead
14:07:30 <elliott> monochrom: no lambdabot. you should @tell yourself to @remember it later
14:07:41 <nand`> head, heaed, heaad, heaeed, ...
14:08:07 <monochrom> there is a bit of a boostrapping problem with @tell if lambdabot is away
14:08:25 <nand`> can haskell solve this problem
14:08:42 <monochrom> the answer is yes! haskell can do that
14:08:50 <nand`> correct.
14:09:00 <nand`> we just don't know enough mathematics yet
14:09:24 <elliott> preflex: tell lambdabot hey monochrom, you can @remember that now!
14:09:25 <preflex>  Consider it noted.
14:09:36 <monochrom> test
14:09:41 <elliott> i told lambdabot, not you
14:09:44 <elliott> preflex: tell monochrom test
14:09:44 <preflex>  Consider it noted.
14:09:52 <monochrom> test again
14:09:53 <preflex>  monochrom: you have 1 new message. '/msg preflex messages' to read it.
14:09:56 <elliott> aww
14:09:57 <monochrom> sweet
14:09:59 <elliott> i was hoping it'd give them inline
14:10:12 <elliott> ... does this mean preflex will bother lambdabot every time it comes online?
14:10:18 <nand`> elliott: that wouldn't be nearly as annoying
14:10:32 <monochrom> preflex: tell monochrom redo @remember elliott |\/|/-\|-|-|=|\||} is my preferred mappend operator
14:10:32 <preflex>  what
14:10:42 <monochrom> what?
14:10:45 <elliott> :D
14:10:49 <nand`> preflex: tell monochrom redo @remember elliott |\/|/-\|-|-|=|\||} is my preferred mappend operator
14:10:49 <preflex>  Consider it noted.
14:10:58 <elliott> let's just pass it around the channel
14:11:03 <elliott> everyone tells the person below them in the nick list
14:11:09 <elliott> until it reaches monochrom
14:11:13 <nand`> okay, but paraphrased
14:11:14 <monochrom> hahaha
14:11:15 <elliott> if lambdabot isn't back yet, monochrom just has to set it off again
14:11:34 <shergill> heh
14:11:39 <shergill> haha
14:11:40 <nand`> might as well pass the time until she's back
14:12:39 <elliott> <elliott> tell person1 if you're monochrom, remember to remember that thing! [... twelve hours pass ...] <person872> tell monochrom gobble the dawn it's in the plastic
14:13:09 <monochrom> hehehe
14:13:40 <nand`> @hoogle Gibberish -> String
14:14:07 <hpc> @hoogle String -> Cheese
14:14:08 <elliott> nand`: ooh, inspiration strikes m1
14:14:09 <elliott> *me
14:14:14 <elliott> thanks
14:15:01 <nand`> elliott: it had better be a plaintext -> artificial pseudo-language translation function based on letter combinations, vowel patterns, diphthongs and hashes
14:15:16 * nand` wants a gnomish function
14:15:53 <elliott> nand`: almost as good as that
14:20:36 <CodeWeaver> I'm not *entirely* sure, but I may have been able to improve on the 2,3,5 thing using Data.List.Stream (to encourage fusion).
14:22:26 <CodeWeaver> Would anybody build it if I posted it?
14:23:26 <nand`> CodeWeaver: post the code and I'm sure raw curiosity will play its course for you
14:24:00 <cmccann> curiosity and/or the urge to quibble over details
14:24:17 <hpc> CodeWeaver: can't you build it yourself?
14:24:21 <nand`> not to mention competition
14:24:32 <nand`> hpc: I believe he was having touble getting LLVM to work or something
14:24:35 <CodeWeaver> hpc: yes, but to verify on someone else's platform.
14:24:36 <hpc> ah
14:24:47 <nand`> oh, did you get LLVM working then?
14:25:08 <elliott> What does newCString do with non-ASCII characters?
14:25:20 <elliott> ah, it uses the "foreign encoding", whatever that is
14:25:29 <CodeWeaver> I got LLVM working after installing the osx support binaries and also going to xcode 3.2 to minimize any glitches.
14:25:45 <nand`> elliott: sounds like it truncates
14:25:47 <CodeWeaver> And it made a huge huge difference.  Instantly my time was cut in half.
14:25:51 <CodeWeaver> At least.
14:25:55 <CodeWeaver> On this puzzle anyway
14:26:17 <shergill> CodeWeaver: project euler?
14:26:29 <elliott> nand`: newCString = GHC.newCString foreignEncoding
14:26:33 <elliott> so some encoding stuff is going on
14:27:03 <elliott> there's also "charIsRepresentable :: Char -> IO Bool", hmm.
14:27:28 <nand`> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Encoding.html
14:27:35 <CodeWeaver> shergill:  the puzzle may have originally come from that, but I use it as an interesting if forced performance benchmark puzzle.  In my adaptation, I try to generate ten million elements of a particular series, and make sure they're all stored and active in the computer for later query (say, in an unboxed array, or fully dethunked container of some sort)
14:27:46 <nand`> elliott: “The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the 'CString' marshalling functions in "Foreign.C.String"”
14:28:09 <elliott> ah
14:28:14 <elliott> ok, so probably utf-8 in most cases
14:28:53 <shergill> CodeWeaver: fibonacci series?
14:29:25 <nand`> elliott: depends on currentCodePage
14:29:28 <alkoma> any emacs haskell-mode expert here? is it possible to setup ...
14:29:49 <hpaste> CodeWeaver annotated “2,3,5 sequence in C, to port to haskell” with “2,3,5 sequence in C, to port to haskell (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/56932#a56973
14:29:49 <nand`> elliott: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/GHC-IO-Encoding-CodePage.html for the relevant functions
14:29:55 <alkoma> haskell-mode so that I can jump to func def other than those of my own?
14:30:07 <nand`> mkCodePageEncoding
14:30:25 <CodeWeaver> Okay, so this uses a different technique for producing unique numbers, but I could never ever get it fast enough before. The generate-all-ints-and-test was easily faster.
14:30:29 <CodeWeaver> Now it seems this way is faster.
14:30:51 <CodeWeaver> Note that this does depart from the C algorithm, which maybe I'll adapt to this solution so a direct comparison is possible.
14:31:25 <elliott> nand`: would be nice if there was a portable way to request latin-1
14:31:41 <CodeWeaver> I'm getting 0.295s (approx) and that includes summing the resulting numbers.
14:31:58 <CodeWeaver> which I did just to make sure there wasn't any magic going on.
14:32:07 <elliott> CodeWeaver: isn't that a lot slower than mm_freak's?
14:32:11 <nand`> >currentCodePage = unsafePerformIO getCurrentCodePage
14:32:11 <nand`> heh
14:32:13 <CodeWeaver> Oh smeg.
14:32:16 <CodeWeaver> It is.
14:32:20 <CodeWeaver> I'm out by a factor of 10.
14:32:24 <CodeWeaver> Or 5 anyway.
14:32:31 <CodeWeaver> I'll go hide now.
14:32:57 <shergill> ah
14:33:11 <shergill> multiples of 2, 3 and 5. yeah it's from project euler
14:33:12 <CodeWeaver> This doesn't beat my own previous solution which finally got down near the best yesterday.
14:33:29 <CodeWeaver> Nothing to see here!  Move along!
14:34:25 <nand`> elliott: isn't latin1 just the first 256 unicode code points
14:37:46 <michal_> Anybody knows how to use state monad with multiple mutable arrays? I'd like to accumulate some results into different arrays, but I either have to create them after state is given (and thus add unnecessary Maybe), or use IO monad...
14:38:21 <michal_> and btw, what is the best way to track stack overflow in a large program?
14:38:22 <nand`> State (a, a) is one option
14:38:47 <Botje> michal_: can't you split the computations that tell you how big to allocate your array off?
14:39:22 <nand`> State [a] is another, or even State (Array Array) or something
14:41:06 <michal_> Botje: I have to grow my arrays on demand anyway. Problem is allocating "initial" mutable arrays as a state component. My state has to hold at least 4 arrays that may grow, and additional attributes
14:41:38 <bgamari> David Terei around?
14:41:55 <Botje> michal_: if you're not going to access them beforehand you can pass in undefined
14:42:15 <Botje> but what nand` suggests is probably more san.e
14:42:25 <michal_> no, I am not accessing beforehand... let's try it.
14:42:30 <c_wraith> michal_: What I want to say here is that State over a mutable array doesn't make a whole lot of sense.
14:42:33 <bgamari> or does anyone know his nick?
14:42:46 <c_wraith> StateT IO over a mutable array makes much more sense, relatively
14:42:51 <michal_> why do you think it wouldn't make sense?
14:43:11 <michal_> Not sure: the point is to parse :: String -> ComplexRecord
14:43:31 <c_wraith> because there are basically no functions that take in a mutable array and return a mutable array
14:43:36 <michal_> then I would unsafeFreeze my mutable arrays after parsing is done
14:43:39 <c_wraith> instead, they return IO actions
14:44:11 <michal_> @lambdabot type Data.Vector.Mutable.write
14:44:19 <c_wraith> and if you don't have functions that return mutable arrays, you really can't do anything with them in State
14:44:51 <alpounet_> bgamari, he's not often on IRC, and when he is it's mostly on #ghc under "dterei", but you should contact him by email
14:45:02 <michal_>  Data.Vector.Mutable> :t write
14:45:02 <michal_> write
14:45:02 <michal_>   :: Control.Monad.Primitive.PrimMonad m =>
14:45:02 <michal_>      MVector (Control.Monad.Primitive.PrimState m) a -> Int -> a -> m ()
14:45:40 <c_wraith> michal_: that's my point. the return type is «m ()», not «a»
14:46:16 <michal_> Because MVector is a reference here, later you do:
14:46:45 <michal_> Data.Vector> :t unsafeFreeze
14:46:45 <michal_> unsafeFreeze
14:46:45 <michal_>   :: Control.Monad.Primitive.PrimMonad m =>
14:46:45 <michal_>      MVector (Control.Monad.Primitive.PrimState m) a -> m (Vector a)
14:47:03 <c_wraith> I'm not saying you don't understand how to use Vector
14:47:10 <c_wraith> I'm saying you don't understand what State is
14:47:18 <michal_> ?
14:47:27 <kallisti> State would be useful to hold a structure of all the array references.
14:47:33 <kallisti> if they're passed around frequently
14:47:37 <kallisti> to many different functions
14:47:49 <c_wraith> State is an abstraction over the process of passing state values around between functions
14:47:51 <nand`> newtype State s v = State { runState :: s -> (v,s) }
14:48:14 <michal_> yeah, but I also see a point in using state transformer to get a pure function out of primitives affecting state
14:48:18 <c_wraith> It's not related to *anything* to do with mutability
14:48:20 <michal_> runST style
14:48:29 <michal_> as far as I recall
14:48:41 <elliott> hmm, is the Haddock Portability field documented anywhere?
14:48:45 <nand`> statefulFunction state = (value, newstate)
14:48:46 <elliott> I can't even find an official mention of the syntax
14:48:48 <bgamari> alpounet_: Thanks
14:49:18 <michal_> I basically want to use mutable arrays outside IO monad, and I believe this is the way, isn't it?
14:49:25 <elliott> no
14:49:26 <c_wraith> No
14:49:27 <elliott> the way is to use ST
14:49:33 <elliott> the way you're doing won't work
14:49:37 <elliott> you can't escape from IO into State
14:49:40 <elliott> you're thinking of ST
14:49:53 <nand`> unsafePe-- y'know what I'll just shut up
14:49:58 <elliott> yes, do :)
14:50:00 <michal_> okay, so I got the wrong name. Good that the types were inferred by compiler :-D
14:50:13 <c_wraith> This is a case where I wish DiffArray had worked out better.
14:50:28 <c_wraith> DiffArray is a brilliant idea, but just too slow in practice
14:50:36 <c_wraith> Too many layers of abstraction and locking
14:50:42 <michal_> no, I just want to have a quick append, and I know that there is a sequential thread of control.
14:51:09 <c_wraith> append?
14:51:10 <elliott> what was DiffArray, again?
14:51:11 <michal_> The other thing however, is that I know, that I may be keen of parsing many Strings in parallel - and then it is better to live in some other monad, not IO
14:51:14 <c_wraith> You don't even want arrays, then
14:51:17 <elliott> michal_: quick append?
14:51:19 <elliott> you want a tree structure
14:51:20 <nand`> if you're only appendinding you can just reverse it later
14:51:26 <michal_> I tried with lists, and got very slow program
14:51:32 <nand`> -ind
14:51:48 <elliott> that's a list problem
14:51:56 <elliott> the solution to a list problem isn't always an array
14:52:00 <elliott> because that could get you an array problem instead
14:52:13 <nand`> elliott: isn't that where the process of appending stuff gets turned into a function which then finally get executed in reverse order
14:52:15 <elliott> instead of, e.g. a finger-tree solution
14:52:23 <michal_> the problem is not parsing a 1MB, but 50MB of text, and then squeeze it into a neat strict structure so that it doesn't blow the stack when trying to fold over it several times
14:52:30 <elliott> nand`: that's difference list... i guess you can apply the same technique to arrays
14:52:42 <nand`> oh, DiffArray
14:52:43 <c_wraith> elliott: DiffArray was putting a pure interface on top of mutable arrays, via use of voodoo involving difference lists for pointers that were not current.
14:52:50 <elliott> c_wraith: cool
14:52:54 <elliott> michal_: Text or ByteString? however you won't get efficient append
14:53:08 <rwbarton> DiffArray is this thing where you do array updates in place by replacing pointers to the old value with a way to recover the old array from the new array
14:53:15 <rwbarton> yeah
14:53:19 <rwbarton> if that made sense at all
14:53:34 <elliott> it doe
14:53:36 <elliott> s
14:53:40 <elliott> yes, it doe
14:53:40 <elliott> s!
14:53:40 <c_wraith> elliott: in theory, so long as you only ever access the most recent version, it gives O(1) updates and O(1) lookups.  But the constants were bad.
14:53:44 <michal_> aha, so maybe DiffArray would help for easier interface, but I know there is a unique (linear) use of these arrays anyway
14:53:50 <nand`> reminds me of a list structure I made for an imperative, immutable-data programming language a while back
14:53:52 <michal_> ByteString is input
14:54:12 <elliott> Does anyone know if there is any official documentation of the Portability field in haddocks? :/
14:54:20 <elliott> or any of the fields that end up in that top-right box
14:54:47 <michal_> no idea
14:54:48 <c_wraith> michal_: use State around Data.Sequence instead, or something
14:55:24 <guerrilla> michal_: btw, http://stackoverflow.com/a/5545599/161937
14:56:41 * hackagebot yesod-auth-fb 0.10 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-0.10 (FelipeLessa)
14:58:07 <michal_> thx guerila
14:58:30 <michal_> as for c_wraith: that would be just slower
14:58:47 <elliott> no it won't
14:58:48 <elliott> if you need fast append
14:58:54 <c_wraith> but it would work. fast and wrong isn't fast. :)
14:59:16 <kallisti> Sequence has O(1) push to both ends.
14:59:20 <elliott> michal_: you are going to be copying all fifty megabytes whenever you append
14:59:32 <DanBurton> Sequence is a magical data structure
15:00:39 <michal_> but ByteString is input, I do not append to it.
15:01:00 <elliott> I was talking about your array
15:01:11 <michal_> and by the way (because I forgot): why are not Sequences the default in Prelude instead of lists, and ByteString or Text a default string instead of [Char]
15:01:20 <michal_> is it just a way to look cooler to students?
15:01:40 <nand`> because lists are very useful
15:01:47 <kallisti> if you need to frequently resize your structure as well as I have decently fast random access then Sequence is not a bad fit.
15:01:49 <c_wraith> michal_: list, along with lazy evaluation, is a model of loops
15:02:03 <nand`> Sequences can't be infinite, for example
15:02:11 <michal_> nope, for the array I have a nice default size that fits 99% of the bill, and if I extend, I do it with amortized O(1) time trick (double the size each time)
15:02:20 <c_wraith> and in particular, it's a *minimal* reification of loops as data structures.
15:03:04 <michal_> main advantage is probably to freeze it, and have a memory efficient data structure later (given my desire to put more of these creatures into memory)
15:03:33 <morel> is there a function which does the same as "\f x -> last $ iterate f x" ?
15:03:48 <morel> fuck
15:03:49 <morel> i mean
15:03:56 <rwbarton> no
15:03:59 <morel> is there a function which does the same as "\f x i -> last $ take i $ iterate f x" ?
15:03:59 <kallisti> takeWhile condition . iterate f $ x
15:04:04 <kallisti> is probably what you want
15:04:05 <kallisti> or something similar
15:04:10 <c_wraith> !!
15:04:13 <kallisti> or that
15:04:16 <morel> oops
15:04:17 <michal_> c_wraith: I don't care about "models", since I finished teaching students few years ago. What I care, is whether it works, or not really. It seems that it gives inefficiency all over, since most of the time, when you have a string, it doesn't have to be overly lazy.
15:04:17 <morel> heh
15:04:26 <kallisti> depends on how you want to grab the element
15:04:39 <kallisti> er actually
15:04:47 <kallisti> head . dropWhile condition . iterate f $ x
15:04:49 <kallisti> or something like that
15:04:53 <c_wraith> michal_: well, yes, *String* is horrible.  But you said lists.  List are great.  type String = [Char] is terrible
15:04:54 <morel> so, is there a function which does the same as "\f x i -> iterate f x !! i" ?
15:04:56 <kallisti> again depending on what criteria you're looking for.
15:05:03 <c_wraith> morel: nope.
15:05:10 <elliott> hmph, yes, it's indeed not documented at all
15:05:23 <michal_> I will think about Data.Sequence by default in the future though. Nice to be lazy and not to overoptimize
15:05:24 <morel> c_wraith: why not? it's cool!
15:05:45 <kallisti> michal_: Sequence operations are strict
15:05:56 <elliott> michal_: Sequence is not lazy.
15:05:56 <rwbarton> Because you can already build it easily out of Prelude-defined pieces (as you can see).
15:06:06 <michal_> c_wraith: so we agree. would be great to have efficient data structures by default in Prelude
15:06:22 <elliott> Move Sequence into Prelude, but discouraging lists is wrong.
15:06:23 <nand`> michal_: because there's no need to make haskell more like C. If you need seq for performance reasons, use seq and not [char]
15:06:27 <c_wraith> lists are efficient structures
15:06:36 <kallisti> michal_: the efficiency of a data structure is a function of the problem domain.
15:06:37 <c_wraith> for any sort of looping
15:06:40 <elliott> Lists are perfectly efficient when used correctly, and Haskell's most common control structure.
15:06:42 <nand`> and by seq I meant Seq and not seq
15:06:46 <michal_> rwbarton: But it takes time and unreasonable number of imports to get everything before you start writing your one-liner script...
15:06:48 <kallisti> lists are well-suited to linear processing of possibly indefinite amounts of data.
15:06:54 <rwbarton> I wasn't talking to you, sorry
15:07:10 --- mode: anthony.freenode.net set +o ChanServ
15:07:12 <rwbarton> but anyways, really?
15:07:19 <rwbarton> in what language do you not need to import things sometimes
15:07:23 <c_wraith> lists are inefficient when you try to use them as a different data structure, sure.
15:07:25 <nand`> PHP
15:07:30 * elliott wonders whether an FFI binding that requires a specific libc but doesn't use any language extensions beyond the FFI itself is "non-portable" or "portable" for the portability field
15:07:31 <c_wraith> Fortunately, there are other data structures out there.
15:07:39 <nand`> because it has everything in its standard namespace either way
15:07:42 <nand`> including all past versions
15:07:45 <rwbarton> the Prelude is fixed to be whatever the standard says it is AFAIK for some reason
15:07:50 <Veinor> rwbarton: i do import a lot more things in haskell than in other languages
15:08:01 <Veinor> like, i'll usually have 10+ lines of imports
15:08:02 <michal_> Honestly saying, in Python I usually import what I really need, instead of redefining and hiding Prelude all the time?
15:08:05 <rwbarton> #include <stdio.h>
15:08:07 <Veinor> (wlel that's an exaggeration)
15:08:08 --- mode: ChanServ set +o mauke
15:08:14 <elliott> michal_: who hides Prelude?
15:08:16 --- mode: mauke set +b $a:fasta
15:08:19 --- mode: mauke set -o mauke
15:08:24 <elliott> the only things you ever need to hide from Prelude are (.), id, catch
15:08:29 <elliott> mauke: that's impossible!
15:08:32 <nand`> wait, is anybody saying imports are bad?
15:08:37 <michal_> Bioinformatics code is like: import Bio.PDB; Bio.PDB.PDBParser(PERMISSIVE=1).get_structure(pdbid, pdbid) and you have it already
15:08:37 <mauke> elliott: inorite
15:08:43 <nand`> imports are good! they mean code is modularized
15:08:44 <Veinor> elliott: why would you hide id?
15:08:55 <elliott> Veinor: Control.Category
15:08:56 <michal_> too many imports of things that should be visible by default.
15:08:56 <c_wraith> Veinor: to use the (.) and id from Control.Category
15:08:57 <nand`> instead of glued into one huge meta-library
15:08:58 <elliott> used with data-lens etc.
15:09:09 <Veinor> ah
15:09:14 <michal_> everybody reads some kind of strings by default, uses some sequences by default etc.
15:09:31 <elliott> "Namespaces are one honking great idea -- let's do more of those!" -- comparing Haskell imports unfavourably to Python imports should be illegal :D
15:09:39 <Veinor> i've never had to use data.sequence
15:09:46 <Veinor> i mean i haven't written a lot of low-level code, granted
15:09:53 <c_wraith> Yeah, I've never used Data.Sequence, either.
15:09:54 <nand`> I've never used Data.Sequence either
15:09:55 <michal_> elliot: I have conflicts between other modules and Prelude most of the time, so I have to import Prelude() or import Prelude hiding(...)
15:10:19 <kallisti> michal_: you can also import OtherModule qualified as M
15:10:26 <kallisti> er
15:10:29 <kallisti> import qualified
15:10:29 <kallisti> rather
15:10:48 <c_wraith> Data.Sequence is good for the operations it supports efficiently, but those are never the operations I've needed efficient access to.
15:10:54 <michal_> elliot: as for libc, I would say "very non-portable" or even "troublesome", since I tried to distribute such a binary once to users.
15:11:20 <michal_> Maybe import qualified...
15:11:30 <elliott> michal_: that's the standard definition of portability, however the field in haddock seems tob e used unievrsally for portability of the code itself
15:11:32 <elliott> *to be, *universally
15:11:36 <elliott> i.e. GHC extensions and the like
15:11:36 <michal_> I do it for most other modules, so that people see what I use from which lib.
15:11:39 * hackagebot happindicator 0.0.4 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator-0.0.4 (AndrewMiller)
15:11:46 <elliott> michal_: you're meant to import other modules qualified anyway
15:11:48 <elliott> like Data.Map
15:11:56 <dainanaki> I'm kind of confused about when to use freeHaskellFunPtr when I export wrapper stubs in Haskell. Could someone clarify for me how to use FunPtrs properly?
15:11:58 <nand`> most of the time when I process strings I process them using folds or pattern matching
15:12:00 <elliott> if you get lots of Prelude conflicts, you're not following standard import practices, usually documented in the modules themselves
15:12:08 <Veinor> Map, ByteString, and Text are almost always imported qualified
15:12:21 <michal_> elliot: yes, I import them qualified, but there are leaks anyway.
15:12:26 <elliott> michal_: like what?
15:12:35 <elliott> btw, two ts :)
15:13:08 <nand`> what's the rule of thumb over when to use “as M” and when to use “(a, b, ...)”? I've been switching over once I import more than three functions
15:13:32 <elliott> nand`: I just import unqualified unless it's a structure or other "clashy" module
15:13:38 <elliott> specifying all the things you import is overkill
15:13:39 <michal_> the main problem with prelude, is that when you start using ByteString/Text, Control.Monad.Exception etc. it suddenly starts conflicting in three different ways on the same identifier. And if they are "trivial" identifiers that everybody knows and uses (splitAt, map), that starts to be verbose.
15:13:48 --- mode: ChanServ set +o mauke
15:13:49 --- kick: fasta was kicked by mauke (get out)
15:13:52 <kallisti> that's a fine rule, though for some data structure modules I just import qualified.
15:14:01 <nand`> elliott: that's what I do for personal/quick/testing code
15:14:44 <michal_> nand: I use "as M", when I want to keep identifiers qualified, and use many of them. Up to 7, I would enumerate.
15:15:19 <nand`> I've never worked with haskell testing frameworks by the way, which I've been meaning to try. Any suggestions?
15:15:20 <elliott> nand`: no reason not to do it for real code too
15:15:22 <elliott> really, it's overkill :)
15:15:32 <elliott> QuickCheck, HUnit are the big ones I think
15:15:41 <elliott> I think test-framework to drive them is popular
15:15:48 --- mode: mauke set -o mauke
15:15:50 <elliott> I've not done much organised testing myself though.
15:16:01 <michal_> elliot: I am not sure how much code you need to write daily, but when you have to make a lot of throwaway experiments and shims before you get it right, then you start to hate Haskell's Prelude and wrongly defined namespaces.
15:16:31 <morel> what's the best way to generate [1,3,6,10,15,21..] == [1,1+2,1+2+3,1+2+3+4,1+2+3+4+5..] == [n*(n-1)/2|n<-[1..]] == map (\x->sum[1..x]) [1..] == … -- ?
15:16:46 <CodeWeaver> Oooh another challenge.
15:16:52 <koeien> morel: scanl
15:16:54 <morel> ah
15:16:55 <morel> yea
15:16:56 <CodeWeaver> heh
15:17:16 <morel> i totally forgot that one; thanks, koeien =)
15:17:17 <koeien> scanl (+) 0 [1..]
15:17:18 <elliott> michal_: as i said, I do not experience this problem and nor do many other Haskell coders, so unless you specify concrete examples of things "falling through the cracks" you're just complaining pointlessly
15:17:31 <nand`> the few things that irk me about GHC's namespaces is that I have to import both Control.Applicative and Control.Monad.Instances for the ((->) r) applicative, and the fact that Applicative and Monoid aren't in Prelude in the first place
15:17:49 <michal_> yes Elliot, possibly I am not using module author's favourite importing practice. that must be wrong :-)
15:17:58 <dibblego> nand`: you should only need Control.Applicative afair
15:18:09 <elliott> michal_: the correct practice is to import data structures qualified
15:18:14 <elliott> that's it
15:18:25 <elliott> why? so that we don't come up with a thousand variations on "lookup" for the same essential operation
15:18:53 <nand`> dibblego: did they change that recently?
15:18:58 <kallisti> michal_: Haskell's import mechanism pretty much makes namespace clashes not an issue.
15:19:09 <nand`> I vividly remember it being like that a while back, seems to be “fixed” in 7.0.4
15:19:09 <kallisti> a mild annoyance if you forget clashing names.
15:19:10 <kallisti> maybe.
15:19:18 <michal_> elliot: ok, I will think about logging my GHC err msgs, and giving you an extract at some point
15:19:21 <dibblego> nand`: I've never heard of needing Control.Monad.Instances for that (maybe you're thinking of ap for ((->) t)?)
15:19:43 <nand`> dibblego: (<*>) for ((->) t) required it a while back
15:19:52 <nand`> which is basically ap but on Applicative
15:19:55 <nand`> so yeah
15:20:02 <dibblego> nand`: I've been using it for years and never needed it
15:20:09 <nand`> hmm
15:20:28 <dibblego> I know that wanting ap on ((->) t) required Control.Monad.Instances though
15:21:49 <michal_> elliot: BTW I always thought that best practice is to use type classes, just like oo guys derive everything from std interfaces. This way you also check consistency, not just naming.
15:21:51 <nand`> what about the Functor instance for that type?
15:22:01 <elliott> michal_: yes, but the problem of typeclasses for containers is a very hard one
15:22:06 <dibblego> yes you need Control.Monad.Instances
15:22:09 <elliott> that a lot of people have failed to solved in a satisfactory manner
15:22:15 <nand`> according to LYAH it's in Control.Monad.Instances, but it works fine for me in ghci 7.0.4 even though I don't have that module loaded
15:22:21 <elliott> so until they do, we use qualified imports, which handle things nicely
15:22:26 <nand`> Prelude Control.Applicative> :t fmap (*3) (+100)
15:22:26 <nand`> fmap (*3) (+100) :: (Num b, Functor ((->) b)) => b -> b
15:22:31 <cmccann> elliott, more importantly it's probably impossible to do with standard haskell
15:22:42 <elliott> cmccann: yes, that too
15:22:51 <elliott> Set and Map and all that
15:22:52 <michal_> elliot: you mean that they are multiparam, sometimes element-type-independent, and sometimes with additional constraints on element-type?
15:22:55 <cmccann> you want MPTCs and fundeps/TFs probably
15:23:14 <elliott> michal_: yes, and how do you handle rigid maps being more efficient than non-rigid maps, and non-rigid maps requiring a different kind to something that supports structures with only rigid maps
15:23:24 <cmccann> it's not a coincidence that a container type class is one of the standard examples of using TFs :P
15:23:28 <elliott> and what laws do you specify for the myriad operations, or if you only specify a small set of operations how do you ensure the complex ones can be implemented efficiently
15:23:35 <elliott> etc. etc. etc. etc.
15:23:43 * lispy waves
15:23:46 <michal_> cmccann: what are TFs? type functions?
15:23:50 <elliott> type families
15:23:54 <cmccann> yes
15:24:45 <cmccann> elliott, we just need a standard Unfoldable type class, then all of our container operations can be done as "fromList . doStuff . toList"
15:24:48 <cmccann> that'll work, right
15:25:36 <elliott> totally!
15:26:01 <michal_> only for sequences, or 1D structures. Multidimensional and otherwise organized structures may not preserve the structure during map, flattening etc.
15:26:16 <cmccann> michal_, shh, you're ruining the joke
15:26:25 <michal_> sorry
15:26:28 <cmccann> :D
15:26:49 <cmccann> obviously the real solution is to use recursion-schemes instead
15:26:53 <cmccann> that should make things much simpler
15:27:23 <michal_> not that I would mind the idea of compiler defaulting rules that automatically derive O(cost) for my algorithm, and use fastest implementation in the library ;-)
15:27:35 <kallisti> just use -XDependentTyping what's the problem?
15:28:00 <cmccann> {-# LANGUAGE Agda #-}
15:28:23 <elliott> LANGUAGE is a really disappointing pragma for its name
15:29:27 <michal_> kallisti: lazy boys like me use programming language to parse something, burn some proc cycles, and then spit it back. With DependentTypes I would first have to write a program that describes the types in my program.
15:29:28 <guerrilla> or idris :)
15:30:07 <kallisti> michal_: just think of it as a second runtime
15:30:46 <ddarius> Nothing about typed languages, dependent or otherwise, requires you to use informative types.
15:31:19 <michal_> kallisti: most of my code is throwaway in the first place, I do not feel necessity to explain it, until it works right!
15:31:20 * kallisti converts all of his data types to Dynamic when passing them around.
15:31:23 <dainanaki> Is it possible to make FunPtr wrappers that take lists as arguments?
15:31:39 * hackagebot acme-strfry 0.1 - A binding to the glibc strfry function.  http://hackage.haskell.org/package/acme-strfry-0.1 (ElliottHird)
15:31:42 <michal_> kallisti: what are you doing? is it python?
15:31:44 <elliott> nand`: behold the product of your inspiration! ^
15:32:01 <dainanaki> no, It's Objective-C
15:32:17 <kallisti> michal_: nah I'm just a fan of dynamic typing but also like the compile-time typesafety
15:32:20 <elliott> Wait, is that really the first thing I've uploaded to Hackage?
15:32:22 <elliott> Oh dear.
15:32:31 <nand`> hmm
15:32:44 <kallisti> elliott: I thought you've done other things that's on Hackge.
15:32:56 <kallisti> +a
15:33:07 <nand`> I'd have expected your first package to be something about type classes involving 9 language extensions to compile
15:33:31 <elliott> Nah, those would overheat Hackage's compilation server.
15:34:02 <nand`> .1.o: unknown symbol `_strfry'
15:34:28 <elliott> nand`: you're not on glibc, I presume
15:34:44 <nand`> that's a fairly Decent assumption considering I'm on windows
15:34:47 <elliott> only disciples of the holy GNU can use the full power of this Free as in Fiefdom library!
15:34:54 <nand`> hmm
15:35:08 <nand`> I have GnuWin32, Interix, SUA, cygwin and MinGW installed
15:35:16 <nand`> I figured I'd have something
15:35:27 <rwbarton> file a cygwin bug report
15:35:29 <elliott> cygwin uses newlib at least
15:35:36 <guerrilla> dcl: nice point
15:35:41 <elliott> newlib has a lot of stuff from glibc, so maybe it has strfry
15:35:45 <nand`> I don't run haskell inside cygwin
15:35:53 <nand`> I'd have to do that I suppose
15:36:04 <elliott> it's worth it for the power of strfry
15:36:06 <nand`> it's a task for tomorrow, time to sleep first and foremost
15:36:10 <nand`> elliott: absolutely
15:36:31 <nand`> by the time I wake up I expect you to have ported Acme::EyeDrops as well
15:37:02 <elliott> nand`: I'll just write a Perl<->Template Haskell bridge
15:37:17 <elliott> and then automatically generate interfaces to every single Acme::* library and put them all on Hackage in one go
15:37:30 <Sgeo> Did someone ping me in here?
15:37:32 <nand`> no need, perl already accepts everything as valid. Just need to reprogram perl appropriately
15:38:04 <kallisti> use Acme::Comment type => 'Haskell';
15:38:11 <nand`> Sgeo: not according to my logs
15:39:05 <NihilistDandy> Anyone around who's built 7.2.2. from source on OS X?
15:39:10 <Sgeo> strfry?
15:39:24 <luite> hmm, I've built 7.2.1 from source
15:39:31 <NihilistDandy> luite: That'll do
15:39:45 <Sgeo> o.O
15:39:47 <NihilistDandy> I'm just trying to figure out how to build a shared base, if it's possible
15:39:48 <LordDeath> hi everyone
15:40:01 <NihilistDandy> And my googlings failed me
15:40:10 <LordDeath> I am just doing my homework and I have to specify the type on an function
15:40:28 <luite> hmm, I don't think I've tried that
15:40:35 <elliott> Sgeo: see the linked glibc documentation
15:40:40 <elliott> http://hackage.haskell.org/package/acme-strfry
15:40:52 <LordDeath> http://pastebin.com/VjRTNZ1a <-- I don't understand what this does :-(
15:40:53 <mauke> The paste VjRTNZ1a has been copied to http://hpaste.org/56975
15:41:16 <kallisti> LordDeath: what kind of function? Maybe we can help you get started.
15:41:18 <NihilistDandy> LordDeath: Have you tried running it?
15:41:37 <LordDeath> the task is to specify it's type
15:41:38 <kallisti> you could just infer the type with ghci but it's probably better educationally to figure it out on your own.
15:41:43 <LordDeath> so I can't run it
15:42:14 <NihilistDandy> Well, what do you think it does?
15:42:18 <LordDeath> I don't understand this (\y -> y ++ x)
15:42:19 <Cale> LordDeath: first, you should make it somewhat less confusing by noticing that there are two distinct variables y, and one shadows the other
15:42:26 <NihilistDandy> LordDeath: It's a lambda expression
15:42:27 <Cale> Do you know about lambda?
15:42:34 <LordDeath> no :-S
15:42:34 <Cale> > (\x -> x*5) 3
15:42:45 <Cale> oh, is lambdabot dead? Let me fix it.
15:43:19 <koeien> > 1 + 1
15:43:21 <dpratt71> woot!
15:43:28 <lambdabot>   2
15:43:28 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
15:43:33 <Cale> heh
15:43:33 <koeien> Cale: thanks!
15:43:35 <Cale> > (\x -> x*5) 3
15:43:39 <kallisti> Cale: a lambda is an expression that evaluates to a function. The argument list begins with a \ and contains a list of vaiables or patterns. After the -> you place the return expression for the function.
15:43:42 <lambdabot>   15
15:43:43 <kallisti> ...
15:43:54 <kallisti> LordDeath: ^
15:43:54 <Cale> kallisti: it wasn't really necessary to tell *me* :D
15:43:56 <kallisti> Cale: hope that helps
15:43:56 <Cale> hehe
15:44:26 <LordDeath> can I express the function I pasted without a lambda expression?
15:44:32 <kallisti> yes
15:44:39 <Cale> You certainly can
15:45:13 <kallisti> if you gave it a name it would be written as:  f y = y ++ x
15:45:17 <kallisti> where f can be any name you'd want.
15:45:36 <kallisti> if you're familiar with currying, you could also write it as (++x)
15:45:38 <michal_> (*5)
15:45:50 <lispy> > let timesFive = (*5) in timesFive 3
15:45:58 <lambdabot>   15
15:46:00 <michal_> (++y)
15:46:21 <LordDeath> I know that my function g is called with g [a] [a]
15:46:37 <LordDeath> that means (x:xs) and y have to be lists of the same type
15:46:39 <LordDeath> right?
15:46:40 <kallisti> Do you know how types are expressed in Haskell, and the type of functions?
15:46:46 <monochrom> test
15:46:50 <koeien> LordDeath: yes
15:47:01 <michal_> cya
15:47:06 <LordDeath> g :: [Int] -> [Int] etc.
15:47:10 <monochrom> @remember elliott |\/|/-\|-|-|=|\||} is my preferred mappend operator
15:47:16 <lambdabot> It is stored.
15:47:20 <monochrom> \∩/
15:47:29 <ion> \☺/
15:47:31 <LordDeath> the task is to give the type of this function
15:47:45 <LordDeath> but instead of [Int] ist should be something like [a]
15:47:51 <LordDeath> like a "generic type"
15:47:54 <NihilistDandy> \ꙮ/
15:48:03 * monochrom is scared!
15:48:11 <kallisti> LordDeath: in Haskell you can use a lowercase variable name within a type to refer to a value of any type.
15:48:13 <kallisti> yes
15:48:21 <kallisti> [a] is a list of any type
15:48:25 <kallisti> for example the empty list [] has the type [a]
15:48:26 <ddarius> monochrom: The only issue is that } is not an operator character.
15:49:00 <monochrom> oh, that's too bad
15:49:05 <LordDeath> kallisti: and as I do a "y ++ x" both x and y need to be the same type
15:49:11 <kallisti> LordDeath: correct.
15:49:12 <kallisti> however
15:49:24 <kallisti> it seems as though the original y variable that's defines by g isn't actually used.
15:49:31 <kallisti> *defined
15:49:48 <monochrom> LordDeath: it may be clearer to rewrite the function as g (x:xs) notused = (\y -> y ++ x) x
15:49:58 <kallisti> (\y -> y ++ x) x
15:50:01 <kallisti> is equivalent to x ++ x
15:50:05 <monochrom> of course, any name in place of "notused" is just fine
15:50:14 <LordDeath> oh
15:50:32 <LordDeath> so the y in the lambda expression is a different y
15:50:35 <monochrom> my point is that I hate two different "y"s hanging around to mislead you
15:50:37 <kallisti> LordDeath: yep
15:50:44 <koeien> yes \x -> ... introduces the name x
15:51:01 <koeien> if there is another x floating around, it's shadowed (meaning you can't see it from within the lambda expression)
15:51:11 <koeien> in general we like to avoid shadowing
15:51:11 <LordDeath> and what does the x at the end?
15:51:20 <monochrom> same x throughout
15:51:34 <kallisti> the x there is being applied to the lambda, it's the x defined by the pattern (x:xs)
15:51:59 <LordDeath> so my types would be: g :: [a] -> [b] -> [a]
15:52:00 <kallisti> are you familiar with patterns?
15:52:06 <LordDeath> yes I am
15:52:18 <kallisti> yep that's correct.
15:52:25 <monochrom> teacher asking "what's the type of this?" without first teaching a fairly comprehensive type-inference algorithm is kind of irresponsible
15:52:50 <monochrom> (yes yes, I totally acknowledge that the algorithm is pretty long)
15:53:09 <kallisti> monochrom: I know absolutely nothing about Hindley-Milner type inference and can intuitively infer most types.
15:53:13 <cmccann> NihilistDandy, hm, apparently GHC the multiocular O a lowercase letter
15:53:21 <cmccann> that's something I'll need to remember
15:53:21 <LordDeath> the unknown part was this lambda expression
15:53:24 <Ralith> type inference is very intuitive
15:53:34 <NihilistDandy> cmccann: It's my favorite :D
15:53:36 <DanBurton> just look at outermost function, and see how many arguments are applied. easycake
15:53:51 <DanBurton> not always correct but serves most purposes
15:54:14 <kallisti> LordDeath: yes it's just another way to define a function without assigning it a name. It's useful for passing small functions to other functions when you don't intend to reuse it.
15:54:17 <monochrom> (but imagine this for a calculus class: "it's too lengthy to tell you how to compute derivatives for even just the common cases, so, I have a great idea! what is the derivative of x^2?")
15:54:56 <NihilistDandy> My programming languages class is in OCaml, and it's so unsettling with Haskell as a background. It just seems so god damned ugly :|
15:55:09 <koeien> it's not so bad
15:55:13 <kallisti> LordDeath: the purpose of the lambda here appears to be to trick you with variable shadowing as the expression is exactly the same as x ++ x
15:55:20 <monochrom> kallisti: it is not universally intuitive. it is definitely counterintuitive given certain poor presentations
15:55:43 <LordDeath> kallisti: and they tricked me successfully ^^
15:55:47 <gwern> so I was thinking about 'filter'; I know the generalization of map on List is fmap on Functors, but what is filter's generalization?
15:55:50 <ddarius> The HM algorithm is pretty short.
15:56:06 <sully> yeah, I feel like you can teach people what polymorphic type inference is going to do
15:56:14 <ddarius> http://www.cafepress.com/skicalc.6225368
15:56:14 <sully> without talking about HM
15:56:24 <LordDeath> this semester we learned java, haskell and prolog
15:56:29 <LordDeath> haskell is fun
15:56:32 <ddarius> sully: Yes, you can teach them Prolog.
15:56:40 <DanBurton> i wish our school taught haskell
15:56:41 <LordDeath> as long as they keep the lambda expressions out :P
15:56:43 <Eduard_Munteanu> gwern: filter is pretty much a fold
15:56:44 <sully> heh
15:56:53 <kallisti> LordDeath: they're not difficult to understand. you should figure them out.
15:56:57 <DanBurton> we have exactly *one* class that is not C/Java/C#/Python
15:57:22 <sully> but I definitely knew howto figure out what type polymorphic functions would have
15:57:22 <DanBurton> well, class Junior and below
15:57:36 <gwern> Eduard_Munteanu: I know, but if I were generalizing to non-lists like Seq, what typeclass am I looking at? I'm pretty sure it can't be Functor
15:57:37 <sully> before I knew prolog or how type inference worked
15:57:55 <cmccann> gwern, mfilter?
15:58:01 <cmccann> :t mfilter
15:58:02 <lambdabot> Not in scope: `mfilter'
15:58:05 <cmccann> pf
15:58:06 <Eduard_Munteanu> gwern: Foldable?
15:58:27 <cmccann> mfilter uses MonadPlus, at any rate
15:58:27 <gwern> hm, that sounds plausible...
15:58:30 <DanBurton> LordDeath: lambdas are pretty straightforward. (\x -> foo) ==> let anon x = foo in anon
15:58:33 <Eduard_Munteanu> And yeah, it can't really be a Functor.
15:58:51 <cmccann> gwern, something like MonadPlus or Alternative is probably what you're after
15:59:13 <dibblego> mfilter is a recent addition and generalises filter to non-list values
15:59:25 <cmccann> oh, is that why lambdabot doesn't know about it?
16:00:14 <ddarius> :t \p m -> do x <- m; guard (p x); return x
16:00:14 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> m b -> m b
16:00:16 <alkoma> LordDeath: (\y -> y ++ x) is a function, say, you replace it with foo - how would you rewrite your function?
16:00:22 <ddarius> Foldable = toList
16:00:53 <ddarius> (Which can be viewed as something rather similar to C#'s IEnumerable interface.)
16:01:47 <LordDeath> alkoma: like this? f( x_) = x_ ++ x
16:01:49 * hackagebot hspec 0.9.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.1 (TrystanSpangler)
16:02:04 <LordDeath> so x is my constant and x_ the variable?
16:02:18 <alkoma> g (x:xs) y = foo ...
16:02:29 <kallisti> LordDeath: that would be correct assuming that f is defined within the scope of g
16:02:52 <kallisti> so for example: g (x:xs) y = foo x where foo x_ = x_ ++ x
16:03:06 <kallisti> foo is defined within the scope of the variables defined by g
16:03:23 <kallisti> if you simply wrote foo at the top level of your program, then x wouldn't be visible.
16:04:00 <LordDeath> hm
16:04:10 <kallisti> LordDeath: are you familiar with where?
16:04:14 <LordDeath> I have here an example of an expression with where
16:04:16 <davv3> newbie question: what does x:xs entail?
16:04:21 <LordDeath> and we used it in older homeworks
16:04:24 <NihilistDandy> davv3: List
16:04:29 <NihilistDandy> (head:tail)
16:04:32 <NihilistDandy> *rest
16:04:36 <davv3> ok
16:04:41 <kallisti> LordDeath: ah okay. does what I'm saying make sense then?
16:04:54 <LordDeath> yes
16:05:12 <LordDeath> we also had this "let foo = ..." expression
16:05:29 <kallisti> yes where is a syntactic sugar for let expressions
16:05:40 <kallisti> that  you can use on function definitions as well as case expressions.
16:05:44 <LordDeath> I think where is the most intuitive
16:05:53 <kallisti> sometimes. sometimes I like let though
16:06:07 <kallisti> where defines a problem from the top down.
16:06:23 <morel> i'm looking for this function: \f (a,b) -> (a,f b) -- how is it called ? it's pre-defined somewhere AFAIK…
16:06:33 <kallisti> :t second
16:06:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:06:56 <kallisti> > second (+1) (3,4)
16:06:57 <lambdabot>   (3,5)
16:07:01 <kallisti> morel: defined in Control.Arrow
16:07:03 <morel> kallisti: thanks
16:07:03 <elliott> if anyone is a Haddock expert: http://stackoverflow.com/questions/9012640/how-are-the-haddock-module-fields-portability-stability-and-maintainer-used
16:07:03 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:07:10 <elliott> lambdabot: :(
16:07:18 <cmccann> hahaha
16:07:27 <elliott> It's shachaf's fault this time.
16:07:45 <oaktree> can someone answer a really basic question about Haskell?
16:07:57 <elliott> yes
16:08:01 <elliott> probably :)
16:08:27 <kallisti> LordDeath: let is nice when you have a very small expression that you want to bind to a name within a much larger expression. Seeing the smaller expression upfront can make the larger one easier to comprehend.
16:08:31 <oaktree> i noticed that it's named after Haskell Curry (combinators) but its symbol is lambda (lambda calculus) and was wondering what its relationship is to the two
16:08:32 <kallisti> LordDeath: most of the time I end up using where, however.
16:08:57 <exFalso> isnt it bind?
16:09:03 <elliott> oaktree: well, combinators are often defined in terms of the lambda calculus
16:09:06 <elliott> S = \xyz.xz(yz)
16:09:09 <kallisti> exFalso: it's a mix between bind and a lambda.
16:09:10 <elliott> K = \xy.x
16:09:23 <cmccann> it's a lambinda
16:10:01 <oaktree> elliott: which Haskell is an implementation of?
16:10:19 <elliott> oaktree: not _really_
16:10:31 <cmccann> oaktree, lambda calculus and combinatory logic are so similar anyway it doesn't matter that much
16:10:32 <exFalso> none of them, Haskell is a term rewriting system afaik
16:10:32 <elliott> haskell is a language based on a form of the typed language calculus
16:10:38 <elliott> no
16:10:47 <cmccann> but as a first approximation, Haskell is a typed lambda calculus with extra stuff bolted on
16:11:05 <elliott> a LOT of extra stuff once you enter the world of ghc extensions :)
16:11:06 <alkoma> exFalso: so Pure is really just another Haskell?
16:11:19 <dschoepe> I guess the "theoretical language" Haskell comes closest to would be PCF, right?
16:11:40 <exFalso> isnt haskell a term rewriting system with system F for typing?
16:11:41 <cmccann> elliott, unbounded amounts of extra stuff if you use TH and/or preprocessors :P
16:12:07 <elliott> exFalso: no, haskell is not a term rewriting system
16:12:26 <elliott> you could implement it as one (but GHC doesn't) but it's not defined as one
16:14:25 <exFalso> hmm can you point us to an article on what haskell is (formally)?
16:14:35 <elliott> exFalso: yes
16:14:38 <elliott> exFalso: http://www.haskell.org/onlinereport/haskell2010/ :)
16:14:43 <exFalso> haha
16:14:46 <exFalso> thanks :D
16:15:06 <LordDeath> data T a = C1 | C2 a (T a) <-- this is just a list, right?
16:15:13 <exFalso> yes
16:15:13 <koeien> LordDeath: yes
16:15:27 <LordDeath> 8.-)
16:15:48 <ddarius> Early implementations of lazy programming languages did make extensive use of combinators.  See particularly David Turner's work (which suggests that Miranda did, and still does, use combinators.)
16:16:28 <ddarius> There are no formal semantics for Haskell.  There's a partial one for an older revision of the standard.
16:17:07 <oaktree> if I wrote an algorithm in untyped lambda calculus would it be a smooth transition to coding it in Haskell?
16:17:28 <byorgey> oaktree: probably, if you didn't do anything too weird.
16:17:44 <monochrom> the only possible hurdle is figuring out types
16:17:52 <exFalso> well once you do recursion it will break
16:17:58 <monochrom> and even then you can use newtype to solve all problems
16:18:01 <exFalso> general recursion that is
16:18:05 <byorgey> exFalso: no, Haskell has recursion.
16:18:06 <MaskRay> I'm trying to implement an Eulerian circuit algorithm on trees and writes such code: http://hpaste.org/56976  . Can sb do me a favor to tell a more efficient approach (e.g. less heap usage)
16:18:20 <exFalso> i mean general recursion in untyped lc
16:18:26 <kallisti> > ap ap const
16:18:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = m (a -> b)
16:18:28 <exFalso> which cant be typed
16:18:32 <monochrom> exFalso probably means the (\x -> x x) (\x -> x x) kind, and what I said.
16:18:45 <byorgey> exFalso: can't be typed in the simply typed lambda calculus.  oaktree was asking about Haskell.
16:18:58 <byorgey> Haskell is most certainly not the simply typed lambda calculus.
16:19:14 <kallisti> um.
16:19:24 <exFalso> yes, but you cant define a y combinator in untyped lc that type checks in haskell
16:19:40 <exFalso> afaik
16:19:42 <ddarius> byorgey: There is no problem adding fix to the simply typed lambda calculus, and that won't cause it to cease being the simply typed lambda calculus.
16:19:45 <byorgey> oh, I see.  I guess we have different ideas of what the "smooth transition" would look like.
16:20:06 <monochrom> of course
16:20:08 <exFalso> ddarius: yes it will!
16:20:15 <elliott> slightly less simply typed lambda calculus
16:20:16 <byorgey> if you mean "just translate it verbatim" then I agree you won't be able to do it.
16:20:17 <elliott> SLSTLC
16:20:19 <exFalso> simplty typed lc is stringly normalising for one
16:20:34 <oaktree> byorgey: no i meant more along the lines of keeping the flow of logic the same
16:20:36 <ddarius> elliott: It doesn't change the typing at all.  It's just a constant that is asserted.
16:20:41 <oaktree> versus working with an imperative language
16:20:52 <monochrom> haskell is not famous for being strongly normalizing either :)
16:20:59 <elliott> ddarius: I'm just kidding :)
16:21:04 <byorgey> oaktree: right. In that case it shouldn't be too hard.
16:21:26 <oaktree> okay, thanks for your help
16:21:36 <monochrom> newtype D = Ctor (D -> D)  will help you
16:21:36 <LordDeath> http://pastebin.com/V02r2mcL <-- can I say that this has the type "i :: [a] -> T a"?
16:21:38 <mauke> The paste V02r2mcL has been copied to http://hpaste.org/56977
16:21:48 <elliott> I wonder if oaktree has actually written a large application in the untyped lambda calculus and is now looking to port it to Haskell.
16:21:56 <ddarius> exFalso: Not if you add constants with delta rules that change that.
16:21:57 <elliott> LordDeath: yes, you can
16:22:01 <elliott> LordDeath: try loading it in ghci and doing :t i
16:22:04 <elliott> you'll get exactly that back
16:22:06 <monochrom> in fact, why don't you use that to write a lambda interpreter in haskell, and be done? :)
16:22:19 <LordDeath> elliott: I will
16:22:25 <exFalso> ddarius: a strongly normalising fix? i'd like to see that!
16:23:01 <LordDeath> btw: is there an ARM version of ghci?
16:23:06 <LordDeath> which runs on android? ^^
16:23:18 <morel> LordDeath: no there isnt
16:23:29 <LordDeath> too bad :-)
16:23:29 <morel> LordDeath: afaik ghci doesnt run on arm yet
16:23:59 <elliott> ghci =/= ghc though
16:24:02 <morel> LordDeath: there's a blog about that bug: http://ghcarm.wordpress.com/
16:24:05 <elliott> is there no plain ghc for android?
16:24:07 <morel> elliott: exactly
16:24:08 <elliott> oh, ghci
16:24:12 <elliott> i didn't notice LordDeath added the i :)
16:24:20 <morel> there is ghc, but not ghci
16:24:23 <morel> :)
16:24:31 <LordDeath> I haven't used ghc yet
16:24:32 <monochrom> I wouldn't want to use ghci on a phone. small keyboard.
16:24:33 <LordDeath> only ghci
16:25:02 <morel> LordDeath: see also: http://hackage.haskell.org/trac/ghc/wiki/Platforms
16:25:11 <LordDeath> monochrom: android != phone ;-)
16:25:16 <morel> monochrom: yea
16:25:53 <rwbarton> tryhaskell.org seems to be broken, every input is producing "Terminated!"
16:26:08 <kallisti> rwbarton: did you try the inputs that don't terminate? :>
16:26:21 <kallisti> (tee hee hee)
16:26:21 <rwbarton> Apparently I can't think of any.
16:26:26 <ddarius> ghci = ghc --interactive
16:26:45 <LordDeath> it is the same binary?
16:27:29 <byorgey> yes
16:27:51 <monochrom> still doesn't mean all platforms get the interactive part
16:28:30 <kallisti> Cale: have you considered giving lambdabot the ability to properly identify nicks?
16:28:38 <monochrom> when you build ghc, you can say, disable the interactive part. then the executable won't include that code
16:29:02 <kallisti> Cale: so that, for example, the admin and messaging features are actually secure.
16:29:12 <monochrom> and for certain platforms, since somethings haven't been figured out, they have to disable the interactive part.
16:29:16 <Cale> kallisti: have you considered becoming lambdabot's maintainer?
16:29:27 <kallisti> Cale: I didn't know the position was available. :P
16:29:29 <ddarius> monochrom: I wasn't suggesting that it did.
16:29:36 <Cale> (because I'm not)
16:29:43 <monochrom> yeah ok, just precautioning
16:29:46 <kallisti> oh, for some reason I thought you were. my mistake.
16:36:03 <eyebloom> So far I'm stumped to find an elegant solution to the problem: in HOpenGL create a (Position GLint GLint) from by dividing a (Size GLsizei GLsizei) in half.
16:36:24 <eyebloom> (Position (w/2) (h/2)) doesn't compile.
16:37:00 <Sgeo> @tell elliott Take a guess what I'm @telling you
16:37:00 <lambdabot> Consider it noted.
16:37:01 <ion> Try `div` 2.
16:37:02 <rwbarton> for a start you'll want `div`
16:37:57 <eyebloom> Doesn't solve the type conflict
16:38:05 <eyebloom> (Position (div w 2) (div h 2))
16:39:17 <elliott> fromIntegral?
16:39:32 <elliott> To convert GLsizei -> GLint.
16:40:13 <eyebloom> I see, combined with div that works.
16:40:15 <eyebloom> Thanks.
16:44:35 <ddarius> (`shiftR`1)
16:51:49 * hackagebot yjtools 0.9.10 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.10 (YoshikuniJujo)
16:53:15 <technopredator> Hi, any of you in #povray?
16:54:23 <technopredator> I guess not
17:02:57 <eyebloom> This code causes a bus error if I include the clearColor line.
17:03:00 <hpaste> eyebloom pasted “Bus error” at http://hpaste.org/56980
17:18:08 <darrint> I can't build zlib. I'm dying on #if MIN_VERSION_base(4,4,0) Any ideas?
17:19:19 <elliott> darrint: GHC version?
17:19:47 <elliott> darrint: it's probably http://stackoverflow.com/questions/8961413/zlib-build-error-with-ghc
17:21:14 <darrint> elliott, indeed. Should have asked google first. Thanks.
17:21:37 <darrint> ah. ghc 7.0.3 even.
18:02:09 <prof7bit> question: if i have something like this: Int -> Int then this is a map from the category of Int to the category of Int. If I have [a] -> [a] then this is a map from the category of [Int] to the category of [Int], is this corrct so far?
18:02:27 <prof7bit> [Int] -> [INt]
18:03:22 <prof7bit> or do I already confuse the meanings of "category" here?
18:03:36 <Veinor> in the category Hask, the objects are types
18:03:46 <Veinor> so your Int -> Int is an arrow from the Int object to itself
18:04:21 <prof7bit> isnt [a] a diffferent category than a?
18:04:25 <Veinor> yes
18:04:36 <prof7bit> ok
18:04:38 <Veinor> [Int] is a different category than [Int]
18:04:40 <olichip> hey :D
18:04:58 <prof7bit> now i am confused
18:05:10 <Veinor> i'm not sure what something with a parametric type represents though
18:05:33 <dmwit> [a] is not a category
18:05:41 <dmwit> It is an object in a category.
18:06:02 <Veinor> er yes
18:06:03 <Veinor> that's what i meant
18:06:25 <dmwit> But yes, I think usually the category is given monomorphic types for its objects.
18:06:36 <dmwit> So [Int] is an object in the category, but [a] isn't.
18:06:50 <Veinor> and so you have id :: Int -> Int and id :: Bool -> Bool
18:06:56 <dmwit> yes
18:07:02 <Veinor> makes sense
18:08:45 <copumpkin> [a] -> [a] is a natural transformation
18:09:21 <dolio> forall a. [a] can be an object if you formulate things right.
18:09:49 <prof7bit> i'm still trying to understand what exactly is a category and how it relates to the things in haskell. I was under the impression that if i have a function that goes from int to int and then i can do some magic to it so that it goes from list to list then where all these lists reside is a different category than where the ints live
18:09:57 <cmccann> [a] could plausibly refer to the subcategory of Hask which is the target of the [] functor
18:10:07 <cmccann> but only if you explain that you mean that
18:10:14 <cmccann> it's not very clear notation :P
18:10:40 <dmwit> prof7bit: Close, except that by coincidence it happens that your Int -> Int arrow and the corresponding mapping arrow of type [Int] -> [Int] are in the same category.
18:11:17 <dmwit> prof7bit: I say coincidence because usually a functor doesn't require that the source and target categories are the same, but in Haskell, we only have one category.
18:11:23 <prof7bit> but doesn't the latter one only work in the world where the lists live?
18:11:43 <dmwit> Yes, its domain is a different object than the domain of the Int -> Int arrow.
18:11:53 <dmwit> But domains (and codomains) are objects, not categories.
18:12:04 <cmccann> dmwit, Functor instances do describe subcategories of Hask though :P
18:12:20 <prof7bit> ok. what about this: Int -> [Int]
18:12:26 <dmwit> What about it?
18:12:36 <Veinor> that's an arrow from the Int object to the [Int] object
18:12:48 <dolio> You can view [a] as an object in the fiber over one type variable.
18:12:48 <cmccann> prof7bit, none of this necessarily means anything in particular without further context
18:13:01 <prof7bit> doesn't this map from the category of integers to the category of integer lists?
18:13:12 <dolio> Then there's a functor back to the fiber over 0 variables called forall, that takes [a] to forall a. [a].
18:13:17 <dmwit> prof7bit: Again, there is only one category under discussion here.
18:13:18 <cmccann> you can describe Haskell stuff in category theory terms, but random bits of haskell don't have an unambiguous interpretation in category theory
18:13:28 <dmwit> prof7bit: Please fix your understanding of the terminology.
18:13:50 <prof7bit> this is what I am trying to do. I don't understand it.
18:14:18 <dainanaki> The category is Hask
18:14:19 <dmwit> There is not much to understand; just repeat to yourself "a type is an object, not a category" and you will have it. =)
18:14:21 <copumpkin> you can probably come up with categories of integers and lists of integers, but they wouldn't be the ones we're expecting here
18:14:27 <copumpkin> maps between them are functors
18:15:23 <dmwit> A category is a collection of objects and a collection of arrows together. The arrows are often mappings from one object to another.
18:15:29 <zeiris> What do you call transparently "caching" the result of a referentially transparent function?
18:15:38 <Ralith> memoization?
18:15:41 <zeiris> Thanks.
18:16:04 <dmwit> In the particular category Hask, each (monomorphic) type is an object, and each function of type A -> B is an arrow whose domain is (object) A and codomain is (object) B.
18:16:14 <prof7bit> "a type is an object" does this mean Int -> Int maps to the obect to itself?
18:16:26 <dmwit> prof7bit: There is a bit of overloading here.
18:16:47 <dmwit> There is the "Haskell" type constructor "->" and there is the "category-level" domain/codomain notation.
18:16:50 * hackagebot husk-scheme 3.5.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.5.1 (JustinEthier)
18:16:54 <dmwit> Let's fix a separate notation for the latter so it's less confusing.
18:17:09 <dmwit> We'll say "f : A |-> B" when we mean "f" is an arrow from object "A" to object "B".
18:17:12 <dmwit> Then:
18:18:05 <dmwit> "A -> B" is an object
18:18:20 <dmwit> So, you could have an arrow "g : (A -> B) |-> (C -> D)".
18:19:43 <dmwit> It would be an arrow from the "A -> B" object to the "C -> D" object -- that is, a mapping from functions to functions.
18:20:26 <prof7bit> and they are all in the same category?
18:20:32 <dmwit> yes
18:21:29 <prof7bit> now i have read there exist functors that map objects and functions from one category into another one. how would such a different category look like in haskell?
18:22:49 <prof7bit> if all haskell types are actually in the same category already?
18:22:51 <dmwit> one sec
18:23:00 <DanBurton> hrm; I'm trying to create a function that takes a pure function (a -> b) and produces the corresponding Conduit (no initialization, no monadic effects needed). Any tips?
18:23:16 <DanBurton> (also no finalization needed)
18:23:53 <dmwit> prof7bit: Okay, I'm back.
18:24:08 <dmwit> prof7bit: So, you know we can have a functor F from category C to category D.
18:24:22 <dmwit> For our purposes, there is only one category, so both C and D are Hask.
18:24:26 <elliott> DanBurton: Does Conduit have an "id"?
18:24:41 <elliott> DanBurton: For Category and Applicative instances, you can define arr = (pure id <*>).
18:24:44 <elliott> So perhaps (pure conduit_id_equivalent <*>) might check out
18:24:47 <dmwit> A functor F from Hask to Hask comprises two things: a mapping from objects to objects, and a mapping from arrows to arrows satisfying some laws.
18:24:56 <adam_> dmwit, i've been trying to follow along, is there a good book on this topic?
18:25:08 <dmwit> adam_: mmm, I'm not sure!
18:25:24 <adam_> thanks
18:25:25 <dmwit> adam_: There's lots of good CT resources floating around, though; Awodey's book gets mentioned a lot.
18:25:33 <dmwit> And I really liked "Topoi".
18:25:57 <dmwit> It's another book, purportedly on topos theory, but actually covering a good deal of category theory on its way to getting to the good bits. =)
18:26:03 <dmwit> Anyway.
18:26:20 <dmwit> prof7bit: The "mapping from objects to objects" bit is usually implemented with a type constructor.
18:26:27 <dmwit> A common first example is the "[]" type constructor.
18:26:33 <elliott> DanBurton: Failing that: conduitPure f = conduitState () (\() x -> return ((), Producing [f x])) (\() -> return [])
18:26:40 <dmwit> So, what does the mapping from arrows to arrows have to do?
18:26:49 <elliott> conduitPure f = conduitState () (\_ x -> return ((), Producing [f x])) (\_ -> return []) -- maybe nicer
18:27:23 <dmwit> Well, for any object A, it maps that object to [A]; so if we have "f : A |-> B" in Hask and we want to map it into Hask and be compatible with the object-mapping, we have to produce "f' : [A] |-> [B]".
18:27:55 <dmwit> So, we're looking for a function which takes "A |-> B" arrows to "[A] |-> [B]" arrows.
18:28:12 <dmwit> There's lots of these things, but a particularly simple and likely one is "map :: (a -> b) -> ([a] -> [b])".
18:28:55 <dmwit> The interesting properties of "map" demanded by calling it a functor are that "map id = id" and "map (f . g) = map f . map g".
18:29:01 <dmwit> (which are both true of "map")
18:30:03 <byorgey> adam_: the CT page on the Haskell wiki is pretty good
18:30:21 <byorgey> just as a place to start.  Although obviously it's not a book.
18:31:08 <dmwit> Anyway, the observation that lets this all work when only one good category is lying around is that the definition of a functor allows the functor's source and target categories to be different, but of course doesn't require it.
18:31:24 <byorgey> hmm, actually, maybe I'm thinking of the CT page in the haskell wikibook
18:31:38 <prof7bit> Then my misunderstanding was that I thougt the transition from A to [A] meant also going into a different category
18:31:40 <DanBurton> elliott: looks like snoyman actually called it "map" in his blog post: http://www.yesodweb.com/blog/2012/01/conduits-conduits
18:31:41 <dmwit> (Hardcore CT folks: yes, I know there isn't only one good category lying around.)
18:32:33 <byorgey> prof7bit: right, not necessarily.  Just like a function may map from one type to a different type but it *may* map from a type to itself.
18:32:50 <byorgey> prof7bit: a functor from a category to itself is sometimes callde an "endofunctor"
18:34:14 <rwbarton> an example of a different category which you can talk about in Haskell is a category whose objects are type (constructors) of kind * -> *
18:34:37 <elliott> DanBurton: heh, perhaps an unwise choice of name
18:34:42 <prof7bit> but there exist (in CT, not in haskell) functors that map from one into another category? that was what I was assuming from the few pages i read about it and i untuitively tried to see the concept of multiple ctegories in haskell too
18:34:46 <hpaste> DanBurton pasted “Conduits to Pipes” at http://hpaste.org/56986
18:34:50 <elliott> I think (fmap f conduitID) would also work
18:35:08 <DanBurton> elliott: that would make sense
18:35:10 <byorgey> prof7bit: yes.
18:35:10 <dmwit> prof7bit: There certainly are, yes.
18:35:22 <DanBurton> check it out ^ my attempt to turn a Conduit into a Pipe. bugs?
18:35:52 <dmwit> prof7bit: Here's a nice example. You can take any graph and turn it into a category by setting the nodes to be objects and (possibly empty) paths in the graph to be arrows.
18:35:53 <rwbarton> there are such functors that you can talk about in Haskell, too, just not with the standard Functor type class
18:36:14 <byorgey> rwbarton: what would be an example?
18:36:30 <dmwit> prof7bit: Then a functor between the category associated with graph G and the category associated with graph G' is exactly a graph homomorphism from G to G'.
18:36:40 <rwbarton> a probably confusing example is (,) viewed as a functor from Hask = { stuff of kind * } to { stuff of kind * -> * }
18:36:47 <dmwit> byorgey: Well, contravariant functors, for one.
18:36:54 <dmwit> byorgey: Which are just functors from Hask to opHask. =)
18:37:42 <byorgey> dmwit, rwbarton: ah, both good examples, thanks =)
18:38:13 * byorgey prefers "Haskop"
18:38:20 <dmwit> Hask^{op}
18:38:22 <dmwit> coHask
18:38:32 <dmwit> (<-)
18:38:46 <byorgey> hehe
18:39:06 <dmwit> Hm, is (<-) a valid type operator? Can I write "type a <- b = b -> a"? =)
18:39:19 <byorgey> next time someone asks what <- means we can completely confuse them by telling them it's the constructor for co-arrows
18:39:39 <rwbarton> well it's definitely not a valid type constructor
18:39:40 <monochrom> haha
18:39:45 <byorgey> dmwit: I assume not, but I don't know
18:39:49 <dmwit> Ah, no, it has to start with a :
18:39:54 <dmwit> But it's a fine type variable. =)
18:40:28 <dainanaki> :(
18:40:38 <rwbarton> dmwit: BTW, did you ever work out what happens with those comonoids?
18:40:49 <prof7bit> but doesn't category theory only unfold its power when there are multiple categories? why is there such  strong connection between CT and Haskell if all there is are only the types and the functions, all within the same category?
18:41:27 <byorgey> dmwit: it seems to be a parse error, sadly
18:41:36 <dmwit> rwbarton: I gave up. The laws that popped out looked to weird to be supported by anything I could think of off the top of my head.
18:41:53 <byorgey> prof7bit: no, category theory has plenty to say even when there is only one category.
18:42:05 <rwbarton> the counit laws actually tell you that split has to be \x -> (x, x)
18:42:10 <dmwit> prof7bit: The power of category theory is that it gives a very concise set of terms for very complicated topics.
18:42:31 <dmwit> s/to weird/too weird/
18:42:57 <byorgey> prof7bit: but the other thing to note is that category theory also illuminates connections between Haskell and many other categories.
18:44:10 <prof7bit> byorgey: that is what i meant with the "power", the similarities of underlying principles in totally different topics. if I understood the intentions of CT correctly.
18:44:10 <rwbarton> and split x = (x, x) satisfies the coassociativity law, so the outcome is that every object is a comonoid in a unique way
18:44:29 <byorgey> For example, (a subset of) Haskell can be used as an "internal language" for any cartesian closed category... so thinking about Haskell programs can give insight into other categories which on the surface might seem unrelated to Haskell
18:44:32 <dmwit> rwbarton: Oh, I see. But doesn't it actually say that split x = (0, 0) instead?
18:44:53 <rwbarton> there isn't a 0, instead you have a "counit" x -> ()
18:45:03 <rwbarton> which, of course, doesn't do anything
18:45:20 <dmwit> hm
18:45:52 <dmwit> oh, right
18:45:53 <rwbarton> right, so with a monoid object the way you formulate the unit of the monoid is as a map () -> m
18:45:57 <rwbarton> since you can't talk about "elements"
18:46:02 <dmwit> bleh, I always screw up dualities
18:46:08 <rwbarton> or more generally 1 -> m where 1 is the unit of your monoidal structure
18:47:50 <rwbarton> then the unit laws should say "1 * x = x" so that's an equality between m = () * m -> m * m -> m and id : m -> m
18:48:01 <rwbarton> where the first arrow is (unit, id) and the second arrow is multiplication
18:48:55 <rwbarton> (and there is the one for the other side of course)
18:49:34 <ezyang> Is there a name for an interactive theorem prover that is only responsible for checking proof certificates are correct?
18:50:00 <byorgey> ezyang: Coq?
18:50:04 <ezyang> Automated theorem checker? Automated type checker?
18:50:11 <rwbarton> verifier?
18:50:14 <elliott> verifier
18:50:14 <ezyang> byorgey: "Well, in abstract"
18:50:17 <rwbarton> How would it be interactive?
18:50:19 <monochrom> usually, proof certicates are designed to be checkable without interaction
18:50:25 <elliott> oh interactive
18:50:25 <byorgey> ezyang: "type checker"
18:50:28 <elliott> "contradiction in terms"
18:50:46 <ezyang> byorgey: That seems to confusing to a non-PL audience
18:50:50 <byorgey> ezyang: hehe
18:50:55 <ezyang> *too
18:51:03 <russellw> Unless what he means by checking is the human has to figure out what steps to take and the program checks each step. In that case, it's called a proof assistant
18:51:04 <byorgey> ezyang: in what sense is it interactive if it only checks proof certificates?
18:51:27 <ezyang> Well, only because, usually, the proofs were constructed interactively.
18:51:50 <byorgey> ezyang: ok, yes, russellw is right, "proof assistant" is probably the right term
18:51:50 <ezyang> Like, I think essentially what I want is "type checker" but less ambiguously
18:51:58 <monochrom> well then, proof assistant
18:52:00 <ezyang> byorgey: OK. I guess that seems a bit wide.
18:52:01 <elliott> type checkers are not ineractive :P
18:52:04 <elliott> interactive
18:52:13 <elliott> it's a proof assistant or a proof verifier depending on whether it's interactive or not
18:52:34 <ezyang> OK, I'll just call it a proof verifier.
18:52:50 <byorgey> ezyang: how about "interactive proof assistant that also verifies the correctness of the final proof", or IPATAVTCOTFP for short
18:52:54 <dmwit> Invent a word, define it, and use it consistentnly.
18:53:06 <ezyang> 'ho boy
18:53:10 <byorgey> ;)
18:53:13 <dmwit> A "mugushimbo" is a widget that frobnosticates the grobnok.
18:53:27 <monochrom> then again, in the great tradition that a debugger doesn't debug, an editor doesn't edit... "proof certificate writer"
18:53:56 <dainanaki> The fun part is that the words that Haskell programmers use already sound entirely ridiculous as it is.
18:54:07 <monochrom> "interactive proof assistant" already includes checking. that's the "assistant" part.
18:54:28 <elliott> most of our ridiculous terminology can be blamed on mathematicians (known to mathematicians as "maximally ridiculous people")
18:54:41 <monochrom> if not for that, ed would qualify as an interactive proof assistant, too
18:54:43 <elliott> or maripeeps for short
18:55:43 <prof7bit> I was reading this: http://en.wikibooks.org/wiki/Haskell/Category_theory#Functors  <-- this was the reason I immediately started thinking about mapping between different categories when using something like fmap to map for example between numbers and lists of numbers
18:57:55 <rwbarton> right, but you're off by a level, the input to the functor is a type (like Int) and the output is another type (like [Int]), so the functor goes from types to types
18:59:42 <prof7bit> from the above page: "Functors in Haskell are from Hask to func, where func is the subcategory of Hask defined on just that functor's types. E.g. the list functor goes from Hask to Lst, where Lst is the category containing only list types"
19:01:17 <chipdude> I've read quite a bit about the extensible records proposals and libraries.  Is there consensus on at least the best way to cope, today?
19:02:41 * dmwit dons his flame-retardant suit and sits silent
19:02:54 <chipdude> oh dear, it's one of *those*, is it
19:03:22 <elliott> if you mean "extensible records" and not just "better records", IMO all the solutions are way too ugly to use
19:03:34 <elliott> they're mostly extreme type hackery to make something that sort of works but is awkward to actually apply
19:03:43 <elliott> but presumably the users of such libraries disagree :)
19:03:50 <chipdude> yes, I suppose I might be jumping to solution land too soon
19:04:31 <elliott> thankfully, a large number of use-cases for extensible records can be done just as well (or close) without, so it might help to give concrete details about your situation
19:05:21 <chipdude> what I actually want is a record type (or something like it), and a limited set of extensions to that record type; and, key, polymorphic field accessors.  you know, the basic kind of thing that would be a field or property or virtual getter
19:06:08 <chipdude> I've just read http://www.haskell.org/haskellwiki/OOP_vs_type_classes
19:06:24 <elliott> chipdude: that's not concrete details about the problem you're trying to solve, that's just a description of an extensible record system :)
19:06:30 <chipdude> is it, now
19:06:31 <chipdude> hm
19:07:08 <chipdude> I have a simultation in which I want reusable code for the base assumptions of the sim, and variants of those same states with additional object information
19:07:24 <chipdude> for specialized variations of the base simulation
19:07:41 <elliott> ok. how about parameterising the simulation data on an "additional data" type, and writing your functions polymorphic in that type?
19:07:47 <dmwit> prof7bit: (I would just like to point out that nothing in that sentence contradicts anything we said before.)
19:07:52 <elliott> and then specialising it to define a variant
19:09:04 <chipdude> hm.  plausible.  to be sure I understand: the simulation data becomes a parameterized record type
19:09:20 <elliott> right. for instance,
19:09:36 <elliott> data SimData a = SimData { frobnication :: Int, mortalityRate :: Double, extra :: a }
19:09:50 <elliott> advanceSim :: (a -> SimChange) -> Time -> SimData a -> SimData a
19:09:54 <elliott> or such
19:10:11 <elliott> the idea being that things that care about the state are simply passed it
19:10:28 <elliott> and can vary their behaviour based on it
19:10:52 <chipdude> lovely!  thanks, that looks quite promising
19:12:07 <chipdude> if I want the extra data to meet some basic requirements, then I introduce  (SimExtra => a)  or the like?
19:12:49 * chipdude is thinking of serialization particularly
19:13:09 <kallisti> you would want to introduce those constraints at the function level
19:13:16 <kallisti> rather than in the data type declaration
19:13:25 <prof7bit> dmwit: it seems the important word was *sub* categoies :-). My reasoning was i can fmap from the subcategory if integers to the subcategory of integer lists.
19:13:43 <chipdude> kallisti: innteresting.  my dynamic past is hard to shed.
19:14:11 <kallisti> chipdude: putting unecessary typeclass constraints on the data type is often not very conductive. it's better to simple include constraints in the relevant functions
19:14:13 <elliott> chipdude: yeah
19:14:18 <elliott> advanecSim :: (SimExtra a) => ...
19:14:19 <kallisti> *simply
19:14:26 <chipdude> mm
19:14:39 <elliott> or, you could use a gadt to bundle the dictionary with the data type (but you probably don't need/want this)
19:16:47 <prof7bit> so by the same logic it should also be possible with the same mechanism of fmap for example to fmap the addition of two integers over into the Maybe subcategory and have the addition of Maybe integers, correct?
19:17:58 <chipdude> elliott: I just googled GADTs, found an initial paragraph beyond me, and add it to my education list
19:18:07 <elliott> hehe
19:18:26 <kallisti> I'm curious what you meant by "carry the dictionary around" I wasn't aware you could do that.
19:18:32 <elliott> gadts are one of the "big" extensions that add  large amount of power to the type system
19:18:45 <elliott> *add a large
19:18:51 <dmwit> prof7bit: Yes, definitely.
19:18:55 <elliott> kallisti: data Foo a where Foo :: (Show a) => a -> Foo a
19:18:59 <elliott> blah :: Foo a -> String
19:19:02 <elliott> blah (Foo a) = show a
19:19:03 <dmwit> > fmap (+3) (Just 7)
19:19:04 <lambdabot>   Just 10
19:19:06 <elliott> also works with existential "a"
19:19:11 <elliott> i.e. blah :: Foo -> String
19:19:16 <kallisti> ah okay
19:19:18 <dmwit> prof7bit: Actually, binary operators are a bit of a weird thing.
19:19:55 <dainanaki> what are the performance implications of using existential quantification?
19:20:15 <elliott> dainanaki: well, in GHC it'll carry around the instance dictionary
19:20:18 <elliott> in the data type
19:20:19 <prof7bit> i experimented a bit with map and fmap and list and suddenly had strange things like [Int -> Int] instead of [Int] -> [Int]
19:20:27 <elliott> and there's no chance of any kind of specialisation
19:20:33 <dmwit> prof7bit: Yes indeed.
19:20:48 <elliott> (is prof7bit in want of Applicative?)
19:20:57 <kallisti> (seems relevant)
19:21:01 <dmwit> prof7bit: Just work out what fmap should do with a binary operator, remembering that a type like "a -> a -> a" corresponds to the arrow with domain/codomain pair "a |-> (a -> a)".
19:21:11 <kallisti> (I feel safe in my parentheses. it's nice and cozy here.)
19:21:23 <dmwit> elliott: prof7bit will want it shortly, but for now I think is just learning category theory. =)
19:21:29 <Sgeo> :t fmap (++) []
19:21:30 <lambdabot> forall a. (Monoid a) => [a -> a]
19:21:40 <Sgeo> ++ is mappend in Caleskell?
19:21:42 <dmwit> :t fmap (+)
19:21:42 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
19:21:44 <kallisti> yes
19:21:44 <dmwit> Sgeo: yes
19:21:53 <dainanaki> elliott: I've heard vague mentions that you can use existensials to speed certain kinds of code up somehow, but I don't understand how that would work.
19:22:12 <chipdude> elliott: in ghc, if the record's field were constrained, would the dictionary be bundled into the record's type as well?  or is the GADT form the only way to do that?
19:23:04 <elliott> chipdude: depends what you mean by record's field being constrained. but I would *strongly* recommend putting the constraint on the functions instead
19:23:11 <dmwit> prof7bit: (As elliott is saying, having *just* fmap isn't enough to do all the kinds of things you might want to do. You need a more restrictive structure than functors; in particular, you often want an applicative functor or a monad instead.)
19:23:18 <elliott> you'll need a constraint on introducers (i.e. anything that construct such a value) anyway
19:23:23 <chipdude> elliott: I'm asking about an implementation detail more than advice
19:23:31 <elliott> right
19:23:35 <elliott> well, it depends what you mean
19:23:42 <elliott> there are lots of kinds of constraining you could do
19:23:47 <chipdude> morbid curiousity, not any other reason.  I'm a langauge implementor in one of my secret identities
19:23:53 <elliott> data (C a) => T a = ... -- useless, not in ~haskell 2011
19:24:18 <elliott> data T a = (C a) => T { ... } -- I forget how this one works; I think it just adds a C constraint to the T constructor and doesn't bundle it
19:24:23 <prof7bit> dmwit: I read that one can learn Haskell without CT but I absolutely need to know why you are all talking in this strange vocabulary all day long so I need to learn at least enough to know *why* it is relevant.
19:24:36 <elliott> haskellers don't talk in category theory all day
19:24:44 <elliott> "functor" and "monad" are as close as we get
19:24:54 <chipdude> hehe.  that last example is what I meant.  ty
19:24:58 <nyingen> iirc there's a specialized irc channel for the category-theorist-haskellers
19:25:03 <dmwit> Some Haskellers talk in CT all day. =)
19:25:13 <adam_> so if I took a class on abstract algebra, would that help out? or are the concepts only distantly related?
19:25:15 <elliott> you're either seeing only tangentially haskell-related discussions actually about category theory, or terms /not/ about CT but that sound "CTy" enough :)
19:25:35 <elliott> dmwit: yeah, I meant "in their capacity as Haskellers"
19:25:40 <prof7bit> I have the impression some of you even *think* in CT
19:25:48 <dmwit> Abstract algebra is usually based on set theory. But having a background in AA often gives some nice motivating examples for particular CT definitions.
19:25:49 <chipdude> there is a category of such people
19:25:58 <prof7bit> i need to know why and so there is no way around it for me.
19:26:08 * kallisti is just a set of morphisms from Time -> Time
19:26:18 <dmwit> prof7bit: I applaud your efforts to learn CT. I think there's a lot of nice rewards at the end of that road.
19:26:25 <dmwit> You don't need to defend yourself to me!
19:26:30 <elliott> well, anyone who needs to know why a false statement is true will have a difficult time of things :) but dmwit is right, the goal is good even if the motivation is odd
19:27:44 <kallisti> er, actually. I guess I'm a set of morphisms Kallisti -> Kallisti
19:27:53 <hmax> hi guys, does anyone know, how quick will the issue with hackage trac be fixed?
19:28:04 <dmwit> kallisti: That's good, small categories are most convenient.
19:28:06 <hmax> or mb someone has the http://hackage.haskell.org/trac/hackage/raw-attachment/ticket/872/ghc7.diff ?
19:29:04 <kallisti> dmwit: yes I agree, in that they're the only ones I know remotely anything about.
19:29:13 * elliott is a cat of small cats
19:29:22 <elliott> Mu Meow
19:29:39 * kallisti is a 2-3 finger tree of cats of small cats.
19:30:06 <kallisti> what other absurd sounding teminology can I string together.
19:30:25 <CodeWeaver> What happens if you map maps to spam?
19:30:48 <chipdude> the black hole lists reify
19:31:50 * hackagebot github-backup 1.20120126 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20120126 (JoeyHess)
19:41:49 <prof7bit> <elliott> well, anyone who needs to know why a false statement is true <-- I intentionally overexaggerated the situation a bit. but it still seems it is an important topic. So I cannot ignore it.
19:43:17 <elliott> :)
19:43:34 <elliott> well, it might help in understanding category-extras :P
19:45:37 * dainanaki is a nyan category
19:46:02 <prof7bit> i have read a few blog posts and articles and book intros already and some even say it will help me get a better understanding of more than just pogramming.
19:48:30 <dmwit> If you are not into maths, you may find the claims that category theory unifies many areas of mathematics to be a bit unsatisfying.
19:48:48 <chipdude> Having read up on GADTs, I must remind myself of one of the most trenchant proverbs of Klortho The Magnificent
19:48:51 <dmwit> If you *are* into maths, you will find you can't help but use the terminology of category theory when discussing new mathematics.
19:48:57 <chipdude> "If you don't know what it does, then why did you put it in your program?!"
19:49:26 <dmwit> Your colleague will laboriously outline a new construct and ten laws it must satisfy, and you will nod and say, "Oh, yes, I see, it's just a natural transformation in the appropriate category.".
19:49:47 <dmwit> And then you can forget the ten laws because you will be able to derive them again yourself as necessary by remembering the final sentence only.
19:51:46 <dainanaki> dmwit: Supposing that I am wanting to learn up to category theory from only a very shaky understanding of basic discrete mathematics, how would I go about doing so?
19:51:47 <elliott> Also you can walk through walls and punch buildings out of the ground.
19:51:58 <elliott> All thanks to the power of category theory!
19:52:39 <dmwit> dainanaki: The thing that worked for me was finding a few other guys that wanted to learn it and making them teach me it as they learned. =D
19:53:12 <byorgey> prof7bit: you may be interested in http://www.cs.nott.ac.uk/~gmh/cat.html and http://www.haskell.org/haskellwiki/User:Michiexile/MATH198
19:54:01 <byorgey> dainanaki: you may also be interested in those links I just pasted.
19:54:18 <dmwit> More seriously, you might like "lecture notes on category theory" by Michael Barr
19:54:18 <prof7bit> bookmarked :-)
19:54:48 <byorgey> also, http://blog.sigfpe.com/2010/03/partial-ordering-of-some-category.html
19:54:50 <dmwit> And "Topoi", available from Amazon: http://www.amazon.com/Topoi-Categorial-Analysis-Logic-Mathematics/dp/0486450260/
19:54:55 <dmwit> and n-cat-lab, of course
19:55:02 <byorgey> but be warned that it will take you three years to work through that last one
19:55:07 <dainanaki> my issue is that I don't really know mathematical logics / how to do proofs
19:55:19 <byorgey> n-cat-lab is not terribly useful for those just learning, IMO
19:55:29 <tikhonjelvis> dainanaki: The best way to learn is to do some :) It's fun.
19:55:31 <hmax> http://hackage.haskell.org/trac/hackage/ guys?
19:55:35 <dmwit> Proofs in category theory are easy. You draw the diagrams that are supposed to commute, and then observe that they do, indeed, commute.
19:55:38 <dmwit> QED
19:55:39 <byorgey> it tends to discuss everything at the highest possible level of abstraction.
19:55:53 <dmwit> That is my impression, as well.
19:55:59 <cmccann> byorgey, I find nlab useful at times
19:56:09 <cmccann> mostly when I need to be reminded that I am in fact a programmer
19:56:13 <cmccann> not a mathematician
19:56:18 <dmwit> Why bother defining functors on boring old categories when you can define them on enriched n-categories instead?
19:56:18 <byorgey> hehehe
19:56:26 <tomprince> Doesn't lawevere have a category theory book aimed at lay-people.
19:56:32 <byorgey> dmwit: you mean (infinity,1)-categories!
19:56:34 <vyom> when I do a ghc --info on my OS X Lion, it says that the linker flags are set to "-m32". I am wondering where that comes from and how to change it
19:56:42 <dmwit> byorgey: I would mean that if I knew what it meant!
19:56:43 <byorgey> dmwit: n-categories are boring
19:56:51 <byorgey> dmwit: well, I sure don't!
19:57:04 <byorgey> I just saw it on n-cat-lab is all =)
19:57:10 <dmwit> haha
19:57:35 <byorgey> hmax: dunno, sory =(
19:57:50 <hmax> byorgey, k, got it
19:58:06 <hmax> maybe someone has the ghc7.diff for making 7.2 and cabal-install work together?
19:58:29 * cmccann tries to develop a better intuition for linear logic
19:58:30 <byorgey> tomprince: oh, yes, "Conceptual Mathematics" I think it's called
19:58:53 <byorgey> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170
19:59:05 <prof7bit> somebody else recommended this to me and I ust started reading: http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170
19:59:42 <tomprince> That's it.
20:01:04 <prof7bit> so far it is ok, but I'm only on page 40 so far :-)
20:01:12 <hmax> i recently met up with category theory in a book on real analysis
20:01:18 <hmax> got scared and stopped reading it :D
20:01:37 <byorgey> prof7bit: yeah, that book is supposed to be good I think
20:01:41 <byorgey> I haven't read it myself
20:02:16 <byorgey> prof7bit: anyway, no matter what you start with you are going to have to read several different things, and keep coming back to the same concepts from different points of view until they sink in
20:02:54 <dainanaki> tomprince: where did you go to university?
20:03:15 <byorgey> in my experience that has seemed more true with CT than with most other things I learn.  for any given concept X I only seem to really get it after like the 4th or 5th time seeing it.
20:03:21 <tomprince> University of Alberta, and currently PhD at University of Western Ontario
20:03:49 <tikhonjelvis> Ooh, Canada.
20:03:58 <dmwit> My paper is all soupy and my soup is all papery. =(
20:04:24 <elliott> Mix them together and get paper soup, the best of both worlds.
20:04:26 <dainanaki> tomprince: then you aren't the Tom Prince that iI know.
20:05:21 <tomprince> dainanaki: Where's the Tom Prince you know from?
20:05:25 <dainanaki> Texas
20:06:02 <dainanaki> he is a programmer, but not a Haskeller afaik
20:06:24 <dmwit> elliott: That is the exact sequence of events that led to this catastrophe!
20:06:35 <byorgey> dmwit: you're supposed to dip your bread in your soup, not the paper you're reading
20:06:52 <dmwit> elliott: I'm never retroactively taking your advice again.
20:07:17 <dmwit> byorgey: ...now I know =(
20:07:17 <elliott> dmwit: My contract covers only damage as the result of causal advice-taking.
20:07:35 <elliott> You violate the laws of physics at your own risk.
20:07:56 <dmwit> Ah, the treachery of functional reactive gastronomy
20:08:08 <cmccann> elliott, what if there was time travel involved? need to account for causal loops.
20:08:17 <cmccann> pretty sure that's a thing that can happen.
20:08:23 <elliott> dmwit: A word of advice: Be careful to avoid space leaks.
20:08:31 <elliott> It's hard to breathe in space, you know?
20:09:10 <elliott> cmccann: My contract is constantly moving forward in time at one second per second. If you go back or forward in time, then you lose it, and have to catch up for it to apply again.
20:09:12 <dmwit> "contents of this jar: 100% vacuum"
20:09:17 <elliott> (Or catch down, if you went to the future.)
20:09:38 <cmccann> elliott, ok. makes sense.
20:20:59 <cmccann> I wonder if thinking that linear logic would be a good basis for an API design means I've gone mad :T
20:21:12 <dmwit> It means you've joined the dark side.
20:21:29 <dmwit> Linear logic was sort of invented to be a good basis for API design.
20:21:32 <dmwit> So... yeah.
20:21:37 <cmccann> dmwit, fortunately that's also the light side by duality
20:22:06 <cmccann> dmwit, it's more the concern of whether anybody understands linear logic well enough to use something like that
20:22:20 <dmwit> oh, yes, well
20:22:35 <dmwit> There's dozens of us, man!
20:22:36 <Philippa> it can help to find wordier translations of the connectives, things like that
20:22:36 <dmwit> DOZENS
20:22:52 <elliott> cmccann: Do most programmers understand anything they're doing?
20:22:54 <Philippa> a good not-quite-formal explanation tied to the formalism can go a long way
20:23:22 <tikhonjelvis> elliott: Hah, most of them claim to be too busy "getting stuff done" to understand...
20:23:25 <CodeWeaver> elliott: I'd like to think so.
20:23:46 <elliott> CodeWeaver: That seems incredibly over-optimistic.
20:23:58 <elliott> Programming has a lot of layers.
20:23:59 <cmccann> Philippa, I'd love to see a less-formal explanation of ⅋ that makes sense
20:24:11 <cmccann> actually I'd like to see any explanation of ⅋ that makes sense
20:24:32 <elliott> cmccann: it's like a 3 but bent a bit at the top and with an extended top curve bit and a diagonal line striking through a bit at the top
20:24:45 <Philippa> mmm. It's 5am here, my sleep patterns are wonky and I haven't touched actual linear logic in some time, or I'd take a shot at it. Also, my font doesn't appear to have the character
20:24:49 <CodeWeaver> elliott:  I said I'd like to *think* so.
20:25:08 <elliott> 5 am is the perfect time to do linear logic!
20:25:10 <Philippa> (latex code?)
20:25:31 <cmccann> Philippa, it's par, the upside down & symbol
20:25:37 <tikhonjelvis> Philippa: Try using a deja-vu font.
20:25:38 <Philippa> oh, also: I'm just starting on an overdue (non-haskell-related) blog post, and I'm crap at starting. Prod me in a bit to see if I'm stalling though?
20:25:57 <tikhonjelvis> Grr. Copying and pasting ⅋ works but \par gives me this:  , which doesn't.
20:26:01 <elliott> Oh, it's an upside-down &.
20:26:06 <elliott> That makse much more sense.
20:26:10 <cmccann> I've sketched out a few approaches using linear logic for modeling something, and the par connective always ends up corresponding to the most baffling-yet-legal corner of the API
20:26:22 <elliott> ʇǝ
20:26:35 <dmwit> "par" is the connective that says you get to look at one or the other side, but not both, isn't it?
20:26:58 <dmwit> Oh, no, par is the disjunctive one.
20:27:14 <cmccann> I really have no idea how to describe it, honestly
20:28:12 <dmwit> No, "par" is the one I'm thinking of.
20:28:39 <byorgey> par is the one that says you get to travel back in time to ask which one of the sides you would have gotten to look at later, if only you hadn't looked at the other one
20:28:41 <dmwit> It's called "par" because you can think of it as a parallel race between two threads, one producing an "A" and one producing a "B". Only one wins.
20:28:50 <cmccann> byorgey, that sounds about right
20:29:12 <tikhonjelvis> Aha: ⅋! I can type it by manually entering the code point in hex.
20:29:48 <byorgey> ok, joking aside, I think there's a nice game-semantics way to understand it, but I forget what it is
20:30:10 <byorgey> game semantics is the most intuitive way to think about linear logic I've seen.
20:30:34 <cmccann> yeah
20:31:14 <sipa> can someone please come up with a burrito analogy?
20:31:25 <cmccann> the ideas I'm mulling over right now kinda seem more intuitive to me but that's probably just because I've been thinking about them a lot
20:32:07 <byorgey> sipa: for linear logic?
20:32:28 <dmwit> Oh, yes, I suppose that's the other problem: there's two dual explanations of a type. One tells how to construct a value of that type, and the other tells how to consume one.
20:32:46 <cmccann> dmwit, how's that a problem?
20:32:50 <byorgey> burritos work well for linear logic actually, since you can't duplicate them and you have to eat them or else they get moldy
20:33:01 <cmccann> dmwit, that's what makes it all useful, if anything
20:33:18 <dmwit> cmccann: By "problem" I mean it makes the pedagogy a bit touchy. You just have to be extra careful about that kind of thing with linear logic compared to other logics, I think.
20:33:23 <dolio> You just consume it with the dual type, no?
20:33:23 <cmccann> byorgey, unless they're exponential burritos
20:33:45 <byorgey> cmccann: right, gotta be careful with those
20:33:49 <elliott> Someone needs to invent the Burrito typeclass.
20:36:03 <byorgey> class Burrito b where fill :: a -> b a; eat :: b a -> (a -> Energy) -> IO ()
20:37:20 <byorgey> quick, name as many partial Prelude functions as you can
20:37:31 <byorgey> I am making a slide of functions my students should avoid
20:37:37 <elliott> class Burrito b where fill :: a -> b a; unwrap :: b a -> b (a, b ()); eatAndAlsoMakeANewMetaBurritoWhichYouThenDevourForSomeReason :: b a -> (a -> b () -> b (b c)) -> c
20:37:47 <dmwit> fromInteger!
20:37:52 <tikhonjelvis> head, tail...
20:37:52 <elliott> byorgey: head, tail, init, div
20:37:55 <dmwit> succ
20:37:57 <elliott> byorgey: fromJust
20:37:58 <cmccann> byorgey, minimum, maximum
20:38:05 <elliott> fix
20:38:10 <tikhonjelvis> fold.1
20:38:11 <cmccann> foldr1, foldl1
20:38:14 <dmwit> (and pred, of course)
20:38:26 <byorgey> fromInteger, what!
20:38:36 <elliott> You object to fromInteger but not fix?
20:38:50 <dmwit> Basically everything in the Enum typeclass, in fact.
20:39:01 <elliott> Honestly, half the functions in the Prelude are partial on some edge-cases.
20:39:04 <dmwit> > fromInteger (2^100) :: Word32
20:39:04 <lambdabot>   0
20:39:10 * dmwit harumphs
20:39:27 <elliott> maximum/minimum should require Bounded.
20:39:36 <sipa> :t maximum
20:39:37 <lambdabot> forall a. (Ord a) => [a] -> a
20:39:38 <elliott> maximum [] = minBound; minimum [] = maxBound
20:39:41 <dmwit> maximum/minimum should just return a Maybe
20:39:48 <byorgey> elliott: yes, that would make sense
20:39:55 <elliott> because then (maximum []) is the identity for max, etc.
20:39:57 <dmwit> This "return a sentinel value" is C-style nonsense.
20:40:03 <elliott> dmwit: That's not a sentinel!
20:40:06 <elliott> That's just the same as
20:40:07 <dmwit> Yes it is.
20:40:07 <elliott> > product []
20:40:08 <lambdabot>   1
20:40:09 <elliott> > sum []
20:40:09 <lambdabot>   0
20:40:16 <sipa> > minimum []
20:40:17 <lambdabot>   *Exception: Prelude.minimum: empty list
20:40:26 <elliott> The foldy-thing of a binary operation on an empty list is its identity element.
20:40:27 <dmwit> How do I know whether the maximum is actually maxBound or you're just telling me it is because you don't know what else to do?
20:40:42 <elliott> How do you know whether the product is actually 1 or you're just telling me it is because you don't know what else to do?
20:40:48 <cmccann> yeah, folding with mempty and mappend makes sense as the general idea for those functions
20:40:51 <tikhonjelvis> Besides, wouldn't it actually make sense for the maximum of an empty list to be minBound?
20:40:56 <cmccann> yes
20:41:06 <dmwit> elliott: That's a fair point. Let me phrase my complaint differently.
20:41:17 <tikhonjelvis> :t maximum
20:41:18 <lambdabot> forall a. (Ord a) => [a] -> a
20:41:25 <dmwit> Currently, the output of maximum is always an element of the input. I like this property.
20:41:45 <byorgey> dmwit: no it isn't, sometimes the output is _|_
20:41:54 * dmwit nods appreciatively
20:41:59 <dmwit> Hence why it should have a Maybe return type.
20:42:13 <tikhonjelvis> byorgey: That's implicitly there everywhere.
20:42:15 <cmccann> byorgey, oh, and cycle
20:42:19 <cmccann> > cycle []
20:42:20 <lambdabot>   *Exception: Prelude.cycle: empty list
20:42:21 <dmwit> read(s) is partial
20:42:29 <byorgey> woah! didn't know about cycle,
20:42:30 <dmwit> err... read, but not reads, I mean
20:42:47 <cmccann> byorgey, it's kind of obvious I guess, cycle [] makes no sense
20:42:48 <dmwit> > abs (1 :+ 2)
20:42:49 <lambdabot>   2.23606797749979 :+ 0.0
20:42:51 <cmccann> but it surprised me too
20:42:53 <byorgey> cmccann: indeed
20:43:10 <byorgey> cmccann: I mean, I guess it could return []
20:43:25 <byorgey> but either way it's a weird edge case
20:43:25 <cmccann> it could, but that would be weird
20:43:40 <byorgey> really the type of cycle ought to be  NonEmptyList a -> Stream a
20:43:40 <tikhonjelvis> Ooh, what about div?
20:43:49 <dmwit> I guess we already covered the div/mod/quot/rem/divMod/quotRem/(/)/recip thing.
20:43:49 <dmwit> Hm, is mod actually partial?
20:43:49 <dmwit> > 3 `mod` 0
20:43:49 <lambdabot>   *Exception: divide by zero
20:43:54 <elliott> dmwit: Maybe return type would be fine.
20:44:02 <elliott> But there's an elegance about the Bounded thing.
20:44:05 <elliott> Wait, no.
20:44:08 <elliott> Maybe return type wouldn't be fine at all.
20:44:15 <elliott> minimum :: (Ord a) => NonEmpty a -> a, pls.
20:44:37 <byorgey> now there's a type I can get behind.
20:44:38 <elliott> (How do you know whether the minimum is actually Nothing or you're just telling me it is because your type allows you to lie? etc.)
20:44:40 <cmccann> byorgey, also I don't think anyone said (!!) yet
20:44:40 <dmwit> I guess the numerical partial functions aren't as interesting as the other ones.
20:44:53 <cmccann> but (!!) is terrible for other reasons anyhow
20:45:08 <dmwit> Ah, nobody mentioned error or fail. =D
20:45:16 <elliott> error is too partial to count as partial.
20:45:17 <byorgey> cmccann: funny, that's usually the first thing people mention!
20:45:22 <byorgey> anyway, I already had that on my list.
20:45:30 <elliott> The bad partial functions are the ones you can use where a _|_ might lurk undetected. :)
20:45:32 <cmccann> elliott, it's more... co-total
20:45:37 <elliott> Yes!
20:46:06 <dmwit> last
20:46:12 <CodeWeaver> *starts littering _|_ traps around the chatroom*
20:47:04 <cmccann> byorgey, also various strict folds when applied to infinite lists
20:47:16 <cmccann> but that's getting into "so don't do that" territory
20:47:19 <byorgey> yeah
20:47:23 <byorgey> oh, and splitAt
20:47:32 <dmwit> really?
20:47:36 <dmwit> > splitAt 10 [1..5]
20:47:37 <lambdabot>   ([1,2,3,4,5],[])
20:47:41 <dmwit> not splitAt
20:47:56 <dmwit> > scanl1 (+) [0..]
20:47:57 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
20:47:57 <byorgey> oh!
20:48:01 <dmwit> > scanl1 (+) []
20:48:01 <lambdabot>   []
20:48:09 <byorgey> > splitAt (-2) [1..5]
20:48:10 <lambdabot>   ([],[1,2,3,4,5])
20:48:38 <byorgey> @check \n l -> splitAt n l == splitAt n l
20:48:38 <lambdabot>   "OK, passed 500 tests."
20:48:42 <dmwit> readLn, ioError, and userError all seem to be in the Prelude
20:48:51 <cmccann> byorgey, btw, suggestion: google search "site:hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/ error"
20:49:01 <cmccann> likewise fail/undefined/&c.
20:49:26 <cmccann> base is mostly polite enough to not simply have non-exhaustive matches and such
20:49:26 <loius384> SOPA wins :S -> http://adf.ly/50eZt
20:49:37 <byorgey> ah, digitToInt
20:50:25 <amiller> i have a monad question
20:50:36 <amiller> instance Monad m => BtcMachine (StateT ([String],[String]) (ErrorT String m)) where
20:50:40 <amiller> ...
20:51:11 <amiller> and the class is class Monad m => BtcMachineT m where ...
20:51:41 <amiller> the question is, is should BtcMachine itself be an instance of monad transformer
20:51:59 <cmccann> byorgey, searching like that's how I started when writing a replacement prelude that I use for random hacking, heh
20:52:18 <dmwit> amiller: The question is ill-formed. BtcMachine is a class, not a type constructor.
20:52:42 <dmwit> (...and only type constructors can be monad transformers.)
20:53:17 <amiller> hm
20:53:47 <amiller> i'm not even sure i could point to the type constructor in here
20:55:42 <Philippa> amiller: did you mean for BtcMachine to be a type constructor of kind (* -> *) -> * such that BtcMachine m's an instance of Monad if m is?
20:57:00 <Philippa> if so, instance Monad m => Monad (BtcMachine (StateT ([String],[String]) (ErrorT String m))) where ... ?
20:57:25 <Philippa> then yeah, you probably do want BtcMachine to be an instance of MonadTrans
20:58:15 <dmwit> perhaps just newtype BtcMachineT m = BtcMachineT (StateT (...) (ErrorT String m)) deriving MonadTrans
20:58:22 <dmwit> and no class BtcMachine at all
21:00:58 <Philippa> I'm guessing the class was a syntactic accident, but yeah
21:01:23 <Philippa> amiller: are we reading your situation right? What are you trying to accomplish?
21:03:06 <amiller> i do have functions associated with BtcMachine as a class
21:03:53 <amiller> say 'push' and 'pop', that aren't what are provided by the actual StatetT and ErrorT
21:04:50 <Philippa> ah, okay. And multiple valid BtcMachine instance
21:04:52 <Philippa> s
21:05:22 <amiller> well in this case i believe a valid instance of BtcMachine must be a complete monad
21:05:30 <amiller> so there's a valid BtcMachine instance for every Monad m
21:05:35 <Philippa> are BtcMachines supposed to provide access to their underlying monad? If someone builds one on top of IO, should knowing that something's a BtcMachine built on IO be enough to let you print "Hello World"?
21:05:44 <Philippa> ah, then you're SOL anyway
21:05:48 <Philippa> at least, if you declare that
21:05:56 <Philippa> overlapping instances and all that
21:06:00 <dmwit> um
21:06:08 <dmwit> Philippa, I think you're misunderstanding him again.
21:06:57 * elliott agrees
21:06:57 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
21:07:03 <elliott> amiller: I think you are misusing "class".
21:07:09 * dmwit agrees
21:07:15 <dmwit> amiller: You probably don't want a class at all.
21:07:18 <elliott> You probably mean that you have functions associated with the monad BtcMachine.
21:07:19 <dmwit> amiller: Just a new data type.
21:07:25 <elliott> Typeclasses aren't like OOP classes.
21:09:03 <Philippa> dmwit: quite possible, but then I was a fair way down the road to exposing that if it's the case?
21:09:04 <amiller> ok i think i see that a newtype is sufficient here
21:09:40 <amiller> Philippa, no i don't expect to provide access to the underlying monad
21:10:08 <Philippa> okay, you don't want a MonadTrans instance then - that's what MonadTrans is about
21:11:31 <elliott> amiller: You don't ahve to provide access to the StateT ErrorT.
21:11:37 <elliott> MonadTrans provides access to the m.
21:11:48 <elliott> If you're parametrising over m, you probably *do* want MonadTrans, otherwise the "m" parameter is useless.
21:11:54 <dmwit> yes
21:12:30 <dmwit> I find it most likely that, as someone who hasn't done this before, you only answered that way because you don't know yet what Philippa means by "access to the underlying monad". =)
21:12:32 <Philippa> it can occasionally save you the odd bit of wiring still
21:12:43 <amiller> hm okay so in other words without the 'lift' then the m can't be used at any higher level
21:12:51 <elliott> yeah
21:12:57 <elliott> lift :: m a -> BtcMachine m a
21:12:59 <elliott> in this case
21:13:00 <Philippa> right, the lift lets you travel between floors
21:13:15 <elliott> the "internal" parts of BtcMachine aren't exposed
21:13:22 <Sgeo> `quote erlang
21:13:47 <elliott> @quote erlang
21:13:47 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
21:13:47 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
21:14:02 <amiller> what i'd like to indicate with the function that matches BtcMachine is that it only uses the get/put/fail from StateT and ErrorT, but not the underlying monad m
21:14:04 <elliott> A different time.
21:14:36 <copumpkin> amiller: universally quantify over a MonadState instance?
21:14:42 <elliott> amiller: If you write
21:14:47 <elliott> foo :: BtcMachine m -> ... result ...
21:14:50 <elliott> then foo can't do anything in m
21:14:58 <Philippa> amiller: how is that different from just using a StateT Error?
21:15:00 <elliott> because it doesn't know what m might be, so there's no useful operations it can do
21:15:49 <Philippa> elliott: yeah. The only use for it is if you've got some functions in m that combine BtcMachines and mess around with their states - and even then that only saves you a little copying
21:16:05 <dmwit> I think you can't usefully universally quantify over m here.
21:16:14 <dmwit> You at least need a Monad m constraint.
21:16:16 <elliott> Philippa: not sure how that relates to what I said
21:16:17 <elliott> dmwit: Oh, er, yes.
21:16:22 <elliott> Sorry, I intended to include such a constraint.
21:16:41 <Philippa> elliott: the one possible 'use' for being parameterised on m rather than just using StateT Error
21:16:48 <amiller> universally quantify over Monad m is what i have now, and it seems to work
21:16:52 <dmwit> So it's not quite true that you can't use anything from the underlying monad -- you can use bind and return -- but you don't get anything *interesting* from the underlying monad.
21:17:05 <Philippa> (or a typeclass, so that you can have multiple implementations of the BtcMachine operations)
21:17:06 <CodeWeaver> *feeling seriously outclassed all afternoon sitting on here*
21:17:07 <amiller> in that what i want is to be able to use the unit/bind of the underlying monad m but none of the details of stateT or errorT
21:17:23 <dmwit> amiller: Yes, that is exactly the guarantee you will get.
21:17:38 <elliott> Philippa: I presume that _user_ BtcMachine code will use m.
21:17:42 <Philippa> and then if you want to use /anything else/ from the underlying monad, you want MonadTrans
21:17:49 <elliott> And amiller just wants generic algorithms that only operate on the BtcMachine part.
21:18:00 <elliott> If not, that's a really weird thing to want.
21:18:03 <Philippa> (underlying monad = m)
21:19:21 <amiller> so do i still get this property even if BtcMachine m implies MonadTrans
21:19:28 <Philippa> yes
21:19:31 <amiller> there's a lift, but i'm still universally quantifying over the monad m
21:19:39 <Philippa> you can write it to lift straight through to m, not to the StateT or the ErrorT
21:19:52 <amiller> ah okay yes exactly
21:20:01 <elliott> "implies" -- has an instance
21:20:02 <amiller> it's a lift _around_ statet and errort
21:20:07 <elliott> (although technically it's BtcMachine that has the instance)
21:20:12 <Philippa> not around, through :-)
21:20:16 <amiller> _through_
21:20:16 <elliott> below :P
21:20:19 <elliott> or through, yes
21:20:50 <Philippa> "through" matters because m can 'affect' the wiring for the StateT or the ErrorT
21:21:31 <Philippa> for example, if m's another ErrorT then it can backtrack everything in BtcMachine's StateT and ErrorT
21:23:05 <amiller> i can't think of an example that would make use of the lift-through
21:24:18 <Philippa> it's more that if you use lift at all, you can't avoid the consequences
21:24:29 <Philippa> for example: if you do some IO and it throws an exception...
21:25:18 <elliott> amiller: any time when you need to run an m a in a BtcMachine m a
21:25:26 <elliott> if you never need to do that, what is m there for in the first place?
21:27:11 <amiller> ok so even in the example with the second ErrorT, if i wanted to catch an exception in BtcMachine (ErrorT s m) a, i would need to use the lift
21:28:07 <amiller> where the ErrorT in that line is a 'second' errorT, the first one is concealed within the btcmachine and the lift goes through that one
21:29:43 <elliott> right. note that you can define instances in such a way that you can forget about lift entirely
21:29:48 <elliott> thanks to the standard monad transformer classes
21:30:00 <elliott> but that may or may not make sense depending on your situation
21:30:11 <elliott> e.g. if you want to provide MonadState or MonadError instances using the internal BtcMachine parts
21:31:29 <Philippa> eh. You can forget about the standard operations so long as they're not duplicated and not in IO. Not the same thing.
21:31:37 <elliott> fair enough :)
21:32:07 <amiller> ok so  may be able to do this with a 'deriving MonadTrans' and newtype rather than a class?
21:33:45 <amiller> well i'll have a look at those anyway, thank you for the clarification and suggestions
21:40:32 <elliott> amiller: yes
22:07:12 <tikhonjelvis>  /names
22:08:44 <elliott> tikhonjelvis: "a lot"
22:09:04 <tikhonjelvis> yes
22:26:49 <tikhonjelvis> Oh hey, turns out I need more help building wx.
22:26:57 <tikhonjelvis> This time I put the error on hpaste: http://hpaste.org/56969
22:27:10 <tikhonjelvis> However, it doesn't make sense because I have those libraries.
22:27:26 <elliott> The developer versions?
22:27:32 <tikhonjelvis> Yep
22:27:37 <elliott> Installed by package manager or similar?
22:27:42 <elliott> (i.e. no non-standard locations)
22:27:43 <tikhonjelvis> By yum, yes.
22:27:49 <tikhonjelvis> In /usr/lib64
22:28:01 <elliott> Right version? :P You could try --extra-lib-dirs=/usr/lib64, but I doubt that's it.
22:28:09 <tikhonjelvis> One thing that might be an issue is that they're all called lib* rather than just *
22:28:15 <tikhonjelvis> I tried that
22:28:24 <tikhonjelvis> And it is the right version–2.8
22:28:27 <elliott> That's how C libraries are named.
22:28:36 <tikhonjelvis> okay
22:28:39 <elliott> hmm
22:28:45 <tikhonjelvis> It just doesn't match the warning and I have a very literal mind.
22:28:58 <elliott> Perhaps it wants the pkg-config files and your distro doesn't include them or something.
22:29:14 <tikhonjelvis> pkg-config?
22:29:28 <tikhonjelvis> I'm on Fedora, for reference.
22:29:47 <elliott> tikhonjelvis: I guessed from the package manager :)
22:30:00 <elliott> pkgconfig is a thing for cflags/linker configuration that Cabal uses.
22:30:01 <tikhonjelvis> I could be using RHEL or CentOS!
22:30:06 <elliott> (yay, http://hackage.haskell.org/package/acme-strfry's docs built)
22:30:54 <Sgeo> elliott,
22:31:25 <tikhonjelvis> And people say Haskell lacks libraries...
22:31:38 <elliott> tikhonjelvis: Well, it was utterly unusable until now, of course.
22:31:41 <elliott> You can't go without strfry()
22:34:03 <tikhonjelvis> It seems I have pkg-config installed, anyhow. I'm going to assume that means it's used.
22:34:21 <elliott> not necessarily, if the pkg-config files for wx aren't upstream
22:34:34 <tikhonjelvis> Any way to check?
22:35:21 <elliott> ls /usr/share/pkg* ... dunno the exact path they'd be in but somewhre thereabouts
22:35:47 <tikhonjelvis> What should I look for there?
22:39:39 <elliott> tikhonjelvis: something with wx in it :)
22:40:06 <tikhonjelvis> Hmm, doesn't seem to have anything including wx there.
22:45:50 <startling> how do people feel about happy?
22:47:51 <Kanisterschleife> Hi. Why do some of the xlib library functions return values of type IO a (like lookUpColor), while others don't, like defaultScreeenOfDisplay? Both of them do not return same output on same input, do they, so naively I would expect defaultScreenOfDisplay to encapsulate its result in the IO monad as well.
22:49:52 <elliott> Kanisterschleife: Probably defaultScreenOfDisplay is just accessing the field of a value already accessed by the IO action.
22:50:06 <elliott> i.e. the IO action producing the Display value also gets the screen, or such.
22:50:33 <elliott> It's also possible that a display's default screen is defined not to change (maybe unless you make another request for the display)... I don't know much about Xlib, so these are just guesses.
22:53:07 <Kanisterschleife> elliott: Hmm ok, that would be plausible
22:58:22 <Kanisterschleife> Probably it depends on whether one should think of values of Display as concrete information or a pointer to information.
23:09:41 <srhb> Noob question: If I compile a haskell program with GHC 32bit on a 64 bit OS X system, will it run on 32 bit OS X?
23:22:22 <Lemmih> startling: I think overkill, usually.
23:23:55 <startling> yeah, I think I agree.
23:24:17 <startling> anyway, is there any way to get more verbose error messages out of it? I get `grammar.ly:51: Parse error`
23:24:37 <startling> (my file is 50 lines long)
23:24:39 <ChristianS> what's preferred instead? attoparsec? parsec?
23:34:40 <earthy> attoparsec is great
23:36:24 <adnam> taoeure
23:36:27 <adnam> ssh pb
23:36:39 <adnam> woops
23:36:45 <insertpseudonym> lol
23:36:45 <adnam> how did i not disconnect
23:36:56 <tikhonjelvis> Does Attoparsec work more or less just like Parsec?
23:37:04 <insertpseudonym> I oughta start using this in a terminal
23:37:10 <tikhonjelvis> Emacs!
23:37:20 <insertpseudonym> haha I'm a vim guy
23:37:33 <insertpseudonym> actually, sell me on emacs
23:37:37 <insertpseudonym> been thinking about a switch
23:37:40 <adnam> was juts about to blindly write my passowrd
23:37:44 <tikhonjelvis> M-x erc comes by default.
23:37:54 <tikhonjelvis> So I'm in Emacs now :)
23:37:59 <insertpseudonym> not familiar with it
23:38:04 <adnam> don't like having irc mixed up with my code
23:38:04 <Ralith> What emacs mode do people generally use for haskell?
23:38:05 <tikhonjelvis> It's an irc client.
23:38:12 <tikhonjelvis> The haskell mode.
23:38:13 <insertpseudonym> oh I see
23:38:16 <alang> haskell-mode
23:38:20 <insertpseudonym> so irc sold u on emacs haha
23:38:26 <tikhonjelvis> You can make it display λ and stuff.
23:38:32 <tikhonjelvis> It makes your code pretty.
23:38:40 <Ralith> The arch linux haskell mode gives me a "haskell-ghci is obsolete" warning every time it starts
23:38:43 <Ralith> what's up with that
23:38:50 <tikhonjelvis> Actually, Emacs sold me on irc.
23:39:14 <Ralith> that's odd
23:39:16 <Ralith> erc is pretty crappy
23:39:23 <tikhonjelvis> You can type useful characters like α → β using their TeX names.
23:39:41 <tikhonjelvis> Eh, it's more than good enough and supports all the normal Emacs commands.
23:39:44 <Ralith> that seems kind of trivial to script
23:39:59 <tikhonjelvis> If you're patient enough to support all the characters you want.
23:40:01 <Ralith> I just use XCompose for that kind of thing
23:40:19 <Ralith> α → β
23:40:21 <Ralith> yep, got those ^^
23:40:51 <Ralith> the default XCompose file has a pretty massive set as it is
23:41:46 <insertpseudonym> so quick Q
23:42:07 <insertpseudonym> I have a function I'm using recursively that outputs a list
23:42:28 <insertpseudonym> I'm using concat to merge separate lists in the call, but I'm getting an error
23:42:40 <insertpseudonym> actually lemme just paste the code
23:42:44 <Ralith> generally a good idea
23:42:53 <tikhonjelvis> Emacs has an hpaste mode :) I just learned about it today.
23:43:07 <Ralith> handy!
23:43:30 * Ralith has been settling for xclip -o |wgetpaste for a while; should look into emacs modes...
23:43:54 <tikhonjelvis> That's actually a nice thing about Emacs–there are modes for everything lying around.
23:44:32 <srhb> tikhonjelvis: Did you get the hpaste functions to work?
23:44:35 <hpaste> insertpseudonym pasted “hanoi_code” at http://hpaste.org/56987
23:44:38 <srhb> tikhonjelvis: My version seems very broken.
23:44:48 <tikhonjelvis> srhb: I used the region one successfully.
23:45:09 <insertpseudonym> pretty straightforward hanoi implementation
23:45:20 <insertpseudonym> I probably need to fix the logic (first time implementing this actually)
23:45:30 <Blkt> good morning everyone
23:47:13 <tikhonjelvis> insertpseudonym: You don't need the parentheses and commas when calling a function.
23:47:28 <srhb> Not only do you not need them, they are wrong
23:47:30 <tikhonjelvis> If you have them, it means you're passing in a tuple, which is wrong.
23:47:47 <tikhonjelvis> You should write 'hanoi (n - 1) a c b' instead.
23:48:15 <tikhonjelvis> Also, you can pattern match on numbers instead of using guards.
23:48:25 <tikhonjelvis> E.g. hanoi 1 a b c = [(a, c)]
23:48:32 <tikhonjelvis> hanoi n a b c = ...
23:48:55 <insertpseudonym> ah okay
23:48:59 <insertpseudonym> and yea good point about the guards
23:49:18 <insertpseudonym> somehow, I got attached to them after the first lecture
23:49:20 <tikhonjelvis> Also, are you sure you want peg to be a string?
23:49:38 <insertpseudonym> that's in the specification for the problem
23:49:44 <tikhonjelvis> ah
23:49:52 <srhb> insertpseudonym: Beat your lecturer with a newspaper, then. :-)
23:50:44 <insertpseudonym> srhb: lol I don't want to go there yet
23:50:58 <srhb> insertpseudonym: Ok, it was bad advice. :-)
23:51:06 <Jafet> Well, strings are the ultimate meaningless type, which suits its use here perfectly.
23:51:27 <insertpseudonym> srhb: apparently, he helped work on the glasgow compiler so I'm inclined to trust his judgment for the most part
23:51:49 <srhb> insertpseudonym: That sounds wise. :-)
23:51:53 <tikhonjelvis> That doesn't mean you should use strings like that in real life though.
23:52:17 <insertpseudonym> point taken
23:52:39 <tikhonjelvis> Besides, if I always listened to my professors, I'd probably be using Python...
23:53:21 <silver> #h is for hate for python
23:53:51 <Jafet> There's nothing wrong with Python; it's just a bit constricting.
23:54:51 <tikhonjelvis> It certainly isn't the worst language I've ever used, but I like a bunch of them more.
23:57:14 <tikhonjelvis> Although I did have one awesome professor who liked Scheme.
