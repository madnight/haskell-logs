00:01:37 <g06|in> i thought i understand foldr
00:08:13 <g06|in> take 10 (foldl (\acc x -> x : acc) [] [1..]) - this one fails… I guess I understand why
00:08:34 <shachaf> g06|in: You do?
00:10:46 <g06|in> shachaf: yes. to me the idea of taking apart elements one by one and applying func seemed like foldl and thought should work; but if I try understanding the expansion first then I see that its different
00:12:30 <shachaf> <shachaf> g06|in: Your words don't make sense to me (although the meaning behind them might make sense, who knows).
00:15:53 <Sgeo> http://stackoverflow.com/questions/3893202/departmental-restriction-against-unsafeperformio is there an answer to keegan's question about switching over to ST?
00:15:57 <g06|in> shachaf: sorry… what I wanted to say was - I keep thinking the way foldl should work is take the first element of the list and apply f on this and the initial value. Proceed only if more output is required. But if I try to see foldl expansion I see the issue.
00:18:37 <Sgeo> "Proceed only if more output is required" is pretty much how foldr works
00:18:50 <g06|in> Sgeo: I understand now
00:20:47 <g06|in> if I've a large list and I try foldl and foldr to do (+) on them, would foldr and foldl take the same time? or would foldl run fast?
00:21:19 <sanjoyd> @djinn (a -> Int) -> (a -> String)
00:21:20 <lambdabot> Error: Undefined type Int
00:24:27 <Sgeo> > foldr (+) 0 [1..1000]
00:24:28 <lambdabot>   500500
00:24:30 <Sgeo> > foldr (+) 0 [1..10000]
00:24:31 <lambdabot>   50005000
00:24:33 <Sgeo> > foldr (+) 0 [1..100000]
00:24:34 <lambdabot>   5000050000
00:24:36 <Sgeo> hmm
00:24:42 <Sgeo> > foldr (+) 0 [1..10000000000]
00:24:44 <lambdabot>   *Exception: stack overflow
00:24:47 <Sgeo> > foldl (+) 0 [1..10000000000]
00:24:53 <lambdabot>   mueval-core: Time limit exceeded
00:24:59 <Sgeo> > foldr (+) 0 [1..1000000000]
00:25:02 <lambdabot>   *Exception: stack overflow
00:25:06 <Sgeo> > foldl (+) 0 [1..1000000000]
00:25:14 <lambdabot>   mueval: ExitFailure 1
00:25:14 <lambdabot>  mueval: Prelude.undefined
00:25:20 <Sgeo> > foldl' (+) 0 [1..1000000000]
00:25:24 <lambdabot>   mueval-core: Time limit exceeded
00:25:27 <Sgeo> :/
00:25:34 <sanjoyd> You'll kill it. :)
00:25:58 <Sgeo> g06|in, I think foldl will work where foldr would stack overflow
00:26:02 <Sgeo> Not entirely sure
00:26:49 <g06|in> Sgeo: thanks
00:35:02 <Sgeo> yw
00:35:24 <Sgeo> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
00:45:43 <MiZsLaY> testink
00:47:15 <MiZsLaY> halooo
00:47:57 <Sgeo> Hi MiZsLaY
00:54:47 <startling> why doesn't this work as I think it should?
00:54:50 <startling> http://bpaste.net/show/21854/
00:58:20 <Sgeo> kth takes a number as an argument, and you're giving it a function
00:58:40 <Sgeo> startling, ^
00:59:46 <startling> Sgeo: ah! Thanks.
01:00:25 <Sgeo> yw
01:40:35 <naimenn> Noob question, is there any difference between runghc and runhaskell?
01:41:45 <srhb> naimenn: Try to read the contents of runhaskell.
01:43:15 <donri> naimenn: not if you only have ghc
01:43:43 <naimenn> donri: Thank you.
01:55:26 <jdprc10> what do you return for an empty list when you need to return a generic type? ([a] -> a)
01:56:22 <_oz_> @src head
01:56:22 <lambdabot> head (x:_) = x
01:56:22 <lambdabot> head []    = undefined
01:57:28 <Palmik> Hmm, would there be a performance penalty to using "x <- return something" instead of "let x = something"?
01:57:54 <jdprc10> nice. i started haskell yesterday and i'm trying to write all the basic prelude functions myself
01:58:07 <jdprc10> i hadn't seen undefined yet
01:58:22 <_oz_> jdprc10: that's probably a good idea. good luck!
01:58:40 <jdprc10> thanks oz
01:59:17 <nand`> Palmik: I'd imagine so, yes - unless the compiler recognizes and optimizes that situation; reason being that x <- return actually binds something *and* joins the result back together
01:59:48 <ddarius> jdprc10: undefined is just a value that throws an error and is semantically equivalent to looping infinitely.
02:00:42 <shachaf> jdprc10: You pretty much shouldn't ever use undefined.
02:00:50 <nand`> in relation to error, “undefined” is like “error x” where x is set by the compiler
02:00:55 <nand`> depending on the situation
02:00:59 <ddarius> @src undefined
02:00:59 <lambdabot> undefined =  error "Prelude.undefined"
02:01:05 <shachaf> At the very least use (error "something informative") instead of undefined.
02:01:17 <shachaf> In this case head is a partial function, so there's not much more you can do.
02:01:21 <nand`> If you need to work with functions that can fail, look at Maybe T
02:01:23 <nand`> instead of undefined
02:01:47 * ddarius actually prefers to use failed pattern matches as they compiler generates line number information.  This would be one use for an empty case.
02:02:01 <ddarius> > case True of False -> ()
02:02:02 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
02:02:21 <nand`> eg div _ 0 = Nothing; div a b = Just (a/b)         and then something like case (div x y) of Nothing -> "Divide by zero!"; Just n -> show n
02:02:34 <shachaf> ddarius: Similarly, "let Just x = lookup ..." is more informative than "let x = fromJust (lookup ...)".
02:02:37 <jdprc10> wow thanks guys
02:03:13 <ddarius> shachaf: I tend to do the former anyways as it is nicer, though I'd probably use case or a strict let depending.
02:03:15 <jdprc10> this might be the single  helpful, non-snarky  irc chat on freenode
02:03:31 <donri> @hackage safe
02:03:32 <lambdabot> http://hackage.haskell.org/package/safe
02:03:35 <donri> might also be useful
02:03:47 * ddarius considers making a safeword package.
02:03:56 <Palmik> nand`, ok, I will try it out.
02:03:58 <nand`> also http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
02:04:03 <yitz> ddarius: that's a small consolation for when you need to write unsafe functions. better to write total functions to begin with when possible though.
02:04:13 <ddarius> yitz: I agree.
02:07:37 <yitz> shachaf: undefined is useful while you are writing code. you can use undefined for things you haven't implemented yet so that you can use the compiler to help write your code.
02:08:12 <shachaf> yitz: Yes, sometimes.
02:08:14 <shachaf> I thought I said "almost" but it turns out I said "pretty much".
02:08:15 <nand`> yitz: But so is using Maybe + incomplete pattern matching; with the added benefit here being that when you're writing actual error handling code all you need to do is add a pattern for Nothing
02:08:34 <shachaf> nand`: The use case that yitz is talking about has nothing to do with Maybe.
02:08:51 <nand`> oh wait
02:08:52 <nand`> I misread, yeah
02:09:12 <nand`> you mean something like NotImplementedException in other languages?
02:10:03 <yitz> nand`: yeah but at compile time :)
02:10:22 <shachaf> yitz: How is undefined "at compile time"?
02:11:18 <yitz> shachaf: oh well it's not, but the point is not to get the exception, it's just a stub to use the type checker on unfinished code
02:12:04 <yitz> ddarius: safeword?
02:13:18 <donri> for bdsm adventures with the type system
02:38:02 <Sgeo> If I, using unsafePerformIO, make a function that distinguishes between some bottoms, and based on that, return a non-bottom value on (the catchable) bottoms, but return bottom when I have a concrete value, did I make a non-monotonic function?
02:38:20 <Sgeo> What would it even count as since it distinguishes _|_s, which shouldn't be possible
02:42:51 <Blkt> good day everyone
02:44:27 <psacvdf> hi
02:46:49 <Sgeo> :t liftM5
02:46:52 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
02:47:03 <Sgeo> There's liftM5 but no liftA5
02:48:10 <psacvdf> use <$> and <*>
02:48:17 * Sgeo knows
02:48:19 <Sgeo> It's just weird
03:07:29 <nand`> There must be a more elegant way to make an n-tuple containing only types of class Show also a member of class Show; looks like the Prelude definition simply includes a definition for everything up to a 15-tuple
03:08:48 <shachaf> nand`: It's not the sort of thing that matters.
03:09:01 <shachaf> Tuples of different sizes are completely distinct types.
03:09:55 <aristid> nand`: why not just use a list of String if all you can do on those elements is show?
03:10:36 <shachaf> aristid: nand` is (presumably) talking about instance (Show a,Show b) => Show (a,b) etc.
03:10:44 <nand`> shachaf: this
03:11:13 <shachaf> I have no idea what nand` is talking about now, but I don't wish to be a part of it any longer.
03:11:52 <nand`> It just seems like a limitation of the type system to not be able to define “n-tuples” as being some sort of recursive “type constructor constructor”, if you know what I mean. Like being able to define n many tuples, each as a distinct type, at once
03:12:49 <shachaf> There are other definitions of "N-tuples" that have some of the properties you want.
03:12:53 <shachaf> @where hlist
03:12:53 <lambdabot> http://homepages.cwi.nl/~ralf/HList
03:20:44 <Jafet> Tuples are the poor man's multiple return.
03:21:49 <shachaf> Jafet: I thought that was Church-encoded tuples.
03:22:12 <janusz1> Hi, I wanted to use OpenGL/GLUT in Haskell(I am totally new in the language). I cannot find any way to delay a frame display. Could some1 tell me how to do that ?
03:23:24 <ddarius> Tuples are also the rich man's multiple return.
03:23:55 <ion> Tuples are being taxed excessively.
03:24:51 <delinquentme> hey all .. quick question. How did you end up picking up haskell and for what purpose?
03:28:32 <danr> delinquentme: I used xmonad so it inspired me to take a good look on haskell
03:29:00 <jdprc10> delinquentme: i picked it up yesterday becuase i like lambda expressions in python
03:29:44 <psacvdf>  delinquentme: because of a university course
03:30:05 <delinquentme> a university taught haskell?
03:30:28 <psacvdf> yes
03:30:35 <delinquentme> kind of impressive .. i guess is expect java to be the only options at UV
03:30:42 <donri> because I noticed my python code was either trying to be haskell code or the corresponding haskell code would be more elegant/powerful
03:31:16 <ClaudiusMaximus> janusz1: if you mean animation, then i use something like  let timer = addTimerCallback (1000 `div` framesPerSecond) (postRedisplay Nothing >> timer)
03:31:51 <janusz1> ClaudiusMaximus: Thx
03:32:09 <donri> and because i suck at writing tests, which while a good idea in haskell is less critical
03:32:44 <donri> (and for that matter often easier)
03:33:05 <ClaudiusMaximus> delinquentme: i learnt the basics at uni a decade ago, picked it up again some years later for reasons i don't recall exactly
03:33:07 <delinquentme> pythons lambda runs haskell?
03:33:24 <donri> say what now?
03:35:25 <mm_freak> donri: have a look at lazysmallcheck…  it's small and can't do a lot, but what it can it does amazingly
03:35:37 <mm_freak> i mainly use it in GHCi
03:36:47 <mm_freak> smallCheck 100 (\b e n -> e >= 0 && n >= 2 ==> myModExp b e n == mod (b^e) n)
03:37:08 <ourfrank> Let's say I have a simple sorted binary tree. Can I label its elements in one pass? For instance, give the smallest element a value of 1, and the next smallest 2, and so on?
03:37:29 <ourfrank> It is also important to preserve the tree's structure.
03:37:29 <mm_freak> ourfrank: custom data structure?
03:37:46 <ourfrank> mm_freak: Yes. A simple data Tree a = None | Node a (Tree a) (Tree a)
03:37:59 <mm_freak> ourfrank: sure, just traverse it with a recursive function
03:38:20 <mm_freak> numberTree :: Int -> Tree a -> Tree (a, Int)
03:38:25 <mm_freak> where the Int is the starting value
03:38:40 <ion> What’s everyone’s favorite package for SHA-1 hashing?
03:39:15 <ourfrank> mm_freak: The trouble is, how do I know which number to assign to each node, when I am limited to only a single pass through the entire tree?
03:39:40 <mm_freak> ion: cryptohash is what i'm using…  not sure if it's my favorite, because i've really just used what was installed already (probably through yesod or a related package)
03:40:48 <mm_freak> ourfrank: wait, extend the type signature
03:41:05 <mm_freak> ourfrank: numberTree :: Tree a -> Int -> (Tree a, Int)
03:41:48 <ddarius> ourfrank: One thing you can do is traverse the tree labelling the nodes with elements of a list in order and, at the same time, output the elements, then you pass in the output numbered then sorted as the input.
03:43:40 <carpi> is it possible to apply a function while extracting a value from an action that does IO?
03:43:58 <carpi> for example is it possible to do "makeInt number <- getLine"?
03:44:10 <ClaudiusMaximus> :t liftM
03:44:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:45:07 <hpaste_> “Ertugrul Söylemez” pasted “Numbering tree nodes” at http://hpaste.org/56468
03:45:23 <mm_freak> ourfrank: see the paste…  assuming that the left branch is always smaller than the right
03:46:31 <carpi> ClaudiusMaximus: was that answer for me?
03:46:35 <ion> mm_freak: Thanks, looks nice.
03:47:11 <carpi> yup..for me.  Thank you : )
03:47:26 <hpaste_> “Ertugrul Söylemez” annotated “Numbering tree nodes” with “Numbering tree nodes (through state monad)” at http://hpaste.org/56468#a56469
03:47:39 <mm_freak> equivalently through a state monad
03:48:25 <carpi> ClaudiusMaximus: thanks it works : ).
03:48:40 <carpi> but why is it called liftM? i don't see the sense in the naming of the function?
03:49:11 <carpi> it should have been called appFuncInAction or something similar
03:49:36 <mm_freak> carpi: that would be a bad name, because you are thinking in IO
03:50:03 <ddarius> @hoogle modify
03:50:04 <mm_freak> carpi: reading its type signature you see how it "lifts" a function into monad space
03:50:06 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
03:50:06 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
03:50:06 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
03:50:16 <mm_freak> liftM :: Monad m => (a -> b) -> (m a -> m b)
03:51:03 <ddarius> :t modify
03:51:03 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:51:58 <carpi> so in essence liftM allows a pure functions to be usied in monad space
03:52:32 <jdprc10> is there a 'verbose mode' for ghci that will print function calls?
03:53:13 <Veinor> carpi: appFuncInAction would also be a lot more verbose than liftM
03:54:19 <ourfrank> mm_freak: Your function labels the top node as 0, whereas I needed to label the leftmost node 0, but you helped me arrive to the solution. Thanks!
03:54:31 <carpi> Veinor: True. But atleast it is self descriptive. However as mm_freak mentioned, when you think in more generatl terms I think liftM is more appropriate because it really does lift a pure function into monad space
03:54:41 <Veinor> yeah :)
03:54:52 <Veinor> there's other 'lift' functions like liftA and liftIO that are broadly similar
03:54:54 <ddarius> @hoogle comparing
03:54:55 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
03:55:05 <ddarius> @hoogle sortBy
03:55:05 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:55:05 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
03:55:05 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
03:55:41 <carpi> liftIO? in control.monad?
03:56:22 <Veinor> liftIO is the first one that springs to mind, yeah
03:56:29 <mm_freak> carpi: not at all…  as said, you are thinking in IO
03:56:53 <mm_freak> the name appFuncInAction would be extremely IO-minded
03:57:01 <mm_freak> and it would be very confusing for other monads
03:57:12 <Sgeo> What does appFuncInAction mean for Maybe?
03:57:22 <Sgeo> > liftM (+1) (Just 5)
03:57:23 <lambdabot>   Just 6
03:57:28 <Sgeo> > liftM (+1) Nothing
03:57:29 <lambdabot>   Nothing
03:57:40 <shachaf> liftM is very different from liftIO...
03:57:53 <nand`> :t liftIO
03:57:54 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
03:58:04 <Sgeo> Oh, I thought we were talking about liftM
03:58:05 <Veinor> shachaf: they both share the concept of 'lifting'
04:00:19 <nand`> Veinor: there's also “fmap”
04:00:24 <Veinor> well yeah
04:00:31 <Veinor> but
04:00:36 <Veinor> > "lift" `isPrefixOf` "fmap"
04:00:37 <lambdabot>   False
04:00:39 <Sgeo> :t runReaderT
04:00:40 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
04:01:20 <Sgeo> > runReaderT (liftIO $ putStrLn "Well, this isn't actually going to print anything other than <IO ()>") ()
04:01:21 <lambdabot>   No instance for (GHC.Show.Show (m ()))
04:01:21 <lambdabot>    arising from a use of `M802372100...
04:01:23 <nand`> for a type that is both a monad, an applicative and a functor (which technically should include every monad), fmap = liftA = liftM; at least they should be
04:01:31 * Sgeo blinks
04:01:36 <Sgeo> :t runReaderT (liftIO $ putStrLn "Well, this isn't actually going to print anything other than <IO ()>") ()
04:01:37 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
04:02:44 <Sgeo> Writing the functor instance for my own custom monad is just fmap = liftM?
04:03:00 <Sgeo> And Applicative (<*>) = ap
04:03:00 <Sgeo> ?
04:03:08 <sciolizer> lambdabot has the monomorphism restriction turned off?
04:03:10 <Veinor> assuming you satisfy the monad laws, i think so
04:03:13 <nand`> yes, pretty much
04:03:22 <Sgeo> So liftM does have a use!
04:03:41 <Veinor> sometimes i'll write liftM when i'm dealing with the monad as a monad to make it 'clearer'
04:03:48 <ddarius> @hoogle merge
04:03:48 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
04:03:48 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
04:03:48 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
04:03:52 <nand`> technically it should be the other way around, when defining the monad instance for your own custom functor it's just liftM = fmap; monads are specializations of applicatives which are specializations of functors
04:04:55 <nand`> the only reason liftM is there is for the different type class; technically the Monad class should be defined as (Applicative m) => Monad m but in practice it isn't, since applicatives were introduced *after* monads
04:05:09 <nand`> so there are some types which are monads but *not* applicatives
04:05:16 <Sgeo> When were functor introduced relative to monads?
04:05:19 <nand`> (or functors, for that matter)
04:05:51 <nand`> no idea, but I can only assume first; since monads are just functors with a few extra transformations
04:06:06 <nand`> namely join and return
04:06:34 <Veinor> oh that reminds me
04:06:39 <Veinor> what's an example of a functor that isn't a monad
04:06:57 <XexonixXexillion> Veinor: Set
04:07:14 <Veinor> aside from 'isn't a monad because of typeclass constraints'
04:07:25 <mauke> Veinor: (,) e
04:07:55 <Veinor> bind :: (e,a) -> (a -> (e,b)) -> (e,b) is pretty easy to write though
04:08:31 <mauke> but return?
04:08:32 <Sgeo> What would set look like from a monad perspective?
04:08:44 <Veinor> mauke: \x -> (undefined, x)
04:08:53 <mauke> Veinor: that's cheating
04:09:20 <mauke> instance Monad m where return = undefined; (>>=) = undefined  -- so there, etc
04:09:40 <Veinor> haha
04:10:09 <shachaf> I'm pretty sure "is a monad" includes "obeys the monad laws".
04:10:24 <Veinor> oh that's true
04:10:37 <ion> Try to implement join :: Set (Set a) → Set a and check that it complies with the monad laws.
04:11:13 <Veinor> i mean
04:11:26 <hpaste_> ddarius annotated “Numbering tree nodes” with “Numbering tree nodes (annotation)” at http://hpaste.org/56468#a56470
04:11:26 <PatrickRobotham> union>
04:11:30 <PatrickRobotham> Union
04:11:44 <Veinor> in this hypothetical Set that doesn't depend on Ord, the Set monad is just like the list one except, you know, with sets
04:12:42 <Veinor> so join is just union, like PatrickRobotham said
04:12:51 <PatrickRobotham> fold union empty
04:13:09 <PatrickRobotham> if you want to be very technical
04:13:18 <Veinor> right
04:13:23 <ddarius> :t unions
04:13:24 <lambdabot> Not in scope: `unions'
04:13:28 <ddarius> @hoogle unions
04:13:29 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
04:13:29 <lambdabot> Data.IntSet unions :: [IntSet] -> IntSet
04:13:29 <lambdabot> Data.Set unions :: Ord a => [Set a] -> Set a
04:14:00 <Veinor> i don't see why Set wouldn't be a monad if it was somehow magically changed to not depend on typeclasses
04:14:17 <ddarius> It would be to the extent that you can't observe the insides.
04:14:21 <carpi> http://ideone.com/rkhjY <- how is it possible that the code is processing the input all at the same time when it is actually written in such a way that it processes input one at a time?
04:14:32 <Sgeo> It would be nice if typeclasses didn't hinder the Monad instance
04:14:50 <Veinor> ddarius: well sure
04:15:05 <PatrickRobotham> Sgeo: I think that's what kind polymorphism is for.
04:15:24 <Veinor> if you interpret the monad laws as saying 'must be extensionally equal' and not 'must be intensionally equal' then Set is a monad
04:15:26 <PatrickRobotham> Sgeo: research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
04:16:02 <Veinor> (assuming that Data.Set doesn't have any functions that break the abstraction)
04:16:11 <ddarius> Veinor: It does, which is the problem.
04:16:15 <Veinor> ah.
04:16:23 <PatrickRobotham> ddarius: Like toList?
04:16:27 <ddarius> PatrickRobotham: Yes.
04:18:00 <mike-burns> carpi: How do you know it's processing it all at the same time?
04:18:16 <Veinor> i do wish sometimes that Set didn't have the Ord restriction
04:18:23 <Veinor> i needed a set of complex numbers
04:19:00 <PatrickRobotham> Velnor: Could you use Data.Map with keys as complex numbers and values as Bools?
04:19:03 <Veinor> (yes, i know about unordered-containers, but it's not quite the same)
04:19:06 <ddarius> Veinor: Then make an instance of Ord (or better, make a newtype with an instance of Ord)
04:19:37 <carpi> mike-burns: i realize that when given a line terminated list of numbers the code simply reads the lines one by one which is what it is programmed to do. My confusion was because when i tried to run it on the terminal i had to input the numbers one at a time and the numbers were being processed one at a time..
04:20:21 <mike-burns> Could be buffering.
04:20:23 <ddarius> PatrickRobotham: Data.Map and Data.Set are pretty much identical.
04:20:38 <ukl> Hello.  Does somebody use Haskell (GHC+platform) on NetBSD?  I'm a little confused about ghc in pkgsrc and pkgsrc-wip; or do you just use the FreeBSD binary distribution of ghc?
04:20:39 <Veinor> PatrickRobotham: Data.Map also requires an Ord instance on keys
04:20:43 <ddarius> Veinor: You could also "hash" the complex numbers as you enter them into the Set.
04:20:55 <Veinor> i mean, that's what Data.HashSet does
04:21:19 <jdprc10> i don't quite get haskell method definitions. could someone write out in english? (a -> Bool) -> [a] -> Bool
04:21:58 <Veinor> jdprc10: for all types a, if you give me a function of type (a -> Bool), and a list of values of type a, I'll give you a Bool
04:22:15 <jdprc10> oh i see
04:22:21 <mikeplus64> is there a way to index local packages to look up type signatures / functions, like hoogle, except using local packages/whatever instead of online ones?
04:22:29 <jdprc10> Veinor: thanks
04:22:39 <ddarius> mikeplus64: Hoogle.
04:22:45 <nand`> jdprc10: it's a function which takes a function from any type to a bool and returns a function from a list of a's to a bool
04:22:57 <Veinor> you can install hoogle on your local machine, although i seem to recall the process of setting it up is annoying
04:22:58 <nand`> any type a*
04:23:17 <nand`> note that it's the same as (a -> Bool) -> ([a] -> Bool)
04:23:21 <nand`> since -> is right associative
04:24:01 <nand`> how it's actually implemented isn't stated here
04:24:02 <nand`> for exam
04:24:19 <jdprc10> exam?
04:24:31 <nand`> example*, it could mean that “return true if the function given is true for all memebers”, or it could just as equally be “return true if the function is true for only *one* member”
04:24:38 <mikeplus64> ddarius: except that just gets the keywords from an online database, and not locally (eg I have Graphics.UI.SDL, but hoogle doesn't know any of the functions from it)
04:24:42 <nand`> or just as easily mean something like “always return true”, it really isn't stated further
04:24:50 <nand`> it just gives you a hint
04:25:07 <jdprc10> yea sorry i thought you though i was trying to get you to do my homework for me
04:25:13 <Sgeo> @free f :: (a -> Bool) -> [a] -> Bool
04:25:13 <lambdabot> f . (.) g = (.) (f g) . $map
04:25:27 <Sgeo> You know that much, at least
04:25:43 <Sgeo> f is a bad name there
04:25:49 <Sgeo> @free mysteryFunc :: (a -> Bool) -> [a] -> Bool
04:25:49 <lambdabot> mysteryFunc . (.) f = (.) (mysteryFunc f) . $map
04:25:58 <ddarius> mikeplus64: I don't know what you are talking about.  If you install Hoogle locally, you need to make a database for it to index.
04:26:28 <matthew> dist/build/monadius/monadius-tmp/Main.o: In function `s1FTa_info':
04:26:28 <matthew> (.text+0x3886): undefined reference to `glutSwapBuffers'
04:26:29 <donri>   -l --local[=FILEPATH]  Use local documentation if available
04:26:31 <Veinor> i should figure out how to get hoogle to index all of your packages
04:26:33 <matthew> what kind of output is that?
04:26:44 <donri> ^^^ hoogle data
04:27:16 <mikeplus64> ddarius: yeah, if I have the package SDL from hackage install, then "hoogle data", then "hoogle getCaption" or something, hoogle states "No results found"
04:27:49 <mikeplus64> installed*
04:28:42 <Veinor> iirc by default hoogle data only indexes the platform
04:28:54 <mikeplus64> seems so
04:28:58 <Veinor> and the remote versions at that
04:29:13 <donri> hoogle data -l
04:29:37 <mikeplus64> donri: you're my hero
04:29:42 <donri> --help is my hero
04:30:08 <mikeplus64> --help doesn't say -l
04:30:14 <mikeplus64> hoogle --help that is
04:30:14 <donri> hoogle data --help
04:30:19 <mikeplus64> oh, right
04:30:22 <donri> :)
04:30:37 <XexonixXexillion> Is anyone here familiar with the inner workings of Graphics.X11.Xlib?
04:31:00 <donri> alias hgl='hoogle search --color --count 10'  # also useful
04:31:21 <Veinor> you might want hoogle data all -l, actually
04:31:32 <Veinor> so that you can get stuff not in the platform
04:31:33 <mikeplus64> I'm doing hoogle data all now
04:31:57 <mikeplus64> hoogle data all -l is probably a better idea
04:32:03 <donri> i'm doing data -l all for some 300 packages right now xD
04:32:09 <Veinor> same \o/
04:32:20 <Veinor> wish i had an ssd, haha
04:33:24 <donri> hm or is this like all of hackage or something
04:33:30 <Veinor> oh i think
04:33:32 <Veinor> it's all of hackage
04:33:34 <donri> looks like it's indexing stuff i don't even have installed
04:33:37 <Veinor> yeah
04:33:44 <donri> oh dear
04:34:01 <Veinor> oh well!
04:34:08 <donri> i'm at "p"
04:34:23 <mikeplus64> it doesn't seem to be in alphabetical order
04:34:31 <Veinor> race you to the finish!
04:34:39 <donri> it does for me
04:35:35 <mikeplus64> it looked like it was in alphabetical order for a moment then the letter after h was w
04:36:21 <donri> Data generation complete
04:36:45 <Veinor> yep
04:36:46 <donri> Searching for: getCaption
04:36:48 <donri> No results found
04:36:50 <donri> guess not?
04:37:42 <Veinor> yeah it's not finding the SDL package for me
04:37:44 <Veinor> weird
04:37:48 <mikeplus64> bah
04:38:08 <donri> haha hoogling hoogle has an easter egg
04:38:18 <Veinor> haha
04:38:20 <Veinor> that's cute
04:39:34 <carpi> i want to use readFile, but with stdin. Is there a way to read from stdin?
04:39:56 <Veinor> what, like all of it?
04:40:03 <carpi> yea
04:40:11 <ddarius> What do you think readFile reads from?
04:40:25 <carpi> ddarius: from a given filename
04:40:28 <ddarius> getContents
04:40:52 <Veinor> yeah, getContents. note that that's lazy, not strict
04:41:07 <carpi> ah thank you
04:41:13 <donri> hGetContents stdin
04:41:39 <donri> uh, ignore me
04:42:03 <ddarius> Veinor: As is readFile.
04:55:58 <Younos> hi i get the following error: Parse error in pattern: n + 1   .in my line: factorial3 (n+1) = (n+1) * factorial3 n
04:56:07 <Younos> with GHCi
04:56:20 <Younos> why is that?
04:56:49 <Sgeo> Younos, GHCi doesn
04:57:07 <Sgeo> doesn't accept the full range of things that can go in a .hs file
04:57:12 <Sgeo> Try putting a let in front of that
04:57:18 <Sgeo> (Which won't work in a .hs file)
04:57:23 <Sgeo> WAIT
04:57:31 <Younos> i typed it into my .hs file
04:57:37 <Younos> its in a file
04:57:45 <Sgeo> Oh, it's an N+K pattern
04:57:50 <Younos> yes
04:58:00 <ddarius> Haskell 2010 removed n+k patterns.
04:58:04 <Sgeo> I'm not sure whether to tell you how to enable that, or tell you not to use that.
04:58:19 <ddarius> Try adding -XHaskell98
04:58:27 <Younos> ohh okay, well i'll not use n+k patterns then
04:58:30 <cheater_> ddarius: has it? interesting why?
04:58:37 <cheater_> ddarius: has it? interesting. why?
04:58:50 <Younos> how does one define factorial then without n+k patterns?
04:59:09 <Sgeo> -XSomeLanguageExtension is enabled by putting {-# LANGUAGE SomeLanguageExtension #-} at the top, or :set -XSomeLanguageExtension in GHCi
04:59:21 <Sgeo> Two definitions, one for 0 and one for n
04:59:29 <Younos> ok, ty :)
04:59:33 <Sgeo> yw
04:59:50 <Sgeo> If the 0 definition is above the n definition, it will try to match the 0 first.
05:01:33 <Younos> great, it works now
05:02:59 <Sgeo> Yay
05:12:01 <XexonixXexillion> Why were (n+k) patterns in the language to begin with?
05:12:30 <Younos> somebody had a bad day
05:12:30 <srhb> XexonixXexillion: See cons: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
05:15:43 <XexonixXexillion> srhb: so they wanted to have something that could be used like data Natural = Z | S Natural, but without the inherent inefficiency?
05:39:27 <jdprc10> does the pattern [x] match a list with only one element?
05:39:52 <mauke> yes
05:41:04 <Sgeo> It's the same as (x:[])
05:41:41 <jdprc10> thanks
05:48:38 <donri> excuse my stupidity but how do you do negative look-ahead with parsec?
05:49:01 <mauke> notFollowedBy
05:49:09 <donri> isn't that look-behind?
05:49:19 <mauke> no
05:51:10 <rkrzr> Hello haskellers, I have a question about runhaskell: Is there something like a .ghci file for it?
05:51:35 <Veinor> i don't believe so
05:51:37 <rkrzr> Specifically I would like to set this option for runhaskell: :set -hide-package parsec-3.1.1
05:51:51 <rkrzr> because there is some mismatch between different versions of parsec
05:52:20 <Veinor> you can do runhaskell -hide-package parsec-3.1.1 whatever
05:52:37 <rkrzr> ah ok I'll try that, thx
05:52:47 <Veinor> (because runhaskell accepts ghc opt.... aww
05:52:52 <Yrogirg> Is there a way to convert a math formula in TeX or fortran to haskell code?
05:54:14 <hpaste_> Carpi pasted “Somethins wrong” at http://hpaste.org/56472
05:54:36 <M0OML> Hi, a quick question i genrally fail at programmng but just found haskel and for some reason it seems easy, anything i should read or should i just do the examples
05:54:37 <carpi> could someone please tell me what im missing? ^^^
05:54:53 <hpc> @where lyah
05:54:53 <lambdabot> http://www.learnyouahaskell.com/
05:54:58 <hpc> M0OML: ^
05:55:16 <M0OML> Cheers hpc
05:55:30 <hpc> it's the best haskell tutorial for beginners, and im not just saying that because i got the book for free ;)
05:55:54 <Veinor> carpi: printLst expects a list of Integers, but map primeRange cleanedInt has type [[Integer]]
05:56:25 * Sgeo keeps looking at HList, even as other potential solutions are presented
05:56:26 <hpc> :t map f []
05:56:27 <lambdabot> forall b. (SimpleReflect.FromExpr b) => [b]
05:56:29 <M0OML> Cheers i can hack code about but not been able to write code since bbc baic
05:56:46 <hpc> :t map (:[]) []
05:56:47 <lambdabot> forall a. [[a]]
05:56:49 <Veinor> also, i'd recommend passing around the 'from, to' range as a tuple of Integers
05:57:00 <hpc> :t concatMap (:[]) []
05:57:01 <Sgeo> Thing is, the potential solution I saw most recently requires users of the library to know more than the relationship between my bindings and the C API, and the C API. It requires extra documentation than just a translation
05:57:02 <lambdabot> forall b. [b]
05:57:42 <carpi> ah.. thanks.. my bad.. how could i have failed to noitce that : (
05:58:21 <hpaste_> donri pasted “Me not understanding parsing” at http://hpaste.org/56473
05:58:42 <donri> pointers?
05:59:07 <Veinor> 0x800002F4
05:59:27 <sipa> that's only one pointer
05:59:28 <Veinor> 0x2CA11454
05:59:35 <donri> -.-
05:59:45 <rkrzr> Veinor, I think my call must still be slightly off, since I'm getting a 'not in scope: `main'', maybe you can see what's wrong
05:59:47 <Veinor> i've always wanted to use that joke
05:59:51 <rkrzr> here's the call: runhaskell -hide-package parsec-3.1.1 Main.hs -css < benchmarks/church.l
06:00:36 <Veinor> rkrzr: you do have module Main where ... at the top of Main.hs and then a declaration of main somewhere in it, right?
06:00:52 <rkrzr> Veinor, yes
06:01:22 <Veinor> i dunno then :/
06:01:33 <rkrzr> hm ok, thanks anyway
06:01:44 <Veinor> have you tried hiding the package with ghc-pkg and compiling it?
06:01:53 <Veinor> if that works then runhaskell is doing something funny
06:02:07 <rkrzr> i can compile it
06:02:17 <Veinor> ok, that's really weird.
06:02:50 <rkrzr> but let me try hiding with ghc-pkg anyway
06:03:54 <Veinor> yeah try hiding it and then runhsakell Main.hs -css < benchmarks/church.l
06:03:57 <Veinor> (what's the -css for?)
06:05:39 * Sgeo reads the HList paper
06:07:06 <jdprc10> can () not be a return value for an empty tuple?
06:07:30 <Veinor> nope
06:07:30 <sipa> jdprc10: sure?
06:07:32 <Veinor> i mean
06:07:38 <sipa> it's the only value of type ()
06:07:40 <Veinor> () can't have the type (Int, Int)
06:07:48 <Sgeo> Am I allowed to really like HList?
06:08:03 <Sgeo> Something about type Animal =Key :*: Name :*: Breed :*: Price :*: HNil just amazes me
06:08:08 <sipa> Sgeo: yes, but be wary of the consequences
06:08:15 <Sgeo> Consequences?
06:08:20 <jdprc10> nevermind. that's what it was. i had to do ([], [])
06:08:28 <sipa> you may want to start during everything at the type level
06:08:32 <sipa> doing
06:08:34 <rkrzr> Veinor, I don't actually now what the -css stands for, I'm just trying to follow dons post about using the ghci debugger :P
06:08:51 <Sgeo> I think extensible records are the best fit for my problem, so
06:24:27 <BlankVerse> how to generate test cases for quickCheck in Data.Array?
06:27:15 <erus`> is there a linear math library (for opengl type stuff) ?
06:27:19 <erus`> mine is playing up
06:27:24 <alistra> instance it with Arbitrary BlankVerse
06:27:26 <erus`> and its gonna take years to debug
06:27:31 <alistra> maybe derive will do it automatically
06:29:56 <ion> blankverse: http://hackage.haskell.org/packages/archive/quickcheck-instances/0.1.0/doc/html/Test-QuickCheck-Instances.html
06:30:08 <BlankVerse> alistra: how do i write an instance Arbitrary of Array , where array size should be greater than 1 and all the numbers should be distinct?
06:32:22 <ion> For Arbitrary instances with special requirements, use a newtype of Array.
06:33:26 <ola_> From the online help/tutorial at tryhaskell.org/#4As you might've guessed, we got back [13,23,30].
06:33:50 <ola_> From the online help/tutorial at tryhaskell.org/#4:  "try this: sort [42,13,22]" ... "As you might've guessed, we got back [13,23,30]._;"
06:34:32 <ola_> woah, my bad
06:34:52 <hpc> haha
06:35:50 <alistra> BlankVerse: dunno, read the docs, i assume you would first generate the length and then permutate a list of that length and transform into an arrray
06:46:58 <BlankVerse> how do i get x <- Just 3 in IO monad/Ghci
06:47:13 <cheater_> "get"?
06:47:24 <BlankVerse> extract the value out of the monad
06:47:33 <cheater_> case x of
06:50:16 <BlankVerse> k, how abt Gen monad in QuickCheck , if a function has type Gen [a] , such as
06:50:16 <BlankVerse> case (Gen t) of (vector 10) -> t
06:51:17 <BlankVerse> :t vector 10
06:51:18 <lambdabot> forall a. (Arbitrary a) => Gen [a]
06:51:18 <BlankVerse> vector 10 :: Arbitrary a => Gen [a]
06:51:37 <BlankVerse> how do i get [a] out?
06:52:07 <_oz> BlankVerse: what are you planning to do with that?
06:52:39 <BlankVerse> the array that my instance of arbitrary generates is
06:52:40 <BlankVerse> array (0,10) [(0,()),(1,()),(2,()),(3,()),(4,()),(5,()),(6,()),(7,()),(8,()),(9,()),(10,())]
06:52:46 <BlankVerse> which seems empty
06:53:02 <_oz> it isn't empty.
06:53:20 <_oz> it probably defaults to Gen [()]
06:53:46 <_oz> try giving a more specific type to the expression
06:53:55 <_oz> for example: vector 10 :: Gen [Int]
07:05:20 <Sgeo> So, with HList records, I choose a model when making labels for my records?
07:19:30 <matthew> do most package systems install into the system cabal repo?
07:19:40 <mreh> oops
07:22:28 <mreh> i'm just trying it out on ubuntu
07:24:02 <geekosaur> all of them, I think; it's bad juju for a system package manager to affect user stuff
07:34:04 <mreh> trying cabal-dev for the first time too
07:34:19 <mreh> i give up manually installing OpenGL every time i want to use it
07:34:40 <mreh> my OS package it and the others up nicely
07:35:50 <cheater_> is there a nice plotting lib for haskell?
07:36:04 <Sgeo> With HList, is there a nice way to make instances of my own classes of records recursively depending on the labels that I define _without_ breaking it if there are labels that are not mine?
07:36:08 <cheater_> so that i can define some data points and get a reasonably smooth plot out of it?
07:36:19 <Sgeo> I think I see how to do it if it's just an HList involving only my own labels
07:36:49 <Sgeo> Hmm, I guess I could just say "If it's not one of my labels, just pass through"?
07:36:52 <cheater_> in fact, what i want to do is to compare distributions of two data series
07:36:54 <Sgeo> Or is that not so easy
07:37:08 <cheater_> as in display the plots on top of eachother
07:37:37 <aristid> cheater_: use gnuplot?
07:39:19 <cheater_> aristid: have you ever used that from haskell?
07:39:57 <aristid> cheater_: no, not from haskell
07:40:36 <aristid> cheater_: shouldn't be too hard to drive it from haskell, even if there is no lib yet
07:41:08 <aristid> looks like there actually is a package for gnuplot http://hackage.haskell.org/package/gnuplot
07:41:24 <byorgey> cheater_: there is also Chart: http://hackage.haskell.org/package/Chart
07:42:01 <Sgeo> Any HList experts?
07:42:10 <aristid> Sgeo: oleg? :D
07:42:24 <cheater_> byorgey: thanks a lot
07:42:34 <Sgeo> I can't imagine oleg actually coming on IRC
07:42:54 <Sgeo> Then again, I tend to do that with what I consider big names. So seeing conal shocks me a bit
07:43:37 <ddarius> Sgeo: /whois JaffaCake
07:43:48 <byorgey> Sgeo: there are actually quite a lot of "big names" in Haskell who hang out here.
07:44:02 <Sgeo> o.O
07:44:12 <ddarius> byorgey: There are actually quite a lot of "big names" in computing who hang out in the Haskell community.
07:44:18 <byorgey> that too.
07:44:39 <Sgeo> Has anyone actually used HList for a project?
07:44:41 <cheater_> ddarius: like who?
07:44:46 <Sgeo> I think I read that HaskellDB did something similar
07:44:48 <cheater_> Sgeo: i wish i could help but i haven't.
07:44:50 <mreh> why don't they use their real names?
07:44:56 <cheater_> Sgeo: oh, is it DB-related?
07:45:00 <ddarius> mreh: Who?
07:45:08 <mreh> Simon Marlow for one
07:45:15 <cheater_> Sgeo: then you might want to ask in #snapframework as they have been trying out different db layers for size
07:45:15 <Sgeo> cheater_, no, but it makes sense that they'd do something similar to what I want to do
07:45:18 <byorgey> mreh: is mreh your real name?
07:45:26 <mreh> byorgey: they are my initials
07:45:33 <mreh> brent yourgey
07:45:39 <mreh> brent yorgey
07:45:47 <byorgey> mreh: JaffaCake are Simon Marlow's initials.
07:45:51 <byorgey> he has a really long name.
07:45:58 <mreh> smarlow?
07:46:10 <mreh> that's cute
07:46:52 <byorgey> mreh: anyway, there are probably as many reasons for not using one's real name as there are people who don't use their real name.
07:47:29 <mreh> he's not that famous
07:47:44 <mreh> anyway, i don't suppose I really had cause to speak to him anyway
07:47:53 <mreh> why do I care?
07:47:59 * byorgey was wondering that too
07:48:24 <mreh> can I make cabal prompt?
07:48:38 <mreh> *ahem* cabal-install
07:48:40 <cheater_> byorgey: you got me, time to out myself, i am in fact eric s. raymond
07:48:52 <mreh> prompt before installing packages
07:49:19 <byorgey> cheater_: orly?
07:50:23 <mreh> brent yorgey looks like shane killian
07:50:26 <cheater_> byorgey: yes. in fact i am currently typing from linus's bedroom, linus is strangled.
07:50:43 <byorgey> cheater_: I see. That's too bad.
07:50:50 <mike-burns> Is it?
07:51:15 <mreh> lets play people who look like other people in the CS community
07:51:25 <mreh> i'll start, david gries and tony hoare
07:52:36 <salisbury> if I have a bunch of thunks (of the `let x = ...` variety) and, depending on a case statement, some of them may not be needed to evaluate the function
07:52:55 <salisbury> I can assume they won't be evaluated, correct
07:53:18 <mreh> sounds plausable
07:57:40 <monochrom> how can you be both Gries and Hoare at the same time? anyway I'm Dijkstra.
07:58:11 <donri> quantuum entanglement, man
07:58:11 <cheater_> all of you are sockuppets of eachother, i am the only other sentient being
07:58:21 <cheater_> in fact #haskell only has two real users chatting.
07:58:38 <monochrom> the two real users are cheater_ and cheater_
07:58:51 <donri> pair chatting
07:59:39 <monochrom> wait, pair chatting means one person chats and the other person supervises, right?
08:00:21 <donri> in deed
08:03:28 <ddarius> Knowing when to stop APPS is the hardest part.
08:04:40 <Sgeo> An HList record is just an HList of LVPairs, correct?
08:04:53 <Sgeo> So if I ... I think I got this
08:05:20 <Sgeo> Just make instances for the relevant LVPairs, and use hMapM to map whatever over the thing
08:05:49 <Sgeo> Um. I'm vaguely wondering how ugly exposing an HList record to my users is
08:06:00 <Sgeo> I mean, they do look simple enough to use for basic stuff, I think
08:06:09 <Sgeo> Not as pretty as lenses, though
08:06:59 <cheater> have you tried searching #haskell logs for mentions of HList
08:07:06 <cheater> i'm not sure if there are any logs being made
08:07:12 <cheater> but there MIGHT be!
08:08:05 <ddarius> cheater is as observant as a rock.
08:11:51 <cheater> ddarius: is he?
08:13:15 <nand`> Logs: http://bit.ly/5mwtRQ
08:13:55 <Sgeo> shapr, I'm falling into that trap of wanting to do everything in the type level now
08:14:10 <cheater> xchat doesn't show the whole topic unless i request it
08:14:20 <cheater> thanks for pasting that in nand`
08:14:46 <geekosaur> I don't know what version you're using but I can hover over the topic bar to see the whole thing as a tooltip
08:15:13 <monochrom> you can use the left-right cursor keys
08:18:30 <nand`> lambdabot-4.2.3.2 depends on unix-2.5.0.0 which failed to install.
08:18:38 <nand`> hmm
08:18:50 <nand`> I wonder if cabal will mix nicely with SUA
08:19:20 <Sgeo> But... I think... to do what I want... would require the user to provide a type signature at some point, and that sounds like a really really bad idea with lengthy HList records
08:19:48 <Sgeo> If what I want (which would merely be icing on the cake) was even possible, which I'm not sure if it is
08:26:01 <Sgeo> Actually, come to think of it
08:26:05 <Sgeo> What I want would be trivial
08:26:17 <Sgeo> But still force the user to provide a type signature, which is icky
08:29:32 <Sgeo> All I'd have to do on my end to enable it is not provide a type signature
08:43:37 <Sgeo> WHY
08:43:48 <Sgeo> Whenever my mouse hovers over a GHC manual page, is there a tooltip?
08:43:51 <Sgeo> It's annoying
08:44:34 <donri> it's a docbook thing
08:44:40 <hpaste_> Carpi annotated “Somethins wrong” with “Somethins wrong (annotation)” at http://hpaste.org/56472#a56477
08:44:43 <carpi> when i run this code it produces no output. .. is it because the main function is not executed? ^^^
08:44:44 <donri> and insanely annoying in deed
08:45:15 <carpi> the problem is with the second annotation
08:45:55 <XexonixXexillion> carpi: why should it produce output?
08:46:52 <XexonixXexillion> carpi: unless I'm mistaken you return [IO ()]
08:47:20 <hpaste_> XexonixXexillion annotated “Somethins wrong” with “Somethins wrong (annotation) (annotation)” at http://hpaste.org/56472#a56478
08:48:15 <carpi> XexonixXexillion: but does main get executed in the version i gave?
08:48:28 <b31> reading Hutton's book I wonder about foldr's type spec
08:48:32 <b31> Isn't (a -> b -> b) -> b -> [a] -> b the same as (b -> b -> b) -> b -> [b] -> b for foldr
08:48:37 <carpi> ah okay..it seems like it does..but since it returns [IO ()]..it never gets printed
08:48:39 <cheater_> hi
08:48:39 <Sgeo> What languages have good records?
08:49:04 <XexonixXexillion> Sgeo: what do you mean by good records?
08:49:10 <cheater_> Sgeo: sometimes having to require type signatures isn't so bad
08:49:24 <mike-burns> I didn't hear people complain about PLT Scheme's records.
08:49:29 <cheater_> Sgeo: remember that program i was writing earlier on that you helped me figure out a type ambiguity?
08:49:38 <cheater_> where i had to define the type of a specific list
08:49:46 <Sgeo> cheater, when the type signature would be incredibly lengthy, I think it is
08:49:47 <cheater_> it was the only thing where i had to do that
08:49:51 <XexonixXexillion> carpi: main is *always* executed
08:49:52 <cheater_> hmm yes
08:49:57 <cheater_> that might be true
08:51:42 <carpi> XexonixXexillion: but why did the output not get printed in the version I gave?
08:51:51 <Sgeo> There's no way to get (HasField MyLabel1 r Int, HasField MyLabel2 r Char) => r to default to something, is there?
08:52:24 <XexonixXexillion> carpi: because you've made a list of IO (); but you've never actually run them
08:52:47 <carpi> XexonixXexillion: you mean it never gets evaluated?
08:53:07 <carpi> no.. i mean.. it never get executed since IO is involved
08:55:13 <mike-burns> carpi: What was the type of `main' in your version? IO ([IO String]) ?
08:55:38 <mike-burns> IO (IO ()) I guess?
08:55:38 <carpi> mike-burns: IO ()
08:55:49 <parcs`> Sgeo: what do the MyLabels mean there?
08:56:02 <XexonixXexillion> carpi: I believe you'll find it was IO [IO ()]
08:56:16 <yitz> Sgeo: cobol
08:56:33 <carpi> IO [IO ()]
08:57:20 <carpi> what i don't understand is.. when we do something like map (^2) [1..10] it gets evaluated right away but when i do "map printLst $ map primeRange cleanedinp" as ive done in the version i gave.. it doens't get evaluated
08:57:45 <b31> Sgeo: one of Wirth's languages (pascal, oberon). they even has a non-null-terminated String definition
08:57:53 <mike-burns> > map undefined []
08:57:54 <lambdabot>   []
08:57:58 <mike-burns> Right away, eh?
08:58:25 <XexonixXexillion> carpi: you return a list of functions; but you don't run them
08:58:28 <copumpkin> > length $ map undefined [1..5]
08:58:28 <Sgeo> parcs`, they are, I think the data types of labels used in the HList record
08:58:28 <lambdabot>   5
08:58:32 <KorriX> is there any metod to "hot swap" haskell modules in working application (like in erlang) ?
08:58:49 <mike-burns> carpi: You're using the word "evaluated" in two different ways.
08:58:54 <Sgeo> XexonixXexillion, IO a is not a function
08:59:20 <yitz> KorriX: it has been discussed at some length, don't remember where the discussion was. maybe google.
08:59:26 <donri> KorriX: the web frameworks have code for reloading code on the fly
08:59:36 <carpi> mike-burns: you mean im confusing evaluation with execution?
08:59:39 <yitz> KorriX: but it certaintly isn't going to be as easy as in erlang
08:59:45 <mike-burns> carpi: Yeah!
09:00:19 <carpi> so in my version the expression is evaluated but not executed? or is it the other way around?
09:00:21 <XexonixXexillion> Sgeo: Everything is a function
09:00:26 <mike-burns> Hah.
09:00:28 <Sgeo> XexonixXexillion, not true.
09:00:35 <mike-burns> carpi: It's evaluated but not executed, yes.
09:00:53 <tgeeky> > let everything = error "I'm a big boy function now!"; everything
09:00:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:01:02 <mike-burns> carpi: You end up with a list of IO () but these are IOs, not the execution of the IO.
09:01:08 <Sgeo> How is 1 a function anymore than it's a list?
09:01:13 <Sgeo> http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:01:18 <Sgeo> ^^ XexonixXexillion
09:01:31 <carpi> so in my version how would i have forced the "execution"?
09:01:32 <yitz> carpi: it's probably not evaluated either. generally the haskell runtime doesn't evaluate anything that it doesn't need.
09:02:02 <mike-burns> carpi: Probably with a forM_ .
09:02:07 <mike-burns> :t forM_
09:02:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
09:02:32 <cmccann> Sgeo, 1 is a function, its argument is a Num instance dictionary and it returns a value of that instance ;]
09:02:52 <cmccann> :t 1
09:02:53 <lambdabot> forall t. (Num t) => t
09:03:09 <carpi> yitz: so you're saying in my version, there was no requirement for thaat last statement to be evaluated..?
09:03:16 <XexonixXexillion> Sgeo: this is an argument I probably want to avoid
09:03:35 <Sgeo> carpi, the evaluation is irrelevent in this case, the issue is execution
09:03:53 <mike-burns> carpi: Though, looking at types alone, you could probably have used msum or join, too.
09:04:06 <Sgeo> :t msum
09:04:07 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:04:11 <carpi> msum? join? in which module are they?
09:04:21 <mike-burns> @hoogle msum
09:04:21 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
09:04:21 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:04:27 <mike-burns> @hoogle join
09:04:27 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:04:27 <lambdabot> package join
09:04:27 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
09:04:42 <mike-burns> The Control.Monad ones are what I was thinking of.
09:06:16 <XexonixXexillion> Sgeo: I'll agree perhaps function is not the correct word; but syntactically something of type (a -> b) is the same as something of type a
09:08:54 <KorriX> Also, with Haskell IDE (except vim and emacs) you recommend ?
09:09:40 <cheater_> Sgeo: why does that type signature have to be so big?
09:09:42 <ddarius> cmccann: If you were going to be a smartass at least you could have done:
09:09:44 <ddarius> > 1 True
09:09:45 <lambdabot>   1
09:09:53 <cheater_> Sgeo: maybe you can somehow minimize it.
09:10:12 <cmccann> ddarius, haha
09:10:52 <ddarius> XexonixXexillion: The correct word would be "value."
09:16:18 <XexonixXexillion> ddarius: Value seems like a decent word... but a value of (a -> b) just doesn't feel right
09:17:49 <Sgeo> Are there any nice lenses for HList?
09:17:50 <mike-burns> XexonixXexillion: That's what makes a first-class function first-class.
09:17:56 <parcs`> KorriX: check out EclipseFP
09:18:24 <KorriX> is there something better ?
09:18:27 <parcs`> Sgeo: stop using HList :P
09:18:34 <mike-burns> KorriX: Vim and Emacs are better.
09:18:37 <Sgeo> parcs`, what should I use instead?
09:18:45 <copumpkin> Sgeo: you could easily make some, but I don't think there are any standard ones
09:18:51 <KorriX> i hate lisp - so i use vim :D
09:19:10 <mike-burns> Well, you've peaked in terms of Haskell IDE then.
09:19:13 <drdo> What is this blasphemy?
09:19:59 * cmccann uses SciTE and a couple terminal windows, IDEs are overrated
09:20:50 <mike-burns> I'd be very frustrated without my IDE.
09:21:15 <XexonixXexillion> mike-burns: I think I'll just blame the fact that I'm doing too much with the SK calculus at present
09:21:26 <nand`> I use ghci as my “IDE”
09:21:31 <nand`> it has everything I need
09:21:41 <Sgeo> EclipseFP looks cool except for the Eclipse part
09:21:44 <nand`> tab completion, :info and :t
09:21:53 <mike-burns> nand`: And insert mode!
09:22:02 <nand`> mike-burns: insert mode?
09:22:09 <mike-burns> nand`: You can type stuff.
09:22:25 <nand`> I think that's a default assumption
09:22:40 <mike-burns> Oh. ... clearly I've used vi for too long.
09:22:58 <cmccann> haha
09:23:08 <mike-burns> (I consider tab completion a given, too.)
09:23:39 <nand`> I hate developing in any language other than C# because it makes me miss IntelliSense every time
09:24:06 <nand`> alt tabbing to documentation so I can ctrl+f every 10 seconds is a pain
09:24:40 <mike-burns> haskell.vim had some Haddock integration, though I never set it up.
09:26:03 <Sgeo> hLens label = lens (\r -> r .!. label) (\newval r -> label .=. newval .@. r)
09:26:05 <Sgeo> I think
09:26:44 <Sgeo> I do not want to figure out the type signature for that
09:27:00 <Sgeo> Not sure if it even types
09:27:34 <dons> btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
09:27:46 <mike-burns> nand`: http://goo.gl/nvxzs - does this suffice?
09:30:02 <copumpkin> wow
09:33:45 <nand`> mike-burns: looks nice
09:36:09 <cl1> mike-burns, does that only list functions that are in scope?
09:36:11 <nand`> mike-burns: this is what I'm used to: http://img708.imageshack.us/img708/9717/intellisense.png
09:36:37 <cl1> nand`, me too!
09:36:46 <mike-burns> http://goo.gl/kXjY4 - that was from 2007. Not sure what's changed since.
09:36:55 <nand`> detailed descriptions on what the function does as well as a short summary of each parameter
09:37:03 <nand`> *and* the type signature
09:38:04 <nand`> IntelliSense aside, the nicest editor I've had the pleasure of using is Sublime Text 2
09:38:06 <ddarius> For both Haskell and C#, that only happens if someone has typed in those descriptions and summaries.
09:38:11 <cmccann> dons, woo, new high score
09:38:33 <ddarius> Luckily, the .NET Framework is fairly well documented.  Unluckily, outside of the .NET Framework things go downhill fast.
09:38:40 <nand`> ddarius: true, that's a blessing on microsoft's part
09:38:48 <nand`> but .NET is most of what I use, since it's so vast
09:39:20 <mike-burns> Documentation sounds amazing. I'd love to try it someday.
09:39:33 <nand`> I've been meaning to try F#
09:39:36 <nand`> feels.. wrong though
09:39:51 <nand`> does anybody know if it's as functional as haskell, if at all?
09:40:10 <cmccann> F# felt kind of clumsy to me
09:40:14 <ddarius> It's basically a bastardized O'Caml.
09:40:19 <cl1> nand`, it does not have type classes (classes in haskell)
09:40:25 <cmccann> compared to Haskell it's like going from modern C# to C# 1.0
09:40:30 <mike-burns> I just taught a little bit of Haskell to a group of F# devs. They picked it up very quickly, so there's that.
09:40:35 <cmccann> or whatever the original version number was
09:40:37 <nand`> ouch
09:40:43 <nand`> C# 1.0 is worse than Java
09:40:51 <arash> Hello, I'm thinking of creating a useful hackage package. I'm here seeking for some inital feedback. Would anyone mind spending some minutes reviewing this?  See https://gist.github.com/1616678
09:41:49 * ddarius might release a package.
09:42:31 <jdavis> I am trying to convert a String to a ByteString in ghc 7. It looks like the interface has changed a few times... I see reference to "Data.ByteString.fromString" and "Data.ByteString.pack" but the former does not exist for me and the latter wants a list of Word8 not Char. What is the appropriate library and function to use?
09:42:51 <mike-burns> arash: Haven't heard of that already, and certainly not recently. Honestly, I don't understand the module hierarchy.
09:43:03 <nand`> I kind of want to write a colorimetry library
09:43:23 <ddarius> jdavis: ByteString is a sequence of bytes.  String is a sequence of Unicode code points.  How do you want to encode those code points into bytes?
09:43:37 <jdavis> UTF8
09:44:04 <ddarius> Also, why do you want to have a String as a ByteString anyway?
09:44:37 <arash> mike-burns,  you don't understand what **I** mean by module hierarchy, or do you mean the current module hierarchy we have is lacking conventions?
09:44:45 <jdavis> ddarius, a library I am trying to use (actually, I'm trying to patch it) accepts ByteStrings to pass to the underlying C code. I just want to test it in ghci easily.
09:45:30 <ddarius> jdavis: If you just want to be able to type string literals and have the be ByteStrings, then enable the OverloadedStrings extension.
09:45:39 <jdavis> Oh, ok.
09:45:42 <ddarius> This is what fromString is referring to.  It is a method of the IsString class.
09:45:52 <nand`> :t Data.ByteString.Char8.pack
09:45:53 <lambdabot> String -> BSC.ByteString
09:46:02 <mike-burns> arash: The current module hierarchy. There are conventions but so many things stray from them, and moreover I don't see how they're useful, that I simply can't tell where someplace should go.
09:46:36 <nand`> mike-burns: some things confuse me, eg. why are the instances for Control.Applicative actually in Control.Monad.Instances
09:46:37 <ddarius> jdavis: Note that it will probably do the wrong thing if you actually have some non-latin-1 code points.
09:46:54 <arash> ok then, I'll start cabal initing then, thanks for your feedback :)
09:47:20 <jdavis> ddarius, yes, of course.
09:48:26 <nand`> I mentioned Data.ByteString.Char8 earlier but note that it does not implement UTF8, it simply truncates all characters to 8 bits
09:48:49 <nand`> Unicode code points 0-255
09:49:42 <jdavis> nand`: yes. I'm using it just to test out my changes in ghci, which have nothing to do with encoding, so it should be OK. I will consider whether the library should use Strings instead of ByteString after I finish with this.
09:51:24 <jdavis> No actual code will be committed that ignores encoding issues; only my ghci history ;)
09:53:24 <lispy> jdavis: or data.text.  A similar representation as BS but unicode support like String
09:54:25 <jdavis> lispy: OK, thank you.
10:06:28 <Duffman> hey guys, I have a data type defined as: data T a b = T (a b)
10:06:42 <Duffman> if I ask GHCI what kind it is
10:06:53 <Duffman> it says (* -> *) -> * -> *
10:06:57 <Duffman> and I don't really understand the result
10:07:04 <Duffman> I'd expect it to be of * -> * -> *
10:07:13 <nand`> Duffman: then you want T a b not T (a b)
10:07:17 <nand`> (a b) means b applied to a
10:07:23 <nand`> where a is a type constructor of kind * -> *
10:07:56 <Cale> Well, a applied to b rather ;)
10:08:13 <nand`> a is the constructor, b is the parameter - in my book, that's “b applied to a”
10:08:23 <nand`> or “a applied with b”
10:08:35 <nand`> then again, my wording is probably off
10:08:42 <Cale> Usually around here we apply functions to their arguments
10:10:34 <nand`> come to think of it, my wording was definitely off
10:12:59 <Duffman> nand`: I got this data type from a book but I'm not quite following. a is a type constructor in this example?
10:13:10 <nand`> yes
10:13:19 <nand`> for a concrete example
10:13:27 <nand`> your T could be something like T Maybe Int
10:13:28 <Duffman> a could be Maybe for example
10:13:34 <Duffman> yes
10:13:34 <nand`> with the data being T (Maybe Int)
10:13:46 <nand`> possible values would be T Nothing or T (Just 5)
10:14:04 <Duffman> I see I  see
10:14:06 <Duffman> interesting :)
10:14:08 <mokus> you could think of T as being like ($) at the type level
10:14:12 <Duffman> thanks nand`!
10:14:40 <Duffman> it all makes sense now.
10:45:10 <ddarius> @hoogle minimumBy
10:45:10 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
10:45:10 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
10:46:27 <ddarius> @hoogle (<$>)
10:46:27 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
10:46:27 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:56:02 <lispy> :t (return =<<)
10:56:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
10:56:38 <lispy> If I have return =<< foo bar, is there a pattern for that already other than, x <- foo bar; return x  ?
10:57:14 <copumpkin> it's id
10:57:15 <geekosaur> it should be just foo bar
10:57:22 <lispy> duh
10:57:23 <lispy> Yes
10:57:45 <lispy> I got hung up on thinking that return did something in this case :)
11:02:30 <cmccann> lispy, something is the opposite of what return should be doing in any case
11:04:46 * lispy nods
11:06:29 * ddarius makes a module exporting psps, ppps, ssps, pps, and apps.
11:11:50 <Ak_> How to get list of packets when using type CallbackBS function from Network-Pcap package?
11:13:39 <Ak_> I meant http://hackage.haskell.org/packages/archive/pcap/0.4.5/doc/html/Network-Pcap.html#t:CallbackBS
11:17:50 <Ray25> hi
11:17:56 <Ray25> For those of you who ever looked down on me
11:18:01 <Ray25> For those of you who ever made fun of me
11:18:18 <Ray25> Well, I have finally made it. I'm finally a millionaire.
11:19:39 <geekosaur> @where ops
11:19:40 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
11:20:00 <copumpkin> Ray25: this channel is about haskell
11:20:10 <copumpkin> do you have a haskell question or a discussion you'd like to have about haskell?
11:23:26 <Ray25> thanks to haskell, i spent 1 year and built my palace coding with haskell. I have plenty of question
11:23:48 <copumpkin> Ray25: you sound like you're trolling
11:23:48 <LMolr> hm
11:23:54 <Ray25> google bought me out for 80 million
11:24:15 <copumpkin> Ray25: I'm happy for you, but that isn't relevant to this channel
11:24:21 <Ray25> it's relevant when I want to hire you
11:24:49 <copumpkin> most job ads are typically posted to #haskell-cafe or to less ephemeral media
11:24:55 <copumpkin> ugh, I mean the haskell-cafe mailing list
11:25:09 <Ray25> my offer is quite lucrative
11:25:17 <byorgey> #haskell-cafe is a good place for Ray25 to make job offers
11:27:06 <copumpkin> Ray25: in that case, post in here about what it would involve and people might contact you if they're interested, but be aware that IRC isn't really a good place to look for people
11:27:16 <copumpkin> I still think a mailing list would be a lot better
11:29:57 <Enigmagic> copumpkin: he looks like a serial troller http://irclog.perlgeek.de/perl6/2011-04-21
11:30:07 <copumpkin> I figured
11:30:16 * ddarius doesn't understand copumpkin.
11:30:23 <copumpkin> I'll quiet him if he keeps making noise
11:36:16 * ddarius doesn't understand why his concurrent function minimizer seems to be converging prematurely.
11:36:34 <copumpkin> ddarius: which of the two is harder to understand? :)
11:37:14 <ddarius> copumpkin: You.
11:37:24 <copumpkin> fair enough
11:37:52 <Ray25> There is no incriminating evidence in that log that proves your allegations that I troll here. If you read, actually read it, you'll notice I was building a business. Anyways, carry on.
11:38:21 <nus> Ray25, who are you, exactly?
11:38:54 <MostAwesomeDude> Ray25: 1% of trolls have 99% of the troll money. Occupy Ray25!
11:43:32 <Enigmagic> Ray25: well you already lied, i'm inclined to believe the logs.
11:44:10 <dmpeters> hi im a haskell noob and im trying to get up and running - when I run cabal configure I get: Error: No 'Main-Is' field found for executable
11:44:32 <dmpeters> any ideas or help?
11:45:05 <byorgey> dmpeters: when you run cabal configure for what? you are trying to create your own cabal package?
11:46:22 <dmpeters> byorgey: im trying to follow this https://github.com/mtnviewmark/barley
11:48:50 <byorgey> dmpeters: hmm, let me take a look
11:49:30 <byorgey> dmpeters: hmm, I don't get that error. What version of GHC do you have, and what version of cabal?
11:49:44 <byorgey> dmpeters: did you edit the barley.cabal file at all?
11:50:48 <dmpeters> byorgey: cabal-install version 0.10.2
11:50:56 <dmpeters> byorgey: not sure what GHC is?
11:51:37 <djahandarie> Has anyone used ICMP packets with Haskell before? Would like toset up some simple PING and tracert stuff here
11:51:41 <byorgey> dmpeters: GHC is a Haskell compiler
11:52:14 <byorgey> dmpeters: you will certainly need a Haskell compiler to be able to run barley.
11:52:48 <Sgeo> Hmm
11:52:53 <byorgey> dmpeters: if you don't have one, you should first install  www.haskell.org/platform
11:52:56 <Sgeo> I know Haskell somewhat well, but not much about Snap
11:53:08 <irene-knapp> :t on
11:53:09 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:53:09 <dmpeters> byorgey: haskell-platform 2011.4.0.0
11:53:23 <byorgey> dmpeters: ah, you've already installed that? OK.
11:53:27 <irene-knapp> :t on (==)
11:53:28 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
11:53:34 <irene-knapp> :t on (==) foo
11:53:35 <lambdabot> Not in scope: `foo'
11:53:38 <byorgey> dmpeters: well, then what is the output of  ghc --version  ?
11:53:55 <dmpeters> byorgey: The Glorious Glasgow Haskell Compilation System, version 7.0.4
11:54:38 <byorgey> dmpeters: ok. strange.  And do you see a  Main-is:  field in  barley.cabal ?  (I do)
11:54:40 <Sgeo> "Frist thing to know is that these are comments. "
11:54:49 <Sgeo> Frist thing to know should be how to spell first =P
11:55:00 <irene-knapp> @wn frist
11:55:00 <lambdabot> No match for "frist".
11:55:03 <irene-knapp> aw
11:55:08 <irene-knapp> that would have been amusing (to me)
11:58:08 <dmpeters> byorgey: okay I got past it - thanks for your help
11:59:06 <irene-knapp> heh, we bored a troll into leaving :)
12:00:50 <copumpkin> lol
12:11:45 <kqr> how would you recommend one going about random number generation? there seems to be so many approaches. before i just made a list of infinite numbers and passed that around, but it seems somewhat like cheating to me
12:12:31 <ddarius> kqr: Why?
12:12:58 <kqr> if something malfunctions due to the random number list, i don't find it as easy to check what the specific arguments was
12:13:15 <kqr> because it's a number some arbitrary length into the random list
12:13:35 <Apocalisp> @message edwardk How come comonad.com has been down for so long?
12:13:35 <lambdabot> Maybe you meant: messages messages?
12:13:46 <Apocalisp> @tell edwardk How come comonad.com has been down for so long?
12:13:46 <lambdabot> Consider it noted.
12:13:47 <ddarius> How is that any different from using an action that produces random numbers?
12:16:01 <kqr> ddarius, you tell me, it's just a hunch of mine that it's easier to track the state in the form of a random number generator rather than an infinite list
12:17:21 <ddarius> kqr: That statement makes no sense.  I should tell you why something I don't believe is true?
12:19:00 <kqr> ddarius, no, i might've misplaced some punctuation there
12:19:22 <kqr> ddarius, the point is that a random number generator seems to me easier to track than an infinite list
12:19:28 <kqr> ddarius, however, you don't seem to think that is true
12:19:32 <kqr> ddarius, is that correct?
12:20:51 <ddarius> kqr: I can't make claims about how things seem or do not seem to you, hence me asking why you think there would be a difference between one way or another.
12:21:02 <kqr> ddarius, ah
12:21:59 <kqr> ddarius, i can't explain it really, as is usual with hunches
12:22:00 <parcs`> kqr: the 'random' function from System.Random has the type 'g -> (a ,g)' which is perfect for abstracting away in a State monad
12:22:10 <ddarius> kqr: Really, it just sounds like you are imagining problems that you don't have.  I would recommend worrying about it if it ever actually causes you a problem or if you can actually articulate a reason why you think it would be a problem.
12:22:15 <kqr> ddarius, so i have to trust you on this one
12:22:17 <parcs`> so, i suggest using the State monad to generate random numbers
12:22:24 <kqr> ddarius, alright, thanks
12:22:30 <kqr> parcs`, i haven't really understood the state monad
12:23:57 <Sgeo> :t state
12:23:58 <lambdabot> forall s a. (s -> (a, s)) -> State s a
12:24:04 <Sgeo> :t runST
12:24:05 <lambdabot> forall a. (forall s. ST s a) -> a
12:24:17 <Sgeo> :t newSTRef
12:24:18 <lambdabot> forall a s. a -> ST s (STRef s a)
12:24:26 <parcs`> :t random
12:24:27 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
12:24:47 <ClaudiusMaximus> @hoogle getRandomR
12:24:48 <lambdabot> No results found
12:24:48 <kqr> Sgeo, unless it's for your own reference, i'm not that experienced that i can read type signatures and understand the monads/functions yet
12:25:01 <Sgeo> kqr, mostly my own reference
12:25:05 <parcs`> kqr: can you write a function that takes a seed and gives me two random numbers using that function?
12:25:08 <kqr> right, never mind me then
12:26:16 <kqr> parcs`, i'm not sure actually
12:26:31 <kqr> parcs`, i've never really used the random generators in haskell
12:26:44 <parcs`> okay
12:27:26 <parcs`> how are you generating random numbers now?
12:28:14 <sipa> 4
12:28:53 <kqr> sipa, guaranteed etc
12:29:01 <kqr> parcs`, i'm not, i did once before with randoms
12:29:11 <kqr> parcs`, but i have no recollection of how i did it
12:29:24 <parcs`> :t random :: StdGen -> (Int, StdGen)
12:29:25 <lambdabot> StdGen -> (Int, StdGen)
12:29:29 <kqr> (yes, i'm new to haskell)
12:29:44 <parcs`> does this help? the random function takes a seed and returns a random int and the new seed
12:30:05 <parcs`> can you write a function "StdGen -> (Int, Int, Stdgen)" using that?
12:31:28 <kqr> parcs`, does it require binding? (just want to know if i'm even on the right track)
12:32:15 <kqr> or, is it a monad, even?
12:32:22 <kqr> (damn i'm inexperienced with this)
12:32:26 <parcs`> yeah, you'll have to bind the intermediate seed to pass it to the subsequent call of random
12:33:20 <kqr> parcs`, bind as in >>= or bind as in let?
12:33:32 <parcs`> let
12:34:58 <kqr> parcs`, yeah, i think i made it
12:35:40 <parcs`> can you write it?
12:35:50 <parcs`> here, i mean
12:36:02 <kqr> parcs`, http://pastebin.com/PP4S16cm
12:36:04 <mauke> The paste PP4S16cm has been copied to http://hpaste.org/56481
12:36:34 <parcs`> looks good
12:37:15 <parcs`> it is quite tedious to pass the seed around, which is what the State monad aims to solve
12:37:23 <kqr> okay
12:37:53 <parcs`> with the state monad it could be written as: do { a <- random; b <- random; return (a, b) }
12:39:00 <kqr> which seems cool, but i have no idea how it works, so i can't really use it
12:39:56 <parcs`> can you define the function "(s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)"?
12:40:35 * ddarius considers rewriting his code in Promela just to see how that goes.
12:41:07 <kqr> parcs`, i'd venture for a no
12:41:14 <kqr> parcs`, i'm confused by the second 'a' there
12:45:17 <parcs`> does shifting the arguments help? "s -> (s -> (a, s)) -> (a -> s -> (b, s)) -> (b, s)"
12:46:03 <kqr> parcs`, or, i'll have to correct myself
12:46:33 <kqr> parcs`, i could write the function you ask for, in much the same was as the last one, but i can't seem to interpret the arguments to it
12:46:42 <kqr> parcs`, but that's perhaps not what you asked for?
12:47:15 <parcs`> well this function captures the very general idea of 'threading the state around'
12:47:56 <kqr> i would understand it if it was of the form (s -> (a, s)) -> (s -> (b, s)) ->s -> (b, s)
12:48:08 <kqr> because then it makes sense that only the state is passed over to the next call
12:48:13 <kqr> but i don't get what the a does there
12:48:22 <kqr> especially not as it doesn't end up in the final result
12:49:26 <parcs`> well what good is generating a value when you can't use it?
12:49:58 * BMeph thinks kqr could use a hint from another type, like: "[a] -> (a -> [b]) -> [b]"...
12:51:19 <kqr> parcs`, yeah, but what kind of function is (a -> s -> (b, s)) when it looks almost exactly the same as (s -> (a, s)) but with an extra a?
12:54:04 <parcs`> it's what allows values to be bound
12:55:17 <parcs`> the 'a' from the second parameter '(s -> (a, s))' is passed to the next function '(a -> s -> (b, s))' so that a 'b' can be generated based on not only the new state but also on the previous value generated by the previous state
12:57:26 <parcs`> this is more powerful than your type '(s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))' because the 'a' can be propagated indefinitely and is not lost
12:58:01 <kqr> ahaaa
12:58:02 <parcs`> i hope i am making sense :P
12:58:04 <kqr> now that makes sense
12:58:05 <kqr> yeah
12:58:10 <eikke> would anyone know a map/hashtable implemented in STM?
12:59:18 <parcs`> kqr: great :) now try to define the function with my given type
13:00:43 <kqr> i'll try
13:00:48 <parcs`> again that is "s -> (s -> (a, s)) -> (a -> s -> (b, s)) -> (b, s)"
13:03:10 * Sgeo blinks until realizing why that looks weird
13:04:31 <JoeyA> A non-Haskeller could see immediately why it looks weird.
13:04:38 <kqr> parcs`, http://pastebin.com/yNZRMXwC
13:04:39 <mauke> The paste yNZRMXwC has been copied to http://hpaste.org/56482
13:04:40 <kqr> parcs`, like that?
13:04:56 <parcs`> yes!
13:05:25 <parcs`> you have mostly defined the State monad
13:05:37 <JoeyA> eikke: I spotted http://hackage.haskell.org/package/tskiplist (LGPL)
13:05:39 <kqr> and i'm still not sure i get it
13:06:25 <eikke> JoeyA: aha! using wrong google keywords I guess
13:06:31 <lukish> How can I add leading zeros to showing some Integer? f 8 1234 == "00001234", for example
13:06:32 <parcs`> @let stateThreading f1 f2 initialState = let (a, next_state) = f1 initial_state; (b, final_state) = f2 a next_state in (b, final_state)
13:06:32 <lambdabot>  <local>:4:61: Not in scope: `initial_state'
13:06:38 <JoeyA> eikke: Why not use one of the purely functional map implementations?
13:06:41 <parcs`> @let stateThreading f1 f2 initial_state = let (a, next_state) = f1 initial_state; (b, final_state) = f2 a next_state in (b, final_state)
13:06:42 <lambdabot>  Defined.
13:06:46 <parcs`> :t stateThreading
13:06:47 <lambdabot> forall t t1 t2 t3 t4. (t -> (t1, t2)) -> (t1 -> t2 -> (t3, t4)) -> t -> (t3, t4)
13:06:52 <parcs`> ouch
13:06:57 <JoeyA> I once implemented AVL using IORefs.  It turned out slower than Data.Map, IIRC.
13:06:59 <parcs`> @undefine
13:07:09 <parcs`> @let stateThreading :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s); stateThreading f1 f2 initial_state = let (a, next_state) = f1 initial_state; (b, final_state) = f2 a next_state in (b, final_state)
13:07:09 <JoeyA> (though Data.Map uses a size-balanced tree rather than height-balanced)
13:07:10 <lambdabot>  Defined.
13:07:19 <parcs`> :t stateThreading
13:07:20 <lambdabot> forall s a b. (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
13:07:27 <eikke> JoeyA: testing something, a multi-threaded key-value server backed by an in-memory map
13:07:32 * JoeyA wonders if stateThreading is a zygohistomorphic prepomorphism.
13:07:53 <parcs`> kqr: okay, to see how this could be put to use, consider again the random function and the one you wrote that generates two random ints
13:08:02 <eikke> JoeyA: obviously I could use a functional map in an IORef or TRef or something alike, but wanted to experiment with other approaches as well
13:08:13 <kqr> parcs`, okay
13:08:22 <eikke> JoeyA: thought a map backed by STM would make sense
13:08:51 <donri> who runs hackagebot?
13:08:53 <ddarius> @google Haskell STM hashtable
13:08:55 <lambdabot> http://en.wikipedia.org/wiki/Software_transactional_memory
13:08:55 <lambdabot> Title: Software transactional memory - Wikipedia, the free encyclopedia
13:08:57 <parcs`> the first paramater (s -> (a, s)) looks just like (StdGen -> (Int, StdGen)) so lets apply it to stateThreading
13:09:06 <JoeyA> The simplest STM-backed map is TVar Map.
13:09:14 <parcs`> :t stateThreading (random :: StdGen -> (Int, StdGen))
13:09:15 <lambdabot> forall b. (Int -> StdGen -> (b, StdGen)) -> StdGen -> (b, StdGen)
13:09:32 <eikke> JoeyA: sure, but that doesnt allow concurrent mutations
13:09:46 <JoeyA> eikke: What do you mean?
13:09:48 <ddarius> The problem with that is that STM's implementation is an optimistic concurrency scheme and so performs poorly under high contention.  That would lead to nothing but contention.
13:10:01 <JoeyA> Inserting into a map replaces the old map with the new one, efficiently.
13:10:17 <JoeyA> Are you talking about concurrently mutating sections of the map?
13:10:25 <eikke> JoeyA: yes
13:10:48 <ddarius> eikke: There is probably an implementation somewhere, but it should be pretty easy to make one.  Making such things easy is the whole point of STM.
13:11:15 <JoeyA> It'd also be a fun exercise, if you're into that kind of thing.
13:11:30 <eikke> same for reads as well: whenever a read is initiated and a write occurs at the same time and finishes 'earlier', the read would be retried, even if it occurs in a completely different part of the map
13:11:46 <eikke> JoeyA: yup, will look into it :-)
13:12:06 <parcs`> @let randomInt :: StdGen -> (Int, StdGen); randomInt = random
13:12:07 <lambdabot>  Defined.
13:12:07 <eikke> ddarius: indeed, just wondering whether I could save some time :-P
13:12:37 <ddarius> eikke: Scour Hackage.  If it's not on Hackage, you probably don't want to use it.
13:13:13 <shachaf> That's my rule of thumb for all software.
13:13:14 <eikke> ddarius: agree, yet eg I didnt find tskiplist (which is on hackage) due to wrong keyword selection
13:13:18 <Mkman> i have a question. how can i generate an random number between 0 and that n ?
13:13:25 <eikke> Mkman: randomR
13:13:34 <ddarius> Scour /= search.
13:13:45 <JoeyA> @type scour
13:13:46 <lambdabot> Not in scope: `scour'
13:14:57 <parcs`> kqr: before that, lets define a helper function (a -> s -> (a, s)) that takes a state and a value and simply returns that value and the state unmodified as a tuple
13:15:16 <parcs`> @let returnState :: a -> s -> (a -> s); returnState a s = (a, s)
13:15:17 <lambdabot>  <local>:3:53:
13:15:17 <lambdabot>      Couldn't match expected type `a -> s'
13:15:17 <lambdabot>             against...
13:15:25 <parcs`> @let returnState :: a -> s -> (a, s); returnState a s = (a, s)
13:15:26 <lambdabot>  Defined.
13:15:29 <Mkman> eikke: thanks
13:15:30 * ddarius decides to read the paper describing the algorithm he's implementing, because an issue he thought might be a problem looks like it is a problem.
13:15:50 <derpladee> hey how do i add a type signature to a function inside an instance declaration?
13:15:58 <derpladee> uhmn like, a type constraict
13:16:13 <derpladee> i want one of the arguments for the function to implement Show
13:16:30 <parcs`> :t randomInt `stateThreading` (\firstRandomInt -> randomInt `stateThreading` (\secondRandomInt -> returnState (firstRandomInt, secondRandomInt)))
13:16:31 <lambdabot> StdGen -> ((Int, Int), StdGen)
13:16:47 <JoeyA> class Show a => Launchable a
13:17:00 <JoeyA> (requires all instances of Launchable to have a Show instance)
13:17:44 <JoeyA> instance Show a => Launchable (Foo a)  -- defines a Launchable instance for any Foo a where 'a' has a Show instance.
13:17:45 <parcs`> kqr: using the very general combinators 'stateThreading' and 'returnState', you can define a function that return two random ints + the new seed like that
13:18:20 <JoeyA> derpladee: Are you defining a type class, or writing an instance for an existing type class?
13:18:23 <ddarius> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
13:18:24 <lambdabot> f a b c =
13:18:24 <lambdabot>     case a c of
13:18:24 <lambdabot>     (d, e) -> b d e
13:18:38 <parcs`> kqr: is a bit verbose due to the long names, but normally stateThreading is defined as '>>=', and returnState as 'return'
13:19:31 <parcs`> in practice, you would write
13:19:32 <derpladee> i'm writing an instance for an existing type class
13:19:39 <derpladee> the monad class
13:20:03 <parcs`> :t state random >>= \a -> state random -> \b -> return (a, b)
13:20:04 <lambdabot> parse error on input `->'
13:20:13 <parcs`> :t state random >>= \a -> state random >>= \b -> return (a, b)
13:20:14 <lambdabot> forall s a a1. (Random a, RandomGen s, Random a1) => StateT s Identity (a, a1)
13:20:55 <parcs`> :t do { a <- state random; b <- state random; return (a, b); } -- or in do notation
13:20:56 <lambdabot> forall s a a1. (Random a, RandomGen s, Random a1) => StateT s Identity (a, a1)
13:21:40 <copumpkin> or just liftA2 (,)
13:22:04 <JoeyA> derpladee: So you need to implement >>= or something by requiring an argument to implement Show?
13:22:29 <JoeyA> I don't think you can declare such constraints on individual functions.  You may need to declare the constraint on the instance
13:23:11 <JoeyA> e.g. instance Show msg => Monad (Foo msg)
13:24:56 <kqr> parcs`, hm, okay
13:25:04 <marks111> Hello room, I'm newish to haskell and was wondering if I could get a quick question answered
13:26:10 <shachaf> marks111: Not if you don't ask it.
13:26:31 <marks111> I'm trying to debug a function using trace, and I'm trying to use it before a let block, ie trace (show (a, b)) $ let .... in .... but ghc says thats a syntax error
13:26:32 <derpladee> yea i tried that but then it says that (Foo msg) is of type * -> * and Monad expects type *
13:26:40 <derpladee> Foo implements Show
13:26:49 <derpladee> or is an instance of show
13:28:01 <marks111> I've tried leaving out the $ but that doesn't work either and I don't know what else could work
13:28:08 <derpladee> no wait, it says that (Foo msg) is type * but Monad espects type * -> *
13:28:30 <parcs`> kqr: it is a bit hard to understand because 1) i am a bad teacher and 2) monads are a very general concept
13:28:41 <derpladee> which is weird, because my Foo is an instance of Show which looks just like Monad class and it doesn't complain about Foo being an instance of Show
13:28:54 <parcs`> kqr: i defer you to http://learnyouahaskell.com/ if you want to learn more
13:29:21 <JoeyA> @back
13:29:21 <lambdabot> Maybe you meant: ask fact smack
13:30:13 <JoeyA> derpladee: Well, Foo msg a could be an instance of Show, and Foo msg could be an instance of Monad.
13:30:13 <BMeph> Hey, parcs`? Isn't "(s -> (a, s)) -> (s -> (b, s)) -> s -> (b, s)" just 'const id'?
13:30:58 <parcs`> BMeph: that's one definition
13:31:02 <parcs`> the other is (>>) :P
13:31:13 <mikeplus64> marks111: let ... in trace (show (a, b)) ?
13:31:50 <marks111> feel stupid now :-)
13:31:53 <marks111> lemme try that
13:33:37 <ddarius> marks111: What you wrote should work, so the problem is in the code you actually wrote and not your abstraction of it.
13:33:46 <marks111> mikeplus64: actually, still a parse error
13:35:06 <marks111> :ddarius thanks for the input, I guess I'll look further to see what's wrong
13:35:28 <mikeplus64> marks111: make sure you haven't left out a paren somewhere or have confusing (to GHC) indentation or something I suppose
13:36:20 <marks111> mikeplus64: yeah so what indentation would be appropriate? the same level as the "let" and "in" I presume?
13:38:30 <mikeplus64> marks111: stuff in the let binding you want indented
13:38:54 <mikeplus64> > let a = 5; b = 14 in trace (show (a, b)) (a + b)
13:38:55 <lambdabot>   Not in scope: `trace'
13:39:07 <mikeplus64> close enough
13:39:27 <sipa> > let 2 = 1 in 2+2
13:39:28 <lambdabot>   4
13:39:32 <sipa> :(
13:40:06 <shachaf> > let !2 = 1 in 2+2
13:40:07 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
13:40:14 <mikeplus64> > let 2 + 2 = 3 in 2 + 2
13:40:15 <lambdabot>   3
13:40:46 <kqr> parcs`, i'd like to disagree to 1), but 2) is certainly true
13:40:50 <kqr> parcs`, i'll take a look at lyah
13:41:26 <marks111> mikeplus64: so now I have the trace statement as the first line of the "in" block, and it still throws a parse error on the following line
13:41:47 <mikeplus64> marks111: hpaste.org
13:42:48 <hpaste_> marks111 pasted “trace example” at http://hpaste.org/56485
13:42:48 <parcs`> kqr: here is the section addressing the state monad (http://learnyouahaskell.com/for-a-few-monads-more#state) but it's probably best to read the book from the beginning
13:43:18 <kqr> parcs`, i've read some of the book, but i'll take a look at the state part to see if i'm ready to grasp it yet
13:47:07 <ddarius> marks111: Why do you have $s in all your case alternatives?
13:47:45 <parcs`> kqr: you'll have no trouble i bet :)
13:48:43 <marks111> ddarius: hehe I had 4 separate traces there originally and forgot to take out the $ :-)
13:49:15 <ak13> IOVar
13:50:09 <srhb> Does anyone have a working version of hpaste.el lying around?
13:50:25 <srhb> (Anyone who's willing to share :-))
14:04:54 <thetrav> trying to wrap my head around the idea of right folds on infinitel lists...  An example where they would be used might be when you're transforming an infinite list to a different infinite list then only getting the first few elements out of it?
14:05:34 <srhb> thetrav: Sure, that's possible.
14:05:44 <Axman6> thetrav: it might be he=lpful to understand how functions like and and or work
14:05:51 <Sgeo> and and
14:05:57 <Sgeo> Sorry
14:05:58 <Sgeo> :t and
14:05:59 <lambdabot> [Bool] -> Bool
14:06:17 <Axman6> > foldr f x [a,b,c] :: Expr
14:06:18 <lambdabot>   f a (f b (f c x))
14:06:58 <Axman6> thetrav: do you understand what's hoing on there? and why if f isn't strict in its second argument, it can terminate early?
14:06:58 <thetrav> hmm
14:07:10 <thetrav> ahh
14:07:23 <thetrav> I was about to ask if you could get f of a without calculating f of b and f of c
14:07:34 <thetrav> I guess that's what not strict in the second argument means
14:07:57 <Axman6> see, if f a <whatever> can return an answer without needing to look at <whatever>, then the rest of the computation doesn't need to be evaluated
14:08:06 <Axman6> for example, use const:
14:08:11 <Axman6> :t const
14:08:11 <lambdabot> forall a b. a -> b -> a
14:08:14 <Axman6> @src const
14:08:14 <lambdabot> const x _ = x
14:08:27 <Axman6> > foldr const 0 [1,2,3]
14:08:27 <lambdabot>   1
14:08:32 <Axman6> > foldr const 0 [1..]
14:08:33 <lambdabot>   1
14:09:03 <thetrav> cool
14:09:09 <Axman6> because we get const 1 (const 2 (const 3 (const 4 ...) (sort of), but const only needs its first argument, it returns 1 right away
14:09:10 <Sgeo> That's really not the full story though. f might return an answer that depends on its second argument without being strict in it
14:09:17 <Sgeo> Or, well, only head, or what have you
14:09:17 <thetrav> I should play with it a while to lock it in, but I get the general idea
14:09:26 <marks111> mikeplus64: sorry got disconnected; do you see anything wrong with my code?
14:09:29 <nus> srhb, what's wrong with the version on the wiki?
14:09:30 <Sgeo> Erm, that was poorly expressed
14:09:43 <Axman6> thetrav: so, now if you have a look at the definition for and:
14:09:45 <Axman6> :t and
14:09:45 <lambdabot> [Bool] -> Bool
14:09:47 <Axman6> @src and
14:09:47 <lambdabot> and   =  foldr (&&) True
14:09:51 <Axman6> :t (&&)
14:09:52 <lambdabot> Bool -> Bool -> Bool
14:09:55 <Axman6> @src (&&)
14:09:56 <lambdabot> True  && x = x
14:09:56 <lambdabot> False && _ = False
14:10:31 <Axman6> we can see that if (&&) gets a False value in its left argument, it doesn't need to evaluate its right argument, and returns false immediately
14:10:54 <thetrav> that's basically short curcuiting logic right? which happens in a lot of languages
14:11:04 <Axman6> > foldr (&&) True [True,False]
14:11:04 <lambdabot>   False
14:11:12 <Sgeo> Except much more pervasive in Haskell then in other languages
14:11:20 <Axman6> > foldr (&&) True ([True,False] ++ repeat True) -- infinite list
14:11:22 <lambdabot>   False
14:11:34 <Axman6> thetrav: yeah, but we can do it with any function
14:11:36 <thetrav> yeah, the pattern seems like it applies to more than just the && case
14:11:42 <thetrav> which is neat
14:16:06 <mikeplus64> marks111: unneeded $, indent the "in block" to the same level as the let one, indent then, else and the case expression
14:16:54 <ddarius> mikeplus64: None of that indentation is necessary.
14:17:08 <mikeplus64> ddarius: just makes it look nicer :D
14:17:26 <kejoki> openFile :: FilePath -> IOMode -> IO Handle  -- and
14:17:27 <kejoki> hGetContents :: Handle -> IO String -- but in a do I can
14:17:27 <kejoki> myString <- hGetContents myOpenedFile
14:17:36 <kejoki> doesn't seem to make sense.
14:17:44 <tomh> hmm does Text.Regex not exist anymore?
14:17:46 <kejoki> what type is (<-) ?
14:18:32 <kejoki> ghci gives me a parse error if I try :type on it.
14:20:10 <kejoki> I'm not getting how hGetContents is supposed to take a Handle but is not having a problem with an IO Handle.
14:20:18 <mokus> <- isn't a function, it's built-in syntax - part of "do notation"
14:20:44 <mokus> in "x <- foo", foo :: M a where M is some Monad, and x :: a
14:21:06 <mokus> it expands to "foo >>= \x -> {- the rest of the do block -}"
14:21:23 <mokus> so (>>=) is the function whose type is most relevant
14:22:09 <kejoki> okay.  That demystifies it a bit.
14:28:55 <kejoki> or not...
14:29:43 <kejoki> well, it demystifies the binding.
14:32:00 <kejoki> I still don't get why hGetContents can work with stdin, which is type Handle AND with the result of openFile "fpath" ReadMode, which is type IO Handle.
14:32:55 <shachaf> kejoki: It depends on what you mean by "result".
14:33:11 <dolio> It works using (>>=)
14:33:12 <shachaf> When you say do { x <- openFile "fpath" ReadMode; ... }, x has type Handle in ...
14:33:59 <mokus> when you say "h <- openFile ...", you're saying "execute this here IO Handle, and if/when it's done, call the Handle 'h'"
14:35:09 * kejoki **head slap**
14:36:02 <kejoki> y'know, it doesn't actually work if you   hGetContents (openFile ...)
14:36:21 <alpounet> thus the <-
14:36:28 <mokus> nope :)
14:36:29 <kejoki> works fine if you bind it, though.
14:37:50 <kqr> am i right in that you can't do "a <- someIOOperation; b <- someOtherIOOperation; f a b"?
14:38:09 <shachaf> @src liftM2
14:38:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:38:14 <ion> You can do that.
14:38:14 <geekosaur> why wouldn't you?
14:38:18 <kqr> oh
14:38:18 <kqr> right
14:38:24 <kqr> i've misunderstood the bind then
14:38:26 <kqr> thanks
14:38:37 <kejoki> kqr: join the club.
14:38:43 <kejoki> :)
14:38:48 <kqr> haha
14:39:28 <djahandarie> @src liftA2
14:39:29 <lambdabot> liftA2 f a b = f <$> a <*> b
14:39:43 <kejoki> /me used to say that an "Aha" moment was better than sex.
14:39:43 <kejoki> But I think Haskell provides a few too many.
14:40:46 <ion> Haskell is better than a sex change.
14:40:57 <kejoki> no argument
14:41:40 <kejoki> so is (insert your most detested programming language here.)
14:41:42 <mokus> i'll take your word for that ;)
14:43:59 <kejoki> @src liftM
14:43:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:44:19 <thetrav> how do I define a list of integers from 1 to infinity?  Is it 1..
14:44:27 <ion> [1..]
14:44:39 <thetrav> ahh, thanks
14:44:47 <shachaf> let ls = 1 : map (+1) ls in ls
14:45:20 <ion> fix ((1:) . map succ)
14:46:04 <shachaf> > map floor [1..1/0]
14:46:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:46:39 <ion> > scanl (+) 1 (repeat 1)
14:46:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:47:29 <kejoki> > [1,0..]
14:47:30 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
14:47:48 <kejoki> (he didn't say *which* infinity.)
14:48:15 <aavogt> > [ 1.1, 1.3 .. 1.7 ]
14:48:16 <lambdabot>   [1.1,1.3,1.5,1.7]
14:48:45 <aavogt> > [ 0, 0.7 .. 2.1 ]
14:48:46 <lambdabot>   [0.0,0.7,1.4,2.0999999999999996]
14:49:18 <kqr> 00:32:15   shachaf> > map floor [1..1/0]
14:49:20 <kqr> why does that work?
14:49:28 <aavogt> maybe somebody else has an example of Enum Double being surprising
14:49:49 <aavogt> > floor (1/0)
14:49:50 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
14:50:08 <aavogt> actually that's not the right order
14:50:18 <aavogt> > 1 > 1/0
14:50:19 <lambdabot>   False
14:50:35 <kqr> shouldn't 1/0 be undefined?
14:50:58 <srhb> kqr: No, but 1 `div` 0 should.
14:51:04 <srhb> Probably. :-)
14:51:05 <kqr> a...ha
14:51:13 <kqr> > 1/0
14:51:14 <lambdabot>   Infinity
14:51:17 <kqr> right
14:51:24 <ion> Floor of infinity is exactly 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216. They never teached that in school.
14:51:24 <kqr> > div 1 0
14:51:25 <lambdabot>   *Exception: divide by zero
14:51:54 <srhb> floor (2/0)
14:51:59 <srhb> > floor (2/0)
14:52:00 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
14:52:06 <srhb> Same infinity! Go figure.
14:52:12 <srhb> :-)
14:53:05 <kqr> doesn't the io monad make sure input and output come in the "right" order?
14:54:24 <cmccann> kqr, they happen in the order specified, modulo stuff like buffering that sometimes confuse people
14:55:08 <kqr> cmccann, right, it's probably the buffering. thanks
14:55:19 <kqr> cmccann, is there a way to flush the buffer?
14:55:32 <ion> hFlush
14:55:42 <byorgey> there is also hSetBuffering
14:55:44 <kejoki> > (1/0) ^ (1/0)
14:55:45 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:55:45 <lambdabot>    `GHC.Real.Fractional t'
14:55:45 <lambdabot> ...
14:55:58 <kqr> :t hFlush
14:55:59 <lambdabot> Not in scope: `hFlush'
14:56:06 <kejoki> tsk.  so much for transfinite numbers.
14:57:09 <JoeyA> Are takeMVar and putMVar guaranteed to be atomic?
14:57:53 <kqr> are strings in haskell per default unicode?
14:58:23 <byorgey> kqr: yes.
14:58:31 <kqr> right
14:58:44 <kqr> are the functions in Data.Char made for this?
14:58:48 <geekosaur> yes
14:58:53 <kqr> great
14:59:02 <geekosaur> if you have a very old GHC, it won't support Unicode I/O, though
14:59:11 <kqr> how old is very old?
14:59:15 <geekosaur> install utf8-string via cabal in that case
14:59:15 <ion> Well, kind of. Never use Data.Char.toUpper/toLower for instance. Use the Text equivalents instead.
14:59:19 <kqr> because mine dont
14:59:27 <kqr> ion, oh
15:00:38 <geekosaur> looks like 6.12.1 and later have it.  if you're runnung ghc from macports it will be 6.10.4 and not support utf8 I/O
15:00:58 <kejoki> what about unicode source?
15:01:08 <geekosaur> you may also need to insure that you have a utf8 locale set (e.g. export LANG=en_US.UTF-8)
15:01:17 <kejoki> sorry, what about unicode haskell source code?
15:01:19 <geekosaur> unicode source should work since 6.6
15:01:22 <kqr> geekosaur, 6.12.3
15:01:43 <kqr> it seems
15:01:54 <kqr> but ghci still dislikes unicode input
15:01:59 <kqr> <stdin>: hWaitForInput: invalid argument (Illegal byte sequence)
15:02:29 <geekosaur> that suggests to me it has utf8 support but $LANG is wrong
15:02:41 <geekosaur> (if it didn;t have support, it would quietly read garbage)
15:03:21 <kqr> geekosaur, right, thanks
15:04:00 <geekosaur> IIRC if $LANG is unset it tries to read ISO8859/1 and convert to unicode; if you feed it utf8 it will throw that error
15:04:29 <irene-knapp> :t min
15:04:30 <lambdabot> forall a. (Ord a) => a -> a -> a
15:04:49 <irene-knapp> :t ceiling
15:04:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:05:10 <kqr> ion, why should i not use the toLower or toUpper from Data.Char?
15:06:45 <geekosaur> at a guess nobody actually redid them to use the unicode case conversion
15:07:14 <kejoki> why is lambdabot putting the "forall a b" in front of the types?
15:07:17 * geekosaur tried to look at source, discovered it uses FFI calls... but not to OS routines that handle it
15:07:32 <kejoki> if it's not restricted then it's forall, right?
15:07:58 <geekosaur> yes, it's just being pedantic
15:08:37 <geekosaur> it's using ghc to compute the types, and ghc-api returns them forall-ed IIRC
15:08:39 <kqr> Prelude Data.Char> putStrLn $ map toUpper "Ελληνικά"
15:08:40 <kqr> ΕΛΛΗΝΙΚΆ
15:08:40 <kqr> Prelude Data.Char> putStrLn $ map toUpper "Räksmörgås"
15:08:40 <kqr> RÄKSMÖRGÅS
15:08:48 <kqr> seems to work for a few codepoints at least
15:08:49 <aavogt> some extensions enabled in \bot make them include the forall
15:09:18 <kejoki> thanks
15:09:20 <geekosaur> yay
15:10:10 <aavogt> http://hpaste.org/56489 <-- example
15:10:43 <aavogt> but there is a more specific extension for that formatting (in this case... sometimes the forall does make a difference)
15:10:58 <aavogt> for example -XScopedTypeVariables
15:11:20 <idnar> is there a structure like a bloom filter that only gives false negatives instead of only giving false positives?
15:17:59 <kejoki> aavogt: existentially quantified types...that's cool.
15:18:31 <kejoki> I don't have to give up *all* of my Perlish scope tricks.
15:18:32 <lispy> I spent the morning refactoring JuicyPixels to store data using vector
15:19:00 <lispy> Now you can use JuicyPixels with OpenGL
15:26:13 <kqr> if i have a function on the form [Char] -> [Char] and i want to turn it into a [Char] -> IO [Char], how do i go about doing that?
15:26:40 <geekosaur> return
15:27:41 <kqr> geekosaur, but where? if i try to put it before the function it just becomes an IO ([Char] -> [Char])
15:28:02 <irene-knapp> > return $ reverse "abc"
15:28:03 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
15:28:04 <lambdabot>    arising from a use ...
15:28:17 <kqr> :t return $ reverse "abc"
15:28:18 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
15:28:21 <shachaf> kqr: This is a good exercise in how functions and types work. :-)
15:28:24 <irene-knapp> > return $ reverse "abc" :: IO String
15:28:25 <lambdabot>   <IO [Char]>
15:28:30 <kqr> :t return $ reverse
15:28:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m ([a] -> [a])
15:28:37 <kqr> shachaf, probably
15:28:43 <ocharles> :t return . (reverse :: [Char] -> [Char])
15:28:44 <lambdabot> forall (m :: * -> *). (Monad m) => [Char] -> m [Char]
15:28:50 <gwern> > (100 * 200) / 194
15:28:51 <lambdabot>   103.09278350515464
15:29:02 <geekosaur> :t return . reverse
15:29:02 <_Mikey> 1+1
15:29:03 <kqr> :t return . reverse
15:29:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
15:29:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
15:29:08 <NemesisD> i've got 2 IO threads that return nothing. how should i have main wait for both threads to finish?
15:29:19 <shachaf> NemesisD: MVars?
15:29:23 <kqr> wow so that works
15:29:35 <kqr> ah
15:29:36 <kqr> right
15:29:37 <kqr> of course
15:29:39 <shachaf> kqr: Yes, but there's a simpler solution that doesn't use (.). Can you figure it out?
15:29:47 <Apocalisp> What's a good text to refer to regarding the technique of trampolining?
15:30:16 <kqr> shachaf, does it involve another function?
15:30:23 <NemesisD> shachaf: is there a simpler way to do that? i've got nothing of value to push into the mvar
15:30:32 <shachaf> NemesisD: Just use MVar ().
15:30:39 <sm> hey all. I've got code importing Text.XML and I'm confused about which package it's coming from. How can I find out for certain ?
15:30:39 <shachaf> NemesisD: There exist packages that will do it for you.
15:30:44 <shachaf> @hackage spawn
15:30:44 <lambdabot> http://hackage.haskell.org/package/spawn
15:30:51 <shachaf> spawn :: IO a -> IO (IO a)
15:31:43 <JoeyA> What's a better name than ExceptionTarget?
15:31:55 <JoeyA> Namely, an abstract object to which you can throw an exception.
15:32:22 <JoeyA> If it were a class, a cute name might be ThrowToable
15:32:34 <shachaf> sm: You could ghci -hide-all-packages -package base, and then try :m + ModuleName
15:32:52 <geekosaur> Catcher?
15:32:57 <derpladee> is it okay to use "let ... in ..." to make your code look "neater" ?
15:33:03 <derpladee> like to avoid huge clusters of code
15:33:13 <shachaf> Yes.
15:33:23 <irene-knapp> it's very okay
15:33:26 <shachaf> Wait, unless you mean "moral".
15:33:36 <sm> shachaf: good trick, thanks!
15:33:57 <irene-knapp> JoeyA: what about, hmmm, ?. ExceptionRecipient?
15:34:01 <derpladee> does anybody know why i'm getting a "parse error on input `='" about my "let ... in ..." in the second line of the let?
15:34:04 <irene-knapp> notice that I don't think "short" equates with "good"
15:34:08 <derpladee> the first line gives me no problems
15:34:12 <irene-knapp> I just think "target" is too vague
15:34:15 <ocharles> derpladee: paste code to hpaste.org, don't let us guess
15:34:22 <JoeyA> Recipient is too long :(
15:34:22 <irene-knapp> (I didn't know what you meant it to be until you said explicitly)
15:34:26 <JoeyA> err, ExceptionRecipient is
15:34:47 <gwern> > log 1.05
15:34:48 <lambdabot>   4.879016416943205e-2
15:34:49 <JoeyA> How is Target not appropriate?
15:34:49 <hpaste_> derpladee pasted “letin” at http://hpaste.org/56490
15:34:50 <irene-knapp> there's no infrastructure I'm aware of that restricts the length of Haskell symbols.  give in to the dark side.
15:34:53 <derpladee> http://hpaste.org/56490
15:35:00 <JoeyA> If I throw a shovel at you, are you a "recipient" or a "target" ?
15:35:02 <derpladee> oh there's a bot for that
15:35:10 <derpladee> fancy
15:35:11 <irene-knapp> target doesn't tell me what it is.  I'm not sure what else it could mean, right, but I'm not sure offhand what it DOES mean either.
15:35:17 <NemesisD> shachaf: spawn looks nice and simple, but i'm not sure how i actually demand the result. i would like to do something like mapM_ (demand . spawn) [iocomputation1, iocomputation2]
15:35:25 <gwern> > (log 1.05) * 100
15:35:26 <lambdabot>   4.879016416943205
15:35:38 <irene-knapp> Common Lisp calls a related concept to the one you're going for a "restart"; you could try that
15:35:47 <NemesisD> shachaf: would demand be seq?
15:35:54 <JoeyA> Thanks for the input.
15:35:56 <gwern> > 13 / (log 1.05)
15:35:56 <shachaf> NemesisD: demand would be id
15:35:57 <lambdabot>   266.4471460857421
15:36:01 <NemesisD> ahh
15:36:01 <irene-knapp> sure thing, good luck
15:36:31 <shachaf> Wait, no it wouldn't.
15:36:47 <shachaf> demand would be join, but that's not really what you want.
15:36:59 <shachaf> You want mapM spawn [io1, io2] >>= sequence_
15:37:16 <shachaf> There's no point to demanding the result *immediately* after you spawn the thread.
15:37:22 <shachaf> You first want to spawn all threads and then wait on them all.
15:38:16 <derpladee> okay i get it now
15:38:29 <NemesisD> shachaf: ah that makes sense. thank you!
15:38:32 <ocharles> derpladee: you got it? it's due to bad alignment
15:40:50 <derpladee> yep i got it
15:43:01 <gwern> > 0.9 * 0.9
15:43:01 <lambdabot>   0.81
15:44:54 <gwern> > 0.9 * 0.1
15:44:55 <lambdabot>   9.000000000000001e-2
15:45:12 <gwern> > (0.9 * 0.1) * 100 -- I'm just not comfortable reading scientific notation
15:45:13 <lambdabot>   9.000000000000002
15:55:07 <chemistree> is it possible to "/join #[usernameYou]" and the channel created automatically joins 'usernameYou' as well as myself?
15:56:05 <bss03> Any one have any experience using the mediawiki package off hackage?
15:56:06 <Axman6> > let f x = let y = x / 100; z = y * 100 in y : z : f z in f 0.9
15:56:07 <lambdabot>   [9.000000000000001e-3,0.9000000000000001,9.000000000000001e-3,0.90000000000...
15:56:17 <Axman6> > let f x = let y = x / 100; z = y * 100 in y : z : f z in f 0.9 !! 100
15:56:18 <lambdabot>   9.000000000000001e-3
15:56:27 <Axman6> > let f x = let y = x / 101; z = y * 101 in y : z : f z in f 0.9 !! 100
15:56:27 <lambdabot>   8.910891089108912e-3
15:57:20 <bss03> I don't see how to easily chain together anything to make a working bot...
15:58:10 <bss03> No monad(s) to hide the session cookie, or function that accept a LoginResponse (or part of one) when performing an action.
15:59:41 <Axman6> reader monad?
16:00:22 <bss03> ...right, but I don't see any functions that live the in right reader monad.
16:00:51 <bss03> It's a fairly large package with very little documentation.
16:01:11 <lupig> quick question: is there a way to apply a function to a parameter multiple times?
16:01:27 <lupig> kind of like > last (iterate f obj)
16:01:56 <byorgey> lupig: if you know how many times you want, you can do  (iterate f obj) !! n
16:01:57 <bss03> lupig: Data.Function.fix?
16:02:04 <Axman6> iterate f obj !! n?
16:02:14 <lupig> sweet!
16:02:21 <Axman6> lupig: your description isn't very helpful...
16:02:23 <lupig> I was just worried it might be inefficient to hold all that stuff?
16:02:32 <Axman6> what stuff?
16:02:41 <byorgey> lupig: hold what stuff?  only what is needed will be computed.
16:02:45 <bss03> Data.Function.fix f ~= last (iterate f undefined)
16:02:59 <lupig> oh
16:03:05 <lupig> I'm still new to this functional programming thing
16:03:12 <Axman6> except that fix can give you useful answers, where as last (iterate f x) cannot
16:03:22 <Axman6> > fix (1:)
16:03:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:03:37 <byorgey> also, this is one of the few places where (!!) is really and truly what you want.
16:03:38 <Axman6> > last (iterate (1:) [])
16:03:43 <lupig> i'm calculating pascal's triangle like this: pasca = iterate (\x -> zipWith (+) ([0] ++ x) (x ++ [0])) [1]
16:03:48 <lambdabot>   mueval: ExitFailure 1
16:03:48 <lambdabot>  mueval: Prelude.undefined
16:03:56 <lupig> but I only need the nth row
16:04:02 <bss03> take 5 $ fix ((1:)  . scanl (+) 1)
16:04:05 <byorgey> lupig: looks good
16:04:07 <bss03> > take 5 $ fix ((1:)  . scanl (+) 1)
16:04:08 <Axman6> lupig: then you probably want the iterate version
16:04:11 <lambdabot>   mueval-core: Time limit exceeded
16:04:13 <Axman6> with (!!)
16:04:19 <lupig> thanks!
16:04:56 <lupig> so it will get rid of old rows, and not run out of memory, right?
16:05:01 <lupig> testing it out. thanks guys
16:05:08 <Axman6> > let pascal n = iterate (\x -> zipWith (+) ([1] ++ x) (x ++ [1])) [1] !! n in pascal 10
16:05:11 <lambdabot>   mueval-core: Time limit exceeded
16:05:15 <Axman6> :|
16:05:19 <Axman6> > let pascal n = iterate (\x -> zipWith (+) ([1] ++ x) (x ++ [1])) [1] !! n in pascal 2
16:05:22 <lambdabot>   mueval-core: Time limit exceeded
16:05:23 * cmccann wonders what (!!) is useful for other than "get the nth iteration" in combination with iterate
16:05:31 <Axman6> you suck lambdabot
16:05:35 <Axman6> @undefine
16:05:35 <byorgey> lupig: right
16:05:45 <Axman6> > let pascal n = iterate (\x -> zipWith (+) ([1] ++ x) (x ++ [1])) [1] !! n in pascal 1
16:05:48 <lambdabot>   mueval-core: Time limit exceeded
16:05:58 <byorgey> cmccann: yeah, I can't think of any other uses either
16:05:58 <Axman6> > 1
16:05:59 <lambdabot>   1
16:06:07 <Axman6> > 1 + 2
16:06:08 <lambdabot>   3
16:06:21 <derpladee> hey
16:06:36 <derpladee> how do i place a type signature for a function inside a class implementation?
16:06:47 <Axman6> you can't. stick it in comments
16:06:52 <derpladee> alright
16:07:07 <bss03> derpladee: you don't.  The type signature is in the class defintion.
16:07:11 <derpladee> yea i know
16:07:17 <derpladee> i just like to be explicit about these things
16:07:26 <derpladee> it helps me do the actual coding :)
16:07:50 <byorgey> derpladee: I would enjoy being able to put type signatures in class instances too.
16:07:55 <byorgey> but alas.
16:08:15 <cmccann> derpladee, have you considered writing the functions outside the instance definition?
16:08:25 <cmccann> then just have "foo = fooBar" for the instance
16:08:28 <cmccann> and such
16:08:36 <Axman6> surerly it can't be too hard to make GHC accept that, as long as the type matches (exactly) what it thinks it should be
16:12:05 <shirt> what's the current situation with global IORef variables? is there finally a good solution?
16:13:47 <bss03> There's a TH library on hackage that codifies the current "best practices", IIRC.
16:16:08 <cmccann> though a fair number of people think that global IORefs are a bad idea anyway
16:17:38 <gwern> > 266.4 * 0.10
16:17:39 <lambdabot>   26.64
16:17:53 <bss03> cmccann: I think the motivator (for the TH library) was some sort of C interop.
16:18:16 <shirt> it's their right to think that and to not use them. but they shouldn't force their views on everyone else who does need to use them :(
16:18:27 <gwern> oh, does TeX have any special name for True/False?
16:18:40 <bss03> cmccann: Like using a non-threadsafe C library from multiple Haskell capabilities or something like that.
16:18:53 <Axman6> shirt: what makes you say you do need to use them?
16:19:07 <cmccann> bss03, yes, sometimes there may be no choice
16:19:16 <bss03> shirt: "need" is what we'd question. :P
16:19:39 <shirt> Axman6: i need a global variable for use in posix signal handlers, which are truly "global". i don't absolutely *need* a global variable, but it would make the code a lot cleaner
16:20:10 <kqr> what is the easiest way to load files as byte sequences in haskell, instead of strings?
16:20:33 <lispy> kqr: bytestring has a readFile
16:20:37 <bss03> kqr: ByteString
16:20:40 <kqr> kay, thanks
16:20:44 <cmccann> shirt, global IORefs being a bad idea doesn't mean they're not still the best option for working around the limitations of interacting with foreign code :P
16:20:46 <shirt> kqr: yep, best and easiest is to use Data.ByteSTring
16:22:08 <shirt> cmccann: not sure i understand
16:23:25 <kqr> Ambiguous occurrence `readFile'
16:23:35 <kqr> how do i call it non-ambiguously?
16:23:42 <kqr> (or import it, perhaps)
16:23:55 <bss03> shirt: I tend to think that you should just pass the IORef to the "signal handlers" via partial application and keep the IORefs from being global, but I don't know the structure of your code.
16:23:58 <nand`> import qualified
16:24:12 <bss03> kqr: import qualified ByteString as BS
16:24:18 <bss03> kqr: BS.readFile
16:24:24 <kqr> okay
16:24:48 <shirt> bss03: problem is i want to read the status of the signal from any IO code, and it will be very annoying to pass the IORef around throughout the entire application
16:25:03 <cmccann> shirt, just saying that even if global IORefs are a bad idea in general, they may still be the best solution in some cases
16:26:52 <bss03> shirt: Do it with global IORefs, then.  I don't know your code.  Also, I think that if GHC breaks global IORefs in some way (unlikely) we'll see plenty of people motivated to fix it fast. :P
16:27:31 <shirt> cmccann: sounds like "use the right tool for the right job"
16:27:46 <tazjin> Does Text.JSON have a function that takes a single field out of a JSON document by field name?
16:30:31 <shirt> bss03: ok :) i'm just not happy that the only to have global IORefs is with a brittle hack. the proper way to support global IORefs would probably have to be for the programmer to define that arbitrary (IO a) code should be run prior to main. very similar to C++ static constructors. but i can understand why the anti-IORef people would be against this since it can introduce hard-to-find bugs. but this would be very useful for libraries that must perform init
16:30:31 <shirt>  code (such as withSocketsDo)
16:32:55 <DanBurton> I have a Coq question, but #coq is rather quiet. Anyone care to give me some insight? http://pastebin.com/yByJP0KG
16:32:56 <mauke> The paste yByJP0KG has been copied to http://hpaste.org/56491
16:36:53 <binarylegit> I'm trying to install haskell-platform on gentoo and I've installed layman and the haskell overlay, but when I run emerge -av haskell-platform it tells me I need to change a whole bunch of keywords, am I doing something wrong?
16:38:21 <Ke> binarylegit: the overlay is in unstable keywords only
16:39:18 <binarylegit> Ke: so what does that mean? do I need to update the keywords?
16:39:27 <Ke> "dev-haskell/* ~amd64" in package.keywords and a few others should do
16:41:07 <kqr> how do i convert from ByteString to String? unpack simply redurns [Word8], not [Char]
16:42:11 <Ke> anyways I wouldn't recomment using platform for anything beyond a simple reference concerning which libraries are commonly available
16:42:28 <JoeyA> kqr: Data.ByteString.Char8's unpack function does, but it doesn't decode Unicode.
16:43:03 <binarylegit> Ke Ah, I see, thanks!
16:43:03 <JoeyA> In the utf8-string package, there's Data.ByteString.UTF8, which has fromString/toString functions that encode/decode UTF-8.
16:46:42 <ocharles> kqr: also, if you're working with human text, consider the text package
16:46:47 <ocharles> what might better suit your needs
16:47:24 <kqr> ocharles, text package to convert from ByteString to String or just going with the text package all the way?
16:47:34 <ocharles> probably the latter
16:47:43 <ocharles> but I don't know what you're working on :)
16:47:52 <kqr> yeah, it's just that i need to do some bitwise operations on the text first, and after that it's all human text
16:48:09 <kqr> but i'd like to avoid installing packages
16:48:30 <ocharles> like bytestring? :)
16:48:38 <kqr> bytestring is installed
16:49:02 <ocharles> bytestring and text are both in the haskell platform, so I wouldn't dismiss them on the issue of deps
16:49:03 <ocharles> imo
16:49:16 <binarylegit> exit
16:49:17 <kqr> no, but my cabal is broken and i have nooo idea why
16:49:27 <kqr> dyld: unknown required load command 0x80000022
16:49:27 <ocharles> :(
16:49:28 <kqr> Trace/BPT trap
16:49:33 <ocharles> oh, that is broken
16:49:33 <kqr> not something i'd like to debug right now
16:53:38 <geekosaur> you're on leopard?
16:53:48 <kqr> yeah
16:54:07 <kqr> but manual installation wasn't that painful so i did that
16:55:00 <geekosaur> think someone's working on a fixed HP build
16:56:28 <kmc> <bss03> [...] Also, I think that if GHC breaks global IORefs in some way (unlikely) we'll see plenty of people motivated to fix it fast.
16:56:34 <kmc> uh, they were broken for a long time
16:56:49 <kmc> http://hackage.haskell.org/trac/ghc/ticket/5558
16:56:52 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
16:57:58 <kmc> shirt, your solution to allow "the programmer to define that arbitrary (IO a) code should be run prior to main" is already implemented in JHC, more or less
16:58:09 <kmc> http://repetae.net/computer/jhc/manual2.html#top-level-actions
16:58:35 <kmc> i wish GHC would implement this feature
16:58:50 <shirt> kmc: nice. that looks perfect! what did the GHC devs say about this?
16:58:57 <kmc> about ACIO? i don't know
16:59:32 <kmc> obviously some people will be against it "on principle"
16:59:36 <kmc> ignoring the demands of the real world
16:59:57 <kmc> in fact I've heard people say that we should make global state *more* dangerous so people don't use it
17:00:30 <kmc> the context for me being interested in this topic is that I was binding a thread-unsafe C library
17:00:35 <kmc> and wanted to protect it with a hidden global lock
17:00:50 <kmc> i would think this is a common problem and solution
17:01:05 <djahandarie> BUT LITTLE DID YOU KNOW
17:01:05 <kmc> but i ran into a GHC bug that was only 2 weeks old at the time, and not fixed in any released version
17:01:23 <kmc> my conclusion is that people writing Haskell bindings for thread-unsafe C libraries don't actually try to make their bindings threadsafe :/
17:02:05 <kmc> @tell bss03 global IORefs were broken for quite a while recently, http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
17:02:06 <lambdabot> Consider it noted.
17:02:47 <kmc> i think after learning about this bug, one would not judge it unlikely that they will break again in the future
17:03:30 <shirt> kmc: hm... if you are doing a direct binding to a c library, couldn't you just leave it to the responsibility of the haskell programmer to do his own locking?
17:03:33 <Eduard_Munteanu> Submit a testcase?
17:03:51 <Eduard_Munteanu> Well, in case GHC actually does that.
17:04:01 <shirt> kmc: ... although i guess this would be a problem for pure functions
17:04:59 <dolio> It occurred to me during an explanation recently that making up top level globals is actually pure.
17:05:01 <kmc> shirt, that's a non-solution
17:05:05 <dolio> Just not referentially transparent.
17:05:14 <kmc> shirt, that's what i mean by "not threadsafe"
17:05:49 <kmc> "this library is threadsafe, as long as you always use it with the proper locking"
17:06:00 <kmc> that's kinda like saying "C is memory-safe as long as you never dereference a bad pointer"
17:06:34 <shirt> kmc: well, pure functions should always be thread safe. but if your binding creates an IO function then i think it is acceptable to declare that it is not thread safe
17:06:42 <djahandarie> C is the best language as long as you don't suck at programming.
17:06:47 <kmc> shirt, I disagree
17:07:04 <cmccann> djahandarie, unfortunately, everyone sucks at programming
17:07:27 <dolio> That isn't the only criterion, either.
17:07:44 <dolio> You also have to enjoy spelling out minutia that don't matter for most stuff most people do.
17:07:58 <shirt> kmc: ok :) it really depends on the library i think
17:08:12 <kmc> shirt, say my code is using this C library, and I also use some Haskell library that (unbeknownst to me) uses the same C library
17:08:46 <kmc> and now i get mysterious segfaults, or worse, exploitable security holes
17:08:57 <shirt> kmc: ok, you've convinced me :)
17:09:10 <kmc> i mean I think FFI bindings should be done in multiple layers
17:09:24 <Eduard_Munteanu> I guess that means it just isn't reentrant (which is actually worse), or what's a better term?
17:09:48 <kmc> the bottom layer will use pointer-based C types, explicit memory allocation, and might not be threadsafe
17:09:58 <kmc> and then you build layers on top of that
17:10:10 <kmc> in hdis86 i have the C layer
17:10:36 <kmc> and another layer which matches the imperative API of the C library, but is memory-safe and thread-safe and has automatic resource management
17:11:01 <kmc> and another layer on top of that which provides the overall library functionality as a single pure function
17:12:14 <shirt> kmc: yep :) btw, the same argument you made could be said about the original c library when programming your app in c. that some other library could be using it in addition to your code. which is why ideally the original c library itself should be thread safe :)
17:12:20 <Eduard_Munteanu> What do you use, something from binutils? (libbfd IIRC)
17:12:28 <kmc> anyway it's ok if these layers are written by different people
17:12:31 <kmc> and in different packages
17:12:43 <kmc> e.g. OpenGLRaw vs OpenGL
17:12:49 <kmc> but it should be clear that one is a bare C binding and the other is a proper Haskell library
17:13:38 <kmc> usually it will be clear from the types etc
17:13:52 <kmc> the problem is when you have a library which looks nice and high-level but isn't threadsafe
17:13:54 <Eduard_Munteanu> Arguably you can't really fix that issue by slapping on some Haskell code, some other lib might use the same C lib.
17:13:57 <kmc> then you get rare mystery segfaults
17:14:05 <Eduard_Munteanu> (and thus use different synchronization objects)
17:14:21 <kmc> yeah, there's only so much you can do
17:14:34 <kmc> as shirt said it would be better if the original C library were threadsafe
17:14:38 <kmc> but many aren't and we have to deal with it
17:14:44 <Eduard_Munteanu> Yeah.
17:14:56 <kmc> Eduard_Munteanu, I don't understand your question about binutils and libbfd
17:15:31 <Eduard_Munteanu> kmc: oh, you said hdis86 used some C lib, I idly wondered if that was something from binutils.
17:15:44 <Eduard_Munteanu> (for disassembling code)
17:15:57 <kmc> no it's a binding to udis86, http://udis86.sourceforge.net/
17:16:03 <kmc> libbfd is not a disassembler
17:16:07 <kmc> you're thinking of libopcodes, which is horrible
17:16:11 <kmc> ask copumpkin about that
17:16:14 <Eduard_Munteanu> Hm, right.
17:16:25 <kmc> udis86 is a very nice C library
17:16:33 <copumpkin> kmc: man, I forgot about that package. I'll put it on hackage tomorrow
17:16:40 <copumpkin> thanks for reminding me :)
17:16:41 <kmc> it doesn't have global state
17:16:51 <kmc> all its state is stored in a struct that the user can allocate however they like
17:17:06 <kmc> so making the haskell bindings thread-safe was not hard
17:17:13 <Eduard_Munteanu> Hm, that's nice.
17:17:47 <kmc> threading in C is hard, so people don't bother, so libraries aren't threadsafe, so threading in C is hard
17:17:59 <kmc> threading in Haskell is easy, so people expect libraries to work
17:19:03 <kmc> anyway i'm mainly annoyed by libraries like http://hackage.haskell.org/packages/archive/repa-devil/0.1.2/doc/html/Data-Array-Repa-IO-DevIL.html
17:19:32 <kmc> which looks all high-level and has a custom monad to provide "statically-guaranteed access to an initialized IL context"
17:19:43 <kmc> and other words haskell programmers love to see
17:19:55 <kmc> but actually it provides very little safety and is not safe for concurrent use
17:20:02 <djahandarie> Hence 'devil'
17:21:21 <kqr> http://pastebin.com/CwDVwH3k
17:21:23 <mauke> The paste CwDVwH3k has been copied to http://hpaste.org/56492
17:21:28 <kqr> any idea why ByteString.map crashes GHC?
17:21:49 <kmc> ghc --make
17:22:05 <kmc> use the flag --make if you are using GHC 6.x
17:22:13 <kqr> oh
17:22:21 <kqr> what's the difference and why?
17:22:45 <kmc> --make will automatically link the relevant Haskell packages for the modules you use
17:22:49 <kmc> it will also chase dependencies between .hs files
17:22:56 <kqr> oh
17:22:57 <kqr> cool
17:23:03 <kmc> if you have Foo.hs which says "import Bar", then "ghc --make Foo.hs" will recompile Bar.hs too
17:23:09 <kmc> unless Bar.hs has not changed since the last build
17:23:29 <kmc> in GHC 7, --make is the default mode
17:23:57 <kmc> maybe you should install the latest Haskell Platform, which has GHC 7.0.4
17:24:02 <kmc> http://hackage.haskell.org/platform/
17:24:05 <kqr> yeah
17:24:06 <kqr> thanks
17:24:18 <shirt> kmc: anyway, jhc "top level actions" look really useful. why was it decided to introduce a complicated ACIO monad, instead of just using IO and running all top level actions prior to main (in an undefined order)?
17:24:34 <kmc> the ACIO monad isn't complicated
17:24:44 <kmc> but anyway, you said it yourself, "undefined order"
17:25:02 <shirt> kmc: it works for c++ and java :)
17:25:08 <kmc> lol
17:25:11 <kmc> we have different standards
17:25:24 <kmc> i mean you could deal with the unsafety of undefined order
17:25:28 <kmc> just like you can deal with unsafePerformIO
17:25:43 <kmc> but if you're introducing a new compiler feature, you might as well get it right, if it's not too hard
17:26:10 <kmc> note that there is a way to embed arbitrary IO actions in ACIO
17:26:14 <shirt> kmc: yep. you could implement the singleton pattern in haskell to have control over execution order. ugh... singleton in haskell.... :P
17:27:08 <kmc> 'If you need to use arbitrary IO, a utility function 'runOnce' is provided. using it you can ensure arbitrary IO actions are run only once and the return values shared, however you must access the value inside the IO monad, thus ensuring program integrity.'
17:27:46 <shirt> kmc: yeah, i didn't really understand that. doesn't *everything* ultimately happen in the IO monad?
17:28:34 <kmc> so the concern is that if you say "x <- e" at top level
17:28:47 <kmc> the compiler is free not to execute the IO action e until the value of x is forced
17:28:53 <kqr> thank you all, guys. i've been learning a lot today
17:29:23 <kmc> someone (probably john meacham) decided the compiler should have that freedom
17:29:51 <kmc> so you have a situation where evaluation triggers execution
17:29:53 <wavewave> how far is ghc 7.4 away?
17:30:09 <kmc> which breaks the normal rules in haskell
17:30:14 <Axman6> probably a better question for #ghc
17:30:23 <kmc> it's like unsafePerformIO or unsafeInterleaveIO
17:30:27 <wavewave> yep.
17:30:37 <kmc> anyway, ACIO is a restriction of IO to types where this is ok
17:30:41 <kmc> err actions where it's ok
17:30:56 <kmc> it stands for "affine central IO"
17:31:12 <kmc> affine meaning that performing the action and then discarding the result is indistinguishable from not performing it
17:31:16 <shirt> kmc: ok thanks. i understand
17:31:24 <kmc> central meaning that the relative order of an ACIO action and an IO action doesn't matter
17:31:50 <kmc> so for example, allocating an IORef and then throwing it away doesn't have any observable effect
17:32:07 <shirt> kmc: this ACIO monad could potentially be useful in other places... STM comes to mind
17:32:11 <kmc> and it doesn't matter whether you allocate that IORef before or after you do some unrelated thing
17:32:30 <kmc> shirt, hmm, yeat
17:32:31 <kmc> yeah*
17:32:51 <kmc> anyway runOnce :: IO a -> ACIO (IO a)
17:33:11 <kmc> when you execute that ACIO action (at top level), it gives you an IO action
17:33:22 <kmc> when you execute that IO action, it will execute the original IO *only* if it hasn't been executed before
17:34:05 <kmc> i'm pretty sure you can implement that with newMVarACIO
17:34:06 <gwern> > minBound :: Int
17:34:07 <lambdabot>   -9223372036854775808
17:35:01 <shirt> makes sense. still, like you mentioned, it brakes haskell, while executing all toplevels upfront does not break haskell :)
17:35:21 <kmc> what do you mean?
17:35:21 <dmwit> :t lex
17:35:21 <lambdabot> String -> [(String, String)]
17:35:31 <dmwit> > lex " kB free"
17:35:32 <lambdabot>   [("kB"," free")]
17:36:11 <shirt> kmc: if all top level actions are executed before main, then there is no situation where "evaluation triggers execution"
17:36:51 <Axman6> :t unfoldr (listToMaybe . lex)
17:36:52 <lambdabot> String -> [String]
17:37:14 <Axman6> > unfoldr (listToMaybe . lex) "Hello world whoo:
17:37:14 <lambdabot>   <no location info>:
17:37:14 <lambdabot>      lexical error in string/character literal at end o...
17:37:19 <Axman6> > unfoldr (listToMaybe . lex) "Hello world whoo"
17:37:20 <kmc> runOnce act = do { v <- newMVarACIO Nothing; return (modifyMVar f) } where { f Nothing = act <$> (\x -> (Just x, x)); f (Just x) = return (Just x, x) }  -- something like this
17:37:20 <lambdabot>   ["Hello","world","whoo","","","","","","","","","","","","","","","","","",...
17:37:29 <Axman6> heh, or not
17:38:31 <dmwit> :t find
17:38:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:38:36 <dmwit> :t lookup
17:38:37 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:38:38 <kmc> shirt, yeah.  that's more work for the compiler though
17:39:00 <kmc> you'd have to build a dependency graph between all the top-level IO actions (at link time or at program init)
17:39:43 <kmc> and you still have the "undefined ordering for unrelated actions" problem
17:39:55 <kmc> which really is no worse than threads but still
17:40:33 <kmc> if you really need top-level full IO and can't use runOnce then I expect there would be unsafeIOToACIO
17:41:09 <Axman6> could you place restrictions like ACIO can only be used in the Main module? (I can already see problems there with libraries that need access to the results)
17:41:36 <shirt> kmc: right. top level actions should be simple and not have any dependencies. if dependencies are needed then they can be implemented manually(using a singleton or something)
17:41:39 <kmc> that restriction would seriously cripple the usefulness of the feature
17:41:47 <Axman6> yeah :\
17:42:07 <kmc> for example my use case of a global lock to protect a C library
17:42:52 <Axman6> yeah, and that should almost certainly be library level
17:43:06 * Axman6 takes back his idea
17:43:08 <kmc> shirt, sure but if someone makes a mistake and has a dependency between top-level actions, you want to catch that
17:43:32 <kmc> otherwise you have a situation which is like "this code works fine until i recompile it, now it segfaults"
17:43:37 <kmc> that's not ok in haskell
17:43:42 <kmc> we have a higher safety standard than C++
17:44:32 * Axman6 would argue that's usually not ok in C++ too
17:44:35 <kmc> ideally nobody using the C library wrapper should even know that global lock exists
17:44:56 <shirt> kmc: you are right. also, a singleton would be impossible to implement, since it relies on setting the initial value of a global variable to null, before any code is executed
17:45:10 <kmc> shirt, i think what runOnce provides is like a singleton
17:45:10 <roconnor> @info Monad
17:45:11 <lambdabot> Monad
17:45:20 <shirt> kmc: yep
17:45:42 <kmc> so it's not impossible to implement, given newMVarACIO
17:46:09 <shirt> kmc: with the jhc system, you don't even need runOnce, you can implement a singleton using just ACIO
17:46:25 <kmc> yes
17:46:41 <kmc> you can implement runOnce with newMVarACIO
17:48:27 <shirt> kmc: yeah, now i understand why you just mentioned that :) runOnce is indeed just a helper function, not some additional new interface to the underlying system
17:48:47 <kmc> yeah
17:49:19 <shirt> hm.... now i'm not sure about what i said earlier
17:51:26 <kmc> Axman6, I wish it weren't ok in C++ either
17:51:51 <Axman6> kmc: i'm already scared of C++ enough, don't make it worse
17:52:11 <shirt> so the ghc guys didn't have anything at all to say about this feature?
17:52:24 <kmc> if you make this kind of mistake in C or C++, people will laugh at you and tell you to learn to program
17:52:29 <kmc> but that's true of any mistake
17:52:42 <kmc> shirt, not that I've seen
17:52:50 <kmc> i've brought it up in #ghc once or twice
17:52:54 <kmc> there was a little discussion
17:53:19 <kmc> one concern is, what if you compile a library and also load it via the bytecode interpreter
17:53:24 <kmc> now you have "two copies" of the library
17:53:32 <kmc> do you have two copies of each top-level IORef
17:54:06 <shirt> kmc: what happens now when you use the global IORef hack?
17:54:20 <kmc> i think two copies
17:54:24 <kmc> only two, if you're lucky ;)
17:54:27 <shirt> so there's your answer :)
17:54:34 <kmc> shrug
17:54:34 <shirt> heh
17:54:56 <kmc> if you're adding a new feature with intentional semantics, you want to think about them
17:55:02 <shirt> yep
17:55:04 <kmc> not just mimic whatever was happening before by accident
17:55:48 <kmc> anyway like I said there will also be some opposition from people who are out of touch with the real world
17:55:53 <kmc> and think that global state is never necessary
17:56:51 <shirt> the core ghc devs don't appear to be like that
17:56:52 <kmc> and people who think making a feature more error-prone will make people not use it
17:56:55 <kmc> yeah i agree
17:57:02 <kmc> they seem like pretty pragmatic people
17:57:13 <kmc> which you have to be, if you're working on a big production compiler and runtime
17:57:47 <Axman6> wouldn't the global state be much easier to implement in a C wrapper anyway? global variables++
17:57:51 <Axman6> >_>
17:57:54 <kmc> try it
17:58:15 <kmc> i mean that's what I did after I ran into that GHC bug
17:58:19 <Axman6> yeah I'd rather not. I'm sure it;s harder than I'd expect
17:58:21 <kmc> http://mainisusuallyafunction.blogspot.com/2011/11/global-locking-through-stableptr.html
17:59:02 <kmc> it's not really that bad, but definitely non-trivial
17:59:11 <kmc> much harder than writing "x <- newMVarACIO ()"
17:59:51 <jmcarthur> MY HAIR HURTS
17:59:53 <jmcarthur> shoot
17:59:53 <Axman6> preflex: zdec hs_globalzmlock_get_global
17:59:54 <preflex>  hs_global-lock_get_global
17:59:56 <jmcarthur> wrong channel
18:00:02 <jmcarthur> lol. sorry guys
18:00:10 <Axman6> #hairdressing?
18:00:45 <kmc> perhaps global variables in Haskell are never /necessary/, but they may sometimes be the lesser evil
18:01:00 <kmc> hidden global locking that Just Works vs. making users do their own locking
18:01:08 <kmc> vs. implementing locking in C
18:01:40 <kmc> there are use cases for global state beyond FFI, though
18:01:49 <jmcarthur> i meant that to be a random comment in a channel full of IRL friends. instead i said it here, with the effect that it seemed even more random
18:01:51 <irene-knapp> um, but what if your users want to coalesce several of your locking calls into one lock
18:01:54 <Axman6> i keep thinking "can't you just make an interface where you have to create a context at startup and use that in all the calls to the library?" but then i remember that there's then nothing stopping you making calls to the context creation function multiple times
18:02:06 <kmc> Axman6, yep, that's the problem with repa-devil
18:02:16 <Axman6> :(
18:02:17 <kmc> also it just uglifies the code
18:02:31 <kmc> to have to use some custom monad rather than IO
18:02:38 <kmc> just because of an implementation detail of the C library
18:03:30 <kmc> irene-knapp, for performance?
18:03:31 <jmcarthur> devil intentionally made the same bad design choices as opengl :(
18:03:39 <irene-knapp> kmc: yes
18:03:52 <jmcarthur> well, actually, i shouldn't be so hard on opengl here
18:03:56 <irene-knapp> locks can actually be quite expensive
18:04:14 <irene-knapp> (hundreds of milliseconds)
18:04:30 <irene-knapp> it does depend of course
18:04:50 <mikeplus64> http://hpaste.org/56493 excluding the redundant do (oops) is there anything "wrong" with this code? It works fine, just wondering if there are better ways to draw pixels 'n stuff
18:05:02 <kmc> irene-knapp, hmm, if i had a library where that was a concern, i would provide several interfaces
18:05:07 <irene-knapp> fair, I guess
18:05:17 <kmc> one with implicit locking that just works
18:05:19 * irene-knapp nods
18:05:29 <kmc> another with maybe a custom monad, or just an unsafe interface
18:05:36 <irene-knapp> I would love to see a generalization of the STM trick
18:05:42 <irene-knapp> for generalized types of user-implemented locking
18:05:52 <kmc> which trick is that
18:06:30 <irene-knapp> it's my understanding that STM basically ensures transactional semantics by preprocessing the action it runs to put the lock-acquisitions and releases in the order they need to be in
18:06:40 <irene-knapp> I haven't read the papers so I'm not sure of that
18:06:44 <jmcarthur> that's not how ghc's implementation works
18:06:45 <irene-knapp> it just seems like the only way it could work
18:06:46 <irene-knapp> oh
18:06:49 <irene-knapp> heh
18:07:04 <irene-knapp> jmcarthur: how does it? :)
18:07:10 <kmc> irene-knapp, do you have an example where a GHC MVar lock takes anywhere near 100 milliseconds?
18:07:19 <kmc> irene-knapp, on my system, it takes roughly one millionth that long
18:07:20 <irene-knapp> no, I admit I do not :)
18:07:20 <jmcarthur> it just performs the actions optimistically and keeps a log, then at commit time it verifies that no conflicts occurred
18:07:24 <kmc> ok
18:07:32 <irene-knapp> jmcarthur: oh!  hmmmm okay
18:07:34 <kmc> so it's FUD then ;P
18:07:36 <Axman6> irene-knapp: mvars are _damn_ fast
18:07:52 <jmcarthur> irene-knapp: the result is sometimes much faster than locks, actually
18:07:56 <Axman6> there's a good reason my thread-ring entry in the language shootout is the fastest of all languages
18:07:56 <irene-knapp> interesting, yes
18:07:59 <kmc> some libraries will have very short calls, where 100 nanoseconds for a lock would matter
18:08:07 <kmc> but i think most don't
18:08:10 <irene-knapp> fair
18:08:22 <kmc> for example DevIL where a single call is "write this image to disk"
18:08:28 <irene-knapp> right
18:08:44 <kmc> it's on the same order as caring about "foreign import unsafe"
18:08:57 <Axman6> mikeplus64: i'd use toInteger rather than fromIntegral (x + y) :: Integer
18:09:50 <mikeplus64> Axman6: ok
18:10:08 <Axman6> :t toInteger
18:10:08 <lambdabot> forall a. (Integral a) => a -> Integer
18:11:13 <mikeplus64> that makes it look a bit less like line noise :)
18:11:15 <jmcarthur> MVars are pretty quick. quick enough that most people don't even realize that unsafePerformIO uses one
18:11:23 <kmc> it doesn't actually
18:11:26 <kmc> i thought so too
18:11:30 <kmc> but then i went source diving
18:11:38 <jmcarthur> it uses the primitives, doesn't it?
18:12:04 <kmc> it invokes this primitive: http://hackage.haskell.org/trac/ghc/browser/rts/PrimOps.cmm?rev=96c80d34163fd422cbc18f4532b7556212a554b8#L1904
18:12:38 <kmc> which calls the RTS function threadPaused()
18:13:15 <kmc> which (inter alia) blackholes all of the thunks being evaluated by the current thread
18:15:12 <kmc> this is some tricky shit
18:15:55 <kmc> GHC RTS is as complex as the core of an operating system (ignoring drivers, filesystem, etc)
18:25:21 <jmcarthur> kmc: i see
18:25:37 <jmcarthur> i could have sworn i had seen otherwise
18:38:19 <blbrown_win3> or
18:38:30 <Axman6> @yarr
18:38:31 <lambdabot> Prepare to be boarded!
18:38:31 <mikeplus64> > [ x | x <- [0..]; x < 5 ]
18:38:32 <lambdabot>   <no location info>: parse error on input `;'
18:38:38 <mikeplus64> > [ x | x <- [0..], x < 5 ]
18:38:42 <lambdabot>   mueval-core: Time limit exceeded
18:38:47 <mikeplus64> wut :(
18:39:04 <Axman6> that's equivalent to filter (< 5) [0..]
18:39:18 <mikeplus64> I know, I'm just wondering why it doesn't work
18:39:39 <Axman6> > take 6 [x | x <- [0..], x < 5]
18:39:40 <mikeplus64> in ghci it shows [0,1,2,3,4 then seemingly freezes
18:39:42 <lambdabot>   mueval-core: Time limit exceeded
18:39:56 <shachaf> mikeplus64: It does work.
18:39:58 <Axman6> of course it freezes, what else can it do?
18:40:06 <Axman6> > take 5 [x | x <- [0..], x < 5]
18:40:07 <lambdabot>   [0,1,2,3,4]
18:40:49 <mikeplus64> I thought it would just stop trying to evaluate anything, and return the list
18:41:18 <Axman6> but it can't, it's still looking in the rest of the list for more elements that are < 5
18:41:24 <Axman6> it doesn't know there aren't any
18:41:32 <mikeplus64> oh, that makes sense
18:41:46 <kmc> this is the difference between filter and takeWhile
18:42:27 <Axman6> filter :find all the things, takeWhile: fine as many as you can until you find something that doesn't match
18:42:32 <Axman6> d*
18:44:55 <petergr> Hi, I have been working with the binary package recently and I am trying to get binary-generic to work. Any1 with experience?
18:45:02 <The_Journey> hi, I have a program that takes in couple of command line arguments and writes to couple of files, how can I write a Haskell program that will call this program several times with different arguments and have them run in parallel and waits until they all finish?
18:47:42 <DanBurton> petergr: I don't have experience, but I've seen several binary-related questions on StackOverflow; if you don't get a prompt answer here, try there.
18:47:48 <Axman6> The_Journey: use Haskell threads (forkIO) and System.Process (i think)
18:48:17 <petergr> @The_Journey: https://github.com/jepst/CloudHaskell may interest you if doing something heavyweight
18:48:17 <lambdabot> Unknown command, try @list
18:48:22 <kmc> The_Journey, i wrote this library to make haskell threads a little easier to use: http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html
18:48:36 <kmc> you could use 'parMapIO_' or 'spawn'
18:48:48 <The_Journey> ok, thank you very much
18:49:14 <kmc> make sure you build with ghc -threaded
18:49:36 <DanBurton> We should get something like that spawn package into Haskell Prime base libraries.
18:49:49 <kmc> why
18:50:04 <DanBurton> because when most people want to use threads
18:50:05 <petergr> DanBurton: Thanks, I have RTFM'd and Googled quite a lot but can't seem to find what the problem is. I have GHC 7.0.3 - meh, maybe I should just upgrade to 7.2 and use binary-derive
18:50:19 <DanBurton> they usually want to spawn children,
18:50:28 <kmc> DanBurton, that seems more like an argument for putting it into Haskell Platform
18:50:29 <DanBurton> and then wait for the children to finish before dying
18:50:33 <wavewave> The_Journey : probably you may be interested in the package 'orc' , too
18:50:36 <kmc> and not an argument for putting it in the Haskell Report
18:50:46 <kmc> putting things in the standard is pain in the ass
18:50:49 <kmc> and you can /never change them/
18:51:05 <DanBurton> kmc: well, ok then. Shoot for Haskell Platform first. :)
18:51:07 <kmc> you have to pick one way that will make everyone happy forever
18:51:44 <kmc> i mean the problem is not that you have to type 'cabal install spawn' before using this library
18:51:58 <kmc> the problem is that hackage is an unorganized mess of thousands of libraries
18:52:07 <DanBurton> u.u
18:52:24 <kmc> in fact there are like four other 'thread manager' libraries
18:52:37 <kmc> someone else might prefer their functionality over mine
18:52:46 <kmc> it would be madness to enshrine one in the Haskell Report
18:53:24 <kmc> but we need a way to a) find libraries relevant to some task, b) figure out which ones actually work
18:55:13 <DanBurton> Suppose someone wrote a website intended to be a "better" hackage, what would it take to get it hosted on the haskell.org servers?
18:55:27 <kmc> people are already working on Hackage 2.0
18:55:47 <DanBurton> @google hackage 2.0
18:55:50 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/ticket/1587
18:55:50 <lambdabot> Title: #1587 (Hackage 2.0 Web Services) – Haskell.org Google Summer of Code
18:55:54 <kmc> it's massively behind schedule but people are working on it
18:56:13 <kmc> anyway this is a hard problem to solve
18:56:22 <petergr> I'm new to Haskell, but I have noticed a lack of tests on some hackage packages. Wouldn't more comprehensize testing identify package breakage automatically?
18:56:34 <kmc> but it's a much better solution than fighting to get your pet library into Platform or base
18:56:49 <DanBurton> aye
18:57:08 <DanBurton> I just wish there were a middle ground between Platform and Hackage
18:57:09 <kmc> petergr, sure, if the authors of buggy libraries write tests that identify those bugs
18:57:30 <kmc> it's not just a problem of bitrot
18:57:55 <kmc> people upload code that just doesn't work, or has terrible performance, or won't interoperate with other libraries
18:57:57 <Axman6> petergr: the problem with that is that then you usually have to make your package rely on a testing framework
18:58:06 <petergr> kmc: Doesn't everyone agree that a a small, clean and well tested base (and probably Platform to some extent) would help significantly?
18:58:10 <kmc> also a lot of code is undocumented, or has bad docs
18:58:15 <Axman6> and that means different packages will rely on different versions of the same framework
18:58:28 <petergr> kmc: Right! multiple testing frameworks :)
18:58:30 <kmc> you might have docs on every function, but no overview of where to start
18:58:37 <kmc> it will be hard to automatically flag such packages
18:59:04 <kmc> DanBurton, you can compile your own list of favorite libraries
18:59:07 <kmc> and blog about them or something
18:59:13 <dylukes> Are we getting static dependencies btw?
18:59:14 <kmc> i've considered doing this, but haven't got around to it yet
18:59:33 <dylukes> I recall one of Marlow's students or something was doing something with that.
18:59:59 <Philippa> code that has terrible performance or doesn't interoperate is to be expected even in an 'ideal' situation, too. It'd be nice to have some way to mark it out given that making something version 0.1 doesn't, but even so
19:00:11 <kmc> right
19:00:15 <petergr> kmc: hmm.. other language communities seem to have a smaller problem with this. IDK, maybe they are more centralized => more organized, or meybe they are simply larger => more people to help out
19:00:17 <kmc> having that code is better than not having it
19:00:22 <Philippa> (it's quite common that someone had to get the functionality at all for their own use but didn't need to optimise for example: wasting their work is bad)
19:00:38 <dylukes> Other language communities often have vetting of big libraries.
19:00:40 <kmc> but the problem is identifying which libraries have these flaws
19:00:50 <kmc> anyway i'll bbl
19:00:52 <dylukes> The closest to that we have is parsec probably.
19:01:07 <dylukes> Like ,there are libraries in the python community considered "good".
19:01:17 <Philippa> heh. Yes, what happened to parsec was... interesting
19:01:22 <dylukes> Hm?
19:01:41 <Philippa> it was the go-to parsing library before 3.x came about
19:01:52 <Philippa> quite some time before that, even
19:01:58 <dylukes> I don't have any reason to prefer it over Trifecta atm.
19:02:00 <Philippa> but the 3.x transition was a big thing
19:02:18 <Philippa> yeah. But Trifecta is a major new development
19:04:14 <Philippa> petergr: I suspect the proportion of people in the community writing code that's worth putting up on an equivalent platform is bigger
19:04:35 <Philippa> (for haskell, that is)
19:05:14 <ben> how, trifecta has more modules than some libraries have functions
19:05:57 <petergr> Philippa: you mean Haskell has a higher seeder to leecher ratio than other communities?
19:06:15 <Philippa> something like that, yeah
19:06:25 <dylukes> Interesting.
19:06:58 <Philippa> in particular, the burden that puts on the community to handle it is proportionally bigger
19:07:39 <Philippa> doubly so given the distribution of code along the research->cutting edge -> ... -> ancient news continuum
19:09:29 <petergr> Philippa: I see. As you say, it seems to me that Haskell is more spread out between stable & established packages and experiments ones. As a result the user experience is more varied and the quality of the packages more uneaven
19:09:35 <Philippa> dylukes: the main reason I'm not using Trifecta at the moment is insufficient reason to learn the differences. It's definitely a very nice lib/set of libs. But it's also at the stage where the conceptual overhead is research-class still, whereas aside from try parsec is about as tried-and-tested idiomatic haskell as it gets
19:09:55 <dylukes> Trifecta is actually really really similar API wise.
19:10:07 <Philippa> dylukes: mostly, yes. Which is another reason for me not to care!
19:10:07 <dylukes> Biggest difference is more records, less typeclasses.
19:10:16 <dylukes> Right. For me it was more,
19:10:21 <dylukes> I can learn Parsec 3.X, or this.
19:10:25 <dylukes> and this is a lot nicer.
19:10:42 <dylukes> The amount of investment is low, so it was a "I might as well" thing.
19:11:00 <Philippa> *nod*. But we couldn't see Trifecta coming at all
19:12:06 <Philippa> whereas Parsec 3.x was an initial "we really should have this by now, shouldn't we?" push to get something working at all, a bunch of gradual maintenance and another major push to gain sufficient efficiency - and the first bit was the one that had people scared as to whether it could work at all. But that stage of development was, er, politically awkward to say the least
19:12:22 <Philippa> but in a way that's inevitable once a community reaches a certain size
19:12:32 <Philippa> (3.x still needs better docs, though)
19:12:40 <dylukes> On an unrelated note, I have the reading rainbow theme stuck in my head right now.
19:15:06 <dolio> Nobody could have possibly seen trifecta coming.
19:15:12 <dolio> Even its author.
19:15:28 <dolio> Ed just decided to write it over the course of like a week.
19:16:08 <Philippa> that too. But I don't know of any precedents at an appropriate level either - it's one of those things that highlights the 20/20 hindsight rule
19:17:09 <byorgey> dylukes: butterfly in the skyyyyyy
19:17:15 <dylukes> take a look
19:17:17 <dylukes> its in a book
19:17:21 <dylukes> reading raaaaainbooooww
19:17:30 <byorgey> =D
19:18:51 <Philippa> that reminds me, at some stage I still want to abuse its tech for munging lambda calculi instead
19:19:03 <Philippa> (now there's a sign the underlying ideas are abstract, no?)
19:19:07 <dylukes> Hm?
19:20:14 <Philippa> eh, if it doesn't make sense at first glance I'd have to all but write the lib to make it do so, unfortunately. There's a monoid or two involved and I plan to exploit that fact, basically
19:20:55 <blbrown_win3> ok another question, is swtor good?  What about guild wars 2?
19:21:33 <Philippa> #haskell-blah is thataway ->
19:21:59 <djahandarie>                                       #haskell-blah
19:22:02 <tigger> is there a nice way to express the following pattern: construct <$> parseByte <*> parseByte <*> parseByte <*> ... <*> parseByte, where we know how many times parseByte is applied before hand? So something like fold construct 5 parseByte. It would be easy to roll my own, just wondering if tis in the standard library somewhere
19:22:43 <Philippa> tigger: you'd have to use template haskell or some fairly icky typeclass hackery - it's not in the standard library
19:22:58 <Philippa> (it's ickier if you only know the number dynamically, too)
19:22:59 <tigger> Philippa: okay thanks!
19:23:14 <Philippa> "call this parser n times and put it in a list" is another matter though
19:24:03 <Philippa> (if you think about it: the number of times you call parseByte affects the required type of construct)
19:24:05 <tigger> Philippa: yeah, repeatM?, I had to use that, just wondering if I could then apply to the constructor
19:24:33 <dylukes> It just occurred to me,
19:24:37 <tigger> Philippa: yea, it does, I was thinking polymophism would help, since input type is always f (a -> b)
19:24:43 * shachaf ,
19:24:46 <dylukes> someone might find it funny that I eat yogurt with two types of honey
19:24:48 <dylukes> one on either side
19:24:55 <Philippa> dylukes: -blah
19:24:56 <dylukes> I don't know why, it's just how i like eating it.
19:24:56 <tigger> Philippa: I could be mistaken, still figuring out haskell...
19:25:06 <dylukes> Philippa: oh whoops, I thought I was in blah :P
19:25:10 <Philippa> tigger: that's where the typeclass hackery would end up, but in practice it's unpleasant
19:25:58 <dmwit> tigger: (\[a, b, c, d, e] -> construct a b c d e) <$> replicateA 5 parseByte
19:26:07 <dmwit> tigger: Or just write "construct" to take a list in the first place.
19:26:18 <Philippa> dmwit: yeah, I should've shown that or similar still
19:26:38 <dmwit> data D = D (D -> D)
19:26:45 <shachaf> I assumed "construct" was an actual constructor.
19:26:46 <Philippa> it's slightly brittle code in that it's not typesafe in the presence of changes
19:26:56 <dmwit> ...and then write your parser combinators in the untyped lambda calculus.
19:27:07 <tigger> dmwit: gotcha, feels unnatural though, im only dealing with 5 times, so its not too bad to write out
19:27:45 <Philippa> honestly, if it's fixed then it's probably better to manually call 5 times. Especially if those 5 times are doing different things, because then you can name the 5
19:28:08 <shachaf> dmwit: Even in this case, I would still want "construct" to take five arguments if it's a function that takes five arguments.
19:28:19 <shachaf> A list is ill-suited for that, even if its five arguments happen to be of the same type.
19:28:40 <dmwit> unsafeConstruct [...] = construct ...
19:28:55 <dmwit> Then everybody's aware that something fishy is going on.
19:29:02 <shachaf> Sure.
19:29:20 * dmwit must be feeling unusually pragmatic today
19:29:25 <shachaf> unsafeConstruct x = let [...] = unsafeCoerce x in construct ...
19:31:08 <shachaf> dmwit: (In practice I don't think giving unsafeConstruct a global name like that is a good idea, of course. As long as the [...] pattern match is right next to the replicateM 5 ..., at least you can convince yourself that it's not broken.)
19:31:52 <Philippa> I think we may be overkilling the issue now :-)
19:32:04 <Philippa> tigger: got the answer(s) you need?
19:32:35 <tigger> Philippa: yep thx, yeah I don't think unsafe is worth it haha. thanks everyone!
19:38:03 <Philippa> tigger: for what it's worth, it's a more than fair question to have :-) Just the sort of thing that needs an even smarter type system than Haskell's, or a less safe one
19:38:47 <shachaf> Haskell's type system is the perfect mix of useless and stupid.
19:40:41 <dmwit> Haskell's type system is useful enough that you actually notice when it's not useful.
19:42:37 <DanBurton> @remember shachaf Haskell's type system is the perfect mix of useless and stupid.
19:42:37 <lambdabot> Okay.
19:43:36 <shachaf> dmwit: It's not as if you couldn't have more or less this same issue in C's type system.
19:45:24 <dmwit> Yes, you couldn't have this same issue there.
19:45:28 <Philippa> C++ can avoid it for statically-known counts, but the cost is painful
19:45:29 <dmwit> Because nobody would think to ask for such a combinator.
19:45:41 <dmwit> (Higher-order functions? What's that?)
19:46:08 <shachaf> dmwit: C has function pointers and they are used.
19:46:13 <Philippa> limited HOFs are a part of some C styles - the language does have function pointers
19:46:16 <shachaf> (By some people.)
19:46:19 * dmwit nods agreeably
19:46:54 <dmwit> It's definitely a choice that not everybody makes, though.
19:46:57 <Philippa> GHC Haskell can solve this one, even. It's just really painful to do so
19:47:09 <dmwit> I don't think anybody has written any real Haskell code that didn't use a HOF anywhere.
19:47:27 <dmwit> s/anywhere/somewhere/ maybe? not too sure...
19:47:29 <Philippa> pretty much impossible
19:47:45 <Philippa> well, for a "real program" at least
19:47:56 <Philippa> (because all you can do without one is Hello World or similar)
19:48:30 <dmwit> do { x <- getLine; print x } -- oops, you just used a HOF
19:49:06 <Philippa> you could write a painful library, I guess
19:50:53 <lfactor> Hi all, having trouble compiling anything on Ubuntu lucid, cabal complains:
19:50:56 <lfactor> (.text+0x4d14): undefined reference to `rtsTimerSignal'
19:51:15 <lfactor> when i try cabal install cabal
19:51:20 <lfactor> or cabal install xmonad
19:51:33 <lfactor> i also can't recompile my xmonad config.
19:51:42 <dmwit> This sounds bad!
19:51:55 <dmwit> Have you mixed your package manager with a manual installation of GHC?
19:52:15 <lfactor> no, everything is from apt repos
19:52:29 <lfactor> default ones even, unless something was in one of my other PPAs.
19:53:04 <lfactor> after it wouldn't compile my xmonad config i attempted to do the cabal thing, not sure if that led to further problems.
19:53:52 <lfactor> i found a very similar looking bug but no solution: http://osdir.com/ml/ubuntu-bugs/2010-02/msg34905.html
19:54:11 <lfactor> should i just install it all from source?
19:54:37 <dmwit> You shouldn't need to install it from source.
19:54:52 <dmwit> Are you on Ubuntu 10.10? If so, perhaps the repositories are just broken.
19:54:59 <dmwit> See, e.g., http://askubuntu.com/questions/34390/problem-installing-cabal-1-8-0-2
19:55:03 <lfactor> yeah, i'm on 10.10
19:55:09 <lfactor> LTS
19:55:38 <lfactor> i found that link, wasn't sure where to go from that.
19:55:47 <dmwit> You can grab a binary distribution from http://www.haskell.org/ghc/ or use the Haskell Platform from http://hackage.haskell.org/platform/
19:56:35 <sshine_> lfactor, are you having problems with Haskell libraries on Ubuntu?
19:56:42 <lfactor> sshine_, yes.
19:57:03 <lfactor> and sorry to focus on the same thing as everyone else, but it's for Xmonad :)
19:57:44 <sshine_> lfactor, I couldn't make the Ubuntu packages work, so I went with the cabal ones instead and applied --reinstall whenever cabal would think that a package was installed already.
19:58:02 <lfactor> ahh, i can't make cabal work :)
19:58:14 <lfactor> cabal install cabal doesn't work
19:58:20 <dolio> I used to install Haskell myself back on ubuntu, for what it's worth. But that was a bit ago.
19:58:27 <dolio> You shouldn't have to cabal install cabal.
19:58:37 <dolio> In most cases.
19:58:41 <sshine_> I didn't cabal install cabal either.
19:58:42 <dmwit> lfactor: Follow the recommendation of the accepted answer on askubuntu: install a newer GHC yourself.
19:58:51 <lfactor> ok
19:58:52 <dmwit> It really isn't hard; 5 minutes tops.
19:59:03 <lfactor> via haskell-platform?
19:59:09 <dmwit> If you like.
19:59:17 <lfactor> no difference?
19:59:17 <dmwit> The Platform comes with a bunch of libraries pre-installed.
19:59:21 <lfactor> ahh ok
19:59:41 <sshine_> those who run Xmonad at uni install the platform themselves. a little more manual labor, a lot less hassle.
19:59:57 <dolio> It also comes with cabal-install, I think, which is a pain to install yourself if you don't have it already.
20:00:00 <dolio> Although I suppose you do.
20:00:10 <The_Journey> hi, how can I test if a filePath exists and if it doesn't I create one?
20:00:19 <lfactor> any version of GHC is ok?
20:00:28 <dmwit> It's an installation, though I'm not sure I would call it a pain: tar xf + ./bootstrap.sh doesn't seem that painful.
20:00:48 <lfactor> sounds fine to me
20:00:53 <dmwit> lfactor: You should look at anything older than GHC7 with suspicious squinty-eyes.
20:01:04 <tgeeky> 7.4 or bust!
20:01:08 <tgeeky> (just kidding)
20:01:10 <dolio> @hoogle doesFileExist
20:01:11 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
20:01:28 <The_Journey> ok thank you
20:01:40 <dmwit> The_Journey: This sounds like an XY problem.
20:01:49 <lfactor> dmwit, it'll just grab 7.2.2 then
20:02:00 <lfactor> thanks tons guys :) will report back.
20:02:39 <dmwit> ?hoogle createDirectoryIfMissing
20:02:39 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
20:03:01 <dmwit> The_Journey: If you're talking about a file, the right answer is "just open the file with a mode that creates it when it doesn't exist".
20:03:25 <dmwit> Using "doesFileExist" before doing something to a file is just asking for trouble.
20:10:26 <The_Journey> dmwit: thank you
21:00:54 <gestur> clear
21:02:59 <lfactor> dmwit, thanks for the help, installed and working well. Configured a custom xmonad setup and one step closer to computing paradise :)
21:03:12 <dmwit> cheers =)
21:20:15 <mewalz> ly <- modify f
21:33:22 <mzero> is there a way to create a monad not based on IO that can have exceptions?
21:35:17 <mewalz> there is the error functions
21:35:31 <shachaf> mzero: That depends on how what your definition of "exception" is.
21:35:41 <shachaf> Does Maybe count?
21:35:49 <mzero> no
21:35:56 <shachaf> How about Either SomeSortOfExceptionType
21:35:57 <shachaf> ?
21:36:05 <mzero> what I'm doing is creating a monad that acts ilke IO, but isn't
21:36:22 <shachaf> Oh.
21:36:34 <mzero> that is I have a class IOesque with a bunch of file operations defined as methods
21:36:41 <shachaf> Are you after asynchronous exceptions or something?
21:36:44 <mzero> then IO is an instance, and, of course it just works
21:36:58 <mzero> but then i have a "TestIO" type that doesn't actually hit the file system
21:37:00 <shachaf> (Are you sure you need a class?)
21:37:05 <shachaf> (Well, I suppose it depends on what you're doing.)
21:37:15 <mzero> that is all well and good, but some file operations in IO
21:37:24 <mzero> are defined with interfaces that throw on recoverable errors
21:37:32 <mzero> and I need to emulated that in IOesque
21:37:33 <shachaf> Anyway, something Either-style seems reasonable to me?
21:37:46 <mzero> but that changes the interface to all the file operations
21:38:00 <shachaf> Why?
21:38:04 <shachaf> Make it part of TestIO.
21:38:06 <mzero> for example    createDirectory
21:38:16 <mzero> createDirectory :: FilePath -> IO ()
21:38:21 <mzero> it fails by throwing
21:38:26 <shachaf> Right.
21:38:34 <shachaf> createDirctory :: FilePath -> TestIO ()
21:39:05 <mzero> and where / how do I handle the implied exception on various failures?
21:39:33 <shachaf> You'd have to add primitives to TestIO for it.
21:39:37 <shachaf> Just like IO has primitives.
21:40:14 <mzero> so build all the try / except machinery into TestIO, and then re-work bind so that on exceptions it jumps to the except continuation stack...
21:40:17 <mzero> oy
21:40:44 <tigger> im using attoparsec, and am having problems some problems. Is there any easy way to debug inside a function of type :: Parser a, possibly get >>= error . printBytestring? trying to print the bytestring in the middle of a do block, where printBytestring :: ByteString -> String
21:41:01 <shachaf> mzero: Well, I mean, this is pretty much Either, isn't it?
21:41:07 <shachaf> You could probably use EitherT or something.
21:41:45 <mzero> sure- but the client code needs to look like you write it in IO: with try blocks
21:41:55 <mzero> they don't see Either for the result of createDirectory
21:42:03 <shachaf> Right.
21:42:15 <shachaf> That's how types work. :-)
21:43:22 <tigger> hmm, yeah I could use eithers, i was just using error, since it would break the code at that point in time, eventually I'll remove that but I just needed a quick and dirty test. I'll go with either, then.
21:43:37 <shachaf> tigger: The Either conversation was around before you joined.
21:43:50 <mzero> like they are going to write      (getDirectoryContetns fp `catch` (\_ -> return []))
21:43:52 <tigger> shachaf: sorry about that
21:44:22 <mzero> I was hoping to not have to write the machinery of catch myself for TestIO - that I could just use something that would do that...
21:44:23 <shachaf> mzero: Right, that's what I meant.
21:44:27 <shachaf> Oh.
21:45:14 <shachaf> I don't imagine that it's all *that* complicated.
21:45:52 <shachaf> class Monad m => MonadError e m | m -> e where throwError :: e -> m a; catchError :: m a -> (e -> m a) -> m a
21:46:10 <shachaf> newtype ErrorT e m a = ErrorT {runErrorT :: m (Either e a)}
21:46:16 <shachaf> instance (Monad m, Error e) => Monad (ErrorT e m)
21:46:21 <shachaf> Looks like ErrorT does what you want, maybe?
21:47:33 <mzero> aha - so you're right
21:47:38 <mzero> it does look about rightish
22:07:29 <saiko-chriskun> kind of afraid to ask hahah but does anyone have any quick opinions on comparisons between the three major haskell web frameworks out there? I've done plenty of googling but most of the info seems to be on yesod and snap and not many seem to compare happstack with 'em
22:07:44 <shachaf> saiko-chriskun: Maybe #haskell-web would know.
22:07:58 <saiko-chriskun> oh there's a #haskell-web? ok
22:09:28 <saiko-chriskun> hm seems pretty dead in there
22:09:29 <saiko-chriskun> hehe
22:10:02 <shachaf> There's a lesson in that, I'm sure.
22:10:09 <saiko-chriskun> hah
22:26:30 <yitz> saiko-chriskun: they're all activiely developed, and they're all designed to be modular and share components with each other
22:27:22 <saiko-chriskun> yeah I got that
22:27:51 <saiko-chriskun> I guess I just gotta try 'em :P
22:28:10 <yitz> saiko-chriskun: yeah. try writing something simple in all three and see how they feel
22:28:33 <yitz> saiko-chriskun: then blog it, and the next person will have more luck when they google like you did :)
22:28:37 <saiko-chriskun> :)
22:52:20 <wvoq> hi, could anyone help me understand why the ghc -prof flag causes an "Implicit import declaration: could not find module `Prelude`" error?
22:53:10 <ivanm> wvoq: maybe your GHC isn't built with profiling enabled?
22:55:23 <wvoq> ivanm: thanks, I'll check that
22:55:32 <wvoq> ps sourcegraph is pretty sweet
22:55:49 <ivanm> thanks
22:55:54 <ivanm> I really need to update that at some point
22:57:13 <wvoq> if you're looking for suggestions, my only complaint is that it handles the absence of graphviz rather cryptically
22:57:45 <wvoq> otherwise, it's very helpful
23:06:02 <wvoq> ivanm: do you know what's the easiest way to check whether profiling is enabled in the build?  Google and the ghc manual aren't helping much.
23:06:52 <ivanm> which OS?
23:07:00 <wvoq> linux
23:07:16 <wvoq> ubuntu, in particular
23:07:34 <ivanm> wvoq: check synaptics (or whatever it's called) for ghc-prof or something
23:08:09 <ivanm> but oen way of quickly checking that *might* work is to see if there are *.p_hi files in /usr/lib/ghc-<version>/base-<base-version>/
23:08:31 <wvoq> well there we go
23:08:36 <wvoq> ghc-prof not installed
23:08:46 <ivanm> that might help ;-)
23:08:47 <wvoq> thanks a lot for the tip
23:08:57 <ivanm> np
23:08:57 <tigger> I have 5 bytes in network byte order, stored in a strict bytestring. I need to convert them into an integer, my machine is little endian. Is there a nice way to do this? I'm looking at Data.Binary, but it seems to do everything in big endianness, unless I'm mistaken. any help is appreciated.
23:09:25 <mauke> network byte order is big endian
23:09:30 <tigger> yes
23:10:22 <ivanm> is there any way (rather than via conversion to ByteString) to have binary/cereal and blaze-builder inter-operate?
23:10:25 <tigger> but, i need to convert it to my systems byte order, so I can go about bit shifting and or'ing bits, but I was hoping there was a better way. of course this wouldn't be portable either
23:10:56 <mauke> if you want to do arithmetic operations, you don't want any byte order
23:10:58 <mauke> you want a number
23:13:32 <tigger> mauke: yes, I tried to use decode, and convert the bytestring to an integer, from data.binary, but it complains about having not enough bytes
23:16:26 <Sgeo> What does the MonadPlus instance of IO do?
23:17:25 <shachaf> @src IO mplus
23:17:25 <lambdabot> m `mplus` n = m `catch` \_ -> n
23:18:32 <frerich> If there's one reason why buying LYAH is a good idea, it's because it is the first time I see monads explained in terms of applicatiev functors (which in turn are explained in terms of functors). First time I see this 'bottom-up' approach instead of top-down.
23:18:43 <Sgeo> For that matter, where is the instance
23:21:08 <shachaf> Sgeo: I could look it up, but I don't imagine I'd be much better at it than you are. :-)
23:24:24 <tigger> if I have a word in big endian format, is there a simple function which converts it to host order, of type, :: Word -> Word?
23:29:00 <dmwit> I don't even think you can determine what host order is without involving some IO.
23:29:04 <dmwit> So, probably no.
23:29:17 <mauke> you should never have a word in some byte format
23:29:51 <dmwit> Wow, never?
23:29:57 <mauke> yes
23:30:09 <dmwit> Not even to write to a file or something?
23:30:17 <mauke> yes
23:30:25 <dmwit> Oh, you're objecting to the return type Word, then?
23:30:31 <mauke> you can't write numbers to files anyway
23:30:32 <dmwit> You'd prefer (Byte, Byte, Byte, Byte) or something?
23:30:46 <mauke> return type of what?
23:31:00 <dmwit> hypotheticalConvertWordOrder
23:31:07 <mauke> that function shouldn't exist
23:31:21 <dmwit> hmph
23:31:37 <dmwit> What if you have a binary format that's also read/written by a C program?
23:32:09 <mauke> what's the problem with that?
23:32:46 <dmwit> Can't you ("accidentally") send a pointer to an integer to the file reading/writing functions in C?
23:33:06 <mauke> depends
23:33:21 <mauke> but sure, you can write C's internal serialization formats to disk
23:33:37 <mauke> but then I'd argue you don't have a "binary format"
23:33:58 <dmwit> Call it whatever you like.
23:34:49 * BMeph will call it 'George'...
23:36:57 <dmwit> aaaaaanyway
23:37:23 <dmwit> I don't think there's any pre-rolled function for it.
23:37:38 <mauke> "it" is ill-defined
23:37:55 <dmwit> It shouldn't be hard to write if you know the two endian-ness-es that you're converting between.
23:38:04 <mauke> also I wish perl had better currying; it would be useful in parsing this binary format
23:44:38 <ion> kqr: λ> (putStrLn . unwords) [(Data.Text.unpack . Data.Text.toUpper . Data.Text.pack) "ﬃ,ß", map Data.Char.toUpper "ﬃ,ß", (Data.Text.unpack . Data.Text.toLower . Data.Text.pack) "İ", map Data.Char.toLower "İ"]
23:44:45 <ion> FFI,SS ﬃ,ß i̇ i
23:48:57 <mephjones> .
