00:04:44 <mmaruseacph2> if I'll privately msg lambdabot with a todo will it show in other people's todo's?
00:05:13 <shachaf> You can pretty much ignore the "todo" feature.
00:05:20 <shachaf> No one uses it, like most of lambdabot.
00:06:55 <tikhonjelvis> As far as I can tell, most people just use it like GHCi.
00:07:22 <merijn> Well, ghci doesn't have things like @pl, afaik
00:07:30 <tikhonjelvis> Oh, I guess that counts too.
00:07:46 <merijn> Or @djinn
00:07:56 <tikhonjelvis> I have never seen people use that. What does it do?
00:08:13 <merijn> @djinn a -> a
00:08:13 <lambdabot> f a = a
00:08:14 <shachaf> Makes a function from a type.
00:08:18 <tikhonjelvis> oh
00:08:22 <tikhonjelvis> I remember reading about that
00:08:25 <shachaf> You can figure out wht things do with /msg lambdabot @help
00:08:33 <merijn> @djinn (a -> b) -> [a] -> [b]
00:08:33 <lambdabot> Error: Undefined type []
00:08:37 <merijn> awww
00:08:58 <tikhonjelvis> @djinn a -> b -> c
00:08:58 <lambdabot> -- f cannot be realized.
00:09:05 <tikhonjelvis> @djinn (a, b) -> a
00:09:05 <lambdabot> f (a, _) = a
00:09:22 <tikhonjelvis> @djinn (a, b) -> (b, a)
00:09:22 <lambdabot> f (a, b) = (b, a)
00:09:31 <startling> @djinn a -> b -> (a, b)
00:09:31 <lambdabot> f a b = (a, b)
00:09:38 <shachaf> Lists aren't very interesting from @djinn's perspective, because [] satisfies every list type.
00:10:11 <startling> @djinn (a -> b -> c) -> (b -> a -> c)
00:10:11 <lambdabot> f a b c = a c b
00:11:08 <mmaruseacph2> @djinn (a -> b -> c) -> (c -> a -> b)
00:11:08 <lambdabot> -- f cannot be realized.
00:11:09 <tikhonjelvis> @djinn (a -> b) -> (a, a) -> (b, b)
00:11:09 <lambdabot> f a (b, _) = (a b, a b)
00:11:11 <mmaruseacph2> cool
00:11:19 <mmaruseacph2> I had that on an exam yesterday
00:11:35 <tikhonjelvis> Ooh, you have a class teaching Haskell?
00:11:45 <mmaruseacph2> actually two
00:11:52 <tikhonjelvis> I'm stuck using Python :(
00:11:54 <mmaruseacph2> in the second year at university
00:11:59 <tikhonjelvis> yeah, same for me
00:12:01 <mmaruseacph2> there is a course called programming paradigms
00:12:02 <merijn> tikhonjelvis: Spoiled brat >.>
00:12:11 <merijn> I had to do Java
00:12:27 <tikhonjelvis> merijn: Python is the dynamically typed, spiritual successor to Java.
00:12:29 <mmaruseacph2> you start with Scheme for 6 weeks, then Haskell 3 weeks, CLIPS 3 weeks and one week of Prolog
00:12:35 <mmaruseacph2> now I'm a TA at that
00:12:37 <tikhonjelvis> Also, I had to do Java too.
00:12:50 <merijn> tikhonjelvis: Python is a spiritual successor to Java?
00:12:50 <mmaruseacph2> and in the first year of masters you have a type systems and functional programming course
00:12:55 <merijn> On what planet is this?
00:12:55 <mmaruseacph2> which is also done in haskell
00:13:05 <tikhonjelvis> It's annoying, imperative and has class-based OO.
00:13:06 <rostayob> python predates Java...
00:13:14 <merijn> rostayob: Well, yes. That too
00:13:43 <tikhonjelvis> Over summer, I worked with a bunch of people who liked Java; now I work with a bunch of people who like Python.
00:13:57 <tikhonjelvis> So from my perspective, it's a successor.
00:14:03 <rostayob> mmaruseacph2: in our uni the first language they teach you is haskell, and you have undergrad type systems courses
00:14:12 <merijn> And you hang out with people who like haskell
00:14:20 <rostayob> tikhonjelvis: that doesn't make any sense.
00:14:29 <tikhonjelvis> We started with Scheme, which was awesome but then went to Java which wasn't.
00:14:36 <merijn> I fail to see how the latter category is different from people who like python and java
00:15:02 <rostayob> *we have undergrad type systems courses
00:15:02 <mmaruseacph2> rostayob: what uni?
00:15:23 <tikhonjelvis> merijn: Which category?
00:15:33 <rostayob> mmaruseacph2: imperial college
00:15:34 <mmaruseacph2> we also have several courses which allows homeworks to be done in haskell
00:15:35 <merijn> tikhonjelvis: People who like haskell (i.e. this channel)
00:15:39 <mmaruseacph2> and that's cool
00:15:42 <mmaruseacph2> rostayob: London?
00:15:45 <rostayob> mmaruseacph2: London
00:15:56 <mmaruseacph2> that's cool :)
00:16:05 <rostayob> it's not all that cool... we have a mandatory "software engineering methodologies" course :)
00:16:13 <merijn> rostayob: I feel your pain
00:16:14 <mmaruseacph2> we have two of them
00:16:24 <mmaruseacph2> same course but with different names
00:16:28 <mmaruseacph2> and I hate them
00:16:28 <rostayob> and the "professional issues" course
00:16:32 <rostayob> those suck
00:16:36 <tikhonjelvis> We have a mandatory computer ethics course :(
00:16:44 <merijn> rostayob: I used to be a functional programmer like you, but then I took an UML diagram to the knee >.>
00:16:55 <mmaruseacph2> I had a teacher there which said that "git is not used in the real world so we'll teach you SVN"
00:17:10 <Botje> merijn: ooh. painful. lots of pointy bits.
00:17:16 <mmaruseacph2> merijn: this quote should be remembered
00:17:29 <rostayob> mmaruseacph2: in my uni they're crazy about Agile now, which is even worse
00:17:36 <merijn> @remember merijn rostayob: I used to be a functional programmer like you, but then I took an UML diagram to the knee >.>
00:17:36 <lambdabot> Good to know.
00:17:51 <rostayob> that methodologies course was all on Agile
00:18:17 <tikhonjelvis> We have a course like that (agile, TDD...etc) but it's optional.
00:18:41 <tikhonjelvis> Actually, *all* of the upper-division courses are optional.
00:19:01 <eejaydubya> i'm starting to feel a little disappointed in my education
00:19:19 <merijn> eejaydubya: #haskell does that to you :p
00:19:21 <eejaydubya> as far as i can tell they advocate the black box methodology and java for future success
00:19:24 <tikhonjelvis> Eh, I'm enjoying myself. Despite the endless Python.
00:19:43 <flux> mmaruseacph2, no reason why they couldn't teach you both
00:19:54 <flux> well, unless they had one lecture to serve that all on
00:20:22 <mmaruseacph2> flux: they had only one lecture for them
00:20:35 <mmaruseacph2> but we teach students git in an extracurricular course
00:20:43 <mmaruseacph2> http://cdl.rosedu.org/2012/english
00:21:07 <mmaruseacph2> unfortunately, no student knows enough haskell when he/she takes the course
00:21:16 <flux> in any case, I'm pretty sure svn was also what was required at my uni, because it was the system they used on some courses to accept submissions
00:21:19 <mmaruseacph2> so there cannot be haskell projects, no matter how much I want to do this
00:21:29 <flux> it was often the student's only backup of the source, so it was good for that
00:22:10 <tikhonjelvis> None of the professors here can agree on what to use: I know of one who mandates git, one who mandates SVN, a bunch who don't care and one who mandates hg.
00:23:25 <c_wraith> make them all cry: use visual sourcesafe
00:23:36 <tkahn6> hey quick question: what is the name for functions like maybe and either?
00:23:45 <tikhonjelvis> They're types
00:23:48 <c_wraith> eliminators, destructors, etc
00:23:53 <merijn> tikhonjelvis: maybe is a function too
00:23:56 <merijn> :t maybe
00:23:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:23:59 <tikhonjelvis> Yeah, I realized that.
00:24:09 <tikhonjelvis> Just after responds :(
00:24:13 <tkahn6> ah ok thanks c_wraith
00:24:13 <tikhonjelvis> responding**
00:24:22 <tikhonjelvis> :t either
00:24:22 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:24:45 <quicksilver> well the one who mandates SVN needs to do some learning
00:24:54 <tikhonjelvis> He's also the one who likes Java.
00:24:55 <shachaf> tkahn6: Folds.
00:25:20 <merijn> quicksilver: He probably doesn't want to, that's the problem
00:25:53 <merijn> quicksilver: My supervisor opposed a move from SVN to hg because "SVN has always worked fine, we don't have problems with it and I don't want to learn new tools every time"
00:26:14 <shachaf> merijn: That is a reasonable objection.
00:26:26 <merijn> shachaf: Well, no. Because we did have problems with it
00:26:41 <merijn> i.e. merging is a freaking pain
00:26:49 <tikhonjelvis> Besides, there really are some advantages to a distributed system.
00:26:54 <shachaf> merijn: Well then, that seems like the obvious response.
00:27:40 <tikhonjelvis> Does anybody outside of the Haskell world use Darcs?
00:28:09 <alexbobp> tikhonjelvis: I'm using darcs for java code, like a heathen
00:28:12 <alexbobp> I just really like darcs
00:28:16 <srhb> It's probably rare.
00:28:19 <alexbobp> (I really like haskell too, but I'm not good at it)
00:28:35 <merijn> shachaf: To which he replies "but you shouldn't branch!", then you get into the discussion that whether you should or not is moot, since it happens anyway. In the end we just moved all our work into hg and didn't mention it until we were in a position that migrating to hg was easier than exporting back to svn :p
00:28:57 <tikhonjelvis> alexbobp: Any reason to prefer darcs over git/hg?
00:29:19 <alexbobp> tikhonjelvis: I like it's behavior of showing you the individual changes and prompting you whether to include each one in your patch
00:29:26 <tikhonjelvis> ah
00:29:30 <tikhonjelvis> that does sound useful
00:29:36 <flamingspinach> git does that too - git commit -p
00:29:39 <alexbobp> but in theory that can all be done for any rcm
00:29:41 <alexbobp> ah, okay
00:29:43 <flamingspinach> so does hg, with the record extension
00:29:48 <alexbobp> well there you go then
00:29:54 <alexbobp> I knew it was possible, didn't know if it was already implemented
00:30:00 <flux> darcs' main advantage is its simplicity
00:30:02 <tikhonjelvis> I think I'll be lazy and stick to git then :)
00:30:04 <alexbobp> yeah, that
00:30:12 <alexbobp> darcs is just easier to read a man page for and then actually use
00:30:16 <flux> it doesn't even have branches. to have branches, you make a copy of the tree.
00:30:17 <flamingspinach> one actual substantive difference between darcs and git/hg is that darcs cares about the orders of patches in certain situations
00:30:20 <merijn> flux: Compared to...?
00:30:30 <flux> merijn, well, everything else has branches, no?
00:30:34 <flamingspinach> lemme see if I can find that post...
00:30:43 <merijn> flux: You wrote that after I asked my question >.>
00:30:43 <shachaf> merijn: My point was that his initial objection was reasonable in itself.
00:30:57 <flux> also darcs' patch view of the world in fascinating
00:31:14 <flux> you don't need to pull/push 'all' between repositories
00:31:25 <flux> instead the default mode of action is to choose which changes you want to push/pull
00:31:36 <flux> that's a bit of work to do in git
00:31:40 <merijn> So it just has anonymous branches (in hg terms)
00:31:48 <merijn> i.e. clones of the repo
00:32:19 <flamingspinach> here https://tahoe-lafs.org/~zooko/badmerge/simple.html
00:33:24 <drbean> If there are 2 modules called Model.hs and, ghc is called with flag -idir1:dir2, will the module in dir1 be used in preference to the one in dir2?
00:33:49 <Blkt> good (late) morning everyone
00:34:23 <flux> merijn, hmm, well a clone of a repo isn't any less/more valuable than the original, you practically make a copy with cp -a.. not sure if I would call then 'anonymous branches', just that every repository is its own branch, just as in git, except in addition each git repo can have many branches
00:34:40 <frerich2> Finally, after about 10 months of lobbying my recent move to run lambdabot on our internal IRC server teased two colleagues to start playing with Haskell.
00:34:43 <flamingspinach> personally I don't think this "bad merge" is such a big deal, but apparently some people feel very strongly about it :)
00:34:46 <tikhonjelvis> Can't an hg repo have many branches like git?
00:34:52 <flux> what I've found darcs useful is for maintaining my ~/.zsh* etc files, it's easy to keep slightly separate versions on many computers
00:34:55 <flamingspinach> tikhonjelvis: with the bookmark extension, yes
00:35:02 * frerich2 should consider writing a 'Lambda Lobbyist' guide
00:35:04 <flux> (..but not that easy that I wouldn't have my ~/.zsh/zshrc.hostname etc files as well)
00:35:05 <merijn> flamingspinach: Even without
00:35:16 <flamingspinach> merijn: yeah but those are not the same as git branches, whereas bookmarks are
00:35:18 <ChristianS> frerich: cool :-)
00:35:19 <merijn> hg has anonymous branches (i.e. clones of the repo) and named branches
00:35:19 <tikhonjelvis> If I'm hosting one remotely (e.g. on Bitbucket), can I add branches there as well?
00:35:30 <flamingspinach> clones of the repo doesn't count lol
00:35:31 <ChristianS> frerich2: cool :-)
00:35:32 <merijn> You can have multiple named branches in a repo
00:35:34 <tikhonjelvis> Yeah, I think I want named branches.
00:35:38 <ChristianS> (how many of you are there, anyway?)
00:35:40 <flamingspinach> and named branches are permanent
00:35:50 <flamingspinach> tikhonjelvis: I don't think you do, if you're coming from git
00:35:52 <tikhonjelvis> ChristianS: of whom?
00:36:01 <ChristianS> frerichs
00:36:18 <frerich2> ChristianS: Sorry, I forgot to log out on the IRC client of the laptop at home.
00:36:18 <tikhonjelvis> flamingspinach: I really just want to push my changes without dealilng with conflicts right now.
00:36:20 <flamingspinach> tikhonjelvis: named branches in hg are recorded in the commits you make to them, unlike branches in git which are just ephemeral refs
00:36:57 <merijn> hg branches are more aimed at long lived branches, rather than feature branches
00:37:09 <flamingspinach> so in hg you can't really get rid of "topic branches" after merging them like you can in git
00:37:10 <tikhonjelvis> ah
00:37:13 <merijn> i.e. having a named stable and experimental branch
00:37:14 <flamingspinach> because they're still there in the history
00:37:26 <ChristianS> frerich2: and i thought you had cloned yourself for increased productivity...
00:37:30 <flamingspinach> whereas bookmarks are basically the same as git branches
00:37:32 * merijn doesn't really consider this a problem
00:37:38 <tikhonjelvis> So what should I do if, say, I want two concurrent implementations of the same feature?
00:37:46 <flamingspinach> also mercurial doesn't care about detached heads, unlike git, because it doesn't garbage collect things
00:37:50 <merijn> tikhonjelvis: Do you intend to keep both?
00:38:05 <tikhonjelvis> At least until I figure out whether mine or my partner's is better.
00:38:19 <flamingspinach> so you could say that hg has always supported git-style branches, just without having a way to assign names to them :)
00:38:43 <merijn> It basically boils down to a culture difference. Most git users seem to think history editing is the neatest thing ever, most hg users seem to think it's a capital crime
00:39:17 <merijn> tikhonjelvis: You can also just push and create multiple remote heads, then keep working from these separate heads
00:39:26 <flamingspinach> much of that stems from the fact that in mercurial you are supposed to eventually sync your repo with everyone else's, and hash out any differences between them eventually
00:39:41 <flamingspinach> whereas in git you are very much encouraged to keep your own private branches which you never push to anyone, and other public branches which you do
00:40:04 <tikhonjelvis> Well, what I would really like to do, is have the Bitbucket repository contain both his version and mine.
00:40:18 <tikhonjelvis> Is that what having multiple heads would do?
00:40:21 <flamingspinach> tikhonjelvis: just use bookmarks, if you already know git
00:40:27 <flamingspinach> they come standard with mercurial 2.0 and higher
00:40:32 <merijn> tikhonjelvis: Actually, maybe #mercurial might be more helpful at helping you come up with a nice workflow?
00:40:33 <tikhonjelvis> ah
00:40:34 <flamingspinach> (or maybe even earlier ones, I don't remember)
00:40:57 <merijn> 1.7 and earlier come with bookmarks too
00:41:05 <flamingspinach> nice :)
00:41:06 <tikhonjelvis> merijn: I'm not going to be using it very much at all, so it's probably not worth the bother.
00:42:17 <flamingspinach> merijn: according to the mercurial wiki, bookmarks became part of mercurial core functionality in 1.8, but it was an extension that came with mercurial for quite some time before that, too
00:42:28 * hackagebot bson-generic 0.0.4 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.4 (PetrPilar)
00:42:41 <merijn> flamingspinach: Ah, yeah. I was thinking of the extension
00:42:56 <merijn> Then again, most big extensions ship with hg by default
00:43:19 <flamingspinach> yeah, I really like the way that mercurial is modular and it's possible to hack extensions to it
00:43:37 <flamingspinach> with git it's much tougher to write any kind of extension, I think
00:44:03 <flamingspinach> but I like git's actual vcs model better in the end, I guess. Ah well.
00:44:26 <tikhonjelvis> I think the git way is just to hack things together with bash scripts :)
00:44:55 <flamingspinach> yeah, bash scripts and highly optimized C haha
00:45:08 <flamingspinach> (if you're implementing anything intensive, that is)
00:45:11 <tikhonjelvis> I meant in place of plugins. But yeah, the core is like that too.
00:45:22 <flamingspinach> yup
00:45:49 <flamingspinach> git commands like filter-branch even accept bash functions as input
01:27:28 * hackagebot zlib-bindings 0.0.3 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.3 (MichaelSnoyman)
01:32:25 <wyfrn> whats going wrong if my program just prints <<loop>> ?
01:32:28 * hackagebot bson-generic 0.0.5 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.5 (PetrPilar)
01:39:55 <ibid> wyfrn: somewhere in your program you've created a (co)recursive definition that dosen't produce a value
01:40:11 <ibid> wyfrn: loop = loop, in the simplest case.  often it's more involved
01:40:32 <shachaf> ibid: Well, that's more general than the meaning of <<loop>>.
01:40:45 <shachaf> <<loop>> means that a thunk depended on itself for evaluation.
01:41:14 <ibid> shachaf: more general is fine.  it answers the question
01:41:33 <ibid> shachaf: now, if there were other ways a <<loop>> can happen, that'd be a problem
01:41:56 <shachaf> "<<loop>> means that your program crashed"
01:45:08 <wyfrn> ibid: thx
01:47:30 <ibid> shachaf: what's your problem?  if i don't give a precise answer i must not answer even if my imprecise answer is helpful?
01:47:53 <shachaf> It seemed to me that that answer was so general as to be unhelpful.
01:48:11 <shachaf> If it helps wyfrn, then never mind, I suppose.
01:48:12 <ibid> oh
01:48:44 <ibid> well, what i said describes what i usually look for myself when i run into <<loop>
01:48:47 <ibid> >
01:49:40 <ibid> (i must say it is the error message i fear and hate the most, in all languages:)
01:50:42 <tikhonjelvis> Not segfaults!?
01:51:07 <ibid> no.  segfaults i can debug easily using core dumps
01:51:16 <NothingMan65> Hey guys/gals. Say I have a function f (x:y:xs) , and I would like to call it recursively with the argument ((y+ x `mod` 10):xs), how would I do that?
01:51:54 <NothingMan65> So essentially drop an element and "modify" the next based on the dropped element.
01:52:01 <shachaf> Just so?
01:52:25 <shachaf> f (x:y:xs) = f ((y+ x `mod` 10):xs)
01:53:29 <NothingMan65> Oh, lol, that's what I had, but I had a different compile error which led me to think that was incorrect!  Lovely shachaf!! Thanks!
01:54:45 <ibid> but you're right.  my phrasing was a bit vague :)  what i was trying to say is that there's a value dependency loop with no nonstrict constructors included in the loop.  but that's easier to explain irl than on irc :)
01:58:24 <hpaste> wyfrn pasted “<<loop>>” at http://hpaste.org/57045
01:58:38 <wyfrn> iam afraid i can't see the problem
01:59:04 <wyfrn> maybe anybody could take a look at my code
01:59:17 <shachaf> wyfrn: The problem might be in "compute"
01:59:30 <shachaf> Given that none of the code you pasted is recursive.
02:01:03 <hpaste> wyfrn annotated “<<loop>>” with “<<loop>> (annotation)” at http://hpaste.org/57045#a57046
02:01:38 <wyfrn> maybe the problem is caused by the iterate filtering
02:02:26 <shachaf> I have no idea what any of this code is supposed to be doing.
02:02:59 <shachaf> It's not especially readable.
02:03:29 <shachaf> I would suggest that you look for recursion somewhere.
02:03:45 <shachaf> Maybe it's in that eeXYZ place.
02:03:49 <wyfrn> it's an implementation of the euclidean algorithm ... if i drop the pretty printing in the main module everything works fine ...
02:04:45 <shachaf> More and more information comes out.
02:04:54 <donri> also you can shorten your args handling: [a,b] <- fmap (map read) getArgs
02:04:58 <shachaf> I suggest you break the code into simple pieces that you understand and test them separately.
02:05:54 <quicksilver> thent he problem is in the pretty printing, surely, wyfrn ?
02:06:10 <quicksilver> so if you think the problem is int he pretty printing you need to show us the source to simpleTable
02:06:59 <hpaste> wyfrn annotated “<<loop>>” with “<<loop>> (annotation) (annotation)” at http://hpaste.org/57045#a57047
02:08:50 <wyfrn> could that line be a problem : "let (s', d, (q, r))  = (take l s, l - length s', d `quotRem` 2)"
02:09:13 <wyfrn> snd result depend on the first and so on
02:09:15 <quicksilver> yes
02:09:29 <quicksilver> I mean it's fine to write code like that
02:09:33 <quicksilver> as long as it makes sense.
02:09:43 <quicksilver> but that *could* be the kind of thing that makes a problem
02:10:00 <shachaf> You might consider using more meaningful variable names.
02:11:12 <ibid> that line does not strike me as the culprit, reading it.  there is no dependency loop, and the tuple is lazy
02:11:19 <mjrosenb> @hoogle Int -> CInt
02:11:19 <lambdabot> Prelude toEnum :: Enum a => Int -> a
02:11:19 <lambdabot> Data.Bits bit :: Bits a => Int -> a
02:11:19 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
02:11:21 <ibid> but i would still define each of the variables separately
02:11:37 <shachaf> ==ibid
02:11:42 <shachaf> mjrosenb: fromIntegral?
02:11:42 <ibid> let s ' = take l s; d = l - length s' ... etc
02:12:12 <shachaf> ibid: Probably "s '" is a little excessive. :-)
02:12:19 <ibid> yeah, typo :)
02:12:21 <mjrosenb> where does CInt live?
02:12:32 <shachaf> mjrosenb: Also note that CInt may be (and is, in many cases) smaller than Int.
02:12:41 <Jafet> @index CInt
02:12:41 <lambdabot> Foreign.C.Types, Foreign.C
02:12:42 <rostayob> mjrosenb: Foreign.C.Types
02:12:51 <shachaf> mjrosenb: For -- yes.
02:13:03 <Jafet> lambdabot beat you all to it.
02:13:31 * mjrosenb is attempting to generate a color for GD, i assume 0-16777215 is the valid range.
02:14:00 <shachaf> Probably, yes. :-) Although I don't think that's guaranteed.
02:14:34 <wyfrn> it works ...
02:15:29 <rostayob> mjrosenb: http://hackage.haskell.org/packages/archive/gd/3000.7.1/doc/html/Graphics-GD.html#g:17
02:16:20 <wyfrn> thx guys
02:16:29 <mjrosenb> rostayob: that makes sense.. had not gotten that far :/
02:16:30 <quicksilver> wyfrn: what was the rpobme?
02:16:32 <quicksilver> problem?
02:17:11 <wyfrn> the let expression in the align function
02:17:28 <wyfrn> [12:01] <quicksilver> I mean it's fine to write code like that
02:17:29 <wyfrn> [12:01] <quicksilver> as long as it makes sense.
02:17:30 <rostayob> mjrosenb: I'd look for functions like those when type Color = CInt :)
02:17:38 <wyfrn> are there anywhere some hints?
02:17:41 <rostayob> (which is what I did now)
02:18:18 <rostayob> mjrosenb: also, http://hackage.haskell.org/packages/archive/gd/3000.7.1/doc/html/src/Graphics-GD.html#rgb
02:18:21 <wyfrn> i didn't expect the let expression to produce an error like that
02:18:31 <rostayob> so it's an RGB color
02:18:51 <rostayob> I would have used a (Word8, Word8, Word8) to represent that
02:22:49 <quicksilver> wyfrn: I don't see a problem with that let
02:23:46 <quicksilver> s' depends only on parameters
02:25:09 <mjrosenb> rostayob: same, perhaps that is more efficent?
02:27:04 <Jafet> sizeof (Word8, Word8, Word8) == 9 * sizeof Word
02:27:07 <quicksilver> then d only depends on s' and then q,r only depend on d
02:41:41 <wyfrn> quicksilver: that's what i thought ... but splitting it in seperate expressions solved there problem ...
02:52:37 * hackagebot hinduce-classifier 0.0.0.1 - Interface and utilities for classifiers  http://hackage.haskell.org/package/hinduce-classifier-0.0.0.1 (RobertHensing)
02:55:54 <mjrosenb> i'm trying to use parMap; the internet says its first argument should be |rnf|, however, this does not seem to be defined.
02:57:03 <Saizan> rnf is a method of NFData iirc
02:57:37 * hackagebot hinduce-classifier-decisiontree 0.0.0.1 - Decision Tree Classifiers for hInduce  http://hackage.haskell.org/package/hinduce-classifier-decisiontree-0.0.0.1 (RobertHensing)
02:57:43 <shachaf> mjrosenb: Are you sure you want to use rnf?
02:58:26 <mjrosenb> nope!
02:58:30 <mjrosenb> what do you recommend?
03:00:11 <mekeor> which typeclass allows to do [Foo .. Bar] ?
03:00:27 <Lemmih> Enum.
03:00:39 <mekeor> Lemmih: thanks :)
03:00:50 <kosmikus> mjrosenb: use rdeepseq, not rnf
03:00:57 <Saizan> mjrosenb: what is the type of the resulting list?
03:01:36 <mjrosenb> (Int, (Int, Int))
03:03:15 <Saizan> rdeepseq (which is the Strategy equivalent of rnf) seem appropriate, though parMap might not because it'll evaluate all the spine of the list and make a spark for each element right from the start
03:03:33 <kosmikus> yes, depends on how long the list is
03:03:54 <Saizan> and that often ends up using too much memory, in which case one of the chunked strategies is more appropriate
03:04:07 <kosmikus> for long lists, a combination with parListChunk or/and parBuffer is usually better
03:04:50 <mjrosenb> what is the difference?
03:05:01 <kosmikus> between what, exactly?
03:05:06 <drbean> Looks like for same-named modules, the present dir gets first shot, unless you pass -i then -idir1,dir2.
03:05:36 <mjrosenb> :t parListChunk
03:05:36 <lambdabot> forall a. Int -> Strategy a -> [a] -> Eval [a]
03:05:51 <mjrosenb> :t parMap
03:05:52 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
03:06:04 <mjrosenb> :t parBuffer
03:06:05 <lambdabot> forall a. Int -> Strategy a -> [a] -> Eval [a]
03:06:13 <mjrosenb> parListChunk is not a strategy
03:06:38 <mjrosenb> @hoogle Eval a -> a
03:06:38 <lambdabot> Control.Parallel.Strategies runEval :: Eval a -> a
03:06:38 <lambdabot> Control.Parallel.Strategies unEval :: Eval a -> a
03:06:38 <lambdabot> Prelude id :: a -> a
03:07:01 <kosmikus> mjrosenb: no, parListChunk is something like parMap
03:07:45 <kosmikus> you can use a normal "map" on the list and then call something like parListChunk 100 rdeepseq on the resulting list
03:08:01 <kosmikus> that'll split the list in chunks of 100 elements and run these chunks in parallel
03:08:06 <kosmikus> rather than each individual computation
03:08:10 <Saizan> well, parListChunk is a strategy morphism :)
03:10:18 <mjrosenb> so if i have [1..1000000] with a chunk of 100, it will run [0..99] in parallel, wait for the whole thing to finish, then start [100..199]?
03:10:30 <Saizan> nope
03:11:23 <Saizan> it'll put all the chunks in parallel at the same time, parBuffer is the one that does more like what you've saidf
03:11:44 <kosmikus> yes, as Saizan said
03:11:53 <kosmikus> it'll run all the chunks of size 100 in parallel
03:12:10 <kosmikus> thereby decreasing the overall number of sparks
03:12:20 <kosmikus> and making the individual computations larger
03:12:24 <kosmikus> both are typically good things
03:12:38 * hackagebot hinduce-examples 0.0.0.1 - Example data for hInduce  http://hackage.haskell.org/package/hinduce-examples-0.0.0.1 (RobertHensing)
03:13:04 <Saizan> though in the case of [1..100000] all the computation is done when creating the spine, so it wouldn't quite help
03:13:55 <mjrosenb> is there a way to get it all the way to an actual value?
03:14:17 <ClaudiusMaximus> tommd: i don't recall avoiding Sqlite "ErrorBusy" in any sensible way - at best i did threadDelay and retry, at worst i did pray it never happens
03:25:11 <mekeor> is there a function which does the same as:   \cond x y -> if cond then x else y -- ?   AFAIK/IIRC, in maths this function is called "sel" (abbreviation for "select").
03:25:42 <merijn> @hoogle Bool -> a -> a -> a
03:25:42 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
03:25:42 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
03:25:42 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
03:26:00 <mekeor> ,m
03:26:01 <ClaudiusMaximus> :t if'
03:26:02 <lambdabot> Not in scope: `if''
03:26:08 <merijn> mekeor: I thought there was one, but its trivial to define anyhoo
03:26:18 <mekeor> merijn: of course
03:26:26 <ClaudiusMaximus> @pl \cond x y -> if x cond then x else y
03:26:27 <lambdabot> join . (if' .) . flip id
03:26:44 <ClaudiusMaximus> oops, typo
03:26:53 <mekeor> what does "typo" mean?
03:27:01 <ClaudiusMaximus> @pl \cond x y -> if cond then x else y -- what i meant
03:27:01 <lambdabot> if'
03:27:18 <ClaudiusMaximus> mekeor: typographical error
03:27:21 <mekeor> ah
03:27:43 <mekeor> @hoogle if'
03:27:43 <lambdabot> No results found
03:27:51 <mekeor> is "if'" syntax??
03:28:02 <mekeor> why does hoogle not find it?
03:28:08 <shachaf> Because it doesn't exist.
03:28:14 <shachaf> It's a function.
03:28:39 <quicksilver> it's a made up function for the purpose of @pl
03:28:43 <mekeor> if it was a function, it would exist.
03:28:47 <quicksilver> although its definition is clear.
03:28:49 <mekeor> ah
03:31:25 <NothingMan65> Hey!  How can I do map something like printf "%3d" to a list?
03:31:26 <mekeor> it'd be great if '\c x y -> if c then x else y' was allowed/able to apply on functions too...
03:31:36 <mekeor> NothingMan65: mapM_
03:32:11 <NothingMan65> Cool, thanks
03:32:23 <mekeor> > map print [1..10] -- doesnt work
03:32:23 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
03:32:30 <mekeor> > mapM_ print [1..10] -- doesnt work
03:32:30 <lambdabot>   <IO ()>
03:32:34 <mekeor> er, does, i mean
03:34:21 <derpladee> yea that would work i think
03:46:47 <andras> hello there, is there anyone here who does graphics with Haskell?  I'm desperately seeking an alternative for Asymptote, which I find is really badly designed... any ideas? diagrams? craftwerk? etc.?
03:47:48 <andras> to clarify: I need the result in a file most of the time, not on-screen (so it seems Gloss doesn't qualify)
03:48:13 <luite> diagrams is ok, but I don't think it does latex typesetting for labels
03:49:55 <Entroacceptor> why don't you use gnuplot or so?
03:51:56 <andras> luite: I'm trying that out as we speak
03:52:31 <andras> Entroacceptor: I need it for more than function and data plotting: charts, block diagrams, etc.
03:53:20 <Guest15036> hi guys
03:53:33 * andras is wondering about diagrams, cairo, and ghci...
03:53:51 * Guest15036 eating
03:54:11 <andras> it looks like diagrams isn't fully documented... can't create output using the cairo backend from within ghci yet
03:54:25 <luite> andras: it should work, but it's a bit tricky to get it running, depending on your platform. but the diagrams guys are working on 'native' backends (no non-haskell dependencies) to make it easier to install
03:55:24 <Guest15036> guysm how to patch kde under freebsd? =)
03:56:39 <andras> luite: so how do I do it for now? all I find in the tutorial is defaultMain, which takes the output file name from command-line arguments, and Diagrams.Backend.Cairo has no documentation on hoogle, so I can't figure out what to use in its place
04:02:38 * hackagebot test-framework 0.4.2.1 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.4.2.1 (MaxBolingbroke)
04:02:40 * hackagebot test-framework-quickcheck 0.2.8 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.2.8 (MaxBolingbroke)
04:02:48 <danr> andras: tikz is great, but there are no haskell bindings afaik
04:02:50 <luite> andras: renderDia Cairo opt diagram, where opt is probably something like    { fileName="test.png", outputFormat=PNG (200,200)} def
04:03:03 <luite> andras: I hope I got that right, had to look it up and didn't test :)
04:04:47 <luite> oh renderDia Cairo (CairoOptions "test.png" (PNG (200,200)) diagram
04:04:49 <luite> should also work
04:06:24 <andras> luite: thanks a lot, just found that in the source myself...
04:06:27 <luite> andras: you can join #diagrams for more help, or if you want to complain about missing features ;)
04:07:02 <andras> danr: i think craftwerk does TikZ, but I haven't tried that yet (it's next in line though)
04:07:42 * hackagebot test-framework-quickcheck2 0.2.11 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.11 (MaxBolingbroke)
04:07:44 * hackagebot ansi-wl-pprint 0.6.4 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.4 (MaxBolingbroke)
04:07:46 * hackagebot test-framework-hunit 0.2.7 - HUnit support for the test-framework package.  http://hackage.haskell.org/package/test-framework-hunit-0.2.7 (MaxBolingbroke)
04:07:48 * hackagebot socks 0.3.0 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.3.0 (VincentHanquez)
04:08:58 <mekeor> andras: diagrams is great! it's so simple and intuitive but despite that still very powerful.
04:12:06 <andras> thanks guys, will play around a bit and maybe join #diagrams later -- not sure if craftwerk is still worth a look given your comments, but I give it a try anyway...
04:12:38 * hackagebot access-time 0.1.0.2 - Cross-platform support for retrieving file access times  http://hackage.haskell.org/package/access-time-0.1.0.2 (MaxBolingbroke)
04:20:05 <shachaf> I like how http://www.haskell.org/haskellwiki/HWN is horribly out of date.
04:20:15 <shachaf> Can someone who isn't me add http://contemplatecode.blogspot.com/ to it, please?
04:20:47 <keep_learning> hello all
04:21:02 <mekeor> keep_learning: hi
04:21:23 <keep_learning> I am trying to profile a program which use dph but getting error /usr/bin/ld: cannot find -lHSdph-prim-interface-0.5.1.1_p
04:22:11 <keep_learning> ghc -o Para  -prof -auto-all  -fdph-par -threaded -rtsopts Main.o ParallelMat.o
04:22:40 <keep_learning> First i compiled ParallelMat.hs and then Main.hs and trying to link them
04:23:12 <keep_learning> Could some one please tell me how to profile  ?
04:25:25 <int-e> keep_learning: this looks like the profiling version of the dph-prim-interface package is not installed properly.
04:28:30 <keep_learning> int-e  Thank you
04:35:00 <PDani> hi
04:37:12 <statusfailed> Is Enum the correct typeclass for a fixed set of values?
04:37:34 <donri> might want Bounded too
04:37:38 <quicksilver> yes. It's a weird typeclass in many respects but still yes.
04:37:59 <statusfailed> hm, it says "Sequentially ordered" though
04:38:05 <statusfailed> that doesn't mean Ord does it?
04:38:54 <donri> Enum gives you succ/prec which are also used in range syntax [from .. to]
04:39:12 <ChristianS> statusfailed: you can derive all standard typeclasses for enums if you like (Eq, Ord, Enum, Bounded, Show, Read)
04:39:44 <donri> pred*
04:41:21 <hpaste> PDani pasted “mmap” at http://hpaste.org/57048
04:41:22 <statusfailed> Well I only wanted an unordered set of values but it doesn't really matter ^^
04:41:24 <PDani> i have this ^^ code. i tried to optimize buildStructs to do only strict evaluations. i would like to make garbage collector free the mmapped space. somehow i see that it doesn't happen (memory usage keeps growing after the debug line), and the prog runs out of heap. my question is: how can i investigate, where do i keep references to the mmapped space, or how could i force the gc to free it?
04:42:48 <ClaudiusMaximus> Ix, Data, Typeable  are also useful to derive
04:42:54 <donri> statusfailed: Enum and Bounded and use [minBound ..] to list them all
04:52:47 <statusfailed> donri: ok, cheers
05:02:44 * hackagebot amrun 0.0.0.1 - Interpreter for AM  http://hackage.haskell.org/package/amrun-0.0.0.1 (DanielSeidel)
05:10:55 <everythingWorks> What can "RealFloat" be seen as?
05:11:26 <everythingWorks> Is it a float with "unlimited" range like Integer is for Int?
05:11:32 <shachaf> No.
05:11:37 <shachaf> It's just a floating-point number.
05:11:40 <shachaf> @instance RealFloat
05:11:40 <lambdabot> Maybe you meant: instances instances-importing
05:11:44 <shachaf> @instances RealFloat
05:11:44 <lambdabot> Double, Float
05:11:50 <everythingWorks> shachaf: So its the same as Floating?
05:11:53 <shachaf> No.
05:12:02 <shachaf> The most information you can typically get about type classes is by what instances and methods they have.
05:12:07 <shachaf> There are no laws, only anarchy.
05:12:10 <statusfailed> What's the difference between the Text.Parsec and Text.ParserCombinators.Parsec libraries?
05:12:11 <shachaf> @instances Floating
05:12:11 <lambdabot> Double, Float
05:12:18 <shachaf> Numeric type classes, I mean.
05:12:21 <mauke> @src RealFloat
05:12:21 <lambdabot> Source not found. You type like i drive.
05:13:07 <everythingWorks> So what's basically the difference RealFloat <> Floating
05:13:19 <shachaf> Hmm.
05:13:24 <shachaf> Maybe the Report has an answer.
05:14:06 <everythingWorks> shachaf: Additionally: how does the "@instances" / "@src" work? If i type "@instances Floating" within GHCi it won't do good
05:14:28 <shachaf> everythingWorks: lambdabot is very different from ghci
05:14:30 <mauke> everythingWorks: have you tried the documentation?
05:14:38 <shachaf> everythingWorks: :i in ghci is useful.
05:15:08 <mm_freak> statusfailed: the version number of parsec
05:15:17 <mm_freak> the former is parsec 3, the latter parsec 2
05:15:43 <statusfailed> mm_freak: oh, ok thanks
05:15:48 <mm_freak> everythingWorks: RealFloat can be read as:  "has a real internal floating point representation, so you can compose and decompose"
05:15:58 <mm_freak> :t floatRadix
05:15:58 <lambdabot> forall a. (RealFloat a) => a -> Integer
05:16:41 <mm_freak> > encodeFloat 3 (-4) :: Double   -- 3 * 2^(-4) = 0.75
05:16:42 <lambdabot>   0.1875
05:16:44 <mm_freak> uhm
05:16:50 <statusfailed> Is there a way to automatically treat Parser [Char]s as Parser ByteStrings ?
05:16:51 <mm_freak> 0.1875 i mean =P
05:17:20 <mm_freak> > encodeFloat 3 (-2) :: Double   -- 3 * 2^(-2) = 0.75
05:17:21 <lambdabot>   0.75
05:17:31 <everythingWorks> okay thanks, also the :i term is kinda useful!
05:18:03 <mm_freak> > decodeFloat (0.75 :: Double)
05:18:04 <lambdabot>   (6755399441055744,-53)
05:18:11 <shachaf> everythingWorks: It works on classes, types, value identifiers, lots of things.
05:18:12 <mm_freak> uh, that's bad
05:18:31 <mm_freak> > decodeFloat (3/4 :: Double)
05:18:31 <lambdabot>   (6755399441055744,-53)
05:18:48 <mm_freak> strange…  why doesn't that give (3, -2)?
05:19:21 <mm_freak> apparently the representation is equivalent to (3, -2)
05:19:49 <mm_freak> > decodeFloat (1/2 :: Double)
05:19:50 <lambdabot>   (4503599627370496,-53)
05:20:10 <mm_freak> > decodeFloat (1/2 :: CDouble)
05:20:10 <lambdabot>   Not in scope: type constructor or class `CDouble'
05:20:20 <mm_freak> > decodeFloat (1/2 :: Foreign.CDouble)
05:20:20 <lambdabot>   Not in scope: type constructor or class `Foreign.CDouble'
05:20:40 <mm_freak> > decodeFloat (1/2 :: Foreign.C.Types.CDouble)
05:20:41 <lambdabot>   Not in scope: type constructor or class `Foreign.C.Types.CDouble'
05:20:50 <sopvop> So, there was a library on hackage which provided safe versions of partial function from prelude. Like 'tail :: [a]->Maybe a' and the like. Anyone remember name?
05:21:11 <ddarius> @hackage safe
05:21:11 <lambdabot> http://hackage.haskell.org/package/safe
05:21:44 <sopvop> Oh :) Thanks!
05:22:35 <everythingWorks> Im currently getting a kinda minor warning inhere: http://ideone.com/BC2Rv
05:22:38 <hpaste> sf pasted “hpaste” at http://hpaste.org/57049
05:22:50 <statusfailed> Can anyone tell me why that ^ doesn't work?
05:22:54 <everythingWorks> It says (line 2): "2 is a Integer because of ^" "2 is a Num because of "2"
05:23:05 <hpc> :t (^)
05:23:06 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:23:08 <everythingWorks> statusfailed: its just a warning
05:23:12 <everythingWorks> hpc: yeah i know..
05:23:22 <everythingWorks> but what i do now know is how to remove this warning :D
05:23:28 <hpc> are you compiling with -Wall?
05:23:30 <everythingWorks> do not know *
05:23:33 <statusfailed> everythingWorks: I get this: Couldn't match expected type `ByteString' with actual type `[Char]'
05:23:48 <everythingWorks> statusfailed: what the f*? :D
05:24:01 <everythingWorks> hpc: You mean i should ignore those warnings?
05:24:22 <everythingWorks> or is there some "clean style" i should code in to remove all pending warnings.
05:24:29 <hpc> everythingWorks: just wondering; ive never seen that warning before
05:24:43 <statusfailed> I've only just realised we're talking about different things
05:24:53 <everythingWorks> To clarify, thats the 'real' warning: http://ideone.com/THSeX
05:26:03 <quicksilver> use (2 :: Int)
05:26:30 <donri> everythingWorks: just a heads up, hpaste.org is the preferred pastebin in here
05:26:37 <hpc> everythingWorks: also, you can change the type to sq :: Num a => ...
05:27:05 <hpc> RealFloat is less polymorphic than that function can be
05:28:25 <everythingWorks> hpc + donri: thanks!
05:28:32 <everythingWorks> quicksilver: nice approach, too, thank you! :D
05:28:38 <hpc> everythingWorks: also, what that error message is saying is "2 is usually a (Num a => a), but it's being used here as an (Integral a => a), and the monomorphism restriction says that it should just be Integer"
05:29:41 <hpc> GHC error messages tend to go "what kind of error \n what we saw \n what we expected \n maybe how to fix it"
05:30:20 <hpc> *warnings
05:32:45 * hackagebot test-framework-quickcheck2 0.2.12 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.12 (MaxBolingbroke)
05:32:47 <lars9> what's the connection between lens and GUI programming?
05:33:05 <lars9> http://www.reddit.com/r/haskell/comments/oxg3c/make_things_now_pragmatic_fp_with_haskell_slides/
05:34:48 <merijn> lars9: You often need to modify very nested GUI data structures
05:35:12 <merijn> dropdown in a tab in a window, or menu in a menu in a menu, that sorta thing
05:35:19 <merijn> At least, that's what I thought
05:36:32 <lars9> oh, i thought it's more fancy than that
05:37:29 <hpc> when i write a function/callback that needs to modify GUI elements, i just close over them
05:37:42 <hpc> i imagine a nested GUI elements record would get untennably large very quickly
05:38:22 <statusfailed> Could anyone point me to example code on using Parsec on ByteStrings?
05:38:43 <lars9> gui programming is not fun
05:38:52 <statusfailed> http://hpaste.org/57049 <-- still having problems with this
05:39:47 <everythingWorks> why list parameters often are called "xs"?
05:40:03 <statusfailed> everythingWorks: I always thought of it like "plural of x" :P
05:40:08 <merijn> everythingWorks: plural of x
05:40:16 <statusfailed> oh :o
05:40:19 <merijn> x:xs == one x followed by multiple x's
05:40:45 <merijn> minus apostrophe, I guess. English plurals are confusing
05:41:05 <merijn> Similarly y:ys, t:ts, etc.
05:41:09 <shachaf> merijn: What's confusing? You never use apostrophes to pluralise things.
05:41:16 <shachaf> All the cat's are out of the bag.
05:41:17 <everythingWorks> mrijn: thanks :D
05:41:49 <shachaf> (If the apostrophe was correct, it could be part of a haskell identifier.)
05:41:52 <everythingWorks> the apostrophe just is used to signal someones thing or make snippets shorter
05:42:01 <merijn> Wait
05:42:03 <everythingWorks> Like in: "It's time"
05:42:05 <merijn> Ha, I was right
05:42:24 <merijn> apostrophe is proper for plurals if the object is not a proper English word
05:42:32 <everythingWorks> =D
05:42:48 <everythingWorks> even haskell would accept ' for names, wouldnt it? *heh*
05:43:13 <merijn> shachaf: "The marking as plural of written items that are not words established in English orthography (as in P's and Q's, the late 1950's)."
05:43:34 <lars9> another reason is haskell does not allow shadowing, so we don't have many names to use. otherwise we'll just use 'case students of student:students ->'
05:43:55 <merijn> shachaf: Anyhoo, the English rules by themselves are not confusing, but in Dutch you use the apostrophe for plurals of words that end in a vowel
05:44:00 <hpc> haskell allows shadowing
05:44:06 <hpc> it's just not even remotely encouraged
05:44:19 <donri> > let x = 5 in case x of x -> x
05:44:19 <lambdabot>   5
05:44:19 <merijn> i.e. plural of foto (photo) is foto's (photos), not fotos
05:44:20 <hpc> i do it all the time with database code
05:44:23 <hpc> for row ids
05:44:27 <hpc> :t id
05:44:27 <lambdabot> forall a. a -> a
05:44:34 <shachaf> merijn: I guess those people are just wrong and evil.
05:44:44 <merijn> Which is why I get confused about apostrophe and plurals sometimes
05:45:26 <mm_freak> > do x <- [1,2]; x <- [3,4]; return x
05:45:27 <lambdabot>   [3,4,3,4]
05:48:48 <statusfailed> Ok wtf
05:48:52 <lars9> ah i dunno where i got that idea
05:48:54 <statusfailed> example code in the parsec documentation doesn't work
05:49:12 <statusfailed> under "manyTill": http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Combinator.html
05:49:20 <statusfailed> the "simpleComment" parser doesn't work
05:49:25 <mm_freak> but going with "haskell doesn't allow shadowing" is probably a good idea anyway
05:49:43 <mauke> statusfailed: "doesn't work" is meaningless
05:50:14 <deech> Hi all, just read the blog post about the UHC Javascript backend and I wanted to ask a more broad question. Why the push to create a Haskell that compiles to Javascript as opposed to a library that can produce it?
05:50:15 <statusfailed> sorry, doesn't compile
05:50:20 <mauke> statusfailed: doesn't compile how?
05:50:50 <statusfailed> No instance for (Stream s0 m0 Char)
05:51:09 <lars9> mm_freak: why? shadowing is so useful when we want to hide something
05:52:06 <shachaf> deech: A library that can produce what?
05:52:29 <statusfailed> mauke: do you want the full error message?
05:52:30 <keep_learning> Hello all
05:52:38 <keep_learning> I have a request.
05:52:42 <lars9> in case xs of x:xs ->, we are sure we don't need the shadowed xs anymore, so just make it not accessable
05:52:47 <deech> shachaf: Javascript. Parenscript (http://common-lisp.net/project/parenscript/) is such a library.
05:52:50 <jeltsch> keep_learning: Just ask. :-)
05:52:54 <mauke> statusfailed: currently installing parsec to see if it's the monomorphism restriction
05:53:14 <mauke> oh wait
05:53:31 <keep_learning> Could some one having more that one cores can run my program on his system and tell if its gaining the performance ( dph package )
05:53:33 <statusfailed> mauke: if it helps I have OverloadedStrings on
05:53:52 <keep_learning> *than
05:54:05 <shachaf> deech: What?
05:54:28 <keep_learning> I have the compiled code
05:54:46 <shachaf> deech: "Parenscript is a translator from an extended subset of Common Lisp to JavaScript."
05:54:51 <shachaf> deech; That looks like a compiler to me.
05:54:57 <statusfailed> mauke: NoMonomorphismRestriction compiles...
05:55:12 <shachaf> I have no idea what's "library"ish about your proposal, but how is it different from a compiler?
05:56:15 <mm_freak> lars9: the question is whether we do want to hide something
05:56:27 <deech> shachaf: To my understanding it only emits JS, it's somewhat analogous to Atom (http://hackage.haskell.org/package/atom-1.0.11) which emits C.
05:56:34 <mm_freak> lars9: for me hiding is a function call, not shadowing
05:57:43 <parcs`> keep_learning: no one sane is going to run a binary off the wild interwebs
05:57:45 * hackagebot socks 0.4.0 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.4.0 (VincentHanquez)
05:58:09 <lars9> mm_freak: how to hide by function call?
05:58:10 <keep_learning> parcs`, i can give you source code if you want :)
05:58:15 <shachaf> deech: It looks like what they did was compromise some of the language in order to make it closer to JavaScript and thereby need no RTS.
05:58:19 <parcs`> keep_learning: that would be better
05:58:31 <keep_learning> parcs`, and one input file
05:58:42 <shachaf> deech: I doubt that'd work for Haskell in any reasonable way. It's much more different from JavaScript than Common Lisp is.
05:58:46 <mm_freak> lars9: each time you make a recursive function call you hide variables…  you replace their values basically
05:58:52 <keep_learning> parcs`, may i message you private ?
05:59:03 <shachaf> deech: What's your objection to a compiler backend for UHC or some such?
05:59:10 <mm_freak> lars9: entirely hiding variables amounts to calling a different function
05:59:11 <keep_learning> parcs`, if you have system with more than one core ?
06:00:03 <deech> shachaf: no objection at all. I was just wondering about the possibilites. It seems easier to produce a library that emits Javascript than to create a whole backend.
06:00:27 <mauke> deech: what's the difference?
06:02:18 <shachaf> deech: What's "a library that emits JavaScript"?
06:02:40 <funktronic> sounds like a compilery thingie
06:02:55 <deech> mauke: Using a library you can implement a small DSL that models Javascript without having to worry about all the features of the host languages. For example UHC might come out with a feature in the future that doesn't compile well to Javascript and users would just have to know not to use it.
06:03:11 <shachaf> Oh, you mean a *Haskell* library?
06:03:19 <deech> shachaf: Yes
06:03:58 <shachaf> I don't see the point of embedding a JavaScript-like language in Haskell's syntax rather than in some other syntax.
06:04:35 <deech> shachaf: The same reason we have HTML quasi-quoting in Haskell, to keep it all in the same language.
06:07:29 <PDani> any idea?
06:07:48 <parcs`> keep_learning: i have a dual core cpu but unfortunately i'm pressed for time at the moment
06:10:17 <mm_freak> deech: the point of quasi-quoting is really to bring a /different/ language into haskell =)
06:10:23 <mm_freak> it's just the same source file
06:10:24 <keep_learning> parcs`, no problem , thanks
06:12:17 <donri> deech: you know it exists already? hjscript and jmacro
06:12:40 <ppseafield> mm_freak: It might also potentially provide static checking for something like javascript. Catching errors at compile time when there are some JS errors (like trailing commas stopping the execution of scripts) that only happen in certain browsers
06:13:23 <donri> yes, jmacro is quasi-quoted and does that
06:14:39 <quicksilver> anyhow the point is they are two completely different purposes
06:14:48 <quicksilver> certainly they both have advantages
06:15:04 <quicksilver> but compiling the full haskell language to javascript is a useful idea to some people
06:15:19 <merijn> Notably, the University of Utrecht ;p
06:15:22 <quicksilver> because so many environments have (rather optimised) javascript VMs
06:15:35 <quicksilver> that's not the only project though
06:15:53 <merijn> I know, but patriotism requires me to disregard the rest :p
06:15:58 <quicksilver> https://github.com/sviperll/ghcjs springs to mind
06:16:09 <quicksilver> but there have been other older efforts
06:16:31 <quicksilver> http://www.haskell.org/haskellwiki/Yhc/Javascript
06:17:33 <donri> I like the UHC approach of having "foreign import/export jscript"
06:18:31 <donri> though I'd prefer to stay in GHC ...
06:21:23 <everythingWorks> How do i add a number x to a list at the end?
06:21:30 <everythingWorks> like: [3,4] : 5
06:21:34 <luite> ++ [x]
06:22:01 <luite> but it's not as fast as appending at the head, you build a completely new list
06:22:01 <everythingWorks> oh, of course. Thank you luite! :D
06:22:05 <funktronic> just be careful about the perf implications of that
06:22:06 <Cale> > [3,4] ++ [5]
06:22:07 <lambdabot>   [3,4,5]
06:22:28 <hpc> everythingWorks: if you are doing lots of those appends, it's better to put it on the head of the reversed list
06:22:34 <hpc> and then reverse it once again at the end
06:23:21 <everythingWorks> okay, but isnt that right what reverse is doing too?
06:23:42 <hpaste> ddd pasted “ddd” at http://hpaste.org/57051
06:23:54 <everythingWorks> upps, im "ddd" thus :D
06:23:56 <Cale> everythingWorks: reverse is also O(n)
06:23:57 <funktronic> everythingWorks: reverse is faster
06:24:14 <merijn> Reverse also has to build a new list, but reverse only does it once
06:24:14 <Cale> oh, *that* reverse is quadratic time
06:24:25 <Cale> the actual reverse is faster
06:24:27 <merijn> Append does it for *each* item you append
06:24:32 <funktronic> everythingWorks: appending to the endof the list is O(n) so if you do it n times you're looking at O(n^2).. if you build it up then reverse it's O(n) + O(n)
06:24:59 <everythingWorks> cool, thanks
06:25:07 <Cale> > let rev = foldl (flip (:)) [] in rev [1..10]
06:25:09 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:25:20 <Cale> ^^ that implementation is linear time
06:25:40 <funktronic> @src foldl
06:25:40 <lambdabot> foldl f z []     = z
06:25:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:25:46 <funktronic> :)
06:25:53 <Cale> you can compare them on [1..1000] or something in ghci to see
06:26:15 <merijn> If you really want to compare performance, use [1..] :>
06:26:24 <Cale> actually, use [1..10000]
06:26:45 <Cale> (or longer)
06:26:49 <hpc> > [1..100000] ++ [15]
06:26:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:27:24 <Cale> It's worth noting that while  (++ [x]) has a linear cost, it's spread out as a constant cost per element
06:31:27 <charro> is there a way to get a value out of monadic context?
06:31:31 <mm_freak> > map last . iterate (++ "x") $ ""
06:31:32 <lambdabot>   "*Exception: Prelude.last: empty list
06:31:33 <Veinor> charro: no.
06:31:38 <Veinor> not for general monads, anyway
06:31:39 <mm_freak> charro: depends on the monad
06:31:57 <mm_freak> charro: if you're talking about IO, then no
06:32:03 <mm_freak> > map last . iterate (++ "x") $ "x"
06:32:04 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
06:32:13 <mm_freak> > drop 10000 . map last . iterate (++ "x") $ "x"
06:32:17 <Veinor> what are some monads other than IO that you can't 'get out of', anyway?
06:32:17 <lambdabot>   mueval-core: Time limit exceeded
06:32:21 <charro> it's actually the X() monad from the XMonad package
06:32:26 <Veinor> oh, list
06:32:26 <merijn> > head [1..10] -- Got a value out of a monad!
06:32:27 <lambdabot>   1
06:32:33 <mm_freak> Veinor: YourFavoriteTransformerT IO
06:32:37 <Veinor> mm_freak: :P
06:32:45 * hackagebot edit-lenses 0.2 - Symmetric, stateful edit lenses  http://hackage.haskell.org/package/edit-lenses-0.2 (DanielWagner)
06:32:49 <mm_freak> Veinor: STM
06:33:00 <charro> merijn: if it were that easy i  wouldn't ask ;-D
06:33:02 <danr> mm_freak: atomically :: STM a -> IO a
06:33:02 <mm_freak> there is no function STM a -> a
06:33:29 <Veinor> charro: X has IO inside it, so no
06:33:30 <everythingWorks> Cale: can you explain your snippet " let rev = foldl (flip (:)) []" in short?
06:33:33 <Veinor> newtype X a = X (ReaderT XConf (StateT XState IO) a)
06:33:42 <charro> Veinor: Thanks
06:33:53 <merijn> charro: I expect the answer is no for X, what is the problem you're trying to solve?
06:34:02 <everythingWorks> I basically have 3 questions: You dont give it a parameter? :O What does foldl/ flip? :P
06:34:08 <Cale> everythingWorks: okay
06:34:17 <merijn> everythingWorks: flip reverses the parameters of a function
06:34:19 <merijn> :t flip
06:34:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:34:24 <Cale> trololol
06:34:25 <Cale> :)
06:34:27 <merijn> hmm, that's not helpful
06:34:37 <Cale> flip :: (a -> b -> c) -> (b -> a -> c)
06:34:40 <charro> trying to get the ScreenId in order to dynamically configure my scratchpad based on what screen it's on
06:34:52 <Cale> flip f x y = f y x
06:35:11 <Cale> everythingWorks: Okay, so if you're not familiar with folds, probably better to start with foldr
06:35:15 <merijn> charro: Ok, that's a bit too abstract for me to help devise a solution :p
06:35:31 <Cale> @src foldr
06:35:31 <lambdabot> foldr f z []     = z
06:35:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:35:34 <mm_freak> is there a way to lower the memory requirements of GHC?
06:35:51 <Cale> foldr f z replaces each (:) in a list with f, and the [] at the end with z
06:35:58 <mzero> mm_freak: compare it to Java!  ;-)
06:36:00 <mm_freak> when compiling the highlighting-kate package, GHC eats up all my memory and starts swapping wildly
06:36:03 <Cale> > foldr f z [1,2,3,4]
06:36:04 <lambdabot>   f 1 (f 2 (f 3 (f 4 z)))
06:36:07 <Cale> like that
06:36:11 <mm_freak> and i have 3.5 GiB free
06:36:19 <charro> merijn: thanks for your help anyway
06:36:26 <mm_freak> for GHC that is
06:36:48 <Cale> another way to look at it is that it produces a right associated expression, combining the elements of the list with f (and using z to handle them empty list case at the end)
06:37:16 <Cale> http://cale.yi.org/share/Folds.svg -- if you'll look at the diagram in the upper left, that shows it as a picture
06:37:27 <merijn> Cale: The diagrams are back?
06:37:29 <merijn> \o/
06:37:37 <Cale> They were never really gone
06:37:44 <Cale> I just lost the article explaining them
06:37:45 * hackagebot edit-lenses-demo 0.1 - Programs demoing the use of symmetric, stateful edit lenses  http://hackage.haskell.org/package/edit-lenses-demo-0.1 (DanielWagner)
06:37:47 <everythingWorks> Cale: okay, can you give a *simple* example using foldr using real values? :D
06:38:04 <Cale> okay, let's derive foldr by abstracting some simple code
06:38:11 <merijn> > foldr (+) 0 [1..10]
06:38:12 <lambdabot>   55
06:38:14 <Cale> Suppose we want to add all the elements of a lsit
06:38:15 <Cale> list*
06:38:19 <merijn> > sum [1..10]
06:38:19 <lambdabot>   55
06:38:29 <Cale> We can write
06:38:32 <Cale> sum [] = 0
06:38:33 <everythingWorks> :D
06:38:37 <Cale> sum (x:xs) = x + sum xs
06:38:39 <Cale> yeah?
06:38:50 <Cale> and if we wanted to multiply them all
06:38:54 <Cale> product [] = 1
06:38:55 <Veinor> Cale: dang, i like those diagrams
06:39:00 <Cale> product (x:xs) = x * product xs
06:39:04 <everythingWorks> > product [1..10]
06:39:05 <lambdabot>   3628800
06:39:13 <bru`> Cale:  "sum = foldl1 (+)"?
06:39:18 <Cale> these definitions should look really similar
06:39:23 <bru`> oh nvm
06:39:24 <bru`> sorry
06:39:32 <Cale> the only difference is that 0 has been replaced by 1
06:39:35 <Cale> and (+) with (*)
06:39:47 <everythingWorks> okay, got it
06:39:58 <tncardoso> http://research.microsoft.com/en-us/projects/trueskill/
06:40:00 <Cale> So in the interest of writing programs well and abstracting out the differences, we should take these two things as parameters
06:40:07 <Cale> and use those parameters
06:40:10 <tncardoso> sorry, wrong window  ;)
06:40:16 <Cale> foldr f z [] = z
06:40:25 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
06:40:32 <Cale> and then we can write:
06:40:37 <Cale> sum = foldr (+) 0
06:40:44 <Cale> product = foldr (*) 1
06:41:31 <Cale> everythingWorks: make sense?
06:42:12 <Cale> everythingWorks: another thing you might notice is that
06:42:15 <Cale> concat [] = []
06:42:19 <everythingWorks> yep, makes sense :D
06:42:21 <Cale> concat (x:xs) = x ++ concat xs
06:42:25 <Cale> also fits that pattern
06:42:28 <Cale> and many others
06:42:34 <Cale> concat = foldr (++) []
06:42:44 <Cale> and what happens with  foldr (:) []  ?
06:42:51 <Cale> Well, it's the identity function of course :)
06:43:05 <Cale> We're replacing each (:) with (:) and the [] at the end with []
06:43:32 <Cale> okay
06:43:33 <Cale> so...
06:43:40 <everythingWorks> one more, what exactly is (:)?
06:44:09 <Cale> (:) constructs a list when given its first element, and another list to be the remainder
06:44:16 <Cale> > 1 : [2,3,4,5]
06:44:16 <lambdabot>   [1,2,3,4,5]
06:44:23 <everythingWorks> ah, yeah, okay!
06:44:33 <Cale> Every list is either empty, or is of the form x : xs
06:44:42 <Cale> where x is the first element, and xs is the tail
06:44:48 <everythingWorks> yupp
06:45:11 <roconnor_> edwinb:
06:45:14 <roconnor_> opps
06:45:21 <roconnor_> edwardk: ping
06:45:56 <Cale> Okay, so foldl is similar, except that it "rebalances the tree to the left" in a sense
06:46:09 <Cale> @src foldl
06:46:09 <lambdabot> foldl f z []     = z
06:46:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:46:20 <Cale> > foldl f z [1,2,3,4,5]
06:46:21 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
06:46:41 <everythingWorks> okay
06:47:07 <Cale> If you look at the diagram, you'll notice that 5, the last element of the list, is near the top of the expression graph
06:47:13 <Cale> (the diagram for foldl)
06:47:47 <Cale> For reversing, we want that 5 to be the first element of our result
06:48:28 <Cale> So if our result looked like 5 : (...), that would be ideal
06:48:42 <Cale> But 5 is going to be the second parameter to our combining function rather than the first
06:48:56 <Cale> So if we flip the arguments to (:), that's starting to look good, yeah?
06:49:04 <everythingWorks> yep.
06:49:16 <everythingWorks> What im still curious about is how you are passing the list argument
06:49:32 <Cale> you mean in  rev = foldl (flip (:)) [] ?
06:49:37 <everythingWorks> yes
06:49:51 <Cale> I'm defining the *function* rev to be the same function as  foldl (flip (:)) []  is
06:50:17 <Cale> the list parameter is implicit, in a sense
06:50:24 <everythingWorks> ah, thats kinda brilliant :p
06:50:33 <Cale> if  f = g,  then f x = g x for any x
06:50:48 <Cale> and vice versa
06:50:58 <everythingWorks> yep, so "let" is here for exactly this reason?
06:51:05 <Cale> If you see an x on both sides of an equation, then you can delete it
06:51:18 <Cale> (in a way)
06:51:28 <Cale> let is here just to allow me to make a definition locally
06:51:37 <Cale> > let x = 6 in x * x
06:51:38 <lambdabot>   36
06:52:04 <everythingWorks> yepp. Thanks for the great explanation :D
06:52:16 <Cale> In general   let <declarations> in <expression>   is an expression in which the declarations are in scope in the given expression.
06:53:08 <Cale> another way we can arrive at the foldl definition of reverse is to write reverse recursively in an efficient manner using a helper function
06:53:24 <Cale> reverse' ys [] = ys
06:53:46 <Cale> reverse' ys (x:xs) = reverse' (x:ys) xs
06:54:24 <Cale> If you think of the two list parameters to this function as stacks, basically it's popping elements off of the second stack and pushing them onto the first
06:54:44 <Cale> until there are no elements in the second stack, at which point it produces the first as its result
06:54:52 <Cale> (to think about it in a fairly imperative fashion)
06:55:07 <everythingWorks> yep, got that, thanks :D
06:55:16 <Cale> and then we can write reverse proper as:
06:55:19 <Cale> reverse = reverse' []
06:55:53 <Cale> things which operate in a similar way to this abstract into uses of foldl
06:56:13 <Cale> anything which accumulates into an extra parameter as it traverses a list
06:56:42 <Cale> (or, nearly so, anyway)
06:57:12 <Veinor> what does ARR_WORDS represent in -hy output?
06:58:34 <copumpkin> hey cheater_, what's up? :)
06:58:57 <Veinor> i have a simple fibonacci-computing function that i'm using to demonstrate how to properly use seq/$!
06:59:08 <Veinor> and ARR_WORDS is using the vast majority of the whopping 100k of memory
07:03:06 <Itkovian> exporting question. I have two modules B and W that export a data type Reason and a module M that import both B and W qualified and exports B.Reason and W.Reason. Since B.Reason and W.Reason both have an S constructor, that's a conflict. Any pointers on how to do this correctly?
07:12:22 <DanBurton> sanity check, am I using ErrorT right in this answer? http://stackoverflow.com/a/9036058/208257
07:12:30 <DanBurton> *correctly
07:16:27 <ceii> DanBurton, I don't see any problems with it
07:18:27 <DanBurton> ceii: cool, thanks
07:20:16 <JordiGH> Is Darcs still popular for Haskell?
07:20:55 <ceii> JordiGH, it's probably the most used VCS in the Haskell community
07:20:57 <hpaste> PDani pasted “constant?” at http://hpaste.org/57053
07:21:11 <ceii> though git has been getting a lot of traction thanks to github
07:21:26 <PDani> ^^ will it run in constant space and linear time of the length of intervals?
07:21:36 <ceii> and because darcs is (used to be?) too slow to be used on very large projects
07:21:50 <PDani> i don't know whether monadic code works the same way as pure code from this perspective
07:22:08 <dolio> I think there are few Haskell projects big enough for darcs slowness to be a problem.
07:22:17 <rs461> What function would transform this list of strings as such: ["foo","bar","hello"] -> "foo bar hello"
07:22:18 <rs461> ?
07:22:23 <mauke> rs461: unwords
07:22:30 <rs461> mauke: thanks
07:24:39 <osfameron> or Data.List.intercalate " "
07:25:00 <ceii> PDani: your code will not be able to "stream" output like a non-monadic version, because it has to treat all of its input before it knows whether to return a Nothing or Just a list.
07:25:11 <frerich> osfameron: I think hlint actually suggests using unwords instead of intercalate " "
07:25:25 <osfameron> fair enough
07:25:43 <osfameron> but knowing about intercalate " " means you know the answer if you later want "foo-bar-hello" etc.
07:25:48 <PDani> ceii, is there a better (more space-conservative) solution for this?
07:26:54 <frerich> PDani: At the risk of pointing out the obvious, but "monadic code" is actually (in most cases, as far as I can tell) pure code. I suppose you mean "I don't know whether IO works the same way as pure code from this perspective"?
07:27:08 <ceii> no, he's using the Maybe monad
07:27:51 <frerich> Oh, well, Maybe definitely (sorry for the pun) counts as 'pure' in my book. :-)
07:27:53 <ceii> but it's true you can't say anything about "monadic code" in general. The question is really about Maybe, not monads
07:28:41 <ceii> at any rate, there's something strange about returning a Maybe [a] in a streaming context
07:29:25 <ceii> basically, you're handling input as it comes, but you might suddenly realize there's something wrong and all the output you already generated was useless?
07:31:19 <ceii> PDani, what kind of failure behaviour do you expect from your getSample function?
07:41:08 <jedai> Hello
07:41:23 <ceii> Hi
07:42:03 <Cale> Itkovian: don't name everything the same? ;)
07:42:16 <Cale> Itkovian: but also you can just import things qualified
07:42:29 <Cale> import qualified B
07:42:33 <Cale> import qualified W
07:42:41 <Itkovian> Cale: It is kinda lame to have BisMyLongNameThingS and WisMyLongNameThingieButDifferen.S
07:42:42 <Cale> oh
07:42:50 <Itkovian> Cale: yeah the imports are no problem
07:42:55 <Cale> right
07:42:56 <Itkovian> re-exporting them is
07:43:04 <Cale> you have to import them qualified where you want to use them too
07:43:09 <Itkovian> true
07:43:10 <Cale> rather than re-exporting them
07:43:22 <Itkovian> I guess I'll just nott export them and have the users import the modules separately
07:43:34 <Cale> Why not name them BReason and WReason?
07:43:37 <Cale> or something?
07:43:41 <jedai> I'm having quite a problem with gtk2hs on windows, ghc 7.0.2, gtk2hs 0.12.2 : while gtk itself (and cairo, pango...) seem to install flawlessly, trying to compile an executable (such as demo\hello\World.hs in gtk) results in a flood of linker error
07:44:27 <Cale> I usually think of the module system as more of a last-ditch effort to get around name conflicts rather than something which is to be used to let me name everything identically
07:44:30 <Itkovian> Cale Because the B and W in themselves mean nothing
07:44:42 <Itkovian> ok, fair enough
07:44:52 <Itkovian> thx
07:44:56 <Cale> To be fair, not everyone does
07:45:15 <Cale> but, I just dislike having to qualify names in my source code
07:45:23 <Itkovian> right :-)
07:45:39 <Itkovian> I do not like it for things from the same project/package/...
07:45:40 <Cale> especially since the . used to separate the module path looks so much like (.)
07:45:45 <ceii> well the idea of having different interchangeable modules exporting the same names is attractive sometimes
07:45:48 <Itkovian> but otherwise it seems a good thing
07:45:52 <ceii> see bytestring
07:46:02 <Itkovian> ceii: but also confusing
07:46:06 <ceii> yep
07:46:07 <jedai> I can compile diagrams-cairo for instance but trying to compile something using it is doomed to failure (yes I use --make). Does that ring a bell for someone ?
07:46:25 <Itkovian> you need to figure out yourself if it's the Lazy, Char8 or Lazy.Char8 or plain that you need
07:46:48 <Itkovian> Since often it's also not clear from the users of ByteString
07:47:08 <Itkovian> if a module uses it, you need to read more then the docs to grok what to use, no?
07:47:27 <quicksilver> Cale: I wish we had smart editors which could display B.foo as foo_{B}
07:47:48 <ppseafield> Itkovian: couldn't you just export aliases for those constructors in that module? e.g. bS = B.S and wS = W.S? I imagine you'd need to use explicit type signatures for stuff like pattern matching though.
07:48:59 <Itkovian> ppseafield: yeah well, it's not just the type constructor, it's also the data constructors eh (or am I mixing up names again?)
07:49:17 <Itkovian> data B.R = S | T and data W.S = S | T
07:49:20 <Itkovian> anyway
07:49:27 <Itkovian> we'll see if I get complaints :-)
07:55:41 <rageous> How might a take a list of lists of a given type and return a list of elements of that type?
07:56:23 <Cale> rageous: concat
07:56:24 <jedai> rageous: do you mean to concatenate all the sublists ?
07:56:59 <rageous> Yeah, concat all the sublists?
07:57:02 <rageous> Can I just map concat?
07:57:07 <rageous> Or, how would that work?
07:57:13 <rageous> I'm no good at this map reduce business.
07:57:15 <jedai> @hoogle concat
07:57:15 <lambdabot> Prelude concat :: [[a]] -> [a]
07:57:15 <lambdabot> Data.List concat :: [[a]] -> [a]
07:57:15 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:57:43 <jedai> rageous: concat already takes a list of list and evaluate to the concatenation of all sublists
07:57:52 <rageous> I see.
07:57:57 * rageous tries again
07:58:07 <jedai> to concatene two list you use the ++ operator
07:58:56 <jedai> so concat = foldr (++) []
07:59:29 <funktronic> @src concat
07:59:29 <lambdabot> concat = foldr (++) []
07:59:54 <frerich> Err, am I having a deja vu? Didn't Cale just talk about this to somebody else?
08:00:10 <mreh> golfy way of cycling a list back one element?
08:00:29 <quicksilver> take n . drop 1 . cycle?
08:00:37 <quicksilver> or take n . drop (n-1) . cycle
08:00:45 <quicksilver> depending what you meant by 'back'
08:00:49 <mreh> > \xs -> let l = length xs in drop (l-1) $ [1,2,3]
08:00:50 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a1])
08:00:50 <lambdabot>    arising from a use...
08:00:58 <mreh> > \xs -> let l = length xs in drop (l-1) xs $ [1,2,3]
08:00:58 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
08:01:03 <mreh> yeah that
08:01:21 <frerich> mreh: Back means, [1,2,3] -> [2,3,1] ?
08:01:26 <mreh> no
08:01:30 <mreh> that's forward :)
08:01:49 <frerich> mreh: Ok, so you want [1,2,3] -> [3,1,2] ?
08:02:59 <rageous> Awesome. Thanks guys.
08:03:16 <rageous> I was having nightmarish flashbacks to programming in Scheme. This is so much easier.
08:03:31 <dp_wiz> What's wrong with this zmq example? http://zguide.zeromq.org/hs:mspoller It leaks memory like crazy!
08:03:57 <jedai> > let turnBack xs = let l = length xs in take l . drop (l-1) . cycle $ xs in turnBack [1..5]
08:03:58 <lambdabot>   [5,1,2,3,4]
08:05:22 <jedai> > let turn xs = last xs : init xs in turn [1..7]
08:05:23 <lambdabot>   [7,1,2,3,4,5,6]
08:06:29 <mreh> that's nice
08:06:43 <mreh> more inefficient?
08:07:11 <mkscrg>  does anyone here know anything about the DJB hash function that's used by default in Data.Hashable?
08:07:14 <Itkovian> any idea is sdist is borked?
08:07:20 <xrl> how can I specify which package to find a module? I'm getting ambiguous module error for Network.Socket.ByteString (offered by network-bytestring and network
08:07:20 <mreh> > liftM2 (:) last init $ [1..7]
08:07:21 <lambdabot>   [7,1,2,3,4,5,6]
08:07:26 <jedai> I don't think there's an huge difference though I would bet on the cycle one being a bit better...
08:07:34 <mkscrg> like how well does it mix?
08:07:35 <mreh> ^^
08:07:36 <Itkovian> in cabal-install 0.10.2?
08:07:41 <Itkovian> afk
08:07:42 <jedai> We would need to bench them to be sure
08:07:43 <Itkovian> train
08:07:47 * hackagebot access-time 0.1.0.3 - Cross-platform support for retrieving file access times  http://hackage.haskell.org/package/access-time-0.1.0.3 (MaxBolingbroke)
08:07:54 <mreh> jedai: it's all linear
08:08:03 <Itkovian> or maybe not
08:08:22 <Saizan> Itkovian: there's a difference between cabal sdist and runghc Setup sdist, the former will ignore any custom Setup script
08:08:37 <jedai> mreh: Which is why there wouldn't be much of a difference ! :D
08:08:40 <Itkovian> I do not have a custom script :-)
08:09:09 <mkscrg> just found the implementation: answer is no
08:11:41 <ceii> xrl: use the PackageImports extension and import "some-package" Some.Module
08:12:16 <ceii> or use a cabal file so the packages you don't depend on are hidden when compiling
08:12:17 <PDani> ceii, yes, this is the case. i collect useful samples from a errorous data source. when i find some error in the data stream, i throw out the whole sample, and move on processing the next serie of data
08:12:40 <xrl> ceii: I found out that the package was recently deprecated... any idea how I can clean out the network-bytestring package? I tried rm -rf'ing it from ghc-7.0.4/lib
08:12:45 <PDani> s/stream/source/
08:13:36 <ceii> sorry, have to go
08:14:01 <xrl> ceii: google is helping :)
08:18:28 <dp_wiz> Not only hs:poller is leaking, but it also halts somewhere...
08:23:29 <jedai> xrl: To "uninstall" a package, you'll have to unregister it with ghc-pkg
08:24:41 <jedai> xrl: though that won't remove the package files themselves, so you'll have to do that by hand (but really, unregistering is enough if you don't care about a squeaky clean cabal dir)
08:30:32 <Guest76063> quit
08:31:00 <Guest76063> hi
08:31:07 <Guest76063> quit
08:31:11 <Guest76063> exit
08:31:15 <Guest76063> ohj dera
08:31:22 <jedai> Guest76063: you must put an / before
08:31:55 <jedai> Guest76063: like /quit (but without anything before the / of course
08:32:48 * hackagebot hMollom 0.3.1 - Library to interact with the @Mollom anti-spam service  http://hackage.haskell.org/package/hMollom-0.3.1 (AndyGeorges)
08:45:26 <jedai> For anyone who may remember my initial question (...no one ?) gtk+-2.22 is really a problem with gtk2hs and since it doesn't manifest until you try to link an executable, it's pretty annoying...
08:45:45 <jedai> gtk+-2.24 works well though
08:47:50 <shachaf> @hoogle Enum a => a -> a -> a -> Bool
08:47:50 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:47:50 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
08:47:50 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
08:47:56 <shachaf> Er.
08:48:00 <shachaf> @hoogle Ord a => a -> a -> a -> Bool
08:48:00 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:48:00 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
08:48:00 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
08:48:05 <shachaf> Well, that helped.
08:48:28 <shachaf> Is there a standard library function f u l x = x <= u && x >= l or so?
08:50:18 <nand`> :t mplus
08:50:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:50:22 <jedai> shachaf: Not exactly, though you have inRange
08:50:29 <Enigmagic> shachaf: maybe for integers
08:50:42 <jedai> shachaf: from Data.Array for Ix instance
08:51:32 <jedai> :t inRange
08:51:32 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
08:52:43 <shachaf> Ah.
08:52:46 <shachaf> But that's for Ix.
08:53:01 <shachaf> I was hoping for something that would work on Doubles.
08:53:09 <ion> Just implement the instance. ;-)
08:53:10 <Enigmagic> i don't think there is one
08:53:18 <shachaf> Anyway, it's one line of code, so I can just write it.
08:53:20 <ion> Doubles are Enums already.
08:53:22 <jedai> shachaf: I don't think so, not in the platform anyway
08:55:20 <jedai> shachaf: by the way, wouldn't it be better to put "inBetween l u x = l <= x && x <= u
08:55:48 <jedai> (the lower parameter to the right of the upper)
08:57:59 <jedai> (to the left ...)
09:00:56 <vortexion> anyone know who copumpkin is?
09:01:08 <vortexion> <copumpkin> hey, any chance you could join #haskell-ops?
09:01:14 <benj_> the categorical duel of a pumpkin
09:01:22 <benj_> er, s/duel/dual/
09:01:28 <ion> Where duel is the grammatical dual of dual
09:01:30 <mauke> vortexion: a channel op
09:05:19 <zomg> Is there any good pattern in haskell to parsing different strings into custom data types?
09:05:42 <adu> Parsec?
09:05:43 <shachaf> jedai: Yes.
09:05:44 <zomg> I have something where I read some strings which represent different commands, some with different args
09:06:06 <adu> ReadS?
09:06:38 <zomg> adu: so you would just suggest writing a parser which would determine the appropriate types to use?
09:07:06 <jedai> zomg: Read can be derived if you're ready to accept Haskell syntax for your commands
09:07:07 <zomg> Was just wondering maybe there was some pattern matching like trick to it or such since it seemed like something that could work with it =)
09:07:33 <zomg> jedai: the commands come from a 3rd party specified protocol which isn't really under my control
09:07:54 <jedai> zomg: Parsec or attoparsec or cereal (if binary protocol) then
09:08:15 <zomg> Cheers, I'll take a look at those
09:09:11 <ozataman> ddarius: ping. When using the Codensity monad, I don't get to disregard the continuation at any point? the forall is giving me a problem when I want to discard the rest of the computation and just return a result...
09:09:23 <jedai> zomg: those libraries are all built onto the parsing combinators paradigm so you don't have to use an external generator and they're often pretty fun and easy to use
09:09:45 <elliott> ozataman: You asked for a short-circuiting monad transformer, right?
09:09:49 <ozataman> elliott: yep
09:09:54 * elliott thought the Codensity suggestion odd.
09:10:00 <elliott> Why not use MaybeT or whatever?
09:10:07 <zomg> jedai: yeah Cereal looks nice
09:10:18 <adu> zomg: there's also "deriving (Read)"
09:10:57 <jedai> adu: he must handle a protocol, he can't use his own commands
09:11:03 <adu> ah ok
09:11:13 <ozataman> elliott: guess that's where I'm headed. it's fascinating to try to get CPS to work, and it's supposedly much more performant
09:14:08 <elliott> ozataman: Well, Codensity doesn't offer short-circuiting.
09:14:21 <ozataman> elliott: what does it offer then?
09:15:46 <elliott> ozataman: To answer that would require writing a blog post in an IRC line :) You might wish to read: http://comonad.com/reader/2011/free-monads-for-less/ http://comonad.com/reader/2011/free-monads-for-less-2/ http://comonad.com/reader/2011/free-monads-for-less-3/ http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ if you're really interested.
09:16:42 <elliott> Oh, http://comonad.com/reader/2008/kan-extensions/ http://comonad.com/reader/2008/kan-extensions-ii/ http://comonad.com/reader/2008/kan-extension-iii/ linked from there might help too... (as many blog posts as packages!)
09:18:06 <ozataman> elliott: thanks :) lots of train ride reading there
09:18:46 <elliott> ozataman: Note that the mtl doesn't have MaybeT -- you have to import Control.Monad.Trans.Maybe.
09:18:56 <elliott> (from transformers, the library mtl builds upon)
09:35:26 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
09:35:26 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:29 2011]
09:35:26 --- names: list (clog gmcabrita srhb dolio tsuraan_ h00k_ pikhq rtharper ceii_ Nordvind Technicus MaciejP qpu Itkovian ique ArchGT der_eq coeus wyfrn LtWorf mmaruseacph2 posteverything vithos frerich2 frerich SyntaxNinja erochester pommes_ TheJH elliott adu homie`` matthiasgorgens smarter Kanisterschleife dgpratt augur aartamonau Spockz ujm looopy_ derpladee thegeekinside jmelesky russruss jeltsch zhulikas ketil borkman warrenharris hang ftrvxmtrx dino- antilect vjn)
09:35:26 --- names: list (imphasing dnjaramba kadoban hugin kallisti adnap vikramverma papermachine Athas nachtwandler jedai noam__ RobertLJ roconnor__ BlankVerse dnolen pgiarrusso basti_ Tinned_Tuna Khisanth gridaphobe taruti anders^^ burp jd10 saati_ proqesi` RayNbow jamiltron Peaker amathew shurane copumpkin soro`` tncardoso conal abc05 ksion areil knoc kaezarrex Vorpal k0001 jfredett VoQn MoALTz_ maloi esmevane mkscrg Jantaro funktronic ISF xinming nand` SeriousWorm Masxmasx)
09:35:26 --- names: list (jlaire estebistec DasIch hpc Shammah zax_ zax vortexion Philonous ppseafield drbean nighty^ nexx Varakh kanak dschoepe jklvxnasd cheater_ ckpinguin LMolr gdsx donri ozgura x_man Darkflux mreh dzhus Spockz` Razz master_of_master RageOfThou danvet ville faber LordTrev Jafet rostayob GeminiRai Blkt nus Nanakhiel amiri_ insomniaSalt jonke ramier kaf3ii levitation[A] jaspervdj _root_ gemelen Palmik s4msung samek Snark m3ga koeien dmos aliak shintah scm c1de0x)
09:35:26 --- names: list (confab_ Blazeix ksf fcr wespee otto_s_ cubi ajhager Jonno_FTW wagle danlndi rglenn srcerer kolmodin lambdanaut noddy maurer [[zz]] macUzer theorbtwo Muad_Dibber mlh minsa Vq pdxleif preflex jix Zephyrus quicksilver X-Scale perlite Shin-LaC Amadiro brodo hundskatt Boney_ rsimoes milkpost Number6 blast_hardcheese dimmy otterdam xivix cmccann peterhil joe9 bartavelle Counter-Strike wunki_off iulian KSkrzet dkannan jbauman dings snetz edwtjo alios)
09:35:26 --- names: list (TacticalGrace kshannon hammi albel727 emmanuelux doubledensity nighty- brisbin `10 avocado AtnNn chipdude BrianHV andrewsw ChristianS Draggor mxweas tltstc redheadphones Botje Axman6 Baughn kvey @ChanServ ian_mi MostAwesomeDude ciaranm SimonRC Krinn fall_ krakrjak twn choptastic_ platinuum guerrilla overrosy smop CosmicRay dp_wiz milli monochrom flux akahn wto adimit abbe j2jx si14 torkjak danols_work aristid Nshag dcoutts Innominate Derander jlewis)
09:35:26 --- names: list (suiside a11235_ scgilardi poucet_ mateu Sunhay joni6128 Hunner Zarathu ido zmoazeni_ lmatos kalven mdwright nots trhodes _jesse_ sordina ice799 jrslepak_ welterde bddn jyyou erg lukish Gilly __class__ shoerain chr1s olsner Enigmagic ben Intensity SonicvanaJr ricky Solver m_stone EgeBamyasi tuv gwern araujo mrshoe yeltzooo majoh jrk_ kleini__ davean ahkurtz k0ral ski comak zenazn loccipocci lpsmith Corey copton othiym23 finnomenon epdtry pcapriotti)
09:35:26 --- names: list (DustyDingo arcatan hackagebot freedrull Nereid tessier FireFly charro trez cygnus_ prof7bit jml gwillen mortberg Nanar Internet13 cods setmeaway2 polux_ hirsch_ sully Bwild plat0 dmwit Ornedan tommd Nimatek jonafan tromp johs mjhan Liskni_si jimleroyer Dashkal Taggnostr2 cschneid HalfWayMan lebastr hiredman pranq_ R496_ Precious1etals mantovan1 dubellz flori warpy caligula_ gereedy i1126 saiam lusory waterlaz tavelram vav ve sunfun vold Boxo pyryp pettter)
09:35:26 --- names: list (aszlig birkenfeld tlockney nniro mimico_ arkx Twey EvanR adnam SamB_XP yottis herself boyscared IvdSangen Shou- em solarus Philippa blooberr sohum elliottcable liesen bradwright bobry lopex nkpart SeanTAllen arnihermann mimico wjlroe srid strmpnk tomh ivan` niko xrl mndrix wilfredh_ puzza007 earthy chops mauke gehho2 demolithion LeNsTR|off Cerise ehuber Redshift64 jrockway args[0] _habnabit flamingspinach zaero brett dumael djanatyn zomg tafryn stchang)
09:35:26 --- names: list (harlekin tgeeky Damn3d pi8027 kyagrd ormaaj inimino nyingen danm_ brandonw nihtml Saizan mendez jabirali McManiaC repnop ttvd nlogax buddyholly def-lkb russellw tridactyla yezariaely davv3 bcoppens Gothmog_ statusfailed Phlogistique xnyhps fwg obcode lokydor_ CrazyThinker Ralith Ptival etpace zw01 ChongLi KitB froztbyte franny kqr Jaxan Entroacceptor gentz exobit robinbb frigga bogner eviltwin_b ps-auxw KaneTW mokus_ dMazzz Younos mike-burns nowhere_man)
09:35:26 --- names: list (eyck mrdomino robbert Laney MrNibbles jonathanj Starfire ibid SHODAN danr JaffaCake amiller OnionKnight OscarZ ddarius joeytwiddle CoverSlide hvr rby klugez snorble And[y] mornfall gernot sjl atomicity dominikh eZet cncl magicman companion_cube Dodek TML MightyMoose dropdrive ESchultz-Rodrigu antonh znutar felipe_ almostsix drdo ousado zenzike alexsdutton freiksenet iFire nominolo popx noplamodo The_third_man Tene kakos ClaudiusMaximus mimi_vx wavewave)
09:35:26 --- names: list (nicoo yrlnry Gracenotes benj_ kissyboy ion ahf A1kmm jrib zeiris sp3ctum aleator dcguru dogmaT edwinb levi Astro thetallguy1 akosch saruman_ mattp_ angstrom stepnem tomku DrSyzygy vmeson sunnavy_ afarmer MK_FG osfameron szbalint pantski eno Igloo pou ahihi2 norm2782 mjrosenb moonlite ocharles jakky opqdonut Obfuscate Mitar chra xsysstar xplat Arnar kloeri jcapper Maxdamantus noj ehamberg Deewiant scsibug marienz tempire clsmith tomaw peddie kate_r zorzar)
09:35:26 --- names: list (tg Will| jbalint_ ixzkn_ shachaf mroman_ sahn_ seats kniu `0660 tomprince thetallguy wingless poindontcare impl mbernstein teiresias ft Aikawa Dave2 rdd` Raynes tamiko jamiely_desktop alang biio brainproxy koninkje_away mikeplus64 sagelywizard jlouis rwbarton ByronJohnson devn saurik Yahovah_ cwb` Runar bezik shutdown_-h_now helgikrs1 bford bmiddleton jboning etabot profmakx dilinger acfoltzer jakeskik ubiquill neptunepink jmcarthur djahandarie sm integral)
09:35:26 --- names: list (mm_freak dever MarcWeber skaar hyko thirsteh sero brixen dlmalloc mejalx Clint hpaste dqd alip Mathieu daimrod ojotoxy jayne alistra Vulpyne sipa muep elgot lispy bbee sahazel_ int-e nibalizer joshc bd_ hzh elarnon zygoloid confound `Zerax` mrd ziman BRMatt jackhill Lemmih lefant_ Ke reacocard quaestor CindyLinz snarkyboojum dcolish tsuraan__ PHO_ thorkilnaur dabradley aninhumer Yacoby dom96 naneau Jaak Guest61372 eigenwea1e dixie ybit koala_man shawn)
09:35:26 --- names: list (byorgey wires cynick deavid cjay emias mietek nimred alexbobp c2thunes ptrf Veinor limetree mike1703 rvncerr Eliel audunska ray dju petanqk inr electrogeek luite endojelly wayne[mobile] anachron dybber)
09:51:27 <tommd> ClaudiusMaximus: Owch!  Thanks for getting back to me!
09:55:22 <frerich> Anybody willing to discuss a small design issue? Right now, a module I've written (for talking to an IRC server) looks like this: http://hpaste.org/57058 - however, I just had another idea: how about making the 'connect' function be a function of type 'HostName -> PortNumber -> (IO (), String -> IO ())', e.g. it takes the host/port but then returns a tuple with the two functions which can be used to disconnect from and sent to that
09:55:23 <frerich> connection. So I don't need to export the 'send' and 'disconnect' functions.
09:55:42 <frerich> What do you think about this, does it seem stupid or is there some value/pitfall with that?
09:56:45 <frerich> I came up with this idea because I noticed that all the functions I export take an 'IRCConncetion' as their first argument. So thought - why not have the 'connect' function return partially applied versions of all those functions, maybe that's nicer?
09:57:05 <elliott> frerich: It would have to be HostName -> PortNumber -> IO (IO (), String -> IO ()).
09:57:18 <elliott> It's not a bad idea, *but* you should wrap the functions in a record.
09:57:41 <Saizan> it makes more sense if you have some reason to prevent any other access to the Handle
09:57:44 <elliott> (Then it actually becomes equivalent to your current version if you don't export the constructor.)
09:57:58 <elliott> I would just do it how you're doing, though.
09:58:04 <elliott> (Remember to export the IRCConnection type.)
09:58:11 <frerich> elliott: Ah, right - I missed one 'IO'. And yes, I considered a 'data IRCConnection = IRCConnection { send :: String -> IO (), disconnect :: IO ()}' type - but then I have exported those names again, so I'm not sure I've won much
09:58:33 <elliott> Well, what are you trying to win?
09:59:12 <frerich> Nothing in particular, it's just that this seemingly "alternative" approach to yield functions for interacting with the IRC server came to my mind. :-)
09:59:45 <frerich> Maybe it's nice to have all those functions dealing with the same connection bound to one value?
09:59:46 <elliott> Returning IO actions like that can sometimes be the nicest way to provide an interface but I don't think it buys you much there.
09:59:54 <frerich> I see.
10:00:02 <elliott> frerich: With a record, they're indistinguishable from outside the module.
10:00:13 <elliott> So the niceness is purely internal, and I think this method will make your module code slightly more complex.
10:00:30 <frerich> Oh, true... even with a record they have to call the functions on something. So I still have a 'handle' value.
10:00:35 <frerich> Hm hm.
10:01:04 <frerich> Well, at least you guys didn't discard this as total rubbish, which I'll count as a victory. :)
10:01:27 <frerich> This reminds me of another question which crossed my mind:
10:02:41 <elliott> frerich: Specifically, they'd call the record accessors on the record, producing the function.
10:02:45 <elliott> So it looks identical from outside. But yeah.
10:03:19 <frerich> How does one model callbacks in Haskell? I considered adjusting the 'connect' function so that people can pass a function which is called whenever data is received. So I thought of asking them to pass a 'Command -> IO ()' function ('Command' would be a nice data type which saves clients from having to parse the IRC format). However, my package would call that function from a different thread and I don't know what that 'callback'
10:03:20 <frerich> function they pass deas in that case.
10:03:37 <frerich> Am I on a totally wrong path here, maybe I'm thinking too much in 'callbacks as in C' terms.
10:04:14 <elliott> That would work (and I wouldn't worry about the thread issue). You might want to provide a (Chan Command) instead.
10:04:15 <c_wraith> frerich: a cool approach is to remove callbacks from the interface via CPS
10:04:24 <elliott> In fact, you could provide (IO Chan), by returning (readChan theChan).
10:04:30 <elliott> Erm
10:04:31 <elliott> *IO Command
10:04:38 <elliott> (That stops them writing to it.)
10:04:50 <frerich> c_wraith: What's CPS?
10:04:56 <hpc> frerich: continuation passing style
10:05:23 <frerich> elliott: Ah, chan. I saw that in a few places but tip-toed around reading up on them. Maybe it's about time I do so. :-}
10:05:27 <hpc> frerich: essentially, you write your program in terms of "what happens next"
10:05:51 <c_wraith> frerich: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
10:06:16 <elliott> CPS is nice but I think a Chan provides enough here.
10:06:31 <elliott> frerich: It's just a channel you can read to and write to, nothing too fancy :)
10:06:43 <elliott> Well, apart from the dupChan stuff.
10:07:43 <frerich> elliott: Hm, and I assume the caller can test whether there's something to read from the chan, or read form it (and block if there's no data yet)? Sounds like a buffer and a semaphore.
10:08:27 <frerich> c_wraith: Thanks for that link, reading it :-)
10:08:39 <c_wraith> testing whether there's something to read with a Chan is bad.  Like, it can deadlock.  Don't test, just read and be aware it can block.
10:08:59 <c_wraith> wait, maybe it doesn't deadlock, just blocks. but that's bad enough
10:09:17 <frerich> c_wraith: So if the client of my little IRC package maintains multiple connections, it should do a blocking read on every chan (in different threads, of course)?
10:09:30 <hpc> and testing first doesn't guarantee that the read won't block
10:09:34 <hpc> so you can block twice
10:09:50 <c_wraith> in any case, that blog post lists a really cool way to provide an API that doesn't appear to use callbacks, but does under the surface
10:09:54 <elliott> frerich: No, it can't test that.
10:10:09 <elliott> frerich: You can just spawn new threads for everything; they're really cheap in Haskell.
10:10:18 <elliott> And a lot easier to reason about than select()-style setups.
10:10:37 <nand`> that reminds me, what's the best pair of modules to base a Server-BNC combination off? (Planning to create a variant of IRC with RSA built in)
10:10:38 <frerich> I noticed, and yes - I'm probably spoiled by select()/WaitForMultipleObjects() (on Win32) style event loops.
10:11:00 <elliott> Spoiled? The only reason people use those is because they're fast, not because they're nice to use ;)
10:11:10 <c_wraith> frerich: just use forkIO code to do that in haskell.
10:11:14 <elliott> (Apart from the node.js people but I think they're just trying to convince themselves.)
10:11:29 <c_wraith> frerich: haskell threads use non-blocking IO with a blocking interface
10:11:48 <c_wraith> frerich: which is very similar to what that blog post is describing with callbacks, instead of IO
10:11:53 <ClaudiusMaximus> trying to learn OpenCL - are there some less trivial examples than "map (*2)" available for me to study?  in particular, some folds and scans would be nice
10:11:54 <funktronic> elliott: node.js is just the newest circlejerk
10:12:22 <frerich> Hm, but what if I deal with some package (say, some sort of GUI package) which doesn't tolerate calling functions form different threads. So I have multiple threads which need to 'post events' to the GUI thread, would they 'post' to a common chan or so?
10:12:27 <dmwit> ?tell dcoutts I noticed a cabal bug today. I'd report it, but Trac seems to be down (?). I've got something like "if flag(foo) main-is: foo.hs else main-is: no-foo.hs". When I "cabal sdist", it complains that the file "foo.hsno-foo.hs" doesn't exist.
10:12:28 <lambdabot> Consider it noted.
10:13:12 <c_wraith> dmwit: does it do that if you run cabal configure first?
10:13:13 <elliott> frerich: Yes.
10:13:23 <elliott> frerich: (Note that Haskell thread =/= OS thread.)
10:13:40 <everythingWorks> whats the best way to profile one specific function. I need to compare several functions achieving the same result but on different approaches
10:13:45 <elliott> (But Haskell threads live on multiple OS threads, so you still have to worry about thread-unsafe C libraries.)
10:13:54 <elliott> everythingWorks: criterion?
10:13:56 <c_wraith> everythingWorks: the criterion library
10:14:07 <hpc> if you are worried about unsafe C libs, you can set affinity
10:14:11 <hpc> @hoogle affinity
10:14:11 <lambdabot> No results found
10:14:20 <cgroza> :t (=/=)
10:14:21 <lambdabot> Not in scope: `=/='
10:14:29 <ceii> :t (/=)
10:14:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:14:35 <hpc> well, there's a function somewhere that lets you set what OS threads an RTS thread will run on
10:16:22 <tommd> hpc: The closest (and not what you asked for) that I know is forkOnIO.
10:17:24 <tommd> oh, misread.  You claimed there is such a function somewhere.  Neat.
10:18:37 <hpc> tommd: that actually might be what im thinking of
10:19:30 <tommd> The documentation for threadStatus only says the thread can be locked to a particular capability via the forkOn function.  It doesn't mention another way.
10:19:39 <tommd> That's a good feature request for GHC HQ though.
10:21:06 <CodeWeaver> And for my next trick, I'm downgrading from xcode 4.2 to xcode 4.1 in order to hopefully cure a completely inexplicable crash when building some projects.
10:21:11 <CodeWeaver> *grumblespit*
10:22:52 * hackagebot GLFW 0.5.0.1 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.0.1 (PaulLiu)
10:23:10 <bfig> is there a datatype for the extended real line ?
10:23:36 <ziman> @index Char -> Int
10:23:37 <lambdabot> bzzt
10:23:58 <ceii> @hoogle Char -> Int
10:23:59 <lambdabot> Data.Char digitToInt :: Char -> Int
10:23:59 <lambdabot> Data.Char ord :: Char -> Int
10:23:59 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
10:24:13 <ziman> thanks :)
10:24:15 <everythingWorks> thanks :D
10:27:28 <hpc> bfig: data EReal = Finite CReal | Infinity | NegInfinity -- Num instance is an exercise for the reader
10:27:28 <yrlnry> What might be a good thing to read if I think I'm interested in universal algebra?  I already know a bunch of abstract algebra and category theory.
10:28:20 <bfig> hpc, bah i was hoping i didn't have to implement... :|
10:30:54 <hpc> bfig: on a more serious note, i can't find anything on hackage either
10:31:08 <hpc> so i suppose you're stuck with doing it yourself
10:31:59 <bfig> ok, thanks :)
10:32:04 <bfig> couldn't find it myself either :(
10:32:28 <elliott> You could just make a data type to add infinities and use (Inf Double), right?
10:33:05 <elliott> I guess that isn't technically any easier.
10:33:14 <ClaudiusMaximus> > isFinite (1/0)
10:33:15 <lambdabot>   Not in scope: `isFinite'
10:34:50 <matthiasgorgens> @djinn (a -> b -> m c) -> m a -> b -> m c
10:34:50 <lambdabot> -- f cannot be realized.
10:35:01 <matthiasgorgens> @djinn Monad m => (a -> b -> m c) -> m a -> b -> m c
10:35:02 <lambdabot> -- f cannot be realized.
10:36:35 <elliott> matthiasgorgens: f <$> a <*> pure b
10:36:49 <hpc> elliott: if he's going to use Double, he already has infinities
10:36:51 <hpc> > 1/0
10:36:52 <lambdabot>   Infinity
10:37:21 <elliott> true
10:37:24 <hpc> bfig: ...actually, is there any reason Double would be inadequate?
10:37:39 <hpc> :t isInfinity
10:37:40 <lambdabot> Not in scope: `isInfinity'
10:37:46 <hpc> @hoogle Double -> Bool
10:37:46 <lambdabot> Data.Generics.Twins geq :: Data a => a -> a -> Bool
10:37:47 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
10:37:47 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
10:38:17 <bfig> hpc, i dunno, i just wanted to write the number of elements in a list
10:38:26 <matthiasgorgens> elliott, actually, I was looking into how to use modifyMVar when the mvar in question has to be read from an environment with `ask'.
10:38:31 <hpc> bfig: ah
10:38:41 <bfig> ie, [0,Inf]
10:39:32 <hpc> sounds like Double will be fine
10:39:43 <hpc> > isInfinite (1/0)
10:39:44 <lambdabot>   True
10:39:56 <Veinor> is there any way to see what the output of the template haskell preprocessing is?
10:40:04 <elliott> matthiasgorgens: You expect a lot of @djinn :P
10:40:12 <elliott> Veinor: -ddump-splices
10:40:44 <hpc> :t modifyMVar <*> ask
10:40:45 <lambdabot> Not in scope: `modifyMVar'
10:41:42 <hpc> :t let modifyMVar = undefined :: (a -> a) -> IORef a -> IO () in modifyMVar f =<< ask
10:41:46 <lambdabot> Not in scope: type constructor or class `IORef'
10:41:50 <hpc> pah
10:42:09 <hpc> matthiasgorgens: some combination of fmap, (=<<), and (<*>)
10:42:20 <matthiasgorgens> hpc, I guess so. ;o)
10:42:37 <hpc> write it the long way and refactor until you get to a short-enough form
10:43:06 <matthiasgorgens> hmm, I'll probably go for a pointful version, anyway.  Now I just have to worry about, how to translate my wrapped reader/state/rpc/IO monad-action into something that modifyMvar will swallow.
10:43:10 <matthiasgorgens> (i.e. IO)
10:47:58 <bfig> hpc, how can i write Infinity? it doesn't seem to work for ghci
10:48:04 <elliott> bfig: (1/0)
10:48:07 <elliott> matthiasgorgens: that's the monad-control problem
10:48:13 <bfig> ok...
10:48:17 <elliott> or rather, the problem that monad-control (among others) tries to solve
10:48:28 <bfig> (i did it that way but i was wondering if i could just write the Infinity or something)
10:48:56 <ion> Infinity is not a data constructor, just something the show instance for floats returns for certain IEEE 754 values.
10:48:57 <elliott> matthiasgorgens: in particular http://hackage.haskell.org/packages/archive/lifted-base/0.1.0.3/doc/html/Control-Concurrent-MVar-Lifted.html#v:modifyMVar
10:49:23 <hpc> bfig: there's no "Infinity" constructor
10:49:28 <hpc> you have to divide by zero, yeah
10:49:34 <ion> > read "Infinity" :: Double  -- the Read instance is symmetric
10:49:35 <lambdabot>   Infinity
10:49:52 <everythingWorks> >3
10:49:53 <ion> But you usually don’t *want* anything to be Infinity. :-P
10:50:06 <bfig> i want the list length to be infinity
10:50:25 <bfig> i'm using a new list representation to create lists with O(1) access times
10:50:32 <marijn`> if I, as an example, declare a class 'Seq s' with a method 'elt :: s a -> Int -> a' -- would it be possible to declare an Int to be an instance of Seq, but only of a Seq of bools (the bits in the int)?
10:50:36 <bfig> see where that takes me
10:50:39 * ion blinks
10:51:10 <nand`> infinite list with O(1) access? sign me up ( ≖‿≖)
10:51:21 <ion> You’re creating a data structure for which the length is measured as a floating point number, and Infinity is a useful value?
10:51:23 <matthiasgorgens> elliott, thanks to the pointer to lifted-base.
10:51:47 <bfig> ion, i just wanted to use the extended real line but apparently a double will do
10:53:02 <nand`> Length Integer | Infinite
10:53:23 <Saizan> marijn`: nope, you'd need class Seq s a where elt :: s -> Int -> a to allow that and you'll likely want a | s -> a fundep, or use type families instead
10:53:58 <marijn`> Saizan: that makes sense. thanks!
10:56:04 <marijn`> Saizan: hm, what would the instance declaration look like in such a case?
10:56:18 <elliott> marijn`: You want type families.
10:56:30 <elliott> class Seq s where type Elt s; elt :: s -> Int -> Elt s
10:56:39 <elliott> instance Seq [a] where type Elt [a] = a; elt = (!!)
10:56:46 <elliott> instance Seq Int where type Elt Int = Bool; elt = ...
10:56:59 <elliott> p.s. Seq is the name of the structure in Data.Sequence, so I would avoid that name
10:57:20 <marijn`> elliott: thanks. the example wasn't real -- i'm just trying to figure out how to express such a thing
10:57:21 <Saizan> marijn`: instace Seq Int Bool where ..
10:57:30 <bfig> nand`, i'd need to implement all operations then :)
10:59:34 <hpaste> “Haskell Noob-wannabe” pasted “Haskell-platform and Repa” at http://hpaste.org/57061
11:01:37 <yrlnry> http://math.berkeley.edu/~gbergman/245/ looks fairly promising for universal algebra.
11:02:19 <elliott> whoever haskell noob-wannabe is: new repa requires ghc 7.2
11:02:28 <elliott> nothing's wrong with the platform
11:02:38 <elliott> also, the type system is irrelevant.
11:02:46 <elliott> this is a packaging/ecosystem problem and would exist in any language.
11:03:04 <ion> Why does someone want to be a newbie?
11:05:54 <elliott> I wonder why someone would make a paste under a name not corresponding to an IRC nick and target it at the channel without seemingly looking for any repl.
11:05:56 <elliott> *reply
11:06:32 <ion> Perhaps he wasn’t sure what the channel option does.
11:20:59 <bobry> is cabal capable of installing packages from vcs? i. e. git hg?
11:21:29 <mm_freak> bobry: no, but it can install their local copies
11:21:40 <mm_freak> just switch into the directory where the .cabal file is located and type:  cabal install
11:21:58 <exFalso> good evening, how can one expose data contructors in a data family to other modules?
11:22:10 <bobry> mm_freak: oh, thanks
11:23:53 <Sgeo> I wish I could downvote on SO
11:23:56 <Sgeo> :/
11:24:31 <Sgeo> http://stackoverflow.com/questions/8884615/can-circular-lists-be-defined-in-erlang
11:24:43 <Sgeo> The top answer makes me facepalm
11:25:02 <Sgeo> Later, I'll write some circular list thing for Erlang that doesn't rely on mutability like the other stuff does
11:30:07 <mrotondo> hi LukeXI
11:30:26 <LukeXI> Hi mrotondo
11:36:54 <bfig> how do i load a package module to ghc?
11:36:56 <roconnor> Sgeo: how do you do with without laziness and without mutability?
11:37:00 <roconnor> Sgeo: callcc?
11:37:20 <frerich> I think it's pretty amazing to what degree you can finish writing your program, without actually writing any code. Just by having type signatures and 'undefined'. :-)
11:37:25 * frerich starts to enjoy this
11:37:27 <maurer> bfig: Be more specific. Packages and modules are different, and you likely don't want to load it into ghc, possibly ghci? Possibly some program you've written?
11:37:39 <bfig> ghci yes,
11:37:40 <tommd> bfig: 'import' works with newer GHCi repls.  Use ":m Some.Module" for older GHCi versions.
11:37:43 <bfig> i want to get unfold
11:37:56 <tommd> you mean "unfoldr"?
11:38:01 <tommd> It's in the prelude.
11:38:03 <bfig> ahh dammit :p
11:38:10 <ddarius> @google cardelli typeful programming
11:38:13 <lambdabot> http://www.daimi.au.dk/~madst/tool/papers/typeful.pdf
11:38:13 <lambdabot> Title: Typeful Programming
11:38:25 <Sgeo> roconnor, make the tail be a function
11:38:33 <Sgeo> Fake laziness
11:39:01 <bfig> thanks, m worked
11:39:06 <bfig> but ih ave ghci version 7.xx
11:39:16 <tommd> :m works on newer GHC's too.
11:39:37 <roconnor> Sgeo: that will use more memory than a proper implementation?
11:39:50 <roconnor> hmm
11:39:53 * roconnor isn't sure
11:40:11 <bfig> well, thanks :)
11:40:29 * Sgeo isn't particularly thinking about efficiency here
11:41:37 <roconnor> ok
11:41:54 <frerich> ddarius: Oooh, thanks for that link!
11:43:00 <roconnor> frerich: TDD?  Type Driven Development?
11:44:04 <frerich> roconnor: I don't really know what it's called, I just made a habit of writing programs with just type signatures and implementing many of the function as 'undefined' (or as compositions of undefined functions) and by now I can actually write large parts of the program without actually writing gory details.
11:44:53 <frerich> Maybe it's my lack of academic education, but it's great to come up with such things and then get a link to a paper which shows that somebody else also thought it's a good idea :-)
11:46:20 <roconnor> frerich: you are going to love epigram 2 when it exists
11:47:19 <elliott> Haha, you said "when".
11:47:51 <roconnor> elliott: I often wish I had access to the dutch world "als" in these situtations
11:48:47 <MarkDBlackwell> Somebody gave me a problem for which the input is a string such as this: (15, 176) (65, 97) (72, 43) (102, 6) (191, 189) (90, 163) (44, 168) (39, 47) (123, 37). In other words, without commas between the tuples. Is this idiosyncratic? or is there any well-known software that uses this format?
11:52:01 <MarkDBlackwell> And they are commas, not dots, so it's not Lisp cons pairs.
11:52:23 <nand`> easiest way to create an n-fold composition of a function? foldl (.) id $ replicate n f
11:53:21 <elliott> nand`: church n f
11:53:26 <elliott> But church isn't standard. :(
11:53:39 <nand`> indeed it isn't :(
11:54:15 <elliott> nand`: "foldl (.)" is probably a bad idea.
11:55:05 * mjrosenb has used foldl (.) before :(
11:55:26 <Sgeo> Is the Y combinator used the same as fix (even if implemented differently)?
11:55:33 <elliott> Yes.
11:55:34 <bfgun> Sgeo, sure
11:55:43 <bfgun> how do i access double2int ?
11:55:45 <Sgeo> Ok
11:55:56 <bfgun> apparently i can't import it from GHC.Float
11:55:59 <roconnor> nand`: I think \n f x -> foldr ($) x $ replicate n f  might be faster
11:56:36 <limetree> why is foldl (.) a bad idea?
11:56:36 <elliott> bfgun: What's double2int?
11:56:39 <elliott> @hoogle double2int
11:56:39 <lambdabot> No results found
11:56:50 <elliott> limetree: foldl is almost always a bad idea
11:56:53 <elliott> you want foldr or foldl'
11:57:06 <roconnor> elliott: foldl is find for defining reverse
11:57:07 <ion> bfgun: Do you mean floor?
11:57:08 <roconnor> @src reverse
11:57:08 <lambdabot> reverse = foldl (flip (:)) []
11:57:09 <elliott> in this case, probably foldr
11:57:13 <elliott> roconnor: indeed
11:57:15 <elliott> that's the "almost" part :)
11:57:35 <roconnor> anyhow, foldr ($) x $ replicate n f is the way to go in this case IMHO.
11:58:15 <roconnor> mostly because it uses foldr instead of foldl :P
11:59:15 <ion> > (ala Endo Data.Foldable.Foldmap . replicate 5) succ 0
11:59:16 <lambdabot>   Not in scope: data constructor `Data.Foldable.Foldmap'
11:59:23 <ion> > (ala Endo Data.Foldable.foldMap . replicate 5) succ 0
11:59:24 <bfgun> elliott, GHC.Float has that function
11:59:24 <lambdabot>   5
11:59:50 <bfgun> hidden inside at least
11:59:52 <elliott> bfgun: What are you trying to do?
12:00:00 <bfgun> float->Int
12:00:02 <elliott> IF you want to turn a Double into an Int, use round or floor or ceiling or truncate.
12:00:06 <elliott> *If
12:00:10 <bfgun> gonna go with floor i guess
12:00:16 <elliott> ion++
12:00:41 <Sgeo> In languages other than Haskell, does "circular list" have any meaning other than a list that, after you go past the last element, you're in the first element?
12:01:04 <CodeWeaver> Isn't that more or less a universal definition>
12:01:11 <CodeWeaver> I mean, its a list.. its in a circle.
12:01:21 <roconnor> Sgeo: well really there is no notion of first or last in a circular list
12:01:28 <ion> In LOGO, it may mean an actual circular list.
12:01:38 <elliott> "Circular list" is usually used to mean "a list with a tail pointer to an element earlier in the list".
12:01:52 <elliott> i.e. a Haskell interpreter without sharing wouldn't make (repeat 1) circular.
12:02:03 <CodeWeaver> hahaha
12:02:04 <roconnor> floor is an adjuction to fromIntegral :: Int -> Double.
12:02:07 <CodeWeaver> I started playing with Logo yesterday.  Got mergesort working in less than an hour given my haskell knowledge.  Then went on to turtlegraphics, and made a fractal snowflake.
12:02:10 <roconnor> so is ceiling
12:02:24 <roconnor> I guess floor and ceiling are right/left adjoints?
12:02:43 <akosch> could someone give me an example where the listT monad transformer would be useful?
12:02:58 <ion> And round is the middle adjoint? :-P
12:02:59 <c_wraith> akosch: you mean if it worked correctly?
12:03:08 <akosch> c_wraith: it doesn't?
12:03:16 <roconnor> akosch: anywhere you want non-deterministic backtracking
12:03:19 <c_wraith> akosch: it's too strict
12:03:36 <c_wraith> You can treat it as a backtracking monad, but LogicT is better for that
12:03:46 <c_wraith> ListT is certainly simpler
12:04:07 <roconnor> ion: heh
12:04:17 <akosch> thanks, I really couldn't imagine anything
12:04:20 <roconnor> clearly round is bad because it isn't adjoint to anything
12:04:27 <lpsmith> is there a builder for the text type?
12:04:52 <donri> lpsmith: perhaps you want one of the pretty printer packages?
12:05:16 <lpsmith> donri, not in this particular case, I don't think so
12:05:20 <roconnor> @check \(x::Double) (y:Int) -> (floor x <= y) == (x <= fromIntegeral y)
12:05:20 <lambdabot>   Parse error in pattern at "(y:In..." (column 14)
12:05:25 <roconnor> @check \(x::Double) (y::Int) -> (floor x <= y) == (x <= fromIntegeral y)
12:05:26 <lambdabot>   Parse error in pattern at "(y::I..." (column 14)
12:05:49 <nand`> it's Integral not Integeral
12:06:04 <ion> @check \ (x::Double) (y::Int) -> (floor x <= y) == (x <= fromIntegral y)
12:06:05 <lambdabot>   Parse error in pattern at "(y::I..." (column 15)
12:06:18 <roconnor> @check \x y -> (floor x <= (y::Int)) == ((x::Double) <= fromIntegral y)
12:06:19 <lambdabot>   "Falsifiable, after 1 tests:\n1.5\n1\n"
12:07:14 <roconnor> @check \x y -> (fromIntegral x <= (y::Double)) == ((x::Int) <= floor y)
12:07:15 <lambdabot>   "OK, passed 500 tests."
12:07:27 <roconnor> @check \x y -> (ceiling x <= (y::Int)) == ((x::Double) <= fromIntegral y)
12:07:28 <lambdabot>   "OK, passed 500 tests."
12:07:41 <roconnor> so ceiling -| fromIntegral -| floor
12:07:48 <roconnor> I guess
12:08:37 <roconnor> copumpkin: are you writing this down? :P
12:08:54 <copumpkin> huh?
12:09:11 <ddarius> roconnor: Now you can consider Galois connections in the divisibility order.
12:09:21 <rwbarton> and find out what gcd 0 0 is
12:09:28 <hpc> > gcd 0 0
12:09:29 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
12:09:29 <elliott> > gcd 0 0
12:09:30 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
12:09:33 <elliott> Or IS IT?
12:09:36 <roconnor> copumpkin: the ceiling, fromIntegral, floor adjunctions
12:09:54 <copumpkin> oh, sure, but why me? :P
12:10:01 <_Mikey> is there a prelude function that will remove tuples which are a permutation of previous tuples in a list, from a list.
12:10:14 <roconnor> copumpkin: I thought you were into this sort of thing with me :)
12:10:22 <copumpkin> oh yes, I am!
12:10:39 <hpc> @hoogle (a,b) -> (b,a)
12:10:39 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
12:10:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:10:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
12:11:02 <hpc> _Mikey: filter (\x y -> x == y || swap x == y)
12:11:09 <hpc> er
12:11:17 <hpc> nubBy (that function)
12:11:22 <ion> > Data.Tuple.swap (0,1) -- Oh, it seems lambdabot has been updated at some point.
12:11:23 <lambdabot>   Not in scope: `Data.Tuple.swap'
12:11:26 <_Mikey> yea that looks aweoms hpc
12:11:28 <ion> -- Oh, it seems it hasn’t.
12:11:33 <roconnor> @check \x y z -> (x `div` y <= (z::Int)) == ((x::Int) <= z * y)
12:11:34 <lambdabot>   "*Exception: divide by zero
12:11:39 <yarou> @hoogle levels
12:11:39 <lambdabot> Data.Tree levels :: Tree a -> [[a]]
12:11:39 <lambdabot> Graphics.UI.GLUT.Objects type NumLevels = GLint
12:12:17 <elliott> ion: don't be silly
12:12:21 <roconnor> ddarius: oh opps, you said divisibility order, not division operation
12:12:22 <elliott> why would @hoogle use the same database as >?
12:12:29 <elliott> or @src?
12:12:31 <elliott> that would be _logical_
12:13:23 <hpc> src is a text file and some grepping; hoogle searches all of hackage; mueval uses a safe subset of imports
12:13:34 <hpc> @hoogle unsafePerformIO
12:13:35 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:13:35 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:13:37 <ddarius> We'll run lambdabot on a LindOS X machine so that every package can be installed.
12:13:42 <ion> I *wish* Hoogle searched all of Hackage.
12:13:47 <hpc> ^ pretty glad hoogle and run aren't the same
12:13:52 <hpc> also what ion said lol
12:14:13 <hpc> ddarius: and just for fun, using a reduceron CPU?
12:15:34 <roconnor> ddarius: right-adjoints preserver products, so floor(a*b) = floor(a)*floor(b) ?
12:16:06 <ddarius> roconnor: No.  (*) isn't the product in the normal ordering of integers or reals.
12:16:14 <roconnor> oh right
12:16:26 <roconnor> it woudl be max or min
12:16:33 <roconnor> probably max
12:17:11 <roconnor> max looks product like.  It is denoted by a wedge
12:18:02 <Saizan> c <= a, c <= b iff c <= a`op`b
12:19:01 <elliott> roconnor: operator-based reasoning, that's true science
12:19:02 <roconnor> Saizan: that looks more coproduct like
12:19:30 <roconnor> a <= c, b <= c iff a `op` b <= c
12:19:55 <Saizan> well, i guess it depends how you point your arrows
12:20:02 <roconnor> a morphism from a to b uniquesly when a <= b
12:20:20 <roconnor> arrows clearly go the opposite directly from how the <= points
12:20:39 <Saizan> then mine is the product unless i'm going mad
12:20:45 <roconnor> > True <= False
12:20:46 <lambdabot>   False
12:20:53 <roconnor> > Flase <= True
12:20:54 <lambdabot>   Not in scope: data constructor `Flase'
12:20:58 <roconnor> > False <= True
12:20:59 <lambdabot>   True
12:21:16 <roconnor> see, True doesn't imply False but False does imply True
12:21:25 <roconnor> so (<=) means implies
12:21:43 <ddarius> What roconnor means to say is that <= means =>.
12:22:10 <Saizan> yeah
12:22:16 <Saizan> ?type (&&&)
12:22:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:22:59 <roconnor> Saizan: oh hmm
12:23:14 <ion> > [ (a,b,a<=b,a<b,a>b,a>=b) | a <- [False,True], b <- [False,True] ]
12:23:15 <lambdabot>   [(False,False,True,False,False,True),(False,True,True,True,False,False),(Tr...
12:23:27 <roconnor> Saizan: I see you are right
12:24:11 <roconnor> Saizan: so that makes `min` the product
12:24:25 <Saizan> seems so
12:25:11 * elliott likes how all of this has happened because someone wanted to convert a Double to an Int.
12:26:01 <roconnor> elliott: clearly the solution to any question of how to converty X to Y starts by asking how do you convert Y to X and then consider an adjuction.
12:26:08 <elliott> :D
12:26:15 <elliott> Recursively.
12:26:20 <roconnor> :O
12:27:04 <nand`> elliott: it's easy, just define your function on the cocategory of Hask and pixie dust will work its magic for you
12:29:15 <mjrosenb> does cabal-install know about .h files installed with macports?
12:30:50 <roconnor> Saizan: okay so floor preserves min since it is a right-adjoint: floor (a `min` b) = floor a `min` floor b
12:31:04 <elliott> @check \a b -> floor (a `min` b) == floor a `min` floor b
12:31:05 <lambdabot>   "OK, passed 500 tests."
12:31:13 * elliott was hoping for floating point weirdness.
12:31:30 <roconnor> @check \a b -> floor (a `max` b) == floor a `max` floor b
12:31:31 <lambdabot>   "OK, passed 500 tests."
12:32:01 <Saizan> mjrosenb: there's --extra-include-dirs otherwise
12:32:31 <nand`> How reliable is @check? What are the odds it just didn't happen to randomly generate the one in a million combination that may break the lambda?
12:32:31 <ion> @check \a b -> (floor (a `min` b) == floor a `min` floor b) `const` (a :: Float, b :: Float)  -- how about with less precision?
12:32:32 <lambdabot>   "OK, passed 500 tests."
12:33:14 <ion> @check \a' b' -> let a = (a' :: Float) * 10e10; b = (b' :: Float) * 10e10 in floor (a `min` b) == floor a `min` floor b
12:33:15 <Taneb> What's the s in ST s a?
12:33:15 <lambdabot>   "OK, passed 500 tests."
12:33:34 <Axman6> Taneb: the secret to making it work
12:33:40 <Saizan> nand`: it makes 500 tests
12:34:15 <Axman6> > 1/998001 :: CReal
12:34:16 <lambdabot>   0.000001002003004005006007008009010011012
12:34:25 <nand`> Saizan: yeah, but does it just use random data or does it use magic to try and generate an input that breaks your functions?
12:34:32 <elliott> Taneb: it's nothing at all: it just exists so that all the operations on the same collections of variables have to be in the same "s"
12:34:34 <elliott> :t runST
12:34:34 <lambdabot> forall a. (forall s. ST s a) -> a
12:34:35 <Axman6> > showCReal 100 (1/99980001)
12:34:36 <lambdabot>   "0.000000010002000300040005000600070008000900100011001200130014001500160017...
12:34:37 <Saizan> nand`: just random data
12:34:43 <elliott> and so that runST can make sure you're not breaking the rules by not letting you depend on any particular "S"
12:34:44 <elliott> *s
12:34:51 <Saizan> nand`: the arbitrary instance decides the distribution
12:35:08 <mjga> elliot: am I stupid, or does runST break automatic type inference and forces you to declare them
12:35:39 <elliott> mjga: Things can't always be inferred with runST I think, but what is the specific problem you're having?
12:35:41 <keep_learning> hello all
12:35:50 <roconnor> mjga: it wouldn't suprise me since runST is rank-2 polymorphic.
12:36:06 <elliott> > runST (do { s <- newSTRef 42; readSTRef s })
12:36:07 <lambdabot>   can't find file: L.hs
12:36:09 <elliott> > runST (do { s <- newSTRef 42; readSTRef s })
12:36:10 <lambdabot>   42
12:36:13 <elliott> So it can certainly infer some cases.
12:36:34 <Saizan> GHC's type inference can act fairly weirdly in the presence of runST
12:36:48 <Sgeo> Why did it not work the first time?
12:36:52 <keep_learning> Could some one please tell me what does the combineP   works ( http://hackage.haskell.org/packages/archive/dph-par/0.5.1.1/doc/html/Data-Array-Parallel.html )
12:36:55 <mjga> elliot: got something crashing due to runST (likely) and unsafeFreezeVector, so I changed a wee bit, and code no longer gets thru inference:
12:36:58 <mjga> elliot: test_List.hs:19:32:
12:36:58 <mjga>     Kind incompatibility when matching types:
12:36:58 <mjga>       t0 :: (* -> *) -> * -> *
12:36:58 <mjga>       ST :: * -> * -> *
12:36:58 <mjga>     Expected type: a0 -> ST s (TempList s a0)
12:36:59 <mjga>       Actual type: a0
12:37:01 <mjga>                    -> t0 m0 (TempList (Control.Monad.Primitive.PrimState m0) a0)
12:37:03 <mjga>     In the return type of a call of `add'
12:37:05 <mjga>     In the first argument of `mapM_', namely `(add tl)'
12:37:07 <mjga> test_List.hs:19:32:
12:37:09 <mjga>     Kind incompatibility when matching types:
12:37:11 <mjga>       m0 :: * -> *
12:37:13 <mjga>       s :: *
12:37:17 <mjga>     Expected type: a0 -> ST s (TempList s a0)
12:37:19 <Enigmagic> AHHHHHHHHHHHHHH
12:37:19 <mjga>       Actual type: a0
12:37:20 <elliott> @where ops
12:37:20 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
12:37:21 <mjga>                    -> t0 m0 (TempList (Control.Monad.Primitive.PrimState m0) a0)
12:37:23 <mjga>     In the return type of a call of `add'
12:37:25 <mjga>     In the first argument of `mapM_', namely `(add tl)'
12:37:36 --- mode: ChanServ set +o Cale
12:37:37 <elliott> mjga: in future please use http://hpaste.org/
12:37:39 <c_wraith> Sgeo: can't find L.hs means that it needed to recreate its environment
12:37:43 <keep_learning> I am not able to find the documentation for this function
12:37:47 <Cale> oh, it's over :P
12:37:50 --- mode: Cale set -o Cale
12:37:53 * Sgeo hpastes mjga 
12:37:56 <mjga> ok :-)
12:38:45 <Axman6> mjga: as a general rule, 5 lines is the absolute maximum you should ever past to an IRC channel
12:38:45 * Sgeo was about to ask if anyone would be mad if mibpaste was used, but that's... not really a concern here
12:38:47 <mjga> sorry :-(
12:39:01 <mauke> Axman6: bad advice
12:39:10 <mauke> there are channels that will kick you for 2
12:39:10 <Axman6> too much? =)
12:39:12 <elliott> 5 is a bit high
12:39:21 <elliott> 2 is about as far as I'd go
12:39:33 <Axman6> thats why i made an absolute maximum. i didn't say it held for all channels
12:39:45 <mauke> as a general rule, don't paste into irc channels
12:40:27 <mjga> ok, looks like I played on strange channels before - nobody minded. Sorry anyway!
12:41:26 <Axman6> strange channels indeed
12:42:18 <mjga> so question is: what is best way to accumulate result over parsing (may be destructive), and then freeze result and sell it as immutable. Obviously my use of ST led to crashes, which are not exactly what I wanted, or to straining type system.
12:42:31 <elliott> rules have to change a bit when you have 874 people wanting to show code :)
12:42:43 <elliott> mjga: You ran into a crash with ST?
12:42:49 <elliott> That's a GHC bug, you should report it.
12:42:57 <elliott> But you probably want StateT.
12:43:26 <Axman6> things should not crash (unless you use unsafeCoerce, the FFI.., or IO at all :P
12:43:42 <napping> if you want to work on a mutable array and then freeze it, runST is the way to go
12:44:13 <Axman6> or runSTArray
12:45:43 <mjga> the only thing unsafe I used was unsafeFreezeVector to get MVector -> Vector before returning it from ST monad. obviously bad enough?
12:45:45 <napping> something like StateT works fine for accumulating a result, it's just not really mutation
12:46:15 <Enigmagic> unasfeFreezeVector should be fine as the last op in a ST
12:46:21 <aristid> Axman6: runSTArray is unsafe?
12:46:35 <aristid> mjga: there's unsafe right in the name!
12:47:15 <napping> aristid: no, runSTArray may be cleaner that using runST directly, if you want to build up a mutable array and then freeze it
12:47:53 <napping> mjga: I think the only "unsafe" with unsafeFreezeVector is if you continue to use and modify the MVector afterwards. Could you paste the code?
12:47:57 <elliott> mjga: hpaste your code?
12:48:07 <elliott> napping: Nooooo, hpaste, hpaste, not paste ;)
12:48:08 <mjga> yeah, I just wonder how to make freezing multiple arrays safe...
12:48:25 <mjga> hpaste sure, just the code is a bit big, so I wonder how to abstract it
12:48:57 <napping> might as well paste what you have
12:48:58 <Enigmagic> you could rule it out by using freezeArray but i doubt it would lead to crashes either way
12:49:20 <elliott> That won't work for an MVector.
12:50:05 <mjga> Vector is there as fast collection with random acces
12:50:53 <mjga> napping: 3308 lines?
12:51:11 <nand`> Has anybody used leksah?
12:51:57 <napping> hpaste it, then try to make a minimal example?
12:52:03 <CodeWeaver> I've tried.  Keeps crashing in OSX on my box.  Not sure why, probably because I'm using 7.2.2 instead of 7.0.1 like it expects.
12:52:11 <CodeWeaver> I've used it before, though, and I found it pretty reasonable.
12:52:26 <mjga> napping: just trying to do it.
12:52:35 <nand`> some of its features soudn really neat
12:52:56 <napping> I was just going to start by looking over the imports and grepping for unsafe things
12:52:57 <nand`> I'm running into the limits and bottlenecks of my plaintext editor as I try writing larger haskell programs
12:53:16 <mjga> it basically parses expressions of the type: {.....[....]..[..(.).]....[(.)(..)]...}, where I want to put each braced span into a vector.
12:53:23 <CodeWeaver> I understand there's also a plugin for the Eclipse IDE for haskell.
12:53:36 <CodeWeaver> I haven't gotten that to work either, yet.  But it looks promising.
12:53:53 <nand`> For Emacs as well it seems, but it's less of an IDE from what I hear
12:55:25 <nand`> I'm mainly excited about debugging and GHCi integration, having to constantly tab to some term and :l my file to see if it even typechecks gets old fast, and the scratchpad should help get rid of my 10+ ghci instances that I launch whenever I want to test some idea quickly
12:55:38 <hpaste> mjga pasted “segfaulting vector creation thru unsafeFreeze” at http://hpaste.org/57071
12:56:01 <napping> nand`: the emacs mode will do at least that much
12:56:18 <napping> C-c C-l to reload in ghci
12:56:36 <Sgeo> What about if GHCi needs to be given some options before it starts
12:56:55 <mjga> that's not too much of it now :-)
12:58:37 <napping> Sgeo: I don't know about that - pragmas work, of course
12:59:06 <elliott> Sgeo: Like what?
12:59:07 <elliott> You can uset :set.
12:59:09 <elliott> *use
12:59:20 <Sgeo> Telling GHCi that it needs to dynamically link a library
12:59:30 <elliott> nand`: but yeah, haskell-mode's ghci integration is great
13:00:33 <napping> mjga: how do you run that code?
13:01:44 <elliott> mjga: I don't see any "unsafe" in your code.
13:02:06 <elliott> Also, I don't think {-# Unpack #-} does anything.
13:03:58 <napping> elliott: according to the user's guide, case is ignored
13:04:33 <napping> It's usually spelled UNPACK
13:05:12 <elliott> huh
13:07:20 <napping> mjga: that code doesn't compile - no "j" or "l" in scope in the definition of add
13:10:32 <frerich> Hm, a little question a colleague just asked and which I couldn't answer myself: in 'f (x:[]) = x', why are the parens needed? How would it get parsed otherwise?
13:11:13 <Saizan> (f x):[] = x
13:11:24 <mauke> and that's why I put spaces around operators
13:12:55 <CodeWeaver> Every operator is essentially lower-precedence to 'space', which is effectively function call.
13:13:14 <Saizan> not that "(f x):[] = x" would be a valid definition, but it's more consistent to parse that way and reject rather than try to extrapolate a meaningful one
13:14:56 <ksion> Err... I get missing dependency 'json -any' when doing `Setup.hs build` on .cabal with Build-Depends: json, but `cabal install json` says the package is already installed...
13:15:25 <Saizan> ksion: have you configured with --user?
13:15:33 <hpaste> mjga pasted “out of memory runST with MVector” at http://hpaste.org/57072
13:15:46 <Saizan> also, you could use "cabal install" instead of the Setup script
13:16:11 <mjga> I changed a wee thing, and now it does not segfault, just gives out of memory during QuickCheck...
13:16:19 <ksion> Saizan: Indeed, I forgot the --user
13:17:05 <copumpkin> mjga: it's probably generating a huge array...
13:18:10 <ddarius> "What do you mean I can't have an array with 9223372036854775808 elements?"
13:18:32 <mjga> yeah, probably huge array, just didn't expect it to actually use that memory, then it would be left unallocated by Linux since I ignore it later anyway
13:19:01 <mjga> yeah, probably cannot overcommit that much :-)
13:23:27 <mjga> altough using abs (i `rem` 2^16) probably fixes the problem?
13:25:13 <akosch> if I have a stream of events and multiple event-handlers, what's a good way to pass control from one to another? For example handler1 gets event5 and decides that handler2 should take it from here (could work vice versa): how would I model this? I want to keep the handlers in different modules, because the're fairly big.
13:25:21 <napping> `mod` always returns a positive result
13:25:54 <napping> but a mod like that sounds like you are trying to make a hashtable
13:28:26 <Saizan> akosch: make them take the other handlers are parameters? maybe in a record type
13:28:50 <hpaste> mjga pasted “panic: ghc 'impossible' happened” at http://hpaste.org/57074
13:29:49 <napping> mjga: the argument to grow is the number of elements to add
13:30:01 <mjga> I do not make claims about correctness of this code, but it made me experience many interesting adventures: segfault, ghc compile-time panic with 'impossible', and also ghc runtime error with wrong closure type. Everything in a mere hour.
13:30:23 <napping> using M.length means the size tries to double every time you call add, quickly running out of memory
13:30:44 <akosch> Saizan: hm, haven't thought of that
13:31:33 <napping> what version of ghc?
13:32:07 <mjga> that is a trick: if you double memory for the array each time, then you have amortized constant allocation time
13:32:14 <napping> an "impossible" should always be reported, but it's nice to check the latest version
13:32:39 <mjga> you mean ghc-7.2 or 7.4?
13:33:21 <mjga> I used 7.0.4
13:33:35 <mjga> latest recommended with current Haskell Platform
13:33:50 <akosch> Saizan: it's hard to get back to the "functions are data" mentality after coding PHP all day :(
13:35:15 <hpc> akosch: that's why you program in perl all day
13:35:19 <hpc> everything is strings!
13:35:31 <napping> 7.0.4 is a good version to work with, but 7.2.2 is the latest release
13:36:12 <akosch> hpc: yeah, at least pearl goes all the way (compared to PHP)... :)
13:37:30 <akosch> hpc: http://www.php.net/manual/en/language.pseudo-types.php#language.types.callback
13:37:34 * akosch shrugs
13:37:37 <hpc> (perl isn't that far gone; it does let you do cool things with function pointers)
13:38:06 <mjrosenb> hrmm, cabal install darcs failed :(
13:38:37 <akosch> hpc: like concatenate their names and get a function? ;)
13:39:04 <elliott>  
13:39:07 <elliott> oops
13:39:15 <mauke> hpc: how is everything strings in perl?
13:39:20 <hpaste> bfig pasted “error” at http://hpaste.org/57075
13:39:22 <elliott> hpc: Everything is strings is Tcl.
13:39:25 <hpc> it isn't, i was being sarcastic
13:39:55 <hpc> akosch: oh god, you believed me? you must deal with lots of php
13:40:04 <hpc> get a new job and restore your faith in programming languages :P
13:40:39 <akosch> hpc: no, I actually use perl sometimes
13:41:09 <akosch> hpc: they got cpan right, that's for sure
13:42:25 <sbi> perl uses me too sometimes
13:42:40 <akosch> sbi: and you feel violated afterwards? :)
13:42:48 <sbi> akosch, sure i do
13:43:01 <napping> mjga: with 7.2.2 I get some type errors rather than an "impossible"
13:43:24 <bfig> what's happening in line 16? it's complaining :|
13:43:48 <akosch> sbi: http://www.catonmat.net/blog/wp-content/uploads/2008/11/larry-wall-quick-and-dirty.jpg
13:43:53 <bfig> iListLib.hs:17:25: parse error (possibly incorrect indentation)
13:44:36 <Axman6> bfig: you're using tabs
13:44:40 <Axman6> don't do that
13:44:44 <bfig> dammit >_>
13:45:00 <Axman6> and a horrible mix of tabs and spaces too
13:45:06 <bfig> i was using them consistently but i copypasted from hpaste
13:45:38 <nand`> I recommend setting up an editor to auto-convert tabs to two spaces
13:45:47 <Axman6> your life will be a lot easier if you set your editor to insert spaces instead of tabs
13:45:52 <mjga> napping: thx, will try
13:45:57 <ddarius> Clearly tabs should be 8 spaces.
13:46:07 * Axman6 uses 4 spaces
13:46:25 <mjga> wanted to try snapshot, but this doesn't seem to build HP
13:46:30 <nand`> I use 4 spaces for every other language, but in haskell I use 2 spaces since I like to indent “where” by one tab and then the lines below that by another
13:46:39 <Axman6> ddarius: well, so speaketh the report
13:46:40 <nand`> or similar
13:47:07 <akosch> ddarius: are you using unix?
13:47:32 <bfig> i'm using vim
13:48:29 <akosch> bfig: http://stackoverflow.com/questions/1675688/make-vim-show-all-white-spaces-as-a-character
13:48:32 <napping> I don't know about the platform, but the dependencies of your example build fine
13:49:43 <napping> the hackage version of cabal-install doesn't build with 7.2.2
13:50:22 <mjga> btw, since I have such a 'gift' for getting a different type of error every time: how to find quickly what is on a GHC stack, when it says that stack has overflown?
13:51:44 <mjga> I occasionally have a problem getting stack overflows, or memory is gone, but RTS doesn't seem to write any idiot-proof helpful message in this case. I mean something like Python's idea to just dump all the stack frames that are there, before they are gone
13:52:51 <bfig> akosch, awesome!!! :D
13:53:01 <bfig>  :set list :)
13:53:11 * hackagebot midi-alsa 0.1.3 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.1.3 (HenningThielemann)
13:53:17 <elliott> mjga: -xc sometimes helps (you must build with profiling)
13:53:19 <elliott> @where rts-xc
13:53:19 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
13:53:52 <nand`> elliott: do you know if haskell-mode works on windows, assuming I can get my hands on a working windows clone of emacs?
13:54:39 <akosch> bfig: it takes some time to get used to, but it's worth it if you're dealing with sloppy people's code all day
13:55:04 <elliott> nand`: yes
13:55:19 <elliott> nand`: http://ourcomments.org/Emacs/EmacsW32.html is meant to be decent IIRC
13:55:27 <bfig> i'm used to working with awfully formatted word documents (even if they're well formatted) with non printable characters visible, it is not a problem
13:55:33 <elliott> It's not really "clone" you're looking for so much as "build", Emacs supports Windows :P
13:55:44 <bfig> how do you remove it?
13:56:06 <akosch> bfig: set nolist ?
13:56:28 <bfig> cool :)
13:58:08 <tech2> if you set it up well enough you can have it showing only trailing spaces and actual tab characters, specially formatted, I use that mostly for python code.
13:59:15 <nand`> why not just remove trailing spaces
13:59:27 <nand`> cannot think of a situation in which you'd need them, other than programming in WHITESPACE
14:00:22 <bfig> well, now that the problem of whitespace has been solved, the real problem shows
14:00:25 <tech2> nand`: I work in a team of 20, making random whitespace changes when I'm not dealing with a particular area of code is frowned upon (makes checking reviews a problem and can lead to spurious merge conflicts), so I get rid of them as and when I can/
14:00:37 <nand`> elliott: knowing RMS I'd guess he would deliberately program emacs to not work on windows natively since it's an enemy of your freedom or something
14:00:46 <akosch> bfig: also, you can change how whitespace is colored to make it less obtrusive and you can choose some nice symbols from :digraphs to avoid mixing them up with actual characters.
14:01:02 <bfig> that sounds great
14:01:15 <bfig>     Could not deduce (RealFrac Int)   |    arising from a use of `helperShowILF'
14:01:19 <akosch> bfig: but this isn't #vim, so I'll stop now :)
14:02:01 <bfig> so, what about that problem, i don't understand
14:04:06 <mauke> bfig: sounds like you're trying to treat an integer as a floating point number
14:05:27 <mjrosenb> is there an easy way to say "start with an IntSet consisting of [0..2^32-1], and apply this filter to it"?
14:05:45 <c_wraith> > (5 :: Int) / 3
14:05:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:05:46 <lambdabot>    arising from a use o...
14:06:19 <bfig> what is RealFrac Int ?
14:06:25 <elliott> mjrosenb: IS.fromList $ filter p [minBound..maxBound]?
14:06:32 <elliott> mjrosenb: but IntSet uses signed keys
14:06:32 <bfig> i mean, in which point i am doing anything that merits treating the number as a floating point number?
14:06:34 <mjga> mjrosenb: do you mean quickcheck?
14:06:36 <elliott> so 2^32-1 you won't get
14:06:39 <mjrosenb> that can immediately give a membership test?
14:06:45 <elliott> bfig: dividing, probably
14:06:49 <mauke> bfig: I don't know, I haven't seen your code
14:06:49 <bfig> ahh floor maybe
14:06:58 <mjrosenb> elliott: well this is a 64 bit system, so Int should be 63 bits?
14:07:04 <mjrosenb> *at least
14:07:13 <mjga> i `rem` 2^32?
14:07:35 <bfig> yeah, that was it :D
14:08:28 <bfig> thanks :)
14:08:30 <mjrosenb> elliott: It looks like with that, I can't to maxBound-1 `member` foo, and expect it to not compute the entire thing
14:09:22 <mjrosenb> s/to/ask for/
14:09:56 <elliott> mjrosenb: True, I guess.
14:10:43 <mjga> mjrosenb: or maybe: import Data.Int; prop_checkFilter :: [Int32] -> Bool
14:11:28 <mjga> the only problem, is that Int32 is signed, so one would have to convert last bit
14:11:50 <mjrosenb> mjga: prop_checkFilter isn't in Data.Int?
14:12:32 <mjga> mjrosenb: I mean to give explicit 32-bit signature to your method that checks filter (with quickcheck)
14:13:03 <mjga> I suppose there is Arbitrary for Int32
14:14:22 <mjrosenb> mjga: wait, how did quickcheck get into this?
14:15:03 <c_wraith> > fromIntegral (minBound :: Int32) :: Word32
14:15:04 <lambdabot>   2147483648
14:15:10 <mjga> mjrosenb: I understood that you want to get random IntSet within bounds of 1..2^(32-1)? don't you?
14:17:10 <mjrosenb> mjga: no, I have a function foo :: Int -> Bool, and I want to get an IntSet that memoizes the results of foo.
14:17:39 <mjrosenb> but it only needs to do so in the range [0..2^32-1]
14:18:12 * hackagebot blaze-builder 0.3.1.0 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.1.0 (SimonMeier)
14:19:20 <nyingen> @quote
14:19:20 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:21:44 <elliott> @hoogle asum
14:21:45 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
14:24:25 <mjrosenb> elliott: actually, that is a good way to think of this, i wish to memoize a function :: Word32 -> Bool
14:25:29 <nand`> hmm
14:25:45 <nand`> I was just wondering about when SublimeLinter will include support for haskell <-> hLint
14:25:53 <nand`> turns out the pull request got submitted just under 2 hours ago
14:26:17 <nand`> must be my lucky day
14:26:42 <elliott> mjrosenb: take a look at the data-memocombinators package
14:26:54 <elliott> mjrosenb: particularly, the integral combinator will construct a tree
14:27:07 <elliott> @hoogle (Alternative f) => f a -> f (Maybe a)
14:27:08 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
14:27:08 <lambdabot> Test.QuickCheck.Gen suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
14:27:08 <lambdabot> Test.QuickCheck suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
14:27:52 <Ngevd> I think I get ST sort of
14:28:20 <Ngevd> It's like a little box for putting some unpure stuff so the program as a whole remains pure?
14:28:29 <Ngevd> Bad analogy, I know
14:28:33 <Sgeo> > runST $ do { mutVar <- newSTRef 0; modifySTRef mutVar (+5); readSTRef mutVar}
14:28:34 <lambdabot>   5
14:28:50 <Sgeo> Ngevd, a particular kind of unpure stuff
14:29:05 <Ngevd> Yes
14:29:19 <napping> mjga: have you got the parser working?
14:29:28 <mjga> not yet...
14:29:40 <napping> have you pasted the full code?
14:30:04 <Ngevd> :)
14:30:06 <Ngevd> Goodnight
14:30:18 <napping> also, it might be easier to use something like Map rather than Vector
14:30:33 <mjga> no, it is really to big. I will try another way...
14:30:41 <napping> how big is it?
14:32:28 <napping> Vector only makes sense if the indices are one dense range of numbers, and if the input is really big enough that the size difference between IntMap and Vector is important, you probably shouldn't be using the boxed Generic Vector either
14:32:36 <exFalso> good evening. if i have a data family how can i expose the data constructors?
14:32:53 <exFalso> * of the instances?
14:34:41 <exFalso> they only seem to be in scope when defining the instances
14:34:59 <elliott> napping++
14:45:51 <exFalso> http://hpaste.org/57081 can anyone explain why C is not in scope?
14:46:38 <mjrosenb> is there any reason that ghci would not immediately return an answer, and is not eating any cpu time?
14:46:57 <exFalso> it probably blocked if its an IO action
14:47:07 <mauke> mjrosenb: optimized loop
14:47:13 <exFalso> or sometimes it detects a loop
14:47:41 <exFalso> it should throw an exception though
14:47:48 <mauke> not in ghci
14:53:06 <Enigmagic> exFalso: module F (T(C)) where
14:53:18 <Enigmagic> you need to give it the class or type name first
14:53:47 <Enigmagic> the error message would be a hint: Not in scope: type constructor or class `C'
14:55:56 <dmwit> c_wraith: cabal configure does not appear to affect the behavior of cabal sdist; would you expect it to?
14:56:31 <c_wraith> dmwit: I wouldn't really expect it to, but I know that at least once I rand cabal sdist and it told me I hadn't configured the project yet.
14:56:45 <c_wraith> err, *ran
14:57:07 <c_wraith> Anyway, it doesn't really make sense for that, so it was probably a strange occurance
15:03:22 <exFalso> Enigmatic: thank you!
15:15:25 <mjga> napping: it took a while, but seems that my parser works now :-)
15:16:42 <mjga> it seems that I may have occasionally desynced growable vector and information of how many seats in the vector are taken, so I converted whole TempList into references, so that both vector and counter were always updated imperatively
15:17:03 <mjga> that worked, since GHC doesn't grok uniqueness typing
15:17:29 <mjga> plus module encapsulation of course
15:18:16 <nand`> anything like hlint that catches syntax errors?
15:18:23 <nand`> or type errors
15:19:29 <Sgeo> Haskell talking to Erlang doesn't mean that the Haskell side should adapt Erlang's conventions of letting it crash, right?
15:20:15 <mjga> Sgeo: right, Haskell doesn't get exceptions well, so crashing is usually going bad...
15:20:34 * Sgeo sent an email to the author of Foreign.Erlang
15:21:12 <Sgeo> .... it was last uploaded at the end of 2008
15:21:19 <Sgeo> So maybe I shouldn't expect a response so soon
15:21:46 <Sgeo> People knew to prefer Maybe over partial functions in 2008, right?
15:22:01 <c_wraith> Not always
15:22:11 <c_wraith> the m pattern was still used back then
15:22:17 <Sgeo> m pattern?
15:23:42 <c_wraith> having the return type of partial functions be "m Foo", where return was used for success cases and fail for failure cases.
15:23:52 <c_wraith> Fortunately, that's gone away
15:24:54 <mjga> well, that would make sense is underlying monad supported somehow "structured" exceptions. but I understand that current approach is that exception send you back to the toplevel IO monad, and may be "imprecise"
15:25:48 <Sgeo> This thing that I'm ticked at is fromErlang :: (Erlang a) => ErlType -> a
15:26:16 <elliott> mjga: What's wrong with Haskell's exceptions?
15:26:29 <elliott> The "imprecise" part is just that (error "a" + error "b") may fail with either "a" or "b".
15:26:50 <Sgeo> Which is a partial function
15:27:17 <Sgeo> Which it has to be able to error, a given ErlType might not be, say, an Int, but it should be a Maybe a that's returned
15:27:22 <mjga> elliot: i sometimes "show" something, and exception breaks it half-way, relatively far from the actual place of error.
15:27:39 <mjga> elliot: like something was buffered, but then lost
15:28:01 <lukish> @pl (\a b c -> [a,b,c])
15:28:01 <lambdabot> (. ((. return) . (:))) . (.) . (:)
15:28:04 <cmccann> > "foo" ++ error "bar"
15:28:06 <lambdabot>   "foo*Exception: bar
15:28:11 <c_wraith> mjga: that's actually likely 100% deterministic, but you're confused by the lazy evaluation model
15:28:23 <elliott> yeah, there's no actual nondeterminism like that
15:28:36 <mjga> c_wraith: may be deterministic, but not precise :-)
15:28:50 * Sgeo backs away from lukish's pointfree code
15:29:07 <elliott> mjga: that is not what "imprecise" means in the context of exceptions
15:29:36 <elliott> what's happening is that "show" is forcing the part with the error; maybe where that happens isn't intuitive to you, but that's an issue of familiarity, not precision
15:30:12 <mjga> I know it sounds bad, but Python exception handling seems more "idiot proof", and gives a jump start at debugging by giving you a complete list of frames on the stack. not to forget that you may isolate any conceptual value by giving try: except: around it.
15:31:17 <c_wraith> mjga: what makes you think haskell has frames on the stack in any way similar to python?
15:31:38 <lukish> @pl (\a b c d e f -> [a,b,c,d,e,f])
15:31:39 <lambdabot> (. ((. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) . (:)
15:31:44 <c_wraith> (it does have a stack, and said stack does have frames.. but it's almost 100% unrelated to function calls)
15:31:45 <lukish> Okay
15:32:12 <mjga> c_wraith: I know it isn't. that's not my point. programming in "less advanced" py-language I can use a model of exception being just another value that may be passed when my program doesn't know what to do
15:32:15 <cmccann> @pl (\a b c d e f -> [f, e, d, c, b, a])
15:32:16 <lambdabot> (((((((flip (:) .) . flip (:)) .) . flip (:)) .) . flip (:)) .) . flip (:) . return
15:32:40 <lukish> @(\a b c -> [c,b,a])
15:32:41 <lambdabot> Unknown command, try @list
15:32:47 <lukish> @pl (\a b c -> [c,b,a])
15:32:47 <lambdabot> (flip (:) .) . flip (:) . return
15:33:25 * cmccann would rather have code that doesn't produce exceptions in the first place
15:33:40 <nand`> you can just use  @pl f a b = [a, b]  etc as well
15:33:46 <mjga> what would be closest to it in haskell, would be probably show you a path of forced thunks within rewriting graph
15:34:10 <elliott> mjga: lukish please don't use those forms
15:34:12 <elliott> argh
15:34:15 <elliott> *lukish:
15:34:29 <nand`> I like to think @pl is short for @perl
15:34:42 <mjga> cmccann: I would prefer to have code that works 100% and on the first run. but my daily practice is of course different. and then it helps when it is easy to handle the exception at any point in the program
15:34:50 <mjrosenb> mjga: that stack could potentially be very very large.
15:35:10 <lukish> elliott: is your SO username "ehird"?
15:35:25 <elliott> yes, I'm ehird on SO :)
15:36:01 <lukish> Impressed of your dynamic
15:36:04 <ion> There should be a @pl that uses a heuristic to determine which version of an expression is the best. Perhaps it’s “f a b c = a <$> b c”, fully pointful and with the infix version of fmap. Perhaps “f a b = fmap a . b” is deemed better. “f = (.) . fmap” should certainly have a worse score.
15:36:08 <lukish> It's really great
15:36:27 <mjga> mjrosenb: but still knowing a part of the rewriting graph near the last forced thunk gives you much quicker debugging. that's why py-language prints it last - so that the most important part is never hidden
15:36:37 <cmccann> elliott, you need to hurry up and get another 26 answers or whatever, join the [haskell] gold badge club
15:36:48 <ion> In fact, perhaps it should be a combination of pointfree and pointful. It would remove and add points until it reaches the best score.
15:36:53 <elliott> cmccann: haha
15:36:59 <elliott> cmccann: quick, ask 26 questions for me!
15:37:01 <elliott> lukish: thanks :)
15:37:44 <cmccann> pf, does it look like I ask questions? I just answer them
15:38:09 <mjga> may be I should just build my binaries with profiling by default, but I can hardly run them with HAT or another debugger by default :-(
15:38:21 <mjrosenb> cmccann: looks like a question to me!
15:39:59 <elliott> mjrosenb: and if cmccann asks it, I know the answer!
15:40:04 <elliott> the perfect crime
15:40:18 <mjrosenb> does either IS.union or IS.unions strictly consume its input?
15:41:25 <elliott> mjga: ghc 7.4 is getting better stack traces, for what it's worth
15:42:27 <mjga> elliot: does it work with Haskell Platform?
15:42:34 <Enigmagic> elliott: if i ever get enough time it might get actual stack traces too
15:42:35 <Enigmagic> https://plus.google.com/u/0/118432899194915702514/posts/bPF9X3s3iM3
15:42:37 <elliott> mjga: 7.4? it's not even released yet :P
15:42:50 <ion> Is there a nice description of the magic GHC uses to do stack traces somewhere?
15:42:58 <elliott> Enigmagic: now *that's* cool
15:43:34 <Enigmagic> elliott: just need to find a month or two to get it working the rest of the way :P
15:43:56 <mjga> so in principle my parser works, and in practice it overflows stack when I try to actually process the results ;-D
15:44:36 <Enigmagic> mjga: if you're trying to prove that the program works you can always bump up the stack limit temporarily
15:44:54 <mjrosenb> or build with optimizations
15:45:13 <mjrosenb> sometimes that removes a whole chunk of nodes from the stack
15:45:42 <Enigmagic> yeah
15:46:02 <mjga> I already tried -O3, and on smaller inputs it works quite snappy
15:46:06 <elliott> -O3 is just -O2
15:46:46 <Enigmagic> mjga: the joys of laziness... is your code up somewhere?
15:47:07 <ion> -O99 -funroll-loops
15:47:23 <Enigmagic> -fadd-strictness
15:47:24 <Enigmagic> :P
15:47:29 <ion> -fgentoo
15:47:37 <elliott> -funroll-function-applications
15:47:41 <elliott> -funroll-all-function-applications
15:47:49 <elliott> (May fail to terminate.)
15:47:53 <ion> heh
15:48:24 <mjga> Enigmagic: thanks for offer, but for now I keep these 3K lines for myself. they will end up on hackage later ;-)
15:49:00 <Enigmagic> mjga: no problem, perhaps i'll go back to doing real work :P
15:49:26 <mjga> don't be so horrid as to remind me about that ;-)
15:49:59 <Enigmagic> i at least write haskell for work :P
15:50:12 <NothingMan65> Hey! I'm trying to modify the fib memoization function from http://www.haskell.org/haskellwiki/Memoization (2) to fit my needs.
15:50:14 <mjga> Enigmagic: sounds gooood
15:50:46 <Enigmagic> most of the time, yes :-)
15:51:16 <mjrosenb> in this: http://pastebin.mozilla.org/1464720 will unions be able to start consuming data before its argument is finished evaluating?
15:51:53 <NothingMan65> I'd like to have a conditional on the fib argument (n).  Something like fib n = if ... then ... else ... and also stop the infinite list with an argument to memoized_fib.
15:52:34 <ion> The example already has a conditional on the argument in the form of pattern matching.
15:52:57 <ion> Why “stop the infinite list”?
15:52:59 <NothingMan65> Okay , so you can use pattern matching in let(s) as well?  Not just in guards and declarations?
15:53:08 <NothingMan65> Because Haskell scares me.
15:53:19 <NothingMan65> At least I'm facing my fears.
15:53:36 <rtharper> NothingMan65: yes
15:53:46 <rtharper> where and let clauses can use pattern matching
15:54:17 <NothingMan65> And, how would I do the equivalent of otherwise before my "in'
15:54:18 <NothingMan65> ?
15:54:38 <mjrosenb> elliott: you wanted to answer questions, here's your chance :-)
15:54:58 <NothingMan65> I suppose just fib n after my conditional which filters out certain n(s) ?
15:55:00 <mjga> mjrosenb: do you gather some "karma"?
15:55:16 <ion> > let f 0 = "foo"; f _ = "bar" in f 42
15:55:17 <lambdabot>   "bar"
15:55:20 <elliott> mjrosenb: I don't see any gold badges on offer! :P
15:55:57 <elliott> NothingMan65: BTW, fib with an infinite list is a bad memoisation strategy.
15:56:22 <elliott> O(n) lookup, which is much worse than a tree (or even better there are sub-linear time algorithms to compute fib), but I suppose you're not going to use this seriously :P
15:56:33 <mjga> not to forget that fib is better computed O(1) from equation ;-D
15:56:36 <NothingMan65> Well, if I get this working, I will follow the rest of the page I suppose.
15:57:03 <elliott> mjga: Arithmetic isn't O(1)! :P
15:57:06 <NothingMan65> Well, I'm just trying to discover memoization in general in Haskell right now.
15:57:17 <elliott> NothingMan65: right, then a list-based solution is reasonable :P
15:57:19 <mjrosenb> mjga: so I have a fun challenge, compute fib (10000000000) :)
15:57:43 <elliott> fib G_64
15:57:58 <elliott> I'll also accept just the last or first 100 digits or so with a proof of correctness.
15:58:05 <elliott> By Monday.
15:58:07 <mjrosenb> elliott: mine will actually fit in most people's swap
15:58:25 <mjrosenb> elliott: last 100 digits shouldn't be difficult?
15:58:41 <mjga> mjrosenb: hoogle "arbitrary precision"
15:58:59 <mjga> > logBase 2 10000000000
15:59:00 <lambdabot>   33.219280948873624
16:00:29 <mjrosenb> mjga: ok?
16:02:07 <elliott> mjrosenb: true
16:02:09 <elliott> first digits only then
16:04:16 <mjga> mjrosenb: my logBase was to indicate that arbitrary precision arithmetic would need circa 2x~33 exponentiation steps for two real numbers, of course number of digits would be a bit large so it depends what accuracy you want
16:05:09 <mjrosenb> mjga: well, since we want an integer result, presumably we want the exact value
16:05:52 <mjga> mjrosenb: then if you go to arb precision or out of int range, then yes you don't get O(1)
16:06:32 <mjrosenb> mjga: well you *need* arbitrary precision
16:06:44 <mjrosenb> mjga: or with a double, you'd get \infty
16:07:00 <mjga> mjrosenb: but I still suspect that about 2*33 multiplications may be faster than 1e10 additions.
16:08:37 <mjga> good night!
16:25:00 <ybit> pal x =  show(x) == reverse (show x)
16:25:12 <ybit> in that, why would pal [1] return false?
16:25:34 <ehuber> show (x)
16:26:05 <copumpkin> > let pal x = show x == reverse (show x) in pal [1]
16:26:06 <lambdabot>   False
16:26:06 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
16:26:07 <ehuber> nevermind!
16:26:19 <copumpkin> > show [1]
16:26:19 <lambdabot>   "[1]"
16:26:22 <elliott> oh boy
16:26:29 <copumpkin> > reverse (show [1])
16:26:30 <lambdabot>   "]1["
16:26:34 <copumpkin> :)
16:26:45 <alistra> what
16:26:56 <copumpkin> *wat
16:26:56 <elliott> @check (==) <$> show <*> reverse . show
16:26:58 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
16:27:54 <ybit> wow
16:28:23 <ybit> that's pretty funny, wished it would have dawned on me to do > reverse (show [1]) before :)
16:28:24 <byorgey> ybit: why bother showing the list at all?
16:28:34 <mjrosenb> so can anything use parBuffer's result before it is done evaluating?
16:29:21 <ybit> i need the numbers spit out by a list comprehension to be sent to this function
16:29:51 <elliott> you want 123,4 --> 4,321?
16:30:00 <ybit> elliott: yes
16:30:13 <elliott> mjrosenb: anything that forces thunks will force them everywhere
16:30:25 <elliott> that is, nothing is going to copy a thunk, force it, and then copy it back -- that would defeat the point :)
16:30:37 <elliott> so you can expect results of all strategies to come in "incrementally"
16:31:06 <elliott> of course, any thread that forces a value before it's done will force it itself, and any thread that forces a value that is already being forced will either duplicate the work or block, depending
16:31:25 <mjrosenb> elliott: I remember reading that attempting to fore a thunk of parMap will go off, compute the entire list in parallel, then once that is done, return control to the thing that just forced the thunk
16:31:32 <byorgey> ybit: show x == reverse (show x) is a fin way to check whether an Integer is a palindrome
16:31:46 <byorgey> > show 12321 == reverse (show 12321)
16:31:47 <lambdabot>   True
16:31:51 <elliott> mjrosenb: oh, yes, sure -- but you can spark off the parMap itself
16:32:03 <byorgey> but if you want to check whether a *list* is a palindrome, just use  x == reverse x
16:32:04 <nand`> ybit: in list comprehension syntax, x <- [1] does *not* mean x has the type (Num a) => [a], in case this was causing any confusion; in the expression  [x | x <- [1..100], pal x]  the pal function gets applied to a number, not a list of numbers
16:32:12 <nand`> so you shouldn't be using pal [1] to test it, you should be using pal 1
16:32:30 <mjrosenb> elliott: well my issue right now is memory consumption, if running it in parallel means the whole list is held in memory, there are issues
16:32:32 <elliott> mjrosenb: i.e. parMap strat f xs `par` ...
16:33:12 <mjrosenb> elliott: but if I can process the first N elements, so they can be GC'ed before the rest are computed, that would make my life much easier
16:33:29 <nand`> ybit: note that in my example I just gave it would have been better and more idiomatic to write:  filter pal [1..100]
16:33:39 <ybit> that wasn't causing confusion, but thanks
16:33:49 <nand`> ok
16:34:01 <elliott> mjrosenb: parListN?
16:34:08 <nand`> I was just wondering why you wrote “pal [1]”
16:34:17 <ybit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/four.hs
16:34:20 <ybit> nand`: that's why
16:34:36 <mjrosenb> elliott: would that mean I can start processing the list before the whole thing has been evaluated?
16:34:40 <mjrosenb> @src unions
16:34:40 <lambdabot> Source not found. Just try something else.
16:34:43 <mjrosenb> :(
16:34:46 <elliott> "maximum pal" this won't work
16:34:56 <mjrosenb> @src Data.IntSet.unions
16:34:56 <lambdabot> Source not found. :(
16:34:59 <elliott> mjrosenb: sorry, i really don't understand the question.
16:35:05 <nand`> ybit: the description on that is.. off
16:35:15 <elliott> mjrosenb: why not spark off the strategy evaluation?
16:35:19 <elliott> that "returns control" immediately
16:35:35 <elliott> you seem to want it to not block the program but not run separately, which is a contradiction
16:36:13 <ybit> nand`: the description of what?
16:36:22 <nand`> ybit: four.hs
16:36:29 <nand`> the comments at the top
16:36:40 <mjrosenb> I want it to process a bunch of elements, and as the first unevaluated element in the list finishes evaluating, be consumed
16:36:58 <ybit> nand`: oh you are referring to my original planned method for solving it? :)
16:37:14 <ybit> yeah
16:37:45 <elliott> mjrosenb: what is the processing to be done? how do you wish to consume the list?
16:37:59 <elliott> do you want to do, e.g. a fold through the list, but have elements be evaluated ahead of time in the background?
16:38:03 <elliott> and for the list to be collected as you walk along it?
16:38:35 <mjrosenb> elliott: yes
16:38:51 <elliott> mjrosenb: ok, well, it'll look like someStrategyStuff xs `par` foldr f z xs, assuming f is strict
16:38:57 <elliott> if f isn't strict, then foldr (f $!) z xs, instead
16:38:58 <elliott> erm
16:39:01 <elliott> yeah
16:39:33 <elliott> http://hackage.haskell.org/packages/archive/parallel/3.2.0.2/doc/html/src/Control-Parallel-Strategies.html#evalListSplitAt looks like evalListSplitAt retains a reference to the start of the list, so...
16:39:35 <elliott> how about something like:
16:40:45 <elliott> ...eh, basically just rewrite evalListSplitAt but have it result in () :P
16:40:50 <nand`> > maximum . filter ((==) <$> show <*> reverse . show) $ (*) <$> [100..1000] <*> [100..1000]
16:40:50 <elliott> it might be easier to write manually with par
16:40:52 <lambdabot>   906609
16:41:46 <nand`> ..999 actually
16:42:00 <mjrosenb> elliott: i'll try it!
16:42:09 <mjrosenb> hrmm, actually, I don't want fold...
16:42:18 <elliott> mjrosenb: well, it doesn't really matter whether it's a fold or not
16:42:27 <elliott> just as long as it actually processes the list in a way that lets it be GC'd incrementally :P
16:42:52 <nand`> ybit: no what I'm saying is the comments are for project euler problem 3, while the body is for project euler problem 4
16:42:56 <nand`> the two don't match
16:43:20 <elliott> mjrosenb: foo [] = []; foo xs = withStrategy (parList strat) ys `par` foo zs where (ys,zs) = splitAt chunkSize xs
16:43:27 <elliott> then foo xs `par` myListProcessing xs
16:43:30 <elliott> or such
16:43:40 <elliott> wait no
16:43:42 <elliott> pseq, not par
16:43:45 <danlndi> I'm looking at doing some basic natural language (english) parsing for a text adventure system.  anyone have any suggestions?
16:43:56 <mjrosenb> :t pseq
16:43:57 <lambdabot> forall a b. a -> b -> b
16:43:58 <yottabit> nand`: well that's just swell, thanks for noticing, i'll fix it
16:44:00 <mjrosenb> :t par
16:44:01 <lambdabot> forall a b. a -> b -> b
16:44:04 <elliott> that processes the first few in parallel, then the next few in parallel, etc.
16:44:12 <elliott> danlndi: "words" is a good start :P
16:45:54 <danlndi> elliott: I've gotten *that* far
16:46:22 <mjrosenb> elliott: for these purposes, should IntSet.union be strict?
16:47:02 <nand`> yottabit: also I like to use Math.NumberTheory.Primes for anything involving prime numbers
16:47:11 <nand`> just in case it helps
16:47:33 <yottabit> definitely, thanks for that tip
16:47:46 <nand`> but I suppose it's best to implement the algorithm yourself here for paedagogical purposes :P
16:47:56 <byorgey> nand`: which package is that from?
16:48:05 <nand`> byorgey: arithmoi
16:48:12 <byorgey> ah, cool
16:48:28 <byorgey> there's also the 'primes' package with Data.Numbers.Primes if all you need is primes
16:48:32 <byorgey> but I like arithmoi
16:48:40 <elliott> mjrosenb: wait, where do IntSets come into it?
16:51:33 <dmwit> danlndi: I think there are a few people interested in NLP, but I haven't seen any packages float by the Hackage upload list yet.
16:52:04 <nand`> that reminds me
16:52:13 <nand`> we need a text adventure engine based on lojban grammar
16:55:04 <danlndi> dmwit: yeah... since it's for a game true NLP is way overkill.  but some approach that could handle simple english commands would be nice
16:55:50 <dmwit> I think something stupid like having disjoint verb and noun lists and just checking membership in those lists gets you pretty darn far.
16:55:56 <elliott> danlndi: you'll probably want to filter out a bunch of stop words
16:55:59 <dmwit> parse :: String -> (Verb, Noun)
16:56:00 <elliott> plus what dmwit said
16:56:06 <mjrosenb> well that's odd
16:56:09 <elliott> dmwit: pfft, at least (Verb, [Noun]) :P
16:56:13 <elliott> "put thing in bag"
16:56:26 <dmwit> No, if you want multiple nouns, then you need more structure than [Noun] allows.
16:56:34 <dmwit> Then you do have to start doing some actual parsing.
16:56:36 <mjrosenb> elliott: i'm generating a very large list of IntSets, and want to join them all together.
16:56:48 <elliott> mjrosenb: ah
16:56:53 <mjrosenb> odd, *Main> length . toList $ canEncodeL !! 2
16:56:59 <mjrosenb> immediately printed out 0
16:57:04 <elliott> unions should do it, then
16:57:22 <mjrosenb> and is now spinning eating 400% of my cpu time
16:57:53 <mjrosenb> elliott: when I tried before, it looked like unions was not being friendly so incremental gc could happen on the list
17:00:53 <danlndi> like <verb> <noun> <in/out/on/under/from/to> <noun>
17:01:19 <dmwit> (those things are called prepositions, by the way)
17:01:32 <danlndi> heh... yeah
17:06:09 <danlndi> "attack computer with haskell"
17:07:44 <insulina> hello a theorical question how to do a nand operater in lambda calculos
17:07:56 <byorgey> "study study in study"
17:07:59 <nand`> danlndi: if you're looking for something simple, what I did for my last text adventure project/engine was create an object oriented hierarchy of objects which had verbs as method; all verbs had their “signatures” defined on the global level as modified regex expressions
17:08:20 <insulina> verbs dont help me
17:08:35 <nand`> and something like “<verb> at <param>” would look up <param> in the current scope, then the parent's scope etc, and see if it can match the verb.
17:08:38 <nand`> Worked reasonably well
17:09:04 <insulina> are you a bot
17:09:28 <elliott> danlndi: unions :: Ord a => [Set a] -> Set a
17:09:28 <elliott> unions = foldlStrict union empty
17:09:30 <elliott> so it should work fine
17:09:35 <byorgey> insulina: nand` was not talking to you.
17:09:36 <elliott> but it is strict
17:09:54 <insulina> yeah I get it now :D
17:09:58 <elliott> insulina: haskell isn't the lambda calculus
17:10:25 <byorgey> insulina: although it is an amusing coincidence that you happened to ask a question about nand while nand` was talking.
17:11:05 <danlndi> nand`: very OO... land of nouns and all that
17:11:06 <insulina> yeah, lol, I jump to early
17:11:10 <nand`> insulina: if you're talking about church booleans  nand a b = a (not b) (not a)
17:11:10 <Jafet> Just don't tell him his problem will be solved by applicative.
17:11:16 <insulina> nand is very cool
17:11:33 <nand`> there's probably a more elegant definition
17:11:44 <byorgey> insulina: try writing nand first as a sequence of nested if-then-else expressions.  Then translate each if to an application of a church boolean.
17:12:32 <insulina> ok, I will try that thanks
17:12:36 <nand`> and in haskell not = flip :)
17:12:42 <danlndi> elliott: that's Data.Set?
17:13:06 <insulina> nand is the mother if all computers ;)
17:13:14 <elliott> danlndi: yes
17:13:26 <insulina> ops of
17:13:47 <nand`> danlndi: to be fair, I implemented it in C# at the time. But text adventures are very easy to model as OO because OO aims to model the real world; or more importantly, objects in the real world
17:14:09 <elliott> Haskell does the independent-objects-describing-behaviour part of OO better than OO languages
17:15:39 <mauke> "OO aims to model the real world"? [citation needed]
17:16:07 <russellw> elliott, why do you think so? (Not saying you're wrong, just curious about your reasoning)
17:17:01 <russellw> mauke, that was the original idea of the original object-oriented language, Simula, hence the name. In my opinion, it has turned out to in practice work better for graphic user interfaces than for simulating the real world; but text adventures are another area where it works well
17:17:15 <Sgeo> The best way to model the real world is to make a language whose primitives are elementary particles, described in terms of ... my quantum physics is a bit shaky... wavefunctions?
17:17:17 <danlndi> objects are straightforward... but the player as object kind of muddies it a little
17:17:18 <nand`> mauke: s/aims to/excels at/
17:17:24 <mauke> nand`: [citation needed]
17:17:34 <elliott> russellw: Because Haskell does function-based programming extremely well, and that's the true essence of the OOP approach: a data type with functions (describing dynamic behaviour).
17:17:50 <elliott> russellw: a la http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
17:18:19 <nand`> danlndi: player wasn't an object in my engine, doesn't make a lot of sense either. The player is on the other side of an aPI
17:18:31 <danlndi> "go north" translates to "I go north" <subject> <verb> <object>   ...?
17:18:35 <nand`> an API to an all-powerful god being that can move between states
17:19:00 <danlndi> nand`: I see
17:19:20 <ski> preflex: xseen lunabot
17:19:20 <preflex>  lunabot was last seen on freenode/#haskell 1 year, 362 days, 18 hours, 49 minutes and 41 seconds ago, saying:  31
17:19:29 <mjrosenb> elliott: I think ys needs to be added onto the list returned...
17:19:30 <nand`> Instead of modelling the player as an entity associated with some other object (eg. a room), I modeled the “game state” as a scope tree, with the player's actions being executed in the context of this scope tree
17:19:35 <ski> preflex: xseen mmorrow
17:19:35 <preflex>  mmorrow was last seen on freenode/#ghc 2 years, 9 days, 23 hours, 14 minutes and 58 seconds ago, saying: * mmorrow is rtfm'ing
17:19:46 <elliott> mjrosenb: Oh, sorry -- foo was meant to return ()
17:19:55 <elliott> foo [] = (); foo xs = withStrategy (parList strat) ys `pseq` foo zs where (ys,zs) = splitAt chunkSize xs
17:19:58 <shapr> preflex: xseen dons
17:19:58 <preflex>  dons was last seen on freenode/#haskell 12 days, 7 hours, 59 minutes and 4 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
17:19:58 <russellw> elliott, ah yes, that's a good way of approaching the question
17:20:05 <shapr> w00t! 884!
17:20:18 <nand`> eg if the player was in the scope “Room.Bed” then “look” would execute “Room.Bed.look” which prints out “It's too dark to see anything”
17:20:43 <elliott> russellw: Consider that in Java, you can't even transform behaviour (because you can't have a function from a class to a class, transforming the functions inside -- ok, maybe with reflection)
17:20:59 <elliott> Admittedly using Java as an example is unfair to other OO languages :)
17:21:04 <elliott> But you can't really do that in Smalltalk, either.
17:21:30 <elliott> ski: this is why you never rtfm
17:21:33 <russellw> yes. You can do it in Python or JavaScript, though the tradeoff is you don't get static type checking
17:21:47 <nand`> danharaj: so in this context you could model a text adventure game as a Tree (StateT IO GameState) or something
17:21:49 <danlndi> nand`: maybe modelling things like the player being drunk or missing his glasses...
17:22:30 <nand`> yeah, one thing I never incorporated into that system was variables
17:22:42 <mjrosenb> elliott: how is that supposed to be used?
17:23:01 <elliott> mjrosenb: foo xs `par` Set.unions xs
17:23:14 <danlndi> my command parser currently looks like "parseLine :: WorldState -> String -> (WorldState, Maybe String)"
17:23:25 <danlndi> dead simple
17:23:34 <elliott> danlndi: aka String -> State WorldState (Maybe String) :)
17:24:06 <ski> > factorize 884
17:24:07 <lambdabot>   [2,2,13,17]
17:24:08 <nand`> maybe define something like an Override.look = if drunk then Just "I see everything twice" else Nothing
17:24:16 <byorgey> danlndi: why does the parser have an effect on the world?
17:24:39 <byorgey> danlndi: I would expect something like   parseLine :: String -> Maybe Command, and   runCommand :: Command -> WorldState -> WorldState
17:25:00 <nand`> maybe  parseLine :: String -> WorldState -> Maybe Command
17:25:19 <byorgey> oh, yes, perhaps, if the world state can influence how the parsing happens
17:25:20 <shapr> preflex: xseen gbacon
17:25:21 <preflex>  gbacon was last seen on freenode/#git 55 days, 5 hours, 18 minutes and 47 seconds ago, saying: but by then, a decent alternative will also have bridges into or out of git, e.g., git-svn
17:25:24 <shapr> bah
17:25:27 <danlndi> byorgey: probably that will be necessary eventually
17:25:29 <nand`> yeah, like, if you're in a room with a dog “dog” would be a valid token
17:25:31 <nand`> but otherwise it wouldn't
17:25:36 * elliott thinks that's mixing concerns.
17:25:49 <nand`> then again
17:25:50 <byorgey> nand`: that's not what I had in mind.
17:25:58 <hpc> i would have parseLine :: String -> Maybe Command, type Command = WorldState -> ...
17:26:07 <danlndi> parsing should be totally separate
17:26:10 <byorgey> I think "dog" should always be a valid token.  You may get an error later on when doing  runCommand if there is no dog.
17:26:16 <nand`> oh yeah I see what you mean, check the tokens in the later step
17:26:41 <danlndi> my parseLine is more parseAndExecuteCommand right now
17:26:43 <hpc> otherwise you get perly madness, where the arity of a function determines if part of a line is a comment or not
17:27:01 <nand`> auxiliary functions like autoComplete :: String -> WorldState -> Maybe String  might have to use that signature though
17:27:11 <hpc> indeed
17:27:14 <byorgey> danlndi: right. it seems it would make things simpler/more modular to split it into two functions.
17:27:26 <nand`> two files as well
17:27:42 <byorgey> danlndi: and "maybe I'll have to do that eventually" is the wrong attitude.  Do it now, while it is still easy!
17:27:56 <byorgey> if you wait too long, separating it out will be a big mess =)
17:28:10 <hpc> nand`: typeCheck :: Command -> WorldState -> Maybe [String] -- perhaps this is the best of both worlds?
17:28:25 <nand`> hpc: what would it do, exactly?
17:28:26 <hpc> (Nothing is a successful typecheck, failure is (Just errors)
17:28:28 <hpc> )
17:28:31 <nand`> oh
17:28:36 <hpc> so you parse, then check it after
17:28:49 <danlndi> well that's what brings me here... to start parsing properly (and separately too)
17:28:49 <nand`> I was thinking the other way round, used to Nothing being failure
17:28:51 <byorgey> Nothing = success is odd =)
17:28:56 <hpc> true
17:29:04 <hpc> Either [String] ()
17:29:05 <nand`> type Error = String
17:29:05 <hpc> :P
17:29:10 <nand`> err
17:29:12 <byorgey> typeCheck :: Command -> WorldState -> TypeCheckResult
17:29:12 <nand`> type ErrMsg = String
17:29:19 <nand`> Then there's no confusion :)
17:29:30 <nand`> also why Maybe [String]? [] can serve as Nothing
17:29:34 <byorgey> data TypeCheckResult = OK | NotEnoughDogs | Other String
17:30:33 <nand`> NotEnough String
17:30:55 <nand`> or something like Unrecognized String
17:31:05 <byorgey> "take string"
17:31:15 <byorgey> "sorry, there is NotEnough String here"
17:31:28 <hpc> ITC: we design a compiler to answer a novice question
17:33:57 <danlndi> thanks for the assistance
17:35:31 <nand`> I'd probably create a complex rule-based token parser that takes something like {I} `throw|fling|hurl` ([a|my|the] $obj) {[at|towards|to] $dest}
17:36:50 <nand`> which could in this case parse “I throw my cake at danlndi” or “throw rock to car” or “hurl towards bed my book” but not something like “you throw” or just “throw”
17:37:16 <nand`> using some arbitrary rules for { }, [ ], ( ) and | I just made up
17:37:30 <mauke> give nand` cake
17:37:33 <nand`> but that seems very un-haskell
17:37:39 <aristid> throw cake at nand`
17:37:40 <nand`> this is only how I'd do it with regex and imperative
17:37:46 <Sgeo> elliott, did you ever finish reading FS?
17:47:53 <yottabit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/four.hs
17:49:36 <yottabit> can i do what's commented out?
17:50:33 <yottabit> something like it rather
17:56:39 <hpaste> ybit pasted “compile error” at http://hpaste.org/57087
18:08:06 <byorgey> yottabit: the lines  i <- [100 .. 999]  mean this is a computation in the list monad.
18:08:14 <kallisti> anyone know of a good web automation library in Haskell? I've found two: a Selenium driver and a thing called shpider.
18:08:20 <byorgey> yottabit: putStrLn must be in the IO monad.  You can't mix the two.
18:08:38 <kallisti> I was hoping for something with as many features as Selenium but which is easier to use.
18:08:40 <yottabit> byorgey: it's not in the IO monad?
18:08:58 <yottabit> how so?
18:09:03 <yottabit> ^actual question
18:09:28 <mauke> <byorgey> yottabit: the lines  i <- [100 .. 999]  mean this is a computation in the list monad.
18:09:34 <byorgey> yottabit: the syntax  i <- foo   is translated to   foo >>= \i -> ...
18:09:47 <byorgey> @type (>>=)
18:09:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:09:50 <MostAwesomeDude> The list monad is a different monad than the IO monad. Monads can't be mixed and matched like that.
18:09:57 <byorgey> so the type of 'foo' determines what monad is being used.
18:10:08 <byorgey> here, you have a list [100 .. 999].  So the list monad is used.
18:10:38 <ybit> ah
18:10:41 <byorgey> yottabit: using the list monad seems like the right thing to do.  So I advise you to separate out the list processing from the printing.
18:11:13 <byorgey> write a function which simply computes a list of answers (e.g. using the list monad, or a list comprehension which is the same thing).  then have a separate function to print the answers.
18:12:11 * elliott wonders if writing Conduits is /meant/ to involve rolling your own from scratch every time, even if you just want to lift a simple pure function...
18:12:48 <kallisti> well it doesn't seem very painful to do so.
18:12:55 <kallisti> at least.
18:13:14 * hackagebot yjtools 0.9.11 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.11 (YoshikuniJujo)
18:13:17 * hackagebot hake 1.3.6 - make tool. ruby : rake = haskell : hake  http://hackage.haskell.org/package/hake-1.3.6 (YoshikuniJujo)
18:13:32 <elliott> conduitState () (\s a -> return (s, Producing [f a])) (\_ -> return [])
18:13:43 <elliott> compare a hypothetical (conduitPure f)
18:13:50 <elliott> sure, it's easy enough to implement, but it's strange it's not included...
18:14:12 <elliott> maybe I just don't understand conduits though -- I can't figure out how to use attoparsec-conduit to build a Conduit rather than a Sink
18:15:56 <kallisti> couldn't you use the Functor instances?
18:16:17 <Jafet> When a Glasgow Haskell program simply prints "out of memory", which memory did it run out of?
18:16:49 <elliott> kallisti: I don't understand.
18:16:54 <elliott> Jafet: it can't remember
18:17:41 <mauke> Jafet: there's only one kind of memory
18:18:15 * hackagebot yjtools 0.9.12 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.12 (YoshikuniJujo)
18:19:12 <kallisti> elliott: there are functor instances for source/conduit/sink. Isn't that the lifting behavior you're looking for?
18:19:49 <elliott> No.
18:19:59 <elliott> fmap f conduitId would work, but there is no conduitId.
18:21:48 <kallisti> maybe instead of lifting the function to a conduit you're just supposed to fmap f and then apply f to a source/sink as desired
18:22:00 <kallisti> *apply fmap f
18:22:33 <kallisti> certainly seems simple enough. though it may not be the "lift a pure function into a conduit" you want.
18:22:49 <kallisti> (er, it's not that, at all, actually)
18:23:11 <kallisti> s/may not be/isn't/
18:23:15 * hackagebot xturtle 0.0.6 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.6 (YoshikuniJujo)
18:23:15 <elliott> kallisti: That would defeat the purpose of conduits, which is to translate between input types.
18:26:50 <kallisti> elliott: wait don't you just want map :: Monad m => (a -> b) -> Conduit a m b
18:26:58 <kallisti> or am I missing something?
18:27:04 <elliott> Yes. Where is that?
18:27:09 <kallisti> Data.Conduit.List
18:27:32 <elliott> (...why would it be in the List module?)
18:27:32 <elliott> Thanks.
18:27:43 <kallisti> a somewhat strange name, but the idea is that it provides a bunch of combinators that "mimic" Data.List
18:28:08 <elliott> I was expecting something working on Strings or such rather than ByteStrings.
18:28:10 <kallisti> so Data.Conduit.List actually has nothing to do with the list type.
18:28:24 <elliott> I guess it mirrors enumerator's module name, though.
18:29:03 <elliott> Now I just have one question, I guess :P
18:29:24 <kallisti> oh?
18:31:12 <elliott> <elliott> maybe I just don't understand conduits though -- I can't figure out how to use attoparsec-conduit to build a Conduit rather than a Sink
18:32:10 <kallisti> oh. haven't looked at attoparsec-conduit
18:33:04 <kallisti> http://hackage.haskell.org/packages/archive/attoparsec-conduit/0.0.1/doc/html/src/Data-Conduit-Attoparsec.html#sinkParser  maybe hack this to use conduitState instead. :P
18:33:57 <kallisti> push parser c | isNull c = return (parser, C.Processing)
18:34:06 <kallisti> huh, I've never seen a guaed used with this style of layout.
18:34:08 <Zamarok> Hmm.. the (\\) operator seems to be overflowing my stack when comparing two large lists... I think. Would the (\\) do that?
18:34:09 <kallisti> *guard
18:35:58 <kallisti> > [5..] \\ [1..]
18:36:01 <lambdabot>  Terminated
18:36:21 <kallisti> well, that wasn't a stack overflow..
18:36:27 <kallisti> perhaps it's something else?
18:36:36 <byorgey> Zamarok: perhaps, if the lists themselves are built up as giant unevaluated thunks and the call to (\\) actually forces the thunks to be evaluated
18:36:43 <ski> > [1..] \\ [5..]
18:36:47 <lambdabot>   mueval-core: Time limit exceeded
18:36:51 <byorgey> that's the sort of thing that can cause the stack to overflow.
18:37:32 <byorgey> Zamarok: see http://www.haskell.org/haskellwiki/Stack_overflow
18:38:43 <Zamarok> byorgey: hmmm it does look that way. My memory starts filling up a few gigs and then the program crashes..
18:39:19 <Zamarok> It definitely says stack overflow though kallisti, but not because of the (\\) operator by itself
18:39:30 <kallisti> right that's what I meant.
18:39:57 <kallisti> fold is a common offender. are you using a fold prior to // ?
18:40:00 <Zamarok> hmm.. the first thing the stack overflow link mentions is folds.. sum is a fold.. I sum that list that (\\) produces, so I guess that's it
18:40:14 <Zamarok> yea that xD
18:40:17 <elliott> no, it's the other way around
18:40:22 <elliott> folds are only problematic as input
18:40:26 <kallisti> yeah
18:40:27 <elliott> (except, only bad folds)
18:40:30 <elliott> (and sum isn't bad)
18:41:10 <Zamarok> A sum will be evaluated during and directly after the (\\)
18:45:18 <ddarius> sum can be bad because the Report is silly.
18:47:01 <elliott> True, but it probably won't be for GHC and Int or Integer.
18:48:16 <Zamarok> Well I'm doing ProjectEuler problems.. very large lists of numbers
18:51:32 <dolio> Int and Integer are specifically handled, so they work.
18:51:46 <dolio> Float and Double weren't working well for a long time, and may still be broken.
18:53:20 <elliott> Is there a projected release date for GHC 7.4?
18:58:15 * hackagebot pez 0.1.0 - A Pretty Extraordinary Zipper library  http://hackage.haskell.org/package/pez-0.1.0 (BrandonSimmons)
19:00:27 * ski . o O ( <http://www.coolfrenchcomics.com/adeleblancsec.htm> )
19:01:08 <plediii> I'm trying to read McBride's paper "The Derivative of a Regular Type..."  I'm new to reading things from this field, and I'm having trouble understanding what he's doing with 'mu', such as what would "mu x . 1" be?
19:01:20 <elliott> recursive type
19:01:23 <elliott> think of it as "fix" on the type level
19:01:29 <elliott> (mu x. 1) is just 1
19:01:43 <elliott> (mu x. 1+x) is Nat
19:01:58 <elliott> i.e. data Nat = {- the 1: -} Zero | {- the recursion: -} Succ Nat
19:02:37 <dolio> mu is least fixed point, though.
19:02:43 <dolio> If that matters.
19:03:00 <elliott> Right.
19:03:05 <CodeWeaver> Greeings
19:03:06 <byorgey> dolio: not in this context, I don't think.
19:03:09 <CodeWeaver> Possibly even Greetings
19:03:29 <elliott> Oh, hmm. Isn't type-level least fixed point nu?
19:03:35 <dolio> It's always least fixed point.
19:03:39 <elliott> I've exhausted my memory of what Greek letters mean.
19:03:43 <dolio> Sometimes least is also greatest, though.
19:03:48 <byorgey> nu is often used for greatest fixed point.
19:04:10 <byorgey> in Haskell least and greatest fixed points coincide, at least on the value level... not sure about the type level off the top of my head.
19:04:13 <elliott> Does anyone know if there *is* a way to "iterate" a Sink into a Conduit?
19:04:20 * elliott hopes conduit experts magically materialise.
19:04:45 <conduit_expert> POOF
19:04:46 * ski thought greatest fixed points didn't generally exist on the value level in Haskell
19:04:58 <elliott> EXCELLENT!
19:05:05 <conduit_expert> elliott: the answer to your question is yes
19:05:13 <elliott> conduit_expert: Awesome! Next qu- dammit.
19:05:18 <CodeWeaver> I'm guessing you only get one. :D
19:05:47 <monochrom> there is a precise sense in which "data R = ... R ..." is the least fixed point, or the smallest CPO.
19:05:55 <ski> plediii : did it get any clearer ?
19:07:01 <byorgey> ski: no? isn't an infinite list of 1's the greatest fixed point of (1:) ?
19:07:25 <dolio> (1+) :: Int -> Int doesn't have a greatest fixed point.
19:07:25 <monochrom> in some other precise sense, it is the greatest fixed point, but that sense does not say the largest CPO, it says the largest something else given some extra constraints, so it's actually less satisfactory
19:07:37 <ski> byorgey : yes. ("generally")
19:07:46 <dolio> Or, perhaps that isn't a good example.
19:08:05 <ski> @type not
19:08:06 <lambdabot> Bool -> Bool
19:08:13 <dolio> id :: Integer -> Integer is a better example.
19:08:16 <byorgey> dolio: why isn't the greatest fixed point _|_ ?
19:08:27 <byorgey> dolio: ah. ok.
19:08:40 <dolio> Types aren't lattices, is the problem.
19:08:48 <ski> byorgey : because `_|_' is strictly less defined than every other integer
19:08:59 <byorgey> ski: but no other integer is a fixed point of (+1).
19:09:04 <dolio> (1+) isn't correct.
19:09:07 <ski> (s/Types/Domains/ ?)
19:09:09 <dolio> I screwed up.
19:09:33 <byorgey> dolio: yes, I see now.
19:09:39 <ski> byorgey : hmm ..
19:12:40 <Sircan> http://pymmc.weebly.com/uploads/3/1/3/2/3132450/mirconi_chat.zip
19:12:51 <ski> byorgey : ah, i think i see .. for some reason i (implicitly) thought the subset of fixed-points must be upper
19:14:41 <ski> byorgey : anyway, i seem to be confused, i retract my statement
19:15:18 <int80_h> I just created two new modules for yesod.
19:15:20 <int80_h>                  Web.Authenticate.LDAP and Yesod.Auth.LDAP. I've never merged
19:15:21 <dolio> What is data R = ... R ... the largest of if not CPOs?
19:15:23 <int80_h>                  code before. I just created my github account and have it
19:15:25 <int80_h>                  ready to go. As of now it's empty. How do I go about preparing
19:15:38 <int80_h> hmm, that wasn't exactly what I wanted to do
19:16:15 <monochrom> there is no largest CPO. as in, I can always build a larger CPO than yours.
19:17:06 <monochrom> ah, but I forgot largest what it is. something to do with algebra vs co-algebra, induction vs co-induction
19:17:38 <dolio> It is a terminal coalgebra over the category of CPOs.
19:17:50 <dolio> I don't know why you'd care about largeness in any other sense.
19:17:55 <int80_h> I just created two new modules for yesod. Web.Authenticate.LDAP and Yesod.Auth.LDAP.  I've never merged code before. I just created my github account and have it ready to go. As of now it's empty. How do I go about preparing to merge my code?
19:18:22 <dolio> Or based in the category of CPOs, or whatever.
19:19:01 <yottabit> i give up on explicitly declaring monads
19:19:13 <yottabit> thought i knew this, but guess not
19:19:18 <yottabit> will read through lyah
19:19:46 <yottabit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/four.hs
19:19:51 <plediii> elliott: I think maybe I'm getting the order of operations wrong.  I've been reading it as "(mu x.1) + x",  but I guess I'm supposed to read it as "mu x . (1+x)".  Is that right?
19:20:02 <yottabit> i'd like to do something like........ maxPal = maximum (filter pal x == True in pal funVals)
19:20:02 <dolio> Probably.
19:20:25 <dolio> Since that x would be free otherwise unless there's another quantifier.
19:20:26 <ski> plediii : yes, like with lambda and the quantifiers
19:21:10 <elliott> plediii: Yes.
19:21:16 <elliott> plediii: Like \forall, etc.
19:21:16 <plediii> great that makes it clearer, thank you.
19:21:39 <ski> plediii : generally, `mu alpha. tau' is basically the same as `tau [alpha := mu alpha. tau]'
19:21:52 <elliott> well that's helpful :D
19:22:16 <elliott> (It is, actually, just amusing on first glance.)
19:22:18 <elliott> (So much Greek.)
19:23:22 <plediii> this topic just seems more interesting the more I get my head around it
19:24:33 <ski> (istr some variant where `mu alpha. tau [beta := mu alpha. tau [beta := alpha]]' was *equal* (not just isomorphic) to `mu alpha. tau [beta := alpha]')
19:32:53 <Zamarok> damnit some of these Project Euler problems don't give enough specific information either >_>
19:35:01 <monochrom> dolio: I see now, you're right, it is the largest CPO too
19:35:55 <dolio> Good, because I was completely stumped about how it could be both terminal and not effectively the largest.
19:56:25 <yottabit> i have ghc 7.0.3
19:56:38 <yottabit> which version introduced Data.Numbers.Primes
19:56:49 <yottabit> maybe this is a #ghc question
19:57:07 * yottabit asks in #ghc
19:58:07 <elliott> yottabit: that's not part of ghc
19:58:39 <elliott> as e.g. http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Data.Numbers.Primes shows, it's part of the primes package
19:58:47 <elliott> "cabal install primes" to get it
19:59:32 <yottabit> thanks elliott
20:14:09 <hpaste> Zamarok pasted “23” at http://hpaste.org/57090
20:14:19 <Zamarok> Anyone know why running that overflows my stack?
20:14:42 <Zamarok> Caution, running it will fill up your ram if you don't have much
20:15:16 <Sgeo> There are RTS options that can be set to prevent it from going over a certain amount
20:15:35 <CodeWeaver> Possibly 'sum' which isn't strict?
20:16:05 <Zamarok> CodeWeaver: yea I think too many thunks are building up.. but I thought 'sum' was safe to use in that situation? Is there a 'safe' way to do it?
20:16:18 <CodeWeaver> foldl' (+) 0
20:16:46 <elliott> CodeWeaver: sum is strict on Int/Integer
20:16:49 <elliott> in GHC
20:16:56 <CodeWeaver> Is it?  I've been able to blow it up before I think.
20:17:00 <CodeWeaver> *tests*
20:17:17 <Zamarok> Yea that still blows up my RAM and then crashes
20:17:24 <CodeWeaver> Definitely not strict, sum.
20:17:32 <monochrom> did you compile with -O?
20:17:38 <Zamarok> -O2 actually
20:17:44 <CodeWeaver> Well, sum isn't strict in ghci anyway.
20:17:50 <monochrom> then again, if defaulting to Integer, -O1000 doesn't do that much
20:18:03 <Zamarok> I'm compiling then running, not in GHCI
20:18:18 <CodeWeaver> Fair enough.
20:18:40 <CodeWeaver> I'm used to making sure things are strict even in ghci, which may be premature but thereyago.
20:19:05 <CodeWeaver> What else in that builds up thunks as it goes…
20:19:24 <monochrom> the rest build small thunks only
20:19:46 <Zamarok> I have no idea.. I'm a Haskell newb, and a very confused as to why it crashes
20:20:01 <elliott> CodeWeaver: You need -O to get the rule to fire, I think.
20:20:09 <elliott> Zamarok: hpaste your code
20:20:15 <CodeWeaver> Fair enough elliot — but I'd just use foldl' (+) to avoid the issue.
20:20:17 <otters> so printf is a variadic function
20:20:30 <monochrom> it's http://hpaste.org/57090 , although, "divisors" is missing
20:20:41 <elliott> foldl' (+) 0 to be precise :P
20:20:47 <otters> can I pass it an array of arguments, rather than each one individually? D:
20:20:47 <hpaste> Zamarok pasted “23 #2” at http://hpaste.org/57091
20:20:48 <yottabit> https://github.com/heath/Project-Euler-Problems/blob/master/haskell/three.hs
20:20:49 <otters> they're all the same type of course
20:20:58 <yottabit> i try compiling that and ghc complains about naked expressions?
20:21:00 <elliott> otters: not really
20:21:06 <otters> figured
20:21:11 <elliott> otters: printf is what we call "a hack"
20:21:15 <yottabit> aha
20:21:17 <yottabit> got it
20:21:21 <otters> oh
20:21:23 <yottabit> didn't import Data.Numbers.Primes
20:21:27 <otters> I wondered why it behaved so weirdly
20:21:41 <elliott> otters: well it's based on the creative use of typeclasses :P
20:21:51 <Zamarok> elliott: there you go. you can compile it, but you'll need to define 'divisors' which is in a library of mine...
20:22:06 <elliott> Zamarok: i would suggest adding type signatures to everything as a first step
20:22:10 <elliott> defaulting could be tripping you up
20:22:14 <elliott> are you compiling with -O2?
20:22:18 <Zamarok> yes
20:22:24 <Zamarok> I'll add type signatures
20:22:25 <monochrom> yes, naked expression "maximum [x | x <- takeWhile (< 600851475143) (wheelSieve 6)]" there. what do you want to happen to it?
20:22:28 <CodeWeaver> Wait, that's sum' not sum…
20:22:46 <Zamarok> CodeWeaver: I changed it on your recommendation, look at the bottom for foldl'
20:22:52 <CodeWeaver> Oh :D
20:22:53 <elliott> Zamarok: I'd like to see divisors' definition, it could be the problem here
20:22:53 <CodeWeaver> hahahaha
20:23:06 <Zamarok> elliott: https://github.com/zachfogg/Euler/blob/master/lib/Euler.hs
20:23:21 <elliott> Zamarok: you might also want to try compiling with -prof -auto-all -rtsopts, running with +RTS -p and looking for suspiciously high memory percentages in <prog>.prof
20:23:38 <Zamarok> in there somewhere.. that's my library of stuff to help me solve ProjectEuler problems and things
20:23:41 <elliott> heh, add' is an interesting function :)
20:23:53 <elliott> ok, divisors looks fine
20:23:57 <Zamarok> ahh my first Haskell function.. I need to clean that file up
20:24:34 <elliott> :t map . (,)
20:24:35 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
20:24:45 <elliott> :t Prelude.map Prelude.. (,)
20:24:46 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
20:24:50 <elliott> oh
20:25:08 <elliott> Zamarok: btw: pairsSum xs = concat $ zipWith (map . (+)) xs tails xs
20:25:12 <CodeWeaver> At a glance, divisors looks fine....
20:25:12 <elliott> (i think)
20:25:22 <elliott> anyway this is odd, so I'd suggest doing that profiling
20:29:05 <Zamarok> Yea it's all being alloc'd in divisors, which is called by sigma, which is called by nType
20:29:32 <hpaste> Zamarok pasted “23 +RTS -p” at http://hpaste.org/57092
20:29:45 <elliott> Zamarok: ok, are you sure your algorithm isn't just really inefficient? :P
20:29:56 <Zamarok> that ^ is what it says.. I'm stumped.
20:30:00 <elliott> Zamarok: as a hack try copying divisors into the program and specialising it to Int or Integer (whichever you're using)
20:30:02 <elliott> see what happens
20:30:10 <Zamarok> ok
20:32:48 <monochrom> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg21183.html "ghc: out of memory (requested 5997056753664 bytes)"
20:33:02 <monochrom> "Before I go out and find a machine with 6 terrabytes of RAM, I figured I'd post here first :)" hahaha
20:33:10 <Zamarok> I did both of those things... good news is the program runs faster.. bad news is that it also crashes faster haha
20:35:00 <elliott> Zamarok: haha
20:35:08 <elliott> well, are you sure your program doesn't just need too much memory? :)
20:35:31 <shachaf> elliott: What do you think my willpower? Eh? EH?
20:35:32 <elliott> monochrom: "Though, ghc 7.0.x is slightly better in that it requests only one and a half terrabytes of ram :)" :D
20:35:36 <shachaf> Er.
20:35:43 * shachaf misspresses key.
20:35:49 <elliott> shachaf: Coherent as ever!
20:36:04 <monochrom> your will power is so strong, it leaks into #haskell, is what I say
20:36:10 <shachaf> Exactly!
20:36:37 <monochrom> you leak will power like haskell leaks memory  <duck>
20:38:05 <Zamarok> maybe.. I gave it a bunch of stack space and it filled up my ram mostly.. sitting and calculating now, and most importantly not crashing.. we'll see what happens I guess lol
20:38:06 <monochrom> which is to say, haskell has very strong memory, too
20:38:51 <elliott> Zamarok: Project Euler is probably expecting you to use a smarter algorithm, if you're having problems like this with no obvious mistake as the source.
20:40:06 * monochrom notes one more reason against Project Euler for Haskell learning: premature laziness surprises
20:40:47 <Zamarok> yea.. I'm pretty sure the error is my own misunderstanding of Haskell, because the algorithm works with a large enough stack.. maybe the list has to be fully evaluated when compared to the other list with (\\) or something, I dunno
20:41:02 <elliott> Zamarok: Like I said, I don't think it's laziness or anything biting you here.
20:41:10 <elliott> Your algorithm just uses too many resources.
20:41:32 <monochrom> list has a high constant factor of memory footprint, too
20:41:59 <shachaf> Cale: hi
20:42:10 <Zamarok> hmm.. right, well I can get rid of even numbers > 48 I guess..
20:42:17 <Cale> hi
20:42:20 <shachaf> Cale: elliott wanted to talk to you.
20:42:32 <elliott> I did?
20:42:37 <Cale> wat
20:42:42 <shachaf> OK, I'm confused.
20:43:07 <shachaf> Cale: Never mind!
20:43:36 <monochrom> (x:xs) takes 1 word for the ":", 1 word for pointing to x, 1 word for pointing to xs. if you're on 64-bit, that's 24 bytes already.
20:46:59 <ramier> hi
20:47:14 <louzer> I end up using as much paranthesis in haskell as in Lisp. Since we are on a global recession, I am trying to learn how to reduce the number of paranthesis.
20:47:18 <louzer> How does $ work? Sometimes I see people doing print $ f x but if I want to do (f (g x)) I can't do f $ g x why is that? What are the different ways of writing (f (g x)) in haskell?
20:47:42 <monochrom> (f (g x)) is (f $ g x)
20:48:00 <louzer> hmm
20:48:04 <monochrom> if you just write f $ g x, that works or doesn't work depending on context
20:48:52 <Zamarok> if (f (g x)) works, (f $ g x) will work
20:48:57 <monochrom> "main = (f (g x))" -> "main = f $ g x" clearly works, "main = print (f (g x))" -> "main = print f $ g x" clearly is unfair
20:49:15 <louzer> i see. wait let me show you a hpaste
20:50:02 <monochrom> I have never had as much parens in haskell as in lisp. haskell has strictly less parens for me.
20:50:04 <hpaste> Edwin pasted “How does $ work?” at http://hpaste.org/57093
20:50:20 <monochrom> and I already avoid $
20:51:01 <monochrom> compare the precedences of - and $
20:51:23 <louzer> uhm isnt function application most important?
20:51:47 <monochrom> " " is most important. that says nothing about $
20:51:57 * ski prefers `(sum . squares) x' to `sum $ squares x' -- though `sum (squares x)' is also fine
20:52:29 <louzer> i guess i have to read up on precedence
20:52:36 <elliott> sum . squares $ x
20:52:42 <shachaf> ski: What about -- what elliott said.
20:52:51 <ski> `(sum [1..x])^2' can be simpler written as `sum [1..x] ^ 2' (as indeed hint(?) suggests)
20:53:02 <louzer> monochrom: so you say - is the more important than $ ?
20:53:12 <monochrom> I forgot. look it up
20:53:19 <ski> shachaf : it's ok, but i usually prefer `(sum . squares) x' to that, anyway :)
20:53:36 <ski> louzer : no, `$' has the lowest precedence
20:53:49 <louzer> ski: aha
20:53:53 <ski> hm, i suppose that makes it "yes", actually
20:53:58 <monochrom> the cargo cult of $
20:54:08 <ski> (if "important" means "binds tighter")
20:54:53 <ski> (elliott : sometimes i write `foo $ bar . baz', though)
20:55:03 * elliott too, though it confuses him :)
20:55:07 <louzer> why does the warnings of my hpaste say, avoid lambda?
20:55:29 <louzer> is lambda not good practise amongst haskellers?
20:55:43 <dolio> What lambda is it complaining about?
20:55:45 <ski> louzer : a section is probably slightly easier to read than a full lambda -- however, i'd just take it as a suggestion
20:55:51 <monochrom> (\i -> i^2)
20:55:55 <ddarius> It is not the case that if (f (g x)) works that (f $ g x) will work.
20:55:57 <Zamarok>  I say big lambdas are bad practice.. might as well make a function if it's a big one
20:56:20 <shachaf> ddarius: In Haskell 98?
20:56:22 <louzer> ddarius: how?
20:56:30 * ski . o O ( *big* lambdas ? )
20:56:33 <louzer> ddarius: in ghci
20:56:33 <monochrom> but I completely ignore and disdain hlint
20:56:48 <monochrom> "big lambda" means long lambda expressions
20:56:50 <ddarius> shachaf: Yes.
20:56:57 <ski> monochrom : yeah, i just realized
20:57:05 <elliott> ddarius: Go on.
20:57:11 * ski was thinking of majuscle lambda letters
20:57:24 <ddarius> shachaf: Though particularly outside of Haskell 98 is the real unexpected case.
20:57:34 <louzer> ddarius: ok
20:57:39 <shachaf> What's the case inside Haskell 98?
20:57:53 <monochrom> yeah, I want to know too
20:57:59 <ddarius> ($) doesn't need to be apply.
20:58:07 <monochrom> um...!
20:58:17 * ski grins
20:58:25 <louzer> hey guys thanks for the quick response
20:58:36 <dolio> if 'f' and 'g x' represent more complex expressions, you could have an infixl 0 operator in them that would conflict with ($).
20:58:45 <Zamarok> monochrom: (flip (^) 2)
20:58:52 <Zamarok> I think that does the same thing as your lambda.. right?
20:59:05 <dolio> So does (^2)
20:59:07 <ski> it's louzer's lambda expression
20:59:21 <monochrom> I denounce hlint
20:59:22 <ddarius> join (*)
20:59:35 <Zamarok> nah (^2) and (flip (^2)) are different, very different
20:59:53 <ski> `flip (^2)' is not `flip (^) 2'
21:00:12 <Zamarok> works either way ;p
21:00:20 <ski> @type flip (^2)
21:00:21 <lambdabot> forall a b. (Num b) => a -> (a -> b) -> b
21:00:24 <monochrom> "(^2) and join (*) can be different, on the ground that ^ may be not exponentiation and * may be not multiplication"
21:00:27 <ski> @type flip (^) 2
21:00:28 <lambdabot> forall b. (Num b) => b -> b
21:00:55 <monochrom> "and that is within Haskell 98, too"
21:00:58 <Zamarok> well, the way I put it was the right way. try "map (flip (^)2) [1..10]"
21:01:40 <ski> Zamarok : yes, and as dolio said, that `(flip (^)2)' is the same as `(^2)'
21:01:40 <ddarius> monochrom: You forgot that join need not be join.
21:01:46 <monochrom> haha
21:02:20 <insyde> hey, quick q, anyone know a decent plugin to use with vim?
21:02:40 <dolio> The surround plugin is handy.
21:02:42 * monochrom suggests :!emacs
21:02:53 <Zamarok> ah so it is.. I had the ^ in parens.. didn't know that had an effect there
21:02:59 <insyde> I tried the "official" one; when I sourced the vimball, it blew up my ./vim :(
21:03:12 <insyde> it's awful
21:03:22 <Zamarok> insyde: what do you want this plugin to do for you?
21:03:40 <ski> Zamarok : `(x ^) y' is `x ^ y', while `(^ x) y' is `y ^ x'
21:03:42 <ddarius> Ideally cook dinner and the laundry.
21:03:46 <insyde> Zamarok: syntax highlighting, autocomplete, etc
21:03:51 <monochrom> and clean the computer keyboard
21:04:37 <insyde> and yea it was haskellmode for vim
21:04:53 <insyde> it destroyed my ./vim directory with all sorts of weird shit
21:04:54 <shachaf> ddarius: You cook your laundry?
21:05:03 <insyde> and on top of that, it doesn't even work
21:05:16 <monochrom> drying laundry is cooking laundry
21:05:24 <Zamarok> ski: Oh... well I use exuberant-ctags, omnicomplete, and the haskell language syntax highlighting plugin
21:05:33 <Zamarok> oops, that was to insyde not ski :s
21:05:59 <insyde> Zamarok: I'll look into those thanks
21:06:12 <ddarius> shachaf: Oven fried socks are the best.
21:06:25 <insyde> Zamarok: any ideas on how to clean up ./vim? I tried to uninstall the vimball throught some revert command
21:06:30 <insyde> Zamarok: but that didn't work
21:07:04 <Zamarok> Is it in a repository of some kind? my ~.vim/ is a git repository
21:07:42 <insyde> Zamarok: oh sorry meant /.vim and no
21:07:47 <insyde> Zamarok: learned my lesson though
21:08:08 <hpaste> Edwin pasted “ghci says sum . squares x isn't Int” at http://hpaste.org/57094
21:08:14 <Zamarok> Ouch.. "git reset --hard HEAD" is my savior. I recommend you start one once you fix it...
21:08:25 <Zamarok> but I have no experience with fixing that lol sorry.. try #vim
21:08:50 <louzer> I am pretty sure sum . squares x is Int
21:08:55 <Zamarok> wait you have a .vim folder in the root folder?
21:09:16 <louzer> but when I put in ghci ghci complaines
21:09:45 <insyde> Zamarok: I ssh into my school's server to code so yea that "root"
21:09:53 <ski> louzer : `sum . squares x' means `sum . (squares x)', not `(sum . squares) x'
21:10:04 <insyde> Zamarok: once I start getting more serious about virtualizing ubuntu, I'll transfer it all over to there
21:10:16 <louzer> ski: what is the difference?
21:10:37 <insyde> is there an easy way to add a new channel?
21:10:41 <ski> louzer : the difference is that the latter works (assuming `x' is an `Int'), while the former is a type error
21:10:41 <Zamarok> What's the purpose of /.vim anyway? I don't get it.. why not just a ~/.vim for each user?
21:10:43 <insyde> I'm new to irc sort of
21:11:05 <ski> insyde : `/join #vim' ?
21:11:06 <Zamarok> insyde: /join #myDesiredChannel
21:11:20 <insyde> ah cool thx
21:11:39 <insyde> and Zamarok yea that's what I meant
21:11:56 <louzer> ski: how can i specify type of an inner function? i.e. inside where clause
21:12:02 <otk> Hello, where can i read about version compatibilities for GHC, trying to compile a program that was origionally compiled using GHC 6.4.2, i am using GHC platform 2011.4 and getting module not found issues for Data.ByteString.Base.
21:12:20 <ski> louzer : using a type signature
21:12:29 <louzer> ski: ok
21:12:38 <otk> ski: nice name
21:12:45 <ski>   f x = ...
21:12:47 <ski>     where
21:12:50 <ski>     squares :: ...
21:12:51 <ski>     squares x = ...
21:12:59 <ski> louzer : like that, e.g.
21:13:36 <ski> otk : Why thank you, kind sir !
21:13:50 <louzer> ski: I tried squares :: Int -> [Int] but it doesnt help
21:14:22 <louzer> sum . squares x still has wrong type
21:14:53 <elliott> that's sum . (squares x)
21:14:53 <elliott> i.e.
21:14:58 <elliott> \y -> sum (squares x) y
21:15:01 <elliott> do you see the problem?
21:15:37 <louzer> elliott: hmm i need one more argument?
21:15:51 <louzer> elliott: if it has to return value?
21:16:38 <otk> maybe i should just install ghc 6.4.2
21:17:09 <louzer> elliott: you mean the . operator always expects a second argument after what follows after the .
21:17:21 <louzer> elliott: hmm interesting
21:18:25 <ski> elliott : `.' wants its left and right arguments to be functions. if `squares :: Int -> [Int]', then the right argument in `sum . squares x', which is `squares x', is *not* a function (it has type `[Int]')
21:18:28 <monochrom> there is no general article on GHC version compatibilities. but yes bytestring in GHC 6.4 and bytestring in GHC 7.0 are too far apart
21:18:29 <ski> er
21:18:31 <ski> louzer : ^
21:18:52 <elliott> otk: Installing ghc 6.4 is a bad idea.
21:19:00 <elliott> otk: It came out mid-2006.
21:19:31 <otk> hm, was just reading that aparently Data.ByteString.Base is now split into two modules
21:19:51 <otk> i just tried making with Data.ByteString.Internal and it seemed to at least not give the same error
21:20:03 * monochrom has an archive of ghc 4.08.1 :)
21:20:05 <louzer> ski: wow elliott: wow thanks i see it now
21:20:25 <otk> elliott: this code is 2006-7 anyway
21:21:01 <elliott> otk: yeah, but will ghc 6.4 even run on your OS? there's a good possibility not
21:21:02 <elliott> louzer: :)
21:21:23 <monochrom> I don't see what's bad about using old software, if it is suitably sandboxed
21:21:24 <otk> elliott: i think the fix is just to use .Internal
21:21:34 <otk> this isn't production code its just a file fuzzer
21:22:17 <monochrom> 6.4 is not old enough to break on today's OS
21:23:05 <otk> well, ghc is the most sophisticated and advanced compiler this planet has ever seen, i figure its safer than others
21:23:28 <otk> and, it looks like it compiled :)
21:23:31 <CodeWeaver> When it works. :D
21:23:41 <monochrom> I have, like, windows games from before 2000 and play fine in windows vista
21:24:00 <otk> im not a haskell person (yet), but from what erik meijer says, i trust it more than other stuff :)
21:24:08 <CodeWeaver> heehee
21:24:39 <ddarius> Erik Meijer is apparently living up to being a used language salesman.
21:25:04 <otk> i have been watching his FP lectures on MSDN and loving them
21:25:12 <otk> slowly getting drawn to haskell
21:25:27 <CodeWeaver> I may have watched some of those actually.
21:25:30 <monochrom> but I do agree that old compilers should be suitably isolated, i.e., not the default compiler for new projects
21:25:46 <otk> monochrom: for production, correct
21:25:52 <otk> but for testing and messing around, who cares?
21:26:08 <otk> a bug in how a compiler may be quite interesting to play with hehe
21:26:16 <monochrom> the production story is actually a bit more complicated
21:26:47 <otk> i wouldn't know, never done production anything
21:26:57 <nus> otk, have you found Ralf Lmmel's lectures yet?
21:27:13 <CodeWeaver> I do sometimes wish I had to fight with GHC on OSX less, especially on some of the weirder packages,but, hey, y'know.
21:27:15 <otk> nus: haven't, i will look into it though if its advised
21:27:35 <monochrom> if you have production code written for an old compiler, the most paranoid mantra says that you should not take risks with another compiler version.
21:27:55 <otk> nus: ok i think ive seen one of his presentations
21:28:08 * otk slowly raises hand to admit that monads are one of the most mind boggling concepts ever
21:28:10 <ddarius> "A bug in the hand is worth two in the bush."
21:28:13 <elliott> CodeWeaver: They couldn't make GHC too nice to use on OS X; Microsoft Research wouldn't allow it :P
21:28:24 <CodeWeaver> DARN YOU MICROSLOTH!
21:28:39 <otk> microsoft bring us F#
21:28:40 <ddarius> elliott: That's why it's so easy to use GHC on Windows.
21:28:45 <elliott> ddarius: Precisely!
21:28:54 <CodeWeaver> Monads aren't that evil.  Understanding all of the *implications* is a bit out there.  But in and of themselves, they're not hideous.
21:28:54 <elliott> otk: Microsoft (Research) also bring us GHC.
21:29:14 <otk> secretly, microsoft use haskell for formal verification of kernel drivers i bet =)
21:29:17 <CodeWeaver> That's the problem I have with haskell… I don't yet understand the consequences.
21:29:20 <elliott> otk: "Monads are the hard thing to understand in Haskell" is a myth spread by non-Haskellers and bad "monad tutorials".
21:29:20 <otk> elliott: this i didn't know
21:29:29 <CodeWeaver> Plus half the things people say in here, I don't understand either.  It can get VERY academic.
21:29:47 <elliott> otk: In reality monads are one of many concepts in Haskell, and they're actually very simple; it's just that you can't "learn monads" out of the blue without knowing the context.
21:29:57 <ddarius> "You do not understand" does not imply "academic"
21:30:02 <otk> elliott: yes i can see some of that, i understand computational expressions for what its worth (not sure if monads have an equivilant) which share similar characteristics to monads
21:30:12 <elliott> A good introduction like Learn You a Haskell covers monads at the appropriate place, which helps get past the mythology.
21:30:19 <otk> i have to agree that the tutorials for monads are bad
21:30:26 <otk> monoid vs monad vs gonad
21:30:33 <mauke> monoids are simple
21:30:36 <mauke> fortunately
21:30:43 <CodeWeaver> Learn You is a great book.  It made me and my girlfriend laugh with delight.
21:30:48 <elliott> And as we all know, monads are basically just monoids!
21:31:02 <ddarius> Computer scientists study monoids more than any other field.
21:31:05 <otk> elliott: im going to be starting on that shortly
21:31:09 <monochrom> haskell is basically just ascii
21:31:13 <otk> 'learn you a haskell'
21:31:15 <elliott> otk: ("Microsoft Research brings usGHC" is misleading; it's an open-source project, just that the main two developers are paid to work on it at MR.)
21:31:16 <Eduard_Munteanu> Heh.
21:31:16 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
21:31:37 <otk> elliott: ah, erik and ?
21:31:38 <CodeWeaver> Okay, true…. maybe I just don't understand.  But I haven't not understood things on this scale in quite some years.
21:31:40 * ddarius has not heard of microsecond GHC.
21:31:44 <otk> well, im just guessing erik
21:31:52 <elliott> otk: The Simons.
21:31:57 <otk> i think hes more into the cloud\azure side though
21:31:59 <otk> ok
21:32:00 <elliott> (Peyton Jones and Marlow.)
21:32:01 <ddarius> Erik doesn't work on GHC and never did to my knowledge.
21:32:08 <ddarius> Also, Erik is not in Microsoft Research.
21:32:19 <otk> i know peyton jones, i think ive seen some material around
21:32:32 <otk> ddarius: think hes on the cloud\parallelism(sp)\azure side of things
21:32:39 <otk> but contributes to C# and F# from what i see
21:32:47 <elliott> "At Microsoft he heads the Cloud Programmability Team[1]. Erik previously worked within Microsoft Research."
21:32:49 <otk> and has his own side project languages i think
21:32:51 <ddarius> He at least was on the VB.NET team.  I don't know if he still is.
21:33:12 <otk> VB.net heh
21:33:26 <otk> i haven't given it a shred of investigation
21:33:30 <otk> don't imagine i ever will
21:33:53 <monochrom> that makes him a travelling used monad salesman. go to VB, say "hey add monads"; go to C#, say "hey add monads"; ...
21:33:57 <ddarius> VB.NET is basically C# with VB syntax.  There are (by design) very few substantial differences.
21:34:01 <Eduard_Munteanu> @remember monochrom <mauke> monoids are simple  <elliott> And as we all know, monads are basically just monoids!  <monochrom> haskell is basically just ascii
21:34:01 <lambdabot> Okay.
21:34:11 <otk> monochrom: hah
21:34:21 <CodeWeaver> :D
21:34:25 <otk> ddarius: i dont really understand C# either
21:34:40 <mauke> language >>= addMonads
21:34:46 <otk> only language i have used with passion is F#
21:35:15 <monochrom> on the bright side, that means he has solved the travelling used monad salesman problem
21:35:41 <monochrom> on a graph of size approximately 3
21:35:50 <otk> monochrom: hes engaging and good enough at presenting and preaches haskell
21:36:05 <otk> sounds like you guys dont like him =p
21:36:06 <mm_freak> otk: C# is like a poor man's F#…  basically =)
21:36:12 <nus> CLIR is much saner nowadays... Also Roslyn.
21:36:20 <ddarius> mm_freak: Not really.
21:36:22 <tikhonjelvis> mm_freak: Or a rich man's Java :)
21:36:34 <otk> roslyn is very impressive, unfortunately there were some odd design decisions
21:36:35 <monochrom> I'm just working up for some NP-complete joke
21:36:43 <nus> otk, such as?
21:36:46 <mm_freak> ddarius: i'm just joking, but i'm interested in your reasoning anyway
21:36:49 <otk> not exposing it to F#
21:36:52 <mm_freak> because i do think that F# is more powerful
21:37:00 <companion_cube> I hope he is SAT-isfied by his work
21:37:11 <monochrom> haha
21:37:35 <otk> tbh im finding MS's attitude towards F# to be very irritating
21:37:45 <otk> latest msdn mag was doing data mining with C# :|
21:37:50 <mm_freak> otk: because F# is "a scripting language"?
21:38:00 <ddarius> otk: Erik Meijer describes himself as a "used programming language salesman"
21:38:09 <otk> ddarius: ah okay
21:38:19 <otk> mm_freak: functional languages are some of the best scripting languages
21:38:27 <otk> broad statement maybe
21:38:43 <otk> i dont know it seems like theyre giving a little bit of effort to F# but not enough
21:38:46 <tikhonjelvis> Well, a lot of bash is like a functional language.
21:39:05 <mm_freak> well, depends on how you define it…  for me a scripting language is a language that just executes statements from top to bottom, and F# is of that sort
21:39:24 <tikhonjelvis> mm_freak: And JavaScript isn't?
21:39:31 <mm_freak> tikhonjelvis: sure it is
21:39:34 <mm_freak> by that definition
21:39:37 <otk> mm_freak: thats just the source though, F# is a compiled language, not sure what it does at the IL level though
21:39:43 <tikhonjelvis> mm_freak: function hoisting, magical variable declarations?
21:40:22 <otk>  for me, F# is both a scripting language and a er, non scripting language
21:40:28 <mm_freak> tikhonjelvis: doesn't change the simple execute-from-top-to-bottom structure of javascript
21:41:05 <ddarius> mm_freak: It probably is in some technical ways, but doesn't really fit into the environment all that well and it lacks many of the things in O'Caml that are interesting.
21:41:05 <Eduard_Munteanu> What's a nice, well-known book on compilers? I'm more interested in implementation details, if it matters. (I know, a bit offtopic :D)
21:41:20 <otk> ddarius: functors ect?
21:41:34 <mm_freak> ddarius: of course, but it's still an improvement over C#
21:41:36 <ddarius> The people I know that have used C# and F# tend to still prefer to use C# for most work.
21:41:53 <mm_freak> by a pure language judgement, of course
21:41:54 <otk> of course if they come from C# lol
21:42:15 <mm_freak> ddarius: and most people coming from C# give up with F#, because the paradigm is very different
21:42:19 <ddarius> I haven't used F# much, but I have no real desire to use it for what I do with C#, not even counting worrying about others.
21:42:23 <mm_freak> the main paradigm that is
21:42:29 <tikhonjelvis> Eduard_Munteanu: I've heard Modern Compiler Implementation in ML is good, but I haven't read it.
21:42:31 <otk> F#'s finer points have concept hurdles
21:42:33 <ddarius> mm_freak: I'm talking about people like edwardk.
21:42:41 <otk> for someone coming from an OOP language like C#\Java
21:42:56 <mm_freak> i'd be interested in why edwardk moved back to C#
21:43:06 <otk> linq ? heh
21:43:10 <otk> monads in disguise
21:43:31 <mm_freak> otk: F# has something resembling do-notation for custom monad-like structures
21:43:33 <nus> Eduard_Munteanu, Muchnik ACDI
21:43:40 <mm_freak> that's basically LINQ on steroids
21:44:03 <mm_freak> they call this thing "computation expressions" (what an unfortunate name)
21:44:12 <otk> hah
21:44:15 <otk> yes
21:44:25 <otk> basically syntactic sugar for monads afaik
21:44:42 <mm_freak> yes, with the same operations as in haskell, but they somehow forgot that F# is a curried language
21:44:51 <elliott> otk: linq is actually extended lisp comprehensions in disguise.
21:44:54 <mm_freak> it's Return (c, f) instead of Return c f
21:44:59 <elliott> *list
21:45:02 <elliott> Actually I think LINQ might be nicer than Haskell's list comprehensions.
21:45:11 <otk> interesting
21:45:11 <Eduard_Munteanu> tikhonjelvis, nus: thanks, I'll have a look.
21:45:21 <otk> mm_freak: http://blog.matthewdoig.com/?p=98
21:45:25 <otk> maybe monad
21:45:27 <otk> whatever that means
21:45:29 <otk> elliott: ah
21:45:50 <mm_freak> otk: a port of haskell's Maybe type
21:46:23 <cmccann> elliott: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
21:46:23 <otk> cool
21:46:27 <hpaste> ybit pasted “Any reason why this module wouldn't import?” at http://hpaste.org/57097
21:46:47 <Eduard_Munteanu> nus: hm, weird, no Google hits for yours
21:46:54 <elliott> cmccann: yep, that's what i meant
21:47:08 <mm_freak> ybit: do you have an error message?
21:47:12 <ddarius> I'm pretty sure Linq and "computation expressions" are not comparable.  There are things you can do with each that you can't do with the other, though they both share a common core.
21:47:15 <Eduard_Munteanu> nus: hm, is ACDI an acronym? Could you spell it out?
21:47:33 <nus> Eduard_Munteanu, "Advanced Compiler Design and Implementation"
21:47:38 <Eduard_Munteanu> Thanks.
21:47:51 <ddarius> elliott: Linq is explicitly inspired by monads and things like list comprehensions/do-notation.
21:47:54 <otk> mm_freak: turns out you can define your own operator in F# and use it with that port
21:47:59 <mm_freak> ddarius: F#'s type system is much weaker than haskell's…  you can just add operations which need a separate type class in haskell
21:48:02 <yottabit> mm_freak: module is not loaded: `IsFactor' (./IsFactor.hs)
21:48:11 <mm_freak> because in F# "monads" are not implemented as a type class…  they are implemented in an ad hoc manner
21:48:21 <ddarius> mm_freak: I'm aware.  I didn't say anything about Haskell.
21:48:33 <ddarius> Linq and "computation expressions" are implemented roughly the same way.
21:48:43 <otk> http://blog.matthewdoig.com/?p=104 seems very haskell
21:48:48 <otk> >>=
21:48:57 <mm_freak> ddarius: i know…  but i'm comparing to haskell, because with computation expressions it's easy to add LINQ-like stuff
21:49:04 <mm_freak> although i'm not sure whether you can add everything
21:49:15 <elliott> ddarius: I know it is.
21:49:20 <louzer> "sum $ map (\i -> i^2) [1..10]" works but "sum [1..10] ^ 2 - sum $ map (\i -> i^2) [1..10]" doesn't work. Why would that be the case?
21:49:35 <mm_freak> yottabit: context?  GHCi?
21:49:41 <otk> louzer: why power of 2? just multiply it by itself its its power of 2
21:49:47 <otk> extra wasted computation
21:49:55 <otk> er
21:49:55 <louzer> otk: ok
21:50:05 <otk> actually i don't know haskell i shouldn't be speaking out of line
21:50:06 <mauke> louzer: because 'sum [1..10] ^ 2 - sum' is a type error
21:50:07 <otk> hehe
21:50:10 <cmccann> ddarius, LINQ is based on an interface, so I'd expect it to include implicitly existential-ish types that wouldn't translate straightforwardly to something that expects a consistent monad
21:50:18 <mauke> otk: what
21:50:32 <louzer> mauke: but the sum on the RHS has a $ to it
21:50:39 <mauke> louzer: what?
21:50:54 <louzer> mauke: the sum on the right hand side has a $
21:50:58 <elliott> mauke: what!
21:50:59 <mauke> louzer: no, it doesn't
21:51:08 <cmccann> but I'm not sure how much that really gives you vs. F#'s computation expressions
21:51:31 <ddarius> mm_freak: One of the things you can do with Linq are things like Linq to Sql which involves 1) having Sql-like notation that "computation expressions" doesn't seem to support and also 2) being able to reify lambdas which I would think F# supports as well as C#, but I don't know for sure.
21:51:34 <Eduard_Munteanu> louzer: that doesn't parse correctly
21:51:35 <louzer> mauke: "- sum $"
21:51:50 <mauke> louzer: no, sum [1..10] ^ 2 - sum $
21:52:06 <otk> assuming carrot ^ is power in haskell, (as opposed to concatenating strings) ^2 is an extra instruction that isnt needed because n^2 is always n * n (i could be wrong though)?
21:52:07 <yottabit> mm_freak: yes
21:52:11 <mauke> otk: caret
21:52:16 <otk> caret, sorry
21:52:23 <mauke> otk: what's an instruction?
21:52:27 <cmccann> mmm carrots
21:52:33 <louzer> mauke: this $ thing is making me crazy. LISP paranthesises are better
21:52:42 <mauke> louzer: no, they aren't
21:52:43 <otk> mauke: an extra action?
21:53:00 <Eduard_Munteanu> I think we need an @un$  :)
21:53:02 <otk> something else spent on cpu time that isn't necessary? im guessing now
21:53:04 <mauke> otk: oh, I'd hope inlining takes care of that
21:53:09 <tikhonjelvis> louzer: You just need to get used to it. Just like you needed to get used to the parentheses ;)
21:53:15 <otk> mauke: ah ok
21:53:22 <otk> compiler gets rid of it
21:53:26 <louzer> tikhonjelvis: ok :(
21:53:32 <mauke> louzer: no one forces you to use $
21:53:36 <mauke> you can just use parens
21:53:42 <tikhonjelvis> louzer: Once you're used it, you'll like it.
21:53:48 <mauke> tikhonjelvis: or not
21:54:03 <louzer> mauke: i want to use $ coz or else why use haskell just use LISP
21:54:06 <Eduard_Munteanu> otk: mind 2 is a compile-time constant, it'd be pretty easy to convert that to i * i
21:54:15 <tikhonjelvis> louzer: Plenty of other reasons?
21:54:18 <mauke> louzer: infix operators
21:54:18 <Grace__> Hello
21:54:27 <tikhonjelvis> louzer: Also depends on which Lisp.
21:54:40 <louzer> tikhonjelvis: hmm
21:54:45 <otk> Eduard_Munteanu: ah
21:54:53 <Eduard_Munteanu> Grace__: hi
21:54:53 <otk> haskell compiler are smart
21:54:55 <tikhonjelvis> If you're thinking of one that's even remotely mainstream, it's dynamically typed.
21:55:04 <Grace__> I have an enumerated data as follow:
21:55:09 <Eduard_Munteanu> otk: I just guessed, I'm not saying it's actually doing that, but it looks reasonable
21:55:12 <Grace__> data Set a = Set [a]
21:55:33 <otk> Eduard_Munteanu: it is indeed reasonable
21:55:37 <Grace__> Eduard_Munteanu: deriving (Show, Eq, Ord)
21:55:59 <yottabit> mm_freak: i'm ybit, in case there's confusion
21:56:06 <ion> edwardk moved back to C#?
21:56:07 <Grace__> I defined a universal set as below:
21:56:10 <Eduard_Munteanu> Grace__: well, you don't have to tell me in particular, anybody can answer :)
21:56:27 <otk> this resulting binary from GHC is rather big! 2181KB do you need to strip a binary after compile?
21:56:28 <mm_freak> yottabit: no confusion, but sorry, i've never seen that error message
21:56:44 <mm_freak> yottabit: sometimes GHCi gets confused with already compiled modules though
21:57:01 <mm_freak> so you might want to delete existing .o and .hi files and then try again
21:57:02 <Eduard_Munteanu> otk: stripping isn't the issue, static linking is
21:57:03 <Grace__> uniS :: (Ord a,Enum a,Bounded a) => Set a
21:57:04 <Grace__> uniS = Set [minBound..maxBound]
21:57:10 <otk> Eduard_Munteanu: ah
21:57:14 <Eduard_Munteanu> Although 'strip' might help cut down the size as well.
21:57:22 <otk> i wasn't aware of this
21:57:24 <Eduard_Munteanu> otk: try -dynamic
21:57:44 <otk> Eduard_Munteanu: will that be binary compatible with other systems that don't have the haskell runtime?
21:58:12 <Grace__> When I check it, it only show Set [()]. So what is wrong with it, thanks?
21:58:26 <Eduard_Munteanu> otk: nope
21:58:33 <mauke> Grace__: you're checking it at type Set ()
21:58:34 <elliott> Eduard_Munteanu: Can't do -dynamic on GHC 6.4.
21:58:44 <Eduard_Munteanu> GHC 6.4? Heh.
21:58:49 <Eduard_Munteanu> That ooooollld :)
21:58:53 <elliott> otk: Newer binaries tend to be smaller I think. You can strip that one, anyway.
21:58:54 <otk> Eduard_Munteanu: dissapointing but acceptable
21:58:55 <elliott> strip -s bin
21:59:07 <Eduard_Munteanu> *that's
21:59:22 <otk> elliott: halved it
21:59:29 <otk> better
21:59:33 <m3ga> otk: there was a significant reduction in inary sizes between 6.8 and 6.10
21:59:33 <Eduard_Munteanu> Grace__: try   uniS :: Set Int    for example
21:59:39 <otk> but.. hmmmm
21:59:51 <otk> haskell is not used for embedded programming?
21:59:52 <Eduard_Munteanu> Grace__: when you test it, that is.
22:00:14 <otk> i would expect a 30-70KB binary size
22:00:15 <Eduard_Munteanu> otk: not really, or at least not directly.
22:00:20 <otk> ah ok
22:00:26 <otk> im arguing a moot point in any case
22:00:28 <elliott> otk: There are Haskell DSLs that generate embedded programs with very good characteristics.
22:00:35 <Eduard_Munteanu> otk: there are some Haskell libs that generate code for embedded platforms.
22:00:41 <elliott> http://hackage.haskell.org/package/atom, http://hackage.haskell.org/package/copilot
22:00:44 <elliott> both for hard real-time systems
22:00:49 <otk> interesting
22:01:25 <Eduard_Munteanu> otk: why are you using GHC 6.4 though?
22:01:34 <otk> im not anymore, i fixed it with magic
22:01:42 <ski> Eduard_Munteanu : "Modern Compiler Implementation" is good
22:02:23 <otk> and by magic i mean changing import qualified Data.ByteString.Base to import qualified Data.ByteString.Internal as B
22:02:35 <otk> (and it compiled in haskell platform 2011.4
22:02:36 <otk> )
22:03:02 <Eduard_Munteanu> ski: hm, there seem to be multiple variant floating around, "in C", "in ML", "in Java" ...
22:03:23 <ski> Eduard_Munteanu : yes, afaik, theyre basically the same, just different implementation languages
22:03:26 <otk> so, will the upcoming standford NLP courses be using haskell i wonder :)
22:03:30 <Eduard_Munteanu> (not that I really care about the impl language, though)
22:03:31 * ski got the ML one, of course
22:03:39 <ddarius> Eduard_Munteanu: Yes.  From what I hear there are some significant differences, though the overall thrust is the same.
22:03:46 <otk> ski: highfive ML! SML?
22:03:52 <ski> yes, it's SML
22:03:56 <otk> woot
22:04:30 <ski> (otk : btw, i assume you know there is #sml and #ocaml)
22:04:39 <otk> i didn't know this
22:04:46 <Eduard_Munteanu> I see.
22:04:56 <otk> wow, populated
22:04:58 <otk> ski: thank you :)
22:05:04 <Grace__> Eduard_Munteanu: I want to use it on an enumerated type which is called 'Set a', and I defined the 'Set a' as:
22:05:06 <Grace__> data Set a = Set [a]
22:05:07 <Grace__>                     deriving (Show,Eq,Ord)
22:05:09 <Grace__> Then, I want to define the universal set of things of type a as
22:05:10 <Grace__> uniS :: (Ord a, Enum a, Bounded a) => Set a
22:05:12 <Grace__> uniS = Set [minBound..maxBound]
22:05:13 <Grace__> However, I didn't get what I wanted; it show Set [()]........
22:05:15 <Grace__> Did I do something wrong here? Thanks.
22:05:50 <mauke> Grace__: why did you ignore the answers you got and repeated everything you said?
22:05:57 <otk> now all i need is a #johnbackusfp
22:06:05 <Eduard_Munteanu> Grace__: well, we told you. If you're just trying to evaluate uniS in ghci you'll get uniS for a = ()
22:06:23 <Eduard_Munteanu> Grace__: you need to specify the type you want explicitly, if you want something else
22:06:29 * ddarius awaits the third iteration.
22:06:39 <elliott> <Eduard_Munteanu> otk: mind 2 is a compile-time constant, it'd be pretty easy to convert that to i * i
22:06:46 <elliott> Eduard_Munteanu: This does not happen in practice, actually.
22:06:48 <Grace__> Oh, sorry... I didn't see your answers above.... Thanks....
22:06:52 <elliott> I think because (^) uses a fancy algorithm.
22:06:57 <elliott> So it's too big for GHC to inline it.
22:07:21 <Eduard_Munteanu> elliott: oh, I would've expected an explicit heuristic, rather than inlining doing the trick
22:07:43 <elliott> There should be a RULE for it.
22:07:48 <ClaudiusMaximus> and x^2 tends to default the 2 to Integer
22:07:54 <ddarius> You can make a rule for it...
22:08:18 <Eduard_Munteanu> :t (^)
22:08:19 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
22:08:20 * ddarius uses F_2 and breaks your rule.
22:08:40 <Eduard_Munteanu> Hm.
22:09:21 <elliott> ddarius: It should be in the Prelude, then.
22:09:32 <Eduard_Munteanu> F_2?
22:09:34 <ClaudiusMaximus> > x^7
22:09:35 <lambdabot>   x * x * (x * x) * (x * x * x)
22:09:36 <ddarius> What should be in the Prelude?
22:10:01 <Eduard_Munteanu> The rule, I'd guess.
22:12:36 <otk> cool
22:12:40 <otk> > x ^ 1
22:12:41 <lambdabot>   x
22:12:47 <otk> > 0 ^ 0
22:12:48 <lambdabot>   1
22:12:54 <otk> oh clever :)
22:13:06 <otk> what about ..
22:13:09 <ski> > x ^ 0
22:13:10 <lambdabot>   1
22:13:14 <otk> > 0 ^ 0.3
22:13:15 <lambdabot>   Ambiguous type variable `t' in the constraints:
22:13:16 <lambdabot>    `GHC.Real.Fractional t'
22:13:16 <lambdabot> ...
22:13:21 <ski> > 0 ** 0.3
22:13:22 <lambdabot>   0.0
22:13:28 <ski> @type (^)
22:13:29 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
22:13:30 <ski> @type (^^)
22:13:31 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
22:13:32 <ski> @type (**)
22:13:32 <otk> ** = ^ in ocaml?
22:13:33 <lambdabot> forall a. (Floating a) => a -> a -> a
22:13:35 <otk> er
22:13:37 <otk> in haskell
22:13:59 <otk> (i hate operator differences between languages, clearly ^ is to concant strings)
22:14:09 <elliott> otk: Note that that x thing is not a Haskell feature.
22:14:13 <ddarius> Just to put it out there, (**) is fucking horrible syntax for exponentiation.
22:14:16 <elliott> It's just a silly hack using the typeclass system.
22:14:18 <Eduard_Munteanu> Nah, ^ clearly does bitwise xor :P
22:14:24 <kallisti> ^ is integer exponents over positive bases. ^^ is integer exponents over any integers. ** is floating point exponentiation.
22:14:33 <Sgeo> ^ should change the direction that the code is read.
22:14:38 <otk> kallisti: interesting
22:14:38 <ski> s/positive/non-negative/
22:14:44 <otk> yoink
22:14:50 <kallisti> er actually both the exponent and integer have to be non-negative. yes.
22:14:55 <kallisti> for ^
22:15:03 <otk> hmm
22:15:05 <Sgeo> > 0^0
22:15:06 <lambdabot>   1
22:15:08 <ski> > (-3) ^ 5
22:15:10 <lambdabot>   -243
22:15:13 <kallisti> oh, nevermind.
22:15:17 <kallisti> just the exponent.
22:15:19 <Sgeo> > (-1) ^ 2
22:15:20 <lambdabot>   1
22:15:22 <otk> > 3 ^ 0xFF
22:15:23 <lambdabot>   463361507923815775883132622632204343714062836028430459972016081433453575432...
22:15:26 <ski> @src (^)
22:15:26 <lambdabot> x ^ 0            =  1
22:15:26 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:15:26 <lambdabot>   where f _ 0 y = y
22:15:26 <lambdabot>         f x n y = g x n
22:15:26 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:15:28 <otk> > 3 ^ 0xFFFFFFFFFFFFFFFFFF
22:15:28 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:15:30 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:15:31 <Sgeo> > 1 ^ (-2)
22:15:33 <lambdabot>   mueval: ExitFailure 1
22:15:34 <lambdabot>  mueval: Prelude.undefined
22:15:36 <lambdabot>   *Exception: Negative exponent
22:15:44 <otk> > 3 ^ 0xFFFFFFFF
22:15:47 <otk> > 3 ^ 0xFFFFFFFF + 1
22:15:49 <lambdabot>   mueval: ExitFailure 1
22:15:49 <lambdabot>  mueval: Prelude.undefined
22:15:50 <ddarius> (^) :: (Integral a, Monoid m) => m -> a -> m; (^^) :: (Integral a, Group g) => g -> a -> g;
22:15:52 <lambdabot>   mueval: ExitFailure 1
22:15:52 <lambdabot>  mueval: Prelude.undefined
22:16:05 <elliott> There's an "undefined" error still in the prelude?
22:16:08 <otk> :o
22:16:20 <otk> haskell doesn't wrap integers i see?
22:16:25 <otk> i.e. overflow is checked
22:16:30 <mauke>  depends
22:16:32 <elliott> Haskell has fixed-size and arbitrary-size integers.
22:16:33 <c_wraith> Integer doesn't overflow
22:16:34 <ddarius> otk: There is no overflow.
22:16:35 <elliott> > 348957347295264237846823946782346278t4678234678234678923462378946237894678923647892364789236423784623784
22:16:36 <lambdabot>   Not in scope:
22:16:37 <ski> > 3 ^ 0xFF :: Int8
22:16:37 <lambdabot>    `t46782346782346789234623789462378946789236478923647892364...
22:16:38 <lambdabot>   -85
22:16:38 <Sgeo> > (maxBound :: Int) + 1
22:16:39 <lambdabot>   -9223372036854775808
22:16:42 <elliott> wtf
22:16:43 <ski> > 3 ^ 0xFF :: Int16
22:16:43 <lambdabot>   -22869
22:16:46 <ski> > 3 ^ 0xFF :: Int32
22:16:48 <elliott> > 348957347295264237846823946782346278t4678234678234678923462378946237894678923647892364789236423784623784
22:16:48 <lambdabot>   Not in scope:
22:16:48 <lambdabot>    `t46782346782346789234623789462378946789236478923647892364...
22:16:48 <lambdabot>   can't find file: L.hs
22:16:48 <elliott> wtf
22:16:53 <otk> ddarius: overflow is a useful optimization though
22:16:58 <ddarius> elliott: Stop writing t
22:17:05 <elliott> > 3489573472952642378468239467823462784678234678234678923462378946237894678923647892364789236423784623784
22:17:06 <lambdabot>   348957347295264237846823946782346278467823467823467892346237894623789467892...
22:17:08 <elliott> > 3489573472952642378468239467823462784678234678234678923462378946237894678923647892364789236423784623784 :: Int
22:17:09 <lambdabot>   2485935910540766888
22:17:29 * Sgeo stabs Ints in the Int
22:17:33 <elliott> Integer is machine word overflowing to bignum, Int is machine word. (Implementation details; specification-wise, Int can store up to 2^29 - 1, and Integer can store anything.)
22:17:35 <ddarius> otk: Overflow is not an optimization, it is a totally different semantics.
22:18:03 <otk> crc32 uses overflow as an optimization iirc? (could be wrong)
22:18:05 <ski> > maxBound :: Int
22:18:07 <lambdabot>   9223372036854775807
22:18:13 <otk> > maxBound :: int64
22:18:14 <lambdabot>   Could not deduce (GHC.Enum.Bounded int64) from the context ()
22:18:14 <lambdabot>    arising fr...
22:18:23 <otk> > maxBound :: long
22:18:24 <Sgeo> > maxBound :: Int64
22:18:24 <lambdabot>   Could not deduce (GHC.Enum.Bounded long) from the context ()
22:18:24 <lambdabot>    arising fro...
22:18:24 <c_wraith> there are also the contents of Data.Word and Data.Int for fixed-size unsigned and signed integer types
22:18:25 <lambdabot>   9223372036854775807
22:18:34 <kallisti> otk: titlecase
22:18:34 <otk> wow large
22:18:35 <otk> kallisti: ah
22:18:54 <otk> > maxBound :: String
22:18:55 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Base.String)
22:18:55 <lambdabot>    arising from a use of...
22:19:00 <kallisti> an identifier with a lowercase letter at the beginning signifies a type variable
22:19:00 <Sgeo> Clearly, we should just use CReals for everything
22:19:03 <c_wraith> > maxBound :: Int8
22:19:03 <lambdabot>   127
22:19:08 <Sgeo> :t iterate
22:19:08 <ski> > maxBound :: Bool
22:19:09 <lambdabot>   True
22:19:10 <lambdabot> forall a. (a -> a) -> a -> [a]
22:19:14 <ski> > maxBound :: ()
22:19:15 <lambdabot>   ()
22:19:25 <otk> kallisti: i see
22:19:36 <mauke> > sqrt 2 :: CReal
22:19:37 <lambdabot>   1.4142135623730950488016887242096980785697
22:19:38 <ddarius> fromInteger = odd
22:19:48 <ski> > showCReal 100 (sqrt 2)
22:19:48 <Sgeo> > (!! 100) $ iterate ((*3) . (1/3)) $ 5
22:19:49 <lambdabot>   "1.414213562373095048801688724209698078569671875376948073176679737990732478...
22:19:49 <lambdabot>   can't find file: L.hs
22:19:51 <Sgeo> > (!! 100) $ iterate ((*3) . (1/3)) $ 5
22:19:56 <lambdabot>   mueval-core: Time limit exceeded
22:19:59 <otk> > foldr [1,2,3,4,5] + 0
22:19:59 <lambdabot>   Couldn't match expected type `a -> b -> b'
22:20:00 <lambdabot>         against inferred type `[...
22:20:08 <kallisti> > head $ showCReal 1000 pi
22:20:09 <lambdabot>   '3'
22:20:12 <Sgeo> Hmm, I need to rethink that
22:20:18 <otk> >sum [1,2,3,4,5]
22:20:25 <Sgeo> otk, space after >
22:20:27 <otk> > sum [1,2,3,4,5]
22:20:28 <lambdabot>   15
22:20:35 <Sgeo> > sum [1..100]
22:20:36 <lambdabot>   5050
22:20:37 <otk> > foldr [1,2,3,4,5] (+) 0
22:20:38 <lambdabot>   Couldn't match expected type `a -> b -> b'
22:20:38 <lambdabot>         against inferred type `[...
22:20:44 * otk doesn't know how to do a haskell fold
22:20:45 <elliott> > foldr f z [a,b,c,d]
22:20:46 <lambdabot>   f a (f b (f c (f d z)))
22:20:55 <elliott> > foldr (+) z [a,b,c,d]
22:20:56 <lambdabot>   a + (b + (c + (d + z)))
22:20:58 <elliott> > foldr (+) 0 [1,2,3,4]
22:20:59 <lambdabot>   10
22:21:03 <otk> ah
22:21:07 <otk> on the left hand side
22:21:07 <elliott> > foldl (+) z [a,b,c,d]
22:21:08 <lambdabot>   z + a + b + c + d
22:21:15 <ddarius> > foldr (+) 0 [1,2,3,4] :: Expr
22:21:16 <elliott> > foldl1 (+) [a,b,c,d]
22:21:16 <lambdabot>   1 + (2 + (3 + (4 + 0)))
22:21:17 <lambdabot>   a + b + c + d
22:21:45 <mauke> :t foldr
22:21:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:21:48 <otk> > foldr (+) "" ['a','b','c']
22:21:48 <mauke> otk: ^
22:21:48 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:21:48 <lambdabot>         against inferred ty...
22:22:16 <otk> cool
22:22:19 <otk> :t map
22:22:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:22:26 <ski> > foldr (++) "" ["a","b","c"]
22:22:28 <lambdabot>   "abc"
22:22:36 <otk> interesting
22:22:39 <elliott> > map f [a,b,c,d]
22:22:41 <lambdabot>   Ambiguous type variable `b' in the constraints:
22:22:41 <lambdabot>    `GHC.Show.Show b'
22:22:41 <lambdabot>      a...
22:22:43 <elliott> > map f [a,b,c,d] :: Expr
22:22:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:22:44 <lambdabot>         against inferred ...
22:22:46 <elliott> :(
22:22:46 <otk> obviously that is a waste of an accumulator though right?
22:22:47 <elliott> > map f [a,b,c,d] :: [Expr]
22:22:48 <lambdabot>   [f a,f b,f c,f d]
22:22:55 <elliott> otk: Waste howso?
22:23:03 <ddarius> What accumulator?
22:23:04 <elliott> foldr (++) "" is the best way to concat some strings.
22:23:12 <ski> > foldr (\n s -> concat ["(",show n," + ",s,")"]) "0" [2,5,52]
22:23:13 <lambdabot>   "(2 + (5 + (52 + 0)))"
22:23:26 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,5,52]
22:23:27 <lambdabot>   "(((0 + 2) + 5) + 52)"
22:23:28 <monochrom> optimizations should be stated with: a specification S, and two implementations I, J. I and J both implement S, and J uses less energy (or whatever), that's when you say J is an optimization of I.
22:23:28 <otk> ah i see
22:23:34 <otk> interesting
22:23:51 <otk> what does the compiler do with fold
22:23:53 <mauke> > foldr (printf "(%d + %s)") "0" [2,5,52]
22:23:54 <lambdabot>   "(2 + (5 + (52 + 0)))"
22:24:00 <elliott> @src foldr
22:24:01 <lambdabot> foldr f z []     = z
22:24:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:24:01 <ddarius> monochrom: So you need additionally a proof that J uses less whatever than I.
22:24:07 <otk> > + 5 5
22:24:07 <lambdabot>   <no location info>: parse error on input `+'
22:24:10 <elliott> The compiler does nothing with fold, it's a library function.
22:24:12 <mauke> > (+) 5 5
22:24:13 <lambdabot>   10
22:24:14 <otk> ah
22:24:19 <otk> parens required
22:24:26 <ski> same as in O'Caml
22:24:29 <otk> ya
22:24:38 <otk> and F# of course
22:24:42 <mauke> > (+ 5) 5
22:24:43 <lambdabot>   10
22:24:45 <otk> i have always wondered why parens are required
22:24:47 <monochrom> if S is "add numbers", I uses unlimited precision, J uses Word32, then J is not an optimization of I, since J breaks S
22:24:53 <kallisti> otk: otherwise it's ambiguous to parse.
22:24:58 <otk> lisp doesn't have them in the same way though
22:25:00 <otk> iirc?
22:25:02 * ski doesn't know very much about F#, except that it's derived from O'Caml
22:25:09 <monochrom> but if S is "add numbers in the range 0-10", I uses unlimited precision, J uses Word32, then J is an optimization of I
22:25:09 <mauke> otk: lisp doesn't have infix syntax
22:25:12 <kallisti> otk: lisp is all prefix
22:25:17 <otk> ah
22:25:19 <otk> thats true
22:25:24 <otk> ski: same as ocaml mostly
22:25:32 <ski> otk : is lisps, brackets have semantic meaning : they are never optional
22:25:33 <otk> i can go to langref and use ocaml snippets in F#
22:25:48 <monochrom> my view is heretic because programmers pretend that S never exists.
22:25:54 <Eduard_Munteanu> Also, you can't depend on behavior which isn't specified.
22:25:58 <otk> ski: hm
22:26:09 <otk> this is quite an interesting active channel :)
22:26:25 <ski> otk : yeah, we like it that way :)
22:27:12 <Eduard_Munteanu> 800 people is quite a lot, comparing to other channels
22:27:19 <ddarius> monochrom: Half the time programmers use "optimize" non-transitively and thus eliminate I as well.
22:27:24 <otk> think i will make an effort to learn haskell
22:27:29 <otk> i like its concepts
22:27:48 <otk> everytime i have tried (twice) in the past though i have given up
22:27:51 <Eduard_Munteanu> Even arguably more popular programming languages have smaller channels on Freenode.
22:28:07 <otk> haskell seems to have less sperglording
22:28:37 <ski> (alternatively s/heretic/heterodox/, i suppose)
22:28:47 <CodeWeaver> otk, fret not, there's a lot of great people here to help you learn. :)
22:28:56 <CodeWeaver> I've figured that out after only a few days of being here.
22:29:03 <ski> "sperglording" ?
22:29:40 <Eduard_Munteanu> @google sperglording
22:29:42 <lambdabot> http://www.urbandictionary.com/define.php?term=sperglord
22:29:42 <lambdabot> Title: Urban Dictionary: sperglord
22:30:08 <Eduard_Munteanu> (first time I've heard it too)
22:30:17 <otk> heh
22:30:26 <otk> i heard it the other day refering to Ruby/Python programmers
22:31:31 <kallisti> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode  channels on Freenode by size.
22:41:19 * ddarius endeavors to dispense "true facts" in a more creepy manner.
22:42:50 <ski> as long as you don't stop ..
22:47:25 <nyingen> @quote
22:47:25 <lambdabot> tg_ says: I can't wait until 100 years from now when 'eating food' will be deprecated from our lexicon in favor of 'oming noms'
22:47:56 <ski> @ghc
22:47:56 <lambdabot> ghc says: Can't represent explicit kind signatures yet
22:59:47 <nyingen> @quote
22:59:47 <lambdabot> <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
23:00:08 <nyingen> I don't get it
23:00:31 <mauke> preflex: quote
23:00:37 <preflex>  <preflex> no quotes found for preflex
23:00:49 <mauke> that's stupid
23:01:04 <Eduard_Munteanu> Talking 3rd person about yourself is kinda dumb :P
23:01:10 <mauke> preflex: forget preflex no quotes found for preflex
23:01:13 <Eduard_Munteanu> (even for a bot :D)
23:01:15 <mauke> preflex: quote
23:01:16 <preflex>  <hex> SEO! SEO! DAYLIGHT COME AND ME WAN GO HOME!  COME MISTER SEARCHY MAN OPTIMIZE ME KEYWORDS
23:01:32 <Eduard_Munteanu> Oh, heh.
23:02:12 <nyingen> Q: "How many Prolog programmers does it take to change a light bulb?" A: "No."
23:02:38 <ion> @quote
23:02:38 <ion> @quote
23:02:38 <lambdabot> accel says: fuck; *.lhs files are unreadable
23:02:39 <lambdabot> JohnDEarle says: I do not wish to reveal all the mysteries of the universe in one sitting
23:02:53 <ski> (mm_freak : ?)
23:03:20 * hackagebot yjtools 0.9.13 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.13 (YoshikuniJujo)
23:05:00 <ski> @quote Keefe
23:05:01 <lambdabot> Richard says: O'Keefe "If I don't write it, I won't wrong it."
23:05:44 <elliott> attribution problems there
23:06:00 <mauke> preflex: quote
23:06:01 <preflex>  <vixey> debugging code is admitting defeat
23:06:37 <ski> @remember O'Keefe "Elegance is not optional."
23:06:37 <lambdabot> Nice!
23:07:00 <ski> (<http://www.myire.org/elegance.html>)
23:07:34 <elliott> @forget Richard O'Keefe "If I don't write it, I won't wrong it."
23:07:35 <lambdabot> Done.
23:07:42 <elliott> @remember O'Keefe "If I don't write it, I won't wrong it."
23:07:42 <lambdabot> Okay.
23:10:44 <nyingen> @quote
23:10:44 <lambdabot> Spark says: "oops, we proved the wrong property"
23:17:26 <ski> "Sacrificing the calf of flexibility on the altar of reliability" by Peter J. Denning in 1976
23:22:22 <jirka> Hello, can you please help me understand how Haskell expressions work? I hoped to find my answers here http://www.haskell.org/onlinereport/exps.html, but it only enlarged my confussion…
23:23:18 <jirka> for example, I know that if I want to make an infix operator a prefix function, I can enclose it in (). So (+) 2 3 and so on.
23:23:40 <jirka> But I can define function like let f = (+ 2)
23:24:05 <tikhonjelvis> That's just like taking a + 2 and chopping off the a
23:24:15 <Eduard_Munteanu> It's called a "section".
23:24:58 <jirka> but why when i try to evaluate (+ 2 3), I get a cryptic error message
23:25:07 <tikhonjelvis> Because a + 2 3 would not make sense.
23:25:16 <tikhonjelvis> The (+ 2) is the same as \ a -> a + 2
23:25:23 <Eduard_Munteanu> > (+ 2) 3
23:25:24 <lambdabot>   5
23:25:25 <tikhonjelvis> So (+ 2 3) is the same as \ a -> a + 2 3
23:25:45 <Eduard_Munteanu> If it makes any sense, that is.
23:26:14 <jirka> It sort of does. But I did not found any of this at http://www.haskell.org/onlinereport/exps.html
23:26:29 <tikhonjelvis> Yeah, that's not the right thing to read if you're just learning.
23:27:09 <Eduard_Munteanu> | ( expi+1 qop(a,i) ) lambdabot (left section)
23:27:13 <Eduard_Munteanu> It is there.
23:27:41 <Eduard_Munteanu> And the right section.
23:27:56 <jirka> OK fine, but that is a page with syntax, but I need semantic
23:28:24 <nus> jirka, read up on currying
23:29:13 <elliott> jirka: Reading the report's desugaring probably won't help you understand the syntactic misunderstanding you're having.
23:29:17 <elliott> (2 +) === \x -> 2+x
23:29:22 <elliott> (+ 2) === \x -> x+2
23:29:35 <elliott> If you omit one half of an infix operator, it's partially-applied like that.
23:29:39 <elliott> That's the entire rule.
23:29:51 <elliott> (+ 2 3) is (+ (2 3)), which is trying to apply 2 to 3, which makes no sense.
23:30:55 <nus> > (+ 2 3) 1
23:30:56 <Eduard_Munteanu> jirka: you should probably use LYAH as a learning material if that's what you're looking for.
23:30:56 <lambdabot>   3
23:30:59 <Eduard_Munteanu> @where lyah
23:31:00 <lambdabot> http://www.learnyouahaskell.com/
23:31:36 <companion_cube> did it just convert 2 to const 2 ?
23:31:58 <elliott> nus: Don't.
23:32:02 <elliott> That's lambdabot's silliness.
23:35:01 <jirka> "If you omit one half of an infix operator, it's partially-applied like that." I would still much appreciate if you could point me to the original source from which for example this claim comes from
23:36:25 <elliott> "Sections are written as ( op e ) or ( e op ), where op is a binary operator and e is an expression. Sections are a convenient syntax for partial application of binary operators."
23:36:28 <elliott> -- http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-300003.5
23:36:39 <elliott> See also the "translation" just below.
23:36:42 <elliott> jirka: ^
23:36:56 <Ngevd> Hello!
23:37:14 <Eduard_Munteanu> Ngevd: hi
23:38:04 <Ngevd> Well, I have three barely started Family Tree programs being written in Haskell by me
23:38:13 <Ngevd> I sort of lost control of that sentence...
23:38:51 <Eduard_Munteanu> What's that?
23:39:13 <Ngevd> Family Tree making software is software that is used to make family trees
23:39:26 <Ngevd> I have began three times to write one of these programs
23:39:28 <Eduard_Munteanu> Oh, ok, I thought it was some sort of exercise.
23:39:39 <jirka> Because this rule seems sort of crazy. I am an parser in GHCI, I am evaluating an expression, suddenly, operator section creeps up, That is defining a function, so suddenly the result of that expression can be a function. Or the function is then given additional parameters…
23:39:49 <jirka> It all seems to me really messy
23:40:02 <elliott> jirka: Huh?
23:40:08 <tikhonjelvis> It's neat in practice.
23:40:10 <elliott> "The result of that expression can be a function" -- the result of any expression can be a function.
23:40:15 <elliott> Sections are no different.
23:40:22 <elliott> :t (id *** id)
23:40:23 <lambdabot> forall b b'. (b, b') -> (b, b')
23:40:28 <tikhonjelvis> You can write stuff like map (+ 2) [1..10] which just makes sense.
23:40:30 <elliott> That's a fully-applied, no-section appliaction.
23:40:34 <elliott> It's a function.
23:40:42 <elliott> So GHCi already has to "cope" with the fact that any expression's result can be a function.
23:41:17 <elliott> Anyway, it's just syntactic sugar; the parser could expand (OP e) and (e OP) into their equivalents at parse-time.
23:41:51 <Eduard_Munteanu> When generating the AST you mean.
23:42:07 <elliott> Right.
23:42:31 <jirka> So 2 + 3 is a syntactic sugar for (+) 2 3 or is it the other way around?
23:43:03 <Eduard_Munteanu> None.
23:43:12 <Eduard_Munteanu> Both should parse to the same representation, AFAICT.
23:43:31 <elliott> jirka: Sure, 2 + 3 is sugar for (+) 2 3. I don't know whether it's defined that way, but the parser could easily and validly make that reduction.
23:43:32 <ibid> i expect both to parse differently.  however, semantically they are the same
23:43:58 <jirka> Thanks
23:45:34 <jirka> Another example. I have a + b * c. I know I can write it in prefix as (+) a ((*) b c) . OK. Now I know that f(g(x)) ~ (f.g) (x)
23:46:12 <Ngevd> > let cascade = flip . (((!!) .) . iterate) in cascade (*10) 5 1
23:46:14 <lambdabot>   100000
23:46:29 <Ngevd> :)
23:46:59 <ion> ugly
23:47:28 <Ngevd> > let cascade f n x = iterate f x !! n in cascade (*10) 5 1
23:47:29 <lambdabot>   100000
23:47:36 <Eduard_Munteanu> @pl \a b c -> a + b * c
23:47:36 <lambdabot> (. (*)) . (.) . (+)
23:47:49 <jirka> So I have (+ a) . (* b) c . So I can do let f a b = (+ a) . (* b) and somehow then f 2 3 4 returns 14 and it all works.
23:48:26 <tikhonjelvis> It's because you basically have f a b = (\ x -> x + a) . (\ x -> x * b)
23:48:43 <tikhonjelvis> So f a b is itself a function.
23:49:23 <jirka> My question is, How haskell know, that the right side should be rewritten to f a b = (\z -> (\ x -> x + a) . (\ x -> x * b) z) ?
23:49:41 <jirka> f a b z, I mean
23:49:54 <tikhonjelvis> Well, f a b c is the same as (f a b) c
23:50:35 <tikhonjelvis> So it evaluates f a b, which is a function (as I explained earlier). Then it takes that resulting function and passes c into it.
23:51:33 <Eduard_Munteanu> jirka: it's called eta-expanding
23:52:00 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Eta_conversion#.CE.B7-conversion
23:52:14 <elliott> jirka: It knows because
23:52:15 <elliott> @src (.)
23:52:15 <lambdabot> (f . g) x = f (g x)
23:52:15 <lambdabot> NB: In lambdabot,  (.) = fmap
23:52:34 <elliott> So, (+ a) . (* b) === (\f g x -> f (g x)) (+ a) (* b)
23:52:42 <Eduard_Munteanu> It also knows it makes sense because of the types involved.
23:52:46 <elliott> === (\x -> (+ a) ((* b) x))
23:52:55 <elliott> === (\x -> (x*b)+a)
23:52:56 <tikhonjelvis> Why is (.) fmap in lambdabot?
23:53:03 <elliott> tikhonjelvis: Because Cale.
23:53:06 <elliott> -skell.
23:53:08 <Eduard_Munteanu> :)
23:53:55 <jirka> But how can you possibly implement an interpreter for this? In C or so, you just put all the function arguments on the stack and call the function on it. And you always get a value. But here you can end up with a partially applied function, and so you do not have a return value…
23:54:23 <elliott> jirka: Haskell implementation is roughly nothing like C implementation.
23:54:33 <tikhonjelvis> In general, functions are also just values.
23:54:36 <tikhonjelvis> So you return a function.
23:54:41 <elliott> Explaining all the differences on IRC would be an exercise in futility; you might wish to read a book on the implementation of functional languages.
23:55:03 <elliott> You can imagine evaluation as proceding by reduction as in my example above, if you want an intuitive model.
23:55:04 <tikhonjelvis> You could also just read SICP.
23:55:10 <ibid> or a book on implementing languages
23:55:18 <insyde> hey question
23:55:25 <Eduard_Munteanu> Certain languages ;)
23:55:27 <insyde> is "a" a character or a string?
23:55:30 <elliott> String.
23:55:31 <elliott> :t "a"
23:55:32 <lambdabot> [Char]
23:55:39 <tikhonjelvis> 'a' is the character
23:55:56 <ibid> so far, there's been nothing particularly FP specific, FP just does this a lot more
23:56:05 <insyde> hmm getting a weird issue where the compiler is viewing it as a char, but maybe there's another problem
23:56:27 <ibid> Eduard_Munteanu: a general book will do, so long as it's not specific to a language
23:56:35 <tikhonjelvis> Maybe your function pattern matches it?
23:56:42 <ibid> ah, the redundancy department of redundancy.  bah :)
23:56:52 <insyde> using it in a case statement
23:56:52 <elliott> ibid: Well, a book on e.g. traditional imperative language implementation won't help much.
23:56:56 <Eduard_Munteanu> ibid: well, I'm not sure how many books deal with the implementation of closures and such
23:57:00 <ibid> Eduard_Munteanu: oh, it will
23:58:10 <ibid> Eduard_Munteanu: unrestricted closures are not that common, but function values are.  even C does them, and if you cover Pascal, you have to introduce most of the machinery
23:58:31 <Eduard_Munteanu> C? How do you mean?
23:58:33 <insyde> On a side note, anything wrong with this? "read(take 1 . drop 1 list)::Int" where list contains strings
23:58:45 <elliott> C's function pointers don't close over a single thing.
23:58:49 <ibid> Eduard_Munteanu: C calls function values pointers
23:58:54 <elliott> You have to explicitly struct closure {void *data; void (*func)(void *);}.
23:59:00 <jirka> You are saying that Pascal and Haskell are build on the same foundations? Does not look remotely like it :P
23:59:01 <ibid> elliott: i didn't say they do
23:59:04 <elliott> So an implementation-of-C book won't help understanding higher-order functions and closures.
23:59:11 <elliott> (The implementation of, that is.)
23:59:16 <Eduard_Munteanu> insyde: take 1 . drop 1 list   doesn't parse right
23:59:20 <elliott> insyde: Yes.
23:59:23 <elliott> insyde: You need a $ after drop 1.
23:59:32 <ibid> jirka: pascal and haskell have the same foundation, but haskell builds on top of it a lot more
23:59:36 <elliott> Right now it's (\x -> take 1 (drop 1 list x)), which doesn't make much sense.
23:59:39 <insyde> elliott: ah okay that explains it
23:59:43 <insyde> elliott: thanks
