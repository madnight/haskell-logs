00:00:05 <mm_freak> and then monad transformers would be harmful altogether, about which i strongly disagree
00:00:15 <ezyang> mm_freak: Right. So the argument that MonadIO is harmful is that /if/ you're programming with IO, you *should* be using IO control structures.
00:00:29 <ezyang> So I similarly argue, monad transformers are harmful *when IO is at the base*
00:00:49 <ezyang> Or, perhaps, that should be qualified as, "And you know IO is at the base and want to deal with it"
00:00:52 <mm_freak> why?  MonadIO is sufficient to throw exceptions
00:00:54 <ezyang> "Which is MonadIO"
00:01:02 <ezyang> It's insufficient to handle them, or bracket.
00:01:11 <ezyang> or anything else that modern Haskell IO offers you.
00:01:50 <mm_freak> correct, but if you ban MonadIO, then you effectively disallow transformer stacks containing ContT to throw exceptions
00:02:14 <mm_freak> MonadIO is a generalization of MonadBaseControl IO
00:02:36 <mm_freak> you should use it, whenever your code doesn't need to handle exceptions or fork threads
00:03:07 <ezyang> I can't think of a situation where that would actually be the case.
00:03:21 <ezyang> My contention here is you always need to handle exceptions.
00:03:25 <mm_freak> see about any library i have uploaded to hackage for examples =)
00:03:36 <ezyang> Or we can weaken this to "if you're making a library for public consumption"
00:03:47 <mm_freak> don't assume there are only application programmers…  there are also library/abstraction programmers
00:04:17 <mm_freak> some libraries /should not/ handle exceptions…  a good example how this can go terribly wrong is the HDBC library
00:04:42 <mm_freak> it catches exceptions, disallowing you to killThread an HDBC-using thread
00:05:32 <ezyang> mm_freak: But they should still be expected to clean up after themselves.
00:05:44 <rwbarton> "Banning" stuff in general is dumb, the idea is to make sure that people only use that stuff when it's the right thing to do.
00:06:00 <mm_freak> yes, and they don't need MonadBaseControl for that…  often abstractions can handle exceptions very well using only MonadIO
00:06:15 <mm_freak> that's what the enumerator library does
00:06:59 <ezyang> mm_freak: Huh, I don't think that is true.
00:07:10 <mm_freak> ezyang: then see the source code of tryIO
00:07:24 <mm_freak> liftIO (x `finally` y) is a common pattern
00:08:14 <ezyang> That's not very modular.
00:08:24 <mm_freak> note that nobody has ever come up with a MonadPeel/MonadControl/MonadBaseControl instance for a CPS-based monad
00:08:29 <mm_freak> so often you don't have a choice
00:08:30 <ezyang> And there easily cases where you fail that ability. See also, enumerator library (enumFile)
00:08:58 <mm_freak> that's not the fault of MonadIO, but of the structure of iteratees
00:09:05 <ezyang> Yeah, exceptions and continuations seem to be an open problem.
00:09:32 <mm_freak> opening files /inside/ of iteratees is just a bad idea
00:10:31 <ezyang> mm_freak: Well, it's what the conduit folks want to do.
00:10:56 <mm_freak> yeah, conduit is cleaner when it comes to resource management
00:11:19 <mm_freak> iteratees are a nice abstraction for handling streams, but not for managing resources
00:11:33 <ezyang> Well, conduits certainly don't work with continuations!
00:12:17 <mm_freak> i don't know…  i even tried to use monad-coroutine for stream processing, but it's just too complicated
00:12:38 <ezyang> mm_freak: :-( I thought coroutines would be a nice way of doing steam processing.
00:12:58 <mm_freak> if you have the tools ready-made for that, yes
00:13:09 <ezyang> Ah I see.
00:13:25 <mm_freak> and i guess monad-coroutine isn't as generic as it could be
00:13:27 <ezyang> Ok, so let's see, so on the issue of MonadIO versus MonadBaseControl
00:14:06 <ezyang> Would you say that MonadBaseControl should be default, *except* in these cases when you have to / should use MonadIO?
00:14:26 <ezyang> (btw I think the HDBC is just bad design; you shouldn't swallow exceptions you don't know about)
00:14:32 <mm_freak> well, view it this way:  not splitting MonadBaseControl and MonadIO is about the same as not splitting Functor and Monad
00:14:57 <ezyang> Erm, the other way around?
00:15:05 <mm_freak> yes, but you get the idea
00:15:12 <mm_freak> MonadBaseControl is more powerful, but less general
00:15:12 <ezyang> I do agree that MonadIO is more general than MonadBaseControl
00:15:21 <ezyang> OK, we're in agreement here :-)
00:15:23 <mm_freak> so you should (as a library designer) use MonadIO whenever you can
00:15:39 <ezyang> Hmmm
00:16:02 <ezyang> OK. So I think the point I want to emphasize here is you should *not* omit functionality because you can't do it in MonadIO
00:16:36 <mm_freak> correct…  if you need to handle exceptions and MonadIO is not sufficient, you should use MonadBaseControl
00:16:57 <mm_freak> in any other case you should use MonadIO, because your library users may get angry otherwise =)
00:17:45 <ezyang> I think there is another countermanding fact, which is that people tend to underestimate how much error handling they are going to end up needing
00:17:52 <mm_freak> i often complain about unfortunte library design…  for example gloss is a nice library for simple exercises, but you can't really do anything serious with it, because the library is just too restrictive
00:18:03 <ezyang> And I think it would be good, culturally, to encourage and make it easy to handle errors.
00:18:44 <mm_freak> also consider that often you can translate IO exceptions to exceptions in your own abstractions
00:18:59 <mm_freak> that's what the enumerator library does…  that's also what netwire does
00:19:14 <ezyang> mm_freak: Insufficient, especially if you want to handle 'mask' correctly.
00:19:37 <mm_freak> why?  mask works, because you're still catching regular IO exceptions
00:19:42 <ezyang> (if you don't handle masking you can implement bracket in enumerator... that's what prompted this problem)
00:19:53 <ezyang> Well, for bracket inside that monad.
00:20:21 <mm_freak> well, then let me ask:  what if you don't even have a monad?
00:20:37 <dmwit> Huh, is this a bug?
00:20:46 <mm_freak> there is ArrowError in the arrows library, which gives you an equivalent to 'bracket' for arrows
00:21:16 <bford> what are the cool kids using for FRP at the moment? does it basically come down to reactive-bananna vs netwire, or are there any other valid choices?
00:21:43 <ezyang> mm_freak: I'd probably say you have no place using exceptions.
00:21:44 <mm_freak> bford: i think those two are the most common…  and reactive-banana is probably more common than netwire
00:21:54 <mm_freak> ezyang: what do you mean?
00:21:55 <bss03> I hadn't heard of netwire.  I was still planning on doing my FRP using a reactive binding.
00:22:14 <mm_freak> bss03: i wouldn't recommend Reactive nowadays
00:22:26 <dmwit> Oh, it's not!
00:22:28 <ezyang> mm_freak: That is to say, you should do the embed the exceptions inside your data type trick.
00:22:30 <dmwit> haha
00:22:56 <mm_freak> ezyang: i still don't understand
00:22:56 <ezyang> But not expect any of the IO machinery to work.
00:23:04 <bford> mm_freak, thanks. what's your take on the different approaches? would it be fair to characterize them as applicative vs arrows or is that too simplistic?
00:23:29 <ezyang> Rephrasing, if you're *not* in a monad, there is no reason to believe the well-designed exceptions/masking facilities of Haskell will work well for believe.
00:23:38 <ezyang> Making this work is a nontrivial task that you have to figure out.
00:23:54 <ezyang> *you
00:23:55 <mm_freak> bford: well, the abstractions can be used in similar ways, but the underlying machinery is different…  if you want to go into UI design, use reactive-banana…  if you want to make games or networking stuff, try netwire
00:24:16 <Sgeo> mm_freak, is that because one works better with events than the other?
00:24:23 <Sgeo> Or what?
00:24:25 <mm_freak> bford: in other words, it's really a question of what kind of application you want to write =)
00:24:50 <mm_freak> ezyang: why?  there is nothing wrong with arrows sitting on top of monads
00:25:04 <bford> mm_freak, what if i want to write a game with a UI? :-0
00:25:23 <mm_freak> Sgeo: not at all…  but there is a ready-made UI library using reactive-banana…  the author has done some nice work
00:25:35 <mm_freak> most of the stuff based on netwire is currently work in progress
00:25:38 <ezyang> mm_freak: I think the analogy with continuations works well? Essentially, you're imposing a different structure on your computations, and the structure given to you by monads may not map cleanly onto the user-facing structure.
00:26:03 <ezyang> Or it maps, but it has undesirable properties.
00:26:08 <mm_freak> Sgeo: view netwire as a generic FRP library, but i've released one proof of concept library based on netwire 1:  webwire, a reactive web framework
00:26:25 <bford> i've played with reactive-bannana and I'm just looking at netwire now, but there seems to be a dearth of examples
00:26:46 <bford> or would webwire be a good example of netwire?
00:26:58 <mm_freak> bford: if "with a UI" you mean "with a menu/heads-up display", then still netwire would be your choice, but if you want to make something like minesweeper, then reactive-banana should be your first choice
00:27:17 <mm_freak> webwire is not a good example anymore, because it's based on netwire 1
00:27:33 <mm_freak> a netwire 3-based webwire is work in progress, but i didn't have the time yet to finish it
00:27:52 <mm_freak> while the released version of webwire is just a proof of concept, the next version should be a real web framework
00:28:18 <mm_freak> ezyang: it's not that simple
00:28:48 <mm_freak> ezyang: it's not a matter of how to map the exceptions from the underlying monad to the arrow, but rather the other way around
00:28:57 <mm_freak> because that way works well usually
00:29:11 <ezyang> mm_freak: I don't think I'm claiming it's simple. In fact, I'm claiming it's complicated.
00:29:17 <bford> mm_freak, i don't suppose you have the code in source control anywhere I can look at do you, i think that might be helpful for learning purposes?
00:29:29 <mm_freak> ezyang: consider the classic example of arrows, where your type is not a monad, because you have some static information attached to values of your type (a fast parser, for example)
00:29:43 <mm_freak> bford: not online, sorry
00:29:45 <ezyang> I guess, at the end of the day, what I'm looking for here is a criterion for picking between MonadIO and MonadBaseControl
00:29:57 <mm_freak> ezyang: no, i mean, you're simplifying things
00:30:04 <ezyang> mm_freak: OK.
00:30:06 <mm_freak> most arrows are "almost monads"
00:30:28 <mm_freak> a good counterexample of that is the automaton arrow, which is far from being a monad
00:30:36 <mm_freak> (for the same reasons streams don't form a monad)
00:31:27 <mm_freak> but if you extend the automaton abstraction to allow what i call signal inhibition, then you've got the wire arrow, which can basically handle all of the IO exception machinery
00:31:52 <ezyang> So, is the claim here that IO-backed exceptions can still be useful for non-monads?
00:32:04 <mm_freak> yes
00:32:14 <mm_freak> useful and, more importantly, correct
00:32:54 <ezyang> Ugh, I want to finish this conversation, but I need to take a RL interrupt
00:32:58 <Sgeo> mm_freak, you're the one writing the Arrow tutorial?
00:33:50 <ezyang> mm_freak: In these cases, can the libraries handle exceptions which "cross" pure IO regions?
00:34:15 <mm_freak> ezyang: example?
00:34:22 <mm_freak> Sgeo: yes
00:34:41 <Sgeo> mm_freak, it never got past mentioning the Automaton arrow, iirc
00:35:01 <ezyang> mm_freak: I'm thinking of throwing an error, it exits liftIo, and you need to handle it before it exits the entire monad.
00:35:12 <ezyang> Not a good example because you won't have liftIO for arrows.
00:35:15 <mm_freak> Sgeo: i think i have extended it a bit, but it's still not finished
00:35:35 <mm_freak> ezyang: i call that arrIO
00:35:41 <ezyang> Ok, sure.
00:35:53 <Sgeo> mm_freak, did the URL change?
00:35:55 <mm_freak> or more generally arrM
00:36:13 <mm_freak> arrM :: ArrowKleisli m (>~) => m a >~ a
00:36:15 <Sgeo> Or is it not online?
00:36:39 <mm_freak> Sgeo: the URL is still the same
00:36:45 <Sgeo> s/mentioning automaton arrow/emphasizing local state/
00:37:05 <ezyang> (erm, question still stands)
00:37:19 <ezyang> mm_freak: OK, I have to run. Let's finish this conversation some time :-)
00:40:28 <mm_freak> ezyang: alright, have fun =)
00:40:56 <mm_freak> Sgeo: i think i have changed some parts of the tutorial and also added the section about composing automata
00:41:19 <mm_freak> no, the "arrow interface" section
00:46:24 <bford> mm_freak, ah that's a shame :-(
00:46:41 <mm_freak> bford: sorry for that…  the wiki page might give you an introduction
00:46:56 <mm_freak> it's incomplete, but should be sufficient to get started
00:47:08 <bford> mm_freak, BTW looking at the Control.Wire.Prefab.Queue i think fifo and lifo do the same thing?
00:47:51 <bford> yeah i've read that page and it gives me a bit of an overview - probably enough to get going :-)
00:50:07 <mm_freak> bford: no, they are different…  as their names suggest =)
00:50:22 <mm_freak> lifo is a stack, fifo is a pipe
00:53:18 <bford> I meant that the implementation is the same, as in it's the same code with a different name
00:58:38 <mm_freak> bford: look more closely
00:59:59 <bford> oh yes... *goes to get eyes tested*
01:00:34 <mcnster> could someone refresh my understanding of ghc lib versions... given v.x.y.z, is it a change in x that represents a change in pre-existing fn interface?  (i can't seem to find the canonical ref.)
01:00:49 <bford> BTW what does this part do: mkPure $ \((>< xs') . S.fromList -> xs)?
01:00:58 <bford> it's the -> xs that's confusing me
01:01:46 <Sgeo> bford, that's a lambda
01:01:49 <Sgeo> See the \ ?
01:02:05 <Sgeo> Wait, wait what.
01:02:31 <Sgeo> > \(a -> a+1) 5
01:02:32 <lambdabot>   <no location info>: Parse error in pattern
01:02:48 <quicksilver> it's a view pattern.
01:02:48 <lambdabot> quicksilver: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:03:01 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
01:03:02 <donri> @where PVP
01:03:02 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
01:04:00 <mcnster> donri, ty very much :)
01:04:31 <bford> yeah i saw that. it's the -> xs bit that i don't get. I should have pasted the whole line: mkPure $ \((>< xs') . S.fromList -> xs) -> <rest of function> xs is a list
01:04:36 <mm_freak> bford: the pattern (f -> y) for the value x pattern-matches f x against y
01:04:49 <Sgeo> quicksilver, that doesn't look like the thing that I saw somewhere reading Haskell 2010 stuff
01:04:51 <Sgeo> bford, I was wrong
01:04:58 <mm_freak> bford: you need the ViewPatterns extension for that
01:05:06 <quicksilver> Sgeo: it's only half a view pattern lambda
01:05:23 <quicksilver> Sgeo: the complete form must be \(a -> b) -> c
01:05:40 <Sgeo> quicksilver, but I saw something like | Just x <- whatever
01:05:41 <Sgeo> What is that?
01:05:42 <quicksilver> Sgeo: then the first -> is a view pattern -> and the second -> is the normal lambda ->
01:05:44 <Sgeo> Not a ViewPattern?
01:05:45 <bford> i'm reading now, thx for the link   :-)
01:05:55 <quicksilver> Sgeo: that's a pattern guard
01:06:00 <Sgeo> quicksilver, I understand that, but right now, "ViewPattern" ... oh
01:06:10 <quicksilver> I pasted the view patterns page
01:06:12 <Sgeo> Which one is in Haskell2010?
01:06:25 <srhb> Pattern guards are, I believe.
01:06:31 <Sgeo> :/
01:06:33 <srhb> Thankfully. :-)
01:06:40 <mm_freak> i'd be surprised to find ViewPatterns in h2010 ;)
01:06:41 <Sgeo> I think I like View Patterns better... wait, why thankfully?
01:06:51 <srhb> Because pattern guards are awesomesauce.
01:07:00 <srhb> And that's objective fact, clearly. :P
01:07:06 <quicksilver> I would cautiously describe mm_freak's use of a view pattern there as obfuscation
01:07:14 <quicksilver> but it is, obviously, a matter of perspective.
01:07:17 <mm_freak> view patterns are also awesome, when exploited fully (i.e. in a 'case')
01:07:22 <srhb> I have yet to decide if I like view patterns, I think they often make code very unreadable if you're not careful
01:07:41 <mm_freak> in my case it's really laziness on my part
01:07:45 <quicksilver> things are hard to read when you don't have practice reading them, and then they become easier to read.
01:07:45 <mm_freak> it's an abuse
01:08:05 <srhb> I just think maybe giving out obfuscation tools like that is a bad idea, but meh.
01:08:12 <quicksilver> maybe it is :)
01:08:14 <mm_freak> i'm used to reading view patterns, so it's not a problem for me, but view patterns in lambdas can be difficult to read, if you're not used to them
01:08:23 <quicksilver> GHC extensions the the playground for 'maybe bad ideas', srhb
01:08:25 <quicksilver> that's the point of them.
01:08:27 <bford> quicksilver, things are even harder to read if you've never heard of the concept :-)
01:08:46 <quicksilver> bford: true enough. I find it completely impossible to read postmodern philosophy written in urdu.
01:08:47 <srhb> Yes, I know, quicksilver. It's a very good idea like that. :)
01:08:54 <Sgeo> quicksilver, is FlexibleInstances a "maybe bad idea"? Is NoNPlusKPatterns a maybe bad idea?
01:09:10 <quicksilver> Sgeo: at one stage they were maybe bad.
01:09:17 <srhb> I was just giving my extended opinion on them as a potential Haskell20XY candidate feature, as I'm sure you all appreciate my opinion. O:-)
01:09:23 <quicksilver> then you use them for a while (a decade or so) and make up your mind about the maybe.
01:09:37 <quicksilver> FlexibleInstances, it turns out, was a very good idea.
01:10:03 <quicksilver> NoNPlusKPatterns isn't quite an 'extension' in the normal sense :)
01:10:03 <mm_freak> i'd like to see type families and scoped type variables become standard
01:10:18 <mm_freak> and furthermore scoped type variables to become the default
01:10:20 <quicksilver> scoped type variables definitely definitely.
01:10:31 <quicksilver> type families are still really quite new, although they look very promising so far.
01:10:40 <Sgeo> Type Families?
01:10:46 <Sgeo> I read about them once, and clear forgot
01:10:58 <mm_freak> Sgeo: set of allowed constructors based on the type variables
01:11:02 <srhb> Scoped type variables, is that what allows me to shadow names in let bindings?
01:11:04 <srhb> Hm, wait no.
01:11:12 <mm_freak> data family Map k a;  data instance Map Int a = ...
01:11:48 <Sgeo> srhb, it allows you to write out types in let or where when the thing it's inside of is polymorphic, I think
01:11:48 <mm_freak> srhb: no, it brings type variables from type signatures into scope for your definition
01:11:58 <quicksilver> srhb: it lets you refer to the variables in earlier type signatures
01:12:13 <quicksilver> which is vital if you want to annotate the type of certain things whose type includes a local type variable
01:12:14 <MostAwesomeDude> Hey, just double-checking I didn't miss anything: If I want a list of some type, but I want the list to be exactly n items long, is there any better option than an n-item tuple?
01:12:17 <srhb> Aha, that's interesting.
01:12:36 <srhb> MostAwesomeDude: "Probably not"
01:12:41 <opqdonut> MostAwesomeDude: if n is over three, I'd say go with lists
01:12:44 <srhb> MostAwesomeDude: Except maybe your own type
01:12:46 <opqdonut> MostAwesomeDude: maybe wrapped into a newtype
01:12:54 <MostAwesomeDude> n is, in this case, nearly always six.
01:13:01 <srhb> "nearly"?
01:13:10 <srhb> If you don't have an exactly in there, don't go with tuples.
01:13:18 <opqdonut> or, hey, Array
01:13:18 <mm_freak> MostAwesomeDude: HList may be an option
01:13:21 <MostAwesomeDude> There are special cases which might arise later and will probably be other types.
01:13:31 <mm_freak> MostAwesomeDude: yes, HList =)
01:14:07 <MostAwesomeDude> mm_freak: I was sold just from the package description. This seems like win.
01:14:14 <mm_freak> MostAwesomeDude: you may also define your own record type and use it through lenses…  that also makes them extensible
01:14:41 <quicksilver> HList is ... fairly heavyweight and has some very subtle optional features.
01:14:54 <MostAwesomeDude> mm_freak: I still don't understand lenses. Is there any documentation besides the API docs?
01:15:10 <quicksilver> and HList is just newtyped tuples at the end of the day.
01:15:11 <mm_freak> MostAwesomeDude: there are lots and lots of lens libraries on hackage
01:15:17 <bford> So if i understand correctly in the code i pasted in it's calling (>< xs') . S.fromList) on it's input (which is a List) and then binding the result of that to xs which is a Seq for us further  down in the case statement
01:15:30 <mm_freak> MostAwesomeDude: each of them taking a different approach
01:15:36 <MostAwesomeDude> mm_freak: None of them are blessed yet? :c
01:15:41 <mm_freak> no idea
01:15:52 <quicksilver> data-lens is blessed
01:16:12 <mm_freak> bford: yes
01:16:39 <mm_freak> bford: it's a shorter way to write:  \xs' -> let xs = f xs' in …
01:16:47 <mm_freak> where 'f' is that list-to-seq thing
01:17:05 <bford> so it's kind of a point free way of doing what you might have done in a case statement
01:17:07 <mm_freak> don't get excited by that…  i'm really abusing view patterns there =)
01:17:16 <mm_freak> sort of, yes
01:17:28 <mm_freak> not point-free, but with one less point
01:17:44 <quicksilver> fewer
01:17:47 <bford> it's neat -  if a little like postmodern urdu to the uninitiated :-)
01:18:05 <mm_freak> it's very neat when you do things like:  \(f -> (x, y))
01:18:18 <mm_freak> then it's not as bad as the abuse i'm doing in fifo/lifo
01:19:14 <mm_freak> there i'm just being lazy…  aka consistent =)
01:22:09 <mm_freak> bford: view patterns are great, when used in 'case':  case x of { (y, f -> Left z) -> …; (g -> Just y, h -> (z', z)) -> … }
01:22:20 <mm_freak> this saves you some nested 'case's
01:22:26 <Sgeo> quicksilver, "blessed"?
01:22:53 * frerich is really stunned how short a basic RPN solver is in Haskell. LYAH has some pretty nice example programs (not just JSON all over, as RWH...))!
01:22:55 <MostAwesomeDude> Sgeo: Recommended by the community at large.
01:23:44 <MostAwesomeDude> Or, at least, given one of two choices which have split the community into two large groups warring over the benefits and drawbacks of respective libraries.
01:24:15 <Sgeo> Hmm?
01:24:16 <MostAwesomeDude> It's kinda like how people use either emacs or vi, so at least you know that one of them is good.
01:24:35 <quicksilver> data-lens is recommend by me. And edwardk.
01:24:35 <donri> why isn't simon using the maybe monad here? http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
01:24:36 <lambdabot> donri: You have 1 new message. '/msg lambdabot @messages' to read it.
01:24:40 <quicksilver> I'm not sure if we count as large
01:25:00 <Sgeo> The data-lens package doesn't have Template Haskell stuff
01:25:18 <Sgeo> Incidentally, I need to use Template Haskell for my current project (or go insane, that's fine too)
01:25:28 <Sgeo> Not sure how simple or complex getting to terms with TH will be.
01:25:35 <donri> data-lens-template
01:26:13 <quicksilver> donri: you can't use the maybe monad inside a guard, basically
01:26:52 <MostAwesomeDude> Hm. So a lens is a tool for removing record-access boilerplate?
01:26:57 <quicksilver> donri: as to why SPJ doesn't discuss the maybe monad as another point in the design space? probably he was writing that for a non-haskell-centric audience, I guess.
01:26:57 <donri> quicksilver: oh, of course, but i mean the whole function could be simplified with a maybe monad no? i'm not arguing against pattern guards here, just curious if he's only avoiding it for sake of argument or because i'm missing something
01:27:09 <quicksilver> it would have been more complete to mention them.
01:27:27 <quicksilver> view patterns have a distinctly maybe monad feel about them, obviously
01:27:54 <donri> Sgeo: data-lens-template provides mkLens[es], it's just separate so the main package can be h98
01:28:34 <Sgeo> My only use-case for TH is writing a lot of lines of repetitive Haskell for me
01:28:52 <Sgeo> So is it likely that I'll be able to use splices inside [| |] to do what I need?
01:29:05 <donri> yes, and data-lens-template makes lenses out of your records for you
01:29:14 <Sgeo> donri, this is separate from data-lenses issues.
01:29:20 <Sgeo> *data-lens
01:29:21 <donri> ok
01:29:45 <quicksilver> writing lots of lines of repetitive haskell is exactly what TH is for, yes.
01:30:03 <donri> (when it can't be done in a better way ;))
01:30:06 <quicksilver> although occasionally special purpose tools may be quicker/more convenient, like Data.Derive
01:30:15 <quicksilver> (which mostly use TH anyway)
01:30:28 <mm_freak> MostAwesomeDude: lenses are for looking at part of a structure in isolation
01:30:37 <mm_freak> for example, individual record fields
01:31:06 <donri> in particular, lenses allow you to use composition for *setting* not just getting
01:31:35 <donri> often with candy for stuff like increment and in-place modification in monadstate
01:31:51 <donri> (data-lens-fd)
01:32:41 <quicksilver> donri: and they let you treat things which are not, really, records as if they were records.
01:32:45 <Sgeo> donri, what's the difference between that and what data-lens comes with in Data.Lens.Lazy?
01:33:03 <donri> Sgeo: -fd? monadstate
01:33:06 <quicksilver> for example, uniform treatment of "mutable variables in IO"
01:33:16 <Sgeo> donri, oh
01:33:43 <quicksilver> or lenses can be updatable views (in the database sense)
01:33:45 <donri> aka works in any state monad (i use it with acid-state)
01:34:38 <donri> also containers like maps with a maybe interface
01:34:54 <donri> where a lens focuses on a key in the map
01:39:00 <hpaste> dmwit pasted “is it safe?” at http://hpaste.org/56065
01:40:54 <quicksilver> dmwit: yes, I believe it is.
01:40:54 <dmwit> Does anyone know if I could (safely) use the commented-out code there?
01:40:58 <dmwit> sweet
01:41:03 <dmwit> Thanks. =)
01:41:18 <quicksilver> I remember SPJ pontificating about this once
01:41:29 <quicksilver> about whetehr the compiler could do this optimisation itself
01:41:45 <dmwit> oh
01:41:57 <quicksilver> the derived instances of Functor and Applicative are actually better than any you could write by hand
01:42:05 <quicksilver> for exactly this reason
01:42:17 <quicksilver> they unfold into core and effectively do what you wrote
01:42:24 <dmwit> That would be nice, though I think the reason for me to use unsafeCoerce is it's less (finger) typing/reading.
01:42:57 <quicksilver> well I think the discussion was about making "e -> e" work
01:43:11 <dmwit> aha
01:43:11 <quicksilver> which would be even less typing ;)
01:43:27 <quicksilver> but is currently not making sense
01:43:36 <dmwit> That would be amazing, though I guess without the hint given by unsafeCoerce it seems hard on the compiler.
01:44:27 <quicksilver> it seems to be inconsistent with the way we understand type inference
01:44:37 * dmwit nods
01:44:40 <quicksilver> I think somebody suggested "e {}" as a syntax
01:44:42 <hpaste> donri pasted “How I misunderstood PatternGuards” at http://hpaste.org/56066
01:44:43 <quicksilver> empty record update
01:44:50 <quicksilver> since record updates can change the type
01:44:55 <dmwit> hah, cute
01:44:58 <quicksilver> the empty record update could stand for "re-generalise type"
01:45:25 <quicksilver> but the compiler still has to keep track of cases and know that you've already written the only case with a 'dx' field
01:45:28 <quicksilver> so it still feels odd.
01:46:01 <donri> i guess i thought patternguards were more like monad comprehensions
01:47:40 <quicksilver> yeah, they are very like monad comprehensions
01:47:47 <quicksilver> but the monad is the 'null' monad
01:47:53 <quicksilver> so <- is a NOP-unwrapper
01:48:02 <quicksilver> but it still matches to the thing on the left of course
01:49:27 <hughfdjackson> NOP-unwrapper sounds like a slur
01:50:50 <srhb> What am I doing wrong here: concat . map (take n . repeat)
01:50:59 <srhb> I wanted to replicate each element in a list n times.
01:51:20 <donri> :t concat . map (take n . repeat)
01:51:21 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
01:51:21 <lambdabot>     In the first argument of `take', namely `n'
01:51:22 <lambdabot>     In the first argument of `(.)', namely `take n'
01:51:32 <donri> :t concat . map (take 5 . repeat)
01:51:33 <lambdabot> forall a. [a] -> [a]
01:51:52 <zenzike> srhb: have you tried concatMap (replicate n) ?
01:51:52 <aristid> > concat . map (take 5 $ repeat) $ [1,2,3]
01:51:53 <lambdabot>   Couldn't match expected type `[a]'
01:51:53 <lambdabot>         against inferred type `a1 -> [a1]'
01:52:03 <srhb> zenzike: Yes, I'm trying to do the more basic solution
01:52:13 <aristid> :t concat . map (take 5 $ repeat)
01:52:14 <lambdabot>     Couldn't match expected type `[a]'
01:52:14 <lambdabot>            against inferred type `a1 -> [a1]'
01:52:14 <lambdabot>     In the second argument of `($)', namely `repeat'
01:52:26 <asda8> can I somehow get the final SQL string from HDBC for debugging? I mean the one filled with parameters.
01:52:29 <aristid> :t concat . map (take 5 . repeat) $ [1,2,3]
01:52:30 <lambdabot> forall a. (Num a) => [a]
01:52:35 <aristid> > concat . map (take 5 . repeat) $ [1,2,3]
01:52:41 <lambdabot>   mueval: ExitFailure 1
01:52:41 <lambdabot>  mueval: Prelude.undefined
01:52:53 <ddarius> asda8: I doubt that ever exists.
01:54:12 <srhb> My mistake then.
01:54:34 <quicksilver> >  concat . map (take 5 . repeat) $ [1,2,3]
01:54:38 <lambdabot>   mueval-core: Time limit exceeded
01:54:44 <quicksilver> srhb: lambdabot is being weird.
01:54:47 <quicksilver> that works fine
01:54:52 <srhb> It does indeed.
01:54:52 <quicksilver> > concat . map (take 5 . repeat) $ [1,2,3]
01:54:53 <quicksilver> [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
01:54:54 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
01:55:12 <asda8> ddarius: ok, just getting a weird "invalid precision value" error and I have no idea which field it refers to.
02:07:22 <yitz> donri: yes pattern guards are very confusing. they are an abuse of the way "<-" is used elsewhere in Haskell.
02:07:25 <Sgeo> Can Haddock deal with Template Haskell? Is there stuff in TH for creating comments?
02:07:56 <srhb> yitz: Huh? Example?
02:07:58 <yitz> donri: and they add nothing. everything you can write with pattern guards, you can write directly with the Maybe monad, with very little increase in verbosity.
02:08:05 <yitz> donri: so i never use them.
02:08:41 <quicksilver> I don't think they are a big abuse
02:08:53 <tigger_> I'm using GHC 7.2.1, in the ghci prompt I type "import GHC" (http://www.haskell.org/haskellwiki/GHC/As_a_library), but it says it could not find that module. Any idea if I might need to use a devel version of haskell or something?
02:08:56 <quicksilver> they are very much like a monad comprehension in an identity monad
02:09:08 <quicksilver> with 'fail' programming to fall through to the next guard or case
02:09:57 <quicksilver> tigger_: did you use -package ghc ?
02:10:15 <yitz> srhb: in both do notation and list comprehensions, <- means bind the value from inside a monadic type to a variable, and scope it to the following elements of a suite of expressions. in pattern guards, it means bind the value itself to a variable, and scope it - i don't even remember how it scopes.
02:10:43 <quicksilver> yitz: it's the same scoping, and the monad is the identity.
02:10:48 <quicksilver> it's not really that inconsistent.
02:10:53 <tigger_> quicksilver: I'll give it a try, only tested if it would load in ghci or not
02:11:04 <quicksilver> tigger_: you need -package ghc whether you are using ghci or not
02:11:12 <quicksilver> tigger_: (it is mentioned on that page you pointed to)
02:11:38 <mm_freak> data-lens is amazing!  why didn't i look into it earlier?!
02:11:47 <mm_freak> now i almost feel stupid using acid-state without it
02:12:13 <srhb> mm_freak: Care to share what the awesome is about?
02:12:16 <yitz> quicksilver: i disagree. it is inconsistent. the monad is actually the Maybe monad, but the <- means something superficially similar but actually significantly different than its usual meaning.
02:12:18 <tigger_> quicksilver: sorry, this might be dumb,  run this at the command prompt "ghci -package"?
02:13:02 <yitz> quicksilver: i don't understand what you mean by "same scoping". where is the suite of expressions?
02:13:10 <mm_freak> srhb: it really makes easy what used to be so difficult so far…  accessing/changing record fields…  and the Category instance does what its stype suggests:  allows you to access fields of fields
02:13:10 <quicksilver> yitz: no, the monad is the identity monad I think. With a special 'fail' behaviour.
02:13:23 <mm_freak> srhb: also data-lens-fd comes fully equipped for acid-state
02:13:26 <quicksilver> yitz: what makes you think it is the maybe monad?
02:13:35 <srhb> mm_freak: OK, sounds like I'll really have to check it out.
02:13:41 <quicksilver> tigger_: "ghci -package ghc" yes
02:13:52 <Sgeo> Can you do the thing from :set?
02:13:59 <quicksilver> I don't know.
02:14:16 <Sgeo> Apparently yes
02:14:29 <tigger_> quicksilver: oh sweet, thanks a lot! appreciate the help.
02:14:59 <mm_freak> srhb: ((firstName . name) ^= "Max") x, where 'x' is a record with a 'name' field and that one is itself a record with a 'firstName' field…  that code takes a record 'x' and changes the firstName of the name
02:15:04 <mm_freak> it's amazing
02:15:20 <mm_freak> edwardk is truly the comaster =)
02:16:07 <yitz> ah there is a suite of guards, but separated by , and not surround by {}, and the equal clause is part of the suite. very weird.
02:16:10 <donri> quicksilver: yitz means in simon's examples, i think, where "lookup" returns a Maybe
02:16:38 <mm_freak> and i misread the fixity…  you can actually write (firstName . name ^= "Max") x
02:16:39 <quicksilver> donri: the automatic Maybe-unwrapping is nasty, yes
02:16:41 <yitz> quicksilver: well, if you write a <- Identity b, it won't do what you think, so it's not the Identity monad.
02:16:42 <donri> so intuitively you might expect the binding mechanism to be that of the maybe monad
02:16:44 <Sgeo> mm_freak, what's the difference between pervasive use of that sort of thing and a more imperative language?
02:16:57 <quicksilver> donri: that didn't make it into the standard one that got implemetned, did it?
02:17:06 <donri> duno
02:17:06 <yitz> quicksilver: i guess it's a some kind of virtual identity monad that doesn't exist anywhere else in Haskell.
02:17:06 <quicksilver> yitz: identity not Identity.
02:17:26 <mm_freak> Sgeo: in the imperative language it's a language feature…  in haskell you write this as a library, hence making this naturally more composable
02:17:27 <quicksilver> yitz: however the fail behaviour does make it feel a little Maybe-esque, certainly
02:17:31 <quicksilver> so I think I know what you mean.
02:17:51 <mm_freak> Sgeo: i don't know an imperative language, where record access is a library of combinators
02:18:03 <donri> do you think a more monad-like behavior as in my hpaste would be useful?
02:18:06 <yitz> quicksilver: it is queer in so many ways. and it's just not needed. what a waste of syntax bandwidth.
02:18:13 <donri> http://hpaste.org/56066
02:18:43 <yitz> quicksilver: sorry, this is my old bugaboo. donr got me started again. let me take a drink and calm down.
02:18:46 <yitz> donri
02:18:57 <donri> i suppose it's easy enough to simulate with monad comprehensions and plain guards
02:19:05 <ddarius> Update in imperative languages is rarely this immutable "update" behavior.  Lenses just capture some common patterns, they don't do anything magical.
02:19:42 <quicksilver> yitz: :)
02:20:01 <yitz> quicksilver: good thing someone tossed a beer a bit earlier
02:20:05 <quicksilver> ddarius: but the fact that they aren't magical is precisely their charm
02:20:20 <quicksilver> ddarius: unlike this terrible misguided "magical" new record syntax being proposed :-(
02:20:21 <mm_freak> Sgeo: example: because it is not tied to records in any way:  (mapLens 15 . fstLens) is the lens for the value at key '15' in the map in the fst of a tuple
02:20:30 <ddarius> Writing (_,s) ^= x = s x hardly changes the very nature of programming in Haskell.
02:20:46 <ddarius> quicksilver: Which one?  There's more than one I think.
02:21:22 <mcstar> hello guys!
02:21:27 <mcstar> can you comment on this code?
02:21:29 <mcstar> http://codepad.org/jwtEVBps
02:21:33 <mcstar> pls read comments
02:21:46 <quicksilver> ddarius: my :-( applies equally to all misguided new record syntaxes :)
02:21:59 <quicksilver> ddarius: there is a several-months-long thread on glasgow-haskell-users
02:22:11 <donri> mm_freak: and the great thing really is that it works for setting too. getting is easily composed already, without lenses.
02:23:03 <yitz> mcstar: the empty list permutes to an empty list? what is this trying to do?
02:23:29 <mm_freak> i was particularly amazed when finding the 'focus' function…  and reading the source code of data-lens i'd say intuitively that lenses are fast
02:23:51 <srhb> mm_freak: Re the stuff before, looks awesome
02:24:10 <mcstar> yitz: sorry?
02:25:04 <yitz> mcstar: sorry. a *singleton* permutes to the empty list?
02:25:14 <mcstar> it makes sense
02:25:29 <mcstar> what is the next lexicographic permutation of [5]?
02:25:30 <mcstar> []
02:25:34 <donri> mm_freak: i have a data-lens-ixset package at home, release worthy? do you use ixset?
02:25:34 <mcstar> there is none
02:25:36 <yitz> > permutations [1] -- mcstar
02:25:37 <lambdabot>   [[1]]
02:25:46 <donri> mm_freak: it's like 13 lines of code -.-
02:25:58 <mcstar> yitz: permutations give ALL the permutations
02:26:03 <mcstar> mine gives the NEXT
02:26:09 <yitz> mcstar: ah ok got it
02:26:21 <mcstar> [5]:[]==[[5]]
02:26:40 <mm_freak> donri: what's that?
02:26:46 <donri> mm_freak: ixset?
02:26:50 <mm_freak> yeah
02:26:56 <donri> mm_freak: i assumed you knew of it, using acid-state
02:27:01 <srhb> Suppesdly you can't live without it with acid-state
02:27:08 <srhb> (I haven't looked into it yet)
02:27:23 <donri> mm_freak: it's like a Map but with computed and multiple keys
02:27:36 <mm_freak> i see…  will look into it
02:27:41 <donri> aka an indexed set
02:27:49 <mm_freak> sounds interesting
02:27:54 <donri> it is quite nice
02:27:55 <yitz> mcstar: first of all, instead of "case process x xs of (False, _) -> []; (_, res) -> res" you probably want process to return a Maybe and then write maybe [] (process x xs)
02:28:15 <mm_freak> so you can have multiple indices, i.e. find elements through different types of keys in O(log n)?
02:28:30 <donri> you can have a large collection of records and quickly query by some arbitrary indices
02:29:06 <mm_freak> i mean, does it essentially do what an index does in an RDBMS?
02:29:21 <donri> likely; I'm no DB expert
02:29:37 <mcstar> yitz: im more interested in the algorithm
02:29:43 <yitz> mcstar: oh, sometimes you do use the snd of it. you could use Either a a, which is equivalent to (Bool, a), but you're not gaining all that much. ok.
02:30:08 <mm_freak> well, you have a (name, age, job) record type…  the database contains persons indexed by a numeric id, but you can create an index on 'name', thus accessing persons through their name in O(log n)
02:30:14 <mm_freak> while without index it would take O(n)
02:30:37 <mcstar> the tuple's first part indicated a success condition, and i do separate things if this is met or not, while backtracking on the list
02:30:43 <mcstar> indicates*
02:31:29 <mcstar> i have 2 different versions of the same algorithm, which is called SEPA btw, but i pasted this, cause it imho the nicest
02:31:40 <mcstar> and doesnt use superflous reverse operations
02:31:43 <donri> mm_freak: sure
02:31:56 <mm_freak> donri: indeed, great stuff!
02:31:59 <mcstar> anyway, guys, this is more like a challenge:
02:32:03 <mm_freak> thanks for that
02:32:06 <donri> mm_freak: plus set operations etc
02:32:10 <donri> bbl food
02:32:13 <mcstar> look up SEPA, and try to write an immutable version of it in haskell
02:32:17 <mcstar> that is easy to read and fast
02:32:33 <Blkt> good day everyone
02:32:54 <mcstar> next question, why is the "built-in" version so slow, and why is it not written in an immutable waay
02:46:38 <silver> btw, about SEPA http://youtu.be/jBd9c1gAqWs
02:49:01 <mcstar> whats that supposed to mean?
02:49:24 <silver> s/SEPA/REPA
03:00:00 <mcstar> i expected a bit more responses, the problem is interesting(imho), and id like to see a better implementation of it, than mine, which shouldnt be that hard since im into haskell for only a couple of days
03:00:33 <srhb> mcstar: I think you didn't really sell the challenge very well. :-)
03:01:44 <mcstar> srhb: what do you suggest?
03:02:04 <silver> mcstar, I'm reading about algorith right now, not much to comment, I absolutely out of context of this problem
03:02:54 <mcstar> ok, it takes time, i just hope i gained SOME attention
03:06:24 <srhb> mcstar: I didn't know the algorithm personally.
03:07:49 <mcstar> it originates from dijkstra i believe
03:10:07 <mcstar> yitz: do you think a data type like Either a a can be faster than a tuple?(i guess not)
03:11:56 <Sgeo> mcstar, Either a a doesn't do the same thing as a tuple
03:12:34 <Sgeo> Either a a will hold exactly one a.
03:12:36 <mcstar> thats why i said like
03:12:39 <mcstar> i know
03:12:42 <mcstar> Either a b
03:12:49 <mcstar> holds either type a or b
03:12:59 <tdammers> that will still only hold one value
03:13:04 <mcstar> yes
03:13:29 <mcstar> but should i make up a type, that hold 2 values(of diff type), or just stay with a tuple
03:13:56 <tdammers> I'd reason from a readability point of view
03:14:06 <yitz> mcstar: sorry i was on a call
03:14:15 <mcstar> np
03:14:26 <tdammers> Pair a b or (a, b)
03:15:18 <tdammers> matter of taste, mainly
03:15:19 <yitz> mcstar: there is a well-known algorithm for next permutation. are you implementing it, or perhaps re-inventing it, or do you think this is something different than the usual?
03:15:21 <mcstar> well, to be honest, the tuple doesnt look bad
03:15:47 <tdammers> no, but if you want to attach meaning to your syntax, the structured approach is better
03:16:14 <mcstar> yitz: can you point me to the well-known one?(this, that im using is behind c++'s next_permutation too)
03:16:33 <yitz> let's see if i can find it
03:17:04 <tdammers> also, maintenance can be easier if you have to add more fields later
03:17:59 <srhb> I think it's one and the same algorithm you're talking about.
03:18:08 <srhb> However, the implementation is a bit unreadable. At least to me.
03:18:18 <mcstar> i totally agree
03:18:26 <mcstar> thats why i came here for one
03:18:33 <srhb> Yeah.
03:18:38 <mcstar> id like to see some functional way of doing it right
03:19:00 <srhb> I'm afraid I'm too inexperienced to be of much help, but I'll be following the discussion. Please share your improvements along the way, if you pursue it.
03:19:39 <mcstar> i thought about making this topic my first blog post, if i get a nice solution XD
03:19:46 <srhb> :)
03:20:03 <srhb> Start now and include the improvements along the way!
03:23:47 <yitz> mcstar: ok it's in knuth 4:2. he attributes it to Narayana Pandita in 14th century India.
03:24:21 <yitz> mcstar: http://en.wikipedia.org/wiki/Permutation in the section "Generation in lexicographic order"
03:24:54 <yitz> mcstar: it appears that the stl implements that
03:25:12 <beefcube>  i'm reading xmonads source at the moment to learn: "keys conf@(XConfig {XMonad.modMask = modMask}) = M.fromList $ ...." i know that @ is an as-pattern, and XConfig is a parametized type, but is it missing its parameter because it doesn't need it in this case? and what is "{XMonad.modMask = modMask}" activity called? sorry, hard to find in the manuals i have
03:26:04 <tdammers> The missing parameters are simply ignored in the pattern matching
03:26:10 <tdammers> they're still there
03:26:23 <tdammers> and you can access them through the 'conf' name
03:26:56 <tdammers> I think 'record syntax' is the keyword you're looking for
03:28:34 <mcstar> yitz: i originally came across this alg. here http://www.freewebs.com/permute/soda_submit.html, so it seems it is something much older, im a bit confused, that guy presents it like it was his doing
03:29:04 <mm_freak> beefcube: where XConfig is the constructor of a record type and modMask is a field, the name 'modMask' becomes that field's value
03:29:31 <mm_freak> X { f = x } is a pattern binding the field 'f' to the variable 'x'
03:29:54 <mm_freak> you can use the same name (f = f), but then you shadow the field accessor function
03:30:22 <mm_freak> this is what your pattern does, although probably no shadowing is going on because the module XMonad may be imported qualified anyway
03:31:20 <yitz> mcstar: maybe you mean a different algorithm, where each step to the next premutation always just exchanges two adjacent element. that one is probably not nearly as old - the earliest reference to it seems to be from English bell ringers in the 17th century.
03:31:39 <beefcube> thx
03:31:46 <mcstar> no
03:32:07 <mcstar> yitz: mine, and the one on the page i linked in are the same as the one on wiki, that you showed
03:32:46 <donri> i wonder if data-lens is useful with xmonad configs )
03:32:46 <donri> ;)
03:32:52 <silver> mcstar, also, check out the http://okmij.org/ftp/Haskell/misc.html#perfect-shuffle I'm not sure it directly related but still
03:34:15 <mcstar> theoretically, this alg. runs in O(n) time
03:34:25 <mcstar> ofc in a mutable language
03:34:45 <mcstar> they say they could do the random one in O(nlogn)
03:36:18 <yitz> mcstar: google next permutation, you'll find thousands of people whe reinvented this wheel
03:37:34 <yitz> mcstar: it was fun re-inventing it for Data.List in haskell, where we had the additional constraint that it had to compile to the fastest possible code by GHC, plus some other constrainsts.
03:38:10 <yitz> mcstar: that was a long time ago. it can probably be improved. if you're thinking about those things, have a look. :)
03:38:51 <mcstar> yitz: are you saying that Data.List permutations function uses the same principle?
03:39:25 <yitz> mcstar: no, it lists all permutations, it's not a next_permutation function. so that's not the fastest.
03:40:06 <mcstar> ok, i was confused you said: "it was fun re-inventing it for Data.List"
03:40:43 <yitz> mcstar: yeah we re-invented something else similar :) it led us to that same knuth chapter. it's deeper than you might think.
03:41:20 <mcstar> are you referreing to the factoriodal number system or somesuch?
03:42:03 <yitz> mm no i don't remember seeing that. just saw it in the wikipedia article. i don't think that's knuth's approach.
03:42:27 <mcstar> i was just thinking what did you mean by "deeper"
03:43:02 <mcstar> anyway, what i didnt like in Data.List permutations, is that it cant handle identical elements
03:43:35 <mcstar> it treats every position in a list as a different element, even though they might be the same
03:44:02 <mcstar> and it is correct of course, if the elements cant be ordered, but id like to see another function in there, that CAN handle this case
03:45:11 <yitz> mcstar: ok
03:46:18 <erus`> the new haskell platform doesnt have data declarations in ghci :(
03:46:49 <quicksilver> well 7.4 hasn't even been released yet
03:46:53 <quicksilver> of course it isn't in the platform yet
03:48:36 <Sgeo> I suppose multiline entries in GHCi aren't going to become easier, are they?
03:49:57 <Sgeo> huh
03:50:25 <Sgeo> The GHC manual seemed to imply to me that I'd need to put {} around do blocks in GHCi even with :{ and :} etc
03:50:28 <Sgeo> I guess not?
04:01:14 <erus`> how can i test the bounds of a circular list?
04:02:22 <Jafet> mcstar: nub.permutations
04:02:47 <Jafet> erus: the same way you grab the corners of a circle?
04:04:43 <mcstar> Jafet: what is the complexity of nub?
04:04:49 <mcstar> O(n^2)?
04:05:15 <Jafet> The product of the number of inputs and the number of outputs.
04:05:25 <Jafet> The cool thing is that it requires only Eq!
04:05:31 <Jafet> Also, it's only three letters.
04:05:41 <mike-burns> The downside is the name.
04:06:15 <mcstar> i dont think that is acceptable
04:06:32 <mcstar> not the name :)
04:06:58 <Jafet> If the name is not diminutive enough, there's also "nubby"
04:08:00 <Sgeo> What's the complexity of sort?
04:08:06 <Jafet> Also, nub.permutations works on infinite lists
04:08:21 <Sgeo> :t permutations
04:08:22 <lambdabot> forall a. [a] -> [[a]]
04:08:50 <mcstar> haha
04:08:58 <mcstar> so useful
04:09:32 <mcstar> nub [1,1..]
04:09:42 <mcstar> how can i execute code?
04:09:45 <Sgeo> >
04:09:49 <mcstar> > nub [1,1..]
04:09:52 <lambdabot>   mueval-core: Time limit exceeded
04:09:57 <mcstar> :)
04:10:12 <Jafet> > take 4 <$> permutations [0..]
04:10:13 <lambdabot>   [[0,1,2,3],[1,0,2,3],[2,1,0,3],[1,2,0,3],[2,0,1,3],[0,2,1,3],[3,2,1,0],[2,3...
04:10:21 <Jafet> > take 3 <$> permutations [0..]
04:10:21 <lambdabot>   [[0,1,2],[1,0,2],[2,1,0],[1,2,0],[2,0,1],[0,2,1],[3,2,1],[2,3,1],[2,1,3],[3...
04:10:35 <Sgeo> On GHCi , nub [1,1..] gives me the first element and then I guess loops
04:10:49 <Sgeo> > (nub [1,1..]) !! 0
04:10:50 <lambdabot>   1
04:11:06 <mcstar> Jafet: thats tricky, it circuvents "permutations"
04:12:15 <mcstar> anyway, (nub.permutations) is not acceptable, since it changes the time complexity heavily
04:12:49 <mcstar> but thanks for the idea, probably it can be used for "experimentation"
04:12:50 <Jafet> Naturally. It's just reference code for you to test your fast code.
04:13:01 <sipa> > (nub . permutations) [1...]
04:13:02 <lambdabot>   A section must be enclosed in parentheses thus: (1 ...)Not in scope: `...'
04:13:12 <sipa> > (nub . permutations) [1..]
04:13:13 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:13:33 <Jafet> Oh crap, nub.permutations isn't lazy
04:13:49 <Sgeo> Jafet, hmm?
04:14:20 <Sgeo> > (!! 5) . (!! 3) $ (nub . permutations) [1..]
04:14:21 <lambdabot>   6
04:14:39 <Jafet> It is lazy precisely when nub is redundant
04:15:01 <Sgeo> > permutations [1,2,3]
04:15:01 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
04:15:06 <Sgeo> Oh, repeats
04:15:07 <Jafet> Or when the input is finite, but we're not interested in that trivial case
04:19:42 <srhb> Is there a convention about when to use "when" and when to use "let..in"?
04:19:57 <srhb> uh, I meant where.
04:20:19 <mcstar> let in is an expression and has a "return value"
04:20:30 <srhb> Yes.
04:20:41 <srhb> The in part is basically what comes before "where", no?
04:21:15 <mcstar> but you cant use them interchangeably
04:21:21 <merijn> srhb: The convention is "whichever is more readable"
04:21:22 <srhb> Hm no, I see that.
04:21:32 <merijn> Personally I almost always prefer "where"
04:21:49 <mcstar> i liek let/in for destructuring
04:21:51 <srhb> 2 * x where x = 4 is definitely not an integer.
04:22:10 <arw> what?
04:22:26 <srhb> Or is that just ghci being funky?
04:22:33 <merijn> srhb: It's (Num a) => a
04:22:35 <srhb> oh right, top level declarations.
04:22:46 <Sgeo> Is it sane to use let in for cases where in imperative languages, one might do something assign it to a variable and use that variable in the next and so in, in order to keep things readable?
04:23:03 <Sgeo> > 2 * x where x = 4 -- not an expression
04:23:04 <lambdabot>   <no location info>: parse error on input `where'
04:23:09 <erus`> Hey guys, does anyone use  https://github.com/Twinside/vim-haskellConceal ?
04:23:15 <Sgeo> > let x = 4 in 2 * x -- expression
04:23:15 <lambdabot>   8
04:23:23 <erus`> i need a font that supports all the unicode chars
04:23:31 <erus`> dejavu sans mono does not
04:23:35 <merijn> erus`: Pretty sure those don't exist
04:23:53 <arw> there is one... wait a sec.
04:24:00 <srhb> With ALL of them? Wow.
04:24:08 <Sgeo> Maybe erus` just means for Haskell programming?
04:24:13 <erus`> i mean all unicode chars used in that script
04:25:04 <merijn> Microsoft's webfonts generally have very decent unicode coverage and should be available on most OSes
04:25:30 <arw> erus`: http://users.teilar.gr/~g1951d/ <- that one supports a lot of the stuff thats usually missing from the standard fonts.
04:26:54 <arw> srhb: there isn't a complete font, but usually its possible to get almost complete coverage from a combination of 3 or 4 fonts
04:27:35 <srhb> arw: I'm surprised. Not that I think I'd ever need it.
04:27:43 <Jafet> Why doesn't the consortium try to provide a complete font
04:27:55 <Jafet> Silly committee people
04:28:26 <quicksilver> because most of them work for companies who make money licensing fonts? :)
04:28:33 <quicksilver> directly or indirectly
04:28:49 <Jafet> Do those companies provide complete fonts?
04:29:04 <asda8> I have the following issue with HDBC and SQL-Server: https://connect.microsoft.com/SQLServer/feedback/details/527188/paramater-datatype-lookup-returns-incorrectly
04:29:04 <merijn> SIL's free fonts have decent coverage too
04:29:16 <Jafet> Also, correct font renderers seem to be in short supply
04:29:20 <asda8> can I somehow force the type of bound parameters in HDBC to overcome this issue?
04:29:21 <merijn> I've out grown pirating software, nowadays I buy software and music but pirate fonts instead :p
04:29:50 <asda8> in perl you can do bind_param(1, 'bbbbbbbbbb', SQL_VARCHAR); to override detection in the buggy driver
04:30:43 <ezyang> What are combinators like withFile $ \f -> ... called? Scoped operators?
04:32:17 <quicksilver> I'm not aware they have a name, ezyang
04:32:28 <quicksilver> I call them "withFoo-style combinators"
04:32:43 <Sgeo> brackets?
04:32:44 <Jafet> ezyang: depends on the industry of the person you ask
04:32:59 <Sgeo> :t Control.Exception.bracket
04:33:00 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:33:06 <ezyang> In particular, I want to search about literature comibning these and continuations.
04:33:32 <asda8> any ideas? I'm really desperate.
04:33:43 <Jafet> Well, I'd start at okmij
04:33:57 <Jafet> I recall seeing something related there
04:34:26 <ski> ezyang : often they establish a dynamic extent
04:35:11 <ski> (so one might then call them "local extent operations")
04:35:32 <ezyang> oh I see, this one's from lispers.
04:36:16 * ski isn't sure how common it is in Common Lisp, but Scheme often does this kind of thing
04:36:48 <ezyang> OK, schemers :-)
04:37:00 <ezyang> Hmm, okmij doesn't appear to treat the subject
04:37:00 <Botje> ezyang: have you looked at the dynamic-wind built-in function of scheme?
04:37:15 <ezyang> Botje: looking now...
04:37:44 <ezyang> Huh, fascinating. I wonder if you can support this sort of thing with ContT.
04:38:41 <Botje> and there is a vague link to contextL as well
04:38:57 <Botje> where your with* functions can be seen as context layers
04:39:00 <quicksilver> some of the issues of resuming arbitrary monads are related as well
04:39:21 <ezyang> Hmm, so is "delimited dynamic binding" the paper I awnt.
04:39:24 <ski> <http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_600>
04:39:41 <aristid> ezyang: when somebody did a "preflex: seen" on you recently, i saw that you said something about talking to michael snoyman about conduits, and wanting to get an impression about them. what was the result of that? :)
04:40:13 <ezyang> aristid: Ah yes!
04:40:53 <ski> contrast the above `with-input-from-file' with `call-with-input-file', at <http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_588>
04:41:00 <ezyang> So, basically, I would interpret conduits as iteratees, but without inversion of control.
04:41:33 <ezyang> Lack of inversion of control is probably one of the key innovations of conduits, and most of the technical decisions follow from there.
04:41:48 <ezyang> "Or, 'uninnovation', if you may."
04:42:47 <ezyang> ski: Huh, why is call-with escape proof, but not with.
04:43:11 <aristid> ezyang: in iteratees, there are only sinks, and in conduits there are sources and sinks. is that what you mean?
04:44:01 <ezyang> aristid: I haven't thought about it that way, but that seems pretty reasonabl.
04:44:04 <Saizan> aren't Enumerators the sources?
04:44:16 <ezyang> Saizan: Only sort of.
04:44:20 <aristid> Saizan: enumerators are not first class
04:44:27 <ezyang> Actually, just a sec.
04:44:40 <quicksilver> "outrovation"
04:44:51 <aristid> type Enumerator = Something -> Iteratee Bla
04:44:55 <ezyang> http://blog.ezyang.com/2012/01/why-iteratees-are-hard-to-understand/
04:45:18 <ezyang> Basically, I'm pretty sure conduits are all about making iteratees look more like the imperative analogues they are inspired from.
04:46:21 <ezyang> Actually, the questions about continuations and with-functions are tenuously related to this discussion :-)
04:46:34 <aristid> ezyang: programming with iteratees doesn't feel very functional/denotative to me, either
04:46:45 <ezyang> aristid: Only if you use the combinators :-)
04:46:52 <mokus> my biggest problems with iteratees are the inversion of control and the fact that tutorials and libraries seem to make no attempt to offer any way to use them other than to hand-craft CPS code
04:47:00 <mokus> and of the two, the latter bothers me a lot more
04:47:14 <ezyang> mokus: Right, that's wrong, and Oleg would be very disappointed in the current crop of implementations.
04:47:25 <ezyang> The point about iteratees is that they should look like Lazy IO.
04:47:37 <mokus> I still have never seen a tutorial that didn't write most of its "example" code in hand-rolled CPS
04:47:39 <ezyang> But actually, you know, be resource efficient and deterministic :-)
04:47:47 <copumpkin> I also don't like his implementations of them, though
04:47:59 <copumpkin> or should I say, Hi
04:48:01 <ezyang> copumpkin: They're optimized for pedagogy.
04:48:01 <copumpkin> His
04:48:13 <mokus> yea, oleg's implementation had some semantic weirdness to them too, but IIRC he fixed it more or less
04:48:33 <aristid> hi copumpkin
04:48:50 <ski> ezyang : i'm not sure why the behaviour for `with-input-from-file' and `with-output-to-file' is implementation dependent when that of `call-with-input-file' and `call-with-output-file' isn't
04:48:52 <mokus> the biggest problem, though, is that it never progressed to a true abstraction
04:48:58 <copumpkin> ohai aristid
04:49:14 <ski> ezyang : you might find Riastradh's blag, at <http://mumble.net/~campbell/blag.txt>, posts "On control brackets and resource release" (with amendment "Correction to control brackets and resource release") might be interesting
04:49:16 <mokus> it was always more of a design pattern
04:49:16 <ezyang> ...while we're on the topic, can someone tell me what the "space-efficient, composable list transformers" thread is about?
04:49:21 <mokus> and in Haskell, we can do better than that ;)
04:49:22 <ezyang> ski: That sounds useful.
04:49:55 <aristid> ezyang: maybe Source is even a list transformer, kind of :D
04:49:56 <quicksilver> hmm Riastradh wrote the paren mode thing didn't he?
04:50:02 <quicksilver> smart chap.
04:50:25 <ezyang> aristid: "Ugh, why would I want nondeterminism in my lists"
04:50:40 <mcstar> mokuskerek
04:50:42 <Sgeo> ezyang, wait what?
04:50:46 <mike-burns> Oh Riastradh keeps sneaking into my life. Amusing.
04:50:52 <mike-burns> I taught him programming when he was 15.
04:51:00 <ski> quicksilver : *nod*
04:51:15 <ezyang> Sgeo: Is this re my nondeterminism comment? I'll reaffirm, and say you probably want the Logic monad instead :-)
04:51:29 <ezyang> Dammit, why are there two corrections.
04:52:43 <ski> (btw, if you dislike reading the blag in plain text, there's a (third-party) RSS feed at <http://home.ccil.org/~cowan/blag.xml>)
04:55:41 <ezyang> OK. So as far as I can tell the Scheme community decided a continuation jump was another way of exiting a block, and so you just add an extra handler for that case.
04:57:00 <ski> yeah, but if you want to implement concurrency using continuations, then you must use low-level continuations which doesn't trigger these dynamic extent boundaries
04:57:16 <ezyang> I can't help but conclude that IO exceptions are a grody (albeit elegant) hack piggybacking off of the existence of _|_ denotations in lazy pure code.
04:57:31 <erus`> Can i test for equality without deep evaluating something?
04:57:37 <ezyang> ski: Heh.
04:57:45 <ezyang> erus`: You can do a conservative test with stable names.
04:57:56 <ezyang> But this tests *sharing* not equality.
04:58:14 <neutrino__> hi
04:58:14 <quicksilver> ezyang: grody albeit elegant? Interesting pairing.
04:58:28 <ezyang> :-)
04:59:53 <neutrino__> cabal comes with haskell-platform right?
05:00:00 <ezyang> Actually, I guess it's worth asking: are these questions relevant in the treatment of MonadTransControl and ContT?
05:00:14 <erus`> neutrino__: ya
05:00:41 <neutrino__> i think i have installed hp in some weird way because cabal is not in my $PATH
05:00:52 <erus`> neutrino__: i lied
05:01:03 <neutrino__> i remember installing ghc from source
05:01:18 <neutrino__> erus`: what is it then?
05:01:23 * ski . o O ( `reallyUnsafePtrEquality# :: a -> a -> Int#' )
05:01:28 <tdammers> assuming debian or similar: if you install just ghc, then you don't have cabal
05:01:29 <erus`> no it is included
05:01:51 <neutrino__> tdammers: i do believe to have installed haskell platform
05:01:54 <ski> ezyang : which questions ?
05:02:10 <neutrino__> i have runhaskell in my $PATH... that doesn't come if you just install ghc, does it?
05:02:13 <tdammers> you can apt-get install cabal and see what happens...
05:02:17 <ezyang> ski: On continuations and lexical scoping
05:02:31 <tdammers> IIRC, ghc includes ghci and runghc
05:02:34 <tdammers> but not cabal
05:02:37 <ski> s/lexical scoping/dynamic extent/ ?
05:02:37 <neutrino__> i also have ghc-pkg installed
05:02:49 <quicksilver> tdammers: yes but he said he installed the platform.
05:02:54 <quicksilver> the platform does contain cabal-install
05:02:57 <ezyang> Erm, yes.
05:03:03 <neutrino__> quicksilver: it was a long time ago and i'm not 100% sure i have.
05:03:13 <quicksilver> which is the package which contains the tool 'cabal'
05:03:21 <quicksilver> neutrino__: ghc-pkg list can confirm.
05:03:59 <quicksilver> does the output contain "cabal-install-x.y.z.w"
05:04:17 <neutrino__> http://pastebin.com/E05iaUw5
05:04:19 <quicksilver> or hmm, do executable only packages show up in that list?
05:04:19 <mauke> The paste E05iaUw5 has been copied to http://hpaste.org/56068
05:04:34 <neutrino__> it does not, it does however contain Cabal-xxx
05:04:38 <quicksilver> you haven't got the platform
05:04:42 <neutrino__> ok
05:04:45 <neutrino__> let me get the platform then
05:04:48 <quicksilver> Cabal-x.y.z comes with GHC
05:04:54 <quicksilver> it is not the tool 'cabal'
05:04:59 <quicksilver> which is in a package called cabal-install
05:05:08 <neutrino__> yeah i thought so
05:05:43 <neutrino__> if my ghc is 7.0.3 then the right hp is 2011.2.0.1 right?
05:05:59 <aristid> is felipe lessa sometimes in irc?
05:08:04 <ski> ezyang : hm, i haven't looked at `MonadTransControl' before
05:09:03 <ezyang> It's kind of interesting. "Note there is no instance for ContT"
05:11:47 * Sgeo decides to write m' functions (for marshaling) right in the .hsc file
05:17:08 <ezyang> Wow, reading the haskell-cafe archives is very enlightening. Everything I'm looking at seems to have been talked about.
05:18:23 <ezyang> And I'm even more amused because it seems all this work seems to be rediscovering what the Scheme community figured out ages ago.
05:19:13 <Saizan> some say that's the main drawback
05:19:39 <ezyang> Saizan: that --> ?
05:19:55 <Saizan> "doing this like scheme"
05:20:02 <ezyang> Oh, I agree
05:20:35 <ezyang> And in "Monad-control rant" Mikhail describes why the monad-control approach won't work for well-designed continuation-based monads.
05:20:53 <ezyang> It is, as we say, "too general"
05:21:21 <ski> any link handy ?
05:21:35 <ezyang> I think the Haskell community can make more progress than Scheme could have, because we have the ability to lock things down, but I don't think better typeclasses for these things have been well studied, except the obvious ones.
05:21:43 <ezyang> just a moment
05:21:55 <ezyang> http://www.haskell.org/pipermail/haskell-cafe/2011-November/096786.html
05:22:49 <aristid> ezyang: things are currently moving fairly quickly in the haskell world, i think.
05:23:12 <aristid> the community is still figuring out the basics
05:23:20 <ezyang> aristid: Yeah, it's kind of cool that all of these conversations only happened in the last year.
05:24:49 <ezyang> OK, I think I should write a survey blog post on this, since I knew nothing about this issue until I blogged about it.
05:24:57 <ezyang> *researched
05:32:06 <ski> ezyang : i think one potential problem is that in Scheme world, you have to pick a way to let the effects interact, but in Haskell, we can play more with different ways of stacking and combining effects
05:32:16 <bgamari> Does anyone know of any substitutes for Text.Printf?
05:32:27 <bgamari> Particularly of one that plays better with monad transformers
05:32:31 <bgamari> http://chplib.wordpress.com/2009/11/06/text-printf-and-monad-transformers/
05:32:37 <bgamari> All I've found is xformat
05:32:47 <bgamari> but it seems quite old and perhaps a tad awkward
05:36:17 <donri> bgamari: what do you need from it
05:36:26 <bgamari> I really just need a more pleasant way than printf to format floats
05:36:45 <Botje> you can printf to a String, no?
05:36:51 <bgamari> there's showgfloat, but it doesn't interact nicely with Text.PrettyPrint
05:36:52 <donri> hm, was going to suggest interpolatedstring-perl6 but don't think it does float formatting in itself
05:37:09 <bgamari> and isnt particularly general
05:38:53 <bgamari> Botje: Fair enough
05:39:08 <bgamari> liftIO $ putStr $ printf ...
05:39:18 <bgamari> It's just a bit unfortunate
05:39:45 <mm_freak> printf itself is unfortunate, but it's handy
05:39:50 <Botje> and you can't do liftIO $ printf "..." ?
05:40:57 <bgamari> Botje: Nope, http://chplib.wordpress.com/2009/11/06/text-printf-and-monad-transformers/
05:41:03 <bgamari> mm_freak: It's true
05:41:17 <mm_freak> liftIO (printf … :: IO ())
05:41:26 <bgamari> yet somehow no one has developed a replacement
05:41:38 <bgamari> mm_freak: Yes, that would be another way to work around the issue
05:41:40 <mcstar> apropo print: what do you guys suggest to someone coming from an imperative world, needing prints to debug?
05:41:48 <bgamari> but you can't contain that in a wrapper
05:41:52 <Sgeo> mcstar, Debug.Trace
05:41:53 <donri> so put the workaround in a function :)
05:41:53 <bgamari> mcstar: Debug.trace?
05:41:54 <mm_freak> well, you can also define printfIO
05:42:00 <mm_freak> hmm, no
05:42:02 <quicksilver> bgamari: it's a one-line function to do that for you
05:42:02 <mm_freak> you can't
05:42:07 <Sgeo> @hoogle Debug.Trace
05:42:08 <lambdabot> Debug.Trace module Debug.Trace
05:42:08 <lambdabot> Debug.Trace trace :: String -> a -> a
05:42:08 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
05:42:11 <quicksilver> hmm
05:42:12 <ezyang> mm_freak: 'lo!
05:42:13 <quicksilver> or, not entirely.
05:42:17 <mm_freak> ezyang: 'lo!
05:42:19 <quicksilver> bah at stupid overloading tricks.
05:42:27 <bgamari> Yep, exactly
05:42:32 <mcstar> thx, ill look into Debug
05:42:35 <donri> mcstar: trace "hi" x == x but also prints "hi"
05:42:37 <quicksilver> you could define a monomorphic liftIO though
05:42:49 <bgamari> quicksilver: This is true
05:42:51 <ezyang> mm_freak: Let's pick up the discussion.
05:43:04 <quicksilver> l :: MonadIO m :: IO () => m (); l = liftIO
05:43:07 <mm_freak> ezyang: sure, although i don't know what to add to it
05:43:16 <quicksilver> then l $ printf ...... blah ....
05:43:19 <bgamari> quicksilver: Sure
05:43:31 <quicksilver> still, printf sucks
05:43:42 <quicksilver> write something based on showGFloat which does what you want.
05:43:55 <ezyang> mm_freak: So, since you left, I realized that there was another context in which MonadTransControl was insufficiently *general* (as opposed to too specific), which was in the case of well-designed continuation based monads.
05:44:06 <mm_freak> i wouldn't say printf sucks…  it's just unfortunate
05:44:42 <ezyang> mm_freak: I guess I'd also like to try to summarize the discussion, to make sure I understood your points
05:44:45 <mm_freak> ezyang: i think this all boils down to defining MonadFix for CPS monads
05:44:48 <mm_freak> and that's difficult
05:45:01 <mm_freak> there are solutions, but they are all ugly
05:45:26 <mm_freak> i think i saw a solution using an IORef
05:45:30 <ezyang> mm_freak: I don't think so?
05:45:52 <ezyang> At least, it's not clear if such a solution will exist for all CPS monads
05:47:12 <mm_freak> probably you can express any single-continuation monad based on ContT
05:47:39 <ezyang> Wait, but I thought we couldn't do MonadFix for ContT
05:48:40 <mm_freak> that's not proven
05:49:21 <ezyang> Sure. But that's an open problem.
05:49:22 * hackagebot websockets-snap 0.5.0.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.5.0.0 (JasperVanDerJeugt)
05:50:15 <Sgeo> Why does hackagebot ACTION?
05:51:16 <quicksilver> it's a hipster
05:51:26 <quicksilver> msgs are so 20th century
05:51:39 <quicksilver> all the cool bots it hangs around with ACTION things
05:54:17 <aristid> damn, where did AWS move the secret keys in the UI? can't find them anymore
05:54:32 <aristid> oh, maybe i should have asked in another channel
05:59:59 <srhb> Can I make ghci give me source code definitions of basic functions like drop and take? It tells me the module GHC.List is not interpreted, so I guess I need to make it run from a non-compiled version, but how?
06:01:28 <neutrino__> check out the source from git
06:01:34 <quicksilver> srhb: no.
06:01:51 <quicksilver> srhb: have a copy of the the haddock docs with full source handy instead
06:02:41 <srhb> I need lambdabot to live in my ghci! :(
06:03:14 <quicksilver> srhb: lambdabot's @src is rubbish anyway
06:03:25 <quicksilver> srhb: the haddock source is much more useful
06:03:29 <srhb> I suppose.. But such a convenience.
06:03:33 <quicksilver> preflex: seen bos
06:03:34 <preflex>  bos was last seen on #haskell 32 days, 19 hours, 44 minutes and 2 seconds ago, saying: KirinDave: it's in a horrible state of sin, to be more accurate.
06:04:14 <Yrogirg> if (,) :: a -> b -> (a, b) then what is the name for a -> b -> c -> (a, b, c) ?
06:04:25 <copumpkin> (,,)
06:04:42 <erus`> > (,,) 1 2 3
06:04:43 <lambdabot>   (1,2,3)
06:04:49 <erus`> :O
06:05:29 <erus`> @src (,,)
06:05:29 <lambdabot> Source not found. I am sorry.
06:05:36 <Yrogirg> hm, is there a way to cast (,,) in terms of (,) ?
06:06:01 <quicksilver> no
06:06:06 <copumpkin> no, they're unrelated types
06:06:13 <quicksilver> each tuple constructor is independent and formally unrelated to the others
06:06:22 <quicksilver> this is a design decision that some people have disagreed with :)
06:07:43 <srhb> So there are just a bunch of magically neverending (,,,,,,....) constructors?
06:08:08 <Saizan> they end at 64 or so, in GHC at least
06:08:17 <mm_freak> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:08:17 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
06:08:18 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
06:08:18 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 ->
06:08:18 <lambdabot> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 ->
06:08:18 <lambdabot> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 ->
06:08:19 <lambdabot> [5 @more lines]
06:08:28 <srhb> They don't seem to. :-)
06:09:09 <arw> somebody had fun generating that stuff...
06:11:05 <lukish> > let x = (1,2) :: (Int,Int); uncurry (/) x
06:11:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:11:31 <quicksilver> Saizan: I think it's just the Typeable and Data instances which end.
06:11:36 <quicksilver> Saizan: the actual types go on forever.
06:11:38 <lukish> Well, question is how can I apply uncurry (/) to (Int,Int)
06:11:47 <quicksilver> s/types/families/
06:12:01 <quicksilver> lukish: (/) isn't an operator on Ints. Would you like `div` ?
06:12:49 <Saizan> there's a GHC.Exts.maxTupleSize == 62
06:13:03 <Saizan> something should end at 62
06:13:16 <lukish> quicksilver: I wanna have list of fractions from list of (Int,Int)
06:13:29 <Saizan> the instances end far sooner
06:13:36 <quicksilver> fractions in what type?
06:13:43 <quicksilver> you could have rational fractions perhaps
06:13:57 <quicksilver> > let x = (1,2) in uncurry (%) x
06:13:57 <lambdabot>   1 % 2
06:14:13 <quicksilver> alternatively,
06:14:22 <parcs`> "A 102-tuple is too large for GHC (max size is 62)"
06:14:31 <snhmib> lukish: fromIntegral?
06:14:39 <quicksilver> > let x = (1,2) in uncurry (/) . (fromIntegral *** fromIntegral) $ x
06:14:40 <lambdabot>   0.5
06:14:45 <parcs`> this is why tuples should be structured like lisp lists :P
06:14:55 <Saizan> parcs`: how did you trigger that?
06:15:11 <snhmib> o_O what's ***
06:15:22 <MaskRay> Control.Arrow
06:15:23 <lambdabot> MaskRay: You have 1 new message. '/msg lambdabot @messages' to read it.
06:15:24 <koeien> snhmib: it's from Control.Arrow
06:15:56 <koeien> > ((+1) *** (*2)) (3,4)
06:15:56 <lambdabot>   (4,8)
06:16:12 <parcs`> Saizan: with ghci + lots of copy/paste
06:16:22 <parcs`> ((),(),...)
06:16:24 <snhmib> ah ok
06:16:38 * snhmib always ignored all that arrow stuff
06:16:48 <lukish> quicksilver: what is (%)
06:16:52 <lukish> :t (%)
06:16:53 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:16:55 <koeien> Data.Ratio
06:16:59 <lukish> Okay
06:17:03 <quicksilver> snhmib: just a way of applying a function to a component of a tuple
06:17:12 <quicksilver> lukish: rational numbers, which is one meaning of 'fraction'
06:17:16 <quicksilver> lukish: didn't really know what you wanted
06:17:21 <ezyang> mm_freak: In your experience, do you ever write libraries where you start off being able to do everything in MonadIO, but then at some point you suddenly find that one place where actually you need a real bracket function?
06:17:35 <lukish> I need fractions with order
06:17:47 <mm_freak> ezyang: that hasn't happened to me yet
06:17:55 <koeien> > (2%3) < (4%7)
06:17:55 <lambdabot>   False
06:18:00 <Saizan> parcs`: ah, fun, you get the error only with ((),(),...) rather than (,,,,...) () () ...
06:18:06 <koeien> lukish: they use the natural ordering.
06:18:12 <mm_freak> ezyang: either the abstraction i implement can deal with exceptions or i use MonadBaseControl right away
06:18:15 <ezyang> mm_freak: Interesting. It happened to me this afternoon, but I was probably just asking for trouble.
06:18:24 <ezyang> mm_freak: Oh, OK, that makes sense.
06:18:28 <parcs`> what is the point of a max tuple size?
06:18:30 <koeien> > a%b < c%d iff a*d < b*c
06:18:31 <lambdabot>   Not in scope: `iff'Precedence parsing error
06:18:31 <lambdabot>      cannot mix `GHC.Classes.<'...
06:18:53 <lukish> Well, yes, Data.Ratio is what I really want, thnx
06:19:12 <parcs`> maybe it has to do with pointer tagging or something
06:19:20 <parcs`> can you construct a record with > 62 fields?
06:19:59 <ezyang> Ugh. I wish I could straight-forwardly just recommend MonadBaseControl, but as you remark, your abstraction doesn't have to be a monad, and MonadBaseControl may not even be powerful enough.
06:20:02 <koeien> parcs`: yes, i just tested
06:20:35 <neutrino__> hello
06:20:55 <neutrino__> i have succeeded in installing haskell-platform and cabal works, but ghc-pkg list does now show "cabal"
06:20:59 <parcs`> koeien: yep, same here
06:21:11 <neutrino__> what's going on?
06:21:32 <Botje> it probably installed it in ~/bin
06:21:44 <mm_freak> ezyang: usually it's /too/ powerful
06:21:46 <neutrino__> no i installed it where it wanted to install, with sudo
06:21:46 <Botje> oh, wait, ghc-pkg
06:21:48 <Botje> nevermind :)
06:22:00 <mm_freak> ezyang: just like sometimes Monad is too powerful (that's when you need arrows)
06:22:08 <mm_freak> more powerful = less generic
06:22:48 <ezyang> mm_freak: I'm getting my words mixed up
06:23:22 <ezyang> It is, indeed, too powerful for certain types of CPS-based monads as well
06:23:32 <ezyang> I wonder if there is an intermediate step here.
06:24:10 <mm_freak> you can make your abstraction exception-aware, like iteratees
06:24:14 <ezyang> just like Applicatives
06:24:28 <mm_freak> under the hood you will be doing the liftIO trick
06:24:32 <ezyang> mm_freak: OK, so here is an avenue I want to explore a little
06:24:46 <mm_freak> that's essentially what MonadBaseControl is about, but it does the trick on a very general level
06:25:00 <mm_freak> and from that you can derive all the usual exception-handling functions
06:25:06 <ezyang> I don't think you can make your abstraction fully exception aware, for example, in the case of asynchronous exceptions
06:25:44 <mm_freak> depends on the abstraction
06:25:58 <ezyang> You can "manage" it in the liftIO sections, but not in the non-liftIO sections
06:26:14 <ezyang> mm_freak: for what abstractions would you be able to?
06:26:23 <ezyang> (and not be able to define MonadBaseIO)
06:26:24 <mm_freak> you can let your computations run with exceptions blocked
06:26:35 <ezyang> Oh, sure.
06:26:38 * ezyang wrinkles face 
06:26:53 <mm_freak> of course it's not as simple as that
06:27:04 <mm_freak> you will want to keep the blocking sections as short as possible
06:27:44 <ezyang> AFAICT, I can't trivially re-enter my non-IO context from inside a mask, without MonadBaseControl
06:28:02 <ezyang> Maybe we shoudl have had a /setMask/ function :^)
06:28:15 <mm_freak> well, i'm assuming an abstraction that involves IO
06:28:41 <neutrino__> does anyone in here have experience using cmdlib? i am wondering if there's a simple howto using it (i couldn't locate any)
06:29:05 <ezyang> erm, sure, it may involve IO, but you might be in 'm' where IO is buried under several layers of monad transformers.
06:29:52 <mm_freak> ezyang: the trick is to let the user choose that 'm'…  this gives you a much clearer structure for your own library
06:30:22 <mm_freak> in general when you write a control abstraction, you write it as a monad, an arrow, an applicative functor or something like that
06:30:30 <mm_freak> and that one receives an argument 'm'
06:32:06 <mm_freak> ezyang: in fact your data type definition should tell you how to handle exceptions
06:32:55 <ezyang> Wait, I thought we were talking about async exceptions
06:33:08 <mm_freak> we are
06:34:13 <ezyang> So you claim: mask :: m a -> m a, does not presume m to be a monad.
06:34:22 <mm_freak> my point is:  avoid this:  newtype MyMonad r m a = MyMonad (ContT r (StateT MyState (ReaderT MyConfig m)) a)
06:35:10 <mm_freak> then the type itself tells you where and how to handle exceptions, including async ones
06:35:15 <ezyang> I don't see how this can work in a control model whose order of execution is much more relaxed then monads.
06:35:28 <mm_freak> like what?
06:35:51 <ezyang> mm_freak: sorry, I'm having trouble approaching this from a non operational "how to implement" perspective
06:36:37 <mm_freak> ezyang: have you ever developed an own control abstraction?
06:36:42 <ezyang> mm_freak: Wouldn't arrows and applicatives fit the bill?
06:36:51 <mm_freak> no
06:36:56 <ezyang> mm_freak: I must confess, all of mine were very monad-y
06:37:08 <mm_freak> well, sort of
06:37:27 <mm_freak> one key difference between arrows and monads is the absense of opaque functions in arrows
06:37:31 <mm_freak> (>>=) is a killer
06:37:38 <mm_freak> because of its second argument
06:37:50 <mm_freak> absence*
06:38:04 <Sgeo> TH can represent things that aren't syntactically valid Haskell?
06:38:11 <Sgeo> InfixE (Maybe Exp) Exp (Maybe Exp)
06:38:21 <mm_freak> so in some sense yes, you are introducing data dependencies in monads, which can lead to ordered execution
06:38:44 <ezyang> OK, maybe applicatives are a bad example
06:38:52 <ezyang> How about commutative applicative functors?
06:39:01 <Sgeo> LetE also seems to allow for instance declarations
06:39:02 <Sgeo> Why?
06:39:12 <ezyang> (though no one has managed to find a good API for this, IIRC)
06:39:17 <Sgeo> Are instance declarations and the like allowed in lets, or is TH overly flexible?
06:39:31 <mm_freak> ezyang: try to give a concrete example
06:40:13 <mm_freak> Sgeo: can't speak for TH, but no, instance definitions are only allowed in the top level
06:41:30 <quicksilver> local declarations would be very handy
06:41:47 <quicksilver> instance declarations should not be any more local than the types they reference though.
06:42:19 <mm_freak> well, you could pass dictionaries around manually
06:42:24 <ezyang> mm_freak: Unfortunately, I don't have any on hand.
06:43:05 <mm_freak> ezyang: you know, we are talking very abstractly…  often the mist clears when you have a concrete example at hand
06:44:02 <nexion> which library is best for parsing HTTP requests and decoding the request strings?
06:44:05 <mm_freak> ezyang: you can practise by implementing an effectful stream functor
06:44:10 <ezyang> OK, imagine I have a test harness for concurrent programs, which can control how things are interleaved.
06:44:11 <mm_freak> it's an applicative functor
06:44:11 <Saizan> newtype MyMonad r m a = MyMonad (ContT r (StateT MyState (ReaderT MyConfig m)) a) <- what should you avoid here in particular? the newtype? the ContT ?
06:44:27 <mm_freak> Saizan: the stack
06:44:52 <mm_freak> ezyang: newtype Stream m a = Stream (m (a, Stream m a))
06:44:52 <Saizan> so avoid monad transformers?
06:44:55 <ezyang> To a first approximation, I have a bunch of values representing program states, and an interpreter which randomly picks one and steps it.
06:45:27 <mm_freak> Saizan: no, but when writing an abstraction, which might involve IO, avoid using complicated monad transformer stacks
06:45:47 <ezyang> Now, suppose that inside my embedded program language, I want to handle asynchronous exceptions fromt he host language./
06:46:11 <ezyang> But when one of the embedded programs enters a masked section, the scheduler may then decide to work on a different thread.
06:46:59 <ezyang> There is some nontrivial interaction here, which needs explicit semantics and some extra code on the interpreter's side.
06:47:06 <Sgeo> Prelude Language.Haskell.TH> pprint (InfixE Nothing (LitE (IntegerL 1)) Nothing)
06:47:06 <Sgeo> "*** Exception: Attempt to pretty-print non-variable or constructor in infix context!
06:47:08 <statusfailed> Is there a sorted container like Data.Map?
06:47:19 <koeien> Data.Set
06:47:19 <quicksilver> Data.Map is sorted by key
06:47:25 <quicksilver> what sorting did you want, statusfailed ?
06:48:06 <statusfailed> quicksilver: sorted by value, but I guess I would just have two maps
06:48:21 <quicksilver> yes, or a map and a set of values
06:48:31 <quicksilver> Data.Set is conceptually a map where the value is always the key
06:48:38 <quicksilver> although that's not how it's stored on disk
06:49:08 <koeien> there's also the bimap package on hackage, but it might do too much for your purposes
06:49:35 <ezyang> mm_freak: But it's certainly not something that can be fully achieved by calling IO mask in the implementation of mask in the embedded language
06:49:39 <danols_work> does haskell support natively unicode ?
06:49:52 <koeien> yes
06:50:02 <koeien> you can use unicode in your Haskell source files, as well
06:50:12 <statusfailed> koeien: that looks good too, i'll take a look
06:50:21 <danols_work> so this error would never happen ? http://dpaste.com/681445/
06:50:41 <danols_work> because somehow the urllib got unicode as user entered it but it doesn't know how to handle it
06:50:46 <koeien> > let 牛 = 3 in 牛
06:50:47 <lambdabot>   3
06:50:51 <ezyang> mm_freak: Is that concrete enough, or do we need some code? :-)
06:52:10 <yitz> danols_work: "how the user entered it" is an entirey different matter. how does the unicode string the user entered get into your program?
06:52:22 * yitz looks at danols_work's paste
06:52:54 <danols_work> sorry the more I learn python the more I realize I made a mistake choosing it
06:53:04 <merijn> danols_work: You're paste shows python and python supports unicode just as much as haskell
06:53:19 <merijn> danols_work: Unicode support doesn't save you from having to learn and understand encodings
06:53:49 <danols_work> k
06:53:50 <yitz> danols_work: ah a 0xfc
06:54:01 <merijn> danols_work: This is a fairly comprehensive (and the minimum required knowledge!) overview of unicode: http://www.joelonsoftware.com/articles/Unicode.html
06:54:36 <Clint> python "supports" unicode
06:55:03 <danols_work> i know python supports unicode
06:55:09 <merijn> Clint: Why the quotes? Python supports unicode as much as haskell or any other language with unicode
06:55:21 <danols_work> but I have to do something like : "string".encode('utf8'))
06:55:23 <koeien> python3 is better than python2
06:55:26 <danols_work> which feel wrong
06:55:33 <Clint> merijn: because it makes you jump through hoops in an ass-backwards fashion
06:55:44 <koeien> yes, strings are different from bytearrays
06:55:50 <merijn> danols_work: Why? You need to know what to encode strings to if you want to output them
06:56:00 <merijn> Clint: Things are much better in python3
06:56:03 <yitz> i don't think django supports python 3 yet though
06:56:08 <danols_work> no it dosen't
06:56:12 <Clint> merijn: glad to hear it
06:56:12 <koeien> yitz: most of the work has been done afaik
06:56:17 <quicksilver> Clint: if you jump through hoops assbackwards you're less likely to fall flat on your face! :)
06:56:30 <mux> so, can you actually change the default encoding in python3? this is a major annoyance in python2
06:57:25 <merijn> mux: Not sure, but in python3 the default is utf8 rather than ascii, so that's much better regardless
06:57:43 <Clint> whew
06:59:16 <yitz> danols_work: the haskell web frameworks are heavily biased towards utf-8. so if that's what you want, it ought to work smoothly for you. if you need to support some other encoding, i'm not sure what you'll need to do/
06:59:35 <danols_work> utf-8 is world wide safe though yes?
06:59:48 <yitz> what do you mean by safe?
06:59:49 <koeien> not completely afaik
06:59:56 <ezyang> Yeah, you can basically uniformally assume it will work
07:00:10 <koeien> there are some  extremely rarely used CJK characters not in unicode, but generally it's quite OK to use
07:00:14 <merijn> ezyang: Quit telling people things that causes them to write brittle software :(
07:00:14 <ezyang> Wikipedia held out for a while due to incomplete support, but they've switched, and that's good enough for me.
07:00:23 <yitz> danols_work: if you are publishing web pages and you decide to use utf-8 for everything, that should work fine.
07:00:50 <ezyang> Wait, I think UTF-8 everywhere is a fine assumption.
07:00:51 <yitz> danols_work: if you are parsing web pages published by others, you may run into other encodings for far east languages.
07:00:56 <ezyang> (re merijn)
07:01:37 <yitz> and also other languages occasionally, but not very often outside the far east
07:02:25 <splitter> Hello, I'm wondering, is it possible with haskell to have "enumerated types", e.g. I want to define a type Vector which might be a vector of arbitrary size, but at compile-time it would get expanded to something like Vector1, Vector2, ... such that attempting to `innerproduct` a Vector2 and a Vector3 would be a compile-time error?
07:02:38 <danols_work> it's just in haskell do I need to do something like 'test'.encode('utf-8'))
07:02:53 <neutrino__> splitter: you're looking for types dependent on values
07:02:56 <koeien> splitter: if you know the size at compile-time, you can use template haskell
07:03:03 <neutrino__> splitter: i believe this may be possible using th
07:03:32 <quicksilver> or you can just use data Two; data Three; data Vector a; innerproduct :: Vector a -> Vector a -> Double
07:03:44 <opqdonut> splitter: you can also use phantom types for that, like this: "data Vector size = Vector [Int]; data One = One; data Two = Two; ..."
07:03:45 <splitter> koeien: yeah, the size would be known at compile-time in the sense of me, say, instantiating a vector with 3 elements.
07:03:49 <opqdonut> oh, quicksilver said it already :/
07:03:56 <yitz> danols_work: in any language you may need to do that sometimes. it depends what you have and what you want.
07:04:29 <koeien> danols_work: strings are really different from arrays of bytes. this holds in every language
07:04:34 <merijn> ezyang: I think UTF-8 everywhere should be mandatory, but telling people to "just use utf-8" without (for example) reading the unicode overview I linked earlier is the kind of thing that got us in this বববব mess to begin with >.>
07:04:36 <danols_work> k
07:05:02 * merijn hopes he got the box glyphs right
07:05:05 <koeien> danols_work: an array of bytes can be a representation of a string. the same string can be represented in multiple ways, for example using UTF-8 or UTF-16LE
07:05:14 <yitz> merijn: they displayed as boxes for me
07:05:36 <splitter> quicksilver: hm, I wonder if that's flexible enough.. I'd like to also be able to -- for instance -- say that VectorN `outerproduct` VectorN will result in a MatrixNxN -- where I can have any n-vector and the type system would automatically know about the corresponding result type
07:05:43 <merijn> koeien: If you ever find yourself having to explain unicode, just google "joel unicode" and link this: http://www.joelonsoftware.com/articles/Unicode.html
07:05:55 <merijn> koeien: That essay is a time saver :>
07:05:55 <koeien> merijn: yeah that's a good resource
07:06:05 <splitter> What I basically would like to achieve is type-safety for vectors and such in the sense that bogus dimensions get catched at compile-time
07:06:11 <quicksilver> splitter: well I only sketched the very beginnings of an answer.
07:06:18 <quicksilver> splitter: the answer is yes, that that is possible
07:06:19 <ezyang> merijn: This is the sort of thing that types are good for.
07:06:20 <yitz> merijn: i think utf-8 for european languages is fine. it may or may not be fine for people who live in the far east and process cjk languages all day long. i think you should find out how many of those people agree with you.
07:06:28 <splitter> quicksilver: allright, I'll look into it, thanks.
07:06:29 <quicksilver> but you can't do *everything* you might imagine without quite a lot of work
07:06:37 <quicksilver> you can do a fair amount
07:06:47 <quicksilver> IIRC the vector-space library on hackage does some of this.
07:06:49 <merijn> ezyang: Agreed
07:06:52 <splitter> Well, I had a quick look at TH, and it looked a bit painful
07:07:04 <koeien> splitter: yeah it's overkill if you have only two sizes (2 and 3)
07:07:06 <splitter> quicksilver: I'll have a look at that as well, thanks
07:07:19 <splitter> koeien: I'd want it to work for arbitrary sizes.
07:08:18 <merijn> yitz: It is an easy encoding, supports all of unicode, is backwards compatible with ASCII and has no byte-ordering issues. A small amount of overhead for CJK languages (and the overhead is likely nowhere near as high as some people claim) is a small price
07:08:43 <merijn> yitz: At current bandwidth, RAM and harddisks the handful of extra bytes won't push anyone over the edge
07:08:49 <koeien> especially for HTML it's fine
07:09:21 <yitz> merijn: that sounds fine. but last i heard there were a lot of people in cjk countries who just aren't that interested in utf-8 and prefer not to use it, for various reasons.
07:09:41 <yitz> merijn: i'm not one of those people, but i'm not prepared to make decisions for them
07:10:07 <yitz> merijn: unlike google, who is trying to evangelize universal utf-8 because they have an interest in it.
07:11:10 <ezyang> Well, I think the problem there is the Han unification.
07:12:26 <aristid> yitz: don't you have an interest in utf-8 too, if using it for everything simplifies your life? :)
07:13:15 <yitz> aristid: i think the balance of internet users is quickly tilting towards the far east, so it's silly not to take their preferences into account
07:13:30 <ion> A small overhead for plaintext will surely overflow our storage capacity.
07:13:31 <koeien> besides that there are billions of speakers of those languages
07:13:55 <aristid> yitz: sadly they are underrepresented on IRC and mailing lists
07:14:38 <yitz> aristid: i believe the old assumption that english is the lingua franca of the web is dated.
07:14:46 <Saizan> you're seeing it the wrong way around, we can't forego this last chance for imposing a bit of cultural imperialism
07:14:51 <aristid> yitz: i don't.
07:15:06 <m4dc0d3r> Hello everyone, my name is m4dc0d3r.
07:15:09 <aristid> yitz: at least for those people who don't want to only address a local audience.
07:15:17 <koeien> m4dc0d3r: hi, how can we help?
07:15:28 <m4dc0d3r> I used to write ruby, but then i took haskell to the irc.
07:15:28 <GorDonFreeMan> hi
07:15:31 <GorDonFreeMan> i invited him
07:15:35 <m4dc0d3r> now im here.
07:15:40 <aristid> yitz: there is no asian alternative to english as a lingua france, right now.
07:15:42 <merijn> This sounds like an imperative coder anonymous introduction :>
07:15:55 <yitz> aristid: i don't feel i understand trends among far east users. i way less of them than their actual proportion in the population, so i have a feeling that things work very differently in that part of cyberspace.
07:16:05 <m4dc0d3r> merijn: im not gonna forget that
07:16:05 <yitz> i *see* way less of them
07:16:11 <merijn> Hello everyone, my name is merijn, and I'm an imperative programmer.
07:16:11 <m4dc0d3r> or forgive you
07:16:23 <m4dc0d3r> Hi merijn
07:16:32 <m4dc0d3r> im gonna eat ur brainz
07:16:33 <koeien> aristid: yeah the sinosphere is huge
07:16:37 <GorDonFreeMan> ;>>
07:16:42 <yitz> merijn: twelve step program?
07:16:44 * m4dc0d3r nom nom
07:17:06 <aristid> yitz: i don't think there's a whole lot i know, but i think it's unlikely that, say, chinese could become a lingua franca of the asian web
07:17:13 <koeien> seems very unlikely
07:17:37 <koeien> but what do i know :)
07:18:07 <yitz> aristid: don't know. but i don't think we can glibly say "utf-8 should be universal" without input from people who are part of that world.
07:18:54 <MostAwesomeDude> yitz: Sure we can! it's just not likely that people in certain parts of the world will want to migrate.
07:18:54 <aristid> yitz: it depends on what you want to accomplish. if you want to make life easy for yourself, you probably can say it.
07:19:09 <yitz> aristid: i have a feeling that it is the linua franca of the chinese world, not english, and that there is not all that much overlap
07:19:30 <MostAwesomeDude> Also, I don't think there is just a single part of the world that is not wanting to move to UTF-8; there are *still* web frameworks that assume Latin-1.
07:19:38 <yitz> MostAwesomeDude: we can say it. we also can be left in the dust later on. maybe.
07:20:01 <MostAwesomeDude> yitz: Well, why would UTF-8 be left in the dust? What will supersede it?
07:20:13 <yitz> MostAwesomeDude: yeah i'm definitely willing to join the fight against latin1 :)
07:20:45 <Jafet> Latin-1? There are still people who only know shit-JIS.
07:20:59 <Jafet> freudian typo
07:21:27 <MostAwesomeDude> Big5 is still very common.
07:21:52 <Clint> also KOI8-R and Latin-9
07:22:43 <MostAwesomeDude> Isn't the Latin-5 codepage still popular in Israel? (Or was it Latin-4? Can't remember.)
07:22:48 <quicksilver> MostAwesomeDude: potentially, another 'universal' character scheme which avoids some of the problems people have with unicode - http://en.wikipedia.org/wiki/Han_unification )
07:23:08 <yitz> MostAwesomeDude: 8. and no, it's almost totally gone now. utf-8 rules.
07:23:38 <mux> the only problem I have with unicode is the stupid planes they added in unicode 6.0 with smiley faces, kittens, and what not
07:24:04 <MostAwesomeDude> Oh, and of course we can't forget the ubiquitous codepage 1252, which is still everywhere that Windows XP is. :c
07:24:10 <yitz> mux: i like the babylonian cuneiform
07:24:48 <mux> I'm ok with babylonian cuneiform, or even runes from Tolkien, but poutty kitten face? seriously?
07:24:56 <yitz> hehe
07:25:40 <quicksilver> mux: that's because mobile phone OS companies want to be able to use unicode for text messages
07:25:41 <MostAwesomeDude> mux: Well, Unicode's mission is to cover *all* of the glyphs.
07:26:00 <mux> how is GRINNING CAT FACE WITH SMILING EYES a glyph?
07:26:03 <quicksilver> and those pictures are required for text messages in more than half the mobile-phone-using-world
07:26:10 <MostAwesomeDude> You can always avoid the astral planes, if you want. Most of Unicode isn't up there.
07:26:18 <mux> quicksilver: I understand the reason, but I still find it stupid :-P
07:26:51 <yitz> mux: what do you mean, that glyph has been around for over 100 years, since Lewis Carroll
07:27:12 <mux> hah, oh well
07:27:15 <quicksilver> mux: it is arbitrary. I'm not sure if that's the same thing as stupid.
07:27:32 <quicksilver> standards do arbitrary things in an attempt to standardise common practice.
07:27:43 <quicksilver> common practice may appear bizarre, since it is practiced by human beings.
07:28:24 <neutrino__> the c64 glyph set is not covered by unicode
07:28:48 <neutrino__> very popular, used in countless computer programs, easy to implement
07:29:02 <yitz> neutrino__: inform the unicode consortium
07:29:53 <neutrino__> yitz: how?
07:30:31 <neutrino__> hmm.
07:30:50 <neutrino__> there's a lot of contact info on unicode.org alright
07:30:58 <byorgey> neutrino__: shine a giant U+2603-shaped light on the underside of the clouds above your house
07:31:00 <neutrino__> maybe too much? :o
07:31:26 <yitz> neutrino__: i think if they hear that there's a widely used character set that they still don't cover, they'll be in shock
07:31:47 <mux> hahaha
07:31:50 <MostAwesomeDude> Maybe it's not that widely used theses days? :3
07:32:04 <neutrino__> what do you mean
07:32:10 <neutrino__> there are modern implementations of BASIC
07:32:22 <yitz> MostAwesomeDude: neither is babylonian cuneiform or egyptian hieroglyphics
07:32:23 <neutrino__> you can run all those programs on those implementations
07:32:39 <MostAwesomeDude> yitz: Good point. I guess they can all go in the astral planes, then.
07:32:54 <MostAwesomeDude> Or maybe you could find one of the reserved bubbles, if there are any left.
07:33:06 <MostAwesomeDude> Anyway, if you seriously care about it, better contact them.
07:33:09 * byorgey writes all his private notes in babylonian cuneiform
07:33:18 <mux> byorgey: classy
07:33:20 <neutrino__> astral planes?
07:33:51 <byorgey> all those clay tablets take up a lot of space though
07:34:06 <yitz> byorgey: but your data will still be intact 4000 years from now
07:34:20 <byorgey> right, it's a tradeoff
07:34:41 <MostAwesomeDude> neutrino__: The Unicode planes which require more than 32 bits to store a single codepoint. There's a story there, but I can't remember it.
07:34:46 * mux tries very hard to keep a serious face while at work, and is utterly failing right now
07:35:29 <mux> the astral planes are also the final levels in the nethack game, but I doubt that this is relevant
07:36:24 <Saizan> those levels are all made of those glyphs
07:37:19 <Renze> Hello
07:37:45 <byorgey> hi Renze
07:38:14 <aristid> byorgey: do you have haskell tools for reading and writing notes (on clay tablets)?
07:39:01 <byorgey> aristid: yes, for writing I have a Haskell program which controls a Lego Mindstorms robot holding a stylus
07:39:14 <byorgey> I haven't yet figured out how to read babylonian cuneiform though
07:39:21 <yrlnry> Remember cuneiform tablets are only permananent once they are baked.
07:39:44 <yrlnry> Until then, you can pound them up in a tub of water and turn them back into clay.
07:39:48 <neutrino__> excluding sopernova
07:39:48 <byorgey> the robot is also holding a blowtorch.
07:39:52 <yitz> byorgey: the latest phonograph turntables use laser scanning instead of needles. perhaps you could adapt one of those.
07:40:08 <byorgey> yitz: ah, good idea.
07:40:12 <srhb> When I've installed the Haskell Platform, shouldn't I be able to just import System.Random in ghci?
07:40:19 <neutrino__> yitz: never seen one of those, got a link?
07:40:44 <byorgey> srhb: yes.  are you getting some sort of error?
07:40:45 <yrlnry> neutrino__:  they don't have Google on your planet yet?
07:41:01 <srhb> byorgey: Could not find module `System.Random'
07:41:04 <yrlnry> https://www.google.com/search?q=laser+turntable
07:41:07 <yitz> neutrino__: hah i've never seen one either. but i found out about those on wikipedia when my brothers and i were working on digitizing my dad's record collection.
07:41:29 <yrlnry> http://www.elpj.com/ is the #1 hit, "Plays records without a needle"
07:41:46 <mekeor> can i do "data Foo = Bar { id :: Int }" despite there's already the id-function?
07:42:11 <byorgey> mekeor: yes, but if you try to use id later, you will get an error about it being ambiguous
07:42:14 <neutrino__> yrlnry: do i know you?
07:42:23 <byorgey> mekeor: to prevent this, you can put  import Prelude hiding (id) at the top of your module
07:42:26 <koeien> yes, but if you use it you have to qualify it
07:42:49 <koeien> or hide the Prelude.id as per byorgey's comment
07:43:04 <byorgey> srhb: what is the output of 'ghc-pkg list random' ?
07:43:12 <MostAwesomeDude> mekeor: Often people will qualify their record accessors with something like fooId or fId instead.
07:43:30 <MostAwesomeDude> Or I guess it'd be barId or bId in this case.
07:43:35 <yitz> mekeor: that doesn't sound like a very good idea to me. do what MostAwesomeDude says.
07:43:58 <mekeor> byorgey, MostAwesomeDude, yitz: thank you very much! =)
07:44:06 <srhb> byorgey: Paths.. With a wrong version of GHC. I think I know what's going on, thank you. Useful command.
07:44:27 <yrlnry> neutrino__:  How should I know?  I have revealed my identity but you have kept yours a secret.
07:45:25 <neutrino__> i'm obviously being picked on by a lunatic
07:45:50 <neutrino__> yitz: anyways, i think i'll stay with ballistics based approaches ;)
07:46:23 <dgpratt> yrlnry: he's a sentient elementary particle; how many of those can there be?
07:46:42 <yrlnry> I dunno, I don't usually notice what neutrinos are doing.
07:46:49 <neutrino__> don't get him wound up, we hadn't got the straight jacket on yet
07:48:03 <Sgeo> Thought: If I have a thread that loops, and checks an MVar (IO ()) or something, and if it sees it filled, switches to the IO () instead of looping, is that similar to Erlang's hotswapping?
07:48:44 <merijn> Sgeo: Not really, because you lose any state the old loop had
07:48:52 <neutrino__> unless you pass it?
07:49:07 <srhb> If I have a "function" that gives me a single value.. Can I then make another "function" from this that gives me an infinite list of random values?
07:49:08 <merijn> neutrino__: That means you need to know in advance which state the loop has
07:49:18 <srhb> single random value on the first one, too.
07:49:20 <neutrino__> merijn: why do you?
07:49:23 <merijn> Making it completely different from Erlang's hotswapping which does not need to know in advance
07:49:39 <neutrino__> merijn: explain.
07:49:40 <merijn> neutrino__: How can you pass state on if you don't know what it is?
07:49:41 <koeien> neutrino__: because you need to pass the state, it has to have a type.
07:49:48 <yitz> Sgeo: you could implement erlang hotswapping in any language if you work hard enough. the point is that in erlang it's there by default by design, without any effort.
07:50:00 <koeien> neutrino__: e.g. MVar ((Integer,Integer) -> IO ())
07:50:01 <MostAwesomeDude> srhb: Are you asking how to create a random number generator?
07:50:07 <srhb> MostAwesomeDude: No.
07:50:11 <ski> ezyang : re `MonadFix' and `Cont', see "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-slides.pdf>)
07:50:12 <neutrino__> koeien: i realize that, but why is that bad?
07:50:24 <koeien> neutrino__: that's not "bad", it's just different from erlang
07:50:29 <neutrino__> obviously there's no way to hotswap an application with incompatible data structures
07:50:30 <merijn> neutrino__: We're not saying that's bad, we're saying it is fundamentally different from Erlang's hotswapping
07:50:42 <neutrino__> i don't know what erlang does, but i don't think it does that
07:50:57 <koeien> neutrino__: erlang is dynamically typed
07:50:58 <neutrino__> after all how would it know how to compare and convert the incompatible types unless you told it to
07:51:03 <neutrino__> that's fine
07:51:05 <KorriX> I have finished my HanoiVizualizer - http://hpaste.org/56073 and i want to ask - how to make "sleep" inside of monad at 61 linine - ?
07:51:09 <merijn> neutrino__: Erlang's hot code updateslet you replace existing processes/object with new implementations at runtime
07:51:09 <neutrino__> it still needs to work on the data
07:51:19 <neutrino__> and if you pass wrong data it's still going to grind the duck into pate
07:51:33 <koeien> KorriX: threadDelay
07:51:38 <neutrino__> whether you call that a crash or duck typing is your personal favorite
07:51:39 <KorriX> doesnt work
07:51:40 <koeien> KorriX: notices, this takes *micro*seconds afair
07:51:44 <Renze> return !$ Just ... doesn't help, right?
07:52:06 <koeien> Renze: that just unpacks the Just again, you need seq x (return (Just x))
07:52:15 <koeien> s/unpacks/forces
07:52:23 <neutrino__> merijn: what happens if the new implementation works on a different data structure?
07:52:35 <neutrino__> let's say my old program was a loop that always printed a string
07:52:52 <neutrino__> the new version of the program is a loop that prints all strings in a list
07:52:56 <neutrino__> what happens?
07:53:24 <merijn> neutrino__: I dunno the exact details, as I don't do much Erlang
07:53:42 <koeien> KorriX: where did you add this function?
07:53:43 <neutrino__> well that's the only kind of situation the type would change
07:53:54 <neutrino__> so argumenting that you "need to know the type in advance" is sort of futile
07:54:00 <merijn> neutrino__: You're ignoring the possibility of internal state
07:54:12 <merijn> neutrino__: The IO () can have arbitrary internal state that needs migrating
07:54:13 <neutrino__> because you do anyways, otherwise your new version is incompatible to the old
07:54:18 <neutrino__> merijn: what is internal state?
07:54:49 <KorriX> koeien: works, thanks :)
07:55:22 <Renze> koeien: thanks, it also doesn't work on tuples right? And tuple 'seq' ... also doesn't do anything, right?
07:55:32 <yitz> KorriX: did you need seq, or was it just the microseconds issue?
07:55:39 <merijn> neutrino__: Open files, variables, everything used to implement your code? I don't really know how to give a fundamental definition of internal state, it seems rather obvious...
07:55:49 <koeien> yitz: seq on threadDelay won't do anything, no?
07:56:00 <srhb>  rnd = randomRIO (1,100) :: IO Int
07:56:01 <KorriX> microseconds issue :)
07:56:11 <srhb> Now if I wanted to generate a list of these random ints, how would I go about that?
07:56:12 <koeien> Renze: well, seq just evaluates to weak head normal form
07:56:17 <yitz> koeien: i guess not :)
07:56:43 <koeien> :t sequence (replicate 100 (randomRIO (1,100))
07:56:44 <lambdabot> parse error (possibly incorrect indentation)
07:56:47 <koeien> :t sequence (replicate 100 (randomRIO (1,100)))
07:56:47 <lambdabot> forall t. (Num t, Random t) => IO [t]
07:56:59 <srhb> Thanks!
07:57:09 <koeien> Renze: so seq'ing (expensive, expensive) won't do anything
07:57:19 <neutrino__> merijn: ok that is what you meant
07:57:23 <ezyang> ski: Thanks! That's cracking.
07:57:29 <Sgeo> What does Erlang do for internal state?
07:57:38 <neutrino__> merijn: you would probably have to do it by hand. i can see how erlang's runtime is an improvement over that
07:57:40 <Sgeo> I was under the impression that it was essentially recursion
07:57:59 <Renze> koeien: yes I know, just wanted to be sure tuples are already WHNF
07:58:10 <neutrino__> @hoogle executeR
07:58:10 <lambdabot> No results found
07:58:14 <koeien> > seq (undefined, undefined) ()
07:58:15 <lambdabot>   ()
07:58:17 <neutrino__> @type executeR
07:58:18 <lambdabot> Not in scope: `executeR'
07:58:23 <neutrino__> hmm, how do i find this function?
07:58:33 <koeien> hayoo?
07:58:39 <neutrino__> thanks
07:58:46 <dolio> koeien: It does something. Just not something expensive.
07:59:15 <KorriX> does you have any ideas about how to make line 66 by "haskell way" ?
07:59:27 <koeien> dolio: i can't observe the difference, so for practical purposes it's the same :)
07:59:28 <merijn> neutrino__: In python you can redefine a class, but existing instantiations won't be updated. Erlang's hot code update replaces the class (and all instantiations) in one go
07:59:38 <KorriX> *64
07:59:51 <merijn> neutrino__: The main goal is to allow you to patch your code without shutting down
07:59:59 <srhb> Is there an infinite replicate?
08:00:09 <dolio> repeat
08:00:10 <koeien> srhb: repeat
08:00:14 <srhb> Thanks again.
08:00:37 <koeien> srhb: if you can figure out the type of a function, you can also use hoogle
08:00:39 <koeien> e.g. in this case,
08:00:42 <koeien> @hoogle a -> [a]
08:00:42 <lambdabot> Prelude repeat :: a -> [a]
08:00:42 <lambdabot> Data.List repeat :: a -> [a]
08:00:42 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
08:00:51 <srhb> Excellent, I'll do that. :)
08:02:51 <Varakh> how do i access vars of data types in record syntax? i got something like data Test  = State {exInt :: Int} if i try to write a show instance it doesnt like my show State s@(v) = show v.
08:03:52 <quicksilver> show (State v) = show v
08:04:00 <quicksilver> that's not record syntax, of course, but it's fine.
08:04:26 <ezyang> ski: very clever application of mutable state to solve a problem thought to be impossible. "But what does it mean???"
08:05:01 <Varakh> quicksilver: no. State is not called v, v is the value of exInt
08:05:13 <quicksilver> Varakh: that is correct, yes.
08:05:15 <Varakh> and i want to "extract" this value
08:05:21 <quicksilver> Varakh: v is the value of exInt, in my code.
08:05:29 <quicksilver> is that not what you intended?
08:05:30 <yitz> @pl \f t u v w x y x -> f (f (f t u v) w x) y z
08:05:31 <lambdabot> ((((const .) .) .) .) . flip flip z . ((flip . ((flip . ((flip . ((flip . (flip .) . flip) .)) .)) .)) .) . ap ((.) . (.) . (.) . (.) . (.)) ((.) =<< (.) . (.))
08:05:43 <yitz> hmm. i guess that's not really the "haskell way".
08:05:45 <^^thief^^> is there any way to separate pattern matches across files?
08:05:53 <quicksilver> it's a terrible show instance but that's not really the point.
08:06:17 <Varakh> data Test  = State {ex1 :: Int,ex2 :: Int} so how do i access value of ex2 ?
08:06:31 <Varakh> show (State _ v2) = show 2 ?
08:06:34 <Varakh> v2
08:06:34 <quicksilver> show (State a b) = show a ++ show b
08:06:45 <koeien> Varakh: if s :: State, then  ex2 s :: Int
08:06:48 <yrlnry> yitz:  That's the Unlambda Way
08:06:50 <koeien> or, (State a b)
08:06:51 <quicksilver> alternatively you can use the record syntax if you like.
08:07:04 <^^thief^^> when should i be using class/instance over pattern matching?
08:07:06 <quicksilver> show (State{ex1 = a, ex2 = b}) = show a ++ show b
08:07:11 <quicksilver> or you can use the selectors
08:07:18 <quicksilver> show s = show (ex1 s) ++ show (ex2 s)
08:07:29 <koeien> ^^thief^^: ADTs are always "closed". you cannot add more cases later
08:07:48 <koeien> ^^thief^^: classes are not closed, you can always add more instances later in calling code and so on
08:08:24 <augur> koeien: welcome to generic programming.
08:08:26 <koeien> so use ADTs if you know that your enumeration is complete, e.g. Maybe, and a class if you don't have an enumeration of all instances, e.g. Eq
08:08:41 <^^thief^^> koeien: so if i have a collection of 20 or so commands, each of which are executable - is this a good case for an Executable class with an instance for each type of command?
08:08:42 <dolio> You should use classes when you want to overload a function.
08:08:54 <^^thief^^> yes thats what im trying to do
08:08:59 <^^thief^^> or maybe not
08:09:01 <^^thief^^> hmm
08:09:22 <yitz> KorriX: i think i would write that line the same way you did, but perhaps split it onto multiple lines and line things up with indentation to make it more clear.
08:10:01 <yitz> @pl \f t u v w x y z -> f (f (f t u v) w x) y z
08:10:01 <lambdabot> ap ((.) . (.) . (.) . (.) . (.)) ((.) =<< (.) . (.))
08:10:08 <yitz> oh it was a typo!
08:10:18 <koeien> the keys are like right next to each other
08:10:27 <yitz> @pl \t u v w x y z -> f (f (f t u v) w x) y z
08:10:28 <lambdabot> (((((f .) .) . f) .) .) . f
08:10:54 <yitz> still in UnlambdaLand though
08:11:30 <augur> yitz: i bet you could do that with a zip
08:11:32 <augur> and a fold
08:12:00 <yitz> augur: right
08:13:34 <yitz> augur: but in this case i would just write it out on separate lines to make it the most clear for the reader.
08:15:28 <Saizan> you should change the order of arguments of setIndex.
08:15:40 <Saizan> the list should come last, so that you can make a pipeline
08:16:11 <Sgeo> :t setIndex
08:16:12 <lambdabot> Not in scope: `setIndex'
08:17:01 <Saizan> http://hpaste.org/56073 <- i was referring to KorriX paste
08:17:46 <yitz> KorriX: in putHannoi you can get rid of the word where, and line up space and minus with levelprint.
08:18:42 <hpaste> “^^thief^^” pasted “Is there a better way of organizing this (ideally with separate files for each execute case)” at http://hpaste.org/56075
08:19:15 <yitz> KorriX: I would try to get all the non-IO logic out of hanoize into separate pure functions.
08:20:13 <Saizan> ^^thief^^: data Cmd = Cmd { execute :: AppState () }
08:20:27 <KorriX> yitz: you mean to first generate all states, and display all at the end ?
08:20:58 <Saizan> ^^thief^^: helpCmd cmd = Cmd (setMsg $ help cmd); ...
08:22:31 <yitz> KorriX: well, in a separate function. one thing you could do would be to use scanl instead of foldM_. that is a fold that accumulates all the partial results into list.
08:23:15 <yitz> KorriX: then have a function that maps over those and formats them for printing. finally, you take unlines of the whole thing and just print that one string.
08:23:39 <^^thief^^> Saizan: I'm not sure if I follow 100% (fairly new to this), would I still be able to have a type signature like "parseCommand :: String -> Either ParseError Cmd"
08:23:39 <KorriX> i will do this
08:23:47 <yitz> KorriX: there are other ways. the point is, we try not to let IO spread over the program.
08:24:07 <Saizan> ^^thief^^: yep
08:24:23 <KorriX> is there any simple method to get number of iteration in scanl ?
08:24:46 <yitz> KorriX: zip it with [1..]
08:24:47 <Saizan> ^^thief^^: you just would have to replace uses of constructors of Cmq into uses of functions like my helpCmd above
08:24:52 <koeien> KorriX: zip with [0..] is the standard way
08:24:57 <KorriX> okay
08:25:06 <koeien> > scanl (+) 0 [1,2,3,4,10,256]
08:25:07 <lambdabot>   [0,1,3,6,10,20,276]
08:25:56 <koeien> > scanl (\x (i, y) -> x + i*y) 0 (zip [0..] [1,2,3,4,10,256])
08:25:57 <lambdabot>   [0,0,2,8,20,60,1340]
08:26:57 <yitz> > zipWith (\n res -> "Result number " ++ show n ++ " is " ++ show res) [1..] $ scanl (+) 0 [1,2,3,4,10,256]
08:26:58 <lambdabot>   ["Result number 1 is 0","Result number 2 is 1","Result number 3 is 3","Resu...
08:27:31 <^^thief^^> Saizan: thanks for the help. could you explain the benefits of doing it that way over the way I have it now?
08:28:21 <^^thief^^> Saizan: My main concern right now is that once all the commands are implemented the "Command" file is going to be really huge - I'd like to split it into separate files
08:28:37 <Saizan> ^^thief^^: that each command gets defined indipendently from the others, since you don't have to list them all in the Cmd datatype and implementation of execute
08:29:13 <Saizan> ^^thief^^: yeah, with my solution you'd be able to define each one separately
08:29:16 <ski> ezyang : i actually don't recall the details of that paper atm, just that it was relevant ..
08:29:48 <Saizan> ^^thief^^: the only problem is that the only thing you would be able to do with a Cmd is to execute it
08:30:11 <^^thief^^> Saizan: Well thats all I'm doing, aside from creating it with Parsec
08:30:23 <Saizan> ^^thief^^: then this is perfect
08:30:31 <^^thief^^> Saizan: OK great thanks - I'll play around with the snippets you gave me
08:30:42 <ezyang> ski: They pull off monadfix by taking a page from the Scheme community and using mutable references
08:30:51 <ezyang> Although I now have forgotten why I was wondering about it.
08:33:02 <paulotruta> hey guys ;)
08:35:49 <paulotruta> i need to use the function sortOn :: (Ord b) => (a -> b) -> [a] -> [a] . What module do i need to import? I also did some search and i need to see the code of that function... where can i find it? Thanks in advance ;)
08:36:13 <koeien> @hoogle sortOn
08:36:13 <lambdabot> No results found
08:36:20 <cheater> @pl flip ($)
08:36:20 <lambdabot> flip id
08:36:31 <koeien> :t \f -> sortBy (compare `on` f)
08:36:31 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
08:36:44 <koeien> perhaps Data.List
08:36:45 <aristid> :t \f -> sortBy (comparing f)
08:36:46 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
08:37:17 <aristid> paulotruta: you need to define it yourself, i think. but Data.Ord has the function comparing.
08:37:24 <aristid> @hoogle comparing
08:37:24 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:37:46 <koeien> otherwise, Data.Function has on
08:37:46 <koeien> :t on
08:37:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:39:58 <paulotruta> hum, thanks koeien & aristid ... I think i will define it myself, but the pages i was reading made me think the function was already defined in some module on GHC
08:40:09 <paulotruta> looks like not ;)
08:40:16 <sheaf> how do I traverse a tree, giving the data of a node as an extra parameter for traversing the child forest?
08:40:31 <ski> ezyang : re `mfixM :: RecMonad m a => (m a -> m a) -> m a', this appears a bit similar to `newCyclicIORef :: (IORef a -> a) -> IORef a' (see `store.new_cyclic_mutvar' at <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_library/store.html>)
08:41:02 <sheaf> I can't see how Data.Traversable allows me to do that
08:41:28 <quicksilver> sheaf: it doesn't, you're entirely correct.
08:41:41 <quicksilver> sheaf: Data.Traversable only allows you to traverse nodes in isolation.
08:42:17 <quicksilver> it does allow you to accumulate state in some surrounding Monad but that's hard to use to solve your problem since you still don't know who your parent was.
08:42:49 <sheaf> quicksilver: acknowledged, thanks
08:43:05 <quicksilver> you probably want a tree zipper to allow you to traverse the tree "in context" (where the context tells you what your parent is, and your siblings)
08:43:27 <paulotruta> ppl look here http://hackage.haskell.org/packages/archive/data-ordlist/0.2/doc/html/src/Data-List-Ordered.html#sortOn ... Looks like i found it xD
08:44:04 <aristid> paulotruta: sure, but is that function worth installing a package? :)
08:44:16 <aristid> paulotruta: you can literally define the function with one line of code
08:45:32 <paulotruta> yeah, i know :) That's what i will do
08:49:17 <ski> ezyang : re `letrec' in Scheme, you can actually oncover the mutable variable hiding inside the implementation of `letrec', using `call-with-current-continuation' -- i.e. you can distinguish between the mutation-based and the `Y'-based implementation of `letrec' in this way
08:49:53 <yitz> quicksilver, sheaf: perhaps Data.Foldable is good enough for what sheaf needs?
08:50:10 <ezyang> ski: For some reason, I find that endlessly amusing :-)
08:51:11 <ski> sheaf : maybe you want to use a function `foldTree :: (a -> [r] -> r) -> (Tree a -> r)' ..
08:52:24 <ski> ezyang : i was thinking oleg has a post/article on that, but couldn't find it -- maybe i read it on comp.lang.scheme, i'm not sure
08:53:23 <quicksilver> yitz: no, foldable also doesn't give you enough context.
08:53:46 <quicksilver> and you can't recover teh shape of the tree from a depth-first traversal
08:53:55 <quicksilver> unless you add some more metadata
08:54:33 <sheaf> I'm trying something at the moment but it'll probably turn out to be garbage
08:57:26 <quicksilver> the traversal used by Foldable and Traversable are the same
08:57:37 <quicksilver> the difference is that in the former, the outputs are combined into a monoid
08:57:55 <quicksilver> and in the latter, they are slotted into the 'same' shape, and can incorporate effects.
08:58:57 <yitz> quicksilver: foldable does allow you to accumulate state. so if sheaf just needs that kind of accumulated state but doesn't need full information about the shape of the tree, i though foldable might help.
09:00:12 <yitz> *thought
09:00:17 <quicksilver> it doesn't allow yuou to accumulate state in a very general sense
09:00:23 <quicksilver> only as much as your Monoid instance permits
09:00:39 <quicksilver> which is very limited if you are playing by the rules, and keeping it associative.
09:01:01 <sheaf> ok so my new traversal function has this type
09:01:03 <sheaf> (a -> (a -> f b) -> (a -> f b)) -> (a -> f b) -> t a -> f (t b)
09:01:07 <sheaf> is this awful y/n?
09:02:02 <yitz> @free (a -> (a -> f b) -> (a -> f b)) -> (a -> f b) -> t a -> f (t b)
09:02:02 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:02:23 <MostAwesomeDude> I think that means that it might be awful, yes. :3
09:02:40 <yitz> MostAwesomeDude: I think it means the @free plugin is broken
09:03:00 <MostAwesomeDude> @free a -> b
09:03:00 <lambdabot> Extra stuff at end of line
09:03:28 <ski> @free foo :: a -> b
09:03:29 <lambdabot> g . foo = foo . f
09:03:44 <yitz> @free foo :: (a -> (a -> f b) -> (a -> f b)) -> (a -> f b) -> t a -> f (t b)
09:03:44 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
09:04:21 <ski> sheaf : is `f' supposed to be in `Functor' or `Applicative', maybe ?
09:05:01 <sheaf> sorry, yeah, f is Applicative, t is Functor
09:05:19 <yitz> @free foo :: (a -> (a -> fb) -> (a -> fb)) -> (a -> fb) -> ta -> ftb
09:05:20 <lambdabot> (forall x f1 f2. g . f1 = f2 . f                 =>                  g . p x f1 = q (f x) f2 . f) => g . f3 = f4 . f => k . foo p f3 = foo q f4 . h
09:06:27 <byorgey> sheaf: so you not only apply the function (a -> f b) to each element, but also use it to update the current (a -> f b) function which you're going to use on the next element?
09:06:28 * ski isn't really sure what sheaf is trying to do, here
09:06:45 <sheaf> byorgey: exactly
09:06:52 <byorgey> sheaf: why not just use an 'f' that carries some state?
09:06:56 <ski> sheaf : it seemed you wanted to traverse a `Tree a' before, but now it seems you want something more general ?
09:07:21 <byorgey> sheaf: then you can use a single  a -> f b  which happens to use the state to decide what to output (and also updates the state)
09:07:40 <ski>   data Tree a = Node {rootLabel :: a,subForest :: Forest a}
09:07:41 <ski>   type Forest a = [Tree a]
09:07:48 <ski> specifically that `Tree' type
09:08:54 <sheaf> byorgey: sure, but I still have to specify how to update the state somewhere
09:09:01 <sheaf> the way I'm doing it is probably clumsy though, yes
09:09:09 <ski> sheaf : so, what is an example implementation of that `(a -> (a -> f b) -> (a -> f b)) -> (a -> f b) -> t a -> f (t b)' thing ?
09:09:16 <byorgey> sheaf: yes, specifying how to update the state is part of the (a -> f b) function
09:09:57 <sheaf> ski: this might be wrong, but what i've got so far is
09:10:02 <tsousa> http://pastie.org/3126141 why this program does not return the 2^1000 if i give the input the number 1000?
09:10:04 <sheaf> pTraverse g f (Node x ts) = Node <$> f x <*> traverse (pTraverse g (g x f)) ts
09:10:09 <tsousa> it only works with 10
09:10:16 <tsousa> with 100 it does not work
09:10:35 <byorgey> sheaf: like it could be  (\a -> get >>= \s -> put (some combination of s and a) >> return (something in terms of s and a))
09:10:35 <ski> @type let pTraverse g f (Node x ts) = Node <$> f x <*> Data.Traversable.traverse (pTraverse g (g x f)) ts in pTraverse
09:10:36 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => (t -> (t -> f a) -> t -> f a) -> (t -> f a) -> Tree t -> f (Tree a)
09:10:59 <tsousa> solved
09:11:08 <tsousa> it need to be Integer instead of Int
09:11:24 <byorgey> sheaf: oh, that looks like it uses the *same* (a -> f b) function for each level, only updating it when it moves down a level
09:11:27 <byorgey> sheaf: is that what you want?
09:12:02 <sheaf> I think so
09:12:12 <byorgey> ok, then disregard what I said before.
09:14:08 <augur> sheaf, when you were just a child
09:14:12 <augur> were you
09:14:18 <augur> pre-sheaf?
09:14:29 <sheaf> yes
09:14:34 <augur> ok just checking
09:14:48 <^^thief^^> is there a way of having a top level module automatically import all its submodules?
09:14:50 <ski> @type let pTraverseB as f (Node a ts) = Node <$> f a as <*> Data.Traversable.traverse (pTraverseB (a:as) f) ts in pTraverseB
09:14:51 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => [t] -> (t -> [t] -> f a) -> Tree t -> f (Tree a)
09:15:21 <mike-burns> ^^thief^^: No.
09:15:27 <^^thief^^> ok thanks
09:15:39 <^^thief^^> is there a way to split a module across files then?
09:15:41 <ski> it seems to me that `g' above really just adds elements to `f', so that one can keep track of a list of such elements instead
09:16:07 <mike-burns> ^^thief^^: You can export an entire module from another module, if that helps.
09:16:35 <^^thief^^> mike-burns: I will look into it - I think that may be what I want to do
09:16:49 <ski> @type let pTraverseB f (Node a ts) as = Node <$> f a as <*> Data.Traversable.traverse (pTraverseB f `flip` (a:as)) ts in pTraverseB  -- maybe nicer argument ordering
09:16:50 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => (t -> [t] -> f a) -> Tree t -> [t] -> f (Tree a)
09:18:01 <ski> @type let pTraverseB f (Node a ts) as = Node <$> f a as <*> Data.Traversable.traverse (pTraverseB f `flip` (a:as)) ts in (ReaderT .) . pTraverseB . (runReaderT .)
09:18:02 <lambdabot> forall (m :: * -> *) t a. (Applicative m) => (t -> ReaderT [t] m a) -> Tree t -> ReaderT [t] m (Tree a)
09:19:29 <tsousa> http://pastebin.com/UYnceS3P i need this functions to be Integer
09:19:30 <mauke> The paste UYnceS3P has been copied to http://hpaste.org/56076
09:19:35 <tsousa> but if i do that it does not work
09:20:43 <yitz> @type digitToInt
09:20:43 <lambdabot> Char -> Int
09:21:27 <ski> @type fromIntegral . digitToInt :: Char -> Integer
09:21:28 <lambdabot> Char -> Integer
09:21:31 <yitz> tsousa: use fromIntegral . digitToInt
09:22:26 <yitz> @type map (fromIntegral . digitToInt) . show :: Integer -> [Integer]
09:22:26 <lambdabot> Integer -> [Integer]
09:23:41 <tsousa> yitz, staying like this to_digit x = map fromIntegral.digitToInt (show(x))
09:25:21 <tsousa> yitz, with that code i get an ghc error
09:25:52 <tsousa> http://pastebin.com/T7JXnQ68
09:25:54 <mauke> The paste T7JXnQ68 has been copied to http://hpaste.org/56078
09:25:54 <tsousa> this error
09:25:57 <rwbarton> you have parentheses in the wrong places
09:26:06 <KorriX> http://hpaste.org/56077 - corrected version. Thanks for yitz :)
09:28:42 <tsousa> rwbarton, then how can i solve it?
09:28:53 <rwbarton> tsousa: put the parentheses in the right places
09:28:56 <jamil_1_> hi all
09:28:59 <jamil_1_> haskell noob here
09:29:11 <jamil_1_> http://paste.pocoo.org/show/529949/
09:29:30 <jamil_1_> ghc says:  Not in scope: `getCh'
09:30:13 <tsousa> rwbarton, yes but where are the right places
09:30:50 <byorgey> jamil_1_: it should be 'getChar'
09:31:06 <jamil_1_> byorgey: but I dont want to echo back to screen
09:31:27 <jamil_1_> byorgey: following G. Huttons book
09:32:52 <byorgey> jamil_1_: apparently Hugs used to provide getCh as a primitive (as an extension to the Haskell language standard) but it doesn't any more (and GHC never has)
09:33:10 <jamil_1_> byorgey:  so I am out of luck ?
09:33:28 <jamil_1_> http://www.cs.nott.ac.uk/~gmh/errata.html say you can define you own such function
09:33:37 <jamil_1_> but can get it to compile
09:34:02 <byorgey> jamil_1_: ah. what error do you get?
09:34:34 <byorgey> that looks like it ought to work
09:34:58 <jamil_1_> byorgey: says: Not in scope: `hSetEcho'
09:35:02 <Juanp> hi there
09:35:08 <jamil_1_> byorgey: and: Not in scope: `stdin'
09:35:25 <byorgey> jamil_1_: and you have 'import System.IO' at the top of your file?
09:35:28 <byorgey> hu Juanp
09:35:30 <byorgey> *hi
09:35:34 <jamil_1_> byorgey: yep
09:35:56 <byorgey> jamil_1_: what version of GHC do you have?
09:36:45 <jamil_1_> byorgey: GHCi, version 7.0.3
09:36:59 <joeyh> the other day I saw ghc run pause(2) when I accidentially had an infinite loop in my program. I fixed the let var = var I'd accidentially put in, but does anyone know what the circumstances are when it compiles a loop down to pause()?
09:37:42 <jamil_1_> byorgey: never mind
09:37:44 <byorgey> jamil_1_: System.IO includes hSetEcho and stdin in GHC 7.0.3.
09:37:54 <byorgey> jamil_1_: figured it out?
09:38:16 <jamil_1_> byorgey: moved import to top of the file and it compiled fine
09:38:24 <byorgey> ah, ok =)
09:38:31 <byorgey> yes, imports have to go at the top
09:38:40 <jamil_1_> byorgey: thanks for the help, much appreciated :)
09:38:45 <cheater> i have a question, i am using this module for option parsing: http://hackage.haskell.org/packages/archive/cmdlib/latest/doc/html/System-Console-CmdLib.html   now i need to make an argument which will select one of the algorithms my program will use for processing a file. what's the best way to do that?
09:38:46 <byorgey> you're welcome =)
09:39:10 <cheater> the algorithm is being passed as a callback, i just need to select which callback
09:39:13 <cheater> and i am not sure how
09:41:04 <tsousa> yitz, i am sorry but  map fromIntegral.digitToInt.show a its not working
09:41:58 <ski> @index hSetEcho
09:41:58 <lambdabot> System.IO
09:42:35 <byorgey> tsousa: you want to map the function   fromIntegral.digitToInt.show  over the list x?
09:42:45 <byorgey> the list a, I mean
09:43:09 <yitz> byorgey: no. show a number, then map over the chars and get Integers.
09:43:19 <byorgey> ah.
09:43:32 <yitz> yitz: at least that's what it looks like tsousa is trying to do in the paste
09:43:41 <tsousa> yitz, yes
09:43:43 <byorgey> tsousa: you need parentheses around the argument to 'map'
09:43:57 <yitz> @type map
09:43:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:44:29 <byorgey> tsousa: map fromIntegral.digitToInt.show a  parses as   (map fromIntegral) . digitToInt . (show a)
09:44:33 <yitz> tsousa: that type of map means that it takes two parameters, a function and a list, and it returns a list
09:45:03 <byorgey> you probaly want   map (fromIntegral . digitToInt) (show a)
09:45:30 <byorgey> > map (fromIntegral . digitToInt) (show 123) :: [Double]
09:45:32 <lambdabot>   [1.0,2.0,3.0]
09:45:52 <tsousa> byorgey, yes that's it
09:45:56 <tsousa> thank you
10:17:41 <Varakh> hi, if've got a data type like data Test = Test1 Int | Test2 Int ... am i able to varify that any variable is of type e.g. Test1 Int ?
10:17:58 <Varakh> just pattern matching?
10:18:40 <Saizan> that's not a type
10:18:55 <Saizan> but yeah, pattern matching
10:19:18 <Saizan> ?src isJust
10:19:18 <lambdabot> isJust Nothing = False
10:19:18 <lambdabot> isJust _       = True
10:19:48 <wbooze>   
10:20:29 <Varakh> is it possible to examine of which type an is? Integer or Int?
10:21:28 <Eduard_Munteanu> Varakh: could you rephrase that?
10:21:36 <koeien> Varakh: i'm not sure what you mean
10:21:39 <Varakh> sry
10:21:39 <Varakh> ^^
10:22:07 <Varakh> i've got p = any number
10:22:18 <Varakh> and i'd like to know which type it is, Integer or Int
10:22:39 <koeien> :t 3
10:22:40 <lambdabot> forall t. (Num t) => t
10:23:04 <Varakh> data Test = Test1 Int | Test2 Integer ...p = Test2 4 so 4 has to be integer and i want to know that
10:23:15 <rwbarton> you already know that
10:23:18 <koeien> ah, but it is. the compiler makes sure.
10:23:30 <rwbarton> I know you know, because you just told me :)
10:24:15 <Varakh> (Test2 _) so _ will always be an Integer
10:24:33 <koeien> the argument to Test2 will need to be of type Integer.
10:24:39 <Varakh> okay
10:24:42 <Varakh> thansk
10:24:44 <Varakh> thanks
10:24:50 <koeien> the compiler ensures it, if you write (Test2 "not an integer, but a string"), then the compiler will complain
10:25:36 <frerich_> Does anybody know whether the author of LYAH is around here sometimes?
10:25:44 <Eduard_Munteanu> Also, there are no implicit conversions in Haskell, so you can't use an Int where an Integer is supposed to go (unless you explicitly convert).
10:25:44 <Renze> What is the name of the function f x [x, f x, f (f x), ...]?
10:25:51 <koeien> Renze: iterate
10:26:02 <Renze> Right, thanks
10:27:53 <Philonous_> @seen BONUS
10:27:54 <lambdabot> Unknown command, try @list
10:28:00 <Philonous_> ,seen BONUS
10:28:08 <monochrom> ask preflex
10:28:45 <shachaf> He's not online here much but you can find him on other IRC networks.
10:28:46 <Philonous_> I thought preflex reacted to comma
10:29:56 <Eduard_Munteanu> preflex: seen BONUS
10:29:56 <preflex>  BONUS was last seen on #haskell 248 days, 23 hours, 42 minutes and 26 seconds ago, saying: yeah i think that's better as well
10:38:46 <fasta> Is this header file GHC7.* only? Missing (or bad) header file: runProcess.h
10:42:18 <Varakh> The type signature for `step' lacks an accompanying binding .... step :: RMstate -> RMstate (State END c r m) = (State END c r m) any idea?
10:42:27 <Varakh> omfg
10:42:32 <Varakh> forgot step -.-
10:42:48 <merijn> Varakh: :D
10:44:07 <c_wraith> Varakh: the most common cause for that error message is a typo or capitalization mistake.  However, sometimes it does mean you just forgot it. :)
10:44:26 <Varakh> xD
10:52:06 <lukish> How can I rewrite (+) (solveTree t1) (solveTree t2) with one solveTree?
10:52:37 <parcs`> ((+) `on` solveTree) t1 t2
10:54:22 <parcs`> :t join (?f <$> ($ ?t1) <*> ($ ?t2)) ?solveTree
10:54:23 <lambdabot> forall a a1 b. (?f::b -> b -> (a1 -> b) -> a, ?t1::a1, ?t2::a1, ?solveTree::a1 -> b) => a
10:55:30 <lukish> :i on
10:55:44 <lukish> :hoogle on
10:56:13 <parcs`> :t (?f <$> ($ ?t1) <*> ($ ?t2)) ?solveTree
10:56:14 <lambdabot> forall b a b1. (?f::b1 -> b1 -> b, ?t1::a, ?t2::a, ?solveTree::a -> b1) => b
10:56:18 <parcs`> der we go
10:56:22 <parcs`> :T on
10:56:24 <parcs`> :t on
10:56:25 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:56:34 <parcs`> @hoogle on
10:56:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:56:34 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
10:56:35 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
11:00:53 <lukish> @hoogle permutation
11:00:53 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:00:53 <lambdabot> package permutation
11:00:53 <lambdabot> package action-permutations
11:03:09 <lukish> How can I filter ala-Integer numbers from [Double]? For example f [-4.0,12.0,0.3333333333333333] = [-4,12]
11:04:05 <koeien> lukish: well it's not conventionally possible. what you could do is check whether a number is very close to an integer
11:04:17 <koeien> this fails for very large numbers though
11:04:20 <dpratt71> what's a good name for a function that returns True if an input list does not contain duplicate elements?
11:04:34 <merijn> Well, you could convert double to int, then back to double and check whether the result is the same
11:04:41 <merijn> Then only keep elements that pass that test
11:05:13 <lukish> merijn: well, what are those convertors?
11:05:16 <merijn> Double -> Integer -> Double should be identity for Integers
11:05:30 <koeien> no
11:05:32 <lukish> truncate and fromInteger?
11:05:41 <shachaf> dpratt71: not . containsDuplicates
11:05:44 <shachaf> isNub?
11:05:45 <merijn> koeien: Elaborate
11:06:35 <koeien> merijn: i would think that very large FP numbers do not have enough significant digits to represent an integer. however i could be wrong.
11:06:51 <koeien> > (maxBound :: Double)
11:06:51 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
11:06:52 <lambdabot>    arising from a use o...
11:07:08 <dpratt71> shachaf: I like 'isNub' :)
11:07:21 <merijn> Double's around bounded because they have infinity as possible value
11:07:26 <shachaf> dpratt71: Better yet, isn'tNub!
11:07:31 <koeien> merijn: yeah
11:07:38 <koeien> :t round
11:07:38 <dpratt71> shachaf: :-D
11:07:39 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:07:50 <merijn> Ah, round is the one I was looking for
11:07:51 <lukish> @hoogle Integer -> Double
11:07:51 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
11:07:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:07:51 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:08:00 <merijn> lukish: You want round and fromIntegral
11:08:15 <merijn> :t fromIntegral . round
11:08:15 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
11:08:16 <koeien> @let closeToInt x = x - fromInteger (round (37.0)) < 1e-10
11:08:16 <lambdabot>  Defined.
11:08:20 <koeien> :t closeToInt
11:08:21 <lambdabot> forall a. (Fractional a, Ord a) => a -> Bool
11:08:21 <lukish> Why not truncate?
11:08:28 <koeien> @let closeToInt x = x - fromInteger (round x) < 1e-10
11:08:29 <lambdabot>  <local>:6:0:
11:08:29 <lambdabot>      Warning: Pattern match(es) are overlapped
11:08:29 <lambdabot>               In...
11:08:36 <koeien> @unlet
11:08:37 <lambdabot>  Defined.
11:08:37 <merijn> lukish: Doesn't matter for your case, I think
11:08:40 <koeien> @let closeToInt x = x - fromInteger (round x) < 1e-10
11:08:40 <lambdabot>  <local>:6:0:
11:08:40 <lambdabot>      Warning: Pattern match(es) are overlapped
11:08:41 <lambdabot>               In...
11:08:47 <koeien> never mind, you get the idea
11:08:49 <merijn> lukish: truncate rounds towards zero, round rounds down
11:09:12 <koeien> round rounds to closest integer
11:09:39 <merijn> > let cmp x = x == fromIntegral (round x) in cmp 4
11:09:39 <lambdabot>   True
11:09:40 <Varakh> how do I match a pattern in record syntax, e.g. END in my example? http://pastebin.com/SAxDJw9G it always gives me Couldn't match expected type `Integer -> RMcom' :/
11:09:41 <mauke> The paste SAxDJw9G has been copied to http://hpaste.org/56081
11:09:42 <merijn> > let cmp x = x == fromIntegral (round x) in cmp 4.1
11:09:43 <lambdabot>   False
11:10:03 <merijn> @pl \x -> x == fromIntegral (round x)
11:10:03 <lambdabot> ap (==) (fromIntegral . round)
11:10:16 <merijn> :t ap
11:10:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:11:15 <mauke> Varakh: like that
11:11:31 <koeien> a double has 52 bits
11:11:39 <Varakh> mauke: ?
11:11:40 <mauke> Varakh: you get a type error because END has the wrong type
11:11:44 <Varakh> ye
11:11:45 <lukish> @hoogle ap
11:11:45 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
11:11:45 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
11:11:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
11:11:47 <koeien> so integers larger than 2^52 cannot be represented with full accuracy
11:11:50 <mauke> Varakh: but the pattern itself is perfectly fine
11:12:58 <merijn> koeien: irrelevant if you have a double list and only want the integers in it. If a double can't represent an integer you can't encounter that integer in your input
11:13:02 <Varakh> mauke: i dont know how to fix the wrong type issue. cuz progr is called with e.g. p 1 = END
11:13:06 <roconnor> @ask tibbe if getCounter can be modified to be an arbitrary showable monoid
11:13:06 <lambdabot> Consider it noted.
11:13:23 <koeien> merijn: yeah, if the double cannot represent it you're out of luck anyway
11:13:40 <mauke> Varakh: what are you trying to do?
11:13:48 <Varakh> emulate assembler :P
11:14:02 <mauke> progr is a function. END is a RMcom
11:14:08 <Varakh> yes
11:14:17 <mauke> therefore progr can never be END and the pattern is nonsensical
11:14:41 <Varakh> prog1 n m = p where p 1= END
11:15:11 <mauke> what?
11:15:42 <lukish> > ap (==) (fromIntegral . round) $ Infinity
11:15:43 <lambdabot>   Not in scope: data constructor `Infinity'
11:15:54 <lukish> > ap (==) (fromIntegral . round) $ (1 / 0.0)
11:15:55 <lambdabot>   True
11:16:07 <lukish> It's bad
11:16:09 <koeien> > round (1/0)
11:16:10 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:17:42 <lukish> > truncate (1/0)
11:17:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:17:53 <lukish> > 1/0
11:17:54 <lambdabot>   Infinity
11:18:50 <lukish> @hoogle Infinity
11:18:50 <lambdabot> package infinity
11:18:51 <lambdabot> System.Posix.Resource ResourceLimitInfinity :: ResourceLimit
11:19:08 <lukish> How can i pattern-match that case?
11:19:12 <lukish> merijn:
11:19:39 <frerich_> MacBook-von-Frerich:haskell frerich$ hlint rpn.hs
11:19:40 <frerich_> No suggestions
11:19:41 <merijn> You could check for it before conversion
11:19:41 <frerich_> FINALLY!
11:19:56 <merijn> > (1/0.0) == (1/0.0)
11:19:56 <lambdabot>   True
11:19:59 <merijn> gah
11:20:04 * merijn kicks haskell
11:20:15 <merijn> > (1/0.0) :: Double == (1/0.0) :: Double
11:20:15 <lambdabot>   <no location info>: parse error on input `0.0'
11:20:33 <merijn> > ((1/0.0) :: Double) == ((1/0.0) :: Double)
11:20:34 <lambdabot>   True
11:20:37 <merijn> >.<
11:20:48 <lukish> I should check Infinity case
11:20:51 * mauke kicks merijn 
11:20:53 <merijn> I guess Haskell double's don't follow IEEE754
11:20:53 <lukish> Not 1/0
11:21:01 <mauke> merijn: why do you think that?
11:21:06 <koeien> they do, afaik
11:21:09 <merijn> Pretty sure NaN and Inifity never compare equal...
11:21:19 <merijn> Or is it just NaN?
11:21:21 <koeien> NaN
11:21:28 <koeien> infinity is equal to itself
11:21:30 <merijn> In which case, why the hell doesn't 1/0 return NaN >.>
11:21:36 <koeien> because it doesn't :P
11:21:39 <koeien> > 0/0
11:21:40 <lambdabot>   NaN
11:21:46 <mauke> merijn: because it's Infinity
11:21:46 <koeien> > (1/0) - (1/0)
11:21:47 <lambdabot>   NaN
11:21:48 <merijn> Fuck everything about floating point numbers >.>
11:22:02 <koeien> they are efficient, sometimes that's important
11:22:10 <lukish> How can I pattern match Infinity?
11:22:29 <koeien> you don't, use isInfinite
11:22:48 <koeien> (this also returns true on -Infinity)
11:22:48 <lukish> > isInfinite (1/0.0)
11:22:49 <lambdabot>   True
11:22:51 * merijn taps out
11:22:55 <lukish> Okay
11:22:57 <merijn> You're on your own :p
11:23:04 <merijn> This is why I avoid floats :>
11:23:24 <lukish> is there something like isNotInfinite?
11:23:28 <mauke> yes
11:23:34 <lukish> @hoogle Infinite
11:23:35 <lambdabot> package infinite-search
11:23:35 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
11:23:35 <koeien> not.isInfinite
11:23:43 <lukish> Ok
11:23:50 <mauke> it involves complicated math like boolean algebra
11:23:53 <koeien> this is normal function composition
11:24:26 <koeien> > 0.0 == -0.0
11:24:27 <lambdabot>   True
11:24:47 <koeien> > isNegativeZero 0.0
11:24:48 <lambdabot>   False
11:24:59 <mauke> > signum (-0.0)
11:25:00 <lambdabot>   0.0
11:25:06 <roconnor> > ((0/0.0) :: Double) == ((0/0.0) :: Double)
11:25:07 <lambdabot>   False
11:26:04 <mauke> > 0/0 == 0/0
11:26:05 <lambdabot>   False
11:26:12 <mauke> now with less fluff
11:26:51 * roconnor type annotates every subexpression ... for safety!
11:27:01 <gregATio> anyone use flymake or some form of tags in haskell?
11:28:04 <byorgey> > ((((0::Double) / (0.0::Double)) ::Double) == (((0::Double) / (0.0::Double))::Double) :: Bool  -- even safer!
11:28:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:28:11 <roconnor> hah
11:28:17 <byorgey> see, it's so safe it doesn't even run
11:28:19 <rostayob> gregATio: I use flymake with cabal projects
11:28:46 <roconnor> byorgey: you didn't annotate (==) nor its partial application
11:28:48 <roconnor> tsk
11:28:50 * frerich_ looks at his IRC window and wonders whether he accidentally joined #lisp
11:28:55 <monochrom> that is more like adding parentheses for safety
11:29:04 <byorgey> roconnor: oh!
11:29:07 * byorgey is ashamed
11:29:22 <zmv> you should always add parens
11:29:25 <zmv> because parens rock
11:29:34 <koeien> #lisp is that way -->
11:29:35 <zmv> (we should really write like this)
11:29:43 <zmv> koala_man: I'm already there :P
11:29:48 <monochrom> > ((((0) / (0.0))) == (((0) / (0.0)))  -- just as safe
11:29:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:31:01 <byorgey> > ((((==) :: Double -> Double -> Bool) (((0::Double) / (0.0::Double)) ::Double)) :: Double -> Bool) (((0::Double) / (0.0::Double))::Double) :: Bool
11:31:02 <lambdabot>   False
11:31:14 <parcs`> you forgot about /
11:31:20 <parcs`> what do you think the compiler is, magic?
11:31:24 <byorgey> hahahaha
11:31:36 <gregATio> rostayob: can you point me to a good link to understand how to use flymake with haskell?
11:31:41 <byorgey> well, let's not be RIDICULOUS.
11:31:45 <rostayob> gregATio: I use ghc-mod
11:32:00 <gregATio> Alt-X ghc-mod?
11:32:01 <rostayob> gregATio: http://www.mew.org/~kazu/proj/ghc-mod/en/
11:32:06 <rostayob> you have to install it
11:32:10 <gregATio> thanks
11:32:20 <rostayob> and you have to have haskell-mode ofc (you have to install that as well)
11:32:43 <mercury^> Hmm, that might not be a bad feature though: a tool that rewrites any expression by annotating everything.
11:33:04 <byorgey> mercury^: why would you want that?
11:33:07 <gregATio> i think i have haskell mode  already, thats part of the standard starter kit no?
11:33:27 <mercury^> byorgey: to check whether assumptions about implicit specialisation were correct.
11:33:27 <byorgey> gregATio: no
11:33:34 <rostayob> brett: no
11:33:37 <rostayob> ops
11:33:39 <rostayob> gregATio: no
11:33:48 <parcs`> isn't system f like that?
11:34:00 <byorgey> mercury^: but it seems there should be a better way to do that than annotation *everything*.
11:34:07 <gregATio> ah , ok will install thanks
11:34:09 <byorgey> parcs`: yes.
11:34:13 <byorgey> parcs`: GHC core is like that.
11:34:38 <mercury^> byorgey: it saves you from having to specify which part exactly you want to look at.
11:34:56 <mercury^> In return you have to find that part in the annotated version, but I think that saves time overall.
11:35:30 <lukish> @hoogle groupBy
11:35:30 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:35:30 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
11:35:30 <lambdabot> Data.ByteString.Lazy.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
11:36:38 <KorriX> when i am trying to compile my app by ghc --make it compiles without errors, but didn't create any binary - what can be wrong ?
11:36:50 <KorriX> my main = forever $ do ....
11:36:52 <mauke> how do you know it didn't create any binary?
11:36:58 <tromp> try ghc --make  ?
11:37:08 <tromp> oops,, ignore:(
11:37:29 <KorriX> i get .hi and .o files
11:37:35 <mauke> irrelevnt
11:37:38 <mauke> +a
11:37:40 <mauke> how do you know it didn't create any binary?
11:38:01 <KorriX> in compilation folder it didn't create it
11:38:02 <shachaf> .o is binary.
11:38:08 <mauke> how do you know it didn't create any binary?
11:38:10 <monochrom> I ask the same question as mauke's. it works for me.
11:38:22 <mauke> shachaf: yeah, but we're talking about executables here, not object files
11:38:29 <shachaf> Yes.
11:38:44 <tromp> i guess he checked with ls -rt  ?
11:38:59 <mauke> checked how exactly?
11:39:00 <KorriX> ls -al
11:39:09 <mauke> KorriX: what did it output?
11:39:25 <KorriX> one line: [1 of 1] Compiling Hanoi            ( hanoi.hs, hanoi.o )
11:39:38 <monochrom> paste exact verbatim output of ls
11:39:48 <mauke> KorriX: that's not something that ls would output
11:39:52 <shachaf> Perhaps it didn't create a binary because your module isn't named Main.
11:40:00 <lukish> How can I find longest consecutivity sublist? f [1,2,3,5] = [1,2,3], for example
11:40:02 <mauke> shachaf: unlikely
11:40:30 <hpaste> KorriX pasted “Output” at http://hpaste.org/56083
11:40:32 <monochrom> shachaf is right. I just tried.
11:40:37 <mauke> hmm
11:40:45 <mauke> ok!
11:40:48 <monochrom> perhaps it's just ghc 7
11:40:51 <augur> lukish: you could use a left fold of some sort!
11:41:04 <lukish> For example?
11:41:10 <augur> eh wel
11:41:10 <shachaf> I thought this was always the behaviour of GHC.
11:41:18 <KorriX> 7.0.4
11:41:20 <augur> if the list is empty just return the empty list, of course
11:41:26 <mauke> KorriX: can you paste hanoi.hs somewhere?
11:41:27 <augur> but otherwise you would want to do something like
11:41:32 <lukish> Okay
11:41:37 <lukish> Like what?
11:41:49 <augur> accumulate elements into a list, paired with an element
11:41:52 <hpaste> KorriX pasted “hanoi.hs” at http://hpaste.org/56084
11:41:57 <augur> where the element is the last item accumulated
11:42:15 <mauke> shachaf++ wins
11:42:18 <augur> and each time you accumulate, you ask if the next element to accumulate is "next" in the sequence
11:42:34 <mauke> KorriX: <shachaf> Perhaps it didn't create a binary because your module isn't named Main.
11:42:42 <KorriX> thanks
11:43:04 <monochrom> yikes, so 6.10, 6.12, 7.0 all do this
11:43:35 <KorriX> mauke: thanks, module name is important
11:44:17 <monochrom> you can write "module Main where" or delete it altogether
11:44:17 <shachaf> You can also compile with -main-is Hanoi
11:44:25 * hackagebot scalable-server 0.2.2 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.2.2 (JamieTurner)
11:44:37 <monochrom> you can also just put main in another file
11:44:46 <lukish> Is there some function to get elements wich exist in 2 lists?
11:44:58 <lukish> f [1,2,3] [2,3,4] -> [2,3]
11:45:05 <mauke> :t intersect
11:45:06 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:45:10 <lukish> Okay
11:45:20 <shachaf> @hoogle (Eq a) => [a] -> [a] -> [a]
11:45:20 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
11:45:20 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
11:45:20 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
11:45:23 <monochrom> it's going to be slow, but as you wish
11:45:29 <augur> > intersect [1,2,2,3] [2,2,3,4]
11:45:30 <lambdabot>   [2,2,3]
11:45:35 <mauke> > intersect [1,2,3] [2,3,2]
11:45:36 <lambdabot>   [2,3]
11:47:52 <dpratt71> is there a straightforward way to do a 'parallel' filter? (I mean a filter operation where the predicate expressions are evaluated in parallel)
11:48:04 <ski> > (head . filter (and . (zipWith ((==) . (1 +)) `ap` tail)) . sortBy (flip (comparing length)) . (++ [[]]) . concatMap (tail . inits) . tails) [1,2,3,5]
11:48:06 <lambdabot>   [1,2,3]
11:48:19 <parcs`> hmm
11:48:21 <parcs`> i got
11:48:24 <parcs`> > listToMaybe . sortBy (flip $ comparing length) . filter (\xs -> [head xs..head xs + length xs - 1] == xs) . tail . subsequences $ [1,2,3,5]
11:48:25 <lambdabot>   Just [1,2,3]
11:50:36 <tibbe> roconnor: you want the Counter itself to be a monoid?
11:50:36 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:06 <roconnor> tibbe: well, only if it is easy
11:51:10 <tibbe> roconnor: so Show isn't quite enough, it's more like SerializableToTheDataFormatsWeSupport
11:51:15 <roconnor> tibbe: maybe it needs to be a commutativemonoid
11:51:21 <DukeDave> Is there a nice way to have ghc tell you exactly what packages (and their versions) it is using when you --make ?
11:51:30 * shachaf wonders whether \s p l -> catMaybes (parMap s (\x -> if p x then Just x else Nothing) l) would be any good.
11:51:32 <roconnor> tibbe: that is a good class name :)
11:51:45 <roconnor> tibbe: feel free to ignore me.  I have an urge to abstract
11:51:48 <tibbe> roconnor: I've been a bit lazy and not thought deeply about how much we can generalize and still make the counter updates not impact the program being measured
11:52:03 <roconnor> tibbe: oh, I see
11:52:09 <tibbe> roconnor: I have thought about it but haven't found enough time to look into it in depth
11:52:26 <roconnor> tibbe: good point about impact
11:53:31 <cheater> hey guys what is the best way to have a dictionary-like data structure in haskell?
11:53:37 <dpratt71> shachaf: yeah, I was thinking along those lines; I wish there was something a bit more direct, but that's probably unlikely
11:53:49 <tibbe> roconnor: the goal is to make it possible to always leave the monitoring on
11:53:56 <tibbe> cheater: Data.Map or Data.HashMap
11:54:13 <shachaf> dpratt71: Keep in mind that I've never really actually used Control.Parallel.Strategies etc.
11:54:20 <shachaf> So you probably oughtn't listen to me.
11:54:26 <cheater> the crudest thing i thought of is a list [(String, a)] and write a function which checks the String and then yields a if the String is what i'm searching for
11:54:38 <cheater> it doesn't have to be performant, hopefully something simple and in the stdlib
11:54:45 <cheater> tibbe: is there something simpler? :)
11:55:00 <dpratt71> shachaf: well, this is an experiment, so worth trying anyways, thanks :)
11:55:04 <shachaf> There is no "best way" unless you give a way to compare two ways.
11:55:08 <lukish> @hoogle a -> [a] -> Bool
11:55:08 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:55:09 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:55:09 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:55:09 <shachaf> Data.Map is good.
11:55:27 <parcs`> cheater: [(String, a)] and lookup
11:55:29 <parcs`> :t lookup
11:55:30 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:55:35 <cheater> oh right lookup
11:55:42 <cheater> i knew there was some function like that
11:55:44 <mux> :t Data.Map.fromList
11:55:45 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
11:56:14 <shachaf> Data.Map is better because its type indicates what it is.
11:56:15 <hpaste> srhb pasted “Problem using random values” at http://hpaste.org/56085
11:56:39 <srhb> In the above paste, positions is an Int, but I meant for it to be a List of IO Int. What am I misunderstanding?
11:56:44 <tibbe> cheater: simpler in what sense?
11:56:59 <cheater> tibbe: in the sense that parcs showed :)
11:57:09 <tibbe> cheater: I see
11:57:33 <tibbe> cheater: Data.Map.lookup and Data.Map.fromList will probably save you headaches in the long run
11:57:33 <mauke> :t randomRs
11:57:34 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
11:57:44 <mauke> srhb: the type of randomRs
11:57:46 <cheater> nah this thing's only used in one place at one level
11:57:54 <cheater> and the value is hard coded
11:58:04 <tibbe> ok
11:58:10 <tibbe> then it's fine I guess :)
11:58:12 <srhb> mauke: The value looks right I think?
11:58:20 <mauke> srhb: what value?
11:58:28 <srhb> mauke: Sorry, the type.
11:58:48 <mauke> srhb: what is the type of rnds?
11:58:51 <srhb> mauke: Ah no, I have an error.
11:58:58 <srhb> mauke: Or wait, no.
11:59:23 <srhb> mauke: rnds :: Random a => a -> a -> [a]
11:59:32 <monochrom> Data.Map is simple and comes with GHC. Data.Map.lookup is as simple as Data.List.lookup
11:59:51 <mauke> srhb: what's the type of take n $ rnds 0 (length xs - 1)?
12:00:31 <srhb> mauke: Aside from guessing.. I don't know. I think it would be [Int] or [IO Int]
12:00:39 <monochrom> unordered-containers has Data.Hashmap and is on hackage. it is as simple as all of the above
12:00:44 <mauke> srhb: why do you have to guess?
12:00:57 <mauke> srhb: and where are you getting the IO from?
12:01:16 <srhb> mauke: True, I used randomRIO earlier, and I'm probably confusing that.
12:01:30 <shachaf> srhb: You should probably understand how IO works in Haskell.
12:01:39 <mauke> first things first
12:01:45 <shachaf> x :: IO Int is a completely different sort of value than y :: Int
12:01:46 <mauke> you should understand how types work
12:02:04 <srhb> mauke: I have a basic understanding and I'm working this example to further it.
12:02:25 <mauke> i.e. when you have f :: A -> B, then in the expression 'f x' the x must have type A and the result type B
12:02:34 <shachaf> If you don't understand how types work, you shouldn't do anything involving IO until you do.
12:02:54 <mauke> length xs :: [Int]
12:03:04 <srhb> shachaf: I do, but I am confused in this problem. Please stop echoing, mauke is helping. :)
12:03:05 <mauke> therefore rnds 0 (length xs - 1) :: [Int]
12:03:06 <shachaf> mauke: What?
12:03:15 <mauke> right, I'm crazy
12:03:20 <mauke> length xs :: Int
12:03:26 <srhb> Yes.
12:03:37 <mauke> therefore take n $ rnds 0 (length xs - 1) :: [Int]
12:03:49 <srhb> Right, as it should be.
12:04:07 <mauke> when you have 'x <- y', then y :: T A and x :: A
12:04:12 <mauke> for some types T and A
12:04:17 <cheater> @hoogle [String] -> String -> String
12:04:18 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
12:04:18 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
12:04:18 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
12:04:26 * hackagebot yesod-core 0.9.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.4.1 (MichaelSnoyman)
12:04:30 <mauke> [Int] is equivalent to [] Int
12:04:34 <srhb> right.
12:04:39 <mauke> therefore positions :: Int
12:04:49 <srhb> So positions ought to be [] Int
12:04:52 <mauke> no, Int
12:04:59 <srhb> Oh?
12:05:31 <mauke> in the x <- y example with y :: T A and x :: A ...
12:05:43 <mauke> x = positions, y = take n $ etc, T = [], A = Int
12:07:37 <srhb> That is definitely confusing. The right side is a list, but the left side is an Int. Which one?
12:07:40 <tsousa> any though in how to solve this problem http://projecteuler.net/problem=11 ?
12:07:57 <srhb> tsousa: The wiki has solutions.
12:08:21 <mauke> srhb: all of them
12:08:26 <mauke> it's a loop
12:08:42 <shachaf> tsousa: If you don't know how to solve the problem on your own, what's the point of asking in IRC?
12:08:43 <tsousa> i dont want to see the solution. i want to solve it muself. but i am thinking in a good way of doing it
12:08:52 <mauke> a foreach loop, if you know other languages with those
12:09:40 <shachaf> If you can't figure it out, either think about it or go to another problem or learn more and then go back to it.
12:10:03 <srhb> mauke: I do, but. meh. I don't get this.
12:10:16 <tsousa> cant you just recommend me a algorithms to solve it?
12:10:26 <mauke> tsousa: how about brute force?
12:10:33 <shachaf> I recommend brute-force.
12:10:52 <mauke> > do { x <- [1, 2, 3]; y <- [7, 5]; return (x * y) }
12:10:53 <lambdabot>   [7,5,14,10,21,15]
12:10:54 <shachaf> I-probably over-hyphenate words-that I-use.
12:11:17 <tsousa> mauke, that will not make that much eficient
12:11:27 <mauke> tsousa: so what?
12:11:42 <srhb> mauke: OK, I can see something to me magical is going on, so I'll take a step back from that way of solving it. Thanks.
12:11:42 <xivix> mauke: i'm still a rockstar
12:12:50 <mauke> tsousa: a simple brute force solution, running (not compiled) under runghc, takes 0.45s here
12:13:03 <srhb> mauke: So now I can rewrite it as a REAL function with let..in.. And have a pseudofunction with no type annotation that warns about that. That seems strange.
12:13:04 <mauke> and it's only that slow because gcc is eating 99% CPU in my other terminal
12:13:13 <rwbarton> i was wondering how it was that slow
12:13:39 <morel> why does hoogle not have an own IRC-channel?
12:14:15 <shachaf> morel: Why would it?
12:14:36 <srhb> Aha, now I know why I was confused.
12:15:27 <morel> shachaf: Why not? =)
12:15:51 <shachaf> morel: Opportunity cost.
12:16:31 <monochrom> demand and supply
12:16:47 <cheater> command and apply
12:17:10 <morel> hm. ic. okay.
12:17:42 <Philippa> I guess we could have ##lambdabotabuse or something
12:17:58 <srhb> That's just /query lambdabot anwyay. :-)
12:18:14 <monochrom> but sometimes someone wants to watch someone else's abuse
12:18:18 <Philippa> not quite true: sometimes you want to do it in public
12:18:20 <Philippa> right
12:18:40 <monochrom> /msg lambdabot beat me! more!
12:19:25 <morel> could anyone inhere change hoogle's css?
12:19:31 <mdmkolbe> Can you put a splice (i.e. $(...)) inside a quasi-quote (i.e. [foo| ... ])?  My guess is no (i.e. there is no way to do "let x = ... in [foo| ... $(x) ...]" and have the "$(x)" get the value of the "let" binding), but maybe I'm overlooking something
12:20:49 <Philippa> mdmkolbe: I think there's a separate barrier to that unfortunately, unless I've missed some improvements to the TH implementation lately
12:21:25 <mdmkolbe> Philippa: what do you mean by "separate barrier"?
12:21:35 <rwbarton> mdmkolbe: here x :: String?
12:21:39 <lukish> @hoogle sortBy
12:21:39 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:21:39 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
12:21:39 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
12:21:44 <rwbarton> wait
12:21:56 <rwbarton> oh yeah
12:22:17 <rwbarton> what is the type of x supposed to be?
12:23:07 <mdmkolbe> rwbarton: eh, probably "Q Exp"
12:24:15 <rwbarton> but a quasiquoter just expects a string
12:26:24 <mdmkolbe> rwbarton: yeah.  I think the quasiquoter interface is incapable of expressing this situation, but I wasn't sure if I overlooked something (e.g. the quasiquoter could parse the splice itself and somehow inspect its environment (IIUC, that sort of introspection isn't Haskell))
12:34:02 <cheater> does the stdlib have a function like the posix uniq tool?
12:34:36 <cheater> [1, 2, 2, 3, 4, 4, 4, 4] -> [1, 2, 3, 4]
12:34:57 <rwbarton> you can use group or maybe nub
12:35:33 <earthy> sounds like you want nub
12:35:43 <earthy> which is uniq. :)
12:35:46 <cheater> nub is best
12:35:52 <rwbarton> uniq is actually more like map head . group
12:36:04 <cheater> yeah uniq doesn't pre-sort
12:36:08 <rwbarton> despite the name
12:36:09 <cheater> it has to work on live streams
12:36:23 <cheater> in dsp terms, uniq is a high pass filter.
12:36:24 <earthy> rwbarton: true enough
12:36:28 <ion> nub is lazy, too.
12:36:49 <earthy> the intention of uniq is that of nub though... ;)
12:38:29 <lukish> How can I convert from RealFloat to Fractional ?
12:38:41 <ion> @type realToFrac
12:38:42 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
12:39:31 <rwbarton> alternatively "you don't need to since Fractional is a superclass of RealFloat"
12:40:10 <tsousa> i have an file that has a number. i read it but i has \n. is there a way of deleting them all and join it in only one int array?
12:42:13 <mauke> int array?
12:42:13 <Phlogistique> is there a name for let { inter l [] = l ; inter [] l = l ; inter (x:xs) (y:ys) = x:y:inter xs ys } in inter ?
12:42:48 <tsousa> mauke, yes i am reading a number from a file
12:43:04 <tsousa> then i need to delete all of the \n from it
12:43:04 <mauke> a number is not an array
12:43:14 <tsousa> and stora that value into a variable
12:43:18 <rwbarton> a number doesn't have \ns
12:43:22 <tsousa> for me to care one
12:43:33 <tsousa> yes but this on is stored in a file
12:43:35 <rwbarton> why don't you give an example
12:43:41 <tsousa> and it has multiple lines
12:43:48 <tsousa> the file is like
12:43:50 <tsousa> 12345567
12:43:53 <tsousa> 2345744567
12:43:54 <mauke> where does the array come in?
12:44:12 <tsousa> i need to join it all other
12:44:16 <mauke> what
12:45:02 <monochrom> I do think the question is fairly unorganized. but why don't we just read one single number right and skip one \n right first before worrying about the rest of the file
12:45:02 <rwbarton> I could guess what you are trying to say but then monochrom would yell at me
12:45:42 <tsousa> i have an file
12:45:52 <tsousa> i need to read this file to fetch a number
12:45:58 <tsousa> this number has multiple lines
12:46:01 <rwbarton> no
12:46:02 <tsousa> like
12:46:05 <rwbarton> oh
12:46:06 <tsousa> 1234567\n
12:46:07 <monochrom> readLn will usually read one number and a \n, and it throws away the \n
12:46:10 <tsousa> 12345677\n
12:46:40 <tsousa> i need to remove the \n and join the all content of a file into one variable
12:46:48 <mauke> where does the array come in?
12:47:00 <rwbarton> he said "array" because he's writing a program
12:47:10 <rwbarton> what he means is he has a number which is written on several lines
12:47:19 <monochrom> I think the "array" part is just an XY problem
12:47:26 <rwbarton> yes
12:47:37 <mauke> yes, but I'd still like a confirmation
12:48:14 <tsousa> yes
12:49:12 <mauke> :t fmap (read . filter (inRange ('0', '9'))) . readFile
12:49:13 <lambdabot> forall a. (Read a) => FilePath -> IO a
12:49:50 <monochrom> if you don't mind lazy I/O of readFile, there is a slick way. (read . concat . lines <$> readFile "file")
12:50:28 <tsousa> nice
12:50:32 <tsousa> ok i will implement
12:50:33 <tsousa> thanks
12:50:41 <monochrom> (concat . lines <$> readFile "file") >>= readIO  if you want parse error to become an IO exception
12:50:54 <mdmkolbe> @type (<$>)
12:50:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:51:06 <monochrom> <$> is another way to say liftM
12:52:01 <tsousa> i dont know what >>= means
12:52:25 <mdmkolbe> tsousa: where did this problem come from?
12:52:33 <matobet> @pw (.q).(.q)
12:52:33 <lambdabot> (. q) . (. q)
12:52:41 <matobet> @pf (.q).(.q)
12:52:41 <lambdabot> Maybe you meant: bf pl
12:52:41 <monochrom> (a >>= b) means do { x <- a; b x }
12:52:58 <tsousa> mdmkolbe, i am trying to improve my Haskell skill while solving some project euler exercises
12:53:45 <matobet> @unpl (.q).(.q)
12:53:45 <lambdabot> (\ e h -> e (q (q h)))
12:54:37 <nand`> I thought <$> was on applicatives? if it's on functors, what's the point between differentiating between it and fmap? They're the same function, are they not?
12:55:00 <rwbarton> fmap is (<$>) is liftM
12:55:15 <monochrom> IO is an Applicative too
12:55:20 <rwbarton> there isn't much point in differentiating between any of them
12:55:22 <monochrom> and a Functor too
12:55:42 <monochrom> <$> is given a nice precedence
12:55:58 <nand`> liftM is not fmap, liftM is defined on all monads, where as fmap is defined on all functors - in the off chance that a type is a member of one but not the other, it holds a practical difference
12:56:09 <rwbarton> yes I'm aware of that
12:56:14 <cheater> @hoogle nub
12:56:14 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
12:56:14 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:56:17 <cheater> @hoogle sort
12:56:17 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
12:56:18 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:56:18 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
12:56:20 <ciaranm> if your monads aren't functors you need to punch someone
12:56:53 <monochrom> everything you say is right and it doesn't contradict the fact that (read . concat . lines <$> readFile "file") does what I want
13:00:44 <cheater> @hoogle fromInt
13:00:44 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
13:00:44 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
13:01:15 <cheater> i have two Int's that i want to divide by eachother, what do i do?
13:01:22 <mauke> div
13:01:34 <cheater> why not / ?
13:01:39 <ion> @type (/)
13:01:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:01:40 <mauke> because that's floating point division
13:01:48 <ion> s/floating point/fractional/
13:01:55 <cheater> i want fractions
13:01:58 <cheater> i don't want div
13:02:07 <mauke> fromIntegral both
13:02:13 <ion> > ((/) `on` fromIntegral) (42 :: Int) 5
13:02:14 <lambdabot>   8.4
13:02:50 <ski> > fromIntegral (42 :: Int) / fromIntegral (5 :: Int) :: Rational
13:02:50 <lambdabot>   42 % 5
13:03:09 <mauke> > 42 / 5 :: Rational
13:03:10 <lambdabot>   42 % 5
13:03:13 <cheater> thank you
13:14:02 <cheater> hi i am having trouble using CmdLib, i cannot get rid of one warning
13:14:08 <cheater> Warning: No explicit method nor default method for `CmdLib.run'' In the instance declaration for `CmdLib.RecordCommand Main'
13:14:14 <cheater> the code is fairly simple: instance CmdLib.RecordCommand Main where mode_summary _ = "Metric tool."
13:15:21 <byorgey> cheater: the warning is also fairly simple: it means you have not given an implementation for the 'run' method of the RecordCommand class
13:15:30 <cheater> i realize that
13:15:37 <cheater> but i have no idea what the syntax for that would be
13:15:51 <byorgey> instance CmdLib.RecordCommand Main where
13:15:53 <cheater> i just tried doing "run = id" where mode_summary was
13:15:57 <byorgey>   mode_summary = ...
13:15:59 <byorgey>   run = ...
13:16:25 <cheater> exactly
13:16:28 <cheater> but then i get:     `run' is not a (visible) method of class `CmdLib.RecordCommand'
13:16:40 <Axman6> D:
13:16:52 <byorgey> oh!   `CmdLib.run''
13:16:55 <byorgey> notice the extra '
13:17:04 <byorgey> so it is called  run'  not run
13:17:32 <JuanDaugherty> that's the shell interface pkg, innit?
13:17:42 <cheater> ohh
13:17:48 <cheater> JuanDaugherty: no it's the optparse kind of thing
13:18:06 <Axman6> I do wish that GHC would use "foo" instead of `foo'
13:18:24 <jimmyrcom> easier copy/paste into google with quotes
13:18:46 <cheater> i find `' superior
13:18:47 <JuanDaugherty> optparse being the pythong pkg
13:18:57 <byorgey> Axman6: yeah, or <foo>, or basically anything OTHER than valid identifier characters
13:18:57 <cheater> because it's more clear where quotes start and end and how they nest
13:18:59 <Axman6> i'd be just as happy with <foo> actually
13:20:49 <Axman6> cheater: except that ' is a valid character for identifiers, and is the reason you just had the problem you did
13:21:16 <cheater> yep you're right
13:21:21 <cheater> there might be better ideas
13:21:25 <cheater> unicode!!
13:21:34 <cheater> anyways, the whole thing works now.. thanks a lot guys
13:37:46 <nexion> is there a read that doesn't throw exceptions?
13:37:55 <c_wraith> :t reads
13:37:56 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:38:11 <c_wraith> sadly, readMaybe has never been added to base
13:38:20 <monochrom> which gives you [] for parse errors
13:38:39 <c_wraith> > reads "123abc" :: Int
13:38:40 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:38:40 <lambdabot>         against inferred type ...
13:38:41 <nexion> ty
13:38:41 <c_wraith> err
13:38:48 <c_wraith> > reads "123abc" :: [(Int, String)]
13:38:49 <lambdabot>   [(123,"abc")]
13:39:02 <c_wraith> so...  depending on whether you want to call that a failure or not
13:39:05 <c_wraith> you need to be aware of it
13:39:31 <monochrom> @src read
13:39:31 <lambdabot> read s = either error id (readEither s)
13:39:46 <Axman6> readEither? :o
13:39:48 <monochrom> @src readEither
13:39:48 <lambdabot> Source not found. Wrong!  You cheating scum!
13:39:55 <monochrom> that's funny :)
13:39:59 <byorgey> nexion: you may be interested in the 'safe' package
13:40:02 <byorgey> @package safe
13:40:02 <lambdabot> http://hackage.haskell.org/package/safe
13:40:15 <Axman6> > readEither "123abc" :: Either String Int
13:40:15 <lambdabot>   Not in scope: `readEither'
13:40:16 <byorgey> which defines several 'safe' variants of read (as well as other functions)
13:40:19 <Axman6> :(
13:40:24 <Eduard_Munteanu> How about spoon? :)
13:40:30 <monochrom> pretty sure readEither is total fiction
13:40:41 <byorgey> spoon is a bit overkill for this particular application =)
13:41:01 <Shiney> read "123"
13:41:26 <Shiney> read "123" ::int
13:41:36 <monochrom> overkill: unsafePerformIO (try (read "123"))
13:41:40 <monochrom> err
13:41:42 <Eduard_Munteanu> > read "123" :: Int
13:41:42 <lambdabot>   123
13:41:47 <Axman6> > read "123" :: Int -- notice the >
13:41:48 <monochrom> unsafePerformIO (try (readIO "123"))
13:41:48 <lambdabot>   123
13:41:58 <Eduard_Munteanu> (and capitalization for types)
13:42:03 <Shiney> read "123" :: Int
13:42:19 * Eduard_Munteanu gives Shiney a bag of '>'s
13:42:27 <byorgey> Shiney: you still need a > at the beginning
13:42:30 <Shiney> oh
13:42:32 <Shiney> i see
13:42:33 <monochrom> and a space
13:42:46 <byorgey> but not until after the >
13:42:55 <Shiney> > read "123"
13:42:55 <tech2> without which this channel would get entertaining I expect.
13:42:56 <lambdabot>   *Exception: Prelude.read: no parse
13:42:59 <Shiney> like that
13:43:02 <byorgey> yep
13:43:16 <byorgey> tech2: not in scope: `without'
13:43:16 <ciaranm> literate lambdabot!
13:43:16 <Shiney> > read "123"
13:43:17 <lambdabot>   *Exception: Prelude.read: no parse
13:43:25 <tech2> byorgey: :P
13:43:25 <Eduard_Munteanu> :t read
13:43:26 <lambdabot> forall a. (Read a) => String -> a
13:43:29 <Shiney> > read "123" :: Inr
13:43:30 <lambdabot>   Not in scope: type constructor or class `Inr'
13:43:32 <Shiney> > read "123" :: Int
13:43:32 <lambdabot>   123
13:43:38 <Shiney> right ok
13:43:58 <Eduard_Munteanu> lambdabot answers to private questions as well
13:44:21 <Shiney> can't I just use ghci?
13:44:30 <monochrom> yes
13:44:47 <ciaranm> if you use ghci you can't add together functions!
13:44:52 <Eduard_Munteanu> Yeah, sure. lambdabot is nice for IRC interaction and maybe some of its plugins come in handy
13:45:01 <Eduard_Munteanu> You can install it locally with some luck, though.
13:45:22 <byorgey> luck does not suffice.
13:45:30 <Clint> apt-get install lambdabot
13:45:48 <Shiney> what stops it from printing forever if I write a statement like [1..]?
13:45:53 <ciaranm> > (+3) + (+4) $ 5
13:45:54 <lambdabot>   17
13:45:58 <ciaranm> lambdabot is magic!
13:46:03 <byorgey> Shiney: in ghci, nothing.
13:46:12 <Eduard_Munteanu> > [1..]
13:46:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:46:18 <byorgey> Shiney: in lambdabot, it cuts off responses at a certain length
13:46:20 <ab500> alright, so I have a question on how to implement a certain algorithm
13:46:22 <Shiney> k
13:46:39 <Eduard_Munteanu> With a few exceptions, though.
13:46:40 <byorgey> ab500: ask away
13:47:04 <ab500> I'm working on a classic interview question to get my feet wet: given a list of random numbers, find three that sum together to some value.
13:47:05 <Eduard_Munteanu> e.g. asking for the type of some weird stuff
13:47:31 <ab500> and in procedural programming by sorting the list first you gain some efficiency improvements
13:47:55 <tech2> ab500: could just sum all permutations of the numbers.
13:47:59 <ab500> and I've got that I can create an exhaustive combination of three numbers from the list and filter on a + b + c
13:48:35 <ab500> but, is there a way to make it more efficient, like in procedural code where I can exploit a sorted listed and move the runtime from n^3 to n^2?
13:48:55 <ciaranm> ab500: you can still sort...
13:49:08 <byorgey> ab500: certainly. there is nothing about that algorithm which is inherently procedural/imperative.
13:49:36 <byorgey> although translating it may take some careful thought.
13:50:54 <monochrom> put stuff in Data.Map. equivalent to sorting.
13:51:09 <monochrom> or rather, equivalent to sorting then binary-searching
13:51:11 <byorgey> I would do it something like: given the list [a1, a2, a3, ...]  first generate the list [(a1, [a2, a3, ..]), (a2, [a3, ...]), ...]
13:51:37 <byorgey> then use takeWhile to throw away the ones toward the end where the sum of an and the first element of the remaining list is already too big
13:52:12 <byorgey> then do something similarish on the list in each pair to find possibilities for the second and third numbers
13:52:26 <Axman6> (assuming positive numbers)
13:52:46 <rwbarton> how about starting with finding two numbers from a list that sum to a given number
13:52:53 <byorgey> I was assuming [a1, a2, a3, ...] is already sorted
13:52:56 <ab500> so traditionally you sort the list, and then for each number in the list you start from the head and the tail from the list, and if the sum of the three numbers is less than the required value increment the bottom pointer, else decrement the top pointer until they overlap
13:53:03 <byorgey> I don't think it matters whether some are negative
13:53:49 <rwbarton> ab500: yep, you can do that in Haskell more or less directly also
13:54:04 <rwbarton> write a recursive function that takes two lists and pass it the original (sorted) list and the reversed list
13:54:19 <ab500> rwbarton: ohhh that's clever
13:54:30 * ab500 is a haskell noob
13:54:34 <nh2> what haskell package do I use for typesafe template-haskell printfs?
13:55:53 <Axman6> @hoogle printf
13:55:53 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
13:55:53 <lambdabot> Text.Printf class PrintfArg a
13:55:53 <lambdabot> Text.Printf class PrintfType t
13:55:57 <Axman6> @more
13:56:03 <Axman6> @hoogle+
13:56:03 <lambdabot> Text.Printf module Text.Printf
13:56:03 <lambdabot> package printf-mauke
13:56:04 <lambdabot> package Printf-TH
13:56:15 <Axman6> Printf-TH I'd guess
13:56:51 <ciaranm> i thought @hoogle+ allowed you to return a copy of the website changed to have you following a particular developer's work
13:57:20 <Axman6> hmm?
14:01:11 <Axman6> hmm, i'm not used to hearing about monoids being used outside haskell
14:01:22 <ciaranm> monoids are everywhere
14:02:01 <c_wraith> It's something that's so abstract it doesn't really fit into OO hierarchies.
14:02:25 <c_wraith> As well as the fact that the unit is a non-function value...  that makes java cry
14:02:28 <Axman6> it's being used when talking about Cilk++
14:02:30 <nh2> Axman6: unfortunately, Printf-TH has one version released, 2008
14:03:03 <rwbarton> neither mempty nor mappend fits the OO model of attaching a dictionary to each value well
14:03:44 <byorgey> nh2: printf-mauke is more recent and also appears to do what you want
14:04:48 <MostAwesomeDude> Man, who decided to name category composition (.) ?
14:04:59 <MostAwesomeDude> @hoogle (.)
14:04:59 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
14:04:59 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
14:05:00 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
14:05:00 <rwbarton> category theorists?
14:05:25 <MostAwesomeDude> Yeah, but I mean, right next to it is (<<<) and (>>>).
14:05:40 <ciaranm> every associative operation with identity should be named (.)
14:06:05 <monochrom> freedom is the freedom to write 2 . 2 = 4
14:06:07 <geekosaur> ohai Cale :p
14:06:22 <monochrom> in fact, freedom is the freedom to write 2.2 = 4 haha
14:06:26 <Cale> hello
14:06:27 <djahandarie> Hahaha
14:06:31 <dylukes> MostAwesomeDude:
14:06:33 <dylukes> @src fmap
14:06:33 <lambdabot> Source not found. You speak an infinite deal of nothing
14:06:36 <dylukes> @src (.)
14:06:36 <lambdabot> (f . g) x = f (g x)
14:06:37 <lambdabot> NB: In lambdabot,  (.) = fmap
14:06:41 <Phlogistique> btw, I heard about Caleskell/the Cale prelude in there; where can I read about this?
14:06:46 <dylukes> @src fmap doesn't show it anymore :P
14:06:46 <lambdabot> Source not found. That's something I cannot allow to happen.
14:06:47 <Axman6> @remember monochrom in fact, freedom is the freedom to write 2.2 = 4
14:06:48 <lambdabot> It is forever etched in my memory.
14:06:53 <Cale> Phlogistique: there's nothing to read about
14:06:56 <dylukes> @src Prelude.fmap
14:06:56 <lambdabot> Source not found. Maybe you made a typo?
14:06:57 <Cale> I don't have a prelude
14:07:18 <djahandarie> Caleude
14:07:22 <Cale> There's just this little file called L.hs in which lambdabot loads a bunch of things
14:07:26 <Axman6> Phlogistique: it's just what we call Cale's random ways of breaking lambdabot :P
14:07:28 <ciaranm> Cale cannot be expressed in words. it only works in symbols.
14:07:31 <Cale> and there are a few extra definitions in there
14:07:32 <Phlogistique> Cale: oh, OK
14:07:59 <Cale> I import Prelude hiding (.) and a few other things, and redefine them.
14:08:17 <dever> hey all, is there any way to work out the type of a variable?
14:08:28 <dever> similar to :t in ghci
14:08:31 <Axman6> :t 2
14:08:32 <lambdabot> forall t. (Num t) => t
14:08:32 <dylukes> MostAwesomeDude:
14:08:33 <dylukes> > (+1) . [1, 2, 3]
14:08:35 <lambdabot>   [2,3,4]
14:08:36 <dylukes> :)
14:08:51 <Phlogistique> (also, Darcs complains about lambdabot being too old-fashioned)
14:08:52 <rwbarton> :(
14:09:31 * hackagebot haskell-src-exts-qq 0.6.0 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.6.0 (MathieuBoespflug)
14:09:36 <dever> Axman6: aye, but i want to do it in a haskell file
14:09:40 <MostAwesomeDude> dylukes: The problem is in things like lenses, which can't be composed without using the Category composition operators.
14:10:17 <dylukes> MostAwesomeDude: What's the problem with that?
14:10:44 <MostAwesomeDude> dylukes: It's not obvious and took me a couple hours to untangle why everybody else's examples with (.) worked while mine didn't.
14:10:49 <Phlogistique> how would you go about manipulating a data structure which looks like [a, b, a, b, a, b ... a, b, a]?
14:10:59 <ciaranm> Phlogistique: with a pointed stick
14:11:00 <Phlogistique> (where a and b denote types)
14:11:04 <ciaranm> uhm
14:11:12 <dylukes> Phlogistique: You'd have to write that as like
14:11:39 <Enigmagic> (a, (b, (a, (b, (a, b))))
14:11:52 <rwbarton> data AlternatingList a b = Empty | Cons a (AlternatingList b a)
14:12:00 <dylukes> ninja'd
14:12:01 <dylukes> :<
14:12:18 <Phlogistique> thanks
14:12:27 <dylukes> MostAwesomeDude: Just hide prelude's (.) and import the correct one?
14:12:31 <dylukes> er, the category one.
14:14:38 <Cale> Phlogistique: it's somewhat uncommon to run across a data structure which is quite like that though
14:14:50 <Cale> Phlogistique: It's much more common to have [(a,b)]
14:14:52 <MostAwesomeDude> dylukes: Or, less messily, since I *like* Prelude's (.), I can hide the one from Control.Category and use (>>>) and (<<<) instead, which do the *same* thing.
14:15:00 <Cale> or (a,[(b,a)])
14:15:10 <dylukes> Why would you prefer the prelude's (.) :P
14:15:18 <Phlogistique> Cale: yes, it looks hard
14:15:27 <ciaranm> kinky
14:15:35 <MostAwesomeDude> dylukes: Because it works on regular functions and not just Categories, for starters.
14:15:42 <rwbarton> (->) is a Category
14:15:45 <Phlogistique> my usecase is Parsing a language that is like something > something ~> something >~ something ~ something
14:15:46 <dylukes> Regular functions are in a Category.
14:15:47 <dylukes> :P
14:16:02 <Phlogistique> so I have the type for somethings and the type for separators
14:16:14 <MostAwesomeDude> Really. Well, then I learned something today.
14:16:17 <ciaranm> Phlogistique: is it left or right associative?
14:16:48 <Eduard_Munteanu> Well, Category actually describes how you make arrows in that "category"
14:16:53 <Phlogistique> ciaranm: it's associative in every direction
14:17:16 <ciaranm> Phlogistique: then pick one and represent it as a tree
14:17:26 <Phlogistique> (though conceptually, ~>, >~ and ~ bind tighter than >)
14:17:50 <Phlogistique> ciaranm: I will pick left-associative
14:17:52 <Phlogistique> ciaranm: thanks
14:17:58 <morel> what is :@ ?
14:18:09 <Phlogistique> @hoogle :@
14:18:09 <lambdabot> No results found
14:18:13 <rwbarton> a guy with a really long tongue
14:18:15 <Phlogistique> @hayoo :@
14:18:15 <lambdabot> Unknown command, try @list
14:18:19 <byorgey> morel: could be anything
14:18:25 <byorgey> morel: where did you see it?
14:18:39 <morel> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype
14:18:58 <rwbarton> it's defined there
14:19:09 <byorgey> morel: it is just an infix data constructor
14:19:17 <rwbarton> one of the constructors of the Term data type
14:19:21 <dylukes> MostAwesomeDude: Control.Category, Data.Functor, etc are all *abstractions*. As is the rest of EdwardKskell.
14:19:21 <byorgey> data Term = K | S | Term :@ Term
14:19:28 <dylukes> i.e, Semigroup, Bifunctor, etc.
14:19:38 <dylukes> They're useful if used prudently.
14:19:45 <dylukes> Semigroup is a bit silly sometimes :3.
14:20:05 * byorgey disagrees, Semigroup is not silly at all
14:20:07 <dylukes> It just generalized a set with a binary operation.... which tends to apply to a lot of stuff.
14:20:16 <MostAwesomeDude> dylukes: Cool story. So, do you understand how a lens is exactly the coalgebras of the costate comonad?
14:20:25 <monochrom> "data Term = K | S | Term :@ Term" can be rewritten to "data Term = K | S | Term Term Term" :)
14:20:25 <dylukes> I read that article, and no, not exactly.
14:20:37 <dylukes> edwardk spent a while explaining algebras to me, but I don't quite have a handle on it.
14:20:41 <Phlogistique> http://en.wikipedia.org/wiki/Edward_Haskell
14:20:44 <morel> byorgey: i dont get it…
14:20:54 <MostAwesomeDude> See, neither do I. However, I *do* understand how I can use lenses to improve my record access code.
14:21:13 <byorgey> morel: do you know what a data constructor is?
14:21:27 <morel> i think so, yes
14:21:28 <morel> e.g.:
14:21:38 <byorgey> you could imagine defining Term as  data Term = K | S | App Term Term
14:21:49 <byorgey> then it would have data constructors K, S, and App
14:21:51 <morel> data Foo = Constructor Int Float Double | AnotherConstructor
14:22:02 <byorgey> but instead of App it uses :@, which is an *infix* data constructor
14:22:13 <morel> AAAAAH
14:22:14 <morel> okay
14:22:18 <dylukes> MostAwesomeDude: How's Baskerville coming btw?
14:22:29 <morel> byorgey: similar to an operator……
14:22:34 <morel> okay okay, i got it.
14:22:37 <morel> byorgey: ty
14:22:45 <byorgey> yep
14:22:48 <rwbarton> the list "cons" constructor (:) is an infix data constructor too, though it has the other special list syntax associated to it (like [x,y])
14:23:01 <MostAwesomeDude> dylukes: Came to an end when Bravo did.
14:23:06 <morel> rwbarton: wow. cool.
14:23:06 <dylukes> MostAwesomeDude: Bravo's dead?
14:23:14 <MostAwesomeDude> Permanent hiatus. Cash or patch.
14:23:27 <dylukes> Heh.
14:23:29 <MostAwesomeDude> The Baskerville experiment's results were mixed.
14:23:48 <dylukes> Conclusions?
14:23:49 <morel> rwbarton: yea, so, [x,y] is "syntactic sugar" (that's how such things are called, isnt it?)
14:23:53 <rwbarton> yep
14:24:39 <dylukes> morel: [a,b,c] -> (a:b:c:[]) -> a1_roT = \u srt:(0,*bitmap*) [] GHC.Integer.smallInteger 1;
14:24:39 <dylukes> SRT(a1_roT): [GHC.Integer.smallInteger]
14:24:39 <dylukes> a2_roU = \u srt:(0,*bitmap*) [] GHC.Integer.smallInteger 2;
14:24:39 <dylukes> SRT(a2_roU): [GHC.Integer.smallInteger]
14:24:39 <dylukes> a3_roV = \u srt:(0,*bitmap*) [] GHC.Integer.smallInteger 3;
14:24:40 <dylukes> SRT(a3_roV): [GHC.Integer.smallInteger]
14:24:40 <dylukes> a4_roW = NO_CCS :! [a3_roV GHC.Types.[]];
14:24:40 <dylukes> SRT(a4_roW): []
14:24:41 <dylukes> a5_roX = NO_CCS :! [a2_roU a4_roW];
14:24:42 <dylukes> SRT(a5_roX): []
14:24:42 <dylukes> CategoryFun.a = NO_CCS :! [a1_roT a5_roX];
14:24:43 <dylukes> SRT(CategoryFun.a): []
14:24:44 <dylukes> Sugar is good.
14:24:55 <dylukes> [1,2,3] rather...
14:25:51 <MostAwesomeDude> Haskell is terse and fast. However, there aren't any completely integrated ways to construct networking libraries, which makes building networking apps laborious. Also, there's very little documentation for the average library.
14:26:12 <MostAwesomeDude> So I'm not gonna build networking things in Haskell. I am building number-crunchers with it, though.
14:26:36 <dylukes> Have you looked into stream fusion and parallel haskell?
14:27:11 <statusfailed> How do I get lambdabot to simplify lambdas?
14:27:16 <statusfailed> or put into point-free
14:27:31 <MostAwesomeDude> Yep. There's still no good way to transform streams.
14:27:32 <dylukes> @pl f a b = a + b
14:27:32 <lambdabot> f = (+)
14:27:39 <dylukes> statusfailed: see above.
14:27:47 <dylukes> @pl f a b c = a + b + c
14:27:47 <lambdabot> f = ((+) .) . (+)
14:27:47 <statusfailed> @pl \x y -> compare (snd x) (snd y)
14:27:48 <lambdabot> (. snd) . compare . snd
14:27:51 <statusfailed> wat
14:28:00 <MostAwesomeDude> iterIO comes close, but it's very cumbersome to work with and puts massive restrictions on how you can manage transformations of data.
14:28:02 <dylukes> Beware, the code it outputs is not always the most... friendly.
14:28:05 <statusfailed> hahaha
14:28:14 <statusfailed> I don't even see how that works :D
14:28:21 <dylukes> MostAwesomeDude: How so? I'm curious, I haven't really used it in depth.
14:28:34 <dylukes> statusfailed: Add underscores to the missing portions of the sections...
14:28:35 <dylukes> i.e
14:28:43 <dylukes> (_ . snd) . compare . snd
14:28:44 <dylukes> make more sense now?
14:28:55 <dylukes> the variable is _not_ getting inserted there mind you.
14:29:15 <dylukes> ( . snd) is similar (but not equivalent to) \x -> (x . snd)
14:29:23 <MostAwesomeDude> dylukes: In Python, I can straight-up transform incoming data streams into whatever I want. Doing that in Haskell is possible, but very tricky. Moreover, there aren't any tools for doing it symmetrically which actually work; there's no way to invert an attoparsec/parsec parser to create a stream builder.
14:29:28 <ion> Not equivalent to?
14:29:35 <statusfailed> errrr
14:29:37 <statusfailed> let me think abuot this :p
14:29:57 <dylukes> MostAwesomeDude: Insisting on transformation being symmetric automatically is a pretty big restriction :P.
14:30:06 <dylukes> And can you give an example?
14:30:22 <rwbarton> you should be able to write your python code in haskell if nothing else
14:30:30 <dylukes> The last bit is of course true by design.
14:30:36 <dylukes> They're parser libraries :P.
14:30:48 <MostAwesomeDude> Yes, but I've grown used to Construct. :3
14:30:59 <dylukes> Construct is a very specific and limited library overall.
14:31:10 <dylukes> It's for *one* kind of stream that you're used too :P.
14:31:11 <MostAwesomeDude> It is the worst boilerplate to have to write both your parser and builder in different functions.
14:31:26 <dylukes> I don't get it.
14:31:34 <dylukes> They're different, independent routines.
14:32:01 <MostAwesomeDude> Why? You probably want parse . build and build . parse to be reasonably equivalent to id, right?
14:32:05 <rwbarton> for trivial (de)serialization-type tasks you'd like to be able to write both at once, and I'm sure there are some haskell packages that do this
14:32:14 <dylukes> read . show and show . read are equivalent to id.
14:32:16 <ciaranm> (.) being fmap should be in a library somewhere
14:32:17 <dylukes> (or should be)
14:32:35 <MostAwesomeDude> dylukes: Should I write everything against Show and Read then? :3
14:32:41 <dylukes> No, definitely not :P
14:32:49 <dylukes> They don't even handle failure or anything.
14:33:30 <MostAwesomeDude> And yes, I understand that it's restricted, but that's part of the point. If you have a strict schema for your data, especially binary data, than it's not unreasonable to expect fine-grained to-the-bit control, and to write tight code to do it.
14:34:07 <dylukes> If you have a restricted schema, you need to write restricted code, unless it's a popular schema...
14:34:10 <ion> dylukes: How are (. foo) and \x -> x . foo not equivalent?
14:34:15 <dylukes> Generalized libraries have bigger markets.
14:34:36 <dylukes> ion: Has to do with monomorphism restriction.
14:34:45 <ion> Ah, thanks
14:34:52 <dylukes> i.e, lambda binds variable name.
14:34:55 <dylukes> sections don't.
14:35:03 <djahandarie> We don't talk about that around these parts.
14:35:04 <rwbarton> hmm?
14:35:53 <ion> :t (+ 42)
14:35:54 <lambdabot> forall a. (Num a) => a -> a
14:35:55 <ion> :t \x -> x + 42
14:35:56 <lambdabot> forall a. (Num a) => a -> a
14:36:18 <shachaf> dylukes: What?
14:36:23 <shachaf> That's not what the monomorphism restriction is.
14:36:42 <dylukes> No, I know...
14:36:46 <dylukes> but it ends up being relevant.
14:36:55 <dylukes> I ran into this a while ago... like 4 or 5 months.
14:36:55 <rwbarton> in what situation?
14:37:10 <dylukes> Let me try to find the example I saw...
14:37:21 <shachaf> f x = x + 42 is different from f = (+ 42), if that's what you mean.
14:37:32 <dylukes> That's not it.
14:37:34 <rwbarton> it is?
14:37:40 <rwbarton> oh yeah
14:37:43 <dylukes> There was a distinction between f = \x + 42 and f = (+ 42)
14:38:28 <dylukes> here, for example...
14:38:36 <rwbarton> maybe having to do with higher-order universal quantifiers?
14:39:11 <shachaf> dylukes: The former is a syntax error.
14:39:12 <ion> @type let f = \x -> x + 42 in f
14:39:13 <lambdabot> forall a. (Num a) => a -> a
14:39:16 <shachaf> Maybe that's the ditinction? :-)
14:39:28 <ion> @type let f x = x + 42 in f
14:39:29 <dylukes> \x -> x + 42*
14:39:29 <lambdabot> forall a. (Num a) => a -> a
14:39:32 <shachaf> Ah, Muphry's Law.
14:39:38 <dylukes> if you compile these to STG...
14:39:38 <dylukes> a = (+1)
14:39:39 <dylukes> 	b = (\x -> x + 1)
14:39:55 <dylukes> you get...
14:40:05 <dylukes> https://gist.github.com/1562784
14:40:10 <rwbarton> different sharing behavior?
14:40:14 <dylukes> mm.
14:40:54 <shachaf> http://www.haskell.org/onlinereport/exps.html#sect3.5
14:41:14 <dylukes> I believe there was another distinction anyhow
14:41:14 <rwbarton> I know GHC tends to compile (a+) to (+) a rather than (\x -> a + x)
14:41:36 <rwbarton> which is technically difference when (+) = undefined
14:41:52 <rwbarton> (by "tends" I mean it might depend on optimization level and language extensions)
14:41:59 <dylukes> shachaf: Huh, I guess you're right.
14:42:13 <shachaf> rwbarton: There's also a type difference.
14:42:24 <shachaf> Which was fixed with the introduction of -XPostfixOperators
14:42:32 <rwbarton> yes, that's one of the options that affects the translation
14:42:58 <rwbarton> or something like that. I think without that option, GHC still uses the first translation, just at a restricted type
14:43:03 <rwbarton> last I tested, anyways
14:43:07 <shachaf> I wish there was a one-page version of the Report.
14:43:22 <shachaf> So you could search it with ^F in your browser and so on.
14:44:32 <rwbarton> :t let f :: (forall a. a) -> b -> c; f = undefined; g = (`f` undefined); h = \x -> x `f` undefined in (g, h)
14:44:33 <lambdabot>     Inferred type is less polymorphic than expected
14:44:33 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:44:33 <lambdabot>         x :: a (bound at <interactive>:1:75)
14:44:53 <rwbarton> :t let f :: (forall a. a) -> b -> c; f = undefined; g = (`f` undefined) in g
14:44:54 <lambdabot> forall c. (forall a. a) -> c
14:45:01 <rwbarton> :t let f :: (forall a. a) -> b -> c; f = undefined; h = \x -> x `f` undefined in g
14:45:01 <dylukes> http://nprheygirl.tumblr.com/
14:45:02 <lambdabot>     Inferred type is less polymorphic than expected
14:45:02 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:45:02 <lambdabot>         x :: a (bound at <interactive>:1:54)
14:45:02 <dylukes> Oh man.
14:45:04 <rwbarton> :t let f :: (forall a. a) -> b -> c; f = undefined; h = \x -> x `f` undefined in h
14:45:05 <lambdabot>     Inferred type is less polymorphic than expected
14:45:05 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:45:05 <lambdabot>         x :: a (bound at <interactive>:1:54)
14:45:07 <dylukes> er, #haskell-blah. My bad.
14:45:21 <rwbarton> not sure whether this really counts as an interesting example
14:45:51 <rwbarton> :t let f :: (forall a. a) -> b -> c; f = undefined; h :: (forall a. a) -> c; h = \x -> x `f` undefined in h
14:45:52 <lambdabot> forall c. (forall a. a) -> c
14:47:21 <rwbarton> > let g = (+ 1) in (g (3 :: Int), g (5 :: Double))
14:47:22 <lambdabot>   (4,6.0)
14:47:24 <dylukes> And again, as usual, #haskell has devolved into a series of type signatures.
14:47:30 <rwbarton> > let g = \x -> x + 1 in (g (3 :: Int), g (5 :: Double))
14:47:31 <lambdabot>   (4,6.0)
14:48:31 <rwbarton> what version of GHC is lambdabot?
14:48:49 <dylukes> Cale7?
14:48:53 <dylukes> Cale6~?
14:49:01 <dylukes> 7.Cale*
14:50:42 <mdmkolbe> Is there a way for a quasiquoter to determine what DynFlags are in effect? (e.g. RankNTypes, etc.)
14:52:15 <tgeeky> mdmkolbe: good question
14:52:30 <monochrom> likely no
14:54:32 * hackagebot iteratee 0.8.7.6 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.6 (JohnLato)
15:06:59 <Phlogistique> Haddock is supposed to work with Litterate Haskell
15:07:31 <Phlogistique> but I don't really see what the litterate haskell would amount to then, because Haddock syntax's would conflict with the markup syntax
15:07:34 <Phlogistique> wouldn't it?
15:07:47 <Phlogistique> does anyone use Haddock _and_ litterate Haskell?
15:08:36 <Saizan> you put the haddock comments in the code blocks
15:08:51 <Saizan> e.g. > -- | blah blah
15:09:59 <byorgey> text in a .lhs file does not count as comments, it is simply removed in a preprocessing step
15:10:03 <byorgey> so Haddock never gets to see it
15:10:47 <Phlogistique> OK
15:11:02 <Phlogistique> thanks
15:16:36 <Twey> I'd like to learn a systems programming language… one of the new ones, like ATS or Deca or BitC.  From a Haskeller's perspective, which is the least horrible?  :þ
15:16:44 <rostayob> how can i refer to type variables in the instance head in the body of the class instance?
15:17:56 <Eduard_Munteanu> Twey: how about C? :)
15:17:56 <Saizan> ScopedTypeVariables for a start, then i wonder if you need something like instance forall a. C (Foo a) where .. or not
15:18:07 <rostayob> Saizan: I tried that, but it doesn't work
15:18:11 <rostayob> (the explicit quantification)
15:18:31 <Saizan> and no quantification?
15:18:35 <Twey> Eduard_Munteanu: I was asking for the *least* horrible :þ
15:18:46 <rostayob> Saizan: no quantification doesn't work either
15:19:20 <byorgey> rostayob: referring to type variables in the instance head in the body of the class instance does not make sense
15:19:33 <byorgey> rostayob: those type variables are basically ignored, they are just placeholders
15:20:01 <byorgey> er, wait, I think I am confused
15:20:07 <dylukes> MostAwesomeDude: what're you working on now?
15:20:10 <hpaste> rostayob pasted “byorgey” at http://hpaste.org/56092
15:20:36 <Saizan> rostayob: it works for me
15:20:38 <rostayob> while they are ignored when searching for the instance it still makes sense to me to write code like that
15:20:56 <Eduard_Munteanu> Twey: in a sense, maybe systems programming is "horrible". So you at least want to start with something that's at least a bit popular.
15:21:08 <byorgey> rostayob: why do you need that annotation on formatTok?
15:21:10 <Eduard_Munteanu> And AFAIH, ATS is quite a bit horrible :)
15:21:20 <Saizan> rostayob: remove the Token tok t => part
15:21:38 <Eduard_Munteanu> (and perhaps unsuitable for some applications C is suitable for? :/)
15:21:40 <Saizan> rostayob: and add {-# LANGUAGE ScopedTypeVariables #-}
15:21:46 <Twey> Eduard_Munteanu: I know C already
15:21:50 <Eduard_Munteanu> Ah.
15:21:53 <rostayob> Saizan: yeah, Ambiguous type variable `tok0' in the constraint:
15:21:55 <rostayob>       (Token tok0 t) arising from a use of `formatTok
15:22:16 <rostayob> it doesn't know with "formatTok" to pick
15:22:29 <rostayob> which seems strange since there is a fundep
15:22:30 <Twey> Eduard_Munteanu: I don't like how I have to constantly re-implement things.  I'd like something that let me re-use my code a bit more.  And a nicer type-system would help a lot, too.
15:22:51 <byorgey> rostayob: maybe you want the fundep to go the other way?
15:22:58 <Eduard_Munteanu> Twey: ATS might be an interesting challenge then, and different enough. Otherwise, some safe C dialect, but not so much fun I guess.
15:23:03 <byorgey> rostayob: now that I look at it more closely, that Token class is unusable
15:23:04 <rostayob> byorgey: not really
15:23:19 <rostayob> the 'tok' is just a placeholder in the bigger type
15:23:22 <byorgey> rostayob: GHC will *never* know what 'tok' to pick, because formatTok only takes a 't' argument
15:23:35 <byorgey> and 't' does not determine 'tok'
15:23:48 <rostayob> byorgey: well that's why I tried to provide 'tok' explicitely
15:24:03 <Twey> Eduard_Munteanu: *nod* I was considering ATS, but I've been seeing talk of Deca all over the place, & wondered if it was worth a go instead
15:24:07 <byorgey> rostayob: there's no way to do that
15:24:13 <rostayob> byorgey: why is that?
15:24:29 <Saizan> yeah, i didn't spot the type of formatTok, sorry
15:25:28 <rostayob> I mean i understand the problem, but I thought that providing the 'tok' explicitly would make GHC pick the right instance
15:25:35 <byorgey> rostayob: there's no way to explicitly specify which dictionary you want to use
15:26:00 <rostayob> byorgey: why is that?
15:26:23 <Saizan> you're not providing tok explicitly, because that type annotation still doesn't fix the tok used by formatTok in any way, since there's no unification on contexts
15:26:27 <Eduard_Munteanu> Twey: I've also stumbled upon this strange (and ugly) thingy, not sure what to say about it: http://www.fing.edu.uy/~jcabezas/c5/c5book/index.html
15:26:41 <rostayob> Saizan: oh, right
15:26:44 <byorgey> rostayob: yeah, that type annotation you gave on formatTok doesn't mean what you want it to mean anyway
15:26:47 <rostayob> i always forget about that
15:26:52 <Eduard_Munteanu> Some sort of semi-dependently-typed C dialect :)
15:27:06 <rostayob> byorgey: why not?
15:27:13 <byorgey> rostayob: because of what Saizan said.
15:27:28 <monochrom> ATS is very very verbose. its proof language is unreadable and doesn't look like a proof language.
15:27:29 <rostayob> ah, yes
15:27:50 <rostayob> it would mean what i want it to mean if there was unification on contexts :)
15:27:52 <byorgey> rostayob: dictionary passing is entirely implicit.  There's simply no way to specify which dictionary you want.
15:28:12 <byorgey> the only way to specify a dictionary is to specify a type which determines the dictionary.
15:28:17 <Eduard_Munteanu> monochrom: how would it compare to Coq's internal language (that is, stuff underlying tactics)?
15:28:19 <Saizan> it just sees Token tok t as another available Token instance, but since it's not opportunistic it won't pick tok from there
15:28:33 <Eduard_Munteanu> I'm asking because the ML-ish aspects seem to lead to some ugliness :)
15:28:40 <rostayob> why is it that anyway? that would allow so much more espressivity
15:28:56 <rwbarton> elaborate on "that"
15:28:58 <rostayob> is it a problem for a language like haskell to implement that?
15:29:07 <rostayob> rwbarton: no unification on instances contexts
15:29:19 <rwbarton> well that would break every program that uses type classes, no?
15:29:23 <rostayob> why?
15:29:42 <rostayob> right now the first matching instance is pick
15:29:47 <rostayob> if there are type variables
15:29:55 <Saizan> rostayob: you're mixing two separate things
15:30:04 <rwbarton> I right   return 3 :: Maybe Int  and now it needs to unify "Maybe Int" with "(Monad m, Num a) => m a"
15:30:14 <rwbarton> but oops, the LHS has no context, unification failure
15:30:27 <Saizan> though the underlying rationale is probably the same: canonicity of instances in an open context
15:30:33 <Saizan> *open world
15:31:02 <rostayob> rwbarton: well that would unify
15:31:22 <rostayob> maybe is an instance of Monad and Int of Num
15:31:22 <rwbarton> now it sounds like you're just making up ad-hoc rules
15:32:50 <rostayob> why? i see it as prolog predicates more or less, Monad(Maybe, a) :- Monad(a), Num(Int), Monad(Maybe, Int) and Num(Int) are OK
15:33:06 <rostayob> no sorry
15:33:17 <rostayob> the thing about Monad doesn't make sense
15:33:38 <rostayob> just Monad(Maybe, A)
15:33:41 <rwbarton> what Saizan is saying is --
15:33:55 <rwbarton> in your example formatTok :: Token tok t => t -> String
15:34:20 <rwbarton> elsewhere you write formatTok :: Token a b => b -> String -- let's say
15:34:27 <rwbarton> and you want to conclude that tok = a and t = b
15:34:54 <rwbarton> yes?
15:34:57 <rostayob> yes
15:35:18 <rwbarton> so what rules would cause you to conclude that
15:36:03 <rwbarton> while still allowing me to unify Maybe Int with (Monad m, Num a) => m a
15:36:49 <rwbarton> personally I can't think how that would work
15:37:14 <rostayob> I am thinking of instances as predicates where Typeclass(type, variables) :- context.
15:37:19 <Eduard_Munteanu> Is it ok to say Maybe Int <: (Monad m, Num a) => m a in Haskell's context?
15:37:59 <Saizan> the other way around, if anything
15:38:09 <rostayob> rwbarton: so it would work the same way, if you have are trying to verify Token(a, b) it'd look for predicates that match that
15:38:23 <Eduard_Munteanu> Erm, right.
15:38:49 <rwbarton> rostayob: but satisfying a type class in reality is not just a predicate
15:38:56 <rwbarton> there is some data associated to the instance
15:39:03 <rostayob> rwbarton: yeah, my question is "could it work that way"
15:39:04 <Saizan> rostayob: 1) prolog assumes a closed world, haskell can't because of separate compilation or just modularity 2) we also pretend unique solutions
15:39:10 <Eduard_Munteanu> Saizan: yeah, I wonder if I can abuse subtyping language to speak about unification.
15:39:24 <rwbarton> we need unique solutions because we need to get the member values out
15:39:29 <rostayob> Saizan: well ofc when we find multiple solutions we have an overlapping instance and the compiler complains
15:39:54 <rostayob> rwbarton: I don't follow you, what are "member values"?
15:39:54 <rwbarton> right, and here you have potentially overlapping instances
15:40:07 <rwbarton> formatTok in this case
15:40:10 <rwbarton> the members of the type class
15:40:24 <Saizan> also, suppose foo :: (C a, C b) => (); then what foo :: (C X, C Y) => () would even mean?
15:40:50 <rostayob> rwbarton: but if type classes are predicates then you just need to check that the type variables are in scope
15:40:57 <Saizan> remembering that (C a, C b) is the same context as (C b, C a) currently :)
15:40:58 <rwbarton> huh?
15:41:09 <rostayob> the type variables of the member values
15:41:23 <rostayob> Saizan: nothing, just some type level computation to find an instance
15:41:24 <rwbarton> I think my point wasn't clear
15:42:16 <rostayob> Saizan: but i don't see how that is a problem
15:42:40 <rwbarton> rostayob: suppose I write instance Token EvilInteger Integer where formatTok = reverse . show
15:42:58 <rwbarton> and now I try to use format with t = Integer
15:43:17 <rostayob> rwbarton: yeah, you'd find multiple solutions and the compiler would complain
15:43:22 <Saizan> rostayob: i mean that given foo :: (C a, C b) => (), if you try to annotate it using like this foo :: (C X, C Y) => (), should X be unified with a or with b? and Y?
15:43:32 <rostayob> with tok = TokenInteger; EvilInteger
15:43:35 <rwbarton> right
15:43:39 <rwbarton> that is why you get an error here
15:43:55 <rostayob> rwbarton: no, that the error I get comes before this problem
15:44:02 <rostayob> there are no overlapping instances in my code
15:44:24 <Saizan> it's preemptive
15:44:28 <rwbarton> but potentially there could be
15:44:45 <rwbarton> suppose there is one, OK
15:44:52 <rostayob> Saizan: with both, that is undecidable as well
15:45:03 <rwbarton> then what should format actually do
15:45:05 <rostayob> whenever you have multiple solution the compiler complains
15:45:31 <rwbarton> this is a general principle of the type class system, it does not work that way
15:45:40 <rwbarton> adding instances cannot cause your program to break
15:45:43 <Saizan> the point is that we want instance resolution to be robust to introducing more instances
15:45:53 <rostayob> yes I understand the principles behind this
15:46:06 <rwbarton> then that's your answer
15:46:06 <rostayob> and yes you could break programs adding instances
15:46:27 <rostayob> but my question was "is it feasible to code a language extension that does that?"
15:46:35 <Saizan> sure
15:46:37 <rostayob> while of course introducing all the possible breakage
15:46:39 <rostayob> ok
15:46:57 <rostayob> because rwbarton said "then no program that uses type classes would work", which surprised me
15:47:25 <rwbarton> well at that point I thought you were suggesting a specific way to do it
15:47:37 <Saizan> well, i meant that it could be implemented, not that it'd be usable :)
15:47:37 <rwbarton> namely to treat contexts as part of the type during unification
15:47:59 <rostayob> Saizan: I think it would be pretty usable
15:48:09 <elarnon> is there any way to inline some definitions in happy (like %inline does in menhir (in ocaml)) ?
15:48:38 <rostayob> Saizan: with a bit of discipline i'd have great fun with a language like that
15:48:46 <Saizan> what is sensible and is probably going to be implemented in GHC sooner or later, is a way to explicitly provide types
15:48:53 <rostayob> yeah
15:48:58 <Saizan> rather than making instance resolution more opportunistic
15:49:09 <rostayob> with "types" you mean instances?
15:49:13 <Saizan> no
15:49:17 <rwbarton> type arguments to polymorphic values
15:49:25 <rostayob> ok
15:49:38 <rostayob> yeah that would be nice
15:49:50 <rostayob> so you could use nicely overlapping instances
15:49:54 <rwbarton> it's tricky though because currently forall a b. a -> b is the same as forall b a. a -> b
15:50:14 <Saizan> no, i don't think it'd help with overlapping instances
15:50:33 <rostayob> ah right
15:50:52 <Saizan> and those are even the same as forall a b c. a -> b, etc..
15:50:57 <rwbarton> it'd help when you want to have type class members where the parameters of the type class are unreachable from the type of the member
15:51:23 <Saizan> it'd solve your problem with formatTok here
15:51:25 <rwbarton> which currently you work around with things like adding an unused parameter, or a Label newtype
15:51:29 <rwbarton> yep
15:51:29 <rostayob> Saizan: the thing is that in system-f explicit type passing is needed because types are undecidable
15:51:50 <rostayob> but type annotations make up for that in haskell, don't they?
15:52:08 <Saizan> not enough, as you've seen
15:52:33 <rostayob> oh right, you could pass tok there
15:52:51 <rostayob> mhm. i don't know, i think i'd be happier with riched type classes
15:53:34 <rwbarton> anyways, if you don't want to allow Token instances with the same t but different tok, then... use another functional dependency?
15:53:44 <rostayob> rwbarton: i want to allow that
15:54:20 <Saizan> add a phantom argument to formatTok then
15:54:32 <rostayob> Saizan: that's what i did a few minutes ago :P
15:54:39 <rostayob> i've got undefineds all over the place now!
15:55:58 <Saizan> data Proxy a = Proxy is more classy
15:56:29 <Saizan> or newtype Tagged t a = Tagged a
15:57:03 <rostayob> not if emacs renders undefined as _|_1
15:57:07 <rostayob> *_|_!
15:57:10 <alpounet__> there's a package for that
15:57:15 <alpounet__> edward kmett wrote one
15:57:54 <rostayob> alpounet__: ?
15:58:36 <alpounet__> http://hackage.haskell.org/package/tagged-0.2.3.1
16:00:41 <rostayob> oh
16:02:48 <Phlogistique> http://www.haskell.org/haskellwiki/Good_Reasons_To_Give_Some_Thought_To_Acquiring_Lingerie_To_Improve_Your_Current_Marriage goddamn it, I spent more than several seconds trying to understand the monad metaphor
16:04:37 <rostayob> Phlogistique: "more than several seconds" doesn't sound like a long time.
16:05:05 <rostayob> @pl \x -> (:) t (arg x)
16:05:06 <lambdabot> (t :) . arg
16:05:11 <Phlogistique> rostayob: it is a long time when you're reading spam about lingerie on Haskell wiki.
16:06:09 <rostayob> ok. if I have (a :: * -> *) and (b :: * -> *) and I want to express the type-level function \t -> a (b t), can I do it without a type synonym/newtype?
16:07:20 <c_wraith> You can't have type-level functions in haskell at all.
16:07:39 <c_wraith> A newtype is a close fake
16:07:52 <rostayob> c_wraith: you can partially apply type constructors, that's a type level function to me
16:08:10 <c_wraith> rostayob: right, should have said "non-constructor"
16:08:39 <rostayob> c_wraith: so the answer is "no, you can't do that"?
16:09:04 <rostayob> because it's frustrating that you can partially apply type constructors but not a really simple composition like that one
16:09:12 <c_wraith> that is the answer
16:09:21 <rwbarton> some context might be helpful
16:09:28 <c_wraith> and it's because arbitrary type-level functions defeat type inference
16:10:04 <c_wraith> newtypes allow type inference to work because they throw constructors in
16:10:08 <rostayob> c_wraith: yeah, but maybe an composition type operator wouldn't... i'm in a type mood tonight eheh
16:11:09 <rostayob> rwbarton: i was fiddling with code to write a better printf
16:11:15 <rostayob> something like
16:11:38 <rostayob> "blah" num "foo" str :: Int -> String -> String
16:12:00 <rostayob> where 'num' and 'str' are heavily overloaded functions lol
16:14:27 <rwbarton> rostayob, you can do nearly this without type classes
16:14:50 <rostayob> rwbarton: really? how "nearly"?
16:14:57 <rostayob> i want it type safe not like the existing printf
16:15:14 <rwbarton> you can write   run ("blah" . num . "foo" . str) :: Int -> String -> String
16:15:23 <rwbarton> using OverloadedStrings for the string literals
16:15:45 <rostayob> with OverloadedStrings you can do what I said as well
16:15:54 <rostayob> which is nicer imho
16:15:56 <rwbarton> yes but I'm not using any other type classes
16:15:59 <rostayob> yeah
16:16:01 <rostayob> true
16:16:02 <rwbarton> it is composable
16:16:35 <rostayob> i wanted to write it without OverloadedStrings
16:16:43 <rostayob> mostly to see if it's possible at all
16:17:15 <rwbarton> surely  "blah" num "foo" str  cannot be valid without OverloadedStrings
16:18:01 <Enigmagic> @hoogle IsString
16:18:01 <lambdabot> Data.String class IsString a
16:18:02 <lambdabot> GHC.Exts class IsString a
16:18:21 <rostayob> rwbarton: not even turning on the right language extensions? it's probably a trick similar to Oleg polyvariadic functions but with a bit more scaffolding
16:18:41 <rwbarton> "blah" :: [Char]
16:18:47 <rwbarton> how can you apply that to something
16:18:52 <rostayob> oh sorry
16:18:53 <rostayob> i meant
16:19:18 <rostayob> "blah" `num` "foo" `str` some_marker :: Int -> String -> String
16:19:23 <rwbarton> oh
16:20:15 <rostayob> mah whatever. i'll just use overloaded strings.
16:24:02 <rostayob> *my* language will have proper type classes :P
16:25:26 <gregATio> haskell mode ofc is that the standard haskell mode found @ http://projects.haskell.org/haskellmode-emacs/ ?
16:26:26 <rostayob> gregATio: http://projects.haskell.org/haskellmode-emacs/
16:26:46 <Phlogistique> do "constructor synonyms" exist?
16:26:49 <gregATio> thanks
16:26:58 <rostayob> Phlogistique: constructor synonyms?
16:27:02 <gregATio> hmm need to uninstall my other haskell mode :-\
16:27:06 <rostayob> data constructor or type constructor?
16:27:11 <rostayob> gregATio: which haskell mode?
16:27:33 <rostayob> anyway, data constructor are just functions
16:27:41 <Phlogistique> rostayob: for exemple I want a type synonym to Maybe, but I would also like to rename Just and Nothing to specific vocabulary relative to their use in my program
16:28:01 <rostayob> Phlogistique: type Foo a = Maybe a; bar = Just; baz = Nothing;
16:28:13 <Phlogistique> indeed; thanks
16:28:32 <gregATio> actually i think its the same one.... (I'm tired)
16:28:43 <rostayob> note that you can't partially apply Foo. You might want type Foo = Maybe in some situations.
16:29:38 <gregATio> anyone have any thoughts on Learn you a Haskell? I dont actually like it very much as a beginner
16:30:03 <rostayob> gregATio: i liked it a lot as a not-so-beginner. as a beginner i devoured "Programming in Haskell"
16:30:13 <rostayob> and with beginner i mean programming beginner.
16:30:42 <rostayob> LYAH is a bit more advanced
16:30:55 <rostayob> it tells you things that programming in haskell doesn't bother covering
16:31:12 <rostayob> you can actually stand for yourself in the haskell world after LYAH, not so much after programming in haskell
16:31:20 <rostayob> but it's a great introduction
16:31:22 <hughfdjackson> gregATio: its a bit ..spread out
16:31:27 <rostayob> if you don't like LYAH try it
16:31:37 <hughfdjackson> i mean i get tired reading through the (admitadly funny) parts
16:31:49 <hughfdjackson> am preferring real world haskell atm
16:32:08 <rostayob> real world haskell is what the title says, real world cases. it's not an introduction to Haskell
16:32:10 <gregATio> yes Ive started reading real world haskell
16:32:23 <gregATio> i trudged through LYAH
16:32:35 <gregATio> and it was cute, but not very coherent for me
16:33:08 <gregATio> Real world haskell is long, but really good, trudging through that
16:33:16 <c_wraith> If it wasn't very coherent, you probably need to go back to the beginning.  I haven't found any better intro to haskell.
16:33:40 <gregATio> LYAH didnt even mention thunks
16:33:56 <chemistree> gregATio: have you tried "Learn you a haskell for great good"?
16:34:03 <gregATio> lol
16:34:11 <chemistree> ....
16:34:20 <djahandarie> chemistree, expand out the acronym LYAH ;p
16:34:23 <gregATio> yes thats the book im talking about
16:34:23 <c_wraith> thunks are just an implementation detail.  they're not part of the language
16:35:04 <chemistree> LYAH... thanks for the heads up. haha
16:35:13 <gregATio> I really liked his advanced use of List Monads as non deterministic values
16:35:15 <c_wraith> How the language is implemented is interesting, but if you pay attention to that, you miss how to *use* the language.
16:35:16 <chemistree> I am trying out that one at the moment
16:36:04 <gregATio> hmmm well i'll be on here a lot , anytime you want to discuss chapters im all ears
16:36:06 <Rotaerk> gregATio, isn't that mechanism used to implement channels
16:36:06 <chemistree> do you know of any PDF versions of either LYAH or RWH
16:36:08 <chemistree> ?
16:36:14 <gregATio> Ive read all but the last chapter
16:36:14 <Rotaerk> for mailbox processors
16:36:45 <gregATio> chemistree: get the latest version of adobe acrobat proffessional
16:36:54 <chemistree> I dont have internet access all the time, and a PDF version would be nice
16:37:13 <gregATio> it allows you to rip straight from a website to pdf, its pretty good
16:37:33 <chemistree> !!!! thanks gregATio
16:37:39 <chemistree> thats awesome
16:38:15 <znutar_> you can get ebook versions of both for money, also
16:38:16 <gregATio> yeah i've made quite a few of my own ebooks that way ;-)
16:38:43 <rwbarton> rostayob: here's a way to do this without type classes http://hpaste.org/56094
16:40:43 <rostayob> rwbarton: oh, cool
16:47:29 <hughfdjackson> belatedly, on the note of implementation: i've been watching a few SPJ talks, and the fact that he talks about implementation helps me understand a lot more
16:47:53 <djahandarie> It could also just be that he's awesome.
16:48:01 <hughfdjackson> :P he is
16:48:26 <gregATio> theres a brilliant blog by yang which is usually too high level for me, but he goes into a lot of detail
16:48:45 <gregATio> i think if you google "grinch" and "haskell" you'll find it
16:49:30 <gregATio> but i agree you gotta love simon, he wrote an very interesting paper on how to write financial contracts which i hope to study better once i level-up my haskell
16:49:38 <chemistree> gregATio: is there a way to rip web page into pdf without paying for adobe acrobat proffessional...?
16:49:45 <monochrom> "how the grinch stole haskell during christmas" :)
16:49:47 <chemistree> :/
16:50:11 <gregATio> im afraid not, perhaps just by the book, - I did
16:50:26 <rwbarton> ... print to pdf?
16:50:42 <rwbarton> does windows still lack this or something
16:50:43 <hpaste> nh2 pasted “printf-like 2” at http://hpaste.org/56095
16:51:13 <monochrom> firefox seems to be able to do that regardless of OS
16:51:27 <gregATio> wont really work because its hyperlinked the chapters
16:51:27 <chemistree> good point, worth it
16:51:35 <chemistree> hard copy better too
16:59:22 <ddarius> gregATio: There are no doubt tons of tools written to do that.
17:09:45 <kwos> hello
17:10:33 <kwos> can I write a function Dynamic -> String that converts to string any dynamic value?
17:12:11 <c_wraith> kwos: no
17:12:24 <c_wraith> kwos: well, sure, but not by examining the dynamic value
17:12:45 <c_wraith> kwos: all you know for sure that you can examine is the TypeRep
17:12:46 <DanBurton> dumbConvert = const "any dynamic value"; dumbConvert :: Dynamic -> String
17:12:48 <rwbarton> you could list a bunch of types you want to handle, and the conversion for each to a string
17:13:02 <c_wraith> :t typeOf ()
17:13:02 <lambdabot> TypeRep
17:13:18 <c_wraith> I wonder if you actually can extract the TypeRep from a Dynamic.
17:13:59 <kwos> I don't think you can
17:14:14 <rwbarton> isn't that dynTypeRep
17:14:16 <c_wraith> doesn't appear you can
17:14:18 <rwbarton> @hoogle dynTypeRep
17:14:18 <lambdabot> Data.Dynamic dynTypeRep :: Dynamic -> TypeRep
17:14:27 <c_wraith> oh, you're right
17:14:32 <c_wraith> hidden at the very bottom of the page
17:15:22 <c_wraith> So, you can do some stuff for "common" types to check to see if it's any of them...  Otherwise just show some sort of message about the TypeRep
17:15:31 <kwos> oh, so extract the TypeRep and then do a case match with appropriate annotations?
17:15:42 <c_wraith> no, you can't case match on the TypeRep
17:15:50 <kwos> my universe of types that can become Dynamic is limited
17:15:55 <c_wraith> though you can do equality comparisons on it
17:15:56 <rwbarton> I was thinking more along the lines of fromDynamic
17:16:06 <c_wraith> but yes, fromDynamic is the cleaner way
17:17:06 <kwos> but fromDynamic would require a type annotation
17:17:25 <c_wraith> only if you don't supply it with context
17:17:37 <ddarius> kwos: Are you sure just using an algebraic data type wouldn't be simpler?
17:17:53 <c_wraith> and it really does sound like an ADT would be simpler
17:17:54 <kwos> ddarius: perhaps it will
17:18:07 <c_wraith> Data.Dynamic is bizarre to actually need
17:18:12 <kwos> I hoped that Data.Dynamic may ease some pain
17:18:16 <kwos> but it actually creates more
17:19:25 <c_wraith> It's really *only* for cases when you can prove something is well-typed, but the type checker can't
17:20:01 <c_wraith> If you want to test against the type with a limited universe, you're almost certainly better off with an ADT
17:20:19 <kwos> ok, cool
17:20:26 <kwos> thanks!
17:21:02 <Nisstyre> has anyone written a Haskell view server for CouchDB?
17:21:17 <Nisstyre> oh, nevermind http://hackage.haskell.org/packages/archive/couch-hs/0.1.2/doc/html/Database-CouchDB-ViewServer.html
17:21:22 <Nisstyre> found it :D
17:23:51 * DanBurton wonders when one can prove something is well-typed, but the GHC type checker can't.
17:26:09 <c_wraith> DanBurton: it's rare.  it happens sometimes
17:27:18 <aristid> well-typed in the haskell sense?
17:27:47 <nexx> MrN!
17:29:25 <Jafet> DanBurton: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:unsafeCoerce-35-
17:32:51 <dmwit> DanBurton: It's certainly very easy to write a program that never crashes, but is not well-typed. (Though I admit that is a significantly different problem.)
17:33:06 <DanBurton> indeed
17:33:12 <hpc> dmwit: main = fix fix -- :D
17:34:08 <aristid> :t fix fix
17:34:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
17:34:09 <lambdabot>     Probable cause: `fix' is applied to too many arguments
17:34:09 <lambdabot>     In the first argument of `fix', namely `fix'
17:34:19 <Jafet> @quote ddarius unsafeCoerce
17:34:19 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
17:34:31 <hpc> hehe
17:34:44 <aristid> > unsafeCoerce (Just ()) :: Bool
17:34:45 <lambdabot>   Not in scope: `unsafeCoerce'
17:34:50 <hpc> intToInteger = unsafeCoerce
17:34:51 <aristid> too bad :D
17:34:57 <DanBurton> don't break lambdabot :)
17:35:00 <hpc> @let unsafeCoerce = fix id
17:35:01 <lambdabot>  Defined.
17:35:08 <hpc> :t unsafeCoerce -- there you go
17:35:09 <lambdabot> forall a. a
17:35:12 <hpc> argh
17:35:15 <hpc> @undefine
17:35:23 <DanBurton> lol
17:35:24 <hpc> @let unsafeCoerce = fix ($) -- better
17:35:24 <lambdabot>  Defined.
17:35:28 <hpc> :t unsafeCoerce -- there you go
17:35:29 <lambdabot> forall a b. a -> b
17:35:30 <DanBurton> nope
17:35:35 <DanBurton> wait what
17:35:42 <mokus> > fix unsafeCoerce
17:35:45 <aristid> hpc: well...
17:35:47 <lambdabot>   mueval: ExitFailure 1
17:35:48 <lambdabot>  mueval: Prelude.undefined
17:36:05 <DanBurton> what exactly is `fix ($)`?
17:36:26 <mokus> ($) = id, with a more specific type
17:36:26 <aristid> DanBurton: bottom
17:36:39 <mokus> so it's the same as fix id
17:36:57 <Jafet> @hoogle forever
17:36:57 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
17:36:58 <hpc> aristid: i have a remarkable proof of termination, which this line is too small to contain
17:37:00 <aristid> fix id is one of the shortest ways (when counting keystrokes) to get bottom
17:37:19 <hpc> 1/0 is the shortest
17:37:26 <Jafet> > 1/0
17:37:27 <lambdabot>   Infinity
17:37:32 <hpc> crap
17:37:34 <aristid> hpc: :P
17:37:43 <aristid> > 1 `div` 0
17:37:44 <lambdabot>   *Exception: divide by zero
17:37:44 <hpc> Double doesn't exist
17:37:50 <Jafet> main = main
17:38:07 <mokus> > 1%0
17:38:07 <lambdabot>   *Exception: Ratio.%: zero denominator
17:38:15 <hpc> Jafet: stil needs the let-in to make an expression
17:38:16 <aristid> > map length ["fix id", "1`div`0"]
17:38:17 <lambdabot>   [6,7]
17:38:18 <hpc> mokus wins
17:38:28 <aristid> mokus: heh
17:38:41 <aristid> hpc: mokus has a much more restricted type tho
17:38:59 <aristid> fix id is uncontested for everything that is not Ratio ;)
17:39:08 <mokus> outside lambdabot it takes more too - gotta import Data.Ratio
17:39:29 <mokus> of course, you have to import fix too
17:39:39 <mokus> in a source file 'x=x' works
17:39:41 <aristid> mokus: i don't think so
17:39:51 <aristid> @hoogle fix
17:39:51 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
17:39:51 <lambdabot> Data.Fixed module Data.Fixed
17:39:51 <lambdabot> Data.Function fix :: (a -> a) -> a
17:40:12 <mokus> aristid: my point is neither is in Prelude
17:40:14 <aristid> ok sorry, you are right.
17:40:20 <Jafet> caleskell is the standard golf course.
17:40:25 <aristid> mokus: i was pretty sure it WAS in the prelude :)
17:40:29 <mokus> ah
17:40:31 <hpc> @remember Jafet caleskell is the standard golf course.
17:40:32 <lambdabot> I will remember.
17:41:42 <ion> > fix 0
17:41:43 <lambdabot>   0
17:42:02 <aristid> ion: nice try :P
17:42:58 <mokus> > head[] -- is pretty short and Prelude-compatible :)
17:42:59 <lambdabot>   *Exception: Prelude.head: empty list
17:43:11 <hpc> ooh, and polymorphic
17:43:15 <mokus> yea
17:43:27 <aristid> > length[]
17:43:28 <lambdabot>   0
17:43:36 <aristid> > length "head[]"
17:43:37 <lambdabot>   6
17:43:45 <aristid> mokus: only a tie with fix id
17:43:59 <davidL> > []!!0
17:44:00 <lambdabot>   *Exception: Prelude.(!!): index too large
17:44:02 <aristid> but then it is fully prelude-compatible
17:44:25 <aristid> :t []!!0
17:44:26 <lambdabot> forall a. a
17:44:33 <aristid> davidL: looking good!
17:46:54 <parcs`> > ?x
17:46:54 <lambdabot>   mueval-core: internal error: PAP object entered!
17:46:54 <lambdabot>      (GHC version 6.12.3 f...
17:46:58 <parcs`> do i wis
17:46:59 <parcs`> win
17:47:05 <mokus> lol
17:47:57 <hpc> > or[]
17:47:57 <mokus> extra points I think
17:47:58 <lambdabot>   False
17:51:22 <mokus> I think davidL's is probably the shortest possible using only prelude
17:51:37 <nexion> is there a variant of "reads" that works on ByteString.Lazy?
17:52:24 <parcs`> there is binary/attoparsec
17:52:46 <ion> > (reads :: ReadS Data.ByteString.Lazy.ByteString) "\"foo\""
17:52:46 <lambdabot>   Not in scope:
17:52:47 <lambdabot>    type constructor or class `Data.ByteString.Lazy.ByteString'
17:53:34 <nexion> it appears to expect String
17:53:53 <parcs`> :t LBS.a
17:53:54 <lambdabot> Couldn't find qualified module.
17:54:01 <parcs`> :t BS.a
17:54:01 <lambdabot> Couldn't find qualified module.
17:54:02 * jeff_s_ loves flip :: (a -> b -> c) -> b -> a -> c, and hates Data.Set functions.
17:55:22 <djahandarie> Why would you make love with things that you hate?
17:55:47 * DanBurton wonders what's wrong with Data.Set functions
17:57:02 <DanBurton> maybe they should make a special import syntax for that
17:57:07 <DanBurton> import flipped Data.Set
17:57:29 <DanBurton> flips all of the 2-or-more-arg functions
17:57:48 <shachaf> jeff_s_: What's wrong with Data.Set functions?
17:58:00 <jeff_s_> I always want the set to be the first argument.
17:58:20 <jeff_s_> But usually it's not.
17:58:26 <DanBurton> jeff_s_: general convention for any container library is the opposite of that
18:25:21 <JoeyA> > let xs = [[1],2] in "Unify that!"
18:25:21 <lambdabot>   "Unify that!"
18:25:29 <JoeyA> Bug?
18:25:39 <rwbarton> to the extent that caleskell is a bug, yes
18:25:43 <JoeyA> > let xs = [[1],2] in length xs
18:25:44 <lambdabot>   No instance for (GHC.Num.Num [t])
18:25:44 <lambdabot>    arising from a use of `xs' at <interac...
18:25:53 <shachaf> rwbarton: Doesn't have to do with Caleskell.
18:25:54 <JoeyA> rwbarton: That happens in regular GHC, too.
18:26:01 <rwbarton> oh
18:26:02 <JoeyA> At least in 7.0.3.
18:26:13 <rwbarton> well it's still caleskell's fault
18:26:13 <shachaf> It makes sense to me.
18:26:34 <rwbarton> in that I would have trusted lambdabot otherwise
18:26:36 <shachaf> Oh, maybe it doesn't make sense to me.
18:27:25 <shachaf> Oh, no, it makes sense.
18:27:28 <rwbarton> yeah
18:27:32 <shachaf> @ty let xs = [[1],2] in xs
18:27:33 <lambdabot> forall t. (Num [t], Num t) => [[t]]
18:27:41 <JoeyA> heh
18:27:47 <shachaf> The instance is a constraint on the type, which is fine as long as you define it later.
18:28:00 <JoeyA> > let xs = [[],()] in True
18:28:00 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
18:28:27 <shachaf> That's different.
18:28:34 <shachaf> Remember that 5 really means fromInteger 5
18:29:02 <JoeyA> > let xs = [[1],2] in xs
18:29:02 <lambdabot>   No instance for (GHC.Num.Num [t])
18:29:03 <lambdabot>    arising from a use of `e_112' at <inte...
18:29:06 <JoeyA> > let xs = [[1],2] in True
18:29:07 <lambdabot>   True
18:29:35 <JoeyA> So why doesn't the let by itself need a Num [t] instance?
18:29:58 <JoeyA> > let xs = ["hello",2] in True
18:29:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:29:59 <lambdabot>    arising from the literal ...
18:30:17 <rwbarton> btw ghc 7.0.4 doesn't like your original example...
18:31:22 <rwbarton> Also, if I try to make a definition like this at top level, it works with a type signature but fails without one
18:32:59 <rwbarton> of course I need FlexibleContexts to write the type signature
18:34:02 <rwbarton> so that takes me outside of Haskell 98
18:42:47 <mm_freak> in parser combinator terms, when does a grammar become context-sensitive?  or better, how can i make sure it's context-free?  does it suffice to make sure that i only use the applicative interface?
18:43:27 <Phlogistique> (I'm interested in the answer to mm_freak too)
18:44:18 <mm_freak> i remember being told that the applicative interface can in fact parse context-sensitive grammars
18:46:49 <mm_freak> having been convinced by the langsec talk at 28c3, i'll try hard to use context-free grammars as much as possible =)
18:46:57 <rwbarton> if you allow infinite grammars, you can parse anything you can compute
18:47:16 <mm_freak> what is an infinite grammar?
18:48:07 <mm_freak> infinite recursion?
18:48:32 <Phlogistique> mm_freak: which langsec talk?
18:48:32 <rwbarton> a recursive function in particular, I guess
18:48:58 <mm_freak> Phlogistique: http://www.youtube.com/watch?v=3kEfedtQVOY
18:49:43 * hackagebot http-enumerator 0.7.2.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.2.3 (MichaelSnoyman)
18:50:26 <rwbarton> parse f = (guard (f []) >> eof) <|> (char 'a' >> parse (f . ('a' :))) <|> (char 'b' >> parse (f . ('b' :))) <|> ...
18:50:27 <Obfuscate> How does one map over multiple lists in haskell? e.g. map + a b
18:50:28 <monochrom> an infinite grammar is probably a grammar with infinitely many production rules
18:51:20 <rwbarton> right, here I effectively have a production rule for every function f :: String -> Bool
18:52:06 <roconnor> Obfuscate: zipWith
18:53:32 <Obfuscate> roconnor: Thanks.
18:59:43 * hackagebot http-proxy 0.0.5 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.5 (ErikDeCastroLopo)
19:14:25 <lispy> hello
19:23:59 <DanBurton> lispy: hi
19:28:25 <dabblego> @type \f d -> fmap Data.Traversable.sequenceA (f `Data.Traversable.traverse` d)
19:28:26 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1 (f1 :: * -> *). (Data.Traversable.Traversable t, Applicative f, Applicative f1) => (a1 -> f1 (f a)) -> t a1 -> f1 (f (t a))
19:28:35 <dabblego> is this already somewhere?
19:31:33 <DanBurton> @hoogle  (a1 -> f1 (f a)) -> t a1 -> f1 (f (t a))
19:31:33 <lambdabot> No results found
19:31:44 <byorgey> dabblego: well, since the composition of functors is a functor, that is really just 'traverse' if you squint at it right
19:31:57 <byorgey> unfortunately, to get Haskell to understand that requires some newtype wrappers
19:32:04 <byorgey> enter the TypeCompose package
19:32:07 <byorgey> @package TypeCompose
19:32:07 <lambdabot> http://hackage.haskell.org/package/TypeCompose
19:32:23 <notrusty> i've got a quick question from the blaze-html tutorial:  it says to import Text.Blaze.Html5 both "qualified as H" and normally, to avoid clashes.  am I right in thinking that's the same as "import Text.Blaze.Html5 as H"
19:32:50 <dabblego> byorgey: right
19:32:58 <dabblego> a TypeCompose of course
19:33:21 <roconnor> functor composition is in transformers
19:33:41 <roconnor> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Data-Functor-Compose.html
19:33:51 <byorgey> oh, so it is, didn't realize that
19:33:53 <byorgey> nice
19:33:59 <DanBurton> notrusty: I think that's right
19:34:08 <djahandarie> Nice, has Applicatives in there too
19:34:09 <roconnor> @type Compose
19:34:10 <lambdabot> Not in scope: data constructor `Compose'
19:34:21 <roconnor> @type Data.Functor.Compose.Compose
19:34:22 <lambdabot> forall (f :: * -> *) (g :: * -> *) a. f (g a) -> Data.Functor.Compose.Compose f g a
19:34:49 <byorgey> @type \g -> getCompose . Data.Traversable.traverse (Compose . g)
19:34:50 <lambdabot> Not in scope: `getCompose'
19:34:50 <lambdabot> Not in scope: data constructor `Compose'
19:35:11 <byorgey> @type \g -> Data.Functor.Compose.getCompose . Data.Traversable.traverse (Data.Functor.Compose.Compose . g)
19:35:12 <lambdabot> forall (f :: * -> *) (g :: * -> *) b a (t :: * -> *). (Data.Traversable.Traversable t, Applicative f, Applicative g) => (a -> f (g b)) -> t a -> f (g (t b))
19:35:20 <byorgey> \o/
19:35:29 <roconnor> @type \f -> Data.Functor.Compose.getCompose . traverse (Data.Functor.Compose.Compose . f)
19:35:30 <lambdabot> Not in scope: `traverse'
19:35:42 <roconnor> @type \f -> Data.Functor.Compose.getCompose . Data.Traversable.traverse (Data.Functor.Compose.Compose . f)
19:35:43 <lambdabot> forall (f :: * -> *) (g :: * -> *) b a (t :: * -> *). (Data.Traversable.Traversable t, Applicative f, Applicative g) => (a -> f (g b)) -> t a -> f (g (t b))
19:35:53 <dabblego> sweeto, thanks mate
19:35:53 <roconnor> pfft
19:35:56 <roconnor> I'm so late
20:16:03 <stepkut> ugh. Found a bug in GHC 7.4rc1 where code that used to work now hangs, but changing the type signature to be less abstract makes the hang go away.
20:16:12 <stepkut> happened in 7.2 as well :-/
20:24:36 <Sgeo> Is Data.Acid an appropriate substitute for other serialization stuff like databases?
20:24:50 <scshunt> yes
20:24:57 <cl1> wow f# is a pain in the ass
20:25:37 <cl1> this code: match input.ToList<char>() with
20:25:37 <cl1>     | [] -> []
20:26:07 <cl1> gives me the error: this expression was expected to have type     Collections.Generic.List<char>     but here has type     'a list
20:26:31 * cl1 bangs head on desk
20:26:55 <shachaf> Sounds like they couldn't make ADT-style lists interact with .NET-style (mutable?) lists.
20:27:04 <shachaf> Doesn't seem that unreasonable. Also not that on-topic. :-)
20:27:46 <cl1> shachaf, its a comparison of f# to haskell
20:28:08 <cl1> just showing how much of a pain pattern matching is for strings
20:49:21 <etuleu> I have 2 styles that I switch on a TextView programmatically; the problem is that after I switch the second time the text is not aligned anymore
20:49:31 <etuleu> note that one of the styles has a bigger font
20:49:49 <etuleu> oops wrong window! really sorry!
21:03:13 <NihilistDandy> http://i.imgur.com/Spnac.jpg
21:31:52 <cl1> NihilistDandy, LMAO
21:32:03 <NihilistDandy> :D
21:44:44 * hackagebot cmdargs 0.9.1 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9.1 (NeilMitchell)
21:46:39 <russruss> so I'm looking for a parser combinator library in the parsec style that A) can deal with partial streams (like attoparsec) and B) is a monad transformer (like parsec).  Does such a thing exist?
21:54:13 <XexonixXexillion> Does anyone know of a way to write a function which uses one definition when compiled with optimisations, and another definition when compiled without?
21:54:24 <DanBurton> russruss: no clue. You might try StackOverflow if no one here wakes up and gives a solid answer
21:55:16 <DanBurton> XexonixXexillion: "with optimizations"? I don't think there's a way to specify a different implementation when ghc is given the -O2 flag, but I could be wrong
21:55:29 <rwbarton> XexonixXexillion: with RULES maybe
21:55:51 <DanBurton> I thought ghc always performed your RULES regardless of optimization level
21:56:07 <DanBurton> though tbh I've never used them
21:56:36 <rwbarton> the manual appears to indicate that it does not
22:00:54 <XexonixXexillion> Well, the code in question is some template haskell, and I can do IO in template haskell, can't I? So I suppose I could just make it read another file to tell it which function definitione to compile
22:19:34 <yitz> russruss: why is it important to have both?
22:21:22 <russruss> yitz: well, they're pretty orthogonal, aren't they?
22:22:06 <russruss> I want to have partial parsing so I can use it as an iteratee, and I want it to be a monad transformer so I can conveniently embed a writer monad
22:22:19 <russruss> using WriterT is kind of annoying because of all the lifting
22:23:21 <russruss> I'm kind of a haskell beginner so maybe I'm wrong, but since I'm parsing more than writing it seems much more convenient to have the parser be the outer monad
22:23:49 <russruss> and also there's attoparsec.iteratee which is pretty nice but that only works on pure parsers
22:24:40 <russruss> so like if I use that I have no way of embedding a writer monad
22:46:22 <srhb> So I've read that the >>= operator for lists is xs >>= f = concat (map f xs), but why do I get a type error when I try [1,2,3,4] >>= (\x -> x+2)?
22:46:40 <Axman6> because the function must return a list
22:46:47 <srhb> Ah yes.
22:46:54 <Axman6> [x+2] would be fine
22:47:04 <shachaf> srhb: For the same reason taht you get a type error when you try concat (map (\x -> x+2) [1,2,3,4])
22:47:13 <srhb> Indeed. Thank you both. Blunder.
22:50:10 <frerich> Hi, I'm sorry for being offtopic but I figured many people here have an academic background, so you can probably easily answer this: I'm trying to remember the name of a particular style of control flow diagrams (used e.g. for software algorithms). In this style, a loop is drawn like a box with a nested box (representing the loop body) aligned bottom-right. A conditional is drawn like a box which has two columns.
22:50:11 <frerich>  It's been too long since I used them, and trying to google for this only yields a bazillion UML diagrams. Does anybody have some idea?
22:51:21 <mrcarrot> frerich: http://en.wikipedia.org/wiki/Flowchart
22:51:57 <frerich> mrcarrot: No, not that one. :-[
22:52:42 <mrcarrot> that one is the classic one...
22:53:20 <XexonixXexillion> frerich: This one http://en.wikipedia.org/wiki/Nassi–Shneiderman_diagram ?
22:53:44 <frerich> XexonixXexillion : That's the one! Great, thanks!
22:57:15 <mrcarrot> hmm, basically the same as flow charts, it is just painted in a different way
22:58:28 <mrcarrot> it has the same things: statement, condidion and loops
22:58:51 <mrcarrot> just taking less paper as everything is more tight painted
23:41:52 <mgsloan> Nassi-Schneidermann-Curry diagram, sooon, I'll bet
