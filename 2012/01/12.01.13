00:14:59 <ddarius> Peaker: That would mean it was both infix and prefix which would be silly.
00:30:49 * hackagebot attoparsec-conduit 0.0.0.1 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.0.0.1 (MichaelSnoyman)
00:35:51 * hackagebot xml-conduit 0.5.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.0.1 (MichaelSnoyman)
00:39:50 <ChristianS> > (Prelude.+) 7 5
00:39:52 <lambdabot>   12
00:40:48 <ChristianS> > 7 Prelude.+ 5
00:40:49 <lambdabot>   12
00:47:11 <Jafet> > a Prelude.+ b
00:47:12 <lambdabot>   a + b
00:47:37 <Jafet> > Prelude.(+) a b
00:47:38 <lambdabot>   Not in scope: data constructor `Prelude'
00:47:41 <carpi> could someone please tell me what is happening in this case "fib = 1:1:(zipWith (+) fib (tail fib))"? I am trying to picture how it get executed but I don't understand
00:47:52 <Jafet> @where stepeval
00:47:53 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
00:47:56 <Jafet> Paste it there
00:48:04 <LoliShana> > fib = 1:1:(zipWith (+) fib (tail  fib))
00:48:05 <lambdabot>   <no location info>: parse error on input `='
00:48:19 <Jafet> It should be 0:1:
00:49:23 <tikhonjelvis> @let fib = 1:1:(zipWith (+) fib (tail  fib))
00:49:25 <lambdabot>  Defined.
00:49:53 <Jafet> Oh, stepeval doesn't have zipWith
00:50:26 <shachaf> Jafet: The first Fibonacci number is, like, 1, man.
00:51:03 <shachaf> Jafet: stepeval *seems* to have zipWith.
00:51:03 <tikhonjelvis> Isn't it 0 sometimes? That's how I always wrote it...
00:51:24 <shachaf> tikhonjelvis: No, this is a fundamental question of utmost mathematical importance.
00:51:40 <shachaf> The first two numbers are obviously (1,1).
00:51:54 <tikhonjelvis> http://oeis.org/A000045
00:52:50 <shachaf> OEIS is obviously wrong.
00:53:07 <tikhonjelvis> Eh, if that's wrong, I'm content to be wrong.
00:53:12 <erus`> @hoogle [[a]] -> [a]
00:53:13 <lambdabot> Prelude concat :: [[a]] -> [a]
00:53:13 <lambdabot> Data.List concat :: [[a]] -> [a]
00:53:13 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
00:53:21 <tty7> tikhonjelvis: "with F(0) = 0 and F(1) = 1"
00:53:21 <shachaf> Just look at the examples. F(n+1) everywhere.
00:53:25 <shachaf> Not a single F(n).
00:53:26 <tikhonjelvis> Actually, I'd be content to be wrong either way, but that probably says nothing good about me.
00:53:38 <shachaf> http://oeis.org/A177194
00:53:39 <tty7> the *first* Fibonacci number is 1.
00:53:48 <tty7> ;)
00:54:22 <ChristianS> unless you code it in C ;-)
00:54:29 <shachaf> This discussion is so useless that the person who started it ought to be eliminated.
00:54:30 <LoliShana> oeis sounds legit to me
00:54:46 <shachaf> As should all people who are participating, especially those meta-discussing it.
00:54:55 <shachaf> And also anyone using a smiley face that contains a semicolon.
00:55:05 <shachaf> Now that that's been clarified, I'm going to sleep.
01:08:21 <tazjin> Does the CouchDB package work with CouchDB 1.1? According to Hackage it was last updated Feb 2010
01:24:52 <erus`> if two points start at the same point and end at the same point on x but different points on y, will the middle point on both lines be at the same point on x ?
01:24:56 <erus`> it must be right?
01:25:45 <shachaf> I don't think your sentence makes any sense. But it might be me not making any sense.
01:25:55 <shachaf> Maybe the word "point" has multiple meanings.
01:26:03 <koala_man> erus`: yes
01:26:04 <erus`> if two lines... *
01:26:14 <erus`> whoops
01:26:47 <koala_man> the middle point will be on X=(x2-x1)/2 , and x1 and x2 are the same
01:27:02 <koala_man> for both lines
01:29:39 <Eduard_Munteanu> koala_man: perhaps you mean (x2 + x1) / 2
01:29:52 <LoliShana> shachaf: I thought you were going to sleep.
01:31:38 <erus`> @hoogle (,)
01:31:38 <lambdabot> Prelude undefined :: a
01:31:39 <lambdabot> Data.Function fix :: (a -> a) -> a
01:31:39 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
01:31:50 <erus`> is there a function name for (,) ?
01:32:06 <shachaf> LoliShana: Didn't we all?
01:33:50 <LoliShana> shachaf: No, I stopped lying to myself about sleep months ago.
01:40:09 <quicksilver> erus`: (,) is a name
01:41:30 <koala_man> Eduard_Munteanu: ehm. yes.
01:56:02 <frerich> In which situations does an applicative style of writing Haskell tend to be 'nicer'? Applicative functors seem to be really powerful, but so far the only good example I found was using them instead of list comprehensions, e.g. '(*)  [2,5,10] <*> [8,10,11]  ' instead of '[ x*y | x <- [2,5,10], y <- [8,10,11]]'
01:56:26 <frerich> I think the notation is really concise, I wonder whether there is "idiomatic" applicative code.
01:56:58 <frerich> Err sorry, a '' was missing in my example.
01:57:03 <frerich> euhm
01:57:14 <frerich> Why is 'lower_than - dollar - greater_than' swallowed? :)
02:04:17 <dobblego> Category (~>) => (b ~> m c) -> (a ~> m b) -> (a ~> m c) -- is this somewhere handy?
02:04:28 <dobblego> +(Monad m) =>
02:04:47 <Veinor> frerich: i assume your irc client is swallowing the <$>
02:07:00 <Eduard_Munteanu> :t (>=>)
02:07:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
02:07:43 <dobblego> I want for any Category, not just (->)
02:07:57 <flojistik> <$>
02:08:22 <Eduard_Munteanu> dobblego: I guess it generalizes that for arbitrary arrows
02:08:59 <Eduard_Munteanu> @hoogle Category (~>) => (b ~> m c) -> (a ~> m b) -> (a ~> m c)
02:09:00 <lambdabot> Did you mean: ~> b (m c) -> ~> a (m b) -> ~> a (m c)
02:09:00 <lambdabot> No results found
02:09:58 <dobblego> not even sure it's possible come to think of it
02:10:07 <Eduard_Munteanu> @hoogle t b (m c) -> t a (m b) -> t a (m c)
02:10:07 <lambdabot> No results found
02:11:33 <Eduard_Munteanu> Well, it is (>=>) for "flip Kleisli"
02:11:48 <dobblego> @type (<=<)
02:11:49 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
02:11:51 <Eduard_Munteanu> Erm, no.
02:12:29 <Eduard_Munteanu> For plain (->)
02:12:52 <dobblego> I don't have plain (->) I have Lens
02:13:43 <Eduard_Munteanu> dobblego: any particular package? I kinda have an idea of what you mean, but it's been a long time since I looked at those.
02:13:53 <dobblego> I am using data-lens
02:15:18 <Eduard_Munteanu> dobblego: alright, is there anything in particular you're having trouble with?
02:15:48 <dobblego> I just want that function for (~>) = Lens and I figure if it is somewhere other than data-lens, that would be handy!
02:15:50 * hackagebot happstack-static-routing 0.2 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.2 (MagnusCarlsson)
02:16:31 <Eduard_Munteanu> :t (<<<)
02:16:32 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
02:21:11 <Eduard_Munteanu> Hrm, I'm not sure.
02:21:43 <dobblego> neither
02:23:56 <dobblego> although, I believe I have just shown that: type Lens f a b = a -> Store (f b) a; Monad f => Category (Lens f) is not
02:24:05 <dobblego> since, what is id?
02:24:17 <Phoul> Hey all, Sorry if this isnt the right place to ask but ive been attempting to install xmobar via cabal and i keep getting an error that im not entirely sure i understand. http://hpaste.org/56410 is the error, if anyone has any ideas id greatly appreciate it, and if this is the wrong place i strongly apologize
02:24:46 <dobblego> Phoul: I had that error when installing xmobar, gave up and used GHC 7.0.4
02:26:27 <Eduard_Munteanu> dobblego: hm, though for a given monad m, Kleisli m is a Category, so that (<<<) might work after all
02:26:57 <dobblego> Kleisli is a -> m b not a ~> m b for any Category (~>)
02:27:19 <Eduard_Munteanu> Oh, right.
02:30:04 <quicksilver> surely edwardk has a typeclass for the Kleisli cat a ~> m b over an arbitrary arrow (or category) ~> ?
02:30:21 <dobblego> one would think innit
02:30:33 <quicksilver> although you'd have fiddly wrapping/unwarpping inevitably
02:30:37 <quicksilver> so it might not be convenient to use
02:30:44 <carpi> could someone please tell me what does it mean when someone says that a function is evaluated and not executed?
02:30:49 * hackagebot IOSpec 0.2.3 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.2.3 (WouterSwierstra)
02:31:32 <Eduard_Munteanu> carpi: only IO actions are executed
02:32:07 <carpi> Eduard_Munteanu: you mean functions that process monad types?
02:33:01 <ddarius> quicksilver: That would require (in general) a notion of functor and monad over an arbitrary Category.
02:33:09 <Eduard_Munteanu> carpi: no
02:33:22 <quicksilver> ddarius: really?
02:33:42 <quicksilver> ddarius: my assertion is just that a ~> m b forms a Category
02:33:55 <quicksilver> ddarius: if m is a Monad and ~> is a Category
02:34:06 <quicksilver> is that not true?
02:34:19 <carpi> Eduard_Munteanu: so what do you mean then?
02:34:20 <Eduard_Munteanu> carpi: think of it this way. The runtime has to execute the 'main' IO action, that is the entrypoint to your program. To do that, it has to evaluate certain things to make progress.
02:34:33 <ddarius> quicksilver: You don't need to ask me.  Start by defining id.
02:35:08 <carpi> Eduard_Munteanu: True..and where does "execution" come in to the picture?
02:36:01 <Eduard_Munteanu> carpi: think of 'main' as a function that produces a list of things the runtime has to do, like write a file, read stdin etc.
02:36:43 <Eduard_Munteanu> carpi: the things the runtime does for you is stuff that gets "executed"
02:37:33 <quicksilver>  
02:38:40 <carpi> and by runtime are you referring to the part where actions are performed by systems outside haskell on behalf of haskell?
02:39:47 <Eduard_Munteanu> carpi: the RTS
02:40:39 <Eduard_Munteanu> It's not really external to the code that's produced, but it's not something you express in Haskell itself.
02:41:15 <quicksilver> ddarius: fmap return . id ?
02:41:26 <quicksilver> ddarius: or is (a ~>) not always a Functor?
02:41:38 <dobblego> I actually don't think that function is possible, even for Category Lens
02:42:14 <mikeplus64> what is "the best", "most supported" GUI library for haskell? (just a question to spark a fire)
02:42:43 <Enigmagic> html
02:42:53 <Eduard_Munteanu> mikeplus64: I'd say Gtk2Hs, then wxHaskell, but I haven't actually tried the latter.
02:42:57 <carpi> ah okay.. i googled RTS for haskell.. seems like its an option for ghc where i can tweak the environment in which the haskell code can run. This is exciting..so it means i can make code more faster this way
02:43:48 <Eduard_Munteanu> carpi: no, you didn't get that right. Haskell needs some other supporting code to run, to perform various tasks like executing IO, managing memory, performing garbage collection etc.
02:43:52 <Eduard_Munteanu> That's the RTS.
02:44:20 <Eduard_Munteanu> Sure, you can pass options to the RTS to alter certain parameters, but that's not the point here.
02:44:41 <carpi> but RTS is not like a seperate program .. yea?
02:44:51 <Veinor> right
02:45:00 <Veinor> ghc puts the RTS in every compiled haskell program
02:45:00 <Eduard_Munteanu> It's not, it's linked into every Haskell program.
02:45:11 <carpi> ah okay
02:45:20 <ddarius> quicksilver: (a ~>) is always a functor (a continuous functor, no less), but not always a Functor.  The natural way is via fmap f = (f Category..) but then f will need to be an arrow in the Category.
02:46:28 <dobblego> Lens is not an arrow
02:46:41 <keep_learning> hello all
02:47:15 <keep_learning> i have installed dph-par library for parallel programming
02:47:36 <keep_learning> and trying to import Data.Array.Parallel
02:47:52 <ddarius> dobblego: "Arrow" there is a synonym for "morphism" and has nothing to do with the Arrow class.
02:48:01 <dobblego> ok
02:48:13 <keep_learning> but its not showing function  ( http://hackage.haskell.org/packages/archive/dph-par/0.5.1.1/doc/html/Data-Array-Parallel.html )
02:48:37 <keep_learning> also it  says there is no such module
02:48:41 <Phoul> dobblego: :( that kinda sucks, this distro doesnt offer ghc7, i wonder how hard it is to build..
02:48:53 <dobblego> Phoul: probably easy
02:49:06 <Veinor> building ghc7 from another ghc is easy
02:49:18 <koeien_> ghc7 should be easy if you have a fairly recent ghc
02:49:22 <Veinor> assuming you have something similar to build-dep
02:49:29 <Phoul> i have 6.12.3
02:49:30 <ddarius> That said, there is a Kleisli arrow transformer.
02:49:33 <koeien_> that's fine
02:49:41 <koeien_> (there are also binaries)
02:51:13 <mikeplus64> Eduard_Munteanu: hm, Reactive-Banana looks good and isn't dead but seems to not build :(
02:52:32 <Eduard_Munteanu> mikeplus64: nah, that's FRP and you should probably use that *only* if you're interested in research in those fields :)
02:53:32 <erus`> @pl map ((,) tid . map (fixNormal n) . makeTexGroup) $	rightAngles $ rightHeavy $ longSideDown $ flatten wt tt
02:53:33 <lambdabot> map ((,) tid . map (fixNormal n) . makeTexGroup) (rightAngles (rightHeavy (longSideDown (flatten wt tt))))
02:53:33 <Eduard_Munteanu> I don't think there's any FRP GUI toolkit that's as featureful or easy or well-supported as Gtk2Hs, for example.
02:53:50 <Phoul> Hmm
02:54:57 <mikeplus64> Eduard_Munteanu: yeah, I was just looking at the examples and going "oooh, ahhhh" ;)
02:55:29 <erus`> is a multiline function call ever a good idea?
02:56:34 <Eduard_Munteanu> mikeplus64: well, it might be usable, considering they say it works with Gtk2Hs/wxHaskell, but IDK how easy it is to work with it.
02:56:44 <Eduard_Munteanu> It might be fun if you're looking to experiment with this sort of stuff.
02:57:42 <mikeplus64> yeah, I am, it's just it fails to build
02:59:01 <koeien_> erus`: why not?
02:59:55 * Phoul feels so stupid right now -_- 
02:59:59 <erus`> ugly?
03:00:50 * hackagebot GPX 0.6.0 - Parse GPX files  http://hackage.haskell.org/package/GPX-0.6.0 (TonyMorris)
03:00:58 <mikeplus64> a multiline function call can be way more readable than one line of noise
03:02:30 <Enigmagic> erus`: i almost always use bracket in a multiline fashion, just like this http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Exception-Base.html#v:bracket
03:02:51 <dobblego> Phoul: I use this snippet to upgrade GHC http://paste.pocoo.org/show/534172/
03:07:34 <Phoul> dobblego: the version of libgmp this distro provides is also apparently too old for the binary
03:07:37 <Phoul> Gona try to build the source.
03:08:41 <naimenn> Any good starting point for using FSEvents with Haskell?
03:08:55 <naimenn> - or equivalent suggestion.
03:12:13 <naimenn> - or something else that can trigger scripts when a dir tree changes?
03:12:45 <aadrake> Does anyone have experience with csv-enumerator?  I want to take a row and map it to a row of 0s and 1s where the 0s indicate there was nothing in the field and 1 indicates the field had a value.
03:13:04 <aadrake> So val1,val2,,val3 would map to 1,1,0,1
03:16:42 <naimenn> aadrake: do you need to worry about escaped commas?
03:17:43 <Sgeo> My school has a Linux system which I have an account on. Some of its libraries are too old to just build GHC out of the box. How easy/difficult would it be for me to use the Linux machine I'm using at home to get GHC onto the school system?
03:18:09 <aadrake> naimenn: There may be commas in the values, yes
03:18:10 <koeien_> you can run the binaries most likely
03:18:14 <koeien_> unless you have a very old libc
03:18:47 <aadrake> naimenn: They're all quoted but empty fields do not contain empty strings.
03:18:56 <Sgeo> koeien, I _think_ it's very old
03:19:00 <Sgeo> Easiest way to find out?
03:19:06 <aadrake> naimenn: So there are no "blah1","","blah2"
03:19:06 <naimenn> http://book.realworldhaskell.org/read/using-parsec.html
03:20:22 <naimenn> aadrake: does that link look like it will help?
03:20:30 <aadrake> naimenn: I built an example using that for some other CSV stuff I was doing, and csv-enumerator was twice as fast.
03:20:43 <aadrake> naimenn: So I'd prefer to use it again
03:20:50 * hackagebot websockets-snap 0.5.0.1 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.5.0.1 (JasperVanDerJeugt)
03:23:58 <erus`> can i trace an undefined somehow?
03:26:07 <frerich> Thanks to this channel, I'm considering fst, snd, head and tail to be code smells now. And indeed, in virtually all cases, I'm better off with pattern matching!
03:26:23 <frerich> I just never realized that you can pattern match almost everywhere.
03:27:08 <erus`> you can pattern match in patterns?
03:27:11 <danr> erus`: if you use a release candidate of ghc 7.4 you can debug the stack trace (I think!)
03:27:24 <erus`> im using windows haskell platform :(
03:27:37 <naimenn> ^ boooooooooooooooooo!
03:28:03 <erus`> ok this is very strange
03:28:19 <erus`> file doesnt contrain "undefined" and im getting Prelude.undefined
03:29:05 <Sgeo> Wait, fst and snd are code smells?
03:29:28 <Veinor> erus`: hpaste?
03:29:55 <Veinor> Sgeo: f x | fst x == 2 = snd x is a smell
03:30:22 <erus`> how do i sewarch for text in vim?
03:32:21 <Tinned_Tuna> erus`: use the slash key
03:32:58 <erus`> omg :|
03:35:57 <Tinned_Tuna> erus`: search and replace (global): %s/find/replace/g
03:36:33 <Botje> spend your time fighting with one piece of technology at a time.
03:37:36 <naimenn> Any help regarding Haskell and file system events? A tutorial would be great.
03:37:57 <danslo`work> What's a popular editor for writing haskell?
03:39:21 <hpaste_> erus` pasted “undefined :|” at http://hpaste.org/56412
03:40:05 <Veinor> that doesn't look like it should produce an undefined to me
03:41:15 <danr> I guess there must be an undefined in the arguments
03:41:20 <Botje> erus`: that means either your V3 Double or your  CnvtPart is undefined.
03:41:57 <tazjin> danslo`work: What OS are you on?
03:42:26 <erus`> CnvtPart is a type not data . V3 Double works
03:42:47 <Botje> erus`: so? the triple constructor can still be undefined.
03:42:58 <Botje> erus`: or one of the parts of CnvtPart
03:43:28 <erus`> theres no undefined in the file
03:44:04 <danslo`work> tazjin: debian / ubuntu (depending on my location)
03:44:05 <Botje> it can still come from libraries.
03:44:19 <Botje> erus`: have you tried using Debug.Trace and printing both parameters?
03:44:39 <erus`> Botje: im calling it from ghci
03:44:43 <tazjin> danslo`work: Why not vim? :]
03:45:18 <erus`> aha
03:45:22 <erus`> its Ord
03:45:25 <erus`> sorry all
03:45:26 <mikeplus64> danslo`work: vim is always good, sublime text I'm starting to like quite a lot
03:45:47 <erus`> i put .cross instead of .dot
03:46:18 <danslo`work> tazjin: I guess that is an option :)
03:48:25 <erus`> @hoogle range
03:48:25 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
03:48:26 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
03:48:26 <lambdabot> Language.Haskell.TH.Syntax data Range
03:48:30 <tazjin> danslo`work, mikeplus64: I also want to try Diakonos but haven't had the time yet.
03:48:34 <danslo`work> I was just wondering because for example RubyMine is really popular for Ruby development... maybe there was some widely used "standard" haskell IDE
03:48:55 <Veinor> danslo`work: your choice of vim/emacs
03:50:18 <cheater_> danslo`work: vim has really good syntax highlighting and formatting for haskell
03:50:26 <cheater_> which is difficult to get right in the first place.
03:50:30 <danslo`work> hah
03:52:34 <cheater_> no kidding
03:53:51 <cheater_> hey guys what's a smart way to do this: given a list of strings xs and string b find out if one of xs isInfixOf b ?
03:54:12 <Botje> any (`isInfixOf` b)
03:54:15 <Botje> any (`isInfixOf` b) xs
04:08:10 <cheater_> Botje: oo nice
04:08:43 <cheater_> but i was also hoping there was another way than "map" and derivatives
04:09:08 <cheater_> let's put the bar up a little
04:09:25 <cheater_> i have two lists of strings, xs and ys, and i want to find out if any of the xs is an infix of any of the ys
04:10:29 <Botje> liftM2 isInfixOf xs ys
04:10:38 <cheater_> ah nice
04:10:43 <cheater_> that's kinda what i was looking for i think
04:10:48 <cheater_> @type liftM2
04:10:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:11:06 <cheater_> i guess i'ld also need to add an "any" there
04:11:09 <Botje> or isInfixOf <$> xs <*> ys
04:11:17 <cheater_> even cooler
04:11:21 <Botje> or (isInfixOf <$> xs <*> ys)
04:11:22 <Botje> even :)
04:11:26 <cheater_> i was actually thinking <$> might have something to do with this
04:11:32 <cheater_> @type <*>
04:11:33 <lambdabot> parse error on input `<*>'
04:11:38 <Botje> shrug
04:11:39 <cheater_> @type (<*>)
04:11:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:12:12 <Botje> liftM can be directly translated into <$> and <*> for most monads-that-are-applicative-functors
04:12:25 <Botje> I use liftM because i'm old school :P
04:12:27 <cheater_> how?
04:12:36 <Botje> like I just showed you.
04:12:43 <Botje> liftM2 f a b = f <$> a <*> b
04:12:49 <cheater_> yeah but what is the general approach for liftMn ?
04:13:02 <Botje> liftM3 f a b = f <$> a <*> b <*>c
04:13:05 <cheater_> _ <$> _ <*> _ <*> ... ?
04:13:05 <Botje> add more stars :)
04:13:09 <cheater_> ok
04:13:13 <cheater_> that's pretty cool!
04:14:15 <cheater_> can you say that <$> <*> is a sort of primitive version of convolution?
04:15:51 * hackagebot doctest 0.5.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.5.0 (SimonHengel)
04:17:45 <Botje> i'm not familiar with the term, sorry
04:18:52 <cheater_> in convolution, you have two lists of Ints
04:19:09 <cheater_> one is called the signal, the other is called the impulse response
04:19:24 <cheater_> it's a typical way of simulating echo on computers, every room has a different impulse response
04:19:31 <cheater_> it's fairly simple
04:19:39 <erus`> @ hoogle trace
04:20:17 <hpc> @hoogle trace
04:20:18 <lambdabot> Debug.Trace module Debug.Trace
04:20:18 <lambdabot> Debug.Trace trace :: String -> a -> a
04:20:18 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
04:20:25 <cheater_> for every index of signal, you multiply the whole of the impulseResponse by that number
04:20:45 <cheater_> actually it's easier to think of this if both are set to be [Float] in the range -1 , 1
04:21:01 <cheater_> so you multiply the whole of impulseResponse by the value of signal at that index
04:21:15 <cheater_> and you do that for every index of signal
04:21:35 <cheater_> then you add those multiplied impulseResponse's together, forming a new list, but you do it in a slightly funny way
04:22:11 <xtea> hi guys just a quick question if I got a chance to return uninitialized variable from the function ie initialization is in if statement is it syntax or semantix issue ?
04:22:11 <cheater_> every time you add the nth impulseResponse, you prepend it with n entries of value 0
04:22:16 <cheater_> before you add it.
04:22:25 <xtea> sorry for offtopic ;)
04:23:13 <erus`> that feel when your program works after days of coding :)
04:23:15 <Botje> xtea: what? haskell doesn't have uninitialized variables
04:23:32 <Botje> cheater_: still no clue, sorry :)
04:24:05 <xtea> Botje: I know its a bit of off topic but got an exam in programming languages in an hour and need to know this one
04:24:52 <xtea> Botje: can be java or c doesnt matter the question is is it syntax or semantics
04:26:09 <xtea> Botje: lets say function returnng int but got 50% chance this will be uninitialized
04:26:40 <frerich>  xtea: The return value is part of the semantic of that function.
04:27:33 <frerich> xtea: I wish you all the best, since a programming languages exam might become rather tricky if you still have troubles with telling syntax and semantic apart. :-}
04:27:40 <sipa> xtea: I'd say that function has undefined semantics, in that case
04:28:02 <xtea> frerich: thanks so that mean this would compile but can have no meaning for the machine ?
04:28:14 <frerich> xtea: Right
04:28:56 <xtea> frerich: thank you I've got problem only with this oneand I found this particular question really tricky
04:29:52 <xtea> ok thank you guys wish me luck ;)
04:34:40 <frerich> Does anybody here have experience with image processing in Haskell? In particular, I'm looking for an efficient data structure for holding a 32bit pixmap in memory to perform various algorithms on it (i.e. edge detection, turning a colorful image to monochrome, things like that).
04:35:01 <erus`> how do i get a package on hackage?
04:35:10 <carpi> how do we distinguish between function application and type constructors?
04:35:46 <carpi> yea.. i think one occurs in places where the other doesn't
04:36:35 <danr> frerich: no but I am also interested in this, please tell me if you find a nice library :)
04:37:33 <ptek> erus`: you mean how do you look for one? or how to install one?
04:37:41 <frerich> carpi: Type constructors are used when specifying the type of expressions, applying a function to some value *is* an expression.
04:37:50 <frerich> danr: I'll try to keep you in mind. :-)
04:37:52 <erus`> how can i upload mine to hackage
04:37:55 <erus`> can i use cabal?
04:38:19 <carpi> frerich: thats what I thought so as well. thanks for the clarification
04:38:21 <ptek> erus`: oh, never tried that. sorry...
04:39:06 <donri> erus`: cabal sdist and cabal upload
04:39:38 <donri> you need a hackage account http://hackage.haskell.org/packages/accounts.html
04:40:51 * hackagebot buildwrapper 0.3.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.3.0 (JeanPhilippeMoresmau)
04:42:29 <vstol> morning, ladies and gents
04:42:46 <vstol> i'll leave this up while my classes are running and see what happens
04:42:55 <Botje> .oO(uninitialized values are tricky nowadays?)
04:43:00 * Botje waves to vstol 
04:45:40 <Lycurgus> .oO(what's not tricky nowadays?)
04:45:51 * hackagebot scion-browser 0.2.1 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.1 (JeanPhilippeMoresmau)
04:46:45 * Lycurgus .oO(irc even)
04:50:04 <erus`> you need to use a real name with hackage :|
04:50:17 <erus`> say goodbye to your privacy
04:52:00 <Veinor> i've always been kind of unsure about that but eh
04:52:06 <Hunner> erus`: Just get a different name?
04:52:32 <erus`> I don't care, but what about that bitcoin dude
04:52:37 <erus`> and that ps3 hacker dude
04:52:56 <Hunner> bitcoin dude?
04:53:15 * Hunner met the ps3 hacker dude last summer :] (well, one of them)
04:53:16 <erus`> satoshi
04:53:51 <Hunner> Ah
04:56:04 <Hunner> If you don't use your real name then you must have aliases, but then it's equally as difficult to keep your aliases separate as well.
04:59:07 <tazjin> Didn't that Satoshi guy from BitCoin mysteriously disappear?
05:03:19 <Veinor> tazjin: yep.
05:04:09 <ClaudiusMaximus> frerich, danr: i think REPA has some image processing examples
05:05:46 <erus`> @hoogle getArgs
05:05:46 <lambdabot> System.Environment getArgs :: IO [String]
05:05:46 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
05:06:16 <erus`> hlint should be in the paltform
05:06:22 <erus`> @hoogle getContents
05:06:22 <lambdabot> Prelude getContents :: IO String
05:06:22 <lambdabot> System.IO getContents :: IO String
05:06:22 <lambdabot> Data.ByteString.Lazy getContents :: IO ByteString
05:06:30 <erus`> :w
05:06:37 <erus`> woops
05:29:05 <byorgey> tromp: good luck vs Zen19!
05:35:09 <dmwit> "Didn't the bitcoin guy mysteriously disappear?"
05:35:14 <dmwit> More like he mysteriously never appeared.
05:48:34 <hpaste_> gregATio pasted “look at this” at http://hpaste.org/56414
05:49:14 <gregATio> can you guys tell me what im doing wrong?
05:49:40 <mjrosenb> gregATio: what are you trying to do?
05:49:57 <Sgeo> Should show error message, but looks like indentation may be wrong?
05:50:03 <Sgeo> Please paste error message
05:50:38 <gregATio> fixed it thanks
05:50:55 <Sgeo> Also, step looks like a partial function
05:55:35 <Leif_Bork> If I have a graph, pure, and change one node, I might have to update the whole graph, true?
05:55:51 * hackagebot wai-routes 0.1 - This package provides typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.1 (AnupamJain)
06:01:24 <mm_freak> Leif_Bork: no
06:01:57 <mm_freak> Leif_Bork: because of immutability the new structure will share the nonchanged parts with the old one
06:02:21 <byorgey> Leif_Bork: it also depends how the graph is represented in memory.
06:05:51 * hackagebot hit 0.2.1 - Git operations  http://hackage.haskell.org/package/hit-0.2.1 (VincentHanquez)
06:15:52 * hackagebot doctest 0.5.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.5.1 (SimonHengel)
06:35:51 * hackagebot histogram-fill 0.6.0.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.6.0.0 (AlexeyKhudyakov)
06:36:00 <erus`> can i use opengl3 shaders with hopengl?
06:36:08 <erus`> ive only ever used glBegin type stuff
06:43:43 <parcs`> with openglraw you should be able to
06:45:35 <erus`> can i use that with glut?
06:45:41 <erus`> i need a cross platform window
07:03:28 <parcs`> probably, but consider using glfw-b
07:03:36 <parcs`> it doesn't depend on hsopengl
07:29:52 <hpaste_> Leif_Bork pasted “Polytree” at http://hpaste.org/56416
07:32:19 <erus`> i used to really moan about hsopengl, but i think its awesome now
07:33:17 <Leif_Bork> In this graph, when removing n3, I have to change n2, and then I will have to change n1 as well, and if there are more nodes connected to n1, I will have to change all of them as well, true?
07:34:04 <byorgey> Leif_Bork: yes, probably
07:34:21 <Fifo> Hello, how are you? Yes, I joined :)
07:34:39 <byorgey> Leif_Bork: maintaining multiply-connected/shared structures in a pure functional setting is rather difficult
07:34:44 <byorgey> hi there Fifo
07:35:09 <Fifo> What’s ‘ChanServ’
07:36:14 <byorgey> Fifo: it is a special robot maintained by freenode which manages various things about IRC channels
07:36:37 <Fifo> Thanks for the reply.
07:36:49 <Leif_Bork> byorgey: So I have to recursively redirect nodes, if I want to change one node. There are no other ways to do this (in a pure functional setting), are there?
07:36:59 <srhb> I have a trivial question about compilation, since I have only ever done interpreted languages before: When I compile a Haskell program with GHC, what platforms can I expect it to run on? Only my exact OS and setup?
07:37:42 <yrlnry> byorgey:  have you looked at http://cs.anu.edu.au/~Ben.Lippmeier/project/thesis/thesis-lippmeier-sub.pdf ?
07:37:48 <byorgey> Leif_Bork: I would do it by assigning unique id's to nodes, then keeping some mappings from nodes to children and nodes to parents, and a separate mapping from node ids to content
07:38:08 <hpc> srhb: it will run on another machine with your same OS and CPU architecture
07:38:18 <byorgey> Leif_Bork: i.e. representing the structure implicitly instead of explicitly.
07:38:26 <srhb> hpc: Oh, thanks. That makes it easier to figure out. :)
07:38:27 <hpc> srhb: assuming requisite libraries are installed (ie, gtk for GUI stuff)
07:38:31 <srhb> Right.
07:39:11 <Fifo> I'm learning Haskell right now.
07:39:20 <Fifo> (1,"hats",23/35)
07:39:54 <Leif_Bork> byorgey: So I have a map, mapping nodes to nodes, that changes instead of the nodes changing
07:40:09 <byorgey> yrlnry: no, should I?
07:40:18 <byorgey> Leif_Bork: right
07:40:33 <byorgey> Fifo: great! Feel free to ask questions in here
07:40:42 <Fifo> let x = 4 in x * x
07:41:36 <yrlnry> byorgey:  I'm not sure; I haven't finished reading it myself.  But the author claims to be able to resolve the conflicts between efficient data structures that support cheap update, and strong static typing, type classes, etc.
07:41:43 <yrlnry> I forget who pointed me to it.
07:42:10 <Fifo> byorgey: What will ‘let x = 8 * 10 in x + x’ do?
07:42:11 <byorgey> yrlnry: neat.
07:42:21 <byorgey> Fifo: what do you think it will do?
07:42:36 <Leif_Bork> byorgey: Thank you! I guess I was think a bit object oriented, or something.
07:42:48 <Eduard_Munteanu> Fifo: lambdabot can help there.
07:43:00 <Eduard_Munteanu> > let x = 8 * 10 in x + x
07:43:00 <lambdabot>   160
07:43:06 <byorgey> Fifo: are you asking what its value will be, or are you asking how many arithmetic operations will be performed?
07:43:52 <Fifo> byorgey: I’m asking how many arithmetic operations will be performed.
07:44:14 <dmwit> The answer is implementation-specific, but GHC does the right thing.
07:44:23 <Eduard_Munteanu> My guess is 0.
07:44:23 <byorgey> Fifo: any sensible implementation of Haskell will do one multiplication and one addition.
07:44:37 <byorgey> Fifo: although technically the Haskell standard does not specify.
07:44:40 <yrlnry> "Disciple is an explicitly lazy dialect of Haskell. DDC uses effect and closure typing to allow destructive update and arbitrary side-effects to play nicely with laziness and compiler optimisations. It also supports real (object.field) type-directed projections and some other useful features. "
07:44:42 <Eduard_Munteanu> At runtime at least.
07:45:11 <Fifo> Eduard_Munteanu, byorgey: How do I get all the commands?
07:45:14 <Eduard_Munteanu> Of course, if it's not known at compile time, it will do what byorgey says.
07:45:21 <yrlnry> byorgey^
07:45:28 <Eduard_Munteanu> Fifo: for lambdabot?
07:45:29 <Eduard_Munteanu> @list
07:45:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:45:37 <Eduard_Munteanu> Mind it also answers private questions
07:45:51 <byorgey> yrlnry: yep, neat.  I had heard about DDC before but haven't read anything about the theory behind it.
07:45:52 <dmwit> Eduard_Munteanu: Depends how specific a type you give it, I suppose.
07:46:01 <Fifo> Eduard_Munteanu: Thanks.
07:46:06 <Eduard_Munteanu> dmwit: hm, right.
07:46:17 <chu> byorgey: Ben's thesis is available online, should talk a bit about the theory behind it.
07:46:53 <Fifo> byorgey: What is the ‘syntactic sugar’?
07:47:03 <byorgey> chu: yeah, yrlnry linked to it earlier, that's why we were discussing it =)
07:47:39 <chu> Ahh true, sorry came in late.
07:47:47 <byorgey> chu: no worries =)
07:47:48 <yrlnry> chu:  Do you know Lippmeier?
07:48:18 <chu> Well, he was my teacher for a few years, but I don't really "know" him I guess
07:48:30 <byorgey> Fifo: syntactic sugar is notation which is just provided for convenience, and is simply translated into more primitive notation
07:48:40 <byorgey> Fifo: for example, [1,2,3] is syntactic sugar for 1 : 2 : 3 : []
07:49:37 <Fifo> byorgey: Thanks.
08:00:39 <Fifo> byorgey: Sorry for the log-off; I accidentally pressed F5!
08:03:42 <dustmote> goodday haskell! ... i've got my first program up and running, kind of: http://pastebin.com/UfCyJeBc ... how come when I uncomment the commented calls to "piz" i end up with compiler errors?
08:03:47 <mauke> The paste UfCyJeBc has been copied to http://hpaste.org/56418
08:03:52 <dustmote> oop! class starting.. i'll be back
08:04:27 <Fifo> dustmote: You can communicate with byorgey.
08:04:38 <cheater> dustmote: what do the errors say?
08:06:01 <Eduard_Munteanu> Fifo: not really, you should ask the channel
08:06:14 <Eduard_Munteanu> Not somebody in particular.
08:06:37 <Fifo> Eduard_Munteanu: What should I ask?
08:08:12 <Eduard_Munteanu> Fifo: I mean don't ask byorgey in particular every time, he just happened to answer your previous question :)
08:08:41 <Fifo> Eduard_Munteanu: Thanks for the reply. :)
08:19:11 <sm> am I imagining it or did we go from first rc of ghc 7.2 in nov to first rc of 7.4 in dec ?
08:19:54 <sm> oh, it was 7.2.2
08:20:27 <sm> go GHC
08:27:09 <Fifo> My PC crashed! It’s so annoying!
08:29:11 <mm_freak> Fifo: memory exhausted?
08:29:26 <mm_freak> by a haskell program?
08:29:52 <Fifo> mm_freak: Yes, I think.
08:30:48 <mm_freak> Fifo: to prevent this, compile your program with -rtsopts and add the option "+RTS -M512m" to your program's command line
08:30:58 <mm_freak> if you use GHCi, just pass "+RTS -M512m" to GHCi
08:31:12 <Fifo> mm_freak: Who is ByronJohnson?
08:32:49 <Fifo> Please reply!
08:33:52 <Sgeo> What happens if you don't compile with -rtsopts?
08:34:21 <Eduard_Munteanu> Sgeo: you can't set RTS options since GHC 7-ish or something unless you use that
08:34:48 <Sgeo> I remember seeing a thing for setting RTS options at compile-time
08:35:16 <mm_freak> Sgeo: -rtsopts is mandatory to enable the RTS options…  one good reason is that RTS options present a security problem for SUID executables
08:35:31 <Eduard_Munteanu> Sgeo: AFAIK the only way to do that is to link C code manually into the Haskell executable
08:35:52 * hackagebot JuicyPixels 1.0 - Picture loading/serialization (in png, jpeg and bitmap)  http://hackage.haskell.org/package/JuicyPixels-1.0 (VincentBerthoux)
08:36:06 <mm_freak> Eduard_Munteanu, Sgeo:  no, you can set default RTS options
08:36:16 <mm_freak> i don't remember what the option was called though
08:36:33 <Eduard_Munteanu> mm_freak: interesting... is it a relatively new option?
08:36:47 <Eduard_Munteanu> I kinda remember that being the case once upon a time.
08:37:45 <srhb> Does anyone know of an example of a simple plus and multiply calculator using parsec? I've done it using a simple lexer and Happy, but parsec is just one huge mystery to me, especially the buildExpressionParser usage.
08:37:52 <mm_freak> Eduard_Munteanu: dunno
08:39:30 <Fifo> My PC crashed again! That’s annoying!
08:39:35 <cwl> where can I find the definition of Pandoc data structure
08:39:45 <donri> @hackage pandoc-types
08:39:45 <lambdabot> http://hackage.haskell.org/package/pandoc-types
08:41:57 <cwl> -- | Convert HTML-formatted string to 'Pandoc' document.
08:41:58 <cwl> readHtml :: ParserState   -- ^ Parser state -> String        -- ^ String to parse (assumes @'\n'@ line endings) -> Pandoc
08:42:11 <cwl> @src readHtml
08:42:12 <lambdabot> Source not found.
08:42:15 <cwl> @type readHtml
08:42:17 <lambdabot> Not in scope: `readHtml'
08:42:30 <cwl> readHtml :: ParserState -> String -> Pandoc
08:42:37 <russruss> hey so this might be a weird question… I'd like to write an Applicative/Alternative instance for functions that return Bool, but I don't know how to write the instance
08:42:52 <cwl> I cannot find Pandoc
08:43:16 <cwl> even here http://hackage.haskell.org/package/pandoc-types and the source file
08:43:18 <donri> http://hackage.haskell.org/packages/archive/pandoc-types/1.8.2/doc/html/Text-Pandoc-Definition.html
08:43:21 <russruss> so like, I can write an instance for functions that *take* a bool by ((->) Bool)
08:43:47 <russruss> but how can I write an instance for the other way?
08:43:53 <Clint> why can't read :: Double handle strings like ".86" or "-.86"
08:44:21 <cwl> donri: strange, Text/Pandoc/Definition.hs is not in the source tree
08:44:23 <srhb> Clint: Because omitting the zero is wrong! :-)
08:44:36 <erus`> in cabal i have to import base
08:44:41 <Haskell> reverse "olleH"
08:45:00 <erus`> what version do i set as lower?
08:45:14 <tommd> Clint: Because section 2.5 of the report says you can't.
08:45:32 <Clint> well then
08:46:36 <Clint> i suppose i'll have to insert zeroes before the read
08:46:50 <tommd> Or use your own "read" function.
08:47:13 <tommd> You can start with the one used in the report http://www.haskell.org/onlinereport/numeric.html
08:47:55 <Fifo> reverse “hello”
08:48:29 <Clint> tommd: thanks
08:48:52 <x_man> olleh
08:48:54 <tazjin> > reverse "hello"
08:48:55 <lambdabot>   "olleh"
08:49:04 <russruss> explicit forall doesn't work… like "forall a. a -> Bool".  Is there some way to write that that haskell will understand?
08:49:39 <Prasoon> JECRC iWeekend presents iSoftware. Means Innovation in software. Show us your innovation and Get money worth 1000$. Goto http://jecrciweekend,com
08:50:06 <Fifo> Reverse "olleH"
08:50:18 <srhb> Fifo: Prepend > to make lambdabot respond
08:50:27 <srhb> Fifo: Thats > and a space. > reverse "olleH"
08:50:39 <Fifo> > reverse "olleH"
08:50:40 <lambdabot>   "Hello"
08:50:50 <Fifo> srhb: Thanks.
08:51:05 <srhb> Fifo: You can also message lambdabot privately to avoid spamming the channel, unless you want to show something.
08:51:21 <DukeDave> Cabal-kids: Is there anything significant about package version 9999 ?
08:51:37 <Fifo> srhb: How can I message lambdabot privately?
08:52:05 <Fifo> > reverse “hello”
08:52:06 <lambdabot>   <no location info>: lexical error at character '\8220'
08:52:16 <DukeDave> Fifo: If most IRC clients you can: "/msg lambdabot Hello there!"
08:52:36 <Runar> You can "/query lambdabot" to chat with her privately
08:52:49 <DukeDave> Ah, disregard that then :)
08:53:02 <Fifo> Runar, DukeDave: Thanks.
08:53:49 <Fifo> DukeDave: Lambdabot doesn’t reply!
08:53:50 <DukeDave> So, cabal is giving me: Linking /tmp/wxcore-999915319/wxcore-9999/dist/setup/setup ...
08:54:00 <DukeDave> Fifo: I just noticed that, I'm sure it used to :O
08:54:12 <DukeDave> ('it'? he? she?)
08:54:24 <russruss> so, there's seriously no way to write instance declarations for functions that return a certain type?  I feel like this should be easy
08:54:31 <russruss> with flexibleinstances that is
08:54:54 <monochrom> takes a while to link
08:55:11 <tazjin> DukeDave: It does if you ask it to do something
08:55:35 <tazjin> DukeDave Fifo: http://klaud.tazj.in/DJMC
08:56:44 <Fifo> tazjin: I will have an iMac.
08:57:26 <tazjin> Fifo: I'm missing the context here D:
08:57:34 <singpolyma> I'm using Data.Array, and I basically want to do an (f)map, but my item transformer needs to also know the index of the item it's working with.  Is there a good way to do that?
08:57:58 <srhb> Figuring out the Parsec types is like black magic. ._.
08:57:59 <rostayob> is there a library in haskell to decompress PNG in RGBA bmps?
08:58:08 <Fifo> tazjin: I noticed a Mac.
08:58:56 <Fifo>  
08:59:08 <ClaudiusMaximus> rostayob: juicypixels was just announced, another is repa-devil, probably others exist
08:59:19 <hpc> singpolyma: with lists, you would replace "map f xs" with "zipWith f xs [0..]"
08:59:35 <hpc> singpolyma: f :: (a, Int) -> b
08:59:50 <singpolyma> hpc: yes, that's what I normally do with lists, but I'm using a Data.Array and my indices are tuples
08:59:51 <hpc> see if there's a similar function you can use on arrays
09:00:12 <hpc> @hoogle Array a -> Array b -> Array (a, b)
09:00:12 <lambdabot> Did you mean: Array a a -> Array b a -> Array (a, b) a
09:00:13 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
09:00:13 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
09:00:26 <hpc> @hoogle Array a a -> Array b a -> Array (a, b) a
09:00:27 <lambdabot> No results found
09:00:33 <hpc> pah
09:00:33 <rostayob> ClaudiusMaximus: repa-devil seems a bit overkill
09:00:55 * hackagebot timeplot 1.0.1 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.1 (EugeneKirpichov)
09:01:05 <rostayob> ClaudiusMaximus: juicypixel is really new... maybe too new
09:05:27 <Fifo> hpc: Can't use this command in this window
09:05:59 <tommd> rostoyob: Jason and I were just talking about this on Google+
09:06:16 <rostayob> tommd: ..and?
09:06:22 <Fifo> rostayob: Can't use this command in this window
09:06:29 <tommd> I'm thinking of taking JuicyPixels and making JuicyPixels-Repa - using a repa backend and exposing OpenGL friendly in memory formats.
09:06:54 <tommd> rostayob: But before ten minutes ago we were talking about making a from-scratch package - hacking starting Saturday morning.
09:07:43 <rostayob> tommd: I think I'll just compress bmp images manually
09:07:50 <rostayob> (i'm storing sprites for a game)
09:08:05 <tommd> rostayob: You can look at pngload, but it never saw any love since its release.
09:08:28 <mdmkolbe> I found a thesis proposal by dcoutts or dcoutts_, on a partial evaluator for Haskell.  Does anyone know if that went anywhere?  Is the code available?
09:08:30 <tommd> And I don't know about saving, so for storing sprites... no, I guess that won't help you.
09:08:49 <tommd> mdmkolbe: He moved on to other work, afaik.
09:08:57 * tommd takes off for a meeting.
09:09:23 * mdmkolbe goes to the same meeting
09:15:57 <Pritchard> Who still uses haskell? :(
09:16:14 <Fifo> Pritchard: I still use Haskell.
09:16:16 <c_wraith> no one.  best to not learn anything about it
09:16:28 <tazjin> Yep, I second c_wraith
09:16:30 <Pritchard> All right.  I'll not learn about it while reading this compiler.
09:16:31 <Botje> Pritchard: does people using haskell make you sad?
09:16:46 <Pritchard> Botje:  No.  I want to learn it but I have a full-time job and other hobbies, like mathematics and music.
09:16:47 <tazjin> Also, is there a better way to parse unix time (in seconds) than \x -> parseTime defaultTimeLocale "%s" x :: Maybe UTCTime ?
09:17:07 <Pritchard> So the idea of people not using it makes me sad :(
09:18:00 <Pritchard> In fact, I really need to learn a functional programming language.
09:18:42 <donri> if you want to focus only on functional aspects, haskell might steal your focus for strictness and types
09:19:23 <Pritchard> I just noticed how many people were in this channel and figured that maybe some of you have jobs writing Haskell code?
09:20:08 <Fifo> Please reply.
09:20:45 <LoliShana> Please respond.
09:21:40 <c_wraith> Pritchard: I actually work at a company that has haskell code in production
09:21:47 <Fifo> LoliShana: What do you need?
09:21:49 <Pritchard> c_wraith:  Cool.
09:22:23 <c_wraith> Though today, I'm tweaking ruby code on the frontend instead.  blech.
09:22:33 <erus`> how do i get Ptr to storable ?
09:23:09 <Pritchard> Well, thanks for answering my question.  I appreciate it, guys.
09:23:28 <LoliShana> Fifo: ...it was just a slight reference to your sentence, never mind~
09:25:23 <ok5016> I just dont know if is beter that i start learning common lisp or Haskell can you make gui programs in it what about speed ?
09:26:23 <donri> haskell programs compiled with ghc are typically relatively speedy
09:26:39 <donri> there's bindings for gtk and wx, likely qt too(?)
09:26:42 <frigga1> ok5016: One of the biggest differences between the two languages is the type system.
09:27:31 <frigga1> ok5016: If you're more of a dynamic language kind of person, then you might prefer lisp.
09:27:45 <ok5016> thanks.
09:29:02 <Pritchard> How do I get the first element in the tuple ( (21, "Alex"), (19, "Bob"), (141, "Joanne") )?
09:29:14 <donri> pattern matching
09:29:21 <Pritchard> At tryhaskell.com, I received an error typing in "fst ( (21, "Alex"), (19, "Bob"), (141, "Joanne") )"
09:29:24 <Pritchard> Oh.
09:29:29 <Pritchard> Well, I'm not quite there yet.
09:29:31 <donri> fst and snd is only for pairs
09:29:37 <Pritchard> Thanks.
09:29:54 <MostAwesomeDude> :t any
09:29:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:29:57 <donri> case x of (a,b,c) -> a
09:30:23 <russruss> so, given a type, how do I find out which typeclasses have instances for that type in ghci?
09:30:27 <donri> > case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a
09:30:28 <lambdabot>   (21,"Alex")
09:30:58 <Pritchard> Neat.
09:30:59 <danr> russruss: :i Num
09:31:01 <danr> for instance
09:31:31 <Guest7929> Great! I synchronized the channel to my iPhone!
09:31:31 <russruss> niiiiiiice, thanks
09:31:31 <copumpkin> quiz: what's the difference between f x = let (a,b,c) = x in a and f x = case x of (a,b,c) -> a?
09:32:18 <Pritchard> The underscores in pattern matching "of (...)" clauses represent what?  Values that aren't being retrieved, or specifying simply that something should be there in the pattern we're matching?
09:32:42 <donri> _ matches anything without binding to a name
09:32:55 <Pritchard> fst (case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a)
09:33:08 <Pritchard> > fst (case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a)
09:33:09 <lambdabot>   21
09:33:11 <Pritchard> Whoo!
09:33:17 <Pritchard> > fst (case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_))
09:33:18 <lambdabot>   <no location info>: parse error on input `)'
09:33:25 <Pritchard> All righty then.
09:33:30 <donri> you could write (a,b,c) as well but that could confuse a reader into thinking we're interested in b and c
09:33:48 <donri> you can also nest pattern matching
09:33:56 <Jeanne-Kamikaze> when setting up a buildHook, is it possible to pass extra field info to the default build thing ? For example, adding stuff to "cc-options:"
09:34:15 <donri> > case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of ((x,_),_,_) -> x
09:34:16 <lambdabot>   21
09:34:24 <Pritchard> Oh!
09:34:35 <Pritchard> All right.  I was thinking along different lines.
09:34:40 <Pritchard> It's neat you can do that, though.
09:35:21 <Pritchard> > case( (case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a) of (x,_) -> x )
09:35:22 <lambdabot>   <no location info>: parse error on input `of'
09:35:26 <Pritchard> Argh.
09:35:41 <c_wraith> too many opening parens
09:35:47 <Pritchard> > case( case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a) of (x,_) -> x )
09:35:48 <lambdabot>   <no location info>: parse error on input `)'
09:35:54 <danr> russruss: np
09:35:58 <Pritchard> All right.  My eyes are confused.
09:36:21 <c_wraith> Pritchard: this isn't C.  Control structures don't need parens
09:36:24 <srhb> Would someone care to give a minimal example of a Parsec parser that parses a string of integers, plus and multiplication operations into a tree? With precedence. buildExpressionParser is so much beyond me.
09:36:26 <donri> > case (case  ( (21, "Alex"), (19, "Bob"), (141, "Joanne") ) of (a,_,_) -> a) of (x,_) -> x
09:36:27 <lambdabot>   21
09:36:34 <Pritchard> Thanks, donri.
09:36:50 <Pritchard> c_wraith:  so "case case" will work?
09:36:55 <c_wraith> yeah
09:37:04 <donri> > case case  ((21, "Alex"), (19, "Bob"), (141, "Joanne")) of (a,_,_) -> a of (x,_) -> x
09:37:05 <lambdabot>   21
09:37:10 <Pritchard> That's much better imo.
09:37:26 <Pritchard> It reads more like a logical statement in mathematics.
09:37:30 <donri> but i can't imagine you'd ever write that ^_^
09:37:39 <russruss> is there a monoid/ring instance of bool kicking around somewhere?
09:37:55 <c_wraith> @hoogle And
09:37:55 <lambdabot> Prelude and :: [Bool] -> Bool
09:37:55 <lambdabot> Data.List and :: [Bool] -> Bool
09:37:55 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
09:38:08 <c_wraith> Huh.
09:38:18 <donri> > case ((21, "Alex"), (19, "Bob"), (141, "Joanne")) of (a,_,_) -> case a of (x,_) -> x
09:38:19 <lambdabot>   21
09:38:23 <c_wraith> I was sure some package defined And and Or newtypes for the two most obvious Bool monoids
09:38:33 <Pritchard> donri:  That's also fine.
09:38:44 <russruss> c_wraith: yeah you would think there would be, right?
09:38:50 <Pritchard> case ((21, "Alex"), (19, "Bob"), (141, "Joanne")) of (a,_,_) -> (case a of (x,_) -> x)
09:38:54 <Pritchard> > case ((21, "Alex"), (19, "Bob"), (141, "Joanne")) of (a,_,_) -> (case a of (x,_) -> x)
09:38:54 <lambdabot>   21
09:39:02 <Pritchard> Okay.
09:39:11 <Pritchard> Well, I'm glad it interprets the "a" correctly.
09:39:31 <Pritchard> Although, I'll have to learn about how, where and why Haskell does that exactly.
09:39:40 <donri> @src fst
09:39:41 <lambdabot> fst (x,_) =  x
09:39:43 <Eduard_Munteanu> > let (a,_,_) = ((21, "Alex"), (19, "Bob"), (141, "Joanne")) in a
09:39:44 <lambdabot>   (21,"Alex")
09:39:45 <otto_s> @hoogle All
09:39:45 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
09:39:45 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
09:39:45 <lambdabot> Data.Monoid All :: Bool -> All
09:39:50 <donri> pattern matching works in function arguments too
09:39:58 <Jeanne-Kamikaze> oh, found it
09:39:58 <Eduard_Munteanu> > a where (a,_,_) = ((21, "Alex"), (19, "Bob"), (141, "Joanne"))
09:39:59 <lambdabot>   <no location info>: parse error on input `where'
09:40:01 <srhb> Pritchard: Look up pattern matching. :) It's quite ubiquitous.
09:40:03 <iPhoneFifo> > reverse "olleH"
09:40:04 <lambdabot>   "Hello"
09:40:35 <Pritchard> srhb:  So it's everywhere?
09:40:52 <Pritchard> Is Haskell used for db applications?
09:41:27 <russruss> otto_s: awesome, thanks
09:41:36 <donri> @faq can haskell be used for db applications?
09:41:36 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:20 <dustmote> Fifo: byorgey?
09:42:31 <dustmote> cheater: all include those
09:42:34 <Fifo> dustmote: No.
09:42:47 <iPhoneFifo> gcxhknvcdkjjhftihfszzhgfezuewwrgfff
09:43:00 <iPhoneFifo> flifooooooo
09:43:18 <Fifo> iPhoneFifo: :D :D :D Vidím čo píšeš :) :) :)
09:43:19 <iPhoneFifo> fiškus
09:43:21 <Pritchard> Haskell seems impressive.
09:43:29 <Pritchard> I really ought to learn new programming paradigms...
09:43:38 <Fifo> iPhoneFifo: I see what are you typing :) :) :)
09:43:46 <srhb> Pritchard: You'll be using pattern matching all the time, yes
09:43:57 <iPhoneFifo> iPhoneFifo, hbhgh
09:44:05 <Pritchard> @faq is haskell used for artificial intelligence?
09:44:05 <lambdabot> The answer is: Yes! Haskell can do that.
09:44:14 <Pritchard> @faq is haskell a banana?
09:44:14 <lambdabot> The answer is: Yes! Haskell can do that.
09:44:18 <Pritchard> Okay.
09:44:27 <Fifo> @faq is Haskell a programming language?
09:44:27 <lambdabot> The answer is: Yes! Haskell can do that.
09:44:30 <donri> @hackage reactive-banana
09:44:31 <lambdabot> http://hackage.haskell.org/package/reactive-banana
09:44:31 <iPhoneFifo> iPhoneFifo, ahoj FILIPKO
09:44:53 <sm> g'day all
09:44:53 <Pritchard> donri:  Hah!
09:44:56 <Pritchard> Well that exploains it.
09:44:59 <Fifo> iPhoneFifo: Fifo!!!!!!!!!!!!!!!!!!!!!!!!!!!!! :P
09:45:44 <sm> how do you join the  https://github.com/haskell organization ? perhaps contact info could be linked
09:45:47 <iPhoneFifo> iPhoneFifo, čo chceš FILIPKO. :-))
09:46:10 <MostAwesomeDude> Is this what happens when one tries to type on an iPhone?
09:46:24 <Pritchard> sm:  Someone in here may know better, but if it's on github, they probably invite people who make contributions to the code base.
09:46:58 <Fifo> MostAwesomeDude: I use an iPhone. I have an IRC client installed.
09:47:15 <MostAwesomeDude> Fifo: Yes, but are you currently on said iPhone? >:3
09:47:29 <Aune> @faq can haskell solve the halting problem?
09:47:29 <lambdabot> The answer is: Yes! Haskell can do that.
09:47:42 <iPhoneFifo> iPhoneFifo, superpipo
09:47:59 <Fifo> MostAwesomeDude: Yes.
09:48:03 <kallisti> http://sprunge.us/ELCM I was wondering if I could get suggestions on this short bit of code that generalizes Enum/Bounded instances for 2-operand product types. I was also wondering if anything similar has been done previously
09:48:17 <kallisti> ah wait that's the old version
09:49:12 <kallisti> http://sprunge.us/Gcbh  here's the slightly newer one with all of the unnecessary instances taken out.
09:49:17 <MostAwesomeDude> Fifo: Well, your typing's pretty good, then.
09:49:44 <Fifo> MostAwesomeDude: What?
09:58:06 <iPhoneFifo>  
09:58:30 <Fifo> iPhoneFifo: Anything.
09:58:58 <sm> Pritchard: that's what I want to do, add a repo to the organization on github
09:59:13 <iPhoneFifo> Fifo: your-message
09:59:35 <monochrom> are you done talking to yourself?
10:00:27 <iPhoneFifo> monochrom, Are you asking me?
10:00:33 <monochrom> yes
10:00:59 <iPhoneFifo> monochrom, No I’m not.
10:01:19 <monochrom> you can create your own channel and do it there
10:01:48 <iPhoneFifo> monochrom: Thanks.
10:02:13 <iPhoneFifo> monochrom, How do I create my own channel?
10:02:23 <monochrom> /join ##iphonefifo
10:02:43 <iPhoneFifo> monochrom, Thanks.
10:04:02 <Fifo> monochrom: Thanks.
10:41:44 <cheater> hey guys
10:42:08 <cmo> tee hee hee, i  love unicode, there's so many amazing characters
10:42:11 <cheater> i have a quasi quote (i am using ShQQ) which looks like this: [sh| foo -b -a |]
10:42:20 <cmo> my haskell is about to get horrible :P
10:42:27 <cheater> now i need to add -r but only if quux == True
10:42:29 <cheater> how do i do that?
10:43:10 <TheLemonMan> noobish question, can i use unless in an IO block ?
10:43:38 <Sgeo> :t unless
10:43:39 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:43:45 <Sgeo> TheLemonMan, yes
10:43:47 <cheater> Sgeo: you have to know about quasiquotes
10:43:50 <Sgeo> IO is a monad
10:45:42 <Sgeo> TheLemonMan, http://codepad.org/9JxRnktO
10:45:58 <Sgeo> (Note that that segment of code has some redundancies
10:46:24 <Sgeo> this is the samehttp://codepad.org/sl48uFXr
10:46:26 <Sgeo> erm http://codepad.org/sl48uFXr
10:47:44 <TheLemonMan> oh forgot to treat the unless body as a function
10:49:10 <Sgeo> The body of the unless isn't a function, it's a m ()
10:49:19 <erus`> is there a nice easy way to get miliseconds
10:49:26 <erus`> like getTickCount()
10:49:26 <Sgeo> Not everything in Haskell is a function. If it takes 0 arguments, it's not a function.
10:49:57 <paradigm> Sgeo: I just attended a presentation on haskell yesterday, and the presenter said constants are functions in haskell.
10:50:05 <djahandarie> Go tell him he's wrong
10:50:06 <paradigm> Did I misunderstand, or was the presenter mistaken?
10:50:10 <paradigm> okay, will do
10:50:12 <djahandarie> :P
10:50:30 <Sgeo> paradigm, http://conal.net/blog/posts/everything-is-a-function-in-haskell
10:50:46 <paradigm> hmm
10:54:02 <singpolyma> Is there a way to create a function like (.), but that takes an n-ary function, applies any incoming arguments to it, and then passes the return value to a second unary function ?
10:54:48 <erus`> how do i messure milliseconds of diffTIme?
10:55:11 <cmo> cheater: i think you use let x = if quux then "-r" else "" in [sh| command $x |]
10:55:19 <byorgey> singpolyma: there is a way to create a function for any particular n
10:55:28 <cmo> can't say for sure cause process refuses to install
10:55:37 <byorgey> singpolyma: but to make one that works for all n would take some serious type system gymnastics
10:55:45 <cmo> but have a look at the source for shqq, there's documentation in there
10:55:51 <singpolyma> byorgey: ok :(
10:56:09 <byorgey> singpolyma: what would you do with such a function?
10:56:39 <singpolyma> byorgey: the same things I do with (.), but without the need to sometimes wrap in a lambda
10:56:53 <cmo> cheater, and thanks for introducing me to quasiquotation, i didn't know about it
10:56:59 <singpolyma> byorgey: my current example:   (revOrd `magicdoc` ordering f)
10:57:37 <byorgey> singpolyma: for n = 2, the operator you want is  (.) . (.), often called oo
10:57:57 <byorgey> > let oo = (.) . (.) in  ((+1) `oo` (+)) 3 4
10:57:59 <lambdabot>   8
10:58:37 <byorgey> singpolyma: for n = 3, you want  (.) . (.) . (.), and so on
10:58:58 <singpolyma> byorgey: ooh
10:59:03 <dmwit> :t (Prelude..) . (Prelude..) . (Prelude..)
10:59:03 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
10:59:06 <singpolyma> that's easier than I may have thought
10:59:12 <byorgey> singpolyma: you may also find 'on' useful
10:59:14 <byorgey> @type on
10:59:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:00:37 <erus`> http://stackoverflow.com/questions/8856328/messuring-time-elapsed-in-haskell
11:00:55 <iPhoneFifo> byorgey, hello
11:01:02 <byorgey> hi iPhoneFifo
11:01:09 <cheater> cmo: hmm yeah probably
11:01:13 <singpolyma> byorgey: thanks :)
11:02:12 <iPhoneFifo> byorgey, Do you know how to print text to the screen with Haskell?n
11:02:25 <cmo> O.O, my handle changed to my system username without me doing it
11:02:42 <dmwit> erus`: It already is an elapsed time in milliseconds.
11:02:45 <dmwit> erus`: Unask the question.
11:02:50 <byorgey> iPhoneFifo: putStr or putStrLn
11:03:04 <erus`> oh i can use realToFrac
11:03:06 <iPhoneFifo> byorgey, Thanks
11:03:24 <dmwit> erus`: What are you going to do with it after you get convert it to another type?
11:03:38 <iPhoneFifo> > putStrLn "hi"
11:03:38 <lambdabot>   <IO ()>
11:03:44 <byorgey> iPhoneFifo: btw, just ask questions in this channel, and people can help you as they are available/able, rather than asking a specific person
11:03:47 <erus`> deltaTime based movement
11:04:29 <dmwit> Aha, then yes, realToFrac.
11:04:40 <dmwit> Beware that when your program runs across a leap second, it will be wrong.
11:04:41 <iPhoneFifo> byorgey, lambdabot just prints “IO ()” on the screen.
11:04:53 <dmwit> Similarly for when it runs across a daylight-savings-time boundary.
11:04:57 <dmwit> err
11:04:59 <byorgey> iPhoneFifo: lambdabot does not actually run IO actions
11:04:59 <dmwit> not the latter
11:05:03 <byorgey> iPhoneFifo: it will work if you try it in ghci
11:05:33 <dmwit> :t realToFrac
11:05:34 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:07:01 <erus`> dmwit: but its UTC
11:07:12 <erus`> i though UTC ignores it
11:07:21 <hpaste_> pcapriotti pasted “variation on callCC” at http://hpaste.org/56420
11:07:42 <pcapriotti> does that above variation of callCC have a standard name?
11:11:19 <dmwit> erus`: Yes, the problem is exactly that UTC ignores it.
11:25:59 * hackagebot git-annex 3.20120113 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120113 (JoeyHess)
11:42:11 <tazjin> > foldl (\x y -> y : x) [] "lambdabot demo"
11:42:12 <lambdabot>   "omed tobadbmal"
11:45:03 <Leif_Bork> Hi can I force Haskell to use 32-bit integers? I want this because HashMap lookups are O(n,W)
11:46:46 <erus`> PROTIP: dont try glut game mode on win7
11:48:36 <ClaudiusMaximus> @hoogle 32
11:48:37 <lambdabot> Parse error:
11:48:37 <lambdabot>   32
11:48:37 <lambdabot>   ^
11:48:39 <Saizan> Leif_Bork: there's Int32 in Data.Int
11:49:09 <koeien> or Word32
11:49:16 <koeien> (that's unsigned)
11:49:38 <parcs`> erus`: http://hackage.haskell.org/packages/archive/clock/0.2.0.0/doc/html/System-Posix-Clock.html provides a monotic clocj
11:51:02 * hackagebot base64-bytestring 0.1.1.0 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.1.0 (BryanOSullivan)
11:54:40 <vendekabyte> hi, i'm having troubles handling exceptions in haskell. say i've got a function (f) and an infinite list (xs) containing arguments to it, and want to get the first (f x) that does not throw an error
11:55:29 <Leif_Bork> Thank you
11:55:32 <vendekabyte> say the function is (10/) and the list goes [0,0,0,0,2,...] i want that 2, as the other values raise a division by zero error
11:55:45 <vendekabyte> err, i mean i want that (10/2)
11:56:02 * hackagebot lio 0.1.1 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.1.1 (DeianStefan)
11:56:10 <vendekabyte> is this possible using Control.Exception?
11:56:35 <koeien> iirc yes, but it's better to use total functions
11:57:29 <vendekabyte> what's a total function? google doesn't tell me much :(
11:57:56 <koeien> a total function is a function that is not _|_ for any arguments
11:58:25 <tgeeky> koeien: is that correct? and if it is, is it helpful?
11:58:26 <koeien> for example (+1) :: Integer -> Integer is total
11:58:34 <koeien> but head is not total, since
11:58:35 <koeien> > head []
11:58:36 <lambdabot>   *Exception: Prelude.head: empty list
11:58:45 <vendekabyte> oh, i see
11:59:51 <vendekabyte> what'd be nice to have is a function (a -> b) -> (a -> Maybe b) that returns Nothing if an error was raised, else Just the result
12:00:22 <koeien> the sppon library does that.
12:00:24 <Eduard_Munteanu> The "first (f x) that doesn't throw an error" depends on the order of evaluation, mind.
12:00:30 <koeien> but it's fairly evil.
12:00:46 <tgeeky> koeien: _|_ = undefined, right?
12:01:02 * hackagebot llvm-base 3.0.0.0 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-3.0.0.0 (BryanOSullivan)
12:01:21 <koeien> _|_ = bottom, it can be "throws an exception", "fails to terminate"
12:01:46 <tgeeky> @src undefined
12:01:47 <lambdabot> undefined =  error "Prelude.undefined"
12:01:59 <koeien> yes, undefined throws an exception when evaluated
12:02:09 <tgeeky> koeien: right, so undefined = _|_. (I knew what bottom was, I was just making sure it's actually the same thing as undef)
12:02:28 <monochrom> you can only catch errors in IO
12:02:28 <tgeeky> koeien: ok, so does what your saying imply that if I write a function, and it doesn't say "undefined" (or equiv in it), then it's total?
12:02:42 <koeien> tgeeky: not at all
12:02:48 <tgeeky> ok, I didn't think so.
12:02:52 <djahandarie> > let f 2 = 3 in f 1
12:02:53 <lambdabot>   *Exception: <interactive>:3:4-10: Non-exhaustive patterns in function f
12:02:54 <vendekabyte> i think i'll just use a function to make sure the arguments are correct (say, for this example, (/= 0))
12:03:10 <Leif_Bork> vendekabyte: filter (not.isInfinite) $ map (10/) [0,0,0,0,2]
12:03:16 <monochrom> and even then, you have to be careful in controlling evaluation orders if you want an error to happen at the time you catch
12:03:19 <koeien> tgeeky: length [1..]
12:03:32 <koeien> this is _|_, but it does not contain undefined and friends
12:03:34 <tgeeky> koeien: so what is your opinion on implementing partial isomorphisms?
12:03:36 <vendekabyte> Leif_Bork: alright, bad example :)
12:04:02 <bos> preflex: seen dcoutts
12:04:02 <preflex>  dcoutts was last seen on #darcs 27 minutes and 3 seconds ago, saying: ah ok
12:04:34 <dcoutts> @yarr!
12:04:34 <lambdabot> Avast!
12:04:55 <tgeeky> koeien: what I'm trying to get at: if anything except total functions are evil, do you "morally" approve of using partial functions plus a default value to emulate a total function?
12:05:03 <tgeeky> or is that still evil?
12:05:21 <koeien> not all partial functions are evil, you just need to supply a proof
12:05:47 <Eduard_Munteanu> Then they're not really partial :)
12:06:02 * hackagebot resource-pool 0.2.1.0 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.1.0 (BryanOSullivan)
12:06:03 <Eduard_Munteanu> (it's just you can prove certain cases are absurd)
12:06:03 <monochrom> however, filer (\x -> x /= 0) or find or dropWhile is pure functional and KISS
12:06:04 <tgeeky> well, each function is :o
12:06:04 * hackagebot llvm 3.0.0.0 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-3.0.0.0 (BryanOSullivan)
12:07:15 <monochrom> not proving programs correct is evil
12:07:28 <tgeeky> it might be impractical
12:08:39 <monochrom> incorrect programs are impractical too. to the user. while the programmer already gets the money and runs away
12:09:00 <koeien> there are many very useful incorrect programs
12:09:14 <koeien> ghc, for example
12:09:22 <tgeeky> monochrom: I mean in the sense that, if you are trying to implement an invertible syntax from a language like GHC haskell
12:09:39 <tgeeky> and you are creating dozens of partial isomorphisms for different parts of the syntax
12:09:43 <tgeeky> it may be impractical to prove them all
12:09:57 <gwern> hm. how to filter a list such that all the entries of any repeated element is deleted... I guess I could do a filter, call elemIndices in it, and return False for anything with more than one entry. 'let y = [1,2,2,3,1] in filter (\x -> if length (elemIndices x) > 1 then False else True'
12:10:03 <monochrom> you can at least prove totality
12:10:16 <tgeeky> monochrom: well you can prove that anyway, with a pointed functor, right?
12:10:25 <Sgeo> Can't prove termination for all terminating functions
12:10:26 <gwern> > let y = [1,2,2,3,1] in filter (\x -> if length (elemIndices x y) > 1 then False else True) y
12:10:27 <lambdabot>   [3]
12:10:36 <gwern> well, it works anyway
12:10:50 <Sgeo> if blah then False else True
12:10:54 <Sgeo> Replace that with not blah
12:11:15 <gwern> Sgeo: fine! I'm sure hlint would've told me as much anyway!
12:11:19 <gwern> gosh you're ruining my life
12:11:27 <tgeeky> psahhhh!
12:11:31 <Sgeo> Sorry, can't say I haven't done that myself
12:12:45 <monochrom> I don't know how pointed functor helps prove totality. but if your point is that proving totality is easy and practical, then that proves my point.
12:14:19 <startling> If how can I use pattern matching for a case when two arguments are equal?
12:14:46 <koeien> f x y | x == y
12:14:47 <startling> oops, that first 'If' shouldn't be there.
12:14:55 <koeien> you can't use f x x = ...
12:14:59 <koeien> (as you might have observed)
12:15:06 <startling> exactly.
12:15:07 <startling> thanks
12:15:33 <Eduard_Munteanu> startling: those are "guards" if you're wondering
12:15:54 <startling> ah, cool. I'd hear that word tossed around and have been meaning to look it up. Thanks
12:17:58 <stbuehler> hi. i have this function 'storeNetworkInt :: (Integral i, Bits i, FS.Storable i) => i -> FP.Ptr x -> IO (FP.Ptr ())'; if i assign an alias in a different function and use the alias on Word16 and Word32, ghc gives an error. if i use the original function name it works
12:18:03 <stbuehler> how can i fix this?
12:18:04 <vendekabyte> haskell programmers prefer (a,b) (no space) over (a, b) everywhere, right?
12:18:11 <monochrom> both
12:18:29 <Eduard_Munteanu> Sgeo: yeah, but the question is whether you can program with provably total functions (assuming a sensible type theory and system), and it turns out you can.
12:18:29 <djahandarie> Don't forget about ( a , b )
12:18:59 <Eduard_Munteanu> I usually prefer (a, b).
12:19:12 <Eduard_Munteanu> djahandarie: Agda habits? :P
12:19:27 <koeien> > let f = id in (f 1, f "hello")
12:19:27 <Eduard_Munteanu> (for the comma)
12:19:27 <lambdabot>   (1,"hello")
12:19:29 <dolio> Agda doesn't require the spaces for the parens.
12:19:40 <monochrom> undecidability is a red herring and stupid excuse. humanity is unlikely to write all of the terminating programs.
12:19:42 <Eduard_Munteanu> Yeah, just _,_
12:20:25 <djahandarie> I was just trying to make it as obnoxious as possible.
12:21:06 <cheater> > (1, 2)
12:21:07 <lambdabot>   (1,2)
12:21:29 <vendekabyte> seems like haskell itself likes (a,b) but programmers like (a, b)
12:22:02 <monochrom> add and delete spaces as you see fit
12:22:09 <ClaudiusMaximus> > minBound :: (Int32, Word32)  -- wondering if there's Bounded instances for tuples
12:22:10 <lambdabot>   (-2147483648,0)
12:25:29 <Jonno_FTW> test
12:27:25 <vendekabyte> "Program error: undefined array element" how do i debug this?
12:27:32 <vendekabyte> that's the vaguest error ever
12:34:22 <stbuehler> let f = const 0 :: (Num i) => i -> i in (f $ 0 :: Integer, f $ 1 :: Int)
12:34:37 <stbuehler> let f = const 0 :: (Num i) => i -> i in (f $ 0 :: Int, f $ 1 :: Int)
12:36:24 <hunz_brazil> when I suffix an expression with a type signature. the type signature englobes everything to the right, just the last name/symble, or what?
12:36:45 <hunz_brazil> symble = symbol*
12:39:52 <Eduard_Munteanu> hunz_brazil: everything, unless you add parenthesis. I'm not sure if there's an exception.
12:40:34 <hunz_brazil> :t (0, 1 :: Int)
12:40:35 <lambdabot> forall t. (Num t) => (t, Int)
12:40:45 <Eduard_Munteanu> > concat $ [[1], [2]] :: [Int]
12:40:46 <lambdabot>   [1,2]
12:42:46 <hpaste_> Carpi pasted “Until the end of the universe” at http://hpaste.org/56422
12:43:17 <carpi> could someone please tell me whats happening?
12:43:23 <hunz_brazil> :t const 0 1 :: Int
12:43:24 <lambdabot> Int
12:43:32 <hunz_brazil> :t const 0 (1 :: Int)
12:43:33 <lambdabot> forall t. (Num t) => t
12:46:46 <carpi> http://hpaste.org/56422
12:46:55 <carpi> could someone please teka look ^^^?
12:47:42 <Sebasti0n> hey guys. I have some weird polymorphism problems. A function which should only be called once is called multiple times when I use polymorphism, when I use an actual type it is called just once. anybody know what could be the cause for that?
12:47:56 <mkscrg> what do i have to do to get my local haddocks to have the nice "source" links/pages that hackage has?
12:50:20 <startling> Say I have a recursive function with a state variable, and a second function wrapping the first and supplying it with a default state variable. How should I name these two functions?
12:50:59 <MostAwesomeDude> Name them whatever's comfortable.
12:51:55 <Saizan> Sebasti0n: if the polymorphic version has a typeclass context then that's just how it works, since it gets implemented as a function from the dictionary of methods
12:52:23 <startling> MostAwesomeDude: so there's not really a convention?
12:52:42 <Saizan> Sebasti0n: though it'd help if you showed some code
12:53:01 <MostAwesomeDude> startling: Not anything useful. Often a simpler or more direct name is used for the outer wrapper, since that's the one you intend to document and export to users.
12:53:03 <Sebasti0n> Saizan: What do you mean? The function shouldn't be called more than once should it? It has a severe impact on runtime
12:54:09 <startling> MostAwesome: mkay, that's what I was going with. Thanks
12:54:21 <monochrom> "Programmer error: undefined array element" is the clearest error message ever. in C, you don't even get an error message.
12:54:35 <Saizan> Sebasti0n: but everytime you call it you could be using it at a different type, and ghc doesn't do common expression elimination much
12:55:18 <monochrom> don't try to infer through human cleverness how many times a function is called
12:56:45 <Saizan> and there's no automatic memoization either, you've to do that yourself
12:57:05 <monochrom> Haskell is just a programming language, not a software architect.
12:57:10 <hpaste_> Sebasti0n pasted “Multiple Calls to vecLen” at http://hpaste.org/56423
12:58:10 <Saizan> the only thing GHC pretty much guarantees is that evaluating "let x = e in (x,x)" it'll evaluate e only once if x has a type without a typeclass context (i.e. without the C a => .. thing)
12:58:25 <Sebasti0n> Saizan:  When I change the signature of centroid to [Vector Double] -> Vector Double vecLen is called just once, when it is polymorph it is called multiple times during one function call
12:58:56 <Sebasti0n> at least that's what the profiler is telling me
12:59:07 <stbuehler> how can i force haskell to use the most generic type without actually specifying it?
12:59:09 <Sebasti0n> and I am having a similar problem somewhere else
12:59:34 <Sebasti0n> so I am really wanting to know what is going on
12:59:40 <Saizan> Sebasti0n: do you have the MonomorphisRestriction off?
12:59:44 <monochrom> normally, if you don't specify a type, the most generic type is inferred. there are exceptions if you use extensions
13:00:30 <Sebasti0n> Saisan: No, I have not extensions
13:00:31 <monochrom> I guess there is also an exception if you don't use a particular extension
13:01:43 <carpi> okay.. i solved the problem.. but it really makes me think that haskell is dead slow. when it was taking more than 20 minutes.. i thought i made a mistake somwhere.. but that doesn't seem to be the case.. after 20 minutes my code gav me the right answer..which leads me to believe that my code was correct..but haskell was dead slow..
13:01:55 <carpi> 20 minutes is simply inexcusable
13:02:23 <Saizan> Sebasti0n: can you show the code where you're calling centroid too?
13:02:36 <monochrom> I agree with you. prolog is faster.
13:02:37 <povman> carpi: you still have to design your software to be fast, it won't do that automatically.
13:02:46 <parcs`> stbuehler: it does that by default
13:02:54 <carpi> povman: what optimization could you possibly do in 4 lines of code?
13:02:56 <koeien> carpi: there are multiple problems with your code.
13:03:10 <koeien> carpi: for example, use Data.Set instead of lists if you want sets
13:03:19 <povman> carpi: can you show the source code?
13:03:37 <carpi> http://hpaste.org/56422
13:03:47 <monochrom> oh, 4 lines? I know how to drive the computer to spend 20 hours in just 1 line of code. "what optimization could you possibly do in 1 line of code?"
13:03:57 <koeien> http://bash.org/?152037 -- relevant
13:04:12 <Sebasti0n> Saizan: It is used in a type class and the type class. instance Cen Vector where  center = centroid
13:04:38 <carpi> koeien: could you please tell me why do you recommend data.set? what aspect of the problem makes you think that using data.set would make it run faster?
13:04:52 <monochrom> of course, the answer is: that 1 line of code is a slow algorithm. a faster algorithm takes 10 lines.
13:04:55 <shachaf> koeien++
13:05:33 <monochrom> Haskell is just a programming language, not a racing car engineer.
13:05:43 <koeien> carpi: you are not giving all code.
13:05:58 <koeien> carpi: i just read the python, saw that set() was being used, did not see set in your haskell code
13:06:06 <stbuehler> parcs`: i actually see the effect of MonomorphisRestriction - thx Saizan for mentioning
13:06:06 <monochrom> anyway, use prolog, it's faster, probably especially with your algorithm style
13:06:20 <carpi> koeien: Thanks for that link. even though i didn't read that earlier it was an enjoyable read : )
13:06:42 <koeien> carpi: alst really should be a Data.Set
13:06:53 <carpi> koeien: sory. ill re up the total code.. but im a beginner..so if you see something silly.. my apologies
13:06:57 <koeien> or IntSet
13:06:58 <Saizan> Sebasti0n: then you'd have to show how center is used, i.e. what are you profiling? or is it too big?
13:07:59 <koeien> carpi: a list has O(n) lookup, a Data.Set has O(log n)
13:08:08 <hpaste_> Carpi annotated “Until the end of the universe” with “Until the end of the universe (annotation)” at http://hpaste.org/56422#a56424
13:08:20 <carpi> almost total code.. ^^^^
13:09:02 <hpaste_> Sebasti0n pasted “Call to Center” at http://hpaste.org/56425
13:09:50 <koeien> carpi: right
13:10:03 <koeien> carpi: how are you evaluating this code? ghci ?
13:10:15 <carpi> koeien: do you think Data.Set would have made a huge difference in time taken?
13:10:17 <koeien> compiling your code is *way* faster
13:10:18 <carpi> koeien: yea in ghci
13:10:19 <koeien> carpi: yes.
13:10:40 <koeien> write abunlst = Set.fromList (...)
13:10:56 <koeien> add   import qualified Data.Set as Set
13:11:13 <koeien> instead of elem, use Set.member
13:12:06 <Sebasti0n> Saizan: I pasted the code
13:12:36 <Saizan> Sebasti0n: i don't have an answer though :)
13:13:00 <Leif_Bork> Is there any way to import hidden modules from other packages?
13:13:03 <carpi> koeien: is it possible that making those changes might bring it closer to the 3 seconds that the python version used..? after all, the algo used in both cases is quite similar..
13:13:11 <koeien> carpi: according to the manual, ghci is 10x slower than compiling.
13:13:16 <Saizan> maybe you could look at the generated core (with ghc-core) to see what GHC is doing
13:13:24 <Sebasti0n> Saizan: Ok, thanks anyway. I asked earlier and nobody had an idea either. This is not good
13:13:33 <hunz_brazil> is there any function with type (a, b) -> State b a?
13:13:43 <hunz_brazil> no luck at hoogle
13:14:01 <shachaf> hunz_brazil: Which does what? (\(a,b) -> put b >> return a)?
13:14:13 <monochrom> I need to check what State b a expands to
13:14:14 <hunz_brazil> shachaf: exactly
13:14:20 <monochrom> @unmtl State
13:14:20 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
13:14:24 <monochrom> @unmtl State b a
13:14:24 <lambdabot> b -> (a, b)
13:14:51 <carpi> ill make the changes and test it out.. i hope it don't take 20 minutes
13:14:57 <shachaf> hunz_brazil: Seems like a strange sort of function.
13:15:23 <monochrom> I dont know what to do with the extra b->
13:15:25 <hunz_brazil> I'm learning Haskell, so as a first attempt, I'm trying to do a dice roller
13:15:30 <koeien> carpi: i'm not convinced your algorithm is the same
13:15:34 <hunz_brazil> rollDice :: State StdGen Int
13:15:34 <hunz_brazil> rollDice = get >>= modifyAndReturn . randomR (1,6)
13:15:43 <hunz_brazil> modifyAndReturn is the function i'm looking for
13:15:56 <shachaf> It's not modifyAndReturn, it's putAndReturn.
13:16:15 <hunz_brazil> yes, you get it
13:16:16 <koeien> carpi: if you use the same algorithm, haskell is likely to be an order of magnitude faster than python
13:16:31 <shachaf> Anyway, it looks specialised enough that you should probably just define it yourself.
13:16:33 <carpi> koeien: i am sure it is.. because.. the author that wrote that python version uses the same constructs..
13:16:45 <carpi> koeien: any, `elem`
13:16:48 <shachaf> Maybe define a function that takes "randomR (1,6)" as an argument, rather than something that has to use get itself.
13:16:59 <carpi> ofcourse he uses the python version of those functions..
13:17:20 <carpi> the meat of the alogorithm is concentrated in the last few lines for the python version
13:17:36 <hunz_brazil> it just looks like a common case for the State monad
13:18:20 <shachaf> Doesn't look that common.
13:18:34 <shachaf> If anything (\a b -> put b >> return a) would seem to be more common.
13:18:44 <shachaf> At least it doesn't use a tuple.
13:18:44 <monochrom> a common case for using State for Random
13:18:59 <shachaf> But it still pretty much looks like two operations, so you might as well do two operations.
13:19:13 <hunz_brazil> I tried that:
13:19:18 <hunz_brazil> :t State (randomR (1,6))
13:19:18 <lambdabot> Not in scope: data constructor `State'
13:19:25 <hunz_brazil> :t state (randomR (1,6))
13:19:25 <lambdabot> forall t s. (Num t, Random t, RandomGen s) => State s t
13:19:29 <povman> carpi: the python one uses sets
13:19:31 <hunz_brazil> but this fails:
13:19:37 <hunz_brazil> :t get >>= state (randomR (1,6))
13:19:37 <lambdabot>     Couldn't match expected type `a -> m b'
13:19:37 <lambdabot>            against inferred type `State s t'
13:19:37 <lambdabot>     In the second argument of `(>>=)', namely `state (randomR (1, 6))'
13:19:57 <carpi> povman: thats the only difference.. though..
13:20:19 <monochrom> @type randomR
13:20:19 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:20:31 <povman> carpi: when he writes (n-a in abn) that operation is probably O(log n). Yours is O(n)
13:20:40 <povman> that is a WORLD of difference
13:20:46 <monochrom> then it's just state (randomR (1,6)), not get >>= state (randomR (1,6))
13:21:04 * hackagebot math-functions 0.1.1.0 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.1.0 (BryanOSullivan)
13:21:35 <povman> carpi: log(200000) = 12
13:21:49 <monochrom> do { x0 <- state (randomR (1,6)); x1 <- state (randomR (1,6)); return (x0+x1) }  throws 2 dice and adds them
13:22:18 <hunz_brazil> monochrom: worked… still don't quite get it, but worked
13:22:46 <hunz_brazil> and my haskell platform uses "State" constructor (capital S)
13:22:50 <monochrom> because state (randomR (1,6)) doesn't need a separate get
13:22:58 <povman> carpi: er, make that 17
13:23:36 <hunz_brazil> … because the monad binding does the state passing around
13:23:39 <hunz_brazil> right?
13:24:08 <carpi> povman: apologies in that case. ill make the changes koeien proposed to see if there is any difference.
13:24:15 <monochrom> yes
13:25:23 <hunz_brazil> monochrom: thank you
13:29:14 <cl1> i got a new irc client Pidgin
13:29:27 <cl1> aparently xchat is not free after 30 days
13:30:06 <cl1> could someone say something so I can at least be sure I'm seeing messages?
13:30:14 <startling> Say I want to construct a data type from a function. Is there a generic type for functions?
13:31:01 <erus`> a -> a
13:31:13 <erus`> a -> b *
13:31:17 <startling> oh, duh. Thanks
13:31:53 <monochrom> xchat is free on everywhere other than windows
13:32:08 <erus`> monochrom: xchat2 is free
13:32:15 <erus`> or was last time i checked
13:32:24 <monochrom> on windows, there is a paid xchat, and a free xchat, the later is by silverx
13:32:38 <erus`> chatzilla is the best on windows anyway :)
13:34:12 <monochrom> pidgin is not exactly suitable for irc. but it does enjoy a latex plugin, for those of you into latex worship
13:36:04 * hackagebot mwc-random 0.11.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.11.0.0 (BryanOSullivan)
13:36:05 <monochrom> if you get a chance to speak to #math residents, remind them of that.
13:36:06 * hackagebot statistics 0.10.1.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.1.0 (BryanOSullivan)
13:36:16 <Sgeo> There's another free XChat
13:36:24 <Sgeo> XChat-WDK
13:36:28 <Sgeo> Haven't tried it yet
13:36:39 <monochrom> nice, choice is good
13:37:45 <hunz_brazil> sortBy (flip compare) is better than reverse . sort, right?
13:37:51 <monochrom> yes
13:38:03 <DanBurton> well
13:38:14 <DanBurton> both sort and reverse need to consume the whole list before producing anything
13:38:25 <DanBurton> so in big-Oh terms they're the same
13:38:34 <hunz_brazil> yes
13:38:42 <cheater> monochrom: are you banned from #math ?
13:38:48 <monochrom> no
13:38:51 <hunz_brazil> but reverse . sort needs 2 traversals
13:38:52 <DanBurton> but sortBy (flip compare) is a little more kosher as far as style goes
13:39:03 <cl1> Sgeo .. gonna give that a try , thanks, pidgin sucks, its hard to read chat from all the enter leave stuff
13:39:54 <Sgeo> Pretty much all IRC clients show enter and leave, although usually in a different style. But at least in XChat, it can be disabled, I'd be surprised if it couldn't be in Pidgin
13:40:14 <Sgeo> But still, Pidgin is not a great IRC client in general
13:40:25 <monochrom> I enjoy the enter-leave
13:40:26 <hunz_brazil> reverse is O(n)… what kind of sort does "sort" do?
13:40:41 <monochrom> usually merge sort
13:41:03 <Martty> bucket sort
13:41:10 <monochrom> sort du jour
13:41:55 <hunz_brazil> what does "sort du jour" means?
13:41:59 <Martty> bogosort
13:42:02 <monochrom> soup of the day
13:42:39 <Sgeo> > sortBy (const LT) [1,5,2,6,3,7]
13:42:40 <lambdabot>   Couldn't match expected type `a -> GHC.Ordering.Ordering'
13:42:40 <lambdabot>         against i...
13:42:47 <Sgeo> :t sortBy
13:42:48 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:43:00 <Sgeo> > sortBy (\_ _ -> LT) [1,5,2,6,3,7]
13:43:01 <lambdabot>   [1,5,2,6,3,7]
13:43:10 <Sgeo> > sortBy (\_ _ -> GT) [1,5,2,6,3,7]
13:43:11 <lambdabot>   [7,3,6,2,5,1]
13:44:03 <monochrom> motorsports? are you a racing car engineer?
13:44:17 <cl1motorsports> lol, used to be a race car driver a LONG time ago
13:44:34 <cl1motorsports> hmm, i can't seem to change my nick
13:44:54 <Sgeo> cl1motorsports, cl1 may not have disconnected
13:44:59 <srhb> cl1motorsports: You might be in a channel that requires you to be registered.
13:45:05 <monochrom> because cl1 hasn't signed off
13:46:20 <monochrom> terminate pidgin or instruct pidgin to disconnect from the irc account
13:47:16 <cl1motorsports> pidgin has the dumb
13:47:46 <dmwit> If cl1 is registered, you can also ask NickServ to ghost it.
13:49:19 <cl1> ah, much better
13:50:09 <hpaste_> koeien annotated “Until the end of the universe” with “Until the end of the universe (annotation) (annotation)” at http://hpaste.org/56422#a56426
13:50:25 <koeien> carpi: much better ^
13:54:06 <gregATio> osmoco
13:54:30 <koeien> replace Data.Set by Data.IntSet and it's much faster, under 0.5 s on my machine
13:59:56 <hunz_brazil> considering that a function has two possible flows depending only on one conditional… what is more common in Haskell, two guards (one with conditional, one with "otherwise") or a if?
14:01:04 <koeien> most likely, the former
14:01:53 <hunz_brazil> e.g. f a b = if a > b then 0 else 1
14:02:07 <koeien> yeah i'd write this as f a b | a > b = 0
14:02:11 <koeien> and so on
14:02:21 <koeien> although your version is perfectly fine
14:02:36 <Guest41493> hi, can anyone please point me to papers or websites explaining how pattern matching is implemented in GHC? or should this go to #haskell-in-depth?
14:02:53 <ddarius> > f a b = fromEnum (a > b)
14:02:53 <lambdabot>   <no location info>: parse error on input `='
14:03:07 <koeien> you could read the papers on spineless tagless g-machine
14:03:45 <blobl> i want to read that
14:03:45 <cl1> :)
14:03:54 <cl1> yay! no moar smileys
14:03:56 <Guest41493> isn't that for how it's implemented on hw?
14:03:59 <hunz_brazil> or even the way ddarius points to… writing other function pattern matching on True and False
14:04:13 <koeien> no, the spineless tagless g-machine is an abstract machine that GHC compiles to
14:04:28 <Guest41493> ah, nice.
14:04:43 <Guest41493> thanks, are there any other references that come to mind?
14:04:56 <DanBurton> > let const2 x _ _ = x in sortBy (const2 GT) [1,3,5,7] -- does const2 exist already somewhere?
14:04:57 <lambdabot>   [7,5,3,1]
14:05:12 <ddarius> :t const . const
14:05:13 <lambdabot> forall b a b1. a -> b -> b1 -> a
14:05:15 <koeien> const . const
14:05:22 <DanBurton> well sure
14:05:26 <koeien> > (const . const $ 100) 2 3
14:05:27 <ddarius> Or \x _ _ -> x
14:05:28 <lambdabot>   100
14:05:39 <DanBurton> but I mean is it predefined under a single name somewhere?
14:05:42 <koeien> no
14:06:01 <monochrom> Guest41493: http://www.mail-archive.com/haskell-cafe@haskell.org/msg96279.html
14:06:33 <Guest41493> cheers koeien, much appreciated :)
14:06:46 <hunz_brazil> :t on
14:06:46 <startling> how can I do this? http://bpaste.net/show/21802/
14:06:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:06:49 <mercury^> Endofunctions should be a Monoid, and for monoids exponentiation by Integers should be defined.
14:07:03 <ddarius> @src (^)
14:07:03 <lambdabot> x ^ 0            =  1
14:07:03 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
14:07:03 <lambdabot>   where f _ 0 y = y
14:07:03 <lambdabot>         f x n y = g x n
14:07:03 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
14:07:05 <lambdabot>                       | otherwise = f x (n-1) (x*y)
14:07:07 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
14:07:14 <DanBurton> @djinn a -> b -> c -> a
14:07:15 <lambdabot> f a _ _ = a
14:07:17 <ddarius> Simple replace (*) with mappend and 1 with mempty.
14:07:35 <koeien> startling: yes, forall a b. SomethingCOnstructor (a -> b) [Char]
14:07:39 <mercury^> Ah, so lambdabot can actually do this?
14:07:40 <koeien> enable ExistentialTypes.
14:07:50 <koeien> however, you cannot do much which this definition!
14:07:51 <mercury^> > const^2 100 2 3
14:07:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
14:07:52 <lambdabot>    arising from a use...
14:07:52 <cl1> why would I not be able to post to the haskell-cafe mailing list?
14:07:55 <koeien> what would you like to accomplish?
14:08:17 <koeien> ExistentialQuantification*
14:08:43 <koeien> you can also do this, data S a b = SConstr (a -> b) [Char]
14:09:18 <koeien> this is a more useful definition
14:10:23 <Axman6> cl1: are you subscribed?
14:10:56 <startling> koein: thanks!
14:11:45 <cl1> yes, my first post got rejected by haskell-cafe-owner@haskell.org, it said i'm not allowed to post to this mailing list, and my message was automatically rejected
14:11:54 <cl1> i signed up through google groups
14:12:28 <hunz_brazil> can I declare somehow to GHC that two types are isomorphic so it automatically "coerce" types? (something like applying "on" to every function with the correct forward/backward functions from my isomorphic declaration)
14:13:29 <c_wraith> GHC will never automatically convert expressions between different types
14:14:16 <c_wraith> That's an important part of making type inference work, actually
14:14:25 <monochrom> be careful with "never", TNDR comes close to breaking it
14:14:40 <monochrom> err, TDNR
14:14:49 <c_wraith> isn't that still...  not in GHC?
14:14:55 <monochrom> thankfully
14:15:05 <eikke> anyone using Repa?
14:15:07 <hunz_brazil> sorry, what is TDNR?
14:15:17 <koeien> TDNR is evil
14:15:21 <koeien> type driven name resolution
14:15:44 <hunz_brazil> lots of things are evil
14:16:11 <c_wraith> still, I did mean "never" as in "in no circumstances, the way it works", instead of "at no time in the future".  So yes, I should have been more careful
14:16:13 <monochrom> type-directed name resolution. it means you can have an identifier with many unrelated definitions and types, and then the "right" definition is chosen at every call site
14:17:02 <hunz_brazil> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
14:17:04 <monochrom> I am just teasing you. or teasing TDNR
14:17:15 <c_wraith> regardless, you have a point. :)
14:18:44 <hunz_brazil> but if I declare the types to be isomorphic, ghc can pick either
14:19:14 <monochrom> there is no syntax to declare isomorphism yet
14:19:26 <dmwit> There is syntax for isomorphisms, but not for equalities.
14:19:36 <koeien> newtype
14:19:39 <dmwit> (newtype introduces an isomorphism)
14:19:43 <koeien> but there is no "automatic selection"
14:20:01 <koeien> you can introduce a new name for a type with type
14:20:15 <koeien> e.g. type String = [Char]
14:20:18 <monochrom> it is good enough that literals like 0 are automatically converted
14:20:20 <dmwit> There is some measure of automatic selection via the typeclass mechanism... and perhaps even enough to make hunz_brazil happy.
14:20:25 <koeien> this lets you freely interchange String and [Char]
14:21:55 <dmwit> It might be worth asking for a bit more detail about what hunz_brazil is trying to accomplish.
14:22:28 <hunz_brazil> dmwit: I'm not trying to make myself happy, I'm trying to understand how Haskell works. Why we use it like this. Why we have no type isomorphisms declarations, etc. I'm just trying to understand, not trying to change things
14:23:07 <dmwit> We do have type isomorphism declarations.
14:23:16 <monochrom> you will not get satisfactory answers for those questions. not just for Haskell. for any programming language.
14:23:42 <dmwit> We don't have structural equality on types because that makes type inference undecidable.
14:24:38 <hunz_brazil> monochrom: just trying to figure out why things are like that
14:25:26 <mceier> there are undecidable instances, so why not have undecidable type inference ? :D
14:25:29 <hunz_brazil> is there any paper/tutorial/text I could read to get more information about that?
14:25:50 <monochrom> why is lambda in Python under such and such restrictions? because a group of people hated lambda. there is no deeper reason. the same is true for several decisions in Haskell.
14:25:58 <dmwit> Yes, TAPL has a good chapter on the difference between equirecursive and isorecursive types.
14:26:39 <monochrom> you are looking at a programming language crafted out by humans, not calculated out by an optimization algorithm
14:26:58 <byorgey> mceier: you can get undecidable type inference by turning on certain extensions, just like you can get undecidable instances by turning on an extension.
14:27:27 <mceier> oh, I didn't know, which extension enables undecidable type inference ?
14:27:31 <hunz_brazil> monochrom: I'm trying to get myself at the level of those humans
14:27:36 <dmwit> RankNTypes
14:27:36 <byorgey> RankNTypes, for example
14:27:42 <mceier> thanks :)
14:27:58 <mmos1127> I just installed binary-strict because I want to use a version of Data.Binary with strict ByteStrings. After the successful install I tried a module with "import Data.Binary.Strict"  but got an error that it can't find that. What's the module called?
14:28:32 <dmwit> mmos1127: Check the documentation?
14:28:35 <byorgey> @package binary-strict
14:28:36 <lambdabot> http://hackage.haskell.org/package/binary-strict
14:28:36 <dmwit> ?hackage binary-strict
14:28:36 <lambdabot> http://hackage.haskell.org/package/binary-strict
14:28:49 <ion> mmos1127: Dunno (check the package’s documentation), but there’s also cereal which uses strict ByteStrings.
14:29:04 * koeien thought cereal was the standard strict binary
14:29:33 <ion> If binary-strict (which i haven’t looked at) mirrors binary too closely, it also has the defect of decode raising exceptions for no reason.
14:29:43 <ion> Cereal doesn’t.
14:30:04 <mmos1127> I'm confused because I've used Data.Binary and that only requires one import, but there are many modules in binary-strict. Can I just import one? Does it work the same way as the lazy version?
14:31:02 <mmos1127> Maybe there is another way to solve my problem. I want to read a file with binary data, alter that data, and write it back. I can't open it for write because it's still open for read.
14:31:16 <c_wraith> mmos1127: modules can re-export other modules, to cut down on required imports
14:32:56 <cl1> you people keep spitting out concepts I do not know. It's making me go crazy.
14:33:42 <hunz_brazil> any prerequisite to read TAPL?
14:33:56 <c_wraith> determination
14:34:18 <monochrom> money or library or piracy
14:34:30 <monochrom> (I chose piracy!)
14:35:23 <tazjin> monochrom: We have tracked you and reported you to the cyber police. Consequences will never be the same etc. etc.
14:35:26 <hunz_brazil> hahahah… I'm going to buy it, $52.76 + shipping to brazil, should I read anything else first or is it a good introductory book for types?
14:35:38 <NapHtaKeRoSene> :)
14:35:53 <monochrom> it is a good introductory book for types
14:39:39 <mmos1127> Okay I solved it--it's easy to convert strict bytestrings to lazy.
14:41:23 * DanBurton bought himself TAPL for Christmas
14:41:56 <Guest41493> is there anything specific in lambda calculus theory that allows for pattern matching e.g. reduction, or is it simply an artefact of functional programming languages?
14:42:27 <mjrosenb> Guest41493: lisp and scheme do not have pattern matching
14:42:30 <DanBurton> Guest41493: pure lambda calculus?
14:42:46 <Guest41493> yes
14:43:05 <DanBurton> You could always define pattern matching as sort of a macro for the accessor functions
14:43:15 <DanBurton> irrefutable matches, anyways
14:43:38 <DanBurton> pattern matching in the sense of choosing the correct pattern to match...not so much
14:45:02 <c_wraith> lots of people have invented pattern-matching macros in lisps
14:45:08 <mjrosenb> pattern matching need not be tied to functional languages.
14:45:09 <DanBurton> assuming, of course, that you have defined said accessor functions
14:45:19 * mjrosenb wrote a pattern matching library in C++
14:45:38 <DanBurton> I know Racket has some pattern matching functionality
14:45:50 <DanBurton> @google racket pattern match
14:45:51 <lambdabot> http://docs.racket-lang.org/reference/match.html
14:45:51 <lambdabot> Title: 8 Pattern Matching
14:46:10 <monochrom> pattern matching in java: http://www.vex.net/~trebla/humour/Nightmare.java
14:46:13 <DanBurton> lambdabot/google...surprisingly relevant
14:47:30 <DanBurton> monochrom: using Exceptions to pattern match...I'm not sure if I'm impressed or repulsed :)
14:48:05 <monochrom> like the name says, you should be nightmared :)
14:48:13 <DanBurton> u.u
14:48:31 <hunz_brazil> ouch
14:49:21 <hunz_brazil> at least the compiler do not let you have a partial match
14:49:56 <Guest41493> so how does Haskell implement pattern matching? does it use a data type's constructor to pull the data apart?
14:50:23 <c_wraith> haskell values contain a word which is "the constructor used"
14:50:25 <DanBurton> Guest41493: I assume you mean GHC? The Haskell language doesn't specify a certain way you must implement it.
14:50:34 <c_wraith> right.  I should have said GHC
14:50:42 <Guest41493> yes, in GHC
14:50:46 <monochrom> Haskell doesn't implement anything. GHC and Hugs do. they use tags.
14:50:50 <c_wraith> pattern-matching means looking at that word and branching on it
14:51:10 <c_wraith> (possibly after evaluating the constructor, if it wasn't already evaluated)
14:51:29 <hunz_brazil> is this runtime type information?
14:51:30 <DanBurton> how exactly is that done? a hashed lookup? binary search?
14:51:49 <c_wraith> no, it contains no type information
14:52:02 <monochrom> no, no runtime type information. therefore, False and Nothing look the same at run time
14:52:09 <mjrosenb> so this means I can't have a datatype with more that 2^32 constructors?
14:52:19 <monochrom> isNothing x = unsafeCoerce x  works
14:52:21 <c_wraith> mjrosenb: less than that actually
14:52:33 <mjrosenb> c_wraith: not suprised :-p
14:52:44 <DanBurton> mjrosenb: if you have more than, say, 100 constructors, you are very likely doing it wrong ;)
14:52:45 * mjrosenb assumes more bits are stolen for other nefarious purposes
14:52:47 <ion> Please release an Acme package that has a type with the maximum possible number of data constructors.
14:53:00 <c_wraith> ion: I'm pretty sure that'd take years to compile.
14:53:06 <c_wraith> and more ram than I have.
14:53:10 <ion> Perhaps starting with False | True | FileNotFound
14:53:17 <c_wraith> that's a good starting point
14:53:18 <mjrosenb> DanBurton: data TagNum a = One a | Two a a | Three a a a | Four...
14:53:20 <mjrosenb> :-p
14:53:31 <DanBurton> -____-
14:53:55 <mjrosenb> DanBurton: oohh, we can make this more fun!
14:53:58 <monochrom> a tag is just a number. use a number to stand for False, another number to stand for True, etc
14:54:23 <DanBurton> I suppose that makes deriving Enum easy
14:54:31 <c_wraith> I think ghc steals two bits from the tag word...  to indicate whether it's been evaluated, or if it's evaluating, if it's been blackholed
14:54:36 <mjrosenb> data TagNum a = One a | Two (TagNum a) | Three (TagNum (TagNum a)) ...
14:54:48 <c_wraith> actually, it doesn't need to steal bits for those.  Just certain constants
14:54:52 <monochrom> the whole of "Just blahblah" is one number for Just and one pointer for blahblah
14:54:58 <c_wraith> so that doesn't steal powers of two, just a couple entries
14:55:20 <hunz_brazil> so a Int is never using only 32 bits?
14:55:30 <mjrosenb> c_wraith: but how do you know what the constructor was while it is being blackholed?
14:55:48 <c_wraith> mjrosenb: well, you don't.  That's the reason it's black holed in the first place
14:56:47 <c_wraith> mjrosenb: a black hole is the value set by the threaded runtime while it's evaluating the thunk to determine what constructor is used, to prevent other threads from also evaluating that thunk in parallel.
14:57:28 <mjrosenb> c_wraith: oh...
14:57:34 <mjrosenb> yeah that makes sense
14:57:49 <monochrom> actually we are a bit lying. GHC uses more than tags. but tag is a part of it.
14:58:54 <c_wraith> everything else is an optimization
14:59:01 <c_wraith> tags are simple, and part of what it does
14:59:06 <c_wraith> so it's best to start the explanation there
14:59:10 <monochrom> actually, tag is the optimization
15:00:38 <monochrom> Simon Peyton McLuhan says, "tag is not being optimized. tag is the optimization." :)
15:03:16 <monochrom> up to a certain version of GHC, "Just blah" is two pointers, one for "Just", one for "blah". the optimization later: observing that pointers have to be 32-bit aligned or 64-bit aligned anyway, we have 2-3 bits in the first pointer for our own use, and so 1 bit is used for "thunk vs whnf", and the other 1-2 bits are for tag.
15:03:38 <monochrom> oh well
15:04:16 <monochrom> I guess my thesis has more readers than whatever I write here.
15:04:41 <hunz_brazil> I did read
15:05:51 <hunz_brazil> so, at runtime, the bit for "evaluated?" is always checked?
15:06:13 <monochrom> yes
15:08:45 <hunz_brazil> so, every value in haskell occupies at least 3 bytes… one for the flag/tag/etc, one for the pointer, at least one for the real structure
15:09:24 <hunz_brazil> and every access needs a check and a pointer dereference
15:09:26 <monochrom> no, the pointer and the flags+tags merge into one machine word
15:11:33 <c_wraith> also, if you're looking at efficiency limits, note that ghc is more clever for types it can determine are used as primitives
15:13:10 <hunz_brazil> um
15:13:36 <c_wraith> in particular, for numeric stuff
15:14:21 <c_wraith> ghc, when using optimizations, can often find cases where it can leave all the pointer tagging stuff out of Ints and the like
15:14:30 <hunz_brazil> I have no idea if this sounds insane, but… data Bool = True | False … does GHC optimizes memory usage of [Bool]?
15:14:36 <c_wraith> no, it does not
15:14:44 <c_wraith> [Bool] is horribly memory-expensive
15:14:45 <dmwit> No, it does not. However, there is an optimized version of Array foo Bool.
15:14:48 <dmwit> err...
15:14:48 <monochrom> when unoptimized, "5 :: Int" is two machine words, the second word has the 101. sometimes, optimizations can waive the first word.
15:14:54 <c_wraith> but then [] is horribly memory-expensive
15:14:54 <dmwit> UArray foo Bool, I mean.
15:15:40 <hunz_brazil> is it even possible for a compiler to optimizes things like that?
15:16:07 <hunz_brazil> (in this very current day)
15:16:50 <Jafet> A compiler shouldn't.
15:16:53 <c_wraith> Not without more information than just the type
15:17:14 <dmwit> Yeah, you need to be a bit careful about optimizing lists, especially in the presence of laziness.
15:17:28 <Jafet> [Bool] isn't exactly the same as UArray a Bool, or even Array a Bool.
15:17:36 <Jafet> http://stackoverflow.com/a/3256825
15:17:39 <hunz_brazil> um… dmwit, didn't remember the non-strict part
15:18:07 <Jafet> Often, the extra pointers do mean something to your program.
15:20:18 <c_wraith> Jafet's link to stackoverflow is especially nice because the answer it links to was provided by Simon Marlow, who's responsible for the most parts of GHC that generate code.
15:20:24 <hunz_brazil> thanks for the link Jafet
15:20:47 <c_wraith> No one knows more than him about how GHC-generated code works.
15:21:37 <JoeyA> Is it possible to do something like threadWaitRead on a Handle (in particular, one returned by Network.connectTo or Network.accept) ?
15:21:57 <c_wraith> No.  You need to get the underlying file descriptor
15:22:36 <c_wraith> however, threadWaitRead is used in the implementation of just about everything that reads from the handle, so...  Maybe don't even worry about it?
15:23:22 <c_wraith> threadWaitRead should only be used if you're writing new low-level operations in terms of some non-blocking FFI interface
15:24:07 <hunz_brazil> a function declaration takes memory?
15:25:02 <c_wraith> declaration?  at compile-time, sure.  At run-time, only definitions take memory
15:25:22 <c_wraith> I mean, a function requires code.  That takes memory
15:26:23 <hunz_brazil> defining an auxiliary function to clean your code consumes more memory?
15:26:48 <c_wraith> That is very hard to answer.
15:26:53 <c_wraith> Maybe, maybe not.
15:26:58 <c_wraith> furthermore, does it matter?
15:27:07 <c_wraith> the code needs to exist one way or the other.
15:27:09 <c_wraith> code takes memory
15:27:40 <c_wraith> ghc might inline an auxiliary function, it might not.  Either one of those could result in slightly larger compiled code
15:27:53 <c_wraith> But...  Does it really matter?
15:28:13 * cmccann prefers to write his programs using only platonic ideals that require no memory, because they exist independently of any tangible incarnation
15:28:46 <Jafet> perl code uses less memory than platonic ideals
15:29:46 <hunz_brazil> c_wrath not at the moment
15:30:13 <hunz_brazil> just seems difficult to reason about the cost of a Haskell piece of code
15:31:34 <mikeplus64> > #1
15:31:34 <Jafet> Haskell doesn't specify the cost of most things.
15:31:34 <lambdabot>   not an expression: `#1'
15:31:43 <Jafet> Generally, we talk about the cost in Glasgow Haskell.
15:31:53 <c_wraith> :t 1#
15:31:53 <lambdabot> GHC.Prim.Int#
15:32:02 <dmwit> > 1#
15:32:03 <lambdabot>   Couldn't match kind `#' against `*'
15:32:08 <dmwit> > I# 1#
15:32:09 <lambdabot>   Not in scope: data constructor `I#'
15:32:12 <Jafet> > Int# 1#
15:32:13 <lambdabot>   Not in scope: data constructor `Int#'
15:32:16 <hunz_brazil> > 1 :: Int#
15:32:17 <mikeplus64> what is the purpose of the #?
15:32:17 <lambdabot>   Not in scope: type constructor or class `Int#'
15:32:21 <Jafet> > I# 1#
15:32:22 <lambdabot>   Not in scope: data constructor `I#'
15:32:25 <cmccann> mikeplus64, magic
15:32:27 <dmwit> mikeplus64: magic
15:32:32 <cmccann> heh
15:32:32 <mikeplus64> ._.
15:32:39 <c_wraith> Jafet: I think you need to specify the package
15:32:46 <c_wraith> > GHC.Prim.I# 1#
15:32:47 <lambdabot>   Not in scope: data constructor `GHC.Prim.I#'
15:32:56 <cmccann> mikeplus64, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#magic-hash
15:32:56 <c_wraith> of course, if I knew what package it was in, it'd help
15:33:41 * cmccann was not actually kidding about "magic", as you can see
15:34:05 <mikeplus64> ah, it's for unboxed types?
15:34:18 <cmccann> It's for a variety of magic internal stuff
15:34:25 <int-e> :k (->)
15:34:26 <lambdabot> ?? -> ? -> *
15:35:08 <cmccann> unboxed values being one important kind of magic internal stuff
15:37:46 <hunz_brazil> any book recommendation for learning Haskell? (other than Learn you a Haskell for great good and Real world Haskell)
15:38:55 <c_wraith> @hoogle I#
15:38:56 <lambdabot> GHC.Exts I# :: Int# -> Int
15:39:06 <c_wraith> > GHC.Exts.I# 1#
15:39:06 <lambdabot>   Not in scope: data constructor `GHC.Exts.I#'
15:39:14 <c_wraith> guess it's not available
15:40:18 <Axman6> hunz_brazil: well you've already mentioned the best two
15:40:54 <hunz_brazil> Haskell: The craft of functional programming is good?
15:41:04 <Axman6> sure, if a little old
15:41:31 <hunz_brazil> 3rd edition is from 2011
15:41:47 <Axman6> hmm, i wonder whats changed
15:41:56 <Axman6> there's some good stuff in it though, we used it at university
15:56:04 <elliottt> what does the package versioning policy require for a bug fix that doesn't change the interface?
15:56:18 <elliottt> minor-minor update?
15:56:22 <elliottt> or minor update?
15:58:39 <int-e> bump 4th field
15:59:02 <elliottt> thanks :)
16:00:25 <int-e> I guess that's minor-minor, naming the fields major-major, major, minor, minor-minor and so on
16:02:16 <elliottt> so many names
16:10:44 <mikeplus64> suppose I want a "plus or minus function", is there a way to us ± without it being interpretted as a infix operator?
16:11:57 <mikeplus64> I could just do x ± y = (x + y, x - y) and do 0 ± something, nevermind
16:16:04 <elliottt> mikeplus64: you can use (+) x y, if that's what you're after
16:16:18 <gwern> > (36 / 958) * 100
16:16:19 <lambdabot>   3.7578288100208765
16:18:48 <cl1> can lambdabot tell me kinds?
16:19:06 <sipa> :k Functor
16:19:07 <lambdabot>     Class `Functor' used as a type
16:19:08 <lambdabot>     In the type `Functor'
16:19:16 <sipa> :k Maybe
16:19:17 <lambdabot> * -> *
16:19:32 <cl1> :k 1
16:19:33 <lambdabot> *
16:20:03 <cl1> so does Functor not have a kind?
16:20:08 <sipa> Functor is a class
16:20:12 <cl1> :k Monad
16:20:13 <lambdabot>     Class `Monad' used as a type
16:20:13 <lambdabot>     In the type `Monad'
16:20:21 <sipa> i.e. a set of types
16:20:36 <cl1> i asked a yes or no question :|
16:21:25 <sipa> unless you have the ConstraintKinds extension, no
16:21:27 <sipa> otherwise, yes
16:22:42 <sipa> if so, the kind of Functor would be (* -> *) -> Constraint
16:27:11 <cl1> :k []
16:27:12 <lambdabot> * -> *
16:27:20 <cl1> :k(,,)
16:27:26 <cl1> :k (,,)
16:27:27 <lambdabot> * -> * -> * -> *
16:27:39 <cl1> :k ,,
16:27:40 <lambdabot> parse error on input `,'
16:29:01 <cl1> so an instance of Functor or Monad would have type * -> *
16:35:06 <shapr> SHAZAM!
16:44:23 <cl1> Monad is the only class that gets do notation?
16:44:33 * cl1 thinks this is starting to sink in
16:45:05 <alistra> :t gets
16:45:06 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
16:45:23 <cmccann> cl1, it's more the other way around
16:45:39 <cmccann> do notation is defined in terms of the Monad type class
16:46:32 <alistra> there's like an ultra snow storm here
16:46:49 <alistra> it was normal one minute ago
16:48:26 <cl1> so if my type implements Monad I get do notation, because do notation is defined in terms of monad. do notation does not make sense for any other type class because of this.
16:48:28 <cl1> correct?
16:49:04 <cl1> alistra, that sucks
16:49:21 <cmccann> cl1, unless you include type classes that require an instance of Monad for their own instances
16:49:45 <cmccann> e.g. stuff like MonadPlus
16:50:31 <cl1> cmccann, that's just like inheritance
16:50:45 <cmccann> not really
16:51:01 <cmccann> comparing type classes to classes in OOP is usually not helpful
16:51:14 <cmccann> more likely to confuse you than help
16:51:30 <alistra> well, it's a dependency
16:51:40 <alistra> probably java has some interface dependency gizmo
16:51:53 <alistra> that's exactly nearly probably similiar to haskell
16:52:52 <cl1> if MonadPlus requires my type to be an instance of Monad in order to work, that is no different than ParentClass requiring ChildClass to implement method foo from GrandParent class of which ParentClass inherits
16:52:56 <cmccann> interfaces are a bit closer to type classes, though interfaces are usually much more limited
16:52:59 <cl1> .. you have to do it, or your code won't work
16:53:43 <cl1> the only limit i see to interfaces in c# vs type classes in haskell is that c# interfaces cannot generalize across types by kind
16:54:09 <cmccann> cl1, partly in depends on your definition of inheritance, a lot of different things get lumped together
16:55:04 <JoeyA> Are these STM transactions equivalent? :
16:55:05 <cmccann> cl1, interfaces make it clumsy or impossible to specify that the implementing type appears anywhere other than as the first argument
16:55:06 <JoeyA> atomically $ (readTVar v >>= \x -> if x then return Nothing else retry) `orElse` (Just <$> readTChan chan)
16:55:13 <JoeyA> versus: atomically (readTVar v >>= \x -> if x then return Nothing else Just <$> readTChan chan)
16:56:21 <cmccann> cl1, interfaces are also usually interchangeable with concrete types in a way that type classes aren't, except via existential quantification and the associated headaches
16:56:21 <JoeyA> I'd think they would be equivalent.  The only difference is that I don't use an orElse, but replace the retry in the left side with the right side.
16:59:20 <JoeyA> I guess the only difference is: if we replace readTVar with something that retries, then it wouldn't permit the readTChan to succeed instead.
16:59:26 <cl1> cmccann, what do you mean "anywhere other than as the first argument"?
17:01:13 <cmccann> cl1, interfaces seen as type classes generally restrict all functions to have types of the form "a -> ..." where a is the type class parameter
17:01:31 <cmccann> corresponding to the implicit this/self/whatever argument in an object's method
17:01:56 <cl1> :k [Int]
17:01:57 <lambdabot> *
17:01:58 <cmccann> you have to jump through extra hoops to do things like "a -> a -> a"
17:02:13 <cmccann> and stuff like "mempty :: a" is usually impossible
17:02:40 <cl1> yes, that's what i was refering to, they can't generalize by kind
17:02:54 <cmccann> no, kind is something else
17:03:14 <cl1> I can't define an interface like IFoo<T<U>> where T is obviously of kind * -> *
17:03:36 <cmccann> mempty and such would be like interfaces including constructors or static methods or constant values
17:03:39 <cl1> i can only specify type parameters that are of kind *
17:04:06 <cl1> cmccann, i can do static methods on interfaces in c# with extension methods
17:04:37 <cl1> the problem is,  I can only have one, not an implementation for each class that implements the interface
17:04:45 <cmccann> right, which misses the point
17:05:03 <cl1> yes
17:05:44 <cl1> is the lack of generic type parameters of kind greater than * that totally limits interfaces, that single concept allows so much more in haskell's types
17:05:56 <cl1> s/is/it's/
17:06:10 <cl1> its pretty epic actually
17:06:26 <cmccann> yes, the limitations on stuff with kind * mostly has workarounds
17:06:29 <cmccann> even if ugly
17:07:26 <cmccann> the limitation on kinds is much trickier and pretty much impossible
17:07:26 <shachaf> That's not the only difference between type classes and interfaces.
17:08:14 <shachaf> Haskell type classes were apparently restricted to * originally.
17:08:37 <cmccann> shachaf, it's the biggest one that can't be circumvented in cases when you can modify both the instance and interface definitions
17:09:00 <cmccann> er, class and interface, meaning the OO end of stuff
17:09:16 <cmccann> I really wish Haskell didn't have so much terminology overlap here
17:10:08 <shachaf> http://lambda-the-ultimate.org/node/3051
17:10:26 * shachaf Proof by ddarius said so.
17:10:35 <cmccann> anyway, there's also some utility to types standing on their own, with type classes having only explicit prerequisites
17:10:43 <cmccann> rather than dying it all into a huge tangled mess of subtyping
17:11:16 <cmccann> ...tying, not dying
17:11:29 <cmccann> heh
17:11:42 <cmccann> so many typos tonight :T
17:12:24 <shachaf> cmccann: "typo" is the term I use for a type error.
17:12:35 <shachaf> Actually I've never used it. But I keep meaning to.
17:12:54 <cmccann> good plan
17:25:10 <Axman6> > [chr 45 .. chr 66]
17:25:11 <lambdabot>   "-./0123456789:;<=>?@AB"
17:25:15 <Axman6> hmm
17:33:31 <dgpratt> does there already exist a factorial function in the standard Haskell libraries?
17:34:01 <shachaf> product [1..n]
17:34:10 <shachaf> @where evolution
17:34:11 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:34:34 <dgpratt> shachaf: that'll do :) thanks
17:34:41 <olsner> and *all* those factorial functions exist in the standard library :>
17:34:47 <olsner> in some sense, anyway
17:36:37 <sipa> > (product . fromTo 1) 5
17:36:38 <lambdabot>   Not in scope: `fromTo'
17:37:00 <sipa> > (product . enumFromTo 1) 5
17:37:02 <lambdabot>   120
17:37:37 <shachaf> We should have that rule where you're never allowed to say something that anybody has ever said before.
17:37:47 <shachaf> This channel would die quickly, of course.
17:38:02 <sipa> people would just add spaces at the end
17:38:10 <shachaf> We would eliminate those people.
17:38:49 <mokus> there's only so many ways you can do that before you start repeating your eliminations
17:39:28 <JoeyA> The Haskell way: don't fix your program; fix the world.
17:59:58 <monochrom> spaces are better used for operator precedence than uuid'ing messages
18:01:54 <monochrom> and I'd better start saying my urls like http://www.vex.net/~trebla/haskell/sicp.xhtml?uuid=394845 . apparently the world still needs me to repeat my urls for quite a while.
18:04:41 <shachaf> monochrom: You should have a domain name instead of a subdirectory on your ISP.
18:05:49 * shachaf notes that treb.la is currently unregistered.
18:25:56 <JoeyA> When posting to haskell-cafe, is it a good idea to indent code samples in Literate Haskell style?  (i.e. start each code line with > )
18:26:53 <AfC> JoeyA;I personally find that annoying, because > is already taken to mean quoted reply in email
18:27:02 <JoeyA> E-mail clients may interpret such lines as quotes from previous messages and hide them by default, which is actually a good thing if the code samples are long.
18:27:03 <AfC> JoeyA: but I'm new around here :)
18:27:20 <AfC> Pitty that lhs couldn't adopt the 4 spaces convention of Markdown.
18:27:21 <JoeyA> On the other hand, mixing that with quotes in replies might turn out ugly.
18:27:29 <monochrom> I don't know. toss a coin. for each line.
18:27:34 <JoeyA> lol
18:27:42 <AfC> monochrom: heh
18:28:19 <JoeyA> I'm about to post a mail to haskell-cafe, and one of my code samples is a whopping 64 lines.  I'm not sure whether I should post it on gist or something.
18:29:19 <monochrom> someone reminded us yesterday that email can contain HTML. I think this is a good time to use it.
18:39:37 <geekosaur> email is not IRC, 64 lines is fine... although verging on attachment, just for receiver convenience (I'd probably suck it into emacs anyway...)
18:43:02 <irene-knapp> I disagree
18:43:05 <irene-knapp> attachments are annoying
18:43:11 <irene-knapp> especially on mobile mail readers
18:43:30 <irene-knapp> maybe provide both the attachment and the inline
18:45:03 <monochrom> haskell-cafe on mobile is pretty insane if you ask me :)
18:45:40 <shachaf> Mobile Social haskell-cafe in the Cloud.
18:47:09 <geekosaur> irene-knapp, any decent mailer will allow the presentation type to be set to inline
18:47:21 <gwern> > (50 / 1206) * 100
18:47:22 <lambdabot>   4.1459369817578775
18:47:43 <monochrom> that assumes that the sender mailer is decent, too.
18:47:44 <irene-knapp> geekosaur: okay, but it's actually really annoying to manipulate such settings while bouncing around in a crowded train =p
18:47:48 <irene-knapp> with one hand
18:47:54 <irene-knapp> I prefer to just scroll through things
18:48:01 <irene-knapp> if there are attachments, I don't even click
18:48:10 <geekosaur> oh trust me, I know (s/train/bus/) --- but it's a sender side option
18:48:15 <irene-knapp> I guess, okay
18:49:01 <geekosaur> that sets the Content-Disposition (IIRC) header to "inline"; you can still extract it as an attachment but it should be shown inline by default
18:49:03 <monochrom> a decent reader honours the mime-type set by the sender. if the type says "application/octet", the reader only offers to save it in a binary file for separate processing. no inline
18:49:06 <irene-knapp> gotcha, makes sense then
18:49:34 <monochrom> the sender, which sucks, is going to do exactly "application/octet-stream" for plain text files
18:50:01 <monochrom> where "sucks" means console mode senders such as pine, actually
18:50:07 <irene-knapp> aw :( poor Pine
18:50:50 <monochrom> GUI senders actually get it right, at least they look at the bloody suffix/extension of your filename
18:50:55 <irene-knapp> indeed!
18:50:56 * geekosaur never did consider pine a decent mailer...
18:51:28 <monochrom> I have a feeling that console mode senders conspire to do mime wrong to perpetuate hatred against mime
18:51:50 <irene-knapp> this is possible haha
18:52:28 <monochrom> 1970s terminals people worship "plain text email" and they desperate need an excuse for that, you know
18:52:50 <gwern> > 1206 - 50
18:52:51 <lambdabot>   1156
18:52:57 <irene-knapp> haha yes
18:53:01 <geekosaur> nobody ever bothered to do a decent one; your choices are more or less pine/alpine (ick) and mutt (ewwww)
18:53:19 <irene-knapp> mind you, UTIs are actually better than MIME imo because they exist in an inheritance DAG
18:53:23 <geekosaur> mutt will do it right but the contortions are horrendous
18:53:53 * geekosaur is expanding that as urinary tract infection, somehow thinks that's wrong :p
18:55:06 <irene-knapp> uniform type identifier
18:55:19 <irene-knapp> a DNS-leveraged namespace, mostly pushed by Apple
18:56:42 <monochrom> oh, on that note, I have a lighter remark. I peer-reviewed a paper. it talked about right-angled triangles. it had to refer to those sides other than the hypotenuse. in the English world we usually say "leg". the paper said "catheter". I looked up "catheter" and was thoroughly horrified.
18:56:57 <geekosaur> oh dear
18:56:58 <monochrom> "plastic tube inserted into e.g. bladder"
18:56:58 <gwern> monochrom: why did it say catheter?
18:57:19 <monochrom> perhaps it's Finnish for those two sides of the triangle
18:57:21 <irene-knapp> hahaha
18:57:23 <irene-knapp> wow
18:57:30 <gwern> those finns
18:57:31 * geekosaur was guessing ESL
18:57:36 <gwern> no wonder they drink so much
18:57:46 <mauke> "cathetus" would have been the right word
18:58:04 <irene-knapp> haha I see
18:58:15 <irene-knapp> a false cognate I guess
18:58:51 <gwern> those are the worst friends!
18:58:57 <irene-knapp> yep
18:59:29 <mauke> german has kathete (cathetus), katheter (catheter), and katheder (lectern)
19:04:33 <jamil_1> http://www.scs.stanford.edu/11au-cs240h/notes/monads-slides.html#(12)
19:04:46 <jamil_1> wonder how/why this works
19:05:13 <shachaf> jamil_1: What do you mean, how?
19:05:33 <monochrom> perhaps you should peek ahead
19:05:33 <jamil_1> shachaf: what does it mean to a value of type (->) a
19:05:42 <mauke> nothing, there are no such values
19:05:43 <shachaf> jamil_1: It doesn't. A value can't have that type.
19:05:48 <shachaf> Just like a value can't have type Maybe.
19:06:08 <monochrom> but you can always prove that the given implementations satisfy Functor laws
19:06:45 <monochrom> if you can also prove that the Functor laws pretty much require the given implementation (or equivalent), then you are enlightened
19:06:51 <shachaf> jamil_1: It looks like you peeked ahead. :-(
19:07:27 <jamil_1> shachaf: but you can construct a value of type Maybe Int = Just 5
19:07:42 <shachaf> jamil_1: And you can construct a value of type (->) a Int = \_ -> 5
19:08:00 <jamil_1> right
19:08:49 <jamil_1> \_ -> 5 looks like an action
19:09:03 <shachaf> So does Just 5.
19:09:31 <shachaf> \_ looks like a reclining chair.
19:09:47 <jamil_1> so would it be correct to sa (->) a is side effecting "thing" ?
19:09:53 <shachaf> jamil_1: No.
19:09:56 <monochrom> "Just 5" looks like a capitalist ripping off a hard-working prole
19:10:09 <mauke> jamil_1: maybe
19:10:14 <monochrom> or shall I say "Just $5" :)
19:10:15 <jamil_1> shachaf: but its not operating on its arguments
19:10:18 <shachaf> None of this has anything to do with "side effects" as such, unless your meaning of "side effect" is sufficiently broad.
19:10:38 <shachaf> As it is, I can't tell if you have a meaning of "side effect" at all. :-)
19:10:53 <monochrom> I'm actually happy to call it a side effect just to move on.
19:11:34 <monochrom> you know, people speak like "monad represents computation". so what's computation? let's just define "a computation is a monad action" and be done.
19:11:44 <jamil_1> shachaf: ok, how would you define side effects
19:11:59 <monochrom> "survival of the fittest" so what is fit? "fit means survives". THE END
19:12:01 <shachaf> jamil_1: I wouldn't use the word "side effect" in talking about any of this. :-)
19:12:10 <shachaf> But monochrom's argument makes sense.
19:12:24 <shachaf> Note that ((->) r) is a particularly uninteresting monad, as far as side effects go.
19:12:42 <cmccann> the primary side effect of ((->) r) is obfuscation
19:12:45 <cmccann> via @pl
19:12:49 <jamil_1> shachaf: ok, but how would you define side effects in general
19:12:51 <monochrom> hehe
19:13:50 <monochrom> "instance Functor ((->) a)" means that after you choose a type for "a", you get a Functor. (Similarly Monad)
19:15:02 <monochrom> so for example let's choose String for "a". ((->) String) is a Functor. an action may have type ((->) String) b which is String->b, and you choose b too.
19:15:19 <monochrom> if you choose b=Int, now you're looking at String->Int, and an example is length
19:16:28 <jamil_1> right
19:17:59 <monochrom> String->Int is an action that returns an Int, and the return value can depend on the String parameter.
19:38:17 <paulotruta> hey guys )
19:38:18 <paulotruta> :)
19:38:47 <paulotruta> is there any module that i can import that can shuffle a list?
19:39:16 <paulotruta> *any module that comes with ghc
19:39:30 <dolio> Don't think so.
19:47:01 <dmwit> paulotruta: There's several packages on Hackage for that.
19:47:13 <paulotruta> si there any library i can import that does the suffle and returns the list? like x :: [a] -> [a] ?
19:47:44 <paulotruta> because the ones i've seen are [a] -> RVar [a]
19:48:10 <dmwit> http://hackage.haskell.org/package/random-extras
19:48:58 <dmwit> paulotruta: Use runRVar.
19:51:44 <paulotruta> if a do something like 'runRvar (Rvar [a])'
19:51:49 <paulotruta> it will return [a] ?
19:53:39 <napping> something like that, probably. Which Rvar are you looking at?
19:57:38 <napping> ah, Data.Random.RVar - that takes a second argument, and will return an m [a]
19:59:33 <paulotruta> a second argument?
19:59:48 <shachaf> cmccann: Are you going to Hac Boston?
20:00:16 <djahandarie> Wait, shachaf, are YOU going to Hac Boston?
20:00:30 <shachaf> djahandarie: I don't know. Are YOU going to Hac Boston?
20:00:42 <djahandarie> Yes!
20:01:02 <shachaf> Well then. Why would I possibly not go?
20:01:17 <djahandarie> Physical proximity?
20:02:40 <shapr> djahandarie: is certainly fun... higher bandwidth than irc
20:03:05 <djahandarie> Hey, I have a gig pipe straight to the freenode server!
20:03:09 <napping> paulotruta: http://hackage.haskell.org/packages/archive/random-fu/0.1.0.0/doc/html/Data-Random-RVar.html
20:03:19 <ion> shapr: But less asynchronicity. :-(
20:03:21 <napping> That "s" looks like some sort of seed
20:03:45 <shapr> ion: At the speed I speak, I prefer that.
20:04:06 <djahandarie> It makes it harder to sound all-knowing via. Google though.
20:04:10 <shapr> true that!
20:04:11 <djahandarie> Still possible, however.
20:04:21 * djahandarie integrates Google into his brain
20:05:03 <djahandarie> These irccloud guys need to figure out their shit.
20:06:27 <napping> paulotruta: that RandomSource class has many choices, but IO + DevRandom is probably the easiest
20:06:42 <napping> > runRVar (shuffle [1,2,3]) DevURandom
20:06:42 <lambdabot>   Not in scope: `runRVar'Not in scope: `shuffle'Not in scope: data constructo...
20:08:51 <paulotruta> omg that sounds too much work for what i'm doing :S I just need to shuffle (And does not need to be perfect) a list of strings :S Well, but if there is no other way... i'm already installing the random-extras package
20:10:34 <napping> paulotruta: once you've got that, import Data.Random and Data.Random.Source.DevRandom, and you can run it like runRVar (shuffle [1,2,3]) DevURandom
20:11:03 <dolio> I should add Knuth shuffling to vector-algorithms.
20:11:51 <paulotruta> napping: i see :) I'm upgrading cabal now :P After installing i will try that, but i think i found another way to do what i want without importing any more libs :)
20:13:27 <drdo> I'm getting a UTF-8 encoding error with HDBC-postgresql when inserting a ByteString into a bytea
20:21:08 <paulotruta> napping: I got an error :( No instance for (RandomSource m DevRandom)
20:21:21 <napping> how are using it?
20:21:34 <napping> If you just type that in ghci it will decide it's IO
20:21:52 <paulotruta> runRVar (shuffle [1,2,3]) DevURandom
20:23:19 <paulotruta> it works if i type it in ghci but not if i load a file
20:23:26 <paulotruta> funcx = runRVar (shuffle [1,2,3]) DevURandom
20:23:39 <paulotruta> when loading it gives me the error :S
20:24:29 <geekosaur> extended defaulting?
20:25:12 <napping> say funcx :: IO [Int]
20:26:32 <lpsmith> hmm... main = forever (putStrLn =<< getLine)  causes 100% CPU usage with 7.4.1-rc1
20:26:53 <shachaf> lpsmith: Even while waiting for input?
20:26:58 <dolio> You must be typing really fast.
20:27:00 <lpsmith> shachaf, yes
20:27:08 <paulotruta> napping : Thanks, that will do
20:27:08 <paulotruta> :)
20:27:43 <lpsmith> I'm downloading the most recent 7.4.0
20:28:51 <dolio> Does it actually work when you type things in?
20:29:16 <lpsmith> yes
20:29:35 <lpsmith> it works fine, other than it constantly saturates a CPU
20:29:39 <dolio> Interesting.
20:32:00 <drull95> out of curiosity, what do people think of fudgets?
20:32:29 <drull95> i've been learning about arrows and i was thinking of a gui based on them, only it turns out fudgets already did that
20:32:31 <lpsmith> I played around with them briefly a _long_ time ago.
20:32:51 <drull95> im starting to read about them
20:32:54 <lpsmith> is there fudgets code that still compiles with a recent ghc?
20:33:04 <drull95> dunno, probably not
20:33:23 <drull95> if fudgets seem cool then  maybe i will revive them
20:33:25 <lpsmith> I think I got it to compile with GHC 5 once, without too much effort
20:33:26 <tikhonjelvis> Aren't there some newer libraries like that?
20:33:32 <drull95> dunno
20:33:58 <drull95> will look later, maybe tomorrow but for now i will have a look at the fudgets papers
20:34:44 <tikhonjelvis> Does Fudgets use FRP?
20:35:43 <drull95> i know it uses arrows but whether it's FRP i don't know yet
20:36:15 <drull95> but the paper mentions bisimilarity and a bunch of other terms i don't know so it looks like im up for some fun :)
20:36:34 <lpsmith> yeah,  the CPU leak still happens with GHC-7.4.0.20120111
20:36:45 <lpsmith> I'm gonna report a bug
20:37:05 <tikhonjelvis> I want to learn how to build a UI with FRP, but I would also want it to use QT.
20:37:12 <dolio> Fudgets might predate FRP.
20:37:20 <tikhonjelvis> I don't think any of the existing frp libraries support Qt though.
20:38:14 <tikhonjelvis> Anyhow, have fun with fudgets.
20:54:35 <Cain_> :q
21:28:27 <JoeyA> What blogging software does http://www.yesodweb.com/blog/ use?
21:29:00 <JoeyA> Oh, I guess it says right on the page :-)
21:29:53 <JoeyA> I'd really like to know what he uses to add the code samples.
21:33:16 <ion> Hmm, i still fail to see where it says it on the page.
21:35:27 <JoeyA> ion: I think it's *implemented* on the page.
21:35:58 <JoeyA> err, nevermind.  Maybe that's just the latest blog post.
21:37:00 <JoeyA> So my question still stands
22:06:37 * JoeyA is transliterating TChan.hs to C to figure out how it works
22:09:29 <JoeyA> #define newTVar(T, x) ({ T *v = malloc(sizeof(*v)); *v = (x); v; })  // not worrying about concurrency or memory leaks, of course.
22:15:42 <Sgeo> Is it unethical to use pattern guards without LANGUAGE PatternGuards?
22:16:30 <shachaf> Well, uh, just add the pragma if you're using them.
22:23:47 <Sgeo> I see the paper on Pattern Guards talks about how nice they would be to have in GHC
22:24:01 <Sgeo> Are they currently used in GHC as heavily as the paper suggests they would be?
23:01:21 <iPhoneFifo> Hello, I’m back.
23:03:35 <JoeyA> Ah, I think I get how dupTChan works.  A TChan is basically a mutable singly-linked list with a read end (start of list) and a write end (end of list).  When a value is written to the channel, the write end is updated, with the TNil pushed out of the way for the next item.
23:03:46 <JoeyA> dupTChan simply creates another cursor on top of the current list.
23:04:11 <iPhoneFifo> > 2 + 3
23:04:12 <lambdabot>   5
23:09:54 <iPhoneFifo> > dupTChan
23:09:55 <lambdabot>   Not in scope: `dupTChan'
23:10:22 <iPhoneFifo> lambdabot, > 1 + 4
23:11:16 <iPhoneFifo> > Not in scope: `'
23:11:17 <lambdabot>   <no location info>: parse error on input `in'
23:11:32 <shachaf> iPhoneFifo: What are you hoping to achieve?
23:12:44 <iPhoneFifo> shachaf: Nothing.
23:14:42 <iPhoneFifo> shachaf,
23:15:20 <iPhoneFifo> (Sorry for blank message)
23:28:09 <Fifo> Hello
23:28:57 <augur> when is hacbo?
23:29:36 <augur> aha! 20th
23:29:38 <augur> maybe i WILL go! :D
23:31:34 <Fifo> Please join ##iPhoneFifo!
23:31:55 <ion> @where ops
23:31:55 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:33:00 <Fifo> @where ops
23:33:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:33:17 <Fifo> @where abbe
23:33:17 <lambdabot> I know nothing about abbe.
23:33:31 <Fifo> > 2+6
23:33:31 <lambdabot>   8
23:34:07 <Sgeo> > 1/0
23:34:09 <lambdabot>   Infinity
23:34:15 <Sgeo> > 1 `div` 0
23:34:16 <lambdabot>   *Exception: divide by zero
23:39:21 <iPhoneFifo> Please /join ##iPhoneFifo (be sure to type two #s or it will not work!)
