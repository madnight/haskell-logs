00:00:28 <tikhonjelvis> Ooh, talking about morning, it's time for bed.
00:00:38 <plediii> Does ghc ever use more than one core without explicitly being told what to parallelize?
00:04:50 * hackagebot hmatrix 0.13.1.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.13.1.0 (AlbertoRuiz)
00:08:17 <Jafet> plediii: GHC, or programs produced by GHC?
00:09:08 <Jafet> A concurrent program compiled with the threaded runtime can use more than one core at a time.
00:14:06 <DanBurton> but if you don't compile it explicitly with threading support, iinm the resultant program will *not* of its own will take advantage of more than one core
00:14:53 <DanBurton> of course the operating system might schedule it on different cores, or something like that.
00:16:32 <DanBurton> You could possibly write an operating system that runs multiple instances of the same program on different cores, and terminates them all once one of them produces a result
00:18:32 <Jafet> That borders on dwim
00:18:35 <plediii> thank you both.  I eventually found the need to use -threaded in one of SPJ's papers.  My previous searches kept leading to pages that made it look like I needed to use Data.Parallel
00:19:04 <Jafet> Though there are computers that run the same program on multiple processors, in lockstep
00:19:25 <Jafet> On spaceships, primarily
00:23:02 <olsner> also, http://en.wikipedia.org/wiki/Tandem_Computers
00:25:36 <olsner> hmm, I may have been mistaken about those though, I thought they did the lockstep thing, but wikipedia doesn't seem to mention it
00:26:27 <russellw> olsner, I thought so too, but I haven't a reference to hand
00:26:48 * ski . o O ( replicated servers )
00:27:15 <Adrian_GG> c ya guys thanks again for the help provided ! I will be back soon.
00:27:28 <russellw> ski, in my opinion that's a better way to go when at all possible
00:28:24 <russellw> I remember a dailyWTF story about how a tandem machine took a country's ATM network down for twenty-four hours when a single crappy beige box would have had a downtime of five minutes and a pair of beige boxes would have had a downtime of five seconds
00:28:49 <Jafet> Even Intel's made one... http://en.wikipedia.org/wiki/Intel_iAPX_432#Fault_tolerance
00:30:08 <russellw> oh yes, that was the CPU that was supposed to take over from the temporary kludge of the 8088, then turned out once they finished it, to be even slower than the 8088
00:32:25 <Jafet> russellw: the beige boxes would have had a similar downtime ratio
00:33:26 <russellw> Jafet, no they wouldn't, even a single beige box can often have an uptime of months
00:34:10 <Jafet> Well, it wasn't the fault of the tandem machine in that case
00:34:51 * hackagebot attoparsec-conduit 0.2.0 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.2.0 (MichaelSnoyman)
00:34:53 * hackagebot blaze-builder-conduit 0.2.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.2.0 (MichaelSnoyman)
00:34:55 * hackagebot conduit 0.2.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.2.0 (MichaelSnoyman)
00:35:04 <Jafet> More like idiocy took two nines off the rating
00:35:10 <russellw> ah, now where to assign the fault is a very interesting question. Here's the story so you can judge for yourself http://thedailywtf.com/Articles/Designed-For-Reliability.aspx
00:39:57 * hackagebot filesystem-conduit 0.2.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.2.0 (MichaelSnoyman)
00:39:59 * hackagebot network-conduit 0.2.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.2.0 (MichaelSnoyman)
00:40:01 * hackagebot http-conduit 1.2.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.2.1 (MichaelSnoyman)
00:40:03 * hackagebot zlib-conduit 0.2.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.2.0 (MichaelSnoyman)
00:40:05 * hackagebot yaml 0.5.2 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.5.2 (MichaelSnoyman)
00:45:07 * hackagebot authenticate 1.0.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.0.0 (MichaelSnoyman)
00:45:09 * hackagebot mime-mail-ses 0.1.0 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.1.0 (MichaelSnoyman)
00:45:11 * hackagebot xml-conduit 0.5.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.2 (MichaelSnoyman)
00:45:13 * hackagebot packdeps 0.2.0 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.2.0 (MichaelSnoyman)
00:54:51 * hackagebot pool-conduit 0.0.0.1 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.0.0.1 (MichaelSnoyman)
00:55:43 <flux> hackageday!
00:55:44 <frerich> harri: So I simply put that first and it helps quite a bit, I only noticed by collecting some statistics.
00:55:51 <frerich> ergs sorry, wrong channel
00:56:22 <qqMuppetpp> new version of yesod being released, i guess? ;)
00:59:53 * hackagebot crypto-conduit 0.1.2 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.1.2 (FelipeLessa)
01:00:48 <MostAwesomeDude> Hopefully.
01:08:47 <erus`> @hoogle [Bool] -> Bool
01:08:47 <lambdabot> Prelude and :: [Bool] -> Bool
01:08:47 <lambdabot> Data.List and :: [Bool] -> Bool
01:08:47 <lambdabot> Prelude or :: [Bool] -> Bool
01:09:02 <erus`> > and [True, False]
01:09:03 <lambdabot>   False
01:10:11 <Jafet> > msum . map All $ [True, False]
01:10:12 <lambdabot>   Couldn't match expected type `m a'
01:10:12 <lambdabot>         against inferred type `Data.Mono...
01:10:43 <Jafet> > mconcat . map All $ [True, False]
01:10:45 <lambdabot>   All {getAll = False}
01:13:15 <erus`> @hoogle liftM2
01:13:15 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:18:19 <erus`> @hoogle Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
01:18:19 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:18:19 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
01:18:19 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
01:20:11 <erus`> i can use do notation here :D
01:24:52 * hackagebot biostockholm 0.2.1 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.2.1 (FelipeLessa)
01:25:39 <ski> erus` : sometimes called `bindM2'
01:26:47 <ski> erus` : one can also use `(<*>>) :: Monad m => m (a -> m b) -> (m a -> m b)' like in `f <$> foo <*> bar <*> baz <*>> quux'
01:27:14 <erus`> :O
01:27:32 <erus`> i have a case expression anyway, so do notation is ok
01:42:28 <erus`> why doesnt (\x -> putStrLn "-" >> print x)    ==    putStrLn "-" >> print    ?
01:43:18 <Jafet> @pl \x -> (>>) (putStrLn "-") (print x)
01:43:18 <lambdabot> (putStrLn "-" >>) . print
01:44:17 <mjrosenb> erus`: parsing?
01:44:49 <erus`> just outputting the steps of my simply typed lambda calc evaluator
01:44:52 * hackagebot network-conduit 0.2.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.2.1 (MichaelSnoyman)
01:46:03 <Jafet> My answer to "why isn't the sky blue?" is also "well, it is blue."
01:46:34 <Jafet> Or more accurately "why isn't the sky green"
01:48:51 <erus`> https://github.com/tm1rbrt/haskell/tree/master/lambdacalc if anyone wants a look
01:49:56 <mjrosenb> erus`: no, i'm saying they are different because of parsing
01:59:19 <frerich> erus`: I think "(putStrLn "-" >>) . print" is a bit hard to read, but I'm not an expert. In any case, I would have tried to do this 'show terms seperated by dashes' in pure code and only then map putStRLn over everything.
01:59:47 <frerich> erus`: Like 'mapM_ putStrLn $ intersperse "-" $ map show $ steps test'
02:00:06 <frerich> Not as concise I guess, but my brain parses that more easily :-}
02:01:25 <Jafet> intercalate
02:01:25 <frerich> Hm I thuoght there was a shortcut for 'map show', but I cannot remember it...
02:01:45 <frerich> Jafet: If you use intercalate, you have to make sure to insert newlines yourself tho.
02:01:47 <Jafet> Not that it does the same thing as erus`s
02:02:02 <Jafet> Oh, I read it incorrectly
02:02:20 <frerich> Jafet: And yeah, I think my version first prints a term, then a dash. Erus` prints a dash, then a term.
02:02:29 * frerich figured if they are just separators, it doesn't matter :-)
02:04:09 <Jafet> There should be a decent tree prettyprinting library by now...
02:04:29 <frerich> Hm is there a function which can 'zip' lists, like 'f [1,2,3] [4,5,6]' evaluates to '[1,4,2,5,3,6]'?
02:04:58 <Jafet> concat . zipWith (\a b -> [a,b])
02:05:21 <Jafet> More generally concat . transpose
02:06:23 <Jafet> Er (concat.) . zipWith (\a b -> [a,b])
02:06:29 <frerich> Hm yes, '\l m -> concat . transpose $ [l,m]' might work
02:06:49 <Jafet> They have different semantics
02:06:56 <Jafet> Decide on one
02:08:12 <frerich> You mean, runtime behaviour as far as lazyness goes or so? I think "(\l m -> concat . transpose [l,m]) [1,2,3] [4,5,6]" generates [1,4,2,5,3,6], just as I needed.
02:08:34 <frerich> First time I have a use for 'transpose', neat - I always wondered what that could be good for. :-)
02:08:54 <Jafet> ((concat.) . zipWith (\a b -> [a,b]) &&& (concat.) . transpose) [1,2,3,4] [5,6,7]
02:09:02 <Jafet> > ((concat.) . zipWith (\a b -> [a,b]) &&& (concat.) . transpose) [1,2,3,4] [5,6,7]
02:09:03 <lambdabot>   Couldn't match expected type `t1 -> t'
02:09:03 <lambdabot>         against inferred type `([[[a...
02:09:15 * Jafet loses points.
02:11:02 <Jafet> > (\x y -> (concat $ zipWith (\a b -> [a,b]) x y, concat $ transpose [x,y])) [1,2,3,4] [5,6,7]
02:11:03 <lambdabot>   ([1,5,2,6,3,7],[1,5,2,6,3,7,4])
02:20:30 <erus`> now i need to implemenet system F :|
02:23:19 <Jafet> "Your interpreter hangs." "It implements System F. NOTABUG"
02:27:26 <erus`> i was gonna read spj's paper
02:27:31 <erus`> i should do that
02:34:08 * Baughn grumbles about Map.alter not being strict
02:36:57 <rribeiro> Hi folks! I'm looking for some good-examples of code that really needs the undecidable-instances extension. Does anyone could point some examples? I would like some libraries...
02:37:50 <koala_man> is there a term for an element z so that forall a. z*a = a*z = z ? zero/null element?
02:38:27 <sipa> http://en.wikipedia.org/wiki/Absorbing_element
02:38:27 <ion> The identity element, i think.
02:38:49 <ion> Oh, i misread.
02:39:17 <koala_man> sipa: great, thanks!
02:46:07 <mm_freak> rribeiro: i can think of examples, but none of them are really good
02:46:47 <mm_freak> proper type-level code should get along without UndecidableInstances
02:47:40 <rribeiro> mm_freak: I'm looking examples of useful code that are only accepted by undecidable instances
02:47:54 <Twey> What's wrong with ad-hoc overloading?  Why did Haskell reject it?
02:48:19 <rribeiro> mm_freak: Mainly to test some ideas that I have for a type inference algorithm
02:49:52 <mm_freak> rribeiro: type instance Add (Succ x) y = Add x (Succ y)
02:50:08 <mm_freak> you can do the same without UndecidableInstaces, but that particular version requires it
02:50:25 <mm_freak> +n
02:51:21 <rribeiro> mm_freak: Did you know a type-families-less example?
02:52:36 <mm_freak> well, you can do the same using a type class instead of a type family
02:52:55 <mm_freak> class Add x y z | x y -> z
02:53:00 <int-e> Twey: "How to make ad-hoc polymorphism less ad hoc" by Wadler and Blott starts out with the example  square x = x*x, which with pure ad-hoc overloading for * will not be typeable.
02:53:13 <Twey> Thank you
02:55:20 <int-e> (well, you could say it should be ad-hoc overloaded, but then you run into problems with combinatorial explosion, typing  squares x y z = (x*x, y*y, z*z)  (example from same source, slightly modified))
02:55:27 <Baughn> ..whee. Once I finally got it working, my nice haskelly parser does 50% more lines than the C parser /while doing slightly more work/.
02:55:30 <Baughn> Definitely a win. :D
02:55:38 * Baughn is sneakily sneaking haskell into google
03:01:25 <int-e> will there be a google haskell compiler? we can use some competition :))
03:01:43 <ion> int-e: Yeah, GHC
03:01:51 <donri> hahaha
03:02:32 <keep_learning> Hello all
03:03:00 <Anteu> earn 40% Rakeback money and a chance to win $1,000/month!  http://rakenews.com
03:03:51 <Baughn> int-e: GHC is already ludicrously smart, why would we try to /compete/? :P
03:03:53 <keep_learning> What is GHC head  ?
03:04:09 <Baughn> keep_learning: The current development code for GHC.
03:04:20 <keep_learning> any idea how to install dph-lifted-vseg library ?
03:04:21 <Baughn> keep_learning: You don't want to use that, I'm pretty sure. :P
03:04:33 <Baughn> cabal-install?
03:04:50 <keep_learning> Baughn, Looks like I have to do this to run dph :)
03:06:11 <keep_learning> Baughn, I have installed GHC-7.4.0.20111219 so do i still need to install ghc from ghc head ?
03:06:37 <quicksilver> GHC is only ludicrously smart in certain respects
03:06:53 <quicksilver> it's smart bits are motivated by the research interests of its main contributors
03:07:06 <quicksilver> a differently motivated compiler would be a very good thing for the language as a whole
03:07:12 <quicksilver> s/it's/its/;
03:07:30 <hpc> i wonder what a haskell compiler made by AI people would look like
03:08:22 <keep_learning> I am getting error " cabal: There is no package named 'dph-lifted-vseg' "
03:08:48 <keep_learning> Pardon me if I sound stupid
03:09:26 <donri> keep_learning: is it new? perhaps you need to cabal update
03:09:32 <hpc> https://encrypted.google.com/search?hl=en&q=dph-lifted-vseg -- try github
03:09:56 <keep_learning> I am working with dph library and Ben Lippmeier suggested me use the new dph-lifted-vseg library and the GHC head instead of dph-par and GHC 7.2.
03:10:36 <quicksilver> hpc: AI people? they would have promised a full implementation in the 70s but in actual fact it would still just be able to perform addition of single digit numbers?
03:11:07 <keep_learning> I am wondering what is GHC head and how to install  dph-lifted-vseg
03:11:36 <hpc> quicksilver: i was more thinking the nonlinear algebra people, not the skynet people :P
03:11:43 <keep_learning> donri, Now i am getting " cabal: There is no package named 'dph-lifted-vseg' "
03:11:46 <donri> ghc head is probably the ghc version in development
03:11:53 <hpc> quicksilver: though now that i think about it, it would probably just look like common lisp
03:12:30 <donri> "head" often refers to the latest commit in revision control
03:13:21 <hpc> keep_learning: ignore ben lippmeier, go with 7.2/dph-par
03:13:36 <hpc> it's not worth it to go past release versions unless you are a dev, IMO
03:14:34 <keep_learning> donri, I have installed ghc-7.4.0.20111219 . I think its the latest ghc . I just want to confirm that its ok .
03:14:48 <donri> git clone git://github.com/ghc/packages-dph.git; cd packages-dph/dph-lifted-vseg; cabal install
03:15:03 <donri> keep_learning: I have no idea :)
03:15:23 <donri> that's not ghc head, but i don't know what you really need
03:15:32 <donri> hpc seems to think 7.2 will be enough
03:16:30 <keep_learning> hpc donri thank you both
03:16:37 <donri> in that case: git checkout ghc-7.2
03:17:05 <hpc> if he already has 7.4, no need to downgrade
03:17:27 <hpc> i was more thinking of "if it's a pain in the ass to install, it better be damn worth it; a couple months newer version isn't worth it"
03:17:52 <donri> in that case, git checkout ghc-7.4 :)
03:18:08 <hpc> :P
03:21:16 <keep_learning> donri, I am getting this error " cabal: cannot configure dph-lifted-vseg-0.5.2.0. It requires dph-lifted-base
03:21:17 <keep_learning> ==0.5.*"
03:22:21 <donri> keep_learning: you sure your cabal is set up for 7.4? if so, you might need to install dph-lifted-base from the same git clone
03:25:24 <keep_learning> donri, My cabal is not set up ghc-7.4. Its for ghc-7.2 how ever doing cabal install -w ghc-7.4.0.20111219 so gives error.
03:28:42 <quicksilver> I don' tthink you can use cabal to install different ghc versions
03:28:46 <quicksilver> it's news to me if you can
03:28:54 <quicksilver> I think you install new GHC versions carefully in a different prefix
03:29:03 <quicksilver> with their own libraries and own copy of cabal-install
03:29:11 <donri> -w points to the compiler executable
03:29:23 <quicksilver> oh
03:29:35 * quicksilver lives and learns
03:29:40 <donri> but i suggest virthualenv if you're going to do multiple ghc versions
03:29:52 <rostayob> ghc installations don't override each other by default anyways
03:30:04 <rostayob> so if you install the binaries you'll have various ghc-version
03:30:08 <rostayob> and ghci-version, etc
03:30:29 <rostayob> which is cool
03:30:43 <koala_man> could one say that Maybe, together with lifted functions, form a category?
03:33:13 <quicksilver> yes, koala_man
03:33:19 <quicksilver> Maybe is a functor so its image must be a category.
03:33:39 <quicksilver> (the objects are types of the form "Maybe X" and functions are fmap'ped functions)
03:35:08 <`juice> www.ircsupport.org general HelpDesk Support news.
03:36:19 <otters> is there a version of groupBy that doesn't just group adjacent elements
03:36:33 <donri> sort then groupBy?
03:36:41 <otters> oh, hm
03:36:46 <otters> you might be onto something
03:36:48 <koala_man> quicksilver: ah, thanks
03:37:30 <donri> or well, sortBy :P
03:37:43 <otters> right right
03:42:28 <fantasticsid> :t order
03:42:29 <lambdabot> Not in scope: `order'
03:52:04 <keep_learning> Could some one please tell me how to resolve this issue ( http://hpaste.org/57225 )
03:52:58 <keep_learning> :t compare
03:52:59 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:55:18 <int-e> keep_learning: looks like you also have to install dph-prim-par manually (since it depends on an older version of vector); in fact I expect that you need the darcs versions of all the dph packages.
03:58:34 <keep_learning> int-e, For this I need to install darcs ?
03:58:57 <keep_learning>  I downloaded dph from github
03:59:14 <int-e> keep_learning: oh. git then.
04:00:07 <keep_learning> int-e, so i need to install dph-prim-par for github ?
04:00:18 <keep_learning> *from
04:00:36 <int-e> yes, I believe so.
04:07:38 <int-e> keep_learning: But I'm not sure whether this works with ghc-7.2.1 at all. (I suspect it won't, actually.)
04:11:29 <erus`> am i supposed to pass the types to polymorphic function in system F ?
04:11:56 <erus`> or are they supposed to be inferred?
04:12:06 <quicksilver> in system F they are passed explicitly
04:12:38 <quicksilver> haskell and ML can both be thought of as using system F as a model, but always inferring the types so that passing is done "behind the scenes"
04:12:42 <erus`> so i have term application and type application right?
04:12:49 <quicksilver> in system F, yes, you have that.
04:13:11 <quicksilver> and two different kinds of lambda, too, type abstraction and term abstraction
04:13:22 <erus`> yup i have that
04:14:21 <Saizan> if you don't like the duplication you could use the type to disambiguate, but then it wouldn't be System F
04:15:01 * hackagebot Cabal 1.12.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.12.0 (RossPaterson)
04:15:06 <Philippa> you have to for type lambdas, yeah. For type application, it's as good as if types and terms are syntactically distinct
04:29:48 <erus`> is there a warning switch for non exhaustive patterns ?
04:30:31 <Lemmih> Yes.
04:30:42 <int-e> -fwarn-incomplete-patterns
04:31:38 <int-e> (how did I find it? start ghci, type :set -fwarn-<tab> :-) )
04:33:07 <Baughn> erus`: There's also -Wall, I believe
04:33:21 <erus`> i typed :set -fwarn-incomplete-patterns and did :r to reload and i dont get a warning
04:34:00 <erus`> ah i have to :load
04:34:10 <erus`> bug report! :o
04:37:07 <prof7bit> why do I need to start ghc with the -package option forcertain packages and don't need it for others? for example here: http://www.haskell.org/haskellwiki/GHC/As_a_library I need to start it with ghc -package ghc why doesn't the import keyword alone do the trick like it is with other packages?
04:39:06 <Baughn> erus`: That's not a bug. :reload only loads changed files.
04:39:06 <int-e> prof7bit:  because some packages are hidden and others are not -- see ghc-pkg list output.
04:40:27 <prof7bit> the ones printed in blue are hidden?
04:40:42 <int-e> yes. it used to use parentheses, hmm.
04:41:07 <prof7bit> i have an old ghc
04:41:27 <prof7bit> 6.12.3
04:42:07 <erus`> what would cause systemf to never halt?
04:42:27 <int-e> maybe I misremember.  ghc-pkg list | less  uses parentheses, so that may be why.
04:42:49 <prof7bit> can i somehow also load these packages from within the sourcecode, is there some sort of compiler directive that does the same?
04:43:56 <prof7bit> for example if i have a plain vanilla ghci session and still wanted to load souce that uses the ghc package?
04:44:24 <prof7bit> or is there no wy around restarting the ghci session with different command line switches?
04:44:58 <int-e> :set -package ghc  works (using ghc 7.2.1 though, maybe 6.12 was different)
04:45:31 <prof7bit> works
04:46:31 <prof7bit> and if i have something that I intend to run with runhaskell, is there also some way to include it in the source itself?
04:49:45 <erus`> systemF is like C++ templates
04:50:02 * hackagebot probability 0.2.3.1 - Probabilistic Functional Programming  http://hackage.haskell.org/package/probability-0.2.3.1 (HenningThielemann)
04:50:03 <erus`> (retarded) :)
04:50:04 <prof7bit> found it: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/ch04s02.html#source-file-options
04:50:58 <erus`> wow so the Type Application stuff is irrelevant at the evaluation level
04:51:02 <erus`> thats cool
04:53:20 <prof7bit> hmm... does not work: {-# OPTIONS_GHC -package ghc #-}
04:53:35 <prof7bit> unknown flag in  {-# OPTIONS #-} pragma: ghc
04:53:47 <prof7bit> unknown flag in  {-# OPTIONS #-} pragma: -package
04:55:35 <prof7bit> why are there hidden packages anyways, what is the advantage of having something like this? IMHO it only makes things more complicated.
04:55:50 <russellw> What synonyms are there for an associative array? (As a concept, without reference to implementations like hash table or binary tree.) Map, dictionary, what else?
04:56:00 <Baughn> prof7bit: Mostly to avoid users accidentally loading internal GHC packages
04:56:15 <int-e> prof7bit: because otherwise if you have two packages that define the same module installed, you can't use either of them in ghci.
04:57:20 <prof7bit> Baughn: accidentally loading?
04:57:37 <Baughn> prof7bit: Such as ghc-binary
04:57:48 <Baughn> prof7bit: Generally, there shouldn't be many hidden packages.
04:57:52 <erus`> if systemF type checks, is it guaranteed to evaluate?
04:58:03 <int-e> For ghc there are two reasons, I guess -- one is that it uses a flat namespace for most of the modules, and some of them have not entirely uncommon names, e.g., Bag, Unify, Kind ...; the other is that the ghc package is not very stable.
04:58:11 <int-e> (by which I mean the API.)
04:58:50 <int-e> erus`: well, many non-terminating programs can be typed.
04:59:22 <prof7bit> int-e: ok, the namespace thing is a valid argument
05:02:33 <prof7bit> the reason I was asking was because I am currently trying to make a little haskell-aware editor that has a ghci console attached to it and should be able to load the current editor file. this would fail if I imported hidden packages in this file
05:06:04 <prof7bit> but i guess the :set command makes it somehow possible to work around this without having to restart the console with different options. but it still seems somehow sub-optimal to me.
05:07:41 <mm_freak> the reverse state monad is some real brainfuck
05:08:03 <ion> :-)
05:10:48 * t3eblinder does a reverse state monad make sense?
05:11:29 <Jafet> It is analogous to fix.
05:18:55 <byorgey> t3eblinder: yes
05:20:02 <parcs`> 'get >>= put . f' is analogous to 'fix f'?
05:20:58 <byorgey> that sounds right.
05:21:20 <koala_man> how do you pronounce yesod? rhyming with abode?
05:22:41 <parcs`> yeah think so
05:24:06 <saati> koala_man: here's the hebrew pronounciation http://www.forvo.com/word/yesod/
05:26:19 <shachaf> That pronunciation is slightly odd but the emphasis is correct. It doesn't rhyme with "abode".
05:32:04 <dca_> what haskell APIs do exist for vector stuff?
05:32:19 <dca_> Data.Vector ?
05:32:38 <quicksilver> depends what you intend to imply by 'vector'
05:33:00 <dca_> something like C++ STL vectors
05:33:19 <dca_> for O(1) access time based on index
05:33:31 <quicksilver> Personally I would use Data.Sequence until I proved that was inadequate for my needs.
05:33:34 <quicksilver> O(1) is a lie.
05:33:58 <dca_> quicksilver: do you mean that O(1) *in haskell* is a lie ?
05:35:01 <copumpkin> O(1) is usually a (mostly acceptable) lie in all languages
05:35:20 <funktronic> O(1) amortized is sorta O(1)
05:35:41 <copumpkin> oh, I don't have a problem with arguments about amortization
05:35:49 <dca_> ok
05:35:52 <osfameron> O(little white lie)
05:36:05 <funktronic> copumpkin: what is yo beef then ?
05:36:19 <dca_> O(1+𝛜)
05:36:35 <copumpkin> O(1) for arbitrary element access of a container breaks information theory
05:37:12 <yrlnry> How do arrays work?
05:37:13 <byorgey> you at least need to spend the time to read the encoding of the element location.
05:37:23 <yrlnry> Oh, okay.
05:37:26 <kalven> ugh
05:37:31 <Saizan> anyhow, if you want contiguous chunks of memory there's a few packages: array, uvector, repa, ..
05:37:31 <funktronic> copumpkin: how so ?
05:37:51 <byorgey> yrlnry: arrays in Haskell are as O(1) as the arrays in any other language.
05:37:52 <luite> Saizan: vector instead of uvector
05:37:55 <copumpkin> yrlnry: by a machine-imposed upper bound on the domain
05:37:56 <dca_> why doesn't that encoding goes to 1 of O(1) ?
05:38:18 <luite> Saizan: the latter is deprecated
05:38:25 <copumpkin> arrays are basically O(1) in the same way that IntMap is O(1)
05:38:46 <copumpkin> except array O(1)s tend to be smaller than IntMap O(1)s most of the time
05:38:52 <Saizan> luite: ah, thanks
05:38:58 <quicksilver> yes, so it's a constant factor that is different
05:39:13 <quicksilver> and therefore the asymptotic argument is beside the point.
05:39:20 <copumpkin> yep
05:39:27 <kalven> O(circle-jerk)
05:39:34 <copumpkin> lol
05:39:34 <quicksilver> O(log n) is bounded by O(64) given that n can't possibly be larger than 2^64 :P
05:39:39 <funktronic> copumpkin: with asymptotic and big-o, O(1) = O(100000) etc...
05:39:46 <copumpkin> funktronic: I know :)
05:39:57 <copumpkin> I was saying the difference was not asymptotic
05:40:13 <copumpkin> or if the difference was asymptotic, we needed to stop lying about both structures
05:40:23 <copumpkin> since machine arrays don't have asymptotes
05:40:30 <funktronic> yes i understand, but for that argument i'd say "arrays tend to slighlty faster than intmaps"
05:40:43 <copumpkin> because they're artificially limited by machine size, and that's crucial to their claim of O(1)
05:40:48 <copumpkin> which is misleading
05:41:25 <yrlnry> machine size is not an "artificial" limitation,
05:41:36 <yrlnry> unless you have found some way to run your program with no machine.
05:41:40 <funktronic> in general big-O IMHO is used for relative perf comparisons on larger data structures and for understanding how they work.
05:41:41 <copumpkin> it is when you're talking asymptotics
05:42:54 <copumpkin> asymptotics when analyzing arrays means "when arrays get kinda large, but not too large (cause that's just silly), they perform better than structure X"
05:43:22 <copumpkin> which I guess is fine, but people need to acknowledge that more
05:43:39 <funktronic> people aren't acknowleding that ?
05:43:48 <copumpkin> I haven't seen it
05:44:23 <copumpkin> asymptotic performance discussions usually revolve around discussions of the abstract datastructures/algorithms outside of any particular machine model
05:48:09 <funktronic> copumpkin: i always get the impression that RAM is implied
05:48:29 <copumpkin> well, I haven't seen it mentioned explicitly anywhere :)
05:48:55 <funktronic> copumpkin: yeah there's a lot of handwaving going on
05:49:15 <funktronic> but i mean in big-o it doesn't really matter that much
05:49:22 <funktronic> well RAM does matter
05:50:52 <erus`> https://github.com/tm1rbrt/haskell/blob/master/lambdacalc/systemf.hs does this look correct?
05:53:19 <ion> Step-by-step evaluation of the RState sample code: https://gist.github.com/1710857
05:54:33 <ClaudiusMaximus> > length [()|x <-[1..3], y <-[x+1..4], z <- [0..4]]
05:54:33 <lambdabot>   30
05:57:20 <frerich> erus`: Looks ok to me, except that you don't use some arguments sometimes (so you could denote that by passing them via '_') and that I personally rather use pattern matching instead of case on the toplevel.
05:57:30 <frerich> (but that's just syntactic sugar for case)
05:58:41 <ion> mm_freak: ↑
06:00:57 <keep_learning> hello all
06:01:19 <byorgey> erus`: looks good
06:01:22 <byorgey> hi keep_learning
06:01:43 <keep_learning> I have installed ghc-7.5.20120126 and it contains a folder of libraries
06:02:03 <Lemon> why do types seem almost like patterns to me?
06:02:16 <keep_learning> I want to install dph-lifted-vseg but cabal in not working
06:02:22 <byorgey> Lemon: what do you mean?
06:02:26 <matthiasgorgens> Lemon: Because the syntax is similar?
06:02:27 <keep_learning> my cabal is configured for ghc-7.2
06:02:39 <keep_learning> http://hpaste.org/57230
06:02:54 <matthiasgorgens> keep_learning: ghc 7.5 is released?
06:03:07 <dcoutts> keep_learning: you can select the ghc to use with the -w flag
06:03:08 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
06:03:19 <keep_learning> matthiasgorgens, http://www.haskell.org/ghc/dist/current/dist/
06:03:50 <matthiasgorgens> keep_learning: interesting.  it's for testing only, not released?
06:03:55 <dcoutts> keep_learning: as in, cabal install foobar -w ghc-7.4.0.20111219
06:04:02 <byorgey> matthiasgorgens: no, that looks like the version number of the latest development version
06:04:22 <dcoutts> matthiasgorgens: 7.5.${date} is the current head development branch
06:04:35 <byorgey> matthiasgorgens: releases of GHC always have an even second version component
06:04:40 <Lemon> byorgey, matthiasgorgens: because of the similar syntax, yeah
06:04:44 <byorgey> like 7.2, 7.4, 7.6
06:04:56 <dcoutts> and 7.4.0.${date} is the 7.4 release candidate
06:05:15 <byorgey> Lemon: well, there is certainly a close relationship
06:05:25 <dcoutts> anything with a long date-like final version component is an unreleased dev version
06:06:00 <byorgey> (almost) every type has patterns to match on values of that type, and the structure of a pattern follows the structure of the type
06:06:32 <Lemon> right now I'm writing a toy interpreter, and what I noticed is that
06:06:48 <Lemon> the printing code and the parsing code for types and patterns are (almost) identical
06:07:34 <byorgey> Lemon: yeah, that doesn't surprise me too much
06:07:39 <Lemon> I'm really tempted to merge the two and use one AST type for both
06:07:55 <byorgey> Lemon: but I'd say it's not because "types are like patterns", but because "patterns follow the structure of types"
06:08:04 <byorgey> Lemon: I wouldn't do that if I were you.
06:08:10 <Lemon> byorgey, why not?
06:08:28 <byorgey> it just seems like the sort of thing that will lead to much pain down the road.
06:08:57 <byorgey> although given that it's a toy interpreter, I changed my mind: go for it, you'll probably learn a lot!
06:09:17 <Lemon> well okay
06:09:40 <byorgey> maybe it will work and it will be really cool.  and maybe it won't, but at least you will have a better understanding of why not.
06:09:55 <Lemon> this kind of reminds me of all that recent talk about datakinds and automatic lifting
06:10:12 <erus`> i feel like if i can create my own dependently typed language, i might be able to get the hang of agda .. ?
06:10:21 <byorgey> hehe
06:10:28 <byorgey> I don't think it's really the same thing
06:10:36 <byorgey> patterns vs types is very different than types vs kinds.
06:10:50 <byorgey> types and kinds are "the same sort of thing" just at different levels.
06:11:04 <byorgey> whereas patterns and types are not the same sort of thing.
06:11:12 <erus`> i dont have patterns, they are for wussies
06:11:31 <Lemon> byorgey, I get that
06:12:19 <Lemon> but this merge would "facilitate" an Omega-like flattening of the value/type/kind/sort/... hierarchy
06:12:42 <Lemon> I don't know what this would imply, though
06:13:05 <byorgey> that's why you should try it and find out =)
06:13:08 <Lemon> but it would be kind of cool to automatically get new kinds with each new type definition
06:13:29 <erus`> universe polymorphism?
06:14:39 <mm_freak> ion: thanks for that
06:14:54 <mm_freak> it's not the actual evaluation of existing code that confuses me
06:15:03 <mm_freak> it's how you might come up with the code in the first place
06:15:12 <Saizan> universe polymorphism (if you mean Agda's) deals with a different but confusingly close stratification
06:15:42 <Saizan> i guess it could be adapted maybe
06:15:50 <keep_learning> dcoutts, I am getting error. Kindly have a look  ( http://hpaste.org/57230 )
06:17:39 <dcoutts> keep_learning: so there are several dph packages which depend on each other, by default cabal does not look in other local directories for dependencies, just the directory you give explicitly (or blank for ./) plus packages published on hackage
06:18:34 <dcoutts> so your problem there is that cabal is looking for the dependencies of dph-lifted-vseg but it only looking at the versions that are on hackage, which are old, you need the versions you've got there locally
06:19:29 <dcoutts> so you need to tell it to install all those local ones, which you can do like so: cabal install ./ ../the-other/ ../blah-blah [--dry-run]
06:20:37 <keep_learning> dcoutts, yes there is one folder name vector in the libraries . Thank you
06:20:59 <keep_learning> Should i unregisted the current vector library
06:21:07 <keep_learning> *unregister
06:21:12 <dcoutts> keep_learning: no, it's ok to have multiple versions
06:21:38 <dcoutts> you'll almost certainly need to list all the local dph packages (that you don't have installed already)
06:23:50 <erus`> @hoogle ($)
06:23:50 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:23:50 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
06:23:50 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:25:39 <Lemon> so when are we finally gonna flip $'s associativity?
06:28:55 <rwbarton> never
06:29:14 <mm_freak> hopefully never
06:29:44 <mm_freak> "f (a x) (b y)" vs. "f $ a x $ b y"
06:29:51 <mm_freak> i totally prefer the former
06:31:20 <keep_learning> dcoutts, I tried to install vector from libraries folder ( cabal install  -w ghc-7.5.20120126 ) but still no success ( http://hpaste.org/57230 )
06:32:13 <dcoutts> keep_learning: this is what I meant about having to list all the dph packages
06:32:19 <dcoutts> they almost all depend on each other
06:32:53 <mm_freak> ion: i'm intrigued by RState as a better Writer…  i'm searching for more use cases
06:33:05 <dcoutts> keep_learning: in this case it's missing dph-base (or rather, finding the version from hackage, which is no good)
06:34:13 <mm_freak> i've just defined RStateT, but unfortunately that one gives me a stack overflow
06:34:20 <mm_freak> for long running programs
06:35:15 <keep_learning> dcoutts, you mean something like this. cabal install -w ghc-7.5.20120126 { list all library from libraries folder } --dry-run ?
06:36:32 <erus`> test2 = App (App (App (TApp (TApp (TApp compose TBool) TBool) TBool) (TApp idfunc TBool)) (TApp idfunc TBool)) (CBool True)    -- Beautiful code
06:36:47 <dcoutts> keep_learning: basically, yes
06:37:04 <dcoutts> keep_learning: you can start with that, and trim out the ones that are unnecessary
06:37:16 <dcoutts> then try for real without the --dry-run
06:37:37 <keep_learning> dcoutts, thank you
06:39:39 <mm_freak> ok, apparently you can't have infinite IO computations with RStateT
06:43:14 <erus`> how do i pronounce System Fω?
06:43:20 <erus`> system f omega?
06:43:22 <Philippa> yeah
06:43:24 <Saizan> yep
06:44:59 <matthiasgorgens> flipping ($)'s associativity could be useful, because you can always use (.) to get the current behaviour.
06:45:45 <matthiasgorgens> though I wouldn't want to worry about making this source-breaking change for such small gain.
06:46:09 <keep_learning> dcoutts, dry run is working fine but while running , vector installation  is  failed ( http://hpaste.org/57230 )
06:46:58 <Cale> matthiasgorgens: It would also make $! more useful
06:47:04 <singpolyma> I want to simplify (map (\f -> someFunc f x v)) I tried (map (`someFunc` x v)), but apparently operators don't work like that.  Is there any trick I can use, or is the first form the simplest?
06:47:07 <Cale> (alongside $)
06:47:23 <mm_freak> flipping associativity would be useful for ($!), but for ($) it would probably just lead to abuse
06:47:41 <Cale> mm_freak: Well, you wouldn't flip the associativity of one and not the other
06:47:52 <matthiasgorgens> singpolyma: you can always do point-free trickery, but it probably wouldn't make for easier reading in your case.
06:47:55 <mm_freak> Cale: then i'd probably not flip either
06:47:58 <Cale> singpolyma: If you have control over the order of parameters to someFunc
06:48:05 <Cale> mm_freak: I'd flip both :)
06:48:24 <Cale> It has the positive effect of getting people to use (.) more as well, which is a good thing.
06:48:34 <matthiasgorgens> Cale: why is that a good thing?
06:48:37 <mm_freak> Cale: you really prefer "f $ a x $ b y" over "f (a x) (b y)"?
06:48:45 <matthiasgorgens> Cale: (.) is not bad, but I don't see why it is good.
06:48:46 <Cale> Because we're functional programmers and we should be thinking in terms of composing functions together :)
06:48:55 <mm_freak> because if you flip ($), that's how people will write their code =)
06:49:07 <matthiasgorgens> cale, (.) has the benefit of not assosciativity not mattering.
06:49:11 <singpolyma> Cale: I can write a helper to change the params, but was mostly just wondering if there was some trick.  I expect not, though
06:49:12 <Cale> indeed
06:49:29 <matthiasgorgens> singpolyma: there's always a trick.  prepare.
06:49:41 <mm_freak> flipping ($) is probably a bad way to get people to use composition…  education is a better way
06:49:44 <Cale> So it f . g . h $ x has more "virtual subexpressions" than f $ g $ h $ x  does
06:49:55 <erus`> That feel when i can apply id to itself :)
06:50:05 <erus`> (In system F)
06:50:08 <mm_freak> > id id 3
06:50:08 <Cale> mm_freak: There are cases where using more than one left-associated $ could look good.
06:50:09 <lambdabot>   3
06:50:09 <matthiasgorgens> :pl (\f -> someFunc f x v)
06:50:16 <lispy> Looks like the Eq and Show constraints are removed from Num in future versions of base.
06:50:18 <matthiasgorgens> @pl (\f -> someFunc f x v)
06:50:19 <lambdabot> flip (flip someFunc x) v
06:50:25 <erus`> i want type inference like haskell
06:50:28 <lispy> Is this also going to result in an update to the language definition?
06:50:30 <mm_freak> lispy: yes, base 4.5 removes them
06:50:31 <Cale> mm_freak: Especially if they're vertically aligned :)
06:50:37 <cmccann> Eq and Show were dumb constraints for Num anyway
06:50:39 <matthiasgorgens> @pl (map (\f -> someFunc f x v))
06:50:39 <lambdabot> map (flip (flip someFunc x) v)
06:50:42 * lispy thinks it should as Haskell98 and Haskell2010 list it as constraint
06:50:43 <erus`> explicit Type applications are silly
06:50:54 <mm_freak> Cale: true, but honestly i'd introduce some syntactic sugar for that instead
06:51:12 <mm_freak> f $$ x; y; z
06:51:12 <lispy> cmccann: I agree, but now code I have is broken with base 4.5
06:51:27 <mm_freak> where you can vertically align x, y and z just like with do-notation
06:51:31 <Cale> Why introduce syntactic sugar when just correctly choosing the association of this function will do?
06:51:32 <lispy> OpenGL is broken, specifically
06:51:49 <singpolyma> matthiasgorgens: Right.  Calling flip twice could work.  or even (flip (`someFunc` x) v)  I expect
06:51:58 <cmccann> lispy, no, previously both your code and Num were broken, and it worked via double-negation elimination
06:52:18 <mm_freak> Cale: because sugar can really get rid of line noise here…  otherwise i'm still fine with parentheses
06:52:25 <lispy> ?tell Igloo do you know if your change to remove (Show a, Eq a) from Num will make it into Haskell'?  It's unfortunate that base 4.5 removes it, but Haskell98 and Haskell2010 document it as being there.
06:52:26 <lambdabot> Consider it noted.
06:52:36 <matthiasgorgens> singpolyma: If you might also be interested in semantic editor combinators.  that might give a better base of basic operations for such manipulation than relying on flip.
06:52:45 <matthiasgorgens> singpolyma: http://conal.net/blog/posts/semantic-editor-combinators
06:52:53 <Igloo> lispy: It should be included in the next language release, yes
06:52:53 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
06:52:58 <Cale> mm_freak: I'm thinking of cases where you have two or perhaps more really long parameters to a function.
06:53:03 <lispy> Igloo: thanks!
06:53:05 <singpolyma> matthiasgorgens: I'll look into it, thanks :)
06:53:15 <mm_freak> Cale: yeah, i'd use either parentheses or even a 'let' there
06:53:19 <Cale> mm_freak: Of course, one can argue that it might be nice to abstract those things into their own definitions instead
06:53:20 <Cale> yeah
06:53:20 * lispy is fine with the change
06:53:37 <Cale> But parens are somewhat awkward in any case that the thing they contain is long.
06:54:00 <matthiasgorgens> Cale: yes, parens are fine for short things.
06:54:12 <lispy> Igloo: BTW, with that C99 refactor on the RTS.  There is enough code there that I'm looking into using something like the ROSE framework to do the refactorings.
06:54:23 <matthiasgorgens> cale, so f (g x) (h y) is fine, but for very long stuff, a flipped $ would be nice.
06:54:26 <mm_freak> Cale: if they spread over many lines, then yes, but when that happens, you should really consider using let/where
06:54:27 <matthiasgorgens> or could be nice.
06:54:29 <lispy> Igloo: or maybe coccinelle
06:54:32 <Cale> matthiasgorgens: yeah
06:54:34 <Igloo> lispy: It's worth sending a mail to cvs-ghc before doing anything large
06:55:06 <ion> foo = a long expression
06:55:09 <Ragnaroek> is there set comprehension in Haskell?
06:55:11 <ion>     $ another long expression
06:55:17 <Cale> mm_freak: yeah, perhaps, though that often involves inventing artificial names for things, rather than letting the structure of the code speak for itself
06:55:20 <ion>     $ second parameter to the first expression
06:55:26 <ion> would be convenient.
06:55:32 <Cale> Ragnaroek: no, but there's list comprehension
06:55:40 <lispy> Igloo: I'm not too worried about that in this case as the motivation for me is to learn more about the things involved (C99, the RTS source, ROSE/coccinelle). So if the changes are not appropriate I still learn things.
06:55:41 <mm_freak> in any case, i'm pretty happy with the way ($) is defined precisely because it does /not/ lead people to the misconception that dollar signs between arguments is in any way easier to read than parentheses =)
06:55:51 <mm_freak> after all you can write ")(" instead of "$" =)
06:56:06 <lispy> Igloo: if I complete them and they get accepted, then we both win :)
06:56:14 <Cale> mm_freak: Instead it has people chaining $'s rather than composing functions.
06:56:24 <Ragnaroek> ok, but set comprehension would be nice too
06:56:34 <mm_freak> Cale: that's unfortunate, too, i agree
06:56:35 <Cale> In fact, I'd be pretty okay with ($) being removed!
06:56:45 <Cale> (though I wouldn't really support that)
06:56:57 <Cale> But (.), never
06:57:07 <keep_learning> dcoutts, The vector library in libraries folder  is  version 0.9.1 and its  installed also but i am not sure why its showing any error.
06:57:12 * cmccann suggests giving ($) the same fixity as (<$>)
06:57:40 <lispy> cmccann: ($) is infixl right? and should be infixr?
06:57:44 <mm_freak> i'd have no issues with ($) being removed
06:57:54 <mm_freak> i'm fine with the more mathematical "(f . g . h) x"
06:57:58 <Cale> ($) is infixr and should be infixl
06:58:02 <lispy> ah
06:58:05 <mm_freak> then it's also more apparent how to remove points from function definitions
06:58:09 * lispy always gets that backwards
06:58:16 <cmccann> also, (<$>) is infixl 4
06:58:28 <mm_freak> "f x = (g . h) x" ⇒ "f = g . h"
06:58:37 <cmccann> as is (<*>)
06:58:39 <DanBurton> removing $ would be annoying though, especially for monadic code, e.g. foo <- lift $ expr
06:58:48 <cmccann> therefore, I think ($) and (=<<) should also be infixl 4
06:58:55 <mm_freak> DanBurton: would it?  i almost always use parentheses there anyway
06:59:03 <mm_freak> liftIO (f x y)
06:59:04 <Ragnaroek> are there chances that set comprehension will be added?
06:59:13 <DanBurton> mm_freak: but then you have to remember to add a close paren at the end
06:59:13 <Cale> Ragnaroek: What would set comprehension do?
06:59:19 <ion> “zip ($) fs xs” might express the intent better than “zip id fs xs”, though.
06:59:30 <Cale> Ragnaroek: Haskell doesn't have a built-in notion of sets.
06:59:35 <mm_freak> DanBurton: if that's your issue, you have much more serious problems =P
06:59:36 <cmccann> Cale, comprehend a list and then use Data.Set.fromList? :P
06:59:41 <hpc> ion: zipWith, you mean?
06:59:45 <ion> yeah
06:59:57 <DanBurton> mm_freak: xD i use paredit for my lispy code but not for my Haskell
07:00:16 <Ragnaroek> year, but fromList sucks
07:00:19 <Cale> I suppose if you want to bless Data.Set into the Report libraries, say.
07:00:23 <Ragnaroek> I want native sets in Haskell :)
07:01:06 <yrlnry> The sysadmin here has a CD-ROM lying around with "SIIX" written on it in marker, for some reason I do not know.  Every time I visit the water cooler I pass by and see it and think "But that is not well-typed!"
07:01:10 <Cale> I think it's nice that Set and Map and so on are just libraries.
07:01:11 <DanBurton> the state of Data.Set bothers me sometimes. What if I want a set of things that do not instantiate Ord? >,<
07:01:26 <Cale> DanBurton: That's theoretically difficult to manage
07:01:45 <DanBurton> Cale: indeed. But I wish it were magically done already.
07:01:53 <ion> I want native syntactic sugar OpenGL, gzip and amplitude modulation in Haskell.
07:02:19 <Cale> In mathematics, because we don't insist on the elements of sets being computable, it's easy.
07:02:21 <erus`> you guys know any good docs for (partial) type inference in system f?
07:02:41 * DanBurton proposes a Set typeclass
07:03:15 <Cale> But in a programming language, we usually want the membership of an element in a set to be possible to determine in a computable way, and not only that, but that we have good asymptotic bounds on the time it'll take for a set of n elements.
07:03:20 <yrlnry> Are ord instances required to implement total orders?
07:03:35 <cmccann> yrlnry, ideally or in practice?
07:03:37 <Cale> yrlnry: You could explicitly take comparison functions.
07:03:50 <Cale> oh
07:03:52 <Cale> yes
07:04:00 <Cale> I read your question backwards
07:04:01 <Cale> hehe
07:04:02 <yrlnry> I mean in the same sense that Monad instances ar expected to actually satisfy the Monad laws, even though this is not enforced.
07:04:18 <Cale> Ord instances must be totally ordered for many things to work correctly
07:04:27 <cmccann> > let x = 0/0 in (x <= x, x >= x)
07:04:27 <lambdabot>   (False,False)
07:04:39 <DanBurton> o_O
07:04:46 <Cale> Of course, Float breaks the rules :)
07:04:50 <yrlnry> DanBurton:  I think that's IEEE NaN.
07:04:56 <Cale> Yeah
07:04:59 <cmccann> breaks both the rules and Data.Set/Data.Map
07:05:01 <lispy> DanBurton: you have my code?
07:05:18 <DanBurton> lispy: all ur codes r belong 2 us
07:05:26 <lispy> o noes!
07:05:31 <Cale> Though a Data.Set of Float values, or a Data.Map keyed on Floats is a bad idea to begin with.
07:05:34 <cmccann> using Floats as keys can make other non-NaN keys "vanish" if you insert a NaN
07:05:35 <ion> > Set.fromList [0/0, 0/0, 0/0]
07:05:36 <lambdabot>   Not in scope: `Set.fromList'
07:05:38 <ion> > S.fromList [0/0, 0/0, 0/0]
07:05:39 <lambdabot>   fromList [NaN,NaN,NaN]
07:05:47 <Cale> Anything which compares Float values for equality is probably subtly flawed.
07:06:03 <lispy> s/probably//
07:06:11 <hpc> s/subtly//
07:06:12 <cmccann> (==) on Float makes sense as comparing for identity
07:06:23 <DanBurton> Cale: can lambdabot import the collections libraries?
07:06:33 <Cale> > S.fromList [1,2,3]
07:06:34 <lambdabot>   fromList [1,2,3]
07:06:38 <Cale> It does
07:06:59 <DanBurton> S = Data.Set, what are the others? is it listed somewhere?
07:06:59 <ion> > M.fromList [(0, "foo"), (0/0, "bar"), (1, "baz"), (0/0, "quux"), (2, "narf"), (0/0, "poit"), (3, "the game")]
07:07:00 <lambdabot>   fromList [(0.0,"foo"),(NaN,"bar"),(1.0,"baz"),(NaN,"quux"),(2.0,"narf"),(Na...
07:07:44 <DanBurton> > T.toList . S.fromList $ [1,2,3]
07:07:45 <lambdabot>   Not in scope: `T.toList'
07:08:03 <cmccann> > S.fromList  [0, -1, 0/0, -5, -6, -3]
07:08:04 <lambdabot>   fromList [-6.0,-5.0,-3.0,-1.0,0.0,NaN]
07:08:33 <hpc> for extra fun, use a Map with instances of Ord and Eq that disagree
07:08:44 <cmccann> > S.member 0 . S.insert (0/0) $ S.fromList  [0, -1, 0/0, -5, -6, -3]
07:08:45 <hpc> *with keys with*
07:08:46 <lambdabot>   False
07:08:52 <DanBurton> > 0/0 < minBound
07:08:53 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:08:53 <lambdabot>    `GHC.Classes.Ord t'
07:08:53 <lambdabot>     ...
07:08:58 <DanBurton> > 0/0 < minBound :: Float
07:09:00 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
07:09:00 <lambdabot>         against inferred typ...
07:09:02 <DanBurton> doh
07:09:08 <DanBurton> > 0/0 < (minBound :: Float)
07:09:09 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
07:09:09 <lambdabot>    arising from a use of...
07:09:25 <erus`> @pl fix f = f (fix f)
07:09:25 <lambdabot> fix = fix (ap id)
07:09:28 <ion> Floats certainly have bounds. ;-)
07:09:34 <DanBurton> I thought Float instantiated bounded :P
07:09:35 <cmccann> > sort  [0, -1, 0/0, -5, -6, -3, 0/0]
07:09:36 <lambdabot>   [NaN,-6.0,-5.0,-3.0,NaN,-1.0,0.0]
07:09:53 <cmccann> > sort  [0/0, 0, -1, 0/0, -5, -6, -3]
07:09:54 <lambdabot>   [-6.0,-5.0,-3.0,NaN,-1.0,0.0,NaN]
07:09:57 <erus`> can i define fix as a lambda term?
07:10:29 <hpc> > join .: show $ repeat (0/0)
07:10:29 <jedai> erus`: With fix yes ... ;)
07:10:30 <lambdabot>   Couldn't match expected type `m (m a)'
07:10:30 <lambdabot>         against inferred type `GHC.T...
07:10:32 <byorgey> erus`: you can define a fixpoint combinator in the untyped lambda calculus
07:10:35 <shapr> What's the best way to make a trig graphing tool on Linux with Haskell?
07:10:36 <hpc> > join .: show $ cycle (0/0)
07:10:36 <lambdabot>   Couldn't match expected type `m (m a)'
07:10:36 <lambdabot>         against inferred type `GHC.T...
07:10:39 <DanBurton> @let prop_sort xs = sort xs == sort (sort xs)
07:10:39 <hpc> pah
07:10:40 <lambdabot>  Defined.
07:10:43 <erus`> in system f ?
07:10:50 <jedai> shapr: Not fix though
07:10:51 <shapr> Should I use the cairo bindings? Would byorgey's diagram library do trig graphs?
07:10:55 <DanBurton> > prop_sort [0, -1, 0/0, -5, -6, -3, 0/0]
07:10:57 <lambdabot>   False
07:10:57 <erus`> someone said i can create infinite recusion
07:10:59 <osfameron> isn't the y-combinator untyped?
07:11:05 <erus`> but i cant figure out how
07:11:10 <shapr> jedai: je ne sais pas :-P
07:11:12 <byorgey> erus`: no, system F is strongly normalizing
07:11:20 <hpc> erus`: system F + fix = not strongly normalizing
07:11:30 <byorgey> erus`: although you can certainly add a constant called 'fix' to system F and give it the proper typing and reduction rules
07:11:35 <hpc> (pretty much anything + fix, in fact)
07:11:36 <DanBurton> osfameron: the untyped lambda calculus is untyped
07:11:44 <erus`> oh cool
07:11:49 <erus`> i want a total language
07:11:53 <hpc> erus`: agda
07:11:56 <ion> system F + fix + British → not strongly normalising
07:12:09 <hpc> erus`: be warned, it's not turing-complete
07:12:11 <erus`> hpc i want to make one :)
07:12:13 <jedai> erus`: or Coq (less Haskell-like though)
07:12:25 <hpc> coq is write-only, imo
07:12:26 <byorgey> shapr: diagrams does cubic splines, so you can create nice function graphs by sampling the functions at a bunch of points and creating a cubic spline through the points
07:12:33 <shapr> huh
07:12:41 <DanBurton> osfameron: in Haskell you can't define y = omega omega, because of the infinite types
07:12:49 <byorgey> shapr: there isn't a module to do graphs per se, but it would be a nice thing to have added to diagrams-contrib
07:12:52 <DanBurton> osfameron: but that doesn't mean you can't define the y combinator
07:13:03 <byorgey> shapr: I know fryguybob is using diagrams to create a function graphing tool
07:13:35 <shapr> fryguybob: got code?
07:13:46 * shapr installs diagrams-contrib
07:13:59 <osfameron> DanBurton: tbh I barely understand 'fix' and don't understand Y at all... I think I'm due another attempt at them...
07:14:09 <byorgey> shapr: -contrib is not on Hackage yet, but you can get it from patch-tag
07:14:14 <ddarius> @src fix
07:14:15 <lambdabot> fix f = let x = f x in x
07:14:28 <DanBurton> hpc: at least you can step through the steps of coq interactively
07:14:36 <byorgey> shapr: http://patch-tag.com/r/fryguybob/LaTeXGrapher/home
07:14:43 <shapr> yay!
07:15:24 <DanBurton> hpc: the code itself is absolutely unreadable, unless your brain is a coq interpreter that perfectly keeps track of subgoals
07:17:25 <quicksilver> isn't everyone's brain like that?
07:23:14 <shapr> Does cabal-install <dir> work?
07:23:25 <luite> shapr: just cabal install in that dir
07:23:29 <shapr> Bah
07:23:33 <byorgey> shapr: I don't think so
07:23:44 <shapr> Would be especially nice to be able to do "cabal install diagrams-*"
07:24:01 <byorgey> shapr: well, you can 'cabal install diagrams' which gets you  diagrams-core, diagrams-lib, and diagrams-cairo
07:24:31 <luite> only if the verisons you need are on hackage
07:24:45 <byorgey> oh! I see, right
07:24:46 <ddarius> Maybe we can add a cabal install Data.* which would just be an alias to install every package on Hackage.
07:24:53 <byorgey> you mean you have them in directories
07:24:55 <shapr> Yah, fryguybob's code needs all dev libs from patchtag.
07:25:01 <byorgey> shapr: yeah
07:25:02 <DanBurton> ddarius: o+O
07:25:16 <shapr> byorgey: right, I have ~/build/ where I throw repo downloads of any flavor.
07:25:51 <luite> is it possible btw to override optimizaiton options globally with cabal-install? I'd like to build everything with -O0
07:26:11 <byorgey> shapr: yeah, I have a little home-cooked script that looks for a file called "deps" that lists package dependencies and rebuilds them all in the right order
07:26:26 <byorgey> otherwise I'd go crazy doing diagrams development
07:26:43 <shapr> does deps build dependencies from .cabal files?
07:26:54 <shapr> and does it assume the libs are subdirectories ?
07:27:01 <byorgey> no, deps is a file where I just manually list the dependencies
07:27:09 <shapr> yow
07:27:09 <byorgey> I hacked this together in like ten minutes.
07:27:14 <shapr> oh :-)
07:27:20 <luite> hehe every larger project seems to have some of those
07:27:29 <shapr> I see a great need, as Igloo would say.
07:27:58 <byorgey> yeah, a nice lib to do this kind of automatic management of multiple related packages would be awesome.
07:28:12 <shapr> What should it do?
07:28:14 <luite> I'm still waiting way too long every day for packages to rebuild...
07:28:21 <eikke> would anyone know whether there's a real simple example of an enumerator-based client-server app (pingpong-style) available somewhere?
07:28:55 <byorgey> shapr: at a minimum, automatically rebuild downstream dependencies every time you build a package.
07:29:17 <byorgey> shapr: maybe tools for testing all the packages at once, uploading multiple ones to Hackage at once, etc.
07:29:24 <shapr> poo, LaTeXGrapher requires vector-space 0.7, but it also depends on diagrams-postscript that requires vector-space 0.8
07:29:33 <luite> is it btw possible to unbreak a package when you rebuild it without changing the api?
07:29:50 <byorgey> shapr: it will probably work if you just bump the vector-space upper bound for LaTeXGrapher
07:30:09 <shapr> ok
07:30:26 <byorgey> and you should also bug fryguybob to fix it
07:30:31 <byorgey> =)
07:30:36 <shapr> fryguybob: OH GREAT DEVELOPER...
07:31:23 <byorgey> IIRC fryguybob made it for his wife, but I'm sure he would be happy to see others finding it useful as well.
07:32:07 <luite> it's a bit annoying having to rebuild 20 packages if you just add a few debug commands to one dependency
07:32:36 <shapr> Oops, diagrams-postscript really does require vector-space 0.7, must be an API change
07:33:31 <ddarius> luite: Set up a build server.
07:34:34 <luite> ddarius: hmm, can you be more specific? is there anything that can rebuild them automatically, or that rebuilds packages without breaking things that depend on them?
07:35:18 <byorgey> shapr: you mean you get an error when you try to build diagrams-postscript with a later version of vector-space?
07:37:18 <ddarius> luite: I'm not sure if I have anything more specific.  It was only a semi-serious suggestion and would only ease the process, you'd still have to wait for it to rebuild after making changes.
07:37:26 <shapr> byorgey: yes
07:37:38 <byorgey> shapr: oh, I don't think it's because of vector-space
07:37:42 <byorgey> shapr: just a second, I'll make a patch
07:37:57 <quicksilver> what would help, but wouldn't be easy, would be for packages to declare explicitly that they support multiple (source) API versions
07:38:05 <shapr> whee!
07:38:28 <quicksilver> so you could release diagrams 0.8 because you did make an API change according to the PVP, but you could declare that it's source comptaible with 0.7
07:38:32 <luite> ddarius: well if there's something that could rebuild packages in parallel (if there are no dependencies between them) that would already help a lot
07:38:35 <quicksilver> so packages with upper-bounds wouldn't break.
07:38:54 <quicksilver> would that make cabal's solver even more intractable than it already is?
07:39:05 <shapr> quicksilver: Or persuade libs to include quickcheck properties, remove all upper bounds on dependencies version numbers, and see if the QC props pass!
07:39:05 <byorgey> quicksilver: that's an interesting idea.
07:40:02 <quicksilver> shapr: it is hard to accurately predict which properties will be broken by future versions, which you happen to depend upon.
07:40:17 <quicksilver> that is, it's hard to make a finite but complete list of all properties you depend on.
07:40:32 <ddarius> quicksilver: It would be an iterative process like anything else.
07:41:00 <quicksilver> quite often that would be too late
07:41:01 <ddarius> And the end result would be a sweet test suite.
07:41:09 <shapr> would be fun to try at least
07:41:11 <quicksilver> where our current approach is conservative htat would be liberal.
07:41:19 * shapr brands himself a liberal
07:41:24 <luite> anyway I find it hard to debug larger haskell things. at the moment I have  problem with wai/yesod that causes certain post requests to hang (before they get to my own code) with C++ or Java I'd just stop the threads, see where in the library they are stuck, and then set some breakpoints based on that. with haskell I don't really know where to start
07:41:38 * quicksilver brands shapr with a lambda on his bleeding heart.
07:41:40 * ddarius brands shapr Grade A Choice beef.
07:41:43 <shapr> hah
07:41:59 <Enigmagic> luite: you can do that too in gdb
07:42:02 <Enigmagic> it's just painful :_)
07:42:10 <shapr> luite: Are there any Haskell debuggers?
07:42:15 <hpc> luite: time profiling, perhaps
07:42:21 <shapr> luite: Can you throw quickcheck properties and/or assertions at the code?
07:42:28 <luite> shapr: ghci debugger, but it really isn't suitable for this
07:42:55 <luite> shapr: problem is that for any debug print thing that I add, I need to rebuild 30 packages or so
07:43:17 <Enigmagic> luite: if you rebuild with -debug you can do some of it in gdb
07:43:27 <luite> hpc: hmm, that might work here, although I've built everything without profiling
07:43:46 <luite> library-profiling just takes too much build tim
07:43:47 <luite> e
07:43:53 <hpc> true
07:43:57 <quicksilver> why do you need to build 30 packages when you've added a single debug print?
07:44:02 <shapr> luite: buy a beefier desktop?
07:44:10 <xarch__> http://paste.awesom.eu/bDA&hl=haskell how could I optimize the memory usage of this code?
07:44:22 <quicksilver> is this because of ABI hashes?
07:44:24 <hpc> quicksilver: it hangs before his code
07:44:27 <luite> quicksilver: the debug print would be somewhere deep in wai or warp, the application is built on yesod, lots of packages that depend on the changed one
07:44:56 <quicksilver> hrm
07:44:57 <byorgey> shapr: sent
07:45:04 <luite> if there's a way to rebuild some "deep" package, add some debug stuff, and not break things that depend on it, then I'd be very happy :)
07:45:20 <quicksilver> surely adding a debug print shouldn't change library ABI
07:45:25 <quicksilver> why woudl other packages need rebuilding?
07:45:26 <xarch__> I can't use more than 6 Mo, but for an unknown input it uses more than that
07:45:37 <hpc> luite: hex editor on the object file ;)
07:45:44 <luite> quicksilver: it still breaks everything that depends on it if I cabal install in that dir
07:45:47 <luite> hpc: hah
07:45:56 <hpc> luite: it might help to have an abacus on hand to count offsets
07:46:18 <shapr> byorgey: thanks!
07:46:24 <shapr> sadly, it's now time for class :-(
07:46:38 <ddarius> shapr: That's a sad thing?
07:46:46 <hpc> depends on the class
07:46:49 <luite> shapr: I'm working on my laptop, a desktop would help a bit, but probably not much more than 30% or so
07:46:53 <shapr> ddarius: I'd rather be writing Haskell
07:46:57 <quicksilver> luite: this sounds like a real problem. I've not done any multi-package development
07:46:59 <luite> since it's a recent model
07:47:02 <ddarius> shapr: Write Haskell in class.
07:47:06 <Enigmagic> luite: two things... you can patch up the package hashes and rebuild the package.conf file (ghc-pkg recache --user) and second you can dump out haskell threads in a native debugger to see where a thread is blocked
07:47:13 <shapr> luite: parallel cabal install? with eight cores or so?
07:47:29 <luite> quicksilver: yeah for me it is, I always feel totally lost doing these things... I was hoping that other ppl had developed some techniques :)
07:47:30 <hpc> it would be awesome if GHC could do parallel compilation
07:47:48 <Enigmagic> hpc: you mean cabal or ghc?
07:47:52 <luite> shapr: yeah more cores would help if there was a parallel cabal install :p
07:47:52 <bgamari> luite: Or you can use +RTS -xc to get a back-tracish thing
07:47:54 <shapr> I thought cabal could do parallel builds?
07:47:57 <bgamari> luite: But this requires profiling
07:48:08 <luite> bgamari: yeah I don't have profiling atm
07:48:14 <hpc> Enigmagic: either; "ghc -c foo.hs bar.hs baz.hs ..."
07:48:15 <luite> can rebuild, again...
07:48:17 <bgamari> Slightly more civilized than gdb (but only slightly)
07:48:25 <bgamari> luite: I certainly feel your pain though
07:48:28 <dcoutts> shapr: the patches are still being worked on
07:48:34 <luite> shapr: there's an experimental branch
07:48:35 <bgamari> I really wish haskell was a bit more debuggable
07:48:38 <shapr> dcoutts: oh, that's too bad
07:48:48 <luite> oh right, the real expert is here:p
07:49:01 <bgamari> DWARF would help quite a bit it seems
07:49:15 <Enigmagic> bgamari: there is a DWARF branch with function/line number info
07:49:19 <luite> dcoutts: any news or estimates on that btw?
07:49:23 <bgamari> Enigmagic: Is there really?
07:49:34 <luite> parallel cabal install would really help tremendously here
07:49:37 <bgamari> Enigmagic: Could you point me towards it?
07:49:44 <Enigmagic> bgamari: yeah i've been slowly working on stack walking too https://plus.google.com/118432899194915702514/posts/bPF9X3s3iM3
07:50:04 <Enigmagic> bgamari: here's the dwarf branch https://github.com/scpmw/ghc/commits/profiling
07:50:26 <dcoutts> luite: it's the GSoC student still working on it, monitor cabal-devel for progress
07:50:29 <bgamari> Enigmagic: Very nice
07:51:07 <czro> #join #python
07:51:38 <luite> dcoutts: do you know btw, if I want to rebuild a pacage (add some debug prints), is it possible to install it without breaking everything that depends on it?
07:52:04 <Enigmagic> bgamari: i've been working with the lldb devs too to hopefully get a working set of extensions for GHC
07:52:39 <Enigmagic> bgamari: i have various bits of crap here, i'll be doing some more work on it again in a few weeks https://github.com/alphaHeavy/ghc-lldb
07:52:49 <smithw> Hi, I'm learning haskell through this tutorial (http://learnyouahaskell.com/a-fistful-of-monads) and I notice that in this part of the code (http://hpaste.org/57236), (c', r') is defined in terms of a "combination" of (c,r), ((+),(+).negate), (2,1) and (1,2). Is there a way to generate that list using bindings and/or applicative functors?
07:53:57 <Veinor> how do i install cabal using ghc 7.4?
07:54:16 <bgamari> Enigmagic: is proper tables-before-code on that list
07:54:40 <bgamari> Enigmagic: This is something I've been thinking of starting a dialogue with the LLVM devs about
07:54:51 <Baughn> Veinor: Ideally, use haskell-platform. Do you have a special reason to want 7.4?
07:54:53 <byorgey> smithw: well, at the very least you could write [(c+i, r+j) | i <- [2,-2,1,-1], j <- [-1,1]]
07:54:57 <bgamari> Enigmagic: Doh, lldb not llvm
07:55:01 <Veinor> Baughn: Yeah, I want to play around with it
07:55:05 <Veinor> :)
07:55:08 <Baughn> Veinor: Good enough. :P
07:55:09 <Enigmagic> bgamari: lldb not llvm :-)
07:55:15 <Baughn> Veinor: There should be a bootstrap script in the cabal-install repository
07:56:07 <smithw> byorgey, wow, I've been so immersed in functors and monads that I totally forgot about list comprehensions. Thanks for the tip
07:56:14 <byorgey> hehe =)
07:56:32 <byorgey> smithw: list comprehensions are just a convenient syntax for the list monad.
07:56:48 <ddarius> s/convenient//
07:56:57 <byorgey> hehe
07:57:11 <byorgey> in fact, as of GHC 7.2, they are a syntax for any monad.
07:57:12 <cmccann> don't we have monad comprehensions now?
07:57:20 <cmccann> so make that "a syntax for monads"
07:57:45 <byorgey> comprehensions are a syntax for monads.
07:57:56 <ddarius> Wadler would be proudd.
07:58:03 <smithw> byorgey, how would I translate that comprehension to a bind?
07:58:44 <byorgey> [2,-2,1,-2] >>= \i -> [-1,1] >>= \j -> return (c+i,r+j)
07:59:03 <ddarius> @undo [(c+i, r+j) | i <- [2,-2,1,-1], j <- [-1,1]]
07:59:04 <lambdabot> concatMap (\ i -> concatMap (\ j -> [(c + i, r + j)]) [- 1, 1]) [2, - 2, 1, - 1]
07:59:18 <byorgey> oh, @undo supports comprehensions, nice =)
07:59:34 <byorgey> not a very readable way to write it though.
07:59:46 <ddarius> It gets better.
07:59:52 <ddarius> @undo [(c+i, r+j) | i <- [2,-2,1,-1], j <- [-1,1], False]
07:59:53 <lambdabot> concatMap (\ i -> concatMap (\ j -> if False then [(c + i, r + j)] else []) [- 1, 1]) [2, - 2, 1, - 1]
08:00:01 <byorgey> hehehe
08:00:02 <cmccann> undo isn't really there to make code pretty, I think
08:00:08 <cmccann> that's what pl is for, obviously
08:00:17 <byorgey> right, that's what @pl ... cmccann beat me to it
08:00:21 <cmccann> :D
08:00:40 <cmccann> the set up was too obvious I guess
08:00:43 <byorgey> @. pl undo [(c+i, r+j) | i <- [2,-2,1,-1], j <- [-1,1], False]
08:00:43 <lambdabot> (line 1, column 77):
08:00:43 <lambdabot> unexpected "["
08:00:43 <lambdabot> expecting variable, "(", operator or ")"
08:01:07 <byorgey> @. undo pl [(c+i, r+j) | i <- [2,-2,1,-1], j <- [-1,1], False]
08:01:07 <lambdabot> ((line 1, column 1) : unexpected "[" expecting white space, "()", natural, identifier, lambda abstraction or expression)
08:01:10 <byorgey> bah
08:01:13 <smithw> thanks for the help everyone :) would I be wrong to guess that list monads are often used in probability calculations?
08:01:27 <ddarius> pl definitely can't handle list comprehensions directly, but it should be able to handle the output of undo.
08:01:41 <byorgey> smithw: they are similar, but much better would be using a probability monad in probability calculations =)
08:02:29 <byorgey> smithw: http://hackage.haskell.org/package/probability
08:02:32 <cmccann> well, lists serve as a simple-minded nondeterminism monad, and it's easy to add probability on top of that... but you likely want something designed for the purpose
08:02:33 * ddarius wonders if he can make a model checking monad/applicative functor.
08:02:47 <smithw> byorgey, well, I don't think this tutorial I'm reading covers it, I'll take a look at that link, thanks again :)
08:03:02 <alpounet> smithw, there's a talk by Dan Piponi that covers a bit a Probability monad in haskell, and also blog posts by him, too (and there are posts by other people too)
08:04:14 <smithw> alpounet, I'll google for that too, thanks :)
08:04:38 <alpounet> you'll most likely find papers too
08:08:57 <tkahn6> does anyone have any experience with greencard or c2hs?
08:09:13 <ddarius> There are tons of papers on "quantum mechanics" monads that are essentially just probability monads.
08:10:31 <cmccann> ddarius, well, what else would they be?
08:11:31 <quicksilver> improbability drive monads
08:29:02 <mroman> http://codepad.org/enY0n6j4 <- there a way to get rid of Nil?
08:29:18 <mroman> B (A) par example
08:29:34 <mroman> but A Term | A is not legal in data
08:30:20 <cmccann> oh boy
08:30:46 <mroman> Wth just happened?
08:30:52 <francesco1> netsplit
08:30:59 <byorgey> mroman: alien invasion
08:31:09 <smithw> http://hpaste.org/57236 <- I guess the annotation was what I was looking for
08:31:36 <mroman> Ic.
08:33:00 <mroman> Ok. So back to my question
08:33:28 <mroman> is it possible to formulate A ( B ( B ( A ) ) ) in Haskell?
08:33:38 <mroman> as data.
08:34:03 <quicksilver> data AorB = A AorB | B AorB
08:34:04 <quicksilver> ?
08:34:14 <quicksilver> hmm you need a nil-case
08:34:27 <quicksilver> data AorB = A AorB | B AorB | StopItThatsEnough
08:34:47 <quicksilver> then you get A ( B ( B ( A StopItThatsEnough ) ) ) which is nearly what you asked for.
08:35:09 <rostayob> or more simply 'data AB = A | B', and then '[AB]'
08:35:30 <rostayob> or [Either () ()]!
08:36:00 <quicksilver> I now see mroman's original uestion
08:36:04 <jeff_s_> If I have an "overlapping instances" error, what is an easy way to pick which one I want? Incidentially, GHC is picking some really bizarre overlapping instances, that don't appear to match at all.
08:36:05 <quicksilver> http://codepad.org/enY0n6j4
08:36:21 <quicksilver> you can't. Don't use them.
08:36:44 <quicksilver> mroman: can you explain "why" you want to get rid of Nil?
08:36:59 <cmccann> jeff_s_, recall that GHC doesn't examine contexts when picking instances
08:37:10 <mroman> Because then I have "Nil" as a 'value'
08:37:36 <mroman> And I can't just 'read' the input ;)
08:37:39 <quicksilver> well the point is mroman that A either has an argument or it doesn't.
08:37:49 <mroman> As the input is in the format (A (B (A)))
08:37:56 <cmccann> jeff_s_, i.e., "(Integral a) => Foo a" and "(Fractional a) => Foo a" overlap
08:37:57 <quicksilver> it doesn't make sense in haskell terms to have a constructor which takes an argument almost all the time except when it doesn't.
08:38:05 <asante> can someone explain me the difference between manually and automatically deriving instances of typeclasses, as explained in "real world haskell" chapter 6, automatic derivation
08:38:19 <asante> http://book.realworldhaskell.org/read/using-typeclasses.html somewhere in the middle
08:38:33 * cmccann thinks mroman wants a non-empty list of A | B, perhaps
08:38:35 <byorgey> asante: for some particular type classes, GHC can automatically generate code for you.
08:38:57 <asante> ok, i understand that, i think xD
08:39:00 <mroman> cmccann: That would work in this simple case
08:39:03 <mroman> but not if you extend it
08:39:09 <byorgey> asante: but sometimes you want to write them yourself, and for other classes you must write them yourself, because GHC can't.
08:39:23 <mroman> C (B (A)) (A (B)) etc.
08:39:50 <asante> byorgey, i dont understand the problem with this example: http://pastebin.com/TWk5BdP4
08:39:52 <mauke> The paste TWk5BdP4 has been copied to http://hpaste.org/57238
08:40:10 <byorgey> mroman: trying to arrange things so that 'read' will work on the particular data format you happen to have is a terrible, horrible abuse of the Read class.
08:40:14 <byorgey> mroman: just write a parser.
08:40:29 <Baughn> mroman: Read is horrifyingly slow, on top of everything else
08:40:38 <cmccann> mroman, well, it doesn't really make sense to have A and B both be leaf nodes and data cosntructors there
08:40:48 <Baughn> mroman: Use binary, attoparsec or parsec (in increasing order of format complexity and decreasing order of speed)
08:40:56 <Baughn> mroman: Or just use parsec and worry about speed later
08:41:32 <quicksilver> asante: what problem? that code compiles fine.
08:41:38 <byorgey> asante: it works fine for me.
08:41:45 <asante> mh
08:41:47 <shachaf> data AB where A :: a -> AB; B :: a -> AB
08:41:52 <byorgey> asante: if you get an error, please paste that as well.
08:41:55 <shachaf> A (B (B A))
08:42:05 <cmccann> shachaf, I didn't want to suggest that because it's a hack :P
08:42:10 <shachaf> What a useful type.
08:42:32 <byorgey> it's also not useful.  You can make one, but you can't do anything with it once you do.
08:42:42 <cmccann> oh, I misread it
08:43:11 <shachaf> When I said "useful" I think I meant "not useful".
08:43:50 <asante> byorgey, quicksilver: it compiles, but if i make a CannotDeriveShow type and want to "show" it, i'll get an no-instance error,
08:44:02 <quicksilver> I don't.
08:44:06 <byorgey> me neither.
08:44:10 <asante> mh.. lol
08:44:17 <byorgey> asante: please show us exactly what you type, and what error you get.
08:44:18 <quicksilver> > show (CannotDeriveShow CannotShow)
08:44:19 <quicksilver> "CannotDeriveShow CannotShow"
08:44:23 <quicksilver> says my ghci
08:44:44 <byorgey> asante: note that 'CannotDeriveShow' by itself is a function of type  CannotShow -> CannotDeriveShow
08:44:45 <asante> ok, but its mentioned in the book to be not working.. and i was just wondering why that should work
08:44:52 <ddarius> You can tell whether it's outermost level is an A or B.  That's a whole bit of information.
08:45:17 <asante> byorgey, thanks, that was my mistake, i think
08:45:28 <byorgey> asante: there is no way to Show functions in general
08:45:31 <quicksilver> asante: well it won't work if you don't have "deriving Show" on CannotShow
08:45:35 <quicksilver> which I assume is the idea
08:45:40 <quicksilver> however that is there
08:45:44 <shachaf> ddarius: Much more informative than half a bit.
08:45:44 <quicksilver> which makes CannotShow misnamed
08:45:47 <quicksilver> since it has a show instance
08:45:49 <asante> yes, ok.
08:46:04 <asante> but why does the book says it wouldnt compile?
08:46:09 <kallisti_> @hoogle a -> ptr a
08:46:12 <kallisti_> @hoogle a -> Ptr a
08:46:17 <kallisti_> oh, no lambdabot.
08:47:12 <byorgey> asante: looks like an error in the book.
08:47:13 <kallisti_> ah new is what I'm looking for.
08:47:54 <asante> byorgey, ok.. thanks!
08:48:22 <guerrilla> what's that book that teaches how to write a lisp interp in haskell? a friend needs help with s-expressions...
08:48:28 <byorgey> asante: I think they meant for the 'deriving (Show)' line following data CannotShow = ... to not be there
08:48:42 <guerrilla> ah, it was schene.. that's why my google-foo fails :P
08:48:55 <byorgey> @google scheme 48 hours
08:49:09 <byorgey> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
08:49:27 <asante> byorgey, ya, that would make sense.
08:51:10 <mreh> :t (.&.)
08:51:26 <mreh> @bots
08:51:31 <eviltwin_b> netsplit killed the bot, I guess
08:51:50 <eviltwin_b> Prelude Data.Bits> :t (.&.)
08:51:50 <eviltwin_b> (.&.) :: Bits a => a -> a -> a
08:51:58 <cmccann> alas, lambdabot has gone to the great fixed point in the sky
08:52:23 <mreh> eviltwin_b: thanks... that raises more questions though
08:53:28 <eviltwin_b> what questions?
08:54:33 <mreh> i just hoogle what Bits was, found out quickly enough
08:54:35 <eviltwin_b> probably most of your questions are ansswered in the documentation for Data.Bits
08:55:47 <mreh> this gets complicated, i'm looking at code that uses withArray with a list of an unknown type
08:57:04 <mreh> it works well enough, but how was the programmer going to be sure that his numbers were going to be interpreted as unsigned bytes, because that's the type of the data he's telling OpenGL will be in this texture array?
08:59:35 <ddarius> cmccann: Polaris?
08:59:44 <cmccann> heh
09:04:48 <mroman> http://codepad.org/XmzBKqD5
09:05:03 <mroman> apparently I suck at Parsec :(
09:05:59 <danols_work> #freeswitch
09:06:15 <neutrino> hi
09:06:20 <neutrino> kmc: hi
09:07:01 <lpsmith> mroman, what's the problem?
09:07:20 <mroman> I'd expect A (B Nil)
09:07:23 <mroman> not an error and Nil
09:07:50 <mroman> also.. if I change parseNested <|> parseSingle to
09:07:55 <benchmar_> I thought that you could use floyd warshall to solve the Frogger problem by generating shortest paths
09:07:56 <neutrino> has anyone here used gnuplot in conjunction with a windowing system in order to create an interface for a zoomable plot?
09:07:56 <mroman> parseSingle <|> parseNested
09:07:57 <mroman> then
09:08:00 <benchmar_> between all nodes
09:08:03 <mroman> A(B) gives me (A Nil)
09:08:04 <neutrino> or any other plotting lib tbh
09:08:16 <mroman> no error, but still not correct. That must be A (B Nil)
09:08:48 <jeff_s_> I have a hierarchy of type classes, but now that I'm bringing them all together, I'm getting some type errors.
09:08:56 <jeff_s_> http://hpaste.org/57239
09:09:33 <neutrino> another question: what's the best way to take a string of words separated by spaces, and create from it a list of pairs? something like words . whatever, where whatever :: [a] -> [(a, a)]
09:10:24 <mroman> zip $ [a] [a] ?
09:10:37 <neutrino> i want to alternate
09:10:55 <neutrino> "aa bb cc dd" -> [("aa", "bb"), ("cc", "dd")]
09:10:59 <byorgey> jeff_s_: there's no way to figure out what the type variables a,b,c are supposed to be in that instance for E.
09:11:35 <byorgey> jeff_s_: is 'd' supposed to determine 'a','b', and 'c'?
09:11:39 <lpsmith> mroman, right,  that's because you can't reason about parsec the same way you'd reason about a context free grammar
09:11:46 <byorgey> jeff_s_: if so, perhaps you want a functional dependency for class D
09:12:14 <lpsmith> and, IIRC,  if an action consumes any input,  then parsec is committed to that alternative
09:12:27 <lpsmith> there is a combinator to fix that,  "try" IIRC
09:12:51 <lpsmith> you could also left-factor your grammar
09:13:34 <jeff_s_> byorgey - how do I introduce that?
09:13:39 <benchmar_> For the frogger problem (http://en.wikipedia.org/wiki/Frogger), is floyd warshall the right solution?
09:13:39 <mroman> neutrino: http://codepad.org/qbeb51mN <- like this?
09:13:43 * ddarius recommends left factoring the grammar (or using combinators that handle that) regardless.
09:13:55 <byorgey> jeff_s_: something like  class (A a, B b, C c) => D d a b c | d -> a b c where ...
09:14:08 <mroman> lpsmith: That means? parsec is only context free?
09:14:10 <neutrino> mroman: yes!
09:14:31 <neutrino> mroman: thank you
09:14:34 <neutrino> very much!
09:14:54 <jeff_s_> Byorgey  - oh my gosh, thanks! I'll look into that syntax. I didn't know about it.
09:15:03 <jeff_s_> Wha tis it called, so I can find it in the documentation?
09:15:12 <byorgey> jeff_s_: "functional dependencies"
09:15:22 <jeff_s_> OK, that's obvious enough I guess. thanks again!
09:15:28 <byorgey> sure
09:15:35 <mroman> As far as I understand it, the problem is, that both single and nested start with an 'A'
09:15:56 <mroman> and parsec does not "go back" if it detects that something did not match after that 'A'.
09:17:07 <lpsmith> right,  for example this produces an error
09:17:14 <lpsmith> parse ((char 'a' >> char 'b') <|> (char 'a' >> char 'c')) "" ("ac" ::  String)
09:17:31 <lpsmith> but you can fix that by left factoring the grammar:
09:17:45 <lpsmith> parse (char 'a' >> (char 'b' <|> char 'c')) "" ("ac" ::  String)
09:17:53 <mroman> Hm.
09:17:56 <mroman> Ic.
09:18:11 <byorgey> or by wrapping the first alternative in 'try'
09:18:20 <lpsmith> right
09:18:27 <byorgey> left-factoring is not always easy
09:18:27 <lpsmith> also,  try :)
09:18:41 <lpsmith> well, left-factoring this particular grammar is
09:18:56 <lpsmith> referring to mroman's grammar, that is
09:19:01 <byorgey> ok, fair enough.
09:19:08 <ddarius> For most artificial language grammars left factoring is fairly straightforward.
09:19:13 <mroman> hey.
09:19:16 <mroman> Try works
09:19:20 <mroman> \o/
09:19:41 <ddarius> It's desirable to minimize the use of try, though in the particular example lpsmith gave it makes little difference.
09:19:47 <lpsmith> mroman, so by default,  once a parser consumes any amount of input, it won't backtrack anymore
09:19:54 <xplat> of course then you have to un-left-factor the parse tree, often enough
09:20:05 <mroman> Ok. I'll try it without try.
09:20:21 <xplat> consume or consume not, there is no try?
09:20:35 <lpsmith> ... groan
09:20:39 <ddarius> xplat: That's usually a much easier thing to do if anything even needs to be done at all.
09:21:37 <lpsmith> another possibility in my example is to use the string parser,  because it won't consume anything unless the whole thing matches
09:21:43 <ddarius> Really what you want to avoid is "large" parsers surrounded by try.  Particularly, you do not want recursive parsers using try (though there are a few cases where that may be reasonable.)
09:22:20 <mroman> hm.
09:22:28 <lpsmith> ok, I was wrong about that
09:22:30 <xplat> lpsmith: isn't that only in attoparsec?
09:22:36 <lpsmith> xplat, yeah it is
09:22:38 <mroman> I'm not sure where to insert the brackets in do stuff
09:22:58 <mroman> char 'a' >> (char 'b' <|> char 'c')
09:23:27 <mroman> do char 'a' (do char 'b' <|> do char'c') ?
09:23:39 <mroman> is there char '' anyway?
09:23:47 <lpsmith> no
09:23:53 <mroman> I need something like
09:23:56 <xplat> what would that be?
09:24:04 <mroman> char 'a' >> (char '(' <|> nothing)
09:24:05 <lpsmith> do { char 'a';  (do { char 'b' } <|> do { char'c' } ) }
09:24:22 <kmc> mroman, see 'option', 'optionMaybe', 'optional'
09:24:25 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Combinator.html
09:24:37 <lpsmith> you can also do  (<|> return Nil)
09:24:42 <nand`> what does this instance declaration mean and more importantly how do I get it to compile? instance UrgencyHook DzenUrgencyHook Window where
09:25:11 <kmc> mroman, also those inner "do"s are redundant
09:25:16 <kmc> do { char 'x' }  = char 'x'
09:25:32 <kmc> the point of "do" is that you can sequence multiple things, and bind variables
09:26:10 <mroman> I know.
09:26:15 <mroman> Do notation considered harmful
09:28:56 <mroman> http://codepad.org/1oFwtSxr <- still not right
09:30:17 <mroman> It's somehow expecting 'A'
09:31:36 <mroman> oh.
09:31:39 <mroman> brackets missing.
09:31:55 <mroman> http://codepad.org/RsUAdAp2 <- seems to do it.
09:32:35 <kmc> mroman, it's not harmful
09:32:43 <kmc> at least, I like it
09:33:01 <tkahn6> c2hs is the coolest thing ever
09:33:02 <tkahn6> omg
09:33:07 <tkahn6> ^_^
09:33:33 <kmc> mroman, you have some superfluous "do"s and also some ($)s
09:33:48 <kmc> do return $ (A Nil)  ≡  return (A Nil)
09:33:59 <tkahn6> and the accompanying paper is so clear
09:37:55 <lpsmith> nand`, you'll have to ask a more specific question than that.  For starters we don't even know which library you are talking about
09:38:13 <kmc> the library is probably xmonad
09:38:22 <kmc> nand`, you should put your whole code on hpaste.org, as well as the error message you get
09:38:32 <kmc> just saying that it doesn't compile is not very helpful
09:43:58 <mroman> http://codepad.org/wcZYFMWx <- Works as expected.
09:44:08 <mroman> Thanks.
09:44:21 <mdmkolbe> Is there an equivalent of the __GLASGOW_HASKELL__ preprocessor flag, but for the version of the base package being used?  I've got code the needs to be one way under base-4.1 but another under base-4.2.
09:44:21 <nand`> lpsmith: kmc: appreciate the assistance but I solved the problem, turns out I was looking at a years old outdated version of the documentation
09:44:24 <nand`> 0.5 instead of 0.10
09:44:27 <nand`> and I didn't realize it
09:45:37 <neutrino> so guys, what's the fastest-to-develop-with windowing lib for haskell which works under linux?
09:45:57 <c_wraith> neutrino: depends. do you know wxwindows or gtk already?
09:46:01 <ddarius> neutrino: The one you are already familiar with.
09:46:07 <MostAwesomeDude> neutrino: "windowing lib"? You mean GUI toolkit?
09:46:14 <neutrino> MostAwesomeDude: yes
09:46:20 <neutrino> c_wraith: ddarius: neither
09:46:20 <MostAwesomeDude> neutrino: GTK+ or Wx.
09:46:42 <MostAwesomeDude> Both have designers and language-independent layout files, both work on Linux, both have Haskell bindings.
09:46:56 <MostAwesomeDude> (I'd also recommend Qt, but I don't know if there's Haskell bindings for it.)
09:47:05 <neutrino> i need to create a window which displays a graph, possibly from gnuplot. i need to be able to drag to zoom inside the graph. i need to replace the image diplayed for the graph with a new one when soom happens.
09:47:05 <kmc> mdmkolbe, if you are building with cabal, yes
09:47:08 <c_wraith> well, your options are what MostAwesomeDude says. You'll just need to pick whichever one you prefer. The haskell bindings for both are pretty close to the native use
09:47:10 <MostAwesomeDude> (And, of course, "recommend" is a strong word because all GUI toolkits suck.)
09:47:25 <ddarius> @hackage scope
09:47:25 <kmc> mdmkolbe, #if MIN_VERSION_base(4,3,0)
09:47:26 <neutrino> i need this to be very very simple to code.
09:47:36 <neutrino> ddarius: lambdabot is gone :(
09:47:40 <mdmkolbe> kmc: I'm patching old code which doesn't use cabal
09:47:52 <kmc> that will include code for only base-4.3 and later
09:47:57 <neutrino> kmc: do you know anything about wx or gtk?
09:47:58 <ddarius> hackage.haskell.org/package/scope
09:48:03 <kmc> oh, then I think you are best off porting it to cabal :)
09:48:25 <kmc> neutrino, why me?
09:50:40 <neutrino> kmc: i heard you were a real programmer
09:51:14 <ddarius> neutrino: Real Programmers don't use GUIs.
09:51:27 <cmccann> those are for imaginary programmers
09:51:44 <neutrino> i am a Cayley programmer
09:51:55 <kmc> mdmkolbe, the version of 'base' is strictly determined by the version of GHC, i think
09:52:05 <kmc> mdmkolbe, so in this case you could use the __GLASGOW_HASKELL__ flag
09:59:47 <lpsmith> kmc, mdmkolbe,  you can write #IF MIN_VERSION_base(4,2,0)
10:01:03 <kmc> lpsmith, i mentioned that, but I think it requires that you build with Cabal
10:01:21 <lpsmith> oh, sorry :)
10:01:21 <kmc> the macros appear in dist/build/autogen/cabal_macros.h
10:04:02 <notyarou> hello all, if i were to implement a simple dfs or bfs algorithm, would i use Data.Tree or just manually define a custom tree
10:04:55 <c_wraith> dfs and bfs are for arbitrary graphs, not just trees
10:05:13 <notyarou> c_wraith, right
10:05:20 <notyarou> what is the simplest method of going about it?
10:05:46 <c_wraith> Well, how are you representing graphs?
10:05:48 <kmc> don't think it matters much
10:06:15 <kmc> if you use Data.Tree you can reuse a little standard library code
10:06:27 <kmc> (e.g. the Foldable and Traversable instances)
10:06:40 <kmc> but your tree might have a different shape from the one in Data.Tree
10:07:09 <carpi> Would it be right if I said that .. a monad essentially takes what you give it and adds its own flavor of functionality and then returns an action that is a combination of your code and the monad code?
10:07:17 <kmc> no
10:07:22 <notyarou> kmc, thanks
10:07:44 <notyarou> kmc++
10:08:20 <kmc> carpi, that might be so vague that it's not wrong, but I don't see how it could be useful either
10:08:28 <neutrino> he's saying "action"
10:08:37 <neutrino> which implies he only ever worked with the IO monad
10:09:05 <carpi> true..but it seems trivial to generalize
10:09:13 <kmc> neutrino, people use the "action" terminology for other monads
10:09:14 <kmc> carpi, what?
10:09:42 <carpi> i do not have much experience with other monads other than the IO monad.. thats what I was saying
10:09:49 <neutrino> do they really?
10:09:57 <neutrino> are there monads where "action" may not be used?
10:10:06 <cmccann> "action" is sometimes used as a generic term for the non-parametric stuff in a functor
10:10:09 <cmccann> or "effect"
10:10:10 <kmc> carpi, don't waste time looking for a statement like "a monad is essentially <foo>"
10:10:11 <cmccann> or whatever else
10:10:15 <kmc> they're all useless
10:10:36 <cmccann> a monad is essentially an overused joke from Iry's blog, obviously
10:10:46 <neutrino> what is it with people sitting around and trying to come up with what a monad is
10:10:54 <neutrino> might as well be contemplating the meaning of life
10:10:56 <carpi> yea.. it doesn't look like its something whose definition can be abstracted in a simple sentence
10:11:12 <kmc> neutrino, people think it's like the one key Haskell concept and path to enlightenment
10:11:21 <mokus_> it can be given in a simple sentence, but most of the words in the sentence would need their own definitions
10:11:23 <kmc> i think they think this due to reading too much Reddit and blog posts by other Haskell beginners
10:11:44 <eviltwin_b> "there's no *there* there"
10:12:00 <carpi> i don't think most people come here to talk about what a monad is.. instead.. they want to know if what they think abut monads are right or wrong
10:12:21 <neutrino> wrong
10:12:30 <carpi> I donno about other folks but im not qualified to tell anyone what a monad is or isn't..
10:12:41 <neutrino> i can tell you what a monad isn't
10:12:46 <neutrino> it isn't any monad analogy
10:12:49 <mokus_> @let is_a_monad_a x = False
10:12:53 <carpi> the reasons i came up with that definition of a monad was to plug some holes in my understanding of it
10:12:59 <carpi> not to say that this is what a monad is !
10:13:21 <kmc> carpi, what you gave isn't a definition though
10:13:41 <carpi> definition, statement, assumption.. pick your word )
10:14:18 <c_wraith> "Monad" is a composition pattern for functions working with types of kind * -> *
10:14:23 <kmc> you didn't define "monad", you made a claim about monads
10:14:32 <kmc> a claim which is too vague to really be right or wrong
10:14:45 <c_wraith> Anything less abstract than that is missing something important.  Mostly that it's that abstract.
10:15:00 <kmc> anyway can we please talk about something other than how to talk about learning how to talk about learning about talking about monads?
10:16:30 <kmc> i want a system for metaprogramming Haskell which is more powerful than CPP and less cumbersome and principled than TH
10:16:51 <c_wraith> m4?
10:17:00 <carpi> If we get into that line of discussion.. I believe this is becoming a bit too pedantic. I don't think I need a lesson in English. Apologies, if that sounds harsh. But it seems like sometimes, discussions here "sometimes" tend to gravitate towards the color of the bike shed instead of actually talking about how well to build it. !
10:17:17 <kmc> one direction is an s-expr syntax for Haskell, to make metaprogramming easier
10:17:19 <kmc> like Liskell and Lisk
10:17:25 <kmc> another direction is a better textual preprocessor, like m4
10:17:34 <kmc> does anyone use m4 on haskell code? any suggestions or experiences to share?
10:17:51 * Clint squints.
10:17:59 <roconnor> kmc: s-exprssion don't have binders
10:18:09 <mike-burns> carpi: Agreed.
10:19:06 <kmc> roconnor, not by themselves no, but they are commonly used to represent languages with binders
10:19:14 <c_wraith> carpi: well, the problem is that Monad is a very abstract concept. If you try to describe it as something less abstract, you're losing the most important part - which is how abstract it is.
10:19:44 <kmc> i think the difference between "definition" and "testable claim" is not an irrelevant pedantic one
10:19:58 <kmc> if that's what you were getting at
10:21:36 <neutrino> i think he meant 'claim' just didn't realize it
10:23:14 <carpi> I think this is pointless. If you really want to talk about the nuances of the wording of that comment.. then it's neither a claim nor a definition. It's a question..
10:23:49 <kmc> i think it's pointless too, that's why i tried to move on to another topic
10:23:57 <neutrino> ok guys
10:24:01 <neutrino> i need you to help me decide
10:24:05 <matobet> @pl \x->(x:).concat
10:24:08 <neutrino> what do i try first, gtk or ws?
10:24:16 <kmc> where is lambdabot anyway
10:24:29 <kmc> neutrino, i think there's more gtk haskell code than wx haskell code
10:24:34 <kmc> there are gtk examples in rwh
10:24:53 <kmc> i've done a bit of gtk programming (in python and haskell) and it's fine
10:25:11 * cmccann found wx to be obnoxiously imperative but otherwise fine
10:25:14 <kmc> it's not magical or inspiring but it works fine
10:25:30 <kmc> the biggest gtk bug I hit was a documentation bug in pygtk that wasted a bunch of my time
10:26:03 <matobet> @pl \x -> (x:) . concat
10:26:31 <carpi> c_wraith: but there must be a way to understand it... I think it would be difficult to understand the concept with a just a bird's eye view. I don't think you can understand the "system" if you don't understand the "parts" that constitute it.. The abstractness is the final level in understanding that system. In this case, 'monads'
10:27:43 <c_wraith> carpi: Learn what >>= and return do for various instances of monad. Learn how to use them. Eventually, you'll understand what's common between all of them. Any other approach is going to fail, because *there's nothing to get*.
10:27:59 <cmccann> carpi, monads in general don't really have parts. they are abstraction, nothing else
10:28:20 <c_wraith> If you spend time worrying that you don't get it, then you're wasting effort worrying about something that doesn't exist.
10:29:16 <carpi> thanks. at least now i know where to llook.
10:29:53 <c_wraith> don't look. Just do.
10:30:03 <neutrino> kmc: ok let me try gtk then
10:30:42 <c_wraith> Write code. Keep an open mind. You'll learn, once you see it enough.
10:32:59 <carpi> Thanks. i'll work through it and do. Either way, I really think someone should start a haskell-class.org just like that ml-class.org from stanford
10:38:04 <neutrino> you know what i wish
10:38:13 <monochrom> I do not know.
10:38:33 <neutrino> i wish there was a statistic, based on real code, on what features of the language and what modules to learn about
10:38:43 <neutrino> that would own
10:39:06 <neutrino> then you could finally tell "ok, i probably need to learn X or my knowledge isn't complete."
10:39:13 <monochrom> I have one such statistics. 100% of real code uses types.
10:39:27 <kmc> helpful monochrom is helpful
10:39:41 <neutrino> and also wrong
10:39:42 <mornfall> 100% of real code uses letters, too...
10:39:54 <neutrino> a lot of programs i wrote in haskell do not use type declarations at all
10:39:57 <mornfall> neutrino: Not really wrong.
10:40:02 <mornfall> neutrino: types not type annotations...
10:40:10 <mornfall> Even assembler has "types".
10:40:11 <neutrino> rly
10:40:30 <monochrom> your code uses types though you don't write them out
10:40:45 <mornfall> Whatever. Exercise in futility, this. :-)
10:40:59 <NothingMan65> Hey y'all, could someone explain what "func elem" does in this http://hastebin.com/tefotehogi.coffee
10:41:00 <monochrom> and I am also serious about types. types are the weak point of many beginners, even intermediaters
10:41:45 <kmc> NothingMan65, it's a local definition (within the "where" clause) of a function named "func" with a parameter named "elem"
10:41:58 <kmc> it's a little bit weird to mix "where" and "let" in this way, but it works
10:42:18 <NothingMan65> Thanks kmc, but more to the point, what are we seeing with the elem function?  What's it's purpose?
10:42:27 <NothingMan65> Doesn't it boolean the existence of a n element?
10:42:36 <kmc> beats me, it's your code
10:42:41 <NothingMan65> Nope, it's not.
10:42:42 <Ngevd> Hello!
10:42:45 <NothingMan65> Bwahahahaha
10:42:49 <kmc> then i suggest you ask the person who wrote it
10:42:58 <NothingMan65> Okay, thanks for your help
10:43:44 <NothingMan65> Would anyone else like to help me understand what 'elem' is doing here?
10:43:46 <kmc> NothingMan65, err, "elem" isn't a function
10:43:53 <kmc> it's the argument to f, which is a number
10:44:17 <NothingMan65> I suppose I got confused with this: http://zvon.org/other/haskell/Outputprelude/elem_f.html
10:44:30 <kmc> yeah, it's not that
10:44:35 <kmc> just a local variable that happens to have the same name
10:44:42 <NothingMan65> Oh okay, it's just bad naming.
10:44:44 <NothingMan65> Cool, thanks!
10:44:46 <kmc> i don't think there's any reason for "func" and "f" to be separate here
10:44:54 <kmc> this code is poorly written or just weird
10:45:06 <monochrom> yeah, eliminate func, replace by f
10:45:34 <NothingMan65> Well, the author is trying to implement a memoization technique using an array, would that have anything to do with the code's structure?
10:45:38 <NothingMan65> Maybe it's necessary?
10:45:47 <kmc> no
10:45:50 <NothingMan65> Okay
10:46:19 <Enigmagic> i wish google would reenable the block site functionality so i could block zvon.org again
10:46:22 <kmc> NothingMan65, this is how i would write ithttp://hpaste.org/57242
10:46:41 <scooty-puff> is there i way to have the ghc compiler tell when a list fusion rule is triggered in a module?
10:46:45 <scooty-puff> or i guess in general any rule
10:46:52 <kmc> NothingMan65, but i'd use http://hackage.haskell.org/package/data-memocombinators instead of an array for memoization
10:47:02 <scooty-puff> well, i know there is that - but is that the correct way to go about it?  check when list traversals are fused?
10:47:08 <NothingMan65> Is that standard practice kmc?
10:47:14 <kmc> is what
10:47:21 <NothingMan65> Using the memo combinators?
10:47:30 <NothingMan65> What is better for my edification?
10:47:38 <kmc> dunno, it's a convenient library though
10:47:59 <NothingMan65> Is learning how to use immutable arrays necessary?
10:48:16 <Taneb> Well, after reinstalling the Haskell Platform and then trying to get my for-unrelated-reasons-failing internet (ish) I am finally installing gtk2hs!
10:48:21 <ddarius> Enigmagic: -zvon ?
10:48:42 <shachaf> ddarius: That's somewhat awkward to type on every search.
10:49:03 <shachaf> I wonder if a curried version of unfoldr (dual to foldr) can be made non-awkward.
10:49:07 <shachaf> It would be something like (s -> ((a -> s -> c) -> c -> c)) -> s -> [a], I guess.
10:49:10 <shachaf> That looks pretty awkward.
10:49:33 <mkscrg> where can i learn about version numbers for packages on hackage? some seem to use x.y.z, some w.x.y.z, and i'd like to learn the "rules" for incrementing each digit
10:49:44 <ddarius> shachaf: Many people prefer the "split apart" version of unfoldr.
10:49:53 <kmc> NothingMan65, i wouldn't say it's necessary, but it is useful
10:49:53 <Taneb> Aaargh
10:49:55 <Taneb> Stupid internet
10:50:03 <kmc> especially because a lot of existing code uses them
10:50:09 <shachaf> ddarius: "split apart" version?
10:50:18 <Taneb> What's the best type for a grid for a 2D rectangular cellular automaton?
10:50:20 <fxr> why gtk2hs? why not web based gui?
10:50:28 <ddarius> shachaf: Where you take a "stopping" predicate and a "next state" function.
10:50:32 <Enigmagic> ddarius: there used to be a feature that you could just click 'block site' on the search results and they'd disappear forever
10:50:49 <Enigmagic> i had zvon and other places with out of date hackage mirrors blocked
10:50:53 <Taneb> fxr, what would a web based gui entail?
10:51:02 <monochrom> mkscrg: there is http://www.haskell.org/haskellwiki/Package_versioning_policy , however, clearly some authors do not follow it
10:51:09 <shachaf> ddarius: Ah, I see.
10:51:27 <mkscrg> monochrom: alright, i guess i'll just stick to the rules there
10:51:32 <shachaf> In cases where you e.g. pattern-match that's presumably not so nice.
10:51:42 <fxr> Taneb: a browser
10:52:03 <Taneb> fxr, what packages would you reccomend for it?
10:52:07 <ddarius> shachaf: As can be seen from the implementation of unfoldr in terms of that unfoldr variation, it can require duplication of work and logic.
10:52:20 <ddarius> Indeed, that pretty generally true for boolean checks.
10:52:25 <kmc> what happened to lambdabot?
10:52:28 <shachaf> Right.
10:52:38 <shachaf> Cale?
10:52:38 <monochrom> @hi
10:52:41 <fxr> Taneb: design your interface, you'll pick one then...
10:52:44 <nus> scooty-puff, -ddump-rule-firings
10:52:58 <monochrom> oh, looks like lambdabot gets a 2nd interview with the Pentagon!
10:53:17 <monochrom> (job title: missile launch control :) )
10:54:10 <cmccann> <lambdabot> a strange game. the only winning move is not to play.
10:54:14 <scooty-puff> nus: k, thanks
10:54:22 <shachaf> Cale++
10:54:26 <cmccann> hooray
10:54:40 <shachaf> Unless that was just coïncidence.
10:54:42 <shachaf> universe++
10:54:55 <ddarius> shachaf: Or maybe lambdabot heard kmc's cries.
10:56:09 * monochrom notices the ï in shachaf's "coïncidence"
10:57:31 <KorriX> hello
10:57:45 <KorriX> is there any method for global module import ?
10:58:10 <KorriX> like #include in C++ ?
10:58:12 <ddarius> "Coincidence"?  I think not!
10:58:31 <kmc> KorriX, "import"
10:58:41 <KorriX> it works locally
10:58:51 <ddarius> (Also, #include is not "module import" in C++...)
10:59:03 <KorriX> if I do:
10:59:04 <KorriX> import sth
10:59:04 <KorriX> import mycode
10:59:12 <shachaf> ddarius++
10:59:13 <monochrom> what does "global" mean? and how is #include "global" if "import" is not?
10:59:18 <KorriX> i want to see functions from sth inside of mycode
10:59:24 <kmc> that's insane, and not supported
10:59:36 <ddarius> It's as supported as it is in C++.
10:59:46 <monochrom> ok I see and yes insane. dynamic scoping you're looking for?!
10:59:48 <ddarius> (Well, almost as supported.)
11:00:06 <kmc> i mean, C++ *headers* do work that way
11:00:14 <kmc> but not the whole library, unless you whole library is a header
11:00:16 <kmc> but a lot of them are
11:00:17 <donri> i think what they mean is re-exporting
11:00:29 <monochrom> well, now I'm pretty sure KorriX doesn't just #include headers
11:00:49 <kmc> #include "glibc/*.c"
11:01:00 <ddarius> If I #include "foo.c" all the functions in foo.c will be available in the code included in a following #include "bar.c"
11:01:04 <ddarius> Also someone will shoot you.
11:01:14 <KorriX> i have partially automaticly generated code
11:01:26 <KorriX> (blaze html templates)
11:01:54 <KorriX> and when i am seeing "|sth|" i am sed'ing that into just sth
11:02:00 <KorriX> *just D.sth
11:02:13 <donri> you can export other modules with module MyModule (module OtherModule) where import OtherModule
11:02:49 <KorriX> and when i am importing quallified Definitions as D
11:02:50 <KorriX> it can be good idea !
11:03:23 <mike-burns> So far as I know, dynamic scope is impossible in Haskell.
11:03:40 <kmc> GHC has an extension for dynamically scoped variables
11:03:44 <kmc> :t ?x + ?y
11:03:44 <lambdabot> forall a. (?x::a, ?y::a, Num a) => a
11:03:53 <ddarius> kmc: That's not quite the same thing as dynamic scoping.
11:03:55 <shachaf> That's dynamically scoped in a static sort of way.
11:03:58 <kmc> yeah
11:04:22 <Taneb> Mixed scoping is the way forward!
11:04:26 <Taneb> Into the FUTURE!
11:05:25 <ddarius> "The future looks like the '80s."
11:05:32 <kmc> it always does
11:05:42 <KorriX> Thanks for all
11:12:19 <neutrino> hey guys, i don't understand something in gtk2hs
11:12:36 <Ngevd> neutrino, you're miles ahead of me.
11:12:39 <Ngevd> But do go on
11:12:44 <neutrino> i can apparently display a bitmap in a window, but what format can it be?
11:13:00 <unknownwarrior> hey guys. if i got something like this: data ABC a = Opt1 | Opt2 | Value a (ABC a) then i have to use it in my case like this: execute (Value a (Value b (Opt1))) = undefined. Now i know that Value a is only a number and i dont want to always type Value 4 instead of 4
11:13:05 <neutrino> and more importantly: how can i generate the bitmap inside my program - without having a physical file on a file system?
11:13:19 <jeff_s_> I'm having a type problem with overlapping instances. The problem is, I have one explicit instance defined, but it looks to me like GHC is claiming that instances that shouldn't apply do. See http://hpaste.org/57245
11:13:33 <Younder> Why is 'The Haskell school of expression' server not responding?
11:14:04 <Ngevd> Why is it so hard to breath?
11:14:50 <jeff_s_> Why would "instance Y a => Super a where..." apply to something that isn't even "Y a"?
11:14:51 <Younder> I love the theme and I think it would make a good complement to 'Real wold haskell'
11:14:54 <kmc> jeff_s_, overlap is a property of the instance head only, not the context
11:15:12 <kmc> the head being the part after the context
11:15:23 <kmc> GHC chooses an instance by the head only, and then tries to fulfill the context
11:15:26 <kmc> there is no backtracking
11:15:30 <neutrino> unknownwarrior: i am not sure if you can actually do anything about that
11:15:41 <jeff_s_> Oh man, that's rough.
11:15:47 <kmc> jeff_s_, yeah
11:15:54 <Younder> Ngevd, I had limonia in December but I am recovering now.
11:16:16 <neutrino> unknownwarrior: maybe try using a shorter name? ...
11:16:18 <kmc> jeff_s_, people keep saying that GHC type classes are like logic programming in Prolog, but they really aren't
11:16:46 <unknownwarrior> neutrino: i had at about the same example concerning bools and i could just write : true = my True; false = my False;
11:17:49 <Veinor> huh
11:17:54 <unknownwarrior> neutrino: and in the data declaration looked like this: data Proposition = My Bool | Proposition `Opt1` Proposition |
11:17:56 <jeff_s_> kmc - How then can I make separate implementations of "Super a" for "X a" and "Y a"?
11:17:59 <Veinor> semigroupoids doesn't build on ghc 7.4
11:17:59 <neutrino> yeah but you can't override literals can you
11:18:30 <Ngevd> If you were making a genealogy application, what type would you give the family tree?
11:18:51 <cmccann> kmc, prolog is to GHC fundep metaprogramming as C is to brainfuck
11:18:51 <kmc> jeff_s_, hpaste isn't loading for me
11:19:14 <kmc> jeff_s_, anyway my usual answer is to rethink your design and use fewer typeclasses, preferably zero
11:19:15 <parcs`> strange, for the expression "withDict (Dict :: Dict (?x :: Int)) ?x" ghc infers "(?x::Int) => Int" but for "withDict (let ?x = 4 in Dict :: Dict (?x :: Int)) ?x" it infers "(?x::t) => t" (where withDict Dict x = x)
11:19:18 <neutrino> Ngevd: it wouldn't be a tree.
11:19:22 <neutrino> Ngevd: it would be a relation.
11:19:30 <Ngevd> I'm using IntMap of all things
11:19:39 <unknownwarrior> neutrino: in the end i could use it like this: (And true true) instead of (And (My True) (My True)). and i also want this for numbers
11:19:56 <kmc> unknownwarrior, that won't work in patterns
11:19:57 <neutrino> Ngevd: http://stackoverflow.com/questions/6163683/cycles-in-family-tree-software
11:20:52 <unknownwarrior> kmc, oh it does, maybe i explained it wrong. one second, obviously it is necessary to hpaste this
11:21:35 <kmc> (And true _) will match (And (My False) (My False)) with true = My False
11:21:46 <kmc> and (And true true) is an error -- you can't use the same variable more than once in a pattern
11:21:46 <Ngevd> But yeah, I'm using IntMap Person, where person has Father :: Int, Mother :: Int, and Children :: Seq Int
11:23:06 <jeff_s_> kmc, why not use type classes?
11:23:18 <kmc> because they are cumbersome and hard to abstract over
11:23:20 <kmc> as you are seeing
11:23:29 <Veinor> @tell edwardk semigroupoids doesn't build on 7.4 because base-4.5 has Data.Monoid.(<>)
11:23:30 <lambdabot> Consider it noted.
11:23:43 <ion> Oh, it has? Nice
11:24:03 <Veinor> yeah
11:24:08 <ion> Too bad it doesn’t have instance Semigroup a => Monoid a where { mempty :: Monoid a }. ;-)
11:24:19 <Veinor> haha
11:24:27 <Veinor> but yeah i think it's a one-line patch to semigroupoids
11:24:34 <ion> yeah
11:25:00 <jeff_s_> kmc, what method of abstraction do you prefer, functions?
11:25:18 <jeff_s_> or maybe something outside of haskell, like ocaml's modules or objects?
11:25:24 * ion refrains from saying “burritos”.
11:25:31 <Ngevd> I tried using IORefs, and a combination of a Map and a Graph, and neither of them worked particularly well
11:26:02 <kmc> ion, nice refraining
11:26:04 <unknownwarrior> http://hpaste.org/57247
11:26:08 <kmc> jeff_s_, yes, functions
11:26:11 <Younder> Category theory  should be the foundation of your type system. (It has been proven it can provide a foundation of mathematics.)
11:26:12 <kmc> and data
11:26:20 <kmc> you know, functional programming ;)
11:26:22 <unknownwarrior> neutrino: http://hpaste.org/57247
11:26:25 <CodeWeaver> Okay, I know this is going to open a can of worms, but what's with the burritos?  Should I be sitting in my local burrito shop when I write haskell for maximum performance?
11:26:28 <kmc> sometimes seems functional programming is underappreciated in Haskell
11:26:41 <kmc> CodeWeaver, it's a reference to http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:26:44 <jeff_s_> Younder - I can't say I know category theory.
11:26:45 <cmccann> CodeWeaver, it's an in-joke about bad monad analogies
11:26:54 <CodeWeaver> Fair enough.  I shall educate myself.
11:27:08 <CodeWeaver> On that note, I sitll don't get why all these monad tutorials are so bad.  yet.  Or why it matters.  Yet. :D
11:27:09 <mike-burns> Yes, go learn comedy.
11:27:20 <jeff_s_> So it's hard for me to use it.
11:27:21 <kmc> that's what the article is about CodeWeaver
11:27:27 <kmc> Younder, have you used any programming language with CT foundations?
11:27:35 <kmc> ski told me about one once, but I forgot the name
11:27:39 <cmccann> just read "burrito" as "monads, while making fun of something"
11:27:53 <kmc> just read "burrito" as "hey guys I know about monads, can i be in the cool kids club"
11:28:01 <jeff_s_> Younder - do you know of a book or something that relates category theory to Haskell? My understanding is that Monads and Monoids are somehow part of or inspired from category theory.
11:28:06 <Veinor> ... wait, Show got taken out of Integral? damn
11:28:20 <kmc> yeah, Show and Eq are no longer Num superclasses
11:28:26 <kmc> fuck the language standard, am i rite
11:28:29 <Veinor> Eq? really?
11:28:35 <cmccann> they never made sense anyway
11:28:46 <kmc> and this broke a bunch of standard code
11:28:48 <cmccann> not that Num makes sense to begin with
11:28:55 <cmccann> but they shouldn't have been there in the first place
11:29:08 <CodeWeaver> I know *about* monads.  I can even when pressed *use* monads in a pragmatic way.  I'm still not totally up with the *consequences* of monads, beyond their utility in sequencing and performing computations in a context — and then, only just.
11:29:10 <Veinor> i can understand taking out Show
11:29:11 <Veinor> but Num?
11:29:18 <Veinor> er
11:29:20 <Younder> jeff_s_, try Steve Awodey's 'category theory' and thenRobert Goldblat's 'Topoi, the categorical analysis of logic''
11:29:20 <Veinor> Eq
11:29:25 <kmc> you can't implement Eq for computable reals
11:29:39 <jeff_s_> Younder, I think I saw Topoi in MSU's math library.
11:29:51 <Veinor> true
11:30:05 <cmccann> CodeWeaver, that's all the understanding you really need to be honest
11:30:32 <Younder> jeff_s_, It is beautiful, give it a try
11:30:37 <CodeWeaver> Then I'll have to refine my understanding of those two properties of monads to get a handle on them.
11:31:21 <kmc> the connections between Haskell and category theory are *way* overblown
11:31:28 <jeff_s_> Younder - good, they have the Awodey book, too.
11:31:34 <unknownwarrior> kmc, would you do me a favor and take a short look at this http://hpaste.org/57247 please ?
11:31:38 <cmccann> CodeWeaver, and by that I mean that you understand enough to move on, the rest will come naturally as you go
11:32:21 <ion> The standard typeclasses should be cleaned up sooner or later and i think i’d prefer to have a bunch of code broken to having some sort of nasty kluges to replace other nastyness in order to be compatible with existing code. But the changes should be dictated by the Report instead of GHC just doing them willy-nilly.
11:32:25 <CodeWeaver> Fair enough… just not sure where to go.  It doesn't take long hanging out in this chatroom to feel awfully unacademic, despite having been in the industry for entirely longer than I care to admit — but I'm absorbing. :)
11:33:00 <kmc> unknownwarrior, what about it
11:33:24 <cmccann> CodeWeaver, a lot of the discussion in here involves stuff that isn't in any way necessary to successfully program in haskell :P
11:33:58 <kmc> yeah, a lot of people use Haskell as vocabulary and syntax for talking about math
11:34:22 <unknownwarrior> kmc, in line 3 i wrote true = Only True and "Only True" is declared in my data = Only Bool. now i want the same for numbers, when i say data a = Value a and then a = Value a or something .. but i dont get how to do it
11:34:31 <neutrino> dude kmc
11:34:39 <kmc> dudetrino
11:34:44 <NothingMan65> Hey y'all.  Say I have a list comprehension, thusly: [(x,follow x 0) | x <- [1..n]] .. I would like to return the fst of  the maximum element based on the second term.
11:34:46 <neutrino> i really wish i had known haskell back when i was in the uni
11:34:58 <neutrino> a lot of its syntactic rules would have been so useful to simplify notation
11:35:08 <kmc> :t fst . last . comparing snd
11:35:10 <lambdabot>     Couldn't match expected type `[(a, b)]'
11:35:10 <lambdabot>            against inferred type `(a1, b1) -> Ordering'
11:35:10 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
11:35:34 <kmc> :t fst . last . sortBy (comparing snd)
11:35:35 <lambdabot> forall a b. (Ord b) => [(a, b)] -> a
11:35:38 <shachaf> kmc: last?
11:35:41 <shachaf> That seems kind of silly.
11:35:52 <kmc> :t fst . head . sortBy (flip $ comparing snd)
11:35:52 <lambdabot> forall a b. (Ord b) => [(a, b)] -> a
11:36:00 <kmc> :t fmap fst . listToMaybe . sortBy (flip $ comparing snd)
11:36:01 <lambdabot> forall a b. (Ord b) => [(a, b)] -> Maybe a
11:36:22 <ddarius> fst . last . median
11:36:40 <kmc> unknownwarrior, you can't
11:36:48 <unknownwarrior> kmc :(
11:36:49 <kmc> unknownwarrior, if you want numeric literals to work for your type, write an instance of Num
11:36:56 <kmc> that's kind of completely different
11:37:21 <unknownwarrior> kmc, ah maybe thats what i want. kmc all i want is that numbers can also be part of my data
11:37:28 <cmccann> yet another reason why Num is kind of terrible
11:37:46 <Younder> it is isn't it
11:37:46 <ddarius> cmccann wants non-numeric numbers now!
11:37:55 <cmccann> because obviously "abs" makes sense for anything that might use numeric literals
11:38:06 <cmccann> incidentally, I also think listToMaybe should be renamed
11:38:11 <shachaf> I prefer my numbers to be numberic, not numeric.
11:38:27 <shachaf> cmccann: To something like "head"? :-)
11:38:37 <cmccann> shachaf, got it in one ;]
11:38:43 <shachaf> listToMaybe = fmap fst . uncons
11:38:46 <rwbarton> ugh
11:39:02 <ddarius> We can rename fromJust to id.
11:39:20 <ion> or unsafeCoerce
11:40:21 <benchma__> I've asked here a couple of days ago, but didn't get much response, what's a functional way to solve the frogger problem? http://en.wikipedia.org/wiki/Frogger
11:40:35 <Younder> well decimals do have their limitations. But my favorite is that that is the cross som divides 3 the number divides 3. and this in fact works recursively.
11:41:02 <neutrino> i truly do wish there was a simple way to apply flip to all sorts of operators
11:41:15 <Younder> s/som/sum/ as in 123 = 6
11:41:21 <neutrino> because i use flip ($) all the time and now i'm starting to use flip (.) all the time
11:41:22 <unknownwarrior> kmc, okey i think i forget about that problem and just take it as it is
11:41:33 <Ngevd> benchma__, frogger problem?
11:41:34 <cmccann> neutrino, (>>>)
11:42:10 <neutrino> :t (>>>)
11:42:11 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:42:30 <neutrino> cmccann: is that like flip (.) ?
11:42:36 <cmccann> > (+4) >>> show $ 1
11:42:37 <lambdabot>   "5"
11:42:38 <tgeeky> :t flip (.)
11:42:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
11:42:49 <cmccann> :t flip (Prelude..)
11:42:50 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
11:42:59 <cmccann> neutrino, yes
11:43:03 <tgeeky> cmccann: ooh! what devilish trick is that?
11:43:12 <neutrino> cmccann: cool
11:43:23 <cmccann> tgeeky, what, the Caleskell nonsense?
11:43:41 <tgeeky> cmccann: (Prelude..) is (.) from Prelude, by why was it necessary?
11:43:51 <neutrino> because Caleskell
11:43:53 <cmccann> tgeeky, that's Caleskell
11:44:10 <kmc> benchma__, the word "problem" does not appear on that page
11:44:22 <cmccann> a.k.a. Cale's weird dialect of Haskell that lambdabot uses.
11:44:27 <kmc> what's a pure functional way to solve the grand theft auto iv problem
11:44:39 <tgeeky> kmc: which one? the hookers problem? the drugs problem?
11:44:51 <tgeeky> kmc: or that problem with the mission so hard that I couldn't beat it and finish the game?
11:44:54 <kmc> or the darts minigame
11:45:02 <tgeeky> cmccann: hm. ok.
11:45:23 <kmc> "all right, I'll sell you assault rifles and grenades... but first we need to play darts about four times"
11:45:35 * hackagebot elerea 2.7.0.1 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.7.0.1 (GergelyPatai)
11:45:54 <tgeeky> kmc: you didn't know? Darts is the international language of arms dealers.
11:48:01 <benchma__> kmc: the problem is that if  you start at the bottom, and how to reach to the top by avoiding the moving trucks, etc
11:48:26 <benchma__> let's say there is only one frog, and several lines of moving trucks, etc
11:48:30 <kmc> you want a program to play the actual game in realtime?
11:48:43 <kmc> or some more abstract mathematical puzzle which you have extracted from the gameplay?
11:48:59 <benchma__> more like the an abstract problem
11:49:20 <neutrino> @hoogle (a, a) -> [a]
11:49:20 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
11:49:20 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
11:49:21 <lambdabot> Prelude snd :: (a, b) -> b
11:49:30 <jklvxnas1> When i load a certain file with ghci, this brings main in scope but nothing else. Has anyone experienced the same?
11:49:40 <kmc> benchma__, ok, you'll have to tell us what the problem is then
11:49:54 <byorgey> jklvxnas1: probably because it's already been compiled
11:50:15 <byorgey> jklvxnas1: you can either delete the .o file, or do   ghci '*FileName'
11:50:24 <kmc> but it sounds like searching a tree of states
11:50:33 <cmccann> or just change some whitespace in the file and reload
11:50:34 <jklvxnas1> byorgey: thank you
11:50:39 <kmc> easier than an AI for checkers or whatever, because you don't have a responsive adversary
11:50:54 <benchma__> Let's simplify it, let's say that you have a road with 5 lanes, each potentially could have a truck moving  at different speed
11:51:01 <benchma__> you are to cross the road
11:51:11 <benchma__> and you can jump on the trucks,
11:51:16 <benchma__> to avoid being hit
11:51:22 <tgeeky> s/GTA/frogger/
11:51:31 <Younder> rotfl
11:52:25 <Taneb> I think the frogger problem is "Why can;
11:52:31 <Taneb> 't he swim!?"
11:52:39 * Clint claps.
11:52:43 <Taneb> s/;\n//
11:53:50 <benchma__> I was thinking to use floyd warshall
11:54:56 <benchma__> i.e., find all possible path
11:55:09 <CodeWeaver> Well, to *some* degree knowing the math dialogue that happens in here would enhance my appreciation.  Functors and Applicatives I'm starting barely to get a handle on, and don't know the full consequences.  Arrows as yet baffle me.  Anything abstract beyond that messes with my head.
11:55:15 <byorgey> benchma__: sure, you could model each "state" (positions of trucks + position of frog) as a node in a graph
11:55:45 <byorgey> CodeWeaver: don't worry about Arrows for now
11:55:54 <byorgey> they have more specialized applications.
11:55:55 <CodeWeaver> When do I start worrying about them then?
11:55:57 <CodeWeaver> :)
11:55:57 <cmccann> Arrows are kind of silly anyway
11:56:06 <byorgey> CodeWeaver: when you need them.
11:56:12 <CodeWeaver> And how do I know that?
11:56:26 <aristid> CodeWeaver: just don't worry
11:56:26 <byorgey> CodeWeaver: you'll just know.
11:56:36 <CodeWeaver> That…. is an unsatisfying answer. ;)
11:56:44 <tgeeky> CodeWeaver: yeah, that will happen.
11:56:45 * cmccann would sometimes like a Category instance with (***) and (+++) but not (&&&) or (|||)
11:56:50 <benchma__> is that the best algorithm?
11:56:59 <benchma__> and how do you do that in Haskell?
11:57:12 <shachaf> CodeWeaver: A simple interpretation is that you'll never need Arrows.
11:57:36 <CodeWeaver> ARGH
11:57:36 <CodeWeaver> :D
11:57:47 <CodeWeaver> I never need foldr either.
11:57:49 <CodeWeaver> or map.
11:57:53 <CodeWeaver> That's really rather not the point is it.
11:58:13 <cmccann> CodeWeaver, the Arrow class really doesn't offer much besides some syntactic sugar
11:58:37 <CodeWeaver> Yes, I realize that.  Most of haskell ends up being syntactic sugar on lower layers of haskell.  Welcome to programming.  In other news, water is wet.
11:58:53 <CodeWeaver> May I ask what arrows are syntactic sugar *for*?
11:59:04 <byorgey> CodeWeaver: really, my point is that if you are just starting to barely get a handle on Functors and Applicatives, there is a ton more stuff you can still learn that will probably be more useful to you than Arrows.
11:59:06 <CodeWeaver> Sorry, too much coffee, and excitable.  Getting punchy. :D
11:59:09 <cmccann> no, the proc notation is syntactic sugar for Arrow combinators
11:59:10 <CodeWeaver> Okay.
11:59:23 <CodeWeaver> That's a fair point, byorgey.
11:59:24 <benchma__> byorgey, i think time has to be introduced as a dimenesion as well, but i haven't gotten my head around it yet
11:59:25 <cmccann> anyway, the Category class is more essential, and simpler
12:01:14 <CodeWeaver> Haven't figured that one out either.  Its not the syntax of these things.  It's the consequences.
12:03:14 <cmccann> CodeWeaver, what sort of consequences do you mean?
12:03:35 <cmccann> stuff like "Applicative can't embed control flow, but Monad can"?
12:04:11 <Clint> are there any guidelines for module naming?
12:04:16 <CodeWeaver> Well, that, and the kinds of questions like "Okay, so what is this construct enabling me to do more easily, or more safely?  What are the 'laws' that they enable me to assume by being rigorous?"
12:04:37 <cmccann> well, the laws should be in the documentation :P
12:05:00 <CodeWeaver> I mean, I understand the basic monad laws for example, but I'm not sure what they end up buying me even though I can rigorously assume them.
12:06:31 <cmccann> CodeWeaver, they buy you certain kinds of compositionality, to be uselessly vague
12:06:48 <john_doe_jr> is haskell like Ruby?
12:07:05 <CodeWeaver> cmccann:  :D
12:07:15 <cmccann> john_doe_jr, yes, they are both programming languages, in the big scheme that's pretty similar
12:07:35 <john_doe_jr> cmccann, does hyskell use a model view controller design ?
12:07:42 <tgeeky> john_doe_jr: no.
12:07:46 <tgeeky> john_doe_jr: nor does Ruby.
12:07:52 <tgeeky> john_doe_jr: You're thinking of Ruby on Rails.
12:08:07 <john_doe_jr> tgeeky, yup...so it's procedural?
12:08:18 <cmccann> CodeWeaver, an example is that if you have "x >> y >> z" the order in which the (>>) operators are applied doesn't matter, much like "1 + 2 + 3"
12:08:26 <Ragnaroek> anyone doing serious gui programming in haskell?
12:08:30 <tgeeky> john_doe_jr: ... No. Haskell is (1) pure, (2) lazy, and (3) functional
12:08:42 <roconnor> tgeeky: and typed
12:08:44 <tgeeky> Ragnaroek: yes. Several attempts are going on using several approaches
12:08:59 <tgeeky> john_doe_jr: ... No. Haskell is (1) pure, (2) lazy, and (3) functional, and (4) strongly typed with fantastic type inferrence
12:08:59 <john_doe_jr> tgeeky, so is it used in database work ?
12:09:05 <CodeWeaver> cmccann: Even though internally there's the possibility of sequencing… as a consequence of having to unwrap (eval) the functions.
12:09:11 <tgeeky> john_doe_jr: yes, it can be used in database work.
12:09:22 <CodeWeaver> interesting.  Associativity, even with sequencing.
12:09:54 <cmccann> CodeWeaver, associativity but not commutativity--the order of operations doesn't matter, but the order of operands does
12:10:18 <CodeWeaver> Fair, but that's evident even in purely functional terms, by say division.
12:10:43 <Ragnaroek> any recommendations for gui programming?
12:10:50 <Ragnaroek> the more haskellish the better
12:11:00 <CodeWeaver> Ragnaroek:  gtk2hs, or wxHaskell
12:11:17 <cmccann> CodeWeaver, it's nothing all that special, just an example of the sort of guarantees you get from the monad laws
12:11:18 <CodeWeaver> The latter being, in my limited opinion, better for getting native look and feel, but both work.
12:11:41 <cmccann> CodeWeaver, it's what justifies functions like mapM being well-behaved--the order of list elements determines the order of actions
12:11:45 <CodeWeaver> cmccann: Okay.  I should probably dig deeper into functors and applicatives then.
12:12:03 <CodeWeaver> cmccann:  Oh, interesting. That last statement is intriguing.
12:12:06 <mdmkolbe> Did "rec" become a keyword or something?  Perhaps with some special flags?  (I'm porting old code and getting parse errors on a variable named "rec".)
12:12:10 <CodeWeaver> IThat didn't occur to me.
12:12:14 <Ragnaroek> ok, it doesn't have to be cross-platform. Only macos would be fine
12:12:21 <shachaf> mdmkolbe: -XDoRec
12:12:28 <shachaf> (Yes.)
12:12:34 <shachaf> (If you enable that extension.)
12:13:00 <tgeeky> roconnor: btw, the other day you mentioned (http://www.reddit.com/r/haskell/comments/on3c9/zippers_with_a_variation_on_multiplate/) that you didn't think CartesianStore b a and Free (Store b) a are isomorphic.
12:13:08 <tgeeky> roconnor: Can you elaborate in there for me?
12:13:15 <CodeWeaver> Ragnaroek:  OSX is always… kind of a bit of a second string OS when it comes to haskell, especially the more hardcore packages.  So you may have *some* difficulty getting started.  I'm in exactly that boat.
12:13:32 <tgeeky> roconnor: in particular, can you inspect his reply and/or reply to it
12:14:09 <cmccann> CodeWeaver, you could write mapM anyway, but the monad laws are what justifies it being the "same" operation for any monad and being able to talk about that operation in general terms, if that makes sense
12:14:14 <roconnor> tgeeky: sjoerd says: ``But I realize now that if you go from Free (Store b) a to CartesianStore b a and back, that you may not end up with the same value you started with.''
12:14:20 <CodeWeaver> Ragnaroek:  That being said, it is definitely getting more and more love as time goes on, so. Hang in there.  I know, for example, that the GHC haskell compiler team doesn't consider their releases complete until OSX is working reasonably.
12:14:27 <roconnor> tgeeky: hence it isn't an isomorphism
12:14:40 <mdmkolbe> shachaf: hmm, the parse error is still there even with -XNoDoRec
12:14:44 <CodeWeaver> cmccann:  Sure, abstracting away the common things that you'd be doing anyway to get monadic like behaviour, and making it mathematically rigorous.  I appreciate that.
12:15:17 <shachaf> mdmkolbe: Well, that's not really enough information to be able to help you in any way. :-)
12:15:24 <shachaf> @paste the file or something.
12:15:24 <lambdabot> Haskell pastebin: http://hpaste.org/
12:15:38 <cmccann> CodeWeaver, and with Functor you have a guarantee that fmap won't change the "shape"--lists stay the same length, &c.
12:15:44 <Ragnaroek> CodeWeaver: any experience with HOC?
12:16:05 <tgeeky> roconnor: what are you left with then? a pair of homomorphisms?
12:16:19 <CodeWeaver> Ragnaroek:  Nope.  Not yet.  I'm just sort of getting started digging into nontrivial programs in Haskell.  So my opinion should be taken with a grain of salt. :)
12:16:39 <CodeWeaver> cmccann:  Okay, interesting.  I'm going to have to look directly at Functors for a while to see why this is.
12:17:48 <CodeWeaver> Okay, so functors are basically generalized maps, it looks like.
12:17:50 <cmccann> CodeWeaver, that's pretty much just an assertion, i.e. "this must be true for any valid instance"
12:18:08 <ion> codeweaver: “Functor” might as well be called “Mappable”.
12:18:16 <CodeWeaver> Nifty, that actually helps.
12:18:17 <CodeWeaver> A lot.
12:18:22 <CodeWeaver> maps don't mystify me.
12:18:28 <mdmkolbe> shachaf: sorry, my bad.  It did eliminate the error.  Another file just had the same error.
12:18:41 <cmccann> CodeWeaver, fmap turns a function (a -> b) into a function (f a -> f b) for any instance "Functor f"
12:18:57 <roconnor> tgeeky: well I'm pretty sure freeCartesian store is a homormophism, specifically an idomatic transformation.
12:19:06 <roconnor> tgeeky: I'm worried that f2s isn't even that.
12:19:12 <unknownwarrior> hey guys, can you help me pleeease i am really close to the solution but i cant solve one stupid unimportant error
12:19:24 <unknownwarrior> http://hpaste.org/57248
12:19:27 <roconnor> tgeeky: granted f2s isn't really written all that well
12:19:27 <cmccann> CodeWeaver, map being the special case for lists, where f is []
12:19:32 <roconnor> tgeeky: let me write it properly for you
12:19:58 <CodeWeaver> cmccann:  In terms of map, it could be said to take a function (a->b) and a 'thing' parameterized on a, and returns for you a 'thing' parameterized on b, having applied the function inside the 'thing'.
12:20:20 <CodeWeaver> currying is fun. :P
12:20:31 <cmccann> CodeWeaver, there isn't always an obvious meaning of "inside", but otherwise yes
12:20:39 <Taneb> Add:Add:ys, not [Add:Add:ys]
12:20:41 <CodeWeaver> Yes, I appreciate that distinction. :D
12:20:52 <tgeeky> roconnor: thank you
12:20:54 <CodeWeaver> Just stating an alternative interpretation to see if I get it.
12:21:01 <Taneb> unknownwarrior, ^^^
12:23:10 <cmccann> CodeWeaver, for example, instead of lists consider "applying a value". so your parameterized thing would be an expression like ($ foo)
12:23:40 <cmccann> CodeWeaver, that's obviously equivalent to just "foo" and if we have a function on the type of thing being applied, we should be able to lift that to the applying-to form, right?
12:23:47 <unknownwarrior> Taneb, okey thank you very much this solved my problem
12:23:59 <Taneb> :)
12:24:02 <Taneb> Glad to help
12:24:03 <Taneb> Where I can
12:24:25 <CodeWeaver> cmccann:  Nope, that one went over my head.  I keep stumbling over the word 'lifting'.  I presume you were using the standard $ function applicator operator there?
12:24:30 <cmccann> yeah
12:24:35 <CodeWeaver> *ponders*
12:25:07 <byorgey> cmccann: that didn't even make sense to me.
12:25:12 <CodeWeaver> Nope, I think I'm stumbling over terminology, but I'm not sure what terminology.
12:25:17 <cmccann> haha, sorry
12:26:08 <e98> anyone else seen the following error when trying to use hsenv: http://pastebin.com/98LawiDz
12:26:10 <mauke> The paste 98LawiDz has been copied to http://hpaste.org/57250
12:27:32 * cmccann lost track of where he was going with that anyway
12:27:52 <CodeWeaver> hahahaha okay, that actually makes me feel better :D
12:28:05 <unknownwarrior> Taneb, do you know why the patterns are overlapped? http://hpaste.org/57248 (you have to scroll down to see the latest version)
12:29:33 <roconnor> tgeeky: I give up.  I cannot write a reasonable term of type f2cs :: Free (Store b) a -> CartesianStore b a
12:30:05 <cmccann> CodeWeaver, I think I was just trying to get to saying that if you have a function "f :: a -> b" and a value "x :: a", then you can get a Functor instance such that "fmap f ($ x)"  = "($ f x)"
12:30:18 <cmccann> as an example of something that's distinctly different from a simple container like a list
12:30:38 <roconnor> tgeeky: the big problem with sjoerd's code is that how much of the list [b] getPeek consumes could depend on the values in the list themselves.
12:30:41 <cmccann> (though you can't write that Functor instance directly, because it would overlap with another instance)
12:31:10 <roconnor> tgeeky: or in other words the FreeStore doesn't have a fixed dimension like a cartesian store,  Different "branches" in the free store could have different dimensions.
12:31:11 <cmccann> (as well as not being syntactically valid because of the type arguments being in the wrong place...)
12:32:00 <tgeeky> roconnor: that is what I wrote down in my notebook. At least my intuition is getting better. I wrote "where are guarantees about correct dimensions here?!"
12:32:17 <unknownwarrior> anyone in this chat willing to help a noob? click right here -> http://hpaste.org/57248 :)
12:33:10 <carpi> I tried to import Codec.Compression.GZip but ghci can't seem to find it. Could someone please tell me what package I should be looking for?
12:36:07 <CodeWeaver> cmccann:  Not quite seeing that.  ($ f x) seems to satisfy the types for ($) and f and x.  However, ($ x) given the same x, doesn't.  *confused*
12:36:59 <unknownwarrior> Taneb, you there?
12:37:04 <Taneb> Ish
12:37:09 <Taneb> Internet is awful
12:37:16 <CodeWeaver> *hugs the internet*  Be nice!
12:37:19 <cmccann> CodeWeaver, with "f :: a -> b" and "x :: a", then "($ x) :: ((a -> r) -> r)" and "($ f x) :: ((b -> r) -> r)"
12:37:19 <CodeWeaver> :P
12:37:31 <CodeWeaver> cmccann:  Okay, let me ponder that.
12:38:11 <unknownwarrior> Taneb, i updated the code, you can see it if you scroll down and i got a new odd problem http://hpaste.org/57248 it says there is overlapping but these are different matches so there shouldnt be an overlapping
12:38:21 <cmccann> CodeWeaver, stick it in a wrapper like "newtype Foo r a = Foo ((a -> r) -> r)" and try to write the Functor instance for it
12:38:35 <cmccann> (also, I'm avoiding the correct terms here to avoid giving it away :P)
12:38:39 <CodeWeaver> Wait… if x is of type a, and $ is of type (q -> r) -> q -> r…. then with ($ x), we have a being q->r
12:38:49 <CodeWeaver> (ponders)
12:38:52 <Taneb> unknownwarrior, I'm not sure what the problem is...
12:39:01 <Taneb> CAN ANYONE HELP unknownwarriow?
12:39:12 <cmccann> CodeWeaver, ($ x) is (flip ($) x), note
12:39:18 <unknownwarrior> Taneb, okey :/ i dont know what the problem is aswell
12:39:27 <cmccann> it's not applying x, it's applying something to x
12:39:28 <CodeWeaver> No, no, don't give me flips on top of it.  I'll do without that for the moment.
12:39:45 <CodeWeaver> Wait…. (ponders)
12:40:03 <cmccann> CodeWeaver, so a would q in your example there
12:40:14 <CodeWeaver> ARGH!  Sections!  I didn't see it!
12:40:23 <CodeWeaver> *headdesk*
12:40:24 <cmccann> right
12:40:35 <CodeWeaver> Goes back
12:40:38 <CodeWeaver> *goes back*
12:40:57 <rwbarton> unknownwarrior: "x:y:[]" overlaps with "x:y:xs"
12:41:16 <CodeWeaver> I gotta rewrite that without sections.
12:41:42 <cmccann> CodeWeaver, it's turning "x" into (\f -> f x)
12:41:46 <unknownwarrior> rwbarton, oh you are totally right i didnt see that. let me think about how to solve that ..
12:42:03 <cmccann> :t \x f -> f x
12:42:04 <lambdabot> forall t t1. t -> (t -> t1) -> t1
12:49:37 <unknownwarrior> rwbarton, i had several ideas but the dont work out. do you know how to make the difference?
12:50:24 <CodeWeaver> cmccann:  I can see that in a loose sense.  I can work with that.
12:50:37 * hackagebot github-backup 1.20120131 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20120131 (JoeyHess)
12:53:37 <cmccann> CodeWeaver, do you see how it's a valid Functor instance, and how it's mostly a different way of working with a plain value?
12:54:26 <cmccann> note that you can convert back and forth with (\x f -> f x) and (\x' -> x' id)
12:55:15 <cmccann> the first turns x into ($ x), and (($ x) id) is (id x), or just x
12:55:29 <magic_clouds> hi everyone
12:56:35 <CodeWeaver> cmccann:  Okay, okay, I'll ponder this a while.  Absorption level is low right now.  I'm going to play with manipulating these expressions offline.  This is a good start.
12:56:38 <CodeWeaver> back online in a bit. :)
12:56:51 <magic_clouds> which OS would you say lets you install haskell and develop on the the quickest?
12:57:19 <mornfall> magic_clouds: Mostly anything that has platform.
12:57:30 <cmccann> CodeWeaver, if it helps, this particular trick is surprisingly mind-bending for something that's almost not doing anything at all
12:57:31 <mornfall> It's probably more important that you are familiar with it.
12:57:44 <mike-burns> magic_clouds: I hear the fewest issues with the Linuxes and also FreeBSD.
12:58:05 <mike-burns> And I hear the most complaints about Windows.
12:58:13 <CodeWeaver> magic_clouds:  probably linux.
12:58:15 <magic_clouds> mike-burns: yeah, i saw that one coming
12:58:21 <CodeWeaver> Mac OSX is a moderate second.
12:58:37 <CodeWeaver> Windows just has lousy unix-style tool support and shels.
12:58:39 <CodeWeaver> shells.
12:58:44 <CodeWeaver> But I have done it there a little.
12:59:05 <magic_clouds> If you could bear with me, what does Linux have that Mac OX X doesn't?
12:59:14 <opqdonut> window managers
12:59:35 <opqdonut> and lots of knobs to fiddle with
12:59:37 <CodeWeaver> magic_clouds:  Nothing in principle.  It is a BSD unix variant under the hood.
12:59:40 <CodeWeaver> As far as I remember.
12:59:50 <mike-burns> It has better HP support.
13:00:03 <mike-burns> Feel free to change that.
13:00:05 <CodeWeaver> magic_clouds:  But there are a few pathy differences, and shell differences, slightly, and just a few niggly details that occasionally make it go boom.
13:00:22 <CodeWeaver> If you're not trying to access os-specific things for the time being, magic_clouds, OSX is just fine.
13:00:54 <mike-burns> gtk2hs works on OS X, despite the fact that tons of people have never gotten it to work on OS X.
13:01:13 <CodeWeaver> wxWidgets works on OSX too, once you wrestle it under control.
13:01:17 <CodeWeaver> If you want to do gui stuff.
13:01:19 <magic_clouds> Okay, thanks for your help everyone
13:01:43 <acowley> Is anyone working on OpenGL 3.x (or beyond) bindings?
13:01:57 <CodeWeaver> Back later.
13:06:34 <neutrino> hi i am having a problem figuring out how to do something in an idiomatic way
13:08:17 <neutrino> i have a list of triples :: [(Int, Int, Int)] which define times of a day, [(hours, minutes, seconds)]. i need to write a function which accepts this list, and two triples called min and max, and: 1. filters out only the triples which are between min and max 2. for any possible triple between min and max (in 1-second increments), if it does not exist, add it
13:08:38 <neutrino> sorry, in fact it's a bit more complex
13:09:01 <neutrino> the list i get is a list of pairs: [((hours, minutes, seconds), count)]
13:09:24 <neutrino> and if no pair with a specific combination of matching h/m/s exists i need to add it, with count=0
13:09:29 <neutrino> how would i best approach this?
13:10:38 * hackagebot data-object-yaml 0.3.4.2 - Serialize data to and from Yaml files (deprecated)  http://hackage.haskell.org/package/data-object-yaml-0.3.4.2 (MichaelSnoyman)
13:17:16 <mike-burns> I could watch Snoyman deprecate packages all day.
13:18:12 <luite> s/enumerator/conduit/
13:18:16 <neutrino> Snoyman ?
13:19:06 <ben> He didn't deprecate it, he bumped the conduit dependency's upper version limit.
13:19:32 <ben> I just tried to install yesod a minute ago and it didn't work because of that package. :V
13:20:41 <Axman6> neutrino: the lead developer of yesod
13:21:01 <plediii> I'm having some difficulty understanding the result of profiling my haskell program.  The prof file shows that 80% is spent on the individual time of a particular function, and less than 1% on the individual time of the function it's calling.  But the only thing the troublesome function is doing is calling my other function.  How can 80% of the time be spent on calling this function?
13:21:59 <luite> ben: yesod 0.10 or 0.9?
13:22:14 <neutrino> Axman6: ah
13:22:15 <ben> I typed "cabal install yesod" and got bored and wandered off when it didn't work
13:22:31 <luite> oh right, that's 0.9
13:22:45 <jonte_> Any ideas on how I can rotate a pixbuf by an arbitrary number of degrees using gtk2hs?
13:22:57 <luite> problem is that it depends on lots of packages, and cabal can't always solve the dependencies when some new version is uploaded
13:23:05 <ben> yeah, figures
13:23:10 <ben> I'm gonna give it another shot.
13:23:12 <ben> Death to cabal, etc
13:23:22 <luite> 0.10 should be out in a couple of weeks
13:23:53 <luite> there's a beta now, but there are already some relatively big changes, some nasty bugs and a new conduit version
13:27:45 <plediii> hmm nevermind, I was calling ./prog -p instead of ./prog +RTS -p
13:32:15 <roconnor> tgeeky: http://www.reddit.com/r/haskell/comments/on3c9/zippers_with_a_variation_on_multiplate/c3mljqe?context=3
13:54:17 <hughfdjackson> just quick Q
13:54:32 <hughfdjackson> haskell has no TCO, but needs none, because it has no stacks and laziness?
13:55:07 <Axman6> haskell is a language, TCO is an optimisation, that may or may not be useful for Haskell
13:55:13 <ddarius> Your premises are false.
13:55:26 <hughfdjackson> u.u why, so they are
13:55:38 <hughfdjackson> s/haskell/GHC/
13:55:44 <hughfdjackson> is that a better premise?
13:55:49 <Axman6> not really
13:55:53 <hughfdjackson> :p d'oh
13:55:56 <ddarius> GHC "optimizes" tail calls.
13:56:00 <Axman6> pretty sure any tail recursive function i've written has been turned into a constant space loop
13:57:04 <Axman6> > let fib n = f n 0 1; f 0 x _ = x; f n !x !y = f (n-1) y (x+y) in fib 100
13:57:05 <lambdabot>   354224848179261915075
13:57:27 <hughfdjackson> i gotta be honest, that did not make a lot of sense to me
13:57:28 <Axman6> that will be compiled into a loop pretty easily
13:57:40 <hughfdjackson> :3 but rather than pester ya, ima go read about for a while
13:57:49 <Axman6> no, it is pretty line noisy isn't it
13:58:22 <hughfdjackson> :D cheers for giving me some leads to read up about
13:58:24 <Axman6> hughfdjackson: i suggest trying to learn some haskell before trying to analyse it. if you're coming from a background of imperative languages, you're going to be at a disadvantage
13:58:37 <hughfdjackson> aye, that i am, i realise :3
13:59:34 <Cromulent> is there a document which talks about the extensions to haskell made since the release of the haskell 98 report in GHC?
13:59:38 <hughfdjackson> u.u problem with an hours-in-the-day : interesting things mismatch
14:00:39 * hackagebot cuda 0.4.1.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.4.1.0 (TrevorMcDonell)
14:00:52 <ehuber> Cromulent: i tend to look at the extensions section in the GHC man .. but im sure there is a better way
14:00:56 <donri> Cromulent: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html perhaps?
14:01:19 <Cromulent> ah thanks :)
14:01:28 <ddarius> ehuber: No, that's the best way other than it won't distinguish between pre- and post-Haskell 98.
14:07:59 <mdmkolbe> I'm having trouble with "-main-is" (http://hpaste.org/57252).  What am I doing wrong?
14:08:19 <mdmkolbe> (This is GHC 7.0.3.)
14:08:39 <elliott> mdmkolbe: -main-is takes a module name
14:08:39 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
14:08:46 <elliott> well
14:08:49 <elliott> mdmkolbe: it takes Module.func
14:09:03 <elliott> so you need e.g. Main.eff there, or Eff.eff and have module Eff (eff) where ... in test.lhs
14:09:24 <monochrom> you fell prey of several GHC rules
14:10:03 <monochrom> rule 1. if you don't have a module header, it defaults to "module Main(main) where". note the default module name. note the default export limit list.
14:10:51 <monochrom> well, essentially that's the rule that stands in your way. eff isn't exported. does not exist. (with -O, it is not even code-generated)
14:11:19 <monochrom> the error message "The main function `eff' is not exported by module `Main'" is being truthful and relevant
14:12:13 <mdmkolbe> monochrom: I see.  Did this change recently?  (This is code that AFAICT worked in 2008.)
14:12:25 <monochrom> -main-is is actually pretty flexible. you can give just module, or just function, or both. since module and function can be told apart by letter case, there is no ambiguity.
14:12:37 <monochrom> no, has been for a long time
14:15:30 <monochrom> perhaps -main-is's ability to respect or violate export limitations has changed.
14:15:30 <mdmkolbe> monochrom: thanks for the explanation.  Putting "module Main where" at the top looks like the fix I needed.
14:15:40 * hackagebot IPv6Addr 0.2 - Library to deal with IPv6 address text representation.  http://hackage.haskell.org/package/IPv6Addr-0.2 (MichelBoucey)
14:17:18 <monochrom> the rule is actually Haskell 98's. "An abbreviated form of module, consisting only of the module body, is permitted. If this is used, the header is assumed to be `module Main(main) where'." Section 5.1
14:18:39 <mdmkolbe> monochrom: That is odd.  This code is from GPBench which I presume worked at one time.
14:19:13 <monochrom> so probably -main-is was a mafia smuggler in the past and a lawful carrier now
14:21:09 <mdmkolbe> In other news, does anyone know of any good generic programming benchmarks other than GPBench and paradise?  (The Alloy paper mentions that they wrote one, but I've not found it yet.)
14:22:15 <monochrom> hrm, Alloy paper? the Alloy software analyzer? Daniel Jackson's Alloy software analyzer?
14:23:11 <tkahn6> ***********************************************************************
14:23:11 <tkahn6>   _______   Sorry for the wait! The repository you are fetching is
14:23:11 <tkahn6>  |       |  using the DEPRECATED 'old-fashioned' format. I'm getting a
14:23:11 <tkahn6>  | O   O |  hashed copy instead, but this may take a while.
14:23:11 <tkahn6>  |  ___  |
14:23:12 <mdmkolbe> monochrom: http://hackage.haskell.org/package/alloy
14:23:12 <tkahn6>  | /   \ |  We recommend that the maintainer upgrade the remote copy
14:23:12 <tkahn6>  |_______|  as well. See http://wiki.darcs.net/OF for more information.
14:23:13 <tkahn6> :/
14:23:18 <tkahn6> someone needs to update c2hs
14:23:25 <tkahn6> doesn't install correctly with cabal
14:23:32 <monochrom> oh then nevermind
14:23:34 <c_wraith> tkahn6: that paste was kind of excessive
14:23:44 <tkahn6> c_wraith: i wanted you to see the face
14:23:52 <c_wraith> still kind of excessive
14:23:53 <elliott> tkahn6: hpaste.org
14:24:21 <monochrom> I forgive this time
14:24:42 <tkahn6> thank you monochrom, i will repay you for the bandwidth
14:24:52 <monochrom> but you almost got me to mistake you as spammer
14:25:05 <tkahn6> :/
14:26:08 <mdmkolbe> Umm, where did the Scrap Your Boilerplate web page go? (http://www.cs.vu.nl/boilerplate/)  I wanted to download the paradise benchmark from there.  Anyone know another place I can get it?
14:28:04 <elliott> http://www.cs.uu.nl/wiki/GenericProgramming/SYB
14:28:06 <elliott> via http://hackage.haskell.org/package/syb
14:31:04 <mdmkolbe> elliott: thanks
14:34:36 <eikke> enumerator 101: run_ $ throwError $ ErrorCall "You're too dumb to use this library"
14:34:39 <eikke> :(
14:35:35 <monochrom> hrm!
14:36:10 <monochrom> people say exceptions are hard. so if you can throw an exception, I say congratulations, what else could stumble you!
14:36:29 <eikke> haha
14:36:55 <eikke> seriously, I've been hacking for several hours and cant get things workign :P not even the most basic stuff
14:40:21 <elliott> eikke: You might find conduits less confusing.
14:40:25 <elliott> Or iterIO.
14:40:54 * cmccann actually likes the API in pipes for many purposes
14:41:11 <eikke> I'm not sure it's an api problem only
14:41:41 <eikke> I mean, main problem is I dont know how to model the thing I want to build
14:42:48 <tommd> crypto-api 0.9 is out - let the build-dep bumping begin.
14:43:09 <eikke> and docs somewhat lacking... most enumerator-related docs seem to *rebuild* an enumerator implementation from scratch
14:43:24 <eikke> or building something to count chars in a file, or maybe a simple server
14:43:40 <eikke> yet no long-living client stuff
14:45:40 * hackagebot crypto-api 0.9 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.9 (ThomasDuBuisson)
14:47:46 <eyebloom> What does it mean that a type variable is escaping it's scope?
14:48:54 <c_wraith> that some crazy type stuff is going on.
14:49:28 <c_wraith> that is, someone is using advanced type safety features in order to prevent you from doing certain wrong things
14:49:35 <c_wraith> and you're trying to do one of those wrong things
14:49:56 <c_wraith> More detail would require a specific case
14:51:25 <eyebloom> Hmmm... I'm not using any language extensions.
14:51:35 <c_wraith> But you might be using a library that is.
14:52:31 <eyebloom> Well what is the general meaning of escaping scope?
14:53:13 <Saizan> that to type your expression the type variable should be used outside of its scope
14:53:22 <Saizan> where scope is the usual lexical one
14:53:41 <elliott> eyebloom: Can you hpaste your code?
14:53:49 <c_wraith> that is, the error message says exactly what it means.
14:53:51 <elliott> It would be odd to get that message without using any type system extensions.
14:53:58 <c_wraith> we can't be more specific without seeing actual code
14:54:44 <rwbarton> an example would be if a pattern match on an existential introduces a type variable and the type of the result depends on that type variable
14:55:02 <eikke> is there anything like e.g. a memcached client for enumerator or something alike?
14:55:17 <tkahn6> is there an idiomatic way to express if the pointer is NULL? Ptr a -> Maybe (Ptr a)
14:55:23 <c_wraith> I guess rank-2 type violations, like from ST, usually say "foo was less polymorphic than expected"
14:55:56 <tkahn6> as in is there a function that people usually use to express this idea of 'it may be null'
14:56:07 <elliott> tkahn6: == nullPtr
14:56:07 <tromp_> Maybe there is
14:56:15 <elliott> (Ptr a) may always be NULL.
14:56:29 <tkahn6> elliott: oh you're right
14:56:31 <tkahn6> thanks
14:56:32 <tkahn6> heh
14:56:38 <eyebloom> It's deep in some fairly extensive modules, but I'll see if I can pull out a tractable example.
14:57:14 <rwbarton> even just the entire error message text would be helpful
14:59:17 <eyebloom>     Couldn't match type `n0' with `n'
14:59:18 <eyebloom>       because type variable `n' would escape its scope
14:59:18 <eyebloom>     This (rigid, skolem) type variable is bound by
14:59:18 <eyebloom>       the type signature for
14:59:18 <eyebloom>         adj :: G.AbstractNode n => V (G.Gr n) -> V Int -> V Adj
14:59:19 <eyebloom>     The following variables have types that mention n0
14:59:19 <eyebloom>       adjE :: LambdaExtension (G.Gr n0 -> Int -> S.Set Int)
14:59:19 <eyebloom>         (bound at VisualHoas.hs:200:1)
14:59:19 <eyebloom>     In the instance declaration for `Naive V'
15:00:00 <elliott> eyebloom: hpaste.org
15:00:12 <elliott> (that's the second huge paste today...)
15:00:22 <eyebloom> my apologies.
15:00:38 <Saizan> eyebloom: is adj in a where or let ?
15:00:45 <elliott> eyebloom: anyway, show us the definition of adj/adjE
15:00:48 <Saizan> *defined in
15:04:48 <eyebloom> http://hpaste.org/57253
15:05:04 <eyebloom> These are pulled from several different modules
15:06:19 <elliott> what is adjE's type signature?
15:06:37 <elliott> what are extend, apply2's type signatures?
15:06:38 <Saizan> the error doesn't match the code
15:06:48 <eyebloom> It's inferred currently
15:06:58 <elliott> but yes, that is not adj's type
15:07:07 <elliott> because GHC says it's adj :: G.AbstractNode n => V (G.Gr n) -> V Int -> V Adj
15:07:15 <elliott> not adj   :: G.AbstractNode n => repr (G.Gr n) -> repr Int -> repr Adj, so something is up
15:07:30 <Saizan> so it's about line 13?
15:08:15 <eyebloom> I see. adj is part of an instantiation of Naive repr
15:08:35 <eyebloom> which is a typeclass for naive expressions.
15:08:36 <elliott> ok. show the entire instance
15:08:40 <elliott> and the typeclass definition
15:08:44 <elliott> and the type you're giving an instance for
15:10:12 <eyebloom> http://hpaste.org/57254
15:11:16 <Saizan> what's the type of apply2 and extend?
15:11:30 <elliott> maybe if we ask three times :)
15:11:33 <Saizan> and how the error looks now?
15:12:02 <eyebloom> Right now those are also inferred.
15:12:20 <elliott> what are their definitions?
15:12:35 <Saizan> ask ghci then :)
15:12:35 <elliott> p.s. tracking down these errors would be a lot easier if you gave everything explicit type sigs :p
15:12:58 <eyebloom> http://hpaste.org/57255
15:13:10 <eyebloom> That's a good suggestion.
15:13:47 <elliott> i agree with the ??? :D
15:13:52 <eyebloom> I was just trying to get it to compile as I'm still working on the logic of my type checker.
15:14:01 <elliott> but yes, i'd like to know what ghci thinks the types of apply2 and extend are too
15:14:10 <eyebloom> It's work in progress.
15:14:50 <eyebloom> Well that leads to another question, how can you look at the inferred type if the module won't compile?
15:14:51 <rwbarton> adjE is probably subject to the monomorphism restriction
15:14:52 <elliott> (Is "VisCode" from a library? Something has to be using an extension for this to be happening, I believe.)
15:15:03 <rwbarton> while you try to use it polymorphically
15:15:03 <elliott> eyebloom: Remove the parts that don't compile.
15:15:35 <Saizan> ah, yeah, that's it
15:15:45 * hackagebot authenticate-ldap 0.0.1.1 - LDAP authentication for Haskell web applications.  http://hackage.haskell.org/package/authenticate-ldap-0.0.1.1 (MichaelLitchard)
15:15:54 <eyebloom> Viscode is from another module.
15:16:05 <elliott> Would that cause an "escape" error?
15:16:06 <Saizan> eyebloom: in general you comment out what doesn't compile
15:16:49 <eyebloom> Gotcha, I'll need a few minutes to see if I can find those type signatures.
15:17:11 <Saizan> eyebloom: anyhow {-# LANGUAGE NoMonomorphismRestriction #-} on top of the module wher you define adjE should fix it
15:17:22 <rwbarton> elliott: maybe? you could think of 'n' (the type variable from adj in the instance Naive V) as escaping its scope because it must be the (monomorphic) type variable that adjE is defined at
15:17:42 <rwbarton> but this is nonsensical because 'n' is under a forall
15:17:53 <Saizan> it's n that escapes the scope
15:18:15 <Saizan> because to make it work you'd have to instance n0, which is really a meta-variable, with n
15:19:42 <Saizan> GHC should learn some error messages from Agda
15:19:50 <eyebloom> Yes it does seem to compile if I add that language extension.
15:20:43 <Saizan> eyebloom: another way to make it compile would be to add an explicit type signature to adjE, so that it'll be polymorphic
15:22:39 <eyebloom> I see, I'll try that now.
15:23:38 <eyebloom> ghci says that the signature is  adjE :: (AbstractGraph.AbstractNode n, AbstractGraph.AbstractGraph g) => VisualHoas.LambdaExtension (g n -> Int -> Data.Set.Set Int)
15:23:44 <elliott> eyebloom: there's another good reason to always use type signatures :)
15:23:51 <elliott> yeah it's just the MR
15:23:58 <elliott> add explicit type signatures to things until it works
15:25:15 <Saizan> yeah, if you put that in your source then you won't need the extension
15:26:05 <smithw> Is there a better, idiomatic way to do this: [(allPositions !! i, allPositions !! j) | i <- [0..length allPositions], j <- [0..i]] ?
15:26:19 <Saizan> the monomorphism restriction says that if you have a definition like "foo = .." as opposed to "foo arg1 .. argn = .." then it can't be polymorphic if it has a class context
15:26:29 <smithw> length allPositions - 1, that is
15:26:39 <Saizan> but if foo has a type signature the restriction doesn't apply
15:26:45 <eyebloom> Just did. It's working. So basically if I understand correctly the compiler needed to know that the type variable n was an instance of something.
15:27:01 <eyebloom> And it couldn't tell that without the explicit signature.
15:27:21 <elliott> eyebloom: no -- the problem is that adjE is a definition at the top-level with no parameters
15:27:22 <eyebloom> Which included the typeclass constraint.
15:27:24 <elliott> and a polymorphic type
15:27:30 <elliott> which means it gets defaulted
15:27:33 <rwbarton> involving a type class
15:27:39 <elliott> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:27:46 <elliott> hmm, wait
15:27:51 <elliott> were any numeric typeclasses ever involved?
15:27:54 <elliott> ah, it'll be the "Int"
15:28:01 <elliott> no, wait, Int isn't defualted to
15:28:08 <rwbarton> defaulting is not relevant here
15:28:10 <Saizan> it could tell everything, it just couldn't allow it
15:28:23 <rwbarton> ghc is just trying to infer from the rest of the program which monomorphic type to select
15:28:26 <elliott> oh, hmm, right
15:28:53 <rwbarton> smithw: Yes
15:29:19 <rwbarton> does it matter what order you produce the pairs in?
15:29:48 <eyebloom> I see. It seems like the original error message would lead you in the wrong direction.
15:30:15 <kallisti> Could not find module `Foreign.LibFFI' Perhaps you haven't installed the "dyn" libraries for package `libffi-0.1'?
15:30:18 <kallisti> any idea what this means?
15:30:19 <rwbarton> > let allPositions = [1..5] in [ (x, y) | t <- tail $ tails allPositions, let x = last t, y <- t ]
15:30:20 <lambdabot>   [(5,2),(5,3),(5,4),(5,5),(5,3),(5,4),(5,5),(5,4),(5,5),(5,5)]
15:30:27 <rwbarton> oops
15:30:31 <rwbarton> > let allPositions = [1..5] in [ (x, y) | t <- tail $ inits allPositions, let x = last t, y <- t ]
15:30:32 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
15:30:34 <smithw> rwbarton, no, the order of the pairs is irrelavant. All I need is that they are not repeated, in any order within the apir
15:30:36 <eyebloom> But thanks for all of the good suggestions. It seems like the art of haskell is commenting and uncommenting type signatures.
15:30:56 <rwbarton> > let allPositions = [1..5] in [ (x, y) | t <- tail $ tails allPositions, let x = head t, y <- t ]
15:30:57 <lambdabot>   [(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,4),(4,5),(5,5)]
15:31:03 <rwbarton> erm
15:31:24 <rwbarton> > let allPositions = [1..5] in [ (x, y) | t@(x:_) <- tails allPositions, y <- t ]
15:31:25 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4...
15:32:19 <smithw> thanks rwbarton :) that's precisely what I need
15:33:42 <kallisti> googling seems to turn up nothing about these "dyn" libraries.
15:35:38 <kallisti> ah I didn't --enable-shared with cabal install
15:36:26 <elliott> kallisti: you could just turn off dynamic linking?
15:36:45 <kallisti> elliott: nope I'm using dynamic linking for a reason.
15:36:58 <elliott> kallisti: time to put it in ~/.cabal/config and reinstall everything then
15:36:58 <kallisti> well... I could statically compile the Haskell runtime if that's what you mean
15:37:13 <elliott> dynamic in this case refers just to the haskell libs
15:37:23 <kallisti> ah, yeah that's an option.
15:37:26 <elliott> most of the time you statically link haskell libraries but dynamically link libc/gmp/other c libs, as is the default
15:37:38 <elliott> you should only get that error if you explicitly ask ghc for dynamic haskell library linking
15:37:44 <elliott> which is usually not what you want
15:37:49 <kallisti> I do. I can't seem to use -shared otherwise.
15:38:04 <elliott> right, that's what you probably don't want
15:38:23 <elliott> -shared is for generating haskell shared libraries
15:38:27 <kallisti> yes.
15:38:30 <kallisti> that's what I'm doing.
15:38:34 <elliott> well... ok, why?
15:38:56 <kallisti> it's a plugin to a C program, which uses dlsym
15:39:15 <kallisti> there's a way to statically compile the Haskell libs but generate a shared library, I believe.
15:39:37 <kallisti> but without the -dynamic flag (using only -shared and -fPIC) I get an error suggesting that I use -fPIC
15:40:10 <elliott> kallisti: you'll have to write C wrapper code for that, btw
15:40:13 <elliott> (I think)
15:40:15 <elliott> to initialise the rts
15:41:11 <kallisti> elliott: unless you're talking about something other than the C wrapper code I already have, then I believe I've already done all of that.
15:41:36 <kallisti> hs_init, hs_add_root, hs_exit, etc
15:42:58 <elliott> anyway
15:43:12 <elliott> kallisti: if you use haskell shared libraries, then you'll have to include about a billion .sos with your .so
15:43:18 <elliott> to get your library to work
15:43:29 <elliott> one for every single haskell library used directly or indirectly
15:43:35 <elliott> if you're only using it locally it doesn't matter
15:44:27 <kallisti> elliott: the only I've needed to explicitly link is the rts
15:44:31 <kallisti> +thing
15:45:18 <kallisti> I might try statically compiling Haskell libs, and then making a shared lib in a seperate step.
15:46:59 <elliott> kallisti: explicitly perhaps, but take a look at ldd mylib.so sometime
15:47:22 <kallisti> ah excellent.
15:52:07 <kallisti> relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC
15:52:19 <kallisti> elliott: this is what happens when I try to compile -shared without -dynamic
15:52:31 <kallisti> (yes -fPIC is on)
15:53:13 <elliott> i've never done it
15:53:23 <ehuber> hello kallisti
15:53:28 <kallisti> ehuber: hi
15:53:34 <ehuber> you're creating a shared library but having trouble linking?
15:54:06 <kallisti> well, it links fine if I use both -shared and -dynamic but I'd like to statically compile the rts so I can then compile a standalone shared library
15:54:26 <kallisti> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/using-shared-libs.html  following this guide under "Shared libraries that export a C API"
15:55:24 <kallisti> ah I see
15:55:32 <kallisti> the other libraries must be built with -fPIC which is not done.
15:55:44 <ehuber> yeah there is that problem
15:55:59 <kallisti> so.... recompile them with -fPIC I guess? :P
15:56:03 <ehuber> the only time i ever did this, i had to reinstall my cabal packages iwth -dynamic
15:56:32 <ehuber> look, im not really sure about this topic either, but here is my Makefile for a project which was a .so to be loaded by apache, https://github.com/edmund-huber/mod_haskell/blob/master/Makefile
15:57:44 <kallisti> hmmm, no -fPIC?
15:58:35 <ehuber> look harder :)
15:58:39 <ehuber> it went into GHC_OPTS
16:00:07 <kallisti> oh, indeed.
16:00:37 <elliott> ehuber: btw, http://www.st.ewi.tudelft.nl/~dolstra/mod_haskell/
16:00:39 <kallisti> what does ghc when it encounters a directory argument?
16:00:41 <elliott> ancient and for hugs though
16:00:48 <kallisti> +do
16:00:50 * hackagebot web-routes 0.26.3 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.26.3 (JeremyShaw)
16:00:55 <elliott> although "18 Apr 2002: you can now try out the experimental Apache 2.0 / GHC version of mod_haskell. The source code is in our CVS repository, branch ghc."
16:01:05 <ehuber> elliott: yeah..
16:01:09 <ehuber> that's why i recreated it
16:01:13 <elliott> ah
16:01:13 <ehuber> also, learning experiment
16:01:28 <kallisti> you seem to pass `ghc --print-libdir` to GHC as a positional argument. what effect does that have.
16:01:51 <ehuber> kallisti: so that ghc knows where to find all the .la's that it's gonna need to link in, iirc
16:01:59 <kallisti> ah okay.
16:02:16 <ehuber> .a 's :p
16:06:06 <kallisti> /usr/bin/ld: Bayes.o: relocation R_X86_64_32 against `Main_d1RM' can not be used when making a shared object; recompile with -fPIC
16:06:11 <kallisti> same problem, different symbol.
16:06:31 <ehuber> that is a bummer.
16:07:21 <ehuber> wait
16:07:24 <ehuber> Main?
16:07:38 <kallisti> hm, oh.
16:07:44 <kallisti> yes I don't have a main actually.
16:09:01 <kallisti> oh wait. I think I added one just to be safe. but I don't need one I can just compile with -no-hs-main
16:09:17 <ehuber> i would just remove it if i were you. you are using source control right? :)
16:09:25 <kallisti> not currently no. :P
16:09:31 <kallisti> it's just return ()
16:09:41 <kallisti> also Main there refers to the module name, actually.
16:10:27 <kallisti> hm weird even with -no-hs-main it complains about no main.
16:10:35 <ehuber> hmmm
16:10:47 <kallisti> Bayes.hsc:1:1: The function `main' is not defined in module `Main'
16:11:21 <ehuber> for giggles can you try with -dynamic?
16:11:28 <elliott> It's a library, why are you trying to compile it as a program?
16:11:36 <kallisti> -dynamic is on.
16:12:01 <kallisti> elliott: because I get errors if I leave out main. :P
16:12:05 <kallisti> or did you mean something else?
16:13:57 <mdmkolbe> Is there a way to parse a large file into a Template Haskell AST?
16:14:23 <elliott> mdmkolbe: http://hackage.haskell.org/package/haskell-src-meta?
16:15:25 <kallisti> build_bayes.sh: 2: -dynamic: not found
16:15:39 <ehuber> kallisti: i dont think i can help you much more. try staring at that Makefile and hopefully that will help. i kind of had to feel it out
16:15:46 <mdmkolbe> elliott: ah yes, I keep forgetting about that library.  thanks
16:15:55 <kallisti> oh wait perhaps the syntax of bash and makefiles differ here.
16:16:58 <kallisti> ehuber: this is valid sh isn't it? GHC_OPTS=-Wall -dynamic -fPIC -no-hs-main
16:17:28 <kallisti> it complains about "-dynamic not found"
16:19:00 <ehuber> yup, sh and make differ
16:19:17 <ehuber> try putting quotes around the whole thing (though im not sure how you're trying to use it)
16:19:32 <kallisti> in the same way as in your makefile
16:19:43 <ehuber> also in a makefile?
16:19:53 <kallisti> no... I don't have one of those. I guess I should.
16:20:43 <ehuber> it's not much work :)
16:21:47 <elliott> kallisti: you want
16:21:52 <elliott> --wait, nevermind
16:22:02 <elliott> kallisti: cabal can build shared libraries i think(?)
16:22:05 <elliott> so you might not need a makefile.
16:23:08 <ehuber> i dont want to be that guy, but i couldn't make it work in the way i wanted
16:23:15 <ehuber> but by all means try the dynamic thing in cabal
16:26:14 <kallisti> does a \ at the end of a line continue a line in a makefile?
16:26:51 <kallisti> hm, no.
16:27:28 <dmwit> Not all lines in a Makefile are identical.
16:27:36 <dmwit> Dependency lines may be continued with a \.
16:28:52 <dmwit> I think you can continue shell lines with a \ too.
16:29:02 <dmwit> So... are you sure what you did didn't work?
16:29:19 <kallisti> pretty sure..
16:30:28 <dmwit> http://www.gnu.org/software/make/manual/make.html#Splitting-Lines
16:31:31 <dmwit> kallisti: Perhaps you'd better ?hpaste what you tried. =)
16:33:59 <nyingen> @quote
16:33:59 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
16:33:59 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
16:34:09 <kallisti> I decided to split it up into multiple targets.
16:34:30 * kallisti was going to use && so that it didn't attempt to compile if a previous compilation step failed.
16:38:01 <Veinor> is there a category theory term for an object with no arrows to anything other than itself?
16:38:26 <dmwit> Wow, great quote.
16:38:37 <dmwit> Veinor: monoid comes close
16:39:07 <dmwit> Veinor: It's a bit unusual for a CT idea, because there's no good sense of "up to isomorphism" for such an object.
16:39:26 <Veinor> right, right
16:39:48 <dmwit> maybe "discrete"
16:40:38 <dmwit> (I don't think that "discrete object" is an already defined term, but if you wanted to pick a term to attach to this idea, that would be a good choice.)
16:40:57 * hackagebot skein 0.1.0.5 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.5 (FelipeLessa)
16:40:57 <Veinor> i was going to pick 'isolated'
16:41:20 <rwbarton> Isolated sounds okay to me, provided you define it of course
16:41:24 <Veinor> right
16:41:25 <dmwit> Ah, yeah, discrete isn't good, because it allows for only identity arrows.
16:41:35 <Veinor> this isn't as part of like a formal category theory thing, i was just wondering
16:41:44 <Eduard_Munteanu> Maybe "disconnected" also alludes to graph theory concepts?
16:41:48 <rwbarton> thinking of the underlying graph of the category, you could call it a "sink"
16:42:36 <rwbarton> though apparently this term has several senses
16:48:12 <kallisti> /usr/bin/ld: /usr/local/lib/ghc-7.2.2/libHSrts.a(Adjustor.o): relocation R_X86_64_32 against `.rodata.str1.8' can not be used when making a shared object; recompile with -fPIC
16:48:17 <kallisti> does anyone actually know what this means?
16:50:35 <eviltwin_b> I know exactly what it means as such, but not what to do about it in the context of GHC
16:51:29 <kallisti> it would appear that manually linking the HSrts .so fixes it
16:51:35 <kallisti> however, adding a -lHSrts does not
16:51:39 <ehuber> interesting
16:52:43 <kallisti> well, I won't say that it "fixes it". just that it allows it to compile
16:55:36 <irene-knapp> are you on OS X by any chance?
16:55:50 <eviltwin_b> not if using a .so they're not
16:55:56 <irene-knapp> oh, good point
16:57:58 * kallisti is on Ubuntu
16:58:32 <kallisti> here's what happens when my library is passed to dlopen
16:58:34 <kallisti> Loading plugin "plugin/bayes.so" failed: "plugin/bayes.so:  undefined symbol:  libffizm0zi1_ForeignziLibFFIziTypes_retCInt_closure".
16:58:54 <kallisti> I'm wondering why I need to manually include the .so of everything I use, despite using -l options
16:59:38 <irene-knapp> have you tried making a .cabal file that works, invoking Cabal with -v or -vv or even -vvv to see what commands it invokes, and then making your Makefile output those commands?
16:59:47 <irene-knapp> Haskell is rather finicky to build, and Cabal does some deep magic
16:59:51 <kallisti> I have not.
17:00:02 <ozgura> hi. where can I read about unsafeDupablePerformIO vs unsafePerformIO?
17:00:04 <irene-knapp> it's probably best to ask it, therefore, rather than try to arrive at the same result from first principles
17:00:20 * kallisti has never made a .cabal file.
17:00:22 <kallisti> I'll have to look up how to do so.
17:00:25 <irene-knapp> I'm not clear on why you're using a Makefile, either :)
17:00:33 <irene-knapp> but I assume for the sake of argument that doing so is desirable
17:00:48 <irene-knapp> yeah - it's fairly self-explanatory.  I believe there's a subcommand of cabal now which will create a skeleton for you, even.
17:01:10 <elliott> ozgura: docs of system.io.unsafe
17:01:16 <ozgura> irene-knapp: that is cabal init.
17:01:18 <elliott> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/System-IO-Unsafe.html
17:01:32 <irene-knapp> thanks, yes
17:01:40 <elliott> kallisti: are you using --make?
17:02:09 <kallisti> elliott: oh. I believe I removed it, actually. that might help.
17:02:36 <ozgura> elliott: cheers, I was somehow looking at an older version of that document.
17:03:05 <ozgura> which doesn't include unsafeDupable
17:03:07 <elliott> ozgura: you can always replace the version number with "latest"
17:03:12 <kallisti> but no it doesn't seem to change anything. I believe --make just does some things for you automatically. I've already got a huge list of compiler options...
17:03:32 <ozgura> elliott: yeah, when I am alert enough to do that :)
17:03:56 <ozgura> I didn't know it was exported from system.io.unsafe anyway.
17:04:11 <ozgura> thanks.
17:04:30 <dmwit> Here goes nothing.
17:05:41 <tgeeky> dmwit: that idiom has always struck me as funny and absurd.
17:05:56 <dmwit> I think that's on purpose. =)
17:05:59 * hackagebot crypto-conduit 0.1.3.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.1.3.1 (FelipeLessa)
17:06:06 <tgeeky> "Here goes nothing." is almost certainly followed by something very interesting.
17:06:26 <tgeeky> dmwit: maybe it's because I grew up hearing that from rednecks who are soon to injure themselves
17:07:03 <dmwit> hehe
17:07:17 <dmwit> Well, if anybody gets hurt from what I just did, it won't be me. =)
17:07:19 <dmwit> ?hackage category-extras
17:07:20 <lambdabot> http://hackage.haskell.org/package/category-extras
17:07:45 <tgeeky> holy nice
17:09:54 <elliott> dmwit: shhh! you're meant to let hackagebot drop it on everyone
17:10:02 <dmwit> =)
17:11:01 * hackagebot category-extras 1.0 - A meta-package documenting various packages inspired by category theory  http://hackage.haskell.org/package/category-extras-1.0 (DanielWagner)
17:11:09 <dmwit> ah, there we are =)
17:11:14 <elliott> dmwit: shouldn't void-Data.Void be void:Data.Void?
17:11:21 <tgeeky> dmwit: thank you very much. As an unintended side effect, I think you've just given me a really interesting (in this case, extreme) example for a discussion about API/package management.
17:11:49 <dmwit> elliott: I dunno. What's better about : compared to -?
17:12:12 <dmwit> I mean, I'm not against it, but I don't think I'll upload a new version to change it unless there's a pretty darn good argument.
17:12:57 <elliott> dmwit: Probably nothing :) although technically uppercase is valid in package names, so it's ambiguous right now... but isn't "package:Module.Name" used by something official like GHC:
17:13:05 <elliott> (come to think of it, : might be valid in package names too)
17:13:13 <elliott> s/GHC:/GHC?/ -- haunted by colons
17:13:14 <tgeeky> dmwit: the dX of the export list is pretty much as extreme as possible (huge, varied number of exports -> 0), and in a way which is not often used
17:13:46 <dmwit> tgeeky: Yeah, pretty extreme.
17:14:14 <tgeeky> dmwit: also, thinking about it... we ought to be actually doing this for deprecated packages!
17:14:24 <tgeeky> well, after-deprecated packages
17:14:25 <dmwit> Note that the dependency list means many of those exported modules are still exported -- just by a different package!
17:16:30 <dmwit> Quick question: are people getting a weird favicon that looks sort of like an upside down seagull from the dependency graph link?
17:16:34 <dmwit> http://dmwit.com/category-extras/dependencies.png
17:16:47 <tgeeky> dmwit: none at all
17:16:57 <dmwit> tgeeky: Good, that's what I expect.
17:17:14 <dmwit> I wonder what chromium thinks it's doing.
17:17:14 <elliott> no, but an upside-down seagull would be a good favicon
17:17:20 * elliott is using chromium
17:17:31 <tgeeky> I'm using s/ium//
17:17:32 <elliott> dmwit: i think chromium often inherits favicons from referers
17:17:35 <tgeeky> or /e/
17:17:38 <elliott> chrom
17:17:43 <tgeeky> yeah
17:17:46 <elliott> dmwit: e.g. i frequently get google favicons after clicking on google results
17:17:51 <elliott> (maybe that's because of google's redirect)
17:17:54 <dmwit> elliott: Ah. That seems... wrong.
17:17:59 <kallisti> cool, now libffi is segfaulting.
17:18:08 <dmwit> kallisti: Progress!
17:18:09 <tgeeky> I was so terrified of IE, that I ripped out the (e) from chrome
17:18:40 <kallisti> yes apparently GHC wants me to manually dumb in the path to every .so that ends up being complained about or something.
17:18:57 <kallisti> s/dumb/dump/ Freudian slip.
17:20:22 <dmwit> elliott: GHC doesn't seem to use either : or - for a separator, at least according to the section on package-qualified imports here: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
17:20:31 <dmwit> import "network" Network.Socket
17:21:05 <monochrom> an upside-down seagull sounds like λ
17:21:56 <elliott> dmwit: I meant in error messages or such.
17:22:01 <dmwit> aha
17:23:29 <dmwit> http://dmwit.com/seagull.png since there seems to be some curiosity =)
17:24:19 <monochrom> inverted romulan warbird? :)
17:24:32 <dmwit> THERE'S NO GRAVITY IN SPACE
17:24:42 <dmwit> Why are those ships always aligned??
17:24:50 <elliott> it's :< with a big moustache
17:24:56 <elliott> hope this helps
17:25:09 <monochrom> aligned with the galactical plane
17:25:20 <Igloo> dmwit: There most certainly is gravity in space
17:25:24 <elliott> dmwit: so people inside don't get dizzy, duh
17:25:27 <monochrom> the milky way is not a sphere
17:25:42 <tgeeky> dmwit: that looks like a splay version of luite's Wolfgang logo
17:25:59 <tgeeky> more like a seagull, but also that
17:26:03 * kallisti wonders what could cause a segfault in ffi_call_unix64
17:26:24 <tomprince> There is a conjecture that inertia is caused by background gravitation.
17:26:47 <dmwit> Igloo: Yes, well. Not in a way that would make aligned spaceships sensible.
17:27:24 <tomprince> Certainly.
17:27:43 <tomprince> Although  ... trafic regulation by cause aligned spaceships.
17:27:44 <dmwit> tgeeky: Google is failing me. Wolfgang?
17:28:05 <tgeeky> dmwit: not public yet. one sec.
17:28:11 <dmwit> Oh, I think I found it.
17:28:15 <dmwit> http://jabberwock.xs4all.nl/exp/wolfgang/
17:28:27 <tomprince> Even ... regulations designed by people who have no appreciation for 3 dimentional movement.
17:28:31 <tgeeky> yes, not very helpful
17:28:35 <dmwit> I remember what it looked like, now that I see the URL.
17:28:41 <dmwit> But not the logo. =)
17:28:43 <tomprince> (also, for set designers)
17:29:17 <elliott> kallisti: Probably you're trying to call a bad pointer?
17:29:34 <Igloo> tomprince: Don't suppose you have a link for the inertia theory?
17:30:06 <stepkut> > shiftL (0xf :: Data.Word.Word32) (-1)
17:30:07 <lambdabot>   7
17:30:07 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
17:30:32 <nyingen> how does lambdabot end up having messages on preflex?
17:30:44 <tgeeky> dmwit: http://hdiff.luite.com/tmp/ws.png
17:31:08 <kallisti> elliott: that's my guess as well.
17:31:22 <elliott> preflex will bother lambdabot till the end of time
17:31:50 <luite> tgeeky: lol that's a really old screenshot
17:31:59 <tgeeky> luite: just the logo is in question
17:32:08 <Axman6> preflex: tell lambdabot We love you
17:32:08 <preflex>  Consider it noted.
17:32:10 <dmwit> ah, yep, that does look a bit like the logo =)
17:32:15 <Axman6> > 2 + 3
17:32:16 <lambdabot>   5
17:32:28 <stepkut> so, this used to return 7, but under GHC 7.4 it now returns 0: shiftL (0xf :: Data.Word.Word32) (-1)
17:32:33 <tgeeky> dmwit: yeah. Take that, and use a 25 ton press, and you have a "seagull"
17:32:39 <stepkut> you aren't actually allowed to pass in a negative shift value
17:32:40 <tgeeky> probably not a very alive one
17:32:53 <stepkut> but I am trying to figure out when it started returning 0 instead of 7
17:33:01 <dmwit> :t shiftL
17:33:02 <lambdabot> forall a. (Bits a) => a -> Int -> a
17:33:03 <elliott> stepkut: probably some optimisation?
17:33:15 <elliott> just do a binary search on GHC versions :P
17:33:35 <stepkut> elliott: I am trying to figure out if it is something that changed in 7.4 or 7.2, or if it is a 32-bit vs 64-bit thing
17:33:38 <Veinor> oh, here's a math problem
17:33:50 <Veinor> given an ordered list with a prior probability distribution of which one is the goal
17:33:56 <dmwit> stepkut: I've got a few versions lying around, let me test for you. =)
17:33:56 <stepkut> elliott: that's what I am trying :) Hoping other people will run that and report their results ;)
17:34:13 <Veinor> and given a test that tells you if you're less than, greater than, or equal to your goal
17:34:17 <Veinor> find an optimum testing strategy
17:34:44 <dmwit> stepkut: x64 here; gives 7 in 7.2.2 and 0 in 7.4-rc1
17:34:50 <stepkut> k
17:35:08 <stepkut> so it is 7.4 issue. Though technically nothing is wrong since using (-1) was illegal to start with
17:35:12 <tomprince> Igloo: Mach' principle
17:35:37 <stepkut> I blame it on Igloo :p
17:36:50 <Axman6> bloody Igloo, always making shit work the way they're supposed to
17:37:40 <monochrom> use the test on the list item s.t. about 0.5 probability the goal is below the item, about 0.5 probability the goal is above the item
17:37:54 <stepkut> Axman6: yeah, but in this case, his name is on the file that uses shiftL incorrectly :p
17:37:58 <Igloo> tomprince: Ta
17:38:26 <Igloo> stepkut: Oh? What file is that?
17:39:14 <stepkut> SHA.lhs from http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/sha1/haskell-sha1-0.1.0/
17:39:15 <monochrom> this is a natural generalization of classical binary search. in classical binary search, we assume equal probability of goals, and so the middle item is such that about 0.5 probability the goal is below the item, etc
17:39:30 <Veinor> monochrom: right, but is that the correct generalization?
17:39:36 <monochrom> yes
17:40:02 <Veinor> do you have a proof?
17:40:04 <stepkut> Igloo: there is a copy of it in happstack-util:Happstack.Crypto.SHA1. Which will be deprecated with the rest of happstack-util when happstack 7 comes out
17:40:20 <monochrom> I don't have a proof.
17:40:33 <lpsmith> stepkut:  your test case is returning 7 on ghc-7.4.1-rc2
17:40:49 <dmwit> Proof by appeal to information theory.
17:40:53 <stepkut> lpsmith: interesting
17:40:54 <dmwit> Cutting it in half maximizes entropy.
17:40:57 <lpsmith> actually,  it was fixed by 7.4.0.20120111
17:41:10 <monochrom> yeah, essentially that argument
17:41:17 <stepkut> lpsmith: oh ? do you know what fixed it ?
17:41:20 <monochrom> (cutting probabilities in half)
17:41:37 <stepkut> lpsmith: according to the docs negative numbers are not allowed anyway, so I am going to change it to shiftR and be done
17:42:06 <lpsmith> stepkut, no,  it's just that I happen to have that version of ghc on my machine
17:42:10 <stepkut> ah
17:42:22 <stepkut> lpsmith: 64-bit or 32-bit?
17:42:32 <lpsmith> stepkut, 64 bit
17:42:37 <stepkut> k
17:43:03 <lpsmith> well, if it's a constant shift,  yeah might as well change it to shiftR
17:43:17 <stepkut> before: rotL a s = shiftL a s .|. shiftL a (s-32)
17:43:23 <stepkut> after: rotL a s = shiftL a s .|. shiftR a (32 - s)
17:43:33 <Igloo> stepkut: Hmm, where do you get -1 as the shift amount?
17:43:46 <Igloo> stepkut: Oh, doh, yes, sorry
17:46:23 * hackagebot happstack-util 6.0.3 - Web framework  http://hackage.haskell.org/package/happstack-util-6.0.3 (JeremyShaw)
18:06:23 <kallisti> elliott: yeah I finally just wrote wrapper functions in C, and it does appear to be bad pointers. which is beyond my control...
18:06:33 <kallisti> excellent
18:14:02 <kallisti> fun fact: peekCString doesn't check to see if the Ptr CChar is null.
18:14:29 <elliott> kallisti: Why would it?
18:14:37 <elliott> It also can't check if your process has actually allocated it.
18:15:15 <kallisti> well, it doesn't have to be all or nothing. a little safety would be nice. I wrote my own, regardless.
18:16:30 <elliott> kallisti: False senses of security are bad, and encouraging people to blithely dereference pointers they don't know are allocated is bad.
18:16:54 <elliott> kallisti: Haskell exceptions interact badly with the FFI, anyway.
18:17:02 <ben> heh, just catch sigsegv
18:17:08 <ben> problem solved
18:19:18 <kallisti> elliott: and yet having a function that checks for NULL and then does return "" instead of dereferencing removes a preventable source of errors (errors that can be difficult to debug depending on how your Haskell code is being run via C interfaces), while making no false claims to security (if properly documented)
18:19:37 <irene-knapp> mm
18:19:44 <irene-knapp> no, it is a false sense of security
18:19:49 <irene-knapp> docs don't help
18:19:51 <irene-knapp> a) nobody reads docs
18:19:55 <irene-knapp> b) nobody reads docs
18:20:00 <irene-knapp> c) nobody reads docs :)
18:20:05 <kallisti> they don't? how do they get away with that?
18:20:14 <irene-knapp> I thought I had a distinct point to make there, which was going to be my c)
18:20:16 <irene-knapp> but I didn't, oh well
18:20:29 <kallisti> and maybe if you called it reallyReallySafePeekCString it would be a false sense of security.
18:20:32 <irene-knapp> they get away with it because their bugs do not become evident until 10 years later
18:20:41 <irene-knapp> when they are working in other industries or retired
18:21:27 <irene-knapp> frankly, if you had this magic behavior, I wouldn't want it even for myself
18:21:31 <irene-knapp> I don't trust /even myself/ that far
18:21:42 <irene-knapp> also I usually want to do something clever and recover
18:21:49 <irene-knapp> so I'd be paying the expense of the check twice
18:21:57 <irene-knapp> if null is in fact a legitimate input, that is
18:22:10 <kallisti> it is. people apparently use it instead of empty strings.
18:22:13 <irene-knapp> the library function can't know how I want my control flow to work in the null case
18:22:22 <irene-knapp> people ALSO use it to mean something DISTINCT from an empty string
18:22:24 <irene-knapp> akin to Maybe String
18:22:31 <kallisti> yes that's true.
18:22:32 <irene-knapp> but, obviously, not the same
18:22:44 * kallisti never suggested that peekCString be removed or modified.
18:23:21 <irene-knapp> you did, in fact, suggest that some function, perhaps an additional one? should behave differently
18:23:30 <irene-knapp> well, okay, then my second argument is a strawman
18:23:33 <irene-knapp> but my first stands :)
18:23:42 <kallisti> CString -> IO (Maybe String)  would possibly be a better function
18:23:48 <irene-knapp> no
18:23:51 <irene-knapp> no, I don't want that
18:24:17 <irene-knapp> C's overloading of pointers to have this special NULL value which inhabits all pointer types
18:24:19 <irene-knapp> is an ugly trick
18:24:22 <irene-knapp> and using it should feel ugly
18:24:31 <irene-knapp> so as to discourage its use except in legacy situations
18:24:49 <kallisti> so the ugliness should be contagious in Haskell libraries? got it.
18:24:58 <mikeplus64> speaking of strings, one can use OverloadedStrings to input ByteString/Text/whatever literals, right, but those are packed at runtime, not compile time
18:25:03 <mikeplus64> if I were to use TemplateHaskell...
18:25:21 <irene-knapp> look, the hotel you've picked for the night's stay is infested with roaches.  we can't change that, there's no refunds.  but you're complaining about the curtains on the windows.
18:25:23 <mikeplus64> like $( [| "foobar" :: ByteString |] )
18:25:34 <mikeplus64> would that be packed at compile time?
18:25:36 <irene-knapp> but YES, the ugliness should be contagious
18:25:42 <irene-knapp> so that you know and are reminded of its existence
18:25:49 <mikeplus64> I might have mixed up the TH syntax but nonetheless
18:26:14 <ion> I’d expect the compiler to be able to inline overloaded strings if it can inline Foo.pack "bar". But i haven’t actually looked at what happens.
18:26:25 <irene-knapp> mikeplus64: very probably, yes
18:26:44 <irene-knapp> mikeplus64: you could probably find out with -ddump-core or something
18:26:50 <mikeplus64> ok, will do
18:26:52 <mikeplus64> thanks
18:26:54 <irene-knapp> sure thing
18:27:10 <irene-knapp> I wouldn't sweat it unless measurements show it's a major cost for you though
18:27:47 <mikeplus64> yeah, it's just I feel wrong converting it at runtime :)
18:28:13 <irene-knapp> ion: I happen to know how inlining mechanisms work in GHC and I don't think it can do that in fact
18:28:31 <ion> irene-knapp: ok
18:28:44 <irene-knapp> ion: RULES pragmas are applied against Haskell, not Core
18:28:53 * irene-knapp nods
18:28:57 <irene-knapp> anyway
18:29:06 <kallisti> does the FFI care at all, internally about what the a is in Ptr a and FunPtr a? I know it provides the type checker with types.
18:29:20 <irene-knapp> not really, no
18:29:36 <irene-knapp> except on hypothetical architectures with multiple address spaces for different types of value :)
18:29:41 <ion> {-# INLINE pack #-} instance IsString Foo where { fromString = pack {-# INLINE fromString #-} } or something like that doesn’t work?
18:30:05 <kallisti> I ask because I have a C wrapper function that allows me to call a vararg function, so the type I give for it isn't technically accurate because I have no way to express that the FunPtr is to a vararg function.
18:30:16 <irene-knapp> ah, indeed
18:30:27 <irene-knapp> well, by the way
18:30:34 <irene-knapp> you probably can do without the C wrapper by cheating with castPtr
18:30:57 <irene-knapp> you would use like
18:31:24 <irene-knapp> Data.Dynamic
18:31:28 <ion> There was a Stack Overflow answer about FFI and varargs. The writer used a libffi API IIRC.
18:31:31 <kallisti> hm, maybe. it's difficult to debug my program given the way it's being run. before I was using a dynamic stub
18:31:41 <irene-knapp> libffi is ideal really
18:31:42 <irene-knapp> yeah, hm
18:32:06 <kallisti> I don't think the dynamic stub worked though
18:32:12 <ion> @google haskell libffi varargs stack overflow
18:32:13 <kallisti> libffi is a bit inefficient, so I've read.
18:32:14 <lambdabot> http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
18:32:14 <irene-knapp> hmm
18:32:14 <lambdabot> Title: Haskell FFI Support for Functions With Variadic Arguments - Stack Overflow
18:32:29 <irene-knapp> yeah, dynamic stubs are for the opposite problem actually
18:32:46 <irene-knapp> where you want to pass a Haskell function to be called from C-side but you don't know which function it will be at compile-time
18:33:14 <kallisti> it is?
18:33:20 <irene-knapp> that's what I use them for, at least?
18:33:29 <irene-knapp> maybe it can do both ways, actually, not sure
18:33:43 <kallisti> the docs suggest that "dynamic" is for making things like, FunPtr a -> a
18:33:48 <irene-knapp> wait, sorry
18:33:51 <irene-knapp> I confused myself ><
18:33:56 <kallisti> thinking of "wrapper" perhaps?
18:33:59 <irene-knapp> I am, yes
18:34:12 <irene-knapp> I hadn't realized there were two of those
18:34:40 * BMeph wants a FunPtr b with extra Fun!
18:34:53 <irene-knapp> hm
18:35:23 <kallisti> BMeph: FunPtr (FunPtr b)  -- you're welcome
18:38:14 <elliott> <kallisti> elliott: and yet having a function that checks for NULL and then does return "" instead of dereferencing removes a preventable source of errors (errors that can be difficult to debug depending on how your Haskell code is being run via C interfaces), while making no false claims to security (if properly documented)
18:38:17 <elliott> kallisti: return "", seriously?
18:38:22 <elliott> NULL is not the empty string.
18:38:26 <kallisti> elliott: that's what it should be for my purposes.
18:38:30 <elliott> that's like saying (1 `div` 0) should return 234789234
18:38:41 <elliott> kallisti: so?
18:38:50 <elliott> that's a property of your purposes, not peekCString.
18:39:01 <kallisti> note that I wasn't suggesting peekCString be modified to have that behavior
18:39:13 <kallisti> just that, with NULL being commonly used as an empty string, it would make sense to have that function as well.
18:39:22 <kallisti> well, maybe not commonly. I have no idea actually.
18:39:36 <irene-knapp> I don't know that I've ever seen it
18:39:37 <elliott> <kallisti> CString -> IO (Maybe String)  would possibly be a better function
18:39:43 <elliott> I would expect this function to never segfault.
18:39:51 <elliott> It's making a claim to handle failure in its type.
18:40:09 <elliott> Handling exactly one of the up to 2^64 or so invalid inputs is terrible.
18:40:13 <kallisti> erm, maybe if you read too far into it.
18:40:17 <elliott> Especially when checking for nullPtr is exactly as easy as using that function.
18:40:52 <irene-knapp> yes - what elliott just said is the key point for me now that I think of it.  you haven't saved anything by having this wrapper.
18:41:11 <irene-knapp> you've saved, like, twenty keystrokes per invocation?  big deal
18:41:49 <irene-knapp> please don't read this as a personal attack
18:41:55 <irene-knapp> I am merely passionate about technology, heh
18:42:12 <kallisti> I'm not. I didn't think it was too controversial of an idea, really.
18:42:17 <irene-knapp> okay, good
18:42:28 <irene-knapp> among C programmers your idea would probably go over
18:42:32 <irene-knapp> not in this community :)
18:42:53 * irene-knapp grew up as a C programmer, btw
18:43:55 <strager> Any help regarding "catching" errors in pure code?  http://hpaste.org/57259
18:44:08 <tgeeky> elliott: (serious question): If you're saying that CString -> IO (Maybe String) implies that it handles failure, isn't that sort of "taking over" Maybe for use in errors?
18:44:45 <irene-knapp> strager: import Prelude hiding (head) ; head :: [a] -> Maybe a ; head [] = Nothing ; head (a:_) = a
18:44:47 <irene-knapp> there I fixed it :D
18:44:55 <strager> ;P
18:45:07 <strager> Now run Maybe through all my code!
18:45:11 <irene-knapp> strager: I seem to say things along the lines of "sorry, not trying to be unhelpful, but..."
18:45:16 <irene-knapp> quite a lot
18:45:34 <irene-knapp> but head (and fromJust) are abominations unto my sight and yea verily I must smite them
18:45:51 <strager> I have a large set of data, and I want to sort them between passing cases and failing cases (so I can debug the failing cases better).
18:45:58 <irene-knapp> fair enough
18:46:03 <strager> head was an easy example.
18:46:08 <elliott> tgeeky: well...
18:46:10 <tgeeky> elliott: I mean to say -- if truly think of Maybe as providing a failure, then why not name them "OK" and "NOK" (not to save on typing, but just because that's what Maybe indicates)
18:46:13 <irene-knapp> well, in general, because of lazy evaluation
18:46:24 <elliott> tgeeky: no, it's not, but in that context the obvious meaning is to model failure
18:46:38 <tgeeky> elliott: why is it obvious?
18:46:56 <irene-knapp> you can't really be sure that a value isn't bottom (error or undefined, that is.  or an infinite loop.) until you have forced it, recursively
18:47:00 <elliott> I mean -- of course Maybe models failure -- that's what the Maybe monad does, that's what MaybeT does -- indeed MaybeT IO String is identical to that type, and MaybeT is isomorphic to ErrorT ()
18:47:08 <strager> irene-knapp: Yeah; I'm fine with doing that.
18:47:09 <irene-knapp> which can be done with the deepseq package but I would never organize code that way
18:47:10 <ski> @where Charity
18:47:10 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
18:47:18 <elliott> tgeeky: because there's no other use a function like peekCString could have for Nothing
18:47:19 <ski> Younder ^
18:47:29 <irene-knapp> what you actually want to do is thread Maybe through all your code, sorry =p
18:47:38 <tgeeky> elliott: what about -- it's not available in memory yet
18:47:41 <irene-knapp> next time you will be so traumatized by how much of a pain it was to do later
18:47:44 <strager> irene-knapp: This is a temporary thing to assist development =]
18:47:45 <tgeeky> elliott: that's probably not a valid one.
18:47:47 <irene-knapp> that you'll do it from the top down instinctively
18:47:51 <irene-knapp> ah - okay then
18:47:52 <elliott> tgeeky: what does that mean?
18:47:55 <irene-knapp> well, there's another option
18:47:59 <elliott> irene-knapp: you don't need to force it deeply to know it's not _|_, technically
18:48:13 <irene-knapp> which is that if you compile with profiling (which requires having compiled the entire Haskell world with profiling - all your libraries and all their recursive dependencies)
18:48:30 <tgeeky> elliott: i'm thinking about asynchronous computation, I suppose
18:48:35 <irene-knapp> you can give the RTS a special option that uses the cost-center stack to attempt to give an intuitive idea of where the exception occurs
18:48:46 <elliott> tgeeky: that doesn't seem to apply to peekCString.
18:48:54 <elliott> pointers don't come with "present yet" information
18:48:55 <irene-knapp> note that giving stack dumps in a lazy language is hard because there is no stack in the sense that there is in a strict language
18:49:00 <ByronJohnson> e\la
18:49:10 <strager> I know *where* the error occurs.  I want to sort my data sets by failing and passing cases, and print out all the failing cases with the errors.
18:49:16 <irene-knapp> oh, okay
18:49:31 <irene-knapp> sorry, I assumed you were in the more common situation of "oh my god this 2,000 lines of code is failing somewhere in it"
18:49:34 <strager> Most of them are just pattern matching failures (due to yet-to-implement features).
18:49:39 <irene-knapp> gotcha
18:49:44 <irene-knapp> okay.  then yes, use deepseq
18:49:47 <irene-knapp> @hackage deepseq
18:49:48 <lambdabot> http://hackage.haskell.org/package/deepseq
18:49:51 <irene-knapp> you will have to implement instances for your types
18:49:56 <irene-knapp> and it's not doing anything you couldn't do yourself
18:49:58 <irene-knapp> but still
18:50:09 <strager> eh =S
18:50:14 <irene-knapp> the package gives you a jump start on it
18:50:32 <irene-knapp> after deepseqing an object you can be sure it contains no bottoms, assuming the instances are correct
18:51:10 <irene-knapp> but, really, again, you should thread maybes :)
18:51:19 <elliott> surely there's some th deriving package for deepseq
18:51:19 <irene-knapp> or perhaps, hmmm
18:51:30 <irene-knapp> you could propagate the failure upwards?
18:51:33 <elliott> strager: show also works
18:51:37 <elliott> if your types have show instances including all field
18:51:38 <elliott> s
18:51:46 <elliott> you can just show it to force it deeply... ugly but it works :)
18:51:49 <irene-knapp> oh good call
18:52:07 <strager> Good idea
18:52:14 <strager> My stuff's Show all the way down.
18:52:18 <elliott> of course you must deepseq the show itself
18:52:22 <elliott> but there's already an instance for that
18:52:25 <elliott> and evaluate (length (show s)) works
18:52:57 <cmccann> making up goofy names for the operations is probably the most enjoyable thing about writing a new monad transformer
18:53:08 <elliott> :D
18:54:21 * cmccann decided that the world needed an "either or both" data type
18:54:47 <elliott> Wasn't one of them just put on Hackage?
18:54:49 <cmccann> since that doesn't factor cleanly in terms of the usual types
18:54:58 <cmccann> hm, maybe, couldn't find any last I checked
18:55:29 <strager> elliott: I'm probably not doing it right =]  I haven't done any strict evaluation before
18:55:33 <strager> >           right = C.evaluate $ (show foo `seq` Right foo)
18:55:34 <lambdabot>   <no location info>: parse error on input `='
18:55:34 <strager> Doesn't seem to change anything.
18:55:51 <strager> in http://hpaste.org/57259'
18:56:04 <elliott> cmccann: the constructors were Fst a | Snd b | IForgetThisOne a b
18:56:10 <dainanaki> I inadvertantly 'make install'ed the ghc trunk, and now it's set as the defult ghc version. How do I go about removing it and setting a standard ghc release as the default again?
18:56:22 <irene-knapp> dainanaki: er, hm :/
18:56:24 * hackagebot highlighting-kate 0.5.0.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.0.1 (JohnMacFarlane)
18:56:34 <irene-knapp> dainanaki: I personally would reinstall a standard release from scratch
18:56:44 <elliott> dainanaki: i believe you can make uninstall
18:58:19 <cmccann> elliott, can't seem to find it, oh well
18:58:28 * cmccann will stick with his own version
18:58:57 * elliott is desperately trying to find it now because i'm worried i imagined it
18:59:44 <elliott> found it
18:59:47 <elliott> cmccann:
18:59:48 <elliott> http://hackage.haskell.org/package/data-or
18:59:52 <elliott> from jan 29
19:00:10 <cmccann> aha
19:00:27 <cmccann> oh well, mine is more comprehensive so I don't feel bad
19:00:33 <cmccann> cf. https://github.com/isomorphism/these/
19:01:36 * tgeeky imagines a priest in 1354, in a small temple, chanting the words: Dictate. Confess. Momento. Absolve. ... Retcon.
19:01:47 <elliott> yay! yours has a more confusing name
19:02:06 <cmccann> haha
19:02:20 <elliott> hmm, that monad has to be useful for something
19:02:27 <elliott> although I can't for the life of me think what
19:02:32 <cmccann> yeah, same here
19:02:40 <cmccann> but it has some interesting properties
19:02:43 <elliott> perhaps... accumulating a list of errors, where you don't stop on an error? like gcc
19:02:46 <tgeeky> maybe...for the life of someone else!
19:02:50 <cmccann> that I've probably never thought of using because it didn't exist
19:02:53 <elliott> wait no
19:02:56 * tgeeky holds up elliott's puppy as hostage
19:02:57 <elliott> the monoid constraint is on the value...
19:03:06 <elliott> oh, no it isn't
19:03:14 <cmccann> yes, accumulating errors was the motivating idea
19:03:16 <elliott> right, you do This [myError], That mySucceedingResult, and they get combined :P
19:03:30 <cmccann> it's basically error + writer, after all
19:03:33 <elliott> right
19:04:06 <tgeeky> elliott: that sounds like (STDIO,STDERR)
19:04:16 <cmccann> the operations on it are basically stuff like catch-and-log-errors, clear error log, &c.
19:04:18 <tgeeky> where STDIO = STDOUT
19:05:00 <elliott> except that it stops normal computation on error output :P
19:05:41 <elliott> cmccann: hmm, actually I don't think that works for accumulating errors, because you /have/ to do all errors as These [err] dummyResult
19:05:43 <elliott> or it'll just act like Either
19:05:55 <elliott> but i suppose the monad structure doesn't let you do anything else
19:06:13 <cmccann> the idea there is that you can log minor errors and abort on major errors
19:06:49 * ski thinks applicative errors can be useful
19:09:15 <elliott> cmccann: ah
19:09:38 <cmccann> I dunno, like I said I'm not sure how useful it would end up being
19:10:23 <cmccann> but I figured that if I wrote it, I might end up using it, if the opportunity arises
19:10:25 <elliott> eagerly awaiting data More a b c = A a | B b | C c | AB a b | AC a c | BC b c | ABC a b c
19:10:41 <cmccann> heh
19:10:50 <cmccann> the name isn't that bad :P
19:11:05 <ion> elliott: Nothing is missing from that. :-P
19:11:15 <elliott> ion: no, that's the point
19:11:18 <elliott> same as These
19:11:33 <elliott> hmm, this is making me think of an Unwriter monad
19:11:40 <elliott> where instead of accumulating, you have to... discard
19:13:16 <monochrom> the Tetris monad, in which you accumulate things, but sometimes cancellation happens
19:13:26 <ion> hah
19:13:29 <cmccann> hahaha
19:13:31 <ion> and you get points
19:13:56 <elliott> :D
19:14:54 <elliott> hmm, for error accumulation, it seems like the right-only case is redundant
19:14:59 <elliott> since it's just These mempty x
19:18:23 <cmccann> elliott, perhaps, you could still distinguish between "no errors at all" and whatever mempty means
19:18:31 <cmccann> not sure if or when that would be useful
19:22:16 <elliott> cmccann: hehe
19:22:28 <elliott> $ prog
19:22:31 <elliott> 0 errors found!
19:22:34 <elliott> $ echo $? --> 1
19:25:49 <Sgeo> What would happen if I wrote import Data.Map as map?
19:25:52 <Sgeo> er, as Map
19:26:20 <Sgeo> I don't get a syntax error
19:26:42 <elliott> It imports all the names and also imports it as Map.
19:27:18 <Sgeo> Ah
19:39:31 <nyingen> @quote
19:39:31 <lambdabot> jessenoller says: [On Python:] The closest we get to "type safety" is function annotations, which make me feel funny in sensitive places.
19:40:42 <MostAwesomeDude> Heh.
19:40:57 <nyingen> Erlang too
19:41:24 <nyingen> Erlang takes type annotations pretty seriously
19:43:36 <nyingen> @quote
19:43:37 <lambdabot> <bfh6558> says: foldr.com reminds me of some horrible lisp nightmear I had a few weeks back
19:44:03 <MostAwesomeDude> @quote
19:44:04 <lambdabot> foot says: You shoot yourself in the foot very elegantly, and wonder why the whole world isn't shooting itself this way.
19:47:00 <monochrom> foot said that?
19:47:12 <nyingen> there's a joke here about space leaks and exsanguination, but it's not quite coming to me
19:54:27 <nyingen> @quote
19:54:27 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
20:19:59 <djanatyn> Hey, question. If I wanted Haskell to post a new status on Facebook, given account info, or to retrieve statuses on Facebook, what libraries would I be using?
20:20:29 <djanatyn> I used tagsoup a while ago, and that was fun, but I don't think it would be appropriate here.
20:21:21 <salisbury> djanatyn: Isn't that sort of deal under their REST api?
20:21:47 <dainanaki> a cursory examination of hackage reveals this: http://hackage.haskell.org/packages/archive/fb/0.7/doc/html/Facebook.html
20:22:34 <djanatyn> Oh, cool.
20:23:44 <djanatyn> I thought cabal downloaded a package list from hackage. if so, why doesn't "cabal list facebook" return that?
20:23:57 <dainanaki> you haven't updated cabal lately?
20:24:08 <dainanaki> you have to run 'cabal update' sometimes
20:25:01 <dainanaki> also, the package name is fb
20:25:20 <dainanaki> so you probably have to do cabal list fb
20:26:15 <djanatyn> Yeah, that's directly after running cabal update.
20:26:26 * hackagebot accelerate 0.9.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.9.0.0 (ManuelChakravarty)
20:26:39 <djanatyn> The only thing that it returns is happstack-facebook; the problem was that the package's name was "fb", which doesn't match with "facebook".
20:27:53 <dainanaki> i generally have more success searching for packages by going to the actual hackage website and searching on there since packages have descriptions too.
20:28:09 <djanatyn> As for grabbing stuff from Facebook, looks like I can get JSON from the site pretty easily: http://developers.facebook.com/docs/reference/api/
20:28:20 <djanatyn> That actually seems pretty fun to work with.
20:38:33 <Axman6> TacticalGrace: is there any Accelerate work going on for OpenCL?
20:48:26 <kallisti> what would be a good serialization/persistence library for saving a single hash table to a file?
20:48:53 <elliott> cereal
20:49:01 <elliott> or check out acid-state which uses safecopy (= cereal + migration)
20:49:08 <mjga> Axman6: check github.org for accelerate-opencl, and possibly ping the author
20:49:21 <elliott> github is a non-profit now?
20:50:43 <kallisti> elliott: is cereal in base/haskell-platform? if not, is there a good alternative that is?
20:50:45 <mjga> elliot: :-D, sorry I meant github.com
20:51:26 * hackagebot xturtle 0.0.8 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.8 (YoshikuniJujo)
20:54:16 <elliott> kallisti: No, it's not. binary might be in the HP, I don't know, but cereal is widely-used and (IMO) better.
20:54:32 <elliott> It's just a cabal install away.
20:56:20 <mjga> elliott: since binary is in HP - in what ways is cereal better?
20:57:19 <kallisti> generalized derive is nice.
20:58:04 <elliott> mjga: IIRC faster, error handling, safecopy/acid-state are built on it, binary hasn't been updated since 2009
20:58:31 <elliott> mjga: also, cereal does IEEE floats
20:58:36 <elliott> which you need a separate package for with binary
20:58:59 <elliott> and only cereal has deriving support for the new generics system, I think (through cereal-derive)
21:01:44 <mjga> btw is there any nice package to replace conventional strings with unicode-based bytestrings with Show and Read functions? I am particularly missing deriving
21:02:08 <kallisti> Text I believe
21:02:15 <kallisti> oh wait
21:03:23 <mjga> I noticed that many Text modules in HP seem to be [Char] based anyway. That's why I ask. Actually I would be pretty happy with {-# NoImplicitPrelude #-} import FastTextPrelude
21:05:51 <TacticalGrace> Axman6: yes: https://github.com/HIPERFIT/accelerate-opencl
21:05:57 <tkahn6> hey yall I'm getting: <command line>: user specified .o/.so/.DLL could not be loaded (dlopen(libpiano.dylib, 9): image not found)
21:06:20 <tkahn6> when i try to link a .so in ghci
21:06:53 <tkahn6>  ghci -L. -lpiano
21:07:16 <tkahn6> and libpiano.so is in the folder
21:13:52 <mjga> kallisti: or maybe that is a mix-up of Text.* namespace (which is often [Char] based), sorry. indeed cabal install text text-icu gives something unicodish. Didn't find any mimic for Show/Read classes though
21:16:14 <elliott> mjga: You won't find much for Unicode ByteStrings -- that's what Text is for.
21:16:20 <elliott> I _think_ there's a Text-based Show/Read somewhere.
21:16:38 <elliott> attoparsec has Text support, but...
21:17:32 <mjga> elliott: I cannot find any method with signature a -> Text with hoogle, but of course I don't know how to put constraint "for any class C, (C a) = > a -> Text"
21:23:07 <kallisti> is there a Haskell equivalent of the touch shell utility?
21:24:09 <mauke> which parts of it?
21:26:04 <kallisti> the "touch file" part
21:26:12 <mauke> which parts of it?
21:26:25 <kallisti> ...? all of that?
21:26:42 <mjga> kallisti: I have seen such code in hsshellscript, I think
21:27:08 <mauke> kallisti: why do you need all of touch?
21:27:20 <kallisti> to create a file in the event that it's not there.
21:27:37 <elliott> that's not even "all" of touch
21:27:44 <elliott> touch bumps the mtime on an existing file
21:27:48 <kallisti> yes I know.
21:28:05 <Enigmagic> it also will create a file if it's not there
21:28:18 <elliott> yes. gnu touch also processes options and even lets you pick a specific date
21:28:30 <Enigmagic> i'll let you pick a date too
21:28:35 <kallisti> ...
21:28:37 <elliott> ...and has a bunch of other options too, so it's not clear how creating a file if it doesn't exist is "all of touch" :)
21:28:39 * Enigmagic has a REST API
21:28:45 <kallisti> I said "touch file"
21:28:46 <kallisti> implying
21:28:47 <kallisti> no options
21:28:53 <kallisti> mauk said "which parts"
21:28:56 <kallisti> I said: "all of that"
21:28:59 <kallisti> sheesh
21:29:05 <mauke> kallisti: that's still two different operations
21:29:11 <kallisti> okay?
21:29:16 <kallisti> I know what touch does.
21:29:34 <mauke> so why not ask about that?
21:29:39 <Cale> open it for appending and close the handle?
21:29:45 <kallisti> yes that's what I'll do.
21:30:14 <elliott> withFile "foo" AppendMode $ \_ -> return ()
21:30:16 <kallisti> mauke: it was a simple question if a platform-independent equivalent of touch with no options existed.
21:30:24 <kallisti> but I probably don't need it, actually.
21:30:30 <mauke> exactly
21:30:44 <mauke> you never answered <mauke> kallisti: why do you need all of touch?
21:31:18 <mauke> I think 'touch' is a bad abstraction and you probably shouldn't want it
21:31:21 <kallisti> I don't
21:31:26 <kallisti> I was thinking in Perl in Haskell.
21:31:34 <kallisti> touch would be the most convenient way to get what I wanted.
21:32:16 <mauke> perl has no 'touch' either
21:32:21 <mauke> (php does)
21:33:29 <kallisti> yes, the convenient thing to do in perl would be to write `touch file`
21:33:31 <kallisti> which is not perl.
21:34:00 <mauke> wtf
21:34:08 <mauke> that's terrible code
21:34:58 <kallisti> it's also really convenient.
21:36:39 <mauke> yeah, it's a good red flag
21:36:54 <mjga> for scripting make that seems okay
21:37:00 <mjga> probably nothing else
21:37:00 <mauke> it tells you that you can't trust the author of that code
21:37:39 <mauke> system qw(touch file); would be slightly less crazy
21:37:56 <kmc> hmm, I had seen some descriptions of problems with the quality of randomness produced by System.Random
21:38:02 <kmc> but I can't find them with google now
21:38:04 <kmc> anyone have a link?
21:39:06 <mjga> kallisti: http://holumbus.fh-wedel.de/hayoo/hayoo.html says System.Posix.Files.touchFile
21:39:15 <CodeWeaver> randomInt :: Int
21:39:15 <CodeWeaver> randomInt = 4 — obtained via die roll, guaranteed random
21:39:22 <CodeWeaver> (thanks xkcd)
21:39:58 <c_wraith> wasn't there some syscall quasiquoter?
21:40:01 <mauke> mjga: the beautiful thing about that is that touchFile will fail on non-existent files
21:40:07 <kmc> kallisti, [sh| touch $x |]  -- http://hackage.haskell.org/package/shqq
21:40:15 <c_wraith> yes, that's the one I was thinking of
21:40:16 <kmc> it will even quote the variable x properly
21:40:19 <kmc> assuming i did not fuck it up
21:40:31 <c_wraith> that's a really cool quasiquoter
21:40:35 <kmc> thanks
21:40:51 <c_wraith> oh, hey, you're the author of it.  I didn't even realize :)
21:40:54 <kmc> example here: http://mainisusuallyafunction.blogspot.com/2011/10/shqq-embedding-shell-commands-in.html
21:40:58 <kmc> yep :)
21:40:59 <c_wraith> Doesn't change my opinion.  Still cool.
21:41:04 <mauke> quoting will not save you
21:41:07 <kmc> you can thank dylukes for the inspiration
21:41:10 <mauke> you need at least --
21:41:27 <c_wraith> oh, hmm.
21:41:31 <c_wraith> yes, it would need a --
21:43:19 <mjga> mauke: why don't you submit patch? it is clearly wrong implementation
21:43:31 <mauke> mjga: no, it isn't
21:44:24 <mauke> the name is "wrong" but so are most functions in System.Posix.*
21:48:53 <elliott> kmc: hmm, why do you escape rather than constructing an argument list?
21:49:28 <kmc> so that you can use shell stuff
21:49:45 <elliott> fair enough
21:50:16 <kmc> like file redirections or pipelines
21:50:22 <mzero> !
21:50:46 * mzero spent much of the last three evenings implementing redirections.....
21:52:34 <mjga> mauke: it implements "touchExistingFile", not the exact behaviour of touch command
21:53:08 <mauke> mjga: yes
21:53:28 <mauke> that's because touch(1) is broken
21:54:01 <mzero> that's kinda an odd statement
21:54:16 <mzero> it is what it is
22:00:24 <Sgeo> Are there good alternatives to unfoldr?
22:00:30 <Sgeo> I think I need an unfoldr
22:00:51 <kmc> the main alternative is "write the recursion yourself"
22:01:09 <kmc> but it would help to know what your goals are and why you're avoiding unfoldr
22:01:21 <Sgeo> I have this weird impression that unfoldr is bad
22:01:23 <elliott> Are there good alternatives to map? I think I need a map.
22:01:30 <kmc> elliott, list comprehension
22:01:30 <kmc> ;)
22:01:42 <Sgeo> And not going into details about my problem, my type is rounds :: [(Person, Person)] -> [[(Person, Person)]]
22:02:06 <elliott> perhaps people could help you better if you gave details?
22:02:15 <Sgeo> Or I could just write the unfoldr
22:02:27 <mzero> unfoldr isn't bad - it's just a functoin
22:02:30 <mzero> function
22:02:36 <elliott> (well, so is gets :p)
22:02:45 <kmc> Sgeo, i don't think unfoldr is bad, but i do have the impression that it produces clear beautiful solutions less often than, say, foldr
22:02:51 <mzero> no no, gets is an IO action!  ;-)
22:03:22 <kmc> as an aside, I liked shachaf's observation that the type of foldr could be revised to «(Maybe (a,b) -> b) -> [a] -> b» for better duality with unfoldr
22:03:38 <elliott> yeah, make foldr uglier for unfoldr's sake :P
22:04:02 <elliott> it sucks that covariant positions are much more awkward than contravariant positions for things like multiple values, in a way
22:04:04 <kmc> i wonder how to generalize that kind of foldr to arbitrary recursive data
22:04:08 <Sgeo> My accumulator will start large and get smaller, I think
22:04:23 <kmc> elliott, sounds like a job for CPS
22:04:40 <elliott> kmc: yeah... unfortunately that makes all the plumbing around it ugly :P
22:04:50 <elliott> concatenative languages can do it conveniently but, well, they're concatenative languages
22:05:13 <ddarius> kmc: Which kind of foldr?
22:05:26 <kmc> (Maybe (a,b) -> b) -> [a] -> b
22:05:34 <ddarius> kmc: That's the standard form.
22:05:45 <elliott> For some values of "standard"...
22:05:54 <ddarius> :t fold alg = In . fmap (fold alg) . alg
22:05:55 <lambdabot> parse error on input `='
22:06:05 <ddarius> :t let fold alg = In . fmap (fold alg) . alg in fold
22:06:06 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
22:06:25 <ddarius> :t let unfold coalg = coalg . fmap (unfold coalg) . out
22:06:26 <lambdabot> <no location info>:
22:06:27 <lambdabot>     not an expression: `let unfold coalg = coalg . fmap (unfold coalg) . out'
22:06:27 <kmc> yeah, you're right
22:06:30 <ddarius> :t let unfold coalg = coalg . fmap (unfold coalg) . out in unfold
22:06:30 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
22:06:37 <kmc> it is pretty close anyway
22:07:00 <elliott> ddarius: I think that's already defined.
22:07:26 * Sgeo decides that manual recursion may be less ugly for his problem
22:07:31 <ddarius> Oops, I switched the names.
22:07:38 <elliott> :t cata
22:07:38 <kmc> under the equivalence  [a] = μb. Maybe (a,b)
22:07:39 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
22:08:36 <Sgeo> n/m
22:09:28 <elliott> > cata (maybe [] (uncurry (:)))
22:09:29 <lambdabot>   Couldn't match expected type `(a, [a])' against inferred type `[a]'
22:09:43 <elliott> oh, duh
22:11:12 <ddarius> You did the same thing I did yesterday and several other times.
22:11:31 <Sgeo> Bluh
22:12:01 <Sgeo> I'm now fairly sure I can't use unfoldr, because I have to change already-written stuff as I go through the accumulator
22:12:20 <kmc> i suggest writing the recursion manually
22:12:28 <kmc> then you can stare at it and see if it fits some nice pattern
22:12:48 <kmc> it might turn out to be an unfoldr anyway
22:12:54 <kmc> if it turns out to be a zygohistomorphic prepromorphism, you're probably better off keeping the explicit recurison
22:13:15 <ddarius> It'll turn out to be a hylomorphism.
22:22:17 <kallisti> is there a way to conditionally reinstall a package, but only if a shared library doesn't exist
22:22:32 <kallisti> cabal install --enable-shared  won't install the shared library if the package is already there
22:22:36 <kallisti> so a --reinstall flag is required
22:22:49 <Sgeo> Is there an easy way to prepend an element to the first list in a list of lists that meets a criterion, or should I just write that recursion explicitly too?
22:23:29 <kallisti> Sgeo: nothing I'm familiar with sounds similar.
22:26:21 <monochrom> you have to manually determine which packages to reinstall, and in what order
22:27:01 <monochrom> or you can erase and start from scratch. that helps the dependency chasing
22:27:27 <monochrom> while you are at it, don't forget to turn on documentation and profiling
22:28:06 <elliott> kallisti: cabal install --reinstall world
22:28:27 <elliott> Since you just turned on shared libraries today, it won't waste much work.
22:28:29 <elliott> Best to be consistent.
22:28:49 <Enigmagic> by now, approximately 30x more money has been spent on power wiping and rebuilding cabal packages due to missing -prof flags than it would have cost to fix cabal-install
22:29:36 <kmc> ain't it always so
22:30:13 * Enigmagic seriously considers fixing cabal-install to not be terrible
22:33:12 <kallisti> :t either
22:33:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:36:28 <Sgeo> Uh
22:36:43 <Sgeo> I seem to have encountered an issue where || does not like being used in guards
22:37:29 <kmc> strange
22:38:33 <Sgeo> Or not
22:39:18 <Sgeo> And the answer turns out to be "not"
22:39:26 <kmc> less strange
22:39:28 <Sgeo> I had a where clause before a guard
22:39:40 <Sgeo> Saw parse error relating to |
22:39:43 <Sgeo> And was too quick to blame ||
22:40:10 <elliott> Enigmagic: please do
22:43:12 <Enigmagic> elliott: don't tempt me :P
22:43:22 <kallisti> @pl (\e -> f e >> x)
22:43:22 <lambdabot> (>> x) . f
22:43:31 <Enigmagic> i'd like to get the stack walking stuff done first though
22:54:57 <mjrosenb> Enigmagic: stack walking?
22:58:06 <bsrk> what is the meaning of type signatures like: ((* -> *) -> *) and (* -> *) ?
22:58:19 <kmc> those are kind signatures, not type signatures
22:58:29 <kmc> kinds classify types and type constructors, the way types classify expressions
22:58:38 <kmc> :k Maybe
22:58:39 <lambdabot> * -> *
22:58:42 <kmc> :k Int
22:58:43 <lambdabot> *
22:58:45 <kmc> :k ReaderT
22:58:46 <lambdabot> * -> (* -> *) -> * -> *
22:59:23 <bsrk> Thank you. Any resources I can read?
22:59:27 <kmc> something of kind * is an actual type, which can have values
22:59:41 <kmc> something of kind (s -> t) is a type constructor which takes a type [constructor] of kind s, and produces one of kind t
23:00:26 <kmc> dunno, googling "haskell kind signature" might be useful, or it might direct you towards frightening language extensions
23:00:51 <frerich2> @wiki kind
23:00:53 <ddarius> @where introduction
23:00:53 <lambdabot> http://www.haskell.org/haskellwiki/kind
23:00:53 <lambdabot> I know nothing about introduction.
23:00:57 <ddarius> @where gentle
23:00:57 <lambdabot> http://www.haskell.org/tutorial/
23:04:39 * ddarius has a desire to @where+ Gentle Yzordderrex
23:16:27 * hackagebot warp 1.0.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.0.0.1 (MichaelSnoyman)
23:16:31 <bsrk> What can possibly have a kind ((* -> *) -> *) ?
23:17:03 <kmc> a type constructor that takes another type constructor
23:17:30 <kmc> data K f = MkK (f Int)
23:17:36 <kmc> K :: (* -> *) -> *
23:18:57 <kmc> MkK [2,3] :: K []
23:19:02 <kmc> MkK (Just 4) :: K Maybe
23:19:15 <ddarius> :k Mu
23:19:16 <lambdabot> (* -> *) -> *
23:19:54 <Sgeo> Ok
23:20:01 <Sgeo> I have a list comprehension
23:20:08 <Sgeo> It works. My algorithm is correct.
23:20:26 <Sgeo> Yet. I want to mix the order up a bit, the current order that results has properties I want to avoid.
23:20:30 <Sgeo> So I want to use logict.
23:20:48 <Sgeo> Is there an easy way to convert a simple list comprehension to a LogicT?
23:21:10 <kmc> rewrite it in "do" notation
23:21:16 <ddarius> Enable MonadComprehensions, or rewrite it into the equivalent do-notation.
23:21:24 <kmc> or use ghc -XMonadComprehensions with ghc 7.2
23:21:52 <kmc> @undo [ f x |  y <- ys, x <- g y ]
23:21:52 <lambdabot> concatMap (\ y -> concatMap (\ x -> [f x]) g y) ys
23:21:55 <kmc> @. do undo [ f x |  y <- ys, x <- g y ]
23:21:55 <lambdabot> concatMap (\ y -> concatMap (\ x -> [f x]) g y) ys
23:22:08 <Sgeo> Ok. I'm drawing from lists
23:22:16 <Sgeo> How do I turn the lists I draw from into LogicT thingies?
23:22:22 <Sgeo> Or maybe I should look at the docs
23:22:27 <ddarius> @. redo undo [ f x | y <- ys, x <- g y]
23:22:27 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
23:22:32 <kmc> looking at the docs is probably a wise choice
23:23:05 <kmc> :t msum . map return
23:23:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
23:23:13 <ddarius> No one ever learned anything by reading documentation.
23:23:20 <kmc> ^^^^ will turn any list of values into a "nondeterministic choice" for any MonadPlus
23:23:27 <kallisti> @hoogle ((a,b) -> (a, m b)) -> m (a,b)
23:23:27 <lambdabot> No results found
23:23:54 <kallisti> @hoogle (a, m b) -> m (a,b)
23:23:55 <lambdabot> No results found
23:23:57 <kallisti> hm
23:24:19 <Sgeo> :t msum
23:24:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
23:24:23 <kmc> if i have an «x :: IO T» and I refer to T as its "codomain", will people want to hit me with sticks?
23:24:28 <ddarius> :t asum . fmap pure
23:24:29 <lambdabot> Not in scope: `asum'
23:24:46 <ddarius> :t Control.Applicative.asum . fmap pure
23:24:47 <lambdabot> Not in scope: `Control.Applicative.asum'
23:24:52 <kallisti> @hoogle asum
23:24:52 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
23:24:53 <ddarius> @hoogle asum
23:24:53 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
23:24:54 <kmc> :t foldr (mplus . return) mzero
23:24:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
23:25:10 <ddarius> kmc: Yes.
23:25:11 <Sgeo> @hoogle guard
23:25:11 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
23:25:11 <lambdabot> Language.Haskell.TH.Syntax data Guard
23:25:11 <lambdabot> Language.Haskell.TH data Guard
23:25:15 <kmc> ddarius, what should I call it?
23:25:50 <ddarius> kmc: I would be fine with something like "result type."  It's not a function though, so it doesn't make sense to call it the codomain.
23:26:14 <kmc> yeah, it is an abuse of notation to call it the codomain
23:27:14 <kallisti> fromList <=< mapM (\(k,v) -> fromList v >>= (k,))
23:27:19 <kallisti> is there perhaps a better combinator to use here?
23:27:56 <ddarius> (>=>) or (=<<)
23:28:12 <kmc> you really want >>= (k,) and not (fmap (k,)) ?
23:28:35 <kallisti> kmc: um, yes.
23:28:42 <kmc> ok
23:28:42 <kallisti> kmc: oh
23:28:43 <kallisti> no.
23:28:44 <kallisti> I misread.
23:28:49 <kallisti> yes I meant fmap
23:29:39 <kallisti> mapM (\(k,v) -> (k,) <$> fromList v)
23:29:50 <ddarius> (,) k
23:29:52 <Sgeo> Gah
23:29:58 <Sgeo> I just want to combine two lists in a fair way
23:29:59 <kallisti> ddarius: not a fan of TupleSections?
23:30:04 <Sgeo> That's all I want to do
23:30:19 <kmc> you mean like http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html ?
23:30:44 <Sgeo> yes
23:30:49 <kallisti> @pl (\(k,v) -> (,) k <$> fromList v)
23:30:49 <lambdabot> uncurry ((. fromList) . (<$>) . (,))
23:31:06 <Sgeo> kmc, thanks
23:33:42 <kallisti> @hoogle a -> [a] -> Bool
23:33:42 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
23:33:43 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
23:33:43 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
23:36:29 * hackagebot mime-mail-ses 0.1.0.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.1.0.1 (MichaelSnoyman)
23:44:22 <Sgeo> :t foldl
23:44:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
