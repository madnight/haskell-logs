00:00:04 <kallisti> :t join. join . liftM3 (,,)
00:00:06 <donri> @where lyah
00:00:06 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
00:00:06 <lambdabot>     Probable cause: `liftM3' is applied to too few arguments
00:00:06 <lambdabot>     In the second argument of `(.)', namely `liftM3 (,,)'
00:00:06 <lambdabot> http://www.learnyouahaskell.com/
00:00:10 <donri> you have seen this one right?
00:00:21 <NothingMan65> Yes yes, indeed.
00:00:22 <kallisti> :t join (join (liftM3 (,,)))
00:00:23 <lambdabot> forall a3 (m :: * -> *). (Monad m) => m a3 -> m (a3, a3, a3)
00:01:06 <kallisti> > join (join (liftM3 (,,))) [1..10]  -- not quite as pretty, but less repetitive with the ranges if they're all the same.
00:01:07 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
00:01:07 <ski> kallisti : related to the (often called) "Santa Paradox", "If this sentence is true, then Santa exists.", see <http://en.wikipedia.org/wiki/Curry%27s_paradox>
00:01:14 <sopvop> kallisti: I'll check it out
00:01:15 <ski> insertpseudonym : yeah, it works
00:01:38 <tikhonjelvis> kallisti: But then of course it's almost as repetitive with the joins.
00:01:44 <kallisti> heh, yes.
00:02:47 <insertpseudonym> ski: have you read Godel Escher Bach?
00:02:52 <ski> kallisti,insertpseudonym : the basic idea is the obvious idea of returning the current result, plus a boolean that says whether we're at an odd or an even index, counted from the end
00:03:13 <everyonemines> ski: I don't think of it as self-reference being invalid in logic; rather, I think of it in terms of a computation, where valid logic is something where the computation ends
00:03:28 <everyonemines> and if the computation doesn't end then you never arrive at a logical result
00:03:32 <insertpseudonym> ski: ah got it now
00:03:50 <ski> kallisti,insertpseudonym : now, instead of doing that, i wanted to separate the odd- and the even- indexed elements from each other, into two coroutines, that only in the base case know whether they'll apply `f' or `id' to their elements
00:04:04 <ski> these coroutines are constructed to interleave their elements back again
00:05:11 <ski> however, i realized that since i was doing a `foldl'-like tail-recursion, the elements in `evens' and `odds' got accumulated backwards, so instead of doing `f a : ...' i changed it to `... . (f a :)', using the `Endo'-trick idea
00:06:11 <ski> insertpseudonym : yes, i've read GEB -- i don't recall that much, though
00:07:33 <insertpseudonym> ski: your reference to the paradox reminded me of it (though it had to do with a Cretan since it dates back to Ancient Greek times I believe) ; still, cool easter egg haha
00:08:40 <ski> kallisti : i have an older paste, implementing `zipWith' using only `foldr' for looping, and matching on the two lists, that uses a similar coroutine idea (but perhaps slightly clearer)
00:09:50 <ski> if you want to, i could give the link to that (but maybe, if you're interested, you'd like to ponder the problem yourself for a while ..)
00:09:51 <kallisti> I'm likely too close to falling asleep to comprehend any of this right now.
00:10:03 <ski> heh
00:10:18 * ski has been awake too long atm, too, in fact
00:10:24 <insertpseudonym> kallisti: not in college huh?
00:10:33 <kallisti> I am actually.
00:10:45 <insertpseudonym> kallisti: ah, then you're just normal. ignore me lol
00:10:57 <tikhonjelvis> Sleep!?
00:11:07 <kallisti> recursive function newtypes are a little too much right now. sorry. :P
00:11:30 <insertpseudonym> tikhonjelvis: says the one in cali hah
00:11:35 <ski> kallisti : in case you're interested, i could elaborate on this problem later, then
00:11:42 <kallisti> yes I am.
00:12:10 <tikhonjelvis> fair enough
00:12:40 <tikhonjelvis> I have class at 4 tomorrow though—have to wake up early!
00:12:43 <insertpseudonym> ski: if you want to writeup a short explanation, I'll store your commented out code in my program file and come back to it when I've explored haskell further. It'd be a cool way to gauge progress. If it's okay with you of course.
00:13:21 <insertpseudonym> tikhonjelvis: 4 am/pm? either way sounds unbelievable hah
00:13:31 <tikhonjelvis> pm
00:13:50 <tikhonjelvis> An am class would be odd but neat.
00:14:01 <insertpseudonym> tikhonjelvis: clearly UCB knows how to schedule classes hah
00:14:16 <insertpseudonym> I can't escape crappy morning lectures
00:14:27 <kallisti> oh wait you meant church booleans earlier, right?
00:14:28 <tikhonjelvis> I had that problem last semester. No good.
00:14:49 <tikhonjelvis> Now I have nothing before 11. And Tuesdays are just awesome.
00:15:07 <kallisti> ski: ^ last thing I said
00:15:15 <ski> kallisti : no, ordinary ones (which i didn't use)
00:15:22 <kallisti> oh
00:16:02 <ski> i wanted to do something similar to the solution that would use a `Bool', flag, but i wanted to avoid having to check the flag all the time, while returning back
00:16:33 <ski> (that's the motivation for trying what i did -- that, plus that it was mind bending)
00:17:57 <ski> insertpseudonym : well, i'm not sure it's possible for me to write a short explanation now : (a) i'm very tired atm ; (b) this is an obscure/strange way of doing coroutines that i've been pondering a little on and off, and even my thoughts on it aren't that clear, yet
00:18:46 <ski> (in fact, i think this is the second example that i wrote using this idea)
00:18:51 <tikhonjelvis> ski: I've found trying to write it down *helps* clear my thoughts.
00:19:05 <insertpseudonym> ski: don't sweat it then. I'll just save the code
00:19:17 <ski> tikhonjelvis : yeah -- i just feels too tired to try, rn
00:19:56 <ski> (i've been awake about a circadian rhythm, atm)
00:20:40 <tikhonjelvis> I know how you feel. I've messed up my sleeping schedule quite a bit too recently.
00:20:52 <insertpseudonym> on a side note: anyone here use haskell in topcoder? I've never seen a top-ranked solution written in it for some reason.
00:21:15 <tikhonjelvis> Don't know about topcoder, but I have seen it used in Project Euler, for what it's worth.
00:21:25 <kallisti> ski: oh wait I can vaguely pick out the interleaving.
00:21:40 <kallisti> it's... backwards.
00:21:43 <kallisti> of course.
00:21:46 <insertpseudonym> tikhonjelvis: yea it'd make a lot of sense in proj euler
00:22:04 <tikhonjelvis> Yeah. It makes most of the early problems much too easy, actually.
00:22:38 <ski> kallisti : i suppose a good exercise would be to actually try to write the `Bool'-based version i was referring to ..
00:22:40 <tikhonjelvis> A one-line solution in the repl just doesn't feel right, even if it works.
00:22:57 <ski> (and hopefully try to make it correspond as close as possible to this one)
00:23:23 <insertpseudonym> tikhonjelvis: it's always a balance between elegance and magic I think. I hate things that are too "magical"
00:23:59 <tikhonjelvis> I suspect magic is a function of experience more than anything else.
00:24:38 <startling> i don't know. in python, people avoid metaclass black magic on principle.
00:25:07 <tikhonjelvis> Eh, I don't much like Python. Name-mangling *is* magic.
00:25:11 <tikhonjelvis> unholy magic
00:25:16 <startling> though perhaps magic in that sense is "things that don't work like the rest of python"
00:25:17 <insertpseudonym> tikhonjelvis: depends who you ask. We had Douglas Crockford over here for a talk and he has very finely honed opinions on the matter lol. Great speaker.
00:25:26 <donri> name mangling isn't magic, it's broken
00:25:28 <tikhonjelvis> Yes, he is very opinionated.
00:25:44 <tikhonjelvis> But then Brendan Eich disagrees with him on a bunch of things (like semi-colon insertion).
00:25:52 <tikhonjelvis> I don't think he sees it as magical.
00:25:56 <merijn> semi-colon insertion seems such a dumb thing
00:26:02 <kallisti> ski: I see how it works in principle but when I try to trace the precise steps I tend to get lost. :P
00:26:03 <insertpseudonym> tikhonjelvis: ah the semi-colons! lol'ing just recalling that talk now
00:26:09 <merijn> Either leave the things out of the grammar or force them to be written...
00:26:25 <kallisti> ski: the logic comes from swapping evens and odds
00:26:31 <kallisti> ski: with each call of loop
00:26:31 <merijn> Why put them in the grammar when you're just going to magically insert them while parsing?
00:26:36 <koala_man> how can you write enumerators that do sql queries? is Database.Enumerator the way to go?
00:26:53 <ski> kallisti : yeah, that's the basic thing
00:27:02 <insertpseudonym> merijn: JS can screw you hard in places if you omit them. I forget what the edge case was.
00:27:11 <tikhonjelvis> Here's the post I was thinking of: http://brendaneich.com/2010/11/paren-free/
00:27:22 <merijn> insertpseudonym: That's not an argument for semicolon insertion
00:27:31 <merijn> insertpseudonym: That's an argument for a less stupid grammar
00:27:57 <tikhonjelvis> Yeah, I don't actually like it either. My point is that some people manage fine even if I don't :)
00:28:10 <tikhonjelvis> In this case he might be the only person who does though.
00:28:43 <insertpseudonym> merijn: preaching to the choir (and Donald Crockford, ironically)
00:28:53 <tikhonjelvis> I'm working on a silly little scripting langauge and couldn't figure out how to leave out semi-colons without making whitespace significant.
00:29:11 <ski> kallisti : similar to the swapping in e.g. `infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys = ys; (x:xs) /\/ ys = x : ys /\/ xs'
00:29:37 <insertpseudonym> tikhonjelvis: newline?
00:29:43 <GreaseMonkey> tikhonjelvis: ...is that some mishmash of js and python?!
00:29:47 <GreaseMonkey> (the link)
00:29:57 <tikhonjelvis> That's what he wants for future versions of JS.
00:30:12 <ski> or `keepHalve [] = []; keepHalve (x:xs) = x : dropHalve xs; dropHalve [] = []; dropHalve (_:xs) = keepHalve xs'
00:30:13 <tikhonjelvis> There are plenty of times when you want a newline in a normal expression.
00:30:28 <tikhonjelvis> Guessing when you don't is too difficult; always enforcing it as a terminator is too constricting.
00:30:29 <merijn> tikhonjelvis: And the problem is?
00:30:55 <merijn> Python ignores whitespace inside expressions...
00:31:06 <tikhonjelvis> Erm, I mean, how do I figure out when an expression ends?
00:31:08 <merijn> i.e. inside lists, parenthesis
00:31:18 <tikhonjelvis> Oh, in my language, *everything* is an expression.
00:31:28 <tikhonjelvis> Unlike, say, Python. Or JavaScript.
00:31:41 <insertpseudonym> tikhonjelvis: dug your own grave there lol
00:31:56 <tikhonjelvis> Semicolons aren't that bad, and they give you flexibility in indentation.
00:32:17 <kallisti> tikhonjelvis: are expressions expressions, even?  (help what am I saying I'm going to sleep now)
00:32:17 <insertpseudonym> I'm so used to it, I don't even care really
00:32:19 <merijn> tikhonjelvis: "They aren't bad, for example, they let you do this bad things"
00:32:32 <merijn> tikhonjelvis: Ignore whitespace inside delimited expressions (i.e. parentheses, lists, etc) treat it as a terminator anywhere else, unless prefixed by a \
00:32:33 <tikhonjelvis> You don't like flexibility?
00:32:44 <merijn> Indentation should be consistent
00:32:46 <tikhonjelvis> merijn: Escaping newlines!?
00:32:50 <tikhonjelvis> ah
00:33:01 <tikhonjelvis> See, in my language, functions can just as easily be control structures.
00:33:03 <merijn> flexibility runs counter to consistency
00:33:11 <tikhonjelvis> So the indentation of a loop would be different from that of a normal functions.
00:33:20 <merijn> I have *never* wished for more flexibility while writing pythong
00:33:22 <tikhonjelvis> And yet they're both "normal" functions.
00:33:39 <merijn> On the other hand, I have wished for enforced indentation millions of times in C and Java
00:33:39 <insertpseudonym> python's indentation shouldn't have been such a big deal...too many sloppy coders out there is the real problem
00:33:43 <tikhonjelvis> I have. And I don't write much Python. (For that reason, probably.)
00:33:51 <merijn> Especially when reading other people's code
00:33:54 <kallisti> I frequently wish I was programming in perl when I progra in Python. :>
00:33:56 <tikhonjelvis> Oh, the indentation isn't the biggest issue. Except sometimes.
00:34:03 <tikhonjelvis> Heh, Perl is fun.
00:34:06 <donri> guys, dangling else
00:34:17 <tikhonjelvis> Like sometimes I want to comment out the try/catch bit.
00:34:31 <tikhonjelvis> Or maybe have my if statements line up :)
00:34:40 <merijn> tikhonjelvis: Can you name one example? (Not being flippant, I've honestly never encountered such a scenario and wanna see if I know a solution)
00:34:41 <tikhonjelvis> Or draw ascii art with my code.
00:34:54 <tikhonjelvis> Well, the first two I've done in JavaScript.
00:35:10 <tikhonjelvis> The last one I've seen in Perl.
00:35:12 <everyonemines> I use multi-line expressions all the time
00:35:16 <donri> http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python
00:35:22 <merijn> tikhonjelvis: Just change the catch to not catch anything?
00:35:32 <everyonemines> like, function \n argument \n argument
00:35:33 <kallisti> there is a CPAN package that automatically transform any program into ASCII art.
00:35:37 <kallisti> +can
00:35:39 * hackagebot hxt 9.2.0 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.2.0 (UweSchmidt)
00:36:16 <tikhonjelvis> I have a neat Perl script that draws an ascii fractal and looks like √-1.
00:36:24 <tikhonjelvis> I forgot where I found it though.
00:36:41 <tikhonjelvis> But yeah, I have also had cases where it's something like:
00:36:46 <tikhonjelvis> if (a) return blarg
00:36:53 <tikhonjelvis> else if (b) return other_blarg
00:37:03 <tikhonjelvis> else return something_else
00:37:10 <merijn> tikhonjelvis: "if a: return b" is valid python
00:37:59 <ski> kallisti : good night. going to sleep ..
00:38:03 <tikhonjelvis> night
00:38:28 <kallisti> the whitespace rules in Python aren't too bad however I have had situations where I want to break up an expression a certain way but can't without either forcing extraneous parentheses or breaking it along an expression I didn't want to break it along.
00:38:37 <kallisti> but most of the time it doesn't matter.
00:38:52 <tikhonjelvis> Yeah, most of the time I haven't had issues with Python indentation either.
00:38:59 <merijn> kallisti: For an expression that big the outer parenthesis are hardly an issue
00:39:04 <tikhonjelvis> But that's at least partly a product of Python.
00:41:27 <harlekin> Is yi still used or maintained?
00:42:05 <donri> last commit in november 24
00:42:53 <harlekin> donri: not on the google codes page. Is there a more up to date repository I don't know of? :)
00:43:04 <donri> https://github.com/yi-editor/yi
00:43:08 <harlekin> donri: thanks!
00:43:13 <donri> np
00:43:19 <tikhonjelvis> Does anybody here use it?
00:45:35 <insertpseudonym> why does trying to cat a 0 to a list fail?
00:45:48 <insertpseudonym> haven't read anything about that anywhere yet
00:46:08 <donri> insertpseudonym: using ++?
00:46:16 <insertpseudonym> :
00:46:21 <tikhonjelvis> 0:[]
00:46:24 <tikhonjelvis> > 0:[]
00:46:25 <lambdabot>   [0]
00:46:33 <tikhonjelvis>  > 1:[0]
00:46:38 <tikhonjelvis> > 1:[0]
00:46:39 <lambdabot>   [1,0]
00:46:50 <insertpseudonym> oh and my bad meant cons
00:47:00 <insertpseudonym> that's odd that it works there...
00:47:30 <insertpseudonym> 1 : 5*0 : 1
00:47:33 <insertpseudonym> oops
00:47:39 <insertpseudonym> > 1 : 5*0 : 1
00:47:40 <lambdabot>   No instance for (GHC.Num.Num [t])
00:47:40 <lambdabot>    arising from a use of `e_11501' at <in...
00:47:57 <insertpseudonym> > 1:(5*0):1
00:47:58 <lambdabot>   No instance for (GHC.Num.Num [t])
00:47:58 <lambdabot>    arising from a use of `e_11501' at <in...
00:47:59 <nicoo> insertpseudonym: You need a list after cons
00:48:02 <harlekin> > 1: 5*0:[1]
00:48:03 <merijn> insertpseudonym: Last item isn't a list
00:48:03 <lambdabot>   [1,0,1]
00:48:07 <donri> > 1:(5*0):1:[]
00:48:08 <lambdabot>   [1,0,1]
00:48:23 <insertpseudonym> it's zs in my recursive declaration
00:48:29 <insertpseudonym> messed up on here
00:48:32 <tikhonjelvis> insertpseudonym: Have you ever played around with any type of Lisp?
00:48:40 <donri> observe the associativity
00:48:57 <insertpseudonym> tikhonjelvis: no actually
00:49:00 <silver> hey guys, consider following situation: I've got a pure algorithm (tree/graph walk for example) and I want to output it's progress, how can I do this kind of things in haskell? Do I have to modify my pure code to use monads? Or there are other ways?
00:49:00 <donri> it's (x:(y:z))
00:49:11 <donri> not ((x:y):z)
00:49:19 <tikhonjelvis> Ah. It's just that list questions like that were very common when I took a class in Scheme.
00:49:32 <tikhonjelvis> You should play around with one, probably Scheme.
00:49:36 <quicksilver> silver: I think that's an excellent question and I don't have a good answer :(
00:49:54 <tikhonjelvis> I think something like Debug.Trace.trace might work.
00:50:06 <silver> sounds hackish
00:50:18 <tikhonjelvis> Well, do you want this for debugging or for something else?
00:50:23 <insertpseudonym> tikhonjelvis: honestly, I haven't forayed too far beyond standard procedural/OOP langs until now. It's fun, but frustrating at this time of night haha.
00:50:23 <donri> silver: is it for debugging or actual code?
00:50:31 <silver> no, for logic of applications actually
00:50:44 <tikhonjelvis> In that case you should consider rewriting your code a bit.
00:50:47 <donri> silver: in latter case, perhaps try the writer monad
00:50:53 <silver> awww
00:50:55 <tikhonjelvis> insertpseudonym: Scheme is very multi-paradigm. Fun too.
00:50:58 <silver> ok, thanks
00:51:26 <tikhonjelvis> It's also surprisingly different from Haskell.
00:51:37 <insertpseudonym> tikhonjelvis: next one I will probably tackle is Scala I think
00:51:47 <tikhonjelvis> Scala is much more like Haskell than Scheme.
00:51:58 <donri> scala is kind of non-interesting
00:52:05 <tikhonjelvis> I'm also thinking of learning Scala, but mostly because one of my friends really likes it.
00:52:12 <insertpseudonym> does Scheme support embedding?
00:52:18 <tikhonjelvis> In a perfect world, I'd get him to learn Haskell instead :)
00:52:25 <tikhonjelvis> Embedding? How exactly?
00:52:35 <donri> probably mean like lua
00:52:44 <tikhonjelvis> I don't see why not, but I'm no expert.
00:52:52 <tikhonjelvis> It's an exceedingly simple language.
00:52:58 <tikhonjelvis> The GIMP uses it for scripting.
00:53:35 <tikhonjelvis> Also, Guile is a variant of Scheme and the offical scripting language of GNU. Or something like that.
00:56:01 <insertpseudonym> cool; reading up on it now. Too many languages/concepts/paradigms, so little time.
00:56:42 <merijn> insertpseudonym: I know how you feel :p
00:56:58 <merijn> My current list of languages to learn is at least 9 long :p
00:57:02 <tikhonjelvis> Scala doesn't have as much in the way of new concepts relative to Haskell as Scheme, I think.
00:57:11 <tikhonjelvis> You should also play around with Prolog or its ilk.
00:57:24 <donri> jump straight at agda
00:57:42 <tikhonjelvis> The real fun is writing your own.
00:58:09 <atomicity> merijn: your list of languages needs to change into a priority queue :)
00:58:19 <merijn> atomicity: :p
00:58:28 <merijn> Yeah, but I dunno which to put first :p
00:58:49 <insertpseudonym> tikhonjelvis: enjoy it while you have the time haha! I'm taking haskell for fun this semester, but the real action is happening in other courses.
00:58:50 <atomicity> merijn: so you don't know the solution to my problem either... (yeah, same here)
00:59:20 <tikhonjelvis> I'm taking the perfect courses for languages: theory of computation and pl/compilers.
00:59:29 <atomicity> although I've pretty much settled on haskell
00:59:56 <merijn> atomicity: What's the rest of your list then?
01:00:03 <atomicity> I need a functional programming language in my toolbox and brain capability, and starting with the most hard-core seems like a good idea
01:00:15 <insertpseudonym> tikhonjelvis: props on going for compilers. They actually removed it from our curriculum and we all got lazy (plus the prof for the subject blows).
01:00:24 <tikhonjelvis> Ah.
01:00:27 <tikhonjelvis> Unfortunate
01:00:47 <tikhonjelvis> Our class is as much about designing programming languages as implementing compilers.
01:01:03 <insertpseudonym> yea, it's hard to justify the incredible workload when it's not a required course I guess
01:01:07 <merijn> insertpseudonym: Same here, went to a different university just to do the compiler course (fairly small course, but we covered the basics and did implement a minimal compiler)
01:01:07 <tikhonjelvis> Luckily I can always take a compiler optimization course later. For some reason, I've always found that interesting.
01:01:28 <atomicity> javascript (eeww, but useful), C++ (i'm quite good at it but template metaprogramming is *hard*), lisp (putting off indefinitely), dart (might be a nice replacement for javascript), lua (will probably need it soon), erlang (another programming paradigm that seems to make sense)
01:01:40 <tikhonjelvis> Meh, I'd go for JavaScript over Dart any day.
01:01:45 <tikhonjelvis> JavaScript is grossly underapreciated.
01:01:55 <atomicity> it's a very very ugly language
01:01:55 <tikhonjelvis> I'd add prolog to that list.
01:02:03 <path[l]> why? we know nothing about dart yet
01:02:04 <tikhonjelvis> It's elegant with some warts.
01:02:05 <merijn> atomicity: JS is on my list "meh, I'll pick it up when I need it"
01:02:06 <atomicity> oh, yeah, prolog definitely
01:02:11 <merijn> Dart seems completely redundant
01:02:13 <insertpseudonym> most the web is scripted in JS? hardly underappreciated
01:02:17 <tikhonjelvis> I've been following some of the development blogs and stuff.
01:02:25 <path[l]> and javascript annoys me greatly with its lack of a proper hash object. And the annoying way in which "this" behaves
01:02:37 <tikhonjelvis> It's just dynamically scoped.
01:02:45 <path[l]> it's still annoying
01:02:46 <tikhonjelvis> I've thought about it, and there isn't any easy way to change how it behaves.
01:02:53 <atomicity> merijn: JS can't be on 'pick it up when you need it', it's a very sneaky language
01:02:53 <path[l]> its rarely what people need
01:03:11 <merijn> atomicity: My current list: Agda, Racket (token Lisp), Forth, J, Io, Erlang, Chapel and Clojure (because one lisp isn't enough! :p)
01:03:15 <tikhonjelvis> You can do stuff like random.method = otherObj.method, and it should work.
01:03:23 <atomicity> merijn: this isn't to say that I haven't used it successfully, just that I don't know the ins and outs and can't really say I'm proficient.
01:03:24 <path[l]> besides the standard library of js is poor. I find myself having to write for loops for simple things, or introduce a library for  small things
01:03:26 <tikhonjelvis> Heh, I want to learn J soonish too.
01:03:43 <tikhonjelvis> Yeah. Underscore.js and newer engines fix that though.
01:03:44 <path[l]> so while I use js a lot, I use it while fervently wishing it was another language
01:03:45 <merijn> atomicity: You can learn the ins and outs while working the basics...
01:03:47 <atomicity> forgot about Clojure
01:04:00 <atomicity> merijn: JS seems like a hardcore production language to me
01:04:01 <tikhonjelvis> I'd go for Scheme (or Racket) over Clojure, but that's just me.
01:04:02 <merijn> Most people don't use every detail of every language anyway
01:04:20 <merijn> tikhonjelvis: Racket has my preference over Clojure, yeah
01:04:20 <NothingMan65> Is there a way to "break" in a list comprehension conditional?
01:04:25 <atomicity> merijn: it's not like haskell in that I would use it if I had an alternative
01:04:36 <path[l]> Im just saying maybe dart if it becomes popular will get rid of all these annoyances
01:04:42 <atomicity> NothingMan65: lists are lazy, you don't have to?
01:04:47 <tikhonjelvis> I think ES6 is going to be great.
01:04:57 <merijn> tikhonjelvis: But Clojure might have a nice purpose as "ok language that you can sneak into Java businesses"
01:05:14 <tikhonjelvis> merijn: Check out Gosu. It's basically Java fixed up to be useable.
01:05:16 <merijn> NothingMan65: Use "takeWhile" or something similar?
01:05:23 <tikhonjelvis> Much easier to sneak into production than Clojure, I suspect.
01:05:27 <donri> merijn: just tell your bosses it's XML
01:05:31 <merijn> tikhonjelvis: Isn't that called python?
01:05:34 <atomicity> hahaha
01:05:40 <atomicity> donri
01:05:48 <merijn> tikhonjelvis: The point of Clojure is that since it's JVM it can call existing Java code
01:05:49 <atomicity> thankfully, my bosses have a brain cell
01:05:59 <tikhonjelvis> merijn: Gosu does that too.
01:06:03 <merijn> ah, right
01:06:13 <tikhonjelvis> merijn: The whole point of Gosu is to be a drop-in Java replacement.
01:06:20 <NothingMan65> Hmmm
01:06:20 <merijn> atomicity: Well, technically, sexpr aren't that different from XML
01:06:22 <tikhonjelvis> It was most of the way there when I used it.
01:06:39 <atomicity> merijn: technically, xml is a markup language
01:06:46 <tikhonjelvis> Unlike Scala and Clojure, it won't scare off the weak of heart.
01:06:56 <donri> can't take credit; from http://www.paulgraham.com/icad.html
01:07:09 <donri> "If you want to trick a pointy-haired boss into letting you write software in Lisp, you could try telling him it's XML."
01:07:24 <merijn> NothingMan65: List expressions don't actually generate a list until they're used, and even then they only generate the part that is necessary. (If you know python you can think of them as generators)
01:07:33 <donri> @where ops
01:07:34 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:07:36 <donri> ADildeaux is back
01:08:08 <atomicity> indeed. I was having trouble deciding whether it's a troll.
01:08:14 <Cale> wat
01:08:17 <Cale> wat do
01:08:21 <donri> ban
01:08:36 <Cale> oic
01:08:40 <donri> ^_^
01:08:46 --- mode: ChanServ set +o Cale
01:08:51 --- mode: Cale set +b *!*@ip72-207-18-160.sd.sd.cox.net
01:08:51 --- kick: ADildeaux was kicked by Cale (ADildeaux)
01:08:52 <donri> he's spreading racist propaganda in pm
01:08:56 --- mode: Cale set -o Cale
01:09:05 <Cale> yeah, I got that just after I asked
01:09:23 <tikhonjelvis> insertpseudonym: Have you ever done any really low-level stuff?
01:09:51 <merijn> Low level stuff is fun!
01:10:03 <tikhonjelvis> Depends on how low-level.
01:10:09 <merijn> And by fun, I mean: About as enjoyable as poking forks into your eye sockets!
01:10:17 <tikhonjelvis> I'm technically an EECS major, so I have to go all the way to the bottom...
01:10:30 <tikhonjelvis> Procrastinating that. A lot.
01:10:53 <merijn> tikhonjelvis: I've got a nice example of low level fun bugs.
01:10:56 <tikhonjelvis> But assembly (which is actually pretty high-level :)) is actually fun.
01:10:58 <tikhonjelvis> ish
01:11:03 <atomicity> I guess I must have really high tolerance for these things - "are you sick of A but can't joing (group A haters) because you are in group A?"
01:11:08 <atomicity> I loled
01:11:34 <donri> poe's law
01:11:36 <tikhonjelvis> merijn: I've heard a bunch of horror stories from electrical engineers :) I'm sure yours will inspire me to procrastinate even more.
01:11:43 <donri> either way, ban worthy
01:11:51 <atomicity> yes, of course.
01:13:01 <merijn> tikhonjelvis: Not quite on the ASM level yet, but using memory mapped IO and mmap to do systems stuff under linux: Was testing my code and it worked fine until I increased the input past a certain size, in which case it would hang the processor
01:13:19 <merijn> Try debugging that, can't inspect state when your core is stuck >.>
01:13:33 <tikhonjelvis> heh, sounds fun
01:13:37 <atomicity> tikhonjelvis: tell me that when you are stuck writing multithreading support for a motorola chip that has 20k RAM and your allocator is a bunch of #define's .
01:13:51 <merijn> Turns out...APIC is mapped in the 0xFE address space, even though the extended architecture specs explicitly stated that the memory was free
01:14:09 <merijn> So if my input was big enough I would accidentally write data to the APIC, triggering a HALT >.>
01:14:15 <koala_man> I'm reading http://hackage.haskell.org/packages/archive/Takusen/0.8.6/doc/html/Database-Enumerator.html , but I'm wondering about doQuery in the example. this is an enumerator? is there some reason why it takes an iteratee as an argument instead of using >>> or .| or $$ or any of the other composition functions seen in other enumerator libs?
01:14:25 <merijn> Only 4-5 weeks down the drain for that one >.>
01:15:06 <hpaste_> “Ertugrul Söylemez” pasted “Chinese remainder theorem implementation” at http://hpaste.org/56912
01:15:23 <atomicity> in the end, "multithreading" was a bunch of case statements bound together with prayer individual callbacks won't write over eachother's memory.
01:16:59 <tikhonjelvis> Still, there is some perverse in writing programs directly in assembly.
01:17:06 <quicksilver> (design by prayer)++
01:17:21 <tikhonjelvis> some perverse pleasure**
01:17:21 <atomicity> tikhonjelvis: indeed :) I did feel like a god while doing it
01:17:38 <merijn> atomicity: Really? I mostly feel stupid
01:17:50 <tikhonjelvis> Of course, taking up several pages for a trivial one-liner does start to annoy pretty quickly.
01:17:56 <merijn> The current race condition counter is at 7 and the deadlock counter at 5 on my current project
01:18:33 <tikhonjelvis> What is using JVM bytecode like?
01:18:47 <tikhonjelvis> I've been meaning to play aronud with that if I get some time in the future.
01:18:52 <atomicity> merijn: oh, the point was that I could write "the stack is from #define BEGIN_STACK 0xfe800 downwards" and everyone had to play ball.
01:18:56 <insertpseudonym> tikhonjelvis: I have actually. Wrote an LC3 compiler for a course last year. Nasty business. A full week of near all-nighters haha. My interests lie more in the realm of distributed systems, machine learning, and algorithms.
01:19:25 <merijn> insertpseudonym: Same here
01:19:40 <merijn> I need to find a place where they do distributed systems research using haskell...
01:19:43 <tikhonjelvis> I want to write a compiler to target the JVM at some point.
01:19:43 <insertpseudonym> tikhonjelvis: which is why I never find time to pickup the more obscure languages lol. There's always something cool to read about in one of those subjects.
01:19:53 <tikhonjelvis> Fair enough.
01:19:57 <tikhonjelvis> I just really like languages :)
01:20:03 <atomicity> tikhonjelvis: interesting. Distributed systems are awesome for me (my batchelor's was in pi-calculus), but I never found machine learning fun.
01:20:12 <tikhonjelvis> It seems everybody at Berkeley is obsessed with distributed systems and parallelization though.
01:20:30 <tikhonjelvis> Even the programming languages guy.
01:20:31 <insertpseudonym> they're definitely trending subjects
01:20:48 <atomicity> tikhonjelvis: you're at berkeley? I enrolled this year, I hope I get in.
01:20:58 <tikhonjelvis> yeah
01:21:17 <frerich2> Is there a good Haskell code review forum? I'm close to finishing my next (the biggest!) Haskell project, a command-line IRC client. I'd really love to get some thoughts by more experienced people once I brought the source code into shape.
01:21:32 <insertpseudonym> tikhonjelvis: you sound like you'll end up doing your phd
01:21:37 <merijn> tikhonjelvis: Any cool distributed systems research projects at Berkeley?
01:21:47 <tikhonjelvis> Actually, the way things are going, I'm probably going to go work at a startup...
01:21:52 <donri> frerich2: put it on github and post to the community (here, mail lists, reddit)
01:22:11 <tikhonjelvis> merijn: Don't know of any particular projects.
01:22:15 <tikhonjelvis> My friend is working on Spark
01:22:24 <tikhonjelvis> I gather it's a distributed computing framework for Scala.
01:22:46 <frerich2> donri: Ok, thanks.
01:22:48 <tikhonjelvis> But I'm not sure it's particularly interesting.
01:22:49 <Peaker> if there were a good Haskell port to the JVM, would it make Scala obsolete?
01:22:53 <tikhonjelvis> No
01:23:05 <tikhonjelvis> Scala fills a very particular niche between Java and functional programming.
01:23:22 <quicksilver> there have been forty-six separate ports of haskell to the JVM
01:23:24 <insertpseudonym> merijn: Carlos Guestrin from Mellon is coming to speak at Penn tomorrow about Graphlab, dunno if you've heard of it
01:23:29 <quicksilver> none of them was ever used more than twice.
01:23:37 <Peaker> tikhonjelvis: it seems so much more complicated than Haskell, and the only noticeable gain is that it supersets Java -- which I am not sure is a gain at all
01:23:39 <quicksilver> the evidence speaks volumes.
01:24:00 <merijn> insertpseudonym: Nope
01:24:03 <tikhonjelvis> Peaker: I think the transition from Java is much easier.
01:24:23 <insertpseudonym> merijn: neither had I...but it sounds very interesting. You should look into it if you get time.
01:24:24 <Peaker> tikhonjelvis: Sure, if you keep writing Java in Scala? :)
01:24:33 <skchrko> Peaker, Scala has almost direct interoperobality with Java. It is designed that way. Haskell was not designed with that goal in mind :)
01:24:34 <Peaker> http://apocalisp.wordpress.com/2010/04/21/a-proper-constant-function-in-scala/ <-- Scala horror story :)
01:24:39 <tikhonjelvis> If you're an enterprise, that might actually make sense...
01:24:44 <tikhonjelvis> Enterprises are weird places.
01:25:03 <atomicity> is there a straigthtforward way of judging the performance of haskell code? Yesterday, I had this unfortunate "incident" that I changed a few characters and all of the sudden I ran out of RAM when testing, where RAM was barely used before.
01:25:06 <merijn> insertpseudonym: Well, I just finished my master project, so I have to investigate stuff like that to see where I need to get my phd applications rejected :p
01:25:33 <tikhonjelvis> I'm still an undergrad, so I haven't been paying much attention to this stuff.
01:26:05 <insertpseudonym> merijn: ahahaha more power to you. I'm finishing my BS/MS in 4.5 years and then I'm done. Don't have the stomach for phd-candidate life.
01:26:26 <tikhonjelvis> I suspect I'm not even going to get a Masters.
01:26:44 <insertpseudonym> tikhonjelvis: does UCB let you start the coursework as an undergrad? That's what I'm doing here.
01:26:49 <tikhonjelvis> yeah
01:26:53 <insertpseudonym> tikhonjelvis: grad courses are also several times more interesting btw
01:26:57 <tikhonjelvis> I'll take a bunch of grad courses no matter what.
01:27:17 <tikhonjelvis> I am considering doing the compiler optimization course next semester.
01:27:38 <atomicity> tikhonjelvis: skip that, start working on polly
01:27:42 <tikhonjelvis> So I might do the 5-year program.
01:27:47 <atomicity> you'll learn more and contribute to the world :)
01:27:55 <insertpseudonym> tikhonjelvis: that's hardcore content
01:27:58 <tikhonjelvis> polly?
01:28:09 <atomicity> a polyhedral optimizer for llvm
01:28:10 <insertpseudonym> the trouble with those courses is that you never know if you'll actually find a use for it (probably won't)
01:28:11 <merijn> And that was my client dying
01:28:12 <tikhonjelvis> There's also a really cool graduate language design course.
01:28:23 <tikhonjelvis> The problem is I don't know enough yet
01:28:34 <tikhonjelvis> Eh, I figure compiler optimization is a good hobby :)
01:28:50 <merijn> The one tip I can give that I wish I'd had is: "Don't think, I'm just an undergrad so I don't have to worry about this"
01:28:51 <atomicity> yeah, it is.
01:29:01 <insertpseudonym> tikhonjelvis: haha true enough. don't listen to me - I'm getting more cynical as I get closer to employed life
01:29:06 <merijn> You need to make friends with 1 or 2 profs so you can bug them for a letter of recommendation later
01:29:14 <tikhonjelvis> If I want to go to grad school?
01:29:28 <merijn> Well, can't hurt for job hunting either :p
01:29:32 <tikhonjelvis> yeah
01:29:38 <tikhonjelvis> Well, I'm going to start doing research next year.
01:29:44 <atomicity> where I live, jobs find you if you're any good
01:30:00 <insertpseudonym> thankfully, I got admitted w/o having to go through all that; took the easy way out deciding to stay here another semester I guess = P
01:30:08 <tikhonjelvis> I just want to finish off a semester working at the startup I was at last semester.
01:30:22 <atomicity> what do you guys do?
01:30:37 <tikhonjelvis> Umm, it's software to help small businesses manage daily deal promotions.
01:30:39 <merijn> I find myself in the unlucky position of not having any professors that remember me from class, because most interesting classes in which I was very active were a long time ago
01:30:45 <tikhonjelvis> And by "small business" I mean restaurant.
01:30:56 <merijn> As a result I have too few people to bug for recommendations :p
01:31:14 <luite> do they really not remember you, even if you talk to them?
01:31:14 <tikhonjelvis> merijn: Luckily my programming language professor seems nice.
01:32:14 <merijn> luite: The most relevant ones were 4 years ago
01:32:19 <insertpseudonym> I have never developed a rapport with any of mine = ( except my algo prof, but there were too many geniuses overshadowing me in that one haha
01:32:20 <tikhonjelvis> Getting to know some VCs would be nice too, I imagine.
01:32:30 <merijn> Took a 1.5 year working sabbatical/midcollege crisis :p
01:32:58 <merijn> And my master has a lot of practical work with not much interaction with professors
01:33:59 <insertpseudonym> merijn: do you really want to go into the research side of things? My goal has always been to learn the upper level content and then build software with it.
01:34:01 <merijn> By now I know the supervisors of my master project and literature study quite well, but that's two and most places seem to want three letters of recommendation :p
01:34:30 <tikhonjelvis> insertpseudonym: I don't think there's nearly as big a divide as you think.
01:34:43 <merijn> insertpseudonym: I want to build software, but most of the stuff I want to build at a scale/difficulty that it mostly happens in research organisations
01:35:19 <tikhonjelvis> Some startups I've talked to also have projects like that.
01:35:26 <tikhonjelvis> They're the ones full of phds...
01:35:32 <merijn> If you want to do research in the business world you'll likely still need a phd
01:35:36 <merijn> Also, I like teaching
01:35:40 * hackagebot fb 0.6.0.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.6.0.2 (FelipeLessa)
01:35:49 <tikhonjelvis> Ooh, teaching is good.
01:35:57 <merijn> Meh, most startups seem to be doing web 2.0/social media BS
01:36:09 <insertpseudonym> yea
01:36:13 <insertpseudonym> very sad actually
01:36:13 <tikhonjelvis> There are actually several professors here who exclusively focus on CS education.
01:36:21 <tikhonjelvis> Hmm, that depends on where you look.
01:36:26 <insertpseudonym> my biggest fear is ending up with a BS project/job
01:36:43 <yezariaely> insertpseudonym: facebook plugin :D
01:36:54 <merijn> Game programming seems fun, but I don't have any actual experience and the hours can be pretty awful unless you work at a place like Valve (which is non-trivial to get into :p)
01:36:57 <tikhonjelvis> e.g. I remember talking to OptumSoft
01:37:04 <insertpseudonym> yezariaely:  haha case in point
01:37:10 <merijn> tikhonjelvis: So where do you look for interesting startups? :p
01:37:40 <merijn> And then there is the problem of a lot (most?) of startups being in the US
01:37:47 <tikhonjelvis> I dunno. I met some interesting ones at a hackathons.
01:37:54 <insertpseudonym> game design would be sick; I've been flip-flopping between that and regular tech companies for a while.
01:37:59 <tikhonjelvis> The ones I meet are all silicon valley ones.
01:38:10 <tikhonjelvis> I am not a big fan of graphics/game stuff. But that's just me.
01:38:11 <insertpseudonym> merijn: are you not in the US?
01:38:30 <merijn> insertpseudonym: No, why else would I be awake now? ;)
01:38:44 <tikhonjelvis> ...
01:38:45 <Botje> crazy and/or insomniac?
01:38:50 <tikhonjelvis> student?
01:38:55 <merijn> I could probably get a visa, but that's a lot of hassle
01:39:03 <insertpseudonym> merijn: haha I'm an insomniac
01:39:07 <tikhonjelvis> It's nice here in California.
01:39:20 <insertpseudonym> u don't need a visa, just a computer and a dream = )
01:39:52 <merijn> Also, while I'm interested in going to the US research/work wise, I'm not sure I actually want to live in the US...
01:40:13 <tikhonjelvis> The places you wouldn't want to live in don't have research anyhow.
01:40:14 <luite> flee europe before the economy and euro crash!
01:40:27 <tikhonjelvis> I bet you wouldn't mind Boston or the Bay Area, for example.
01:40:45 <merijn> tikhonjelvis: I dunno, from here the valley seems like a big echo chamber of wankery
01:40:47 <Botje> luite: we'll still have socialism
01:40:54 <merijn> luite: I have no money so I don't care about a Euro crash
01:40:59 <merijn> As long as it goes back up after :p
01:41:06 <tikhonjelvis> merijn: Do you follow HN or something? I think you're not getting the full picture.
01:41:35 <merijn> tikhonjelvis: Casually, I usually scan for interesting headlines once or twice a day and then ignore the rest
01:41:39 <tikhonjelvis> Although there is some nonsense, there is just *so much* stuff here that there is also plenty of cool and interesting things going on.
01:42:25 <tikhonjelvis> Facebook/Google alone have a ton of interesting engineering going on.
01:42:30 <tikhonjelvis> It just gets much less press.
01:42:48 <tikhonjelvis> Then you have a really wide range of startups.
01:43:30 <tikhonjelvis> For example, my dad is working at a company that's using flash memory to speed up servers. Not what you usually read about, but relatively interesting.
01:44:14 <EgeBamyasi> Didnt Vista support that?
01:44:40 <tikhonjelvis> Maybe. I gather they're doing something more sophisticated, but I'm not too familiar with the company.
01:45:01 <atomicity> yeah, but you can work at google *and* be in europe at the same time :)
01:45:14 <atomicity> there's a great center in france, for instance.
01:45:30 <tikhonjelvis> Oh yeah, I would actually love to work in Europe. But California is also very nice.
01:45:36 <insertpseudonym> atomicity: I love the Zurich office from the pictures
01:45:49 <merijn> atomicity: Zurich too
01:45:51 <insertpseudonym> I hope I get to visit at some point
01:45:56 <atomicity> tikhonjelvis: honestly, I'm a bit scared of actually coming to the US. TSA seems to be out of control, as does DHS.
01:46:01 <tikhonjelvis> And it's great to have random engineers from Facebook, Google, small companies...etc all just hanging around.
01:46:03 <merijn> Also, bonus: Swiss is a beautiful country and ETH is close by
01:46:11 <merijn> atomicity: Same
01:46:13 <tikhonjelvis> atomicity: Yeah, that's probably true.
01:46:29 <merijn> Not to mention healthcare issues if you move there
01:46:32 <tikhonjelvis> The whole borders/civil rights nonsense makes me sad.
01:46:33 <atomicity> tikhonjelvis: it's probably a lot worse if you're a foreigner
01:46:41 <tikhonjelvis> Well, I *am* a foreigner.
01:46:58 <atomicity> merijn: healthcare is still paid by my country if I move to the US, so no problems there
01:47:01 <insertpseudonym> tikhonjelvis: if you're asian in cali, then it doesn't count = P
01:47:07 <tikhonjelvis> I'm actually Russian.
01:47:11 <tikhonjelvis> But I used to live in Canada.
01:47:14 <tikhonjelvis> It's warmer here :)
01:47:26 <insertpseudonym> tikhonjelvis: wow then you have traveled
01:47:41 <tikhonjelvis> And, ideally, I want to travel more after college.
01:47:51 <atomicity> I was to toronto once. Seemed like a nice city, and a lot like my home country.
01:47:56 <tikhonjelvis> But that's because I want to see as much of the world as possible.
01:48:07 <tikhonjelvis> I used to live in Ottawa, which is pretty close to Toronto.
01:48:10 <tikhonjelvis> Montreal is really nice.
01:48:22 <insertpseudonym> tikhonjelvis: you may have seen this, but I found it inspirational http://alexmaccaw.co.uk/posts/traveling_writing_programming
01:48:57 <tikhonjelvis> Yeah, that sounds really awesome.
01:49:02 <atomicity> if I have to come to the us if they let me into berkeley, do you guys advise me to leave my laptop at home?
01:49:08 <atomicity> and buy one when I come stateside?
01:49:24 <tikhonjelvis> I don't really know.
01:49:32 <luite> why?
01:49:38 <atomicity> TSA
01:49:38 <tikhonjelvis> The department might give you one for free.
01:49:46 <drdo> What happens if you bring a laptop to the US?
01:49:48 <insertpseudonym> atomicity: I think the only manufacturing differences are in the keyboard settings if that's your concern
01:50:05 <luite> atomicity: why is that a problem? if you have sensitive data, just download it later?
01:50:05 <atomicity> keyboards aren't my concern, I use the american one as it is. Better symbol placement.
01:50:27 <atomicity> luite: I don't want my equipment siezed because of drive encryption. I've heard enough horror stories to become scared :)
01:50:48 <tikhonjelvis> You can just store everything on the internet and clean your laptop if you're worried.
01:51:10 <luite> just upload it to megauplaod or something ;p
01:51:10 <russellw> atomicity, the EFF wrote an extensive document with advice on that topic, you might want to look it up
01:51:10 <tikhonjelvis> But, while it's a horrible infringement of rights, I don't think the actual practical inconvenience is *that* bad.
01:51:11 <merijn> atomicity: I would treat the TSA as the average defcon visitor
01:51:13 <atomicity> so... if you cross the border with a clean, windows only machine, they can't and won't touch it?
01:51:20 <insertpseudonym> luite: LOL
01:51:23 <merijn> Wipe before going, wipe after arriving
01:51:28 <insertpseudonym> luite: that's low
01:51:41 <tikhonjelvis> I think they're likely to not look at all; if they do, it's most likely only going to be cursory.
01:52:04 <tikhonjelvis> Frankly, as far as laptops go, I'd probably worry about theft as much as the TSA–the latter is just more evil.
01:52:14 <atomicity> oh, ok. then it'm ok. I've got a server at home I store everything on anyway
01:52:37 <atomicity> russellw: thanks, I'll look that up
01:54:55 <atomicity> thanks to everyone for the input
01:54:59 <insertpseudonym> well I'm out; night/morning fellas
01:55:11 <tikhonjelvis> night
02:08:28 <argiopeweb> I've got an odd issue and I wonder if anyone's seen before. I have a multi-threaded server application that crashes without error output after a client disconnects, but only on RHEL5/CentOS 5 x86_64. An exception handler at the top level (in main) keeps everything from crashing and makes the finally handler at the client level work. I've got a hacky work-around, but I don't have a clue why it works...
02:09:14 <argiopeweb> With both handlers in there I get the standard IOException for the unexpectedly closed socket and a "writev: resource vanished (Broken pipe)" error.
02:15:36 <mm_freak> argiopeweb: aren't your clients in separate threads?
02:17:49 <snetz> q
02:18:38 <argiopeweb> mm_freak: They are. It appears this exception propagates up to the top level and chops the exec off at the head. I'm guessing it has something to do with the fact I'm using lazy IO (due to Data.Binary) and writev is being called after the "socket disconnected" exception is thrown, triggering a second exception.
02:19:09 <quicksilver> argiopeweb: broken pipe is traditionally a signal SIGPIPE which will actually take out the whole server if you don't handle it.
02:19:30 <quicksilver> Some version of the GHC RTS started catching this signal for you, but I don't remember which. Possibly 7.0 or 7.2
02:19:35 <argiopeweb> quicksilver: I noticed. Kind of odd it doesn't act like that elsewhere though.
02:19:52 <argiopeweb> I'm compiling on 7.2.2, but there's nothing to say it isn't OS-version dependent.
02:20:00 <argiopeweb> RHEL5 is old as sin in my eyes.
02:21:39 <mm_freak> argiopeweb: you get SIGPIPE on all unixy systems
02:21:55 <mm_freak> but it only happens if you write to a half-closed handle, i think
02:22:35 <quicksilver> mm_freak: yes, but GHC catches SIGPIPE for you and turns it into an exception
02:22:37 <quicksilver> or it tries to.
02:22:43 <quicksilver> I wonder if there is a race condition.
02:23:24 <argiopeweb> mm_freak: Right. I get a Haskell exception (which I handle with both finally and a literal catch), then the lazy write goes and hits it again... I wonder how much it'll change to shift over to strict IO...
02:27:40 <argiopeweb> Hmm, interesting. I currently have the function wrapped by finally wrapped by catch wrapped by onException (combined everything going up the call tree into one place). Finally closes, catch prints the exception, and onException just prints "Oops." In practice, finally can be deleted without changing the application (need to check netstat to confirm), catch prints, and onException doesn't. But if you take onException out, it crashes.
02:27:56 <argiopeweb> And doesn't print in the catch, I might add.
02:33:07 <mm_freak> argiopeweb: have you thought about not using lazy I/O?
02:33:18 <mm_freak> you may be suffering from the unpredictability problem
02:35:43 * hackagebot HipmunkPlayground 5.2.0.5 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.5 (FelipeLessa)
02:39:08 <Razz> Is there anyone here that has gone through typeclassopedia that could explain ex 5.2.3 to me (monad instance for 'free monad built from functor f')?
02:39:49 <Razz> I'm a bit stuck on the fact that I can assume f is a functor, but my function in the monad instance is not (a -> b) but (a -> Free f b)
02:39:58 <argiopeweb> mm_freak: That's my current theory as well. Only reason I'm using it in the first place is because it doesn't require any work-arounds to use it with Data.Binary. I'll work on converting over to strict and see what happens.
02:47:03 <Nicknack> Hello, just wondering if anyone can help me uninstall yi or explain how to get it running? I did cabal install yi and can't get anything going :(. Im new
02:47:27 <Nicknack> #haskell Hello, just wondering if anyone can help me uninstall yi or explain how to get it running? I did cabal install yi and can't get anything going :(. Im new
02:50:50 <ion> razz: http://www.haskell.org/haskellwiki/Free_structure
02:51:05 <argiopeweb> mm_freak: Yep, seems like strict send will fix my issues. I still get the resource vanished (as expected), but no follow-up writev exception. Thanks for the tip.
02:51:08 <rostayob> Nicknack: I can't help you with yi, but if you're looking for an editor yi might not be a good choice
02:53:20 <Razz> ion: thx !
02:55:56 <mm_freak> argiopeweb: have a look at the cereal library
02:55:59 <Nicknack> Sorry lost my connection, What editor do you suggest is decent for haskell? Any idea on how to uninstall Yi also? I'm on MBA and want all of the precious HD space possible :P
02:56:47 <mm_freak> argiopeweb: it can handle both lazy and strict bytestrings
02:57:02 <mm_freak> and internally it's based on blaze-builder
02:57:06 <mm_freak> which you can also use
02:58:17 <argiopeweb> mm_freak: I'll take a look at it. My data sizes are ridiculously well-defined and moderately small, so it's a bit silly to be using lazy in the first place.
02:59:27 <rostayob> Nicknack: emacs, vim
02:59:47 <mm_freak> argiopeweb: that's not a valid argument against laziness
03:01:15 <argiopeweb> mm_freak: Most things are a valid argument against lazy IO, though I'll agree that I've made better arguments against lazy data structures. It's nearly 7am and I'm not quite thinking straight. ;)
03:01:48 <argiopeweb> In fact, I believe I'm going to hit the rack. Thanks all.
03:03:49 <mm_freak> argiopeweb: there are plenty of arguments against lazy I/O, but you weren't referring to lazy I/O
03:11:07 <Veinor> > foldr f z [a,b,c,d]
03:11:08 <lambdabot>   f a (f b (f c (f d z)))
03:11:16 <Veinor> > foldl f z [a,b,c,d]
03:11:17 <lambdabot>   f (f (f (f z a) b) c) d
03:42:47 <dhun_233> I am trying to learn about the Cont Monad, it seems to me that you could define m>>=f=m f, but the official definition looks much more complicated
03:43:08 <ion> @src Cont (>>=)
03:43:08 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
03:45:08 <dhun_233> >>=:: ((a->r)-r)->(a->((b->r)_>r))->((b->r)->)
03:45:13 <dhun_233> >>=:: ((a->r)-r)->(a->((b->r)_>r))->((b->r)->r)
03:45:26 <dhun_233> >>=:: ((a->r)-r)->(a->((b->r)->r))->((b->r)->r)
03:45:42 <dhun_233> >>=:: ((a->r)->r)->(a->((b->r)->r))->((b->r)->r)
03:45:57 <ion> dhun_233: Cont and runCont are just a wrapper and an unwrapper. If you try replacing Cont and runCont with “id” and simplifying, you’ll end up with m k.
03:45:57 <dhun_233> so from the type it would fit
03:46:09 <dhun_233> ok thank you
03:46:25 <ion> @pl \m k -> id $ \c -> id m $ \a -> id (k a) c
03:46:26 <lambdabot> (. flip) . (.)
03:46:32 <ion> @pl id $ \c -> id m $ \a -> id (k a) c
03:46:33 <lambdabot> m . flip k
03:46:39 <ion> err, wait
03:47:22 <dhun_233> well I simplified to \k->m ( \a-> (f a) k) but that is not yet m f
03:48:05 <byorgey> dhun_233: no, m k  does not work
03:48:54 <byorgey> for that to typecheck you would have to have   r = (b -> r) -> r   which is impossible
03:49:49 <Arnar> can I use Data.Generics to apply a transformation only to the topmost instance of a particular type?
03:50:04 <byorgey> @type (\m k -> m k) :: ((a->r)->r)->(a->((b->r)->r))->((b->r)->r)
03:50:05 <lambdabot>     Occurs check: cannot construct the infinite type: r = (b -> r) -> r
03:50:05 <lambdabot>     In the expression:
03:50:05 <lambdabot>           (\ m k -> m k) ::
03:50:10 <byorgey> voila
03:50:56 <byorgey> dhun_233: the types  a, b, and r  are chosen by the *caller* of (>>=)
03:52:03 <byorgey> dhun_233: when implementing (>>=) you must treat them as unknown.  In particular you don't get to use something more specific in place of 'r'.
03:53:00 <dhun_233> yes thats right r is fixed and I cant chose it myself
03:53:28 <dhun_233> in particular I can say r' = (b->r)->r
03:53:36 <dhun_233> since r'=r has to hold
03:53:42 <byorgey> right.
03:54:05 <byorgey> assuming you meant "in particular I *can't* say ..."
03:54:23 <dhun_233> yes I did
03:54:43 <merijn> dhun_233: That's exactly what he said you *cannot* do
03:54:54 <dhun_233> I can not
03:55:00 <dhun_233> and that right
03:55:08 <dhun_233> that why my idea does not work
03:55:44 <merijn> "There is a possible type T that lets me do X" is not the same as "I can do X for all possible types T"
03:56:07 <dhun_233> thats the point
03:56:16 <byorgey> merijn: I think dhun_233 understands now =)
03:56:47 <merijn> Hmm, I think I might have misparsed some answer
03:57:31 <dhun_233> my answers were nearly unparsable
03:58:19 <dreixel> Arnar: yes
03:58:29 <dreixel> though I'm not entirely sure there is a function in the library that does exactly that
03:59:10 <dreixel> maybe you can use `everywhereBut`
04:04:25 <whald> can s.o. recommend me an easy way to store prefereces with the user account? something like java.util.prefs.Preferences ?
04:07:18 <Arnar> dreixel: thanks, I'm not sure what the query should be then
04:07:29 <Arnar> dreixel: do I have any guarantees in which order nodes are visited?
04:07:43 <donri> whald: uh, context?
04:07:54 <rostayob> whald: I'm not sure exactly how Preferences works (I rememeber vaguely), but in doubt I'm going to suggest acid-store, which is a persistent storage of Haskell data structures
04:08:59 <donri> if you mean configuration, you might have a look at dyre or configurator
04:09:01 <donri> @hackage dyre
04:09:01 <lambdabot> http://hackage.haskell.org/package/dyre
04:09:03 <donri> @hackage configurator
04:09:03 <lambdabot> http://hackage.haskell.org/package/configurator
04:09:07 <donri> @hackage acid-state
04:09:07 <lambdabot> http://hackage.haskell.org/package/acid-state
04:09:43 <whald> donri: for storing login credentials in my case, short strings basically
04:10:12 <whald> rostayob, donri: thanks for the suggestions, i'll have a look now
04:11:07 <dreixel> Arnar: yes, at least for the derived instances of Data, the order is left-to-right
04:11:20 <dreixel> have a look at `somewhere` too
04:12:13 <NothingMan65> Ugh I'm such a n00b.
04:12:50 <NothingMan65> I wanna iterate over my list without changing the current element, rather, I want to change a large number of elements in xs given the form [x:xs]
04:14:06 <Arnar> dreixel: thanks. I suppose the query has to be stateful then, returning true on first call and false afterwards (if used with everywhere')
04:14:17 <Botje> NothingMan65: what?
04:14:24 <Botje> NothingMan65: can you make it more concrete?
04:14:34 <NothingMan65> Sure
04:15:22 <NothingMan65> I have a list of Tuples (Int,Bool),  and I want to basically iterate through that list and set (_, False) on all of the elements which are squares of (Int,_)
04:15:26 <NothingMan65> Does that make sense?
04:15:49 <Arnar> dreixel: aaah, the source comment for somewhere explains it, but the doc comment sounds like there is no guarantee about the order
04:15:52 <NothingMan65> Or power*
04:16:08 <Arnar> dreixel: but it apparently does exactly what I need http://www.haskell.org/ghc/docs/6.12.2/html/libraries/syb-0.1.0.2/src/Data-Generics-Schemes.html#somewhere
04:17:13 <rostayob> Arnar: those are outdated docs btw
04:17:17 <rostayob> unless you're using GHC 6
04:17:23 <Botje> NothingMan65: okay, so you want to pattern match on the first element, and grab the rest
04:17:39 <NothingMan65> Like x:xs ?
04:18:55 <Botje> more like ((x,m) : ts)
04:18:56 <merijn> NothingMan65: You can have multiple pattern matches "(x, b):xs" <- here x is ant int, b is a bool
04:19:10 <Botje> so you pattern match on a tuple, the number is x and the Bool is captured in m
04:19:13 <Botje> ts is the rest of your tuples
04:20:02 <NothingMan65> I got that, but basically I want to call a function with (x,b) as input and find some other tuples in xs which need to be modified, based on (x,b)
04:20:21 <Arnar> rostayob: ach, yes, true. for some reason Google favours the old ones
04:21:06 <merijn> NothingMan65: foo (i, b):xs = if square i then (i, False) : foo xs else (i, b) : foo xs
04:21:42 <rostayob> Arnar: because people keep linking to them! eheh
04:21:45 <merijn> (Or you can use guards or whatever, I personally don't like if-then-else, but its easier to write on one line)
04:21:49 <rostayob> in general the best thing is to use your own docs
04:22:08 <rostayob> which are shipped with the platform
04:22:21 <rostayob> and enable documentation generation in the cabal config file
04:22:23 <merijn> oh, wait
04:22:58 <merijn> NothingMan65: You mean you want to set false on future tuples based on the current value of x? As in a sieve?
04:23:05 <NothingMan65> Aye
04:23:37 <Arnar> rostayob: what's the best way to browse docs for whatever packages I have installed?
04:24:21 <NothingMan65> Sorry for being so cryptic.  I find that abstractly describing what I'm trying to do helps me learn more effectively.
04:24:32 <Botje> NothingMan65: use a list comprehension.
04:24:36 <NothingMan65> Instead of like, "How do I make a sieve?".
04:24:52 <NothingMan65> Well I'm using a list comprehension to populate the range I want to sieve.
04:25:05 <Botje> you can use a list comprehension over that same range.
04:25:05 <NothingMan65> But I'm having trouble figuring out where to put the code to cross of elements.
04:26:09 <Botje> killMultiples ((x,m):ts) = (x,m) : [ (x', m'') | (x', m') <- ts, let m'' = {- some calculation based on x, x' and m' -} ]
04:26:26 <Botje> and you probably want a recursive call to killMultiples in there somewhere.
04:26:59 <Botje> so for every element in the rest of the list, you grab each component of the tuple and recalculate the bool part
04:27:06 <Botje> using the values of x, x' and m'
04:27:24 <Botje> I can imagine that m' == False immediately shortcuts your code.
04:27:47 <NothingMan65> Shouldn't there be a way to just set element list !! index to (x,False)
04:27:58 <dhun_233> ion I think the m >> f = m . (flip f) that lambda bot produced some minutes ago helps me to understand what happens
04:28:08 <Botje> no.
04:28:09 <merijn> @pl \x y -> x `mod` y == 0
04:28:09 <lambdabot> flip flip 0 . ((==) .) . mod
04:28:20 <Botje> at best you can generate a new list with a different element at the given index
04:28:31 <Botje> but you will need to traverse the list each time
04:28:35 <rostayob> flip flip?
04:28:41 <NothingMan65> Hmm
04:29:17 <mekeor> haha: on his blog, chris done says/said: "According to a talk I saw by Simon Peyton-Jones, the early Haskell compilers would delete your source code upon a type error."  -- haha, lol
04:29:28 <NothingMan65> Does (list !! index = (1,False) ) do that under the hood?
04:29:38 <Botje> no.
04:29:43 <Botje> !! only grabs the element.
04:30:02 <NothingMan65> Oh so it's like a by value copy of the element?
04:30:33 <Botje> you would have to do something like "let (before, x:after) = splitAt x list in before ++ (new_x : after)
04:31:30 <NothingMan65> Well splitting, replacing and reassembling is probably more efficiently than recalculating the entire tail for one element, right?
04:31:43 <NothingMan65> efficient*
04:32:06 <merijn> NothingMan65: Splitting replacing an reassembling means rebuilding the entire start of the list
04:32:21 <merijn> NothingMan65: "a ++ b" means copying the entirety of a
04:32:32 <NothingMan65> lol, so I should do that if I am before the halfway point and then recalc the entire tail if I am after the halfway point
04:32:37 <merijn> Since otherwise you'd have to modify a to append b, which is not possible
04:33:01 <Botje> NothingMan65: the way I showed above recalculates the entire list at once
04:33:30 <Botje> but each calculation is delayed to the last possible point
04:33:45 <NothingMan65> Oh okay, cool!
04:33:57 <NothingMan65> I see it now! Gonna play around with that.  Thanks Botje!  Great help!
04:34:03 <ion> dhun_233: Say, you want to implement “f :: ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r” from scratch. It’s a function of three parameters: “m :: (a -> r) -> r”, “k :: a -> (b -> r) -> r” and “c :: b -> r”. “(\a -> k a c) :: a -> r”. “m (\a -> k a c) :: r”. Therefore, “f m k c = m (\a -> k a c)” has the right type.
04:34:03 <kuznero> Hi All!
04:34:10 <ion> Oh, he left.
04:34:31 <Botje> no problem
04:34:41 <Botje> stick around, we like to answer questions :)
04:34:59 <NothingMan65> I'll be in and out (=
04:35:50 <ion> @tell dhun_233 Say, you want to implement “f :: ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r” from scratch. It’s a function of three parameters: “m :: (a -> r) -> r”, “k :: a -> (b -> r) -> r” and “c :: b -> r”. “(\a -> k a c) :: a -> r”. “m (\a -> k a c) :: r”. Therefore, “f m k c = m (\a -> k a c)” has the right type.
04:35:50 <lambdabot> Consider it noted.
04:36:16 <ion> @tell dhun_233 If you replace Cont and runCont with id in “m >>= k = Cont $ \c -> runCont m $ \a -> runCont (k a) c” you’ll end up the same definition.
04:36:16 <lambdabot> Consider it noted.
04:40:13 <_Mikey> that sounds cool!
04:40:35 <harlekin> How can I sum every two elements of a list, e.g. [1,1,2,3] -> [2,5,...]
04:40:38 <_Mikey> whooops was looking at a convo that happened this 4 hours ago
04:41:11 <_Mikey> fold over it
04:41:12 <_Mikey> ?
04:41:46 <merijn> NothingMan65: You can also use laziness to have a data structure refer to itself, something like this (warning, doesn't actually work since I have a mistake somewhere and I'm not spotting it right now): http://hpaste.org/56918
04:41:52 <harlekin> _Mikey: how do I know if I am processing the even or odd -indexed element?
04:41:56 <Lemmih> _Mikey: map sum . chunk 2
04:41:57 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:42:06 <harlekin> Lemmih: thanks!
04:42:07 <mm_freak> > let each n = takeWhile (not . null) . map (take n) . iterate (drop n) in map sum . each $ [1, 1, 2, 3]
04:42:08 <lambdabot>   Couldn't match expected type `[[a]]'
04:42:08 <lambdabot>         against inferred type `[a1] ->...
04:42:12 <_Mikey> ahh
04:42:25 <_Mikey> Lemmih, that looks right
04:42:27 <mm_freak> > let each n = takeWhile (not . null) . map (take n) . iterate (drop n) in each $ [1, 1, 2, 3]
04:42:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:42:29 <lambdabot>         against inferred type ...
04:42:30 <harlekin> ohayoo
04:42:35 <harlekin> Woops.
04:42:40 <mm_freak> @let each n = takeWhile (not . null) . map (take n) . iterate (drop n)
04:42:42 <lambdabot>  Defined.
04:42:43 <mm_freak> :t each
04:42:44 <lambdabot> forall a. Int -> [a] -> [[a]]
04:42:57 <mm_freak> > map sum . each $ [1, 1, 2, 3]
04:42:58 <lambdabot>   Couldn't match expected type `[[a]]'
04:42:58 <lambdabot>         against inferred type `[a1] ->...
04:43:17 <Lemmih> _Mikey: Oops, sorry. That was for harlekin.
04:43:17 <_Mikey> mm_freak, you're going ham :)
04:43:27 <mm_freak> lol
04:43:29 <_Mikey> hehe no worries
04:43:32 <mm_freak> > map sum . each 2 $ [1, 1, 2, 3]
04:43:34 <lambdabot>   [2,5]
04:43:35 <mm_freak> there we go ;)
04:43:51 <_Mikey> on lambdabot 5*
04:44:26 <mm_freak> > map sum . takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..]
04:44:28 <lambdabot>   [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,1...
04:44:55 <_Mikey> pretty sequence
04:45:43 <_Mikey> mm_freak, could you explain the way the State Monad works in 3 sentences?
04:46:15 <mm_freak> _Mikey: yes, but those three sentences would involve the type and the Monad instance definition =P
04:46:28 <_Mikey> XD
04:46:33 <donri> http://www.haskell.org/haskellwiki/All_About_Monads#The_State_monad
04:46:34 <mm_freak> _Mikey: what's your trouble with it?
04:46:40 <ion> http://heh.fi/state-monad
04:46:53 <mm_freak> _Mikey: or /them/ actually…  State is a family of state monads
04:46:53 <_Mikey> I'm confused as to what the significance of the two values in the tuple are
04:47:07 <zomg> I'm trying to use Data.Binary.Get to read a bunch of stuff from a ByteString, but it seems to be producing a bit confusing results
04:47:23 <mm_freak> _Mikey: newtype State s a = State (s -> (a, s))
04:47:29 <donri> _Mikey: one is the state, the other the normal return value of the computation
04:47:44 <_Mikey> ok
04:47:46 <zomg> Basically the form of data is like this: int32, char[], null byte, which is repeated again and again. So I try to getWord32le for the int32, and then use getBytes to read the char[], but this seems to mess up somehow
04:47:53 <mm_freak> _Mikey: a state-monadic computation is basically a value depending on some value of type 's', and it gives a new value of 's' along with that value
04:48:01 <_Mikey> so you can define aribtrary states
04:48:04 <zomg> Does getBytes actually advance the internal pointer like getWordX does?
04:48:17 <_Mikey> and change state based on the value
04:48:25 <mm_freak> _Mikey: like a random number generator would have this signature:  randomInt :: RNG -> (Int, RNG)
04:48:38 <_Mikey> ok
04:48:38 <mm_freak> the state-monadic equivalent would be:  randomInt :: State RNG Int
04:49:13 <mm_freak> randomInt = \rng -> (toInt rng, newRng rng)
04:49:13 <mm_freak> or
04:49:18 <mm_freak> randomInt = State $ \rng -> (toInt rng, newRng rng)
04:49:30 <_Mikey> ok
04:49:38 <_Mikey> I think I get it
04:49:46 <mm_freak> it's really just such a function wrapped in a State constructor
04:50:15 <ion> mikey: Check out my link, too.
04:50:43 <_Mikey> ok
04:50:50 <ben> @src filter
04:50:50 <lambdabot> filter _ []     = []
04:50:50 <lambdabot> filter p (x:xs)
04:50:50 <lambdabot>     | p x       = x : filter p xs
04:50:50 <lambdabot>     | otherwise = filter p xs
04:50:51 <_Mikey> cheers ion
04:51:00 <SplinterCDO> Hello, I would like to know is it legal to use python for commercial products from your experience
04:51:25 <russellw> SplinterCDO, yes
04:51:26 <ion> splintercdo: No, it’s illegal to use any programming language.
04:51:26 <_Mikey> google use python..
04:51:26 <chu> Odd question considering the channel ...
04:51:51 <ChristianS> python is legal, but haskell is much more fun
04:51:58 <mm_freak> _Mikey: before checking out the link, try to write 'get' and 'put' yourself
04:52:01 <froztbyte> does that make haskell a drug?
04:52:10 <ion> chu: It’s just a normal everyday troll.
04:52:18 <osfameron> SplinterCDO: are you talking about licensing?
04:52:20 <mm_freak> _Mikey: those two are the key functions…  if you can write them, you have understood the essence of state monads
04:53:03 <osfameron> SplinterCDO: people can, and do write a) webapps and b) client-facing apps in Python (and, indeed, in most useful programming languages), so I suspect your answer is "yes", but if you are really worried, you should check with your lawyer ;-)
04:53:29 <ChristianS> better yet, ask your lawyer to write the software for you
04:53:45 <donri> CDO: OCD sorted lexicographically.
04:57:40 <SplinterCDO> I am sorry guys I didn't saw I am in Haskell chat sorry sorry :)
04:59:02 <mm_freak> no worries, we talk about other languages all the time =)
04:59:25 <zomg> Is there some way to see variables in the ghci debugger?
04:59:40 <zomg> I'm trying to get the values of bytesRead in a Data.Binary.Get monad
04:59:42 <merijn> mm_freak: No we don't, heretic!
04:59:56 <zomg> but stepping in the debugger and I never get the vars.. I'm guessing it has something to do with lazy evaluation
05:00:49 * hackagebot logic-classes 1.4 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4 (DavidFox)
05:00:59 <donri> zomg: isn't that what :list does?
05:00:59 <zomg> I hate debugging haskell :( Probably because I suck at it. With most languages I'd just toss in a few print X print Y print Z and hey presto, there's my variables and there's my problem =)
05:01:04 <zomg> Doesn't seem to do that
05:01:19 <donri> there's Debug.Trace
05:01:20 <merijn> Debug.Trace?
05:01:34 <donri> though I prefer the file-location package
05:01:44 <zomg> How exactly does that work? I must have failed using it somehow as I was just getting some errors
05:01:55 <mm_freak> zomg: just like seq works
05:02:01 <mm_freak> :t trace
05:02:02 <lambdabot> Not in scope: `trace'
05:02:06 <mm_freak> :t Debug.Trace.trace
05:02:07 <lambdabot> forall a. String -> a -> a
05:02:14 <donri> trace "ohai" x == x
05:02:18 <donri> plus printing "ohai"
05:02:36 <Arnar> zomg: replace any expression E with (trace "hej" E) and it will print "hej" when it evaluates it
05:02:45 <mm_freak> there is also traceShow, which is usually handier
05:04:13 <EgeBamyasi> Hej hej svenskar.
05:04:24 <zomg> Ah neat, I figured it out
05:04:37 <zomg> I was getting an error for the type of the expression in trace
05:04:42 <mm_freak> hmm
05:04:44 <donri> tjabba tjena hallå
05:04:46 <zomg> I tried 'trace thing ()'
05:04:53 <mm_freak> > Debug.Trace.trace "blah" 3
05:04:54 <lambdabot>   Not in scope: `Debug.Trace.trace'
05:04:54 <zomg> but I needed trace thing (return ())
05:05:01 <mm_freak> too bad
05:05:05 <mm_freak> > Debug.Trace.traceSzow "blah" 3
05:05:06 <lambdabot>   Not in scope: `Debug.Trace.traceSzow'
05:05:08 <mm_freak> > Debug.Trace.traceShow "blah" 3
05:05:09 <lambdabot>   Not in scope: `Debug.Trace.traceShow'
05:05:19 <donri> even if you get that to work, lambdabot doesn't perform IO
05:05:35 <mm_freak> donri: if that worked, it would perform IO =)
05:05:46 <donri> :P
05:06:10 <mm_freak> zomg: if you're in a monadic context anyway, you could also switch to a monad transformer, then on occasion you could add an IO to make debugging easier
05:06:20 <donri> > unsafePerformIO $ print "bla"; return 3
05:06:21 <lambdabot>   <no location info>: parse error on input `;'
05:06:28 <donri> > unsafePerformIO $ do print "bla"; return 3
05:06:29 <lambdabot>   Not in scope: `unsafePerformIO'
05:06:47 <merijn> donri: No IO in lambdabot :p
05:07:06 <zomg> mm_freak: I tried - I was too noob
05:07:06 <zomg> =)
05:07:11 <kuribas> Is it possible to script haskell, for example to enable the user to extend the program with their own functions?
05:07:12 <mm_freak> zomg: like if you have Cont r Int, you could change that to Monad m => ContT r m Int
05:07:24 <mm_freak> kuribas: on the fly?
05:07:27 <zomg> I didn't see a GetT but perhaps it exists and I just didn't look properly
05:07:29 <merijn> kuribas: Yes, look at ghci and lambdabot
05:07:34 <kuribas> mm_freak: preferably
05:07:38 <donri> @hackage dyre
05:07:39 <lambdabot> http://hackage.haskell.org/package/dyre
05:07:40 <mm_freak> kuribas: look into the hint library
05:07:42 <donri> @ kuribas
05:07:59 <merijn> kuribas: Err, rather. It is possible to extend GHC haskell with functions at runtime, other implementations may vary ;p
05:08:19 <mm_freak> kuribas: but hint gives you a full haskell interpreter, which might be dangerous depending on the application
05:08:26 <merijn> Blah
05:08:42 <merijn> I had a nice link on this subject, but apparently dons' university website no longer works?
05:08:44 <kuribas> I want to make a music notation program, where the user can extend the builtin definitions with their own functions.
05:09:08 <kuribas> I might make a small embedded language, but having a powerful language can be beneficial.
05:09:09 <mm_freak> then make it a music notation library =)
05:09:20 <mm_freak> see how haskore is designed
05:09:50 <kuribas> I looked at haskore, but it is more for MIDI than for notation.
05:10:01 <kuribas> For notation you need a lot more info about the piece.
05:10:05 <mm_freak> kuribas: yes, but you can employ the same idea
05:10:29 <mm_freak> if your users are going to be haskell programmers anyway, you could just as well provide a library
05:11:22 <kuribas> What do you mean with library?
05:12:32 <kuribas> Having full haskell available shouldn't be a problem, because it would only deal with pure functions.
05:13:46 <donri> kuribas: unsafePerformIO
05:13:59 <donri> purity is not a security feature
05:14:09 <portnov> -XSafeHaskell
05:14:14 <donri> in deed
05:14:37 <kuribas> true
05:14:59 <kuribas> Maybe I should add a DSL to it.
05:16:01 <joe9> is there a irc channel for idris? #idris just has 1 other nick
05:16:01 <joe9> anyone trying out idris?
05:16:48 <kuribas> Maybe I'll write a simple pure scheme interpreter
05:19:04 <mm_freak> kuribas: why not just release a library for it?  again, see how haskore works
05:19:18 <mm_freak> the idea is that your user would just write a haskell program using a DSL you provide
05:19:24 <zomg> Awesome, I just wrote something which reads a binary protocol from a socket and parses it
05:19:32 <zomg> Something which I could've done in 30 minutes in most languages I know
05:19:40 <zomg> but I spent a day on it and did it with haskell
05:19:40 <zomg> =)
05:19:55 <zomg> I feel smarter already!
05:21:22 <mm_freak> zomg: great…  what abstractions did you use?
05:21:35 <donri> are you using attoparsec-conduit
05:22:57 <kuribas> mm_freak: Yes, that was my intention.  But I also want to be able to specify music in a dedicated syntax, to make typing complex scores faster.
05:23:14 <joe9> kuribas: checked out idris?
05:23:30 <zomg> mm_freak: Socket.ByteString.Lazy and Data.Binary.Get mainly
05:24:07 <zomg> Half of the problems I had was due to my lack of good grasp of binary =)
05:24:59 <tdammers> kuribas: I have a somewhat useful music notation program up and running, feel free to fork: https://bitbucket.org/tdammers/notator
05:27:58 <kuribas> tdammers: cool, I'll have look :)
05:28:33 <kuribas> joe9: Very interesting, but I don't see how I could use it?
05:28:46 <baordog> tdammers: Do you know of a good synthesis system using haskel?
05:29:21 <tdammers> baordog: you mean music synthesis? no. I only do score writing, that's complex enough as it is.
05:29:48 <baordog> tdammers: are you a composer? I'm a composer as well, and I've been interested in haskel for a while
05:30:20 <tdammers> among other things, yes.
05:30:39 <tdammers> been a bit quiet lately though, two kids and a day job and all that
05:30:47 <kuribas> tdammers: I already have a general idea, but I might steal some from your project :)
05:31:06 <tdammers> sure, go ahead
05:31:35 <tdammers> it's BSD licensed, so do whatever you like
05:31:35 <pt114> can someone help me with building the latest stable ghc? I am getting the following error when i do `make`
05:31:35 <kuribas> Such as using Knuth's optimal paragraphbreaking algorithm for breaking pages and staffs.
05:32:00 <tdammers> page and staff breaks are actually done quite naively
05:32:22 <tdammers> with music, it's a bit more complex than with text though
05:32:57 <pt114> ...Schedule.dyn_o: relocation R_X86_64_PC32 against `StgRun' can not be used when making a shared object; recompile with -fPIC
05:32:58 <pt114> ...: final link failed: Bad value
05:33:12 <baordog> do you think it's possible to have an algorithm that does beaming right most of the time? I always hated that about both finale and lilly pond
05:33:16 <baordog> the beaming always fails
05:33:16 <kuribas> tdammers: My idea was to render the music several times, using tight layout, normal and loose, and then calculating the springs from there.
05:33:28 <tdammers> I'm not using springs
05:33:51 <kuribas> I don't think there is any music notation program that does that.
05:33:53 <tdammers> I just calculate the minimum distances, and then distribute the remaining space using a weight
05:34:05 <tdammers> there is, but I can't remember the name
05:34:28 <kuribas> guido notation?
05:34:35 <tdammers> the idea is nice - using some kind of verlet integration to yield visually balanced output...
05:34:59 <tdammers> isn't GUIDO just the syntax?
05:35:30 <kuribas> Could be
05:35:35 <tdammers> (parsing GUIDO, abc, and MusicXML is actually on my radar, but way at the bottom of the priority list)
05:35:37 <kuribas> baordog: In what way?
05:36:35 <kuribas> tdammers: I was thinking to interpolate the spacing with a 2nd degree function, for a more balanced layout.
05:36:44 <baordog> kuribas: It is very dificult to put in music of any complexity and not have to re-beam everything. An editor that recognized groups of twos/ threes and understood basic compositional rules for notation would save me hundreds of hours of monkey work
05:36:45 <tdammers> yep
05:37:07 <tdammers> I have the weight function as a parameter to the spacing algorithm
05:37:24 <kuribas> baordog: That's my intention, or at least to research the possibilities.
05:37:27 <tdammers> so you can use whatever you like - linear, constant, quadratic, exponential...
05:37:52 <tdammers> I think I'm using a second-degree polynominal right now
05:37:57 <kuribas> Ah, nice!
05:38:20 <baordog> kuribas: I mean, I've been really impressed with abjad and lillly pond, but they screw the beams almost every time
05:38:32 <kuribas> I also want to do kerning based on the shapes of the noteheads and other graphical elements.
05:38:37 <tdammers> I solved that by making beams explicit, always :P
05:39:06 <kuribas> Using only the bounding boxes doesn't give a nice layout when spacing is tight.
05:40:54 <kuribas> Hand-engraved scores often have the graphical elements put nicely together, while with computer programs there is often a small space between them.
05:41:59 <tdammers> I'm aiming for speedy entry and flexibility, perfect spacing is not my primary objective
05:42:20 <tdammers> I'm not going to beat lilypond on that front anyway, but I can certainly come up with a more usable syntax
05:43:47 <kuribas> I don't like that lilypond let's elements collide without warning.  For a complex piano score adjusting individual notes isn't very efficient.
05:44:25 <kuribas> BTW I am making a nice font based on my favorite scores :)
05:44:46 <tdammers> I'm not even allowing individual notehead tweaking :o
05:47:17 <kuribas> tdammers: The output looks very strange, do I need to install a font?
05:55:28 <tdammers> kuribas: yes
05:55:57 <tdammers> you can use Petrucci, Maestro or Engraver from Finale, or the MusicalSymbols font
05:56:07 <tdammers> the latter is a bit unclear on licensing terms
05:56:20 <ion> tdammers: Interesting. I’ve been using Lilypond. I’ll have to check Notator out.
05:56:37 <tdammers> heh, so now I really need to come up with a proper name for the thing
05:56:52 <ion> The most difficult part of software development. :-)
05:57:58 <tdammers> oh, and there's also a free music font, Fughetta, which also works but lacks symbols for dynamics, so I emulate them using a regular italic serif font
05:58:12 <tdammers> it kind of works, but doesn't look right
05:58:34 <ion> Someone should make a horrible font and call it Fugletta.
05:58:46 <rostayob> ahah
05:58:53 <tdammers> there's lots of ugly music fonts, just pick one
05:59:06 <tdammers> finding a good one is actually pretty damn hard
06:00:28 <kuribas> tdammers: You can use my font, but it is far from complete.  Also, I don't want the font to be used in commercial programs.
06:00:45 <ion> I can imagine. I’ve been quite happy with Lilypond’s default output, though. It has improved amazingly over the years.
06:01:47 <tdammers> kuribas: I could add support, but I'm not going to include anything non-free in the distribution itself
06:01:55 <tdammers> so it would be just like the other fonts
06:02:18 <kuribas> tdammers: Ok.  I would put it under the GPL (not the LGPL).
06:02:28 <tdammers> I can't do GPL either
06:02:47 <tdammers> GPL is more restrictive than BSD, and I really want to release under BSD
06:03:04 <merijn> The Haskell community in general seems to prefer BSD to GPL
06:03:07 <tdammers> but again, I can add support for your font, if I get around to it
06:03:10 <kuribas> see for example: http://kuribas.hcoop.net/test.ps
06:03:24 <Clint> it should prefer MIT to BSD
06:04:39 <ion> I like the ISC license. http://en.wikipedia.org/wiki/ISC_license
06:04:44 <merijn> Clint: They are mostly identical, the only major difference I'm aware of is patent grants. Which for now are irrelevant where I am as the EU doesn't recognise software patents atm
06:05:05 <tdammers> anything less restrictive than LGPL is fine by me
06:05:14 <koeien> LGPL + haskell = ???
06:05:15 <ion> It’s equivalent to the 2-clause BSD license and similar to the MIT license, but with all redundant text removed.
06:05:31 <tdammers> BSD-2 is pretty concise already :o
06:05:39 <koeien> although for fonts i imagine it does not matter that much
06:05:56 <merijn> tdammers: Pretty sure the redundant text belonged to the MIT part, not BSD ;)
06:06:26 <tdammers> koeien: fonts are a horrible mess, legally speaking
06:07:06 <koeien> no i mean the wording of the LGPL + the inner workings of GHC combined might not be what you expect
06:07:07 <tdammers> it's not actually clear if and how copyright applies to a typeface or individual glyphs, and laws and interpretations differ wildly between countries
06:07:12 <ion> merijn: It is shorter then the BSD license, too.
06:07:46 <ion> Wow, i can’t believe i made the than/then mistake. It seems i’m beginning to think like a native speaker. :-P
06:08:11 <merijn> ion: I make that mistake all the time :(
06:08:26 <merijn> I know which is which, but it still messes me up
06:08:53 <merijn> I seem to type phonetically, leading to a lot of homophone typo's...
06:09:26 <merijn> to/too/two, then/than, you're/your, etc.
06:09:44 <ion> “Thank’s!” “Your welcome.”
06:10:02 * Clint shudders.
06:10:15 <tdammers> they're their there
06:11:14 <merijn> tdammers: yes
06:11:23 <merijn> All. The. Freaking. Time.
06:11:46 <tdammers> Learn some German then
06:11:56 <tdammers> should cure you thoroughly
06:11:58 <merijn> I know some German...
06:12:11 <merijn> Enough to not die while there, anyway
06:12:53 <ben> Fortuntely, "beer" is pronounced exactly like the german word for beer.
06:13:00 <kuribas> tdammers: Does your licence forbit using a GPL font with it?
06:13:05 <koeien> not completely
06:13:18 <merijn> kuribas: Using, no. Because that is impossible
06:13:34 <kuribas> Ok, I see.
06:13:38 <tdammers> no, but including GPL'd content would require me to also go GPL
06:13:42 <merijn> kuribas: But the GPL prohibits distribution of GPL/BSD without relicensing the entire distribution to GPL
06:13:54 <koeien> if it is a "derived work"
06:14:01 <koeien> which is arguable
06:14:06 <tdammers> yeah
06:14:09 <kuribas> How would that work for fonts?
06:14:18 <merijn> koeien: True, but why introduce the headache of worrying about it?
06:14:32 <tdammers> kuribas: that exactly is the issue - does it apply, or doesn't it?
06:14:34 <merijn> Just include a link and say "here is another font you can download and use"
06:14:34 <koeien> to make it easier for your users.
06:14:50 <tdammers> yeah, that's what I'm thinking
06:15:00 <merijn> koeien: If he already supports other fonts that he can distribute that's not that much added value
06:15:01 <tdammers> it's pretty much what I do now, only I don't really have a lot of users
06:15:14 <tdammers> and adding support for yet another font isn't that hard
06:15:24 <koeien> merijn: it's a tradeoff, a legal risk versus inconveniencing your users
06:15:27 <merijn> Alternatively kuribas could distribute under modified GPL, adding an exception for your code :p
06:15:38 <merijn> (Assuming kuribas is the sole copyright holder)
06:15:47 <kuribas> I am at the moment :)
06:15:52 <tdammers> you just have to add suitable font properties in one source file, and add a mapping to the command line parser
06:16:32 <tdammers> if your font is compatible with maestro or one of the other supported font, you can even skip the "add font properties" part and just map the font name to the same font props
06:16:43 <kuribas> It's not
06:17:05 <tdammers> I'm thinking about making the font properties entirely dynamic, so you could add font support without recompiling
06:17:19 <tdammers> but then, the added benefit is too small to make it likely to happen soon
06:17:35 <kuribas> The fontforge source: http://kuribas.hcoop.net/music.sfd
06:18:30 <tdammers> I'll have a look after work ;-)
06:18:43 <kuribas> ok, thanks :)
06:20:15 <kuribas> tdammers: lilypond can transpose and handle different parts.
06:20:42 <tdammers> kuribas: not as flexibly as I can :-)
06:21:17 <kuribas> yes, true
06:21:31 <tdammers> believe me, I've tried to make it my primary tool, but I ran into edge cases and other clumsiness all the time
06:21:46 <kuribas> Yes, me too.
06:22:02 <tdammers> which is my main incentive to write one myself
06:22:34 <kuribas> I once rewrote the part-combiner, because I badly needed it.  They didn't want to include the code because the didn't understand it.
06:22:46 <kuribas> They still have the old, broken part-combiner.
06:23:16 <tdammers> I think lilypond basically lacks one level of abstraction
06:24:07 <kuribas> It's great when it works, but pain when it doesn't.  And they used to change the syntax every few weeks, breaking your existing work.
06:24:13 <kuribas> I don't know it it's better now.
06:25:18 <tdammers> I gave up on lilypond about half a year ago
06:25:30 <tdammers> so my prognosis is that it's still painful
06:27:55 <kuribas> tdammers: BTW, do you know pmw?  It doesn't look as good as lilypond, but the interface is nice, and it is more stable.
06:28:19 <kuribas> http://www.quercite.com/pmw.html
06:28:51 <PDani> hi
06:29:39 <Cale> PDani: hello
06:30:50 <tdammers> haven't checked out pmw before
06:31:07 <tdammers> looks interesting, but probably not enough to suit my needs
06:32:11 <PDani> i have a conceptional question which i can't figure out how to do: in a function, i would like to build a very long list based on a very big other data structure. so far I'm good, I can do it in constant space. _but_ sometimes i have corrupt data in my bid data structure, in that case, i should tell the caller function, and terminate the execution. I have ideas how could I implement this, but none of them can be done in constant space
06:32:11 <PDani> (head and stack)
06:32:16 <PDani> heap*
06:33:05 <PDani> terminate not the whole program, just the given function
06:34:50 <mm_freak> PDani: use a stream type with an error abort
06:35:15 <mm_freak> data Stream e a = Chunk [a] (Stream e a) | Error e | End
06:35:22 <frerich2> PDani: this reminds me of how the 'Maybe' monad works. In 'Just 1 >> Just 2 >> Nothing >> Just 3', the whole thing evaluates to 'Nothing' (since one of the contained values is 'Nothing'). A bit like short-circuit.
06:40:22 <everythingWorks> hi guys
06:40:31 <everythingWorks> What IDE do you actually use on windows?
06:40:52 <everythingWorks> Im currently trying Eclipse with a plugin. Turns out: no syntax highlighting or code completion? :o
06:40:58 <PDani> mm_freak, frerich2: thx
06:41:15 <merijn> everythingWorks: My Windows using friends tell me Notepad++ is a pretty decent Windows editor
06:41:26 <merijn> everythingWorks: Personally I just used gvim
06:41:43 <quicksilver> C# or Java style completion doesn't work well in languages which aren't C#/Java
06:41:45 <merijn> Since that allows me to use the same editor on BSD/linux/windows/OSX
06:42:05 <everythingWorks> merijn: thanks
06:42:27 <mekeor> talking about editors,  does anybody have experiences with haskell-emacs ?
06:42:31 <quicksilver> the good emacs and vim modes do moderately useful haskell trick though
06:42:52 <tdammers> protip: ghci can generate a tags file ;-)
06:42:55 <mekeor> (i'm talking about chris done's haskell-mode...)
06:43:09 <byorgey> everythingWorks: did you install the EclipseFP plugin?
06:43:30 <mekeor> (that one: https://github.com/chrisdone/haskell-emacs )
06:43:39 <byorgey> everythingWorks: as far as I know, it does syntax highlighting and code completion
06:44:32 * tdammers uses vim for everything
06:44:34 <everythingWorks> thanks guys, i'll try!
06:45:00 <mm_freak> mekeor: emacs user here
06:45:04 <mekeor> mm_freak: yippie!
06:45:13 <mm_freak> or do you mean something specific with "haskell-emacs"?
06:45:25 <mekeor> mm_freak: i'm currently using haskell-mode but chris done's haskell-emacs is great, too
06:45:34 <mekeor> mm_freak: https://github.com/chrisdone/haskell-emacs
06:45:39 <mm_freak> oh ok, no, then i misunderstood you, sorry
06:45:43 <mm_freak> i use haskell-mode right now
06:45:56 <Entroacceptor> I love ghc-mod
06:45:58 <everythingWorks> By the way, what for does the haskell symbol stand for?
06:45:59 <mm_freak> i'll give it a go later
06:46:15 <mm_freak> everythingWorks: it's a combination of a lambda and haskell's bind operator >>=
06:46:18 <mekeor> mm_freak: http://www.youtube.com/watch?v=pMEyz4leeLk
06:46:46 <mekeor> mm_freak: it's really great
06:47:10 <mm_freak> everythingWorks: so basically it stands for higher order functional programming and monads
06:47:15 <roconnor> > maxBound :: Word32
06:47:16 <lambdabot>   4294967295
06:48:00 <mr_sleepy> mm_freak: i am a vim user, but i really quickly tried emacs with haskell and i could not get syntax highlightning. is it working at all with emacs and haskell?
06:48:12 <mekeor> mm_freak: that feature is nice, too: http://www.youtube.com/watch?v=uQSRD3uIP4o
06:48:33 <mekeor> mr_sleepy: oh yes! haskell-mode is great
06:48:49 <mekeor> mr_sleepy: but haskell-emacs (written by chris done) seems even better.
06:48:51 <everythingWorks> mm_freak: okay. "monads" ?
06:48:54 <mekeor> mr_sleepy: do you use linux?
06:49:09 <mekeor> mr_sleepy: which distribution? debian? just apt-get install haskell-mode
06:49:40 <mm_freak> everythingWorks: something you'll eventually come across when learning haskell =)
06:49:46 <mm_freak> everythingWorks: don't worry about it now
06:50:11 <mr_sleepy> mekeor: openbsd. emacs-haskell is even a ready package
06:50:16 <mm_freak> mr_sleepy: for syntax highlighting in emacs you need to turn on font-lock-mode
06:50:21 <mekeor> mr_sleepy: O_O
06:50:39 <mm_freak> mr_sleepy: type M-x customize RET
06:50:54 <mm_freak> then somewhere under editing you'll find Font Lock
06:51:05 <mm_freak> turn that one on globally, save, done
06:51:32 * mekeor just installed "haskell-mode"-package and afterwards everything worked perfectly…
06:51:33 <mr_sleepy> i am very used to vim, so i need to check up if emacs+haskell has something significantly more to add than my vim setup
06:52:11 <koeien> check out evil
06:52:15 <mr_sleepy> i am open for a editor switch if it gives me more :)
06:52:17 <koeien> vim bindings for emacs
06:52:44 <mr_sleepy> yeah, i would probably use evil or viper.
06:53:26 <tdammers> personally, I found that editor features are much less important with haskell than with more verbose languages
06:53:45 <tdammers> you simply don't write that much boilerplate, so there is much less room for automation
06:54:04 <koeien> i agree, but the vim keybindings are just hardwired to m brain by now
06:54:19 <parcs`> except for imports and language pragmas :P
06:54:37 <tdammers> yeah, vim kind of erases motor memory acquired in other editors :)
06:55:37 <mm_freak> mr_sleepy: emacs is a totally different world
06:55:55 <mm_freak> vim vs. emacs is a bit like imperative vs. declarative programming
06:56:05 <mm_freak> if you're used to either of them, it can take months to get used to the other
06:56:06 <Entroacceptor> as I said, if you use haskell-mode, try ghc-mod
06:56:14 <Entroacceptor> and could we make a wiki site out of this discussion?
06:56:30 <mm_freak> Entroacceptor: for reference?  yes
06:56:33 <mr_sleepy> the only thing i wish i could get with vim is easy testing without saving, opening a terminal, loading the file into ghci
06:56:35 <mm_freak> to stop the discussions?  no ;)
06:57:02 <mr_sleepy> it is of course not taking much time to do ESC :w, switch over to the terminal, :r
06:57:16 <mm_freak> tdammers: i disagree
06:57:38 <Entroacceptor> mm_freak: for reference, yes
06:57:47 <mm_freak> at least for emacs users you still miss the editing features you have there
06:57:54 <mr_sleepy> is emacs-haskell having some sort of way to test directly your functions? without
06:58:05 <mr_sleepy> without saving, reloading a file
06:59:01 <parcs`> ghc-mod provides flymake support for haskell which automatically saves and reloads the file for you as soon as you stop typing, and highlights errors/warnings
06:59:10 <nh2> is there a tool that reads my cabal file, and for each of the dependencies just re-prints it, but with the lower version limit set to what I have right now? I'm starting a new project and want to limit versions to the current state of my system
07:01:16 <mm_freak> mekeor: looks great…  are you supposed to use it together with haskell-mode?
07:01:23 <mr_sleepy> parcs`: do you happen to know if you can get hoogle (or similar haskell documentation) straight in emacs. most of the time i am coding over ssh and no graphical browser
07:02:01 <merijn> mr_sleepy: I just use a terminal multiplexer, one terminal running vim, the other running ghci/whatever
07:02:04 <joe9> mr_sleepy: isn't there a lambdabot which can do hoogle at ghci prompt.
07:02:47 <mr_sleepy> merijn: that is what i am doing at the moment
07:03:04 <mr_sleepy> merijn: and i am not switching to anything else unless i can see a clear benefit
07:03:24 <mm_freak> i run emacs in X and even though with emacs you normally don't need a separate terminal, i prefer one
07:03:36 <merijn> mr_sleepy: I agree that some emacs features would be nice, but the pain of losing vim movements is too big to consider switching to emacs :)
07:03:46 <mm_freak> i'm probably the only one using emacs and haskell-mode without inferior-haskell
07:03:59 <merijn> I considered hacking vim to be more like emacs in that regard, but after one look at the code base I ran away screaming
07:04:04 <mm_freak> merijn: you don't lose them, you just find them on different keys ;)
07:04:13 <mr_sleepy> merijn: i have never really tested viper or evil, so that is why i could consider a switch...
07:04:29 <flux> merijn, vimperator.. :)
07:04:33 <mekeor> mm_freak: afaik not, no.
07:04:36 <flux> oops, viper I meant
07:04:43 <merijn> Every single time people mention viper/evil/etc
07:04:50 <merijn> But no, they're not the same, not even close
07:05:18 <mr_sleepy> mm_freak: some things you lose with standard emacs. for example to delete the whole row you write dd in vim. with emacs you need to jump to the beginning of the line first, then delete it (was it ctrl-k or ctrl-y, i don't remember anymore)
07:05:20 <flux> I'm sure many mention it in a jest
07:05:34 <merijn> Sure, the most obvious superficial behaviour is mimicked. But the more subtle interplay between commands and movements is non-existent in emacs
07:05:53 <flux> but apparently it's still a useful tool for some
07:06:12 <mm_freak> mr_sleepy: that's not lost functionality…  obviously certain things are going to need more keystrokes in emacs, but others are going to take more in vim
07:06:29 <mm_freak> especially when it comes to non-editing-related tasks like jumping back and forth between two files
07:06:32 <merijn> mm_freak: Sure, but afaict vim commands are more composable than emacs
07:06:55 <flux> all emacs commands compose nicely with record/play macro :)
07:07:08 <mm_freak> flux: that's not what merijn means
07:07:15 <merijn> record/playback is not composing commands
07:07:17 <mm_freak> vim can do on the fly composition
07:07:25 <mm_freak> which can be pretty nice
07:07:26 <mr_sleepy> without trolling intention, i really think emacs lacks a good editor, but probably have everything else
07:07:46 <mm_freak> emacs has a great editor
07:07:53 <Urchin> there's a few vi modes that come with standard emacs
07:07:57 <Urchin> you can take your pick
07:08:07 <mm_freak> it lacks the micro-commands vim offers, but it has nice things on a greater scale
07:08:08 <Urchin> if you're really into that
07:08:18 <merijn> Urchin: The point we covered (not 2 minutes ago) is how those are horribly deficient...
07:08:26 <mm_freak> just to name one:  rectangle editing…  this is so amazingly useful
07:08:33 <merijn> mm_freak: What's that?
07:08:38 <koeien> CTRL+V
07:08:47 <koeien> sometimes a life saver
07:09:03 <merijn> koeien: That's what I suspect, but I'm unsure whether that's what he means
07:09:05 <mm_freak> merijn: you have typed a few rows of similar lines and then find yourself needing to change something in each of them
07:09:15 <mm_freak> rectangle editing allows you to do that easily
07:09:16 <merijn> mm_freak: Yeah, so just block-visual mode
07:09:42 <mm_freak> merijn: no…  for example you have typed:  f abc def
07:09:46 <mm_freak> five lines
07:09:50 <mm_freak> and the arguments are lined up
07:09:57 <merijn> And then you want to change abc on each line
07:10:06 <int-e> emacs has some ^X r commands for that
07:10:06 <merijn> As I said, block-visual mode
07:10:08 <mm_freak> then you can exchange the arguments with two key combinations
07:10:20 <mm_freak> such that they become f def abc
07:10:30 <laar> Hello, is there a way to compile the version from cabal into a source file (for the --version flag)?
07:10:45 <mm_freak> that's one application of rectangle editing
07:10:45 <flux> I would probably do that with a macro, not with rectangle editing
07:11:08 <ClaudiusMaximus> laar: Paths_pkgname module might contain that
07:11:18 <flux> it doen't even require the rectangular layout, only some nice way to find the position, such as a pattern or nth word, paren, etc
07:11:58 <mm_freak> flux: if you can use rectangle editing, you're usually much faster with that instead of macros
07:12:05 <mm_freak> but yeah, in all other cases i'd also use macros
07:12:10 <byorgey> laar: yes, cabal generates a special module named  Paths_yourpackagename  which contains the version as well as info about where your package's data files (if any) are installed
07:12:25 <flux> the problem with macros is that if you do one error (or hit ^G) the whole macro is gone
07:12:35 <mm_freak> flux: you get used to that =)
07:12:36 <merijn> mm_freak: Open vim, write 5 lines of "f abc def", move cursor to space after f on first line, ctrl-v, shift-g, e, d, $, p and done :p
07:12:37 <flux> or well, not gone, but useless
07:12:46 <flux> (depending on situation)
07:12:48 <byorgey> just 'import Paths_yourpackagename (version)' and then use 'version', I think
07:12:55 <flux> mm_freak, if only there was to undo something without undoing the macro
07:13:14 <flux> like, eradicate the fact that something ever happened in the macro, while simulatenously rolling back the world
07:13:29 <laar> ClaudiusMaximus, byorgey is there any documentation on that module?
07:13:31 <merijn> Which I guess seems very cryptic if you come from emacs, but in vim that makes perfect sense and afaict is essentially exactly the same as rectangle editing
07:13:59 <mm_freak> merijn: tried it, didn't work
07:13:59 <flux> in fact, what would be cool would be to have a real-time application of said macro to following blocks, as you type the macro in..
07:14:23 <merijn> ctrl-v (block visual), shift-g (jump to last line), e (jump to end of next word), d (delete), $ (jump to end of line), p (paste)
07:14:29 <mm_freak> flux: you can use C-u in a macro
07:15:13 <flux> mm_freak, and it does what? or do you mean the normal undo mechanism?
07:15:31 <merijn> mm_freak: Odd, might be some vi compatibility setting in your vim config (or rather, most likely lack thereof)
07:15:55 <byorgey> laar: http://www.haskell.org/cabal/users-guide/#accessing-data-files-from-package-code but unfortunately it does not mention anything about the version
07:16:21 <byorgey> laar: if you 'cabal build' your package, you can look at the generated Paths module in dist/build/autogen
07:16:26 <mm_freak> merijn: it went into visual mode, but it totally messed up the entire file
07:16:42 <merijn> visual mode is wrong, ctrl-v should jump to block visual
07:16:43 <mm_freak> merijn: and it only moved a single character
07:16:49 <koeien> mm_freak: this is what vim users always have :)
07:16:58 <mm_freak> merijn: it says VISUAL BLOCK at the bottom
07:17:02 <merijn> hmm, weird
07:17:15 <mm_freak> flux: yes, normal undo
07:17:15 * merijn goes of to check whether he missed something
07:17:31 <koeien> maybe :set nocompatible
07:17:38 <flux> mm_freak, well, it helps sometimes. (btw, isn't C-u normally universal argument?)
07:17:40 <merijn> koeien: That's what I was guessing
07:17:48 <mm_freak> let me try again
07:17:57 <merijn> But no sane vim config has compatible on
07:18:04 <mm_freak> merijn: shift-g is certainly not what i want
07:18:09 <laar> byorgey thanks, it contains a Version and that should be more than enough
07:18:28 <merijn> mm_freak: If you have more in the file you probably want 5j (or whatever number of lines you have)
07:18:44 <mm_freak> merijn: now it worked
07:18:56 <mm_freak> ok yeah, that's the same mechanism
07:19:24 <merijn> My life improved so much on the day I learned of block-visual :)
07:19:40 <mm_freak> yeah, the same happened to me with emacs rectangles =)
07:19:57 <mm_freak> flux: sorry, i meant C-x u
07:20:03 <merijn> I think there is only one change that had a bigger positive impact to time-invested ratio
07:20:09 <mm_freak> i type the key combinations so intuitively, i really forget what they are ;)
07:20:19 <merijn> Rebinding bash arrow keys to forward and backward history search
07:20:33 <mm_freak> i use zsh with emacs bindings
07:20:39 * koeien has set -o vi
07:20:50 <merijn> (i.e. "ssh " followed by up arrow only screws through history commands starting with "ssh ")
07:20:53 <merijn> errr
07:20:59 <merijn> s/screws/scrolls
07:21:01 <mm_freak> well, does vim have something like emacs buffers?
07:21:08 <merijn> Dunno wtf I was thinking there
07:21:19 <koeien> registers
07:21:25 <int-e> C-_ (ctrl + shift + -) is a standard binding, I believe, and much easier to tupe repeatedly than C-x u
07:21:30 <mm_freak> merijn: beavis and butthead perhaps =)
07:21:35 <merijn> I think registers? But I hardly use those
07:21:42 <mm_freak> "huh-huh…  screws…  huh-huh huh-huh…"
07:21:48 <koeien> i'm not sure what emacs buffers are
07:21:54 <mm_freak> windows basically
07:21:55 <koeien> just a view on a file?
07:21:58 <mm_freak> editor buffers
07:21:59 <dolio> Buffers are where the text is.
07:21:59 <koeien> yes they exist
07:22:24 <merijn> mm_freak: They're called buffers in vim :p
07:22:30 <mm_freak> hehe ok
07:22:59 <merijn> I heard some people say they're less convenient, and maybe for large numbers of files they are, but I never really noticed that much
07:23:10 <mm_freak> int-e: depends on your keyboard layout…  by using C-x b so often i got used to type these awkward key sequences
07:23:14 <koeien> i have some bindings for next-window and stuff
07:23:21 <koeien> the C-w bindings are annoying
07:23:24 <mm_freak> in fact i've bound "make" to C-c c
07:23:41 <hughfdjackson_> just to clarify a thought that's been rattling on my brain
07:23:41 <flux> what vim doesn't have, though, is align-regexp and dynamic expansion! my code will be sooo pretty with soo long identifiers! also, org-mode.
07:23:47 <flux> I'm feeling this discussion isn't very productive :)
07:23:55 <merijn> As I mentioned, these two lines improve quality of life immeasurably when added to .inputrc:"\e[A": history-search-backward      "\e[B": history-search-forward
07:23:57 <hughfdjackson_> pure functional and imperative are mutually exclusive descriptors, right?
07:24:05 <merijn> hughfdjackson: No
07:24:12 <int-e> mm_freak: my problem is that when I want to undo a longer sequence of edits I mess up the timing, usuually ending up with typing a literal 'u' ... then to undo further, I first have to redo everything ... awkward.
07:24:25 <koeien> flux: what's "dynamic expansion"? :)
07:24:26 <hughfdjackson_> merijn: ah, well now i feel way off base
07:24:30 <merijn> hughfdjackson_: Haskell has imperative programming and is pure (well, okay, it isn't 100% pure, but that is not because of imperative programming)
07:24:43 <merijn> unsafePerformIO and friends make it unpure :p
07:24:47 <hughfdjackson_> ehehe
07:24:47 <dominikh> int-e: look into undo-tree
07:24:53 <mm_freak> int-e: then i usually just use a macro
07:24:53 <flux> koeien, you write a word, like fofol, hit M-/ and it finds you the closest fofol-word and expands with that. pressing again rotates along other candidates.
07:24:54 <hughfdjackson_> but thats kinda what i'm getting at
07:25:06 <mm_freak> int-e: F3 C-x u C-e e e e e e e …
07:25:06 <merijn> hughfdjackson: You can do IO without unsafePerformIO, though
07:25:09 <koeien> flux: vim ha that :)
07:25:12 <hughfdjackson_> it's level of impurity is directly proportional to its level of imperitiveness?
07:25:16 <parcs`> flux: so name completion? :P
07:25:18 <flux> bah, I was sort of guessing it wouldn't ;)
07:25:24 <flux> koeien, from all open buffers?
07:25:30 <hughfdjackson_> :D i'm thinking more broadly than of haskell particularly
07:25:30 <koeien> I'm not sure.
07:25:36 <parcs`> flux: yes
07:25:38 <parcs`> ^P and ^N
07:25:49 <int-e> mm_freak: hehe. dominikh: thanks for the hint.
07:25:53 <merijn> hughfdjackson: No, they are orthogonal. Most imperative haskell code is completely pure.
07:26:03 <flux> that's be so useful to me when I need to use vi(m), thanks :)
07:26:12 <dolio> Purity is about not having to worry what order in which things are evaluated.
07:26:15 <mm_freak> anyway, enough editor talk =)
07:26:21 <hughfdjackson_> the state monad is not imperative, right?
07:26:25 <hughfdjackson_> as an example
07:26:30 <merijn> Editor talk should probably go to -blah now
07:26:32 <mm_freak> hughfdjackson_: yes, it is
07:26:40 <hughfdjackson_> u.u *now* my brain hurts
07:26:49 <hughfdjackson_> i think my definition of imperative is a bit off-base
07:27:01 <mm_freak> hughfdjackson_: note that imperative is a /style/, not an implementation detail
07:27:08 <mm_freak> with state monads you certainly use an imperative style
07:27:17 <mm_freak> like:  x <- get; put (x + 1)
07:27:40 <dolio> When you have purity, and you write 'x + y' you don't need to worry whether x or y gets evaluated first, because it doesn't matter.
07:27:47 <merijn> hughfdjackson_: Imperative basically means "the program state on line X is dependent on the execution of all lines before X"
07:28:01 <hughfdjackson_> aha :) sense is made now
07:28:02 <merijn> hughfdjackson_: You can basically see each line as modifying the program state
07:28:24 <merijn> hughfdjackson_: Which is perfectly obvious in, say, python or C
07:28:30 <mm_freak> hughfdjackson_: on a more fundamental level, imperative programming is thinking in commands
07:28:38 <mm_freak> declarative programming is thinking in relationships
07:28:54 <hughfdjackson_> :P my programming is lucky if it gets thought about at all
07:28:57 <hughfdjackson_> *ba dum chish*
07:29:02 <hughfdjackson_> (its not true, don't sack me)
07:29:24 <hughfdjackson_> i can see the former, but the latter boggles my brain a bit more, mm_freak
07:29:52 <merijn> hughfdjackson_: The classical example is that "x = 5" means (in C), change the program state in such a way that the location of the variable named x contains 5"
07:30:14 <merijn> hughfdjackson_: In haskell "x = 5" means "the name x is an alias for the value 5"
07:30:16 <mm_freak> hughfdjackson_: add x 0 = x;  add x y = add (succ x) (pred y)
07:30:20 <mm_freak> that's declarative
07:30:27 <hughfdjackson_> :D i think i can hear the voice of SPJ in my head
07:30:50 <cheater_> flux: you can even write a configurable function which generates those
07:30:51 <mm_freak> a bad example, but a declarative one =)
07:30:57 <cheater_> flux: the completions, that is
07:31:02 <hughfdjackson_> cheers, mm_freak
07:31:06 <hughfdjackson_> that makes it clearer
07:31:23 <niteria> ok smart people from #haskell, can someone recommend me introductory textbook on probability form CS students? Ideally it would just skim over measures and concentrate on discreete stuff
07:31:26 <mm_freak> hughfdjackson_: in declarative programming the '=' sign introduces an equation
07:31:31 <niteria> *for
07:31:39 <merijn> hughfdjackson_: You can see a declarative program as being a unsorted graph of definitions that refer to eachother and telling the compiler to "sort it out"
07:31:57 <hughfdjackson_> ahaha
07:32:07 <mm_freak> hughfdjackson_: so if you say y = x + 1, then that's an equation defining a equality relationship between y and x + 1
07:32:09 <hughfdjackson_> i see what you mean, thinking about the 'spreadsheet' example
07:32:11 <merijn> Which is why you can have functions and expressions out of order
07:32:13 <cheater_> flux: eg you could have something analyze the ASTs of your complete project, and only offer completions of the same kind: eg if it thinks you're writing a function, then only offer completion to names of other functions... obviously the same goes if you're writing for a specific type and you want to use lenses on it or something, you could use accessors only for that type
07:32:24 <hughfdjackson_> and the 'pure functions could be lookup tables of infinite size' way of thinking
07:32:53 <hughfdjackson_> (i hope those two references make sense out of context)
07:33:03 <merijn> hughfdjackson: Spreadsheets are pretty declarative, yes
07:33:20 <mm_freak> > fix (1:)
07:33:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:33:28 <mm_freak> a declarative description of an infinite list of ones =P
07:33:46 <merijn> > let infiniteList = 1 : infiniteList in infiniteList
07:33:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:33:58 <hughfdjackson_> mind = blown ;)
07:33:58 <merijn> Same thing, but hopefully easier to follow :p
07:34:08 <mm_freak> > repeat 1
07:34:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:34:12 <mm_freak> same thing, but really easy to follow =)
07:34:56 <mm_freak> if you write the lambda out in 'fix', it makes it orders of magnitude easy to understand for beginners
07:34:57 <hughfdjackson_> :| from an outsider's perspective, one might conclude the prelude includes enough repetition to preclude easy memorization without frequent interlude
07:35:06 <mm_freak> > fix (\xs -> 1 : xs)
07:35:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:35:13 <mm_freak> > let xs = 1 : xs in xs
07:35:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:35:25 <merijn> hughfdjackson: That's why we have Hoogle which lets you search based on type signatures :p
07:35:31 <hughfdjackson_> merijn: :D bonus
07:35:34 <merijn> That way you only have to figure out the function type you want
07:35:45 <byorgey> niteria: "Concrete Mathematics" has a good introduction to discrete probability
07:36:06 <byorgey> it's just one chapter, not a whole book, not sure how deep of an introduction you're looking for
07:36:19 <mm_freak> which is a lot easier in haskell, because the type of a function is very informative
07:36:19 <merijn> hughfdjackson: Now, *sometimes*, you do want to explicitly order some operations. Say, for example, IO. This is where imperative style comes in handy as the rest of our program's behaviour depends on the result of reading input for example
07:36:54 <niteria> byorgey: I need something that covers markov chains
07:37:02 <hughfdjackson_> or in a gui for blitting?
07:37:16 <byorgey> niteria: ah, ok, in that case I don't know
07:37:23 <niteria> I forgot I had Concrete Mathematics on my bookshelf
07:37:32 <merijn> hughfdjackson_: Well, GUIs are basically just IO but prettier :p
07:37:39 <hughfdjackson_> merijn: xD point taken
07:37:46 <nand`> > [1,1..]
07:37:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:37:47 <merijn> Haskell monads are just a nice abstraction for making this ordering of operations explicit
07:37:53 <hughfdjackson_> its hard for me to think lazily sometimes
07:38:19 <Scriptor> it's another challenge on top of just thinking functionally
07:38:26 <niteria> :t fix
07:38:27 <lambdabot> forall a. (a -> a) -> a
07:38:33 <niteria> > fix fix
07:38:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
07:38:37 <byorgey> > let ones = 1 : 1 : zipWith max ones (tail ones) in ones
07:38:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:38:50 <mm_freak> > [ x | x : _ <- tails [1..] ]
07:38:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:38:54 <mm_freak> uh
07:39:01 <Scriptor> alright, I think we've seen enough ways to make infinite lists
07:39:01 <hughfdjackson_> hah
07:39:02 <mm_freak> > [ x | x : _ <- inits [1..] ]
07:39:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:39:03 <hughfdjackson_> combo brrrreaker
07:39:07 <hughfdjackson_> :D
07:39:09 <byorgey> hehehe
07:39:19 <Scriptor> let's just paste the line of code instead of making lambdabot evaluate it
07:39:19 <merijn> niteria: Fix really only makes sense for functions that produce partial output (appending to lists, etc)
07:39:30 <mauke> > [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
07:39:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
07:39:31 <merijn> Err, prepending I guess
07:39:34 <mauke> > [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
07:39:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:39:39 <mauke> there we go
07:39:51 <Scriptor> now it's just annoying
07:40:05 <mauke> > var "[1,1,1,...]"
07:40:06 <lambdabot>   [1,1,1,...]
07:40:13 <merijn> Anyhoo, time to go home
07:40:18 <byorgey> mauke: amazing! lambdabot is smart enough to continue the pattern!
07:40:19 <mm_freak> > genericReplicate (fix Succ) 1
07:40:20 <lambdabot>   Not in scope: data constructor `Succ'
07:40:22 <mm_freak> too bad
07:40:24 <Scriptor> no, ad
07:40:25 <niteria> > fix $ fix (:1)
07:40:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:40:27 <Scriptor> *bad
07:40:29 <niteria> > fix $ fix (1:)
07:40:30 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[t]'
07:40:49 <mm_freak> there is no Nat type in lambdabot's library?
07:41:11 <byorgey> mm_freak: guess not. You can use Fix Maybe  instead. ;)
07:41:16 <niteria> @hoogle fix
07:41:17 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
07:41:17 <lambdabot> Data.Fixed module Data.Fixed
07:41:17 <lambdabot> Data.Function fix :: (a -> a) -> a
07:41:28 <mm_freak> byorgey: but that's not a Num =)
07:41:36 <byorgey> mm_freak: ah, so it isn't
07:41:58 <mm_freak> genericReplicate (fix Succ) 1 should actually work
07:42:09 <mm_freak> at least for a nonstrict Succ
07:43:59 <mm_freak> > [()] + [()]
07:43:59 <lambdabot>   No instance for (GHC.Num.Num [()])
07:43:59 <lambdabot>    arising from a use of `GHC.Num.+' at ...
07:44:48 <byorgey> > cata (maybe [] (1:)) (fix (In . Just))
07:44:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:45:15 <mm_freak> > iterate id 1
07:45:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:47:45 <frerich2> Is there a way to get the (possibily infinite) decimal representation of some 'Rational'? E.g. '1 / 3 :: Rational' should result in "0.33333333..."
07:48:01 <frerich2> I mean, of course there is a way, but is there a ready-made function for this.
07:48:45 <ChristianS> you want to print an infinite representation?
07:49:21 <frerich2> ChristianS: No, not necessarily print it; I'd like to have it, take the first 'n' digits of it and then work with those.
07:49:40 <frerich2> Say, the first 1000 digits of some decimal representation of a Rational value.
07:49:54 <koeien> CReal perhaps
07:50:17 <Veinor> it looks like there isn't
07:50:18 <Veinor> weird
07:50:30 <matthiasgorgens> frerich2, you could take a rational value (1%3) multiply with 10**1000, and take the integral part.
07:50:40 <matthiasgorgens> and `show' it.
07:50:40 <rostayob> frerich2: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
07:51:00 <rostayob> + fromRational
07:51:17 <dolio> CReals show at a specified precision.
07:51:29 <frerich2> Oh yes, showCReal sounds really good.
07:53:33 <frerich2> :t showCReal
07:53:34 <lambdabot> Int -> CReal -> String
07:53:40 <elliott> You don't want CReal.
07:53:45 <elliott> Unless you don't want equality.
07:54:09 <rostayob> elliott: he wants to show an arbitrary number of digits => he wants CReal
07:54:10 <elliott> Wanting to be able to compute 0.3 recurring for 1/3 is not the same thing as wanting the entire computable reals...
07:54:17 <elliott> rostayob: What?
07:54:18 <maurer> To anyone wondering about the bug I encountered yesterday, it seems I accidentally pulled in a development version of Cabal which has that error
07:54:21 <elliott> You can do that with Rational.
07:54:32 <elliott> You might have to write your own decimal conversion function, but you can do that with Rational.
07:54:32 <koeien> elliott: enlighten us :D
07:54:35 <koeien> right
07:54:39 <cmccann> elliott, hey, check it out: https://github.com/isomorphism/esoteric-fractals/blob/master/Make/Makefile
07:54:46 <rostayob> elliott: yeah exactly, you have to hack something up
07:54:56 <elliott> There's an easy way to solve this.
07:55:00 <elliott> frerich2: Are you OK if (x == x) never terminates?
07:55:20 <elliott> cmccann: that's amazing
07:55:32 <rostayob> elliott: I think his goal is just to show an arbitrary number of digits, so he'll just do 'showCReal . fromRational'
07:55:39 <cmccann> elliott, see also https://github.com/isomorphism/esoteric-fractals/blob/master/Make/output.txt
07:55:56 <elliott> rostayob: That seems like massive overkill (and another library) just for one decimal conversion, but okay.
07:56:03 <dolio> showCReal doesn't produce an arbitrary number of digits.
07:56:09 <elliott> I also suspect it'll be rather less efficient than just writing a ~5 line conversion routine.
07:56:16 <dolio> It produces however many you tell it to.
07:56:21 <elliott> Also, what dolio said; you can just multiply + show with a Rational.
07:56:24 <frerich2> elliott: Yes, that's fine. I'm just playing little games here. For instance
07:56:29 <elliott> Then the only tricky part is stuffing the decimal point in the right place.
07:56:38 <elliott> (And that's one function call.)
07:56:41 <frerich2> > let s = showCReal 100 (1 / 998001 :: CReal) in drop 2 s
07:56:42 <lambdabot>   "00000100200300400500600700800901001101201301401501601701801902002102202302...
07:56:45 <elliott> cmccann: awesome
07:57:01 <dolio> To get higher and higher precision, you'd have to keep calling showCReal at those higher precisions.
07:57:30 <frerich2> I'm just tinkering with decimal representations for now, CReal works nicely.
07:57:37 <rostayob> cmccann: that is incredible.
07:58:14 <cmccann> rostayob, that's one word for it
07:59:16 <rostayob> cmccann: it's pretty resource intensive too.
07:59:27 <cmccann> elliott, I'm thinking I should do a Haskell type-level mandelbrot as well but it's hard to draw pictures with GHC error messages :[
07:59:47 <elliott> cmccann: just defer the printing until runtime?
07:59:54 <copumpkin> cmccann: typeclasses to convert your types into values you can print
07:59:58 <elliott> you can still assemble the "string" in the type system
08:00:03 <rostayob> cmccann: do you mind if I submit to HN?
08:00:11 <Sgeo> :t showCReal
08:00:12 <lambdabot> Int -> CReal -> String
08:00:37 <cmccann> rostayob, I was actually surprised by how fast it runs, given how horrible the implementation is
08:01:01 <dolio> > 1/3 :: CReal
08:01:02 <lambdabot>   0.3333333333333333333333333333333333333333
08:01:11 <rostayob> cmccann: ehe.
08:01:12 <elliott> cmccann: TypeNats will take all the fun out of type-system programming :(
08:01:34 <cmccann> and it seems like cheating for a type level version if you have to actually run the resulting program
08:02:00 <elliott> cmccann: you don't have to
08:02:04 <elliott> you could just grep for the string in the executable
08:02:26 <elliott> hmm, assuming ghc will "inline" the typeclass stuff enough, I guess
08:02:44 <cmccann> rostayob, and uh... submit it if you want, I guess?
08:02:45 * cmccann shrugs
08:03:16 <cmccann> elliott, meh
08:03:25 <cmccann> I'd still rather get output via compiler errors
08:03:35 <elliott> cmccann: sounds like giving up to me!
08:03:46 <elliott> cmccann: i guess you could do line
08:03:47 <elliott> like
08:04:07 <elliott> (Brot (Line a b c d ...) (Line ...) ...)
08:04:08 <elliott> with well-chosen letters
08:04:14 <elliott> and hope the compiler formats it properly
08:04:34 <cmccann> yeah, that would be the rough idea
08:05:04 <elliott> cmccann: hey, instead of printing it out in ascii, compute an XBM (or whatever) image string at compile-time and print it out at runtime
08:05:17 <elliott> anyone who says it's cheating is encouraged to write their own type-level XBM library :D
08:05:29 <cmccann> haha
08:05:52 <cmccann> ok yeah that's ridiculous enough that I could deal with it
08:06:08 <cmccann> hm
08:06:34 <elliott> Has anyone calculated pi in the type system yet?
08:06:41 <elliott> (With a parametrised number of digits.)
08:07:27 <elliott> (#haskell game: mentally append "in the type system" to every message)
08:09:34 <cmccann> elliott, I wouldn't think it'd be difficult given basic arithmetic and looping constructs, which are straightforward enough
08:10:33 <elliott> cmccann: It's just a small matter of incredibly painful programming.
08:10:52 <elliott> Anyway, arithmetic is more difficult once you step outside pure Peano numbers (which you'd probably have to for the Mandelbrot, anyway).
08:11:15 <cmccann> ...did you look at the arithmetic in that makefile? :P
08:11:31 <Enigmagic> also: compiles so slow you may wonder if any progress is being made at all
08:11:32 <cmccann> starting with peano numerals would be an improvement
08:11:37 <elliott> cmccann: Make is faster than GHC.
08:11:55 <elliott> cmccann: Anyway, with Haskell you'd have to compute the ASCII values to output at compile time.
08:12:45 <cmccann> still, straightforward to implement. just very slow to "run".
08:13:06 <byorgey> www.cs.ox.ac.uk/jeremy.gibbons/publications/spigot.pdf would probably be a good place to start for computing pi in the type system
08:13:24 <elliott> cmccann: It doesn't count if you can't run it.
08:13:31 <nand`> >shittons := $(call MUL,$(twofivesix),$(twofivesix))
08:13:36 <nand`> that's one way to name things
08:13:51 <elliott> Maybe I'll write an efficient non-Peano type-level number library and put it on Hackage.
08:13:52 <cmccann> nand`, whatever works
08:13:58 <elliott> You know, to reduce code duplication for important things like this.
08:14:12 <byorgey> elliott: doesn't something like that already exist?
08:14:15 <cmccann> elliott, yes, that is an excellent plan.
08:14:19 <cmccann> especially if one already exists
08:14:32 <Enigmagic> @hackage type-level
08:14:32 <lambdabot> http://hackage.haskell.org/package/type-level
08:14:43 <elliott> I think that's just Peano.
08:14:52 <elliott> "Type-level numerical representations. Currently, only decimals are supported."
08:14:54 <elliott> Eww.
08:16:08 * byorgey was sure he'd seen a package with type-level binary naturals
08:16:23 <cmccann> I've written a couple versions of that myself
08:16:27 <elliott> Also, that thing uses fundeps. Type families are the future!!!
08:16:38 <cmccann> fundeps are necessary for TypeEq anyway
08:16:50 * elliott hasn't had to use TypeEq in his hackery yet.
08:16:57 <elliott> Can't you do it with type families + ridiculous other extensions?
08:16:58 <cmccann> yeah, it's not always needed
08:17:00 <cmccann> nope
08:17:09 <cmccann> at least not last I checked
08:17:15 <elliott> That sucks.
08:17:25 <cmccann> it relies on disreputable overlapping that TFs forbid.
08:17:36 <elliott> Overlapping/IncoherentInstances
08:17:36 <elliott> ?
08:17:43 <elliott> I don't think TFs forbid anything outright if you use those.
08:17:43 <cmccann> just overlapping
08:17:52 <elliott> So it works with OverlappingInstances?
08:17:52 <byorgey> no, overlapping of type family clauses
08:17:57 <elliott> Ah.
08:18:03 <mekeor> can i write "[ x+y | x<-[1..5] | y<-[6..10] ]"  instead of "[ x+y | x<-[1..5], y<-[6..10] ]" ? i mean "|" instead of a comma (",")...
08:18:14 <elliott> Wrap it in a type-class so it can't "see" the overlapping? I guess that doesn't make sense.
08:18:17 <elliott> mekeor: it means something else
08:18:20 <elliott> and is a GHC extension
08:18:23 <elliott> (it zips the two lists)
08:18:27 <mekeor> oh, okay.
08:18:28 <elliott> i.e. it's (x,y) <- zip [1..5] [6..10]
08:18:31 <mekeor> thanks anyway.
08:18:42 <byorgey> FYI, there is currently preliminary work to extend type families with the ability to have blocks of overlapping clauses which are tried in order.
08:18:45 <mekeor> @src zip
08:18:46 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
08:18:46 <lambdabot> zip _      _      = []
08:18:50 <mekeor> good.
08:21:10 <cmccann> byorgey, nice! that basically allows closed families, doesn't it?
08:21:32 <cmccann> and therefore type-level functions that actually behave like such
08:21:52 <elliott> "At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'"
08:21:55 <byorgey> cmccann: well, closed families would be orthogonal I think
08:21:57 <elliott> I hate this restriction so much.
08:22:04 <byorgey> but they would also be quite useful.
08:22:13 <dolio> Closed families would be a sufficient condition for the overlapping to be safe.
08:22:39 <byorgey> indeed, but not necessary.
08:22:40 <cmccann> byorgey, if you have overlapping clauses tried in order, and the last clause is maximally generic, then any other instance would be disallowed, right?
08:22:48 <rostayob> elliott: you just want to do arbitrary type level computations?
08:22:48 <dolio> What condition are you using?
08:22:51 <byorgey> cmccann: oh, I see what you mean, yes.
08:23:05 <elliott> rostayob: In general? Duh.
08:23:12 <elliott> What do you think I use Haskell for?!
08:23:16 <rostayob> right.
08:23:23 <rostayob> how naive of me
08:23:28 <hpc> heh
08:24:02 <byorgey> dolio: you could have an overlapping block   f [Int] = ...; f [a] = ...;  and then elsewhere in another module it would still be safe to add  f Int = ...
08:24:23 <dmwit> cmccann: (...but that requires the type family to be defined for all types, which closed type families wouldn't.)
08:24:50 <cmccann> dmwit, ah, hm
08:25:21 <dolio> byorgey: So, overlap is only allowed among definitions in a single block?
08:25:27 <byorgey> dolio: right.
08:25:28 <dolio>  /module
08:25:31 <dolio> Okay.
08:25:42 <cmccann> dmwit, not sure how much of an obstacle that would be though, I suspect a workaround would be possible but I'm not certain
08:25:53 * hackagebot c-storable-deriving 0.1 - Generate C-like storable instances from datatypes  http://hackage.haskell.org/package/c-storable-deriving-0.1 (MatthewMaurer)
08:28:38 * cmccann wonders if that makefile is technically the most well-commented piece of code he's written
08:29:12 <elliott> type families are kind of disappointing
08:29:22 <cmccann> elliott, how so?
08:29:22 <elliott> in that they make it way too easy to write things compared to fundeps
08:29:26 <cmccann> haha
08:29:34 <elliott> you just turn on UndecidableInstances and it's basically Haskell
08:29:46 <cmccann> it's not that different, really
08:30:36 <dolio> Haskell with a terrible degenerate type system and bad syntax.
08:30:44 <dolio> Until 7.4, possibly.
08:30:56 <elliott> dolio: Yeah, but it's even nicer than C++ templates.
08:30:58 <byorgey> in 7.4 the type system is better but the syntax is still bad.
08:31:07 <elliott> Which is Haskell with a terrible degenerate type system and the worst possible syntax.
08:31:31 <dolio> Are type level naturals actually a distinct kind from *?
08:31:39 <dolio> Unlike, what you'd get with SHE.
08:31:50 <elliott> dolio: considering it's arbitrary type lifting, I'd hope so...
08:31:59 <elliott> or, hmm
08:32:06 <elliott> is the type lifting coming later than 7.4?
08:32:18 <dolio> Well, SHE has all kinds of automatic promotion, but it turns everything into *, since it's just a preprocessor.
08:32:25 <elliott> actually C++ templatse are a bit too easy because they give you integers
08:32:34 <elliott> dolio: well they are different kinds
08:32:36 <elliott> so i'd hope they're checked
08:32:47 <rostayob> http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml . that is all there is to say about C++ templates
08:33:15 <byorgey> dolio: yes
08:33:21 <dolio> That's reassuring.
08:35:00 <cmccann> rostayob, didn't someone make a Haskell version of those?
08:35:33 <byorgey>  Kind mis-match: The second argument of `Vec' should have kind `Nat', but `Int' has kind `*'   -- an actual error message produced by GHC 7.4
08:35:48 <rostayob> cmccann: with quasi-quoting, we could
08:35:56 <elliott> cheating
08:36:08 <cmccann> no, someone did it without TH
08:36:19 <rostayob> cmccann: how do you do that?
08:36:20 <cmccann> using an extreme version of the printf hack, as I recall
08:36:27 <rostayob> ah
08:36:39 <rostayob> yeah but you have to enclose everything in a multiline string
08:36:59 <elliott> huh?
08:36:59 <rostayob> with OverloadedStrings it's easy
08:37:02 <elliott> hmm
08:37:10 <elliott> i doubt it's that
08:37:10 <cmccann> what? no, not strings.
08:37:14 <elliott> I suspect cmccann just means, using letters to replace the symbols
08:37:17 <elliott> so they're valid identifiers
08:37:20 <rostayob> ah
08:37:23 <cmccann> http://paczesiowa.blogspot.com/2010/07/two-dimensional-analog-literals-in.html
08:37:28 <cmccann> I think that's what I was remembering
08:37:53 <elliott> meh, stopped before 3d
08:37:59 <cmccann> yeah :T
08:38:03 <elliott> C- subpar type-level hackery, would not read again
08:38:13 <cmccann> better do the 3D version yourself then
08:38:23 <elliott> A+++ blog post is already perfect, previous opinion incorrect
08:39:45 <int-e> @karma A+
08:39:45 <lambdabot> A+ has a karma of 1
08:39:57 <elliott> +++
08:39:58 <elliott> @karma +
08:39:59 <lambdabot> + has a karma of 7
08:40:10 <_Mikey> @karma +
08:40:10 <lambdabot> + has a karma of 7
08:40:12 <elliott> test1++test2++
08:40:13 <elliott> @karma test1
08:40:14 <lambdabot> test1 has a karma of 0
08:40:14 <elliott> @karma test2
08:40:15 <lambdabot> test2 has a karma of 0
08:40:18 <elliott> @karma test1++test2
08:40:18 <lambdabot> test1++test2 has a karma of 1
08:40:53 * hackagebot persistent-protobuf 0.1.2 - Template-Haskell helpers for integrating protobufs with persistent.  http://hackage.haskell.org/package/persistent-protobuf-0.1.2 (MichaelStone)
08:40:55 <_Mikey> hmmm how can I define an instance of show for  my type (Int->Int)
08:41:16 <elliott> _Mikey: wrap it in a newtyp
08:41:17 <elliott> e
08:41:25 <_Mikey> :o!
08:41:25 <elliott> otherwise you need FlexibleInstances and it won't do what you want
08:41:35 <_Mikey> Awesome
08:41:38 <_Mikey> cheers elliott
08:41:43 <elliott> :)
08:41:51 <rostayob> _Mikey: you're defining a show instance for (Int -> Int)?
08:42:02 <rostayob> how does that look like?
08:42:20 <elliott> probably like <Function I can't display so here's a dummy string instead>
08:42:31 <koeien> or the image of a subset of N
08:42:41 <_Mikey> yea
08:42:47 <_Mikey> just a dummy string
08:42:58 <rostayob> _Mikey: I'd rather have some dummyString function then...
08:43:17 <elliott> rostayob: showing complex structures with the functions in them
08:43:26 <elliott> if you have a lot of derived instances etc.
08:43:38 <elliott> it's ok as long as it's in a newtype imo
08:43:52 <rostayob> yeah in a newtype is acceptable
08:44:06 <_Mikey> cool
08:44:33 <int-e> The Shoe instance could do something more useful, too. "..., f(-2) = 23, f(-1) = 0, f(0) = 1, f(1) = 3, f(2) = 4711, ..."  'Show' is not quite the right class for this purpose, but few people will really care if it's a newtype.
08:44:50 <int-e> Oh. A shoe? Interesting typo.
08:44:58 <elliott> class Shoe a where ...
08:44:59 <cheater_> i was wondering wtf.
08:45:01 <cheater_> :)
08:45:22 <elliott> int-e: Better to interleave positives and negatives, then it generalises to Integers too with only a right-infinite result
08:45:31 <Sgeo> int-e, is it really that useful to start from minBound?
08:45:51 <int-e> Sgeo: I didn't mean to start from minBound, the ... were meant literally.
08:45:53 <elliott> int-e: Anyway, you can make it valid Haskell.
08:45:55 <cmccann> elliott, in other words, alternate between the left shoe and the right shoe? :D
08:46:09 <elliott> show f --> "(`lookup` [(0,1), (1,3), ...])"
08:46:14 <elliott> You can even give it a Read instance.
08:46:29 <elliott> cmccann: Precisely!
08:47:04 * cmccann once wrote a type class that serialized "arbitrary" functions to an Integer
08:47:11 <elliott> Did it use the RTS?
08:47:15 <cmccann> no
08:47:20 <elliott> Aww.
08:47:21 <cmccann> it did it the obvious and stupid way
08:47:31 <elliott> I'm not sure what the obvious way is. peek?
08:47:39 <elliott> Hmm, no.
08:47:53 <int-e> serialize f = 0 -- TODO: implement deserialize
08:49:24 <unknownwarrior> hey guys. do you know what this error message means? Occurs check: cannot construct the infinite type: a1 = [a1] i only use head, tail and reverse on a given list ..
08:49:52 <int-e> unknownwarrior: please show actual code.
08:49:53 <elliott> unknownwarrior: Can you hpaste your code?
08:49:54 <_Mikey> elliot?
08:49:59 <rostayob> unknownwarrior: you probably have something like 'tail (head x)'
08:50:01 <elliott> _Mikey: ?
08:50:15 <_Mikey> previously I was using a type synonym for (Int->Int)
08:50:16 <unknownwarrior> rostayob, thats true
08:50:16 <rostayob> unknownwarrior: anyway, paste the code
08:50:22 <int-e> > let f xs = xs : xs in f []
08:50:23 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:50:23 <unknownwarrior> okey
08:50:39 <_Mikey> now everywhere I use the type synonym doesn't match the newtype is that normal?
08:50:46 <mm_freak> > concat . iterate (map (liftA2 (+) id signum)) $ [1, -1]
08:50:46 <elliott> _Mikey: Yes, you have to use the constructor.
08:50:47 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
08:50:56 <elliott> newtype is basically like a "data" with only one field and no runtime overhead.
08:50:58 <cmccann> elliott, by testing all inputs, serializing the outputs, then combining them using a place value system
08:51:08 <elliott> cmccann: ah, so not "arbitrary" then
08:51:13 <int-e> > zip [0..] [-1,-2..]
08:51:15 <lambdabot>   [(0,-1),(1,-2),(2,-3),(3,-4),(4,-5),(5,-6),(6,-7),(7,-8),(8,-9),(9,-10),(10...
08:51:39 <cmccann> elliott, any function whose input and output types were also instances of the class
08:51:39 <_Mikey> so if my constructor is the same as my old name for my type synonym it should work finr?
08:51:41 <_Mikey> so if my constructor is the same as my old name for my type synonym it should work fine?
08:51:45 <hpaste_> unknownwarrior pasted “temp” at http://hpaste.org/56922
08:52:00 <int-e> > concat (transpose [[0..],[-1,-2..]]) -- oops.
08:52:01 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
08:52:03 <cmccann> and the result would be an Integer between 0 and the number of values inhabiting the type
08:52:16 <elliott> _Mikey: No.
08:52:29 <int-e> I believe that 'transpose' is really underappreciated :)
08:52:32 <elliott> _Mikey: If you do
08:52:34 <mm_freak> > 0 : concat [ [x, -x] | x <- [1..] ]
08:52:35 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
08:52:35 <elliott> newtype Foo = Foo (Int -> Int)
08:52:43 <elliott> then you do (Foo f) where (f :: Int -> Int) to get a Foo
08:52:47 <matthiasgorgens> If I have a function like f :: a -> b -> c, and a function g :: a -> d, f .g will have the type d -> b -> c.  What's the most light-weight way to manipulate the second argument instead?
08:52:48 <elliott> and you can pattern-match on it, i.e.
08:52:50 <elliott> blah (Foo f) = ...
08:53:05 <unknownwarrior> let abc = ":)"
08:53:08 <unknownwarrior> abc
08:53:10 <unknownwarrior> :(
08:53:29 <_Mikey> ok but in type signatures I can use Foo?
08:53:45 <elliott> matthiasgorgens: (\x y -> f x (g y)) -> (\x -> f x . g) -> (g .) . f, I think.
08:54:00 <unknownwarrior> rostayob, i pasted my code
08:54:04 <elliott> matthiasgorgens: I would stick with the lambda form, but you might be interested in: http://conal.net/blog/posts/semantic-editor-combinators
08:54:05 <unknownwarrior> rostayob, what can i do?
08:54:09 <elliott> which let you write things like that without the noise.
08:54:11 <elliott> _Mikey: Yes.
08:54:26 <rostayob> unknownwarrior: where?
08:54:28 <_Mikey> elliott: ok thanks
08:54:40 <unknownwarrior> rostayob, http://hpaste.org/56922
08:54:44 <int-e> mm_freak: pointless version: (0:) $ [1..] >>= ap (:) ((:[]) . negate)
08:55:18 <mm_freak> > [0..]>>=\x->[x+1,-x]
08:55:18 <lambdabot>   <no location info>: parse error on input `->'
08:55:19 <rostayob> unknownwarrior: you're using ++ with a single element
08:55:19 <matthiasgorgens> elliott, thanks. I'd like to avoid the lambda-form here.  To give you more context, I'm trying to decide on the order of arguments for a function.
08:55:23 <mm_freak> > [0..]>>=\x ->[x+1,-x]
08:55:24 <lambdabot>   <no location info>: parse error on input `->'
08:55:28 <mm_freak> > [0..]>>=\x-> [x+1,-x]
08:55:29 <lambdabot>   <no location info>: parse error on input `->'
08:55:34 <mekeor> syntax:  i wanna be able to use ":=" instead of "=" (because that'd be as long as "::" or "->" etc). is there a way for that?
08:55:38 <int-e> >>=
08:55:45 <int-e> err. >>=\ is a single token
08:55:47 <mm_freak> > [0..]>>= \x->[x+1,-x]
08:55:48 <lambdabot>   [1,0,2,-1,3,-2,4,-3,5,-4,6,-5,7,-6,8,-7,9,-8,10,-9,11,-10,12,-11,13,-12,14,...
08:55:55 <unknownwarrior> rostayob, oh :/ so what do i have to write when i want to add an element to the end of a list?
08:55:55 <mm_freak> hmm
08:55:59 <mm_freak> > [0..]>>= \x->[-x,x+1]
08:56:00 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
08:56:17 <rostayob> unknownwarrior: xs ++ [x]
08:57:23 <unknownwarrior> rostayob, :)
08:57:38 <rostayob> unknownwarrior: be aware that that's fairly inefficient
08:57:52 <rostayob> there will be no sharing between the two lists
08:58:00 <elliott> matthiasgorgens: With SECs it'd be (argument g . f), for what it's worth.
08:58:05 <unknownwarrior> rostayob, do you mean its bad to go through the list twice?
08:58:06 <rostayob> and the list will have to be traversed
08:58:16 <elliott> (Or (argument . result) g f.)
08:58:29 <rostayob> unknownwarrior: well I'm just saying that each time you do xs ++ [x], you're traversing and copying the whole of xs
08:58:38 <rostayob> to get the new list with [x] appended
08:58:59 <unknownwarrior> okay. so for long lists this will suck
08:59:05 <rostayob> it will
08:59:07 <unknownwarrior> but i think its okey for what i want to do
08:59:11 <rostayob> yeah, probably
08:59:36 <unknownwarrior> well thanks for your advise ;) maybe i think of a better solution later
09:00:35 <elliott> I just realised that Data.* violates common package naming conventions. :(
09:01:02 <matthiasgorgens> elliott: (result.argument) from the blog-post worked.  thanks.
09:01:22 <elliott> Oh, oops, got it the wrong way around :P
09:01:53 <matthiasgorgens> elliott, only in the actual code, the pointful way reads easier.
09:01:58 <rostayob> sometimes I'd like (.) to be flipped
09:02:02 <rostayob> like >>>
09:02:09 <elliott> matthiasgorgens: hehe
09:02:15 <elliott> rostayob: it's called (>>>)
09:02:35 <rostayob> elliott: I know
09:02:40 <rostayob> but they could just be the same
09:02:52 <koeien> function application should be written in the other way around then, as well
09:02:55 <koeien> x f
09:03:06 <rostayob> koeien: why?
09:03:15 <elliott> consistency
09:03:17 <koeien> (f . g) x === g (f x)   is kinda bizarre
09:03:30 <rostayob> well that's how it works for Arrows
09:03:38 <elliott> no it doesn't
09:03:38 <matthiasgorgens> elliott, I'm looking whether changing a databaseWrite function from Path -> Item -> m () to Item -> Path -> m () makes the code nicer.
09:03:39 <elliott> arrows have (.)
09:03:43 <rostayob> I mean it's just that the asimmetry between (.) and >>> annoys me
09:03:47 <elliott> it works they way if you write (>>>) instead
09:03:48 <rostayob> elliott: Category has (.)
09:03:49 <elliott> *that
09:03:54 <elliott> rostayob: yes and Arrow depends on Category
09:03:56 <elliott> and that's where (>>>) comes from
09:03:59 <elliott> s/depends on/subclasses/
09:04:07 <rostayob> I know. but when you write generic Arrow code
09:04:09 <matthiasgorgens> in most cases it does for our code.  Only the one part that I just polished before, gets slightly worse.
09:04:11 <rostayob> and you use it with functions
09:04:20 <rostayob> >>> is like (.), but the other way around
09:04:24 <elliott> matthiasgorgens: Path -> Item -> m () is the correct way around, unless you often write the same item to a bunch of different paths.
09:04:32 <elliott> :t insert
09:04:32 <Saizan> that's why we have (<<<)
09:04:32 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
09:04:34 <elliott> argh, not that one
09:04:41 <elliott> it's generally
09:04:46 <elliott> location -> value -> structure -> result
09:04:47 <rostayob> Saizan: well but >>> is more intuitive for arrows, imho.
09:04:51 <elliott> see e.g. Data.Map for examples of that
09:05:09 <matthiasgorgens> elliott, we also have a remove function, and that takes only a path.
09:05:19 <elliott> :t M.lookup
09:05:22 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
09:05:22 <elliott> :t M.delete
09:05:22 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> M.Map k a
09:05:25 <elliott> erm
09:05:27 <elliott> :t M.insert
09:05:28 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
09:05:29 <elliott> :t M.delete
09:05:30 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> M.Map k a
09:05:30 <elliott> rather
09:05:35 <matthiasgorgens> elliott, the structure is implicit for us.
09:05:43 <elliott> right, so (Map -> Map) is m ()
09:05:46 <elliott> so that's k -> a -> m (), k -> m ()
09:05:59 <elliott> well, change it if you want, but I think Path -> Item -> ... is the right way :)
09:06:24 <matthiasgorgens> elliott, but I'll probably leave it like it is.  It's too much work for something that's not The Right Thing (TM) anyway.
09:06:53 <matthiasgorgens> although stuff like
09:06:53 <matthiasgorgens> dbMaybeWrite :: (MonadRpcLike m, Marshall a) => Maybe a -> String -> m ()
09:06:53 <matthiasgorgens> dbMaybeWrite = maybe dbRm dbWrite
09:06:57 <matthiasgorgens> looks much better the other way round.
09:07:11 <matthiasgorgens> (where String is the type for the location.)
09:08:11 <elliott> matthiasgorgens: I think it's more that you're finding existing composition operators awkward rather than the interface itself being awkward
09:08:13 <elliott> but I don't know
09:10:55 * hackagebot HaskellNN 0.1 - High Performance Neural Network in Haskell  http://hackage.haskell.org/package/HaskellNN-0.1 (KietLam)
09:12:04 <matthiasgorgens> elliott, yeah, probably.
09:14:58 <ehuber> hello. ive skimmed the haskell98 report, and the report about the history of haskell. however, i still dont understand the motivation for having lazy values. is there something in particular that i missed or another document i should read that will explain why haskell is nonstrict?
09:15:00 <Lemon> > let x = x + 1 in x
09:15:04 <lambdabot>   mueval-core: Time limit exceeded
09:15:16 <elliott> ehuber: that was decided before "haskell" even existed
09:15:27 <elliott> haskell was designed to unify the various purely-functional, non-strict languages existing at the time
09:15:44 <ehuber> heh, i gather so much from the report. should i be reading about miranda instead to understand why nonstrict? :)
09:16:00 <elliott> heh, perhaps
09:16:14 <ehuber> or like, is there a page with practical uses of laziness?
09:16:28 <elliott> ehuber: if you're interested in "contemporary" justifications, http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
09:16:29 <dmwit> The interesting property of lazy evaluation is that, if any evaluation strategy terminates, then lazy evaluation does, too.
09:16:30 <mauke> ehuber: refactoring
09:16:30 <koeien> it makes a lot of language constructors more composable
09:16:39 * cmccann wonders why strict languages are strict, and what the practical uses of strict evaluation are.
09:16:42 <elliott> although, I guess augustss was probably making the same points backw hen Haskell started existing
09:16:44 <elliott> *back when
09:16:58 <koeien> cmccann: effiency
09:17:16 <mauke> koeien: how is it efficient to evaluate expressions you never need?
09:17:44 <ehuber> yeah, im wondering what about laziness is so useful for expression that the space cost is worth it.
09:17:44 <koeien> i'd wager that in the dark ages evaluating thunks was less well-understood
09:17:56 <elliott> ehuber: apart from what that blogpost says:
09:18:05 <koeien> how to optimize*
09:18:11 <ehuber> ah, sorry i didnt see the link at the end of the line there
09:18:12 <elliott> ehuber: it's also more composable in that you can do things like construct an infinite tree of results, and just traverse it in the right order to do what you want
09:18:19 <mauke> ehuber: what is it about strictness that is so useful that the runtime and complexity cost is worth it?
09:18:25 <elliott> whereas in a strict language, you'd have to tie the computation of results to how you traverse them and which ones you care about
09:18:45 <elliott> (or take a "callback" to calculate the value at a point, which is just non-strictness in disguise)
09:19:07 <chrisdone> in case you didn't already know bos re-registered the hpaste.org domain, so it should be back sometime once your dnses and interwebs are up to date
09:19:12 <mm_freak> > dropWhile (< 16) . map (^2) . filter even $ [1..]
09:19:13 <lambdabot>   [16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,1444,1...
09:19:16 <mm_freak> that's one use of laziness
09:19:27 <elliott> ehuber: another good summary: http://apfelmus.nfshost.com/articles/quicksearch.html
09:19:28 <mm_freak> operatings over an entire infinite list
09:19:34 <koeien> i like laziness, but the spaceleaks :(
09:19:39 <ehuber> thanks, ill be reading the links
09:19:42 <elliott> that's just one specific example but it summarises what non-strictness gives you quite well
09:19:45 <koeien> but the net result is totally awesome
09:19:56 <koeien> you can write (||) short-circuiting in native haskell
09:19:57 <ehuber> mm_freak: sure but, ive never had occassion to build an infinite list. have you?
09:20:04 <cmccann> ehuber, all the time
09:20:07 <mm_freak> ehuber: all the time
09:20:10 <koeien> in scheme you'd need a macro, and in C it's not possible
09:20:14 <mm_freak> in fact i seldomly construct a finite list
09:20:21 <chrisdone> …often the time
09:20:24 <mm_freak> more even usually it feels like a design flaw to start with a finite list
09:20:35 <elliott> ehuber: you don't do that because it doesn't work in your favourite language :)
09:20:36 <elliott> data structures are a lot more like control structures in haskell
09:20:52 <ehuber> hm, ok
09:20:58 <elliott> lists are basically like loops
09:21:00 <mm_freak> ehuber: the difference is that i think in haskell
09:21:01 <elliott> but first-class
09:21:08 <mm_freak> while you probably think in another language
09:21:10 <ehuber> anyway, thanks everyone. hope i didnt stir u p a flamewar :]
09:21:19 <mm_freak> =)
09:21:23 <elliott> and so repeated transformation and processing of an infinite list comes down to very powerful loop transformations
09:21:24 <koeien> #haskell is impossible to flame :)
09:21:34 <mm_freak> hehe true
09:21:38 <elliott> @faq Can #haskell be flamed?
09:21:38 <lambdabot> The answer is: Yes! Haskell can do that.
09:21:43 <cmccann> haha
09:21:48 <MostAwesomeDude> koeien: Clearly you haven't been around for Python discussions. :3
09:21:59 <mm_freak> #haskell is truly unique in many ways =)
09:22:02 <chrisdone> @vixen how do i flamed #haskell?
09:22:02 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
09:22:12 <chrisdone> wise words
09:22:17 * cmccann makes an offhand remark about the language "C/C++"
09:22:43 <mm_freak> chrisdone: ah, good timing…  i find emacs-haskell interesting…  my question is:  is it supposed to be used together with haskell-mode?
09:22:47 <mauke> cmccann: I've written a C/C++ interpreter in Haskell
09:22:55 <mauke> well, sort of
09:22:58 <cmccann> mauke, oh boy, sounds fun
09:22:59 <mauke> the spec is incomplete
09:23:27 <chrisdone> is there a C which has an ml-ish type system, a module system and ml syntax or something? it seems probable
09:23:41 <elliott> I think #haskell is quite easily trolled, but terrible at realising it.
09:23:42 <koeien> int main(void) { int class; return 0; } /* compile this! */
09:23:54 <MostAwesomeDude> elliott++
09:23:58 <elliott> chrisdone: ML?
09:24:10 <chrisdone> elliott: sure
09:24:12 <matthiasgorgens> chrisdone: OCaml.
09:24:24 <chrisdone> matthiasgorgens: in what was is ocaml like c?
09:24:32 <matthiasgorgens> chrisdone, it's strict. ;o)
09:24:42 <elliott> chrisdone: ML + MLton, especially, might quite thoroughly resemble C in many aspects.
09:24:45 <chrisdone> mm_freak: it's supposed to be a replacement for haskell-mode, really… but the hs-mode isn't yet awesome enough to usurp haskell-mode's editing mode. but the haskell-emacs repl and stuff is better
09:24:48 <elliott> Might because I haven't really used ML or MLton :P
09:25:04 <mm_freak> chrisdone: ok, thanks
09:25:18 <chrisdone> elliott: yeah—i saw that Ur compiles to mlton and it has some interesting properties of needing no garbage collector
09:25:26 <matthiasgorgens> chrisdone: and I found it quite straightforward to transform C into OCaml so far.
09:25:43 <mauke> crap
09:25:52 <elliott> chrisdone: http://mlton.org/GarbageCollection
09:25:58 <elliott> MLton has a GC. Maybe Ur doesn't need it or something.
09:26:14 <matthiasgorgens> chrisdone: The other way around is harder, of course, since OCaml is more expressive.
09:26:18 <chrisdone> well, that's what ur's website claims. but i don't claim to understand ur's type system
09:26:50 <elliott> chrisdone: maybe it does its own region inference and turns off the MLton gc
09:26:58 <dolio> Garbage is collected for Ur by the process ending.
09:27:11 <elliott> dolio: that seems... suboptimal
09:27:19 <cmccann> how to emulate C using Haskell: error "Segmentation fault"
09:27:31 <dolio> The processes don't run very long.
09:27:35 <koeien> fromJust Nothing
09:27:53 <elliott> dolio: "For example, the standalone web server generated for the demo uses less RAM than the bash shell."
09:27:57 <dolio> Just long enough to generate some html.
09:28:01 <elliott> Are you meant to deploy to CGI or something?
09:28:13 <elliott> FastCGI servers service multiple requests and so on.
09:28:56 <dolio> This is just what I've heard, by the way. Maybe I'm wrong.
09:29:05 <dolio> But I think that's the answer.
09:29:18 <chrisdone> it seems i'm not alone in my looking-at-ur-in-awe-but-from-afar
09:29:38 <elliott> I can't imagine anyone would design a web language that targets CGI (or something equivalent) in the 2000s, but...
09:30:59 <chrisdone> does hpaste.org resolve properly for you guys yet?
09:31:08 <koeien> yes.
09:31:25 <elliott> yes
09:32:05 <hpaste> キタ━━━(゜∀゜)━━━!!!!!
09:32:18 <elliott> I need more Unicode fonts.
09:32:35 <chrisdone> elliott: did you try the ubuntu font? ♥
09:33:06 <elliott> I've used an Ubuntu machine with it. It's alright.
09:33:28 <elliott> I suspect I'm missing Japanese fonts for that thing, though.
09:33:46 <mreh> preflex seen luqui
09:33:54 <elliott> preflex: seen preflex
09:34:47 <mreh> > "> 1+2"
09:34:48 <lambdabot>   "> 1+2"
09:35:35 <mreh> urgh, must I upgrade my OS to use graphics-drawingcombinators
09:35:37 <copumpkin> what's a nice golfy way to generate all rotations of a list?
09:36:00 <mreh> cycle and drop?
09:36:05 <copumpkin> > liftM2 (zipWith (++)) inits tails [1..5
09:36:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:36:06 <copumpkin> > liftM2 (zipWith (++)) inits tails [1..5]
09:36:08 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]]
09:36:11 <copumpkin> lol
09:36:24 <qpu> > permutations "abc"
09:36:25 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
09:36:32 <copumpkin> not all of those are rotations
09:36:34 <mreh> they are permutations
09:36:34 <dolio> > liftM2 (zipWith (++)) tails inits [1..5]
09:36:36 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4],[1,2,3,4,5]]
09:36:49 <qpu> oh, i misunderstood
09:37:02 <mreh> writing permutations is a good exercise
09:37:25 <copumpkin> > liftM2 (zipWith (++)) inits tails [1,0,0]
09:37:27 <lambdabot>   [[1,0,0],[1,0,0],[1,0,0],[1,0,0]]
09:37:33 <chrisdone> lol
09:37:36 <copumpkin> > liftM2 (zipWith (++)) tails inits [1,0,0]
09:37:37 <copumpkin> dammit
09:37:37 <lambdabot>   [[1,0,0],[0,0,1],[0,1,0],[1,0,0]]
09:37:38 <mreh> brain fart
09:37:38 <chrisdone> Great Job
09:38:00 <matthiasgorgens> instead of liftM2 you can also use <$> and <*>
09:38:26 <_Mikey> :t liftM2
09:38:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:39:08 <matthiasgorgens> :t \f a b -> f <$> a <*> b
09:39:10 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
09:39:32 <mreh> would someone backport graphics-drawingcombinators?
09:39:59 <cmccann> backport?
09:40:25 <mreh> to OpengGL 2.2
09:40:50 <mreh> the hackage package
09:41:26 <elliott> why not upgrade the OpenGL package?
09:42:13 <elliott> :t (++) <$> (ZipWith . tails) <*> (ZipWith . inits)
09:42:14 <lambdabot> Not in scope: data constructor `ZipWith'
09:42:14 <lambdabot> Not in scope: data constructor `ZipWith'
09:42:14 <mreh> that is an alternative
09:42:19 <elliott> :t (++) <$> (ZipList . tails) <*> (ZipList . inits)
09:42:20 <lambdabot> forall a. (Monoid (ZipList [a])) => [a] -> ZipList [a]
09:42:24 <Veinor> no, this is an alternative
09:42:27 <elliott> mreh: well, that's one cabal install, rather than porting work :)
09:42:35 <Veinor> @type (<|>)
09:42:36 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
09:42:56 <elliott> > ((++) <$> (ZipList . tails) <*> (ZipList . inits)) [1,0,0]
09:42:56 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList [a]))
09:42:56 <lambdabot>    arisin...
09:43:01 <elliott> > getZipList $ ((++) <$> (ZipList . tails) <*> (ZipList . inits)) [1,0,0]
09:43:02 <lambdabot>   No instance for (Data.Monoid.Monoid
09:43:02 <lambdabot>                     (Control.Applicativ...
09:43:08 * elliott cries
09:43:29 <mreh> I found the packages for openGL 2.2.* for my OS so i figured i'd use them
09:43:41 <mreh> good job i install cabal-dev
09:43:43 <elliott> > getZipList $ (\xs -> (++) <$> ZipList (inits xs) <*> ZipList (tails ys))) [1.0.0]
09:43:44 <lambdabot>   <no location info>: parse error on input `)'
09:43:55 <elliott> mreh: that won't help if you have an OS package; it'll be installed globally
09:43:59 <elliott> so you'll have to remove it with your package manager
09:45:01 <mreh> cabal-dev will just look to fufil the dependencies, if theres an OpenGL installed locally then it will go for that
09:45:24 <matthiasgorgens> elliott, haskell too hard for you?
09:45:29 <mreh> installed locally and more up to date
09:46:16 <MostAwesomeDude> mreh, elliott : You're talking about the system's GL drivers?
09:47:24 <mreh> MostAwesomeDude: i'm talking about the cabal package
09:48:07 <MostAwesomeDude> mreh: Oh. Unfortunate versioning, then.
09:48:23 <mreh> yeah, they all use OpenGL 2.1 i think
09:48:49 <MostAwesomeDude> There's still lots of GL 1.3 and 1.5 hardware out there.
09:49:11 <NothingMan65> Should I even be trying to represent a 2D matrix in Haskell?
09:49:18 <mreh> which is kind of out of date
09:49:25 <mreh> NothingMan65: why not?
09:49:39 <NothingMan65> Cuz I don't know how, and it doesn't seem inuitive?
09:50:12 <mreh> > [[1,2],[3,4]]
09:50:13 <lambdabot>   [[1,2],[3,4]]
09:50:17 <mreh> like that
09:50:33 <mreh> > transpose [[1,2],[3,4]]
09:50:34 <lambdabot>   [[1,3],[2,4]]
09:50:58 * hackagebot ftp-conduit 0.0.1 - FTP client package with conduit interface based off http-conduit  http://hackage.haskell.org/package/ftp-conduit-0.0.1 (MylesMaxfield)
09:51:46 <NothingMan65> How would I go about getting a diagonal?  What concept should I use?
09:51:56 <NothingMan65> A list comprehension?
09:52:14 <NothingMan65> A nested list comprehension?
09:53:47 <brill> noob question: Why can't I do something like this in ghci: max.sum[2,3] $ 5
09:54:10 <cmccann> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0..]
09:54:11 <lambdabot>   [1,5,9]
09:54:21 <NothingMan65> That's cute.
09:55:32 <drdo> brill: Why do you think you should be able to?
09:55:49 <chrisdone> NothingMan65: i heard you like comprehending lists
09:55:49 <NothingMan65> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0..1]
09:55:50 <lambdabot>   [1,5]
09:56:14 <NothingMan65> lol, chrisdone, It's like the only thing I know in Haskell
09:56:21 <NothingMan65> And not very well, at that.
09:56:40 <chrisdone> man i almost never use list comprehensions, there's probably 3 in a 20k line codebase
09:56:42 <brill> drdo: How would you make function composition of max and sum?
09:58:30 <hpc> brill: what do you want that code to do?
09:59:00 <parcs`> > (max . sum) [2, 3] 5
09:59:02 <lambdabot>   5
09:59:05 <NothingMan65> chrisdone, well, I'm still in that phase of learning Haskell in which you find yourself in the dark room, and you've a box of matches, and you are striking, striking, striking while seeing the flickers of your surroundings, some familiar others foreign.  Soon, the match will light and I will see the outlines of the fundamentals in Haskell, then, and only then, will the real learning begin.
09:59:34 <brill> parcs`: Thanks. I'm a complete noob at this...
09:59:46 * Botje hands NothingMan65 a few rolls of duct tape
09:59:48 <hpc> brill: oh god, don't use that
10:00:07 <hpc> it's a lambdabot quirk that you shouldn't learn until much later
10:00:11 <parcs`> no it's not
10:00:13 * NothingMan65 looks down inquisitively
10:00:15 <hpc> :t max
10:00:16 <parcs`> :t max . sum
10:00:16 <lambdabot> forall a. (Ord a) => a -> a -> a
10:00:17 <lambdabot> forall a. (Ord a, Num a) => [a] -> a -> a
10:00:19 <NothingMan65> What's this for Botje?
10:00:20 <hpc> oh, nvm
10:00:30 * NothingMan65 has a bad feeling...
10:00:36 <hpc> :t maximum -- what i thought it was
10:00:37 <lambdabot> forall a. (Ord a) => [a] -> a
10:00:49 <hpc> brill: ignore me ;)
10:00:53 <parcs`> brill: you shouldn't use function composition when it makes expressions harder to understand
10:01:09 <parcs`> max (sum [2, 3]) 5 is better
10:01:31 <brill> parcs`: Okay. Point well made.
10:02:44 <drdo> brill: The obvious problem there is that funtions aren't numbers
10:03:06 <parcs`> brill: max . sum [2, 3] $ 5 doesn't work because it gets parsed as (max . sum [2, 3]) $ 5 and sum [2, 3] is not a function so it can't be used as an argument to .
10:03:21 <Botje> @quote tape
10:03:22 <lambdabot> EvilTerran says: writing machine code by hand on tape with a magnetised needle looks good compared to PHP :P
10:03:26 <Botje> awwh
10:03:42 <NothingMan65> Hehe
10:04:19 <Botje> NothingMan65: haskell blows the mind. repeatedly.
10:04:22 <Botje> @quote skull
10:04:22 <lambdabot> kyevan says: my skull is already mostly duct tape. And I'm only on page 25 of YAHT!
10:04:25 <Botje> maybe this one is better
10:04:26 <brill> parcs`: Ahh. Dim light begins to shine somewhere at back of head.
10:04:26 <Scriptor> sweet, I can say I'm more hardcore than machine code programmers
10:05:28 <NothingMan65> It's not so hard to blow my mind, so basically I'm screwed.
10:06:24 <elliott> <drdo> brill: The obvious problem there is that funtions aren't numbers
10:06:49 <elliott> > (42 :: String -> Int) "Pfft."
10:06:50 <lambdabot>   42
10:08:10 <mauke> > max . sum [2, 3] $ 5
10:08:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:08:11 <lambdabot>    arising from a use of `...
10:09:47 <matthiasgorgens> :t max
10:09:48 <lambdabot> forall a. (Ord a) => a -> a -> a
10:12:52 <mreh> Registering GLURaw-1.1.0.1...
10:12:53 <mreh> cabal: GLURaw-1.1.0.1: dependency
10:12:53 <mreh> "OpenGLRaw-1.1.0.2-7c2d2052ed2853f4cf54bfb263546cf9" doesn't exist (use
10:12:53 <mreh> --force to override)
10:12:53 <mreh> cabal: Error: some packages failed to install:
10:12:57 <mreh> wut?
10:13:24 <elliott> what
10:13:26 <mreh> cabal-dev says this, i don't understand
10:13:38 <elliott> your packages are broken
10:14:29 <mreh> OpenGLRaw-1.1.0.2-7cblahblah is a directory in the package directory inside my current working dir
10:17:00 <Feuerbach> Does anyone know of good real-world examples of STM usage? I'm looking at xmobar, but can't see where atomicity is required there
10:17:20 <elliott> You don't necessarily need atomicity to get advantages from STM.
10:17:42 <elliott> I mean, it's easier to understand than MVar even for simple use.
10:17:56 <elliott> Feuerbach: Also, is xmboar collating data from several sources?
10:18:16 <elliott> If so, (readTChan c1 `orElse` readTChan c2 `orElse` readTChan c3) is incredibly useful.
10:18:17 <Feuerbach> elliott: It does. I don't see any advantages even over IORefs there
10:18:32 <elliott> Feuerbach: Well, is it using TChans?
10:18:46 <Feuerbach> no, just TVars
10:19:22 <elliott> It's hard to say without seeing the code you're looking at.
10:19:26 <elliott> Could you hpaste a representative sample?
10:19:56 <Feuerbach> https://github.com/jaor/xmobar/blob/master/src/Xmobar.hs
10:20:30 <Feuerbach> see e.g. https://github.com/jaor/xmobar/blob/master/src/Xmobar.hs#L115
10:20:40 <elliott> -- | Send signal to eventLoop every time a var is updated
10:20:44 <elliott> You can't do that with IORef.
10:21:07 <elliott>                guard (nv /= ov)
10:21:24 <elliott> Feuerbach: If that condition isn't met, the transaction will be paused until any of the vars in vs change.
10:21:37 <elliott> Not a busy-loop or anything; it'll just stop running, and a write will kick it off again.
10:22:10 <elliott> That's one of the main advantages of STM transactions: you can wait for arbitrarily complex changes in state efficiently.
10:23:09 <Feuerbach> I see
10:23:35 <adnap> apl looks like a scary language
10:24:16 <danols_work> does haskell have the GIL flaw ?
10:24:21 <danols_work> as in python ? http://www.dabeaz.com/python/UnderstandingGIL.pdf
10:24:22 <mauke> danols_work: hahaha
10:24:35 <danols_work> ? :)
10:24:41 <mauke> does anything but python do that?
10:24:48 <danols_work> i don't know
10:24:54 <mauke> I mean, even perl has real threads
10:25:06 <danols_work> I feel cheated to have been learning python
10:25:13 <danols_work> god damn propaganda
10:25:19 <danols_work> ok that answer my question
10:27:33 <ppseafield> mauke: Ruby has a global interpreter lock as well IIRC.
10:28:00 <mreh_> python propaganda?
10:28:19 <mreh_> sounds silacious
10:28:29 <mreh_> do tell
10:28:44 <Feuerbach> elliott: still, couldn't the same be achieved by a simple MVar ()?
10:28:59 <mm_freak> i'd be fine with python propaganda…  what i'm not fine with is PHP propaganda
10:29:07 <elliott> Feuerbach: Yes, but you'd have to manually put into it whenever you updated the value from elsewhere.
10:29:20 <elliott> In fact, Chan () would be better.
10:29:29 <elliott> Feuerbach: You could have a (TVar a, Chan ()) combination and functions to handle it appropriately, but... why not use STM?
10:29:35 <Feuerbach> right, but it doesn't sound that scary
10:29:39 <elliott> So?
10:29:42 <elliott> It sounds scarier than TVar.
10:29:52 <elliott> There's no point to avoid simple, lightweight abstractions when they're readily available.
10:29:53 <Feuerbach> I'm looking for a very convincing example of STM :)
10:30:23 <mm_freak> it's a common misconception that Chan is faster than MVar…  in almost all benchmarks i did, MVar outperformed Chan by a large factor, even if multiple messages were sent
10:30:33 <elliott> mm_freak: yeah but Chan is the semantics you want here
10:30:36 <elliott> well hmm
10:30:42 <elliott> yeah it is
10:30:48 <elliott> you wouldn't want the put to block
10:30:57 <elliott> How could Chan be faster than MVar? It's made out of tons of MVars.
10:31:23 <mm_freak> could you summarize the application?
10:32:15 <elliott> mm_freak: a thread that acts every time a TVar is updated
10:32:32 <elliott> Feuerbach: Well, I just showed you how it would take a lot of annoying boilerplate to accomplish this without STM.
10:32:44 <elliott> Feuerbach: You're not going to find anything that's impossible to do without using STM.
10:32:52 <elliott> It's just simpler, easier to understand, and in some cases it can be more efficient.
10:33:10 <mm_freak> elliott: yeah, that's a TVar application…  is there anything else?
10:33:21 <elliott> mm_freak: Nope.
10:33:49 <mm_freak> then Chan is certainly not the right abstraction…  this really sounds like a semaphore or a TVar
10:34:50 <Feuerbach> elliott: I'm looking for something that would require a set of non-trivial locks as a replacement to STM
10:35:02 <elliott> Feuerbach: STM doesn't use locks like that, anyway.
10:35:07 <elliott> It's optimistic concurrency.
10:35:20 <lukish> Can I rewrite that better? mapM_ (mapM_ putStrLn) . map (map showMatrix) $ equivalenceRClasses (3,3)
10:35:20 <elliott> mm_freak: It is a TVar, Feuerbach is just asking why it isn't something vastly more complicated. :)
10:35:21 <Feuerbach> I didn't say it uses locks
10:35:36 <elliott> lukish: mapM_ (putStrLn . showMatrix) . concat $ equivalenceRClasses (3,3)
10:35:37 <mm_freak> why should it be more complicated?  this is haskell, not C++
10:35:51 <_Mikey> lol
10:35:51 <monochrom> hehe
10:36:34 <elliott> mm_freak: I'm not the one saying it should be more complicated :P
10:36:53 <mm_freak> elliott: i wasn't directing that at you =)
10:37:05 <lukish> elliott: your code did other thing that my
10:37:18 <Feuerbach> all I'm asking is just a convincing real-world usage of STM
10:37:32 <Feuerbach> something that would convince a non-Haskell programmer consider using Haskell
10:37:39 <elliott> lukish: I don't think so.
10:37:47 <lukish> Oh, my fault
10:38:00 <mm_freak> Feuerbach: that's very difficult
10:38:09 <lukish> I will reformulate my question later
10:38:10 <elliott> Feuerbach: It seems like you don't want to be convinced, to be honest.
10:38:17 <_Mikey> I hope to use STM in my ant simulation
10:38:19 <elliott> Locks are error-prone, complicated, and they can be slow.
10:38:21 <mm_freak> i mean it's easy to fascinate them, but it's difficult to get them to use haskell themselves
10:38:27 <elliott> STM is simple to understand, lightweight, and it has good performance.
10:38:36 <elliott> Why would you choose not to use STM because, hey, locks?
10:38:50 <Feuerbach> mm_freak: fascinating would be enough :)
10:39:10 <cmccann> the thing about STM is that using it never looks impressive
10:39:14 <Feuerbach> elliott: because you're not using haskell?
10:39:34 <monochrom> "why should it be more complicated?  this is haskell, not C++" is fascinating enough, unless the audience is C++ fans and feel offended
10:39:37 <cmccann> because you don't see the alternative, which is hours of tracking down weird concurrency bugs
10:39:41 <mm_freak> cmccann: you have to write an application that is so cool that other people want to rewrite it in other languages and fail miserably because they don't have STM
10:39:43 <elliott> Feuerbach: "Now you have two problems" :)
10:39:44 <mm_freak> but hurry up
10:40:01 <mm_freak> STM is implemented in other languages as well…  i think haskell has the best and most flexible implementation though
10:40:12 <elliott> STM doesn't work well in 90% of languages because of pervasive mutability
10:40:14 <companion_cube> people seem to use it a lot in clojure
10:40:19 <cmccann> does any language other than haskell and clojure have a usable STM implementation?
10:40:33 <elliott> pypy are doing stm
10:40:35 <elliott> they claim it's going well
10:40:38 <cmccann> usable in the sense of "not a toy implementation"
10:40:43 <elliott> cmccann: scala has akka
10:40:49 <elliott> which I am told also does something like frp(?!)
10:40:57 <lukish> When I'm using `mapM_ ( print . map showMatrix) $ equivalenceRClasses (i, j)` i have "" around the strings. How can I avoid it? Replacing print with putStrLn gave me a type error
10:41:10 <Feuerbach> monochrom: I'm looking for a real-world example, not words
10:41:13 <mauke> lukish: what type error?
10:41:16 <elliott> lukish: The problem is that it's a [String]
10:41:23 <elliott> but putStrLn takes a String
10:41:31 <elliott> How do you want to print the list?
10:41:35 <mauke> oh, I see
10:41:47 <Feuerbach> monochrom: (sorry if it sounded harsh, I didn't mean it)
10:42:12 <lukish> elliott: yes I do
10:42:19 <lukish> I have ["1101","1110"] with print
10:42:24 <elliott> You want [1101,1110]?
10:42:26 <lukish> And I want [1101,1110]
10:42:29 <lukish> Yes
10:42:31 <mauke> lukish: "yes" doesn't answer "how?"
10:42:45 <monochrom> I want to know your rigorous definition of "real-world"
10:42:45 <elliott> mapM_ (\xs -> putStrLn $ "[" ++ intercalate ", " (map showMatrix xs) ++ "]") $ equivalenceRClasses (i, j)
10:43:38 <lukish> M. okay
10:43:51 <Feuerbach> monochrom: a program that is used by more than 10 people, say
10:44:37 <elliott> I'm sure xmobar is used by more than 10 people.
10:44:51 <monochrom> oh, xmobar uses STM?
10:44:54 <Feuerbach> yes
10:44:55 <elliott> In fact, base uses STM.
10:45:10 <monochrom> well, that does it
10:45:12 <elliott> So there's a great many number of programs used by more than 10 people that use STM.
10:45:16 <Feuerbach> but xmobar's STM usage can be replaced by a single MVar, so that's not impressive
10:45:20 <elliott> A single?
10:45:22 <elliott> No, an MVar per TVar.
10:45:27 <Feuerbach> no
10:45:34 <Feuerbach> MVar + set of IORefs
10:45:41 <Feuerbach> MVar for signaling when something is updated
10:45:52 <elliott> You'd need to set it every single time any TVar-equivalent in the program is updated. Are you sure it only ever applies that function to every TVar?
10:46:05 <elliott> It will be massively inefficient if there are lots of variables and it's only used on some of them, and you emulate it with a single MVar.
10:46:20 <monochrom> now I want to know your rigorous definition of "impressive"
10:46:47 <Feuerbach> elliott: I don't see why it would be inefficient
10:47:39 <monochrom> and after all these exercises, I want to remind you that it is legit to request "an example that convinces *me*", but do not pretend that you can speak for anyone else
10:48:16 <Feuerbach> monochrom: well, I'm looking for an example that I can use for convincing others. Unfortunately, I can't ask them in advance
10:49:38 <etpace> Hm... I have two monads (ReaderT State) -- say Outer and Inner. Inner is only ever "ran" (ie, runReaderT, runState..) by a function inside the Outer monad (therefore it also sets up the initial state and environment). This abstraction was working well but now I want to do something that will break my current implementation: I want my Inner monad to run values in the Outer monad, using the Inner's Outers environment/state (which is ok..) but I wo
10:51:42 <jeank> hey, someone here use xmonad + tint2 (status bar) ?
10:53:22 <elliott> Feuerbach: Because the thread would wake up whenever any variable changed.
10:53:25 <elliott> And read them all.
10:53:33 <Feuerbach> elliott: that what it does currently
10:53:34 <elliott> Rather than whenever the vars it cares about changes.
10:53:35 <elliott> No.
10:53:44 <elliott> It only retries when one of the variables it read changes.
10:54:06 <Clint> has anyone tested out the reverse proxy and tls performance of mighttpd2?
10:54:55 <Feuerbach> elliott: in this particular example, it cares about all variables
10:55:05 <elliott> Feuerbach: ok; that's what i was asking :)
10:55:24 <timemage>  
10:55:59 * hackagebot nonlinear-optimization 0.3.5.2 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.5.2 (FelipeLessa)
10:59:32 <unknownwarrior> hey guys. do you know how i can tell a recursive function that recalls itsself without any termination that it should only go .. 10 stepts ?
11:00:07 <elliott> unknownwarrior: sure, add a counter argument to the function
11:00:31 <plathrop> I'm sure this isn't as good as I could make it. Would anyone be willing to help me improve it? https://gist.github.com/1672161
11:00:50 <unknownwarrior> elliott: y thats what i usually do but i know there is a way to do it with "repeat" or something
11:01:08 <elliott> unknownwarrior: If you make your function just do a single step, rather than recursing, then you can use
11:01:09 <elliott> > iterate f x
11:01:10 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
11:01:17 <kuribas> Is there a function  f [1, 2, 3] = [[[1], [1, 2], [1, 2, 3]], [[2], [2, 3]], [[3]]] ?
11:01:33 <elliott> unknownwarrior: If you have another termination condition, then maybe it -> Maybe R, where R is your result.
11:01:50 <elliott> unknownwarrior: Then you can catMaybes (iterate f x), and take the tenth element or the last, whichever comes first.
11:02:11 <unknownwarrior> umm im not even sure waht the function i want to look at does, so i want to see what happens
11:02:49 <unknownwarrior> kuribas: i dont know
11:03:08 <Feuerbach> unknownwarrior: if you express your function using fix, you can then replace fix with similar function that also takes care of counting
11:04:26 <unknownwarrior> Feuerbach: no this function does not use fix
11:04:51 <Feuerbach> unknownwarrior: you can rewrite it so that it does
11:05:00 <cmccann> > inits <$> tails [1, 2, 3] -- kuribas
11:05:01 <lambdabot>   [[[],[1],[1,2],[1,2,3]],[[],[2],[2,3]],[[],[3]],[[]]]
11:05:05 <cmccann> not quite the same
11:05:25 <unknownwarrior> regular = 1 : map (*2) regular `unionSorted` map (*3) regular `unionSorted` map (*5) regular <--- thats my function. i want to look at the result of the first 10 elements because i dont understand what this does .. any guesses?
11:05:32 <elliott> aka map inits . tails :P
11:05:39 <kuribas> map (tail . inits) $ tails [1..3]
11:05:43 <elliott> > (tails >=> inits) [1,2,3]
11:05:44 <lambdabot>   [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
11:05:45 <kuribas> But with good space behaviour
11:05:49 <elliott> > (inits >=> tails) [1,2,3]
11:05:49 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[]]
11:06:29 <byorgey> unknownwarrior: oh, in that case, just   take 10 regular
11:06:50 <byorgey> unknownwarrior: that's not a function, it's a list.
11:06:59 <unknownwarrior> byorgey: thank you byorgey, you help me as always ;)
11:07:13 <unknownwarrior> oh i see i should have been more specified
11:07:53 <unknownwarrior> still this is infinite :O take 10 regular results in [1 and then only calculation
11:07:58 <byorgey> looks like a sorted list of all numbers whose only prime factors are 2, 3, and 5
11:07:59 <plathrop> slightly improved with use of if instead of case...
11:08:00 <ClaudiusMaximus> > let  part _ [] = [] ; part e xs = let (ys, zs) = break (== e) xs in ys : part e (drop 1 zs)  in  part ' ' "perhaps something like this, plathrop?"
11:08:01 <lambdabot>   ["perhaps","something","like","this,","plathrop?"]
11:08:32 <byorgey> unknownwarrior: in that case the definition is bad.
11:08:58 <byorgey> unknownwarrior: what's the definition of unionSorted?
11:09:33 <hpaste> lukish pasted “m” at http://hpaste.org/56924
11:09:34 <lukish> How can I rewrite it with some patter function f, which will be unusable to other functions?
11:09:57 <plathrop> ClaudiusMaximus: ooh, yeah there's some better approaches there, thanks
11:10:12 <lukish> Something like `where' but for greater than one function
11:10:15 <lukish> How can I do that?
11:10:23 <unknownwarrior> byorgey: my task is to write unionsorted myself and it should work like union. i wrote a light-version of union sorted that returns either an empty list or just the first list appended to the second list. still there should at least be result to take 10 regular :/
11:10:26 <monochrom> w00t, hpaste is back :)
11:11:02 <elliott> unknownwarrior: You may find "trace" helpful.
11:11:13 <elliott> unionSorted xs ys | trace ("unionSorted " ++ show xs ++ " " ++ show ys) False = undefined
11:11:19 <elliott> put that at the top of your unionSorted definition
11:11:19 <frerich> lukish: You could simply have helper functions, no? For instance "nonEmptySubsequences = filter (not . null) subsquences"
11:11:28 <elliott> and when you evaluate regular, you'll get a bunch of output showing all the calls to unionSorted
11:11:37 <elliott> (import Debug.Trace)
11:12:19 <unknownwarrior> ty elliott
11:12:49 <byorgey> unknownwarrior: from the way you described it, it sounds like that ought to produce some output beyond 1.  But clearly it doesn't, so you must have described your implementation incorrectly.
11:13:12 <unknownwarrior> okey :/
11:13:27 <frerich> lukish: Or you could have a generalized helper function, like 'filteredMatrix p q = map (foldl1 p) . (filter (not . null) subsequences ) . q'. And then your other functions could simply use that. So "disjSomeRows = filteredMatrix disj rows" or "conjSomeColumns = filteredMatrix conj columns"
11:14:00 <byorgey> unknownwarrior: how does your "light" version of unionSorted decide whether to return the empty list or append the inputs?
11:14:49 <unknownwarrior> byorgey: y it does, i made this with xs < ys and otherwise = []
11:14:58 <lukish> frerich: yes, I can do it. But I don't want to have that function filteredmatrix available to others
11:15:04 <mauke> shit
11:15:10 <unknownwarrior> but i really dont want to ask you about the solution, i only wanted to see how the function unionsorted is called
11:15:26 <mauke> [disjSomeRows, disjSomeColumns, conjSomeRows, conjSomeColumns] = [map (foldl1 f) . filter (not . null) . subsequences . g | f <- [disj, conj], g <- [rows, columns]]
11:15:44 <byorgey> unknownwarrior: ok.
11:16:49 <unknownwarrior> elliott: Ambiguous type variable `a0' in the constraint:       (Show a0) arising from a use of `unionSorted' when i use your code
11:17:08 <_Mikey> @hpaste
11:17:09 <lambdabot> Haskell pastebin: http://hpaste.org/
11:17:18 <unknownwarrior> elliott: Probable fix: add a type signature that fixes these type variable(s)     In the second argument of `(:)', namely       `map (* 2) regular `unionSorted` map (* 3) regular    `unionSorted`      map (* 5) regular'
11:18:28 <hpaste> “_Mikey” pasted “what could I use to achieve this pattern?” at http://hpaste.org/56926
11:19:10 <mauke> _Mikey: putStrLn . show = print
11:19:42 <cmccann> plathrop, how about this? partitionAt i = unfoldr $ justIf (not . null . fst) . break (== i) . dropWhile (== i)
11:19:58 <cmccann> with justIf p x = if p x then Just x else Nothing
11:19:58 <_Mikey> mauke: but the feeding of the result into the next parameter
11:20:35 <mauke> _Mikey: main = step a; step x = print (brokenUpGraph x) >> step (processAQuadrant x b)
11:20:44 <ClaudiusMaximus> _Mikey: mapM_ f (iterate g a)
11:21:05 <mauke> ClaudiusMaximus: oh, true
11:21:22 <_Mikey> mauke: ahhh ok..
11:21:29 <_Mikey> cheers ClaudiusMaximus
11:22:07 <mauke> main = forM_ (iterate (`processAQuadrant` b) a) (print . brokenUpGraph)
11:24:06 <elliott> unknownwarrior: ah, sorry, didn't see
11:24:13 <elliott> unknownwarrior: Add a type signatuer to "regular"
11:24:19 <elliott> you've run in to the monomorphism restriction
11:24:25 <elliott> regular :: [Integer] should do it.
11:24:31 <elliott> You can remove that once you're done debugging.
11:24:33 <unknownwarrior> elliott: okey..
11:24:52 <unknownwarrior> elliott: but i have that type signature :O
11:26:48 <elliott> Oh, wait, hmm.
11:27:00 <elliott> unknownwarrior: Are you sure?
11:27:03 <elliott> Can you hpaste your whole file?
11:28:22 <hpaste> unknownwarrior pasted “the whole file for elliott” at http://hpaste.org/56927
11:28:47 <elliott> unknownwarrior: oh! don't get rid of the rest of your unionSorted definition
11:28:57 <elliott> you can just uncomment the other lines and it'll work
11:29:09 <elliott> you just add that line to existing definitions to see how they're called
11:29:11 <nand`> have any attempts been made at developing a shell based on a haskell interpreter?
11:29:35 <nand`> I guess ghci sort of fits this role but it's not exactly intended for that purpose
11:29:52 <unknownwarrior> okey it compiles. and how do i now get the first 10 results? take 10 still doesnt work
11:30:03 <elliott> unknownwarrior: just type "regular"
11:30:09 <elliott> all the calls to unionSorted will be printed on the console
11:30:14 <elliott> so you'll be able to see where it gets stuck
11:30:27 <unknownwarrior> hm. actually i only see [1
11:30:59 <elliott> hmm
11:31:05 <elliott> and you still have the trace line at the top?
11:32:09 <ClaudiusMaximus> 'reverse'ing an infinite list might take some time...
11:32:24 <TTimo> just start at the end
11:33:01 <elliott> oh
11:33:13 <elliott> yes, that doesn't matter though
11:33:17 <elliott> as long as the trace is at the top
11:33:19 <elliott> shh :)
11:35:08 <_Mikey> cheers mauke and ClaudiusMaximus
11:35:10 <unknownwarrior> elliott: at which point should be the trace inserted at the top? :/
11:35:44 <danr> Is zlib-0.5.3.2 known to be broken? i get an error from Stream.hsc:86:21, using ghc 7.0.3
11:35:47 <_Mikey> I now have a bug in one of my functions... throwing an empty list exception
11:35:57 <_Mikey> is there and easy way to track the function throwing it?
11:36:03 <unknownwarrior> elliott: the file is still like i pasted it here http://hpaste.org/56927 unless my code is de-commented again.
11:36:30 <danr> installing zlib-0.5.3.1 worked
11:37:19 <hpaste> elliott annotated “the whole file for elliott” with “the whole file for elliott (annotation)” at http://hpaste.org/56927#a56928
11:37:27 <elliott> unknownwarrior: it should be like that ^
11:37:33 <elliott> ah
11:37:44 <elliott> hmm, no, i was thinking the problem was your additional unionSorted xs ys line
11:37:47 <elliott> but that should be fine, too
11:37:55 <unknownwarrior> elliott: this task messes me up :/ i wont get this solved today and the deadline is .. today so i guess i thank you for your help and just leave it like it is now
11:38:06 <qpu> if a language was entirely pure, is there a meaningful distinction between run-time and compile-time computation? could all of its computations be done compile time?
11:38:35 <elliott> unknownwarrior: well, if it helps, the problem is the "reverse" call :)
11:38:56 <elliott> qpu: No, because the compiler is expected to terminate.
11:39:15 <unknownwarrior> elliott: okey but .. i need to look at the end of the list somehow, brb
11:39:32 <maurer> Monad m => (a -> m b) -> Map k a -> m (Map k b) -- any reason we don't have a function like this, or just nobody bothered to put it in?
11:40:36 <qpu> elliott: yeah, that's reasonable. i suppose if you're doing c++ templates or something you do so at your own risk
11:40:49 <hpc> @hoogle Map k (m b) -> m (Map k b)
11:40:49 <lambdabot> No results found
11:40:56 <danr> @hoogle (a -> m b) -> f a -> m (f b)
11:40:57 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:40:57 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
11:40:57 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:41:07 <hpc> ah
11:41:08 <danr> traverse? :)
11:41:09 <hpc> yes, that
11:41:13 <maurer> Oh, so I might be able to use Data.Traversable
11:41:33 <maurer> I guess I just didn't phrase my hoogle query right
11:44:56 <elliott> qpu: hmm?
11:45:09 <elliott> unknownwarrior: You don't, actually.
11:45:13 <elliott> At least not if that example is meant to work.
11:45:19 <elliott> qpu: Ah.
11:46:15 <qpu> elliott: i mean you can get into cases where the c++ compiler doesn't terminate (scala too, i think) because of template programming or type-level computation
11:48:11 <elliott> qpu: Yeah.
11:48:14 <_Mikey> is there an quick way to tell which line threw an exception in ghci?
11:48:26 <elliott> qpu: Well, let me rephrase: The compiler is expected to terminate if "static" things terminate.
11:48:39 <elliott> "Static" is of course defined as "things that are run at compile-time". :)
11:49:11 <unknownwarrior> elliot: i dont?
11:49:24 <elliott> unknownwarrior: Indeed, you don't.
11:49:43 <elliott> Indeed, regular should be an infinite list, so you *can't*, and that's why it's failing.
11:50:19 <qpu> elliott: obvious but i overlooked it. thanks for reminding me :]
11:50:28 <unknownwarrior> elliot: so this is a huge task, isnt it?
11:51:06 <elliott> unknownwarrior: Not really.
11:51:17 <elliott> The definition should be quite simple and only take up a few lines at most.
11:51:41 <elliott> Here's a hint: You're not trying to find out which list is bigger as a hole; you're trying to find out where each *element* goes.
11:51:41 <elliott> *whole
11:52:13 <elliott> qpu: Oh, and the compiler is of course not expected to perform side-effects like asking the user for input.
11:52:20 <erus`> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html?  <- notice haskell is the only one he didnt have to joke about ....
11:52:30 <elliott> But a compiler with a halting oracle could fully evaluate every pure expression it can prove terminates, yes.
11:52:40 <parcs`> > ord ' '
11:52:40 <lambdabot>   32
11:52:47 <elliott> erus`: Wadler didn't actually say that, though.
11:53:04 <elliott> Also, Ashton Kutcher and People for the Ethical Treatment of Animals weren't involved.
11:53:19 <elliott> So that's one more joke than every other language got, actually.
11:53:55 <maurer> Is there anything like hGetContents that doesn't put the handle in a semiclosed state by reading until EOF?
11:54:04 <unknownwarrior> elliott: but it is said that i should do this by using lazy evaluation and i cant imagine only handling for example the biggest element without looking at the others. so i thought when these lists are sorted i can just look at the end ..
11:54:09 <maurer> I need to read a full file multiple times.
11:54:11 <lukish> @index find
11:54:11 <lambdabot> Data.List
11:54:16 <lukish> @index partition
11:54:16 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
11:54:20 <maurer> (as it will change over the course of the program execution)
11:54:31 <maurer> And would like to avoid having to reopen the handle every time.
11:54:34 <elliott> unknownwarrior: You don't need to know the biggest element.
11:54:46 <elliott> unknownwarrior: You don't have to preserve the order of the two lists, you want to interleave each element.
11:55:02 <elliott> For instance, unionSorted (x:xs) (y:ys) should start with x if x > y, or y if y > x.
11:55:03 <unknownwarrior> elliott: okey, okey i try
11:55:21 <elliott> Well, not each element. But you want to interleave the contents of the two lists in general.
11:55:54 <mekeor> if i could re-design/improve haskell, i'd remove the character "{" and would make it to syntactic sugar of Data.Set. and furthermore, i'd allow functions with multiple names such that you can define "if.. then.. else.." as a function (like it's in agda). besides, dependent types are great, too.    -- what do you think?
11:56:05 <mekeor> what'd you improve?
11:58:03 <elliott> mekeor: congrats, you just broke records
11:58:34 <mekeor> ?
11:58:58 <mekeor> elliott: why? i'm confused.
11:59:43 <elliott> mekeor: F {x=42, y="hello"}
11:59:58 <hpaste> unknownwarrior annotated “the whole file for elliott” with “the whole file for elliott (annotation)” at http://hpaste.org/56927#a56929
12:00:21 <mekeor> elliott: speak english, not haskell, please.
12:00:30 <qpu> mekeor: records are { label = value }
12:00:39 <unknownwarrior> elliott: still is infinite
12:00:53 <frerich> mekeor: The RebindableSyntax extension to GHC lets you overload if ... then ... else expressions with your own version. In particular, the ifThenElse function is used to define alternative meanings. if e1 then e2 else e3" means ifThenElse e1 e2 e3.
12:00:59 <elliott> mekeor: you want to get rid of {}
12:00:59 <mekeor> qpu: ah, okay
12:01:02 <elliott> mekeor: record syntax uses {}
12:01:25 <mekeor> yea, i got it.
12:01:28 <mekeor> right…
12:02:28 <mekeor> frerich: yea, but AFAIK, you can not define a function "if_then_else_ a b c = ..." in haskell as agda can; wait a second…
12:03:10 <maurer> No ideas on how to read a file without killing the handle?
12:04:16 <mekeor> frerich: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Mixfix
12:04:59 <asante> is there a module where a 2D-Point-Type is defined? i can only find a Graphics.Rendering.Diagrams.Types-Module and some opengl-modules
12:06:08 <qpu> elliott: i'll be digging around for research on the topic of partial evaluation. its easy to veer into halting problem territory, but heuristics might work well enough. i'd welcome any research you can recommend
12:06:09 <elliott> asante: Is a tuple of coordinates not good enough for your purpose?
12:06:38 <asante> elliott, ya, that should work. i could also define it, but i just wondered..
12:06:42 <asante> thanks anyway
12:07:01 <unknownwarrior> elliott: maybe one last hint why this still fails?
12:07:12 <plathrop> cmccann: That looks totally awesome, if only I could understand it... :-)
12:07:15 <elliott> qpu: No research links off the top of my head, but you might want to look into specialisation, e.g. http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
12:07:17 <unknownwarrior> elliott: i annotated it on hpaste
12:07:25 <elliott> which is related
12:07:30 <qpu> elliott: thanks, i was just reading that :]
12:07:45 <elliott> qpu: there's also http://thyer.name/phd-thesis/
12:07:46 <cmccann> plathrop, do you know how unfoldr works?
12:08:00 <elliott> qpu: which i found from http://lukepalmer.wordpress.com/2009/07/07/emphasizing-specialization/ ages ago
12:08:17 * cmccann also notes that tuples are pretty clumsy for representing coordinates
12:08:40 <plathrop> cmccann: Not yet I don't. I'm taking a look now.
12:09:05 <qpu> elliott: oh that's new to me, thanks!
12:09:08 <elliott> maurer: Load a file without killing the handl?
12:09:11 <elliott> *handle
12:09:26 <elliott> qpu: beware that it's a bit of a holy grail type thing
12:09:35 <elliott> qpu: i.e. I doubt we'll be seeing specialisers go even vaguely mainstream any time soon
12:09:37 <cmccann> 2D coordinates are more like a fixed-length list and really want niceties like the Functor and zippy Applicative instances
12:09:46 <elliott> but that applies to anything that verges on a sufficiently-smart-compiler
12:09:48 <elliott> except GHC :P
12:10:03 <elliott> cmccann: agreed, but tuples are simple if you're just doing simple things
12:10:10 <maurer> elliott: Yeah.
12:10:24 <maurer> elliott: I basically want to hGetContents non-lazily and be able to do it again later
12:10:27 <elliott> also, that way lies the nth implementation of type-level naturals and Vec :)
12:10:27 * cmccann has rarely needed coordinates for simple things
12:10:47 <elliott> maurer: right. Force its result, or don't use hGetContents.
12:10:58 <elliott> maurer: evaluate (rnf s) -- using rnf from Control.DeepSeq
12:11:02 <elliott> evaluate (length s) will also work.
12:11:04 <cmccann> elliott, I have my own implementation already :P
12:11:20 <elliott> there is also http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
12:11:32 <maurer> elliott: Forcing its result will still close the file
12:11:32 <elliott> maurer: if you're using Text or ByteString, they have their own strict versions of hGetContents
12:11:37 <elliott> oh, I see
12:11:41 <elliott> what would "doing it again" later mean?
12:11:44 <elliott> returning the same string again?
12:11:47 <maurer> No.
12:11:52 <maurer> I am reading /proc/pid/maps
12:11:54 <elliott> reading everything beyond the previous point?
12:11:56 <elliott> ah.
12:12:02 <maurer> I am trying to avoid reopening the file to get updates
12:12:12 <elliott> maurer: well, you can just write your own hGetContents-alike then
12:12:42 <elliott> blah h = maybeGetChar >>= maybe (return []) ((c:) <$> blah h)
12:12:58 <elliott>   where maybeGetChar = hGetChar h `catch` (\e -> if isEOFError e then return () else throwIO e)
12:13:02 <elliott> or whatever
12:13:30 <elliott> maurer: why are you avoiding reopening the file, incidentally?
12:13:40 <unknownwarrior> elliott: i think i got this now :O take 10 regular works !! plus i guess i use lazy evaluation in my code :D
12:14:07 <maurer> elliott: The application is perf heavy. It would be much nicer if I weren't constantly opening/closing.
12:14:13 <kmc> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString.html#v:hGetContents says "As with hGet, the string representation in the file is assumed to be ISO-8859-1."
12:14:26 <kmc> why does ByteString.hGetContents know or care what the "string representation" of a file is, or even that it has one?
12:14:26 <maurer> elliott: The opening/closing might not be necessary to avoid.
12:14:48 <plathrop> cmccann: Okay, unfoldr is cool
12:14:49 <maurer> kmc: It might be for the Char8 version of bytestring instead of Word8?
12:15:00 <cmccann> plathrop, it is indeed :]
12:15:18 <plathrop> . is function composition, remind me what $ is again?
12:15:20 * plathrop is a n00b
12:15:27 <shachaf> @src $
12:15:27 <lambdabot> f $ x = f x
12:15:39 <kmc> maurer, sure, then it's a bug that it appears on the docs for both
12:15:58 <kmc> but this is because Char8.hGetContents is reexported from ByteString.hGetContents
12:16:24 <plathrop> shachaf: that definition makes $ seem pointless? So clearly I'm not getting something :-)
12:16:26 <kmc> where do i go to file a bug with bytestring?
12:16:28 <maurer> I'll just use readFile for now, and if it chokes later, be sad.
12:16:42 <shachaf> plathrop: The point is to reduce parentheses.
12:16:45 <cmccann> plathrop, note that it has very low precedence
12:16:54 <kmc> > zipWith ($) [pred, succ] [3, 5]
12:16:55 <lambdabot>   [2,6]
12:16:56 <shachaf> plathrop: E.g. f $ a b c d ===> f (a b c d)
12:17:03 <plathrop> Oh. I see.
12:17:11 <elliott> kmc: GHC trac I think
12:17:13 <shachaf> There's also what kmc says, although that would work just as much with id.
12:17:32 <elliott> awesomely the homepage http://hackage.haskell.org/package/bytestring links is 403'd
12:17:35 <plathrop> I come from Common Lisp (and love it) so reducing parens seems weird to me, but cool
12:17:38 <kmc> yep
12:17:53 <elliott> and bytestring isn't listed at https://github.com/haskell... so GHC trac then
12:17:55 <kmc> i don't see libraries/bytestring in the dropdown on ghc's trac search
12:18:04 <kmc> where bugs for e.g. base live
12:18:09 <elliott> plathrop: Reducing parens can have a benefit beyond just readability sometimes.
12:18:09 <shachaf> plathrop: $ is often overused, I think, especially by beginners.
12:18:15 <kmc> preflex, seen dons
12:18:15 <preflex>  dons was last seen on #haskell 9 days, 2 hours, 55 minutes and 37 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
12:18:17 <shachaf> So don't worry about it too much. :-)
12:18:21 <cmccann> plathrop, it's a stylistic thing popular in Haskell, but you don't have to use it. parentheses are fine.
12:18:22 <kmc> ^^^ no it's not cool
12:18:40 <elliott> plathrop: For instance, if you do: f (g (h x)), then that's the same as (f . g . h $ x) -- and that lets you see that you can factor (f . g . h) out into its own definition: foo = f . g . h
12:18:40 <kmc> i guess I'll just email the maintainers
12:18:55 <shachaf> elliott: That has nothing to do with ($), though.
12:18:58 <elliott> So it's more compostional.
12:19:04 <elliott> shachaf: Yeah, I was just responding to "reducing parens".
12:19:08 <shachaf> "(f . g . h) x" works just as well.
12:19:14 <elliott> indeed
12:19:24 <elliott> All time record?
12:19:28 <elliott> We just had 901 days ago.
12:19:28 <plathrop> This channel is awesome. Every time I join it I learn something cool.
12:19:49 <shachaf> Hmm. Maybe I should call "(" and ")" "da" and "mo" (or "mu", in the UK).
12:23:38 <ezyang> So, has anyone argued that IO should not have a MonadPlus instance?
12:25:14 <adimit> Google: Did you mean: you should not have a monadplus instance
12:25:27 <elliott> ezyang: Yes, just days ago I saw someone on haskell-cafe... oh wait. :)
12:25:34 <ezyang> "Yeah yeah"
12:25:59 <ezyang> :^)
12:26:34 <elliott> I forget what your argument was, so I can't remember whether I agree or not. :(
12:26:36 <gwern> > sum [94,86,90,95,101,88,100,106,91] / fromIntegral (length [94,86,90,95,101,88,100,106,91])
12:26:37 <lambdabot>   94.55555555555556
12:26:55 <ezyang> Really simple
12:27:04 <ezyang> MonadPlus law says that mzero `mplus` a === a
12:27:13 <Lemmih> gwern: What are you calculating?
12:27:21 <parcs`> what package defines the Free monad?
12:27:22 <ezyang> But in IO, (fireTheMissiles >> mzero) `mplus` a === fireTheMissiles >> a
12:27:50 <Axman6> but thats not the same...
12:27:55 <elliott> ezyang: Ah. I agree, then.
12:28:15 <elliott> ezyang: The notion of being able to recover from an error without undoing previous effects is valuable, though. I wonder if MonadPlus is all that useful.
12:28:20 <elliott> I mean, Maybe satisfies it, but MaybeT doesn't.
12:28:26 <gwern> Lemmih: I have been running random vitamin d doses at bedtime and awakening to test effect on sleep scores. roberts speculates that taking d in the morning improves sleep at night, as well as taking d at night damages sleep, so I extracted scores from every evening following a placebo/d-in-the-morning day, and that's averaging them
12:28:27 <elliott> Same with (Either e).
12:28:49 <ezyang> Well, as I mentioned on haskell-cafe, STM is very obviously MonadPlus
12:28:54 <gwern> Lemmih: now I'm going to check my record over a year to see whether my normal sleep is greater or less than 95
12:28:55 <cmccann> isn't MonadPlus kind of incoherent about what it means, anyway?
12:28:57 <ezyang> Erm, sorry, that's not what you mean.
12:29:04 <ezyang> cmccann: It's true.
12:29:40 <Lemmih> gwern: Isn't the score determined mostly by how long you sleep? I'm assuming you're using the Zeo.
12:30:04 <gwern> Lemmih: no, it also incorporates fraction by rem/deep, awakening and morning feel, iirc
12:30:09 <elliott> ezyang: Hmm, right.
12:30:10 <gwern> * # of awakenings
12:30:41 <elliott> ezyang: Rephrase: What useful generic operations can you write on MonadPlus that wouldn't work with MonadPlus with laws such that IO is a correct instance?
12:31:02 <elliott> If there aren't many compelling examples, I'd rather generalise MonadPlus than remove instances.
12:31:35 <ezyang> Huh, I wasn't aware that we had that many MonadPlus derived ops.
12:31:40 <elliott> I don't think we do :)
12:31:46 <elliott> Maybe I mean "patterns" rather than "generic operations".
12:32:04 <elliott> i.e., when do you need to assume that law to get something useful done that wouldn't generalise properly to a MonadPlus that didn't require that?
12:33:01 <ezyang> Well, if I want MonadPlus to represent "try each of these things and do the one that actually ends up succeeding" I really really need the monoid law.
12:33:16 * cmccann suggests starting by reconciling Maybe and []
12:33:55 <ezyang> > [1,2,3] `mplus` [4,5,6]
12:33:56 <lambdabot>   [1,2,3,4,5,6]
12:34:01 <rwbarton> isn't the issue that fireTheMissiles >> mzero /= mzero
12:34:03 <elliott> cmccann: Are they not reconciled?
12:34:03 <ezyang> hoo boy
12:34:04 <plathrop> cmccann: wow, as I'm trying to break this down it is bending my brain a bit. So, we're composing a function to pass to JustIf, then passing a partial application of that as the function to unfoldr?
12:34:11 <elliott> ezyang: What's wrong with that?
12:34:14 <elliott> It still follows the laws.
12:34:31 <plathrop> I don't understand the dropWhile part...
12:34:31 <ezyang> elliott: Nothing :-)
12:34:40 <elliott> ah :P
12:35:01 <cmccann> elliott, effectively, when neither argument is mzero, [] takes the "effects" from both arguments, while Maybe keeps only the first argument
12:35:14 <elliott> cmccann: I think that's mixing your semantic layers.
12:35:23 <frerich> Is there a Haskell function like 'IO a -> IO b -> IO (Either a b)' which takes two blocking computations and then yields a value when either of the two returns? Kind of like select() on POSIX or WaitForMultipleObjects on Win32.
12:35:25 <elliott> cmccann: [] is nondeterministic computation.
12:35:31 <elliott> If there are multiple possible successes, it takes them all; that's what defines it.
12:36:34 <cmccann> elliott, yes it makes sense for what it is, but it reduces the semantic content of MonadPlus
12:36:38 <ezyang> rwbarton: Actually, I think I agree with you.
12:36:44 <elliott> cmccann: Well...
12:36:45 <kmc> bytestring bug email sent
12:36:48 <ezyang> That's /exactly/ the problem.
12:36:55 <elliott> cmccann: OK, what else follows the laws so strictly other than Maybe and STM? :P
12:36:58 <elliott> And (Either e).
12:37:25 <elliott> Hmm, the other instances are [], ReadP, P (?), ReadPrec.
12:37:27 <cmccann> elliott, what laws? MonadPlus? does it even have well-defined and agreed-upon laws?
12:37:29 <elliott> But I think transformers gives instances.
12:37:36 <elliott> cmccann:
12:37:36 <elliott>  mzero >>= f  =  mzero
12:37:36 <elliott>  v >> mzero   =  mzero
12:37:40 <Saizan> frerich: soemthing like that: \a b -> do m <- newEmptyMVar; forkIO (a >>= putMVar m . Left); forkIO (b >>= putMVar m . Right); takeMVar m
12:37:42 <elliott> But no mplus laws, huh.
12:37:54 <ezyang> cmccann: Well, while it is the case the zero laws are contentious, I feel that the Monoid laws are pretty uncontroversial
12:37:59 <elliott> cmccann: But by "laws", I mean "what you consider as not diluting the meaning".
12:39:17 <cmccann> plathrop, yes, it's composing functions as an argument to justIf, and that checks to see if there's a new chunk
12:39:50 <cmccann> plathrop, that's composed with the rest, which drops any leading separators before breaking on the first separator
12:40:20 <mm_freak> ezyang: minor note about your recent blog post:  MonadIO is not in the base library
12:40:27 <mm_freak> it's in the 'transformers' library
12:40:32 <cmccann> plathrop, the result will then be a pair of the next chunk and the remaining input, or Nothing if there isn't a new chunk
12:40:34 <ezyang> Erm, it got moved out.
12:40:43 <ezyang> "It used to be in base"
12:40:53 <cmccann> plathrop, and then unfoldr just iterates that until done
12:41:15 <mm_freak> really?  in my four years of haskell i don't remember it being in base ever =)
12:41:32 <mm_freak> it did move from mtl to transformers though
12:41:40 <c_wraith> there's a second implementation of MonadIO hidden inside the ghc package
12:41:45 <cmccann> elliott, there are plenty of reasonable laws for mzero and mplus, the problem is they don't all agree and instances may follow any subset of them :P
12:41:48 <c_wraith> which is...  annoying
12:41:59 <plathrop> cmccann: It's... really awesome. Thanks.
12:42:00 <mm_freak> really?  where?
12:42:10 <olsner> cmccann: which is kind of the same as there being no laws, but each instance doing whatever it does
12:42:10 * plathrop keeps playing with unfoldr to get a good handle on it
12:42:11 <mm_freak> i think i've gone through all GHC.* modules
12:42:43 <cmccann> plathrop, btw, do you see how unfoldr is the exact opposite of foldr?
12:43:10 <c_wraith> mm_freak: no, the ghc package.  GHC.* is mostly in base
12:43:18 <mm_freak> ah, i see
12:43:24 <mm_freak> didn't know there was a separate package
12:43:27 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/MonadUtils.html
12:43:37 <c_wraith> the ghc package is the implementation of ghc itself, mostly
12:43:41 <cmccann> olsner, except that they all have just enough in common to trick people into thinking it all makes sense :P
12:43:44 <mm_freak> i see
12:44:07 <plathrop> cmccann: No, I don't see it yet. I mean, I see it in the docs, but I don't actually get why. Still thinking about it.
12:44:18 <cmccann> plathrop, well, look at the type of foldr
12:44:19 <cmccann> :t foldr
12:44:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:44:24 <mm_freak> c_wraith: well, that could be justified, because as a bootstrappable compiler you'll want as few external dependencies as possible
12:44:25 <monochrom> the "ghc" package is GHC API, usually not used by normal programs
12:44:51 <cmccann> plathrop, the first argument says what to do with a non-empty list, the second argument what to do with an empty list
12:45:21 <NothingMan65> Hey beautiful humans.  How can I modify this snippet to loop and use each element in the [[],[] ... ] matrix as a starting point?
12:45:23 <NothingMan65> zipWith (!!) (getMatrix s w) [0..4]
12:45:31 <c_wraith> mm_freak: right, my point is more...  If it's used internally in the implementation of ghc, but isn't specific to ghc, maybe it shouldn't be hidden and an identical external implementation provided for other code
12:45:37 <cmccann> plathrop, so if you uncurry the first argument, that becomes ((a, b) -> b)
12:46:07 <cmccann> plathrop, and since the empty list is the case where we have no input but still need a "b", we can combine them by using Maybe (a, b) instead of (a, b)
12:46:08 <mm_freak> c_wraith: but not as part of the ghc package
12:46:12 <c_wraith> right
12:46:17 <mm_freak> c_wraith: i'm fine with transformers
12:46:38 <c_wraith> well.  the ghc package already depends on things like base and containers.  Why not add transformers?
12:46:45 <cmccann> plathrop, so that rewrites foldr to have the completely equivalent type (Maybe (a, b) -> b) -> [a] -> b
12:46:48 <cmccann> :t unfoldr
12:46:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:46:54 <cmccann> look similar now?
12:47:01 <plathrop> cmccann: indeed!
12:47:02 <mm_freak> NothingMan65: could you elaborate?
12:47:14 <c_wraith> or, maybe, redo base to be in terms of MonadIO where possible.
12:47:16 <mm_freak> c_wraith: good question
12:47:28 <NothingMan65> Sure.  The snippet gets 4 elements on the diagonal.  But the diagonal starts at index (0,0)
12:47:33 <plathrop> cmccann: I think this explains why I was failing so hard when I was trying to write this code as a right fold
12:47:54 <NothingMan65> I would like to get all of the diagonals (i,j) for i = 0..w, j = 0..h
12:49:00 <mm_freak> NothingMan65: for (i, 0) drop elements from component lists, for (0, j) drop elements from the outer list
12:49:20 <NothingMan65> Can I do this without modifying the list?
12:49:26 <mm_freak> NothingMan65: drop j . map (drop i) $ yourMatrix
12:49:41 <mm_freak> "modifying"?  you're not modifying anything
12:49:53 <mm_freak> haskell data structures are immutable
12:50:03 <cmccann> plathrop, what's going on is that Maybe (a, b) corresponds to the definition of the list type--the "b" is the recursive portion, and we either have Nothing (the empty list) or Just (x, xs) for (x:xs)
12:50:07 <NothingMan65> Hmmm, wow, that seems integral, how did I miss that.
12:50:25 * NothingMan65 skimpers away in shame...
12:50:41 <mm_freak> NothingMan65: of course lists are not a good choice for matrices if you want to access individual elements that way
12:50:56 <NothingMan65> Thanks again, you hearty souls!
12:51:34 <NothingMan65> Champions of functionality! Guardians of knowledge! Saviors of n00bs!
12:51:39 <NothingMan65> My gratitude is yours.
12:51:51 <mm_freak> hehe, no worries
12:51:58 * NothingMan65 bows
12:51:59 <elliott> NothingMan65: Compliments aren't gonna pay your support contract!
12:52:04 <mm_freak> who claimed that unfoldr is the exact opposite of foldr?
12:52:09 <elliott> (Wait, we're not getting paid for this?)
12:52:18 <rwbarton> Wait, you're not getting paid for this?
12:52:21 <plathrop> mm_freak: the docs. Oh, and cmccann
12:52:35 <mm_freak> well, conceptually yes, but it's not strictly true
12:52:57 <mm_freak> there is no unfoldr that can generate an infinite stream as read from /dev/urandom
12:53:46 <mm_freak> unless you're allowed to write infinite source code
12:53:59 <koeien> if you're allowed that, you can solve the halting problem as well.
12:54:11 <koeien> to do*
12:54:30 <elliott> mm_freak: Sure you are.
12:54:35 <elliott> unfoldr rng seed
12:54:36 <mm_freak> hmm…  are you sure?  i can totally imagine interpreters being able to read infinite source code
12:54:50 <mm_freak> elliott: /dev/urandom is not a deterministic PRNG
12:54:51 <plathrop> I solved the halting problem. As far as we can tell the universe is expanding and will continue to expand. Therefore all algorithms are guaranteed to halt at the total heat death of the universe. :-P
12:54:53 <elliott> You can have Chaitin's omega if you're allowed infinite source code.
12:55:00 <koeien> mm_freak: you can enumerate all programs
12:55:05 <elliott> mm_freak: No, but unfoldr rng seed is perfectly possible output for /dev/urandom.
12:55:15 <mm_freak> koeien: not in finite time
12:55:23 <mm_freak> koeien: that's basically the point of the HP
12:55:36 <koeien> mm_freak: right. but if you're allowed to write "infinite source code", you can
12:55:40 <mm_freak> elliott: information theory would disagree with you
12:55:44 * plathrop knows that's not what the halting problem means.
12:56:06 <koeien> if (strcmp(source, prog_1) == 0) { printf("terminates.\n"); return; }
12:56:07 <elliott> mm_freak: I do not think /dev/urandom is true randomness.
12:56:07 <koeien> and so on
12:56:14 <mm_freak> elliott: it doesn't have to be
12:56:19 <elliott> Yes, it's seeded from external sources, but it's still a PRNG.
12:56:29 <elliott> As far as I can tell, you're claiming that PRNGs don't exist.
12:56:43 <mm_freak> well, let's take /dev/random
12:57:06 <mm_freak> there is no unfoldr that can reproduce a /dev/random-generated list
12:57:16 <mm_freak> unless you solved the halting problem, of course
12:57:37 <mm_freak> infinite list, btw
12:58:33 <sully> what exactly is meant by "infinite source code"?
12:58:45 <elliott> mm_freak: I don't think /dev/random is truly random, either.
12:58:49 <koeien> yeah it doesn't really make sense
12:58:55 <elliott> It's not really HotBits-quality.
12:59:08 <mm_freak> elliott: it doesn't have to be
12:59:14 <kallisti> sully: presumably an infinite sequence of instructions in a finite alphabet.
12:59:57 <idest0> hi everyone
13:00:18 <koeien> hi
13:00:27 <sully> and presumably the sequence isn't required to be recursively enumerable?
13:01:15 <koeien> a turing machine with a possibly infinite number of states
13:02:42 <kallisti> sully: it's an ill-define concept, but I would think it's not required.
13:02:47 <kallisti> otherwise it's not much different from a regular program.
13:03:00 <sully> right.
13:03:15 <idest0> after spending some time searching for some good introductory text to haskell, i've come to LYHFGG, and it seems pretty attractive indeed. However, some people (which seem far more competent than me (which is not that hard at that point but anyway)) are saying that this book can put great confusion in some of the major concepts of Haskell, and that one should directly go to RWH. Would you have any help on a choice of one of those 
13:03:18 <sully> I mean, you can make it well defined
13:03:32 <idest0> (oh sorry for the message size, did not realize)
13:03:36 <nand`> idest0: stick with LYAH
13:03:38 <mm_freak> elliott: given that a well implemented /dev/random requires external entropy all over the sequence, it is information-theoretically impossible for an unfoldr with finite source code to reproduce the sequence
13:03:56 <sully> but I think it winds up being "arbitrary partial functions over the naturals"
13:04:06 <nand`> idest0: if you have the aptitude to understand haskell you'll have no problems adapting later on
13:04:08 <elliott> mm_freak: Well, /dev/random is not infinite.
13:04:08 <kallisti> idest0: I started with LYAH and have been doing just fine.
13:04:08 <plathrop> idest0: They're both solid. I read LYHFGG first, and RWH second.
13:04:14 <elliott> mm_freak: If you define it in terms of external entropy.
13:04:25 <kakos> idest0: I would almost take the exact opposite position.  LYH teaches you a lot of basics of Haskell really well that RWH doesn't.
13:04:36 <mm_freak> elliott: physical hypotheses about the end of the world disregarded =)
13:04:41 <koeien> it's also not really the purpose of RWH.
13:04:46 <nand`> also it's not like LYAH is all “hurr do notation imperative programming”. It actually explains what monads are and gives numerous examples
13:04:47 <idest0> alright then, thank you very much for these answers
13:05:02 <kakos> RWH doesn't do a really good job at explaining Monads, for example, and understanding Monads is pretty crucial to Haskell
13:05:12 <plathrop> idest0: I recommend both, for sure. kakos has it right here.
13:05:17 <nand`> stuff like working with lazy styles or optimization is a job for later, not sooner
13:05:17 <idest0> ah ok
13:05:30 <kallisti> RWH just bombards you with large complicated examples written in a fairly imperative style.
13:05:31 <idest0> i'll go with lyah then
13:05:31 <nand`> RWH is a bit confusing if you're clueless, yes
13:05:33 <plathrop> As much as I hate saying that.
13:05:52 * plathrop gives kakos a mock glare
13:05:56 <mm_freak> kakos: i disagree
13:06:03 <kakos> plathrop: You hate saying that I'm right?  I thought you loved me.  :(
13:06:10 <mm_freak> you can very well use haskell productively without knowing a lot about monads
13:06:11 <koeien> oh i liked the monad explanation in RWH, but i understood them already.
13:06:13 <mm_freak> but it helps
13:06:13 <elliott> mm_freak: So, you're arguing based on physical sources but reject the second law of thermodynamics?
13:06:25 <plathrop> kakos: for some values of love.
13:06:29 * cmccann wonders why nobody suggests the gentle introduction
13:06:43 <nand`> You can use everything productively without understanding it
13:06:45 <rwbarton> IMO the strength of RWH is (surprise!) the real-world parts which come later on in the book
13:06:46 <nand`> I can drive my car to work
13:06:52 <nand`> do I know the specifics about how my engine functions?
13:06:53 <kakos> mm_freak: You can, but a lot of haskell is magic if you do something without really understanding monads.
13:07:02 <mm_freak> elliott: no, but i add quantum mechanics
13:07:08 <kakos> What nand` is saying
13:07:16 <cmccann> nand`, understanding how your car's engine works is more like understanding the internals of GHC
13:07:46 <kakos> LYH should really be titled Learn You About Modern Functional Concepts For Great Good.  I became a much better Scala programmer after reading LYH
13:07:49 <nand`> cmccann: true, the analogy may have been a bit off; it would have to be something about the nature of driving my car
13:07:49 <kallisti> nb4 analogy collapse
13:07:59 <mm_freak> kakos: interestingly not understanding everything seems to bother haskell programmers much more than programmers in other languages
13:07:59 <kallisti> oh wait I'm late.
13:08:02 <nand`> either way, understanding things will *always* improve your experience
13:08:06 <nand`> so I recommend it
13:08:14 <plathrop> Yeah, whereas the difference between "using Haskell without getting Monads" and "using Haskell with understanding Monads" seems more like the difference between "I just got my learner's permit" and "Damn that dude can drive"
13:08:14 <cmccann> ok, so monads are like manual gear-shifting, and...
13:08:25 <nand`> mm_freak: other languages are designed to outsource easily
13:08:31 <koeien> mm_freak: maybe that's why i didn't like scala that much :)
13:08:36 <nand`> haskell is designed for programmers
13:08:44 <mm_freak> true =)
13:08:48 <kallisti> dude what if the whole universe is like a car analogy.
13:09:01 <nand`> kallisti: and something about the haskell car making progressive copies of it self
13:09:02 <nand`> amirite
13:09:10 <plathrop> kallisti: What if car analogies are like car analogies? INCEPTION!
13:09:16 <mm_freak> the universe is like a spacesuit
13:09:20 <mm_freak> or was it a burrito?
13:09:21 <mauke> plathrop: no, recursion
13:09:31 <kakos> mm_freak: Haskell's culture has a lot of academia in its history that still persists today and doing stuff without knowing why it works is antithetical to academia
13:09:39 <nand`> ..incursion?
13:09:47 <sipa> reception?
13:10:08 <mm_freak> kakos: but not every haskell programmer comes from academia…  i'm a good example of that
13:10:10 <mauke> "inception" is the beginning of something
13:10:14 <nand`> kakos: I like to think it's because of the type of people that like to use haskell are the type of people that hate seeing somebody do something wrong
13:10:16 * nand` glares at cmccann
13:10:18 <mm_freak> i have a comparably low degree
13:10:40 <kakos> mm_freak: Right.  I'm just explaining why the Haskell community seems more bothered by not understanding what you're doing.
13:10:59 <cmccann> nand`, wait, what did I do
13:11:08 <mm_freak> kakos: for me using haskell without understanding monads didn't work, because not understanding what i'm doing drives me crazy
13:11:24 <nand`> maybe I'm remembering the wrong person, weren't you the guy who kept trying to find the flaws in everybody's explanations of monads?
13:11:33 <plathrop> Cut and paste your way to a successful career!
13:11:37 <mm_freak> but i'm giving haskell workshops, where people happily use IO without even asking how it works
13:11:40 <plathrop> I also hate not understanding.
13:11:54 <cmccann> nand`, maybe, but I doubt I'd be the only one
13:11:57 <nand`> mm_freak: I solved that problem by not actually using haskell until I was done with LYAH
13:12:10 <elliott> That was monochrom, and he was quite right.
13:12:19 <kallisti> mm_freak: well in most languages you don't have to question how side-effects work, they just do.
13:12:31 * cmccann does enjoy trying to poke holes in analogy-based concepts of monads
13:12:34 <nand`> elliott: I wasn't saying it's wrong
13:12:40 <nand`> cmccann: cars?
13:12:49 <elliott> cmccann: Can you poke holes into something without any substance?
13:12:57 <plathrop> cmccann: So, a monad is like sushi...
13:13:02 <nand`> Can you poke a hole in a hole?
13:13:16 <olsner> elliott: that's a no-op since the holes are already there?
13:13:25 <kallisti> monads are like monoids in the category of endofunctors.
13:13:29 <elliott> olsner: Yep!
13:13:44 <nand`> kallisti: 5/5
13:13:51 <plathrop> kallisti: Ouch. My brain hurts now.
13:14:02 <nand`> on the plus side
13:14:06 <cmccann> nand`, car analogies are practically broken by definition
13:14:06 <idest0> kallisti: this is something one can understand without knowing haskell (as a statement)
13:14:20 <nand`> when you actually understand that quote, you can finally relax around monads
13:14:29 <kallisti> idest0: but most people wouldn't understand that without further explanation.
13:14:38 <sully> you can also understand haskell without understanding that statement
13:14:45 <nand`> kallisti: I tried bringing it up casually
13:14:54 <nand`> the first question was generally “what's a monoid” followed by “what's an endofunctor”
13:15:14 <plathrop> I was going to ask "is there such a thing as an exofunctor, then?"
13:15:19 <sully> you don't need a deep category theory understanding of monads to use them effectively
13:15:20 <koeien> haha
13:15:44 <nand`> to which my mind instantly imagined a monad describing the answering of a question and the resulting questions it results in
13:16:21 <plathrop> Oh hey! I guess there is.
13:16:26 <cmccann> turning a question into multiple questions sounds more comonadic to me
13:16:40 <nand`> cmccann: you may have a point. What's a comonad?
13:16:52 <kallisti> a monad in the dual category. :>
13:17:03 <elliott> A comonad is like a car that you can turn into a car with a car inside it.
13:17:04 <plathrop> nand`: I see what you did there.
13:17:07 <cmccann> nand`, a monad from the evil mirror universe
13:17:09 <cmccann> with a goatee
13:17:09 <elliott> Also, you can take everybody out of the car, and the car disappears.
13:17:24 <elliott> A world with comonadic cars is a world where cars drive bigger cars.
13:17:44 <dolio> A comonad is a comonoid in the category of endofunctors.
13:18:39 <nand`> cmccann: judging by wikipedia, a monad where the functor component maps from the opposite category, in which all morphisms are reversed. More or less accurate?
13:18:56 <rwbarton> fun exercise if you haven't seen it before: why don't we use a Comonoid type class?
13:20:13 <frerich> cmccann: Thanks a ton for mentioning the 'Source' links next to functions in hackage docs. I never noticed those links, very very useful!
13:20:38 <dolio> Because types are a boring monoidal category.
13:20:46 <frerich> cmccann: (Just noticed I was reading an answer by you mentioning them, on SO)
13:20:59 <cmccann> frerich, I was about to ask when I said that :]
13:21:12 * nand` wonders what a programming language based on CoHask would look like. Unhaskell?
13:21:22 <cmccann> nand`, beats me, I'm not that good with straight-up category theory :P
13:21:22 <ceasarbautista> Can someone help a Haskell newbie? I'm trying to use digitToInt and I'm getting compile errors, I'm guessing because I don't get imports.
13:21:32 <koeien> ceasarbautista: sure, paste your code
13:21:33 <koeien> @hpaste
13:21:33 <lambdabot> Haskell pastebin: http://hpaste.org/
13:21:35 <dmwit> ?hpaste some code, ceasarbautista
13:21:36 <lambdabot> Haskell pastebin: http://hpaste.org/
13:21:59 <nand`> digitToInt is in Data.Char
13:22:18 <hpaste> Ceasar pasted “digitToInt trouble” at http://hpaste.org/56931
13:22:32 <koeien> ah yes, add   import Data.Char
13:22:48 <koeien> you can find these functions using hoogle
13:22:48 <koeien> @whereis hoogle
13:22:48 <lambdabot> Maybe you meant: where where+
13:22:48 <nand`> !hoogle digitToInt
13:22:49 <koeien> @where hoogle
13:22:49 <lambdabot> http://haskell.org/hoogle
13:22:51 <nand`> err
13:22:52 <nand`> hoogle digitToInt
13:22:53 <nand`> ..
13:22:54 <nand`> @hoogle digitToInt
13:22:56 <lambdabot> Data.Char digitToInt :: Char -> Int
13:23:07 <cmccann> nand`, in Haskell terms you have functions with types like "(Comonad w) => w a -> a" and "(Comonad w) => w a -> (w a -> b) -> w b" that correspond to return and (>>=)
13:23:21 * nand` notes that DuckDuckGo.com has a !hoogle bang
13:23:27 <koeien> nand`: really? awesome :)
13:23:28 <Axman6> :o
13:23:40 <koeien> too bad the results suck.
13:23:49 <ceasarbautista> Ah. Okay, thanks. And yeah, I found it on Hoogle but couldn't figure out how stdlib imports work.
13:23:53 <nand`> cmccann: right, just the morphisms reversed
13:24:15 <nand`> dolio: wouldn't it be “a comonad is a monoid in the cocategory of endofunctors”?
13:24:30 <nand`> or is that the same
13:24:44 <dolio> nand`: A comonoid in the category of endofunctors is a monoid in the cocategory of endofunctors.
13:24:56 <stepcut> yay!
13:25:06 <nand`> koeien: what do you mean? https://duckduckgo.com/?q=!hoogle+digitToInt It doens't seem too different from what lambdabot does
13:25:21 <koeien> nand`: ah no, the results in general
13:25:30 <nand`> oh, yeah, I don't use DDG for its own search engine
13:25:55 <nand`> dolio: fair enough
13:26:20 <nand`> actually, that makes sense
13:26:25 <parcs`> @djinn Monad m => m (a, b -> m c) -> m (a, b -> c)
13:26:26 <lambdabot> -- f cannot be realized.
13:27:04 <koeien> parcs`: that's not possible, think of IO.
13:27:34 <nand`> :t unsafePerformIO
13:27:35 <lambdabot> Not in scope: `unsafePerformIO'
13:27:41 <koeien> nand`: ...
13:27:48 <nand`> I was joking :)
13:28:13 <nand`> dolio: I just realized it's actually like that by definition
13:28:28 <nand`> “a comonoid in a monoidal category C is a monoid in the dual category C^op.” [wikipedia]
13:28:32 <dolio> Yes.
13:29:15 <chillitom> hi guys, is there a quick way to get up a ghci console in a Yesod app with all the right flags and options set and modules loaded?
13:30:47 <donri> chillitom: cabal-dev ghci
13:31:47 <chillitom> donri: thanks!! been hitting my head for an hour
13:32:21 <donri> i don't think that helps
13:33:20 <nand`> it's a figure of speech :rolleyes:
13:33:26 <donri> :)
13:33:43 <nand`> sometimes mathematicians need to be reminded of such things :P
13:34:31 <dmwit> :t split
13:34:32 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
13:34:35 <donri> jbobau ko
13:34:54 <nand`> donri: lojban?
13:35:21 <donri> go'i
13:35:27 <dmwit> ?quickcheck let braid (a, (b, c)) = ((a, b), c) in \g -> (first split . split) g == (braid . second split . split) g
13:35:27 <lambdabot> Unknown command, try @list
13:35:34 <dmwit> ?check let braid (a, (b, c)) = ((a, b), c) in \g -> (first split . split) g == (braid . second split . split) g
13:35:35 <lambdabot>   Add a type signature
13:35:42 <dmwit> ?check let braid (a, (b, c)) = ((a, b), c) in \g -> (first split . split) g == (braid . second split . split) (g :: StdGen)
13:35:43 <lambdabot>   No instance for (GHC.Classes.Eq System.Random.StdGen)
13:35:43 <lambdabot>    arising from a use...
13:35:50 <dmwit> bleh
13:36:11 <nand`> donri: .ua, unfortunately I forgot basically everything
13:36:15 <nand`> probably wrong channel
13:36:17 <donri> u'i
13:37:18 <danr> oO are you speaking lojban?
13:37:27 <donri> go'i
13:37:45 <danr> bah! speak itkhuil instead
13:37:59 <danr> ithkuil
13:38:08 <donri> oO(answering in lojban, kinda like when mm_freak(?) hpasted how to make hpaste work during dns move)
13:38:09 <shachaf> Unless you're speaking about Haskell, you should speak it in another channel. :-)
13:38:23 <nand`> 43 65 61 73 65 20 79 6f 75 72 20 69 72 72 65 6c 65 76 61 6e 74 20 72 61 6d 62 6c 69 6e 67 73 20 61 6e 64 20 73 70 65 61 6b 20 61 20 70 72 6f 70 65 72 20 61 6c 70 68 61 62 65 74 2c 20 6e 65 72 64 73
13:38:25 <danr> donri: lol, that's pretty clever of mm_freak
13:38:55 <nand`> shachaf: that reminds me
13:38:58 <nand`> does lojban have a word for haskell?
13:39:05 <donri> xaskyl
13:39:12 <nand`> I see what you did there
13:41:11 <mauke> lolban
13:42:51 <donri> prologban
13:44:37 <mm_freak> donri, danr: that wasn't me
13:44:51 <ClaudiusMaximus> ^^ truth
13:45:34 <donri> so many nicks, so much haskell to fit into short-term memory
13:47:12 <donri> merijn is guilty! http://hpaste.org/56898
13:47:43 <ClaudiusMaximus> is GPipe maintained?  no update since 2010...
13:48:42 <elliott> ClaudiusMaximus: I don't think so, although the author responded to some github issues I created
13:48:45 <elliott> but only once :)
13:49:04 <ClaudiusMaximus> getting bored of writing glsl and accompanying boilerplate
13:49:05 <mm_freak> a question totally or not even remotely related to haskell depending on your viewpoint:  there is this kind of euphoria you experience when you discover something very abstract, but in this highly abstract sense very beautiful…  is there a word for this feeling?  not looking for insanity here
13:49:27 <qpu> epiphany?
13:49:31 <elliott> mm_freak: mathematics? :p
13:49:36 <donri> nirvana?
13:49:44 <mm_freak> lol elliott
13:50:06 <mm_freak> qpu: close
13:50:11 <CodeWeaver> mm_freak: Absolutely.  I see it in students I tutor all the time, when the lightbulb goes on.  I feel it whenever I learn something new.
13:50:12 <nand`> power
13:50:44 <nand`> 's what I feel. The power to apply my knowledge, gained in an abstract space, to concrete situations
13:50:58 <mm_freak> well, it's a stronger feeling…  epiphany is close…  like getting onto a new level of awareness
13:51:08 <monochrom> elegant
13:51:09 <donri> the power to apply your knowledge, without anyone else being able to understand it
13:51:12 <nand`> the greatest feeling is learning something in an abstract model and applying it back to the situation we made the model for
13:51:14 <CodeWeaver> mm_freak:  How about 'raising conciousness'?
13:51:52 <qpu> elevate!
13:51:59 <mm_freak> CodeWeaver: something like that, but that's not what i'm looking for…  i'm looking for the feeling of excitement that comes with that…  euphoria is the strongest word i could find
13:52:37 <donri> enlightenment
13:52:39 <CodeWeaver> I do have an interesting optimization problem if someone wants a distraction.  I've been trying to get a bit of code down to near C levels of performance.  I'm within a factor of about 5, but I've hit a wall.  Just want to convince myself its a wall I can't overcome by learning more Haskell.  Which is probably not true. :)
13:52:39 <qpu> google sets never helps for pinpointing words like that
13:52:56 <koeien> CodeWeaver: i am not claiming to be able to help, but
13:52:57 <koeien> @hpaste
13:52:58 <lambdabot> Haskell pastebin: http://hpaste.org/
13:53:12 <mm_freak> CodeWeaver: probably, just paste the code
13:54:57 <Lemmih> CodeWeaver: Pass the code through the #haskell transformation and you'll get near optimal performance.
13:55:06 <CodeWeaver> heehee
13:55:16 <CodeWeaver> Well, the problem's fairly simple to state, and has probably been approached by a lot of people before:
13:55:16 <CodeWeaver> Generate a container (array, list, whatever, as long as its fully de-thunked) of a sequence of positive integers in order starting at 2 that has all multiples of 2, 3, and 5 without repeats.
13:55:33 <CodeWeaver> Outputting them isn't the point.   Just having them generated and available.
13:55:36 <Lemmih> An -O#haskell flag was considered but the latency was deemed too high.
13:55:48 <koeien> hehe
13:55:53 <CodeWeaver> Hahahahahahaha
13:55:56 <mm_freak> CodeWeaver: sounds like a simple wheel to me
13:56:29 <CodeWeaver> It may very well be.  There are a few approaches.  I've tried generating merges of lists, merges of vectors, and just spinning through all the integers in sequence and testing.
13:56:44 <CodeWeaver> Also, unboxing, strict fields....
13:56:46 <c_wraith> eh.  I don't understand how you can generate an infinite structure fully de-thunked...
13:56:50 <CodeWeaver> Sorry.
13:56:54 <mm_freak> CodeWeaver: basically you don't have to calculate anything there
13:56:56 <CodeWeaver> Up to a maximum value, say, 10 million.
13:57:06 <CodeWeaver> Finite list.
13:57:15 <mm_freak> or perhaps you do
13:57:15 <mm_freak> wait
13:57:37 <CodeWeaver> I'm happy for it to be an infinite list, and then just use takeWhile and deepSeq out the list.
13:57:38 <c_wraith> what are you going to do with this container?
13:57:43 <c_wraith> iterate?
13:57:45 <c_wraith> test?
13:58:11 <CodeWeaver> Well, consider it to be an analog of storing the values like a C array.  I don't *really* care if it's a tree or list, as long as all the values are there.
13:58:14 <c_wraith> what your intended purpose is makes a big difference.
13:58:22 <c_wraith> But what will  you use it for?
13:58:39 <CodeWeaver> Let's say I wanted to output them all in principle, in order.
13:58:59 <mm_freak> CodeWeaver: how long does your algorithm take for how many elements?
13:59:01 <CodeWeaver> I just don't want to time actually outputting them.
13:59:11 <koeien> maybe output the sum?
13:59:12 <ceasarbautista> Having some more trouble getting join to work with Strings. Why doesn't "import Data.String.Utils" work?
13:59:33 <c_wraith> > join ["foo", "bar", "baz"]
13:59:34 <lambdabot>   "foobarbaz"
13:59:47 <c_wraith> @hoogle Data.String.Utils
13:59:48 <lambdabot> package array-utils
13:59:48 <lambdabot> package astview-utils
13:59:48 <lambdabot> package bluetileutils
14:00:11 <c_wraith> @hackage array_utils
14:00:12 <lambdabot> http://hackage.haskell.org/package/array_utils
14:00:13 <ceasarbautista> > join " "  ["foo", "bar", "baz"]
14:00:13 <lambdabot>   Couldn't match expected type `[a]'
14:00:14 <lambdabot>         against inferred type `GHC.Types...
14:00:14 <c_wraith> err
14:00:17 <nand`> :t join
14:00:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:00:21 <c_wraith> oh, you want intercalate
14:00:22 <koeien> ceasarbautista: join is something else entirely.
14:00:24 <nand`> oh right
14:00:34 <c_wraith> > intercalate " " ["foo", "bar", "baz"]
14:00:35 <lambdabot>   "foo bar baz"
14:00:40 <cmccann> join just means concat in this case
14:00:40 <ceasarbautista> Sorry. Used to Python.
14:00:45 <c_wraith> That's just in Data.List
14:01:09 <CodeWeaver> Well, the real timing is going to be hardware dependent.  For C I got 0.042 seconds.  For Haskell using an IO loop and unboxed mutable vectors I got 0.130s.  For Haskell using unboxed unmutable vectors I got 0.200s.
14:01:12 <nand`> >join [[1,2,3],[4,5,6]]
14:01:22 <nand`> > join [[1,2,3],[4,5,6]] -- ceasarbautista
14:01:23 <lambdabot>   [1,2,3,4,5,6]
14:01:25 <CodeWeaver> For a maximum value in the array of ten million.
14:01:40 <CodeWeaver> (note maximum value, not number of elements).
14:01:42 <koeien> CodeWeaver: are you using GMP in C?
14:01:58 <CodeWeaver> GMP?
14:02:07 <CodeWeaver> Clue me in.  I haven't had coffee yet.
14:02:19 <koeien> or is there no overflow?
14:02:20 <cheater_> gmp is a lib
14:02:22 <c_wraith> CodeWeaver: this is hard to make recommendations on because it's really not clear what it is you're *doing*.
14:02:42 <c_wraith> CodeWeaver: if this is just a synthetic test, what is the ultimate goal of your test?
14:03:18 <CodeWeaver> Mostly seeing if I can get haskell to generate code close to C code for a similar problem.  How about I post the C code to show the idea?
14:03:37 <elliott> CodeWeaver: Have you tried Data.Vector?
14:03:37 <CodeWeaver> I realize it *is* a synthetic test.
14:03:40 <c_wraith> CodeWeaver: because often, the answer to poor performance in haskell is "don't do it that way."
14:03:43 <CodeWeaver> Yes, I'm using Data.Vector.
14:03:47 <elliott> Right.
14:03:51 <elliott> Is your data multi-dimensional?
14:03:54 <rwbarton> CodeWeaver: yes, please post your C code
14:04:26 <mm_freak> CodeWeaver: do you want /all/ or /no/ multiples of 2, 3 and 5?
14:04:54 <CodeWeaver> c_wraith:  Yes, I get that in the 'real world' each language should be played to its strengths.  But let's say, for example, I wanted to know the i'th element of this container in a good worst case time.  In the case of a Data.Vector or Data.Array I could do it in constant time after the table was fully de-thunked.
14:04:59 <nand`> it's like saying “C is faster at processing an imperative state machine”
14:05:11 <CodeWeaver> All multiples of 2, 3, and 5, with no repeats, in order, up to a maximum value.
14:05:13 <elliott> CodeWeaver: Is your data multi-dimensional?
14:05:20 <CodeWeaver> Nope, one dimensional.  A single table of ints.
14:05:20 <rwbarton> guys... how about waiting to see the C code
14:05:28 <elliott> CodeWeaver: Well, you might want to try repa anyway.
14:05:31 <rwbarton> rather than playing 20 questions
14:05:32 <CodeWeaver> yes, okay, where should I paste C code?
14:05:32 <elliott> Since it has automatic parallelisation stuff.
14:05:37 <elliott> hpaste.org
14:06:49 <hpaste> CodeWeaver pasted “2,3,5 sequence in C, to port to haskell” at http://hpaste.org/56932
14:07:00 <CodeWeaver> That is freaking cool, pasting showing up as a link here.
14:07:06 <CodeWeaver> Did I mention I love the haskell community? :D
14:07:13 <elliott> CodeWeaver: That looks like something you'd want to rely on fusion for.
14:07:17 <CodeWeaver> i agree.
14:07:25 <rwbarton> Thanks.
14:07:28 <elliott> Which means that the array won't exist at runtime at all.
14:07:37 <CodeWeaver> The way I did it in C is just to iterate over all integers since *most* of them end up in the array.  I'm willing to entertain other ways of populating the container.
14:07:39 <elliott> CodeWeaver: Can you change the C program to print out the array?
14:07:41 <mauke> CodeWeaver: don't cast malloc
14:07:46 <elliott> I doubt deepseq fuses.
14:07:50 <nand`> CodeWeaver: I like how most of the haskell tools are made by Really Smart People(tm), I still smile when I see hoogle automatically bringing up polymorphic functions that would match my signature
14:07:53 <nand`> and lambdabot is just amazing
14:08:01 <CodeWeaver> elliot, there's a print loop at the bottom, commented out.
14:08:01 <nand`> stuff like @djinn or @free or even @pl
14:08:12 <elliott> CodeWeaver: Uncomment it, then :P
14:08:22 <Eduard_Munteanu> @oeis 2,3,5
14:08:26 <elliott> Useless benchmarks still have to give results, or it's too easy to cheat on them!
14:08:30 <CodeWeaver> I have to cast malloc.  It comes back as a char*.
14:08:35 <koeien> CodeWeaver: not in C
14:08:35 <lambdabot>  The prime numbers.
14:08:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:08:43 <nand`> Don't you have to check for a malloc error first? (not a C programmer)
14:08:44 <koeien> in C++ yes
14:08:51 <elliott> CodeWeaver: untrue
14:08:55 <rwbarton> what is this ##c
14:08:55 <elliott> malloc returns (void *)
14:08:58 <koeien> nand`: yeah but otherwise you'll get a segfault in normal code.
14:09:00 <elliott> koeien: malloc returns (void *) in C++ too
14:09:04 <elliott> but C++ is stricter about casting
14:09:10 <koeien> elliott: yes, that's what i meant.
14:09:18 <CodeWeaver> Blargh, can we not argue about the strictness of my type safety? I prefer being explicit, and it has nothing to do with the problem. :)
14:09:20 <koeien> nand`: s/code/circumstances
14:09:28 <elliott> http://c-faq.com/malloc/mallocnocast.html
14:09:38 <elliott> hmm, that's a really silly reason given :)
14:09:43 <elliott> but it's really really unidiomatic to do that in C anyway
14:09:45 <monochrom> I guess this is why askers don't want to show actual code
14:09:49 <Eduard_Munteanu> You still have to check the pointer in C or C++, although it will fail rather gracefully if you don't.
14:09:54 <Eduard_Munteanu> (null pointer dereference)
14:10:05 <CodeWeaver> Yes, I should have detected malloc returning null.  Can we gloss over that too? :D
14:10:06 <elliott> monochrom: :)
14:10:11 <Eduard_Munteanu> At least when you access the first element.
14:10:12 <CodeWeaver> At least I free'd.
14:10:14 <CodeWeaver> :P :D
14:10:14 <mauke> CodeWeaver: casting malloc doesn't add any safety but it can hide errors
14:10:18 <koeien> CodeWeaver: haha
14:11:21 <CodeWeaver> mauke:  I've never personally run into that after decades of coding in C and C++, but Im all in favour of learning why — later.
14:11:25 <elliott> CodeWeaver: you're not meant to free() data that expires with the process :)
14:11:41 <monochrom> A:"hi I have a type error in this code hpaste.org/39283493" B:"why the bloody hell are you not using camel case? also you should indent by a power of 2"
14:11:42 <CodeWeaver> I always free cleanly as a matter of policy.  Cope.
14:11:51 <nand`> :t (\|)
14:11:52 <lambdabot> Not in scope: `\|'
14:11:58 <nand`> @hoogle \|
14:11:58 <lambdabot> No results found
14:11:59 <elliott> CodeWeaver: I bet it'd be faster without the free() call :)
14:12:26 <nand`> elliott: it'd be faster with inline assembly, less stack overhead due to the function call
14:12:38 <CodeWeaver> Um, okay.  C version fast enough.
14:12:38 <CodeWeaver> :D
14:12:53 <CodeWeaver> Focus is over there at that other shiny object. :D
14:13:16 <mauke> the C version doesn't do anything
14:13:41 <CodeWeaver> It populates the array for access 'later' in principle.  This is about generating a container of values to be looked up later.
14:13:52 <nand`> CodeWeaver: so how fast is [x| x <- [1..], x `mod` 2 == 0, x `mod` 3 == 0] etc?
14:14:02 <nand`> oh wait
14:14:12 <elliott> CodeWeaver: It's really only fair if you print out the array, because an idiomatic solution in both languages might leave "initialisation" to later.
14:14:13 <nand`> you want either or
14:14:24 <CodeWeaver> I don't want to time the console output.
14:14:25 <elliott> CodeWeaver: You would not use deepseq if you're going to use the container later like that.
14:14:26 <cmccann> I believe you will find that Haskell is usually faster than C at generating values which are clearly never used
14:14:31 <CodeWeaver> Yes, elliot, your'e right.
14:14:36 <nand`> elliott: suffice to access the millionth element, no?
14:14:40 <elliott> CodeWeaver: And so deepseq won't be subject to things like fusion.
14:14:46 <nand`> or calculate the sum
14:14:47 <nand`> or something
14:14:51 <nand`> that way you won't measure IO
14:14:56 <CodeWeaver> Clearly I was careful to say 'a fully dethunked container'
14:14:57 <koeien> nand`: but then we'd fuse the loop
14:14:58 <monochrom> I vote for printing out the last item
14:15:01 <CodeWeaver> Vector, for example.
14:15:03 <elliott> So you're really being unfair here: Haskell isn't failing at anything but not being able to "do nothing" in a certain amount of time where the source code looks a certain way.
14:15:08 <rwbarton> uh
14:15:15 <rwbarton> can we stop being ridiculous for one moment please
14:15:18 <ceasarbautista> > head "I like dogs " == "I"
14:15:19 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:15:19 <lambdabot>         against inferred type...
14:15:19 <elliott> You're not really being agnostic over the set of all possible Haskell solutions to the problem by the way you're phrasing it.
14:15:37 <ceasarbautista> Can anyone explain that one..?
14:15:45 <koeien> ceasarbautista: use 'I'
14:15:53 <koeien> 'I' is a Char
14:15:55 <koeien> "I" is a String
14:16:00 <ceasarbautista> Ah. Thank you.
14:16:02 <mauke> "I" is ['I']
14:16:08 <CodeWeaver> Do I really have to add so many conditions to a haskell solution to make 'looking up a table of preinitialized values where there's going to be minimal access overhead to any given element' fairly obvious?
14:16:27 <parcs`> > take 1 "I like dogs" == "I" -- ceasarbautista
14:16:28 <lambdabot>   True
14:16:29 <mauke> CodeWeaver: yes
14:16:39 <CodeWeaver> blargh. ;)
14:16:43 <elliott> CodeWeaver: Yes, since data is vastly different in Haskell.
14:16:50 <rwbarton> CodeWeaver: no
14:16:57 <elliott> CodeWeaver: Adding the console output is likely to disadvantage Haskell more than C, anyway.
14:17:08 <elliott> Haskell's IO almost certainly has more overhead for that than stdio.
14:17:55 <CodeWeaver> Then given that it would force dethunking of everything anyway, I'm confused as to why this matters.  Let's say I wanted to output the container twice or three times, from the beginning.
14:18:01 <nand`> elliott: fairly positive they're both bottlenecked by the terminal emulator
14:18:08 <elliott> nand`: >/dev/null
14:18:17 <elliott> CodeWeaver: It matters because of things like fusion.
14:18:24 <frerich> Does anybody here have experience with the readline or editline packages on Mac OS X, maybe even in combination with System.Console.ANSI (or maybe hscurses)? I'm trying to show a readline-style prompt at the bottom of the screen but can't seem to get it working.
14:18:33 <elliott> If you want a fair assessment of how good Haskell is at populating a data structure, your current task won't achieve it.
14:18:41 <elliott> Because it doesn't adequately model how this would be done in Haskell.
14:19:10 <frerich> The 'readline' package didn't work out of the box (I have no readline library, just libedit), the 'editline' package works well but I don't see how to position the input field on the terminal. Using 'setCursorPosition' and similiar ANSI functions didn't seem to have an effect.
14:19:13 <mm_freak> CodeWeaver: is 100 ms for the first 10^6 multiples of 2, 3 and 5 a good time?
14:19:16 <CodeWeaver> Okay, how would it be done in haskell?  What options might I have to do this differently so that I could generate this data fast and have it available for output?
14:19:41 <hpaste> rwbarton annotated “2,3,5 sequence in C, to port to haskell” with “2,3,5 sequence in C, to port to haskell (annotation)” at http://hpaste.org/56932#a56934
14:19:44 <elliott> CodeWeaver: I would try and phrase it as a pipeline with vector or repa in such a way that fusion will kick in.
14:19:53 <CodeWeaver> mm_freak:  That's… pretty good.  But how does it compare to the C test?  Its hard to benchmark across hardware.
14:19:55 <rwbarton> this is 2x the runtime as your C program on my machine
14:19:59 <elliott> rwbarton: suggest `rem`
14:20:02 <rwbarton> good call
14:20:19 <rwbarton> now it is about 150% runtime
14:20:31 <rwbarton> so, pretty good
14:20:31 <mm_freak> CodeWeaver: wait, gimme a minute to optimize a bit more, then i'll paste the code
14:20:55 <CodeWeaver> Great googly moogly!
14:21:09 <CodeWeaver> Does that 'seq' call really dethunk the values and the vector?  It is unboxed so…. wow.
14:21:13 <rwbarton> I don't know if you can gain advantage by knowing the size of the vector ahead of time
14:21:25 <mm_freak> CodeWeaver: ok, got 40 ms now
14:21:29 <CodeWeaver> O.O
14:21:31 <elliott> hahaha
14:21:41 <CodeWeaver> I'M NOT WORTHY!
14:21:43 <CodeWeaver> I'M NOT WORTHY!
14:21:44 <CodeWeaver> *bows*
14:21:46 <koeien> rwbarton: for me that version is actually faster than C
14:22:03 <elliott> rwbarton: hmm
14:22:06 <rwbarton> interesting
14:22:09 <elliott> rwbarton: maybe V.fromList and filtering on a list could be faster
14:22:15 <elliott> if the list is fused out
14:22:18 <CodeWeaver> please feel free to annotate with other variations.
14:22:22 <rwbarton> elliott, I'm hoping the intermediate vector is fused
14:22:28 <rwbarton> but I can try that also
14:22:30 <elliott> rwbarton: yeah, fair enough
14:22:32 <CodeWeaver> Also… what compile options did you use?
14:22:35 <koeien> elliott: i tried that, for me it's slower. maybe i did something else wrong.
14:22:48 <rwbarton> just ghc -O2
14:22:52 <monochrom> mm_freak: what did you do?
14:22:56 <CodeWeaver> Really?  *nothing* else?
14:22:59 <CodeWeaver> Wow.
14:23:00 <koeien> yes
14:23:05 <rwbarton> okay I used --make because I forgot I don't need to now :P
14:23:09 <koeien> ah i used -fllvm.
14:23:13 <mm_freak> monochrom: wait a minute, i'll post the code in a couple of minutes
14:23:46 <koeien> llvm makes it faster for me
14:23:52 <rwbarton> does rem have any silly checks like mod or could it help to use an underlying primitive?
14:24:20 <CodeWeaver> Okay, so these times don't help me without the c baseline, but I'll try your examples on my own box.
14:24:39 <CodeWeaver> I really should try llvm on my box, but I'm not sure how to get that established.
14:24:53 <mm_freak> needs 3.6 seconds for the first 10^8 multiples of 2, 3 and 5 now
14:25:08 <Peaker> Did anyone read the "Why dependent types matter" paper?
14:25:13 <rwbarton> also, I wonder whether there is a way to unfuse that vector, to see how much the gain from fusion is
14:25:32 <Peaker> I wonder how hard it would be to add a proof that the result of the sort is a permutation of the input (which, iiuc, will make the sort fully proven correct)
14:25:45 <koeien> for me the C version is slower than hs with -fllvm, lol
14:25:47 <nand`> > let f = (==0) .: flip mod in filter (or . (map f [2, 3, 5] <*>) . pure) [1..]
14:25:48 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,...
14:26:06 <rwbarton> koeien: what about compiling the C with llvm :P
14:26:18 <nand`> presenting, maximum golf
14:26:25 <koeien> rwbarton: maybe i should do that, yes, i used gcc -O2 :)
14:26:36 <CodeWeaver> Interesting.  the vector/filter version is still at 0.130 seconds on mine for max value of 10 million.  Its still way more *elegant* than my haskell version.
14:27:02 <nand`> elegance is a matter of perspective
14:27:04 <CodeWeaver> I wonder if 7.2.2 on OSX 64 bit isn't up to snuff on back end code generation.  I really should try llvm.
14:28:16 <CodeWeaver> That's about a factor of 8 or 9 slower than the C version on my box.
14:28:20 <CodeWeaver> Curious.
14:28:33 <nand`> CodeWeaver: the one I posted?
14:28:50 <nand`> or llvm
14:28:56 <CodeWeaver> No, the one rwbarton posted.
14:29:02 <mm_freak> now i'm at 30 ms for 10^6 numbers
14:29:08 <copumpkin> anyone know of any haskell gpg bindings/implementation?
14:29:10 <CodeWeaver> I'll try yours, nand
14:29:12 <nand`> don't
14:29:14 <mm_freak> i'll post my code now
14:29:32 <elliott> CodeWeaver: what ghc version
14:29:41 <CodeWeaver> 7.2.2 osx 64 bit, running on lion.
14:29:53 <frerich> CodeWaver: For me (gcc 4.2.1 compiling with 'gcc -O2' and ghc 7.0.2 with 'ghc -O2'), the C version takes 133ms on average, the Haskell version takes 214ms
14:30:00 <hpaste> “Ertugrul Söylemez” pasted “Fast multiples of given numbers” at http://hpaste.org/56935
14:30:07 <elliott> CodeWeaver: also, did you replace `mod` with `rem`?
14:30:08 <CodeWeaver> Yes, I"m not getting those kind of time comparisons.
14:30:15 <CodeWeaver> I'm getting a factor of 8, not  factor of 2-3
14:30:15 <mm_freak> CodeWeaver: see last paste
14:30:28 <mm_freak> you'll need the ScopedTypeVariables extension
14:30:43 <elliott> mm_freak: you might want to add a main to that
14:30:44 <mm_freak> (or remove the type signatures below the 'where')
14:31:07 <koeien> CodeWeaver: for me C is at 1.1s, haskell at 750ms
14:31:08 <mm_freak> elliott: the main is as simple as:  main = print (take someLargeNumber $ sieve [2, 3, 5])
14:31:10 <elliott> mm_freak: ah
14:31:17 <koeien> CodeWeaver: for 1e8 numbers
14:31:20 <CodeWeaver> Such fast differences in compiler timings.
14:31:32 <elliott> mm_freak: except you'd need deepseq or whatever
14:31:33 <mm_freak> 'sieve' produces an infinite list of products of the given numbers
14:31:36 <elliott> since CodeWeaver doesn't want any IO :P
14:31:44 <CodeWeaver> :P
14:31:50 <mm_freak> main :: IO ()
14:31:50 <mm_freak> main = print (foldl' (+) 0 . take 1000000 $ sieve [2 :: Int, 3, 5])
14:31:53 <mm_freak> this is my main
14:31:55 <mm_freak> it just prints the sum
14:32:12 <elliott> Maybe CodeWeaver should also tell us what C compiler flags they're using.
14:32:26 <mm_freak> and i compiled with -O
14:32:31 <nand`> -O7 -funroll-loops
14:32:37 <elliott> mm_freak: does -O2 help?
14:32:43 <mm_freak> i doubt it, let me try
14:32:58 <CodeWeaver> I'm using -O2 on gcc.  I'm using -Odph on Haskell.  Also got RTS options on, unboxing strict fields.
14:33:05 <mm_freak> no, with -O2 the timings are the same
14:33:09 <mm_freak> but i think my version is pretty fast
14:33:09 <CodeWeaver> I could try using just -O2 on Haskell alone.
14:33:17 <mm_freak> CodeWeaver: have you tried my variant?
14:33:18 <rwbarton> CodeWeaver: well, now that I try clang on my system I find that its output on your C program is 6 times as fast as gcc's
14:33:26 <rwbarton> which sounds like the numbers you are getting
14:33:31 <CodeWeaver> Working on it, mm_freak
14:33:44 <mm_freak> CodeWeaver: add -XScopedTypeVariables, if compilation fails
14:33:44 <koeien> rwbarton: that explains :)
14:33:44 <nand`> that's.. quite a difference
14:33:46 <elliott> CodeWeaver: -Odph?
14:33:53 <elliott> -Odph would be pointless here, I think.
14:33:59 <elliott> Use -O2 instead.
14:34:01 <elliott> And which RTS options?
14:34:01 <rwbarton> maybe I should, like, actually read the assembly output
14:34:04 <rwbarton> but eh
14:34:18 <CodeWeaver> I'm just building with RTS options, not using them except to get a timing sample with -sstderr
14:34:38 <elliott> CodeWeaver: I bet that's slowing things down.
14:34:41 <nand`> I wonder how easy GHC output is to do forensics on
14:34:42 <elliott> try building with just -O2 and using time
14:34:45 <CodeWeaver> Okay.
14:35:02 <CodeWeaver> Trying to catch up.  Flailing.  Moment.
14:35:21 <hpaste> “Ertugrul Söylemez” annotated “Fast multiples of given numbers” with “Fast multiples of given numbers (full code)” at http://hpaste.org/56935#a56936
14:35:40 <mm_freak> CodeWeaver: pasted the full code now…  just put in a file and compile
14:35:49 <koeien> mm_freak: however, this code does not allow for O(1) access of the n-th element
14:35:57 <mm_freak> koeien: correct
14:36:08 <mm_freak> koeien: neither does any other =)
14:36:24 <koeien> mm_freak: amortized it does :)
14:36:44 <mm_freak> koeien: remember that you need to generate the list first…  with my version you can easily build an array to get the O(1) access, if you need it
14:36:52 <mm_freak> otherwise i concentrated on pure generation speed
14:36:53 <koeien> mm_freak: yup
14:37:04 <koeien> but that overhead might still be present in other code
14:37:18 <rwbarton> it seems fairest to assume that we actually want the array
14:37:20 <koeien> the comparison is not 100% "fair" anyway
14:37:57 <mm_freak> well, the best you can get is O(f) lookup, where f is the product of the factors
14:37:58 <mm_freak> in this case 30
14:38:08 <koeien> i assume that to be fixed
14:38:10 <kallisti> what are the drawbacks of using Data.Sequence?
14:38:19 <mm_freak> kallisti: in what context?
14:38:23 <kallisti> any
14:38:45 <kallisti> I'm not using it for a specific problem I'm just curious. It seems to have good asymptotic characteristics for many of its operations.
14:39:11 <kallisti> so it seems like it could be useful as a sort of "well-rounded" sequence type, but maybe I don't fully understand the disadvantages?
14:39:17 <rwbarton> is there some handy way to deal with the fact that debian installed the LLVM optimizer at '/usr/bin/opt-2.7' rather than '/usr/bin/opt'?
14:39:22 <mm_freak> kallisti: well, you can't have infinite sequences
14:39:33 <hpc> slower linear accesses
14:39:49 <rwbarton> kallisti: pattern matching is not as convenient
14:39:54 <hpc> so folds won't be as fast
14:40:13 <rwbarton> and also worse time/space (I assume) constants for linear access patterns yes
14:40:23 <hpc> (Sequence Char) requires extra gymnastics to print out
14:40:34 <hpc> though that's more of a case for Text
14:40:56 <rwbarton> Or possibly Sequence Text
14:41:11 <kallisti> wait I thought viewr and viewl were constant time?
14:41:28 <kallisti> oh constants
14:41:32 <rwbarton> sure, they are, but not all constants are equal :)
14:41:36 <kallisti> right
14:41:36 <peddie> rwbarton: try update-alternatives to deal with different package versions like that
14:41:39 <erus`> How many programmer does it take to change a lightbulb? none, its a hardware problem
14:41:50 <hpc> kallisti: and i was talking about foldl/r...
14:41:58 <frerich> mm_freak: Unfortunately your test program is flawed since you tried just one million numbers, not ten million as the C and rwbarton's version.
14:42:06 <frerich> (Just in case nobody pointed it out yet)
14:42:19 <kallisti> is it a significant enough constant factor though?
14:42:29 <kallisti> depends on the problem I suppose.
14:42:47 <CodeWeaver> And we're not talkign ten million elements. We're talking about where the maximum element is ten million.
14:42:54 <CodeWeaver> That's a lot less than ten million numbers.
14:43:00 <CodeWeaver> Its' a little over 7 million.
14:43:07 <koeien> 73333334
14:43:10 <CodeWeaver> Yup
14:43:27 <CodeWeaver> Errr, one less 3.
14:43:30 <CodeWeaver> I think.
14:43:39 <koeien> oh that's possible, that this was the 1e8 version
14:43:59 <CodeWeaver> Brain short circuiting.  realy should just try this in another file.
14:44:04 <CodeWeaver> Moment.
14:46:06 * hackagebot honk 1.1.1.1 - Cross-platform interface to the PC speaker.  http://hackage.haskell.org/package/honk-1.1.1.1 (ChrisWong)
14:48:27 <mm_freak> frerich, CodeWeaver:  with takeWhile (< 10^7) my code needs 643 ms on my machine
14:48:58 <mm_freak> wait, no
14:49:00 <mm_freak> that's not correct
14:49:06 <mm_freak> 250 ms
14:49:56 <rwbarton> when I use clang -O2 and ghc -O2 -fllvm I get back to roughly 1.5x slower Haskell
14:50:25 <rwbarton> I guess on Mac OS your compiler is using llvm
14:50:28 <koeien> rwbarton: as expected
14:50:29 <mm_freak> i don't know the speed of the C version, so i can't compare
14:51:26 <hpaste> mmos1127 pasted “timing” at http://hpaste.org/56937
14:51:29 <rwbarton> what is filter doing given that it can't know how long the result will be?
14:52:30 <elliott> CodeWeaver: The requirement is that the program set up a structure so that the 235ness of any integer between 0 and ten million can be determined in O(1) time thereafter, yes?
14:52:58 <mmos1127> is this a good way to take an action at a specific time?  ("good" means precise, like to 1 ms) http://hpaste.org/56937
14:53:16 <elliott> CodeWeaver: Then my solution is: p :: Int -> Bool; p n = n `rem` 2 == 0 || n `rem` 3 == 0 || n `rem` 5 == 0; main :: IO (); main = return () -- table is already set up
14:53:23 <elliott> CodeWeaver: I think you will find it far exceeds even the C solution's performance.
14:54:07 <mm_freak> elliott: a sieve would be better
14:54:12 <russellw> mmos1127, general-purpose computers do not have that much timing precision no matter what code you write. If you really need down to the millisecond, you will have to use special-purpose hardware or at least a real-time operating system or suchlike
14:54:17 <elliott> mm_freak: Better howso?
14:54:29 <mm_freak> elliott: it gets along with a single mod operation
14:54:30 <rwbarton> what the C program gives is a way to find the ith such number
14:54:45 <elliott> mm_freak: Mine gets by with 0.
14:54:52 <rwbarton> of course you can also solve for this in closed form
14:54:57 <elliott> The accesses of the values are O(1) later, as desired.
14:55:12 <mmos1127> russellw: how about a non-critical application which kinda sorta approximately most of the time does it somewhere around 1ms?
14:55:13 <elliott> rwbarton: That wasn't how CodeWeaver summarised the task.
14:55:24 <mm_freak> elliott: yes, but each check will require three modulos
14:55:29 <mm_freak> with a wheel you only need one
14:55:42 <rwbarton> True, but it is what the C program does.
14:55:43 <elliott> mm_freak: But I don't do any checks. The later accesses aren't part of the benchmark.
14:55:58 <mm_freak> elliott: ah, that's what you mean
14:56:04 <russellw> mmos1127, that depends on how close an approximation is good enough then, I guess :-) try your current solution and see if it gets close enough?
14:56:11 <elliott> rwbarton: None of the Haskell solutions so far work, then; they all use different memory layouts, etc. to the C program.
14:56:18 <elliott> Also, they probably don't free the resulting memory.
14:56:18 <mm_freak> well, in that case yes…  of course a code that doesn't do anything beats any other code in performance =)
14:56:20 <rwbarton> what?
14:56:21 <elliott> So they don't do what the C program does.
14:56:47 <mm_freak> well, i understood the task as to /generate/ a large quantity of those numbers
14:56:54 <mm_freak> my code is optimized to do that
14:56:59 <rwbarton> they give you constant-time access to the ith such number and most likely they do actually use the same memory layout aside from a small constant amount of space
14:57:04 <elliott> mm_freak: Yours does that, but doesn't meet the O(1) access requirement.
14:57:11 <mmos1127> russellw: I should mention the application is real-time generation of midi events. I'm on XP. There are many real-time midi players on XP and the rhythms sound pretty good by ear. There is no special-purpose hardware on my machine, but maybe these apps are using low-level drivers.
14:57:30 <frerich> rwbarton: FWIW, replacing 'mod' with 'rem' in your solution (As suggested by somebody here) brought the runtime of your program from 171ms to 112ms (compiled with GHC 7.0.3 passing just '-O2')
14:57:36 <mm_freak> elliott: it does, but it requires a generation step ahead of that
14:57:42 <elliott> rwbarton: Constant-time - so does mine; same memory layout -- definitely not mm_freak's, and how are you defining "does the same thing" if you can ignore arbitrarily large portions of constant space?
14:57:44 <rwbarton> frerich: Yeah, I'm using rem now.  Always forget about that
14:57:46 <russellw> mmos1127, then if it sounds right, it is right? :)
14:57:51 <rwbarton> uh
14:57:58 <rwbarton> this is another ridiculous discussion, sorry
14:58:02 <rwbarton> I am not getting involved in it
14:58:09 <shachaf> That's the spirit!
14:58:21 <elliott> The ridiculous thing is that this is a benchmark defined in terms of whatever looks sufficiently like a C program.
14:58:27 <mmos1127> russellw: in the case of music, yup :) just wondering though if you have any ideas about where I should poke around. If not, that's fine.
14:59:01 <NothingMan65> Can I do a map which takes a list of Ints and spits out a list of lists?
14:59:07 <rostayob> uh, found out about the London Hoodlums
14:59:09 <koeien> NothingMan65: sure!
14:59:10 <elliott> mmos1127: I suspect they set up some kind of timer.
14:59:15 <rostayob> is anybody going to the Friday one?
14:59:16 <NothingMan65> Howzy?!
14:59:18 <koeien> > map return [1,2,3]
14:59:19 <lambdabot>   No instance for (GHC.Show.Show (m a))
14:59:19 <lambdabot>    arising from a use of `M1330732589...
14:59:24 <elliott> NothingMan65: have your function take an Int and return a list of lists
14:59:25 <koeien> > map (:[]) [1,2,3]
14:59:26 <lambdabot>   [[1],[2],[3]]
14:59:28 <elliott> and give it to map
14:59:36 <mmos1127> elliot: hmm, is there a Haskell library to do that?
14:59:39 <koeien> > map (\x -> [x,x,x+1]) [1,2,3]
14:59:39 <lambdabot>   [[1,1,2],[2,2,3],[3,3,4]]
14:59:43 <mm_freak> i don't see any definition at all…  in any case, i wrote my code before seeing any other code
14:59:51 <elliott> mm_freak: threadDelay
14:59:52 <elliott> erm
14:59:55 <elliott> mmos1127: threadDelay
15:00:08 <NothingMan65> Sick, I just got so much information, my brain exploded again.
15:00:09 <elliott> mm_freak: I don't, either. I'm trying to figure out what definition everyone is pretending is meaningful.
15:00:12 <NothingMan65> Gotta go get the mop.
15:00:14 <NothingMan65> Thanks.
15:00:22 <mm_freak> only CodeWeaver can tell us that
15:00:42 <elliott> That's why I asked CodeWeaver.
15:00:42 <mm_freak> i understood him like he needed to /generate/ these numbers in order
15:00:44 <CodeWeaver> Sorry about that.  Real Life (™) intruded and took over my brain
15:00:54 <elliott> CodeWeaver: <elliott> CodeWeaver: The requirement is that the program set up a structure so that the 235ness of any integer between 0 and ten million can be determined in O(1) time thereafter, yes?  <elliott> CodeWeaver: Then my solution is: p :: Int -> Bool; p n = n `rem` 2 == 0 || n `rem` 3 == 0 || n `rem` 5 == 0; main :: IO (); main = return () -- table is already set up
15:00:54 <Peaker> > let monkeyOperator = (:[]) in map monkeyOperator [1..3]  -- much more readable
15:00:55 <lambdabot>   [[1],[2],[3]]
15:00:56 <elliott> <elliott> CodeWeaver: I think you will find it far exceeds even the C solution's performance.
15:00:58 <elliott> in case you didn't see
15:01:08 <mmos1127> elliott: the issue with threadDelay, as I understand it, is that I can't wake it up at an absolute time, only an approximate delta time. And I don't know what its precision is, so time errors can accumulate
15:01:18 <irene-knapp> @ask edwinb How did your talk go? :)
15:01:18 <lambdabot> Consider it noted.
15:01:19 <CodeWeaver> I didn't.  I have to scroll back because you guys are TOO PROLIFIC :D
15:01:30 <CodeWeaver> Moment.
15:01:35 <mm_freak> CodeWeaver: did you want to /generate/ multiples of 2, 3 and 5 or to /check/ whether a number is a multiple of any of those?
15:01:38 <elliott> mmos1127: You can adjust how long you delay by what kind of error you get in practice.
15:01:46 <elliott> mm_freak: i.e. write an adjustingDelay function that keeps track of the error.
15:01:46 <Peaker> mmos1127: you can remember some arbitrary absolute point in the past -- and always delay relatively to absolute points in relation to that past point
15:02:00 <mmos1127> Peaker: there you go!
15:02:01 <mm_freak> mmos1127: you have an unfortunate nickname =P
15:02:17 <irene-knapp> this is why I don't use a prefix on my nick =p
15:02:29 <Peaker> mmos1127: for example, always delay   (nextTime - curTime), and nextTime += gap   regardless of curTime
15:02:33 <mm_freak> i have one for historical reasons
15:02:37 <mmos1127> Peaker++
15:02:41 <mm_freak> it doesn't even have a meaning =)
15:02:46 <CodeWeaver> I wanted to generate, not just test.  Generating a huge table.
15:02:48 <CodeWeaver> Just ot be clear.
15:03:01 <mm_freak> CodeWeaver: does a list for on-the-fly processing suffice?
15:03:02 <elliott> I just assumed mm_freak was a freak about mm.
15:03:07 <Peaker> mmos1127: to be fair, what elliott said is basically the same :)
15:03:14 <nand`> #haskell - the only place where you spend more time arguing about the problem than the solution
15:03:26 <mmos1127> elliott++ then
15:03:27 <elliott> nand`: *the internet
15:03:30 <CodeWeaver> mm_freak:  as an alternative, I suppose, but then it doesn't really match the benchmark.  I'd love to know your alternative.  Say for getting the ten millionth element.
15:03:34 <elliott> @karma elliott
15:03:34 <lambdabot> You have a karma of 7
15:03:42 <elliott> @karma Peaker
15:03:42 <lambdabot> Peaker has a karma of 1
15:03:42 <CodeWeaver> Or rather for getting all elements in sequence but not storign them
15:03:43 <mmos1127> did it take?
15:03:46 <elliott> Yesss.
15:03:58 <donri> preflex: karma elliott
15:03:59 <preflex>  elliott: 10
15:04:01 <elliott> CodeWeaver: I have an idea for a solution. Give me a few minutes.
15:04:13 <mm_freak> CodeWeaver: yeah, that's exactly my solution…  if you multiply the running type by a linear factor, you also get an array
15:04:24 <mm_freak> type → time
15:04:26 <CodeWeaver> I can't catch up with waht you guys have already done.  Yargh! :D
15:04:28 <mmos1127> I gotta go, thanks guys
15:05:12 <hpaste> “Ertugrul Söylemez” pasted “Fast multiples of given numbers” at http://hpaste.org/56938
15:05:22 <mm_freak> CodeWeaver: my solution, with array generator added
15:05:29 <mm_freak> array = table in this context
15:05:41 <mm_freak> @ hpaste
15:06:14 <CodeWeaver> Okay your original, which did the sum, took 0.150 seconds.  I don't think I'm getting the performance everyone else is.
15:06:22 <mm_freak> of course the array generator is far from optimal, because usually you would generate that array using ST using an inverted sieve of eratosthenes
15:06:55 <CodeWeaver> So I htink its possible that the 'wall' I'm hitting isn't related to my haskell solution.  Something else is holding up the show.
15:07:02 <CodeWeaver> I'm confused.
15:07:17 <CodeWeaver> Oh wait.
15:07:18 <CodeWeaver> I lied.
15:07:24 <CodeWeaver> 0.037s.
15:07:26 <Axman6> hmm, i've never tried pronouncing that before, is it like erra-toss-than-eez?
15:07:27 <CodeWeaver> Punk.
15:07:34 <CodeWeaver> :D
15:07:38 <CodeWeaver> Also WOW
15:08:06 <CodeWeaver> Oh wait, that's one million elements.
15:08:14 <CodeWeaver> Fixing for a maximum value of 10000000 with a takeWhile
15:08:44 <CodeWeaver> Okay, that killed performance.
15:08:47 <rwbarton> so it looks like V.filter knows that the vector it needs to produce is no longer than 10^7 (the length of its input vector), and it just allocates that much memory and then truncates off the extra space
15:09:43 <CodeWeaver> Okay, mm_freak, using your first version, going up to a value of ten million, runs in 0.241s
15:09:49 <CodeWeaver> That's the wheel.
15:09:53 <Axman6> why is the sieve's type to general?
15:10:00 <CodeWeaver> So I don't know why I'm not getting the crazy optimizations you guys are.
15:10:09 <elliott> CodeWeaver: maybe your computer is just slow?
15:10:39 <CodeWeaver> Modern macbook pro.  Also my C benchmark is in the ballpark of these fast numbers.
15:10:42 <CodeWeaver> So, I doubt that.
15:11:04 <CodeWeaver> The difference between the C and haskell versions as a scaling factor is easily about 8-12 times for me, and getting down to nearly par for you guys.
15:11:06 <CodeWeaver> That's weird.
15:11:31 <mm_freak> CodeWeaver: is that good or bad?
15:11:45 <koeien> i'm using ghc 7.0.3
15:11:57 <koeien> did you try -fllvm ?
15:12:06 <CodeWeaver> Well, if you guys are compiling down to haskell being nearly as fast as C, and I'm not by a wide margin, then that's a serious difference, don't you think>
15:12:10 <elliott> What GHC versions are rwbarton and mm_freak using?
15:12:25 <CodeWeaver> I don't appear to be able to use -fllvm… no llvm installed
15:12:38 <mm_freak> CodeWeaver: now i have a table-based solution that generates the numbers up to 10^7 in 67 ms
15:12:41 <mm_freak> is that what you wanted?
15:12:54 * monochrom uses GHC 11.3 and GCC 0.9 to ensure prompt service of GHC compared to GCC :)
15:12:56 <CodeWeaver> Sure, that's great, mm_freak, but I'm not able to get those numbers.  I'd love to be able to.
15:13:17 <CodeWeaver> I'm using your code.
15:13:25 <CodeWeaver> And getting really bad relative performance.
15:13:51 <hpaste> “Ertugrul Söylemez” pasted “Fast multiples of given numbers (table-based)” at http://hpaste.org/56939
15:14:00 <mm_freak> that's the code…  it's very simple
15:14:04 <rwbarton> are you using -fllvm?
15:14:06 <mm_freak> basically just crossing the multiples
15:14:12 * monochrom tries to work out a formula for this, i.e., replace results[i] by a O(1) formula
15:14:15 <mm_freak> you can improve it further
15:14:24 <CodeWeaver> No, I'm not using -fllvm because I don't have llvm installed apparently.
15:14:25 <rwbarton> oh for mm_freak's code, I didn't test that one.
15:14:44 <mm_freak> monochrom: isMul x = wheel ! mod x 30
15:14:50 <mm_freak> that's the O(1) formula
15:14:51 <nand`> you know you spend too much time in ghci when you have to set an alias from :q to exit in your regular shell
15:14:53 <rwbarton> ...
15:15:01 <rwbarton> do people not know what an array is
15:15:05 <monochrom> ah, I forgot that
15:15:07 <rwbarton> (excluding monochrom)
15:15:09 <SirFrancisDrake> is there a way to check memory usage from inside the program, like with ./test +RTS -s?
15:16:24 <mm_freak> actually s/mod/rem/
15:16:37 <elliott> CodeWeaver: fwiw, I suspect the main difference is OS X here
15:16:38 <mm_freak> faster, but might crash your program with the above formula
15:16:38 <rwbarton> the O(1) formula is going to be of the form (some constant)*(x `div` 30) + (some function)(x `mod` 30)
15:16:51 <elliott> at least istr OS X having weird performance problems on microbenchmark type things
15:16:51 <mae> 3rz123
15:16:52 <koeien> chinese remainder theorem
15:16:56 <CodeWeaver> elliot:  That's possible.
15:17:03 <mae> l33t
15:17:15 <CodeWeaver> I'd like to know more concretely.  It seems odd for there to be that much difference.
15:17:38 * elliott is writing a solution that should be faster than mm_freak's
15:17:45 <mm_freak> monochrom: oh, you mean for generating?
15:17:52 <rwbarton> whatever the default mac compiler is uses llvm, and for some reason that is generating about 6x faster code than either gcc or ghc native code gen on your C program/my Haskell program
15:17:53 <mm_freak> monochrom: i gave you the formula for checking
15:18:02 <mm_freak> for generating rwbarton is right
15:18:04 <elliott> nand`: Ctrl+D is shorter
15:18:08 <CodeWeaver> rwbarton:  Okay, so you're recommending I get llvm working?
15:18:14 <elliott> rwbarton: "gcc" is llvm-gcc nowadays?
15:18:22 <elliott> right, I seem to recall that
15:18:23 <elliott> CodeWeaver: no, you do
15:18:25 <rwbarton> on Mac OS I think so, yes
15:18:27 <elliott> if you have OS X Lion and working compilers
15:18:30 <monochrom> A formula backed by a 30-element array is good enough
15:18:32 <elliott> try $ clang from a terminal
15:18:42 <CodeWeaver> okay, but the -llvm switch doesn't work.  So it's implicitly using it by default
15:18:43 <CodeWeaver> >
15:18:43 <rwbarton> or at least newer Mac OS, yeah
15:18:45 <CodeWeaver> ?
15:18:47 <CodeWeaver> Hm.
15:18:57 <nand`> elliott: interesting. :q is more comfortable though, I don't have capslock remapped to ctrl or anything
15:19:08 <monochrom> @quote JS.array
15:19:08 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
15:19:13 <CodeWeaver> rwbarton: But I don't appear to be getting the performance you guys are.
15:19:14 <monochrom> rwbarton: ^^ :)
15:19:18 <rwbarton> perhaps it is doing something like replacing x `mod` 2 == 0 || ... with a test on x `mod` 30 and a bitshift? That would be super smart
15:19:19 <CodeWeaver> rwbarton:  This confuses me.
15:19:24 <rwbarton> :)
15:19:38 <mm_freak> monochrom: well, the program i pasted can be made to start at arbitrary points in the sequence
15:19:44 <koeien> rwbarton: look up the chinese remainder theorem
15:19:47 <koeien> err, CodeWeaver: ^
15:19:54 <monochrom> we all understand monads but we have all forgotten what arrays are!
15:19:55 <elliott> CodeWeaver: -fllvm is not default
15:19:58 <rwbarton> CodeWeaver: I get similar results to you with ghc and no -fllvm.
15:20:18 <CodeWeaver> rwbarton:  how to i enable llvm with haskell?  The -fllvm gives me an error when I try to use it
15:20:28 <mm_freak> monochrom: where you see "sieve' 2 2", just replace by "sieve' (k*n + 2) 2"
15:20:45 <mm_freak> for some variable k
15:20:47 <Peaker> CodeWeaver: what's the error?
15:20:49 <rwbarton> I don't have a Mac (and actually am about to head out) so I can't help you, sorry
15:21:06 <CodeWeaver> Warning: Couldn't figure out LLVM version!
15:21:06 <CodeWeaver> Make sure you have installed LLVM
15:21:06 <CodeWeaver> ghc: could not execute: opt
15:21:20 <mm_freak> that leads to an O(f) formula, where f is the product (30 in this case)
15:21:35 <mm_freak> if you hard-code [2, 3, 5] that becomes an O(1) formula
15:22:36 <elliott> reading core is such a pain
15:23:36 <CodeWeaver> I'll have to figure out if I have to manually install llvm on my Mac or something to take advantage of that.  GHC certainly whines when I try to generate for it.
15:23:56 <Axman6> CodeWeaver: do you have LLVM installed?
15:24:06 <Axman6> hmm, mac, odd
15:24:16 <elliott> CodeWeaver: okay, the C version runs in 0.205s here, and the haskell version I just wrote in in 0.477s
15:24:20 <Axman6> CodeWeaver: make sure you install LLVM 2.9, not 3.0
15:24:26 <CodeWeaver> Why 2.9 over 3?
15:24:32 <elliott> and my computer is slow
15:24:39 <Axman6> because GHC doesn't support 3.0 yet
15:24:43 <elliott> http://sprunge.us/PjJg
15:24:45 <elliott> compile with -O2
15:24:46 <Axman6> well, at least it didn't for me
15:24:53 <mm_freak> where is the C version?
15:25:01 <elliott> oh wait, hpaste is back
15:25:06 <CodeWeaver> Got it.  I'll grab 2.9.  Any docs on how to get it installed for osx?  I'm guessing this means contrary to what I assumed its not automatically part of xcode.
15:25:10 <hpaste> elliott pasted “My solution” at http://hpaste.org/56940
15:25:19 <elliott> CodeWeaver: You *do* have LLVM installed.
15:25:24 <CodeWeaver> I do?
15:25:28 <elliott> It might not be the right version, but you have it if you have Lion.
15:25:29 <Axman6> yes
15:25:31 <CodeWeaver> Okay, but ghc isn't taking the -llvm option.
15:25:32 <elliott> Are you on Xcode 4?
15:25:33 <nand`> >unsafeFreezeByteArray do I even want to know what this function does
15:25:35 <elliott> CodeWeaver: it's -fllvm
15:25:38 <elliott> not -llvm, but yes
15:25:38 <Axman6> you do have Xcode install right?
15:25:38 <CodeWeaver> Yes, xcode 4.something.
15:25:41 <CodeWeaver> Yes.
15:25:44 <elliott> CodeWeaver: you might want to try xcode 3.2
15:25:54 <CodeWeaver> Heyyy look at this
15:25:54 <CodeWeaver> gcc --version
15:25:54 <CodeWeaver> i686-apple-darwin11-llvm-gcc-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.1.00)
15:25:54 <CodeWeaver> Copyright (C) 2007 Free Software Foundation, Inc.
15:25:54 <CodeWeaver> This is free software; see the source for copying conditions.  There is NO
15:25:54 <CodeWeaver> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
15:26:06 <koeien> please don't do this
15:26:12 <elliott> CodeWeaver: don't paste
15:26:14 <mm_freak> elliott: your code seems to have a bug
15:26:27 <CodeWeaver> Sorry
15:26:29 <mm_freak> you have two times 2 and one time 5
15:26:30 <CodeWeaver> Apologies.
15:26:54 <elliott> CodeWeaver: anyway, ghc depends on xcode 3.2, and downgrading to 3.2 solved a "can't find opt" problem for someone else: http://stackoverflow.com/questions/8864696/installing-dph-examples-in-mac-os-x-10-7-2
15:27:00 <elliott> mm_freak: oops
15:27:08 <nand`> I wonder how much that changes performance
15:27:20 <mm_freak> elliott: also note that bit-level access is usually faster than byte-level access
15:27:23 <elliott> ok, mine now runs in 0.596!
15:27:29 <mm_freak> so UArray should outperform your code
15:27:29 <nand`> wouldn't GHC see that you have (remInt# n 2#) ==# 0# twice in there
15:27:30 <elliott> mm_freak: i'm doing word-level access
15:27:47 <hpaste> elliott pasted “My fixed solution” at http://hpaste.org/56941
15:27:52 <elliott> CodeWeaver: try that with -O2
15:28:00 <CodeWeaver> Hmmmmm, good call on the 3.d
15:28:01 <CodeWeaver> 3.2
15:28:07 <CodeWeaver> This could be the problem.
15:28:18 <mm_freak> elliott: how does it compare to my new array-based solution on your machine?
15:28:25 <mm_freak> http://hpaste.org/56939
15:28:29 <mm_freak> it's done in 60 ms
15:28:30 <elliott> mm_freak: what main should I use?
15:28:33 <mm_freak> on my machine
15:28:40 <mm_freak> main :: IO ()
15:28:40 <mm_freak> main = sieveArray 100000000 [2 :: Int, 3, 5] `seq` return ()
15:28:49 <CodeWeaver> Okay, despite my fight with not having llvm and getting bad performance numbers, you guys are awesome for taking up my little puzzle here.
15:29:08 <elliott> mm_freak: mine runs in 0.596s, yours in 1.232s
15:29:10 <elliott> tested over 3 runs of both
15:29:14 <koeien> the best way to get help is saying "X is better than haskell."
15:29:14 <elliott> CodeWeaver: i wanna know how fast mine is!! :P
15:29:28 <CodeWeaver> elliott:  It will be crap until I get llvm sorted!
15:29:28 <mm_freak> i see
15:29:34 <CodeWeaver> I can still do it if you like. :D
15:30:23 <elliott> CodeWeaver: llvm is irrelevant
15:30:31 <elliott> i very much doubt it'll speed mine up significantly.
15:30:38 <elliott> also, -fllvm does not always improve speed
15:30:59 <elliott> mm_freak: my machine is really slow btw (1.33ghz dual core)
15:30:59 <elliott> the difference is probably less on real hardware
15:31:22 <CodeWeaver> elliott: 0.191s …. so the wall I'm hitting is not code related.
15:31:34 <CodeWeaver> Everyone, let me get llvm sorted out if I can.
15:31:41 <CodeWeaver> Then I'll re-test your favourites.
15:31:46 * elliott thinks ghc's os x support might be the problem, not llvm
15:31:46 <elliott> because i am not using llvm
15:31:49 <elliott> at all
15:31:53 <CodeWeaver> Possibly.
15:31:56 <elliott> and your C version runs in 0.204s here
15:31:56 <quinn> I'm having difficulty understanding how this code results in (Num a) => a -> [Bool].:  sequence [(>4),odd].  I get how, for 'odd' it can translate to 'fmap (:) odd <*> pure []
15:32:05 <quinn>  but I'm not sure how the rest chains together.
15:32:11 <quinn> can someone demystify it for me?
15:32:14 <elliott> CodeWeaver: mine is still slower than the C, mind you
15:32:19 <elliott> but only 2x
15:32:20 <CodeWeaver> My C version runs in 0.041 here.
15:32:20 <elliott> or so
15:32:34 <elliott> mine is pretty much as fast as is possible
15:32:40 <hpaste> ClaudiusMaximus pasted “2,3,5 GPU implementation” at http://hpaste.org/56942
15:32:43 <CodeWeaver> So the problem isn't absolute speed…. it's the difference between the C and haskell versions y scale.
15:32:47 <elliott> it only does one allocation, and goes into a tight loop with unboxed integers after that
15:32:49 <elliott> ClaudiusMaximus: LOL
15:32:55 <ClaudiusMaximus> i was bored...
15:32:56 <koeien> ClaudiusMaximus: lol.
15:32:58 <koeien> nice work
15:33:07 <elliott> ClaudiusMaximus: now rewrite it with http://hackage.haskell.org/package/OpenCL and Haskell wins
15:33:34 <nand`> oh shit, haskell has an OpenCL package
15:33:39 <elliott> it has at least three
15:33:41 <cmccann> of course it does
15:33:45 <elliott> but that's the most popular one
15:33:52 <elliott> probably because it's called OpenCL :)
15:33:53 <nand`> cmccann: It's more like I forgot OpenCL existed
15:34:51 <cmccann> though I don't think ClaudiusMaximus was using OpenCL stuff?
15:35:03 <nand`> how ugly is its API on a scale from 1 to OpenGL?
15:35:16 <elliott> nand`: OpenCL's API is worse than OpenGL. The Haskell binding has some nice wrappers, though.
15:35:29 <elliott> And it uses exceptions (thanks to me :P) rather than hideous error codes, so it's a lot less boilerplatey.
15:35:39 <cmccann> how's it worse than OpenGL?
15:35:42 <nand`> well, I'm concerned about turning my entire program into a huge IO monad inside a do block
15:35:58 <elliott> cmccann: well, opengl has glut :P
15:35:59 <nand`> but I guess when dealing with GPUs that's unavoidable at a certain level
15:36:05 * cmccann hates glut
15:36:11 <elliott> yeah, but it's simple!cmccann: basically the initialisation with opencl takes about 10 calls of
15:36:12 <elliott> argh
15:36:16 <elliott> cmccann: basically the initialisation with opencl takes about 10 calls of 10 parameters each
15:36:20 <elliott> and each one of them returns an error code
15:36:26 <cmccann> yay!
15:36:33 <elliott> cmccann: and there's no standard error code -> string function!
15:36:37 <elliott> that's in the vendor-specific toolkits
15:36:40 <elliott> so is all the documentation
15:36:50 <elliott> oh, and some take a pointer to the error code I think
15:36:54 <elliott> rather than returning it
15:36:56 <cmccann> whereas opengl initialization takes a whole bunch of random functions that might do something and returns "a black screen" as an error code
15:37:17 <elliott> cmccann: oh, and then you get to compiling a kernel, which runs a C compiler in your code(!)
15:37:26 <elliott> and again takes ten functions
15:37:31 <elliott> and don't get me started on queueing up the memory stuff...
15:37:34 <mm_freak> elliott: wait a minute
15:37:36 <cmccann> opengl compiles programs now, too
15:37:37 <elliott> it took me upwards of an hour to write a single "find an OpenCL device, run a trivial kernel on it, and print the results" program
15:37:38 <mm_freak> my code is faster than yours
15:37:42 <elliott> mm_freak: not for me
15:37:52 <mm_freak> elliott: remove a zero from 100000000 =)
15:37:52 <elliott> mm_freak: OS, CPU, GHC version + flags?
15:37:58 <elliott> oh
15:38:01 <elliott> hmph
15:38:18 <elliott> why the heck is it faster
15:38:29 <mm_freak> because i use bit-level access, whereas you use word-level access
15:38:42 <elliott> that's slower on all modern CPUs, isn't it?!
15:38:45 <elliott> otherwise everyone would pack their structures
15:38:54 <mm_freak> i thought that, before i tried it out in C
15:39:08 <nand`> >data CLError
15:39:17 <nand`> >see those possible values
15:39:18 <nand`> yeah, no
15:39:23 <elliott> nand`: that's an exception
15:39:26 <elliott> you can just not handle them
15:39:33 <elliott> and they'll get printed out
15:40:35 <nand`> does it only strike me as odd that they aren't split up into multiple error types
15:40:46 <nand`> like say CLInitError or CLCompileError
15:41:02 <elliott> nand`: IOError is one type too
15:41:14 <elliott> also, that would be 5x the work for the binding-writer, and save... one line of code for everyone else
15:41:20 <elliott> (that line being handle e = throwIO e at the end of exception handlers)
15:42:35 <CodeWeaver> *downloaddownloaddownloaddownload*
15:42:49 <mm_freak> elliott: UArray Int Bool and STUArray s Int Bool are the fastest bit vectors you can get in haskell, and they well approach C performance with the right code
15:43:12 <elliott> mm_freak: I'm sure they wouldn't be faster if I inlined their primops into my program :)
15:43:31 <elliott> CodeWeaver: you will need to _uninstall_ xcode 4 first btw
15:43:37 <elliott> i don't think the installer will be able to downgrade for you
15:43:59 <CodeWeaver> Apparently I can have multiple versions at once.
15:44:02 <CodeWeaver> http://iphonedevelopertips.com/xcode/download-and-install-older-versions-of-xcode-xcode-previous-releases.html
15:44:03 <mm_freak> elliott: if you bring both to an optimal level, the bit-level variant will still be faster…  you can try it in C to see for yourself
15:44:17 <elliott> mm_freak: I meant I'd inline the bitvector code into my program:P
15:44:18 <elliott>  
15:44:20 <elliott> oops
15:44:25 <elliott> s/program:P\n /program :P/
15:44:38 <elliott> CodeWeaver: you would have to tell ghc about the other version
15:44:41 <mm_freak> i noticed this when writing an optimized sieve of eratosthenes in C
15:44:43 <elliott> might even require recompiling ghc
15:44:55 <CodeWeaver> elliott: Hm.
15:44:59 <mm_freak> one word for every number took longer to complete than one bit for every number
15:45:07 <mm_freak> it probably has to do with caches
15:45:28 <mm_freak> because then you can complete a word while it's in the cache
15:46:51 <mm_freak> which leads me to an idea for yet another improvement
15:48:00 <CodeWeaver> You guys scare me. :D
15:58:56 <mm_freak> ok, didn't work =)
15:59:10 <mm_freak> you're safe…  my code won't get any faster =P
15:59:14 <mm_freak> except perhaps…
15:59:17 <elliott> :'(
15:59:20 <elliott> I'm scared.
15:59:32 <elliott> Why the heck doesn't GHC support inline assembly yet, anyway.
16:00:26 <taotree> is there a tool that will automatically create a visualization (class diagram sort of thing) of a haskell data model from source code?
16:00:37 <mm_freak> hah…  50 ms
16:00:48 <elliott> nooooooooooooooooooooooooooooooo
16:00:52 <mm_freak> another 10 ms save =)
16:00:52 <elliott> or is that slower
16:01:03 <mm_freak> faster…  went from 60 ms to 50 ms
16:01:03 <elliott> oh no :(
16:01:36 <ClaudiusMaximus> original c version takes 60ms here, my c/glsl version takes 160ms :(
16:02:35 <elliott> probably setup cost
16:02:37 <elliott> add a few 0s
16:03:40 <ddarius> @hackage harpy
16:03:41 <lambdabot> http://hackage.haskell.org/package/harpy
16:03:50 <elliott> ddarius: that's not compile-time :)
16:04:00 <ddarius> elliott: With TH it can be!
16:04:54 <elliott> ddarius: Well, you'll still have to copy the bytes somewhere to call 'em/
16:04:56 <elliott> .
16:05:27 <CodeWeaver> mm_freak, keep posting those examples… I'll be testing 'em. :D
16:05:34 <CodeWeaver> And most of all, learning.
16:06:58 <nyingen> ls
16:08:28 <elliott> CodeWeaver: p :: Int -> Bool; p = arrayRange (0, 10000000) (\n -> n `rem` 2 == 0 || n `rem` 3 == 0 || n `rem` 5 == 0); main = return ()
16:08:42 <elliott> CodeWeaver: there's a table to hold the values from 0 to 10000000 and access is O(1) through the table
16:09:01 <elliott> and it runs faster than the C no matter how you compile it
16:09:42 <mike-burns> :t arrayRange
16:09:43 <lambdabot> Not in scope: `arrayRange'
16:09:51 <elliott> mike-burns: http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html
16:09:54 <hpaste> “Ertugrul Söylemez” pasted “Fast nonredundant multiples of 2, 3 and 5” at http://hpaste.org/56944
16:10:01 <mm_freak> CodeWeaver: this is my final variant
16:10:08 <mm_freak> takes 50 ms on my platform
16:12:19 <mm_freak> and i'd say that's the speed limit for STUArray-based solutions
16:12:51 <elliott> mm_freak: haha, that is cheating in the highest
16:13:07 <mm_freak> elliott: the solution is correct…  i verified it =)
16:13:18 <elliott> ok gimme a sec i have a new solution
16:14:24 <mm_freak> that's a long sec =P
16:14:31 <derpladee> can a type implement a class?
16:14:37 <elliott> mm_freak: p.s... yours doesn't set the value in the table
16:14:40 <elliott> which the C program _does_
16:14:40 <derpladee> or does it have to be a datatype if i want to implement classes?
16:14:56 <elliott> derpladee: data or newtype
16:14:56 <mm_freak> elliott: why should it?
16:14:59 <mike-burns> derpladee: newtype or data can.
16:15:07 <elliott> you can implement a typeclass for a type, but it'll apply to the wrapped type too
16:15:10 <mm_freak> derpladee: you write instances of type classes
16:15:10 <elliott> and you can't do it if there's already one
16:15:13 <elliott> mm_freak: because the C program does
16:15:23 <elliott> it lets you get the n-th such number in O(1)
16:15:39 <mm_freak> elliott: that's redundant
16:15:46 <mm_freak> elliott: ah
16:15:49 <mm_freak> that's what you mean
16:17:28 <mm_freak> elliott: does your variant do that?
16:17:56 <elliott> mm_freak: yes
16:18:25 <Saizan> for the purpouse of typeclasses, and everything else really, definitions made with "type" are transparent
16:21:13 <mm_freak> elliott: 200 ms
16:21:36 <elliott> ok, i have a new solution
16:21:54 <elliott> not a cheat in any way
16:22:01 <elliott> there's a table, it initialises it at runtime, fully
16:22:03 <JoeyA> How can I test an old version of a package in GHCi?
16:22:25 <hpc> JoeyA: package imports are a GHC extension
16:22:26 <JoeyA> Ah, ghci -package attoparsec-0.9.1.2
16:22:30 <hpc> or that
16:22:42 <JoeyA> I tried a package import, and I got a hidden-package message.
16:22:45 <JoeyA> This works.
16:22:47 <hpc> import Foo.Bar "foo-bar 1.1.1.1" -- iirc
16:22:53 <hpc> yay
16:23:44 <hpaste> elliott pasted “My solution (gzip | uuencoded)” at http://hpaste.org/56946
16:24:03 <elliott> mm_freak: try that one (compared to your Bool version)
16:24:09 <monochrom> wait, why are you gzipping and uuencoded it?
16:24:42 <elliott> monochrom: I don't think hpaste would accept it if I didn't.
16:24:54 <monochrom> also, it looks to have much repetition and can be compressed further
16:25:14 <elliott> uuencode introduces much repetition :P
16:25:16 <monochrom> perhaps you should gzip | uuencode | gzip | uuencode
16:25:37 <elliott> ahaha... it takes 0.715 seconds here
16:25:41 <elliott> how is it slower than mm_freak's?!
16:25:49 <mm_freak> lol
16:26:06 * hackagebot twitter-enumerator 0.0.2 - Twitter API package with enumerator interface and Streaming API support.  http://hackage.haskell.org/package/twitter-enumerator-0.0.2 (TakahiroHimura)
16:26:08 * hackagebot http-proxy 0.0.6 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.6 (ErikDeCastroLopo)
16:26:14 <elliott> ok, but you could easily store it in space/* form and convert on lookup, that's a very tiny constant
16:26:17 <elliott> and use # suffix to get an Addr#
16:26:20 <elliott> thus making initialisation a nop
16:26:22 <elliott> so my point stands
16:27:14 <mm_freak> i don't have uuencode
16:27:29 <mm_freak> what is it?  did you just generate a ready-made list in source code?
16:27:42 <elliott> yeah
16:27:44 <elliott> with your program :P
16:27:52 <elliott> i turned it into " * * * * *   ** * ***** " form to save bytes
16:27:52 <mm_freak> i can see why it's slower then =)
16:27:56 <elliott> but i guess the array . map . zip slows it down
16:28:06 <elliott> however, put a # suffix on the string and it becomes flat memory
16:28:11 <elliott> and you can skip the array altogether
16:28:15 <mm_freak> on the fly construction is going to be faster than loading the data section of your program
16:28:25 <elliott> hmph
16:28:31 <elliott> we should benchmark in a way that avoids OS time like that
16:28:57 <mm_freak> it's not OS time actually…  it's really the construction from constant values
16:29:32 <mm_freak> constant values in the data section are slower than both constant values in registers and variable values in registers
16:29:56 <monochrom> ha, uuencode is in sharutils in ubuntu
16:31:14 <elliott> mm_freak: yeah, but reading from the data section should be omitted :)
16:33:31 <CodeWeaver> brb
16:34:14 <mm_freak> elliott: you'll hate me for this
16:34:22 <mm_freak> my array version now runs in 20 ms =)
16:34:27 <mm_freak> the bool version i mean
16:35:15 <elliott> mm_freak: :'(
16:35:56 <mm_freak> but wait…  it's not correct yet
16:36:09 <monochrom> mm_freak: http://www.vex.net/~trebla/tmp/foo.hs.gz has elliott's file, gzip but no uuencode
16:36:37 <monochrom> and "My God, it's full of STARS"
16:37:43 <elliott> haha
16:38:28 <CodeWeaver> Okay so turns out its easier to just uninstall xcode 4 and go back to 3.2.x for my experiments. :)
16:38:39 <CodeWeaver> dual-compiler-ing is just too headachey
16:39:55 <mm_freak> elliott: ok, you're safe for now…  castSTUArray didn't work as expected =)
16:40:00 <mm_freak> back to 50 ms
16:40:12 <elliott> yesss
16:40:16 <elliott> mm_freak: what were you trying?
16:41:07 * hackagebot yjtools 0.9.9 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.9 (YoshikuniJujo)
16:41:18 <monochrom> elliott: cat foo.hs | gzip | uuencode foo.hs.gz | gzip | uuencode foo.hs.gz.u.gz > ggg  leads to just 15 lines :)
16:41:24 <elliott> monochrom: haha
16:41:30 <elliott> monochrom: do it a few more times and it'll be 0 bytes
16:41:57 <monochrom> haha, naw, I see those 15 lines and they're pretty optimized already
16:42:47 <mm_freak> elliott: i tried to write the [2, 4 …] bits wordwise
16:43:06 <elliott> mm_freak: haha
16:43:11 <mm_freak> because i just discovered the castSTUArray function
16:43:16 <mm_freak> but as said, it didn't work
16:43:22 <monochrom> actually just gzipping twice is already a big improvment. cat foo.hs | gzip | gzip | uuencode foo.hs.gz.gz > ggg  is just 11 lines
16:43:42 <elliott> i'm disappointed in gzip
16:43:49 <elliott> maybe it only finds like the "local" patterns
16:43:59 <elliott> and ends up turning the global patterns into local patterns
16:44:02 <elliott> that the next gzip picks up on
16:44:03 <monochrom> yeah, I think so
16:44:18 <monochrom> "we put a pattern in your pattern so you can compress while you compress"
16:44:43 <c_wraith> fractals!
16:44:51 <CodeWeaver> That'll only work so much before you start making your file bigger again. ;)
16:44:57 <c_wraith> (if the pattern keeps repeating after every level of compression)
16:46:07 * hackagebot hake 1.3.5 - make tool. ruby : rake = haskell : hake  http://hackage.haskell.org/package/hake-1.3.5 (YoshikuniJujo)
16:46:14 <monochrom> typically, a fractal is compressible down to a 1-line formula, yes
16:46:15 * hpc designs a new archive format that is an integer header, followed by gzip^n(content)
16:46:20 <mm_freak> elliott: with a Ptr-based solution i think i could easily bring it down by another 30 ms, because i can replace the [2, 4 .. n] part by a simple memset operation
16:46:20 <elliott> CodeWeaver: the pidgeonhole theorem is for pigeons
16:46:23 <hpc> patent-pending :P
16:46:36 <elliott> mm_freak: Ptr? Addr#, man.
16:46:37 <mm_freak> but honestly i lost interest in the project =P
16:46:47 <mm_freak> elliott: never worked with primitives
16:47:02 <elliott> ooh, lucky you! you get to learn something :D
16:47:20 <mm_freak> dunno…  i never ran inter such performance issues that i would need to go that low level
16:47:35 <CodeWeaver> elliot wins. :D
16:47:44 <mm_freak> and as you've seen, my regular UArray solution beat the hell out of your primitive solution =P
16:48:36 <elliott> I do?
16:48:37 <elliott> mm_freak's is faster.
16:48:53 <elliott> mm_freak: i just wasn't primitive enough
16:49:00 <mm_freak> =)
16:49:04 * elliott writes hand-crafted machine code to an array, jumps there
16:49:20 <CodeWeaver> No I mean mentioning the pigeonhole principle.
16:49:29 <CodeWeaver> hahahahah
17:02:13 <eyebloom> What is the best way to create graphics in a Haskell program?
17:02:38 <monochrom> the "diagram" package
17:03:06 <eyebloom> How does it actually render?
17:04:21 <elliott> eyebloom: What do you mean by graphics?
17:05:22 <eyebloom> I'm interested in writing a node editor that allows boxes to be connected by edges or noodles as they are sometimes called.
17:06:40 <eyebloom> So, I'd be interested in good support for animation, interaction and shapes defined by vectors.
17:09:06 <mgsloan> eyebloom: this is my own project, but http://hackage.haskell.org/package/gtk-toy-0.2.0 is a good way to play around with stuff
17:10:28 <eyebloom_> I'm just curious what the most mature project is, or if there are good binding to OpenGL.
17:10:28 <mgsloan> eyebloom_: http://hackage.haskell.org/package/gtk-toy-0.2.0 is something I put up recently
17:10:48 <mgsloan> it's a quick easy way to get a Gtk canvas and have mouse / keyboard
17:10:52 <elliott> eyebloom_: http://hackage.haskell.org/package/gloss
17:10:59 <mgsloan> yeah, that's the one to go for
17:11:10 <elliott> oh, hmm
17:11:13 <elliott> might not do mouse movement
17:11:17 <elliott> eyebloom_: anyway, there's a good binding to opengl
17:11:22 <elliott> but it exposes the full might and power of opengl
17:11:26 <elliott> so it's ugly, like OpenGL :)
17:11:42 <elliott> eyebloom_: But wx or gtk are probably your best bets for something like that.
17:12:01 <Sgeo> elliott, do you get @tells?
17:12:37 <elliott> Unfortunately.
17:13:43 <CodeWeaver> *installinstallinstall*
17:13:51 <eyebloom> Unfortunately I'm fairly anti-Gtk. I just don't think it's designed well and it renders porly on systems like MacOs
17:14:16 <eyebloom> Qt would be a better option in my humble oppinion.
17:14:21 <mgsloan> even if you use no GTK widgets?
17:14:37 <cmccann> elliott: You have ⊥ new messages.
17:14:47 <elliott> eyebloom: Haskell's Qt support isn't so good.
17:14:51 <elliott> The wxWidgets support is excellent, though.
17:14:59 <elliott> But yeah, you'd only have to use the canvas widget.
17:15:01 <eyebloom> mgsloan: yes the issue is the object model in Gtk.
17:15:19 <CodeWeaver> Hey, no crashing the elliot with bottoms. :P
17:15:21 <elliott> Well, don't worry about that; every GUI toolkit is approximately equally un-Haskelly.
17:15:30 <elliott> CodeWeaver: btw, two "t"s :P
17:15:35 <eyebloom> Not trying to start a flame war, I have a long history with GTK
17:15:36 <CodeWeaver> Notted.
17:16:00 <elliott> Xored!
17:16:12 <mgsloan> yeah, I'm not going to claim that any UI toolkit is designed well :D it's hard
17:16:16 <CodeWeaver> *snort* *hack* hahahaha
17:17:06 <elliott> It wasn't *that* funny!
17:17:20 <yottabit> nubBy :: (a -> a -> Bool) -> [a] -> [a]
17:17:24 <yottabit> will someone explain this to me?
17:17:37 <eyebloom> In any case thanks for the suggestions
17:17:37 <elliott> eyebloom: you might also be interested in http://hackage.haskell.org/package/graphics-drawingcombinators
17:17:42 <yottabit> example usage...
17:17:44 <elliott> yottabit: it's like nub but uses the function instead of (==)
17:17:45 <yottabit> that's about all i need
17:18:12 * cmccann likes drawingcombinators but it's pretty limited
17:18:23 <Sgeo> > nubBy ((==) `on` fst) [(1,"Hi"), (1, "Bye"), (2, "Hi)]
17:18:25 <lambdabot>   <no location info>:
17:18:25 <lambdabot>      lexical error in string/character literal at end o...
17:18:28 <Sgeo> > nubBy ((==) `on` fst) [(1,"Hi"), (1, "Bye"), (2, "Hi")]
17:18:29 <lambdabot>   [(1,"Hi"),(2,"Hi")]
17:18:48 <Sgeo> Same thing without on:
17:19:00 <eyebloom> elliott: Thanks, no mouse interaction there though. It seems
17:19:02 <Sgeo> > nubBy (\a b -> fst a == fst b) [(1,"Hi"), (1, "Bye"), (2, "Hi")]
17:19:03 <lambdabot>   [(1,"Hi"),(2,"Hi")]
17:19:16 <Sgeo> yottabit, ^^
17:19:54 <elliott> eyebloom: "drawing"combinators :) it doesn't handle input
17:20:01 <elliott> but it abstracts away all the mess of drawing with opengl
17:20:13 <elliott> so you can just use your favourite windowing library (sdl, glfw, etc.) for input
17:23:19 <eyebloom_> I see.
17:23:25 <eyebloom> Sounds messy.
17:24:08 <elliott> eyebloom: Well, it's usually just "set up a key/mouse callback, set up drawingcombinators as the render callback, enter the main loop".
17:24:11 <elliott> At least it's that simple with GLFW-b.
17:24:25 <yottabit> Sgeo: in your example, why did it not return (1, "Bye")?
17:25:18 * Cale grumbles. GHC is inferring types for things at toplevel which only universally quantify some of the involved type variables when all of them should be.
17:25:24 <elliott> yottabit: Do you know what nub does?
17:25:29 <Sgeo> yottabit, because with nubBy, it doesn't use the normal == to see whether two values are equal. It uses the function I defined. And the function I defined says that two things are equal if their first values are equal
17:25:30 <elliott> nub reduces a list to its non-equal elements.
17:25:34 <elliott> i.e. duplicates are removed.
17:25:40 <dolio> GHC doesn't explicitly quantify any prenex variables.
17:25:47 <dolio> When it prints types.
17:25:50 <yottabit> elliott: i do not
17:25:55 <elliott> yottabit: Well, start there :)
17:25:57 <elliott> > nub "abcabc"
17:25:58 <lambdabot>   "abc"
17:26:00 <elliott> > nub "abccba"
17:26:01 <lambdabot>   "abc"
17:26:05 <elliott> > nub "Hello, world!"
17:26:06 <lambdabot>   "Helo, wrd!"
17:26:14 <elliott> (nubBy f) is just like nub, but uses f as the equality relation rather than (==).
17:26:37 <yottabit> nub "Hello, world!"
17:26:41 <yottabit> > nub "Hello, world!"
17:26:42 <lambdabot>   "Helo, wrd!"
17:26:46 <yottabit> that makes no sense to me
17:26:56 <Cale> dolio: Well, giving type signatures with explicit foralls with *all* the variables is fixing type errors...
17:26:57 <yottabit> it removes duplicates?
17:26:58 <Sgeo> yottabit, the second l is a duplicate, so it gets dropped
17:27:00 <Sgeo> Yes
17:27:08 <yottabit> nub == remove dups
17:27:19 <yottabit> True
17:27:28 <Cale> I'm not sure I understand what a prenex variable is though.
17:27:31 <dolio> I should say, it used to.
17:27:31 <ClaudiusMaximus> @check \xs -> let f = (==) `on` fst in (reverse . nubBy f . reverse) xs == nubBy f (xs :: [(Bool, Bool)])
17:27:33 <lambdabot>   "Falsifiable, after 6 tests:\n[(False,False),(True,False),(True,False),(Fal...
17:27:48 <startling> > nubBy (==) "hello, world!"
17:27:48 <lambdabot>   "helo, wrd!"
17:27:48 <dolio> But it doesn't anymore, as of some time in the 7 series (possibly 7.0).
17:28:01 <hpc> @src nub
17:28:01 <lambdabot> nub = nubBy (==)
17:28:10 <yottabit> i don't quite understand its type signature: nub :: Eq a => [a] -> [a]
17:28:20 <startling> > nubBy (/=) "hello, world!"
17:28:21 <lambdabot>   "h"
17:28:32 <Sgeo> yottabit, that means, if a is something that you can use == on, nub is a function from a list of a that gives a list of a.\
17:28:35 <yottabit> "it's of the type equality that takes a list and returns a list", correct?
17:28:36 <startling> yottabit: it takes a list of `a` and returns a list of `a`.
17:28:44 <CodeWeaver> I have -fllvm not giving me an error finally.
17:28:46 <yottabit> equaity type*
17:28:47 <CodeWeaver> So let's see if we get anywhere.
17:29:07 <hpc> to expand on what Sgeo said, if 'a' is an instance of Eq, ...
17:29:17 <yottabit> someone once showed me how to read, this: (a -> a -> Bool)
17:29:29 <yottabit> (a -> a -> Bool) -> [a] -> [a] rather
17:29:30 <elliott> > nubBy (\a b -> toLower a == toLower b) "HELLO hello"
17:29:32 <lambdabot>   "HELO "
17:29:34 <hpc> yottabit: it's a function that takes two things and yields a Bool
17:29:51 <yottabit> okay, i can see that
17:29:52 <elliott> yottabit: a function that takes (a function that takes two as and returns a Bool) and a list of as and returns a new list of as
17:29:53 <hpc> so nubBy takes one of those functions and a list, then yields a list
17:30:00 <dolio> Cale: They're the variables that are quantified in the outermost forall.
17:30:06 <yottabit> but then it yields a list [a] which then yields another list [a]?
17:30:13 <Cale> dolio: okay
17:30:29 <startling> > nubBy (>) [4, 3, 2, 1]
17:30:29 <elliott> yottabit: no, it's
17:30:29 <lambdabot>   [4,3,2,1]
17:30:34 <elliott> (a -> a -> Bool) -> ([a] -> [a])
17:30:37 <startling> > nubBy (>) [1, 2, 3, 4]
17:30:38 <lambdabot>   [1]
17:30:50 <Cale> dolio: well, there are some variables which should be like that, but it's introducing new rigid, skolem type variables and not generalising them, which is leading to type errors elsewhere
17:30:54 <startling> that's really cool, it's almost a fold.
17:30:59 <Sgeo> a -> b -> c is a function that takes an a and yields (a function that takes a b and yields c)]
17:31:05 <Cale> This is in top-level definitions
17:31:14 <Sgeo> erm, using a was a bad idea
17:31:24 <Cale> I can't really explain it, and the source file this is happening in is a few thousand lines...
17:31:27 <hpc> @src nubBy
17:31:27 <lambdabot> nubBy eq []             =  []
17:31:28 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:31:29 <yottabit> it's a function that takes two values which yield a bool value and then er.....
17:31:35 <Sgeo> alpha -> beta -> gamma is a function that takes an alpha and yields (a function that takes a beta and yields a gamma)]
17:31:38 <dolio> I don't really understand how the way it prints types is causing type errors.
17:31:39 <hpc> startling: it in fact is a fold
17:31:46 <dolio> Unless you're copying them into the source.
17:31:48 <Cale> dolio: this isn't about how it prints types
17:31:59 <Cale> this is about the actual types it's inferring
17:32:02 <parcs`> @src nubBy
17:32:03 <lambdabot> nubBy eq []             =  []
17:32:03 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:32:07 <Cale> I have  getEventValues :: forall bi ei bo eo x. RAM bi ei bo eo (GM x) (HashMap (SomeSourcePtr E (GM x)) (Maybe Any))
17:32:16 <hpc> nubBy eq = foldr (\x xs -> stuff) []
17:32:19 <dolio> Oh, well, that's changed, too, I suppose.
17:32:21 <Cale> but without an explicit type signature, the inferred type which appears in the error message is:
17:32:26 <Cale> getEventValues :: forall bi ei bo eo. RAM bi ei bo eo (GM x) (HashMap (SomeSourcePtr E (GM x)) (Maybe Any))
17:32:36 <startling> oh, so it always compares to the first element.
17:32:37 <Cale> Well, x1 occurs instead of x
17:32:43 <Cale> and that x1 won't unify with things
17:32:52 <Cale> because it's not generalised
17:33:11 <startling> > nubBy (<) [1, 5, 7, 4, 2, 9]
17:33:11 <lambdabot>   [1,5,7,9]
17:33:35 <Cale> Adding explicit type signatures fixes the associated type errors
17:33:47 <elliott> startling: bad example
17:33:47 <monochrom> I don't think you should rely on nubBy implementation details for non-equivalence relations
17:33:50 <Cale> but this is rather weird
17:33:52 <startling> oh, guess it doesn't always compare to the first, I misread that.
17:33:53 <elliott> (<) isn't equality-enough for nub to behave properly on it
17:34:14 <Cale> I think we *should* be able to rely on nubBy's semantics for non-equivalence relations
17:34:30 <dolio> Cale: Signatures inside the expression, or just a signature declaration for getEventValues?
17:34:31 <monochrom> but until full non-determinacy is implemented, I guess I can't stop you
17:34:49 <Cale> dolio: A top level type declaration for getEventValues
17:34:53 <startling> Cale: couldn't that be easily done with `foldr` or `foldl`, though?
17:35:03 <yottabit> aha, i think it was cale who explained this to me
17:35:05 <Cale> startling: not that easily...
17:35:05 <ClaudiusMaximus> cabal install opencl ; ghc -O2 -Wall --make opencl-example-01.hs -> undefined references to clFooBarBaz ; ghc -O2 -Wall --make opencl-example-01.hs -lOpenCL -> links correctly
17:35:09 <ClaudiusMaximus> is that a bug?
17:35:14 <yottabit> i've got the log on an external hdd, i'll grab it and read
17:36:04 <Cale> It pains me that nubBy / groupBy etc. end up flipping the parameters to their function parameter
17:37:10 <dolio> Cale: I don't know what could be going on, then. Top level bindings should be generalized.
17:37:18 <CodeWeaver> Bah, ghc still whining.
17:37:23 <Cale> dolio: yeah, it's like nothing I've seen before
17:38:10 <kniu> what is showsPrec?
17:38:54 <dolio> The new inference engine is noticeably less forgiving when dealing with higher-rank stuff, though.
17:39:25 <ClaudiusMaximus> kniu: adds parentheses if needed
17:39:25 <elliott> kniu: like shows, but with operator precedence
17:39:49 <kniu> huh
17:39:50 <elliott> ClaudiusMaximus: No.
17:39:54 <Sgeo> Cale, flipping?
17:39:55 <dolio> 'id :: (forall a. a) -> forall a. a' will fail, for instance.
17:39:56 <elliott> ClaudiusMaximus: The library name differs from platform to platform.
17:40:00 <elliott> So you have to handle the linking business yourself.
17:40:02 <kniu> how am I supposed to use it?
17:40:03 <ClaudiusMaximus> elliott: ah ok
17:40:24 <ClaudiusMaximus> > showsPrec 0 (a + b :: Expr) ""
17:40:24 <lambdabot>   "a + b"
17:40:29 <ClaudiusMaximus> > showsPrec 9 (a + b :: Expr) ""
17:40:30 <lambdabot>   "(a + b)"
17:40:34 <kniu> oh
17:40:41 <Cale> Sgeo: nubBy (<) changes semantics to nubBy (>)
17:40:45 <Cale> Sgeo: for example
17:41:31 <Cale> Sgeo: for no discernable reason other than to assert that the Report technically refuses to specify nubBy on non-equivalence relations, even though it's a useful higher order function with them
17:45:10 <startling> what was that function that takes a function and calls it on itself recursively forever?
17:45:15 <MostAwesomeDude> fix
17:45:25 <MostAwesomeDude> @src fix
17:45:25 <lambdabot> fix f = let x = f x in x
17:45:40 <startling> is that not in the prelude?
17:45:44 <elliott> Data.Function
17:45:51 <startling> ah
17:45:58 <MostAwesomeDude> @hoogle fix
17:45:58 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
17:45:58 <lambdabot> Data.Fixed module Data.Fixed
17:45:58 <lambdabot> Data.Function fix :: (a -> a) -> a
17:45:58 <ClaudiusMaximus> elliott: but, wouldn't it be better for all the platform wrangling to be centralized in one place rather than duplicated among all opencl-using applications?
17:47:38 <elliott> ClaudiusMaximus: Well, cabal isn't really powerful enough; I think you'd need a custom build type thing.
17:48:43 <ClaudiusMaximus> elliott: ah, hmm - any way to specify extra-libraries on the cabal install command line?  so i could do that once when installing opencl from hackage and then not worry?
17:50:10 <elliott> ClaudiusMaximus: Probably, with --ld-options or something, but I would advise againsti t.
17:50:11 <elliott> *against it.
17:50:32 <elliott> If you want platform library detection, I'd suggest it on the issue tracker.
17:52:01 <ClaudiusMaximus> elliott: not that important to me yet - i've not written any of my own code yet!
17:55:39 <vinodh42> I just downloaded the Haskell platform.  I wanted to ask you all a quick question:  What is the name of the recommend emacs mode for ghci?  Is there an equivalent of the SLIME mode for common lisp?
17:56:45 <elliott> Nothing quite as comprehensive as SLIME. The normal haskell-mode is the best pick for now, and it has GHCi support.
17:56:55 <elliott> There's also a haskell-emacs that's promising but not really ready for prime-time yet.
17:57:05 <elliott> And scion, which I know almost nothing about but I don't think is all that popular.
17:59:22 <vinodh42> elliott: Okay thanks.  haskell-mode looks more than good enough for me.
18:21:31 <startling> what does `<?>` do in parsec?
18:21:57 <startling> oh, found it, nvm.
18:22:00 <Clint> startling: lets you specify a description
18:22:17 <mmos1127> how can I find the difference between two ClockTime's in seconds or microseconds or something like that? TimeDiff doesn't seem to be what I want-- it converts to human-readable using hour/min/sec etc.
18:24:16 <mmos1127> I guess I could look at the TimeDiff and multiply hours by 3600, minutes by 60, add in seconds
18:24:31 <mmos1127> my TimeDiffs will never be larger than hours
18:31:54 <elliott> mmos1127: realToFrac?
18:31:59 <elliott> I think TimeDiff has an appropriate instance
18:32:15 <elliott> wait, what is ClockTime? oh, you are using old-time
18:32:30 <elliott> yeah, dunno then
18:33:03 <elliott> mmos1127: you could add it to the epoch and extract the seconds/picoseconds
18:33:06 <elliott> ugly, though
18:35:25 <CodeWeaver> HOLY SWEET ZOMBIE JESUS… pardon my language.
18:35:41 <CodeWeaver> Elliott's code is down to 0.050s on my box, using the llvm compiler.
18:35:49 <nyingen> that's pretty fast
18:36:18 <CodeWeaver> Where's mm's best code....
18:36:39 <CodeWeaver> That difference is *staggering*.
18:37:45 <rwbarton> where is elliott's code?
18:37:53 <rwbarton> not the gzip | uuencoded one I hope
18:39:02 <ddarius> The gzip | uuencode | gzip | uuencoded one.
18:39:03 <CodeWeaver> Moment, gotta go back in my log to find the hpaste
18:41:02 <elliott> rwbarton: If it works...
18:41:58 <mmos1127> elliott: thanks. I just discovered some bad news. it appears that "getClockTime" is only accurate to 15 ms (1/66 second) in XP.
18:42:44 <scooty-puff> are there any plans to expand the IsMap and IsSet type classes of hoopl?
18:43:00 <scooty-puff> i need toList (for IsSet), and a few other things that it does not include
18:43:16 <scooty-puff> and i am about to resort to unsafeCoerce on Unique's to use and IntSet because its missing
18:43:34 <mmos1127> There is another way, not something I wanted to do, but maybe I could find a way to make it work -- the PortMidi library has a way to play midi events with (I would suppose) decent time precision-- the problem is that one must give it all the events in a single list, with no opportunity for real-time interaction with my program
18:44:57 <elliott> mmos1127: You can "fix" that with lazy IO.
18:45:17 <mmos1127> elliott: sounds cool but I don't understand
18:45:32 <elliott> Actually
18:45:34 <elliott> writeEvents :: PMStream -> [PMEvent] -> IO PMError
18:45:41 <elliott> I don't see anything saying you can't call this multiple times.
18:45:42 <mmos1127> oh, I see what you mean.. I don't need to construct the entire list at once?
18:45:59 <elliott> mmos1127: yeah, but actually you do have to, since this uses withArrayLen.
18:46:07 <rwbarton> apparently emacs doesn't like 10000000-character long lines
18:46:23 <mmos1127> elliot: you are quick with the documentation? did you look at the code already?
18:47:28 <mmos1127> elliott: thanks.. I'll look at the idea of calling writeEvents multiple times.. I bet I can make that work
18:48:25 <CodeWeaver> elliott, could you repaste your hpaste of your fast 2,3,5 generator?  I'm having a hard time finding it in my chatlog.
18:49:11 <elliott> CodeWeaver: Which one?
18:49:15 <elliott> http://hpaste.org/56946?
18:49:35 <elliott> http://hpaste.org/56941 is my other one, but mm_freak's http://hpaste.org/56944 is faster.
18:49:46 <elliott> Mine stores the values, though, which mm_freak's doesn't.
18:50:00 <CodeWeaver> Wait that first one is a big binary file or something?
18:50:19 <rwbarton> http://hpaste.org/56946 doesn't store the values either
18:51:49 <rwbarton> http://hpaste.org/56941 is about 20% faster for me than the Vector one
18:51:53 <elliott> CodeWeaver: nah, you need to uudecode | gunzip it
18:51:54 <elliott> but it's slow :)
18:52:06 <elliott> so use the #y one instead
18:52:08 <CodeWeaver> elliott:  That's a nuisance. :D
18:53:00 <CodeWeaver> That's really weird.  elliott's is faster on my box than mm_freak's.
18:53:36 <CodeWeaver> The non-uuencoded one.
18:54:19 <elliott> mm_freak: ha! take that!
18:54:37 <elliott> CodeWeaver: is that mm_freak's new one, though? he revised it
18:54:45 <CodeWeaver> What's the most revised one?
18:55:08 <rwbarton> I think this is due to remInt# being faster than rem
18:55:41 <CodeWeaver> Okay, I need mm_freak's best then.  I don't think I have it.  If you can find it easily, I'd love to re-benchmark.
18:55:51 <CodeWeaver> Both are very very good solutions, and I'm creeping up on C level performance here.
18:55:54 <elliott> CodeWeaver: <elliott> http://hpaste.org/56941 is my other one, but mm_freak's http://hpaste.org/56944 is faster.
18:56:13 <CodeWeaver> Okay, yes.
18:56:15 <CodeWeaver> Got it.
18:56:19 <elliott> rwbarton: I suspect mm_freak's Ints get unboxed.
18:56:32 <hpaste> rwbarton annotated “2,3,5 sequence in C, to port to haskell” with “2,3,5 sequence in C, to port to haskell (annotation) (annotation)” at http://hpaste.org/56932#a56951
18:56:55 <CodeWeaver> mm_freak's runs at 0.082s, and elliott's works at 0.049s
18:57:22 <CodeWeaver> I'll do rwbarton's next.
18:58:06 <rwbarton> here it seems to be about the same speed as elliott's, though I've increased to 100M for testing
18:58:43 <CodeWeaver> Ah, that won't be *quite* a fair comparison.  Both elliott and mm_freak make the mistake of computing ten million elements, rather than capping out at ten million as a value.  rwbarton actually meets spec by going up to ten million as a value. But this means comparisons aren't possible.
18:59:00 <CodeWeaver> I'd have to do some tweaking of the solutions.
18:59:10 <CodeWeaver> I can compare rwbarton's to mine, however.
18:59:25 <startling> could someone help me with this weird error I'm getting with parsec? My code and some explanations here: http://bpaste.net/show/22397/
18:59:35 <rwbarton> actually mm_freak's (and one of elliott's) are doing something very different which is building an array of Bools
18:59:51 <CodeWeaver> Hmmmm
19:00:19 <mmos1127> elliott: Eureka! Sound.PortMidi provides a 'time' function that is accurate to 1 ms
19:00:44 <rwbarton> hmm, is there browsable ghc source online somewhere?
19:00:44 <CodeWeaver> rwbarton: 0.053s.
19:01:20 <tromp> > .001*.002*.95*.63
19:01:21 <lambdabot>   <no location info>: parse error on input `.'
19:01:29 <CodeWeaver> Wow, that's within like 20 percent of the C executable.
19:01:31 <CodeWeaver> That's amazing.
19:01:36 <tromp> > 0.001*0.002*0.95*0.63
19:01:36 <lambdabot>   1.197e-6
19:01:45 <rwbarton> did you get llvm installed?
19:01:48 <rwbarton> for ghc
19:02:39 <CodeWeaver> Yes, I did.
19:02:46 <CodeWeaver> The improvement was dramatic.
19:02:54 <rwbarton> apparently it generates much better assembly than non-llvm gcc or ghc for modulo (not really sure how this is possible)
19:02:57 <CodeWeaver> Only reason I'm getting 50 milliseconds instead of 200.
19:03:53 <parcs`> what is the link to the fastest implementation?
19:04:42 <CodeWeaver> My best is apparently 0.082, so I definitely don't have the crown on my box.
19:05:57 <CodeWeaver> The fastest is either http://hpaste.org/56932#a56951
19:05:57 <CodeWeaver> http://hpaste.org/56944http://hpaste.org/56932#a56951http://hpaste.org/56941http://hpaste.org/56932#a56951
19:05:58 <rwbarton> parcs`: it sounds like http://hpaste.org/56941 is the fastest and http://hpaste.org/56932#a56951 is marginally slower
19:07:00 <CodeWeaver> ooh, I'm down to 0.040s on my own box.  Verifying.
19:07:22 <CodeWeaver> Looks good.  Although I'm only going up to value ten million, not ten million elements, so that could be the difference.
19:07:35 <elliott> oh right
19:07:36 <CodeWeaver> between mine and the best so far.  So I claim nothing until I can get them all computing the same number of terms.
19:07:40 <parcs`> heh yeah -fllvm makes elliott's version 8x faster here
19:07:40 <elliott> mm_freak's has one too many 0s
19:07:45 <elliott> remove a 0 from his code
19:07:49 <elliott> to compare to mine
19:07:55 <elliott> i forget which value the C program has...
19:08:07 <CodeWeaver> No, the one I got from him has ten million as its number of elements.
19:08:10 <CodeWeaver> Verified.
19:08:29 <elliott> ok, seems like mine does too
19:08:35 <kniu> I can't figure out how to actually implement showsPrec
19:08:37 <CodeWeaver> But its still more elements than I generate because I only go up to value ten million as I said.
19:08:41 <elliott> CodeWeaver: mine builds an array of Ints, btw
19:08:44 <kniu> why does it have that extra string parameter?
19:08:46 <CodeWeaver> That's about 7.3 million elements.
19:08:54 <elliott> CodeWeaver: mine does value ten million
19:08:58 <elliott> -> 7.3 million elements
19:09:03 <elliott> it just /allocates/ an array for ten million for speed
19:09:04 <CodeWeaver> Really?
19:09:07 <CodeWeaver> OH wait.
19:09:10 <CodeWeaver> *looks*
19:09:15 <elliott> kniu: that's ShowS
19:09:22 <elliott> kniu: you can use standard combinators like showString, showParen, showChar
19:09:23 <elliott> :t showString
19:09:24 <lambdabot> String -> String -> String
19:09:25 <elliott> :t showParen
19:09:26 <lambdabot> Bool -> ShowS -> String -> String
19:09:34 <CodeWeaver> elliott, what stops it at 7.3 million elements?
19:09:38 <elliott> showString "foo" . showString "bar" === showString "foobar"
19:09:41 <kniu> oh okay
19:09:42 <CodeWeaver> I'm being dumb.  I can't see it.
19:09:51 <elliott> CodeWeaver: Nothing. It goes through all ten million entries.
19:09:58 <kniu> but why?
19:10:05 <elliott> It just doesn't fill in more than 7.3 million entries, that's all.
19:10:05 <Axman6> :t showParen
19:10:05 <lambdabot> Bool -> ShowS -> String -> String
19:10:09 <elliott> Because those are the only ones that fit the predicate.
19:10:13 <elliott> kniu: efficiency
19:10:19 <CodeWeaver> Uhhh...
19:10:25 <elliott> kniu: ("foo" ++ "bar") ++ "baz" is slow, basically
19:10:31 <elliott> we want "foo" ++ ("bar" ++ "baz")
19:10:41 <elliott> ShowS enforces this with something basically like continuation-passing style
19:10:41 <CodeWeaver> Oh for heaven's sake. I see.
19:10:43 <elliott> showString foo = (foo ++)
19:10:47 <rwbarton> uh I totally didn't notice before that on 64-bit systems, C int is 32 bits but GHC Int is 64 bits
19:10:48 <kniu> that seems
19:10:51 <kniu> roundabout
19:10:51 <elliott> CodeWeaver: it just does what your C code does :)
19:10:58 <CodeWeaver> I told you, I'm being dumb.
19:11:01 <kniu> why not just use Data.Sequence?
19:11:11 <Sgeo> What's the associativity of ++?
19:11:13 <CodeWeaver> So elliott and I do about 0.5ms.
19:11:18 <Axman6> Sgeo: the good one
19:11:19 <elliott> kniu: ShowS is really simple, and Data.Sequence doesn't have good constant factors
19:11:22 <CodeWeaver> Actually I do 0.4, so I'm sure elliot wants to kick my bum.
19:11:24 <elliott> also, ShowS massively predates Data.Sequence
19:11:29 <Axman6> x ++ (y + z)
19:11:30 <Axman6> ++*
19:11:40 <CodeWeaver> I'll paste my code to you in a sec.
19:11:40 <Sgeo> Ok
19:11:55 <kniu> okay I kinda get it now
19:12:01 <tikhonjelvis> Has anybody here had any luck installing wx?
19:13:12 <elliott> kniu: you don't have to worry about it, really, just use the standard combinators
19:13:58 <CodeWeaver> Okay, fixing mm_freak's code for the right number of elements, I get 0.065s on my box.
19:14:14 <CodeWeaver> I get 0.050s for elliott's.
19:14:25 <rwbarton> you shouldn't really compare mm_freak's code at all unless you are going to add a pass to convert the array to a list of Ints rather than a list of Bools
19:14:26 <CodeWeaver> I get 0.051s for rwbarton's.
19:14:36 <CodeWeaver> Yes, true, so take that as a caveat.
19:15:32 <CodeWeaver> And I get 0.041s on my box for mine.  Shall I post mine?  Hm, I'll have to clean up my code, cause I used a custom seq function to time my code.  Hang on.  I'll verify I'm not cheating somehow.
19:17:43 <elliott> CodeWeaver: just use "time" to compare times, doing it in the language is a bad idea
19:19:25 <augur> why is GHC 125k lines of code? 0.0
19:19:35 <elliott> how big is gcc?
19:19:40 <tikhonjelvis> That sounds really short, actually.
19:19:43 <elliott> GHC is not that big for what it does.
19:19:44 <Axman6> because its a complex compiler?
19:19:47 <elliott> It could be shorter.
19:19:51 <elliott> But it's a very advanced compiler.
19:19:51 <CodeWeaver> yes, I'm stripping out my timing and seq code that doesn't matter.
19:20:10 <elliott> augur: How big is gcc?
19:20:16 <augur> no idea!
19:20:18 <elliott> (Okay, gcc minus all the non-C languages.)
19:20:26 <elliott> augur: You can look at jhc if you want to read a shorter Haskell compiler.
19:20:31 <augur> but i mean, GHC1 was 13k lines
19:20:37 <augur> even thats a lot to me, but
19:20:49 <elliott> GHC1?
19:20:55 <elliott> I did not think versions that early were available.
19:21:02 <monochrom> why do you say "0.0"? 0.0
19:21:02 <tikhonjelvis> Have you ever used a language like Java? It takes 13k lines for hello world...
19:21:09 <elliott> Oh, http://www.haskell.org/ghc/download_ghc_029 is available.
19:21:28 <elliott> augur: How big did you *expect* GHC to be?
19:21:45 <elliott> If 13k lines is a lot, I'd like to see you implement an optimising Haskell compiler in 10,000...
19:21:47 <augur> elliott: i dont know! but less than 13k lines, nevermind 125k lines
19:22:05 <elliott> I take it you haven't written any substantial programs? Or compilers, at least.
19:22:07 <augur> thats what i imagine most of it is -- optimization
19:22:12 <augur> but thats why im asking
19:22:20 <CodeWeaver> Damn, introduced a bug.  I can't claim the crown.
19:22:41 <elliott> Anyway, jhc is only 46k lines of Haskell.
19:22:52 <elliott> And it's whole-program-optimising.
19:22:59 <elliott> I think people consider it more idiomatically-written than GHC, too.
19:23:17 <monochrom> to me, your "0.0" is no longer "just" asking, it is already a statement of your judgement, it makes your question rhetorical
19:23:36 <elliott> augur: How are you counting these lines?
19:23:41 <augur> monochrom: its an expression of .. stunnedness?
19:23:46 <augur> elliott: im not, SPJ is
19:23:49 <elliott> Use sloccount or ohcount or similar, not wc -l, and do not count the libraries/ directory, which is not part of the compiler.
19:23:50 <elliott> Ah.
19:24:46 <monochrom> no, to me, it is an expression of disbelieve based on presumptions
19:25:11 <monochrom> in fact, if you had no presumption, there would be no stun
19:25:15 <tikhonjelvis> That said, Haskell is the only language where as I add features to my programs the code gets shorter >.<
19:26:07 * hackagebot taffybar 0.2.0 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.2.0 (TristanRavitch)
19:26:40 <CodeWeaver> Nope, there was a bug in my code.  I got 0.050s myself, or close enough.
19:26:48 <elliott> augur: Anyway, GHC contains a Haskell parser, a desugarer, a Core language (including pretty-printer), a great great deal of optimisation, the data-parallel Haskell stuff, an advanced runtime system with lots of multithreading, profiling, and statistics support including a good GC, a full Cmm implementation, several native code backends (actually, are these still around?), a C backend, an LLVM backend, a bytecode interpreter, a REPL, Template Hask
19:26:48 <elliott> ell support (which is non-trivial, given that the compiler has to interpret and interface with Haskell code at compile-time, and then stuff the result back into the program, and it "interleaves" compiler passes a lot), ... not to mention all the language extensions it supports.
19:27:23 <augur> elliott: mm that makes sense
19:27:26 <monochrom> GHC has more than 2 native code backends
19:27:28 <rwbarton> apparently gcc doesn't decide to inline fill_235 in the original C program, which is why clang does so much better there...
19:27:57 <Axman6> yay clang
19:28:10 <elliott> You could write a toy Haskell compiler in <10k lines.
19:28:12 <elliott> But it'd be terrible.
19:28:40 <hpaste> CodeWeaver annotated “2,3,5 sequence in C, to port to haskell” with “2,3,5 sequence in C, to port to haskell (annotation) (annotation) (annotation)” at http://hpaste.org/56932#a56952
19:29:12 <CodeWeaver> I win no points for elegance.
19:29:20 <ion> elliott: Some of us prefer Toy Haskell.
19:29:53 <tikhonjelvis> Can anybody help me with building wx?
19:29:54 <Axman6> CodeWeaver: why use IO when you could use ST?
19:30:10 <CodeWeaver> No particular reason.
19:30:34 <dmwit> tikhonjelvis: Even if somebody can help you, they will need more details.
19:30:40 <CodeWeaver> I was reading up on how to use the Vector class and it happened to use the IO monad instead of ST as a demo that it didn't much matter.
19:30:58 <tikhonjelvis> naturally
19:31:15 <elliott> CodeWeaver: Is that seriously faster than mine?
19:31:36 <tikhonjelvis> Trying `cabal install wxcore` returns: wxcore-0.13.2 failed during the configure step. The exception was:
19:31:37 <tikhonjelvis> ExitFailure 1
19:31:37 <rwbarton> if I just declare fill_235 to be static then gcc inlines it and that makes it faster than clang
19:32:02 <tikhonjelvis> This is after a long string of "parsing: ..." and "generating: ..." lines
19:32:12 <elliott> tikhonjelvis: That's not the error, that's just telling you there was some error.
19:32:15 <elliott> hpaste the whole build log
19:32:16 <tikhonjelvis> Oh, it also says "setup: failed" at some point
19:32:20 <tikhonjelvis> Okay
19:32:27 <Axman6> do you have wx installed?
19:32:29 <dmwit> Have you got the -dev versions of the wx library installed?
19:32:38 <CodeWeaver> elliott:  It's not faster.  It's identical in speed.
19:32:40 <dmwit> (i.e. the non-Haskell part)
19:32:40 <tikhonjelvis> I think so.
19:32:42 <CodeWeaver> On my box anyway.
19:32:47 <CodeWeaver> 0.050s
19:32:58 <CodeWeaver> Yours is *way* more elegant.
19:33:21 <elliott> CodeWeaver: :(
19:33:23 <tikhonjelvis> Or maybe I don't. Oops.
19:33:33 <elliott> Of all the code I've written, that was not the piece I'd most expect to be called elegant :P
19:33:53 <Axman6> hmm, why use remInt# x 2 when you could use even (which may or may not be faster)
19:34:17 <tikhonjelvis> dmwit: Aha, that was the particular issue. Now it's still failing, but I can probably figure it out :)
19:34:53 <monochrom> because there is no multiple_of_3_Int# to go with it
19:35:00 <dmwit> tikhonjelvis: Despite our success in guessing this time, next time you should just paste the whole error. =)
19:35:45 <CodeWeaver> remInt# is pretty bloody fast.  I could do a bitwise test *perhaps* to speed that up.
19:36:01 <CodeWeaver> But I doubt even would.
19:36:09 <CodeWeaver> And even doesnt have an unboxed variant.
19:36:20 <rwbarton> another fun fact is the C executable is under 7K while the Haskell executable is over 4M :D
19:36:35 <CodeWeaver> On mine, the C and haskell execs are both about 1.4M.
19:36:49 <CodeWeaver> Don't know what that's about, but I wasn't after the exec size.
19:36:59 <ion> rwbarton: -split-objs -dynamic :-P
19:37:29 <rwbarton> ion: But perhaps I haven't installed the "dyn" libraries for package `vector-0.9'.
19:37:30 <monochrom> just gzip the executable. twice.
19:38:02 <Clint> strip --strip-like-the-wind
19:38:13 <ion> monochrom: You get better results by using a lossy executable compressor.
19:38:42 <elliott> monochrom: Don't forget the vital uuencode step.
19:39:24 <monochrom> cat foo.exe | lame > foo.mp3
19:39:29 <rwbarton> llvm is actually turning remInt# x 2# ==# 0# into a bit test for you
19:39:41 <elliott> monochrom: Vorbis makes your program, like, 70% more reliable.
19:39:59 <Enigmagic> 70% less bugs
19:40:21 <ion> Programs stored on vinyl still sound better.
19:40:44 <rwbarton> Also, apparently remInt# x 3# ==# 0# gets turned into some clever thing involving a two-word multiply by 0xaaaaa...aaab
19:40:56 <CodeWeaver> Freaky.
19:41:10 <Sgeo> :t (==#)
19:41:11 <lambdabot> Not in scope: `==#'
19:41:20 <elliott> It's equality on unboxed ints.
19:41:22 <rwbarton> yeah, it's like 10 instructions but I guess it is better than doing a divide
19:42:11 <rwbarton> how do I get unboxed 32-bit ints on 64-bit ghc?
19:42:31 <elliott> you can't
19:42:32 <ion> > map (* 0xaaaaaaab) [0..10] :: [Word32]
19:42:33 <lambdabot>   [0,2863311531,1431655766,1,2863311532,1431655767,2,2863311533,1431655768,3,...
19:42:34 <elliott> Int32 is just Int# inside
19:42:39 <rwbarton> oh huh
19:42:41 <Enigmagic> W32#
19:42:41 <Axman6> o.O
19:42:43 <elliott> rwbarton: but there are Int32 array functions
19:42:47 <elliott> well primops i should say
19:42:50 <Enigmagic> GHC.Word.W32#
19:42:52 <elliott> they just take Int#s, though
19:42:53 <elliott> Enigmagic: oh huh
19:43:05 <CodeWeaver> To get ==# you'll need GHC.Prim and also turn on the MagicHash extension
19:43:10 <elliott> CodeWeaver: GHC.Exts
19:43:16 <elliott> you shouldn't import GHC.Prim
19:43:19 <CodeWeaver> Oh?
19:43:20 <CodeWeaver> Okay.
19:43:21 <Sgeo> :t (GHC.Exts.==#)
19:43:21 <CodeWeaver> Noted.
19:43:22 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> Bool
19:43:29 <CodeWeaver> Why's that
19:43:31 <Sgeo> It says that in the documentation
19:43:35 <rwbarton> so is there remInt32# etc.?
19:43:36 <CodeWeaver> Does it?  Missed that.
19:43:37 <CodeWeaver> Okay.
19:44:10 <Sgeo> "Use GHC.Exts from the base package instead of importing this module directly."
19:44:18 <CodeWeaver> Gotcha.
19:44:19 <CodeWeaver> Okay.
19:44:20 <CodeWeaver> You win.
19:44:21 <CodeWeaver> :D
19:44:23 <elliott> CodeWeaver: GHC.Exts is the officially-supported interface, and GHC.Prim requires a ghc-prim dependency.
19:44:25 <elliott> (i.e. it's not in base.)
19:44:44 <elliott> rwbarton: dunno
19:45:25 <ion> > let n = (maxBound `div` 3) * 3 - 30 in map (* 0xaaaaaaab) [m,m+3..] :: [Word32]
19:45:26 <lambdabot>   Couldn't match expected type `GHC.Word.Word32'
19:45:26 <lambdabot>         against inferred typ...
19:45:41 <ion> > let n = (maxBound `div` 3) * 3 - 30 in map (* 0xaaaaaaab) [n,n+3..] :: [Word32]
19:45:42 <lambdabot>   [1431655755,1431655756,1431655757,1431655758,1431655759,1431655760,14316557...
19:46:21 <dmwit> > (1372-37,460-60)
19:46:21 <lambdabot>   (1335,400)
19:47:19 <Sgeo> @hoogle Down
19:47:20 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Down :: KeyState
19:47:20 <lambdabot> GHC.Exts Down :: a -> Down a
19:47:20 <lambdabot> GHC.Exts newtype Down a
19:47:36 <Sgeo> o.O is there not a better way to make Down values than GHC.Exts?
19:47:47 <elliott> That's where Down is.
19:47:55 <Sgeo> Why?
19:47:58 <elliott> I think GHC uses it.
19:48:05 <Sgeo> @hoogle the
19:48:06 <lambdabot> GHC.Exts the :: Eq a => [a] -> a
19:48:06 <lambdabot> Text.XHtml.Strict thead :: Html -> Html
19:48:06 <lambdabot> Text.XHtml.Frameset thead :: Html -> Html
19:48:06 <elliott> And there's less red tape just putting it in GHC.Exts.
19:48:36 <Sgeo> > GHC.Exts.the [1,1,1,1,1,1]
19:48:37 <lambdabot>   Not in scope: `GHC.Exts.the'
19:49:22 <Axman6> the?
19:49:25 <thlorenz> is there a lib that has a function to download binary files (e.g, images) from the web ideally saving it to a file?
19:49:43 <Sgeo> Axman6, checks that all elements are equal, then returns the element
19:49:54 <Sgeo> Why was I thinking it was good, it's clearly a partial function
19:49:57 <Axman6> and if they're not?
19:49:59 <thlorenz> I searched Hoogle with URL -> FilePath -> IO () without any luck
19:50:17 <Sgeo> error "GHC.Exts.the: non-identical elements"
19:50:32 <tikhonjelvis> I think there's a package for using curl.
19:50:34 <Axman6> thlorenz: sounds like a great use for the conduit (well, depending on how big the files are anyway)
19:50:57 <Sgeo> @hoogle (Eq a) => [a] -> Maybe a
19:50:58 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
19:50:58 <lambdabot> GHC.Exts the :: Eq a => [a] -> a
19:50:58 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:51:04 <thlorenz> I expect them to be smaller images
19:51:11 <Sgeo> > listToMaybe [1,2]
19:51:12 <lambdabot>   Just 1
19:51:19 <ion> @check \b -> let a = fromInteger b :: Word32 in ((a * 0xaaaaaaab <= (maxBound `div` 3) * 3 * 0xaaaaaaab) == (a `mod` 3 == 0))
19:51:21 <lambdabot>   "OK, passed 500 tests."
19:51:21 <rwbarton> oh I see, it is basically doing x `mod` 3 by calculating x - 3 * floor(x/3)
19:51:22 <Axman6> thlorenz: we tend not to make such specialised functions in haskell, tending more to make things that are easilly composed. so there's probably a function that takes a URL and gives you a bytestring, and there's others to take a bytestring and write them to disk
19:51:45 <rwbarton> except it can compute x/3 with a multiplication
19:51:56 <elliott> thlorenz: simpleHttp "...url..." >>= B.writeFile "foo"
19:52:01 <elliott> thlorenz: using simpleHttp from http-conduit: http://hackage.haskell.org/packages/archive/http-conduit/1.2.0/doc/html/Network-HTTP-Conduit.html
19:52:12 <elliott> and writeFile from Data.ByteString
19:52:31 <elliott> oh, wait
19:52:31 <elliott> and writeFile from Data.ByteString.Lazy
19:52:37 <rwbarton> what ion did looks way more clever
19:52:59 <rwbarton> > (maxBound `div` 3) * 3 * 0xaaaaaaab :: Word32
19:53:00 <lambdabot>   1431655765
19:54:08 <monochrom> 0xaaaaaaab * 3 = 1  (mod 2^32)
19:55:13 <thlorenz> elliot thanks, looks like simpleHTTP looks actually simpler (nip) in conduit than the one that is built into NetworkHTTP, looks like this is what I need
19:56:02 <thlorenz> Axman6 I know, was just looking for a shortcut it's midnight here already ;)
19:58:06 <monochrom> > (maxBound :: Word32) `div` 3
19:58:06 <lambdabot>   1431655765
19:58:25 <monochrom> > ((maxBound :: Word32) `div` 3) * 3 * 0xaaaaaaab
19:58:26 <lambdabot>   1431655765
19:58:42 <CodeWeaver> Are you still having fun with that screwy mod 3 implementation?
19:58:43 <CodeWeaver> :D
19:58:44 <monochrom> you don't need 3 * 0xaaaaaaab there
20:49:21 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
20:49:21 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:48 2011]
20:49:34 <elliott> and then we'll start writing lazy IO type-level programs, and that just doesn't scale...
20:50:00 <monochrom> then it's Iteratee at the type level all over again
20:50:16 <ion> Type level IO programming isn’t web scale in the cloud?
20:50:18 <monochrom> and conal will say "this is not denotative --- at the type level!"
20:50:31 <elliott> kind class morphisms
20:50:42 * cmccann wants kind-level programming
20:50:51 <ion> kind of
20:50:54 <elliott> what semantics does * have?
20:52:35 <ion> In some fonts it’s five-pointed. In others, six-pointed.
20:53:32 <monochrom> hahaha
20:54:11 <ion> *∗*
20:54:14 <monochrom> great way to answer a semantics question by commenting on the font
20:54:32 <elliott> I see, so it's like IO
20:54:42 <elliott> differing between implementations and with only superficial meaning :)
20:55:29 <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width in some other fonts"
20:55:47 <elliott> :D
20:55:50 <ion> :-)
20:57:02 <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
20:57:14 <CodeWeaver> Now stop that.  You're making me giggle into my bubbly beverage.  That's fraught with broken keyboards.
20:57:41 <elliott> @remember monochrom <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
20:57:41 <lambdabot> It is stored.
20:57:47 <elliott> oh, that's a lot longer than it looked
20:57:53 * monochrom saw a very old typewriter of his grandfather. did not have "1" or "0". it did expect you to type "IO" for that
20:59:10 <ion> That’s also where the " kluge originated from AFAIU (since they didn’t want to waste two keys for “, ”). And ASCII inherited it for a similar reason.
21:08:09 <CodeWeaver> Alright, be back later… *waves*
21:13:37 <wavewave> hxournal now has lasso selection support!
21:14:18 <wavewave> just implemented!
21:17:01 <ion> If i ever get around to implementing the Best Ever™ piece of software for creating Khan Academy style videos using a stylus and a microphone (with integrated non-linear editing for both audio and drawings), hxournal’s code might be useful.
21:17:30 <ion> (Since i’ll probably never get around to that, someone else should. :-P)
21:17:38 <wavewave> ion: definitely.. I am actually thinking about that.
21:17:55 <wavewave> just add time coordinate...
21:18:41 <wavewave> eventually I would like to make a base library of pen computing
21:19:23 <wavewave> ion: if you are interested in hxournal, please try and give some feedback ;-)
21:20:50 <wavewave> it's much stabilized last weekend. ;-D
21:21:02 <ion> It would be nice to have an Audacity-style UI for audio tracks where you could remove moments of silence, failed takes etc. and the associated changes to the drawing would be deleted along with them.
21:21:21 <ion> I’ll have to try hxournal, yeah. :-)
21:22:25 <wavewave> lecture recording is definitely of my interest.
21:23:21 <wavewave> anyway, before that, I will make hxournal more extensible as user can script.. like xmonad or emacs .
21:24:03 <wavewave> haskell is so productive language. hehe.
21:28:23 <mzero> and yet it is so easy to get jaded: I just complained on in private chat that adding a web server to my app too.... 58 lines of code -- 58 whole lines!!!!
21:28:51 <mzero> (well, only 31, really - the rest were imports and headers)
21:29:13 <mzero> :-)
21:29:17 <wavewave> :-)
21:29:27 <tikhonjelvis> It sounds like you should use APL
21:29:48 <wavewave> mzero: I also implemented network support for hxournal.. but now removed it from official version.
21:29:54 <mzero> or Control.Arrow... !
21:30:28 <shachaf> mzero: So I was at Hac Boston and I brought up BayHac, and at least one local person said they would probably go and wanted to know when it would be.
21:30:36 <shachaf> Sadly I was not able to provide that information.
21:30:39 <wavewave> I would like to make plugin system first and put network support as contrib package like xmonad style.
21:30:49 <wavewave> shachaf : hi!!
21:30:57 <shachaf> wavewave: G'day!
21:31:03 <mzero> oy
21:31:09 <mzero> I still haven't found a date
21:31:09 <ion> life←{↑1 ⍵∨.^3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
21:31:33 <tikhonjelvis> What exactly is BayHac?
21:31:47 <wavewave> BayHac sounds good. If it works with my schedule, I may also go there.
21:33:05 <ion> wavewave: What does hxournal do with networking? Collaborative editing?
21:33:20 <wavewave> ion: yes.
21:33:25 <ion> Ok, cool.
21:33:41 <mzero> BayHac was a Haskell Hackathon held in Mountain View, California
21:33:41 <wavewave> ion: i just implemented sharing clipboard first
21:33:46 <mzero> last year in February
21:33:51 <tikhonjelvis> ah
21:33:55 <mzero> This year, it is likely to be end of March or April
21:34:04 <tikhonjelvis> sounds interesting
21:34:43 <wavewave> ion: but it depends on too many other network-related package, so I would like to make it as a plugin.
21:34:44 <mzero> we did 2.5 days of hacking (~25 haskellers), and 0.5 day workshop for newbies (~70!!!!)
21:34:53 <handonson> Hi. A hosting server I am using can't access hackage.haskell.org. I tried the IP address of the hackage server with w3m and it doens't work either. I contacted the hosting company and they say it is most likely that hackage has banned the IP for causing traffic in the past.
21:35:03 <tikhonjelvis> Quite the turn-out
21:35:16 <handonson> Does there such ban exist? If so, what should I do to lift it?
21:35:33 <mzero> http://mtnviewmark.wordpress.com/2011/02/13/bayhac-2011-wrap-up/
21:35:35 <wavewave> keep the main thing simple.
21:36:22 <mzero> ah - misspoke - ~40 newcomers + the ~25 haskllers = ~70 folks
21:36:30 <tikhonjelvis> Still impressive
21:36:47 <handonson> also, is there an up-to-date hackage mirror that I can set cabal to use in the meantime? the attoparsec package for ubuntu is a buggy version and it's causing all my code to malfunction.
21:37:07 <tikhonjelvis> I'll try to make it out this year then.
21:37:25 <wavewave> I remember some hackage mirror exist...but I don't know right now.
21:37:54 <wavewave> I also found hackage server often got slow.
21:38:36 <handonson> in my case it's completely fine on my laptop and completely unreachable from this server.
21:40:34 <ion> printf ("%u folks\n", ~40 + ~25);
21:40:34 <ion> 4294967229 folks
21:41:11 * hackagebot llrbtree 0.1.0 - Purely functional data structure  http://hackage.haskell.org/package/llrbtree-0.1.0 (KazuYamamoto)
21:41:26 <handonson> I can't find any hackage mirror
21:44:45 <alkoma> seem like haskeller doesn't take compiler's warning very serious ;)
21:45:12 <alkoma> seem like haskeller doesn't take compiler's warning very serious ;)
21:45:12 <alkoma>                                                                         [22:I just cabal install darcs and the screen is flooded with warning ...
21:46:22 <ion> It seems people whose nicks begin with the letter A tend to overgeneralize.
21:46:27 <Ralith> seem like alkoma doesn't take terminal input very serious ;)
21:49:26 <ddarius> ion: Meanwhile ~70 is 4294967225
21:52:47 <alkoma> perhaps, I overgeneralize, but on my freebsd machine, "build world" is done with -Werror.  So I am a bit surprise to see a lot of warning - that's all.
21:53:20 <alkoma> perhaps, I overgeneralize, but on my freebsd machine, "build world"
21:53:20 <alkoma>          is done with -Werror.  So I am a bit surprise to see a lot of warning
21:53:20 <alkoma>          - that's all.                                                  [22:
21:53:23 <alkoma> - that's all.
21:53:23 <alkoma>          [22:
21:53:27 <alkoma> [22:
21:53:31 <alkoma> [22:
21:53:32 <alkoma> [22:
21:53:36 <alkoma> [22:
21:53:39 <alkoma> [22:
21:53:44 <alkoma> [22:/me reset my terminal
21:53:48 <alkoma> [22:/bye
21:54:21 <Ralith> looks like one of us had good judgement anyway ^^
21:59:25 <alkoma> iam back - sorry for the messed up termianl, hope it's ok now.
21:59:44 <alkoma> iam back - sorry for the messed up termianl, hope it's ok now.
21:59:45 <alkoma>                                                                         [22:arghhh, seem like it's not
22:02:13 <homie> lol
22:02:30 <alkoma> hello again!
22:02:40 <copumpkin> alkoma: I hope it's fixed
22:02:51 <alkoma> yes, look like it ok now.
22:03:08 <alkoma> yes, look like it ok now.                                      [22:or does it? I can't tell.
22:03:14 <copumpkin> no
22:03:32 <homie> you leak escape sequences.....
22:03:47 <homie> have you color terminal ?
22:03:54 <copumpkin> can you sort it out in another channel?
22:03:57 <alkoma> yes, my TERMCAP is messed up perhaps
22:04:16 <alkoma> yes sure - sorry for the mess
22:08:34 <alkoma> hello again
22:08:53 <alkoma> should be ok now, right?
22:09:15 <tikhonjelvis>  Seems fine so far.
22:09:44 <alkoma> i think something is wrong with my emacs-24.x
22:10:00 <alkoma> downgrade to emacs-23 and everything is fine ;)
22:10:12 <tikhonjelvis> Is there any compelling reason to use 24?
22:10:44 <alkoma> curiosity - perhaps ;)
22:11:54 <alkoma> I guess the same reason some people like to compile their own version of ghc instead of installing haskell-platform ;)
22:13:21 * mzero looks at cat
22:17:59 <elliott> alkoma: darcs is in large part old code, and it's not considered idiomatic by any means
22:18:22 <elliott> many common packages are -Werror-friendly (many require it)
22:21:47 <alkoma> darcs is the first thing I installed after installing haskell-platform, so it also install a few more dependencies.
22:22:04 <alkoma> so the warning is not just in darcs.
22:22:35 <alkoma> but please, don't bother with my comment about the warning.  I was just kidding, and it was but a mere observation.
22:22:51 <alkoma> I am here hoping to re-learn haskell.
22:24:34 <CodeWeaver> I'm still getting a grip on Haskell for the first time. :)  Its a fun ride.
22:28:14 <mzero> CodeWeaver: which roller coaster are you on?
22:43:43 <pcavs> When I'm specifying a new data delcaration parametrized on some type parameter a, how can I ensure that a is of some typeclass, namely Ord a ?
22:45:07 <CodeWeaver1> http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
22:45:18 <shachaf> pcavs: You can add a data type constraint, but don't.
22:45:35 <CodeWeaver1> don't?
22:45:48 <CodeWeaver1> *curious*
22:45:53 <quintessence> pcavs: Generally you put the constraint on the functions that use the datatype instead
22:45:54 <shachaf> There's no point to it.
22:45:55 <Sgeo> Make every function that relies on the constrain being there have the constraint
22:46:02 <quintessence> :t Data.Map.member
22:46:02 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
22:46:21 <shachaf> Even if Map had a data-type constraint, you'd still need to write (Ord k) there.
22:46:32 <CodeWeaver1> ahh.
22:46:42 <pcavs> okay, thanks all, it sounds like I should be putting the constraint on the functions not the actual datastructure/data delcaration
22:46:54 <shachaf> Yes.
22:47:20 <CodeWeaver1> I think i'll hang out here forever just learning things ;)
22:47:42 <shachaf> In fact, it's been removed in Haskell 2011.
22:47:46 <CodeWeaver1> i shooulda come here months ago.
22:47:52 <shachaf> Not that Haskell 2011 exists. But if it did, it would've been removed.
22:48:00 <elliott> I thought it exists, as a mailing list post.
22:48:07 <shachaf> http://www.haskell.org/pipermail/haskell-prime/2011-January/003335.html
22:48:55 <shachaf> Calling that post "Haskell 2011" is stretching it a little bit.
22:51:15 <shachaf> However, GADTs let you do something which is sort of what you want.
22:51:31 <shachaf> (In certain cases.)
22:51:57 <shachaf> E.g. for <http://hackage.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts>, data Foo a where Constr :: Eq a => a -> Foo a
22:55:12 <elliott> shachaf: It's ~Haskell 2011!
22:55:20 <elliott> The first ~Haskell report.
23:07:31 <mzero> shachaf: is the difference with GADTs that if the constructor is used or pattern matched, then the constraint is propagated into the using code, whereas with constraints on H98 ADTs it isn't?
23:10:39 <elliott> mzero: H98 ADTs don't even carry the constraint
23:10:40 <elliott> so yes
23:13:55 <mzero> elliott: but GADTs do propagate into the use site, right
23:22:45 <EvanR> with acid state, i get a state which is a single value of some type? and making changes to that type is difficult?
23:23:13 <elliott> That's what safecopy is for, no?
23:23:58 <EvanR> havent used the library yet
23:25:34 <EvanR> reading about Data.SafeCopy now
23:26:58 <elliott> acid-state is meant to be used with safecopy, as I understand it.
23:29:41 <EvanR> elliott: acid state relies on Serialize?
23:30:13 <EvanR> doesnt seem to
23:30:29 <EvanR> ... wonder how it saves the log....
23:30:57 <EvanR> oh IsAcidic relies on SafeCopy
23:41:16 <NothingMan65> Filter maximum on list?
23:42:19 <elliott> > maximum [1,2,3,4]
23:42:19 <lambdabot>   4
23:43:01 <NothingMan65> filterMaximum [1,2,3,4,5,1,5,2,3] => [5,5]
23:43:22 <EvanR> that looks frightening
23:43:29 <NothingMan65> (=
23:43:41 <elliott> > let filterMaximum xs = filter (== maximum xs) xs in filterMaximum [1,2,3,4,5,1,5,2,3]
23:43:42 <lambdabot>   [5,5]
23:43:45 <tikhonjelvis> Why does it look frightenting?
23:43:47 <elliott> Is this homework or something? Weird function.
23:44:06 <EvanR> tikhonjelvis: efficiency implications ;)
23:44:07 <shachaf> @ty ((==).maximum) >>= filter
23:44:08 <lambdabot> forall a. (Ord a) => [a] -> [a]
23:44:13 <elliott> shachaf: I was just doing that!
23:44:13 <tikhonjelvis> Now we need the pointless version!
23:44:14 <elliott> Sheesh.
23:44:20 <tikhonjelvis> Oh
23:44:22 <tikhonjelvis> timing
23:44:26 <elliott> > (==) . maximum >>= filter $ [1,2,3,4,5,1,5,2,3]
23:44:27 <lambdabot>   [5,5]
23:44:33 <NothingMan65> Thanks guyzzz
23:44:41 <EvanR> do we get the good grade
23:44:43 <EvanR> or do you
23:44:44 <EvanR> lol
23:44:52 <Blkt> good morning everyone
23:45:10 <NothingMan65> Does there exist a school where Haskell is taught?
23:45:26 <tikhonjelvis> I think it's used for a graduate class here at Berkeley.
23:45:49 <EvanR> well haskell has stopped me from getting one job so far ;)
23:45:54 <NothingMan65> Well I'm inferior enough to never have a chance at Berkeley (=
23:46:00 <tikhonjelvis> How did it do that?
23:46:09 <Ralith> my school has an elective that covers it sometimes, depending on the prof
23:46:15 <Ralith> not in much depth though
23:46:15 <EvanR> they were convinced that dynamic typing systems were superior
23:46:20 <EvanR> i said no
23:46:22 <tikhonjelvis> ah
23:46:24 <tdammers> There's a few universities where Haskell is used as an introductory-level language, can't remember which ones though
23:46:35 <tikhonjelvis> Probably in Europe...
23:46:39 <Ralith> haskell's getting me an internship!
23:46:49 <tikhonjelvis> Heh, I want a Haskell internship.
23:47:04 <tdammers> dynamic vs. static... old debate, no correct answer
23:47:10 <Ralith> I know I'm looking forward to it
23:47:38 <tikhonjelvis> tdammers: Plenty of wrong answers though. Like Java :)
23:47:41 <NothingMan65> What's the >>= operator called?
23:47:44 <tikhonjelvis> bind
23:47:52 <NothingMan65> Okay thanks
23:48:15 <tikhonjelvis> And return is sometimes pronounced unit.
23:48:20 <tikhonjelvis> Just to make life more exciting.
23:48:42 <dibblego> pure, point, η
23:48:45 <tdammers> tikhonjelvis: absolutely. java is the worst of both worlds
23:48:56 <tdammers> personally, I prefer static typing done right
23:49:05 <shachaf> dibblego: "generalised cookiemonster"
23:49:19 <dibblego> shachaf: yeah I use that sometimes
23:49:20 <tdammers> but I'd rather work with a decent dynamic language than a horribly wrong statically-typed one
23:49:21 <tikhonjelvis> I like the idea of making the types warnings. Not sure exactly how it'll work, but it could be really nice.
23:49:49 <tdammers> tikhonjelvis: you mean like in C?
23:50:03 <dibblego> no not like C
23:50:21 <tikhonjelvis> No, just let you compile Haskell even if it doesn't type-check.
23:50:31 <dibblego> exactly like most people use haskell manually, whereby they insert "undefined" in code that they are uninterested in, while type-checking some other piece of code
23:50:35 <tikhonjelvis> I remember reading about it somewhere and it seemed interesting.
23:50:48 <tikhonjelvis> dibblego: yeah, like that
23:50:54 <tikhonjelvis> more or less
23:51:10 <EvanR> i would love a javascript value which acts like haskell undefined ;)
23:51:19 <dibblego> for example, when I am teaching, most students will be happy for me to tell them that to compute length they must "fold left starting at the value 0", but the rest is vague, so they write foldl undefined 0
23:51:23 <tdammers> but there's quite a number of scenarios where your code becomes arbitrary or doesn't make any sense at all if the types don't check out
23:51:36 <EvanR> ironically haskell has values which cause side effects and js doesnt xD
23:51:48 <tikhonjelvis> tdammers: So just make warning errors for production.
23:51:49 <frerich2> I'm sorry for being offtopic, but somebody here once mentioned a nice saying and I cannot remember what it was; there's the famous "The perfect is the enemy of the good" but somebody here extended that with something like ", but the imperfect is the enemy of the good as well" or something in that spirit. Something about not using "The perfect is the enemy of the good" as an excuse to not improve.
23:51:56 <frerich2> Does anybody remember this by any chance?
23:51:57 <shachaf> https://plus.google.com/107890464054636586545/posts/EbSuoRA6FTw
23:52:13 <NothingMan65> +1 Hakell channel
23:52:17 <NothingMan65> You guys are awesome.
23:52:24 <NothingMan65> Such engagement!
23:52:31 <tdammers> I mean, one could certainly come up with a piece of code where the compiler has no chance of figuring out what the code is supposed to do because of type mismatches
23:53:06 <c_wraith> @quote perfect
23:53:06 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
23:53:15 <tikhonjelvis> tdammers: Just leave that as undefined behavior and live on happily :)
23:53:29 <c_wraith> @quote good.+perfect
23:53:29 <lambdabot> No quotes match. It can only be attributed to human error.
23:53:30 <tikhonjelvis> Heh, that quote is unrelated and yet I agree.
23:54:12 <c_wraith> at the time xahlee was active, the haskell logo would not have been what we have now :)
23:54:12 <tikhonjelvis> Basically, it would just let you work with code that's in progress.
23:54:12 <c_wraith> xahlee was a rather well-known troll
23:54:12 <tikhonjelvis> c_wraith: ah
23:54:26 <tikhonjelvis> c_wraith: Well before my time. Because I started coming here a couple of weeks ago...
23:54:48 <tikhonjelvis> Now the logo's really nice though: it both looks cool and is clever.
23:57:07 <EvanR> acidstate and safecopy seem to me to be revolutionary
23:57:39 <EvanR> eliminating huge chunks of old style applications
23:57:53 <EvanR> salivating
