00:32:19 <plat0> Does someone here know about right Kan extensions and the codensity monad?
00:32:30 <ddarius> Didactic mathematical texts use ambiguous notation to force you to work through the results again.
00:34:00 <xil> I'm "giddy as a school girl" over parsec
00:36:10 <ddarius> "Willie Moore was a young man, his age twenty-one, and he courted a damsel fair.  Oh her eyes were as white as the diamonds after night, wavy jet black wore her hair."
00:36:28 <ddarius> plat0: You are best of just asking your question.
00:36:55 <ddarius> s/of/off/
00:38:20 <plat0> When we say the codensity monad is "the right Kan extension of f along itself" presumably we mean "the right Kan extension of f along 'the restriction of f to the discrete category of its domain'".  It seems that the right Kan extension of f along f (literally) is just f.
00:39:07 <ddarius> That's not the case.
00:39:38 <plat0> What am I missing?
00:40:16 <ddarius> A functor, F, is dense if Lan_F F ~ Id, and Y (the Yoneda embedding) is dense, so Lan_Y Y ~ Id  Y /= Id clearly.
00:40:40 <ddarius> plat0: I don't know what you are doing to get to that conclusion, so I don't know.  All I know is that conclusion is false.
00:42:38 <plat0> Yes sorry.  I mean the right Kan extension of f along f (literally) is just id
00:42:40 <xil> ddarius: I love how you end your second to last comment with "clearly" while the entire thing went right over my head
00:42:49 <ddarius> plat0: That's only true for codense functors.
00:43:12 <plat0> Hmm OK
00:43:52 <ddarius> xil: I think it is pretty clear that the Yoneda embedding is not the identity functor.  They don't even have the same types.
00:44:24 <plat0> Using the definition here http://en.wikipedia.org/wiki/Kan_extension#Definition , surely if F = X then R is the identity functor and eta is the identity nat. trans.
00:44:26 <xil> ddarius: lol. I just don't know the stuff you're talking about. I just recently learned about Functors
00:44:34 <augur> ddarius: scott encodings dont let you know something will terminate just because it type checks, or so wikipedia says, but would it not be possible to take non-scott encoded code and secretly encoded it that way, thereby smuggling in termination checking?
00:44:40 <xil> it was just funny to read all of that and then, "clearly"
00:45:50 <ddarius> augur: Scott encodings just give you one layer of pattern matching.  They have nothing to do with termination.  The only notable connection is that to handle recursive types that are encoded using the Scott encoding, you need to handle the recursion through some other means.
00:47:43 <augur> ddarius: right, i know they have nothing to do with termination, but presumably they introduce type craziness so you cant use the well typedness to ensure termination (eg if you have SystemF you know it terminates if it type checks, but scott encoded LC isnt doable in SystemF)
00:48:01 <augur> what i mean tho is
00:48:18 <augur> could you treat constructors as not scott encodings when you type check
00:48:36 <augur> and then lift them into scott land and retain the termination that you had
00:48:44 <augur> or would that somehow mess things up?
00:48:52 <augur> i feel it should be exactly the same
00:51:16 <ddarius> plat0: If you choose X = F and R = Id and η = id, then it will certainly be the case that -if- you have a δ : M -> Id, then it will be unique, but you may not have such a δ.
00:53:12 <plat0> Oh I see.  Because mu is not a nat. trans. : M -> Id but : MF -> F
00:53:18 <ddarius> You can do Scott encoding in System F, it's just that for recursive types, you need to handle the recursiveness through some other means.  You could, for example, Church encode the type and then define the Scott encoding in terms of that.
00:54:03 <ddarius> plat0: You can see the significance of codensity there (and the motivation for naming it "codensity")
00:54:35 <plat0> So basically the question is does every nat. trans. : MF -> F arise from a : M -> Id
00:54:47 <plat0> and if the answer is yes then F is codense.
00:56:07 <ddarius> I would put it is every natural transformation t : MF -> F equal to s_F where s : M -> Id.
00:57:24 <plat0> I see.  Thanks ddarius.
00:57:37 <augur> doesnt this belong in ##categorytheory? :D
01:02:28 <MaskRay> is there any good tutorials/blogs on the Store comonad?
01:03:54 <shachaf> MaskRay: data Store b a = Store (b -> a) b
01:03:55 <shachaf> Done.
01:06:25 <MaskRay> shachaf: could you demonstrate further meanings about it?
01:06:44 <mauke> how do you extend?
01:11:02 <shachaf> @djinn ((s->a,s) -> b) -> (s->a,s) -> (s->b,s)
01:11:02 <lambdabot> f a (b, c) = (\ d -> a (\ _ -> b c, d), c)
01:12:21 <ddarius> MaskRay: Meaning?  Who needs meaning?
01:13:03 <companion_cube> who needs meaning when they can have proof trees
01:13:27 * ddarius prefers proof terms (though those still have a tree-like structure.)
01:15:12 <companion_cube> #agda? :)
01:15:49 <plat0> I never understood why terms we preferred to trees.
01:27:17 <ddarius> @djinn-add data Store b a = Store (b -> a) b
01:27:52 <ddarius> @djinn Store s a -> (Store s a -> b) -> Store s b
01:27:53 <lambdabot> f a b =
01:27:53 <lambdabot>     case a of
01:27:53 <lambdabot>     Store c d -> Store (\ e -> b (Store (\ _ -> c d) e)) d
01:28:22 <ddarius> @djinn Store s a -> a
01:28:23 <lambdabot> f a =
01:28:23 <lambdabot>     case a of
01:28:23 <lambdabot>     Store b c -> b c
01:28:50 <shachaf> djinn should optimize the one-constructor case.
01:29:00 * shachaf likes the pun he accidentally just made.
01:29:18 <ddarius> Optimize it to what?
01:29:31 <shachaf> f (Store a b) = a b
01:30:56 <mauke> @djinn Store b a -> Store b (Store b a)
01:30:56 <lambdabot> f a =
01:30:57 <lambdabot>     case a of
01:30:57 <lambdabot>     Store b c -> Store (Store (\ _ -> b c)) c
02:03:20 * hackagebot abstract-deque 0.1.5 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.1.5 (RyanNewton)
02:08:20 * hackagebot crypto-conduit 0.1.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.1.1 (FelipeLessa)
02:24:49 <Blkt> good day everyone
02:51:54 <hoqhuuep> > fmap (replicate 3) (Right "blah")
02:51:55 <lambdabot>   Right ["blah","blah","blah"]
02:52:06 <hoqhuuep> > fmap (replicate 3) (Left "foo")
02:52:07 <lambdabot>   Left "foo"
02:52:48 <hoqhuuep> Can someone explain to me why this isn't "Left ["foo", "foo", "foo"]"?
02:53:19 <mauke> because type error
02:53:41 <aadrake> :t Right
02:53:42 <lambdabot> forall b a. b -> Either a b
02:53:44 <aadrake> :t Left
02:53:45 <lambdabot> forall a b. a -> Either a b
02:53:50 <mauke> :t fmap
02:53:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:54:02 <mauke> f = Either String
02:54:23 <mauke> it's fixed as far as fmap is concerned
02:54:54 <hoqhuuep> Ah, I think I understand now... sort of
02:55:58 <Sgeo> If "left" meant correct instead of right meaning correct, how would Either have been defined, as to make it both memorable and to keep its ease of use as representing errors?
02:57:05 <Sgeo> There's no way to flip type constructors, is there?
03:01:59 <dmwit> Sgeo: No.
03:02:14 <dmwit> Sgeo: However, there are various type-level combinators available, e.g.
03:02:24 <dmwit> newtype Flip f a b = Flip (f b a)
03:02:26 <hoqhuuep> How about this? "type EitherFlip a b = Either b a"
03:03:24 <dmwit> Additionally, there are classes available in libraries like class Bifunctor f where lfmap :: (a -> b) -> (f a c -> f b c); rfmap :: (a -> b) -> (f c a -> f c b)
03:03:55 <dmwit> hoqhuuep: "type"s must always be saturated
03:04:34 <aadrake> Can anyone tell me why decode $ head contentLines :: Result [JSValue] returns "Error unable to read list"
03:04:39 <dmwit> hoqhuuep: (Which is a bit odd from some perspectives, since this means in particular that something like type Apply f a = f a and type Apply' f = f are not the same.)
03:04:40 <hoqhuuep> dmwit: sorry but I don't understand, what does 'saturated' mean in this context?
03:04:48 <dmwit> hoqhuuep: All the arguments must always appear.
03:05:10 <aadrake> Using Result JSValue works just fine
03:05:19 <dmwit> hoqhuuep: So, for example, you wouldn't be allowed to write "instance Functor (EitherFlip b) where ...", because EitherFlip hasn't been given both arguments.
03:06:25 <hoqhuuep> Because it becomes "Either <unknown> b" ?
03:06:29 <dmwit> newtype does not have the same restriction, however, so "instance Functor (Flip Either b) where ..." would be fine.
03:06:39 <aadrake> That question is related to the Text.JSON library by the way.
03:07:07 <hoqhuuep> Hmm, OK. I haven't got up to "newtype" yet ;-)
03:07:20 <dmwit> hoqhuuep: Hm. Well, the level-0 reason is because the spec doesn't allow it. But the reason the spec doesn't allow it is because type-level lambdas make type-inference hard (undecidable, I think).
03:08:01 <dmwit> As you say, you could interpret "EitherFlip b" as "Either <unknown> b", or, in more familiar syntax, "\a -> Either a b".
03:08:33 <hoqhuuep> I see
03:08:45 <dmwit> The reason newtypes don't make inference hard is because there are hints given to the compiler whenever the newtype's constructor appears.
03:22:19 <hoqhuuep> Not sure I fully understand yet, but I'm sure it'll become clearer as I read more... Thanks for the help! Good night.
03:23:20 * hackagebot hakyll 3.2.4.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.4.0 (JasperVanDerJeugt)
03:34:44 <Peaker> a bit annoying that the stdlib stuff regarding processes is String-based and not ByteString based
03:36:23 <Peaker> I want this as a cabal lib: http://community.haskell.org/~simonmar/unix-with-bytestring-extras/
03:39:27 <alpounet> Peaker, isn't there any package for this on hackage ?
03:39:35 <alpounet> pretty sure i saw one
03:39:51 <Peaker> alpounet: there's unix-bytestring has virtually nothing
03:41:38 <dmwit> Peaker: Coming soon to a compiler near you!
03:41:42 <dmwit> Also, Hackage.
03:41:44 <dmwit> I think.
03:42:17 <dmwit> (There was quite a kerfluffle on the mailing list recently... maybe a month ago now?)
03:42:56 <aadrake> I think I remember an example somewhere that showed how to replace text within a string.  For example, replacing \n with , or something.  Does that sound familiar to anyone?
03:46:38 <Peaker> dmwit: for now I'm duplicating process code into my own process-bytestring package
03:47:10 <Peaker> dmwit: not sure why he didn't spend a few minutes uploading to hackage after doing all that work :(
03:47:43 <Peaker> JaffaCake: maybe you could upload unix-with-bytestring-extras to hackage?
03:50:42 <tsousa> do you guys think that Haskell has some kind of a future in the programming world without beeing only research ?
03:51:51 <irene-knapp> yes, but it's not clear to me whether that's even a desirable thing
03:52:53 <tsousa> irene-knapp, why?
03:53:09 <irene-knapp> tsousa: well, it comes with a lot of baggage, like having to stay backward-compatible for example :)
03:53:31 <irene-knapp> and it's not like the world, or even the world of programming languages, is meant to be a popularity contest
03:55:05 <tsousa> the syntax of Haskell is a bit weird and you have to think a lot more to do simple things
03:55:14 <tsousa> that you did in an imperative language
03:55:26 <irene-knapp> until you get used to it, yes, but what does that have to do with the topic?
03:55:27 <aadrake> tsousa: I'm learning Haskell for 3 general reasons.  1) It's cool and I like it.  2) It has good parallelism and concurrency support which is important to me because I do a lot data analysis on very large files.  3) I think that the functional paradigm will become increasingly popular as a way to take advantage of advances in processor architecture.
03:56:16 <aadrake> tsousa: I'd say number 3 is closely aligned with your question.  I think it will become more popular in industry.
03:56:43 <irene-knapp> I mean, it's not true that weird syntax is /objectively/ harder
03:56:52 <irene-knapp> because "weird" is relative to what you already know, right
03:57:04 <irene-knapp> if everyone learned Haskell as a first language, Java would be the weird one
03:57:15 <irene-knapp> it may be that Haskell is conceptually more complex than Java, but that isn't what you said
03:57:36 <tsousa> irene-knapp, i did say that, i did say that the sintax is a bit weird, and i have to think more me Haskell because the variables are immutable that stuf like that
03:58:03 <irene-knapp> okay, so you were saying that things like immutable variables and maybe even monads are conceptual overhead which doesn't exist in other languages
03:58:24 <irene-knapp> may or may not be the case that they would still seem "weird" to people who learned them first - there's no way to test that, really
03:58:30 <aadrake> tsousa: I agree with the having to think more part.  I've been spending two days trying to figure out the best way to do some stuff with a JSON file because I have to consider immutable variables, types, etc.  In Ruby I would just throw it in a string and do what amounds to fancy regex with looping.
03:58:36 <muep> tsousa: why does immutability inherently cause need to think more?
03:58:38 <irene-knapp> but accepting that it is the case,
03:58:58 <irene-knapp> it might or might not hurt adoption, you know?
03:59:00 <irene-knapp> it might help adoption!
03:59:25 <irene-knapp> for example, managers might (correctly imo) believe that the complexity acts as a filter so that if they are hiring someone with Haskell experience, they know they're hiring someone competent
03:59:36 <irene-knapp> which is not the case when hiring, say, someone billing herself as a PHP programmer
04:00:20 <tsousa> but there is highly capable php programming that never learned Haskell
04:00:29 <irene-knapp> there are, yes
04:00:37 <irene-knapp> but it's difficult when hiring them to determine that
04:00:43 <irene-knapp> not impossible, but hard
04:01:00 <mokus> the difference isn't whether some are competent, the issue is whether many are incompetent
04:01:11 <irene-knapp> because PHP doesn't have these barriers to entry, anyone can call herself a PHP programmer and not be challenged on it
04:01:15 <mokus> it's harder to get by in Haskell without actually 'getting it'
04:01:25 <irene-knapp> yes, thank you mokus :)
04:01:25 <aadrake> tsousa: I agree with Irene that knowledge of Haskell can act as a filter.  It demonstrates various skills like problem solving, critical thinking, attention to detail, etc.
04:01:32 <tsousa> well companys instead of hiring only for where they did college they should make some hard challenges
04:01:42 <irene-knapp> tsousa: Oh I agree!
04:01:57 <irene-knapp> tsousa: I don't hold a college degree myself, and I really strongly question the value of them :)
04:02:12 <arw> aadrake: or fingering the code until the compiler doesn't complain anymore.
04:02:21 <irene-knapp> arw: haha that too
04:02:44 <arw> that is a lot more viable in haskell than in other languages.
04:02:45 <tsousa> well thanks to all :)
04:02:53 <irene-knapp> tsousa: anyway, yeah, those are my views on it.  you're welcome :)
04:02:57 <aadrake> arw: I think that would be possible for someone who has "some experience" with Haskell, but not for someone who would be considered productive with the language.
04:03:21 * hackagebot zeromq3-haskell 0.1 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.1 (ToralfWittner)
04:03:53 <mokus> aadrake: it does force them to actually spend time playing with the code, though, which is how you get better ;)
04:05:23 <aadrake> arw: At this point I'm spending (probably) over 90% of my time figuring out types and getting used to the type system in general.  So for me there is a lot of time spent running code to try to figure out why it doesn't work
04:06:16 <aadrake> mokus: Indeed, but I think it is generally accepted that getting better with Haskell is a much longer process than something like PHP or Ruby
04:06:28 <aadrake> mokus: One can be productive with those language fairly quickly by comparison.
04:06:38 <mokus> yes, that's definitely true
04:06:57 <arw> aadrake: thats true if one already knows an imperative language
04:07:03 <mokus> i tend to think it has a lot to do with availability of libs to do "cool stuff" though
04:08:05 <mokus> arw: i think to some extent imperative programming really is "more natural" - we spend 10-20 years learning to think about doing things one after another, mutating the state of our little corner of an imperative universe, before we start thinking about how to teach a computer some of our tricks
04:08:23 <aadrake> arw: So you are saying that someone could solve a given problem equally fast in Ruby or Haskell given that they had no prior programming experience?
04:08:49 <mokus> obviously, since i've spent a lot of time coding Haskell, I think there are other factors that make a difference, but i do think we are trained from birth, if not hard-wired, to think "imperatively"
04:08:51 <arw> aadrake: i'm not sure.
04:09:21 <arw> aadrake: but i think it might be possible.
04:10:36 <arw> mokus: i've seen people learning java without consciously using a single variable or state for the first few weeks of the semester. they just nested variables.
04:11:24 <aadrake> arw: I would say that anyone with a reasonable background in algebra will be able to become productive in an imperative language faster than they would in Haskell.
04:11:34 <aadrake> arw: And by algebra I don't mean abstract algebra
04:11:36 <arw> mokus: when somebody showed them how variables worked they were somewhat stomped. but i don't know if those incidents really translate to them being more functional-thinking.
04:12:11 <arw> s/nested variables/nested functions/
04:13:16 <mokus> arw: i don't know either... i suppose the real question i'd have is whether, when it comes time to actually make the leap to where their thinking is, in a sense, 'turing complete', they find it easier to do so by pushing that tendency further into recursion or they manage to grasp mutability and iteration and realize they're already there
04:13:29 <aadrake> arw: I agree with you, but take a language like R as an example.  The syntax is simple and it's easy to construct programs that consist solely of nested functions.  That doesn't mean that one can pick up Haskell just as easily.
04:13:50 <mokus> almost every R user I know is a cargo-cult programmer
04:13:52 <mcstar> hi, how can i import someting as qualified in ghci?
04:13:59 <drdo> Is there a package with networking stuff for conduit?
04:14:10 <mokus> which makes it hard to say whether they are programming in a functional style of their own accord or not
04:14:30 <aadrake> mokus: I know about cargo cults, but can you tell me what you mean by that?
04:15:19 <mokus> i forget who originally wrote it, but it's from an essay about "kinds of approaches to programming"... the idea for that one is they find some code that does what they want, copy what seems to be the core of it into theirs, and change little bits till it works for their problem
04:15:23 <arw> aadrake: i think its something like "programming by google" or "programming by copy&paste"
04:15:27 <mokus> yea
04:15:46 <mcstar> anyone pls?
04:16:05 <mokus> mcstar: in later versions you can just type an import line at the ghci prompt
04:16:07 <arw> aadrake: if you know the magic incantation it does magic things. without any deeper understanding.
04:16:11 <mokus> not sure when that started though... maybe 7.2
04:16:18 <aadrake> arw: mokus: Got it
04:16:20 <mokus> before that i don't think it was possible
04:16:22 <mcstar> ok, thx
04:17:13 <aadrake> mokus: I have used R extensively, but I came to it from a math background, so it was just a tool for me to do things more quickly because I didn't need to implement algorithms in whatever language.  Also, the integrated plotting is convenient.
04:17:24 <arw> mokus: but I think that approach is also very characteristic for beginners and beginners' languages.
04:18:09 <vikramverma> mokus: :module, no?
04:18:12 <mokus> arw, aadrake: yea, my point is that most R code that comes across my desk is written by people who never go past that stage of just using R as the hammer to do their math
04:18:29 <mokus> vikramverma: yea, but there's no way with :module to do something like 'import qualified Foo as Bar'
04:18:40 <mokus> vikramverma: which i believe is what he was asking
04:18:54 <aadrake> mokus: That's really all that it's for.
04:19:05 <mokus> aadrake: true
04:19:08 <aadrake> mokus: It's not a general-purpose language, at least not in my opinion.
04:19:43 <mokus> i agree, the reason i bring that up is because R was given as an example of how people approach programming
04:20:03 <aadrake> mokus: I provided that example because it's very easy to use nested functions to do everything in R
04:20:03 <arw> you would be surprised how many people and companies use matlab as their implementation language for everything.
04:20:14 <arw> whole factories are controlled by that stuff
04:20:16 <aadrake> arw: I don't really like mablab very much
04:20:22 <aadrake> arw: So are nuclear research facilities
04:20:31 <mokus> yea, i cringe when they bring me matlab code to translate too ;)
04:21:02 <arw> aadrake: i don't either, especially given the shitty code combined with the things that code does.
04:22:03 <mokus> i think R and MATLAB also has a bit of a selection bias toward functional styles too, because a lot of them are translations from the coder's handwritten notes, where they don't reuse variable names because that'd be really confusing
04:22:13 <aadrake> arw: There are good uses for matlab, but like Excel it gets abused.
04:22:32 <mokus> they're already thinking functionally because they're writing math, not code
04:22:41 <aadrake> mokus: There's a big difference between functional style, and wrestling with Haskell :)
04:22:49 <mokus> yes
04:23:20 <mokus> i didn't mean to start a huge discussion with my remarks (though i knew it probably would ;))... just wanted to make the observation
04:23:35 <mokus> i don't have any data to back it up, it just 'seems' true to me ;)
04:24:12 <aadrake> mokus: Learning Haskell is far more difficult for me than any other language I've learned, and I come from a math/CS background.
04:24:20 <aadrake> mokus: It isn't the concepts that are all that difficult, it's the implementation.
04:24:52 <mokus> aadrake: is it the implementation or the fact that the implementation is nothing like any other language you've used before?
04:25:00 <aadrake> mokus: In other words, for me, almost the whole learning curve is due to the type system
04:25:12 <mokus> ah
04:25:23 <mokus> yea, there's a lot to learn there too, even aside from functional/imperative
04:25:51 <mokus> and the fact that Haskell is basically one of a small number of research platforms for type systems certainly doesn't help
04:27:00 <aadrake> mokus: If Haskell had the same type system as something like Ruby or R then it would have only taken a few hours to get productive.  I'm not saying the type system is a bad thing, but it does add a whole (huge) layer of complication.
04:27:03 <mokus> have you used many other typed languages though?  might it just be that you're simultaneously learning the language, the styles, and typed programming in general all at once, which conspires to make the experience much harder than if you were only learning any one of those?
04:27:08 <aadrake> mokus: So just thinking functionally doesn't really help.
04:27:38 <hpaste> Sgeo pasted “Correct use of unsafePerformIO to make a global lock?” at http://hpaste.org/56175
04:27:45 <mokus> aadrake: that wasn't what i was claiming anyway, actually  - just that thinking functionally seems 'less natural' to me than thinking imperatively
04:28:08 <aadrake> mokus: I've used Java, C/C++, and some Python in the past so the concept of types isn't foreign to me.
04:28:25 <mokus> true, but none of those have a type system that's much like haskell's at all
04:28:44 <aadrake> mokus: You just asked if I had used a typed language
04:29:14 <aadrake> mokus: The issue is that Haskell types are a nasty web of confusion.  Especially when dealing with libraries that use their own types.
04:29:38 <plat0> aadrake: can you give a simple explicit example of type confusion?
04:29:39 <aadrake> mokus: It's not like you have to learn a few basic primitives for integers, floats, characters, etc.
04:29:56 <mokus> aadrake: true
04:30:04 <mokus> aadrake: but on the other hand, that's the real power
04:30:13 <arw> c++ imho comes very close, except for type inference of course.
04:30:27 <merijn> aadrake: I disagree with Haskell types being a web of confusion. In haskell types are just used more than in say C or Java
04:31:09 <mokus> aadrake, merijn: would it be more fair to say "haskell types are often used to spin webs of confusion"?  after aadrake's elaboration that's what i think he was getting at
04:31:14 <merijn> In Java/C the type of things hardly tells you anything about their behaviour and doesn't really influence program execution either. In haskell the types are used much more to make decisions
04:31:42 <mokus> because IMO, the type system itself is actually quite elegant and not very complicated, at least if you don't turn on a zillion extensions
04:31:55 <merijn> mokus: Well, no. I don't think they spin webs of confusion. They explain things to me, it's just that you have to learn to interpret them
04:32:35 <mokus> merijn: most of the time, i agree, but i have seen code i would describe as 'spaghetti' at the type level
04:32:49 <aadrake> plat0: Sure, I'm trying to figure out the Text.JSON library.  The file IO is no problem.  However, once I have some string that I want a function to operate on I have to use the 'decode' function to essentially convert it from a String to Result a (Result :: JSValue for example).  Then, I have to look around and figure out which functions can operate on the JSValue type
04:33:01 <merijn> Of course there are some packages that are completely un-understandable, but to be fair I've also found completely ununderstandable Java/C/Python packages
04:33:04 <aadrake> plat0: And it just goes on and on from there
04:33:21 <aadrake> plat0: When all I really want to do is take each string and split out the names of the keys
04:33:47 <Botje> probably you can just pattern match JSValue to its constructors
04:34:03 <plat0> aadrake: That sounds like library organisation is the problem, not the type system
04:34:11 <stulli> Well, type witness was/is a source of confusion for me.
04:34:21 <mokus> merijn: and when you're first learning the type system, i imagine most types beyond kind * elicit the "OMG, this is so confusing" response
04:34:21 <aadrake> plat0: Then there's the JSString type, JSObject type, etc.
04:34:28 <merijn> stulli: Yes, but it's not like every single library uses that
04:35:05 <mokus> merijn: monads, of course, being the biggest example since it's the first non-trivial * -> * concept people generally encounter
04:35:46 <aadrake> The problem is that most libraries I've looked at all implement their own types and therefore in order to be productive with a library you have to know it on a very deep level compared to other languages.
04:35:58 <plat0> aadrake: I see how a plethora of types can be confusing, but I don't understand how this is any different from a Python implementation that would have JSString class, JSObject class etc..
04:36:38 <mokus> aadrake: the nice thing, though, is that you don't actually have to understand the internals of those types to use them, just look at what functions in the library allow you to manipulate those types
04:36:47 <merijn> aadrake: Usually the types are supposed to help you not understand them. In this case (just glanced at Text.Json) the problem is that the library tries to handle the possibility that you're JSON is wrong/etc in the type system
04:36:51 <mokus> aadrake: at least, if the library is well-designed
04:37:27 <merijn> aadrake: The reason you can't "just" get a list of keys is that the JSON you're parsing might not have it. I'd have to look at the docs to see what the best approach is
04:37:56 <mokus> aadrake: it's definitely bewildering for a new user though, i agree completely
04:38:14 <mokus> aadrake: especially when key functionality is provided by highly abstract operations
04:38:34 <aadrake> plat0: Getting JSON parsed in Ruby is as simple as result = JSON.parse(data).  Doing the same thing is more complicated in Haskell.
04:38:48 <aadrake> mokus: It's not so much that it's bewidering as it is time-consuming.
04:38:53 <merijn> aadrake: That's because the JSON.parse in ruby can throw exceptions and result in flaming death
04:39:09 <aadrake> merijn: I didn't say they were equally safe
04:39:09 <mokus> aadrake: fair enough
04:39:45 <mokus> aadrake: i'd argue though, that once you reach a certain level of skill in interpreting types, you start to find that not having types is more time consuming
04:39:46 <merijn> aadrake: Ok, so I just looked. You use the "readJSNull", "readJSBool", etc. functions to create a JSON parser which you can then run on a JSON string using runGetJSON
04:39:48 <Sgeo> The NOINLINE pragma can be placed anywhere, right?
04:40:36 <mokus> aadrake: i can usually find what i need quicker with a call to hoogle or a few :t's than i can by browsing docs
04:40:39 <aadrake> merijn: The problem I have is that I don't know beforehand what keys will be in the records, so it is impossible for me to create my own structure for a JSON record beforehand.
04:40:40 <merijn> aadrake: The library looks fairly straightforward, I guess the problem is that it's implemented as a JSON monad and I suspect that you're new to haskell and not that familiar with how to use monads?
04:41:42 <mokus> aadrake: but, i only get there by having at least skimmed the docs before, and by being able to look at the types and function names and make an educated guess about which of the features i've read about that they correspond to
04:42:15 <aadrake> merijn: You are correct that I do not have a thorough understanding of monads.
04:42:52 <aadrake> merijn: I am not convinced that is the contributing factor in this case.
04:43:05 <Saizan> does this json library have a JSONObject type?
04:43:28 <aadrake> It has JSObject
04:43:41 <Saizan> if it does that would be a fair type to use when you don't know the shape of what you're parsing
04:44:09 <Saizan> i.e. when you don't know which keys to expect
04:44:50 <aadrake> Saizan: In this case I don't care what the keys are, I just want to construct a list of all keys in the file
04:45:06 <Saizan> aadrake: which library is this?
04:45:06 <plat0> aadrake: the equivalent of JSON.parse(data).  Doing the same thing is more complicated in  Haskell.
04:45:09 <plat0> Oops
04:45:15 <merijn> Saizan: Text.JSON
04:45:16 <aadrake> Saizan: Text.JSON
04:45:23 <plat0> the equivalent of JSON.parse(data) seems to be "Text.JSON.decode data"
04:45:28 <Saizan> that's not a package name :P
04:45:45 <plat0> I guess it's walking the structure that you're having problems with.
04:45:46 <aadrake> Saizan: json
04:46:19 <aadrake> plat0: Well, considering that the structure is not consistent I can't really define it beforehand
04:46:29 <plat0> aadrake: can you share a sample of the JSON and the desired output?
04:46:33 <Sgeo> {-# OPTIONS_GHC -fno-cse -fno-full-laziness #-}
04:46:44 <Sgeo> Is this correct for a module that uses unsafePerformIO to make a global variable?
04:47:03 <merijn> aadrake: To get back to your types complicating things. I've never used this library and glancing the types gives me a fairly good idea of how to use it. But I will agree with you that if you don't fully grok how to use the type system it's probably just very confusing and opaque
04:47:18 <aadrake> plat0: Unfortunately I cannot share a sample of this, but it is completely valid JSON.
04:47:38 <Saizan> aadrake: http://hackage.haskell.org/packages/archive/json/latest/doc/html/Text-JSON.html#v:decJSDict <- this is what you want, i think
04:49:11 <plat0> Well are you trying to do something like parse '{ k1: "A", k2: {k3: "B", k4: 3}, k5: [4.0, "D"] }' and get ["k1", "k2", "k3", "k4", "k5"]?
04:49:13 <Saizan> aadrake: note that String is an instance of JSKey
04:50:44 <Saizan> btw, if you're dealing with lots of data you might want to look for a library which uses a more compact way to store strings
04:52:28 <plat0> Is there a good reason this library uses Result rather than Either?
04:52:35 <aadrake> Saizan: Basically, yes, but that requires type JSObject.  If I take a line from the file and try to decode it (decode jsonLine :: Result JSObject) I get an error about type problems.
04:52:46 <mokus> probably because Either has about 3 different orphan monad instances
04:53:05 <aadrake> plat0: Yes, precisely that.
04:53:09 <Saizan> aadrake: that requires JSValue, actually
04:53:25 <Saizan> aadrake: and what type problems do you get?
04:53:25 <aadrake> Saizan: You are right, my mistake
04:54:22 <plat0> aadrake: With the recursion on sub-objects, or just ["k1", "k2", "k5
04:54:26 <plat0> ]?
04:54:35 <ddarius> There's a JSON category and the json package is not in it.
04:56:13 <aadrake> Saizan: So Let's say I use decode jsonLine :: Result JSValue, the result of that has type Result JSValue (not just JSValue).
04:56:28 <aadrake> plat0: Yes, with recursion on sub-objects
04:56:33 <plat0> aadrake: ok
04:56:47 <Saizan> aadrake: right, you've to pattern match on Result to check if the parsing succeeded
04:57:01 <Saizan> aadrake: or you can stick into the Result monad
04:57:07 <plat0> 'decJSDict "" jsval where Ok jsval = decode jsonLine' will be a good start.
04:57:38 <aadrake> Saizan: Well then that is where my lack of monad knowledge impedes me.  :)
04:57:53 <ddarius> No knowledge of monads is needed.  Just pattern match.
04:58:11 <ddarius> plat0: That would be a bad start.
04:59:36 <Saizan> knowledge of monads make the recursion on the JSValue nicer
05:00:44 <ddarius> I don't see how, particularly with the Result monad.  Once the value is successfully parsed, Result no longer matters.
05:00:57 <ddarius> At that point it is a straightforward tree recursion.
05:01:31 <Saizan> aadrake: anyhow, as a start: case decode jsonLine of Error msg -> Error msg; Ok jvalue -> decJSDict "usedfordebugging" jvalue :: Result [(String, JSValue)]
05:01:52 <Saizan> ddarius: decJSDict is in the Result monad too
05:03:42 <ddarius> Why wouldn't I just use from JSObject?
05:04:53 <Saizan> yeah, that's probably better
05:05:33 <Peaker> Is there a recommended replacement for Parsec?
05:05:47 <Peaker> iirc, edward was working on one?
05:06:28 <aadrake> Saizan: I'm working on it now.  I'll let you know if I come up with something :)
05:07:10 <irene-knapp> whoa
05:07:15 <irene-knapp> I have a use for ImpredicativeTypes, apparently
05:07:19 <irene-knapp> but I don't know what it is! :/
05:11:40 <plat0> ddarius: Why would my example be a bad start?
05:12:13 <ddarius> Because one shouldn't blithely ignore error cases.
05:12:20 <plat0> I see.
05:13:17 <ddarius> Also, why is everyone using decJSDict?
05:13:21 <Saizan> aadrake: http://hpaste.org/56176
05:13:44 <plat0> Are you asking because decJSDict doesn't do recursion?
05:13:51 <Saizan> ddarius: my fault, that's what i found when skimming the docs
05:14:00 <ddarius> I'm asking because I don't understand why that function even exists.
05:14:21 <ddarius> Saizan: Now you need to decide whether you should recurse into arrays, though that is a minor change.
05:14:40 <dumiopky> is there a function to remove an element from a list?
05:14:42 <ddarius> But yes, the end result should be about three lines of code.
05:16:37 <plat0> You don't understand why it exists why?
05:17:11 <donri> dumiopky: tail?
05:17:25 <ddarius> donri: monochrom would be proud of you.
05:17:46 <donri> dumiopky: or init, but why do you think you want this?
05:17:49 <plat0> Anyway, perhaps aadrake is getting bitten by the monomorphism restriction, and in that case confusion is perfectly understandable.
05:17:50 <donri> ddarius: oh?
05:18:02 <dumiopky> likes i have to remove all multiple of 2,3,7,9 in a very big list
05:18:18 <donri> dumiopky: filter
05:18:47 <mokus> also you can ignore 9, multples of 9 are multples of 3
05:19:33 <Saizan> aadrake: probably better http://hpaste.org/56177
05:20:00 <dumiopky> yes
05:25:47 <aadrake> Saizan: Thanks, working on it now.
05:28:37 <etpace> Bit of a vague question, but: If I have some analysis/inference function (for example, type inference) - how does one handle mutually recursive groups (letrecs)? I know in the special case of HM I can put a fresh variable and unify afterwards, but is there a more general method?
05:29:09 <etpace> The analysis im using at the moment I don't think extends to the fresh and unify, although perhaps I could make use of a "notyetknown" and look for a fixed point?
05:29:26 <aadrake> Saizan: What do you think would be the easiest way to grow the set of keys without having duplicates?  I'm guessing Data.Set is overkill, right?
05:30:52 <Saizan> aadrake: sounds like the easiert route to me
05:30:56 <Saizan> *easiest
05:31:01 <mokus> personally I'd go with Data.Set and then if it turns out to be a bottleneck, fix it
05:31:06 <Sgeo> With data-lens, how can define a new record with all fields set without writing RecordType { _x = blah, _y = foo } etc?
05:32:54 <Saizan> aadrake: you'd just have to change concatMap keys with (unions . map keys), iirc
05:33:54 <aninhumer> Hmm, I just tried > (300 % 25) == 12 in ghci and it pegged the CPU for about a minute before I interrupted it...
05:34:05 <aninhumer> lambdabot managed fine
05:34:37 <dmwit> what.
05:35:00 <dmwit> aninhumer: could not reproduce
05:35:17 <plat0> What's % in this case?
05:35:20 <Saizan> Sgeo: unless you have strict fields you could use RecordType {} to build an empty RecordType value and then use setL for each field
05:35:27 <aninhumer> Apparently I'm on version 7.0.3
05:35:32 <dmwit> plat0: Division for ratios. import Data.Ratio
05:35:33 <aninhumer> plat0: Data.Ratio
05:35:50 <dmwit> plat0: (Actually, conversion from numerator/denominator to ratio, not division for ratios.)
05:35:51 <akosch> can I somehow get the width for an individual glyph from the SDL TTF bindings? I want to wrap text and I need it for calculating the 'width' of a string.
05:35:57 <mauke> dmwit: that would be /
05:36:00 <dmwit> yes
05:36:05 <dmwit> I realized my mistake. =P
05:36:05 <Skola> I have installed some modules through cabal, but I cannot load them in ghci (or I'm doing it wrong)
05:36:38 <Saizan> Skola: what are you doing exactly?
05:36:54 <dmwit> akosch: I'm not sure of the answer to your question about single glyphs, but the width of a string is not necessarily just the sum of the widths of the glyphs, is it?
05:36:58 <dmwit> Thanks to kerning and friends.
05:37:00 <Saizan> Skola: i.e. paste the commands, if more than one line use hpaste.org
05:37:26 <akosch> dmwit: why shouldn't it be?
05:37:41 <dmwit> akosch: 09:18 < dmwit> Thanks to kerning and friends.
05:37:46 <aninhumer> dmwit: ah, I think I overloaded % by accident earlier in the session
05:37:49 <aninhumer> nevermind
05:38:01 <Skola> command-line: cabal install Data.List.Split ghci: > :i Data.List.Split
05:38:02 <akosch> dmwit: SDL does that?
05:38:10 <dmwit> How should I know?
05:38:28 <byorgey> Skola: you want 'cabal install split'
05:38:38 <Skola> sorry I did do that
05:38:38 <dmwit> Googling "sdl kerning" seems to indicate that kerning can be turned off. So... yes?
05:38:43 <byorgey> Skola: 'split' is the name of the package; Data.List.Split is a module provided by that package
05:38:56 <Saizan> Skola: also you want "import Data.List.Split"
05:38:56 <byorgey> Skola: so now you want  :m +Data.List.Split
05:39:01 <Saizan> or that
05:39:02 <byorgey> :i is something else
05:39:38 <Skola> <no location info>:
05:39:39 <Skola>     Could not find module `Data.Lists.Split':
05:39:49 <ddarius> sigh
05:39:49 <byorgey> you have an extra s on the end of List
05:40:09 <akosch> dmwit: hm, I haven't seen it around in the binding though. Anyway, I only need an approximate, but somewhat better that just a fix glyph size based on font-size
05:40:31 <Skola> sorry for my sloppiness
05:40:45 <Skola> Data.List.Split doesn't work either though
05:41:38 <dmwit> akosch: http://forums.libsdl.org/viewtopic.php?p=9830&sid=3d7079dda7ec09258310ad6e1288d4e6 suggests calling TTF_GlyphMetrics().
05:41:44 <dmwit> Is there an equivalent in the Haskell binding?
05:41:48 <Saizan> Skola: which error do you get?
05:42:09 <Skola> Could not find module `Data.List.Split':
05:42:42 <Saizan> Skola: what does "ghc-pkg list split" says? you've to run it outside of ghci
05:43:02 <akosch> dmwit: I don't think so, sadly...
05:43:07 <dmwit> akosch: Probably the only really right thing to do is create a pango-sdl package. =)
05:43:26 <Skola>  % ghc-pkg list split
05:43:28 <Skola> /var/lib/ghc-7.0.3/package.conf.d
05:43:34 <dmwit> akosch: (There is already a pango library, but I'm not sure you can use it with SDL at all.)
05:43:46 <dmwit> s/library/package/ of course
05:44:08 <akosch> dmwit: yes, I agree. Still I would say it's out of the scope of my current efforts :)
05:44:29 <akosch> dmwit: I think it's time to use a monospaced font
05:44:32 <Skola> can I add that dir to the path ghci uses?
05:44:39 <Saizan> Skola: just that? so it seems the split package didn't get installed, try "cabal install split" again and make sure it completes successfully, then restart ghci and try "import Data.List.Split⇧" again
05:44:48 <mauke> Skola: what dir?
05:44:58 <Saizan> sigh, without the ⇧
05:45:23 <Saizan> Skola: that directory is not where split was found, it's just the directory where the registry of packages is kept
05:45:24 <plat0> Saizan: getting bitten by urxvt, like me?
05:45:54 <Saizan> Skola: the fact that ghc-pkg list didn't show something like "split-x.y.z" means that it wasn't found
05:46:01 <Saizan> plat0: yeah
05:46:25 <Saizan> plat0: is there a way to disable those things?
05:47:06 <Skola> if I cabal install it without sudo, the install fails
05:47:10 <Skola> cabal: ghc-pkg: /home/bas/.ghc/x86_64-linux-7.0.3/package.conf.d:
05:47:11 <Skola> createDirectory: permission denied (Permission denied)
05:47:27 <plat0> Saizan: I've been wondering the same thing.
05:48:06 <byorgey> Skola: probably because you cabal-installed with sudo in the past (which you should not do)
05:48:30 <byorgey> Skola: just go look in .ghc/x86_64-linux-7.0.3  and make sure nothing is owned by root
05:48:36 <dgpratt> are there any caveats I should know about before installing a package from sources (git) instead of Hackage?
05:48:42 <byorgey> I mean, change anything which is owned by root to be owned by you
05:48:44 <mrcarrot> Skola: suda rm -R .ghc .cabal
05:48:48 <mrcarrot> Skola: then try over again
05:49:06 <Saizan> Skola: never use "sudo cabal install", only use "cabal install --root-cmd=sudo"
05:49:20 <Saizan> Skola: but only if you also use --global, which you generally shouldn't
05:49:24 <byorgey> mrcarrot: I doubt that is necessary in this case.
05:49:29 <Skola> ok
05:49:44 <Saizan> rm -fr ~/.cabal is never necessary, anyhow
05:50:09 <Saizan> except in this case maybe :)
05:51:20 <byorgey> yeah, the only reason I can think of for deleting .cabal is if the permissions get screwed up and you don't want to fix them yourself
05:51:56 <dmwit> Skola: (Likely what happened is you installed split into root's user-specific package repository. So it installed successfully, but only root gets to use it. =)
05:52:12 <Skola> yeah dmwit, it seems to be the case
05:52:40 <Skola> I have chmodded/chowned the ghc folders and now it works : )
05:52:46 <dmwit> excellent =)
05:52:59 <Skola> thanks byorgey, Saizan, mrcarrot, dmwit ;}}
05:54:34 <plat0> or
05:54:41 <plat0> or
05:57:58 <aadrake> Saizan: Almost done, just need to make a few small modifications to operate on a list of records and to use Data.Set
05:59:56 <Saizan> aadrake: good :), feel free to  ask if you get stuck
06:01:43 <funktronic> not sure if this is the appropriate place, but my leksah crashes pretty much immediately.. on os x lion. any ideas ?
06:03:19 <Sgeo> I see some libraries based on dealing with events
06:03:21 <Sgeo> Any of them any good?
06:03:35 <aadrake> Saizan: Not stuck so far, just little hangups like not being allowed to do stuff like lines (readfile "blahblah")
06:03:50 <aadrake> readFile
06:04:42 <Saizan> funktronic: not unappropriate but you might have more luck in #leksah if you are patient or mailing the author
06:04:53 <funktronic> Saizan: thanks
06:05:53 <mm_freak> Sgeo: that's very vague…  what do you want to do?
06:07:26 <dumiopky> is there an easy way of getting the primes numbers?
06:08:30 <Sgeo> mm_freak, provide a wrapper around an event-based API, or an event-based API if it could be made threadsafe
06:08:57 <Sgeo> (e.g. not running an event handler while that event handler is running because the event handler decided to wait for some reason)
06:09:03 <rostayob> dumiopky: yeah, and that's why most encryption methods are based on large prime numbers, or on factorising large numbers
06:09:42 <dumiopky> rostayob, so can you tell me a way to do that
06:09:43 <dumiopky> ?
06:10:00 <rostayob> dumiopky: i was joking, finding out if a very large number is prime is quite hard.
06:10:18 <rostayob> dumiopky: amongst the "easy" ways of finding prime numbers, the nicest is the sieve
06:10:26 <rostayob> http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
06:10:44 <byorgey> @package primes
06:10:44 <lambdabot> http://hackage.haskell.org/package/primes
06:10:52 <byorgey> dumiopky: ^^^ ?
06:11:10 <dumiopky> nubBy(((>1) .) . gcd) [2..] i found this code online
06:11:19 <dumiopky> it is pretty nice but quite hard to read
06:11:28 <byorgey> also not very efficient
06:13:03 <Sgeo> I'm thinking of just making a registerEvent function, and then having say, eventAvatarAdd accept a Chan after it has been registered. Another thread can then read the Chan
06:13:05 <dumiopky> byorgey, that code essencial use gcd 2 <number> in all of the number and then check if it retrives a number >1 right?
06:13:19 <dumiopky> byorgey, i need to find the 10.001 prime number
06:13:21 <Sgeo> Does this make sense, or is involving Chans like this such that the user deals with them an overcomplication?
06:13:29 <byorgey> dumiopky: right, it's just doing trial division
06:13:30 <rostayob> dumiopky: yeah the heavy lifting in that code is done by gcd
06:13:36 <rostayob> but that's really slow
06:13:46 <aadrake> Saizan: Here is a question.  I can't just go using the unions function because it operates on type Set not on List.  So if I have [[String]] how do I go about using unions on that?
06:13:54 <rostayob> you're not exploiting in any way the fact that you're discovering primes and non-primes as you go along
06:14:18 <byorgey> dumiopky: try using the 'primes' package I linked earlier
06:14:31 <aadrake> Saizan: Do I just use the fromList function?
06:14:36 <dumiopky> byorgey, but why the code is not very eficient?
06:14:43 <rostayob> the sieve of eratosthenes works by striking out the multiples of each prime you find
06:14:46 <arw> there is also stuff like probabilistic primality tests which are quite a bit faster. but of course probabilistic, so no definite answer.
06:14:54 <rostayob> dumiopky: because it does a lot of useless computation for each number
06:14:57 <byorgey> dumiopky: because there are much better ways of generating primes than trial division.
06:15:33 <dumiopky> yeh i guess
06:16:32 <Sgeo> Any advice?
06:17:19 <Sgeo> Well, hmm, maybe registerEvent whatever or in fact just eventWhatever should make a new Chan and return it
06:17:22 <Sgeo> That seems simpler
06:17:34 <Sgeo> Well, a tuple of a Chan and a thing to unregister it
06:19:11 <mm_freak> Sgeo: as always, my suggestion is FRP =)
06:19:45 <Sgeo> I'm thinking of adding an FRP layer on top eventually
06:19:53 <Saizan> aadrake: unions :: Ord a => [Set a] -> Set a, so it takes a list of sets
06:20:36 <funktronic> another question, i'm going through learn you a haskell. is it kosher to ask super-newb questions here? coming from F#.
06:20:37 <Saizan> aadrake: but yeah, if you start with a [[String]] i'd go with fromList . concat
06:21:01 <Philonous> funktronic:  Don't ask to ask, just ask away
06:21:05 <rostayob> funktronic: ofc
06:21:08 <rostayob> ask
06:21:21 <rostayob> for some reason really smart people spend a lot of time here! ehe
06:21:47 <funktronic> Philonous: okay. looking at this definition: boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] . confused about what x <- xs does.. oh wait just figured it out
06:22:12 <aadrake> Saizan: I figured it out but I had nested maps and it looked nasty.  I guess I can always refactor.
06:22:30 <funktronic> actually. in ghci is there a way to show the signature of a function or operator ?
06:22:40 <rostayob> funktronic: :t
06:22:42 <Sgeo> funktronic, :t whatever
06:22:51 <Sgeo> For operators, surround it with ()
06:22:54 <Sgeo> :t (+)
06:22:55 <lambdabot> forall a. (Num a) => a -> a -> a
06:23:03 <funktronic> ah excellent, thanks. this helps a lot
06:23:12 <Philonous> funktronic:  That's a list comprehension. What it does is it binds x to all the elements in xs sequentially and then evaluates the part on the left of |
06:23:22 * hackagebot zeromq3-haskell 0.1.1 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.1.1 (ToralfWittner)
06:23:22 <mm_freak> Sgeo: IMO event-based APIs are unfortunate
06:23:41 <Sgeo> mm_freak, I think the model I'm going to expose may be less event-based
06:23:49 <Sgeo> eventChat :: IO (Chan Chat, IO ())
06:24:02 <funktronic> Philonous: i got slighly confused because <- in F# is used for re-assignment of mutable things so i thought "how do you assign 'a list to 'a" but yeah
06:24:02 <Saizan> aadrake: yeah, maybe paste what you have when you're done so that we might catch some refactorings
06:24:20 <Sgeo> mm_freak, unless you don't mean dealing with event handlers, but something else?
06:25:32 <Philonous> funktronic:  It actually gets desugared to regular function. Your's would be equivalent to map (\x -> if x < 10 then"BOOM!" else "BANG!") . filter odd $ xs
06:25:42 <Sgeo> Using Chan like that solves several problems at once, I think.
06:26:26 <funktronic> Philonous: ah that's what i thought.
06:27:25 <Philonous> funktronic:  Btw. the "<-" is overloaded. It's also used in do-blocks and monad comprehensions and means something different there.
06:28:02 <funktronic> Philonous: will figure those out when i get there :) now trying to figure out how to declare a function in ghci
06:28:02 <Philonous> I meaqnt to say overloaded notation. It's not a regular function, just syntax
06:28:07 <Sgeo> do-blocks are similar to ... computational expressions is I think the F# name? Except do doesn't do monoids, just monads.
06:28:27 <Sgeo> funktronic, better to load a .hs file, but you can use let f a = a
06:28:47 <Sgeo> Doesn't work well for some stuff though
06:29:17 <arw> funktronic: write it in a file and :load file.hs. sooner or later you exit ghci and then your work is lost.
06:29:37 <funktronic> Sgeo: do-blocks are still monads right ?
06:29:50 <Sgeo> funktronic, do-blocks are syntactic sugar for using monads.
06:30:16 <hpc> funktronic: "do ..." isn't a monad
06:30:23 <funktronic> yeah that's what computation expressions are in F#.. apparently don syme & co decided that "monad" is too imposing
06:30:25 <hpc> funktronic: nor is the type "IO ()"
06:30:27 <hpc> the monad is IO
06:30:46 <hpc> though that's kind of beside the point
06:31:14 <funktronic> hpc: i got it. syntax sugar for using monads because it's a real hassle to write out the full thing
06:31:32 <hpc> not a huge hassle; just more typing
06:31:35 <Entroacceptor> there are times when using the full form is easier
06:32:57 <Sgeo> getLine >>= putStrLn is easier than do { line <- getLine; putStrLn line}
06:33:04 <Sgeo> Or at least it can be when you get used to it
06:33:06 <arw> more typing and often less friendly to read.
06:33:11 <aadrake> Saizan: I'm may try and move some things around so that the decodeKeys function unions everything as it goes instead of generating a huge set of sets and then taking the union at the end.
06:33:11 <Philonous> funktronic:  Actually it's not. The translation is straight-forward and the "real deal" is not much heavier than do.
06:33:32 <Sgeo> (Actually I might write putStrLn =<< getLine in that case)
06:33:42 <Sgeo> (But taking my advice on Haskell style is a bad idea)
06:33:45 <hpc> i find that (=<<) comes in handy when using the list monad
06:34:13 <hpc> you can write regular code, and use (=<<) as "function application with context"
06:34:27 <Philonous> funktronic:  AFAIK do notation was added to haskell in an attempt to appeal to the imperative programming crowd
06:35:11 <hpc> Sgeo: i think i would too, though not in so trivial a case
06:35:43 <aadrake> Saizan: The nasty line is  case decode (head records) of Error msg -> Error msg; Ok jvalue -> decJS
06:35:50 <hpc> Sgeo: i think i would write (bigAction =<< getInput)
06:36:00 <aadrake> Saizan: paste error
06:36:02 <hpc> for non-trivial and already factored out values of bigAction and getInput
06:36:20 <aadrake> Saizan: The actual bad line is DS.toList $ DS.unions $ map DS.fromList $ map decodeKeys records
06:36:31 <Sgeo> How common is it, inside a do block, to have something like let whatever x y = do
06:36:32 <Sgeo> ?
06:36:51 <hpc> Sgeo: never seen that used
06:36:59 * Sgeo can imagine doing that out of laziness
06:37:49 <Philonous> funktronic:  It's a different story in F#, because they don't have higher-kinded polymorphism,
06:38:30 <hpc> Sgeo: i tend to write nested do-blocks as hanging actions
06:38:34 <hpc> foo = do
06:38:35 <hpc>   bar
06:38:38 <hpc>   baz $ do
06:38:40 <hpc>     quux
06:39:07 <Sgeo> hpc, what about when you have a baz whose type suggests it takes two whatevers?
06:39:11 <dgpratt> well, now I've done it
06:39:15 <hpaste> dgpratt pasted “broken packages” at http://hpaste.org/56178
06:39:15 <Sgeo> Is my main thinking
06:39:17 <Sgeo> Like catch
06:39:19 <hpc> Sgeo: right
06:39:32 <hpc> then it's time to factor stuff out, but i wouldn't use 'let'
06:39:48 <dgpratt> how much fun do I have to look forward to in sorting that mess out?
06:40:00 <hpc> i prefer to have my do-blocks read as much like C code as possible
06:40:21 <hpc> having a big action visually in the middle of a block, and having it not run until later
06:40:24 <hpc> that's confusing
06:40:59 <teneen> > 5 / 0
06:41:00 <lambdabot>   Infinity
06:41:06 <teneen> what's Infinity?
06:41:13 <teneen> is it a constructor?
06:41:16 <hpc> teneen: an IEEE float value
06:41:30 <hpc> not a constructor, just part of the definition of Show
06:41:41 <hpc> > 0 / 0 -- NaN is also in the same boat
06:41:42 <lambdabot>   NaN
06:41:46 <merijn> teneen: Look up IEEE754 floats, otherwise you will end in a world of pain
06:42:14 <teneen> so what does the (/) function actually return?
06:42:20 <hpc> :t (/)
06:42:21 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:42:47 <dgpratt> anyone have any advice on how to fix those broken packages (pasted above)?
06:42:49 <hpc> teneen: it's polymorphic; type defaulting is one of those confusing features; for Fractional, it defaults to Double
06:43:04 <hpc> > 5 / 0 :: Ratio Integer
06:43:05 <lambdabot>   *Exception: Ratio.%: zero denominator
06:43:07 <teneen> Is the 0 case handled as a special case?
06:43:12 <teneen> how does it show "Infinity"
06:43:14 <hpc> > 18 / 6 :: Ratio Integer
06:43:15 <lambdabot>   3 % 1
06:43:27 <hpc> teneen: it just does; read the RFC
06:43:29 <merijn> teneen: Depends on the type it ends up being
06:44:26 <teneen> hpc, merijn: I see, thanks
06:44:30 <merijn> teneen: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html "What every computer scientist should know about floating point arithmetic"
06:44:37 <merijn> And very related
06:44:39 <merijn> @quote double.is.my.friend
06:44:39 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
06:44:39 <lambdabot> will stab you in the back with a mantissa
06:45:18 <teneen> hahaha =D
06:46:15 <merijn> You're laughing now...I've written two types of floating point code: 1) blatantly wrong code and 2) blatantly wrong code which I thought was correct
06:47:16 <hpc> merijn: that's too bad; the only kind of floating point code ive written is code where i don't care about anything beyond 3 decimal places
06:50:18 <merijn> hpc: To be fair I don't write that many floating point code :p
06:51:11 <merijn> And when I do I'm usually ok with anything that's accurate up to 1 order of magnitude :p
06:51:20 <mm_freak> Sgeo: i mean event handlers, whether you implement them as an event type or as callbacks doesn't really matter
06:51:29 <merijn> I prefer fixed width representations usually
06:51:57 <Sgeo> mm_freak, is my type decent?
06:52:12 <Sgeo> Is basically my question, did I get rid of most of the badness
06:53:32 <Peaker> I'm finding myself defining a normal parser and a duplicate skipParser when using Parsec, for the same reason many and skipMany exist...
06:53:57 <hpc> @src many
06:53:57 <lambdabot> Source not found. I feel much better now.
06:54:18 <hpc> Peaker: i would expect there to be a way to write skip* in terms of *
06:54:28 <Peaker> hpc: the problem is the operational semantics
06:54:51 <Peaker> I wish ghc was smart enough to notice a value is always discarded, and so avoid building it up in memory prior to that
06:55:05 <Peaker> (it could require duplicating code, but since ghc doesn't do this, humans duplicate code ala sequence and sequence_)
06:58:01 <funktronic> @src (sum)
06:58:01 <lambdabot> Source not found. Sorry.
06:59:22 <Peaker> in the case of parsec -- they could have the representation of the parser include both a parser and a skipper, and composition could compose both
06:59:24 <merijn> @src sum
06:59:24 <lambdabot> sum = foldl (+) 0
06:59:32 <merijn> funktronic: parenthesis are for operators
06:59:47 <Peaker> then, a combinator could convert a parser to a skipper by copying the skipper into the parser too, and converting the type to ()
07:00:05 <funktronic> merijn: ah, makes sense, i thought it'd do what Peaker said
07:00:25 <funktronic> i gotta say, haskell is quite nice
07:00:54 <funktronic> i really hope i don't decide to port that mini-mountain of F#
07:02:13 <etpace> @pl \k m -> M.insert k 1 m
07:02:14 <lambdabot> flip M.insert 1
07:02:25 <merijn> funktronic: () around an operator makes it prefix whereas `` around a prefix function makes it an operator. I think :t, @src and friends expect the parenthesis around operators for parsing convenience
07:03:12 <funktronic> merijn: what would it look like for operators without parens for :t say ?
07:03:26 <merijn> :t +
07:03:27 <lambdabot> parse error on input `+'
07:03:32 <funktronic> :t (+)
07:03:33 <lambdabot> forall a. (Num a) => a -> a -> a
07:04:18 <merijn> funktronic: Dunno the reason, but as I said, I expect it makes parsing easier. And it's not that big of a hassle when you know it
07:05:36 <jeff_s_> I have a function with a type signature like '(A a) => (a -> b) -> IO ()'. The first time I use the (a->b) function, it seems to fix 'a' to a particular type, so when I pass the function a value with a different type (that is also an instance of 'A'), I get a compiler error, because it's not the same type. Is there a way to avoid this?
07:05:58 <funktronic> merijn: seems that () converts infix into a function. it seems that :t + by itself would be equal to applying :t to + which doesn't make sense. someone correct me if i'm wrong
07:06:29 <etpace> jeff_s_: foo f' = let f = f' in ..
07:06:33 <etpace> that might work?
07:06:45 <etpace> use let polymorphism to generalise the argument
07:06:59 <jeff_s_> etpace: Thanks, I'll try that.
07:08:03 <etpace> > (\f' -> (f' 5, f' "foo")) show
07:08:04 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:08:04 <lambdabot>    arising from the literal ...
07:08:07 <mm_freak> Sgeo: as far as i understand your type it's an action that creates something and returns a corresponding event channel for it
07:08:10 <merijn> funktronic: Well, there's no real "converts infix into a function", both are functions, the only difference is whether its parsed as infix or prefix. And you'd be right, except that ":t" is not part of the language and thus doesn't have to follow the rules of making sense within Haskell, although I guess that it's still allowed to follow the rules
07:08:19 <etpace> > (\f' -> let f = f' in (f 5, f "foo")) show
07:08:19 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:08:20 <lambdabot>    arising from the literal ...
07:08:22 <mm_freak> Sgeo: for a basic low/mid level design that seems reasonable
07:08:31 <mm_freak> Sgeo: you can put other abstractions on top of it
07:08:39 <Sgeo> mm_freak, well, I'm wrapping around a very low level design that uses event handlers
07:09:07 <funktronic> merijn: ah. makes sense.. still figuring out what's part of the language and what's not
07:09:33 <mm_freak> Sgeo: as in callbacks?
07:09:38 <etpace> I guess not
07:10:14 <Sgeo> mm_freak, yes
07:11:00 <mm_freak> Sgeo: in any case getting rid of callbacks is a major step forward, even if you only replace them by an event polling function
07:11:08 <jeff_s_> I'll try to make a minimal example.
07:11:43 <Sgeo> I thought about event polling and discarded it, as such, because I might drop events
07:11:57 <mm_freak> Sgeo: you're doing event polling
07:12:07 <mm_freak> readChan myEventChan  -- polls
07:12:11 <Sgeo> Ah, ok
07:12:28 <Sgeo> By event polling I thought you mean eventWhatever :: IO a
07:12:35 <Sgeo> Where eventWhatever waits for the event to occur once
07:13:01 <mm_freak> no, such a method belongs into a higher level API
07:13:03 <Peaker> Isn't anyone else bothered by the need to have functions and functions_? (sequence/sequence_, many/skipMany, mapM/mapM_, etc)
07:13:23 <Sgeo> mm_freak, I was thinking of exposing this channel stuff
07:13:23 <mm_freak> Peaker: given they do different things, no
07:13:53 <mm_freak> Sgeo: if you plan to put a higher level API around it, that's fine
07:13:58 <Sgeo> mm_freak, :/
07:14:16 <Sgeo> I wasn't really planning to. Maybe provide a convenience function like once, but other than that
07:14:17 <mm_freak> personally i'd expose as much as possible and then wrap things up again, because by not exposing you might risk being less flexible
07:14:37 <merijn> Peaker: many/skipMany maybe, but they are all just shorthand for common operations
07:15:01 <Peaker> mm_freak: how is sequence_ not a special-case of sequence, except for a lacking optimization?
07:15:09 <Sgeo> mm_freak, this chan stuff seems as flexible as exposing directly the event handler API, but doing event-handler like stuff with it would be less efficient
07:15:15 <mm_freak> Peaker: exactly that's the point
07:15:30 <mm_freak> Peaker: by a unified function you would have to write type signatures to point out which variant you want
07:15:34 <merijn> Peaker: It *is* just a special case, but one that's so common it has its own shorthand
07:15:35 <mm_freak> that would be less convenient
07:15:42 <Peaker> mm_freak: GHC already knows when I use sequence with (a=())
07:16:03 <merijn> Peaker: How is it supposed to know that you do not want [()]?
07:16:09 <Peaker> merijn: it's not just a short-hand, it has more operational semantics that are always desirable when the result of sequence is discarded
07:16:15 <merijn> You can say "I never want that!" but what if someone does?
07:16:19 <mm_freak> Peaker: when you write "sequence [putStrLn "abc", putStrLn "def"]" in a do block, you will need a type signature
07:16:24 <Sgeo> mm_freak, should I be worried about that and expose the event-handler stuff, or go for a safety first approach?
07:16:38 <Peaker> mm_freak: Nope, because I'm discarding the result
07:16:48 <Peaker> mm_freak: ghc could know that it need not collect the list in memory since it is discarded
07:17:00 <mm_freak> Sgeo: go for a "reasonable safety first" approach and don't assume that your user is totally stupid
07:17:28 <mm_freak> Sgeo: i frequently complain about the gloss library, because it assumes i'm stupid, rendering it completely useless for any serious application
07:17:44 <merijn> Peaker: This sounds like "sufficiently smart compiler conjecture", which means it's probably not implemented because A) no one figured out a convenient way yet or B) no one cared enough until now
07:18:01 <mm_freak> Peaker: i don't want to count on the compiler there
07:18:19 <Peaker> mm_freak: we count on the compiler countless times in Haskell
07:18:21 <Sgeo> By exposing this Chan API, I'm assuming the user is somewhat too stupid to realize the danger posed by event handlers
07:18:40 <Peaker> mm_freak: there's probably much production code that would stack-overflow if not compiled with -O2
07:18:48 <Peaker> (and newbies are indeed told to use -O2 to avoid stack overflows)
07:18:57 <mm_freak> Sgeo: that fits with the purpose of your library
07:19:03 <Peaker> merijn: I'm not waving my hands at some general smartness here :) I'm talking about a pretty specific optimization
07:19:10 <mm_freak> Peaker: we are counting on the compiler at a different level
07:19:26 <mm_freak> if the compiler is really smart enough to do it, fine, but i don't think it will ever be
07:19:38 <Phlogistique> hi
07:20:11 <Sgeo> mm_freak, but I can imagine situations where I do want the unsafe event handlers. I can do that on top of Chan somewhat easily (a thread in a loop reading the chan then forking etc.), but that's less efficient, I'd think
07:20:12 <Phlogistique> beginner question: I'm transforming a binary tree that represents a left-associative syntax tree
07:20:15 <Phlogistique> to a list
07:20:15 <Peaker> mm_freak: hmm.. maybe I'll open a ghc bug report...  it's a real bummer implementing a _ version of each parser combinator I write
07:20:41 <Phlogistique> so the normal course of operation would be appending to the right of the list at every step
07:20:48 <Phlogistique> now this is clearly inefficient
07:20:48 <Sgeo> My library is inefficient in other ways though, so
07:20:52 <funktronic> is there a best practice on the use of let vs where ? seems that where is just syntax sugar and let is what is is in F#/ocaml
07:20:53 <Phlogistique> how do I avoid that?
07:20:58 <mm_freak> Sgeo: when would you want that?
07:21:11 <mm_freak> funktronic: use the most readable variant
07:21:23 <funktronic> or rather, what does where get compiled to ?
07:21:32 <Sgeo> mm_freak, responding to things people say, and not updating, say, a TVar because of it
07:21:35 <dolio> I don't think knowing whether or not you use the result of something is that trivial a property.
07:21:38 <funktronic> is it a search/replace or is it a let binding ?
07:21:43 <Phlogistique> funktronic: the same as let
07:22:10 <dolio> Unless you mean a very restricted subset of that.
07:22:19 <Sgeo> I shouldn't delay responding to the next person just because I'm doing an expensive operation
07:22:26 <mm_freak> Sgeo: i don't understand…  the event channel approach is really just event handlers, but you do the dispatching manually
07:22:40 <Phlogistique> (I say binary tree but it's really a lisp-style list)
07:23:25 <Phlogistique> so I can restate my question: what's the efficient way to convert a lisp-style list to a haskell-style list? (provided the list is homogenous)
07:23:26 <Sgeo> mm_freak, I'm not saying my use-case is unimplementable with the event channel approach. I'm saying it's less efficient than using the library primitive that I'm wrapping event channels on top of.
07:23:50 <mm_freak> funktronic: 'where' has slightly more flexible scoping, but you can't use it everywhere
07:24:01 <mm_freak> funktronic: for example you can use 'where' bindings in pattern matches
07:24:09 <mm_freak> (guards that is)
07:24:17 <funktronic> mm_freak: i can also say let foo = … and then case foo of for similar effect right ?
07:24:45 <rostayob> Phlogistique: what's wrong with the "naive" flattening? flatten terminal = [terminal]; flatten (Node l r) = flatten l ++ flatten r;
07:24:53 <parcs`> Phlogistique: lisp-style as in (5, (10, (15, ()))) :: (Int, (Int, (Int, ()))) ?
07:24:59 <mm_freak> Sgeo: unless you need a few million FPS or real time responsiveness, i'd still go with channels
07:25:10 <Phlogistique> parcs`: yes
07:25:20 <Phlogistique> rostayob: let me rethink about it for a second
07:25:28 <mm_freak> funktronic: think of guards for a top level function
07:25:48 <Phlogistique> rostayob: yes, the problem is that flatten l is always the longest list
07:25:50 <funktronic> mm_freak: yeah, makes it simpler
07:25:54 <Phlogistique> so it's innefficient
07:26:25 <mm_freak> funktronic: to answer your question…  the best practice in haskell is to write your code as readable as possible
07:26:31 <rostayob> Phlogistique: you could use difference lists to do the traversal once, but i'm not sure it'd help here...
07:26:33 <mm_freak> funktronic: standards would get in your way there
07:26:45 <mm_freak> strict standards that is
07:26:53 <funktronic> mm_freak: true.
07:26:59 <rostayob> Phlogistique: http://www.haskell.org/haskellwiki/Difference_list
07:27:29 <hpaste> “Jeff Shaw” pasted “How to avoid this type error?” at http://hpaste.org/56180
07:27:30 <Phlogistique> parcs`: and no, I actually meant ((((), 5) 3), 4)
07:27:48 <jeff_s_> There's a pretty minimal example of the problem I want to work around.
07:27:54 <rostayob> Phlogistique: yeah difference lists are probably going to help
07:28:04 <mm_freak> funktronic: in other words, just experiment and review your readability
07:28:09 <rostayob> Phlogistique: http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
07:28:19 <aadrake> parcs`: With some help I got that JSON key aggregator written.  The test file I ran it on had 405 distinct keys (which I was really shocked about).
07:30:13 <Phlogistique> ro	thanks
07:30:23 <rostayob> Ph yw :)
07:31:00 <Sgeo> jeff_s_, what's the error?
07:31:40 <Sgeo> But it looks like you want to accept a function that takes a Stringable and turns it into a b
07:31:45 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation)” at http://hpaste.org/56180#a56181
07:32:03 <jeff_s_> Sgeo - I added the error to the link.
07:32:59 <hpaste> funktronic pasted “acc” at http://hpaste.org/56182
07:33:11 <Sgeo> printExamples couldn't figure out if it should be a (String->b)-> String -> Int -> ()
07:33:17 <funktronic> ^ is there a pattern for declaring maxAcc inside maximum' ?
07:33:27 <Sgeo> Or a (Int->b) -> String -> Int -> IO ()
07:33:34 <Sgeo> (First one should have said IO () not ())
07:35:31 <Sgeo> It looks like you're trying to do "printExamples ::((Stringable a, Showable b) => a -> b) -> String -> Int -> IO ()"
07:35:44 <Sgeo> Which looks like it might need an extension, but I'm not sure what
07:35:50 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation)” at http://hpaste.org/56180#a56183
07:36:26 <jeff_s_> Sgeo - I think I fixed the problem you found, which was indeed a mistake. The error remains, however.
07:37:37 <Sgeo> The problem is that it doesn't know that the a->b is supposed to be any function that takes a stringable and gives a whatever
07:38:07 <jeff_s_> Perhaps not, though. I've never seen a type signature like "x :: (A a => a -> b) -> x".
07:38:09 <Sgeo> (Also, I didn't even notice that. I was referring to my commentary)
07:38:24 * hackagebot conduit 0.0.1.1 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.1.1 (MichaelSnoyman)
07:38:55 <Sgeo> jeff_s_, I don't know if there are any extensions in which that type signature is legal, but if not, you probably need to rethink your approach.
07:39:12 <Sgeo> Because that is probably the actual type of the function you wrote
07:39:42 <Sgeo> Try changing the type signature, and see what the compiler says
07:39:50 <Sgeo> It can often guess what extension would be needed.
07:41:17 <jeff_s_> Sgeo - ghc accepts that type signature with the language extension, Rank2Types, but I get the same error.
07:41:39 <Sgeo> After you enable the extension?
07:41:41 <Phlogistique> how do I do the equivalent of regesxp backtracking in Parsec? something like .$foo
07:41:45 <Phlogistique> oops
07:41:46 <jeff_s_> Yup.
07:41:51 <Phlogistique> .*foo
07:42:05 <Sgeo> jeff_s_, just to be sure, hpaste the new code and error?
07:42:09 <hpc> Phlogistique: parsec doesn't backtrack; it stores a list of potential matches
07:42:15 <hpc> Phlogistique: it's basically the same thing
07:42:19 <hpc> afaik
07:43:19 <Phlogistique> hpc: so it will work; then how do I select the shortest (or the longest) match?
07:43:30 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation) (annotation)” at http://hpaste.org/56180#a56184
07:43:34 <hpaste> “acc fixed” pasted “funktronic” at http://hpaste.org/56185
07:43:40 <funktronic> figured it out :)
07:45:24 <Sgeo> jeff_s_, hmm, I'm not sure
07:45:45 <Sgeo> Maybe you need forall a b. in there?
07:46:01 <Sgeo> But now I'm guessing
07:47:37 <jeff_s_> Sgeo - Thanks for helping. But ya, this is a strange problem, eh? Maybe I should try the mailing list.
07:47:58 <Sgeo> I should note that I am NOT a Haskell expert.
07:50:20 <Sgeo> jeff_s_, what happens with (forall a b. (Stringable a, Showable b) => a -> b) -> String -> Int -> IO ()
07:50:31 <Sgeo> (I'm not sure exactly where the forall goes
07:50:38 <jeff_s_> Sgeo - your idea to add forall a b. might give us a hint of what's going on, though, because the error changed. I think maybe there's something going on where ghc is trying to unify the (Show a => a) and String types.
07:50:53 <Sgeo> What's the new error?
07:50:56 <jeff_s_> One sec, I'll paste teh change.
07:51:20 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/56180#a56186
07:53:02 <jeff_s_> If I use "forall b." instead of "forall a b.", I get the original error.
07:53:39 <Sgeo> Try getting rid of the b and replacing with String
07:54:02 <Sgeo> Because currently the function expects a function that can turn a Stringable into any Show
07:54:07 <Sgeo> I think.
07:54:11 <Sgeo> Better yet:
07:54:18 <jeff_s_> "parse error on input `String'"
07:54:18 <Sgeo> Move the Show b in front
07:54:20 <Sgeo> Like this
07:54:46 <Sgeo> printExamples :: (Show b) => (forall a. (Stringable a) => (a -> b)) -> String -> Int -> IO ()
07:55:31 <Sgeo> This way, printExamples can take a function that takes any Stringable and turns it into a fixed Showable
07:55:38 <jeff_s_> Woah, Sgeo - that works.
07:55:48 <jeff_s_> at least, it compiles.
07:55:49 <Sgeo> Insteading of requiring that the argument can turn any Stringable into any Showable
07:57:09 <Sgeo> jeff_s_, do you understand why the type is what it is?
07:57:11 <byorgey> jeff_s_: if a function with a type signature like that compiles, it probably does work =)
07:57:27 * Sgeo learned a lot from this :D
07:57:30 <Phlogistique> let(s try again: I want to express in Parsec the grammar equivalent in regex to non-greedy repetition; how do I do that?
07:58:07 <Phlogistique> manyTill is insufficient because I can't express the parser 'whatver follows'
08:00:26 <Phlogistique> if I got for exemple let { a = b >> c; b = manyTill d (try e) >> e } in a it won't work because e is optional
08:00:34 <jeff_s_> Sorry, my grandpa showed up, so I had to stop looking at this discussion for a while..
08:02:50 <byorgey> jeff_s_: no worries, grandpas are more important than Haskell
08:02:59 <jeff_s_> Blasphemer!
08:03:43 * byorgey was actually serious
08:05:47 <Sgeo> Is RankNTypes controversial?
08:06:00 <hpc> Sgeo: nope
08:06:08 <hpc> it's quite useful, even
08:06:11 <hpc> :t runST
08:06:12 <lambdabot> forall a. (forall s. ST s a) -> a
08:06:19 <Sgeo> That's Rank2Types, isn't it?
08:06:32 <hpc> sure, but the two are equivilent
08:06:49 <hpc> RankNTypes just cuts back on the crap you have to deal with to get rank 3 and up
08:07:20 <hpc> with rank 2 types, you need to make more data types for each level up you go
08:08:43 <byorgey> isn't there also a difference re: type inference?
08:09:05 <hpc> probably
08:09:09 <byorgey> IIRC type inference is decidable for rank 2 but not for higher ranks
08:09:17 <byorgey> not sure if it makes a practical difference though
08:09:40 <hpc> i wouldn't use inferred higher rank types anyway
08:09:47 <hpc> just as a general readability rule
08:09:48 <byorgey> true, me either
08:11:40 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/56180#a56188
08:12:09 <Sgeo> Congratulations!
08:12:30 <jeff_s_> I pasted the working version. I can't say I understand why it works. It must have something to do with the scoping of the type classes, but even then, there is that "forall a.", which I don't understand why it's required.
08:12:49 <Sgeo> jeff_s_, ok
08:13:05 <Sgeo> Let's ignore the Show b => for now, and pretend that in place of b, we have String
08:13:16 <Sgeo> (forall a. (Stringable a) => (a -> String))
08:13:27 <Sgeo> This, essentially, is the type of toString
08:14:19 <jeff_s_> Why does it fail to work when there is no explicit "forall a."? I thought it was implicit.
08:14:38 <Sgeo> It's usually implicit, but I guess with the way Rank2Types/RankNTypes work, it needs to be explicit?
08:14:54 <monochrom> "printExamples :: (Stringable a, Show b) => (a -> b) -> String -> Int -> IO ()" means the user of printExamples chooses a and b. the user is me. I may choose a=(), b=Bool. that won't work for you, will it?
08:15:23 <byorgey> jeff_s_: if you let the forall be implicit, it will go at the very beginning of the entire type
08:15:27 <jeff_s_> No, because I didn't write instances for those.
08:15:33 <byorgey> jeff_s_: in this case you want the forall somewhere else, so you must write it explicitly
08:16:01 <monochrom> "printExamples :: (Show b) => (forall a. (Stringable a) => (a -> b)) -> String -> Int -> IO ()" means printExamples's author (that's you) choose a. so you can choose a=String and a=Int. me the user can't object to it.
08:16:11 <jeff_s_> byorgey: Oh I see, very interesting.
08:17:13 <byorgey> in other words, "printExamples :: (Show b) => (forall a. (Stringable a) => (a -> b)) -> String -> Int -> IO ()"  means the user of printExamples must provide a way to convert ANY Stringable into a b.
08:17:55 <byorgey> whereas with "printExamples :: (Stringable a, Show b) => (a -> b) -> String -> Int -> IO ()" they need only provide a way to convert some *particular* Stringable (which they get to choose) into a b.
08:19:12 <akosch> `n' is a rigid type variable: what does this mean?
08:19:25 <jeff_s_> Thank you monochrom and byorgey, I'll keep thinking about what you've said.
08:20:29 <byorgey> akosch: it means  n  stands for an abstract type which may not unify with anything other than itself
08:20:43 <byorgey> akosch: it's basically an artifact of the type inference algorithm.
08:21:00 <byorgey> akosch: if you give us more information (i.e. your code and the full error message) we can probably help you figure out what is wrong.
08:23:52 <dgpratt> so it seems that the cause of my broken packages is that
08:24:03 <dgpratt> ...\
08:24:05 <akosch> byorgey: http://hpaste.org/56189
08:24:13 <monochrom> oleg explains rigid type variable at http://www.mail-archive.com/haskell-cafe@haskell.org/msg96108.html
08:24:48 <akosch> byorgey: I'm trying to do the following. handleControlEvent accepts a controller c and an event producing the succeeding controller
08:24:56 <akosch> byorgey: which is n
08:24:59 <dgpratt> ...EclipseFP installed yesod via --global, but some of the packages yesod depends on are installed at the user level
08:25:39 <monochrom> yikes, "the constant--variable duality of eigen-variables" hahaha
08:25:42 <dgpratt> so should I try to move the global packages to the user level or vice versa? or...?
08:25:49 <akosch> byorgey: I'm probably doing something wrong, this is my first attempt at writing a class
08:29:11 <jeff_s_> I have another puzzle, but I mostly solved it myself! My question was, instead of Int and String as arguments to printExample, what if I want the types to be anything? I found that the solution was pretty easy, but I have to fix the type of 0 manually. I'll paste the error.
08:29:22 <monochrom> dgpratt, it is really up to you.
08:29:47 <dgpratt> monochrom: ok
08:29:47 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/56180#a56190
08:30:09 <jeff_s_> The solution was to replace "0" with "(0 :: Int)".
08:30:30 <monochrom> Show b => (forall a. Stringable a => a -> b) -> c -> IO ()
08:31:37 <Guest80544> Hi guys am new to Haskell..
08:31:40 <monochrom> 0 is polymorphic, understandably
08:31:44 <dgpratt> are there any packages that really should be installed at the global level?
08:31:53 <Guest80544> can you show me a better way to learn this language?
08:31:53 <jeff_s_> monochrome - if I don't include (Stringable c) on the front, along with Show b, it doesn't type check.
08:32:11 <dgpratt> Guest80544: better than what?
08:32:21 <monochrom> packages that come with GHC really should be global.
08:32:28 <dgpratt> monochrom: ok
08:32:47 <Guest80544> as in book or tutorials?
08:32:56 <dgpratt> @where lyah
08:32:56 <lambdabot> http://www.learnyouahaskell.com/
08:33:13 <Guest80544> cool thanks
08:33:25 <jeff_s_> http://book.realworldhaskell.org/read/
08:34:15 <monochrom> if you set up barriers so that modifying global is hard and modifying user is easy, you can say: carefully chosen highly stable packages go to global, stuff in flux go to user. but apparently you don't have such barrier.
08:34:30 <akosch> I suspect what is wrong: in an instance definition to my Controller class I try to return the same type I'm defining the instance for (which has the type constraint of Controller)? can I do that? I mean refer to a type as instance of a class inside the definition of the instance for the same class (and type)?
08:34:44 <jeff_s_> My battery is going to run out soon. Thanks everyone for the great conversation!!
08:34:54 <dgpratt> Guest80544: RWH is very good also, but the consensus seems to be that LYAH is more beginner friendly
08:35:33 <hpc> RWH is more of a reference
08:35:38 <hpaste> “Jeff Shaw” annotated “How to avoid this type error?” with “How to avoid this type error? (annotation) (annotation) (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/56180#a56191
08:35:42 <Guest80544> I have already got RWH but cant manage to get anything into my brain
08:35:45 <hpc> go through LYAH, then when you need to learn something specific, jump to the RWH chapter
08:36:04 <Guest80544> cool
08:36:17 <monochrom> see, "I have already got RWH" is what you should have answered earlier when asked "better than what?"
08:36:25 <Peaker> dolio: Just scrolled up -- you could definitely get false positives where a value isn't actually used -- but a very common case is that the result is just never pattern-matched into a variable
08:36:45 <Guest80544> oops sorry!
08:37:10 <dolio> Okay, so you don't really care about it being particularly smart.
08:37:10 * monochrom hates guessing games
08:37:16 <dolio> Just some common, obvious cases.
08:37:46 <Peaker> dolio: yeah, my guess is that if you can use "sequence_" you might as well just make it obvious
08:39:05 <Peaker> if sequence was used in place of sequence_, then surely the useless result of sequence would not be given a name
08:39:33 <Peaker> and then GHC could use the auto-specialized_ sequence
08:41:10 <Guest80544> can you guys explain what Parse means?
08:42:00 <aninhumer> Guest80544: http://en.wikipedia.org/wiki/Parsing ?
08:43:25 * hackagebot quickcheck-instances 0.1.0 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.1.0 (AntoineLatter)
08:43:51 <Guest80544> thanks animhunter
08:43:59 <Guest80544> aninhumer
08:44:20 <Guest80544> sorry for the typo
08:45:01 <aninhumer> it's one of the most interesting mispellings of my nick I've seen...
08:45:23 <mauke> no tab completion in webchat?
08:45:47 <aninhumer> mauke: or perhaps just not familiar with it?
08:47:19 <Guest80544> lol
08:47:21 <Guest80544> cheers guys
08:55:14 <funktronic> @src ($)
08:55:14 <lambdabot> f $ x = f x
08:55:36 <ben_> `id`?
08:59:40 <byorgey> akosch: that type signature for handleControlEvent means that it must be able to return IO n for *any* Controller type, which the caller gets to choose
08:59:43 <byorgey> is that really what you want?
08:59:51 <byorgey> oh, sory, I have to go
09:00:06 <akosch> byorgey: np, I'm doing it another way now
09:00:25 <akosch> byorgey: thanks for the advice
09:00:48 <teneen> I've heard that polymorphic values (and CAFs) do not benefit from sharing
09:00:59 <teneen> however with monomorphism restriction disabled
09:01:09 <teneen> fibs = 0:scanl (+) 1 fibs
09:01:12 <teneen> is very fast
09:01:18 <teneen> fibs !! 10000
09:01:20 <teneen> is instant
09:01:35 <hpc> i thought polymorphic CAFs get a CAF for each monomorphic type you use in your program
09:01:54 <hpc> since that can be determined at compile-time
09:02:15 <stepkut> there is no sensible way to declare this instance right: instance Monad ((,) a) where return b = (undefined, b)
09:02:28 <stepkut> because you can't just magically create a non-bottom value of type 'a'
09:02:32 <teneen> hpc: but even in ghci it's very fast
09:02:41 <teneen> hpc: I see no difference
09:02:47 <stepkut> I guess if there was a constraint like, (Default a) => instance Monad ((,) a)
09:03:05 <hpc> stepkut: that would typecheck with undefined, but wouldn't be useful, yes
09:03:11 <stepkut> hpc: right
09:03:15 <stepkut> too bad
09:03:16 <hpc> stepkut: the constraint you want is Monoid
09:03:20 <stepkut> oh yeah
09:03:26 <hpc> stepkut: it has an empty value for return, and concatenation for bind
09:03:35 <hpc> and it doesn't break the laws
09:03:36 <stepkut> that could work
09:03:55 <stepkut> my end goal is to get, Traversable ((,) a)
09:04:34 <stepkut> so I can do, links <- mapM (second showURL) [ ("Edit Page", Pages) , ("New Page", NewPage) , ("Edit Menu", EditMenu) ]
09:04:49 <angstrom> is there something like an 'except' Parsec combinator? e.g., `digit >>= except (char '0')'?
09:05:02 <mauke> noneOf?
09:05:03 <hpc> angstrom: yes, i forget the name
09:05:06 <hpc> that
09:05:10 <mauke> notFollowedBy?
09:05:15 <hpc> @hoogle noneOf
09:05:15 <lambdabot> Text.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
09:05:15 <lambdabot> Text.ParserCombinators.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
09:05:38 <teneen> anybody has a good explanation for my question?
09:08:47 <stepkut> looks like, Monoid a => Applicative ((,) a), exist already.. I just need to add the Monad, Foldable, and Traversable instances.. and then convince the jury of my peers to accept the patch
09:09:50 <hpc> stepkut: the Monad instance exists too
09:10:35 <stepkut> hpc: I see a functor instance.. but not a Monad instance
09:10:49 <hpc> check Control.Monad.Instances
09:11:44 <stepkut> hpc: don't see it.. maybe I need a newer base than what comes with GHC 7.4rc1 ?
09:11:59 <stepkut> on hackage I don't see it either, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Control-Monad-Instances.html
09:12:11 <hpc> hmm
09:12:12 <stepkut> I am also not convinced it can be done
09:12:13 <hpc> nvm then
09:12:25 <hpc> i could have sworn...
09:12:40 <stepkut> ?type join
09:12:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:13:09 <angstrom> mauke: hm. `notFollowedBy (char '0') >> digit' seems to be what I want, then?
09:13:29 <stepkut> so for ((,) a), we would have, join :: (a, (a, b)) -> (a, b) ?
09:13:34 <stepkut> oh
09:13:44 <stepkut> I guess that would use the Monoid instance to combine the a values
09:13:49 <hpc> yep
09:14:06 * stepkut gives it a shot
09:14:33 <stepkut>     (a, b) >>= f = let (a', b') = f b in (a' `mappend` a, b')
09:14:54 <stepkut> oh, the a and a' should probably be the other way around
09:15:09 <hpc> indeed
09:15:36 <hpc> otherwise you end up with the "reverse writer" monad
09:15:47 <stepkut> :-|
09:15:54 <hpc> (if you want a major brainfuck, google "reverse state monad")
09:17:43 <stepkut> ?type fold
09:17:44 <lambdabot> Not in scope: `fold'
09:17:59 <stepkut>   fold :: Monoid m => t m -> m
09:18:19 <stepkut> so, that would be, fold :: (a, b) -> b
09:18:43 <stepkut> should I just toss the a ?
09:19:13 <stepkut> fold = snd
09:23:27 * hackagebot gloss-devil 0.1 - Display images in Gloss using libdevil for decoding  http://hackage.haskell.org/package/gloss-devil-0.1 (ThomasDuBuisson)
09:33:49 <kallisti> if I have a mapping f :: a -> Word8, how can I write a Storable instance that stores a as a Word8?
09:36:42 <rostayob> kallisti: sizeOf = sizeOf (undefined :: Word8), alignment = alignment (undefined :: Word8); peek ptr = peek >>= f; etc
09:37:09 <kallisti> rostayob: aaaah okay.
09:37:26 <rostayob> sorry, peek >>= (something :: Word8 -> a)
09:37:53 <kallisti> right
09:37:54 <Sgeo> Is PolymorphicComponents controversial?
09:38:33 <kallisti> rostayob: wait is that the monad instance for (->) a  ?
09:38:42 <kallisti> peek takes an Ptr a argument
09:39:13 <rostayob> kallisti: peek ptr = liftM (something :: Word8 -> a) (peek ptr)
09:41:48 <dolio> Sgeo: Probably less so than RankNTypes.
09:42:24 <kallisti_> rostayob: oops. dc'd. Did you get any recent messages?
09:42:38 <Sgeo> <kallisti> peek takes an Ptr a argument
09:42:41 <rostayob> kallisti_: not after the one about (a ->)
09:42:51 <rostayob> oh right. use castPtr for that.
09:43:05 <rostayob> :t castPtr
09:43:05 <lambdabot> Not in scope: `castPtr'
09:43:09 <rostayob> @hoogle castPtr
09:43:09 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
09:43:09 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
09:43:10 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
09:43:17 <rostayob> a pointer is a pointer :)
09:43:38 <kallisti_> 13:21 < kallisti> I feel like I need to make a cast to Word8, peek that, then  convert.
09:43:41 <kallisti_> 13:21 < kallisti> *Ptr Word8
09:43:44 <kallisti_> oh..
09:43:45 <kallisti_> yes.
09:44:03 <kallisti_> so fmap + castPtr. got it.
09:53:04 <bremner> I'm having trouble registering with trac.haskell.org, I don't seem to get the verification email (at an address that is otherwise receiving mail). Is this a know issue?
09:53:59 <irene-knapp> check your spam box
09:57:37 <bremner> I'm watching incoming mail at the smtp level. No likely looking messages are arriving.
09:58:09 <irene-knapp> ah okay
09:58:14 <irene-knapp> then I don't know
09:58:39 * bremner double checks the spam box, just in case
09:59:41 <bremner> no spam about haskell ;)
10:02:04 <Sgeo> @hoogle CInt -> Int
10:02:04 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
10:02:05 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
10:02:05 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
10:02:36 <rostayob> :t toIntegral
10:02:37 <lambdabot> Not in scope: `toIntegral'
10:02:46 <rostayob> :t fromInteger . toInteger
10:02:47 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
10:02:51 <rostayob> Sgeo: ^^^
10:03:03 <rostayob> :t fromIntegral
10:03:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:03:16 <Sgeo> What about fromEnum?
10:03:17 <rostayob> always mess up the names
10:03:32 <rostayob> Sgeo: that too, but fromIntegral is more general
10:43:57 <Sgeo> @hoogle withMVar
10:43:58 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
10:43:58 <lambdabot> GHC.Conc.Sync withMVar :: MVar a -> (a -> IO b) -> IO b
10:43:58 <lambdabot> GHC.Conc withMVar :: MVar a -> (a -> IO b) -> IO b
10:50:32 <nh2> is it always possible to write GeneralizedNewtypeDeriving instances by hand?
10:51:31 <byorgey> nh2: yes
10:51:42 <byorgey> nh2: but the hand-written instances may not be as efficient.
10:52:30 <Cody_> byogey_: Just like to say I read you 12 tetrahedral numbers article and I'm currently working on creating a function in Haskell to find the 12th tetrahedral number
10:53:20 <byorgey> Cody_: cool
10:54:43 <byorgey> nh2: hmm, actually, I take it back, it is not always possible
10:55:06 <byorgey> I can give you an example if you want
10:55:55 <nh2> I'm having trouble writing one for my newtype. I can easily derive MonadReader MyEnv for it, but I kinda fail to write it by hand. Is this one of the cases where it might not be possible or am I doing something wrong?
10:56:54 <nh2> byorgey: if this is not one of the examples, I'd appreciate to see one :)
10:57:07 <byorgey> nh2: This is probably not a case where it is impossible.
10:57:27 <byorgey> nh2: if you paste your code I could take a look.
10:57:32 <Sgeo> Do I have to do LANGUAGE QuasiQuotes, or does TemplateHaskell imply QuasiQuotes?
10:57:56 <byorgey> nh2: an example where it is not possible can be found here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg72300.html
10:58:28 <masylum> is it possible to parse a JSON with an unknown structure?
10:58:54 <Clint> isn't the structure json?
10:59:15 <masylum> I mean, you don't know the tyes
10:59:31 <masylum> in can be {a: 'b'} o {foo: [1, 2, 3], bar: 2}
11:00:07 <masylum> it may be a stupid question
11:01:40 <geekosaur> Sgeo: Quasiquotes are part of Template Haskell, which at the moment is a single lump
11:03:40 <nh2> byorgey: ok, I have some example code: http://hpaste.org/56193
11:06:26 <nh2> byorgey: I know that deriving the instance in the first case works because I told how to treat the outermost type as MonadReader with my not-so-nice instance declaration, but when I want to avoid that, I cannot run my extraction function
11:07:12 <byorgey> nh2: ask = VocablTerminal ask
11:07:34 <byorgey> nh2: also, it should be  instance (MonadReader ProgramEnv) VocablTerminal
11:07:57 <byorgey> oh, wait, sorry, that doesn't matter
11:08:32 <funktronic> any suggestions for good haskell problems other than 99 problems and euler ?
11:08:56 <nh2> byorgey: to do ask = VocablTerminal ask, I have to keep the first, ugly instance
11:10:55 <yitz> masylum: a lot of libraries are built on the JSON-Combinator package
11:10:57 <byorgey> nh2: 'local' is sort of ugly anyway, it is a stronger requirement than 'ask'.  It probably ought to be in a separate type class.
11:11:16 <byorgey> nh2: in other words I don't think it's that bad that you can implement 'ask' but not 'local'
11:11:45 <nh2> byorgey: oh wait, I think ask = VocablTerminal (lift ask) does the job
11:11:46 <masylum> I didn't know about that library
11:11:49 <masylum> thanks
11:12:03 <byorgey> nh2: ah, yes, that should work
11:12:22 <byorgey> nh2: you still won't be able to implement local, of course
11:13:10 <yitz> masylum: it provides a class JSONLike, which allows each library to decide how to implement JSON types
11:13:13 <nh2> byorgey: in the new context, I might even be able to, because it is more specific
11:13:35 <nh2> byorgey: definitely thanks, now I have one ugly compiler warning less :D
11:13:44 <byorgey> you're welcome =)
11:13:46 <yitz> masylum: it then gives you a way of running different functions based on the "json type" of an element of a JSON structure
11:14:40 <masylum> do you know any resource with examples? I'm learning haskell and is still difficult to understand everything by reading the source
11:15:32 <yitz> masylum: in that case your better off looking at a specific higher-level json library for practical json parsing and rendering
11:15:57 <masylum> I was playing with aeson
11:16:07 <yitz> masylum: that library i first mentioned is meant for building json libraries, not for use itself as a json library
11:16:20 <yitz> masylum: oh, now you're talking
11:16:26 <masylum> :)
11:17:04 <masylum> I'm trying to port this file to haskell
11:17:05 <masylum> https://github.com/LearnBoost/socket.io/blob/master/lib/parser.js
11:17:26 <masylum> but I'm stucked with the json parsing
11:17:43 <masylum> in JS you just do JSON.parse(str) and you get the object
11:18:14 <masylum> but with Aeson I don't know how to do it before knowing what I will receive
11:19:31 <aadrake> masylum: I was working on a similar problem earlier, acquiring JSON keys without knowing the structure
11:20:00 <aadrake> masylum: I was using the json library though and didn't need to do parsing
11:20:31 <masylum> http://hpaste.org/56194
11:20:34 <masylum> this is what I got so far
11:20:36 <byorgey> masylum: it looks like there is a fixed set of options for what you may receive?
11:20:52 <masylum> no, is a socket that can receive any json message from a client
11:21:22 <yitz> masylum: json and json' correspond to the JS way. in haskell that's not always what you want, though.
11:21:31 <masylum> I know
11:21:34 <masylum> this is why I ask
11:21:51 <masylum> to see if its doable or not at least
11:22:13 <byorgey> well, if you can receive ANY json message then you probably just want to parse it to a Value.
11:22:48 <byorgey> ah, yitz just said that.
11:23:16 <byorgey> you can't parse it to some more specific type if you don't know what you are going to get.
11:23:19 <aadrake> masylum: The json library lets you parse to type JSValue which is a container for all the possible (standards compliant) types in JSON
11:23:36 <aadrake> That's my understanding as someone new to Haskell
11:23:44 <yitz> masylum: at the top level you'd want to use FromJSON and ToJSON for the specific structure. for an item inside labeled 'json' that might be any JSON, you'd probably want the more generic approach.
11:23:46 <masylum> interesting
11:24:34 <yitz> masylum: that is just after a quick glance. i may be getting it wrong if i didn't understand correctly what LearnBoost is trying to do.
11:24:35 <masylum> maybe  should restrict the json to {foo: "bar", a: "b"} so I always get [(String), (String)]
11:25:31 <masylum> s/[(String), (String)]/[(String, String)]
11:25:35 <masylum> srry
11:25:45 <masylum> I think I will do that
11:26:18 <masylum> parse JSOn as a list of String key values
11:26:37 <masylum> its flexible enough
11:27:32 <yitz> masylum: you can do whatever you would have done in any other language.
11:28:24 <yitz> masylum: however, in cases where you know that the json structure is limited, you can leverage haskell's type checker to help you write your program more easily than if you just allow any generic json.
11:29:53 <hpaste> aadrake pasted “jskeys” at http://hpaste.org/56195
11:30:33 <masylum> wow
11:31:20 <aadrake> ôOops
11:31:24 <aadrake> Oh well
11:31:55 <masylum> I see in the bottom
11:32:04 <masylum> its itneresting
11:32:40 <aadrake> Yes, the last bit is relevant lol
11:34:23 <masylum> I will play more with Test.JSON
11:34:31 <masylum> Text.JSON*
11:34:47 <masylum> thank's for your help
11:34:59 <aadrake> masylum: It took me a while and I only got it working with help from the channel.
11:35:12 <aadrake> masylum: I'm quite new to Haskell though so you may have better luck.
11:35:37 <masylum> I'm missing more blogs or resources about haskell
11:35:42 <funktronic> if i have for example (take n . drop y) items.. is there a way to do it without the parens? i'm looking for something like the <| in F#
11:36:16 <masylum> its quite easy to get the basics, but when you want to learn how some modules work.. its not really easy
11:36:39 <Botje> funktronic: take n . drop n $ items
11:36:51 <funktronic> Botje: thanks!
11:37:11 <funktronic> Botje: i got confused for a sec and thought $ is the |>
11:37:20 <Botje> i have no clue about F# :)
11:37:39 <funktronic> oh (|>) x f = f x
11:38:05 <Botje> ah. that's called flip ($) :)
11:38:32 * hackagebot cmdargs 0.9.2 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9.2 (NeilMitchell)
11:39:11 <funktronic> another question. i have a function to calculate the weighted average.. so i have a line let weighted = zipWith (*) [ x | x <- [0 .. count]] srs which seems to force everything to int. how do i specify a constraint so that it's not just int just any numeric type? is that possible ?
11:39:27 <byorgey> > let { (|>) = flip ($); infixl 0 |> } in [1..10] |> take 3 . drop 5
11:39:28 <lambdabot>   [6,7,8]
11:39:50 <funktronic> byorgey: it's a VERY handy operator .. at least in F#
11:39:57 <funktronic> and ocaml
11:40:46 <byorgey> funktronic: note that  [ x | x <- [0 .. count]] == [0 .. count]
11:40:54 <byorgey> the [ x | x <-  is redundant
11:41:19 <funktronic> byorgey: good catch, i was going to one line it all but decided against it
11:41:41 <byorgey> funktronic: that code does not force everything to Int.  It is probably forced to be Int because count has type Int.
11:42:13 <byorgey> funktronic: what is count?
11:42:33 <byorgey> funktronic: you may not need count there. observe:
11:42:42 <byorgey> > zipWith (*) [0..] [5,6,2,8,3]
11:42:43 <lambdabot>   [0,6,4,24,12]
11:42:57 <funktronic> oh yeah it stops once the first list gets big enough
11:43:03 <funktronic> but i do need the count in another place :)
11:43:04 <byorgey> zipWith truncates the result to the length of the shorter list
11:43:42 <byorgey> funktronic: ok, but if you remove count from [0 .. count]  it will not be constrained to Int
11:44:09 <funktronic> byorgey: yep that worked
11:44:22 <aadrake> Can anyone recommend some changes that would speed this up? https://gist.github.com/9e00947bca292bc6b51f
11:44:53 <aadrake> Specifically the line et allKeys = DS.toList $ DS.unions ( map DS.fromList (map decodeKeys records))
11:44:58 <aadrake> If that is the bottleneck
11:45:40 <MostAwesomeDude> I'm running a relatively large list search (maximumBy, modified for constant space) and was hoping to capture incremental statistics during the search. What would be the general technique for this? Is there any helper for batching list operations so that every million or so items I could print out a status report?
11:46:16 <byorgey> aadrake: that line looks fine.
11:46:21 <byorgey> aadrake: are you reading a very large file?
11:47:07 <aadrake> byorgey: I guess that depends on your definition of large.  It has about 500,000 records
11:47:16 <aadrake> byorgey: It's a very small subset of a full file
11:48:07 <aadrake> byorgey: This small file is 706MB
11:49:25 <aadrake> Also, the composed map functions seem clumsy.  Is there a different way I should do that?
11:49:36 <byorgey> aadrake: I'm just guessing, but probably the main bottleneck is your use of String rather than something like ByteString
11:50:00 <byorgey> but to really be sure you'd have to do some profiling.
11:50:00 <Cale> aadrake: map f . map g = map (f . g)
11:50:17 <Cale> aadrake: But in terms of performance, once -O is on, those are equivalent
11:52:17 <aadrake> byorgey: On the topic of ByteString, I'm guessing that when you're dealing with library functions that take string arguments you end up doing a lot of packing/unpacking if you also implement ByteString.  Is that a fair assesment?
11:52:36 <aadrake> Cale: I think it's a worthwhile readability/style change even if it's equivalent where -O2 is concerned
11:53:12 <byorgey> aadrake: you probably don't want to use ByteString and library functions that take String arguments simultaneously.
11:53:39 <aadrake> byorgey: Because all the packing/unpacking would negate (or worse) any speedup you get from using ByteString in the first place?
11:53:44 <byorgey> aadrake: right.
11:54:18 <byorgey> aadrake: for parsing JSON in particular, I'm pretty sure the aeson library works directly with ByteStrings
11:54:21 <hpaste> funtronic pasted “compil” at http://hpaste.org/56196
11:54:21 <Cody_> What is the fastest way to check if a number is square? If sqrt(8*x+1) results whole number, how do you check for a whole number is haskell?
11:54:26 <aadrake> byorgey: Well I guess what I have is as good as it gets without some serious effort.
11:54:34 <funktronic> ^^ anyone got an idea what it's asking for http://hpaste.org/56196
11:54:37 <aadrake> byorgey: I don't really need to parse it though, just grab the keys from the JSON records.
11:54:48 <aadrake> byorgey: Do you think it would be faster in this case?
11:54:56 <byorgey> aadrake: I don't know.
11:55:24 <Younder> Hi, I am dying of lung cancer and woud like to sell some mathe books
11:55:28 <byorgey> funktronic: / cannot be used on integers.
11:55:53 <aadrake> Younder: That's an interesting first statement.
11:56:08 <byorgey> funktronic: you probably want  fromIntegral weighted / fromIntegral denom
11:56:28 <byorgey> funktronic: 'fromIntegral' can be used to convert any integral type (like Int, Integer) into any numeric type
11:56:31 <Younder> I have prepared a list of my 50 favourite boks
11:56:37 <funktronic> byorgey: weighted should be a floating point number though
11:57:05 <byorgey> funktronic: oh, ok, so then  weighted / fromIntegral denom
11:57:52 <funktronic> excellent!
11:57:53 <funktronic> thanks byorgey
11:58:06 <byorgey> Cody_: well, you could  let n = round (sqrt (8*x + 1)) and then check whether  n*n == x
11:58:16 <Younder> ever wondered about elliptic curve geometry, I have a book on that
11:59:19 <byorgey> Cody_: however, note that this does not work for large enough integers, because too much precision is lost when converting to floating point
11:59:24 <Younder> I don't know everyting goes. I am dying
11:59:42 <aadrake> Younder: Maybe you should donate them to a univeristy math department
11:59:52 <Younder> I also havea reld worl haskell book
12:00:01 <Cody_> byorgey_: That would be for perfect squares (i think?). I'm looking to see if it is a square number / triangular
12:00:19 <byorgey> Cody_: square numbers and perfect squares are the same thing.
12:00:54 <Younder> aadrake, nop, I have a real passionate relton to my books. It is important that they fall into the right hands
12:01:26 <shachaf> aadrake: ByteString isn't really comparable to String.
12:01:34 <Younder> aadrake, otherwise I might as well sell them back to amazon
12:01:48 <shachaf> aadrake: String is comparable to Text and ByteString is comparable to [Word8].
12:02:30 <aadrake> shachaf: Okay
12:02:39 <byorgey> Cody_: to check whether something is a triangular number, you check whether 8*x + 1 is a perfect square, just like you said
12:03:24 <shachaf> aadrake: That's because characters aren't bytes. If you don't see why you should probably read about the difference before using ByteString.
12:03:47 <Cody_> let triangular x = [x | x <- 1..x],  sqrt(8*x + 1)== (?? a whole number?)]
12:04:17 <Cody_> There is a missing [ in there, sorry
12:04:20 <aadrake> shachaf: I know the difference between characters and bytes.  Thank you for the help.
12:04:31 <byorgey> Cody_: try making a function  isSquare :: Integer -> Bool
12:04:55 <Cody_> Hold on.
12:04:59 <byorgey> Cody_: I think you will find that easier than doing it directly inside the list comprehension
12:05:09 <shachaf> aadrake: Great. :-) A lot of people who come to this channel don't, and end up using abominations like Data.ByteString.Char8.
12:05:11 <dgpratt> in a package id such as this "enumerator-0.4.14-1bdd82c566499aaf4364573efb3e8310", what's the significance of the bits the end? I assume it's a hash of some sort?
12:06:08 <shachaf> dgpratt; It's a hash of some sort.
12:06:29 <aadrake> shachaf: I don't know what Data.ByteString.Char8 does exactly, but I have seen it used in many examples, so perhaps that's why people keep trying to use it?
12:06:56 <shachaf> @google cabal packages hash suffix
12:06:56 <lambdabot> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/packages.html
12:06:57 <lambdabot> Title: 4.9.� Packages
12:07:09 <dgpratt> "ghc-pkg check" reports numerous broken packages, all similar to "There are problems in package zlib-enum-0.2.1:
12:07:09 <dgpratt>   dependency "enumerator-0.4.14-042e4c5d82703f7ad16279e203a5066d" doesn't exist"
12:07:15 <byorgey> dgpratt: see http://www.vex.net/~trebla/haskell/sicp.xhtml
12:07:58 <teneen> what's the difference between rnf and deepseq?
12:08:35 <dgpratt> I have the "enumerator-0.4.14" package installed, but it has a different hash
12:08:41 <shachaf> teneen: I would assume the same as the difference between id and seq.
12:08:51 <dgpratt> how the heck did this happen and how do I fix it?
12:08:52 <shachaf> teneen: I.e., look at the types, figure it out.
12:08:54 <brisingr> sorry for spamming the nick stuff, my irc is acting strange
12:08:56 <shachaf> Unless I'm wrong.
12:09:03 <funktronic> if i have a function that takes 2 args: rc :: Int -> Int -> a is it possible to do something like map rc [(x, x+a) | x <- [0 .. (count + b - a)]]
12:09:24 <funktronic> basically deconstruct the tuple and pass it to map. i can do it with a lambda but wondering if there's a different way
12:09:24 <shachaf> funktronic: (uncurry rc)
12:09:29 <teneen> shachaf: Does using rnf or deepseq cost some overhead somehow?
12:09:43 <funktronic> shachaf: thanks!
12:09:46 <shachaf> teneen: Yes, using both costs some overhead. That's because they do things.
12:09:46 <funktronic> @src uncurry
12:09:46 <lambdabot> uncurry f p = f (fst p) (snd p)
12:09:53 <shachaf> funktronic: Alternatively:
12:09:54 <funktronic> ah exactly what i needed
12:09:55 <eyebloom> Help, I'm in type hell.
12:10:00 <shachaf> [rc x (x+a) | x <- ... ]
12:10:11 <hpaste> eyebloom pasted “Hell” at http://hpaste.org/56197
12:10:14 <shachaf> funktronic: Since list comprehensions already "map".
12:10:24 <funktronic> shachaf: ah, that's even better
12:10:41 <teneen> shachaf: So it's not equivalent to how a strict language evaluates expressions?
12:11:02 <shachaf> teneen: I didn't say that.
12:11:15 <shachaf> teneen: But, no, how GHC evaluates an expression isn't equivalent to how a strict language evaluates an expression.
12:11:20 <shachaf> Even with rnf/deepseq.
12:11:32 <shachaf> eyebloom: Looks like you brought it onto yourself.
12:11:51 <shachaf> That's a huge typeclass. Are you sure you even need typeclasses at all?
12:12:00 <eyebloom> It's possible
12:12:06 <teneen> shachaf: Is it because it's still evaluated by outermost reduction, so it takes O(n) to reach the subexpressions
12:12:16 <eyebloom> Which one Node or AbstractGraph
12:12:24 <teneen> shachaf: it's more costly than in a strict language
12:12:51 <shachaf> teneen: No.
12:13:18 <shachaf> teneen: GHC's evaluation model is completely different from that of most other compilers/interpreters. You should understand it before using rnf/deepseq.
12:13:23 <shachaf> eyebloom: Oh, wow, there are two.
12:13:28 <shachaf> Are you sure you need either?
12:13:58 <eyebloom> I think I do.
12:14:14 <shachaf> Why?
12:14:23 <eyebloom> I've been working with Fgl for a while and this is a better interface for what I'd like to do.
12:14:26 <funktronic> sweet jesus it works, and it's half the length of the F# version
12:14:27 <shachaf> Haskell doesn't need typeclasses for abstraction.
12:14:54 <funktronic> and half as readable
12:15:04 * shachaf hasn't actually looked at the code, mind you.
12:15:14 <shachaf> funktronic: Half as readable?
12:15:20 <shachaf> You should @paste it in that case. :-)
12:15:32 <cheater> funktronic: what works?
12:15:37 <ion> I don’t think i’ve needed a typeclass of my own yet. Not that i’ve written any big projects, but i do use Haskell daily – if for nothing else, as a desktop calculator and quick oneliners.
12:15:43 <ion> +for
12:16:19 <funktronic> i decided to write something that calculates values of coppock curve
12:16:26 <cheater> what is the coppock curve?
12:16:46 <funktronic> cheater: http://en.wikipedia.org/wiki/Coppock_curve .. technical analysis for stocks.. a rather dumb one but a good exercise :)
12:17:04 <cheater> a technical analysis indicator for long-term stock market investors
12:17:04 <hpaste> coppock pasted “funktronic” at http://hpaste.org/56199
12:17:06 <cheater> interesting.
12:17:09 <funktronic> that's my code
12:17:23 <ion> let foo = bar
12:17:27 <ion>     baz = quux
12:17:29 <ion> in  …
12:17:31 <eyebloom> Well, if anything else, I think this code is 95% ready to compile so from my perspective it's at least helpful make it work even if I free those functions from typeclasses.
12:18:14 <shachaf> funktronic: You should write top-level type signatures. Even if it makes the code longer. :-)
12:18:23 <eyebloom> I'm planning on mixing types of graphs in the future by changing the parameters of ComplexNode l e.
12:18:25 <srhb> :t addtoin x = getLine >>= print . (+x) . read
12:18:26 <lambdabot> parse error on input `='
12:18:28 <srhb> Hmm
12:18:37 <srhb> :t getLine >>= print . (+x) . read
12:18:38 <lambdabot>     No instance for (Read Expr)
12:18:38 <lambdabot>       arising from a use of `read' at <interactive>:1:27-30
12:18:38 <lambdabot>     Possible fix: add an instance declaration for (Read Expr)
12:18:40 <Cale> I wonder when they're going to put up video for SPJ's talks at YOW
12:18:44 <srhb> Sorry.. Thought that was possible.
12:19:15 <funktronic> ion: that doesn't work.. parse error on input `='
12:19:22 <ion> @type let addtoin x = print . (+x) =<< readLn in addtoin
12:19:22 <lambdabot> forall a. (Read a, Num a) => a -> IO ()
12:19:32 <srhb> Thank you.
12:19:38 <srhb> My question is then, why Read a?
12:19:43 <srhb> I get Num a, because of the plus operator.
12:19:56 <Cale> readLn requires an instance of Read
12:19:57 <shachaf> srhb: Because you're using readLn.
12:19:59 <Cale> :t readLn
12:20:00 <lambdabot> forall a. (Read a) => IO a
12:20:06 <shachaf> Just look at the types of each part of the thing you wrote.
12:20:49 <ion> funktronic: Paste the erroneous code.
12:21:03 <srhb> But isn't the "readable" part something different from my argument x?
12:21:13 <ion> @type (+)
12:21:14 <srhb> Oh, the a is just referring to the type
12:21:14 <lambdabot> forall a. (Num a) => a -> a -> a
12:21:26 <ion> Both parameters to (+) must be of same type.
12:21:27 <Saizan> aadrake: ah, i would change the type of decodeKeys to make it return Set String directly, so that you can just DS.unions that
12:21:45 <hpaste> compile pasted “funktronic” at http://hpaste.org/56200
12:21:53 <ion> (+) wants it to be an instance of Num and readLn wants it to be an instance of Read.
12:21:54 <funktronic> ion: ^ complains on line 11
12:22:12 <funktronic> oh wait the indentation is off
12:22:31 <ion> funktronic: Your code seems to contain tabs. I strongly recommend using spaces for indentation.
12:22:44 <srhb> I understand now, thank you. :)
12:22:49 <funktronic> ion: yeah the editor decided to use tabs
12:23:18 <funktronic> yeah it works now
12:23:22 <ion> @src readLn
12:23:22 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:24:21 <ion> srhb: Note: readLn uses readIO instead of just read to raise an exception immediately upon read failure instead of whenever the result value happens to be evaluated.
12:25:53 <Cody_> byorgey_: Maybe I am overthinking it, but I can't come up with the solution. If the square root of 8*x + 1 is a whole number(no decimals) then it is a square number. How do I check if it is a whole number?
12:26:04 <srhb> ion: Which is desirable?
12:26:15 <srhb> I suppose it is, yes.
12:26:49 <ion> srhb: If you’re doing IO code and don’t mind read exceptions, use readIO. Otherwise use reads or something else that doesn’t throw exceptions in the first place.
12:27:07 <srhb> Right.
12:27:13 <brisingr> Cody_ perhaps a bit late to the convo here, but a workaround would be to sqrt it, floor it and then square it and compare with the original
12:27:25 <shachaf> ion: Why give people the evil answer first? :-(
12:27:43 <brisingr> Cody_: or better round than floor, to prevent errors
12:27:52 <ion> shachaf: In hindsight, that was wrong of me.
12:27:54 * ion repents
12:28:32 * hackagebot usb 1.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.1 (BasVanDijk)
12:28:34 * hackagebot usb-iteratee 0.4.0.1 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-iteratee-0.4.0.1 (BasVanDijk)
12:28:36 * hackagebot ircbot 0.1.2 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.2 (JeremyShaw)
12:29:46 <Cody_> brisigr_: Why would floor cause erros
12:30:54 <brisingr> Cody: I'm a bit scared of flooring 1.0, for example. I know I shouldn't be
12:30:55 <brisingr> but I am
12:31:27 <ion> funktronic: This is a matter of preference, but i’d write that code pretty much completely in reverse, like: coppock … = calculateWma where { total = zipWith (+) first second; first = …; second = …; rc = … }; roc = …; calculateWma … = weighted / fromIntegral denom where { denom = (n * (n + 1)) …; n = …; weighted = … srs …; srs = … }
12:32:11 <brisingr> Cody_: I'm an utter noob on sqrt internal representation, I'm afraid that sqrt would do something like 125.999999999999999851 and when you floor it, it all goes haywire
12:32:20 <byorgey> absolutely, you should use round, not floor
12:32:30 <byorgey> for the reason brisingr said
12:33:26 <shachaf> You should just use integer square root if you insist on doing this.
12:33:32 * hackagebot ircbot 0.1.3 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.3 (JeremyShaw)
12:33:53 <Cody_> brisingr: So it would be something like this => (if round(sqrt(x)) == x then True else False)
12:34:50 <brisingr> Cody_: if round(sqrt(x)) ^ 2 == x then True else False
12:35:34 <byorgey> Cody_, brisingr: you will also need to convert x from an integral to a floating-point type first
12:35:51 <Cody_> Just going to say, got an error
12:36:00 <Saizan> what about isWhole x = x == fromIntegral (round x); isWhole (sqrt x) ?
12:36:02 <byorgey> round (sqrt (fromIntegral x) :: Double) ^2 == x
12:36:27 <brisingr> how about doing an integer square root like shachaf suggested?
12:36:31 <Saizan> ?type properFraction
12:36:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
12:36:39 <byorgey> Saizan: that is just asking for trouble.
12:37:11 <Saizan> byorgey: more than the other version?
12:37:21 <byorgey> yes.
12:37:46 <byorgey> at least the other version relies on integer equality, not floating-point equality.
12:39:06 <Cody_> byorgey: What does (fromIntegral x)::Double mean? X has a type double?
12:39:24 <byorgey> it means (fromIntegral x) has type Double.
12:39:47 <byorgey> since fromIntegral can produce any numeric type, here you have to give the compiler a hint to know which type you want to use
12:40:27 <byorgey> sigh
12:40:44 <Cody_> byorgey:  Thanks. So in your isSquare, any triangular number would return false, correct?
12:41:04 <thlorenz> Hi, I'm getting monomorphism exception for the following function:
12:41:06 <thlorenz> takeWhile (<10000) $ map (^3) [1..]
12:41:07 <byorgey> Cody_: you should know, by the way, that you have walked right into a corner of Haskell that is often particularly frustrating for newbies
12:41:20 <thlorenz> sorry wrong one - let's try again
12:41:33 <Cody_> byorgey: Believe me, I know
12:41:39 <byorgey> Cody_: ok =)
12:42:10 <byorgey> Cody_: some triangular numbers are also square
12:42:12 <ion> brisingr: “if foo then True else False”? Much better: “if if foo then True else False then True else False”.
12:42:18 <thlorenz> clean'   = sort . nub
12:42:18 <thlorenz> This function gives me the monomorphism exception
12:42:24 <byorgey> for example 36
12:42:31 <trinithis> Is there a function of the type (String -> ExpQ) that takes a string representation of a Haskell expression and returns its AST? I know there's [|...|], but that doesn't seem to take a variable string.
12:42:34 <byorgey> in fact, there are infinitely many such numbers
12:42:38 <thlorenz> while this one is fine: clean xs = sort $ nub xs
12:42:45 <brisingr> ion: ?
12:43:00 <mike-burns> thlorenz: Does it work if you give it an explicit type?
12:43:04 <byorgey> thlorenz: just turn off the monomorphism restriction.
12:43:05 <thlorenz> I was just trying to write it points free style
12:43:11 <Cody_> byorgey_: Ugh.
12:43:14 <ion> brisingr: Oh, it seems the “then True else False” came from Cody.
12:43:28 <thlorenz> that's what ghci tells me to do, but I'm trying to understand why there is a difference
12:43:28 <byorgey> {-# LANGUAGE NoMonomorphismRestriction #-}  -- thlorenz, put this at the top of your .hs file
12:43:40 <thlorenz> aren't both functions identical?
12:43:56 <byorgey> thlorenz: yes, they are.
12:44:07 <byorgey> thlorenz: it is not that important.  but if you really want to know you can read http://www.haskell.org/haskellwiki/Monomorphism_restriction
12:44:14 <funktronic> ion: i like to have many separate pieces since it's easier to test them and narrow down issues
12:44:20 <brisingr> ion: now I get it, yes, I did that too
12:44:32 <brisingr> wasn't paying attention
12:44:34 <thlorenz> and I didn't give an explicit type for the former, why does the compiler have no problem figuring things out for that one?
12:44:36 <byorgey> Cody_: what's wrong?
12:45:38 <thlorenz> thanks for the link, that explains it
12:45:41 <Cody_> I coded two functions in Python, one for triangular numbers and the other for tetrahedral numbers. Converting them to Haskell is difficult
12:45:49 <dgpratt> how can I start over with my user-level installed packages? I think that's the only way out of this mess
12:46:28 <ion> funktronic: My example didn’t change the amount of separate pieces at all.
12:46:37 <thlorenz> just weird, that it only gets confused when you write the same function points free style
12:47:10 <funktronic> ion: i misunderstood, my bad
12:47:43 <byorgey> Cody_: these are functions for recognizing whether a number is triangular or tetrahedral?
12:47:51 <byorgey> Cody_: or for generating them?
12:47:57 <Cody_> generating
12:48:20 <byorgey> Cody_: note that  [ x | x <- [1.. blah], isTriangular x ]  is not a very good way to generate triangular numbers
12:48:25 <Cody_> So triangular 4 would generate the first 4 Triangular numbers.
12:48:36 <brisingr> Cody_: use the general formula
12:48:45 <Cody_> The what?
12:48:53 <byorgey> Cody_: you know the general formula for the nth triangular number, right?
12:48:58 <Cody_> Yes
12:49:06 <byorgey> otherwise where did you get sqrt(8*x + 1) from =)
12:49:09 <brisingr> [ x*(x+1)/2 | x <- [1..5]]
12:49:15 <brisingr> > [ x*(x+1)/2 | x <- [1..5]]
12:49:16 <lambdabot>   [1.0,3.0,6.0,10.0,15.0]
12:49:22 <brisingr> > [ x*(x+1) `div` 2 | x <- [1..5]]
12:49:23 <lambdabot>   [1,3,6,10,15]
12:49:28 <Cody_> math wiki
12:49:38 <Cody_> Whoa, you can type functions in here?
12:50:03 <brisingr> yep
12:50:21 <byorgey> Cody_: so if you want the first 4 triangular numbers, just apply the formula to the numbers [1,2,3,4]
12:50:22 <Cale> You can type expressions preceded by "> ", which will be evaluated by lambdabot.
12:50:26 <sipa> no, you can type expressions in here
12:50:46 <thlorenz> byorgey: adorning the function with clean' :: (Ord a, Eq a) => [a] -> [a]  fixed it, but still odd
12:50:57 <Cody_> Thank you brisinger!
12:51:07 <Cody_> What does `div` mean?
12:51:20 <byorgey> thlorenz: I am not arguing with you there.
12:51:22 <mike-burns> :t div
12:51:23 <lambdabot> forall a. (Integral a) => a -> a -> a
12:51:25 <ion> Integer division
12:51:42 <thlorenz> byorgey: :)
12:51:46 <byorgey> Cody_: integer division, i.e. division where you discard any remainder
12:52:00 <byorgey> > 19 `div` 2
12:52:00 <lambdabot>   9
12:52:04 <Cody_> If I knew that an method an hour ago...
12:52:14 <byorgey> Cody_: well, you should have asked =)
12:52:37 <Cody_> I hope learning every method won't take that long lol
12:53:09 <mike-burns> Cody_: http://www.haskell.org/onlinereport/standard-prelude.html
12:53:47 <Cody_> byorgey_: finished! and mike-burns: Thanks
12:54:15 <byorgey> great!
12:54:25 <Cody_> let triangles x = [x*(x+1) `div` 2 | x <- [1..x]]
12:54:34 <Cody_> let tetrahedral x = sum(triangles x)
12:55:14 <Cody_> While more difficult than Python, it was 3 times shorter
12:55:39 <mike-burns> Which is easier to read?
12:55:52 <byorgey> it's only difficult if you're not used to it.  I find it much easier. =)
12:56:26 <Cody_> Bit of a learning curve I guess. You made it seem so easy in J
12:56:57 <MostAwesomeDude> Cody_: I should point out that you can do this exact same thing in Python: triangles = (x * (x + 1) // 2 for x in itertools.count()); tetras = sum(triangles[:x])
12:57:06 <mekeor> Cody_: can you paste the python code, too?
12:57:09 <byorgey> > let triangles x = scanl1 (+) [1..x]; tetrahedral = sum . triangles  in  tetrahedral 5
12:57:10 <lambdabot>   35
12:57:14 <brisingr> Cody_: I find haskell stimulating because it's relatively hard to write something, but if you see it it's immediately obvious
12:57:18 <byorgey> ^^^ even shorter but not as obvious =)
12:58:20 <brisingr> byorgey: I know someone who would have shunned you for inefficiency
12:58:23 <Cody_> mekeor_: sure and brisingr: I agree
12:58:48 <Cody_> def triangular(x):     result = []     result.append(1)     while 1 < x:         result.append(sum([x for x in range(1,x+1)]))         x = x - 1     result.sort()     return result
12:58:53 <mike-burns> @paste
12:58:53 <lambdabot> Haskell pastebin: http://hpaste.org/
12:59:27 <hpaste> Cody pasted “Test” at http://hpaste.org/56202
12:59:49 <mike-burns> Oh sure, you used a different algorithm in Python.
12:59:56 <mike-burns> Could've used a list comprehension, too.
13:00:08 <mike-burns> But MostAwesomeDude already said that.
13:00:09 <Cody_> I did
13:00:16 <mike-burns> Ah I see it now.
13:01:32 <Cody_> Learning Python and Haskell together
13:01:38 <MostAwesomeDude> Cody_: Yeah, I'd do uri: http://paste.pocoo.org/show/531485/ instead.
13:01:49 <Cody_> Able to see significant differences
13:02:24 <ion> > let triangles = scanl1 (+) [1..]; tetrahedral n = sum . take n triangles in tetrahedral 5
13:02:25 <lambdabot>   No instances for (GHC.Enum.Enum [a], GHC.Num.Num [a])
13:02:25 <lambdabot>    arising from a use...
13:02:35 <ion> > let triangles = scanl1 (+) [1..]; tetrahedral n = sum (take n triangles) in tetrahedral 5
13:02:36 <lambdabot>   35
13:02:37 <byorgey> brisingr: um, if efficiency is important then we should just use the closed form for tetrahedral numbers in the first place =)
13:02:57 <Cody_> ion: Whats scan1?
13:03:06 <mike-burns> :t scanl1
13:03:07 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
13:03:39 <mike-burns> One way to think of scanl is as every step of a foldl.
13:03:53 <mike-burns> :t scanl
13:03:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:04:00 <Cody_> :t fold1
13:04:00 <lambdabot> Not in scope: `fold1'
13:04:09 <Cody_> :t foldl
13:04:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:04:23 <brisingr> byorgey: that person keeps killing me for efficiency so if I have a O(n log n log n) in 2 lines but an O(n log n log n log n) in 2000 lines he prefers the latter
13:04:28 <Cody_> MostAwesomeDude: does yours work?
13:04:32 <byorgey> Cody_: scanl1 is the same thing as /\ in J ;)
13:04:40 <Cody_> Thanks^
13:04:50 <MostAwesomeDude> Cody_: It should, but I didn't test. :3
13:05:00 <byorgey> Cody_: note in my blog post where I do  +/\ >: i. 12  and get  1 3 6 10 15 ...
13:05:08 <byorgey> Cody_: in Haskell that would be:
13:05:15 <byorgey> > scanl1 (+) [1..12]
13:05:15 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78]
13:05:38 <byorgey> Cody_: in other words  scanl1 (+) [1..12]  gives you  [1, 1+2, 1+2+3, 1+2+3+4, ...]
13:05:44 <byorgey> > scanl1 (+) [a,b,c,d]
13:05:44 <Cody_> MostAwesomeDude: You only find the triangular number for 1 number, so that would screw up your tetrahedral
13:05:45 <lambdabot>   [a,a + b,a + b + c,a + b + c + d]
13:05:57 <Cody_> Awesome
13:06:10 <byorgey> brisingr: that person has some seriously screwed up priorities.
13:06:38 <ion> > let triangles = scanl1 (+) [1..]; tetrahedrals = scanl1 (+) triangles in tetrahedrals !! 4
13:06:39 <lambdabot>   35
13:06:50 <byorgey> brisingr: also, O(n log n log n log n) is slower than O(n log n log n), pehaps you meant  O(n log log log n) versus O(n log log n).
13:06:51 <Cody_> What are some other reason you'd want to your scanl?
13:07:13 <Cody_> ion: Infinite list
13:07:16 <brisingr> byorgey: yeah
13:07:25 <brisingr> been kinda slow thinking today
13:07:46 <byorgey> no worries =)
13:07:53 <ion> > let triangles = scanl1 (+) [1..]; tetrahedrals = scanl1 (+) triangles in tetrahedrals
13:07:54 <lambdabot>   [1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,1540,...
13:08:24 <byorgey> Cody_: I don't know, any time you wanted to do some operation on all the prefixes of a list
13:08:32 <byorgey> having trouble thinking of specific examples.
13:08:35 <Cody_> Except this one time =)
13:08:52 <MostAwesomeDude> Cody_: Oh, it's zero-indexed. Check http://codepad.org/v7GAtmUE
13:08:57 <Cody_> Give every student extra credit in a databse?
13:09:04 <MostAwesomeDude> Python's LCs are just like Haskell's.
13:09:06 <byorgey> Cody_: no, that sounds more like 'map'
13:09:11 <ion> > let fibs = 0 : scanl (+) 1 fibs in fibs
13:09:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:09:35 <byorgey> oh yes, scanl is also useful for that obfuscated version of fibs, I forgot =)
13:09:44 <ion> @quote fibonac
13:09:44 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
13:10:00 <byorgey> haha
13:10:07 <Cody_> scanl (+) 1 [1..]
13:10:08 <mike-burns> A+
13:10:30 <byorgey> Cody_: you have to prefix expressions with a > and a space
13:10:50 <mike-burns> > take 10 $ scanl (*) 1 [2..]
13:10:51 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
13:11:28 <mike-burns> I've only ever seen useless mathy scanls.
13:11:36 <mike-burns> I'm sure they're useful to someone.
13:12:08 <MostAwesomeDude> Well, it's a generalized form of a certain kind of recursion. It just isn't used often because people don't recognize when that pattern occurs.
13:12:23 <mike-burns> Do you have a non-useless-mathy example?
13:12:33 <ion> Math is useless?
13:13:11 <mike-burns> You have a use for using scanl to compute the infintie list of Fibonacci numbers?
13:13:35 <byorgey> mike-burns: a quick grep through the codebase for diagrams-lib shows that I use it to convert between two representations of paths: one that stores vertices and one that stores offsets from each vertex to the next
13:13:59 <mike-burns> byorgey: Ah, perfect!
13:14:14 <byorgey> that's pretty 'mathy' in one sense, but also quite practically useful because it lets people define paths in multiple ways
13:14:56 <mike-burns> I'm fine with math, mostly asking for useful examples. And you've provided one.
13:15:10 <cl1> does paying close attention to tail recursion matter in haskell? for example in f# its not lazy evaluated so you have to watch out for stack overflows
13:15:14 <byorgey> oh, even better, I thought you asked for a non-mathy example, but I see now you asked for a (non-useless)-mathy example =)
13:16:03 <Saizan> cl1: in some cases tail-recursion can be worse in haskell
13:16:39 <Saizan> cl1: it all depends on how lazy you can be
13:16:44 <Saizan> @wiki Stack overlfow
13:16:45 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overlfow
13:16:48 <Saizan> @wiki Stack overflow
13:16:48 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
13:17:19 <cl1> that link turns up nada
13:17:25 <srhb> The last one.
13:17:42 <srhb> There is not stack overlfow, nor overfowl.
13:17:54 <Saizan> yeah, i typoed the first time
13:18:32 * hackagebot vty-ui 1.4 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.4 (JonathanDaugherty)
13:18:42 <MostAwesomeDude> Hm. A package on Hackage is broken, but I was able to download and build it just fine. How would I figure out how to fix the build failure? It's not my package, but I want to use it.
13:18:51 <byorgey> stack overfowl is when you use too many chickens
13:19:33 <byorgey> MostAwesomeDude: what do you mean 'it is broken'?
13:19:48 <MostAwesomeDude> byorgey: The package is monadiccp; it has a build failure listed on Hackage.
13:19:48 <byorgey> MostAwesomeDude: you mean Hackage shows a 'build failure'?
13:19:57 <byorgey> MostAwesomeDude: ah, don't pay attention to those
13:20:40 <byorgey> MostAwesomeDude: the build environment on Hackage is in many ways too restrictive
13:20:51 <MostAwesomeDude> byorgey: So if I want to read the docs, I need to Haddock locally?
13:21:01 <ion> byorgey: http://i.imgur.com/lGhdr.png
13:21:10 <byorgey> MostAwesomeDude: yes, unfortunately
13:21:45 <MostAwesomeDude> Hm. Looks like most of the package is not commented. Annoying.
13:22:04 <byorgey> ion: what is that? a stack overfowl?
13:22:07 <ion> yeah
13:22:22 <byorgey> looks more like sheep to me
13:22:48 <monochrom> build failures are more often on hackage itself than on your computer. often unfixable over there.
13:22:51 <byorgey> amusing, at any rate =)
13:23:34 * hackagebot vty-ui-extras 0.1 - Extra vty-ui functionality not included in the core library  http://hackage.haskell.org/package/vty-ui-extras-0.1 (JonathanDaugherty)
13:23:36 * hackagebot twitter-enumerator 0.0.1.2 - Twitter API package with enumerator interface and Streaming API support.  http://hackage.haskell.org/package/twitter-enumerator-0.0.1.2 (TakahiroHimura)
13:25:27 <cl1> Saizan, very helpful link, thank you
13:29:02 <lukish> How can I get "page" value from that response?
13:29:02 <lukish> Chunk "{\r\n  \"total\": 0,\r\n  \"page\": 1,\r\n  \"pagesize\": 30,\r\n  \"users\": []\r\n}\n" Empty
13:29:05 <lukish> it :: Data.ByteString.Lazy.Internal.ByteString
13:30:36 <ddarius> @hackage aeson
13:30:36 <lambdabot> http://hackage.haskell.org/package/aeson
13:32:24 <augur> irene-knapp: thoughts?
13:32:42 <lukish> ddarius: okay, and how?
13:32:55 <parcs`> what are the applicative laws?
13:33:28 <parcs`> also the functor laws :P
13:35:46 <parcs`> never mind, read the documentation
13:44:02 <alistra> i have a question about MVars, it says with most of the functions, that they're atomic if they're the only producer
13:44:08 <alistra> what does it mean
13:44:22 <roconnor_> are pattern guards Haskell 2010?
13:44:27 <copumpkin> yeah
13:44:33 <roconnor_> What is the syntax?
13:44:43 * roconnor_ is tempted to use it
13:44:44 <copumpkin> foo x y | Just z <- bar y x
13:45:13 <roconnor_> does hugs support 2010?
13:45:24 <shachaf> I doubt it.
13:45:35 <copumpkin> I don't think anyone's touched hugs since 2006?
13:45:51 <copumpkin> it appeared stagnant when I started haskell
13:47:00 <MostAwesomeDude> Oh, trace and traceShow. I wish I had known about these sooner.
13:48:25 <ddarius> @quote refreshing.desert
13:48:25 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:50:11 <yitz> trace is definitely useful. i don't think it's *that* important for productivity, though.
13:50:56 <MostAwesomeDude> Well, my earlier question, about how to examine the progress of a several-million-item fold, would have been way easier to answer had I known about it.
13:51:26 <MostAwesomeDude> It did eventually finish, though. 17 minutes for 6 million items. Guess it's time to profile.
13:51:35 <yitz> yeah that's one way
13:52:30 <yitz> MostAwesomeDude: -O2
13:53:15 <MostAwesomeDude> yitz: That was with -O2. I didn't have the patience to see what happens without it.
13:53:58 <toxicode> hey
13:54:07 <yitz> MostAwesomeDude: ok :) i wouldn't have the patience either, especially if it took 17 min. *with* -O2
13:54:24 <yitz> hi toxicode
13:54:46 <MostAwesomeDude> So it's time to profile and see what I can fix up. I'm investigating this other CP library in the hopes that it might be faster.
13:55:02 <yitz> CP?
13:55:28 <MostAwesomeDude> Constraint programming.
13:55:30 <ddarius> Linear canonical transforms are intriguing.
13:56:11 <MostAwesomeDude> I'm doing a constraint solve over a fairly large domain (110**6 or so) and I'm only constraining my search to about 6 million items. I bet I could get that down further.
13:56:17 <monochrom> alistra: take modifyMVar for example. if every thread uses only modifyMVar (as opposed to raw putMVar), the MVar in question is effectively an atomic shared variable
14:03:51 <toxicode> my cxx poisoned brain can't take the concept of immutable vars (
14:04:12 <hpc> toxicode: it's just like "const" :P
14:05:34 <erus`> @hoogle nad
14:05:34 <lambdabot> Prelude class Monad m
14:05:34 <lambdabot> Control.Monad class Monad m
14:05:34 <lambdabot> Control.Monad.Instances class Monad m
14:05:37 <erus`> @hoogle and
14:05:37 <lambdabot> Prelude and :: [Bool] -> Bool
14:05:37 <lambdabot> Data.List and :: [Bool] -> Bool
14:05:37 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
14:05:47 <erus`> @hoogle all
14:05:48 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
14:05:48 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
14:05:48 <lambdabot> Data.Monoid All :: Bool -> All
14:06:26 <toxicode> hpc: yep, but why it's default?
14:06:32 <Jerrry> Can someone help me with a beginniner question? I'm supposed to describe an example type: someType -> (someType, String)
14:06:35 <erus`> can i make the following shorter?
14:06:39 <erus`> > [ n | n <- [1..1000], all ((==0) . mod n) [3,5,7] ]
14:06:41 <lambdabot>   [105,210,315,420,525,630,735,840,945]
14:06:49 <Jerrry> beginner** not beginniner rofl
14:07:05 <ddarius> toxicode: It's not just "default," but why not?  In C++ (and any other language) it is best to make as much things "const" as possible.
14:07:41 <ddarius> erus`: It looks like the result is shorter than the code to produce it.
14:07:46 <byorgey> erus`: map (*105) [1..9]
14:08:08 <Jerrry> My best answer that I can think of is that it takes the function someType and returns a tuple consisting of the result paired with a string.
14:08:11 <ddarius> > 3*5*7
14:08:12 <lambdabot>   105
14:08:33 <hpc> toxicode: that's a more interesting story than i can tell
14:08:34 <Silvah> What's the name of the guy who's famous for being a Haskell hater and letting people know it by writing on every single site he can find?
14:08:38 <nexion> does Haskell have a timestamp system that is independent of the system clock? I'm looking for something that would allow me to keep track of how long ago an entry was created, regardless of system clock adjustments
14:08:49 <byorgey> Jerrry: someType is not (necessarily) a function
14:08:56 <erus`> does that work for all primes?
14:09:01 <Jerrry> What can I call it in my answer, then?
14:09:07 <hpc> nexion: probably; the time stuff haskell has is ridiculous
14:09:08 <byorgey> Jerrry: someType is a type
14:09:12 <Jerrry> Oh, okay, thanks.
14:09:19 <Jerrry> Is the rest correct?
14:09:30 <ddarius> nexion: There are a lot of libraries for talking to different clocks.  Pick one.
14:09:42 <parcs`> are there any sql libraries that provide type-safe QQ sql statement parsers?
14:09:44 <byorgey> someType -> (someType, String)  is the type of a function which takes an arugment of type  someType  and produces a value of the same type paired with a String.
14:09:48 <byorgey> Jerrry: more or less.
14:10:02 <Jerrry> Thanks, byorgey.
14:10:06 <byorgey> "the result paired with a String" -- why isn't the String part of the result?
14:10:13 <toxicode> ddarius: clear, thanx
14:10:18 <byorgey> it depends how you are thinking of "the result"
14:10:34 <nexion> could you recommend one that would be ideal for the described purpose?
14:10:36 <Jerrry> I should have worded that better.
14:10:42 <Jerrry> I know that the tuple is the result.
14:10:44 <tcrayford> where can I read stuff about stripping stuff out of the ghc distribution? ghc/lib is using like 700mb of space (and I'm bandwidth/space constrained on heroku)?
14:11:53 <Jerrry> byorgey: is it wrong or unnecessary to say that it's a tuple?
14:13:14 <racingSnail> hello, I don't want to interrupt the conversation -- but wonder if somebody can help me understand "Maybe" and "Just" better.  I am working through the LYAH tutorial and would like a tip.  can someone help me in a private msg?
14:13:35 <shachaf> racingSnail: You should just ask questions you have in here.
14:13:39 <racingSnail> ok
14:13:50 <hpc> racingSnail: let's start with a simpler type
14:13:54 <shachaf> racingSnail: Don't worry about interrupting the conversation.
14:13:59 <hpc> "data Bool = False | True"
14:14:11 <shachaf> hpc: I think Maybe is pretty simple. We should wait until we know what racingSnail's actual question is.
14:14:12 <hpc> racingSnail: False and True are obviously values of type "Bool"
14:14:31 <racingSnail> yes, and those are the only 2 values that Bool can be
14:14:37 <hpc> racingSnail: "data Maybe a = Nothing | Just a"
14:14:48 <ddarius> hpc: Why don't you wait for racingSnail's question?
14:15:08 <hpc> ddarius: i figured i could infer the question from "help me understand "Maybe" and "Just" better."
14:15:09 <racingSnail> right.  so here is my question: if I know it isn't "nothing", so it is "Just something", is there any way to strip off "Just"?
14:15:14 <hpc> oh
14:15:19 <shachaf> racingSnail: Yes; pattern-matching.
14:15:20 * hpc shuts up :P
14:15:29 <shachaf> case foo of Just x -> ...; Nothing -> ...
14:15:30 <hpc> @src fromJust
14:15:30 <lambdabot> fromJust Nothing  = undefined
14:15:30 <lambdabot> fromJust (Just x) = x
14:15:34 <racingSnail> ah: like Just a | a
14:15:37 <hpc> one of many ways
14:15:38 <shachaf> hpc: Come *on*.
14:15:45 <hpc> @src maybe
14:15:45 <lambdabot> maybe n _ Nothing  = n
14:15:45 <lambdabot> maybe _ f (Just x) = f x
14:15:45 <nexion> ddarius, the only library I've managed to find so far is Windows-specific, providing GetTickCount
14:15:48 <hpc> a better way
14:15:57 <shachaf> hpc: You're seriously not helping, you know.
14:16:33 <shachaf> racingSnail: "Just a | a"?
14:16:45 <Silvah> @src fmap
14:16:46 <lambdabot> Source not found. Maybe you made a typo?
14:17:30 <racingSnail> now that I see @src fromJust I think I understand.
14:17:49 <shachaf> racingSnail: You pretty much shouldn't ever use fromJust.
14:18:05 <shachaf> It's an unsafe function, and even if you want the unsafety there are usually better ways of doing it.
14:18:22 <shachaf> The advantage of pattern-matching yourself is that the compiler can warn you if you don't cover all the cases.
14:18:46 <Silvah> Is it possible to create a type that is both an instance of Num and Monad (of course respecting the laws)?
14:18:49 <racingSnail> ok, I'm going to try something with the pattern matching and see if I get it right
14:18:58 <shachaf> Silvah: No.
14:19:17 <shachaf> Not even disrespecting the laws, assuming you aren't including "compiles" as a law.
14:19:34 <shachaf> They're different kinds, i.e., an instance of Monad takes an argument and an instance of Num doesn't.
14:20:43 <monochrom> unless the wording of the question is modified. instance Monad X and instance Num (X a)
14:20:50 <Silvah> Right, but wouldn't it be possible to make e.g. instance Num (Foo a) or something?
14:20:55 <Jeanne-Kamikaze> nexion, looking for timers ?
14:20:57 <Cale> Silvah: yeah
14:21:01 <Cale> That's possible
14:21:47 <Cale> In fact, whenever you have Monad M, you can write an instance (Num a) => Num (M a)
14:21:53 <monochrom> and example is the phantom type: data X a = X Int
14:21:58 <Rc43> Hi, guys.
14:22:01 <nexion> Jeanne-Kamikaze, kind of.. basically, a way to get a timestamp that is "actual time" as opposed to clock time, since clock time can be changed easily
14:22:22 <Jeanne-Kamikaze> actual time as in a timestamp ?
14:22:29 <Jeanne-Kamikaze> eh
14:22:47 <monochrom> what is actual time? definition?
14:23:06 * geekosaur isn't getting that one either, even if it queries NTP I can arrange to spoof responses...
14:23:11 <Rc43> Can anybody answer? The fact that cardinality of continuum /= cardinality of natural numbers set is part of continuum hypothesis or proved statement?
14:23:11 <Jerrry> How do I describe this type? (a -> b) -> [a] -> [b] I think I get it but I don't know how to describe it exactly.
14:23:28 <aristid> nexion: a monotonic clock?
14:23:36 <Silvah> So it would be possible?
14:23:40 <shachaf> Num doesn't really have laws.
14:23:48 <shachaf> Reasoning about it is silly.
14:23:48 <Jeanne-Kamikaze> Jerrry, map ?
14:23:51 <Rc43> (So, we can't make map between N and set of Real.)
14:24:06 <Feuerbach> Rc43: it's proven by diagonalisation
14:24:07 <Silvah> But Monad has.
14:24:09 <nexion> for example, if the app starts at clock time = 3, we consider actual time =3 as well.. but if later the clock is moved back 1 second, the clock time is now 1 second less than actual time
14:24:15 <shachaf> Jerrry: What do you mean by getting it?
14:24:18 <geekosaur> Jerrry: transform a list by applying a transformation to its elements
14:24:22 <shachaf> Jerrry: Can you describe it approximately?
14:24:28 <Jeanne-Kamikaze> uh
14:24:32 <ddarius> @hackage clock
14:24:33 <lambdabot> http://hackage.haskell.org/package/clock
14:24:41 <Feuerbach> Rc43: http://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
14:24:52 <Jerrry> Okay, my buest guess is:
14:24:56 <nexion> the purpose being to accurately time things, regardless of background clock sync operations
14:25:11 <shachaf> Jerrry: You shouldn't have to guess if you understand it. :-)
14:25:12 <monochrom> System.CPUTime?
14:25:16 <Jeanne-Kamikaze> you cannot accurately time things
14:25:23 <aristid> nexion: time? as in, determing order? or also cardinality?
14:25:24 <Jeanne-Kamikaze> by definition of time
14:25:26 <Jerrry> I'm not sure.
14:25:32 <ddarius> @hackage rdtsc
14:25:33 <lambdabot> http://hackage.haskell.org/package/rdtsc
14:25:37 <chturne> I'm trying to test the result of lookup :: ... -> Maybe b. I have a utility function isNothing :: Maybe a -> Bool which has patterns like isNothing (Just _) = True etc. However, I get type errors when I try things like if isNothing(lookup(...)) then .. else .. Is it obvious why that's the case?
14:26:01 <nexion> I was considering spawning a thread with threadDelay to trigger an event when an entry hasn't been updated for 10 seconds, which would solve that problem
14:26:01 <Jerrry> I just don't know how to word the part inside the parentheses.
14:26:24 <Jeanne-Kamikaze> a function that takes an a and produces a b ?
14:26:41 <chturne> Oops, that should have been isNothing (Just _ ) = False...
14:26:48 <shachaf> Jerrry: This is your homework, right?
14:27:02 <Jerrry> Sort of. My friend wrote me these questions to help me learn Haskell.
14:27:04 <ddarius> nexion: Yep, that's another possibility.
14:27:06 <Jeanne-Kamikaze> how else are you supposed to read a -> b
14:27:12 <Jerrry> So I am doing it for the purpose of learning, not trying to cheat.
14:27:35 <Saizan> chturne: not obvious, also why don't you just use a case expression instead?
14:27:41 <ehuber> a silly question, but I can't find the answer in the cabal user guide: how do i make an 'executable' section and specify that i want the executable to be built (cabal build), but not installed (cabal install) ?
14:27:52 <ddarius> chturne: You probably have a syntax error.
14:27:53 <Saizan> chturne: case lookup ... of Nothing -> ..; Just _ -> ..
14:28:13 <chturne> Saizan, that's probably a better idea. I'll paste some code so that I can understand why my original attempt is working.
14:28:20 <chturne> *isn't
14:28:29 <Jerrry> (a -> b) -> [a] -> [b] maps type a to type b and what?
14:28:43 <shachaf> Jerrry: Mainly "what.".
14:29:09 <ddarius> chturne: In general, you should probably paste actual code and not bother with "abstracted" versions.  At best, you can attempt to narrow down to a smaller section of actual code, but even that is not necessary or desirable for relatively small amounts of code.
14:29:10 <Jerrry> And then maps the result of type b and a list of type a into a list of type b?
14:29:12 <mzero> I've got a Parsec design conundrum: My parser is big enough that I want to put the token parsers in one module and the command grammar parsers in another --- but deep inside one of the token parsers, there is a construct that can embed a whole command  -- how should I do this w/o having mutually recursive modules?
14:29:20 <ddarius> chturne: You should also paste the actual error messages you are getting.
14:29:35 <ddarius> mzero: Parameterize.
14:29:46 <mzero> ehuber - just don't run 'cabal install'
14:29:54 <ddarius> Or just move that token parser.
14:29:56 <ehuber> :p okay
14:30:09 <Jeanne-Kamikaze> Jerrry, it takes a function that takes and a to produce a b and maps it to a list of a's to produce a list of b's
14:30:11 <chturne> ddarius, yes, sorry about that. I was being lazy.
14:30:20 <mzero> wait - do you have multiple executables, and some are, say, tests?
14:30:27 <Jerrry> Thanks Jeanne-Kamikaze and shachaf.
14:30:46 <mzero> ddarius: moving will pull the whole cycle into the upper parse, I fear
14:30:53 <ehuber> mzero: suppose a case though, where i have a project with some example executables, and a library. the library should be installed , but the examples are just there for reference -- should i have a subdir w/ another cabal? or is there a way to tell cabal to not install certain build products?
14:31:12 <toxicode> hpc: vars in haskell are using in math sense, that's why they are const by default. Is it your interesting story? :)
14:31:42 <ddarius> mzero: It's a little odd to have a "token" parser that can parse a whole "command"
14:31:42 <mzero> ehuber: I don't believe there is, and the common way is to have multiple .cabal files - exactly as you suggest - the ones for tests in subdirs
14:31:52 <ehuber> mzero: thank you :)
14:32:01 <mzero> ddarius - POSIX shell is a little "odd" !!
14:32:16 <ddarius> mzero: Not that odd.
14:32:18 <hpc> toxicode: well... yeah
14:32:40 <hpaste> chturne pasted “an error” at http://hpaste.org/56204
14:32:57 <mzero> ddarius:    echo "moo $(date | sed -e 's/0/z/') bar"
14:33:02 <mzero> yes, yes it is!
14:34:00 <ddarius> mzero: I would recommend either parsing that as a string and post-processing it later, or treating that as made up of multiple lexemes.
14:34:30 <mzero> ddarius: I wish i could - but you can't, you actually have to parse the entire grammar to properly find end of that item
14:34:30 <ddarius> I see no reason why that must be a single token containing a "command."
14:34:41 <mzero> ehuber: you might also be able to use the configuration form
14:34:54 <ddarius> mzero: Then it should be treated as multiple lexemes.
14:34:57 <mzero> in cabal - where the default configuration just builds (and hence will install) just the library
14:35:23 <monochrom> chturne: "lookup name primitives"
14:35:27 <mzero> but a "developer configuration" would build all the tests and/or samples, -- and you just expect people won't install the "developer" config.
14:36:04 <Rc43> Feuerbach, thanks; but why such set T exists? It is looks like Russell's paradox.
14:36:04 <monochrom> and there will be further errors. type of name (String) is not [LispVal] -> LispVal
14:36:14 <mzero> ddarius: it isn't possible to find the delimiter unless you parse the whole command -- it looks like it might be "matching )", but there are cases where it most definitely isn't
14:36:22 <monochrom> err nevermind, that is not going to be a further error
14:36:39 <ddarius> mzero: Then it should be treated as multiple lexemes.
14:36:52 <chturne> monochrom, thanks, I make this mistake all the time, should have realised. Sorry for the bother!
14:36:54 <Rc43> Feuerbach, I mean `set, containing elements of infinite sequence of infinite sequences` ~ `set of all sets`
14:38:20 <mzero> the issue with that grammar is that you can't tokenize without being able to do a full parse in some cases
14:38:29 <mzero> (you should read the spec, it is very scary)
14:38:45 <Feuerbach> Rc43: you can obtain it by taking the powerset of natural numbers, and then filtering out finite ones
14:39:39 <ddarius> mzero: I'm saying you can define a lower level notion of token.
14:40:22 <Feuerbach> ddarius, mzero: I'm yet to read the log, but I see you're discussing parsing of shell scripts
14:40:31 <mzero> indeed
14:40:43 <Feuerbach> I've been solving that problem, and indeed you need parser and lexer to cooperate
14:40:52 <mzero> it is, if one wants to be POSIX compliant, very tricky
14:40:57 <mzero> are you solving that in Haskell?
14:41:01 <Feuerbach> yes
14:41:07 <mzero> curious - so am I
14:41:12 <Feuerbach> :)
14:41:15 <mzero> are you building a shell in Haskell?
14:41:28 <Feuerbach> this is my project: https://github.com/feuerbach/loker
14:41:35 <Feuerbach> mainly analyser/compiler
14:41:52 <Feuerbach> and I created https://github.com/feuerbach/regex-applicative to build such a lexer
14:42:18 <ehuber> another question :P i was under the impression that cabal uses yaml, but im having trouble getting anchor/reference to work
14:42:32 <Rc43> Feuerbach, `filtering out` is `throw out of the set` or `leave in the set`?
14:42:33 <ddarius> ehuber: Why are you under that impression?
14:42:43 <ehuber> because it looked like it, i guess
14:42:45 <monochrom> I did not hear that cabal uses yaml
14:42:50 <mzero> ehuber: yaml? where?
14:43:10 <Rc43> Feuerbach, didn't understand you =/
14:43:13 <monochrom> unless yaml is a blanket term for "homebrew notation"
14:43:14 <mzero> Feuerbach: interesting - I'm actually building one to be used as an interactive shell
14:43:18 <Jerrry> What would be the type annotation for a function that returns a sentence that mentions a list of Ints in it?
14:43:25 <Feuerbach> Rc43: well, since you need the set of infinite sequences, you throw away finite ones. But I now see I lied to you: you'd get infinite sets, not sequences...
14:43:30 <ehuber> monochrom: it's not :P
14:43:32 <Rc43> Feuerbach, T consists of infinite subsets of N?
14:43:35 <Jerrry> Would it be [Int] -> String?
14:43:40 <Feuerbach> mzero: anyway, obviously we need to cooperate :)
14:44:11 <ehuber> so then, does cabal's syntax allow for me to write something once then repeat it several places?
14:44:22 <monochrom> I don't know what is "sentence", but I expect to see "-> ... [Int] ..."
14:44:35 <Rc43> Feuerbach, I can't understand why _subsets_ of _N*_, but not _subsets_ of {0,1}*
14:44:54 <Jerrry> monochrom: I guess it means words + integers.
14:45:08 <Rc43> Feuerbach, also _elements_ of _N_ may be coded like such sequences, but finite =/
14:45:28 <monochrom> no, cabal syntax doesn't have that
14:46:01 <ehuber> bummer. thanks
14:46:11 <Rc43> Feuerbach, no, I mixed up all
14:46:22 <Feuerbach> Rc43: roughly speaking, that set is just the set of functions from N to {0,1}
14:46:46 <Feuerbach> Rc43: that doesn't yet explain how to build it in ZF, but I'm sure it can be done
14:47:20 <Rc43> Feuerbach, you mean {0,1}*?
14:47:32 <Feuerbach> no, {0,1}
14:47:54 <Feuerbach> every sequence corresponds to a function from N to {0,1}
14:47:57 <Rc43> We can map number to {0,1} with two ways.
14:48:13 <Rc43> Aaa
14:48:17 <Rc43> sorry
14:48:32 <Feuerbach> e.g. 0110... corresponds to {1->0, 2->1, 3->1, 4->0, ...}
14:48:43 <ddarius> Every infinite sequence.
14:48:46 <racingSnail> <shachaf> <hpc> thanks for the help I understand the matching pattern for Maybe now.
14:48:56 <Feuerbach> ddarius: right
14:51:01 <ddarius> Also, just to address an aspect of the original question, the continuum hypothesis is the statement about the existence of cardinalities between ℵ_0 (i.e. N) and the continuum (i.e. R ~ 2^N).
14:51:11 <Rc43> Feuerbach, where is bug? Suppose we have such T (it contains every infinite sequence of {0,1}); but for every such T we can construct T' such that T' > T and have s0, which is different from any s from T; so we can't construct the set of all inf seqs of {0,1}
14:51:17 <Rc43> like Rusell's paradox
14:51:23 <ddarius> Snappily it's just the question is ℵ_1 = R
14:52:02 <ddarius> What does T' > T mean?
14:52:16 <Rc43> T is a subset of T'
14:52:25 <ddarius> T is a sequence not a set.
14:52:37 <ddarius> Er, sorry, I misread.
14:53:05 <ddarius> T = 2^N.
14:53:08 <Rc43> > Snappily it's just the question is ℵ_1 = R
14:53:09 <lambdabot>   <no location info>: parse error on input `='
14:53:24 <Rc43> can you link it? I am not strong in all this things
14:53:29 <ddarius> Rc43: You are just asserting that you have an s0.  You need to prove that some exists.
14:53:48 <ddarius> (and that it is an infinite sequence, i.e. an element of 2^N, which should show the problem.)
14:54:11 <Rc43> it is constructed in Cantor's argument, as I understood
14:54:20 <ddarius> Rc43: Then you misunderstood.
14:54:25 <Feuerbach> Rc43: that argument only works if you assume you can put all those things in a sequence
14:54:33 <Feuerbach> so that means you can't
14:54:53 <McManiaC> is there a way why my app leaks memory?
14:54:56 <McManiaC> *to tell
14:55:09 <hpc> McManiaC: profile it
14:55:12 <Feuerbach> McManiaC: heap profiling might help
14:55:47 <Rc43> It seems, now I understood :)
14:55:48 <McManiaC> how do you do that?
14:55:50 <shachaf> racingSnail: Great. This idea of pattern-matching is very fundamental to all Haskell data types.
14:56:29 <ddarius> Rc43: Cantor's argument saying that N is "smaller" than R relies on the fact that you can find a "next" N, whereas with R there is no "next" R.
14:57:50 <Rc43> ddarius, yeah, right now I had similar associations
14:57:58 <Rc43> ddarius, like parallel branches
14:58:16 <Cody_> What IDE do you guys use?
14:58:25 <roconnor_> Cody_: kate
14:58:28 <Rc43> ddarius, (excepting that in any `branch` in R we can compare them)
14:58:44 <Cody_> kate?
14:59:06 <tcrayford> Cody: it's a text editor
14:59:15 <tcrayford> most haskell developers just use text editors
14:59:46 <Cody_> Notepad is getting kinda boring. Keep having to exit it, change it, and then reload
14:59:57 <racingSnail> cody: gvim
15:00:48 <Cody_> I head about vim
15:01:08 <hpc> on windows, notepad++
15:01:19 * ddarius learned vim on Windows.
15:02:00 <ddarius> Rc43: You can compare any for inequality (especially if you don't care about computability), there's just no "next" real.  It doesn't have to be the "next biggest" real, there's just no way of having any "list" that covers all reals so that you could say this real follows this other real.
15:02:08 <Cody_> I mean something that has a split screen. One being the editor and the other GCHI
15:02:37 <ddarius> Cody_: Why do you need a special editor for that?  Just have two windows.
15:02:42 * monochrom used Turbo Pascal
15:03:09 <Cody_> In order to reload the module in GCHI, I have to save Notepad and close it. Gets annoying
15:03:21 <ddarius> It's GHCi, unless you are talking about something else.
15:03:23 <monochrom> you can save and not close
15:03:34 <Cody_> ddarius: excuse me, GHCi
15:03:38 <Rc43> ddarius, yes-yes, I am exactly about it
15:03:50 <Cody_> ^^How?
15:03:55 <ddarius> ...
15:04:01 <monochrom> ctrl-s or use the "file" menu
15:04:02 <McManiaC> hpc: why do I get
15:04:02 <McManiaC> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
15:04:02 <McManiaC> used on a library. Use the configure flag --enable-library-profiling and/or
15:04:02 <McManiaC> --enable-executable-profiling.
15:04:05 <ddarius> Cody_: How are you a programmer?
15:04:14 <McManiaC> hpc: when adding -prof -auto to me GHC-options of my cabal file?
15:04:24 <Cody_> ddarius: What do you mean? I am a student
15:04:26 <McManiaC> I'm not compiling a library, it's an executable
15:04:30 <monochrom> any other editor or IDE will be harder to use than notepad
15:04:56 <srhb> This is quite possibly true, and a good point.
15:04:57 <monochrom> (considering how they have way more choices in their menus, etc)
15:05:07 <Cody_> As with any IDE for most languages
15:05:12 <srhb> Also true.
15:05:21 <ddarius> Cody_: I expect a five year old who's had access to a computer to be able to answer these questions.
15:05:38 <ddarius> I'm not even exaggerating.
15:05:46 <Cody_> Ok then.
15:05:47 <monochrom> anyway my point is "not know how to save and not close in notepad" = "not know how to save and not close in anywhere"
15:05:53 <irene-knapp> you're just assuming that Cody meant "college student"
15:06:04 <irene-knapp> for all you know he's ten and living in the developing world or something
15:06:15 <irene-knapp> in which case these questions are quite fair
15:06:38 <irene-knapp> although his English seems quite good if that's the case, so I dunno
15:06:44 <srhb> Even if not, I've seen smart university students use computers poorly. :-)
15:06:56 <ddarius> irene-knapp: And if he has access to a computer, which he clearly does, then I'd expect him to know the answers to these questions, unless he -just- started using a computer, but then how has decided he should be a programmer?
15:07:15 <irene-knapp> ddarius: I take your point, and have no answer :)
15:07:20 <monochrom> notepad is not unexplorable, you know.
15:07:42 <ddarius> Admittedly, there are definitely three year olds that can use an iPhone better than I.
15:07:45 <Cody_> I know how to close notepad. In MS Excel 2007 you can close the file and still have Excel open. You can't do that in Notepad
15:08:01 <srhb> Cody_: Why do you need to close the file though?
15:08:06 <Cody_> I don't know where all this hostility is coming from
15:08:11 <copumpkin> me neither
15:08:14 <srhb> Me neither, some people just like to be snide.
15:08:25 <pikhq> I strongly suspect Cody's running into some sort of Windows brokenness. I wouldn't be *too* surprised to find out Notepad's locking the file.
15:08:44 <Cody_> Because its gets annoying when you have to keep editing programs, hence, why I was asking for and IDE
15:08:51 <pikhq> Cody_: So, if you leave Notepad open and try using GHCi on the file, it doesn't work?
15:08:56 <Cody_> Nope
15:09:03 <srhb> Cody_: Why not leave the file open after saving it?
15:09:07 <pikhq> Yup, Windows brokenness. Not his fault.
15:09:11 <srhb> Aha.
15:09:14 <Cody_> Thank you
15:09:23 <ddarius> pikhq: Also not what he originally said.
15:09:23 <srhb> That's.. interesting behaviour.
15:09:38 <shachaf> pikhq: I don't think that's how Notepad works.
15:09:43 <monochrom> I used to use notepad in conjunction with ghci too. did not observe the locking.
15:09:55 <ddarius> pikhq: And seemingly not true.
15:09:56 <pikhq> I'd try it out myself, but I don't have a Windows system handy.
15:10:00 <pikhq> ddarius: Bleh.
15:10:07 * ddarius can boot Windows in a VM.
15:10:15 <srhb> Which version, etc.
15:10:25 <ddarius> Admittedly, I don't have GHCi installed on it, I don't think.
15:10:32 <Cody_> There we go
15:11:52 <mike-burns> Cody_: If you want a split-pane IDE, where you can edit code in one pane and GHCi in the other, try emacs or (perhaps) vim.
15:11:59 <mike-burns> I like vim but I don't use it for a split pane.
15:12:02 <Cody_> Just double checked. When Notepad it open, GHCi freezes up
15:12:13 <ddarius> Now the story changes.
15:12:21 <Cody_> When did it ever?
15:12:53 <Cody_> mike-burns_: Thanks
15:13:22 <srhb> Cody_: This page on the wiki might interest you: http://www.haskell.org/haskellwiki/Applications_and_libraries/Program_development#Editor_support
15:13:46 <monochrom> there was no snide remarks. disbelief is not snide.
15:14:17 <srhb> monochrom: I think you failed to read the comments in here, if you really think that.
15:14:24 <Cody_> Really? What about what irene-knapp was saying?
15:14:59 <mike-burns> I saw a ton of snide remarks, including stuff claiming that anyone knows how to save a file in Notepad. (I certainly don't. I think.)
15:15:11 <Cody_> I that this was for beginners and other Haskell users to ask questions. Not to be put on trial because of Notepad
15:15:26 <srhb> Cody_: Don't worry too much, not all people in here are like that. Far from it.
15:15:43 <srhb> And either way, along the road you probably -will- want something else than Notepad, I think.
15:15:51 <Cody_> shrb_: Water under the bridge as far as I'm concerned
15:15:59 <dolio> ddarius: Can't I just use the obvious well ordering on the reals?
15:16:25 <erus`> can i remove the lambda from this: foo i (t:ts) = (\(i, t) -> (i,t:ts)) idxt i t
15:16:43 <ddarius> dolio: What's the "next" subset of the reals?
15:17:10 <ddarius> @pl foo i (t:ts) = (\(i, t) -> (i,t:ts)) idxt i t
15:17:10 <lambdabot> foo = (`ap` tail) . (. head) . flip . flip (flip (. snd) idxt . ap (,) . flip (:))
15:17:26 <ddarius> erus`: Use where (or let.)
15:17:54 <mike-burns> :t idxt
15:17:55 <lambdabot> Not in scope: `idxt'
15:18:00 <erus`> ddarius: could you show me an example ?
15:18:11 <dolio> Given a real, use the fact that the reals are isomorphic to an ordinal to get an ordinal. Take the successor ordinal. Then use the isomorphism to get a real.
15:18:34 <ddarius> (\x -> y) z = let x = y in z (as long as y doesn't use x)
15:19:20 <merijn> dolio: Wait, the reals aren't isomorphic with ordinals, are they? Or am I confusing names again?
15:19:42 <rostayob> merijn: reals are countable
15:19:53 * ddarius doesn't know what rostayob is saying.
15:20:20 <dolio> They're isomorphic to a specific ordinal if you have the axiom of choice, which is pretty uncontroversial.
15:20:23 <merijn> I thought they were uncountable, but I might be misremembering because we didn't cover this in English...
15:20:33 <ddarius> merijn: They are.
15:21:11 <merijn> dolio, rostayob: Elaborate?
15:21:58 <copumpkin> Cody_: I'd use sublime text
15:22:03 <merijn> Wikipedia agrees with my memory: "an uncountable number of reals, almost all real numbers fail to be computable."
15:22:14 <ddarius> Perhaps, rostayob, being a programmer, only believes in computable reals, which I can get behind.
15:22:30 <Cody_> copumking: I'll take a look at it, thanks
15:22:50 <merijn> ddarius: Yes, but you can't just say something exists by redefining what you're talking about!
15:22:57 <shachaf> ddarius: Come to think of it, I've never seen one of these uncomputable reals. Are we really sure they exist?!
15:22:59 <copumpkin> Cody_: no specific support for haskell other than syntax highlighting and completions, but it's nice
15:23:06 <ddarius> merijn: Says you.
15:23:16 <ddarius> shachaf: I certainly don't believe in them.
15:23:23 <dolio> In the presence of the axiom of choice, you can well order every set, and well ordered sets are isomorphic to ordinals.
15:23:40 <McManiaC> hmmmmm why do I get "could not find module XY" as soon as I turn on the -prof flag with ghc --make ??
15:23:47 <McManiaC> without that flag it compiles fine
15:23:53 <ddarius> McManiaC: You need profiling versions of the libraries you use.
15:24:02 <Saizan> merijn: maybe you're confusing ordinals with naturals? since there's no contradiction between being uncontable and being isomorphic to an ordinal
15:24:10 <ddarius> McManiaC: This probably means you need to recompile almost everything.
15:24:15 <merijn> Saizan: Probably?
15:24:17 <Jerrry> Haskell trick question! I have to write the type annotation for a function that accepts three values of any type, ignores them, and returns "I don't know."
15:24:33 <ddarius> Jerrry: Write the function, and then ask GHCi for the type.
15:24:34 <Jerrry> I am guessing the answer might just be :: String
15:24:43 <merijn> Jerrry: a -> b -> c -> ()?
15:24:57 <monochrom> I think you can write down a formula using supremum, and that formula gives you an uncomputable real.
15:25:24 <rostayob> merijn: sorry i was on the phone the whole time, reals aren't countable
15:25:27 <tromp> :t const  "I don't know."
15:25:28 <lambdabot> forall b. b -> [Char]
15:26:12 <merijn> Saizan, rostayob: Yeah, my brain was parsing Ordinal as Natural. Apparently I have no clue what ordinals are
15:26:20 <McManiaC> ddarius: is turning on library/executable profiling in the ~/.cabal/config enough?
15:26:43 <ddarius> McManiaC: I believe so, but you'll still have to recompile the packages you already have installed.
15:27:16 <ddarius> McManiaC: That will make it so that you won't have this issue in the future.
15:27:54 <monochrom> f :: a -> b -> c -> String; f _ _ _ = "I don't know"
15:28:21 <merijn> ddarius: Well, you can't redefine what you're talking about without either 1) the other party agreeing or 2) losing the capability to have useful discussion
15:28:40 <Jerrry> monochrom: I had a -> b -> c -> String for my first answer, but can't it be just String since it always returns "I don't know"?
15:28:52 <mike-burns> Jerrry: But it takes three arguments.
15:28:58 <Jerrry> Oh, I see.
15:29:06 <McManiaC> ddarius: ok thank
15:29:07 <McManiaC> s
15:30:10 <rostayob> merijn: ordinals are numbers used to have an isomorphism between well ordered sets and those numbers iirc
15:30:12 <ddarius> merijn: You have at least one implicit assumption in that statement.
15:30:48 <Cody_> copumkin: Thanks, just downloaded it
15:31:11 <dolio> merijn: Ordinals are kind of an extension of the natural numbers. The way they're typically constructed in set theory is....
15:31:15 <merijn> ddarius: I'm human, I've billions of implicit assumptions :)
15:31:27 <rostayob> merijn: i'm not sure how you represend those in day to day programming though
15:31:46 <rostayob> merijn: you might want to look at http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
15:31:47 <dolio> The ordinal 0 is {}, given an ordinal n, there's a successor ordinal n U {n}....
15:33:02 <merijn> rostayob: I'll take a look
15:33:16 <ddarius> merijn: But not, hopefully, in that statement.  That said, finding out what your billions of implicit assumptions are would be a good exercise.
15:33:59 <ddarius> dolio: But you are saying the set of reals is isomorphic to an ordinal and that implies we can map each real to a specific ordinal (via von Neumann's definition.)
15:34:13 <dolio> And then there are limit ordinals that are complete sets of ordinals, where 0 is in the ordinal, and if n is in the ordinal, then so is Sn.
15:34:49 <dolio> ddarius: It was a jab at the axiom of choice.
15:34:53 <blalb> the set of reals is in bijection with at least one ordinal. like every set. this follows from AC
15:35:19 <blalb> but -which- ordinal in indeterminate
15:35:37 <rostayob> blalb: wait, like every ordered set
15:35:45 <rostayob> oh whatever i shouldn't speak of maths.
15:35:55 <dolio> Every set is well ordered according to AC.
15:35:56 <ddarius> dolio: Also, not every ordinal is a successor ordinal, though I guess my wording wasn't precise enough for that to quite be a problem.
15:36:00 <kall5> what is the y-axis in the activity area in threadscope?
15:36:11 <blalb> the reals can be the same size as any uncountable ordinal
15:36:25 <blalb> you can add this as an axiom and be consistent with ZFC
15:36:31 <dolio> ddarius: I don't think that matters unless you want to find the _previous_ real.
15:36:56 <ddarius> dolio: It matters if you want to list -all- reals by following the iterates of the successor function.
15:37:04 <blalb> but your bijection wont preserve ordering, because the usual ordering on the reals isnt a well ordering
15:37:43 <ddarius> blalb: No one said anything about preserving the reals' numeric ordering.
15:37:55 <blalb> what are you trying to do, then?
15:39:32 <ddarius> blalb: This wasn't that serious a discussion, so it's a bit hard to explain where "a bit" = more effort than I feel like putting out.
15:40:00 <dolio> ddarius: Finding the first real might be the problem there. Also, there aren't enough spots in a list, depending on your definition of list.
15:40:14 <dolio> Wait, no, finding the first is easy.
15:40:24 <dolio> It's given by 0 and the isomorphism.
15:40:27 <ddarius> Indeed.
15:41:11 <hpaste> erus` pasted “tom's ugly code of the day” at http://hpaste.org/56205
15:42:34 <mike-burns> erus`: Use two spaces instead of tabs; that'd prevent it from shifting right so much.
15:42:59 <erus`> also twice the hard disk space
15:43:20 <mike-burns> Hah. Yes, I bet that's a concern.
15:43:29 * ddarius gives erus` a dollar to buy all the disk space he'll need for those spaces.
15:43:50 <mike-burns> Why does `idxt' produce a value that is immediately thrown away?
15:44:11 <erus`> i need it on the last line
15:44:29 <mike-burns> Ah.
15:45:49 <erus`> is there some super analyzer that will find potential folds or maps i could use instead of recursing ?
15:46:34 <JoeyA> hlint, but I don't know if it's *that* advanced in that direction.
15:46:36 <rostayob> erus`: not that i know of
15:46:58 <rostayob> JoeyA: hlint just looks for common patterns that you can replace by convenience functions
15:47:08 <rostayob> but i'm pretty sure it doesn't look for recursion to be turned into folds
15:47:14 <Peaker> hmm.. not exposing the data constructor of a record while exposing the fields -- still allows constructing any value by modifying an existing value... breaking invariants. any idea besides re-exposing each field getter as a new function?
15:47:31 <rostayob> Peaker: don't expose the record functions?
15:47:40 <Peaker> rostayob: well, I want record field getters only
15:47:41 <rostayob> Peaker: oh well you already said that
15:47:52 <rostayob> Peaker: no, you have to hide them and expose setters
15:47:57 <rostayob> can't think of anything else
15:48:01 <rostayob> *getters
15:48:34 <mike-burns> erus`: f [] = b ; f (x:xs) = g x (f xs)   -- this is a fold.
15:48:45 <mike-burns> (For example, your `foo'.)
15:48:54 <Peaker> well, might as well encode my invariants better so I don't need a smart constructor
15:48:59 <rostayob> erus`: also, sometimes an explicit function is much better than a big ass fold, in terms of readability.
15:49:10 <merijn> rostayob++
15:49:28 <erus`> ass-fold
15:49:36 <rostayob> that sounds painful
15:50:35 <mike-burns> erus`: Can you explain what this function does? I'm having trouble piecing together `foo' and `idxt'.
15:51:16 <dolio> Anyhow, something like Chaitin's constant makes it a little hard to write off uncomputable reals. You can at least write a (classical) specification for that one.
15:51:41 <Peaker> I really wish my Haskell IDE managed imports for me...
15:51:51 <Jerrry> I need help determining the type of the righthand side of: countLetterX s = length (filter (== 'x') s)
15:51:52 <rostayob> Peaker: your haskell IDE? you mean emacs?
15:52:00 <Peaker> rostayob: unfortunately it is emacs, yes :)
15:52:04 <erus`> mike-burns: an example usage is   indexType (Tuple [Tuple [Number], Number ])     ->     IndexedTuple 0 [IndexedTuple 1 [IndexedNumber 2],IndexedNumber 3]
15:52:07 <rostayob> Peaker: you're good.
15:52:13 <mike-burns> @type length (filter (== 'x') s)
15:52:14 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Expr'
15:52:14 <lambdabot>     In the second argument of `filter', namely `s'
15:52:14 <lambdabot>     In the first argument of `length', namely `(filter (== 'x') s)'
15:52:15 <Peaker> rostayob: I find the current state terrible
15:52:31 <rostayob> :t \s -> length (filter (== 'x') s)
15:52:31 <ddarius> dolio: I don't believe in the set of natural numbers, why would it be hard to write off uncomputable reals?
15:52:31 <lambdabot> [Char] -> Int
15:52:39 <rostayob> Peaker: mah. it's not bad.
15:52:43 <rostayob> ghc-mod is nice.
15:53:05 <rostayob> Jerrry: in other words, the RHS :: Int
15:53:06 <Peaker> rostayob: Not even automatic imports after hoogling for a name
15:53:17 <rostayob> Peaker: is that really going to save time?
15:53:30 <Jerrry> rostayob: that's what I thought, but the next question is determining the return value of the length function.
15:53:38 <Peaker> rostayob: the little things add up. When I write Haskell, I spend a significant chunk of my time on little things
15:53:50 <rostayob> Peaker: little things like?
15:53:59 <rostayob> :t length
15:53:59 <lambdabot> forall a. [a] -> Int
15:54:11 <rostayob> :t \s -> length s
15:54:12 <lambdabot> forall a. [a] -> Int
15:54:14 <salvo> ciao
15:54:18 <salvo> !list
15:54:18 <dolio> ddarius: Then it's easy.
15:54:27 <Peaker> rostayob: Haskell eliminated most of the big annoyances :)   Little things like going from point-ful to point-free (or vice versa). Refactoring into a "where". Adding/removing imports.  Adding/removing language pragmas. (Each little thing takes little time, but the sum ..)
15:54:29 <rostayob> :t length []
15:54:30 <lambdabot> Int
15:54:44 <Jerrry> rostayob: I did do :t length and :t filter inside GHCI but I don't know what's next.
15:54:52 <Peaker> rostayob: each of these little things takes about 5 times more time than it should (which is just a few seconds each time, but it does add up for mE)
15:55:09 <rostayob> Peaker: wait, you want an automatic tool that turns everything in point-free form?
15:55:24 <Peaker> rostayob: I want to be able to select an expression and refactor it in various ways with a few keystrokes
15:55:46 <rostayob> Peaker: i'm not sure. i can agree with imports and language pragmas
15:55:57 <Peaker> "extract to where definition", "point-free -> select-point -> select-one-of-the-pointless-forms"
15:56:05 <rostayob> (but still, they don't take much time)
15:56:19 <rostayob> but refactoring to wheres and to point free seems like something you want to do
15:56:21 <rostayob> imho eh
15:56:34 <rostayob> it's not going to be shorter with dedicated keystrokes
15:56:39 <rostayob> and it's going to be tricky
15:56:41 <Jerrry> rostayob: Thanks, I got it now.
15:56:45 <Peaker> rostayob: For example, using (>=>) saves just a tiny bit of time, as opposed to using >>= with a new def or lambda. That time is offset by the need to go add its import
15:57:06 <Peaker> rostayob: I don't want dedicated keystrokes, I want name lookups to be an IDE operation rather than just character insertions
15:57:19 <Peaker> rostayob: and if the name happens to be in another, unimported module, I want an import to also be added
15:57:38 <rostayob> Peaker: mah, i have, being pessimistic, 10/15 imports in a file. it probably takes a time of 30 seconds to type them all over the coding time
15:57:53 <Peaker> rostayob: Many of my files are about half-import lines :)
15:58:09 <rostayob> Peaker: wow then we're different :P
15:58:22 <rostayob> maybe you should cut down on the imports! ehehe
15:58:33 <Peaker> I like small modules
15:58:45 <rostayob> yeah but half import lines sounds too much lol
15:59:06 <rostayob> also, you can have a Common module or something like that with all the utilities that you always want
15:59:08 <rostayob> and import that
15:59:12 <mike-burns> Is 10 imports in a file also the same as half import lines?
15:59:24 <rostayob> mike-burns: if your file is 20 lines long
15:59:31 <mike-burns> rostayob: Thank you for the math.
15:59:38 <rostayob> mike-burns: you're welcome.
15:59:42 <ddarius> Peaker: I would expect that eclipsefp can do that.
16:00:09 <rostayob> Peaker: anyway it'd be helpful i agree
16:00:10 <Peaker> ddarius: I couldn't get EclipseFP to work
16:00:14 <rostayob> it shouldn't be too hard to code
16:00:24 <rostayob> i think that ghc-mod already does similar things
16:00:48 <rostayob> Peaker: i just doubt it changes things radically
16:01:09 <Peaker> rostayob: I agree it doesn't -- as I said it's the sum of many little things of which imports management is just one
16:01:13 <Eduard_Munteanu> I wonder how many languages provide IDE features by interacting with the compiler, a-la Agda.
16:01:23 <merijn> Eduard_Munteanu: Epigram
16:01:26 * Eduard_Munteanu can't think of another example
16:01:30 <merijn> I guess?
16:01:30 <Eduard_Munteanu> Ah.
16:01:34 <irene-knapp> Common Lisp
16:01:49 <mike-burns> Smalltalk?
16:01:50 <rostayob> Eduard_Munteanu: i interact with the compiler in most languages with flymake.
16:01:57 <mike-burns> Maybe I don't understand.
16:02:06 <mike-burns> How else is the IDE supposed to provide language features.
16:02:09 <Eduard_Munteanu> rostayob: hm, how do you mean?
16:02:19 <rostayob> Eduard_Munteanu: compiling files on the fly and highlighting mistakes
16:02:22 <merijn> mike-burns: ghetto regex's
16:02:38 <ousado> the whole C-family, i.e. clang
16:02:40 <mike-burns> I didn't consider syntax highlighting a language feature.
16:02:40 <Eduard_Munteanu> rostayob: what I mean is, instead of using some hackish regexp to do highlighting (for example), you ask the compiler to do it.
16:02:46 <rostayob> Eduard_Munteanu: also, name completion
16:02:52 <rostayob> Eduard_Munteanu: yes, that's what i do
16:03:03 <rostayob> i compile the file and highlight the errors, if any. flymake.
16:03:10 <rostayob> well that's what emacs does
16:03:15 <ddarius> rostayob: That's not syntax highlighting.
16:03:35 <rostayob> ddarius: i think he meant highlighting of errors.
16:03:45 <rostayob> why would you ask the compiler to do syntax highlighting?
16:03:46 <Eduard_Munteanu> rostayob: no, syntax highlighting.
16:03:59 <Eduard_Munteanu> rostayob: because it's awfully complex in some languages.
16:04:03 <ddarius> rostayob: Because the compiler is the authoritative source of what the syntax is.
16:04:04 <Eduard_Munteanu> And pretty much impossible in some.
16:04:11 <ddarius> Eduard_Munteanu: Those are secondary.
16:04:21 <Eduard_Munteanu> (impossible without compiling I mean)
16:04:27 <mike-burns> You'd ask the compiler what sort of thing a term is, and then highlight based on that, I suppose.
16:04:35 <Eduard_Munteanu> Yeah, ddarius hit it right on.
16:04:43 <rostayob> Eduard_Munteanu: fair enough, syntax highlighting is really good for the languages i use. and most compilers i know don't provide that facility
16:04:47 <rostayob> not that i know of, at least
16:05:15 <rostayob> Eduard_Munteanu: still, for example in haskell, with ghc-mod there is a lot of compiler-editor interaction
16:05:19 <ddarius> rostayob: They should, among other things.
16:05:41 <ddarius> E.g. compilers should export their parsers, preferably in some standard (for the language at least) manner.
16:05:50 <mike-burns> erus`: Look into the State data type to help with threading state through (e.g. that incrementing count).
16:05:54 <rostayob> ddarius: exporting the parser is different from providing syntax highlighting
16:06:05 <Eduard_Munteanu> Yeah, even for stuff like ctags, it's probably better in the long run.
16:06:07 <ddarius> rostayob: It is, but it facilitates making a syntax highlighting tool.
16:06:15 <ddarius> rostayob: As well as many other tools.
16:06:25 <Eduard_Munteanu> And it says a lot about your compiler API.
16:06:34 <rostayob> ddarius: not really, once you have an AST, how do you take it back to its exact form? you can carry source code positions ok
16:06:39 <rostayob> but i think it'd be equally fragile
16:06:41 <Eduard_Munteanu> If you can do that, you can probably add static analysis and more.
16:06:46 <ddarius> rostayob: The point is, the compiler has information that is extremely relevant to tooling and this information is rarely exported.
16:06:50 <Jerrry> If I have: pairWith' :: Int -> [a] -> [(Int, a)]    and    pairWith' n = zip (repeat n) , what is the type of the right hand side expression? I answered [a] -> [(Int, a)]
16:07:10 <Eduard_Munteanu> GCC was (is?) notoriously difficult to plug into for such purposes.
16:07:13 <mike-burns> Jerrry: Have you been watching us use lambdabot to answer your questions?
16:07:30 <rostayob> ddarius: GHC and in general Haskell is not bad in this regards. you have the GHC api, and you have tools like haskell-src
16:07:40 <Jerrry> Yes, but I'm totally new and I can't figure this one out.
16:07:48 <rostayob> there's a lot of exposed stuff
16:07:50 <Eduard_Munteanu> What does haskell-mode use anyway?
16:07:51 <Jerrry> This is the very last question on this whole list of questions.
16:07:54 <ddarius> rostayob: The GHC API is a step in the right direction.  haskell-src-exts is useful, but the wrong thing to do.
16:08:09 <hpaste> owst pasted “Type family fun” at http://hpaste.org/56206
16:08:10 <mike-burns> Jerrry: Your answer looks right to me.
16:08:16 <Jerrry> Thanks, mike-burns.
16:08:17 <rostayob> Eduard_Munteanu: haskell-mode is all elisp. ghc-mod works in tandem with an executable that uses ghc
16:08:53 <rostayob> ddarius: why is it the "wrong thing to do"? i think it should be a separate library, but GHC should use it as well
16:09:00 <Eduard_Munteanu> rostayob: yeah, but for example in Agda's case, agda-mode opens up a ghci and calls the Agda library for everything, including highlighting.
16:09:13 <owst> So, I'm playing with type families, and getting some confusing errors - can someone take a look? http://hpaste.org/56206
16:09:23 <Eduard_Munteanu> There is some elisp, but the logic isn't there.
16:09:46 <owst> Particularly I'm confused by the third error - where has t1 come from?
16:09:58 <rostayob> Eduard_Munteanu: I agree that's a better approach. I just don't see the big problem with the current state of Haskell editing. Also, keeping an usable library tied to GHC would probably slow down things
16:10:05 <ddarius> rostayob: That would constrain GHC pretty significantly and require a lot from haskell-src-exts, but that would be one way of doing it.  The point is currently GHC's syntax can change independently of haskell-src-exts, let alone other compiler's syntaxes.  The compiler should be telling you the language -it- is using.  It is the only thing that knows.
16:10:35 <rostayob> ddarius: mhm, it sounds good, but it's a lot of work on the people who write the compilers
16:11:09 <rostayob> but yeah it'd be helpful. i think that ghc-mod is underrated anyways. it does a pretty good job
16:11:29 <hpaste> owst annotated “Type family fun” with “Type family fun (annotation)” at http://hpaste.org/56206#a56207
16:11:41 <ddarius> rostayob: It's simply exporting the parser they already wrote.  I'd be fine with it being pretty ugly.  It is some work if a "standard" interface is supported, but not that much.  Still, it being "extra" work is part of the reason so few compilers do it.=
16:11:55 <Eduard_Munteanu> rostayob: well, it's a design issue. My guess is you can provide some reasonable, small API that does stuff like that.
16:12:09 <rostayob> ddarius: I'd like to see how much work it is to extract the current parser and make it useful. probably not much...
16:12:25 <rostayob> has anybody every proposed to expose it?
16:12:26 <ddarius> rostayob: Again, that's the wrong thing to do because that will quickly get out of sync.
16:12:43 <rostayob> it's just a alex and happy file, big ones but still
16:12:51 <ddarius> You want to provide an API to the compiler to get its parsing functionality.
16:12:55 <rostayob> ddarius: i meant to do it for the first time and then keep it mantained
16:13:11 <rostayob> as an accessible part of GHC
16:14:02 <ddarius> rostayob: You don't need to "extract" anything if it is a part of GHC.
16:14:06 <rostayob> because if it's not a big burden, why wouldn't they do it? they're pretty open to proposal
16:14:16 <rostayob> ddarius: extract = make it accessible as a free-standing library
16:14:51 <ddarius> rostayob: Define "free-standing."  The whole point is that it is part of the compiler interface, not a separate library.
16:15:07 <rostayob> ddarius: import GHC.Parser; parseHaskell :: String
16:15:33 <rostayob> :: String -> HsModule
16:15:39 <rostayob> or whatever
16:17:08 <rostayob> i bet it's not that easy to make it useful for, to say, syntax highlighting
16:17:23 <rostayob> it'd be very useful anyways
16:17:29 <rostayob> but i'm not sure about the syntax highlighting :P
16:17:52 <erus`> @hoogle (!!)
16:17:53 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:17:53 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:17:53 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
16:18:03 <rostayob> since you have to revert back the AST to text, or any way identify the position of each element precisely in the buffer
16:18:03 <erus`> @hoogle [a] -> Integer -> a
16:18:03 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
16:18:04 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
16:18:04 <lambdabot> Prelude const :: a -> b -> a
16:18:22 <ddarius> rostayob: It probably isn't trivial, but at that point it no longer is a problem for the compiler writers.  And the tool writers at least have the basics of what they need, rather than having to guess or approximate it.
16:18:56 <rostayob> ddarius: what i meant is that it's probably quicker for the editors modes mantainers to hack regegxps.
16:19:32 <ddarius> rostayob: There's always a quicker way to do the wrong thing.
16:19:50 <rostayob> ddarius: i don't see anything wrong with the current syntax highlighting for tha languages i use
16:19:57 <mike-burns> "Wrong" isn't quite the right word for this.
16:20:00 <rostayob> there's nothing "wrong" with them
16:20:25 <ddarius> rostayob: Sure there is, also you are missing the point that this isn't solely or even primarily to support syntax highlighting.
16:20:45 <ddarius> That's just an example of something that can't be done correctly without knowing what the compiler knows.
16:20:50 <Saizan> btw, there are already IDE-ish libs which use the ghc-api for things like this
16:21:02 <JoeyA> And don't forget that you don't want syntax highlighting to break when the syntax is only slightly incorrect (for example,
16:21:04 <ddarius> Saizan: Yeah, I imagine GHC API does export enough to do this.
16:21:07 <rostayob> ddarius: ok, what's wrong about it? amongst the huge amounts of complaints about editors, syntax highlighting rarely shows up
16:21:23 <Eduard_Munteanu> rostayob: it is kinda wrong and stupid to use plain regexes to parse and highlight syntax, for example
16:21:46 <rostayob> ddarius: maybe you don't have perfect syntax highlighting for type families, or ConstraintKinds, but it's not a problem
16:22:19 <ddarius> rostayob: I'm not saying it is a huge problem.  I'm saying, though, that it is not a fixable problem without knowing what the compiler knows.
16:22:37 <rostayob> Eduard_Munteanu: "wrong and stupid". it works well. regexps are easy to write, probably easier than interfacing with the compiler, generate an AST which is probably really complex, reverse it back to text form somehow, highlight
16:22:59 <rostayob> Eduard_Munteanu: also, you don't need to install GHC to edit an Haskell file.
16:23:47 <rostayob> whatever. i have big doubts that that kind of thing would improve things, except if the core team is focused to make the editor experience great (e.g. Agda)
16:24:10 <Eduard_Munteanu> rostayob: it'd be a lot easier if you just told the compiler to "highlight" a source file and it returned a marked-up source.
16:24:28 <rostayob> Eduard_Munteanu: that's not the compiler's job. it's a nice utility
16:24:39 <Eduard_Munteanu> Well, for Agda, it isn't much of an option, really./
16:24:40 <rostayob> also, you need to settle on some mark-up format
16:24:50 <rostayob> each editor has to transform that mark up format into its own format
16:25:02 <mike-burns> It's not the compiler's job but it would improve other people's lives in small amounts. Is that to be avoided?
16:25:11 <rostayob> Eduard_Munteanu: I'd love it if GHC was like Agda with emacs, don't get me wrong
16:25:25 <rostayob> i'm just saying i respect the choice of the ghc team of focusing on the compiler
16:25:36 <ddarius> rostayob: The "core team" of Java designers isn't focused on it, yet Eclipse (and other Java IDEs) spend a lot of time reimplementing the Java front-end to provide a good experience.  Luckily for them, Java moves really slowly.  Again, this would also support things like looking up names, annotating with type information, any smart comment stuff, annotating with other information the compiler may know, e.g. strictness.
16:25:45 <Eduard_Munteanu> It's not a language thingy, but a compiler thingy.
16:26:00 <Eduard_Munteanu> You could probably get that into the language spec, but it's a bit too much IMO.
16:26:01 <rostayob> ddarius: yes, java has excellent code tools and they don't work with the compiler.
16:26:21 <rostayob> they just work because people put work into it (and some IDEs are great, but you need more of that stuff for java)
16:26:46 <rostayob> Eduard_Munteanu: get what in the language spec? syntax highlighting???
16:27:05 <rostayob> or "what tools to provide with the compiler"?
16:27:08 <rostayob> that sounds crazy to me
16:27:24 <Eduard_Munteanu> Yeah, I'm not suggesting that. Therefore it's ok if it's different from one implementation to another ;)
16:27:35 <ddarius> rostayob: A large amount of the work they put into it is reimplementing stuff that already exists in the Java compiler.  Also, I expect many of them do need parts of the Java environment around to, e.g. load class files.  Java -does- provide such reflection capabilities.  Finally, the IDEs will still lag the actual Java language, but Java moves really slowly so that's not a huge problem.
16:27:44 <mike-burns> Putting it in the language spec would imply that everyone who uses Haskell wants syntax highlighting.
16:29:20 <ddarius> And, yet again, this would be useful for and essentially necessary to do things just beyond syntax highlighting, such as saying where names come from, type checking and providing type information.
16:29:59 <rostayob> ddarius: while i agree with you in principle, i already do all the things you mentioned with indipendently developed tools, and i prefere the GHC team to put effor into improving GHC
16:30:01 <ddarius> Having an IDE developer have to reimplement and track changes in GHC's type system is not going to happen.  Even if someone tried, they'd fail.  The IDE would give incorrect information.
16:31:03 <funktronic> real developers don't use ides. they use a hex editor and write their own debuggers
16:31:25 <rostayob> "a needle and a steady hand"
16:31:48 <merijn> yada, yada, emacs ctrl-alt-meta-butterfly/obligatory XKCD reference
16:31:58 <funktronic> but honestly i'm glad i'm not a real developer. they'll pry my VS from my cold dead body
16:32:25 <mike-burns> Oh man we had gone so long without mentioning XKCD, too. Oh well.
16:32:51 <ddarius> rostayob: I'm not saying GHC should provide a syntax highlighter and pop-up type information, I'm saying they should provide an API to the information the compiler already has to support these things, otherwise you get incompatible implementations being written by tool developers.  It's not just IDEs as well, think static analysis tools.  Luckily, GHC already largely does, so apparently they thought it was important en
16:32:51 <ddarius> ough to do.  Also luckily, most of this work doesn't require the Simons to do.
16:32:55 <merijn> Personally, I'm ditching whatever IDE/editor the minute someone produces a workable structural editor :>
16:33:19 <funktronic> ddarius: so roslyn for haskell basically?
16:33:27 <rostayob> ddarius: ok, so you're not arguing for an agda kind of thing
16:33:36 <rostayob> which requires a lot of effort, i suppose
16:33:46 <rostayob> i'm all up for a good GHC api. never said the contrary
16:34:00 <ddarius> I don't know what roslyn is.
16:34:17 <funktronic> ddarius: http://blogs.msdn.com/b/visualstudio/archive/2011/10/19/introducing-the-microsoft-roslyn-ctp.aspx
16:34:27 <merijn> rostayob: His point was that currently the APIs implementing this and the code used by GHC are not the same. This means they can diverge with all the annoyances associated with it
16:34:41 <ddarius> rostayob: Yes, something like that.
16:35:16 <rostayob> mah, going to bed
16:36:35 <Nisstyre> Is there a better way of doing this? http://codepad.org/l1RAWyru
16:37:01 <Nisstyre> formatting fixed: http://codepad.org/klJnJmgU
16:37:09 <parcs`> Nisstyre: yes, with top-level type annotations
16:38:15 <mike-burns> @hoogle splitOn
16:38:15 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
16:38:16 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
16:38:26 <owst> Can I rudely bump my associated type-synonym question again? I'm stumped! http://hpaste.org/56207
16:38:58 <mike-burns> owst: I simply don't know!
16:39:14 <mike-burns> Nisstyre: Maybe you can use the `splitOn' function from the split package, and `take'.
16:39:20 <mike-burns> Hm, not `take'.
16:39:23 <irene-knapp> looking, owst, but no promises
16:39:27 <ezyang> Is a free term algebra the same thing as a free Eilenberg-Moore algebra?
16:39:31 <owst> mike-burns: thanks for the look anyway :)
16:40:15 <owst> irene-knapp: the desired output should be ["a_1", "a_2"...]
16:40:54 <irene-knapp> owst: so I see.  hmm.  I need to play with compiling this to test my theory? one sec
16:40:58 <parcs`> :t \xs x n -> curry (++) . second (take n) . break (== x) $ xs
16:40:59 <lambdabot> forall b a. (Monoid b, Eq a) => [a] -> a -> Int -> b -> (([a], [a]), b) -> (([a], [a]), b)
16:41:25 <dolio> ezyang: No.
16:41:38 <Cody_> Wow, Haskell is awesome!. Just wrote code to multiply any matrix by another, 3 lines. My Java code was 50 lines!
16:41:55 <mike-burns> Cody_: Which is easier to understand?
16:42:04 <parcs`> :t \xs x n -> uncurry (++) . second (take n . drop 1) . break (== x) $ xs
16:42:05 <lambdabot> forall a. (Eq a) => [a] -> a -> Int -> [a]
16:42:18 <Cody_> Haskell. Took a while
16:42:25 <Cody_> Originally Java
16:42:32 <Cody_> because it is so explicit
16:43:15 <ezyang> dolio: OK.
16:43:38 <dolio> ezyang: A free term algebra is, I think, given by a functor F, and it's an F-branching tree.
16:44:22 <dolio> The free Eilenberg-Moore algebra is for a monad M, and it's MA, together with MMA -> MA given using join.
16:44:41 <hpaste> irene-knapp annotated “Type family fun” with “Type family fun (annotation) (annotation)” at http://hpaste.org/56206#a56208
16:44:55 <erus`> whats the word for 'does the same thing every time'? deterministic?
16:45:01 <ezyang> I don't think I understand what people mean when they say "algebra"
16:45:07 <irene-knapp> owst: it works now
16:45:27 * owst looks :)
16:45:35 <irene-knapp> owst: I don't know that I can exactly explain why it doesn't work with type synonym instances, but it looked to me like data instances were what you really wanted anyway
16:45:48 <irene-knapp> owst: since you were declaring one type for each instance, heh
16:46:18 <dolio> ezyang: An algebra has an associated signature. In category theory it's usually given by a functor or a monad. An algebra over a functor F is an object A together with a mapping FA -> A.
16:46:24 <irene-knapp> owst: basically what the error message was telling you was that the type of genFresh is more polymorphic than the type of freshVars
16:47:09 <dolio> An Eilenberg-Moore algebra for a monad M is an object A together with a mapping MA -> A that commutes with eta and mu in appropriate ways.
16:47:24 <hpaste> Cody pasted “Matrix Multiplication” at http://hpaste.org/56209
16:47:50 <ezyang> OK, I guess I don't really understand how to manipulate algebras.
16:48:10 <ezyang> They form a category with homomorphisms as arrows, right?
16:48:13 <ddarius> eZet: Thehre are a -lot- of different technical meanings for "algebra" in mathematics.
16:48:20 <ddarius> Not to mention the non-technical meanings.
16:48:46 <owst> irene-knapp: Interesting - it seems I don't understand the two flavours of type families then! :)
16:48:49 <parcs`> owst: with associated type synonyms, the compiler doesn't know which instance of VarFoo to use because associated type synonyms are not injective
16:48:54 <ezyang> ddarius: Yeah. I'm probably interested in the meanings that i'm most likely to figure out the intuition of.
16:49:06 <parcs`> owst: associated data types are, however
16:49:09 <dolio> I expect this is the context: http://personal.cis.strath.ac.uk/~raa/posts/2012-01-06-streams.html
16:49:10 <irene-knapp> owst: hehe np!  yeah, so, there's actually three flavours :) one for type, one for newtype, one for data
16:49:25 <ddarius> ezyang: The one that would be most intuitive would probably be the one underlying term algebra and algebraic semantics.
16:49:27 <irene-knapp> owst: they all have similar syntax but slightly different restrictions on what they can do
16:49:41 <irene-knapp> owst: as parcs` just said
16:50:04 <ddarius> ezyang: But I wasn't saying there are a bunch of different definitions for the same thing (there is that too) but there are a bunch of different things that are called algebras.
16:50:23 <ddarius> That may or may not have something to do with other things called algebras.
16:50:26 <ezyang> ...d'oh.
16:50:37 <ezyang> Now that's confusing :o)
16:51:34 <owst> irene-knapp, parcs`: thanks for help, much appreciated. I'm going to go and read/think some more!
16:51:40 <irene-knapp> owst: np np!
16:51:51 <irene-knapp> owst: what are you using your type-level letters for? :D
16:52:15 <ddarius> ezyang: If you want to know about algebras as in the things in "initial algebras" then that is what dolio is talking about.
16:52:30 <ezyang> I *think* so?
16:54:27 <owst> irene-knapp: A type-checker I'm writing, for a language with type-variables, and "annotations" on types, which are basically equations (including variables).
16:54:37 <irene-knapp> oh neat!
16:54:50 <ezyang> I feel like I'm swimming around a lake of examples and I haven't really seen the underlying structure yet.
16:55:31 <owst> If you've seen F#'s measures, they're the inspiration. If you haven't, check them out, they're cool :)
16:55:54 <irene-knapp> I shall!
16:56:22 <ddarius> ezyang: I would start with term algebras, which should be pretty easy to understand.  That leads naturally into initial algebras and general algebras.
16:56:32 <ezyang> k
16:56:38 <ddarius> ezyang: In fact, reading something on algebraic semantics is probably useful.
16:56:59 <ezyang> Specific book recommendation? Otherwise I'll pick a random one off the library
16:57:00 <owst> irene-knapp: There's a good introduction tutorial paper by the author, Andrew Kennedy available somewhere
16:57:40 <erus`> i duno why !! is not `genericIndex`
16:57:48 * irene-knapp nods, nice
16:58:32 <ddarius> ezyang: This isn't the best book in the world and it doesn't touch on the category theory, but it is pretty concrete and readable. http://www.divms.uiowa.edu/~slonnegr/plf/Book/
16:58:39 <ddarius> Chapter 12 is Algebraic Semantics.
16:59:22 <ezyang> ok, I'll start there.
17:00:17 <ezyang> Oh-ho, I see one reason why I'm getting slightly confused; the algebras used in program analysis tend to be really simple.
17:00:37 <dgpratt> what are these .yml files in this yesod project?
17:01:43 <ddarius> ezyang: What's an example of an "algebra used in program analysis" to your mind?
17:04:44 <ezyang> ddarius: Recursion schemes.
17:05:51 <ddarius> ezyang: Okay.  The term "program analysis" makes me think of things like static analysis and abstract interpretation.
17:06:03 <nh2> byorgey: yay, I could implement local in that context!
17:06:08 <ezyang> Ah, sure.
17:07:03 <ddarius> Incidentally, recursions schemes are not algebras but rather algebra homomorphisms, but anyway, understanding term algebras and term algebra homomorphisms is a first step.  Then understanding the categorical abstraction of them is the next step.
17:13:20 <roconnor_> @hoogle local
17:13:21 <lambdabot> System.IO localeEncoding :: TextEncoding
17:13:21 <lambdabot> GHC.IO.Encoding localeEncoding :: TextEncoding
17:13:21 <lambdabot> Data.Time.LocalTime module Data.Time.LocalTime
17:17:42 <ezyang> Hmm, term algebras seem reminiscent of Herbrand universes.
17:17:52 <monochrom> yeah
17:20:15 <zzo38> Stop lying about monads!
17:20:24 <monochrom> haha
17:22:26 <ddarius> ezyang: They should be.
17:22:50 <ezyang> Oh ha, the Wikipedia article says they're the same thing. OK, glad to see that correspondence.
17:28:32 <nh2> do we have an equivalent to the Django pony?
17:28:51 <mike-burns> No.
17:29:46 <Entroacceptor> we have http://www.bestechvideos.com/thumbnails/0000/1881/6cp16i6sbjaexu6otmxn3ib6kt.jpg
17:29:48 <mike-burns> http://www.reddit.com/r/haskell/comments/mn8p1/a_mascot_for_haskell/ - this was the debate.
17:32:14 <ezyang> So, if I understand correctly, the term algebra for zero and succ corresponds to a carrier set of ground terms, but *not* to naturals
17:32:21 <ezyang> since the correspondence is not 1-to-1
17:32:47 <ezyang> (erm, toss in some extra operations like addition)
17:33:46 <copumpkin> :t floor
17:33:47 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:33:50 <erus`> @hoogle either
17:33:50 <lambdabot> Prelude data Either a b
17:33:50 <lambdabot> Data.Either data Either a b
17:33:50 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:33:58 <copumpkin> > floor (5.6 :: CReal)
17:33:59 <lambdabot>   5
17:35:26 <ezyang> And the evaluation function for a term algebra is the simplest possible, the identity function?
17:35:53 <erus`> @hoogle Either a b -> a
17:35:54 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
17:35:54 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:35:54 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:38:51 * cmccann wonders why the standard libraries have fromJust but not fromNothing
17:38:58 <cmccann> it's only slightly less sensible, really
17:39:02 <luite> hehe
17:39:12 <luite> that was suggested before
17:39:33 <luite> fromNothing (Just _) = error "fromNothing: Just", fromNothing _ = undefined
17:39:37 <cmccann> fromNothing = maybe () (error "fromNothing: Just")
17:39:39 <ezyang> In the beginning, there was nothing.
17:39:44 <Cody_> :t scanl
17:39:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:39:50 <Cody_> :t scanl1
17:39:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
17:40:12 <luite> I guess () would also be acceptable :)
17:40:15 <cmccann> yeah
17:40:26 <cmccann> since Maybe a is equivalent to Either () a
17:40:52 <cmccann> as long as it crashes the program when applied to (Just _) for absolutely no good reason whatsoever
17:41:04 <byorgey> > scanl f z [a,b,c,d]
17:41:05 <cmccann> since it's supposed to be a counterpart to fromJust after all
17:41:05 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
17:41:10 <byorgey> > scanl1 f [a,b,c,d]
17:41:11 <lambdabot>   [a,f a b,f (f a b) c,f (f (f a b) c) d]
17:41:26 <byorgey> > scanl (+) z [a,b,c,d]
17:41:27 <lambdabot>   [z,z + a,z + a + b,z + a + b + c,z + a + b + c + d]
17:41:34 <byorgey> > scanl1 (+) [a,b,c,d]
17:41:35 <lambdabot>   [a,a + b,a + b + c,a + b + c + d]
17:41:58 <byorgey> Cody_: you can see what scanl and scanl1 do there
17:41:59 <mike-burns> Do you have a use for fromNothing?
17:42:08 <Cody_> Sorta
17:42:24 <cmccann> mike-burns, as much as I do for fromJust
17:42:52 <mike-burns> I use fromJust all the time but have never wanted fromNothing, which is why I ask.
17:42:59 <ddarius> ezyang: The term algebra for arithmetic expressions would include things like plus and multiply.  You can say that the natural numbers are the term algebra for zero and succ.
17:43:15 <ezyang> right-o
17:43:21 <Cody_> transpose [[1,2,3],[3,4,5],[7,8,9]]
17:43:25 <cmccann> mike-burns, why on earth would you do that
17:43:28 <Cody_> ???
17:43:47 <byorgey> Cody_: what about it?
17:43:52 <mike-burns> :t fromJust
17:43:53 <lambdabot> forall a. Maybe a -> a
17:43:55 <Cody_> it didn't evaluate
17:44:02 <byorgey> Cody_: you forgot the > in front
17:44:04 <mike-burns> cmccann: Oh, I was thinking of something else.
17:44:13 <cmccann> mike-burns, fromMaybe perhaps
17:44:16 <mike-burns> Yeah!
17:44:16 <cmccann> :t fromMaybe
17:44:17 <lambdabot> forall a. a -> Maybe a -> a
17:44:18 <Cody_> transpose > [[1,2,3],[3,4,5],[7,8,9]]
17:44:24 <mike-burns> I use fromMaybe all the time.
17:44:28 <Cody_> transpose -> [[1,2,3],[3,4,5],[7,8,9]]
17:44:31 <mike-burns> You're right, why the imbalance.
17:44:36 <byorgey> Cody_: I mean in front of the whole thing, lambdabot only pays attention to expressions if you put > in front of them
17:44:49 <cmccann> yes, fromMaybe is very nice
17:44:50 <byorgey> > transpose [[1,2,3],[3,4,5],[7,8,9]]
17:44:50 <lambdabot>   [[1,3,7],[2,4,8],[3,5,9]]
17:44:52 <Cody_> > transpose [[1,2,3],[3,4,5],[7,8,9]]
17:44:53 <lambdabot>   [[1,3,7],[2,4,8],[3,5,9]]
17:44:55 <byorgey> right =)
17:45:02 <cmccann> most misguided uses of fromJust should be fromMaybe instead
17:45:17 <Cody_> Why is transpose useful, other than multiplying matrices?
17:45:44 <Cody_> > transpose [[3,4],[3,5]
17:45:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:45:50 <Cody_> > transpose [[3,4],[3,5]]
17:45:51 <lambdabot>   [[3,3],[4,5]]
17:46:15 <byorgey> > transpose ["hello", "there", "Cody_"]
17:46:15 <lambdabot>   ["htC","eho","led","lry","oe_"]
17:46:28 <byorgey> see, it's quite useful
17:46:33 <Cody_> encryption?
17:46:34 <Ke> cmccann: what if you want the code to crash if fromJust fails
17:46:42 <JoeyA> When I do cabal update, where is the package list downloaded to?
17:46:45 <Cody_> can you "un"transpose something?
17:47:04 <JoeyA> Oh, 00-index.tar
17:47:04 <cmccann> Ke, I don't want my code to crash
17:47:08 <byorgey> > tranpose (transpose ["hello", "there", "Cody_"])
17:47:09 <lambdabot>   Not in scope: `tranpose'
17:47:13 <byorgey> > transpose (transpose ["hello", "there", "Cody_"])
17:47:14 <lambdabot>   ["hello","there","Cody_"]
17:47:23 <Cody_> Sweet
17:47:26 <Ke> cmccann: crash is awesome is there is no way to handle
17:47:32 <byorgey> Cody_: transpose is its own inverse for lists whose elements are all the same length
17:47:41 <Axman6> NB: transpose . transpose != id
17:47:46 <byorgey> > transpose (transpose ["hi", "there", "Cody"])
17:47:47 <lambdabot>   ["hiere","thdy","Co"]
17:47:50 <ezyang> Oh-ho! Grammars are algebras
17:47:52 <byorgey> it does weird things otherwise
17:47:52 <Ke> cmccann: eg. internal error
17:48:00 <Cody_> > transpose [[2,4],[4,5,3]]
17:48:01 <lambdabot>   [[2,4],[4,5],[3]]
17:48:23 <Cody_> > transpose [[2,4,5],[4,5]]
17:48:24 <lambdabot>   [[2,4],[4,5],[5]]
17:48:39 <Cody_> Why didn't 5 tack on the other 5?
17:49:00 * cmccann notes that transpose would just be sequence for ZipList
17:49:03 <cmccann> well, sequenceA
17:49:19 <ezyang> OK, I think that helped a little.
17:49:31 <shachaf> Cody_: Why would it?
17:49:33 <byorgey> Cody_: the nth list in the output consists of all the nth elements in the input.
17:49:42 <Cody_> I see
17:49:46 <byorgey> > transpose [[1,2,3], [1,2], [1,2,3,4]]
17:49:47 <lambdabot>   [[1,1,1],[2,2,2],[3,3],[4]]
17:50:13 <Cody_> I see, makes perfect sense
17:50:16 <cmccann> Ke, I'm not sure how you'd get any error that dire using fromJust
17:50:16 <mike-burns> Whoa, cabal-dev is perfect.
17:50:30 <mike-burns> You all should have yelled at me for not using it months ago.
17:50:33 <ezyang> Initial algebras seem pretty simple too now.
17:51:17 <Cody_> let test x = print x
17:51:20 <Cody_> test 4
17:51:34 <Cody_> doesn't work here I guess
17:51:38 <mike-burns> > let test x = print x in test 4
17:51:39 <lambdabot>   <IO ()>
17:51:41 <mike-burns> You need >
17:51:49 <ezyang> Oh. Eilenberg-Moore algebras are pretty simple then.
17:51:50 <mike-burns> :t print
17:51:51 <lambdabot> forall a. (Show a) => a -> IO ()
17:52:02 <ezyang> Most typeclasses form algebras, don't they?
17:52:05 <Cody_> > let test x = print x in test 4
17:52:05 <lambdabot>   <IO ()>
17:52:08 <Cody_> 4
17:52:13 <mike-burns> I can only hope that you expected lambdabot to give you an   IO ()  in response to that.
17:52:25 <shachaf> mike-burns: I thought lambdabot was non-deterministic.
17:52:26 <Cody_> Lol
17:52:39 <mike-burns> shachaf: Sure seems that way sometimes!
17:53:13 <Cody_> That'd be cool though it was like an open GHCi and could distinguish code via >
17:53:16 <shachaf> > let test x = print x in tеst 4
17:53:17 <lambdabot>   4
17:53:34 <Cody_> And be able to use other peoples functions
17:53:51 <mike-burns> Sure, you can define things globally.
17:53:57 <byorgey> ezyang: I wouldn't say most.  Some certainly do.
17:54:01 <mike-burns> Cody_: http://www.haskell.org/haskellwiki/Lambdabot
17:54:07 <ezyang> "well, the good ones, anyway"
17:54:10 <shachaf> If you want to talk about lambdabot, you s hould probably do so in /msg or #haskell-overflow.
17:55:23 <ezyang> Does the preservation of an Eilenberg-Moore algebra correspond to the fact that there exists a ReaderT monad transformer?
17:55:45 <Cody_> > let degToRad deg = deg * pi / 180 in degToRad 180
17:55:46 <lambdabot>   3.141592653589793
17:56:24 <byorgey> ezyang: heh.  anyway, yes, making a type class corresponding to a particular algebra is a nice trick.  Then every instance can be seen as an algebra homomorphism from the initial algebra.
17:56:37 <ezyang> hoo hoo hoo, that's right!
17:56:43 <byorgey> it's a lovely way to structure domain-specific languages and give them multiple semantics.
17:57:00 <ezyang> Ah, that is lovely.
17:57:05 <ezyang> So simple too.
17:57:37 <Cody_> > let triangles x = scan1 (+) [1..x] in triangles 12
17:57:38 <lambdabot>   Not in scope: `scan1'
17:57:45 <Cody_> > let triangles x = scanl (+) [1..x] in triangles 12
17:57:45 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
17:57:46 <lambdabot>    arising from a ...
17:57:57 * byorgey can hear ezyang's brain expanding
17:58:06 <cmccann> byorgey, what's it sound like
17:58:25 <byorgey> kind of like wumwumwumwooooooopclick
17:58:36 <ezyang> Oh, I see why f-algebras are recursion schemes now.
17:58:47 <ezyang> Is the carrier set here Hask?
17:58:47 <cmccann> ok. yes, that is pretty much the sound my brain makes when expanding as well.
17:59:08 <Cody_> What is the maximum values that an Integral and Int can have?
17:59:18 <ezyang> Integral is bounded by machine memory
17:59:22 <ezyang> Int is arch dependent.
17:59:31 <JoeyA> > maxBound :: Int
17:59:32 <lambdabot>   9223372036854775807
17:59:38 <Cody_> > let fac n = product[1..n] in fac 100
17:59:39 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
17:59:40 <JoeyA> (on 32-bit systems, it's usually 2^32-1)
17:59:42 <ddarius> Cerebral edema is a serious condition.
17:59:43 <Cody_> > let fac n = product[1..n] in fac 1000
17:59:44 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
17:59:47 <Cody_> > let fac n = product[1..n] in fac 10000
17:59:47 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
17:59:51 <Cody_> > let fac n = product[1..n] in fac 100000
17:59:52 <shachaf> JoeyA: Probably 2^31-1
17:59:54 <lambdabot>   mueval-core: Time limit exceeded
17:59:57 <Cody_> Comon!
17:59:58 <ddarius> ezyang: F-algebras aren't recursion schemes.
18:00:00 <JoeyA> err, right
18:00:13 <ddarius> Homomorphisms from the initial F-algebra are folds.
18:00:13 <byorgey> ezyang: the carrier for an f-algebra is a particular type.
18:00:40 <ddarius> Integral is a type class.
18:00:47 <ezyang> OK, I still need to get a better separation between algebras and homomorphisms
18:01:03 <ezyang> I guess I'm always considering every algebra w.r.t. the initial one.
18:01:31 <ddarius> (Also, unfolds are homomorphisms into the final coalgebra.)
18:04:42 <mike-burns> Cody_: You can PM lambdabot .
18:05:25 <ezyang> OK, where am I supposed to go from here?
18:05:34 <ezyang> I'm still not sure why the carrier for an f-algebra is a particular type.
18:06:06 <Cody_> mike-burns: Thanks
18:06:21 <Cody_> mike-burns: Probably annoying to do in here I guess
18:07:17 <ddarius> ezyang: You are supposed to get a good understanding of defining term algebras and term algebra homomorphisms.  Then you need to see how they are a special case of initial F-algebras and homomorphisms from it.  I.e. you should be able to map the parts of each of these things to the other.
18:07:54 <ezyang> OK, I think term algebras are OK, term algebra homomorphisms are kind of mushy
18:09:25 <ddarius> Also, when I suggested this route, I was not intending it to be something that would take an hour and then you'd be done.
18:10:09 <cl1> > foldr (+) [] (repeat 1)
18:10:10 <lambdabot>   No instance for (GHC.Num.Num [a])
18:10:10 <lambdabot>    arising from a use of `e_11' at <inter...
18:10:14 <cmccann> yes, you should allot at least two hours to the effort
18:10:20 <ezyang> *snerk*
18:10:24 <cl1> why won't that ^^^ work?
18:10:42 * cl1 knows it will run forever
18:10:53 <ezyang> I just want enough to put a Christmas tree, so I can hang future experiences on it.
18:11:06 <cl1> it says i need an instance declaration, how do i apply that?
18:11:31 <ddarius> ezyang: This shouldn't take you more than a day or two, but it will probably take more than an hour or two of reading and thinking.
18:11:43 <ddarius> And even then, there will be large gaps.
18:12:27 <blalb> cl1,  what is 1 + []?
18:13:01 <cl1> oh, i see what i did there, thanks blalb
18:13:06 <ezyang> ddarius: Well, I do feel like I have a lot of the pieces already lying around in my brain.
18:15:16 <ezyang> Hmm, I need some exercises
18:15:20 <ddarius> ezyang: If you were starting completely from scratch, it would take more than a day or two.  Term algebras are something that are extremely natural to Haskell programmers.
18:16:47 <ezyang> Hmm... it seems the functor is sufficient to encode the operations of a term algebra.
18:17:04 <ezyang> If you use the Rec operator?
18:18:20 <ezyang> Oh, but those are functors too. (Irrelevant, I see.)
18:20:20 <ezyang> OK, so if in Haskell I wanted to make an F-algebra out of a term algebra, I'd write an ADT which generates the ground terms (constructors are nullary to n-ary functions), say it's a functor and call it a day.
18:20:38 <ezyang> Erm, no, not yet.
18:20:52 <ezyang> I also need F A -> A. I wonder what that is. Maybe the evaluation function in term algebraS?
18:22:05 <ezyang> Oh, I see, there are two term algebras involved
18:22:36 <ezyang> So, for the algebra of arithmetic, you have the term algebra N with Zero and Succ, and then the term algebra on top of N with Plus, etc.
18:22:57 <ezyang> The latter is an F-algebra because it is a functor F N with an evaluation function F N -> N
18:23:07 <ezyang> since N is canonical
18:23:08 <ddarius> No.
18:23:12 <ezyang> Aw man :-(
18:23:17 <hpaste> Cody pasted “Sum of Square minus Square of Sums” at http://hpaste.org/56211
18:23:35 <Cody_> Any reason why its throwing errors? ^
18:23:45 <ddarius> ezyang: What is Σ and where does it fit into the picture?
18:23:59 <mike-burns> Cody_: Also add the errors to the paste.
18:24:11 <Cody_> hold on
18:24:47 <ezyang> OK, I've compressed the signature and the algebra, haven't I.
18:24:58 <mike-burns> :t sum
18:24:59 <lambdabot> forall a. (Num a) => [a] -> a
18:25:23 <mike-burns> Cody_: You're passing an instance of Num to `sum' instead of a list, in (sum b)
18:26:30 <mike-burns> Also also in `map (^2) a'. Same problem.
18:26:39 <hpaste> Cody pasted “Sum of Square minus Square of Sums” at http://hpaste.org/56212
18:27:47 <mike-burns> > [ sum a | a <- [1..10] ]
18:27:48 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
18:27:48 <lambdabot>    arising from a use...
18:27:56 <mike-burns> That's the error you're seeing.
18:28:02 <Cody_> Correct
18:28:08 <mike-burns> `a' is a number, not a list. You can't sum a number.
18:28:38 <mike-burns> Is the type of `problem6' correct?
18:28:45 <Cody_> yes
18:29:11 <mike-burns> So `x' is a list?
18:30:01 <Cody_> x is a number
18:30:16 <mike-burns> That's not what the type of `problem6' says.
18:30:39 <mike-burns> [t]  -- that's a list, not a number.
18:30:44 <Cody_> I know that
18:30:56 <ezyang> Bleh, I need a text that is more definition dense.
18:30:56 <Cody_> > sum [1..10]
18:30:58 <lambdabot>   55
18:31:09 <mike-burns> Since   x :: [t]  that means that x is a list, not a number.
18:31:40 <Cody_> > sum (map (^2) [1..10])
18:31:41 <lambdabot>   385
18:31:50 <Cody_> x would be 10
18:32:00 <shachaf> > sum . map (^2) . enumFromTo 1 $ 10
18:32:04 <lambdabot>   mueval-core: Time limit exceeded
18:32:13 <shachaf> Whatever you say, lambdabot.
18:32:17 <mike-burns> Hah.
18:32:44 <mike-burns> Cody_: So should it be:   problem6 :: (Num a) => a -> a    ?
18:33:14 <Cody_> Supposed to be
18:33:30 <mike-burns> :t sum
18:33:33 <lambdabot> forall a. (Num a) => [a] -> a
18:34:25 <mike-burns> Well in that case you don't want it to produce the result of a list comprehension, since that's of type  [a]   .
18:34:41 <Cody_> > (sum ([1..10])) ^2
18:34:42 <lambdabot>   3025
18:34:50 <mike-burns> But `sum' can take an `[a]' and produce an `a' .
18:35:07 <Cody_> > (sum ([1..10])) ^2 - sum(map (^2) [1..10])
18:35:08 <lambdabot>   2640
18:35:16 <Cody_> > (sum ([1..100])) ^2 - sum(map (^2) [1..100])
18:35:17 <lambdabot>   25164150
18:35:35 <mike-burns> Excellent.
18:38:27 <Cody_> :t problem6
18:38:27 <lambdabot> Not in scope: `problem6'
18:38:42 <mike-burns> :t [a | a <- [1..10]]
18:38:43 <lambdabot> forall t. (Num t, Enum t) => [t]
18:38:47 <Cody_> problem6 :: (Num a, Enum a) => a -> a
18:39:38 <Cody_> > let problem6 x = sum([1..x])^2 - sum(map (^2) [1..x]) in problem6 1000
18:39:39 <lambdabot>   250166416500
18:39:46 <ezyang> OK, the signature doesn't actually specify the carrier set.
18:39:46 <mike-burns> Nice.
18:40:04 <Cody_> Don't want to sound like a noob, but what is Enum?
18:40:09 <ezyang> This means we can swap out non-isomorphic things.
18:40:11 <ezyang> @src Enum
18:40:12 <lambdabot> class  Enum a   where
18:40:12 <lambdabot>     succ                     :: a -> a
18:40:12 <lambdabot>     pred                     :: a -> a
18:40:12 <lambdabot>     toEnum                   :: Int -> a
18:40:12 <lambdabot>     fromEnum                 :: a -> Int
18:40:14 <lambdabot> [3 @more lines]
18:40:24 <Cody_> isomorphic?
18:40:33 <ezyang> sorry, that was @ddarius
18:40:53 <Cody_> :t sum
18:40:54 <lambdabot> forall a. (Num a) => [a] -> a
18:40:58 <mike-burns> Cody_: It's the typeclass that makes [1..x] work. It describes how to get from 1 to the successor of 1, all the way up to x .
18:41:01 <mike-burns> > succ 1
18:41:02 <lambdabot>   2
18:41:17 <Cody_> > succ (succ 1)
18:41:18 <lambdabot>   3
18:41:23 <Cody_> :t succ
18:41:24 <lambdabot> forall a. (Enum a) => a -> a
18:42:02 <Cody_> for all a where a uses an instance of the class "enum", we return a
18:42:03 <Cody_> right?
18:42:08 <shachaf> @remember kmc "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
18:42:08 <lambdabot> Nice!
18:42:42 <Cody_> What did lambdabot just do?
18:43:01 <mike-burns> @quote curry-howard
18:43:01 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
18:43:04 <mike-burns> It did that.
18:43:31 <mike-burns> Anyway, there are lots of ways to read a function's type.
18:43:54 <mike-burns> I usually say "succ is from a to a, where a is an instance of Enum". To myself. Aloud.
18:44:10 <ezyang> So, the term algebra defines a carrier set based on a signature
18:44:13 <Cody_> Whats the quickest way to check if a number is Prime.
18:44:20 <cmccann> mike-burns, aloud? that's silly.
18:44:24 <cmccann> you should sing it instead.
18:44:25 <Cody_> mike-burns: That's what I do
18:44:29 <mike-burns> Cody_: http://isitpri.me/
18:44:38 <cl1> functions are right or left associative?
18:44:50 <Cody_> Lol,  I mean in pseudo code
18:44:57 <mike-burns> cmccann: My coworkers will love that suggestion.
18:45:03 <cl1> foo bar baz == (foo bar) baz .. correct?
18:45:03 <BMeph> cl1: Yes.
18:45:20 <BMeph> cl1: Yes.
18:45:32 * cl1 is trying to understand foldl written in terms of foldr
18:48:14 <Jafet1> @quote Jafet succ
18:48:15 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
18:48:36 <Cody_> :t factors
18:48:37 <lambdabot> Not in scope: `factors'
18:48:40 <Cody_> :t factor
18:48:40 <lambdabot> Not in scope: `factor'
18:49:14 <ezyang> ddarius: OK, try to: an F-algebra is a unique homomorphism from the term algebra of that Sigma to some other algebra of signature Sigma. Sigma is isomorphic to the functor.
18:49:19 <ezyang> *try two
18:51:27 <Cody_> :t filter
18:51:27 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:52:16 <Cody_> > filter (1)
18:52:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
18:52:17 <lambdabot>    arising from the literal `1'...
18:52:30 <Cody_> > filter (>1) [1..10]
18:52:30 <lambdabot>   [2,3,4,5,6,7,8,9,10]
18:52:57 <Cody_> > filter (mod 1 2 ==0)  [1..10]
18:52:58 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
18:52:58 <lambdabot>         against inferred ...
18:53:02 <ezyang> I don't think that's quite right either, but I think it's closer.
18:53:16 <Cody_> > filter (mod 2 == 0)  [1..10]
18:53:17 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
18:53:17 <lambdabot>         against inferred ...
18:53:20 <mike-burns> :t (>1)
18:53:21 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
18:53:24 <mike-burns> :t (mod 1 2 == 0)
18:53:24 <lambdabot> Bool
18:53:30 <mike-burns> :t const
18:53:31 <lambdabot> forall a b. a -> b -> a
18:53:46 <Cody_> > filter ((mod 2 == 0) == True)  [1..10]
18:53:47 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
18:53:47 <lambdabot>         against inferred ...
18:55:16 <mike-burns> > filter (\x -> x `mod` 2 == 0) [1..10]
18:55:17 <lambdabot>   [2,4,6,8,10]
18:56:17 <mike-burns> Goodbye, irccloud.
18:56:32 <ezyang> ddarius: No, I still think my original statement is closer. The functor is the "syntax tree" generated by the signature, and the morphism tells me how to take F A to A (the chosen carrier set)
18:56:50 <ezyang> In the case of a term algebra this is the identity.
18:57:01 <cmccann> network problems always seem so dramatic in a channel with this many people idling
18:58:17 <ezyang> so, given a signature <N,[Succ,Zero]> for nats, I can make some silly algebras.
18:58:51 <ezyang> For example, given an arbitrary total ordering of nats, I get an algebra for that.
19:00:49 <ezyang> I'm not sure why a one-to-one mapping on operations is rqeuired, however. Suppose I have a silly signature <B,[true,false]>, it seems I should be permitted to select 1 as my carrier set and map true and false to the same thing.
19:00:55 <Cody_> >let problem7 x = [a | a <- [1..x], prime a == True] in problem7 10
19:01:04 <Cody_> Sorry
19:01:08 <Cody_> Ignore that
19:02:37 * cmccann wonders why there are like fifty libraries on hackage for parsing command line arguments and yet he doesn't really like any of them
19:02:51 <mike-burns> Write another!
19:02:59 <mike-burns> cmdargs is in the top two.
19:03:12 <shachaf> cmccann: I vaguely recall not liking any of them either.
19:03:18 <shachaf> Some of them are insane.
19:04:49 <cmccann> I'd like something that handles typical flag/argument style, can actually handle parsing the values instead of just giving me a bunch of strings, and isn't full of incomprehensible magic that tries to do everything behind my back
19:05:15 <shachaf> cmccann: Surely you want a little bit of unsafePerformIO in there?
19:05:46 <ezyang> And indeed, when I've seen this in logic, all you need is an interpretation function, not one that is one-one
19:06:18 <cmccann> shachaf, noooooot really :I
19:06:22 * cmccann sighs
19:07:00 <tgeeky> question:  when I'm changing a package to compile on 7.4, and the solution is (mostly) peppering Eq constraints around.. is there a faster way to do this other than adding them by hand (or, by regex or something)
19:07:34 <shachaf> tgeeky: If you're changing the types of a bunch of functions, there's not much you can do other than changing their types.
19:07:45 <cmccann> tgeeky, just stick "instance Eq a" in there somewhere, that ought to do it
19:09:27 <roconnor_> > tails []
19:09:28 <lambdabot>   [[]]
19:12:01 <Cody_> I have a function that tells if N is a prime number or not. How do I take the first prime number?
19:12:25 <mike-burns> :t take
19:12:26 <lambdabot> forall a. Int -> [a] -> [a]
19:12:33 <shachaf> Cody_: 2
19:12:36 <ezyang> @hoogle (a -> Bool) -> [a] -> a
19:12:37 <cmccann> heh
19:12:37 <mike-burns> A+
19:12:39 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:12:40 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
19:12:40 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
19:13:10 <shachaf> I mean, there's no general way of writing a function :: (a -> Bool) -> [a] that enumerates all the values of a for which the predicate is true.
19:13:13 * cmccann prefers shachaf's implementation here
19:13:16 <Cody_> shachaf_: What about the 10001 prime number?
19:13:27 <shachaf> You can do (Integer -> Bool) -> [Integer] by enumerating all Integers.
19:13:29 <ezyang> :t filter
19:13:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:13:32 <roconnor_> > tails [1,2[
19:13:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:13:35 <roconnor_> > tails [1,2]
19:13:36 <lambdabot>   [[1,2],[2],[]]
19:13:40 <shachaf> You can do something more specific when you know more about your predicate.
19:13:51 <shachaf> For example, you know that all prime numbers are greater than 1.
19:13:56 <Cody_> True
19:14:00 <ezyang> Oh, I've always wondered what I'm supposed to call the f in fold f. I guess 'algebra' works.
19:14:42 <shachaf> ezyang: What do you call the z in fold f z?
19:14:48 <shachaf> Oh, this is generic "fold", isn't it.
19:14:49 <ezyang> uhh
19:14:51 <Cody_> Anyways, the back story is create a function(x) where x is the nth prime number
19:15:00 <ezyang> "Also part of the algebra"
19:15:09 <cmccann> :t unfoldr
19:15:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:15:22 <ezyang> That's a... coalgebra...?
19:15:27 <shachaf> Cody_: I don't think "function(x)" means anything.
19:15:30 * cmccann notes that foldr "should" be (Maybe (a, b) -> b) to match that
19:15:52 <shachaf> You should call f in fold f "the reductionist" and f in unfold f "the holist".
19:16:01 <shachaf> cmccann: Why?
19:16:11 <shachaf> Oh, I see.
19:16:15 <mokus> analyst and catalyst ;)
19:16:16 <shachaf> Yes, that would work.
19:16:31 <cmccann> shachaf, it disguises the duality between them is all
19:16:41 <cmccann> foldr's type is nicer as-is, of course
19:16:43 <Cody_> schchaf_: It doesn't mean anything in any language. Use it to explain. Trying to create a function(x) that takes x where x is the xth prime number
19:16:46 <shachaf> cmccann: Right, the Nothing case corresponds to z.
19:18:29 <ezyang> OK, I guess next think I need to do is get edwardk to rant at me about algebras for an hour and see how much I understand
19:18:34 <cmccann> haha
19:19:32 <cmccann> ezyang, just read the source to recursion-schemes until everything makes sense
19:19:39 <shachaf> ezyang: Is that standard procedure for you?
19:19:52 <ezyang> Well, usually when edwardk rants at me I don't understand most of it.
19:20:18 <shachaf> cmccann: I think edwardk doesn't espouse much of recursion-schemes.
19:20:33 <shachaf> ezyang: I had a similar experience, really.
19:20:50 <cmccann> shachaf, did he disown it or something?
19:21:08 <shachaf> cmccann: I think the goal of making the package was to understand the recursion schemes.
19:21:25 <shachaf> And once he understood them he decided that most of them weren't a good idea.
19:21:28 <cmccann> haha
19:22:46 <tgeeky> reask, with type in question: question:  when I'm changing a package to compile on 7.4, and the solution is (mostly) peppering Eq constraints around.. is there a faster way to do this other than adding them by hand (or, by regex or something)
19:22:56 <tgeeky> newtype Vect k b = V [(b,k)] deriving (Eq,Ord,Read)
19:23:22 <shachaf> tgeeky: I don't think that tells us any more than it did before.
19:23:36 <tgeeky> well the errors are all fixes of (Eq k)
19:23:48 <tgeeky> but I can't write "instance Eq k" there
19:24:12 <tgeeky> so I'll have to fix all these by hand
19:24:13 <shachaf> What?
19:24:40 <drull95> i wish we could have a prefix operator for flip
19:24:40 <tgeeky> 2:49 < cmccann> tgeeky, just stick "instance Eq a" in there somewhere, that ought to do it
19:24:57 * cmccann was joking
19:25:02 <tgeeky> cmccann: oh. :/
19:25:05 <cmccann> and not even a good joke either
19:25:06 <cmccann> sorry
19:25:15 <cmccann> what are you trying to do, exactly?
19:25:47 <ion> instance Eq a where a == b = unsafeCoerce a == unsafeCoerce b
19:25:51 <tgeeky> cmccann: compile HaskellForMaths on ghc 7.4.1
19:26:03 <cmccann> the deriving clause should handle constraints on type parameters, shouldn't it?
19:27:47 <tgeeky> cmccann: I thought so, but in the Eq in deriving was already there before the complaints about k not being Eq
19:30:44 <dolio> ezyang: If you were the one who pinged me earlier, sorry, I stepped out (and I can't see far enough back in the scrollback).
19:31:05 <shachaf> 04:34 < ddarius> ezyang: If you want to know about algebras as in the things in "initial algebras" then that is what dolio is talking about.
19:31:17 <dolio> Ah.
19:33:08 <hpaste> tgeeky pasted “hfm diff and output” at http://hpaste.org/56213
19:34:16 <tgeeky> cmccann: there's what I did to supress several of the errors.
19:34:31 <tgeeky> cmccann: the Eq was already in deriving...
19:34:52 <tgeeky> cmccann: ignore the "alas, more" that's a accidental repate
19:34:54 <tgeeky> repaste
19:35:14 <cmccann> tgeeky, oh, that has nothing to do with the Vect type I'm pretty sure.
19:35:25 <tgeeky> yes, it's something with Num not implying Eq anymore?
19:35:28 <tgeeky> or something like that?
19:36:17 <cmccann> tgeeky, oh, did that finally happen?
19:36:25 <tgeeky> I'm not aware of release notes for 7.4.1 yet
19:36:30 <cmccann> well
19:36:35 <cmccann> if that is the case then yes
19:36:38 <tgeeky> i should be able to tell in ghci, I would think
19:36:43 <tgeeky> if i knew what to type
19:36:50 <cmccann> :i Num
19:37:06 <tgeeky> yes, right. and, no Eq isn't there
19:37:22 <cmccann> ok.
19:37:32 <cmccann> then, yes, you have a bunch of functions that need an Eq constraint
19:37:36 <cmccann> and don't have one anymore
19:37:57 <tgeeky> regex it is!
19:38:34 * hackagebot skein 0.1.0.4 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.4 (FelipeLessa)
19:38:36 <cmccann> tgeeky, the deriving stuff on Vect and whatnot just tells it how to make instances for that type based on the type parameters
19:38:54 <tgeeky> yes, that is what I originally thought.
19:39:08 <tgeeky> I shouldn't be doing "coding" while drinking and watching football. ;o
19:39:22 <tgeeky> i figured I could handle package stuff, but maybe it's a worse idea
19:40:12 <cmccann> anyway, yeah, you'll need to add Eq constraints and possibly Show if that's also gone
20:03:47 <Cody_> How do I filter a list by two things?
20:04:03 <shachaf> Cody_: Use logic.
20:04:06 <cmccann> the same way you filter it on one thing
20:04:09 <cmccann> except using both
20:04:28 <Cody_> filter (<= 4000000, `mod` 2 == 0)
20:05:15 <Cody_> filter(<= 4000000 filter (`mod` 2 == 0) some list)
20:05:15 <shachaf> Cody_: Why do you think that a comma there will do what you want?
20:05:31 <Cody_> It's the java talkign
20:05:40 <shachaf> It wouldn't do what you want in Java either.
20:05:48 <Cody_> Yes
20:06:02 <Cody_> But thats not the poitn
20:06:04 <Cody_> point*
20:06:10 <cmccann> > filter (liftA2 (&&) even (> 5)) [0..15]
20:06:11 <lambdabot>   [6,8,10,12,14]
20:06:17 <cmccann> obviously that's the sensible way to do it
20:06:24 <shachaf> Cody_: You should go back to an introduction on how Haskell syntax and read it. We could give you the answer here -- filter (\x -> x <= 40 && x `mod` 2 == 0) xs, or filter (<= 40) (filter (`mod` 2 ...) xs)
20:06:30 <shachaf> But there won't be much point.
20:06:40 <Cody_> I learn better by examples, thanks
20:06:53 <cmccann> there's certainly no points to my version, har har
20:07:11 <shachaf> You've been asking pretty much the same questions here over and over again, though, which indicates that you're trying to go too far ahead.
20:07:18 <Cody_> cmcann: Yours made the most sense
20:07:30 <shachaf> Seriously?
20:07:36 <cmccann> Cody_, does it? What's liftA2 mean, then?
20:07:36 <shachaf> Do you actually know wht "liftA2" does?
20:07:41 <Cody_> Nope
20:07:50 <cmccann> then how do you know it makes sense?
20:07:57 <cmccann> this isn't magic
20:08:23 <mercury^> Makes the most sense to him.
20:08:35 <mercury^> Naturally, because he does not know liftA2.
20:08:37 <Cody_> I thought I could substitute liftA2 with my own expression. So I figured I didn't need to know it
20:09:02 <shachaf> You *can* substitute liftA2 with your own expression, if your own expression happens to do exactly what liftA2 is doing here.
20:09:18 <tgeeky> hehe
20:09:55 <mercury^> Cody_: liftA2 (&&) correctly combines those two functions with Boolean outputs into one function with Boolean output by applying (&&) to their joint output on a single value.
20:10:12 <mercury^> i.e., exactly what the more explicit description does.
20:10:15 <shachaf> Cody_: If you don't understand the other two ways of doing it, you have no chance of understanding the liftA2 version.
20:10:16 <cmccann> Cody_, you're really not going to get anywhere trying to use things without knowing what they are
20:10:56 <Cody_> shachaf: I apologize if I am annoying with these questions. I am trying to teach myself haskell. I don't know the best route because there are no classes, so I am jumping around from book to tutorial to etc.
20:11:19 <shachaf> Cody_: You should probably follow one book/tutorial/whatever, all the way through, slowly, doing exercises if they exist.
20:11:29 <cmccann> Cody_, you are probably jumping around too much
20:11:30 <shachaf> If you see something you don't understand, don't just skip it.
20:12:57 <Cody_> I guess I'm getting impatient
20:13:17 <cmccann> for example, you probably shouldn't even be asking about how to combine two filters if you're still having trouble with the basic syntax
20:14:20 <Clint> > filter (\x -> even x && x > 5) [1..10]
20:14:21 <lambdabot>   [6,8,10]
20:14:23 <Clint> @pl filter (\x -> even x && x > 5) [1..10]
20:14:24 <lambdabot> filter (liftM2 (&&) even (> 5)) [1..10]
20:14:33 <Cody_> How did you learn?
20:14:54 <shachaf> Cody_: Probably in a different way from what would work for you.
20:14:59 <shachaf> Unless you're me.
20:15:01 <cmccann> Clint, liftM2 and liftA2 are the same thing there, for what it's worth
20:15:06 * Clint nods.
20:15:14 <Cody_> books?
20:15:26 <shachaf> Books are good, but you're still going to have to think.
20:15:41 <shachaf> Books won't save you. :-)
20:16:14 <shachaf> Hutton's _Programming in Haskell_ is good.
20:16:27 * cmccann had some advantages because of the other programming languages he already knew
20:16:54 <shachaf> "I already knew Haskell 98, so learning Haskell 2010 was really easy for me."
20:17:01 <cmccann> haha
20:17:23 <cmccann> not quite that helpful
20:18:08 <Cody_> cmcann: How'd you learn?
20:18:24 <ion> By doing
20:18:40 <cmccann> by writing code, trying to compile it, then consulting reference material when it didn't work
20:18:44 <Clint> i learned by abusing lambdabot
20:18:51 <cmccann> for about three months or so
20:19:07 <Cody_> cmcann: Kind of what I am doing. Except I am consult #haskell
20:19:22 <MostAwesomeDude> I learned from LYAH and RWH
20:19:31 <Cody_> which one is better
20:19:41 * cmccann didn't really use either while learning
20:20:02 <ion> Read LYAH first and RWH second.
20:20:15 <parcs`> cmccann: what languages did you previously know that gave you an advantage?
20:20:26 <ion> And Typeclassopedia at some point
20:21:24 <Cody_> Isn't RWH the same as LYAH?
20:21:32 <Cody_> Is is more indepth?
20:21:58 <cmccann> parcs`, python and scheme mostly. the type system in haskell was a major adjustment, but the rest was less of a shock than it would be coming from e.g. Java or C++
20:22:41 <Cody_> cmccann: Agreed on the type system. I think of it as more parameters
20:23:16 <cmccann> it also took me a while to stop trying to write lisp in haskell but that's another matter :]
20:23:55 <Cody_> Side question: Is there another way to access #haskell besides tryhaskell.org?
20:24:29 * Clint blinks.
20:24:43 <shachaf> @google how do i irc
20:24:43 <lambdabot> http://www.irchelp.org/irchelp/irctutorial.html
20:24:44 <lambdabot> Title: An IRC Tutorial
20:24:49 <Cody_> I don't have an IRC client
20:24:59 <shachaf> Yes you do. tryhaskell.org.
20:25:06 <shachaf> Get another IRC client if you don't want that one.
20:29:11 <mauke> Cody_: if you don't want to install a separate program, chatzilla is an irc client that runs in firefox
20:30:13 <Cody_> It's not a big deal, just curious
20:30:22 <ion> Your desktop system may also come with an IRC client already.
20:30:34 <ion> Ubuntu for instance does.
20:30:49 <shachaf> Cody_: I agree that it's not a big deal, but I don't know what your question is.
20:30:56 <shachaf> I'm not sure you do either, but if you do, you should clarify.
20:31:07 <Cody_> Me?
20:31:27 <Cody_> Asking what is another IRC client besides tryhaskell.org
20:31:50 <parcs`> webchat.freenode.net
20:31:56 <Cody_> But nevermind that, it doesn't matter, I was just curious
20:34:07 <Cody_> It sucks that no library has any type of Haskell book at all.
20:34:21 <shachaf> It's also not true.
20:34:27 <Cody_> At least by me
20:34:40 <Cody_> Within 20 mile area
20:35:02 <cmccann> several books are available online anyway
20:35:22 <mmos1127> Read World Haskell
20:35:27 <Cody_> Yea, but reading on a book is better than screen
20:35:33 <Cody_> reading a book*
20:42:17 <Cody_> Alright well its been a semi-productive day. Signing off
20:58:58 <augur> tromp: ping
21:01:18 * BMeph wonders if anyone will ever write a "Haskell for Dummies" book...
21:52:16 <jargonjustin> Is it possible to look up the reverse dependencies of a package on hackage?
22:07:24 <mikeplus64> what's the bytestring equivalent for read? (looking to convert a bytestring to an int)
22:07:40 <mauke> no such thing
22:08:17 <mikeplus64> equivalent?
22:09:19 <mauke> you can decode the bytestring to a string and read that
22:13:43 <ion> > let zero = fromIntegral (ord '0') in BS.foldl' (\acc x -> acc*10 + fromIntegral x - zero) 0 (BSC.pack "12345") :: Integer
22:13:43 <lambdabot>   12345
22:17:36 <shachaf> B.foldl' (\x w -> x * 256 + fromIntegral w) 0 -- convert a ByteString to an Integer
22:18:25 <ion> hehe
22:18:36 * hackagebot osm-download 0.1 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.1 (ThomasDuBuisson)
22:18:38 * hackagebot leapseconds-announced 2012 - Leap seconds announced at library release time.  http://hackage.haskell.org/package/leapseconds-announced-2012 (BjornBuckwalter)
23:00:30 <Sgeo> http://ideone.com/AJZRX is there a way to do this without wrapping in a type?
23:01:26 <ion> I’m under the impression it’s not possible, but i’d be happy to be proven wrong.
23:02:44 <BMeph> Sgeo: Short answer? No. Longer answer: Hell no! ;)
23:03:06 <BMeph> Sgeo: What type would the list be?
23:03:24 <shachaf> Sgeo: That type is wrong.
23:03:38 <shachaf> You want "exists", not "forall".
23:03:57 <shachaf> Before you ask that question, figure out why.
23:04:02 <ddarius> With overloaded literals, you could get two out of three.
23:04:33 <Veinor> ddarius: ?
23:04:51 <shachaf> Veinor: instance IsString Int
23:04:59 <Veinor> :I
23:05:18 <shachaf> Anyway, I think there exists a Haskell implementation that supports first-class "exists"?
23:05:23 <shachaf> I'm not quite sure how that works, though.
23:05:49 <ddarius> UHC does, but it has some limitations.
23:05:56 <ion> ddarius: With unsafeCoerce, you could get three out of three.
23:06:15 <ddarius> ion: That would require writing unsafeCoerce for each element, at which point you might as well just write show.
23:06:43 <shachaf> map unsafeCoerce [1::Int, True, "hello"] -- So obvious!
23:08:35 <BMeph> I don't like unsafeCoerse; it always reminds me of guys in trenchcoats and full panel vans. :/
23:08:45 <Veinor> what does unsafeCoerce True :: String even result in
23:09:37 <ion> λ> take 10 (unsafeCoerce True :: String)
23:09:37 <ion> "\1102201608\1102201608\1102201608\1102201608\1102201608\1102201608\1102201608\1102201608\1102201608\1102201608"
23:09:47 <shachaf> @quote ddarius isJust
23:09:47 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
23:10:18 <ddarius> Similarly for listToMaybe and a variety of other handy functions.
23:10:58 <Veinor> ion: i got something similar
23:11:18 <Veinor> oh god.... that works
23:11:20 <Veinor> why does that work
23:11:50 <ion> FSVO “work”
23:12:07 <shachaf> Veinor: data Maybe a = Nothing | Just a
23:12:11 <shachaf> data Bool = False | True
23:12:15 <Veinor> ah
23:13:24 <shachaf> Similarly data [a] = [] | a : [a]
23:13:31 <mauke> what is unsafeCorece True :: Maybe Bool?
23:14:03 <ion> Just booleanInUninitializedMemory probably.
23:14:43 <shachaf> This isJust is probably a memory leak too.
23:15:21 <ddarius> I'm going to say it will essentially always be Just False.
23:15:40 <shachaf> As guaranteed by the Report, no doubt.
23:15:48 <ion> :-D
23:17:07 <ddarius> I am wrong though, maybe if you don't have the info tables next to values optimization enabled it will work out that way.
23:17:48 <aweis> what is the best way to debug long running programs with haskell?
23:17:57 <augur> http://www.youtube.com/watch?v=-sBVdOlyIyI fractals are so cool :\
23:18:22 <aweis> I am finding myself in a position where printing would be useful - but I would like to stay away from IO
23:18:42 <mauke> Debug.Trace?
23:23:35 <jargonjustin> Is there a library for parsing and building binary data that can work as a monad transformer (or in IO)? Something akin to cereal or binary.
23:50:19 <aweis> does tail recursion optimization work in haskell?
23:50:27 <aweis> or does the laziness mess that up?
23:51:27 <shachaf> aweis: It doesn't make much sense to talk about it.
23:51:39 <shachaf> ddarius would say that it doesn't make much sense to talk about in any language, of course. :-)
23:51:49 <arw> aweis: it should better, or else everything would overflow the stack...
23:52:09 <companion_cube> it makes a lot of sense in some languages
23:52:19 <aweis> ummmm
23:52:39 <shachaf> arw: What?
23:52:43 <aweis> so I am perplexed at some of the code I have been running
23:52:52 <aweis> as I think it should be moving faster
23:53:05 <shachaf> companion_cube: In particular, he would call it "tail call pessimization" *not* to do it.
23:53:11 <aweis> I have coded it with accumulators -> just as I would with SML or scheme
23:53:36 <aweis> but a friend pointed out that haskells laziness could be detrimental in that approach
23:53:45 <companion_cube> how can it be a pessimization??
23:53:46 <shachaf> aweis: Lazy evaluation makes things behave completely differently.
23:53:58 <ion> aweis: hpaste the code.
23:54:04 <arw> shachaf: not making loops out of most recursive calls (like every larger fold) would eat up all stackspace, wouldn't it?
23:54:12 <aweis> ion: its a lot
23:54:16 <shachaf> arw: No, because that's not how Haskell is evaluated.
23:54:37 <jdavis> let's say I want to write a C function that returns a lazy list to haskell. Is there a tutorial for that kind of thing?
23:54:43 <ion> aweis: Profile the code.
23:54:53 <shachaf> jdavis: There are introductions to the FFI in general.
23:54:59 <shachaf> I hear the one in _Real World Haskell_ is good.
23:55:02 <aweis> ion: im finding out all the possible of numbers 1..28123 that are not the sums of 2 abundant numbers
23:55:15 <jdavis> shachaf: OK, I'll take a more detailed look there.
23:55:23 <shachaf> jdavis: You probably want to figure out what a reasonable C API would be, and then make a lazy list wrapper around that, maybe with unsafeInterleaveIO, if you're sure it's safe.
23:55:26 <shachaf> See also:
23:55:28 <shachaf> @google keegan ffi
23:55:30 <companion_cube> shachaf: so what's wrong with TCO?
23:55:30 <lambdabot> http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
23:55:30 <lambdabot> Title: High-level FFI in Haskell
23:56:15 <shachaf> companion_cube: Nothing. I think you misread my sentence.
23:56:23 <shachaf> (Well, there are *some* things wrong with TCO.)
23:56:32 <aweis> on a side note: is tail recursion using accumulators bad haskell style?
23:57:00 <jdavis> shachaf: Thanks, I'll look at the presentation as well.
23:57:04 <companion_cube> i did not understand "pessimizatio"correctly then
23:57:20 <aweis> ion: list_abundant n= (list_abundant_helper n [])
23:57:22 <shachaf> aweis: Good Haskell style is understanding what's going on.
23:57:29 <aweis> ion: list_abundant_helper 0 ls = ls
23:57:29 <aweis> list_abundant_helper n ls =
23:57:29 <aweis>   if (isAbundant n)
23:57:29 <aweis>     then list_abundant_helper (n-1) (n:ls)
23:57:30 <aweis>     else list_abundant_helper (n-1) ls
23:57:38 <shachaf> aweis: ...Don't paste in here...
23:57:39 <shachaf> @paste
23:57:39 <lambdabot> Haskell pastebin: http://hpaste.org/
23:57:52 <aweis> thanks
23:58:37 <shachaf> aweis: Anyway, you're best off understanding how strictness and laziness work.
23:59:04 <hpaste> aweis pasted “abundant” at http://hpaste.org/56217
