00:01:36 <quicksilver> rwbarton: its rather arbitrary parameter type is a secondary wart, too
00:01:49 <quicksilver> why String? what's so good about String?
00:02:03 <quicksilver> (but there isn't a better solution without MPTCs or type families, so it's not suprirsing)
00:02:11 <Sgeo> It's a linked list of characters, stored not particularly efficiently, so what's not to love!
00:03:03 <Sgeo> type families are the thingies where you say type whatever = blah in an instance declaration?
00:03:03 * quicksilver deducts 1 point from Sgeo's house for bringing implementation details into a semantic discussion.
00:04:46 <rwbarton> you mean that's part of the problem with it as a Monad member function, which would still exist if it were moved to a separate class, right
00:05:36 <quicksilver> yes. For example, that's the problem with 'fail' in the Either e monad
00:05:54 <quicksilver> even though 'Either e' is an excellent example of the kind of behaviour fail is intending to model
00:06:12 <quicksilver> leading to the rather daft situation of the "Error" class with its "fromString" method.
00:10:41 <ski> @free error
00:10:42 <lambdabot> f . error = error . $map $id
00:10:48 <Sgeo> free?
00:10:52 <Saizan> > fail "foo" :: Either () ()
00:10:53 <lambdabot>   *Exception: foo
00:11:09 <ski> @google theorems for free wadler
00:11:10 * Sgeo blinks
00:11:11 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
00:11:11 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract From t ...
00:11:26 <ski> @help free
00:11:27 <lambdabot> free <ident>. Generate theorems for free
00:11:35 <Sgeo> @free id
00:11:36 <lambdabot> f . id = id . f
00:11:42 <ski> @free reverse
00:11:43 <lambdabot> $map f . reverse = reverse . $map f
00:11:48 <Sgeo> $?
00:12:09 <ski> `$map' just means the `fmap' for the relevant type function
00:12:09 <Sgeo> @free (>>=)
00:12:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:12:32 <Sgeo> @free fail
00:12:32 <lambdabot> Expected variable or '.'
00:12:41 <ski> hm, actually, `$map' is just the ordinary `map'
00:12:44 <ski> @free listToMaybe
00:12:45 <lambdabot> $map_Maybe f . listToMaybe = listToMaybe . $map f
00:12:48 <ski> @type listToMaybe
00:12:49 <lambdabot> forall a. [a] -> Maybe a
00:13:23 <ski> i don't think `free' understands the `Monad m => ' in the type signature of `fail'
00:13:41 <Sgeo> Ah
00:13:56 <Sgeo> @free (\a b c -> b a c)
00:13:56 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:14:10 <Sgeo> How do I put in things of arbitrary types?
00:14:42 <ski> @free foo :: [Maybe a] -> [a]
00:14:42 <lambdabot> $map f . foo = foo . $map ($map_Maybe f)
00:14:46 <ion> @free map
00:14:46 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
00:15:40 <Sgeo> @free foo :: a -> (b -> c -> d) -> c -> d
00:15:40 <lambdabot> (forall y. k . p y = q (g y) . h) => k . foo x p = foo (f x) q . h
00:16:25 <Sgeo> @free coerce :: a -> b
00:16:26 <lambdabot> g . coerce = coerce . f
00:16:31 <ski> hehe
00:16:52 <Sgeo> @free fix
00:16:53 <lambdabot> f . g = h . f => f (fix g) = fix h
00:17:18 <ski> @free b :: Bool
00:17:19 <lambdabot> b = b
00:17:27 <ski> @free mb :: Maybe Bool
00:17:27 <lambdabot> $map_Maybe $id mb = mb
00:17:33 <Sgeo> @free (a -> b) -> c
00:17:33 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
00:18:09 <Sgeo> @free foo (a -> b) -> c
00:18:10 <lambdabot> Extra stuff at end of line
00:18:13 <Sgeo> @free foo :: (a -> b) -> c
00:18:13 <lambdabot> g . k = p . f => h (foo k) = foo p
00:18:32 <Sgeo> That looks vaguely familiar
00:18:50 <Sgeo> Except it's not
00:19:12 <Sgeo> That foo should be writable in Haskell, right?
00:19:25 <Sgeo> foo coerce = coerce coerce .. wait, no
00:19:45 <Sgeo> Wait, yes, I think
00:20:03 <Sgeo> :t \coerce -> coerce coerce
00:20:04 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
00:20:04 <lambdabot>     Probable cause: `coerce' is applied to too many arguments
00:20:04 <lambdabot>     In the expression: coerce coerce
00:20:16 <Sgeo> :t \coerce -> coerce id
00:20:17 <lambdabot> forall a t. ((a -> a) -> t) -> t
00:20:54 <Sgeo> @free foo :: ((a -> a) -> t) -> t
00:20:54 <lambdabot> (forall p q. f . p = q . f             =>              g (h p) = k q) => g (foo h) = foo k
00:21:05 <ion>                            =>
00:21:27 <ski> @type evalCont . cont
00:21:28 <lambdabot> forall o. ((o -> o) -> o) -> o
00:21:57 <Sgeo> oooo
00:22:19 <Sgeo> > evalCont . cont $ fix
00:22:23 <lambdabot>   mueval-core: Time limit exceeded
00:22:23 <ion> I’m still ignorant of the Curry-Howard isomorphism (should get around to studying that some day). Is the => in @free’s output the logical implication operator?
00:23:16 <ion> What i know about propositional logic so far is pretty much just the truth tables.
00:25:14 <Sgeo> ion, I think that's a separate sort of implication? @free isn't giving a type. I may be utterly confused though
00:25:17 <quicksilver> ion: it's probably easiest to read it just as "therefore" or "and so I deduce"
00:25:26 <Sgeo> -> in a type is implication
00:25:41 <quicksilver> ion: admittedly, "therefore" is just logical implication in your metalogic (the language you're using to describe the logic)
00:25:51 <Sgeo> a -> a is the statement that a implies a. id is the proof of this statement.
00:25:57 <quicksilver> so they are the same thing. But it may be simpler to keep the level separate in your mind.
00:26:31 <rwbarton> @free f :: a -> b
00:26:31 <lambdabot> h . f = f . g
00:26:41 <rwbarton> oh that's too simple
00:27:07 <Sgeo> (a -> a) -> a is the statement that if there's a proof of a implies a, there's a proof of a. Which means there's a proof of a. Which means fix is weird.
00:27:20 <ski> also see the free theorem for `error' above
00:27:21 <Sgeo> I guess because undefined fits every type, whether it should be able to or not?
00:27:39 <mauke> undefined is the universal proof
00:29:03 <ion> @free undefined
00:29:04 <lambdabot> f undefined = undefined
00:31:20 <Sgeo> Wait what?
00:31:25 <Sgeo> That makes no sense
00:31:29 <mauke> all functions are strict
00:31:38 <Sgeo> Ah
00:31:53 <mauke> @free error
00:31:53 <lambdabot> f . error = error . $map $id
00:32:27 <Sgeo> @free const
00:32:28 <lambdabot> f . const x = const (f x) . g
00:32:29 <rwbarton> @free f :: (a -> a) -> (a -> a)
00:32:29 <lambdabot> g . h = k . g => g . f h = f k . g
00:32:56 <Sgeo> What if there's multiple theorems provable from the type?
00:34:03 <Sgeo> @free head
00:34:03 <lambdabot> f . head = head . $map f
00:34:04 <rwbarton> @free f :: (a, a) -> a
00:34:04 <lambdabot> g . f = f . $map_Pair g g
00:34:40 <Sgeo> @free map
00:34:40 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
00:34:47 <rwbarton> can i somehow use this to prove f = fst or f = snd?
00:37:21 <rwbarton> oh
00:39:20 <Sgeo> @free f :: (a, b) -> a
00:39:20 <lambdabot> g . f = f . $map_Pair g h
00:39:33 <rwbarton> f (fst, snd) (x, y) = f (x, y)
00:39:37 <rwbarton> does that get me anywhere?
00:39:55 <Sgeo> rwbarton, from (a, a) -> a it shouldn't be possible to prove which it is
00:40:11 <Sgeo> iiuc
00:40:26 <rwbarton> I want to prove "either f = fst or f = snd"
00:40:43 <Sgeo> Ah
00:41:37 <ion> @free f :: (a -> b) -> b -> a  -- :-P
00:41:37 <lambdabot> h . k = p . g => g . f k = f p . h
00:42:29 <Sgeo> @free alpha :: a -> b -> a -> c -> a -> d -> a -> e -> a -> f -> a -> g
00:42:29 <lambdabot> f1 . alpha x y z u v a b c s t = alpha (f x) (g y) (f z) (h u) (f v) (k a) (f b) (p c) (f s) (q t) . f
00:43:27 * Sgeo reads the function closely and decides it's nonsensical
00:43:50 <ion> @type \a b c d e f g -> c a b b a g e
00:43:51 <lambdabot> forall t t1 t2 t3 t4 t5 t6. t -> t1 -> (t -> t1 -> t1 -> t -> t5 -> t3 -> t6) -> t2 -> t3 -> t4 -> t5 -> t6
00:44:14 <ion> @free t -> t1 -> (t -> t1 -> t1 -> t -> t5 -> t3 -> t6) -> t2 -> t3 -> t4 -> t5 -> t6
00:44:14 <lambdabot> Extra stuff at end of line
00:44:18 <ion> @free f :: t -> t1 -> (t -> t1 -> t1 -> t -> t5 -> t3 -> t6) -> t2 -> t3 -> t4 -> t5 -> t6
00:44:19 <lambdabot> (forall z u v a b. q . f3 z u v a b = f4 (g z) (h u) (h v) (g a) (k b) . p) => q . f x y f3 c s t = f (g x) (h y) f4 (f1 c) (p s) (f2 t) . k
00:44:21 <GorDonFreeMan> hi
00:44:54 <GorDonFreeMan> ahah m4dc0d3r|uberman so, you like haskell?
00:45:18 <m4dc0d3r|uberman> didnt spend too much time on it yet
00:45:38 <m4dc0d3r|uberman> i gotta focus on getting good at rails and earning soem money
00:46:08 <GorDonFreeMan> yeah it's sometimes good to eat something
00:46:23 * ski eats second breakfast
00:48:03 <db81> Is there any difference between Data.Set.elems and Data.Set.toList?
00:48:23 <quicksilver> nope.
00:48:38 <quicksilver> toList is added for consistency with other data types than use the same name I think
00:48:58 <ion> @check \xs -> let s = Data.Set.fromList xs in Data.Set.elems s == Data.Set.toList s
00:49:00 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `Data.Set.fromList'Not in scope: ...
00:49:09 <db81> aha, thx
00:49:37 <ion> @check \xs -> let s = S.fromList (xs :: [Integer]) in S.elems s == S.toList s
00:49:38 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `S.fromList'Not in scope: type co...
00:49:44 <ski> @check False
00:49:45 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `False'Not in sc...
00:50:53 <MostAwesomeDude> @check True
00:50:54 <lambdabot>   Not in scope: `myquickcheck'Not in scope: data constructor `True'Not in sco...
00:52:08 <Sgeo> True is not in scope?
00:52:24 <erus`> does haskell IR have any idea about generics ?
00:52:25 <Sgeo> Incidentally, I should probably learn to use quickcheck at some point
00:52:27 <Sgeo> And HUnit
00:52:33 <Sgeo> But the HUnit docs are still broken
00:52:36 <quicksilver> erus`: "IR" ?
00:53:03 <erus`> ir code
00:53:16 <srhb> Am I understanding this right... Feeding mkStdGen an integer will give me a deterministic generator? Ie. I can expect to get the same numbers from it?
00:53:37 <srhb> As long as the integer is the same between different times.
00:54:04 <quicksilver> erus`: what is "ir code"?
00:54:11 <ion> For the same version of GHC on the same computer, probably.
00:54:11 <mauke> srhb: yes, that's how functions work
00:54:16 <erus`> intermediate language
00:54:20 <srhb> mauke: Thanks.
00:54:32 <quicksilver> erus`: "haskell" doesn't have an intermediate representation.
00:54:35 <quicksilver> GHC has three.
00:54:57 <quicksilver> so your question is a bit hard to answer usefully.
00:55:28 <quicksilver> four if you count the llvm backend as adding a stage.
00:56:31 <osfameron> quicksilver: you could average that as 2 then ;-)
00:57:06 <ion> FSVO “average”
01:01:49 <shachaf> mauke: But what if the word "monad" appears in the general vicinity of the function? Then it doesn't work that way anymore, right?
01:02:16 <ski> shachaf : no difference
01:12:08 <shachaf> ski: Nonsense.
01:12:45 <erus`> @hoogle [a] -> [b] -> (a -> b -> c) -> [c]
01:12:46 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
01:12:46 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
01:12:46 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:13:33 <ski> shachaf : elaborate on what you mean ?
01:13:57 <frerich> I think the 'fmap' function is pretty funky, because it can be considered so many things. It can be like 'map', it can be like (.), it could be used to 'lift', and whatnot. I only now realize that (after reading the chapter on functors in LYAH).
01:14:21 <frerich> I guess usually it's better to just use 'map' and '(.)' and so on dierctly, because that communicates the intent more clearly?
01:14:41 <shachaf> @let foo x = x + 1
01:14:42 <lambdabot>  Defined.
01:14:44 <shachaf> > foo 5
01:14:45 <lambdabot>   6
01:14:55 <shachaf> > {-monad-} fоo 5
01:14:56 <lambdabot>   25
01:15:08 <shachaf> > {-monad-} fоо 5
01:15:09 <lambdabot>   4
01:15:10 <ski> frerich : yeah, that's often a good idea, i think
01:15:22 <shachaf> > {-monad-} foо 5
01:15:24 <lambdabot>   25
01:15:33 <Axman6> yeah, don't use fmap for function composition.
01:15:38 <ski> frerich : but in case there's no special name for `fmap', or you're writing generic code, you can use `fmap'
01:15:50 <Axman6> using in place of map is fine, but unnecessary, since it's an extra letter!
01:15:59 <ski> (no special name for `fmap' for a specific type function, i mean)
01:16:48 <ski> shachaf : what are these `fоo',`fоо',`foо' things that you use ?
01:16:59 <shachaf> :-(
01:17:15 <shachaf> Is that at least showing up looking like "foo"?
01:17:20 <ski> it's not
01:17:24 <shachaf> Bah. My IRC client is just broken.
01:17:25 <frerich> Yes, I think 'fmap (+1) [1..10]' is actually okay to my amateur eyes, but 'take 10 `fmap` repeat 3' or even 'fmap (++"!") getLine' seems.... non-idiomatic?
01:17:46 <ski> (it might be, in utf8-enabled clients, though)
01:17:47 <ion> shachaf: It is.
01:17:52 <Axman6> the latter is something i do often frerich
01:17:56 <shachaf> frerich: fmap instead of (.) seems non-idiomatic because it's non-idiomatic.
01:18:00 <ion> So, it seems ski’s client is broken. :-)
01:18:08 <shachaf> fmap (++"!") getLine is pretty common.
01:18:14 <ion> shachaf: I mean, it is showing up looking like “foo”.
01:18:35 <ski> ion : heh, considering the above, i think this is not broken ;)
01:18:43 <shachaf> And there I thought ski was in Swedishania.
01:18:48 <frerich> Axman6, shachaf: Ah, interesting! That's good to know (I never saw fmap on IO before, but then - I didn't see a lot of other peopls code yet)!
01:19:18 <frerich> I wasn't sure whether this was just crazy examples to show off the flexibility of fmap (ignoring whether it's common practice or not)
01:19:26 <shachaf> frerich: It's nicer to say (fmap f getLine) than do { something <- getLine; return f something }
01:19:44 <shachaf> frerich: It's not *really* flexbility, as such.
01:19:44 <ion> return (f something)
01:19:49 * ski wonders where Swedishania might be
01:19:50 <shachaf> ion: Right.
01:20:05 <Sgeo> I tend to use <$>
01:20:13 <shachaf> ski: Next to Neitherway.
01:20:14 <frerich> shachaf: Yes, it's certainly shorter. It's just that with all those 'fmap' examples I was never sure whether each of them is a 'people actually do that' thing or more a 'you could use fmap like this, but nobody will recognize that idiom in your code' thing.
01:20:24 <Sgeo> But then I tend to go overboard with <$> and <*> when there are more idiomatic things available
01:20:37 <shachaf> Sgeo: Oh, no, a synonym which is defined is (= fmap) instead of fmap! That changes things completely!
01:20:46 <scshunt> Sgeo: it's pronounced 'idiotic'
01:20:48 <ski> @google Swedishania
01:20:49 <lambdabot> http://www.swedishanna.com/
01:20:50 <lambdabot> Title: blonde escort Phoenix GFE swedish
01:21:01 <shachaf> ...I don't think that's what I meant.
01:21:04 <frerich> :-))
01:21:07 <Sgeo> shachaf, I mean, join $ someFunctionThatReturnsIO <$> foo <*> bar
01:21:59 <ion> Sometimes i wouldn’t mind having something like “bind2” which is join .: liftA2 f
01:22:00 <shachaf> Sgeo: When someone is learning about fmap and you say "I prefer to use <$> instead of fmap", I was just pointing out that that's a bit of a silly thing.
01:22:07 <erus`> > zipWith (+) [1..3] [1..5]
01:22:08 <lambdabot>   [2,4,6]
01:22:13 <Sgeo> shachaf, oh
01:22:14 <Sgeo> >.>
01:22:20 <shachaf> Sgeo: Just wait until you hear about applicative brackets.
01:22:37 <shachaf> iI someFunctionThatReturnsIO foo bar Jj
01:22:55 <shachaf> frerich: Anyway, in a certain sense, fmap is doing the exact same thing in all those cases.
01:23:02 <erus`> does $ have lower prec than && ?
01:23:04 <Sgeo> @free fmap
01:23:05 <lambdabot> Expected variable or '.'
01:23:09 <shachaf> The type is different but fmap is the same.
01:23:23 <Sgeo> erus`, $ has a lower precedence than anything, I think
01:23:25 <ski> @let infixl4 <*>>; foo <*>> bar = join (foo <*> bar)
01:23:25 <lambdabot>   Parse error: ;
01:23:31 <shachaf> @free sgeomap :: (a -> b) -> Sgeo a -> Sgeo b
01:23:31 <lambdabot> g . h = k . f => $map_Sgeo g . sgeomap h = sgeomap k . $map_Sgeo f
01:23:56 <ski> @let infixl 4 <*>>; foo <*>> bar = join (foo <*> bar)
01:23:57 <lambdabot>  Defined.
01:24:16 <srhb> So I'm still playing around with getting an understanding for IO, and right now I've made a function (from 99 haskell problems) diff_select n m gen which selects n random numbers from [1..m] by using randomR with gen. Now, however, is the question - how do I put an IO random generator in there?
01:24:20 <ski> then you can say `someFunctionThatReturnsIO <$> foo <*>> bar'
01:24:40 <srhb> diff_select n m (newStdGen) is definitely a too simple approach.
01:24:56 <ion> @type \f a b c -> f <$> a <*>> b <*>> c
01:24:57 <lambdabot> forall a a1 (m :: * -> *) a2 a11. (Applicative m, Monad m) => (a -> a1 -> m (a2 -> m a11)) -> m a -> m a1 -> m a2 -> m a11
01:25:02 <shachaf> srhb: First step: Understand what you want to do.
01:25:02 <ski> Sgeo : generally, `f <$> foo <*> bar <*> baz <*>> quux'
01:25:11 <ion> @type \f a b c -> f <$> a <*> b <*>> c
01:25:12 <lambdabot> forall a a1 a2 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> a2 -> m a11) -> m a -> m a1 -> m a2 -> m a11
01:25:15 <ski> (feel free to suggest a better name than `<*>>')
01:25:17 <Sgeo> ski, people might not be used to that
01:25:36 <shachaf> let foo <*>>> bar = join (join (foo <*> bar))
01:25:37 <ski> Sgeo : i don't see why that's a problem
01:25:50 <ski> shachaf :)
01:26:03 <erus`> can i have a guard in a case statement?
01:26:06 <Sgeo> Yes
01:26:18 <Sgeo> > case () of () | False -> 5 | True -> 6
01:26:19 <lambdabot>   6
01:26:33 <shachaf> You can have one in a case expression, at least.
01:26:35 <ion> let foo <*>>>>>>>>>>>>>>>>> bar = fix join (foo <*> bar)
01:26:48 <ski> srhb : `liftM (diff_select n m) newStdGen'
01:27:10 <ski>   liftM :: (a -> b) -> (IO a -> IO b)
01:27:38 <srhb> Oh, clever!
01:27:39 <ski> > case () of () -> u where u = ()
01:27:40 <lambdabot>   ()
01:27:45 <shachaf> I sometimes have the vague hope that there's some deep and interesting theory behind each of the Applicative combinator symbols, such that you can write a computer program that will generate symbolic names based on types.
01:27:55 <shachaf> Including things like <**> and <*$> and what not.
01:28:13 <shachaf> And then I remember that it's just people running a random search until Hoogle stops complaining about clashes, or something.
01:28:15 * ski thinks there is no such thing
01:28:19 <Sgeo> :t (<**>)
01:28:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
01:28:22 <ion> shachaf: hehe
01:28:26 <shachaf> Yes, it's all just arbitrary.
01:28:35 <shachaf> But I wish it wasn't, y'know.
01:28:36 * ski never liked the `Applicative' infix symbols
01:29:07 <shachaf> ski: What would you use instead?
01:29:09 <ion> I find <$> rather nice.
01:30:41 <shachaf> rwbarton: Oh, another argument for infixl $ is infixl <$>
01:30:44 <ion> OTOH, <*> might as well be named <$>, it’s another kind of “lifted” $
01:30:53 <srhb> ski: So what is happening is basically newStdGen >>= return . diff_select n m?
01:30:53 <shachaf> ion: But there's no counterpart to <*>
01:30:54 <shachaf> Right.
01:31:45 <hpaste> bytbox pasted “Th "Cycle in type synonym declarations"” at http://hpaste.org/56145
01:31:48 <bytbox> Why do I get "Cycle in type synonym declarations" with <paste>? Shouldn't it be equiv. to type A=Int?
01:32:28 <hpaste> erus` pasted “babbys first type system” at http://hpaste.org/56146
01:32:46 <ski> shachaf : `<*>' is ok-ish (but i'd prefer `<$>'), `<**>' is bad; instead of `<$>', i'd prefer `$>'
01:33:08 <erus`> what do you think of my paste above?
01:33:13 <ski> one could possibly do other things with sense, as well
01:33:13 <shachaf> erus`: Ah, the beloved Anything type.
01:33:34 <Sgeo> GHC has an Any type
01:33:52 <ion> shachaf: Well, you need to implement unsafeCoerce *somehow*.
01:34:04 <erus`> i guess i dont need anything with Limited
01:34:06 <shachaf> It's not a real language without unsafeCoerce.
01:34:44 <ion> ski: <$> and $> would be nice indeed.
01:35:47 <ion> Does anyone actually use <**>? :-)
01:37:24 <erus`> how do i deal with the fact that two numberList will never type check?
01:40:16 <Saizan> bytbox: it could either be a limitation of TH or a bug
01:41:01 <bytbox> Saizan: works if I do "data A = A $(stuff)" - I'm guessing bug; I'll send a message to the ML to confirm.
01:43:36 <XexonixXexillion> bytbox: Off memory, it's a limitation of TH
01:44:11 <bytbox> XexonixXexillion: ok, thanks.
01:46:35 <srhb> Is the terminology of f >>= return . g what is called lifting? I lift g "into" the Monad of f? Not sure how to say it conceptually.
01:46:53 <quicksilver> lifting is a bad word, overused in various different ways
01:46:59 <srhb> Okay.
01:47:05 <quicksilver> it may be best to avoid it if you're trying to be clear :)
01:47:17 <Saizan> bytbox: type synonyms are more restricted by themselves, to avoid situations like type A = B; type B = A
01:47:19 <geekosaur> lifting or mapping, but both are rather overloaded; the other ways to express that operation are liftM and fmap
01:47:25 <quicksilver> but, yes, one use of it is that you "lift" the pure function g into the monad.
01:47:32 <quicksilver> as in the name 'liftM' which is equivalent to what you wrote
01:47:40 <bytbox> Saizan: makes sense
01:47:41 <srhb> Indeed. Okay, thanks. :)
01:47:41 <ski> srhb : `f >>= return . g', which could be written more nicely as `return . g =<< f', is the same as `liftM g f'
01:47:54 <quicksilver> quite different from the "lift" of MonadTrans
01:48:05 <quicksilver> which is about going up (or down) a layer in the monad transformer stack
01:48:30 <ski> @type length
01:48:31 <lambdabot> forall a. [a] -> Int
01:48:40 <ski> @type liftM length
01:48:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m Int
01:48:41 <srhb> I must say the word lift in itself doesn't tell me much, but I'm thinking of it as putting g into the context of the monad of f
01:48:43 <ski> @type liftM length getLine
01:48:43 <srhb> Sort of.
01:48:43 <lambdabot> IO Int
01:49:02 <quicksilver> I suppose it's not totally unrelated, you could view "g" as isomoprhic to "Identity . g" and then rewrite your original monad as a transformer over Identity.
01:49:03 <srhb> It's hard to use precise terminology when you only barely understand what's going on. O:-)
01:49:16 <quicksilver> and then liftM is lift, in a sense.
01:50:55 <koeien> you would say "g is lifted to monad m"
01:51:36 <srhb> And do I say monad M is the monad of f?
01:51:41 <srhb> How is that relation expressed?
01:51:51 * hackagebot http-conduit 1.1.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.1.0 (MichaelSnoyman)
01:51:53 * hackagebot http-conduit 1.1.0.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.1.0.1 (MichaelSnoyman)
01:52:13 <shachaf> I think you're too hung up on the word "monad".
01:52:26 <shachaf> It's just a regular type.
01:52:38 <koeien> f is a "monadic value"
01:52:49 <srhb> shachaf: I probably am.
01:52:54 <koeien> it's a regular value with some extra property.
01:52:58 <srhb> Aye.
01:52:58 <alistra> @hoogle [(a,b)] -> [(a,[b])]
01:52:59 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
01:53:09 <alistra> ehhhh
01:53:21 <koeien> e.g. putStrLn "Hello world" is a monadic value
01:53:48 <ski> @type putStrLn "Hello world"
01:53:49 <lambdabot> IO ()
01:54:08 <shachaf> [1,2,3] is a "monadic value"
01:54:21 <shachaf> (\x -> x) is a "monadic value"
01:54:27 <koeien> yeah, lots of things are
01:55:00 <koeien> it is probably not a particularly useful definition
01:55:23 <shachaf> I think it causes more confusion than it's worth.
01:55:28 <ion> 0 is a “monadic value”.
01:55:36 <shachaf> I guess it's better than having people say "getLine is a monad", though...
01:55:41 <philandstuff> a monadic value is a value of a type which implements the Monad typeclass
01:55:50 <alistra> :t groupBy
01:55:50 <XexonixXexillion> bytbox: What are you trying to achieve?
01:55:50 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
01:56:04 <alistra> @src groupBy
01:56:04 <lambdabot> groupBy _  []       =  []
01:56:04 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
01:56:04 <lambdabot>     where (ys,zs) = span (eq x) xs
01:56:32 <bytbox> XexonixXexillion: nothing; I was mainly just fooling around. (Very generally, I'm working on an n-dimensional raytracer, but this was only tangential.)
01:56:44 <koeien> i think the definition singles out monads too much. we don't really talk about "comparable value" if its type implements Eq or Ord
01:56:51 * hackagebot conduit 0.0.1 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.1 (MichaelSnoyman)
01:57:00 <koeien> monads are not special
01:57:20 <shachaf> Yes.
01:57:28 <shachaf> philandstuff: There are no monadic values, by that definition.
01:57:41 <shachaf> No value has type Maybe.
01:57:54 <philandstuff> ah i see, yes
01:58:16 <plat0> He said "monadic value is a value of a type" not "monadic value is a type"
01:58:25 <plat0> Surely return () is a value of type IO ()
01:58:29 <shachaf> Right.
01:58:35 <shachaf> return () is a value of type IO ()
01:58:35 <philandstuff> it's of type IO (), not of type IO
01:58:39 <shachaf> It's not a value of type IO
01:58:41 <koeien> IO is not a type.
01:58:48 <plat0> Ah!
01:58:48 <shachaf> I think we're all in agreement here.
01:58:58 <koeien> yeah :)
01:59:05 <ion> I strongly disagree.
01:59:09 <shachaf> Except I wish people had these discussion elsewhere.
01:59:16 <shachaf> Like #haskell-/dev/null
01:59:22 <philandstuff> heh
01:59:39 <srhb> I like them, it gives me a sense of where to be confused and where not to bother. :-)
02:01:32 <hpaste> XexonixXexillion pasted “Type synonyms in TH” at http://hpaste.org/56147
02:01:59 <hoqhuuep> Speaking of #haskell-/dev/null, which other haskell related IRC channels are reasonably active?
02:02:21 <ski> koeien : "`M'-action", for particular values of `M', is more useful
02:02:22 <XexonixXexillion> bytbox: If you want a simple solution to your problem, http://hpaste.org/56147
02:02:23 <koeien> there is #haskell-blah, not so active, and various haskell projects like #xmonad #yesod #snap-framework
02:02:36 <ski> abbreviated as "action", when the monad is understood
02:03:20 <hoqhuuep> koeien, thanks.
02:03:23 <ski> philandstuff : strictly speaking, "a monadic value is a value of a type which implements the Monad typeclass" isn't right
02:03:41 <ski> philandstuff : the kind of the type of any value is `*', but the kind of types in the `Monad' class must be `* -> *'
02:03:49 <koeien> yeah we reached that conclusion already :)
02:03:52 <philandstuff> ski: we've been there
02:03:59 <b_jonas> I think I understand it now…
02:04:06 <bytbox> XexonixXexillion: I think the simpler solution is just 'data A = A $( foothing)', which works fine
02:04:23 <ski> philandstuff : oh sorry, i missed that
02:04:38 <XexonixXexillion> bytbox: But that's no longer a type synonym
02:04:40 <b_jonas> so basically a data family or type family isn't a real higher-kind type, in that you can't use it without passing arguments to it
02:04:43 <bytbox> XexonixXexillion: (well, it doesn't actually, because ghc crashes, but that's a separate issue).
02:04:57 <bytbox> XexonixXexillion: I know.
02:04:58 <b_jonas> you can't, like, pass a data family to a data type that needs a higher-kind type as argument
02:05:03 <b_jonas> nor a class constraint etc
02:05:28 <b_jonas> which is why type families can always be translated back to "ordinary" fundeps
02:05:54 <ski> koeien : we need a name that includes all of `Int',`IO',`IO Int'
02:06:27 * ski thinks that name should be "type"
02:06:34 <ion> I was just about to say that. :-P
02:06:45 <ion> Just like values include functions, too.
02:07:04 <b_jonas> but then we need a name for types of kind *
02:07:30 <ion> Values include functions. Types include type constructors.
02:07:43 <koeien> but types aren't first-class
02:08:13 <ion> “*-types” :-)
02:08:22 <koeien> "a type is a 0-ary type constructor"
02:08:27 <ski> b_jonas : "concrete type"
02:08:31 <koeien> probably not so accurate
02:08:44 <koeien> since then you introduced arity for no reason
02:08:46 <ski> (also, `Either Int' is not a type constructor, imo)
02:08:47 <ion> koeien: Yeah, just like non-function values are 0-ary functions. /me ducks
02:09:04 <koeien> ion: :( yeah that's not a conclusion i'd like to reach
02:09:24 <hoqhuuep> Partial evaluation works with type constructors, doesn't it?
02:09:37 <koeien> hoqhuuep: partial application works, yes
02:09:41 <shachaf> Partial evaluation?
02:09:46 <shachaf> Oh, application.
02:09:51 <shachaf> That's just regular application.
02:10:04 <hoqhuuep> ah, yeah what ever it's called... yeah I know, currying :)
02:10:10 <koeien> type D = IO -- this works
02:10:17 * ski doesn't see what partial evaluation (nor partial application) has to do (directly) with type constructors
02:10:24 <b_jonas> ski: concrete types sounds good
02:10:24 <asda8> if I enable library-profiling in my cabal configuration, does that affect performance for my executables using them without executable-profiling enabled?
02:10:30 <koeien> type D a = IO a -- also works
02:10:30 <ion> type E = Either String  -- this, too
02:10:36 <srhb> hoqhuuep: Partial application is correct term when you're talking about passing fewer than the total number of arguments to a curried function.
02:10:40 <koeien> there is a difference between those, though
02:11:01 <koeien> asda8: AFAIK no, it compiles the libraries twice, once with and once without the profiling info
02:11:03 <hoqhuuep> srhb, OK thanks for that clarification
02:11:21 <asda8> koeien: thanks!
02:11:40 <ski> koeien : *nod*, the second defines a `1'-ary type function
02:11:41 <koeien> asda8: so enabling it slows down the installation of a package
02:12:36 <koeien> (and you'll use a bit more disk space)
02:13:04 <b_jonas> but I still think I don't really understand data families
02:13:30 <b_jonas> they're not just type families that are injective, because they also can't overlap with any other data typee
02:13:51 <osfameron> well, when a daddy data and a mummy data love each other very much...
02:13:55 <shachaf> hoqhuuep: No, it's not currying. "currying" is much more wrong.
02:14:10 <shachaf> You should read the entry on the Haskell wiki on the differences between these terms. :-)
02:14:28 <koeien> currying and partial application are related. you curry functions in order to be able to partially apply them
02:14:30 <asda8> koeien: that is not a problem, I was afraid it would slow down my final executables even when I'm not currently using profiling
02:14:33 <b_jonas> shachaf: as in http://www.haskell.org/haskellwiki/GHC/Indexed_types ?
02:15:03 <shachaf> b_jonas: I was talking about the "currying" thing.
02:15:15 <shachaf> However, that answer probably applies to a lot of questions people ask around here...
02:15:31 <srhb> Bitter, bitter.. :)
02:15:37 <b_jonas> ok :-)
02:15:44 <hoqhuuep> shachaf: will do!
02:17:42 <Guest72605> Are runhaskell and ghci related?  I get segfaults sometimes when I start ghci and runhaskell seems to work/not work randomly as well.
02:18:02 <koeien> aadrake: yes, they are related. runhaskell runs your script by invoking ghci
02:18:38 <koeien> that said, i think segfaults should not happen[tm]
02:18:44 <koeien> unless you're invoking a C library somehow
02:18:56 <aadrake> koeien: They started after I upgraded to GHC 7.4
02:19:17 <koeien> that's not been released yet, is it?
02:19:17 <b_jonas> ghc what?
02:19:21 <rdancer> how does one go about replacing elements of an Array?
02:19:32 <b_jonas> I think the latest stable one is still ghc 7.2.2
02:19:42 <aadrake> koeien: It's available but it's not in the platform.
02:19:43 <koeien> rdancer: you don't "replace", you make a new array with new elements.
02:19:54 <koeien> rdancer: (//) probably does what you want
02:19:56 <b_jonas> no way... let me check
02:19:56 <koeien> :t (//)
02:19:57 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
02:20:14 <b_jonas> look at http://www.haskell.org/ghc/
02:20:26 <b_jonas> it saays ghc 7.2.2 is the latest and was released in November 2011
02:20:28 <koeien> aadrake: i can only point you to the GHC bug tracker.
02:21:13 <aadrake> koeien: Is it possible to downgrade or is that a complicated process?
02:21:15 <asda8> can I have cabal build the dependencies for my local package automatically?
02:21:15 <b_jonas> maybe you're getting a segfault when trying to read from the future, because your time machine can't handle the load?
02:21:28 <aadrake> b_jonas: GHC 7.4 is in RC1 or 2
02:21:38 <b_jonas> hmm
02:21:39 <rdancer> koeien: how do I use (//) if I only know the current index, not the current value, and want to replace the value?
02:21:59 <aadrake> b_jonas: So ghc 7.2.2 is not the most recent available, it's the most recent stable release
02:22:05 <b_jonas> I see
02:22:53 <aadrake> b_jonas: Here you go :) http://www.haskell.org/ghc/dist/7.4.1-rc1/
02:23:17 <b_jonas> no thanks, I won't install it till it's stable
02:23:37 <rdancer> koeien: oh I see; thanks!
02:23:40 <koeien> rdancer: you don't need the current value
02:24:08 <koeien> i think GHC 7.0.4 is recommended tho
02:24:22 <asda8> found it: cabal install --only-dependencies
02:25:44 <ski> rdancer : `myArray // [(myIndex,myNewValue)]' ?
02:26:04 <ski> rdancer : that said, you should try to make many updates at a time, instead of just a single update, like that
02:26:28 <ski> (also, in some cases you can get away with no updates at all, by defining the array in a recursive way -- cf. dynamic programming)
02:26:50 <ski> if you really need fine-grained updates, you might want to use mutable arrays instead
02:27:05 <koeien> premature optimization and all that, imo
02:27:43 <koeien> but yeah you can always revert to STArray / STUArray
02:28:37 <ski> @quote premature.generalisation
02:28:37 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
02:28:40 <aadrake> koeien: You were correct, this is a known bug in 7.4 on Mac OS
02:29:13 <b_jonas> heh
02:30:19 <Jafet> @quote generalize
02:30:19 <lambdabot> not-gwern says: 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras,
02:30:19 <lambdabot> and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero.
02:30:19 <lambdabot> Just like your statistic
02:30:41 <aadrake> Igloo: Are you around?
02:31:23 <b_jonas> heh
02:31:37 <koeien> lol
02:31:37 <b_jonas> do people enter overly long quotes like that with the lambdabot compose command?
02:31:45 <b_jonas> I used to do that with buubot
02:32:36 <b_jonas> hmm, generalization gave me an idea...
02:32:56 <b_jonas> let's write general code
02:33:10 <Jafet> <Jafet> In Haskell, you obfuscate code by generalizing it
02:39:07 <mikeplus64> do notation is purely syntactical right? would there be a way to implement a "do"-like function that would achieve the same thing?
02:39:35 <Jafet> @undo do { a; b <- c; let d = e; f }
02:39:35 <lambdabot>  Parse error at "}" (column 30)
02:39:41 <Jafet> @undo do { a; b <- c; let { d = e }; f }
02:39:42 <lambdabot> a >> c >>= \ b -> let { d = e} in f
02:40:53 <Jafet> Obviously, you cannot easily replace special syntax with functions
02:41:15 <mikeplus64> yeah, I'm just wondering how you would approach it
02:41:54 * hackagebot authenticate 0.11.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.11.1 (MichaelSnoyman)
02:51:45 <ski> mikeplus64 : in Scheme, you could define a macro `do' so that `(do a (<- b c) (let ((d e))) f)' translated into `(>> a (>>= c (lambda (b) (let ((d e)) f))))'
03:02:58 <erus`> can any human even understand that?
03:03:46 <ion> Yes, and i’m not even a Lisp programmer.
03:08:03 <erus`> lambdurp 2.0 with static types
03:08:11 <erus`> oh boy oh boy
03:11:40 <erus`> @hoogle Either
03:11:40 <lambdabot> Prelude data Either a b
03:11:41 <lambdabot> Data.Either data Either a b
03:11:41 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:13:03 <b_jonas> does ghc export a truncated square root function for Integers?
03:13:24 <b_jonas> gmp has such a function (mpz_sqrt), but we know it's not easy to get to the gmp handle from an Integer
03:15:05 <koeien> mikeplus64: most likely you wouldn't do it. if you must, you can use template haskell.
03:15:14 <koeien> mikeplus64: we try to use combinators for most things
03:16:06 <ion> If you could just do “do” as a function, it wouldn’t be syntactic sugar in the first place.
03:16:46 <b_jonas> what's wrong with just the usual translation to >>= ?
03:17:09 <ion> Depending on what you mean by “do-like”, you get to use “do” by making your stuff a monad.
03:17:40 <rostayob> you could simulate a do by having a :: [someting] -> something function
03:17:43 <koeien> i interpreted it as things like arrow-notation
03:17:45 <rostayob> so you'd put your statements in a list
03:17:57 <rostayob> but the arrow notation, no
03:18:08 <rostayob> the variable binding in general
03:18:21 <b_jonas> like some fold1 (>>=) stuff?
03:18:39 <b_jonas> no wait, that woudln't work
03:18:42 <rostayob> yeah
03:18:56 <ion> I suppose it would with >=>
03:20:00 <erus`> o god i need some kinda monad fold
03:20:06 <erus`> my brain hurts
03:22:20 <ion> > foldr1 (<=<) [ return . map Data.Char.toUpper, permutations, subsequences ] "hai"  -- totally contrived
03:22:21 <lambdabot>   ["","H","A","HA","AH","I","HI","IH","AI","IA","HAI","AHI","IAH","AIH","IHA"...
03:24:02 <b_jonas> what on earth is a (<=<) ?
03:24:08 <ion> @type <=<
03:24:09 <lambdabot> parse error on input `<=<'
03:24:10 <ion> @type (<=<)
03:24:11 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:24:21 <ion> @type (=<<)  -- compare
03:24:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:24:28 <koeien> it's flip (>=>)
03:24:31 <b_jonas> right, I looked that up and it says "Right-to-left Kleisli composition of monads." which doesn't really explain what it is
03:24:41 <b_jonas> I don't know what (>=>) is either
03:24:41 <koeien> :t (>=>)
03:24:42 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:24:46 <ion> Yeah, that piece of documentation is horrible. :-)
03:24:59 <b_jonas> @src (>=>)
03:24:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:25:03 <b_jonas> @src (<=<)
03:25:04 <lambdabot> Source not found. That's something I cannot allow to happen.
03:25:05 <koeien> it's (a -> m b) -> (b -> m c) -> (a -> m c)
03:25:38 <ski>   (f <=< g) x = f =<< g x
03:25:39 <ion> @type \m n a -> m =<< n a
03:25:40 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
03:25:41 <koeien> so given  f :: a -> m b, g :: b -> m c, f >=> g is the function that takes a value x of type a, runs f x, extracts the value, passes that to g, and returns that
03:25:50 <b_jonas> ski: thanks
03:25:53 <ski>   (g >=> f) x = g x >>= f
03:26:50 <ski> @type \f g -> runKleisli (Kleisli f <<< Kleisli g)
03:26:51 <lambdabot> forall b (m :: * -> *) b1 a. (Monad m) => (b -> m b1) -> (a -> m b) -> a -> m b1
03:26:59 <b_jonas> is that the one that comes in in the monad laws?
03:27:00 <ski> @type \g f -> runKleisli (Kleisli g >>> Kleisli f)
03:27:01 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => (a -> m b) -> (b -> m b1) -> a -> m b1
03:27:15 <koeien> b_jonas: there are multiple equivalent versions of the laws
03:27:32 <ski> b_jonas : `(>=>)' is one (nice) way to express the laws, yes
03:27:36 <koeien> I guess one formulation involves "(>=>) is associative"
03:28:09 <koeien> and "return is the identity element of >=>"
03:28:10 <ion> The monad laws look nicer (to many) when expressed in terms of the Kleisli operators.
03:28:18 <b_jonas> reading up, it says one rule is that ((m >>= k) >>= h) equivalent to (m >>= (\x -> k x >>= h))
03:28:22 <ski> @type (>>>) `asTypeIn` \(>>>) g f -> runKleisli (Kleisli g >>> Kleisli f)
03:28:23 <ski> @type (<<<) `asTypeIn` \(<<<) g f -> runKleisli (Kleisli g <<< Kleisli f)
03:28:23 <lambdabot> forall a b c (m :: * -> *). (Monad m) => Kleisli m a b -> Kleisli m b c -> Kleisli m a c
03:28:24 <lambdabot> forall b c a (m :: * -> *). (Monad m) => Kleisli m b c -> Kleisli m a b -> Kleisli m a c
03:28:40 <b_jonas> but in that, (\x -> k x >>= h) is just (k >=> h) by the definition of (>=>), right?
03:29:05 <koeien> b_jonas: yeah but then your formulation involves both >=> and >>=
03:29:05 <ski> b_jonas : using `(>=>)', that law can be stated like `forall f g h. (f >=> g) >=> h = f >=> (g >=> h)'
03:29:21 <b_jonas> so ((m >>= k) >>= h) equivalent to (m >>= (k >=> h))
03:29:32 <ski> yes
03:30:08 <b_jonas> which you could write as ") >>=" is equivalent to ">=> )"
03:30:21 <koeien> urgh
03:30:43 <hpaste> erus` pasted “Can i shorten this?” at http://hpaste.org/56148
03:31:06 <ski> also, the laws `forall a amb. return a >>= amb = amb a' and `forall ma. ma >>= return = ma' can be stated as `forall f. return >=> f = f' and `forall f. f >=> return = f'
03:31:17 <ski> b_jonas : hehe
03:31:32 <ion> @type let m >>= f = (const m >=> f) (error "<trollface>") in (>>=)
03:31:33 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
03:32:31 <koeien> there is also a nice formulation in terms of fmap, join and return
03:32:35 <ski> erus` : `Right $ i - 1' could be written as `Right (i - 1)'
03:32:42 <b_jonas> ski: I see, so that lets you express all the monad laws
03:32:50 <erus`> ski hlint will moan?
03:33:02 <ski> if it does, then it's stupid
03:33:24 <ion> I’d rather have hlint moan about “Right $ i - 1”. :-P
03:33:26 <ski> (imho)
03:33:28 <erus`> can i make the tfi (Tuple ts) i ... into a fold?
03:33:58 <ski> erus` : i think so
03:34:58 <ski> btw, no recursive call to `foo' changes the first parameter, so there's not much use to it
03:36:13 <ski> hm, no that's not true
03:37:22 <ski> it looks like `foo' possibly wants to use `StateT Integer (Either Type)'
03:38:19 <erus`> oh god
03:38:46 <erus`> @pl typeFromIndex t i = either id (error "Out of bounds type index") (tfi t i)
03:38:46 <lambdabot> typeFromIndex = (either id (error "Out of bounds type index") .) . tfi
03:38:57 <ski>   tfi (Tuple ts) i = foldr (\t foo_ts i -> tfi t i >>= (\i -> foo_ts i)) (return i) ts (i - 1)
03:39:02 <ski> is the direct `foldr' version
03:39:19 <ski> i'll paste a version using `StateT'
03:42:05 <erus`> i wish there was types for lists of n items or greater :)
03:42:59 <ion> newtype MyList a = MyList a a a a a a a a a a a a a a a a a a [a] ;-)
03:48:04 <asda8> I'm sorry if this question is rubbish, but I'm not very familiar with GHC profiling: if I wait for a blocking operation in my program (waiting for data from the database for example), where does that time show up in the profiling statistics? I'm asking because for my small program it says that 83% of individual time was spent in main and main really just calls other modules which do the work.
03:48:52 <asda8> I also don't understand how profiling works with lazyness
03:49:33 <hpaste> ski annotated “Can i shorten this?” with “`mapM_' in `StateT Integer'” at http://hpaste.org/56148#a56149
03:49:44 <ski> erus` ^
03:50:18 <erus`> lol thanks
03:50:34 <ski> if there had been no matching on `0', the whole shebang could have been written in `StateT Integer (Either Type)'
03:51:08 <ski> i suppose one could alternatively make something that checks whether the state is `0', and fails with the given type then
03:51:35 <ski> @type (StateT . (fmap ((,) ()) .) . )
03:51:36 <lambdabot>     The operator `.' [infixr 9] of a section
03:51:36 <lambdabot>         must have lower precedence than that of the operand,
03:51:36 <lambdabot>           namely `.' [infixr 9]
03:51:47 * ski sighs
03:52:37 <ski> @type let (.) = (Prelude..) in StateT . (fmap ((,) ()) .)
03:52:38 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> StateT a f ()
03:52:40 <asda8> for example if I have an expensive computation in a module somewhere, but it only gets evaluated when I try to print it in my main function: where is the calculation time counted (the main function or the module)?
03:52:56 <ski> arguably that ^ thing should have a name
03:53:07 <ski> it being the inverse to `execStateT', i think
03:53:16 <asda8> both would be useful in some cases
03:56:25 <asda8> could someone please explain?
03:57:42 <aadrake> So if lines :: String -> [String] and head :: [a] -> a then shouldn't putStrLn (head linesOutput) work just fine?
03:58:09 <ion> > (head . lines) ""
03:58:11 <lambdabot>   "*Exception: Prelude.head: empty list
03:59:03 <ion> > (take 1 . lines) ""
03:59:05 <lambdabot>   []
03:59:21 <ion> > (listToMaybe . lines) ""
03:59:23 <lambdabot>   Nothing
03:59:58 <ion> (I’d use listToMaybe . take 1 . lines instead to make the intent obvious, though.)
04:00:36 <aadrake> Interesting
04:01:55 <aadrake> Wait, my fault, I had a mapM_ at the front of that line
04:01:59 <aadrake> Which was causing the problem
04:12:59 <Blkt> good day everyone
04:19:32 <erus`> is overwriting names bad practise?
04:19:46 <erus`> like (\x -> \x -> x)
04:20:29 <mike-burns> Shadowing?
04:20:43 <mike-burns> It's a bad practice until you want it, and then it's the right thing to do.
04:21:09 <mike-burns> Doing it carelessly hides a bug that you don't know about, and that's bad practice.
04:21:32 <koeien> generally considered harmful i think
04:21:39 <koeien> -Wall will warn
04:22:33 <erus`> i really enjoy programming :) This is the first time i have written any code for over a month
04:22:57 <mike-burns> Welcome back!
04:23:18 <erus`> its like riding a bike
04:23:35 <mike-burns> Fun until you get doored?
04:23:43 <mike-burns> Segregating?
04:24:03 <mike-burns> Painful on your back?
04:25:09 <BleuM937> G'day
04:26:31 <frerich> erus`: Difficult when done uphill?
04:27:09 <erus`> annoying when it doesnt work
04:27:31 <mike-burns> Something I'm about to do in 30 minutes?
04:32:07 * hackagebot uAgda 1.2.0.1 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.2.0.1 (JeanPhilippeBernardy)
04:36:20 <haze__> hi there
04:36:51 <haze__> i got a question
04:37:05 <hpc> we may or may not have an answer ;)
04:37:12 <haze__> :D
04:37:22 <haze__> it's about DrRacket
04:38:02 <haze__> i have to write a procedure
04:38:30 <ski> haze__ : maybe you want #scheme or #racket ?
04:38:44 <haze__> oh, thx :)
04:39:00 <haze__> didn't know about these channels
04:39:34 <haze__> just got here coz i'm reading "learn you haskell for great good" ;)
04:39:53 <ski> well for Haskell, this is the right channel
04:40:14 <ski> but for DrRacket, you presumably want help for Scheme, rather than Haskell
04:40:17 <haze__> yes but my question is about racket..
04:40:47 <haze__> ok, gonna ask there
05:03:37 <erus`> god damnit, my type checker still recurses infinatly
05:06:53 <erus`> @hoogle elem
05:06:53 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
05:06:53 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
05:06:53 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
05:10:58 <ehuber_> can anyone here field a question about the Hamlet library?
05:11:08 <rostayob> ehuber_: you're better off just asking
05:12:07 <ehuber_> allright. so, I'm doing a #thisIsAString -style interpolation inside a hamlet quasiquotation
05:12:16 <ehuber_> thisIsAString = "<p>bla</p>"
05:12:25 * hackagebot epic 0.9.2 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.9.2 (EdwinBrady)
05:12:30 <gregATio> que?
05:13:18 <ehuber_> ... and i just realized that i am a moron
05:13:38 <ehuber_> i was going to claim that things aren't getting autoescaped, but i have to lern2curl. :)
05:13:47 <rostayob> ehuber_: re-stating questions or problems you're having often has that effect
05:13:55 <ehuber_> yup :) thanks for the reminder
05:14:10 <rostayob> ehe
05:14:41 <tdammers> a.k.a. the Rubber Duck Approach
05:14:46 <quicksilver> #teddybeareffect
05:14:54 <tdammers> same thing :)
05:15:03 <hpc> im about this close to writing a RubberDucky bot, which when asked questions, responds with "can you explain what you mean by that?" and stuff like that
05:15:16 <rostayob> hpc: this has already been done, in the 60s (ELIZA)
05:15:30 <quicksilver> we already wrote that bot, hpc, using 'mechanical turk' methods :)
05:15:34 <hpc> rostayob: that was a psychologist :P
05:15:47 <rostayob> hpc: well, I'd guess there isn't' much difference :P
05:16:41 <teneen> Any example of a Functor that's not an Applicative?
05:16:56 <rostayob> teneen: a Functor is always an Applicative.
05:17:08 <hpc> not always
05:17:09 <rostayob> it's even in the class declaration
05:17:13 <rostayob> damn
05:17:16 <hpc> there are functors that don't have 'pure'
05:17:16 <rostayob> i meant the opposite
05:17:31 <rostayob> yes sorry
05:17:32 <teneen> hpc: any concrete example?
05:17:36 <hpc> i can't think of any off the top of my head
05:17:40 <ski> hm, i think `CoYoneda IORef' is probably not an `Applicative'
05:17:46 <hpc> stick around; someone's bound to know the answer
05:18:35 <hpc> i want to say Set, but that's not a functor either
05:18:36 <quicksilver> ski: well IORef is really nothing like a functor
05:18:42 <quicksilver> ski: so that's not terribly surprising is it?
05:18:49 <ski> `CoYoneda IORef' is, however
05:19:12 <Phlogistique> can't hoogle/hayoo answer teneen?
05:19:14 <hpc> (IO :. IORef) is a functor, for (:.) = type composition
05:19:50 <hpc> Phlogistique: don't think the search stuff is advanced enough for that kind of query
05:20:05 <teneen> All examples which I know of functors, can be made Applicative by undefined
05:20:15 <gregATio> a set isnt a functor? im sure a set can be mapped over
05:20:15 <ski>   data CoYoneda f b = forall a. FmapIncl (a -> b) (f a)
05:20:52 <hpc> gregATio: (Set a) isn't parameterized by arbitrary a
05:21:01 <ski>   instance Functor (CoYoneda f)
05:21:03 <ski>     where
05:21:04 <ski>     fmap bc (FmapIncl ab fa) = FmapIncl (bc . ab) fa
05:21:07 <alpounet> gregATio, there's the Ord a constraint
05:21:11 <hpc> gregATio: it has an Ord constraint for removing duplicates and keeping things sorted for performance
05:21:12 <quicksilver> gregATio: it's a quirk of haskell that it isn't
05:21:20 <quicksilver> and annoying one, no-less
05:21:41 <ski> teneen : using that, i think `CoYoneda IORef' is an example
05:22:05 <gregATio> so a functor cant have an Ord constraint? (forgive me im fairly new to haskell)
05:22:08 <teneen> ski: but it can be made an instance of Applicative very easily
05:22:15 <ski> teneen : how ?
05:22:30 <hpc> gregATio: assuming Functor f, fmap :: (a -> b) -> f a -> f b
05:22:34 <hpc> gregATio: for ALL a, b
05:22:41 <hpc> gregATio: which doesn't happen for Set
05:23:10 <hpc> gregATio: you would have fmap :: Ord a, Ord b => (a -> b) ...
05:23:17 <hpc> gregATio: which isn't valid
05:23:31 <gregATio> aha
05:23:34 <teneen> instance Applicative (CoYenda f) where pure x = undefined; _ <*> _ = undefined
05:24:00 <gregATio> interesting that the constraint on a Set is Ord and not Eq
05:24:10 <rostayob> teneen: since every type is inhabited, then you can instantiate every class for every type with an appropriate kind...
05:24:33 <hpc> gregATio: Set is implemented as a sorted tree
05:24:37 <koeien> gregATio: that's for implementation reasons
05:24:41 <rostayob> teneen: but that instance clearly breaks the Applicative laws
05:24:54 <koeien> gregATio: it could have Eq, but then it'd be less efficient
05:25:02 <koeien> (far)
05:25:27 <gregATio> aha that makes sense, makes it faster to find duplicates i guess :-\, albeit lacking a touch of integrity
05:25:44 <teneen> rostayob: which one?
05:25:51 <Phlogistique> couldn't an FFI implementation of set use the order on the representation to be efficient without the Ord restriction?
05:26:02 <rostayob> teneen: pure x = undefined; _ <*> _ = undefined
05:26:21 <rostayob> since pure id <*> v /= v
05:26:29 <hpc> Phlogistique: you still need the Eq instance; that's semantics, not performance
05:26:33 <koeien> Phlogistique: not really, (==) is still needed
05:26:40 <gregATio> ive always been of the opinion to get something right first then worry about performance
05:26:55 <koeien> two equal things could have different binary representations
05:27:09 <rostayob> gregATio: well i doubt that you'd ever want a set with linear lookup...
05:27:31 <rostayob> and insertion
05:28:23 <gregATio> whats more important having integrity or being fast?
05:28:34 <Phlogistique> koeien: that would still be better
05:28:46 <rostayob> gregATio: a Set in the programming word is almost bound to have logarithmic lookups.
05:29:04 <rostayob> so I think that everyone would agree that it's better to have that and the Ord constraint
05:29:44 <Phlogistique> gregATio: what's the point of using Set if it doesn't have a fast implementation? You can implement a linear version in 3 lines of Haskell
05:31:46 <gregATio> haskell is a research language that prides itself on purity, it didnt have a proper way to handle side effects, but refused to compromise like other languages then stm came along, im just saying im suprised to find a compromise thats all
05:31:57 <koeien> haskell is also practical
05:32:00 <rostayob> gregATio: it's not a compromise
05:32:11 <koeien> it's a balance
05:32:15 <gregATio> er except set isnt a functor
05:32:17 <rostayob> that's the most natural way to define a set-like data structor
05:32:18 <hpc> gregATio: it's just not possible to get a Functor instance without breaking semantics
05:32:24 <rostayob> gregATio: it couldn't be a functor anyway
05:32:28 <rostayob> since you need the Eq constraint
05:32:42 <rostayob> *structure
05:32:49 <mm_freak> it's not even a balance…  it's a fully correct solution with the added benefit that you can make composable imperative programs
05:32:53 <mm_freak> haskell is a great imperative language
05:33:05 <gregATio> aha... fair enough, sorry i dont mean to sound antagonistic, i just need to work these things through in my head
05:33:35 <koeien> no problem, i understand the initial surprise completely
05:33:51 <rostayob> gregATio: btw, it is very annoying that you can't instantiate Set with Functor
05:34:06 <gregATio> rostayob: lol
05:34:14 <rostayob> so you are right in being surprised that you can't do that
05:34:16 <mm_freak> you can in GHC 7.4, but not Functor, but RFunctor
05:34:26 <koeien> what's an RFunctor?
05:34:36 <rostayob> mm_freak: this is a more general problem anyway
05:34:42 <mm_freak> true
05:34:51 <mm_freak> koeien: a functor with an associated constraint
05:35:00 <gregATio> brb guys , thanks for explaining...
05:35:01 <mm_freak> GHC 7.4 will come with the ConstraintKinds extension
05:35:12 <koeien> ah, new magic that i'll learn whenever the time comes :)
05:35:21 <rostayob> you don't even need ConstraintKinds, just type families, right?
05:35:42 <arunkjn> what is haskell all about?
05:35:46 <rostayob> arunkjn: cheese
05:35:50 <arunkjn> i am new to it
05:35:53 <arunkjn> sorry
05:35:57 <mm_freak> class RFunctor f where type FuncConstr :: * -> Constraint; fmap :: (FuncConstr a, FuncConstr b) => (a -> b) -> (f a -> f b)
05:36:01 <hpc> arunkjn: it's a story of love, loss, and stolen bukkits
05:36:10 <arunkjn> ok
05:36:17 <hpc> it's also a general-purpose programming language
05:36:19 <arunkjn> then how can i learn that story
05:36:20 <rostayob> arunkjn: haskell main traits are: purity, you can't have side effects (in other words, immutability)
05:36:22 <hpc> @where lyah
05:36:22 <arunkjn> ??
05:36:22 <lambdabot> http://www.learnyouahaskell.com/
05:36:24 <hpc> ^ for more
05:36:25 <rostayob> lazyness
05:36:25 <mm_freak> rostayob: no, you really need the constraint kind to add constraints to functors
05:36:37 <rostayob> and a very expressive type system
05:36:45 <arunkjn> cool
05:36:56 <mm_freak> arunkjn: one can summarize haskell as the science of safety and composability
05:37:12 <mm_freak> haskell is all about types and composition patterns
05:37:38 <mm_freak> and perhaps domain-specific languages, if you want to mention that explicitly
05:38:21 <rostayob> mm_freak: you can hack your way around it, i remember this: http://hackage.haskell.org/packages/archive/rmonad/0.5/doc/html/Control-RMonad.html
05:39:25 <walter_> Hello. I had a Prolog course at the university... which ended up making me hate Prolog. But I'm now sort of starting to see that declarative programming might be a good thing to learn. The question is - would you recommend learning Haskell as something to be used together with C? For example, to write parsers in or to get into some AI problems? Or should I try and learn something else, at least for now?
05:39:32 <mm_freak> interesting solution
05:39:34 <^^thief^^> is there some way i can accept user input in a parsec parser?
05:39:43 <rostayob> walter_: firstly, Prolog is great
05:40:11 <^^thief^^> "No instance for (MonadIO Data.Functor.Identity.Identity)
05:40:11 <^^thief^^>       arising from a use of `liftIO'"
05:40:15 <rostayob> walter_: secondly, haskell excells at parsers and AI. so go for it. haskell excells at almost anything.
05:40:21 <dmwit> ^^thief^^: Well, there's ParsecT, so... use ParsecT IO, I guess.
05:40:25 <dmwit> Seems a bit questionable, though.
05:40:50 <walter_> I suspect I should have gotten in deeper with Prolog before writing it off, but I just don't feel like it to be honest
05:40:50 <^^thief^^> well im parsing a csv file and i need to deal with incorrect input
05:41:09 <dmwit> ^^thief^^: Doing IO during parsing is not the right way to deal with it.
05:41:13 <mm_freak> ^^thief^^: perhaps you want parsers as iteratees
05:41:25 <mm_freak> that's a reasonable way to interleave parsing with IO
05:41:29 <dmwit> The right way to deal with it is to have the parsing fail, and have a wrapping piece of IO that reports this to the user and asks what to do next.
05:41:55 <mm_freak> walter_: haskell is definitely a great language to learn, but beware, it will ruin you for all other languages =)
05:41:56 <dmwit> s/is not the right way/*probably* is not the right way/
05:42:11 <^^thief^^> perhaps i should just parse the csv file into strings then run separate methods on the result where i can accept user input?
05:42:12 <arw> walter_: combining haskell and C is often a great idea, since stuff which C is terrible at, like parsing, strings, generic programming is easy in haskell. otoh stuff that haskell sucks at, like systems programming, library support, is easy to add via C. so imho its a good combination.
05:42:18 <rostayob> mm_freak: that's not true
05:42:40 <rostayob> (the haskell makes you hate other languages bit)
05:42:43 <rostayob> i never understood that
05:42:56 <mm_freak> do you have to use PHP sometimes?
05:43:02 <walter_> mm_freak: I doubt it, I love C too much
05:43:02 <rostayob> mm_freak: i'd hate PHP anyways.
05:43:11 <rostayob> but i use other languages
05:43:16 <mm_freak> rostayob: i never liked PHP, but haskell made me hate it completely
05:43:20 <hpc> mm_freak: learning haskell has made me a much better perl programmer
05:43:24 <mm_freak> walter_: i loved C as well
05:43:36 <rostayob> mm_freak: i think that's just because you're a better programmer now and you understand what's wrong...
05:43:52 <rostayob> instead of just feeling "this is ugly" :P
05:43:58 <walter_> arw: I see, that's more or less what I was thinking. thanks.
05:43:59 <mm_freak> i came from the C/C++ world to haskell…  i wouldn't say i /hate/ C/C++, but i see much fewer applications for them
05:44:09 <^^thief^^> mm_freak: I have no idea what "parsers as iteratees" means - can you point me at a useful resource?
05:44:12 <hpaste> erus` pasted “the code” at http://hpaste.org/56151
05:44:30 <rostayob> as someone said, using C for non-system programming is criminal negligence.
05:44:34 <erus`> is it possible to prove than eq1 is of type eq2 without infinite loop?
05:44:42 <mm_freak> ^^thief^^: http://www.yesodweb.com/book/enumerator
05:44:47 <^^thief^^> thanks
05:45:27 <mzero> ^^thief^^: (sorry I missed the preamble) - unless you need to do IO in order to proceed with the parse (like you have to read dynamic syntax extensions while your parsing) --- parsing as iterates is probably overkill
05:45:28 <erus`> (where both are inifinite lists)
05:45:51 <teneen> Can this type be made an Applicative? data Ins b = forall a. Ins {ins ::(a -> b)}
05:46:00 <mzero> if what you are trying to do is recover from parse errors, or report them nicely, then Parsec is completely able here
05:46:37 <mzero> if you need to feed the IO in real time (rather than wait for the whole input at once), then attoparsec is your package
05:46:58 <mm_freak> teneen: i don't see why not
05:47:02 <rostayob> teneen: isn't it the same as (a ->)?
05:47:03 <^^thief^^> mzero: I'm trying to parse a csv file into a list of records, converting one of the cells into valid date objects
05:47:09 <mm_freak> rostayob: nope
05:47:12 <arw> rostayob: c is definitely overused, but mostly due to a lack of sane alternatives.
05:47:15 <rostayob> ah, the existential
05:47:16 <mm_freak> rostayob: the existential changes everything
05:47:16 <walter_> oh yeah, one more thing: how's Haskell in terms of speed?
05:47:25 <koeien> excellent, if you wish
05:47:29 <^^thief^^> mzero: the input in the date cells may not be valid though, in which case id like to ask the user to fix it
05:47:29 <rostayob> arw: no, people
05:47:33 <teneen> mm_freak: so?
05:47:34 <koeien> it can be very fast
05:47:42 <rostayob> arw: no, people code stuff in C that shouldn't be coded in C
05:47:46 <walter_> because I remember Prolog being pretty bad
05:47:52 <rostayob> and there are alternatives
05:47:52 <mm_freak> walter_: well written code will usually run at about half the speed of C…  sometimes slower, sometimes faster, sometimes even exceeding C (when it comes to concurrent programs)
05:47:58 <teneen> mm_freak: do you know a calid instance declaration for it?
05:48:07 <rostayob> walter_: there are really fast prolog implementations, but they'll be fast at doing prolog...
05:48:11 <mzero> ^^thief^^: so - parse the WHOLE thing, put a Either String Date where you do the date parsing
05:48:15 <mm_freak> teneen: 'pure' would be the constant function, and <*> would feed its own input to both arguments
05:48:20 <rostayob> ofc prolog is not really strong for algorithmic stuff
05:48:30 <dmwit> mzero++
05:48:38 <mzero> then scan the result of the parse (in IO) and for each Left bad-input   ask the user there
05:48:40 <^^thief^^> mzero: ok that makes sense
05:48:50 <mm_freak> teneen: but how is that type useful?  or to ask differently, where would the values of type 'a' come from?
05:48:58 <teneen> mm_freak: I tried something similar and it didn't work
05:49:02 <mzero> remember - it's lazy - so it feels weird (at first) to parse the WHOLE file before asking the user
05:49:10 <rostayob> btw, why didn't they introduce a keyword "exists" for existentials?
05:49:12 <mzero> but hey, the parse will proceed incrementally
05:49:17 <rostayob> it's so confusing to se a forall
05:49:30 <arw> rostayob: yes, but people do that for a reason
05:49:34 <rostayob> it's a language extension anyway
05:49:40 <teneen> mm_freak: I know it isn't useful, I just want to show it's not an Applicative
05:49:48 <rostayob> arw: do they? which reason? why would you code, let's say, a desktop application in C?
05:49:58 <^^thief^^> mzero: thanks Ill give it a shot
05:50:13 <rostayob> arw: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
05:50:14 <arw> rostayob: because the only viable alternative to C is C++, which also sucks.
05:50:20 <rostayob> ops, that was for teneen
05:50:20 <singpolyma> rostayob: what sort of desktop application?  C can b every good at that
05:50:34 <frerich> rostayob: I guess you'd have to ask the entire Microsoft development staff working on early Windows versions. Or The hundreds of developers working on the GTK toolkit and/or the Gnome desktop environment. :-}
05:50:45 <rostayob> arw: no it isn't, can't you just use python, java, whatever?
05:50:53 <arw> rostayob: the rest is either scripting languages, non-portable, without libraries, etc.
05:51:01 <arw> rostayob: in short: no useful alternatives.
05:51:01 <koeien> Java.
05:51:03 <rostayob> java is very portable, same for python
05:51:05 <koeien> C#.
05:51:16 <mzero> ^^thief^^: you might want to put things like line numbers into your parsed result - you can get that info from Parsec via getPosition
05:51:17 <teneen> rostayob: Thanks I saw that thread before. It doesn't have a valid example of a Functor which is not Applicative
05:51:19 <rostayob> there were no alternatives in 1995
05:51:19 <koeien> well yeah C# is not that portable
05:51:34 <mm_freak> teneen: hmm…  in fact i'm not sure how to define it
05:51:37 <singpolyma> rostayob: so, portability is a bit reason, but I do stuff in ruby/haskell and other stuff.  But why should one *not* do it in C?  C can be very good at some apps
05:51:40 <mzero> so perhaps for each date, put out    Either (SourcePos, String) Date
05:51:42 <arw> rostayob: python doesn't have static type safety, which is usually nice. java doesn't support any libraries that C supports without major pain.
05:51:53 <mm_freak> teneen: without a source for the input values, this indeed doesn't seem to be an Applicative
05:51:58 <koeien> singpolyma: because using C is a pain
05:52:05 <rostayob> singpolyma: because C brings a slew of problems that are solved automatically in modern languages
05:52:20 <teneen> mm_freak: I also think so
05:52:24 <mm_freak> teneen: i had a similar type, which is in fact an applicative functor:  data LocalState a = forall s. LS s (s -> (a, s))
05:52:32 <mm_freak> there the first argument to the constructor is the source
05:52:35 <rostayob> arw: java has a TON of libraries. more than what you'd ever wish. python type-unsafety is nothing compared to C memory unsafety.
05:52:37 <singpolyma> koeien: if you find using C a pain, don't use it.  I'm asking why someone who likes C should choose to not use it just because he's building a "desktop application"
05:53:00 <singpolyma> rostayob: It also gives you control over others (such as RAM use)
05:53:17 <koeien> if you enjoy it, sure.
05:53:18 <arw> rostayob: that is has libraries is true. but usually you need very specific ones.
05:53:32 <rostayob> arw: if you want to code a GUI app, you'll have them.
05:53:40 <yrlnry> The dark side of "control of all the details" is "opprotunity to screw everything up"
05:53:43 <daimrod> C gives you so much power that we usualy use valgrind to debug it.
05:53:50 <singpolyma> yrlnry: yes
05:53:58 <rostayob> singpolyma: it's just not worth it. sure if you are a C junkie go on, but you're choosing the needlessly tricky way
05:53:58 <singpolyma> daimrod: sure.  I love valgrind
05:54:02 <teneen> mm_freak: I can't see the difference in LocalState which allows it to be an Applicative. Can you ellaborate?
05:54:03 <arw> rostayob: usually you don't code just a GUI app. usually you code a gnome/kde/whatever app.
05:54:11 <rostayob> arw: yeah
05:54:13 <yrlnry> I love eating Tylenol after I pound my head against the wall!
05:54:29 <yrlnry> ← has been programming in C for 25 years come this spring.
05:54:37 <q0tw4> C is faster
05:54:44 <mzero> singpolyma: C does not offer enough guaranteed correctness by modern standards -- it just isn't a strong enough tool for modern production engineering
05:54:46 <rostayob> q0tw4: C is slow. assembly is faster.
05:54:50 <singpolyma> My three "main" lanugages (ones I choose to do stuff in by default) are Ruby, Haskell, C (haskell being the recent addition).  Now that I have Haskell there are things I did in C that I will do in Haskell, but I don't feel like I no longer need C
05:55:01 <rostayob> singpolyma: I never said that
05:55:01 <mzero> If you enjoy it, sure - but people write applications in Forth too!
05:55:06 <rostayob> (that you never need C)
05:55:10 <mm_freak> teneen: LS s0 ff <*> LS t0 xf = LS (s0, t0) $ \(s', t') -> let (f, s) = ff s'; (x, t) = xf t' in (f x, (s, t))
05:55:32 <singpolyma> rostayob: oh?  sorry, I did come in partway through
05:55:35 <mm_freak> teneen: the difference is the first argument to the LS constructor, which is an actual value you can pass to that underlying function
05:55:43 <erus`> whats the word for when a * b  = c but b * a = d ?
05:56:00 <rostayob> erus`: non transitive operator
05:56:03 <Ke> discussing C again
05:56:06 <srhb> Noncommutativity?
05:56:07 <rostayob> sorry, commutative
05:56:08 <srhb> Oh.
05:56:20 <q0tw4> Haskell can be faster than C but supercompilers is not ready for production
05:56:21 <singpolyma> Also: isn't haskell only like 10 years (or a bit less) newer than C?
05:56:24 <mm_freak> teneen: on the other hand, in a denotational sense your type seems to be equivalent to Identity, which is not just an applicative functor, but also a monad
05:56:30 <erus`> ah thats it thanks
05:56:32 <rostayob> singpolyma: 20 years newer than C
05:56:39 <teneen> mm_freak: Ohh I see
05:56:49 <singpolyma> rostayob: really?  haskell 1.0 was, what, 1992 or something?
05:56:52 <mm_freak> teneen: note how the only value you could ever pass to such a function is bottom, and if you disallow bottom, you got Identity
05:56:59 <rostayob> singpolyma: yes, 1990 - 1970 = 20
05:57:17 <singpolyma> rostayob: hmm, ok.  so two decades
05:57:37 <singpolyma> It still feels funny to call something from 1990 "new".  even H98 is hardly "new"
05:57:37 <rostayob> haskell is half the age of C
05:57:47 <singpolyma> but maybe that's my age talking
05:57:56 <rostayob> haskell is average aged in terms of programming languages
05:58:12 <rostayob> Fortran, C, C++, Perl, Haskell, Python, Java, Ruby
05:58:13 <teneen> mm_freak: You mean the function within the constructor of Ins ?
05:58:16 <rostayob> forgot Lisp
05:58:19 <mm_freak> teneen: yes
05:58:51 <singpolyma> yeah, I guess people call ruby "new" and it's '95
05:58:59 <teneen> mm_freak: thanks a lot
05:59:01 <rostayob> and call Java old
05:59:11 <rostayob> while java is pretty new. and already pretty much frozen.
05:59:48 <q0tw4> C# is better than java I think
05:59:58 <singpolyma> rostayob: wow.  that's funny.  I guess people don't know what new and old mean
06:00:04 <rostayob> C# runs on a proprietary runtime
06:00:08 <singpolyma> q0tw4: C# is maybe a tab beter, but they're both terrible
06:00:20 <rostayob> they're not that terrible... but let's not go there again :P
06:00:36 <singpolyma> q0tw4: and I lost any respect for C# when I found out they intentionally repeated Java's broken-not-quite-UTF16 mistake
06:00:42 <mzero> mono is an open source, free implementation of the CLI, and C# (and related languages) run on it
06:00:58 <rostayob> mzero: and it's always kind-of behind, last time i checked. but that was a while ago.
06:01:16 <mm_freak> did you guys know microsoft is working on a dependently typed language?  i was very surprised
06:01:18 <q0tw4> vala can be replacement for C#
06:01:19 <mm_freak> it's called F*
06:01:20 <arw> singpolyma: thats a windows mistake. which is fairly understandable, c# being windows-only.
06:01:27 <henriavelabarbe> Hi, do you know if Osker source code is available for public review ?
06:01:29 <mzero> it is a bit - but it is a quite workable systen, and you can (and I have) deployed production systems with it
06:01:35 <rostayob> mm_freak: Microsoft also funds GHC eh...
06:01:42 <singpolyma> arw: oh, really?  windows has that too.  That makes more sense then, but it's still silly
06:01:54 <rostayob> we could say that no microsoft = no haskell
06:02:00 <rostayob> haskell as it is right now
06:02:03 <singpolyma> q0tw4: vala is nifty, but it only runs with gobject and other stuff around
06:02:07 <rostayob> so thank you microsoft! eheh
06:02:09 <mm_freak> but when i looked into F*, it seems to be a square wheel reinvention of agda
06:02:20 <erus`> is ehrid in here?
06:02:34 <erus`> from Stack overflow
06:02:39 <rostayob> erus`: no. what happened to your nick list?
06:02:51 <arw> singpolyma: well, windows up to 2000 was ucs2-only, xp transitioned to utf-16, with some weird not-quite-isms.
06:03:00 <erus`> he might use a different nick on stackoverflow
06:03:01 <erus`> i do
06:03:16 <rostayob> ah. then it's going to be hard to know. why would you do that anyway?
06:03:28 <mm_freak> i must say, microsoft has interesting research projects…  unlike most other companies they seem to be interested in fundamental problems instead of patching broken languages
06:03:47 <q0tw4> Every high level language needs for runtime library
06:04:15 <rostayob> mm_freak: they also manage to push those changes in the mainstream (F#, LINQ). microsoft has been a godsend for programming languages, as far as i can see
06:04:59 <mm_freak> yeah, now just wait another 30 years for the industry to catch up
06:05:05 <mm_freak> they still use PHP for web development
06:05:14 <rostayob> you really don't like PHP do you
06:05:33 <arw> there is no catching up, fortran and cobol are also still widely used in their niches.
06:05:35 <erus`> Guys how can i check equality of recursive structures?
06:05:52 <Saizan> erus`: recursing!
06:05:57 <rostayob> erus`: that is a pretty hard problem
06:06:03 <mm_freak> rostayob: "don't like" is largely understated
06:06:09 <erus`> Saizan: halting problem
06:06:15 <singpolyma> mm_freak: we had things better than PHP when PHP came out, I don't think they use PHP because it was best at the time, so I don't think the existence of better things now will stop them
06:06:19 <mzero> erus`: structure like     data Foo = A String | B Int Foo | C Int Foo Foo
06:06:20 <mzero> ?
06:06:32 <rostayob> erus`: and sometimes you can't, e.g. you can't check for equality of two infinite lists
06:06:36 <walter_> i need to go, thanks for the answers and bye. i'll pick up some haskell tutorial tomorrow.
06:06:41 <Saizan> erus`: yeah, on infinite values the comparison won't terminate
06:06:57 <rostayob> but if the nodes of the recursive structure are tagged in some ways
06:07:01 <erus`> i dont have infinite lists i have indexs now
06:07:09 <mm_freak> singpolyma: hence my very optimistic estimate of 30 years
06:07:11 <erus`> De Bruijn index
06:07:17 <erus`> but i duno what todo with them
06:07:24 <mzero> haste what you have, perhaps?
06:07:26 <Saizan> compare them for equality
06:07:29 <erus`> some guy said use a stack
06:07:43 <rostayob> erus`: you're transforming lambda terms to nameless form?
06:08:01 <ski> mm_freak : `data Ins a = forall x. Ins {ins :: x -> a}; instance Functor Ins where {fmap ab (Ins xa) = Ins (ab . xa)}; instance Applicative Ins where {pure a = Ins (\() -> a); Ins (xab) <*> Ins (ya) = Ins (\(x,y) -> xab x (ya y))}' doesn't work ?
06:08:02 <mm_freak> erus`: if comparing them is not undecidable, you can try to restate the same structures in agda and prove their equality there
06:08:05 <erus`> rostayob: kinda, im checking if types are compatible
06:08:12 <rostayob> erus`: you already have types?
06:08:28 <q0tw4> I think that lisp-like language + theorem prover (for typing) will be very good for real life.
06:08:30 <rostayob> oh, got to go
06:08:32 <mm_freak> ski: nope
06:08:41 <mm_freak> ski: that's what i tried
06:09:15 <hpaste> erus` pasted “example” at http://hpaste.org/56152
06:09:32 <mm_freak> ski: obviously it can't unify the two existential types
06:09:54 <mm_freak> q0tw4: or just haskell, since you can prove most important properties there
06:10:05 <singpolyma> q0tw4: lisp-like in features or in syntax?  I don't think that syntax is very good for real life :P
06:10:35 <ski> mm_freak : that's not what i do
06:12:04 <mm_freak> ski: try it
06:12:09 <Saizan> erus`: so the index is for type variables?
06:12:35 <erus`> its like x levels down
06:12:47 <singpolyma> Does anyone know what the current status on compiling for other target (cross-compiling) with ghc is?  Different wiki pages show different levels of status
06:13:25 <erus`> Saizan: De Bruijn index
06:13:26 <Saizan> erus`: but levels of what? what does it refer to?
06:13:55 <Saizan> erus`: yeah, you said that, but what is the binder in your datatype?
06:14:04 <erus`> so in numberList 'Index 2' evaluates to the root structure eg Limited [...
06:14:34 <Saizan> what does Limited mean?
06:14:46 <erus`> oh Limited can be any of its members
06:14:51 <q0tw4> I think that theorems about types is more flexible that concrete type system. And it is hard (for begginres) to work where context can affect function behavior
06:15:07 <erus`> Number could be a Limited [Number, Tuple []]
06:15:11 <Saizan> so it's meant to be something like Either ?
06:15:18 <erus`> kinda
06:15:59 <Saizan> ok, so i think you don't fully understand how de Bruijn indexes are meant to work
06:16:32 <Saizan> because it's not enough to have the Index constructor, you also need another constructor to mark the position the indices refer to
06:16:42 <mm_freak> ski: IMO the only valid input to an Ins function is bottom
06:17:12 <dmwit> erus`: Are you explicitly representing cycles in your data structures now? If so, TAPL has a nice section on checking coinductive relations (in the subtyping with recursive types chapter).
06:17:25 * hackagebot GHood 0.0.4 - A graphical viewer for Hood  http://hackage.haskell.org/package/GHood-0.0.4 (HugoPacheco)
06:17:30 <Saizan> oh, wait, you're using all the other constructors as binders, sorry
06:17:59 <dmwit> If not, well, that's the first step. =P
06:18:33 <q0tw4> But using haskell is fun
06:18:41 <Saizan> one usually have an explicit Fix constructor in the types, but i guess it works this way too
06:20:17 <Saizan> anyhow, "i know i'll use equi-recursion" is the "i know i'll use regexes" of recursive types :P
06:20:39 <teneen> mm_freak: Any reason why (CoYoneda f) cannot be made an Applicative?
06:20:41 <Saizan> but the chapter in TAPL should be a start
06:21:21 <erus`> how about id i check could i just stack every comparison
06:21:34 <mm_freak> teneen: what's the definition?
06:21:36 <erus`> no wait
06:21:52 <teneen> mm_freak: data CoYoneda f b = forall a. FmapIncl (a -> b) (f a)
06:23:36 <erus`> i could get just store every position i check
06:23:45 <erus`> if i reach a dupe then i know its the same
06:24:10 <erus`> because checking is stateless
06:24:46 <pagos> haskell is neat
06:24:58 <byorgey> true
06:25:48 <koeien> lol
06:27:01 <dmwit> erus`: Here's a tricky case to consider: is (Fix (Arrow 1 0) == Fix (Arrow 1 (Arrow 1 0)))?
06:27:25 * hackagebot wxdirect 0.13.1.1 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.13.1.1 (KidoTakahiro)
06:27:30 <dmwit> (where "0" is meant to be the deBruijn index pointing at the Fix, and "1" is meant to be a deBruijn index pointing at an unbound variable)
06:27:47 <erus`> dmwit: im gonna use tree indexes now
06:28:01 <erus`> eg count each leaf branch by branch
06:28:16 <dmwit> I don't know what that means.
06:28:22 <erus`> its hard to explain
06:28:55 <byorgey> if it's hard to explain then you don't know what it means either =)
06:29:01 <dmwit> Do you understand why the case I proposed is tricky? If so, then perhaps you can adapt it to your weird indices.
06:29:06 <erus`> its like if you try to take every right hand turn
06:29:08 <ski> mm_freak : i just tried it, it loaded
06:29:12 <ski> erus` : `Limited' is a union type ?
06:29:13 <erus`> and count each corner you get to
06:29:19 <ski> <erus`> i wish there was types for lists of n items or greater :)
06:29:19 <ski> erus` : you may want to look into refinement types
06:29:32 <ski> mm_freak : "<mm_freak> ski: IMO the only valid input to an Ins function is bottom" -- i agree
06:30:02 <dmwit> erus`: Your explanation isn't helpful, in part because I don't know what tree it is you're using for your index.
06:30:27 <ski> teneen : for some `f' i think `CoYoneda f' can be `Applicative', but not for `CoYoneda IORef'
06:30:53 <Saizan> dmwit: http://hpaste.org/56152
06:31:11 <ski> teneen : because to be able to write `pure :: a -> CoYoneda IORef' you have to be able to create an `IORef b', for some `b', and you can't do that directly
06:31:27 <ski> (you can only do it as a monadic result in the `IO'-monad)
06:31:42 <ski> sorry, `pure :: a -> CoYoneda IORef a'
06:32:06 <erus`> http://imgur.com/WwJhL
06:32:10 <erus`> counting left to right
06:32:13 <erus`> level by level
06:32:26 <erus`> err i messed up 2
06:32:29 <erus`> but u get the idea
06:32:43 <dmwit> Saizan: Seems he isn't explicitly representing cycles, then?
06:32:47 <erus`> 5 = 2 , 2 = 3, 3 = 4
06:33:21 <ski> > let 5 = 2 ; 2 = 3 ; 3 = 4 in "yessir !"
06:33:22 <lambdabot>   "yessir !"
06:33:27 <Saizan> dmwit: he doesn't have a Fix constructor, but rather the indices point to the right amount of levels up in the tree
06:33:52 <dmwit> Aha.
06:33:56 <Saizan> dmwit: it's a bit like having Fix everywhere except around Index
06:34:04 <dmwit> right
06:34:20 <dmwit> Alright, then here's my tricky question:
06:34:37 <dmwit> is (Function Number 1) == (Function Number (Function Number 2))?
06:35:08 <dmwit> err
06:35:11 <erus`> yes
06:35:16 <erus`> they should type check
06:35:20 <dmwit> Function Number (Index 1) == Function Number (Function Number (Index 2)), I guess
06:35:33 <erus`> is that even possible?
06:35:47 <erus`> maybe i will get an award
06:35:53 <dmwit> Yes, it's possible, but it means you will need a bit of machinery.
06:35:59 <erus`> for outstanding contribution to CS
06:50:32 <ski> mm_freak : any feedback ?
06:55:26 <mm_freak> ski: very strange!
06:55:38 <mm_freak> it didn't work for me, because i used 'let'
06:55:43 <mm_freak> without 'let' it worked
06:55:51 <mm_freak> probably because of polymorphism
06:55:57 <ski> `let' for matchin on `Ins' ?
06:56:03 <mm_freak> no
06:56:20 <mm_freak> \(s, t) -> ff s (xf t)
06:56:31 <ski> vs. ?
06:56:37 <mm_freak> was:  \(s, t) -> let f = ff s; x = xf t in f x
06:56:45 <mm_freak> i'll try with type signatures
06:57:47 <mm_freak> D'OH!
06:57:53 <mm_freak> silly me
06:57:57 <mm_freak> i was shadowing a name
06:59:45 <mm_freak> what i called (s, t) above i called (x, y) in my actual code, then f = ff x; x = xf y obviously can't work
07:01:42 * ski nods
07:02:01 <mm_freak> but i'd still say that this type is pretty much Identity…  strict functions will always bottom, nonstrict functions are constant functions
07:15:43 <owst> Does anyone know what causes Happy to become sad and call notHappyAtAll? With a quick glance at the generated hs file I can't see an obvious cause.
07:20:24 <masylum> hi
07:20:44 <alistra> how to implement a 'random sublist of a list' in haskell
07:20:59 <alistra> i want to evade some randomRIO hacking :/
07:21:06 <alistra> is there something already?
07:21:23 <copumpkin> alistra: define what it means first of all? uniformly random in the sense that every element is either picked or not picked with 50% chance?
07:21:25 <copumpkin> then filterM will do it
07:21:30 <copumpkin> in a suitable monad
07:22:11 <alistra> so like filterM (randomRIO :: Bool) list?
07:22:15 <alistra> :t filterM
07:22:16 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:22:38 <Saizan> filterM (const randomIO)
07:23:02 <alistra> Saizan: thx
07:23:04 <copumpkin> or you could do it in a more restricted randomness monad
07:23:07 <copumpkin> if you don't like IO
07:25:03 <alistra> Prelude Control.Monad System.Random> filterM (const (randomIO :: IO Bool)) ([1,2,3,4,5] :: [Integer])
07:25:03 <alistra> [2,4,5]
07:25:03 <alistra> Prelude Control.Monad System.Random> filterM (const (randomIO :: IO Bool)) ([1,2,3,4,5] :: [Integer])
07:25:03 <alistra> [1,2,3,5]
07:25:03 <alistra> Prelude Control.Monad System.Random> filterM (const (randomIO :: IO Bool)) ([1,2,3,4,5] :: [Integer])
07:25:04 <alistra> [2,4]
07:25:12 <alistra> i already fuck around with files, so no worries
07:25:17 <alistra> copumpkin++
07:25:20 <alistra> Saizan++
07:25:24 <masylum> I have a doubt regarding Aeson
07:25:39 <alistra> copumpkin: i wish you will be a real pumpkin someday
07:26:06 <hpaste> “Pau ramon” pasted “parsing packets” at http://hpaste.org/56156
07:26:14 <byorgey> he is a real pumpkin on some days
07:26:19 <masylum> I want to parse a json file
07:26:20 <dmwit> Just remember: the sequence of first numbers to come out of a random number generator given arbitrary seeds is not random.
07:26:34 <masylum> but I always get back Nothing
07:26:53 <koeien> masylum: could you paste your code?
07:27:07 <masylum> yes
07:27:10 <koeien> @hpaste
07:27:11 <lambdabot> Haskell pastebin: http://hpaste.org/
07:27:19 <masylum> “Pau ramon” pasted “parsing packets” at http://hpaste.org/56156
07:27:28 <dmwit> :t random
07:27:29 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
07:27:47 <masylum> the problem is converting to [(String), (String)]
07:28:27 <dmwit> > map (random . mkStdGen) [0..30] :: [Int]
07:28:28 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:28:28 <lambdabot>         against inferred type ...
07:28:44 <dmwit> > map (fst . random . mkStdGen) [0..30] :: [Int]
07:28:46 <lambdabot>   [-117157315039303149,7917908265643496962,-2493721835987381530,5541392136091...
07:35:02 <djanatyn> if you wrote a function that took a regular expression and a string to parse, it would be pure, right?
07:35:12 <djanatyn> are there any special things to consider when parsing regular expressions that could make them impure?
07:37:47 <gregATio> the regex engine in itself isnt especially pure
07:38:07 <gregATio> it needs to save groups for example
07:38:23 <Saizan> that can be done without involving mutation
07:38:41 <Saizan> and it depends on what the result type is
07:38:43 <djanatyn> is there a pure regular expression parser in haskell?
07:38:50 <djanatyn> and if not, would it be possible to write on?
07:39:06 <Saizan> most of them are, i think
07:39:19 <djanatyn> oh, cool.
07:39:22 <djanatyn> thanks :D
07:39:37 <Saizan> http://hackage.haskell.org/package/regex-tdfa <- e.g.
07:41:34 <Saizan> too bad regex-base has an ugly API
07:41:59 <jasonleds> Free PSN Store Codes   http://www.points2shop.com/?ref=uin1328881016
07:42:07 <hughfdjackson> :P too bad regex has an ugly API
07:42:38 <Botje> wow, long time no spammer
07:42:51 --- mode: ChanServ set +o copumpkin
07:42:55 --- mode: copumpkin set +b *!~jasonleds@c-68-55-116-174.hsd1.md.comcast.net
07:42:55 --- kick: jasonleds was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
07:43:02 --- mode: copumpkin set -o copumpkin
07:46:46 <alistra> @src putStrLn
07:46:46 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
07:46:53 <alistra> @src putStr
07:46:53 <lambdabot> putStr s  = hPutStr stdout s
07:47:50 <DukeDave> So, I can make a (higher order) type an instance of a class, but only if I place a constraint on the higher order type; am I doing it wrong?
07:48:15 <dolio> Example?
07:49:40 <DukeDave> data UpdatedOnFriday a = UpdatedOnFriday { updatedOnFriday :: Bool, a :: a }
07:50:21 <DukeDave> So I can define: instance Show (UpdatedOnFriday a), only if I have (instance Show a)
07:50:37 <dolio> Yeah, not surprising.
07:51:13 <DukeDave> Does that smell bad?
07:51:21 <dolio> No.
07:51:25 <dolio> That's standard.
07:51:52 <DukeDave> Ah excellent, so my question: Where should the constraint on 'a' be ?
07:52:10 <Silvah> What's standard?
07:52:12 <Saizan> instance Show a => Show (UpdatedOnFriday a) where
07:52:12 <dolio> instance Show a => Show (UpdatedOnFriday a)
07:52:29 <DukeDave> Okay, excellent, I just wasn't sure if that was valid
07:52:29 <dolio> If you derive Show for UpdatedOnFriday, that's exactly what you'll get.
07:52:44 <DukeDave> Oh yes, I always for get about derive
07:52:55 <dolio> Although, maybe you won't like the output it generates.
07:53:16 <dolio> It's going to look like "UpdatedOnFriday { updatedOnFriday = True, a = whatever }"
07:54:13 <Silvah> Hey, it's show. It's not meant for pretty-printing.
07:54:45 <dolio> I'd still probably rather have "UpdatedOnFriday True whatever"
07:56:30 <ski>   instance Show a => Show (UpdatedOnFriday a) where showsPrec p (UpdatedOnFriday b a) = showParen (p > 10) $ showString "updatedOnFriday " . showsPrec 11 b . showChar ' ' . showsPrec 11 a
07:56:37 <ski> Silvah : prettier ^
07:58:52 <Silvah> And how does the result look like?
07:59:12 <ski> like `UpdatedOnFriday True "whatever"', of course
07:59:53 <ski> the above is basically what you get if you do `data UpdatedOnFriday a = UpdatedOnFriday Bool a deriving Show'
07:59:53 <Silvah> :t showsPrec
07:59:54 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
08:00:06 <ski>   showsPrec :: Show a => Int -> a -> ShowS
08:00:13 <ski>   type ShowS = String -> String
08:00:32 <ski> the `Int' is the precedence at which to show the expression
08:01:02 <ski> application has precedence `10'
08:03:58 <^^thief^^> whats the best way of parsing a date string that could be formatted in a number of different formats?
08:04:30 <Silvah> Heh, I always thought that Show was only about show, never expected it's more sophisticated than that.
08:04:31 <^^thief^^> finding this rather difficult, really wishing for something as simple as PHP's strtotime!
08:06:03 <ski> `show' can be defined as `show a = shows a ""' with `shows = showsPrec 0'
08:15:56 <ski> hm, can bidirectional FDs like in `class C a b | a -> b , b -> a' be translated to associated types ?
08:16:48 <Enigmagic> i've heard it's possible but messy
08:17:13 <dolio> Yes.
08:17:38 <dolio> class (T1 a ~ b, T2 b ~ a) => C a b where T1 a :: * ; T2 b :: * ; ...
08:18:09 <ski> i was imagining one might be able to get `BofA' and `AofB' such that we have above `b = BofA a' and `a = AofB b' -- in particular `AofB (BofA a) = a' and `BofA (AofB b) = b'
08:18:24 <dolio> As long as you have those equality constraints.
08:18:31 <ski> mhm, ok
08:18:59 <dolio> If you go with the original plain associated types proposal, they're insufficient.
08:19:57 <ski> hm, ok -- that seems to work for cases like `class C a b c | a b -> c , c -> a , c -> b' as well
08:25:08 <Enigmagic> gah... Couldn't match type `t0' with `()' `t0' is untouchable
08:25:13 <Enigmagic> what does that even mean
08:25:31 * Enigmagic shakes his fist
08:26:14 <smarter> t0 comes from a low cast in India
08:26:30 <Enigmagic> that's what i was worried about :(
08:28:34 <byorgey> Enigmagic: it means that t0 is a type variable that must be held abstract
08:28:59 <byorgey> i.e. it is not allowed to unify with anything, it is just an abstract placeholder which is equal only to itself and nothing else
08:29:13 <byorgey> now, why you are getting that particular error is anyone's guess, unless you show us some code.
08:29:24 <c_wraith> did the skolem escape again?
08:30:58 <byorgey> Escaped skolem!  Authorities mount massive search.  News at 11.
08:32:04 <Enigmagic> byorgey: it's in a pretty big project so it doesn't make much sense by itself...
08:32:12 <djahandarie> @remember byorgey Escaped skolem!  Authorities mount massive search.  News at 11.
08:32:13 <lambdabot> I will never forget.
08:32:55 <Enigmagic> code in question works in a different module though... think it's because i'm using a lambda
08:38:05 <tsousa> Haskell is a functional language so it has to use recursion to iterate so it will be slower than perl app?
08:38:10 <tsousa> with a cicle?
08:39:00 <Enigmagic> tsousa: to california, or by bus
08:39:13 <MostAwesomeDude> tsousa: Yes, yes, no.
08:39:21 <MostAwesomeDude> Recursion is not slow in Haskell.
08:39:43 <geekosaur> it's also compiled, unlike perl, and compiler optimizations include tail recursion, fusion, and others that make it fast
08:40:09 <tsousa> yes but an perl version that uses cicles and a Haskell version that usea a recursive function the perl version will be faster right?
08:40:22 <koeien> what is a "cicle"?
08:40:28 <MostAwesomeDude> Probably "cycle."
08:40:46 <koeien> you mean loops?
08:40:54 <tsousa> yes
08:40:58 <koeien> no the haskell version is not necessarily slower -- in fact it is probably faster
08:41:02 <MostAwesomeDude> tsousa: TIAS. It depends on other things. I see no reason why one would be exceptionally faster than the other just on the basis of programming idioms.
08:41:17 <eyebloom> Is it always necessary to import common modules like Data.Map as qualified in order to prevent ambiguous occurrences with Prelude functions.
08:41:31 <koeien> eyebloom: necessary? no you can use Prelude.map and Data.Map.map
08:41:37 <koeien> (the fully qualified names)
08:41:47 <koeien> however, it's customary to import Data.Map qualified as M
08:42:00 <Enigmagic> or you could 'import Data.Map as Map'
08:42:04 <Enigmagic> then use Map.lookup
08:42:11 <eyebloom> right, it just leads to messy code.
08:42:32 <Enigmagic> doesn't need to be imported qualified
08:42:58 <eyebloom> how then might I override the Prelude definition.
08:43:06 <int-e> import qualified Prelude; import Data.Map
08:43:08 <Enigmagic> Map.lookup
08:43:09 <koeien> import Prelude hiding (...)
08:43:27 <eyebloom> I see.
08:43:45 <int-e> you may do that. but you'll probably confuse readers of the code. importing Data.Map qualified (as Map or M) is very common.
08:43:58 <Enigmagic> then again, I don't use single letter aliases most of the time because M could mean a lot of things but Map is more obvious imo
08:44:19 <int-e> M always means Data.Map in my code ;)
08:44:32 <geekosaur> also you're likely to discover just how common it is to use quick list functions (including String functions) from Prelude
08:44:43 <eyebloom> Likewise if I'm using both Data.Map and Data.Set in one module, I'd hope the compiler could figure out the difference between Set.empty and Map.empty
08:44:51 <eyebloom> Based on the type
08:45:10 <eyebloom> But it doesn't seem to want to do that either.
08:45:38 <MostAwesomeDude> eyebloom: It might not always be able to do that, and isn't required to try.
08:45:39 <Enigmagic> empty isn't overloaded, so you'll need to use the correct one for the type you want
08:46:02 <Saizan> it's required to not try and give an error instead.
08:46:10 <kuznero> Hi All!
08:46:21 <Saizan> kuznero: hi!
08:46:42 <eyebloom> Is there a way to help it try?
08:47:16 <Enigmagic> eyebloom: you could make a typeclass that has common functions like empty and lookup defined on it, and create instances for Map and Set..
08:47:23 <MostAwesomeDude> eyebloom: Seriously, get used to "import qualified Data.Map as M". Namespaces are a Good Thing.
08:47:28 <Enigmagic> there might be one already
08:47:31 <rwbarton> yes, write "Map." or "Set." before empty to tell it which one it should try :P
08:47:42 <eyebloom> For example if my function is f:: a -> Set a and the definitions include f Nothing = empty
08:47:46 <rwbarton> (or "M." or "S.")
08:48:00 <Saizan> remember that the more you overload the less type inference works :P
08:48:09 <eyebloom> It seems like the compiler should no it's an empty set.
08:48:13 <eyebloom> *know
08:48:27 <int-e> eyebloom: but there is no type-directed name resolution
08:48:34 <rwbarton> The real benefit to overloading comes when you can reuse the same code at both types
08:48:43 <MostAwesomeDude> eyebloom: Wouldn't that example actually be f :: Maybe a -> Set a ?
08:48:56 <eyebloom> yes it would
08:49:06 <MostAwesomeDude> We're asking you to type *two* extra characters: f Nothing = M.empty; f Just a = M.singleton a
08:49:25 <MostAwesomeDude> Er, f (Just a); you get the point.
08:49:34 <rwbarton> and in exchange type inference works better both for you and for the compiler
08:50:14 <eyebloom> right, I get it. It's just ugly.
08:50:19 <cheater> hi
08:50:29 <MostAwesomeDude> Practicality beats purity.
08:50:31 <cheater> is there something like levenshtein but for graphs instead of strings?
08:50:37 <eyebloom> And in Leksah, M.empty is formatted as a type.
08:50:49 <eyebloom> er, constructor.
08:51:11 <int-e> really? But that's Leksah's fault then
08:51:23 <eyebloom> I understand all that.
08:51:24 <cheater> let's say i have an nary graph of single characters, and then another one but a single of those characters was changed, or a leaf was changed, or an internal point was changed..
08:51:44 <rwbarton> what's an "n-ary graph"?
08:51:53 <eyebloom> I'm just asking if there is a way.
08:51:53 <rwbarton> is it some kind of tree?
08:52:01 <cheater> er
08:52:03 <cheater> nary tree
08:52:04 <cheater> sorry
08:52:14 <cheater> let's assume n=2
08:52:26 * hackagebot type-unary 0.1.14 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.14 (ConalElliott)
08:52:47 <Enigmagic> eyebloom: with typeclasses, yes
08:52:50 <cheater> i'm guessing levenshtein distance could then become the application of such a distance for n=1
08:53:06 <cheater> since an unary tree and string are the same (right?)
08:53:35 <eyebloom> Can you explain again how that is done?
08:53:43 <int-e> cheater: what does deleting an internal node in an n-ary tree do? which of the children survives? or do you have to delete a child first (reducing it to an empty tree) before you can do that>
08:53:54 <hpc> cheater: data List a = Nil | Cons a (List a)
08:53:59 <cheater> rwbarton: is that a bit clearer? sorry
08:54:03 <rwbarton> Yes
08:54:07 <hpc> cheater: data UTree a = Leaf | Node a (UTree a)
08:54:14 <cheater> int-e: one of the children
08:54:18 <Enigmagic> eyebloom: you could make a typeclass that has common functions like empty and lookup defined on it, and create instances for Map and Set
08:54:50 <cheater> int-e: if all other children were nils then it's just "reducing" the tree
08:55:10 <cheater> in which case it's like the transformation  abcd -> abd
08:55:25 <rwbarton> there's nothing particularly unique about the definition of levenshtein distance, so you are going to have to make some choices when you try to adapt it to trees.
08:55:39 <cheater> yea that's fine
08:55:46 <cheater> i'm wondering if there's *anything* at all like that
08:56:13 <rwbarton> you can compute a similarity metric in the same way, though, for every pair of a subtree of the first tree and a subtree of the second tree, define an "edit distance" recursively in terms of their subtrees
08:56:18 <rwbarton> based on some moves that you allow
08:56:45 <cheater> why only subtrees and not supertrees?
08:56:54 <int-e> cheater: hmm, it seems to lose the symmetry between deletion and insertion. in any case, such a distance can certainly be defined in several ways, I don't know whether it has been done before.
08:57:21 <rwbarton> supertrees?
08:57:34 <cheater> yes.
08:57:38 <cheater> the opposite of subtrees.
08:58:10 <cheater> int-e: i was thinking, it would be a good idea to have something like that for code related metrics
08:58:14 <rwbarton> like, every tree that contains the tree as a subtree? :P
08:58:17 <rwbarton> I don't know what you mean.
08:58:20 <krakrjak> isn't the opposite of a subtree a tree?
08:58:22 <cheater> let's say you take an AST of 1000 functions and you want to find code duplication
08:58:31 <rwbarton> yeah
08:58:32 <cheater> rwbarton: yes
08:58:38 <rwbarton> well there are infinitely many of those
08:58:47 <rwbarton> unless you just mean, the path from a given node to the root
08:58:58 <cheater> rwbarton: not infinitely many with distance 1
08:59:22 <rwbarton> I still don't know what you mean.
08:59:48 <rwbarton> I give you some tree
08:59:59 <rwbarton> and you're going to add some stuff to it to make a supertree?
09:00:39 <Silvah> That's two characters more!
09:00:43 <Silvah> er
09:01:07 <cheater> anyways, continuing my story: let's say you then want to compare the AST of each such function to the other. then you might find you have some duplicates, but things where e.g. one part of the function was put in an if branch means that function doesn't register as a dupe for the function its code was copied from. so you'd need some sort of distance based heuristic on the ASTs.
09:01:21 <cheater> rwbarton: yes, exactly. is there something troubling you about the notion of a superset?
09:01:25 <Silvah> Damn, I had the window scrolled way upwards.
09:02:42 <rwbarton> there are infinitely many ways you can do this and so how are you going to compute something on all of them? besides, it doesn't seem relevant
09:03:18 <rwbarton> Anyways, yeah, I'd do something like --
09:03:31 <rwbarton> the distance between two subtrees is the minimum of all of the following:
09:03:50 <rwbarton> if they have the same value at the root and the same number of children, the sum of the distances between the corresponding children
09:04:09 <rwbarton> if they have different values at the root, add 1 (or whatever) for that difference
09:04:37 <rwbarton> If one happens to be equal to a child of the other, put in some cost for that (maybe the sum of the sizes of the other children)
09:04:48 <rwbarton> etc. with whatever editing moves you think are relevant
09:05:46 <rwbarton> Using those first three reduces to levenshtein distance in the 1-ary case
09:07:05 <rwbarton> the third rule would catch your "if" example where the distance would end up being something like the size of the condition of the if statement plus the size of the other branch
09:08:56 <rwbarton> oh, or more generally I should say we are allowed to make the root of one subtree correspond to any child of the other subtree, with a cost equal to the edit distance between those two trees plus the sum of the sizes of the ignored trees (plus 1 for the root)
09:10:42 <rwbarton> oh I see why you are talking about supertrees now, for the "insert" operation
09:14:23 <rwbarton> the subtrees I am talking about correspond to substrings of the original texts, in the algorithm for computing Levenshtein distance
09:19:02 <cheater> rwbarton: interesting
09:32:27 * hackagebot ReadArgs 1.1 - Simple command line argument parsing  http://hackage.haskell.org/package/ReadArgs-1.1 (NoahEasterly)
09:33:30 <masylum> can someone help me with this doubt?
09:33:31 <masylum> http://stackoverflow.com/questions/8761089/parsing-a-nested-array-of-objects-with-aeson
09:38:23 <lpsmith> Is there any particular reason why you can't mutate the Ptr inside a ForeignPtr?
09:39:50 <c_wraith> lpsmith: I can't see a technical reason...  Probably just not the anticipated use
09:41:36 <lpsmith> c_wraith, yeah, I don't intend on using such a feature willy-nilly,  but I do have a use case in mind
09:42:00 <lpsmith> Namely,  making the postgresql-libpq interface safer
09:42:14 <lpsmith> by setting the ptr to null when you explicitly call finish
09:45:43 <lpsmith> although, maybe allowing for the ptr to be mutated constrains the implementations in a way that other possible implementations cannot really be done, or get a lot messier
09:47:25 <c_wraith> I can't really see that.
09:47:38 <c_wraith> The only downside I can see is making it a lot easier to leak memory
09:47:49 <c_wraith> By changing it, then forgetting to free what it pointed at before
09:48:42 <c_wraith> And, in your case, who knows if the free action the ForeignPtr runs works properly with NULL
10:10:59 <jeff_s_> Does anyone have an idea of difficult it would be to make Data.TrieSet.TSet an instance of NFData. It looks like it might be really difficult.
10:11:46 <ryuk58> what can i use to make a new line in an instance of show
10:12:32 <jeff_s_> ryuk58: "\n"
10:12:45 <c_wraith> jeff_s_: what package is that in?
10:12:55 <ryuk58> "\n" only works with putStr
10:13:12 <c_wraith> uh
10:13:25 <c_wraith> \n is the escape sequence for a newline in any string
10:13:41 <c_wraith> is your problem that you're not actually doing that?
10:13:45 <jeff_s_> I think I found the answer to my own question.
10:14:08 <c_wraith> I mean, if you just ask for a string in ghci, it will show you the *escaped* version
10:14:14 <c_wraith> that doesn't mean it doesn't contain a newline
10:14:29 <c_wraith> Just that what you're doing doesn't *unescape* it
10:15:14 <ryuk58> ok thx
10:15:20 <c_wraith> ryuk58: this, by the way, is exactly the same as any other programming language
10:19:38 * ski thinks `Show' instances shouldn't generate strings with `\n's in them
10:20:03 <ski> (now, some class for pretty-printing values would be another thing)
10:20:49 <jeff_s_> Oh, gr, TSet isn't an instance of Traversable.
10:22:00 <byorgey> jeff_s_: why does it look like it might be difficult?
10:23:20 <jeff_s_> To make "TSet a" an instance of NFData, where (NFData a => TSet a) holds, don't I need to go through each element in the TSet and call rnf on it?
10:24:36 <jeff_s_> Sorry, that was to byorgey.
10:24:49 <jeff_s_> My irc-ese is very rusty.
10:25:05 <byorgey> no worries =)
10:25:27 <byorgey> jeff_s_: yes, you do.  I don't know anything about TSet, I'm looking at the docs now
10:26:02 <byorgey> I was hoping you could help me get up to speed by explaining exactly why you think that process will be difficult
10:26:06 <c_wraith> foldl deepseq mostly works
10:26:14 <jeff_s_> I guess I can just use map. or ya fold.
10:26:19 <c_wraith> assuming it implements Foldable
10:28:10 <jeff_s_> Well, the implementor didn't make TSet an instance of Foldable, but foldl and foldr exist.
10:28:23 <c_wraith> it's obviously less efficient than an implementation that can use the internals, but really efficiency is hardly a concern with NFData anyway.  It's always slow
10:33:25 <aweis> Hello, anyone around willing to help a new haskell person with understading how to work with IO in haskell?
10:34:09 <MostAwesomeDude> aweis: I bet there's lots of people around. Do you have a specific question?
10:34:54 <lpsmith> aweis, I'll give some generic advice:  don't worry about trying to "understand" what a Monad is,  just try to focus on using the IO Monad
10:35:24 <shachaf> aweis: I'll give you some generic advice: If you have a question in IRC, you should just ask it, rather than ask if there's anyone around who can help you with it.
10:35:29 <MostAwesomeDude> ^^ You'll understand monads at a later point. It's fine enough to just learn how to do IO.
10:35:40 <shachaf> Also, read _Introduction to IO_ on the wiki.
10:35:46 <lpsmith> but yeah,  I would recommend trying to do something concrete,  and then asking for help.
10:36:13 <aweis> I have read a bunch of documentation - nothing is sticking just yet
10:36:37 <shachaf> Also, if you join #haskell and ask a question like this, about half of the information people will tell you is actually wrong, sadly. Don't take it too seriously. :-)
10:36:47 <aweis> im curious as to why when i type the following into ghci
10:36:51 <lpsmith> have you tried writing a program?   Does anybody have a suggestion for a simple program involving IO to tackle?
10:36:59 <aweis> input <- readfile "names.txt"
10:37:04 <aweis> lines input
10:37:11 <aweis> that works great
10:37:17 <shachaf> aweis: ghci is kind of magical.
10:37:27 <aweis> but if I plug that into a hs file in do notation
10:37:32 <shachaf> aweis: It does a few different things based on the type of what you type into it.
10:37:48 <lpsmith> :t lines
10:37:49 <lambdabot> String -> [String]
10:37:51 <shachaf> For example, if you type "5" in ghci, it'll print it out; but if you write "main = 5", that's an error.
10:37:53 <lpsmith> :t readFile
10:37:54 <lambdabot> FilePath -> IO String
10:38:25 <lpsmith> The thing is that in do notation,  the next line needs to be an (IO something)
10:38:37 <aweis> I have encountered two IO problems
10:38:39 <lpsmith> but you can turn anything into (IO something) using return
10:38:41 <lpsmith> :t return
10:38:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:38:50 <aweis> I was using the Data.HashTable for one problem
10:38:51 <lpsmith> :t return :: a -> IO a
10:38:52 <lambdabot> forall a. a -> IO a
10:38:59 <aweis> and lookup's returned IO a
10:39:15 <shachaf> aweis: Don't use Data.HashTable. :-)
10:39:23 <aweis> and after a painful experience was finally able to work out how to get the value from the IO type
10:39:36 <aweis> now I have moved onto the file IO
10:40:02 <shachaf> aweis: As far as IO goes: There's no such thing as "getting the value from the IO type". This may seem like annoying pedantry, but it's actually an important distinction.
10:40:19 <lpsmith> You don't really get the value from the IO type,  you bring the computation you want to do into the io monad,  in a sense,   e.g.   do { input <- readFile "...";  return (lines input) }
10:40:29 <aweis> I apologize in advance for my lack of vocabulary
10:40:33 <shachaf> "IO Int" is a completely different type of value from "Int"; it doesn't "contain an Int", and it's not "a tainted Int", tagged by the type system.
10:40:33 <lpsmith> it's ok
10:40:47 <aweis> I am a CS student
10:41:01 <shachaf> aweis: I like "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
10:41:09 <aweis> I have worked with SML and scheme before so my haskell coding is fine for the functional stuff
10:41:32 <aweis> the second I touch monads/IO I halt...
10:41:55 <shachaf> aweis: Monads are a completely different thing from IO. :-)
10:42:10 <aweis> IO monad...?
10:42:33 <shachaf> aweis: IO *is* a monad, but so is (r ->) (functions), [] (lists), and so on.
10:42:38 <mokus> IO is a monad, but that's incidental
10:42:41 <MostAwesomeDude> Monads are like burritos.
10:42:45 <rwbarton> ugh
10:42:47 <gregATio> !
10:42:48 <shachaf> MostAwesomeDude: Just go away, please.
10:42:53 <MostAwesomeDude> shachaf: Alright, alright.
10:42:54 <geekosaur> what's weird about the IO monad is not that it's a monad, but that it is IO
10:43:16 <mokus> "the IO monad" is a phrase that's just too catchy for its own good
10:43:23 <rwbarton> yep
10:43:23 <shachaf> Yep.
10:43:25 <mokus> "the IO type" is better for beginners
10:43:35 <geekosaur> or just "IO"
10:43:41 <aweis> I have been working with the following resources: Haskell for C programmers
10:43:51 <aweis> Learn you a haskell for great good
10:43:59 <aweis> IO inside: down the rabbit hole
10:44:01 <aweis> Monads
10:44:13 <aweis> Write yourself a scheme in 48 hours
10:44:45 <aweis> so I don't think its just an 'rtfm' problem
10:45:02 <shachaf> aweis: Most of those are old and/or outdated and/or contain wrong information, sadly.
10:45:12 <aweis> I guess I am just having a problem with fundamental understanding of "what is going on"
10:45:13 <gregATio> i like real world haskell
10:45:30 <gregATio> me too a little aweis - lol
10:45:44 <shachaf> Half the problem with learning Haskell is the actual difficulty of it, and the other half all the misinformation you get, I think.
10:45:48 <shachaf> aweis: Did you read _Introduction to IO_?
10:45:56 <Algorith> for some lighter stuff you could watch some of the video lectures linked from the main site
10:46:02 <aweis> I watched mzero's google talk on youtube as well
10:46:16 <gregATio> whats mzeros talk called?
10:46:16 <shachaf> aweis: Also, you're in a good position because you already know SML etc. (I think you said).
10:46:18 <aweis> shachaf: can you link me to it
10:46:23 <shachaf> @google introduction to io
10:46:25 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
10:46:25 <lambdabot> Title: Introduction to IO - HaskellWiki
10:46:46 <aweis> my web history says I have read this
10:46:57 <aweis> I will look it over again
10:47:04 <jeff_s_> Hm, aren't type classes transitive? I have NFData BS.ByteString, and Set predefines NFData a => NFData (Set a), so shouldn't Set (BS.ByteString) be ready for me without any additional code?
10:47:27 <jeff_s_> Sorry, shouldn't NFData (Set BS.ByteString)
10:47:28 <byorgey> jeff_s_: yes
10:47:50 <byorgey> jeff_s_: are you getting some sort of error?
10:48:04 <shachaf> aweis: If you want a somewhat tricky but probably rewarding exercise, try taking Haskell (the pure language) as you know it, without IO and with only pure, deterministic functions and data types, and figuring out how you might add IO to it.
10:48:20 <jeff_s_> byorgey: "No instance for (NFData (Set BS.ByteString))"
10:48:50 <shachaf> jeff_s_: I imagine one of those instances you mentioned isn't actually defined.
10:49:17 <byorgey> NFData a => NFData (Set a) is defined in Data.Set
10:49:47 <byorgey> jeff_s_: where is the NFData instance for ByteString defined?
10:49:58 <byorgey> s/defined/declared/
10:50:12 <jeff_s_> I defined it as "instance NFData BS.ByteString where\n    rnf bs = BS.foldl (\accum c -> rnf c) () bs"
10:50:35 <shachaf> jeff_s_: That's a weird instance for strict ByteStrings, if those are strict ByteStrings.
10:50:36 <jeff_s_> I'm working with just one source code file right now.
10:50:44 <shachaf> Do you know how strict ByteStrings work?
10:50:51 <rwbarton> maybe your NFData is somehow not the same as Set's NFData
10:50:53 <jeff_s_> Ya... should I just do \b -> b `seq ()?
10:51:20 <jeff_s_> I am using strict bytestrings.
10:51:58 <shachaf> Hmm, I imagine that that would be sufficient, though you might want to double-check.
10:52:31 <rwbarton> that should be fine
10:52:32 <shachaf> But it's something along the lines of data ByteString = ByteString !Int !Int !(Char *)
10:52:53 <shachaf> Ooh, Ptr should definitely be a PostfixOperator called :*
10:53:18 <aweis> shachaf: i have a bunch of examples I am working through right now
10:54:09 <aweis> shachaf: I have a bunch of code which i can whip up 95% of it in the "pure" style, then the reading the data from file or writing it to a file causes me a lot of pain
10:55:02 <aweis> Also, I hope to be useful to you guys in helping you better teach the language
10:55:22 <lukish> :index isDigits
10:55:35 <lukish> :i isDigits
10:55:38 <cheater> hmmm what does :index do?
10:55:48 <lukish> @hoogle isDigits
10:55:48 <lambdabot> No results found
10:55:48 <jeff_s_> Hm, if my NFData comes from more than one place, wouldn't I get a warning about ambiguous definitions?
10:55:55 <aweis> I am rather determined to learn this stuff -> maybe once I understand it, I can help you guys figure out what the important stuff is to help people learn it faster (and with as little pain as possible)
10:56:11 <lukish> @hoogle isDigit
10:56:11 <lambdabot> Data.Char isDigit :: Char -> Bool
10:56:14 <shachaf> aweis: Someone wrote an article about that.
10:56:19 <shachaf> @google monad burrito fallacy
10:56:21 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
10:56:21 <lambdabot> Title: Abstraction, intuition, and the “monad tutorial fallacy” « blog :: Brent -> ...
10:56:45 <shachaf> aweis: Not that your current problem is about monads, but that article is probably relevant.
10:57:07 <shachaf> aweis: Have you figured out the concepts of "evaluation" and "execution"?
10:57:26 <aweis> shachaf: are you referring to laziness?
10:57:40 <jeff_s_> lol? "instance NFData (Set BS.ByteString) where rnf = rnf" works to remove my error.
10:58:21 <rwbarton> well yes, if you are lacking an instance than writing a nonsensical definition for it will cause your code to compile :)
10:58:22 <shachaf> aweis: No.
10:58:25 <Cale> aweis: He's talking about the distinction between turning an expression into a value (evaluation), and carrying out the actions described by an IO action (execution)
10:58:30 <Saizan> jeff_s_: it'll loop at runtime though
10:59:03 <geekosaur> monads are simple and so general that it's hard to "understand" them because you're almost always trying to readinto them more than they are
10:59:41 <shachaf> geekosaur: Why talk about monads? aweis is just trying to understand IO.
11:00:01 * geekosaur misunderstood scrollback, sorry
11:00:12 <geekosaur> saw the monad tutorial fallacy thing
11:00:24 <geekosaur> and, well, I just summarized the fallacy, after a fashion
11:00:30 <jeff_s_> Saizan - OK your'e right, it's lookping
11:00:59 <byorgey> x = x  is always a valid definition of x, no matter what type it is supposed to be.
11:01:00 <jeff_s_> But on the other hand, I'd think it wouldn't compile, since I'm providing an instance using the instance that supposedly doesn't exist.
11:01:14 <Saizan> geekosaur: that's not all of it
11:01:20 <byorgey> jeff_s_: but it does exist!  you just defined it =)
11:01:34 <jeff_s_> byorgey - good point.
11:01:37 <byorgey> jeff_s_: do you think  xs = 1 : xs  should compile?
11:01:51 <jeff_s_> ya, taht's the same as [1..]
11:02:00 <Saizan> geekosaur: and what you left off is what was relevant to the discussion, i.e. that many think they can write a better tutorial once they figure out the missing bits
11:02:05 <byorgey> well, this is no different.
11:02:29 <geekosaur> Saizan, I would say that the comment about generality is exactly that problem.
11:02:51 <jeff_s_> So NFData a => NFData (Set a) exists, and I wrote NFData BS.ByteString, so why doesn't NFData (Set BS.ByteString) exist?
11:02:52 <geekosaur> more specifically, "trying to read into them more than they are"
11:02:57 <aweis> Also, I definitely see a bunch of inspiration from Lisp and ML in haskell -> I cannot imagine learning haskell as your first exposure to functional and laziness as well as this odd method of doing IO
11:03:06 <plat0> jeff_s_: NB It's not [1..] it's [1,1..]!
11:03:16 <shachaf> aweis: Somehow it works. :-)
11:03:25 <Saizan> jeff_s_: what code do you have and what error are you getting?
11:03:43 <Cale> aweis: You could learn Haskell as your very first programming language, and some people do!
11:03:57 * jeff_s_ comes from OCaml, and that's hard enough.
11:04:05 <Cale> In fact, that's an excellent way to go about it: forget that you know how to program already.
11:04:39 <aweis> Cale: I feel to feeble when doing IO that I already feel that way :/
11:04:53 <Cale> aweis: Well, what are you having trouble with?
11:05:08 <Cale> Perhaps I can give some hints. It really turns out to be not that hard in the end.
11:05:09 <aweis> Cale: I am so tempted to just write the damn thing in 2 lines of ruby...
11:05:16 <Cale> What are you writing?
11:05:45 <aweis> Cale: grabbing a list of names from a text document, sort them, then count the number of letters in each name
11:05:51 <Cale> okay, that's not hard
11:06:10 <parcs`> aweis: that is a _one_ liner in haskell :P
11:06:27 <Cale> It is a one liner, but let's not do it that way to start...
11:06:39 <aweis> Cale: yesterday I was able to count all amicable numbers under 10000 using the Data.HashTable
11:06:50 <Cale> First of all, let's read the text file into a string: do xs <- readFile "filename.txt"; ...
11:07:06 <aweis> xs would be an IO string?
11:07:10 <Cale> nope
11:07:11 <aweis> not a String
11:07:13 <Cale> xs :: String
11:07:15 <aweis> what..
11:07:22 <Cale> readFile "filename.txt" :: IO String
11:07:35 <Cale> v <- x means "run the IO action x and name its result v"
11:07:39 <rwbarton> you seem to have the common misconception that IO is like a "tag" used to "mark" "impure" data
11:07:46 <Cale> An action of type IO t has a result of type t
11:07:52 <tromp> why noy assume data on stdin, Cale?
11:07:58 <Cale> tromp: could do that as well
11:08:24 <tromp> hardcoding filenames in programs is ugly:(
11:08:27 <Cale> aweis: Make sense?
11:08:30 <aweis> yes
11:08:32 <jeff_s_> I found a working but not good solution to my NFData instance problem - compile it on another computer.
11:08:36 <Cale> tromp: well, we can always abstract over that later...
11:08:42 <jeff_s_> Something about my haskell environment must be broken.
11:08:45 <aweis> so xs is a String
11:08:50 <Cale> The important thing here is that we're getting input from somewhere.
11:08:51 <aweis> this is all in do notation
11:08:51 <Cale> okay
11:08:55 <Cale> yeah
11:08:56 <shachaf> tromp: You know what else is ugly? Making programs that people barely understand more complicated for the sake of abstraction alone.
11:08:57 <aweis> i need to sort it
11:09:01 <aweis> there is a sort method
11:09:03 <rwbarton> shachaf++
11:09:05 <Cale> So the do-block as a whole will have type IO t for some t
11:09:06 <aweis> "function"
11:09:07 <aweis> sorry
11:09:09 <aweis> :)
11:09:13 <Cale> and we're going to use it as our 'main'
11:09:18 <Cale> okay
11:09:30 <Cale> So, before sorting it actually, we need to break it up
11:09:35 <aweis> lines?
11:09:40 <Cale> We can break it up using words or lines depending
11:10:01 <aweis> so do xs <- readFile "file"; lines xs
11:10:10 <Cale> So,  do xs <- readFile "filename.txt"; let ls = lines xs; ...
11:10:26 <Cale> or if you want, we can just print the list of lines right there
11:10:33 <Cale> So,  do xs <- readFile "filename.txt"; print (lines xs)
11:10:40 <lukish> @hoogle find
11:10:40 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:10:40 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:10:41 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:11:06 <Cale> We can sort:
11:11:12 <Cale> do xs <- readFile "filename.txt"; print (sort (lines xs))
11:11:19 <aweis> what is this deal with must finishing do notation with an IO action?
11:11:28 <aweis> everytime I try and do this
11:11:36 <aweis> xs <- readFile "file"
11:11:38 <Cale> Because each action in a do-block must be an action
11:11:44 <aweis> i just put lins xs at the end
11:11:47 <aweis> then type error
11:11:51 <Cale> oh, right
11:11:53 <aweis> i actually need to print
11:12:03 <Cale> That's because you're not going to use xs if it's like that
11:12:07 <Cale> so there's no sense in binding it
11:12:20 <aweis> ok...
11:12:33 <lukish> Are some function Maybe String -> String which handle Just and Nothing cases?
11:12:47 <Cale> really, it's because   do v <- x; <stmts>   is translated into   x >>= (\v -> <stmts>)
11:12:50 <parcs`> :t fromMaybe ""
11:12:51 <lambdabot> Maybe [Char] -> [Char]
11:12:54 <cwb> Anyone know if the Hackage trac being down (http://hackage.haskell.org/trac/hackage/) is a known issue by the sysadmin?
11:12:57 <Cale> but you don't have to worry about that, if you don't want, for now
11:13:14 <aweis> Cole: i have read that syntatic sugar a bunch already
11:13:14 <Cale> So it'd be like leaving the body of a lambda blank
11:13:18 <Cale> okay
11:13:29 <Cale> So that should make a certain amount of sense
11:13:41 <rwbarton> I think aweis was talking about   do { xs <- readFile "file"; lines xs }
11:13:46 <aweis> Its about sequencing IO actions, right/
11:13:52 <rwbarton> and why that doesn't work
11:14:01 <Cale> yeah, do-notation is about gluing smaller actions together into larger ones
11:14:03 <aweis> rwbarton, yes
11:14:12 <Cale> ah, okay
11:14:17 <Cale> Yeah, lines xs isn't an action
11:14:20 <Cale> it's a list of strings
11:14:29 <Cale> So you want to do something with that list of strings, like print it.
11:14:40 <aweis> does every line in do notation have to be an action?
11:14:43 <Cale> yes
11:14:44 <aweis> or just the last line
11:14:47 <aweis> oh okay
11:14:48 <Cale> every line
11:14:56 <Cale> except let of course
11:15:20 <Cale> So we can use let to make local definitions if we want
11:15:27 <aweis> im going to hack in ghci for a little with this new info
11:15:32 <rwbarton> since the do block is building up a big action that consists of executing the individual actions in turn; it doesn't make sense to just throw in some other values in there
11:15:33 <Cale> (which scope over the rest of the block)
11:15:35 <aweis> I'll come back with the results
11:15:35 <shachaf> aweis: That's what do *is*. There's no point in having a line that isn't an action.
11:21:12 <Cale> aweis: Any luck?
11:21:38 <aweis> Cale: really not a fan of the escaping of my quotes thats going on from readFile
11:21:52 <Cale> oh, don't worry about that
11:22:06 <Cale> When you 'print' a String, it quotes it so that it's valid source code for a String
11:22:18 <Cale> If you putStrLn a String instead, it won't quote it
11:22:21 <aweis> oh, okay
11:22:30 <aweis> I was able to sort it
11:22:43 <aweis> odd that I needed to import List first to grab sort
11:22:50 <Cale> yeah
11:22:52 <aweis> when that was available to me in ghci
11:22:53 <aweis> ...
11:22:55 <Cale> Er...
11:23:04 <aweis> not sure why the library was available to my at prelude
11:23:05 <Cale> Well, it's available in lambdabot
11:23:19 <Cale> (but that's because lambdabot imports Data.List
11:23:21 <Cale> )
11:23:24 <aweis> ah
11:23:26 <alistra> http://www.quickmeme.com/meme/35nlkz/
11:23:28 <Cale> It shouldn't be available in plain ghci
11:23:42 <gregATio> PutStrLn "hi"
11:24:12 <Cale> lowercase that P ;)
11:24:18 <gregATio> putStrLn "hi"
11:24:26 <gregATio> hmmm
11:24:28 <gregATio> lol
11:25:17 <aweis> you can't just swap putStrLn for print...
11:25:27 <gregATio> great article on the haskell wiki on IO by the way, just finished devouring it *slurp*
11:25:37 <Cale> which one?
11:25:51 <gregATio> print "hi"
11:25:57 <lukish> @hoogle hasYear
11:25:57 <lambdabot> No results found
11:26:30 <gregATio> http://www.haskell.org/haskellwiki/Introduction_to_IO
11:27:05 <Cale> Ah, thanks! I wrote that :)
11:27:16 <gregATio> map (\r -> r + 1) [1,2,3]
11:27:28 <Cale> Let me know if you have any questions
11:27:44 <gregATio> its great Cale , very succint and clear
11:27:53 <gregATio> you've got a great writing style
11:27:59 <George_> hello
11:28:08 <byorgey> hi there George_
11:28:58 <George_> I was just checking out the "Try Haskell" tutorial
11:29:26 <byorgey> George_: cool, feel free to ask in here if you have any questions
11:29:36 <gregATio> I'm going to read your writings on Monads, I actually understand what they are, just dont really see why they are so useful yet
11:30:23 <shachaf> gregATio: "What they are"?
11:30:32 <shachaf> What are "they"?
11:31:16 <George_> I'm just a novice at computer science, and Haskell seems quite different from the other languages I have touched (C, Python, etc.).  What is Haskell all about?
11:31:44 <aweis> George_: run fast :)
11:31:47 <shachaf> It's all about fun, Fun, FUN!
11:31:51 <Cale> George_: That's a pretty broad question :)
11:31:57 <gregATio> they strike me as a type, that specify how to apply itself to other monads
11:32:15 <jamil_1> hi all, haskell noob here
11:32:19 <jrk_> hello
11:32:23 <George_> hello
11:32:33 <Cale> gregATio: You can think of "Monad" as an API pattern which a lot of libraries sort of fall into
11:32:55 <jrk_> George_: standard answer is: haskell is a purely functional, type safe programming language :)
11:32:57 <Cale> gregATio: and it's useful to pick that pattern out and give it a name so that we can write some code which works with all monads
11:33:02 <George_> I'm still in Lesson 2 at the Try Haskell tutorial, and it seems like Python so far.
11:33:04 <jamil_1> I was wondering how can create a List like ADT with length determined at compile time
11:33:23 <Cale> gregATio: You might read: http://www.haskell.org/haskellwiki/Monads_as_computation
11:33:31 <Cale> gregATio: for a bit of motivation along those lines
11:33:44 <jrk_> i got a question:
11:33:49 <Cale> jamil_1: You could use a tuple...
11:34:12 <gregATio> IMHO Cale they are that , but they are more, ive just realised that they help the programmer separate how to combine subproblems from the calculation of the subproblems
11:34:15 <jrk_> i have a function "f a b c d = .. let e = .. etc. "
11:34:16 <Cale> jamil_1: But if you want to do type-level computations on the lengths of the lists, that gets fancy and complicated quickly.
11:34:21 <gregATio> will read Cale!
11:34:31 <jrk_> now i have a where clause in that function
11:34:41 <jrk_> where g f = ..
11:34:43 <jamil_1> Cale: I had tuple in mind, but I dont want to process it like a list
11:34:55 <jrk_> and i'd like to make use of the e from the outer scope
11:34:56 <jamil_1> Cale: s/dont//
11:35:13 <Cale> jrk_: maybe you can move the definition of e into the where clause
11:35:22 <Cale> jrk_: alongside the definition of g?
11:35:23 <jrk_> is there another way to bring the e the scope of g instead of passing it as an argument?
11:36:00 <rwbarton> the "let" is actually inner to the "where", if I understand what you are describing correctly
11:36:06 <gregATio> hard to process a tuple as a list because it will constantly change type
11:36:10 <jrk_> Cale: i am not sure, because to be precise it is a monadic value like "e <- some stuff"
11:36:13 <rwbarton> f a b c d = (let e = ... in ...) where g = ...
11:36:16 <rwbarton> oh
11:36:22 <jrk_> sorry :)
11:36:36 <Cale> jrk_: okay, then you'll have to move things the other way
11:36:44 <jrk_> state monad?
11:36:45 <Cale> jrk_: define g in a let after e
11:36:52 <Cale> inside the do-block
11:36:59 <jrk_> ah, ok
11:37:52 <jrk_> hm.. so my g function takes 4 or 5 arguments, mostly monadic values from the the scope of f
11:38:05 <jrk_> now i could apply the let method
11:38:17 <jrk_> or use a state monad or so
11:38:19 <George_> how does Haskell support the object-oriented programming paradigm?
11:38:22 <jrk_> is there a prefered way?
11:39:18 <Cale> George_: There's nothing specifically in its design which is directly in support of OOP, but you can do OOP nonetheless, because functions are first class, and you can construct records of them.
11:39:53 <Cale> (or at least something which is closely analogous to OOP)
11:40:37 <Cale> jrk_: I'm not sure... do you have to take them as parameters? If they're already in scope, and you're defining g inside the body of f, they may already be in scope
11:40:44 <Cale> (in the definition of g)
11:43:14 <George_> What are some typical applications of the Haskell language? Is it practical for a variety of tasks, or is it simply an esoteric language?
11:43:21 <gregATio> George I saw a great article by yang on functional programming and OO design patterns and how FP addresses almost all issues Design Patterns are there to solve
11:43:39 <Cale> George_: It's general purpose, you could do anything that you could write in C++, say.
11:44:00 <Cale> (actually, there are a lot of things which I would attempt in Haskell which I wouldn't dare begin to program in C++)
11:44:35 <jrk_> Cale: i'm just trying to put the whole g thingie into the body of f with let
11:44:42 <Cale> George_: I'm presently working for a startup company writing an action RPG for iPhones and other mobile devices in Haskell
11:44:49 <jrk_> Cale: it looks nasty but it could work
11:44:52 <gregATio> loads of applications AFAIK, its purity means that some great optimisations can be made particularly in concurrent programs, Yesod is blazingly fast
11:45:12 <George_> so I understand that functional languages like Haskell are used for their expressive power?
11:45:14 <Cale> Yeah, Haskell is particularly good at concurrency and parallelism
11:45:22 <Cale> and yeah, it's very expressive
11:45:23 <jrk_> correction: it works
11:45:50 <Cale> It has a really nice type system which means that programs usually work once they compile -- at least, a lot more than is true in most programming languages.
11:46:03 <jeff_s_> gretATio - do you have a link to that paper, or where I can find it?
11:46:23 <jrk_> just not sure if i want a 40 line function as a let parameter
11:46:23 <gregATio> yeah i'll just dig for it  from my history
11:46:27 <gregATio> brb
11:46:29 <Cale> (It's much nicer to have a compiler message telling you where you've messed up than a program which just does the wrong thing and you have to sort out why on your own)
11:46:35 <jrk_> that somehow looks like.. well .. bad design :)
11:46:47 <Cale> Saves a lot of time which would be spent debugging
11:47:09 <gregATio> http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
11:47:11 <Cale> jrk_: well, yeah, you could lift it out and add parameters for the stuff that it uses
11:47:30 <jrk_> just never play with io, cause then you have to spend the time for debugging anyway :p
11:47:35 <Cale> hehe
11:47:36 <gregATio> great paper, great blog this guy really knows his stuff, most of it is above my level though :-/
11:47:49 <jeff_s_> gregATio - thanks!
11:48:03 <Cale> jrk_: Well, it depends on how you break things up... you can move more and more of the description of the IO that you're going to do into pure datastructures
11:48:09 <Cale> and then it becomes harder to mess things up
11:48:15 <jeff_s_> I read the OOHaskel paper, and it seemed like a lot of work to make Haskell work like Java. It was kind of nasty looking.
11:48:25 <George_> So far, my only experience with the functional programming paradigm is Python's lambda expressions, as well as functions like reduce(), map(), etc.
11:48:40 <Cale> jeff_s_: Bah, you don't need all that nonsense :)
11:48:45 <jrk_> Cale: sure, but you'll hit the bottom line at some time :)
11:48:52 <Cale> jeff_s_: Java does OOP really poorly anyway :)
11:49:11 <jeff_s_> Cale: No, but I do want subtyping, which is kind of nasty in Haskell.
11:49:14 <jrk_> and you definitely can break a program with nullPtr :D
11:49:16 <Younder> I have some math-books to sell. http://paste.lisp.org/display/126900
11:49:36 <Cale> jeff_s_: Well, there's typeclasses, which give you another way to break things up
11:49:37 <Younder> I am dying of lung cancer ad have no further use of them
11:49:42 <gregATio> George I started with python, just because it was really easy... but its not that pure, but if you want to continue there is a FP library in python
11:49:59 <jeff_s_> Yup, that's how I've been doing it, with typeclasses and records, but it's a lot of extra code for something OO does easily.
11:50:04 <Cale> jeff_s_: I usually find that subtyping actually isn't *really* what you need for OO.
11:50:17 <jrk_> Cale: if i move my function to the top level scope then i would have to pass the same parameters as in the where clause .. so there seems to be no benefit there
11:50:38 <gregATio> Cale can you suggest what the haskell idiomatic response is to subtyping?
11:50:51 <Cale> jeff_s_: A lot of the subtyping that goes on in typed OO languages is spurious, because method implementations are tied to classes (types)
11:50:57 <parcs`> Younder: what edition is Anton Elementary Linear Algebra
11:51:16 <Cale> If you can just replace the methods with other methods of the same type (but different functionality), you don't need a subtype
11:51:26 <gregATio> Younder are you really dying?
11:51:42 <Cale> You just have many objects of the same type which behave differently, and support the same interface.
11:51:48 <Younder> gregATio, yes
11:51:53 <gregATio> ah yes subtyping is for people that cant afford first class functions :P
11:51:58 <Cale> Now, sure, you may want fancily nested kinds of interfaces
11:52:07 <Cale> but... ehh, that's usually not so essential
11:52:09 <Younder> parcs`, an old one from te 90's
11:52:17 <gregATio> Younder I'm really sorry to hear that
11:52:56 <gregATio> if you want to talk about anything, you can message me
11:53:13 <b_jonas> Cale: ah, so you say instead of haskell classes just fall back to explicit table of methods, because that can do anything?
11:53:34 <Cale> b_jonas: yeah, and function parameters in place of private members
11:53:50 <b_jonas> Cale: makes sense
11:54:34 <b_jonas> Because unlike normal algebraic types (not higher-order ones), function types are open in that you can create new constructors for them.
11:54:53 <b_jonas> s/higher-order/higher-rank/
11:55:01 <Cale> right
11:55:16 <gregATio> i wonder how much syntax actually would remain in haskell when all of the syntactical sugar is removed :-/
11:55:37 <Cale> gregATio: not more than a dozen cases
11:55:47 <gregATio> incredible
11:55:53 <Cale> The core is really really simple
11:56:06 <rostayob> gregATio: you might want to look at GHC core to get an idea
11:56:19 <b_jonas> Is that after you've removed classes completely?
11:56:22 <rostayob> which is really simple but cluttered by the record passing thingies
11:56:35 <rostayob> but apart from that all the sugar is gone
11:56:38 <gregATio> a necessary evil
11:56:45 <Cale> b_jonas: oh, yeah, that's true
11:56:57 <Cale> It is after typeclass translation
11:57:00 <gregATio> i'll check it out , just going to read Cales Monad as computation post
11:57:07 <gregATio> brb
12:01:11 <ManateeLazyCat> Hi all.
12:02:30 <George_> fhello
12:02:54 <George_> Is there a Haskell compiler I can use on Windows?
12:03:07 <ManateeLazyCat> ghc
12:03:24 <George_> GNU Haskell Compiler?
12:03:38 <lpsmith> @where GHC
12:03:38 <lambdabot> http://haskell.org/ghc
12:03:49 <Algorith> you could also download the haskell platform for windows
12:03:54 <Clint> why is ghci not exposing any function but 'main' in this file i am loading?
12:03:59 <George_> oh Glasgow Haskell Compiler
12:04:03 <lpsmith> @where Platform
12:04:03 <lambdabot> http://hackage.haskell.org/platform/
12:04:34 <George_> @where tutorial
12:04:34 <lambdabot> http://www.haskell.org/tutorial/
12:04:41 <George_> wow
12:04:50 <hpc> @where lyah
12:04:50 <lambdabot> http://www.learnyouahaskell.com/
12:05:04 <mimi_vx> good ..
12:05:13 <George_> there's even good books about Haskell?
12:05:16 <George_> great
12:05:34 <lpsmith> Ok,   is it safe to {-# UNPACK #-} an MVar into a data structure,  or would that lead to a lot of boxing/unboxing?
12:07:28 <rostayob> lpsmith: it depends on how you use it, if you often pass the contained MVar around, yes
12:07:38 <rostayob> GHC has to repack when it needs to
12:08:43 <lpsmith> rostayob, but if I just use take/put/with/modify most of the time,  that doesn't lead to boxing/unboxing?
12:09:21 <George_> So Haskell is as general purpose as Python is?
12:09:33 <Cale> George_: yep
12:09:48 <rostayob> lpsmith: i'd guess it doesn't a mvar is probably just a reference to something external hunder the hood.  but i can't swear
12:10:07 <lpsmith> George_, yeah.  In many areas,  Python has better library support but Haskell is just as general
12:10:18 <Cale> But afaik, Haskell has a better compiler and better concurrency support.
12:10:22 <lpsmith> oh yeah
12:10:31 <ManateeLazyCat> Cale: Hey, how are you?
12:10:34 <ManateeLazyCat> Long time no see.
12:10:41 <Cale> I'm fine :)
12:11:10 <rwbarton> hopefully takeMVar/etc. first does a pattern match on the MVar constructor, then GHC can inline it and optimize out the boxing/unboxing
12:12:11 <shachaf> Cale: So is that a No on beans?
12:12:21 <Cale> beans?
12:12:26 <ManateeLazyCat> Cale: If you have time, you can see my Linux OS: http://www.youtube.com/watch?v=mC1wGRc1uVM
12:12:35 <ManateeLazyCat> Cale: We will release English version in this month.
12:12:48 <shachaf> Cale: Boston.
12:12:51 <lpsmith> rwbarton, IIRC,  withMVar and modifyMVar don't do that :-/
12:12:56 <ManateeLazyCat> Cale: Linux Deepin 11.12, much hacking on gnome-shell and software center. :)
12:12:59 <lpsmith> lemme check
12:13:15 <ManateeLazyCat> Cale: Of course, not Haskell. :(
12:13:29 <rwbarton> not directly, true
12:14:21 <rwbarton> if withMVar and also the MVar functions within it are all inlined, though, I think it is still OK
12:14:50 <lpsmith> right, I was just thinking the same thing
12:17:38 <Cale> ManateeLazyCat: Nice :)
12:18:08 <Cale> ManateeLazyCat: To be honest, I've been putting off on upgrading my entire OS because of gnome 3.0 and broken linux audio
12:18:40 <shachaf> Cale: Is your OS Ubuntu?
12:18:49 <Cale> shachaf: At the moment, yes.
12:18:55 <c_wraith> rwbarton: shouldn't ghc-core be your tool of choice for answering this?
12:18:57 <shachaf> I've been doing the same thing. I'll probably switch from Ubuntu rather than upgade it.
12:19:00 <ManateeLazyCat> Cale: I have write many gnome-shell extension to improve user experience, example add Dock instead blank topbar
12:19:27 <rwbarton> Yes. It's lpsmith's program though. :)
12:19:40 <Cale> shachaf: I was going to switch to Debian, because I didn't like the direction that Ubuntu was heading, but it turns out that all my complaints are not really Ubuntu's fault.
12:20:10 <Cale> (and that Debian has all the same issues, plus some more)
12:20:29 <Clint> like what?
12:21:08 <shachaf> Cale: I don't imagine that Debian has *all* the same issues.
12:21:27 <shachaf> I'm possibly going to try Arch.
12:21:30 <shachaf> It's popular around here.
12:21:56 <Cale> My audio isn't really working 100% on Ubuntu even now -- my headphone volume maxes out at about 50% of what it should, for instance. But with PulseAudio / newer ALSA, there's fucking jack detection which pins my speaker volume to 0% whenever my headphones are plugged in, which is much much worse.
12:22:30 <shachaf> pulseaudio is the best thing.
12:22:41 <Cale> and Gnome 3.0 is just terrible. I want to keep all my panel applets because they're useful.
12:22:46 * Clint has never seen pulseaudio work
12:23:01 <Cale> I have never had PulseAudio do anything sane
12:23:13 <Cale> It always gives me one big derpy master volume control
12:23:50 <Cale> Rather than ALSA's dozen or two separate controls for all the outputs and inputs of my soundcard
12:23:55 <Clint> it screamed at me that my soundcard didn't make sense and then refused to work
12:24:04 <Algorith> use xmonad as wm :) some more haskell in your life
12:24:32 <Cale> and yeah, it does ridiculous things like muting my speakers until I *physically* unplug my headphones
12:24:42 <rostayob> pulseaudio has always worked for me, with pavucontrol
12:25:02 <rostayob> and for what concerns me it's a lot better than just alsa if you have more than 1 soundcard
12:25:47 <Clint> is it?
12:25:51 <Cale> and then, yeah, I just really don't like the direction that Gnome's been headedd
12:25:53 <Cale> headed*
12:26:10 <rostayob> Clint: well yeah, you can control each applicatio independently easily
12:26:19 <rostayob> why are we talking about this here anyway
12:26:39 <George_> How does Haskell differ from the other functional programming languages like those in the LISP family (common lisp, scheme, etc.), Standard ML, ObjectiveCAML, and F#?
12:26:49 <Cale> Well, because Clint asked me what I didn't like
12:26:53 <George_> and is Haskell the most popular one at the present?
12:26:57 <tromp> > putStrLn "my thinkpad seems to be running pulseaudio ok"
12:26:58 <lambdabot>   <IO ()>
12:26:59 <rostayob> ah. ok
12:27:17 <shachaf> George_: You're asking very general questions that don't really have clear, specific answers and have also probably been asked many times before.
12:27:34 <Cale> George_: It's very different from anything in the Lisp family, apart from the fact that functions are first class. It can be seen as a distant cousin of the MLs
12:27:39 <Algorith> most distinctive might be the lazy aspect
12:28:20 <rostayob> and the type classes, and the purity, and the concurrency, and...
12:28:27 <George_> and lazy evaluation is similar to the idea of the way Python evaluates expressions such as "a and b"?
12:28:32 <Cale> George_: Where most of the MLs have strict evaluation, and handle I/O by just putting effects in evaluation, Haskell uses lazy evaluation and separates I/O effects into their own datatype.
12:28:46 <hpc> George_: yes; short-circuiting is a form of lazy evaluation
12:28:49 <Cale> George_: Basically lazy evaluation is outermost-first
12:28:51 <shachaf> George_: Similar in a vague sense, but more general, to the point that it's different. You should just read about it.
12:28:56 <Algorith> will concurrency is more erlangs thing for now
12:28:58 <George_> right
12:29:15 <Cale> George_: So if you write something like f (g (h x)) in a strict programming language (f,g,h are functions, x is a parameter to h)
12:29:43 <Cale> George_: then in a strict language you evaluate innermost first, so x is evaluated, and then h is applied to the result of that
12:29:49 <Cale> and then g, and then f
12:29:59 <darrint_> Does cabal have a development only dependency option?
12:30:19 <Cale> In lazy evaluation, you evaluate f first, applying it to the expression (g (h x)) which only gets evaluated if f actually examines its parameter
12:30:44 <darrint_> I want to say Dev-Depends: hlint but I don't see a way to do that
12:30:58 <parcs`> development?
12:31:31 <Cale> Algorith: Haskell does a great job of concurrency too. Not as nice a job as Erlang for really distributed computation, but probably nicer than Erlang for SMP.
12:31:59 <rostayob> haskell and erlang have different approaches to concurrency altogether
12:32:16 <rostayob> but yeah the support for distributed computation is better in erlang
12:32:21 <darrint_> parcs`, I want to add hlint to my cabal-dev package respository but not have it part of the "real" build-depends that would be used in production.
12:32:51 * hackagebot HGamer3D-Data 0.1.0 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-Data-0.1.0 (PeterAlthainz)
12:33:12 <c_wraith> I feel like haskell isn't really great for parallel computation either, having read all the literature.
12:33:17 <Algorith> If i recall correctly SPJ has been focusing on getting some of the Erlang goodies into Haskell so ya
12:33:22 <darrint_> I guess I can just cabal-dev install hlint
12:33:35 <rostayob> Algorith: Cloud Haskell
12:33:43 <parcs`> darrint_: yep
12:34:04 <Cale> c_wraith: soon... :)
12:34:05 <c_wraith> the way lazy evaluation is implemented interacts poorly with garbage collection and multiple cores.
12:34:14 <Cale> c_wraith: nah, it's often essential :)
12:34:34 <Cale> c_wraith: but parallelism is to some extent just hard
12:34:44 <c_wraith> Cale: that's not the impression I end up with after reading all of Simon Marlow's papers on concurrent GC
12:34:47 <Cale> c_wraith: lazy evaluation can actually work in the favour of parallelism
12:35:16 <Cale> But not always :)  You want good control over the evaluation mechanism, and lazy default gives you that.
12:35:23 <rostayob> erlang solves that by not allowing sharing between processes and GC'ing ever process separatedly
12:35:47 <gregATio> er I think theres a Remoting package thats fairly new in Haskell which mirrors the message passing idiom used by Erlang
12:36:50 <c_wraith> Cale: you want more control than that, even.  There are times when call-by-name would result in better performance, because it could allow multiple cores to run completely independent of each other
12:36:50 <gregATio> its meant to be pretty hot , i got a chance to mess about with it at a dojo, havent compared perfomance specs though
12:37:07 <jeff_s_> One I looked at a few days ago even allowed sending continuations.
12:37:33 <b_jonas> jeff_s_: one what?
12:37:36 <gregATio> yup it does jeff_s
12:37:38 <rostayob> also the fact that erlang has one vm with a certain bytecode helps a lot
12:37:48 <rostayob> i can't imagine how you'd send functions with haskell
12:37:51 * hackagebot HGamer3D-Ogre-Binding 0.1.0 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.0 (PeterAlthainz)
12:37:53 * hackagebot HGamer3D-OIS-Binding 0.1.0 - Library to enable 3D game development for Haskell - OIS Bindings  http://hackage.haskell.org/package/HGamer3D-OIS-Binding-0.1.0 (PeterAlthainz)
12:37:55 * hackagebot HGamer3D-API 0.1.0 - Library to enable 3D game development for Haskell - API  http://hackage.haskell.org/package/HGamer3D-API-0.1.0 (PeterAlthainz)
12:38:01 <gregATio> the remote package allows you to
12:38:09 <rostayob> gregATio: link?
12:38:13 <gregATio> eek
12:38:21 <gregATio> um let me burrow , brb
12:39:28 <jeff_s_> b_jonas - I think it might have been the Remote package (aka Cloud Haskell).
12:39:47 <b_jonas> I see
12:46:00 <gregATio> http://www.cl.cam.ac.uk/~jee36/remote.pdf paper on remoting, note that you can send closures
12:47:01 <Apocalisp> Trying to think of a compelling use case for traversing a list with State
12:47:26 <Apocalisp> compelling but short
12:47:37 <gregATio> closure = continuation
12:47:43 <eikke> stupid question: what would be the unboxed type for an unsigned 8-bit char/int?
12:49:13 <Apocalisp> how about nub?
12:49:28 <lispy> eikke: You mean like the Foo# types?
12:49:52 <eikke> lispy: jup
12:50:44 <shachaf> Word8 is defined as data Word8 = W8# Word#
12:50:45 <eikke> guess I need Word8#
12:50:55 <shachaf> "-- Word8 is represented in the same way as Word. Operations may assume and must ensure that it holds only values from its logical range."
12:51:06 <eikke> right, thanks
12:51:18 <lispy> eikke: many times they are in modules named Ghc.Foo
12:51:30 <lispy> eikke: for example, for signed ints: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Int.html
12:51:32 <eikke> I'm trying to implement an algorithm as proof-of-concept, but I find myself worrying too much about performance at this stage already :(
12:51:49 <lispy> eikke: yeah, don't manually unbox until you have it working
12:52:00 <lispy> eikke: many times making things strict and asking the compiler to unbox is sufficient
12:52:01 <eikke> like, trying to figure out whether to use Data.Vector{.Unboxed,.Primitive}, Data.Array.Somethingelse,...
12:52:02 <shachaf> eikke: You're implementing a proof of concept and worrying about unboxed Word8s?
12:52:17 <eikke> shachaf: my bad
12:52:52 <lispy> eikke: Unless you're a haskell veteran (I don't know your bg) then coding for efficiency may actually bias you towards inefficient implementations.  Optimizing in Haskell is counter-intuitive compared to many other languages.
12:53:22 <eikke> lispy: not a veteran ;-) But not completely new either
12:53:43 <Algorith> just profile it at the end, save  time now spend that time optimizing it when you know where it'll pay off
12:54:24 <lispy> Yeah, what Algorith said.  We have a good profiler in ghc.
12:54:34 <eikke> Algorith: agree. but that's counter-intuitive for my C-based mind in this case :-) (cause in the end performance *will* matter *a lot*, and sticking to Haskell will require even decent performance in the prototype)
12:59:41 <lispy> eikke: think of performance in Haskell this way: It helps you to optimize for programmer time.  Write a high level specification of the solution and refine that spec as needed.
13:00:01 <eikke> agreed
13:00:48 <parcs`> how does one FFI import a variadic C function?
13:00:49 <lispy> eikke: eventually you'll develop intuition to write with good performance initially, but writing it simple and quickly first is often still advantageous (IMO)
13:01:18 <shachaf> parcs`: I think the simplest thing is to write a non-variadic C wrapper for it.
13:01:18 <lispy> parcs`: I think you'd have to write a wrapper in C that marshalls the args to a list?
13:01:19 <c_wraith> parcs`: I don't think you can import it without making non-variadic wrapper functions
13:01:40 <lispy> (I should say marshalls from a list)
13:01:56 <shachaf> lispy: The arguments could be of different types, of course.
13:03:10 <lispy> shachaf: True. I was thinking the list was in C (meaning likely an array)
13:03:19 <lispy> shachaf: But what I said was totally ambiguous
13:03:28 <lispy> ?slap lispy
13:03:29 * lambdabot smacks lispy about with a large trout
13:03:30 <mokus> libffi has functions for calling varargs-based functions
13:03:43 <parcs`> mokus: hehe, sounds meta
13:03:54 <mokus> it works pretty well in practice
13:04:06 <mokus> it's not as heavy-weight as it sounds
13:04:21 <parcs`> oh hey that's you: http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
13:04:34 <shachaf> Functions that, like, call other functions? Whoa, man. So meta.
13:05:16 <mokus> heh, yea that's me
13:05:28 <mokus> forgot i answered that, could've linked to my answer ;)
13:09:21 <darrint_> Is there a Data.Text equivalent to (++) besides concat?
13:09:42 <shachaf> darrint_: mappend
13:10:00 <shachaf> @hoogle Text -> Text -> Text
13:10:00 <lambdabot> Data.Text append :: Text -> Text -> Text
13:10:01 <lambdabot> Data.Text.Lazy append :: Text -> Text -> Text
13:10:01 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
13:10:20 <shachaf> Also append, it seems.
13:10:23 <darrint_> thanks.
13:11:31 <augur> hmm
13:11:36 <augur> i think
13:11:40 <augur> perhaps
13:12:39 <krakrjak> is there ever a time where performUnsafeIO is actually safe?
13:12:51 <krakrjak> sorry unsafePerformIO
13:12:54 <augur> no nevermind actually
13:12:54 <shachaf> krakrjak: Yes.
13:13:04 <parcs`> unsafePerformIO (return ())
13:13:37 <DanBurton> parcs`: -____-
13:13:50 <krakrjak> shachaf: can you elaborate a little.
13:13:59 <shachaf> krakrjak: parcs`'s answer is an example.
13:14:17 <DanBurton> krakrjak: most of the time you should avoid unsafePerformIO.
13:14:19 <krakrjak> ooohhh sorry, I just thought it was a fecetious statement...
13:14:22 <shachaf> krakrjak: First define "safe" to your satisfaction and then see whether there are IO actions that are actually safe to execute.
13:14:32 <shachaf> krakrjak: ByteString is full of unsafePerformIO, for example.
13:14:40 <DanBurton> krakrjak: if you think you have a good reason to use it, then run it by #haskell or /r/haskell or StackOverflow, and see what other people say
13:14:44 <shachaf> (Actually it uses unsafeDupablePerformIO, which is even more unsafe.)
13:15:06 <augur> i think tho i stumbled upon a nice way to relate non-tail-recursive programs to their stack based implementations quite nicely
13:15:18 <DanBurton> krakrjak: otherwise, generally leave unsafePerformIO to people who implement high-performance libraries and such
13:15:20 <augur> im sure someones observed this before but
13:15:25 <krakrjak> ok.  The only time I've used it in the past really was out of ignorance and it's been replaced.  I just wasn't sure if that will always be the case.
13:15:43 <parcs`> krakrjak: some libraries like bytestring use unsafePerformIO
13:15:58 <nolrai_E> So in a action of type "ListT St r" there is one state that is shared among the options right?
13:15:59 <DanBurton> and uglyMemo, and spoon
13:16:19 <krakrjak> parcs`: ok thank you.  I will be trying to steer clear of it for the most part.
13:16:22 <augur> if you imagine the code AST as a zipper, with the currently-evaluating term as the filler, the context looks exactly like the stack
13:16:43 <parcs`> krakrjak: so unsafePerformIO can be used when creating efficient, low-level things with a pure interface
13:17:04 <DanBurton> krakrjak: i think you misunderstood. bytestring uses it in a safe way
13:17:10 <parcs`> also runST uses unsafePerformIO, and other stuff. there are lots of use cases
13:17:13 <DanBurton> no need to steer clear of bytestring
13:17:21 <parcs`> you'll know when you have to use it, probably.
13:17:26 <krakrjak> DanBurton: yes I did misunderstand.  thank you for the clarification.
13:17:31 <DanBurton> :)
13:18:40 <shachaf> DanBurton: spoon isn't safe.
13:18:52 <DanBurton> ain't it?
13:19:06 <shachaf> Well, it depends on what you mean by "safe".
13:19:10 <DanBurton> it just catches "pure-ish" exceptions and turns them into Nothing
13:19:26 <c_wraith> spoon doesn't preserve monotonicity
13:19:41 <shachaf> DanBurton: Right, which you're not supposed to be able to do.
13:19:43 <c_wraith> But it is safe, in terms of "can't lead to crashing or undefined behavior"
13:19:46 <DanBurton> what's monotonicity? spoon makes you sing better?
13:20:11 <DanBurton> shachaf: well yes. unsafePerformIO basically lets you do things you're not supposed to be able to do
13:20:16 <DanBurton> in general
13:20:37 <shachaf> DanBurton: No, you can do what ByteString does without unsafePerformIO.
13:20:41 <rwbarton> But the question was what ways of using unsafePerformIO are safe
13:20:42 <shachaf> It's only used there as an optimization.
13:20:55 <rwbarton> FSVO of safe, spoon is not an example
13:21:01 <DanBurton> true point
13:21:13 <shachaf> The "unsafe" in front of unsafePerformIO isn't exactly a well-defined term.
13:21:23 <shachaf> It's more a "stop and think before using this function" term.
13:23:00 <hpaste> TheJH pasted “indent stuff question” at http://hpaste.org/56165
13:23:26 <TheJH> http://hpaste.org/56165 - would that eval to 100? is that valid syntax?
13:23:41 <TheJH> don't know haskell at all, but just heard about its indent rules
13:23:58 <shachaf> TheJH: Why don't you try it?
13:24:07 <dolio> The answer is no.
13:24:26 <TheJH> shachaf, uh, I don't have an installation of haskell handy anywhere or so...
13:24:31 <TheJH> dolio, hmm, ok
13:24:34 <TheJH> thanks
13:25:37 <nh2> having a myList :: MyMonad m => [(String, (String, m ())), why can I not map fst myList [String]?
13:25:40 <b_jonas> TheJH: for at least short phrases, you can try private messaging lambdabot
13:25:43 <DanBurton> TheJH: when I'm away from my computer, I usually go with http://ideone.com
13:25:56 <nolrai_E> @hoogle STRef
13:25:56 <lambdabot> Data.STRef module Data.STRef
13:25:56 <lambdabot> Data.STRef data STRef s a
13:25:57 <lambdabot> Data.STRef.Lazy data STRef s a
13:25:59 <DanBurton> @where tryhaskell
13:25:59 <lambdabot> http://tryhaskell.org/
13:26:02 <DanBurton> that too
13:26:08 <b_jonas> TheJH: prefix haskell expressions with "> " if you message lambdabot
13:26:11 <shachaf> nh2: Why can't you what?
13:26:12 <DanBurton> and/or lambdabot
13:26:12 <TheJH> b_jonas, DanBurton, ok, thanks
13:26:31 <rwbarton> I guess there is a :: missing before [String]
13:26:40 <b_jonas> DanBurton: interesting
13:26:57 <rwbarton> :t let myList :: Monad m => [(String, (String, m ()))]; myList = undefined in map fst myList
13:26:58 <lambdabot>     Ambiguous type variable `m' in the constraint:
13:26:58 <lambdabot>       `Monad m' arising from a use of `myList' at <interactive>:1:83-88
13:26:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:27:05 <nh2> exactly
13:27:19 <George_> print "Hello, World!"
13:27:28 <rwbarton> Because it doesn't know which m to use, and the resulting value could depend on the choice of m.
13:27:29 <kallisti> can anyone point me to the code in lambdabot that detects typos?
13:27:34 <Sgeo> > print "Hello, World!"
13:27:35 <lambdabot>   <IO ()>
13:27:38 <shachaf> @version
13:27:38 <lambdabot> lambdabot 4.2.2.1
13:27:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:27:42 <shachaf> kallisti: There.
13:27:47 <Sgeo> You can't actually do IO in lambdabot
13:27:56 <DanBurton> lambdabot doesn't do IO actions
13:28:00 <kallisti> shachaf: yes I already have the source code visible but there's a lot of it. :P
13:28:02 <Sgeo> Note that right around this point is where shachef starts trolling.
13:28:05 <DanBurton> doesn't "perform" them, I should say
13:28:21 <ion> > safePerformIO (print "Hello, World!")
13:28:22 <lambdabot>   Not in scope: `safePerformIO'
13:28:34 <shachaf> kallisti: Try line 213 in Base.hs.
13:28:37 <nh2> rwbarton: how could it depend on the choice of m, doesn't it know that all the fst elements must be Strings?
13:28:50 <rwbarton> the *value* could depend on m
13:30:14 <DanBurton> n.b. http://codepad.org can also compile/run haskell
13:32:34 <nh2> rwbarton: I don't get it, what value? Do you mean the whole result list?
13:32:50 <rwbarton> well, myList is some value that is going to be different for each m, right
13:33:20 <rwbarton> That's what type classes do
13:33:38 <shachaf> kallisti: Oh, it's in the package lambdabot-utils
13:33:56 <rwbarton> for example, maybe myList is a member function of MyMonad
13:34:45 <rwbarton> then I can make up a new instance MyMonad CheeseMonad where myList = [("Swiss", undefined), ("Cheddar", undefined)]
13:35:07 <rwbarton> there's no reason at all why the values of myList, for different m, should even have the same length
13:35:16 <rwbarton> let alone contain the same strings
13:35:17 <rwbarton> right?
13:35:56 <nh2> rwbarton: aye, but doesn't map fst throw away all the variable m part, e.g. in you example, we know that there must always be a String in the Tuple's first place, no matter how we choose our ms
13:36:12 <rwbarton> that's not the problem!
13:36:13 <kallisti> shachaf: oh, hmmm, so it just does a normal levenshtein. I've been playing around with applying weights.
13:36:31 <rwbarton> you just wrote "map fst myList"
13:36:32 <Balahla> Please, somebody help me! I'm trying, without success, to compile some code I wrote using sqlite. I got the following: "C:/dev/HaskellPlatform-2011201/mingw/bin/ld.exe: cannot find -lsqlite3".
13:36:55 <rwbarton> how is it supposed to know whether you meant myList :: [(String, (String, CheeseMonad ()))] or myList :: [(String, (String, SomeOtherMonad ()))] or ...
13:37:00 <kallisti> Balahla: it looks like you have a missing library.
13:37:08 <rwbarton> all of those will have different resulting "map fst myList"
13:37:26 <Balahla> It works in WinGHCi fine.
13:37:30 <shachaf> nh2: Consider: class Foo a where foo :: (String,a); instance Foo Int where foo = ("Int", 5); instance Foo Char where foo = ("Int", 'x')
13:37:44 <Balahla> But just don't compile.
13:37:55 <laian> hello
13:37:57 <shachaf> Balahla: What version of ghci are you using?
13:38:04 <shachaf> s/ghci/ghc/
13:38:21 <Balahla> WinGHCi 1.0.6
13:38:23 <Clint> is there a library function that shortens a string to a specified length and adds some form of ellipsis?
13:38:24 <nh2> rwbarton: so it's one of the problems where I don't care about the types because I'm only interested in a particular value, but the typechecker needs it because it doesn't know which fst to use?
13:38:36 <rwbarton> you care about the type too!
13:38:52 <shachaf> Clint: It exists in various projects, but I don't think I've seen it in a library.
13:38:59 <shachaf> nh2: The value depends on the type.
13:38:59 <rwbarton> different choices of the type will give you different answers, so if you care about what answer you get, then you care about the choice of m!
13:39:03 <shachaf> That's what type classes do.
13:39:07 <Balahla> GHC is 7.0.3
13:39:38 <rwbarton> shachaf: I think there is a bug in your instance Foo Char. :)
13:39:51 <Clint> shachaf: alas
13:40:10 <nh2> ah I think I see
13:40:17 <shachaf> rwbarton: Nonsense! You just don't understand the semantics of Foo.
13:40:43 <monochrom> why do people work so hard to throw away types. that's the job of compilers.
13:40:45 <shachaf> Anyway, yes. But I hope the point comes across.
13:41:46 <rwbarton> nh2: you can illustrate this with shachaf's simpler example by annotating the expression with two different types and seeing two different results
13:41:58 <Balahla> How can it be that the code runs in WinGHCi and doesn't compile?
13:42:50 <DukeDave> Can anyone recommend a tutorial/docs on Endo?
13:43:09 <rwbarton> Now, I guess what is confusing here is that actually myList is defined like myList = [("help", ("blah", liftIO $ print "hello")), ("quit", ("blah", liftIO $ exitWith ExitSuccess))] :: MonadIO m => [(String, (String, m ()))]
13:43:19 <rwbarton> so it looks fine to write map fst myList
13:43:45 <shachaf> Polymorphism is the devil.
13:43:45 <monochrom> "Endo a" is equivalent to "a -> a". the end.
13:44:05 <shachaf> monochrom: The Endo.
13:44:19 <Mathnerd314> poll: is ghc spaghetti code?
13:44:27 <monochrom> do { getLine } endo :)
13:44:57 <Balahla> Please, somebody help me! I'm trying, without success, to compile some code I wrote using sqlite. I got the following: "C:/dev/HaskellPlatform-2011201/mingw/bin/ld.exe: cannot find -lsqlite3".
13:45:06 <DanBurton> @where endo
13:45:06 <lambdabot> I know nothing about endo.
13:45:09 <DanBurton> boo
13:45:20 <monochrom> "where is waldo?" "where is endo?"
13:45:22 <Balahla> How can it be that the code runs in WinGHCi and doesn't compile?
13:45:44 <Mathnerd314> DanBurton: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#v:Endo
13:45:49 <c_wraith> @hoogle appEndo
13:45:49 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
13:45:49 <lambdabot> System.Posix.IO AppendOnWrite :: FdOption
13:46:11 <c_wraith> I like that the name appEndo makes it sound like some sort of magician who appends things
13:46:23 <c_wraith> Today, the fabulous appEndo!
13:46:33 <monochrom> that's camel case for you
13:47:12 <monochrom> app'endo and app_endo would not have suggested wrong ideas
13:47:21 <DanBurton> "stupEndo" <- hard to tell if compliment or insult
13:47:44 <Sgeo> Is there any indexed monad stuff on Hackage?
13:48:05 <DanBurton> define "indexed monad stuff"
13:48:52 <copumpkin> classes for indexed monads and common instances, perhaps
13:48:54 <copumpkin> I don't know of any
13:49:07 <gienah> Balahla: maybe this might help: http://stackoverflow.com/questions/5953293/cabal-install-libclang-haskell-dont-work-under-mingw
13:49:09 <applicative> Balahla: what haskell sqlite library are you using?
13:49:36 <aweis> back from the abyss
13:49:57 <Balahla> the one of the Real World Haskell book. HDBC-sqlite3-2.3.3.0
13:50:16 <Balahla> http://book.realworldhaskell.org/read/using-databases.html
13:51:07 <Feuerbach> Sgeo: copumpkin: so, what do you mean by "indexed monads"?
13:51:41 * DanBurton is also wondering this
13:51:59 <aweis> is elemIndex a O(n) function or does compilation optimize this to O(1)
13:51:59 <rwbarton> category-extras has some
13:52:16 <copumpkin> class IMonad f where return :: a -> f i i a; (>>=) :: f i j a -> (a -> f j k b) -> f i k b
13:52:17 <DanBurton> @hoogle elemIndex
13:52:17 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:52:17 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
13:52:17 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
13:52:30 <shachaf> aweis: That would be an impressive compiler.
13:52:33 <DanBurton> aweis: it's O(n) on regular lists
13:52:48 <aweis> then I guess my code is quite inefficient
13:52:56 <DanBurton> aweis: I think some libraries like ByteString have optimized versions of the same operation
13:52:56 <rwbarton> is elemIndex what you think it is?
13:53:16 <DanBurton> > elemIndex 3 [1..]
13:53:17 <lambdabot>   Just 2
13:53:18 <shachaf> DanBurton: How optimized can it get?
13:53:23 <ion> Most code can be optimized to O(1). (With a rather big time constant.)
13:53:34 <aweis> it was exactly what i thought it was
13:53:49 <Patinho`busy> o/
13:53:53 <DanBurton> shachaf: if the list also maintains some information, like a tree on the side
13:54:06 <copumpkin> Feuerbach, DanBurton: see my previous message
13:55:00 <aweis> shachaf: couldn't the compiler notice elemIndex within lambda in a map and then change the structure of the list to be accessed like an array
13:55:06 <copumpkin> Feuerbach, DanBurton: the typical application is tracking changing "state" in your monad. Possibly preventing you from reading a closed handle or similar, or at the simplest, a state monad whose state type can change
13:55:43 <aweis> honestly, I have no clue about the actual implementation of haskell; I barely know how to use it
13:55:56 <rwbarton> elemIndex is not like lookup in an array
13:56:03 <shachaf> aweis: Even in an array elemIndex would be an O(n) operation.
13:56:34 <aweis> shachaf: not in (not functional)
13:56:41 <DanBurton> aweis: are you thinking of !! instead?
13:56:53 <DanBurton> > [1,3,5,7,9] !! 2
13:56:54 <lambdabot>   5
13:56:54 <shachaf> But anyway the compiler doesn't do that, and whether you want to do that at all is quite questionable.
13:57:27 <shachaf> > elemIndex 'w' "lambdabot aweis"
13:57:28 <lambdabot>   Just 11
13:58:03 <DanBurton> Hey if the compiler wants to make my code faster *and* take up less memory, while still behaving the same, I'm all for it.
13:58:38 <aweis> DanBurton: -O 11
13:58:44 <nolrai_E> Is there a name for the operation of calculating the index into an single dim array, given the index to a value in the array considered as a 2d array?
13:59:14 <shachaf> DanBurton: Keeping it so that it behaves the same is not particularly easy.
13:59:16 <aweis> DanBurton: isn't !! also a O(n) operation
13:59:21 <shachaf> nolrai_E: As in "n * i + j"?
13:59:28 <DanBurton> aweis: yes it certainly is
13:59:28 <shachaf> aweis: It is, but that's not the operation you were asking about.
13:59:38 <nolrai_E> shachaf: yes.
13:59:55 <DanBurton> shachaf: indeed
14:00:03 <rwbarton> nolrai_E: are you looking for an English word to describe it, or the name of a Haskell function that does it?
14:00:04 <monochrom> > elemIndex 4 [0,1,2,3,4,5]
14:00:05 <lambdabot>   Just 4
14:00:13 <monochrom> > [0,1,2,3,4,5] !! 4
14:00:13 <lambdabot>   4
14:00:16 <monochrom> :)
14:00:29 <shachaf> > (const . Just) 4 [0,1,2,3,4,5]
14:00:31 <lambdabot>   Just 4
14:00:34 <shachaf> > (const . Just) 2 [0,1,2,3,4,5]
14:00:36 <lambdabot>   Just 2
14:00:38 <nolrai_E> An english word, but come to think of it I'll just bundel it with the array access.
14:00:55 <shachaf> aweis: Anyway, this is tricky to do for various reasons.
14:01:03 <DanBurton> nolrai_E: that function would also need as input the width of the 2D array
14:01:05 <dmwit> > index ((0,0), (5,7)) (2,3)
14:01:05 <lambdabot>   19
14:01:12 <dmwit> > index ((0,0), (5,7)) (8,6)
14:01:13 <lambdabot>   *Exception: Error in array index
14:01:19 <dmwit> nolrai_E: ^^
14:01:25 <Feuerbach> copumpkin: interesting. I also found this: http://www.haskell.org/pipermail/haskell/2006-December/018917.html
14:01:45 <shachaf> dmwit++ # like, knowing stuff
14:01:45 <nolrai_E> dmwit: Ah ha.
14:01:57 <DanBurton> dmwit++
14:02:11 <DanBurton> @hoogle index
14:02:12 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
14:02:12 <lambdabot> Data.Data indexConstr :: DataType -> ConIndex -> Constr
14:02:12 <lambdabot> Control.Exception.Base IndexOutOfBounds :: String -> ArrayException
14:02:12 <dmwit> =)
14:02:42 <DanBurton> so in this case a = (Int, Int)
14:02:47 <dmwit> yes
14:02:56 <DanBurton> for Data.Ix.index
14:03:52 <monochrom> It translates segmentation to linear addressing
14:03:53 <aweis> also: it has been a while since I have done lots of functional programming
14:04:10 <aweis> in my code I mapd a function over a list to update the values
14:04:21 <aweis> then i foldl'd over it to sum it up
14:04:31 <nolrai_E> Is there really not libray suport for multy dimentional bit arrays?
14:04:36 <aweis> is there an easy way to compose both a map and a foldl
14:04:42 <nolrai_E> I mean its not hard to roll my own, but..
14:04:54 <dmwit> nolrai_E: I think there's a UArray instance for Bool.
14:04:57 <dmwit> It does bit-packing.
14:05:07 <rwbarton> aweis: you can fuse them manually, but there's little reason to do so
14:05:08 <dmwit> So... yes, there's library support.
14:05:17 <nolrai_E> Does it implement Ord?
14:05:30 <dmwit> Check the documentation...?
14:05:43 <aweis> rwbarton: thanks, I was just reflecting on my code to see where I could clean and optimize
14:06:09 <nolrai_E> doh. Sorry for silly questions.  So I should just use UArray Bool? not BitArray?
14:06:13 <dmwit> nolrai_E: http://hackage.haskell.org/packages/archive/array/0.3.0.3/doc/html/Data-Array-Unboxed.html says yes
14:06:22 <Algorith> you could use hlint for some suggestions
14:06:26 <dmwit> nolrai_E: Yes.
14:06:36 <dmwit> nolrai_E: Without even knowing what BitArray is, yes. =)
14:06:44 <nolrai_E> Okay then!
14:06:47 <nolrai_E> Thanks!
14:07:09 <DanBurton> @hoogle foldMap
14:07:10 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:07:10 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:07:40 <roconnor> heh, SPJ is interested in extending the module system to allow multiple modules in a single file ... which BTW is already Haskell 98 ... kinda.
14:08:03 <Algorith> I believe some doctorate student was working on it
14:08:19 <rwbarton> It's not not Haskell 98!
14:08:29 <DanBurton> :t foldr
14:08:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:08:39 <dmwit> I guess Haskell 98 doesn't really specify how modules are stored on disk, right?
14:08:55 <nolrai_E> Why is it hard?
14:09:05 <roconnor> rwbarton: :D
14:09:07 <dmwit> nolrai_E: GHC currently has a bit of magic for finding modules by filename.
14:09:15 <nolrai_E> Ah.
14:09:23 <dmwit> So some manual method of doing that would have to arise.
14:10:01 <DanBurton> > foldMap succ [1..5]
14:10:02 <lambdabot>   Not in scope: `foldMap'
14:10:10 <DanBurton> > Data.Foldable.foldMap succ [1..5]
14:10:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:10:11 <lambdabot>    `Data.Monoid.Monoid a'
14:10:11 <lambdabot>  ...
14:10:16 <DanBurton> sigh
14:10:36 <DanBurton> > Data.Foldable.foldMap (succ :: Int -> Int) [1..5]
14:10:37 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:10:37 <lambdabot>    arising from a use of...
14:10:42 <dmwit> I don't think it's hard, but you do have to be a bit careful with these things; doing a hack just to make it work is a bad idea (because these things tend to stick around longer than you expect).
14:10:42 <DanBurton> oh yeah
14:11:08 <dmwit> > getSum $ foldMap succ [1..5]
14:11:09 <lambdabot>   Not in scope: `foldMap'
14:11:18 <dmwit> :t F.foldMap
14:11:19 <lambdabot> Couldn't find qualified module.
14:11:23 <dmwit> bummer
14:11:30 <dmwit> > getSum $ Data.Foldable.foldMap succ [1..5]
14:11:30 <DanBurton> have to write it out
14:11:30 <lambdabot>   No instances for (GHC.Enum.Enum (Data.Monoid.Sum a),
14:11:31 <lambdabot>                    GHC...
14:11:35 <dmwit> hah
14:11:42 <dmwit> Now that's an oversight that ought to be corrected.
14:11:53 <parcs`> roconnor: what will be the relationship between the file name and module name, then?
14:12:10 <dmwit> parcs`: Somebody suggested a manifest. That seems reasonable to me.
14:12:22 <roconnor> parcs`: I'd stick modules in a database myself :D
14:12:29 <tgeeky> dmwit: maybe the "make TH reify modules" ticket is related?
14:12:39 <dmwit> I have no idea.
14:12:57 <dmwit> roconnor++ filesystems are so 2011
14:13:11 <DanBurton> > getSum $ Data.Foldable.foldMap (+1) [1..5]
14:13:12 <lambdabot>   No instances for (GHC.Num.Num (Data.Monoid.Sum a),
14:13:12 <lambdabot>                    GHC.E...
14:13:17 <DanBurton> -_-
14:13:21 <dmwit> =/
14:13:30 <dmwit> Sum should really just derive all the instances.
14:13:38 <DanBurton> > getSum $ Data.Foldable.foldMap id [1..5]
14:13:38 <lambdabot>   No instances for (GHC.Num.Num (Data.Monoid.Sum a),
14:13:39 <lambdabot>                    GHC.E...
14:13:45 <DanBurton> boo
14:13:54 <ion> > getSum . Data.Foldable.foldMap ((+1) . Sum) $ [1..5]
14:13:55 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum a))
14:13:55 <lambdabot>    arising from a use of ...
14:14:02 <ion> eh
14:14:11 <dmwit> > getSum $ Data.Foldable.foldMap (Sum . (+1)) [1..5]
14:14:12 <ion> > getSum . Data.Foldable.foldMap (Sum . (+1)) $ [1..5]
14:14:13 <lambdabot>   20
14:14:14 <lambdabot>   20
14:14:33 <DanBurton> ion++
14:14:49 <dmwit> > instance Num a => Num (Sum a) where fromInteger n = Sum (fromInteger n) -- ;-)
14:14:50 <lambdabot>   <no location info>: parse error on input `instance'
14:14:54 <jjg> hi all, does anyone have any reading material on implementing language defined operators (like haskell has)?
14:15:12 <ion> > ala' Sum Data.Foldable.foldMap (+1) [1..5]
14:15:13 <lambdabot>   20
14:15:14 <dmwit> jjg: There's nothing to implement; the only interesting bit is parsing.
14:15:34 <dmwit> jjg: Other than that it's just a plain old function application.
14:15:37 <jjg> dmwit: well that's the interesting bit I'm trying to implement
14:15:41 <dmwit> aha
14:15:47 <dmwit> Then, you should take a look at the Report.
14:15:56 <dmwit> It has detailed instructions for lexing and parsing Haskell.
14:16:06 <DanBurton> jjg: implementing infix operators, you mean?
14:16:09 <dmwit> You can probably adapt them to your needs without too much difficulty.
14:16:11 <jjg> dmwit: the Report?
14:16:15 <dmwit> ?where report
14:16:15 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:16:18 <ion> danburton: ↑
14:16:18 <jjg> DanBurton: yeah
14:17:12 <dmwit> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-280003.4 looks especially relevant
14:17:50 <jjg> I'm generally not understanding how you deal with an expression on both sides without ending up with infinite recursion :(
14:18:37 <dmwit> What kind of parser are you writing?
14:19:02 <jjg> currently I'm just playing around with parsec
14:20:48 <dmwit> Well, the usual way is to stratify expressions into those with operators and those without.
14:20:58 <mokus> one possibility is to just parse it ignoring precedence and rebalance the tree as needed
14:21:00 <DanBurton> so wait, where did ala' come from?
14:21:41 <DanBurton> :t ala'
14:21:42 <c_wraith> DanBurton: the newtype package
14:21:42 <lambdabot> forall o n a b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((a -> n) -> b -> n') -> (a -> o) -> b -> o'
14:21:52 <DanBurton> mmmmmmmmkay
14:21:53 <dmwit> The Report seems to do that; infixexp may have infix operators, while lexp may not.
14:22:56 <dmwit> DanBurton: The Newtype class is basically for isomorphic types; ala lifts the isomorphism to functions.
14:23:12 <dmwit> (And gives you a bonus hook in the middle of the isomorphism.)
14:24:04 <dmwit> mokus: I don't think the precedence is the bit troubling jjg (yet). =)
14:24:24 <nolrai_E> @hoogle minimumBy
14:24:24 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
14:24:25 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:24:35 <dmwit> :t minimumBy . comparing
14:24:36 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
14:24:38 <mokus> well, by ignoring precedence it's way easier to factor all the recursion to whichever side your parser framework needs
14:24:55 <mokus> that's all i was getting at
14:24:55 * dmwit nods agreeably
14:25:27 <nolrai_E> @hoogle on
14:25:27 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:25:27 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
14:25:27 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
14:25:34 * DanBurton continues staring at the type signature of ala'. It's slowly starting to make more sense.
14:25:50 <nolrai_E> What is ala'?
14:26:18 <dmwit> ala' :: (o -> o) -> ((a -> o) -> (b -> o')) -> ((a -> o) -> (b -> o'))
14:26:39 <dmwit> except we add n ~ o, n' ~ o', and do some casting
14:27:07 <nolrai_E> Is it just "const id"?
14:27:20 <dmwit> Not quite; it does use its first argument.
14:27:41 <dmwit> ala' idLike f g = f (idLike . g)
14:27:49 <dmwit> (again, + casting)
14:28:20 <nolrai_E> Okay.
14:29:09 <DanBurton> hrm I need some Newtype exercises or something. This Newtype + Monoid hackery is foreign territory to me
14:29:44 <dmwit> Yeah, I've never worked out how to use it profitably either. =P
14:29:55 <dmwit> I think ala' is pretty much only used in conjunction with foldMap.
14:30:16 <dmwit> :t flip ala' foldMap
14:30:17 <lambdabot> Not in scope: `foldMap'
14:30:23 <dmwit> :t flip ala' Data.Foldable.foldMap
14:30:24 <lambdabot> forall n a o' (t :: * -> *). (Monoid n, Data.Foldable.Foldable t, Newtype n o') => (o' -> n) -> (a -> o') -> t a -> o'
14:31:07 <dmwit> The first argument just tells which Newtype instance to use, basically.
14:31:09 <noob> is there a good haskell lib to read excel files? like xlrd for python ?
14:31:40 <dmwit> If you don't see anything on Hackage, the answer is probably no.
14:32:10 <monochrom> newtype and monoid are pretty orthogonal. someone wanted "instance MyClass (a->a)", but doesn't want to break Haskell 2010, so a newtype wrapper is used. it just happened that MyClass is Monoid.
14:33:58 <dmwit> jjg: Are ya dead yet?
14:34:04 <noob> dmwit: i did not find any that i could use
14:34:05 <DanBurton> with newtype hackery you can get around tons of Haskell 2010 restrictions, e.g. TypeCompose, but you have to learn tons of little combinators
14:34:15 <jjg> dmwit: still lost :P
14:34:40 <dmwit> Whatcha thinkin'?
14:34:56 <noob> a while ago i hacked together a python script to convert an excel table to a custom text format. now i need that same info in a custom XML too.
14:34:56 <jjg> dmwit: no one has a decent example of doing it in parsec lying around, everything is based around pre defined operators from what I can tell
14:35:02 <monochrom> no, don't learn. re-invent. you could have invented TypeCompose yourself.
14:35:13 <noob> so i was hoping i could redo it all in Haskell :) and learn me some Haskell
14:35:19 * DanBurton uses CTRL-F on the hackage list of packages, searching for "excel", finds "pez: a Potentially-Excellent Zipper library" -____-
14:35:35 <enzuru> the last person who learned himself some haskell became an atheist
14:35:48 <dmwit> jjg: Oh. Well, take their parser for pre-defined operators, and substitute a parser for your infix operator in place of their built-in (string "+").
14:35:51 <noob> enzuru: i am already an atheist :)
14:35:52 <Axman6> and it was for great good
14:35:52 <dmwit> Not much to it, mate!
14:36:06 <enzuru> noob: that person was me. high five!
14:36:37 <jjg> dmwit: this is the closest I've found, still trying to grok it
14:36:40 <DanBurton> obligatory slashdot-ism: correlation /= causation
14:36:42 <jjg> dmwit: https://github.com/insane/kivi/blob/master/Parser.hs
14:37:45 <jjg> it's not really using parsec though
14:37:50 <drdo> oh no, not here too, the atheists are invading everywhere
14:37:55 <dmwit> jjg: There you are. Just tear out that call to (pLit "+") and use something that's more flexible.
14:39:07 <dmwit> Gotta run. Good luck.
14:39:16 <jjg> dmit: thanks for the help
14:42:12 <nolrai_E> @ty flip id
14:42:13 <lambdabot> forall a b. a -> (a -> b) -> b
14:45:59 <DanBurton> :t flip
14:46:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:46:09 <DanBurton> :t flip `asAppliedTo` id
14:46:10 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> (a -> b) -> b
14:46:23 <ddarius> :t Prelude.flip
14:46:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:46:50 <DanBurton> :t Prelude.flip `asAppliedTo` id
14:46:51 <lambdabot> forall b c. ((b -> c) -> b -> c) -> b -> (b -> c) -> c
14:47:45 <DanBurton> observe the type from Prelude.Flip, when applied to id, a = (b -> c)
14:48:57 <nolrai_E> @pl \ f -> ixmap (bounds grid) f grid
14:48:57 <lambdabot> flip (ixmap (bounds grid)) grid
14:49:21 <nolrai_E> seems like a wash to me.
14:49:37 <DanBurton> it just flipped the expression so you wouldn't need to list f as an explicit param
14:49:47 <DanBurton> @pl \f grid -> ixmap (bounds grid) f grid
14:49:47 <lambdabot> join . flip (ixmap . bounds)
14:50:22 <DanBurton> abstracting the grid as input, you get a more interesting pointfree solution
14:51:40 <DanBurton> :t join `asAppliedTo` (flip (ixmap . bounds) undefined)
14:51:41 <lambdabot> forall i e. (Ix i) => (Array i e -> Array i e -> Array i e) -> Array i e -> Array i e
14:52:30 <applicative> @pl \grid f -> ixmap (bounds grid) f grid
14:52:30 <lambdabot> flip =<< ixmap . bounds
14:53:02 <cl1> what does @pl do?
14:53:12 <DanBurton> :t join `asAppliedTo` (undefined :: a -> a -> a)
14:53:12 <lambdabot> forall a. (a -> a -> a) -> a -> a
14:53:25 <DanBurton> cl1: @pl produces the "pointfree" version of a function
14:53:40 <cl1> DanBurton, good to know :)
14:53:53 <DanBurton> cl1: are you familiar with what "pointfree" is?
14:54:21 <cl1> DanBurton, yes
14:54:59 <nolrai_E> I find it most useful as entertainment, but it can find good patterns sometimes.
14:55:02 <DanBurton> i suppose "pl" stands for "pointless", though :) I always try to sound leet and say "pointfree"
14:55:12 <applicative> @unpl flip =<< ixmap . bounds
14:55:12 <lambdabot> (\ f -> (ixmap >>= \ a b c -> a c b) (bounds f))
14:55:18 <applicative> ick
14:55:45 <DanBurton> @unpl join . flip (ixmap . bounds)
14:55:45 <lambdabot> (\ f -> (\ c -> ixmap (bounds c) f) >>= \ g -> g)
14:56:51 <DanBurton> \g -> g is a bit excessive, even if the goal of @unpl is to add points back :P
14:57:12 <applicative> it prefers (>>= \g -> g) to join, that can't be right
14:57:40 <rwbarton> @pl (\ f -> (\ c -> ixmap (bounds c) f) >>= \ g -> g)
14:57:40 <lambdabot> join . flip (ixmap . bounds)
14:59:35 <nolrai_E> Anyone use the haskel plug in for eclipse?
14:59:47 <nolrai_E> *Haskell
14:59:59 <DanBurton> I've tried a few times. I never really stick with it though.
15:00:10 <hpc> nolrai_E: i remember it not working
15:00:35 <hpc> applicative: it picks the one with more points :P
15:01:21 <DanBurton> nolrai_E: I even asked a question about it on StackOverflow a few months ago: http://stackoverflow.com/questions/8059427/eclipsefp-on-indigo-issues-with-maven
15:02:28 <nolrai_E> It seems to mostly work to me, but I keep getting this odd "Could not find file in module graph." and cant figure out why it appears or why it goes away.
15:03:08 * hackagebot postgresql-libpq 0.6.2 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.6.2 (LeonSmith)
15:03:10 * hackagebot dropbox-sdk 0.1.1 - A (very preliminary) library to access the Dropbox HTTP API.  http://hackage.haskell.org/package/dropbox-sdk-0.1.1 (KannanGoundan)
15:03:12 * hackagebot postgresql-simple 0.0.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.0.2 (LeonSmith)
15:03:42 <applicative> hpc, @pl is better at getting rid of them than unpl is at adding them
15:03:45 <applicative> @pl (\g->g) (\g->g)(\g->g) (\g->g)( \grid f -> (\g->g) ixmap (bounds grid) f ((\g->g) grid))
15:03:45 <lambdabot> flip =<< ixmap . bounds
15:07:47 <tempire> recommendations for tutorials on applicative functors?  I've read learnyouahaskell sections, and the wiki, but it's just not clicking
15:08:11 <hpc> tempire: you've already learned Functor, yes?
15:08:21 <DanBurton> tempire: RWH?
15:08:32 <Saizan> http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner#Degrees_of_freedom_instanciating_the_rules <- TIL that you can complicate Hindley-Milner by using the union-find algorithm
15:09:08 <tempire> I understand functors to be a type class of anything that can mapped over
15:10:29 <DanBurton> tempire: another way to think about functors is providing a way to "lift" a function to work "inside" the functor
15:10:48 <DanBurton> :t fmap (+1) `asAppliedTo` [1,2,3,4,5]
15:10:49 <lambdabot> forall a. (Num a) => [a] -> [a]
15:11:07 <DanBurton> in this case, fmap "lifts" the (+1) function to work on lists
15:11:24 <DanBurton> or "inside" lists, if you will
15:13:10 * DanBurton shamelessly suggests his own "monad tutorial" which touches on Functors and Applicative Functors: http://unknownparallel.com/monads.php
15:14:17 <c_wraith> My main suggestion is "don't look at monad tutorials.  they make you feel dumb, and do little else"
15:14:27 <shachaf> DanBurton: But that page says misleading things like "trapped inside".
15:14:41 <ion> Trapped inside the burrito or the space suit?
15:14:55 <c_wraith> Can I be trapped inside paradise?
15:15:02 <c_wraith> data Paradise a = ...
15:15:03 <tempire> lull.  I was just thinking maybe understanding monads and monoids would help, since most tutorials (with the exception of learnyouahaskell) includes those words in the explanation of applicative functors
15:15:08 <irene-knapp> you have it all BACKWARDS.  the spacesuit is trapped inside the nuclear waste!
15:15:15 <DanBurton> shachaf: yes but it uses scare quotes at least for that phrase
15:15:17 <hpc> c_wraith: i remember a game with that premise
15:15:24 <shachaf> DanBurton: So? It's still wrong and misleading.
15:15:30 <c_wraith> hpc: no, a real paradise, not a fake one
15:15:43 <DanBurton> shachaf: if I remove "trapped" is it less misleading? "inside" is the best way I can think of to describ eit
15:16:06 <hpc> DanBurton: that's at least less misleading; it follows "monads as containers"
15:16:26 <shachaf> DanBurton: Yes, it's still misleading.
15:16:42 * tempire looks at the monads tutorial against the recommendation of c_wraith
15:16:54 <nolrai_E> @hoogle [a] -> ListT m a
15:16:55 <lambdabot> Control.Monad.Trans.List ListT :: m [a] -> ListT m a
15:16:55 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
15:16:55 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
15:17:07 <ion> @typeclassopedia
15:17:07 <lambdabot> Unknown command, try @list
15:17:08 <shachaf> DanBurton: There's no "String" inside "IO String" or "Maybe String" or "[String]" or "State s String" or "r -> String" or pretty much "(any interesting monad) String"
15:17:10 <ion> @where typeclassopedia
15:17:10 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:17:17 <shachaf> It's not trapped, and it's not inside.
15:17:25 <ion> There’s a “monad tutorial” that doesn’t suck.
15:17:30 <nolrai_E> Yeah there is.
15:17:53 <nolrai_E> Or I guess I have a mathy idea of "inside"..
15:18:00 <DanBurton> shachaf: challenge: succinctly describe <*>
15:18:06 <nolrai_E> produces might be a better word.
15:18:28 <nolrai_E> Really it depends on which monad you are talking about.
15:18:31 <hpc> DanBurton: apply a "sandwich artist" to a burrito
15:18:35 <shachaf> DanBurton: Why would I succinctly describe <*>?
15:18:45 <shachaf> I imagine it makes sense to explain Monad before explaining Applicative.
15:18:53 <nolrai_E> :t (<*>)
15:18:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:19:03 <DanBurton> shachaf: because I challenged you to, duh!
15:19:15 <c_wraith> I feel like Applicative is easier.
15:19:29 <ion> Drawing a function from the first applicative functor and a value from the second one, result in the function applied to the value.
15:19:40 <shachaf> c_wraith: I think the type of (>>=) is simpler than the type of (<*>).
15:19:42 <c_wraith> <*> is "applying a function in a context to a value in that context"
15:20:17 <nolrai_E> @ty (>>=)
15:20:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:20:54 <DanBurton> c_wraith: nice. I might have to steal that.
15:21:19 <c_wraith> with a suitably vague definition of "context"
15:21:27 <DanBurton> "context" is a good word that I didn't use
15:21:42 <nolrai_E> Context is good.
15:22:18 <nolrai_E> Though really its not closer then contains, just more abstract sounding.
15:22:42 <c_wraith> shachaf: the difference is that >>= crosses layers in a way <*> doesn't.  I think it's easier to learn at the start.
15:23:04 <DanBurton> nolrai_E: precisely :) Haskell people like things that are more abstract sounding
15:23:19 <c_wraith> err.  Easier to learn how to operate in each layer, before learning how to cross between them
15:23:40 <shachaf> c_wraith: Crosses layers?
15:23:52 <shachaf> c_wraith: I also think join is simpler than (<*>)
15:24:41 <shachaf> In fact, I think join is simpler than (>>=), so if you want the simplest definition and you already have a pointed functor, just add join.
15:24:46 <c_wraith> shachaf: f (a -> b), f a, f b...  You can think of it as putting aside the f, and just being function application.
15:25:34 <tempire> is it correct to say Applicative Functors allow you to fmap over the values that are represented by Maybes?
15:25:52 <ddarius> tempire: No, Functor allows you to fmap over values.
15:26:05 <applicative> fmap lets you fmap over Maybes
15:26:28 <shachaf> c_wraith: Right, but I think "f (a -> b)" is confusing to beginners in a way none of the other mentioned types are. On the other hand maybe someone would need to understand that anyway before they have a hope of understanding Monad.
15:26:39 <applicative> applicative lets you fmap over two or three at once so to speak
15:27:06 <DanBurton> ddarius: in fairness, all Applicative Functors are Functors, so technically Applicative Functor does let you fmap, by virute of being a subclass of Functor
15:27:07 <c_wraith> shachaf: I think your second thought is exactly correct.  You need to be able to understand it either way.
15:27:13 <shachaf> applicative talks about himself in third person.
15:27:45 <DanBurton> lol
15:29:51 <ddarius> shachaf: You can present Applicative as liftA0 :: () -> f () and liftA2 :: (f a, f b) -> f (a, b) (and of course liftA0 can be simplified to just f ()).
15:30:39 <shachaf> Oh, that's a good point.
15:31:50 <shachaf> You can use liftM2 instead of ap.
15:31:57 <ddarius> (From that perspective, fmap becomes much more important, similar to the join/return perspective of Monad.)
15:32:11 <shachaf> Right.
15:33:03 <DanBurton> So Functor gives you the power to add context and lift functions into a context, while Applicative gives you the power to merge contexts?
15:33:47 <DanBurton> and Monad gives you the power to flatten nested contexts
15:34:07 <ciaranm> s/context/burrito
15:34:09 <hpc> huh
15:34:20 <DanBurton> ciaranm: -__-
15:34:29 <hpc> or alternatively, it gives you a means to write fmap2, fmap3, fmap4, ...
15:34:32 <Axman6> mmm, nested burritos
15:34:38 <c_wraith> DanBurton: functor doesn't give you the ability to add context.  that comes with applicative
15:34:46 <DanBurton> right, my bad
15:34:52 <nolrai_E> "Functor gives you the power to add context" it does?
15:35:00 <DanBurton> nope
15:35:01 <nolrai_E> ninjad.
15:35:11 <ciaranm> functor gives you the power of greyskull
15:37:25 <c_wraith> data Greyskull a =
15:39:02 <nolrai_E> @ty readSTRef
15:39:03 <lambdabot> forall s a. STRef s a -> ST s a
15:43:00 <nolrai_E> @ty (runST . runListT)
15:43:01 <lambdabot> Not in scope: `runListT'
15:43:13 <nolrai_E> really. hmm
15:43:14 <nh2> c_wraith: haha
15:43:22 <nolrai_E> @ty runST
15:43:23 <lambdabot> forall a. (forall s. ST s a) -> a
15:43:25 <hpc> there isn't a list transformer iirc
15:43:33 <hpc> it breaks laws
15:44:05 <nolrai_E> Its still in the libraries.
15:52:57 <Jerrry> Can anyone help me with my Haskell homework?
15:53:26 <ion> @vixen Can anyone help Jerrry with his Haskell homework?
15:53:26 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
15:53:50 <Jerrry> I am confused.
15:53:55 <parcs`> Jerrry: no, sorry
15:55:32 <hinkes> Does anyone have experience using the haskell-curl library?
15:55:41 <nolrai_E> I want "runOurMonad :: forall r. (forall a. ListT (ST a) r) -> [r]" but "runST . runListT " doesnt type check because it cant match expected type `forall a. ListT (ST a) r' with actual type `ListT m0 a0'.
15:55:54 <nolrai_E> Is this a fundamental problem with what I am doing?
15:57:36 <copumpkin> don't use (.)
15:59:02 <alpounet> is haskell on android still pretty much dead ?
15:59:54 <parcs`> nolrai_E: try "\(x :: forall s. ListT (ST s) a) -> runST $ runListT x"
16:00:13 <copumpkin> or just use parentheses
16:00:22 <Eduard_Munteanu> alpounet: well, I remember asking a few days ago, and while it seems some people had some success with Haskell on Android, there's no API binding
16:01:31 <alpounet> Eduard_Munteanu, all the threads/whatever i see on the internet tell about ways to do it but none of them about any success at doing so. any pointer ?
16:01:50 <Cale> Jerrry: feel free to ask any questions you might have :)
16:02:03 <Eduard_Munteanu> alpounet: hm, I haven't actually tried it, at all.
16:02:07 <Jerrry> Thanks Cale.
16:02:29 <Cale> Jerrry: We might not want to solve your homework questions outright, but if you're confused about something, there are lots of people who can help.
16:02:46 <Jerrry> I'm actually just confused about the format of this question, I don't need it solved.
16:02:52 <Cale> okay
16:02:55 <Jerrry> For example:
16:03:02 <Jerrry> Write a complete sentence describing each of
16:03:02 <Jerrry> these functional type signatures.
16:03:03 <Jerrry>  2a) Int -> [Char] -> [Char]
16:03:16 <alpounet> Eduard_Munteanu, do you remember who are the people who had some success with Haskell on Android ?
16:03:18 <irene-knapp> (it's best to use http://hpaste.org/ instead of pasting multiple-line things into the chat)
16:03:18 <ion> jerrry: As a general rule on the tubes, just asking the question works better than asking to ask.
16:03:21 <shachaf> Jerrry: Well, do you understand that type?
16:03:36 <Jerrry> I wrote this: This function takes an Int and a String (list of chars) and returns a String.
16:03:43 <Eduard_Munteanu> Jerrry: you're supposed to explain what that type means.
16:03:44 <irene-knapp> for the record, by "functional type signature" it just means "type signature", haha
16:03:47 <Eduard_Munteanu> Yeah.
16:04:14 <Jerrry> Thanks.
16:04:21 <Eduard_Munteanu> alpounet: oh, not really, but that was my impression. I'm not sure those who answered my question had any first hand experience either.
16:04:25 <hoqhuuep> Jerry, have you covered currying in class?
16:04:26 <Cale> Jerrry: that seems fine
16:04:27 <ion> I’m applying this functional function to this functional value and it returns a new functional value.
16:04:31 <irene-knapp> your answer seems reasonable
16:04:45 <Jerrry> I have not covered currying yet. I am actually just starting in Learn You a Haskell.
16:04:58 <Cale> Jerrry: It'd also be acceptable to say that it's a function which takes an Int and produces a function from Strings to Strings.
16:05:07 <Cale> (because that's the same thing)
16:05:11 <hoqhuuep> OK, your answer shuld be more or less acceptable then
16:05:12 <irene-knapp> what Cale just said is the one-sentence explanation of currying :)
16:05:13 <Eduard_Munteanu> Well, strictly, you don't need currying to get an intuition for that type.
16:05:16 <Jerrry> Oh, okay.
16:05:35 <irene-knapp> in Haskell, we can partially apply functions - call them on fewer parameters than they expect
16:05:38 <irene-knapp> we call this currying
16:05:46 <ion> Well, we call this partial application. :-)
16:05:50 <Eduard_Munteanu> Erm...
16:05:51 <irene-knapp> the result of doing that is a function that takes the remaining parameters
16:05:52 <irene-knapp> well, yes
16:05:52 <Eduard_Munteanu> What ion said :)
16:05:57 <irene-knapp> currying is the act of making the function be that way
16:05:59 <augur> irene-knapp: you interested in functional machine architecture?
16:06:05 <irene-knapp> augur: surely!
16:06:24 <Eduard_Munteanu> :t curry
16:06:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:06:29 <augur> irene-knapp: overflow?
16:06:30 <Jerrry> I think I sorta understasnd.
16:06:47 <irene-knapp> Jerrry: cool cool.  anyway, your professor will cover it (hopefully!) when the time comes.
16:06:53 <irene-knapp> augur: what about it?
16:06:54 <alpounet> Eduard_Munteanu, ok, thanks for the informations.
16:07:04 <augur> irene-knapp: lets talk in there, where its quiet :p
16:07:06 <irene-knapp> information cannot be pluralized
16:07:08 <Jerrry> Actually my friend is just teaching me Haskell but is writing me academic-looking quizzes.
16:07:08 <irene-knapp> it is already plural
16:07:10 <irene-knapp> like water
16:07:12 <Rc43> H, guys.
16:07:16 <irene-knapp> ah cool Jerrry :D
16:07:16 <Rc43> Hi*
16:07:19 <Jerrry> :P
16:07:21 <augur> irene-knapp: its not "already plural"
16:07:27 <augur> its "non-count / mass"
16:07:37 <irene-knapp> yes, yes, that's the linguist's explanation
16:07:41 <Eduard_Munteanu> alpounet: I haven't looked much at that, just Googled a bit and asked if there's a reasonable way to write Haskell apps on Android. Or rather Android apps in Haskell. Seems not, at the moment.
16:07:43 <irene-knapp> I'm giving the English teacher's explanation
16:07:47 <irene-knapp> as we already know, these are often at odds :D
16:07:48 <augur> irene-knapp: no, thats _the_ explanation :P
16:07:53 <Rc43> can anybody tell me some about join and meet operations. Are they the same as intersection and union?
16:08:00 <irene-knapp> but since the purpose of giving either at this juncture is to annoy and confuse, and either will accomplish it
16:08:07 <irene-knapp> :)
16:08:19 <irene-knapp> well, let's say tease and confuse, haha
16:08:21 <Eduard_Munteanu> Rc43: the latter are particular instances of the former
16:08:48 <monochrom> actually, I would think the teacher says "uncountable" as a doctrine and the linguist says "you could think of it as uncountable or always-plural, same difference"
16:08:48 <Eduard_Munteanu> Rc43: at least considering join and meet from lattices.
16:09:00 <Rc43> Eduard_Munteanu, yeah, thanks
16:09:25 <augur> monochrom: it cant be always plural
16:09:32 <irene-knapp> anyway, it's true, "already plural" was a very loose notion
16:09:35 <Eduard_Munteanu> Or least upper bound and greatest lower bound.
16:09:36 <augur> it doesnt agree like a plural, it agrees like a singular
16:09:38 <irene-knapp> it really is more accurate to say noncount
16:09:40 <augur> "this water" not "these water"
16:09:43 <Rc43> Eduard_Munteanu, I have seen wiki page about them, but there is no page on my lang and I didn't understood all on english.
16:09:45 <augur> "water is" not "water are"
16:09:45 <monochrom> except "information wants to be free" destroys my always-plural theory
16:10:00 <irene-knapp> the fun noncount noun is "signal"
16:10:08 <irene-knapp> because it has only started to be such since cellphones :)
16:10:12 <Eduard_Munteanu> Rc43: anything in particular?
16:10:19 <monochrom> "the United States is a strange country" hehe
16:10:54 <Eduard_Munteanu> It's an aliens' country, that's for sure.
16:11:10 <Rc43> Eduard_Munteanu, nothing serious, but e.g. why it is called 'meet'
16:11:32 <Eduard_Munteanu> Hm, I'm not sure about that.
16:11:34 <Rc43> I have an association like `meet = collide = intersect`
16:12:26 <Rc43> And what is mean `with respect to`?
16:12:39 <monochrom> "meet" is inspired by "intersect", "join" is inspired by "union"
16:13:09 * hackagebot type-unary 0.1.15 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.15 (ConalElliott)
16:13:39 <monochrom> "with respect to" doesn't have a mathematical definition. treat it as English prose.
16:13:59 <monochrom> similarly "it is interesting to note that"
16:14:41 <Rc43> monochrom, it is clear, difficult thing is 'with respect to partial order'.
16:14:41 <Eduard_Munteanu> "trivially" and "straightforward" also have interesting meanings :P
16:15:25 <Eduard_Munteanu> Rc43: what's the context?
16:15:43 <Rc43> monochrom, it is about that meet(a,b) < meet(c,d) if a<c & b<d ?
16:15:53 <Rc43> A meet on a set is defined as the unique infimum (greatest lower bound) with respect to a partial order on the set
16:16:40 <Rc43> (to be accurate if a<c or b<d)
16:16:48 <Eduard_Munteanu> Rc43: ah, it just says it's the greatest lower bound given by the actual partial order there, not another order
16:17:30 <monochrom> you can treat it as "A meet on a set is defined as the unique infimum (greatest lower bound) where "lower" is determined by a partial order on the set"
16:17:30 <Eduard_Munteanu> For example, they can talk about inf with respect to inclusion.
16:18:17 <Eduard_Munteanu> Then your '<=' is the inclusion.
16:18:43 <monochrom> this is not to say that "differentiate x*y with respect to x" equals "differentiate x*y where ___ is determined by x". did I say treat it as English prose? that's English for you.
16:18:59 <Rc43> ok, it is clear now, thanks
16:22:42 <ergot> hi, I was wondering if it is correct to use unionBy to discard "repeated" elements in to lists that are not really complete equal, and in case its fine to use it is it specified if the element to construct the final list is from the first list or the second?
16:24:12 <Eduard_Munteanu> @google nubBy
16:24:14 <lambdabot> http://nubbytwiglet.com/
16:24:14 <lambdabot> Title: Nubbytwiglet.com
16:24:17 <Eduard_Munteanu> Erm.
16:24:20 <Eduard_Munteanu> @hoogle nubBy
16:24:20 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
16:24:45 <Eduard_Munteanu> ergot: are you looking for that?
16:24:47 <nolrai_E> Where is the group keyword used?
16:25:10 <ergot> Eduard_Munteanu: no, let me explain
16:25:25 <nolrai_E> Or at least Eclipse thinks its a haskell keyword.
16:25:31 <Eduard_Munteanu> nolrai_E: hm... not sure, but SQL-like comprehensions?
16:25:39 <ergot> lets say I have data type that contatins a string and an Integer
16:25:51 <Eduard_Munteanu> (yes we have those :) )
16:25:52 <ergot> and I have two lists
16:25:58 <shachaf> ergot: I think you can rely on whatever behaviour is specified by the reference implementation in the Report.
16:26:12 <ergot> there are elements with same String value but different integer values
16:26:24 <monochrom> "group" is a keyword when you use monad comprehension. it's inspired by SQL
16:27:06 <monochrom> "[ x | x <- [1,1,2,2,3], then group by x ]"
16:27:23 <Eduard_Munteanu> So it's enabled by monad comprehensions alone?
16:27:37 <ergot> I want to get a list that is an union of both lists, but discarding items with same string
16:27:38 <shachaf> No, it existed before monad comprehensions were added back to GHC>
16:27:41 <monochrom> probably not
16:27:43 <shachaf> @google comprehensive comprehensions
16:27:44 <lambdabot> http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
16:27:44 <lambdabot> Title: Comprehensive Comprehensions
16:28:28 <monochrom> or probably yes. I don't know.
16:28:37 <shachaf> ergot: The implementation in http://www.haskell.org/onlinereport/list.html looks like it takes values from the first list.
16:28:37 <ergot> the thing is, if I have (Foo "hello" 1) in list one and (Foo "hello" 2) in list two
16:29:05 <Eduard_Munteanu> @google ghc sql comprehensions
16:29:07 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/SQLLikeComprehensions
16:29:07 <lambdabot> Title: SQLLikeComprehensions – GHC
16:29:10 <ergot> shachaf: and is sure that it wont change in that behaviour?
16:29:44 <shachaf> ergot: I *imagine* that List functions are guaranteed to behave like the Report implementation.
16:29:52 <ergot> maybe I'm doing it wrong by using union with elements that are not really equal
16:30:02 <shachaf> Maybe that's not true, though.
16:30:21 <ergot> ok shachaf, thank you
16:30:28 <shachaf> ergot: In the worst case you can just write a union-the-way-you-want-it function yourself (or take the implementation from the Prelude).
16:30:33 <shachaf> That might be safer.
16:30:35 <shachaf> s/Prelude/Report/
16:31:19 <ergot> yes that will be better, I have to be less lazy and write more code :)
16:34:59 <monochrom> "Duplicates, and elements of the first list, are removed from the the second list, but if the first list contains duplicates, so will the result" is from the haddock of union
16:35:39 <monochrom> it is not in the haddock of unionBy, granted
16:38:15 <shachaf> monochrom: But I imagine that it's reasonable to expect union = unionBy (==)
16:40:07 <ddarius> The Report says the By functions work given arbitrary equivalence relations (or total orderings), so presumably, when satisfying those constraints the Report definitions are authoritative.
16:43:27 <nolrai_E> @pl \ (x,y) -> (f x, f y)
16:43:27 <lambdabot> f *** f
16:43:39 <Mathnerd314> so what's the process for including packages into the Haskell Platform?
16:44:12 <hpc> @hackage haskell-platform
16:44:12 <lambdabot> http://hackage.haskell.org/package/haskell-platform
16:44:16 <hpc> see contact info there
16:44:21 <nolrai_E> @hoogle (***)
16:44:21 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:44:38 <hpc> possibly the main hackage.org contact info too
16:44:50 <ion> @pl \f -> f *** f
16:44:51 <lambdabot> join (***)
16:45:06 <ion> @pl \f (x,y) -> (f x, f y)
16:45:07 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:45:08 <nolrai_E> @pl ixmap' f grid = ixmap ((f *** f) . bounds grid) f grid
16:45:08 <lambdabot> ixmap' = join . (flip =<< (ixmap .) . (. bounds) . (.) . join (***))
16:45:19 <Mathnerd314> hpc: 404
16:45:22 <nolrai_E> that is super clear.
16:45:32 <nolrai_E> @pl ixmap' grid f = ixmap ((f *** f) . bounds grid) f grid
16:45:32 <lambdabot> ixmap' = flip =<< join . (ixmap .) . flip ((.) . join (***)) . bounds
16:45:41 <monochrom> the cabal controls the haskell platform :)
16:45:49 <nolrai_E> :P
16:46:58 <nolrai_E> @pl ixmap' grid f = ixmap (((\(x,y) -> (f x, f y)) bounds grid) f grid
16:46:58 <lambdabot> (line 1, column 15):
16:46:58 <lambdabot> unexpected "="
16:46:58 <lambdabot> expecting variable, "(", operator or end of input
16:47:38 <nolrai_E> @pl \ grid f = ixmap ( ((\(x,y) -> (f x, f y)) bounds grid) f grid
16:47:38 <lambdabot> (line 1, column 10):
16:47:38 <lambdabot> unexpected "="
16:47:38 <lambdabot> expecting pattern or "->"
16:47:48 <BMeph> :t (&&&)
16:47:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:48:13 <nolrai_E> bah.
16:48:15 <BMeph> Ah, yes, that one goes the other way.
16:48:29 <ion> Not exactly.
16:48:30 <monochrom> you were almost there. -> instead of =
16:48:38 <monochrom> @pl \ grid f -> ixmap ( ((\(x,y) -> (f x, f y)) bounds grid) f grid
16:48:38 <lambdabot> (line 1, column 64):
16:48:38 <lambdabot> unexpected end of input
16:48:38 <lambdabot> expecting variable, "(", operator or ")"
16:49:12 <ddarius> The problem is \(
16:49:26 <nolrai_E> @pl \ grid f -> ixmap ( ( \(x,y) -> (f x, f y) ) bounds grid) f grid
16:49:27 <lambdabot> flip =<< join . (ixmap .) . flip (flip (`ap` snd) bounds . (. fst) . (flip =<< (((.) . (,)) .)))
16:49:59 <nolrai_E> @pl ixmap' grid f = ixmap ((f *** f) bounds grid) f grid
16:49:59 <lambdabot> ixmap' = flip =<< join . (ixmap .) . flip (flip (join (***)) bounds)
16:50:17 <nolrai_E> @pl ixmap' f grid = ixmap ((f *** f) bounds grid) f grid
16:50:18 <lambdabot> ixmap' = join . (flip =<< (ixmap .) . flip (join (***)) bounds)
16:50:30 <ion> (Hint: it’s readable enough already. :-P)
16:50:39 <nolrai_E> Yeah. it is.
16:50:42 <monochrom> methinks it doth flippeth too much
16:52:19 * BMeph loves swapping function arguments, he said flippantly.
16:53:00 <monochrom> what, whom are copumpkin trolling?!
16:53:19 <ion> copumpkin are many?
16:53:42 <monochrom> oops, is
16:55:25 <hpc> we are copumpkin; you will be trolled; /ignore is futile
16:55:57 <mdmkolbe> :info (<$>)
16:56:04 <mdmkolbe> @info (<$>)
16:56:04 <lambdabot> (<$>)
16:56:13 <mdmkolbe> Where is "<$>" defined?
16:56:14 <hpc> use ghci
16:56:21 <hpc> Control.Applicative
16:56:23 <mdmkolbe> thx
16:56:45 <monochrom> hehe hpc
16:57:47 <monochrom> also in http://hackage.haskell.org/package/prelude-plus
16:59:40 <mdmkolbe> if (<$>) is liftM, is there something like it that is liftM2?
16:59:49 <hpc> liftA2
17:00:10 <hpc> also, liftA2 f x y = f <$> x <*> y
17:00:24 <hpc> repeat applications of (<*>) for arbitrary args
17:00:35 <mdmkolbe> hpc: thx agn
17:04:44 <Axman6> @remember BMeph loves swapping function arguments, he said flippantly
17:04:44 <lambdabot> I will never forget.
17:05:34 <shachaf> @forget how to use @remember
17:05:34 <lambdabot> No match.
17:06:05 <Mathnerd314> has anyone ever succeeded in using readline on windows? I found instructions here: http://kayalang.org/download/compiling/windows/readline
17:09:51 <Mathnerd314> it compiles, but it doesn't link to the readline library
17:25:49 <nolrai_E> I wish to make a new array that is a copy of an old array where they overlap, and a default value otherwise. (I.e. I wish to truncate and pad)
17:27:43 <nolrai_E> Or maybe I should make my shifts clock shifts.
17:30:59 <Algo> anyone here use Haskell for physics?
17:37:56 <Algo> while (*s++ = *t++);
17:38:08 <Algo> That has to be the most elegant line of code I have ever seen
17:38:27 <hpc> while (n --> 0) {...
17:38:35 <shachaf> It's not very Haskell.
17:38:52 <shachaf> Also, I'd say that that "elegance" is kind of incidental.
17:39:56 <Eduard_Munteanu> Well, that might not be very efficient, as well.
17:40:47 <Eduard_Munteanu> You want to use memcpy and let the compiler optimize (perhaps vectorize) the copy.
17:43:10 <hpaste> dgpratt pasted “error installing conduit” at http://hpaste.org/56166
17:43:31 <dgpratt> any ideas how to resolve that error?
17:44:14 <dmwit> dgpratt: Check that the top of the file says "module System.Win32File", not "module System.Win32FileRead".
17:44:19 <dmwit> Pretty much just what the error says. =P
17:44:46 <shachaf> dmwit: The error doesn't say that it's at the top of the file!
17:44:48 <dgpratt> dmwit: top of the file? the .cabal file?
17:44:58 <shachaf> The Haskell file.
17:45:02 <dmwit> dgpratt: No, the file it's complaining about, System\Win32File.hsc.
17:45:08 <shachaf> It's a GHC error, after all.
17:45:11 <dgpratt> dmwit: oh
17:45:48 <dmwit> shachaf: It does too say it's at the top of the file.
17:45:55 <dmwit> shachaf: System\Win32File.hsc:3:8
17:46:05 <hughfdjackson> someone suggested hereabouts that i dip my toes in the haskell waters w/ a webserver backend
17:46:05 <dmwit> Line 3, column 8.
17:46:09 <shachaf> dmwit: That's a bunch of numbers.
17:46:15 <hughfdjackson> since i lik emaking games, and my main language is javascript
17:46:22 * shachaf wants feeling from his compiler, not cold calculations.
17:46:34 <dmwit> hughfdjackson: Sounds like reasonable advice.
17:46:48 <hughfdjackson> dmwit: seems to be ^_^
17:47:02 <hughfdjackson> erm, basically i'm wondering what the canonical websockets package is
17:47:03 <dmwit> I guess Yesod and Snap are the reigning web frameworks just now.
17:47:09 <Jerrry> Can someone explain to me what this means?  (Int -> Bool) -> [Int] -> [Int]
17:47:13 <hughfdjackson> http://hackage.haskell.org/packages/archive/network-websocket/0.2/doc/html/Network-Websocket.html <-- this?
17:47:15 <dmwit> (Not sure what happstack's status is, but it was the reigning one before those two appeared.)
17:47:27 <hughfdjackson> dmwit: ^_^ shall take a look!
17:47:44 <dmwit> Jerrry: Yes.
17:47:51 <hoqhuuep> Jerry, just break it up, first, what is the bit in the parentheses?
17:48:05 <dmwit> Jerrry: It's a type signature; it tells how you can use or construct a value.
17:48:14 <Jerrry> The part inside the parentheses returns a boolean, right?
17:48:23 <dmwit> Correct.
17:48:31 <Jerrry> Okay, thanks.
17:48:43 <hoqhuuep> Yes, it's a function fwhich takes an Int and returns a Bool
17:48:49 <shachaf> Jerrry: Can you say what you don't understand about it?
17:48:52 <dmwit> But, keep in mind that since it's to the left of a function arrow, that means the entire type (Int -> Bool) is an argument to the function.
17:49:13 <Jerrry> shachaf: I just wasn't sure what the parentheses meant. I'm completely new to Haskell and I'm doing homework.
17:49:34 <Jerrry> Thanks, dmwit.
17:50:07 <hughfdjackson> hrm, it seems that neither yesod or snap support websockets
17:50:34 <hughfdjackson> oOo http://hackage.haskell.org/package/websockets-snap-0.5.0.0 <-- that integrates it though
17:50:49 <hughfdjackson> :P it's hard to come into a scene and not know what the canonical packages are sometimes
17:51:04 <hoqhuuep> So looking at the whole thing you've got a function which takes 2 arguments. The first argument is a function which takes an Int and returns a bool, the second argument is a list of Ints, and it returns another list of Ints, does that make sense?
17:51:54 <Jerrry> Yeah, hoqhuuep that makes sense.
17:52:35 <shachaf> That's also Jerrry's homework. :-(
17:52:45 <dmwit> hughfdjackson: Do you have a reason for wanting to use web sockets?
17:52:50 <Jerrry> I already wrote an answer.
17:52:50 <dmwit> (Just because they're neat, or what?)
17:54:45 <hoqhuuep> Yeah sorry, I guess probably shouldn't have just told the answer...
17:54:47 <hughfdjackson> dmwit: i was gonna try to implement pong, so it seemed a more natural fit
17:54:53 <hughfdjackson> i suppose i could just poll the server every frame
17:55:06 <hughfdjackson> :P bit ugly, no?
17:55:26 <hughfdjackson> erm, not so much poll, rather, send a HTTP request
17:55:28 <Jerrry> hoqhuuep: it's okay, I had already written an answer and plus this isn't real homework.
17:55:33 * hughfdjackson 's a little sleepy 
18:00:50 * hoqhuuep finally finished reading the "Input and Output" chapter of LYAH... that's one long chapter, a lot of stuff to take in :)
18:14:57 <Duffman-> :t fmap (:) (+3)
18:14:58 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
18:22:56 <Algo> shachaf: isn't "while (*s++ = *t++);" copying an array?
18:23:12 * hackagebot crypto-conduit 0.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.1 (FelipeLessa)
18:26:30 <issactrotts> Does anyone here know of a haskell search engine with good ranking of packages?
18:26:44 <issactrotts> Hoogle does not seem to do a good job of ranking currently.
18:26:50 <shachaf> Algo: It's copying a zero-terminated buffer of memory.
18:31:09 <lpsmith> issactrotts, I'm pretty sure such a thing doesn't currently exist
18:31:43 <lpsmith> hackage was supposed to add features to help judge the quality/popularity of packages.
18:31:50 <issactrotts> lpsmith: It sort of looks like Hayoo does it with the results that come up on the left hand side.
18:32:16 <issactrotts> lpsmith: Yeah, I heard about that. Do you know why that didn't happen?
18:32:37 <lpsmith> I have no idea.
18:34:15 <issactrotts> lpsmith: I'm thinking it would work pretty well to rank libraries according to how many packages depend on them. For executables it's not as clear, but maybe the number of downloads would be a start if that number is available.
18:42:42 <xil> hi. Is the Data.List.sort function O(log n)? Or can I not rely on that? I remember once reading that it was in fact a quicksort, but I don't see that anywhere now
18:43:12 <aweis> comparison based sorts are O(nlogn).....
18:43:18 <xil> whoops, that's what I meant
18:43:39 <shachaf> xil: No, it's not quicksort.
18:43:52 <drull95> it's bubble sort
18:44:03 <xil> drull95: lol
18:44:22 <xil> shachaf: but is it O(nlog n)? That's what matters really
18:44:25 <shachaf> Quicksort is awkward to write in Haskell.
18:44:28 <copumpkin> it's an unsafePerformIO'd bogosort
18:44:34 <mauke> xil: yes
18:44:39 <shachaf> xil: Quicksort isn't O(n log n).
18:44:54 <copumpkin> xil: it's also less than that if you don't ask for the whole list
18:45:00 <copumpkin> or so the haskell lore says
18:45:06 <xil> shachaf: what?
18:45:10 <shachaf> The Report sort is O(n^2), I think.
18:45:11 <xil> copumpkin: that's pretty cool, haha
18:45:16 <copumpkin> unlike most non-strictness properties, you can't test this one with undefined
18:45:18 <shachaf> GHC's sort uses mergesort.
18:45:36 <shachaf> xil: Quiksort is O(n^2) in the worst case.
18:46:07 <shachaf> Of course, Quiksort is a cheap knock-off of Quicksort®. Accept no imitations.
18:46:39 <aweis> shachaf: then isnt the sort then O(nlogn)
18:47:43 <xil> I thought quicksort was the fastest but just tricky to write, and mergesort was the same other than greater memory usage
18:47:50 <shachaf> aweis: No, quicksort is also O(n^2) in the worst case.
18:47:57 <shachaf> xil: No sorting algorithm is "the fastest".
18:48:11 <c_wraith> mergesort also has better locality effects when multi-level memory makes a big difference
18:48:12 <xil> shachaf: of the ones we know*
18:48:13 <shachaf> And also things are completely different when you're dealing with immutable linked lists and with muable arrays.
18:48:25 <xil> oh right...
18:48:29 <shachaf> xil: No sorting algorithm is "the fastest of the ones we know".
18:48:41 <aweis> shachaf: sorry to call you out on intro to algo stuff but merge is O(nlogn) in all cases
18:48:42 <xil> but you know what I meant
18:48:52 <Eduard_Munteanu> Well, that doesn't prevent people from saying quicksort performs best *usually*.
18:48:54 <shachaf> aweis: Right, but I was talking about QUicksort.
18:49:12 <shachaf> aweis: Oh, by "the sort" you meant GHC's implementation.
18:49:17 <Eduard_Munteanu> AFAIK, that's not a bad assessment.
18:49:18 <aweis> quicksort is only bad if the method of picking your median is ungodly done
18:49:34 <shachaf> I assume it's O(n log n).
18:49:57 <aweis> fast median finding is O(n) using probabilistic methods
18:49:58 <Duffman-> is <*> left associative?
18:50:00 <shachaf> GHC's sort isn't actually a plain mergesort.
18:50:16 <c_wraith> it's a plain bottom-up mergesort, I thought
18:50:24 <Duffman-> :info (<*>)
18:50:43 <Duffman-> nvm
18:50:46 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
18:50:48 * Eduard_Munteanu thought the typical bad Haskell quicksort wasn't actually a quicksort
18:50:52 <aweis> the fact that haskell is lazy really works in its favor when finding optimal medians for pivots during a quicksort
18:51:18 <Eduard_Munteanu> s/typical/simple/
18:51:22 <shachaf> aweis: It does?
18:51:37 <c_wraith> aweis: not in any way I know of
18:51:41 <aweis> there is a brilliant method for finding medians in O(n) time
18:52:01 <BMeph> Can't you just tell it to use the median value for the pivot? ;)
18:52:18 <shachaf> "laziness" isn't this magical thing that makes your code fast.
18:52:52 <c_wraith> aweis: all the techniques I know of for that are too slow for use in real algorithms
18:53:07 <BMeph> shachaf: Of course not! It's a magical  thing to make your code AWESOME! ;þ
18:53:18 <aweis> http://en.wikipedia.org/wiki/Selection_algorithm
18:53:18 <aweis> half way down the page
18:53:24 <aweis> Linear general selection algorithm - Median of Medians algorithm
18:53:34 <shachaf> aweis: I'm not sure what that has to do with either laziness or quicksort.
18:53:59 <aweis> the fact that half the medians are just thrown away works beautiful in a lazy environment since... we don't ever compute anything
18:54:01 <shachaf> Oh, well, I see what it has to do with quicksort.
18:54:13 <c_wraith> aweis: that's not how laziness works
18:54:22 <shachaf> aweis: Laziness isn't going to do magic, you know.
18:54:32 <aweis> I understand that
18:54:42 <shachaf> Anything that's possible with laziness in Haskell is quite possible in C.
18:54:45 <aweis> but in eager methods, those medians would be computed
18:55:04 <c_wraith> they're not optional
18:55:14 <aweis> half of them are
18:56:06 <mauke> lol wut
18:56:16 <shachaf> What mauke said.
18:57:51 <monochrom> I have decided to summarize lazy evaluation as short-circuit evaluation, meaning some things are skipped, sure, but there are rigid conditions and rules for that. I have decided not to say "when needed", because people attribute magical divine wisdom in figuring out "need". the computer doesn't have magical divine wisdom.
18:58:29 <mauke> aweis: what do you mean by "half the medians are just thrown away"?
18:58:31 <Philippa> "when demanded" seems to work slightly better, in that people seem to have an easier time accepting that there are rigid rules governing demand
18:59:44 <aweis> mauke
18:59:45 <shachaf> mauke: I refer you to section 28.4 of the Haskell 98 Report, "The Trash Can".
18:59:53 <aweis> our goal is to find the median
18:59:54 <mauke> aweis
18:59:58 <mauke> yes
19:00:08 <aweis> we partition our lists in n/5 sub lists
19:00:28 <aweis> we find median of these lists
19:00:39 <c_wraith> there is no way to avoid looking at every element in the process.
19:00:54 <mauke> c_wraith: no spoilers
19:01:06 <aweis> oh perhaps I was mistaken
19:01:08 <shachaf> c_wraith: No, you just, like, stop looking once you find the median!
19:01:39 <aweis> i seemed to recall that there were even crazier optimizations using things like fib heaps and the like
19:01:49 <mauke> c_wraith: I'm specifically interested in the "half" part of "half the medians"
19:04:20 <aweis> im pretty sure the half comes in when you recurse, each of those n/5 lists of 5 becomes lists of 3 or 2 to look at
19:04:41 <aweis> n/5/2 medians are useless now
19:04:48 <aweis> since they are not the median
19:05:28 <mauke> each of those n/5 lists becomes 1 element
19:11:49 <ezyang> Oh man, why am I not subscribed to Bob Atkey's blog
19:13:07 <c_wraith> I don't know.  Why haven't I heard of it?
19:22:37 * BMeph hugs his RSS feed from http://personal.cis.strath.ac.uk/~raa/
19:23:18 <ezyang> http://personal.cis.strath.ac.uk/~raa/posts/2012-01-06-streams.html
19:23:35 <c_wraith> oh.
19:23:37 <ezyang> It looks suspiciously similar to Oleg's generalization in IterAdv, but I haven't looked too closely yet.
19:23:40 <c_wraith> heh.  I *just* clicked on that link
19:23:46 <c_wraith> (via reddit)
19:23:51 <ezyang> yep yep
19:24:10 <ezyang> I tip my hat to bentnib for some well played self promotion
19:24:10 <c_wraith> but at least now I know what you're talking about
19:26:51 <ezyang> IMO, the possibility of fusion is probably one of the biggest reasons why the conduit approach may not work out.
19:27:21 <c_wraith> possibility of fusion?
19:27:35 <c_wraith> My biggest issue with conduits is the reliance on mutable structures
19:27:51 <ezyang> Well, no one knows how to implement fusion on effectful stream processors yet.
19:28:07 <c_wraith> ah.  So you mean "possibility of fusion of something else"
19:28:11 <ezyang> c_wraith: Yeah, but if everyone thinks that conduits are *so* much easier to implement I fear they may end up seeing wide usage anyway :^)
19:28:49 <ezyang> But it seems pretty clear to me that the pure side of the coin isn't that well baked yet so I'm all for a bit of friendly competition.
19:29:18 <c_wraith> yeah, there's certainly room to figure stuff out
19:34:39 <djanatyn> Hmm, I was wondering, say I had a list of numbers represented as strings
19:34:53 <djanatyn> > ["1","2","3","4","5"]
19:34:54 <lambdabot>   ["1","2","3","4","5"]
19:35:07 <djanatyn> and I wanted to go through each element, reading them into a Int.
19:36:00 <shachaf> djanatyn: Do you know about "read"?
19:36:14 <djanatyn> ...oh. I was being silly.
19:36:18 <djanatyn> I was trying to do this:
19:36:30 <djanatyn> > map (read :: Int) $ words "1 2 3 4 5 6 7 8 9 10"
19:36:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:36:31 <lambdabot>         against inferred type ...
19:36:34 <djanatyn> when I needed to do this:
19:36:45 <djanatyn> > map (\x -> read x :: Int) $ words "1 2 3 4 5 6 7 8 9 10"
19:36:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:36:55 <djanatyn> Is there a way to do that without a lambda?
19:37:01 <shachaf> > map read $ words "1 2 3 4 5 6 7 8 9 10" :: [Int]
19:37:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:37:22 <djanatyn> Oooh. okay.
19:37:43 <djanatyn> So, if we put the type signature at the right, that's the type of the entire completed expression, and haskell can infer what to do from there
19:37:43 <shachaf> If you use the values in an Int context, you don't even need to write the type signature.
19:37:46 <BMeph> > map ((+0).read) $ words "1 2 3 4 5 6 7 8 9 10"
19:37:46 <djanatyn> ?
19:37:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:37:53 <shachaf> BMeph: Don't be disgusting.
19:37:55 <djanatyn> Oh, sweet.
19:38:19 <shachaf> djanatyn: Don't do (+0). That doesn't even do what you want, on top of everything else.
19:38:29 <shachaf> > map (read :: String -> Int) $ words "1 2 3 4 5 6 7 8 9 10"
19:38:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:38:31 <djanatyn> Yeah, that seems kind of pointless. Demonstrates the concept, though.
19:38:40 <djanatyn> Ah, cool!
19:38:45 <BMeph> shachaf: What, You're the one who said "use the values in an Ynt context". ;þ
19:38:50 <aweis> > foldl (+) 0 [1,2,3]
19:38:50 <lambdabot>   6
19:38:54 <djanatyn> > map (read :: String -> Double) $ words "1 2 3 4 5 6 7 8 9 10"
19:38:54 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
19:38:56 <djanatyn> :D
19:39:04 <BMeph> Rather, an "Int" context. :)
19:39:12 <shachaf> BMeph: Yes, which (+0) doesn't do. Also, I meant "use the values produced by the expression".
19:39:23 <Cody_> Hello everyone
19:39:27 <djanatyn> I'm a little confused, though. Earlier, you did  > map read $ words "1 2 3 4 5 6 7 8 9 10" :: [Int]
19:39:41 <djanatyn> > words "1 2 3 4 5" :: [Int]
19:39:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:39:42 <lambdabot>         against inferred type ...
19:39:48 <BMeph> Hello, Cody_
19:39:49 <shachaf> :: is looser than $
19:39:56 <djanatyn> ohhhhhhhhhh okay that makes total sense then.
19:39:57 <shachaf> $ is an operator, :: is syntax.
19:40:01 <djanatyn> Yay.
19:40:21 <BMeph> .
19:40:21 <djanatyn> We can still put it inside of parentheses though, which is cool.
19:40:34 <djanatyn> Like when we made a more specific type declaration for read.
19:40:40 <Cody_> BMepg_ how long have you've been in Haskell?
19:40:40 <shachaf> > (map read . words $ "1 2 3 4 5 6 7 8 9 10") :: [Int]
19:40:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:41:01 <aweis> > foldl (-) [1,2,3,4]
19:41:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
19:41:02 <lambdabot>    arising from a us...
19:41:07 <aweis> > foldl (-) 0 [1,2,3,4]
19:41:08 <lambdabot>   -10
19:41:17 <aweis> > foldl (-) 0 [4,3,2,1]
19:41:18 <lambdabot>   -10
19:41:25 <BMeph> Cody_: Not long enough. How are you?
19:41:36 <aweis> > foldr (-) 0 [4,3,2,1]
19:41:37 <lambdabot>   2
19:41:48 <Cody_> BMeph_: Hanging in there. Ever used python?
19:41:49 <shachaf> Cody_ demands 15 years of Haskell experience from people who help him.
19:41:53 <djanatyn> Haskell's type inference system is pretty crazy. Is it magical, or is there some formal specification for what it'll figure out and what it won't?
19:42:01 <shachaf> djanatyn: It's not magical.
19:42:03 <djanatyn> I'm...guessing it's not magical
19:42:20 <djanatyn> I'm asking for what the specification is, or a link, or something. Maybe a cool article or paper.
19:42:22 * BMeph finds it "magically delicious," though
19:42:22 <Cody_> shachaf_ not necessarily lol
19:42:27 <shachaf> It's actually pretty simple.
19:42:31 <Eduard_Munteanu> If nobody is in the mood to explain it, it's magical :P
19:42:47 <BMeph> Cody_: Yes. So, writing an Experience blog? ;)
19:42:52 <shachaf> djanatyn: "type inference" would be a good thing to look up.
19:42:58 <shachaf> djanatyn: Or "Hindley-Milner".
19:42:59 <drull95> djanatyn, search for "typing haskell in haskell"
19:43:10 <Cody_> BMeph_: Expericence blog?
19:43:19 <shachaf> Haskell isn't Hindley-Milner but that's a good start.
19:43:34 <shachaf> djanatyn: It's all about unification, if you know Prolog or something.
19:43:45 <djanatyn> Is the implementation of haskell's type inference scary?
19:43:59 <djanatyn> ghc is so cool, but it really makes me wonder how crazy the code beneath is.
19:44:07 <mauke> djanatyn: I find it pretty intuitive
19:44:08 <djanatyn> Then again, it's written in Haskell, I think.
19:44:12 <aweis> my favorite part of the haskell type system is the fact that it does not care what the user explicitly types, it figures itself out itself and then checks to see if the user lied
19:44:15 <mauke> at least for standard haskell
19:44:16 <Cody_> BMeph_: In java, there is +=. Does such exist in haskell?
19:44:27 <ezyang> yeah, explicit types makes GHC's job harder >:-)
19:44:55 <c_wraith> Cody_: no.  You can't change the value a name is bound to
19:45:11 <drull95> for a simple language type inference is easy, just pass known types up and down the tree, attempt to unify where they meet
19:45:13 <djanatyn> Cody_: You could make it, but that would be Really Bad
19:45:18 <Eduard_Munteanu> You can devise some sort of (+=) for (certain) STRefs/IORefs.
19:45:27 <Cody_> c_wraith: so for example. It'd be  a = a +1?
19:45:40 <djanatyn> Cody_: lying is wrong
19:45:43 <shachaf> Cody_: No.
19:45:49 <shachaf> Cody_: There's no assignment.
19:45:52 <shachaf> There are no variables.
19:45:54 <c_wraith> Cody_: no, that's not going to work.  the a in the body refers to the same name as you're binding it to.  that creates an infinite loop
19:45:54 <shachaf> Things never change.
19:46:43 <djanatyn> Hah, I forgot that we could define names recurisvely. I always assumed that `a = a + 1` would throw some type of error.
19:46:44 <Cody_> So variables are immutable?
19:46:55 <c_wraith> yes
19:47:02 <Eduard_Munteanu> They're not really variables :)
19:47:04 <djanatyn> < shachaf> There are no variables.
19:47:05 <Cody_> Where as in Python they are not?
19:47:11 <drull95> unless you're using monads, then a += 1 could be meaningful :P
19:47:19 <shachaf> Cody_: That's correct.
19:47:21 <c_wraith> drull95: monads aren't really relevant there
19:47:37 <shachaf> drull95: Monads have nothing to do with that.
19:47:38 <Eduard_Munteanu> Some monads.
19:47:43 <c_wraith> drull95: IO or ST are, but that's because they allow mutability.  The fact that they happen to be monads is irrelevant
19:47:53 <shachaf> Eduard_Munteanu: You might as well say "unless you're using types".
19:47:55 <Eduard_Munteanu> Or some hypothetical fake ST.
19:48:54 <drull95> well, i meant you could make a dsl for an imperative interpreter using the state monad, but i guess i could've made that more clear
19:49:03 <Eduard_Munteanu> shachaf: yeah, I agree the wording isn't really fortunate
19:49:11 <cl1> @pl unlines (splitLines input)
19:49:11 <lambdabot> unlines (splitLines input)
19:49:37 <cl1> @unpl unlines (splitLines input)
19:49:38 <lambdabot> unlines (splitLines input)
19:49:40 <shachaf> Eduard_Munteanu: It's not just unfortunate, it's misleading.
19:49:55 <shachaf> drull95: If you mean "using State", you should say "using State". :-)
19:50:14 <shachaf> The fact that State is a monad isn't really relevant; you could do it even if State wasn't a monad.
19:51:28 <lpsmith> @pl  \input -> unlines (splitLines input)
19:51:28 <lambdabot> unlines . splitLines
19:52:44 <cl1> does ghci have some @pl feature?
19:52:59 <byorgey> no
19:53:14 <BMeph> yes
19:53:18 <c_wraith> someone should resurrect the GoA project
19:53:56 <shachaf> Most of lambdabot isn't worth having in ghci.
19:53:56 <BMeph> (FSVO "have", "some" and "ghci"... ;) )
19:54:05 <lispy> hmm...trying to remove cairo/gtk as deps from Chart.  It's harder than I exected as it's very tied to them.
19:54:09 <shachaf> You can get @pl in ghci easily enough without lambdabot.
19:54:22 <lispy> I made enough progress for tonight.
19:54:37 <byorgey> lispy: what are you replacing them with?
19:54:57 <lispy> byorgey: glfw-b + homegrown png writer for now.
19:55:37 <lispy> byorgey: I want to be able to 'cabal install' Chart on any platform without hard to satisfy dependencies.  I want that more than I want output formats :)
19:55:44 <byorgey> cool, just curious
19:55:48 <Cody_> Is anyone here familiar with the solve() function in the TI-89?
19:55:49 <byorgey> I hear you!
19:56:11 <lispy> byorgey: I'm probably also giving up font rendering for now too, but I can add that back later with freetype2 if I miss it
19:56:18 <byorgey> sure
19:56:27 <lispy> Cody_: Nope.
19:56:33 <ion> I have a TI-89 but i haven’t used it for ages.
19:56:33 <byorgey> Cody_: I've used it, I don't know if that counts as being familiar
19:56:37 <lispy> Cody_: symbolic solver?
19:56:47 <byorgey> lispy: yes
19:57:16 <lispy> Oh, you could probably make a neat solver in Haskell by using some type class hacks on Num like that one package lambdabot bot uses
19:57:19 <c_wraith> > x + y
19:57:19 <Cody_> Always thought it'd be interesting to implement (or mimic) in Haskell or maybe even Python.
19:57:20 <lambdabot>   x + y
19:57:47 <dolio> You should replace it with console graphics.
19:58:00 <dolio> Ed and I happened upon a sweet console backend for the Java AWT yesterday.
19:58:09 <lispy> dolio: are you refering to chart?
19:58:09 <mauke> > deriv (^2) x
19:58:10 <lambdabot>   1 * x + x * 1
19:58:15 <dolio> Yes.
19:58:24 <lispy> dolio: link?
19:58:34 <dolio> http://bmsi.com/tuipeer/
19:59:33 <hpaste> djanatyn pasted “type inference rocks” at http://hpaste.org/56170
19:59:50 <djanatyn> yay, I did a little thingy :D
20:00:04 <djanatyn> ...oh, wow. Yeah, should've used print there. Thanks, hlint.
20:00:10 <ion> And less $s
20:00:29 <Cody_> For example: solve(x-1=0, x), will return x = 1. Example: solve(x^2-2x+1=0,x) will return x = -1. Would you use pattern matching to decide "how" to solve for x?
20:00:41 <djanatyn> really? where?
20:00:50 <lispy> dolio: bummer, no "screen shots"
20:00:53 <mauke> everywhere
20:01:01 <dolio> There are.
20:01:08 <djanatyn> at least there's only four.
20:01:14 <dolio> http://bmsi.com/tuipeer/images/tui.gif
20:01:15 <djanatyn> main = forever $ do -- that's idiomatic haskell, right?
20:01:17 <ion> In forever $ do … the $ is warranted, although i wish Haskell supported “forever do …”
20:01:24 <mauke> djanatyn: yes
20:01:26 <dolio> http://bmsi.com/tuipeer/images/gui.gif
20:01:28 <djanatyn> okay, so 3 left
20:01:39 <ion> But if you have more than $ on one line you’re almost certainly overusing it.
20:01:47 <ion> more than one $
20:01:52 <dolio> Same application, apparently.
20:02:53 <lispy> dolio: haha, that's epic.  Looks so much like Windows 3.x
20:02:59 <djanatyn> Cody_: that's one way to do it, yeah. Let me try it!
20:03:20 <parcs`> > fix (`deriv` x)
20:03:21 <lambdabot>   Occurs check: cannot construct the infinite type:
20:03:21 <lambdabot>    b = Data.Number.Dif.Di...
20:03:45 <monochrom> no, that's at least windows 95
20:03:46 <djanatyn> it would be a pretty complicated function as you added more functionality to it, but solving equations with one operator wouldn't be too complicated.
20:03:50 <Cody_> djanatyn_:I had a math midterm today and mid-test I thought to myself, "hey this would be an awesome project!"
20:04:01 <djanatyn> also, we don't use parentheses when supplying arguments to functions
20:04:03 <djanatyn> just spaces
20:04:16 <Cody_> sore, that is the TI-89 talking
20:04:20 <Cody_> sorry*
20:04:23 <djanatyn> sure :D
20:05:13 <djanatyn> soon you might start haskell-talking to your TI-89
20:05:28 <djanatyn> writing perl code for me is getting kind of weird now
20:05:32 <ion> Let’s port GHC to it.
20:05:37 <Cody_> Lol, maybe. I think there is an editor for it.
20:05:45 <Cody_> In visual basic?
20:05:59 <djanatyn> what about visual basic?
20:06:00 <lispy> GHC on a TI-89 sounds intense.
20:06:23 <Cody_> You can create your own functions in the TI-89 in BASIC
20:06:25 <djanatyn> I've wanted a haskell calculator for a very long time
20:06:32 <lispy> http://www.ticalc.org/basics/calculators/ti-89.html#3
20:06:38 <djanatyn> GHC in BASIC sounds intense
20:06:47 <Cody_> the coolest calculator I've ever seen is PARI / GP
20:08:10 <Cody_> I've gotten bored with Java so I came over to Haskell. I wish Java was able to do list comprehensions. Python can I know.
20:08:22 <djanatyn> I started out using the python shell as my calculator. Then I used lisp with emacs. Now I use haskell with ghci!
20:08:45 <Cody_> Would you recommend learning Python or Haskell first?
20:08:47 <ion> There used to be a nice RPN interface for TI-89 but the site seems dead.
20:08:52 <djanatyn> Uhh. Well.
20:09:07 <ion> cody: Haskell of course. Now ask that on #python. :-P
20:09:08 <djanatyn> From my own personal experience, it's taken me many attempts to learn the basics of haskell. And I'm still an absolute beginner
20:09:16 <Cody_> ion_: lol
20:09:36 <djanatyn> At least, for *me*, and a lot of other people, haskell has been difficult to learn.
20:09:45 <Cody_> One or the other will be my second language. Can't decide!
20:09:49 <djanatyn> Whether or not that's because we come from imperative backgrounds, I dunno. Probably.
20:10:03 <djanatyn> I think there was a university that taught Haskell in their introductory CS classes, with success
20:10:12 <Cody_> Haskell seems more interesting / challenging. But python seems more practical.
20:10:19 <Cody_> Can't decide!
20:10:26 <djanatyn> Both are very practical.
20:10:40 <djanatyn> Python will be easier to learn and start using immediately, for sure.
20:10:48 <Cody_> Already stared :)
20:10:51 <ion> Knowing Haskell will make you able to write better code in Python as well.
20:10:58 <Cody_> Heard that as well.
20:11:37 <djanatyn> It's harder to write Really Bad Code in haskell than it is in python.
20:12:01 <c_wraith> Eh.  only a little.
20:12:03 <ion> And there’s LYAH for Haskell. ;-)
20:12:11 <c_wraith> You can write Really Bad Code in any language :)
20:12:12 <djanatyn> there's a barrier that you have to overcome with all the new concepts to learn, but you'll be better off once you do! And if you're still not convinced, just ask other haskell programmers
20:12:20 <Cody_> I have a matrix multiplication calculator in Java. I have no idea how to translate it into Haskell.
20:12:25 <ion> And there’s #haskell for Haskell.
20:12:31 <lispy> I find that it can be hard sometimes to get haskell installed (but the HP makes that easier) and sometimes haskell doesn't run where you want it.  But for everything else, it's simply amazing.
20:12:33 <Cody_> Started reading LYAH.
20:12:42 <djanatyn> c_wraith: at the very least, writing haskell code requires a more disciplined approach. You can't just vomit out state everywhere, you have to think about it.
20:12:47 <ion> (The Friendly Programming Channel™ :-P)
20:13:04 <jakky> haskell is very different
20:13:11 <djanatyn> Which eliminates a lot of people who aren't seriously interested in learning the language, and who would have contributed bad code
20:13:27 <djanatyn> Cody_: LYAH is awesome! Keep reading. It gets better the farther you go.
20:14:08 <djanatyn> And don't die when you get to chapter 8
20:14:09 <Cody_> Personally, I use Java to do programs that aren't mathematically based. For example, we are mocking Edline right now. I feel learning Haskell or Python would make it easier to do mathematically orientated programs easier
20:14:31 <Cody_> I don't know if Haskell can read in CSV files
20:14:32 <djanatyn> types seemed really boring to me at first, but they're awesome and practical.
20:14:46 <Cody_> My teacher suggested to learn PHP...
20:14:50 <djanatyn> Haskell can totally read in CSV files.
20:14:57 <djanatyn> Whether or not someone has coded a library to do that, I dunno.
20:15:21 <djanatyn> Oh. That looks really easy >_>
20:15:25 <Cody_> Disapproved haskell because it's too academic and not used in the "real world"
20:16:33 <djanatyn> well, that's wrong. haskell is being used in the industry right now!
20:16:46 <Cody_> Besides in finance
20:16:53 <djanatyn> And with great results, as far as I can tell
20:17:12 <Sgeo> Cody_, well, do you want to learn a bad language because jobs use it, or do you want to learn a good language that may be fun to use on your own even if you end up having to learn a bad language on the job?
20:17:14 <djanatyn> COBOL is used in the real world, but that's not a very good reason to learn it.
20:17:53 <djanatyn> I don't know if Haskell would make you a better PHP coder. Maybe?
20:18:00 <djanatyn> You would probably be a more thoughtful one.
20:18:03 <Cody_> Sgeo_:60 % because I like it. 40 % because I would like a job.
20:18:30 <Cody_> I feel PHP is sloppy, Python reads easier.
20:18:35 <JoeyA> I found Haskell made me a better C and PHP programmer.
20:18:36 <Sgeo> Question: Would any employers be impressed by Haskell knowledge?
20:18:51 <JoeyA> Good question
20:19:00 <Cody_> Honestly, I don't know. Yes?
20:19:25 <JoeyA> I listed that on a job application for food service.  Not sure that was a good idea in retrospect.
20:19:37 <Cody_> Hahah^
20:19:37 <djanatyn> Cody_: http://www.haskell.org/haskellwiki/Haskell_in_industry
20:19:40 <djanatyn> xD
20:21:48 <jakky> are there any other languages that are fun to write in besides hs
20:22:01 <jakky> i'm generally a perl coder and i started getting in hs
20:22:13 <Cody_> python and ruby
20:22:15 <cl1> i have been writing software for a decade in c#, and I would have to say haskell seems to be far superior than any other language I have seen
20:22:19 <djanatyn> I find it fun to write in most modern languages. >_>
20:22:44 <Sgeo> jakky, languages that might be considered not-mainstream but "good", in some sense over more popular languages:
20:22:48 <Sgeo> Lisps, Smalltalk
20:22:50 <Sgeo> Factor
20:23:09 <cl1> prolog, and ada are good languages too
20:23:10 <Sgeo> Hmm, what good strongly-typed languages are there other than Haskell?
20:23:15 <jakky> i've heard ruby is fun cody
20:23:21 <cl1> c# is pretty damn good
20:23:22 <jakky> smalltalk could be fun
20:23:25 <Cody_> So coming off java, should I a) learn Haskell, b) learn a scripting language (Python, Php) or c) delve depper into java?
20:23:38 <djanatyn> The most fun languages I have used are haskell, perl6, python, ruby, javascript, common lisp, and clojure
20:23:49 <Sgeo> I have some biases, but I may be against Java and PHP
20:23:57 <Cody_> Why so?
20:24:01 <drull95> haven't really used them but constraint logic languages like oz and mozart seem cool
20:24:01 <jakky> i want to start focusing on perl6 and haskell
20:24:05 <Sgeo> But I never oriented learning towards a career
20:24:06 <djanatyn> the least fun language has been java
20:24:12 <drull95> i love j, k
20:24:22 <cl1> Cody_ I would learn haskell. understanding functional programming will stick with you for the rest of your programming life, even if you don't use haskell every day. You wouldn't get that from python php or java
20:25:15 <drull95> i would learn coq, type theory will warp your mind
20:25:42 <Sgeo> You probably should learn a somewhat dynamic language at some point too, perhaps. A Lisp, or Smalltalk, or Python or Ruby. Others may disagree though
20:25:46 <cl1> why did they have to name the lanugage coq, it sounds so perverse
20:25:54 <Sgeo> Having flexibility to modify stuff at runtime is interesting though, I think.
20:26:26 <Sgeo> (Well, hmm, CL more than Scheme? I'm not sure, CL is janky in other ways, I think. Note that some or all of my impressions may be mistaken)
20:26:34 <JoeyA> "The word coq means "cock" (rooster) in French, and stems from a tradition of naming French research development tools with animal names."
20:26:39 <JoeyA> (Wikipedia)
20:26:39 <drull95> cl1, i think it's named after one of its creators, Thierry Coquand, or something like that
20:27:24 <shachaf> Sgeo: "strongly-typed" is close to meaningless.
20:27:27 <Cody_> cl1_: I see where your coming from
20:27:31 <drull95> whoohoo, had it right
20:27:40 <cl1> don't mind me, my mind lives in the gutter
20:28:05 <drull95> cl1, can you handle coq?
20:28:06 <Sgeo> So does everyone's, except for the people who named Coq, apparently.
20:28:08 <drull95> :P
20:28:16 <Eduard_Munteanu> shachaf: how so?
20:28:30 <shachaf> Eduard_Munteanu: Well, what does it mean?
20:28:31 <Cody_> I keep mentioning Python because you can do "functional programming" in the loose sense
20:28:37 <nand`> https://en.wikipedia.org/wiki/File:Coq_logo.png
20:28:39 <nand`> the logo doesn't help
20:28:44 <shachaf> Cody_: Python is very hostile to functional programming.
20:28:48 <nand`> I don't know why but that looks so... lewd
20:28:56 <Cody_> Can't you do lambdas?
20:28:57 <Sgeo> Ruby is a bit more convenient for functional programming, and Smalltalk more so
20:29:00 <cl1> its a rooster with a fro
20:29:01 <Eduard_Munteanu> shachaf: well, for one thing, implicit conversions and stuff like duck typing would make it *not* strongly-typed
20:29:02 <nand`> Cody_: ruby is nice for FRP
20:29:12 <Cody_> So many choices!
20:29:13 <jakky> yeah the coq logo looks like a coq
20:29:14 <Sgeo> Cody_, lambdas exist in Python, but are rather hideous
20:29:23 <shachaf> Eduard_Munteanu: That's not really a definition.
20:29:24 <companion_cube> but inner functions can replace them
20:29:34 <shachaf> Eduard_Munteanu: I don't even know what "strongly-typed" is a property of.
20:29:35 <companion_cube> (although the 'semantic' of closures is awful)
20:29:42 <shachaf> Is it something a language can be? A library can be?
20:29:44 <nand`> a lot of ruby's design patterns are based on chaining functions and passing functions to other functions
20:29:47 <Cody_> Down to Haskell, PHP, Ruby, and Python. Cross out the ones you don't like.
20:29:58 <nand`> eg. it prioritizes stuff like “map” or “each” over traditional loops and state
20:30:00 <Eduard_Munteanu> shachaf: or a type system, though it sounds a tad bit odd
20:30:01 <Sgeo> In Ruby, there's a special magic argument that takes a function
20:30:07 <Sgeo> Smalltalk's better in that respect
20:30:18 <Eduard_Munteanu> I guess there could be a more or less formal definition for that.
20:30:19 <cl1> i would cross off php
20:30:20 <shachaf> Eduard_Munteanu: That's part of "language", but sure.
20:30:26 <nand`> ruby is a nice intermediate language to give the perl/python crowd the “feel” of a functional language
20:30:30 <nand`> to see if they like how simple it makes things
20:30:42 <shachaf> Eduard_Munteanu: Part of the issue is that everyone seems to have their own definitions of the term, and they disagree.
20:30:52 <Cody_> cl1_: Can Python/Ruby/Haskell all work with databases (MySQL)?
20:30:54 <Sgeo> Magic argument positions make me cry
20:30:57 <cl1> shachaf, i disagree
20:30:58 <shachaf> Is C strongly or weakly typed? Is Python?
20:31:04 <Eduard_Munteanu> shachaf: heh, as with "functional" ;)
20:31:05 * companion_cube likes list comprehensions in python
20:31:16 <companion_cube> shachaf: weakly typed
20:31:25 <companion_cube> implicit conversions (void*) everywhere
20:31:25 <shachaf> Eduard_Munteanu: Yes, that term is also pretty useless. But not as bad as "strong typing".
20:31:27 <ben> I'm trying to wrap my head around monad-control, is there some prose on it that goes deeper than the haddock blurbs?
20:31:30 <Sgeo> Although in Haskell, having a function that accepts an IO a as the last argument is kind of easier to deal with
20:31:44 <Cody_> Agredd
20:31:44 <Cody_> Agreed*
20:31:45 <shachaf> companion_cube: People will disagree with you, certainly.
20:31:49 * cl1 's disagree joke didn't get noticed
20:31:57 <ezyang> ben: Try searching haskell-cafe archives for monad-control, MonadCatchIO and monad-peel
20:32:02 <cl1> Cody_, yes yes and yes
20:32:06 <shachaf> Some people say that because 5 + '3' is 8 in JavaScript, JavaScript is weakly typed.
20:32:06 <ezyang> There have been a lot of iterations of the idea, and it's still pretty experimental.
20:32:10 <Eduard_Munteanu> shachaf: C would be stronglier typed than say PHP, I guess, though you probably can't quantify that notion.
20:32:21 <shachaf> But that's just the behaviour of the operator, not a property of the type system.
20:32:29 <ezyang> Maybe also MonadMorphIO
20:32:32 <ben> will do, cheers
20:32:34 <cl1> Cody_, are you wanting to learn something to get you a job, or to be a better programmer?
20:32:55 <Cody_> If being a better programmer will get me a "better" job, then yes
20:33:24 <Eduard_Munteanu> shachaf: but somewhere '3' becomes 3, no?
20:33:27 <ben> snoyman sure gets around
20:33:36 <Eduard_Munteanu> And not in the way 'read' does that.
20:34:02 <nand`> shachaf: I thought implicit conversions don't automatically make a type system “weak”, what I consider “weak typing” is if it's possible to write a polymorphic function that makes assumptions about its parameter's type other than what was given from the type signature;
20:34:06 <Sgeo> autoadd x y = read x + read y
20:34:24 <nand`> eg. in haskell, an f :: a -> a can't do anything specific with that a since it can't make assumptions about the t ype other than the fact that it's a type
20:34:25 <Sgeo> Wait, that doesn't work
20:34:30 <shachaf> Eduard_Munteanu: Sure, because + (if you think of it as a function, conceptually) is implemented along the lines of if (arg1.type == Num && arg2.type == String) { return numPlus(arg1 + stringToNum(arg2)) }
20:34:37 <Eduard_Munteanu> nand`: hm? What about ad-hoc polymorphism?
20:34:48 <nand`> Eduard_Munteanu: you mean like casting (void*) or interface{}s around?
20:34:49 <Cody_> cl1_: Which language is the best to work with databases?
20:35:01 <Eduard_Munteanu> nand`: no, C++ overloading
20:35:07 <ben> sql :)
20:35:07 <shachaf> nand`: So Python is weakly typed?
20:35:09 <nand`> I don't know much about C++, can't answer
20:35:18 <nand`> shachaf: I don't know much about python either
20:35:19 <cl1> Cody_, if you want to get a job, learn java or c# .. if you want to be a better programmer, i would say learn haskell
20:35:37 <Sgeo> C# is marginally better than Java as far as languages go
20:35:43 <Cody_> Really?
20:35:48 <Sgeo> C# has more functional programming features
20:36:03 <cl1> out of all the c# and java jobs, c# has 80% and java has 20%
20:36:05 <Eduard_Munteanu> I think ad-hoc polymorphism isn't as bad as some implicit conversions, really.
20:36:06 <nand`> C# is a vastly better language than Java and it comes with better documentation and a better standard library and an (arguably) better IDE, but in return for that it locks you down to a single dying platform
20:36:09 <nand`> so choose wisely
20:36:10 <cl1> and c# got generic right
20:36:31 <Cody_> Guess I better switch over sometime
20:36:33 <nand`> problem with C# is it's not as open as it should be
20:36:44 <nand`> it's a great language, but the only implementation worth speaking of is locked down by ms
20:36:53 <cl1> microsoft isn't going to die any time soon, they don't finance anything, so even a huge screw up wouldn't take the company down before they had a chance to recover
20:37:03 <cl1> c# has mono
20:37:11 <ben> they happily drop technologies as they go along
20:37:18 <Cody_> Did a quick job search on Indeed.com. Java came up with 78,000 jobs, c# had 36,000
20:37:28 <ben> mono still can't run most C# code people actually write
20:38:00 <Eduard_Munteanu> Cody_: that doesn't say much unless you also evaluate your competition :)
20:38:12 <cl1> Cody_, I work with recruiters all the time. They are telling me this information. job boards are notorius about having old and out of date listings that do not correspond to real market conditions
20:38:51 <Cody_> cl1_: So I'm guessing you do not like the TIOBE?
20:39:01 <ben> lol
20:39:11 <cl1> TIOBE?
20:39:22 --- mode: ChanServ set +o mauke
20:39:22 --- mode: mauke set +b *!*@pool-108-0-183-9.lsanca.fios.verizon.net
20:39:26 <Cody_> one moment
20:39:27 <shachaf> The last pageful of discussion -- other than what ezyang said -- belongs in #not-haskell
20:39:34 <Cody_> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
20:39:58 <shachaf> mauke: ?
20:40:15 <JoeyA> Is there a #not-haskell ?
20:40:23 <ion> #php
20:40:27 <JoeyA> lol
20:40:27 <Cody_> lol
20:40:27 <Eduard_Munteanu> JoeyA: #haskell-blah
20:40:28 <shachaf> JoeyA: Yes.
20:40:31 <shachaf> Eduard_Munteanu: NO
20:40:35 <Cody_> gchat
20:40:46 <Eduard_Munteanu> Oops :)
20:40:55 <companion_cube> there is no life outside #haskell
20:41:03 <Eduard_Munteanu> Though it's awfully silent at the moment.
20:41:09 <companion_cube> no one should ever need to do any else than reading #haskell
20:41:12 <shachaf> There's too much nonsense in here.
20:41:21 --- kick: ion_cannon was kicked by mauke (ban evasion)
20:41:38 <ezyang> Anyone have a copy of Voigtlander's "Asymptotic Improvement of computations over free monads" handy? I think there's a bug in one of the typeclass definitions but I'm not sure.
20:41:58 <Cody_> shachaf_: I enjoy the people on here.
20:42:09 <Cody_> cl1_: Did you see my link?
20:42:19 <nand`> While we're talking about languages that might make you a better programmer, anybody else like (google's) go?
20:42:19 <shachaf> ezyang++ # Haskell
20:42:27 <Cody_> or Dart?
20:42:30 <nand`> helped me think about asynchronous design patterns
20:42:34 <shachaf> I don't think we're talking about that.
20:42:39 <nand`> and concurrency
20:42:45 <ezyang> Yeah, --> #haskell-blah folks!
20:42:57 <shachaf> :-(
20:43:12 <nand`> shachaf: ah, apologies, wasn't reading the chat properly (I'm quite busy unfortunately)
20:43:21 --- mode: mauke set -o mauke
20:43:49 <shachaf> ezyang: I haven't read it.
20:43:57 <Cody_> shachaf_: What was your first language
20:44:10 <Cody_> Please don't tell me haskell
20:44:15 <shachaf> Should I read it? What's the bug (or are you hoping for someone else to verify it by finding it independently? :-) )?
20:44:43 <shachaf> Cody_: English, I think. At any rate it's off-topic in here.
20:44:48 * shachaf hates to be the off-topic police.
20:45:16 <ezyang> shachaf: Look at page 8, instance definition of FreeLike for f (C m). I think there also needs to be a functor instance for f.
20:46:04 <ezyang> Or maybe a monad instance for m? I don't want to look at their code too carefully since the point of this exercise was to re-derive the code myself :-)
20:47:04 <ezyang> oh no, I'm just silly
20:47:15 * shachaf is still gathering context.
20:47:17 <ezyang> Sorry, you automatically get those instances. Keep calm and carry on :-)
20:47:20 <shachaf> I think I should just read the paper. :-)
20:47:40 <shachaf> Also, yes, what you said. They're superclass constraints.
20:52:58 <Platehead> YOU COME TO PEACE.IGNORELIST.COM 6667 OR NZCHATTER.NET FOR A GOOD CHAT ;]
20:55:52 <blbrown_win3> anyone use matplotlib,  is there a way to use '1000' as opposed to'10^3'
20:57:26 <elliott> The http://hackage.haskell.org/trac/hackage/raw-attachment/ticket/872/ghc7.diff link from the GHC 7.2 instructions from the topic is 403'd -- is there another source for the ghc7.diff file?
20:57:41 <blbrown_win3> wrong channel
21:00:43 <elliott> Oh, even http://hackage.haskell.org/trac/hackage/ticket/872 is 403; is there a temporary outage?
21:01:23 <shachaf> elliott: Either that or a permanent outage.
21:01:31 <elliott> Well, yes.
21:01:34 <nus> it's down for maintenance
21:01:41 <elliott> nus: Thanks.
21:01:46 <nus> spammers
21:01:48 <tommd> @seen dons
21:01:48 <lambdabot> Unknown command, try @list
21:01:53 <tommd> preflex: seen dons
21:01:53 <preflex>  dons was last seen on #haskell 5 days, 12 hours, 11 minutes and 13 seconds ago, saying: yy.mm.dd
21:01:56 <aavogt> elliott: I got some spam on all the tickets I've been subscribed to
21:02:03 <elliott> Ah.
21:02:15 <elliott> We,l
21:02:24 <elliott> Well, google cache has the trac html version of the file :p
21:02:32 <elliott> I'll just reconstruct it from that.
21:11:46 <Sgeo> If I were to implement a 2d grid in terms of a cell containing, say, 8 other cells (its neighbors), then mapping over them would mean redoing the mapped function each time I visited a cell, even if I backtracked, right?
21:12:34 <Sgeo> What O would that be?
21:12:40 <elliott> Sgeo: You want a zipper.
21:13:14 <Sgeo> What do zippers of 2d grids look like?
21:13:22 <djanatyn> I can have string literals in my pattern matches, yeah?
21:13:23 <elliott> Depends what your 2d grid looks like.
21:13:26 <elliott> djanatyn: Yes.
21:13:28 <djanatyn> like ("foo":xs)
21:13:30 <djanatyn> Cool.
21:13:33 <Sgeo> Say, a GoL grid
21:13:48 <elliott> Sgeo: I mean what data structure you use.
21:13:57 <elliott> It'll look different if you use a quad-tree or a k-d tree or whatever.
21:14:08 <elliott> But you can mechanically derive the zipper once you figure out what your top-level structure looks like.
21:14:23 <Sgeo> I guess just making it out of cells that point to cells is a bad idea?
21:14:39 <elliott> Yes.
21:16:36 <Sgeo> How about making it out of cells that contain the number of times they've been mapped over, or would that violate a functor law?
21:16:38 <JoeyA> In Conway's Game Of Life, every cell in a generation can be defined in terms of cells of a previous generation.
21:17:14 <elliott> Sgeo: I don't know how you think that would simplify things, but yes, it would violate the functor laws.
21:17:43 <Sgeo> elliott, a bit of mutability crept into my thoughts, I think
21:18:15 <Eduard_Munteanu> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html   and see the comments
21:18:48 * elliott was considering linking that, but too lazy to.
21:20:23 <Eduard_Munteanu> You could just use a 2D array and wrap this stuff in some helpers.
21:20:48 <Sgeo> 2d arrays can't be infinite, can they be?
21:22:07 <dolio> Can 1D arrays be infinite?
21:28:15 * hackagebot repa-devil 0.1.2 - Support for image reading and writing of Repa arrays  http://hackage.haskell.org/package/repa-devil-0.1.2 (ThomasDuBuisson)
21:31:48 <augur> Philippa, and anyoone interested in non-von-neuman architectures: http://pastebin.com/DPvpgnL8
21:31:50 <mauke> The paste DPvpgnL8 has been copied to http://hpaste.org/56171
21:32:03 <Sgeo> dolio, I didn't think so?
21:32:22 <dolio> Well then, 2D arrays don't have much chance either.
21:33:02 <Sgeo> I think I have a use-case for lazy IO for this
21:33:14 <Sgeo> If I want to simulate running a randomly generated infinite GoL grid...
21:38:48 <Sgeo> Actually, I may not need lazy IO for that
21:39:08 * Sgeo needs to think about that more
21:39:21 --- mode: ChanServ set +o mauke
21:39:21 --- mode: mauke set -b *!*@pool-108-0-183-9.lsanca.fios.verizon.net
21:39:23 <elliott> You don't need lazy IO for anything.
21:40:26 <augur> mauke: fine :|
21:40:32 <augur> meany
21:41:21 --- mode: mauke set -o mauke
21:43:08 <Eduard_Munteanu> mauke: who was that?
21:48:23 <ezyang> Hyo folks. I'm having trouble developing an operational intuition for why the codensity transformation increases efficiency.
21:49:20 <dolio> It avoids re-traversing trees to get down to the leaves.
21:49:26 <ezyang> As far as I can tell, all I have is a tenuous connection to Hughes lists, which isn't that good since Hughes lists are not monads that benefit from this translation
21:49:40 <ezyang> dolio: Right. What I'm having difficult seeing is why the CPS transformed version avoids this.
21:49:51 <ezyang> *difficulty
21:50:59 <ezyang> I even hand-derived the bind implementation!
21:51:08 <ezyang> but I did it mostly by appealing to the types
21:56:58 <mm_freak> Sgeo: 2D array-like structures can be infinite, but you will get O(log n) lookup
21:57:08 <mm_freak> Map (Int, Int) (Maybe a)
21:57:12 <dolio> ezyang: Look at the normal form of both '(m >>= f) >>= g' and 'm >>= \x -> f x >>= g'.
21:57:31 <mm_freak> uh, not Maybe
21:57:39 <ezyang> OK, that sounds helpful
21:57:45 <dolio> The first one traverses m to replace the leaves using f, then traverses that to replace with g.
21:57:53 <mm_freak> Sgeo: another good approximation of this is the function-based Store comonad
21:58:40 <dolio> The latter traverses m to replace with f, but while it's there it substitutes into f x using g.
21:58:43 <rwbarton> are Hughes lists difference lists?
21:58:56 <dolio> However, for codensity, they reduce to identical expressions.
21:58:56 <ezyang> rwbarton: Yep.
22:01:03 <ezyang> dolio: I don't think it's quite precise to refer to it as the 'normal form'; forcing the first constructor will always be constant time.
22:01:12 <ezyang> You only see the blowup if you traverse down to a leaf.
22:01:41 <dolio> I mean the normal form of those three expressions for abstract m, f and g.
22:02:06 <dolio> Make it '\m f g -> (m >>= f) >>= g' and the same for the other, for instance.
22:02:57 <dolio> They both reduce to \m f g k -> m (\x -> f x (\y -> g y k))
22:03:39 <ezyang> Erm, that's for the abstracted case, right?
22:03:51 <dolio> yes.
22:06:31 <cl1> @pl \xs -> map head xs : transpose (map tail xs)
22:06:32 <lambdabot> ap ((:) . map head) (transpose . map tail)
22:06:39 <dolio> So based on that, it's not a stretch (I think) to expect (m >>= f) >>= g and m >>= \x -> f x >>= g to perform very similarly.
22:06:42 <cl1> really?
22:06:43 <dolio> Either both good, or both bad.
22:07:06 <elliott> cl1: That's pretty good for @pl output.
22:07:37 <cl1> elliott, I ended up with more parenthesis than i started with
22:07:38 <cl1> lol
22:07:45 <ion> That’s not surprising.
22:07:47 <elliott> cl1: (:) . map head <*> transpose . map tail
22:07:50 <mm_freak> :t liftA2 (:) (map head) (transpose . mail tail)
22:07:51 <lambdabot> Not in scope: `mail'
22:07:57 <mm_freak> :t liftA2 (:) (map head) (transpose . map tail)
22:07:58 <lambdabot> forall a. [[a]] -> [[a]]
22:08:00 <mm_freak> mail tail?  lol
22:08:06 <elliott> You should really not be using something like "map head" though :(
22:08:30 <cl1> i'm not i have safeHead and safeTail
22:08:48 <cl1> safeHead xs = if null xs then ' ' else head xs
22:08:57 <elliott> Please tell me you're joking!
22:09:02 <cl1> and safeTail xs = if null xs then [] else tail xs
22:09:10 <elliott> You're not joking. :(
22:09:16 <mm_freak> cl1: the latter is just "drop 1", btw
22:09:35 <cl1> no i'm not, it works great, very specific to what i'm doing
22:09:54 <elliott> You should really not be using a meaningless placeholder like ' '; corrupting data is less safe than crashing the program when a problem appears... unless ' ' has some special meaning to your program, in which case it probably shouldn't be called safeHead.
22:09:56 <mm_freak> cl1: perhaps you shouldn't be using lists there
22:10:04 * elliott agrees with mm_freak
22:10:08 <elliott> Why not e.g. end every list with (repeat ' ')?
22:10:16 <elliott> btw, safeHead = fromMaybe ' ' . listToMaybe
22:10:20 <cl1> elliott, for your information it is not meaningless, i specifically need space when the text runs out
22:10:34 <mm_freak> elliott: you may be confused by the name "safeHead"
22:10:50 <dolio> ezyang: Another possible avenue is that things with type Codensity m a are waiting for "what do I do at the leaves?"
22:10:52 <mm_freak> it's a misleading name, where his specific application might actually require "headOrSpace"
22:10:52 <elliott> Yeah, I think it's just a bad name rather than a bad function.
22:11:34 <dolio> And m >>= f is, when we're told what to do at the leaves, go to the leaves of m, and do f, then do whatever we were told.
22:11:40 <ion> I like “listToMaybe . take 1” to make the intent explicit.
22:12:08 <dolio> On the leaves of the f-expanded leaf.
22:12:11 <elliott> ion: foo = listToMaybe . take 1... foo = listToMaybe :P
22:12:24 <cl1> omg its three lines of code, like you can't tell what the context is for those names from the line above their declaration, sheesh
22:12:31 <ion> elliott: Yes, they’re equivalent.
22:12:40 <ion> from the point of view of the machine.
22:12:40 <cl1> fricken grammar nazis
22:12:51 * elliott made no complaint about grammar.
22:13:02 <elliott> I merely suggested that a better name could make your program more clear.
22:13:16 <elliott> And that another data representation might be better suited to the task for what you're doing.
22:13:17 <mm_freak> cl1: always look on the bright side of life =)
22:13:23 <cl1> transpose' xs =
22:13:23 <cl1>     map safeHead xs : transpose' (map safeTail xs)
22:13:23 <cl1>     where safeHead xs = if null xs then ' ' else head xs
22:13:23 <cl1>           safeTail xs = if null xs then [] else tail xs
22:13:35 <ezyang> dolio: Yeah, that intuition is Ok.
22:13:42 <cl1> there is the code, in all its haskelly uglyness
22:13:50 <ezyang> There's a gap there, which is that when I do multiple binds, these compose in constant time.
22:14:11 <davidL> w 11
22:14:11 <mm_freak> cl1: not being a nazi here, but you really don't want lists…  not because of the unsafety, but other data structures may make your life easier there
22:14:19 <mm_freak> like arrays or vectors
22:14:33 * elliott eagerly awaits the day every comment on IRC must be prefixed with "not being a nazi here, but"
22:14:36 <cl1> mm_freak, well i'm working on a tutorial using what i've learned so far
22:14:55 <cl1> elliott, its all good
22:14:56 <mm_freak> cl1: ah, that's different
22:14:59 <elliott> :)
22:15:55 <mm_freak> cl1: get used to comments like that, since haskell is all about safety ;)
22:16:29 <dolio> ezyang: Maybe the first argument is more convincing, then.
22:16:30 <mm_freak> in an idealized world, you wouldn't and perhaps even couldn't have 'head' the way it's defined
22:16:57 <elliott> We should have a site where you can vote on and add Prelude definitions, and every release the Prelude gets replaced with the top 100.
22:16:59 <mm_freak> and a proper type for a function named "safeHead" would be:  [a] -> Maybe a
22:17:02 <dolio> (\m f g -> (m >>= f) >>= g) = (\m f g -> m >>= \x -> f x >>= g), not by extensionality or induction, but by beta reduction.
22:17:12 <elliott> Then we could trade in head for all those convenience operators everyone wants.
22:17:18 <mm_freak> if you found safeHead :: String -> Char in a library, you would be VERY confused as a haskell programmer =)
22:17:35 <dolio> And inlining of definitions, I suppose.
22:17:41 <elliott> data Char = Nope | '\0' | '\1' | ...
22:18:10 <ezyang> Maybe I should just stare a little bit at Hughes lists.
22:18:12 <Sgeo> Clearly, '\0' is never a valid character, so we should use it to mean that
22:18:24 <Eduard_Munteanu> Heh.
22:19:16 <elliott> Sgeo: Those who castrate Char are doomed to become UNIX!
22:19:16 <mm_freak> yeah, who would ever want a null byte in a string?  ok, there are the mailcious attackers, but who else?
22:19:18 <cl1> mm_freak, i'm not upset, i should have added <sarcasm> tags around my comment
22:19:31 <rwbarton> safeHead str = head $ str ++ " "
22:19:43 <elliott> Nobody? No? Oh well.
22:19:55 <mauke> ITYM head $ str ++ "\0"
22:20:05 <elliott> head $ str ++ '\42'
22:20:14 <cl1> mm_freak, why would array of vector be better in that case (i don't know how to use either in haskell yet)
22:20:36 * Sgeo blinks at elliott's code
22:20:37 <mm_freak> cl1: array /or/ vector…  but don't bother now, go through the tutorial
22:20:47 <ion> safeHead xs = head (xs ++ def)
22:20:50 <cl1> s/of/or/
22:21:01 <ion> safeHead xs = head (xs ++ [def])
22:21:02 <ion> :-P
22:21:13 <cl1> safeHead = (* use a rubber *)
22:21:19 <elliott> Sgeo: Wait, which code?
22:21:22 <mm_freak> cl1: Vector has some useful functionality
22:21:27 <Sgeo> <elliott> head $ str ++ '\42'
22:21:37 <elliott> Oh.
22:21:39 <cl1> mm_freak, i see
22:21:39 <elliott> s/'/"/g
22:21:58 <elliott> mm_freak: I think cl1 might have meant they were writing a tutorial based on what they knew so far; at least that's how I parsed it.
22:21:59 <elliott> I may be wrong.
22:22:03 <ezyang> dolio: Hmm. Would it be accurate to say that the abstract encoding "builds" the list from leaves to root?
22:22:09 <mm_freak> cl1: not as a data structure, but in terms of predefined functions and you have some possibilities you don't get easily with lists
22:22:20 <cl1> mm_freak, that makes sense
22:22:34 <mm_freak> like the 'generate' function
22:22:36 <cl1> elliott, :P i'm learning haskell
22:22:56 <ezyang> That is to say, it does the substitution on the innermost level, and then takes that result and performs the substitution again for the "inner" lambda (which is the left-side of the list, or the higher up nodes of the tree)
22:22:57 <dolio> Encoding of what?
22:23:07 <Sgeo> Doesn't preclude writing a tutorial for yourself to get a better understanding (please don't assume it will be useful for anyone else though_
22:23:08 <ezyang> dolio: Erm, leafy trees.
22:23:21 <ezyang> But I'm sort of drawing metaphors from both hughes lists and abstract leafy trees
22:23:37 <mm_freak> i don't think cl1 is /writing/ a tutorial
22:23:47 <cl1> that would be scary
22:23:53 * Sgeo goes to sleep no
22:23:54 <Sgeo> now
22:23:56 <cl1> at least one in haskell, c# a different story
22:24:05 <elliott> Write a Haskell tutorial in C#.
22:24:12 <cl1> elliott, i'm a grammar nazi when it comes to methods too at work
22:24:38 <cl1> elliott, haskell for c# programmers?
22:24:42 <mm_freak> cl1: anyway, when you write a function, its name should fit its type signature
22:24:53 <elliott> cl1: Well, you know how most Haskell tutorials are written in English?
22:25:02 <elliott> Replace the English part with C#. (Please don't.)
22:25:07 <mm_freak> if you read "headOrSpace :: String -> Char", i'd think that most programmers would understand what that function does
22:25:27 <cl1> yes you are correct headOrSpace is a MUCH better function name
22:25:49 <cl1> tailOrEmpty would have been better for the other one
22:25:58 <mm_freak> cl1: in haskell i frequently learn how to use a library only by reading the haddock docs, often only reading function names and their types
22:26:05 <mm_freak> that's just drop 1
22:26:08 <mm_freak> > drop 1 []
22:26:08 <lambdabot>   []
22:26:17 <ezyang> dolio: OK, let me be concrete.
22:26:22 <ezyang> Consider Hughes lists
22:26:52 <cl1> transpose' xs =
22:26:52 <cl1>     map headOrSpace xs : transpose' (map (drop 1 xs))
22:26:53 <cl1>     where headOrSpace xs = if null xs then ' ' else head xs
22:27:01 <cl1> elliott, mm_freak : better?
22:27:09 <dolio> [a] -> [a]?
22:27:09 <mm_freak> a lot =)
22:27:22 <mm_freak> [[a]] -> [[a]]
22:27:27 <ezyang> dolio: Yeah.
22:27:32 <dolio> Okay.
22:27:37 <elliott> transpose' = map (fromMaybe ' ' . listToMaybe) <*>  transpose' . map . drop 1
22:27:41 <elliott> oh, that doesn't handle the nil case :)
22:27:42 <ezyang> So, if I evaluate ((a ++ b) ++ c) z
22:28:06 <ezyang> First I need to evaluate the left argument, so it goes to (\z' -> (a ++ b) (c z')) z
22:28:16 <ezyang> Then I can apply: (a ++ b) (c z)
22:28:20 <ezyang> The rest follows by induction.
22:28:27 <mm_freak> elliott: i hope you don't seriously suggest that this is better than the pointy version ;)
22:28:28 <cl1> transpose' ([]:_) = []
22:28:39 <elliott> mm_freak: If not for the null case, I would actually
22:28:52 <mm_freak> at least use liftA2
22:29:15 <mm_freak> liftA2 (:) (map headOrSpace) (transpose' . map . drop 1)
22:29:18 <cl1> elliott, does <*> use the Maybe monad?
22:29:21 <ezyang> It now seems clear: upon the concretization of a Hughes list ([a] -> [a]) -> [a], we build the list backwards up.
22:29:23 <cl1> :T fromMaybe
22:29:27 <elliott> cl1: (<*>) is the applicative operator
22:29:30 <cl1> @t fromMaybe
22:29:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:29:33 <elliott> cl1: in this case, it's the (a ->) Applicative
22:29:49 <elliott> mm_freak: Are you sure that does the same thing?
22:29:49 <cl1> elliott, over my head
22:29:55 <cl1> in due time
22:30:02 <elliott> cl1: (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
22:30:06 <mm_freak> elliott: when you have f (a x) (b x), you can write that as either f <$> a <*> b or as liftA2 f a b
22:30:12 <mm_freak> uhm
22:30:13 <elliott> mm_freak: yes, but it's not <$>
22:30:15 <elliott> it's <*>
22:30:16 <elliott> f <*> x
22:30:26 <mm_freak> yeah, i meant cl1 anyway =)
22:30:32 <elliott> oh :)
22:30:46 <rwbarton> @let transpose' = map (fromMaybe ' ' . listToMaybe) <*>  transpose' . map . drop 1 in transpose' ["abc", "def", "ghi"]
22:30:46 <lambdabot>   Parse error: in
22:30:51 <rwbarton> > let transpose' = map (fromMaybe ' ' . listToMaybe) <*>  transpose' . map . drop 1 in transpose' ["abc", "def", "ghi"]
22:30:51 <lambdabot>   Couldn't match expected type `a -> b'
22:30:52 <lambdabot>         against inferred type `[GHC.T...
22:31:13 <rwbarton> don't you want a (:) in there somewhere?
22:31:22 <elliott> ah. of course
22:31:25 <rwbarton> > let transpose' = map (fromMaybe ' ' . listToMaybe) <*>  transpose' . map . drop 1 in transpose' ["abc", "def", "ghi"]
22:31:26 <lambdabot>   Couldn't match expected type `a -> b'
22:31:26 <lambdabot>         against inferred type `[GHC.T...
22:31:28 <rwbarton> oops
22:31:32 <ezyang> Hugh, I wonder if Hughes lists are an appropriate Yoneda encoding of some data type.
22:31:32 <rwbarton> :t let transpose' = map (fromMaybe ' ' . listToMaybe) <*>  transpose' . map . drop 1 in transpose'
22:31:33 <lambdabot>     Couldn't match expected type `a -> b'
22:31:33 <lambdabot>            against inferred type `[Char]'
22:31:33 <lambdabot>     Probable cause: `map' is applied to too many arguments
22:31:34 <mm_freak> yeah, that's the ((:) <$>) ;)
22:31:36 <dolio> ezyang: ((m >>= f) >>= g) k = (\k -> (m >>= f) (\x -> g x k)) k = (m >>= f) (\x -> g x k)
22:31:50 <mm_freak> cl1: when you have f (a x) (b x), you can write that as either f <$> a <*> b or as liftA2 f a b
22:32:00 <elliott> :t let transpose' = (:) <$> map (fromMaybe ' ' . listToMaybe) <*> transpose' . map . drop 1 in transpose'
22:32:01 <lambdabot>     Couldn't match expected type `a -> b'
22:32:01 <lambdabot>            against inferred type `[[Char]]'
22:32:01 <lambdabot>     In the second argument of `(.)', namely `drop 1'
22:32:06 <elliott> Thought so.
22:32:20 <elliott> :t let transpose' = (:) <$> map (fromMaybe ' ' . listToMaybe) <*> transpose' . map (drop 1) in transpose'
22:32:21 <lambdabot> [[Char]] -> [[Char]]
22:32:24 <elliott> There we go, perfect! :)
22:32:32 <ezyang> dolio: Yeah, that's the analogous situation.
22:32:41 <ezyang> The confusion cleared up when I manually applied to the rules for lazy evaluation.
22:32:42 <mm_freak> perfect?  i found that one terribly ugly ;)
22:33:02 <rwbarton> it's a lot easier to read with the (:) at least :P
22:33:02 <dolio> I'm not sure the lazy evaluation matters, though.
22:33:09 <elliott> mm_freak: foo = (:) <$> map (headOr ' ') <*> foo . map (drop 1)
22:33:23 <elliott> It's pretty good, given a nicer name than transpose' (I don't know what the function does) and a headOr function.
22:33:29 <ezyang> dolio: Ah yes, it doesn't.
22:33:34 <cl1> mm_freak, where do i have f (a x) (b x) in that code?
22:33:37 <ezyang> "Sorry, just evaluation rules"
22:33:37 <dolio> In practice, no one evaluates under binders.
22:33:48 <mm_freak> cl1: you have a x : b x
22:33:52 <ezyang> Evaluating under binders was precisely what was confusing me.
22:33:58 <cl1> ah
22:34:00 <mm_freak> cl1: which is (:) (a x) (b x)
22:34:06 <cl1> mm_freak,  (:) (a x) (b x)
22:34:10 <cl1> yes I see
22:34:13 <mm_freak> hence:  liftA2 (:) a b
22:34:24 <cl1> or (:) <$> a <*> b
22:34:33 <mm_freak> yeah, but that one makes me throw up =)
22:34:37 <cl1> lol
22:34:40 <ezyang> Hmm. data H a = [a]. Then the Yoneda encoding is data YH a = (forall r. (a -> r) -> [a]). Doesn't really look like Hughes lists, I guess.
22:34:45 * elliott thinks non-curried liftA2 is a shame, since generalising zipWith* to n lists was exactly the motivation for applicatives.
22:34:55 <cl1> its going to be a while before liftA2 seems normal
22:35:08 <ezyang> erm, that should be forall r. (a -> r) -> [r]
22:35:14 <mm_freak> cl1: you don't have to use it…  your original definition is fine
22:35:24 <mm_freak> cl1: applicative style just adds some composability to your code
22:35:39 <mm_freak> and it's not always something you want to do
22:35:45 <cl1> @pl \xs -> transpose' (map (drop 1 xs))
22:35:45 <lambdabot> transpose' . map . drop 1
22:35:53 <elliott> cl1: (map drop 1) xs
22:35:55 <elliott> is what you really want
22:35:58 <elliott> transpose' . map (drop 1)
22:36:01 <elliott> argh
22:36:08 <dolio> ezyang: Anyhow, instead of prepending to a list, Codensity is buliding up continuations 'bottom up', so to speak.
22:36:20 <dolio> I suppose.
22:36:38 <ezyang> dolio: That's only helpful after I have the evaluation picture in my head :-)
22:37:18 <dolio> The same thing happens when you Church encode things.
22:38:55 <dolio> Which is at least one reason why Logic(T) is better than [] for doing searching.
22:39:06 <dolio> Plus any optimizations GHC does better on functions than on lists.
22:40:01 <cl1> mm_freak, what benefit would i get from adding composability to my code?
22:41:07 <mm_freak> cl1: depends on the code you are writing…  if you writing an application, you get the benefit that it becomes easier to change it later
22:41:35 <mm_freak> when you write a library or an abstraction, the user gets to build up things by composition
22:41:47 <mm_freak> composition is what haskell is all about
22:41:52 <dolio> Amusingly, when I was working through this stuff with Ed, it made me realize that the "Asymptotic Improvement of Computations over Free Monads" is wrong.
22:42:23 <dolio> Because using the Church encoding of the free monad data type is still the free monad, but it has the good asymptotics.
22:42:37 <cl1> so composition makes your code easier to maintain
22:42:49 <mm_freak> and to write
22:42:52 <dolio> Er, the title is wrong.
22:42:58 <mm_freak> it helps looking at things in isolation
22:43:06 <cl1> but not to read when you are a n00b
22:43:28 <mm_freak> cl1: that's mostly true for programmers coming from other languages
22:43:41 <mm_freak> a programming newbie has a much easier time understanding haskell in my experience
22:43:47 <shachaf> Aw, #haskell was having an interesting discussion just when I was gone.
22:44:31 <mm_freak> shachaf: you know #haskell…  just name the issue and you can take part in the discussion ;)
22:46:02 <rwbarton> mm_freak, do you think it is easier for a newcomer to haskell to read "f = liftA2 (:) a b" than "f x = a x : b x"
22:46:21 <mm_freak> rwbarton: no
22:46:51 <mm_freak> rwbarton: but it's easy to explain the (e ->)-specific definition of liftA2
22:47:40 <mm_freak> liftA2 f a b x = a x `f` b x
22:48:12 <mm_freak> i wonder why that one is not just called zipWith2
22:50:32 <cl1> that last bit of code was the last exercise for that section, i get to start on how to think about loops
22:51:07 <cl1> i hardly ever write loops anymore in c# i usually use linq operators
22:51:24 * cl1 tries to stay on topic but fails once again
22:54:42 <keep_learning> hello all
22:55:54 <keep_learning> I have a string which i have to break list of strings  at comma (,) . The best  i can think of break ( ==',' ) string
22:56:06 <mauke> Data.List.Split
22:57:00 <keep_learning> :t split
22:57:01 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
22:57:04 <ddarius> @hackage split
22:57:04 <lambdabot> http://hackage.haskell.org/package/split
22:57:57 <keep_learning> make , ddarius thank you
23:03:15 <ddarius> mm_freak: Becauses liftA2 doesn't zip.
23:26:17 <mm_freak> cl1: in haskell you would, for example, compose list processing functions
23:28:38 <elisa87> Help Stanford research and win an iPad2
23:28:38 <elisa87> http://labs.stanford.edu/ipad/6b3dd886
23:29:04 <Jafet> Why do research groups like to give away trendy Apple products
23:29:16 <Jafet> Seems like an international phenomenon
23:30:31 <elisa87> because they need audience for testing their social networks!!
23:30:35 <elisa87> it worths it
23:30:52 <elisa87> why did you say seems like an inter....
23:30:53 <elisa87> ?
23:33:25 <arw> hu? help stanford from somebody from *.wisc.edu?
23:34:20 <Jafet> Maybe the test subjects who invites the most test subjects wins the ipad2.
23:34:42 <Jafet> Social networking
23:39:32 <ddarius> "Take iSurvey and win a Windows Mobile phone."
23:43:25 <arw> well. windows mobile would really only select subjects who are used to pain...
23:44:49 <xil> hi. I need to parse a string into a datatype I made. Does anyone know a resource for techniques of parsing? Like how do programming languages parse code?
23:45:04 <dominikh> "We map that function over a list of values and then we filter the resulting list out for the results that satisfy our search. Thanks to Haskell's laziness, even if you map something over a list several times and filter it several times, it will only pass over the list once." ← is that really true?
23:45:25 <aweis> ^ woah what?
23:45:40 <mm_freak> xil: search for parsec
23:45:41 <shachaf> dominikh: It's not true "thanks to Haskell's laziness"
23:45:47 <dominikh> (that quote is from learn you a haskell)
23:45:56 <shachaf> It's true due to other optimizations that have to do with laziness.
23:46:39 <arw> dominikh: similar to loop fusion in imperative languages you can fuse folds or maps.
23:46:42 <ddarius> @google parsing theory
23:46:43 <lambdabot> http://en.wikipedia.org/wiki/Parsing
23:46:43 <lambdabot> Title: Parsing - Wikipedia, the free encyclopedia
23:46:48 <mm_freak> actually it is true
23:46:49 <ddarius> Damn you Wikipedia.
23:47:01 <mm_freak> a simple proof is that you can do this for infinite lists
23:47:04 <ddarius> Parsec doesn't teach you parsing theory.  It assumes you already know.
23:47:05 <xil> shachaf: but it's also not perfect, in the sense that it doesn't always work right? I saw something about an addon to Haskell for better stream handling for things like complex multiple calls to map
23:47:30 <mm_freak> the other optimizations try to remove as much of the list structure itself as possible
23:47:36 <shachaf> xil: Yes, it doesn't always work.
23:47:41 <mm_freak> but they don't reduce the number of iterations
23:48:15 <ddarius> mm_freak: It's the number of passes, which can well reduce.
23:48:41 <ddarius> But no, laziness won't change how many passes you make over a data structure, it will just cause them to be interleaved rather than sequential.
23:48:51 <mm_freak> it's the number of destruction/reconstruction pairs that reduces, i'd say
23:48:59 <mm_freak> not sure if you want to call them passes, but you might
23:49:58 <xil> mm_freak: wow I think parsec is perfect. I just need to parse the most primitive form of a regular expression. Looks like parsec could do that perfectly. This is awesome!
23:50:26 <mm_freak> xil: if the grammar is regular, parsec might be overkill, but it's not wrong to use it anyway
23:50:53 <arw> the real reason why it works is imho not laziness but purity. converting (map f $ map g) to (map f.g) only works because the executions of f and g are independent except for the parameter that is passed.
23:51:29 <ddarius> The grammar for regular expressions is not regular.
23:51:57 <xil> ddarius: I was thinking that
23:52:02 <ddarius> arw: Those two expressions mean dramatically different things and neither means map f . map g.
23:52:54 <mm_freak> oh, you mean you want to parse the regular expression itself?
23:53:17 <ion> xil: See also Trifecta, edwardk’s nice alternative to Parsec et al.
23:55:22 <shachaf> What's edwardk doing these days?
23:55:45 <mm_freak> writing the next library to fulfill his evil plan to take over the world
23:56:00 <shachaf> @brain
23:56:01 <lambdabot> Umm, I think so, Brain, but what if the chicken won't wear the nylons?
23:56:12 <arw> ddarius: really? both should apply f, then g to each element, shouldn't they?
23:56:25 <mm_freak> arw: map f $ map g = map f (map g)
23:56:36 <mm_freak> (map f . map g) xs = map f (map g xs)
23:56:50 <ddarius> :t \f g -> map f $ map g
23:56:50 <lambdabot>     Couldn't match expected type `[a]'
23:56:51 <lambdabot>            against inferred type `[a1] -> [b]'
23:56:51 <lambdabot>     In the second argument of `($)', namely `map g'
23:56:55 <ddarius> :t \f g -> map f . g
23:56:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f [a] -> f [b]
23:56:56 <arw> ah, right. yes
23:56:59 <ddarius> :t \f g -> map f . map g
23:57:00 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> [a1] -> [b]
23:57:47 <arw> my bad, sloppy use of misleading and wrong syntax.
