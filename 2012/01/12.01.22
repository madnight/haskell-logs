00:29:36 <kuznero> Hi All!
00:58:29 <Ralith> How is it that + :: Num a => a -> a -> a can accept arguments of different types, such as 1.5 + 1?
01:00:00 <elliott> it can't
01:00:06 <elliott> in (1.5 + 1), both arguments have the same type
01:00:10 <elliott> probably, they're both Doubles
01:00:26 <elliott> in Haskell, an integer literal like that can have /any/ numeric type
01:00:31 <elliott> (specifically, any instance of Num)
01:00:41 <elliott> something like 1.5 can be any instance of Fractional
01:01:03 <Ralith> ah, so literal types are kind of fuzzy?
01:01:15 <elliott> :t 42
01:01:16 <lambdabot> forall t. (Num t) => t
01:01:19 <elliott> not fuzzy, just overloaded :)
01:01:25 <elliott> 42 specifically means fromInteger (42::Integer)
01:01:35 <Ralith> hah.
01:01:43 <elliott> 0.5 means fromRational (1%2)
01:01:52 <Ralith> that's clever; thanks.
01:02:00 <elliott> :)
01:07:11 <Ralith> elliott: hm, so how is the type of (1.5 + 1) inferred?
01:07:25 <elliott> Ralith: well, the first argument is (Fractional a) => a
01:07:28 <elliott> the latter is (Num a) => a
01:07:39 <elliott> they have to be the same a, and Num is a superclass of Fractional, and the result type is the same as the two arguments
01:07:47 <elliott> so the result is inferred as (Fractional a) => a
01:07:55 <Ralith> and yet
01:07:56 <elliott> it's then instantiated to Double by the defaulting mechanism
01:08:03 <Ralith> ah.
01:08:06 <Ralith> what's that?
01:08:14 <vikramverma> The defaulting mechanism?
01:08:24 <elliott> Ralith: basically, if there's an unresolved numeric overload at a "top level" like that, it tries Integer and then Double :P
01:08:32 <elliott> (you can override which types it tries locally, but nobody bothers)
01:08:38 <elliott> it'd be better if it worked for every typeclass
01:08:49 <elliott> but it doesn't actually come up all that often in practice; it's mostly useful in GHCi and the like
01:08:55 <Ralith> has anyone written up a generalization of this mechanism?
01:08:57 <elliott> since you usually use explicit type signatures in actual source files
01:09:29 <elliott> Ralith: you'd just add a typeclass name to the "default" declaration... but probably nobody has bothered to implement it anywhere
01:09:49 <Ralith> the "default" declaration?
01:10:00 <elliott> <elliott> (you can override which types it tries locally, but nobody bothers)
01:10:06 <elliott> it's just default (type, type, type)
01:10:16 <Ralith> I'm afraid you've lost me :/
01:10:20 <elliott> :P
01:10:21 <elliott> you asked
01:10:37 <elliott> you can, in a Haskell file, override the list of types considered for numeric defaulting
01:10:42 <Ralith> right, I got that
01:10:44 <elliott> it defaults to (Integer, Double)
01:10:45 <elliott> but you can say
01:10:50 <elliott> default (Rational) instead or w/e I think
01:10:57 <elliott> I've never actually used it :P
01:11:08 <Ralith> oh, now I see.
01:11:28 <Ralith> thanks again!
01:11:49 <elliott> no problem :)
01:22:55 <Ralith> now that I think of it, that explains the (apparently) strange type signatures ghci was giving me for literal numbers.
01:52:35 <Ngevd> Hello
02:13:05 <Ikaru> Good moring
02:13:16 <Ngevd> Hello
02:13:30 <Ikaru> I have a question
02:13:49 <Ngevd> I have an answer. Whether it matches your question is another matter entirely
02:13:53 <Ngevd> But go on
02:14:50 <Ikaru> in a expression `case x of alts` has the `x` a specific name?
02:18:30 <donri> Ikaru: it's what you're pattern matching against
02:20:15 <Ikaru> I saw the word "scrutinee" , it's the official name?
02:20:47 <donri> i've never seen it, but that doesn't say much
03:17:49 <Ke> ghc: unrecognised flags: -hide-all-packages -package mtl
03:17:56 <popx>  > (+) 1 2 4
03:18:09 <popx> > (+) 1 2 4
03:18:10 <lambdabot>   3
03:18:13 <Ke> how am I supposed to set these options for runhaskell
03:21:32 <Lemmih> Ke: runhaskell -hide-all-packages "-package mtl"
03:22:31 <ion> It’s also a good idea to use -- before the GHC flags just in case. runhaskell -- -hide-all-package '-package mtl' Foo.hs
03:23:41 <donri> preflex: seen hackagebot
03:23:42 <preflex>  hackagebot was last seen on #haskell 8 days, 13 hours, 52 minutes and 14 seconds ago, saying: * hackagebot statistics 0.10.1.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.1.0 (BryanOSullivan)
03:25:50 <Ke> I guess these "" and '' are not shebangable
03:26:05 <erus`> can i derive storable?
03:26:18 <erus`> and write binary data ?
03:26:25 <donri> shebang lines are interpreted as #!<executable> <single argument>
03:27:11 <ion> Yeah, #! is unfortunately quite restrictive.
03:28:24 <ion> Too bad there isn’t a standard helper to work around that either (to my knowledge). One that parses the single argument in sh style.
03:29:54 <rostayob> erus`: you can't derive storable
03:30:24 <rostayob> erus`: well probably for newtypes
03:31:11 <rostayob> with GeneralizedNewtypeDeriving
03:31:33 <mauke> or with TH
03:31:57 <rostayob> mhm... there are some arbitrary things in Storable, like alignment
03:32:45 <Liskni_si> I had a code somewhere which did it
03:32:56 <Liskni_si> it was old and ugly and untested, but I can find it
03:33:17 <rostayob> erus`: the thing is that most of the times Storable is used to work with C types, and in those cases you can't derive the instance
03:33:23 <Liskni_si> provided it's not been done elsewhere
03:33:49 <rostayob> erus`: why do you need a Storable instance?
03:34:13 <erus`> i needed to serialize some stuff a little while ago
03:34:24 <erus`> and show was too big
03:34:27 <rostayob> erus`: then Storable is not what you need. look at Binary
03:34:33 <rostayob> and possible cereal
03:34:37 <ion> cereal is nicer.
03:34:44 <rostayob> *possibly
03:34:46 <rostayob> yeah
03:35:00 <rostayob> erus`: those can be derived
03:35:24 <Liskni_si> hm, the problem I had with Binary was that it was too slow
03:35:36 <rostayob> Liskni_si: too slow doing what?
03:35:54 <Liskni_si> serializing and deserializing :-)
03:36:02 <Liskni_si> maybe it was the GC, I don't know
03:36:15 <Liskni_si> I was writing a state space generator for a model checker
03:36:54 <Liskni_si> and those states were quite small a mostly statically sized
03:36:55 <rostayob> Liskni_si: so wait you stored in memory and then got the bytestring from the pointer?
03:37:03 <Liskni_si> so Storable was logically much faster
03:38:01 <rostayob> Liskni_si: yeah but storable doesn't include "serializing" functions, so I guess that you mean storing in memory and then getting the ByteString with fromCString (or whatever that is) and then writing out the bytestring
03:38:21 <Liskni_si> well, the model checker was in C++, the generator was in Haskell compiled to .so, and I don't exactly remember what I stored where
03:38:24 <rostayob> i'm not sure why that method would be "logically faster"
03:38:29 <Liskni_si> but basically storing in memory was the goal
03:38:37 <rostayob> Liskni_si: yeah, so you weren't serializing
03:38:42 <Liskni_si> bytestring was the middlestep that probably made it slower
03:38:58 <rostayob> you were just passing data between Haskell and C, which is what Storable is useful for
03:39:11 <Liskni_si> well, nobody in C read it
03:39:27 <Liskni_si> I could just as well pass stable pointers to bytestrings
03:39:46 <Liskni_si> or, whatever :-)
03:40:14 <rostayob> mhm I'm not sure I understand what you were doing, but it's not the classical serializing use case :)
03:40:32 <Liskni_si> and in the end I wanted that blob to go over a network to another node and be "deserialized" (or whatever you call it)
03:40:36 <rostayob> my point is that you really shouldn't use Storable to store haskell data structures for future use
03:40:54 <Liskni_si> yeah, sure
03:41:20 <Liskni_si> but I did have a homegeneous cluster, and I wanted speed, so it looked like a good idea :-)
03:42:06 <rostayob> yeah maybe in your case it was
03:44:51 <donri> even better, safecopy adds versioned migrations to cereal
03:45:12 <rostayob> even better, acid-state gives you ACID
03:45:12 <donri> and acid-state adds state transactions
03:45:16 <rostayob> AH!
03:45:19 <donri> \o/
03:46:32 <ion> Oh, interesting. I wish Hackage had lists of reverse dependencies, i’d surely have noticed safecopy and acid-state before from cereal.
03:47:07 <rostayob> aka "The Lemmih trio"
03:48:59 <ion> SafeCopy would be useful for Erlang-style hot code upgrades.
03:50:01 <donri> acid-state is sorta about that
03:50:11 <donri> sorta.
03:50:12 <rostayob> donri: ?
03:50:19 <rostayob> where's the code swapping in acid-state?
03:50:26 <donri> sorta.
03:50:27 <rostayob> afaik you can't do what you do in erlang in haskell
03:50:42 <donri> it's more recovering from where you left off
03:50:47 <donri> which is different, but similar.
03:50:59 <rostayob> well...
03:51:12 <rostayob> i mean the cool thing about hot swapping is that the system never goes down
03:51:19 <donri> yea
03:51:32 <donri> doesn't cloud haskell or something aim to implement that?
03:51:44 <rostayob> I think so, never tried
04:02:20 <Chaze> :k Max
04:02:21 <lambdabot> Not in scope: type constructor or class `Max'
04:02:47 <ben> @hoogle addForeignPtrConcFinalizer
04:02:47 <lambdabot> No results found
04:03:20 <ben> that's a ghc extension? what's the conc stand for?
04:12:02 <cheater_> hi
04:23:12 <Razz> for the typeclassopedia exercise on monads (The free monad built from functor f) I've got the functor instance, but for the monad instance, do I assume f is still a functor or may I assume it is now a monad? Cause if I assume f is still a functor, I need some way to get the value out of the functor ...
04:26:53 <nand`> is (f :: a -> a -> a) associative if foldl (f) mempty = foldr (f) mempty for all inputs?
04:28:47 <mauke> did you mean: foldl f (mempty)
04:29:32 <mauke> > let mempty = var "mempty" in mempty + 1
04:29:33 <lambdabot>   1+mempty
04:30:08 <mauke> > let mempty = var "mempty" in foldl f mempty [a,b,c]
04:30:09 <lambdabot>   No instance for (SimpleReflect.FromExpr
04:30:09 <lambdabot>                     (Data.Number.Sy...
04:31:44 <Chaze> nand`: makes perfect sense, something you'd easily show inductively isnt it?
04:31:51 <mauke> hmm. is f mempty surjective?
04:35:09 <PatrickRobotham> f mempty is the identity function isn't it?
04:35:59 <mauke> PatrickRobotham: why?
04:36:34 <PatrickRobotham> Oh, sorry, f can be anything.
04:36:46 <PatrickRobotham> I was thinking of mconcat mempty
04:37:56 <Veinor> mappend mempty is id, yeah
04:38:03 <Chaze> @src Monoid
04:38:04 <lambdabot> class Monoid a where
04:38:04 <lambdabot>     mempty  :: a
04:38:04 <lambdabot>     mappend :: a -> a -> a
04:38:04 <lambdabot>     mconcat :: [a] -> a
04:38:23 <PatrickRobotham> Oh, whoops/
04:40:10 <ion> > a `mappend` b `mappend` mempty :: Expr -- Is Expr a monoid, too?
04:40:11 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
04:40:12 <lambdabot>    arising from a u...
04:42:52 <Chaze> is there some resource that explains how Monoids, Monads, etc. relate to common algebraic structures you learn in math lectures? like groups and rings?
04:43:03 <Chaze> they feel so closely related
04:43:45 <chu> How monads in Haskell relate to category theory, and then how category theory relates to algebra?
04:43:56 <Chaze> chu: yes
04:44:11 <PatrickRobotham> Chaze: Well monoids are an algebraic structure in their own right.
04:44:16 <chu> http://en.wikibooks.org/wiki/Haskell/Category_theory
04:44:21 <Veinor> i mean a monoid is a group that doesn't have inverses
04:44:27 <PatrickRobotham> Chaze: Monoids are groups without inverses.
04:44:34 <Veinor> (or, more properly, a group is a monoid with inverses)
04:44:43 <Chaze> good link!
04:46:19 <Chaze> so why is there no class definition for groups in haskell? aren't they of any practical use?
04:46:49 <Veinor> i guess in practice, nothing's shown up that's a group that isn't also something else
04:47:30 <Chaze> but groups are relevant to so many fields. like cryptography
04:47:43 <Chaze> oh, seems there is Algebra.Structures
04:48:00 <dschoepe> there's also: http://hackage.haskell.org/package/numeric-prelude-0.1.3.4
04:48:29 <dschoepe> or the current version of that, rahter.
04:49:19 <Chaze> so, what about functors and monads? they can't be seen as algebraic structures, can they?
04:50:49 <PatrickRobotham> Chaze: Functors are like Homomorphisms for categories.
04:51:31 <Chaze> so i see categories are special algebraic structures..
04:56:47 <ems> Does anyone know if there are more efficient ways to do arithmetic with rational numbers than the built in Ratio Integer?
04:57:06 <ems> my program is spending the majority of its computation time adding and multiplying rationals
04:57:26 <tulcod> ems: you could use floating point, but that's not exact
04:57:26 <abdulsattar> Can I measure the time taken by an expression in ghci without considering the time taken to print its value?
04:57:54 <tulcod> ems: theoretically you could do the integer calculations using the CPU's vector extensions, but i have no idea how taht'd work in haskell
04:58:28 <ems> I was looking at the source for Data.Ratio, here: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/src/GHC-Real.html#Ratio
04:58:47 <ems> and it looks like there are ways to improve it (at least for the purposes of my application)
04:59:04 <ems> but I don't know what sort of Black Magic is going on in the base package as far as optimization is concerned
05:05:52 <Razz> Anyone make the typeclassopedia exercises, I'm completely stuck on the 3rd exercise for monads (the monad instance for the free monad built from functor f) I've done the functor instance but I don't see a way of doing the monad instance for the Node constructor
05:09:29 <clsmith> i'm curious. is there a reason why (/) and div are separate? is it *just* that one is for fractionals and the other integrals?
05:12:15 <mauke> clsmith: AFAIK yes
05:15:43 <aristid> clsmith: say you have 1 / 5 and 1 `div` 5. both have fairly different values :)
05:16:35 <clsmith> aristid: but surely Integer + and Int + can have 'fairly different values'? :p
05:16:44 <ClaudiusMaximus> > 1 `div'` 5
05:16:46 <lambdabot>   0
05:16:47 <Rc43> Hi, guys,
05:17:37 <aristid> clsmith: well sure, it's not black and white :)
05:17:49 <Rc43> for ({1..n}) {..} is O(n), but how long works for ({1..Amax}), where Amax is max({a1,a2,a3,...,aN})?
05:18:04 <Rc43> I mean, time depends on input, but not on N.
05:18:10 <Veinor> clsmith: x / y * y == x should be true, or close to it.
05:18:43 <Veinor> (i say 'close' because mumble mumble floating point)
05:19:07 <Veinor> Rc43: I think you'd just write O(max(a_n))
05:19:59 <Rc43> Veinot, yes. But If I have problem from book, that I should write programm works with O(N)?
05:20:10 <Veinor> what do you mean
05:20:13 <Rc43> Can I use for to any variable?
05:20:16 <Veinor> what?
05:20:17 <clsmith> wouldn't it be possible (sufficiently advanced compiler disclaimer) to use a technique to infer the necessary representation for a given number? like, if you use a fractional division and then round it, it could be like, oh, i'll just do an integral division.
05:20:48 <clsmith> s/round/floor/ i guess
05:20:54 <Veinor> Rc43: i'm really not sure what you're asking
05:21:08 <Rc43> Veinor, suppose we have array A[N]. we have to solve a problem with it, and time must be O(N).
05:21:17 <Veinor> clsmith: that's possible, but it would have to make a large number of assumptions that i'm not sure that it'd be safe to assume
05:21:28 <Veinor> like the functor laws
05:21:34 <mauke> Rc43: is this in any way related to haskell?
05:21:38 <Rc43> Veinor, we have found an algorithm O(max(A[N]). Is it correct solution?
05:21:59 <clsmith> Veinor: so i guess you'd need to infer the properties of all the surrounding functions as well...
05:22:06 <Veinor> yeah
05:22:16 <Rc43> mauke, nope, but I know that there are people, who knows about asymptotics.
05:22:20 <hpaste_> donri pasted “Bash completions for cabal-dev and aliases” at http://hpaste.org/56835
05:22:24 <Veinor> like iirc ghc doesn't assume that fmap (f . g) = fmap f . fmap g
05:22:25 <donri> ^^^ enjoy
05:22:52 <clsmith> i was thinking it would be interesting to be able to infer commutativity, associativity, etc, so you can more efficiently map and fold and so on.
05:23:13 <Veinor> and that's not because it can't, but because the ghc devs decided that it wouldn't be worth mysteriously breaking non-functor-law Functor code
05:23:37 <Veinor> Rc43: no, it's not
05:23:40 <clsmith> btw, is that fmap property decidable at compilation time? i would guess not.
05:23:42 <ems> Veinor: actually I was wondering about that myself recently
05:23:59 <Veinor> i think it is with a very clever compiler
05:24:03 <ems> Veinor: because I've been defining some Ord instances that violate the usual laws, and wanted to make sure I didn't get in trouble with it
05:24:18 <Veinor> what laws?
05:24:33 <Veinor> also keep in mind that instances automatically get exported
05:24:37 <ems> a <= b and b <= a imply a = b
05:24:41 <Veinor> ah
05:24:47 <ems> or something like that
05:24:54 <ems> I was doing interval arithmetic, which doesn't give a total ordering
05:25:16 <Veinor> what were you worried would berak?
05:25:19 <Veinor> *break
05:25:20 <clsmith> ems: i did that a while back, and i haven't stopped feeling uneasy about it
05:25:29 <ems> the Ord instance was just for convenience to reuse the same symbols with somewhat different meanings
05:25:38 <Veinor> clsmith: iirc ghc does optimize map f . map g into map (f . g), but that's because map's builtin
05:26:08 <ems> hmm, I wasn't worried about something in particular breaking, as I ended up not needing the false Ord instance for very much
05:26:28 <Veinor> ems: the problem is
05:26:34 <Veinor> anybody who imports your module will get this Ord instance
05:26:52 <clsmith> i wonder if it could infer properties like that just from the definition, and then optimise fmaps like that. very interested in optimising code via graphs atm :p
05:26:52 <ion> I take it Jan Rochel isn’t on IRC?
05:27:00 <ems> Veinor: you can define additional rules like map f . map g == map (f . g) with GHC
05:27:12 <ClaudiusMaximus> does ghc use parallelism?  would compiling go faster if i use ghc +RTS -N
05:27:12 <Veinor> right, right
05:27:24 <ems> as for the Ord instance
05:27:48 <ems> I'm the only person using my code
05:27:56 <Veinor> for now!
05:27:58 <ems> so so long as I'm aware of any pitfalls, it should be okay
05:27:59 <ems> heh
05:28:02 <brill> As a complete noob at Haskell :: What IDE are you all using? Emacs, Eclipse or something else?
05:28:13 <Veinor> emacs
05:28:17 <ems> vim!
05:28:25 <brill> :-)
05:28:26 <Veinor> i'd guess 90-95% of all haskell coders use emacs/vim
05:28:34 <brill> Okay.
05:28:38 <clsmith> more vim than emacs, iirc?
05:28:43 <mauke> brill: linux
05:28:47 <Veinor> cat >
05:30:08 <davv3_> hello. if i want my function to take arguments abc and produce d, with a b being integer c and d floats. what is my function typeclass to be? is it not: f :: Int -> Int -> Float -> Float
05:30:42 <mauke> that's not a typeclass
05:30:52 <mauke> why are you using Floats?
05:31:10 <davv3_> :t f returns Integral a => a -> a -> a -> a
05:31:10 <lambdabot> parse error on input `=>'
05:31:24 <davv3_> im calculating the square root with decimals
05:31:36 <mauke> well, ghc thinks they're all integers then
05:32:07 <davv3_> yes, which is why im trying to pre-define the variables
05:32:28 <davv3_> c is argument for how many decimals in decimal form.
05:32:51 <mauke> so put an explicit type signature in and see if it complains
05:33:01 <Chaze> :t arr
05:33:01 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:33:08 <Chaze> :src Arrow
05:33:14 <Chaze> @src Arrow
05:33:14 <lambdabot> class Arrow a where
05:33:14 <lambdabot>     arr, pure   :: (b -> c) -> a b c
05:33:14 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
05:33:14 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
05:33:14 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
05:33:16 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
05:33:18 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
05:34:08 <davv3_> mauke: can you give an example of an explicit type signature?
05:34:16 <Chaze> usually, when I use these, the instance is the "function application arrow"
05:34:17 <mauke> f :: Int -> Int -> Float -> Float
05:34:18 <Chaze> right?
05:34:26 <Veinor> Chaze: yeah
05:34:36 <Chaze> Veinor: are there any other notable instances?
05:34:44 <rostayob> Chaze: Klesli
05:34:48 <Veinor> none that i can think of off the top of my head, but I haven't done alot of Arrow programming
05:34:51 <rostayob> Chaze: various automaton-like things
05:34:57 <mauke> Klesli Knielsen
05:35:05 <rostayob> Chaze: stream processors
05:35:25 <rostayob> Kleisli, not Klesli
05:35:29 <rostayob> can't spell that.
05:35:40 <rostayob> did they really have to name it like that?
05:36:07 <Chaze> the name rings a bell, I've heard it before
05:36:21 <Chaze> some operation maybe?
05:36:31 <Chaze> kleisli operator? related to regular expressions?
05:36:33 <rostayob> Chaze: turns a monad into an arrow
05:36:34 <Chaze> or do i mix that up
05:36:40 <mauke> Chaze: Kleene closure?
05:36:50 <Chaze> ah, that was Kleene
05:37:02 <davv3_> mauke: ive tried that before but it yields an errror with ghc
05:37:04 <davv3_> im sure it may be
05:37:14 <rostayob> Chaze: as I said it turns a monad into an arrow, so you can do stuff like
05:37:14 <davv3_> logical
05:37:21 <davv3_> | abs (a*a - n) < e = a
05:37:30 <davv3_> where e is the floating datatype
05:37:35 <ClaudiusMaximus> davv3_: you probably need more   fromIntegral
05:37:47 <rostayob> let foo = Kleisli readFile >>> words >>> Kleisli (mapM putStrLn)
05:38:13 <rostayob> sorry, should be 'arr words'
05:38:47 <copumpkin> shiver me timbers
05:43:43 <davv3_>  http://sprunge.us/UEOV
05:44:02 <mauke> :t (<)
05:44:03 <davv3_> Couldn't match expected type `Float' with actual type `Int' in the expression a
05:44:04 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:44:13 <mauke> (<) takes two values of the same type
05:44:22 <davv3_> is the type signature wrong?
05:44:23 <mauke> that's why it's saying Float doesn't match Int
05:44:31 <davv3_> oh
05:44:38 <aristid> davv3_: which language is that?
05:44:49 <davv3_> swedish
05:44:57 <mauke> also because you're returning 'a' (an Int) from a function claiming to be Float
05:45:02 <davv3_> mauke: << i assume is not bitshift?
05:45:10 <mauke> :t shiftL
05:45:11 <lambdabot> forall a. (Bits a) => a -> Int -> a
05:45:16 <mauke> this is
05:45:19 <davv3_> :)
05:45:25 <donri> kvadratroten = square root
05:46:16 <mauke> this is like blinkenlights and gefingerpoken
05:46:16 <davv3_> so i need to use fromIntegral or some such to two floats for comparison?
05:46:17 <cnwdup_> I want to write a X11 terminal emulator in Hakell and I seem to have a profound misunderstand what a terminal emulator is. I thought I could create a shell process and just write X11 input to the process' stdin and draw the shell's stdout and stderr to my X11 window. I there some documentation that could get me started?
05:46:41 <copumpkin> davv3_: if they're two floats, you don't need to do anything
05:46:48 <copumpkin> davv3_: but you're trying to compare an Int and a Float
05:47:05 <mauke> copumpkin: man pty
05:47:07 <mauke> argh
05:47:10 <mauke> cnwdup_: man pty
05:47:14 * copumpkin hugs mauke 
05:47:20 * mauke ghci copumpkin
05:47:24 <clsmith> lol
05:47:49 <Veinor> man pity
05:59:30 <ems> The results are in! I finished comparing my homebrew rational class versus the built-in Ratio Integer
05:59:40 <ems> and I learned that I need to optimize gcd somehow
06:00:07 <ems> my program spent 93% of its execution time computing gcds
06:00:53 <ion> Why reinvent Ratio?
06:01:20 <ems> my program was spending most of its time during arithmetic on rationals
06:01:48 <ems> and the source code for Ratio in the GHC docs looked like it had (marginal) room for improvement
06:01:59 <rostayob> I'd doubt that
06:02:04 <ems> so I more-or-less copied that source code to see if I would get the same performance
06:02:14 <ems> but got markedly worse performance
06:02:53 <ems> so there must be something going on under the hood not reflected in the source code in the docs (or, the minor changes I made were not as minor as I thought)
06:03:10 <ems> the improvement I wanted to make was to not perform a reduce after every rational multiplication
06:03:22 <ems> which is, I think, mostly wasted effort
06:03:50 <ems> I suspect that if I batch together, say, 5 multiplications and perform a reduce on the result I might get better performance than doing a reduce after every multiplication
06:08:27 <Ngevd> Hello
06:13:39 <argiopeweb> 'Morning all. Anyone happen to know why identical code & compilers on 64-bit versions of Fedora 16 & RHEL 5 produce 11 and 23mb executables, respectively? Seems they should be freakishly similar, if not identical.
06:14:00 <hpc> argiopeweb: different library versions, perhaps
06:14:14 <hpc> or different linkers, or something
06:14:55 <argiopeweb> hpc: Everything non-Haskell should be getting linked dynamically... I suppose I'll set aside some time tomorrow to pore over an objdump... :\
06:18:04 <sara89> ciao
06:18:06 <sara89> !list
06:25:04 <byorgey> @tell carter would be great to see you at POPL, let me know if you're around!
06:25:04 <lambdabot> Consider it noted.
06:28:44 <mm_freak> rostayob: not really, no…  but honestly i didn't really try
06:28:55 <mm_freak> rostayob: i guess the difficulty is comparable to writing mfix for []
06:29:15 <mm_freak> which is also pretty nontrivial
06:30:39 <aristid> :t mfix
06:30:40 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
06:31:52 <abc22134> :t fix
06:31:53 <lambdabot> forall a. (a -> a) -> a
06:32:42 <ems> I am proud to report my program received a 27.5% speedup using a slightly altered rational class
06:33:15 <ems> where I suppressed the reduction to lowest terms in a few key places
06:33:28 <abc22134> Does Haskell has a tail recursion guarantee?
06:34:03 <byorgey> abc22134: with a non-strict language such as Haskell, tail recursion is not what you want.
06:34:35 <byorgey> instead you want something called guarded recursion.  And GHC is very good at compiling guarded recursion to efficient code.
06:36:39 <mm_freak> you mean guarded corecursion?
06:36:52 <abc22134> Tail-recursive formulations is standard technique for state passing iterative processes. Consider fib n (a,b) = fi (n-1) (b.a+b). Is there a guarantee in Haskell this will work in linear time (sans bignums)?
06:37:08 <byorgey> mm_freak: in Haskell, greatest and least fixed points coincide, so there's no difference.
06:37:16 <mm_freak> i see
06:37:47 <mm_freak> abc22134: not sure if the standard guarantees that, but that definition will get compiled to iterative code
06:37:53 <byorgey> abc22134: no, but not for the reason you might think
06:38:13 <abc22134> please explain
06:38:18 <mm_freak> abc22134: but you wouldn't do that in haskell anyway
06:38:45 <byorgey> abc22134: the problem with that code is that the result will be constructed lazily.  so a huge unevaluated expression will be built up by the recursion, and when the result is finally needed it will use a lot of memory evaluating it.
06:39:02 <byorgey> abc22134: but if you introduce some strictness annotations, that code will work in linear time.
06:39:09 <abc22134> no, I'll just add some bangs there. Will it be OK then?
06:39:26 <byorgey> well, actually, I should say that it will work in linear time regardless.  the question is just how much memory it needs.
06:39:29 <byorgey> abc22134: yes.
06:40:18 <abc22134> I know this compiles and run in linerar time. THe question is, is there guarantee it will alwys be so, for other code as well?
06:43:13 <abc22134> And I would actually like even stronger guarantee. Since tail-recursion = last frame re-use, each param passed between invocations should e reused too. That means in case it is an array (simple immutable one) the update should be O(1) and be actually destructive.
06:43:14 <byorgey> abc22134: no, the Haskell standard does not make any such guarantees.
06:43:38 <mauke> function calls don't call functions
06:43:50 <mauke> control flows sideways
06:44:57 <abc22134> Thanks, I had some recollection of reading it somewhere but I don't remeber exactly where. Wouldn't a guarantee for destructive update of *anything* in tail position eliminate (half) the need for Monads and stuff? Because it is _unique_.
06:45:12 <mm_freak> no
06:45:19 <mauke> abc22134: how would tail recursion eliminate lists?
06:45:21 <mauke> list is a monad
06:45:28 <mm_freak> you have two entirely unrelated things there
06:46:08 <abc22134> Not all monads of course, just mutable arrays where an aray update in tail position should realy reuse the array ie. get compiled to destructive update.
06:46:12 <byorgey> abc22134: perhaps you would be interested in Clean's "uniqueness types"
06:46:16 <byorgey> but Haskell does not have that
06:46:49 <mm_freak> abc22134: tbh i prefer haskell's approach there, but in fact you don't need destructive update as often as you might expect
06:47:05 <byorgey> something occuring in tail position does not guarantee that nothing else has a reference to it.
06:47:55 <abc22134> Thanks, I'm not that much of a mathematician, but at least in simple cases where something is passed as changing state in taio  position, it is clear it should get reused, and i imagine it mustn't be that hard to augent the compiler to recognize this.
06:48:25 <mauke> abc22134: foo x (x + 1)
06:48:29 <byorgey> abc22134: it is not clear to me at all.
06:48:33 <mauke> abc22134: (x + 1) is in a tail position. can x be modified?
06:49:40 <byorgey> abc22134: in practice, GHC *does* generate code that does a lot of destructive update, but not in the way you are suggesting.
06:50:13 <abc22134> 'x' is used twice there, so the ref to it clearly not unique anymore.
06:50:31 <mauke> abc22134: how do you know it's used twice?
06:51:26 <abc22134> What i'd like very much is to have this guarantee as part of the language. Then I won't e forced to write imperative code with utable arrays. I just don't like imperative code.
06:51:35 <mauke> abc22134: how do you know it's used twice?
06:51:42 <byorgey> abc22134: "It mustn't be that hard to augment the compiler to recognize this" --> actually, it is hard.
06:51:56 <byorgey> abc22134: as I said before, Clean is able to do this, via "uniqueness types"
06:51:57 <abc22134> you wrote foo x (x+1), so it seems to appear twice.
06:52:06 <byorgey> but the analysis/type system is nontrivial.
06:52:44 <byorgey> abc22134: I think mauke's point is that one of them may not actually be *used*
06:53:34 <byorgey> abc22134: this is also related to "linear types"
06:53:50 <abc22134> byorgey: I see; ut what if something useful can e done here which won't worl in all cases, but just in some well-defined cases? Like, in tail code, anything that's not apeaing twice, gets full reuse.
06:54:06 <byorgey> abc22134: ultimately, I think the answer to your questions is "this is a sensible thing to want, and people have thought about it, but it is a lot harder than you think"
06:54:26 <byorgey> abc22134: another language you may be interested in is Disciple
06:54:42 <byorgey> which I think may also do some analysis of this sort, although I'm not certain
06:54:52 <mauke> abc22134: how do you know there are no other references to x
06:55:33 <byorgey> abc22134: I think "tail calls" is a red herring here.  Just because something occurs in a tail call does not really tell you anything about whether it is referenced anywhere else.
06:55:59 <abc22134> mauke: If I write a function which creates an array and then passes it in to its internal function which has array-update in tailcall, then I know.
06:56:31 <abc22134> mauke: then, I want that array-appdate to ba O(1), not O(|a|).
06:56:44 <mauke> abc22134: that's unrelated to and more complicated than tail calls
06:57:38 <byorgey> abc22134: you still have to do some analysis to ensure that outer function which created the array does not look at it again or do anything else with it.  And I still don't see what tail calls have to do with anything.
06:59:32 <abc22134> I just thought tail call is about reuse of stack frame, _including_ arguments slots. So it was tempting, vague thought.
07:00:37 <prof7bit> does the notion of "stack frame" and function "call" even make the same sense as in imperative languages?
07:00:50 <prof7bit> does it even exist?
07:01:27 <ClaudiusMaximus> > 2^31 / 44100 / 60 / 60
07:01:28 <lambdabot>   13.5266039808516
07:01:49 <abc22134> byorgey: even if something else has reference to this array, what I suggest may still be used with (deep) copying of the argument. But if used in internal function, compiler has full knowledge.
07:02:09 <mauke> prof7bit: not really, no
07:02:26 <shachaf> prof7bit: Not really. Though I would say it's more because of laziness than because of "not-imperative"ness.
07:03:37 <prof7bit> yes, laziness vs strict is what i meant.
07:03:43 <byorgey> abc22134: yes, but the reusing of argument slots usually happens in a context where the arguments have initially been copied anyway. So it is OK to throw away previous values.
07:05:08 <abc22134> byorgey: so what d'you think, can this be somehow "pushed" into the language?
07:05:25 <mm_freak> abc22134: you are only asking how to do it
07:05:32 <mm_freak> you are not asking whether one might actually want to do it
07:06:25 <mm_freak> you should first gain a deeper understanding of the language and how to write productive code with it, before asking to scheme-ize/ML-ize/C-ize haskell
07:06:30 <byorgey> abc22134: I have already answered that multiple times above, by pointing you to other languages where this sort of thing IS done.
07:06:58 <byorgey> abc22134: the point is that it is nontrivial so is unlikely to be added to Haskell anytime soon.
07:08:18 <mm_freak> or, for that matter, disciple-ize haskell
07:10:43 <byorgey> it is certainly a reasonable thing to want.
07:10:54 <mm_freak> byorgey: destructive update?
07:11:33 <abc22134> byorgey: OK, clear enough, Thanks to all. Just imagine being able to write in-place quick-sort in functional Haskell.
07:11:43 <mm_freak> i wouldn't be surprised if GHC actually did that for tight loops
07:12:16 <mm_freak> after all with tight loops i get close to C performance in my numerical code
07:13:03 <mm_freak> (tight loop = tail recursion with variables of simple atomic types like Int and Bool)
07:13:08 <byorgey> mm_freak: nice pure functional code being compiled to something using destructive update when possible, yes.
07:13:16 <ion> Blub-ize Haskell.
07:15:07 <mm_freak> i don't know whether GHC does that in some places, but the performance of GHC-compiled code is amazing…  since GHC 6.12 i haven't had the need to resort to C anywhere
07:15:49 <mm_freak> and IMO if you really want that kind of optimization, you should introduce uniqueness types first
07:32:32 <Sgeo> Hmm
07:34:55 <Sgeo> Can the RTS be made to detect when it's running low on memory, and if it is, spark off another thread to evaluate some unevaluated stuff? If it returns a non-bottom, replace it, if it returns a detectable bottom, just mark the original with something saying not to try again, and if it infinite loops, well, so what?
07:35:44 <rostayob> Sgeo: I don't think so. I was looking for something similarbut the other way aroud  (java style weak pointers) but it's not provided
07:37:13 <mm_freak> Sgeo: if that would help your application, you should improve your code
07:37:39 <mm_freak> in other words +RTS -M should be all you need (to keep the program from crashing your machine)
07:37:43 <ddarius> An evaluated thunk can take much more memory than an unevaluated thunk.
07:37:44 <Sgeo> mm_freak, I'm just thinking to improve the situation of space leaks due to laziness
07:38:04 <Sgeo> Oh, hmm
07:38:19 <ddarius> Space leaks aren't caused by laziness.  They are caused by programmers writing inappropriate code.
07:38:23 <Sgeo> What's -M
07:38:26 <mm_freak> Sgeo: you shouldn't work around space leaks…  you should fix them
07:38:32 <mm_freak> -M sets a heap memory limit
07:38:43 <Veinor> oh that reminds me
07:38:45 <mm_freak> run your program with +RTS -M512m
07:38:47 <Sgeo> What happens if the heap memory limit is hit?
07:38:57 <mm_freak> then the program is aborted with an error message
07:39:15 <hpaste_> Veinor pasted “Fibs” at http://hpaste.org/56841
07:39:23 <Veinor> why does that leak?
07:39:38 <Sgeo> ddarius, can it just be inappropriate failing to write the proper strictness annotations?
07:39:47 <mm_freak> Veinor: the seq doesn't force the addition
07:39:52 <ddarius> Veinor: Forcing a constructor does nothing.
07:39:53 <mm_freak> it only forces the (,) constructor
07:39:56 <Veinor> ah
07:40:37 <ddarius> Sgeo: Placing strictness (or really eagerness) annotations in the appropriate places would be an important skill, as well as knowing why you are doing that.
07:41:13 <hpaste_> Veinor pasted “Fibs” at http://hpaste.org/56842
07:41:18 <Veinor> it still leaks
07:41:24 <ddarius> You can eliminate some space leaks in eager languages by applying appropriate laziness annotations.
07:41:45 <rostayob> ddarius: what I think people mean is "this program wouldn't leak if it was strict"
07:42:00 <rostayob> i'm not sure that means that lazynes "causes" leaks
07:42:31 <Sgeo> I basically keep hearing that a problem with laziness is that it's harder to reason about performance, so
07:42:41 <rostayob> Sgeo: that's true
07:43:26 <ddarius> rostayob: Most people write Haskell programs as if they are eager programs, so that is not surprising at all.
07:43:30 <ddarius> rostayob: There are dual cases.
07:43:45 <mm_freak> Veinor: are you compiling with -O?
07:43:52 <rostayob> ddarius: ok. i was just replying to your "lazyness doesn't cause leaks"
07:43:55 <ddarius> But in the dual cases, people don't say, "this program wouldn't leak if it was lazy" they say "fix your program!"
07:43:55 <mm_freak> i don't see any leak there
07:44:02 <hpc> ddarius: i think it's less "as if they are eager" and more "without thinking about strictness or laziness"
07:44:26 <ddarius> hpc: Which, since almost no one has experience programming in a lazy language, usually means using habits from eager languages.
07:44:40 <rostayob> i doubt that "most" people write haskell like that anyways. an awful lot of haskell programs wouldn't work without lazyness
07:44:42 <hpc> true
07:45:00 <Veinor> mm_freak: never mind, it doesn't leak
07:45:08 <Veinor> i was misunderstanding the output of -p
07:45:19 <mm_freak> actually now that my mind got used to haskell, i have a harder time writing code in a strict language
07:45:26 <rostayob> me too, absolutely
07:45:35 <Veinor> i thought "total alloc" meant "maximum memory in use"
07:45:49 <hpc> i haven't had problems with strict languages since starting haskell
07:46:22 <hpc> ive had problems writing procedural code, where i get bored and start wishing for easy-to-use (.), or (<$>)
07:46:27 <hpc> but that's about it
07:46:48 <rostayob> hpc: I don't have problems, but sometimes I find myself writing out a lot of things that I'd put in "where", when some of the things are not needed in some cases
07:46:58 <mm_freak> well, i always have to remind myself:  "buddy!  remember, this list is going to be in memory as a whole all the time!  here the list WILL be copied!"
07:47:07 <nand`> I don't have problems *writing* it, but I have problems looking at imperative code and not wishing to kill myself
07:47:09 <mm_freak> writing code in a strict language is difficult
07:47:22 <mike-burns> Writing code is difficult.
07:47:34 <nand`> it's been consistently uglier, longer and less elegant than functional solutions
07:47:40 <nicoo> mike-burns: Writing correct code is difficult;
07:47:41 <mm_freak> dunno, haskell made coding pretty easy actually
07:47:44 <dmwit> ?remember xplat When I'm programming in Agda, I feel like I'm pair-programming with some god-like entity that tells me when I'm wrong. When I'm programming in Scala, I feel like I'm pair-programming with an alien that's about as smart as I am.
07:47:44 <lambdabot> Done.
07:47:54 <Veinor> haha that was a good one
07:48:05 <mm_freak> lol
07:48:13 <nicoo> xD
07:49:11 <mm_freak> nand`: i even get sick reading functional code in a strict language…  i think no language knows the value of combinators as much as haskell
07:49:23 <mike-burns> APL?
07:49:27 <ClaudiusMaximus> mm, ghc-7.4rc removes the char *ghc_rts_opts hook, must update my .cabal files to use -with-rtsopts
07:49:29 <mm_freak> haskell takes the concept to build your program from small, isolated parts to its conclusion
07:49:32 <hpc> when i program in haskell with ghci running, i feel like im pair-programming with a robot
07:49:48 <_Mikey> me too
07:50:16 <mm_freak> when i program in haskell with GHCi running, i miss GHC 7.4 (i'm back to 7.0.3) =)
07:50:16 <cheater_> hpc hahaha
07:50:23 <cheater_> never thought of it that way
07:52:42 <rostayob> mm_freak: I think that SML is better for what concerns composability
07:52:55 <rostayob> due to its module system
07:53:09 <rostayob> also, monadic code is not that composable
07:53:29 <rostayob> (sometimes)
07:53:53 <kuribas> When I want a list of attributes, lets say "data Attribute = A1 Int | A2 String", how would I extract the attribute A1?
07:53:59 <kuribas> Or is there a better way?
07:54:09 <mauke> what do you mean by "extract"?
07:54:18 <rostayob> what do you mean by "arribute"?
07:54:28 <kuribas> read the value of the attribute.
07:54:37 <mauke> pattern matching
07:55:08 <mm_freak> rostayob: why is monadic code not well composable?  the whole point of monads is composition
07:55:11 <hpc> kuribas: unrelated, but why use [Attribute] instead of data Attributes = A Int String
07:55:18 <hpc> ?
07:55:36 <rostayob> mm_freak: because you have to initiate all the environment, you can't just "use" it like you do with functions
07:55:42 <kuribas> hpc: Because the attributes might have different types...
07:56:01 <mm_freak> > [ x | x@(Left _) <- [Left 1, Right 2, Left 3, Right 4] ]
07:56:02 <lambdabot>   [Left 1,Left 3]
07:56:15 <mm_freak> > lefts [Left 1, Right 2, Left 3, Right 4]
07:56:15 <lambdabot>   [1,3]
07:56:34 <mm_freak> rostayob: i don't understand
07:57:10 <kuribas> I want to make a music notation program, and for every timestep there can be attributes, such as articulation, note grouping, dynamics...
07:57:22 <Sgeo> @src lefts
07:57:23 <lambdabot> Source not found. stty: unknown mode: doofus
07:57:34 <rostayob> mm_freak: if you define a very specific monad for your application, and write the whole application in that monad, the functions will be much less reusable.
07:57:48 <rostayob> you have to be careful to keep the bare minimum in the monad
07:57:59 <mm_freak> kuribas: recursion with pattern matching?  or perhaps even separate the two
07:58:48 <mm_freak> rostayob: if the actions in that application-specific monad are not application-specific, then you made a mistake designing the library
07:58:52 <kuribas> I could use pattern matching, but I want to avoid a lot of boilerplate code, if that is possible.
07:59:13 <mm_freak> (or program)
07:59:14 <rostayob> mm_freak: yeah, but that often happens in the end
07:59:46 <mm_freak> kuribas: what's the boilerplate there?  at some point you will have to pattern-match to know which kind of attribute you have
07:59:52 <rostayob> mm_freak: because it's often much more comfortable to define the functions in a monadic way instead of factoring out the specific arguments
08:00:05 <mm_freak> rostayob: really?  i disagree
08:00:32 <Eduard_Munteanu> It's a bit funny how arrows are composable and monads aren't, or are/aren't considered to be.
08:00:36 <rostayob> mm_freak: that's what i see reading code written by myself and my friends
08:00:41 <mm_freak> Eduard_Munteanu: wrong
08:00:59 <mm_freak> Eduard_Munteanu: 'id' corresponds to 'return' and (.) corresponds to (<=<)
08:01:11 <mm_freak> Eduard_Munteanu: and all the combinators from Arrow correspond to what you get with Applicative
08:01:14 <rostayob> you mean arr id
08:01:18 <rostayob> corresponds to return
08:01:21 <mm_freak> rostayob: no, i mean 'id'
08:01:26 <mm_freak> see Control.Category
08:01:51 <rostayob> yes, I know what id is, but return lifts the value, and 'arr id' lifts the function
08:01:54 <mm_freak> arr id = id for arrows, but not every category is an arrow
08:01:57 <Eduard_Munteanu> Yeah, sure.
08:02:00 <rostayob> in fact returnA = arr id
08:02:24 <rostayob> mm_freak: ah, you were comparing with Category
08:02:39 <mm_freak> rostayob: define 'id' for Kleisli…  you will see why it corresponds to 'return'
08:03:16 <rostayob> mm_freak: yeah i was thinking of Arrow
08:03:16 <_Mikey> hey guys
08:03:27 <rostayob> mm_freak: btw... news about SP?
08:03:30 <mm_freak> well, for arrows arr id = id
08:03:31 <_Mikey> is there a this sort of key word in Haskell?
08:03:36 <mm_freak> rostayob: i haven't tried honestly
08:03:47 <mm_freak> _Mikey: what would it do?
08:03:50 <Eduard_Munteanu> _Mikey: what do you mean? 'this' like in C++?
08:04:00 <_Mikey> like if you have a function called id in a module and you don't want it to be confused with Pelude's id
08:04:12 <rostayob> mm_freak: elliott was trying i think. anyways it doesn't seem to be easy
08:04:24 <rostayob> expecially since huges wants loop (arr id) = arr id
08:05:09 <mm_freak> rostayob: as said, the problem is comparable to mfix for []
08:05:18 <mm_freak> and i haven't tried that one either
08:05:54 <mm_freak> _Mikey: not really…  you'll have to import the clashing symbols qualified to work around that
08:06:11 <davv3_> hey, im trying to recursively make a binary tree of sorts, is there a way to call two functions from one condition? (with guards)
08:06:20 <rostayob> mm_freak: why is it comparable to that?
08:06:51 <davv3_> (dumb question?)
08:06:52 <mm_freak> davv3_: well, just use two functions and combine their results in some way
08:07:07 <davv3_> mm_freak: ah clever
08:07:19 <mm_freak> davv3_: but i sense you might have an imperative idea of "calling a function"…  note that functions can't have side effects in haskell
08:07:20 <Eduard_Munteanu> davv3_: not dumb, but you have to think about what sort of data you want to get back, not in terms of just calling stuff.
08:07:38 <mm_freak> davv3_: so basically you're writing equations
08:07:53 <hpaste_> kuribas pasted “attributes” at http://hpaste.org/56843
08:08:00 <mm_freak> rostayob: because SP is a generalization of []
08:08:03 <Eduard_Munteanu> > let func = (+) in (func 1 2, func 3 4)
08:08:04 <lambdabot>   (3,7)
08:08:09 <davv3_> Eduard_Munteanu: i hear you
08:08:23 <mm_freak> rostayob: and the code for mfix for [] is somewhat complicated
08:08:37 <mm_freak> @src mfix []
08:08:37 <lambdabot> Source not found. I feel much better now.
08:08:41 <mm_freak> @src [] mfix
08:08:41 <lambdabot> mfix f = case fix (f . head) of
08:08:41 <lambdabot>            []    -> []
08:08:41 <lambdabot>            (x:_) -> x : mfix (tail . f)
08:08:44 <kuribas> mm_freak: I would have to write this for every attribuate: http://hpaste.org/56843
08:09:25 <mm_freak> kuribas: you might be interested in generic programming…  see for example uniplate
08:10:11 <mm_freak> kuribas: another way to solve this problem is using lenses
08:10:22 <mm_freak> if you want to try that approach, see the data-lens package
08:10:23 <gwern> preflex: seen aavogt
08:10:23 <preflex>  aavogt was last seen on #xmonad 23 hours and 1 minute ago, saying: * aavogt looks at code
08:10:28 <rostayob> mm_freak: in what sense SP is a generalization of SP? it is equivalent in some way to [a] -> [b]
08:10:38 <kuribas> mm_freak: I see.  I'll look them up :)
08:10:45 <rostayob> mm_freak: also, MonadFix [] is fairly simple: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Fix.html#MonadFix
08:10:52 <mm_freak> rostayob: it is more powerful than [a] -> [b], because it can wait
08:11:01 <mm_freak> [a] -> [b] can't wait
08:11:34 <rostayob> mm_freak: if it couldn't wait, it wouldn't be as powerful as [a] -> [b]
08:11:38 <mm_freak> rostayob: really?  it took some time for me to get my head around that definition
08:11:47 <mm_freak> and i only did that after failing to write it myself =)
08:12:29 <rostayob> mm_freak: well it's assuming, as others MonadFix instances, that the list has at least 1 element
08:12:42 <rostayob> i can do the same with SP and assume that the first "action" is a Put
08:12:47 <rostayob> but then loop (arr id) doesn't work
08:13:47 <hpaste_> “_Mikey” pasted “instance Show Record” at http://hpaste.org/56844
08:14:04 <_Mikey> Where about's am I falling off?
08:14:20 <_Mikey> I know I could just derive Dhow.
08:14:27 <_Mikey> show*
08:14:36 <mm_freak> rostayob: if you can write spToAuto, then SP is equivalent in power to SF
08:14:42 <mm_freak> i couldn't write it
08:14:45 <cheater_> hm
08:14:49 <_Mikey> but I want to only display one field of the record namely id if show is called.
08:14:58 <rostayob> what's spToAuto?
08:15:05 <mm_freak> SP a b -> Auto a b
08:15:18 <rostayob> ok, I guess I'm missing Auto then :P
08:15:24 <rostayob> is it the 'Automaton' in arrows?
08:15:27 <mm_freak> yes
08:15:32 <mm_freak> almost
08:15:39 <rostayob> but not transformer
08:15:42 <byorgey> _Mikey: show Ant = ...  is wrong, because a value of type Ant does not look like 'Ant', it has three fields
08:15:43 <mm_freak> Auto (->) a b in the case of the 'arrows' library
08:15:54 <rostayob> yeah
08:15:56 <byorgey> _Mikey: perhaps you want   show a = "Ant: " + antId a
08:16:06 <rostayob> mm_freak: is the non-transformer form somewhere?
08:16:08 <mm_freak> i've written autoToSP yesterday, so SP is at least as powerful as Auto
08:16:16 <mm_freak> the other way i couldn't figure out
08:16:20 <mm_freak> and i'd say it's not possible
08:16:29 <byorgey> _Mikey: alternatively you could write  show (Ant i _ _) = "Ant: " + show i
08:16:32 <mm_freak> the non-transformer form is Auto (->)
08:16:40 <byorgey> _Mikey: or even   show (Ant { andId = i }) = ...
08:16:43 <_Mikey> hmm
08:16:44 <mm_freak> (->) acts as identity for arrow transformers
08:16:46 <_Mikey> yes
08:16:48 <rostayob> mm_freak: yes but I mean without the non-transformer data type
08:16:49 <_Mikey> those would work
08:16:54 <rostayob> so that there is less noise
08:16:58 <rostayob> type noise :P
08:17:12 <mm_freak> there won't be additional noise…  just define:  type PAuto = Auto (->)
08:17:57 <mm_freak> otherwise just define your own Auto type…  you don't need to write any instances for it for this purpose
08:18:02 <rostayob> mm_freak: noise when reading the source
08:18:05 <mm_freak> just prove that there is a conversion from SP to Auto
08:18:32 <mm_freak> there is no additional noise…  it's unlike Monad, where the identity needs a newtype wrapper =)
08:18:48 <mm_freak> the identity for arrow transformers is (->) itself, not some newtype wrapper around it
08:19:00 <rostayob> mm_freak: I understand that, I mean noise when reading this code: http://hackage.haskell.org/packages/archive/arrows/0.4.4.0/doc/html/src/Control-Arrow-Transformer-Automaton.html#Automaton
08:19:08 <rostayob> if I want to study the definition and instances
08:19:25 <rostayob> the fact that there is an inner arrow is distracting
08:19:30 <_Mikey> byorgey, pattern bindings aren't allowed apparently.
08:19:32 <mm_freak> yeah, unfortunately they write in prefix syntax, because h98 doesn't have type operators
08:19:45 <byorgey> _Mikey: what do you mean?
08:19:50 <mm_freak> newtype Auto (>~) a b = Auto (a >~ (b, Auto (>~) a b))
08:19:55 <mm_freak> that might be more readable
08:19:58 <rostayob> mm_freak: h98 doesn't have FlexibleInstances either
08:20:07 <mm_freak> does it use flexible instances?
08:20:16 <rostayob> ofc
08:20:20 <rostayob> instance Arrow a => ArrowTransformer Automaton a where
08:20:23 <rostayob> and so on
08:21:40 <mm_freak> is that a flexible instance?
08:21:56 <rostayob> yes
08:22:12 <rostayob> type var on the RHS => flexible instance
08:22:32 <rostayob> well
08:22:33 <mm_freak> ah…  type var at the top level
08:22:35 <rostayob> no
08:22:43 <rostayob> it's not exactly like i said
08:22:48 <rostayob> but that is a flexible instance
08:23:03 <_Mikey> its ok I've got it... I was trying to pattern match the whole record and it didn't like it.
08:23:07 <mm_freak> it's an MPTC, so my point about h98 was pointless anyway =)
08:23:11 <rostayob> yeah
08:23:20 <byorgey> _Mikey: it should be possible to pattern match the whole record.
08:23:30 <ozataman> is there a good example to that trick for passing an undefined into a function to fix down the type of some intermediate, otherwise not seen variable? I need to do something like "mkWorker (undefined :: MyData)" so the compiler knows which typeclass instances to use... I remember something like this, but just can't find any examples right now...
08:23:36 <mm_freak> somehow i thought that 'arrows' was an h98 library, but yeah, it wasn't written by edwardk
08:24:09 <mm_freak> ozataman: a proxy type might help
08:24:12 <_Mikey> byorgey, it should I guess but ghc complained, I have something similar to the second to last thing you pasted now.
08:24:25 <_Mikey> byorgey, can we still edit hpastes?
08:24:26 <mm_freak> ozataman: i think the library is called 'tagged'
08:24:37 <ozataman> mm_freak: let me take a look, thank you
08:24:42 <byorgey> _Mikey: you can't edit them but you can add annotations
08:25:16 <rostayob> mm_freak: most useful haskell code is not h98
08:25:37 <mm_freak> rostayob: another point against type operators is that in many font/size combinations the common ~> arrow is hard to tell from ->
08:25:39 <rostayob> whatever people say
08:25:44 <rostayob> mm_freak: that's a bonus!
08:25:48 <rostayob> but anyway, the noise will remain
08:26:11 <rostayob> i just wanted to read some code using a simple Automaton, instead of the transformer
08:26:16 <mm_freak> rostayob: no, it can be confusing, when you have both arrows, which is pretty common in arrow transformer context
08:26:25 <rostayob> mm_freak: yeah i was joking :)
08:26:37 <mm_freak> hence my usage of (>~) instead of (~>) =)
08:27:02 <rostayob> really? i've seen ~> in netwire
08:27:08 <rostayob> and I've copied you
08:27:14 <mm_freak> you most certainly haven't =)
08:27:36 <hpaste_> “_Mikey” annotated “instance Show Record” with “instance Show Record (annotation)” at http://hpaste.org/56844#a56845
08:27:50 <rostayob> oh then my eyes concluded that ~> was nicer
08:27:51 <_Mikey> what you pasted worked
08:28:12 <mm_freak> lol
08:28:23 <_Mikey> byorgey, but the last suggestion didn't
08:28:34 <_Mikey> which I tried first XD
08:28:38 <rostayob> mm_freak: but i took the type operator trick from you, it's actually pretty neat
08:29:03 <rostayob> mm_freak: the real programmer would use —>
08:29:18 <mm_freak> the real programmer would use →
08:29:31 <rostayob> mm_freak: isn't that already taken for functions?
08:29:38 <rostayob> or is that a supposedly longer one?
08:29:50 <mm_freak> good question
08:30:02 <rostayob> this: ↠
08:30:04 <mm_freak> well, there is also a unicode variant of ~>
08:30:23 <byorgey> _Mikey: it works for me.  Note I misspelled 'antId'
08:30:23 <rostayob> ⇶
08:30:35 <mm_freak> how about +?
08:30:44 <rostayob> ↣ this is pretty amazig
08:30:47 <_Mikey> oh no I saw that.
08:30:51 <mm_freak> newtype Auto (+) a b = Auto (a + (b, Auto (+) a b))
08:30:54 <mm_freak> =)
08:31:14 <rostayob> mm_freak: http://thc.org/root/phun/unmaintain.html
08:31:25 <rostayob> typedef struct { int i; } ínt;
08:31:32 <mm_freak> you have to admit, nobody uses (+) on the type level, so there is no way you could confuse that =P
08:31:44 <hpaste_> byorgey annotated “instance Show Record” with “pattern-matching using record syntax” at http://hpaste.org/56844#a56846
08:31:53 <byorgey> _Mikey: ^^^
08:32:07 <rostayob> Choose variable names that masquerade as mathematical operators, e.g.:
08:32:09 <rostayob>     openParen = (slash + asterix) / equals;
08:32:57 <rostayob> use define statements to make made up functions that simply comment out their arguments, e.g.:
08:32:59 <rostayob>     #define fastcopy(x,y,z) /*xyz*/
08:33:01 <rostayob>     ...
08:33:03 <rostayob>     fastcopy(array1, array2, size); /* does nothing */
08:33:05 <rostayob> I love that page.
08:33:08 <ozataman> mm_freak: any idea how I can pass in a phantom type and get a function to unify with that type for something like FromJSON?
08:33:35 <ozataman> I almost need a combinator that'll force the unification without actually using the first argument
08:33:39 <_Mikey> byorgey, yeesh! It does! Cheers man.
08:34:23 <rostayob> ozataman: I missed the first part, what's the problem?
08:35:27 <ozataman> rostayob: I have a bunch of functions that depend on the monoid typeclass for processing. now I want to write a generic "mkWorker" function to operate on these values. the operation goes something like serialize from db, use mappend, serialize back to somewhere else. problem is, the compiler has no way of knowing which instance of monoid should be used..
08:35:46 <ozataman> I can pull out the monoid instance and pass an explicit (a -> a -> a) to the mkWorker function, but that just doesn't seem nice
08:36:03 <rostayob> ozataman: wait, the compiler will know when you finally pass something with a monomorphic type
08:36:16 <ozataman> so I'm trying to get something like "mkWorker (undefined :: MyData)" to go figuour out that FromJSON MyData should be used for serialization, for example
08:36:32 <mm_freak> ozataman: as said, see the 'tagged' library
08:36:46 <ozataman> mm_freak: well, that library makes the (undefined ::) part better
08:37:12 <ozataman> I still need a way to unify the type there with FromJSON a
08:37:23 <mm_freak> it should also help with unification, because you can actually pass Proxy values around, and they take the phatom type with them along the way
08:37:33 <ozataman> rostayob: that's just it.. I end up never directly feeding a monomorphic type
08:37:37 <rostayob> ozataman: can't you simply give a new type to the function? mkWorker :: this -> that?
08:38:00 <ozataman> rostayob: all the values are already in the db, I'm just writing a function that will handle logistics and use mappend for the actual processing
08:38:21 <ozataman> rostayob: not sure if I follow
08:38:45 <mm_freak> ozataman: well, i'm not sure why you need a phatom type there…  perhaps an existential type is more like what you want?
08:38:52 <ozataman> mm_freak: I don't see how Tagged will fix something (undefined :: MyData) can't
08:39:01 <ozataman> if I know how to get the latter to work, then Tagged will just make it safer
08:39:09 <rostayob> 1) what do you mean "the compiler has no way of knowing which instance of monoid should be used"?
08:39:27 <ozataman> rostayob: ok. let me try to give a simple example. sec
08:39:35 <rostayob> yes that would help i think
08:39:48 <rostayob> if you mean that you're always working with polymorphic data
08:40:13 <mm_freak> ozataman: just to understand the problem…  you have a computation that will, at some point, receive a value from outside of a certain type…  and you just want to specify that type and along that way also require a Monoid instance for the processing
08:40:29 <mm_freak> correct?
08:40:34 <rostayob> then you want to enforce some monomorphic type at some point, and you can do it both on the value (foo :: Data) both on the function (function :: Data -> Foo)
08:40:47 <ozataman> mm_freak: nope. it will never get the type
08:40:55 <rostayob> if you mean that you have undecidable instances, then...
08:41:02 <ozataman> err, the value, rather
08:41:14 <mm_freak> ozataman: then on what are you using mappend?
08:41:52 <etpace> I have a question on how the STG machine is implemented: When I force an updateable thunk that returns a data value, we enter the data values code with a vectored return, and in that vectored return we have a pointer to jump to saying "overwrite closure with this value" -- but what about if a thunk returns a function value -- the functions code pointer is indeed just the code to execute that function, so how do we perform updating?
08:41:54 <rostayob> ozataman: so your problem is that you've got something '(Monoid a, Serializable  a => a)' and you can't actually serialize it?
08:42:09 <rostayob> because the type is polymorphic
08:42:15 <rostayob> right?
08:43:03 <ozataman> http://hpaste.org/56848
08:43:36 <ozataman> rostayob, mm_freak: the first bit there obviously has no clue which instances to use for antying
08:43:38 <rostayob> ozataman: just pass functions
08:43:42 <ozataman> right
08:43:50 <ozataman> exploring a way to avoid that
08:43:51 <rostayob> mkWorker :: (a -> a) -> whatever
08:43:53 <rostayob> ah
08:44:02 <rostayob> mhm...
08:44:09 <ozataman> I could rewire the whole thing to get it to work that way for sure
08:44:17 <Enigmagic> etpace: the update code lives on the stack (StgUpdFrame), and values can also be pointers they'll just have a different type than StgClosure, like StgAP
08:44:39 <rostayob> ozataman: I can't see another way. note that you only need id and ScopedTypeVariable
08:44:48 <rostayob> mkWorker (id :: This -> This)
08:44:55 <mm_freak> ozataman: you want to be able to /select/ the type?
08:44:55 <Sgeo> Can I make GHC error instead of warn if I don't explicitly discard the ... thing?
08:45:10 <Saizan> ozataman: it's pretty simple, mkWorker phatom = do ....; putToSomewhereElse (singleX `asTypeOf` phatom)
08:45:10 <Sgeo> Such as, if I do a >> b where a is m s and s is not ()
08:45:11 <Enigmagic> etpace: function pointers, i meant :)
08:45:17 <ozataman> mm_freak: yep, because there could be multiple types stored in the DB on which there will be different operations based on the mappend instance
08:45:26 <rostayob> Sgeo: he wants to be able to select a different type each time
08:45:28 <ozataman> Saizan: aha!!!
08:45:34 <mm_freak> then either use ScopedTypeVariables or asTypeOf
08:45:38 <rostayob> ah, right
08:45:39 <Sgeo> rostayob, I wasn't responding to anyone else
08:45:40 <rostayob> that would work as well
08:45:45 <rostayob> Sgeo: sorry that was for Saizan
08:45:49 <etpace> Hmm.. ok thanks Enigmagic -- I think I need to reread the operational semantics -- I dont think I've totally groked how it works yet
08:46:00 <etpace> Especially the whole triple stack -> double stack conversion
08:46:08 <rostayob> ozataman: why is that nicer than using id?
08:46:09 <ozataman> Saizan: that's exactly what I was trying to find :))
08:46:23 <ozataman> rostayob: good point, that's another solution!
08:46:54 <Enigmagic> etpace: the actual objects allocated on the heap are mostly laid out here https://github.com/ghc/ghc/blob/master/includes/rts/storage/Closures.h
08:47:26 <rostayob> ozataman: I think passing a function is better, and you don't have to fiddle with (undefined :: Whatever)
08:47:29 <mm_freak> mkWorder :: forall e. (Monoid e) => e -> IO () …  (singleX :: e)
08:47:37 <mm_freak> that's the ScopedTypeVariables variant
08:48:41 <Saizan> data Proxy e = Proxy is a way to avoid undefined
08:48:46 <Enigmagic> etpace: where StgAP/StgPAP are for functions (fully applied and partially applied) and StgClosure/StgThunk are the common things that hold values
08:48:59 <rostayob> ozataman: btw, I'd do the getting and serializing separatedly, and then just do 'manyXs :: whatever <- getXs'
08:49:04 <ozataman> rostayob: great, with the id version, I just apply id to whatever fromJSON returns and done. can't believe I missed that...
08:49:21 <ozataman> mm_freak: how would that work with singleX :: e - I don't know the e at the time I'm writing the mkWorker function
08:49:32 <rostayob> ozataman: well you still have to pass a function which is annoying
08:49:53 <mm_freak> ozataman: it's an argument to mkWorker…  but as said, you really should use the tagged library
08:49:55 <Saizan> ozataman: the e is the one bound in mkWorker's signature in that case
08:50:00 <ozataman> rostayob: I'm happy to pass a function to mkWorker.. in any case, I'll call mkWorker once per the data group being operated on
08:50:31 <ozataman> aaahhh that's right the ScopedTypeVariables lets you use the originally bound variables
08:50:55 <rostayob> oh true, that works as well
08:51:03 <ozataman> thanks all, I'm properly humbled once again :)
08:52:32 <rostayob> ozataman: yw... these are all hackish solutions btw. the real solution is mkWorker : {t} -> IO a :)
08:52:38 <Veinor> i need to store a bunch of ints
08:52:45 <Veinor> what's the 'best' way to do that?
08:52:51 <Veinor> er
08:52:52 <ozataman> rostayob: :)
08:52:53 <Veinor> store in a database
08:53:04 <nand`> reading through an introduction on agda
08:53:09 <nand`> not sure if my brain will have recovered by tomorrow
08:57:06 <mike-burns> Veinor: serialize them.
08:59:37 <rostayob> Veinor: store them in some data structure, and store the whole data structure in a file using Binary & co.
09:00:31 <mike-burns> He just added an additional constraint IRL: multiple processes will want to write a list of ints to the same DB.
09:00:39 <mike-burns> And another: it's actually an array of size four.
09:01:08 <rostayob> Veinor: use acid-state
09:01:51 <rostayob> one of my all time favourites when speaking of haskell libraries.
09:03:04 <mm_freak> rostayob: that unmaintain page you linked…
09:03:13 <mm_freak> isn't that a perl tutorial?
09:03:15 <rostayob> mm_freak: great isn't it?
09:04:09 <rostayob> it applies to a lot of languages.
09:04:45 <rostayob> "Pepper the code with comments like /* add 1 to i */ however, never document wooly stuff like the overall purpose of the package or method."
09:12:25 <rostayob> is there a tutorial on how to work with multiple versions of GHC/platform/cabal?
09:14:43 <donri> "step 1: install virthualenv, step 2: use virthualenv"
09:14:55 <irene-knapp> actually, I work with multiple versions without it
09:14:59 <irene-knapp> but no, I've never written up how
09:15:17 <Saizan> ghc has versioned binaries, so that's not much of a problem
09:15:19 <byorgey> stow is also helpful
09:15:24 <Saizan> but some other tools don't
09:15:28 <cmccann> my approach is to just install stuff haphazardly and then grumble when it all breaks
09:15:44 <cmccann> it works well except when it doesn't
09:16:00 <Saizan> you can specify which ghc to use with -w to cabal
09:16:19 <Saizan> packages are kept separate
09:16:36 <rostayob> Saizan: ah. like cabal -w whatever install foo?
09:17:01 <Saizan> the -w goes after install
09:17:34 <rostayob> ok, that's very interesting, thanks
09:17:49 * gwern feels very pleased with his new haskell-src-exts program to count the number of function uses in a set of files
09:18:20 <gwern> (didn't figure out how to cut out variables, but oh well, on a large corpus the functions will drown out the bindings)
09:19:30 <rostayob> Saizan: how is the "default" ghc decided?
09:20:10 <donri> probably ghc in $PATH
09:20:24 <Saizan> yes
09:20:59 <hpaste_> gwern pasted “function counter” at http://hpaste.org/56850
09:21:37 <gwern> '("getArgs",23) ("length",23) ("mother",24) ("args",25) ("f",25) ("father",25) ("putStrLn",27) ("ns",28) ("p",28) ("t",31) ("a",38) ("c",40) ("n",45) ("map",68) ("s",68) ("show",73) ("x",80) ("return",111)' <-- or the variable names don't wash out, well, one can live with that...
09:22:47 <rostayob> ok, it works, but I have some problems with haddock apparently
09:22:50 <byorgey> mother? father?
09:22:57 <donri> --with-haddock=PATH
09:23:23 <rostayob> donri: oook. thanks.
09:23:34 <gwern> byorgey: I dunno either. I'm starting a run on my entire corpus
09:23:56 <byorgey> gwern: fair enough.
09:28:13 <gwern> byorgey: would you like a copy of the full run? it'll be pretty big
09:29:02 <byorgey> gwern: what exactly is it? A count of references to identifiers in all the code on Hackage?
09:29:14 <aavogt> gwern: haskell src exts can parse everything on hackage?
09:29:29 <gwern> not hackage, my local collection - c.h.o, patch-tag, github, misc
09:29:41 <byorgey> ok
09:29:50 <byorgey> anyway, sounds interesting
09:29:57 <gwern> aavogt: well, I know this code can parse *most* of what I have, but I don't know how much is left
09:30:47 <aavogt> I think you have to go to some effort to figure out which extensions are enabled in the .cabal file (and not with LANGUAGE pragmas)
09:31:21 <aavogt> and I think even then there are (or at least were) some files ghc could accept that hsx didn't
09:33:04 <gwern> bleh. 'function-counter: Ambiguous infix expression'. enable printing out the filename, and then begin debugging...
09:34:50 <thlorenz> I'm using TagSoup and want to change this "let hrefs xs = filter  (~== "<a href>") xs" into points free style
09:34:57 <aavogt> gwern: probably haskell-src-exts still doesn't look through all the source it has to find infix decls
09:35:14 <gwern> @pl hrefs xs = filter  (~== "<a href>") xs
09:35:14 <lambdabot> (line 1, column 10):
09:35:14 <lambdabot> unexpected "="
09:35:14 <lambdabot> expecting variable, "(", operator or end of input
09:35:15 <cmccann> it doesn't look through any last I checked
09:35:22 <aavogt> so it doesn't know what the precedence is (you can specify a list / go through your files first to check / ask ghc)
09:35:23 <cmccann> you have to give it a list of fixities
09:35:23 <thlorenz> type of hrefs is hrefs :: StringLike str => [Tag str] -> [Tag str]
09:35:38 <gwern> cmccann: yeah, but if you look at my source, I do
09:35:58 <gwern> thlorenz: does just deleting the xs not work?
09:36:01 <thlorenz> when I remove xs, I get the ambiguous type variable … constrain error
09:36:07 <cmccann> gwern, ah, hm
09:36:24 <thlorenz> I can't figure out how to properly constrain the type
09:36:37 <aavogt> @google monomorphism restriction
09:36:38 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:36:38 <lambdabot> Title: Monomorphism restriction - HaskellWiki
09:37:17 <thlorenz> I thought this should have worked "let a = filter (\x -> x ~== "<a href>") :: Text.StringLike.StringLike str => [Tag str] -> [Tag str]" but it didn't
09:38:05 <aavogt> thlorenz: put the signature like:         let a :: StringLike str => [Tag str] -> [Tag str]; a = filter ...
09:39:48 <thlorenz> thanks aavogt that worked perfectly
09:40:11 <thlorenz> I guess inlining the type wouldn't have worked at all in that case?
09:41:18 <aavogt> right. Because the MR says that definitions that don't look like functions should be things that can be shared once computed the first time
09:41:44 <gwern> what the heck function-counter:1:1: lexical error at character '\DEL'
09:42:21 <aavogt> and they weren't fancy enough when defining the MR to say "if you have a type signature inline, that's a good as one above the definition"
09:42:34 <Enigmagic> gwern: processing a file that isn't haskell source?
09:42:44 <gwern> Enigmagic: they all have .hs in the name...
09:43:21 <aavogt> you could re-write it to use ghc's parser somehow
09:43:46 <aavogt> maybe through the output of one of the -ddump-* flags
09:46:10 <aavogt> gwern: how about first running   ghc -ddump-parsed?
09:46:43 <byorgey> gwern: 'function-counter' does not end with .hs.
09:47:39 * aavogt guesses it's a bit of work to cut out the
09:47:41 <aavogt> ==================== Parser ====================
09:47:58 <gwern> byorgey: so?
09:48:43 <byorgey> gwern: well, often errors like that tell you the entire file name
09:49:29 <byorgey> gwern: I just created a file with a bad character in it and got the error message "Foo.hs:1:1: lexical error at character '\EOT'"
09:49:30 <gwern> aavogt: I dunno if the -ddump-parsed flag would rewrite any source, but I'll give it a try if I run into something bad
09:49:41 <nand`> is Data.Map based on self balancing binary search trees?
09:50:19 <scooty-puff> what is the purpose of AGraph in hoopl?
09:50:20 <byorgey> nand`: no, they are balanced by the code in Data.Map
09:50:29 <ddarius> @hoogle digitToInt
09:50:29 <lambdabot> Data.Char digitToInt :: Char -> Int
09:50:30 <byorgey> self-balancing trees would require some sophisticated AI
09:50:35 <ddarius> > digitToInt 'a'
09:50:35 <lambdabot>   10
09:51:05 <monochrom> in which case the tree still doesn't balance itself, it is balanced by AI
09:51:14 <thlorenz> is there a way to make something that uses pattern matching into points free definition
09:51:25 <byorgey> monochrom: good point
09:51:28 <ion> > digitToInt 'g' -- :-(
09:51:29 <lambdabot>   *Exception: Char.digitToInt: not a digit 'g'
09:51:34 <byorgey> I guess you also need an object-oriented language
09:51:35 <Eduard_Munteanu> thlorenz: you could use something like...
09:51:37 <Eduard_Munteanu> :t maybe
09:51:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:51:49 <thlorenz> I'm particularly trying to do this for "extractLink (TagOpen tag xs) = (snd . head) xs
09:51:50 <thlorenz> "
09:51:50 <Chaze> meh, how is "Either e for a fixed e" an instance of Functor?
09:52:14 <gwern> thlorenz: areyou trying to obfuscate your program or something?
09:52:25 <mauke> Chaze: how isn't it?
09:52:29 <byorgey> Chaze: instance Functor (Either e) where ...
09:52:30 <ion> I don’t get the arbitrary restriction to base-16 in digitToInt.
09:52:38 <thlorenz> nope, just trying to figure out how to create functions that compose nicely
09:52:39 <byorgey> Chaze: is there a particular part of the fmap definition you're having trouble with?
09:52:46 <nand`> Chaze: fmap _ (Left e) = Left e; fmap f (Right x) = Right (f x)
09:52:53 <monochrom> a self-balancing tree is like a self-debugging program
09:53:14 <nand`> Chaze: (Either e x) is like (Maybe x) except instead of Nothing you have (Left e)
09:53:37 <Chaze> how can i have a function f that works either on the left, or right type of my either?
09:53:41 <Eduard_Munteanu> monochrom: I would've thought self-balancing meant a tree which is always balanced by construction, no?
09:53:47 <hpc> :t either
09:53:48 <monochrom> we could use some self-maintaining packages on hackage
09:53:48 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
09:53:55 <ddarius> @hoogle FastSet
09:53:55 <lambdabot> No results found
09:53:55 <thlorenz> so is there a way to remove the xs from: "extractLink (TagOpen tag xs) = (snd . head) xs" ?
09:53:55 <hpc> :t join either ?f
09:53:56 <lambdabot> forall a c. (?f::a -> c) => Either a a -> c
09:54:02 <hpc> Chaze: ^
09:54:02 <ion> I wouldn’t mind self-documenting packages.
09:54:11 <hpc> Chaze: for some value of f
09:54:20 <Eduard_Munteanu> Ah, no, I guess I'm thinking about something else.
09:54:30 <hpc> (join f x = f x x
09:54:31 <hpc> )
09:54:35 <Eduard_Munteanu> Like dancing trees.
09:55:02 <Eduard_Munteanu> (but that's the opposite)
09:55:03 <Chaze> nand`: so you simply apply f only on the Right-types
09:56:05 <nand`> Chaze: seeing as ‘e’ is “locked”, yes
09:56:39 <aavogt> thlorenz: TagOpen might be defined like                  data Tag a = TagOpen { tag :: a, xs :: [a] }, in which case you can use the function xs (or whatever it is actually called) to get the second argument to the TagOpen constructor
09:56:44 <ddarius> preflex: seen bos
09:56:45 <preflex>  bos was last seen on #ghc 8 days, 21 hours, 53 minutes and 14 seconds ago, saying: okey dokey
09:56:49 <gwern> huh... apparently the /DEL error was coming from not invoking it iwth .hs
09:57:04 <byorgey> Chaze: f :: a -> b  does not have the right type to be applied to the stuff in Left
09:57:07 <nand`> and by “locked” I mean fmap can't change the type of e since fmap :: (a -> b) -> (f a -> f b) and if f = “Either e” then it has type :: (a -> b) -> (Either e a -> Either e b)
09:57:15 <byorgey> gwern: oh, weird
09:57:32 <Chaze> yeah, that makes sense now
09:57:34 <Chaze> thx
09:57:37 <nand`> from this signature it's visible how f only gets applied to the Right hand side, if any
09:59:35 <thlorenz> thanks aavogt, I'll give it a try (btw TagOpen is defined like this: "data Tag str
09:59:35 <thlorenz>   = TagOpen str [Attribute str]"
10:00:11 <aavogt> then you'll have to define a function (with pattern matching) to get at the that list
10:01:07 * gwern tosses '#' into the infix list
10:01:12 <thlorenz> aavogt understood, so pattern matching is the only way then?
10:03:48 <nand`> Creating a BST from a list is O(n log n) right
10:04:09 * gwern wonders what the heck is >==
10:04:13 <aavogt> depends what you interpert as pattern matching. You could use methods in the Data class (ghc can write the instance for you) to get at that list too
10:04:16 <nand`> gwern: do you mean >>=?
10:04:23 <gwern> no, I mean >==
10:04:34 <parcs`> @hoogle >==
10:04:34 <lambdabot> No results found
10:04:47 <gwern> probably from Control.ShiftResetGenuine... leave it to oleg
10:04:59 <ion> It’s greater than or equal to or equal to.
10:05:50 <nand`> ion: my first thought was something like (Ord a) -> (a -> a) -> Bool -> Bool; which wouldn't have made an awful lot of sense since one can just use (not) instead
10:06:07 <aavogt> thlorenz: while that kind of stuff can be useful, it isn't a good choice if you can accomplish the same thing with such a simple pattern match
10:06:08 <monochrom> yes O(n log n)
10:07:16 <thlorenz> aavogt ok, I just wanted to isolate the url extraction via pattern match. Right now I got this and am happy with it:
10:07:18 <thlorenz>         getLink = snd . head . getUrls
10:07:18 <thlorenz>         getUrls (TagOpen tag urls) = urls
10:08:15 <aavogt> but again you probably run into the monomorphism restriction (which you can turn of in GHC by the way)
10:08:16 * gwern adds '>.', again courtesy of oleg
10:09:03 <aavogt> gwern: there ought to be an automated way of doing that
10:09:22 <gwern> aavogt: there is an automated way. the automated way is what I'm fixing...
10:09:24 <monochrom> if you like pointfree definitions like "f = sum . map id", turn off the monomorphism restriction
10:09:53 <Oxryly> is there a pretty print in haskell?
10:10:00 <monochrom> or, by an ironic twist of logic, turn on NoMonomorphsimRestriction
10:10:11 <donri> Oxryly: you mean like show?
10:10:19 <donri> but formatted
10:10:23 <byorgey> Oxryly: there are several libraries for doing pretty-printing
10:10:25 <donri> @hackage groom
10:10:26 <lambdabot> http://hackage.haskell.org/package/groom
10:10:48 <monochrom> GHC comes with a pretty printing lib. Text.PrettyPrint.HughesPJ
10:10:50 <donri> "pretty printing" seems to have a different meaning in haskelland
10:11:20 <hpc> > compare "tex" "pretty printing"
10:11:20 <lambdabot>   GT
10:11:42 <monochrom> TeX is ugly-printing
10:11:55 <donri> @hackage pretty-show
10:11:56 <lambdabot> http://hackage.haskell.org/package/pretty-show
10:11:58 <donri> also
10:12:16 <aavogt> @hackage IPPrint
10:12:16 <lambdabot> http://hackage.haskell.org/package/IPPrint
10:12:27 <aavogt> @hackage ipprint
10:12:27 <lambdabot> http://hackage.haskell.org/package/ipprint
10:12:37 <gwern> tex is a demonstration of anti-entropy - that even the most disordered of things can give rise to order
10:13:03 <rostayob> yeah, sadly.
10:13:10 <donri> @hackage data-pprint
10:13:11 <lambdabot> http://hackage.haskell.org/package/data-pprint
10:14:39 <monochrom> be careful with the @hackage command. it does not check errors
10:15:05 <Oxryly> ok cool these look good... thanks
10:15:22 <hpc> @hackage base'); DROP TABLE users; --
10:15:22 <lambdabot> http://hackage.haskell.org/package/base'); DROP TABLE users; --
10:15:45 <monochrom> fortunately, lambdabot doesn't even know SQL
10:16:06 <Oxryly> none of these are including in the platform, right?
10:16:13 <Oxryly> including -> included
10:16:24 <monochrom> Text.PrettyPrint.HughesPJ comes with GHC
10:16:28 <nand`> monochrom: am I the only one who thinks map id is an awfully tautological function
10:16:59 <byorgey> Oxryly: the 'pretty' package is in the Platform
10:17:00 <monochrom> I don't know
10:17:23 <donri> Oxryly: it would be useful if you explain which sort of pretty printing you're looking for
10:17:41 <donri> it has two distinct meanings
10:17:41 <byorgey> nand`: map id is, in fact, equivalent to id
10:18:04 <hpc> it is, in fact, a functor law
10:18:10 <nand`> byorgey: assuming [] follows the functor laws
10:19:39 <byorgey> nand`: types do not follow or not-follow functor laws.
10:19:46 <byorgey> nand`: and 'map' does indeed follow the functor laws.
10:19:57 <aavogt> byorgey: it might be possible to construct a case where replacing "map id" with id will prevent a stack overflow
10:19:58 <nand`> the [] implementation of Functor*
10:20:01 <davv3_> hi. im trying to write a recursive function that calls on itself twice. in C i would simply put them in brackets {} but i cannot figure out how to do something equivelant in haskell, ideas?
10:20:08 <nand`> then again map isn't defined as fmap in Prelude, is it
10:20:17 <hpc> @src map
10:20:17 <lambdabot> map _ []     = []
10:20:17 <lambdabot> map f (x:xs) = f x : map f xs
10:20:22 <hpc> @src [] fmap
10:20:22 <lambdabot> fmap = map
10:20:29 <nand`> ah, other way around
10:20:33 <byorgey> aavogt: true. If you care about that then I must qualify that by "equivalent" I mean "semantically equivalent".
10:21:11 <nand`> davv3_: not sure I understand your question. Calls on itself twice?
10:21:20 <byorgey> davv3_: what is the type of your function?
10:21:21 * monochrom harps his rhetoric again. which "semantically"? operational-semantically?
10:21:55 <byorgey> ah. I must further qualify that by "semantically" I always mean "denotational semantics"
10:21:57 <davv3_> its a binary recursive function, it would call itself with different arguments (twice)
10:22:18 <byorgey> davv3_: well, you need to figure out how you want to combine the results from those two recursive calls
10:23:46 <davv3_> byorgey: ok
10:24:15 <byorgey> davv3_: if you paste what you have on hpaste.org someone can probably take a look
10:25:17 <nand`> > let add 0 n = n; add m n = add (pred m) (succ n) in add 4 5 -- davv3_
10:25:19 <lambdabot>   9
10:26:00 <Ngevd> > let add 0 n = n; add m n = add (pred m) (succ n) in add 'a' 'A'
10:26:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:26:02 <lambdabot>    arising from a use of `add'...
10:26:09 <Ngevd> Missed the 0
10:27:22 <davv3_> http://sprunge.us/BTSQ?hs
10:27:25 <hpaste_> edwardk pasted “categorical silliness” at http://hpaste.org/56852
10:27:35 <davv3_> apologize if its not very clear what i am doing
10:27:47 <davv3_> the commented line is what i would prefer for it to do.
10:28:42 <davv3_> i know logical operator && is not applicable there
10:28:56 <byorgey> davv3_: ok. so what do you want to do instead of && ?
10:29:15 <byorgey> you get two Ints back from the two recursive calls, and you have to return a single Int
10:29:25 <byorgey> or do you want robot to return multiple Ints?
10:29:58 <davv3_> i would like it to return n when function check returns 1
10:30:12 <byorgey> right, that's the first line
10:31:40 <byorgey> davv3_: and otherwise...?
10:33:17 <davv3_> for it to keep recursing. maybe a edge?
10:33:24 <davv3_> define an edge
10:33:29 <byorgey> an edge?
10:33:40 <davv3_> halt condition
10:34:02 <nand`> the halt condition is check str 0 == 1
10:34:19 <nand`> if you want another, you'll have to add another bar
10:34:34 <byorgey> davv3_: so it "keeps recursing", but eventually what sort of result do you expect to get?
10:34:46 <byorgey> a single number? a bunch of numbers?
10:35:18 <davv3_> a single number, the depth of the binary tree where it matches check
10:36:29 <byorgey> davv3_: ok.  So in the otherwise case you call robot twice.  Each one gives you back a single number.  You need to take those numbers and combine them somehow to give you the answer for the original call to robot
10:37:15 * elliott (doesn't know the context, but maybe the function has to return Maybe Int(eger) instead?)
10:37:37 <byorgey> ah, that might be so
10:37:56 <byorgey> it seems there are not really enough halting conditions
10:38:09 <elliott> it seems like if one branch of the binary tree meets the condition, and the other doesn't
10:38:20 <elliott> then you'll want the return value to be Just (1 + depth) of the branch that meets it
10:38:37 <elliott> of course, what to do when /both/ branches match isn't clear...
10:39:10 <davv3_> ok got some ideas. let me try :)
10:39:16 <nand`> elliott: seems to me the correct return type would be [Int], a list of all depths at which it was found
10:39:26 <nand`> assuming it can occur multiple times
10:40:17 <rostayob> repa does N-dimensional arrays with unboxed data. is there some library like that for normal data?
10:40:29 <elliott> nand`: that is a more complicated task to implement, though :P
10:40:41 <elliott> rostayob: Data.Array?
10:40:46 <rostayob> elliott: did you manage to write that instance? I'm going crazy here
10:40:52 <elliott> rostayob: You could use repa by sticking things into StablePtrs, maybe.
10:40:53 <rostayob> elliott: you mean with tuple as indices?
10:41:07 <elliott> Yes. I wouldn't suggest actually using Data.Array, though.
10:41:18 <rostayob> yeah, I don't like Data.Array
10:41:27 <elliott> rostayob: The instance -- I wrote about five instances, all of which worked perfectly except for one missing variable that had to magically cross over a lambda somehow :P
10:41:30 <rostayob> I mean I'd like something with the concept of dimension built in
10:41:42 <rostayob> elliott: ah! paste somewhere!
10:41:54 <rostayob> so wait
10:42:01 <rostayob> the "except ..." means that they actually didn't work?
10:42:05 <elliott> That's another way of saying they were totally broken. :/ I do have an idea for one that might work, though, based on the definition of "first" in Generalizing Monads to Arrows.
10:42:10 <rostayob> ah, ok.
10:42:14 <rostayob> damnit.
10:42:31 <rostayob> did my 'first' make sense?
10:43:06 <elliott> rostayob: I didn't look too closely at it, but it seemed a little too simple; Hughes' uses a where-clause definition with a list
10:43:12 <elliott> because of some "trickiness" that I didn't bother actually reading, hehe
10:43:31 <rostayob> elliott: yeah, that's likely. mine works to do basic stuff not involving strange recursions
10:43:52 <elliott> It's more about "buffering", I think.
10:44:14 <elliott> rostayob: If you do five gets and then five puts, I think it's meant to reuse the second tuple element from the five gets.
10:44:19 <rostayob> elliott: I wrote a buffering instance that works, but not for loop (arr id). that's the case that i don't get.
10:44:23 <elliott> At least that's how Hughes' works.
10:44:30 * elliott is talking about first, not loop :P
10:44:32 <rostayob> ah you were talking of first?
10:44:34 <rostayob> ah
10:44:56 <rostayob> ah. why would that be necessary?
10:44:59 * elliott is interested in your buffering implementation of loop, though; I had an idea involving a buffering list but couldn't think how to make it work
10:45:06 <elliott> rostayob: well consider five gets
10:45:10 <elliott> and then five (Put ())s
10:45:13 <elliott> yours does ten gets
10:45:22 <elliott> and discards the second tuple elements of the first five
10:45:32 <elliott> whereas Hughes' goes through the second tuple elements of the five gets in order for the Puts
10:45:41 <hpaste_> rostayob pasted “possibly broken ArrowLoop instance” at http://hpaste.org/56854
10:45:46 <elliott> hmm
10:45:51 <elliott> yours supports Put right after Get
10:45:56 <elliott> but I don't know if that's enough when you have multiple Gets
10:46:09 <elliott> rostayob: a Seq is way too strict for that I think
10:46:27 <rostayob> elliott: mhm.... yeah i didn't pay much attention
10:46:38 <rostayob> since the interesting case (loop returnA) didn't work
10:46:47 <elliott> hmm...
10:47:21 <elliott> I was under the impression that runSP (loop . Get $ \(_,d) -> Put (d,1234)) [()] --> [1234]
10:47:33 <elliott> it's not really a fixed point if you have to give the result before using it :P
10:48:14 <rostayob> elliott: yeah, so my instance is broken for the "interesting" case (the feedback one)
10:50:42 <rostayob> elliott: I still find it funny that that's the first exercise
10:53:26 <rostayob> elliott: going back to my original question, alternatives to Data.Array for N-dimensional arrays?
10:53:50 <kkrev> how do I get ghci to use vi keybindings? My installation defaults to emacs. rlwrap usually works fine (makes my .inputrc settings apply) but it does not seem to work for ghci.
10:54:29 <parcs`> kkrev: http://trac.haskell.org/haskeline/wiki/UserPrefs
10:54:34 <elliott> rostayob: repa + StablePtr could work like I said
10:54:40 <elliott> or you could just unbox your data :P
10:54:47 <rostayob> elliott: it's nested arrays
10:54:51 <elliott> hmm, is overflow on Ints defined? like (maxBound + 1 :: Int), in the Report
10:54:56 <hape01> module star where \n  open import Data.Star  is valid Haskell Syntax? I didn't see the "open" in front of an import before.
10:55:02 <elliott> rostayob: ah. just roll your own indexing functions with Vector? you'll lose the automatic parallelism stuff
10:55:14 <elliott> hape01: no
10:55:22 <elliott> "module star" isn't valid either
10:55:35 <hape01> ok than it is not haskell. What is it?
10:55:41 <parcs`> it's probably agda
10:55:46 <rostayob> elliott: mh. yeah I wanted to avoid that
10:55:48 <rostayob> thanks
10:55:55 <jmcarthur> looks like agda to me
10:56:02 <kkrev> parcs`: much thanks. that works.
10:56:06 <hape01> it is this:
10:56:12 <hape01> http://hpaste.org/56852
10:56:33 <elliott> hape01: That does not contain "module star" or "open import Data.Star".
10:56:36 <elliott> I think "open import" is an Agda thing.
10:56:39 * Sgeo is beginning to think he should use ResourceT internally
10:56:41 <jmcarthur> i don't see what you are talking about at that link
10:56:47 <elliott> But you'll have to link to the actual code to be sure.
10:56:55 <elliott> http://hpaste.org/56851 this?
10:56:57 <elliott> That's Agda.
10:58:01 <hape01> thanks
10:58:26 <kallisti> can you use as-patterns with NamedFieldPuns?
10:58:35 <kallisti> Record {pun@(Con a b c)}   ?
10:59:21 <rostayob> kallisti: thhat's not a valid pattern without the @ as well
10:59:25 <parcs`> Record {pun@Con{..},..}
10:59:55 <rostayob> kallisti: maybe Record { a = pun@(Con a b c) }?
11:00:12 <kallisti> rostayob: yes that's how it would work without record puns
11:00:13 <parcs`> yeah, Record {con = pun@Con{..},..}
11:00:24 <kallisti> that wasn't really my question though. I know how to write it otherwise.
11:00:42 <parcs`> well that's using as-patterns with namedfieldpuns no?
11:00:44 <kallisti> I guess I can just try it and see.
11:00:49 <rostayob> kallisti: you can also write (Record pun@(Con a b c) _ _ ...)
11:01:07 <kallisti> parcs`: no because you're explicitly writing the constructor field and the pattern variable
11:01:20 <kallisti> namedfieldpuns look like Record {field1, field2, field3}
11:01:40 <parcs`> oh right, i'm thinking of recordwildcards
11:01:48 <rostayob> kallisti: data Foo = Foo {a::blah, b::baz} can be treated as Foo (a :: blah) (b :: baz), if that's your question
11:01:55 <rostayob> otherwise, I don't understand :P
11:01:56 <kallisti> rostayob: that is not my question
11:02:03 <rostayob> ok, I don't understand
11:02:07 <kallisti> indeed not.
11:02:27 * elliott wishes NamedFieldPuns was deprecated.
11:02:30 <parcs`> > let (Node {rootLabel}) = Node () [] in ()
11:02:31 <lambdabot>   Illegal use of punning for field `rootLabel'
11:02:31 <lambdabot>  Use -XNamedFieldPuns to permi...
11:02:39 <parcs`> stupid lambdabot
11:02:50 <rostayob> oh, that language extension.
11:02:55 <kallisti> elliott: oh hi. in favor of what?
11:03:03 <elliott> Nothing at all.
11:03:08 <kallisti> oh, yes that works.
11:03:09 <ornicar> I wonder why in haskell, multiplicity is called [a] instead of, say, Many a
11:03:13 <parcs`> > let (Node {subForest@(x:xs)}) = Node () [] in ()
11:03:14 <lambdabot>   <no location info>: parse error on input `@'
11:03:18 <elliott> It encourages people to shadow global names.
11:03:21 <rostayob> yeah
11:03:25 <elliott> It encourages people to shadow global names *with values of a different type*. It's evil.
11:03:30 <parcs`> so w
11:03:32 <parcs`> what
11:03:35 <rostayob> i don't like that extension. my brain erases gross things like that.
11:03:41 <kallisti> parcs`: hm, so, no.
11:03:51 <kallisti> it /could/ make sense if it worked.
11:03:54 <kallisti> but it doesn't.
11:03:54 <elliott> I wonder if -Wall yells at you for shadowing with NamedFieldPuns.
11:03:58 <parcs`> nope
11:04:00 <parcs`> thank god
11:04:01 <Ngevd> I am not familiar with NamedFieldPuns
11:04:17 <Ngevd> There are many things I am not familiar with.
11:04:30 <elliott> parcs`: You won't be thanking anyone when you decide to try and access a single field of another record somewhere within a function that happens to have a named field pun somewhere.
11:05:00 <parcs`> recordwildcards and namedfieldpuns aren't bad because the only names you'll be shadowing will definitely have a different type than what the name will be bound to
11:05:20 <parcs`> so there will be never be any ambiguity
11:05:33 <kallisti> to the compiler at least, excluding typeclass hacks.
11:05:38 <rostayob> it's really confusing to read.
11:05:46 <elliott> parcs`: Name shadowing is OK when it's more confusing?
11:05:54 <rostayob> expecially since most recods are like fooBar where foo is the data type name
11:06:42 <parcs`> it's ok for records
11:07:11 <rostayob> this reminds me that records suck in haskell :(
11:07:49 <elliott> Nobody would use named field puns if you could write foo.x or whatever rather than (fooX foo).
11:07:55 <chrisdone> did anyone get encoding to compile on ghc7.2.*?
11:08:33 <rostayob> there ah huge discussion on the ghc mailing list
11:08:44 <rostayob> should read it sometime
11:08:53 <elliott> http://hackage.haskell.org/packages/archive/encoding/0.6.6/logs/failure/ghc-7.2
11:08:55 <kallisti> elliott: my only complaint with that is that . is going to be massively overloaded.
11:09:01 <elliott> chrisdone: looks like it might be an easy fix
11:09:26 <elliott> kallisti: # or @ or $ or £ or `, I don't care.
11:09:33 <kallisti> '  :)
11:09:41 <elliott> (Foo.x) is already "unsafe" so I don't mind making (foo.x) unsafe too.
11:09:55 <kallisti> aaaaaaah
11:10:05 <elliott> Unless people think reformatting their code once their pipeline happens to start containing a constructor is reasonable.
11:10:26 <Sgeo> Is there a function like ResourceT m a -> ResourceT m (ReleaseKey, a)?
11:10:27 <kallisti> I guess it's no big deal if you (unlike me) put spaces between all of your compositions
11:10:31 <kallisti> for small compositions I leave them out sometimes.
11:10:51 <Sgeo> To grab a release key that when released will release everything in the given resourcet, usable withing a resourcet?
11:10:52 <kallisti> Sgeo: I'm assuming you've tried hoogle?
11:11:05 <kallisti> oh
11:11:10 <kallisti> I bet it doesn't list ResourceT stuff.
11:11:14 <kallisti> it might.
11:11:17 <dmwit> Is there a way to make a documentation page like Hackage's without uploading to Hackage?
11:11:35 <Sgeo> dmwit, haddock
11:11:54 <dmwit> Specifically, I want to see the Description: and Synopsis: fields of my .cabal file the way Hackage would display them.
11:12:02 <dmwit> Sgeo: Still think haddock does that after my last requirement?
11:12:06 <c_wraith> run "cabal haddock"
11:12:16 <c_wraith> it will spit out the summary page
11:12:31 <elliott> kallisti: Hayoo might, but ResourceT is very new, so it's not guaranteed.
11:12:34 <elliott> Hoogle won't.
11:12:36 <dmwit> "haddock: no input files"
11:12:52 <c_wraith> that's impressive
11:12:58 <c_wraith> I've never got that error before
11:13:04 <elliott> dmwit: Haddock's summary pages are OK.
11:13:08 <elliott> I mean...
11:13:09 <elliott> Just OK.
11:13:10 <dmwit> It's easy to get: make a package with no modules, only dependencies.
11:13:17 <elliott> Ah.
11:13:25 <elliott> add /dev/null as an extra source file :P
11:13:39 <Saizan> get the hackage-scripts
11:13:53 <dmwit> elliott: no effect
11:14:01 <elliott> :(
11:14:06 <dmwit> Saizan: That sounds promising; where would I find them?
11:14:11 <elliott> Speaking of Haddock, I really hate Haddock markup.
11:14:24 <kallisti> elliott: assuming there's not some hideous parse ambiguity I think record[field] would be an okay syntax.
11:14:34 <kallisti> but... there is.
11:14:38 <rostayob> yeah. lists.
11:14:41 * elliott once decided to add a Pandoc Markdown backend thing to Haddock but then he looked at Pandoc's dependencies.
11:14:53 <kallisti> I think even record{field} would be ambiguous as well.
11:15:01 <elliott> tagsoup and zip-archive probably shouldn't be boot libs.
11:15:10 <elliott> kallisti: It is, with named field puns.
11:15:12 <rostayob> i'd be happy with record fields declared as lens automatically, and qualified with the data type name
11:15:17 <kallisti> elliott: right that would have to be removed.
11:15:19 <rostayob> well, happy
11:15:27 <elliott> Hmm, is Haddock actually a boot package?
11:15:40 <kallisti> rostayob: well the fact that another syntax element uses the same lexemes doesn't necessarily imply that it can't be used for something else. {} is used in both layout rules and record syntax, . is qualification of names and function composition.
11:15:58 <Sgeo> kallisti, looking at the ResourceT documentation, I don't see what I want
11:16:04 <parcs`> whitespace around operators should be mandatory
11:16:06 <cheater__> mornin', TML
11:16:17 <rostayob> > map (+1)[1,2,3]
11:16:18 <lambdabot>   [2,3,4]
11:16:19 <kallisti> parcs`: I am not agree.
11:16:27 <rostayob> kallisti: you'd have to change the rulse
11:16:29 <rostayob> *rules
11:16:34 <kallisti> rostayob: correct
11:16:34 <Saizan> dmwit: i thought it was on d.h.o but i can't find it
11:16:36 <Sgeo> Then again, I'm not sure it would even be useful
11:16:51 <dmwit> Saizan: Anyway, "cabal haddock" seems to do enough for me.
11:16:56 <kallisti> rostayob: yeah [] is a bad idea because f[x] is f [x]
11:17:00 <rostayob> kallisti: yes
11:17:02 <dmwit> Once I add an empty module.
11:17:09 <elliott> record{field} would be abominably ugly, so nobody would use it.
11:17:17 <rostayob> i would
11:17:21 <kallisti> ..it's ugly? :P
11:17:24 <elliott> Okay, rostayob would use it.
11:17:25 <parcs`> record->field ?
11:17:29 <elliott> record/field would be nice if it wasn't for that stupid division operator.
11:17:33 <parcs`> no ambiguity there
11:17:44 <rostayob> parcs`: it looks like PHP, out of the question
11:17:47 <elliott> parcs`: lambda syntax clash?
11:17:50 <kallisti> I like record'field but then ' is a valid identifier character mid-variable (which is pretty dumb...)
11:17:53 <elliott> rostayob: C++, rather
11:18:02 <parcs`> elliott: oh right :P
11:18:04 <kallisti> > let _'_ = 2 in _'_
11:18:04 <lambdabot>   2
11:18:07 <parcs`> and case expression clash
11:18:08 <elliott> record#field has precedent.
11:18:18 <kallisti> elliott: uglier than {} imo :P
11:18:19 <elliott> Since people used to define (#) = flip ($) and use accessors like that.
11:18:20 <rostayob> yeah but C++ is not PHP
11:18:27 <elliott> But MagicHash sticks a wrench in using # for other things, possibly?
11:18:34 <elliott> Hmm, I guess it only reserves the end-of-identifier position.
11:18:35 <cheater__> i use <> for flip ($)
11:18:48 <Sgeo> > let _|_ = undefined in 5
11:18:49 <lambdabot>   Pattern syntax in expression context: _
11:18:51 <Sgeo> aww
11:18:54 <elliott> ^ would be nice if not for that awful exponentiation thing: foo^bar
11:19:00 <Sgeo> > let (_|_) = undefined in 5
11:19:01 <lambdabot>   <no location info>: parse error on input `|'
11:19:03 <kallisti> what's bad about record'field ?
11:19:11 <kallisti> aside from breaking don't
11:19:11 <rostayob> kallisti: it's a valid variable name
11:19:13 <cheater__> ' is identifier
11:19:14 <elliott> kallisti: Breaks syntax.
11:19:30 <elliott> foo:bar -- God dammit, lists!
11:19:37 <elliott> Lists should have (::).
11:19:41 <rostayob> Oleg even uses it instead of camel case, one'two
11:19:43 <elliott> Type disambiguation can be (:::).
11:19:46 <rostayob> well, used it
11:19:48 <kallisti> isn't that kind of acceptable given that the main suggestion is to use . which breaks probably more code than restricting ' to the end of variable identifiers where it probably should be anyway?
11:20:00 <rostayob> anyways, this is pointless, the syntax is not the problem here
11:20:09 <parcs`> elliott: no, type annotations should be : and cons ::
11:20:09 <rostayob> there are other problems
11:20:23 <elliott> parcs`: I would agree if I wasn't busy trying to appropriate (:) for records.
11:20:27 <rostayob> as i said there a huge discussion on ghc-users
11:20:35 <elliott> foo|bar
11:20:35 <rostayob> and that said, going to eat
11:20:50 <Sgeo> Why "should" type annotations be : and cons be ::?
11:20:58 <kallisti> seriously, find a legitimate use of ' in the middle of a variable name.
11:21:05 <rostayob> i propose foo☢bar
11:21:10 <elliott> Sgeo: Types are more important than lists.
11:21:20 <elliott> They swapped it from ML for some unknown reason.
11:21:26 <elliott> I kind of like how "foo :: bar" looks at the top level, though.
11:21:39 <elliott> kallisti: as rostayob mentioned, a lot of Oleg's code uses it
11:21:44 <elliott> as a word delimiter
11:21:48 <kallisti> oh....
11:21:50 <rostayob> we can't break Oleg's code
11:21:52 <Sgeo> My first and primary functional language is Haskell, so
11:21:54 <elliott> move'left = ... etc.
11:22:00 <kallisti> I, see...
11:22:04 <Sgeo> move ' left?
11:22:09 <elliott> kallisti: it's nicer than move_left
11:22:15 <kallisti> I /guess/
11:22:16 <rostayob> elliott: Huges once said that they use : for cons since :: looked ugly
11:22:22 <geekosaur> they considered cons a more fundamental operation than assigning a type
11:22:27 <rostayob> i think there was a big debate
11:22:32 <elliott> rostayob: hehe, and type declarations should look ugly
11:22:38 <kallisti> I think record'field is the nicest alternative to . that I've seen so far though. :(
11:22:41 <kallisti> oh well.
11:22:44 <rostayob> elliott: explicit types weren't considered important back then
11:22:46 <parcs`> elliott: they swapped it because it was found that when :: is cons people tend to write f (x :: xs) and when it's : people tend to write f (x:xs)
11:22:46 <Sgeo> : for type declarations look ugly to me
11:22:48 <elliott> record\field
11:22:50 <rostayob> weren't considered as important
11:22:51 <elliott> that's not ambiguous!
11:22:51 <parcs`> at least that's what hughes said
11:22:53 <elliott> and it gives us PHP compatibility
11:22:56 * cmccann enjoys having types like (Either Didn'tWork a)
11:23:01 <kallisti> elliott: oh hmmm yes \ isn't too bad
11:23:03 <elliott> dude
11:23:06 <elliott> i was joking
11:23:17 <Ralith> Where can I find documentation on GHC's implementation of separate compilation?
11:23:21 <kallisti> what? unpossible.
11:23:22 <elliott> parcs`: that's amusing, because I always get annoyed that I have to inconsistently space my (:)s because (Just x:xs) looks weird
11:23:26 <rostayob> what about foo☹bar?
11:23:34 <dafis> dcoutts: Why would hsc2hs not know about cabal_macros.h when building zlib?
11:23:36 <elliott> foo☃bar
11:23:41 <parcs`> elliott: heh, yeah
11:23:46 <Ralith> or another Haskell compiler's
11:23:52 <rostayob> foo☠bar. intimidating.
11:24:25 <kallisti> record-field  thereby giving - even more problems.
11:24:36 <elliott> foo∎bar
11:24:44 <elliott> the tombstone is in memorial of those who died in the flamewar over what operator to use
11:25:08 <kallisti> record?field
11:25:11 <kallisti> ???
11:25:19 <rostayob> also, the tombstone is mathy.
11:25:32 <elliott> Come to think of it, record!field wouldn't be that bad. How many people actually import array libraries unqualified?
11:25:40 <elliott> I know Data.Array is meant to be used unqualified, but we should get rid of that, too :P
11:25:54 <dafis> elliott: what??
11:25:57 <kallisti> record@field
11:26:00 <rostayob> Data.Array sucks
11:26:16 <kallisti> I don't really like the appearance of @ in code for some reason though
11:26:17 <elliott> what rostayob said :P
11:26:29 <dafis> elliott: importing array libs qualified, okay, but using (!) qualified? urgh
11:26:39 <elliott> dafis: ah
11:26:49 <kallisti> A.!
11:26:52 <elliott> it is ugly, admittedly, but how do you use Map and <favourite array type> in the same piece of code otherwise?
11:26:53 <kallisti> egads
11:27:01 <elliott> I guess (Map.!) isn't that commonly used.
11:27:07 <elliott> (Oh, it's Map.(!), isn't it.)
11:27:12 <mauke> no
11:27:20 <kallisti> (Map.!) I believe
11:27:23 <kallisti> ??
11:27:27 <elliott> I keep forgetting which way around is the sensible new rejected syntax and which is the weird standard one.
11:27:29 <kallisti> I am bad at qualified operators. :P
11:27:44 <elliott> Let's just combine every proposal so far: record.!@'field
11:27:51 <donri> it's Map.!
11:27:57 <dafis> elliott: that's simple, it's always the other one
11:27:58 <mauke> haskell allows qualified infix operators
11:28:01 <mauke> the rest follows
11:28:01 <elliott> donri: as the operator value
11:28:18 <kallisti> record.!@'#{field}
11:28:26 <kallisti> good good.
11:28:38 <elliott> record;field
11:28:46 <donri> Control.Category..
11:28:49 <elliott> foo system = do { system;start }
11:29:01 <kallisti> elliott: help
11:29:40 <kallisti> Haskell should just use a special keyboard
11:29:48 <geekosaur> foo⍞bar
11:29:53 <kallisti> when you become a Haskell programmer you get to buy your very own Haskellboard
11:29:59 <kallisti> that has all the symbols you need.
11:30:08 <mauke> U+235E (e2 8d 9e): APL FUNCTIONAL SYMBOL QUOTE QUAD [⍞]
11:30:14 <mauke> THANK YOU, UNICODE
11:30:23 <elliott> use a unicode space character
11:30:37 <kallisti> record&nbsp;field
11:30:48 <elliott> record<field>
11:31:18 <mauke> http://mauke.hopto.org/stuff/javascript/unicode.html?q=space
11:32:55 <thorsten`> hi, i am trying to extract the image information (as [[Color]]) from a Image using Graphics.GD. But i don't get it how to use getPixel (something that returns IO Color) within a map-call
11:33:12 <mauke> mapM
11:34:37 <thorsten`> thanks! s/map/mapM/g fixed it :)
11:37:53 <kallisti> thorsten`: I hope you didn't have any legitimate uses of map in that code
11:38:05 <kallisti> because your /g option just broke them all. :P
11:38:37 <thorsten`> i had two nested maps within one line
11:39:10 <thorsten`> i do this:  img_as_matrix <- mapM (\y -> mapM (\x -> getPixel (x,y) img) [0..w-1]) [0..h-1]
11:41:08 <sm> oh my.. has hackagebot been awol for the last week ?
11:41:27 <donri> preflex: seen hackagebot
11:41:28 <preflex>  hackagebot was last seen on #haskell 8 days, 22 hours, 10 minutes and 11 seconds ago, saying: * hackagebot statistics 0.10.1.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.1.0 (BryanOSullivan)
11:42:00 <sm> yes.. sorry ! :/
11:42:36 <donri> do you run it?
11:42:40 <sm> yes I do
11:42:50 <donri> good to know who to whine at
11:43:12 <sm> also /whois hackagebot should say
11:44:04 <donri> oh it's back
11:44:11 <sm> yes. that's the worst downtime since I started
11:44:15 <donri> :)
11:44:34 <mauke> sm: you could make a nickserv account for it
11:44:51 <mauke> see e.g. /whois preflex
11:44:51 <sm> mauke: come again ? tell me more
11:44:52 <donri> thanks for running it
11:45:03 <sm> ok.. np donri
11:45:26 <mauke> though apparently that's still not good enough for some haskellwiki authors
11:45:30 <elliott> hi hackagebot
11:48:22 <sm> mauke: I don't get what you mean about nickserv, exactly ?
11:49:30 <mauke> sm: do you see the hostmask preflex has?
11:50:35 <sm> mauke: the (~preflex@unaffiliated/mauke/bot/preflex) part ?
11:50:43 <mauke> yes
11:50:54 <sm> yyeess..
11:51:33 <sm> what's the advantage and how did you set it up ?
11:52:20 <elliott> the advantage is that people know the owner, presumably
11:52:20 <lambdabot> elliott: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:52:28 <mauke> ...
11:52:35 <nand`> haha
11:54:32 <elliott> I really hate lambdabot.
11:55:08 <ion> :-D
11:55:33 <ion> You could just ignore it. :-P{
11:55:43 <ion> :-P even. The beard was a typo.
11:56:00 <elliott> I think there's a way to turn messages off.
12:00:02 <Veinor> @undo do {answerList <- lift $ AS.query View; return $ length answerList }
12:00:03 <lambdabot> lift $ AS.query View >>= \ answerList -> return $ length answerList
12:00:14 <elliott> lambdabot...
12:00:19 <elliott> you messed it up!
12:00:29 <elliott> Veinor: length <$> lift (AS.query View)
12:00:42 <hape01> How Do you call the "()" in "IO ()"? Is it the empty list? I dont remeber
12:00:47 <Veinor> unit
12:01:05 <hape01> thanks
12:01:15 <byorgey> it is not the empty list
12:01:22 <Veinor> elliott: excellent, thanks
12:01:23 <byorgey> (it is not a list at all)
12:01:27 <hape01> yes
12:01:39 <Veinor> actually in this case
12:01:50 <Veinor> i have so much stuff being applied to the result of the do-block i might as well keep it that way for clarity
12:02:03 <hape01> what is the equivalent for unit in algebra?
12:02:18 <byorgey> 1
12:02:29 <hape01> it is the neutral element?
12:02:40 <byorgey> 1 is the identity for multiplication, just as () is the identity for product of types (up to isomorphism)
12:02:54 <byorgey> that is, the type  ((), A) is isomorphic to the type A
12:03:20 <hape01> thanks
12:03:22 <elliott> (modulo _|_)
12:03:36 <byorgey> (right)
12:03:44 <ion> (lisp)
12:03:55 <byorgey> (troll
12:03:57 <elliott> )
12:04:06 <ion> OCD competition
12:04:10 <sipa> (((xkcd 297)))
12:05:08 <elliott> /kick sipa xkcd
12:05:20 <aristid> is xkcd a banned word?
12:05:24 <mike-burns> Yes.
12:05:28 <elliott> i hope so!
12:05:30 <Veinor> more like
12:05:33 <Veinor> /kick sopa
12:05:41 <ion> or pipa?
12:05:41 <sipa> i was first!
12:05:54 <ion> Both have the same Levenshtein distance.
12:06:09 <sipa> sipa = stop IP act
12:06:10 <Veinor> yeah but sipa is a much more likely typo for sopa than for pipa
12:06:16 <Veinor> i is right next to o
12:06:23 <elliott> sopa + pipa = sipa, the horrific zombie act of terror
12:06:46 <Ikaru> Does the word "scrutinee" in English?
12:06:49 <sipa> sopa = stop online piracy act; pipa = protect ip act; sipa logically means stop ip act :)
12:06:51 <Scriptor> it's like when flu strains combine
12:07:08 <Scriptor> Ikaru: not according to wiktionary
12:07:14 <Scriptor> use "scrutinized"
12:07:23 <Scriptor> as in, "the ones scrutinized"
12:07:42 <sipa> Ikaru: you seem to have accidentally a word
12:08:07 <adimit> Ikaru: scrutinee seems to be used in some formal contexts.
12:08:10 <ion> sipa: the whole word?
12:08:28 <elliott> Scrutinee is perfectly cromulent.
12:08:35 <Sgeo> Whee
12:08:41 <adimit> Anyway, since language is purely conventional, as long as you're being understood (and you most likely are…)
12:08:42 <Sgeo> The C SDK does something that's nice, at least:
12:08:47 <elliott> sipa: stop intellectual property act, then
12:08:48 <Sgeo> It makes a copy of all incoming strings
12:09:04 <Sgeo> So when I send stuff in, I can immediately free the used memory
12:09:16 <adimit> it follows valid and active morphological processes.
12:09:29 <ion> cromulee, the one cromulized.
12:09:38 <Clint> cromulized by a scrutiner
12:09:52 <Ikaru> I read "case scrutinee" in several docs
12:10:09 <elliott> that's the value being scrutinised
12:10:12 <elliott> by a case statement
12:10:17 <elliott> case x of ...
12:10:20 <elliott> x is the scrutinee
12:11:28 <Ikaru> I know. I want to know if that word is used in English. I don't see in the dictionary
12:12:10 <elliott> the dictionary doesn't have every word in it :)
12:12:19 <elliott> it's a perfectly valid derivation from scrutinise + -ee
12:12:35 <elliott> there's probably a name for -ee but I don't know it
12:12:54 <Taneb> Shouldn't it be scrutinisee?
12:13:20 <nyingen> how do I leave a message for someone in here, like when they unidle?
12:13:29 <elliott>  @tell
12:13:34 <elliott> @tell nyingen like this
12:13:35 <lambdabot> Consider it noted.
12:13:38 <elliott> @ask nyingen or this?
12:13:38 <lambdabot> Consider it noted.
12:13:39 <adimit> Taneb: apologize — apologee
12:14:06 <Taneb> I was thinking refuge -> refugee
12:14:14 <elliott> "Apologee"?
12:14:15 <elliott> That's going TOO FAR.
12:14:19 <ion> refuger
12:14:22 <nyingen> @tell Cale How did you get lambdabot/mueval working with the "rts options disabled by default" behavior that's now in GHC?
12:14:23 <lambdabot> Consider it noted.
12:14:40 <adimit> elliott: nope, you sholud google it, it's actively used.
12:14:45 <elliott> nyingen: The next time you speak without a @ in front, lambdabot will bother you.
12:14:54 <nyingen> ok
12:14:54 <lambdabot> nyingen: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:15:03 <elliott> adimit: I assume you're kidding, since I did, and it's all misspellings of "apology".
12:15:16 <nyingen> elliott: thanks
12:15:20 <ion> elliott: Ah, that’s the fix for lambdabot bothering you with messages. Prefix all lines with @.
12:15:30 <adimit> elliott: :-D
12:15:52 <elliott> adimit: I think the joke went over my head. :'(
12:15:52 <Eduard_Munteanu> @just like '@echo off' :P
12:15:52 <lambdabot> Maybe you meant: list quit
12:16:00 <elliott> @ ion: Perfect!
12:16:03 <Sgeo> Does lambdabot do cross-channel messages?
12:16:08 <Taneb> Yes?
12:16:11 <Eduard_Munteanu> Sgeo: yeah
12:16:15 <Sgeo> Ok
12:16:16 <adimit> elliott: I still think it's a valid derivation though.
12:16:27 <Taneb> I can message you here and you can pick it up in #esoteric
12:16:28 <adimit> elliott: sorry, us linguists are sometimes a little… different.
12:16:59 <elliott> adimit: Is it valid if nobody understands you? :P
12:17:03 * Sgeo hushes Taneb 
12:17:05 <Eduard_Munteanu> lambdabot is in #esoteric?
12:17:17 * Eduard_Munteanu figures :P
12:17:32 <Sgeo> elliott, awesome, I don
12:17:41 <elliott> Awesome, I don too.
12:17:42 <Sgeo> I don't have to bother leaving #esoteric now to update you
12:17:57 <adimit> elliott: per definition, no. language is meant to communicate, if you're not being understood, it's not fulfilling its purpose.
12:18:00 <Sgeo> (Or using /msg)
12:21:37 <ciaranm> does the ((->) a) functor have a canonical name in category theory?
12:22:14 <mercury^> ciaranm: the functor corepresented by a.
12:22:42 <ciaranm> thanks
12:24:05 <dafis> dcoutts: ping
12:24:43 <djahandarie> I don't think I've really seen corepresentable functors used very much in category theory though.
12:25:12 <djahandarie> Not that I see anything about category theory these days though.
12:25:43 <mercury^> They appear pretty often in algebraic contexts.
12:27:05 <mercury^> Well, homological ones, to be more precise.
12:32:07 <jro_> I have performance troubles with a simple perceptron: http://pastebin.com/9srk5QvV
12:32:10 <mauke> The paste 9srk5QvV has been copied to http://hpaste.org/56860
12:32:39 <jro_> why this slows down after 10 rounds or so
12:33:51 <koeien> !! is O(n)
12:33:56 <jro_> oh!
12:33:58 <jro_> thanks
12:34:26 <koeien> didn't check everything, it just occurred to me as a possible problem
12:35:05 <jro_> ok, here !! is applied to a constant sized list
12:35:47 <koeien> right
12:35:57 <donri> http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
12:36:27 <koeien> foldl (+) 0 on a list of integers/doubles is better written as foldl' (+) 0
12:36:31 <Eduard_Munteanu> j <- [0.. length trainingData]   looks odd
12:38:32 <Sgeo> I think currying sometimes leads to confusing error messages
12:38:57 <Sgeo> I omit the first argument out of two, and I get that the acutal type is secondargtype -> final reasult instead of the expected type final result
12:40:04 <Eduard_Munteanu> jro_: also, you might want to give errorNorm a type signature
12:42:35 <jro_> Eduard_Munteanu: index j goes through values 1..n, where n is length of trainingData. The training process iterates first all training samples by adjusting weights and then increase time by one.
12:43:30 <Taneb> Goodnight
12:43:38 <adimit> so, effectively, you're emulating a for-loop?
12:43:44 <adimit> with a list comprehension…
12:45:49 <jro_> well, the main program is just a test printing the values. I want to evaluate y t 0, and the time for evaluating it seems to increase very rapidly as a function of t, and I do not understant why
12:55:06 <cheater__> @hoogle python
12:55:06 <lambdabot> package cpython
12:55:06 <lambdabot> package language-python
12:55:06 <lambdabot> package language-python-colour
12:56:22 <Somelauw> lambdabot: help @hoogle
12:58:02 <Somelauw> @help
12:58:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:00:12 <cheater__> hi has anyone here used language-python?
13:01:57 <kallisti> does the MonadPlus instance for StateT obey the left zero law of MonadPlus?   mzero >>= k = mzero
13:02:00 <Sgeo> Why does ByteString call it packCString when Foreign.C.String calls it peekCString>?
13:02:40 <Axman6> Sgeo: don't they do different things?
13:02:52 <Sgeo> @hoogle packCString
13:02:52 <lambdabot> Data.ByteString packCString :: CString -> IO ByteString
13:02:52 <lambdabot> Data.ByteString.Char8 packCString :: CString -> IO ByteString
13:02:52 <lambdabot> Data.ByteString packCStringLen :: CStringLen -> IO ByteString
13:02:59 <Sgeo> @hoogle peekCString
13:02:59 <lambdabot> Foreign.C.String peekCString :: CString -> IO String
13:03:00 <lambdabot> Foreign.C.String peekCStringLen :: CStringLen -> IO String
13:05:14 <koeien> because there was a pack already for ByteStrings
13:05:23 <koeien> pack :: [Word8] -> ByteString
13:07:27 <Axman6> kallisti: what's the definition of mzero for StateT?
13:07:44 <kallisti> oh. it's probably return mzero
13:08:03 <kallisti> because it's:  instance (MonadPlus m) => MonadPlus (StateT s m)
13:08:12 <kallisti> so it depends on the inner monad.
13:08:24 <Axman6> yeah
13:09:50 <JoeyA> Is it safe to call Network.Curl.withCurlDo and withSocketsDo in the same program?  withCurlDo calls curl_global_init with CURL_GLOBAL_WIN32.
13:10:50 <JoeyA> This boils down to: on Windows, is it safe to initialize the Windows Sockets API twice?
13:12:21 <JoeyA> Looks like it should be okay.  From msdn.microsoft.com: "An application can call WSAStartup more than once if it needs to obtain the WSADATA structure information more than once. On each such call, the application can specify any version number supported by the Winsock DLL."
13:17:33 <JoeyA> Hmm, the network package requests version 1.1 of WSA, but curl's version choice is configurable.
13:24:23 <niteria> is Recursive programming techniques worth reading?
13:24:26 <jro_> that perceptron paste problem was solved with an accumulated parameter recursion
13:26:40 <Axman6> @where lyah
13:26:40 <lambdabot> http://www.learnyouahaskell.com/
13:28:43 <vhd> anyone worked through exercise 3.9 of purely functional data structure? How do you create a rb tree from ordered list?
13:29:15 <alistra> split in half
13:29:23 <alistra> and then recursively split in half
13:29:24 <alistra> etc
13:29:27 <alistra> and mark all black
13:29:42 <alistra> and mark the difference from the biggest power of 2 red
13:29:46 <vhd> and that will be O(n)?
13:29:46 <alistra> or something :D
13:30:13 <Axman6> it's probably closer to n log n isn't it?
13:30:21 <vhd> yeah :/
13:30:38 <roconnor> @type showS
13:30:39 <lambdabot> Not in scope: `showS'
13:30:48 <roconnor> @hoogle ShowS -> STring
13:30:48 <lambdabot> Did you mean: ShowS -> String
13:30:48 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
13:30:53 <roconnor> @hoogle ShowS -> String
13:30:53 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
13:31:02 <Axman6> anyway, try making each element a leaf, then joining pairs recursively until you have 1 tree
13:31:35 <koeien> roconnor: ShowS = String -> String
13:33:15 <alistra> Axman6: this is nlogn isn't it?
13:33:24 <Axman6> i believe so
13:33:28 <Sgeo> After I set :set -fforce-recomp in GHCi, can I unset it?
13:33:31 <alistra> can't you do it like greedy?
13:33:35 <Axman6> i'm not sure of a way of doing in in O(n) time
13:34:04 <vhd> there has to be, the exercise is basically that.
13:34:10 <Axman6> actually, maybe this way is O(n). you do n/2 operations, then n/4, then n/8 etc
13:34:45 <Axman6> > let n = 128 in n/2 + 2/4 + n/8 + n/16
13:34:46 <lambdabot>   88.5
13:34:48 <niteria> n + 2 * n/2 + 4 * n /4 ... = O(n log n)
13:35:03 <Axman6> ah right
13:35:06 <Axman6> wait
13:35:18 <niteria> you deal with both halves
13:35:19 <Axman6> why is it 2 * n/2?
13:35:26 <Axman6> mine doesn't use halves
13:35:28 <Sgeo> Uh
13:35:48 <Sgeo> There's no IsString instance for ByteString
13:35:50 <niteria> you mean merging?
13:36:06 <Sgeo> According to the docs, there is
13:36:08 <Sgeo> WTF is going on
13:36:12 <Axman6> there's O(n) for the conversion to leaves, then n/2 operations to join consecutive pairs, then n/4 to join consecutive pairs again
13:36:15 <alistra> i thought that you can start with building like the left lower side of the tree
13:36:18 <alistra> and extend it
13:36:26 <alistra> keepeing the invariants
13:36:47 <mauke> Sgeo: you're importing the wrong module?
13:37:12 <Axman6> foo [x] = x; foo (x:y:xs) = foo $ Node x y : foo xs
13:37:16 <Sgeo> mauke, hmm?
13:37:22 <Axman6> roughly
13:37:47 <Axman6> but not quite
13:39:14 <MostAwesomeDude> This looks like a job for Foldable?
13:39:32 <nh2> http://hackage.haskell.org/trac/hackage/ down?
13:39:55 <donri> yep, got spammed
13:40:21 <nh2> :(
13:48:37 <kallisti> is there a more efficient MonadLogic instance than [] ?
13:49:16 <Axman6> like some kind of tree?
13:49:52 <kallisti> Axman6: I don't really know  honestly.
13:50:21 <kallisti> is LogicT more efficient? it seems to just use a list underneath.
13:51:09 * hackagebot cassy 0.2.0.3 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.2.0.3 (OzgunAtaman)
13:54:34 <niteria> vhd: assuming you have 2^n - 1 numbers in that list, you take every second element - that will be your leaves, then take every second element of remaining elements - that will be parents of your leaves and so on
13:54:58 <niteria> it's O(n) = n + n/2 + n/4 +...
13:55:48 * Axman6 wins
13:57:36 <niteria> Axman6: I was under impression yours joined pairs next to each other, which is wrong
13:57:53 <Axman6> hmm?
13:58:20 <niteria> [1, 2, 3, 4, 5, 6, 7] - 1 and 2 won't be siblings
13:58:28 <Axman6> hmm, my method doesn't woork for trees where elements are stored in the nodes
13:59:04 <Axman6> actually, i need to figure out how top do this exact same problem for the assignment i'm writing (for other people to complete, it's not my homework =)
13:59:30 <niteria> oh, ok, but the question was to construct bst, or more specifically rb tree
13:59:35 <vhd> I guess its safe to assume this wont be asked in my exam :/
14:01:31 <vhd> niteria, your method would require iterating over the list multiple times or can it be done with one pass?
14:02:01 <niteria> it iterates multiple times, but with lists of length n, n/2, n/4...
14:02:17 <Axman6> you can do it in one pass in O(nlogn) time (just insert all elements)
14:03:21 <Axman6> niteria: i think you've managed to help me figure out how to do what I need =)
14:04:49 <niteria> Axman6: cool
14:05:38 <vhd> Axman6, yeah I have that already but excercise specifically says to do it in O(n)
14:05:39 <niteria> Axman6: colors left as an exercize :)
14:05:52 <niteria> I mean vhd
14:06:06 <niteria> and *exercise
14:06:12 <vhd> I dont follow
14:06:32 <niteria> I didn't tell you how to color that tree
14:06:49 <niteria> but it should be straightforward
14:07:18 <Axman6> niteria: yeah colours not needed here. i'm actually working with a ternary tree, but i initially need to build it up as a binary tree
14:09:07 <Axman6> (implementing a LZW algorithm, and im using a ternary tree to find previous prefixes)
14:12:33 <niteria> ok #haskell I read Monadic Parser Combinators, what should I read next?
14:13:55 <Axman6> what are you interested in?
14:14:11 <Pseudonym> You could write a monad tutorial. You never really understand monads until you do that.
14:14:14 <mreh> cabal: vector-space-0.8.0: dependency
14:14:14 <mreh> "Boolean-0.0.1-5f08221cfe33434d0c9976b31f42f900" doesn't exist (use --force to
14:14:15 <niteria> parsing ;)
14:14:24 <mreh> cabal-dev keeps spitting out this
14:14:52 <Pseudonym> General theory of parsing, or do you have a parsing job that you need to do?
14:14:53 <mreh> should I be reading SICP?
14:15:17 <Pseudonym> mreh: How you manage your time is up to you, but everyone should read it once.
14:15:39 <mreh> SICP = structure and identification of cabalised packages
14:15:46 <Pseudonym> Ah.
14:15:51 <Pseudonym> Never mind.
14:15:53 <niteria> :D
14:16:23 <mreh> SICP = storage and identification of cabalised packages*
14:16:53 <niteria> that's greatly misleading
14:17:20 <mreh> i think it's meant to be a joke :)
14:17:55 <niteria> seems like
14:18:36 <mreh> nothing seems to be working today :(
14:19:03 <niteria> today is only 8 minutes in
14:19:47 <mreh> GMT here
14:19:48 <niteria> well, at least in my TZ
14:21:09 * hackagebot osm-download 0.2 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.2 (ThomasDuBuisson)
14:22:55 <mreh> yeah... cabal-dev can't find the packages it just installed, that's annoying
14:32:26 <niteria> Write_Yourself_a_Scheme_in_48_Hours looks promising
14:56:02 <hpaste_> “Ertugrul Söylemez” pasted “Optimized sieve of Eratosthenes” at http://hpaste.org/56866
14:58:48 <derpladee> hey guys is there a function like (a -> b -> c) -> b -> (a -> c) ?
14:59:13 <kallisti> > flip (++) "hello" "world"
14:59:14 <lambdabot>   "worldhello"
14:59:21 <kallisti> derpladee: like that?
14:59:32 <sipa> :t flip
14:59:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:59:45 <Nafai> Is there a particular resource that explains how to write a server in Haskell.  I'm coming primarily from a Python/Twisted background.
14:59:55 <kallisti> :t (flip.($))
14:59:55 <lambdabot> forall a b a1. (a1 -> a -> b) -> a -> a1 -> b
15:00:03 <sipa> :t flip :: (a -> b -> c) -> b -> (a -> c)
15:00:04 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:00:04 <kallisti> Nafai: Real World Haskell has a few examples of servers.
15:00:29 <Nafai> Oh, yeah, been a while since I've read that, I had forgotten
15:00:31 <derpladee> hmm maybe i'll look into it
15:00:32 <c_wraith> Nafai: the first thing you need to know is that you don't need to contort yourself like twisted does.  GHC's IO system already is based on event loops.
15:00:37 <mike-burns> @hoogle (a -> b -> c) -> b -> (a -> c)
15:00:38 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
15:00:38 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
15:00:38 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
15:01:02 <derpladee> i want it to return a function though
15:01:09 <kallisti> derpladee: it does.
15:01:14 <kallisti> derpladee: are you familiar with currying?
15:01:22 <derpladee> a little :) i think i understand now
15:01:24 <kallisti> :t flip (++) "hello"
15:01:25 <lambdabot> [Char] -> [Char]
15:01:36 <Nafai> c_wraith: Yeah, that's what I'm seeing :)
15:01:37 <derpladee> i just give it one argument and then it returns the function that i want
15:01:42 <kallisti> derpladee: yep
15:01:47 <derpladee> alright thanks :)
15:01:54 <kallisti> no problem.
15:02:04 <kallisti> derpladee: note that some people prefer (`f` x) as opposed to flip f x
15:02:09 <kallisti> myself included.
15:04:14 <hpaste_> “Ertugrul Söylemez” annotated “Optimized sieve of Eratosthenes” with “Refinement of soeST” at http://hpaste.org/56866#a56867
15:08:49 <mm_freak> derpladee: the function arrow (->) is right-associative
15:08:59 <mm_freak> that means:  a -> (b -> c) = a -> b -> c
15:19:14 <SoleSoul> Hi. Is there such thing as an application written in haskell which can be copied to a usb disk and run on any windows machine without the need of any installed libraries/applications on the windows machine? Can you show me an example of such a program? Is it even possible with haskell?
15:19:38 <mike-burns> You want a statically compiled binary?
15:19:53 <SoleSoul> yes. portable.
15:20:01 <SoleSoul> as portableapps
15:20:01 <kallisti> Haskell compiles standalone executables as far as I know.
15:20:15 <SoleSoul> like you can have portable firefox
15:20:29 <mike-burns> It can do dynamically linked binaries now, kallisti , but static is still an option.
15:20:43 <SoleSoul> I never saw a download link for a haskell application.
15:20:52 <mike-burns> Hah well, that's a different issue.
15:20:52 <mzero> how would you know?
15:20:56 <SoleSoul> only "run this on cabal"
15:21:10 * hackagebot happstack-server 6.5.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.5.1 (JeremyShaw)
15:21:58 <kallisti> SoleSoul: Haskell applications are compiled (with either static or dynamic linking). libraries which are used by Haskell applications can be downloaded via cabal.
15:22:10 <kallisti> you don't "run" things on cabal.
15:22:38 <SoleSoul> kallisti: sorry, it's just a language mistake. I know what you mean.
15:22:59 <mm_freak> SoleSoul: most haskell applications are on hackage, so you can use a simple command line tool "cabal" (called cabal-install in most distributions) to compile and install them along with all dependencies they have
15:23:04 <kallisti> so an application for end users would be downloaded as an executable/binary, but libraries for programmers would be found on cabal.
15:23:23 <mm_freak> SoleSoul: you get cabal-install for windows by installing the haskell platform
15:24:07 <Saizan> SoleSoul: once it's compiled, if it's statically linked, you can use it anywhere, it's just more common to distribute just the source atm
15:24:17 <SoleSoul> kallisti: This is exactly what I'm looking for: an example of  an application which can be downloaded by users without them having to install any library or knowing that the application was written in haskell.
15:24:57 <mm_freak> SoleSoul: write hello world, compile it statically, then you have the example
15:25:12 <kallisti> http://www.haskell.org/haskellwiki/Applications_and_libraries#Haskell_applications_and_libraries   look for something sufficiently end-usery in this list. :P
15:25:19 <kallisti> games probably has a few.
15:25:20 <Sgeo> There may be legal issues with giving away statically compiled exes oin Windows
15:25:21 <Axman6>  believe laksah is distributed in binary form, at least for OS X
15:25:26 <Sgeo> on Windows
15:25:32 <Saizan> SoleSoul: there http://wiki.darcs.net/Binaries#microsoft-windows
15:25:33 <SoleSoul> Saizan: is there even just one example of such statically linked application? I'm quite new to real programming in haskell and I wondered why I couldn't find any even a text editor written in haskell.
15:25:57 <koeien> there is yi.
15:25:59 <mike-burns> http://www.haskell.org/haskellwiki/Yi
15:26:08 <mzero> Yup - Leksah is indeed distributed as a statically compiled app
15:26:10 * hackagebot happstack-hamlet 6.2.3 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.2.3 (JeremyShaw)
15:26:12 * hackagebot happstack-heist 6.0.6 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.6 (JeremyShaw)
15:26:17 * mzero is running it right as we type
15:27:11 <Axman6> mzero: how is it? it's been a while since i tried it (gave it a go at AusHac2010 when Hamish M. needed OS X testers)
15:27:12 <mzero> Sgeo: what are you talking about? One can certainly write a program, compile it, and give it away statically linked for Windows
15:27:16 <kallisti> SoleSoul: why does the issue concern you so much. It's very possible.
15:27:25 <mzero> Axman6: as of the 0.11 release it is great
15:27:31 <Sgeo> mzero, something with gmp being LGPL, I think
15:27:36 <tazjin> SoleSoul: I for one like to create web frontends for end users, solves lots of problems. I think many other people do that as well
15:27:43 <mzero> I've switched to using it almost exclusively -
15:28:06 <SoleSoul> Saizan: this darcs binary looks like what I'm looking for. it's quite big but it is really a statically linked application
15:28:07 <Sgeo> http://haskell.forkio.com/gmpwindows
15:28:09 <mzero> the only think I drop into my trusty text editor for is .cabal file editing, (I don't like the way Leksah formats .cabal files when it edits them)
15:28:41 <kallisti> SoleSoul: statically compiled binaries tend to be large, yes.
15:28:50 <Dodek> hello, i have written a simple program in haskell and it performs rather poorly in terms of speed, compared to ocaml
15:28:53 <hpaste_> Dodek pasted “slow ” at http://hpaste.org/56870
15:29:02 <Dodek> here it is
15:29:21 <Dodek> do you have any suggestions on how i can make it faster?
15:29:35 <koeien> Dodek: add !'s strategically
15:29:46 <Saizan> SoleSoul: btw, even with dynamic linking one would just need to make sure the shared libs are packaged with the exe
15:29:48 <koeien> process (!n, !m) !k | ...
15:29:48 <kallisti> Dodek: perhaps foldr would be faster?
15:30:04 <kallisti> the compiler should determine strictness for n and m automatically
15:30:05 <Dodek> kallisti: foldr overflows the stack
15:30:09 <kallisti> no need to litter !'s everywhere
15:30:15 <kallisti> Dodek: I'm assuming you ran with -O2 ?
15:30:22 <kallisti> er
15:30:23 <SoleSoul> kallisti: the reason is simple. I saw many portable application written in compiled languages but after many tries on linux and windows I couldn't install yi and leksah and couldn't find a simple binary to download even for windows where this is a common practice.
15:30:25 <kallisti> compiled rather.
15:30:27 <Axman6> foldr is rarerly faster, unless you can temrinate early
15:30:27 <koeien> depending on the size of your input, ByteString can be faster
15:30:51 <Saizan> Dodek: the ! on n is probably the biggest thing you need
15:31:03 <mzero> kallisti: don't use Data.Set, use Data.IntSet
15:31:07 <mike-burns> Don't use ByteString unless you're doing byte processing. Maybe you meant Text?
15:31:14 * hackagebot happstack-hsp 6.2.5 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.5 (JeremyShaw)
15:31:14 <koeien> yes, for this case Data.IntSet is way faster
15:31:16 * hackagebot happstack-hstringtemplate 6.0.4 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.4 (JeremyShaw)
15:31:16 <Saizan> Dodek: because you're never forcing it within the loop
15:31:18 * hackagebot happstack-jmacro 6.0.1 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-6.0.1 (JeremyShaw)
15:31:18 <kallisti> Saizan: won't demand analysis determine that n is strict?
15:31:20 * hackagebot happstack-lite 6.0.4 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-6.0.4 (JeremyShaw)
15:31:24 <Dodek> kallisti: yeah, it's equally bad
15:31:24 <mm_freak> Dodek: in your specific cache, foldl' doesn't rescue you, because it only forces the (,) constructor, not the actual values
15:31:29 <Axman6> hackagebot: shut up
15:31:39 <mm_freak> Dodek: you probably want to write your own foldl that is tuple-aware
15:31:48 <koeien> mike-burns: in general, sure, but we're reading numbers here
15:31:49 <Axman6> o.O
15:31:55 <kallisti> mzero: you pinged the wrong person
15:31:55 <Dodek> mm_freak: it kind of does, because without ' it overflows the stack
15:31:57 <Saizan> mm_freak: no, he just needs to make process stricter
15:32:30 * Axman6 agrees
15:32:36 <mm_freak> yeah, the main killer is the accumulation of 'n', because nothing forces that one
15:32:42 <mzero> oops - sorry - Dodek - what koeien and I said: IntSet is your friend
15:32:45 <Dodek> !n does not change anything
15:32:49 <Saizan> it's already strict enough in m and k because of the guard
15:32:53 <Axman6> s/Data.Set/Data.IntSet/ should make a big change
15:32:57 <SoleSoul> Saizan: it's like in C++ then. logical :). but in all of my years using computers I never found myself downloading an haskell application and running it! I kept wondering why is it so hard to distribute a simple working application for the users? why do they have to install libraries when they are not supposed to be concerned about development details?
15:33:10 <mzero> replace   n+1   with   n `seq` (n+1)
15:33:15 <mm_freak> Dodek: f n' = let n = … in n `seq` …
15:33:18 <mzero> on line 6, Dodek
15:33:26 <koeien> mzero: won't help if it's inside the tuple.
15:33:27 <Axman6> just use bang patterns for that...
15:33:29 <mzero> and use IntSet - you should be good to go
15:33:31 <kallisti> SoleSoul: it's not a question of difficulty it's just that more applications are written in not-Haskell than they are in Haskell.
15:33:32 <Dodek> IntSet makes it a bit faster, but it's still 8 times slower than ocaml
15:33:42 <rwbarton> bytestring will make a huge difference
15:33:47 <mike-burns> SoleSoul: Please, write more Haskell apps that users want!
15:34:08 <mm_freak> Dodek: what should your code do?  add elements to a Set and count how many new elements have been added?
15:34:12 <mzero> the tuple is unpacked each time, so, sure it will
15:34:24 <mm_freak> no
15:34:24 <Axman6> rwbarton: where do you propose using bytestring? is there a library that will read Ints from a bytestring?
15:34:28 <rwbarton> in my experience reading (ASCII) Ints with bytestrings is faster than C scanf("%d", &x)
15:34:31 <koeien> mzero: but n is not forced
15:34:35 <mm_freak> Dodek: it should count the number of distinct numbers?
15:34:39 <rwbarton> for Int it's included in the bytestring library
15:34:45 <SoleSoul> mike-burns: I'm still in chapter 13 "For a few monads more" :)
15:34:52 <Axman6> ah, nice
15:34:56 <Dodek> mm_freak: no, the problem is a bit more tricky
15:34:59 <koeien> yes, Data.ByteString.Char8
15:34:59 <rwbarton> @hoogle readInt
15:35:00 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:35:00 <lambdabot> Text.Read.Lex readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
15:35:00 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:35:12 <mm_freak> Dodek: the way i read your code it counts duplicates
15:35:19 <mzero> hmmm, koeien  - perhaps you are right - well, an extra ! here and there, I guess
15:35:53 <kallisti> IntMap is good for counting things. :)
15:36:06 <koeien> overkill here
15:36:10 * hackagebot happstack-plugins 6.3.2 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.3.2 (JeremyShaw)
15:37:05 <Dodek> mm_freak: suppose you label some points on a line with natural numbers and you want to connect with segments the points with the same number. what's the maximal number of segments such that that none of them intersect?
15:37:47 <SoleSoul> mike-burns, kallisti: so is it all about the lack of applications written in haskell? I thought it was more  widely used and that I could at least find a portable text editor written in it. Maybe this is not the case, and it is interesting why it is like that.
15:38:21 <mike-burns> SoleSoul: Most Windows apps are written in C, last I checked.
15:38:22 <Dodek> mm_freak: for instance, for labels 6 4 1 4 1 4 4 6 3 7 3, the answer is 3 -- you connect first 4 with second 4, then again two fours, and then 3s
15:38:26 <kallisti> SoleSoul: probably. it's certainly not the case that Haskell is difficult to use for compiling standalone applications.
15:38:44 <mike-burns> SoleSoul: It's 85% marketing and the rest is cultural.
15:38:57 <Dodek> ocaml code is http://wklej.org/id/675710/
15:39:27 <Axman6> god ocaml is ugly >_<
15:39:35 <SoleSoul> mike-burns: well, I didn't ask for a large market share. I asked for one text editor, just one.
15:39:50 <mike-burns> SoleSoul: http://www.haskell.org/haskellwiki/Yi
15:40:26 <SoleSoul> kallisti: ok, thank you. I will have to experiment myself and see if I can produce reasonable sized portable binaries.
15:40:48 * mzero can't imagine why a text editor is a good benchmark of programming system maturity ...
15:40:55 <Axman6> indeed
15:40:59 <mike-burns> There's gotta be a better phrase than "portable binary" to describe what you're describing.
15:41:07 <koeien> Dodek: did you try the ByteString suggestion?
15:41:11 * hackagebot happstack 6.0.6 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.6 (JeremyShaw)
15:41:13 * hackagebot happstack-hsp 6.2.6 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.6 (JeremyShaw)
15:41:20 <Dodek> koeien: not yet
15:41:20 <SoleSoul> mike-burns: I wrote earlier that this editor is the proof of the opposite. Do you know how hard is it to install yi for a normal user?
15:41:29 <mike-burns> Hah, oh yeah.
15:41:38 <Dodek> koeien: now i'm droping the fold/tuple code and rewriting it to to proper recursive function
15:41:41 <Axman6> Dodek: it's quite likely that using string IO is having a large effect
15:41:55 <elliott> SoleSoul: That's a property of Yi, not Haskell.
15:41:57 <SoleSoul> mike-burns: do you know of any downloadable working binary for yi?
15:42:00 <koeien> Dodek: it should work with process (!n, !m) ..
15:42:02 <elliott> Yi is quite old and complex.
15:42:07 <elliott> It's also targeted at very technical users.
15:42:09 <mike-burns> SoleSoul: I do not, no.
15:42:09 <Axman6> Dodek: how long are your benchmarks running for btw?
15:42:14 <mm_freak> Dodek: i've just done that…  how long is the list you are giving it?
15:42:17 <elliott> And I don't think many of its developers care about Windows (though I don't know for sure).
15:42:35 <elliott> mike-burns: It might be C# nowadays.
15:42:36 <Dodek> Axman6: 4.5 seconds for Haskell, 0.7 seconds for Ocaml, 0.6 for C++
15:42:54 <elliott> mike-burns: And if not that, I suspect C++, at least I was under the impression that raw Win32 was not very popular any more.
15:42:54 <Dodek> mm_freak: 500 000 elements
15:43:07 <Axman6> hmm, odd. it would be good to see profile data. also are you compiling with optimisations on?
15:43:08 <mm_freak> Dodek: how often does it reset?
15:43:10 <SoleSoul> elliott: I tried to install it on archlinux a few times and failed. there was an incompatibility with a particular version of ghc.
15:43:14 <Axman6> that sounds very slow for what its doing
15:43:16 <Dodek> mm_freak: reset?
15:43:22 <rwbarton> bytestring bytestring bytestring
15:43:34 <mm_freak> Dodek: how often does it switch back to S.empty?
15:43:40 <mm_freak> in that 500k list
15:43:57 <Dodek> mm_freak: exactly 122 times
15:44:06 <Axman6> > 500000/122
15:44:07 <lambdabot>   4098.360655737705
15:44:09 <elliott> SoleSoul: Again, a property of Yi; it was not maintained at all for a long while, IIRC, and it actually hooks into the GHC API itself to do fancy tricks.
15:44:26 <Philippa_> yeah, Yi does things that at first glance aren't supported
15:44:34 <Philippa_> it's very susceptible to bitrot
15:44:43 <elliott> SoleSoul: I'm sure it's not intentional, but you're kind of coming off as trying to discredit Haskell's suitability for Windows binaries based on a few examples.
15:45:20 <Philippa_> yeah. There are much better reasons to do that! :p
15:45:30 <hpaste_> Dodek annotated “slow ” with “slow  (annotation)” at http://hpaste.org/56870#a56872
15:45:42 <Dodek> this is a direct translation of ocaml code, modulo IO code
15:45:47 <Dodek> i'll work on rewriting IO now
15:45:49 <SoleSoul> elliott: I would be more than happy to hear about a haskell application for end users which can be put on a usb disk and be run on any windows machine.
15:45:57 <Dodek> the results are unchanhed
15:46:16 <elliott> SoleSoul: It's more like "Haskell hasn't been used in all that many end-user-facing desktop apps", instead of "no Windows Haskell apps that meet my very specific requirements exist because GHC is unsuitable".
15:46:19 <koeien> Dodek: I did the translation, now it's from 4.2 s to 0.23 s
15:46:20 <Philippa_> FCVO "end users", pandoc
15:46:24 <SoleSoul> elliott: I am learning haskell and it is surprisingly hard to find applications written in haskell and even harder to install them...
15:46:37 <elliott> SoleSoul: Why not make one that fits your requirements? We've already covered that it's very easy to do with GHC.
15:46:37 <Dodek> koeien: oh, really? could you show me your code?
15:46:41 <Philippa_> but what elliott said
15:46:50 <elliott> There are no technical obstacles, it's just that Haskell's adoption has been far more in programmer-related tools, for whatever reason.
15:46:53 <hpaste_> koeien annotated “slow ” with “slow  (annotation)” at http://hpaste.org/56870#a56873
15:46:53 <elliott> And web apps.
15:47:09 <mm_freak> Dodek: if you had 500k times the same element, is the correct answer 250k?
15:47:10 <Philippa_> elliott: FCVO "technical obstacles", the range of GUI libs might count
15:47:19 <elliott> Perhaps partially because the GUI bindings scene wasn't too good for a while, or because Haskell's users tended to be programmer's-programmers before it rose in popularity.
15:47:23 <elliott> Philippa_: Right.
15:47:25 <SoleSoul> elliott: Don't get me wrong, GHC is godly, I just want to see it in practice.
15:47:26 <Philippa_> though once gtk2hs works, you just drop the binary and the relevant DLL together
15:47:35 <koeien> Dodek: see paste
15:47:46 <mm_freak> Dodek: if yes, then i have a function that does what you want for 500k elements in less than a second
15:47:53 <Philippa_> SoleSoul: pandoc is a useful tool, it's just not a GUI app?
15:47:53 <mm_freak> for the worst case (never resetting)
15:47:56 <mike-burns> SoleSoul: So  apt-get install haskell-platform  and try it out?
15:48:07 <Philippa_> > "I am a haskell application"
15:48:07 <lambdabot>   "I am a haskell application"
15:48:13 <SoleSoul> :)
15:48:14 <Dodek> koeien: wow it's cool
15:48:16 <elliott> SoleSoul: Consider darcs.
15:48:21 <Dodek> koeien: thanks
15:48:25 <SoleSoul> again, a developer tool
15:48:36 <elliott> SoleSoul: darcs is popular (less so than it was since git dominates now, but it was for a long time), and has *widespread use outside the Haskell community*.
15:48:45 <elliott> Many users of darcs probably don't even know it's written in Haskell.
15:48:53 <elliott> Sure, it's a developer tool. Developers are people too.
15:48:54 <hpaste_> “Ertugrul Söylemez” annotated “slow ” with “slow  (annotation)” at http://hpaste.org/56870#a56874
15:48:55 <SoleSoul> no one goes with darcs on usb disks :)
15:48:59 <mike-burns> People use darcs?
15:49:02 <Axman6> are there many users of darcs? :\
15:49:03 <mm_freak> Dodek: see paste
15:49:04 <elliott> It's more "end-user" than something like cabal, which is just for Haskell programmers.
15:49:22 <elliott> Axman6: A lot of people use it for personal projects, I think. Everyone's on git nowadays.
15:49:22 <Axman6> i used to use darcs, but no more
15:49:25 <mike-burns> Wait; people put programs on USB disks?
15:49:38 <elliott> SoleSoul: You could easily put darcs on a USB stick. You probably wouldn't want to.
15:49:39 <rwbarton> People use Windows?
15:49:47 <elliott> Why not put it on a USB stick yourself? :P
15:49:56 <mm_freak> Dodek: my variant needs 700 ms for the worst case (never resetting) and 10 ms for the best case (always resetting)
15:50:07 <Philippa_> rwbarton: amazingly, yes. Some even write Haskell on it
15:50:13 <SoleSoul> elliott: pandoc looks like imagemagick for text. sounds good :)
15:50:14 <pcavs> I installed Data.Aeson, but I can't seem to import it from GHCi because it looks like aeson-native is name colliding, what's the proper way around this?
15:50:41 <dgpratt> rwbarton: indeed, some people even claim to like it!
15:50:49 <Saizan> pcavs: ghc-pkg hide, or -package flags
15:51:04 <SoleSoul> elliott: so according to what you say, the reason is just lack of adoption?
15:51:10 <Philippa_> SoleSoul: pandoc is also a library, which is the form I'm using it in - but that's because I'm rigging up a rather customised toolchain to spew out wordpress.com-compatible material
15:51:13 <dolio> There are multiple nethack forks that use darcs as source control.
15:51:30 <cmccann> there seem to be XMonad users who aren't haskell programmers, since they wander in here occasionally asking for help tweaking it
15:51:40 <koeien> cmccann: many
15:51:49 <Philippa_> dgpratt: I wouldn't go that far, I just find the network effects are dominant for me. I'm a gamer, for example
15:51:56 <SoleSoul> Philippa_: ah right, it was you who suggested it. thanks for letting me know about it.
15:51:59 <Eduard_Munteanu> Because their dungeons are darc? :P
15:52:00 <dgpratt> I need a sticker for this Windows 7 laptop that says "My other OS is Arch Linux"
15:52:09 <cmccann> so that's another example of something written in haskell that's not just used by haskell programmers :P
15:52:21 <koeien> Dodek: basically, String is very slow. use ByteString or Text
15:52:27 <SoleSoul> Philippa_: looks useful and a good example for what I'm looking for.
15:52:35 <koeien> Dodek: String is just [Char]
15:52:38 <Dodek> koeien: yeah, i see why
15:52:44 <Philippa_> yeah, I did a rather "hey, guess who drank too much caffeine?" intro to Haskell at Barcamp Notts and had to explain that I wasn't using XMonad because I was running windows
15:53:09 <koeien> Dodek: also putStrLn . show == print
15:53:30 <koeien> other than that i think the code is very idiomatic
15:53:46 <mauke> who you calling an idiom?!
15:53:48 <Eduard_Munteanu> Philippa_: heh, and not a masochistic one to use Wine I guess :P
15:54:15 <SoleSoul> Philippa_, elliott, mike-burns, kallisti, tazjin, Saizan: thank you all. :)
15:54:24 <SoleSoul> cya
15:54:24 <Eduard_Munteanu> Which kinda works when it does, but for games it's still pretty bad in terms of performance.
15:54:30 <mm_freak> koeien: your version is not optimal and is the reason i don't like bang patterns
15:54:35 <Dodek> koeien: i've been playing with haskell for a while, recently i've written a 1300 loc program in it, but speed has never been concern for me till now
15:54:37 <mm_freak> they're usually off by one
15:54:43 <sm> hey, is there a good reason why pandoc doesn't parse man pages yet ?
15:54:45 <Dodek> koeien: thank you for suggestions
15:54:50 <Dodek> mm_freak: i can't get your code to compile
15:55:09 <koeien> mm_freak: could you elaborate?
15:56:01 <koeien> mm_freak: you suggest  let !n' = n + 1 in (n' , ...)
15:56:05 <hpaste_> Dodek annotated “slow ” with “slow  (annotation) (annotation)” at http://hpaste.org/56870#a56875
15:56:11 <Dodek> mm_freak: this is what i get
15:56:15 <hpaste_> “Ertugrul Söylemez” annotated “slow ” with “Optimal foldl' variant” at http://hpaste.org/56870#a56876
15:56:36 <mm_freak> koeien, Dodek:  see the paste
15:56:45 <mm_freak> the last annotation
15:57:04 <mm_freak> Dodek: sorry, just remove the "forall a." and remove the type signature of "count"
15:57:07 <koeien> mm_freak: right, thanks.
15:57:26 <mm_freak> i'm using a language extension there for nicer type signatures, but you don't need it
16:00:15 <Dodek> mm_freak: your code is slower than koeien's one
16:00:19 <Dodek> by about 30%
16:00:58 <koeien> that's because of the excess polymorphism I presume
16:01:09 <koeien> szy :: [Int] -> Int -- try to add this again
16:01:20 <Dodek> oh yeah
16:01:33 <Dodek> it's faster for ints
16:01:42 <koeien> also, I changed Data.Set into Data.IntSet
16:01:48 <mm_freak> Dodek: replace Set by IntSet
16:01:57 <mm_freak> that gives it a 4x performance boost here
16:02:10 <Dodek> mm_freak: i just did it and it's indeed faster, but the factor is 2x for me
16:02:13 <Eduard_Munteanu> What is that function supposed to do?
16:02:32 <Dodek> Eduard_Munteanu: which one?
16:02:57 <Eduard_Munteanu> szy
16:03:02 <derpladee> how does show work on a CInt ?
16:03:12 <Eduard_Munteanu> Looks a bit complicated for something [a] -> Int.
16:03:15 * Sgeo looks at the rmonad package
16:03:22 <mm_freak> Eduard_Munteanu: count the number of unique sequences (sequences without repetition)
16:03:22 <derpladee> it appears that it retunrs a seemingly random number
16:03:31 <Axman6> o.O
16:03:37 <mm_freak> szy [1,2,3,1,3,2,2,3] = 3
16:03:45 <mm_freak> [1,2,3], [1,3,2], [2,3]
16:04:00 <Axman6> 23 is repeated no?
16:04:03 <Dodek> mm_freak: it's 2 actually
16:04:04 <kallisti> using Int8 or Word8 would speed up the code greatly, and of course reduce the range of numbers that can be counted.
16:04:09 <mm_freak> true
16:04:11 <Sgeo> Prelude Foreign.C.Types> show (5 :: CInt)
16:04:12 <Sgeo> "5"
16:04:14 <mm_freak> the last sequence isn't counted
16:04:31 <derpladee> well i'm actually working with Color from the Graphics.GD package
16:04:32 <mm_freak> Dodek: you can give it another speed boost, if you know that your list lives in memory as a whole by switching to Seq
16:04:34 <derpladee> but it's just a CInt
16:04:49 <Dodek> Eduard_Munteanu: suppose you label some points on a line with natural numbers and connect with segments the points with the same label. what is maximal number of nonintersecting segments?
16:04:51 <kallisti> I also found that when factoring numbers
16:04:56 <kallisti> that Word was faster than Int.
16:04:58 <mm_freak> Dodek: but that only improves the speed, if the list will be in memory as a whole
16:05:44 <elliott> Sorry, I got disconnected...
16:05:45 <elliott> <SoleSoul> elliott: so according to what you say, the reason is just lack of adoption?
16:05:51 <elliott> SoleSo- oh, they left.
16:05:53 <Eduard_Munteanu> I see.
16:05:58 <mm_freak> kallisti: no, Int8 and Word8 would perform worse, because we would need to use the general Set
16:06:10 <Sgeo> derpladee, maybe with TypeSynonymInstances a different Show instance is being used?
16:06:11 <mm_freak> we really need type family-based Set and Map
16:06:22 <Sgeo> Wait, no
16:06:31 <kallisti> mm_freak: ah indeed
16:06:47 <Eduard_Munteanu> kallisti: I don't think an 8-bit integer is necessarily faster on, say x86, instead of word-sized integers.
16:07:14 <Sgeo> derpladee, did you try it in GHCi just importing Graphics.GD and playing with show there?
16:07:23 <Sgeo> Or how are you finding seemingly random results?
16:07:34 <derpladee> maybe "arbitrary" is a better word, it's not random
16:07:35 <kallisti> Eduard_Munteanu: maybe not. Word does appear to be faster than Int in general though.
16:07:38 <derpladee> i just don't understand it :P
16:07:45 <derpladee> is there any way i can show a CInt as separate bytes?
16:08:02 <derpladee> i assume CInt is a 32bit int, can i use a function to get 4 bytes instead?
16:08:26 <Eduard_Munteanu> kallisti: I'm not sure it should.
16:08:29 <mm_freak> derpladee: CInt has a Storable instance
16:08:32 <rwbarton> derpladee: You can write one.
16:08:50 <mm_freak> derpladee: but you can use that only, if you have a pointer to a CInt value
16:09:41 <Axman6> dpratt71: CInt is whatever int is in C on your platform
16:09:46 <Axman6> uh, derpladee
16:10:07 <dpratt71> Axman6: ah, good to know...I was wondering about that
16:10:22 <Axman6> just keeping you on your toes!
16:10:31 <dpratt71> :)
16:10:34 <derpladee> think it's 32 bits :)
16:10:41 <derpladee> mm_freak, i don't, i just have a value
16:10:50 <kallisti> > sizeOf (undefined :: CInt)
16:10:50 <lambdabot>   Not in scope: `sizeOf'Not in scope: type constructor or class `CInt'
16:10:54 <kallisti> :(
16:10:59 <mm_freak> derpladee: you can't assume int to be 32 bits
16:11:08 <elliott> you can assume CInt to be 32-bits
16:11:11 <elliott> if int is 32-bits on your platform
16:11:11 <Sgeo> :t undefined :: Foreign.C.Types.CInt
16:11:13 <lambdabot> Foreign.C.Types.CInt
16:11:15 <Sgeo> :t undefined :: Foreign.C.Types.CIn
16:11:16 <lambdabot>     Not in scope: type constructor or class `Foreign.C.Types.CIn'
16:11:16 <mm_freak> derpladee: but you can easily convert an Int to a base 256 representation
16:11:31 <derpladee> oh yea
16:11:32 <derpladee> lol i can
16:11:35 <koeien> int is at least 16 bits
16:11:35 <derpladee> okay thanks guys
16:11:38 <kallisti> :t Foreign.Storable.sizeOf
16:11:39 <lambdabot> forall a. (Foreign.Storable.Storable a) => a -> Int
16:11:55 <Eduard_Munteanu> It could be 30-ish bits, no?
16:11:55 <kallisti> > Foreign.Storable.sizeOf (undefined :: Foreign.C.Types.CInt)
16:11:56 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'Not in scope: type constructor or cl...
16:11:58 <kallisti> :(
16:12:02 <koeien> Eduard_Munteanu: Int, yes, CInt no
16:12:07 <Eduard_Munteanu> (assuming thunk tags eat up a few bits)
16:12:10 <mm_freak> > map (`mod` 256) . takeWhile (> 0) . iterate (`quot` 256) $ 5287352
16:12:11 <lambdabot>   [184,173,80]
16:12:11 <Eduard_Munteanu> Yeah, Int.
16:12:19 <mm_freak> derpladee: that gives you base 256
16:12:36 <Sgeo> :t Foreign.Storable.sizeOf (undefined :: Foreign.C.Types.CInt)
16:12:37 <lambdabot> Int
16:12:37 <mm_freak> you can improve the performance by using Data.Bits operations instead of quot and mod
16:12:41 <Eduard_Munteanu> > maxBound :: Int
16:12:42 <lambdabot>   9223372036854775807
16:12:44 <Sgeo> > Foreign.Storable.sizeOf (undefined :: Foreign.C.Types.CInt)
16:12:45 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'Not in scope: type constructor or cl...
16:12:47 <Eduard_Munteanu> > maxBound :: CInt
16:12:47 <Sgeo> ???
16:12:47 <lambdabot>   Not in scope: type constructor or class `CInt'
16:12:58 <Eduard_Munteanu> > 2^32
16:12:59 <lambdabot>   4294967296
16:13:04 <Eduard_Munteanu> > 2^64
16:13:05 <lambdabot>   18446744073709551616
16:13:11 <elliott> > 2^128
16:13:12 <lambdabot>   340282366920938463463374607431768211456
16:13:15 <Axman6> > maxBound :: Word
16:13:16 <lambdabot>   18446744073709551615
16:13:19 <mm_freak> > map (.&. 0xFF) . takeWhile (> 0) . iterate (`shiftR` 8) $ 5287352
16:13:19 <elliott> Axman6: YOU RUINED THE PATTERN
16:13:21 <lambdabot>   [184,173,80]
16:13:29 <mm_freak> that's faster
16:13:30 <elliott> mm_freak: ooh, nice solution
16:13:43 <Sgeo> 5287352?
16:13:45 <Eduard_Munteanu> Wha?
16:13:49 <mm_freak> again my beloved iterate/map pattern =)
16:13:53 <Axman6> mm_freak: are you sure?
16:13:58 <elliott> Eduard_Munteanu: "Wha?"?
16:14:00 <Eduard_Munteanu> Ah. right
16:14:05 <Eduard_Munteanu> Nevermind, stupid thought.
16:14:16 <Sgeo> :t iterate
16:14:17 <lambdabot> forall a. (a -> a) -> a -> [a]
16:14:20 <mm_freak> Sgeo: 5287352 = 80*x^2 + 173*x + 184
16:14:22 <mm_freak> where x = 256
16:14:24 <Axman6> i don't remember bit operations in haskell being very fast. maybe that's changed
16:14:51 <dafis> Axman6: on Int and Word, they're very fast
16:14:56 <Axman6> > map (.&. 0x0F) . takeWhile (> 0) . iterate (`shiftR` 4) $ 5287352
16:14:57 <mm_freak> Axman6: that really depends on the data type…  for Int and Integer they are fast
16:14:57 <lambdabot>   [8,11,13,10,0,5]
16:15:03 <derpladee> mm_freak, wow nice
16:15:08 <mm_freak> it might be different for CInt, which is the type in question here
16:15:14 <mm_freak> you have to benchmark
16:15:26 <dafis> Axman6: assuming that one compiles with optimisations, of course
16:15:47 <Eduard_Munteanu> That's one question.
16:15:59 <elliott> Axman6: they can beat division sometimes
16:16:04 <elliott> as i discovered optimising a program
16:16:37 <mm_freak> GHC seems to optimize 2^x division/modulo and multiplication
16:16:38 <Axman6> good to hear
16:17:03 <elliott> mm_freak: not always
16:17:12 <elliott> at least div and quot were both slower than a shift
16:17:14 <Axman6> i've been interested in whether that sort of info makes it into the LLVM in a way it can do those optimisations
16:17:18 <elliott> and the core proved it wasn't doing the optimisation
16:17:24 <elliott> oh I wasn't using llvm though
16:17:33 <mm_freak> i'm not using LLVM either
16:18:13 <Axman6> i wish i could use LLVM, but GHC produces LLVM assembly that's rejected by LLVM 3.0 (i think)
16:18:47 <mm_freak> how do you generate LLVM code anyway?  GHC 7.0.3 assumed
16:18:52 <elliott> -fllvm
16:22:14 <mm_freak> hmm…  LLVM compilation fails for me
16:22:18 <mm_freak> is LLVM 3 supported?
16:22:25 <Axman6> no
16:22:27 <Axman6> :(
16:22:29 <mm_freak> ok
16:22:38 <mm_freak> back to -fasm =)
16:22:49 <Axman6> there's some nice stuff in LLVM 3, like a new register allocator which produces quite nice results
16:23:58 <elliott> <Axman6> i wish i could use LLVM, but GHC produces LLVM assembly that's rejected by LLVM 3.0 (i think)  <mm_freak> how do you generate LLVM code anyway?  GHC 7.0.3 assumed
16:24:00 <elliott> good timing :P
16:24:02 <parcs`> -fllvm works for me on ghc7.2 and llvm 3
16:37:10 <Sgeo> elliott, say something
16:41:31 <nand`> elliott, you have 1 new message. PM lambdabot to read it
16:41:33 <nh2> what uboxed type does S# stand for
16:41:55 <copumpkin> small Integer
16:42:05 <mauke> :t S#
16:42:06 <lambdabot> Not in scope: data constructor `S#'
16:42:12 <mauke> @src Integer
16:42:13 <lambdabot> data Integer = S# Int#
16:42:13 <lambdabot>              | J# Int# ByteArray#
16:42:23 <nh2> copumpkin, mauke: thanks!
16:42:50 <Eduard_Munteanu> And "J#" stands for Jumbo? :)
16:43:33 <sipa> S# and J# are constructors, not types
16:43:40 <rostayob> nh2: niklassssss
16:45:35 <aavogt> sipa: type constructors taking 0 arguments! Everything is a function!
16:46:03 <sipa> aavogt: not type constructors, constructors
16:49:09 <aavogt> ah true
16:49:17 <mm_freak> how do i provide associated type synonym defaults?
16:49:27 <mm_freak> "type X a = Y a" doesn't work
16:49:34 <rostayob> aavogt: also, some values are not functions
16:52:05 <Sgeo> I thought Integer used GMP?
16:52:05 <lambdabot> Sgeo: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:52:44 <parcs`> mm_freak: it's ghc 7.4 only
16:52:53 <ddarius> Sgeo: What would you expect to see if it did?
16:53:12 <rostayob> Sgeo: that's probably true, but it tags normal integers when the value is small
16:53:17 <Sgeo> ddarius, Integer# ?
16:54:06 <rostayob> Sgeo: the S# is if the integer is small enough, otherwise the GMP value is contained by the ByteArray (buessing)
16:54:10 <rostayob> *guessing
16:54:11 <ddarius> Sgeo: Presumably you're saying that Integer# would be some wired-in primitive.  What would the representation of that primitive be?
16:54:43 <mm_freak> parcs`: but GHC 7.0.3 gives me the error:  "Type declaration in a class must be a kind signature or synonym default"
16:55:02 <mm_freak> so at least it seems to know some concept of default associated type synonyms
16:55:09 <Sgeo> ddarius, something to correspond with whatever GMP uses, I guess. But what rostayob is saying makes sense
16:55:11 <elliott> <rostayob> aavogt: also, some values are not functions
16:55:18 <elliott> that's like "some values are not Ints" :P
16:55:28 <rostayob> elliott: well, he said that everything is a function
16:55:33 <elliott> right
16:55:45 <elliott> "almost nothing is a function" :)
16:55:52 <elliott> Sgeo: Integer doesn't necessarily use GMP.
16:55:52 <dafis> Sgeo: The J# corresponds to what GMP uses
16:55:56 <elliott> GHC with integer-simple doesn't.
16:56:16 <monochrom> mm_freak: I'm guessing that defaults can't be done
16:56:24 <Sgeo> With J#, what does the Int# store?
16:56:25 <nh2> rostayob: hey yo
16:56:29 <rostayob> nh2: sup
16:56:30 <rostayob> :)
16:56:43 <Sgeo> The length of the array? Because if so, then there's a limit on how big the numbers can be...
16:56:48 <dafis> Sgeo: a) the signe, b) the number of limbs (Word's)
16:56:53 <ddarius> > case 2^129 of J# i _ -> Int# i
16:56:54 <elliott> Sgeo: The number of ... whatever GMP's name for them are.
16:56:54 <parcs`> mm_freak: strange
16:56:54 <lambdabot>   Not in scope: data constructor `J#'Not in scope: data constructor `Int#'
16:56:55 <elliott> Limbs.
16:57:04 <elliott> Sgeo: There's a limit no matter what; GMP is written in C and pointers have a specific size.
16:57:29 <Sgeo> J# Integer# ByteArray#
16:57:31 <elliott> Support for storing integers larger than the 64-bit address space on 64-bit computers is not very compelling to the GMP developers, I'd think.
16:57:32 <parcs`> mm_freak: do you have 'type X a = Y a' or 'type X a; type X a = Y a'
16:57:40 <dafis> Sgeo: if the integer uses w words and is < 0, the Int# is -w#
16:57:44 <mm_freak> parcs`: i tried both
16:58:04 <mm_freak> well, there is nothing in the docs, so i'm guessing it's impossible
16:58:12 <parcs`> mm_freak: i'm pretty sure it's 7.4-only
16:58:22 <parcs`> that error message is strange though :P
16:59:00 <dafis> elliott: on top of that, it would pose memory problems to have so large Integers
17:00:04 <rostayob> what's the standard name for a function, if 'f' and 'g' are taken? 'h'?
17:00:31 <monochrom> yeah, I'd try h. or f1, g1, f', g'
17:00:31 <mm_freak> rostayob: f1, f2, f3, f4, …
17:00:50 <rostayob> ok.
17:01:28 <mm_freak> and then it's a matter of taste whether to write f3 . f2 . f1 or f1 . f2 . f3
17:01:38 <monochrom> f2. f3. f1
17:02:07 <monochrom> f3 . f1 . f4 . g1 . f5 . f9
17:02:43 <mm_freak> at some point you end up using template haskell to generate names
17:03:17 <elliott> dafis: Storing data larger than your address space generally does pose memory problems, yes :P
17:03:38 <elliott> In the future, CPUs will just have one primitive unit of data: the IPv6 address.
17:03:49 <Axman6> heh
17:03:50 <elliott> Pointers? Nah, you just use HTTP.
17:04:06 <Axman6> ibm already has one OS using 128 bit pointers i believe
17:04:29 <tikhonjelvis> I think ZFS did something like that, for supporting obscenely large filesystems.
17:05:09 <kniu> so I installed llvm-base 3.0.0.0
17:05:13 <tikhonjelvis> I read some article where it explained that if you turned the Earth into pure energy and stored as much information as possible, you could still use a 128bit address system.
17:05:13 <Axman6> <3 ZFS
17:05:14 <kniu> and it went fine
17:05:27 <kniu> but when I try to build a program that imports LLVM.FFI.Core
17:05:28 <mikeplus64> are there any docs about loading 3D models (eg .obj) with the SDL bindings or GLUT/OpenGL bindings?
17:05:50 <kniu> I get a whole bunch of undefined references to stuff like LLVMOpaqueTypeInContext and whatnot
17:05:56 <kniu> anyone else get this problem?
17:06:30 <kniu> I've submitted an issue to bos/llvm on github, but got no comments thus far
17:10:56 <elliott> tikhonjelvis: That just means IPv6 isn't jupiterscale.
17:11:46 <ddarius> tikhonjelvis: The universe, let alone Earth, is small.
17:12:38 <Axman6> there's a poster outside my office that gives you an idea of how big the ipv6 address space is, and you can pretty much address every atom in the universe several times over i believe
17:12:49 <Axman6> > 2^128
17:12:50 <lambdabot>   340282366920938463463374607431768211456
17:12:52 <elliott> Axman6: That's not quarkscale!!!
17:14:44 <ddarius> Axman6: But not every Planck scale swatch of spacetime for the entire universe over all time.
17:14:57 <Axman6> sadly :(
17:15:13 <kallisti> say I have an arbitrary point on a chessboard. what would be the easiest way to find all the points with a chebyshev/chessboard distance of N from that central point?   if it simplifies things, I can also index from the entire board (which is a Vector)
17:15:14 <lambdabot> kallisti: You have 1 new message. '/msg lambdabot @messages' to read it.
17:15:16 <Axman6> oh well, IPv8 is being worked on, with 2^1024 bits
17:15:20 <Axman6> uh addresses
17:15:25 <Axman6> that's a crazy amount of bits...
17:15:27 <ddarius> Axman6: That should be adequate.
17:15:30 <Axman6> > 2^1024
17:15:31 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:15:37 <elliott> Isn't IPv8 that... yeah, it is.
17:15:39 <Axman6> > length . show $ 2^1024
17:15:41 <lambdabot>   309
17:16:17 <ddarius> > logBase 10 2 * 1024
17:16:18 <lambdabot>   308.2547155599167
17:16:22 <meggamine_> Is there a recent GHC for powerpc architecture? Prehaps bundled into a distro?
17:16:52 <elliott> Does GHC even support PPC these days?
17:17:15 <Axman6> m3ga might know
17:17:47 <elliott> If it does then Debian might have a package.
17:17:53 <m3ga> all recent ghc on ppc work. ghci however only works on 32 bit cpus.
17:18:19 <m3ga> debian has 7.0.4 and will be getting 7.4.X soon after it is officially released
17:18:20 <Axman6> does linux support running 32 bit programs on a 64 bit install?
17:18:27 <m3ga> yes
17:18:36 <meggamine_> But, I'm on Debian and my ghc is broken.
17:18:52 <m3ga> meggamine_: which version of debian?
17:18:59 <m3ga> sorry release
17:19:15 <m3ga> and which ghc from debian?
17:19:52 <mm_freak> why would one want 1024 bits addresses?
17:20:47 <meggamine_> m3ga: Debian 6.0.3
17:21:15 <m3ga> debian 6.0.3 is debian stable, right?
17:21:22 <Axman6> mm_freak: so you can address all time and space down to the picosecond level
17:21:26 <m3ga> that should have ghc 6.12.1
17:21:45 <koeien> yes that's stable
17:22:07 <meggamine_> m3ga: Yeah, that's in the path.
17:22:24 <m3ga> afaik 6.12.1 should work. i haven't used though because i run testing on just about everything.
17:23:10 <m3ga> meggamine_: maybe you could try purging the ghc package and reinstalling it.
17:23:23 <meggamine_> m3ga: Yeah...
17:23:36 <meggamine_> How?
17:23:43 <m3ga> hang on, i've got a debian stable chroot. let me go check it out.
17:23:52 <m3ga> meggamine_: 'sudo apt-get purge ghc'
17:24:01 <m3ga> then 'sudo apt-get install ghc'
17:24:40 <meggamine_> m3ga: Thanks, I'm trying that.
17:25:20 <m3ga> i'm installing ghc in my stable chroot
17:25:21 <meggamine_> m3ga: Yeah, ghc-pkg-6.12.1 list returns ... Segmentation fault; that's what's broken.
17:26:10 * hackagebot happstack-hsp 6.2.7 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.7 (JeremyShaw)
17:26:30 <meggamine_> Err, "that's why I say it's broken". What are you doing then?
17:27:36 <m3ga> meggamine_: i'm seeing if the version you have segfaults on my machine.
17:29:31 <m3ga> meggamine_: ghc-6.12.1 compiles simple 'hello world' style program without a problem. everything normal.
17:29:51 <m3ga> thats on ppc, in debian stable chroot
17:30:02 <meggamine_> m3ga: Can you run xmonad?
17:30:15 <m3ga> not inside a chroot :-)
17:30:30 <Axman6> you should totally be abl;e to assign a monitor to a chroot
17:30:52 <m3ga> Axman6: i really, really doubt that
17:31:17 <koeien> i think Axman6 was speaking hypothetically
17:31:33 <Axman6> indeed
17:31:44 <meggamine_> m3ga: Oh.
17:31:54 <m3ga> hypotetically looks like "it would be nice if ...."
17:31:54 <elliott> well
17:31:58 <elliott> you can easily just Xnest
17:32:01 <elliott> and DISPLAY=... xmonad
17:32:07 <elliott> Xnest outside the chroot that is
17:32:34 <m3ga> yes, xnest would work, but not over long distance ssh
17:32:56 <m3ga> meggamine_: i can try xmonad with xnest this evening
17:33:08 <mm_freak> Axman6: for the price that a single address alone is multiple times larger than an IPv4 header?
17:33:18 <geekosaur> it's a progression, chroot -> jail -> compartment -> VM
17:33:28 <Axman6> mm_freak: worth it
17:33:29 <elliott> m3ga: people run X apps over ssh all the time! ... or at least like to pretend they do so they can claim it as an advantage of X :P
17:33:30 <Sgeo> I have a type like:
17:33:32 <Sgeo> Map CInt (MVar (CInt -> IO ())))
17:33:36 <mm_freak> IMO IPv6 addresses are already too large
17:33:48 <elliott> Sgeo: You should really newtype that function, at least.
17:33:53 <Sgeo> Would it make sense to use lazy I/O to set up the maps?
17:33:55 <Sgeo> Er, the map
17:34:02 <meggamine_> m3ga: Thanks, see I was came here from #xmonad. Some endianess issue makes key events fail in xmonad, fixing ghc is the plan.
17:34:12 <Axman6> geekosaur: i should learn more about jails. i feel i should be running irssi in one on my FreeBSD machine
17:34:14 <elliott> Set it up how? Your question is really too vague to answer, going by just a type.
17:34:15 * meggamine_ curses the trackpad!
17:34:16 <Sgeo> Since I don't want to create an MVar until it's needed
17:34:25 <m3ga> elliott: yes, but i'm currently in the office supposedly working. this is not a good time to messing with that sort of stuff.
17:34:26 <mm_freak> Sgeo: you probably should use IntMap there
17:34:34 <elliott> MVars do not take up much memory.
17:34:45 <elliott> m3ga: hehe
17:34:46 <Sgeo> elliott, so making one for every possible CInt would be ok?
17:34:48 <Sgeo> :/
17:34:55 <Axman6> no...
17:35:08 <elliott> Sgeo: sounds like your design is broken
17:35:10 <Axman6> given there'd be at least 2^32 of them
17:35:15 <Axman6> agreed
17:35:17 <elliott> at least 2^16, actually.
17:35:21 <elliott> technically :P
17:35:36 * Axman6 lives in the real world
17:35:38 <Axman6> :P
17:35:45 <mm_freak> Sgeo: what are you trying to do?
17:36:08 <Sgeo> A map of callback handlers
17:36:26 <Sgeo> Setting a callback handler should try to put into the MVar
17:36:38 <Sgeo> This way, no more than one callback handler can be set at a ti,e
17:36:38 * elliott wonders if Sgeo realises he could just create an MVar if lookup returns Nothing.
17:36:39 <Sgeo> time
17:36:52 <mm_freak> Sgeo: what do you need the MVars for then?
17:37:05 <mm_freak> doesn't Map CInt (CInt -> IO ()) suffice?
17:37:33 <rostayob> mm_freak: you were right, the instances for Auto are *a lot* easier
17:37:33 <elliott> Sgeo: You're binding to a C library with callback support, right? Why not just use "foreign export" and set them directly rather than maintaining your own map?
17:37:36 <elliott> Apart from that, what mm_freak said.
17:37:42 <Sgeo> mm_freak, the possible callbacks will mutate over the lifetime of the thing
17:37:44 <elliott> Also, I'm sceptical of the CInt parameter.
17:37:49 <elliott> Sgeo: MVar (Map CInt ...).
17:38:00 <mm_freak> Sgeo: then put the map in an MVar
17:38:07 <mm_freak> not the individual callbacks
17:38:08 <rostayob> mm_freak: took me 15 minutes to write them down, unless i'm missing something... the hardest part was (.) :P
17:38:13 <m3ga> meggamine_: i can test xmonad inside xnext on ppc in about 5-6 hours. if you're not here i'll get lamdbabot to keep a msg for you.
17:38:19 <mm_freak> rostayob: yeah =)
17:38:24 <Sgeo> elliott, I need to lock if a thread tries to set a callback while waiting for a callback
17:38:38 <Sgeo> While another thread is waiting for the same callback, I mean
17:38:44 <rostayob> mm_freak: general recursion is strong in arrows :P
17:38:47 <mm_freak> rostayob: now just as an interesting exercise, write Applicative and Functor instances
17:38:54 <elliott> Sgeo: I go back to my other suggestion, then.
17:38:58 <rostayob> mm_freak: for 'Auto a'?
17:39:01 <mm_freak> yeah
17:39:04 <rostayob> ok
17:39:07 <Sgeo> elliott, which?
17:39:12 <mm_freak> rostayob: if you have time, install the "profunctors" package and write a Profunctor instance, too
17:39:12 <elliott> Sgeo: <elliott> Sgeo: You're binding to a C library with callback support, right? Why not just use "foreign export" and set them directly rather than maintaining your own map?
17:39:21 <mm_freak> the Profunctor instance is a particularly useful one
17:39:32 <rostayob> mm_freak: uh-oh, ekmett package
17:39:54 <Sgeo> elliott, because that wouldn't enforce the blocking I need
17:40:12 <Sgeo> Is MVar (Map CInt MVar (CInt -> IO ())) acceptable?
17:40:28 <elliott> Sgeo: I don't understand why you want that blocking. What's wrong with setting a callback when a callback is running?
17:40:29 <Sgeo> Er
17:40:34 <mm_freak> rostayob: as a mental exercise, also install the "bifunctors" package and figure out why Auto is a profunctor, but not a bifunctor =)
17:40:35 <elliott> If you want to forbid that, maintain a lock outside of this infrastructure.
17:40:38 <meggamine_> m3ga: How thoughtful :>
17:40:49 <elliott> mm_freak: Contra- I said nothing.
17:41:11 <Sgeo> elliott, theres no way to see which call to the callback actually resulted in the callback being called if I don't
17:41:12 <rostayob> mm_freak: cool, I'll do that tomorrow
17:41:15 <ddarius> mm_freak: Shouldn't that be immediately obvious?
17:41:30 <elliott> Sgeo: Huh?
17:41:41 <elliott> How could it not be actually called if you call it, and why does it matter if it was "actually called"?
17:42:00 <mm_freak> ddarius: it wasn't to me…  i intuitively started writing a Bifunctor instance and only after getting the type error i saw i actually wanted a Profunctor instance
17:42:13 <Sgeo> Suppose one thread look up info on person 1, and another thread look up info on person 2
17:42:34 <Sgeo> The problem is making sure that the thread looking up info on person 2 doesn't see person 1's data and visa verse
17:42:36 <Sgeo> versa
17:42:49 <Sgeo> The SDK supplies a solution for some of the callbacks, but not all of them
17:43:07 <Sgeo> I think
17:43:08 <elliott> Presumably the possibility for conflict arises because the data is sent back with the same identifier that you map the callbacks to?
17:43:40 <Sgeo> identifier?
17:43:41 <elliott> I would not implement what you're doing, then. Doing this with callbacks like that would constitute a leaky abstraction, I would think.
17:43:46 <elliott> Sgeo: Whatever the CInt is.
17:43:53 <elliott> (What is that CInt parameter for, by the way?)
17:44:18 <Sgeo> The CInt identifies whether I'm doing a callback that looks up info on an avatar vs. info on the world... oh
17:44:20 <Sgeo> Which CInt?
17:44:28 <elliott> The one that's a parameter.
17:44:58 <Sgeo> That, at the SDK level, is a result code that identifies whether the callback succeeded, or whether there was an error.
17:45:12 <Sgeo> I have an abstraction to turn that into an exception, but not sure what level to do taht at
17:45:14 <Sgeo> *that at
17:45:57 <ddarius> If I'm a thread, and I want to look up information on person 1, what is the process I go through?
17:46:02 <elliott> You seem to be trying to do something very high-level that is beyond what your protocol can actually support, given that two-thread example, so this would be the correct layer. I remain sceptical that this callback model is a good idea in general, though, and I don't really see how it prevents the conflict you mentioned.
17:46:19 <hpaste_> rostayob pasted “Auto instances” at http://hpaste.org/56877
17:46:24 <Sgeo> ddarius, at the SDK level?
17:46:36 <rostayob> ^^^ mm_freak: is pure as simple as it seems?
17:46:37 <Clint> is it saner to have a single Chan with messages tagged by destination and each thread dupChan it and filter for relevant messages than to newChan once for each destination and maintain a map of destination Chans?
17:47:04 <rostayob> it'd make more sense to me to have Auto $ \() -> (x, pure x)
17:47:48 <mm_freak> rostayob: you can improve 'pure' and 'arr' slightly
17:47:54 <mm_freak> rostayob: make use of sharing
17:48:00 <ddarius> Sgeo: Yes.
17:48:04 <Sgeo> elliott, if only one is set at a time, then maybe person 1 is requested first, the request for person 2 blocks. person 1's data comes through, it's clear which that belongs to, person 2's request unblocks, gets sent to SDK, and waits
17:48:18 <mm_freak> rostayob: use either 'let' or 'fix' for taht
17:48:19 <mm_freak> that
17:48:29 <rostayob> mm_freak: right
17:48:30 <elliott> Sgeo: So you're solving multithreaded conflicts with an elaborate scheme that amounts to a global lock?
17:48:36 <elliott> Why not just use a global lock on SDK requests?
17:48:52 <mm_freak> pure x = fix $ \again -> Auto (const (x, again))
17:49:21 <Sgeo> ddarius, set the function that is called for all requests of info on a person. Call the function that requests info. Wait.
17:49:34 <Sgeo> The function pointer isn't passed in to the request for info
17:49:49 <rostayob> mm_freak: yeah
17:49:59 <mm_freak> rostayob: also i don't think you need an irrefutable pattern for ArrowLoop there
17:50:03 <Sgeo> elliott, I'm doing that too, but that lock will only be held while marshalling data in and out and actual communication
17:50:11 <elliott> Sgeo: So your lock doesn't have a wide enough scope.
17:50:11 <ddarius> Sgeo: What SDK are you talking about?
17:50:14 <Sgeo> The lock on callbacks is held while waiting
17:50:16 <elliott> Widen it.
17:50:18 <rostayob> mm_freak: oh, i put it there just to be sure
17:50:23 <rostayob> i wrote them just now
17:50:25 <elliott> Better than cluttering every single piece of code with global-locking logic.
17:50:35 <Sgeo> ddarius, http://wiki.activeworlds.com/index.php?title=SDK
17:50:36 <rostayob> anyway, going to bed now, i'm going to investigate what to do with Auto tomorrow :)
17:50:39 <rostayob> mm_freak: thanks for the tips
17:51:40 <Sgeo> ddarius, relevent info: http://wiki.activeworlds.com/index.php?title=Aw_callback_set
17:52:09 <Sgeo> I can do synchronous calls, actually, but I think things would get ugly
17:52:37 <Sgeo> (uglier)
17:53:11 <Sgeo> Basically, the "wait for event" functionality would move from aw_wait to whatever the synchronous call is
17:54:19 <Sgeo> And as far as I can tell, it would be impossible to actually lock the global lock the instant it returns
17:54:39 <Sgeo> Unless I expanded the global lock to include waiting for it, but then nothing else can do stuff
17:54:50 <kniu> okay so LLVM.FFI.Core doesn't work
17:54:59 <kniu> I need an alternate way to output LLVM code
17:58:17 <Sgeo> elliott, not sure what you mean by widening it
17:59:40 <elliott> Sgeo: You have a global lock that is fractured into a bunch of pieces, but the end result is still that only one thread is going to be in your code at a given time, so just call a spade a spade and make it a global lock. Or redesign your interface to have less mismatch.
18:00:16 <Sgeo> But that's not the desired end result
18:01:05 <Sgeo> If I have a callback to look up a person, and a separate thread runs a thing to look up an object, they can run at the same time
18:01:42 <elliott> Okay. So there's even more mismatch than I thought.
18:02:25 <Sgeo> This is all internals of my wrapper. The client should never have to deal with any of this garbage
18:02:37 <elliott> That does not mean there isn't a mismatch.
18:06:03 <ddarius> Sgeo: So, you should have a process that hooks all the callbacks that you are interested in.  You should have threads send requests to that process.  That process will give back an MVar that will hold any relevant results and will store a mapping to the information in the operation that can be used to disambiguate the returns, e.g. citizen name.  When a callback is called, that process will demultiplex the result appro
18:06:03 <ddarius> priately.
18:06:12 <Axman6> kniu: are you sure you're liniing properly to the LLVM library?
18:06:26 <kniu> Axman6, liniing?
18:06:29 <kniu> linking?
18:06:39 <kniu> how do I "link properly"?
18:09:00 <Sgeo> I haven't exactly checked if there is always disambiguating information
18:09:54 <Axman6> kniu: you probably need to specify the path to the LLVM libs when compiling. it's been a while since i've done it
18:10:53 <roconnor> @hoogle setBit
18:10:53 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
18:10:59 <kniu> Axman6, I've never had to do that for GHC before
18:11:12 <kniu> it always seemed to be able to find the required .so files automatically
18:11:23 <Axman6> fair enough
18:11:48 <kniu> also, wouldn't it be complaining about the missing libraries instead of missing symbols?
18:11:51 <ddarius> Sgeo: An alternative is simply to fork a thread every time you need to call a method and stick to the synchronous calls.  Then there is no ambiguity.
18:12:21 <ddarius> I would be very, very surprised, though, if this library is thread-safe in the slightest.
18:12:34 <Sgeo> ddarius, the library I'm wrapping is not thread-safe in the slightest
18:12:43 <elliott> So you *do* need a global lock.
18:12:48 <Sgeo> Yes.
18:13:03 <elliott> And are still trying to use finer-grained locks?
18:13:13 <Sgeo> For different purposes to the global lock
18:13:32 <Sgeo> The global lock is more of a "quickly grab it, do what you need to do, and let go" sort of thing
18:14:24 <Sgeo> These smaller locks are more "help tell the difference between this call and that call" sort of thing
18:16:40 <ddarius> Sgeo: Because this library essentially requires you to assign values to global variables and then call methods, pretty much all your calls to this library will need to go through one thread.
18:18:02 <Sgeo> Assuming the SDK doesn't use thread-local storage, what's wrong with just a global lock (and smaller locks for callbacks) for this?
18:19:11 <ddarius> What do you need the smaller locks for?
18:19:50 <Sgeo> As a way of preventing confusion about which callback goes with which call
18:22:06 <m3ga> conduits anyone? getting "No instance for (C.IsSource C.PreparedSource) arising from a use of `C.$$'". anyone have a clue what that means?
18:22:33 <Sgeo> Is there a function to convert a PreparedSource into a Source?
18:23:37 <elliott> m3ga: I think you're meant to use a Source, not a PreparedSource (the result of initialising a Source).
18:24:19 <Sgeo> A Source is simply a monadic action that returns a PreparedSource.
18:24:21 <Sgeo> return?
18:24:30 <Sgeo> Hmm, that seems wrong
18:24:40 <Sgeo> Wait, why am I saying that seems wrong
18:24:47 <Sgeo> What would the type of Source . return be?
18:25:01 <ddarius> Sgeo: I'm not sure using the smaller locks actually buys you much over just using the global lock for everything.  That approach seems beneficial only if the separate threads make a lot of requests but to distinct sets of methods but very occasionally make requests to methods other threads use.
18:25:02 <m3ga> yeah, return also doesn't work.
18:25:18 <ddarius> Sgeo: Even then, it seems overly complicated and error-prone.
18:26:00 <Sgeo> I am assuming that the "lot of requests but rarely to things other threads use" is the common case
18:26:11 * hackagebot couch-hs 0.1.6 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.6 (PeterSagerson)
18:26:11 <Sgeo> And also note that there are things that don't involve callbacks at all.
18:26:18 <Sgeo> (Or at least what the SDK calls callbacks)
18:26:40 <elliott> Sgeo: Basically every request goes through the network, yes?
18:27:06 <Sgeo> Are you going to tell me to ignore the SDK and write for the protocol directly?
18:27:06 <elliott> It seems the only advantage of not using a completely global lock for everything is if the server can process multiple requests in parallel.
18:27:21 <ddarius> Sgeo: So you are going to have a thread that calls a lot of object functions, but every once in a blue moon calls citizen functions, and another thread that is vice versa?
18:27:21 <elliott> I mean, there's a slight pipelining benefit even if it doesn't, but it's probably far too minor to bother with.
18:27:54 <Sgeo> I think it can process in parallel.
18:28:22 <Sgeo> ddarius, well, I was thinking that a thread would more, say, manage a part of a game dealing with x y and z, and might, during its run, call various types of callbacks
18:28:27 <elliott> I would be very surprised if their server is threaded, considering the state of this API wrt threads.
18:28:54 <elliott> One thread per client, sure.
18:29:00 <elliott> But your program presumably constitutes one client.
18:29:16 <Sgeo> Could be multiple clients, actually
18:29:36 <Sgeo> The SDK actually handles that half-reasonably.
18:29:42 <Sgeo> half being the keyword.
18:30:03 <ddarius> Sgeo: The only question is what methods the threads call.  Do the sets of methods typically called largely overlap or not.  If you had a thread for, say, several bots that will use a variety of methods regularly, then your scheme will produce very little speed-up over just using a global lock all the time.
18:31:09 <elliott> Sgeo: I suggest you try and measure whether the server gets any speedup from multiple requests at once.
18:31:17 <elliott> If not, there is no point doing anything but a completely global lock.
18:32:17 <Sgeo> Would it hurt to do what I'm doing?
18:33:11 <elliott> Yes, since you've just spent about half an hour trying to explain what you're doing :P
18:33:20 <elliott> And it's wildly overcomplicated.
18:33:23 <ddarius> Sgeo: It adds complexity and errors.
18:33:35 <ddarius> And the "benefits" may not even exist.
18:35:43 <Sgeo> I guess I could use a second global lock...
18:36:46 <ddarius> Also, here's a much simpler way of doing what you are describing.  Spawn a thread for each independent set of methods.  Other threads can send requests to these threads when they need a particular method called.  That process asynchronously but sequentially sends the requests in the order received.
18:37:16 <ddarius> This approach would be identical to yours in behavior, but involves no locks whatsoever.
18:37:39 <elliott> ddarius: Apparently there are as many possible requests as CInts, since Sgeo wanted to use lazy IO to initialise a map of the locks.
18:37:49 <Sgeo> elliott, no, there aren't
18:37:53 <ddarius> elliott: Read the API docs.
18:38:32 <Sgeo> ddarius, I'm not entirely sure how that's simpler
18:39:05 <m3ga> elliott, Sego : needed to do "C.bufferSource $ C.Source $ return $ source' instead of just 'source'
18:39:16 <elliott> ddarius: That sounds painful.
18:39:20 <thlorenz> what is a common library that people use to generate xml?
18:39:25 <elliott> Anyway, Sgeo is the one who claimed there'd be 2^32 locks to initialise.
18:39:59 <Sgeo> I only was thinking that I'd want to be able to initialize any needed lock, without specifying in advance the possibilities
18:40:23 <monochrom> 2^32 locks are going to be slow. locks aren't free, just cheap.
18:40:27 <thlorenz> currently looking into xml pickler, but are there more popular ones?
18:40:44 <ddarius> Sgeo: There is no possibility of forgetting to take or release a lock.  Each thread only needs to deal with the methods its responsible for and nothing else.  All calls to the methods simply become writeChan citizenChan (CitizenChange foo bar baz) etc.
18:40:46 <elliott> thlorenz: There's HXT and HaXml.
18:40:49 <elliott> I don't know anythinga bout them, though.
18:41:08 <elliott> *about
18:41:18 <thlorenz> elliot: those are the two I found so far as well
18:41:24 <monochrom> method call as message passing. the holy grail of OOP
18:41:39 <ddarius> (Actually, you'll probably need to pass in a return MVar that you can wait on as well, but that's easy enough to do and encapsulate.)
18:42:05 * elliott distinctly recalls recommending "use a Chan to handle requests that return through an MVar" to Sgeo months ago.
18:42:25 <Sgeo> Taking and releasing locks can be easily encapsulated in my code, I think
18:42:51 <Sgeo> elliott, all I can remember is recently when I was using an MVar where a Chan would make more sense
18:42:59 <monochrom> that MVar idea is analogous to stamped self-addressed envelope
18:43:21 <ddarius> Sgeo: I never said you couldn't encapsulate it.  I'm saying there's a clearer and less error-prone way of implementing it while still encapsulating it nicely.
18:43:57 <Sgeo> When would I fork off the thread? The first time something is called?
18:44:14 <ddarius> Sgeo: You would fork it off at program start.  It would just loop forever.
18:44:47 <Sgeo> Hmm, no thanks. I don't feel like needing to remember to hook up all of these things somewhere.
18:45:12 <elliott> Computers are excellent at not forgetting to perform tasks.
18:45:19 <ddarius> Instead you want to remember to hook up all of these things everywhere?
18:45:38 <monochrom> you want to remember to acquire locks and then release locks
18:46:15 <Sgeo> I will mostly be acquiring and releasing in 1 definition, I ... think
18:46:29 <monochrom> "so you want to write a fugue? so go ahead..." http://www.youtube.com/watch?v=N2JFgfc7c70
18:46:31 <Sgeo> But yes, I actually understand my lock-based solution
18:46:46 <elliott> I don't see how ddarius' solution can really require any more boilerplate than you'll already have.
18:46:55 <elliott> If you can programmatically determine the number of request types, you can programmatically spawn all the threads.
18:47:00 <monochrom> "so don't be clever for the sake of being clever"
18:47:01 <elliott> So there's no "remembering" to be done.
18:52:01 <monochrom> (ObTopic: a fuge is like a multi-threaded program :) )
18:52:22 <monochrom> err, s/fuge/fugue/
18:54:03 <ddarius> monochrom: A relatively simple and structured multithreaded program.
18:55:02 <Axman6> wouldn't it be more like a parallel program? doing lots of the same thing at the same time (possible at different speeds)
18:55:10 <elliott> deterministic, at that
18:55:40 <elliott> Axman6: That's not really what parallelism means, is it?
18:55:48 <monochrom> so you want to multi-thread, you got the urge to multi-thread, you got the nerve to multi-thread, so go ahead and multi-thread so we can sync :)
18:55:49 <Axman6> depends who you ask
18:55:55 <elliott> A program that calculates the sum and the product of a list of numbers in parallel is ... parallel.
18:56:00 <elliott> But it's not doing the same thing.
18:59:00 <ddarius> Axman6's notion is closer to the notion of "data parallel" or SIMD parallelism.
18:59:28 <Axman6> less SIMD though
18:59:38 <Axman6> otherwise the different speeds part wouldn't make sense
19:00:27 <ddarius> Axman6: That's why it's "is closer to" not "is."  Also, SIMD is a general term.
19:00:48 <Axman6> yeah i guess the granularity of an
19:00:57 <Axman6> instruction is important*
19:01:33 <Axman6> @let simd = map
19:01:34 <lambdabot>  Defined.
19:01:38 <ddarius> Even for processors, there's no reason the microcode operations of a SIMD instruction have to be in lockstep, though I believe they essentially always are.
19:02:12 <ddarius> Or do I believe that?
19:02:33 <Axman6> http://en.wikipedia.org/wiki/List_of_lists_of_lists
19:03:18 <ddarius> Hopefully noone pollutes that with a mere list.
19:03:35 <Axman6> now, should the list of lists of lists contain itself?
19:03:59 <Axman6> yes, apparently, =)
19:04:10 <ddarius> It should.  It should also be in the list of lists.
19:04:28 <ddarius> Which would be contained in the list of lists of lists.
19:04:36 * Axman6 is reminded to get back to reading GEB
19:05:18 <ddarius> LLL in LLL and LLL in LL and LL in LLL (and LL in LL for that matter.)
19:06:38 <ddarius> As long as they don't make a "list of lists that do not contain themselves" the universe should be good.
19:07:51 * byorgey things we should make such a page and then sit back to watch the ensuing edit war
19:07:54 <cmccann> ddarius, "List of lists that do not contain themselves" is mentioned right on the page
19:07:56 <byorgey> *thinks
19:08:23 <elliott> revision history shows a bunch of people adding links to russell's paradox and the like and getting reverted
19:08:29 <elliott> so i'd say the joke is already tired :P
19:08:38 <ddarius> elliott: Of course it is.
19:08:59 <elliott> anyway, it could easily survive that, just put a "this list is not complete, please help wikipedia by expanding it" notice up
19:09:02 <elliott> like appears on http://en.wikipedia.org/wiki/List_of_numbers
19:09:15 <elliott> add new reliably-sourced numbers to that list to help wikipedia!
19:10:20 <monochrom> create en.wikipedia.org/wiki/List_of_lists_that_don't_contain_themselves and say "this list is not complete or consistent, please help wikipedia by improving it" :)
19:10:41 <ben> :D
19:11:10 <monochrom> or "please help wikipedia by diagonalizing it" :)
19:11:17 <Axman6> "This has been reported as a big to the Wikipedia team"
19:11:23 * ddarius defines the number that is the number of knowable numbers.
19:11:45 <ion> Is it more then seven?
19:12:23 <elliott> ion: It wasn't, but you just made it be.
19:12:37 <irene-knapp> is it more than eight?
19:12:39 <irene-knapp> this is fun!
19:12:47 <elliott> Stop it! You'll overflow the counter!
19:12:50 <irene-knapp> haha
19:12:52 <irene-knapp> is it more than -1
19:12:52 <irene-knapp> wait
19:13:11 <elliott> Is it more than ω?
19:13:31 <ion> Is it more than ಠ?
19:13:32 <Axman6> dude, that's a letter
19:13:38 <Axman6> and half a face
19:15:00 <elliott> Axman6: ω is an ordinal number.
19:15:18 <ddarius> elliott: No.
19:15:40 <ddarius> It's a finite number.
19:15:50 <Axman6> it's a name used for many numbers in many contexts
19:15:56 <Axman6> and that is why i say it is not a number
19:16:08 <elliott> You didn't say it wasn't a number, you said it was a letter :)
19:18:10 <ddarius> Under the restrictions of ultrafinitism, the natural numbers has a rather interesting structure.
19:19:48 <Sgeo> What is inlinePerformIO doing?
19:20:03 <Sgeo> inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
19:20:07 <c_wraith> pattern-matching on the super-secret IO constructor
19:20:09 <Sgeo> On some slide about ByteString
19:20:17 <Sgeo> I mean, why not unsafePerformIO?
19:20:24 <Sgeo> unsafePerformIO has the same type
19:20:31 <ddarius> inlinePerformIO gets inlined, unsafePerformIO does not.
19:20:34 <c_wraith> it has a bunch of restrictions
19:20:40 <c_wraith> it only works for some things
19:20:50 <c_wraith> (in ways that can't be expressed by the type)
19:21:00 <Sgeo> Hmm
19:21:00 <c_wraith> But it's much more efficient for the things it works for
19:21:05 <elliott> Sgeo: inlinePerformIO is like unsafeDupablePerformIO but GHC is allowed to pick apart the results, IIRC.
19:21:10 <Axman6> does inlinePerformIO work on things that actually do IO?
19:21:13 <elliott> It's something like you can't do inlinePerformIO (breakEverything >> putItBack).
19:21:20 <elliott> Because the two parts can get reordered, or something.
19:21:25 <elliott> I don't actually know; I'll shut up.
19:21:32 <c_wraith> I doubt inlinePerformIO even works for reading from a file.
19:21:40 <Axman6> #ghc is that way...
19:21:49 <ddarius> c_wraith: No, because reading from a file is not something that should be duplicated.
19:27:27 <startling> is there a way to use bind monadic actions in a `where` statement?
19:28:40 <XexonixXexillion> are there any decent ncurses libraries? (i.e more than just a wrapper around a c library)
19:28:46 <Axman6> startling: that sounds like a quite confused question.
19:28:58 <startling> heh.
19:29:21 <Axman6> the answer is yes, but you're probably trying to do something wrong...
19:29:45 <startling> Axman6: I want to use pattern matching on the arguments of a monadic action, can I do that?
19:29:51 <elliott> yes
19:29:52 <elliott> do { Just x <- m; ... }
19:30:20 <elliott> XexonixXexillion: there's http://hackage.haskell.org/package/ncurses
19:30:26 <elliott> XexonixXexillion: also http://hackage.haskell.org/package/vty but that isn't based on ncurses
19:30:29 <Axman6> or do { x <- m; case x of Just y -> ...; Nothing -> ...; }
19:33:45 <startling> is there a good way to pattern match away a string prefix?
19:34:13 <XexonixXexillion> elliott: thanks, that's exactly what I was looking for... why was that one not on the GUI libraries wiki page...
19:34:21 <startling> I can do `| ("p":"r":"e":rest = ...` but that's a pain
19:34:35 <elliott> XexonixXexillion: which one?
19:34:44 <elliott> strager: s | "pre" `isPrefixOf` s = ...
19:34:46 <XexonixXexillion> elliott: ncurses
19:34:48 <elliott> XexonixXexillion: ah
19:34:49 <Axman6> startling: use the isPrefixOf function
19:34:52 <elliott> you could add it :P
19:35:16 <pVi> is there a good gchi interpreter for vim? I saw one or two, but they didn't seem to work properly. (I'm using MacVim)
19:35:31 <startling> Axman6: yeah, but then I get the entire string as a variable.
19:35:39 <startling> it's not the biggest deal, but it would be nice
19:36:48 <XexonixXexillion> pVi: what features are you looking for?
19:36:59 <elliott> startling: ah, you could try the split package
19:37:09 <pVi> Just load the current file directly into the interpreter.
19:37:21 <elliott> pVi: you can use :r in ghci to reload quickly
19:37:30 <monochrom> startling: stripPrefix helps
19:37:48 <XexonixXexillion> pVi: why not just use ":!ghci %" ?
19:38:35 <startling> yeah, I can just strip the prefix.
20:02:54 <startling> w
20:03:02 <startling> oops, wrong window
20:06:12 * hackagebot full-sessions 0.6.2.1 - a monad for protocol-typed network programming  http://hackage.haskell.org/package/full-sessions-0.6.2.1 (KeigoImai)
20:27:41 <tommd> preflex: seen lemmih
20:27:41 <preflex>  lemmih was last seen on #haskell 17 hours, 6 minutes and 32 seconds ago, saying: Ke: runhaskell -hide-all-packages "-package mtl"
20:50:45 <Sgeo> "From a theoretical point of view, type families (TFs) and functional
20:50:45 <Sgeo> dependencies (FDs) are equivalent in expressiveness. "
20:51:00 <Sgeo> Yet in the conduit blog posts, Snoyman stated that he had to use TFs
20:52:33 <cmccann> Sgeo, equivalent expressive power doesn't imply equivalent API niceness, among other things
20:59:25 <rata_> hi
21:00:06 <rata_> does anybody know why there are two indentation-aware parsec libraries (indents and IndentParser)?
21:01:36 <Sgeo> Are there any idioms for unit testing where each test can take a significant amount of time?
21:03:50 <ddarius> rata_: Probably more than two.
21:07:11 <rata_> ddarius: which one would you recomend?
21:08:12 <ddarius> rata_: I've never used any.
21:09:37 <Philippa> rata_: I'd suggest checking how each one actually works, they may well use different rules
21:10:21 <Philippa> I have a module lying around that I've not uploaded that does slightly generalised Haskell-style layout for parsec 3 as well, for example - which is quite different to python's approach, or even the in-practice approach of most haskell compilers
21:10:43 <rata_> ddarius, Philippa: ok... they look identical in their description, I think probably just one of them is up-to-date
21:11:09 <elliott> Sgeo: they're not equivalent in the presence of some extensions, IIRC.
21:12:55 <rata_> I'm trying to look for examples, but the ones I found doesn't really help that much in understanding any of both
21:12:55 <cmccann> fundeps let you get away with more stuff using overlapping instances
21:13:48 <cmccann> last I checked you can't write Oleg's TypeEq stuff with only TFs
21:14:49 <Philippa> rata_: you may have to read the source, unfortunately
21:20:04 <rata_> this seems to be a real pain in the ass... I can't believe there's nothing better to handle indentation-based syntaxes
21:22:35 <kallisti> something weird just happened.
21:22:51 <kallisti> earlier today I'm pretty sure I saw a logical negation operator in Control.Monad.Logic.Class, but now it's gone?
21:24:48 <Philippa> rata_: I suspect many people do what I did and crib off the Haskell Report in one form or another
21:24:50 <geekosaur> kallisti, looks there to me.  lnot, at the bottom of the page
21:25:03 <Philippa> admittedly, I was specifically targetting Haskell-like syntax
21:25:06 <geekosaur> (going off the docs on hackage)
21:25:23 <kallisti> perhaps I'm looking at the wrong version
21:25:24 <geekosaur> logict-0.5.0 package
21:25:28 <kallisti> why does google like to give me the wrong version?
21:25:33 <Philippa> it sounds like the existing packages are underdocumented though?
21:25:50 <ddarius> kallisti: Which version is the wrong version?
21:25:52 <rata_> Philippa: I'm targeting something similar... how did you do it? did you use states to store the indentation level?
21:27:14 <ddarius> "Why are there three libraries that do the same thing?"  "These suck.  I'm going to write my own."
21:28:18 <kallisti> ddarius: older versions specifically
21:28:40 <Philippa> I was already using a lexing stage, so I ported the Report's stuff on top of that. To handle the parse-error case, I did a little parsec 3 magic so the parser could tell its input stream that it'd like a layout } right now if it can get one, and used that every time I was parsing a } that could be layout
21:29:06 <geekosaur> ddarius, ob http://xkcd.com/927/
21:30:51 <carr> help
21:30:57 <carr> oops
21:31:09 <elliott> hi
21:31:30 <elliott> geekosaur: blatant ripoff of ancient joke about editors
21:31:34 <carr> false alarm, i was typing help for ERC in emacs
21:31:51 <elliott> (well, at least i recall hearing one with identical structure long before xkcd got 900 comics :p)
21:32:26 <Philippa> rata_: the best description I've heard of what I did was that I used a "backtracking lexer" :-)
21:33:01 <Philippa> if you don't want the parse-error case, it's a lot easier and you can put the layout stack in the parser state, yeah
21:33:19 <Philippa> I deliberately wanted token info and so forth though
21:33:27 <rata_> ok
21:33:36 <rata_> well, I need something very simple
21:34:12 <rata_> indeed I can't believe something that simple is not in parsec itself
21:34:44 <rata_> I just need to parse a block, much like where or do in haskell (and without the braces case)
21:34:46 <elliott> most parser libraries do not support indentation-based syntax
21:34:50 <elliott> in any language
21:34:57 <Philippa> "just" - what exact rules do you want it to use?
21:35:08 <Philippa> (I'm not being funny here, it makes a difference)
21:36:14 <rata_> the same as for do... it can be "do something\n<3 spaces>something else" or "do\n<n spaces>something\n<n spaces>something else"
21:36:35 <Philippa> ah. You've not done this before, have you?
21:37:19 <rata_> no, it's the definition of a block as appear here http://hackage.haskell.org/packages/archive/IndentParser/0.2.1/doc/html/Text-ParserCombinators-Parsec-IndentParser.html or here http://hackage.haskell.org/packages/archive/indents/0.3.0/doc/html/Text-Parsec-Indent.html
21:38:57 <Philippa> neither of those appear to be precisely defined in the docs, though
21:39:40 <Philippa> the second one appears to be aware of Parsec 3 though, which may be preferable
21:41:08 <rata_> Philippa: well, I tried to use that one first, but I couldn't figure out how
21:42:58 <Philippa> it looks like it stacks ParsecT on top of its own state, so it wants you to call runIdent on whatever the parser returns
21:43:51 <Philippa> I suspect you're going to find that nothing is quite as simple as you were hoping for, though
21:44:03 <Philippa> there are more design trade-offs involved than are immediately obvious
21:44:59 <Philippa> but block looks like it's just a variant of many, from your point of view - what's confusing you?
21:45:04 <rata_> I don't really care if it does more than what I expect, the only thing I hope is not to have to rewrite the whole parser just because I want some things to be in block form
21:47:56 <Philippa> yeah. So: what's so hard here?
21:48:13 <Philippa> are you familiar with monad transformers?
21:48:48 <rata_> not really
21:49:07 <rata_> sometimes I feel I understand them
21:49:31 <Philippa> okay. Is IndentParserT and runIndent what's hard?
21:49:40 <Philippa> or are you having trouble figuring out how to parse a block?
21:52:02 <cy> Oh, oh dear.
21:52:06 <elliott> oh no
21:52:52 <cy> Now I'll have to actually form questions.
21:52:54 <rata_> I think I'm giving up, because I'm not even sure if a block is what I need... what I need is a little bit different from that... I need something like "rules: a, b, c" and a, b, and c can be in different lines as long as they respect the block indentation syntax
21:53:38 <rata_> but the comas must be there
21:53:46 <Philippa> yeah, that's slightly different
21:54:00 <rata_> and you can put a and be in the same line and c in another one
21:54:03 <rata_> is that a line fold?
21:54:04 <Philippa> why not keep a "minimum acceptable indentation" stack in your state?
21:54:14 <Philippa> it sounds like your use case is pretty simple
21:54:32 <rata_> because messing with state is exactly what I have been trying to avoid
21:54:35 <Philippa> you'll have to modify everywhere you've got a pattern like that, but you should be able to build a combinator
21:54:42 <Philippa> ah. Don't, this is a good use for it
21:54:47 <Philippa> sometimes it's actually good engineering
21:54:49 <cy> I've been trying to get the "hecc" module to do ...anything. Um... the type signature for genkey is ECP a => a -> EC -> IO a.
21:55:12 <kallisti> what arrow function should I use if I want to apply 1 function to 2 tuple elements?
21:55:16 <cy> There are many ECP instances, but they all have something called a "constructor" which I haven't a clue what means. They're already instantiated, right?
21:55:42 <rata_> Philippa: any pointers to a good introduction to using state in parsec?
21:55:42 <kallisti> > join (***) (+1) (1,2)
21:55:43 <lambdabot>   (2,3)
21:55:52 <cy> There doesn't seem to be any way to produce an EC. And the IO it puts out doesn't seem to produce anything printable...
21:55:54 <Philippa> rata_: it's much the same as using any other state monad
21:57:28 <elliott> cy: EC (Integer, Integer, Integer)
21:57:30 <elliott> from the docs
21:57:36 <elliott> (sigh, tuple in data type)
21:57:49 <rata_> any good introductions to using any other state monad then?
21:58:18 <Sgeo> Why is there a tuple in a data type? Does supporting EC _|_ separately from EC (_|_, _|_, _|_) make semantic sense in this case?
21:58:21 <cy> elliott: Yeah, I gathered. So EC is a function that takes a tuple?
21:58:22 <Philippa> I'm too old guard to know what's any good these days, honestly
21:58:37 <rata_> ok
21:58:38 <Philippa> you get two monadic operations that really matter, and they get and set the state as if it were a single mutable variable
21:59:04 <shachaf> "state" is the monadic operation that really matters. :-(
21:59:07 <Philippa> they're often called something like get and set, and you use them like so: do set 2; a <- get
21:59:10 <shachaf> (For State.)
22:00:02 <Philippa> shachaf: doing?
22:00:11 <cy> The thing is the documentation says "Constructors EC (Integer, Integer, Integer)"
22:00:18 <elliott> cy: Yes.
22:00:21 <elliott> A constructor, technically.
22:00:22 <cy> Shouldn't it be Constructors EC (Integer, Integer, Integer) -> something?"
22:00:26 <elliott> No, it's
22:00:28 <shachaf> @ty state
22:00:29 <lambdabot> forall s a. (s -> (a, s)) -> State s a
22:00:30 <elliott> data EC = EC (Integer, Integer, Integer)
22:00:48 <Sgeo> EC :: (Integer, Integer, Integer) -> EC
22:00:56 <shachaf> Philippa: That, except for any MonadState.
22:01:00 <elliott> That is true, but not a valid declaration.
22:01:15 <shachaf> elliott: Not even in a GADT?
22:01:20 <cy> So EC is a function that takes three integers and results in... itself? sort of a way to wrap 3 integers meaningfully?
22:01:24 <elliott> Yes, introducing GADTs will help a lot.
22:01:36 <elliott> cy: If you haven't encountered data types yet, writing a full program might be a bit ambitious :)
22:01:36 <shachaf> cy: The type "EC" and the value "EC" are completely distinct.
22:01:39 <Sgeo> cy, no, EC the function and EC the type are different things
22:01:53 <elliott> EC takes a triple and results in a value of type EC.
22:01:53 <cy> elliott: define encountered. :|
22:02:00 <shachaf> This causes a bit of confusion. You could call the value "EC" (the (value) constructor) "MkEC".
22:02:00 <Philippa> shachaf: honestly? I consider that about as helpful as "S and K are the operations that really matter"
22:02:09 <elliott> Philippa: Of course they are.
22:02:14 <elliott> Haven't you heard of Applicative?!
22:02:23 <shachaf> Philippa: It's just a much more reasonable primitive than "get" and "set".
22:02:26 <cy> shachaf: So you could say MkEC :: (Integer, Integer, Integer) => EC?
22:02:33 <cy> er
22:02:36 <shachaf> cy: No, "=>" is completely different.
22:02:37 <cy> shachaf: So you could say MkEC :: (Integer, Integer, Integer) -> EC?
22:02:42 <cy> yeah I forgot sorry
22:02:45 <shachaf> cy: MkEC does have that type.
22:02:47 <elliott> You can't actually do that.
22:02:50 <elliott> But if it was called MkEC, you could.
22:02:56 <elliott> And by do, I mean state correctly; you can't defineit that way.
22:02:59 <elliott> *define it
22:03:11 <cy> Can't I call it MkEC?
22:03:20 <cy> Not that I want to, just trying to understand the syntax.
22:03:43 <Sgeo> cy, the thing is, that :: stuff doesn't work on constructors, which need to be defined with data
22:03:53 <Philippa> shachaf: different notion of "really matter". Also, really shitty thing to throw at a confused beginner
22:03:56 <elliott> cy: You can't, because you're not defining EC.
22:04:04 <Sgeo> If a value has a capital letter, like MkEC does, it's a constructor.
22:04:08 <elliott> But you could pretend, if you wanted to talk about it.
22:04:23 <cy> So what exactly is a constructor?
22:04:26 <Sgeo> Er, begins with
22:04:42 <elliott> cy: It might be more productive to read what e.g. LYAH has to say on the matter rather than having people try to haphazardly reproduce it on IRC :P
22:04:50 <shachaf> Philippa: True, this is more of a general statement.
22:05:01 <elliott> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
22:05:02 <cy> I read LYAH... hm...
22:05:35 <cy> Oh damn I stopped at ch 7 haha whoops
22:06:05 <cy> brb den00bin
22:06:17 <elliott> That's chapter 8 :)
22:08:55 <mr_sleepy> LYAH is very great, with one exception: no exercises >:(
22:11:05 <Scriptor> mr_sleepy: easy workaround to that
22:11:26 <Scriptor> mr_sleepy: whenever it introduces a new function, try to write it before you peek at the code for it
22:11:59 <cy> so data A = B (a,b,c) makes a function B that produces the type A when fed a 3-tuple. Not a function A. And data EC = EC (a, b, c) makes a function called EC that produces a type EC the same way, just both named EC.
22:12:11 <Sgeo> Yes
22:12:56 <elliott> cy: yes, but usually it's
22:12:58 <elliott> data A = B a b c
22:13:02 <elliott> the use of a tuple here is unidiomatic
22:13:08 <cy> well, sure...
22:13:37 <Sgeo> elliott, maybe the author of that library really cares about the extra value
22:13:39 <shachaf> cy: It's also a magic function because you can unapply it.
22:13:58 <shachaf> foo :: A -> (a,b,c); foo (B blah) = blah
22:13:59 <cy> hah, unapply so like (B a b c) = someA
22:14:07 <elliott> just pattern matching :P
22:14:22 <Sgeo> Hmm, what does Scala's unapply do?
22:14:32 <Philippa> rata_: did that make any sense re state?
22:15:09 <rata_> well, I'm reading to make sense of it
22:15:34 <rata_> I'm attempting to follow your recomendation and use state now
22:16:25 <Sgeo> Customizable pattern matching?
22:16:39 <Sgeo> I guess that use case in Haskell is doable with ViewPatterns
22:16:53 <elliott> she has pattern synonyms
22:17:55 <rata_> Philippa: what does it mean that the underlying monad of ParsecT is StateT SourcePos m?
22:18:46 <Sgeo> {-# OPTIONS_GHC -F -pgmF she #-}
22:18:53 * Sgeo has no idea what those options do
22:19:07 <Philippa> it means your parsing monad's got access to the features of StateT SourcePos m - that is, some state holding a SourcePos
22:19:08 <Sgeo> Well, run she as a preprocessor
22:19:27 <elliott> -F turns on the preprocessor
22:19:30 <elliott> -pgm stands for program
22:19:34 <elliott> -pgmF = preprocessor program
22:19:50 <elliott> (you can also use opt in place of pgm for options, etc.)
22:20:21 <Sgeo> What if I don't have ~/.cabal/bin in my PATH?
22:20:31 <Sgeo> Then I guess I could put ~/.cabal/bin/she instead?
22:21:38 <elliott> Sgeo: Why don't you have ~/.cabal/bin in your PATH?
22:21:43 <elliott> You need that to install lots of packages anyway.
22:22:04 <Sgeo> elliott, because I'm too lazy to add it?
22:22:42 <rata_> Philippa: ok.. could they achieve the same using ParsecT s SourcePos Identity a? I mean, what they need to use a different underlying monad to have state if ParsecT already provides means to handle state?
22:22:45 <elliott> Seems like tweaking every program using she, and being unable to install packages depending on alex or happy, would kind of outweigh that, but okay.
22:22:51 <m3ga> @tell meggamine_ xmonad compiles here on debian stable ppc
22:22:51 <lambdabot> Consider it noted.
22:22:54 <startling> I have a data type in one file. When I have another file and import it, the type constructors are apparently not being imported. What am I doing wrong?
22:23:56 <Philippa> rata_: they don't, they're offering you extra possibilities by not fixing m = Identity
22:24:17 <Philippa> similarly, they're not taking up Parsec's state slot
22:24:24 <Philippa> that's just being a good citizen, as it were
22:26:05 <elliott> startling: Does one module have an explicit export list?
22:26:43 <elliott> If it contains the type name, you need to change e.g. A into A(..) in the export list, to export all the constructors. (Unless you mean the literal meaning of "type constructor", in which case it's probably not in the list at all.)
22:27:18 <startling> elliott: yep, that did the trick.
22:27:24 <rata_> Philippa: ah ok, thanks
22:28:58 <rata_> Philippa: but then you need to call runIndent on what runParser returns right?
22:29:13 <cy> When I say main = ... putStrLn (show key) and it outputs "Null" does that mean key is the exact defined instance named Null, or could it be a type that doesn't implement Show?
22:29:37 <Philippa> rata_: yeah, exactly
22:29:37 <shachaf> cy: I think you might be misusing the word "instance" here.
22:29:48 <cy> yeah, probably.
22:29:52 <shachaf> But it means that the type definitely implements Show.
22:30:01 <shachaf> Otherwise it would be an error at compile-time.
22:30:02 <startling> (and yeah, I did mean data constructor. I always get those confused.)
22:30:05 <cy> When (show a) returns "Null" what do mean
22:30:07 <Philippa> before, you had a parsing machine running a parsing program. Now, you have a state machine running a parsing machine running a parser
22:30:10 <cy> or is it type specific
22:30:21 <cy> as in check the source
22:31:23 <elliott> cy: It probably means that key is Null.
22:31:31 <elliott> If the Show instance is well-behaved.
22:32:46 <shachaf> elliott: "well-behaved" is pretty broad.
22:33:02 <cy> ehe
22:33:26 <shachaf> I think I'm not saying helpful things here.
22:36:31 <ddarius> shachaf: Is that what we're supposed to be doing here?
22:37:03 <elliott> Evidence points to no!
22:37:10 <ddarius> Woo!
22:37:26 <elliott> Guys, I heard that [monad tutorial joke].
22:38:39 <cy> I don't understand why people find monads so confusing. They're just [insert incorrect definition here].
22:43:35 <rata_> Philippa: thank you very much! I finally figured out how to use Text.Parsec.Indent =D
22:43:44 <wavewave> hi
22:46:15 <wavewave> got home from hac boston.
22:46:17 <Philippa> rata_: cool. I appreciate it's a bit tricky getting used to the way a good monadic library has to abstract stuff :-)
22:46:40 <Philippa> you can see why I said a state-based solution (of some sort) was the way to go?
22:46:56 <Philippa> wavewave: always good to know the bus factor's losing out
22:46:57 <rata_> yes
22:47:11 <Philippa> used judiciously, it's a hell of an abstraction
22:48:06 <wavewave> Philippa: in my case, airplane ;-)
22:48:22 <Philippa> well, you don't want your airplane to hit a bus either!
22:48:27 <rata_> yeah, at the end I'm just using commaSep for what I told you and using block for something that is in block form
22:49:09 <wavewave> lots of progress in hxournal now. I was coding at the airport.
22:49:33 <Philippa> cool
22:49:45 <Philippa> I missed CamHac this year on account of lack of cope :-(
22:49:49 <Philippa> last year, even
22:50:35 <rata_> maybe afterwards I add something for handling that indented commaSep, but that's fine for now
22:55:18 <rata_> Philippa: at the end it was very easy, the only complicated part was to redefine Parser a to use IndentParser... I think my problem was that I've been away of Haskell for more than a month and away of Parsec (and heavy monadic stuff like monad transformers) for a couple of months
22:56:16 <Philippa> *nod* - yeah, it takes a while for stuff to embed into long-term memory enough that you know how to at least relearn quickly and in the meantime a shortish break can really mess you up
23:04:12 <rata_> yes, I hope this time the stuff gets embedded into long-term memory =D
23:06:10 <mgsloan> has anyone already done the conversion of gtk2hs to ghc7.4.0?
23:07:02 <mgsloan> I think I fixed glib - we'll see if it actually runs
23:10:13 <cy> w00t I made a Show instance for something what didn't have one.
23:10:52 <elliott> yay! your first orphan instance
23:11:00 <elliott> http://www.haskell.org/haskellwiki/Orphan_instance :P
23:11:12 <shachaf> data D = D; instance Show D
23:12:39 <cy> uh... 'k...
23:16:38 <ddarius> data D = D deriving ( Show )
23:16:57 <elliott> That's incompatible with shachaf's instance!
23:17:54 <shachaf> elliott: My instance is show = _|_, so you can never know for sure!
23:18:20 <elliott> It's just really slow.
23:19:23 <cy> hua...?
23:19:40 <cy> data D = D deriving ( Show ) is "really slow?" Like, noticeably?
23:20:04 <ddarius> elliott: More evidence.
23:20:13 <frerich> What's really cool about Haskell is that it gives you the "Man, these are the smartest five lines of code I've ever written" feeling like once a month.
23:20:40 <cy> I like how Haskell is lazy.
23:20:46 <cy> Because database query languages are lazy.
23:20:54 <cy> I wanna make a database in pure Haskell.
23:21:13 * hackagebot scotty 0.1.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.1.0 (AndrewFarmer)
23:21:14 <cy> But aside from that, I'm sick of being toyed with by the racket language.
23:21:29 <cy> "with-syntax is a syntax that means with-syntax!"
23:21:44 <frerich> Did anybody play with the latest iteratee-flavour 'pipes' on hackage yet? It looks sos imple and minimalistic, it's hard to believe that it works :-}
23:21:48 <ddarius> frerich: Five lines?!  You have a long way to go.
23:22:03 <frerich> ddarius: :-)
23:22:15 <cy> frerich: I've only run across something called enumerators, aside from the regular IO stuff...
23:24:17 <cy> http://hpaste.org/56884 anyway
23:24:25 <cy> I got a key to output!
23:24:34 <cy> Oh uh...
23:25:24 <elliott> cy: comments are --, not #, btw :P
23:25:47 <shachaf> elliott: That's not a comment, it's the first line of a root shell.
23:25:53 <shachaf> "sudo" is redundant, of course.
23:26:13 * hackagebot wai-middleware-static 0.0.1 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.0.1 (AndrewFarmer)
23:26:21 <cy> elliott: WAS JUST GONNA ASK
23:26:23 <elliott> shachaf:           # help how do I elliptic curve
23:26:23 <elliott>           # wtf are these numbers for? vvvvvv
23:26:31 <shachaf> Oh.
23:26:57 <shachaf> That's, uh, zsh.
23:27:29 <cy> http://hpaste.org/56885 there
23:27:40 <cy> actual use of hecc.
23:29:07 <cy> I swear in the past day I've made comments with ;, //, #, and now --
23:29:13 <cy> Oh and #;()
23:29:27 <cy> I guess that's what I get for making a javascript webapp in a scheme.
23:29:28 <nibalizer> cy: go put something in your vimrc to complete the set
23:29:49 <cy> REM what is this i don't even
23:30:01 <shachaf> PLEASE NOTE that the set will never be completed.
23:30:35 <cy> ..but I like redundant brackets :(
23:41:39 <Blkt> good morning everyone
23:44:30 <rata_> good morning Blkt
