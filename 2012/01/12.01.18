00:00:50 <hpaste_> ClaudiusMaximus pasted “littlewood” at http://hpaste.org/56601
00:00:57 <ClaudiusMaximus> ^^ 70-line program which takes longer to run (wall-clock time) with -N2 than with -N1  -- what am i doing wrong?
00:02:28 <Lemmih> Do you only have one core?
00:02:53 <ClaudiusMaximus> Lemmih: dual core laptop
00:03:25 <Lemmih> 27s with -N1, 14s with -N, looks ok to me.
00:03:47 <Lemmih> Really couldn't be any better, actually.
00:05:22 <ClaudiusMaximus> hm, d'oh - reading the wrong column.,...
00:06:20 <ClaudiusMaximus> > 25/7.4
00:06:21 <lambdabot>   3.378378378378378
00:06:55 <ClaudiusMaximus> thanks Lemmih
00:35:48 <frerich> claudius: Cool, thanks to your littlewood example I just learned a nice way to write a 'clamp' function. I like this way of writing 'a `max` x `min` b', looks very nice :-)
00:36:15 <ClaudiusMaximus> sadly my C++ / OpenMP is 21x faster than my Haskell / parMap :(
00:36:34 <ClaudiusMaximus> frerich: cool :)
00:38:21 <hpaste_> Peaker pasted “Coalesce to thread” at http://hpaste.org/56603
00:38:26 <Redshift64> eh, i think 'min (max a x) b is more readable
00:38:28 <Redshift64> '
00:38:46 <Peaker> Using (IO (forall a. IO a -> IO a)) wants ImpredicativeTypes which is going to go away
00:38:57 <Peaker> min b . max a $ x
00:40:04 <c_wraith> Peaker: I don't think it is going to go away anymore
00:41:26 <c_wraith> 7.0 introduced a new system for marking up impredicative types, rather than deprecating them.
01:12:44 <Itkovian> which package should I use instead of HTTP that allows working with ByteStrings instead of old Strings?
01:16:09 <Silvah> Anyone around?
01:16:25 <shachaf> There is only silence and some second-hand clothes.
01:17:47 <Silvah> If converting a function of type a -> a to CPS the type will be a -> (a -> r) -> r, right?
01:18:30 <shachaf> Yes.
01:19:10 <Silvah> What if I want to CPSify a binary function a -> a -> a?
01:20:12 <shachaf> I'm not sure "CPSify" is really a well-defined operation.
01:20:29 <shachaf> I would ask you to define what you mean by it, but I suppose you're asking us what it means.
01:24:00 <Silvah> Isn't it?
01:24:23 <Silvah> I mean "make it CPS".
01:25:10 <shachaf> If you said that I would probably ask "what do you mean by CPS?".
01:25:24 <shachaf> Similarly for "make a function into a monadic function".
01:26:05 <shachaf> Do you want a -> a -> m a or a -> m (a -> m a) or what?
01:26:28 <shachaf> I guess in this particular case it's a silly question.
01:26:34 <shachaf> What is your goal in "making it CPS"?
01:26:46 <quicksilver> a -> a -> (a -> r) -> r is one way
01:27:01 <quicksilver> if you choose to interpret it as taking two arguments and returning one (via a continuation)
01:27:05 <shachaf> Right.
01:27:11 <quicksilver> on the other hand, a -> ((a -> a) -> r) -> r
01:27:24 <quicksilver> if you choose to interpret it as taking one argument, and returning a function via a continuation.
01:27:25 <Silvah> I'm trying to grok the very concept.
01:34:53 <jeltsch> Does anyone know why the Hackage bot isn’t online?
01:35:09 <ivanm> jeltsch: it's resting
01:35:19 <ivanm> it was tired and shagged out after a prolonged announcement
01:35:19 <ivanm> :p
01:35:24 <ivanm> preflex: xseen hackagebot
01:35:25 <preflex>  hackagebot was last seen on freenode/#haskell 4 days, 12 hours, 1 minute and 45 seconds ago, saying: * hackagebot statistics 0.10.1.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.1.0 (BryanOSullivan)
01:35:32 <ivanm> :o that's a fair time
01:36:14 <jeltsch> ??
01:36:59 <jeltsch> “??” is the command to start preflex according to http://www.haskell.org/haskellwiki/IRC_channel#preflex.
01:37:33 <jeltsch> preflex: quote lambdabot
01:37:34 <preflex>  no quotes found for lambdabot
01:37:38 <jeltsch> Huh?
01:37:45 <shachaf> jeltsch: No, that's not the command to start preflex.
01:37:48 <ivanm> ?quote lambdabot
01:37:49 <lambdabot> lambdabot says: is annoying
01:37:52 <ivanm> heh
01:38:02 <shachaf> If you want to talk to preflex, say "preflex: ..." or (better) /msg preflex ...
01:38:24 <jeltsch> ivanm: Why question mark?
01:38:34 <jeltsch> And not “preflex: ”
01:38:37 <jeltsch> ?
01:38:38 <shachaf> "?" is a prefix for lambdabot.
01:38:42 <ivanm> jeltsch: why not?
01:38:55 <shachaf> That wiki page is pretty horrible.
01:39:14 <jeltsch> According to the abovementioned page, preflex has a quote command. No quote command mentioned for lambdabot.
01:39:32 <jeltsch> preflex: quote jeltsch
01:39:32 <preflex>  no quotes found for jeltsch
01:39:43 * shachaf sighs.
01:39:44 <jeltsch> Seems as if preflex’ quote command doesn’t work.
01:39:58 <shachaf> It works fine. If you want to experiment with it, it's probably best to do it in /msg.
01:39:59 <jeltsch> shachaf: Indeed.
01:40:06 <shachaf> preflex: quote monochrom
01:40:07 <preflex>  <monochrom> n is the nth English letter.
01:41:18 <Silvah> > let addcps x f = f (\y -> x + y) in addcps 5 (*2) 3
01:41:19 <lambdabot>   16
01:42:16 <Silvah> I understand why it's 16, but I don't get how this one works. Could someone explain it?
01:42:50 <shachaf> Why this function works?
01:44:44 <Silvah> Are you asking me?
01:45:44 <shachaf> I'm asking you what it is that you don't get how works.
01:47:07 <magicman> :t let addcps x f = f (\y -> x + y) in \f -> addcps 5 f 3
01:47:07 <lambdabot> forall t t1 t2. (Num t, Num t1) => ((t -> t) -> t1 -> t2) -> t2
01:49:12 <Silvah> I'm not sure I understand your question.
01:49:35 <shachaf> Silvah: I was asking you what your question was.
01:54:38 <Silvah> My question is: what exactly happens when calling this function?
01:55:13 <mlpfim> holla
01:55:41 <ivanm> Silvah: you give it some x value, a function, and a y value
01:55:45 <ivanm> x and y are added
01:55:51 <ivanm> then the function applied to it
01:56:01 <ivanm> (5 + 3) * 2 = 8 * 2 = 16
01:56:08 <magicman> Except that's not what happens.
01:56:27 <magicman> addcps 5 (*2) 3 = (*2) (\y -> 5 + y) 3
01:56:56 <ivanm> how isn't that what happens?
01:56:59 <magicman> Which normally would be a type error, but not in Caleskell.
01:57:14 <ivanm> magicman: yeah, just realised that
01:57:15 <ivanm> :@
01:57:51 <magicman> > let addcps x y f = f (x + y) in addcps 5 3 (*2)
01:57:51 <lambdabot>   16
01:58:35 <magicman> That would be the more conventional definition of addcps.
01:58:41 <magicman> And then what ivanm said.
01:58:46 <ivanm> yeah
01:58:56 <ivanm> I admit I didn't look at it that thoroughly
02:00:46 <statusfailed> How should I match a set of unique strings with parsec?
02:01:06 <statusfailed> (i.e. I don't care the order, just that they don't appear twice)
02:01:55 <Veinor> how big is the set?
02:02:17 <statusfailed> well in this case, 7
02:02:37 <statusfailed> Why does it matter? because of the lookahead thing?
02:02:48 <Veinor> no, i was just wondering whether it'd be less effort to manually write it out
02:03:04 <statusfailed> oh, haha
02:03:22 <statusfailed> well it's more an exercise in learning
02:03:27 <ion> Write a parser that takes a set of parsers as a parameter, matches one of them and recurses to itself with the matching one removed from the set.
02:03:31 <Silvah> Why it's a type error in Haskell, but not in Caleskell?
02:03:49 <Veinor> or you could write a parser that accepts 7 strings and compares them as a set against the target
02:03:55 <shachaf> Silvah: Why is what?
02:03:58 <magicman> Silvah: Caleskell has an instance Num a => Num (b -> a)
02:04:14 <magicman> In which 2 is actually \_ -> 2, and (*) is actually \f g x -> f x * g x.
02:04:17 <statusfailed> ion: oh, I like that
02:04:30 <statusfailed> Veinor: not sure what you mean
02:05:01 <Veinor> well, like
02:05:20 <Silvah> shachaf: are you just being silly?
02:05:24 <Veinor> is it possible to write a parser that parses out the next 7 words xs and succeeds if p xs is true?
02:05:57 <shachaf> Silvah: No. I still don't know what example you're talking about.
02:06:52 <Silvah> Whatever.
02:07:18 * shachaf sighs.
02:07:22 <ion> :-D
02:08:40 <shachaf> Silvah: Oh, now I see what you were talking about.
02:08:55 <shachaf> let addcps x f = f (\y -> x + y) in addcps 5 (*2) 3, which uses the Num (b -> a) instance.
02:08:59 <statusfailed> Veinor: I'm not sure :)
02:09:07 <statusfailed> Veinor: I think I will go with ion's method, it seems to fit
02:09:08 <shachaf> Not let addcps x y f = f (x + y) in addcps 5 3 (*2)
02:11:56 <Silvah> :t let addcps x f = f (\y -> x + y) in addcps
02:11:56 <lambdabot> forall a t. (Num a) => a -> ((a -> a) -> t) -> t
02:12:03 <Silvah> :t let addcps x f = f (\y -> x + y) in addcps 5
02:12:03 <lambdabot> forall t t1. (Num t) => ((t -> t) -> t1) -> t1
02:13:03 <Silvah> Ah.
02:13:48 <Silvah> @djinn (a -> a) -> e
02:13:48 <lambdabot> -- f cannot be realized.
02:14:12 <danr> @djinn ((a -> r) -> a) -> a)
02:14:13 <lambdabot> Cannot parse command
02:14:19 <danr> @djinn ((a -> r) -> a) -> a
02:14:19 <lambdabot> -- f cannot be realized.
02:14:30 <Silvah> So that's where Num (b -> a) kicks in?
02:15:15 <shachaf> It "kicks in" where you're multiplying a function by 2.
02:15:20 <Silvah> :t let addcps x f = f (\y -> x + y) in addcps 5 (*5)
02:15:21 <lambdabot> forall t. (Num t) => t -> t
02:15:29 <shachaf> f = (*2); f (\y -> x + y) = (*2) (\y -> x + y)
02:15:36 <shachaf> See? You're doubling a function.
02:15:46 <shachaf> That doesn't make sense, except with the weird Num instance.
02:19:29 <Silvah> Yeah, I see.
02:19:51 <Silvah> Also my mind just exploded.
02:20:22 <magicman> If you want to learn about CPS, then go with "addcps x y f = f (x + y)". No need to worry about that particular Num instance.
02:39:26 <Manehattan> in wich package is the function (</>) defined?
02:39:41 <shachaf> That depends on what the function (</>) is.
02:39:50 <shachaf> There are probably a bunch of packages that use that name.
02:39:52 <shachaf> @hoogle </>
02:39:53 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
02:39:53 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
02:39:57 <shachaf> Apparently it's in that module.
02:41:34 <Manehattan> it's divided by the OS? I thought it was just one and automatically used the right divider
02:42:07 <ion> You’ll probably find System.FilePath to re-export the right one.
02:43:07 <ion> You might or might not find http://hackage.haskell.org/package/system-filepath to be nicer than the “type FilePath = String” stuff.
02:44:13 <Manehattan> ion: Thanks... unfortunately I work on Texts
02:45:22 <ion> Filesystem.Path.CurrentOS.toText :: FilePath -> Either Text Text
02:46:09 <tulcod> ion: is type SomeType = String generally discouraged?
02:46:28 <Moby> please tell me why on hell this doesn't work : comment = token "//" <*> greedy (satisfy isAlphaNum) <*> symbol '\n'
02:47:01 <ion> tulcod: No, but Strings aren’t a good match at all to paths on most filesystems.
02:47:04 <Moby> i want to exlude comments from a parser and i want to assign that one to the whitespace
02:47:44 <tulcod> ion: because of filenames with a / in them, for example?
02:47:55 <tulcod> ... which would need to be escape
02:48:31 <ion> tulcod: Filesystem paths in, say, ext4 are lists of octets, not lists of Unicode characters.
02:49:06 <tulcod> got it.
02:49:15 <donri> there's also the issue of type safety with not having distinct types
02:49:35 <tulcod> donri: well yeah, but that's what the type declaration is for
02:49:46 <donri> "type" doesn't create a distinct type
02:51:38 <carpi> is it true that its not possible to create operators that are like "True and2 False"? I know we can do "True `and2` False"? but is there anyway to do it without backticks?
02:52:11 <donri> carpi: preprocessor
02:52:31 <donri> don't recommend it though
02:53:08 <carpi> ah okay.. so its possible. just wanted to know. thanks
02:53:24 <tdammers> carpi: that would break established syntax assumptions
02:53:35 <Moby> please tell me why this doesn't work : comment = token "//" <*> greedy (satisfy isAlphaNum) <*> symbol '\n'
02:53:43 <tdammers> and2 begins with a lowercase letter, so it should be a function
02:54:04 <tdammers> functions do not use infix notation unless backticked
02:54:19 <tdammers> if you want it to be an operator, use non-alphanumeric characters
02:54:53 <tdammers> &&& or &/& or <&&> or whatever
02:58:06 <carpi> the convention makes more sense. after all, no point confusing an operator and a function that looks like an operator even though fundamentally they are indifferent
02:58:13 <carpi> s/the/that
02:59:03 <erus`> Do you guys know of a good coq tutorial/book for a haskell programmer ?
02:59:27 <carpi> the  docs for "replicateM" simply says that "replicateM n act performs the action n time, gathering the results".. whats that supposed to mean? because... i tried it out on a list and it simply producing all the different combinations.
02:59:41 <ocharles> erus`: are you looking for specifically coq, or just branching out to theorem prooving?
02:59:41 <carpi> so it seems more like a combinations functions than a replicate functions
02:59:49 <quicksilver> carpi: that's because "performing an action" in the list monad does combinations
03:00:01 <quicksilver> carpi: so you're observing a property of the list monad, not of replicateM
03:00:23 <quicksilver> try replicateM 5 (putStrLn "Hello carpi")
03:00:27 <erus`> ocharles: i have very little knowledge of theorem prooving
03:00:43 <ocharles> erus`: I only ask because I wanted to learn something beyond haskell, but I ended up choosing Agda instead because there is some good material right on their site
03:00:48 <ocharles> dunno how helpful that is
03:01:15 <ion> @src replicateM
03:01:15 <lambdabot> replicateM n x = sequence (replicate n x)
03:01:24 <ocharles> the advice I got from #coq on irc was that it was probably a better use of my time, as I planned to write safer programs
03:01:24 <ion> @src sequence
03:01:25 <lambdabot> sequence []     = return []
03:01:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:01:25 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:02:01 <carpi> quicksilver: it did the actions thrice giving me a list of the retunred values
03:02:21 <carpi> but why doing the same on a list give different results?
03:02:31 <ion> carpi: See the definitions above.
03:02:48 <tulcod> haskell has a lot of declarations like "deriving instance (Eq  a, Eq  b) => Eq  (a, b)" for numerous tuple sizes. why isn't there, like, a kind of "deriving instance (a,(b,c)) =>(a, b,c)" ?
03:03:15 <quicksilver> carpi: because that's what the list monad does.
03:03:25 <ion> replicateM 3 foo means: do a <- foo; b <- foo; c <- foo; return [a,b,c]
03:03:27 <statusfailed> Is there a simple intro to the Data/Typeable classes anywhere? I'd like to inspect a type's constructors, fields, etc. but i'm totally lost
03:04:35 <erus`> ocharles: but then i'm tied to emacs and stuff am i not?
03:04:36 <quicksilver> carpi: the list monad is not the easiest one to look at to get an intuition for various monad operations.
03:05:00 <ocharles> erus`: probably, can't really comment. I use emacs anyway.
03:05:15 <erus`> :(
03:05:26 <erus`> whats the commandline interface like
03:05:44 <carpi> googling list monad
03:05:57 <ocharles> no idea, I haven't done anything substantial with it :) I can write a head function that can't crash though!
03:06:00 <ocharles> :P
03:06:39 <ocharles> erus`: i guess it depends what you're looking to get out of this. if it's just for more learning and expanding your knowledge, I would think dependent types is more applicable than theorem proving
03:07:00 <ocharles> mostly because Haskell tends to pick up ideas from these areas, ie - the kind polymorphism extension is moving in that direction
03:07:20 <erus`> ok will give agda a try
03:08:19 <Redshift64> >[1..10]
03:09:09 <Redshift64> > [1..10]
03:09:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:10:07 <Manehattan> anyone can quickly tell me how to lift an normal Arrow to an Automaton arrow?
03:10:42 <Manehattan> or just how to use lift in arrow syntax generally
03:25:00 <Redshift64> > [x | x <- [1..10, all (\y -> mod x y /= 0) [2..x-1]]
03:25:01 <lambdabot>   <no location info>: parse error on input `,'
03:25:21 <Redshift64> > [x | x <- [1..10], all (\y -> mod x y /= 0) [2..x-1]]
03:25:22 <lambdabot>   [1,2,3,5,7]
03:27:31 <Redshift64> > [x | x <- [1..30], all (\y -> mod x y /= 0) [2..x-1]]
03:27:32 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29]
03:30:18 <carpi> am i correct in assuming that the '<-' used in comprehension lists and the '<-' used in do notations are either related to each other or almost one and the same?
03:30:40 <shachaf> Yes.
03:31:44 <donri> also see monad comprehensions
03:31:46 <ion> [ a | b <- c, d, e <- f ] (where d is a Bool) is equivalent to do b <- c; guard d; e <- f; return a
03:32:29 <carpi> ^^^ is a monad comprehension?
03:32:50 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#monad-comprehensions
03:32:52 <carpi> i mean not the comprehnsin list but the constructs after that
03:32:52 <mjrosenb> carpi: yes.
03:33:40 <dp_wiz> ... and i thought python were beautiful for it's data processing ...
03:33:48 <Redshift64> heh
03:35:04 <mjrosenb> so i've tried to learn python about a dozen times
03:35:22 <mjrosenb> every time, i write about 5 lines of code before giving up, and switching back to haskell
03:35:28 <ion> carpi: Monad comprehensions generalize the list comprehension syntax to arbitrary monads.
03:36:16 <carpi> ion: by arbitrary monads.. you mean any monad?
03:36:19 <Redshift64> mjrosen, do you know any other? imperative languages
03:36:29 <Redshift64> er
03:36:56 <ion> carpi: Yes
03:37:06 <donri> see my link
03:37:39 <donri> it's new in 7.4 or something though
03:38:04 <donri> 7.2?
03:38:15 <carpi> i never knew you could use then constructs in comprehensions
03:38:30 <donri> i wish the user guide would tell when something was added where it's documented
03:40:36 <carpi> donri: thanks for link.
03:42:00 <carpi> seems like n+k patterns are back
03:46:04 <int-e> They are? I thought they'd just live on as a language extension for a while.
03:47:20 <carpi>  why are so many extensions disabled by default..
03:48:17 <carpi> i think its more like experimentation perhaps..to let people get a feel for it and then if its really usefull, to make it standard and add it into the language
03:53:56 <quicksilver> carpi: the haskell committee has a policy of never standardising things which have not been implemented already (and used)
03:54:19 <quicksilver> all the changes to haskell2010 amounted to the standardisation of widely used GHC extensions. (and a couple of small removals)
03:55:44 <donri> (why) was(n't) NoNPlusKPatterns standardized?
03:56:01 <quicksilver> NoNPlusKPatterns is part of haskell 2010, yes
03:56:07 <carpi> Im not an expert on these things but commen sense tells me thats the best way to go about it. feeling the waters so to say..
03:56:07 <quicksilver> that was one of the 'small removals'
03:56:37 <donri> it's not like it's difficult to enable a ghc extension if you need/want it
03:56:52 <Manehattan> seeing as there is no compile who's completely implemented the C++0x standard that's quite smart of the haskellers
03:57:52 <quicksilver> I do think it's a better process.
03:58:03 <quicksilver> it's quite a slow process :)
03:58:12 <donri> see also: perl6
03:58:16 <donri> ;p
03:58:18 <quicksilver> although I don't know how much of that is inherent, and how much of that is a property of the mostly-volunteer community.
04:03:55 <Manehattan> How can I catch an exception in an arrow that's been thrown from inside a Kleisli?
04:12:47 <liff> any tips on how to get alsa-pcm to compile? c2hs complains about a '#' character in Core.chs.h but i have no idea how to fix that :/
04:16:29 <carpi> coudl someone please tell me whats wrong with this bit of code "let tosp = unwords . map (\x -> (show x))"
04:17:08 <derpladee> @hoogle [a] -> ([a],[a])
04:17:09 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
04:17:09 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
04:17:09 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
04:17:10 <shachaf> carpi: Why don't you tell us what's wrong with it?
04:17:14 <temp> carpi, why not, let tosp = unwords . map show
04:17:28 <temp> :t unwords . map show
04:17:29 <lambdabot> forall a. (Show a) => [a] -> String
04:17:38 <mjrosenb> carpi: it typechecks, what is it doing that it should not do?
04:17:57 <temp> :t unwords . map show $ [1 .. 3]
04:17:58 <lambdabot> String
04:18:02 <temp> > unwords . map show $ [1 .. 3]
04:18:04 <lambdabot>   "1 2 3"
04:18:12 <carpi> i did "tosp [True, True]" and i got "Couldn't match expected type `()' with actual type `Bool'"
04:18:24 <shachaf> @google monomorphism restriction
04:18:26 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:18:26 <lambdabot> Title: Monomorphism restriction - HaskellWiki
04:18:30 <temp> > unwords . map show $ [True, True]
04:18:31 <lambdabot>   "True True"
04:18:33 <shachaf> carpi: Add an explicit type signature.
04:20:22 <carpi> ah..now tis works
04:22:13 <carpi> atleast.. the error message should be more helpful than "Couldn't match expecte..."
04:23:42 <mjrosenb> carpi: that error message looks pretty good to me
04:24:50 <carpi> it is clear from within the body of the code that nothing expects '()'..that is why i thought it was a little misleading
04:25:19 <ppseafield> carpi: The problem is that, since I'm guessing you're using ghci, the interpreter had to go ahead and guess what the type of (\x -> show x) was, and since it can't see into the future, it couldn't guess [Bool] -> String or Show a => [a] -> String. If you put `tosp = unwords . map show' in a .hs file and try to load the file in ghci, it will tell you explicitly about a possible monomorphism restriction problem.
04:26:12 <mjrosenb> that isn't the monomorphism restriction, is it?
04:27:02 * mjrosenb thought that was ghc's new type inference implementation that doesn't generalize let-bound variables
04:27:26 <shachaf> mjrosenb: What carpi showed was the MR, yes.
04:27:32 <shachaf> mjrosenb: let tosp = ...
04:27:49 <shachaf> ghci has a special defaulting rule for (), but the MR would've made it fail in any case.
04:28:01 <mjrosenb> fun times.
04:28:17 <mjrosenb> oh hey, that had typeclasses in it, i didn't even notice
04:31:24 <carpi> so im guessing it is a useful restriction.. because on the link shachaf gave, its seems to suggest that it is
04:37:49 <Manehattan> is there a package that can tell me the mime to a file's extension automatically?
04:39:21 <derpladee> is there any way to force the evaluation of an expression to "primitive" form (like, not WHNF but all the way)
04:39:32 <derpladee> i am messing around with some parallelism and i think this might be a problem for me
04:39:47 <derpladee> i make another thread and it takes a huge evaluation and just reduces it slightly instead of all the way
04:40:30 <Entroacceptor> Manehattan: happstack.server has that
04:40:52 <Entroacceptor> you should make a standalone package of that
04:40:57 <Entroacceptor> http://happstack.com/docs/6.0.0/happstack-server/src/Happstack-Server-FileServe-BuildingBlocks.html#mimeTypes
04:41:18 <Manehattan> derpladee: If you use a data-type you can add ! to the types of the constructor to force evaluation when you're constructing the type
04:41:50 <Manehattan> derpladee: Otherwise, there are the 'seq' and '$!' function which, afaik, force evaluation
04:42:12 <Entroacceptor> oh, there is http://hackage.haskell.org/packages/archive/mime/0.3.3/doc/html/Codec-MIME-Type.html
04:42:29 <shachaf> derpladee: Sometimes there is, but it's often not what you want.
04:42:31 <Entroacceptor> or not
04:43:08 <Manehattan> Entroacceptor: No it's not, but making my own package is a great idea
04:43:52 <Entroacceptor> I have a feeling it really should go into that codec.mime.type
04:44:34 <Entroacceptor> or just the guessType part into mime.utils
04:48:53 <derpladee> shachaf, what will i want then?
04:49:25 <derpladee> my problem is quite clear, i have a list of elements and i want to map a function on them, i split the list in two and i want to perform the mapping on the two lists on separate cores
04:49:54 <shachaf> derpladee: Are you sure you don't just want parMap?
04:50:23 <Fire_Fli> greetings channelings:)
04:50:52 <Fire_Fli> anybody here?
04:51:24 <dp_wiz> #t
04:52:16 <derpladee> Maybe.
04:52:19 <derpladee> let me look into that
04:52:36 <Fire_Fli> into what???
04:52:44 <Fire_Fli> i wanna see too :)
04:53:09 <dp_wiz> Just you
04:53:17 <Fire_Fli> and you
04:53:24 <Fire_Fli> ....
04:53:41 <Fire_Fli> so wich channels does one join?
04:54:22 <Fire_Fli> omg
04:54:28 <Fire_Fli> hi bru
04:57:18 <nand`> Here's how to restore Wikipedia back to normal: http://pastie.org/3207338
04:58:22 <parcs`> or just turn off javascript
04:59:11 <shachaf> Or just press Esc before the page finishes loading.
04:59:27 <shachaf> But that's all off-topic here.
04:59:40 <carpi> would it be possible to do bit manipulation in haskell?
04:59:54 <carpi> data.bits simply has a class..
05:00:10 <ClaudiusMaximus> > bit 42 :: Integer
05:00:11 <Fire_Fli> aaah theres life here :)
05:00:11 <lambdabot>   4398046511104
05:00:36 <Fire_Fli> is this site business or social related?
05:01:08 <applicative> neither
05:01:19 <parcs`> this channel is pure business
05:01:42 <ClaudiusMaximus> > round (1/0) `shiftR` 1000 :: Integer
05:01:42 <lambdabot>   16777216
05:02:30 <Fire_Fli> oh so why is everyone  --------> JOINED THEN
05:03:20 <dgpratt> Fire_Fli: to talk about "Haskell"...if you have no idea what that is, you're probably not going to get a lot out of the conversations here
05:05:45 <Fire_Fli> OOOH computer programming language - SO WHERE is the social channels? if i may ask?
05:06:00 <nand`> Fire_Fli: you might want to check it out, it may interest you: https://en.wikipedia.org/wiki/Haskell_%28programming_language%29
05:06:31 <donri> Fire_Fli: the primary social channel is #defocus
05:06:31 <Fire_Fli> already googled thanks :)
05:06:59 <Baughn> Fire_Fli: How'd you even end up here? #haskell is not a typical default channel.
05:07:19 <Fire_Fli> lol Google!!!
05:07:52 <Fire_Fli> i was looking around for CHATTING channels and this popped up and i joined .... and so here i am!
05:08:09 <tdammers> nand`: I have serious doubts about that
05:08:33 <tdammers> Fire_Fli: you know the 'C' in 'IRC' stands for 'Chat', right?
05:08:59 <Fire_Fli> i SWEAR!!! Internet relay chat dah.... why who wouldnt know that?
05:09:35 <nand`> tdammers: strange as it may sound, I believe haskell is the gap-closer between programming languages and non-programmers
05:09:41 <int-e> nand`: not the best day to link to wikipedia :)
05:09:41 <Baughn> Fire_Fli: Lots of people. Anyway, doesn't seem like this is the channel for you, so.. want to switch? It's getting a little noisy.
05:09:55 <Baughn> Fire_Fli: Unless you want to learn Haskell, in which case we're hapy to help. :P
05:09:58 <nand`> because when you think about it, the functional style is the most natural for a human with mathematical background
05:09:59 <tdammers> nand`: I value your optimism :)
05:10:15 <tty7> int-e: (14:44:54) nand`: Here's how to restore Wikipedia back to normal: http://pastie.org/3207338
05:10:21 <tty7> ;)
05:10:45 <nand`> we're used to stuff like x = 2 + 5 and y = x * 2 from school and everyday life, what we're *not* used to is the whole concept of state and state transitions
05:11:01 <int-e> tty7: Oh that seems hard, I just disabled javascript. In fact, I had Javascript disabled and couldn't find the anti-sopa page :)
05:11:02 <nand`> I've found that the way programs are evaluated from top to bottom, line per line boggles the mind of most newcomers
05:11:38 <tdammers> but then, the way haskell programs are lazy and all that also boggles the minds of most newcomers
05:11:55 <tdammers> I mean, imperative flow is at least easy to follow visually
05:12:32 <tdammers> but grasping how lazily-evaluated pure IO actions become an interactive program is way beyond that
05:13:18 <nand`> yeah, that's the major hurdle I seem to be experiencing - understanding monads and how they can be used to model state
05:13:37 <flux> tdammers, the IO monad doesn't actually need laziness to function, so perhaps not thinking of that is helpful
05:13:53 <flux> (some features might need, though, such as the lazy reading of files)
05:16:26 <nand`> [02+1502] <nand`> nonetheless, using ghci as a sort of “super-calculator” is neat -- not sure if this got through before my disconnect
05:16:58 <int-e> it didn't
05:18:04 <ezyang> Are there any non-trivial monads for which error "foo" :: m a is not a left zero?
05:18:37 <nand`> 02+1458] <tdammers> but then, the way haskell programs are lazy and all that also boggles the minds of most newcomers <- I've found that that applies more to “newcomers who know other imperative languages”, since they're already in the C mindset
05:19:07 <int-e> > evalState (error "foo" >> return 1) ()
05:19:08 <lambdabot>   1
05:19:27 <ezyang> huh
05:19:36 <parcs`> lazyness
05:19:39 <ezyang> > Control.Monad.State.Strict.evalState (error "foo" >> return 1) ()
05:19:40 <lambdabot>   Not in scope: `Control.Monad.State.Strict.evalState'
05:20:06 <ezyang> bah
05:20:47 <int-e> yes, that's the lazy state monad. error "foo" destroys the state though, obviously.
05:21:10 <deech> Hi all, does anyone know if Simon Marlow's new stack trace functionality will made it into 7.4 or is currently in HEAD?
05:21:16 <hpaste_> prof7bit pasted “Can't get rid of this imperative feel. What am I missing?” at http://hpaste.org/56611
05:21:36 <prof7bit> hi. question inside hpaste
05:22:17 <int-e> ezyang: and I'm unsure whether this behaviour can be useful in practice.
05:22:36 <parcs`> > execState (error "foo" >> return 1) ()
05:22:37 <lambdabot>   *Exception: foo
05:23:43 <Botje> prof7bit: you could use the state monad or parsec
05:23:48 <int-e> > runState (error "foo" >> put 42 >> return 1) 23 -- you can recover if you like
05:23:49 <lambdabot>   (1,42)
05:24:07 <nand`> I think parsec would be the best tool here, personally
05:24:17 <nand`> since it's designed to parse strings
05:24:27 <Botje> although your problem can also be solved using regexps.
05:26:23 <prof7bit> its not a real problem that I have to solve, I am just making up problems that would be easy to solve for me in other languages and forcing myself to do the same in haskell so that I eventually discover thze advantages (as soon as I find something that is actually easier)
05:27:02 <int-e> ezyang: I guess you can sort of fork off threads by exploiting this laziness: runState (do s <- get; Lazy <$> (put s >> some action) <*> (put s >> some other action)), getting closer to the reader monad.
05:27:11 <Botje> would you solve it using a character-by-character approach in otehr languages as well
05:27:14 <Botje> ?
05:27:48 <deech> prof7bit: In fact the Token parser module datatype "GenTokenParser" has a parser for braces. http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html. You might read the associates source code for more pointers.
05:29:25 <Botje> prof7bit: you could use break and/or span to simplify looking for the { and }
05:29:27 <prof7bit> Botje: for this simple problem (only removing the braces and their contents) yes. Of course for more complicated things I would write something that could take entire words out of the string
05:29:40 <magicman> In this simple case, Data.List.Span would be a great solution.
05:29:56 <magicman> ... which Botje just said >_<
05:30:20 <Botje> prof7bit: also note that it's rather rare to pass arguments using tuples in Haskell
05:30:34 <magicman> *Data.List.span (case matters)
05:31:15 <tty7> prof7bit: if you have tuples as the arguments for your functions, you wont get the advantages of currying
05:31:38 <tty7> better do that:
05:32:44 <prof7bit> (I intuitively tried to make the argument the same type as the return value)
05:32:56 <tty7> yep
05:32:57 <tty7> wait.
05:33:16 <tty7> you should better use lists, i will make up an example
05:33:43 <Botje> you could even use the writer monad to separate the {} stuff from others
05:34:33 <deech> prof7bit: Using parsec your problem would be solved by "braces p = between (symbol "{") (symbol "}") p"
05:34:56 <tdammers> nand`: you might have a point there...
05:35:14 <tty7> uh, sorry. the (before, remaining) thing seems to make it impossible to do what i wanted to
05:35:36 <tty7> sorry. but span and break should help you, as said :)
05:36:11 <edsko> anybody any idea what might be wrong if running a cabal-install'ed program (zeno) gives the error "zeno: unexpected RTS argument: "-N"" when run? (I'm on Mac OS X)
05:36:32 <edsko> (and no, I'm not providing any RTS arguments manually, just running "zeno")
05:37:37 <ClaudiusMaximus> edsko: programs can link in custom rts options; recent ghcs require -rtsopts at link time to enable rts options; perhaps there's a conflict there
05:37:58 <prof7bit> but using library functions would somehow feel like cheating, wouldn't it?
05:38:40 <magicman> If it feels like cheating, try defining span and break yourself.
05:39:02 <edsko> ClaudiusMaximus: this is a very recent installation of the Haskell Platform, followed by a cabal install zeno, with very little else.
05:39:11 <edsko> (very recent meaning a few days ago)
05:39:40 <deech> prof7bit: What language makes this kind of parsing easier with out library functions?
05:39:45 <nand`> prof7bit: if it helps you, instead of thinking “how would I go through this data” like in imperative languages, in functional programming you often want to think “how can I define this in terms of its data?” For example, a (naive) imperative sorting algorithm might feature lots of loops and passes, while a (naive) functional sorting algorithm could look like “sortedlist = lowestelement : restofelements”
05:39:53 <dcoutts> edsko: sounds like the program is using the single threaded RTS, hence no -N
05:40:09 <edsko> dcoutts: can I manually override this?
05:40:13 <dcoutts> edsko: rebuild the program and link using the -threaded -rtsopts flag
05:40:15 <nand`> deech: perl I suppose due to built-in regex parsing ;)
05:40:38 <dcoutts> edsko: obviously -N will only make a difference if the program is designed for parallelism
05:41:01 <edsko> dcoutts: sure, of course. it's just that I didn't pass any of those options myself, that was all done by cabal. thanks.
05:41:04 <deech> nand`: That's still cheating :)
05:42:07 <dcoutts> edsko: hmm, zeno's .cabal file does use -threaded, so -N should work
05:42:39 <dcoutts> edsko: try -N2, perhaps you're using an older ghc that doesn't support the -N on it's own (meaning use the number of cores detected)
05:43:21 <prof7bit> deech: easier in terms of seeing the same imperative steps needed to go through the string laid out in front of me in the order of execution as opposed to my example where I have effectively the same imperative steps only obscured by recursive function calls
05:44:15 <edsko> dcoutts: -N2 when recompiling or when running zeno?
05:44:41 <edsko> dcoutts: as in, is there a way to override the built-in RTS options?
05:45:57 <hpaste_> keep_learning pasted “converting List of Lists ( [[a]] )  into PArray ( PArray a ) ” at http://hpaste.org/56612
05:46:13 <keep_learning> Hello Haskell
05:47:53 <princess> Query: Is there a remotely succinct way to get a somewhat random number? Or do I need to carry the IO type around to access the System StdGen?
05:48:20 <dcoutts> edsko: -N2 when running
05:48:32 <keep_learning> I am trying to convert list a lists [[a]] into PArray ( PArray a ) but i am stuck with Segd ( http://hackage.haskell.org/packages/archive/dph-par/0.5.1.1/doc/html/Data-Array-Parallel-Prelude.html )
05:48:41 <donri> princess: r <- randomIO
05:48:46 <prof7bit> nand`: I somehow think I am close to understanding what this "define this in terms of its data" might mean, I can already spot the difference when I see it and can realize what it means but I cannot yet come up with such elegant definitions myself
05:48:51 <dcoutts> edsko: zeno +RTS -N2
05:50:10 <MostAwesomeDude> princess: I found, and liked, the MonadRandom package.
05:50:49 <princess> Thank you, I'll check it out
05:50:59 <MostAwesomeDude> Which is basically some sugar for getting and using random number generators independent of any actual StdGen source.
05:51:19 <edsko> dcoutts: yeah, I had tried that, but gets the same error message (zeno: unexpected RTS argument: "-N", plus "zeno: Most RTS options are disabled. Link with -rtsopts to enable them.". I guess I need to recompile after all.
05:51:24 <dcoutts> edsko: oh, the .cabal file is also missing -rtsopts
05:51:37 <erus`> whats this symbol called, and whats the backslash name people use? ℕ
05:51:59 <dcoutts> edsko: either edit the .cabal file or build using --ghc-options=-rtsopts
05:52:17 <princess> jscxk5w
05:52:27 <princess> Garble, sorry
05:53:18 <nand`> erus`: blackboard bold N?
05:53:58 <erus`> i wish there was a more complete agda vim mappings...
05:54:17 <ocharles> erus`: that's \n, I believe
05:59:02 <Girffe> Out of curiousity, does anyone here use Haskell for any programming that they do?
05:59:20 <tdammers> certainly
05:59:29 <Girffe> What kind of projects do you do with it?
05:59:31 <Entroacceptor> no, I'm just a programming hipster
05:59:52 <Girffe> It's just that whenever I try to program with functional programming languages
05:59:54 <tdammers> sheet music processor, bit like lilypond, but better suited to my needs
06:00:09 <Girffe> I inevitably end up forcibly using imperative techniques in my programming
06:00:11 <tdammers> I've also written a little web server, but it's far from industrial-strength
06:00:20 <benj_> I study haskell to better understand concepts which are encoded in a more noisy boilerplatey way in other languages
06:00:24 <nand`> No, I spend a few minutes each day exploring haskell (eg. by learning something new or experimenting with ways to solve a problem)
06:00:28 <Girffe> And while some parts end up being much nicer and more concise, the project is a lot more tedious in general
06:00:34 <nand`> I've never actually written any real program in haskell for some reason
06:00:49 <Girffe> benj, that's the same thing I'm doing
06:00:57 <Girffe> Although I'm learning in racket, I've also done some haskell
06:01:00 <tdammers> well, the imperative part of the music thing is pretty messy, but luckily, that part is small
06:01:04 <dever> i wrote a file manager in haskell a few moons ago, was quick enough for what it was
06:01:30 <Girffe> I guess the main issue with haskell and Racket that I see is that it scales poorly to larger projects
06:01:47 <Girffe> and it becomes extremely difficult to manage/organize a larger project
06:01:59 <tdammers> not if you use the right tools/libraries, I guess
06:02:09 <Botje> does a 5kLOC compiler count?
06:02:24 <nand`> I've actually been thinking about writing a VN engine similar to renpy in haskell, but overall it seems like only 5% of the project will be the actual dialogue management engine and the rest will just be boring stuff like I/O, SDL interaction and so on
06:02:57 <nand`> and I'm still not quite sure how to give the user the most flexibility when it comes to tracking state variables
06:02:57 <Girffe> That's something I've noticed too, I'm writing a text-based RPG in Racket, and most of the work I'm doing is trying to find a good way to handle user input
06:03:03 <Girffe> rather than working with the engine itself
06:03:10 <int-e> > permutations (transpose ["twyd","hhoo","iau","nt","k"]) !! 10
06:03:10 <^thief^> is there any way of passing as a parameter, a string containing the name of a named field in a record, in order to then access/update the specified field? (if that makes any sense)
06:03:10 <lambdabot>   ["what","do","you","think"]
06:03:13 <nand`> it seems like I'd be re-implementing the wheel by embeddeding an imperative DSL into haskell
06:03:50 <nand`> Girffe: isn't that most of the work in any text based RPG?
06:04:03 <nand`> managing to understand user input
06:04:15 <Girffe> I suppose, the problem is that managing user input is a lot more convenient in a language like java
06:04:45 <nand`> getLine; you now have a String to work with and parsing that is just as hard in any language
06:05:08 <Botje> Girffe: how is java more convenient?
06:05:17 <tdammers> actually, parsec and such make it much more comfortable in haskell than in, say, C
06:06:10 <Girffe> Well, the problems I'm having are more in racket, but I feel like the philosophy of the two languages is the same
06:06:50 <Girffe> The imperative approach to I/O, where a program is more like a series of statements
06:07:04 <Girffe> It's something I've had to forcibly implement in my program anyway
06:07:23 <nand`> when you think about it, there are only two steps involved
06:07:28 <nand`> 1. get user input
06:07:31 <nand`> 2. parse user input
06:07:35 <Botje> Girffe: my compiler (5kLOC) is about 5% IO and the rest is pure code.
06:07:43 <nand`> and those are two lines in haskell
06:07:52 <nand`> or one
06:08:00 <int-e> Botje: somebody (forgot who) said that Haskell is a domain-specific language for writing compilers ;)
06:08:31 <tdammers> int-e: that's probably why it's such a good fit for a sheet music processor
06:08:36 <Girffe> Do you ever have difficulty, though, simply trying to manage a large project in Haskell, as opposed to OOP?
06:09:13 <Girffe> Haskell is nicely optimized for being short and concise, but organization is the main difficulty I'm having
06:09:50 * ocharles has found he does use IO quite a bit
06:09:54 <ocharles> but still perfectly managable
06:10:11 <int-e> Girffe: That was a very suggestive question. Managing large OO programs is hard. It just happens that Java in particular has quite good tool support.
06:10:21 <Botje> Girffe: I organize my code in modules, roughly per functionality
06:10:56 <Botje> http://wilma.vub.ac.be/~dharnie/code/TM/
06:10:57 <Girffe> I've actually just learned modules; I'm studying this at university, that will hopefully considerably make it easier
06:11:07 <Girffe> Since up until now I've had the entire list of definitions in one file
06:11:09 <dever> Girffe: define manage. the module system in haskell is very good, and if you have a good strategy for putting functions in modules, and not just anywhere that doesn't cause a cyclic import, then it becomes quite intuitive.
06:11:13 <tdammers> Java's tools actually somewhat compensate for poor project organisation
06:11:18 <Botje> each pass of my compiler is roughly one module
06:11:31 <Botje> and my other compiler is similarly organized
06:11:33 <ocharles> Does anyone have any advice on how I can best use types to express boolean flags to a function call? For example, getArtist can be passed the flags WithRecordings and WithReleases. getRelease can only be passed WithRecordings however, and not WithReleases
06:11:41 <Girffe> And yeah, I suppose I was sort of spoiled my what java has available for project management
06:11:43 <int-e> I don't think that Haskell is any worse there, and it may well be better because higher-order functions allow for better composability across module boundaries.
06:11:48 <ocharles> so data Flag = WithReleases | WithRecordings is not clear enough
06:12:03 <ocharles> getRelease 6754 [ WithReleases ] for example, should not be possible
06:12:46 <ocharles> I considered using type classes for this, and "data WithReleases" and "data WithRecordings" and using a type class, but then I can't really do ReleaseFlag f => [ f ], because that would mean a list of the *same* flag
06:12:59 <ocharles> Which only really leaves me with HList
06:16:38 <ppseafield> ocharles: You can't just have getRelease ignore the WithRelease flag?
06:16:59 <ocharles> ppseafield: I would prefer the type system helps eliminate this incorrect behavior
06:17:43 <ocharles> getRelease is a web service request, and I wanted to make this all as simple as possible - simple stringify and concenate all flags, and dispatch the query
06:18:03 <ocharles> of course i have to encode what's valid somewhere, but I always like compile time :)
06:19:07 <edsko> dcoutts: even when I rebuild Zeno with cabal install zeno -v --ghc-options=-rtsopts (and the -rtsopts is now in fact passed to ghc) is still gives the same error message when running zeno (except that the warning about rtsopts missing is now gone).
06:19:19 <ocharles> the other option is data ArtistFlag = ArtistWithRecordings | ArtistWithReleases
06:19:22 <ocharles> and data RecordingFlag
06:19:45 <edsko> the relative order of -rtsopts and -with-rtsopts should not matter, should it? (tested it on a small program, didn't seem to make a difference)
06:21:22 <ocharles> the only thing I don't like about that is that we now have ArtistWithRecordings and ReleaseWithRecordings - which are really the same "thing"
06:26:38 <prof7bit> i have simplified my previous example, i like this one better already: http://hpaste.org/56617  :-)
06:27:05 <PDani> hi
06:27:06 <^thief^> is there any way of converting a string to record accessor?
06:28:55 <statusfailed> ^thief^: Do you mean, given some data structure and a string, find the function whose name is the same as the string?
06:29:42 <^thief^> statusfailed: Yes I think thats what I mean
06:29:48 <PDani> http://pastebin.com/emBdDDA5 <- i wrote this code for reading up triples of integers from a binary data file. but it uses up my stack because chunks function call isn't in tail position. but i can't rewrite it into tail-recursive, or something efficient. Could somebody give me some pointers?
06:29:53 <mauke> The paste emBdDDA5 has been copied to http://hpaste.org/56618
06:32:07 <statusfailed> ^thief^: I think you need generics for that
06:32:30 <statusfailed> ^thief^: I could be wrong though. Try looking at Data.Data and Data.Typeable. If you find out, let me know, I've been meaning to look at it :)
06:32:43 <^thief^> statusfailed: ok thanks I'll have a look
06:33:47 <statusfailed> ^thief^: I know there is a generic JSON encoder/decoder which uses those somehow, the source of that might be worth a look, too
06:33:57 <ppseafield> ocharles: How many flags are you planning on making?
06:34:15 <ocharles> ppseafield: http://musicbrainz.org/doc/XML_Web_Service/Version_2#inc.3D_arguments_which_affect_subqueries enough to cover that
06:34:29 <ocharles> http://musicbrainz.org/doc/XML_Web_Service/Version_2#Subqueries actually, those flags first
06:34:39 <ocharles> these are the ones with some overlap
06:35:34 <^thief^> statusfailed: ok thanks, short on time though - end of term project due for Friday and I'm way behind schedule! Spent all my time finding out the best way to do things when I should have just been doing things the OK/Good Enough way
06:37:17 <ocharles> ppseafield: have a meeting in 5 mins so I posted http://stackoverflow.com/questions/8912686/how-can-i-use-the-type-system-with-flags-to-functions-that-are-sometimes-shared for now
06:37:40 <roconnor> is go t@(Tip k x) = t faster than go (Tip k x) = Tip k x ?
06:37:49 <edsko> dcouts: anyway, don't think the -N is crucial for zeno so I just removed it from the .cabal file. seems to work okay now. thanks.
06:42:33 <ppseafield> ocharles: Okay. Might want to put that link to the web service API on SO too.
06:42:43 <ocharles> ppseafield: ah yes, thanks
06:44:04 <rkrzr> Hi haskellers, I have a question about overlapping instances: I put the "OverlappingInstances" pragma on top of my file, but when trying to compile, I still get an error because of overlapping instances, any ideas?
06:44:29 <ocharles> rkrzr: the file with the type class itself needs to have that extension on
06:44:30 <ocharles> I believe
06:44:42 <ocharles> possibly you haven't got that
06:44:58 <rkrzr> ocharles, oh that'r right, thanks!
06:45:31 <Saizan> the module with the instances that overlap, not necessarily the module with the typeclass
06:47:07 <rkrzr> Saizan, I put it in the module with the overlapping instances but that didn't work
06:48:18 <Saizan> the module where the instances are defined?
06:48:28 <rkrzr> yes
06:48:35 <rkrzr> the instances but not the type class
06:49:40 <Saizan> that's never been how it worked, maybe they changed it recently though
06:50:22 <rkrzr> hm it might be some different problem altogether, since adding the pragma to the module with the type class didn't help either
06:50:56 <rwbarton> there's a limit to how much your instances are allowed to overlap, even with OverlappingInstances
06:51:09 <rwbarton> for example you can't write two identical instance heads
06:51:19 <rwbarton> I don't know exactly what the rules are
06:51:27 <rkrzr> rwbarton, as long as there is a most specific one, there shouldn't be a problem, right?
06:51:36 <rwbarton> no idea
06:51:41 <rkrzr> hm ok
06:52:03 <rwbarton> often it might look like there is a most specific one when in fact there is not, due to an unexpected substitution
06:52:20 <Saizan> the error should tell
06:52:55 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap <- they are documented quite well
06:53:08 <rkrzr> it just says "Overlapping instances for ..."
06:53:12 <Saizan> see the part about being conservative
06:53:17 <rkrzr> ok
06:53:31 <Saizan> yeah, but it also says the types involved
06:53:57 <nand`> Is there some sort of GHCI configuration file where I can specify which modules to import automatically on program start?
06:54:06 <rwbarton> can you paste the error and the relevant instances?
06:54:14 <nand`> It's getting tiring having to import stuff like Control.Applicative every time I need them
06:54:50 <wjt> nand`: ~/.ghci
06:55:00 <Saizan> .ghci only affects the propmt
06:55:05 <Saizan> *prompt
06:55:46 <Saizan> you can make a module that reexports them
06:56:23 <nand`> ah never mind, found http://stackoverflow.com/questions/3518619/how-to-configure-ghci-to-automatically-import-modules
06:58:01 <hpaste_> rkrzr pasted “overlap problem” at http://hpaste.org/56622
06:58:29 <rkrzr> rwbarton, I pasted the problem
07:00:01 <rwbarton> hmm
07:00:05 <rwbarton> Wrapper is just a normal newtype/data?
07:01:04 <Saizan> none of those say [overlap ok] so you don't have OverlappingInstances enables in the module defining them atm, right? it looks like they should work if you do
07:01:11 <Saizan> *enabled
07:01:41 <rkrzr> yes Wrapper is just a normal data type
07:02:18 <rkrzr> and I enabled OverlappingInstances in that file
07:02:59 <Saizan> have you saved it? it looks like ghci isn't convinced you did
07:03:54 <rwbarton> or maybe cabal is building your program differently than you expect, if you're using cabal
07:04:14 <roconnor>  @type maybe
07:04:17 <roconnor> @type maybe
07:04:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:04:24 <rkrzr> yes maybe it's a problem with cabal, that's possible
07:04:46 <rwbarton> I know {-# LANGUAGE ... #-} used to work with cabal but I understand it was viewed as a kind of bug
07:05:00 <rwbarton> if the language extension wasn't listed in your cabal file at least
07:06:41 <Saizan> cabal won't remove {-# LANGUAGE .. #-} pragmas from files though
07:06:44 <rkrzr> do you have to add FlexibleInstances as well maybe?
07:07:22 <Saizan> if you need them you should get an error if you don't have them
07:07:41 <rkrzr> ok that's not it then
07:10:10 <Saizan> instance View [Port] n ⇒ View [Port] (Wrapper n) where <- this one requires FlexibleInstances, though, so there's something fishy if you are not getting an error for it
07:10:19 <Saizan> (and you don't have the extension on)
07:11:48 <rkrzr> what's also weird, that GHC doesn't suggest adding OverlappingInstances, since usually it suggests missing extensions
07:12:48 <Saizan> well, OverlappingInstances aren't as tame as the others
07:14:32 <rkrzr> true
07:15:10 <rkrzr> I'll have to think about this a little more, I think, maybe there's a way without using them in the first place
07:18:58 <nand`> if M and N are cyclic monoids with periods m and n respectively, and there exists a monoid homomorphism from M to N, does this mean that m = n?
07:19:27 <nand`> or does that only apply if the monoid homomorphism in question is also a functor?
07:20:15 <ezyang> Does anyone have a copy of the stream fusion paper?
07:20:21 <nand`> (since F(f.f) = F(f).F(f) and if f.f = 1 then F(f.f)=F(1)=id in the new category)
07:20:22 <cheater_> nand`: try figuring out if this homomorphism also translates operations
07:20:34 <cheater_> among others, whether (+) ends up being the same
07:20:40 <cheater_> if it is then you know m = n
07:21:33 <rwbarton> it just means n divides m
07:22:03 <ezyang> up, foudn a copy
07:23:05 <rwbarton> also, I'm a little confused, if you are thinking of monoids as one-element categories then monoid homomorphisms correspond to functors, so there is no "also"
07:24:15 <nand`> rwbarton: I'm thinking of monoids as any object in a category where this category has a functor that, in the case of the monoid object, acts as a monoid homomorphism
07:24:27 <nand`> one-element categories would fulfil this situation
07:24:55 <Silvah> :t newStdGen
07:24:56 <lambdabot> IO StdGen
07:25:06 <nand`> that is, the functor maps a monoid in category M to a monoid in category N, both of which are cyclic in this case
07:27:40 <Silvah> :t (>>=)
07:27:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:29:58 <Silvah> Er, what happened to System.Random?
07:35:33 <KitB> Whatever happened to fruit?
07:35:39 <rwbarton> nand`: it sounds like you're talking about what would normally be called the endomorphism monoid of an object? (http://ncatlab.org/nlab/show/endomorphism)
07:36:01 <erus`> anyone with agda knowlede in here ? I wanna implement something similar to Eq for my type using standard library
07:36:13 <erus`> is ≡ the same as == in haskell?
07:37:04 <rwbarton> a functor F between categories automatically gives you a monoid homomorphism from End(X) to End(FX) for every object X
07:37:21 <rwbarton> again this is just expanding the fact that F is a functor
07:45:44 <statusfailed> ^thief^: (hugely late response) Ah, yes... i've been there :D
07:46:29 <^thief^> statusfailed: yep me too haha never learn
07:46:32 <parcs`> erus`: the closest thing to that is to create something like: "data Eq a where (==) :: (a -> a -> Bool) -> Eq a" but in agda
07:47:08 <erus`> parcs`: how do i check other types are equal, such as Nat and Integer ?
07:49:39 <Silvah> Ha-ha-ha.
07:50:25 <Silvah> I've just written "instance Monad (Foo a) where".
07:50:48 <parcs`> erus`: implement natEq : Nat -> Nat -> Bool then pass around a parameter Eq Nat to whatever functions that you want to use them in
07:51:06 <erus`> parcs`: is this not in the standard library?
07:52:18 <parcs`> there is probably some fancy module in the standard library that does this
08:11:52 <hpaste_> “^thief^” pasted “How would I write this in Applicative style?” at http://hpaste.org/56625
08:15:20 <parcs`> ^thief^: (char '$' *> ((\num -> (0, ("$" ++ show num)) <$> integer) <* skipMany space
08:15:41 <parcs`> oops, remove the first paren
08:16:28 <^thief^> parcs`: thank you! still getting my head around the details of Applicative, it does clean things up nicely though
08:16:40 <Silvah> @pl \num -> (0, ("$" ++ show num)) <$> integer
08:16:40 <lambdabot> (<$> integer) . (,) 0 . ('$' :) . show
08:16:56 <Silvah> Huh, not that bad, actually.
08:17:17 <roconnor> @tell kosmikus nix-env -iA nixpkgs_sys.haskellPackages_ghc6123.criterion fails to build (for me).
08:17:17 <lambdabot> Consider it noted.
08:17:21 <parcs`> you can do something like (0, ) . ("$" ++) . show <$> integer if you have TupleSections enabled
08:17:25 <ion> (sequence [char '$', show <$> integer] <|> arg) <* skipMany space or something
08:17:52 <ion> whoops
08:18:07 <parcs`> oh and for the second alternative you can do '((0,) <$> arg) <* skipMany space'
08:18:12 <ion> (liftA2 (:) (char '$') (show <$> integer) <|> arg) <* skipMany space
08:19:38 <parcs`> ion's version is more concise
08:19:45 <^thief^> what is the liftA2 bit about?
08:20:23 <Silvah> :t liftA2
08:20:24 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:21:22 <parcs`> liftA2 (:) a b = (:) <$> a <*> b
08:22:07 <Silvah> :t liftA -- the best function ever
08:22:08 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
08:22:45 <^thief^> hmm damn it takes a while to get your head around this stuff
08:23:33 <Silvah> What's the point of liftA, if fmap is the same, only more general?
08:23:51 <Veinor> in case someone was weird and declared an applicative instance but not a functor one?
08:24:11 <dmwit> Surely Functor is a superclass of Applicative.
08:24:20 <Silvah> Veinor: that's impossible.
08:24:28 <mm_freak> liftA would be Functor, not applicative
08:24:28 <Veinor> ah
08:24:31 <monochrom> when someone wants the letter A and not the letter f
08:24:49 <Saizan> completness?
08:24:50 <Silvah> monochrom: li**f**tA
08:25:05 <Saizan> and simmetry with liftM
08:25:05 <dmwit> I suppose it's a nice continuation of the liftA2, liftA3, liftA4 pattern.
08:25:14 <mm_freak> liftA3 = <$><*><*>, liftA2 = <$><*>, liftA = <$>…  at least that would make sense
08:25:18 <Veinor> dmwit: yeah
08:25:37 <dmwit> Though if that's the rationale, it ought to be called liftA1. ;-)
08:25:54 <Veinor> but it's not liftM1!
08:26:07 <^thief^> I think ion's version misses out on the tuple though
08:26:18 <Silvah> @src liftA
08:26:19 <lambdabot> liftA f a = pure f <*> a
08:26:35 <^thief^> I think I see what liftA2 is doing with the cons now
08:26:56 <donri> it should be noted for applicative that it's parsed as (((+) <$> Just 2) <*> Just 3) and not ((+) <$> (Just 2 <*> Just 3)) as you might be tempted to read it
08:27:19 <Veinor> haha
08:27:24 <parcs`> ^thief^: try fixing it yourself :)
08:27:40 <^thief^> parks': yep am working it!
08:48:10 <keep_learning> hello all
08:49:16 <keep_learning> I am trying to convert  list of Lists of Int ( [[Int]]  ) to PArray ( PArray Int )
08:50:35 <keep_learning> There is function fromList :: PA a => [a] -> PArray a  but  i don't know how to convert this for [[a]]
08:51:15 <keep_learning> Could some one please tell me how to solve this issue
08:51:25 <monochrom> perhaps fromList (map fromList yours)
08:52:06 <cmccann> or just "fromList (concat xs)"?
08:52:11 * cmccann isn't sure what the goal is
08:52:16 <cmccann> oh wait
08:52:22 <cmccann> nested arrays, missed that
08:52:34 <cmccann> yeah, what monochrom said, ignore me
08:59:03 <ion> thief: The tuple’s just a matter of (,) 0 <$> …
08:59:58 <keep_learning> monochrom, thank you
09:37:50 <hpaste_> keep_learning pasted “run time error in program” at http://hpaste.org/56626
09:38:39 <keep_learning> hello all
09:39:15 <keep_learning> My program is compiling fine but i am getting run time error.
09:39:27 <keep_learning> Could some one please have a look
09:41:33 <leviccampbell> keep_learning: what runtime errors are you getting?
09:42:21 <keep_learning> leviccampbell, ParallelMat: Data/Array/Parallel/PArray/PDataInstances.hs:337:10-30: No instance nor default method for class operation Data.Array.Parallel.PArray.PData.fromListPR
09:49:39 <leviccampbell> keep_learning: huh, I'm not finding Data.Array.Parallel.PArray.PData.fromListPR in hoogle or hayoo, try asking on StackOverflow.
09:50:06 <keep_learning> leviccampbell, thank you.
09:50:39 <leviccampbell> keep_learning: Sorr I couldn't be more help.
09:50:56 <leviccampbell> keep_learning:Sorry*
09:51:05 <keep_learning> leviccampbell, no problem :)
10:00:09 <keep_learning> hello all
10:00:43 <keep_learning> looks like i have issue with P.fromList ( map P.fromList c )
10:01:31 <keep_learning> when i am trying to    print $    ( map P.fromList ( [[1..10],[1..10]] :: [[Int]] ) )
10:01:39 <keep_learning> >    print $    ( map P.fromList ( [[1..10],[1..10]] :: [[Int]] ) )
10:01:40 <lambdabot>   Not in scope: `P.fromList'
10:02:12 <keep_learning> >    print $    ( map Data.Array.Parallel.PArray.fromList ( [[1..10],[1..10]] :: [[Int]] ) )
10:02:13 <lambdabot>   Not in scope: `Data.Array.Parallel.PArray.fromList'
10:03:20 <keep_learning> but when i am trying to do  print $ P.fromList ( map P.fromList c ) then i am getting error
10:03:31 <keep_learning> Could some one please have a look
10:04:45 <keep_learning> this page http://hackage.haskell.org/packages/archive/dph-par/0.5.1.1/doc/html/Data-Array-Parallel-PArray.html also shows that PA a => PA (PArray a) so  a can itself be PArray
10:06:37 <keep_learning> no one :(
10:12:41 <parcs`> > maxBound + 1 :: Double
10:12:42 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
10:12:42 <lambdabot>    arising from a use o...
10:20:30 <monochrom> > maxBound :: Double + 1
10:20:31 <lambdabot>   Could not deduce (GHC.Enum.Bounded
10:20:31 <lambdabot>                      ((+) GHC.Types.Doub...
10:20:45 <monochrom> I guess parentheses are necessary
10:20:55 <mauke> > maxBound :: 1
10:20:56 <monochrom> > (maxBound :: Double) + 1
10:20:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Generics.Unit)
10:20:56 <lambdabot>    arising from a use ...
10:20:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
10:20:56 <lambdabot>    arising from a use o...
10:21:43 <monochrom> oh, nevermind
10:30:21 <swandance> hi
10:30:30 <swandance> to talk?
10:30:52 <ocharles> open mouth, words come out
10:30:53 <ocharles> magic!
10:31:21 <saiko-chriskun> profit!
10:31:22 <bobry> hello, i need to convert a Data.Bson value (Val instance) to an aeson value (ToJSON instance) -- is it even possible to achieve in a generic way?
10:33:54 <swandance> bobry google.com
10:34:10 <bobry> swandance: sure, can you at least give me a hint what to google?
10:34:48 <Veinor> bobry: i'm not too familiar with bson or aeson
10:35:19 <Veinor> what is the type of the convert function you want to write, Bson.Field -> Aeson.Value?
10:35:47 <bobry> [Bson.Field] -> Aeson.Document
10:35:58 <bobry> here's what got atm https://gist.github.com/1635032
10:36:15 <bobry> *Aeson.Object, typo
10:37:01 <Veinor> ah
10:38:43 <Veinor> the problem is basically, for example, that it doesn't 'know' that a BSON Value using the Float constructor is the same as a JSON Number
10:40:08 <bobry> yup, and even though a can convert a BSON Value to a Haskell type, I need to fix the type to do that <_<
10:40:22 <Veinor> are all of your values going to be the same type?
10:40:22 <ocharles> hrm, you need to introduced a scoped type variable, but I don't know if that's possible for instance declarations
10:40:27 <mdmkolbe> Is there an equivalent to "=<<" that has type "(a -> b -> m c) -> m a -> b -> m c"?  (I can build it myself, but if it already has a name (like "liftM", "ap", etc.), then I'd prefer to use that.)
10:40:45 <Veinor> or are some of them going to be strings, some of them numbers, etc.
10:41:21 <bobry> Veinor: nope, they will have different types (unfortunately)
10:41:41 <bobry> ocharles: well, i'm not sure what constraints i need on that type variable
10:41:41 <Veinor> bleh.
10:42:02 <sshine> mdmkolbe, doesn't (=<<) exist?
10:42:08 <Veinor> i dunno then, i'm sorry
10:42:11 <Veinor> @type (=<<)
10:42:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:42:46 <Botje> mdmkolbe: partially apply flip first_argument ?
10:42:51 <mdmkolbe> sshine: it has the wrong type
10:42:54 <dmwit> :t flip (fmap (=<<))
10:42:55 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => a1 -> (a1 -> a -> m b) -> m a -> m b
10:43:23 <dmwit> ah
10:43:28 <mdmkolbe> :t fmap (=<<)
10:43:29 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => f (a -> m b) -> f (m a -> m b)
10:43:47 <ocharles> bobry: well, you want to say (forall a.) somewhere, and then make use of that variable in the declaration
10:43:51 <ocharles> but I don't know how to do that
10:43:58 <dmwit> fmap (=<<) :: (a -> b -> m c) -> (a -> m b -> m c)
10:44:31 <dmwit> ?pl \f -> flip (fmap (=<<) (flip f))
10:44:31 <lambdabot> flip . fmap (=<<) . flip
10:44:40 <dmwit> :t flip . fmap (=<<) . flip
10:44:40 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> a1 -> m b) -> m a -> a1 -> m b
10:44:47 <dmwit> bingo
10:44:51 <mdmkolbe> Botje: I don't quite understand what you mean and am unable to parse that into code
10:45:22 <Botje> mdmkolbe: myeah, never mind.. i don't think it'll work
10:45:49 <ocharles> @djinn
10:45:49 <lambdabot> Cannot parse command
10:46:06 <dmwit> ?pl \f ma b -> ma >>= \a -> f a b
10:46:06 <lambdabot> flip ((.) . (>>=)) . flip
10:46:12 <dmwit> I like mine better.
10:46:14 <ocharles> @djinn (a -> b -> m c) -> m a -> b -> m c
10:46:14 <lambdabot> -- f cannot be realized.
10:46:18 <ocharles> meh
10:46:28 <dmwit> ?djinn Monad m => (a -> b -> m c) -> m a -> b -> m c
10:46:28 <lambdabot> -- f cannot be realized.
10:46:42 <dmwit> Maybe Monad isn't in ?djinn-env.
10:46:49 <dmwit> Anyway, I don't think there's a name for it.
10:46:59 <ocharles> no, it's pretty weird
10:47:16 <dmwit> But flip . fmap (=<<) . flip is an elegant and concise implementation.
10:48:18 <ocharles> well, to a degree. I wouldn't be able to figure out what actually happened if someone gave me that
10:48:19 <ocharles> but hopefully this is going to be named
10:48:54 <dmwit> Yes, well, \f ma b -> ma >>= \a -> f a b is an elegant, concise, and readable implementation. =)
10:50:25 <dmwit> I would propose a new naming scheme for the lift* family:
10:50:35 <acowley> I often wish my definition of readable was constant
10:50:44 <dmwit> liftM, liftMM, liftMMM, liftMMMM; then liftM_ and lift_M for the two that are like mdmkolbe's request
10:50:49 <dmwit> lift_ for ($)
10:50:58 <dmwit> or no, lift_ for return, I guess
10:51:27 <dmwit> (return .)?
10:51:53 <mdmkolbe> dmwit: and if you treat number as exponents, then the existing "liftM3" name is consisstent with "liftMMM", heh
10:52:26 <dmwit> Ah, I see, the confusion I'm getting myself into is that there aren't enough "arguments" in the name: it also needs an M or _ for the return type of the argument.
10:52:43 <dmwit> bleh
10:52:51 * dmwit retracts his suggested naming convention
10:54:01 <dmwit> liftJustLookAtTheTypeToSeeWhatItDoesAlpha, liftJustLookAtTheTypeToSeeWhatItDoesBeta, liftJustLookAtTheTypeToSeeWhatItDoseGamma, liftDidYouNoticeTheTypoInThatOneWhatIsThisPHPOrSomethingDelta
10:54:33 <mdmkolbe> dmwit: note, that the other monadic helpers suffer the same problem. e.g. there is no "m (a -> b) -> a -> m b" equivalent of "ap" (perhaps not the best example)
10:54:43 <acowley> Come to think of it, why don't we call type errors typos?
10:55:09 <dmwit> heh
10:55:21 <nand`> because some programmers actually make logic mistakes. Strange, I know
10:55:21 <geekosaur> because beginners find haskell confusing enough as is?  (also I think mauke beat you to that one...)
10:55:33 <geekosaur> "type-o" might work :p
10:55:37 <dmwit> ?quote mauke typo
10:55:37 <lambdabot> No quotes match. Just what do you think you're doing Dave?
10:55:53 <acowley> So a type checked program is type-o-negative?
10:56:07 <dmwit> argh
10:56:23 * dmwit sighs
10:56:25 <dmwit> acowley++
10:56:34 <acowley> geekosaur: I intend to overwhelm beginners with so much reused terminology that they can no longer speak English after learning Haskell.
10:56:40 <geekosaur> someone should have recorded it, nobody did :/ and it's scrolled out of my buffer
10:57:15 <dmwit> Vim has a fit trying to load #haskell.log.
10:57:22 <nand`> acowley: what shall you rename functors and monads to then? They're hardly english
10:57:41 <Sgeo> What's the most idiomatic way to do things that have events?
10:57:55 <acowley> Sgeo: argue about it on #haskell
10:58:12 <Sgeo> Someone suggested wrapping stuff up with reactive-banana, but I don't want to force clients to be written in an FRP style
10:58:16 <dmwit> geekosaur: closest I see is 10:31 < mauke> lukish: no, you made a typo when you wrote the type here
10:58:22 * Sgeo was thinking about conduits
10:58:30 <acowley> Sgeo: you could provide Chans as an interface for clients
10:58:46 <geekosaur> it was sometime yesterday
10:58:50 <mdmkolbe> acowley: "constructor", "class" and "instance" are a good start.  I gave up learning Haskell the first couple of times because I had the OOP terms in my head.
10:59:03 <geekosaur> hrm
10:59:11 <Sgeo> I thought about that for a while, but not sure it's a great idea
10:59:35 <mauke> geekosaur: probably not me
10:59:41 <acowley> mdmkolbe: it's hard to beat Object in terms of confusing terminology. It's a familiar word that most people struggle to define when asked, so we overload it with lots of PL baggage.
10:59:42 <cmccann> "class" and "constructor" are at least valid uses of existing terminology, even if they differ from OO use
11:00:04 <cmccann> using "instance" and "method" is kind of painful though
11:00:08 <nand`> functions should be renamed methods just to confuse the hell out of OOP programmers
11:00:11 <acowley> I suppose I should advocate a sharp, techinical meaning of "Thing"
11:00:29 <mauke> nand`: but what do we call methods then?
11:00:48 <acowley> mauke: objects
11:00:49 <nand`> hmm
11:01:24 <nand`> interface methods?
11:02:21 <geekosaur> oh.  it was shachaf, actually.  Jan 14 01:58:15 <shachaf>       cmccann: "typo" is the term I use for a type error.
11:02:21 <Sgeo> acowley, Chans are not functors, nor are they things that can easily be filtered
11:02:35 <geekosaur> and not yesterday.  /me squeegees brain...
11:02:35 <Sgeo> Well, the reading IO stuff is a functor, I guess
11:02:39 <Sgeo> I was considering exposing that
11:02:41 <aaa`938> yoyo
11:03:03 <acowley> Naming things is really a fascinating subject. I know I waste tons of my life trying to divine why something has a particular name in the hope that it will help with understanding. It never does. Names are worse than analogies.
11:03:19 <mm_freak> isn't there any text type with O(1) lookup?
11:03:23 <acowley> Sgeo: Is there a problem with just using lists?
11:03:29 <mm_freak> "lookup" as in indexing
11:03:32 <acowley> mm_freak: Vector Char?
11:03:33 <dmwit> mm_freak: Array Char
11:03:34 <Sgeo> acowley, you mean lazy lists?
11:03:38 <acowley> Sgeo: yes
11:03:39 <dmwit> Or, yeah, Vector.
11:03:41 <Sgeo> er, lazy IO lists?
11:03:45 <acowley> ah
11:03:54 <mauke> mm_freak: how is that a useful operation?
11:04:04 <mm_freak> acowley: indeed
11:04:08 <mm_freak> dmwit: no, Array sucks =)
11:04:19 <dmwit> mm_freak: Can you be a bit more specific?
11:04:25 <mm_freak> mauke: it's useful for some text processing operations
11:04:30 * tgeeky read something earlier (but can't get link due to reddit being down) -- the basic scenario for when you want to use bytestring is you want to get at another language's (say, C) string data in memory?
11:04:30 <mauke> for example?
11:04:40 <mm_freak> dmwit: just joking, but i usually prefer Vector over Array
11:04:59 <acowley> Sgeo: if you need IO (or some computational context for steps along the stream), you could try something like what I use here: https://github.com/acowley/roshask/blob/master/Ros/Topic.hs
11:05:04 <nand`> tgeeky: it's appropriate whenever you want to process a sequence of 8-bit integers
11:05:05 <dmwit> tgeeky: ByteString is great whenever you need a string of bytes (crazy, I know).
11:05:07 <nand`> for example, file IO
11:05:12 <mm_freak> mauke: building markov chains
11:05:38 <acowley> Sgeo: though that type has a buffering component that you probably don't want
11:06:01 <tgeeky> dmwit: who... whe... what kind of devious mind thought of that!?
11:06:13 <tgeeky> you're crazy! the lot of you!
11:07:34 * geekosaur still not sure he understands the use case, but perhaps this is intended to be a text buffer (as with an editor)?  the problem there is the design depends on how exactly you're going to use it
11:07:35 <acowley> Should I push for a rename of ByteStrings, too? The existing name is a bit too on the nose for comfort.
11:07:54 <geekosaur> we can call it FPS! :p
11:08:22 <dmwit> Ah, yes, the old first-person shooter data type.
11:08:45 <acowley> its constructors are W|A|S|D
11:09:05 <nand`> I think haskell might be too unappealing to java programmers, we should push for some better naming schemes: I propose UnsignedEightBitIntegralNumberOrderedUnidirectionalSequence...Generator
11:09:08 <geekosaur> (now I want to know if it has unsafeKonamiCode)
11:09:11 <Botje> Call them Enterprise-level directional unicode containers!
11:09:30 <Botje> with state of the art character processing methods!
11:09:37 <acowley> I know I've said it before, but I still find the haskell topic on SO to be comically well-served.
11:09:45 <Sgeo> Hmm?
11:10:00 <cmccann> acowley, everyone needs a hobby
11:10:04 <acowley> nand`: I thought Javanians didn't believe in unsigned numbers?
11:10:09 <Philonous_> nand`:  ...FactoryFactory
11:10:40 <nand`> acowley: beats me, they dont? Okay, uh... signed 16-bit integer with a >=0 <=255 restriction hardcoded into each method?
11:10:50 <acowley> cmccann: If you polled the Haskell community and asked for hobbies, "Helping people" would probably come out very high.
11:11:01 <acowley> nand`: now you're talking
11:11:02 <Sgeo> I don't get the Factory pattern. I mean, of course it's useful for things to be able to make other things, but why does that need a special name?
11:11:17 <acowley> Sgeo: I call those things Objects
11:11:18 <nand`> actually, it's 2012.. no reason not to use 64 bit integers. I mean, they're faster in memory right guys?
11:11:20 <Botje> Sgeo: it's to remind java programmers where they'd otherwise be.
11:11:38 <The_Journey> hi, I am using a low-level C file in a Haskell module, how can I make it so that when I import that module, I don't have to include the C file in the compilation process?
11:11:40 <Philonous_> Sgeo:  Because "closure" all mathy and scary
11:11:44 <Philonous_> sounds*
11:12:08 <Botje> The_Journey: create a proper haskell library?
11:12:11 <acowley> The_Journey: build your low-level-C-using module as its own package
11:12:16 <nand`> Sgeo: in C# land we like to put generators like that inside static methods; but java takes it a step further by recommending that generator parameters deserve states of their own
11:12:27 <nand`> so you can re-use generators, I guess
11:12:55 <cmccann> Sgeo, it's mostly about working around limitations that prevent you from abstracting over constructors
11:13:09 <The_Journey> :(
11:13:18 <nand`> Sgeo, it's because they don't have partial application so they can't pass around specialized versions of functions like haskell can
11:13:33 <The_Journey> is there some tutorial or guide-lines on how to write a proper Haskell library?
11:15:16 <acowley> The_Journey: http://en.wikibooks.org/wiki/Haskell/Packaging is somewhat out of date. I'd just create a new directory then run "cabal init" in that directory. You can figure out most of it from there.
11:15:28 <The_Journey> acowley: thank you
11:16:13 <The_Journey> what is the main difference between darcs and git? I'm using git for my project, should I switch to darcs?
11:16:37 <Enigmagic> no
11:16:37 <Botje> darcs has a much better interface
11:16:48 <Botje> but you shouldn't switch, no
11:16:51 <acowley> The_Journey: no, unless you want to work with someone who only uses darcs
11:16:58 <mauke> I don't think darcs has a better interface
11:17:11 <cmccann> git has github, which is a major benefit
11:17:16 <The_Journey> ^
11:17:17 <parcs`> how can i make git pull look like darcs pull?
11:17:22 <acowley> github is spectacular
11:17:57 <Botje> mauke: you think git add -i is better than darcs record?
11:18:31 <Enigmagic> parcs`: what do you want it to do?
11:18:36 <mauke> Botje: no
11:18:38 <acowley> I've never found darcs's interface to be better, but I know git much better so it's not a useful comparison.
11:18:40 <nand`> my vote is for git + github
11:18:41 <nand`> + git flow
11:18:46 <nand`> it's the version management system of the future
11:19:00 <Botje> mauke: that's what I was referring to :)
11:19:16 <Botje> I'm so bad at git's -i mode I just bought a graphical git client and use that
11:19:37 <parcs`> Enigmagic: i want git pull to enumerate the new patches/revisions and allow me to view the diffs
11:20:08 <acowley> git flow always seems to demand too much of a committment when getting started
11:20:46 <Enigmagic> parcs`: i think you need to use cherry-pick to selectively merge commits
11:21:01 <nand`> it's geared towards larger projects. For two or three man stuff I just used regular git without a problem
11:21:10 <mjrosenb> Botje: every time i need to use git, i end up using a gui.
11:21:11 <Clint> parcs`: you could do a git fetch and then git log on the remote before merging
11:21:38 <parcs`> Clint: git log doesn't show the diff
11:22:02 <Clint> parcs`: git log -p does
11:22:19 <Botje> parcs`: git fetch; git log -p FETCH_HEAD..HEAD
11:22:23 <Botje> uh
11:22:27 <kuznero> Hi All!
11:22:28 <Botje> HEAD..FETCH_HEAD even :/
11:22:31 <acowley> I'm not sure how frequently to make release branches in a git flow type model
11:22:50 <parcs`> yay, thanks
11:23:27 <Enigmagic> acowley: you could tag each release and branch later if you need to patch it
11:23:46 <acowley> yeah that's probably wise
11:24:11 <acowley> I worry about scalability with having too many branches. On a very simple level, it makes the output of git branch harder to parse.
11:24:19 <acowley> So most of my branches are short-lived
11:25:11 <Enigmagic> i don't think it's going to change perf much, it's just a matter of having too many branches :-)
11:25:41 <acowley> Yeah, it's a UI issue not a perf one
11:26:06 <parcs`> git log -p --color is even better!
11:26:12 <Enigmagic> though a lot of times i'll just push excess branches to a remote and nuke them locally
11:27:01 <acowley> Enigmagic: that makes sense, but you still end up with this long linear list of branches at some point. Either with git branch -r, or in a drop-down list on github (or something providing similar functionality).
11:27:24 <parcs`> --color-words is even better!!
11:27:24 <Enigmagic> yeah
11:27:25 <acowley> Enigmagic: I suppose what I'd want is an archive to dump branches into
11:27:45 <acowley> what does --color-words do?
11:27:52 <Clint> i have color in my .gitconfig
11:28:12 <Enigmagic> only colors the changed bits of each line instead of the full line
11:28:14 <acowley> oh wow that is neat
11:29:01 <acowley> err, one problem is that it makes my strict line-length discipline sort of irrelevant
11:29:32 <acowley> If there's a deletion and an addition on the same line, they're placed next to each other, which causes my line to run off the edge of my terminal.
11:29:38 <Enigmagic> not really, using more lines still helps auto-merges
11:29:56 <acowley> I meant irrelevant for display purposes
11:30:25 <parcs`> 'git config --global color.ui true' for color everywhere!
11:30:35 <alistra> COLORS
11:30:42 * ocharles also colours all the things
11:30:43 <nand`> have any attempts been made to localize haskell into languages with other alphabets?
11:30:43 <acowley> One of the benefits of treating 80 as a hard limit is I minimize how often I deal with lines getting cut short when displayed
11:30:45 <Clint> auto might be wiser
11:30:55 <ocharles> also, magit is amazing
11:31:09 <parcs`> Clint: synonymous
11:31:25 <Clint> ah, then nevermind
11:40:30 <slack1256> is there a way in GHC to make that Data.Map "insert 5 'x' (insert 7 'x' bigTree)" occur as a single mutation?
11:40:46 <parcs`> mu-what?
11:41:08 <Clint> genetic insert
11:41:22 <slack1256> because haskell inmutability make that ghc copy the whole tree after "insert 7" when I only care about the tree after the (insert 5)
11:41:27 <slack1256> genetic insert?
11:41:34 <Botje> slack1256: you could use the union function
11:42:04 <slack1256> oohh RIGHT!
11:42:10 <c_wraith> I don't actually know of any algorithm that's better for adding two nodes to a balanced tree than just adding the two one at a time.
11:43:25 <Enigmagic> slack1256: it doesn't copy the whole tree
11:44:25 <slack1256> yeah, but conceptually "the first insert" throw new tree that "the last insert" modifies
11:44:38 <slack1256> instead Data.Map.union seems to do this on a single step
11:44:48 <slack1256> or i am wrong for seeing this in such way?
11:45:15 <Enigmagic> the first tree isn't fully discarded
11:45:26 <c_wraith> most of it isn't discarded, in fact.
11:45:29 <parcs`> slack1256: union is implemented in terms of insert
11:45:43 <c_wraith> most of the result of insert is shared with its input
11:45:48 <c_wraith> especially for large trees
11:45:54 <c_wraith> that's the benefit to immutability
11:46:04 <c_wraith> you don't copy the whole thing, only the parts that change.
11:46:14 <Enigmagic> slack1256: http://en.wikipedia.org/wiki/Persistent_data_structure#Trees
11:46:22 <Enigmagic> that has pretty diagrams
11:46:53 <roconnor> is shiftRL# new in GHC 7 or something?
11:47:34 <acowley> roconnor: Probably. I think several unboxed/unchecked shifts were added.
11:49:40 <slack1256> Enigmagic: thank, although wikipedia is supposed to be in black out i still see it
11:50:23 <dmwit> parcs`: No, union is not implemented in terms of insert.
11:51:13 <Enigmagic> roconnor: doesn't look like it, has been around since 2005 according to git
11:51:38 <Enigmagic> err 2001
11:51:39 <Enigmagic> 260e7f2e (simonmar              2001-12-21 15:07:26 +0000 779) a `shiftRL#` b  | b >=# WORD_SIZE_IN_BITS# = int2Word# 0#
11:51:58 <slack1256> dmwit: true, it is in term of "join" which is defined in terms of "insertMin and insertMax"
11:52:09 <slack1256> insert is implemented on term of balance
11:52:49 <dmwit> It's a hedge-union algorithm, which is (supposed to be) more efficient than just doing lots of inserts.
11:59:36 <silver> is there any easy way to get Int out of Word32?
11:59:43 <silver> except through Bits
11:59:46 <dmwit> :t fromIntegral
11:59:46 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:59:55 <silver> oh, silly me
12:00:12 <silver> @info Word32
12:00:12 <lambdabot> Word32
12:00:20 <dmwit> ?undo Word32
12:00:20 <lambdabot> Word32
12:00:27 <dmwit> ?info do { x <- m; y }
12:00:27 <lambdabot> m >>= \ x -> y
12:01:01 <dmwit> Somebody should really write an ?info plugin that just responds with "Not implemented" or something.
12:01:06 <silver> what does info do? I thought it prints type info
12:01:17 <silver> 9nstances for example)
12:01:21 <dmwit>  ?info auto-corrects to ?undo, as I demonstrated above.
12:01:32 <silver> oh
12:01:43 <acowley> I'm putting undo in the bag with typo.
12:03:56 <silver> oh there's :info in ghci
12:06:23 <tsousa> here http://dpaste.com/689914/ why do we need fmap?
12:07:19 <dmwit> because "reverse" only knows how to work on Things, not IO Actions That Return Things
12:07:22 <silver> getLine is IO monad
12:07:28 <DanBurton> tsousa: getLine has type IO String
12:07:32 <silver> fmap lifts reverse in it
12:07:35 <Lemmih> tsousa: Because 'reverse' has type '[a] -> [a]' and you want it to have type 'IO [a] -> IO [a]'.
12:07:51 <tsousa> i couldnt have done onlye rever $ getline?
12:08:01 <silver> nope
12:08:06 <tsousa> why not?
12:08:22 <silver> types do not match
12:08:50 <DanBurton> reverse works on lists
12:08:56 <DanBurton> :t reverse
12:08:56 <lambdabot> forall a. [a] -> [a]
12:09:02 <silver> :t getLine
12:09:03 <lambdabot> IO String
12:09:07 <DanBurton> :t fmap reverse `asAppliedTo` getLine
12:09:07 <lambdabot> IO [Char] -> IO [Char]
12:09:17 <DanBurton> so when you fmap reverse, it "lifts" it
12:09:21 <DanBurton> into the IO context
12:09:28 <MostAwesomeDude> :t liftIO reverse
12:09:29 <lambdabot>     Couldn't match expected type `IO a'
12:09:29 <lambdabot>            against inferred type `[a1] -> [a1]'
12:09:29 <lambdabot>     In the first argument of `liftIO', namely `reverse'
12:09:32 <tsousa> oh!
12:09:33 <tsousa> nice
12:09:34 <MostAwesomeDude> Oh, that's right. Nevermind.
12:09:39 <tsousa> Haskell is pretty sweet
12:09:44 <nand`> :t liftM reverse
12:09:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a]
12:10:34 <tsousa> another question i did well understand the type of fmap
12:10:37 <tsousa> :t fmap
12:10:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:10:52 <tsousa> f a -> f b
12:11:00 <silver> f here is a type constructor
12:11:09 <tsousa> fmap returns an function f a and then that function returns another function f b?
12:11:16 <DanBurton> it takes a function (a -> b), and "lifts" it so it works in a context: (f a -> f b)
12:11:17 <tsousa> i dont undestand it
12:11:41 <DanBurton> the "context" for your example is f = IO
12:11:42 <acowley> extra parens helps: Functor f => (a -> b) -> (f a -> f b)
12:11:48 <statusfailed> Hmm, why isn't there an "alter with default" kind of function in Data.Map ?
12:11:54 <silver> this vasically means that fmap take function that works on naked a and b (a -> b) and makes it work on clothed in f a anb b (f a -> f b)
12:12:16 <Saizan> tsousa: something of type (f a) isn't necessarily a function, e.g. f could be Maybe, [], IO, ..
12:12:17 <tsousa> humm ok
12:12:22 <DanBurton> statusfailed: isn't there? I thought there was
12:12:53 <statusfailed> DanBurton: Oops, I meant "adjust"
12:13:00 <tsousa> yeh i am still very confused previously i almost had never worked with language that have strong type system
12:13:05 <statusfailed> e.g. adjust' :: Ord k => (a -> a) -> a -> k -> Map k a -> Map k a
12:13:07 <tsousa> it's kinda of weird
12:13:09 <tsousa> but awesome
12:13:26 <statusfailed> I hoogle'd it and got nothing
12:13:58 <statusfailed> adjust' f d k m = let g = Just . maybe (f d) f in alter g k m
12:15:14 <ppseafield> statusfailed: Could you use alter to do that?
12:15:16 <DanBurton> statusfailed: I think "alter" is what you are looking for...isn't it?
12:16:34 <statusfailed> DanBurton: well that's how I wrote adjust', but I was just wondering if I duplicated any effort
12:17:02 <acowley> Isn't that just: statusfailed f d = alter (maybe (Just d) f)
12:17:19 <acowley> err, not quite
12:17:44 <statusfailed> acowley: adjust' f d = let g = Just . maybe (f d) f in alter g
12:17:47 <statusfailed> maybe?
12:17:54 <acowley> alter (maybe (Just d) (Just . f))
12:17:55 <statusfailed> oh but I could just ditch the let
12:18:07 <statusfailed> yes it is.
12:18:11 <statusfailed> awww
12:18:21 <acowley> I guess the point is that what you want is just a slightly clunky use of alter
12:19:00 <DanBurton> @pl adjust' f d k m = let g = Just . maybe (f d) f in alter g k m
12:19:00 <lambdabot> adjust' = ((alter . (Just .)) .) . (flip =<< (maybe .))
12:19:04 <DanBurton> ew
12:19:09 <statusfailed> hehe
12:19:31 <statusfailed> well I wanted to write some stuff to allow keeping lists of things with the same key
12:19:54 <statusfailed> so I needed a function to insert a value into a map of lists of values
12:20:32 <DanBurton> sounds like a hash set
12:20:39 <statusfailed> baaaaallls
12:21:23 <statusfailed> wait, does it?
12:22:16 <acowley> Yes, but that's what you're already doing except your hash function is very specifically tailored to your application.
12:26:03 <statusfailed> Wouldn't a hashset lose the order elements were added?
12:28:02 <DanBurton> statusfailed: maps also have this property
12:28:29 <DanBurton> statusfailed: but with a linked list inside, elements that are placed in the same key will preserve insertion order amongst themselves
12:28:47 <DanBurton> or "can" I should say
12:28:47 <acowley> not to mention DanBurton introduced the idea that the values in the map are sets
12:29:11 <DanBurton> acowley: no, rather, I was thinking of this: http://stackoverflow.com/a/7971705/208257
12:29:53 <DanBurton> and that the map itself is simply an implementation of a set
12:31:26 <DanBurton> is there a standard library version of takeWhile that also includes the "offending" element as the last element of the list?
12:32:33 <geekosaur> didn't someone else ask that recently?  the answer is "no" but you can get something vaguely similar with e.g. span/break
12:36:00 <mirantopac> Hello. i have previous knowledge in Python(some parts of the language) i did some small stuff like exercises, programs to solve some maths problems, some euler. but i never did any big or medium project. now i want to change the language and learn something new to start coding more big or at least medium size projects with a new language. Haskell will be nice for it?
12:38:07 <parcs`> sure
12:38:08 <nogginBasher> mirantopac: haskell is a great language, but it's quite tough.  i would start off with small projects ;)
12:38:18 <silver> yeah, but a bit challenging
12:38:41 <nogginBasher> you could write some of the library functions for your app first
12:38:51 <mirantopac> i want to learn the language in depth in python i read some tutorial and i wanted to start coding but that was a mistake because i didnt know the language that well
12:38:57 <silver> well now I think that come up with good task for myself is harder then to learn new language :<
12:40:32 <nogginBasher> hehe
12:40:46 <nogginBasher> "hello world", then factorial, then "guess what number i'm thinking of"
12:41:26 <DanBurton> :t factorial
12:41:27 <lambdabot> Not in scope: `factorial'
12:41:35 <acowley> nogginBasher: 3
12:41:54 <silver> hehe
12:43:05 <mirantopac> so you guys think that Haskell would be a nice language to go further?
12:43:33 <silver> totally
12:43:46 <statusfailed> DanBurton: I thought this would turn out more concise than it did: until ((>16) . head . snd) (\(xs,(y:ys)) -> (y:xs, ys)) ([], [1..20])
12:43:49 <statusfailed> it's also backwards
12:43:49 <statusfailed> :D
12:43:52 <mirari_> mirantopac: Asking in #haskell, what answer do you expect? :)
12:43:58 <mirari_> mirantopac: What kind of programs do you wish to write?
12:43:59 <silver> well if you ask same question about python on #python you'll get same answer ;)
12:44:23 <DanBurton> statusfailed: lol :)
12:45:27 <mirantopac> mirari_: i want to try a lot of thing GUI, network
12:45:45 <statusfailed> @pl \g xs = fst $ until (g . head . snd) (\(xs,(y:ys)) -> (y:xs, ys)) ([], xs)
12:45:46 <lambdabot> (line 1, column 7):
12:45:46 <lambdabot> unexpected "="
12:45:46 <lambdabot> expecting pattern or "->"
12:45:54 <statusfailed> @pl \g xs -> fst $ until (g . head . snd) (\(xs,(y:ys)) -> (y:xs, ys)) ([], xs)
12:45:54 <lambdabot> (fst .) . (. (,) []) . flip until (ap ((,) . join (:) . head) tail . snd) . (. (head . snd))
12:45:58 <statusfailed> ...... wat?
12:50:35 <hpc> @pl \a b c d e f g -> g f e d c b a
12:50:36 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
12:54:21 <DanBurton> ...flip
12:54:38 <donri> look at meee, i'm flyyiiiing
12:54:53 <dmwit> ?pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> d m w i t i s a w e s o m e
12:54:56 <lambdabot> const . const . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .)
12:54:56 <lambdabot> .) . (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const
12:54:56 <lambdabot> .) .) .) .) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) .
12:54:56 <lambdabot>  flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (
12:54:56 <lambdabot> ((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (
12:54:58 <lambdabot> [3 @more lines]
12:55:00 <DanBurton> -_____________-
12:55:00 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:12 <cheater_> haha
12:55:24 <DanBurton> @more
12:55:25 <cheater_> you could use that for encoding strings
12:55:39 <dmwit> @more
12:55:49 <dmwit> @pl-resume
12:55:52 <dmwit> ...=/
12:55:53 <DanBurton> ..."more" broken?
12:55:55 <lambdabot> const . const . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .)
12:55:55 <lambdabot> .) . (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const
12:55:55 <lambdabot> .) .) .) .) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) .
12:55:55 <lambdabot>  flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (
12:55:55 <lambdabot> ((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (
12:55:57 <lambdabot> [3 @more lines]
12:55:59 <lambdabot> optimization suspended, use @pl-resume to continue.
12:56:01 <DanBurton> o_O
12:56:07 <dmwit> laaaaaag
12:56:24 <DanBurton> @botsnack
12:56:24 <lambdabot> :)
12:57:19 <Liskni_si> hello, given some function  f ∷ (A a → A a) → (B a → B a) → (C a → C a) → (ABC a → ABC a), is there any way to write something like:  g h = f h h h ?
12:57:42 <dmwit> :t join
12:57:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:57:47 <dmwit> :t join . join
12:57:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
12:58:03 <shachaf> Liskni_si: With a rank-2 type?
12:58:19 <dmwit> Oh, yes, I missed those capital letters.
12:59:17 <shachaf> g :: (forall d a. d a -> d a) -> ABC a -> ABC a; g h = h h h, or something along those lines.
12:59:27 <shachaf> Depending on what type you actually want.
13:00:05 <DanBurton> h would have to satisfy (A a -> A a), (B a -> B a), (C a -> C a) simultaneously
13:00:28 <Liskni_si> shachaf: the problem with rank2 is that if h needs something like Show a, it doesn't typecheck
13:00:50 <Liskni_si> i made a typeclass ABC' of which A a, B a and C a were instances
13:00:55 <shachaf> It doesn't?
13:01:19 <shachaf> I'm not sure a typeclass is what you want here...
13:01:30 <shachaf> Well, I have no idea what you want here, really. Your example doesn't quite say.
13:01:55 <dmwit> Yeah. An intelligent answer requires more details.
13:02:16 <Liskni_si> I need to express a constraint meaning that h typechecks as (A a -> A a), (B a -> B a), (C a -> C a) simultaneously
13:02:49 <shachaf> "more details" doesn't mean "restate the same details in different words" so much as "what are you actually trying to do?". :-)
13:03:28 <Liskni_si> okay, gimme a sec, I'll think how to say it without all the irrelevant details :-)
13:04:05 <Liskni_si> but then, I guess I can make a hpaste with the details, for a start
13:04:23 <shachaf> > let f :: (Int -> Int) -> (Char -> Char) -> (Int,Char) -> (Int,Char); f ii cc (x,y) = (ii x, cc y); g :: (forall d. Enum d => d -> d) -> (Int,Char) -> (Int,Char); g h = f h h in g succ (5,'a')
13:04:24 <lambdabot>   (6,'b')
13:04:33 <shachaf> Liskni_si: For example, that seems to work.
13:05:03 <shachaf> The question is whether the function you want to write is actually a function you want to write. :-)
13:05:17 <Saizan> a simple one would be data W (f :: * -> *) where IsA :: W A; IsB :: W B; IsC :: W C, g :: (forall f. W f -> f a -> f a) -> ABC a -> ABC a; g h = f (h IsA) (h IsB) (h IsC)
13:05:22 <Saizan> fsvo simple
13:06:45 <Liskni_si> shachaf: yeah, something like that, but what if now h ∷ (Enum d, Show d) ⇒ d → d ?
13:07:24 <shachaf> Liskni_si: Well? It'll still work, but the Show instance doesn't buy you much unless you can figure out something to do with the String.
13:07:58 <Liskni_si> it shouldn't work, because g requires me to supply a function that works for all Enum d
13:08:41 <Liskni_si> and I'd like g to just check that it works for Int and Char :-)
13:08:47 <Liskni_si> sort of.
13:09:28 <dmwit> g :: Either (Int -> Int) (Char -> Char) -> ABC a -> ABC a
13:09:32 <shachaf> > let f :: (Int -> Int) -> (Char -> Char) -> (Int,Char) -> (Int,Char); f ii cc (x,y) = (ii x, cc y); g :: (forall d. (Enum d,Show d) => d -> d) -> (Int,Char) -> (Int,Char); g h = f h h in g (\x -> toEnum . (+ length (show x)) . fromEnum $ x) (5,'a')
13:09:34 <lambdabot>   (6,'d')
13:09:51 <shachaf> Liskni_si: I have the feeling you're doing something that there's a much simpler solution to.
13:10:00 <shachaf> But I have no idea because I have no idea what you're doing.
13:10:09 <Saizan> dmwit: not Either, (,)
13:10:15 <dmwit> yes, right, of course
13:10:20 <Blkt> good evening everyone
13:10:31 <dmwit> and then "g = f" =)
13:11:14 <Saizan> Liskni_si: given just what you stated you have to do something like my gadt version, though maybe if you give us the bigger picture we can find something better
13:11:32 <Liskni_si> I'll give the bigger picture, gimme a sec
13:14:00 <Saizan> if you don't like gadts you can do it the "closed typeclass" way: class W f where caseW :: f a -> (f ~ A => A a -> r) -> (f ~ B => B a -> r) -> (f ~ C => C a -> r) -> r
13:14:44 <Saizan> and then make g :: (forall f. W f => f a -> f a) -> ABC a -> ABC a
13:14:57 <Saizan> but both of these are fairly unidiomatic
13:16:26 <tempire> sshine: thanks for your help the other day.  functors and applicative functors are clear as day now
13:16:35 <tempire> next up: everything else
13:17:02 <Liskni_si> shachaf: http://hpaste.org/56634
13:17:27 <Liskni_si> and yeah, I understand your solutions, but the key is that I don't want to add all those typeclasses to the signature of g
13:17:52 <Liskni_si> the function I'm trying to write is this descendQTM' at the end
13:18:32 <Liskni_si> if that f adds a Show b constraint, it ceases to typecheck
13:19:09 <acowley> Will I get kicked if I sometimes wish we had C++-style template instantiation available in Haskell?
13:19:28 <cheater_> @faq can acowley be kicked?
13:19:28 <lambdabot> The answer is: Yes! Haskell can do that.
13:19:38 <shachaf> acowley: No.
13:19:47 <acowley> cheater_: I should have seen that coming :P
13:19:57 <Saizan> no you won't, i'd hate you though
13:20:02 <Clint> what would that even mean
13:20:04 <cheater_> acowley: :D
13:20:50 <Saizan> Liskni_si: i think the most sensible solution is to just use descendQTM directly in that case
13:21:07 <^thief^> is there any way to access record fields given just a string with the name of the accessor function for the field?
13:21:14 <silver> acowley, like OverlappingInstances?
13:21:32 <Liskni_si> Saizan: yeah, that works :-)
13:21:52 <Liskni_si> Saizan: I was just hoping that there's a way to make that general function
13:21:54 <acowley> no, I'm just annoyed at jumping through hoops to have unpacked strict constructors for things, and then having to define instances for individual members of a family so I can pattern match on constructors
13:21:54 <Manehattan> so, uh, how can I get the data from the Iteratee ByteString IO Response thingie, I want to get the ByteString part out
13:22:36 <monochrom> you should wish for lisp-style macro instantiation
13:22:45 <acowley> that would work, too
13:23:03 <Saizan> an Iteratee ByteString IO Response is supposed to consume ByteString's
13:23:05 <silver> template haskell? metahaskell?
13:24:20 <dmwit> Common misconception number one of Haskell types: if "x" appears somewhere in the type, a value of type "x" must appear somewhere in the value.
13:24:36 <c_wraith> template-haskell is entirely compile-time, such that it's not really that much like list-style macros
13:24:42 <c_wraith> err, *lisp-style
13:24:42 <Manehattan> Saizan: it is? Then how am I supposed to get the http request data from a Request?
13:24:45 <shachaf> dmwit: Are you going to HacBos?
13:24:50 <dmwit> I am.
13:24:55 <hpc> dmwit: i doubt that's the first misconception :P
13:25:04 <hpc> misconception #1: monads are hard
13:25:11 * shachaf sighs.
13:25:31 <Saizan> Manehattan: well, i don't know of which library you're talking about
13:25:39 <dmwit> hpc: That misconception stems from mine. "How do I get a String out of my IO String? Oh, you can't? Man, monads are hard!"
13:25:59 <dmwit> shachaf: If you don't mind my asking, what's the continuation you're applying to my answer?
13:26:26 <Manehattan> Saizan: I am working on a function library that created a Wai-Application, which is Request -> Iteratee Bytestring IO Response
13:26:44 <hpc> i had that problem when i first started, but only for a couple of hours; i decided i wasn't ready to learn Monad properly and went on reading LYAH
13:27:16 <pantsman> monads are squidgy
13:27:17 <shachaf> dmwit: Oh, I remembered you were in ~PHL, so I wondered because it was close by (relatively speaking).
13:27:18 <Manehattan> Saizan: I have understood that the Iteratee consumes the bytestring, and seeing that there must be a way to actually deal with the bytestring somehow
13:27:20 * shachaf is also going.
13:27:29 * dmwit high fives shachaf
13:27:48 <Saizan> Manehattan: ah, so it works fine because you are producing an Iteratee so you just have to access the ByteString from within there
13:28:27 <Manehattan> Saizan: Indeed. But my dealing function is an arrow
13:28:30 <aristid> Manehattan: if you wait a week, wai will no longer use iteratees
13:28:54 <monochrom> I think beginners actually pay lip service to the types. from C, getchar is a "function" that "returns" a char, and beginners simply expect the same out of Haskell.
13:29:00 <Manehattan> aristid: Of course I happen to start my project short before the change.
13:29:21 <Saizan> to what? conduits?
13:29:26 <aristid> Saizan: yes
13:29:44 <Manehattan> aristid: I thought they were already using it on yesod level?
13:29:45 <monochrom> that they eventually ask "getChar :: IO Char  how do I fetch that Char" is an XY Problem.
13:29:56 <slack1256> there is an articule on haskelwiki about how to mantaining GC_Time low?
13:30:07 <Saizan> fun that WAI was supposed to be some kind of standard
13:30:19 <slack1256> or somewhere to look? some general advise i haven't read?
13:30:38 <aristid> Saizan: proof: https://github.com/yesodweb/wai/blob/master/wai/wai.cabal
13:31:00 <Saizan> i wasn't disbelieving :)
13:31:20 <aristid> Saizan: i was briefly unsure myself, so i checked
13:31:48 <aristid> Saizan: well, i guess it's problematic at this time to establish any "standard" while also using an I/O library
13:32:07 <Manehattan> aw man how the heck am I supposed to fit this into my arrow
13:35:31 <Manehattan> maybe if I changed my arrow to a (Request, Source) (Sink)...
13:37:19 <monochrom> I think inversion of control is a suitable story for beginners. you won't get a Char on a silver platter. you have to submit a callback that will be called with the Char as a parameter. submit this way: getChar >>= callback
13:37:55 <silver> neat
13:37:57 <Manehattan> that's what I left node.js for?
13:38:13 <shachaf> monochrom: That's not particularly far from the truth.
13:38:39 <shachaf> In fact it's correct, pretty much.
13:39:07 <monochrom> that is my specialty. true stories for dummies. err, beginners!
13:39:09 <Manehattan> monochrom: And there I thought GHC does tha behind the scenes
13:42:02 <^thief^> is there a way I can make parsec fail and stop parsing immediately?
13:42:30 <monochrom> yes. you can use fail "yikes"
13:43:23 <Manehattan> Ah i just see the new wai will deliver me a source with the request body
13:43:38 <Manehattan> crisis averted, silver plate is in the kitchen
13:43:54 <^thief^> monochrom: i must be doing it wrong because its not stopping the parser
13:44:00 <cmccann> won't "fail" in parsec still try other options when using (<|>) and such?
13:44:02 <^thief^> I did try that first!
13:45:18 <cmccann> if you want complete escape halting all parsing without  having that dictate the way you write the rest of the parser I think you'll need to add a separate ErrorT or something
13:45:19 <monochrom> yes, fail "yikes" <|> blah will go with blah
13:45:20 <mrakan> When I do (x <- get) within a do block and in context of a state monad, why is x only one of the two values inside the (state, value) tuple? Why isn't x the entire tuple?
13:46:25 <Botje> that translates to get >>= \x -> ...
13:46:27 <^thief^> cmccann: ok thanks I guess Ill live without it, time running short now o_0
13:46:40 <Botje> if you expand the >>= operator you'll see how it does that
13:46:53 <mrakan> Botje: Thanks, I'll try it out.
13:46:54 <dmwit> mrakan: You're wrong; the "x" is the "value" part of the tuple, not the "state" part!
13:47:18 <dmwit> mrakan: It just so happens that the "get" action copies the "state" part into the "value" part.
13:47:33 <cmccann> ^thief^, if you want to blow up everything you can use "error" or the like, which will kill the entire program unless you catch the exception in IO somewhere
13:47:52 <dmwit> mrakan: But there's no magic; in a do-block, a line like "x <- foo" will always put the "value" part into "x".
13:47:53 <^thief^> cmccann: hmm that may very well work, cheers
13:48:21 <monochrom> IMO only an ill-conceived parser needs a "global abort" that transcends even <|>
13:48:50 <dmwit> s/You're wrong/
13:49:09 <dmwit> Since on a re-reading you didn't claim the "x" got bound to the "state" part. =P
13:49:14 <mrakan> dmwit: I understand this. I only don't understand why x is the value, and not the entire (state, value) tuple.
13:49:24 <dmwit> Yes, I badly misread the question.
13:49:48 <ocharles> well when you run the state, you want to yield a value from the computation presumably
13:50:09 <ocharles> and the whole point about a monad is that the value from one computation may affect others
13:50:10 <monochrom> if the state is b, the entire (state, value) tuple of get is (b, b). do you need that tuple? the two components are the same.
13:50:11 <dmwit> mrakan: Perhaps a better question for you to ask is how come x is the value, and not the entire "state -> (state, value)" function. =)
13:50:31 <rpglover64> I have read Luke Palmer's "The 'Whole Program' Fallacy", and I still want to use a global parameter (in particular to affect the way a pure function of type "SomethingIJustMadeUp -> String" behaves). This would be constant for the duration of program execution, and I would like to avoid wrapping every function which displays values of my type in a monad or modifying the type signature of every such function to use implicit parameters. Is there a bet
13:50:31 <rpglover64> way than the unsafePerformIO trick?
13:51:23 <dmwit> "I want to do something ugly and wrong. Is there a way to do it that isn't ugly and wrong?"
13:51:38 <copumpkin> rpglover64: Reader! ;)
13:51:45 <monochrom> there is a compiler that supports global variables without going unsafePerformIO altogether, but it is not GHC. and I forgot which compiler.
13:52:01 <copumpkin> JHC's ACIO
13:52:02 <c_wraith> JHC has top-level IO actions
13:52:19 <shachaf> gcc?
13:52:32 <monochrom> shachaf wins :)
13:52:33 <dmwit> copumpkin: "I would like to avoid wrapping every function in a monad" just in case you missed it (I realize the joke may be that you didn't miss it, in which case sorry)
13:52:56 <Saizan> -> String does't allow IO, but i guess write-once vars have been done too
13:53:04 <monochrom> turbo pascal, too
13:53:50 <dmwit> rpglover64: Anyway, the point is that your function of type "SomethingIJustMadeUp -> String" isn't pure. So stop pretending it is.
13:53:57 <ocharles> rpglover64: you haven't said why a reader monad isn't sufficient
13:54:08 <ocharles> or any other monad
13:54:31 <dmwit> "constant for the duration of program execution" isn't sufficient for purity.
13:54:54 <dmwit> (Which is why some people think GHC got it wrong when they wrote os :: String instead of os :: IO String.)
13:56:02 <shachaf> dmwit: As well as Int.
13:56:06 <monochrom> that is up for debate
13:56:22 <Saizan> Int :: IO *
13:56:24 <dmwit> monochrom: Hence the "some people".
13:56:38 <dmwit> I happen to be one of those people, though I acknowledge that not everyone agrees.
13:56:39 <cheater_> dmwit: what's the significance of "os :: String" ?
13:56:39 <monochrom> if you start that again on haskell-cafe, it will be another 100-messages-per-day debate
13:56:52 <Zamarok> Is there a concatWith function in the library somewhere?
13:57:00 <dmwit> cheater_: I can't go into ghci, evaluate "os", and then replace any calls to "os" in my program with the String that results.
13:57:03 <Sgeo> foldr?
13:57:04 <Pseudonym> The Haskell community can be hacked so damn easily.
13:57:05 <Sgeo> and foldl?
13:57:08 <dmwit> cheater_: So saying it has type String is just wrong.
13:57:19 <dmwit> or rather, saying it's a pure String is questionable
13:57:23 <cheater_> dmwit: what does os do? sorry
13:57:25 <Zamarok> Sgeo: oh right, those should do what I need
13:57:26 <cheater_> :t os
13:57:27 <lambdabot> Not in scope: `os'
13:57:35 <dmwit> cheater_: Oh, it evaluates to something like "Linux" or "Windows"
13:57:47 <cheater_> why can you not replace it with strings?
13:57:48 <dmwit> :t System.Info.os
13:57:49 <lambdabot> String
13:58:04 <cheater_> oh, that is what you mean
13:58:05 <cheater_> ok yea
13:58:08 <cheater_> i know what you mean
13:58:15 <Sgeo> > System.Info.os
13:58:16 <lambdabot>   Not in scope: `System.Info.os'
13:58:31 <rpglover64> dmwit, ocharles: I was going to explain more, but suffice it to say, my superior handed those requirements to me.
13:58:37 <cheater_> i could see that being potentially a problem if you use code optimization tools that recompile haskell into haskell
13:59:07 <shachaf> The problem isn't so much one of optimization as one of semantics.
13:59:14 <cheater_> so i'm with you in that it should be somehow denoted
13:59:18 <cheater_> shachaf: yes
13:59:20 <Pseudonym> > maxBound :: Int
13:59:21 <lambdabot>   9223372036854775807
13:59:25 <cheater_> shachaf: i'm just bringing up a practical example
13:59:39 <Pseudonym> Prelude> maxBound :: Int
13:59:39 <Pseudonym> 2147483647
14:00:45 <Pseudonym> One thing that is true, though, is that os wouldn't even be a constant in Erlang.
14:00:54 <parcs`> rpglover64: so instead of "SomethingIJustMadeUp -> IO String" you want "SomethingIJustMadeUp -> String"?
14:01:14 <Pseudonym> @google haskell implicit configuration
14:01:16 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
14:01:16 <lambdabot> Title: Functional Pearl: Implicit Configurations
14:01:30 <monochrom> how would Erlang do it?
14:01:37 <Pseudonym> No idea.
14:01:44 * Pseudonym doesn't speak Erlang well enough
14:01:59 <monochrom> why would it not be constant in Erlang? not even sessional constant?
14:02:00 <Pseudonym> But you can transparently migrate Erlang threads across machines.
14:02:06 <monochrom> yikes
14:02:13 <Zamarok> When making a lambda for the first argument of foldr1, is the accumulator the first or second arg of my lambda?
14:02:16 <dmwit> Anyway, I think there's some packages on Hackage for this kind of thing, to make the ugly thing as clean as it can be.
14:02:18 <nand`> I imagine os :: String would be a problem for a hypothetical haskell machine running on a distributed network of computers running different operating systems. Wrapping it inside an IO monad would make it clear that it's handled by a specific front-end black box
14:02:20 <rpglover64> parcs`: Well, it could be a Reader that gets configured in main
14:02:23 <monochrom> (I was thinking you could hot-swap OSes! XD)
14:02:35 <shachaf> Zamarok: foldr1 uses the same order as foldr.
14:02:35 <c_wraith> Zamarok: it's unwise to think of either value as an accumulator in foldr
14:02:53 <c_wraith> Zamarok: if you want an accumulator, you should be using foldl
14:03:03 <c_wraith> (and foldl' in particular, most of the time)
14:03:05 <shachaf> c_wraith: It's not a completely unreasonable shorthand. What would you call it?
14:03:09 <Zamarok> c_wraith: Oh.. why is that?
14:03:18 <rpglover64> Pseudonym: it looks like that doesn't solve the "I need to annotate very function with a constraint" problem.
14:03:37 <nand`> :t foldr1
14:03:38 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:03:44 <c_wraith> shachaf: I'd call it "the result of the fold over the rest of the list"
14:04:08 <Pseudonym> rpglover64: Correct.  But that's an unreasonable expectation in a pure language.  Dependencies should be explicit.
14:04:14 <Pseudonym> Even Java programmers know that.
14:04:34 <nand`> TRotFotRotL for short
14:04:35 <c_wraith> Zamarok: because of the way the chain of function calls builds up.  foldr is about processing a list incrementally.  foldl is about performing a computation with an accumulator
14:05:13 <dmwit> ?hackage global-variables
14:05:13 <lambdabot> http://hackage.haskell.org/package/global-variables
14:05:17 <dmwit> ?hackage safe-globals
14:05:17 <lambdabot> http://hackage.haskell.org/package/safe-globals
14:05:18 <parcs`> it would be nice if you can leave the implicit-parameter annotations out of a type signature and let the compiler infer just those
14:05:30 <rpglover64> parcs`: Yes!
14:05:42 <Zamarok> I see.. well really I just need to concat a list of strings with a spacer between each string
14:05:50 <dmwit> Zamarok: intercalate
14:05:54 <dmwit> :t intercalate
14:05:55 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:06:10 <dmwit> > unwords ["hello,", "world"]
14:06:10 <lambdabot>   "hello, world"
14:06:12 <c_wraith> Zamarok: well, that's actually a use for foldr.  but Data.List.intercalate is that foldr already
14:06:13 <monochrom> > intercalate " " ["hello", "haskell", "monsters"]
14:06:14 <lambdabot>   "hello haskell monsters"
14:06:22 <Zamarok> ahh ok. I was looking for 'concatWith'. Thanks
14:06:23 <c_wraith> @src intercalate
14:06:23 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:06:27 <dmwit> > intercalate "  " ["hello,", "spacey", "world"]
14:06:28 <lambdabot>   "hello,  spacey  world"
14:06:47 <Zamarok> yep, exactly that
14:06:56 <rpglover64> dmwit: I'll take a look. That looks good and useful.
14:06:58 <monochrom> > intercalate "! " (repeat "die")
14:06:58 <lambdabot>   "die! die! die! die! die! die! die! die! die! die! die! die! die! die! die!...
14:07:12 <dmwit> "It means 'the' in German!"
14:07:26 <monochrom> damn you
14:07:40 <Pseudonym> dmwit: Well, feminine nominative.
14:07:59 <rpglover64> Although it would be nice if there were a version which only allowed a single assignment and errored in any other case. I guess I can wrap it.
14:08:05 <Pseudonym> Or accusative, I guess.
14:09:27 <Pseudonym> > intercalate "! " (repeat "the (f. n.)"
14:09:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:09:35 <Pseudonym> > intercalate "! " (repeat "the (f. n.)")
14:09:36 <lambdabot>   "the (f. n.)! the (f. n.)! the (f. n.)! the (f. n.)! the (f. n.)! the (f. n...
14:09:56 <monochrom> > intercalate "! " (repeat "tod")
14:09:57 <lambdabot>   "tod! tod! tod! tod! tod! tod! tod! tod! tod! tod! tod! tod! tod! tod! tod!...
14:11:42 <Pseudonym> Isn't "Tod" a noun?
14:12:11 <monochrom> yes. I don't know the verb. (or knew and forgot.) but "death! death! ..." is good enough.
14:12:31 <monochrom> and oh bother I forgot to capitalize it!
14:12:37 <Pseudonym> > intercalate "! " (repeat "stirb")
14:12:38 <lambdabot>   "stirb! stirb! stirb! stirb! stirb! stirb! stirb! stirb! stirb! stirb! stir...
14:12:55 <Pseudonym> I think that's the correct declension of "sterben".
14:13:01 <dmwit> Those backward Brits.
14:13:02 * Pseudonym has forgotten most of this
14:14:19 <nand`> Pseudonym: it's correct
14:15:38 <smoge> Hello
14:15:41 <monochrom> yikes, mail-archive.com is also blacking out for SOPA today
14:15:48 <Pseudonym> Thanks.
14:15:59 <cheater_> i want facebook to black out
14:16:11 <smoge> I'm having problems trying to install cmath bindings...
14:16:16 <hpaste_> smoge pasted “cmath” at http://hpaste.org/56637
14:16:24 <smoge> any ideas?
14:16:31 * geekosaur hears the screams of horror already
14:16:57 <smoge> it's glibc 2.15-3
14:16:59 <smoge> archlinux
14:17:25 <nand`> I want the google search engine to black out
14:17:31 <nand`> think of the damage that would cause though
14:17:42 <smoge> hi??
14:17:43 <cheater_> haha
14:17:49 <cheater_> it would be, like
14:17:52 <cheater_> total abuse of power
14:18:01 <nand`> the financial implications alone would be mind-boggling
14:19:57 <smoge> help please.. :S
14:20:06 <parcs`> imagine if freenode blacked out
14:20:11 * parcs` shudders
14:20:36 <nand`> smoge: If nobody's replying to you then it means nobody knows what's causing your problem or how to fix it, sorry
14:21:34 <sshine> tempire, wow cool.
14:21:35 <nand`> parcs`: it's a free excuse for a server downtime or netsplit
14:21:36 <parcs`> smoge: cmath is from 2008. arch is a bleeding edge distro. it is 2012.
14:22:01 <smoge> it's ghc 7.0.3
14:22:03 <sshine> tempire, did you see the typeclassopedia page?
14:22:15 <smoge> I've just compiled ghc 7.0.4, no good
14:22:27 <smoge> it should work
14:22:55 <nand`> parcs: cmath Built on	ghc-6.10, ghc-6.12, ghc-6.8, ghc-7.0, ghc-7.2
14:23:12 <smoge> yes, you see, it should work... strange..
14:23:33 <smoge> maybe a update in glibc in arch broke it?
14:25:03 <parcs`> smoge: i just successfully compiled cmath on x64 arch
14:25:14 <smoge> hum...
14:25:26 <smoge> http://hpaste.org/56637
14:26:40 <parcs`> you failed to mention you are using the AUR
14:26:53 <smoge> trying cabal
14:26:58 <smoge> with stock ghc now
14:27:02 <smoge> same problem
14:27:56 <parcs`> try 7.2 from [testing]. it's what i'm using and it works
14:28:19 <smoge> it's not in testing anymore
14:28:58 <smoge> what could make it fail? it's just ghc and glibc... strange
14:31:09 <parcs`> wow they pulled 7.2 from testing?
14:31:22 <smoge> yes
14:31:30 <smoge> correctly I think
14:31:45 <smoge> testing is to packages that will end up in core/extra
14:31:49 <smoge> 7.2 is a preview
14:32:00 <derpladee> hey where's that thing you paste stuff inhere?
14:32:09 <smoge> http://hpaste.org/56637
14:32:11 <parcs`> if that is the case they shouldn't have put it in testing in the first place
14:32:16 <parcs`> their direction is terrible
14:32:23 <smoge> yes, it was a mistake
14:32:28 <parcs`> one of many
14:33:25 <geekosaur> derpladee:
14:33:26 <geekosaur> @paste
14:33:27 <lambdabot> Haskell pastebin: http://hpaste.org/
14:34:13 <hpaste_> smoge pasted “cmath-verbose” at http://hpaste.org/56640
14:34:19 <smoge> with -v3
14:35:00 <hpaste_> derpladee pasted “par” at http://hpaste.org/56641
14:35:26 <derpladee> hey can anybody help me with that? with the first attempt, the code is sped up greatly but the garbage collector uses like 20 times more time
14:35:41 <derpladee> with the next attempt, the code is slower but the garbage collector doesn't use any time at all
14:36:00 <derpladee> i'm talking about http://hpaste.org/56641 this
14:39:41 <Saizan> you probably want to do this chunked-wise
14:40:08 <derpladee> can you elaborate?
14:40:14 <derpladee> why is the GC going crazy over that forcelist thing
14:40:23 <Saizan> though another simple thing to try might be clrs = forceList clrs2 `par` (clrs1 ++ clrs2)
14:40:54 <Saizan> i think it's going crazy simply because you're putting a lot of stuff in the heap up front
14:41:13 <gienah> smoge: http://hackage.haskell.org/trac/ghc/ticket/5050
14:42:05 <djanatyn> what's a good haskell library for sorting through information on the web and downloading it? Kinda like, beautiful soup for python?
14:42:20 <djanatyn> or, I guess, something lke WWW::Mechanize for perl would work too.
14:42:46 <derpladee> Saizan, but i can't be sure that haskell will evaluate the right hand side of `par`, and i can't be sure that the left hand side will be evaluated with "clrs1" first
14:43:41 <gregATio> yes i would like to know too about the something equivalent to mechanize though i used python
14:43:43 <Saizan> djanatyn: there's tagsoup, but it doesn't cover all of it i guess
14:43:53 <deech> I've read that Coq and Agda have stronger type systems than Haskell. How is the Haskell type system weaker?
14:44:14 <derpladee> practically, the main thread does evaluate clrs1 first, i still have problems with the GC though. is there any way i can force a list without making the GC go all crazy?
14:44:15 <gregATio> python tag soup only used to do parsing, it didnt actually do http as i recall
14:44:28 <Saizan> derpladee: well, when you ask for clrs it'll have to evaluate the RHS of par, and if you don't nothing of this will get evaluated
14:44:50 <djanatyn> Maybe someone could suggest something better for the situation, as I haven't really done anything like this before.
14:45:23 <djanatyn> I was going to write a haskell script that would slowly download all of the images on xkcd, and store them in a couple folders.
14:45:36 * monochrom sees the JHC new version announcement. wait, what? JHC requires GHC to build?
14:45:47 <geekosaur> deech, haskell doesn't (easily) support dependent types (where a type is dependent on a value)
14:45:57 <gregATio> i would probably just use wget for that
14:46:04 <derpladee> but in the RHS of par, i can't know if the main thread will try to evaluate clrs1 or clrs2 first, which is why i am trying to force it to evaluate clrs2 first using pseq .. anyway this is just all theoretical stuff since it actually does evaluate clrs1 first and leaves clrs2 for a worker thread
14:46:05 <Enigmagic> monochrom: GHC requires GHC to build too
14:46:07 <gregATio> the images are numbered
14:46:10 <Saizan> djanatyn: tagsoup + HTTP (or even shelling out to wget) should work well enough for that
14:46:14 <gregATio> so its really simple
14:46:25 <monochrom> yeah, I was hope JHC just requires JHC to build :)
14:46:26 <derpladee> anyway, you suggestion has the same problem, it makes the GC go crazy
14:46:35 <derpladee> is there any way to force a list without making the GC go crazy?
14:46:54 <gregATio> force a list , u mean dethunk it?
14:47:01 <derpladee> yes
14:47:02 <smoge> so do I need to downgrade to binutils 2.20??
14:47:11 <deech> geekosaur: Ah, is that the only difference? Don't the new extensions to 7.4 address that?
14:47:18 <derpladee> gregATio, that's what i mean
14:47:26 <smoge> gienah: so do I need to downgrade to binutils 2.20??
14:47:33 <Saizan> derpladee: you've to use something like this, i think: http://hackage.haskell.org/packages/archive/parallel/3.2.0.2/doc/html/Control-Parallel-Strategies.html#v:parListChunk
14:47:38 <m151> I'm cornfused
14:48:04 <gregATio> maybe dont use a list
14:48:20 <geekosaur> deech, not really, you still can't easily create (for example) a type which is statically checked to only hold an Int whose value is between -3 and 5.
14:48:43 <gienah> smoge: that seems to be one suggestion, or remove the -fvia-C if that is possible
14:49:00 <geekosaur> there are tricks one can use but they're generally ugly and painful (although there are libraries such as typelevel that help)
14:49:40 <deech> geekosaur: Oh, ok. Are dependant types that useful? Don't you still have to check the ranges and such at runtime before creating some value of that type?
14:50:31 <smoge> gienah: how to do it?
14:52:45 <derpladee> Saizan, but does parListChunk dethunk all elements in the list? it looks like it just reduces them to WHNF right?
14:54:06 <gienah> smoge: I wonder if there is some way to specify --size-check=warning to binutils, that may avoid it
14:54:08 <geekosaur> deech, part of it is that you would in Haskell also need to verify that every modification to such a value remains valid (that is, given the (-3 .. 5) example earlier, Haskell doesn't do much to prevent you from subtracting 8 from such a value); Coq and Agda provide compile time checking for such things.  (Again, you can do it in Haskell if you use type level naturals, but it's highly painful and easy to make mistakes)
14:54:38 <Saizan> derpladee: your forceList does the same
14:54:46 <geekosaur> but we're getting a bit beyond my understanding, really; hopefully someone with better understanding can step up and make things clearer
14:54:58 <Saizan> derpladee: but you can't just replace one for the other in your code
14:56:02 <Saizan> actually, parListChunk deals with the elements according to the Strategy you pass it
14:56:32 <derpladee> yea i just read up on it, i didn't think there was a strat to do "deep evaluation" but apparently there is
14:56:35 <derpladee> i'm trying it out
14:56:54 <deech> geekosaur: I see, thank for the explanation.
14:57:28 <derpladee> how does parListChunk divide the input list? randomly or do elements go to like thread 1,2,1,2,1,2 etc or is it like 1,1,1,1....2,2,2,2 ?
14:57:44 <hpc> @hoogle parListChunk
14:57:45 <lambdabot> Control.Parallel.Strategies parListChunk :: Int -> Strategy a -> Strategy [a]
14:58:48 <hpc> derpladee: i would suspect that parListChunk 3 blah [1..9] would go
14:59:06 <hpc> blah [1..3] `par` blah [4..6] `par` blah [7..9] or whatever
14:59:15 <hpc> probably not that exact expression
14:59:43 <hpc> ie, that Int is the size of the chunks, and then it evaluates each chunk in parallel
14:59:51 <derpladee> alright looks kinda like that from the source too
15:00:48 <gienah> smoge: in cmath.cabal maybe it might help to change: s@cc-options:      -std=c99@cc-options:      -std=c99 -Wa,--size-check=warning@
15:01:03 <tempire> sshine: yes
15:01:33 <gienah> @tell smoge in cmath.cabal maybe it might help to change: s@cc-options:      -std=c99@cc-options:      -std=c99 -Wa,--size-check=warning@
15:01:33 <lambdabot> Consider it noted.
15:25:18 <derpladee> hey, how do you install new packages with cabal?
15:26:28 <Saizan> cabal install somepackage
15:27:35 <derpladee> hmm why do i get Failed to load interface for `Control.Deepseq': when ghc-pkg list clearly says that i have deepseq installed?
15:27:59 <derpladee> oh it's DeepSeq
15:50:05 <cheater> hey guys has anyone here coded an FIR in haskell?
15:51:54 <ddarius> > let fir (x:y:xs) = (x+y)/2:fir (y:xs) in fir (0:1:repeat 0)
15:51:54 <lambdabot>   [0.5,0.5,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0....
16:06:26 <trinithis> Is it possible to write an instance of  Language.Haskell.TH.Syntax.Lift for ForeignPtr?
16:08:45 <c_wraith> trinithis: how would that even possibly make sense?  How do finalizers survive from compile time to runtime?
16:09:19 <trinithis> Oh, I've never really programmed with them. I've just been trying to get ByteString under Lift
16:09:29 <c_wraith> oh, Bytestring is much easier than that
16:09:38 <c_wraith> ignore the implementation
16:09:45 <trinithis> oh, ahah
16:09:49 <c_wraith> just work with the contents.
16:11:20 <c_wraith> just implement it in terms of pack and unpack
16:13:29 <c_wraith> something like: lift bs = let unpacked = B.unpack bs in [| B.pack unpacked |]
16:13:44 <c_wraith> of course, then you'd need to supply a Lift instance for Word8
16:14:48 <c_wraith> But that's not very hard.  lift w = let i = toInteger w in [| fromInteger i |]
16:16:58 <clsmith> hey. do you get 'dynamic dependent types'? it seems to me with a dependent type like, say, 'Prime', it would require lazy runtime assertions or something? or would you do it by declaring that x is Prime iff isPrime x, and have to check to cast from Int to Prime. but that seems like it might be undecidable, so we're back at runtime stuff. how's that solved? any links i could read?
16:22:36 <ddarius> I've never heard the phrase "dynamic dependent types."
16:23:22 <clsmith> it probably doesn't make any sense :p
16:24:17 <hpc> im pretty sure "dynamic dependent types" just means unit tests :P
16:27:09 <clsmith> well, what i'm thinking is, dependent typing can i guess require turing completeness (or whatever) (did i mention i've done very little wrt dependent types?), so if you have a Prime type you'd need to check for a given number whether it is in fact Prime. so you could define a Prime as a Num which satisfies the property isPrime? it's quite possible i am completely wrong.
16:27:39 <ddarius> clsmith: You're not even wrong.
16:30:41 <clsmith> oh goody. ok, so in that case are assertions redundant if you have dependent types? also, how could you be certain that all your bases are covered? i.e., if the number is *not* prime, what happens? you'd have to have an if somewhere checking for primality. could a compiler check for that? >.>
16:31:04 <ddarius> @google "not even wrong"
16:31:05 <lambdabot> http://www.math.columbia.edu/~woit/wordpress/
16:31:05 <lambdabot> Title: Not Even Wrong
16:31:18 <ddarius> Bah.
16:31:44 <clsmith> does 'not even wrong' mean 'you are off the scale of wrongness'? :<
16:32:40 <ddarius> clsmith: Sort of.  It means what you say doesn't make sense so assigning a truth value to it doesn't make sense.
16:32:49 <vrook> Is there a way to encode a natural number inside a type? I'm not talking about Data Nat = Zero | Succ Nat. That encodes naturals in data. I want something like Succ Zero in a type.
16:33:09 <toduro> Hi.  I'm brand new.  Have a noob question about cabal install.  Also I think what clsmith said about "not even wrong" is right.
16:33:41 <wobsite> ATS does some of this; you can have a type "arrays of size n" for example.
16:34:08 <Sgeo> Should I install Leksah from my distro or from cabal?
16:34:23 <Sgeo> I've heard that installing Haskell stuff except for platform from distro is generally a bad idea
16:34:31 <Sgeo> But Leksah website says to try distro first?
16:34:36 <toduro> Is this an OK place to ask questions about how to get a basic install of some haskell application to work?
16:35:01 <toduro> Sgeo:  On windows 7 I have installed the platform, then Leksah OK.
16:35:16 <geekosaur> Sgeo, likely because they get lots of "how do I install this?" questions and it's easier for them to say "install distro package"
16:35:21 <Clint> i don't install anything through cabal unless i have to
16:35:37 <toduro> The only instructions I have say to install via cabal.
16:36:10 <dmwit> vrook: data Zero; data Succ a
16:36:24 <toduro> Trying to install yesod.  I tried joining the yesod google group to ask the question there but apparently did not get approved or something.  Not in the group so I can't ask the question there.
16:36:27 <Sgeo> What's the worst that can happen if I install via distro?
16:37:01 <vrook> dmwit: Will that allow me to recurse on the previous natural?
16:37:03 <Clint> one of many reasons google groups is terrible
16:37:14 <dmwit> vrook: Depends what you want to do.
16:37:29 <dmwit> vrook: It's a pretty standard start for type-level programming, though.
16:37:45 <dmwit> By now, there might even be a Hackage package for the bare minimum stuff.
16:38:13 <dmwit> I was wrong, there isn't a Hackage package.
16:38:18 <dmwit> There's a *dozen* Hackage packages.
16:38:19 <vrook> I have a type associated with natural number N that is defined terms of a type with natural number N - 1.
16:39:18 <vrook> The only thing I see to do is template haskell
16:39:18 <tgeeky> at least one is: http://hackage.haskell.org/packages/archive/type-unary/0.1.15/doc/html/TypeUnary-Nat.html
16:39:19 <ddarius> There've been a dozen hackage packages for a long time.
16:39:37 <tgeeky> vrook: and as you can see, it doesn't use template haskell
16:39:49 <dmwit> Just grep for "type-level" and you'll have your long list.
16:40:00 <vrook> ok thanks I poke around
16:40:12 <dmwit> Or do it yourself.
16:40:15 <todd__> I'm following "Learn you a Haskell Monads chapter" and getting error : Not in Scope getting data contractor 'Writer' for following code
16:40:20 <dmwit> Probably it's better to do it yourself the first few times.
16:40:23 <vrook> Is the Haskell type system decidable? That's seems a huge constraint
16:40:29 <vrook> I can't do arithmetic
16:40:33 <vrook> for example
16:40:36 <todd__> logNumber x = Writer (x, ["got number:" ++ show x])
16:40:43 <ezyang> vrook: Haskell98 certainly is.
16:40:49 <c_wraith> vrook: there's an extension called UndecideableInstances for a reason
16:40:59 <todd__> I imported Control.Monad.Writer
16:41:07 <vrook> ok good to know
16:42:17 <timemage> todd__, http://www.haskell.org/hoogle/    hoogle is helpful for sorting out that kind of thing.
16:42:38 <vrook> It seems like it should be easier or more natural to do this. A lot of hoops to get an integer encoded in an array type, from what I see so far.
16:43:01 <vrook> though that is not my purpose
16:43:41 <vrook> Is it because Haskell98 was designed to be decidable?
16:43:50 <dmwit> Until you tell us what "this" is (I note that you have not yet, except that "it uses recursion"), we can't help you make it natural.
16:44:05 <todd__> timemage, thanks I'll check it out
16:45:02 <Enigmagic> vrook: check out the type-level package
16:45:30 <toduro> Directions are to install Haskell platform, then do a cabal update, then do "cabal install Cabal cabal-install yesod".  That step churns for a while but ultimately fails with lots of components failing to install because they depend on transformers-base-0.4.1 which failed to install because it was not in tar format.
16:45:53 <toduro> How to I circumvent this problem to get yesod to install?
16:46:22 <Enigmagic> vrook: and this http://hackage.haskell.org/packages/archive/llvm/3.0.0.0/doc/html/LLVM-Core.html#t:Array
16:46:28 <toduro> I have git-cloned yesod locally so I have the source
16:46:34 <Enigmagic> it's messy but it works
16:46:55 <vrook> ok thanks
16:47:03 <nh2> in Happy, can I match all tokens in a production?
16:47:30 <beez> any1 there?
16:47:40 <dmwit> toduro: Looks like it's in tar format to me. Maybe just install transformers-0.4.1 manually?
16:47:52 <dmwit> beez: No, all 600 of us have just stepped out.
16:47:56 <beez> :D
16:48:01 <beez> i am new to this irc stuff ^^ sorry
16:48:03 <dmwit> Don't ask to ask, just ask.
16:48:13 <c_wraith> dmwit: 600?  that still leaves 230 people here!
16:48:21 <vrook> I can't help but get the feeling that these are workarounds for haskell98 being too strict than what was eventually needed.
16:48:26 <dmwit> yeesh, this place just keeps getting bigger =P
16:48:54 <vrook> even C++ has no problem with integers in types (templates)
16:49:03 <nh2> I need a shortcut for myprod :: { Mytype } : TOK1 | TOK2 | TOK3 | ... | TOKn
16:49:24 <nh2> like myprod :: { Mytype } : MAGIC_ALL_TOKENS
16:49:30 <dmwit> vrook: C++ also requires significantly more type annotation.
16:49:40 <dmwit> Annoyingly much, in many cases.
16:49:42 <toduro> How do I install transformers-0.4.1 manually?   Tried to cabal-install it but that failed.  I guess the short story is I don't know how to install something without using cabal.
16:49:46 <dmwit> There is always a trade-off.
16:50:06 <dmwit> toduro: Visit its page on Hackage, grab the .tar.gz from there; untar it, and type "cabal install" in the directory it creates.
16:50:11 <dmwit> ?hackage transformers-base
16:50:11 <lambdabot> http://hackage.haskell.org/package/transformers-base
16:50:15 <toduro> thx
16:50:16 <beez> anyways.. my problem: i am learning about list monads.. and now id like to create infinite lists like this list comprehension would do for example: [x+y | x <- [1..], y <- [1..] ] .. the problem is: when i "translate" this code into a listmonads it doesnt output anything, only computes infinitely.. any ideas?
16:50:51 <dmwit> beez: What translation did you try?
16:50:56 <Sgeo> Leksah is slow at collecting package information
16:51:08 <Enigmagic> vrook: it's not so hard to specify an integer as a parameter with type-level, you'd just say "undefined :: Array Int D200" but if you want bounds checking ala dependent types it's much more difficult
16:51:37 <Sgeo> beez, the list monad isn't smart enough to alternate between the lists, so it will keep trying one of the lists forever
16:51:51 <Enigmagic> sometimes i'd like C++ templates too but oh well :P
16:51:56 <beez> i tried that: http://pastebin.com/AqiwT4mL
16:51:57 <mauke> The paste AqiwT4mL has been copied to http://hpaste.org/56642
16:51:59 <Sgeo> > take 10 $ [x+y | x <- [1..], y <- [1..] ]
16:52:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:52:57 <Sgeo> > take 10 $ do { x <- [1..]; y <- [1..]; return (x+y) }
16:52:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:53:02 <dmwit> beez: Okay, that's a translation of a very different list comprehension.
16:53:16 <Enigmagic> vrook: the upside is that you can provide the type variable at runtime, where in C++ that's not possible (with integer template parameters)
16:53:19 <dmwit> beez: It's also fairly easy to explain why that never gives you any results.
16:53:40 <beez> i understand why it doesnt give any results
16:53:47 <dmwit> ah
16:53:52 <dmwit> Then I must have misunderstood the question.
16:54:06 <vrook> Enigmagic: but the whole point is to do it at compile time. Otherwise I would just write out run-time data structures. I want to define data structures recursively at the type level, at compile-time.
16:54:14 <nh2> toduro: often you don't even have to download from hackage manually: e.g. cabal install leaves the tar.gz for me in ~/.cabal/packages/hackage.haskell.org/transformers/0.2.2.0/transformers-0.2.2.0.tar.gz
16:54:38 <vrook> type associated with integer N is defined in terms of N - 1.
16:55:08 <vrook> Are you sure there's a predecessor type operation?
16:55:34 <vrook> I still smell template haskell
16:55:53 <Enigmagic> vrook: pred :: Pred x y => x -> y
16:55:55 <dmwit> vrook: Really, come off it. You've been shown how to do it several times.
16:56:01 <dmwit> type family Foo a
16:56:09 <dmwit> type instance Foo Zero = {- base case here -}
16:56:20 <dmwit> type instance Foo (Succ a) = {- use Foo a here -}
16:56:40 <geekosaur> TH isn't required for any of them.  it's offered as a convenience
16:56:58 <vyom> I get a warning "Top-level binding with no type signature", and the return type is actually an internal type which has not been exported
16:57:12 <vyom> is there a right way to make the warning go away
16:57:44 <vrook> dmwit: I need another meta-level. I'm not writing out Foo (Succ a) = {- use Foo a here -} in code myself. I need to write code that writes that.
16:58:24 <dmwit> Huh. Are you sure?
16:58:35 <vrook> I'm defining this for general N, not for some small N and all its predecessors myself.
16:58:50 <vrook> dmwit: I am certain.
16:59:01 <dmwit> beez: Do you want to try clarifying your question? I didn't understand it the first time around, but I'm still interested in trying to help you.
16:59:18 <beez> dmwit: now i am confused.. probably i do _not_ understand why it does not output anything.. just translated the original list comprehnsion i was talking about: http://pastebin.com/MsyKVqp1 and it creates an infinite list.. would you mind giving me a short insight why the other code of mine runs infinitely without outputting anything!?
16:59:20 <mauke> The paste MsyKVqp1 has been copied to http://hpaste.org/56643
17:00:03 <dmwit> beez: Right, good. That's an accurate translation of the original comprehension you wrote.
17:00:20 <dmwit> beez: So the deal is, with list-based do-blocks, the last binding is the one that varies fastest.
17:00:52 <dmwit> beez: In your second example, "y" varies fastest; in your Pythagorean triples example, "c" varies fastest.
17:01:39 <dmwit> beez: Since "y" is drawn from an infinite list, it continues varying infinitely, and "x" never reaches its second value; likewise, in the Pythagorean triples example, "c" varies infinitely, never letting "a" or "b" take values other than 1.
17:01:39 <vrook> dmwit: just to be clear -- you are outlining a way to define some Foo type associated with some small number N which I choose at compile time; I code all the predecessor types myself. But I want to generate the type for any number N.
17:01:53 <monochrom> > do { x <- [1..]; y <- [1..]; return (x+y) }
17:01:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:01:59 <monochrom> produces some output
17:02:40 <dmwit> beez: Since there are no Pythagorean triples with "1" and "1" on the two legs, no value of "c" ever satisfies the guard, but it keeps searching more and more values of "c" indefinitely...
17:03:08 <beez> monochrom: yea.. but http://pastebin.com/AqiwT4mL doees not :(
17:03:08 <mauke> The paste AqiwT4mL has been copied to http://hpaste.org/56642
17:03:33 <dmwit> beez: The simplest way to fix this "problem" is for only the first list bound (the slowest-varying list) to be infinite.
17:03:52 <monochrom> what dmwit says. c is in the innermost loop
17:04:10 <irene-knapp> :t catMaybes
17:04:11 <lambdabot> forall a. [Maybe a] -> [a]
17:04:15 <monochrom> or more accurately, c <- [1..n] the innermost loop
17:04:27 <monochrom> Haskell is just a programming language, not a mathematician.
17:04:44 <Enigmagic> vrook: if you need it for a specific N or a range of values (not all naturals or whatever) then you could make a classifying type like "class MyRange n" and make instances for each type-level number
17:05:14 <vrook> Enigmagic: using template haskell, you mean?
17:05:16 <dmwit> beez: For example, why not let "b" range only from 1 to a?
17:05:19 <Enigmagic> vrook: no
17:05:34 <Enigmagic> vrook: unless it's a large number :P
17:05:52 <dmwit> beez: And why not let "c" range only up to a size at which "c^2" exceeds "a^2+b^2"?
17:06:08 <geekosaur> vrook, you have a fixation, better get it looked at
17:06:12 <monochrom> because it is easy to mistake Haskell for a mathematician.
17:06:15 <dmwit> beez: Then only the list that "a" is drawn from will be infinite.
17:06:54 <monochrom> if you assume that Haskell is a mathematician, then only the problem statement itself needs to be coded up
17:07:11 <vrook> Enigmagic: Oh I misunderstood. No, not a specific N. I need a general N.
17:07:21 <dmwit> vrook: That is not accurate. I am not outlining a way to define Foo only for small N. I am showing how to code Foo for all N, small or large.
17:11:09 <vrook> dmwit: "type instance Foo (Succ a) = {- use Foo a here -}" This technique would require template haskell to define Foo (Succ (Succ (Succ ...))) for a general number of Succs. Since you said "Huh. Are you sure?" I took this as confirmation of my interpretation of what you said.
17:12:03 <geekosaur> you can *always* write them out manually
17:12:13 <geekosaur> the question is why you'd want to, but as you seem to have this weird fixation...
17:12:36 <beez> dmwit: http://pastebin.com/BrcwpSkF
17:12:37 <mauke> The paste BrcwpSkF has been copied to http://hpaste.org/56644
17:12:38 <vrook> geekosaur: I assume template haskell can write them out. What I don't understand is the claim that template haskell is not needed.
17:12:56 <Enigmagic> template haskell is not required but it can be used, sure.
17:13:03 <beez> dmwit: :) thank you soo much.. excellent explination.. but actually i should have thought of that and that's why i am probably cry all night :/ ^^
17:13:05 <geekosaur> template haskell is used solely to build a sequence of (S (S (S ... Z)))
17:13:08 <geekosaur> in a loop
17:13:14 <geekosaur> you can ALWAYS write that out manually
17:13:16 <Enigmagic> if you'd like to use template haskell then go for it
17:13:30 <geekosaur> as I said, the question is why you would want to when you can make the compiler do it for you
17:13:36 <beez> dmwit: *probably gonna cry...
17:14:26 <dmwit> vrook: No. Again, your claim is not accurate.
17:14:29 <vrook> OK so the options are (1) write them out manually, (2) use template haskell. If this is correct then, as I said, some new meta-level is needed to handle the general case. And this is the role of template haskell.
17:15:05 <vrook> geekosaur: could you drop the "write them out manually" meme? I'm not interested in that, and I keep saying I want a general N.
17:15:10 <dmwit> vrook: In "type instance Foo (Succ a)", the type variable "a" matches all possible N, both Zero and (Succ a') for some other a'.
17:15:17 <ddarius> Template Haskell is neither necessary nor sufficient.
17:15:33 <dmwit> vrook: Those are *not* the options.
17:15:36 <dmwit> Please listen to us.
17:15:44 <geekosaur> vrook, it's the only way I can understand your complaint.  possibly that means you are complaining about something completely nonsensical
17:16:00 * ddarius watches dmwit get further pulled in.
17:16:06 <geekosaur> because there is no sense to what you're sauying if that *isn'[t* your point
17:16:10 <geekosaur> none whatsoever
17:16:26 <vrook> OK how do I define the 10th Foo without using template haskell?
17:16:42 <Enigmagic> vrook: http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/src/Data-TypeLevel-Num-Sets.html#Pos
17:16:43 <dmwit> The tenth Foo is already defined by the "type instance Foo (Succ a)" clause.
17:16:53 <dmwit> There are exactly three lines in the entire definition.
17:16:57 <vrook> If not Foo (Succ (Succ (Succ ...))) ten times, then how would I do it?
17:17:05 <dmwit> Foo (Succ a)
17:17:31 <geekosaur> vrook, in Foo (Succ a), a is a type variable.  that type vartiable can be instantiated to (Succ a) without any help from you
17:17:39 <geekosaur> or (Succ (Succ (Succ a)))
17:17:41 <geekosaur> it's automatic
17:17:48 <vrook> dmwit: That doesn't give me the 10th Foo. As I said at the beginning, I want to encode the number in the type itself.
17:17:55 <irene-knapp> ><
17:18:02 <geekosaur> you really are not getting it
17:18:06 <geekosaur> at all
17:18:08 <vrook> Let's say it's the 100th Foo.
17:18:20 <dmwit> Let's say it's the googol'th Foo.
17:18:21 <vrook> I don't want to write 100 Succs to get my type.
17:18:23 <dmwit> Why not.
17:18:33 <geekosaur> but you don't want the compiler to do it for you?
17:18:38 <dmwit> You don't need to write googol Succ's to get your type.
17:18:39 <geekosaur> please, make some sense.
17:19:01 * Enigmagic grabs some popcorn
17:19:15 <irene-knapp> you could probably confuse the issue some more by talking about type synonyms, but I wouldn't recommend it.  reread what has been said above, vrook - you do not need to write it out for it to exist and be referred to.
17:19:17 <vrook> geekosaur: you haven't said anything I don't understand. I know that a is a type variable in Foo (Succ a). I know how instances work.
17:19:30 <vrook> I know that it can stand for any previous Foo.
17:19:32 <geekosaur> vrook, you haven't said anything *I* can understand
17:19:37 <irene-knapp> it doesn't seem like you do know how instances work.  did you realize that that same instance declaration works for ALL the levels?
17:20:00 <geekosaur> you're repeating the same nonsense, most of it wrong, over and over again
17:20:01 <irene-knapp> there is no writing it out to get to level two - as a matter of fact if you wrote even two instance declarations, you would have overlapping ones
17:20:06 <vrook> geekosaur: what does the 100th Foo look like? Write it.
17:20:10 <geekosaur> over and over ahain
17:20:18 <irene-knapp> the 100th foo looks like Foo (Succ a) =p
17:20:26 <Enigmagic> vrook: or Foo D100
17:20:41 <vrook> Enigmagic: that uses template haskell
17:20:46 <irene-knapp> what?  no
17:20:46 <Enigmagic> vrook: no it doesn't
17:20:58 <Enigmagic> vrook: import Data.TypeLevel (D100)
17:21:07 <irene-knapp> word to the wise, if you don't see a $(someFunction) there is no TH happening
17:21:29 <c_wraith> irene-knapp: actually, the $ is optional at the top level now.  I'm not sure *why*
17:21:34 <irene-knapp> really?  weird
17:21:38 <ddarius> irene-knapp: Newer versions of TH allow the splice notation to be omitted for top-level splices.
17:21:45 <irene-knapp> that's fascinating and slightly disturbing :)
17:21:48 <Enigmagic> Prelude Data.TypeLevel> :info D100
17:21:55 <Enigmagic> type D100 = (D1 :* D0) :* D0
17:22:00 <geekosaur> vrook doesn't want to write it out and doesn't want the compiler to write it out for em.  what does vrook want?  apparently, nothing but to whine
17:22:12 <irene-knapp> I would rather the effort implementing that had been invested into resolving the issues regarding typechecking and splicing each relying on the other having already been completed
17:23:00 <vrook> geekosaur: you aren't being serious. where did I say I don't want the compiler to write it out? Point it out.
17:23:10 <ddarius> irene-knapp: I don't think the "effort" put in "implementing" that would have made a noticeable difference to the problem to which you refer.
17:23:14 <geekosaur> vrook, you are not being serious
17:23:20 <irene-knapp> ddarius: that's fair enough, certainly, and probably true
17:23:34 <geekosaur> you are repating the same nonsense over and over and in response to anyone pointing out that it's nonsense you just repeat it again
17:23:37 <irene-knapp> ddarius: the problem I'm referencing is certainly much deeper
17:23:54 <geekosaur> and again and again
17:23:55 <vrook> Enigmagic: http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/Data-TypeLevel-Num-Aliases.html says template haskell
17:24:12 <geekosaur> and again and again
17:24:48 <vrook> geekosaur: where did I say I don't want the compiler to write it out? Point it out.
17:24:52 <Enigmagic> vrook: no template haskell is needed to use that package
17:25:05 <vrook> Enigmagic: upper right corner
17:25:11 <ddarius> There is an interesting conundrum with regards to Template Haskell.  On the one hand, explicit splice syntax is fugly.  On the other hand, implicit splicing leads to code that looks like pure code that isn't referentially transparent.
17:25:14 <Enigmagic> vrook: no template haskell is needed to use that package
17:25:26 <vrook> Enigmagic: OK, file a bug report then.
17:25:30 <irene-knapp> I think this is the point where we tell vrook that it's not our responsibility to prove he's not talking sense - it's his to prove he is, since he's the one asking for our time!
17:25:31 <geekosaur> vrook, that is what TH *does*
17:25:37 <Enigmagic> vrook: please do
17:25:46 <geekosaur> since you're severely allergic to TH, you don;t want the compiler to write it out for you
17:25:58 <geekosaur> so it's not at all clear *what* you want
17:26:02 <geekosaur> if anything at all
17:26:04 <toduro_> thanks to the #haskell crowd for (1) getting me past the roadblocks to building yesod and (2) good conversation I could read while it was building.
17:26:21 <irene-knapp> oh?  grats toduro
17:26:28 <vrook> geekosaur: that makes even less sense. why would you say I'm severely allergic to TH? Where did I say that? Point it out.
17:27:05 <vrook> Obviously no TH is preferred to TH where possible. That does not imply "severely allergic". You are getting emotional or something.
17:27:12 <irene-knapp> you keep asking people to point out where you said thing A or thing B.  the notion seems to be that you are being attacked.
17:27:19 <irene-knapp> and that you want some justification.
17:27:26 <monochrom> haha toduro_
17:27:27 <irene-knapp> people are not attacking you.
17:27:43 <irene-knapp> people are simply saying that they do not wish to help you, in light of your failure to communicate with them.
17:28:02 <irene-knapp> indeed, they are trying to be as helpful as they possibly can
17:28:09 <Enigmagic> vrook: the code is non-portable because the type-level package requires template haskell, that doesn't at all impact any users of the package
17:28:14 <Enigmagic> vrook: check the source: http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/src/Data-TypeLevel-Num-Aliases.html
17:28:14 <irene-knapp> by explaining, futilely, the nature of the breakdown in communication
17:28:17 <vrook> Enigmagic: how does one produce the token "D100" if not through template haskell or manually in code?
17:28:23 <irene-knapp> if they were attacking you, they would not go to the effort!
17:28:46 <irene-knapp> you, um, type the token in
17:28:46 <Enigmagic> vrook: the definition or the use of?
17:28:52 <irene-knapp> with your keyboard
17:28:54 <Enigmagic> using it doesn't require template haskell
17:29:07 <vrook> Enigmagic: "or manually in code"
17:29:15 <Enigmagic> they chose to use template haskell to generate the D100 symbol in the type-level package
17:29:24 <vrook> Enigmagic: that's what I'm saying.
17:29:27 <irene-knapp> are you asking how one converts an integer value to a type?  you can't - that would be a dependent typing.
17:29:31 <irene-knapp> -a
17:30:03 <irene-knapp> if you're doing this at the type level, in a Haskell-like system, you're doing it at the type level.  which means not at the value level.
17:30:11 <irene-knapp> you cannot go back and forth between types and values in Haskell.
17:30:12 <Enigmagic> vrook: ok, so sounds like you have a good understanding of where the D100 type comes from now
17:30:29 <Enigmagic> if you'd like something aside form the type alias, you can just construct it manually
17:30:40 <vrook> irene-knapp: I thought I explained that at the very beginning: "Is there a way to encode a natural number inside a type? I'm not talking about Data Nat = Zero | Succ Nat. That encodes naturals in data. I want something like Succ Zero in a type."
17:30:42 <dmwit> irene-knapp: I appreciate your point, but GADTs do get gallingly close to going back and forth between types and values.
17:30:47 <Enigmagic> by saying D1 :* D0 :* D0
17:30:53 <vrook> irene-knapp: you seem to be summarizing my point for me.
17:31:03 <irene-knapp> vrook: no.  you can encode it in a type just fine.
17:31:24 <irene-knapp> vrook: you cannot convert between a data encoding of it and a type encoding of it, because type encodings exist at compile-time and data encodings exist at runtime (to oversimplify a little)
17:31:34 <vrook> geez, of course
17:31:44 <irene-knapp> it's not of course.  Agda, for example, is a system in which that does not hold.
17:32:01 <Enigmagic> vrook: do the type-level Succ and Pred classes not work for your problem?
17:32:02 <irene-knapp> anyway, if that wasn't what you were stuck on, I return to being mystified as to what you were saying
17:32:15 <ddarius> In fact, in GHC 7.4, the data declaration implies a type level datakind if I understand correctly, so actually, "data Nat = Zero | Succ Nat" would be all you need.
17:32:48 <irene-knapp> ddarius: wait, really?  because that would be kind of awesome.  have you got a link explaining the feature? :D
17:32:59 <BMeph> Hint: "data" is short for "datatype"
17:33:08 <ddarius> @google simon peyton jones promoting
17:33:10 <lambdabot> http://research.microsoft.com/~simonpj/papers/ext-f
17:33:10 <lambdabot> Title: Simon Peyton Jones: papers
17:33:27 * irene-knapp goes to read :)
17:33:29 <irene-knapp> thanks!
17:33:39 <vrook> irene-knapp: c'mon, there's no way I could possibly have been referring to agda. This is the haskell IRC.
17:34:00 <irene-knapp> vrook: I thought that perhaps you were confused on the distinction
17:34:11 <vrook> ffs
17:34:14 <irene-knapp> vrook: I didn't think you thought Haskell was Agda, but I thought you might think it had some Agda-like properties which it does not
17:34:17 <irene-knapp> haha
17:34:19 <irene-knapp> after all that
17:34:23 <irene-knapp> THAT is what got him to leave?
17:34:27 <irene-knapp> well, at least he left voluntarily
17:34:38 <irene-knapp> and without cursing at me except in an abbreviation
17:35:17 <dmwit> I'm actually still a bit lost about what he wanted to do but couldn't.
17:35:21 <dmwit> honestly
17:35:29 <irene-knapp> me too
17:35:32 <Enigmagic> i think he's a bit lost too
17:35:33 <cmccann> I kept being tempted to join in that conversation
17:35:46 <cmccann> but I couldn't figure out how to ask what was being discussed without sounding like I was making fun of him
17:35:48 <irene-knapp> he kept saying something about how you can't write out the type constructor D1000
17:35:48 <Enigmagic> i have another 5 or so minutes to kill :P
17:35:53 <irene-knapp> except by either writing it out, or not writing it out
17:36:18 <irene-knapp> people were agreeing that indeed, the universe of possible actions is partitioned by any given action into actions which are that one, and actions which are not :)
17:36:27 <irene-knapp> and saying "what's your point"
17:36:34 <irene-knapp> and he was then repeating his question
17:36:34 * cmccann wonders if maybe he just wanted something like type-level numeric literals
17:36:48 <irene-knapp> I don't think so
17:36:49 <Enigmagic> i'd like GHC to support them, there is a ticket for it too
17:37:08 <irene-knapp> yes, I played with the branch that had them for a while about six months ago
17:37:19 <Enigmagic> i can't use a type-level number larger than D9 in one of my packages cuz it takes too long to compile if i do
17:37:21 <irene-knapp> at that time, you couldn't actually use them for anything because you couldn't infer things you would want to infer
17:37:54 <irene-knapp> for the record, edwardk has a nice package that represents them in hexadecimal.  I un-bit-rot-ified it for GHC 7.2ish.
17:38:04 <irene-knapp> it achieves better compilation speeds, though not stunning
17:38:16 <irene-knapp> it uses /scarily deep template haskell/ :)
17:38:18 <irene-knapp> three layers of it
17:38:43 <ddarius> cmccann: This is pretty typical of interactions with vrook.
17:39:03 <irene-knapp> I still ran into a problem where I couldn't do anything really useful with them, although due to limitations of TH rather than anything else
17:39:04 <dmwit> Oh, has vrook done this before?
17:39:10 <cmccann> ah. didn't know there was a recurring pattern here.
17:39:13 <Enigmagic> irene-knapp: i'm just a heavy user of the llvm-bindings, which use type-level a lot
17:39:14 <irene-knapp> ah, nor did I
17:39:20 <irene-knapp> Enigmatic: ah okay, fair enough then!
17:39:44 <Enigmagic> so i'm bound by the slow compiles of anything using LLVM's arrays or vectors :|
17:39:48 <irene-knapp> hm ugh
17:40:10 <irene-knapp> well, anyway, I definitely see the attraction of type-nats
17:41:34 <monochrom> 3 layers of TH is pretty Inception :)
17:41:39 <irene-knapp> it is, isn't it :)
17:41:51 <cmccann> C O M P I L A T I O N
17:41:53 <geekosaur> Omega, anyone? :)
17:41:54 <dmwit> As someone the other day said: nothing looks like type-level functions until you need them once.
17:42:05 <irene-knapp> indeed
17:42:36 <irene-knapp> I'm starting to understand the overlapping functionality of GADTs and type families now
17:42:40 <irene-knapp> not really fully there yet
17:42:41 <monochrom> "every time you go down one level, compilation speed slows down" :)
17:42:42 <irene-knapp> but on my way
17:42:45 <irene-knapp> haha
17:42:48 <cmccann> I'd still like to see support for term-level natural numbers, as revolutionary as that would be
17:42:52 <cmccann> monochrom, ahahahahaha
17:43:01 <ddarius> cmccann: Me too.
17:44:24 <cmccann> particularly galling is the absurdity that with RebindableSyntax, numeric literals are handled with a function called fromInteger, which is only ever applied to integers >= 0 in that case
17:44:59 <Cale> Well, of course ;)
17:45:03 <cmccann> but just appropriating that as "fromNatural" gives no way to exclude applying it to negative integers manually
17:45:09 <Cale> because there are no negative numeric literals after all
17:45:25 <cmccann> Cale, exactly, that's what "negate" is for
17:55:54 <Sgeo> Why is Leksah taking so long to find all the Haskell packages?
18:02:19 <The_Journey> say that I have modules inside of modules, so it would be like this: import Foo.Bar.Var, how can I make Foo.hs so that the user won't have to do import Foo.Bar.Var to use the functions inside Var? All the user has to do is import Foo and every submodules will be visible?
18:02:34 <elliott_> The_Journey: In Foo's export list, include "module Foo.Bar.Var".
18:02:44 <elliott_> (You'll have to "import Foo.Bar.Var" in Foo itself.)
18:02:56 <elliott_> i.e. module Foo ( ..., all the other exports, module Foo.Bar.Var ) where ... import Foo.Bar.Var ...
18:03:21 <monochrom> "Foo.Bar.Var" is not modules inside modules.
18:03:29 <The_Journey> elliott: I am trying in that and it is not working
18:03:43 <elliott> The_Journey: What error are you getting?
18:03:44 <lambdabot> elliott: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:03:52 <elliott> If you do that correctly it'll work.
18:04:11 <The_Journey> elliott: "blah blah" is not a visible field and not in scape errors
18:04:15 <The_Journey> *scope
18:04:29 <ddarius> clsmith: Consider you're given a function f :: (b :: Bool) -> if b then Int else String.  With that you could say something like 3 :: f True.  If you said 3 :: f (g 10) the compiler will check if g 10 = True.  Typically, the (=) used there is beta equality, i.e. it will reduce g 10 to normal form and check if that is syntactically equal to True.  If your language is Turing-complete, this approach would imply that type
18:04:29 <ddarius> checking is undecidable.  What happens for \g -> 3 :: f (g 10)?  It's clear g :: Int -> Bool.  The compiler can't show that g 10 = True, and so this is rejected, as well it should since there is no way to ensure g 10 does in fact return True.
18:04:30 <elliott> The_Journey: Well, that has nothing to do with re-exporting a module; there must be some other problem with your code.
18:04:52 <The_Journey> elliott: if I do import Foo.Bar.Var explicitly the compiler doesn't complain
18:04:58 <monochrom> then it is Foo.Bar.Var itself not exporting enough
18:05:43 <The_Journey> can I export data constructors?
18:06:13 <dmwit> Of course.
18:06:26 <elliott> The_Journey: Are you turning
18:06:27 <monochrom> yes. module D(T(C)) where data T = C
18:06:28 <elliott> module Foo where ...
18:06:29 <elliott> into
18:06:33 <elliott> module Foo (module Foo.Bar.Var) where ...
18:06:34 <elliott> ?
18:06:38 <mm_freak> The_Journey: (Bool(True, False)) or (Bool(..))
18:06:41 <elliott> Because, with an explicit export list, you must list *everything* you are exporting.
18:07:32 <mm_freak> elliott: module Foo (module Foo)
18:08:03 <elliott> mm_freak: Yes, that works too... but is a rather confusing introduction to explicit export lists :P
18:08:41 <mm_freak> just for the case you want an explicit export list, but want to export everything anyway
18:09:00 <mm_freak> which happens when you want to export everything plus some imported modules
18:09:12 <ddarius> clsmith: What we can do about that is write the function: ifTrue :: Bool -> ((b :: Bool) -> if b then Int else String) -> Maybe Int; ifTrue True f = Just (f True); ifTrue False _ = Nothing.  And then write ifTrue (g 10) f.  Note that this approach can be used for any boolean, including ones derived from user input.  There are no types at run-time here or run-time type checking.  There is a run-time check, but it is not
18:09:12 <ddarius>  a type check and it is necessary because if g really were a function of user-input, there is no way of knowing beforehand that g 10 is True.
18:10:21 <int80_h> I want to install a project that's not part of hackage yet, 0.10 Yesod. How can I minimize risk to my current installation?
18:10:40 <geekosaur> cabal-dev or virthualenv?
18:11:04 <elliott> int80_h: Didn't they make cabal-src for that?
18:11:15 <int80_h> elliott: yes they did
18:11:23 <elliott> I suggest cabal-src, then :P
18:11:29 <elliott> Oh, "current installation" of Yesod, I guess.
18:11:35 <int80_h> yes
18:11:38 <elliott> Yeah, cabal-dev sounds good. You can add non-Hackage sources.
18:11:50 <elliott> cabal-dev add-source /path/to/yesod-0.10, I think.
18:12:20 <int80_h> and how is that different from cabal, I've never used it
18:12:49 <int80_h> But I am going to try to add an authentication extension for LDAP, which is why I want to download it in the first place.
18:12:49 <ddarius> clsmith: The ideas in ifTrue can be readily generalized to a richer types and can be captured by the notion of pattern matching.  Indeed, pattern matching usually has a much more fundamental role in dependently typed languages than it does in Haskell for this reason.  The "trick" in ifTrue can be used any time you need to recover type information, not just for dependent typse.
18:13:26 <elliott> int80_h: cabal-dev maintains an isolated package database, basically.
18:13:43 <elliott> int80_h: So every package is installed locally to the project you're working on.
18:13:48 <elliott> (apart from global packages)
18:14:22 <parcs`> mm_freak: does netwire have a wire that would help me clamp the output of another wire in between a range?
18:14:50 <mm_freak> parcs`: arr (min maxVal . max minVal)?
18:16:17 <mm_freak> min maxVal . max minVal ^<< someWire
18:16:48 <mm_freak> or use fmap, which is what i prefer nowadays
18:17:03 <mm_freak> fmap (min maxVal . max minVal) someWire
18:20:41 <parcs`> mm_freak: that won't work.. imagine 'foo >>> integral 0 >>> arr (min maxVal . max minVal)' and the integral wire overflows to (maxVal + 20) but gets clamped to maxVal. on the next step, if 'foo' produces '-10' then the integral will be (given a delta of 1s) maxVal + 10, which will get clamped to maxVal. i want the next step to produce maxVal - 10
18:21:12 <parcs`> so i think i need a wire transformer
18:22:37 <mm_freak> parcs`: the way i understand it, the range will be given by foo?
18:23:43 <parcs`> mm_freak: no, foo will produce a double that get fed into integral. the range will be independently specified
18:24:03 <mm_freak> parcs`: then i'm not sure i understand the problem
18:24:16 <Sgeo> null :: forall a. PSQ a -> Bool
18:24:18 <Sgeo> What is PSQ?
18:24:27 <Sgeo> @hoogle PSQ a -> Bool
18:24:28 <lambdabot> Warning: Unknown type PSQ
18:24:28 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
18:24:28 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
18:26:25 <ddarius> Sgeo: Probably a priority search queue.
18:26:40 <geekosaur> I believe it's a priority search queue, availab;e on hackage
18:30:06 <parcs`> mm_freak: the internal value of the 'integral' wire is not clamped, so subsequent steps will not use the clamped value, but rather the unclamped internal value.
18:31:25 <mm_freak> parcs`: well, you can either clamp the input or the output…  if you want to clamp the internal value of 'integral', you actually want something that is not 'integral'
18:31:50 <mm_freak> parcs`: so you will need a wire transformer
18:31:57 <parcs`> a wire transformer wouldn't help here?
18:32:17 <parcs`> if the internal value of the integral wire is 250, and i have magically clamped it to 200, i'd like to get 150 back if i feed it (-50) (assuming a delta of 1s)
18:32:22 <mm_freak> actually, no, it won't really help there
18:33:03 <ddarius> I don't think this is possible to do "generically."
18:33:10 <mm_freak> yeah, i understood the problem now, but i think you can't use 'integral' at all
18:33:37 <mm_freak> note how the result of 'integral' already applies an argument that is not under control of the wire transformer
18:38:36 <mm_freak> parcs`: i think you can easily prove this in the equivalent local state function representation:  data Wire e (>~) a b = forall s. Wire s ((a, s) >~ (Either e b, s))
18:38:48 <mm_freak> you basically want to clamp the 's', which is impossible
18:41:44 <parcs`> i don't quite follow yet, but i'll take your word for it :P
18:43:07 <mm_freak> parcs`: the 's' value corresponds to the argument of 'integral'
18:43:46 <parcs`> yeah, i see now
18:44:07 <parcs`> so what are my options?\
18:46:04 <mm_freak> write your own version of 'integral'
18:46:15 <mm_freak> perhaps with a clamping function
18:46:37 <mm_freak> myIntegral (max minVal . min maxVal) 0
18:47:20 <parcs`> mm_freak: did you ever come across this problem?
18:48:14 <parcs`> because if not i must be doing something wrong :P
18:50:24 <mm_freak> parcs`: never come across it, but that doesn't mean you're doing something wrong, even though i don't understand why you would want to clamp the internal state of integral =)
18:51:46 <mm_freak> parcs`: i'd say what you want is just not the integral wire, but something application-specific
18:52:27 <xplat> well, basically it's like a robot whose velocity is dependent on a signal, except there are walls
18:52:38 * ddarius agrees with mm_freak.
18:52:47 <parcs`> what xplat said
18:53:37 <ddarius> It's a reasonable thing to want.
18:54:07 <xplat> or like a bucket that you flow water in and out of under control of a signal
18:54:13 <roconnor__> @seen sjoerd
18:54:13 <lambdabot> Unknown command, try @list
18:54:24 <mm_freak> i see
18:54:25 <roconnor__> preflex: seen sjoerd
18:54:25 <preflex>  Sorry, I haven't seen sjoerd
18:54:25 <xplat> and if the bucket is full, *splash*
18:54:29 <roconnor__> preflex: seen sjoerdv
18:54:30 <preflex>  Sorry, I haven't seen sjoerdv
18:54:41 <mm_freak> well, if it's common enough, i'll include it in the next release
18:55:41 <parcs`> what about 'proc v -> do { a <- integral 0 -< v; if a > maxPos then integral maxPos -< 0 else if a < minPos then integral minPos -< 0 else returnA -< a }'
18:56:40 <parcs`> that would only work for the first time it overflows i think
18:57:03 <ddarius> You would need recursion.
18:57:10 <mm_freak> parcs`: well, you can write an integral-aware wire transformer that switches, but i'd consider that an ugly solution
18:57:58 <ddarius> However, if you are only interested in this integral thing, rather than "clamping" arbitrary wires in this way, then it should be doable.
18:58:17 <mm_freak> whenever the direction is switched, switch to integral maxVal or integral minVal
18:58:25 <mm_freak> but personally i'd just write a custom integral wire
18:59:50 <Sgeo> Hmm
19:00:09 <Sgeo> I can read mempty = Event $ \_ ->  return (return ()) better than mempty = Event . const . return $ return ()
19:00:19 * ddarius agrees with mm_freak.
19:01:20 <mm_freak> Sgeo: i could read the latter better
19:01:35 <mm_freak> Sgeo: once you get used to it, it's actually easier
19:07:27 <Sgeo> Maybe I'll like Yi
19:08:41 <ddarius> Maybe you should learn to be at harmony with the world as it is.
19:12:19 <Sgeo> Hmm?
19:14:25 <penelope> Yi could stand with a bit more documentation...
19:15:01 <penelope> a debian package wouldn't hurt either...
19:23:58 <parcs`> mm_freak: by the way, why do you provide an identity wire when there's already returnA?
19:27:01 <Sgeo> What's a cua keymap?
19:29:12 <penelope> CUA == IBM's Common User Access
19:29:23 <Sgeo> ?
19:32:03 <penelope> e.g. paste is ctrl + ins
19:33:12 <penelope> CUA was an attempt back from the days of WordStar to unify keyboard control combinations...
19:34:24 <geekosaur> after wordstar.  the notion was that windows, os/2, and osf/motif would all use similar keybindings.
19:34:42 <penelope> heh.
19:35:49 <penelope> There can only be one. Emacs will outlive them all.
19:42:33 <DanBurton> quick question, is there a clean way to take a ByteString, and drop everything through the *last* space?
19:45:49 <Sgeo> Is there a way to turn a CWString into a Text?
19:46:00 <Sgeo> Without turning it first into a String and then from there Text?
19:58:04 <ddarius> I wonder if the endomorphism monoid can be characterized with a universal property.
20:18:56 <hpaste_> DanBurton pasted “Simple ppm to pgm” at http://hpaste.org/56646
20:20:08 <DanBurton> rolling my own ppm to pgm converter, but the file it produces is completely wrong for some reason
20:20:45 <DanBurton> is it bad to convert from ByteString to Char to Ints to Char and then putChar?
20:23:05 <DanBurton> *809 crickets chirp*
20:27:42 <ddarius> chr and ord aren't what you want anyway.
20:28:48 <DanBurton> ddarius: how can I read 8 bits at a time as an unsigned ints?
20:29:05 <ddarius> DanBurton: That's not the ppm format.
20:29:51 <DanBurton> ddarius: isn't it? the P6 version, anyways?
20:30:38 <ddarius> No.
20:33:59 <ddarius> DanBurton: What you're doing would expect a binary format and produce a binary format.  None of the PNM formats are binary.
20:37:05 <penelope> What's the equivalent of C-l in Yi?
20:45:37 <DanBurton> ddarius: according to the specs I have at http://morse.cs.byu.edu/450/resources/ppm.man.txt it says they are binary
20:45:45 <DanBurton> see the bottom
20:46:10 <nyingen> so the haskell binding for FFTW operates on CArrays
20:46:27 <Sgeo> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
20:46:28 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
20:46:41 <nyingen> if my data is in Vectors, is it easy to convert between the two? or is that a losing proposition in terms of efficiency?
20:47:17 * Sgeo wonders who came up with that
20:49:19 <ddarius> DanBurton: Consider using documentation that is not over 10 years old.
20:49:31 <ddarius> For example, type "man ppm" into your shell.
20:50:01 <DanBurton> has the standard changed?
20:50:34 <ddarius> It has changed somewhat, though I guess that should still be valid.
20:51:11 <ddarius> Anyway, what is your program doing "wrong."
20:52:14 <DanBurton> the output looks nothing like the original .ppm
20:52:23 <DanBurton> it looks like grey lines
20:53:46 <ddarius> Is your input ppm have a max color value of 255 or less?  One of the things that changed over the last decade... well over a decade ago, was that the PPM format could have components that were greater than 255 and thus were multi-byte.
20:54:47 <DanBurton> the max val on my ppm is 255
20:55:10 <ddarius> Also, there only need be one newline character.
20:55:23 <DanBurton> hrm?
20:55:28 <ddarius> Actually, I take that back.  There need not be any newline characters.
20:55:45 <DanBurton> sure, it just needs a single whitespace after the maxval
20:55:54 <DanBurton> putStrLn only puts \n at the end on linux, right?
20:56:37 <ddarius> I'm more worried about the input not meeting your expectations than the output.
20:57:34 <ddarius> You should be able to quickly make a small pnm image by hand and see what it outputs.
20:58:32 <jamil_1> hi all
20:58:48 <jamil_1> :type funName show type of the funtion in GHCi
20:59:08 <jamil_1> is there a way to show definition of the function in GHCi ?
21:00:58 <jamil_1> nevermind
21:01:00 <jamil_1> http://stackoverflow.com/questions/5786372/function-definition-in-haskell-ghci
21:01:41 <Cale> jamil_1: The source code for most things won't actually be available
21:01:44 <dp_wiz> ?src fix
21:01:44 <lambdabot> fix f = let x = f x in x
21:02:00 <Cale> jamil_1: because the installed libraries are already compiled
21:02:07 <jamil_1> Cale: right
21:02:25 <dp_wiz> hoogle rocks
21:04:21 * ddarius is underwhelmed by stackoverflow.
21:06:36 * DanBurton enjoys StackOverflow
21:25:48 <xil> hi everyone. I was wondering if someone would mind helping me understand laziness. I read up on it from the wiki book so I think I understand the technical side of it, but I'm not sure how to use it to my advantage. I have this article, I don't recall the name but it's that one with a bunch of examples and such, but it's quite dense and I'm tired. Was hoping for some help here
21:28:55 <ivanm> xil: the way I use laziness is this:
21:29:09 <ivanm> I have functions that in essence create a very long stream of values
21:29:23 <ivanm> but since I only consume them one at a time, I don't need to worry about the fact that it *is* so long
21:29:47 <lispy> and that's why we call ivanm a Functorist.
21:30:00 <ivanm> lispy: you do? :o
21:30:02 <ivanm> since when? :o
21:30:31 <lispy> ivanm: or an fmapper if I'm feeling informal :)
21:30:35 <lispy> ivanm: since now :)
21:30:39 <ivanm> heh
21:30:47 <ivanm> why an fmapper?
21:30:53 <ivanm> I tend to use liftM more than fmap :p
21:30:57 <xil> so I understand how laziness prevents unnecessary processing of list elements, but how exactly are you using that to increase efficiency?
21:30:57 <lispy> heh, good to know
21:31:03 <ivanm> and i'm not a fan of Caleskell
21:31:16 <ivanm> xil: it increases efficiency from a programmatic point of view
21:31:21 <lispy> xil: efficiency of the programmer or the program?  The former is often more important.
21:31:23 <ivanm> where I don't have to think about buffering, etc.
21:31:33 <ivanm> xil: laziness also allows you to tie the knot
21:31:34 <xil> no not how does it increase efficiency, I'm saying how do you use it more precisely
21:31:37 <ivanm> @google tying the knot haskell
21:31:39 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
21:31:39 <lambdabot> Title: Tying the Knot - HaskellWiki
21:32:17 <xil> right, I get that stuff
21:33:32 <xil> I guess where I'm stuck is that I'm really used to thinking in...don't know what you call Java and those languages, but like that
21:33:54 <xil> and even though I know laziness know, I don't really know how to think that way I guess
21:33:57 <ivanm> xil: consider this:
21:34:05 <xil> so it's really a issue of programming practices in Haskell
21:34:08 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:34:09 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
21:34:16 <xil> yeah love that
21:34:19 <ivanm> ^^ uses laziness to compute an infinite stream of fibonacci numbers
21:34:25 <xil> yes, and I understand that
21:34:31 <ivanm> xil: yes, but with quite large impacts on programmatic style
21:35:16 <xil> okay can I pose an example problem and maybe you can propose a strategy for dealing with it properly in haskell?
21:35:37 <ivanm> well, I would, but I'm about to head off for dinner :p
21:36:01 <xil> actually I just realized this is a bad example because it's essentially a sparse graph and there's probably a module for that isn't there
21:37:28 <lispy> xil: if you need a graph library try out fgl, as it happens ivanm is the maintainer
21:37:39 <xil> lol, convenient
21:37:51 <ivanm> lispy: sure, dump it on me whilst I won't be here to defend myself :p
21:37:59 * ivanm has plans for graphs... big plans... just no time :(
21:38:22 <ivanm> but sparsity isn't that big a problem, as FGL uses a Map rather than an array anyway
21:38:27 <lispy> ivanm: have to get your laptop working reliably first :)
21:38:41 <ivanm> lispy: yup, will be buying compressed air whilst getting dinner
21:39:02 <lispy> ivanm: if you're brave, open it up for best results
21:39:07 <ivanm> luckily there's an office shop that'll be open (since Ballarat is a big country town)
21:39:15 <ivanm> lispy: not sure if I'm brave enough here, due to lack of tools
21:39:25 <lispy> I hear you.
21:39:39 * lispy is off for sleep
21:39:42 <ivanm> they're all at home, 8 hours drive away (and I'm not planning on going back for another week)
21:39:47 * ivanm -> food
21:40:11 <xil> well maybe a graph isn't the way to go about this. I'm writing a neural network. All of the actual information about the network is stored in the connections, so those are the most important bits and I'm pretty confident it's best served having them in a list. But when I need to simulate the network how deal with the nodes?
21:40:23 <ivanm> xil: there are neural network libraries on hackage
21:40:46 <ivanm> anyway, gotta go
21:40:49 <xil> ivanm: I hadn't looked, so I should, but I'm pretty sure I'll need to do this from scratch anyway. But I'll check them out
21:47:48 <teneen> In Data.Vector.Generic the description of the "modify" function says "Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise"
21:48:02 <teneen> How can I know when will the operation be in-place or not?
21:48:09 <teneen> http://hackage.haskell.org/packages/archive/vector/latest/doc/html/Data-Vector-Generic.html#v:modify
21:49:20 <teneen> what does it actually mean by "safe" ?
21:54:58 <drdo> How can i tell cabal where to find packages?
21:55:46 <drdo> ah found it in .cabal/config i think
21:57:59 <drdo> nop, didn't, local-repo apparently wants a package list
22:07:47 <ddarius> teneen: modify is defined as cloning (i.e. copying) its argument and then performing an in-place modification.  Vector uses a fusion-like transformation to eliminate the clones, primarily clone . new = id.  This fusion rule should capture any case where you are modifying a freshly allocated array.
22:26:51 <skirmish> @pl \p xs->not $ Data.List.isPrefixOf p xs
22:26:52 <lambdabot> (not .) . Data.List.isPrefixOf
22:29:06 <teneen> ddarius: what is a freshly allocated array? for example if I had  mutable vector in the ST monad and I did some operations on it and then I called "modify",  will in operate in-place?
22:32:40 <skirmish> @pl \p xs@(x : xs') -> if p xs then let (ys, zs) = span' p xs' in (x : ys, zs) else ([], xs)
22:32:40 <lambdabot> (line 1, column 6):
22:32:40 <lambdabot> unexpected "@"
22:32:40 <lambdabot> expecting pattern or "->"
22:45:44 <teneen> ddarius: is "new . clone" treated the same as "clone . new", I can see "new . clone" is the one in the source
22:57:48 <xil> hi. Is there an infinity for Ints? I have a pair of bounds that I need to compare a positive (or 0) Int to and I'd like the upper bound to be able to be something such that 'myInt < upperBound == True' for all Ints myInt. Is there something like that?
22:58:59 <jdavis> If I have a FunPtr from an FFI module, can I dereference it to get the normal function?
22:59:55 <tikhonjelvis> What about just using maxBound (or whatever it's called)?
23:00:18 <jeltsch> tikhonjelvis: Well, maxBound is still a (finite) integer, not an infinity.
23:00:25 <jdavis> That is, can I take a FunPtr (Ptr Sometype -> IO ()) and return a Ptr Sometpye -> IO () ?
23:00:29 <jeltsch> So using it is misleading if you really mean ∞.
23:00:45 <tikhonjelvis> jeltsch: Yes, but I don't think an "infinite" Int exists, so it's the next best thing.
23:00:51 <tikhonjelvis> I could be completely delusional, of course.
23:01:27 <jeltsch> tikhonjelvis: xil wants every integer to be less than this infinity, but maxBound is an integer which is not less than maxBound.
23:01:44 <jeltsch> You are right, an infinite integer doesn’t exist. So we should just not call it an integer.
23:01:51 <xil> to be fair, now that I think about it really, myInt is very unlikely to ever be close to the maxBound for Int
23:02:02 <tikhonjelvis> I think the best compromise is <= maxBound.
23:02:43 <jeltsch> xil: Okay, this is a pragmatic argument. But I’d prefer a solution that really expresses what you intend. It’s nicer, not misleading, and might avoid problems in the end.
23:02:47 <xil> it's a population size and I doubt the computer could handle simulating such a large population
23:03:04 <jeltsch> I would just define a type for integers plus infinity.
23:03:27 <jeltsch> If it’s a population size, I’d even prefer naturals (no negative numbers).
23:03:33 <xil> oh actually, I just realized that it is more convenient to use <= than <, in which case maxBound would absolutely work
23:03:40 <xil> is there a natural type?
23:03:46 <xil> I wasn't aware of an unsigned int
23:03:57 <jeltsch> Unfortunately there isn’t.
23:04:06 <tikhonjelvis> Is there some easy way to define one yourself?
23:04:11 <jeltsch> I really don’t understand why there is still no Natural, since it is often what you actually want.
23:04:23 <tikhonjelvis> Yeah.
23:04:33 <tikhonjelvis> I remember being annoyed at that in *Java*!
23:04:39 <The_Journey> hi, I'm writing a cabal install file. My program depends on the C-library liblbfgs, how can I make sure that the user must have the library as a prerequisite to install the program?
23:05:06 <jeltsch> xil, tikhonjelvis: Wait a moment, I’m coding.
23:05:08 <silver> there is no unsigned in java
23:05:19 <tikhonjelvis> jeltsch: Cool, no worries.
23:05:22 <silver> for simplicty lol
23:07:26 <mm_freak> parcs`: 'identity' is faster than 'returnA'
23:07:38 <xil> silver: there is an argument for simplicity, but I would argue that there are many cases where it complicates things, because it would be good to have overflow start again from 0 not -maxBound
23:07:46 <xil> or where the extra bit is handy
23:07:57 <mm_freak> parcs`: correction:  it used to be faster
23:08:16 <tikhonjelvis> More pertinently, it makes code that uses them clearer and more robust.
23:08:33 <tikhonjelvis> You wouldn't have to check nobody passed you a negative number.
23:08:36 <xil> tikhonjelvis: still talking about unsigned?
23:08:40 <xil> right
23:08:42 <tikhonjelvis> yeah
23:08:47 <tikhonjelvis> I sometimes have a one-track mind
23:09:21 <xil> no I'm still on topic too, but whenever someone says something in the middle of a conversation, when someone replies I never know to whom they did
23:09:36 <xil> that sentence is all kinds of weird
23:10:02 <tikhonjelvis> Its syntax represents your confusion :)
23:10:09 <xil> haha
23:10:26 <tikhonjelvis> ...and that is how I got through literature without reading half the books.
23:11:14 <xil> lol. But yeah I see the benefit of not having unsigned and other types, but I like them
23:11:15 <silver> lol
23:11:27 <bobry> can somebody please explain to me why Aeson forces the value before encoding it? (or at least it seems like it does) https://gist.github.com/68f9c36696cc647bbc8a
23:11:39 <hpaste_> “Wolfgang Jeltsch” pasted “Data.Natural” at http://hpaste.org/56654
23:12:02 <jeltsch> xil, tikhonjelvis: I found this on my harddisk.
23:12:14 <nyingen> how do I use CArray? I have some data in a Vector of Double that I need to put into CArray
23:12:17 <jeltsch> It doesn’t provide an instance of Num yet, but this can be added.
23:12:21 <jeltsch> Unfortu
23:12:54 <jeltsch> Unfortunately, negate doesn’t really make sense for Natural, so it has to quit with a runtime error if the argument isn’t 0.
23:13:10 <xil> okay I have what I think is a great question. What in the hell is newtype? I've looked for the answer many times and just can't figure it out
23:13:32 <tikhonjelvis> It lets you create a new type from an old one with almost no overhead.
23:13:40 <jeltsch> It should be described in most Haskell tutorials, isn’t it?
23:13:42 <xil> I thought that was 'type'
23:13:45 <tikhonjelvis> Ah
23:13:53 <tikhonjelvis> Type just creates a synonym
23:13:54 <xil> I use 'data' and 'type' all the time
23:14:00 <tikhonjelvis> Netype is like data
23:14:18 <jeltsch> But it’s semantically different wrt. undefined values.
23:14:19 <tikhonjelvis> except it can only have one constructor, which can only have one argument
23:14:27 <jeltsch> And it’s implemented more efficiently.
23:14:49 <jeltsch> Say you write this: newtype T = T S
23:14:55 <tikhonjelvis> Basically, it's like type except it creates a *distinct* type.
23:15:01 <jeltsch> T is like S then
23:15:09 <jeltsch> Has the same values, so to say.
23:15:14 <xil> so it's much more efficient if I only need one constructor, than using data
23:15:19 <jeltsch> But is still considered a different type.
23:15:28 <jeltsch> Yes.
23:15:36 <jeltsch> But it’s also different semantically.
23:15:48 <tikhonjelvis> For example, you could have something like newtype Size = Size Integer
23:15:56 <jeltsch> In the above example, T undefined = undefined.
23:16:12 <jeltsch> But if you used data, then T undefined would be “more defined” than a pure undefined.
23:16:40 <jeltsch> Matching T undefined against the pattern T _ would succeed, matching undefined against it would fail.
23:17:00 <xil> well in that example tikhonjelvis just gave, would I be able to use Size in place of Integer anywhere I want but just not vice versa? Or no?
23:17:20 <tikhonjelvis> No, you wouldn't be able to use it in place of Integer.
23:18:12 <tikhonjelvis> Also, it wouldn't be an instance of any of the classes of Integer, unless you added them yourself.
23:18:56 <xil> so what exactly is the difference from data
23:19:16 <tikhonjelvis> It's more efficient and there's the undefined stuff jeltsch was explaining.
23:19:23 <xil> yeah I get that, but I mean
23:19:27 <xil> how is it more efficient?
23:19:47 <tikhonjelvis> I think the difference is that data creates an extra level of indirection.
23:20:12 <tikhonjelvis> I remember seeing a nice diagram about it somewhere...
23:20:29 <jeltsch> The implementation is actually up to the compiler, but it’s typically like this:
23:20:36 <xil> well I guess what's important for me is practice. When should I use it and when should I use data?
23:20:43 <xil> oh go on
23:21:08 <jeltsch> With newtype the new type is represented exactly like the old type. So the representation of Size would be like the representation of Integer.
23:21:55 <xil> oh wait
23:22:08 <xil> so with newtype I have to specify a single type after the single constructor?
23:22:21 <jeltsch> With data, you would have a data item that either represents an unevaluated Size value or that tells you that the constructor is Size. In the latter case, there would be a pointer to the actual Integer value.
23:22:21 <tikhonjelvis> I think so, yeah
23:22:22 <xil> I can't specify something like newtype T = T (Int,Int)
23:22:36 <ski> xil : you can use `newtype' when you would have used `type', but want to make it abstract, or want to not have the same instances
23:22:55 <ski> `newtype T = T (Int,Int)' is fine
23:23:08 <jeltsch> xil: You can do this, because the pair of type (Int,Int) is a single value.
23:23:09 <xil> ski: why not just use data? Just the efficiency and undefined stuff?
23:23:21 <jeltsch> You just can’t say this: newtype T = T Int Int
23:23:31 <tikhonjelvis> I think newtype also makes your intentions clearer.
23:23:48 <jeltsch> But data T = T Int Int is equivalent to newtype T = T (Int,Int)
23:24:01 <xil> in power
23:24:06 <xil> but okay, I'm getting the difference
23:24:37 <xil> but I'm still not sure why it would really matter using newtype as opposed to data, unless efficiency really really matters, right?
23:24:56 <jeltsch> Actually, the syntax for newtype is misleading, in my opinion. The data constructor (T, Size, …) suggests a level of indirection, which actually isn’t there.
23:25:06 <jeltsch> xil: Semantics also matter. :-)
23:25:28 <jeltsch> I take newtype if the newtype is intended to be “the same” as the old type or a restriction of it.
23:26:02 <jeltsch> So if I define Natural in terms of Integer, I take newtype, because a natural is just a special integer and thus, should be represented like an integer.
23:26:38 <jeltsch> If you have only one data constructor, which has one field, there is usually no good reason to use data.
23:27:00 <xil> okay, that makes sense
23:27:06 <jeltsch> By the way, I found this: http://hackage.haskell.org/package/naturals
23:27:39 <ski> jeltsch : so you'd prefer "Restricted type synonyms" <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> ?
23:28:26 <jeltsch> Unfortunately, it has a special value for “indeterminate” naturals, which are not really naturals. It should better signal an error instead returning “indeterminate naturals”, in my opinion.
23:28:46 <ski> jeltsch : "If you have only one data constructor, which has one field, there is usually no good reason to use data." -- unless that just "happened to be the case", and you expect that in the future you possibly will have more arguments and/or more constructors
23:29:57 <ski> "The Natural module attempts to provide a representation of natural numbers (non-positive integers) ..." -- hrmm
23:29:57 <jeltsch> ski: wrt. restricted type synonyms: I didn’t know about these, but I was thinking of something similar for quite some time. Interesting feature.
23:30:19 <jeltsch> What’s the problem?
23:30:24 <ski> jeltsch : you can do basically the same thing in the MLs, using the module system
23:30:49 <ski> (i.e., you can declare a `datatype' inside a module, and only export it as an abstract `type')
23:31:08 <ski> problem ?
23:31:25 <ski> oh .. see "natural numbers (non-positive integers)"
23:32:11 <jeltsch> Ah. :-D  Funny.
23:33:10 <ski> hm, i don't think i like this `indeterm :: Natural' thing
23:33:41 <ski> better would probaably be to throw an error, or to make the subtraction truncating
23:34:03 <ski> (or even better, don't make it an instance of `Num', instead using some alternate prelude classes)
23:50:46 <mm_freak> the types "data T = T Int Int" and "newtype T = T (Int, Int)" are fully isomorphic, so in the newtype version the layer of indirection /is/ there
23:51:23 <tikhonjelvis> I think the layer of indirection is the tuple constructor (is that what it is?).
23:51:28 <mm_freak> exactly
23:51:40 <mm_freak> you can have T (undefined, undefined), which is different from T undefined
23:53:26 <Blkt> good morning everyone
23:55:15 <mm_freak> good morning
