00:01:51 <mjrosenb> Twey: pretty sure lambdabot's is shorter :-p
00:02:15 <Twey> But uglier :Ã¾
00:03:06 <Sgeo> :t last
00:03:07 <lambdabot> forall a. [a] -> a
00:03:12 <Sgeo> :t rest
00:03:13 <lambdabot> Not in scope: `rest'
00:03:16 <Sgeo> :t tail
00:03:17 <lambdabot> forall a. [a] -> [a]
00:03:25 <mauke> :t first
00:03:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
00:03:28 <alistra> tail []
00:03:31 <alistra> > tail []
00:03:32 <lambdabot>   *Exception: Prelude.tail: empty list
00:03:36 <mauke> > drop 1 []
00:03:37 <lambdabot>   []
00:03:45 <alistra> :(
00:04:24 <alistra> > second (+5) (1,2)
00:04:24 <lambdabot>   (1,7)
00:04:46 <alistra> i only know about second and first because hlint suggests them
00:04:47 <alistra> for
00:05:06 <alistra> (\(a,b) -> (a, f b))
00:05:08 <mauke> > fmap (+5) (1,2)
00:05:09 <lambdabot>   (1,7)
00:05:39 <alistra> > fmap (+4) (Left 4)
00:05:39 <lambdabot>   Left 4
00:06:34 <alistra> > fmap (+4) (Right 4)
00:06:34 <lambdabot>   Right 8
00:06:59 <mauke> > 4 . Left 4
00:07:03 <lambdabot>   mueval-core: Time limit exceeded
00:07:20 <mauke> > 4 . Left 4
00:07:23 <alistra> > 4 . 5
00:07:23 <lambdabot>   No instance for (GHC.Show.Show (f b))
00:07:24 <lambdabot>    arising from a use of `M5370395093...
00:07:25 <lambdabot>   mueval-core: Time limit exceeded
00:07:29 <mauke> hwat
00:07:44 <alistra> lambdabot's haskell is mad
00:07:55 <mauke> umad?
00:08:12 <alistra> trollface.png
00:08:37 <mauke> > 4 . Left
00:08:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
00:08:38 <lambdabot>    arising from a use of `...
00:08:43 <mauke> > 4 . Left 4
00:08:45 <lambdabot>   Left 4
00:08:50 <mauke> there we go
00:08:50 <alistra> what
00:09:04 <alistra> > 4 . Left 4
00:09:05 <lambdabot>   Left 4
00:09:13 <alistra> > 4 . Left 5
00:09:14 <lambdabot>   Left 5
00:09:18 <Sgeo> > rest []
00:09:20 <lambdabot>   Not in scope: `rest'
00:09:22 <alistra> > 4 . Right 5
00:09:23 <lambdabot>   Right 4
00:09:24 <Sgeo> > tail []
00:09:26 <lambdabot>   *Exception: Prelude.tail: empty list
00:09:27 <alistra> hahaha
00:09:28 <Sgeo> Boo
00:09:33 <alistra> i ain't even mad
00:09:42 <mauke> Sgeo: scroll up
00:09:51 <Sgeo> Ooh, ty
00:09:57 <Sgeo> Although I don't need it anymore
00:10:09 <Sgeo> I was trying to write an ill-conceived oneliner to show off to a C++ user
00:10:11 <Sgeo> >.>
00:10:33 <rwbarton> @let moar = drop 1
00:10:34 <lambdabot>  Defined.
00:10:54 <mauke> > inRange 2 (1, 5)
00:10:55 <lambdabot>   False
00:11:23 <Sgeo> replaceRN s = [c | let fs = zip s (tail s), let fixedTups = map (\(f, s) -> if s == '\n' then if f == '\r' then ('\x80', '\x7F') else ('\x80', s) else (f, s)) fs, c <-map fst fixedTups]
00:11:34 <Sgeo> That doesn't even work properly
00:12:10 <mauke> what does it do?
00:12:36 <Sgeo> Supposed to find \n in a string and replace it with another character, and if there's an \r before the \n replace that also
00:12:50 <alistra> crlf?
00:13:14 <Sgeo> Yes, but freestanding \r are allowed to be left alone
00:13:24 <Sgeo> Freestanding \n are not
00:13:26 <mauke> I'd go with manual recursion
00:13:29 <mauke> and/or perl
00:13:38 <mauke> s/\r?\n/whatever/g
00:13:42 <alistra> well creating a pair list
00:14:10 <alistra> isn't probably the solution with the smallest memory footprint
00:14:29 <mauke> meh, it's all ok if it streams well
00:14:56 <alistra> also
00:15:12 <alistra> > zip [1..10] (tail [1..10])
00:15:13 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
00:15:23 <alistra> > map fst $ zip [1..10] (tail [1..10])
00:15:24 <lambdabot>   [1,2,3,4,5,6,7,8,9]
00:15:33 <alistra> you lose the trailing char
00:15:40 <alistra> i think
00:17:12 <alistra> also the list compreh seems a bit redundant
00:19:38 <dropdrive> @pl \f (a,b) -> (a, fb)
00:19:38 <lambdabot> const (flip (,) fb . fst)
00:19:41 <dropdrive> @pl \f (a,b) -> (a, f b)
00:19:41 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
00:20:04 <alistra> @unpl second
00:20:04 <lambdabot> second
00:20:09 <alistra> @unpl ap
00:20:10 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
00:20:21 <alistra> it doesn't have seconds definition
00:21:26 <Sgeo> How does this look as far as manual recursion?
00:21:27 <Sgeo> http://hpaste.org/55973
00:21:41 <azaq23> @src snd
00:21:42 <lambdabot> snd (_,y) =  y
00:22:27 <alistra> better Sgeo
00:29:58 <ddarius> Sgeo: That simultaneously has too many parentheses and too few.
00:30:19 <Sgeo> I think the third line is missing parens around the pattern
00:30:47 <ddarius> You also close a single quote with a double quote.
00:31:14 * Sgeo sees
00:31:25 <rwbarton> and on line 2 I don't think you want the "x:"s
00:32:10 <Sgeo> Why wouldn't I?
00:32:24 <Sgeo> http://hpaste.org/55973
00:32:26 <rwbarton> why would you?
00:32:33 <rwbarton> what if the first character is '\n'?
00:32:46 <Sgeo> Would be nice if hpaste showed whether or not it parsed
00:32:52 <ddarius> > let x = (((((((((())))))))) in x
00:32:53 <lambdabot>   <no location info>: parse error on input `in'
00:33:03 <Sgeo> Good point
00:33:03 <ddarius> > let x = (((((((((()))))))))) in x
00:33:04 <lambdabot>   ()
00:33:24 <ddarius> Well the fact that hlint isn't yelling at you suggests that it couldn't be parsed.
00:33:50 <Sgeo> http://hpaste.org/55973
00:34:04 <ddarius> Of course, GHCi will also tell you whether it parses or not.
00:41:10 <Sgeo> When I use something like attoparsec, is it expected that I write little parsers that, in the end, return whatever where whatever is my data structure?
00:41:26 <Sgeo> Or part of my data structure, anyway?
00:42:24 <ddarius> ENOPARSE
00:42:35 <ddarius> Oh.
00:42:50 <ddarius> You typically want parsers that return stuff, yes.
00:43:16 <opqdonut> and in the case of simple parsers, you can usually directly return parts of the thing you're building
00:43:39 <opqdonut> but some times you might want to go through an intermediate representation (these are often termed ASTs)
00:45:34 <ddarius> You almost always want to produce an AST as that facilitates a separation of concerns between the parser and any further analyses or transformations.
00:46:19 <opqdonut> yes, in general
00:46:33 <opqdonut> but for simple things it's not always necessary
00:48:36 <kranius> hello
00:48:49 <mauke> hi
00:52:01 <jaspervdj> I vaguely recall an article which defines something like: type Image = (Int, Int) -> (Int, Int, Int), (x, y) to (r, g, b)
00:52:34 <jaspervdj> and then it continues by illustrating function composition with image effects
00:53:08 <jaspervdj> So, if anyone knows this article, I'm interested in a link :-)
00:53:36 <flux> hoogle should be extended to cover articles :)
00:54:19 <drdo> Is there if as a function somewhere?
00:54:49 <ddarius> jaspervdj: You're probably thinking of things like Pan.
00:55:06 <ddarius> And various related projects.
00:55:52 <azaq23> drdo: http://www.haskell.org/haskellwiki/If-then-else
00:56:00 <jaspervdj> ddarius: Ah, Pan was indeed the thing I was looking for, thanks!
00:56:17 <drdo> azaq23: Yes, i was reading that, what i'm asking is if it's defined in some widely used utility lib
00:57:16 <Kanisterschleife> hi. Trying "'foo' =~ '(foo|bar)' :: Bool" after importing Text.Regex.Posix in ghci v.7.0.4 I get the "No instances for (RegexMaker ...) arising from =~" - error. Any idea what's wrong?
00:58:42 <ddarius> You don't have an instance of RegexMaker.
00:58:54 <azaq23> it's not in prelude and the other fitting place would have to be a very general utility module, so you'll likely be out of luck unless you really want to deal with something named "import
00:58:54 <azaq23> Data.Util.ThisAndThat"
00:59:26 <ddarius> I believe there is a library that defines a "BoolLike" class that probably includes it.
00:59:45 <ddarius> That said, I don't think it is a separate package, but maybe it is.
00:59:48 <ddarius> I would just define it.
00:59:50 <Veinor> Prelude Text.Regex.Posix> "foo" =~ "foo" :: Bool
00:59:52 <Veinor> True
01:00:15 <ddarius> @hackage higherorder
01:00:16 <lambdabot> http://hackage.haskell.org/package/higherorder
01:00:22 <Kanisterschleife> Veinor: I have the same input, but get an error
01:00:40 <Veinor> hmm
01:00:48 <Veinor> could you hpaste the entire error?
01:01:55 <drdo> azaq23: In CL there are libraries that everyone uses that are exactly like that, lots of little general utilities that people that aren't in the standard
01:02:06 <drdo> *people use
01:02:19 <ddarius> In fact there are a lot of packages on Hackage that provide such functiosn.
01:02:52 <Kanisterschleife> http://hpaste.org/55976
01:03:01 <drdo> It's not a big deal to just define it, but might as well use it if it was already available
01:03:22 <Veinor> that's weird
01:03:43 <drdo> Hmm, i wonder, what was the rationale for including if-then-else in Haskell?
01:04:01 <ddarius> It decreases parentheses.
01:04:15 <Veinor> Kanisterschleife: what versions of regex-base and regex-posix do you have installed?
01:04:22 <ddarius> I don't have a problem with if-then-else being there, but it is odd to not include an equivalent function in the prelude.
01:04:45 <Kanisterschleife> Veinor: I had some trouble installing the regex library because of bad dependencies or so... I mistakenly mixed stable and testing. Is there a way to find out if this is the source of the error?
01:04:56 <drdo> I find myself wanting some alternative to case all the time
01:05:07 <ddarius> drdo: It's called pattern matching.
01:05:15 <ddarius> I rarely use if or case.
01:05:16 <Kanisterschleife> Veinor: how do I get the version numbers?
01:05:21 <Veinor> ghc-pkg list | grep regex
01:05:32 <drdo> ddarius: That makes me give names to stuff
01:05:40 <Kanisterschleife> Veinor: posix is 0.95.1
01:05:45 <ddarius> Occasionally.
01:05:52 <Veinor> what about regex-base?
01:05:56 <Kanisterschleife> 0.93.2
01:06:01 <Veinor> hmm
01:06:03 <Veinor> that's what i have, too
01:06:22 <Kanisterschleife> I also got "regex-compat-0.95.1"
01:06:50 <ddarius> drdo: Usually when I would have to make up some meaningless name otherwise, I will use case or if-then-else, but that doesn't happen often (which was my point.)
01:06:59 <Veinor> if you load up ghci, do the import, and :info RegexLike, what do you see?
01:08:04 <hpaste> Kanisterschleife pasted âRegex error No2â at http://hpaste.org/55977
01:08:07 <drdo> ddarius: For example, right now i'm getting some JSON and i want to check if a value is of a particular type, i end up writing (\t â case t of ....)
01:08:21 <Veinor> huh, that's odd
01:08:29 <drdo> It's not horrible, but i don't particularly like it
01:08:35 <ddarius> Why are you checking if it is of a particular type?  You should be parsing out the value and getting Maybe WhatYouWant.
01:08:40 <Veinor> do you have a Text.Regex.Posix.String module?
01:08:42 <ddarius> At which point you use the maybe function.
01:09:09 <Kanisterschleife> Veinor: yes
01:09:22 <drdo> ddarius: Not following
01:09:30 <Veinor> try importing it
01:09:36 <Veinor> and then seeing what instances you get
01:10:04 <drdo> I'm getting JSON but i still need to check if it has a particular structure
01:10:22 <drdo> and extracting the parts i want
01:10:37 <Kanisterschleife> Veinor: ok I imported it, how do I get a list of the instances?
01:10:44 <Veinor> :info RegexLike
01:10:47 <ddarius> Yes, and the thing that extract the parts you want will need to check if it has that particular structure you just checked for.
01:10:52 <ddarius> Why do it twice?
01:11:18 <Kanisterschleife> instance RegexLike Regex String \n -- Defined in Text.Regex.Posix.String
01:11:48 <Veinor> ok, so now make sure you imported both Text.Regex.Posix and Text.Regex.Posix.String and try the matching
01:12:02 <Veinor> i have no clue why it's not automatically importing it but you might need to reinstall regex-posix
01:12:05 <drdo> ddarius: I'm writing the thing to extract...
01:12:25 <ddarius> Or if you mean you are doing this all at once, then this seems like a perfectly reasonable use of pattern matching via case or a function parameter.
01:12:43 <Kanisterschleife> Veinor: still the same error. Ok, I will try to reinstall regex-posix. Thank you so far!
01:12:47 <ddarius> Also, view patterns are nice.
01:12:51 <Veinor> yeah, i have no clue what's going on there :/
01:13:16 <drdo> I'm parsing something close to json-rpc
01:14:20 <Kanisterschleife> Veinor: Just to make sure I reinstall the right thing. I need libghc-regex -(base|posix)?
01:14:25 <Veinor> oh
01:14:29 <Veinor> you're installing from your repo?
01:14:33 <drdo> I find myself writing stuff like this: parseObject (Object o) = return o
01:14:37 <drdo> parseObject _ = mzero
01:14:45 <drdo> For all kinds of stuff i might want
01:14:51 <Kanisterschleife> Veinor: I install via apt-get install
01:14:51 <drdo> Is there a better way?
01:15:05 <Veinor> Kanisterschleife: i have no experience with doing that, sorry :/
01:15:12 <ddarius> drdo: Use view patterns.
01:15:30 <ddarius> But that method can be used to make a powerful language of first-class patterns as well.
01:15:32 <Veinor> i just install ghc from the repository, bootstrap my way to cabal, and then cabal install everything from there
01:15:38 <ddarius> There is only so much to a JSON object.
01:16:17 <ddarius> parseObject seems kind of pointless except perhaps as a minor utility function.
01:16:32 <Kanisterschleife> Veinor: I'm sorry for this noobish questions, but what is cabal, and what do you mean by "bootstrap my way to cabal"?
01:16:47 <Veinor> oh
01:16:49 <ddarius> From my perspective, you should either be parsing -to- something, or you should just treat the JSON as your "AST".
01:16:58 <drdo> ddarius: it basically ends up being used like this: parseObject >>= extractSomethingFromObject
01:17:17 <ddarius> drdo: Then you should just have extractSomethingFromObject pattern match.
01:17:21 <Veinor> cabal is haskell's packaging system, like python's pip
01:17:31 <ddarius> Then it's just extractSomethingFromObject json.
01:18:01 <drdo> But then all those extracts need to have two clauses
01:18:38 <Kanisterschleife> Veinor: could you give me advise how to use cabal to get regex-posix?
01:18:48 <Veinor> drdo: what library are you using?
01:18:52 <drdo> aeson
01:18:56 <ddarius> drdo: I imagine most of them can be captured in a few patterns and the remainder that can't will need complex matching anyway.
01:19:22 <Veinor> Kanisterschleife: do you have the cabal executable installed? (just run 'cabal' and see if it gives you a help message or a 'file not found')
01:20:17 <Kanisterschleife> Veinor: just installed it
01:20:41 <ddarius> drdo: I don't have enough information, but my feeling is that you are making the cuts for abstraction in the wrong places.
01:20:53 <drdo> ddarius: I'
01:20:59 <drdo> I might be
01:21:07 <drdo> That's why i'm asking for suggestions
01:21:13 <Veinor> Kanisterschleife: uninstall the libghc-regex-(base|posix) stuff, then cabal install regex-posix
01:23:33 <Kanisterschleife> Veinor: strange. Did what you said, but I still get the same error
01:23:38 <Veinor> that's
01:23:40 <Veinor> really, really weird
01:23:43 <Veinor> i have no clue, i'm sorry :(
01:24:41 <Kanisterschleife> Veinor: me neither, I'll maybe reinstall everything and hope for a wonder :) Anyway, thank you for your help!
01:27:56 <Veinor> no problem
01:28:01 <Veinor> for the record, what i prefer doing is this:
01:28:44 <Veinor> Kanisterschleife: if you want to use the haskell platform, install from http://hackage.haskell.org/platform/
01:29:18 <Veinor> specifically, what i do is i install ghc from aptitude, then download http://lambda.haskell.org/platform/download/2011.4.0.0/haskell-platform-2011.4.0.0.tar.gz and install that
01:29:48 <Kanisterschleife> Veinor: ok, thank you!
01:30:35 <Veinor> no problem!
01:33:26 <drdo> Is there a function that can be defined as (MaybeT . return) ?
01:33:52 <ddarius> lift?
01:34:43 <cmccann> no, lift would be m a -> MaybeT m a, that function would be Maybe a -> MaybeT m a
01:35:28 <drdo> What he said
01:35:49 <Veinor> . o O (typeLevelFlip lift)
01:36:07 <Veinor> but i think you just want MaybeT . return
01:36:11 <drdo> I'm basically just writing MaybeT . return a lot :P
01:36:43 <ddarius> That's also an unusual thing to be doing.
01:37:01 <drdo> A lot might be an overstatement
01:37:37 * cmccann would look at it as a special case of (MaybeT m a -> MaybeT n a) 
01:37:48 <cmccann> or the same for any monad transformer
01:38:06 <cmccann> one of the weird monad transformer libraries has something along those lines
01:38:21 <cmccann> but since Maybe isn't actually MaybeT Identity that doesn't help you here
01:38:35 <ddarius> :t maybe mzero return:
01:38:35 <lambdabot> parse error (possibly incorrect indentation)
01:38:39 <ddarius> :t maybe mzero return
01:38:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
01:39:06 <cmccann> that's another way to look at it, yeah
01:43:07 <MaskRay> Is there an ipv6 address for hackage.haskell.org?
01:43:07 <lambdabot> MaskRay: You have 1 new message. '/msg lambdabot @messages' to read it.
01:43:18 <ddarius> My opinion is that using constructors like MaybeT is breaking the abstraction.
01:43:19 <mm_freak> a Fractional instance gives you quite some funny things
01:43:27 <mm_freak> > withMod 101 (0.1 * 10)
01:43:27 <mm_freak> 1
01:43:28 <lambdabot>   Not in scope: `withMod'
01:43:54 <mm_freak> it really calculates 1/10 modulo 101 * 10 modulo 101
01:44:39 <ddarius> My favorite class in Haskell is Real.
01:45:19 <mm_freak> lol yeah
01:46:05 <ddarius> I don't understand what you are trying to demonstrate with that withMod code.
01:48:21 <ddarius> Oh, I think I know what you are doing and thus what you are getting at.
01:49:13 <mm_freak> well, withMod 101 0.1 = 91
01:49:16 <mm_freak> that's 1/10
01:49:22 <ddarius> fromRational presumably has the modulo in it for whatever instance of Fractional you are using (I'm thinking one from the reflection package)
01:49:28 * hackagebot cqrs 0.7.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.7.0 (BardurArantsson)
01:49:30 * hackagebot cqrs-sqlite3 0.7.0 - SQLite3 backend for the cqrs package.  http://hackage.haskell.org/package/cqrs-sqlite3-0.7.0 (BardurArantsson)
01:49:32 * hackagebot cqrs-example 0.7.0 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.7.0 (BardurArantsson)
01:49:55 <mm_freak> no, i've written my own variant of type-nat
01:50:33 <ddarius> Just what we needed.  Another type level naturals library.
01:51:27 <mm_freak> no, not at allâ¦  it's really just a utility in a larger libraryâ¦  i've written it myself, because the variant from the reflection package has an ambiguous representation of natural numbers
01:51:43 <cmccann> hey, I've invented the wheel. mine have slightly different color spokes than the other ten wheels that have been invented.
01:52:38 <drdo> cmccann: Sometimes that makes all the difference!
01:52:54 <mm_freak> mine has the same representation as the one from the type-level-numbers package, but has a different reification method and an efficient reflection method
01:53:00 <mm_freak> i'm writing this for speed
01:53:27 <ddarius> mm_freak: Is there a reason not to include your changes in one of the current packages?
01:53:39 <mm_freak> in other words, if i were to use the type-level-numbers package, i'd basically only use the bit types and still write the rest myself =)
01:54:00 <mm_freak> ddarius: impatience mainlyâ¦  i want to get this library done
01:54:28 <ddarius> mm_freak: I'm not saying you should submit a patch and the sit on your hands until it is applied.
01:55:32 <mm_freak> ddarius: i know what you're saying, but i won't nowâ¦  the code is still experimental and lacks a test suiteâ¦  i'm currently testing by hand using lazysmallcheck
01:56:04 <mm_freak> and it's not even finished =)
01:59:19 * Sgeo is having too much fun with SimpleIRC
01:59:31 <Sgeo> Running a SimpleIRC bot off of GHCi, no code saved, just messing around
01:59:41 <Sgeo> OverloadedStrings is a very good idea
02:00:05 <asda8> how would I extend a list up to n elements consisely? I mean if I have a list of 3 integers and want a list of length 5 with the missing elements filled up with 0 for example.
02:00:32 <Sgeo> I see a way to do it, but not sure if it's "concise"
02:00:43 <cmccann> asda8, take 5 (xs ++ repeat 0) ?
02:00:48 <Sgeo> > take 5 ([1,2,3] ++ ...darn
02:00:49 <lambdabot>   <no location info>: parse error on input `...'
02:00:54 <cmccann> heh
02:01:07 <cmccann> there might be a nicer way but that's an obvious one
02:01:16 <asda8> thanks, it should do fine :)
02:05:22 <hpaste> int pasted âBug in GHC When Compiling CGI?â at http://hpaste.org/55978
02:14:28 * hackagebot acid-state 0.6.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.6.3 (DavidHimmelstrup)
02:15:44 <Lemmih> Have you ever seen a package looking that good?
02:16:23 <c_wraith> dunno.  the docs haven't built yet :)
02:23:35 <Lemmih> When the worls is ready for their glory, the docs will be there.
02:23:55 <Lemmih> The world will be ready in a few hours, hopefully.
02:39:37 <ddarius> Lemmih: Have you heard of the Stasis project?
02:48:01 <dhun_233> I get a linking error with ghc:
02:48:03 <dhun_233> undefined reference to `ghczmprim_GHCziTuple_Z63T_con_info'
02:48:15 <dhun_233> I am using frisby and thus mdo
02:48:33 <azaq23> use --make
02:51:24 <dhun_233> ghc  -XRecursiveDo --make fris.hs
02:51:32 <dhun_233> so I use make but it does not help
02:52:07 <dhun_233> it worked for quite some time, but now I added more rules to my grammer and this error appeared
02:52:26 <hpaste> Sgeo pasted âSimple Story Tellerâ at http://hpaste.org/55981
02:52:35 <dhun_233> fris.o: In function `s5aX_info':
03:04:30 * hackagebot cqrs 0.7.1 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.7.1 (BardurArantsson)
03:04:32 * hackagebot cqrs-sqlite3 0.7.1 - SQLite3 backend for the cqrs package.  http://hackage.haskell.org/package/cqrs-sqlite3-0.7.1 (BardurArantsson)
03:04:34 * hackagebot cqrs-example 0.7.1 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.7.1 (BardurArantsson)
03:05:32 <Sgeo> That sounds like a notion in Eiffel
03:10:17 <drdo> ddarius: I actually don't need those parseObject things, there's the FromJSON class with parseJSON
03:10:31 <drdo> and all useful things have instances
03:14:32 * hackagebot IntervalMap 0.2.0 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.0 (ChristophBreitkopf)
03:25:22 <asda8> how can I force recompilation with GHC?
03:25:59 <opqdonut> -fforce-recomp
03:26:09 <asda8> opqdonut: thanks
03:26:15 <opqdonut> :)
03:36:49 <dhun_32> after analysing the linking error I found that it depends on the ordering of lines, it disappeard when interchanging some lines
03:37:10 <dhun_32> this effect occured in the mdo notation
03:37:44 <sm> happy new year all
03:39:16 <copumpkin> preflex: zdec ghczmprim_GHCziTuple_Z63T_con_info
03:39:16 <preflex>  ghc-prim_GHC.Tuple_Z63T_con_info
03:39:22 <copumpkin> lol
03:45:23 <Kanisterschleife> Veinor: Hi, just wanted to tell you that I set up my system again, and now everything works fine
03:45:49 <Kanisterschleife> maybe it was really a problem with the mixture of testing and stable *guess*
03:47:33 <leino> Kanisterschleife: in my experience, all computer problems arise from mixing testing and stable :)
03:57:17 * Sgeo is uncertain how to mix do and where
03:57:37 <cmccann> they don't really mix
03:57:54 <cmccann> where clauses can be attached to any identifier definition I think
03:57:59 <cmccann> do blocks create an expression
03:58:13 <Sgeo> Do I have to have the where less indented than the do block?
03:58:49 <cmccann> is the where attached to a definition that the do block is part of? then probably, yeah
03:59:19 * Sgeo gets rid of the do block, it was really unnecessary
04:09:21 <Cale> Sgeo: you don't actually *need* to have the where indented less, but you should, because it's part of the containing declaration, and not part of the do expression.
04:10:25 <drdo> Speaking about where, how does one get a where that is visible in multiple clauses?
04:10:49 <drdo> multiple equations really
04:10:50 <cmccann> make them into a single clause
04:11:11 <drdo> so the answer is "you don't" ?
04:11:34 <cmccann> well, you can move the separate equations to an auxiliary function also in the where clause
04:11:40 <cmccann> so that the actual definition is a single equation
04:11:48 <drdo> yes i do that sometimes
04:11:56 <cmccann> also, guards all share the where clause
04:11:59 <cmccann> but otherwise no
04:12:11 <cmccann> at least as far as I know
04:24:33 * hackagebot yaop 0.1.1 - Yet another option parser  http://hackage.haskell.org/package/yaop-0.1.1 (EugeneSmolanka)
04:38:14 <ezyang> Hyo folks, I have some enumerator questions.
04:38:50 <hpaste> ezyang pasted ânonResumable enumerateeâ at http://hpaste.org/55982
04:39:10 <ezyang> ^- does this eem reasonable? Why isn't it in the standard library?
04:41:22 <frerich> ezyang : Hi, I don't know the answer to your question but I just wanted to let you know that I greatly appreciate your blog entries ever since I discovered your blog. :-)
04:42:05 <ezyang> frerich: Haha, thanks!
04:44:11 <mrcarrot> what blog?
04:44:30 <mike-burns> http://blog.ezyang.com/
04:51:47 <hpaste> Gavri pasted âFunctor for ITreeâ at http://hpaste.org/55983
04:52:06 <gavri> is http://hpaste.org/55983 a valid solution to the problem from typeclassopedia?
04:52:27 <gavri> I wasn't able to check the functor laws because I couldn't derive Eq for ITree
04:52:44 <mike-burns> Oh bummer, that new yoap package is exactly what I wanted a week ago. Oh well.
04:52:57 <byorgey> gavri: you only need to check whether  fmap id = id, which you can usually do by hand
04:53:10 <gavri> what about the other functor law?
04:53:11 <byorgey> gavri: looks good though
04:53:28 <cm> mike-burns, yoap?
04:53:36 <byorgey> gavri: the other functor law is implied by the first, because of parametricity.
04:53:41 <mike-burns> Oh, yaop.
04:53:47 <mike-burns> Unforunate name.
04:54:06 <byorgey> gavri: however, you seem to have essentially inlined the definition of fmap for lists into your definition of pmap
04:54:38 <byorgey> gavri: so although your implementation is valid and correct, it could be simpler
04:54:40 <gavri> byorgey: I only used the definition of fmap on lists I thought
04:55:22 <byorgey> gavri: I mean that fmap for lists already does a case analysis for the empty list vs cons, and recurses in the cons case, etc.
04:55:34 <gavri> oh ok, got it
04:55:36 <byorgey> so there is no need for you to do that yourself, just call fmap in the first place.
04:55:41 <gavri> thanks
04:56:00 <gavri> about the paramtericity thing, I'll look it up. I didn't realize that just the id law was sufficient
04:56:21 <byorgey> gavri: it's mentioned in the Typeclassopedia, although I forget exactly where
04:56:31 <gavri> cool, thanks
04:57:14 <byorgey> end of section 3.3
04:57:25 <gavri> thanks
04:57:43 <gavri> regarding question 5, do I work on it now, or will it help if I read further?
04:59:33 <byorgey> gavri: I don't think it will help if you read further
04:59:55 <gavri> byorgey: k, will work on it now. thanks again
05:00:07 <byorgey> hmm, although I guess that question really should be moved to the end of section 3.3
05:02:45 <Saizan> is there an easily linkable version of the proof that fmap id = id implies the other law?
05:03:12 <asda8> is there a function that executes an IO action while some condition based on the action is true (like (a -> Bool) -> IO a -> IO ())? I can't seem to find it through hoogle.
05:03:33 <mike-burns> @hoogle when
05:03:33 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
05:03:33 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
05:03:33 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
05:03:34 <byorgey> Saizan: http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384  is a proof that fmap is unique
05:03:49 <byorgey> Saizan: and it is not hard to see how to turn it into a proof that  fmap id = id  implies the other law
05:04:14 <Saizan> byorgey: thanks
05:04:55 <asda8> mike-burns: hm, is this depending on the return value of the action? I would like to make a database query until some condition occurs
05:05:40 <mike-burns> asda8: Is there something in the monad-loops package for this, maybe?
05:05:54 <asda8> mike-burns: thanks, I'll check
05:06:10 <mike-burns> @hoogle iterateUntil
05:06:11 <lambdabot> No results found
05:06:59 <abernste1n> can someone help me with Data.Lens ? I want to compose g :: Lens a (Maybe b) and f :: Lens b c to get  h :: Lens a (Maybe c)
05:07:59 <asda8> mike-burns: yeah, iterateUntil looks good. thanks!
05:08:48 <byorgey> abernste1n: which package is this from?
05:09:18 <abernste1n> byorgey: from data-lens
05:12:20 <byorgey> abernste1n: hmm, I guess you'll have to write your own  liftLens :: Lens a b -> Lens (Maybe a) (Maybe b)  using the 'lens' function
05:12:26 <byorgey> then you can do  g >>> liftLens f
05:13:34 <abernste1n> byorgey: ok. i'll do that. thanks
05:13:36 <byorgey> a more interesting question is:  liftLens :: (??? f) => Lens a b -> Lens (f a) (f b)   -- what is needed in the ???
05:14:29 <byorgey> I don't think Functor is enough
05:16:16 <Saizan> Monad should be
05:17:03 <abernste1n> i found repLens :: Representable f => Lens a b -> Lens (f a) (f b)
05:17:23 <abernste1n> but i do not know if that is useful in my case
05:17:49 <Saizan> Maybe is not Representable afaiu
05:17:55 <abernste1n> ok
05:19:34 * hackagebot monadiccp 0.7.1 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.1 (TomSchrijvers)
05:21:43 <asda8> what is the recommended way of breaking a long (top-level) type declaration into multiple lines?
05:22:33 <ezyang> I've seen a lot of folks do ahnging arrows
05:22:37 <hpc> asda8: ive never had the problem, but i would add newlines around the arrows
05:22:40 <hpc> yeah, that
05:22:46 <hpc> foo -> bar -> baz
05:22:50 <hpc> -> quux -> ...
05:23:11 <Cale> line up the arrows
05:23:38 <asda8> ok, that seems reasonable. I've seen people use one line / type and that is ugly
05:23:48 <Cale> (and the ::)
05:24:28 <hpc> i think if i ever encountered a type that long, i would refactor it
05:24:49 <asda8> hpc: it's not a lot of types, just a few long ones ;)
05:25:42 <asda8> I mean it's a type declaration for a function of course
05:25:55 <hpc> asda8: so, LongTypeWithLongNameIsLong -> AnotherLongTypeWithLongName ...
05:26:02 <hpc> vs a -> b -> c -> d -> e ...
05:26:07 <hpc> ?
05:26:17 <asda8> hpc: yes
05:26:24 <asda8> hpc: the first one
05:26:29 <hpc> i see; that makes more sense then
05:29:27 <Saizan> ?type let liftLens l = \x -> ((fmap (snd . l) x <*>) , fmap (fst . l) x) in liftLens
05:29:28 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> (a1, a2 -> b)) -> f a -> (f a2 -> f b, f a1)
06:07:16 <ezyang> So, if I understand correctly, ResourceT is manual management for resources, with protection from double-frees, automatic free at exit scope, and *no* protections against accidentally closing a handel too early? :X
06:08:28 <ezyang> http://www.yesodweb.com/blog/2011/12/resourcet
06:08:49 * cmccann closes bach and vivaldi too early as well as handel
06:09:16 * ezyang is on a slow Internet connection, and is accessing his IRC session over ssh :^) 
06:09:37 <cmccann> ezyang, I figured you just had some code that was... ahem... baroque
06:09:43 <cmccann> *rimshot*
06:09:51 <ezyang> *crash*
06:10:04 <abernste1n> :)
06:10:28 <cmccann> the really sad part is that I actually went to the trouble of looking up other baroque composers for the sake of that joke
06:10:34 <cmccann> just to make sure I got it right
06:10:42 <ezyang> So, I suspect Oleg'ian lightweight monadic regions handle this use-case, but I don't know how they interact with iteratees, and I don't blame Snoyman for shying away from... more Oleg.
06:10:46 <ezyang> cmccann: Heehee.
06:11:17 <ezyang> But I kind of wonder whether or not using the GC to handle early resource disposal would be better.
06:11:23 <ezyang> Probably not :X
06:11:38 <cmccann> ezyang, I thought everyone liked cryptic names and having continuations all the way down
06:12:33 <ezyang> So, now armed with a better understanding of iteratees, I understand why Oleg opted for the terms 'Iteratee, Enumerator and Enumeratee' rather than 'Sink, Source and Conduit'.
06:12:50 <ezyang> The latter are the right intuitions for *function* but not for *operation*
06:14:35 * hackagebot maude 0.3.0 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.3.0 (DavidLazar)
06:15:18 <ezyang> Also, is it just me, or is the 'enumerator' library missing a lot of important combinators?
06:16:40 <cmccann> I wouldn't know, I've mostly avoided iteratee stuff to be honest :T
06:16:50 <ezyang> Yeah, me too.
06:17:13 <cmccann> mutilating the logic to cram everything into little state machines doesn't appeal much
06:17:36 <ezyang> Well, the primary utility of iteratees is that the compose extremely well.
06:17:57 <cmccann> yes, they're very compositional little state machines
06:17:58 <ezyang> You need to build lots of little state machines to make libraries, but afterwards it should be like ordinary programming in a lazy language.
06:18:19 <ezyang> So I also suspect that if people are writing a lot of these manually, they're missing the point ^_^
06:18:45 <cmccann> yeah, I'm happy to use libraries built on top of them when that makes sense
06:19:39 <cmccann> but not thrilled about building that sort of stuff myself
06:19:48 <ezyang> I also think the choice of combinator symbols for these libraries is unfortunate, but I guess that's another can of worms...
06:20:00 <Saizan> Enumerator's seem harder to compose though, but i've not spent much time with them either
06:20:15 <ezyang> Saizan: Compared to Conduits or...
06:20:35 <Saizan> to Iteratees
06:20:49 <Saizan> i.e. i'm using Oleg's terms
06:21:09 <ezyang> Ah, OK.
06:22:18 <ezyang> Well, Oleg gives us Enumerator a m b -> Enumerator a m b -> Enumerator a m b for concatenating two things together
06:22:58 <ezyang> I don't think I've seen that in 'enumerator', though maybe I didn't look hard enough.
06:23:10 * frerich was just googling to figure out who this 'Oleg' guy is in Haskell-land, he seems to have done everything already. And what did I find: http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
06:23:13 <ezyang> (using ticks to indicate package names)
06:24:06 <Saizan> that seems easy enough, but e.g. Enumerator a m b -> Enumerator a m b -> Enumerator (a , a) m b for zipping streams?
06:27:05 <merijn> ezyang: "More generally, the class of languages (Haskell is just one of a few) that compile into native code seem to be becoming more and more attractive replacements for tight C programs", there's not many mainstream languages in that class :p
06:28:18 <merijn> Besides C++ I can think of Go, haskell, ocaml, but those are really more fringe languages than mainstream
06:29:22 <ader111> I read in the conduit article that guys at Yesod found a solution for closing resources in the iteratee but they are not going to use it and they will replace with conduits. Does anyone have any information about that fix?
06:30:02 <Renze> Am I correct when I say the ghc dependency for Haddock is not correct? It states ghc >=7.2 && <7.4, but I assume they meant ghc >= 7.0.2 && 7.0.4 (http://hackage.haskell.org/package/haddock)
06:30:18 <ezyang> ader111: I believe it consists of the ResourceT transformer, and some extra magic.
06:31:16 <ezyang> Wow, quick response from Michael!
06:31:19 * ezyang goes off to read... 
06:44:56 <byorgey> Renze: no, it is correct.  Version 2.9.4 of Haddock only works with ghc 7.2.
06:45:19 <byorgey> Renze: if you want a version that works with ghc 7.0, try Haddock-2.9.3
06:45:44 <Kanisterschleife> Hello, I want to learn Haskell and have a question. Suppose X is a typeclass and 'f :: (X => a) a', and suppose further that I consider the "type of all values", i.e. 'data Everything = forall a. Take a' Then 'Take :: a -> Everything' ( = 'forall a. a -> Everything'). When I try to consider 'Take f' I get an error. Why that? I expected that I would get 'Take f :: (X => a) Everything', so that I can specialize Take f to a value of
06:45:44 <Kanisterschleife> Everything for all Types in X. The only problem I see is that in contrast to the association of a -> Everything with a, in the association of Everything with all a in X I cannot tell from the result what was the input.
06:45:44 <Renze> byorgey: that one crashes with 7.0.4, so I installed 2.9.2, which works fine :)
06:45:55 <byorgey> Renze: ok, good =)
06:46:43 <byorgey> Renze: yeah, it looks like 2.9.2 is the version that comes with the latest Haskell Platform
06:46:54 <Renze> byorgey: But I found the problem. I thought I installed the newest version of Haskell Platform with the newest version of ghc, but I installed the newest 'older version'
06:47:07 <Renze> byorgey: Ah, didn't knew it was already installed.
06:47:14 <byorgey> Renze: the newest version of the Haskell Platform does not come with the newest version of GHC.
06:47:29 <byorgey> it comes with GHC 7.0.4.
06:48:08 <Renze> That's kind of old, but well, it works fine now, so I won't change it.
06:48:36 <byorgey> it's not that old.  Just one version behind the latest release.
06:49:17 <Renze> What happened with 7.1?
06:49:42 <byorgey> even numbers are for releases, odd are for development versions
06:50:10 <asda8> I'm currently using forM_ for iterating: is there a function that not only provides me with the list element, but also with it's index? (maybe in a pair?)
06:50:48 <byorgey> asda8: instead of iterating over lst, just iterate over  zip [0..] lst
06:52:06 <hpc> :t let forM_' f xs = forM_ (uncurry f) (zip [0..] xs) in forM_'
06:52:07 <lambdabot>     Couldn't match expected type `[a]'
06:52:07 <lambdabot>            against inferred type `(a1, b) -> c'
06:52:07 <lambdabot>     In the first argument of `forM_', namely `(uncurry f)'
06:52:18 <asda8> byorgey: thanks
06:52:31 <hpc> :t let mapM_' f xs = mapM_ (uncurry f) (zip [0..] xs) in forM_'
06:52:32 <lambdabot> Not in scope: `forM_''
06:52:40 <hpc> :t let mapM_' f xs = mapM_ (uncurry f) (zip [0..] xs) in mapM_' -- argh
06:52:41 <lambdabot> forall a b (m :: * -> *) b1. (Monad m, Enum a, Num a) => (a -> b -> m b1) -> [b] -> m ()
06:53:10 <hpc> use: mapM_' (\index value -> action) list
06:53:28 <byorgey> no reason you can't make forM_'
06:53:33 <hpc> forM_' = flip mapM_'
06:53:50 <hpc> byorgey: easier to change those three characters than fix the reversed params :P
06:53:55 <byorgey> hehehe
06:54:39 <hpc> :t uncurry . uncurry
06:54:40 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
06:55:10 <hpc> :t zip [0..] . zip [100,99..]
06:55:11 <lambdabot> forall t t1 b. (Num t, Enum t, Num t1, Enum t1) => [b] -> [(t, (t1, b))]
06:55:32 <hpc> hmm
06:55:32 <Kanisterschleife> Hm, maybe a more specific question: Why does specialization of types in Haskell go by telling what the resulting type should be instead of telling what types I want to plug into the free type variables? Like when I want to specialize 'Nothing' Maybe Int, I have to say Nothing :: (Maybe Int) instead of telling in some way that the free type variable should be replaced by Int) This seems to be the problem with the concatenation of a
06:55:32 <Kanisterschleife> function f:: forall a. a -> bla with an element x :: forall a. a
06:55:48 <hpc> some type trickery might be in order to allow zips and uncurries to associate tuples in the same direction
06:56:12 <byorgey> Kanisterschleife: yes, it would be nice to be able to explicitly instantiate type variables.
06:56:36 <byorgey> Kanisterschleife: there are some practical issues to be worked out but no theoretical impediments.
06:56:56 <hpc> one way would be a phantom parameter
06:56:58 <byorgey> it's something that has been occasionally discussed among ghc developers, and I'm still hopeful it will be implemented someday.
06:57:06 <hpc> foo :: a -> b -> Something a b
06:57:16 <hpc> foo _ _ = \stuff -> blah
06:57:23 <byorgey> hpc: yes, but that only works if you are able/willing to change the definition of your function to take an extra parameter
06:57:27 <hpc> foo (undefined :: Int) (undefined :: Bool)
06:57:42 <hpc> indeed, it is very much a hack
06:57:46 <Saizan> practical issues like forall a b. T a b being the "same" type as forall b a. T a b
06:57:52 <hpc> something like agda's implicit params would be ideal
06:58:07 <hpc> and what i have is the explicit params version
06:58:38 <Saizan> what you have is not simply the explicit params version
06:59:02 <byorgey> Saizan: right, that's one issue.  Probably you would just specify a canonical ordering on the type variables, i.e. the order they are declared in an explicit forall, or left-right by first occurrence
06:59:13 <Saizan> because you also provide values of the types, not just the types
06:59:16 <Kanisterschleife> byorgey: hmmm, ok
06:59:28 <hpc> byorgey: i personally would make the forall mandatory with this hypothetical extension
06:59:35 * hackagebot haskell-updater 1.2.0.3 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.3 (SergeiTrofimovich)
06:59:55 <hpc> the order of type variables can sometimes be tricky
06:59:58 <hpc> for instance, type aliases
06:59:59 <byorgey> hpc: the problem with that is the same as the problem with your hack: it doesn't work if you are trying to call some function you did not write
07:00:05 <hpc> type Flip a b = b -> a
07:00:15 <byorgey> (and the person who did write it didn't give an explicit forall)
07:00:21 <hpc> true
07:00:23 <Kanisterschleife> But at the moment type expressions with free variables 'outisde' not occurring in the type expressions are forbidden, right?
07:00:41 <byorgey> hpc: hmm, yeah, you're right about type aliases complicating ordering
07:01:04 <byorgey> Kanisterschleife: I'm not sure I understand your question
07:01:27 <Kanisterschleife> byorgey: I mean something like forall a. Integer or the thing (X => a) Everything from above
07:01:32 <Saizan> ?type id :: forall a b c d e. e -> e
07:01:32 <lambdabot> forall e. e -> e
07:01:48 <Saizan> ?type 0 :: forall a. Integer
07:01:49 <lambdabot> Integer
07:01:59 <byorgey> Kanisterschleife: as Saizan demonstrates, those are fine
07:02:20 <byorgey> no different than a function that happens to ignore one of its arguments
07:02:56 <Saizan> foo :: forall a. Show a => Integer is still a valid type, but calling foo will be a problem
07:03:17 <Saizan> well, impossible
07:03:20 <byorgey> but as Saizan also demonstrates, this causes even more practical problems for the hypothetical explicit-type-instantiation extension.
07:03:30 <Kanisterschleife> Ok, but then the composition of functions is not always defined. Like above when you have 'Take :: forall a. -> Everything" and want to plug in something like 'f :: forall a. a'
07:03:34 <byorgey> since GHC considers  forall a. Integer === Integer, should you be able to instantiate a, or not?
07:04:20 <hpc> byorgey: i vote for "it depends"
07:04:49 <hpc> specifically, on if forall a. Integer {a = Bool} === Integer === forall a. Integer === forall a b. Integer === ...
07:04:56 <Kanisterschleife> I meant 'Take :: forall a. a -> Everything'  and 'f :: forall a. a'. One would expect a the type of the composition to be the set of families of elements of Everything parametrized by all types, but according to Saizan, forall a. Everything is equal to Everything?
07:05:26 <byorgey> Kanisterschleife: hmm, looking back at what you asked earlier (I missed it before).  What error do you get for 'Take f'?
07:06:04 <byorgey> Kanisterschleife: "One would expect a the type of the composition to be the set of families of elements of Everything parametrized by  all types
07:06:10 <byorgey> -- no I wouldn't
07:06:38 <byorgey> if Take :: forall a. a -> Everything  and  f :: forall a. a, then  Take f :: Everything.
07:06:49 <byorgey> the problem is probably that GHC doesn't know what type to pick for f.
07:06:50 <Kanisterschleife> Ok, then I have to misunderstand something. For me, the type forall a. a -> Everything has as its values families of functions a -> EVerything, running over all a.
07:07:13 <byorgey> right
07:07:27 <Kanisterschleife> And forall a. a has as its values families of values of a, running over all a.
07:07:44 <byorgey> right
07:07:46 <Kanisterschleife> So if I concatenate both, I get families of values of type Everything, still parametrized by all types a
07:07:53 <copumpkin> "concatenate"?
07:07:56 <Kanisterschleife> and this is not the same as the value set of Everything
07:08:38 <Saizan> i think the answer is "it actuall is, by parametricity"
07:09:31 <byorgey> Kanisterschleife: if you write  Take f  you are instantiating the 'a' in the type of Take to the type of f, namely, (forall b. b)
07:10:28 <Saizan> (are you sure? it think Take f is more like Take [Any] (f [Any]))
07:10:54 <byorgey> hehehe, no, I'm not sure
07:10:56 <Kanisterschleife> byorgey: Why that?
07:11:04 <byorgey> this gets into some murky waters re: impredicativity
07:11:13 <Kanisterschleife> byorgey: As copumpkin said, it seems to be the question of the "Take f" should mean
07:11:16 <Saizan> it's not even easy to tell :)
07:11:56 <byorgey> in any case, I am guessing the reason that 'Take f' gives an error from GHC is that GHC demands to know what concrete type it should pick for f, but the type is unconstrained
07:12:55 <byorgey> in particular, there is no *theoretical* reason that it should give an error.
07:13:10 <Saizan> there's a reason iff f has a typeclass context
07:13:19 <Saizan> which seems to be the case in the original question
07:13:24 <byorgey> oh.
07:13:42 <Kanisterschleife> wait, why is it important if f has a typeclass context?
07:14:06 <Saizan> because then the value of f itself can change according to the choice of 'a'
07:14:16 <byorgey> because the choice of typeclass has runtime computational significance
07:14:25 <copumpkin> Saizan: it could do some fancy reasoning to realize that there's no way you could figure out what value it was ;)
07:14:27 <byorgey> the choice of types does not, since types are erased
07:14:28 <Kanisterschleife> I acutually took one to be able to write down a value of type (X => a) a; wouldn't have known how to write down a value of forall a. a
07:14:46 <byorgey> Kanisterschleife: by the way, (X => a) a  does not make sense
07:14:54 <byorgey> do you mean something like  (X a) => a ?
07:15:00 <Kanisterschleife> örgs, yes
07:15:13 <byorgey> ok, just making sure =)
07:15:15 <Kanisterschleife> sorry, still mixing things up...
07:15:18 <byorgey> no worries
07:15:42 <Kanisterschleife> In my example, I took class Unit a where unit :: a, so that I have a distinguished element unit :: (Unit a) => a
07:15:50 <byorgey> right
07:16:23 <byorgey> Kanisterschleife: so the question is what  Take unit  should mean (and whether it should work)?
07:16:25 <Kanisterschleife> acutally for the queston it'd be happy with f :: forall a . a, but I couldn't check what ghci does because I don't know a value for it.
07:16:37 <byorgey> @type undefined
07:16:38 <lambdabot> forall a. a
07:18:03 <Kanisterschleife> byorgey: Yes. Intuitively, viewing Take as a family of functions and unit as a family of values (both having the same type parameters), I would expect that Take f is eevaluated for each choice of a separately, so that it would result in a family of values of type Everything, parameterized by all types. I had expected this to be the value set of 'forall a . Everything'
07:19:28 <Kanisterschleife> However, this cannot make sense with ghci, because since specialization seems to be done be telling the type I want to have in the end, and in our case it's *always* 'Everything', I wouldn't know how to "evaluate" this hypothetical 'function' 'forall a. Everything' at a given type.
07:19:52 <Kanisterschleife> If type specialization was done by telling what should be plugged into the free type variables, then I'd see no problem with that..
07:20:17 <Saizan> since the rest of the type system prevents you from doing different things for different types (except when you have a typeclass context), given x :: forall a. Everything, x used at Int would evaluate to the same as x used at Bool, or any other type
07:20:28 <Saizan> that's why the forall a. has no significance there
07:21:36 <byorgey> Kanisterschleife: well, your intuition re: Take f is not correct.  You want the application of a family to a family to be "lifted" so that a family results, but it doesn't work that way.
07:22:28 <byorgey> well... hrm. I guess it does sometimes.
07:22:41 <byorgey> the thing that is complicating this particular example is that Everything involves existential quantification.
07:22:50 <Kanisterschleife> Saizan: isn't the problem to tell what evaluation of "forall a. Everything" or "(X => a) Everything" 'at a' should mean?
07:23:26 <Saizan> Kanisterschleife: forall a. Everything and forall a. X a => Everything are quite different
07:23:50 <Saizan> Kanisterschleife: in the former case you know that the 'a' chosen won't matter at all
07:24:24 <Kanisterschleife> Saizan: but in any case it's not clear how you could tell ghc to specialize to some 'a', because it's not present in 'Everything' anymore.
07:24:26 <Saizan> *the type chosen to instantiate a, i guess
07:24:41 <Kanisterschleife> Saizan: Ok, it's again my wrong intuition
07:24:42 <Saizan> Kanisterschleife: right, you wouldn't
07:25:37 <byorgey> Kanisterschleife: right, that's the key: Everything contains an *existentially quantified* type.  Think of 'Take' as a box that seals up a type inside.
07:25:41 <Kanisterschleife> Saizan: But if you were able to instantiate by telling what the value of a should be, then forall a. X a => Everything should be a different type than Everything
07:25:42 <Saizan> in neither case you'd be able to tell ghc which type you want for 'a', in the former case you're just lucky that it doesn't make a difference and in fact ghc is happy to ignore it
07:25:46 <byorgey> once you have applied Take there is no way to change the type inside, or learn what it is.
07:26:19 <Saizan> Kanisterschleife: forall a. X a => Everything is in fact a different type
07:26:49 <byorgey> however,  applying Take  to a value of type  forall a. X a => a  still does not produce  forall a. X a => Everything
07:27:04 <Saizan> Kanisterschleife: it's just that currently it's a pretty useless type, because you won't be able to pick an 'a' yourself and ghc won't be able to decide which one you want
07:27:22 <mux> http://www.tbray.org/ongoing/When/201x/2011/12/27/Type-Systems <- someone needs to get educated
07:28:13 <byorgey> Kanisterschleife: I need to go get some work done, but before I go, I have two things to say
07:28:18 <byorgey> Kanisterschleife: (1) keep asking such great questions
07:28:32 <byorgey> Kanisterschleife: (2) you may be interested in reading a book such as "Types and Programming Languages"
07:28:55 <Kanisterschleife> byorgey: ok, thank you!
07:29:00 <Kanisterschleife> Saizan: thank you, too!
07:29:02 <Renze> I can't refer to a specific constructor with Haddock, right? f.e.: data Foo = NoFoo | Bar, and then I'd like to refer to Bar (or NoFoo).
07:29:32 <Saizan> yeah, one needs to see System F and Hindley-Milner to really understand this
07:30:18 <hpc> mux: that was painful to read
07:31:02 <byorgey> Renze: data Foo = NoFoo -- ^ blah blah   | Bar -- ^ blah blah     -- if by "refer to" you mean "document"
07:31:02 <Kanisterschleife> Saizan: Assuming that it would be possible to tell ghc to specialize the value of a - do you agree that then forall a. Something and Something should be different types?
07:31:17 <Kanisterschleife> byorgey: I'll have a look in that book
07:31:22 <Saizan> Kanisterschleife: nope
07:31:28 <mux> hpc: it made me feel nauseous :-(
07:31:53 <mux> same old bullshit "dynamic systems get built faster", "dynamic produces less code"
07:31:59 <Renze> byorgey: No, I'd like to say in a function f: ... 'Bar' ..., instead of referring to 'Foo'
07:32:27 <hpc> mux: strictly speaking, it does...
07:32:32 <hpc> mux: assuming a perfect programmer :P
07:33:08 <mux> I don't see how but I'm not sure I even want to enter that debate again
07:33:45 <Saizan> Kanisterschleife: well, it depends, in a more explicit system like System F where you're always forced to explicitly specialize types those two would be different, (but the type you use to specialize still wouldn't matter, unless it has type-case), but here in Haskell where type inference is doing the work for you they are interchangeable
07:34:44 <Saizan> Kanisterschleife: because when you construct something of type forall a. Everything you've no information about what 'a' is going to be, so any choice will be irrelevant to you
07:36:48 <Kanisterschleife> Saizan: I don't agree. I thought a forall statement describes a type whose values are given by the disjoint union of the value sets of the things the follow the 'forall'-statement, and the index set of the union is the set of all possible instantiations of the free variables.
07:37:14 <Kanisterschleife> no no, damn
07:37:48 <Saizan> Kanisterschleife: it's the product or intersection actually of them, not the disjoint union
07:38:00 <Kanisterschleife> I don't mean disjoint union, what am I saying... I meant I want to have a value for the type following the forall statement, for all possible instantiations of the free type vars
07:38:42 <Saizan> Kanisterschleife: to a first approximation that's right
07:39:02 <Saizan> Kanisterschleife: my point is that you can't look at what the type is to produce that value
07:39:56 <Saizan> Kanisterschleife: e.g. if you want to produce something of type forall a.a you can't say "if a is Int then give 0; if a is Bool then give True; ..."
07:40:28 <Saizan> Kanisterschleife: because the language doesn't provide any operation to construct such an if statement
07:41:45 <Kanisterschleife> yes, at the moment, where you instantiate by telling what the resulting type should be, you cannot distinguish the components of a value in such a big product. This is why I asked: If you were able to instantiate not by telling the type you want to get, but instead by tellin explicitly what types you want to plug in into the free type variables, then the value set of the forall blabla thing should really by the product of all the value
07:41:45 <Kanisterschleife> sets of the rhs
07:42:10 <Kanisterschleife> Saizan: do you understand what I mean?
07:42:19 <Saizan> i understand, but you're still mistaken
07:42:27 <Kanisterschleife> Hmm :/
07:43:34 <Saizan> because what makes the 'a' irrelevant is in how a value of type "forall a. ..." is constructed, not how it's used
07:44:13 <Saizan> in fact in System F you can instantiate the variables like you're suggesting and you still have this property
07:46:20 <Kanisterschleife> Ok, so let me check if I understand you correctly
07:49:21 <Kanisterschleife> Morally, at first the "product-definition" of the value set of the "forall"-type would the right thing. But after all, you only care about values that you can "construct" (though I'm not sure what this should mean), and with this restriction, you end up with the insight that all values you can "construct" are "functions" that don't care about the value of the free type variable a
07:50:43 <Saizan> yes, and by construct i mean that you have a Haskell program that evaluates to them
07:52:06 <Saizan> and in the end this insight is justified by the fact that an haskell program can't "pattern match" on types
07:52:27 <Kanisterschleife> funny... now the circle closes, as I wanted "Take f" to actually be such a non-constant function
07:54:47 <Saizan> to get something approximating non-constantness you can make use of typeclasses, because the methods of the typeclass can have type-specific implementations, and then in fact there's a difference between forall a. X a => Everything and Everything
07:55:27 <Saizan> and the impossibility to explicitly instantiate 'a' starts to be a problem
07:56:09 <Kanisterschleife> My question/claim was: If Haskell would allow direct instantiation of free variables, then forall a . Something should be different from a, and the argument is that in this case, precisely a thing like "Take f" would be a nonconstant, constructible function in the value set of forall a . Something
07:56:38 <Saizan> Kanisterschleife: yeah, and that claim is false
07:58:01 <Saizan> because either f has a typeclass context and then that expression doesn't have that type, or f is itself a constant function wrt 'a'
07:58:20 <jgreene> hi all,
07:58:22 <jgreene> I'm trying to understand memory management in functional programming language design and was wondering various languages handle it, I'm guessing most functional languages use pass by value semantics, but I'm wondering how efficient that can be made for large lists/arrays?
07:59:04 <Saizan> your guess seems utterly wrong
07:59:48 <Saizan> well, at an high enough level it looks like pass by value, because you can't mutate your arguments
08:00:03 <asda8> if I want to do the same for multiple cases in a case expression, can I list the cases I want somehow (like how switch in C is "falling through")?
08:00:18 <Saizan> though the lowlevel implementation in e.g. GHC is much closer to pass by reference
08:00:20 <Kanisterschleife> Saizan: :-(
08:01:32 <Saizan> asda8: nope, maybe you can use a guard though
08:02:20 <Saizan> asda8: f 0 = e; f 1 = e; ... is the same as f x | x `elem` [0,1] = e; ...
08:03:08 <Kanisterschleife> Saizan: for me it doesn't matter if a typeclass is present or not. At the moment, the expression Take f for f :: (C a) => a is not defined, but if direct instantiation of free type variables where possible, then it should be defined, and it should be a "nonconstant" function of type (C a) => Everything.
08:03:10 <asda8> Saizan: ok, this should work for me. Can I use guards on lambdas?
08:03:32 <Kanisterschleife> Anyway, I'm getting confused... thank you for your time, and sorry for spamming the chat for so long.
08:03:35 <Saizan> asda8: no, but you can in case expressions
08:04:01 <asda8> Saizan: oh, what's the syntax?
08:04:09 <Saizan> Kanisterschleife: trust me, it's pretty important if the typeclass is present or not :)
08:05:01 <Saizan> asda8: case .. of x | x `elem` [0,1] -> e; ...
08:05:45 <asda8> Saizan: ok, thank you! :)
08:12:31 <Kanisterschleife> Saizan: What do I have to do in ghci so that ":type id :: forall a b c d e. e -> e" won't yield the error "Illegal symbols '.' in type"? I want to reproduce the thing you did above
08:13:48 <Saizan> Kanisterschleife: :set -XExplicitForAll
08:16:57 <Kanisterschleife> Saizan: thx
08:22:01 <Kanisterschleife> Saizan: Can I maybe ask one last time? I'm happy assuming that a typeclass is present. What are the values of forall a. (C a) => Integer?
08:23:19 <ben> :t read "42"
08:23:20 <lambdabot> forall a. (Read a) => a
08:26:11 <Saizan> Kanisterschleife: one way to see them is as functions from a record type containing the implementations of the methods of C for 'a' to Integer
08:30:22 <frerich> For some obscure reason, programming in Haskell (I suspect the same is true for any other functional language, but I only really know Haskell) sometimes blurs the line between data and code for me. Like, I needed a map and instead of using 'Data.Map LastName Person' I started by writing 'getPerson :: LastName -> Person'
08:30:59 <frerich> Maybe because Haskell functions aren't "raw code" as in the "imperative, assembler mnemonic" sense but rather declarative.
08:31:40 <hughfdjackson> freiksenet: SPJ made note of this effect in the talk i was watching the other night
08:31:44 <hpc> frerich: http://blog.ezyang.com/2010/09/data-is-code/ -- you would love this article
08:31:44 <drdo> Is there a working TLS implementation fork haskell?
08:31:47 <hughfdjackson> i almost wrote SJP :|
08:32:05 <drdo> (or bindings to something)
08:32:19 <frerich> hpc: I see it's by ezyang, so yes - I probably will. ;-) Thanks for the pointer, looking at it! :-)
08:39:30 <hughfdjackson> hpc: cheers for the article :3 very interesting
08:39:42 * hackagebot sendfile 0.7.4 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.4 (JeremyShaw)
09:04:42 * hackagebot git-annex 3.20111231 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20111231 (JoeyHess)
09:32:35 <dhun_233> I tried to compile a certain source with ghc, it turned out that I can't since my computer has only got 1 Gbyte of RAM, any ideas?
09:35:02 <nus> add swap space
09:36:01 <dhun_233> I got swap but the runtime seems to be close to infinity because of the access time of hdds
09:36:45 <paolino> hello, I'm having hard times to write a function from some paths to a tree. If anyone has some hints I'm very interested
09:37:00 <dhun_233> if all else fails I could by a ssd and use a 64 Bit cpu and so on, but for now I don't want to pay that
09:37:43 <srhb`> dhun_233: Have you tried skipping the linking step?
09:37:57 <nus> paolino, paths?
09:37:59 <dhun_233> I does not come to linking
09:38:07 <srhb`> Aha.
09:38:13 <paolino> nus , from root to a leaf
09:38:28 <Botje> paolino: that's a rather vague specification.
09:38:45 <Botje> you are given a set of paths and you need to create a tree that contains those paths?
09:38:48 <dhun_233> its a 5 MByte file consisting of one mdo block describing the grammer of MediaWiki
09:39:01 <paolino> Botje, yes that's it
09:39:14 <Botje> paolino: okay, what have you tried so far?
09:39:26 <Botje> paolino: my general approach would be to insert the paths into the tree one at a time.
09:39:42 * hackagebot abstract-deque 0.1.4 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.1.4 (RyanNewton)
09:39:44 <Botje> so write an insert function first, then fold it over your list of paths
09:39:52 <paolino> Botje, same strategy here
09:40:35 <Botje> have you created a data definition for your tree?
09:40:38 <Botje> << food
09:40:49 <mike-burns> Yeah, hpaste what you have at least.
09:42:17 <Lemmih> dhun_233: +RTS -M600M maybe?
09:43:15 <hpaste> paolino pasted âmake a treeâ at http://hpaste.org/55991
09:43:30 <dhun_233> Lemmih does not seem to work
09:43:45 <dhun_233> option not recognized by ghc
09:45:13 <paolino> mike-burns, it's wrong because id doesn't add branches when the node is not found
09:46:51 <dhun_233> I am not trying to compile on a 2 GByte machine
09:47:41 <mike-burns> paolino: Is mkDirectory taking a list of paths?
09:48:01 <paolino> yep
09:50:26 <paolino> Botje, also a sort and transpose was an idea given Ord a. But I couldn't get it
09:50:31 <monochrom> either "ghc --make haha.hs +RTS -M600M" or "ghc +RTS -M600M -RTS --make haha.hs"
09:50:47 <itasyno> Hi, I've installed the prerequisites for Xmobar using Cabal, they're in my local pkg directory. I want to install Xmobar into the system directories, but the runhaskell command says it can't find the dependencies, despite ghc-pkg --list showing them in the local pkg directory. How do I get around this?
09:50:52 <monochrom> i.e., "-RTS" in the latter case
09:51:43 <dhun_233> it running, lets see
09:52:36 <monochrom> but ghc (or ghc-generated programs) wouldn't enlarge the heap if it could find garbage to collect
09:54:33 <statusfailed> a cabal file is giving me "Could not find module Data.Time \ It is a member of the hidden package `time-1.4.0.1"
09:54:48 <statusfailed> do I need to manually add it?
09:55:06 <monochrom> you have to unhide the package
09:55:34 <monochrom> oh, I see now, yes you have to add it. add every bloody package.
09:55:59 <monochrom> I mean add all direct and indirect transitive dependencies
09:56:10 <statusfailed> er
09:56:15 <statusfailed> what? :)
09:56:28 <monochrom> add in the cabal file.
09:56:30 <paolino> itasyno, maybe sudo cabal install is putting the packages in the global
09:56:42 <dhun_233> not the memory consuption seems to be stable at 600 MByte
09:57:06 <itasyno> paolino: the packages I installed as dependecies are in my local pkg dir (under ~/.cabal)
09:57:22 <dhun_233> now the ...
09:57:27 <itasyno> I don't want cabal to install the packages into system dirs, but I do want to Xmobar into system dirs.
09:58:02 <dhun_233> Heap exhausted;
09:58:25 <dhun_233> so well I have to look for a machiene with more ram
09:58:44 <monochrom> rent one on amazon or something :)
09:59:08 <dhun_233> yes pooibly
09:59:13 <Botje> paolino: sorry, have to go. I'll be back in ~ three hours, but i'm sure you can find help from other people here by then :)
09:59:25 <statusfailed> monochrom: ok, thanks :)
10:04:25 <applicative> itasyno: will it go wrong if you just cabal install xmobar --user and then symlink it to /usr/local/bin or whatever?
10:07:31 <itasyno> applicative: l suppose not. But I'd rather not symlink into the system directory like that. I'm confused why this approach isn't working. ghc-pkg --list say I haev parsec and stm installed in my local pkg dir, so runhaskell should be able to see that, I thought.
10:09:43 <applicative> sudo cabal install xmobar --global  should do it but I'm wondering if it will want the necessary libraries also to be in the global setup. I can't remember how that works.
10:10:36 <applicative> if not then there's nothing to be said against it since it's just an executable
10:12:54 <The_Journey> what are some Haskell techniques that I can use to increase modularity in my program?
10:13:59 <mike-burns> Test-driven development.
10:14:11 <Kanisterschleife> Saizan: Can you provide a type class C, a fixed type c and a value for the type 'forall a. (C a) => c'?
10:14:43 <kmc> The_Journey, modules
10:14:47 <applicative> polymorphism?
10:15:07 <mike-burns> I also recommend software engineering.
10:15:09 <hpc> The_Journey: higher-order functions
10:15:32 <applicative> The_Journey: I think  the question could use a bit of development, maybe
10:15:57 <Saizan> Kanisterschleife: one that's non-constant on 'a'?
10:16:16 <Kanisterschleife> Saizan: I even cannot define a constant one in ghci.
10:16:36 <Saizan> ?type () :: forall a. Show a => ()
10:16:37 <lambdabot>     Ambiguous constraint `Show a'
10:16:37 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
10:16:37 <lambdabot>         must be reachable from the type after the '=>'
10:16:47 <Kanisterschleife> yea :)
10:17:07 <Saizan> ?type let f :: forall a. Show a => (); f = () in f
10:17:08 <lambdabot>     Ambiguous constraint `Show a'
10:17:08 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
10:17:08 <lambdabot>         must be reachable from the type after the '=>'
10:17:14 <Saizan> oh right
10:17:42 <Kanisterschleife> That's a bit strange, because, again mathematically / intuitively thinking, one would expect that one can "restrict" the constant function in c = forall a. c so the "subclass" C a of "forall a", though strictly speaking this doesn't make sense
10:17:53 <tsousa> i read 6 chapters of LYAH. what should i do next?
10:17:54 <Kanisterschleife> so the -> to the
10:17:55 <applicative> is there a clear definition of 'modularity' as a desideratum? Robert Harper says, obviously we need it, so obviously we need ML since it has such excellent modules
10:18:09 <Saizan> Kanisterschleife: i guess they added this check because something of that type is not usable
10:18:14 <mike-burns> tsousa: Write code, put it on Hackage.
10:18:48 <tsousa> mike-burns, i did some math stuff but it already duplicated
10:18:55 <tsousa> should i do more reading?
10:19:04 <tsousa> buy Real World Haskell?
10:19:12 <mike-burns> Write more code!
10:19:23 <iorivur_> how can I know which cabal package include xxxx where I miss xxxx when compiling with "import xxxxx"?
10:19:25 <mike-burns> I mean, if you prefer reading to writing, I do recommend RWH.
10:19:28 <applicative> it sounds like you need a project tsousa.
10:19:40 <applicative> @where rwh
10:19:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:19:45 <Saizan> iorivur_: use hayoo or hoogle
10:19:47 <tsousa> applicative, yeh
10:19:58 <iorivur_> Thanks, Saizan
10:20:42 <kmc> tsousa, http://prog21.dadgum.com/80.html
10:21:25 <Kanisterschleife> Saizan: In case you can't hear the question anymore, tell me and I'll shut up. Case _: Do you agree that when one had the possibility to directly instantiate free type variables, then there would be no need to exclude the things from above? Are there languages with direct instantiation of free type variables?
10:21:49 <mike-burns> kmc: That's a great post!
10:22:43 <kmc> i don't 100% agree with it
10:23:09 <mike-burns> I mostly agree with it.
10:23:28 <tsousa> kmc, i would like to help in xmoand but my knowlodge of Haskell is not great
10:24:09 <mike-burns> I bet #xmonad would love to point you in the right direction.
10:24:17 <Saizan> Kanisterschleife: yes, there would be no need to exclude f :: forall a. Show a => () (and it'd be very different from ()), and yes there are languages like that e.g. Agda
10:24:27 <kmc> tsousa, try to do something, get confused, read or ask here about it
10:24:41 <Saizan> Kanisterschleife: but also the System F calculus, though i'm not sure if you consider that a language :)
10:24:58 <Kanisterschleife> Saizan: I don't know what I consider a language either :)
10:25:07 <applicative> if you use xmonad, xmonad-contrib has no end of possibilities for expansion
10:25:25 <tsousa> kmc, do you think i should learn monad and that kind of stuff
10:25:31 <kmc> you should keep reading LYAH
10:25:33 <Saizan> (these don't have typeclasses but you can use record types as i described above)
10:25:46 <kmc> it gets to monads eventually
10:26:09 <kmc> one reason monads have this fearsome reputation is that everyone gets excited and jumps ahead to learn about them before they're ready
10:26:12 <kmc> so, don't do that ;)
10:26:20 <Saizan> Kanisterschleife: well, System F is a minimal language used in research, not one meant for everyday programming
10:26:29 <Kanisterschleife> Saizan: sounds cool
10:26:47 <kmc> System F is like the simplest polymorphic lambda calculus
10:26:55 <kmc> (typed lambda calculus, that is)
10:26:56 <tsousa> kmc, thanks
10:29:03 <Saizan> Kanisterschleife: btw a way to emulate explicit instantiation is with a proxy type: data Proxy a = Proxy; f :: forall a. Show a => Proxy a -> () would work, and you could instiatiate like this: f (Proxy :: Proxy Int)
10:29:15 <Saizan> *instantiate
10:29:43 * hackagebot http-enumerator 0.7.2.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.2.2 (MichaelSnoyman)
10:31:11 * mike-burns re-writes his libraries to use http-conduit.
10:31:34 <applicative> how is that going? is it as orderly as it is supposed to be?
10:31:38 <Fuco> is it possible to make data Tree a = Empty | Node a [Tree a] instance of Foldable? I can't seem to figure it out, trying to implement foldr but I end up with "f a [b]" (my implementation is something like treefold f v (Node x s) = f x "something" (map (treefold f v) s) and the something part is impossible I think :D
10:32:09 <kmc> Fuco, did you see the example here: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.3.1.0/Data-Foldable.html
10:32:19 <mike-burns> I haven't played with Conduit yet. About to dive in, I supose.
10:32:40 <Fuco> kmc: well that's binary tree
10:32:52 <applicative> mike-burns, I was fiddling with it, just to see how it was different
10:32:58 <kmc> sure, it might be similar though ;)
10:33:34 <mike-burns> Now that http-enumerator is deprecated I'm basically forced to learn conduit.
10:34:21 <applicative> it seems to suit me better than enumerator, but I think this may be a discredit to my brain. i like snoyman's haskell, it is very readable and straightforward
10:34:34 <mike-burns> His blog posts are very clear, too.
10:34:43 * hackagebot xml-enumerator 0.4.4.1 - Pure-Haskell utilities for dealing with XML with the enumerator package. (deprecated)  http://hackage.haskell.org/package/xml-enumerator-0.4.4.1 (MichaelSnoyman)
10:34:45 * hackagebot uri-enumerator 0.1.0.1 - Read and write URIs (deprecated)  http://hackage.haskell.org/package/uri-enumerator-0.1.0.1 (MichaelSnoyman)
10:34:45 <mike-burns> The documentation is the biggest selling point.
10:34:47 * hackagebot uri-conduit 0.2.0 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.2.0 (MichaelSnoyman)
10:35:01 <applicative> and very productive ^^^
10:35:17 <mike-burns> Hah, he's just deprecating everything.
10:35:46 <aristid> applicative: snoyman's haskell doesn't use very many higher-order functions, interestingly
10:36:15 <applicative> true, aristid, there is a lot of monads on  monads that's the type of sophistication
10:36:26 <aristid> applicative: indeed :P
10:36:40 <Fuco> well [] is foldable in itself so I guess if I fold Tree a into b and then [b] into c... but if I only give it one function (a->b->b) it won't work
10:36:50 <Fuco> I can only define it for (a->a->a) and that's useless
10:36:52 <aristid> applicative: i didn't mean it in a derogatory way at all.
10:36:52 <applicative> but he has a method of controlling complexity, I noticed studying some of conduit. I didn't tend to get lost.
10:37:46 <applicative> aristid: I didnt think you did. I certainly think it is a sound approach, especially given the idea of the yesod framework of whatever
10:38:00 <byorgey> Fuco: oh, define foldMap instead of foldr, it's much easier
10:38:06 * ezyang is still pretty unhappy that conduits use mutation under the hood 
10:38:12 <byorgey> Fuco: and you only need one of those two
10:38:39 <Fuco> ok, I'll try
10:38:39 <aristid> hey byorgey i read your species paper recently, and it was awesome, but i also thought that haskell is not the right language for this stuff
10:38:52 <byorgey> aristid: I agree, I'd much rather be doing it in Agda
10:39:04 <aristid> byorgey: but?
10:39:26 <applicative> ezyang, yes, but one is spared a lot of mental strain ...
10:40:02 <byorgey> aristid: but I want to use species to make practical tools that will impact functional programmers right now.
10:40:21 <hpaste> kmc pasted âTree foldMap (for Fuco)â at http://hpaste.org/55996
10:40:22 <byorgey> Agda is great but it does not yet qualify as practical.
10:40:32 * applicative can't commit to any of these post-lazy-io schemes
10:40:37 <ezyang> applicative: I think the removal of inversion of control is what is really sparing the mental strain.
10:40:47 <aristid> byorgey: i don't know how i could use enumerate practically (and the species package doesn't compile)
10:41:17 <byorgey> aristid: I know.  I'm going to fix it soon.
10:41:19 <applicative> ezyang, yes, but is that depraved in principle, or just because here he's using iorefs and so on.
10:41:33 <byorgey> aristid: basically I have just recently switched back to working on species for my dissertation
10:41:36 <kmc> ezyang, I'm happy that a prominent Haskell programmer had the guts to say "hey, in this case, mutation makes the design nicer"
10:41:46 <kmc> but I haven't studied the design enough to say whether it's really nicer ;)
10:41:50 <byorgey> aristid: so you can expect lots more soon (and much more practical things than just 'enumerate')
10:42:03 <Fuco> and what it a is not Monoid instance?
10:42:07 <aristid> byorgey: cool!
10:42:14 <kmc> Fuco, ?
10:42:27 <applicative> hi HURR_DURR
10:42:32 <Fuco> well then you can't use mappend, and mempty
10:42:35 <kmc> Fuco, the Foldable class defines foldr in terms of foldMap, and vice versa
10:42:35 <HURR_DURR> HURR
10:42:57 <byorgey> Fuco: no, foldMap says if you have a function that can make a's into m's where m is a Monoid, then you can fold the structure
10:43:01 <byorgey> it doesn't require a to be a Monoid
10:43:04 <kmc> foldMap :: Monoid m => (a -> m) -> t a -> m
10:43:11 <kmc> foldr f z t = appEndo (foldMap (Endo . f) t) z
10:43:21 <aristid> HURR_DURR: http://www.youtube.com/watch?v=RAx0P-8n5K4
10:43:23 <Fuco> yea I'm looking at the soruce right now
10:43:36 <ezyang> kmc: As far as I can tell, the mutation is unnecessary in the case of Conduits and Sinks.
10:43:37 <Fuco> Endo is a class of stuff that can map to itself I guess?
10:43:42 <kmc> it's not a class
10:43:51 <byorgey> @src Endo
10:43:51 <lambdabot> Source not found.
10:43:56 <kmc> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.3.1.0/Data-Monoid.html#t:Endo
10:44:08 <kmc> newtype Endo a = Endo { appEndo :: a -> a }
10:44:13 <Fuco> ah
10:44:25 <byorgey> the monoid of endofunctions under function composition.
10:44:27 <HURR_DURR> aristid: DURR
10:44:38 <kmc> which is mostly the same as:   newtype Endo a = Endo (a -> a);  appEndo (Endo x) = x
10:44:53 <kmc> more suggestively:  appEndo (Endo f) x = f x
10:46:45 <Fuco> ah well
10:47:30 <Fuco> now how the hell am I going to explain this to my sister :D (she's in some intro haskell class)
10:47:58 <byorgey> Fuco: explain what?
10:48:10 <HURR_DURR> Fuco: I got sucked into haskell from a very similar situation. Beware
10:48:19 <kmc> presumably you don't have to explain how foldr is implemented in terms of foldMap
10:48:23 <kmc> since that's done for you
10:48:27 <Fuco> true
10:48:28 <HURR_DURR> in a couple of years, you might be saying things like HURR and DURR if you're not careful
10:48:38 <applicative> GURR
10:48:57 <HURR_DURR> :O
10:50:13 <applicative> So in the end when one is doing <Haskell> one gets to the point where one would like just to emit an inarticulate sound -- Wittgenstein
10:51:31 <applicative> ezyang, you should write a brilliant critique of conduits, it would help us understand what is going on
10:53:49 <ezyang> applicative: I'm having a conversation with Snoyman right now. I want to give him a chance to turn it into praise.
10:54:05 <jeff_s_> Is TVar just a wrapper for TMVar, where readTVar is readTMVar?
10:54:24 <c_wraith> jeff_s_: nope.  TMVar is built with TVars
10:54:33 <jeff_s_> Ah, ok thanks.
10:54:49 <applicative> i see. I was just thinking you
10:55:16 <applicative> sorry, I meant: I see, I will be interested to find out your result.
11:00:30 <kmc> jeff_s_, http://lambda.haskell.org/platform/doc/current/packages/stm-2.2.0.1/doc/html/src/Control-Concurrent-STM-TMVar.html
11:00:49 <jeff_s_> kmc: Thanks for ht elink!
11:01:39 <kmc> jeff_s_, note the use of 'retry'; this is basically how STM gives the user control over blocking
11:02:44 <kmc> it would be harder to implement, say, MVar using IORef, because you don't have a way to block until some IORef changes
11:03:31 <jeff_s_> Ya, you would have to poll for the IORef to change, which would be nasty.
11:03:40 <kmc> yeah
11:03:49 <kmc> STM basically lets you write polling code, and implements it more efficiently
11:04:02 <kmc> that's one of the composability benefits
11:05:22 <jeff_s_> I was going to use normal MVars, but my application requires reading often and writing hardly ever, so TVar sounded like it would have lower overhead, even though STM involves a log. I'll play with it and see.
11:06:40 <kmc> i don't know the read overhead of MVar
11:07:28 <lpsmith> Yeah,  i wouldn't worry too much about the read overhead of an MVar,  they are pretty cheap
11:07:42 <kmc> i would benchmark it :)
11:07:48 <kmc> and by 'would' i mean will do so in a few minutes
11:08:16 <jeff_s_> I benchmarked TMVar vs MVar, but didn't know about TVar at the time.
11:08:28 <kmc> did you use Criterion?
11:08:45 <jeff_s_> Hm, I guess not.
11:10:04 <jeff_s_> What is Criterion?
11:10:21 <kmc> the best benchmarking library i've seen for any language
11:10:24 <kmc> http://hackage.haskell.org/package/criterion
11:10:25 <JuanDaugherty> somekina hs profiler I guess
11:10:35 <kmc> it's not a profiler
11:10:39 <kmc> but thank you for your guess
11:10:52 <jeff_s_> I love Haskell version numbers. 0.6 is a mature product.
11:11:28 <Fuco> so when I have f :: (a -> b -> b) Endo . f makes it into a -> Endo b (Endo b being monoid) so the foldMap (a -> m) really is a -> Endo b which really is a -> b -> b right?
11:11:44 <kmc> open source is like that in general
11:11:51 <Kanisterschleife> What's wrong with 'check = (=~) "*:2,*S*" :: (String -> Bool)'? I can define it, but when I do 'check "dummy"' I get the error 'Exception: user error (Text.Regex.Posix.String died: (ReturnCode 13,"Invalid preceding regular expression"))'
11:12:05 <JuanDaugherty> yeah, I see, makes purty piktures
11:12:23 <HURR_DURR> Kanisterschleife: looks like an invalid regexp
11:12:44 <HURR_DURR> Kanisterschleife: did you mean .*?
11:12:47 <HURR_DURR> instead of *
11:12:55 <hpaste> kmc pasted âsimplistic MVar vs. TMVar benchmarkâ at http://hpaste.org/55997
11:13:00 <Kanisterschleife> HURR_DURR: hm, I want * to represent an arbitary string
11:13:06 <HURR_DURR> then .*
11:13:23 <kmc> this is simplistic in a bunch of ways
11:13:26 <HURR_DURR> * is a modifier that says "0 or more times"
11:13:28 <sefb1704> hello
11:13:33 <kmc> one thread only, no writers
11:13:37 <HURR_DURR> . accepts any character
11:13:43 <kmc> also the TMVar case includes the overhead of starting and completing a transaction
11:13:49 <jeff_s_> That's good enough to get me started, though.
11:14:04 <Kanisterschleife> HURR_DURR: ah, I remember :-) thank you!
11:14:41 <kmc> Fuco, sounds right
11:14:59 <applicative> hello sefb1704
11:15:00 <kmc> you're trying to understand the implementation of foldr using foldMap?
11:15:28 <lpsmith> oh,  and does anybody know why hackage has stopped building documentation?
11:15:33 <Fuco> kmc: yea
11:15:43 <c_wraith> lpsmith: has it been more than a day?
11:15:50 <Fuco> now that I stumbled upon it I can't just let it go :D
11:16:03 <lpsmith> c_wraith, it's been like 3 or 4 days since hackage stopped building docs
11:16:18 <Fuco> altho I have crapload of calculus to do @_@ damn you haskell, why are you so interesting
11:16:25 <c_wraith> lpsmith: huh.  that makes it sound like it has a broken install of something haddock depends on
11:17:39 <irene-knapp> @hoogle attribute
11:17:40 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState AccumBufferAttributes :: ServerAttributeGroup
11:17:40 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState AllClientAttributes :: ClientAttributeGroup
11:17:40 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState AllServerAttributes :: ServerAttributeGroup
11:17:42 <irene-knapp> hm
11:19:03 <applicative> oh no, haskell has been overtaken by something called ASP as n-th most popular language on github. this is wrong.
11:19:09 <kmc> oh noes
11:19:37 <yrlnry> Was it SPJ who said that Haskell's motto was "failure at any cost"?
11:19:38 <nand`> applicative: quality over quantity I guess
11:19:48 <kmc> all those ASP programmers should stop making useful websites and gobs of money, because they're using the wrong tool!
11:19:51 <hpc> yrlnry: avoid success
11:20:02 <yrlnry> thanks.
11:20:28 <hpc> yrlnry: as long as haskell hasn't succeeded, it has a certain amount of freedom to make fundamental changes
11:20:40 <hpc> it has failed at avoiding success :P
11:21:08 <lpsmith> c_wraith, yeah, sometime between Tue Dec 27 and Fri Dec 30 the hackage server stopped building documentation
11:21:27 <sefb1704> when i create a 'data' like this: data item = knife | wood, how do i tell haskell that these are integers?
11:21:32 <lpsmith> though I can't easily narrow it down because I don't know which packages were uploaded between those points in time
11:21:34 <c_wraith> lpsmith: you're going to need to find an admin of the machine, then.  Someone will need to look in the logs
11:21:38 <kmc> sefb1704, you can't
11:21:43 <applicative> sefb1704: but they aren't integers
11:21:51 <c_wraith> lpsmith: isn't there an rss stream for new uploads you can check?
11:21:56 <hpc> sefb1704: by making a data type, you are explcitly stating that they are not integers
11:22:00 <applicative> sefb1704: besides you need capitals there
11:22:03 <kmc> sefb1704, what are you really trying to do
11:22:03 <BMeph> Has anyone written a haddock tutorial? I'm not sure more to get cabal to link all of the documentation together.
11:22:05 <hpc> sefb1704: if they are integers, define them as integers
11:22:13 <hpc> sefb1704: if you want to convert them, derive Enum
11:22:16 <lpsmith> c_wraith, that rss stream has been broke for like,  9 months
11:22:21 <c_wraith> oh.  hah.
11:22:23 <sefb1704> okey i am the guy programming this haskell adventure game
11:22:27 <c_wraith> where does hackagebot draw from?
11:22:30 <lpsmith> or at least, the haskell.org website wasn't updating
11:23:04 <sefb1704> and you told me to make a data item = knife wood bla bla and then make a list of item and when i then want to check if i got the knife in my inventore i say if knife 'elem' items
11:23:13 <kmc> yeah, so why do you need integers
11:23:21 <lpsmith> ok, the haskell.org front page "recent packages" is actually only like a week or so old at this point.
11:23:25 <applicative> sefb1704: you can write e.g. a Num instance, though it would be a little strange.  But a function toInt :: Item -> Int ; toInt Knife = 0 ... is okay
11:23:27 <sefb1704> well, they can also be booleans
11:23:30 <hpc> sefb1704: first, it's backticks
11:23:32 <kmc> why can't they be Items?
11:23:41 <kmc> i think you don't understand the point of defining new data types
11:23:48 <lpsmith> ok, the problem is not the rss stream itself.
11:23:56 <kmc> the point is that they are new, and are different from the existing ones like Bool and Int
11:23:57 <kmc> you should read a Haskell tutorial
11:24:06 <lpsmith> It might be easiest to look in my irc logs for lambdabot announcements
11:24:20 <lpsmith> who is a hackage admin?
11:25:16 <kmc> sefb1704, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
11:25:35 <sefb1704> basically i know what data and type is. why is it bad to say that an item is a knife, a wood or something else and then make a list of items and see if a knife exist in the list of items?
11:25:43 <kmc> that's good, not bad
11:25:51 <kmc> but why should they be integers
11:26:23 <kmc> if you say Â«data Item = Knife | WoodÂ» then you have defined a new type named Item
11:26:25 <sefb1704> im not sure :/
11:26:29 <kmc> it's not the same as Int, and it's not the same as Bool
11:26:35 <kmc> the values in that type are Knife and Wood
11:26:36 <sefb1704> ah okey
11:26:41 <kmc> they have type Item; they will never have type Int or Bool
11:26:49 <sefb1704> its starting to make sense ..
11:26:51 <kmc> you can use them and pattern-match them like you would Bool or other types
11:26:52 <ion> Knife `mappend` Wood
11:26:56 <sefb1704> okey thanks i think i got what i need
11:26:56 <kmc> again, you should read a Haskell tutorial
11:27:04 <sefb1704> kmc, ok
11:27:42 <mike-burns> And you can use   elem   to know if an element is in a list.
11:28:00 <sefb1704> anyone who wants to play version 0.7 of my haskell adventure game? ^^
11:28:03 <mike-burns> Hah.
11:28:27 <mike-burns> Though if you use  elem  often and you have a very, very long list, you may want to consider a different data structure. Maybe.
11:28:53 <sefb1704> mike-burns, okey i will see what i can do
11:29:01 <kmc> like Data.Set
11:29:12 <kmc> but i think don't worry about that just yet
11:29:26 <sefb1704> i have 6 items upto now.
11:29:35 <mike-burns> Yeah you're good with the list.
11:29:38 <mike-burns> Get it working first.
11:32:36 <sefb1704> okey one question, i got pattern matching and with pattern matching and my list of integers its very easy to match something like this (0:0:1:0), but how do i do pattern matching with this 'elem' and the list of items?
11:32:52 <xplat> sefb1704: when you get STAB TROLL WITH KNIFE working, come back looking for playtesters :)
11:32:59 <hpc> (Knife:Wood:items)
11:33:11 <kmc> sefb1704, you probably want to use guards instead of pattern-matching
11:33:21 <sefb1704> xplat, is kill the bear with knife enough? ^^
11:34:42 <sefb1704> kmc, using guards would make this very complicated vor me i think. first im not used to guards and second, i use alot of "do" .. i think this doesnt look nice with guards
11:35:05 <kmc> "first im not used to guards"  this can be solved by reading a haskell tutorial
11:35:12 <xplat> sefb1704: like case inv where items | Knife `elem` items = putStrLn "The knife in your belt slides into the thin plastic, turning your raft into an overpriced rain poncho."
11:35:18 <applicative> @where lyah
11:35:19 <lambdabot> http://www.learnyouahaskell.com/
11:35:30 <applicative> sefb1704: ^^^ super goodness
11:36:18 <applicative> xplat is really confusing me
11:36:27 <sefb1704> me 2
11:36:31 <xplat> the advantage of using elem is you don't get results that depend on where the player picked up the knife
11:37:12 <xplat> applicative: i was giving an example of a guard
11:38:37 <irene-knapp> :t sequence
11:38:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:39:08 <giorgiob> Hello
11:40:02 <applicative> good day giorgiob; what are your expected and intended types?
11:40:24 <giorgiob> What do you mean?
11:40:39 <JuanDaugherty> he was joking
11:40:44 <xplat> applicative is really confusing me
11:40:48 <applicative> giorgiob: i was just imagining you were confronting an opaque type error
11:40:58 <applicative> xplat, !
11:41:28 <applicative> giorgiob: and that you wanted #haskell to sort out those mysterious types
11:41:32 <giorgiob> No I am not. I have just entered this channel for the first time. Maybe the joke about types has to do with h
11:41:40 <giorgiob> Haskell types?
11:41:48 <srhb`> A fair chance.
11:41:57 <applicative> yeah, I regret it. xplat  has convinced me
11:42:31 <applicative> but giorgiob what do you want to know?
11:42:49 <mike-burns> He'll want us to sort out his types in no time.
11:43:38 <giorgiob> I am interested in Haskell in general.
11:43:54 <giorgiob> I have some basic knowledge but I would like to learn more.
11:43:56 <mike-burns> @where lyah
11:43:56 <lambdabot> http://www.learnyouahaskell.com/
11:44:02 <giorgiob> I do not have precise questions right now.
11:44:06 <mike-burns> ^ There's a highly-recommended place to learn more.
11:44:12 <mike-burns> @where rwh
11:44:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:44:20 <mike-burns> ^ That's my recommendation.
11:44:29 <giorgiob> I would like to just read what is being discussed
11:44:34 <giorgiob> I have the book already
11:44:36 <giorgiob> :-)
11:44:44 <chrisdone> can i catch a KillThread exception and ignore it?
11:44:46 <giorgiob> I have already written some simple tools in Haskell
11:44:55 <srhb`> This is kind of funny, new person enters room and is immediately asked by seven people if he needs helps - politely declines.
11:45:11 <mike-burns> We're overly helpful today.
11:45:12 <srhb`> The world is all upside down.
11:45:13 <giorgiob> Thanks
11:45:25 * mike-burns slinks away.
11:45:34 <homie> wait until it turns downside up!
11:45:38 <homie> lol
11:45:43 <chrisdone> well, i know i can catch it. but does some kind of clean-up commence behind the scenes in ghc? i'd assume the scheduler just wats until the thread's ended rather than looking at exceptions
11:45:48 <giorgiob> Some kind of reverse being applied here
11:45:50 <JuanDaugherty> yes, saying "Hello" in a channel with over 800 users, that's what did it
11:46:32 <chrisdone> e.g. E.catch (readMVar v) (\e -> case KillThread of _ -> go; _ -> throw e)
11:47:41 <JuanDaugherty> I was gonna tell him you're usually not like that but didn't get a cha ...
11:47:42 <chrisdone> actually nevermind. i'll let the thread die, like the evil man i am
11:48:29 * chrisdone . o O ( where's my flying lambda case syntax? )
11:48:46 * hpc wants a picture of a flying lambda
11:49:00 <hpc> possibly in the "Fringe" floating text font
11:49:19 <srhb`> hpc: http://www.flickr.com/photos/oneearedrabbit/5822169305/
11:49:31 <srhb`> The text is... Oddly matching for a random google image search.
11:49:33 <hpc> delightful!
11:50:17 <danr> srhb`: hmm looks a bit like an y too, but really nice :)
11:50:24 <srhb`> I didn't make it.
11:50:31 <srhb`> (But yes, it is.)
11:50:32 <chrisdone> hpc: âESPâ âtime travelâ âlambda calculusâ âtelekinesisâ âcorecursionâ
11:51:15 <chrisdone> H  A  S  K  E  L  L
12:02:28 <tsousa> can someone please explain me this type declaration. http://pastebin.com/QJ2MTk4A ?
12:02:30 <mauke> The paste QJ2MTk4A has been copied to http://hpaste.org/55998
12:03:27 <lukish> How can I figured out, that all elements in list is >=0 or all of them <=0 ?
12:03:37 <hpc> :t all
12:03:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:04:13 <fryguybob> tsousa: Record syntax section here might be helpful: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
12:04:40 <tsousa> fryguybob, what i am not understarding is the {}
12:04:59 <lukish> all (<0 ) [-1,-1,...]
12:05:06 <lukish> > all (<0 ) [-1,-1..]
12:05:10 <lambdabot>   mueval-core: Time limit exceeded
12:05:16 <lukish> > all (< 0) [-1,-1]
12:05:17 <lambdabot>   True
12:05:23 <lukish> > all (>= 0) [1,1]
12:05:24 <lambdabot>   True
12:05:39 <hpc> > any (not . null) [[],[],[],"not an empty list"]
12:05:41 <lambdabot>   True
12:05:46 <lukish> > all (\x -> (x >= 0) or (x < 0)) [1,1]
12:05:46 <lambdabot>   Couldn't match expected type `t -> t1 -> GHC.Bool.Bool'
12:05:47 <lambdabot>         against inf...
12:06:33 <irene-knapp> :t catMaybes
12:06:34 <lambdabot> forall a. [Maybe a] -> [a]
12:06:37 <lukish> > all (\x -> (x >= 0) || (x < 0)) [1,1]
12:06:37 <irene-knapp> :t mapMaybe
12:06:38 <lambdabot>   True
12:06:38 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
12:06:46 <lukish> > all (\x -> (x >= 0) || (x < 0)) [1,-1]
12:06:46 <lambdabot>   True
12:06:55 <lukish> How can I get False?
12:07:06 <mux> with a condition that is not always true?
12:07:28 <lukish> Read my question earlier
12:07:35 <fryguybob> tsousa: There are examples on the page I linked with a good explanation.  The {}'s let you bind names for functions that get values from the data.
12:07:50 <srhb`> One thing I've wondered - why is it `mplus` for MonadPlus and not +?
12:07:59 <Axman6> lukish: your question makes no sense
12:08:13 <sefb1704> :D
12:08:14 <byorgey> > (\l -> all (>=0) l || all (<=0) l) [1,-1] -- lukish
12:08:15 <lambdabot>   False
12:08:24 <Axman6> srhb`: because (+) is for numbers
12:08:34 <chrisdone> srhb`: monadpluses aren't Nums so it wouldn't make sense
12:08:40 <irene-knapp> > (\xs -> all (>= 0) xs || all (< 0) xs) [1,1]
12:08:41 <lambdabot>   True
12:08:44 <irene-knapp> > (\xs -> all (>= 0) xs || all (< 0) xs) [1,-1]
12:08:45 <lambdabot>   False
12:08:47 <irene-knapp> thusly
12:08:54 <lukish> Okay
12:08:56 <irene-knapp> oh, byorgey beat me to it
12:08:58 <McManiaC> what do you guys think of this GHC extension proposal? http://npaste.de/fn/
12:09:07 <srhb`> So while I'm thinking of (+) as being "overloaded" for lack of a better term, this is a wrong way to think of it?
12:09:14 <lukish> :pl  (\l -> all (>=0) l || all (<=0) l)
12:09:19 <tsousa> from what i am reading it only declares the tyoe
12:09:21 <ClaudiusMaximus> > let nan = 0/0 in all (\x -> x >= 0 || x <= 0) [nan]
12:09:22 <lambdabot>   False
12:09:38 <lukish> :pl (\l -> all (>=0) l || all (<=0) l)
12:09:59 <Axman6> McManiaC: what's the point?
12:10:18 <Axman6> srhb`: it is overloaded by the use of type classes
12:10:40 <byorgey> McManiaC: seems very strange to me.  Why use the keyword 'do'?  And what does this really buy you over existing ways to work with monoids?
12:10:42 <hpaste> sefb1704 pasted âtestcodeâ at http://hpaste.org/55999
12:10:58 <srhb`> Axman6: Ah, and Monadplus is NOT an instance of Num, therefore...
12:11:18 <McManiaC> Axman6: use this instead of do-notation exploits for stuff like blaze-html
12:11:26 <sefb1704> this doesnt work, i wrote additional information in the code. i dont know why this doesnt work, i hope you do
12:11:38 <McManiaC> byorgey: as I wrote below, the `do` keyword is only there because I havent touched the parser at all
12:12:11 <gwern> @quote
12:12:11 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
12:12:15 <gwern> @quote
12:12:15 <lambdabot> skew says: We don't believe in constant factors.
12:12:18 <gwern> phew
12:13:01 <byorgey> McManiaC: Those exploits are silly.  I see no need to legitimize them.  Really, what's wrong with just defining (<>) = mappend  and putting  <>  at the beginning of each line?
12:13:30 <byorgey> also, if you were going to do this it ought to be for Semigroup instead of Monoid.
12:13:40 <byorgey> your monoid-do-notation does not make use of 'mempty' at all.
12:14:52 <byorgey> sefb1704: 'function' needs two arguments.  you have  main = function [Knife]  but you need to also give it a String.
12:15:04 <McManiaC> byorgey: the point of those exploits is that a <> at the beginning of *every* line is kind of "bloaty"
12:15:24 <McManiaC> it's the same reason why haskell has whitespace notation
12:15:36 <HURR_DURR> McManiaC: then use mconcat [
12:15:37 <McManiaC> instead of the do { .. ; .. }
12:15:37 <HURR_DURR> moo
12:15:56 <McManiaC> byorgey: your Semigroup point is valid tho
12:16:03 <byorgey> McManiaC: now, what I *could* get behind is layout syntax for list literals.
12:16:09 <byorgey> that would be much more general.
12:16:20 <sefb1704> byorgey oh damn, right
12:16:22 <McManiaC> byorgey: for example?
12:16:52 <byorgey> McManiaC: I mean a way to write list literals where the [ , ]  are optional, just like { ; } is optional for do-blocks
12:17:27 <byorgey> McManiaC: then you could write  'mconcat' followed by a list written using layout to get essentially the same thing as your proposed extension
12:18:03 <McManiaC> byorgey: lists are already monoids
12:18:15 <jeff_s_> byorgey - I think I remember learning that you can use do notation instead of list ... are list literals the same thing as list comprehensions?
12:18:38 <McManiaC> even though right now the monad-instance will "overwrite" the monoid thingy
12:18:42 <byorgey> jeff_s_: you can use do-notation instead of list comprehensions
12:19:47 <McManiaC> jeff_s_: basically what byorgey said, but there are a couple of extensions for list (and monad) comprehensions which don't translate that easily to do-notation
12:19:57 <jeff_s_> Ah, ok.
12:20:04 <McManiaC> grouping e.g.
12:20:05 <aristid> copumpkin: oh that was you?
12:20:14 <copumpkin> HURR
12:20:19 <aristid> copumpkin: i hope you enjoyed my HURZ video :D
12:20:25 <copumpkin> totally
12:20:25 <byorgey> McManiaC: yeah, I guess in some sense the proposals are "equivalent" since lists are free monoids.  But I still think layout syntax for lists seems more "primitive" than do-blocks for monoids.
12:20:40 <aristid> probably not due to the language barrier. oh well, everybody should just learn german.
12:21:04 <copumpkin> ganz
12:21:25 <McManiaC> byorgey: but why limit it to lists?
12:22:10 <byorgey> McManiaC: it's not limiting.  lists are the "most general" monoid, so you can always prepend 'mconcat' to recover any monoidal semantics
12:22:26 <aristid> copumpkin: so did you understand it or not? :D
12:22:30 <copumpkin> nope
12:22:53 <aristid> copumpkin: it didn't make any sense anyways. but HURR reminded me of HURZ :)
12:23:13 <byorgey> McManiaC: also, the list thing sidesteps the whole issue re: Monoid vs Semigroup
12:23:41 <McManiaC> hmhm
12:24:04 <copumpkin> aristid: ah :)
12:25:32 <byorgey> McManiaC: I don't know, the longer we've discussed this the more I'm realizing there's not a whole lot of difference between our positions =)
12:26:06 <byorgey> McManiaC: certainly we need something other than 'do', and I don't like 'mdo' either (even if it wasn't already taken)
12:26:19 <byorgey> the idea of "do"ing something fits well with monads but not monoids
12:26:36 <fryguybob> don't
12:26:45 <byorgey> hehe
12:26:59 <byorgey> that's already taken too
12:27:02 <McManiaC> byorgey: yeah
12:27:02 <byorgey> @package acme-dont
12:27:02 <lambdabot> http://hackage.haskell.org/package/acme-dont
12:27:49 <alistra> if i were to search the internet for some way to minimize if and case statement depths, what keywords should i google for?
12:28:03 <xplat> it should definitely be introduced by a keyword other than 'do', whether it's for lists, monoids, semigroups, whatever
12:28:19 <xplat> the ad-hoc overloading is horrible
12:28:22 <Philonous> "don't"
12:28:40 <McManiaC> xplat: agreed :)
12:29:14 <hughfdjackson> that package
12:29:15 <hughfdjackson> genius
12:31:42 <xplat> why hasn't it built under 7.2?
12:40:48 <ehuber_> hey all. I'm reading a tutorial about template haskell @ https://doc-0s-08-docs.googleusercontent.com/docs/securesc/5t6ihi3nbfd9viibb1c5id5kc38do784/r6sq8f12i0n5jr030h8qa7thpdov12bc/1325538000000/10578434965449041783/09238471969519345631/0B4BgTwf_ng_TM2MxZjJjZjctMTQ0OS00YzcwLWE5N2QtMDI0YzE4NGUwZDM3?nonce=j65jfs2h1cmnk&user=09238471969519345631&hash=sfc3ktqad5ivncsa48rt1vlsidvrpmq0 , and it claims "you can't define a function in a
12:42:00 <ehuber_> http://hpaste.org/56000
12:42:13 <ehuber_> g evaluates to 47 in ghci
12:42:55 <parcs`> what is the best way of mapping C enums to haskell values?
12:43:04 <ehuber_> c enums?
12:43:21 <hpc> ehuber_: sure, like int, char, short
12:43:22 <hpc> :P
12:43:34 <ehuber_> haha, sorry i am stuck in the past
12:43:51 <hpc> i don't know of any C enums either :P
12:44:11 <ehuber_> parcs`: i have done this in the past:  "handledOK = HandledStatus (#{const OK})"
12:44:25 <ehuber_> and i am certain that someone will chime in now about how that is a bad way to do it :)
12:44:42 <ehuber_> where HandledStatus Int is a constructor.
12:44:51 <ehuber_> CInt :P
12:45:05 <parcs`> ehuber_: ah cool, didn't know c2hs did that too
12:45:19 <ehuber_> there's a section in the docs with all the macros it gives you
12:45:27 <ehuber_> i read it once and it saved me a lot of time :D
12:46:16 <ehuber_> parcs`: i assume you mean hsc2hs
12:46:45 <ehuber_> haha, i didnt know c2hs is also a thing .. *reading*
12:47:07 <parcs`> oh wait it seems that c2hs provides an enum macro
12:47:17 <parcs`> http://blog.ezyang.com/2010/06/first-steps-in-c2hs/
12:48:10 <ehuber_> even better. do that and ignore what i said :D
12:48:28 <parcs`> hehe
12:58:10 <Axman6> srhb`: regarding your earlier question, no, MonadPlus has nothing at all to do with Num
12:58:47 <srhb`> Axman6: Indeed, I was just tying together in my mind why it is (+) can't be used.
12:58:56 <srhb`> Axman6: Thanks.
12:59:01 <The_Journey> is it possible to transpose a 2-dimensional lists, so that the rows become the columns and vice versa?
12:59:14 <luite> :t transpose
12:59:15 <lambdabot> forall a. [[a]] -> [[a]]
12:59:19 <luite> yep, this one :)
12:59:26 <The_Journey> ah, didn't know that, thanks :D
12:59:39 <Axman6> > transpose ["Nope","it's,","not","possible"]
12:59:40 <lambdabot>   ["Ninp","otoo","p'ts","ess",",i","b","l","e"]
13:00:01 <Axman6> > transpose $ transpose ["Nope","it's,","not","possible"]
13:00:02 <lambdabot>   ["Nope,ble","it'si","nots","pos"]
13:00:11 <srhb`> Surprise!
13:00:21 <hpc> @remember lambdabot Nope,ble
13:00:21 <lambdabot> It is forever etched in my memory.
13:00:36 <Axman6> > iterater transpose ["Nope","it's,","not","possible"]
13:00:37 <lambdabot>   Not in scope: `iterater'
13:00:37 <The_Journey> a transpose of a transpose does not equal the original?
13:00:42 <Axman6> > iterate transpose ["Nope","it's,","not","possible"]
13:00:43 <lambdabot>   [["Nope","it's,","not","possible"],["Ninp","otoo","p'ts","ess",",i","b","l"...
13:00:47 <Axman6> The_Journey: no, it can't
13:00:54 <srhb`> Unless.
13:00:55 <luite> it does if the lists are the same length
13:00:57 <Axman6> > iterate transpose ["Nope","it's,","not","possible"] !! 3
13:00:58 <lambdabot>   ["Ninp","otoo","p'ts","ess",",i","b","l","e"]
13:00:59 <xplat> it does if it was rectangular
13:01:09 <The_Journey> oh right
13:01:18 <Axman6> yeah, should've added 'in general'
13:02:31 <xplat> > transpose $ words $ "never enter court while naked"
13:02:32 <lambdabot>   ["necwn","enoha","vtuik","eerle","rrted"]
13:02:39 <The_Journey> what does the forall keyword do exactly?
13:02:39 <xplat> > transpose $ transpose $ words $ "never enter court while naked"
13:02:40 <lambdabot>   ["never","enter","court","while","naked"]
13:03:08 <ion> It foralls the names.
13:03:09 <Axman6> The_Journey: you can ignore it, it's implicit in haskell's type signatures
13:03:20 <The_Journey> ah ok
13:04:03 <xplat> more precisely you can usually ignore it
13:04:34 <aristid> xplat: any case where you can't ignore it (without language extensions)?
13:04:44 <The_Journey> are functor in OCaml the same as functor in Haskell?
13:04:51 <aristid> The_Journey: no. not at all.
13:05:07 <xplat> aristid: no, but when you have language extensions you can't always ignore it
13:05:16 <hpc> aristid: one example (with extensions) where you can't ignore it is ST
13:05:19 <hpc> :t ST
13:05:20 <lambdabot> Not in scope: data constructor `ST'
13:05:25 <xplat> @unmtl ST
13:05:26 <hpc> :t runST -- rather
13:05:26 <lambdabot> ST
13:05:27 <lambdabot> forall a. (forall s. ST s a) -> a
13:05:42 <xplat> ST too
13:05:42 <Axman6> ST isn't a monad transformer
13:05:56 <xplat> no, but @unmtl still works on it
13:05:59 <hpc> ST is pretty much "pure IO"
13:06:07 <hpc> plus that forall magic to keep STRefs from escaping
13:06:17 <aristid> and ST requires no language extensions?
13:06:26 <hpc> not sure about using it
13:06:38 <hpc> definitely took Rank2Types to define
13:06:39 <rwbarton> runST requires a language extension
13:10:30 <byorgey> preflex: seen ezyang
13:10:30 <preflex>  ezyang was last seen on #haskell 2 hours, 16 minutes and 44 seconds ago, saying: applicative: I'm having a conversation with Snoyman right now. I want to give him a chance to turn it into praise.
13:12:26 <danharibo> oh my hello
13:12:40 <ddarius> aristid: Being able to write 'forall' at all is an extension.
13:12:56 <danharibo> I'm new to haskell, I'm wondering how I would define something akin to a C enum in Haskell
13:12:59 <danharibo> ?
13:13:08 <aristid> ddarius: oh
13:13:30 <Axman6> danharibo: data Foo = A | B | C
13:13:42 <danharibo> Axman6: aha, TY
13:13:47 <Axman6> danharibo: data Foo = A | B | C deriving Enum (gives you a bit more power_
13:14:15 <Axman6> danharibo: any basic haskell tutorial should have taught this btw
13:14:45 <danharibo> Yeah I had seen that but I'm still thinking C-ish
13:14:52 <danharibo> hard to get my mind around some things
13:15:23 <Axman6> you'd do well to forget everything you know about C, you won't find that knowing C will help you much, if at all
13:17:34 <kmc> you don't have to turn on language extensions to use runST
13:17:41 <kmc> though you would have to turn on extensions to write its type
13:17:48 <kmc> maybe this is a GHC bug
13:19:25 <ddarius> kmc: There are other features that require extensions to define but not to use.
13:20:09 <Axman6> can you use GADTs without an extension?
13:20:35 <kmc> ddarius, sure, but in this case the fact leaks to the user
13:20:41 <kmc> for example ghci will print a type that it would itself reject
13:22:26 <Igloo> kmc: Hmm, you can't give type signatures to all bindings in standard Haskell, although I think you can to all top-level bindings
13:23:37 <ddarius> kmc: I'm pretty sure that happens in the other cases as well.
13:24:14 <Igloo> e.g. you can't give g a type (when f has it's most general type) in "f x = g where g = x"
13:25:06 <ddarius> I have no idea why Haskell didn't specify lexically scoped type variables from the get-go.
13:25:47 <hpc> ddarius: to annoy you ;)
13:26:02 <McManiaC> byorgey: using lists only for that layout thing might even result in a parser/lexer-only-patch
13:27:06 <kmc> are there notes from Haskell Committee meetings somewhere?
13:27:26 <ddarius> I believe the mailing list where the design of Haskell was discussed is archived somewhere.
13:32:03 <xtalmath> Hi, im not sure how to ask this question, its about quantifiers (for both variable and function symbols)(and their possible interdependencies), linearized notation and expressability, and euh
13:32:47 <xtalmath> I cant really find a strict and crystal clear text on predicate logic...
13:33:35 <xtalmath> so which quantifiers, and when, do commute ("order" linear or directed graph)
13:41:06 <Rc43> Hi, guys.
13:41:13 <Rc43> When I should use cabal-dev?
13:41:43 <xplat> xtalmath: quantifiers commute with each other when they have the same scope, are the same kind of quantifier, and either are unbounded or don't refer to each other in their bounds
13:42:04 <Rc43> As I have uderstood, cabal use local installing by default.
13:42:04 <Rc43> *uses
13:42:14 <silverfix> hello guys
13:42:39 <ddarius> xtalmath: #math or #not-math would probably be a more appropriate place to ask.
13:42:44 <silverfix> it's still a good book or it is deprecated ?
13:42:45 <silverfix> http://www.amazon.it/Haskell-Functional-Programming-Simon-Thompson/dp/0201403579/ref=sr_1_1?s=english-books&ie=UTF8&qid=1325542664&sr=1-1
13:43:00 <shachaf> ddarius: Those two channels pretty much cover it all.
13:43:50 <ddarius> shachaf: You're clearly not an intuitionist.
13:44:15 <xtalmath> xplat: i am asking in #math but the people awake think you would know better
13:45:58 <xtalmath> what do you mean with bounded or unbounded? it expresses their interdependency? i was trying to resolve my problem by making the difference between variable and functional quantification, and having functional quantification explicitly express on which other symbols it depends? is that the same as bounded/unbounded or is there a better framework?
13:46:45 <xplat> @remember ddarius < ddarius> xtalmath: #math or #not-math would probably be a more appropriate place to ask. < shachaf> ddarius: Those two channels pretty much cover it all. < ddarius> shachaf: You're clearly not an intuitionist.
13:46:46 <lambdabot> Done.
13:47:20 <carpi> could someone please tell me how I may avoid getting this error message "Couldn't match expected type `(t0, t1)' with actual type `IO (a0, [a0])
13:47:28 <hpaste> Carpi pasted âCan't connectâ at http://hpaste.org/56003
13:47:35 <ddarius> Stop writing type errors.
13:47:40 <kmc> carpi, by reading http://www.haskell.org/haskellwiki/Introduction_to_IO
13:47:58 <Botje> carpi: you cannot use IO actions in pure code.
13:48:12 <Botje> see the pickRandomEl invocation in line 4 ? you can't do that.
13:48:19 <xplat> xtalmath: a bounded quantifier is a quantifier whose domain is somehow restricted.  for example, 'forall n > 2. Prime(n) \/ Â¬Prime(n)'
13:48:32 <carpi> but it returns the same type which is (a, [a])
13:48:44 <Botje> carpi: no it doesn't.
13:48:52 <Botje> it returns an IO action that will eventually return (a,[a])
13:49:52 <kmc> i like to use different verbs, 'return' versus 'produce'
13:49:58 <kmc> to emphasize that evaluation and execution are distinct
13:50:03 <kmc> which is really the crux of the whole thing
13:50:18 <xtalmath> xplat: but for example (forall x in N)(exist y in N)(y>x)<=/=>(exist y in N)(forall x in N)(y>x)
13:50:23 <rwbarton> or "with a result of type (a,[a])
13:50:24 <shachaf> kmc: Oh, "produce". I've used "yield" but of course that has another popular meaning.
13:50:24 <rwbarton> "
13:50:32 <ddarius> I prefer to emphasize that there is no guarantee anything will ever be "returned"/"produced"/"whatevered" by an IO action.
13:50:50 <shachaf> kmc: Of course, "return" and "produce" are different things.
13:51:04 <carpi> so i think i wll have to change the newRndlst
13:51:05 <xplat> in many logics you don't actually need them, you can take them as an abbreviation for something like forall n. (n < 2) -> (Prime(n) \/ Â¬Prime(n))
13:51:29 <kmc> ddarius, there's no guarantee anything will be returned by a function, either
13:51:38 <shachaf> The non-monadic counterpart of "produce" isn't "return" so much as "is".
13:51:39 <ddarius> kmc: There is if it terminates.
13:51:50 <xplat> xtalmath: yeah, forall and exist are different kinds of quantifiers so they don't commute even if everything else is compatible
13:51:53 <xtalmath> so it seems more like the crucial difference lies in the implicit functional dependence of the second (from left to right) quantified "variable" (function of the first really) that makes it not commute
13:52:08 <dhun_233> the memory problem disappeared when I switched from mdo to do rec, but now linking error occur whenever a certain number of statement in the do rec block (frisby parser) is exceeded
13:52:29 <ddarius> Also, if you need a value that is not "returned" by a function then your whole program fails to return.  This is not the case for IO.
13:52:34 <xtalmath> xplat: do they never commute? I think they can but Im trying to find out the rules when they do or dont...
13:53:06 <xplat> you can say they have 'opposite polarity'.  in classical logic 'forall n. foo' is the same as 'Â¬ exist n. Â¬foo' and vice versa, those nots get in the way of commuting
13:53:15 <rwbarton> xtalmath: the reason unbounded quantifiers of the same type commute is that you can rewrite forall x. forall y. as forall pairs (x, y).
13:53:20 <carpi> could someone please tell me ..how may i connect the 2 functions in the hpaste i posted before
13:53:36 <rwbarton> there's no reason for universal and existential quantifiers to commute with each other in general
13:53:49 <ddarius> xtalmath: I recommend looking up and getting familiar with the Curry-Howard correspondence which provides a different, and in my opinion, much more intuitive perspective that allows you to intuit these things at a semantic level.
13:53:50 <Pseudonym> xplat: So to answer xtalmath's question, you can find out when quantifiers commute by converting to only one kind of quantifier.
13:53:53 <Botje> carpi: make newRndlst [a] -> IO [a].
13:54:17 <xtalmath> I know (through example I supplied above) that they dont commute in general, but that doesnt yet mean that they never commute
13:54:33 <Pseudonym> xtalmath: forall commutes with forall and exists commutes with exists.
13:54:37 <carpi> Botje: but then I will end up changing the implementation of all the other functions that depend on newRndlst.. :(
13:54:52 <carpi> isn't there anhy other solution?
13:54:58 <Botje> carpi: correct.
13:55:04 <monochrom> eh? quantifier logic? :)
13:55:06 <Pseudonym> Otherwise, they don't commute. BUT it can look like they can because of scoping.
13:55:10 <Botje> carpi: no. once you step into the IO monad you cannot step out.
13:55:11 * monochrom loves quantifier logic
13:55:35 <Pseudonym> For example: forall y. (exists x. p(x)) -> q(y)
13:55:53 <carpi> that is a severe limitation then.. :(
13:56:05 <mike-burns> We think of it as a feature.
13:56:08 <Pseudonym> Because the exists is in a contravariant position, can in a sense "commute" with the forall y.
13:56:10 <Botje> carpi: it also helps you to not launch missiles accidentally.
13:56:18 <xtalmath> Pseudonym: I know that to not be true, because one can quantify functions and if you dont explicitly add the dependence than for all can commute with exists
13:56:26 <carpi> and all this because of one little statement in pickRandomEl
13:56:31 <Pseudonym> Example?
13:56:40 <carpi> I was really aiming for pickRandomEl to not use IO at all..
13:56:43 <Botje> the IO tag is more than just decoration.
13:56:45 <xtalmath> ddarius: where do I find out more about CurryHoward correspondence?
13:56:46 <carpi> but it was inevitable
13:56:47 <kmc> it's not a tag!
13:56:54 <mike-burns> carpi: I'd expect a function with the word 'random' in its name to be in IO.
13:57:01 <kmc> if you think of IO as a "taint tag" on "impure functions" then you are doomed to misunderstand it
13:57:08 <xplat> carpi: the implementation of pickRandomEl could involve hiring someone to roll a die on mechanical turk
13:57:30 <Pseudonym> forall y. (exists x. p(x)) -> q(y)  <=>  forall y. (not (forall x. not p(x))) -> q(y)
13:57:42 <xplat> obviously this is not something you could do in a function :)
13:57:50 <Pseudonym> <=> forall y. (forall x. not p(x)) /\ q(y)
13:57:52 <roconnor> Pseudonym: :^)
13:57:57 <Pseudonym> Sorry. that should be \/
13:57:59 <xtalmath> Pseudonym: the example above is actually ambiguous, lets agree to from now on declare variables with quantifiers and naked symbols, and that we must explicitly write the parameters when quantifying functional symbols
13:58:17 <xtalmath> yeah!
13:58:42 <Pseudonym> <=> forall x y. not p(x) \/ q(y)
13:59:20 <monochrom> âx. ây. p(x)â§q(y) = ây. âx. p(x)â§q(y)  provided domains of x,y are non-empty (I forgot which one can be waived)
13:59:33 <carpi> mike-burns: maybe thats because you've been using haskell for awhile
13:59:37 <monochrom> but it is a contrived example rather than an enlightening example
13:59:57 <rwbarton> âx. ây. True = ây. âx. True
14:00:07 <xtalmath> Pseudonym: I have trouble parsing your statements (adding braces at right place)
14:00:09 <rwbarton> with similar constraints on the domains
14:00:13 <monochrom> oh, that's even cuter :)
14:00:16 <Pseudonym> ây. âx. p(x)â§q(y) => âx. ây. p(x)â§q(y)
14:00:25 <Pseudonym> But the converse is not true.
14:00:30 <Pseudonym> In general.
14:00:41 <Pseudonym> Because y may exist on x in gerenal.
14:00:42 <xplat> a forall and exists never commute 'directly', all examples of when they commute are when you can push them around with other rules (expand/contract scope, de morgan duality) until you get the commuted version back
14:00:49 <Pseudonym> BRB
14:01:28 <xplat> there's no set of side conditions i've ever heard of that cover all the cases and are as easy to get a handle on as the underlying rules themselves
14:01:38 <rwbarton> monochrom's example looks legit to me
14:02:09 <xtalmath> I can follow and agree with rwbartons example, but Pseudonyms its unclear if the second quantifier is \forall x or \forall x(y)
14:02:10 <monochrom> y's "dependence" on x is a red herring because q(y) couldn't care less about x
14:02:23 <rwbarton> since both sides are (âx. p(x)) â§ (ây. q(y))
14:02:54 <xtalmath> monochrom: true, but it makes at least explicit what is claimed
14:02:56 <monochrom> r(x,y) would trigger the "dependence"
14:03:28 <xplat> well, there is a sense in which every variable 'depends' on every variable whose scope encloses its own
14:03:43 <xtalmath> xplat: using braces?
14:03:43 <xplat> but that's a very simple syntactical matter to figure out
14:04:29 <xtalmath> if we use braces to define scope or dependence, then theres claims which would be very tedious and long to write out, i.e. the expressive power is affecte
14:04:55 <The_Journey> how would I zip three lists into a list of tuples?
14:05:14 <xtalmath> (btw, my background is semantic networks/ ontologies, im trying to make a graphbased visualization of predicate statements)
14:05:28 <mike-burns> :t zip3
14:05:29 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
14:05:30 <xplat> in which case you can say that in something like (forall x. p(x) /\ (exists y. q(y)) that y depends on x
14:05:54 <xplat> but since q doesn't depend on x you could always make y a constant function of x
14:05:56 <The_Journey> thank you
14:06:00 <monochrom> there is no silver bullet for figuring out dependence
14:06:22 <xtalmath> so I want to get rid of ambiguity in linearized statements (the rules of precedence of 'everything' including quantifiers)
14:07:26 <alistra> :t (&&&)
14:07:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:07:28 <xtalmath> monochrom: you mean there is no silver bullet when presented with some authors statement in current notations, or there is no silver bullet even if the author agreed to write in an explicit framework?
14:07:38 <alistra> > 5 &&& 2
14:07:38 <lambdabot>   No instance for (GHC.Show.Show (a b (c, c')))
14:07:39 <lambdabot>    arising from a use of `M74...
14:07:43 <rwbarton> current notation is perfectly explicit
14:07:57 <alistra> > (5,2) &&& (3,2)
14:07:57 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
14:07:57 <lambdabot>    arising from a use of `Control...
14:07:58 <rwbarton> at worst, you need to insert ()s to avoid issues of precedence
14:08:27 <xplat> xtalmath: can you give an example of a statement that is awkward to write with braces?
14:08:50 <xtalmath> then how is dependence on previous variables written, all statements above didnt explicitly make the second variable a function by declaring say \exist y(x)
14:09:08 <rwbarton> it doesn't need to be written
14:09:23 <xtalmath> xplat: not sure
14:09:28 <monochrom> (âd. âx. 0<|x|<d â |f(x)|<0.1) is a typical statement in limits. it makes x depend on d, against most people's will.
14:09:59 <kmc> shouldn't this be in #math?
14:10:09 <rwbarton> I guess you are thinking of something like this: "forall a in A. exists b in B." can be written as "exists f : A -> B. forall a in A. let b = f a in"
14:10:21 <monochrom> it should be in #math. but I should be the ruler of #math, too.
14:10:37 <xplat> maybe it should be in -blah or -overflow
14:10:49 <monochrom> well, I don't mind -blah
14:10:53 <ddarius> monochrom: Cale can make you the ruler of #math if so desired.
14:11:03 <xtalmath> monochrom: im saying I feel that it should be written (âd. âx(d). 0<|x(d)|<d â |f(x(d))|<0.1)
14:11:27 <xtalmath> kmc: people here are more practically experienced with subleties of predicate logic
14:11:45 <Cale> wat
14:11:46 <xtalmath> to make explicit the fact that x is a function and not a variable
14:11:57 <monochrom> people here are more qualified for logic and less welcome in #math
14:12:02 <xplat> but x is not a function of d there
14:12:13 <mike-burns> People here are good at many things, but we discuss Haskell in here.
14:12:13 <ddarius> xtalmath: Even if you were to do that, it would still be "forall x" not "forall x(d)"
14:12:14 <xplat> there are many values of x you consider for each d
14:12:16 <Cale> Do I magically have founder status in #math now?
14:12:27 <ddarius> Cale: I thought you were at least an op.
14:12:33 <Cale> I am an op...
14:12:43 <Cale> but I don't think I can make other people ops
14:12:52 <xtalmath> xplat: yes many functions x for each d
14:13:00 <Jafet> Math in #haskell is fine, compared to #math in #haskell
14:13:08 <carpi> is there a way to overcome the limitation of not being able to use a function that makes use of an IO fucntion in a function that doesn't?
14:13:14 <mike-burns> No.
14:13:18 <ddarius> carpi: Stop using Haskell.
14:13:29 <mike-burns> It's basically the best thing about Haskell.
14:13:35 <kmc> mike-burns, I disagree
14:13:50 <kmc> carpi, there's no such thing as an "IO function"
14:14:35 <kmc> IO actions are pure values like any other
14:14:42 <kmc> functions which return IO actions are pure functions like any other
14:14:55 <kmc> you need to understand what an IO action is, and the difference between evaluation and execution
14:14:56 <elarnon> IO (a -> b) ?
14:15:11 <copumpkin> that's an action that gives you a pure function
14:15:15 <copumpkin> IO (a -> IO b)
14:15:25 <copumpkin> that's an action that gives you a pure function ;)
14:15:46 <Jafet> traceShow
14:15:56 <xtalmath> allthough im not sure (when parsing to a graph of relations) which would make more sense: (âd. âx(d). 0<|x(d)|<d â |f(x(d))|<0.1) or (âd. (â(d)x). 0<|x|<d â |f(x)|<0.1)
14:16:30 <elarnon> IO (a -> b) is what I would call an "IO function"
14:16:39 <monochrom> if you like to emphasize dependence, you should just skolemize. (âx. ây. f(x)=y) = (âF. âx. f(x)=F(x)). just write the latter.
14:16:42 <mauke> elarnon: I -> O
14:16:47 <xtalmath> i.e. promote x to a function, or make the dependence on d connected to its selection at the quantifier
14:16:49 <kmc> elarnon, maybe so, but you will confuse everyone in doing so
14:17:00 <kmc> mike-burns, while it is an important feature, I think we do the language a disservice by saying that it only has merit if you buy into a particular kind of ideology
14:17:08 <kmc> an ideology which is seen as quite extreme and unpractical
14:17:54 <rwbarton> xtalmath: it doesn't even make sense to talk of x as a function of d in this example
14:17:55 <xtalmath> ok I never heard of skolemize before, let me look it up
14:17:58 <mike-burns> When it's actually impractical and not useful, unsafe* is there for you.
14:18:01 <kmc> half of what makes Haskell and GHC good is adherence to radical ideologies
14:18:17 <kmc> but the other half is just little stuff that other languages get wrong for no clear reason
14:18:33 <mike-burns> I claim that the first is the cause of the second.
14:18:34 <xtalmath> rwbarton: so increasing the arity of the quantifier relation would be better?
14:18:46 <rwbarton> what?
14:18:49 <kmc> mike-burns, some of it only
14:18:58 <kmc> mike-burns, but should this history lesson inform how we present the language today?
14:19:01 <ddarius> xtalmath: Again, even if you want x to be a function of d, you are binding x not x(d), you should not write "forall x(d)" in the same way you should not write "f(x) is a function" when what you mean is "f is a function."
14:19:12 <mike-burns> kmc: It should not, you are correct there.
14:19:29 <kmc> i don't think either laziness or purity is to thank for nestable multi-line comments
14:19:29 <rwbarton> I haven't understood anything you've said so far. the usual formulation (âd. âx. 0<|x|<d â |f(x)|<0.1) is the correct one. the idea that some quantified variables "depend" on others exists purely in our minds as an interpretation of the statement
14:20:10 <mike-burns> I think IO is to thank for monoid and STM.
14:20:25 <monochrom> yeah, you have to examine the body 0<|x|<d â |f(x)|<0.1 to notice dependence. it's why I say there is no silver bullet for this
14:20:33 <kmc> <mike-burns> People here are good at many things, but we discuss Haskell in here.
14:20:50 <xtalmath> rwbarton: you mean that they dont really depend, or that they do but dont explicitly write them ou?
14:21:35 <ddarius> mike-burns: It has nothing to do with monoid.
14:21:46 <kmc> anyway I see Haskell as a multiparadigm language
14:21:52 <mike-burns> kmc: Oh, agreed.
14:21:53 <xtalmath> I have no problem with adding depency in body, just I feel that there is another kind of dependency at declaration..
14:22:12 <kmc> it takes some effort to learn how to do imperative and object-oriented programming in Haskell, but it's fairly natural once you have learned it
14:22:14 <mike-burns> ddarius: You think we'd have the monoid typeclass if IO wasn't done the way it was?
14:22:17 <aristid> kmc: the word "multiparadigm" reminds me of c++
14:22:26 <kmc> the radical thing isn't that the language forces FP but that the standard libraries take FP seriously
14:22:28 <xplat> xtalmath: in the limit case, it doesn't depend at all
14:22:35 <Axman6> ALL the paradigms!
14:22:36 <rwbarton> I'm saying there is no need to have any notion of "dependency". âx. ây. f(x,y) is formally the correct thing to say.
14:22:53 <xtalmath> alternatively one could write (âd. (âx in (0,d)).|f(x)|<0.1)
14:22:56 <cmccann> lambda is the ultimate multi-paradigm
14:23:07 <Kanisterschleife> gtg. bye!
14:23:08 <ddarius> mike-burns: Yes.
14:23:30 <aristid> mike-burns: are you confusing Monoid with something else?
14:23:49 <mike-burns> aristid: Nah, it's just one example.
14:23:52 <xtalmath> but I feel that my confusion may be enlightened after reading more about skolemizing
14:24:08 <rwbarton> yes, very likely
14:24:09 <aristid> mike-burns: because really, neither IO nor IO a is an instance of Monoid, so it ... you would need to explain
14:24:24 <rwbarton> it is a way to formalize the idea that there is a dependence
14:25:27 <mike-burns> aristid: The IO separation caused lots of research into better ways to handle IO. Eventually we got the Monad typeclass, and early literature indicates that this is because of IO. With the Monad typeclass came interest in related ideas, and hence the Monoid typeclass.
14:25:56 <Axman6> so you meant monad, not monoid
14:25:56 <monochrom> you're looking at closures. when I write (\y -> head ('c':y)), you go, hey what the hell is "head" there? it is not so much "y depends on head" but rather "(\y -> head ('c':y)) depends on head". so similarly for âhead. ây. head('c':y) = blah
14:25:59 <kmc> instance Monoid (IO a) where { mempty = throwIO (ErrorCall "mempty"); x `mappend` y = x `catch` (\(_ :: SomeException) -> y) }
14:26:11 <mike-burns> Axman6: No, I meant Monoid.
14:26:14 <shachaf> mike-burns: I think Monoid would come about independently of Monad.
14:26:17 <shachaf> It's much simpler.
14:26:19 <mike-burns> shachaf: But it didn't.
14:26:28 <ddarius> mike-burns: We had Eq, Ord, Show, and many other classes long before Monad.  Monoid is a perfectly reasonable class to make even if we didn't have constructor classes.
14:26:34 <Axman6> is IO even a monoid?
14:26:39 <mike-burns> Axman6: No.
14:26:39 <rwbarton> certainly "monoid" came about independently of "monad"
14:26:40 <Axman6> @instances Monoid
14:26:41 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:26:47 <kmc> ahem
14:26:57 <Axman6> so what makes you think that IO and monoids are related? o.o
14:26:58 <mike-burns> How are you not understanding me?
14:27:17 <kmc> "With the Monad typeclass came interest in related ideas, and hence the Monoid typeclass."
14:27:19 <aristid> mike-burns: huh? i thought monoid was a mathematical concept way before haskell existed?
14:27:26 <mike-burns> aristid: It was. Lots of things are.
14:27:28 <mike-burns> srsly.
14:27:47 <Jafet> IO has existed from the dawn of humanity
14:27:51 <monochrom> some haskell compilers compiles (\y -> head ('c':y)) to (\head -> \y -> head ('c':y)) to make explicit the dependence. note how it is "the whole thing is a function of head" not "y is a function of head"
14:28:12 <Axman6> Jafet: humanity? that seems quite late in history =)
14:28:16 <mike-burns> So anyway, I won't say that the IO separation is basically the best thing about Haskell.
14:28:30 <Jafet> subhumanity
14:28:31 <mike-burns> I happen to like it, but there are many other great things.
14:28:46 <kmc> *nod* it has many benefits but also many drawbacks
14:28:48 <kmc> like laziness
14:28:54 <mike-burns> Indeed.
14:28:56 <kmc> whereas i think some other features have many benefits but few drawbacks
14:29:56 <Sgeo> Is GHCi compiled with the threaded runtime?
14:30:03 <monochrom> yes
14:30:16 <Sgeo> Thanks
14:30:21 <kmc> Sgeo, ghci +RTS --info
14:30:54 <kmc> (ghci is the same binary as ghc)
14:31:04 <monochrom> in fact, when you enter "2+4" or "getLine" or whatever, that is executed in a new thread
14:31:38 <kmc> to use that output you have to know the somewhat cryptic code that ("RTS way", "rts_thr") means "threaded RTS"
14:31:39 <Jafet> On some platforms, in a different process
14:32:07 <aristid> Jafet: which platforms?
14:32:11 <rwbarton> has anyone ever heard the term "monoid act" for "monoid action"?
14:32:19 <Jafet> Windows, generally
14:32:22 <ddarius> rwbarton: No.
14:32:22 <Sgeo> What if I do x <- lengthyThing
14:32:34 <rwbarton> that's what I thought, but the wikipedia entry uses "monoid act" with a straight face
14:32:34 <kmc> rwbarton, you mean like a function M x A -> A, where M is a monoid?
14:32:38 <rwbarton> yep
14:32:42 <monochrom> it was eventually noticed when someone entered "show_window w" for a GUI lib and got some kind of "you're using the wrong thread" error
14:32:50 <xtalmath> question while reading: http://en.wikipedia.org/wiki/Skolem_normal_form#How_Skolemization_works the first equation presented, shouldn't the right side have a \exist f? and would that be before or after the quantification of x?
14:32:53 <aristid> Jafet: i thought CreateProcess was expensive?
14:33:20 <Jafet> It amortizes that CreateProcess over the whole ghci session, of course
14:33:23 <ddarius> aristid: Expensive is relative.
14:33:31 <Jafet> As far as I know, that is
14:34:00 <ddarius> xtalmath: Why aren't you asking about R as well?
14:34:01 <aristid> Jafet: so it isn't a process for every input but for all inputs
14:34:08 <parcs`> cool, sum [1..3000000] is around 2.5x slower on ghci +RTS -N than on plain ghci
14:34:25 <kmc> heh, cool
14:34:30 <xtalmath> ddarius: because it isnt quantified on either side, while y was quantified on the left side
14:34:54 <monochrom> xtalmath, people usually confine themselves to first-order log, and so "âF" is not tolerated. what they do to work around it: place it at the meta-level.
14:34:54 <xtalmath> R might not need quantification, maybe a definition is enough
14:35:10 <monochrom> s/log/logic/
14:35:13 <ddarius> xtalmath: What does y have to do with f?
14:35:21 <xtalmath> why is "âF" is not tolerated?
14:35:32 <monochrom> because F is a function
14:36:25 <xtalmath> so you mean you need second order logic, to have the universe of variables and the universe of functions?
14:36:36 <monochrom> yes
14:36:52 <xtalmath> im not confining myself to first order, I read now I stated I did, but meant predicate logic in general
14:37:04 <monochrom> universe of value variables and universe of function variables
14:37:15 <xtalmath> right
14:38:31 <xtalmath> but euh, then the example on wikipedia, ... really this meta-level is just the same as second order logic no? and in second order logic you'd write explicitly the quantifier for F at the right side no?
14:39:11 <monochrom> people have no problem using unrestricted logics for their meta-logics.
14:39:40 <ddarius> In fact people have a problem of leaking the unrestrictedness of their meta-logic into their logic.
14:39:41 <monochrom> but people do have problem writing symbolically for their meta-logics.
14:39:58 <xtalmath> way over my head
14:40:17 <kmc> Mathematical Anti-Telharsic Harfatum Septomin
14:40:40 * mauke looks around him
14:40:44 <ddarius> kmc is putting a pox on us!
14:40:57 <xtalmath> all I want to do is make a graphbased language of relations and quantifiers that still makes sense mathematically
14:40:59 <lexande> somebody said second order logic?
14:41:08 <kmc> a wild lexande appears!
14:41:25 <monochrom> anyway, like I said, (\y -> head('c':y) == 'c') is a case of "the whole thing depends on head" not "y depends on head".
14:41:31 <ddarius> xtalmath: Then spend a lot of time reading about relations and quantifiers.  You are not going to figure it all out in an IRC discussion.
14:41:49 <ddarius> monochrom: Don't forget (:) and (==)
14:41:58 <monochrom> yeah, those too
14:42:28 <kmc> mauke, have you worked out what we're looking for?
14:42:50 <rwbarton> iron?
14:42:51 <mauke> I think so, Brain
14:43:58 <monochrom> I am actually fine with this scheme: you write "\y(head)" as syntax sugar for "\y". the syntax sugar tries to redundantly remind you that the outer "head" plays a role later. the syntax sugar should not be read as "y is a function of head".
14:43:58 <xtalmath> http://en.wikipedia.org/wiki/Relational_model how can this be first-order logic? if theres different domains in a database?
14:44:14 <ClaudiusMaximus> ouch :(  Program received signal SIGSEGV, Segmentation fault.
14:44:14 <ClaudiusMaximus> 0x00000000005349d5 in evacuate ()
14:44:55 <ClaudiusMaximus> is this a sign that something is corrupting memory?
14:45:11 <kmc> "You can evacuate a building, but to evacuate a person is to give them an enema"
14:45:16 <monochrom> what program is that?
14:45:50 <monochrom> and 0x00000000005349d5 looks like a really long address
14:45:55 <ClaudiusMaximus> monochrom: my ghc-compiled executable
14:46:16 <monochrom> any more information?
14:46:34 <ClaudiusMaximus> monochrom: i've got a gdb attached, any suggestions?
14:46:54 <monochrom> suggestion: reveal more information
14:47:15 <Pseudonym> Back.
14:47:42 <hpaste> ClaudiusMaximus pasted âgc segfaultâ at http://hpaste.org/56004
14:47:54 * ddarius suspects sheaf is appropriately named.
14:48:00 <monochrom> alternative suggestion: screw me, wait for someone who can spew out answers after answers with 0 information from the question. there are plenty of them here actually, I don't know where they have all gone
14:48:25 <ClaudiusMaximus> monochrom: was asking for suggestions for gdb commands (i only know bt)
14:48:55 <mike-burns> I'm still here, but taking a break from spewing out answers with 0 info.
14:49:27 <The_Journey> how would I multiple elements of two multi-dimensional lists that have the same shape?, like I want to multiply element-wise of k1 = [[1,2,3], [4,5,6], [7,8,9]] and k2 = [[10,11,12],[13,14,5],[16,17,18]]
14:49:42 <Pseudonym> Adi Shamir would be proud of zero-knowledge answers.
14:49:45 <ddarius> ClaudiusMaximus: monochrom is wondering what your program does, are you using FFI, if so what does that do, etc.
14:49:50 <mauke> zipWith . zipWith
14:50:14 <ClaudiusMaximus> ddarius: right - it uses mainly hmatrix FFI, opengl FFI
14:51:20 <The_Journey> mauke: thank you very much
14:51:21 <ClaudiusMaximus> and i am using unsafeCoerce in 3 places (but only for newtype re/wrapping that the benevolent library authors wanted to hide from me)
14:54:17 <monochrom> with these FFI libs there are always points you have to be careful who allocates the block of memory you pass to whom, and who gets to deallocate it
14:54:55 <Sgeo> With the FFI, how do I tell Haskell to look for the library at runtime?
14:55:05 <Sgeo> (Because I can't statically link it, I think)
14:55:25 <monochrom> normally, you don't have to do anything
14:56:07 <ddarius> ClaudiusMaximus: Figure out how to get a stack trace out of gdb, and that will hopefully isolate it to one of the hmatrix, OpenGL, or other groups.
14:56:18 <monochrom> the exception is of the form "after my main begins, I want to detect whether gtk exists, if so load it, if not do something else"
14:56:51 <monochrom> the stack trace already has #6  0x000000000044ce13 in GraphicsziUIziGLUTziRawziCallbacks_d4fx ()
14:57:42 <ddarius> You can also always bind to dlopen or LoadLibrary, but that is usually only necessary if you don't even know what DLLs you'd be loading until run-time.
14:59:43 * hackagebot haskeline 0.6.4.6 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.6 (JudahJacobson)
15:00:37 <kmc> monochrom, even then there are likely to be easier ways
15:00:46 <kmc> compared to dlopen / LoadLibrary, i mean
15:01:12 <kmc> using a C library through dlopen might work, but using a Haskell library through dlopen is likely to be a real pain in the ass
15:01:26 <kmc> though one of the 'plugins' libraries might make it work ok
15:02:44 <ClaudiusMaximus> well, i can crash ghci/hmatrix with a bus error in gsl_multimin_fminimizer_alloc, but i assumed that was due to threading (it works fine most of the time when compiled..)
15:03:51 <kmc> hmm, is there a tool to trace all FFI calls?
15:03:54 <kmc> that would be super
15:04:12 <kmc> there are some generic binary tracing things which might work
15:04:18 <xtalmath> monochrom: your recurring statement about the dependency occuring in the body made me think about the following: is second order logic really an extension or first order logic? i.e. "(\foral x in X)(\exist y in Y)(body)" of second order logic can be written in first order logic as (\forall x)(\exist y)(body^memberofX(x)^memberofY(y))... so it seems to be a different language but with the same expressive power?
15:04:49 <xtalmath> correct or false?
15:05:06 <Phlogistique> http://sprunge.us/RhaL this fails to compile with /tmp/types.hs:7:15: parse error in data/newtype declaration
15:05:19 <Phlogistique> what am I getting wrong?
15:05:24 <rwbarton> false (your translation is not the right one) but this has nothing to do with first v. second order logic
15:05:43 <xtalmath> rwbarton: could you please point out the error in my translation?
15:05:49 <ddarius> xtalmath: Sets are an encoding of higher order logic into first order logic.
15:05:55 <ddarius> xtalmath: Sets are not part of first order logic.
15:05:59 <rwbarton> it should be \forall x. x in X => \exist y. y in Y and body
15:06:31 <xtalmath> rwbarton for the right hand side or the left hand side?
15:06:44 <rwbarton> the right hand side
15:06:49 <kmc> Phlogistique, 'newtype' needs to define a data constructor, like 'data'
15:07:10 <xtalmath> ddarius: but I could still use a proposition memberofX(x) instead of x in X
15:07:17 <elarnon> xtalmath: you aren't able to quantify over sets (or predicates) that way
15:07:36 <kmc> Phlogistique, the valid syntax for 'newtype' is the subset of the 'data' syntax where you have exactly one constructor with exactly one field
15:07:39 <elarnon> you can't say things like "forall X. memberofX(x)"
15:07:57 <kmc> like, your Rotation could be a newtype
15:08:00 <Phlogistique> kmc: thanks
15:08:02 <xtalmath> elarnon: I didnt, only quantified over lowercase
15:08:18 <ClaudiusMaximus> trying a debugging run in ltrace now... (thanks kmc for the idea)  (valgrind didn't report anything unusual memorywise)
15:08:21 <ddarius> xtalmath: You could, and then you'd be limited to only the things for which you had those built-in predicates, and thus you wouldn't have the power of second order logic.
15:08:38 <xtalmath> im not seeing the difference anymore
15:08:46 <ddarius> If you assert that you have those built-in predicates for any predicate X then you are just using funny notation.
15:08:46 <elarnon> xtalmath: my point was actually that you can do it in second order logic
15:09:05 <kmc> 'newtype' is like a restricted version of 'data', which might have a more efficient implementation, and also has slightly different semantics
15:09:37 <peterjoel> hi. I can see a lot of different postgres packages listed on hackage. Which is the best one to use?
15:09:39 <elarnon> (forall P. P(x))
15:09:44 <hpaste> benmachine pasted âMissing Traversable instancesâ at http://hpaste.org/56005
15:09:47 <xtalmath> elarnon: so its second order logic just simplifies notation
15:09:54 <monochrom> "foral x in X" doesn't use the power of 2nd-order logic, may as well be 1st-order, unless X is a set of functions or a set of sets, in which case what ddarius says, you hide arbitrarily advanced technology inside X and then use "forall x in X" to access advanced technology while staying 1st-order in name
15:09:54 <jeff_s_> Maybe 'newtype' should have been 'newdata'.
15:09:54 <ddarius> xtalmath: No.
15:10:08 <benmachine> http://hpaste.org/56005 â anyone want to hypothesise for me why these instances aren't provided in Data.Foldable/Traversable?
15:10:28 <kmc> jeff_s_, or "isodata" -- because it creates a data type isomorphic to but distinct from another
15:10:28 <xtalmath> ah!, I thought second order logic was about using different domains, and not quantifying the domains themselves
15:10:32 <kmc> *shrug*
15:10:40 <lukish> > length . ( \n -> [ (x,y) | x <- [1..n], y <- [x+1..n] ] ) $ 100
15:10:41 <lambdabot>   4950
15:10:53 <kmc> for 'newtype', the analogy to 'type' is one of use cases, while the analogy to 'data' is one of syntax and semantics
15:10:57 <lukish> Is there a way to do that faster?
15:11:03 <lukish> > length . ( \n -> [ (x,y) | x <- [1..n], y <- [x+1..n] ] ) $ 10000
15:11:06 <lambdabot>   mueval-core: Time limit exceeded
15:11:13 <rwbarton> > (100 * 99) `div` 2
15:11:14 <lambdabot>   4950
15:11:29 <xtalmath> so in first order logic one can use quantify variables over different sets of symbols, but one cant quantify sets?
15:11:40 <benmachine> (admittedly they're a bit... stubby, but really no more so than Maybe... I'm actually finding myself wanting to use the tuple sequenceA, at least
15:11:43 <benmachine> )
15:11:48 <ddarius> xtalmath: There are no sets.  There are only predicates.
15:11:49 <lukish> I need all pairs x y < n where x < y
15:12:00 <ddarius> and "objects."
15:12:09 <xtalmath> ddarius: but one can emulate sets by predicates
15:12:15 <ddarius> xtalmath: No.
15:12:35 <xtalmath> what is the difference between x in X and memberofX(x)?
15:13:15 <Sgeo> I have a libaw_sdk.52.so.100 file
15:13:18 <rwbarton> there is no difference because neither has been defined in this context
15:13:30 <Sgeo> And I'm having trouble getting the right -l command to make GHCi see it
15:13:31 <ddarius> memberofX has no inherent meaning in predicate logic.  You can -add- arbitrary predicates and assert arbitrary axioms for them, but this is just data to predicate logic.
15:13:51 <ddarius> This is all sets are.  They are just arbitrary objects and predicates added to first-order logic.
15:14:16 <xtalmath> ok, so change the example to 3 in N and memberofN(3)
15:14:30 <jeff_s_> lukish - isn't the code you gave what you wanted?
15:14:31 <ciaranm> there is no such thing as 3 or N
15:14:33 <ddarius> N has no inherent meaning. memberofN has no inherent meaning. 3 has no inherent meaning.
15:14:37 <benmachine> sigh
15:14:47 <lukish> jeff_s_: yes it gives
15:14:50 <lukish> But slowly
15:14:53 <Pseudonym> Once 3 has been suitably defined, it can be shown that 1+2 = 3.
15:14:55 <lukish> For 10000 for example
15:14:56 <benmachine> :t mapM (\(a,b) -> (,) a <$> b) -- someone name this for me
15:14:57 <lambdabot> forall t a (m :: * -> *). (Functor m, Monad m) => [(t, m a)] -> m [(t, a)]
15:15:08 <xtalmath> so one can quantify variables over different sets in first order logic but if one wants to quantify sets (i.e. for all sets s) one needs second order?
15:15:10 <benmachine> you can specialise m to Maybe if that helps
15:15:11 <rwbarton> well guess what, there are a lot of pairs (x, y) with 1 <= x < y <= 10000.
15:15:15 <ddarius> xtalmath: No.
15:15:21 <ddarius> xtalmath: Again, there are no sets.
15:15:31 <rwbarton> most likely whatever you are doing with each pair takes longer than generating them with this list comprehension anyways.
15:15:36 <xtalmath> ok, suppose the sets and the predicates were defined
15:15:46 <ddarius> xtalmath: You can define a class of objects and call them sets in which case you can quantify over these "sets" in first order logic, and this is -exactly- what set theory does.
15:16:05 <xtalmath> ok
15:16:30 <ddarius> What second-order logic lets you do is quantify over -predicates- which are something first-order logic talks about.
15:17:14 <monochrom> benmachine: keep_the_first_component_but_activate_the_second,_now_do_this_for_the_whole_list
15:17:30 <benmachine> silly monochrom, commas can't be in identifiers
15:17:43 <monochrom> sorry, it is so asymmetrical and ad-hoc, I can't think of a short name
15:18:00 <benmachine> neither can I
15:18:23 <benmachine> but... I use it in enough places that my "give this thing a name" senses are tingling
15:18:35 <monochrom> assymmetric_activate_and_map
15:18:40 <xtalmath> ok ok ok I think ive had enough mindscrew for a day
15:18:48 <benmachine> it would be 'traverse sequenceA' if those instances I linked existed
15:19:52 * benmachine toys with calling it traverse'sequence
15:19:57 <monochrom> mapM_2nd
15:20:04 <ciaranm> xtalmath: it stops being a mindscrew once you realise that everything is defined upside down. you don't use simple things to create maths; you use maths to create simple things.
15:20:40 <monochrom> eh? I think logic is quite simple, math is the rich complex one
15:20:58 <xtalmath> enough i says
15:21:31 * xtalmath crackpipe
15:21:50 <ddarius> Anyway, higher order logic is to first order logic is to set theory as Haskell is to C is to encodings of closures into C.
15:22:05 <benmachine> hmm maybe I should call this function by what it *does* rather than what it *is*...
15:22:05 <ciaranm> monochrom: the usual example i hear people who study teaching moaning about is that area is defined in terms of the integral, rather than integral being a way of finding area
15:22:28 * benmachine shrug
15:22:51 * ddarius likes defining differentiation in terms of integration.
15:23:08 <ddarius> (and not implicitly)
15:23:10 <monochrom> I have problem agreeing that "âe âd âx 0<|x|<d â |f(x)|<e" is simple math. some people try to make it a bit simpler by deleting "âx"
15:23:43 <ciaranm> ddarius: if you do that, aren't the proofs that step functions are a good approximation to functions an utter pain?
15:23:43 <monochrom> I have not seen a definition of "area" simpler than integration when it comes to curvy things.
15:23:44 <Pseudonym> ddarius: You shouldn't do that, because you're liable to confuse integration with antidifferentiation.
15:23:56 * ddarius makes it a bit simpler by deleting "0<|x|<d => |f(x)|<e"
15:25:45 <ddarius> Again, I'm not talking about an implicit definition, but an explicit formula for the derivative in terms of the integral.
15:25:54 <ddarius> Pseudonym: I don't know what "antidifferentiation" is.
15:26:17 <monochrom> note: if you prepare to be not-too-rigorous and just say "dividing into triangles infinitestimally" for area, you should do the same to integrals to be fair, and so you still don't have one of them simpler than the other.
15:26:32 <ddarius> Pseudonym: But if anything my approach would confuse differentiation with anti-integration, not the other way around.
15:27:20 <monochrom> at any rate the Riemann sum screams "area" to me.
15:27:29 <roconnor> monochrom:  <ski> ("The logical calculus is easier to execute than any of the techniques of mathematics itself, yet only in 1934 did Gerhard Gentzen set it out in a natural way. Even now, mathematics students are expected to learn complicated (e- d)-proofs in analysis with no help in understanding the logical structure of the arguments. Examiners fully deserve the garbage that they get in return." -- Paul Taylor)
15:28:04 <monochrom> oh, is that in #haskell-blah?
15:28:09 <ddarius> Logic is not taught.  News at 11.
15:28:21 <Pseudonym> ddarius, consider a function F such that the derivative of F is f.
15:28:22 <roconnor> monochrom: it is from http://niobium.mine.nu/~sunrice/ithp.cgi?channel=math-fn&filename=math-fn.log.20110125&display=1&page=1
15:28:30 <Pseudonym> F(x)
15:28:34 <jeff_s_> I took logic in college. Probably it was the best class I took.
15:28:48 <monochrom> I totally agree.
15:28:50 <Pseudonym> Let H be the Heaviside step function. Then the derivative of F(x) + H(x) is also f(x).
15:29:08 <Pseudonym> Except at one point, but if you take the two-sided limit at that point, it still works.
15:29:43 * hackagebot dnscache 1.1.0 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-1.1.0 (ErtugrulSoeylemez)
15:30:14 <ddarius> jeff_s_: Did you take it before or after calculus?
15:30:35 <Pseudonym> However, F(x) + H(x) is not an antiderivative of f(x).
15:30:39 <jeff_s_> After. I went on to take a couple more serious math classes, like real analysis.
15:31:02 <Pseudonym> The fundamental theorem of calculus is wrong. QED
15:31:06 * kmc takes only joke math classes
15:31:06 <jeff_s_> Strangely, logic was part of the philosophy department, not math, but it was formal, anyway.
15:31:17 <ddarius> Really, the largest thing that I think trips people up is scoping.  Scoping is handled sloppily in most mathematical presentations and is rarely explicitly covered, at least early on.
15:31:27 <kmc> mathematicians think logic is philosophy, and philosophers think logic is maths
15:31:38 <kmc> similarly mathematicians think Haskell is programming, and programmers think Haskell is maths
15:31:47 <jeff_s_> Scoping in Whitehead's principia is even nastier, as I remember.
15:32:03 <kmc> what about newton's principia
15:32:10 <mateu> and mathophers live in caves
15:32:10 <mike-burns> I'd take joke math classes. That sounds awesome.
15:32:12 <jeff_s_> It has no scoping, just lensing.
15:32:13 <Pseudonym> ddarius: Einstein summation notation still annoys the hell out of me.
15:32:13 * roconnor thinks logic is computer science.
15:32:19 <Sgeo> If the foreign library I'm linking to has an opaque void*, what type would that correspond to in Haskell?
15:32:20 <mokus> if neither math nor philosophy want logic, we should claim it for #haskell
15:32:22 <Sgeo> A Ptr ()?
15:32:25 <kmc> Math 999: Analytic and algebraic topology of locally Euclidean parameterization of infinitely differentiable Riemannian manifold
15:32:31 <kmc> Sgeo, usually, yes
15:32:33 <ciaranm> iirc i got one lecture on logic at the start of analysis, and it was deliberately disguised because that class was mandatory for physicists too
15:32:34 <Sgeo> ty
15:32:35 <mike-burns> I hear #haskell-blah wants logic.
15:32:40 <irene-knapp> kmc: oh boy, j'ai mal
15:32:47 <kmc> Sgeo, sometimes you want to distinguish it from other void*'s
15:32:55 <Sgeo> kmc, in this case, I do
15:33:02 <Sgeo> So do I newtype around the Ptr ()?
15:33:14 <kmc> so you might have {-# LANGUAGE EmptyDataDecls #-}  data Foo;  data Bar;  foreign import ccall foo :: IO (Ptr Foo);  foreign import ccall bar :: IO (Ptr Bar)
15:33:27 <kmc> newtype wrapping Ptr would be a higher level of the library, I think
15:33:51 <kmc> i think most FFI bindings should have at least three layers
15:33:57 <kmc> though it's fine to separate them into distinct packages
15:34:07 <ciaranm> ffi bindings are like ogres
15:34:11 <Pseudonym> BTW, the fundamental theorem of calculus isn't actually wrong, but it does mean that the algebraic notion of a differential operator doesn't necessarily coincide with the applied maths meaning.
15:34:15 <shachaf> @google keegan ffi
15:34:16 <lambdabot> http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
15:34:16 <lambdabot> Title: High-level FFI in Haskell
15:34:28 <kmc> thanks, shachaf.  thachaf.
15:34:39 <ddarius> Pseudonym: The fundamental theorem of calculus is â«_M d^{m}xÂ·â f = â®_âM d^{m-1}x f
15:34:48 * ion appreciates kmcâs reference.
15:34:52 <kmc> 1) a bare import of C functions;  2) a type-safe, memory-safe imperative API with basically the same operations;  3) a high-level API of functions
15:34:57 <Pseudonym> Ooh, nice statement!
15:35:02 <jeff_s_> Who wants to make me a nice, haskell native mysql client library so I don't have to use withRTSSignalsBlocked all the time?
15:35:16 * shachaf is really missing out on #haskell with his broken Unicode support.
15:35:28 <kmc> shachaf, you racist
15:35:29 <shachaf> What was the thing ddarius just said? I mainly see question marks.
15:35:32 <shachaf> kmc: I know. :-(
15:35:35 <mike-burns> I don't think those are unicode characters. Otherwise, my unicode support is also broken.
15:35:36 <ciaranm> i stopped doing applied maths when they refused to define "operator" and then started claiming that differentiation and "indefinite integration" were the same "type" of operator
15:35:42 <Pseudonym> Quick, someone post line noise and pretend that it's profound! Nobody tell shachaf!
15:35:47 <jeff_s_> I don't understand how people are typing all those fancy symbols.
15:35:51 <Rc43> How can I represent types?
15:35:57 <ion> He said: â«_M d^{m}xÂ·â f = â®_âM d^{m-1}x f (although he probably meant â«_M d^{m}xÂ·â f = â®_âM d^{mâ1}x f)
15:36:12 <Rc43> For example, I want to use a value like [Type] in my program.
15:36:14 <shachaf> mike-burns: They're all Unicode characters. Some of them have code points greater than 127.
15:36:31 <kmc> Rc43, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.3.1.0/Data-Typeable.html .  but What Are You Really Trying To Do â¢?
15:36:32 <Pseudonym> I just realised that many of today's youngins may not know what line noise is.
15:36:36 <jeff_s_> Clearly, since the first only evaluates in Mathematica 17 or later.
15:36:38 <mike-burns> Rc43: I don't understand; can you explain a little more? Or maybe paste what you're trying to do?
15:36:39 <ciaranm> no-one tell jeff_s_ about â!
15:36:43 <ddarius> The FFI specification allows newtypes of Ptrs to be used in arguments.
15:36:46 <mike-burns> Pseudonym: Huh!
15:36:47 <rwbarton> Rc43: what would you do with this value of type [Type]?
15:36:48 <ddarius> In foreign import.
15:36:49 <Sgeo> If I have a module Network.Blah.A and a module Network.Blah.B and they're both in Blah, how do I make them see each other so I can import them?
15:37:03 <Sgeo> ddarius, ooh, cool
15:37:08 <kmc> jeff_s_, http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
15:37:14 <jeff_s_> ciaranm: brilliant!
15:37:22 <ddarius> ciaranm: They are both operators on infinite dimensional linear spaces of functions.
15:37:25 <miden> how can i find a type of a function without ghci... not an easy one but somehting like concat. map concat ? I know how to calculate map concat but i have problem with the (.)
15:37:41 <mike-burns> Sgeo: Do you mean like 'import B' from inside Network.Blah.A ? So far as I know you cannot do this.
15:37:50 <ciaranm> annoyingly, the unicode snowman isn't a "letter", so you can't use it as an identifier in unicode-aware languages
15:37:50 <Rc43> I want tot create interface type, then I will use it for processes communication.
15:37:58 <Sgeo> mike-burns, o.O
15:38:00 <jeff_s_> Eh, I'll stick with my Cocoa irc client.
15:38:08 <Sgeo> mike-burns, import Network.Blah.B isn't working
15:38:08 <kmc> miden, I will show you the derivation
15:38:10 <ion> jeff_s: The compose key, altgr combinations, the IBus LaTeX table and ctrl-shift-UXXXX.
15:38:19 <kmc> (.) :: (b -> c) -> (a -> b) -> (a -> c)
15:38:29 <kmc> concat :: [[d]] -> [d]
15:38:30 <ddarius> Sgeo: The module namespace is flat.  There is absolutely no connection between module Foo.Bar, module Foo, and module Foo.Baz.
15:38:31 <mike-burns> Sgeo: Oh, that should be possible. Do you have the file named Network/Blah/B.hs ?
15:38:37 <kmc> map concat :: [[[e]]] -> [[e]]
15:38:42 <Sgeo> mike-burns, yes
15:39:01 <Sgeo> Nothing is set up with cabal, if that's making the difference
15:39:02 <kmc> miden, note how I have carefully used distinct type variables in each case
15:39:06 <mike-burns> Sgeo: And at the top you have   module Network.Blah.B where   spelled correctly?
15:39:15 <miden> ok
15:39:16 <mike-burns> Sgeo: Oh are you using `cabal build"?
15:39:18 <mike-burns> '
15:39:29 <Sgeo> mike-burns, no I am not.
15:39:36 <kmc> miden, now the type of (.) says that its left-hand argument has type (b -> c), and we know its left-hand argument is 'concat' with type [[d]] -> [d]
15:39:38 <mike-burns> Sgeo: runhaskell? How are you building this?
15:39:57 <Sgeo> mike-burns, currently, testing in GHCi
15:40:05 <kmc> so we "unify" the type (b -> c) with the type ([[d]] -> [d]) and determine that b = [[d]] and c = [d]
15:40:08 <Sgeo> I loaded the library at the GHCi command line with -L and -l
15:40:08 <kmc> does that make sense so far?
15:40:24 <miden> of course
15:40:25 <mike-burns> Sgeo: Ah. I actually don't typically do that; maybe someone else will know the answer.
15:40:39 <Sgeo> At some point, I do plan on using cabal
15:40:46 <kmc> now we have a more specific type for (.)
15:40:49 <mike-burns> I use a mix of runhaskell then cabal build.
15:41:00 <miden> hmm ok
15:41:03 <kmc> (.) :: ([[d]] -> [d]) -> (a -> [[d]]) -> (a -> [d])
15:41:14 <Sgeo> Maybe I should try to get Cabal going right now?
15:41:21 <Sgeo> Or is it possible to put it off?
15:41:25 <mike-burns> It's always the first thing I do.
15:41:34 <kmc> now the second argument to (.) must have type (a -> [[d]]), and we know it's (map concat), with type [[[e]]] -> [[e]]
15:42:02 <kmc> so e = d,  a = [[[d]]]
15:42:33 <kmc> (.) :: ([[d]] -> [d]) -> ([[[d]]] -> [[d]]) -> ([[[d]]] -> [d])
15:42:34 <miden> aaaaaah oook
15:42:41 <miden> that was the part that i was missing :D
15:42:45 <kmc> and having applied two arguments to that, the result is  [[[d]]] -> [d]
15:42:51 <kmc> :t concat . map concat
15:42:52 <lambdabot> forall a. [[[a]]] -> [a]
15:42:52 <miden> yes
15:42:54 <miden> thanks
15:42:55 <kmc> :)
15:42:58 <kmc> no prob
15:42:59 <miden> thanks a lot
15:43:10 * kmc considers writing a little tool which can produce exposition like the above
15:43:12 <xplat> xtalmath: maybe you'd be interested in game semantics and the related generalized quantifiers, but it might be a little tough before you get more of a handle on regular first-order quantifiers
15:43:47 <mike-burns> kmc: Upon reading this PDF of high-level FFI in Haskell I've realized: I was there when you presented this, and I remember it as one of the best talks at Boston Haskell.
15:43:51 <Sgeo> mike-burns, I just moved my GHCi invocation up the directory
15:43:56 <Sgeo> So that :l Network.Blah.A works
15:43:57 <mike-burns> Sgeo: Did that fix it?
15:44:03 <Sgeo> And it's working now, yes
15:44:09 <kmc> aww thanks mike-burns
15:44:09 <mike-burns> Oh! Well, fantastic.
15:44:14 <kmc> (the slides are updated since)
15:44:21 <Sgeo> Except for the syntax error in A, but whatever
15:44:25 <mike-burns> Heh.
15:45:33 <kmc> mostly i have switched from html/s5 to pdf/beamer, but I also made a number of small changes to the content
15:45:37 <shachaf> Hmm, Hac Boston is coming up.
15:45:38 <Rc43> I can use [x->y, x->y->z] only with heterogenous lists, right?
15:45:45 <shachaf> Cale: Are you going?
15:45:56 <kmc> Rc43, what does that even mean
15:46:00 <kmc> that's not valid haskell syntax
15:46:24 <Rc43> kmc, list of functions, the first has one argument, the second - two
15:46:41 <shachaf> Rc43: What do you intend to do with such a list?
15:46:51 <kmc> yes, you should tell us what you're trying to do
15:47:21 <roconnor> @hoogle intercalate
15:47:22 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:47:22 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
15:47:22 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
15:47:27 <roconnor> @hoogle intersperse
15:47:27 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:47:27 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
15:47:27 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
15:47:52 <shachaf> Even if you had a list like this, it would be useless because you wouldn't know what to do with an element in it. You can't say things like "if numberOfArguments f == 1 then f x else f x y".
15:48:02 <Rc43> shachaf, kmc, emmm...
15:48:21 <Rc43> my thought was unfinished =/
15:48:22 <kmc> you can do it with Data.Dynamic, but most cases when people say they want Dynamic are an instance of WAYRTTD
15:48:35 <shachaf> @whatis WAYRTTD
15:48:35 <lambdabot> I know nothing about wayrttd.
15:48:43 <kmc> What Are You Really Trying To Do
15:48:55 <shachaf> @where+ WAYRTTD What Are You Really Trying to Do?
15:48:55 <lambdabot> It is forever etched in my memory.
15:49:05 <shachaf> @where+ WAYRTTD What Are You Really Trying To Do?
15:49:05 <lambdabot> Done.
15:49:09 <kmc> that is, you have some goal in mind, and you have decided that dynamic types are the right way to do it (which is rare), and ask us how to use dynamic types
15:49:31 <Rc43> I want to implement independent processses, which have common interface, and one of them can interrupt with other.
15:50:02 <Rc43> e.g. one process is called 'world', other 'input'.
15:50:16 <Renze> Is just typing some numbers random enough to get good different results in finding neighbor solutions completely random? As I want to have it randomly deterministic, I use setStdGen ...
15:50:38 <kmc> StdGen sucks, so no it isn't sufficient
15:50:53 <Renze> Why does it suck? :(
15:51:02 <kmc> poor quality randomness; slow
15:51:05 <ciaranm> because it isn't random
15:51:09 <kmc> like most builtin PRNGs
15:51:17 <kmc> i recommend http://hackage.haskell.org/package/mwc-random or one of the mersenne packages
15:51:49 <gwern> > 9055 + 7912
15:51:50 <lambdabot>   16967
15:51:51 <mike-burns> Rc43: OK so you have two processes which are each listening to a known ... socket? And they're sending messages?
15:51:59 <mike-burns> Or do I not understand at all.
15:52:15 <Renze> Well, I needed to know this some time earlier.
15:52:20 <Renze> How slow is slow?
15:52:35 <Renze> As the fastness of my implementation kind of matters (actually quite a lot).
15:52:42 <ciaranm> Renze: seven and a half
15:53:05 <kmc> Renze, benchmark it using Criterion
15:53:09 <kmc> that is the way to find out how slow things are.
15:53:51 <rageous> Suggestions for better understanding of Curried Functions? (learnyouahaskell isn't cutting it for me)
15:53:56 <kmc> i saw some example with a StdGen seed for which randoms returns a list starting with False thousands of times
15:53:59 <shachaf> ciaranm: That's pretty slow.
15:54:12 <kmc> rageous, a "function of 2 arguments" is really a function of 1 argument, which returns a function to take the second argument
15:54:22 <kmc> it's not a language feature, but a convention
15:54:30 <kmc> you can do this in any language with first-class functions (which is almost all of them)
15:54:42 <kmc> but Haskell's syntax and libraries strongly encourage you to follow this convention
15:54:43 * hackagebot time-http 0.5 - Parse and format HTTP/1.1 Date and Time strings  http://hackage.haskell.org/package/time-http-0.5 (MasatakeDaimon)
15:55:03 <rageous> Why is it important?
15:55:07 <peterjoel> and if you aren't getting it, it's more likely that you're expecting the idea to be more complicated than it actually is :)
15:55:14 <rageous> It could be.
15:55:15 <kmc> because it makes code look nicer
15:55:18 <mike-burns> It's convenient.
15:55:27 <kmc> through "partial application" which isn't really
15:55:30 <kmc> > map (subtract 2) [1..10]
15:55:31 <lambdabot>   [-1,0,1,2,3,4,5,6,7,8]
15:55:48 <mike-burns> :t subtract
15:55:49 <lambdabot> forall a. (Num a) => a -> a -> a
15:55:51 <mike-burns> :t subtract 2
15:55:52 <lambdabot> forall t. (Num t) => t -> t
15:55:56 <kmc> subtract is a "2-argument function" but we can apply one argument and then pass the result to 'map'
15:56:10 <ciaranm> now try writing that in java
15:56:17 <rageous> You must blow minds for a living. Thank you.
15:56:24 <kmc> nah it's just a hobby for me
15:57:27 * rageous dies
15:57:46 <rageous> So, I could define divideByTen = (/10) and map that to a list, and... it'll just do that. That's awesome.
15:57:50 <kmc> yes
15:57:58 <kmc> though you're invoking an extra Haskell feature there
15:58:03 <kmc> "operator sections"
15:58:26 <Rc43> mike-burns, sorry; it seems, that I haven't thought about it enough, forget it
15:58:30 <kmc> in fact that case "partially applies" the *second* argument, which you can't really do in general
15:58:38 <kmc> (/ 10)  is syntactic sugar for   (\x -> x / 10)
15:58:48 <shachaf> kmc: Well, you can do it in general with operator sections.
15:58:52 <kmc> > map (/ 10)  [1..10]
15:58:54 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
15:58:58 <shachaf> But, yes, that's not an example of "partial application".
15:59:13 <kmc> rageous, defining the name divideByTen would be counterproductive;  (/10) is a better name than divideByTen
15:59:43 * hackagebot ismtp 4.0.2 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-4.0.2 (ErtugrulSoeylemez)
15:59:45 <ciaranm> doesn't "partial application" usually mean a generalisation of currying to any "argument"?
15:59:47 <mike-burns> `divideByTen' would ctrl-p complete in vim.
16:00:06 <kmc> this explains some of the gaps in the Haskell standard library...  filter (== x)   is a nicer name than  filterEquals x
16:00:14 <shachaf> mike-burns: Not if you also have divideByFive and divideByTwo
16:00:25 <mike-burns> shachaf: Ah, quite true.
16:00:37 <shachaf> mike-burns: And at any rate it's more keystrokes than (/10).
16:00:53 <rageous> kmc: So you're suggesting that a definition isn't actually needed. Simply mapping (/10) will give me what I need.
16:00:58 <kmc> yes
16:01:03 <kmc> > map (/10)  [1..10]
16:01:04 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
16:01:19 <kmc> > map (map (+3)) [ [1,2,3],  [10,20,30] ]
16:01:20 <shachaf> kmc: Going by the Haskell library pattern, "filter" might be called "selectBy" or something along those lines.
16:01:20 <lambdabot>   [[4,5,6],[13,23,33]]
16:01:37 <monochrom> shachaf: the formula was Stokes's theorem
16:02:02 * monochrom loves Stokes's theorem
16:02:19 <rageous> Very cool.
16:03:12 * monochrom was in a differential geometry class. the manifold kind. the last homework had: prove Stokes's theorem :)
16:03:14 <Fuco> does it have sometihngto do with Gauss's theorem (divergence)?
16:03:20 <Fuco> it seems a bit similar
16:03:40 <monochrom> Stokes's is more general than Gauss divergence
16:03:40 <kmc> rageous, this also means that some care is required when choosing the order of arguments to a function you're defining
16:03:49 <rageous> I can see that.
16:03:51 <mike-burns> :t flip
16:03:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:03:54 <kmc> you want to anticipate the arguments which might be "partially applied" and put them toward the left
16:03:58 <kmc> :t Prelude.flip
16:03:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:04:02 <Sgeo> @hoogle String -> CString
16:04:02 <lambdabot> Foreign.C.String newCAString :: String -> IO CString
16:04:02 <lambdabot> Foreign.C.String newCString :: String -> IO CString
16:04:02 <lambdabot> Prelude read :: Read a => String -> a
16:04:17 <kmc> though there are tricks
16:04:22 <kmc> > map (`map` [1,2,3]) [ pred, succ ]
16:04:23 <lambdabot>   [[0,1,2],[2,3,4]]
16:04:27 <Fuco> operator sections are tricky with non comutative operators :P
16:04:29 <kmc> people might look at you funny if you write code like that
16:04:40 * mike-burns looks at kmc funny
16:04:50 <kmc> > fix((0:).scanl(+)1)
16:04:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:04:53 <dgpratt> kmc, rageous: a nice side-effect is that Haskell functions tend to have a predictable parameter order
16:04:56 * monochrom looks at map (`map` [1,2,3]) [ pred, succ ] funny
16:05:29 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml explains fix((0:).scanl(+)1)
16:05:48 <rageous> monochrom: I think you're supposed to look at kmc funny for writing that, rather than looking at what he wrote.
16:05:50 <Fuco> @type fix
16:05:51 <lambdabot> forall a. (a -> a) -> a
16:05:56 <kmc> could be both
16:05:56 <Renze> I can't find it in the ghc documentation, so I'll ask it here: what does the flag -fvia-C do? Apart from doing something via c.
16:05:58 <Fuco> what did I expect...
16:06:16 <kmc> Renze, it compiles your Haskell code via C to machine code
16:06:18 <kmc> it's deprecated now
16:06:31 <kmc> the alternatives are direct code generation and LLVM
16:06:36 <Renze> Ok, tnx.
16:06:46 <hpc> Renze: ghc compiles hs -> core -> assembly
16:06:51 <hpc> or llvm
16:06:56 <kmc> with many other stages
16:07:02 <kmc> (it's actually not 'deprecated' in that it's still used for a majority of platforms... but not the most important ones)
16:07:12 <monochrom> -fvia-C generates a C file, gives it to gcc, gets assembly back, and butchers the assembly first before committing it to object code
16:07:18 <kmc> monochrom, not anymore
16:07:23 <rageous> kmc: A really basic question, how might I put in prints troughout, say, quicksort to see intermediate stages of the recursive process?
16:07:30 <monochrom> oh? no evil mangler?
16:07:38 <mike-burns> The evil mangler is gone.
16:07:38 <kmc> right, evil mangler was removed in GHC 7.0
16:07:50 <kmc> now -fvia-C is disabled by default
16:08:09 <kmc> you can compile a GHC which has it, in which case it uses the simpler "unregisterized" C backend, with much worse performance
16:08:33 <kmc> to summarize, what was removed in 7.0 was the idea that fvia-C would be performance-competitive with the others, and it was vastly simplified as a result
16:08:59 <kmc> rageous, the quick and dirty way: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.3.1.0/Debug-Trace.html
16:08:59 <Fuco> rageous: writer monad
16:09:19 <monochrom> so if I go unregisterized, I don't need mangling?
16:09:24 <kmc> correct
16:09:25 <Fuco> either way it's not very simple, I struggled with that exact issue a lot when I "started" with haskell
16:09:32 <mike-burns> :t traceShow
16:09:33 <lambdabot> Not in scope: `traceShow'
16:09:57 <kmc> unreg'd backend has existed for many years... you decide when you compile GHC whether fvia-C should be unregisterized or {registerized (pre 7.0), absent (7.0+)}
16:10:04 <hpaste> Andrew__C pasted âQuasiQuote newbie questionâ at http://hpaste.org/56008
16:10:21 <Andrew__C> how fix?
16:10:30 <kmc> registerized "C" backend was hardly via-C, as it used many GCC extensions as well as custom post-processing of the assembly code
16:10:34 <monochrom> that actually frees up GHC team time for something else more worthwhile
16:10:52 <kmc> the benefit was taking advantage of GCC's many backend optimizations
16:10:58 <rageous> Fuco: Is this how one might go about debugging a misbehaving function?
16:11:06 <kmc> which benefit is now obtained from LLVM instead
16:11:24 <hpc> LLVM is closer to a suitable compilation language than C
16:11:35 <kmc> indeed
16:11:46 <hpc> given that C is explicitly a human-written language :P
16:11:51 <kmc> that does not follow
16:11:54 <Sgeo> If I have an foreign library that loves to return error codes, and it's all in IO, should I be doing stuff with Either, or should I be throwing exceptions?
16:12:00 <ion> I want a 6502 code generator for GHC.
16:12:01 <kmc> with a few extra features, C could be a good backend language
16:12:09 <Sgeo> Most of the time, error code other than 0 is bad, maybe once or twice it should be read
16:12:14 * monochrom still has an unused 6502 chip!
16:12:19 <kmc> in fact, GHC compiles through Cmm, which is a derivative of C--, which was intended to be a cross-platform backend language like LLVM
16:12:20 <mike-burns> Sgeo: I vote doing stuff with Either !
16:12:21 <Sgeo> I'm thinking that those occasions it's easy to use Control.Exception.try or something
16:12:36 <Sgeo> @hoogle Control.Exception.try
16:12:36 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
16:12:36 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
16:12:36 <lambdabot> Control.Exception.Base tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
16:12:39 <Fuco> rageous: well I have no idea what are "proper" tools for the job, but if you want to "log" the computation writer monad is the best choice I guess
16:12:43 <kmc> but C-- never really caught on, so GHC itself compiles the C-- to LLVM or C or "C" or native assembly
16:12:53 <Andrew__C> Sgeo: Either seems more polite to me.
16:12:58 <Saizan> Sgeo: i'd go with exceptions if you're already in IO
16:13:05 <kmc> hpc, assembly is explicitly a human-written language too
16:13:11 <monochrom> rageous: use Debug.Trace, it works by a backdoor, but you aren't abusing it anyway
16:13:26 <kmc> Sgeo, i vote for exceptions (and a custom exception type)
16:13:33 <kmc> but can you tell us more about the error conditions
16:13:35 <Fuco> rageous: http://book.realworldhaskell.org/read/monads.html here's a RWH article on it
16:13:47 <kmc> is it likely that errors would be handled locally, or far away at some outer last-ditch restart loop?
16:13:58 <Fuco> monochrom: does it use unsafe io or what is the backdoor?
16:14:09 <monochrom> the backdoor is unsafe io
16:14:22 <Sgeo> Most of the time it's stuff like a lost connection, or a world not existing, or there's one for forgetting to initialize the library
16:14:38 <kmc> probably exceptions
16:14:42 <Sgeo> There's one or two that are used to mean "Continue calling the function, we're not done yet"
16:14:43 <kmc> Either is pretty annoying
16:14:51 <kmc> oh, those i might handle differently
16:14:59 <kmc> in fact you can wrap them at a higher level
16:15:09 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml :)
16:16:33 <Sgeo> kmc, actually, I'm mistaken, that's not an RC, that's... wait, it is
16:16:51 <Sgeo> Oh, no, it's not.
16:16:59 <Sgeo> It uses one of the library's global variables.
16:17:02 <Sgeo> I kid you not
16:17:04 <kmc> sounds like a fun library you're dealing with
16:17:17 <Sgeo> http://wiki.activeworlds.com/index.php?title=Aw_query
16:17:20 <Sgeo> Yes, very fun.
16:17:23 <kmc> sometimes additional layers of C is the right answer
16:17:43 <Sgeo> Look at the example code
16:17:48 <kmc> i think I looked at this library before
16:17:52 <kmc> and had a ... negative reaction
16:18:29 <Renze> kmc: do you know any example of mwc-random?
16:18:51 <Andrew__C> is there anyone who could write me a one-line QuasiQuoter that just gives me the String back as a String literal? http://hpaste.org/56008
16:19:16 <kmc> Renze, http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-2.html
16:19:22 <kmc> search for 'mwc-random' or 'RNG.'
16:20:53 <keseldude> maybe map2M
16:28:00 <Andrew__C> Sorry to ask again: could anyone help me with a QuasiQuoter definition?
16:29:08 <kmc> Andrew__C, these days, the QuasiQuoter type has four fields
16:29:28 <kmc> https://github.com/kmcallister/hexquote/blob/master/Data/Hex/Quote.hs#L151
16:29:30 <monochrom> str = QuasiQuoter { quoteExp = stringE }
16:29:39 <monochrom> and [str|test   |], no $
16:30:07 <monochrom> and it took me that long because unless other irresponsible answerers, I had to set up and test my code first
16:30:14 <monochrom> s/unless/unlike/
16:30:21 <kmc> hey, hexquote is tested!
16:30:31 <kmc> i promise
16:31:00 <monochrom> and {-# LANGUAGE QuasiQuotes #-} or -XQuasiQuotes
16:31:30 <geheimdienst> Andrew__C: this module helped me get up to speed on template haskell -- http://hackage.haskell.org/package/shqq-0.1
16:33:26 <geheimdienst> Andrew__C: (i mean, click the "source" link on the module's documentation page, just in case this wasn't obvious)
16:33:55 <kfish> Renze, did you find examples for mwc-random? i added some docs recently but not yet released:https://github.com/bos/mwc-random/blob/master/System/Random/MWC.hs
16:33:55 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
16:36:05 <Renze> kmc: well, I was looking for something which works like getStdRandom, because I don't want to pass a seed as my program works fine and rewriting 'everything' is kind off too much work (deadline is in 46 hours), but I see you use defaultSeed. Is it still random if I constantly use defaultSeed?
16:36:18 <Renze> Probably not, but still asking to be sure
16:37:01 <kmc> i'm confused; do you want to specify a seed or not
16:37:15 <Renze> No, not.
16:37:20 <kmc> i'm using withSystemRandom
16:37:23 <Renze> As in: specifying maybe, but not necessary
16:37:26 <kmc> "Seed a PRNG with data from the system's fast source of pseudo-random numbers ("/dev/urandom" on Unix-like systems)"
16:37:38 <Andrew__C> monochrom: works a treat, thanks...
16:37:41 <Renze> But not passing the seed to another function to use it over there again
16:37:50 <Renze> I have windows :(
16:38:05 <Andrew__C> geheimdienst: thanks.
16:38:09 <Andrew__C> kmc: thanks
16:38:23 <kfish> Renze, write your pure functions taking a seed as their last argument, then call that from your application using withSystemRandom
16:38:56 <kmc> Renze, I don't read that as implying it doesn't work on windows
16:39:07 <monochrom> I have updated the haskell wiki page for that
16:39:10 <kmc> "on Windows, this code does not yet use the native Cryptographic API as a source of random numbers (it uses the system clock instead)"
16:43:09 <Renze> kfish: what do you mean exactly?
16:45:01 <Renze> Wait, I read the last argument part wrong.
16:47:26 <Renze> I'm getting ambiguous type variable m0 in the constraint
16:48:21 <Rc43> How can I manage processes interaction?
16:48:50 <Rc43> With sockets? With pipe file? With any memory tricks?
16:49:59 <ddarius> monochrom: The formula was a generalized form of Stokes theorem which includes Green's theorem and the typical "fundamental theorem of calculus" and more.
16:50:59 <Renze> I solved it.
16:51:07 <Renze> But... not really random I think
16:54:25 <hpaste> Renze pasted âRandom?â at http://hpaste.org/56009
16:54:31 <The_Journey> is there a function that replaces a list to the head of another list? Like say k1 = [1,2,3] and k2 = [0,0,0,4,5,6,7], is there a function that do like fooBar k1 k2 and the result is [1,2,3,4,5,6,7]?
16:54:48 <kmc> > [1,2,3] ++ dropWhile (== 0) [0,0,0,4,5,6,7]
16:54:50 <lambdabot>   [1,2,3,4,5,6,7]
16:55:04 <The_Journey> kmc: thank you very much
16:55:07 <Cale> er
16:55:09 <The_Journey> kmc: wait not
16:55:11 <The_Journey> wait no
16:55:21 <Sgeo> Are there any good quasiquoters for C enums?
16:55:23 <Cale> Yeah, that's not at all what he asked for :)
16:55:24 <The_Journey> say the first elements are random and not 0
16:55:25 <Renze> kmc, kfish: this is the consequence of using windows. Should that be random enough for something which takes a random number like every 25 lines (including extra functions etc.)?
16:55:40 <mike-burns> Use splitAt instead of dropWhile.
16:55:41 <companion_cube> > let f l1 l2 = l1 ++ (drop (length l1) l2)
16:55:42 <lambdabot>   not an expression: `let f l1 l2 = l1 ++ (drop (length l1) l2)'
16:55:42 <kmc> how would i know how long 25 lines takes
16:55:57 <companion_cube> > let f l1 l2 = l1 ++ (drop (length l1) l2) in f [1,2,3] [0,0,0,4,5,6]
16:55:58 <lambdabot>   [1,2,3,4,5,6]
16:56:23 <The_Journey> companion_cube: thank you
16:56:25 <Renze> You don't of course, but I don't know how to explain otherwise
16:56:39 <kmc> Renze, by measuring the time?
16:57:11 <kmc> better yet, you should log the random numbers and apply your favorite statistical tests of randomness
16:57:58 <ddarius> Renze: replicateM
16:59:17 <rwbarton> > let f l1 l2 = zipWith ($) (map const l1 ++ repeat id) l2 in f [1,2,3] [0,0,0,4,5,6]
16:59:19 <lambdabot>   [1,2,3,4,5,6]
17:03:00 <Sgeo> ??
17:03:26 <kmc> !!
17:03:42 <mike-burns> :t (??)
17:03:43 <lambdabot> Not in scope: `??'
17:03:47 <Eduard_Munteanu> :t (!!)
17:03:48 <lambdabot> forall a. [a] -> Int -> a
17:04:17 <lukish> I have some question about 2-dimension memoization. For example, I wanna have all value of f a b = sum . map (\x -> x*x) $ enumFromTo a b
17:04:23 <lukish> How can I manage it
17:04:27 <mdmkolbe> Why does "$( recover [|1 1|] [|2|])" produce the expression "2" but "$(recover [|(1 :: Int) (1 :: Int)|] [|2|])" produce an exception?  I thought "recover" would catch the failing action.
17:04:30 <Rc43> Is it normal to interact between processes, launched on one machine, using RPC?
17:04:33 <lukish> Using Array (Int,Int) Integer
17:04:34 <Sgeo> Is HSFFIG maintained?
17:06:13 <Eduard_Munteanu> lukish: what's there to memoize?
17:06:29 <mike-burns> Rc43: RPC is common, as is a socket or a pipe file or signals (e.g. SIGUSR1) or a common database.
17:07:12 <lukish> Eduard_Munteanu: f i k = i*i + f(i+1) k
17:07:14 <Rc43> mike-burns, which way is cross-platform?
17:07:20 <rwbarton> mdmkolbe: do you have the argument order of recover backwards perhaps?
17:08:06 <mike-burns> Rc43: I've no idea. Everything I just listed works on all the platforms anyone I know uses, but there could be other limitations.
17:08:39 <mike-burns> And other platforms.
17:08:58 <Rc43> mike-burns, I am not sure, but for example linux and windows have different implementations of all ways. Am I right?
17:09:12 <lukish> Eduard_Munteanu: I don't want to recalculate some values many times. When I need f 10 20 I calculating f 10 11, f 10 12, f 10 13 ...
17:09:15 <mdmkolbe> rwbarton: You are right that I had the order backwards, but now both of them give type errors (???)
17:09:18 <Eduard_Munteanu> lukish: ah, across multiple calls.
17:09:22 <kmc> lukish, i don't like arrays.  the nice way to memoize is http://hackage.haskell.org/package/data-memocombinators or http://hackage.haskell.org/package/MemoTrie
17:09:25 <mike-burns> Rc43: No idea. I only know programmers and very end users, not Windows users.
17:09:27 <Rc43> Excepting the read-file-by-timer-way :D
17:10:32 <Rc43> mike-burns, may be it will be enough to program for unix only ..
17:10:39 <xplat> > foldr (\a -> ((a:) .) . (. drop 1)) id [1,2,3] [0,0,0,4,5,6]
17:10:41 <lambdabot>   [1,2,3,4,5,6]
17:10:41 <mike-burns> Rc43: And for other platforms you'd do it differently too; for example, in Android you'd use a Service or maybe a Broadcast.
17:10:58 <kmc> memoization basically requires mutation; these libraries exploit the fact that laziness is implicit mutation
17:11:00 <mike-burns> I think it's enough to get sometihng working.
17:11:24 <Eduard_Munteanu> Right.
17:11:40 <Eduard_Munteanu> I'm not sure there's an (obvious) way to do it here.
17:11:40 <rwbarton> mdmkolbe: probably because type checking does not happen until after TH splices are run
17:11:56 <hpaste> kfish pasted âRandomer?â at http://hpaste.org/56010
17:12:08 <Rc43> mike-burns, what is it? (service and broadcast are too common words to google it)
17:12:16 <Eduard_Munteanu> Well, short of using a toplevel a x b array (or similar).
17:12:26 <mike-burns> Rc43: Ah, you won't be using Haskell for Android anyway.
17:12:42 <kmc> http://hackage.haskell.org/package/thrift is rumoured to be a nice way to do RPC
17:12:57 <kmc> the protocol is used extensively by Facebook
17:12:58 <kfish> Renze: that last paste just uses one gen, can you refactor like that?
17:13:31 <rwbarton> mdmkolbe: sadly the TH documentation does not go into much detail about recover, but I guess it recovers from exceptions raised while running the Q monad
17:13:40 <mdmkolbe> rwbarton: hmm, then "recover" is less useful than I thought.
17:14:01 <mike-burns> Rc43: If you go with a pipe file you'll need to define a common protocol, which will help for when you try RPC or HTTP, etc.
17:14:34 <Rc43> I am afraid that it will be too heavy for me. I want a desktop application which will be launched in some separated processes
17:14:43 <kmc> people have been reinventing RPC protocols for like 50 years
17:14:46 <kmc> it's really funny
17:14:54 <mike-burns> It's one of the easiest things to re-invent.
17:15:02 <kmc> and one of the easiest to get wrong?
17:15:06 <mike-burns> Yeah!
17:15:20 <mike-burns> Which do you think is more re-invented: RPC, or make ?
17:15:24 <Rc43> kmc, I have worked with java RMI, it was not bad
17:15:41 <kmc> the 4 dozen existing RPC systems all suck because they're written by idiots, but mine will be great because i am a genius
17:15:41 <ddarius> mike-burns: RPC
17:15:41 <mike-burns> Rc43: How about threads instead of processes?
17:15:44 <Renze> Did you see my last two messages?
17:15:54 <ddarius> kmc: Damn straight.
17:16:11 <Rc43> mike-burns, I want ot be able reset one part of application and save other
17:16:39 <Rc43> mike-burns, for example, one part computes something, and other manages it
17:16:59 <Eduard_Munteanu> I guess you can look at any data passed between two entities as RPC, no?
17:17:13 <kmc> if you don't, you're even more likely to reinvent it
17:17:14 <Eduard_Munteanu> Erm, s/entities/processes/
17:17:27 <kmc> the word 'process' is barely more specific than 'entity'
17:18:12 <xplat> it has a very specific meaning in unix, and another very specific meaning in windows
17:18:22 <Eduard_Munteanu> Well, I'm not sure about mere threads.
17:18:25 <kmc> and another in Erlang, and...
17:18:36 <Rc43> I have in mind some complex interfaces between processes, so it will be better just call a function then give message
17:18:50 <mike-burns> Oh, you want to go message passing.
17:19:00 <russellw> In practice, its meaning in Unix and Windows is very similar, and that's what the word process is taken to mean unless another context is specified
17:19:08 <Rc43> mike-burns, ?
17:19:16 <kmc> 'thread' also means nothing in general.  worse yet, it has such a negative connotation that new languages (like Go) have to invent new words rather than calling them 'threads'
17:19:31 <xplat> Rc43: just use thrift, or use erlang, or use E
17:19:44 <mike-burns> Yeah.
17:19:53 <mike-burns> It really sounds like you want Erlang.
17:19:54 <Eduard_Munteanu> The question I'm not sure about is how much overlap there is between message passing and RPC, and if it's possible (or common) to misuse one for the other.
17:19:56 * mike-burns looks into E.
17:20:08 <kmc> Eduard_Munteanu, very common
17:20:41 <companion_cube> RPC can be used for message passing quite easily, I'd say
17:20:47 <Rc43> Do you know, is it hard to program with haskell+erlang in the one project?
17:20:59 <kmc> probably
17:21:07 <mike-burns> From what I've seen: yes.
17:21:14 <xplat> probably thrift will be the best RPC system for general languages right now
17:21:17 <AfC> Mixing runtimes is usually a recipe for pain.
17:21:18 <kmc> not so bad to have them in separate processes communicating by.... a standard RPC protocol
17:21:23 <Cale> hmm, there are some libraries which claim to be useful in that regard though
17:21:32 <AfC> Nothing like duelling garbage collectors to really thrash things.
17:21:33 <kmc> and there is http://hackage.haskell.org/package/erlang
17:21:41 <Rc43> kmc, it isn't interesting :D
17:21:42 <xplat> i'm not saying that having looked at it or anything, it just seems to be at the right point in the Inevitable RPC Lifecycle
17:21:44 <companion_cube> xplat: what about xml-rpc?
17:21:48 <companion_cube> it seems really simple
17:21:57 <Rc43> kmc, (i am about the first msg)
17:22:09 <xplat> companion_cube: yes, it does /seem/ really simple, xml-rpc does :P
17:22:11 <AfC> [we helped someone mix Java, Python and [C] GObject once. Hard problems, and after all that, slow as]
17:22:22 <kmc> i expect relatively few people actually do it, and so regardless of which libraries technically exist, it won't work well
17:22:51 <Renze> kmc: I'm getting a divideByZero error, while I'm sure I don't do that (I divide twice, once with a pattern match on 0 and once with fromIntegral $ 10 ^ x , which never is 0). Could that be because of the system clock?
17:23:02 <kmc> don't know
17:23:11 <rwbarton> fromIntegral $ 10 ^ x could be 0
17:23:22 <Eduard_Munteanu> companion_cube: the other way around is possible as well
17:23:28 <Renze> rwbarton: when?
17:23:34 <kmc> > fromIntegral (2 ^ 8) :: Word8
17:23:35 <lambdabot>   0
17:23:36 <rwbarton> > fromIntegral $ 10 ^ 100 :: Int
17:23:37 <lambdabot>   0
17:24:10 <lukish> kmc: am I doing it right? http://hpaste.org/56011
17:24:15 <Renze> it's an Int not greater than 4 to be precise.
17:24:39 <kmc> probably
17:24:49 <xplat> besides xml, the main problem with xmlrpc is that it is permanently frozen at the 'good enough for Dave Winer's personal use' stage
17:24:58 <Renze> (besides, that should happen before the real work is done, and the error is during the real work)
17:25:10 <Eduard_Munteanu> I'm not sure I can find fundamental reasons to say one should use one or the other, except for technical details like performance concerns related to the underlying protocol.
17:25:10 <lukish> kmc: I'm asking because of no velocity increasing
17:25:11 <kmc> i don't consider xml a problem as long as I don't have to write it or look at it or care especially about performance
17:25:13 <wavewave> hi
17:25:19 <kmc> lukish, are you compiling your code with ghc --make -O2
17:25:33 <Rc43> maybe, anybody can say something about hessian/protobuf?
17:25:50 <kmc> i used protobuf once; it's pretty far from a RPC system, though it has some hooks to let you write one
17:25:56 <lukish> kmc: I just testing it in ghci
17:25:59 <kmc> also at that time (several years ago) the Python bindings were terribly slow
17:26:08 <kmc> C and C++ were ok, and that was all that existed
17:26:27 <xplat> yeah, i would have mentioned protobuf if you were looking for a versionable serialization framework instead of an rpc system
17:26:41 <xplat> protobuf is more of a competitor for something like asn.1
17:26:44 <companion_cube> thrift looks like a rp built over an clone of protobuf
17:26:45 <wavewave> has anyone tried to run haskell in browser using PNaCl?
17:26:47 <kmc> or you can use xml+gzip or json+gzip or yaml+gzip or ...
17:26:59 <companion_cube> rpc*
17:27:12 <wavewave> using ghc llvm backend.
17:27:55 <Rc43> ok, imagine the app, where GUI interacts with program with thrift. Is it ugly enough?
17:27:57 <xplat> involving gzip in the chain means a call is pretty heavyweight
17:28:16 <mike-burns> Rc43: Seems like a great start.
17:28:38 <xplat> isn't serialization + a couple of syscalls bad enough?
17:29:04 <Rc43> xplat, maybe, I am newbie
17:29:12 <Rc43> xplat, and crossplatform way is preferable
17:29:12 <companion_cube> xplat: depends on whether you have a network between components, or just IPC
17:29:18 <mike-burns> When sending the data over some network it's possible (possible!) that gzipping will be faster.
17:29:46 <Rc43> xplat, and it will be veeeery cool to make GUI and program distributed in far future
17:29:49 <kmc> Rc43, I think you should just try Thift.  this debate can go on forever.
17:30:06 <kmc> you should pick one and see if it meets your needs and give up if it doesn't or if it takes too long to get working
17:30:14 <shachaf> I like to repeat (repeat!) words in parentheses (parentheses!) to make sure people really read them.
17:30:18 <kmc> it's pretty hard to guess performance otherwise
17:30:22 <companion_cube> reminds me that I never could make dbus work with haskell
17:30:25 <Rc43> kmc, how much overhead it can bring?
17:30:33 <kmc> 1.21 jiggawatts
17:30:37 <mike-burns> shachaf: Hey I've only done that once! I think.
17:30:41 <companion_cube> shachaf: (shachaf!) +1
17:30:55 <kmc> if you want you can make a little Thrift benchmark program using Criterion
17:31:12 <kmc> or find someone else's benchmark (though many benchmarks on the interwebs are crap)
17:31:13 <shachaf> I have the feeling I'm missing out by not using criterion.
17:31:20 <shachaf> Even though I have nothing Haskell-related to benchmark.
17:31:35 <shachaf> Maybe I should find something.
17:31:54 <kmc> shachaf, it's great for settling pissing matches about "I need unsafe code because it's FAST!!!!!!!11"
17:31:57 <kmc> and things like that
17:32:04 <ddarius> kmc: Many benchmarks are crap.
17:32:06 <kmc> also a better way to choose datastructures
17:32:16 <companion_cube> kmc: for loops are definitively faster than recursion, because they are loops
17:32:31 <Rc43> kmc, it seems it is good thing to start with
17:32:34 <companion_cube> and hashtables beat trees wth one hand
17:32:35 <kmc> hashtables are faster because O(1)!!!!!!!!!!!!!!
17:32:46 <rwbarton> the O(1) thing is hilarious
17:33:12 <ddarius> Hashtables usually do beat trees with one hand.
17:33:22 <rwbarton> since you can't even read the key in O(1) time (what would that even mean)
17:33:22 <kmc> it's true, but only because most trees are bad
17:33:30 <kmc> but what about fat hash tries
17:33:37 <xplat> what do they beat with the other hand?
17:33:46 <companion_cube> the coder
17:34:16 <Eduard_Munteanu> Hash tables are like Chuck Norris.
17:36:23 <ddarius> In one context, Justin Zobel explicitly designed a trie data structure for a particular full-text programming task (burst tries) which was much better than the other tree based alternatives, and also worse in pretty much every way than a move-to-front hash table with a simple hashing scheme.  Admittedly, the hashing scheme was novel if simple and the move-to-front heuristic was important and non-standard.
17:36:35 <hpc> hash tables are like quiche mixed with guacamole
17:36:47 <hpc> a burrito would be more preferable
17:37:02 <ddarius> Does the burrito have guacamole?
17:37:14 * ddarius like guacamole even though he doesn't like avocados.
17:37:33 <Eduard_Munteanu> Simple hashtables are relatively easy to write in a few languages, might explain their appeal.
17:37:49 <hpc> Eduard_Munteanu: and built into even more
17:38:01 <Eduard_Munteanu> E.g. dumb hashtable vs a red-black tree implementation in C
17:38:28 <xplat> hashtables are easy to screw up
17:38:40 <kmc> C is easy to screw up
17:38:52 <ddarius> Programming is easy to screw up
17:38:54 <mike-burns> Programming is easy to screw up.
17:38:57 <mike-burns> Oh snap.
17:39:04 <Eduard_Munteanu> xplat: even dumb hash functions can be pretty good, I'd say
17:39:14 <hpc> 90% of everything is already screwed up
17:39:17 <xplat> well, there are many ways to screw them up, and end up with something like an exploitably bad hash function
17:39:24 <ddarius> Dumb hash functions are usually best.
17:39:29 <ddarius> hpc: An optimist I see.
17:39:38 <pikhq> xplat: We're discussing hash table hashes, not cryptographical hashes.
17:39:39 <HugoDani1l> hashtables: http://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html
17:39:46 <hpc> ddarius: i like to think that the 10% is my stuff ;)
17:39:52 <xplat> if you control the input, dumb hashes can be pretty good
17:39:55 <hughfdjackson> what's the state of haskell's audio bindings atm?
17:39:58 <ddarius> hpc: You must be extraordinarily productive.
17:39:59 <pikhq> xplat: Even a truly terrible hash function will *work* for the purpose.
17:40:03 <pikhq> (just... Not well.)
17:40:06 <hpc> ddarius: i like to think that too
17:40:09 <hughfdjackson> :p a general question, perhaps
17:40:11 <xplat> if you don't control the input, you could suddenly find yourself with a linked list
17:41:51 <Sgeo> Hmm
17:42:00 <Sgeo> How worried should I be about overuse of language extensions?
17:42:02 <lukish> kmc: why using sums slower than using sumsN ?
17:42:07 <mike-burns> Sgeo: Not worried.
17:42:07 <lukish> http://hpaste.org/56013
17:42:13 <rwbarton> depends on the language extensions in question
17:42:17 <kmc> Sgeo, depends which ones and what your goals are
17:42:31 <kmc> overusing type class extensions is a symptom of overusing type classes
17:42:43 <Sgeo> If I use ScopedTypeVariables then realize I could just move the signature...
17:42:46 * hughfdjackson sees you have a jack package
17:42:46 <Sgeo> >.>
17:43:07 <kmc> ScopedTypeVariables is fine, imo
17:43:09 <mike-burns> :t (>.>)
17:43:10 <lambdabot> Not in scope: `>.>'
17:43:33 <Sgeo> maybe (randomRIO (1,99) >>= \(r::Int) -> return ("SimpleIRC" ++ show r)) return mNick
17:43:48 <ddarius> As I said earlier today, I really don't know why that isn't just how Haskell always worked.
17:43:48 <Sgeo> I could have attatched the sig to the randomRIO (1,99) instead, right?
17:44:11 <companion_cube> https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/ xplat, to support your point on linked lists
17:44:32 <ddarius> companion_cube: That's essentially what HugoDani1l posted earlier.
17:44:44 <ddarius> Also, the first "real-world" example of this was done in 2003.
17:44:46 <companion_cube> aww, I missed his link
17:45:04 <ddarius> (Well published real-world example.)
17:45:05 <companion_cube> anyway
17:45:19 <ddarius> And actually, I don't know if that was the first, but it seems to think it was.
17:45:24 <ddarius> But probably so do these people.
17:47:49 <Rc43> How transports usage is described in thrift? There is TMemoryTransport, which, obviously, cannot be used with separated machines. Where its usage will be specificated? Or it will be done automatically by thrift?
17:48:37 <rwbarton> lukish: sums is only memoizing on the first argument 'a' of sums'
17:48:40 <rwbarton> which is useless
17:49:17 <lukish> For that function I don't how can I do it better
17:49:28 <rwbarton> use memo2
17:49:54 <lukish> Can you make annotation in hpaste?
17:50:11 <rwbarton> just replace 'integral' by 'memo2 integral integral'
17:50:31 <mike-burns> Rc43: Everything I'd tell you about thrift would be from this page: http://thrift.apache.org/
17:51:53 <Rc43> mike-burns, i have sequential access ;)
17:52:47 <lukish> rwbarton: should I memoize squares of natural numbers?
17:52:55 <lukish> If (\x -> x*x) fast?
17:53:02 <rwbarton> well think about it
17:53:05 <lukish> Is (\x -> x*x) fast?*
17:53:20 <lukish> I think this function is fast.
17:53:24 <rwbarton> yes
17:53:28 <lukish> For numbers lower than 10000
17:53:32 <rwbarton> assuming x is not millions of digits long or something
17:53:34 <mike-burns> Is it the slowest function in your code?
17:53:38 <mike-burns> Is it the bottleneck?
17:53:43 <rwbarton> it won't be if you memoize it :P
17:53:58 <lukish> mike-burns: slowest function is sums
17:54:01 <kmc> benchmark it using criterion
17:54:13 <lukish> Profiler said 99%
17:54:19 <hiptobecubic> rwbarton, not always true, the lookup cost might be high
17:54:25 <rwbarton> that is my point
17:54:35 <ddarius> hiptobecubic: He said it -won't- be fast.
17:54:36 <rwbarton> the lookup cost will exceed the cost of the original multiplication
17:54:43 <hiptobecubic> ah sorry. misread
17:54:48 <hiptobecubic> carry on then
17:54:55 * hiptobecubic backs into the shadows
17:55:12 <lukish> I memoized it and get memory overflow
17:55:34 <rwbarton> that doesn't surprise me
17:56:22 <rwbarton> well, maybe it does a little
17:56:44 <lukish> Well, I'm solving http://projecteuler.net/problem=125 if someone interested in what am I doing
17:57:25 <rwbarton> You should try doing some back-of-the-envelope calculations about how much memory you expect your program to need.
17:57:56 <Rc43> eeee, http://wiki.apache.org/thrift/LibraryFeatures?action=show&redirect=LanguageSupport
17:58:02 <kmc> that's hard because Haskell programs use like 20 times as much memory as you would expect
17:58:04 <Rc43> os support X haskell = {}
17:58:07 * ddarius wonders how much of Project Euler he could solve with his little dynamic programming function and no intelligence whatsoever.
17:58:13 <kmc> unless you are familiar with the details of the compiler you're using
17:58:14 <rwbarton> right, so include a fudge factor of 20 :P
17:59:15 <rwbarton> lukish: is sqrt1 1000000 = 1000? earlier you were talking about 10000
17:59:53 <lukish> sqrt1 (10^8)
17:59:53 <lukish> 10000
18:01:04 <lukish> rwbarton: am I doing right that apply memoized function to each value of long list?
18:01:04 <rwbarton> your hpaste writes sqrt1 1000000
18:01:28 <lukish> Well, it's no updated :)
18:01:31 <lukish> length . ( \n -> [ (x,y) | x <- [n,n-1..1], y <- [x+1..n] ] ) . sqrt1 $ 100000000
18:01:32 <rwbarton> did you change that 1000000 to upperBound? okay
18:01:34 <lukish> ^[^[[C49995000
18:01:42 <lukish> Yep.
18:01:49 <lukish> That list is really huge
18:01:50 <rwbarton> right, so this is obviously not going to work
18:01:50 <wavewave> if you memoize all list, it's similar to do foldl not foldl'
18:01:53 <rwbarton> 50 million elements
18:02:06 <rwbarton> in an ideal world, you need to store 4 bytes of data for each element so that is already 200 MB
18:02:19 <rwbarton> applying the haskell factor takes you to around 4 GB
18:02:36 <lukish> I have 8 gb ram
18:02:37 <monochrom> haha
18:02:45 <rwbarton> and 20 is quite conservative here because of the memo trie
18:03:05 <rwbarton> if you have 8 gb ram then you are probably on a 64-bit system so double everything
18:03:08 <monochrom> lazy list is certainly pretty fat for that. but try various arrays
18:03:23 <kmc> i wish GHC would get a mode where it uses 32-bit pointers on x86_64
18:03:30 <lukish> rwbarton: are you serious?
18:03:30 <kmc> mayhaps i should implement it
18:03:33 <monochrom> "pay double rent if you have the whole color group"
18:03:37 <rwbarton> kmc: yeah I've wanted that too
18:03:45 <rwbarton> lukish, why wouldn't I be serious
18:03:54 <lukish> Okay
18:04:05 <kmc> someone was discussing supporting such an ABI at the Linux kernel level
18:04:14 <monochrom> use an array
18:04:15 <kmc> i don't remember the name :/
18:04:21 <rwbarton> kmc: are there free bits in pointers so that we can address (> 1)-byte blocks?
18:04:23 <pikhq> x32, and they have code.
18:04:31 <lukish> Anywa, I feel uncomfortable about mapping memoized function to list length of 50 million elements
18:04:32 <pikhq> I don't know if it's any *good*, but they certainly have code.
18:04:38 <kmc> pikhq, thanks
18:04:52 <kmc> rwbarton, if you give up pointer tagging, or increase heap alignment
18:05:00 <kmc> both of those sound unpleasant
18:05:07 <monochrom> in an ideal world, people don't use a list for 50 million items
18:05:09 <pikhq> https://sites.google.com/site/x32abi/
18:05:19 <rwbarton> the problem isn't the list, the problem is he has a memotrie with 50 million items
18:05:24 <rwbarton> but yeah
18:05:42 <monochrom> oh, then I have to think again
18:05:46 <pikhq> Huh, some of it's upstream.
18:05:48 <rwbarton> anyways you can probably do this with a 10000x10000 array
18:05:54 <kmc> i wonder why kernel support is needed... it may speed up syscalls; is that the only reason?
18:06:04 <lukish> But, there is no any bung-hole in algorithm to reduce the bruteforce
18:06:23 <lukish> 10000x10000 array sounds great
18:06:25 <pikhq> kmc: The kernel might hand you pointers in 64 space.
18:06:43 <kmc> pikhq, what if i use mmap(... MAP_FIXED ...)
18:06:54 <Kaytee> EFWAGTHDYMTFNHTGRFEWDEFET
18:06:58 <kmc> you can use 32-bit syscalls from a 64-bit-personality process on x86_64, through int $0x80
18:07:10 <kmc> (this was a workaround for one of the CVE-2010-3081 countermeasures)
18:07:11 <hpaste> benmachine annotated âMissing Traversable instancesâ with âMore missing Traversable instancesâ at http://hpaste.org/56005#a56014
18:07:20 <kmc> but probably not through a faster path
18:07:36 <pikhq> Really? Well, then, there's no point in the 32-bit stuff except maybe adding a faster path, I suppose.
18:07:41 <monochrom> some of those trie implementations try not to use one node (3 pointers) per item
18:07:46 <rwbarton> kmc, pikhq, I'm not sure I understand what you're discussing exactly, just running a process in 64-bit mode but using 32-bit pointers?
18:07:56 <kmc> rwbarton, yes
18:08:00 <pikhq> Precisely.
18:08:07 <rwbarton> so you are still addressing just 4 GB of virtual memory
18:08:13 <kmc> that is, storing 32-bit pointers in memory, and loading them to the low 32 bits of %rax etc (which zero-extends the high 32 bits)
18:08:14 <kmc> yes
18:08:16 <rwbarton> okay
18:08:20 <pikhq> For *most* processes, 64-bit pointers are just a waste of space.
18:08:28 <kmc> but you have all the extra registers and other niceness of x86_64
18:08:33 <rwbarton> Yeah
18:08:38 <kmc> pikhq, arguably, that's because memory-mapped files are underappreciated
18:08:46 <pikhq> kmc: No argument there.
18:08:48 <pikhq> I â¥ mmap.
18:08:55 <kmc> and arguably *that's* because 32-bit compatibility is still an issue
18:09:00 <kmc> but it's also because people are generally ignorant
18:09:26 <kmc> how many programmers have implemented a crappy demand-paging system for big files using read(), when the OS has decades of effort going into precisely that problem
18:09:47 <Jafet> mmap has crappy guarantees
18:09:57 <pikhq> Jafet: Such as?
18:10:03 <blackdog> kmc: really? i can really only think of squid off the top of my head...
18:10:16 <Jafet> And probably half of those crappy guarantees are ignored on linux
18:10:45 <Jafet> pikhq: file disappears, everyone dies
18:10:50 <kmc> blackdog, dunno, it's a question I see pretty often on IRC, maybe i'm talking out of my ass
18:11:28 <pikhq> Jafet: File disappears, you get SIGBUS.
18:11:30 <shachaf> kmc: The OS has decades of effort going into precisely that problem if you want to do it in precisely the OS's way.
18:11:31 <rwbarton> kmc: yeah, I have a word search program that is using a database on disk mmap'ed with bytestring-mmap, it's a perfect interface for large read-only data and the total process startup time is < 1 ms
18:11:42 <monochrom> "how many programmers have implemented a crappy demand-paging system for big files using read()" answer: fewer than how many programmers have implemented crappy sorters using buggy sort
18:11:53 <pikhq> Not POSIX's fault that you can't use it right.
18:11:58 <mike-burns> And fewer than have implemented their own RPC.
18:12:12 <shachaf> E.g., using OS threads (because blocking on an mmap()ed page will block an OS thread and there's nothing you can do about it).
18:12:18 <mike-burns> But more than have implemented their own make(1) variant.
18:12:36 <blackdog> rwbarton: i'd love to have an easier way to mmap haskell data structures in and out
18:12:45 <Jafet> I thought linux would give you SIGSEGV
18:12:47 <companion_cube> I'd ike to write my own build system with a cloud-aware (xml based) rpc interface.
18:12:51 <companion_cube> Can you help me?
18:12:52 <blackdog> pretty much all of my linguistic programs are fast once they've loaded data, but hideously slow until that
18:13:10 <ddarius> blackdog: Stop having data.
18:13:13 <rwbarton> blackdog: that would be nice. in my case I put a fair amount of effort into designing a byte-efficient format for the data
18:13:13 <Jafet> companion_cube: only if you want to write it in webscale haskell
18:13:28 <rwbarton> perhaps it could be generalized
18:13:40 <blackdog> ddarius: if i didn't have gigs of data i'd have to actually know something about language
18:14:00 <pikhq> Jafet: That would be fairly silly. SIGSEGV is pretty clearly intended for "you wrote to something that Should Not Be Written To", not "you wrote to something that, BTW, disappeared on you."
18:14:02 <companion_cube> Jafet: only if I can refactor  it to agile javascript
18:14:22 <Jafet> blackdog, you could consult an augur
18:14:33 <ddarius> pikhq: That seems unreasonable.
18:14:33 <augur> O_O
18:14:39 <monochrom> companion_cube wins :)
18:15:02 <augur> whats this about linguistics now
18:15:19 <blackdog> augur: my fault
18:15:33 <augur> jet!
18:16:16 <ddarius> Giving money away is tricky.
18:16:35 <blackdog> ddarius: i can sympathise, and am willing to help you out
18:21:27 <kmc> conceivably an 'x32' GHC program could even use space above 4GB
18:22:35 <kmc> say, Haskell heap lives below 4GB, but you have data FarPtr = FarPtr FarAddr#
18:22:37 <Sgeo> I created low-level bindings with HSFFSIG, but no idea how to use the enums
18:22:40 <ddarius> Why wouldn't it be able to?  You'd just have to break out the old-school segmentation stuff.
18:22:52 <kmc> and then FarForeignPtr and FarByteString and... yeah, it would be pretty nasty ;P
18:23:05 <ddarius> kmc: Just like the good ole day.
18:23:07 <ddarius> +s
18:23:11 <Eduard_Munteanu> What would a far pointer be? A 64-bit integer or so?
18:23:12 <kmc> damn straight
18:23:17 <kmc> ddarius, you don't have to, and segmentation is mostly unavailable in long mode
18:23:32 <ddarius> kmc: It wouldn't be hardware segmentation in that case.
18:23:45 <hpc> what's a far pointer?
18:23:47 <kmc> ah, i see what you mean
18:24:02 <Eduard_Munteanu> Many OS kernels never really used much segmentation anyway.
18:24:03 <kmc> hpc, in this context a far pointer would be a 64-bit pointer, and a near pointer a 32-bit pointer (with the top 32 bits implicitly 0)
18:24:09 <hpc> oh, i see
18:24:42 <kmc> Eduard_Munteanu, indeed.  it's kind of a shame how much setup x86 requires in terms of segments, task structs, etc., all to get a flat model where you can ignore those things
18:24:43 <russellw> Segmentation? Segmentation? *Reaches for large axe while mumbling the word segmentation over and over again*
18:24:48 <kmc> i recently found http://www.returninfinity.com/pure64.html
18:24:51 <pikhq> Eduard_Munteanu: Yeah, the stock "use" is "data segment that spans RAM, code segment that spans RAM"
18:25:03 * russellw was around in the 80s for the 286
18:25:05 <ddarius> kmc: It's not that bad.
18:25:08 <russellw> And has bad memories
18:25:33 <pikhq> russellw: I've gotten from real mode to sane, flat protected mode.
18:25:35 <kmc> ddarius, I know
18:25:37 <pikhq> I, too, have bad memories.
18:25:43 <Eduard_Munteanu> hpc: generally, near pointers are pointers used by the majority of instructions etc., while far pointers are bigger and you have to jump through a few hoops to access data.
18:26:07 <kmc> it's just an annoying distraction when teaching people how an x86 OS works
18:26:15 <ddarius> kmc: That's true.
18:26:18 <Eduard_Munteanu> pikhq: in Linux it's code and data for userspace and kernel separately
18:26:48 <pikhq> Eduard_Munteanu: Well, yeah... For complicated reasons you really want the userspace/kernelspace split.
18:27:16 <kmc> vanilla Linux does not use segmentation to protect kernelspace from dereferncing userspace data accidentally
18:27:20 <Eduard_Munteanu> I'm not entirely sure anymore what the reasons were in detail.
18:27:40 <kmc> on x86 the privilege level (ring) is part of the segment descriptor
18:28:10 <Eduard_Munteanu> Yeah, the address spaces overlap.
18:28:43 <kmc> so the way you deny kernel memory access to userspace code is force them to use a segment index pointing to a segment descriptor with CPL=3
18:28:44 <Eduard_Munteanu> kmc: hm, but I figured some task descriptor or paging would've superseded that by now :/
18:29:08 <kmc> and then there's a pagetable bit for "only accessible by CPL=0", or something like that
18:29:08 <Eduard_Munteanu> IIRC, they don't use the TSS stuff, not entirely sure why.
18:29:35 <kmc> however, the kernel and user code segments in vanilla Linux have the same base linear address
18:29:40 <kmc> so they address the same memory
18:29:59 <kmc> the same linear address space, i mean
18:30:11 <Sgeo> Why do I always end up choosing the crappy libraries from Hackage first?
18:30:14 <kmc> and CR3 is not reloaded on system calls, so they have the same set of page tables too
18:30:29 <Sgeo> HSFFIG depends on unix
18:30:38 <kmc> PaX fixes this security liability, using either segmentation or paging
18:30:41 <Sgeo> Including for applications that just want to use the bindings
18:30:51 <kmc> the former is preferred for performance, but is unavailable on x86-64
18:31:06 <kmc> Sgeo, because most libraries on Hackage are crappy?
18:31:31 <arw> is there an easy way to debug ffi bindings?
18:31:40 <Eduard_Munteanu> kmc: presumably it's a performance hit either way, AFAICT you don't just get to do e.g. plain movs
18:31:44 <Sgeo> Is there an easy way to write ffi bindings?
18:32:00 <kmc> Eduard_Munteanu, it's a really complicated question, but I wouldn't be sure it's a performance hit in the segmentation case
18:32:09 <arw> Sgeo: it is surprisingly easy, the documentation just sucks :)
18:32:12 <kmc> however since "nobody uses segmentation" it might be that modern CPUs don't implement segmentation well
18:32:20 <Sgeo> I meant, in terms of automated tools to do work for me
18:32:27 <kmc> Sgeo, I like hsc2hs; people speak highly of bindings-dsl as a layer on top of that
18:32:29 <Sgeo> That don't randomly rely on the unix package
18:32:34 <kmc> neither will quite do it for you
18:32:43 <kmc> ezyang has some good blog posts about c2hs, which is higher level still
18:33:18 <kmc> Eduard_Munteanu, you're right that copy_from_user and friends will need a segment override, but they already have bounds checks etc, so I'm not sure it matters
18:33:28 <ddarius> Greencard used to generate bindings automatically.  As far as I can tell, no one uses Greencard anymore.
18:33:29 <Eduard_Munteanu> kmc: what exactly does this prevent or fix, playing with user pointers without going through copy_from_user etc.?
18:33:30 <companion_cube> people use only segmentation faults
18:33:38 <Eduard_Munteanu> Hm.
18:33:42 <kmc> Eduard_Munteanu, I'm giving a talk about that at MIT in a few weeks :)
18:34:08 <kmc> there are a whole class of kernel bugs which involve the kernel dereferencing a bogus pointer
18:34:14 <Eduard_Munteanu> Nice, will it go on Youtube or something?
18:34:20 <kmc> i will post pdf slides
18:34:28 <Eduard_Munteanu> Ah, that's good too.
18:34:29 <kmc> if the user can contrive for that bogus pointer to point to userspace
18:34:34 <kmc> then they can mmap() some stuff there
18:34:38 <kmc> and control what the kernel dereferences
18:35:01 <kmc> which, because kernels are full of function pointers, multiply-indirect pointers, etc., usually allows you to execute arbitrary code or write arbitrary memory
18:35:03 <companion_cube> is L4.verified free of this kind of kernel bugs ?
18:35:05 <kmc> with ring 0 privileges
18:35:31 <kmc> the simplest, most embarrassing case is a kernel NULL pointer dereference
18:35:34 <kmc> which are very very common
18:35:42 <Eduard_Munteanu> companion_cube: assuming they got the spec right
18:35:42 <kmc> dozens discovered in Linux every years
18:36:01 <kmc> if the user maps a page at 0, they can turn that kernel panic into privilege escalation
18:36:16 <kmc> recent linux systems will deny you the right to map very low memory addresses
18:36:21 <Eduard_Munteanu> Yeah, hence mmap_min_addr or whatsitsname
18:36:26 <kmc> yes
18:36:35 <kmc> many ways to bypass that were discovered
18:37:14 <kmc> one of the funniest is that you can construct an ELF which uses so much of the address space that the kernel has to put the VDSO at address 0 :D
18:37:50 <rwbarton> nice :) presumably then you don't have much control over the contents of the page, though
18:38:08 <Eduard_Munteanu> Heh, will it do that?
18:38:12 <kmc> yeah, but you can get write privs with mprotect
18:38:17 <monochrom> this is funny and sad. but let's make it funny
18:38:26 <kmc> Eduard_Munteanu, not anymore, it was fixed in maybe late 2010
18:39:08 <shachaf> kmc: You can make the VDSO writable?
18:39:14 <kmc> yeah, or you could anyway
18:39:49 <Eduard_Munteanu> Even if it isn't it's a potential risk.
18:40:01 <Eduard_Munteanu> (excluding mere denial of service)
18:45:13 <kmc> http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=462e635e5b73ba9a4c03913b77138cd57ce4b050
18:48:50 <Eduard_Munteanu> Hm, I see.
18:51:12 <arw> in IO, what is the semantics of do { stuff <- someAction; }? is someAction executed instantly or is it lazy?
18:51:37 <Axman6> depends on the action
18:51:40 <kmc> not really a well-defined question
18:51:52 <kmc> "do" notation doesn't really "do" anything; you're building up descriptions of IO which could be performed
18:51:53 <arw> damn, thought so...
18:51:54 <Axman6> reading from a fill will produce the value lazily for example
18:52:18 <shachaf> Axman6: I think you're spreading confusion by saying that. :-(
18:52:20 <kmc> not in general it won't
18:52:28 <kmc> but using the hackish file APIs in the standard library, it will
18:52:31 <kmc> by special case hack
18:52:32 <Axman6> file*
18:52:46 <kmc> arw, once "do { stuff <- someAction; otherAction stuff }" is executed, someAction and (otherAction stuff) will be executed in sequence
18:53:09 <kmc> it does not matter when 'stuff' is forced (unless those actions are defined using the hacks of which I spoke)
18:53:34 <kmc> however the "do" expression itself is just an expression, which can be evaluated to a pure value... doing so does not perform any IO at all
18:53:53 <Eduard_Munteanu> arw: do { stuff <- someAction; } by itself is invalid
18:54:14 <arw> Eduard_Munteanu: yes, should be a more complete example perhaps.
18:54:42 <Eduard_Munteanu> You can't have a binding dangling there at the end of a 'do' block.
18:54:47 <arw> http://pbot.rmdir.de/b601ce81f172c3ae59b0600909510f16 <- the concrete problem is the 'getnetgrent'.
18:54:53 <Eduard_Munteanu> It must end with an action.
18:55:48 <arw> the c_getnetgrent function must be executed in all cases or its return values (in the form of one real return value and three pointers) won't be valid.
18:56:19 <kmc> i think you're fine
18:56:34 <Eduard_Munteanu> "result `seq` ();" doesn't seem right
18:56:39 <kmc> isn't that a type error
18:56:42 <rwbarton> that `seq` line is quite unnecessary
18:56:43 <Eduard_Munteanu> Yeah.
18:56:44 <kmc> cause () is not an IO action
18:56:45 <arw> Eduard_Munteanu: oh, sorry, yes. thats a type error
18:57:00 <kmc> if you need to explicitly evaluate something as an IO action, use Control.Exception.evaluate
18:57:01 <arw> that was just some stupid idea.
18:57:03 <kmc> but i do not think you need to here
18:57:25 <kmc> maybe you shouldn't be peeking in the case where result is 0?
18:57:53 <ddarius> arw: Your peekMaybeCString doesn't do what you expect.
18:57:54 <rwbarton> also your case at the end is wrong
18:57:59 <kmc> also why do you have (\c_netgroup -> c_setnetgrent c_netgroup)?  that's just  c_setnetgrent
18:58:01 <rwbarton> as is that one, yeah
18:58:04 <ddarius> You are probably getting warnings about it, if not, use -Wall.
18:58:08 <arw> well, that is part 2 of the question. it should work if the maybe* thingies were evaluated lazy?
18:58:14 <kmc> if â¤, use -Wall
18:58:16 <rwbarton> er, I meant "case result of { ... }"
18:58:22 <kmc> arw, i think you mean "executed lazily"
18:58:29 <kmc> and they aren't
18:58:36 <kmc> because doing so produces terrible confusion in the semantics of IO
18:58:47 <kmc> hidden errors everywhere
19:00:14 * ddarius has no idea why arw thinks that that would make things work anyway.  It seems like that would break things horribly.
19:00:50 <rwbarton> it would, but I can also see why one might think it would help
19:02:23 <ddarius> rwbarton: Well it would avoid bad pointers if the function doesn't return valid values, but that is a pretty horrible way to go about it.
19:02:50 <arw> ddarius: it warns about overlapping patterns, but not about errorneous assumptions about laziness.
19:03:26 <ddarius> arw: The overlapping patterns is what I (and rwbarton) are talking about.
19:03:39 <ddarius> peekMaybeCString will -always- take the first case.
19:03:48 <ddarius> Same for the case result of ...
19:03:50 <arw> oops...
19:03:57 <arw> well, that explains a lot.
19:05:49 <arw> okay, i'm stomped. can you explain why those patterns always match?
19:06:13 <kmc> a variable always matches
19:06:22 <kmc> if c_one was already in scope, it will shadow the existing binding
19:06:38 <kmc> you have case e of { x -> ... } when what you want is: case e of { y | y == x -> ... }
19:06:56 <kmc> (also it should work fine to use the literal 1)
19:06:57 <rwbarton> otherwise we would have the disasterous situation where a new binding in a library could change the meaning of a pattern from a variable to an equality test
19:07:22 <kmc> > let one = 1 in  case 2 of { one -> one }
19:07:23 <lambdabot>   2
19:07:23 <rwbarton> a new exported value, I mean
19:07:42 <kmc> that should warn about shadowing
19:07:47 <arw> kmc: interesting, i've never thought about those two as different...
19:08:57 <The_Journey> is there a way to zip an arbitrary number of lists?
19:09:46 <ddarius> transpose
19:09:47 <geheimdienst> arw: it's similar to when you declare functions. you probably have come across the syntax "f 42 = ...", and you surely have come across "f x = ...". "f x" catches always (whatever the argument x may be)
19:09:53 <Eduard_Munteanu> Only as unlifted pairs.
19:10:17 <geheimdienst> arw: here's an example (section 1)
19:10:19 <geheimdienst> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Naive_definition
19:10:22 <Eduard_Munteanu> Or yeah, transpose if you're ok with lists.
19:10:37 <Eduard_Munteanu> (of lists)
19:10:46 <ddarius> Eduard_Munteanu: You have to be okay with lists, how else are you going to have an arbitrary number of lists?
19:11:07 <kmc> arw, in general, pattern-matching does not invoke (==)
19:11:27 <Eduard_Munteanu> ddarius: (((a, b), c), ...
19:11:27 <kmc> pattern-matching is supposed to be structural, whereas (==) is an arbitrary user-defined function
19:11:37 <kmc> however it does invoke (==) for numeric literals and character literals, which is confusing
19:11:45 <arw> yes, exactly
19:11:46 <ddarius> Eduard_Munteanu: Yes, and you will only have a fixed number of lists at any call.
19:12:16 <Eduard_Munteanu> Hrm, right... I was thinking some printf-like magic could do that but hrm.
19:12:25 <Sgeo> aw.hsc:1:26: fatal error: bindings.dsl.h: No such file or directory
19:12:35 <ddarius> printf-like magic could let you have a variadic zip.
19:12:39 <kmc> Sgeo, did you install bindings-dsl?
19:12:42 <Sgeo> Yes
19:12:48 <Eduard_Munteanu> Yeah, it doesn't help you with the result type.
19:12:54 <arw> ok, thanks alot, not its working.
19:13:08 <ddarius> Eduard_Munteanu: You may find the paper "The Zip Calculus" interesting.
19:13:11 <arw> s/not/now/
19:13:28 <Eduard_Munteanu> Hm, I'll have a look, thanks.
19:19:24 <Sgeo> kmc,
19:19:40 <Sgeo> I'm cheating and copying the bindings.dsl.h to the directory containing my .hsc
19:19:41 <Sgeo> :/
19:19:44 * hackagebot conduit 0.0.0.2 - A pull-based approach to streaming data.  http://hackage.haskell.org/package/conduit-0.0.0.2 (MichaelSnoyman)
19:20:55 <ddarius> bindings-dsl is nothing but a header file anyway.  It just needs to be somewhere in your include path.
19:21:13 <dabblego> can I generate all pairs of a list with duplicate, without using a zipper, except by essentially emulating a zipper as I traverse?
19:22:13 <Sgeo> How easy/difficult is it for me to do malloc stuff in my hsc?
19:23:24 <ddarius> Sgeo: You just do it.
19:23:49 <ddarius> dabblego: Your question made no sense to me.
19:23:59 <dabblego> yeah I worded it shittily
19:24:35 <Sgeo> ddarius, so, I have a function that in C expects me to malloc and fill a pointer and give it to the function, and I want to make a function that handles that for the user. Should I still prefix my function c', is it at the wrong level, or what?
19:24:46 * hackagebot fresh 0.1.1 - Introduce fresh variables into Haskell source code  http://hackage.haskell.org/package/fresh-0.1.1 (DavidLazar)
19:24:47 <Sgeo> (I know how physically to do it, just unsure of the conventions)
19:24:58 <kmc> Sgeo, my advice is to have only foreign imports in the .hsc file
19:25:05 <xplat> dabblego: we've done something like that several times, but i'm not sure if it's *exactly* like that from your wording
19:25:08 <kmc> leave allocation and marshalling to another layer
19:25:16 <kmc> but, I don't think it matters too much
19:25:17 <Sgeo> kmc, ok, thanks
19:25:45 <Sgeo> Some of the structs I have to deal with are not storables :(
19:25:49 <Sgeo> I think
19:25:55 <rwbarton> I was hoping this "fresh" package would replace all my boring variable names like "xs".
19:25:57 <dabblego> the goal is e.g. f [a, b, c] -> [(a, b), (a, c), (b, c)]
19:26:52 <dabblego> oh wait, I screwed it up never mind
19:27:17 <ddarius> @let select [] = []; select (x:xs) = (x,xs):second (map (x:)) (select xs)
19:27:18 <lambdabot>  <local>:7:39:
19:27:18 <lambdabot>      Couldn't match expected type `[a]'
19:27:18 <lambdabot>             against in...
19:27:24 <dabblego> right
19:27:41 <ddarius> @let select [] = []; select (x:xs) = (x,xs):map (second (x:)) (select xs)
19:27:42 <lambdabot>  Defined.
19:27:50 <ddarius> > select "abcd"
19:27:52 <lambdabot>   [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
19:28:43 <ddarius> Actually, I think this doesn't even need select.
19:28:46 <Sgeo> kmc, I'm a bit freaked out by all the copy/pasting and search/replacing I'm doing
19:28:52 <Sgeo> Like this isn't the best way
19:30:23 <ddarius> We need a paramorphism function in the Prelude.
19:30:30 <xplat> > zip`ap`(tail.tails) >=> uncurry (map.(,)) $ [1,2,3]
19:30:32 <lambdabot>   [(1,2),(1,3),(2,3)]
19:31:28 <ddarius> Select would be if you wanted all pairs in either direction (though not the reflexive ones.)
19:31:45 <kmc> Sgeo, you don't need to make Haskell datatypes and Storable instances for every struct
19:31:50 <kmc> in fact I discourage it
19:32:00 <kmc> often it's enough to define getters and setters using hsc2hs #peek and #poke
19:32:10 <kmc> anyway, yes, Haskell is a boilerplatey language and FFI doubly so
19:32:18 <kmc> fancier bindings generators may help
19:32:21 <ddarius> > [(x,y) | (x,ys) <- [1,2,3], y <- ys]
19:32:22 <lambdabot>   No instance for (GHC.Num.Num [t])
19:32:22 <lambdabot>    arising from a use of `e_1123' at <int...
19:32:23 <kmc> at some other cost
19:32:26 <ddarius> > [(x,y) | (x,ys) <- select [1,2,3], y <- ys]
19:32:27 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
19:32:49 <Sgeo> Haskell without FFI is considered boilerplatey?
19:32:50 <Sgeo> :/
19:32:55 <kmc> by me, yes
19:33:02 <kmc> i mean it's nowhere near as bad as Java
19:33:09 <kmc> but it's much worse than a dynamic language used competently
19:33:41 <Rodayo> This is probably a stupid question, but when you call, for example, 'insert' on a map does it actually allocate a brand new tree with a new item? Or does it just return the same tree but with a new item inserted?
19:34:00 <ddarius> kmc: We could do similarish things as dynamic languages do without too much boilerplate via TH and/or generics.
19:34:07 <kmc> Rodayo, it will create new nodes form the path from the root to the inserted element
19:34:13 <kmc> but the rest of the tree is shared
19:34:18 <kmc> those nodes point back into the original tree
19:34:26 <kmc> this is probably the #1 underappreciated idea in functional programming
19:34:33 <kmc> something which should be widely known by all programmers everywhere
19:34:39 <kmc> i'm thinking of writing a blog post about it, actually
19:34:53 <ddarius> It is talked about outside of FP contexts.
19:35:14 <ddarius> It's just usually a subsection of a section of data structure course that people aren't paying attention to anyway.
19:35:17 <Eduard_Munteanu> What, TH-ish stuff?
19:35:33 <kmc> Sgeo, Haskell is not king of safety, expressiveness, or performance, but provides a remarkably good tradeoff between the three
19:35:36 <Rodayo> kmc, still sorta going over my head. The exact wording from "learnyouahaskell" is "insert takes a key, a value and a map and returns a new map that's just like the old one, only with the key and value inserted" to me this translates to "allocates a new tree"
19:35:42 <kfish> kmc: generics are cool, or sharing happens? which is the #1 underappreciated?
19:35:43 <Sgeo> What
19:35:46 <kmc> sharing
19:35:49 <Sgeo> What's king of safety?
19:35:58 <kmc> something with more formal methods
19:36:06 <kmc> Rodayo, it's a new tree that shares most nodes with the old one
19:36:11 <Eduard_Munteanu> Rodayo: I take "a new map" to mean it doesn't use mutation
19:36:18 <xplat> Rodayo: it's just a little more like the old one than you thought
19:36:21 <rwbarton> conceptually it is a new map
19:36:23 <Cody_> hello
19:36:34 <Eduard_Munteanu> Cody_: hi
19:36:40 <rwbarton> but the implementation is not duplicating the entire old map
19:36:42 <Rodayo> In memory what does it look like?
19:36:46 <ddarius> It's not just conceptually a new map.  The root node will be reallocated.  The pointer insert returns will be different from the pointer passed in.
19:37:15 <ddarius> Rodayo: You have a path of new stuff with pointers back into the original tree for the not new stuff.
19:37:50 <ddarius> I.e. log n nodes will be allocated (for a balance tree).
19:38:15 <Rodayo> Is there a diagram somewhere I can look at?
19:38:17 <kmc> http://i.imgur.com/HI24J.png
19:38:19 <ddarius> Probably.
19:38:22 <ddarius> Also see vacuum.
19:38:39 * Jafet undusts the box-and-pointer diagrams
19:38:40 <kmc> the blue nodes are a binary search tree with keys 5, 2, 7, 9
19:38:46 <kmc> the red root is the result of inserting 3 into that tree
19:38:50 <ddarius> kmc: The change in chirality is confusing.
19:38:53 <kmc> yep
19:38:55 <kmc> blame graphviz
19:39:16 <Cody_> Can someone help me with some code? The book I am using does a poor job explaning. I am just starting out
19:39:17 <kmc> this is from the blog-post-in-progress
19:39:35 <Jafet> ddarius: how would you lay it out?
19:39:44 <Rodayo> kmc, I see! That makes sense now
19:39:48 <kmc> i implement an immutable tree in Python, and some code to render graphviz diagrams of the structures
19:39:48 <ddarius> Rodayo: You can use the vacuum package to generate images like this: http://code.haskell.org/~dons/images/vacuum/intmap.png of actual in memory structures.
19:40:14 <kmc> then i'm planning to put a mutable interface on it (because that's what many people want), talk about why it's good for concurrency, and improve it to a n-way hash trie
19:40:19 <kmc> and maybe get some real benchmarks
19:40:26 <Rodayo> ddarius: that's neat. I'll keep that in mind if I ever need it =]
19:40:27 <Cody_> -- Creating our own sum function sum ' :: (Num a) => [a] -> a sum ' [] = 0 sum ' (x:xs) = x + sum ' xs
19:40:33 <ddarius> Jafet: With the root red node to the left of the root blue node and have the right pointer cross the other arrows.
19:40:34 <kmc> ddarius et al, any references i should include in this post?
19:40:45 <byorgey> Cody_: I just sent you a reply on the beginners mailing list, did you see it yet?
19:40:46 <Jafet> .oO(Python, where lists are arrays)
19:41:03 <tehgeekmeister> i've been playing around with iteratees for fun, and did a comparison between a script i'd already written in perl and the equivalent implementation in haskell, and after hacking away for a few days, was surprised it was still five times slower
19:41:18 <tehgeekmeister> i'd love if someone could take a look and tell me if there's something obviously wrong i've done: https://gist.github.com/1553455
19:41:33 <Rodayo> So what's the point of inserting a new node in this way?
19:41:34 <Cody_> Hasn't come around yet. Surprised to see that you recognized me.
19:41:59 <kmc> Rodayo, you get a pure functional interface, which is good for concurrent access or nondeterministic search for example
19:42:08 <kmc> but you don't pay the cost of copying the whole tree
19:42:08 <ddarius> kmc: I don't know if you should include them, but Tarjan did a lot work on persistent structures, albeit usually in an internally mutable manner.
19:42:23 <kmc> Rodayo, by the way this is the result you get from the most naive binary search tree implementation in Haskell
19:42:30 <kmc> neither you nor the compiler does any tricks to get sharing
19:42:37 <ddarius> I'd expect a typical data structures book to have some coverage of sharing in tree-like structures.
19:42:38 <Sgeo> What I have to deal with: "note: increase the strucure's total size
19:42:38 <Sgeo>   // by the length of the strings
19:42:38 <Sgeo>   // when allocating memory for this structure!"
19:42:51 <kmc> insert v (Node x l r)  | v < x   =  Node x (insert v l) r
19:43:06 <kmc> note that 'r' is part of the right hand structure, unchanged
19:43:16 <ddarius> Rodayo: What are the alternatives?
19:43:19 <kmc> so even a simplistic haskell compiler will reuse the pointer from the left-hand value
19:43:22 <byorgey> Cody_: it wasn't too hard, your name is 'Cody' in both places and you're asking about the same piece of code =)
19:43:33 <Eduard_Munteanu> Sgeo: is it using C flexible arrays?
19:43:40 <Sgeo> No.
19:43:43 <ddarius> Cody_: Also byorgey is really smart.
19:43:51 <byorgey> yes, that helps
19:43:52 <Cody_> Byorgey_: Thanks a lot
19:43:56 <Cody_> lol
19:44:10 <Sgeo> char                  str_data[1]; and str_data is the reference to the first byte, or something
19:44:27 <Rodayo> ddarius, i would expect it to insert a single node in the proper location in the tree...
19:44:27 <kmc> Rodayo, concurrent programming is far easier with these kind of structures... you can get a "snapshot" with a single pointer copy, and that snapshot stays valid forever
19:44:38 <kmc> then you can do a lockfree update with an atomic compare-and-swap
19:44:53 <kmc> Rodayo, then existing pointers to the old tree would suddenly see a new value
19:45:05 <ddarius> Rodayo: And how would you get to the node later without changing the nodes above it?
19:45:31 <Rodayo> ddarius, traverse the tree...
19:45:49 <ddarius> Rodayo: Yes, and that has the old pointers to the old nodes.
19:46:18 <Rodayo> kmc, trying to make sense of it but I'll probably have to google a few things that you referened =P Thanks the explanationtthough
19:46:36 <kmc> ddarius, I don't think my data structures course covered sharing, but I wasn't paying that much attention to any of it
19:46:40 <kmc> is it in CLRS?
19:46:45 <Rodayo> ddarius, maybe I misunderstood your question
19:47:01 <ddarius> kmc: I'd like to check but I don't have a copy.
19:48:01 <Rodayo> ddarius, I'm picturing a map like 'let a = insert 2 100 empty'. Then calling insert on 'a' again I would assume that that just inserts a new node into its tree
19:48:11 <kmc> 'inserts a new node' by changing existing pointers?
19:48:13 <Rodayo> or does that contradict some rule of functinoal programming?
19:48:37 <kmc> say you do Â«let b = insert 2 100 aÂ»;  someone might still have a reference to 'a'
19:48:54 <kmc> if you in-place modify anything reachable from 'a', then that value changes out from under them
19:49:40 <Rodayo> i see...
19:49:56 <kmc> in FP we are serious when we say a value is a value
19:50:06 <kmc> not an 'object' which can change mysteriously as someone else works on it
19:50:12 <kmc> separate concepts for value, identity, and state
19:50:38 <Rodayo> kmc, lol yeah for a second I pictured a call like: "insert 1 2 a" but remembered that doesn't make any sense =P
19:50:47 <kmc> oh it makes perfect sense
19:50:53 <kmc> i mean, you can implement a mutable tree in most languages
19:50:55 <kmc> including Haskell
19:51:01 <kmc> in Haskell you might use IORef or STRef
19:51:17 <Rodayo> hwo about "a = insert 1 2 a"
19:51:20 <kmc> but the point is, our default data structures don't work that way
19:51:23 <Rodayo> that's incorrect isn't it?
19:51:28 <kmc> Rodayo, in Haskell that would be a recursive equation
19:51:31 <kmc> > let x = 1 : x in x
19:51:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:51:37 <kmc> the revolutionary thing about Haskell isn't that the language forces purity, but that the standard libraries allow it
19:51:47 <shachaf> I think lists are a simpler thing to demonstrate sharing with than trees.
19:51:50 <kmc> you can implement whatever imperative datastructures you like, but you have an alternative
19:52:07 <kmc> adding an element to the beginning of a list is more efficient than adding to the end
19:52:14 <kmc> because each element of the list points to the next element
19:52:38 <ddarius> shachaf: For this purpose, yes, probably.
19:52:39 <kmc> if you have a list xs then (1:xs) can be just a single new node with a pointer to the existing xs
19:52:40 <Rodayo> kmc,that makes sense
19:52:53 <kmc> but (xs++[1]) has to copy the whole spine of the list
19:53:24 <Rodayo> copy? Not "traverse"?
19:53:27 <kmc> copy
19:53:37 <Axman6> Rodayo: you're creating a new list
19:53:41 <kmc> the last element of (xs++[1]) is different from the last element of xs
19:53:45 <kmc> and the last element is reachable from any other
19:54:03 <kmc> therefore the list must be allocated with all-new list nodes
19:54:07 <Axman6> it will reference the elemnts of the previous list, but it we can't modify the spine of the list
19:54:37 <Rodayo> kmc, okay i get that...
19:54:48 <Rodayo> I feel like the tutorial I'm following should've covered this in more detail earlier
19:54:51 <kmc> yep
19:54:59 <kmc> it's the #1 underappreciated blah blah
19:55:00 <shachaf> Well, this is all implementation details, really.
19:55:06 <ddarius> let a = ['a']; b = 'b':a; c = 'c':b in b := b ++ ['x'] means that a will become ['a','x'] and c will become ['c','b','a','x']
19:55:08 <shachaf> Although important ones.
19:55:12 <Cody_> Byorgey_: Read the response online, thanks a lot. It cleared up some of the foggy details I was confused about. Haskell requires a different way of thinking than Java, one that is not on the AP exam in may :)
19:56:08 <ddarius> (Actually, as written it wouldn't affect a, but whatever, Haskell doesn't have convenient notation for this.)
19:56:48 <ddarius> kmc: Cactus stacks might be a useful reference.
19:58:18 <kmc> nice
19:58:41 <kmc> though i'm not sure those are well-known
19:59:01 <kmc> by the way http://en.wikipedia.org/wiki/Persistent_data_structure has some diagrams too
19:59:04 <ddarius> Yeah, the problem I see is that the people who know about them already know whatever you have to say.
19:59:23 <kmc> yeah wikipedia says "The term spaghetti stack is closely associated with implementations of programming languages that support continuations"
19:59:30 <kmc> and that's going to scare off most of the target audience ;P
19:59:53 <shachaf> Is a "cactus stack" what people around here call a "list"?
20:00:12 <kmc> shachaf, or a particular use case thereof
20:00:40 <ddarius> kmc: I wouldn't say it will scare off the audience so much as any value you'd get from referencing them would only be useful to people who don't need to take advice from you on this.
20:00:53 <kmc> no, i think it will scare people off
20:01:01 <ddarius> kmc: It depends on how you bring it up.
20:01:10 <kmc> some people will tune out as soon as functional programming is mentioned at all
20:01:41 <ddarius> kmc: Then you are sunk anyway.
20:01:50 <kmc> true, but it's a matter of degrees
20:01:54 <ddarius> Also ruby has continuations.
20:02:30 <ddarius> In fact, the environment in languages like Python and Ruby (and, well, most languages) is a similar semi-persistent tree structure.
20:02:33 <kmc> one can explain sharing without reference to 'functional programming'
20:03:08 <rwbarton> and you can provide an API which does not permit mutation
20:03:54 <kmc> well to the degree Python code can disallow anything
20:03:59 <kmc> (Python being my implementation language for the post)
20:04:04 <kmc> and on top of it an imperative API with a single reference cell
20:04:04 <rwbarton> Well, yeah.
20:04:10 <kmc> and a suspiciously efficient 'copy' operation
20:05:16 <tehgeekmeister> aside from basic profiling, how can i figure out what's actually going on at run time making some haskell slow?
20:05:37 <kmc> did you read the RWH chapter on performance?
20:05:40 <Axman6> more advanced profiling!
20:05:55 <ddarius> tehgeekmeister: Threadscope, criterion, more profiling as Axman6 said, instrumenting your code, thinking at your code.
20:05:57 <Axman6> threadscope may or may not be useful, depending on wehat you're doing
20:06:09 <kmc> if you wanna know when things are getting evaluated, Debug.Trace
20:06:17 <ddarius> Also looking at core.
20:06:20 <tehgeekmeister> yeah, i read it and applied each technique in there that was relevant
20:06:25 <Axman6> thinking at? i'm not quite sure how to do that :o
20:06:27 <tehgeekmeister> the core is far too complicated for me to follow it
20:06:28 * ddarius usually just thinks at the code until it is faster.
20:06:45 <tehgeekmeister> too many things in there i don't understand at all
20:06:52 <Axman6> tehgeekmeister: core is just very verbose. using the ghc-core package can make life easier
20:07:21 <tehgeekmeister> Axman6: used it
20:07:34 <tehgeekmeister> ddarius: instrumenting code?
20:07:45 <Axman6> adding cost centres explictly
20:07:59 <ddarius> tehgeekmeister: Stuff like Debug.Trace or adding other things to track time and/or memory.
20:08:15 <tehgeekmeister> memory usage is fine, it's time that i'm interested in
20:08:17 <Axman6> {-# SCC "Hmm-this-is-probably-expensive #-} <code> (roughly
20:08:35 <tehgeekmeister> the haskell version is 5 times slower than the perl, and i want to understand why
20:08:41 <ddarius> tehgeekmeister: How much time are you spending GCing?
20:08:53 <tehgeekmeister> ddarius:  let me run a sample again and check
20:08:53 <Axman6> tehgeekmeister: if you share the code, we can help
20:09:20 <tehgeekmeister> i did earlier -- here's the link again https://gist.github.com/1553455
20:11:34 <tehgeekmeister> ddarius: 1.2% in gc
20:12:06 <Axman6> do you specifically need to use Text? would ByteStrings be ok?
20:12:32 <tehgeekmeister> i think bytestring would do fine -- i used text because it has a function to do the infix bit
20:12:37 <tehgeekmeister> bytestring might have that too
20:12:38 <Axman6> because processing the bytes coming in as unicode text is porobably not going to be that fast
20:12:57 <Axman6> ah, there's no infix for bytestring? how lame -_-
20:13:13 <Axman6> @hoogle ByteString -> ByteString -> Bool
20:13:13 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
20:13:14 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
20:13:14 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
20:13:21 <Axman6> there we go
20:13:21 <tehgeekmeister> nope, there is
20:13:39 * ddarius suspects isInfixOf is not the most efficient implementation.
20:15:40 <tehgeekmeister> what would you suggest?  i used it because it seemed to be the closest analogue to the perl i wrote, and i wanted to do as fair a comparison as possible
20:15:56 <Axman6> tehgeekmeister: just to see what happens, what if you change import qualified Data.Enumerator.Text as ET to import qualified Data.Enumerator.ByteString as ET?
20:16:09 <tehgeekmeister> (i used a regex in perl)
20:16:17 <tehgeekmeister> Axman6: trying it
20:16:54 <ddarius> tehgeekmeister: The regex is probably compiled into something smarter than what isInfixOf is doing.
20:17:04 <tehgeekmeister> ddarius: probably
20:17:09 <kmc> maybe http://hackage.haskell.org/package/stringsearch
20:17:53 <ddarius> At any rate, I suspect this is an area where Perl will do well regardless since I suspect little of the work will have to deal with the Perl interpreter.
20:18:00 <ddarius> And Perl can do IO and regexes.
20:18:21 <ddarius> There also may be differences in buffering.
20:18:29 <tehgeekmeister> i tried playing with the buffer sizes
20:18:56 <tehgeekmeister> i'd be happy to get it within two times as slow as perl, that'd be acceptable to me.  five times seems like it's more than is necessary.
20:19:44 * hackagebot http-conduit 1.0.0.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.0.0.1 (MichaelSnoyman)
20:20:03 <parcs`> how costly is that append "\n\n"?
20:20:19 <tehgeekmeister> parcs`: good question.
20:20:28 <tehgeekmeister> i should probably break this up into a few different cost centers.
20:20:41 <ddarius> It will be an O(length) operation.
20:20:50 <ddarius> That said, the Perl equivalent may well be the same.
20:21:17 <kmc> if you're feeling adventurous you could try to use https://github.com/kmcallister/haskell-re2
20:21:24 <kmc> for fast regular expressions
20:21:40 <Axman6> i think you'd tdo better to print out the "\n\n" separately, rather than appending it
20:21:50 <shachaf> kmcallister is making RE2 bindings?
20:21:52 <ddarius> Axman6: Probably.
20:22:00 <kmc> has made, but not hackage-quality
20:22:13 <kmc> need to test
20:22:14 <parcs`> yeah, try using EL.mapM_ instead of EL.map and iterHandle
20:22:30 <ddarius> Which should really scare you because of kmc's opinion of the quality of hackage packages.
20:22:35 <tehgeekmeister> what buffer size should i use for the bytestring test?  i have to provide one explicitly to enumFile
20:23:03 <kmc> ddarius, i don't exclude my own packages ;)
20:26:33 <parcs`> tehgeekmeister: try 4K
20:28:13 <parcs`> enumFile doesn't take a buffer size btw
20:30:52 <parcs`> also are you parsing a csv file? there's a library for that :P
20:32:28 <tehgeekmeister> parcs`: no, json
20:33:03 <tehgeekmeister> i suppose i could use a library for that, but i wanted to keep the code similar
20:35:30 <parcs`> ah
20:35:48 <hughfdjackson> http://www.youtube.com/watch?feature=player_detailpage&v=045422s6xik#t=128s
20:36:01 <parcs`> well i suggest using mapM_ or mapM to print the "\n\n" for you
20:36:07 <hughfdjackson> why does data PixelData = PixelData work as a catchall?
20:36:13 <hughfdjackson> :P that seems madness!
20:36:51 <kmc> "catchall"?
20:37:03 <kmc> it defines a new datatype with a single value (not counting 'undefined')
20:37:30 <hughfdjackson> ^^ i see
20:37:40 <kmc> i don't know what you mean by 'catchall'
20:37:51 <hughfdjackson> i really didn't mean that
20:37:53 <hughfdjackson> hehe
20:37:59 <hughfdjackson> i meant why does it allow it to compile
20:38:01 <rwbarton> catchone
20:38:41 <aristid> hughfdjackson: so you want to know why data PixelData = PixelData is valid?
20:38:52 <kmc> hughfdjackson, a) it's useful, b) why shouldn't it be allowed, why should there be a special case forbidding this particular use
20:39:08 <parcs`> tehgeekmeister: something like (EL.mapM (<$ liftIO (putStr "\n\n"))) instead of (EL.map $ T.append "\n\n")
20:39:15 <kmc> it is an instance of the general idea of "constructors with fields"
20:39:19 <kmc> one constructor with zero fields
20:39:44 <blackdog> hughfdjackson: for instance, you use unit or "()" all over the place
20:39:54 <tehgeekmeister> parcs`: i'll try that, trying to test just converting to bytestring first
20:40:58 <parcs`> (you probably won't need the liftIO there)
20:42:00 <hughfdjackson> gotcha
20:42:14 <hughfdjackson> :P that was a dreadfully noobish Q, thanks for the patience
20:42:59 <kmc> hughfdjackson, Haskell should also allow the case of "zero constructors"
20:43:07 <kmc> and the empty case expression
20:43:10 <kmc> but it doesn't :(
20:43:39 <aristid> kmc: with an extension it does!
20:43:44 <kmc> sure
20:43:56 <kmc> > "Haskell with an extension" == "Haskell"
20:43:57 <lambdabot>   False
20:44:28 <kmc> also i don't think any GHC extension enables Â«case x of {}Â»
20:44:40 <aristid> kmc: i would not say that Haskell should be restricted in its definition to Haskell 98 or Haskell Prime
20:44:57 <kmc> i don't think Haskell Prime means what you think it does
20:45:07 <kmc> anyway "Haskell" and "GHC Haskell" are both fine designators
20:45:10 <kmc> for different things
20:45:24 <kmc> there's no reason to confuse the meaning of the former when you can just use the latter
20:45:41 <aristid> kmc: i thought haskell prime was a project for new revisions to the "official" haskell?
20:45:44 <kmc> yeah
20:45:51 <kmc> but not a particular version
20:46:03 <kmc> there is significant value in distinguishing standard Haskell from "what GHC implements"
20:46:08 <kmc> even if everyone is using GHC
20:46:24 <kmc> for example, standard Haskell has a fairly precise specification
20:46:37 <kmc> GHC extensions have a couple paragraphs in the manual and a link to a paper
20:46:38 <aristid> kmc: well, there may be more value in actually talking about the specific things that are added or removed
20:46:51 <kmc> often the paper differs from what GHC implements in more or less undocumented ways
20:47:11 <kmc> new GHC extensions appear and disappear, and change meaning significantly
20:47:59 <aristid> kmc: given that GHC usually tells you which extensions you need to enable, i think the fraction of haskell programs that require extensions is significant now
20:48:16 <kmc> that's irrelevant to my point
20:48:20 <ddarius> @src ()
20:48:20 <lambdabot> data () = ()
20:48:26 <aristid> kmc: i don't think that EmptyDataDecls (if i wrote the name correctly) will change anytime soon
20:48:42 <kmc> agreed
20:48:57 <kmc> that doesn't make it part of Haskell
20:49:16 <ddarius> It should've been.
20:49:25 <kmc> indeed
20:49:26 <ddarius> Along with empty cases.
20:49:57 <aristid> kmc: your demand for notational preciseness is incompatible with human nature :P
20:50:22 <kmc> you think people discussing programming languages shouldn't use precise terminology?
20:50:25 <ddarius> I find his demand perfectly compatible.
20:50:29 <kmc> won't that cause some trouble?
20:50:52 <MostAwesomeDude> I don't think compatibility ever caused trouble,  no.
20:50:58 <kmc> haha
20:51:23 <aristid> kmc: didn't say it doesn't cause trouble
20:51:39 <kmc> in my experience most of us have no trouble distinguishing Haskell from GHC Haskell
20:51:50 * BMeph thinks that avoiding causing trouble is highly overrated.
20:51:53 <kmc> even if some people think the latter is the only one worth talking about
20:51:59 <kmc> if you're having trouble distinguishing them, I suggest further study
20:52:22 * ddarius smashes BMeph over the head with a folding chair.
20:52:23 <aristid> kmc: people will prefer calling both haskell, even if the reason is just that the word is shorter
20:52:39 <kmc> and people prefer calling their computer a hard drive too
20:53:51 <aristid> kmc: it seems like a more feasible solution is to allow for clarification when there is ambiguity that isn't resolved by context, rather than demand full precision all the time.
20:54:01 <kmc> ok
20:54:54 <ddarius> aristid: I'm unclear about what you mean by clarification, please precisely specify.
20:55:15 <aristid> ddarius: i'm too stupid for that, sorry.
20:56:16 <aristid> also too lazy
20:56:57 <kmc> aristid, I disagree with you on the factual claim that the distinction is 'infeasible'; that people here have difficulty maintaining the distinction
20:57:06 <kmc> but I don't care enough to marshal data to support my position
20:57:15 <kmc> so perhaps that's the end of it?
20:58:36 <ddarius> He said with hope in his eye, but darkness fluttered at the edges of his vision.
20:58:47 <maurer> It's important to maintain a distinction, because while ghc may not look like it will be superceded in the near future (think gcc), eventually, something better will come along (e.g. clang) and GHC Haskell vs Haskell will have very different end effects
20:59:03 <kmc> i think that's a good reason but not even the best reason
20:59:13 <aristid> kmc: it's not inability to distinguish, but rather unwillingness to distinguish and/or actually say it
20:59:17 <kmc> i think the best reason is that it's documented what Haskell code does
20:59:22 <kmc> and less documented what GHC Haskell code does
20:59:31 <maurer> Although, honestly, I think that once an extension is released in a stable version of ghc, a more careful specification of the extension should be released
20:59:36 <maurer> So it can be Haskell + extension
20:59:46 <maurer> Rather than Haskell + GHC's interpretation of this general idea
20:59:51 <kmc> yes
20:59:59 <kmc> aristid, I don't see that people are unwilling, either
21:00:13 <kmc> i think you are unwilling and are projecting onto others
21:00:18 <kmc> or else you're just arguing for the hell of it
21:00:23 <ddarius> I think once an extension has been in constant use for the better part of the last twenty years a more careful specification of the extension should be released.  We'll see how that goes.
21:00:48 <tehgeekmeister> how do i convert a char to a word8?
21:00:58 <kmc> which word8 do you want?
21:01:00 <ddarius> Bloody Christ!
21:01:09 <kmc> i'm guessing Â«const 0Â» is not the answer you're looking for
21:01:24 <ddarius> const 42
21:01:41 <Axman6> const 32 would be harder to debug when printing
21:01:44 <tehgeekmeister> kmc: no, it's not.  the bytestring splitWhen in the enumerator package expects a word8 instead of a char
21:01:54 <kmc> that's because bytestrings store bytes, not characters
21:02:04 <Axman6> tehgeekmeister: fromIntegral . ord
21:02:05 <kmc> there are many different, incompatible ways to represent a character as a sequence of bytes
21:02:21 <tehgeekmeister> kmc: i know, ascii will do for this
21:02:31 <Axman6> tehgeekmeister: someone people love to be pedantically correct, even when they know the answer you ned, and it's a shame
21:02:32 <kmc> use Â«fromIntegral . ordÂ», I'm sure your users will be willing to learn English just to use your software
21:02:32 <ddarius> Ah, the memory of #haskell as fickle and short-lived.
21:02:38 <Axman6> need*
21:02:48 <kmc> Axman6, you think software that works for the majority of the world is a pedantic detail?
21:02:55 <aristid> kmc: well, maybe we are observing different worlds, through our imperfect eyes and minds.
21:02:59 <tehgeekmeister> kmc: it's a one off script for fun.  i am my only user.
21:03:03 <ddarius> kmc: He was using Text before, people suggested that he use ByteString to see if that made a difference in performance.
21:03:13 <ddarius> tehgeekmeister: Have you learned English?
21:03:29 <tehgeekmeister> ddarius: yes, apparently.
21:03:32 <Axman6> tehgeekmeister: but all one off scripts should be perfect and support everyone. don't be so descrimitory
21:03:42 <ddarius> tehgeekmeister: Good.  Then you're set.
21:03:52 <aristid> kmc: people do say haskell 98 when they actually want to refer to standard haskell.
21:03:56 <Axman6> your shopping list should also be written in all known languages, otherwise you're a racist
21:03:58 <kmc> aristid, or Haskell 2010
21:04:01 <kmc> my answer would be different if i'd known it was a "one-off script"
21:04:09 <kmc> and many of my "one off scripts" process non-ascii text
21:04:14 <kmc> for example the contents of this here IRC log
21:04:28 <parcs`> tehgeekmeister: use the .Char8 module
21:04:40 <kmc> Axman6, you're treating like "ASCII only" is the default and "works for Unicode" is a weird requirement that only some software supports
21:04:47 <kmc> and I think it should be the other way
21:05:02 <kmc> if your program is to be ASCII only then you should say so; I'm not going to assume it
21:05:11 <kmc> but anyway it's clear you're pissed off at me personally
21:05:17 <ddarius> kmc: Considering you were involved in the conversation where it was suggested that he use ByteString, I can't say that I'm sympathizing with your position here.  That said, I rarely sympathize with anybody about anything.
21:05:27 <Axman6> no, more that general kind of response in this channel
21:05:32 <kmc> i was?
21:05:40 <tehgeekmeister> parcs`: that snippet you handed me throws away all of the incoming chunks and just prints newlines.  =P
21:05:44 <ddarius> kmc: For example, when you suggested your re2 binding.
21:05:54 <aristid> kmc: language also shifts. right now, i think the popular definition of "haskell" is GHC-centric, for good reason. if a different compiler comes along, and haskell will be defined differently.
21:06:01 <kmc> my re2 binding supports ByteString (UTF8 or Latin1), Text, and String
21:06:18 <aristid> kmc: i think fighting the fluidity of natural language is futile and counterproductive
21:06:26 <ddarius> Yes, I'm just saying that was the conversation.  I'm not saying that you suggested using ByteString.
21:06:30 <kmc> oh
21:06:48 <maurer> tehgeekmeister: The more practical upshot of what kmc is saying is that if you are trying to turn a Char into a Word8, it probably shouldn't have been a Char in the first place
21:06:49 <ddarius> This was less than an hour ago.
21:07:02 <kmc> i don't understand which contradiction you're pointing at
21:07:17 <kmc> aristid, so if I start calling IRC "XChat" that's okay with you
21:07:18 <tehgeekmeister> maurer: it's a literal char
21:07:19 <maurer> tehgeekmeister: In fact, some things that produce Chars may attempt to do fancy UTF-8 decoding and the like you aren't looking for if you intend to convert it to a Word8
21:07:30 <maurer> tehgeekmeister: Oh, OK, nevermind then :P
21:07:34 <Axman6> i'm curious, if you were to translate that original enumerator code to use bytestrings, reading in the phrase to find as Text, and converting it to ByteString, and then searching in the bytes for that phrase, could you possibly have false positives?
21:07:39 <maurer> tehgeekmeister: My apologies
21:07:43 <aristid> kmc: if it catches on, i would probably have to grudgingly accept it. it isn't always easy
21:07:45 <tehgeekmeister> maurer: no problem
21:07:53 <kmc> aristid, right, but I don't think your usage of "Haskell" has caught on
21:08:12 <ddarius> Fuck acceptance.
21:08:34 <aristid> kmc: what do you think my usage of "haskell" is?
21:08:57 <tehgeekmeister> okay, running my test now
21:09:06 <kmc> aristid, that it's equivalent to "whatever GHC supports today"
21:09:10 <Philippa> Axman6: FWIW, you might be pissed off with the unhelpful nitpicks but your response re the particular issue was still crap
21:09:35 <aristid> kmc: i don't use it that way.
21:09:35 <shachaf> kmc: Calling IRC "mIRC" is fairly popular, I understand.
21:09:41 <kmc> shachaf, yeah
21:09:52 <kmc> aristid, ok, I must be confused then, but I'm really beyond caring
21:10:02 <maurer> shachaf: Indeed, and I bitch people out every time they do that.
21:10:22 <kmc> you use the word "Haskell" however you like; I'll complain if you use it in a confusing way, and you can complain if I call IRC "XChat"
21:10:23 <kmc> deal?
21:10:51 <shachaf> Hey, I was never in favour of calling GHC "Haskell".
21:10:55 <kmc> regarding Char -> Word8, I think a majority of people asking that question are confused about Char, Unicode, or how the world works
21:10:55 <aristid> kmc: sure. i thought my point about language was the more interesting bit either way.
21:10:57 <shachaf> Assuming that's what this discussion is about.
21:10:58 <tehgeekmeister> it doesn't appear to be doing a whole lot better than it was before.  IO is still peaking at 3MB/s.
21:11:03 <aristid> shachaf: no
21:11:07 <kmc> and a minority have a really solid reason to assert their code is ASCII only
21:11:20 <Axman6> Philippa: i don't really disagree. but sometimes nitpicking is far more unhelpful than just giving an answer to what they want. when people are usually asking that question, they have something like a character literal, and want the byte value of it. this usually implies they have an acsii value, because not many people write more uncommon unicode characters in their source. if it didn't worked, there's other things that can be suggested then
21:11:42 <kmc> Axman6, no, when people are usually asking that question, they are confused about Char, Unicode, or how the world works
21:12:11 <kmc> often they assume that Char is an "8-bit character" or a C char
21:12:14 * ddarius likes how many people here unilaterally ascribe intentions to large group.s
21:12:16 <shachaf> Oh, this is about confusing UTF8 and Unicode, or Char and Byte, or something like that?
21:12:31 <kmc> shachaf, it's about the question "How do I convert Char to Word8" with no context
21:12:33 <Philippa> Axman6: sure, so it could've been pointed out that a Char-that-is-in-ASCII can be mapped to Word8. OTOH, your response /was/ laden with race/nationalism/imperialism issues whether you intended it to be or not
21:12:36 <shachaf> Oh.
21:12:47 <shachaf> I think kmc's response to that question is pretty good.
21:12:49 <ddarius> kmc: Except that there was context in this case.
21:12:50 <Axman6> um what?
21:12:51 <kmc> it's fine for someone to say their code is ASCII-only and I can give advice from that perspective
21:12:54 <maurer> Maybe we should have called Char Glyph instead.
21:12:55 <kmc> but it's not the default assumption I will make
21:12:57 <tehgeekmeister> 44 seconds versus 4 seconds
21:13:02 <maurer> And had nothing called Char
21:13:12 <maurer> Just to prevent people from saying "I know what this is"
21:13:13 <kmc> ddarius, I must not have been paying enough attention to the context
21:13:15 <aristid> shachaf: would you consider haskell with NoMonomorphismRestriction and EmptyDataDecls to still be haskell. just curious, not want to debate any kmc about this any more
21:13:17 <ddarius> maurer: A Char is not a glyph.
21:13:23 <maurer> ddarius: Oh, then I too am confused.
21:13:23 <ddarius> kmc: Agreed.
21:13:25 <tehgeekmeister> so we've gone from 5 times as slow to ten times as slow as the perl version
21:13:26 <maurer> ddarius: What is it?
21:13:31 <shachaf> aristid: I think that's probably not a worthwhile argument.
21:13:36 <ddarius> maurer: A codepoint.
21:13:48 <maurer> That is different from a glyph?
21:13:54 <kmc> combining characters!
21:13:56 <kmc> @where zalgo
21:13:57 <lambdabot> import Random;main=mapM_((>>(×=<<randomRIO('Ì','Í¯'))).×)=<<getContents;×=putChar
21:13:59 <aristid> shachaf: ?
21:14:00 <ddarius> maurer: Yes.
21:14:07 <Axman6> Philippa: my issue was with things needing to perfect for a small, single person's use script. I fail to see how that makes what you said at all fair
21:14:21 <kmc>  ÍiÍ¡mÌ»pÌoÍ§rÍ©tÍ Ì¦ÈaÌ¢nÌºdÌoÍmÌ;Ìá¹aÍiÍnÍ=ÍmÌ¦aÍpÍMÍ_Í(Í(Í¥>Ì>Ì¥(Ì¡×Í=Ì<Ì»<Ì¦rÌ©aÍnÍ«dÍoÌmÌRÌIÌOÌ(Ì'ÍÌÌ'Ì,Ì'Í¢Í¯Ì¶'Ì)Í)Ì±)Í.Í§×Ì)Í¦=Ìª<Ì¾<ÌgÍ¡ÄtÌCÌoÍnÍÅ£eÌ®nÌtÍ£sÍ¨;Ì¯×Ì=ÌpÍuÍ¨tÌCÌhÌ³aÌ½rÌ
21:14:23 <ddarius> Axman6: She's complaining about your follow on comments.
21:14:39 <rwbarton> wow that line really messed up my terminal
21:14:46 <blackdog> kmc: like reading haskell on a pyramid
21:14:50 <Axman6> rwbarton: mine too. putty-- -_-
21:14:51 <Philippa> indeed, that goes a lot further than just "you probably knew what was intended though"
21:15:15 <kmc> Axman6, again, maybe this is my own carelessness, but I didn't see where tehgeekmeister said it was a one-off script with one user, before i said the thing about character encodings
21:15:37 <maurer> ddarius: Oh, OK, got it (just read up)
21:15:40 <tehgeekmeister> kmc: i had not said it directly
21:15:45 <ddarius> kmc: His original version used Text.  It was not his idea to use ByteString.
21:16:03 <Axman6> kmc: i'd infered it by the simplicity, and the fact it was being compared to perl. there's an equal chance i could have been wrong
21:16:26 <kmc> yeah, I'd rather ask a couple more questions than give silently bad advice
21:16:26 <ddarius> The suggestion to do so was to see if it made a difference in performance to help isolate the problem.
21:16:48 <Axman6> also, i might add my suggestion to use ByteString was not to change the code, but to see if it did perform differently, nothing more
21:16:51 <kmc> i don't see the relevance of being compared to Perl
21:17:09 <kmc> Perl is used all over in big production systems, processing Unicode text
21:17:12 <kmc> far more than Haskell is
21:17:45 <tehgeekmeister> kmc: perl is used more frequently for quick one off scripts than haskell.  in fact, my main use of perl is precisely that.
21:17:50 <ddarius> kmc: He has a working version that in 5x faster than his then-current version.  If this wasn't just for the heck of it, he'd be better off just using the Perl.  In fact, that's what I'd suggest if this was intended for actual use.
21:19:05 <Axman6> tehgeekmeister: did you take a look at that stringsearch package?
21:19:26 <tehgeekmeister> Axman6: nope, not yet.  just looking at a more detailed profile of it
21:19:31 <tehgeekmeister> (the new code, that is.)
21:19:57 <Axman6> "In general, not . null $ indices pat target is a much more efficient version of isInfixOf."
21:20:06 <Axman6> from the docs
21:21:10 <Axman6> tehgeekmeister: it doesn't seem to support Text though
21:21:19 <tehgeekmeister> https://gist.github.com/1553455 <== updated with new code and profile with nicely broken out cost centers
21:22:09 <ddarius> tehgeekmeister: Clearly go back to Text and try an alternate to isInfixOf.
21:22:26 <Axman6> ddarius: what alternates are there for Text?
21:22:35 <Axman6> alternatives*
21:22:51 <rwbarton> if not . null $ indices pat target is a much more efficient version of isInfixOf, how is that not a bug in the library
21:23:28 <Philippa> I'm not familiar enough with Text's performance characteristics: are there any use cases where Seq Char still makes enough sense to be worthwhile?
21:26:29 <tehgeekmeister> it's still got essentially the same performance.  convertLinesToFields is taking the largest chunk of the time, which surprises me.
21:27:09 <tehgeekmeister> oh, no, i'd misread the report, i think.  it's reporting it that way because the other enumeratees/iteratees got nested inside that one, isn't it?
21:29:47 <MostAwesomeDude> Hm. There's a (,) operator which is a -> b -> (a, b) right? Hoogle can't show it to me.
21:30:16 <DanBurton> @hoogle a -> b -> (a, b)
21:30:16 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
21:30:16 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:30:16 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:30:22 <DanBurton> blegh
21:30:35 <DanBurton> > (,) 2 "foo"
21:30:36 <lambdabot>   (2,"foo")
21:30:54 <MostAwesomeDude> Right, just wondering why Hoogle can't find it.
21:31:00 <MostAwesomeDude> @hoogle (,)
21:31:00 <lambdabot> Prelude undefined :: a
21:31:00 <lambdabot> Data.Function fix :: (a -> a) -> a
21:31:00 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
21:31:03 <DanBurton> no clue; that seems rather odd
21:31:07 <DanBurton> o_O
21:31:21 <DanBurton> conspiracy?
21:31:26 <rwbarton> well it's not defined in any source file, so it would have to be added manually
21:31:42 <MostAwesomeDude> Oh, it's part of the core and not the Prelude?
21:32:12 <rwbarton> it doesn't have the right kind of syntax to be defined in haskell
21:32:22 <ddarius> Yes.  It can't be defined for minor syntactic reasons.
21:32:36 <rwbarton> @hoogle a -> [a] -> [a]
21:32:37 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:32:37 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
21:32:37 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
21:32:49 <MostAwesomeDude> Aha. I'm just looking to clean up this hilarity: let packer (a1:a2:as) = (a1, a2) in ...
21:33:19 <MostAwesomeDude> Isn't there something lambdabot does to guess at a function name, given a definition?
21:33:49 <DanBurton> @djinn a -> b -> (a,b)
21:33:50 <lambdabot> f a b = (a, b)
21:33:56 <ddarius> You can get the type and then use hoogle, but nothing would go just by a definition.
21:34:01 <ddarius> Alternatively, you could use @pl.
21:34:12 <ddarius> Which may produce a suggestion.
21:34:24 <MostAwesomeDude> @pl f (x:y:xs) = (x, y)
21:34:24 <lambdabot> f = ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
21:34:26 <Axman6> @djinn a -> b -> (a,(a,(a,b)))
21:34:26 <lambdabot> f a b = (a, (a, (a, b)))
21:34:38 <Axman6> @djinn a -> b -> ((a,b),(a,(a,b)))
21:34:38 <lambdabot> f a b = ((a, b), (a, (a, b)))
21:34:44 <MostAwesomeDude> ...Yeah, that pointfree style is not helping.
21:34:44 <Axman6> hmm, no sharing
21:35:14 <MostAwesomeDude> I wonder if I can just change the relevant spot to return [a] instead of (a, a).
21:35:19 <ddarius> MostAwesomeDude: There is no function that does what packer does.
21:35:31 <ddarius> MostAwesomeDude: What's wrong with your code as is?
21:35:45 <MostAwesomeDude> ddarius: It comes right after a "take 2".
21:35:55 <MostAwesomeDude> It was just annoying me.
21:35:57 <ddarius> MostAwesomeDude: Just get rid of the take 2.
21:36:20 <tehgeekmeister> ddarius: why should i try an alternative to isinfixof when most of the time is spent in a different function?
21:36:24 <MostAwesomeDude> Yeah, that'd work.
21:37:55 <mm_freak> MostAwesomeDude: hoogle takes a type, not a valueâ¦  obviously there is no function of the ill-kinded type (,)
21:38:08 <mm_freak> @hoogle a -> b -> (a, b)
21:38:09 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
21:38:09 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:38:09 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:38:09 <ddarius> mm_freak: Hoogle also takes names.
21:38:19 <ddarius> mm_freak: In fact, that's how it is most commonly used here.
21:38:34 <mm_freak> oh, indeed
21:41:13 <mm_freak> :t uncurry id
21:41:14 <lambdabot> forall b c. (b -> c, b) -> c
21:41:20 <mm_freak> :t curry id
21:41:21 <lambdabot> forall a b. a -> b -> (a, b)
21:41:37 <mm_freak> @pl \x y -> (x, y)
21:41:37 <lambdabot> (,)
21:41:45 <ddarius> The counit and unit of the adjunction defining functions.
21:42:00 <DanBurton> @src curry
21:42:01 <lambdabot> curry f x y = f (x, y)
21:42:17 <DanBurton> it would probably be circular to define (,) in terms of curry
21:42:32 <mm_freak> > curry id 3 4
21:42:34 <lambdabot>   (3,4)
21:43:10 <mm_freak> DanBurton: i wouldn't know how to do that
21:43:13 <mm_freak> (,) is a constructor
21:43:27 <DanBurton> or is it? ...yeah I guess it is.
21:43:44 <ddarius> @src (,)
21:43:44 <lambdabot> Source not found. My pet ferret can type better than you!
21:43:51 <mm_freak> data (a, b) = (a, b)
21:49:17 <ddarius> It's data (,) a b = (,) a b
22:37:28 <zzo38> Control.Monad.Trans.Error defines MonadPlus IO but not Alternative IO and anyways their instance is wrong (I defined my own Alternative IO)
22:37:55 <zzo38>  I think they should allow override instances! I wrote some ideas in my user space in Haskell Wiki. Do you intend to implement anything like this in future?
22:41:52 <zzo38> The one they define is   mzero       = ioError (userError "mzero"); m `mplus` n = m `catch` \_ -> n
22:42:11 <zzo38> But that one wrong; good one is:   empty = fail []; x <|> y = catch x $ \e -> modifyIOError (\z -> if z == userError [] then e else z) y;
22:44:43 <zzo38> Do you think this one is better one or if it is also wrong?
22:54:03 <ddarius> Bread goes much better if your yeast is alive.
22:56:25 <DanBurton> ...what
23:17:47 <Sgeo> I may end up defining my own Storable instance
23:17:53 <Sgeo> What happens if my peek is wrong?
23:18:05 <Sgeo> Because I don't think I can write a correct peek
23:18:15 <Sgeo> Wait, what does bindings-dsl do for flexible arrays?
23:18:31 <Sgeo> For the sizeof or whatever, I mean
23:19:23 <ehuber_> ive had my program just crash w/out any warning or error message when i messed up my peek statements (hsc2hs)
23:26:49 <Veinor> oh dear
23:27:02 <Veinor> readFile "/etc/passwd\0lolololol" probably shouldn't work
23:33:06 <ehuber_> what's it do?
23:33:53 <ddarius> Presumably the actual system call sees "/etc/passwd"
23:34:56 <ehuber_> why's that bad?
23:35:45 <ddarius> I don't know.
23:36:28 <ehuber_> heh well, it's a file like any other .. and \0 is a perfectly ok character, and is how C denotes endofstring.. Veinor what's the concern?
23:36:32 <ddarius> It is generally somewhat bad to have two messages interpreted differently.  For example, an IDS may fail to recognize the former as problematic.
23:36:50 <ddarius> And then it gets used internally with a meaning different from what the IDS thought it was.
23:37:05 <arw> yes. but \0 is an illegal character in any filename in any filesystem I know of.
23:37:19 <ehuber_> oh, i get it
23:38:01 <ddarius> arw: It's not Haskell's readFile's job to decide what is and is not a legal file system character.
23:38:08 <Veinor> it's bad because if i do readFile $ "/tmp/" ++ userInput ++ ".cfg", and userInput = "../../../../../etc/passwd\0", ...
23:38:10 <arw> there are some very problematic things you could do with that.
23:38:45 <ddarius> Veinor: The handling of \0 is the least of your problems if you do that.
23:38:48 <Veinor> well, sure
23:39:04 <ehuber_> to be fair, you could be doing this in a c string too
23:39:10 <ddarius> But yes, that's along the lines of what I was saying above.
23:39:13 <arw> let \b be the backspace/delete to left character: "/etc/passwd\0\b\b\b\b\b\b\b\b\bharmless filename that the user sees.txt"
23:39:14 <Veinor> but this is still not something that should be doable at all
23:39:50 <arw> that is frequently used to exploit x509 certificates when ASN.1 and C don't agree about where the string ends...
23:39:50 <ddarius> Veinor: The "problem" is, in my opinion, below the level of Haskell.
23:40:10 <Veinor> well, in python you can't open() a file path with null bytes
23:40:23 <Veinor> so it wouldn't be unprecedented
23:40:27 <arw> ddarius: the problem is that haskell doesn't have the same idea of what a string is that the operating system has.
23:41:17 <ddarius> arw: True, but, as ehuber_ said, you can write the equivalent in C just as easily.
23:41:21 <Veinor> > takeExtension "foo\0cfg"
23:41:22 <lambdabot>   Not in scope: `takeExtension'
23:41:32 <Veinor> ddarius: 'C does it too' isn't a valid excuse
23:41:34 <arw> ddarius: no, you can't.
23:42:04 <ddarius> arw: I can't write fopen("/etc/passwd\0foobar") in C?
23:42:07 <arw> ddarius: its much harder, since almost everything in c consistently uses \0 as string termination character.
23:42:09 <Veinor> also, in System.FilePath.Posix, takeExtension and probably everything else doesn't know about poison null bytes
23:42:30 <arw> ddarius: you can. but you won't get any security bugs out of it
23:42:49 <Veinor> ddarius: it's a lot harder for a user to provide malicious input that winds up with you reading from "/etc/passwd\0foobar"
23:43:02 <ddarius> arw: There are plenty of sources of user input where you have something other than NUL termination to indicate the end of a string.
23:44:06 <arw> ddarius: which doesn't matter since usually that is converted into a \0-terminated string by just replacing the termination character in question. you can't really work with different kinds of strings in c.
23:44:36 <Veinor> ddarius: the problem is this:
23:44:39 <arw> ddarius: the only exception is asn.1 or pascal where a string has a length tag. which leads to the bugs described above.
23:44:50 <ddarius> arw: Who said anything about merely using a different termination character?  And you can easily add a takeWhile (/= '\0')
23:45:21 <ddarius> arw: In HTTP, you get told the length of POSTed data out of band.
23:46:17 <arw> yes, that too. probably also some source of buffer overflows in some webservers.
23:46:25 <Veinor> Prelude Text.Regex.Posix System.FilePath.Posix> let badInput = "file.malicious\0file.innocent" in takeExtension badInput
23:46:26 <Veinor> ".innocent"
23:46:34 <Veinor> this is a problem.
23:47:31 <Jafet> You are a programmer
23:48:05 <Veinor> i shouldn't have to check every place that might conceivably have a null in it
23:48:21 <ddarius> Veinor: If POSIX specifies that NUL bytes are illegal in filenames, I agree, it's a bug in System.FilePath.Posix.  It's still not a bug in readFile.
23:48:37 <ddarius> Veinor: No, you should be scrubbing all user input for NULs as well as many other things.
23:49:27 <Veinor> google says that NUL bytes are indeed illegal in filenames
23:49:29 <Veinor> in posix
23:49:34 <arw> ddarius: its a bug in the open()-syscall-wrapper that readFile uses.
23:50:04 <Jafet> I don't think it's a great idea to write your setuid binaries in glasgow haskell
23:50:28 <Veinor> Jafet: don't thing setuid, think 'web services'
23:50:31 <arw> Jafet: maybe, but in what language would you write those? C?
23:50:52 <Jafet> For better or worse, C is chained to unix in many ways.
23:51:08 <Veinor> i filed a ghc bug about it
23:51:11 <Veinor> well, feature request
23:51:35 <ddarius> What should the behavior of takeExtension even be in that example?
23:51:51 <Veinor> probably .malicious?
23:52:10 <Veinor> or it could throw an exception, i dunno
23:52:17 <Sgeo> If I use #starttype whatever
23:52:19 <Sgeo> #stoptype
23:52:30 <Sgeo> Can I make up my own whatever, or does it have to actually be a thing?
23:52:47 <Sgeo> Because I just really want an alias for void* that this library uses
23:52:52 <Veinor> "POSIX also allows that filesystems will probably be more relaxed than this, but it forbids the characters NUL and / from appearing in filenames."
23:52:52 <arw> depends on the underlying operating system. .malicious or exception on posix, perhaps .innocent if \0 is allowed on other systems.
23:52:56 <Sgeo> And I have to malloc space for it myself
23:53:36 <ddarius> Sgeo: bindings-dsl is just CPP macros.
23:53:51 <Veinor> either way the principle that 'openFile x should open a file whose extension is takeExtension x' should always be true
23:54:12 <The_Journey> hi, how would I make a function so that it will have a side effect? Like say I want to have a function f such that everytime it is invoked, it's output is non-deterministic to the caller?
23:54:29 <ddarius> The_Journey: You'd use a different language.
23:54:43 <shachaf> The_Journey: That's not what "function" means.
23:55:05 <The_Journey> is there something in Haskell that can do that?
23:55:08 <sp3ctum> i think it's a method description
23:55:09 <Sgeo> The result of a function always has to be the same, but the value it gives can mean "do this or that"
23:55:09 <arw> Veinor: oehm, is that currently true? posix doesn't know anything about file extensions and windows with vfat has two possibly different extensions per file...
23:55:18 <Sgeo> Or "one out of these values"
23:55:27 <Veinor> arw: let me rephrase
23:55:31 <sp3ctum> The_Journey, are you talking about random data generation?
23:55:34 <Veinor> it should open a function whose name contains takeExtension x
23:55:37 <Jafet> The_Journey: http://en.wikipedia.org/wiki/Function_(mathematics)
23:55:39 <Veinor> er, open a file
23:55:48 <shachaf> The_Journey: What are you actually trying to do?
23:55:49 <ddarius> Veinor: That underspecifies it.
23:55:53 <Sgeo> Take lists, for example. A list like [1,2,3] is a value, but you can consider it to be a number that might be 1, 2, or 3
23:56:03 <Veinor> it was a law, not a definition
23:56:31 <Sgeo> > do { a <- [1, 2, 3]; b <- [10,11,12]; return (a+b) }
23:56:32 <lambdabot>   [11,12,13,12,13,14,13,14,15]
23:56:41 <The_Journey> sp3ctum: well I have a function a that takes in a function b and everytime a calls b, it would get a different value, but I guess I'm barking up the wrong tree here
23:57:28 <Sgeo> :t runState
23:57:28 <lambdabot> forall s a. State s a -> s -> (a, s)
23:57:45 <Veinor> The_Journey: step back a little. what concretely are you trying to accomplish?
23:58:00 <Jafet> The best random sequences are deterministic.
23:58:15 <Sgeo> > flip runState 0 $ do { a <- getState; putState (a+1); b <- getState; return b }
23:58:16 <lambdabot>   Not in scope: `getState'Not in scope: `putState'Not in scope: `getState'
23:58:28 <Sgeo> > flip runState 0 $ do { a <- get; put (a+1); b <- get; return b }
23:58:30 <lambdabot>   (1,1)
23:59:07 <Veinor> also, argh
23:59:16 <Veinor> someone really needs to fix cabal-install and ghc 7.2
23:59:16 <shachaf> I think "the State monad" is the wrong answer to give to most people who are asking about how to do state.
23:59:47 * hackagebot websockets 0.5.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.5.0.0 (JasperVanDerJeugt)
23:59:48 <Veinor> maybe i should supply a patch
