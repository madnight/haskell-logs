00:08:59 <Fifo> @where lambdabot
00:08:59 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
00:15:18 <JoeyA> What happened to the module named Monad (without Control. ) ?  Was it deprecated, or is it part of a haskell98 package I don't have installed?
00:16:30 <JoeyA> Oh, it is in the haskell98 package.  I guess they took that out of the Haskell Platform recently, or maybe I don't have it because I didn't install the Haskell Platform all the way.
00:17:13 <MarcWeber> JoeyA: Its in base.Control.Monad now
00:17:50 <MarcWeber> So replace "Monad" by Control.Monad and should be fine (I may be wrong - didn't do that much Haskell lately)
00:18:16 <JoeyA> But that's 8 extra characters (I was thinking along the lines of code golf)
00:18:31 <JoeyA> Monad has fewer exports than Control.Monad
00:18:47 <MarcWeber> JoeyA: Then wait till someone with more knowledge replies.
00:18:53 <JoeyA> Thanks
00:20:23 --- mode: ChanServ set +o dibblego
00:20:28 --- kick: Fifo was kicked by dibblego (Fifo)
00:20:31 --- kick: iPhoneFifo was kicked by dibblego (iPhoneFifo)
00:24:32 <Fifo> dibblego: Why did you kick me?
00:25:04 <dibblego> Fifo: please do not spam the channel or its users in private
00:25:29 <Fifo> dibblego: Sorry!
00:25:49 <Fifo> dibblego: Please join ##iPhoneFifo!
00:37:51 <hpaste_> Cain pasted “SDL-image error” at http://hpaste.org/56429
00:38:09 <Cain_> Hey, if anyone is online, would you have any idea why i'm getting that error? ^
00:38:10 <Cain_> thanks :)
00:39:12 <koral> hi, I've got a strange problem with the package hbro; I split it into hbro and hbro-contrib, the latter imports the former; at compilation, I'm getting this odd "Couldn't match expected type `hbro-0.8.0.0:Hbro.Types.Environment' with actual type `Environment'" error message
00:40:18 <koral> it only occurs at Dyre's recompilation
00:40:28 <koral> not in a standard "cabal install" compilation
00:46:59 <Lemmih> Cain_: What version of GHC do you have?
00:47:15 <Cain_> version 7.0.4
00:48:01 <Lemmih> Cain_: What's in the generated Version.hs file?
00:48:55 <Cain_> appears to be nothing
00:49:20 <Cain_> it's 0kb
00:49:30 <Lemmih> Can you run hsc2hs?
00:51:09 <Cain_> sorry, yes
00:51:14 <Cain_> i'll check*
00:51:39 <Cain_> Lemmih, what sholud I run it on?
00:51:43 <Cain_> should *
00:52:44 <Fifo> Cain_: Please /join ##iPhoneFifo.
00:53:49 --- mode: dibblego set +b *!*58d42422@*.88.212.36.34
00:53:52 --- kick: Fifo was kicked by dibblego (Fifo)
00:54:06 --- mode: dibblego set +b *!*Fifo@*.antik.sk
00:54:09 --- kick: iPhoneFifo was kicked by dibblego (iPhoneFifo)
01:09:51 <Lemmih> Cain_: Try running 'Setup build -v'.
01:11:02 <Sgeo> @hoogle flop
01:11:02 <lambdabot> No results found
01:11:04 <Sgeo> Boo
01:13:00 <hpaste_> Cain_ pasted “verbose SDL-image build” at http://hpaste.org/56430
01:14:13 <gestur> .quit
01:15:22 <Lemmih> Cain_: Try running hsc2hs on Version.hsc manually.
01:16:03 <Cain_> ah
01:16:12 <Cain_> thanks Lemmih :)
01:16:16 <Cain_> it's not finding SDL_image.h
01:43:07 <drbean> It looks like it won't back out of a stacked case and try the next one like I hear it's supposed to do with pattern matching.
01:44:18 <ddarius> drbean: Paste your code and what you expect it to do.
01:44:20 <drbean> Getting a non-exhaustive pattern in case that would be satisfied in a case of a case lower down.
01:44:48 --- mode: dibblego set -o dibblego
01:47:15 --- mode: ChanServ set +o dibblego
01:47:17 --- mode: dibblego set -b *!*58d42422@*.88.212.36.34
01:47:21 --- mode: dibblego set -o dibblego
01:48:10 <applicative> drbean: http://hpaste.org/
01:49:18 <hpaste_> drbean pasted “statcked case not backed out of” at http://hpaste.org/56431
01:49:55 <drbean> Wait that is not it.
01:55:04 <hpaste_> drbean pasted “statcked case not backed out of” at http://hpaste.org/56432
01:57:19 <drbean> If I change 4,5 and 6-8 around in that paste, then 'Queen was a homeless woman' errors with Queen was a homeless woman.     *** Exception: LogicalForm.hs:(227,44)-(229,66): Non-exhaustive patterns in case
02:00:12 <XexonixXexillion> drbean: unless I'm mistaken, that last pattern is unreachable. It reaches the second pattern, goes into the case statement, and then can't match to the case statement's pattern
02:01:41 <TheLemonMan> is there a standard function that extracts n elements starting from m or do i have to write my own ?
02:01:59 <ddarius> take n . drop m
02:02:08 <ddarius> Assuming you are referring to a list.
02:02:30 <applicative> drbean: like XexonixXexillion says, aren't they actually the same case?
02:02:31 <TheLemonMan> yessir. thanks
02:02:32 <drbean> I believe that's what's happening too, but I expected it to be reachable, like I heard pattern matching is.
02:03:06 <XexonixXexillion> drbean: Your pattern match suceeds, and then it goes to another pattern match. Perhaps you are thinking about guarded expressions?
02:03:24 <XexonixXexillion> drbean: (the other pattern match being the one for the case)
02:03:41 <ddarius> There is no backtracking.
02:03:51 <drbean> The first case is checking for whether 'was' is followed by anything.
02:05:26 <drbean> Then the second cases are checking for the form of the 3 Cats that follow.
02:06:17 <drbean> I should have realized that because I am getting 'Pattern matches are overlapped' errors.
02:07:49 <hpaste_> XexonixXexillion annotated “statcked case not backed out of” with “statcked case not backed out of (annotation)” at http://hpaste.org/56432#a56433
02:07:51 <drbean> With the [np,pos,cn] and [det,adj,cn] arguments.
02:08:37 <ddarius> XexonixXexillion: There's no reason to do that.  drbean can just pattern match against adj in the alternative anyway.
02:09:03 <ddarius> Which is probably what should be done for all the inner cases.
02:09:52 <XexonixXexillion> ddarius: Agreed, but it's the least typing :p
02:10:05 <ddarius> No it isn't.
02:11:43 <drbean> Yes that isAdjective guard does fix it.
02:12:50 <XexonixXexillion> drbean: It's not an ideal solution; it's merely an example of how it will drop through failed guards
02:13:00 <fedvasu> I have a small problem
02:13:21 <drbean> I didn't want heavy pattern matches on the LHS.
02:13:34 <drbean> I thought heavy RHS was better.
02:13:36 <fedvasu> in lesson 6 of LYHGG
02:13:49 <fedvasu> the chapter named modules
02:14:07 <fedvasu> at the end the author , says one can create submodules
02:14:34 <fedvasu> and put them together in a folder and that folder will be treated as module
02:15:00 <fedvasu> Geometry/Sphere.hs,Cuboid.hs,Cube.hs
02:15:11 <fedvasu> where each source file has
02:15:30 <fedvasu> module Geometry.<filename>
02:15:50 <fedvasu> (volume,area) , where
02:15:57 <fedvasu> definitions of area and volume
02:16:09 <fedvasu> but how to load this module in ghci
02:16:12 <fedvasu> ??
02:16:38 <fedvasu> when i just write a plain import statement it says can;t find module
02:17:01 <fedvasu> if i import the source file it imports the Geometry.<filename> module
02:17:51 <fedvasu> without qualification , i am not able to use all three submodules at a time
02:18:20 <Saizan> you need a Geometry.hs if you want a Geometry module
02:19:02 <applicative> fedvasu:  try starting ghci outside the Geometry directory, doing ghci Geometry/Sphere.hs
02:19:15 <Saizan> also, you can use "import Geometry.Foo" and then "import Geometry.Bar" if you want to load both, i think
02:19:55 <applicative> then when Geometry.Sphere imports Geometry.Cuboid, ghci will know where to find Geometry.Cuboid
02:20:34 <ddarius> GHCi would know that regardless of where you were.
02:20:41 <fedvasu> im starting ghci outside of the geometry module all the time
02:20:56 <ddarius> The terminology "submodule" is misleading.
02:21:13 <rostayob> is gloss viable to build 2D games?
02:21:15 <fedvasu> Saizan: I suspected that
02:21:35 <ddarius> Haskell's module namespace is flat.  There is no relation between the Geometry module (which doesn't exist) and Geometry.Sphere, or between Geometry.Sphere and Geometry.Cube.
02:22:05 <ddarius> rostayob: It would depend on the game.
02:22:07 <fedvasu> ddarius: please elaborate
02:22:27 <ddarius> fedvasu: There's nothing to elaborate.
02:22:50 <fedvasu> is this an errata in the book?  as the author doesn't ask to write a Geometry.hs
02:22:59 <fedvasu> file which shows the
02:23:03 <rostayob> ddarius: so, which kind of games? I'm doing a simple platformer
02:23:15 <fedvasu> relation between Sphere.hs, Cube.hs
02:23:20 <ddarius> fedvasu: It definitely talks about Geometry.hs.
02:23:20 <fedvasu> and Cuboid.hs
02:23:22 <rostayob> the big problem is that the "play" function requires all the functions to be non-IO
02:23:45 <rostayob> so, for example, it would be impossible to include sound
02:24:31 <fedvasu> no Geometry.hs , which contains sphereVolume , sphereArea etc
02:24:39 <fedvasu> not submodules
02:25:22 <fedvasu> here is the text
02:25:24 <fedvasu> Modules can also be given a hierarchical structure. Each module can have a number of submodules, which can have submodules of their own. Let’s section our geometry functions so that Geometry is a module that has three submodules: one for each type of object. First, we’ll make a folder called Geometry. In it, we’ll place three files: Sphere.hs, Cuboid.hs, and Cube.hs. Let’s look at what each of the files contains. Here are 
02:25:48 <rostayob> ddarius: also, afaik it's impossible to draw text
02:26:02 <fedvasu> otice how we placed Sphere.hs in a folder call- ed Geometry, and then defined the module name as Geometry.Sphere. We did the same for the cube and cuboid objects. Also notice how in all three sub- modules, we defined functions with the same names. We can do this because they’re in separate modules.
02:26:35 <ddarius> rostayob: You wouldn't use just gloss unless your game was rather simple.  You could probably make your own "play" function connecting to more events.
02:26:44 <XexonixXexillion> rostayob: nothing is impossible when you have unsafePerformIO, just ill-advised :p
02:26:50 <rostayob> ddarius: yeah, that's the impression I have as well
02:27:06 <ddarius> gloss is definitely not intended to be a "real" game API.
02:27:14 <rostayob> ddarius: it's a shame because it's a really nice library. If it offered you a bit more control...
02:27:40 <rostayob> maybe it wouldn't be that nice :P
02:28:29 <XexonixXexillion> gloss is intended to be put in front of first year programming students, so that they can do nice looking things without worrying about having to control everything
02:28:41 <rostayob> yeah, fair enough
02:32:38 <applicative> fedvasu: but in the sentence you're talking about there is no Geometry.hs and so far no "module Geometry"
02:33:37 <applicative> fedvasu: I see, I think there is a defect in the way he's writing there should be a bigger break where he begins "Modules can also be given a hierarchical structures." He is starting from scratch
02:34:01 <fedvasu> applicative: my point!!
02:34:28 <ddarius> applicative: Since he never goes on to say "import Geometry" later, that isn't crucial.
02:34:46 <applicative> yeah, it seems likely to confuse
02:35:13 <ddarius> applicative: The real thing that "wrong" is talking about modules having "sub-modules."
02:35:16 <fedvasu> applicative: there must be some glue code in Geometry.hs to make it possible to do
02:35:19 <ddarius> There are no "sub-modules" in Haskell.
02:36:15 <fedvasu> ok i get it , there is no sub-modules in haskell
02:36:28 <applicative> ddarius, of course, but it should be clear that the old Geometry.hs and module Geometry are out of the picture, no?
02:36:29 <fedvasu> thats the term author uses , so my bad
02:36:38 <fedvasu> yeah
02:36:44 <ddarius> fedvasu: It's not your fault.
02:36:52 <ion> Num.Rational? Nope. Num.Ratio? Nope. Surely not Data.something. Oh! Rational? Nope. Ah! Ratio. (I never remember the name of the module on the first try. :-P)
02:36:52 <applicative> fedvasu: ddarius understands that I think
02:37:09 <ddarius> ion: Data.Ratio
02:37:15 <fedvasu> whatever
02:37:25 <ion> ddarius: Oh. So it seems. :-D
02:37:28 <fedvasu> here what happened in ghci session
02:37:36 <ddarius> There is no Num hierarchy at all, so I'm not sure why you'd guess that.
02:39:15 <fedvasu> Cuboid.hs  Cube.hs Prelude> :l Geometry/Cube.hs  [1 of 2] Compiling Geometry.Cuboid  ( Geometry/Cuboid.hs, interpreted ) [2 of 2] Compiling Geometry.Cube    ( Geometry/Cube.hs, interpreted ) Ok, modules loaded: Geometry.Cube, Geometry.Cuboid. *Geometry.Cube> import qualified Geometry.Cube as Cube
02:39:23 <fedvasu> so far so good
02:40:14 <fedvasu> now this is beyond cmprehension
02:40:16 <fedvasu> *Geometry.Cube Geometry.Cube> import qualified Geometry.Cuboid as Cuboid *Geometry.Cube Geometry.Cube Geometry.Cuboid> Cuboid.area 67 1 2 406.0 *Geometry.Cube Geometry.Cube Geometry.Cuboid> Cube.area 7  <interactive>:1:1:     Failed to load interface for `Cube':       Use -v to see a list of the files searched for.
02:40:34 <ion> Ah, the haskell98 package exports “Ratio”.
02:40:59 <fedvasu> Cuboid.area works
02:41:08 <fedvasu> but when i say Cube.area
02:41:17 <fedvasu> failed to bring up interface
02:41:59 <Cain_> Lemmih, sorry to be a pain, but if you're still on, could I get your assistance again? I fixed the other problem of not having SDL_image.h by prepending SDL\ to the include, but now i'm getting WinMain@16 linker errors (which go away if i add the flags -lmingw32 -lSDLmain -lSDL but the build still fails (with the same error) even if i manually add these to the config.mk), any ideas?
02:42:46 <rostayob> what would be really nice is to have gloss "Picture" in a separate library and then have different backends to play with
02:43:37 <Saizan> fedvasu: could be a bug of "import qualified" in ghci
02:44:11 <Saizan> fedvasu: what you can do is have a .hs file with all the imports as you like them and load that
02:45:21 <ddarius> rostayob: As far as I can tell, nothing keeps you from using Picture and display within another program.  There's also a displayWithBackend function that lets you use a different backensd.
02:54:51 <applicative> fedvasu: it is a little surprising, the 'import Blah" inside ghci is new.  this works, some strangely, ":l Geometry/Cube.hs" then ":m -Geometry.Cube" then "import qualified Geometry.Cube as Cube"
02:57:55 <rostayob> ddarius: yeah but for example the OpenGL "backend" is not exposed
02:58:21 <Lemmih> Cain_: No ideas. Building on Windows is just plain hard.
02:58:52 <Cain_> Ah ok, I might just switch to my laptop for this :)
02:58:53 <Cain_> thanks
03:00:35 <ion> I hadn’t even noticed import qualified … as … works in ghci nowadays. This is great.
03:03:11 <applicative> fedvasu: if you put this omnibus Geometry.hs outside the Geometry directory, that's one way of getting everything qualified inside ghci http://hpaste.org/56435
03:04:02 <applicative> ion, it does seem a little confusing with uncompiled things
03:04:42 <ion> Aye, but my typical use case would be something like import qualified Data.ByteString as BS.
03:05:08 <applicative> yeah, I do that all the time, its great
03:07:16 <eg202_MM_VV_2> @pl \x -> (x,y)
03:07:16 <lambdabot> flip (,) y
03:08:15 <ion> (,y)
03:08:22 <ion> (TupleSections)
03:09:56 <rostayob> eg202_MM_VV_2: you can use (,y) with TupleSections
03:10:24 <eg202_MM_VV_2> thanks rostayob
03:10:34 <eg202_MM_VV_2> I only wanted to test the @pl script :)
03:32:44 <dschoepe> Is it a good idea to use criterion for non-Haskell things, for example by just running the binary in question in an IO action and have criterion benchmark that?
03:34:51 <jdp32> i just started reading realworldhaskell. haskell is the shit
03:35:48 <Jafet> dschoepe: well, just be aware of what you're really measuring
03:36:20 <dschoepe> Jafet: Yeah, I guess things like starting the binary would make it a bit less useful.
03:37:40 <Jafet> It shouldn't be hard to implement most of criterion in another language
03:38:00 <Jafet> People who use those languages just generally don't have the temerity to
03:50:44 <koala_man> I can't seem to find anything in the haskell platform for connecting to databases. what's a fair choice for that?
03:57:53 <aristid> koala_man: hackage has plenty of those.
03:58:04 <aristid> @hackage mysql-simple
03:58:04 <lambdabot> http://hackage.haskell.org/package/mysql-simple
03:58:37 <aristid> i don't know which database you use. apparently the portable database packages are much slower.
03:59:10 <aristid> koala_man: see here for a list of ALL packages: http://hackage.haskell.org/packages/archive/pkg-list.html
03:59:29 <koala_man> aristid: yes, it has loads. that's the problem. most of them are experimental, old and/or immature
03:59:51 <aristid> mysql-simple isn't
04:00:00 <aristid> which database, again, are you using?
04:01:49 <koala_man> aristid: I'll be creating it, so anything foss would work. whatever has the most convenient haskell libs, for example
04:02:45 <aristid> mysql i guess.
04:03:17 <luite> persistent is relatively convenient, but only if you don't need too many complex queries or really high performance
04:06:25 <donri> also acid-state is nice if you don't have an existing database
04:07:10 <luite> i personally don't like that you don't have your data in a format that easily accessible with existing tools (for backup, simple manipulation with scripts etc)
04:08:42 <luite> i'd use it for things where the data is less critical and performance is important, like storing web sessions
04:22:05 <hpaste_> drbean pasted “I think I read a guards explanation wrong.” at http://hpaste.org/56437
04:25:11 <Jafet> You are correct that you are wrong. That explanation of guards is not incorrect.
04:34:02 <dd> any dere
04:34:12 <dd> dd
04:34:18 <dd> any one dere
04:35:15 <alistra> we're ear
04:45:39 <Jeffrey_> Hi Guys! O
04:45:44 <Jeffrey_> Hi Guys!
04:45:56 <luite> hi Jeffrey_!
04:46:16 <Jeffrey_> Do you want get free premium account on TutsPlus.com?
04:46:27 <luite> no
04:47:03 <Jeffrey_> Okay! How are you? You use Haskell?
04:47:09 <luite> yes
04:49:52 <Jeffrey_> Something very little activity in the chat...
04:50:11 <sipa> sometimes
04:50:14 <luite> yeah it's quiet
04:50:20 <luite> but ppl are generally helpful
04:50:28 <srhb> It's actualy a very active channel.
04:50:50 <sipa> depends on the time of the day
04:52:08 <Sgeo> Is it just me, or does Gloss have no provision for making games that, say, do IO?
04:52:56 <rostayob> Sgeo: yeah
04:53:09 <rostayob> that's what i asked a few minutes ago
04:53:24 <rostayob> another thing: is it possible to use SDL and OpenGL in haskell?
04:53:26 <Jeffrey_> Got it. I want create game for pokki competition)
04:53:31 <luite> rostayob: yes!
04:54:03 <rostayob> luite: ok, where are the functions? they don't seem to be in SDL
04:54:23 <Jeffrey_> I want use WebGL, but I don't know WebGL...
04:54:40 <luite> rostayob: hmm I'm nto sure how but some games seem to use it
04:54:53 <rostayob> luite: use what?
04:54:59 <luite> sdl with opengl
04:55:03 <rostayob> ah
04:55:06 <rostayob> games like?
04:56:02 <Jeffrey_> rather I want create game...
05:00:23 <luite> rostayob: hmm, there are some packages that depend on both
05:01:54 <luite> rostayob: this one seems to use OpenGL and SDL http://hdiff.luite.com/cgit/astrds/tree/src/RenderUtil.hs?id=f66153d852baf2f1e94355161ec21124b6aca074
05:06:51 <Sgeo> Is SDL easy to learn?
05:09:07 <luite> it's fairly low-level code, all in IO
05:09:38 <luite> not really difficult I'd say
05:33:19 <alistra> @instances Applicative
05:33:20 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
05:33:34 <alistra> anyway:
05:33:38 <alistra> Applicative (StateR s)	 
05:33:39 <alistra> Applicative (StateL s)
05:33:44 <alistra> what are those 2 classes
05:33:57 <alistra> hoogle nor google don't know anything about htem
05:39:12 <byorgey> alistra: no idea, where did you see those?
05:39:27 <alistra> hackage?
05:39:31 <alistra> Control.Applicative
05:39:36 <alistra> i was wondering if State
05:39:39 <alistra> is Applicative
05:44:23 <byorgey> alistra: every instance of Monad should also be an instance of Applicative
05:44:28 <byorgey> alistra: State s  certainly is
05:44:40 <byorgey> I don't know what StateR and StateL are though
05:45:19 <byorgey> hmm, those are listed in the Control.Applicative docs, aren't they
05:45:39 <Sgeo> Listed, but not linked
05:47:18 <nus> Data.Traversable.State{R,L}
06:03:11 <dmwit> :t foldr
06:03:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:03:42 <dmwit> :t let (!~) = undefined in (!~)
06:03:43 <lambdabot> forall a. a
06:03:54 <Sgeo> Is there an extension that allows you to define how deriving operates for user-made classes?
06:05:55 <pradeep13> :t concatMap
06:05:55 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:06:02 <hpc> Sgeo: don't think so
06:06:47 <Sgeo> :t flip (>>=) `asAppliedTo` ['a']
06:06:48 <lambdabot>     Couldn't match expected type `a -> m b'
06:06:48 <lambdabot>            against inferred type `[a1]'
06:06:48 <lambdabot>     In the second argument of `asAppliedTo', namely `['a']'
06:07:05 <Sgeo> :t flip (>>=) `asAppliedTo` (:[])
06:07:06 <lambdabot> forall b. (b -> [b]) -> [b] -> [b]
06:07:18 * Sgeo apparently doesn't know how to asAppliedTo
06:07:50 <Sgeo> :t (=<<) `asTypeOf` (undefined::(a -> [b]) -> [a] -> [b]))
06:07:51 <lambdabot> parse error on input `)'
06:07:57 <Sgeo> :t (=<<) `asTypeOf` (undefined::(a -> [b]) -> [a] -> [b])
06:07:58 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:09:56 <Sgeo> :t asAppliedTo
06:09:57 <lambdabot> forall t b. (t -> b) -> t -> t -> b
06:12:03 <dmwit> If you're going to give a type signature anyway, asTypeOf/asAppliedTo seems a bit silly.
06:12:24 * Sgeo blinks at suddenly realizing the obvious thanks to dMazz 
06:12:27 <Sgeo> erm, dmwit
06:24:14 <dgpratt> Sgeo: since I know next to nothing about it, this probably isn't what you were asking for, but it *sounds* sorta like what you were asking for: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/generic-programming.html
06:24:57 <Sgeo> Hmm
06:29:39 <Sgeo> What's the difference between GHC.Generics and Data.Data?
06:31:14 <rostayob> Sgeo: they're completely different
06:31:59 <rostayob> Typeable and Data are a set of typeclasses to, respectively, reify monomorphic types and traverse data structures generically
06:32:17 <rostayob> GHC.Generics introduces a meta-representation for data-types
06:32:24 <rostayob> so you can write your generic functions on that
06:32:29 <rostayob> and then convert back and forth
06:32:51 <donri> O hackagebot where art thou
07:01:36 <XexonixXexillion> is there anyway I can run an IO function at compile time, and then choose to throw an error based on the result?
07:02:43 <aristid> XexonixXexillion: yes, but... don't.
07:03:25 <donri> template haskell
07:04:24 <XexonixXexillion> aristid: Why is throwing an error at compile time bad; if the compiled code in not going to run, why not throw the error at compile time?
07:06:09 <carpi> in a do block when we do something like "n <- getLine" .... what does the '<-' stand for? is it an infix function? or is it a language construct like "if" and "let"? Because the IO monad doesn't seem like it has the "<-" implemented..
07:06:16 <carpi> or am i confusing myself?
07:06:25 <donri> i think it makes perfect sense to abort compilation with template haskell. it's sort of the whole point to quasi-quotation for example.
07:06:38 <donri> check syntax at compile time, possibly fail
07:07:10 <Sgeo> carpi, it's part of the do notation. It gets desugared into something like getLine >>= \n ->
07:07:13 <nand`> carpi: do a <- b; c is syntactic sugar for b >>= \a -> c
07:07:19 <donri> carpi: it is syntactic sugar for >>=
07:08:02 <nand`> in short, the rest of the lines are “bound” to
07:08:04 <nand`> err
07:08:24 <carpi> donri: i thought 'do' was sugar for >>=
07:08:29 <nand`> the result of “getLine” is “bound” to n for the rest of the lines
07:08:55 <carpi> nand`: meaning i can refrence 'n' in any of the liens that follow?
07:09:02 <nand`> yes, it's like a lambda
07:09:22 <aristid> XexonixXexillion: well, what do you want to check?
07:09:23 <nand`> getline >>= \n -> putStr ("hello " ++ n)
07:09:38 <nand`> do n <- getLine; putStr ("hello ++ n)
07:09:41 <nand`> same thing
07:10:00 <donri> carpi: http://book.realworldhaskell.org/read/monads.html#monads.do
07:10:02 <carpi> nand`: ah okay.. so all the ensuing lines will be inside nested lambdas? or rather it helps to think of it that way.. am i correct?
07:10:56 <nand`> carpi: they're nested inside lambdas, which then get passed as argument to >>=, yes
07:10:59 <nand`> note the signature of >>=
07:11:19 <nand`> (Monad m) => m a -> (a -> m b) -> m b
07:11:50 <nand`> the rest of the lines are put inside a lambda for (a -> m b), with the name of the variable to the left of <- having the type a in this case
07:12:27 <aadrake> I have a function that may or may not produce IO and I'm not sure how to go about making nothing happen in the case that there is no IO.  I looked into the Maybe monad but haven't been using Haskell long enough to really digest how to use that or if it is even necessary.  Advice?
07:12:43 <ddarius> return ()
07:12:47 <XexonixXexillion> aristid: whether or not their version of X supports non rectangular windows
07:13:02 <aadrake> ddarius: That is significantly simpler than I thought it would be
07:13:06 <carpi> so do a <- b; c; d will be something like "b >>= (\a -> c >> (\_ -> d))"
07:13:19 <carpi> is that more or less correct ? ^^^^
07:13:41 <ddarius> XexonixXexillion: And if I build the program and then give it to someone else, what happens?
07:13:59 <adrake_> carpi: that looks right to me
07:14:04 <adrake_> carpi: ah
07:14:08 <nand`> carpi: (>>) has the signature (Monad m) => m a -> m b -> m b
07:14:14 <nand`> but otherwise it's correct
07:14:22 <carpi> holy shite.. thats correct?
07:14:26 <adrake_> (\_ -> d) should just be  d
07:14:28 <carpi> no wait.. something's wrong?
07:14:29 <adrake_> due to >>
07:14:30 <nand`> in your example it would be >>= instead of >>, or that adrake_ said
07:14:33 <carpi> ah okay.. : )
07:14:40 <Sgeo> a >> b is a >>= \_ -> b
07:15:06 <nand`> but yeah, same principle - nested lambdas, each new line is bound to the previous
07:15:13 <carpi> but why would it be >>=? because in the example i gave , the result of the evaluation of c is not passed on to d...
07:15:22 <XexonixXexillion> ddarius: It'll throw an error at run time
07:15:35 <adrake_> carpi: >>= is the monad primitive, >> is a helper for "ignore the result of the thing on the left"
07:15:41 <nand`> carpi: I'm saying it would have to be >>= for (_ -> d) to be correct
07:15:48 <nand`> which for all intents and purposes, is the same as >>
07:16:06 <nand`> _ means “throw this away”
07:16:08 <Sgeo> \_ -> d is a function that ignores its argument and returns d
07:16:31 <XexonixXexillion> On second thoughts, I'll just make it print a warning at compile time
07:16:43 <aadrake> ddarius: Thank you
07:17:30 <donri> same as const, no?
07:17:37 <donri> @pl \_ -> a
07:17:38 <lambdabot> const a
07:17:45 <ddarius> XexonixXexillion: This seems like a waste of effort.
07:18:27 <nand`> donri: yeah, (>>) = (const =<<)
07:19:08 <aadrake> ddarius: I've tried to put return (blahblahblah) out of my mind and I guess that was a mistake.
07:19:15 <XexonixXexillion> ddarius: The entire things is a complete waste of time, and probably something only I will use; but I have nothing to do for nearly a month
07:19:48 <carpi> thanks for the clarifications..  i think i understood something
07:20:03 <donri> @where do
07:20:03 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
07:20:06 <donri> also
07:21:11 <donri> hlint will warn or error for some of those
07:35:51 <jkoshy> @undo do { x <- Just (3+5); y <- Nothing; return (x-y); }
07:35:51 <lambdabot> Just (3 + 5) >>= \ x -> Nothing >>= \ y -> return (x - y)
07:37:44 <donri> @undo do a; b
07:37:45 <lambdabot> a >> b
07:37:47 <donri> nice
07:37:54 <Sgeo> undo isn't perfect
07:38:13 <Sgeo> @undo do { a <- Just 5; b <- Just 6; return (a+b) }
07:38:14 <lambdabot> Just 5 >>= \ a -> Just 6 >>= \ b -> return (a + b)
07:38:30 <Sgeo> Much easier to write (+) <$> Just 5 <*> Just 6 or something
07:39:10 <donri> @pl Just 5 >>= \ a -> Just 6 >>= \ b -> return (a + b)
07:39:10 <lambdabot> (`fmap` Just 6) . (+) =<< Just 5
07:39:26 <alistra> lol
07:39:30 <donri> ^_^
07:39:43 <donri> liftM2?
07:40:16 <Peaker_> @unpl liftM2 (+) (Just 5) (Just 6)
07:40:16 <lambdabot> ((Just 5) >>= \ b -> (Just 6) >>= \ a -> return (b + a))
07:40:44 <Peaker> no, you see, the names are backwards in liftM2 :-)
07:41:15 <Peaker> @unpl liftA2 (+) (Just 5) (Just 6)
07:41:15 <lambdabot> liftA2 (+) (Just 5) (Just 6)
07:41:52 <nand`> is lambdabot open source?
07:42:01 <Peaker> nand`: cabal install lambdabot
07:42:29 <ddarius> Sgeo: @undo isn't trying to produce the "nicest" expression.  It simply desugars do-notation as specified by the Report with a slight simplification.
07:42:38 <Sgeo> simplification
07:42:39 <Sgeo> ?
07:42:41 <ddarius> @undo do Just x <- m; x
07:42:41 <lambdabot> m >>= \ a -> case a of { Just x -> x; _ -> fail ""}
07:43:52 <alistra> > fail ""
07:43:54 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:43:54 <lambdabot>    arising from a use of `M7354501529...
07:44:09 <alistra> > fail "" :: State Int Int
07:44:10 <lambdabot>   No instance for (GHC.Show.Show
07:44:10 <lambdabot>                     (Control.Monad.Trans.Sta...
07:44:30 <alistra> > fail "" :: IO ()
07:44:32 <lambdabot>   <IO ()>
07:44:36 <alistra> > fail "" :: IO 5
07:44:37 <lambdabot>   Only unit numeric type pattern is valid
07:44:44 <alistra> > fail "" :: IO Int
07:44:45 <lambdabot>   <IO Int>
07:45:26 <Sgeo> > runState () (fail "Fail")
07:45:27 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
07:45:27 <lambdabot>         ...
07:45:32 <Sgeo> :t runState
07:45:33 <lambdabot> forall s a. State s a -> s -> (a, s)
07:45:51 <Sgeo> > runState (fail "Fail") ()
07:45:52 <lambdabot>   *Exception: Fail
07:50:29 <alistra> > error (show 1 ++ error (show 2 ++ error "")))
07:50:30 <lambdabot>   <no location info>: parse error on input `)'
07:50:31 <alistra> > error (show 1 ++ error (show 2 ++ error ""))
07:50:33 <lambdabot>   *Exception: 1*Exception: 2*Exception:
07:52:11 <alistra> > foldl (\x y -> error (show y ++ x) [1..10]
07:52:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:52:19 <alistra> > foldl (\x y -> error (show y ++ x)) [1..10]
07:52:20 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:52:20 <lambdabot>    arising from the literal `1...
07:53:32 <alistra> > foldr (\y x -> error (show y ++ x)) "" ([1..10] :: [Int])
07:53:34 <lambdabot>   "*Exception: 1*Exception: 2*Exception: 3*Exception: 4*Exception: 5*Exceptio...
07:53:41 <x_man1> I have a question concerning strong normalization of simple typed lambda calculus.
07:53:43 <alistra> > foldr (\y x -> error (show y ++ x)) "" [1..]
07:53:44 <lambdabot>   "*Exception: 1*Exception: 2*Exception: 3*Exception: 4*Exception: 5*Exceptio...
07:54:25 <alistra> x_man1: yes?
08:23:18 <bobry> QuickCheck question: is it possible to derive Arbitrary instances for records automatically?
08:23:39 <alistra> bobry: derive
08:23:45 <alistra> @hackage derive
08:23:45 <lambdabot> http://hackage.haskell.org/package/derive
08:24:57 <bobry> alistra: nice, thank you
08:25:23 <alistra> ;]
08:47:32 <ergot> I have set the library-profiling option in cabal to True and rebuilt some modules, will this affect the performance of any program built using this modules or just the ones compiled with profiling flags?
08:49:45 <geekosaur> profiling creates a completely separate version of the library that is used only with programs built for profiling; normal builds are completely unaffected
08:49:57 <ergot> ok great
08:49:59 <ergot> thank you
08:51:14 <geekosaur> (the flip side of this is sometimes you'll go to build a program for profiling and get link errors because you don't have the profiling version of some library it uses...)
08:52:31 <dmwit> Turn on the profiling flag before you install GHC.
08:52:34 <dmwit> Be forward-looking.
09:00:27 <hpaste_> keep_learning pasted “error in dph-examples installation library on mac os x version 10.7.2” at http://hpaste.org/56445
09:00:40 <keep_learning> hello all
09:01:08 <keep_learning> i am trying to install doh-examples library on mac os x version 10.7.2 but getting error.
09:01:38 <keep_learning> Could some one please tell me how to resolve this issue.
09:02:15 <angstrom> how can I easily make a data-type an instance of Eq, such that only the type-constructor is taken into account?
09:03:00 <ryuk58> i have a function that prints IO [()], how can i drop the [()]?
09:03:32 <copumpkin> you probably used mapM or sequence instead of mapM_ or sequence_
09:03:58 <ryuk58> i used sequence, then sequence_ solves my problem?
09:04:04 <Saizan> keep_learning: do you have LLVM installed?
09:04:17 <copumpkin> ryuk58: look at the types for the two
09:04:19 <copumpkin> :t sequence
09:04:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:04:21 <copumpkin> :t sequence_
09:04:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:04:37 <copumpkin> ryuk58: sequence_ just ignores the results
09:04:48 <ryuk58> ok.. thx
09:05:09 <keep_learning> Saizan, i am fairly new to mac so i have installed Xcode. I am not sure if LLVM is installed.
09:05:29 <keep_learning> Saizan, how to check if LLVM is installed ?
09:05:39 <ryuk58> it worked, thx alot
09:06:05 <Saizan> keep_learning: don't know, i've never used osx myself
09:07:33 <keep_learning> Saizan, Thank you for you time.  Looks like  i have to dig on net to installed LLVM .
09:10:34 <hpaste_> keep_learning annotated “error in dph-examples installation library on mac os x version 10.7.2” with “error in dph-examples installation library on mac os x version 10.7.2 (annotation)” at http://hpaste.org/56445#a56446
09:12:06 <keep_learning> Saizan, It seems that only error is in installing dph-examples. In ghci It shows Data.Array.Parallel
09:12:50 <keep_learning> Saizan, could you confirm if its enough to start for parallel programming ?
09:14:37 <ryuk58> is there a way to join the result of two sequence_
09:14:49 <hpaste_> ocharles pasted “Struggling to implement MonadBase for PropertyM (QuickCheck)” at http://hpaste.org/56447
09:14:49 <ddarius> (>>)
09:15:08 * ddarius prods copumpkin.
09:15:26 <ocharles> Hi, I'm trying to create an instance of MonadBase for PropertyM in QuickCheck, and the above ends up failing one of the functional dependencies, but I don't know why this is
09:15:31 <Saizan> keep_learning: don't know, but you could try compiling some program that imports that module to test
09:15:37 <ocharles> Paste at http://hpaste.org/56447, with error message
09:16:23 <rostayob> sometimes, i really wish Haskell had a ML-style module system
09:17:49 <angstrom> e.g., `data A = B | C Int | D | E Int' `C 4 == C 2' -> True
09:23:19 <ocharles> Hum, I really can't see how given: class MonadBase b m | m -> b, "instance MonadBase b m => MonadBase b (PropertyM m)" would fail the fun dep :(
09:23:42 <Saizan> it doesn't, but it fails the coverage condition
09:23:51 <dolio> angstrom: Empty record matches work on any data type. So you can write cases like "C{} == C{} = True".
09:24:03 <ocharles> hmm, what does failing the coverage condition mean?
09:24:47 <dolio> Of course, that's only a win if you have constructors with more than one field.
09:24:53 <Saizan> ocharles: that b doesn't appear in (PropertyM m), that's what the condition check, since that's a sufficient (but not necessary) condition to satisfy the fundep
09:24:57 <angstrom> dolio: yeah. but I was hoping that there's a way around writing the class instance myself, given the data-type is quite "big"
09:25:12 <Saizan> ocharles: so in this case it's fine to turn on UndecidableInstances
09:25:15 <dolio> I don't know of a way to derive it.
09:25:18 <ocharles> ah
09:25:25 <Cale> dolio: It's also a win if you ever extend the number of fields, even if they only have one field now.
09:25:26 <ocharles> and I see that http://hackage.haskell.org/packages/archive/transformers-base/0.4.1/doc/html/src/Control-Monad-Base.html#liftBase also turns UndecidableInstances on
09:25:32 <ddarius> > let constrEq x y = toConstr x == toConstr y in Just 3 `constrEq` Just 4
09:25:33 <lambdabot>   True
09:25:36 <ddarius> > let constrEq x y = toConstr x == toConstr y in Just 3 `constrEq` Just True
09:25:36 <lambdabot>   True
09:25:37 <dolio> angstrom: You could probably derive Data, and query the constructor.
09:26:05 <dolio> Which is what ddarius just did.
09:26:41 <dolio> Cale: Yes. I merely meant that C{} == C{} is no shorter than C _ == C _.
09:26:55 <dolio> And it's longer than D == D, of course.
09:27:07 <angstrom> ah. I didn't know about toConstr yet :-)
09:43:13 <ocharles> Is it possible to write a MonadTransControl instance for continuation monads? I see the docs explicitly say "except ContT", and I seem to remember reading somewhere that it can't be done for the general ContT transformer, but can be done for specific continuation monads
09:46:56 <ocharles> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/76262 also seems to suggest it can't be done
09:48:36 <boz> hello
09:48:56 <boz> just been sent ere by a friend
09:50:59 <Saizan> hi
09:51:27 <luite> ocharles: this was one of the reasons for yesod to switch from enumerator to conduit
09:51:49 <ocharles> luite: because it's unsolvable, or terribly hard? :)
09:51:57 <luite> it looks unsolvable
09:52:00 <ocharles> damn
09:52:13 <ocharles> to step back and /achieve, I'm trying to bracket monadic quickcheck actions, so I can do quickcheck against my database
09:52:23 <luite> conduit is simpler, based on mutable data instead of continuations
09:52:27 <ocharles> i want to delimit (may be the wrong term) each property by a rolled back transaction
09:53:03 <ocharles> last time I asked here the answer was "oh, you simply want bracket, so you just need to write an instance of {whichever class I needed}"
09:53:15 <byorgey> boz: that friend is a keeper
09:55:10 <hpc> ocharles: that's correct; the hardest part of what you want i think will be figuring out how to tell your database to roll back
09:55:20 <hpc> then you do something like:
09:55:35 <hpc> bracket connect testAction rollbackAndDisconnect
09:56:22 <ocharles> right, but PropertyM is implemented in terms of continuations, so I'm stuck. I guess I can't use a general bracket function, and would have to write my own?
09:56:29 <boz> thanks @byorgey
09:56:40 <hpc> :t bracket
09:56:41 <lambdabot> Not in scope: `bracket'
09:56:46 <hpc> @hoogle bracket
09:56:46 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:56:46 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:56:46 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:56:56 <ocharles> there's one in lifted-base
09:57:07 <boz> gah, havent used irc in a while
09:57:19 <ocharles> which requires MonadTransControl, which is where I'm stuck, because I can't figure out how to capture the state
09:58:12 <boz> im new to programming - but im computer literate. when i say new to programming i mean ive dabbled, but nothing serious
09:58:24 <boz> why is haskell good and is it useful?
09:58:55 <donri> http://www.haskell.org/haskellwiki/Introduction
09:59:23 <byorgey> boz: it's very useful, it can be used for pretty much anything.
09:59:31 <luite> ocharles: hmm i think it might still be possible to do (not 100% sure), but actions may be lost or get executed more than once
09:59:32 <donri> sorry for link-dumping over answering personally, but have to go now :)
09:59:40 <boz> programming microcontrollers?
09:59:41 <hpc> ocharles: i would write a specific instance, i think
09:59:47 <boz> its fine donri
09:59:49 <hpc> ocharles: unless you really need the full polymorphism
09:59:57 <ocharles> hpc: a specific bracketting function you mean?
10:00:13 <hpc> or that, yes
10:00:31 <ocharles> hpc: I was just unclear of an instance of what; a typeclass?
10:00:36 <byorgey> boz: it could be used for that (and people do) but probably not directly
10:00:50 <hpc> of MonadBaseControl
10:00:58 <byorgey> boz: i.e. you could use Haskell to write high-level code that *generates* other code which will then actually run on the microcontroller.
10:01:07 <hpc> instance MonadBaseControl IO YourSpecificThingHere where ...
10:01:17 <monochrom> microcontrollers seems to be a niche
10:01:20 <rsimoes> is there a way to bundle ffi libraries so that they can be compiled without ghc?
10:01:26 <byorgey> boz: for example, see http://hackage.haskell.org/package/atom
10:01:30 <hpc> though just writing your own bracketFoo is probably better
10:01:34 <hpc> so ignore me
10:01:36 <hpc> :P
10:01:40 <ocharles> hpc: right, that's what I was doing but, YourSpecificThingHere is a PropertyM, which is a continuation - and it seems that a monad MonadBaseControl for that is very hard
10:01:45 <ocharles> cause that was my initial attack :)
10:02:00 <boz> thankyou
10:02:29 <luite> ocharles: lemme know if you succeeed :)
10:02:53 <ocharles> luite: I doubt my haskell-fu, but I'll probably try the cafe and see if any other gurus can shine some light :)
10:03:27 <ocharles> it's a real shame though, cause my initial quickcheck-against-a-database stuff has worked really well, but nothing cleans up after itself so I get primary key violations
10:22:19 <Sgeo> Are there any languages that don't curry by default but still make partial application easy?
10:24:01 <monochrom> SML
10:30:30 <ddarius> Haskell
10:32:31 <alistra> > don't curry by default
10:32:32 <lambdabot>   <no location info>: parse error on input `default'
10:35:45 <hpc> > let don't _ = return () in don't curry by
10:35:46 <lambdabot>   Not in scope: `by'
10:36:04 <monochrom> "default" is a keyword, remember? :)
10:36:18 <hpc> yeah, just trying to see if "don't curry by" typechecked
10:36:58 <monochrom> "don't = id" would allow maximum currying
10:39:24 <monochrom> ddarius, there is a strong sense in which SML doesn't curry by default and Haskell does. in SML: op + (1,2). in Haskell: (+) 1 2
10:40:15 <monochrom> similarly for turning alphabetic function names into infix syntax
10:47:04 <dolio> Does it have curried product constructors?
10:47:38 <dolio> data Foo = Bar Int Char vs. Bar (Int, Char)
11:00:29 <saati> hi, while i was reading this http://jaspervdj.be/posts/2012-01-14-monads-arrows-build-systems.html i found something i don't uderstand there is instance Monad BuildM where return x = BuildM []   $ return x ... how can something be equal to itself applied to something?
11:04:45 <Lemmih> saati: 'return' is overloaded.
11:05:04 <lispy> tommd: http://www.jpeg.org/public/jfif.pdf
11:06:00 <k0001> Hi everyone. I'm looking for a function like "filterSingle" here {[1,2,3] >>= filterSingle odd} that would give the same results as {mfilter odd [1,2,3]}, (i.e, [1,3]). {[1,2,3] >>= (\pred -> (\x -> if pred x then return x else mzero)) odd} would work of course, but I'm wondering if the standard library provides something like that already. filterSingle's signature should be something like {MonadPlus m => (a -> Bool) -> a -> m a}. I tried bu
11:06:54 <saati> k0001: you were cut of at "I tried bu"
11:07:05 <k0001> “I tried but couldn't find something like that on Hoogle.
11:07:13 <k0001> :)
11:09:22 <Lemmih> k0001: filterSingle f x = guard (f x) >> return x ?
11:09:28 <hpaste_> s pasted “x” at http://hpaste.org/56452
11:12:24 <teneen> I want to read the ghc core output, but when compiling with ddump-simpl I only see the main function in the core
11:12:31 <teneen> where are the other functions?
11:12:45 <hpaste_> Duffman- pasted “Quicksorts” at http://hpaste.org/56453
11:12:49 <Lemmih> teneen: Try adding -fforce-recomp
11:12:50 <fryguybob> k0001: (. return) . mfilter ?
11:13:13 <Duffman> Hello, in this code you can see 2 implementations of quicksort: http://hpaste.org/56453
11:13:14 <teneen> Lemmih: I did
11:13:22 <Duffman> is one of them faster than the other?
11:13:27 <teneen> Lemmih: It only show functions which are called from main
11:15:02 <Lemmih> teneen: Are the missing functions used at all?
11:16:10 <teneen> I had to call them in main to see their core. But again their core is not output separately
11:16:42 <Lemmih> teneen: I don't quite follow.
11:16:50 <k0001> Lemmih, fryguybob interesting approaches, thank you. Anyway, I thought some reusable function like that would be available on the standard library.
11:17:10 <lispy> JuicyPixel is kind of nice.  TomMD and I are hacking out a repa wrapper to make it a bit easier to use for OpenGL.
11:19:07 <luite> how fast is it compared to devil or similar?
11:24:22 <lispy> luite: I haven't done any benchmarking.  The cool thing about juicypixel is that I don't have to install devil to build it
11:26:09 <cmccann> oh, what's this about juicypixel and gl?
11:26:14 <cmccann> loading pngs as textures?
11:26:20 <cmccann> that would be amazing.
11:26:20 <lispy> cmccann: yes
11:26:25 <lispy> We're going via repa
11:26:31 <cmccann> interesting
11:26:35 * cmccann has never used repa
11:27:15 <lispy> So you would convert to Data.Vector.Storable then you can use the Ptr a to either construct a HOpenGL PixelData, or with OpenGLRaw, you could directly call glteximage2d
11:27:51 <lispy> So it's like load with juciypixel, get a Data.Vector.Storable instance then bind that to a texture
11:28:05 <cmccann> sounds awesome
11:28:11 <lispy> It sounds more compilcated than it is
11:28:37 <cmccann> I figure the complicated part is getting everything hooked up and working
11:28:45 <cmccann> understanding complicated stuff in order to do something simple with it :P
11:29:46 <lispy> cmccann: something like that :)
11:30:26 <cmccann> lispy, anything I could pitch in with? I've been wanting something along these lines for a while
11:30:26 <parcs`> does juicypixel use its own decoding algorithm?
11:31:24 <lispy> parcs`: yeah, it's pure haskell
11:31:36 <carpi> could someone please tell me if there is a library for communicating with nfc chips?
11:31:41 <lispy> cmccann: We don't have anything on github yet, but tommd has a fair bit of code in his emacs buffer :)
11:32:16 <lispy> cmccann: One thing tommd has been looking for is what api to export in order to be useful to people.  do you have example code where you used some other library that he could reference?
11:33:00 <tommd> Right now I did a bad job of engineering and am trying to redesign so we don't need undecidable instances.
11:33:31 <tommd> I'll clean and push to github
11:33:37 <tommd> then notify folks here.
11:34:06 <Sgeo> Suppose I have a zipper
11:34:18 <Sgeo> I move from one end to the other, while evaluating everything in between
11:34:27 <Sgeo> Will all of that stuff stay in memory?
11:34:38 <cmccann> lispy, sadly no, I always found the whole thing too much of a pain to be honest
11:34:53 <cmccann> I've got some broken code lying around somewhere and some stuff using drawingcombinators that's just geometric shapes
11:36:44 <Duffman> Can someone explain why it is possible to process infinite lists with foldr while this is impossible with foldl?
11:37:18 <Eduard_Munteanu> Duffman: see how foldr associates, and take laziness into account.
11:37:39 <cmccann> lispy, and I'm kind of rusty with opengl in general, otherwise I'd be tempted to bash out a simple game of some sort just to take things for a spin :P
11:37:44 <Eduard_Munteanu> E.g. a `op` (b `op` c)
11:38:20 <cmccann> was already tempted to do that using juicypixel to load sprites for SDL, but GL would be nicer
11:38:29 <Eduard_Munteanu> Well, you have the starting value as well.
11:39:12 <Eduard_Munteanu> Duffman: so if the operation you're applying is *not* strict, then you can get intermediate results as you go
11:39:38 <Duffman> what do you mean with strict Eduard_Munteanu?
11:40:33 <Eduard_Munteanu> Duffman: as in strict evaluation, "non-lazy".
11:40:43 <lispy> cmccann: You should do the next Ludum Dare in Haskell.  It's in April :)
11:41:04 <Duffman> I see
11:41:54 <cmccann> lispy, if I have time to rough out some of my baseline stuff before then
11:41:59 <cmccann> so I can publish it as a library
11:42:00 <Eduard_Munteanu> Duffman: (+) on Haskell's numeric types is strict, while (:) isn't.
11:42:24 * lispy is rethinking our approach.  What if we made JuicyPixel use repa or Data.Vector instead of writing a conversion wrapper.
11:42:25 <cmccann> don't really relish the idea of implementing everything during a ludum dare's time frame
11:42:26 <Eduard_Munteanu> Duffman: think what happens if you fold a list with (:)
11:42:31 <Eduard_Munteanu> *foldr
11:42:58 <Duffman> I'm just having trouble grasping the  fact you can work with infinite lists I think. I mean I understand the implementation of foldr. But the way I see it, the base-case (foldr f e [] = e) is never reached and so the computation just keeps on going
11:43:18 <Duffman> oh
11:43:26 <Duffman> ":" is not strict
11:43:36 <Eduard_Munteanu> Duffman: you can process the intermediate results, you don't need the whole result
11:43:37 <Duffman> so that means that it will create an "intermediate" list?
11:43:53 <shachaf> Duffman: The base case is indeed never used in an infinite list.
11:43:56 <Eduard_Munteanu> Yes. x:y:z:...
11:44:16 <Duffman> that also answers one of my other questions: why "repeat" works :)
11:44:23 <Sgeo> @src repeat
11:44:24 <lambdabot> repeat x = xs where xs = x : xs
11:44:41 <lispy> cmccann: I have a day job and a sweetheart so bounding ludum dare to 48 hours makes it possible to participate for me :)
11:45:15 <cmccann> lispy, I did a couple pyweeks, I know what longer time frames are like :P
11:45:27 <Eduard_Munteanu> Duffman: in repeat, you don't care for the whole result, just that you can get an arbitrary number of pieces from it (as long as it's not infinite, sure)
11:45:52 <Eduard_Munteanu> > take 3 $ repeat 1
11:45:53 <cmccann> but haskell lacks too much stuff right now for me to tackle a worthwhile game in 48hrs
11:45:54 <lambdabot>   [1,1,1]
11:45:57 <Duffman> but the implementation of repeat also relies on the ':'-operator being lazy richt?
11:45:58 <Sgeo> > take 20 $ zip [1..] (repeat 'a')
11:45:59 <lambdabot>   [(1,'a'),(2,'a'),(3,'a'),(4,'a'),(5,'a'),(6,'a'),(7,'a'),(8,'a'),(9,'a'),(1...
11:46:00 <Duffman> right*
11:46:07 <Eduard_Munteanu> Duffman: yes
11:46:18 <lispy> cmccann: ah, so that's why I'm hacking on this library :)  Next I need to revisit the SDL bindings
11:46:22 <Duffman> k
11:46:29 <lispy> cmccann: having some trouble building sdl-mixer but most of the rest of sdl is working
11:46:31 <Duffman> gonna play around with foldr and infinite lists in ghci for a sec
11:46:34 <Duffman> thx Eduard_Munteanu
11:46:36 <Sgeo> How easy is SDL to learn for someone who did a bit of XNA in class?
11:46:44 <cmccann> SDL is stupidly simple
11:46:47 <cmccann> there's very little to learn
11:46:49 <Sgeo> Gloss doesn't seem to allow IO in its games, which seems stupid to mean
11:46:49 <Duffman> can I ping you again if I'm not understanding it?
11:46:50 <Sgeo> *me
11:47:08 <cmccann> Sgeo, the hard part is what you have to do on your own
11:48:05 <cmccann> SDL is about as low-level as possible while being usefully platform-independent, honestly
11:48:07 <Sgeo> "low-level"?
11:48:11 <Sgeo> :/
11:48:23 <Duffman> Eduard_Munteanu, got it. Thx!
11:48:24 <Duffman> :)
11:48:34 <cmccann> you can create surfaces with pixels, blit between them, get events, stuff like that
11:48:51 <Sgeo> What's a NoParachute?
11:49:08 <Sgeo> InitNoParachute :: InitFlag
11:49:17 <Eduard_Munteanu> Duffman: well, you can ask further questions in here, anybody can answer.
11:50:26 <Eduard_Munteanu> Duffman: also, compare with foldl to see the difference
11:50:27 <cmccann> Sgeo, something to do with stuff to run if the program crashes I think
11:51:14 <Sgeo> It would be nice if things like http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL.html listed all the functions on one page
11:51:27 <Eduard_Munteanu> > foldl (++) [] [a,b,c,d]
11:51:28 <lambdabot>   Couldn't match expected type `[a]'
11:51:29 <lambdabot>         against inferred type `SimpleRef...
11:51:41 <lispy> cmccann: The reason I was looking at SDL is that the alternative looks to be hand picking libraries and making sure they play well together.  SDL has already done that for me.  But, it's true that I oscillate between those two alternatives frequenly :(
11:52:03 <Eduard_Munteanu> > foldl (+) 0 [a,b,c,d]   -- but ignore the strictness of (+)
11:52:04 <lambdabot>   0 + a + b + c + d
11:52:08 <lispy> and OpenAL fails to build for me on windows...
11:52:09 <Eduard_Munteanu> Bah.
11:52:22 <cmccann> Sgeo, the SDL bindings are pretty direct, try consulting the C documentation
11:52:30 <cmccann> it should be easy to translate that back
11:53:36 <Eduard_Munteanu> You also don't really want foldr with strict operations, foldl' is better.
11:53:46 <parcs`> sdl supports an insane amount of platforms
11:53:47 <shachaf> Eduard_Munteanu: (+) isn't actually strict.
11:53:57 <shachaf> > foldr (+) 0 [1..] :: Expr
11:53:57 <Eduard_Munteanu> Yeah, it's strict only for integer types.
11:53:58 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
11:54:12 <saiko-chriskun> is there any still maintained more portable haskell compiler besides hugs? nhc98 doesn't seem to have any recent activity...
11:54:45 <Eduard_Munteanu> saiko-chriskun: Hugs isn't maintained anymore AFAIK
11:54:55 <cmccann> lispy, I don't really mind SDL
11:54:57 <ddarius> Hugs is not a compiler.
11:55:04 <Eduard_Munteanu> That too :)
11:55:19 <rostayob> SDL is awesome
11:55:22 <rostayob> idiot proof
11:55:41 <rostayob> and if you need to code a 2D game, is good enoufh
11:55:43 <rostayob> *enough
11:55:45 <saiko-chriskun> heh :P
11:56:07 <saiko-chriskun> so there doesn't really exist an alternative then?
11:56:26 <Eduard_Munteanu> I wonder if Cairo works as well for graphics. There should be an OpenGL backend.
11:56:28 <cmccann> SDL is nice for what it is, just isn't really enough to build a game quickly for something like ludum dare
11:56:47 <rostayob> yeah, it's not a game engine
11:56:58 <carpi> is there a way to force the evaluation of a fucntion?
11:57:05 <Eduard_Munteanu> It's more like a hw/abstraction lib.
11:57:14 <rostayob> yes, but a good and really simple one
11:57:16 <Eduard_Munteanu> *hw/OS abstraction
11:57:32 <carpi> or rather to make it strict
11:57:53 <Sgeo> If Gloss included IO, would that make it more sufficient for games?
11:58:06 <cmccann> I don't think that's really what gloss is meant for
11:58:16 <rostayob> Sgeo: gloss, like SDL, is nice for what it is
11:58:26 <lispy> Eduard_Munteanu: there is an experimental opengl backend for cairo, but the problem with cairo is the gtk dependency is very hard to satisfy for mere mortals on non-linux systems.
11:59:03 <cmccann> getting SDL to work with haskell on non-linux systems is also a pain
11:59:13 * lispy is anti-gtk so take my complaints with a grain of salt.
11:59:29 <lispy> cmccann: right, I'm running into that :)
11:59:40 <rostayob> cmccann: is it? damn
11:59:43 * cmccann is anti-non-native-GUI as far as such things go, but that doesn't matter for games mostly
11:59:48 <lispy> cmccann: so that's why I often use glfw-b for making the opengl context
12:00:02 <kqr> how do you perform a binary not in haskell?
12:00:33 <Eduard_Munteanu> Ah, I see.
12:00:34 <cmccann> rostayob, there are multiple difficulties, starting with the usual FFI installation headaches on Windows in particular
12:00:34 <edwardk> look in Data.Bits for complement
12:00:41 <kqr> edwardk, right, thx
12:00:51 <Sgeo> cmccann, FFI installation headaches?
12:00:51 <cmccann> and then extra headaches because of the whole SDLMain madness
12:01:23 <cmccann> Sgeo, getting FFI bindings to install from hackage can be a crapshoot on Windows in my experience
12:01:24 <exFalso> good evening, how can one get the bounds of an STArray?
12:01:51 <rostayob> cmccann: oh.. I know nothing about that
12:01:54 <cmccann> but at least the SDLMain thing can be worked around by exporting your actual main through the FFI and building the application with a C wrapper
12:02:03 <rostayob> (about the FFI headaches)
12:02:03 <exFalso> :t bounds
12:02:05 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
12:02:31 <Eduard_Munteanu> :t getBounds
12:02:32 <lambdabot> Not in scope: `getBounds'
12:02:34 <Sgeo> :t getBounds
12:02:35 <lambdabot> Not in scope: `getBounds'
12:02:36 <tazjin> So I felt like making a simple wallpaper: http://klaud.tazj.in/DKrM :]
12:02:40 <rostayob> @hoogle getBounds
12:02:41 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
12:02:53 <exFalso> thank you!
12:02:55 <Sgeo> Well, getBounds is an MArray method, and STArray is an MArray
12:03:26 <exFalso> hmm no instance for MArray
12:04:10 <rostayob> exFalso: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-ST.html#t:STArray
12:04:45 <cmccann> lispy, anyway, I've been thinking about getting some game library stuff hacked together recently
12:05:01 <cmccann> since that's something I like tinkering with anyhow and it came up on /r/haskell recently
12:05:09 <exFalso> yeah i found the hackage package as well:) just cant find a bounds function
12:05:25 <lispy> cmccann: checkout #haskell-game if you want to find collaborators
12:05:32 <Eduard_Munteanu> exFalso: it's just not documented there
12:05:38 <lispy> cmccann: Yeah, I think I posted that on /r/haskell :)
12:05:42 <Eduard_Munteanu> It's part of the MArray interface.
12:05:47 <JoeyA> What is the benefit of using registerDelay n over do {v <- newTVarIO False; _ <- forkIO $ threadDelay n >> atomically (writeTVar v True); return v}
12:05:47 <exFalso> oh hmm the instance is there,
12:06:01 <JoeyA> Other than terseness.  registerDelay is only available with -threaded.
12:06:04 <rostayob> exFalso: yeah that's what i was referring to
12:06:04 <Eduard_Munteanu> However, the docs do tell you it's an instance of MArray.
12:06:27 <cmccann> lispy, oh, ok. sheesh, can't keep it straight when people use different handles on reddit and irc...
12:06:43 <exFalso> thank you figured it out misread the error message oops
12:06:44 <lispy> cmccann: oh right.  I'm lispy here and dagit or thedagit everywhere else
12:07:13 <ddarius> cmccann: What do you do about the people you meet in person?
12:07:15 <cmccann> lispy, ok. will probably forget next time it matters, but ok.
12:07:33 <lispy> cmccann: Well, /whois lispy should tell you if you forget
12:07:45 <cmccann> ddarius, I try to avoid that mostly, it just makes things more difficult
12:07:53 <Eduard_Munteanu> ddarius: I've seen people continuing to use the "virtual" handles IRL
12:08:14 <Eduard_Munteanu> Especially when it comes to community-related meetings.
12:08:23 <lispy> like shapr
12:08:36 <lispy> he took using his irc nick IRL to the logical extreme
12:08:47 <Eduard_Munteanu> Heh.
12:09:25 <rostayob> mhm... there wouldn't be a way to modify the elements of a map 'Map k a' with some functions of type 'a -> IO a',  right?
12:09:29 <shachaf> lispy: Not as extreme as Ingy döt Net.
12:09:31 <nand`> Is there an equivalent of mod for fractionals?
12:09:40 <Eduard_Munteanu> Oh, what? :)
12:09:43 <nand`> eg. (Fractional a, Integral b) => a -> b -> a
12:09:52 <lispy> shachaf: I'm not sure what you're referencing
12:10:34 <shachaf> lispy: A person I know whose nick is "ingy" and whose domain name is ingy.net.
12:10:50 <lispy> shachaf: but did ingy change his real name legally?
12:10:54 <shachaf> Yes.
12:10:56 <lispy> ah okay
12:11:14 <ddarius> Or mayhaps he changed his name illegally!
12:11:37 <lispy> Exception: Illegal name change
12:11:57 <eyebloom> What is "intensional analysis"?
12:12:02 <Eduard_Munteanu> rostayob: well, you could end up with Map k (IO a), but do you really want that?
12:12:07 <Eduard_Munteanu> :t fmap
12:12:08 <lispy> ddarius: I tried to follow you on g+ the other day but then realized that google was tricking me.  Sorry if you received email because of that.
12:12:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:12:16 <aristid> Eduard_Munteanu: well, nicknames can be quite practical when three people in the room have the name Christian :)
12:13:07 <Sgeo> I think rostayob wants Map k a -> (a -> IO a) -> IO (Map k a)?
12:13:09 <rostayob> Eduard_Munteanu: actually, if Map had Traversable
12:13:13 <rostayob> Sgeo: yes
12:13:19 <rostayob> which would be provided by Traversable
12:13:36 <Eduard_Munteanu> Looks like it does.
12:13:51 <rostayob> oh, wonderful then
12:14:48 <Sgeo> mapM = sequence . fmap ?
12:15:07 <kqr> if i use complement to inverse an integer, it gives me the number with a sign. can i somehow return the literal inversion as a positive number?
12:15:14 <Sgeo> o.O at WrapMonad shenanigans
12:16:12 <Sgeo> Makes sense, way to get an fmap and <*> out of any monad
12:16:24 <Sgeo> But what if some idiot makes a monad with a nonsensical fmap?
12:16:40 <Sgeo> Then the Traversable stuff won't see it
12:16:40 <Eduard_Munteanu> kqr: I'm unsure what you mean.
12:17:01 <Eduard_Munteanu> Sgeo: well, that's not *really* a monad :)
12:17:17 <ddarius> kqr: An Integer has an infinite number of bits.
12:17:49 <Peaker> rostayob: SDL is annoying on OS X.. GLFW-b works ok everywhere
12:18:29 <kqr> Eduard_Munteanu, hm. i have a string which i want to "encrypt" by mapping (complement . xor 57) over each character
12:18:56 <kqr> Eduard_Munteanu, but complement returns a negative number, something chr dislikes
12:19:35 <nand`> kqr: add 255 to it?
12:19:41 <kqr> nand`, point very well made
12:19:47 <rostayob> Peaker: last time I checked, SDL ran more or less everywhere
12:19:51 <Eduard_Munteanu> kqr: ah, then see what ddarius said
12:20:36 <kqr> nand`, thanks
12:20:37 <nand`> 256, even
12:20:58 <Peaker> rostayob: it uses ugly c preprocessor tricks to run on OSX
12:20:59 <nand`> (since complement also subtracts one)
12:21:00 <Eduard_Munteanu> kqr: do you actually have Integer?
12:21:06 <Peaker> rostayob: so the Haskell bindings have trouble on OSX
12:21:11 <kqr> Eduard_Munteanu, i have whatever ord returns
12:21:11 <Eduard_Munteanu> Or some Int something?
12:21:25 <kqr> int, as it happens to be
12:21:26 <Eduard_Munteanu> :t ord
12:21:27 <lambdabot> Char -> Int
12:21:36 <rostayob> Peaker: trouble = they don't work, or they work but you have to fight with them?
12:21:39 <ddarius> > complement 0
12:21:40 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:21:40 <lambdabot>    `Data.Bits.Bits a'
12:21:40 <lambdabot>      a...
12:21:42 <Eduard_Munteanu> kqr: ah, you're ok then.
12:21:43 <ddarius> > complement 0 :: Integer
12:21:44 <lambdabot>   -1
12:21:47 <ddarius> In 2's complement, one has the identity: -x = ~x + 1.  Solving for ~x gives you ~x = -x - 1.  So complement x = -x - 1 for an Integer.
12:21:59 <nand`> > fmap (chr . (+256) . complement . xor 57 . ord) "hello world"
12:22:01 <lambdabot>   "\174\163\170\170\169\230\177\169\180\170\162"
12:22:13 <Peaker> rostayob: I don't know, there was some README about how you might be able to fight them
12:22:21 <tommd> cmccann: https://github.com/TomMD/JuicyPixels-repa
12:22:25 <tommd> lispy: ^^^
12:22:42 <nand`> note that this is not very secure for two reasons
12:22:48 <Eduard_Munteanu> ddarius: eh, I guess that's what you get if you extend that solutions for reals + infinities by continuity :)
12:22:54 <rostayob> Peaker: mhm... ok
12:23:04 <tommd> lispy, cmccann: That's a very simple conversion from basically any JuicyPixel type into my own "Img" which is a Repa representation.
12:23:10 <Eduard_Munteanu> Erm, integers + infinities.
12:23:32 <nand`> 1. the complement adds no extra security since 2. since you're doing a 1-1 mapping of each source character to a destination character, it's no more secure than a simple replacement cipher
12:23:37 <Peaker> What's the source of the name "2's complement"?
12:23:46 <nand`> which can very easily be cracked by using statistical analysis and comparing it to english letter distribution
12:23:53 <kqr> nand`, yeah, i know, it's only there to serve as an example
12:23:59 <tommd> cmccann: I know lispy is working a new JuicyPixel that might be vector based - it should be easy to move to supporting that project instead.
12:24:00 <nand`> oh ok
12:24:03 <nand`> carry on
12:24:19 <kqr> in fact, it /is/ essentially a replacement cipher
12:24:30 <nand`> note: it's much more secure to zipwith (xor) using some same-length randomly generated list as key
12:24:43 <nand`> so secure, in fact, that it's impossible to crack as long as you use the key only once and it's truly randomly generated
12:25:00 <kqr> oh
12:25:07 <kqr> i haven't thought of that
12:25:09 <kqr> kind of interesting
12:25:11 <tschilling> Anyone here remember mtviewmark's other nick? (Mark Lentczner)
12:25:20 <nand`> kqr: https://en.wikipedia.org/wiki/One-time_pad
12:25:38 <kqr> thanks
12:27:05 <tschilling> preflex: seen mzero
12:27:05 <preflex>  mzero was last seen on #haskell 1 day, 15 hours, 13 minutes and 51 seconds ago, saying: :-) are we helping there, dustmote ?
12:27:23 <tschilling> (found it :) )
12:27:48 <Peaker> nand`: and the key actually remains a secret, too
12:27:58 <Eduard_Munteanu> Peaker: I guess this? http://en.wikipedia.org/wiki/Two%27s_complement#Two.27s-complement_numbers   I don't remember if that's the actual reason.
12:31:59 <Duffman> Eduard_Munteanu: is foldl and foldr on its own strict? I'm thinking yes ..
12:32:26 <Eduard_Munteanu> Duffman: no. Only foldl' is strict in the accumulator.
12:33:59 <Duffman> foldl f e (x:xs) = foldl f (f e x) xs
12:34:03 <Eduard_Munteanu> Well, it has a tad bit strictness in the sense it needs to pattern-match and see if it has (x:xs) or [], but that's all.
12:34:03 <nand`> > map chr $ zipWith (xor) (map ord "hello, world!") (cycle "password")
12:34:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:34:04 <lambdabot>         against inferred type ...
12:34:09 <Duffman> by the accumulator you mean "f e x"
12:34:21 <ddarius> foldr _|_ /= _|_, similarly for foldl, and foldl'.  None of them are strict.
12:34:37 <nand`> whoops
12:34:47 <nand`> > map chr $ zipWith (xor) (map ord "hello, world!") (map ord $ cycle "password")
12:34:47 <lambdabot>   "\CAN\EOT\US\US\CANCR\DC3\US\DC3\US\ETBV"
12:35:22 <cmccann> rostayob, SDL uses C preprocessor tricks on windows and OSX that do not work with haskell at all
12:35:35 <cmccann> rostayob, the easiest workaround is to use a C wrapper
12:35:44 <cmccann> and then call your haskell "main" from C via the FFI
12:36:00 <Eduard_Munteanu> @src foldl'  -- to compare
12:36:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:36:07 <Eduard_Munteanu> Bah.
12:36:33 <cmccann> rostayob, last time I messed around with this I had some horrible hacked makefile that would build the same application on linux, OSX, or windows using the wrapper and other tweaks as needed
12:37:05 <cmccann> it's ugly but not too difficult if you just need to build something
12:37:53 <wvoq> hello all, I'd like to ask: what are my options for enforcing semantically distinct types, short of creating a bunch of newtypes?  For example, phone numbers and social security numbers both have type [Int] but I'd like to be able to catch a substitution of a phone number for an ssn at compile time.
12:38:30 <wvoq> I asked this on r/haskell before, and the end of the discussion was "Haskell doesn't do subtyping, which seems to be what you're asking for. In principle, it's possible, but type inference in the presence of subtyping is a can of worms that nobody enjoys dealing with." --dmwit
12:38:31 <hpc> wvoq: tag types, perhaps
12:38:42 <cmccann> wvoq, tagging with phantom types?
12:38:49 <cmccann> which is basically still newtypes
12:38:54 <hpc> data SSN = SSN; data Phone = Phone; data Tagged a b = Tagged a b
12:38:58 <cmccann> but lets you work with them generically if you want
12:39:09 <hpc> wvoq: phone = Tagged Phone 123456789
12:39:45 <Saizan> you usually don't have an 'a' field
12:39:51 <cmccann> or just "newtype Tagged a b = Tagged b"
12:39:51 <wvoq> thanks all.  I tried to do due google diligence on this, but I didn't find the tagged package
12:40:09 <cmccann> wvoq, search for "phantom type"
12:40:22 <hpc> cmccann: ah, that's what i wanted to say
12:40:43 <wvoq> cmccann: already done, thanks
12:40:50 <hpc> you can also search for GADTs, which are more powerful
12:40:56 <Sgeo> How new is the LANGUAGE pragma? :/
12:43:15 <shachaf> I really wish newtypes were more convenient to work with, so that things like type SSN = type Phone = Int wouldn't happen.
12:43:34 <shachaf> Also -- why are you storing social security "numbers" and phone "numbers" as Ints? They're not actual numbers.
12:43:49 <jaredj_> wvoq said [Int]
12:43:56 <cmccann> shachaf, would "deriving Newtype" be enough to make it more convenient?
12:44:02 <hpc> ^
12:44:08 <shachaf> jaredj_: Right.
12:44:22 <shachaf> cmccann: I don't imagine it would.
12:44:28 <Sgeo> Why doesn't GHC have HereDocuments?
12:44:29 <cmccann> shachaf, http://hackage.haskell.org/package/newtype if you don't know what I mean
12:44:42 <jaredj_> although theoretically you could do better than four bytes to store a single decimal digit
12:44:53 <shachaf> Yes, I know about the package.
12:45:28 <cmccann> shachaf, what sort of convenience do you think is missing, then?
12:45:49 * cmccann has a few combinators based on Control.Newtype that help as well
12:46:14 <ddarius> http://en.wikipedia.org/wiki/Lion-Eating_Poet_in_the_Stone_Den
12:46:15 <wvoq> shachaf: I'm not, I just wanted to provide a reasonably intuitive example.  If there were a Digit type that I knew about, I would have used that instead.  String would also have worked, I guess, albeit with a different set of limitations.
12:46:39 * cmccann wonders if there's a digit type on hackage anywhere
12:47:00 <shachaf> wvoq: OK. :-) It's beside the point, I admit (and the point of the newtype is that you can fix it later).
12:47:01 <jaredj_> ^
12:47:02 <Sgeo> Control.Newtype?
12:47:22 <cmccann> http://hackage.haskell.org/package/Digit heh
12:47:23 <shachaf> cmccann: Surely digits are used in the implementation of finger trees. :-)
12:47:41 <cmccann> Sgeo, see the hackage link a few lines before that
12:48:21 <jaredj_> ddarius: !
12:49:34 <copumpkin> ddarius: hey hey :)
12:50:44 <jaredj_> aww shiiiii
12:51:09 <copumpkin> jaredj_: clay, is that you?
12:51:24 <jaredj_> buh
12:51:46 <jaredj_> who?
12:52:03 <jaredj_> "Try to explain this matter."
12:52:14 <copumpkin> http://www.youtube.com/watch?v=pUjh9Id6Id8
12:53:09 <jaredj_> copumpkin: lol. that's poetic
12:53:27 <Palmik> Hmm, I have seen a lot of Contructor { unSomething :: SomeType }, where did the convetion of unSomething come from?
12:54:01 <sipa> typically, it is data Bla = Bla { unBla :: a }
12:54:13 <sipa> so that Bla :: a -> Bla and unBla :: Bla -> a
12:54:57 <parcs`> unBlah undoes what Blah does
12:55:16 <Palmik> Yeah, it makes sense now, thanks. :)
12:55:18 <hpc> or more often, runBlah
12:55:24 <ddarius> copumpkin: License.
12:55:26 <hpc> see: MTL
12:56:20 <ddarius> hpc: runX is only done for monads.
12:56:52 <hpc> ddarius: and arrows
12:56:53 <cmccann> ddarius, pretty sure I've seen it used elsewhere
12:57:13 <hpc> the deconstructor for Endo is "appEndo"
12:58:52 <dibblego> I use runX in HXT (arrows)
12:58:53 <ddarius> :t (getSum, getProduct, getZipList)
12:58:54 <lambdabot>     Ambiguous occurrence `getSum'
12:58:54 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
12:58:55 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
13:03:43 <Lycurgus> is there a project, paper or something addressing Haskell readability?
13:04:34 <alistra> Lycurgus: hlint
13:04:48 <cmccann> Lycurgus, define "readability"
13:05:24 <Lycurgus> in the normal way cmccann , obviously it's not the same as linting
13:05:28 <ddarius> cmccann: That can be covered in the first of the series of research papers.
13:05:40 <ddarius> cmccann: Ah yes, the "normal" way.
13:05:49 <cmccann> Lycurgus, the "normal way" is "ill-defined and impossible to measure"
13:05:56 <cmccann> so in that case, no, nothing like that exists
13:05:59 <Lycurgus> just suddenly realized how ugly Haskell code is from a readability perspective
13:05:59 <cmccann> for any language
13:06:21 <alistra> i still don't know what he means
13:06:29 <copumpkin> Lycurgus: keep at it
13:06:43 <alistra> readability as in understanding the code?
13:07:09 <alistra> it kinda depends on the coder, not the language
13:07:09 <Sgeo> If you don't know Haskell, it could be hard to read Haskell?
13:07:15 <copumpkin> Lycurgus: can you point me at some haskell you wrote? you know, so we can give you pointers on readability
13:07:26 <alistra> or use hlint
13:07:31 <Sgeo> How hard/easy obfuscation is?
13:07:42 <Lycurgus> copumpkin, what explaining readability? What I'm referring to isn't based on how well you know Haskell although that's obviously a factor
13:08:17 <Lycurgus> also I'm partly speaking from Great Expectations that are probably unfounded
13:08:26 <cmccann> Lycurgus, I find Haskell in general to be significantly more readable than most other languages
13:08:31 <copumpkin> Lycurgus: how could you ever dissociate the reader's experience from how well (s)he can read the code?
13:08:52 <alistra> cmccann++
13:08:58 <Lycurgus> omg
13:09:01 <alistra> it totally is
13:09:09 <alistra> it's more succinct
13:09:15 <alistra> it's more succint
13:09:17 <cmccann> Lycurgus, which is why I'm asking what you mean by readability
13:09:24 <alistra> inct*
13:09:44 <Lycurgus> are you really asking me to explain readability to you? Are you a native speaker of English?
13:10:28 <Saizan> Lycurgus: no, he's asking you to explain in which ways you find haskell poor wrt readability
13:10:32 <Lycurgus> http://en.wikipedia.org/wiki/Readability
13:10:39 <cmccann> Lycurgus, I'm asking you to explain what you mean by it, because Haskell is very readable compared to most programming languages in my experience
13:11:02 <Lycurgus> yes, but I'm not talking about your experience
13:11:19 <Lycurgus> the languages that in fact have high readability, like say Smalltalk
13:11:32 <donri> fact?
13:11:34 --- mode: ChanServ set +q *!*@cpe-72-228-177-92.buffalo.res.rr.com
13:12:06 <cmccann> Lycurgus, do readability standards for natural language really apply to programming?
13:12:37 <cmccann> I mean, I'd expect most programming languages to be terrible by such metrics and I don't think it's obvious that we should expect otherwise
13:12:46 <dibblego> Lycurgus has been silenced; please resume the previous intelligent discourse
13:13:02 <cmccann> dibblego, that seems a bit excessive :T
13:13:08 <alem0lars> lol
13:13:14 <copumpkin> cmccann: the conversation was clearly going nowhere
13:13:18 <cmccann> I guess
13:13:21 <copumpkin> he was going to keep waving his hands and getting more and more people agitated
13:13:35 <copumpkin> with vacuous statements about how haskell was unreadable compared to some other language he could read better
13:13:36 <copumpkin> it wasn't useful
13:14:00 * cmccann shrugs
13:14:46 <fasta> Silencing Lycurgus seems like a very intolerant action.
13:14:47 <alem0lars> i think that he was getting started to haskell from other imperative languages and he would figure out why the coding styles are so different
13:15:08 <copumpkin> no, he's been around for ages
13:15:42 <alem0lars> ah ok
13:16:11 <alem0lars> i just joined the channel when the discussion was already started, sorry
13:17:35 <alistra> copumpkin: is pasting nsfw links relating current chat discussion on the channel is permitted?
13:17:45 <alistra> or whoever the op is and may ban me for it :P
13:18:00 <copumpkin> no
13:18:09 --- mode: ChanServ set -q *!*@cpe-72-228-177-92.buffalo.res.rr.com
13:18:22 <x_man> copumpkin: hi
13:18:29 <copumpkin> hi x_man
13:19:04 <alem0lars> x_man: hi
13:19:22 <x_man> i had bad internet connection, now i am back in the chanell but merijn is away :)
13:19:39 <x_man> hi alem0lars
13:20:52 <x_man> copumpkin he had willing to help me with understanding of the proof.
13:21:56 <parcs`> what is the resolution of threadDelay?
13:22:14 <copumpkin> x_man: the usual IRC etiquette is to just ask a channel, without putting a particular user on the spot, so there is less pressure on a single person. If a single person does want to help you, they'll answer your questions in the channel, and it lets them leave at some point so they don't have to commit too hard. So ideally, you'd just ask your question to the channel and people would answer (or not, which
13:22:14 <copumpkin>  would suggest that no single person would want to respond either)
13:22:17 <parcs`> seems to be about 1/800 of a second
13:23:34 <ddarius> Quick, copumpkin, I need a mechanized proof of the associativity of addition.
13:24:16 <copumpkin> lol
13:24:33 <cmccann> quick? thought it took like three hours for any of copumpkin's agda proofs to check
13:24:46 <byorgey> Theorem plus_assoc' : forall n m p : nat, n + (m + p) = (n + m) + p. Proof. intros n m p. induction n as [| n']. reflexivity. simpl. rewrite -> IHn'. reflexivity.  Qed.
13:25:04 <x_man> copumpkin: aha, then seems my question is to specific, because i have problem to follow step of the proof of theorem from book :)
13:25:38 <byorgey> x_man: why is that too specific?
13:26:37 <Philonous> Proof. intros. omega. Qed.
13:27:37 <x_man> byorgey: i am not sure whether will be someone here who read same book and same theorem in details...
13:27:41 <parcs`> i don't understand why threadDelay takes an input microseconds when its resolution is more than a millisecond
13:28:07 <byorgey> x_man: well, there's no way to know unless you ask!
13:29:02 <byorgey> Philonous: yes, well, I copied mine from the solution to an introductory exercise... =)
13:30:03 <drdo> What can i do if some library function wants an IO but i need to pass it some other monad that is an instance of MonadIO ?
13:30:18 <cmccann> drdo, not much besides the obvious
13:31:16 <drdo> What would the obvious be?
13:31:31 <cmccann> unwrapping the other monad to get at the underlying IO
13:31:39 <drdo> meh
13:31:43 <cmccann> yeah
13:32:03 <Philonous> byorgey:  I was joking, of course one should do them by hand first.
13:33:21 <cmccann> drdo, there probably isn't anything else you can do in the general case though
13:33:29 <cmccann> drdo, depending on the specifics you might have other options
13:34:07 <ddarius> Why are there so many research papers?
13:34:45 <drdo> Is there any special reason why one would require IO specifically and not just accept any MonadIO?
13:35:10 <Philonous> byorgey:  Btw. "software foundations" is awesome. Quite literally. I've been thoroughly enjoying it for weeks now. It's incredible that it is free. Thanks!
13:35:35 <cmccann> drdo, if you're forking threads then IO specifically probably makes sense
13:36:01 <drdo> I'm just trying to use postegresql-simple
13:36:31 <cmccann> anything used as a callback with an FFI library might be stuck with IO as well
13:36:51 <byorgey> Philonous: oh, great! You're welcome!  (And yes, of course that's where I copied my proof from =)
13:37:02 <drdo> I want to use forEach but i want to use CGIT IO instead of IO
13:37:50 <The_Journey> hi, how can I reinstall a library and all of its dependencies with profiling support?
13:38:10 <drdo> I don't mind using any other postgre library? Is there one i should look at?
13:38:58 <alistra> The_Journey: i know how to do it on gentoo, are you interested :D?
13:39:01 <parcs`> drdo: use liftIO to lift an IO computation into another monad
13:39:04 <cmccann> drdo, beats me. doesn't look like there's anything that requires only IO in that function
13:39:08 <cmccann> parcs`, that won't work
13:39:14 <The_Journey> alistra: yes please
13:39:14 <drdo> parcs`: can't do that
13:39:24 <cmccann> parcs`, he needs lifting in contravariant position
13:39:24 <drdo> I need the other way around :P
13:39:30 <cmccann> whatever you'd call that
13:39:40 <cmccann> which doesn't make sense in general, obviously
13:39:41 <Saizan> the usual culprits are exceptions
13:39:50 <Saizan> (handlers)
13:40:02 <ddarius> runCGIT
13:40:27 <parcs`> ah..
13:41:48 <ddarius> @google site:hackage.haskell.org promela
13:41:50 <lambdabot> http://hackage.haskell.org/packages/archive/pandoc/1.8.2.1/doc/html/src/Text-Pandoc-Writers-LaTeX.html
13:41:50 <lambdabot> Title: src/Text/Pandoc/Writers/LaTeX.hs
13:41:50 <cmccann> drdo, anyway, just unwrapping the CGIT stuff is probably the best you can do
13:42:12 <parcs`> i wonder why postgresql-simple isn't lifting its IO anyway
13:42:47 <alistra> The_Journey: USE=profile emerge -1 libnames :D
13:42:48 <parcs`> it doesn't seem to be doing anything more intricate than throwing an exception once in a while
13:43:01 <cmccann> parcs`, a lot of libraries just don't bother
13:43:05 <alistra> The_Journey: better: add it to package.use :P
13:43:13 <The_Journey> alistra: thank you
13:43:13 * ddarius <3 cache-oblivious data structures.
13:43:25 <parcs`> cmccann: they should :P
13:43:25 <alistra> */*::gentoo-haskell profile
13:43:30 <alistra> The_Journey: */*::gentoo-haskell profile
13:43:33 <parcs`> especially when it uses callbacks
13:43:33 <cmccann> parcs`, never claimed otherwise :]
13:43:45 <alistra> The_Journey: if you're using the gentoo-haskell overlay
13:44:32 <The_Journey> alistra: shouldn't cabal be used instead of emerge?
13:45:19 <alistra> The_Journey: nope, you can get a pretty big shitstorm of dependencies with cabal, it's safer to use emerge :P
13:45:37 <The_Journey> alistra: oh ok, thank you
13:45:39 <alistra> but if you already have cabal-installed it's better not to mix them
13:45:52 <alistra> it's even a bigger shitstorm
13:46:00 <The_Journey> :(
13:46:33 <cmccann> mixing cabal-install with other ways of installing things is pretty much the worst thing you can do last I checked
13:48:34 <alistra> yup
13:49:02 <alistra> it has a high probability of ghc reinstall with all the packets
13:53:23 <Philonous> byorgey:  I was just wondering which parts where written by whom, because the style is rather inconsistent (I noticed some haskellisms like (x :: xs) for lists). Not that it matters, though
13:53:59 <byorgey> Philonous: at this point it is pretty much impossible to disentangle which parts were written by whom.
13:54:14 <Philonous> Yeah, that's what I though
13:54:17 <ddarius> x::xs isn't a "Haskellism."
13:54:19 <byorgey> Philonous: if you notice anything where the style is inconsistent in a confusing way, let me know
13:55:33 <Philonous> ddarius:  Well, it doesn't seem to be the idiomatic choice of variable names in coq.
13:55:46 <ddarius> @google COSB-tree
13:55:47 <znutar_> that's ML-ish
13:55:48 <lambdabot> http://publications.csail.mit.edu/abstracts/abstracts06/bradley5/bradley5.html
13:55:48 <lambdabot> Title: MIT CSAIL Research Abstracts
13:56:30 <Philonous> fair enough
14:08:24 <Sgeo> nested where clauses will do what I think they should do, right?
14:10:10 <mike-burns> If you think they will be hard to read then yes, they will do that.
14:11:35 <Sgeo> ??
14:12:58 <azaq23> > let { a = let w = p where p = z + 2 in w } where z = 1
14:12:59 <lambdabot>   <no location info>: parse error on input `where'
14:13:46 <byorgey> Sgeo: it depends on what you think they should do.  But probably the short answer is yes.  But probably the longer answer is "you should consider refactoring your code so you don't need nested where clauses".
14:13:54 * BMeph likes checking out mgsloan's "bottom" - but not in a gay way. ;)
14:15:23 <azaq23> > let { a = (let p = w where w = 5 + z in p) where z = 4 } in a
14:15:24 <lambdabot>   9
14:15:57 <kejoki> trying to write a unix-style command line filter.  running into IO Handle vs. Handle trying to pass handles around.  IO is eatin' my lunch -- where can I read about unboxing t
14:16:08 <Sgeo> Why is lookup's argument order what it is?
14:17:31 <BMeph> Sgeo: Presumably, because it's more convenient than the other way. :)
14:17:49 <jmcarthur> :t lookup
14:17:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:18:08 <byorgey> kejoki: your message seems to have gotten cut off after "read about unboxing t"
14:18:19 <jmcarthur> Sgeo: it allows you to do things like this:      lookup "foo" . generateListFromArg
14:18:41 <BMeph> Yeah, I suppose I should have said "than an other way," but I felt like being less general.
14:18:42 <kejoki> it was cut off by catlike typing and a phone call from a wayward child.
14:18:54 <Rotaerk_> if its arguments were reversed, it would warrant a different name
14:18:59 <Rotaerk_> such as lookupIn
14:19:04 <ronan> Hello everybody my name is Ronan it is my first time with Haskell
14:19:13 <phyrephox> hi
14:19:20 <hunz_brazil> hello ronan
14:19:30 <phyrephox> i tried to install the http-server package using cabal install
14:19:33 <byorgey> kejoki: that is the most poetic reason for a truncated message I have heard in a long time.
14:19:35 <phyrephox> but it fails to compile and i'm not sure what to do
14:19:40 <kejoki> about unboxing these boxed up Monad things so I can pass stdin and or an open file handle.
14:19:47 <phyrephox> could anyone help me?
14:20:01 <BMeph> phyrephox: Run it as an Administrator.
14:20:08 <kejoki> byorgey: ;)
14:20:12 <ronan> sorry my english is not good
14:20:20 <jmcarthur> kejoki: there is no Handle in an IO Handle
14:20:37 <byorgey> kejoki: try reading http://www.haskell.org/haskellwiki/Introduction_to_IO
14:20:43 <parcs`> Sgeo: why not?
14:20:48 <ronan> I'm Brazilian
14:21:10 * BMeph agrees with monochrom, and wants an easy way to get the "IO" out of an "IO String". ;)
14:21:10 <Rotaerk_> names of functions should be chosen such that name plus the first argument can be understood in english as a verb and direct object, and all the other parameters just provide further specification
14:21:26 <Rotaerk_> at least that's what makes sense to me
14:21:28 <kejoki> byorgey: tx.  jmacarthur: of course there isn't.  <sigh />
14:21:28 <byorgey> kejoki: monads are not boxed up things.  I advise you to forget that idea as quickly as possible.
14:21:32 <Sgeo> parcs`, because Map a b is conceptually a function a -> Maybe b, I thought
14:21:52 <jmcarthur> kejoki: and IO Handle is just an action that you can execute. when executed by using it as the first argument to (>>=), the second argument is passed a handle
14:22:05 <copumpkin> Sgeo: omg Map a b = Kleisli Maybe a b
14:22:19 <BMeph> Rotaerk_: Ah, so you "get it", that's good. :)
14:22:23 <ronan> I come from Python
14:22:23 <ronan> I am willing to learn a functional language Haskell chose
14:22:23 <ronan> Do you have a good indrodução?
14:22:23 <jmcarthur> kejoki: in other words...   myIOHandle >>= \handle -> useTheHandle handle
14:22:40 <phyrephox> BMeph: I still get the error
14:22:55 <mgsloan> BMeph: haha, random! My blog is "Rock _|_" - definitely need to update more
14:22:56 <Sgeo> ronan, http://learnyouahaskell.com/ is pretty well-liked
14:22:59 <merijn> ronan: Learn You a Haskell is great
14:23:03 <parcs`> Map a b is also conceptually a -> [(a, b)] -> Maybe b
14:23:05 <phyrephox> here's the error i'm getting: https://gist.github.com/1613294
14:23:38 <BMeph> mgsloan: Definitely; I'm interested, if you're doing more "fun tricks" with AST visualization. :)
14:24:17 <mgsloan> yup, working on a type visualizer
14:24:23 <mgsloan> but gtg unfortunately!
14:24:29 <ronan> good
14:25:25 <kejoki> so ... if I want to use stdin OR an (openFile mypath ReadMode) I need to turn it into an action on stdin and pass that?
14:25:31 <ronan> I'll read a bit if you have any questions I'll be back
14:25:42 <BMeph> phyrephox: Thank you; I was wondering how anyone would be expected to help if they knew no more than that you needed some. :)
14:26:22 <Sgeo> I am sorely tempted to make lenses that look like (HasAvatarname s) => Lens s String
14:26:27 <Sgeo> etc.
14:26:34 <Peaker> phyrephox: What's the type of socketConnection?
14:27:02 <ddarius> copumpkin: Now define Kleisli composition, join, etc. on Maps.
14:27:07 <Peaker> phyrephox: this one: http://hackage.haskell.org/packages/archive/HTTP/latest/doc/html/Network-TCP.html#v:socketConnection ?
14:27:52 <Peaker> phyrephox: You seem to miss a port argument there
14:28:06 <parcs`> Sgeo: never mind, i made no sense. i think lookup is the way it is because the partially applied "lookup foo" does what it sounds like
14:28:32 <Sgeo> Is there a special name for flip lookup?
14:28:48 <phyrephox> Peaker: i think so... i didn't write this package though
14:29:11 <Sgeo> Is it a bad idea to have code write instances for me like instance HasAvatarName Bleh where
14:29:16 <Sgeo> And then have that show a lens?
14:29:21 <Sgeo> For a while lot of HasWhatevers?
14:30:38 <Peaker> phyrephox: what package is it?
14:30:47 <phyrephox> Peaker: http-server
14:30:53 <Peaker> phyrephox: I'll try building it..
14:30:58 <phyrephox> Peaker: thanks!
14:31:14 * kejoki may be too old a dog for this
14:32:15 <Peaker> phyrephox: interesting, it fails to install "text" because it seems to depend on "integer" which is not in hackage's lists
14:32:18 <BMeph> kejoki: What, for your cat? ;)
14:33:45 <phyrephox> Peaker: i think maybe i'll email the maintainer and see if he has any insight
14:34:35 <Peaker> oh! I know why it's failing.. it's the custom cabal-install I installed that ignores upper constraints :)
14:34:38 <Peaker> oops it breaks it! :)
14:34:43 <Peaker> phyrephox: ok I know how to fix it
14:35:18 <byorgey> kejoki: nonsense.
14:35:32 <byorgey> kejoki: but no one said it is supposed to be easy.
14:35:54 <kejoki> BMeph : no, the Schroedinger's non-box that is a monad.
14:36:03 <byorgey> kejoki: that feeling of confusion is the feeling of your brain expanding.
14:36:37 <Sgeo> How bad an idea am I approaching?
14:36:39 <kejoki> maybe, byorgery.  or senility.
14:37:22 <Peaker> kejoki: I missed your question the first time... you need to do something like:  handle <- if x then return stdin else openFile mypath ReadMode
14:37:49 <Peaker> kejoki: you do need to lift "stdin" into action form via "return" in order for it to match the type of "openFile"
14:37:59 <phyrephox> Peaker: oh yeah?
14:37:59 <Peaker> (of the result of openFile that is)
14:38:03 <kejoki> BANG!
14:38:16 <kejoki> that's what I'm missing.  return.
14:38:38 <kejoki> Peaker: tx!  that was what I needed.  yesssss.
14:38:39 <Peaker> phyrephox: well, I really really hate the conservative upper version constraints on hackage pages :)
14:39:14 <phyrephox> Peaker: sorry, i don't understand!
14:39:19 <kejoki> tx all.  I go now to save the world with functional programming!
14:40:38 <nexion> if I have a custom data type that contains something that isn't showable, is it possible to make my type still showable and fill the non-showable component with some static string?
14:40:44 <Peaker> phyrephox: I made a custom Cabal where upper version constraints are ignored
14:40:48 <Peaker> phyrephox: and this breaks various "if ghc >= .." checks
14:40:53 <Peaker> phyrephox: and gives wrongs cabal flags
14:40:58 * BMeph hates that upper version constraints have appeared, at a time when upper version limits seem less likely to be an issue (i.e., when no one wants to "break" old stuff by improving the language in game-changing ways)...
14:41:30 <phyrephox> Peaker: ahh, i see :)
14:41:42 <Peaker> ok, now installing http-server :)
14:42:12 <BMeph> nexion: Yes. It's called "write your own Show instance." :)
14:42:15 <Peaker> phyrephox: http-server built ok here.. hmm
14:42:27 <Peaker> phyrephox: did you "cabal update" ?
14:42:36 <Peaker> phyrephox: what ghc version are you using?
14:43:18 <nexion> instance Show TVar where show _ = "some TVar" ?
14:43:33 <ronan> porque eu tenho que colocar let ao definir uma variavel no gchi
14:43:50 <phyrephox> Peaker: i'm thinking maybe its because i'm using an old version of GHC... 6.12.1
14:44:26 <phyrephox> that's probly definitely it :(
14:44:49 <ronan> because I have to let the place to set a variable in gchi
14:45:22 <Peaker> phyrephox: People don't tend to maintain their packages for older ghc's.. is it a big deal for you to install the platform's ghc? That's the safest bet, probably
14:46:14 <phyrephox> Peaker: nope! should i uninstall my package manager's version of ghc first?
14:46:28 * ddarius is pretty sure the game would still be writing programs no matter how much they changed Haskell.
14:46:33 <Sgeo> @hoogle (Eq a) => [[a]] -> [[a]]
14:46:36 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
14:46:36 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
14:46:36 <lambdabot> Prelude concat :: [[a]] -> [a]
14:46:39 <Sgeo> Wow, not so helpful
14:46:52 <nexion> a variant of the above appears to have worked; thanks BMeph
14:47:18 <Peaker> Sgeo: What do you want it to do?
14:47:54 <Peaker> phyrephox: I prefer to, but some say it is unnecessary
14:48:05 <Peaker> phyrephox: it's possible to have multiple versions of ghc installed
14:48:08 <Hannspree> How do you ask a girl out?
14:48:16 <Sgeo> From a list of list of strings, find the largest groupings such that no item in the grouping appears without the other members of its group
14:48:24 <Peaker> phyrephox: But I think that's a recipe for confusion
14:48:32 <ddarius> It's not even difficult to have multiple versions of GHC installed.
14:48:49 <dgpratt> Sgeo: so did I send you on a wild goose chase or not?
14:48:53 <shachaf> In my experience, it's difficult *not* to have multiple versions of GHC installed.
14:48:54 <Duffman> :k T
14:48:55 <lambdabot> *
14:49:01 <Peaker> shachaf: why?
14:49:02 <Sgeo> dgpratt, erm, with what?
14:49:09 <BMeph> nexion: Happy it "helped"... :)
14:49:21 <shachaf> Peaker: Somehow I always end up with extra version I don't want.
14:49:36 <phyrephox> Peaker: thanks for all your help, i'll let you know how it goes!
14:49:39 <dgpratt> Sgeo: the generic deriving stuff; was it what you were after?
14:50:09 <Sgeo> I don't remember what that was about, but pretty sure I .. wasn't going to use it? I don't remember
14:50:43 <peterjoel1> Hi, I'm having difficulties installing / uninstalling on osx. Is it ok to ask about that sort of thing here?
14:50:48 <Sgeo> Oh, that
14:50:55 <nexion> BMeph, surprisingly, it did.. I haven't written instances before and wasn't sure I could do so for types that aren't mine :)
14:50:57 <Sgeo> It was more of a general curiosity
14:51:10 <dgpratt> Sgeo: ah
14:51:22 <shachaf> peterjoel1: Assuming it's Haskell-related, it's usually OK. In general you should just ask your question, and in the worst case someone will tell you to ask it somewhere else.
14:51:51 <peterjoel1> ok... I originally installed HP 32bit by mistake (though it worked fine), and later tried to install 64 bit. It didn't install correctly, failed with: "The installer encountered an error that caused the installation to fail. Contact the software manufacturer for assistance".
14:52:22 <dgpratt> heh; who would that be? SPJ?
14:52:24 <peterjoel1> also, ghc - - version now reports 6.10.4, while it was previously 7.0.4
14:52:30 <Philonous> I wonder whether it makes sense to reason about monads with Hoare-Floyd Logic. For example forall P : {P} return {P} intuitively makes sense.
14:52:49 <peterjoel1> so I'm trying to uninstall to start again, but I don't know how
14:56:24 <peterjoel1> according to this:  http://www.haskell.org/haskellwiki/Mac_OS_X:
14:56:34 <peterjoel1> "To uninstall ghc call: sudo /Library/Frameworks/GHC.framework/Tools/Uninstaller"
14:56:45 <peterjoel1> but that directory doesn't exist
14:56:54 <geekosaur> probably didn;t reach that part of the install
14:57:04 <peterjoel1> ok, but it was previously installed
14:57:08 <Hannspree> How do you ask a girl out?
14:57:26 <Rotaerk_> "Do you want to go out?"
14:58:04 <geekosaur> sudo rm -r /Library/Frameworks/GHC.framework /Library/Haskell /private/var/db/receipts/org.haskell.*
14:59:30 <peterjoel1> thanks, I'm just going to trust you and try it blindly
14:59:58 <ddarius> Philonous: Of course it makes sense.
15:00:46 <Hannspree> How do you ask a girl out?
15:01:02 <ddarius> @where ops
15:01:02 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:01:15 <Philonous> ddarius:  I should have typed my question into google rather than IRC. Got me the answer in a fraction of a second.
15:01:25 <ddarius> Philonous: Indeed.
15:01:28 <Sgeo> :/ lines etc. use explicit recursion
15:01:28 <Cale> Hannspree: I'll ask you to stay on topic here if you would.
15:01:56 <Cale> Hannspree: This channel is primarily for discussion of the programming language Haskell and related topics.
15:01:57 <peterjoel1> geekosaur: thanks, that did the trick, it installed first time after that
15:02:33 <peterjoel1> to be fair, haskell programmers are probably amongst the group most in need of dating tips ;)
15:03:09 <b0fh_ua> Hi all! Can somebody please suggest how to do replacement of regex string in PCRE?
15:03:50 <Hannspree> How do you ask a girl out?
15:03:51 <Hannspree> How do you ask a girl out?
15:03:51 <Hannspree> How do you ask a girl out?
15:03:51 <Hannspree> How do you ask a girl out?
15:03:51 <Hannspree> How do you ask a girl out?
15:03:52 <Hannspree> How do you ask a girl out?
15:03:52 <Hannspree> How do you ask a girl out?
15:03:54 <Hannspree> How do you ask a girl out?
15:03:56 <Hannspree> How do you ask a girl out?
15:03:57 <Cale> Okay
15:03:58 <Hannspree> How do you ask a girl out?
15:04:00 <geekosaur> @where ops
15:04:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:04:00 <Hannspree> How do you ask a girl out?
15:04:00 --- mode: ChanServ set +o Cale
15:04:02 <Hannspree> How do you ask a girl out?
15:04:04 --- mode: Cale set +b *!*@c-66-30-168-93.hsd1.ma.comcast.net
15:04:04 --- kick: Hannspree was kicked by Cale (Hannspree)
15:04:09 --- mode: Cale set -o Cale
15:04:11 <Phlogistique> b0fh_ua: you have to implement it yourself
15:04:17 <peterjoel1> how do you ignore a person on this channel?
15:04:35 <Cale> peterjoel1: You use the /ignore command in your IRC client
15:04:49 <Cale> peterjoel1: but in this case, I just banned him. :P
15:04:57 <peterjoel1> ah ok :)
15:04:58 <copumpkin> powercale
15:05:20 <ddarius> Now in gun flavor
15:05:56 <b0fh_ua> Phlogistique: wow, so no other options?
15:06:24 <peterjoel1> geekosaur: Actually I'm not sure what has happened. The installation apparently was successful, but ghc - -version is still 6.10.4
15:06:46 <geekosaur> 6.10.4 makes me think you have it installed via macports or something
15:06:53 <Phlogistique> b0fh_ua: afair yes
15:07:01 <geekosaur> "type ghc" will probably return something like /opt/local/bin/ghc or /sw/bin/ghc
15:07:07 <b0fh_ua> Phlogistique: may be with other implementation of regex?
15:07:15 <geekosaur> the HP package installs /usr/bin/ghc
15:07:18 <b0fh_ua> I can't believe that there is PCRE without replacing.
15:07:22 <Phlogistique> b0fh_ua: what do you want to do?
15:07:38 <peterjoel1> $ type ghc
15:07:38 <peterjoel1> ghc is hashed (/opt/local/bin/ghc)
15:07:52 <geekosaur> there you go.  sudo port uninstall ghc
15:08:13 <geekosaur> then "hash -r"
15:08:21 <Phlogistique> b0fh_ua: it's not very hard to write your own replacing code for your use; except if your use is quick&dirty scripting. if you want to do quick&dirty scripting, use perl or ruby (imho
15:09:08 <peterjoel1> failed to uninstall (please uninstall the ports that depend on ghc first). So I assume this is where my problem started?
15:09:19 <Feuerbach> Why does this require UndecidableInstances? http://hpaste.org/56460 Doesn't relation x -> y follow from the constraint?
15:09:52 <geekosaur> no, ghc never considers class constraints when selecting an instance
15:10:23 <Feuerbach> geekosaur: but this is not about selecting an instance, as I understand
15:11:03 <geekosaur> oh, urgh, coverage condition
15:11:12 * geekosaur knows it's there but not implications thereof...
15:11:27 <geekosaur> (well, I sort of know them but am not good with that part ofg the type system)
15:12:36 <ddarius> It's essentially the same situation anyway.
15:13:21 <Sgeo> The more I think about it, the more I think that abusing typeclasses is the best solution
15:13:24 <Sgeo> :/
15:14:14 <Feuerbach> ddarius: ok, but how to solve it?
15:14:27 <ddarius> Enable undecidable instances.
15:14:34 <Feuerbach> :)
15:14:40 <Feuerbach> fair enough
15:16:01 <geekosaur> Feuerbach, IIRC the overage condition is a somewhat overbearing but necessary constraint on types to insure that the typechevcker can't get into an infinite loop or something.  If that condition fails, it doesn't even try
15:16:17 <geekosaur> but it's a bit more restrictive than is useful, hence undecideableinstances
15:16:54 <geekosaur> (undecidable instances == don't stick to a guaranteed safe subset of possible types that cann't cause the typechecker to diverge)
15:18:46 <peterjoel1> I think my problem is that I've installed gtk2hs with macports, as it's not available through cabal. But that's meant macports wants to install ghc, as it can't find the one I've installed separately
15:19:13 <geekosaur> it's in cabal, just not as a single metapackage like that (cabal doesn;t understand the concept of metapackages)
15:19:26 <peterjoel1> oh
15:19:38 <peterjoel1> so.. how do I install it?
15:20:07 <peterjoel1> or I don't have to maybe?
15:20:39 <geekosaur> packages:  gtk2hs-buildtools, then glib gio pango cairo gtk soegtk
15:22:14 <geekosaur> http://projects.haskell.org/gtk2hs/download/ more details as to the available individual cabal packages
15:22:46 <peterjoel1> ok thanks
15:31:28 <dolio> You know the, "expressions can be replaced by their values," definition of referential transparency is surprisingly bad.
15:31:42 <Sgeo> If I want records of the sort I see in various extensible records proposals, is HList my best bet for now?
15:31:47 <ddarius> dolio: Correct.
15:32:15 <mikeplus64> what's the "best" way to update installed (cabal) packages?
15:32:31 <dolio> Sgeo: I think that's about your only option aside from using Trex with Hugs.
15:32:58 <ddarius> Or any of the other libraries that present an extensible record interface.
15:33:13 <Sgeo> dolio, if I make a library that uses HList like that, how inconvenient will it be for users of the library?
15:33:26 <Sgeo> What other libraries present an extensible record interface?
15:33:27 <dolio> No idea. I'm not a huge fan of HList, though.
15:33:27 <ronan> I back using emacs ERC
15:33:42 <ddarius> @hackage records
15:33:42 <lambdabot> http://hackage.haskell.org/package/records
15:33:44 <dolio> I don't have a lot of experience with it, though.
15:33:56 <dolio> Is that one better?
15:34:17 <Sgeo> ddarius, build failure on 7.2 o.O
15:34:59 <dolio> I guess type families are at least somewhat better suited to the hackery going on.
15:35:32 <Sgeo> But if it doesn't work on newer GHC...
15:36:04 <dolio> The error has to do with base >=3.0 && < 4.4 not being available, which doesn't make much sense.
15:36:11 <dolio> See if it installs for you.
15:36:27 <gienah> Sgeo ddarius: the records base dep can be relaxed, then it builds: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/records/records-0.1.1.5.ebuild
15:36:55 <ddarius> gienah: I don't know why you're telling me.
15:37:10 <Sgeo> gienah, someone should tell Wolfgang
15:38:58 <tommd> What is the best way to cache data for a set amount of time potentially across program runs?
15:39:10 <tommd> Persistent?
15:47:53 <dgpratt> tommd: acid-state would seem to be a fairly attractive option
15:48:58 <dgpratt> tommd: to be clear, I've never had the opportunity to use it, but I find the concept quite appealing
15:52:50 <wavewave> hi, what is that package that defines (.).(.)?
15:54:05 <wavewave> I mean that is there some standard package which defines owl op so that I don't need to define it again?
15:55:27 <wavewave> :t (.).(.)
15:55:28 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:56:32 <dgpratt> wavewave: I wonder if that isn't the "Caleskill" definition
15:57:25 <cmccann> :t (Prelulde..)Prelude..(Prelude..)
15:57:26 <lambdabot> Couldn't find qualified module.
15:57:33 <geekosaur> (.).(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:57:33 <cmccann> :t (Prelude..)Prelude..(Prelude..)
15:57:34 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:58:02 <geekosaur> @hoogle (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:58:03 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
15:58:04 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
15:58:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:58:37 <cmccann> I think (.:) is the most popular name for that combinator
15:58:41 <cmccann> I don't really care for it
15:58:45 <cmccann> but there's nothing better I know of
15:59:05 <shachaf> Clearly the solution is `` supporting arbitrary expressions.
15:59:35 <cmccann> shachaf, yes then we could all write `fmap fmap fmap` like we secretly want
16:00:04 <k0001> cmccann, wavewave: I'm curious. ¿Could you point me to an example where I can see the usage of those combinators?
16:00:20 <cmccann> k0001, what, the (.).(.) stuff?
16:00:33 <k0001> cmccann: sure.
16:00:36 <cmccann> k0001, you know what (.) does, right?
16:00:43 <k0001> cmccann: yes.
16:00:48 <dibblego> @type (.:)
16:00:49 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:01:08 <cmccann> k0001, ok, this is the same idea except it works with a 2-argument function
16:01:19 <wavewave> ahh.. just come back from the restroom
16:01:21 <cmccann> @type not .: (&&)
16:01:22 <lambdabot> Bool -> Bool -> Bool
16:01:39 <cmccann> would let you write NAND for example
16:02:28 <k0001> cmccann: oh, now I see. Thank you.
16:02:33 <Sgeo> How do we still not have Scoped Labels?
16:02:37 <Sgeo> Or something similar?
16:02:56 <cmccann> Sgeo, what, you mean something related to the endlessly dissatisfying record syntax situation?
16:03:03 <Sgeo> YES
16:03:13 <mike-burns> We don't have that because no one has fixed it yet.
16:03:18 <mike-burns> Can you fix it?
16:03:23 <ocharles> k0001: http://conal.net/blog/posts/semantic-editor-combinators
16:03:28 <geekosaur> there's yet another go-round of that endless thread on -cafe currently
16:03:29 <ocharles> may also be interesting to you
16:03:42 <wavewave> ocharles : yes I just found it.
16:03:49 <Sgeo> geekosaur, linky?
16:03:55 <geekosaur> (I think it's on -cafe...)
16:04:09 <mike-burns> I haven't seen it on -cafe this week.
16:04:15 <wavewave> TypeCompose may have related things...
16:04:28 * wavewave is looking at TypeCompose things more. 
16:04:37 <Philippa> I'd kinda like to see a complete "add a new GHC extension including syntax" walkthrough one of these days - I know the usual approach to such things is "if you need to ask you probably shouldn't be doing it", but lowering the overhead'd get more people having a go too
16:04:39 <geekosaur> oh, it's on ghc-users
16:05:01 <Philippa> (I never did take a proper look at the plugins framework, but I'm guessing it's not sufficient for new syntax?)
16:05:20 * geekosaur digging for link to latest...
16:05:53 * cmccann occasionally gets tempted to say screw syntax and take the McBride solution instead
16:06:50 <copumpkin> @tell lycurgus sorry about that
16:06:51 <lambdabot> Consider it noted.
16:06:56 <k0001> ocharles: Thank you, I'm reading it now.
16:10:11 <geekosaur> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-January/021422.html I think is the root of the rather long thread
16:13:52 <Sgeo> http://chrisdone.com/posts/2010-11-22-duck-typing-in-haskell.html
16:14:00 <Sgeo> This might be exactly what I actually want
16:14:08 <Sgeo> Are there any particular problems with this?
16:16:34 <stepcut> what is a good way to block forever? I have some code and I want to forkIO a bunch of threads, and then just block forever so the app doesn't exit..
16:17:21 <Peaker> Sgeo: what's the point of it? I see type-classes as a more useful/simple form of duck-typing
16:17:36 <dschoepe> stepcut: forever (threadDelay <big-number>) comes to mind.
16:17:43 <Peaker> stepcut: forever (threadDelay maxBound) -- specifically
16:18:20 <stepcut> :-/
16:18:28 <peterjoel1> readLine "press Enter to exit" ?
16:19:27 <Sgeo> :t readLine
16:19:28 <lambdabot> Not in scope: `readLine'
16:19:30 <DanBurton> "so the app doesn't exit"...how is doing nothing via blocking any better than doing nothing via exiting?
16:19:33 <Sgeo> @hoogle readLine
16:19:34 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
16:19:34 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
16:19:34 <lambdabot> package readline
16:19:52 <stepcut> DanBurton: because there are forkIO'd threads still running..
16:20:13 <DanBurton> stepcut: can't you just wait on them then?
16:20:37 <stepcut> DanBurton: wait how? via an MVar?
16:21:25 <DanBurton> hrm...doesn't Haskell have some sort of "join" operation?
16:21:43 <DanBurton> thread join, obviously
16:21:47 <stepcut> not that I have seen..
16:21:49 <DanBurton> not referring to monadic join
16:22:03 <dschoepe> there's a wait here: http://hackage.haskell.org/packages/archive/threads/0.4.0.1/doc/html/Control-Concurrent-Thread-Group.html
16:22:03 <stepcut> I usually see some trick involving MVars
16:22:24 <geekosaur> haskell doesn't use posix threads (at least, not in its programmer-visible thread API)
16:22:43 <DanBurton> hrm see also: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#g:12
16:24:04 <stepcut> yeah, that is the mvar thing I mentioned
16:24:24 <stepcut> anyway, I only have two things I am forking here. I can just fork one of them and not the other
16:24:58 <parcs`> stepcut: foerver yield ?
16:25:19 <parcs`> that's probably a busy operation
16:25:46 <parcs`> yep, it is. never mind
16:26:49 <DanBurton> that thread group library looks nice, assuming it works :)
16:30:08 <Peaker> background action = do { m <- newEmptyMVar ; forkIO (try action >>= putMVar m) ; return (takeMVar m) }
16:30:13 <Peaker> now you've got joinable threads
16:30:49 <Peaker> getResult <- background doStuff ; ... now getResult is the "join" of the thread
16:31:27 <shachaf> Peaker: Control.Concurrent.Spawn will do that for you.
16:32:30 <Peaker> shachaf: nice little package :)
16:35:38 <Cody__> > :t [tail, init, reverse]
16:35:38 <lambdabot>   <no location info>: parse error on input `:'
16:36:07 <DanBurton> :t [tail, init, reverse]
16:36:08 <lambdabot> forall a. [[a] -> [a]]
16:36:35 <DanBurton> the > symbol means "evaluate" to lambdabot
16:36:48 <DanBurton> iinm
16:36:56 <Cody__> Thanks.
16:37:22 <Cody__> :t [(True, 'a'), (False, '1')]
16:37:23 <lambdabot> [(Bool, Char)]
16:38:59 <Cody__> If you have a pair of tuples inside a list, can you change the types between tuples?
16:39:18 <Cody__> :t [(False, '1'), (1, "c")]
16:39:19 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
16:39:19 <lambdabot>       Expected type: (Bool, Char)
16:39:19 <lambdabot>       Inferred type: (Bool, [Char])
16:39:42 <Cody__> :t [(False, '1'), (1, 'c')]
16:39:42 <lambdabot>     No instance for (Num Bool)
16:39:43 <lambdabot>       arising from the literal `1' at <interactive>:1:16
16:39:43 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
16:39:50 <Cody__> :t [(False, '1'), (not, 'c')]
16:39:51 <lambdabot>     Couldn't match expected type `Bool'
16:39:51 <lambdabot>            against inferred type `Bool -> Bool'
16:39:51 <lambdabot>       Expected type: (Bool, Char)
16:39:53 <mokus> nope, all the tuples have to have the same types in the same order
16:40:26 <mokus> :t [(False, 1), (True, 42)] -- is ok, for example
16:40:27 <lambdabot> forall t. (Num t) => [(Bool, t)]
16:41:00 <Cody__> mokus: thanks
16:42:26 <Cody__>  :t [tail, init, reverse, head]
16:42:39 <Cody__> :t [tail, init, reverse, head]
16:42:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
16:42:40 <lambdabot>       Expected type: [a]
16:42:40 <lambdabot>       Inferred type: a
16:42:46 <Cody__> :t [tail, init, reverse, drop]
16:42:47 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
16:42:47 <lambdabot>     In the expression: drop
16:42:47 <lambdabot>     In the expression: [tail, init, reverse, drop]
16:42:56 <Cody__> :t drop
16:42:57 <lambdabot> forall a. Int -> [a] -> [a]
16:43:10 <byorgey> [tail, init, reverse]  is OK
16:43:27 <byorgey> (however, you should avoid using tail and init)
16:43:31 <byorgey> because
16:43:33 <Cody__> I see, they don't Int
16:43:35 <byorgey> > tail []
16:43:36 <lambdabot>   *Exception: Prelude.tail: empty list
16:43:39 <byorgey> > init []
16:43:40 <lambdabot>   *Exception: Prelude.init: empty list
16:44:10 <byorgey> :t [tail, init, reverse, drop 3]
16:44:11 <lambdabot> forall a. [[a] -> [a]]
16:44:32 <Cody__> Forgot drop was expecting an argument
16:51:23 <Cody__> :t [tail, init, reverse, sort, drop 3]
16:51:23 <lambdabot> forall a. (Ord a) => [[a] -> [a]]
17:04:00 <tommd> dgpratt: Thanks!
17:04:53 <dgpratt> tommd: ur welcome!
17:05:18 * dgpratt scrolls back to find out why he is the target of gratitude
17:05:44 <tommd> acid-state.  For some reason I forgot about that package.  Now I have a reason to use it for once.
17:06:23 <dgpratt> tommd: oh, right
17:29:52 <Axman6> :t (|||)
17:29:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
17:30:07 <wavewave> my hxournal finally has layer support ;-)
17:31:21 <wavewave> refactor singleton to list to zipper functor...
17:32:25 <wavewave> programming is a fight against complexity with weapon of mass abstraction
17:37:06 <drdo> wavewave: except sometimes those weapons backfire
17:37:19 <mokus> especially when you hold them the wrong way around
17:37:28 <mokus> which is easy to do
17:39:25 <wavewave> yup.. but give a trial is better than do nothing
17:40:16 <wavewave> type system is good for giving a trial as we discuss with compiler.
18:07:09 <bfig> god, i feel like an idiot. stopped programming haskell for a second, now i can't make anything numbery compile
18:08:11 <bfig> i want to make this list: fun n = filter ( <= fromIntegral (sqrt n)) [1..]. what is wrong with that?
18:09:47 <bfig> the computation doesn't terminate, how can i stop it? (other than using finite lists). i tried putting the filter condition inside the list but it also complains about types: [1..ceiling (sqrt n)]
18:11:19 <wavewave> bfig: why did you use fromIntegral?
18:11:22 <byorgey> bfig:use 'takeWhile' instead of 'filter'
18:11:34 <byorgey> bfig: also, that fromIntegral looks wrong.  (sqrt n) is not integral.
18:12:02 <wavewave> bfig: your program is logically faulty..
18:12:10 <byorgey> perhaps you want  (<= floor (sqrt (fromIntegral n)))  or something like that
18:12:11 <bfig> ok. let me redo that
18:12:12 <wavewave> because there is no assumption about [1..]
18:12:27 <wavewave> you implicit assume [1..] is increasing.
18:12:39 <wavewave> but computer does not know what it is .
18:12:43 <bfig> i didn't write it right here, i actually had it correctly written in the program
18:13:13 <Axman6> you almost certainly want takeWhile instead of filter
18:13:16 <bfig> wavewave, ok, i'll take byorgey's suggestion about takewhile
18:13:33 <wavewave> bfig : yes. filter is not what you want at all.
18:14:22 <byorgey> bfig: [1 .. ceiling (sqrt (fromIntegral n))]  would probably work too.
18:14:41 <byorgey> assuming n is an Int or Integer.
18:15:12 <Cain_> wavewave, forgive my ignorance, this may be the wrong question (theory vs reality ...), but when is [1..] not increasing?
18:15:47 <bfig> Cain_, the problem is the interpreter can't make that kind of inference
18:15:57 <wavewave> Cain_ : of course, it's increasing.. but during filtering computer does not know
18:16:13 <wavewave> so filter just does until the end of list.
18:16:20 <bfig> there is no metainformation that lets it know anything about what's inside (other than a list of a fixed type)
18:17:02 <Cain_> ah, ok
18:18:06 <wavewave> but you may make a type : IncreasingList or something like that if you want to have it in type theory
18:19:03 <wavewave> then IncreasingList has an additional information like lower bound..
18:20:01 <dolio> IncreasingList won't help you short circuit.
18:20:17 <bfig> was there a way to inline where/lets ?
18:20:25 <wavewave> dolio: definitely.. I am talking about something in principle
18:20:26 <dolio> Unless you also know that if y > x, p x -> p y
18:20:44 <bfig> ie, i have a lambda (\md -> x == floor x where x = sqrt md)
18:20:54 <bfig> (but that gives me trouble with where)
18:21:10 <wavewave> dolio: yes. so now my filter can do such inference .
18:21:37 <Cain_> i see
18:21:52 <bfig> using types to do that kind of stuff however is a real pain
18:21:54 <wavewave> so filterForIncreasingList has a predicate preserving monotocity.
18:22:07 <bfig> ie, you can program in the types
18:22:24 <wavewave> bfig: yes.. that's whole dep type idea.
18:22:30 <bfig> but in my opinion it is harder to understand what's happening
18:23:12 <bfig> so... inline wheres?
18:24:10 <wavewave> depending on how you write a program. if you write a program just as you write a proof, then it should be very clear to understand.
18:24:51 <wavewave> but if you just experiment and scratch whatever you think, then maybe it blocks the way quite much.
18:25:37 <wavewave> anyway. practical dep type programming is still something in future. not now.
18:26:01 <bfig> wavewave, but say, in past example, instead of just using takeWhile you would've had to invent a type, give a proof of the property, make a 'type case'
18:26:54 <wavewave> bfig: yes. that was my point... I just told that ensuring increasing list at type level can be another avenue.
18:27:06 <bfig> :)
18:27:38 <wavewave> bfig: but of course, it's overkill for everyday mundane programming.
18:28:11 <wavewave> I did use such type level insurance for alternating list before.
18:28:23 <bfig> wavewave, when do you believe it will be good enough?
18:28:40 <wavewave> a list  with alternating element type   a : b : a : b  ... something like that
18:28:42 <bfig> or for what, i mean
18:29:06 <wavewave> but it can start either b : a .. .or a : b ...
18:29:19 <bfig> cool :)
18:29:29 <wavewave> although I can implement it with simple type.. or existential type..
18:29:47 <wavewave> but I just tried it with type-level info.
18:30:09 <wavewave> and actually compiler caught many of my errors from then on... that was really rewarding experience.
18:31:31 <wavewave> increasing list type may be helpful in some cases.. hmmm..
18:31:52 <bfig> i'm just playing with the facebook hacker cup problems. i needed to get the numsber of ways to write a number as the sum of two squares
18:32:15 <wavewave> because it has more assurance than takewhile..
18:32:53 <hpaste_> bfig pasted “qual problem” at http://hpaste.org/56464
18:32:54 <wavewave> maybe for efficient dictionary making or something like that.
18:32:56 <wavewave> hm.
18:33:13 <bfig> is there a more elegant solution?
18:34:21 <bfig> that is acceptably fast if you want to check a couple thousand elements
18:34:34 <mike-burns> What does this function do?
18:34:53 <bfig> mike-burns, <bfig> i'm just playing with the facebook hacker cup problems. i needed to get the numsber of ways to write a number as the sum of two squares
18:35:01 <mike-burns> Oh.
18:35:24 <mike-burns> Does it have to be correct?
18:35:36 <mike-burns> I have a version of the function that is very fast but often incorrect.
18:35:41 <bfig> takes the amount of leftovers which are squares after substracting from the number the square of an increasing sequence (up to square root of that number)
18:35:56 <bfig> mike-burns, no idea
18:36:14 <gestur> you might want to look at Fermat's theorem on sums of two squares
18:36:24 <bfig> my guess is that it must be correct 100% of the time, but you can always make a function fail by using super large numbers
18:37:07 <mike-burns> That `fromIntegral' all over the place is frustrating. Is there a better way to do that?
18:37:45 <mike-burns> :t sqrt
18:37:46 <lambdabot> forall a. (Floating a) => a -> a
18:37:49 <bfig> mike-burns, i don't think there is
18:38:01 <mike-burns> Is the type signature given to you?
18:38:14 <mike-burns> Or can this function be  squares :: (Floating a) => a -> Int
18:38:30 <bfig> what? i don't even know if haskell is an acceptable programming language
18:39:36 <mike-burns> OK.
18:39:52 <mike-burns> I don't know how to help you with your personal programming challenge, then.
18:40:21 <bfig> i'm just thinking and having fun, if you have an interesting observation on my code or an alternative solution, go ahead
18:40:51 <bfig> this are problems from last year, they are there just in case somebody wants to practice. i'm just taking them apart for fun
18:40:57 <bfig> and to refresh my haskell :)
18:41:36 <bfig> mike-burns, you said you had a function which works most the time. care to show it?
18:41:53 <mike-burns> squares n = 4
18:42:02 <mike-burns> I was being a wise-ass.
18:42:02 <bfig> >_>
18:42:04 <mike-burns> Carry on.
18:42:31 <byorgey> for the record, mike-burns actually said it is "often incorrect".
18:42:46 <bfig> lol
18:43:14 <bfig> i wonder if there are numbers which can be written as arbitrarily many sums of squares
18:43:27 <bfig> ie, squares x = y forall y in N
18:43:36 <bfig> (exists some x)
18:44:28 <cody__> > ()
18:44:29 <lambdabot>   ()
18:44:32 <cody__> > ('c')
18:44:32 <lambdabot>   'c'
18:44:51 <cody__> I thought tuples could not have an arity of one..?
18:45:23 <mike-burns> :t ('c')
18:45:24 <lambdabot> Char
18:45:43 <mike-burns> An expression can be wrapped in parens for grouping.
18:46:19 <cody__> so ('c') is not a tuple, just an expression (or argument for a function)
18:46:29 <mauke> same thing
18:52:04 <byorgey> bfig: no, any finite number can be a sum of squares in only finitely many ways.
18:52:37 <bfig> byorgey, i mean this: forall x in N, there exists some y in N such that squares y = x
18:52:52 <byorgey> ah, I see.  hmm.
18:53:01 <bfig> i don't think there is, it doesn't seem possible
18:53:14 <bfig> maybe they are unbounded but they aren't for arbitrary x
18:54:48 <drull95> theoretical introduction to gets off to one hell of a start
18:55:11 <drull95> ^ theoretecial intro to programming
18:55:57 <bfig> drull95, are they theoretically teaching you to program? :p
18:56:44 <PatrickRobotham> hi all, can someone give me an example of a type with kind * -> * which isn't a Functor?
18:57:04 <koninkje> (_->A)
18:57:06 <mauke> data T a = a -> Int
18:57:22 <mauke> data T a = C (a -> Int)
18:58:39 <koninkje> Type families are also typically not functors
18:59:02 <koninkje> Technically Data.Set.Set is not a Functor
18:59:17 <djanatyn> why would anyone use free expressions in haskell? I don't understand what they're for.
18:59:22 <koninkje> (even though sets are functors)
18:59:29 <djanatyn> if there are free variables, what is the purpose of the expression? how can the compiler interpret it?
18:59:54 <mauke> it can't
19:00:02 <djanatyn> then, uhh
19:00:04 <bfig> PatrickRobotham, functors are not related to the concept of higher kinds in principle. consider this: data Wrapper a = C a
19:00:09 <djanatyn> do we ever use free expressions in haskell code?
19:00:22 <mauke> djanatyn: no
19:00:33 <byorgey> djanatyn: sure.  If I write  'f x = g x + 3'
19:00:38 <byorgey> there is one free variable, g.
19:00:47 <mauke> yeah, but it won't compile
19:00:48 <byorgey> of course, g had better be bound somewhere in the enclosing context.
19:01:01 <mauke> if it's bound somewhere, how is it free?
19:01:10 <byorgey> my point is that free vs bound depends on context.
19:01:15 <djanatyn> >_>
19:01:22 <byorgey> if you consider an expression on its own, it may have free variables.
19:01:33 <byorgey> if you consider it as part of a larger expression, those variables may be bound.
19:01:37 <djanatyn> so, we don't actually use free expressions.
19:01:41 <djanatyn> or free variables.
19:01:45 <djanatyn> that's bad. it causes errors.
19:01:47 <PatrickRobotham> bfig: Isn't that a functor?
19:01:52 <djanatyn> so, does that make everything a combinator?
19:01:58 <bfig> PatrickRobotham, what is your definition of functor?
19:02:16 <PatrickRobotham> bfig: Something for which we can implement the Data.Functor instance.
19:02:28 <byorgey> djanatyn: oh, is that why you're wondering about free variables.  Ignore that definition of combinators, it is useless.
19:02:30 <PatrickRobotham> Bah, that's awful english.
19:02:35 <byorgey> djanatyn: for exactly the reason you have discovered.
19:02:40 <djanatyn> byorgey: I thought it was sketchy
19:02:43 <PatrickRobotham> bfig: Something which can be made an instance of Data.Functor
19:02:53 <bfig> PatrickRobotham, you have phantom types, ie, using a type just for markup... you'll have difficulties to translate that to a functor
19:02:54 <djanatyn> I was kind of confused - I thought free variables were part of haskell's syntax or some weird feature
19:03:13 <bfig> PatrickRobotham, but as long as the object has something of said type inside you can most likely construct a functor instance
19:04:33 <bfig> PatrickRobotham, i don't think i know of something like what you're asking except those
19:05:10 <PatrickRobotham> bfig: Well I think data T a = C (a -> Int) works.
19:05:22 <PatrickRobotham> That's a Cofunctor.
19:05:33 <byorgey> bfig: "functors are not related to the concept of higher kinds in principle" -- what?
19:05:53 <PatrickRobotham> class Cofunctor f where cofmap :: (b -> a) -> f a -> f b
19:05:54 <byorgey> a functor must be something of kind  * -> *.
19:05:57 <koninkje> PatrickRobotham: rather, it's a contravariant functor
19:06:20 <bfig> byorgey, but something of kind * -> * isn't necessarily a functor
19:06:36 <byorgey> indeed.  hence PatrickRobotham's question.
19:06:41 <koninkje> byorgey: only endofunctors must have that kind. you can have functors to another category, which don't have a kind at all
19:06:53 <byorgey> well, sure.
19:07:05 <bfig> what?
19:07:07 <bfig> how?
19:07:13 <byorgey> I should have been more careful with functor vs Functor.
19:07:16 <koninkje> :)
19:07:18 <byorgey> bfig: not in Haskell.
19:07:31 <bfig> oh
19:08:01 <koninkje> bfig: The Functor class only captures the (category theoretic) endofunctors which are definable in Haskell. However, there are plenty of other functors around
19:09:14 <PatrickRobotham> covariant endofunctors! :P
19:09:30 <bfig> i can only think of stupid functors right now, but i definitely see how it could make sense
19:09:37 <koninkje> the covariance is assumed ;p
19:10:16 <bfig> think i'm gonna chill out with some SSBB for a while. thanks for helping me with the types
19:10:57 <PatrickRobotham> Is that the unofficial motto of haskell? "Follow the types"?
19:11:15 <mike-burns> It will get you pretty far.
19:13:11 * byorgey sings follow the system F types, follow the system F types, fol-low fol-low fol-low fol-low follow the system F types!
19:13:42 * cmccann drops a house on Java
19:14:24 <PatrickRobotham> System F?
19:16:28 <byorgey> PatrickRobotham: System F is the formal type system on which Haskell's type system is (loosely) based
19:16:47 <byorgey> cmccann: hahaha
19:17:36 <dolio> F is way too weak.
19:17:40 <dolio> Needs F_w.
19:17:59 <dolio> F is for those ML guys.
19:18:00 <byorgey> ah, right, I always forget that
19:18:37 <dolio> F_w doesn't fit in your song, though.
19:18:49 <byorgey> indeed.
19:18:59 <byorgey> with great power comes a great many syllables.
19:19:09 <mike-burns> Ha!
19:19:22 <cmccann> that reminds me, I never did get around to rewriting byorgey's haddocks in poetic meter
19:19:38 <cmccann> completely slipped my mind
19:20:20 * byorgey is patient
19:36:59 <mdwright> Is there a way to get cabal to automatically recompile alex/happy files?
20:08:20 <tgeeky> wow:
20:08:21 <tgeeky> http://flare.prefuse.org/demo
20:10:11 <tgeeky> oh. that's flash. wow retracted.
20:26:21 <byorgey> tgeeky: also, it looks like the last release was in January 2009?
20:26:28 <tgeeky> yeah.
20:26:31 <tgeeky> it was a link from d3.js
20:26:41 <tgeeky> i didn't realize he just meant "took inspiration from" or somehting, lol
20:27:10 <byorgey> heh
20:34:50 <tempire> in english terms, how is <*> commonly referred to?
20:37:58 <byorgey> tempire: it isn't commonly referred to in English
20:38:09 <byorgey> at least, not spoken English
20:38:12 <wavewave> ap?
20:38:17 <byorgey> in written English I usually refer to it as <*>
20:40:15 <wavewave> do we have boston hackathon soon ?
20:40:41 <dolio> Yes.
20:40:46 <dolio> This coming weekend.
20:40:55 <wavewave> when exactly?
20:41:24 <dolio> Starts Friday afternoon/evening some time, ends Sunday afternoon.
20:41:32 <dolio> Ed is supposed to send out a reminder.
20:42:02 <wavewave> this coming weekend means Jan 20 - Jan 22?
20:42:09 <dolio> Yes.
20:42:43 <wavewave> i see.. the haskell wiki page was wrong.
20:42:52 <dolio> Oh?
20:43:10 <wavewave> http://www.haskell.org/haskellwiki/HacBOS
20:43:33 <dolio> http://www.haskell.org/haskellwiki/Hac_Boston
20:43:51 <dolio> That's the one that's been getting updated, I think.
20:44:01 <wavewave> thanks!
20:45:22 <dolio> That HacBOS one dates back to 2009.
20:45:35 <deech> Hi all, does anyone know if qtHaskell has a SC repository? I'd like to know if there's any development going on.
20:45:41 <dolio> And hasn't changed much since then.
21:04:45 <gienah> deech: I don't know, qtHaskell builds with a few patches: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/qt/files
21:10:01 <deech> gienah: It built file on Linux, on Windows the compilation maxed out the RAM. Never tried Mac. I'm more worried that there hasn't been a release since Sep'2010 and there isn't a public repo.
21:10:12 <deech> s/file/fine
21:28:32 <wvoq> hello again all, I found a very charming quirk with GHCi in emacs
21:28:49 <wvoq> it won't accept expressions of more than 253 characters in length
21:30:08 <wavewave> dolio: I just registered to hac boston.
21:30:17 <dolio> Ah, good.
21:30:29 <shachaf> Hmm, Hac Boston.
21:30:31 <shachaf> I might go.
21:30:48 <wavewave> found cheap air ticket ;-D
21:31:06 <dolio> I heard ddarius is going to mug everyone at the event.
21:31:23 <shachaf> dolio: Really? ddarius mugging is included?
21:31:31 * shachaf can't think of any reason not to go, in that case.
21:31:35 <shachaf> Thai tea and everything?
21:32:37 <dolio> There are definitely places that serve Thai tea around here.
21:33:18 <shachaf> The question is whether we'll be forced to purchase some at ddariuspoint.
21:33:51 <dolio> It's logically possible.
21:34:22 <wavewave> has written up my project on the wiki ;-D
21:34:46 <wvoq> arg, nevermind.  For the sake of posterity and logging, Wei Hu solved this here: http://sites.google.com/site/haskell/notes/ghci610emacsmadness
21:36:11 <tommd> Lemmih: wrt acid-state, how much work is done when a state is opened?  Pretending I opened the state every time a (somewhat infrequent) operation occurred... how dumb would that be?
21:36:39 <wavewave> tommd: you can use checkpoint.
21:37:19 <wavewave> tommd : if you create checkpoint, then acid-state does not take much time for reopening it.
21:38:57 <tommd> wavewave: Ok, I'll give it a go - thanks.
21:39:10 <wavewave> welcome ;-)
21:53:02 <mdwright> Is there a way to enable flags for cabal to use similar to the `--prog-options`, except from within the .cabal config file
21:54:36 <wavewave> mdwright : use flag in your cabal file.
21:55:57 <thetrav_> trying to learn haskel.  I wrote some stuff in a file, now want to load that stuff into ghci I thought load fileName was the right way to do that?
21:56:13 <wavewave> mdwright: refer to my code : http://github.com/wavewave/hxournal/blob/master/hxournal.cabal
21:57:04 <wavewave> mdwright: there you can find "Flag Poppler"
21:57:45 <XexonixXexillion> thetrav_: it should be :load
21:57:46 <mdwright> wavewave: sorry, I mean there already /is/ a flag for the option I want, I just don't know how to set it from within a .cabal file
21:58:19 <thetrav_> ahh, missed the : thanks
21:58:55 <wavewave> mdwright : if it is ghc-options, then you can use ghc-options: ....
21:58:59 <mdwright> There is a flag I can enable doing "cabal install --alex-options="-g"", and I would like to do something along the lines of "alex-options: -g" but that isn't valid
21:59:08 <mdwright> wavewave: it isn't ghc-options
21:59:26 <thetrav_> and there's a function for outputing types right?
21:59:53 <saiko-chriskun> thetrav_: :t
21:59:56 <thetrav_> ta
22:01:11 <thetrav_> hmm
22:01:28 <thetrav_> let x = Some 10; :t x gives me a different result to :t (Some 10)
22:01:37 <mdwright> See --prog-options at http://www.haskell.org/cabal/users-guide/#package-descriptions for an example of how to do what I want with a command line flag
22:02:20 <thetrav_> one gives me an Option Integer, the other gives me Num a => Option a
22:02:21 <shoerain> Just wondering, what are you using to learn Haskell, thetrav_ ?
22:02:30 <thetrav_> hmm
22:02:34 <thetrav_> experience I guess :P
22:02:41 <thetrav_> I've got learn me a haskel for greater good open
22:02:44 <mauke> the dreaded monomorphism restriction
22:02:53 <saiko-chriskun> thetrav_: that sounds right
22:02:56 <thetrav_> I've also done some stuff a while ago
22:03:55 <thetrav_> Tony Morris ran a day workshop in December where we blasted though a whole heap of stuff
22:04:07 <thetrav_> I've been a bit crap though and not re-visited it until now
22:04:39 <thetrav_> so I'm sort of fishing around for remembered ideas and trying to tape them together
22:16:50 <hpaste_> Jeff pasted “IO” at http://hpaste.org/56465
22:17:57 <jdavis> In the example here: http://hpaste.org/56465 "should not print" is, indeed, not printed when I run it. I understand that it shouldn't be, but I don't really understand the mechanism: shouldn't "seq" force the evaluation, and then cause it to print?
22:19:30 <mauke> jdavis: evaluation doesn't cause printing
22:19:52 <mauke> putStrLn isn't a function that prints a string
22:20:12 <mauke> putStrLn is a function that takes a string and returns an action that (when executed) will print that string
22:21:09 <shachaf> jdavis: You should probably read an introduction to how IO works in Haskell, because you seem confused about an important distinction, and people have written it up better than we can hope to do in a few lines of IRC. :-)
22:21:13 <shachaf> @where io
22:21:14 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:23:04 <jdavis> Thank you, reading that now. mauke, I had a vague feeling it was something like that, but I'll need to learn in a little mote detail.
22:26:01 <jdavis> OK, it pretty much explains  it right at the top of that document. "main" is special because the IO action returned from it is actually executed.
22:26:25 <mauke> well, not really "returned from it"
22:26:28 <shachaf> jdavis: Not so much "returned from it", as "is", but yes.
22:26:30 <mauke> main isn't a function
22:26:57 <shachaf> I hear it usually is.
22:27:04 <jdavis> Oh, I see, because it doesn't take arguments.
22:27:12 <jdavis> ?
22:27:20 <shachaf> More precisely, because it doesn't take an argument. :-)
22:27:57 <jdavis> OK, I assume you say that because all functions take exactly one argument?
22:28:39 <mauke> yes
22:28:56 <mauke> and "main is usually a function" is a gcc message :-)
22:29:26 <shachaf> A function is a thing that has type "X -> Y" for some types X and Y.
22:30:21 <jdavis> OK, thank you both.
22:31:08 <DanBurton> random question, so I have this function, "sinkM hof f = runIdentity . hof (return . f)", which, when applied to certain functions, produces the non-monadic version of them. for example, sinkM mapM === map. Rather than "sinkM", what would you name this function?
22:33:33 <copumpkin> :t let sinkM hof f = runIdentity . hof (return . f) in sinkM
22:33:34 <lambdabot> forall (f :: * -> *) (m :: * -> *) a (f1 :: * -> *) a1. (Functor f1, Functor f, Monad m) => (f (m a) -> f1 (Identity a1)) -> f a -> f1 a1
22:33:53 <copumpkin> :t let sinkM hof f = runIdentity . hof (return P.. f) in sinkM
22:33:54 <lambdabot> Couldn't find qualified module.
22:34:01 <copumpkin> :t let sinkM hof f = runIdentity . hof (return Prelude.. f) in sinkM
22:34:02 <lambdabot> forall a (m :: * -> *) b (f :: * -> *) a1. (Functor f, Monad m) => ((a -> m b) -> f (Identity a1)) -> (a -> b) -> f a1
22:37:24 <dolio> @type let sink :: (forall m. (a -> m b) -> c -> m d) -> (a -> b) -> c -> d ; sink hof f = runIdentity . hof (return . f) in sink
22:37:25 <lambdabot> forall a b c d. (forall (m :: * -> *). (a -> m b) -> c -> m d) -> (a -> b) -> c -> d
22:39:11 <XexonixXexillion> Is there any way I can import a function that wasn't explicitly exported without changing the module the function is in?
22:39:39 <dolio> No.
22:40:13 <dolio> Unless the export list is just omitted, in which case everything is exported, but not explicitly.
22:42:24 <XexonixXexillion> dolio: How about a way to re-write the constructors of a newtype and tell GHC that they're the same thing in both modules?
22:43:09 <dolio> No, I don't think so.
22:43:28 <dolio> Unless there are some evil hacks. Let me check.
22:47:08 <dolio> Nope. They closed the loophole I was thinking of.
22:47:46 <shachaf> dolio: What loophole is that?
22:48:22 <dolio> If it's a newtype, derive an instance using newtype deriving.
22:48:29 <dolio> That works with whatever the underlying thing is.
22:48:45 <dolio> Standalone if necessary.
22:48:54 <XexonixXexillion> It's just that Graphics.X11.Xlib.Region doesn't allow any way to get at the underlying foreign pointer in the region type, and I'm writing bindings to a c library which needs the underlying pointer
22:49:01 <dolio> But that doesn't work when the constructor isn't in scope.
22:49:08 <shachaf> Aw.
22:49:24 <dolio> At least, standalone deriving doesn't work when the constructor isn't in scope.
22:49:30 <dolio> So says the error message.
22:51:21 <Sgeo> Wait, derive an instance... of a constructor?
22:51:25 <Sgeo> What sense does that make?
22:51:50 <shachaf> Very little.
22:51:57 <shachaf> It's a good thing dolio didn't say that.
22:52:38 <Sgeo> What did dolio say?
22:53:03 <shachaf> A bunch of things. Your IRC client probably kept a record, if you look up. :-)
22:53:22 <shachaf> An instance, in Haskell, is of a type class.
22:54:22 <shachaf> Sgeo: (Do you know how standalone deriving works?)
22:57:25 <Sgeo> Only vaguely
22:57:49 <Sgeo> It didn't look like they were talking about typeclasses
23:14:20 <g06|in> need some help understanding foldr
23:14:22 <g06|in> r
23:14:48 <g06|in> "right folds work on infinite lists, whereas left ones don't" - why?
23:15:06 <shachaf> g06|in: Right folds are a much more fundamental type of operation than left folds.
23:15:16 <shachaf> g06|in: The short answer is "evaluate it for yourself by hand and see".
23:15:26 <mikeplus64> http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell can someone verify that this doesn't work?
23:15:28 <shachaf> Here's what right folds do:
23:15:33 <shachaf> > foldr f z [a,b,c,d]
23:15:34 <lambdabot>   f a (f b (f c (f d z)))
23:15:35 <mikeplus64> none of the code examples that is
23:16:36 <mikeplus64> it has to do with the way let bindings are interpretted by ghc I believe, it's very annoying
23:16:37 <g06|in> shachaf: but that means that you first have to go all the way to the end of the list and you keep chaining up functions on the left… that are waiting for inputs from the result from the right
23:17:48 <XexonixXexillion> mikeplus64: the hello world example works for me
23:18:31 <shachaf> g06|in: Your words don't make sense to me (although the meaning behind them might make sense, who knows).
23:18:40 <mikeplus64> XexonixXexillion: what ghc version?
23:18:59 <shachaf> mikeplus64: The example works for me with GHC 7.0.x.
23:19:01 <hpaste_> me pasted “broked” at http://hpaste.org/56466
23:19:08 <XexonixXexillion> mikeplus64: 7.0.4
23:19:14 <mikeplus64> can someone try that paste above?
23:19:17 <mikeplus64> it doesn't compile for me
23:19:25 <arks> how to use the "readPrec", i can't find the usage~
23:19:25 <shachaf> mikeplus64: Your indentation is broken, yes.
23:19:45 <mikeplus64> that's odd, it's pasted differently from what I see in my editor
23:19:47 <shachaf> That has nothing to do with the example on the wiki, which uses spaces and not tabs.
23:19:52 <g06|in> shachaf: in case of foldr wouldn't you keep building up the stack?
23:19:54 <mikeplus64> yeah
23:19:59 <shachaf> GHC treats tabs as ~8 spaces or something.
23:20:36 <shachaf> g06|in: Functions don't really "wait for input". There's no real "you" who "goes all the way to the end of the list" and "chains up functions on the left".
23:20:36 * yitz takes pride in having no idea how GHC treats tabs
23:21:18 <mikeplus64> shachaf: in vim, all the bindings are aligned, but when I just try cat on it it looks completely wacky, odd
23:21:34 <shachaf> mikeplus64: :se ts=8
23:21:40 <mikeplus64> I think the editor I was using is mixing tabs and spaces sillily
23:21:44 <mikeplus64> (I was using sublime text)
23:21:47 <shachaf> Just don't use tabs.
23:21:52 <mikeplus64> I try not to
23:21:57 <mikeplus64> I didn't think I was
23:22:01 <mikeplus64> forgive me ._.
23:24:39 <Sgeo> g06|in, suppose that f sometimes can ignore its second argument
23:25:17 <Sgeo> What happens?
23:26:44 <Sgeo> Suppose it returns a result based on the second argument without necessarily evaluating the second argument. What happens?
23:27:27 <shachaf> Sgeo: You should write up your explanation, put it up on the wiki, and then paste a link to the wiki.
23:27:28 <g06|in> Sgeo: not sure what you mean by result based on second arg without evaluating it…
23:27:41 <Sgeo> g06|in, take (:) for example
23:27:46 <Sgeo> It takes an element and a list
23:27:58 <Sgeo> You don't need to know the whole list to use it
23:28:09 <g06|in> Sgeo: hmmm
23:28:25 <Sgeo> g06|in, do you understand the basics of laziness
23:28:31 <Sgeo> Or, well, non-strict-ness?
23:28:48 <g06|in> Sgeo: I thought I did, before I saw foldr and foldl
23:29:23 <Sgeo> f might not be strict in its second argument.
23:29:41 <Sgeo> (:) is not strict in its second argument:
23:29:50 <Sgeo> > head ('a' : undefined)
23:29:51 <lambdabot>   'a'
23:30:03 <Sgeo> > head ('a' : ('b' : undefined))
23:30:04 <lambdabot>   'a'
23:30:15 <g06|in> Sgeo: !
23:30:28 <g06|in> Sgeo: so how is this helping foldr … :(
23:30:42 <Sgeo> Suppose that f is not strict in the second argument
23:30:55 <Sgeo> That means it might give a result, without necessarily evaluating the second argument
23:31:09 <Sgeo> > foldr f z [a, b, c, d]
23:31:10 <lambdabot>   f a (f b (f c (f d z)))
23:31:54 <Sgeo> If f ignores its second argument in this example, it returns immediately. Separate example, if f is (:), then its result is a:(rest of the foldr)
23:32:00 <g06|in> Sgeo: sorry… :( still missing something… in f a (f b (f c … it looks like to find the result of the first application you need to push f a into the stack and then evaluate the result and pop the stack and return the final result. isn't that how things work?
23:32:19 <Sgeo> g06|in, in languages other than Haskell, yes
23:32:40 <shachaf> g06|in: No, it's not how things work.
23:33:02 <shachaf> g06|in: You'll possibly be better-served by thinking about "what things are" than "how things work".
23:33:35 <XexonixXexillion> g06|in: think of it as being f a someUnevaluatedThunk, not f a (f b (f c..
23:34:10 <shachaf> I also imagine that you'll be better served by reading some text about how laziness/non-strictness works than by Sgeo's impromptu explanation of foldr. This is very fundamental to understanding anything in Haskell, so it's a good idea to go over it until you're sure you understand it.
23:34:35 <Sgeo> shachaf, sorry
23:34:42 <shachaf> Sgeo: ?
23:34:49 <g06|in> shachaf: sure… can you point me to some links… ?
23:34:53 <shachaf> Sgeo: I wasn't saying your explanation was bad.
23:35:08 <Sgeo> Ok
23:37:19 <g06|in> ok… in foldl the evaluation will would look like (f (f (f a z) b) c), right? hence, I thought haskell would compute the first (f a z) and then the next, keep going till the end. all one has to do is pick the head apply f with z and move on. should work on infinite lists… but it doesn't
23:38:15 <shachaf> g06|in: That's not how it works. Evaluation is "outermost-first".
23:38:25 <shachaf> If you think about it enough, you'll see that this is the only way it makes sense.
23:38:55 <shachaf> I mean, even if foldl did what you said -- and in a sense it does -- what good would it do to the person who's *using* the value that foldl returns?
23:39:18 <shachaf> When you use that value, you're looking at it from the outside, not the inside.
23:39:26 <Cale> g06|in: foldl f z [1..] = foldl f (f z 1) [2..] = foldl f (f (f z 1) 2) [3..] = ...
23:40:16 <Cale> foldl only calls itself until it reaches the end of a list. Control never passes to f until then.
23:40:50 <Cale> @src foldl
23:40:50 <lambdabot> foldl f z []     = z
23:40:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:40:59 <Cale> ^^ as you can see there too :)
23:42:20 <XexonixXexillion> g06|in: why not trying working through a simple function like; take 4 (foldr (\x -> (:) (2*x)) [] [1..])
23:42:29 <Cale> and yeah, evaluation is outermost-first, so if you have  f (f (f z a) b) c, first thing to evaluate is f applied to (f (f z a) b) (which is not evaluated yet) and c
23:42:45 <g06|in> shachaf, Cale: I think I will go and read some more… I'm still confused.
23:42:48 <Cale> @src foldl
23:42:48 <lambdabot> foldl f z []     = z
23:42:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:42:51 <Cale> @src foldr
23:42:51 <lambdabot> foldr f z []     = z
23:42:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:43:06 <Cale> foldr in the nonempty list case immediately passes control to f
23:43:24 <Cale> and only if f uses its second parameter will the foldr f z xs be evaluated
23:43:34 <g06|in> Cale: in foldl I don't understand why control never passes to 'f' until the end of list is reached. I mean why expand after 'foldl (f z 1) [2..]'
23:44:24 <shachaf> g06|in: You should look at the definition of foldl and evaluate it by hand for a bit.
23:44:27 <Cale> because foldl is the outermost function, it's the one to evaluate first
23:44:28 <shachaf> It'll probably make more sense after that.
23:45:09 <Cale> according to the definition, foldl f (f z 1) (2 : [3..]) = foldl f (f (f z 1) 2) [3..]
23:45:40 <Cale> The f z 1 isn't evaluated because it isn't the outermost reducible subexpression
23:46:16 <XexonixXexillion> g06|in: If you were presented with a function like; (\ x y -> x) 1 [1..] would you evaluate the infinite list?
23:46:56 <g06|in> XexonixXexillion: no
23:47:47 <Sgeo> Would it help if I mentioned that there are functions f for which the foldr won't work on infinite lists?
23:48:10 <g06|in> Sgeo: I guess. examples… ?
23:48:19 <Sgeo> (+)
23:48:22 <Sgeo> (*)
23:48:54 <g06|in> Sgeo: what about examples where it would work?
23:48:58 <Sgeo> > foldr (+) 0 [0,0..]
23:48:59 <lambdabot>   *Exception: stack overflow
23:49:24 <Sgeo> > take 20 $ foldr (:) [] [1..]
23:49:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
23:49:33 <Sgeo> > take 20 $ foldr (+) 0 [0,0..]
23:49:34 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
23:49:34 <lambdabot>    arising from a use...
23:49:53 <Sgeo> derp, the last one doesn't make sense
23:50:21 <g06|in> how can you do take 20 when the result of foldr isn't a list?
23:50:40 <XexonixXexillion> g06|in: you don't, hence why it didn't make sense
23:50:43 <shachaf> g06|in: You can't. Hence Sgeo's next message.
23:50:48 <g06|in> oh cool
23:51:47 <Sgeo> For f being (:) though, the result is a list
23:51:55 <Sgeo> :t foldr (:) [] [1..]
23:51:56 <lambdabot> forall a. (Num a, Enum a) => [a]
23:55:59 <XexonixXexillion> g06|in: or for another example of a function you can foldr over an infinite list with (and have return a non infinite result); let fac n = foldr (\x -> if x > n then const 1 else (x*)) 1 [1..]
23:57:41 <hpaste_> “g06|in” pasted “foldl - in terms of - foldr” at http://hpaste.org/56467
23:58:07 <g06|in> don't understand this snippet where foldl is done in terms of foldr
23:58:13 <shachaf> g06|in: Why are you looking at that?
23:58:18 <shachaf> That's way too complicated.
23:58:23 <g06|in> ok
23:58:24 <shachaf> First understand foldr.
