00:00:23 <shachaf> No, "m" is a Monad instance. "m ()" isn't.
00:00:32 <ion> @src unless
00:00:32 <lambdabot> unless p s = if p then return () else s
00:02:36 <Duffman-> thank you
00:03:23 <ion> @type unless `asTypeIn` \unless -> unless undefined (Just undefined)
00:03:23 <lambdabot> Bool -> Maybe () -> Maybe ()
00:03:27 <ion> @type unless `asTypeIn` \unless -> unless undefined [undefined]
00:03:28 <lambdabot> Bool -> [()] -> [()]
00:05:51 <Duffman-> ion: I don't see  what you're wanting to show. On the other hand, I alsodon't know this "asTypeIn" method
00:06:59 <shachaf> I don't think "asTypeIn" will help you understand anything.
00:09:16 <Duffman-> I understand Maybe Int
00:09:19 <Duffman-> and Maybe Char
00:09:30 <Duffman-> but what do the brackets mean in "Maybe ()"?
00:09:38 <Duffman-> I don't know the type "()"
00:09:46 <Duffman-> :t ()
00:09:47 <lambdabot> ()
00:10:41 <shachaf> Well, now you know it.
00:10:52 <shachaf> data () = ()
00:10:58 <koala_man> Duffman-: it's an empty tuple. the unit type.
00:13:13 <Duffman-> but what's the use then? Since the definition of the type is " data () = () ", it doesn't seem like it's useful or anything ..
00:14:03 <ion> @type putStrLn
00:14:04 <lambdabot> String -> IO ()
00:14:06 <flux> duffman-, sometimes you have a general function with some genericity you don't need. in those cases you would use () for that.
00:14:11 <Duffman-> oh
00:14:12 <flux> and IO, of course
00:14:32 <Duffman-> so you can do actions, and afterwards you NEED to return some value, and that's why you'd want to use this empty tuple?
00:14:47 <flux> for example, maybe you need a Set datastructure but you already have a Map. a Map from your type to () is the same as Set.
00:14:49 <ion> “result in” some value
00:15:15 <ion> @type guard
00:15:16 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
00:15:19 <ion> @src guard
00:15:19 <lambdabot> guard True  =  return ()
00:15:20 <lambdabot> guard False =  mzero
00:15:46 <flux> duffman-, btw, Maybe () is essentially the same as Bool
00:16:10 <ion> Ignoring bottoms
00:17:46 <yitz> Duffman-: every function has to return something. a function is a description of a way to get from type A to type B.
00:18:34 <shachaf> Another word is "produce".
00:18:34 <Duffman-> thanks guys
00:18:50 <Duffman-> I think I get it.
00:19:00 <shachaf> An action "produces" a value, as well as possibly having some sort of effect. If you only care about the effect, you can produce ().
00:23:18 <Blkt> good morning everyone
00:24:09 <ion> Good news, everyone!
00:38:46 <erus`> @hoogle [a] -> [
00:38:46 <lambdabot> Parse error:
00:38:46 <lambdabot>   [a] -> [
00:38:46 <lambdabot>          ^
00:38:51 <erus`> @hoogle [a] -> a -> [a]
00:38:51 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
00:38:51 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
00:38:51 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
00:38:57 <erus`> @hoogle trim
00:38:58 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS trimmingCurve :: TrimmingPoint c => NURBSObj -> GLint -> Ptr GLfloat -> GLint -> Ptr (c GLfloat) -> GLint -> IO ()
00:38:58 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS class TrimmingPoint p
00:38:58 <lambdabot> package trimpolya
00:56:57 <fasta> Which database interface is currently the best (as in easy to use and not terribly slow and maintained)?
01:13:56 <erus`> a b c = (a b) c, is it the same in lambda calc?
01:15:14 <danr> erus`: yeah, you have left associative function application in lambda calculus
01:15:30 <erus`> that makes life easier :)
01:15:43 <danr> yeah :)
01:15:56 <danr> How's your language turning out?
01:17:04 <erus`> I have a type system with generics but only forall. for now
01:17:29 <erus`> im just making a lambda calc interpreter today because im tired, and its a slow day at work
01:18:21 <carpi> is there any good strategy for naming variables?
01:18:41 <danr> So we have bang patterns in patterns, but what are the bangs in datatype definitions called? I cannot recall the name...
01:18:48 <frerich> erus`: I don't want to spoil the fun of hacking up a custom language, but I just thought of http://colinm.org/language_checklist.html ;-)
01:19:05 <shachaf> danr: Strict fields?
01:19:08 <danr> carpi: short if they have short scope, if they have big scope (entire module), descriptive name :)
01:19:24 <danr> shachaf: thanks!!
01:19:25 <erus`> lol i got that last time i posted on reddit
01:19:37 <shachaf> If any identifier in your program is longer than one character, you're obviously doing something wrong.
01:19:56 <carpi> thanks. that makes a lot of sense. _ )
01:20:43 <danr> carpi: i think there's a little article on it on the haskell wiki
01:25:08 <carpi> http://www.haskell.org/haskellwiki/Variable <- this one?
01:25:44 <carpi> but it seems kinda irrelevant and google doesn't seem to have any other results for haskell wiki variable naming
01:27:16 <erus`> (\x -> (\x -> y)) a = (\a -> y) ?
01:27:52 <erus`> i hope not
01:29:49 <sshine> no
01:30:07 <sshine> (\x -> f) a = f
01:31:29 <sshine> or rather, it doesn't matter. what you said is also true, modulo alpha-transformations.
01:32:10 <sshine> (\x -> (\x -> y)) a = (\x -> y) = (\a -> y)
01:33:00 <sshine> it isn't the same a, however.
01:34:00 <sshine> err... it doesn't have to be.
01:34:03 * sshine goes away =)
01:40:03 <erus`> guess now i should implement those de bruj indexes or whatever their called
01:41:07 <ddarius> You don't need to do that, you just need to implement substitution correctly.
01:41:12 <ddarius> Also "de Bruijn"
01:41:39 <erus`> I have substitution
01:41:50 <erus`> but i use Char for variables
01:43:37 <ddarius> erus`: Other than that gives you a finite set of variables, that's not a problem.
01:43:58 <erus`> yeah but (\x -> x) /= (\y -> y)
01:44:20 <quicksilver> why do you care about term equality?
01:44:21 <ddarius> You just need to define (==) to be alpha equality.
01:44:39 <erus`> i dunno, OCD?
01:44:46 <quicksilver> serious not rhetorical question :) term equality only matters if you have a use for it
01:44:52 <quicksilver> compilers often do not need it
01:48:30 <danr> You have to implement unification to do term equality up to alpha conversion, and I guess solve the halting problem if you want to do it up to beta (please correct me if I am wrong)
01:48:51 <danr> (for untyped lambda calculus)
01:49:30 <ddarius> You don't need to "implement unification" to write an alpha equality checker.
01:49:42 <ddarius> Even if you did, that would be really easy.
01:50:47 <danr> ddarius: Hmm, I guess you could translate it to de bruijn indicies, but what other options that that an unification do you have?
01:51:13 <danr> than that and*
01:52:57 <danr> I guess that's quite an open question, what I am really wondering is which solution did you have in mind ddarius
01:52:57 <ddarius> Just remembering that x is paired with y is not unification.  You'll never have x = y and y = z.  All you have to do is do a parallel tree traversal and verify that the lambda bound variables are used in the same way.
01:53:40 <danr> That's true indeed ;) thanks
01:54:40 <ddarius> Another, more difficult option, would be to perform the substitution at each lambda with a "fresh" constant and otherwise do normal syntactic equality.
01:56:12 <danr> True and that would be quite similar to using Bruijn indicies
01:56:47 <carpi> (sum .) . zipWith (*) <- am i correct in saying that a single parameter passed to that function is partially appplied to (sum .) and when the final parameter is passed that entire fucntion is applied to that parameter?
01:57:04 <danr> yes
01:57:06 <ddarius> It would be sort of like doing a "lazy" de Bruijn translation, except there is no ordering of the constants produced or constraints on their use.
01:57:21 <ion> @unpl (sum .) . zipWith (*)
01:57:22 <lambdabot> (\ d g -> sum (zipWith (*) d g))
01:57:31 <ddarius> It would also require substitution which alpha equality does not require and conceptually precedes.
01:57:42 <carpi> thanks for the clarification
01:57:50 <danr> ((sum .) . zipWith (*)) f = sum . zipWith (*) f
01:58:24 <carpi> how is taht?
01:58:59 <carpi> ah yes it is : )
01:59:07 <erus`> if i use de Bruijn indexes then I don't have free variables - is it still 'lambda calc' ?
01:59:21 <erus`> or do i add a type for free vairbales
02:00:39 <Ptival> lambda calculus with only closed terms
02:01:17 <Ptival> or you allow overflowing indices to access a stacked environment? :)
02:01:50 <erus`> that would break my 'show'
02:02:03 <shachaf> De Bruijn indices have free variables, of sorts. :-)
02:02:28 <erus`> maybe i should find the deepest index first then
02:02:45 <Ptival> with dependent types you could enforce them not to
02:03:14 <danr> you can do it without dependent types too
02:03:26 <Ptival> indeed
02:03:30 <danr> :)
02:03:35 <danr> nicer with DT though
02:25:30 <erus`> @hoogle Enum -> Enum
02:25:31 <lambdabot> Warning: Unknown type Enum
02:25:31 <lambdabot> Prelude id :: a -> a
02:25:31 <lambdabot> Data.Function id :: a -> a
03:02:35 <erus`> should i allways try to reduce an expression as much as possible when evaluating?
03:04:23 <sshine> recursive expressions are tricky to reduce.
03:12:28 <sshine> if they recurse infinitely, you should stop reducing at some point. if the structure of the expression is cyclical, you can choose the shortest reduction after a fix-point iteration, but if it just grows, it's hard to know when to stop.
03:20:24 <quicksilver> sshine: stop when the entire house is full of porridge
03:20:38 <Redshift64> erkin is stupid
03:20:44 <quicksilver> any more than that, and it inconveniences your neighbours.
03:20:45 <erkin> Redshift64: Thanks.
03:20:51 <Redshift64> np
03:20:54 <erkin> <3
03:55:03 <hpaste_> erus` pasted “lambda calc eval” at http://hpaste.org/56542
03:55:33 <erus`> am i doing anything silly/not-optimal  there?
03:56:15 <erus`> and i still need to parse
03:59:02 <byorgey> erus`: (1) it's silly to have to check terms for equality each time after you step, step should have type  Term -> Maybe Term  to tell you whether it stepped or not
04:00:01 <byorgey> erus`: (2) I think your step function is incomplete.  What about ((\x -> x) (\x -> x)) (\x -> x)
04:03:05 <Ptival> @hoogle (Int -> a -> b) -> [a] -> [b]
04:03:05 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
04:03:05 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
04:03:05 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:15:01 <erus`> byorgey: 2) you are correct :|
04:19:39 <byorgey> erus`: the usual approach is if you have  (e1 e2)  to first check whether e1 steps at all; if it steps to e1' then the whole expression steps to (e1' e2)
04:20:04 <byorgey> erus`: otherwise e1 must be an abstraction, in which case you can do a beta-reduction
04:20:41 <erus`>  whats a step, if not reduction?
04:21:17 <byorgey> erus`: of course, but if e1 steps it may be because there is some reduction that happens buried under many layers of application
04:21:50 <byorgey> so you have to just call 'step' recursively and see whether it can step at all
04:22:29 <erus`> ah ok
04:28:01 <erus`> byorgey: works like a charm :)
04:28:25 <erus`> simpler too
04:31:17 <erus`> is there an iterate until not changing function?
04:32:45 <funktronic> like takeWhile ?
04:33:07 <Jafet> Sure.
04:33:18 <Jafet> Platonically speaking.
04:33:26 <erus`> but takewhile cant access previous items?
04:33:52 <funktronic> @src takeWhile
04:33:52 <lambdabot> takeWhile _ []                 =  []
04:33:52 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
04:33:52 <lambdabot>                    | otherwise =  []
04:34:25 <funktronic> take that and replace the p with the element and fix it up
04:34:31 <funktronic> you just need to carry the head
04:34:57 <funktronic> hell you can just takeWhile and for p use (=) head foo
04:35:30 <funktronic> so takeWhile ((=) head foo) myList
04:46:24 <ClaudiusMaximus> > let step n x = (x / n + n / x) / 2 in (^2) . snd . last . takeWhile (uncurry (/=)) . (zip`ap`tail) . iterate (step 3) $ 1
04:46:28 <lambdabot>   mueval-core: Time limit exceeded
04:46:57 <ujm> @src reverse
04:46:58 <lambdabot> reverse = foldl (flip (:)) []
04:49:18 <erus`> @pl changes f x = case f x of { x' | x' == x -> []; _ -> f x : changes f (f x)}
04:49:18 <lambdabot> (line 1, column 27):
04:49:18 <lambdabot> unexpected "{"
04:49:18 <lambdabot> expecting variable, "(", operator or end of input
04:49:31 <erus`> can @pl handle case?
04:53:35 <erus`> @pl steps t = t : changes step t
04:53:35 <lambdabot> steps = ap (:) (changes step)
04:56:05 <sipa> :t ap
04:56:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:56:33 <frerich> :t (<*>)
04:56:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:56:59 <frerich> Hm, pity that 'Monad' isn't also an 'Applicative'.
04:57:27 <osfameron> pity?
04:58:12 <frerich> Well just like 'Applicative' has a requirement on 'Functor', 'Monad' should have one on 'Applicative' as well, no? In that acse, you wouldn't need 'ap' - you could use (<*>), right?
04:59:18 <frerich> And yo uwouldn't need "return", you could use "pure".
04:59:33 <cheater_> :t pure
04:59:34 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:59:50 <cheater_> what is the difference between "return" and "pure"?
05:00:08 <sipa> none
05:00:17 <cheater_> :t return
05:00:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:00:26 <cheater_> then why are the types different
05:00:36 <sipa> if both are defined, they should do the same thing
05:01:04 <donri> cheater_: because monads came before applicative and not all applicative functors are monads
05:01:18 <cheater_> are all monads applicative functors?
05:01:22 <donri> yes
05:01:32 <hpaste_> dp_wiz pasted “can this be made simplier?” at http://hpaste.org/56544
05:01:41 <cheater_> is there an extra axiom you need to satisfy to be an applicative functor?
05:01:57 <ClaudiusMaximus> :t [map, fmap, liftA, liftM]
05:01:57 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
05:01:58 <donri> http://www.haskell.org/haskellwiki/Functor_hierarchy_proposal
05:03:38 <cheater_> ClaudiusMaximus: ?
05:03:50 <cheater_> oh
05:03:52 <cheater_> interesting
05:04:03 <erus`> byorgey: do you know about simply typed lambda calc?
05:04:28 <dp_wiz> can someone hint me at http://hpaste.org/56544 ? (other than pointed by hlint)
05:05:02 <cheater_> lambada calculus
05:05:08 <erus`> if i wanna descript   type: x -> x    where x has to be the same as x do i have to use abstractions like in the language itself ?
05:06:40 <yitz> cheater_: all monads are applicative. but unfortunately the haskell class Monad does not require an Applicative instance.
05:07:08 <yitz> @where typeclassopedia
05:07:08 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:07:08 <cheater_> yitz: so all monads are applicative and all applicatives are monads?
05:07:23 <yitz> cheater_: not all applicatives are monads
05:07:25 <donri> no, an applicative functor doesn't have to be a monad
05:07:33 <donri> (but does need to be a functor)
05:07:34 <yitz> cheater_: see typeclassopedia, linked above
05:07:58 <cheater_> right ok sorry
05:08:12 <yitz> nothing to be sorry about :)
05:08:12 * cheater_ is not at his best right now :)
05:08:23 <cheater_> well donri just told me something i asked about :)
05:08:29 <cheater_> i didn't want to seem dismissive
05:09:04 <yitz> cheater_: we do try to be pleasant around here.
05:09:12 <yitz> so don't worry about it :)
05:10:14 <frerich> dp_wiz: Instead of 'do result <- eval env form; return $ result' you could just do 'eval env form', no? You're un-wrapping the value contained in whatever 'eval env form' yields, just to wrap it again (using return).
05:10:40 <frerich> dp_wiz: Or am I totally misunderstanding and you're asking for something else?
05:10:57 <donri> @where do
05:10:57 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
05:11:29 <cheater_> :)
05:12:27 <frerich> Hm, and there was a nice idiom if yuo do things like 'do x <- foo; return $ f x', but I forgot what it was. Some one-liner which you could use if you just extracted something and then wrapped the return value of some function applied to whatever you extracted.
05:12:47 <donri> fmap?
05:12:59 <frerich> Yes, I think it was fmap
05:13:18 <Veinor> @. pl undo \foo -> do {x <- foo; return $ f x}
05:13:19 <lambdabot> (f `fmap`)
05:14:13 <Sgeo> fmap f foo
05:14:17 <Sgeo> or f <$> foo
05:14:24 <Sgeo> (Same thing, <$> is fmap)
05:15:04 <wjt> hmm. is there a good treemap/ringchart tool for clicking around '+RTS -p' output?
05:15:24 <frerich> Sgo: Except of 'foo' is a Functor but not an Applicative :-)
05:15:35 <frerich> Oh
05:15:49 <donri> fmap is for functors
05:16:00 <frerich> I take that back, I just realized  is actually available for Fucntor, that never occurred to me! I always though it's like <*>
05:16:11 <frerich> (e.g. only for Applicative)
05:17:17 <donri> (<$>) = fmap -- it's just infix fmap
05:17:39 <donri> just happens to go well with <*> :)
05:18:11 <erus`> is this allowed: data A a = A (A a) ?
05:18:31 <erus`> Expected kind `?', but `Term' has kind `* -> *'
05:21:05 <erus`> > data A = A
05:21:06 <lambdabot>   <no location info>: parse error on input `data'
05:21:37 <Sgeo> There's no DataNotAvailableYet in Conduits
05:21:38 <Sgeo> :(
05:21:51 <sshine> frerich, if you do: do { x <- foo; y <- bar; return $ baz x y }, you can instead do: liftM2 baz foo bar. similarly for liftM3, liftM4. liftM = fmap.
05:22:31 <donri> or: baz <$> foo <*> bar
05:22:33 <frerich> sshine: Or 'baz  foo <*> bar'
05:22:37 <frerich> err
05:22:40 <cheater_> so what are those conduit things
05:22:43 <frerich> damn client eating lower-than-dollar-greater-than again
05:22:48 <cheater_> and how do they relate to lenses
05:22:57 <donri> cheater_: they're not related to lenses
05:23:09 <sshine> frerich, why does your client do that?
05:23:16 <frerich> No idea :-(
05:23:23 <frerich> It only happen with dollars, not with <*> or so
05:23:36 <Sgeo> > sequence [[1,2,3],[4,5,6]]
05:23:37 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
05:24:35 <Sgeo> Hmm
05:24:51 <Sgeo> I think thinking of the Traverseable sequence helps me understand that a bit better
05:25:07 <Sgeo> Traversable
05:26:06 <cheater_> :t sequence
05:26:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:26:14 <Sgeo> :t Data.Traversable.sequence
05:26:15 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
05:26:21 <cheater_> is "sequence" like transposition?
05:26:38 <rtharper> :t sequence
05:26:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:26:40 * rtharper has to remember what that one does
05:26:42 <rtharper> ah
05:26:44 <rtharper> umm
05:26:46 <rtharper> not really
05:26:49 <rtharper> it takes a list of computations
05:26:55 <cheater_> oh right yes
05:27:04 <rtharper> runs each of them, and collects the results
05:27:13 <cheater_> is there something which swaps monads?
05:27:26 <cheater_> let's say i have a list of lists, and want to transpose
05:27:39 <cheater_> not sure if tuples are monadic, but if i have a list of tuples, i could want a tuple of lists
05:27:47 <rtharper> so m (m a) -> m (m a)
05:28:01 <cheater_> more like m (n a) -> n (m a)
05:28:03 <rtharper> right
05:28:13 <cheater_> @hoogle m (n a) -> n (m a)
05:28:13 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:28:13 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
05:28:13 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
05:28:43 <cheater_> interesting.
05:28:50 <cheater_> is every monad traversable?
05:28:50 <erus`> that feel when reusing term structure for types :)
05:28:55 <erus`> get ready for meta programming
05:29:06 <cheater_> is every traversable monad?
05:29:11 <cheater_> a monad
05:29:18 * Sgeo notes that Foldable has _ versions of stuff found in Traversable
05:31:50 <quicksilver> cheater_: no.
05:32:49 <quicksilver> traversable lets you do transformations which keep the shape the same
05:32:54 <quicksilver> it's like Functor only more so.
05:33:18 <quicksilver> "join", which you need to be a monad, needs to do some kind of collapse operation, and that's not shape preserving.
05:33:58 <cheater_> ok so traversable and monad are mutually exclusive?
05:34:21 <j2jx> ````~fgahya 86x v'[fv7w1 ] '0o fv f 6`f126 f    gww f d9ps gv . '0- m]]m
05:39:18 <ion> [91PP[dx]93PP]dx
05:40:03 <quicksilver> cheater_: not at all.
05:40:11 <quicksilver> cheater_: lists are both traversable and monad.
05:40:39 <quicksilver> cheater_: the point is that traversable is "not enough" to give you monad
05:41:06 <hpc> ziplists are traversable, yes?
05:41:29 <ddarius> Distributive laws form monads in a particular category.
05:41:35 <quicksilver> well their zippiness is not relevant, hpc
05:41:44 <cheater_> quicksilver: ok so..
05:41:50 <quicksilver> you can use the same traversable instance you'd use for standard lists
05:42:06 <cheater_> quicksilver: monads aren't necessarily traversable, and traversables are not necessarily monads, but they have some common axioms?
05:42:10 <quicksilver> (they have compatible Functor instances, which is the extent of their overlap)
05:42:26 <quicksilver> cheater_: they have Functor in common.
05:42:31 <cheater_> k
05:46:27 <erkin> I like how some people think GHC stands for "GNU Haskell Compiler".
05:46:53 <donri> Glasgow Compiler Collection
05:47:08 <erkin> Ahahah. I'll use that.
05:47:15 <cheater_> doesn't it
05:47:30 <Sgeo> o.O I have never seen GNU Haskell Compiler
05:47:35 <Sgeo> Should I count myself lucky?
05:48:21 <erkin> Yes.
05:48:42 <donri> cheater_: no, the ghc is the glasgow haskell compiler
05:49:05 <cheater_> there was no question mark there :p
05:49:07 <hpc> technically, "Glorious Glasgow Haskell Compilation System"
05:49:10 <hpc> :P
05:49:19 <erkin> GGHCS
05:50:13 <erus`> > let a ***hello b = 1
05:50:14 <lambdabot>   <no location info>: Parse error in pattern
05:50:31 <erus`> > let a ***hello b = 1 in 1 ***hello 2
05:50:32 <lambdabot>   <no location info>: Parse error in pattern
05:51:48 <Sgeo> What's the Codensity monad?
05:52:57 <cheater_> ...?
05:53:00 <cheater_> interesting.
05:53:10 <cheater_> something that has to do with statistical density?
05:53:13 <cheater_> perhaps?
05:53:27 <frerich> quicksilver: With 'Traversable preserves the shape' you mean to emphasize that Traversable only sees one element at a time whereas Functor sees the complete value inside the context at once?
05:54:45 <erus`> instance Show (Term Type) where <- can i make this work without extensions?
05:55:39 <byorgey> erus`: yes, I know about STLC
05:56:06 <byorgey> erus`: I think you need FlexibleInstances for that, but FlexibleInstances is one of the most benign and uncontroversial extensions there is
05:56:09 <quicksilver> frerich: no.
05:56:18 <quicksilver> frerich: traversable and functor both preserve the shape
05:56:41 <quicksilver> frerich: traversable is a slightly stronger notion which lets you tangle an 'effect' along with your shape-preserving function
05:56:59 <quicksilver> where functor only permits a parametric (natural) function to be applied evenlyl
05:57:23 <frerich> quicksilver: Oh, okay - that's what I understood. But you said 'traversable lets you do transformations which keep the shape the same' and then 'it's like Functor only more so.' and I somehow read 'Functor may or may not preserve shape, Traversable certainly does' into that somehow :-}
05:57:23 <byorgey> Sgeo: see http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
05:57:46 <frerich> quicksilver: ...so I was wondering about your definition of shape, but ok - thanks for clarifying.
05:58:02 <hpc> frerich: the "shape" varies
05:58:09 <Sgeo> byorgey, thanks
05:58:22 <hpc> frerich: for IO, it would be "doesn't do side effects"; for [], it would be "the length and order of elements is the same"
05:58:39 <Sgeo> byorgey, this looks like an explanation of something that I don't even know how to use
05:59:02 <byorgey> Sgeo: hehe, that may be so
05:59:38 <byorgey> Sgeo: it's only useful in certain specific situations
05:59:58 <byorgey> Sgeo: in particular, it's useful for speeding up "left-nested" uses of (>>=)
06:11:37 <sparkleshy> @pointless f g h = (\a b -> g (h a) (h b))
06:11:37 <lambdabot> f = join . ((flip . ((.) .)) .) . (.)
06:11:42 <sparkleshy> o_O
06:11:45 <sparkleshy> oh dear
06:12:02 <sparkleshy> should I just stick with the pointful form?
06:12:12 <ion> No, join . ((flip . ((.) .)) .) . (.) is much more readable.
06:12:29 <byorgey> sparkleshy: a better way to write that is  g `on` h
06:12:56 <byorgey> > (g `on` h) a b
06:12:57 <lambdabot>   Ambiguous type variable `b' in the constraints:
06:12:58 <lambdabot>    `GHC.Show.Show b'
06:12:58 <lambdabot>      a...
06:13:08 <byorgey> > (g `on` h) a b :: Expr
06:13:09 <lambdabot>   Ambiguous type variable `b' in the constraints:
06:13:09 <lambdabot>    `SimpleReflect.FromExpr ...
06:13:42 <byorgey> well, you get the idea
06:13:50 <ion> > ((g :: Expr -> Expr -> Expr) `on` h) a b
06:13:51 <lambdabot>   g (h a) (h b)
06:14:02 <byorgey> aha
06:14:43 <mm_freak> haskell has ruined me for all other areas of math that use the "co-" prefix
06:15:08 <byorgey> mm_freak: eh? why is that?
06:15:28 <mm_freak> because i find myself getting overexcited by words like "colinear" =)
06:15:54 <byorgey> The "co-"s don't really belong to Haskell, it gets them all from category theory
06:16:19 <mm_freak> i know, but CT has always been over my head…  i understand the corresponding concepts in haskell
06:16:19 <sparkleshy> @pointless f g h = (\a b -> g (h a) b)
06:16:20 <lambdabot> f = (.)
06:16:26 <sparkleshy> @pointless f g h = (\a b -> g a (h b))
06:16:27 <lambdabot> f = flip . ((.) .)
06:16:29 <dever> is there anyway i can check if a number is NaN?
06:16:36 <mm_freak> dever: isNaN
06:16:37 <sparkleshy> okay, `on` is cool :D
06:16:53 <mm_freak> > isNaN (0/0)
06:16:54 <lambdabot>   True
06:17:01 <dever> mm_freak: thats blindingly obvious, thanks!
06:17:03 <byorgey> mm_freak: well, if you understand the corresponding concepts in Haskell then you understand some category theory.  You just don't understand them at the maximal level of generality.  But no one does.
06:17:24 <mm_freak> dever: look into the RealFloat class, it has more functions like that
06:17:34 <mm_freak> isInfinite, etc.
06:18:16 <byorgey> In CT you are always straining to grok that one next level of abstraction that you can't quite get your head around.  And there is always a next level.
06:18:22 <mm_freak> byorgey: that's good to know…  my problem with learning CT is that i just don't know what to do with that knowledge
06:18:48 <mm_freak> sounds reasonable
06:18:50 <byorgey> mm_freak: sure, then don't bother.
06:19:26 <mm_freak> i think i gave up when trying to understand limits and colimits in general
06:19:51 <mm_freak> probably i did understand them, but didn't really know how to do anything with them
06:20:13 <mm_freak> as far as i understand CT it's more or less just a language
06:21:03 <Sgeo> CT?
06:21:12 <mm_freak> category theory
06:22:19 <mm_freak> the depressing part is that i see people actually applying CT to real world stuff, so there seems to be some really powerful stuff going on, but i never found out how to exploint that power
06:22:34 <mm_freak> -n
06:23:19 <quicksilver> CT is study of "hmm, that reminds me of..." applied to mathematics. When it works well it enables you to transfer results or techniques from one area to another, where they may appear novel.
06:24:45 <mm_freak> quicksilver: i guess the question is:  how can you exploit CT if you only know one area of math?  or worse, if you don't know a lot of math, but you are a haskell programmer
06:25:19 <quicksilver> in some cases, general CT results tell you something interesting about the structure of haskell programs and types
06:25:26 <quicksilver> but practically the answer is probably "no"
06:25:48 <mm_freak> i see
06:27:44 <erus`> @hoogle (a, b) -> (a -> b -> c) -> c
06:27:45 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
06:27:45 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
06:27:45 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
06:28:26 <erus`> uncurry seems like the wrong way round compared to >>=
06:29:40 <mm_freak> erus`: it makes more sense that way…  you "uncurry" a function, then apply an argument to it
06:30:16 <byorgey> erus`: that's because (>>=) is the wrong way round compared to ($)
06:31:45 <NapHtaKeRoSene> would you call a 2x2 matrix type matrix2d_t or matrix_2x2_t ?
06:32:28 <erus`> M2
06:32:55 <NapHtaKeRoSene> hehe
06:32:55 <quicksilver> haskell types begin with capital letters
06:33:04 <quicksilver> so, Matrix2 or Matrix2D
06:33:09 <NapHtaKeRoSene> erg<< well... M2 is short
06:33:29 <NapHtaKeRoSene> erus`
06:33:50 <ion> quicksilver: It’s a troll whose MO is to wake up every once in a while and ask random C questions here. It’s best to ignore it.
06:34:40 <NapHtaKeRoSene> ignoring *.fi ;/
06:34:55 <erus`> thats reasonably funny, perhaps because its the first time i have seen it
06:35:40 --- mode: ChanServ set +o quicksilver
06:35:47 --- mode: quicksilver set +b *!*lambda@*.lesbianbath.com
06:35:47 --- kick: NapHtaKeRoSene was kicked by quicksilver (how about we all ignore it together?)
06:36:15 <erus`> i give him 4/10 for the idea, but no bites
06:36:49 <cheater_> 2/10 here
06:38:36 <DanBurton> appending _t to type names in C bothers me
06:38:42 --- mode: quicksilver set -b *!*lambda@*.lesbianbath.com
06:38:49 --- mode: quicksilver set -o quicksilver
06:40:15 <Veinor> StringT
06:40:22 <SPHN> Hello. I have a question about nested data parallel Haskell, if anyone knows about that. Why can't you achieve the same effect by using a parallel map operation, that we already had, and within that parallel map, doing another parallel map?
06:41:39 <erus`> i love it when a line seems like its gonna be really long and then fits in exactly 80 characters :)
06:41:56 <Veinor> i don't care about the 80-character limit, personally
06:42:21 <erus`> enjoy not using screen space effectively
06:42:33 <Veinor> it's 2012, we have monitors with resolution measured in kilopixels
06:42:48 <srhb> Was that ever the issue? The point readability, I believe.
06:42:54 <erus`> yeah but fonts need to be bigger as dpi increases
06:43:37 <roconnor> SPHN: load balancing
06:44:02 <Veinor> either way
06:44:04 <SPHN> roconnor: thanks, but can you expand on that?
06:44:07 <Veinor> i stick to a roughly 100-character limit
06:44:29 <bl4ckcomb> I think my haskell program just defeated Chuck Norris O.O
06:44:40 <bl4ckcomb> it used lfold
06:45:04 <byorgey> bl4ckcomb: well, defeating Chuck Norris 0.0  is not that hard.  Try Chuck Norris 1.0.
06:45:30 <bl4ckcomb> byorgey, didn't bruce lee kill 1.0 ?
06:45:36 <sshine> or any other non-zero multiplication of Chuck Norris.
06:46:33 <byorgey> bl4ckcomb: 2.0 then.  Anyway, what is lfold?
06:47:02 <bl4ckcomb> left folding a list
06:47:20 <sshine> I think it is usually called foldl.
06:47:27 <roconnor> SPHN: each parallel map in your parallel map could be of a different size, so a processor doing one parallel map might finish well before the processor on another parallel map ... I guess.
06:47:30 <bl4ckcomb> oh right, my bad
06:48:12 <SPHN> roconnor: so data parallel Haskell looks at the entire job at once and schedules it based on all that info... i see. thanks
06:48:33 <roconnor> does GHC 7.4 have an Eq constraint in Num?
06:49:42 <erus`> can i read anywhere about the type function (->)
06:49:46 <Veinor> roconnor: nope
06:50:55 <quicksilver> erus`: what would you like to read? From one perspective there is nothing to say, it's so basic. From another perspective, most of the literature about intuitionistic logic is about (->)
06:52:24 <erus`> quicksilver: why does it have the kind ?? -> ? -> *
06:52:41 <quicksilver> it doesn't, except in GHC
06:53:02 <quicksilver> that's an implementation quirk of GHC to do with the precise way it handles unboxed values and unboxed tuples.
06:54:07 <erus`> oh cool
06:54:35 <quicksilver> erus`: http://stackoverflow.com/questions/3034264/haskell-weird-kinds-kind-of-is
06:54:40 <erus`> whats the next level up from kind?
06:54:53 <ion> sort IIRC
06:55:19 <erus`> how meta does it get ?
06:56:39 <carpi> does anyone else think that haskell would be a perfect candidate for a programming environment that encourages "constructing" or "building" programs as opposed to "writing" programs?
06:57:04 <carpi> or rather.. a perfect candidate to be used in such a programming environment
06:57:32 <donri> no idea what you mean
06:57:34 <daimrod> smalltalk ?
06:57:45 <benj_> what do you mean by 'environment' - some kind of RAD app builder? or a developer culture in, say, a workplace?
06:57:55 <ion> erus: Go too far and you’re playing with dangerous powers.
06:58:05 <donri> are you talking about something like http://chrisdone.com/posts/2011-12-17-concept-for-editing-asts-rather-than-text.html ?
06:58:39 <carpi> one moment please.. let me take a  look . i be back
06:58:40 <geekosaur> erus`, there's a programming language (omega) which allows arbitrary levels
07:01:50 <carpi> thanks fror showing that video. very interesting. but does that kind of environment increase productivity? or rather the joy of coding?
07:02:54 <erus`> I think i can implement that in my system :|
07:03:11 <erus`> the question is, would i be useful
07:03:54 <carpi>  if it improves productivity by an order of magnitude.. then i suppose it is inherently more useful
07:05:21 <erus`> whats the difference between dependant types and (EvenNumber Integer) ?
07:05:23 <carpi> in any case.. that was not what i had in mind.. I was thinking more like an environment that allows the placement of code blocks in some sort of order instead of typing code
07:05:35 <erus`> is it that EvenNumber can be odd?
07:06:14 <erus`> it all boils down to proving it ?
07:06:17 <danr> erus`: what is that? is it a QuickCheck newtype?
07:06:35 <erus`> no its a hypothetical type
07:06:50 <danr> in Agda, you can have an argument be (x : Integer) and another argument is a proof that it is even
07:19:54 <dever> strange nuance i found today. NaN in haskell is positive, (e.g. sqrt (-1.0)), whereas the equivalent in C is negative.
07:20:11 <HugoDaniel> hi
07:20:18 <HugoDaniel> i need some help with aeson and json parsing
07:21:12 <HugoDaniel> im trying to parse something like this: { caption: null } (when no caption is present), and { caption: { text: "this is a caption" } } (when there is a caption)
07:21:30 <HugoDaniel> into a datatype "MyData { caption :: Maybe String }"
07:21:35 <HugoDaniel> so
07:24:17 <sparkleshy> @pointless (\x -> x `mod` 7 /= 0)
07:24:17 <lambdabot> (0 /=) . (`mod` 7)
07:24:24 <HugoDaniel> http://hpaste.org/56545
07:24:36 <HugoDaniel> this is what i currently have
07:24:41 <HugoDaniel> its the fruit of despair :)
07:24:51 <sparkleshy> @pointless (\a b -> a `mod` b /= 0)
07:24:52 <lambdabot> flip flip 0 . ((/=) .) . mod
07:24:57 <sparkleshy> waugh :(
07:26:17 <ion> @type (0 /=) .: mod
07:26:18 <lambdabot> forall t. (Integral t) => t -> t -> Bool
07:26:35 <ion> (I’d just write it in poinful form.)
07:27:00 <dever> HugoDaniel: you would want to create your MyData along the lines of: for null: MyData Nothing - for caption: MyData (Just "caption")
07:27:19 <HugoDaniel> thanks dever
07:27:22 <Jaak> :t let (.:) = (.).(.) in (/= 0) . (uncurry mod .: (,))
07:27:23 <lambdabot> forall a. (Integral a) => a -> Bool
07:27:40 <dever> HugoDaniel: np.
07:27:40 <Jaak> er no
07:28:01 <sparkleshy> @unpl (/= 0) .: mod
07:28:01 <lambdabot> ((\ a -> a /= 0) .: mod)
07:28:10 <sparkleshy> @unpl (/= 0) . mod
07:28:10 <lambdabot> (\ d -> (mod d) /= 0)
07:28:27 <sparkleshy> @unpl (\x -> (/= 0) . mod x)
07:28:27 <lambdabot> (\ x d -> (mod x d) /= 0)
07:28:43 <erus`> is maybe a sum type?
07:28:52 <erus`> or a set type?
07:29:02 <Jaak> maybe (/= 0) .: uncurry mod .: (,)
07:29:07 <parcs`> Maybe a is Either () a
07:29:58 <ion> parcs: Ignoring bottoms
07:32:03 <parcs`> Either !() a :D
07:32:46 <Sgeo> What's .:
07:32:58 <Sgeo> Oh, that thing that I don't understand
07:33:13 <parcs`> f .: g = \a b -> f (g a b)
07:33:31 <parcs`> .: = (.) . (.) = fmap . fmap = fmap fmap fmap
07:34:07 <parcs`> > case (Left undefined :: Either !() a) of Left _ -> ()
07:34:08 <lambdabot>   Unexpected strictness annotation: !()
07:34:25 <parcs`> > case Left undefined of Left !_ -> ()
07:34:26 <lambdabot>   *Exception: Prelude.undefined
07:35:21 <Jaak> oh the fmap fmap fmap is just loveley
07:38:49 <tromp> :t (.).(.)
07:38:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:40:26 <Sgeo> Might be easier to understand:
07:40:39 <Sgeo> :t (Prelude..) Prelude.. (Prelude..)
07:40:40 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:40:41 <funktronic> widly offtopic but i saw that and i thought "boobies"
07:41:49 <dmwit> erus`: What is a set type?
07:42:09 <erus`> like GADT, many constructoirs
07:43:22 <dmwit> ?
07:43:30 <dmwit> Did you just make this word up, or what?
07:44:18 <srhb> i and o are fairly close in Querty, I don't think it was a diminutive constructor. :-)
07:44:28 <srhb> (Though it does sound cute)
07:44:46 <HugoDaniel> dever: http://hpaste.org/56545  <- at least it compiles, im going to test it now
07:44:49 <HugoDaniel> :)
07:44:57 <dmwit> Oh, no, I know constructoir was a typo. But I've never heard of a "set type", and it seems like erus` hasn't either given his definition.
07:45:13 <erus`> agda called it a Set
07:45:26 <dmwit> Set in Agda is * in Haskell.
07:45:34 <dmwit> That is, all types.
07:45:50 <HugoDaniel> it works fine
07:45:52 <HugoDaniel> thanks :)
07:46:07 <sparkleshy> If I give an expression like `sum $ map phi [2..1000000]` to GHCI, it runs but takes hours. (phi is the euler totient function, but it could be anything that takes a little while to compute)
07:46:23 <Saizan> (not quite all types, but close enough for the current discussion)
07:46:28 <sparkleshy> But if I break it up into some parts like `map (\x -> sum $ map phi [x*100000+1 .. (x+1)*100000]) [1..9]` it runs much, much faster.
07:46:31 <sparkleshy> What.
07:47:06 <sparkleshy> * er, `sum $ map (\x -> sum $ map phi [x*100000+1 .. (x+1)*100000]) [0..9]`
07:47:27 <dever> HugoDaniel: that looks fine!
07:47:41 <dmwit> sparkleshy: sum is written badly for hysterical raisins
07:48:00 <dmwit> sparkleshy: And ghci doesn't do optimization, so it won't fix it automatically.
07:48:16 <dmwit> sparkleshy: Either compile your code (which should make the two run about the same speed), or write sum' = foldl' (+) 0
07:48:40 <dmwit> s/compile your code/compile your code with -O2/
07:48:51 <sparkleshy> Oh.
07:48:56 <srhb> sparkleshy: http://www.haskell.org/haskellwiki/Memory_leak This might interest you
07:49:05 <srhb> sparkleshy: It touches upon the strictness issue.
07:49:50 <sparkleshy> oooooooooo
07:49:56 <sparkleshy> that makes sense now! Thanks!
07:52:02 <rwbarton> It doesn't seem like that would make the difference between "hours" and "much, much faster"
07:52:57 <rwbarton> (well, compiling with -O2 might very well, but splitting the sum up in ghci wouldn't)
07:53:40 <dmwit> Depends how much memory it was leaking.
07:53:43 <dmwit> Perhaps he was swapping.
07:53:44 <rwbarton> Unless you're running on a machine with a tiny amount of memory, or something.
07:53:46 <rwbarton> Yeah
07:59:03 <sparkleshy> It had about 1GB to do it in... by "hours" and "much much faster" I probably mean like "90min" and "20min"
07:59:07 <rwbarton> But on my machine, sum $ map id [2..1000000] takes under 3 seconds, so it's hard to imagine you could be getting "hours" of overhead
07:59:14 <rwbarton> (in ghci)
07:59:40 <sparkleshy> that takes about 5 seconds for me
08:00:16 <rwbarton> Did replacing sum by  foldl' (+) 0  make your original program much faster?
08:00:21 <dmwit> Well, my hypothesis is easy to test. Does the un-chunked version of the code with sum' make it much faster?
08:00:27 <dmwit> rwbarton++
08:01:00 * Sgeo blinks a few times
08:01:15 <Sgeo> I think that reactive-banana's AddHandler type forms a monad
08:01:18 <Sgeo> Not certain though
08:01:23 * Sgeo flips out a few times
08:02:34 <sparkleshy> Am testing; my implementation of phi is pretty slow.
08:06:23 <sparkleshy> dmwit: hypothesis is correct :) It takes about 10min.
08:06:56 <dmwit> Could you hear the long version swapping?
08:07:16 <dmwit> Because, in retrospect, I have to agree with rwbarton: that speedup seems amazing.
08:08:03 <rwbarton> I wonder if you've somehow switched from Integer to Int, or something like that.
08:09:33 <rwbarton> Oh, well, maybe if phi itself does a lot of allocation?
08:09:46 <sparkleshy> ...I'm just going to be happy and go on my way.
08:09:56 <sparkleshy> Am still newbie.
08:10:30 <dmwit> rwbarton: Still, presumably only one phi would be allocating at a time, right?
08:10:50 <dmwit> The total memory leak of sum ought to be proportional to the spine size, not anything else.
08:10:57 <rwbarton> maybe he's copying those thunks built up by sum many times. Though I thought that's what the generational garbage collector was supposed to avoid
08:11:14 <rwbarton> like, every time he has to do a garbage collection caused by phi allocating lots
08:11:23 <dmwit> oh, huh
08:12:07 <rwbarton> I don't really know enough about the garbage collector to speculate intelligently
08:12:46 <rwbarton> but maybe the generation heuristics are not working well on his program
08:14:44 <hoverbear> Anyone know if the haskell ebuild in gentoo is still only building on 1 thread?
08:16:07 <hpaste_> Sgeo pasted “Functor instance for AddHandler (here called Event). Not sure if this is correct, but at least it does compile.” at http://hpaste.org/56547
08:18:29 <Saizan> AddHandler might have weird invariants preventing that instance to make sense, though i can't think of any
08:20:50 <Sgeo> I'm pretty sure I can write mconcat then define mappend in terms of mconcat. More efficient that way I think
08:25:05 <carpi> i get a parse error when I do "_ and2 _ = False". am i missing something?
08:26:07 <krakrjak> _ `and2` _ = False maybe?
08:26:10 <geekosaur> you intend and2 to be an operator?  must use backquotes around it
08:26:10 <Sgeo> carlocci, and2 is not an operator, if you want to define it as though an operator, surround with ``
08:26:44 <donri> or name it with punctuation
08:26:45 <carpi> i think i should put it in brackets in the signature like (and2) :: Bool -> Bool -> Bool
08:27:19 <donri> that's not necessary
08:27:21 <geekosaur> the parentheses don't do anything there
08:28:14 <carpi> tak.. thanks. now it works.. backquotes it was
08:29:58 <Sgeo> Why is mempty necessary in Monoid?
08:30:32 <c_wraith> because it's not a Semigroup
08:30:34 <luite> a mathematcial monoid is an associative operation with identity element
08:30:43 <luite> +set with
08:31:21 <Sgeo> I can write the identity element, but it just feels... bizzare
08:31:33 <Sgeo> As though likely no one would ever actually use the identity
08:31:39 <tty7> is it possible to define your own (*) or (+) function or anything on your own types?
08:32:01 <c_wraith> Sgeo: there's a lot of code that abstracts over Monoids and uses the identity element
08:32:13 <mauke> who needs 0 anyway
08:32:16 <c_wraith> tty7: sure, just create a Num instance for your type
08:32:27 <mauke> is 0 even a number?
08:32:42 <c_wraith> 0 is failure to malloc
08:33:09 <tty7> c_wraith:  but to create a Num instance, I would also have to define abs, signum and fromInteger and all that
08:33:14 <luite> yep
08:33:45 <tty7> what if i only want (+) and (*)
08:33:46 <luite> tty7: it isn't possible to make something where (+) works, but not (*)
08:33:55 <luite> tty7: same for the others
08:34:04 <luite> (unless you use a custom prelude)
08:34:09 <qpu> tt7: you could define abs = error "not implemented"
08:34:14 <tty7> too bad :/
08:34:22 <tty7> well, okay
08:34:24 <c_wraith> tty7: what's your type?
08:34:26 <luite> yeah you could do that :)
08:34:36 <c_wraith> tty7: is this something that's strictly just a ring?
08:34:43 <tty7> but there'd be no compiler error warnings then :/
08:34:43 <qpu> tty7: for reference, there's a fun use of Num here http://book.realworldhaskell.org/read/data-structures.html
08:34:48 <c_wraith> if so, then you could look at the Numeric Prelude
08:34:59 <tty7> yeah, in that case it may be
08:35:09 <geekosaur> tty7, this touches on the whole "everyone want to redesign Num but nobody agrees how to do it"
08:35:15 * Sgeo feels weird doing newMVar undefined
08:35:28 <tty7> actually i am thinking about vector spaces, so in fact (*) isnt a -> a -> a but a -> a -> b
08:35:33 <c_wraith> Sgeo: what's wrong with newEmptyMVar?
08:35:50 <c_wraith> tty7: there are probably classes for that somewhere already
08:35:56 <tty7> and i am pretty sure there exist modules for that, but i try to implement it by myself
08:35:58 <tty7> ;)
08:36:04 <Sgeo> I'm giving the MVar to a bunch of threads, don't want one going off early just because it's first
08:36:08 <Sgeo> I guess, I'm not sure
08:36:22 * Sgeo makes it an empty MVar
08:36:25 <c_wraith> tty7: then import Prelude hiding (Num(..)), and define your own class
08:36:26 <luite> tty7: yep vector spaces aren't good, that's why they use other operators in existing packages
08:36:31 <Sgeo> If the events are coming in that close :/
08:36:39 <luite> arent a good match for Num
08:36:55 <tty7> geekosaur: okay. so overwriting existing functions is generally only possible if you make the type an instance of a class with that function?
08:36:57 <c_wraith> Or just use different operator names.
08:37:16 <c_wraith> well.  the only form of "overriding" is with classes
08:37:23 <tty7> okay
08:37:24 <tty7> thanks
08:37:25 <geekosaur> tty7, if the function is part of a typeclass, yes
08:37:36 <tty7> typeclass, yes
08:37:48 <tty7> luite: what do you mean "aren't good"?
08:37:50 <c_wraith> Otherwise you're just shadowing or defining the same name in another place
08:38:04 <tty7> i see
08:38:12 <luite> tty7: aren't a good match for Num, since (*) usually has the wrong type
08:38:22 <luite> depending on what you want (*) to mean
08:38:27 <tty7> ah, yes
08:38:39 <tty7> yep..
08:39:10 <qpu> yeah, you can shadow (+). make your own type class or just define a top-level function named (+). you may have to qualify it like Main.+ to distinguish it from Num.+
08:39:44 <tty7> and i guess it isn't possible as well to define (*) - or maybe "mult" to avoid overriding - to allow both a -> a -> b and b -> a -> a?
08:41:09 <tty7> qpu: the point is, that i dont want to write Main.+ or smth, I  could do "mult" then as well ;)
08:41:22 <tty7> it would just be nice to avoid that and use the standard "*" instead
08:41:36 <luite> tty7: you might want to have a peek at the vector-space package, since the 'b' type is not quite arbitrary, it must be of the scalar field that you have a vector space over. vector-space uses an associated type for that
08:41:57 <tty7> yeah, i dont mean a and b to be arbitrary types
08:42:15 <tty7> i see, i will have a look at the package
08:42:40 <Ptival> how does one wrap a long let line inside a do block?
08:43:54 <donri> in "let x = y", "y" must be indented more than "x" if it wraps
08:44:13 <Ptival> than the beginning of x or the whole x?
08:44:25 <donri> than the column where x starts
08:44:30 <Ptival> ok
08:45:30 <Ptival> or is there a cool way of doing
08:45:37 <Ptival>   let (start, end, align1, align2) =
08:45:38 <Ptival>         (read start_s, read end_s, read align1_s, read align2_s)
08:46:11 <Ptival> (heterogen types)
08:46:35 <hpaste_> Sgeo pasted “Monoid instance” at http://hpaste.org/56548
08:46:41 <erus`> is there a more specific name than type for a 'data'
08:46:46 <donri> @hoogle uncurry4
08:46:46 <lambdabot> No results found
08:46:56 <Ptival> datatype? :)
08:47:06 <Sgeo> ...I forgot to handle
08:47:12 * Sgeo blinks at self
08:47:13 <donri> algebraic data type
08:47:17 <donri> "record"
08:47:18 <quicksilver> erus`: losely, they are algebraic data types.
08:47:35 <quicksilver> however, haskell data can include non-algebraic types
08:47:40 <quicksilver> so that's not really a precise term
08:48:04 <Ptival> quicksilver: like what?
08:48:12 <erus`> quicksilver: a non algebraic type would have a single constructor?
08:48:23 <quicksilver> IO is non-algebraic
08:48:40 <quicksilver> but can say data Foo a = Baz (IO a) | Bam (a -> a)
08:48:45 <quicksilver> that's all I meant.
08:49:36 <Sgeo> forkIO $ handle =<< takeMVar finalData
08:49:40 <Sgeo> That should fix it
08:50:18 <erus`> quicksilver: is that no algebraic? i need to read up on this
08:50:34 <quicksilver> erus`: I don't think there is a very precise consensus.
08:50:41 <quicksilver> the terms are used imprecisely more often.
08:51:36 <quicksilver> often the meaning is as basic as "a language like C provides simple types like int, char, and float, while functional programming languages typically allow you to define new "algebraic" data types by combining these
08:52:06 <cheater_> uh
08:52:08 <cheater_> struct
08:53:29 <Sgeo> struct implies an and relationship. Or relationships are possible in algebraic data types
08:53:50 <cheater_> explain
08:53:56 <koala_man> union
08:54:15 <cheater_> ^
08:54:21 <Saizan> yeah, union + a tag is a way to encode sum types
08:54:35 <Saizan> but it's not the real thing
08:54:36 <applicative> data SN = S Int | N Char
08:54:53 <Saizan> anyhow it's still more than just "primitive types"
09:02:56 <erus`> type constructors are functions and type functions
09:03:28 <erus`> no thats a lie
09:07:32 <qpu> i'm curious why it's not idiomatic to have single-function type classes like "Multiply" and "Add" and compose them like sumOfSquares :: (Multiply a, Add a) => [a] -> a
09:08:07 <qpu> rather than a class like Num
09:08:38 <koala_man> many people have argued that a typeclass shouldn't have more than one function
09:09:08 <qpu> does that approach become a mess somehow?
09:09:23 <koala_man> some of the decisions in Prelude might have been made differently today
09:09:25 <erus`> after you add two numbers do you get back an Add? what if i wanna Subtract now?
09:09:44 <qpu> erus` you get back "a", which might be an Int or whatever
09:10:35 <sipa> qpu: maybe performance reasons?
09:10:52 <sipa> more typeclasses -> more dictionnaries being passed around
09:11:19 <MostAwesomeDude> qpu: AFAICT it's because of how Scheme laid out numbers.
09:11:24 <qpu> does that degrade runtime performance or just the compiler's performance?
09:11:32 <sipa> runtime
09:11:42 <sipa> not sure if it's significant though
09:12:18 <_oz> qpu: I think one reason is that, as the technology stands it would clutter things too quickly
09:12:49 <_oz> proposals like (http://repetae.net/recent/out/classalias.html) try to bring best of both worlds
09:13:04 <qpu> it kind of seem like one-method type classes put you back to the ad-hoc system type classes were designed to address
09:13:40 <qpu> _oz: thanks for the link, i'm not familiar enough with haskell to know where to look sometimes :]
09:14:27 <Enigmagic> _oz: i think constraint kinds (in 7.4.1) do that
09:14:42 <_oz> do what?
09:14:50 <_oz> i'd be surprised if they did.
09:14:51 <Enigmagic> _oz: class aliasing
09:15:21 <hpaste_> shokodrink pasted “data stuff” at http://hpaste.org/56551
09:15:22 <Enigmagic> e.g type Stringy a = (Show a, Read a)
09:15:27 <rwbarton> there is also a point of view where type classes can (informally) carry laws
09:15:30 <shokodrink> why do i get an error here?
09:15:49 <rwbarton> if you write an instance for the type class, you have a proof obligation that the laws hold; if you write a function which is generic over the type class, you can assume that the laws hold
09:15:56 <roconnor> @tell edwardk thanks to you, now I want to generalize my binary radix tree implementation to arbitrary representable functors.
09:15:56 <lambdabot> Consider it noted.
09:16:00 <_oz> Enigmagic: hmm, thats nice.
09:16:05 <roconnor> @tell edwardk I hate you :P
09:16:06 <lambdabot> Consider it noted.
09:16:24 <_oz> it would also be nice if one could directly define an instance of Thingy (which in turn defines instances of Show and Read)
09:16:36 <sipa> roconnor: resist the temptation!
09:16:53 <applicative> shokodrink: You need to wrap Bool
09:17:31 <Enigmagic> yeah
09:17:37 <shokodrink> applicative: i dont know what you mean by that
09:17:51 <rwbarton> typically these laws will involve more than one function... for example, Monad
09:18:03 <applicative> shokodrink: just a sec i'm 'annotating' the paste
09:18:44 <_oz> rwbarton: but you can still talk about those laws using the class alias, which combines the smaller type classes. can't you?
09:18:53 <rwbarton> though you could define class HasReturn m where return :: a -> m a; class HasBind m where (>>=) :: m a -> (a -> m b) -> m b; class (HasReturn m, HasBind m) => Monad m where {- the monad laws hold -}, the classes HasReturn and HasBind aren't useful at all in practice
09:18:58 <rwbarton> you can, yes
09:19:35 <qpu> rwbarton: that matches my intuition. i was about to try that myself
09:19:36 <hpaste_> applicative annotated “data stuff” with “data stuff (annotation)” at http://hpaste.org/56551#a56552
09:19:38 <_oz> HasReturn is useful. for example for Applicative..
09:19:39 <rwbarton> you can also write things like class Ring a => CommutativeRing a where {- no new functions, but multiplication is commutative -} and form a lot of 0-method type classes
09:19:49 <_oz> and it is called Pointed by some.
09:20:05 <rwbarton> it may be barely useful, okay
09:20:16 <applicative> shokodrink: see the paste http://hpaste.org/56551#a56552 .  You can't just use a naked Bool the way you did.
09:20:17 <rwbarton> it's less useful without a functor superclass :)
09:20:52 <sparkleshy> @type fint = fromIntegral
09:20:53 <lambdabot> parse error on input `='
09:20:58 <sparkleshy> @type let fint = fromIntegral
09:21:00 <lambdabot> <no location info>: not an expression: `let fint = fromIntegral'
09:21:19 <shokodrink> applicative: i thought haskell ppl are lazy, why do i have to add "atomic" or "banana" behind the bool for no reason?
09:21:45 <applicative> Well, if you wrote True, how would the compiler know whether you meant a Bool or a Proposition
09:21:59 <_oz> rwbarton: it would at least combine pure and return (and point, which Pointed defines).
09:22:08 <_oz> that's a useful thing if you ask me :)
09:22:20 <rwbarton> my comment was mainly about HasBind.
09:22:25 <shokodrink> applicative: oh i see :O thanks
09:22:43 <sparkleshy> If I say `fint = fromIntegral` then while `fromIntegral :: (Num b, Integral a) => a -> b`, `fint :: Integer -> Integer`
09:22:45 <_oz> you are probably right about that one.
09:22:55 <rwbarton> if you break down Monad like this, you also have to choose a distinguished way to do this, when it's equally sensible to define a monad in terms of return + join
09:23:31 <rwbarton> unless you are going to write a HasJoin class also, and force Monad implementors to implement all three.
09:24:08 <sparkleshy> This is because of http://www.haskell.org/haskellwiki/Monomorphism_restriction . The problem goes away if I go -XNoMonomorphismRestriction , but how can I have that happen *with* -XNoMonomorphismRestriction ?
09:24:21 <rwbarton> Anyways, type class members can have types other than functions and a tuple of functions is not much different from multiple functions anyways :)
09:24:48 <_oz> that's a possibility I suppose. using something like default method implementations, you can still reduce the boilerplate
09:25:54 <sparkleshy> like, do I just have to have the type signature manually?
09:25:58 <erus`> I wanna design a system where kinds have the same types as types :|
09:26:20 <erus`> i think i need to start smaller
09:26:22 <shokodrink> applicative: one more question, in the data declaration it is the type bool and in the part of "calculate" its only a variable right?
09:27:04 <applicative> right, it could have been x, anything lower case.
09:27:51 <prof7bit> I have a quick question: (I'm a total Haskell noob): http://hpaste.org/56553  (question is inside the comments)
09:28:05 <applicative> shokodrink: but note that p and q in the next line range over Propositions, not Bools
09:29:32 <shokodrink> applicative: yes i think i understood this, its necessary to also handle bigger equations
09:34:03 <shokodrink> applicative: and how can i then use this in ghc? it always says that this data doesnt know bool :/
09:34:59 <sipa> data Proposition = Value Bool | And Proposition Proposition
09:35:08 <sipa>   derving Eq
09:35:27 <sipa> the constructors are Value and And *names you choose)
09:35:34 <applicative> shokodrink: so if you ask it what Atomic True is, it'lll say True.
09:35:43 <applicative> sorry
09:35:59 <roconnor> ooh updateLookupWithKey is a lens more or less
09:36:06 <applicative> I meant, if you ask it what "calculate (Atomic True)" is itll say "True"
09:36:49 <applicative> shokodrink: if you ask it what calculate (And (Atomic True) (Atomic False)) is, it'll say False, no?
09:37:54 <shokodrink> applicative: oh yes, it seems to work :) but can i somehow avoid writing atomic?
09:38:22 <applicative> shokodrink: you can choose a shorter constructor, like P Bool | And Proposition Proposition
09:38:44 <applicative> also since there are only two 'atomic propositions' as you've set it up
09:38:53 <shokodrink> applicative: ok
09:39:34 <applicative> you can define (lower case) true = Atomic True; false = Atomic False; then you can write calculate (false `And` false) and so on
09:39:57 <tty7> prof7bit: this is what it does for me: http://hpaste.org/56554
09:40:38 <applicative> tty7: prof7bit yeah, I wasnt getting the funny result either, both mains worked the same
09:41:06 <hpaste_> keep_learning pasted “compiler error in quick sort of dph-examples” at http://hpaste.org/56555
09:41:24 <keep_learning> hello all
09:41:50 <prof7bit> I'm using an old ghc: 6.8.2
09:41:54 <tty7> prof7bit: also, you can also write just x instead of complete x
09:41:58 <keep_learning> I am trying to compiler main.hs of QuickSort in doh
09:42:14 <keep_learning> but getting compiler error for Timing module.
09:42:21 <tty7> take (length x) x doesnt do anything actually
09:43:04 <tty7> @check liftM2 (==) (\x -> take (length x) x) (\x -> x)
09:43:06 <lambdabot>   "OK, passed 500 tests."
09:43:46 <tty7> oh, you actually did. sorry. didnt see that line 2 was commented
09:44:02 <ezyang> Do... people actually write monad stacks with ST at the bottom?
09:44:18 * ezyang shivers 
09:44:31 <mm_freak> never done, but might be reasonable
09:44:51 <prof7bit> tty7: I understand why my result looks like it looks: it is passing the first elements of the incomplete string around to the next function and printing it to the screen already even before the line is complete. if i use the complete function (that does nothing) it will delay processing until the length of the string is known,
09:45:54 <ezyang> mm_freak: I mean, I sort of feel like, at that point, you might as well give up and go write Python instead.
09:46:02 <prof7bit> i was looking for a function that would enforce the complete evaluation of a list until the very last element is known and not pass any incomplete results to the next function
09:46:17 <ezyang> prof7bit: deepSeq
09:46:29 <mm_freak> ezyang: you might have a big mutable array computation with multiple possible outcomes
09:46:36 <applicative> prof7bit: I wonder if this has something to do with the line editor that is being used in your system? I mean, vs. the one tty7 and I are using
09:47:01 <mm_freak> ezyang: LogicT (ST s) a
09:47:24 <prof7bit> i'm using linux / kde3
09:47:26 <ezyang> O.o
09:47:53 <tty7> prof7bit: it depends on the terminal, i'd guess
09:48:02 <prof7bit> it also behaves slightly different (but still proints too early) ehrn compiling it to an executable
09:48:16 <applicative> prof7bit: though what you are doing fits with the original use of interact, which predates Haskell '98, I only use it for thing like " cat a.txt |  runhaskell inttest.hs"
09:48:37 <ezyang> mm_freak: I don't even know how I would reason about backtracking and mutable state in that setting.
09:48:38 <tty7> and why do you want to remove the laziness there?
09:48:57 <tty7> (i'm not even sure if it really is used at that point)
09:49:16 <rwbarton> qpu: I guess I would say that I think of type classes as a mechanism to express that a type is an instance of some interesting concept rather than just a way to have overloaded values. Then you write type classes with however many functions are needed to "implement" or express this concept.
09:49:17 <hyper_c^3> applicative: useless use of cat :)
09:49:22 <Saizan> @google typed logic variables
09:49:24 <lambdabot> http://www.cs.nott.ac.uk/~gmh/papers/20.ps
09:49:26 <applicative> yeah
09:49:28 <Saizan> ezyang: ^^^
09:49:42 <applicative> i was just trying to show the use of 'interact' for piping
09:49:51 <prof7bit> tty7: i want the laziness removed at the line level, so it would be still lazy regarding the entire stdin but regard one line always as a complete line
09:49:51 <ski> oh, `check' in lambdabot works again
09:49:53 <rwbarton> Often it happens that some individual functions in the type class correspond to interesting concepts on their own, while others do not.
09:50:15 <tty7> well, why? the result is the same ;)
09:50:28 <ski> ezyang : i've done it, parametrically, like in that `LogicT'
09:50:48 <tty7> it internally may print it letter by letter, not asking for the third letter of the input when just printing the second
09:50:52 <applicative> prof7bit does the same happen if you compile, ghc --make inttest.hs -o inttest , then do ./inttest or whatever?
09:51:07 <ezyang> Saizan: Is that intended as a monad stack on top of ST?
09:51:11 <tty7> but still, when reaching the "<end", all the input is there+
09:51:14 <ski> ezyang : presumably the mutable state is used to implement instantiation and uninstantiation (when backtracking) for logic variables
09:51:20 <prof7bit> tty7: its the same mathematically but the sequence of things happening on the screen is confusing if it already starts printing the partial results that can be calculated before i finished the complete line
09:51:43 <tty7> yeah. but i dont believe it's the laziness' fault
09:51:46 <Saizan> ezyang: it uses a backtracking transformer over a monad which provides mutable variables
09:52:27 <ski> prof7bit : `reverse . reverse' ?
09:52:28 <Saizan> ezyang: though, tbf, the API exposed (i.e. logic variables) is much nicer than unrestricted mutation
09:52:36 <roconnor> oh crap, updateLookupWithKey isn't quite a lens.
09:52:53 <roconnor> ... if only API designers knew more category theory (than me).
09:53:03 <qpu> rwbarton: that seems to be the consensus based on the standard haskell libraries… pretty sensible i think, though maybe some classes like Num don't work as well in certain instances
09:53:20 <roconnor> I wonder if updateLookupWithKey is lazy enough for me to cheat
09:53:33 <ezyang> Ah yes. I guess I'm OK if it's just an implementation detail.
09:54:21 <roconnor> heh I think it might be
09:55:03 <ski> @type M.updateLookupWithKey
09:55:03 <lambdabot> forall k a. (Ord k) => (k -> a -> Maybe a) -> k -> M.Map k a -> (Maybe a, M.Map k a)
09:55:18 <applicative> tty7: prof7bit Oh, i do get prof7bit 's result if I just ask for main inside ghci
09:55:22 <prof7bit> tty7: for me as a 43 year old totally imperative programmer it is mind boggling to see these thing happening. I intuitively see function calls as control flow constructs, call something and not do anything else until the result is calculated and the funtion returns. Now i can see the "program flow" stuck in half a dozen functions at the same time passing around partial results as they become available. this is a crazy experience.
09:56:05 <roconnor> ah crap it isn't
09:56:08 <sipa> prof7bit: in the presence of lazyness, it is rather data flow than program flow
09:56:11 <roconnor>       | k==ky         -> case (f k y) of
09:56:12 <roconnor>                            Just y' -> (Just y,Tip ky y')
09:56:14 <roconnor>                            Nothing -> (Just y,Nil)
09:56:25 <roconnor> If onlye the (Just y,) were floated out of the case statement
09:56:49 <prof7bit> sipa: yes, this is a totally different way of thinking about what is going on
09:56:58 * ski would have done that
09:57:03 <applicative> prof7bit: the peculiarities of 'interact' are the reason why they introduced the IO monad to begin with
09:57:11 <prof7bit> it is like learning programming completely new a second time.
09:57:26 <tty7> prof7bit, applicative: yep, in ghci, the same happens to me
09:57:26 * ski wonders why prof7bit is using `interact'
09:57:46 <tty7> probably because of interact inside of ghci?
09:58:02 <prof7bit> ski: i saw that in some blog post and thought I try how it behaves when I use it this way
09:58:48 <prof7bit> I'm ust playing around with all this to get an impression of how this all behaves
09:58:52 <ski> prof7bit : typically you want/need to be very picky about strictness behaviour, if you use `interact' for anything interactive (as opposed to as a simple filter)
09:58:53 <ezyang> OK, so here's a question for y'all: does writing a finalizer that only affects mutable state ever make sense in a language like Haskell?
09:58:56 <prof7bit> I'm totally new to Haskell
09:59:06 <ezyang> As opposed to just making it pure.
10:00:05 <ski> prof7bit : i.e., normally if you'd want control over interaction, you'd not use `interact', since strictness behaviour can be fragile
10:00:27 <prof7bit> ski: I already had another version that would use do and getLine and loop by recursively calling itself but then I saw this interact function and thought lets see how this works
10:00:50 <Sgeo> AddHandler is ... so so so similar to Cont
10:00:55 <ski> dialogue-based I/O was invented to abstract away from irritating details of the raw `interact'-style I/O
10:00:58 <Sgeo> Almost, but not quite
10:01:05 <ski> prof7bit : *nod*
10:01:18 <ski> then monadic I/O was invented
10:02:02 <Sgeo> dialogue-based I/O?
10:03:35 <\b> hallo
10:04:38 <\b> it seems, that my vim does not good at highlight haskell codes
10:05:02 <Eduard_Munteanu> \b: hi
10:05:20 <\b> Eduard_Munteanu: hi :)
10:06:07 <\b> if i write \ in the comment (i use '\' for haddock), the next code lines will not be rightly highlighted
10:06:08 <dgpratt> \b: how so (or how not so)?
10:06:20 <dgpratt> I spoke too late
10:06:26 <\b> :D
10:07:26 <\b> do you have the same problem?
10:07:51 <dgpratt> \b: hmm; maybe you can hpaste an example?; I'm either not understanding or I don't have that issue
10:07:57 <dgpratt> @where hpaste
10:07:58 <lambdabot> http://hpaste.org/
10:08:20 <\b> i found this discussion: http://stackoverflow.com/questions/2211518/is-vims-haskell-syntax-highlighting-broken
10:08:21 <ski> Sgeo : `type Dialogue = [Response] -> [Request]'
10:08:46 <\b> but "sync fromstart" would be slow
10:09:23 <ski> Sgeo : `end :: Dialogue; putChar :: Char -> Dialogue -> Dialogue; getChar :: (Char -> Dialogue) -> Dialogue'
10:09:43 <keep_learning> Hello all
10:09:53 <ski> hi there, keep_learning
10:10:02 <dgpratt> \b: have you tried "sync fromstart" to see if it would fix your issue?
10:10:40 <keep_learning> I have a Main.hs file which imports module Timing and Randomish . I kept all these files in same directory ( dph ) .
10:11:34 <hpaste_> “\b” pasted “vim highlight” at http://hpaste.org/56556
10:11:35 <keep_learning> when i am trying to compile this Main.hs i am getting compiler error.
10:12:00 <\b> dgpratt: yes i have tried.  it works.
10:12:22 <\b> dgpratt: you could have a look at this example in vim: http://hpaste.org/56556
10:12:36 <\b> dgpratt: and goto the last page
10:13:13 <hpaste_> keep_learning annotated “compiler error in quick sort of dph-examples” with “compiler error in quick sort of dph-examples (annotation)” at http://hpaste.org/56555#a56557
10:13:40 <dgpratt> \b: yeah, I can repro the issue
10:13:41 <keep_learning> Could some one please tell me how to compile Main.hs
10:13:57 <Saizan> ghc --make Main.hs
10:14:42 <keep_learning> Saizan, thank you.
10:15:21 <keep_learning> Saizan, stupid me :(
10:16:07 <dgpratt> \b: whereas the "syn sync fromstart" fix "fixes" it, it sounds like a fundamental limitation/issue of Vim; as such, I suspect you're stuck
10:16:28 <Saizan> it's ok to ask :)
10:18:15 <dgpratt> so, does anyone have any advice for me to convince my local ".NET Developer" group to let me give a talk on Haskell?
10:19:42 <mm_freak> dgpratt: some of the nicer features of the .NET languages are haskell-inspired
10:19:55 <mm_freak> especially starting with F#
10:19:57 <dgpratt> mm_freak: good point
10:20:06 <cmccann> also LINQ
10:20:08 <cmccann> which is the list monad
10:20:10 <\b> dgpratt: thanks. it was solved with "sync fromstart". But i doubt, the vim would be slow, if the codes were longer. I had experience with a long perl file, that makes vim very slow...
10:20:44 <dgpratt> yeah, LINQ is a good angle, F# scares these people
10:20:55 <cmccann> and explicitly so, LINQ was designed by someone coming from a very Haskell-influenced background
10:21:29 <mm_freak> dgpratt: the concept of parametric polymorphism in general
10:21:39 <mm_freak> called "generics" in .NET languages
10:22:13 <dgpratt> mm_freak: is that Haskell-inspired also? The equivalence is easy to see, but I guess I assumed a common ancestor
10:22:30 <mm_freak> dgpratt: not sure if it's haskell specifically
10:23:00 <cmccann> weren't java's generics designed in large part by wadler?
10:23:08 <cmccann> since that's probably where C#'s version is coming from
10:23:29 <cmccann> but yeah that's back to ML-style languages in general, if not haskell itself necessarily
10:23:29 <dgpratt> cmccann: I'm thinking C# had generics first...not so?
10:23:46 <cmccann> dgpratt, maybe, I'm actually not sure
10:24:10 <dgpratt> did Miranda have parametric polymorphism?
10:24:39 <c_wraith> yes
10:24:50 <c_wraith> It didn't have ad-hoc polymorphism, though
10:27:15 <ski> in Miranda, type variables are written like `*',`**',`***',&c.
10:30:03 <dgpratt> ski: interesting
10:42:19 <^thief^> Im trying to call parseTime on a user input string but its complaining thats its getting "IO String" instead of just "String" - how can I fix this?
10:42:21 <hpaste_> “^thief^” pasted “parseTime with user input” at http://hpaste.org/56560
10:42:46 <prof7bit> regarding my problem with waiting for the complete list: I think this works and looks better: complete x = seq (length x) x
10:42:53 <mm_freak> cmccann: yes, generics have been developed by wadler…  i've seen a talk
10:43:18 <hyper_c^3> I thought Odersky was also involved?
10:44:10 <mm_freak> dunno
10:44:10 <ski> ^thief^ : you need `newdate :: Record -> String -> IO UTCTime' to begin with (or pass `str' as a parameter)
10:45:22 <ski> "Pizza into Java: Translating theory into practice" at the bottom of <http://homepages.inf.ed.ac.uk/wadler/topics/gj.html> ?
10:49:41 <^thief^> ski: but even if I pass 'str' as a parameter to newdate, I still have to get user input in 'fix' , which means I'll be passing back an IO Record instead of a Record
10:50:49 <ski> ^thief^ : or you could possibly send `str' as a parameter to `fix' as well
10:51:11 * ski isn't really sure what ^thief^ is trying to do, so can't tell whether doing this would be appropriate or not
10:51:20 <^thief^> no because 'str' is specific to each Record - the user is being asked to fix the dates in a set of records
10:51:29 <^thief^> sorry yea I should have provided more context
10:51:36 <ski> generally, it's a good idea to try to separate user interaction with the internal workings of the computation, though
10:51:51 <^thief^> I know but I don't know how to do that in this case
10:53:05 <ski> then you must wrap the return type of your operations in `IO'
10:53:17 <dgpratt> cmccann: btw, I was wrong, it appears Java got generics first (04 vs 05)
10:53:41 <ski> judging from your question, it sounded like you were new to how the I/O system in Haskell works
10:53:58 <ski> in that case, it might perhaps help a bit to look at
10:54:00 <ski> @wiki Introduction to IO
10:54:01 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
10:54:29 <^thief^> ski: no I get the monad thing, I know how IO works (or at least sort of)
10:55:13 <ski> ^thief^ : maybe i should try to fix that code in the paste ?
10:55:40 <^thief^> ski: I should probably try to formulate my question/problem a bit better
10:56:08 <ski> to me it sounds like you just need to insert a few `IO's in the types, and use some more `do'-notation
10:57:49 <^thief^> ski: heres a go at an explanation of what my problem is:
10:57:50 <^thief^> I have a list of records. Records have a date field of type (Either String UTCTime). I need to loop through the records and for each record of type (Left String) I need to prompt the user for a new entry. Then I have to call setRecords with the updated set of records. setRecords expects a plain list of records.
10:58:40 <^thief^> no somewhere in there IO has to be introduced, but how can I keep that out of the Records list?
10:59:05 <^thief^> *no should read now
11:04:15 <hpaste_> ski annotated “parseTime with user input” with “more `IO'” at http://hpaste.org/56560#a56562
11:04:23 <ski> ^thief^ ^
11:04:46 <^thief^> ski: thanks, ill have a look
11:05:15 <ski> there are two code lines which are commented out -- they are replaced by the single line following them
11:05:21 <ski> you can use either version
11:06:46 <^thief^> ok I'm trying it out now cheers
11:07:48 <ski> ^thief^ : by "somewhere in there IO has to be introduced, but how can I keep that out of the Records list?", i assume that you want to not have an `IO Something' lying inside the record, is that correct ?
11:08:07 <adimit> Hi, does anybody here have experience with running ghc-mod? I'm trying to make it recognize packages I have installed via cabal locally ($HOME/.cabal,) and I somehow can't find a way to.
11:08:41 <^thief^> ski: yep
11:09:07 <ski> ^thief^ : ok, as i thought then
11:09:42 <ski> ^thief^ : and the way i did that there is by running `newdate rec val' using `<-' *before* putting the *result* of that into the record
11:11:13 <^thief^> ski: ah ok I'm starting to see it
11:12:43 <ski> ^thief^ : oops, i did a mistake, `mapM_' should be `mapM'
11:12:50 <^thief^> ok
11:13:30 <ski> `mapM' is running an action for every element in a list, and collecting the results into a new list
11:13:35 <ski> (and that is what you seem to want)
11:14:03 <ski> `mapM_' otoh is running an action for every element in a list, and *not* collecting the results into a new list
11:14:15 <Sgeo> Do mapM_ and forM_ get used more than mapM and forM?
11:14:24 <Sgeo> I can imagine that would be a source of people using the wrong thing
11:14:34 <ski> i suppose it depends on what kind of code you write
11:14:58 <ski> if the code is very "imperative", there might be lots of `mapM_', whose only effect is the monadic effect
11:15:10 <adimit> Sgeo: sometimes, you need monadic actions for their side-effects only. mapM_ and forM_ get used a lot in the IO monad, specifically.
11:15:18 <vodik> is there a simpler (or a fold way) of doing something like this with lists: list1 ++ drop (length list1) list2
11:15:22 <byorgey> as far as I can tell I use them about equally often
11:15:33 <ski> adimit : also in backtracking stuff
11:15:39 <vodik> basically "overwriting" list2 with list1
11:15:56 <vodik> i can't find anything in the docs
11:15:58 <adimit> ski: yeah, but that's more complicated. The easiest, and probably most common use would be something like mapM_ putStrLn someList
11:16:11 * ski nods
11:16:45 <adimit> I use mapM_ a lot to commit lists of stuff to a db. So I use mapM_ commitToDB someValues
11:16:45 <vodik> it seems like something that should be more straightforward but im stumped
11:16:47 <byorgey> vodik: zipWith ($) (map const list1 ++ repeat id) list2  -- hmm, that's not really simpler, is it.
11:17:06 <byorgey> vodik: your code seems pretty straightforward to me.
11:17:10 <vodik> okay
11:17:22 <Sgeo> I'm noting similarities between my type and a continuation monad
11:17:28 <Sgeo> Should I explore further, or ignore it?
11:17:32 <vodik> byorgey: thats good enough to please me then. thanks
11:17:33 <Sgeo> Because it's not the same
11:17:37 <Sgeo> And Cont confuses me
11:17:47 <cheater_> learn cont while you're at it
11:17:54 <byorgey> Sgeo: it depends. Do you want to understand continuations better, or not?
11:18:15 <Sgeo> I think I do, but I am trying to get my project to work in a sane fashion
11:18:15 <ski> `Cont' is fun
11:18:30 <Sgeo> Cont has no monoid instance, and that's the tricky thing here >.>
11:18:38 <ski> Sgeo : how does your type look like ?
11:18:44 <byorgey> Sgeo: in my experience, one does not understand continuations.  One simply becomes more comfortable being confused by them.
11:18:50 <Sgeo> newtype Event a = Event { addHandler :: (a -> IO ()) -> IO (IO ()) }
11:19:07 <Sgeo> The IO () returned by the addHandler deregisters the handler
11:20:57 <ski> and presumably that typically uses `IORef's or `MVar's or something similar ?
11:21:02 <byorgey> Sgeo: you can always make a lifted  instance (Monoid a) => Monoid (m a)  for any monad m.
11:21:10 <byorgey> or an  instance Monoid (m ())
11:21:57 <Sgeo> ski, well, the Monoid instance is
11:22:13 <Sgeo> Maybe I should just go ahead and write the Monad instance for what I have
11:22:18 <Sgeo> Maybe I'll learn something that way
11:22:51 <Sgeo> (Would writing it in terms of join mean I learn less? Because I'm planning on writing joinEvent, then implementing >>= in terms of that.
11:23:14 <byorgey> who knows?
11:23:30 <byorgey> just write something and worry about what you've learned later =)
11:23:42 <c_wraith> @src Kleisli
11:23:42 <lambdabot> Source not found. That's something I cannot allow to happen.
11:24:16 <alexdavey> How can you represent an "empty" value in an amorphous list (ie: without forcing to to a specific type)?
11:24:26 <c_wraith> You... can't.
11:24:34 <ski> what is an "amorphous list" ?
11:24:42 <byorgey> what is an empty value?
11:24:46 <c_wraith> for "empty" to make sense, you need a type where "empty" makes sense.  Sounds tautological, but it isn't
11:25:03 <byorgey> [Nothing] :: [Maybe a]?
11:25:11 <cmccann> how about []? :P
11:25:13 <ski>   newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}  -- c_wraith
11:25:23 <c_wraith> ski: that's what I was guessing it'd be.
11:25:25 <c_wraith> thanks
11:25:44 * cmccann notes that Kleisli and ReaderT differ only in the order of their type parameters
11:26:05 <c_wraith> yeah.  Kleisli's ordering was chosen to make it an instance of Arrow
11:26:08 <byorgey> heh, I never noticed that.
11:26:12 <cmccann> yep
11:26:15 <c_wraith> and yes, clearly . and <=< are the same operator
11:26:31 <c_wraith> err.  >=>
11:26:34 <c_wraith> one of the fish, anyway
11:26:37 <cmccann> one order is needed for MonadTrans, the other order for Category
11:26:37 <ski> @type (Prelude..)
11:26:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:26:41 <cmccann> it's <=<
11:26:46 <cmccann> like <<<
11:26:54 <c_wraith> ok, quit second-guessing myself
11:29:12 <cmccann> byorgey, it's not too surprising, treating an Arrow instance like an Applicative or Monad ends up working like Reader
11:29:28 <cmccann> except with some other Arrow instead of a function
11:29:44 <hpaste_> “^thief^” annotated “parseTime with user input” with “more `IO' (annotation)” at http://hpaste.org/56560#a56564
11:30:00 <roconnor> gez, you write one paper explaining how a lens is really a higher order monoidal natural transformation, and suddenly everyone thinks you are an expert on lenses.
11:30:21 <^thief^> ski: ^ can't seem to get it working, did have a good go at it!
11:30:43 <osfameron> roconnor: i know the feeling
11:31:20 * cmccann needs to invent some new way of composing lenses in "parallel" so that he can call the result "binoculars"
11:32:00 <Eduard_Munteanu> /<oo>\
11:32:01 <ski> ^thief^> :t parseTime
11:32:05 <ski> ^thief^> :t defaultTimeLocale
11:32:11 <sipa> :t hammerTime
11:32:12 <lambdabot> Not in scope: `hammerTime'
11:33:29 <Younos> :t map
11:33:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:33:37 <Younos> :t foldr
11:33:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:33:40 <ski> @remember roconnor gez, you write one paper explaining how a lens is really a higher order monoidal natural transformation, and suddenly everyone thinks you are an expert on lenses.
11:33:41 <lambdabot> Done.
11:33:41 <Younos> oh this is nice
11:34:34 <Younos> how do i tell lambdabot to calculate something?
11:34:51 <adimit> > let 2 + 2 = 5 in 2 + 2
11:34:51 <lambdabot>   5
11:34:53 <Younos> : sum [2,4,6]
11:35:01 <Younos> sum [1,2,3]
11:35:05 <Sgeo> Younos, >
11:35:09 <ski> you need an initial `> '
11:35:09 <Sgeo> Start your line with >
11:35:20 <Younos> ohh ofcourse i should have guessed
11:35:28 <Sgeo> Or just have seen people use it
11:35:32 <adimit> you can also use ghci…
11:35:37 <ski> @run "this" ++ " is also possible"
11:35:38 <lambdabot>   "this is also possible"
11:35:49 <Sgeo> @run putStrLn "Can run do IO?"
11:35:50 <lambdabot>   <IO ()>
11:35:53 <Sgeo> aww
11:36:00 <ski> @help run
11:36:00 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
11:36:13 <Younos> hehe
11:36:16 <Eduard_Munteanu> @. google run "has" ++ "kell"
11:36:19 <lambdabot> http://www.haskell.org/
11:36:30 <parcs`> @. google google google
11:36:33 <lambdabot> http://support.google.com/webmasters/bin/answer.py?hl=en&answer=35624
11:36:33 <lambdabot> Title: Site title and description - Webmaster Tools Help
11:36:49 <Younos> i'm still learning Haskell, today i'm learning monads
11:36:54 <adimit> allowing IO on lambdabot would have… security implications.
11:37:02 <adimit> aw, cute.
11:37:09 <ski> 'tis a great day for learning monads, methinks
11:37:20 <Younos> yea we dont want people screwing up the bot, its ment to be helpfull
11:37:31 <ski> ^thief^ : i'm still waiting for an answer
11:37:50 * ski tries to sound demanding
11:37:50 <^thief^> ski: sorry - I thought that was a hint! haha
11:38:18 <^thief^> I just this minute found the problem - sorry it was my mistake
11:38:26 <^thief^> I had missed a return
11:38:29 <Younos> > sum map sin [0,6.28]
11:38:30 <lambdabot>   Couldn't match expected type `[a]'
11:38:30 <lambdabot>         against inferred type `(a1 -> b)...
11:38:40 <Younos> > sum map (sin [0,6.28])
11:38:41 <lambdabot>   Couldn't match expected type `[a]'
11:38:41 <lambdabot>         against inferred type `(a1 -> b)...
11:38:52 <ski> ^thief^ : where ?
11:39:04 <iLeNsTR> sum $ map sin [0.0, 6.28]
11:39:06 <merijn> Younos: That parses as "((sum map) (sin [0,6.28]))"
11:39:07 <Younos> > sum (map sin [0,6.28])
11:39:08 <lambdabot>   -3.1853017931379904e-3
11:39:15 <copumpkin> merijn: it does?
11:39:19 <^thief^> ski: Just dt  -> return d
11:39:21 <Younos> yes, i found the error just before you said it:)
11:39:22 <iLeNsTR> > sum $ map sin [0.0, 6.28]
11:39:23 <lambdabot>   -3.1853017931379904e-3
11:39:31 <merijn> copumpkin: The previous one did
11:39:38 <copumpkin> oh, yep :)
11:39:58 <^thief^> ski: thanks a lot!! I learned a lot, have to have a closer examination of the differences between my original code and the final working one to make sure I really get it
11:40:04 <merijn> Just unlucky timing from me :p
11:40:06 <ski> ^thief^ : also note that you need to line up the commands in the `do'-blocks (unlike in your last annotation)
11:40:53 <^thief^> ski: didn't notice that - copy/paste issue, they're lined up in my editor
11:41:31 <ski> ^thief^ : btw, in case you don't know, make sure that there are no tabs in your Haskell source (e.g. set editor to convert tabs to spaces)
11:42:03 <^thief^> ski: yep got a stern warning from our lecturer at the start of term! generally use spaces myself anyway
11:42:26 <ski> (it is also possible to use tabs for indentation, but then you must use solely tabs for that, and you must break line after layout-introducing keywords if you intend to follow them by layout-blocks with more than one line)
11:42:36 <ski> that's fine
11:43:11 <adimit> I used tabs in Haskell for a very long time, actually. It's fine, just gotta know what to do.
11:43:14 <amiller> is anyone using haskell for decentralized or anonymous distributed systems
11:43:21 <Eduard_Munteanu> Or you have to make sure everybody uses 8-spaces wide tabs.
11:43:25 <Eduard_Munteanu> :P
11:43:49 <merijn> amiller: Probably? :p
11:44:06 <amiller> i'm looking for examples of open projects to look at but i haven't found any
11:44:09 <adimit> the point of tabs is that everybody can adjust their indentation to their preferences. I lke to view C code with 8 space tabs, java with 5, etc. because I'm strange like that. But Haskell allows for prettier indentation anyway.
11:44:17 <amiller> on the other hand i know of tons of examples in python or C
11:44:56 <amiller> bittorrent clients, otr plugins, i2p and freneet and tahoe-lafs, stuff like that
11:45:31 <amiller> oh, i found a haskell-torrent https://github.com/astro/haskell-torrent
11:47:10 <ski> adimit : *nod*, it's possibly to use tabs, if you know how
11:49:16 <amiller> and here's a nice analysis about what the bitcoin client in haskell looks like. http://jlouisramblings.blogspot.com/2009/12/on-idioms-in-haskell-torrent.html that's pretty much what i was looking for
11:49:35 <amiller> i hope i can also find a bunch of other neat examples like that
11:52:31 <adimit>  *sigh* — when will I finally be able to just import Control.Monad.State without dependency hell?
11:53:22 <adimit> … is the only way to treat it still to just globally ghc-pkg hide the transformer library you don't want (or invoke ghci with similar arguments?)
11:53:51 <kuznero> Hi All!
11:58:14 <ivanm> adimit: you mean to hide mtl-2 or monads-tf ?
11:58:29 <ivanm> adimit: but yes, either that or use cabal-dev or something
11:59:34 <adimit> ivanm: yeah. I've seen cabal-dev cropping up all over the place lately, but haven't had time to investigate…
11:59:56 <ivanm> adimit: what it is, is that it uses a per-project ghc-pkg db
12:00:16 <ivanm> so you only "install" the packages you actually want/need
12:00:23 <ivanm> (as listed in the .cabal file)
12:00:36 <adimit> ivanm: will this be recognized by stuff like command-line ghci or ghc-mod?
12:00:53 <ivanm> you need to use something like "cabal-dev ghci" rather than just ghci
12:00:57 <ivanm> no idea about ghc-mod
12:02:19 <adimit> ivanm: ah, thanks; well, that means I'd still have to hide it globally, since I don't want ghc-mod reporting bogus errors all over the place. that'd be distracting!
12:02:28 <ivanm> heh
12:02:35 <derpladee> hey, i'm trying to import Graphics.GD but GHC can't find it for some reason
12:03:24 <derpladee> does anybody know what the problem is?
12:03:37 <derpladee> do i need to specify that i need to use it with the -package switch or something?
12:03:49 <adimit> derpladee: you'll have to go into more detail. What does ghci say when you tell it to import Graphics.GD?
12:04:24 <Sgeo> If I define a monad in terms of a join function, is it a bad idea to use liftM in the bind definition?
12:04:26 <Sgeo> @src liftM
12:04:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:04:37 * Sgeo thinks it would loop
12:04:39 <derpladee> Failed to load interface for `Graphics.GD':
12:04:54 <copumpkin> Sgeo: yes, unless it's another monad's liftM
12:05:03 <ski> Sgeo : use `fmap'
12:05:12 <Sgeo> ski, but then I can't do fmap = liftM
12:05:12 <ivanm> derpladee: do you have the gd package installed?
12:05:22 <derpladee> Possibly.
12:05:23 <Sgeo> Although I already have an fmap
12:05:24 <Sgeo> so
12:05:27 <ivanm> derpladee: ghc-pkg list gd
12:05:37 <ski> Sgeo : if you define `return' and `join', you need to define `fmap' as well, you don't get it for free
12:05:59 <derpladee> ivanm, that says /var/lib/ghc-6.12.1/package.conf.d
12:06:00 <Sgeo> Ok
12:06:01 <derpladee> and nothing else
12:06:13 <ivanm> derpladee: then you need to install gd first before you can use it
12:06:35 <ski>   ma >>= amb = join (fmap amb ma)  -- `(>>=)' in terms of `join' and `fmap'
12:07:30 <Sgeo> Is there a thing of monad laws written in terms of join
12:07:39 <ivanm> Sgeo: I believe so
12:07:42 <ivanm> on the wiki maybe?
12:07:43 <Sgeo> Because I think for this monad, I understand join far better than I do bind
12:07:53 <Sgeo> I may be wrong though (in terms of what I understand)
12:07:54 <derpladee> ivanm, is that libghc6-hgl ?
12:08:02 <ivanm> derpladee: no
12:08:03 <shachaf> Sgeo: It's a good exercise to figure out those laws yourself.
12:08:11 <ivanm> it'd be libghc6-gd (I'm guessing)
12:08:26 <ski> Sgeo : `join . return = id', `join . fmap return = id', `join . join = join . fmap join'
12:08:38 <shachaf> Well, I guess you no longer have the opportunity.
12:09:01 * ski apologizes for wanting to help Sgeo
12:09:11 * Sgeo hmms
12:09:14 <ezyang> @seen edwardk
12:09:15 <lambdabot> Unknown command, try @list
12:09:18 <shachaf> ski: Yes, help isn't what we do in this channel!
12:09:20 <ezyang> ,seen edwardk
12:09:24 <shachaf> preflex: xseen edwardk
12:09:24 <preflex>  edwardk was last seen on freenode/#haskell 3 days, 10 minutes and 27 seconds ago, saying: look in Data.Bits for complement
12:09:51 <shachaf> ezyang: I'm going to Hac Boston, by the way.
12:09:57 <Axman6> m >>= f = join (fmap f m) right?
12:09:58 <ezyang> @tell edwardk So, it's less than four days before Hac Bos; what else do we need to do? (I think the website needs some udpates.)
12:09:59 <lambdabot> Consider it noted.
12:10:02 <ezyang> shachaf: Excellent!
12:10:14 <ski> Axman6 : yes, as mentioned above
12:10:27 <shachaf> ezyang: You should be in #haskell-hacboston
12:10:32 <shachaf> ...Not that there's much point.
12:10:40 <Axman6> i didnt see it put that clearly
12:10:50 <derpladee> ivanm, guess it isn't in the repo then, i'm only looking to write simple images to my hdd, is there another haskell library that you'd use for this?
12:11:11 <ivanm> derpladee: you could always do "cabal install gd"
12:11:29 <ivanm> derpladee: you could try the diagrams library
12:14:35 <derpladee> ivanm, well that seems exceedingly easy
12:16:54 <Palmik_> Hmm, is there a way to host Haddock generated documentation on github?
12:17:29 <Eduard_Munteanu> Palmik_: I guess it's static HTML no? Github pages should do then.
12:17:40 <donri> no reason not to
12:17:51 <Eduard_Munteanu> @google github pages
12:17:52 <donri> but what's wrong with hackage?
12:17:52 <lambdabot> http://pages.github.com/
12:17:52 <lambdabot> Title: GitHub Pages - Home
12:17:55 <Palmik_> Eduard_Munteanu, hmm, I though you can have only one per account?
12:18:05 <Eduard_Munteanu> Ah, not sure about that.
12:18:08 <donri> nope, one per repo
12:18:12 <donri> in the gh-pages branch
12:18:19 <byorgey> derpladee: are the images vector-based, or raster-based?
12:18:42 <ivanm> byorgey: didn't even mention your name and you *still* picked up that someone was talking about your diagrams library! :o
12:18:57 <byorgey> ivanm: I have ESP!
12:19:01 <derpladee> raster
12:19:06 <byorgey> and I also have a highlight on 'diagrams' =P
12:19:08 <Palmik_> donri, nothing, just that it takes some time untill hackage generates the docs and I also do not want to spam hackage with minor edits.
12:19:09 <Eduard_Munteanu> Or /hilight :P
12:19:20 <Eduard_Munteanu> Heh.
12:19:28 <byorgey> derpladee: OK. Then ignore ivanm's suggestion re: diagrams, which is for vector graphics
12:20:27 <donri> Palmik_: but on the other hand hackage cross-links with all your imports
12:20:35 <djanatyn> Hey, does seperating pure and impure stuff in haskell increase performance?
12:20:57 <djanatyn> Because of referential transparency, and the magic of GHC?
12:21:14 <Palmik_> donri, well, I do not inted to stop using hackage, I just wanted the github distribution to be complete as well.
12:21:24 <donri> well, ghc does a lot of tricks that would be difficult to do in not-haskell
12:21:39 <donri> like rewriting blocking io to async
12:21:39 <c_wraith> djanatyn: not really.  It's much more for doing things sanely.
12:22:19 <donri> Palmik_: just put some html in a branch called gh-pages and an empty file .nojekyll
12:23:05 <djanatyn> Yeah, definitely for sanity.
12:23:17 <djanatyn> I was just wondering if it had any speed benefits, too.
12:24:18 <c_wraith> occasionally, in that it allows code written more simply to be optimized more aggressively...
12:24:30 <c_wraith> But you can always get to those same levels with manual optimization of impure code.
12:25:03 <Palmik_> donri, yep, thanks :)
12:25:22 <djanatyn> GHC is written in haskell, right?
12:25:34 <c_wraith> yes, though it's not a good example of haskell code. :)
12:25:40 <c_wraith> It contains a lot of global mutable state
12:25:44 <djanatyn> heh :D
12:25:55 <lorx> woah, djan and donri in #haskell
12:26:03 <donri> coi lorx
12:26:12 <lorx> coi
12:28:20 <Phlogistique> for some reason, I feel like there are a lot of lojbanists in here
12:28:41 <Phlogistique> though they should be in #prolog? maybe.
12:31:24 <djanatyn> lorx: I'm trying to be less scared :)
12:32:07 <Sgeo> @src ap
12:32:07 <lambdabot> ap = liftM2 id
12:32:13 <Sgeo> @src liftM2
12:32:13 <adimit> haskell was a natural choice for me as a prolog-expat.
12:32:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:32:21 <c_wraith> that's like the list useful source for ap possible
12:32:40 <c_wraith> ap a b = do { f <- a ; x <- b ; return x }
12:32:43 <c_wraith> err
12:32:45 <c_wraith> ap a b = do { f <- a ; x <- b ; return $ f x }
12:33:32 <c_wraith> "liftM2 id" is like saying "join = (>>= id)"
12:34:01 <c_wraith> correct, but not really enlightening
12:36:35 <xft0> hello
12:36:57 <shachaf> Hello, xf0.
12:38:35 <derpladee> what does it mean if i get a lot of undefined references?
12:38:54 <xft0> is there any way to embed haskell interperter/compiler into c/c++ app? in other words: i'm looking for mechanism allowing to call haskell function from c application, run-time compilation and execution or sth like this
12:39:21 <ezyang> xft0: Yep.
12:39:31 <cmccann> xft0, you may need to jump through quite a few hoops
12:39:38 <cmccann> but I'm pretty sure everything you need exists
12:42:12 <c_wraith> derpladee: if you have a lot of them?  Maybe that you copied code from somewhat, but missed the necessary imports?
12:43:54 <xft0> ezyang, cmcann: nice. any details? can you give me name of c/c++ library (?) or some useful link(s)?
12:44:56 <cmccann> xft0, you proabably want to do everything in Haskell, then export a simple C API to that using the FFI
12:45:17 <cmccann> from the Haskell side you want the same sort of dynamic loading that GHCi uses
12:45:34 <cmccann> there are libraries for doing that sort of thing but I forget the names
12:46:11 <c_wraith> hint is one, something like hsplugins is the other
12:46:52 <c_wraith> oh, just plugins
12:47:45 <djanatyn> hey, I was wondering, has anyone had success using happstack on windows?
12:48:23 <Saizan> i did when it was still happs
12:48:30 <djanatyn> oh, sweet.
12:48:47 <donri> "Happstack is supported on GNU/Linux, OS X, FreeBSD, and Windows environments."
12:49:02 <donri> try describing your problem in #happs
12:49:10 <djanatyn> I was thinking about writing a happstap app, compiling it using the haskell platform with wine, and then taking the executable over to windows
12:49:46 <Saizan> does ghc work fine in wine?
12:49:53 <djanatyn> not sure! :D
12:50:09 <Eduard_Munteanu> Saizan: it did for me, although there were a few quirks
12:50:11 <djanatyn> I have to give a presentation tommorow, and I'll be using haskell and happstack
12:50:21 <Eduard_Munteanu> There was a wiki post on that.
12:50:22 <djanatyn> but I have to give the presentation using a windows machine, so I need to work out a few things tonight
12:50:30 <Saizan> i guess you can try with a virtual machine otherwise
12:50:47 <Saizan> just remember to give it a good chunck of memory
12:50:51 <djanatyn> I have a windows box, so I could always just install the haskell platform and just get happstack installed with cabal
12:50:55 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/GHC_under_Wine
12:52:15 <Eduard_Munteanu> Only Gtk2Hs proved to be a bigger headache to deal with, but that might've changed.
12:53:46 <Eduard_Munteanu> (also, I just grabbed the entire Platform)
12:56:44 <parcs`> Saizan: yes it does
12:56:51 <parcs`> oh someone said that already
13:11:12 <DanBurton> @let ifE b t f = if b then Left t else Right f -- do you think this is at all useful, as a generalization of "if" that allows the branches to have different types?
13:11:13 <lambdabot>  Defined.
13:11:20 <DanBurton> :t ifE
13:11:20 <lambdabot> forall a b. Bool -> a -> b -> Either a b
13:11:51 <mm_freak> DanBurton: it's not a generalization, it's the same
13:12:23 <DanBurton> well, I just mean, how useful would it be to use ifE as opposed to regular if
13:12:55 <DanBurton> :t if'
13:12:55 <lambdabot> Not in scope: `if''
13:13:55 <Jafet> @pl ifE b t f = if' b (Left t) (Right f)
13:13:55 <lambdabot> ifE = flip flip Right . ((.) .) . (. Left) . if'
13:14:16 <Jafet> Why is True Left?
13:14:45 <mm_freak> DanBurton: i don't think it's very useful except perhaps in the context of arrows (ArrowChoice)
13:15:27 <shachaf> Jafet: It's a political statement, I imagine.
13:16:52 <Jafet> Goddamned liberals.
13:16:54 <DanBurton> look at the code "foo bar"...which one is on the Left? ;)
13:16:58 <DanBurton> clearly foo
13:18:17 <dschoepe> DanBurton: what about line breaks?! :)
13:18:53 <shachaf> DanBurton: No, I write my code RTL.
13:19:16 <sp3ctum> @src (:)
13:19:17 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:19:21 <shachaf> @src []
13:19:21 <lambdabot> data [] a = [] | a : [a]
13:20:50 <mike-burns> You'd find ifE more useful if the true clause was Right. Nothing political, but it's what everything else does.
13:21:16 <shachaf> Well, people do it for good reason.
13:21:57 <mike-burns> Consistency, I assume.
13:22:20 <shachaf> Well, instance Functor (Either e)
13:22:29 <shachaf> You can't really do that the other way around.
13:22:35 <mike-burns> Indeed.
13:27:23 <hpaste_> Sgeo pasted “Not a complete snippet, but I'm amused by how the do (currently) lines up” at http://hpaste.org/56565
13:29:58 <erus`> can a lambda calc expression ever grow?
13:30:47 <Saizan> by evaluation you mean?
13:30:53 <dschoepe> erus`: Yes, it can even diverge (in simply-typed LC)
13:30:55 <merijn> erus`: untyped lambda calculus, yes. simple typed lambda calculus, no.
13:31:09 <shachaf> dschoepe: It can diverge in simply-typed LC?
13:31:20 <dschoepe> err, the other way around; I meant untyped
13:31:20 <merijn> dschoepe: Surely you mean UTLC?
13:31:31 <erus`> merijn: can you give me an example of an expression that grows in untyped
13:31:36 <merijn> Fix
13:31:40 <merijn> Y combinator
13:31:43 <merijn> Eh
13:32:11 <Saizan> (\x -> (x,x)) (\a b c d -> a) -- does this one count as growing?
13:32:56 <erus`> (x, x) isnt allowed :)
13:33:13 <Saizan> fine
13:33:26 <Saizan> (\x -> \k -> k x x) (\a b c d -> a) -- does this one count as growing?
13:33:32 <shachaf> Why isn't (x,x) allowed?
13:33:46 <shachaf> Oh, I was assuming it was an abbreviation for Saizan's second thing.
13:35:17 <omnomchildren> Hullo. I was wondering if someone could help me out with parsec for a second. I've been looking at the examples @ RWH, but I'm guessing he's using an older version
13:35:21 <omnomchildren> Because it won't really accept the examples
13:35:28 <omnomchildren> I'm thinking I have to explicitly specify a type?
13:35:50 <shachaf> omnomchildren: It might help if you provide code and an error and so on.
13:36:07 <omnomchildren> Oh, of course, just a second
13:36:15 <shachaf> There's not really much anyone can do to help you given what you said unless they try going through RWH themselves, or already have.
13:37:15 <hpaste_> omnom pasted “parsec madness” at http://hpaste.org/56567
13:37:24 <omnomchildren> shachaf: ^
13:37:53 <shachaf> omnomchildren: Why are you telling *me*? I don't know anything about Parsec. I'm just telling you how to ask the channel questions. :-)
13:38:26 <shachaf> omnomchildren: This might have to do with the monomorphism restriction.
13:38:30 <Saizan> omnomchildren: one easy solution is to :set -XNoMonomorphismRestriction
13:38:44 <shachaf> What Saizan said.
13:39:30 <Saizan> that'll make stuff more polymorphic than RWH would expect, but code should work as before
13:40:07 <Saizan> another option might be to replace your parsec-3.* with parsec-2.*
13:41:14 <omnomchildren> I see, thanks. Wouldn't explicitly specifying the type fix this?
13:41:42 <Saizan> yes, that would also do, but it's more manual work
13:41:47 <omnomchildren> Indeed
13:46:33 <miogaruna> OK #Haskell, I think I'm going to need your help,
13:46:46 <miogaruna> How does one go about doing an installation of the Haskell Platform using Cabal?
13:46:59 <miogaruna> I'm on Arch Linux and installed pandoc using the AUR,
13:47:11 <miogaruna> but then tried to switch to cabal
13:47:29 <miogaruna> and now compilation breaks with errors regarding key libraries
13:47:57 <miogaruna> Do I need to reinstall these myself? (I would have thought Network, for example, would be included)
13:49:25 <roconnor> maybe "lookupdate" is a warmer and fuzzier name for a lens.
13:49:26 <mm_freak> miogaruna: on arch linux i prefer to only install GHC and cabal-install via pacman, then do the rest via cabal-install
13:50:18 <miogaruna> mm_freak: Ok then, how would I go about reinstalling my broken libraries? Feed and Network seemed to be broken, when they were working before
13:50:56 <mm_freak> miogaruna: that's version hell…  i recommend uninstalling all haskell packages you have installed via pacman/AUR, then be sure to clean your local .cabal and .ghc directories
13:51:08 <mm_freak> finally just use cabal-install "cabal update; cabal install PACKAGENAME"
13:51:23 <miogaruna> mm_freak: OK, thanks, I'll try that.
13:51:25 <nand`> What does -XNoMonomorphismRestriction do, exactly? Does it just “ignore” the restriction and thus allow cases of potential double-evaulation, or does it use some GHC-specific cruft to have the compiler be more complex?
13:52:04 <mm_freak> miogaruna: after "cabal update", personally i find it useful to set "Documentation" to True in ~/.cabal/config
13:52:16 <mm_freak> that installs local haddoc documentation for all installed packages
13:52:19 <mm_freak> haddock
13:52:47 <mm_freak> roconnor: why?  i find "lens" to be a very fitting name
13:53:02 <lpsmith> @pl mx >>= \x -> f x y
13:53:02 <lambdabot> flip f y =<< mx
13:54:23 <miogaruna> mm_freak: Hm, how should I go about installing xmonad, then?
13:56:16 <miogaruna> mm_freak: Oh, there seems to be a copy of xmonad on hackage.
13:56:42 <mm_freak> miogaruna: i think the only notable package not found on hackage is gtk2hs
13:57:00 <mm_freak> that's probably the only package i'd install via pacman
13:57:28 <miogaruna> mm_freak: Got it, thanks!
14:12:19 <dcoutts> mm_freak: gtk2hs is several packages on hackage, glib, gtk, cairo, pango
14:12:54 <dcoutts> it's been there for nearly two years now
14:13:01 <hpc> glib and cairo are depends of gtk
14:13:11 <hpc> and i would suspect gtk is a depend of pango
14:13:16 <dpratt71> in general, there is no precise representation of a floating point number in decimal format, correct?
14:13:47 <merijn> dpratt71: Correct
14:13:54 <cl1> test
14:14:02 <dcoutts> hpc: other way around, gtk depends on pango
14:14:06 <dpratt71> merijn: ok, thanks for the confirmation
14:14:27 <merijn> dpratt71: Some fractions that have a finite floating point representation are repeating in decimal, and vice versa
14:14:40 <hpaste_> PetrosGR pasted “Class Inheritance Problem” at http://hpaste.org/56571
14:14:40 <dcoutts> dpratt71, merijn: though there are decimal floats (but not supported yet by hardware or many prog langs)
14:14:54 <merijn> finite floating point representations *in binary*
14:14:55 <dcoutts> http://en.wikipedia.org/wiki/Decimal_floating_point
14:15:04 <hpc> dpratt71: and then there's stuff like CReal, where it does "fake exact math", and then you ask for x digits, instead of an exact answer
14:15:17 <MostAwesomeDude> merijn: I thought that all finite floating-point numbers had terminating decimal representations?
14:15:39 <mauke> yeah, 2 divides 10
14:15:43 <petrosgr> Hi, I've just pased a small class inheritance related problem that's been giving me headaches at http://hpaste.org/56571.
14:15:46 <c_wraith> petrosgr: haskell is not an OO language.  The fact that it also has something called classes doesn't mean it works like subtyping in java.
14:15:50 <petrosgr> s/pased/pasted
14:15:51 <merijn> MostAwesomeDude: Why? 1/3 is finite but repeating in decimal
14:16:00 <mm_freak> dcoutts: oh…  good to know
14:16:02 <mm_freak> thanks
14:16:14 <merijn> MostAwesomeDude: Some fractions that are repeating in decimal are not so in binary
14:16:22 <MostAwesomeDude> merijn: 1/3 does not have a finite floating-point representation.
14:16:32 <petrosgr> Is it not possible to redefine an inherited default class method in Haskell?
14:16:33 <MostAwesomeDude> Well, not in IEEE 754, at least.
14:16:33 <merijn> MostAwesomeDude: *in decimal*
14:16:40 <MostAwesomeDude> merijn: Or in binary!
14:16:44 <merijn> MostAwesomeDude: Oh sure, I don't know a concrete example
14:16:46 <petrosgr> oh, sorry..
14:16:46 <mm_freak> miogaruna: sorry for the wrong information…  gtk2hs seems to be on hackage, but not as "gtk2hs"
14:16:58 <petrosgr> c_wraith: didn't see the answer
14:17:07 <merijn> MostAwesomeDude: My point was there *are* finite binary floating points with a repeating decimal representation
14:17:15 <mauke> merijn: no, there aren't
14:17:21 <MostAwesomeDude> merijn: I don't think there are.
14:17:39 <tromp> they repeat in 0000 :)
14:17:56 <MostAwesomeDude> n/(2^m) for any integer n and m will have a terminating decimal representation.
14:18:01 <c_wraith> petrosgr: new classes must have new names.  The fact that a class depends on another class isn't anything like a java subclass
14:18:11 <merijn> mauke: Damn, smart people are disagreeing now I need to invest time to look up proof and potentially look stupid when I'm wrong :(
14:18:30 <MostAwesomeDude> merijn: It's the Internet, don't worry about it. :3
14:18:48 <MostAwesomeDude> *2 for IRC.
14:18:54 <MostAwesomeDude> And another *2 for #haskell :3
14:19:00 <hpc> merijn: 10 is divisible by 2; all negative powers of 2 have a finite representation in base 10; all base-2 fractions are sums of those powers; QED
14:19:49 <petrosgr> c_wraith: I see, thanks. It should have been obvious from the fact that class methos are in global scope...
14:20:22 <merijn> Bah, now I need to figure out where I got this stupid idea from >.>
14:20:23 <c_wraith> petrosgr: well, module scope anyway.  But yeah, they're externally visible.
14:20:36 <petrosgr> c_wraith: correct.
14:20:42 <mauke> preflex: calc '2 1/3
14:20:43 <preflex>  0.01010101010101010101010101010101010101010101010101
14:21:16 <hpc> merijn: base-12 perhaps?
14:21:22 <Jafet> Base e
14:21:32 <MostAwesomeDude> preflex: calc '3 1/4
14:21:32 <preflex>  0.02020202020202020202020202020202
14:21:37 <MostAwesomeDude> Hah, that's awesome.
14:21:37 <hpc> there are finite base-12 decimals that are not finite in base-10
14:22:00 <mauke> preflex: calc 12'0.1
14:22:00 <preflex>  0.08333333333333333
14:22:44 <petrosgr> I was trying to do this in order to make Data.Binary.Derive work.
14:22:53 <Sgeo> I have a garbage collection question
14:23:00 <Sgeo> Suppose I have several threads waiting for an MVar
14:23:01 <petrosgr> Does anyone have experience with Data.Binary.Derive?
14:23:17 <Sgeo> There are no references to the thread, and besides the threads waiting on the MVar, no references to the MVar
14:23:30 <Sgeo> Are they stuck forever, sitting in memory waiting for nothing to happen?
14:23:42 <mauke> maybe
14:23:48 <petrosgr> I'd like to use it to serialize a large number of data types.
14:24:06 <petrosgr> with as little boilerplate as possible
14:24:56 <Saizan> Sgeo: the GC will throw a BlockedIndefinitely or something at those kind of threads, though i'm not sure if it's guaranteed or not
14:25:15 <Jafet> It is guaranteed, but not by the GC
14:25:23 <Jafet> By the GHC IO manager I think
14:25:31 <Sgeo> Should I worry about it this much?
14:25:36 <Jafet> The documentation is either at MVar or Exception
14:28:27 <Zoxc> does anyone know how the performance of recursive descent parsers or compiler frontends in general in Haskell compares to say C?
14:29:05 <Jafet> Small constant factors
14:29:36 <Jafet> that may or may not be greater than 1
14:29:38 <Sgeo> Why isn't there a modifyTVar?
14:29:43 <hpc> Jafet: haha
14:33:16 <Sgeo> Whee, my code compiles
14:33:27 <Sgeo> I can't help fear that it might not do what I want though
14:33:48 <hpaste_> Sgeo pasted “Hideous joinEvent stuff” at http://hpaste.org/56572
14:36:08 <JoeyA> How do I get GHC 7.2.2 and cabal running on Windows?  I already have the Haskell Platform with GHC 7.0.3, and many packages built with 7.0.3, but I want to upgrade to 7.2.2.
14:37:47 <JoeyA> I already ran the installer, but the 7.0.3 install is still taking precedence.
14:39:10 <dcoutts> JoeyA: each install of ghc is independent, in particular each has its own set of libs
14:39:23 <dcoutts> so you can have 7.0.3 and 7.2.2 installed at once
14:39:38 <dcoutts> but the libs for each will be completely separate
14:39:43 <JoeyA> Thanks
14:39:58 <dcoutts> you can tell cabal which to use using the -w flag
14:40:06 <JoeyA> Ah
14:40:08 <dcoutts> e.g. cabal install -w ghc-7.2.2 foo
14:40:11 <derpladee> is there anything in haskell that looks like: next :: a -> (a -> a) -> [a], next a f = a : (next (f a) f) ?
14:40:20 <dcoutts> JoeyA: assuming ghc-7.2.2.exe is on the %PATH%
14:40:41 <JoeyA> Will that automatically ensure packages aren't built with a mixture of 7.2.2 and 7.0.3?
14:40:41 <hpc> :t iterate
14:40:42 <lambdabot> forall a. (a -> a) -> a -> [a]
14:40:47 <hpc> > iterate succ 5
14:40:48 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
14:40:55 <hpc> > iterate (* 2) 1
14:40:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:41:02 <hpc> derpladee: ^
14:41:11 <dcoutts> JoeyA: it picks one instance of ghc, by default the one called ghc.exe on the %PATH%
14:41:31 <derpladee> hpc, thanks
14:42:40 <JoeyA> Ah, so it installs them like this: C:\Program Files\Haskell\stm-linkedlist-0.1.0.0\ghc-7.2.2
14:43:27 <JoeyA> dcoutts: So I can basically build my program with cabal install -w ghc-7.2.2 pkg1 pkg2 .  Easy, thanks!
14:43:55 <dcoutts> JoeyA: assuming you can get all your package deps to build with that version of ghc, yes.
14:44:16 <Jafet> @pl next a f = a : next (f a) f
14:44:16 <lambdabot> next = fix (liftM2 (.) (:) . flip flip id . (ap .) . (. flip id) . (.))
14:44:26 <Jafet> @slap lambdabot
14:44:26 * lambdabot hits lambdabot with an assortment of kitchen utensils
14:44:30 <JoeyA> I was looking for an obscenely complicated way to do it.  I wonder if there's a way to get my %PATH% to give ghc 7.2.2 higher priority.
14:44:36 <Sgeo> I don't know if the Monad instance I wrote even does what I want it to do :/
14:48:52 <Enigmagic> JoeyA: %PATH% is scanned left to right, so just put the 7.2.2 bits in before the other stuff
14:50:05 <JoeyA> Enigmagic: I tried to update %PATH% in Control Panel -> System -> Advanced -> Environment Variables (I'm on Windows XP)
14:50:16 <mikeplus64> is there a way to get ByteString literals? there is OveloadedStrings, but that seems to just hide the conversion from string -> whatever
14:50:26 <JoeyA> but it doesn't contain all of %PATH% when I open a terminal and echo %PATH%
14:50:41 <JoeyA> The Haskell Platform somehow puts additional paths before mine.
14:50:57 <Enigmagic> JoeyA: did you check both PATH entries (user & system) in the control panel?
14:51:20 <JoeyA> mikeplus64: There's Data.ByteString.Char8.pack "Hello" (which is what OverloadedStrings will do by default)
14:51:40 <JoeyA> And there's the utf8-string package, which has Data.ByteString.UTF8.fromString
14:52:22 <JoeyA> Enigmagic: Ah, I didn't notice that.  Thanks!
14:52:23 <mikeplus64> JoeyA: I mean, without having to convert from a String
14:52:34 <mm_freak> mikeplus64: what's wrong with OverloadedStrings?  are you concerned about the conversion still being done?
14:52:37 <JoeyA> Not that I'm aware of.
14:53:13 <mikeplus64> mm_freak: curious mainly, but yes I don't like the conversion being done at run-time, but I'm not really concerned about it as such
14:53:39 <mm_freak> mikeplus64: you can't ensure that really…  there is no mechanism for literals in the target representation
14:53:46 <JoeyA> Also, be careful to use Data.ByteString.UTF8 qualified.  Last time I tried, IsString's fromString function overrides whatever is already defined without warning...
14:53:51 <mm_freak> even integer literals need to be converted, although probably that's optimized away
14:54:13 <mm_freak> at least for the standard types
14:56:48 <mikeplus64> well, that's quite lame, oh well
14:57:39 <mm_freak> mikeplus64: that's the semantics of haskell…  OverloadedStrings just enables the from* mechanism for strings
14:57:46 <mm_freak> fromInteger, fromRational, fromString, etc.
14:58:04 <mm_freak> but seriously, it's not a big deal ;)
14:58:58 <Jafet> How are Strings encoded in a binary, anyway?
14:59:07 <Jafet> Literal Strings, that is
14:59:22 <mm_freak> Jafet: in lower level languages usually you would put the raw string into the data section of the binary
14:59:46 <Jafet> Lower-level than Glasgow Haskell
15:01:14 <mikeplus64> mm_freak: yeah, it's just that having to convert String to ByteString when everyone says "don't use String it eats babies" (ok, a bit of a hyperbole) makes the OCD deep inside of me cringe with the force of a thousand suns
15:01:31 <c_wraith> mikeplus64: you should be converting to Text
15:01:51 <mikeplus64> c_wraith: that works too
15:02:00 <mm_freak> mikeplus64: again, it's not a big deal…  i'm pretty experienced with high performance network in haskell, and that conversion is the least of your worries ;)
15:02:09 <mikeplus64> yeah
15:02:24 <mm_freak> it's usually done only once anyway, in my experience
15:02:34 <JoeyA> FYI, the network-2.3.0.8 package fails to build with ghc-7.2.2 on Windows because it can't find gcc (which does exist, in C:\ghc\ghc-7.2.2\mingw\bin).
15:02:48 <mikeplus64> I suppose it'd only matter if you had a huge literal string in an actual .hs file, but you don't really have that
15:02:59 <mm_freak> JoeyA: FYI, you shouldn't use networking under windows =P
15:03:11 <JoeyA> Why not?
15:03:58 <mm_freak> mikeplus64: right…  the vast majority of strings you process come from outside (files, etc.)
15:04:06 <mm_freak> JoeyA: just joking
15:04:21 <JoeyA> Heh.  Not my choice.
15:04:52 <JoeyA> My program needs to run on a retro-encabulator.
15:16:56 <Sgeo> I wonder if someone can help me understand if my Monad instance does in fact follow the Monad laws
15:17:45 <c_wraith> most of the time, you can prove that it does by just working the methods symbolically
15:17:53 <c_wraith> But go ahead and paste it
15:20:30 <hpaste_> Sgeo pasted “Complicated monad” at http://hpaste.org/56573
15:20:35 <Sgeo> I just pasted in the whole file
15:20:44 <Sgeo> The monoid instance isn't relevent to the Monad instance
15:20:58 <Sgeo> Uh, oops
15:21:08 <Sgeo> join in the Monad instance should be joinEvent
15:21:51 <c_wraith> well, that one's terrifying.
15:22:02 <c_wraith> use of forkIO in return...
15:23:15 <Sgeo> Well, Events are not supposed to run their handlers in the thread they're initially executed in
15:24:16 <c_wraith> also, that data type is contravariant.  I'm not sure it can be a Monad.
15:25:02 <c_wraith> Or how you got a Functor instance to compile...  What am I missing?
15:25:32 <Sgeo> If a -> b is a data type, is it contravariant on a? Because then , surely doing it twice isn't? I'm not sure though
15:26:10 * Sgeo is a bit unsure what is meant by contravariant
15:26:23 <c_wraith> yes, that's what it means
15:27:07 <c_wraith> I will say, it's hard to follow anything without at least having the type for addHandler around
15:27:27 <Sgeo> addHandler :: (a -> IO ()) -> IO (IO ())
15:27:29 <Sgeo> Right there
15:27:33 <c_wraith> oh, hah.
15:27:33 <Sgeo> wait, no
15:27:39 <Sgeo> addHandler :: Event a -> (a -> IO ()) -> IO (IO ())
15:27:43 <c_wraith> I have trouble with seeing names inside of newtypes.  personal error. :)
15:28:31 <c_wraith> You're right, that becomes covariant after being used twice in contravariant position
15:39:14 <Sgeo> c_wraith, any thoughts on the correctness/sanity of the Monad instance?
15:39:36 <Sgeo> I ... think, when using this as a monad, what will happen is sort of an event that fires as each component event fires
15:39:38 <c_wraith> sanity is questionable.  Might actually be morally correct, though
15:42:49 <Sgeo> *Network.Activeworlds.Event> addHandler (return 'a') putChar
15:42:49 <Sgeo> Loading package array-0.3.0.2 ... linking ... done.
15:42:49 <Sgeo> Loading package stm-2.2.0.1 ... linking ... done.
15:42:49 <Sgeo> a*Network.Activeworlds.Event>
15:50:35 <Sgeo> My monoid instance is wrong
15:50:43 <Sgeo> addHandler ((return 5) `mappend` (return 6)) print
15:50:43 <Sgeo> 5
15:50:43 <Sgeo> 6
15:50:58 <Sgeo> That's not the behavior I intended out of the Monoid instance... yes it is
15:51:19 <dobblego> perhaps you want the YesNoYes instance?
15:51:45 <dobblego> instance Monoid WellIsIt? where mempty = Yes
15:52:56 <Axman6> anyone know if anyone's written a DEFLATE codec in Haskell?
15:53:19 <ivanm> @google deflate haskell
15:53:21 <lambdabot> http://hackage.haskell.org/packages/archive/zlib/0.5.0.0/doc/html/Codec-Compression-Zlib-Raw.html
15:53:21 <lambdabot> Title: Codec.Compression.Zlib.Raw
15:53:27 <ivanm> heh, doubt that's it
15:53:34 <Axman6> @hoogle deflate
15:53:34 <lambdabot> Codec.Compression.Zlib.Internal Deflated :: Method
15:53:34 <lambdabot> Codec.Compression.Zlib.Raw Deflated :: Method
15:53:34 <lambdabot> Codec.Compression.Zlib Deflated :: Method
15:53:42 <Axman6> @hoogle+
15:53:42 <lambdabot> Codec.Compression.GZip Deflated :: Method
15:53:42 <lambdabot> Codec.Compression.Zlib.Internal deflateMethod :: Method
15:53:42 <lambdabot> Codec.Compression.Zlib.Raw deflateMethod :: Method
15:53:43 <Axman6> @hoogle+
15:53:43 <lambdabot> Codec.Compression.Zlib deflateMethod :: Method
15:53:43 <lambdabot> Codec.Compression.GZip deflateMethod :: Method
15:53:49 <ivanm> @more
15:53:52 <Axman6> @hoogle+
15:53:56 <Axman6> :(
15:54:01 <ivanm> awwww, @more doesn't work with @hoogle?
15:54:05 <ivanm> or has it just run out?
15:54:20 <Axman6> that only works with... other commands
15:55:39 <ivanm> this mentions the DEFLATE algorithm: http://coder.bsimmons.name/blog/2009/06/fun-with-lazy-arrays-the-lz77-algorithm/
15:55:59 <ivanm> implementation doesn't look too great though
16:02:13 * ski wonders whether `eventMVar' is ever meant to be called more than once on the same `MVar a'
16:06:14 <ski> Sgeo : "That's not the behavior I intended out of the Monoid instance... yes it is" -- huh ?
16:13:05 <lpsmith> So I'm playing with configurator
16:13:18 <ddarius> Why am I ever-foiled in my quest for semi-hemi-demi-faux Chinese cuisine?
16:13:21 <lpsmith> and it appears to deadlock the whole threaded runtime when I change a configuration
16:13:40 <shachaf> ddarius: Do you live in China?
16:14:05 <ddarius> shachaf: No.
16:14:21 <shachaf> There you go, then.
16:14:41 <ddarius> I don't want -authentic- Chinese cuisine.
16:14:51 <lpsmith> Chinese is good,  but I tend to prefer Indian or Mexican
16:14:52 <mm_freak> is there a simple real time graphing library?  i really just need to draw some data points on a blank surface
16:15:00 <shachaf> Oh, now I see.
16:15:07 <ddarius> Actually, I wouldn't mind -also- having authentic Chinese cuisine.
16:21:03 <lpsmith> has anybody been using configurator with 7.4.1-rc1?
16:21:32 <lpsmith> I seem to be deadlocking the whole runtime system
16:24:09 <lpsmith> yeah, something is throughly broken
16:24:24 <lpsmith> I'm not feeling good about deploying on 7.4.1.   Sigh
16:25:54 <c_wraith> lpsmith: are you at least going to be filing GHC tickets?
16:26:08 <lpsmith> yes
16:26:35 <lpsmith> I'm going to try reducing the test though first
16:26:56 <irene-knapp> don't spend a lot of effort reducing it, nobody has time to fix it anyway ^^'''
16:27:01 <irene-knapp> or that's been my experience
16:27:13 <lpsmith> no, this is important enough they'll fix it
16:27:34 <lpsmith> I'm deadlocking the whole runtime, for whatever reason
16:27:44 <irene-knapp> I would hope so, but I'm about 60% certain we haven't been doing constant-folding when profiling is off on most platforms
16:27:58 <irene-knapp> granted they couldn't reproduce even after I reduced, but :/
16:28:18 <irene-knapp> not sure why - I was able to on a separate box from my main, on an unrelated architecture
16:28:36 <lpsmith> well,  deadlock beats not  constant folding.  That's like,  at least a straight to a two pair :)
16:28:40 <irene-knapp> granted
16:28:54 <lpsmith> maybe a bit more than a two pair
16:29:32 <irene-knapp> the thing is that the one I found, right, goes away when profiling is on (because more information gets put in the .hi file)
16:29:49 <irene-knapp> so it's hard to notice when you're looking at your code for performance problems
16:30:21 <irene-knapp> you can observe it with --hi-dump or whatever the option is though, and when another bug that I also found is present, it triggers that one
16:30:37 <lpsmith> can't you spot it through examining ghc core?
16:30:42 <irene-knapp> yes
16:30:48 <irene-knapp> that also
16:31:36 <irene-knapp> the problem is simply that the built-in rewrite rules which implement constant folding never get a chance to fire because cross-module inlining, which is supposed to cause ie. the multiplication operator to turn from a class method into a primop, never happens
16:31:48 <irene-knapp> because the information needed to actually do the cross-module inlining is not in the .hi file
16:31:57 <lpsmith> hmm
16:31:59 <irene-knapp> which in turn is because the format of the .hi file changed at some point to not have a spot for that information
16:32:01 <irene-knapp> only nobody noticed
16:32:22 <irene-knapp> but there's a different spot the information can also reside and when it's there everything is copacetic
16:32:24 <lpsmith> any idea of when that changed, roughly speaking?
16:32:28 <irene-knapp> no, no idea
16:42:00 <mm_freak> given GHC 7.0.3, is there a way to update to base 4.4?
16:42:05 <mm_freak> without updating GHC
16:42:39 <c_wraith> no
16:42:47 <c_wraith> base is locked to a ghc version
16:45:40 <mm_freak> i wonder whether arch will ever update to GHC 7.2
16:46:46 <Cale> I wonder whether I will ever actually care which version of GHC my distribution has
16:46:49 <c_wraith> They shouldn't
16:47:04 <c_wraith> GHC 7.2 was never intended to be used by anyone other than library authors
16:47:23 <shachaf> Cale: Are you going to be in Boston this weekend?
16:47:30 <Cale> no :P
16:47:31 <mm_freak> has repa improved since 2.1.1.5?  the last time i tried it, it was rather slow compared to regular vectors
16:47:40 <shachaf> :-(
16:48:01 <Cale> I'm always on IRC thouhg
16:48:04 <Cale> though*
16:48:05 <mm_freak> and now that i can't try the latest version, i have to ask here =)
16:48:13 <Cale> It doesn't really matter where I am physically :P
16:48:46 <shachaf> Cale: It, like, totally matters, man!
16:50:02 <dylukes> I want to shoot myself
16:50:09 <dylukes> I'm pasting a base64 encoding of an SVG
16:50:10 <dylukes> of a font
16:50:12 <dylukes> into tumblr
16:50:14 <shachaf> dylukes: Because you're not going to Hac Boston?
16:50:15 <Sgeo> :t (<$)
16:50:16 <shachaf> Oh.
16:50:16 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:50:16 <dylukes> what ever happened to "web 2.0"
16:50:29 <shachaf> I don't get it.
16:50:50 <ddarius> Oh fuck.  This weekend is this weekend.
16:50:57 <dylukes> https://gist.github.com/4010ca9b0c6443105914
16:51:06 <Cale> dylukes: I don't understand what would motivate you to do that...
16:51:15 <dylukes> Cale: lack of external hosting.
16:52:36 * ddarius <3 data urls.
16:52:55 <shachaf> ddarius: Are you going to HacBos?
16:53:01 <mike-burns> This Boston thing is gonna be big, eh?
16:53:12 <shachaf> The biggest.
16:53:28 <shachaf> I heard that even ddarius will be there.
16:53:41 <mike-burns> Well that sure is exciting.
16:53:54 <ddarius> shachaf: Does that require putting on pants?
16:54:10 <shachaf> ddarius: I don't make the rules. Ask edwardk.
16:54:12 <mike-burns> It's at MIT, so no.
16:54:21 <shachaf> Ah. There you go, then.
16:54:59 <dylukes> oh fuck tumblr
16:55:08 <dylukes> why do you have 7031 js warnings, and 4 js errors.
16:55:15 <dylukes> JS is just like "errors? w/e."
16:55:43 <mike-burns> Whereas Haskell is like, "errors? I have all these different, incompatible ways of representing them!"
16:56:10 <Cale> What is tumblr anyway? Like some sort of imageblog thing?
16:56:25 <shachaf> Cale: As far as I can tell it's like Twitter but for longer posts.
16:56:28 <augur> Cale: tumblr is a tumblog host!
16:56:35 <shachaf> I.e., a lot of emphasis on reposting other people's things.
16:56:46 <nyingen> it's actually a pretty nice blogging platform, though 99% of users seem to just reblog photos
16:56:55 <augur> shachaf's description is pretty correct
16:56:57 <mike-burns> It's easy to laugh at, and a great way to do marketing.
16:57:10 <augur> you usually have different modes of posting
16:57:19 <augur> so you have text posts or picture posts or whatever
16:59:15 * ddarius goes to the logical conclusion.  You can post only a bit of information.  Alive? [ ]
16:59:37 <mike-burns> I've started that project a few times, and a few other logical conclusions.
16:59:51 <mike-burns> No one actually wants to use it.
17:04:11 <ddarius> mike-burns: You have to make an app that will use it for the users.
17:04:28 <mike-burns> Yup, tried that. It's very tricky.
17:04:39 <mike-burns> That turns out to be difficult data to get.
17:06:04 * ddarius makes a button pressing app.  All your button pressing needs at the press of a button.
17:07:58 * cmccann wonders if anyone has played the game "Progress Quest"
17:08:56 <c_wraith> "played" is an awfully strong word for "turned it on and watched it run once"
17:08:57 <Cale> <fine-print>You grant ddarius corp. the right in perpetuity to use your button presses for any purpose whatsoever, including but not limited to selling your button pressing statistics to affiliates of ddarius corp.</fine-print>
17:09:28 <irene-knapp> cmccann: I'm familiar with it.
17:09:34 <cmccann> c_wraith, it's slightly less interactive than many popular games, yes, but pretty similar in spirit
17:09:53 <c_wraith> cmccann: Not games I play. :)
17:10:01 <cmccann> the gameplay is pretty similar to most MMORPGs when you get right down to it
17:10:08 <cmccann> just streamlined further
17:10:14 <ddarius> It's more interactive than the games c_wraith plays.
17:10:34 <c_wraith> yeah, the games I play don't even give you feedback on their current state.
17:10:46 * shachaf wonders if anyone has played the game "Journey to Alpha Centauri (In Real Time)"
17:10:46 <Cale> Black box game of life
17:10:51 <cmccann> heh
17:11:11 <ivanm> shachaf: heh
17:11:13 <c_wraith> I played IdleRPG once.
17:11:23 <ivanm> wasn't there a similar game about catching a bus through nevada or something?
17:11:34 <c_wraith> But sitting in an IRC channel without talking was too hard, so I quit.
17:12:17 <shachaf> mauke plays IdleRPG.
17:12:38 <irene-knapp> Desert Bus
17:12:41 <irene-knapp> driving the bus
17:12:42 <irene-knapp> not catching it
17:13:31 <Cale> Desert Bus has so much verisimilitude
17:13:34 <irene-knapp> (the steering wheel, I am informed, pulls slightly to the right)
17:13:43 <irene-knapp> (so that you cannot just put the controller down)
17:14:01 <irene-knapp> (every five minutes or so you get to see a cactus.  otherwise the screen is featureless.)
17:14:18 <irene-knapp> (there is no soundtrack, but it fully supports the "hook up the music device of your choice and play it at the same time as the game" protocol.)
17:14:39 <Cale> http://loadingreadyrun.com/videos/view/238/LRReview-Desert-Bus
17:14:49 <irene-knapp> yes, thank you
17:14:54 <irene-knapp> yay for C=64 themes
17:15:29 <ivanm> irene-knapp: heh (for the audio access)
17:15:33 <irene-knapp> yeah :)
17:17:10 <irene-knapp> speaking of presentation the lack of ability to pause?. ahahah
17:19:55 <irene-knapp> ahahahaha "It's due for release about fifteen years ago."  "Really?  It's up against some tough competition!"  "How do you figure?"  "Well, it's slated to come out the same day as Duke Nukem Forever."
17:20:19 <ivanm> heh
17:34:48 <Modius> Okay, maybe a common question - I'm not trying to start s*** here; but can someone point me to a good article/page discussing the prediction of space usage of lazy programs?
17:38:04 <ivanm> Modius: it's not that easy
17:38:15 <ivanm> because it depends on how you write it
17:38:50 <ddarius> Modius: Can you point me to a good article discussing the prediction of space usage of eager programs?
17:45:46 * cmccann predicts that most programs will require space to run
17:49:20 <ChaosMonkey> hi, can anyone answer an xmonad related question for me?
17:50:01 <lpsmith> ChaosMonkey, I probably can't, but go ahead and ask :)
17:50:08 <lpsmith> Somebody probably can
17:55:01 <Modius> Well that was helpful
17:58:14 <Sgeo> Why is it that Haskell uses :: for type signatures and other languages use :?
17:58:30 <Sgeo> I'm looking at the Idris tutorial, and I see how nicely : aligns with =
17:58:56 <ivanm> I tend to line up :: with =
17:59:07 <ivanm> I think it's more because :: sticks out more than just :
17:59:15 <ivanm> and : is used for list consing
17:59:37 <shachaf> I think : for "type" would be nicer in Haskell.
17:59:48 <shachaf> But it's not important enough to care about unless you're designing a new language.
18:00:19 <Sgeo> I can barely look at a language that uses : for type, Haskell is that embedded in my brain. But I see the benefits to :
18:00:46 <derpladee> hey guys i need a function like :: Int -> [a] -> ([a],[a]) that will split a list in two with the first one containing all elements before number X and the second one containing all elements after number X
18:00:51 <derpladee> is there anything like that in haskell?
18:00:58 <hpc> :t break
18:00:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:01:02 <hpc> :t split
18:01:03 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:01:09 <hpc> :t breakAt
18:01:10 <lambdabot> Not in scope: `breakAt'
18:01:11 <shachaf> @hoogle Int -> [a] -> ([a],[a])
18:01:12 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
18:01:12 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
18:01:12 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
18:01:18 <hpc> ah, that
18:01:21 * shachaf takes a bow.
18:01:25 <derpladee> thanks :)
18:09:35 <derpladee> hey, i am using par from Control.Parallel to parallelize the execution of my program but i'm not seeing any speedup at all
18:09:44 <derpladee> am i supposed to use some switch when compiling or when executing the program?
18:10:25 <shachaf> derpladee: Yes, you want to compile with -rtsopts and then run with +RTS -N
18:10:34 <bertolo> can anyone help me in private?
18:10:34 <shachaf> -rtsopts -threaded, rather.
18:10:35 <bertolo> small doubt
18:10:44 <bertolo> about expression types
18:10:46 <shachaf> bertolo: Just ask your question here.
18:10:50 <bertolo> hmm ok
18:11:11 <derpladee> +RTS -N when i'm executing?
18:11:19 <derpladee> does it have to be -N2 if i have two cores?
18:11:20 <shachaf> derpladee: Also, you possibly want to use "pseq" as well, if you're using "par".
18:11:27 <bertolo> what is the type of this: [[1,2,3]]++fst ([[4]],[2])
18:11:45 <shachaf> I think -N with no options will default to the number of CPUs that are visible or something.
18:11:53 <shachaf> @type [[1,2,3]]++fst ([[4]],[2])
18:11:54 <lambdabot> forall t. (Num t) => [[t]]
18:12:07 <shachaf> bertolo: You can figure that out by using ":type" in ghci.
18:12:13 <bertolo> i know
18:12:16 <bertolo> my problem is not that
18:12:22 <bertolo> is the Num t => thing
18:12:23 <derpladee> shachaf, ghc says "-rtsopts unrecognized flag"
18:12:24 <bertolo> i dont get it
18:12:40 <shachaf> derpladee: Are you sure you're spelling it correctly?
18:12:44 <ski> > [[1,2,3]]++fst ([[4]],[2]) :: [[Integer]]
18:12:45 <lambdabot>   [[1,2,3],[4]]
18:12:48 <ski> > [[1,2,3]]++fst ([[4]],[2]) :: [[Rational]]
18:12:49 <shachaf> bertolo: You should probably read an introduction to Haskell, then. :-)
18:12:49 <lambdabot>   [[1 % 1,2 % 1,3 % 1],[4 % 1]]
18:13:08 <shachaf> We could explain it in here but many people have written out more detailed explanations already.
18:13:09 <derpladee> this is copy pasted: -rtsopts
18:13:13 <shachaf> @where lyah
18:13:14 <lambdabot> http://www.learnyouahaskell.com/
18:13:28 <shachaf> derpladee: Is that an old version of GHC or something?
18:13:29 <Axman6> :t 1
18:13:29 <lambdabot> forall t. (Num t) => t
18:13:47 <derpladee> 6.12.1
18:13:54 <Axman6> ew :(
18:13:57 <derpladee> -threaded works fine
18:14:14 <shachaf> derpladee: Oh, -rtsopts may have gotten added in GHC 7.
18:14:15 <bertolo> zzzz
18:14:20 <shachaf> So in GHC 6 you don't need i.
18:14:24 <shachaf> s/.$/t./
18:14:40 <derpladee> but i still need +RTS -N when executing?
18:15:07 * ybit is looking for string slicing operations....
18:15:13 <shachaf> derpladee: Yes.
18:15:23 <shachaf> derpladee: There's probably a wiki page or something that describes all this.
18:15:31 <bertolo> what about this one: infer the most general type of this: f x y z = ( length (y ++ (fst x))) == 2*z
18:15:49 <ybit> e.g. in python i can check to see if a string is a palindrome using the following... lambda p: str(p) == str(p)[::-1]
18:15:55 <ybit> would be handy to do something like that in haskell
18:16:12 <shachaf> pal x = x == reverse x
18:16:20 <derpladee> i just haven't been able to find it :)
18:17:03 <DanBurton> @type truncate . sqrt . fromIntegral -- is there a way to tell the intermediate fractional type that will be used here?
18:17:04 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
18:17:11 <shachaf> @google ghc parallel smp
18:17:12 <lambdabot> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/using-smp.html
18:17:12 <lambdabot> Title: 4.14.�Using SMP parallelism
18:17:29 <shachaf> DanBurton: Yes -- give explicit type signatures.
18:17:42 <ybit> shachaf: thanks
18:17:44 <shachaf> @ty show . read -- same as this
18:17:45 <lambdabot> String -> String
18:17:46 <DanBurton> shachaf: I mean I want to know what is inferred
18:17:54 <bertolo> what about this one: infer the most general type of this: f x y z = ( length (y ++ (fst x))) == 2*z
18:17:54 <shachaf> DanBurton: Oh. Read about defaulting.
18:17:55 <DanBurton> shachaf: and defaulted
18:18:16 <shachaf> bertolo: Is this homework or something?
18:18:23 <The_Journey> hi, I have a low-level C function that takes in a callback function from Haskell that has the type:: [Double] -> [Double], how may I convert this callback function into a function that C can use? The C expects a call back with the signature:: typedef int (*callbackFunc) (int, double*, int double*)
18:18:32 <bertolo> nop
18:18:35 <bertolo> got a exam tomorrow
18:18:37 <bertolo> and i dont get it
18:18:43 <DanBurton> shachaf: no I'm just curious
18:18:44 <bertolo> dont worry too much if you dont want to help
18:18:57 <ybit> shachaf: but i don't understand that
18:19:01 <shachaf> The_Journey: You'll need to do a bit of work to convert [Double] <-> (Ptr Double)
18:19:01 <DanBurton> shachaf: about the correctness of it
18:19:51 <ybit> pal --function declaration  got it.. x = x --what?  == reverse x --this i can understand
18:20:10 <Axman6> The_Journey: int double* int double*? that seems very wrong
18:20:17 <shachaf> pal = \x -> x == reverse x
18:20:21 <The_Journey> shachaf: I'm not tryingto convert [Double] into Ptr Double, I am trying to write a Haskell function that has the type [Double] -> [Double] that C can use when it expects the function to call to be (int, double*, int, double*) where each int is the total number of element in each array
18:20:41 <shachaf> pal = (\(x) -> ((==) (x)) ((reverse) (x)))
18:20:41 <The_Journey> Axman6: int is the number of element, double* is the array
18:20:42 <DanBurton> Related question, what *is* the best way to take an integer square root? Is "truncate . sqrt . fromIntegral" the most efficient way to do it?
18:20:50 <shachaf> DanBurton: No.
18:20:53 <Axman6> The_Journey: ah, just missing a comma then?
18:20:54 <shachaf> @google integer square root
18:20:55 <lambdabot> http://en.wikipedia.org/wiki/Integer_square_root
18:20:55 <lambdabot> Title: Integer square root - Wikipedia, the free encyclopedia
18:20:56 <ski>   pal x = (x == reverse x)  -- if you prefer
18:21:05 <The_Journey> Axman6: yea
18:21:37 <DanBurton> shachaf: ah cool. I don't suppose integer square root is in the HP libs anywhere?
18:21:48 <shachaf> I have no idea.
18:21:51 <shachaf> @google haskell integer square root
18:21:52 <The_Journey> I gave up on using HMatrix's minimization because it's causing random segfaults, so I am trying to the C liblbfgs library
18:21:53 <lambdabot> http://www.haskell.org/haskellwiki/Generic_number_type
18:21:53 <lambdabot> Title: Generic number type - HaskellWiki
18:22:07 <shachaf> DanBurton: Anyway, going through floating points is a really bad way of doing it.
18:22:25 <ski> bertolo : what conclusion can you draw about the type of `x' from the use `fst x' ?
18:22:33 <DanBurton> shachaf: and yet quickCheck assures me that it's rather safe, which confused me.
18:22:48 <bertolo> ski its a tuple
18:22:59 <ski> bertolo : what conclusion can you draw about the type of `y' from `y ++ (fst x)' ? -- how about `x' ?
18:23:04 <bertolo> hmm
18:23:10 <DanBurton> @check let isqrt :: Int -> Int; isqrt = truncate . sqrt . fromIntegral in \x -> x > 0 ==> let y = isqrt (x*x) in y == x
18:23:11 <lambdabot>   Not in scope: `==>'
18:23:12 <shachaf> DanBurton: It's not when you get out of Double's precision.
18:23:17 <bertolo> wait, x is a Num?
18:23:17 <ski> bertolo : and how is a tuple type written ?
18:23:19 <shachaf> And @check is broken.
18:23:23 <DanBurton> :(
18:23:23 <shachaf> bertolo: Num isn't a type.
18:23:29 <bertolo> ok
18:23:32 <ski> shachaf : again ?
18:23:34 <bertolo> (Int,Int9
18:23:36 <bertolo> )*
18:23:38 <Axman6> you already said, x is a tuple
18:23:40 <shachaf> ski: ?
18:23:47 <ski> oh, `(==>)', yeah
18:23:56 <shachaf> @check True
18:23:57 <lambdabot>   "OK, passed 500 tests."
18:24:01 <bertolo> wait wait, my mistake now. lol yes x is the tuple, , fst x is the number
18:24:02 <ski> @check False
18:24:03 <lambdabot>   "Falsifiable, after 0 tests:\n"
18:24:04 <shachaf> Oh, wait, I guess it's not as broken as before.
18:24:06 <ski> @check ()
18:24:07 <lambdabot>   "Arguments exhausted after 0 tests."
18:24:16 <Axman6> bertolo: why is it a number? what is the type of (++)?
18:24:29 <DanBurton> @check let isqrt :: Int -> Int; isqrt = truncate . sqrt . fromIntegral in \x -> x > 0 || let y = isqrt (x*x) in y == x
18:24:31 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n"
18:24:41 <DanBurton> @check let isqrt :: Int -> Int; isqrt = truncate . sqrt . fromIntegral in \x -> x <= 0 || let y = isqrt (x*x) in y == x
18:24:43 <lambdabot>   "OK, passed 500 tests."
18:25:16 <shachaf> Integer -> Integer, please.
18:25:25 <Axman6> hmm, what should the integer square root of say 8 be?
18:25:49 <ski> Axman6 : which way to round ?
18:25:49 <Axman6> does Integer have anAarbitrary instance?
18:25:55 <bertolo> i dunno the type of the function (++), since im assuming it is a function
18:25:59 <Axman6> ski: that's what i'm wondering
18:26:16 <Axman6> bertolo: you haven;t seen (++)? surerly you have used it in the course
18:26:30 <bertolo> of course, but i dunno what to say about it's type
18:26:37 <Axman6> what does it do?
18:26:40 <shachaf> > let isqrt :: Int -> Int; isqrt = truncate . sqrt . fromIntegral in isqrt (58001622734^2)
18:26:42 <ski> Axman6 : i suppose i'd look for the largest `n' such that `n^2 <= x', if nothing else was said
18:26:42 <lambdabot>   2623131403
18:26:59 <DanBurton> @check let isqrt :: Integer -> Integer; isqrt = truncate . sqrt . fromIntegral in \x -> x <= 0 || let y = isqrt (x*x) in y == x
18:27:00 <shachaf> I guess that doesn't even fit in Int, though.
18:27:01 <lambdabot>   "OK, passed 500 tests."
18:27:02 <bertolo> probably, ([a]->[a]) ->a
18:27:10 <shachaf> Anyway, it's still broken.
18:27:15 <DanBurton> sadface
18:27:15 <Axman6> bertolo: do you know what it does?
18:27:22 <bertolo> it concatenates lists
18:27:33 <Axman6> so shouldn't the result also be a list?
18:27:40 <bertolo> not only lists
18:27:41 <shachaf> > let isqrt :: Integer -> Integer; isqrt = truncate . sqrt . fromIntegral in isqrt (58001622734281461423^2)
18:27:42 <lambdabot>   58001622734281465856
18:27:45 <Axman6> yes, only lists
18:27:55 <shachaf> bertolo: Your discussion might be better placed in #haskell-overflow.
18:28:00 <Axman6> (++) only concatenates lists (in the haskell prelude anyway)
18:28:04 <DanBurton> shachaf: excellent
18:28:07 <shachaf> Because we'll keep interrupting it otherwie.
18:28:20 <bertolo> ok ty
18:28:27 <Axman6> bertolo: i'll head to #haskell-overflow too
18:28:50 <DanBurton> > let isqrt :: Integer -> Integer; isqrt = truncate . (sqrt :: Ratio Integer -> Ratio Integer) . fromIntegral in isqrt (58001622734281461423^2)
18:28:51 <lambdabot>   No instance for (GHC.Float.Floating
18:28:52 <lambdabot>                     (GHC.Real.Ratio GHC...
18:28:59 <DanBurton> -_-
18:29:08 <shachaf> You can't take the sqrt of a ratio.
18:29:10 <shachaf> That don't make sense.
18:29:21 <shachaf> > let isqrt :: Integer -> Integer; isqrt = truncate . (sqrt :: CReal -> CReal) . fromIntegral in isqrt (58001622734281461423^2)
18:29:23 <lambdabot>   58001622734281461423
18:29:28 * shachaf takes a bow.
18:29:30 <DanBurton> CReal?
18:29:43 <ski> > pi :: CReal
18:29:43 <shachaf> That function is probably correct but inefficient.
18:29:43 <lambdabot>   3.1415926535897932384626433832795028841972
18:29:56 <DanBurton> @google haskell creal
18:29:58 <lambdabot> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
18:29:58 <ski> > showCReal 100 pi
18:29:58 <lambdabot> Title: Data.Number.CReal
18:29:59 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
18:30:19 <shachaf> DanBurton: Did you know Google also works in the web browser? :-)
18:30:26 <ski> > showCReal 100 (exp 1)
18:30:26 <shachaf> It's a new feature.
18:30:26 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
18:30:48 <shachaf> > showCReal 0 (exp 1)
18:30:49 <lambdabot>   "3"
18:31:25 <DanBurton> shachaf: nope :P i thought google was merely another lambdabot feature
18:31:57 <shachaf> DanBurton: That's how it started out, but it was so popular that they implemented a RESTful Web 2.0 Cloud API for it.
18:32:10 <shachaf> Now you can use it from the comfort of Internet Explorer.
18:32:16 * DanBurton shudders
18:32:30 <DanBurton> Internet Explorer is the farthest thing from comfort for me
18:32:54 <DanBurton> @google internet explorer web developer
18:32:56 <lambdabot> http://www.microsoft.com/download/en/details.aspx?id=18359
18:32:56 <lambdabot> Title: Download: Internet Explorer Developer Toolbar - Microsoft Download Center - Down ...
18:32:59 <DanBurton> aw
18:33:10 <DanBurton> was expecting the top hit to be scathing hatred
18:33:24 <shachaf> Anyway, that's enough offtopicness.
18:33:27 <DanBurton> aye
18:50:35 <Fey_> hello everyone...!
18:50:46 <Fey_> one quick question
18:51:06 <The_Journey> in FFI, how may I allocate enough memory for n number of CDouble to be passed into a C function as an argument with the type of double* ?
18:51:23 <shachaf> The_Journey: mallocArray or allocaArray or something?
18:51:43 <Fey_> how can i express simple comments "//" in a simple parser like Parse Char String using ParseLib
18:51:45 <Fey_> ?
18:51:59 <djanatyn> woo. got happstack-lite running just fine on windows - my presentation tommorow will be fine.
18:52:09 <The_Journey> shachaf: thank you
18:52:45 <Fey_> please someone? i am trying it 3 days and i cannot find the problem
18:52:53 <hpaste_> DanBurton pasted “Gets stuck on 3, 8, 15” at http://hpaste.org/56580
18:54:29 <Fey_> my basic idea was something like:     token "//" <*> many anySymbol <*> symbol '\n'
18:54:35 <Fey_> but this does not work
18:55:33 <shachaf> If only there was a convenient way of writing case ... of True -> ...; False -> ...
18:55:56 <DanBurton> shachaf: I am allergic to if statements
18:56:11 <shachaf> DanBurton: Fortunately Haskell has if expressions.
18:56:19 <shachaf> And guards.
18:56:31 <DanBurton> case makes things so clear
18:56:52 <shachaf> Anyway, it's not working because you have a bug.
18:56:57 <DanBurton> clearly
18:57:02 <DanBurton> but what is the bug?
18:57:08 <shachaf> I don't know.
18:57:14 <DanBurton> -____-
18:57:31 <shachaf> The fact that you're using Int might be a bug.
18:58:20 <shachaf> DanBurton: Look, you should obviously be using guards.
18:58:28 <shachaf> > (compare `on` length) "test z z'" "otherwise"
18:58:29 <lambdabot>   EQ
18:58:30 <shachaf> It's an omen.
18:58:43 * DanBurton begins littering his code with fromIntegral
18:58:52 <shachaf> What? Don't do that.
19:00:02 <shachaf> DanBurton: For (isqrt 3), (z,z') is cycling between (1,2) and (2,1).
19:00:51 <shachaf> Isn't "abs (x' - x) < 1" the same as "abs (x' - x) == 0", or "x' == x"?
19:01:13 * shachaf isn't sure what DanBurton is trying to do anymore.
19:01:19 <DanBurton> yes basically
19:01:22 <monochrom> yes if x' and x are integral
19:01:41 <DanBurton> i was just mindlessly translating math from wikipedia into code
19:02:04 <shachaf> I think it was a bit too mindless if you ended up with that code.
19:02:19 <DanBurton> hey, it works for most inuts
19:05:10 <hpaste_> DanBurton pasted “Fudging it (and guards, yay)” at http://hpaste.org/56581
19:05:31 <DanBurton> this hack tends to round up for the wibbly-wobbly cases
19:06:25 <shachaf> DanBurton: Well, this algorithm'll work with Rationals.
19:07:05 <DanBurton> shachaf: but avoiding Rationals was the whole point of trying this algorithm >,<
19:07:23 <shachaf> I thought it was avoiding floating point numbers.
19:07:27 <shachaf> Anyway, your new version is broken.
19:07:41 <DanBurton> yeah it lies sometimes
19:07:45 <shachaf> QuickCheck can probably tell you how.
19:07:48 <shachaf> E.g. isqrt 63
19:08:28 <DanBurton> in fact, any number n^2 - 1 is susceptible to the lie
19:08:32 <DanBurton> apparently
19:08:54 <shachaf> That's also not true.
19:08:55 <monochrom> you should first prove the wikipedia algorithm correct
19:09:13 <shachaf> monochrom++
19:09:43 <DanBurton> it's "Newton's approach"...according to Wikipedia
19:09:53 <DanBurton> and as we all know, Newton never got anything wrong >.>
19:09:57 <shachaf> DanBurton: Do you understand how Newton's method works?
19:10:47 <DanBurton> shachaf: sure, keep evaluating values in the converging sequence until the error is small enough.
19:11:15 <DanBurton> shachaf: upon reflection, I suppose rationals *are* necessary /sigh
19:11:22 <monochrom> normally, Newton's method is correct because (among other things) full real numbers are used, no truncation. clearly, once you butcher it to integers, the first question is why it should make progress at all instead of getting stuck
19:11:41 <DanBurton> surprisingly, it makes progress in most cases
19:12:04 <monochrom> under suitable conditions and/or modification, integers work. but you have to prove it. not a God-given.
19:12:27 <DanBurton> indeed
19:14:19 <monochrom> I also don't mean to say that wikipedia authors have a high chance of being wrong. but they have a low non-zero chance of being wrong.
19:14:47 <DanBurton> is there a divide operation on Rationals?
19:14:56 <monochrom> yes, it's call /
19:15:17 <DanBurton> @t (/)
19:15:17 <monochrom> > (1%1) / (2%1)
19:15:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:15:18 <lambdabot>   1 % 2
19:15:23 <irene-knapp> :t (/)
19:15:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:15:36 <shachaf> > (1/1) / (2/1) :: Rational
19:15:37 <lambdabot>   1 % 2
19:15:49 <irene-knapp> > pi / pi :: Rational
19:15:50 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
19:15:50 <lambdabot>    arising from a us...
19:15:51 <DanBurton> oh :P for some reason I saw Fractional but read Floating
19:16:04 <shachaf> Frational.
19:16:21 <irene-knapp> > (pi % 1) / (pi % 1) :: Rational
19:16:21 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
19:16:22 <lambdabot>    arising fr...
19:16:30 <irene-knapp> hm, anyway
19:16:37 <irene-knapp> well, I mean, I realize that pi is irrational :)
19:16:59 <irene-knapp> > realToFrac pi :: Rational
19:16:59 <lambdabot>   884279719003555 % 281474976710656
19:17:02 <irene-knapp> haha
19:17:03 <irene-knapp> I see
19:20:18 <Veinor> how do you 'pronounce' <- ?
19:20:31 <shachaf> "grunt"
19:20:38 <irene-knapp> the same way I "pronounce" asdf
19:20:46 <irene-knapp> heh, sorry
19:20:58 <irene-knapp> nah, "is drawn from" or something like that
19:21:06 <irene-knapp> works in most contexts that it has meaning in
19:21:13 <irene-knapp> though it's worth noting that it's actually distinct syntax
19:21:26 <irene-knapp> in guards, do-statements, and magic-list-thingies
19:21:35 <irene-knapp> list comprehensions, that's the word
19:21:48 <DanBurton> I second "is drawn from"
19:22:34 <DanBurton> I suppose if you want to get technical, you could call it "bind lambda", since it sort of translates into (>>= \)
19:22:40 <irene-knapp> heh, yes
19:23:03 <irene-knapp> but that's only for do-notation, as I noted
19:23:35 <monochrom> "x <- m" x likes m
19:23:42 <irene-knapp> haha!
19:23:44 <hpaste_> DanBurton pasted “No more bugs” at http://hpaste.org/56582
19:24:29 <irene-knapp> DanBurton: now find the minimal set of type annotations such that the program works.  once you've done that, wax eloquent on -cafe about how convenient type inference is that you can omit unnecessary stuff!
19:24:45 <DanBurton> lol
19:24:51 <irene-knapp> (in the event of multiple minimal sets, scrunch your eyes and pretend there's only one)
19:24:59 <shachaf> DanBurton: Now implement the Rational operations yourself instead of using Rational.
19:25:15 <DanBurton> shachaf: -___-
19:25:21 <shachaf> That way you don't ned to complain that you're not using Integers.
19:26:59 <hpaste_> DanBurton annotated “No more bugs” with “No more bugs (less types)” at http://hpaste.org/56582#a56583
19:27:57 <shachaf> That paste has just as many types as the other one.
19:28:20 <shachaf> Not as many annotations, though.
19:28:25 <DanBurton> yeah, yeah
19:28:33 <DanBurton> annotation is a long word
19:28:53 <DanBurton> anyways, thanks for the tips guys; I'm out for the night.
19:38:36 <NemesisD> hi all. i'm a bit confused: http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-LocalTime.html#g:1 indicates that TimeZone has a Read instance
19:39:06 <shachaf> NemesisD: My ghci agrees with it.
19:39:22 <NemesisD> however the source doesn't show one and read "-8:00" :: TimeZone complains that theres no instance Read TimeZone
19:40:05 <shachaf> λ> read "-8:00" :: TimeZone
19:40:06 <shachaf> *** Exception: Prelude.read: no parse
19:40:19 <shachaf> Are you sure you're referring to the same TimeZone type?
19:40:21 <parcs`> NemesisD: you have to import Data.Time
19:40:27 <shachaf> What does :i TimeZone say?
19:40:58 <shachaf> Mine says -- Defined in time-1.2.0.3:Data.Time.LocalTime.TimeZone
19:41:08 <thlorenz> I'm playing with a code sample from Learn You a Haskell:
19:41:39 <thlorenz> import Control.Monad
19:41:40 <thlorenz> import Data.Char
19:41:40 <thlorenz>   
19:41:41 <thlorenz> main = forever $ do
19:41:41 <thlorenz>     putStr "Give me some input: "
19:41:41 <thlorenz>     l <- getLine
19:41:41 <thlorenz>     putStrLn $ map toUpper l
19:42:26 <NemesisD> oh
19:42:27 <parcs`> NemesisD: the Read instance is defined in Data.Time.Format.Parse
19:42:35 <thlorenz> wondering why it behaves unexpectedly e.g. the output does not occur until I input some value (order of operations is odd)
19:42:36 <shachaf> thlorenz: Please don't paste more than a few lines of code in here.
19:42:38 <shachaf> You can use hpaste.org
19:43:02 <shachaf> thlorenz: It's probably a buffering issue.
19:43:03 <thlorenz> I thought 7 lines was ok
19:43:07 <thlorenz> oh
19:43:27 <NemesisD> parcs`: i don't see aa Parse module
19:43:29 <parcs`> thlorenz: getLine blocks until a line text is given
19:43:35 <thlorenz> so the putStr doesn't run until I reach the end of the IO ?
19:43:50 <parcs`> NemesisD: it is hidden and imported from Data.Time.Format
19:43:51 <shachaf> thlorenz: This has nothing to do with how IO works in Haskell. You'd have the same problem in C.
19:43:59 <thlorenz> I mean the putStr before the getLine
19:44:11 <shachaf> thlorenz: Try main = do { hSetBuffering stdout NoBuffering; forever $ do { ... } }
19:44:31 <parcs`> thlorenz: buffering issue. try putStrLn for a quick fix
19:44:43 <shachaf> putStrLn will also work.
19:44:51 <shachaf> As will inserting "hFlush stdout" after the putStr.
19:45:21 <thlorenz> thanks putStrLn worked
19:45:42 <NemesisD> man that format is gnarley
19:52:11 <thlorenz> shachf: hFlush stout as well and is closer to what it tries to achieve - thanks
19:52:31 <shachaf> This is a toy program so none of it matters anyway.
19:52:50 <thlorenz> well, I was just trying to understand what is going on ;)
19:53:11 <thlorenz> now I have a better idea
19:53:34 <NemesisD> screw time zones. storing everything as integers, using seconds offset
19:53:52 <Axman6> form what time in what timezone though? D:
19:55:01 * Cale grumbles at these annoying people who actually want jack detection to mute their speakers just because headphones happen to be plugged in
19:55:25 <Axman6> works fine in OS X :\
19:56:41 <dmwit> Cale: Alsa has a setting for that; perhaps jack does, too.
19:56:47 <NemesisD> Axman6: irrelevant. i'm having this receive an email and store something in a queue with a timestamp. so i figure ill calculate the integer offset as seconds, add that to the POSIX timestamp and i havethe correct timestamp
19:56:49 <Cale> Axman6: It's started working like that in Linux too, and I hate it. I like to leave my headphones plugged in even when I'm not wearing them.
19:56:56 <Cale> dmwit: Oh really?!
19:57:46 <Cale> dmwit: I talked to some ALSA and PulseAudio people before, but I guess they were the wrong people to talk to...
20:13:00 <startling> I don't understand monads at all; any advice?
20:13:22 <shachaf> startlin: Look at the FAQ.
20:13:26 <shachaf> @where faq
20:13:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:13:43 <Axman6> shachaf: start using them (they're a lot easier to use than to "get" without having used them)
20:13:48 <shachaf> In particular, there are a bunch of things you need to understand before you can "understand monads".
20:13:56 <Axman6> bleh, startling
20:14:01 <Axman6> i really need to stop doing that
20:14:01 <shachaf> Axman6: I'll keep that in mind. :-)
20:14:09 <Axman6> shachaf: use moar monads!
20:14:12 <shachaf> What, press a single key before tab-completing?
20:14:21 <Axman6> yeah
20:14:51 <shachaf> At least two is customary, yes.
20:15:09 <Axman6> startling: if you start using specific monads, like Maybe, List and Either, you'll start to see a pattern emerging.
20:15:56 <startling> Alright, I'll try and do that. thanks
20:16:20 <shachaf> Axman6: Do you have an objection to the FAQ's explanation, by the way?
20:16:32 <shachaf> If so, you should probably edit it or something so that it's better.
20:16:58 <Axman6> startling: the RWH chapter on the Maybe monad is quite enlightening if i remember rightly. you write a parser for a simple image format, non-monadically, and then you rewrite it monadically, and it becomes a lot clearer
20:17:14 <Axman6> shachaf: if i'd read it, I might. i'll take a look
20:17:57 <startling> Axman6: thanks, I'll look at that too.
20:18:09 <startling> since wikipedia is blacked out now, what is a functor?
20:18:17 <startling> is it just a word for a function that returns a function?
20:18:21 <shachaf> No.
20:18:37 <shachaf> @where typeclassopedia
20:18:37 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:18:45 <applicative> wow, wikipedia blackout; probably just as well
20:18:55 <applicative> @type fmap
20:18:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:19:08 <applicative> @type map
20:19:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:19:13 <shachaf> Axman6: I think the general idea, as proposed by kmc, is that it's not helpful to have every single person in the channel give an off-the-cuff pet explanation for every question that's asked; instead we should write really good explanations and then link to them when people ask questions.
20:19:24 <applicative> startling: that's all there is to Functor ^^^
20:19:37 <shachaf> applicative: (Well, not really.)
20:20:06 <applicative> fmap has to obey a couple laws to be legitimate ...
20:20:10 <Axman6> shachaf: that's a good idea I can support. I'll see if there's anything I can add
20:20:21 <shachaf> Axman6: That way the channel doesn't get crowded with repetitive noise and people talking over each other to get their explanation out.
20:20:53 <applicative> > fmap (+1) (Just 2)
20:20:53 <lambdabot>   Just 3
20:20:54 <shachaf> It also makes the channel less pleasant for regulars, which is one of the reasons he isn't in here nowadays.
20:21:11 <applicative> > fmap (+1) [1,2,3]
20:21:12 <lambdabot>   [2,3,4]
20:21:24 <Axman6> > fmap (+1) (Just 3)
20:21:25 <lambdabot>   Just 4
20:21:29 <shachaf> For specific questions, personalied IRC help is great; but for general-purpose questions like "what is a monad?" we can't hope to do better than some prewritten article.
20:21:33 <Axman6> > fmap (+1) (Left "Hello")
20:21:33 <lambdabot>   Left "Hello"
20:21:41 <Axman6> > fmap (+1) (Right 3)
20:21:41 <lambdabot>   Right 4
20:21:52 <shachaf> Ah, well. I tried.
20:22:09 <Axman6> shachaf: it's a hard habit to break >_<
20:22:16 <applicative> what other instances are abroad
20:22:26 <startling> Yeah, I was just really asking for links to explanations, not really explanations themselves.
20:22:26 <Axman6> (,)?
20:22:29 <applicative> nothing wrong with lambdabot illustrations
20:22:39 <applicative> we can produce them at about 7/min
20:24:04 <applicative> the typeclassopedia explains these things, but i wonder if you should read 'learn you a haskell'?
20:24:14 <applicative> it explains functor pretty well, as I remember
20:24:47 <applicative> functor types are ones you can 'map over'
20:24:52 <startling> I've read good chunks of learn you a haskell actually, as a supplement to 'a gentle guide to haskell
20:25:06 <startling> but thanks, I'll look there.
20:25:15 <startling> 'a  gentle guide to haskell
20:25:38 <applicative> the gentle guide is old, but it has the nature of a priceless classic
20:25:49 <startling> I've only read 'a gentle guide to haskell' up to the chapter on monads, and then I was derailed, ha.
20:26:16 <applicative> have you read the famous blog post by sigfpe, you could have invented monads.  not too bad
20:26:30 <Axman6> shachaf: I feel that #8.6 of the FAQ should be might higher in the list for the M-word section. it should be made clear that Monad is just an API much sooner
20:27:14 <ben_m> Where is that FAQ?
20:27:16 <shachaf> Axman6: kmc wrote most of the FAQ; if you have comments on it, talk to him (he'll be happy to hear taht someone else is working on it).
20:27:18 <applicative> but if you don't have total handle on functor and why e.g. Maybe _ , [_] (list) and IO _ are 'functor' types, it will be a bit rough getting Monad, which takes another step
20:27:19 <shachaf> @where faq
20:27:20 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:27:22 <ben_m> Thank you.
20:28:39 <applicative> startling: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html for what it's worth.
20:30:08 <startling> thanks!
20:34:55 <tigger> is there a nice alternative to Data.Map, that doesn't require the ord constraint?
20:37:50 <Axman6> tigger: what, just having Eq? you can use lists for that
20:38:38 <tigger> Axman6: yes, I was wondering if there was something faster than O(n)
20:39:34 <Axman6> how could there be without being able to order the elements? (you could hash too i guess, but if you can hash something, you can often order it too)
20:41:38 <tigger> Axman6: gotcha, yeah I know languages like python can do dictionaries with O(1), but the type system (or maybe its something else) makes that harder (impossible?) in haskell without io, just curious if there was a structure i was missing. Thnaks
20:42:19 <Axman6> there's a lot of assumptions to tackle there...
20:43:23 <tigger> axman6: yeah I guess the same thing is possible in haskell with a binary typeclass, or some sort of serialization, though, just wanted to see if I was overlooking somehting
20:43:35 <Axman6> eh?
20:43:42 <Axman6> we have a binary typeclass..
20:43:46 <Axman6> called Binary =)
20:44:06 <Axman6> i'm not sure what serialisation has to do with it
20:44:42 <applicative> tigger: i dont know what you're up to but did you look at the shiny http://hackage.haskell.org/package/unordered-containers
20:44:56 <Axman6> (requires hashing)
20:46:38 <tigger> Axman6: yeah, I'm not sure if this is correct, but I was trying to  saying, I guess you could write O(1) dictionaries, if you could convert data into its binary representation (serialize to binary), then just hash it. Binary library does that, but I guess I was just avoiding making the binary instance for my data
20:46:44 <tigger> applicative: thanks, I'll take a look!
20:52:37 <applicative> it seems the python dictionaries use a hash
20:54:07 <applicative> "Python's dictionary implementation reduces the average complexity of dictionary lookups to O(1) by requiring that key objects provide a "hash" function."
20:55:36 <dolio> Oh yeah?
20:55:43 <dolio> O(1) hash functions?
20:56:24 <Axman6> tigger: one of the reasons such a thing isn't done in haskell is that we quite often use infinite pieces of data
20:57:01 <tigger> Axman6: yes. interesting!
20:57:05 <applicative> seems a bit much, but so the docs say
20:57:53 <tigger> applicative: it makes sense why it shouldn't be built in, but I wonder if it is possible to do some sort of auto deriving, like we might derive eq, show, read, which work even for infinite types?
20:58:14 <Axman6> how can it?
20:58:42 <tigger> Axman6: I don't know really, I don't really understand how deriving works for eq, read, show, tbh
20:59:05 <applicative> we do derive eq and show for 'infinite' objects, or what are you thinking
20:59:28 <applicative> > let ones = 1 : ones in show ones
20:59:29 <lambdabot>   "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:59:43 <tigger> applicative: I was thinking about why it would be difficult to do auto deriving for binary instance
20:59:55 <Axman6> well, it doesn't make much sense to try and take the hash of something that's infinite, you'll never get a result (unless you're ok with clashes)
21:00:06 <Axman6> tigger: it's not
21:00:23 <tigger> Axman6: that is true as well for equality, which needs to cope with infinite types, no?
21:00:54 <Axman6> yes, but it doesn't really cope with infinite types very well either:
21:01:00 <Axman6> > [1..] == [1..]
21:01:03 <lambdabot>   mueval-core: Time limit exceeded
21:01:49 <applicative> > let ones = 1 : ones ; quasi_ones = 1:1:1:2:one in ones == quasi_ones
21:01:50 <lambdabot>   Not in scope: `one'
21:01:57 <applicative> > let ones = 1 : ones ; quasi_ones = 1:1:1:2:ones in ones == quasi_ones
21:01:57 <lambdabot>   False
21:02:41 <tigger> Axman6: yes, its only become a curiosity now, I've just decided to use standard lists, but I was interested in why its hard to do auto derviing for some sort of binary (or hash like instance), since it shouldn't be too hard to support it for the primitive (string, float, int, etc)
21:04:11 * applicative is compiling the UHC; somehow he feels he will regret this
21:04:15 <geekosaur> afaik the only reason it's not built in is that Binary isn't built in; but IIRC the standalone deriving package knows how to derive Binary
21:05:24 <dp_wiz> Can someone help with 'fixing' this snippet? http://hpaste.org/56587
21:06:50 <shachaf> dp_wiz: You can't really do that.
21:06:55 <geekosaur> you can't use a type as a value or use a wildcard to match a data constructor.  there are ways to do it with template haskell
21:07:23 <shachaf> You can sometimes do limited approximations of it, but the thing you're trying to do isn't fundamentally a thing that one does in Haskell.
21:07:32 <shachaf> Types are all checked at compile time.
21:08:09 <shachaf> Oh, wait.
21:08:13 <dp_wiz> The type itself is always a MyVal. What i want to check is the it's subtype: MyVal ...whatever...
21:08:26 <shachaf> I misread a bit. These are String and Bool values.
21:08:47 <shachaf> s/value/constructor/
21:09:01 <shachaf> "subtype" is probably not the word you mean.
21:09:29 <dp_wiz> yep. i'm a week-age newb (:
21:10:30 <dp_wiz> I can check that's required but in a dumb way - by writing out a really generic checker. And that's seems ugly...
21:10:33 <Philippa> dp_wiz: MyVal is a type constructor, and you want to find out one of the phantom types? GADT-style?
21:11:13 <shachaf> Philippa: I *think* dp_wiz means MyString and MyBool.
21:11:26 <shachaf> I don't know why I'm guessing what dp_wiz means, on the other hand.
21:11:37 <applicative> dp_wiz: hm, this could use some work. by String [(String _)] = return $ Bool True you mean something like isString [(MyString _)] = return $ MyBool True
21:11:41 <shachaf> I also don't know why dp_wiz is using lists.
21:12:09 <applicative> why not guess what dp_wiz means?
21:12:37 <dp_wiz> a cut from data definition is at 1st line. I can't really put it into words yet (:
21:12:45 <shachaf> applicative: Because it's not very productive to try to guess at vague questions instead of getting clarifications.
21:12:51 <shachaf> I think dp_wiz is very confused, though.
21:13:00 <dp_wiz> shachaf: you bet
21:13:02 <applicative> yes, so was everyone once
21:13:42 <shachaf> applicative: Right, I didn't say otherwise.
21:14:12 <shachaf> I guess we can go bit by bit over the things that are confused about dp_wiz's code.
21:14:20 <dp_wiz> I guess that there should be a way to write this with lambdas that wold take [uhm.. some of MyVal constructor?] and pattern-match it's arg against it.
21:14:29 <shachaf> dp_wiz: The first step is probably to get isString and isBool working.
21:14:38 <dp_wiz> shachaf: they are working
21:14:52 <shachaf> dp_wiz: No, there's no real way to do that. The typeclasses Typeable and Data might allow you to do what you want, though.
21:15:04 <shachaf> dp_wiz: Really? Then you must be missing some code.
21:15:08 * geekosaur remembers running into this early on as well, ultimately rewrote to use a different mechanism reminiscent of gtk2hs's castToMumble setup for Glade widgets
21:15:17 <shachaf> dp_wiz: Because there's nowhere that defines the data constructors "String" and "Bool".
21:15:23 <startling> does `const` just evaluate to the first of two arguments, or is there more to it?
21:15:31 <shachaf> startling: That's all it is.
21:15:35 <shachaf> > const 1 2
21:15:35 <lambdabot>   1
21:15:55 <startling> cool, that's the feeling I was getting but I didn't want to depend on it if I wasn't sure.
21:16:14 <shachaf> dp_wiz: There are a bunch of other questions, like "why are all these functions taking lists of MyVal instead of just a single MyVal?"
21:16:37 <shachaf> And "Why are you returning MyVal/ThrowsError MyVal, instead of Bool, given that this is a Haskell-level function?"
21:16:48 <shachaf> (It might be justified, of course; it depends on how you're using it.)
21:17:16 <dp_wiz> There is a 'data Unpacker = forall a. Eq a => AnyUnpacker (MyVal -> ThrowsError a)' and some related code like unpackString and friends.
21:18:01 <shachaf> Existential types?
21:18:12 <shachaf> Are you sure all this is necessary?
21:19:02 <dp_wiz> Yeah, maybe not for this task though.
21:19:30 <shachaf> I'm not sure that particular existential type is very useful.
21:20:00 <shachaf> It looks like you're trying to shoehorn a dynamic type system into Haskell's type system.
21:20:22 <shachaf> Which might make sense partly if what you're doing is implementing a dynamically-typed language -- but even in that case I think you're doing it excessively.
21:20:49 <dp_wiz> shachaf: yeah, for pocket scheme (from *that* book, yes).
21:21:08 <hpaste_> applicative annotated “How to generalize type checkers?” with “How to generalize type checkers? (annotation)” at http://hpaste.org/56587#a56590
21:21:23 <applicative> dp_wiz: this compiles for what its worth
21:21:38 <shachaf> I don't know what Pocket Scheme or *that* book are.
21:22:44 <applicative> dp_wiz: I introduced the identity monad since I didn't know what a ThrowsError a was
21:22:57 <dp_wiz> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours this one
21:24:35 <applicative> oh i see type ThrowsError a = Either LispError a
21:30:52 <dp_wiz> In essence i try to match a constructor "tag" from that data type, not the actual value or any of it's arguments.
21:40:03 <applicative> I don't get this typechecker function. If the first argument is a Bool, e.g. True, what is supposed to happen?
21:40:30 <The_Journey> when would I use applicative functors?
21:41:30 <applicative> > [(+1),(+2)] <*> [100,1000]
21:41:30 <lambdabot>   [101,1001,102,1002]
21:42:14 <The_Journey> applicative: I don't see how they are useful besides some few esoteric stuff like that
21:42:19 <ben_m> The_Journey, for computations in sequence, I guess
21:42:43 <dp_wiz> applicative: it's first argument is supposed to be (MyVal Bool _)
21:42:46 <ben_m> Someone summarized it for me in here once.
21:42:56 <The_Journey> doesn't that make the code more obsfucated?
21:43:02 <ben_m> No, not at all.
21:43:04 <applicative> dp_wiz, then the other values in the list don't matter
21:43:10 <applicative> ?
21:43:11 <dp_wiz> applicative: indeed
21:43:17 <ben_m> Look at parsec for examples
21:48:04 <dp_wiz> Maybe i should just write a "type?" primitive and do all the matching inside lang's stdlib with curry and ==...
21:48:28 <shachaf> In general I support writing as much of the language inside the language. :-)
21:48:42 <shachaf> (However, "?" in Scheme is usually a suffix for things that return booleans.)
21:49:08 <shachaf> (Also, "curry" doesn't mean "partially apply". Maybe you weren't saying it does, but anyway.)
21:49:45 <hpaste_> applicative annotated “How to generalize type checkers?” with “How to generalize type checkers? (annotation) (annotation)” at http://hpaste.org/56587#a56592
21:49:53 <dp_wiz> And what does it means?.. (:
21:50:04 <applicative> dp_wiz: why not pattern match ^^^
21:51:05 <dp_wiz> applicative: that's more like it, thanks.
21:51:49 <applicative> dp_wiz: it would be a little laborious if there were a lot of ways of being a MyVal
21:52:14 <dp_wiz> yeah, it has a lots of them already...
21:52:52 <dp_wiz> like, dozens.
21:54:35 <dp_wiz> Ah... With "type" primitive i still have to register them by hand with similar construct.
22:03:14 <hpaste_> applicative annotated “How to generalize type checkers?” with “How to generalize type checkers? (annotation) (annotation) (annotation)” at http://hpaste.org/56587#a56594
22:03:31 <applicative> dp_wiz: here's the Data.Data Data.Typeable sort of way
22:05:56 <applicative> dp_wiz: should have added the signature typeChequer :: MyVal -> [MyVal] -> ThrowsError MyVal
22:06:00 <The_Journey> how do I convert CInt to Int?
22:07:01 <applicative> fromIntegral?
22:08:12 <The_Journey> applicative: sorry my bad, the other way around
22:08:38 <applicative> fromIntegral again
22:08:59 <The_Journey> applicative: strange, GHC is not letting me do it
22:09:30 <The_Journey> applicative: Couldn't match expected type `CInt' with actual type `Int' when using (fromIntegral $ length ls) where ls is a list
22:10:15 <MostAwesomeDude> :t fromIntegral :: Int -> CInt
22:10:16 <lambdabot> Not in scope: type constructor or class `CInt'
22:10:19 <applicative> have you imported Foreign.C.Types
22:10:23 <MostAwesomeDude> Derp.
22:10:33 <MostAwesomeDude> I think you want toIntegral if you're converting away from Int.
22:10:44 <The_Journey> nvm, I found it, I had another length ls in the call >_<
22:10:50 <shachaf> MostAwesomeDude: No.
22:11:33 <MostAwesomeDude> shachaf: Oh. Okay.
22:12:42 <dp_wiz> applicative: is it possible to match not the rigid type (Bool _), but only it's constructor tag?
22:13:50 * dp_wiz checking out Typeable
22:14:39 <shachaf> dp_wiz: Honestly, you can use Typeable, but at this stage of learning Haskell I wouldn't advise it.
22:18:53 <applicative> dp_wiz: I agree with shachaf of course
22:26:20 <The_Journey> I'm trying to do callbacks in FFI letting the C code to call my Haskell functions, but I'm having problem, I'm getting random outputs, can anyone help me? The code is very short. The Haskell is here: http://hpaste.org/56595, the C is here: http://hpaste.org/56596
22:29:36 <shachaf> That's not very short. :-(
22:29:52 <jkff> Hi guys. What does INHERENT_USE mean in the memory profiling output in ghc 7.4?
22:30:10 <The_Journey> shachaf: I'm sorry, I just can't figure out where I went wrong
22:30:24 <shachaf> The_Journey: Have you tried making a simpler test case?
22:31:59 <The_Journey> shachaf: the C code is calling the Haskell function, the fToFIO converts a [Double] -> [Double] into a callable C function which allocates memory and modifies it in place, the C code then calls that function and then adds its own modifications and that's basically it
22:32:42 <Peaker> Are Conduits like ListT m or like Iteratees   Iteratee i o = (i -> m (Either o (Iteratee i o)))
22:32:42 <The_Journey> shachaf: then I (in Haskell) call the C function, creating a memory space and passing the pointer into the C function for storing the result
22:32:47 <The_Journey> but obviously I went wrong somewhere
22:32:50 <shachaf> Are n2 and p2 even used?
22:33:07 <shachaf> I don't know what's supposed to be happening.
22:33:21 <The_Journey> shachaf: ok, I will try to make a simpler test case
22:34:21 <shachaf> As far as I can tell the Haskell code and the C code are looking at different things. Anyway I don't know. A simpler test case will indeed make this simpler. :-)
22:35:42 <jkff> Oh, I found what is INHERENT_USE: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-June/018906.html
22:37:19 <Enigmagic> The_Journey: you're not copying anything into p2
22:37:27 <The_Journey> shachaf: I'm not sure how to write a simpler one honestly, but the expected output is [4..20]
22:37:42 <The_Journey> Enigmagic: ah, you're right
22:38:28 <shachaf> Right. You have two different arrays.
22:38:31 <The_Journey> didn't know why I was allocating in fToFIO
22:38:34 <The_Journey> thank you
22:39:04 <Enigmagic> blah.hs:16:19: Warning: Defined but not used: `p2'
22:39:13 <Enigmagic> the compiler is magic :-)
22:39:21 <The_Journey> should have heeded the warning >_>
22:39:38 <shachaf> <shachaf> Are n2 and p2 even used?
22:39:44 * shachaf is slightly magic.
22:39:47 <shachaf> Not Enigmagic, though.
22:39:59 <shachaf> That's a whole different level.
22:40:12 <The_Journey> alright, it's working correctly now :) thank you so much
22:40:13 * Enigmagic puts on his wizard cloak and hat
22:41:07 <Enigmagic> alright, back to debugging :(
22:41:36 <shachaf> Enigmagic: What are you debugging?
22:41:57 <Enigmagic> floating points
22:42:03 <Enigmagic> my least favorite kind
22:42:22 <Enigmagic> function is diverging after a couple hundred thousand iterations
22:42:55 <ben_m> Anyone with an idea how to get rid of that ugly repetition (line 15-18 & 27/28)? https://gist.github.com/0500c4b0a0f800f86fd3
22:46:25 <c_wraith> ben_m: at the very least, you could reduce the repetition in 15 and 16 by something like helper f = foldr f 0 (zip poly $ wrap poly) / 6 / signedArea poly
22:48:18 <c_wraith> though cycling a list the way "wrap" does is painful, and I wonder if you could do anything with knot-tying to simplify things.
22:49:12 <c_wraith> regardless of that, you probably want a foldl', rather than a foldr, since you're working with an accumulator
22:51:34 <c_wraith> 27/28 and 17/18 could likewise be made functions that take params to distinguish cases, like the 15/16 split
22:52:01 <hpaste_> dp_wiz annotated “How to generalize type checkers?” with “Attempt at typeChecker w/o Data.Data toConstr” at http://hpaste.org/56587#a56597
22:54:14 <The_Journey> will using newArray cause memory leak if I do not free it?
22:55:46 <The_Journey> yes... no?
22:55:56 <ben_m> c_wraith, why do I want foldl' when working with an accumulator?
22:56:48 <c_wraith> ben_m: because foldr is (usually) for generating incremental results, which isn't possible when you're accumulating a result.
22:57:04 <shachaf> The_Journey: Um, presumably?
22:57:13 <shachaf> The_Journey: Depending on what you're doing, withArray might be what you want.
22:57:14 <c_wraith> ben_m: then it comes down to foldl vs foldl', and the latter forces the accumulator at each step, so it doesn't grow into a huge thunk
22:57:47 <c_wraith> (assuming that whnf for the data type is sufficient to remove the thunks, which it is for the type you're accumulating)
22:57:48 <shachaf> The_Journey: You can just look at the source code of the module to figure it out for yourself, like I'm doing.
22:58:04 <The_Journey> shachaf: how would I free it? I do not see such a function in Foreign.Marshall.Array?
22:58:32 <ben_m> What do you mean by generating incremental results? What'd be a typical use where I'd use foldr over foldl (except infinite lists)
22:59:02 <shachaf> The_Journey: Well, going by the source of Foreign.Marshal.Array, mallocArray just calls mallocBytes.
22:59:50 <shachaf> Which, in turn, just calls malloc.
23:00:11 <shachaf> I mean, stdlib.h malloc().
23:00:32 <The_Journey> shachaf: shouldn't the GC be able to handle it?
23:02:42 <shachaf> Not for mallocArray-style arrays, I don't think.
23:04:38 <The_Journey> shachaf: would free in Foreign.Marshall.Alloc do the trick?
23:06:50 <shachaf> The_Journey: Given that mallocBytes looks like a binding to stdlib.h malloc() and free looks like a binding to stdlib.h free(), presuambly, yes.
23:07:01 <shachaf> See also allocaArray, in case it does what you want.
23:08:15 <The_Journey> shachaf: I think you're right earlier, using withArray is a better way to go
23:08:47 <shachaf> I meant withArray.
23:12:06 <dp_wiz> Error: Couldn't match expected type `a -> LispVal' with actual type `LispVal'. But :t Bool is `a -> LispVal'! What's wrong?
23:12:20 <dp_wiz> in typeChecker (Bool) [Bool _] = return $ Bool True
23:12:45 <Jafet> :t Bool
23:12:46 <lambdabot> Not in scope: data constructor `Bool'
23:13:01 <dp_wiz> (a -> LispVal) was suggested by a compiler looking at isBool = typeChecker Bool
23:13:28 <geekosaur> Bool may be a -> LispVal, but Bool True is not
23:13:50 <dp_wiz> geekosaur: sure it is not, but it is in the return value
23:14:00 <geekosaur> (True has filled in the a)
23:14:08 <dp_wiz> how so?
23:14:13 <dp_wiz> typeChecker :: (a -> LispVal) -> [LispVal] -> ThrowsError LispVal
23:14:43 <geekosaur> oh.  you omitted context...
23:14:50 <dp_wiz> sry..
23:32:27 <Cale> It's everything-on-the-internet-is-annoying-regardless-of-whether-you're-a-US-citizen day
23:33:43 <Cale> a.k.a. use Google's cache day
23:34:21 <osfameron> we get a lot of us laws by proxy (sarbanes oxley, dmca) so protest leaking outside us borders is sensible
23:35:01 <hyper_c^3> a.k.a. disable javascript day
23:35:16 <osfameron> Cale: easier hacks include: use mobile version; disable javascript; disable blackout css
23:35:49 <osfameron> but they've made headlines, which is the point
23:36:06 <osfameron> </offtopic>
23:36:51 <shachaf> If you're talking about Wikipedia, you can also just press Esc before the page is finished loading.
23:37:28 <osfameron> hah!
23:38:25 <c_wraith> or turn off js
23:38:45 <c_wraith> I never had js enabled for wikipedia in the first place
23:38:52 <c_wraith> So I had to work to even see the blackout
23:46:14 <hpaste_> dp_wiz annotated “How to generalize type checkers?” with “How to generalize type checkers? (annotation)” at http://hpaste.org/56587#a56600
23:53:30 <Blkt> good morning everyone
