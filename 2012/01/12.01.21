00:11:48 <solirc> Is there some standard type with one phantom parameter and one constructor in base (something like `data Witness a = Witness`)?
00:31:32 <Lemmih> soiamso: No. But Nothing is close.
00:31:53 <Lemmih> solirc: Oh wait. Maybe Proxy is in base.
00:38:26 <drdo> Hmm, is it possible to tell GHC to statically link everything?
00:40:03 <Lemmih> drdo: Yes, with -optl-static or something.
00:43:31 <drdo> That worked, the only trouble is that it's now warning me that some packages are using dlopen and will require the shared libraries avaliable :S
00:45:19 <BMeph> Are there any projects out there experimenting with using a pre-existing logical language to handle Haskell's type system?
00:50:52 <solirc> Lemmih: Are you refering to Data.Proxy from `tagged`?
01:18:48 <itwenty> I am using LYAH as a beginner's guide. How do I provide a type signature to my function from within GHCi?
01:26:57 <lars9> itwenty: ghci can't do that
01:31:22 <rostayob> Mhm. I'm having trouble defining the ArrowLoop instance for 'data SP a b = Put b (SP a b) | Get (a -> SP a b)'
01:33:59 <itwenty> lars9: ok so where do I define the lucky function as defined here: http://learnyouahaskell.com/syntax-in-functions. Tried creating a .hs file and compiling using ghc, but it says "The type signature for `<functionname>'' lacks an accompanying binding"
01:38:39 <lars9> itwenty: your .hs file? paste it on hpaste
01:41:43 <hpaste_> itwenty pasted “Haskell Newb” at http://hpaste.org/56783
01:43:59 <lars9> itwenty: dub' is not the same as dub
01:44:32 <itwenty> sh!te, realised the typo after positng it..lemme fix it...
01:46:10 <itwenty> yup..working fine now..pays to actually look at what you are typing..:/
01:55:31 <keep_learning> hello all
01:56:15 <keep_learning> I have installed ghc-7.4.0.20111219
01:56:55 <keep_learning> and and this announcement ( http://www.haskell.org/pipermail/glasgow-haskell-users/2011-December/021310.html) says that it contains dph libraries
01:58:25 <keep_learning> Could some one please tell me how to compile  a program using dph ( additional parameters ) with  ghc-7.4
02:00:22 <keep_learning> ghc-7.4.0.20111219  -c -Odph -fdph-par ParallelMat.hs  gives me unrecognised flag.
02:03:16 <keep_learning> Could some one please ?
02:08:29 <mm_freak> isn't DPH a language extension?
02:08:40 <mm_freak> -XDataParallelHaskell or something like that
02:09:14 <Aemdy> Hello everybody, i've just read the article here http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ and decided to give Haskell a try!:)
02:11:36 <luite> Aemdy: great! be sure to join #yesod for Yesod-specific help :)
02:12:10 <keep_learning> mm_freak, it says unrecognised flag
02:13:21 <mm_freak> keep_learning: i was just guessing…  perhaps look into the GHC manual
02:14:26 <ibizaman> hi, imagine I've got a "Tree a b = Leaf b | Branch a [Tree a b]" type
02:14:36 <ibizaman> I want it to be an instance of Functor
02:14:43 <Aemdy> i've been programming in python+django so far, I think i'll have a great bunch of problems to deal with, but i'll keep trying;)
02:15:00 <ibizaman> it will be something like "instance Functor (Tree a) where"
02:15:05 <Veinor> ibizaman: do you want fmap to map over the leaves, or the branches?
02:15:12 <ibizaman> the branches
02:16:02 <ibizaman> (that's exactly the question that makes me feel you understood what I meant ^^)
02:16:03 <Veinor> then i think you need Tree a b = Leaf a | Branch b [Tree a b]
02:16:13 <ibizaman> ok
02:16:41 <ibizaman> thanks!
02:17:04 <Veinor> (there might be a way to do it the other way but this way's nicer unless you have a particular reason to order them that way)
02:17:47 <ibizaman> no reason at all, but I still wonder what are the implications of ordering them in one way or another
02:17:55 <luite> Aemdy: yeah it can be a bit intimidating at first, Yesod in particular uses lots of advanced features that might take some time to fully grasp
02:19:04 <mm_freak> Aemdy: just don't get frustrated with the type system…  every type error you encounter would have been a run-time bug in python ;)
02:19:04 <Veinor> i mean, the type of fmap is going to be fmap :: (m -> n) -> Tree a m -> Tree a n
02:19:23 <mm_freak> Aemdy: and honestly i'd suggest learning the language basics first
02:19:41 <Veinor> so if you want fmap to change the value of the branches, you want the branch value's type to come second in the type constructor
02:20:31 <ibizaman> I see
02:20:33 <mm_freak> ibizaman: see also the bifunctors package
02:21:21 <Aemdy> How to write specifically to the person I want (its the first time ive used irc). / I understand that, now GHCi is being downloaded.
02:21:25 <Veinor> iirc using TypeSynonymInstances and doing like tree SwappedTree a b = Tree b a
02:21:30 <mm_freak> ibizaman: it gives you the Bifunctor class that allows you to map over both leaves and branches
02:21:50 <ibizaman> mm_freak: very interesting, thanks
02:22:14 <Veinor> (you might need another extension or two, I don't know)
02:22:22 <mm_freak> Aemdy: regularly you don't, just say "nick: msg"
02:22:52 <mm_freak> Aemdy: be sure to spell the nick correctly (or just use auto-completion), so the other person gets a highlight
02:22:54 <Aemdy> mm_freak: just testing
02:23:08 <mm_freak> for testing, feel free to type "/query mm_freak" =)
02:23:11 <luite> Aemdy: if you type /msg person hi, the message will go to that person. you can also /query person (this will open a new window/tab)
02:23:11 <Aemdy> Well, i use opera built-in irc client
02:23:38 <Aemdy> oh, okay, got it:)
02:23:51 <luite> but usually the channels are fine for asking help :)
02:24:25 <Veinor> yeah, i don't think i've ever private messaged someone
02:24:27 <Veinor> in here
02:26:43 <itwenty> A newb question: if I match pattern (x:xs) on a list of length 10, then x becomes the head and xs becomes tail of list. What is the pattern to match against init and last of the same list?
02:27:11 <mm_freak> itwenty: there is no pattern for that
02:28:34 <mm_freak> itwenty: note that matching this pattern requires traversing the list, so you would write a function for that and then perhaps use view patterns
02:29:23 <keep_learning> mm_freak, I found one reference for data parallelism ( http://www.haskell.org/ghc/dist/stable/docs/html/users_guide/lang-parallel.html#id723662 ) and it redirects to me  Haskell wiki ( nested data parallelism ). This page only contains information regarding ghc-7.2.1.
02:29:26 <mm_freak> f (splitLast -> Just (xs, x)) = …
02:30:00 <mm_freak> keep_learning: i can't help you there, sorry, but have you had a look into 'repa'?
02:30:17 <mm_freak> it's another implementation of nested data parallelism
02:30:30 <silver> keep_learning, looks like libraries a there, but the rest of the stuff isn't
02:30:31 <mm_freak> but it's only for arrays
02:30:41 <silver> are*
02:30:54 <rostayob> I'm halfway through 'Programming with arrows' and I've got an headache.
02:31:06 <rostayob> this is like the confusion when learning monads, x10
02:31:16 <silver> heh
02:31:38 <itwenty> mm_freak: ok, I will look into view patterns once I make it through initial few chapters of LYAH
02:31:41 <rostayob> also, i find it really suspicious that you have like 17 monad laws
02:31:45 <mm_freak> rostayob: i'm writing an arrow tutorial that builds on the knowledge of monads and is quite approachable…  it's not finished yet, but if you're interested, i can send you a link
02:32:06 <rostayob> mm_freak: Programming with arrows is really good actually
02:32:09 <keep_learning> mm_freak, it will be great
02:32:19 <rostayob> but some concepts are hard to digest
02:32:22 <ibizaman> me again, after inspection, I realise I need my map function to be of type "([Tree a b] -> [Tree a b]) -> Tree a b -> Tree a b", is this defined in a module somewhere ?
02:32:24 <rostayob> e.g. ArrowLoop
02:32:27 <keep_learning> mm_freak, kindly post the link
02:32:53 <mm_freak> rostayob: arrows are simple, once you understood /when/ and /why/ you need them…  most intros into arrows ignore that part entirely
02:32:56 <rostayob> mm_freak: btw, the original reason to read that is AFRP, and your library played a role
02:33:31 <mm_freak> keep_learning: see notice
02:33:42 <rostayob> mm_freak: well, if arrows were simple they'd have simple laws, simpler syntax and a shorter interface, no?
02:33:51 <ibizaman> I'd like to be able to do something like "fmap sort tree" and it sorts all the children and their children
02:34:01 <mm_freak> the laws are simple…  most of them you would have come up with yourself =)
02:34:11 <ClaudiusMaximus> > let f n = maximum [ m | m <- [0 .. 16{-arbitrary-}], n `mod` (2^m) == 0 ] in map f [0..16]  -- is there some magic bit-twiddling way to do this without loops?
02:34:12 <lambdabot>   [16,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4]
02:34:12 <rostayob> mm_freak: so why are there so many of them?
02:34:29 <rostayob> also
02:34:30 <mm_freak> almost all of the laws are about how 'arr' cannot have side effects and how 'first' will not have effects on the other value, etc.
02:34:38 <rostayob> the fact that it took two papers to enumerate them
02:34:39 <mm_freak> there are so many, because you can't compress them nicely
02:34:58 <keep_learning> mm_freak, oh this is you link. I have gone through your monad tutorial :)
02:34:58 <rostayob> makes me doubt that i would have came up myself
02:35:08 <mm_freak> really, the laws are very intuitive…  for programming with arrows it totally suffices to just remember that 'arr' cannot have side effects
02:35:19 <rostayob> mm_freak: mhm
02:35:20 <mm_freak> keep_learning: =)
02:35:26 <rostayob> mm_freak: so for example right now
02:35:38 <ClaudiusMaximus> @oeis 0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4
02:35:39 <Aemdy> http://s3.amazonaws.com/lyah/listmonster.png heh, i liked it :D
02:35:47 <rostayob> I'm kind of stuck in defining the ArrowLoop instance for 'data SP a b = Put b (SP a b) | Get (a -> SP a b)'
02:35:49 <lambdabot>  Exponent of highest power of 2 dividing n, a.k.a. the binary carry sequence,...
02:35:49 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
02:36:21 <mm_freak> ibizaman: Functor is for mapping over the values…  fmap can't be used for structural changes
02:36:44 <mm_freak> ibizaman: you can use list's fmap for mapping a function over the values, but you cannot reorder them using fmap
02:37:22 <mm_freak> rostayob: what exactly is that arrow good for?
02:37:40 <ibizaman> mm_freak: ok, that's what I was supposing, but I was searching for a general structure that enables this to me
02:37:44 <rostayob> mm_freak: it's isomorphic to newtype SF a b = SF ([a] -> [b])
02:37:49 <rostayob> i'm not sure what is good for
02:37:53 <rostayob> but it's an exercise
02:38:25 <mm_freak> rostayob: ah, i see…  if the lists are infinite, you've got yourself a stream processing arrow =)
02:38:45 <mm_freak> rostayob: ArrowLoop is really intuitive for that one…  there is really only one way to write it
02:38:53 <mm_freak> make the types fit and you've won
02:39:29 <mm_freak> and for now don't try to understand what it does…  you can review the code later, when you've actually used 'loop' =)
02:39:52 <hpaste_> ibizaman pasted “fmap changes structure” at http://hpaste.org/56784
02:39:57 <rostayob> mm_freak: the problem is that with recursion i can make the type fit in many different ways
02:40:23 <mm_freak> rostayob: but only one way doesn't lead to bottom across the board =)
02:40:44 <rostayob> mm_freak: yeah, so "make the types fit" doesn't help :)
02:41:34 <mm_freak> well, then think about what 'loop' is good for…  imagine a stream processor that is a composition like "a . b . c"
02:41:59 <mm_freak> and in streams you have instants…  an instant is just the time at which a single value is produced
02:42:21 <mm_freak> now imagine this instant of 'c' wants to access the value of the last instant of 'a'
02:42:39 <mm_freak> that's what ArrowLoop is for
02:45:18 <mm_freak> it gives you feedback…  it feeds a's value back into c…  and that works as long as the first instant of 'a' doesn't depend on anything else, particularly not on the output of 'c'…  that's why you have this weird fully polymorphic type variable in there that you feed back into the same function =)
02:45:37 <mm_freak> and this of course can only work in the presence of laziness
02:45:46 <rostayob> mm_freak: what fully polymorphic type variable?
02:46:38 <mm_freak> loop :: ArrowLoop (>~) => ((a, r) >~ (b, r)) -> (a >~ b)
02:46:53 <mm_freak> see the fully polymorphic variable 'r' that isn't involved in the result
02:47:01 <rostayob> ah, in that sense
02:47:18 <mm_freak> do you understand mfix?
02:47:48 <rostayob> yes, i also get what the point of loop is (in the paper he defines a flip-flop with it)
02:48:13 <mm_freak> well, loop is equivalent to mfix in the arrow context =)
02:48:55 <mm_freak> same purpose and in fact almost same implementation, just that you have a separate feedback argument with loop =)
02:50:10 <rostayob> yeah but I'm used to defining fix and company with recursive lets, and I really can't see the opportunity here
02:50:43 <mm_freak> it's there, it's just less obvious…  and i think the main confusion here is that you have two constructors
02:50:55 <mm_freak> try to write an ArrowLoop instance for the automaton arrow…  that's easier
02:51:48 <rostayob> i mean i can write - for the get case 'loop (Get f) = Get $ \x -> loop (f x)'
02:51:55 <rostayob> but it doesn't make much sense to me right now
02:52:14 <rostayob> no wait, that doesn't work :P
02:52:22 <mm_freak> ;)
02:52:22 <rostayob> ahhhh
02:52:25 <rostayob> ok
02:52:56 <mm_freak> as an interesting exercise write the automaton arrow, write an ArrowLoop instance for it and then write a function that turns any SP computation into an automaton computation =)
02:53:31 <rostayob> there's probably something like 'let (z, y) = loop (f (x, y))' involved
02:54:05 <mm_freak> without the recursive call to 'loop', yes
02:54:19 <mm_freak> that's the feedback pattern
02:54:46 <rostayob> yeah but 'f :: (a, c) -> SP (a, c) (b, c)'
02:54:50 <rostayob> so i can't pattern match the tuple
02:54:59 <rostayob> i can pattern match a 'Put'
02:55:35 <mm_freak> problem is:  if the current instant depends on the recursive call to 'loop', it will diverge
02:55:49 <rostayob> mm_freak: i'm not sure what you mean by "instant"
02:56:24 <mm_freak> the stream [x, y, z, …] produces 'x' in the first instant, 'y' in the second, 'z' in the third, etc.
02:56:37 <rostayob> mm_freak: no, my problem here in writing the recursive let is that I never have a function '(a, c) -> (b, c)', or similar
02:57:03 <mm_freak> yeah, that's not the point anyway
02:57:12 <mm_freak> you really have to think about individual instants
02:57:19 <mm_freak> "this" instant is the first value in the stream
02:57:45 <mm_freak> don't think of the stream as a whole
02:58:17 <mm_freak> you have a stream processor of type SP (a, d) (b, d)
02:58:19 <mm_freak> what is that?
02:58:40 <rostayob> what do you mean?
02:59:03 <mm_freak> well, it represents some sort of function…  what exactly?
02:59:10 <mm_freak> (disregarding loop!)
02:59:46 <rostayob> [(a, d)] -> [(b, d)]?
03:01:23 <rostayob> mm_freak: also, I don't see how you can define the 'delay' function with SP, if you want to mantain the number of elements in the list
03:01:31 <rostayob> maybe I'm just missing the point of SP
03:01:46 <mm_freak> well, SP is a complicated example to start with
03:02:08 <mm_freak> i really suggest starting with a single-constructor type
03:02:52 <rostayob> well huges in the paper starts out with newtype SF a b = SF ([a] -> [b])
03:03:04 <rostayob> but the ArrowLoop instance is already fairly complex imho
03:03:31 <mm_freak> yeah, that's because you don't have direct access to the instants…  you need to destruct the list to do so
03:03:46 <rostayob> I mean I don't think i would have come up with the 'stream ~(x:xs) = x : stream xs' trick
03:04:26 <rostayob> mm_freak: anyway, what is it? i'm too curious now
03:04:39 <mm_freak> what is what?
03:04:46 <rostayob> the ArrowLoop instance for SP
03:05:23 <mm_freak> i'd have to write it first, but no, this is your homework =)
03:05:51 <rostayob> yeah but i've been trying to write for half an hour and i'm starting to feel stupid
03:06:49 <mm_freak> no worries…  i needed longer for my first ArrowLoop instance =)
03:10:30 <rostayob> mm_freak: well, then arrows are not that simple
03:14:50 <mm_freak> rostayob: ArrowLoop is a bit mind-twisting
03:15:05 <mm_freak> there rest is fairly straightforward, once you understood what arrows are good for
03:25:12 <rostayob> mm_freak: we'll see. my ultimate goal is to write an AFRP game engine
03:25:33 <nicoo> rostayob: AFRP ?
03:25:42 <rostayob> with "game engine" I mean "really simple game engine"
03:26:01 <rostayob> nicoo: arrowized functional reactive programming
03:26:07 <nicoo> Ah, ok
03:27:18 <mm_freak> rostayob: then you should really study the automaton arrow
03:27:27 <mm_freak> it's one of the simplest non-monadic arrows
03:27:36 <mm_freak> and the one you'll need for AFRP
03:27:42 <rostayob> i will
03:27:48 <rostayob> but i'm stubborn, i want to solve this first
03:27:54 <rostayob> but after lunch, i'm hungry now
03:28:14 <byorgey> not THAT stubborn
03:28:14 <rostayob> mm_freak: is netwire general enough to use it for a project like my little engine?
03:29:04 <rostayob> byorgey: i can't think if i'm hungry :P
03:29:14 <mm_freak> rostayob: netwire is about as general as an FRP library can get =)
03:29:35 <byorgey> =)
03:29:37 <ion> mm_freak: Is your article about arrows is still unpublished, btw? I *still* haven’t managed to get around to reading the alpha version, but it’s in the queue. :-)
03:30:43 <mm_freak> ion: i keep extending it, but i haven't really got time to finish it yet
03:31:18 <ion> alright
03:34:50 <rostayob> mm_freak: all in all, to you think AFRP would be nice for what I want to do? I have a feeling it would be based on my readings
03:34:55 <rostayob> but I'm not sure really
03:36:18 <mm_freak> well, FRP is a bit tricky with dynamic systems…  i've tried many approaches…  there is no general answer to that
03:38:10 <rostayob> mm_freak: is it? wasn't it also conceived to model user interaction declaratively?
03:38:48 <rostayob> or are youreferring to physics
03:40:21 <mm_freak> i'm referring to systems, where there are not only distinct, named entities, but also dynamic subsystems like spawned objects, particle systems, etc.
03:42:25 <rostayob> mm_freak: mhm, ok
03:43:16 <rostayob> the thing is that I'd really like a functional 2D game engine
03:43:37 <rostayob> which is a field that seems to be dominated by big and ugly C++ software
03:44:03 <mm_freak> i'm not saying that they are difficult to implement (assuming you know your FRP), but there are lots of different ways to do it
03:44:14 <mm_freak> yeah, i understand
03:50:23 <gregATio> i love emacs
03:53:13 <nicoo> gregATio: I like it too, but I don't believe #haskell is the best place to start a troll about text editors.
03:54:07 <Blkt> good afternoon everyone
03:54:24 <Chaze> :t (->)
03:54:25 <lambdabot> parse error on input `->'
03:54:34 <Philippa> -> isn't an operator
03:54:35 <Chaze> what is -> semantically ?
03:54:41 <Philippa> in what position?
03:54:52 <Philippa> in a case statement it's just a separator. In a type, it's a type constructor
03:54:56 <Philippa> :k (->)
03:54:57 <lambdabot> ?? -> ? -> *
03:55:07 <Chaze> ah, a constructor
03:55:25 <Chaze> i recalled that there is such a thing as the "function application monad"
03:55:39 <Chaze> correct?
03:55:41 <Veinor> yeah
03:55:49 <Veinor> ((->) e) is a monad
03:56:00 <Veinor> where return is const and bind is... i forget what
03:56:13 <Veinor> @djinn (a -> e) -> (a -> b -> e) -> (b -> e)
03:56:13 <lambdabot> -- f cannot be realized.
03:56:21 <Veinor> oh, wrong way
03:56:35 <Veinor> @djinn (e -> a) -> (a -> e -> b) -> (e -> b)
03:56:35 <lambdabot> f a b c = b (a c) c
03:56:49 <byorgey> it's the S combinator
03:57:06 <byorgey> wait, no, that's ap
03:57:21 <Chaze> :t ap
03:57:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:57:56 <byorgey> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
03:57:56 <lambdabot> f a b c = a c (b c)
03:58:15 <byorgey> Well, I guess they are isomorphic in the particular case of ((->) e)
03:58:24 <Chaze> what does @djinn do?
03:58:38 <byorgey> Chaze: it tries to produce a function with the given type
03:58:39 <Veinor> djinn, given a type, tries to construct a function with that type
03:59:05 <Chaze> @djinn a -> a -> a
03:59:05 <lambdabot> f _ a = a
03:59:06 <Veinor> @djinn Either a b -> (a -> e) -> (b -> e) -> e
03:59:07 <lambdabot> f a b c =
03:59:07 <lambdabot>     case a of
03:59:07 <lambdabot>     Left d -> b d
03:59:07 <lambdabot>     Right e -> c e
03:59:37 <Veinor> @djinn (a -> a) -> a
03:59:38 <lambdabot> -- f cannot be realized.
03:59:42 <Veinor> it's not perfect :)
04:00:58 <mreh> I'm trying to install cabal-dev-0.9, i have cabal-1.8.0.2, hackage says cabal >= 1.2 is needed, but cabal-install picks cabal 1.10
04:02:20 <donri> cabal 1.10 is >= 1.2
04:02:40 <donri> versions are not decimal
04:02:42 <mreh> i'm talking about cabal the library
04:02:54 <mreh> i know
04:03:14 <donri> oh ok, sorry
04:03:15 <mreh> anyway, hackage is wrong
04:05:03 <mreh> does hackage not create the dependency lits from the .cabal file?
04:06:12 <Veinor> it does
04:06:26 <Veinor> have you done cabal update recently?
04:06:36 <mreh> yes
04:06:42 <mreh> just now
04:07:49 <Chaze> for my understanding: can someone define ap with >>= please?
04:08:01 <koeien> @src ap
04:08:01 <lambdabot> ap = liftM2 id
04:08:23 <Chaze> @src liftM2
04:08:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:08:34 <Veinor> mreh: ah
04:08:36 <kosmikus> mreh: the dependency list is generated by Hackage from the Cabal file, but not correctly.
04:08:46 <Veinor> yeah
04:08:48 <koeien> liftM2 m m' is m >>= (\x -> m' >>= (\x' -> return (id x x')))
04:08:56 <kosmikus> cabal-dev actually depends on Cabal >= 1.10
04:09:05 <koeien> so  s m >>= (\x -> m' >>= (\x' -> return (x x')))
04:09:47 <ion> mf <*> mx = do f <- mf; x <- mx; return (f x)
04:09:47 <koeien> :t ap
04:09:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:09:51 <koeien> :t (<*>)
04:09:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:10:01 <drdo> monochrom: Using gold solved my problem!
04:10:01 <Chaze> koeien: thanks
04:10:15 <byorgey> mreh: I don't know why it would do that, but you can try doing  cabal install cabal-dev --constraint='Cabal ==1.8.0.2'
04:10:34 <koeien> the type signature says, given two actions, one containing a function and the second containing an argument, the result is the action that applies the function on its argument
04:10:43 <koeien> so there is basically one thing that it can do
04:10:53 <mreh> byorgey: i did :(
04:10:56 <byorgey> koeien: two
04:11:01 <byorgey> it can run the actions in either order
04:11:08 <koeien> very good point! thanks
04:11:18 <byorgey> but one of them is more sensible than the other
04:11:19 <Chaze> koeien: i'm confused by (id x x')
04:11:26 <nand`> Chaze: realising how ap can be define in terms of >>= makes you realize that all monads are be necessity also applicatives, assuming they follow the monad laws (note that exceptions exist in haskell since applicatives were introduced after monads)
04:11:34 <koeien> oh don't be. id x x' means ((id x) x') which is just  x x'
04:11:35 <nand`> Chaze: id x is x
04:11:35 <ion> (id x) = x
04:11:38 <nand`> so that's the same as x x'
04:11:40 <ion> (id x) x' = x x'
04:12:00 <mreh> rats, no version of cabal-dev will build with Cabal ==1.8.0.2
04:12:05 <Chaze> yeah, so id could be omitted?
04:12:05 <nand`> Chaze: if you apply more parameters to a function than it accepts, the rest of the parameters are applied to the result of that
04:12:09 <byorgey> Chaze: koeien was just translating the definition  liftM2 id  which is where the id came from
04:12:14 <nand`> Chaze: exactly
04:12:14 <Chaze> aah
04:12:16 <byorgey> Chaze: yes
04:12:17 <koeien> Chaze: in my expression, yes
04:12:35 <koeien> id is mostly useful when you pass it to other functions, by itself it doesn't add much value :)
04:12:45 <nand`> this is also why you can reduce something like (\x y z -> x y z) to (id)
04:13:46 <Ptival> the point of id is to be passed to an existing function indeed
04:13:47 <koeien> ah now i see that i omitted the id from the left hand side
04:14:02 <koeien> liftM2 id m m' = ... -- should be this
04:16:02 <Chaze> :t <*>
04:16:03 <lambdabot> parse error on input `<*>'
04:16:07 <Chaze> :t (<*>)
04:16:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:16:18 <Chaze> @src (<*>)
04:16:18 <lambdabot> Source not found. :(
04:16:26 <koeien> it's a class method
04:16:32 <Chaze> right
04:16:35 <koeien> so (<*>) for lists has its own implementation
04:16:39 <koeien> @src (<*>) []
04:16:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:16:43 <koeien> @src [] (<*>)
04:16:43 <lambdabot> (<*>) = ap
04:16:48 <koeien> right :(
04:17:32 <koeien> > [(+1), (*2)] <*> [1,2,3,4]
04:17:33 <lambdabot>   [2,3,4,5,2,4,6,8]
04:18:31 <koeien> "class function" is probably a better term
04:18:35 <Chaze> uh, that operator is actually useful!
04:18:43 <koeien> <*> is very useful
04:18:51 <koeien> i use it all the time
04:18:56 <Chaze> i'm just trying to understand a paper actually, but i'm all getting hyped up about haskell again
04:19:13 <ion> > ((==) <*> reverse) "saippuakauppias"
04:19:14 <lambdabot>   True
04:19:34 <Chaze> ion: nice
04:19:41 <koeien> the (e ->) monad again
04:19:55 <ion> Not monad, actually.
04:20:12 <ion> Although…
04:20:15 <koeien> well, i just assumed that <*> = ap also for (e ->)
04:20:19 <ion> > ((==) =<< reverse) "saippuakauppias"  -- :-P
04:20:20 <lambdabot>   True
04:20:35 <Chaze>  ((==) `ap` reverse) "saippuakauppias"
04:20:43 <Chaze> >  ((==) `ap` reverse) "saippuakauppias"
04:20:43 <lambdabot>   True
04:20:48 <Chaze> now its a monad, eh?
04:20:53 <koeien> yes, ap is for monads
04:21:05 <koeien> monads were introduced before applicatives in haskell
04:21:07 <ion> Yeah, but only because of the historical accident of Monad not depending on Applicative.
04:21:18 <koeien> ap == <*> if your data structure is also a monad, but <*> is more general
04:21:35 <Chaze> So they build a hierarchy of Functor => Applicative => Monad
04:21:42 <ion> yeah
04:21:52 <Chaze> and in a proper implementation we'd drop ap
04:21:56 <koeien> yes
04:22:21 <koeien> haskell should've avoided success more
04:22:24 <ion> I wouldn’t mind having ap as an non-infix alias to (<*>) or the other way around. But yeah, they shouldn’t be different.
04:23:10 <Philippa> eh, it's nice having a name for what might otherwise be the default implementation for monads
04:23:13 <Chaze> still trying to wrap my head around that reverse-test example
04:23:37 <Philippa> makes it easier to factor some laws, for example. And gives a name to it so it's easier to write a test
04:23:44 <Chaze> :t (==) `ap`
04:23:44 <ion> chaze: http://heh.fi/haskell/functors/#function-instance
04:23:44 <lambdabot> parse error (possibly incorrect indentation)
04:23:45 <nand`> ion: (r ->) is a monad
04:23:55 <nand`> it's the reader monad, even
04:24:03 <koeien> <*> :: (e -> a -> b) -> (e -> a) -> (e -> b)
04:24:11 <ion> nand: But in the example only the applicative instance was used. The code would have worked just fine without the monad instance.
04:24:16 <Chaze> ion: Awesome! Thats so what i needed
04:24:16 <koeien> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
04:24:17 <lambdabot> f a b c = a c (b c)
04:24:19 <nand`> indeed
04:24:22 <Chaze> i remember drawing these myself last year
04:25:01 <ion> @@ @djinn @type (<*>) `asTypeIn` \ (<*>) -> undefined <*> (undefined :: a -> b)
04:25:02 <lambdabot>  f a b c = a c (b c)
04:25:04 <koeien> so this is (==) xs (reverse xs) where xs = "koeienneieok"
04:25:05 <ion> @type (<*>) `asTypeIn` \ (<*>) -> undefined <*> (undefined :: a -> b)
04:25:06 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
04:26:17 <Chaze> how can I tell lambdabot to give me the definition of, say, <$> in the ((->) e) instance?
04:26:35 <nand`> note: <$> = fmap
04:26:37 <koeien> @type ((->) e) fmap
04:26:37 <lambdabot> parse error on input `->'
04:26:42 <koeien> @type (e ->) fmap
04:26:43 <lambdabot> parse error on input `)'
04:26:46 <byorgey> @src ((->) e) fmap
04:26:46 <lambdabot> Source not found. I am sorry.
04:26:48 <koeien> @src (e ->) fmap
04:26:49 <lambdabot> Source not found. That's something I cannot allow to happen.
04:26:51 <ion> @@ @djinn @type (<$>) `asTypeIn` \ (<$>) -> undefined <$> (undefined :: a -> b)
04:26:51 <koeien> grmbl
04:26:51 <lambdabot>  f a b c = a (b c)
04:26:53 <byorgey> @src (->) fmap
04:26:54 <lambdabot> fmap = (.)
04:27:01 <byorgey> there we go
04:27:14 <Chaze> @src (->) <$>
04:27:14 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:27:18 <Chaze> @src (->) (<$>)
04:27:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:27:23 <koeien> @src (<$>) -- note
04:27:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:27:30 * koeien gives up
04:27:54 <Chaze> <$> = (.)  -- right?
04:27:54 <byorgey> @src is not very intelligent, it just textually matches what you write against a large file of source entries
04:27:54 <lambdabot> Source not found. Wrong!  You cheating scum!
04:28:02 <nand`> Chaze: for functions, yes
04:28:34 <byorgey> although apparently @src begs to differ
04:29:23 <nand`> (<$>) :: (Functor f) => (a -> b) -> f a -> f b, and since we know that f is in this case (r ->), that's the same as (<$>) :: (a -> b) -> (r -> a) -> (r -> b)
04:29:25 <nand`> @type (.)
04:29:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:29:35 <nand`> oh wow
04:29:40 <nand`> I didn't except that
04:29:43 <nand`> expect*
04:29:48 <ion> Caleskell strikes again. You’re going to love this:
04:29:50 <ion> @type flip
04:29:51 <koeien> that's Cale's haskell
04:29:51 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:30:40 <mike-burns> It'd be nice to get a bot in here that runs actual Haskell.
04:30:42 <byorgey> @type (Prelude..)
04:30:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:30:54 <ion> > [1,2,3] >>= flip (pure (+10))
04:30:56 <lambdabot>   [11,12,13]
04:31:16 <Chaze> why pure? why not return?
04:31:26 <Chaze> > [1,2,3] >>= flip (return (+10))
04:31:27 <lambdabot>   [11,12,13]
04:31:31 <koeien> pure is applicative
04:31:40 <koeien> pure = return for monads
04:31:41 <ion> Yet another symptom of Monad not depending on Applicative.
04:31:42 <byorgey> pure and return should be the same
04:31:46 <Chaze> but >>= isn't defined on applicatives
04:31:53 <Chaze> in my head that creates a type error
04:31:59 <Chaze> but maybe i'm too naive
04:32:00 <mike-burns> :t pure
04:32:01 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:32:02 <mike-burns> :t (>>=)
04:32:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:32:24 <koeien> Chaze: [] is an instance of both Applicative and Monad
04:32:32 <olsner> Chaze: if a type has instances for both, it doesn't matter that you used pure in one place and >>= in another
04:32:35 <mgsloan> imho pure is a better name for return in the first place
04:32:36 <ion> Both the “f” and the “m” become [] in that piece of code.
04:32:46 <mgsloan> avoids the confusion with imperative return
04:33:00 <olsner> pure is also two characters shorter
04:33:16 <Chaze> I just read "return" as "wrap in monad"
04:33:21 <mike-burns> > [1,2,3] >>= flip [+10]
04:33:21 <Chaze> is that not so accurate?
04:33:21 <lambdabot>   A section must be enclosed in parentheses thus: (+ 10)
04:33:37 <koeien> why not use eta?
04:33:49 <byorgey> Chaze: return means map an 'a' to an 'm a' for some type 'm'
04:34:13 <koeien> η is even shorter than pure
04:34:25 <byorgey> Chaze: the type 'm' must be an instance of Monad, but any particular 'm' may also be an instance of Applicative or whatever
04:34:41 <koeien> (in fact, m should)
04:35:08 <byorgey> Chaze: You said "(>>=) isn't defined on applicatives", but that's not true.  It's defined on any applicatives which also happen to be instances of Monad.
04:35:28 <Chaze> byorgey: oh, i see
04:35:58 <nand`> return is a natural transformation from the Identity functor to the monad's functor that abides to the monad laws; for any type x in the functor's domain, in this case Hask (the category of all haskell types) -- so it's a function that can take any type and wrap it inside a monad, yes
04:36:24 * mgsloan always finds himself wanting "(<.>) f g x = f <$> g x"
04:51:02 <prof7bit> I need someone experienced with happstack: consider this minimal hello world server: http://pastebin.com/ZENZhVVL when I load it in ghci and call main then it will run. when I press Ctrl-C then ghci will print "interrupted." and come back with the prompt. but the server is still running. I can reload the source, run main again without errors but it will still continue running the old version and still serve the old page. Is this
04:51:03 <prof7bit> behavior "by design"? Is there a way around it?
04:51:05 <mauke> The paste ZENZhVVL has been copied to http://hpaste.org/56786
04:53:03 <donri> prof7bit: probably because it's threaded
04:54:42 <prof7bit> shouldn't happstck kill all threads when its main entry function is interrupted?
04:55:22 <donri> could be a ghci issue? http://hackage.haskell.org/packages/archive/happstack-server/6.4.6/doc/html/Happstack-Server-SimpleHTTP.html#v:waitForTermination
04:59:06 <prof7bit> how do i know how (or if) this function is used somewhere deep inside happstack? ghci itself doesn't seem to have a problem catching the signal
04:59:27 <donri> looking at the source i'm not sure it uses it itself, hm
05:00:00 <donri> btw #happs might be more helpful
05:00:29 <siracusa> prof7bit: Though this function is supposed to kill all threads, I still had issues with developing Happstack apps from GHCi on Windows
05:00:35 <siracusa> #happstack even
05:00:51 <siracusa> erm no, gnore tha last
05:00:55 <siracusa> *ignore
05:01:08 <prof7bit> i'm on linux btw
05:01:42 <donri> maybe try using :main instead of main directly
05:01:50 <prof7bit> but I have only ghc 6.12.3, this is the latest version I can run on this ancient ubuntu from 2008
05:01:51 <donri> no idea if it helps but worth trying
05:03:04 <donri> @hackage virthualenv
05:03:04 <lambdabot> http://hackage.haskell.org/package/virthualenv
05:03:15 <donri> makes it easy to use other ghc versions
05:04:52 <Lemmih> prof7bit: I think it's a bug.
05:06:58 <prof7bit> the problem with my old ghci is something with an old glib version, i don't want to mess up my system by replacing such core libraries with newer versions. I have tried a few of the vanilla binary ghc packages and 6.12 is the latest version that does not complain
05:10:16 <prof7bit> the happstack problem is not really super important, I was ust wondering if it was me doing something wrong or whether it might be a bug. It just would have been convenient being able to experiment with it from the prompt in chci. (I'm still a total haskell noob, I'm still trying to find answers to 1000s of questions)
05:11:34 <donri> prof7bit: you might find runhaskell similarly convenient
05:12:56 <prof7bit> donri: yes, that essentially what I'm doing now. and a second terminal window with ghci for exploring the types of functions etc.
05:15:35 <hpaste_> nand annotated “Unbase64 and save” with “Unbase64 and save (cosmetic fix)” at http://hpaste.org/56788#a56789
05:19:14 <kuznero> Hi All!
05:19:36 <koeien> hi
05:23:11 <kejoki> eureka!  I finally got my "simple" program working!  Boy did I learn a lot...
05:23:38 <nand`> kejoki: grats, what does it do?
05:26:26 <kejoki> it's a cli that takes a key for picking a function, then one or two filepaths, and changes the line endings to \n, \r, \r\n (or doesn't: there's and option to turn it into an expensive cp)
05:26:32 <mindbender> please what is the best way of editing haskell in emacs?
05:26:46 <shergill> haskell-mode
05:26:48 <rostayob> mindbender: haskell-mode
05:27:18 <mindbender> rostayob: I was only surprised that haskell-mode doesn't get indentation right
05:27:24 <rostayob> mindbender: it does
05:27:27 <rostayob> most of the times
05:27:29 <kejoki> mind-bender -- you have to go get it from the emacs wiki, and then install it more or less "by hand"
05:27:34 <rostayob> also, there is no "right" indentation
05:27:41 <rostayob> (in haskell)
05:27:53 <kuznero> :)
05:28:05 <mindbender> so I have to use varying indentation modes?
05:28:32 <rostayob> haskell-mode has various indentation modes
05:28:44 <mindbender> rostayob: I noticed that
05:29:07 <rostayob> I don't remember the details, but one of them does what you'd expect from emacs (TAB cycles through indentations)
05:29:09 <shergill> mindbender: haskell-mode is available in debian/ubuntu repositories as well, fyi
05:29:20 <rostayob> and marmalade
05:29:22 <mindbender> I think I just have to learn how to use.. I'm very new to haskell I hope it will be an interesting ride
05:29:35 <rostayob> oh yes, it will
05:29:49 <kuznero> mindbender: haven't you considered using Leksah?
05:29:53 <hpaste_> kejoki pasted “It Works!” at http://hpaste.org/56790
05:29:59 <rostayob> I'd suggest emacs over leksah
05:30:05 <rostayob> expecially if he already knows emacs
05:30:05 <kuznero> why?
05:30:14 <koeien> use the editor you know.
05:30:17 <rostayob> because Leksah has pretty rough edges afaik
05:30:24 <rostayob> and emacs works as you'd expect
05:30:27 <koeien> if you know vim, use vim, if you know emacs, use emacs
05:30:34 <kuznero> It becomes better... :)
05:30:34 <koeien> at least initially
05:30:34 <shergill> agree with koeien
05:30:40 <mindbender> I prefer emacs
05:30:45 <kuznero> I know vim... but stick with Leksah :)
05:31:00 <shergill> kuznero: perhaps time to move on to emacs? :P
05:31:02 <kuznero> Who's here using Leksah at all?
05:31:06 <kuznero> :))))
05:31:42 <kuznero> shergill: if it's better then vim-mode than I will need to consider that... but is it?
05:32:01 <koeien> kuznero: you can use evil
05:32:03 <koeien> this is what i do
05:32:54 <kuznero> koeien: is it just a text editor? can you share a link to that?
05:33:09 <koeien> kuznero: no, it's magic for emacs to enable vim keybindings
05:33:18 <kuznero> Ah... :)
05:33:23 <koeien> http://emacswiki.org/emacs/Evil
05:33:29 <koeien> otherwise i'd be dead in the water
05:33:32 <mindbender> In addition to materials I already have... any suggestions for high community rated exposure material
05:33:40 <donri> I use vim with emacs-like bindings ;)
05:33:49 <donri> (...in insert/command mode)
05:34:14 <rostayob> mindbender: I guess you already know LYAH? the other good beginners book is "Programming in Haskell"
05:34:23 <kuznero> What about suggestions while coding - what I saw in vim was kinda wrong...
05:34:56 <koeien> depends on your level, there is LYAH, Real World Haskell, typeclassopedia
05:35:11 <shergill> kuznero: i'm probably biased, this is probably a biased opinion. but having used both vim and emacs interchangeably for a while i finally shifted to emacs permanently. my main reason for switching was preference of elisp over vim. emacs is *very* hackable and found it a lot easy to hack on than vim. as donri and koeien suggested if you prefer vim bindings there are easy ways to accomplish that
05:35:28 <koeien> shergill: yeah vimscript is awful
05:35:43 <shergill> but emacs seems to have better language support in general
05:35:52 <shergill> vim gets syntax highlighting right, but little else
05:35:59 <mindbender> rostayob: thanks for the directions.. another quick question is how is interactive dev done in emcas
05:36:07 <donri> FWIW http://learnvimscriptthehardway.stevelosh.com/ is nice if you need to write vimscript / just to edit your vimrc better
05:36:22 <kejoki> (Anyone who can suggest a way to get rid of the three different functions for doing essentially the same thing would have an interested audience.)
05:36:23 <rostayob> mindbender: you can fire up the interpreter with with the current file with C-c C-l
05:36:24 <XexonixXexillion> I use leksah to generate cabal stuff for me, but write code in vim
05:36:32 <kuznero> shergill: thanks, will try to dig more into emacs and haskell...
05:37:05 <koeien> kejoki: take a handle instead of a String
05:37:22 <kejoki> oh, I tried.  I tried and tried.
05:37:22 <koeien> Handle*
05:37:24 <shergill> kuznero: np
05:37:52 <koeien> replace args !! 0 by head args
05:38:47 <koeien> you can leave out the "do" in line 24 and pattern match directly on cliargs
05:38:49 <kejoki> koeien: openFile gives you an IO Handle, you can't pass it as a Handle
05:39:01 <koeien> kejoki: that's right, but you can write
05:39:09 <koeien> do { h <- openFile; ... h ... }
05:39:13 <koeien> here h is of type Handle
05:39:37 <kejoki> koeien: yeah, hpaste is giving me a lot of lint advice.
05:39:48 <srhb> I am trying to build an infinite list IO [String] but having troubles getting the types to align. I have a start value, and every subsequent value IO String can be made by using a function on the preceding element. I think I should have something that looks like.. list = return $ "start" : map f list, but I can't quite get there. Can anyone give me a hint?
05:40:12 <srhb> f has type [Char] -> IO String
05:40:17 <kejoki> koeien: I thought I'd tried that.
05:40:27 <koeien> :t unfoldM
05:40:28 <lambdabot> Not in scope: `unfoldM'
05:40:33 <srhb> But I need something like f that is IO String -> IO String
05:41:00 <koeien> kejoki: that's possible, but then the error is somewhere else :)
05:41:19 <koeien> kejoki: you use input <- getContents, getContents is of type IO String, but input of type String
05:41:31 <koeien> the situation with openFile "/tmp/bla" is completely analogous
05:41:41 <kejoki> k
05:42:09 <koeien> kejoki: also, your argument handling could be better; write
05:42:20 <koeien> (firstArg:restArgs) <- getArgs
05:42:28 <kejoki> I certainly did have enough trouble with parse errors to make finding logic and syntax errors a frustrating enterprise.
05:42:53 <koeien> then use firstArg instead of head args, and you can pass restArgs (since you don't use the first argument in fixlines)
05:43:00 <kejoki> koeien: yep.  did that at first, but ...
05:43:11 <koeien> parse errors are generally caused by mismatched parens, brackets, and so on, or the layout rule
05:43:29 <kejoki> the layout rule is my bugaboo.
05:43:50 <koeien> if you are stuck somewhere with a type error you can always paste it, we're generally happy to help
05:44:06 * kejoki hasn't used a language that cared about indentation since ... FORTRAN?
05:44:12 <XexonixXexillion> srhb: try using (>>=)
05:44:12 <koeien> python does
05:44:20 <srhb> XexonixXexillion: In the map? Hmm
05:44:31 <koeien> COBOL cares about the columns that your code is in
05:45:07 <koeien> kejoki: that said, you can use {'s and ;'s
05:45:17 <koeien> kejoki: but most people think this is uglier
05:45:24 * kejoki <- is not a python coder
05:45:25 <XexonixXexillion> srhb: something like map (>>= f) list
05:45:28 <srhb> XexonixXexillion: I get it! Thanks
05:46:04 <srhb> list = return start : map (>>= f) list
05:46:09 <srhb> And it even makes sense. :-)
05:46:14 <shergill> curious, but which chat client do people here use?
05:46:20 <kejoki> koeien: it probably is.  and more typing.
05:46:28 <XexonixXexillion> shergill: irssi
05:46:33 <kejoki> shergill: erc
05:47:17 <mr_sleepy> somebody should make an irc client in haskell :)
05:47:36 <shergill> mr_sleepy: i was wondering the same
05:48:16 <mr_sleepy> while irssi is really nice, it could actually be nice to have an irc client where you can write triggers in haskell
05:48:21 <mr_sleepy> and extend it in haskel
05:48:49 <kejoki> mr_sleepy: that way lies madness.   Pick a channel for any language, and go through the logs, and you'll find the same "someone should" for that language, somewhere.
05:49:10 <nicoo> mr_sleepy: An irssi with s/perl/haskell/ ?
05:49:20 <mr_sleepy> :)
05:49:29 <mr_sleepy> that would be nice...
05:49:55 <XexonixXexillion> Now I feel I should write an irc client in agda...
05:49:56 <mr_sleepy> but i am not the one that would do it... i just slipped into this topic becaise of shergill
05:50:48 <mr_sleepy> because*
05:50:59 <kejoki> oh sure.  get some larval all excited and let *it* do all the work, and end up in a rest home...
05:51:12 <shergill> heh
05:52:04 <shergill> i'm being less ambitious and musing about writing an extension for pidgin. i like libpurple's multi-protocol support and like the ability to have encrypted chats
05:53:17 <mr_sleepy> kejoki: i have actually been tempted several times to creat an irc client. but with children, stable work, a house building project and soon maybe some dogs there is simply not any time. not even my health allows it regardless of how much i want
05:53:29 <kejoki> haskell plugins for pidgin/finch would be very cool.
05:53:32 <mr_sleepy> one day i might actually do it
05:53:32 <mm_freak> XexonixXexillion: you may want to take inspiration from the lemmachine project, an HTTP framework in agda =)
05:55:20 * kejoki is trying to find the link to the "IRC client in Prolog" project...
05:55:25 <Ptival> irssi too
05:56:49 <mr_sleepy> once i made an irc bot in i386-asm. to make a client in haskell should not be that difficult with enough of time
05:57:04 <mm_freak> mr_sleepy: haskell beginner?
05:57:16 <ben> please throw in native xmpp support, bitlbee is a confusing mess sometimes :)
05:57:16 <shergill> mr_sleepy: for the love of god, why?
05:57:24 <nicoo> kejoki: Seriously ? An IRC client in *Prolog* ?
05:57:32 <srhb> That would be painful.
05:58:06 <shergill> i'm curious about the prolog irc client. was one the first languages i learnt and still love it for what it's good at
05:58:07 <kejoki> kidding.  just kidding.  (I *hope*.)
05:58:17 <nicoo> kejoki: Some googling found me an IRC bot in prolog, but no IRC client
05:58:21 <mr_sleepy> mm_freak: a returning haskell beginner, or what you call it. i had to program haskell at uni. but since then passed many years and last summer i got again interest for haskell
05:58:44 <rostayob> nicoo: what's wrong in writing an haskell client in prolog?
05:58:48 <mm_freak> mr_sleepy: then you shouldn't expect it to be easy =)
05:58:49 <mr_sleepy> shergill: i was a big fan of asm at that time... and i hated the haskell i was forced to program at uni
05:58:55 <rostayob> a friend of mine did the compilers course in prolog
05:59:01 <rostayob> he *loves* prolog
05:59:13 <nicoo> rostayob: s/haskell/IRC/ :P
05:59:22 <rostayob> yes, IRC client :P
05:59:29 <mr_sleepy> mm_freak: irc is easy... if i was able to do something like that in asm, it should be easy in haskell too. irc is something that is easy to handle
05:59:42 <arckeda> i need to get into hacker forum any link
06:00:07 <nicoo> rostayob: And I'm just saying that Prolog isn't very suited to problems where IO and lexing/parsing are the main problems
06:00:09 <mm_freak> mr_sleepy: well, IRC isn't easy, because the standard sucks…  the standard is easy to implement, but unfortunately most IRC servers don't follow it, but that's not even my point =)
06:00:11 <elliott> a haskell compiler in prolog!
06:00:12 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
06:00:19 <elliott> lambdabot: WHAT DO YOU WANT FROM ME
06:00:31 <srhb> elliott: She has the hots for you.
06:00:32 <mr_sleepy> mm_freak: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
06:00:32 <rostayob> nicoo: i think that SWI-Prolo is well equipped for those two
06:00:40 <mr_sleepy> mm_freak: as you can see irc is not difficult
06:00:59 <donri> @hackage ircbot
06:00:59 <lambdabot> http://hackage.haskell.org/package/ircbot
06:01:12 <nicoo> rostayob: I was thinking standard-compliant prolog :)
06:01:22 <mm_freak> mr_sleepy: well yes, but for serious networking you want more than what is in that article =)
06:01:29 <shergill> elliott: the same message from yesterday huh?
06:01:39 <rostayob> nicoo: Prolog is standardized?
06:01:46 <rostayob> oh, yes
06:01:51 <rostayob> well, who cares
06:02:03 <rostayob> we all write standards uncompliant haskell after all :)
06:02:08 <shergill> rostayob: SWI is good. as is XSB
06:02:32 <shergill> yapp isn't bad too, though i'm not sure if it has tabling or not
06:02:34 <rostayob> shergill: my uni had sicstus, which is proprietary but has a great emacs mode
06:03:03 <rostayob> and a lot of tools
06:03:22 <rostayob> but yeah, not free
06:03:43 <shergill> rostayob: sadface@not free
06:03:47 <kejoki> my univ had a Univac 1100/80 with Unisys
06:03:48 <rostayob> i know :)
06:04:03 <rostayob> kejoki: OLD
06:04:32 <kejoki> but we were able to get a couple of IBM 4381's later.  10M of HD apiece!  w00t!
06:04:33 <aiman> hi all, i'm new to haskell. i'm trying to get ghci to page its output through PAGER, so that if i do something like ":hoogle map", i can actually scroll through the results. i even tried adding "set page-completions on" to my .inputrc, but it didn't seem to respond to that.
06:05:07 <aiman> any suggestions?
06:05:31 <donri> :!hoogle | less works for me
06:07:18 <aiman> thanks donri, not sure what the problem is with my setup! nothing happens when i pipe through less in ghci
06:07:36 <donri> are you using :!
06:07:45 <aiman> aw, no! let me try
06:07:47 <donri> or some predefined hoogle command?
06:08:11 <aiman> i see what you did there donri
06:08:33 <donri> supposedly you have some :def in your .ghci
06:09:06 <aiman> yes with ":!" i can pipe just fine... what about for haskell functions i call from the interpreter?
06:09:34 <donri> that i don't know, sorry
06:10:29 <aiman> thanks anyway donri
06:12:50 <rostayob> mm_freak: ok, I spent some more time and I really can't figure this one out, can you give me some hints :P?
06:13:11 <mm_freak> rostayob: later i can…  right now i'm busy
06:13:42 <rostayob> mm_freak: ok thanks. this is frustrating
06:17:38 <Feuerbach> rostayob: what's the problem?
06:18:55 <mm_freak> Feuerbach: defining ArrowLoop for the SP arrow
06:19:36 <rpglover64> Is there a standard way to keep track of the lineage of the creation of a particular value? In particular, in a transitive closure over an initial set and a bunch of staticly defined rules, I'd like to know why each element of the final set was added.
06:20:24 <rostayob> mm_freak: i think i get it... it's not a total function right?
06:20:29 <rostayob> i mean it might fail
06:21:02 <Feuerbach> rostayob: it's more likely to loop indefinitely than fail
06:21:24 <Feuerbach> (if by failing you mean an exception)
06:21:39 <rostayob> well what i'm doing now, in a rather unelegant way
06:21:46 <rostayob> is to keep a queue with the elements to feed back
06:22:36 <mm_freak> rostayob: i'm not sure about that, because SP doesn't guarantee infinite lists
06:22:44 <mm_freak> so loop might indeed be partial
06:23:28 <mm_freak> i'd expect loop for an actual infinite stream processor arrow to be total
06:23:54 <mm_freak> and it will diverge whenever the argument computation is strict in this argument of type 'd'
06:25:33 <hpaste_> rostayob pasted “ArrowLoop SP” at http://hpaste.org/56793
06:25:37 <rostayob> ^^^ this is what I have
06:25:49 <Feuerbach> btw, are the laws for ArrowLoop written down anywhere?
06:27:02 <rostayob> Feuerbach: the paper "Programming with arrows" doesn't mention it
06:27:08 <rostayob> *them
06:28:56 <rostayob> no, that instance doesn't work
06:31:38 <wyfrn__> am i right that Text.ParserCompinators.ReadP.readP_toS call will always result in a list with just one element ?
06:33:19 <rostayob> mm_freak, Feuerbach: ok, I'm not the first person to stumble upon this: http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/71d8dcc07327c3e5/ae0d94a92885f7cf?lnk=gst&q=1st+Exercise+of+John+Hughes%27+Programming+with+Arrows+1st+Exercise+of+John+Hughes%27+Programming+with+Arrows+
06:33:42 <elliott> wyfrn__: yes, IIRC
06:33:55 <elliott> wyfrn__: that's the reason ReadP is used to implement the standard parsers (efficiency)
06:35:42 <_oz> I get a "stack space overflow" when I run a program compiled with ghc 7.2.2. What's the best way to diagnose the cause?
06:35:54 <elliott> _oz: it means you have a huge thunk building up somewhere
06:36:08 <elliott> likely, you have a numeric accumulator parameter that isn't being forced enough
06:36:27 <pchiusano> hello
06:36:28 <elliott> you could try one of the heap profile things, but it's probably easier to analyse the code directly
06:37:14 <_oz> elliott: is 7.4 supposed to spit out a stack trace in this case?
06:37:30 <_oz> I could certainly make use of one right now.
06:37:59 <_oz> maybe this is a good time to upgrade
06:38:16 <elliott> _oz: I don't know about that, but why not try and isolate the problem with GHCi?
06:38:29 <elliott> just test smaller components until you find the one that's causing the overflow
06:38:33 <elliott> you could also hpaste your code :P
06:39:15 <srhb> http://hpaste.org/56794 <-- I'm having a problem where "slow" seems to take more and more time for each line. I think somehow it's reevaluating all preceding terms, but I'm not sure what I did wrong to cause this.
06:39:35 <elliott> srhb: use mapM_
06:39:38 <_oz> this is quite a big program. I think I'd be the best one to triangulate the faulty bit.
06:39:40 <elliott> mapM accumulates a list in memory
06:39:55 <_oz> thanks for the offer though.
06:40:25 <srhb> elliott: Doesn't seem to change anything though. Maybe it really is not a problem with my code.
06:40:37 <elliott> srhb: well... ah, yes it is
06:40:43 <elliott> nothings = return "12345" : map (>>= nothing) nothings
06:40:52 <elliott> srhb: you get every previous page every time you get a page
06:40:58 <srhb> elliott: Right, I thought an infinite list would be an idiomatic solution.. Oh
06:41:00 <elliott> your code is kinda weirdly structured :P
06:41:05 <srhb> SOrry, I'm a newbie.
06:41:17 <elliott> an infinite list isn't really doing what you want here; it's not an infinite list of the resulting pages, but an infinite list of /actions/
06:41:23 <elliott> each one getting one more page than the previous
06:41:31 <rostayob> one of the disadvantages in generalizing functions in arrows is that you lose the nice currying
06:41:43 <srhb> elliott: I see. So this is just a "bad idea (tm)"
06:42:13 <elliott> srhb: slow = forM_ [0..10] $ \n -> nothing n >>= putStrLn
06:42:16 <elliott> is probably the best way to do it
06:42:17 <srhb> elliott: If I just get the last element, it seems to be very fast
06:42:31 <elliott> odd
06:42:54 <srhb> As in fast = last $ take 10 nothings
06:42:55 <elliott> there _are_ ways you can represent "an infinite stream of web pages" elegantly, btw, but they're probably very much overkill for what you're doing
06:43:08 <srhb> elliott: It probably is since I'm just playing around.
06:43:11 <elliott> srhb: well, that should get all 10 pages
06:43:19 <srhb> elliott: But only once
06:43:23 <elliott> as opposed to all 55 slow does
06:43:27 <srhb> elliott: Where the other gets 1 + 2 + 3 ...
06:43:29 <elliott> right
06:43:44 <elliott> you could use it to calculate triangular numbers :)
06:43:49 <srhb> elliott: Fun!
06:43:58 <srhb> elliott: Anyway thanks, I think I get the point.
06:44:17 <elliott> :)
06:46:44 <srhb> elliott: Couldn't I lazily sequence the IO actions?
06:48:35 <mm_freak> rostayob: i don't think of arrows as generalized functions
06:49:10 <rostayob> also, with the Arrows language extension, haskell code starts to look pretty esoteric: http://hpaste.org/56795
06:49:24 <rostayob> mm_freak: yeah but it's still kind of annoying having all those tuples
06:49:54 <elliott> srhb: well.. the problem is that your list looks like this
06:50:17 <elliott> srhb: <action that retrieves page 1> : <action that retrieves page 1, discards it, and retrieves page 2> : <action that that retrieves page 1, discards it, retrieves page 2, discards it, and retrieves page 3>
06:50:24 <elliott> srhb: and you're executing them in order
06:50:35 <srhb> elliott: Right, I expected some memoization going on I suppose.
06:50:38 <elliott> laziness doesn't really come into it: if you execute all of those, you're asking the computer to make 55 HTTP requests :)
06:50:51 <elliott> srhb: imagine that instead of "load HTTP page", it was "create file with random name"
06:50:54 <srhb> elliott: Because each page does need the previous. (to compute the URL)
06:51:15 <srhb> Hmm.
06:51:17 <elliott> you can't eliminate the duplication, because the whole point of IO actions is that they have arbitrary side-effects :)
06:51:21 <elliott> srhb: ah -- then my replicateM solution won't work
06:51:27 <srhb> No, I realize that.
06:51:43 <elliott> foldM is probably what you want
06:51:44 <elliott> :t foldM
06:51:45 <srhb> So what I want is to "promise Haskell" that this really is "pure" - sounds unsafe.
06:51:45 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:51:58 <koeien> well it isn't pure
06:51:59 <elliott> hmm, maybe not
06:52:16 <srhb> It is sort of pure. Any specific url will (barring errors) produce the same number every time.
06:52:21 <elliott> srhb: it's probably best to just structure your program in a way that says what you want :P
06:52:27 <koeien> srhb: not in general
06:52:39 <srhb> koeien: No, for this problem specifically.
06:53:00 <srhb> But OK. I guess this really isn't an idiomatic problem for Haskell anyway.
06:53:10 <elliott> currently your program tells the computer to do something really weird, and that's reflected in the fact that your loop is pretty hard to read (for me at least)
06:53:13 <koeien> i wouldn't recommend using unsafePerformIO here
06:53:15 <mm_freak> rostayob: actually i moved to a very applicative style with arrows, especially with AFRP
06:53:19 <koeien> only for a one-off script
06:53:46 <koeien> and even then, i'd sacrifice a goat afterwards
06:53:47 <mm_freak> rostayob: it's the Arrow class that requires all those tuples…  in the Applicative class it's up to you
06:53:59 <elliott> srhb: nothings 0 = return ["12345"]; nothings n = do { x <- nothings (n-1); xs <- nothings x; return (x:xs) }
06:54:16 <elliott> srhb: will probably be the best you'll get without using one of the proper effectful stream libraries like iteratees or conduits
06:54:19 <mm_freak> rostayob: but of course if you want multiple inputs to an arrow computation, you'll still need tuples
06:54:40 <srhb> elliott: That's a good point. And this would actually mean that even if I print everyone, the previous result is "memoized" (?)
06:54:45 <srhb> I'm not sure I'm using that term right
06:54:48 <rostayob> mm_freak: wait I don't get the connection between Arrow and Applicative here
06:54:48 <elliott> srhb: it's not really related to memoisation at all :)
06:54:49 <srhb> every term*
06:54:51 <elliott> it's just not duplicating work
06:54:56 <srhb> I see.
06:54:57 <elliott> i mean
06:55:05 <elliott> i guess you could say every reduction of duplicate work is memoisation in a sense
06:55:09 <koeien> this is a foldM, isn't it?
06:55:14 <mm_freak> rostayob: it's been shown that Category + Applicative = Category + Arrow
06:55:16 <elliott> koeien: nope
06:55:18 <elliott> koeien: it's natM
06:55:32 <elliott> if we had nat :: a -> (a -> a) -> Integer -> a
06:55:40 <koeien> ah, unfoldM
06:55:47 <elliott> oh... it would have to be natAccum :: a -> (a -> a) -> Integer -> [a], even
06:55:51 <elliott> :t unfoldM
06:55:52 <rostayob> mm_freak: Category + Applicative?
06:55:52 <lambdabot> Not in scope: `unfoldM'
06:55:55 <elliott> bah
06:56:00 <elliott> @hoogle unfoldM
06:56:00 <lambdabot> No results found
06:56:02 <koeien> if that would exist
06:56:04 <elliott> oh right
06:56:04 <rostayob> mm_freak: Category and Applicative have different kindness
06:56:05 <elliott> yeah, it would be
06:56:26 <mm_freak> rostayob: if you have 'instance Category X' and 'instance Applicative (X a)', then you have something equivalent to 'instance Arrow X'
06:56:30 <elliott> mm_freak: you forgot + laws
06:56:33 <koeien> Control.Monad.Loops has it
06:56:37 <koeien> in monad-loops
06:56:43 <rostayob> mm_freak: ah. interesting
06:56:49 <mm_freak> roughly it least…  i'm ignoring laws =)
06:57:05 <elliott> (ignoring laws)++
06:57:31 <heatsink> Can someone point me to example use cases of recursive data types where the recursive type is different?
06:57:40 <heatsink> Things like data T a = T (T [a])
06:58:09 <mm_freak> heatsink: Tree
06:58:33 <roconnor> heatsink: untyped lambda calculus
06:58:39 <heatsink> Not the trees I'm familiar with
06:58:43 <koeien> balanced trees, data T a = Leaf a | Branch (T (a,a))
06:58:54 <heatsink> Okay, balanced trees are one
06:59:04 <roconnor> heatsink: data LC a = Var a | App (LC a) (LC a) | Abs (LC (Maybe a))
06:59:07 <elliott> different to what?
06:59:19 <elliott> oh
06:59:22 <elliott> i see
06:59:24 <roconnor> heatsink: this is in Bird's paper on non-uniform data types
06:59:27 <elliott> heatsink: free monad
06:59:33 <elliott> hmm
06:59:38 <roconnor> cofree comonad
06:59:42 <heatsink> I'll look for that paper
07:00:06 <elliott> i don't think free monads count
07:00:12 <elliott> since the recursion itself is the same
07:00:15 <roconnor> oh oops
07:00:15 <Philippa> 2-level types, eg Sheard's Generic Unification
07:00:30 <elliott> same with the co version
07:00:30 <Philippa> (best thing about 2-level types? 2-level functions)
07:01:10 <roconnor> heatsink: twanvl_ uses them to implement what I call "CartesianStore"s
07:01:25 <elliott> heatsink: data AltList a b = Empty | Cons a (AltList b a)
07:01:31 <elliott> gotta be useful for _something_
07:01:50 <elliott> it's ([(a,b)], Maybe a) :P
07:01:53 <roconnor> data CartesianStore b a = Unit a | Battery (CartesianStore b (b -> a)) b
07:02:24 <roconnor> elliott: ([(a,b)], Maybe a) is different
07:02:29 <nicoo> heatsink: GADT for modeling pl, for instance "data Expr a = Apply (Expr a->a, a) | ..."; If you want something like "Equal :: a Expr -> a Expr -> bool Expr", you need GADT tought
07:02:56 <elliott> roconnor: erm, really?
07:03:11 <heatsink> I'm not familiar with these examples, so I'm going through them slowly.  Still looking up that encoding of untyped LC
07:03:11 * elliott is probably missing something obvious
07:03:17 <elliott> nicoo: *Expr (a->a), methinks
07:03:25 <elliott> also *Expr a :P
07:03:38 <elliott> heatsink: basically you use LC Void for an expression with no free variables
07:03:41 <nicoo> elliott: Yes, yes; tired
07:03:53 <elliott> heatsink: it's "typed" de bruijn, essentially
07:04:16 <roconnor> elliott: compore (Cons "t" (Cons 1 Empty)) and (Cons "t" Empty) with your proposed uniform type.
07:04:20 <roconnor> *compare
07:04:57 <elliott> roconnor: those are ([("t",1)], Nothing), ([], Just "t")
07:05:07 <elliott> the (Maybe a) holds any "trailing" a
07:06:11 <roconnor> ah
07:06:23 <roconnor> okay I see now
07:06:46 <elliott> probably pretty awkward to actually use that representation, though
07:10:49 <heatsink> I found Bird's paper and roconnor's paper.  It will take me some time to read those.  Thanks.
07:12:55 <elliott> :t foldM
07:12:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:15:11 <mm_freak> rostayob: to me SP appears to be isomorphic to wire arrows
07:15:35 <mm_freak> while SP pushes, wires pull
07:15:46 <mm_freak> otherwise they seem equivalent
07:18:03 <rostayob> mm_freak: ghc: panic! (the 'impossible' happened)
07:18:11 <rostayob> ops, didn't mean to direct that to you
07:18:25 <elliott> it couldn't match No with Yes
07:18:28 <mm_freak> rostayob: does your ArrowLoop problem even cause GHC to crash now? =P
07:18:40 <rostayob> mm_freak: not exactly that, but pasting some code from that paper causes that
07:18:58 <koeien> ghc has proven False, no problem
07:19:03 <mm_freak> i want to prove the isomorphism now =)
07:19:23 <rostayob> mm_freak: if you can write a working ArrowLoop instance, cool
07:19:25 <rostayob> because i can't
07:22:49 <mm_freak> rostayob: that's why i'm trying to prove the isomorphism now
07:23:04 <mm_freak> SP is at least as powerful as Auto, because i have a working autoToSp function now
07:24:21 <rostayob> mm_freak: i'll be waiting :)
07:24:51 <mm_freak> apparently Auto is less powerful, so i suspected right…  i'll need at least the wire arrow for that
07:29:32 <akosch> I'm looking for ways to improve my code: http://hpaste.org/56796
07:30:15 <akosch> especially the runRequest function
07:31:11 <twanvl_> You can probably use Applicative instead of Monad for parsing the arguments there
07:31:43 <roconnor> akosch: seems pretty reasonable to me
07:31:44 <twanvl_> multiPrint <$> (maybeFromJSON =<< params !? 0) <*> (maybeFromJSON =<< params !? 1)
07:32:06 <twanvl_> perhaps wrap the combination of maybeFromJSON and (?!) in a function
07:32:11 <elliott> akosch: it looks fine
07:32:14 <akosch> twanvl_: thanks, but it's still too explicit for my taste ;)
07:32:25 <elliott> what's explicit about that?
07:33:03 <akosch> elliott: use the first parameter from params as the first parameter of my function (after converting it)
07:33:10 <elliott> akosch: runRequest could use pattern guards
07:33:50 <akosch> elliott: I think this could be generalized somehow (I would use reflection for this in other languages)
07:34:04 <elliott> akosch: also, you never use requestId
07:34:37 <akosch> elliott: I will use requestId, this is just an early version
07:35:29 <hpaste_> elliott annotated “rpc test” with “runRequest” at http://hpaste.org/56796#a56797
07:35:36 <elliott> akosch: something like that ^
07:35:50 <elliott> using the Maybe monad
07:36:32 <akosch> elliott: thanks, I didn't know I could write it like that
07:37:47 <akosch> elliott: still, if I have another method besides 'multiPrint' (with 4 parameters this time) I would again need to list param1, param2, param3
07:38:49 <akosch> elliott: can't I generalize the "get parameters from the array + convert them + call a function using them" part?
07:40:32 <elliott> akosch: sure
07:40:35 <elliott> well
07:40:40 <elliott> for a fixed number of parameters
07:40:48 <elliott> actually
07:40:52 <elliott> you can just generalise the applicative pattern
07:41:09 <copumpkin> ezyang: http://hpaste.org/48794
07:41:45 <elliott> akosch: but uh unless you're going to have, say, 10 or more of these, the boilerplate will override the benefits
07:42:19 <elliott> akosch: you could have a table like
07:42:26 <elliott> akosch: [("multiPrint", lift2 multiPrint), ...]
07:42:33 <elliott> and defining lift1/lift2/etc. would be easy
07:42:59 <elliott> lift2 f params = f <$> paramAt 0 params <*> paramAt 1 params
07:43:05 <elliott> and have paramAt n params = maybeFromJSON =<< params !? n
07:43:14 <elliott> that'd be simpler than defining your own combinators, really
07:43:20 <elliott> (applicative-style)
07:43:40 <akosch> elliott: I see, it's a bit hard with variable parameters I guess
07:45:57 <akosch> elliott: I could have multiPrint accept a list of parameters and pattern-match them out of it
07:46:22 <akosch> elliott: but that would make my function definitions ugly :(
07:46:26 <elliott> akosch: that's uglier :)
07:46:40 <elliott> akosch: if all your functions are 1-5 parameters or so, just defining five liftN combinators will be the nicest solution
07:46:50 <elliott> and you can list all the functions in a single table
07:47:48 <akosch> elliott: thanks, this is definitely the way to go. Functions with more than 5 params are unreadable anyway :)
07:48:23 <elliott> indeed :P
07:48:56 <elliott> akosch: an applicative style could be useful if you want to have things like multiPrint operate directly on haskell data types instead of parsing the json themselves, though
07:49:09 <elliott> something like: multiPrint <$> stringArg <*> intArg
07:49:36 <akosch> elliott: I'll keep that in mind, thanks again!
07:49:45 <elliott> np :)
07:50:00 <akosch> elliott: one last thing, what would you use for error handling without complicating the code too much? Either or exceptions maybe?
07:50:56 <elliott> it depends on which part you're talking about... if everything you're doing is very "IO-y" and you're not using any monad transformers, IO exceptions could probably work
07:51:01 <elliott> especially if you need to handle the errors of other IO libraries
07:51:11 <elliott> otherwise, probably ErrorT or something
07:51:19 <kuznero> How is it possible to make Emacs (with haskell-mode) aware of different imported functions? Is it possible to load whole project somehow (like in GHCi)?
07:52:23 <akosch> elliott: I'm leaning towards exceptions, because I will do more or less only IO
07:52:35 <elliott> kuznero: C-c C-l starts a GHCi session in Emacs, but that's probably not what you want...
07:52:48 <elliott> akosch: exceptions are probably fine then
07:53:16 <kuznero> elliot: let me try...
07:53:53 <akosch> elliott: for errors regarding missing parameters or invalid requests (no IO there), ErrorT seems more appropriate though
07:54:10 <kuznero> ellitt: that will load only the file from current buffer in Emacs, whether I would like to make it aware about whole project somehow....
07:54:26 <elliott> kuznero: you might want to look into haskell-emacs which has a lot of "project"-style features
07:54:29 <kuznero> elliott: (sorry for misspelling your name)...
07:54:35 <elliott> or scion, maybe
07:54:38 <elliott> kuznero: hehe, i'm used to it :)
07:54:47 <elliott> akosch: dealing with two error-handling facilities is probably more pain than just using exceptions
07:55:02 <elliott> unless you have a large body of code that's /just/ parsing requests
08:00:17 <Yrogirg> What is the best way to have a fresh ghc in ubuntu? Is there a dependable ppa?
08:00:28 <koeien> download the binaries from haskell.org/ghc
08:00:45 <koeien> be sure to install GHC 7.0.4
08:00:54 <koeien> then install the haskell platform
08:00:56 <koeien> @where platform
08:00:57 <lambdabot> http://hackage.haskell.org/platform/
08:01:13 <elliott> ubuntu already has 7.0.3
08:01:27 <koeien> that doesn't fly with the latest platform
08:01:40 <koeien> which is ok if you don't mind that
08:01:44 <elliott> ubuntu also has the platform
08:01:51 <elliott> so i guess Yrogirg probably wants 7.2
08:02:09 <kuznero> elliott: yeh... that is exactly why I'm using Leksah IDE, but not vim (or emacs) - those simply does not have a notion of a project, module, etc.
08:02:47 <elliott> kuznero: well, haskell-emacs and scion and the like are basically IDEs built on top of emacs
08:02:52 <elliott> (I think scion has non-emacs backends though)
08:04:13 <kuznero> elliott: yes, but it's not mature enough... or I simply can't bake it the right way :)
08:04:33 <akosch> scion doesn't build for me :(
08:04:42 <elliott> i think scion doesn't build for anyone
08:04:50 <elliott> at least i've never heard anyone say "scion builds!"
08:04:57 <kuznero> :)
08:06:17 <akosch> elliott: yeah, hackage says it needs ghc-6.10 (even my debian system is too much up-to-date)
08:06:45 <elliott> akosch: oh, the repo version works in ghc 7, as i understand it
08:07:04 <elliott> https://github.com/nominolo/scion
08:08:09 <akosch> elliott: hm, always wanted to try it with vim. I guess now's the time :)
08:14:04 <nominolo> elliott: after the ICFP deadline I will have some more time to work on scion
08:14:17 <elliott> haha, hi
08:14:28 * elliott hasn't used it, but is tempted to try it out just for the "type at point" feature
08:14:51 <nominolo> now that I no longer have to reimplement shake it should finally be possible to put it onto solid foundations
08:15:15 <nominolo> elliott: ironically I had to disable that feature for the time being
08:15:19 <elliott> aww
08:15:48 <hpaste_> kejoki annotated “It Works!” with “It Works! (better)” at http://hpaste.org/56790#a56798
08:16:36 <srhb> I really do miss while loops an awful lot..
08:17:00 <mike-burns> kejoki: How about using the cmdargs package?
08:17:13 <mike-burns> srhb: We have forM_.
08:17:29 <srhb> mike-burns: I'll check that out.
08:17:38 <kejoki> mike: learning.  I'm an old curmudgeon, so I have to do things the hard way first.
08:18:04 <elliott> I even suggested forM_ to srhb :)
08:18:16 <elliott> srhb: you'll probably miss them a lot less when you try a task that isn't 100% IO :P
08:18:40 <kejoki> mike-burns: sorry, my name-grabbing macro has a bug.
08:19:01 <mike-burns> OK well, have fun!
08:19:25 <srhb> elliott I thought it was just mapM with arguments switched. It doesn't solve it. But yes, the whole "following this series of data from web pages to new urls" is a very contrived problem.
08:19:34 <srhb> elliott: Not being able to solve it cleanly is still annoying though. :P
08:19:40 <kejoki> mike-burns: no fist-through-moniter yet.
08:19:46 <elliott> it's mapM_ with arguments switched
08:19:47 <kejoki> close, though
08:19:57 <elliott> srhb: wasn't my solution clean enough? :)
08:20:17 <srhb> elliott: I don't think either of your solutions were really solutions. :)
08:20:38 <mike-burns> You're scraping HTML for links then following them?
08:20:40 <srhb> But still, I get that the problem is contrived. Perhaps I should stop dwelling on it.
08:20:43 <srhb> mike-burns: Yes
08:20:49 <srhb> mike-burns: Until "something"
08:21:03 <srhb> mike-burns: They're not really links though, just numbers that I pop into an url.
08:21:20 <hpaste_> elliott annotated “Slower and slower” with “Slower and slower (annotation)” at http://hpaste.org/56794#a56799
08:21:32 <elliott> srhb: doesn't that work? ^ (hmm... I guess it gives the result backwards)
08:22:01 <elliott> if you really want it to look nice though you'll want to use one of the proper monadic stream processing facilities we have :P
08:22:22 <mike-burns> http-conduit and ... tag-stream? Is there a better HTML parsing lib?
08:22:23 <srhb> elliott: No, that does not work. Er, I'm not sure why it doesn't - nor why it would if it wasn't broken.
08:22:34 <srhb> I'm sure I should. :) I'm just obsessing.
08:23:14 * kejoki muses that insanity is an instance of Monad
08:23:16 <Yrogirg> does anybody here use https://launchpad.net/~someone561/+archive/ppa ?
08:23:39 <elliott> Yrogirg: that thing's 7.2 /and/ 7.0 releases are behind :(
08:23:43 <elliott> (7.2.2 and 7.0.4 are the latest)
08:23:54 <srhb> So nothings "10" tries nothing 10.. Which makes no sense, the first item in nothing is "12345"
08:24:04 <elliott> srhb: oh, err, right
08:24:27 <srhb> It is contrived, let's let it die. :-) I just got annoyed because of a clean twoliner in Python. No sense in comparing anyway.
08:24:28 <elliott> srhb: yes... my code is totally broken :)
08:24:38 <srhb> RIght. :D I'm glad I'm not completely lost then.
08:25:43 <srhb> I still think Unsafesomething is the way here
08:25:58 <elliott> it's really not, the people who suggested that didn't see the context :P
08:25:59 <mike-burns> srhb: Write a library to cut the Haskell down to two lines.
08:26:07 <Veinor> i think network.http is known to kind of suck
08:26:11 <mike-burns> Yes.
08:26:14 <srhb> elliottUnsafe is not the way?
08:26:20 <srhb> Hehe.
08:26:32 <elliott> what you need is unfoldM, not unsafePerformIO :)
08:26:42 <srhb> The solution is trivial if I can have a list that is simply list = "12345" : map unsafesomething list
08:26:50 <srhb> Or am I not seeing the problem?
08:27:06 <Veinor> srhb: what's the thing that you're trying to do?
08:27:19 <hpc> :t unfoldM
08:27:20 <lambdabot> Not in scope: `unfoldM'
08:27:26 <hpc> @hoogle unfoldM
08:27:26 <lambdabot> No results found
08:27:26 <srhb> This is going in circles. :P
08:27:31 <koeien> it's in monad-loops
08:28:08 <elliott> srhb: for what it's worth: using unsafePerformIO like that is _not_ guaranteed to work
08:28:16 <mm_freak> srhb: you have while loops in haskell…  they're just not spelled that way, have semantic meaning and are usually attached to data structures =)
08:28:22 <elliott> unsafePerformIO _must_ only be used when there is _no_ possibility of external side-effects
08:28:28 <elliott> i.e., it /must/ only be used to implement a pure interface
08:28:37 <elliott> and the compiler can and will take advantage of this fact to break code that ignores that
08:28:43 <srhb> Right, I'm obsessing over the solution not being short because the non-short solution is safe. I do get it. Let's let it die. :-)
08:28:46 <mm_freak> srhb: and no, for you unsafePerformIO is never /a/ solution, let alone the best ;)
08:28:59 <kejoki> Why is hpaste all bent out of shape about concatMap vs. concat . map ??  Is concatMap a fast builtin?
08:29:02 <mm_freak> the solution to what anyway?
08:29:12 <koeien> kejoki: no, it's the same.
08:29:16 <elliott> It can't die!! Nothing can die until Haskell is the shortest!!!
08:29:16 <hpc> @src concatMap
08:29:16 <lambdabot> concatMap f = foldr ((++) . f) []
08:29:18 <elliott> NOTHIIIING
08:29:32 <srhb> :-)
08:29:39 <elliott> kejoki: hpaste just forwards hlint's suggestions
08:29:46 <mike-burns> ... so write a library to make this shorter.
08:29:50 <Veinor> kejoki: there's no point in using concat . map when concatMap (aka bind) exists
08:29:50 <mike-burns> Really, this will help everyone.
08:29:54 <kejoki> hpc: got it
08:30:06 <hpc> kejoki: personally, i would go all the way and use join instead of concatMap
08:30:09 <srhb> mm_freak: You can check that hpaste if you're curious
08:30:14 <hpc> er
08:30:19 <koeien> (>>=) you mean
08:30:20 <hpc> use (>>=)
08:30:20 <mm_freak> srhb: could you link it again?
08:30:22 <srhb> mm_freak: http://hpaste.org/56794#a56799
08:30:23 <hpc> yeah, that
08:30:34 <srhb> mm_freak: The first one works, but is slow because of (very long discussion)
08:30:36 <elliott> mm_freak: note that the solution there does not have the correct semantics :)
08:30:41 <elliott> it is only meant to request each page once
08:30:45 <srhb> Yes.
08:31:10 <koeien> what's wrong with this solution?
08:31:17 <mike-burns> What's the main entry point in that hpaste?
08:31:23 <koeien> slow
08:31:24 <prof7bit> quick question: I ust tried whether I could use :m instead of :main (just like i could use :t instead of :type) but it did something else. now i tried to look up what :m actually does but i cannot find it. what happened?
08:31:35 <mauke> :module
08:31:44 <koeien> :module
08:31:54 <mm_freak> srhb: what is the code supposed to do?
08:32:00 <hpc> i think :? lists all the shorthands
08:32:09 <prof7bit> but a comes before o, what is the logic in chosong module instead of main?
08:32:14 <elliott> mm_freak: request http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345
08:32:19 <hpc> prof7bit: frequency of use
08:32:19 <elliott> mm_freak: extract the last word, request http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=<lastword>
08:32:19 <koeien> prof7bit: frequency of usage
08:32:21 <mauke> what is :main?
08:32:23 <elliott> repeat until 10 pages have been fetched
08:32:27 <elliott> and print out every one of the words
08:32:34 <mm_freak> i see
08:32:41 <kejoki> hpc, koeien: still looking at how do sugars >>=
08:32:42 <elliott> at least that is my understanding
08:33:00 <mm_freak> doesn't sound terribly complicated to me
08:33:03 <mm_freak> sounds like foldM
08:33:05 <srhb> mm_freak: Exactly what it does. read the number from the page, get the next one, read the new number, get the next one from the url
08:33:08 <koeien> mm_freak: unfoldM
08:33:23 <mm_freak> i'd foldM =)
08:33:23 <srhb> mm_freak: The solution in the top does work, but it repeats every request for each item in the list.
08:33:23 <koeien> although foldM could also work, i think
08:33:39 <srhb> I don't see how it would.
08:33:56 <srhb> Anyway, it is silly. And dead. :-)
08:34:26 <mm_freak> hmm…  actually i wouldn't even foldM…  i'd really write this recursively
08:34:33 <koeien> yup
08:34:41 <koeien> like the annotated version
08:34:47 <srhb> Which doesn't work at all.
08:34:47 * kejoki Oh look!  A horsie!  Move, horsie!  Whap! Whap!  Move!
08:34:53 <srhb> It does nothing like the original one.
08:34:56 <koeien> in what respect?
08:34:59 <elliott> mine is broken
08:35:03 <elliott> completely
08:35:08 <elliott> but it's only a 10-char fix or so to fix it :P
08:35:16 <elliott> fine!! i'll fix it
08:35:21 <srhb> I scarcely believe that!
08:35:22 <srhb> :P
08:35:30 <mike-burns> What's the Python solution look like?
08:35:45 <srhb> get number.. while true.. get number
08:35:53 <srhb> Of course, that is infinite, which non-lazy does not handle well
08:36:07 <mike-burns> What's get number look like?
08:36:23 <hpaste_> elliott annotated “Slower and slower” with “Slower and slower (annotation) (annotation)” at http://hpaste.org/56794#a56800
08:36:24 <srhb> retrieve page from url, take last word from output
08:36:34 <shirt> anyone participating now in the facebook hacker cup?
08:36:41 <elliott> oh, needs an import Control.Applicative
08:36:53 <elliott> but yeah, I'd like to see the Python "two-liner"
08:36:57 <elliott> I bet the lines are 100 chars at least :)
08:37:19 <mike-burns> Oh you want an infinite loop, not a while loop?
08:37:22 <prof7bit> hmm... :? does not list the shorthands for me, it seems it does the same as :help
08:37:26 <mike-burns> :t forever
08:37:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:37:42 <koeien> forever is not useful in this case
08:37:44 <srhb> x = urllib2.urlopen(y+x).read().split()[-1]
08:37:46 <srhb> Really, not that long.
08:37:49 <prof7bit> :?
08:37:49 <srhb> Not readable, but not long
08:37:59 <elliott> srhb: erm, that's definitely not the complete program :)
08:37:59 <srhb> oh sorry, that y shuouldn;t be there
08:38:04 <srhb> Of course not.
08:38:17 <elliott> x = urllib2.urlopen(y+x).read().split()[-1]
08:38:17 <elliott>   n' <- last . words <$> getPage (url n)
08:38:31 <elliott> haskell would be shorter if you removed the whitespace :)
08:38:35 <elliott> I guess getPage is cheating though, hehe
08:38:36 <koeien> and the type sigs.
08:38:44 <srhb> It;s true, but that part I had down already. :-)
08:38:57 <hpc> elliott: nonono, it's the pixels you have to remove
08:39:02 <hpc> what we need is Acme.Bleach
08:39:18 <koeien> you could use an IORef
08:39:20 * koeien hides
08:39:24 <mike-burns> Can you pastebin the Python?
08:39:26 <elliott> /ban koeien
08:39:48 <srhb> I can, later, but I'm actually standing here half naked and on my way out the door ( too exciting)
08:39:51 <srhb> So see you!
08:39:56 <mike-burns> Er, bye.
08:40:10 <mm_freak> srhb: you know what…  that is actually the first valid application for the automaton arrow outside of AFRP =)
08:40:14 <mm_freak> there he goes
08:40:50 <Veinor> what's the automaton arrow?
08:41:04 <elliott> Auto a b =a -> (b, Auto a b)
08:41:06 <elliott> *= a
08:41:13 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
08:41:31 <Veinor> ah
08:41:33 <mm_freak> composable streams, basically
08:41:39 <elliott> mm_freak: it's basically an infinite unfold
08:41:45 <elliott> so it's not surprising it's applicable here
08:41:53 <byorgey> it takes a's as input and generates b's as output, but can also change behavior based on the input a's
08:43:39 <roconnor> > (+) 1 2 4
08:43:40 <lambdabot>   3
08:43:46 <Veinor> caleskell!
08:44:23 <roconnor> > (+) id succ 4
08:44:24 <sipa> yay for extensive Num instances, and unintended consequences
08:44:25 <lambdabot>   9
08:44:38 <mauke> consequences will never be the same
08:45:25 <mauke> :t (sin, cos) + pi
08:45:26 <lambdabot> forall a a1. (Floating a, Floating a1) => (a -> a, a1 -> a1)
08:45:40 <elliott> `:D
08:45:44 <koeien> that's horrible
08:45:46 <elliott> s/`//
08:45:55 <koeien> or awesome, i'm not sure yet ;)
08:45:56 <elliott> > both ($ 42) ((sin, cos) + pi)
08:45:57 <lambdabot>   Not in scope: `both'
08:46:00 <mm_freak> :t (sin, cos pi) + pi
08:46:01 <elliott> @let both = join (***)
08:46:01 <lambdabot>  Defined.
08:46:01 <lambdabot> forall a a1. (Floating a, Floating a1) => (a -> a, a1)
08:46:02 <elliott> > both ($ 42) ((sin, cos) + pi)
08:46:05 <lambdabot>   (2.2250711056741594,2.7416073386014417)
08:46:17 <ion> @oeis 2,2,2,5,0,7,1,1,0
08:46:26 <lambdabot>  Sequence not found.
08:46:45 <Veinor> > sin 42 + pi
08:46:46 <lambdabot>   2.2250711056741594
08:47:00 <byorgey> what we need is a lambdabot plugin for Plouffe's Inverter
08:47:03 <mm_freak> > (sin sin pi, sin pi, sin, pi) + pi
08:47:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:04 <lambdabot>    arising from a use of `...
08:47:13 <mm_freak> > (sin pi, sin, pi) + pi
08:47:14 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:14 <lambdabot>    arising from a use of `...
08:47:22 <ion> > (sin pi, sin, pi) + pi $ pi
08:47:23 <lambdabot>   Couldn't match expected type `a -> b'
08:47:23 <lambdabot>         against inferred type `(a1, a...
08:47:24 <mm_freak> > (sin sin pi, sin pi, sin) + pi
08:47:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:25 <lambdabot>    arising from a use of `...
08:47:25 <XexonixXexillion> > (abs id) (-5)
08:47:26 <lambdabot>   5
08:47:34 <mm_freak> alright
08:47:38 <mauke> > abs -5
08:47:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:39 <lambdabot>    arising from a use of `...
08:47:41 <mm_freak> > (sin pi, sin) + pi
08:47:42 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:42 <lambdabot>    arising from a use of `...
08:47:45 <mauke> > abs -5 $ 2
08:47:46 <lambdabot>   -3
08:47:49 <mm_freak> huh?!
08:47:56 <mm_freak> > (cos, sin pi) + pi
08:47:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:47:57 <lambdabot>    arising from a use of `...
08:48:05 <mm_freak> did anyone just add an instance?
08:48:16 <mm_freak> oh wait…  i'm evaluating…  d'oh!
08:48:33 <mm_freak> :t (sin sin pi, sin sin, sin, pi) + pi
08:48:34 <lambdabot> forall a a1 a2 a3. (Floating a, Floating a1, Floating a2, Floating a3) => (a, a1 -> a1, a2 -> a2, a3)
08:49:03 <mm_freak> :t sin + sin sin + sin sin sin + sin sin sin sin
08:49:04 <lambdabot> forall a. (Floating a) => a -> a
08:49:15 <mm_freak> wow
08:49:20 <mm_freak> > (sin + sin sin + sin sin sin + sin sin sin sin) pi
08:49:21 <lambdabot>   4.898587196589413e-16
08:49:27 <ion> All your sins have been forgiven.
08:49:30 <XexonixXexillion> ...
08:49:47 <mauke> creating random numbers by deterministic means?
08:49:53 <Veinor> hmm
08:49:53 <mauke> you must be living in a state of sin
08:50:02 <Veinor> does sin sin sin sin ... converge to 0?
08:50:08 <mm_freak> isn't this like physics?  exploring the land of types…
08:50:13 <mm_freak> by experimentation
08:50:32 <Veinor> i want to say it does
08:50:33 <mm_freak> Veinor: let's see
08:50:35 <mm_freak> > fix sin
08:50:39 <lambdabot>   mueval-core: Time limit exceeded
08:50:42 <mm_freak> no idea ;)
08:50:44 <koeien> Veinor: sin(x) < x for x > 0
08:50:55 <mauke> > iterate sin 2
08:50:56 <lambdabot>   [2.0,0.9092974268256817,0.7890723435728884,0.7097000402345258,0.65160626364...
08:51:00 <Veinor> koeien: does that prove it?
08:51:07 <koeien> not necessarily :/
08:51:26 <kejoki> All of the ancient computer scientists and mathematicians command you to wash your brain for even *thinking* about experimental algorithmics, mm_freak
08:51:28 <Veinor> actually, i think it might
08:51:28 <elliott> > sin sin 42
08:51:29 <lambdabot>   -0.7934894946620349
08:51:30 <elliott> > sin (sin 42)
08:51:31 <lambdabot>   can't find file: L.hs
08:51:32 <mm_freak> wait, fix is right-associative
08:51:33 <elliott> > sin (sin 42)
08:51:34 <lambdabot>   -0.7934894946620349
08:51:36 <elliott> hahaa awesome
08:51:43 <Veinor> haha what the hell happened there
08:51:44 <elliott> implicit composition!
08:51:46 <XexonixXexillion> > ((iterate sin sin) !! 1000) pi
08:51:47 <lambdabot>   1.2246467991473532e-16
08:51:50 <elliott> Veinor: numeric instance
08:51:51 <elliott> erm
08:51:52 <elliott> function instance
08:51:53 <Veinor> no i mean
08:51:54 <mm_freak> > foldl ($) sin (repeat sin)
08:51:55 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
08:51:57 <koeien> don't take pi
08:51:58 <Veinor> 12:40:49        <lambdabot>   can't find file: L.hs
08:52:01 <elliott> oh
08:52:03 <elliott> lambdabot does that all the time
08:52:14 <elliott> usually when something like this is going on :)
08:52:18 <Veinor> > (iterate sin !! 1000) 1
08:52:18 <lambdabot>   Couldn't match expected type `[a]'
08:52:19 <lambdabot>         against inferred type `a1 -> [a1]'
08:52:19 <Feuerbach> koeien: it proves that it converges. Now, because sin is continuous, that needs to converge to its fixed point less than any eps, which is 0
08:52:34 <koeien> Feuerbach: yes continuity is needed
08:52:37 <shachaf> Veinor: I think it's some race condition with @let.
08:52:40 <Veinor> ah
08:52:41 <nyingen> I have this package (mueval), but it doesnt' work properly since "most RTS options are disabled"
08:52:42 <XexonixXexillion> > ((iterate sin sin) !! 1000) 1
08:52:42 <lambdabot>   5.456585747020246e-2
08:52:47 <elliott> nobody @letted, though
08:52:50 <elliott> unless in /msg I guess
08:52:57 <elliott> nyingen: recompile with -rtsopts
08:52:57 <nyingen> it says to "link with -rtsopts" but how do I do that with a cabal package?
08:52:57 <shachaf> Which people do.
08:53:05 <elliott> nyingen: --ghc-options="-rtsopts"
08:53:05 <nicoo> kejoki: Experimental algorithmics are fine. Experimental *analysis* is inherently evil; this way lies the path of the Sith^Wnumerician
08:53:17 <koeien> matlab, here i come!
08:53:22 <nyingen> elliott: I added -rtsopts to the ghc-options field of the .cabal file, and rebuilt it, but it didn't seem to work
08:53:35 <koeien> did you reconfigure as well?
08:53:41 <nyingen> yes
08:53:47 <kejoki> nicoo : that just means it's all actually synthesis.
08:54:03 * kejoki my analyst will be so disappointed.
08:55:01 <nyingen> hm, maybe I didn't
08:55:25 <elliott> nyingen: oh... i think it maybe doesn't use the options for linking
08:55:35 <elliott> if reconfiguring doesn't work try --with-ghc="ghc -rtsopts" as a hack
08:55:55 <XexonixXexillion> I think we should make caleskell the new haskell standard
08:56:04 <nyingen> elliott: where do I type that? 'runghc Setup.hs --with-ghc=...' ?
08:56:38 <elliott> nyingen: yes, but you should really be using "cabal" :)
08:56:43 <elliott> cabal configure
08:56:45 <elliott> erm
08:56:47 <elliott> cabal configure --with-ghc=...
08:56:48 <elliott> cabal build
08:57:02 <nyingen> so, run that in the mueval-0.8.1 directory?
08:57:08 <elliott> but uh there is probably a nicer way than that, so don't do that unless nobody else knows how to turn on -rtsopts properly
08:57:14 <elliott> nyingen: oh, hmm, wait
08:57:22 <elliott> I bet it's that mueval is compiling the program without -rtsopts and then trying to run it with rtsopts
08:57:25 <elliott> or something like that
08:57:35 <nyingen> oh, I see
08:57:41 <mm_freak> XexonixXexillion: please not
08:57:44 <elliott> bah, I don't know :) but you might have to edit your mueval-using code to use -rtsopts
08:57:49 <elliott> as one of the options
08:57:53 <nyingen> yeah, that would be lambdabot
08:58:04 <elliott> ask Cale :P
08:58:35 <XexonixXexillion> mm_freak: but it's so much more fun
09:00:51 <irene-knapp> okay, so right, I asked this in the wrong channel
09:00:52 <irene-knapp> http://hpaste.org/56801
09:01:00 <irene-knapp> this code works fine with type synonyms (not shown)
09:01:13 <nyingen> Cale: having some trouble getting mueval/lambdabot to work, has to do with -rtsopts. Any ideas?
09:01:32 <irene-knapp> but it's inconvenient to have a type synonym as a monad instance, because you can't write the transformer for it, because type syononym constructors must always be fully applied
09:01:42 <irene-knapp> and I also can't use a newtype because it's an existential
09:01:52 <irene-knapp> so I need to use data, yes
09:02:16 <shachaf> If it's an existential how does a type synonym work?
09:02:24 <mm_freak> XexonixXexillion: fun on IRC, but imagine there are people who use haskell productively
09:02:29 <irene-knapp> it appears to be supported, with appropriate language pragmas :)
09:02:34 <irene-knapp> I think Rank2Types probably
09:02:48 <rostayob> then you can use Rank2Types inside the newtype as well, right?
09:02:53 <irene-knapp> no, not supported
09:03:02 <irene-knapp> ticket to add it
09:03:09 <elliott> irene-knapp: you don't seem to have asked an actual question yet :P
09:03:11 <rostayob> ah, ok
09:03:11 <irene-knapp> ticket exists but no movement
09:03:12 <elliott> oh
09:03:13 <elliott> it's in the paste
09:03:19 <irene-knapp> oh, the question is how can I write this stuff
09:03:26 <elliott> "instance forall backend context" uh, you can do that?
09:03:27 <rostayob> irene-knapp: but it's not an existential
09:03:28 <irene-knapp> with the synonyms, throw and catch were just ordinary functions, right
09:03:55 <rostayob> irene-knapp: newtype Foo = Foo (forall a. a) works for me
09:03:58 <irene-knapp> elliott: no you can't, because that's the first error message
09:04:10 <irene-knapp> rostayob: hmmmmmmmm?. GHC version?  I'm on 7.2.2, maybe I need to upgrade?
09:04:11 <elliott> i didn't even know it was syntactically valid
09:04:14 <rostayob> irene-knapp: so higher ranked types are supported in newtypes
09:04:17 <irene-knapp> yeah, it's syntax fine
09:04:24 <monochrom> I don't recommend using type synonyms to begin with.
09:04:25 <elliott> this typeclass looks somewhat... overcomplicated :P
09:04:27 <irene-knapp> that would be great because then I can use newtype deriving
09:04:27 <rostayob> it'd be really strange otherwise
09:04:27 <rostayob> irene-knapp: 7.0.2
09:04:28 <rostayob> irene-knapp: note that
09:04:36 <rostayob> newtype Foo = forall a. Foo a
09:04:39 <rostayob> it's an existential
09:04:46 <rostayob> but it's an entirely different matter
09:04:58 <irene-knapp> hmm
09:05:49 <irene-knapp> elliott: it's a little complicated, but it's motivated by the context
09:05:51 <rostayob> irene-knapp: it would be clearer if it was data Foo = exists a. Foo a :)
09:05:58 <irene-knapp> rostayob: yes wouldn't it
09:06:22 <rostayob> irene-knapp: i wonder why they didn't do it that way, it can't be that much of an effort to add that anyways
09:06:28 <elliott> it's not exists a. Foo a
09:06:30 <irene-knapp> no idea
09:06:31 <elliott> it's Foo (exists a. a)
09:06:38 <rostayob> elliott: yes, right
09:06:52 <elliott> i think it is an effort. at least, UHC has exists, and I think it's "weird" somehow
09:06:55 <elliott> but I don't really know
09:07:03 <mm_freak> in fact, i think the generalizations of caleskell are unfortunate
09:07:06 <rostayob> and maybe we could also write stuff like [exists a. a]
09:07:07 <monochrom> they don't want to reserve another word. by a trick of logic, they managed to reuse "forall".
09:07:17 <mm_freak> (.) shouldn't be fmap, it should be (Cateogry..)
09:07:18 <shachaf> Apparently "exists" is very incompatible with the way GHC does typechecking.
09:07:49 <aristid> mm_freak: why?
09:07:52 <elliott> mm_freak: agreed
09:07:58 <irene-knapp> right so
09:08:04 <elliott> aristid: because Category's (.) is more general
09:08:06 <rostayob> mm_freak: and Applicative m => Monad m, etc. etc.
09:08:13 <elliott> and (.) as fmap is hard to read
09:08:20 <elliott> map can be fmap, though :)
09:08:21 <irene-knapp> not clear on how I can use your trick of putting the forall near the variable though
09:08:22 <ion> I like how “forall” is used for everything. We should change “do” and ”\” to “forall” as well.
09:08:25 <monochrom> @quote monochrom freedom
09:08:25 <lambdabot> monochrom says: in fact, freedom is the freedom to write 2.2 = 4
09:08:27 <monochrom> :)
09:08:27 <irene-knapp> because I need it in two places
09:08:27 <aristid> elliott: more general? not all functors are categories
09:08:42 <elliott> :t (id .)
09:08:43 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
09:08:47 <elliott> :t (id Control.Category..)
09:08:48 <lambdabot> forall b a. (a -> b) -> a -> b
09:08:51 <elliott> oops
09:08:54 <elliott> :t (Control.Category.id Control.Category..)
09:08:55 <mm_freak> aristid: for one thing, i have to import Prelude hiding ((.), id) for most of my applications
09:08:55 <lambdabot> forall (cat :: * -> * -> *) b a. (Control.Category.Category cat) => cat a b -> cat a b
09:08:58 <rostayob> irene-knapp: Foo = Foo (forall a. a) means something different from Foo = forall a. Foo a
09:09:00 <irene-knapp> I need it in the context and I also need it in the actual type
09:09:01 <elliott> one more polymorphism! :)
09:09:05 <elliott> that's a bad example actually
09:09:07 <irene-knapp> yes, I just figured out how it's different
09:09:08 <monochrom> ion++ :)
09:09:09 <elliott> :t (Control.Category.. Control.Category.id)
09:09:10 <lambdabot> forall (cat :: * -> * -> *) c a. (Control.Category.Category cat) => cat a c -> cat a c
09:09:11 <mm_freak> aristid: for the other, we already have an infix fmap called <$>
09:09:11 <elliott> :t (. id)
09:09:12 <lambdabot> forall a b. (a -> b) -> a -> b
09:09:13 <irene-knapp> and it's different in the way that I need it not to be :(
09:09:14 <elliott> that's better
09:09:16 <aristid> mm_freak: but that's the fully specific (.) from haskell :)
09:09:36 <aristid> mm_freak: ok, the point regarding (<$>) is fair
09:09:37 <rostayob> irene-knapp: i'm not sure i follow you, but i didn't read your paste
09:09:38 <elliott> aristid: (.) is useful for composing lenses
09:09:42 <elliott> and arrows
09:09:47 <elliott> (.) as fmap destroys that
09:09:51 <irene-knapp> oh, yeah, you've gotta read the paste to see what I'm trying to do
09:09:58 <elliott> also, having the type constructor be differen for both arguments of (.) is just weirdly unsymmetrical
09:09:59 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
09:10:03 <elliott> lambdabot: I HATE YOU
09:10:14 <mm_freak> exactly…  (.) = fmap would destroy most of the things you actually use (.) for
09:10:20 <mm_freak> except function composition
09:10:31 <mm_freak> and the funny succ . [1,2,3] syntax
09:10:34 <ion> > (text . map pred) "fmmjpuu;!J!IBUF!ZPV!UPP"
09:10:36 <lambdabot>   elliott: I HATE YOU TOO
09:10:43 <sipa> > succ . [1,2,3]
09:10:45 <lambdabot>   [2,3,4]
09:10:50 <elliott> !J!IBUF!ZPV!UPP yourself.
09:11:06 <mauke> preflex: calc 36'elli.ott
09:11:07 <preflex>  681174.6896647805
09:11:20 <monochrom> actually, could use "\" for "forall" instead. f :: (\r . a -> r) -> Int
09:11:26 <Veinor> monochrom: haha
09:11:30 <ion> monochrom: :-)
09:11:50 <nand`> ah, that shrb guy left already
09:12:05 <nand`> just started python challenge myself (didn't know it existed), here's how I solved that slower and slower problem: link n = fmap (last.words) (getPage (url n)) >>= \n -> print n >> link n
09:12:23 <nand`> could be prettier with do notation but I did it within ghci so whatever
09:12:27 <irene-knapp> rostayob: I mean there's actually a specific error message which says "A newtype constructor cannot have an existential context"
09:12:40 <irene-knapp> plus a ticket saying "please allow newtype constructors to have existential contexts"
09:12:42 <monochrom> oh, the python challenge. I did a bunch of those, many years ago
09:12:46 <irene-knapp> this is the basis of my claim that it's not supported :)
09:12:47 <monochrom> (in haskell, too)
09:12:58 <rostayob> irene-knapp: yes, GHC doesn't support existentials in newtypes
09:13:01 <elliott> mauke: wat
09:13:01 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:13:03 <irene-knapp> yes, indeed
09:13:06 <elliott> oh
09:13:08 <elliott> lambdabot: aaSADGHSDFOPJDFGOFGJDFLG
09:13:36 <rostayob> irene-knapp: but Foo = Foo (forall a. a) is not an existential. the 'a' in there actually means "this can be any type", if it was an existential it would be different
09:13:42 <mauke> preflex: calc '36 31780886321.89723
09:13:43 <preflex>  elliott.wat
09:13:48 <elliott> irene-knapp: what you want isn't an existential
09:13:51 <elliott> oh rostayob already said
09:14:16 <irene-knapp> elliott: I'm pretty convinced it is, in fact.  I want it in both the context and the actual right-hand-side.
09:14:20 <mm_freak> pass :: (Functor f) => (a -> f b) -> (a -> f a)
09:14:24 <mm_freak> pass f x = x <$ f x
09:14:27 <mm_freak> such a useful function
09:14:54 <elliott> irene-knapp: if you have
09:15:00 <elliott> data Foo = Foo (forall a. ...)
09:15:02 <elliott> and are happy
09:15:04 <elliott> then you do not have an existential
09:15:06 <irene-knapp> no
09:15:08 <irene-knapp> I don't
09:15:12 <elliott> hmm
09:15:14 <elliott> what do you have then? :P
09:15:27 <irene-knapp> newtype ContextualSerialization context a =
09:15:27 <irene-knapp>   forall backend
09:15:27 <irene-knapp>   .  MonadSerialWriter BackendSpecificSerialization backend
09:15:27 <irene-knapp>   => ContextualSerialization
09:15:27 <irene-knapp>        (BackendSpecificSerialization backend context a)
09:15:40 <irene-knapp> see?  the backend appears in the context and also in the rhs
09:15:48 <elliott> ok
09:15:48 <irene-knapp> I believe that makes it a genuine existential, doesn't it?
09:15:48 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
09:15:56 <elliott> I hate you, lambdabot.
09:15:58 <ion> :-D
09:16:00 <monochrom> you have to change "newtype" to "data" for that. for GHC's sake
09:16:08 <irene-knapp> yeah, I realize that :)
09:16:15 <irene-knapp> the problem is that then I can't figure out how to write my instances :)
09:16:20 <ion> I’m tempted to @tell elliott something, but i resist.
09:16:23 <monochrom> afterwards, it's an existential type
09:16:29 <elliott> ion: You'll go on the Bad People List.
09:16:41 <shachaf> But if you had something that was working with "type", there's no reason it shouldn't work with newtype, is there?
09:16:52 <elliott> what shachaf said
09:16:57 <kejoki> @tell kejoki example
09:16:57 <lambdabot> You can tell yourself!
09:16:57 <elliott> just put the constructor around the whole RHS of the "type"
09:17:05 <irene-knapp> shachaf: oh hmmmm!
09:17:07 <elliott> if you have
09:17:19 <elliott> type contextSerualization context a = forall backend. MonadSerialWriter BackendSpecificSerialization backend => BackendSpecificSerialization backend context a
09:17:22 <Veinor> are there any common haskell string-y types other than String, ByteString, and Data.Text ?
09:17:23 <elliott> *ContextSerialization
09:17:27 <elliott> then you _don't_ have an existential
09:17:31 <elliott> and it's probably not going to do what you want
09:17:38 <koeien> Veinor: utf8-string
09:17:39 <elliott> Veinor: GHC's weird fast string thing?
09:17:47 <elliott> koeien: those aren't types
09:17:47 <shachaf> Veinor: ByteString isn't String-y!
09:17:51 <irene-knapp> elliott: yes hmmmmmmmmmmm
09:17:54 <koeien> ByteString is not really a string tho
09:17:54 <mm_freak> Veinor: Seq Char can be useful at times
09:17:55 <elliott> oh
09:17:56 <shachaf> byorgey: If ByteString is string-y, then [Word8].
09:17:59 <elliott> http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-String-UTF8.html yeah ok
09:18:01 <shachaf> s/byorgey/Veinor/
09:18:08 <monochrom> oh? if you newtypify "type X = forall y. blah", then it is newtype X = X (forall y. blah). the forall is inside, not outside
09:18:30 <rostayob> yeah
09:18:36 <mm_freak> Seq Char is the only unicode-aware string type i know that has O(1) 'last'
09:18:39 <rostayob> also, you can't have an existential in a type
09:18:43 <rostayob> no question about that
09:18:52 <rostayob> the only context in which you can have an existential is in 'data'
09:18:57 <rostayob> so if "it worked with type"
09:18:57 <elliott> mm_freak: erm, Text?
09:19:00 <shachaf> mm_freak: Why doesn't Text have an O(1) last?
09:19:08 <mm_freak> elliott: Text has O(n)
09:19:14 <elliott> ...huh?
09:19:14 <mm_freak> shachaf: because of the encoding
09:19:18 <elliott> yes, so?
09:19:19 <monochrom> or if you dataify that, it is still data X = X (forall y. blah), the forall is still inside
09:19:21 <maurer> Hey, I need -XDefaultSignatures for my package, but hackage does not recognize it
09:19:23 <elliott> you can start at the end and scan back to see if there's a surrogate
09:19:28 <elliott> scan back one character
09:19:29 <Veinor> Data.Text has O(1) last
09:19:30 <maurer> Was it deprecated in favor of something else?
09:19:33 <elliott> *one encoding unit thing
09:19:34 <elliott> = O(1)
09:19:34 <maurer> What am I supposed to do?
09:19:34 <Veinor> O(1) Returns the last character of a Text, which must be non-empty. Subject to fusion.
09:19:38 <irene-knapp> okay, so I think elliott's idea is going to work
09:19:42 <mm_freak> elliott: Seq Char is faster there
09:19:48 <mm_freak> according to my benchmarks
09:19:50 <irene-knapp> once I add the wrapper constructors/dissectors everywhere they're needed
09:19:57 <elliott> mm_freak: "Seq is faster" =/= "Seq is O(1), Text is O(n)"
09:19:57 <mm_freak> at least for the application i have used it for
09:20:14 <mm_freak> elliott: but Text has O(n) 'last'
09:20:18 <elliott> <Veinor> O(1) Returns the last character of a Text, which must be non-empty. Subject to fusion.
09:20:18 <Veinor> mm_freak: no it doesn't
09:20:20 <elliott> no it doesn't
09:20:35 <elliott> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/src/Data-Text.html#last
09:20:41 <Veinor> head, tail, init, last are all O(1)
09:20:42 <elliott> not a single loop in sight
09:21:01 <mm_freak> huh?  last time i checked it was O(n)
09:21:04 <Saizan> Veinor is talking about strict Text i guess
09:21:05 <koeien> you can detect in UTF16 whether a byte is part of a surrogate pair
09:21:17 <elliott> oh
09:21:25 <elliott> well yes the lazy types will always be O(n) in something :P
09:21:28 <Saizan> there's a lazy variant too, iirc
09:21:34 <koeien>  yup
09:21:35 <elliott> that's kind of the point
09:21:36 <elliott> but!
09:21:38 <elliott> Seq is strict
09:21:40 <Veinor> head, tail, init, last are all O(1) even in Lazy
09:21:41 <elliott> comparing it to lazy Text is nonsense
09:21:59 <elliott> Veinor: nah, documentation error: http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/src/Data-Text-Lazy.html#last
09:22:03 <mm_freak> ah, forget it…  it was indexing, not 'last'
09:22:20 <Veinor> ah
09:22:28 <koeien> yes, indexing requires decoding
09:22:31 <mm_freak> in any case, Seq turned out to be faster in my particular application
09:22:33 <elliott> indexing is rare :)
09:22:52 <monochrom> "python is strict. comparing it to Haskell is nonsense" has never stopped any comparison
09:22:54 <mm_freak> depends
09:22:55 <Veinor> anyway
09:22:59 <Veinor> the reason i asked about text types
09:23:10 <Veinor> is because i wanted to write a post about what text type you should use and how to convert between them
09:23:24 <Saizan> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/src/Data-Text-Lazy.html#last <- doesn't look O(1) to me
09:23:25 <elliott> I'd second the "ByteString isn't a text type" then
09:23:32 <elliott> Saizan: <elliott> Veinor: nah, documentation error: http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/src/Data-Text-Lazy.html#last
09:23:33 <elliott> :p
09:23:45 <Veinor> yeah, but enough things use ByteString that knowing how to convert from/to them is useful
09:24:02 <mm_freak> elliott: i had a lot of indexing going on when building a markov model for text
09:24:04 <Veinor> but yeah my advice for when to use ByteString is going to be 'don't'
09:24:10 <mm_freak> Text was too slow
09:25:12 <shachaf> Veinor: There are plenty of valid uses of ByteString.
09:25:25 <Veinor> such as?
09:25:26 <ion> ByteStrings are convenient with FFI and char arrays. And as an alternative to [Word8].
09:25:36 <shachaf> Veinor: The word is "encode" (or "decode"), not "convert".
09:26:04 <Veinor> shachaf: my point is that tail on a unicode bytestring will not do what you want
09:26:21 <monochrom> well, I am of the opinion that "convert" is vague to begin with, doesn't hurt to include encode and decode
09:26:32 <shachaf> Veinor: There's no such thing as "a unicode bytestring". :-)
09:26:37 <shachaf> Veinor: I didn't say those uses were text, anyway.
09:26:39 <monochrom> notice that "convert Int to String" is also an encoding
09:26:42 <Veinor> you get what i mean anyway
09:26:44 <Veinor> :P
09:26:53 <Veinor> ByteString could be useful for 'a string of bytes', yeah
09:26:55 <XexonixXexillion> I've never actually used Data.Text... How well does it go with very, large amounts of text (as in a few hundred thousand words)?
09:27:03 <shachaf> monochrom: As is "convert IO String to String"?
09:27:05 <shachaf> (Or to IO.)
09:27:20 <monochrom> no
09:27:42 <elliott> XexonixXexillion: 500,000 words? So... about 6 megabytes (in UTF-16)?
09:27:45 <koeien> XexonixXexillion: it uses the same techniques as Data.ByteString afaik
09:27:50 <elliott> That's a weird definition of very large.
09:28:13 <elliott> convetByteStringToText = T.pack . show . B.unpack
09:28:41 <ion> elliott: I use an Amiga 500 with 0.5 megabytes of chip RAM and 0.5 megabytes of fast RAM, you insensitive clod!
09:28:44 <Veinor> isn't it just Data.Text.Encoding.decodeAsWhatever
09:29:20 <elliott> ion: and you process strings of a few hundred thousand words with ByteStrings? :P
09:29:33 <elliott> Veinor: My function produces a Text like "[42,104,255,...]".
09:29:37 <elliott> Which is conversion :)
09:29:52 <Veinor> ah
09:30:28 <ion> (Oh, another use for ByteStrings: you can mmap a file and wrap that in a ByteString.)
09:30:33 <elliott> ion: same for Text
09:30:40 <elliott> i guess you need a UTF-16 file though
09:30:54 <rostayob> why is Text UTF-16 again?
09:31:24 <monochrom> heuristically decided
09:31:41 <monochrom> and to a large extent experimental
09:31:46 <rostayob> no i remember that someone tried to make it UTF-8
09:32:01 <monochrom> yes, another heuristic experiment
09:32:39 <elliott> it didn't end up being much faster in most cases and things like ICU use UTF-16
09:32:43 <elliott> (i.e. text-icu benefits)
09:33:56 <rostayob> yeah but i'd imagine the performance gain would be the fact that you wouldn't have to convert the huge amount of UTF-8 documents out there
09:34:03 <elliott> yes, that was the original assumption
09:34:09 <elliott> then it was actually done, and measured, and imagination lost :)
09:34:24 <rostayob> shit. but but they told me that imagination
09:34:54 <monochrom> depends on how often you convert and how often you internal-process
09:35:33 <elliott> yeah, i think it's outweighed by the fact that you generally only do conversion once in a pipeline
09:35:34 <ChristianS> i use bytestrings with the utf8-package and that's much faster (factor 2-3) than converting everything to Text and back
09:35:47 <elliott> so if you're doing anything performance-sensitive, encoding/decoding probably won't be that large a part of it
09:35:51 <ChristianS> utf8-string package*
09:36:04 <elliott> ChristianS: I wish it at least used a newtype.
09:36:06 <ion> It would be nice if there was just one variable-width Unicode encoding, UTF-8. But no, we need to have UTF-16, too. With various endiannesses, of course. :-P
09:36:17 <elliott> encouraging people to do unicode text operations directly on ByteStrings is completely evil
09:36:18 <erus`> is it safe to eat food after a lady bug walked all over it?
09:36:51 <ChristianS> elliott: why? it works if you know what you're doing
09:36:52 <ion> erus: Depends. Does the ladybug have AIDS?
09:37:10 <rostayob> ChristianS: i often hear that when talking about C++
09:37:18 <monochrom> if your internal-process is even just "change to upper case", you already have to decode utf-8 to something, and later encode back to utf-8 again. keeping it as utf-8 internally doesn't help you change to upper case.
09:37:36 <elliott> ChristianS: so does assembly
09:37:40 <elliott> ha rostayob beat me to it
09:37:50 <rostayob> elliott: again! yo
09:37:51 <elliott> this is haskell, types are supposed to mean something
09:37:56 <erus`> http://imgur.com/a9HIo in b4 im joking
09:38:06 <erus`> i know you cant eat after flys been on it
09:38:21 <elliott> erus`: I don't *quite* see the relevance of this to Haskell.
09:38:26 <elliott> I guess ladybug-walking could be monadic.
09:38:29 <rostayob> elliott: haskell-blah
09:38:34 <erus`> sorry you guys are smart and this isnt an emergency
09:38:42 <XexonixXexillion> it depends on the type of the ladybug
09:38:48 <ion> I’m sorry you guys are smart, too.
09:39:04 <monochrom> does the ladybug use utf-8 or utf-16?
09:39:08 <elliott> everyone: pls get dumber so i can be more prominent
09:39:21 <elliott> drag you down to their level, beat you with experience, etc.
09:39:40 <monochrom> oh, #haskell, yeah. does the ladybug use haskell? :)
09:40:02 <shergill> erus`: it's unhygienic if a fly has been on it, but you can safely eat it unless you really have a compromised immune system
09:40:03 <ion> Control.Monad.Trans.Ladybug.runLadybugT
09:40:19 <erus`> monochrom: haskell? in the real world?
09:40:21 <elliott> So, for instance, if a ladybug has walked over erus`'s immune system...
09:40:35 <erus`> im throwing it
09:40:35 <prof7bit> still trying to understand monads: http://hpaste.org/56803 what is happening after line 8 (or after line 11 or 13)? Were exactly is the mechanism hidden that combines these one-element lists into a 3-element list?
09:40:48 <XexonixXexillion> erus` >>= antibodies
09:41:06 <elliott> prof7bit: it's the list monad
09:41:09 <shergill> elliott: a buggy immune system is always a problem
09:41:09 <elliott> it, uh
09:41:13 <elliott> i'll let someone else explain :)
09:41:18 <elliott> shergill: >_<
09:41:24 <monochrom> >>= is the mechanism that combines stuff
09:41:37 <shergill> heh
09:41:56 <monochrom> xs >>= f  is concatMap f xs
09:42:13 <monochrom> concatMap f xs is concat (map f xs)
09:43:10 <prof7bit> where can i see the source code for the implementation of >>= for lists?
09:43:15 <elliott> concat is foldr (++) []. map f is foldr ((:) . f) []. wait, am I helping?
09:43:20 <elliott> prof7bit: @src [] (>>=)
09:43:22 <elliott> @src [] (>>=)
09:43:22 <lambdabot> xs >>= f     = concatMap f xs
09:43:23 <monochrom> you will rehearse what happens to concat (map (\x -> [x*2]) [1,2,3])
09:43:25 <elliott> @src concatMap
09:43:25 <lambdabot> concatMap f = foldr ((++) . f) []
09:43:27 <elliott> ugh
09:43:31 <elliott> concatMap f = concat . map f
09:43:40 <monochrom> usually, the Haskell Report has it
09:45:35 <rostayob> prof7bit: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/GHC-Base.html#Monad
09:45:55 <Veinor> XexonixXexillion: itym antibody >>= antigen
09:45:57 <elliott> rostayob: that doesn't let you get to the implementation of (>>=) for []
09:46:00 <elliott> well
09:46:02 <monochrom> I wouldn't cite that. usually it contains highly optimized unlearnable code
09:46:06 <elliott> i guess you can click [] and click source and hope for the best
09:46:33 <rostayob> elliott: yes it does
09:46:41 <rostayob> search for "instance Monad []"
09:47:10 <rostayob> monochrom: mah, not really... i mean yeah there is some noise...
09:47:32 <elliott> rostayob: yeah, but that does not work in general
09:47:40 <elliott> for instance, you have to be psychic to know whether to
09:47:43 <elliott> (a) look at the source for the typeclass
09:47:44 <monochrom> and sometimes it contains implementational details that will change and you should not rely on. such as how nub is done
09:47:47 <elliott> (b) look at the source for the type
09:47:53 <elliott> (c) look for an orphan instance god-knows-where
09:47:57 <prof7bit> i'm still struggling with the *general* idea of monads and wonder whether looking at this conctete list example would help me or introduce even more confusion. At least i have already an *idea* what a list is and what things like map and fold and lift and others do in the context of lists. But I have no idea whether this will help me build a general understanding of the general concept o distract me
09:48:04 <rostayob> elliott: I got good at that kind of thing
09:48:14 <elliott> prof7bit: it's probably best not to worry at all about understanding the general concept
09:48:24 <elliott> sufficient use of a wide range of specific examples will generally impart that understanding over time
09:48:28 <monochrom> you shall look at a million examples before going general
09:48:33 <XexonixXexillion> prof7bit: A monad is like an acid trip. You'll understand it once you've done it
09:49:09 <aristid> XexonixXexillion: wait, that almost makes sense. monad analogies must traditionally be totally ridiculous.
09:49:10 <rostayob> monochrom: I personally owe a lot to cabal "view source" links
09:49:21 <aristid> XexonixXexillion: like this: "a monad is like a burrito"
09:49:41 <elliott> aristid: but they are! http://blog.plover.com/prog/burritos.html
09:50:06 <monochrom> for poorly explained libs yes. for well-explained libs like what the Haskell Report specifies no
09:50:09 <shergill> does anyone know of any reference material similar to typeclassopedia?
09:50:10 <prof7bit> elliott: i have experimented with a simple happstack example and then i wanted to use putStrLn to log requets to the console and then I needed to mess around with liftIO. I have no idea how i could use things like these without understanding what I'm actually doing.
09:50:42 <elliott> prof7bit: understanding monads won't help that
09:50:52 <geekosaur> (that burrito is from taco bell, filled with artificial flavors and sawdust instead of the real thing?)
09:50:53 <erus`> @djynn m a -> (a -> m b) -> m b
09:50:53 <lambdabot> -- f cannot be realized.
09:51:01 <elliott> that's (a) monad-transformer-related classes from transformers/mtl (b) standard library
09:51:08 <rostayob> shergill: "Programming with arrows" for arrows, "bautyful concurrency" for STM
09:51:09 <erus`> @hoogle (>>=)
09:51:09 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:51:09 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:51:09 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:51:13 <aristid> elliott: uh.
09:52:28 <elliott> prof7bit: reading the Typeclassopedia might help
09:52:30 <elliott> prof7bit: http://www.haskell.org/haskellwiki/Typeclassopedia
09:52:48 <monochrom> probably knowing types helps more than knowing monads.
09:52:56 <rostayob> monochrom: sadly, there are a lot of poorly explained libs
09:52:59 <XexonixXexillion> To be honest, I think people might understand monads better if they were explained in terms of join and fmap, as opposed to >>=
09:53:30 <elliott> XexonixXexillion: that works iff you already have a strong grounding in Applicatives
09:53:46 <rostayob> XexonixXexillion: join is pretty useless, >>= is used all the time
09:53:51 <elliott> because you already understand how computations are formed, etc., and join just lets you do dynamic computation structures
09:54:04 <elliott> I'm not sure starting out with monads and using return/fmap/join would help
09:54:04 <monochrom> putStrLn "x" :: IO (). that clearly does not fit into the "BlahBlah a" context. IO is not BlahBlah.
09:54:10 <elliott> rostayob: join isn't useless at all
09:54:16 <elliott> join on (->) is incredibly useful, for instance
09:54:35 <monochrom> but you have liftIO :: IO a -> m a, where m could be BlahBlah, now that may help
09:54:47 <monochrom> you can get this far by just being type-aware
09:54:49 <rostayob> elliott: ok. >>= is used a lot more then join
09:55:18 <monochrom> and type-awareness is equivalent to logic-awareness. no more no less.
09:55:22 <elliott> rostayob: fair enough :P
09:56:05 <rostayob> also, you meant on (a ->), right?
09:56:24 <XexonixXexillion> rostayob: x >>= f === join (fmap f x)
09:56:32 <rostayob> XexonixXexillion: sure
09:56:43 <elliott> rostayob: ((->) r), technically.
09:56:44 <roconnor> @pl \x -> (x,())
09:56:44 <lambdabot> flip (,) ()
09:56:53 <elliott> (,())
09:56:55 <rostayob> elliott: yeah, the reader
09:56:55 <elliott> with TupleSections
09:57:23 <roconnor> for libraries I don't like adding unecessary language features
09:58:03 <XexonixXexillion> rostayob: I suppose I just have a bias, because I tend to define my monads in terms of join
09:58:14 <Veinor> i don't think i've ever used (>>=) for ((->) r)
09:58:30 <rostayob> Veinor: you did, wrapped in a newtype
09:58:34 <Veinor> ?
09:58:41 <nand`> Veinor: he means Reader
09:58:45 <Veinor> ah
09:58:52 <nand`> Reader is a newtype for ((->) r) with a monad instance
09:59:03 <rostayob> yes, that
09:59:33 <elliott> (>>=) for (->) is kinda useless
09:59:33 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
09:59:37 <elliott> oh for...
09:59:51 <rostayob> elliott: you've got mail
09:59:53 <nand`> elliott: You have 1 new message.
10:00:09 <nand`> Type /server inbox to read it :rolleyes:
10:00:20 <elliott> /msg nand` @messages
10:00:29 <Veinor> @msg elliott elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
10:00:29 <lambdabot> Not enough privileges
10:00:32 <Veinor> dammit!
10:01:04 <Veinor> oh
10:01:10 <Veinor> @tell elliott You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:10 <lambdabot> Consider it noted.
10:01:18 <elliott> @messages?
10:01:18 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:22 <elliott> @messagse
10:01:23 <lambdabot> Maybe you meant: messages messages?
10:01:24 <elliott> @messages
10:01:24 <lambdabot> Veinor said 13s ago: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:29 <elliott> @messages
10:01:29 <lambdabot> You don't have any new messages.
10:05:29 <rostayob> mm_freak: any luck?
10:11:05 <BMeph> I should Tweet this: "Understanding what you're doing is different from understanding how it's done."
10:11:25 <mike-burns> This isn't #siri.
10:11:29 <RomyRomy> hi haskellers…  i'm a Ruby girl and I wonder if anyone can help convert my Ruby code to Haskell?
10:11:49 <RomyRomy> "puts ["wow "].map{ |e| e * 10 }.to_s.upcase + "FLURRIES."
10:11:59 <cheater_> furies?
10:12:05 <mike-burns> Is that Ruby 1.8 or 1.9?
10:12:12 <Veinor> RomyRomy: what's that do?
10:12:14 <monochrom> I don't know ruby.
10:12:16 <RomyRomy> that is Ruby 1.9
10:12:43 <RomyRomy> it just started snowing in new york city and i was so shocked and thrilled i made a twitter post in Ruby about the snow
10:12:44 <RomyRomy> https://twitter.com/#!/RomyOnRuby/status/160798208786825216
10:13:05 <mike-burns> :t iterate
10:13:06 <lambdabot> forall a. (a -> a) -> a -> [a]
10:13:18 <elliott> > map toUpper (replicate 10 "wow ") ++ "FLURRIES."
10:13:19 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:13:19 <lambdabot>         against inferred type...
10:13:28 <elliott> > map toUpper (concat (replicate 10 "wow ")) ++ "FLURRIES."
10:13:30 <lambdabot>   "WOW WOW WOW WOW WOW WOW WOW WOW WOW WOW FLURRIES."
10:13:32 <mike-burns> Yeah, that's it.
10:13:35 <osfameron> ah!
10:13:37 <RomyRomy> (beams)
10:13:45 <RomyRomy> thank you elliott !!!!
10:13:48 <osfameron> what's the map for?
10:13:52 <elliott> to uppercase it
10:14:03 <mike-burns> I can never remember the word "replicate".
10:14:12 <RomyRomy> map takes individual elements inane array and applies an action to each one
10:14:24 <elliott> I'm surprised (\n -> concat . replicate n) doesn't have a name.
10:14:38 <elliott> @hoogle Int -> [a] -> [a]
10:14:39 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:14:39 <lambdabot> Data.List drop :: Int -> [a] -> [a]
10:14:39 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:14:47 <mike-burns> You didn't need the map, RomyRomy .
10:14:50 <mike-burns> "wow " * 10
10:15:05 <osfameron> ah, it takes every element of ["wow "]... ie. "wow "
10:15:12 <elliott> You didn't need anything but a string literal! puts "WOW WOW WOW WOW WOW WOW WOW WOW WOW WOW FLURRIES."
10:15:19 <elliott> RomyRomy: Oh, you probably want putStrLn $ at the front of that.
10:15:25 <elliott> And main = in front of that, if you want a complete program.
10:15:44 <RomyRomy> elliott:  really?
10:15:49 <shachaf> And main :: IO (); in front of that, if you want a program that compiles with ghc -Wall
10:15:58 <cmccann> and GHC, if you want to compile anything
10:16:03 <cmccann> also a computer
10:16:04 <monochrom> or hugs
10:16:05 <mike-burns> And a computer, if you want to run it.
10:16:06 <mike-burns> Ah.
10:16:10 <RomyRomy> are you guys talking about the Haskell code or the Ruby code?
10:16:14 <mike-burns> Haskell.
10:16:15 <cmccann> monochrom, now you're just being silly
10:16:17 <monochrom> don't forget electricity
10:16:30 <elliott> main = putStrLn $ map toUpper (concat (replicate 10 "wow ")) ++ "FLURRIES."
10:16:40 <elliott> I guess main = putStrLn $ (map toUpper . concat . replicate 10) "wow " ++ "FLURRIES." is nicer
10:16:42 <mike-burns> That Ruby runs fine, though you'd want a shebang line to run it.
10:16:50 <monochrom> also, most computers won't work below a certain temperature and above a certain other temperature
10:16:57 <elliott> or in a vacuum
10:16:58 <RomyRomy> mike-burns: the ruby comes out looking awkward too though, unfortunately
10:17:00 <elliott> bring your own atmosphere
10:17:14 <RomyRomy> mike-burns: i meant MY ruby code
10:17:18 <elliott> I think puts ( "wow " * 10).upcase + "FLURRIES." would work for the Ruby.
10:17:20 <elliott> like mike-burns said
10:17:28 <elliott> s/\( /(/
10:17:39 <monochrom> but I still like hugs
10:17:51 * osfameron hugs monochrom 
10:17:55 <cmccann> haha
10:18:03 <monochrom> hehe
10:18:42 <monochrom> hugs is my answer to "can I defer type errors to run time"
10:18:52 <mike-burns> In Ruby: puts ((["WOW"] * 10) + "FLURRIES.").join(' ')
10:18:56 <mike-burns> That's how I'd write it, at least.
10:18:58 <Veinor> hugs are nice :D
10:18:59 <mike-burns> OK back to Haskell.
10:19:05 <RomyRomy> elliott:  oh yes, but i was craving strongly to use the code bloc { |x| } thing
10:19:24 <Veinor> also, you need matter in order to have a computer
10:19:36 <Veinor> elliott: computers run fine in vacuum! just not for long
10:19:47 <elliott> > map toUpper . unwords $ replicate 10 "wow" ++ ["FLURRIES."]
10:19:49 <lambdabot>   "WOW WOW WOW WOW WOW WOW WOW WOW WOW WOW FLURRIES."
10:19:51 <mmos1127> I'm getting an exception on Prelude.read. Can I use the GHCI debugger to find the module/line-number?
10:19:52 <mike-burns> Ruby programs are too slow to complete in a vaccuum.
10:19:53 <elliott> \o/
10:19:59 <elliott> Not the same program any more, though.
10:20:08 <elliott> Veinor: mike-burns beat me to it :(
10:20:23 <elliott> mmos1127: try compiling with profiling and run with +RTS -xc
10:20:30 <elliott> you'll get a (really ugly) cost centre stack trace
10:20:41 <shachaf> @where rts-xc
10:20:41 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
10:21:17 <monochrom> I don't know how you can memorize the keyword "rts-xc"
10:21:21 <mmos1127> elliot: thanks. Will it be obvious in the trace where the exception occurred?
10:21:31 <RomyRomy> Ruby was the first programming language I taught myself, after I realized Haskell was a bit 'ambitious' for a n00b.  I plan to learn Haskell eventually though, it's so theoretically pure.  a pure, pure functional language, and that is alluring.
10:21:36 <elliott> mmos1127: Yes, it'll be the last element.
10:21:39 <RomyRomy> thank you all!
10:22:01 * cmccann would rather just avoid functions that can cause exceptions
10:22:10 <elliott> Yeah, like half the Prelude.
10:22:31 <mike-burns> RomyRomy: I know people who learned Haskell as their first language. No need to give up so quickly!
10:22:47 <cmccann> elliott, which is why I have an AltPrelude module I use in my personal code that replaces most of those
10:23:09 <RomyRomy> mike-burns: I come from a background as a graphic designer / front end developer, no math skills here, no previous experience with computer science
10:23:23 <koeien> RomyRomy: excellent, you're not corrupted :)
10:23:25 * monochrom avoids allowing functions to cause exceptions instead. i.e., if I use read or head etc, I know they work fine in that context
10:23:27 <elliott> cmccann: So does lambdabot!
10:23:52 <elliott> Caleskell and Cmccannskell should merge efforts.
10:24:05 <shachaf> elliott: lambdabot's technique is to make success so confusing that it's indistinguishable from an error.
10:24:06 <cmccann> I don't think they have the same goals
10:24:16 <mmos1127> elliot: it tells me I haven't installed the profiling libraries for parsec-3.1.1  . Is it worth doing that? I could always debug it in the hack way by commenting out portions of my code and narrowing down the location
10:24:37 <elliott> mmos1127: Yes, it's worth doing that.
10:24:44 <RomyRomy> koeien: i had never 'programmed' before until last summer my eyes opened to the world of 'functional programming' versus 'imperative' programming.  the idea of being able to express an idea in a fraction of the lines required by imperative, and the expression itself being a mathematical 'statement' of sorts, was rather exotic and alien to behold by myself, a visual designer.
10:24:44 <mmos1127> I'm also using Sound.PortMidi
10:24:48 <elliott> mmos1127: Set library-profiling to True in ~/.cabal/config and cabal install --reinstall world.
10:24:56 * monochrom does not understand writing 1000 lines of code and then "give it a spin" and then try to troubleshoot. why not test and correct each 10-line fragment first
10:24:57 <elliott> It might take a while, but you always want the profiling libraries sooner or later.
10:25:04 <RomyRomy> so i ventured out to learn pure functional programming.  i bought the LYAH book, and didn't get past the first few chapters.
10:25:15 <elliott> mmos1127: I would recommend trying smaller parts in GHCi rather than commenting out,t hough.
10:25:32 <RomyRomy> I decided to take up Ruby as a 'middle' stepping stone, as Ruby can take on functional expressions of sorts.
10:25:34 <mmos1127> elliot: is "world" literal -- does that mean reinstall every current installed library
10:25:37 <RomyRomy> and then… i fell in love with...
10:25:39 <RomyRomy> SCHEME!!!!!!
10:25:49 <elliott> mmos1127: Yes :)
10:25:49 <koeien> ah yes, scheme is also nice
10:25:51 <RomyRomy> from the Structure and Interpretation of Computer programs~!!!!!!
10:26:01 <elliott> mmos1127: You could also s/world/parsec and whatever other dependencies you have/.
10:26:04 <RomyRomy> I stayed up LATE into the night defining my own small functions recursively!
10:26:20 <RomyRomy> i felt my life was changing, lol!  i had that 'transcendental' experience that some people have when learning Lisp!
10:26:25 <mike-burns> I appreciate some enthusiasm in here.
10:26:39 <RomyRomy> mike-burns: unfortunately i have copious amounts of it.  good and bad.
10:27:01 <mike-burns> RomyRomy: You can use functional techniques in your Ruby.
10:28:05 <RomyRomy> mike-burns: oh yes, i did…. and strangely, my elementary Ruby codes are at times 'influenced' by Scheme also!
10:28:40 <RomyRomy> not surprising, since Yukihiro Matsumoto was inspired by Lisp when he wrote Ruby!  (though one cannot really compare the two, that would be doing either a disservice)
10:29:09 <mike-burns> He was also inspired by Smalltalk, which was intented to hide side effects (among other things).
10:30:41 <RomyRomy> yes
10:31:29 <Ptival> RomyRomy: I can understand the joy of reading SICP :)
10:32:24 <RomyRomy> Ptival: Oh yes.  It got me through the sadness of my past fall.  The videos also.  Beautiful, beautiful.  It was life changing for me, actually.
10:32:57 <Ngevd> Hello
10:33:24 * cmccann enjoyed scheme quite a bit
10:34:21 <elliott> > sin (/) pi
10:34:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:34:22 <lambdabot>    arising from a use of `...
10:34:28 <elliott> > sin (/) pi cos
10:34:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:34:29 <lambdabot>    arising from a use of `...
10:34:31 <elliott> > sin (/) pi cos 42
10:34:32 <lambdabot>   -0.9999999584271058
10:34:38 <mmos1127> elliot: I did "cabal install --reintall parsec-3.1.1" and when I run ghc with profiling, I'm getting the same error: "can't find Text.Parsec.String; perhaps not installed profiling libraries for parsec-3.1.1"
10:34:57 <elliott> mmos1127: did you set library-profiling to True in ~/.cabal/config?
10:34:59 <elliott> (and uncommented that line)
10:35:27 <ChristianS> since somebody mentioned Seq Char to represent strings: how would a read a file into a Seq Char, or decode a bytestring into a Seq Char (and vice versa)?
10:35:42 <mmos1127> elliot: I did-- but I'm on windows, so I found config in /documents and settings/Mike/cabal -- did I change the wrong "config"?
10:36:20 <shachaf> did++
10:36:25 <monochrom> it's the right config
10:36:49 <elliott> mmos1127: yeah, that's right
10:36:53 <elliott> mmos1127: i suspect the reinstall failed
10:36:53 <monochrom> but it's just difficult to remotely troubleshoot a computer setup
10:36:59 <mmos1127> what about "--executable-profiling"?
10:37:12 <monochrom> executable-profiling is unneeded for this
10:37:12 <elliott> don't need that
10:37:21 <elliott> anyway, run the reinstall again, check that it doesn't print any errors
10:37:26 <elliott> usually it'll say ExitFailure 1 at the end if it's failed
10:37:41 <mmos1127> elliot: I didn't get any error after the cabal install .. last thing it said was "registering parsec-3.1.1"
10:38:06 <cmccann> RomyRomy, for what it's worth if you enjoyed scheme and the more functional-flavored aspects of ruby I doubt you'll have too much trouble learning haskell as well
10:38:08 <mmos1127> I know this is hard to debug remotely
10:38:39 <elliott> mmos1127: well...
10:38:41 <elliott> ghc-pkg list, hpaste that?
10:38:48 <mmos1127> should cabal install indicate a message to the effect that it's compiling with profiling?
10:38:49 <elliott> oh hmm
10:38:52 <elliott> do you use cabal-dev or something?
10:38:53 <cmccann> mmos1127, did you see it build twice?
10:38:55 <elliott> mmos1127: it should compile everything twice
10:39:21 <cmccann> enabling profiling pretty clearly shows both versions being built, yeah
10:39:45 <cmccann> also, you could try putting some bogus in the cabal config file and see if it complains, to be sure you've got the right location
10:40:01 <mmos1127> elliot: didn't compile twice, at least I don't think so
10:40:51 <mmos1127> I put junk in the config and it did in fact complain
10:41:00 <elliott> mmos1127: hpaste the config file
10:41:02 <elliott> sans junk
10:41:17 <Ngevd> Which way does Graphics.Gloss.Data.Picture rotate rotate?
10:41:34 <Ngevd> Clockwise or anticlockwise?
10:41:40 <nand`> test it?
10:41:48 <monochrom> I don't know. I would be anticlockwise first. and then test.
10:41:48 <hpaste_> mmos1127 pasted “config” at http://hpaste.org/56805
10:41:53 <monochrom> s/be/bet/
10:42:02 <elliott> heh, i would guess clockwise
10:42:10 <elliott> mmos1127: -- library-profiling: True
10:42:14 <elliott> mmos1127: i said you had to uncomment it :)
10:42:16 <elliott> remove the "-- "
10:42:48 <monochrom> parsec depends on mtl. you will have to rebuild mtl too
10:43:09 <mmos1127> elliot: oops, sorry
10:43:23 <elliott> monochrom: mmos1127 will discover that when the parsec build fails :)
10:43:32 <elliott> human dependency resolver
10:43:36 <kniu> so uh, guys
10:43:37 <Ngevd> Clockwise
10:43:41 <monochrom> I don't trust humans
10:44:41 <elliott> kniu: hi
10:44:52 <mmos1127> progress! I have to profile a few more libraries, will report back in a moment
10:45:05 <yitz> ChristianS: you'd have to go via a list of Char, i.e. String, and use Data.Seq.fromList.
10:45:24 <monochrom> this is why I have stopped suggesting -xc. look at how many hours have passed
10:45:30 <kniu> how do you feel about Rust and Dart using syntax like
10:45:39 <kniu> fn foo(n: int) -> int {...}
10:45:46 <kniu> just wondering
10:45:50 <yitz> ChristianS: so for a bytestring use fromList . unpack.
10:45:54 <kniu> because that arrow seems really out of place for me
10:45:54 <elliott> monochrom: mmos1127 will thank us when they need to debug a performance problem in the future :P
10:46:01 <monochrom> by this time, one has already mastered all the tricks and secrets of the ghci debugger
10:46:04 <elliott> library-profiling should really default to on
10:46:13 <elliott> the Platform's libs all have profiling it hink
10:46:15 <kniu> but almost nobody else agrees with me
10:46:15 <elliott> *i think
10:46:26 <ChristianS> yitz: thanks, but that sounds pretty dreadful. might just as well use [Char] if you need it is an interim step anyway...
10:46:49 <elliott> ChristianS: huh? the reason to use Seq is that all the operations on it are different to lists
10:47:03 <elliott> if bytestring didn't have its own IO stuff you'd have to go via Strings too, that wouldn't make it useless :)
10:47:11 <yitz> ChristianS: could be. it depends on your further processing needs, though.
10:47:41 <parcs`> kniu: that is alright with me. foo is a function that takes an int and returns an int
10:47:44 <yitz> ChristianS: if you're going to be doing things pretty much linearly, then bytestring is a big win, and forget about Seq Char.
10:47:55 <mmos1127> elliot: "cabal install --reinstall world" gave me the error it couldn't find "world" -- did I misundertand?
10:47:59 <parcs`> foo(n: int, m: int) -> int is a function that takes a tuple (int, int) and returns an int
10:48:17 <koeien> and binds n, m presumably
10:48:29 <yitz> ChristianS: but if you need to read it all in and then do a lot of random access to the chars, Seq Char could be worth it.
10:48:33 <kniu> just wondering, parcs`
10:48:35 <monochrom> parsec is in the platform. if someone's parsec doesn't have profiling, that someone does not use the platform.
10:48:47 <kniu> are you much of a "Haskell guy"?
10:48:49 <kejoki> kniu: what are the objections?
10:48:53 <kniu> well
10:48:57 <parcs`> kniu: i'm in this channel aren't i
10:49:06 <kniu> the main one is that (->) is supposed to be the function type constructor
10:49:09 <elliott> yitz: if you're doing things linearly, [String] might even be the best choice :)
10:49:12 <ChristianS> yitz: ok, you're right there (guess that use case is pretty rare for me, but YMMV)
10:49:19 <monochrom> in fact the anti-platform people are in the majority here
10:49:22 <elliott> mmos1127: hmm. I may have been lied to!
10:49:28 <kniu> whereas here they're kind of using it as another form of type annotation
10:49:29 <kejoki> um ...
10:49:29 <elliott> or maybe it only works in sufficiently new cabal-instals
10:49:36 <Sgeo> anti-platform?
10:49:46 <RomyRomy> cmccann: i was a bit doubtful of my mind's ability to grasp higher order programming, but if there is an ounce of truth to what you say, then i just may very well explore my LYAH book more in depth in the coming days.  What a breath of fresh air it would be.
10:49:53 <mmos1127> I'm doing it library by library but I'm not getting dependcies in the right order so I'm getting a lot of ExitFailure
10:50:03 <kniu> I mean, if I had designed it, defining a function would look more like
10:50:04 <elliott> mmos1127: anyway you can just copy your cabal config file somewhere else, and nuke your equivalents of ~/.cabal and ~/.ghc
10:50:07 <elliott> then cabal update
10:50:09 <elliott> copy the config file back
10:50:12 <yitz> elliott: yeah good ol' String with lazy IO still works great for some things. and when it does, it's the simplest.
10:50:12 <elliott> and reinstall what you need
10:50:12 <kniu> let foo(n: int): int {...}
10:50:37 <parcs`> kniu: this is a non-issue, really
10:50:40 <kejoki> kniu: shades of Pascal!  :)
10:51:22 <kniu> parcs`, you're not bothered at all?
10:51:52 <coeus> am i wrong here? is this the c++ vs pascal channel?
10:52:02 <monochrom> yes!
10:52:09 <prof7bit> Paskell
10:52:23 <kejoki> kniu: why worry about what bothers the unwashed rabble?
10:52:24 <monochrom> C++aleskell
10:53:00 <parcs`> kniu: no. what -> means is haskell is inconsequential to what -> means in rust
10:53:04 <parcs`> in*
10:53:14 <elliott> kniu: this is more of a -blah topic i think
10:53:21 <kniu> okay
10:53:30 <yitz> monochrom: someone is anti-platform?
10:53:52 <yitz> (before we even get to a majority)
10:53:56 <monochrom> I have grown to dislike the notation f(x) for function application (and therefore for function definition syntax). what would you write for curried functions, f(x)(y)(z)?
10:53:58 <kniu> but parcs`, Rust *also* uses -> in the same way Haskell does, elsewhere.
10:54:21 <cmccann> RomyRomy, getting used to the type system will still be a hurdle, but the rest shouldn't be too bad
10:54:29 <Ngevd> Hello
10:54:39 <parcs`> are you also bothered that c has no lambdas?
10:54:41 <byorgey> hi Ngevd
10:54:47 <cmccann> RomyRomy, at least that was my experience, approaching haskell already knowing scheme and python (and a bit of ruby)
10:54:58 <kniu> parcs`, that has nothing to do with this
10:55:38 <elliott> neither does haskell
10:55:46 <monochrom> yitz, try to pretend to be a beginner and ask "how do I install haskell on linux" some time. you will get a lot of "skip the platform, just get ghc and cabal-install and cabal install the rest as you go"
10:56:00 <kniu> okay fine
10:56:02 <elliott> monochrom: do you pretend to be a beginner often? :)
10:56:16 <monochrom> no, but I watch a lot of answers often
10:56:17 <coeus> whow, this channel is awesome! i'm an old haskell programmer but i just learned something
10:56:24 <elliott> personally i think the platform is worthwhile on windows
10:56:28 <elliott> but basically pointless on linux
10:56:35 <monochrom> see?
10:56:35 <elliott> worthwhile on os x too
10:56:44 <coeus> some guys invented "rust".
10:56:49 <monochrom> instant evidence!
10:56:51 * byorgey doesn't think the platform is pointless on linux
10:56:53 <elliott> monochrom: that was me expressing my opinion explicitly because you brought it up :P
10:56:58 * cmccann wonders if the simplest answer to "how do I install haskell on windows" starts with "install linux"
10:57:15 <byorgey> install all the platform packages in your global package DB, then don't touch them.
10:57:20 <yitz> monochrom: well, the just get ghc part is pretty much required on linux whether you are using the platform or not, until the distros get better at the platform
10:57:21 <elliott> cmccann: simplest for the answerer, definitely
10:57:28 <ericch> Hi, I'm completely new to haskell and learning with Programming with Haskell. I have a beginner question when using the interactive mode with GHCi: why does "round (sqrt 36)" work, but if I write "let a = 36", and then "round (sqrt a)" I get an error?
10:57:33 <monochrom> I do sometimes suggest "install virtualbox on windows. inside, install linux..."
10:57:54 <elliott> the platform would be more useful on linux if it was a cabal package that just depended on all the libs and exported nothing
10:57:56 <elliott> IMO
10:57:59 <byorgey> ericch: because when you write  let a = 36, it doesn't know what type you want for a, so it defaults to Integer
10:58:04 <kniu> using just ghc and cabal would be fine if somebody would just let cabal uninstall packages
10:58:19 <byorgey> ericch: but sqrt can only be called on floating point arguments (like Double)
10:58:23 <geekosaur> ericch, it's the monomorphism restriction.  names without parameters get their types "fixed" immediately, and the default is Integer
10:58:31 <byorgey> geekosaur: it's not the MR.
10:58:36 <byorgey> just defaulting.
10:58:50 <byorgey> oh, sorry, I guess it is
10:59:09 <koeien> nah it's the MR
10:59:12 * byorgey should think a few seconds more before typing
10:59:13 <ericch> Could I do something like "let a = 36 :: Float"?
10:59:14 <yitz> kniu: the problem is that cabal allows compiling packages with ffi, and then there is no way for it to know on its own how to uninstall them.
10:59:17 <koeien> ericch: yes
10:59:18 <byorgey> ericch: yes.
10:59:18 <elliott> endojelly: yes
10:59:20 <elliott> ...
10:59:22 <elliott> god dammit
10:59:23 <byorgey> hehehe
10:59:26 <ericch> Thanks
10:59:37 <koeien> (Double has more precision though)
10:59:49 <yitz> kniu: it would be nice if it would keep track of which packages it does know how to uninstall, and then let you uninstall them.
11:00:04 <cmccann> defaulting applies whenever something is required to be monomorphic but is otherwise ambiguous, which is often but not always because of the MR
11:00:15 <cmccann> > show (1 + 1)
11:00:16 <lambdabot>   "2"
11:00:22 <cmccann> that's plain defaulting in action
11:00:42 <kniu> I kind of find it much better to leave -XNoMonomorphismRestriction on at all times
11:00:50 <kejoki> > t: (1 + 1)
11:00:50 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
11:00:51 <lambdabot>    arising from the lite...
11:01:03 <kniu> :t (1 + 1)
11:01:03 <stulli> it seems that at least on archlinux the platform is not very liked. i'm waiting for a update since november or so and nobody else seems to be bothered
11:01:04 <lambdabot> forall t. (Num t) => t
11:01:21 <kejoki> oops
11:01:31 <elliott> stulli: they're waiting on 7.4 i think
11:01:34 <elliott> before updating any haskell stuff
11:01:34 <coeus> isn't there a better alternative to the platform for linux? and some uninstaller? anything that is up to date? i'm still using cabal-install and bash scripts to remove packages.
11:01:36 <yitz> in ghci at least, -XMonomorphismRestriction should always be on. it probably will be by default in ghc 7.6
11:01:38 <elliott> at least 7.2 was in testing and then went away
11:01:51 <elliott> coeus: the best way to uninstall cabal packages is rm -r ~/.cabal ~/.ghc
11:02:00 <elliott> cabal-dev is the refined expression of this idea :)
11:02:02 <monochrom> you missed a "No" there :)
11:02:09 <kejoki> I installed the platform on the kids' vista box and it hasn't been too bad
11:02:13 <kniu> oh and also
11:02:20 <kniu> I wish cabal would allow me to update packages too
11:02:26 <cmccann> I still want -XPolymorphismRestriction to forbid monomorphic bindings :T
11:02:35 <elliott> -XDuomorphismRestriction
11:02:45 <elliott> you must have exactly one quantifier
11:02:45 <yitz> coeus: i use the platform and cabal-dev. then i don't need any bash scripts to remove packages, a simple rm does the trick.
11:03:00 <elliott> kniu: it does
11:03:13 <elliott> cabal upgrade, then read the message :)
11:03:13 <c_wraith> hmm.  oleg on combining iteratees and regions...  clearly a response to conduits.
11:03:17 <stulli> elliott: last time i checked haskell-platform was orphaned: http://www.archlinux.org/packages/extra/x86_64/haskell-platform/
11:03:21 <monochrom> cabal-install updates packages too often, in fact
11:03:32 <elliott> c_wraith: ooh, got a link?
11:03:45 <elliott> stulli: oh, well maybe, i was just guessing :)
11:03:47 <c_wraith> elliott: it's on -cafe.  don't have a link handy, but check the archives
11:03:50 <kniu> huh
11:03:56 <c_wraith> elliott: posted 9 hours ago
11:04:11 <monochrom> I'll find you a link
11:04:13 <stulli> i'd step in if i only had any clue about packaging. well, for now i can live with it as it is.
11:04:15 <kniu> I remember getting something like "WE WON'T LET YOU DO THIS" the last time I tried a cabal upgrade
11:04:23 <coeus> @elliott: for explicit package removal, i use my bash script. that does practically the same.
11:04:23 <lambdabot> Unknown command, try @list
11:04:26 <yitz> c_wraith: not just a response to conduits. oleg was involved in the design discussions for conduits.
11:04:31 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg96562.html
11:04:31 <shergill> what do people here generally use to uninstall packages installed by cabal-install?
11:04:34 <mmos1127> I'm getting compilation errors trying to install musicxml.. "can't match expected type 'QName' against inferred type 'String' -- do I have my dependcies wrong? any ideas?
11:04:41 <elliott> coeus: you don't want to ping people with @ in here :)
11:04:52 <elliott> coeus: anyway, cabal-dev is probably the best solution
11:04:52 <mmos1127> elliot: I did what you suggested, moving config and running cabal update
11:04:53 <c_wraith> yitz: interesting. I clearly did not know that
11:04:57 <mmos1127> then copying config back
11:05:02 <monochrom> you can use the @ notation. put it at the end.
11:05:09 <elliott> mmos1127: you have to remove .cabal and .ghc first
11:05:13 <coeus> ok, just found the cabal-dev package. thx elliott.
11:05:13 <mich> hello
11:05:14 <elliott> i guess ghc will be wherever cabal was
11:05:19 <elliott> not ghc itself
11:05:26 <elliott> but the ghc directory, in the same place as the cabal one
11:05:32 <mmos1127> oh you know what I didn't do .ghc -- I'll have to look for that
11:05:34 <elliott> the "cabal update" is to get the cabal directory back so you can put the config file back there
11:05:38 <elliott> yeah
11:06:10 <mmos1127> there's a ghc directory where cabal is, but no .ghc in it..
11:06:19 <coeus> i'm new to irc, what do you write instead of @ + personname?
11:06:20 <mmos1127> there's a ghci_history
11:06:44 <elliott> coeus: "nick:" or "nick,"
11:06:49 <byorgey> coeus: like this
11:06:54 <elliott> coeus: bonus: you can tab-complete like that
11:07:01 <mich> i was reading this : http://patternsinfp.wordpress.com/2012/01/19/comprehensions/ and was trying to implement the simple for comprehension: but it doesnt seem to work? [2 * a + b | a <- [1,2,3], b <- [4,5,6], b mod a == 0 ]
11:07:02 <elliott> e.g. coe<tab> --> "coeus: " in most clients
11:07:04 <mmos1127> do I move the ghc directory?
11:07:14 <elliott> mmos1127: the ghc directory where cabal is -- remove that
11:07:17 <mmos1127> I notice it has all the package config files
11:07:32 <elliott> mmos1127: yeah, this is an "uninstall everything" solution :)
11:07:49 <elliott> but you get most packages back just by installing anything in my experience, thanks to dependencies
11:07:55 <monochrom> on windows it is called "ghc" not ".ghc". similarly for ".cabal"
11:07:58 <coeus> nick:coeus test
11:08:02 <elliott> mich: b `mod` a
11:08:09 <elliott> mich: (equivalent to (mod b a))
11:08:13 <coeus> coeus: test
11:08:16 <elliott> you're trying to call b with the function mod as a parameter :)
11:08:16 <mich> elliott: thx!
11:08:22 <monochrom> if you see things like "i386-mingw32-6.12.3" that's the right directory
11:08:23 <coeus> hmpf.
11:08:32 <elliott> you have xchat so it should work
11:08:36 <elliott> try completing someone else's nick
11:08:38 <elliott> e.g. ellio<tab>
11:08:53 <coeus> elliott, ah, thx.
11:09:25 * monochrom changes that to a dollar sign
11:09:32 <monochrom> elliott$ like this? :)
11:09:58 * elliott changes his nick completion suffix
11:10:03 <elliott> monochrom!!! YES, INDEED
11:10:14 <monochrom> ooohhhh, !!! is so cute
11:10:15 <elliott> coeus!!! as you can see tab completion is really great!!!
11:11:08 <coeus> elliott, yeah. thx.
11:11:10 * monochrom is tired of both colon and comma for that
11:11:19 <coeus> i'll install cabal-dev and try that out.
11:11:45 <elliott> monochrom: a lot of clients don't annoy the user if you don't use : or , i think
11:11:50 <elliott> which is unacceptable
11:12:03 <Razz> I'm following the exercises in Typeclassopedia and I'm a bit stuck on ex.3 for the monads: the free monad built from functor f, the case for Var is easy enough but how does one implement fmap for Node?
11:12:13 <monochrom> no, I am not annoyed by the software notification
11:12:29 <elliott> Razz: hint: you know f is a functor, so you can use fmap on (f <anything>)
11:12:33 <elliott> Razz: and you need to recurse
11:13:22 <elliott> (think of fmap as lifting a function (a -> b) to (f a -> f b))
11:13:31 <Razz> elliott: I thought about that, but I'm a little uncertain about the pattern matching I now have fmap g (Node x)
11:13:34 <monochrom> I am annoyed by the infomercial style "monochrom, it really works great. monochrom, here are the cheques I received. monochrom, it is really easy. monochrom, this. monochrom, that."
11:13:52 <elliott> monochrom: kinda necessary in large enough channels
11:14:02 <byorgey> Razz: right, so what type is x?
11:14:03 <elliott> unless you pay attention to every thread of discussion
11:14:19 <monochrom> oh, sure. that is fine.
11:14:28 <kejoki> let Razz = "#@!$!!" ++ Razz
11:14:30 <Razz> byorgey: x would be (f (Free f a)
11:14:35 <byorgey> Razz: right.
11:14:54 <monochrom> but I know examples of 5 consecutive lines of "monochrom, " in the presence of absolutely no other thread
11:14:59 <elliott> Razz: if you have h :: (Free f a -> b), you can use (fmap h x) to get (f b)
11:15:09 <aristid> monochrom: who would do that
11:15:14 <aristid> monochrom: that would be ridiculous!
11:15:28 <elliott> monochrom: hi monochrom!
11:15:29 <monochrom> dogmatic people would do that, for example
11:15:33 <Razz> elliott: thx
11:15:52 <elliott> Razz: that helped?! that line confused _me_ :)
11:16:07 <Razz> elliott: well I'm still interpreting ;-)
11:17:14 <Razz> elliott: the 'concrete' type for fmap should be something like fmap :: (a -> b) -> (Free f) a -> (Free f) b for this functor right?
11:17:34 <yitz> monochrom: i'm afraid i'm guilty of that
11:17:37 <Peaker> I type "nick:" prefix first, as a habit.. not worrying about whether others throw some threads in there
11:17:46 <elliott> Razz: you have (fmap :: (a -> b) -> f a -> f b), and you're writing (fmap :: (a -> b) -> Free f a -> Free f b), yeah
11:17:59 <yitz> monochrom: it's just become a habit of my fingers to hit m<tab> or whatever
11:18:13 <Razz> elliott: ok, then I'm at least at the right type
11:18:17 <yitz> monochrom: it's like turning my head towards who i'm talking to
11:18:30 <yitz> i have to conciously not do it when i don't want it
11:19:14 <yitz> i admit it looks really weird in an empty chat room
11:19:35 <coeus> i'll stay in this channel, but atm i have to go to the grocery store, need some lenses and bananas.
11:19:40 <kejoki> yitz: if the chat room is empty who are you typing at?
11:19:54 <coeus> read you later.
11:20:07 <yitz> kejoki: ha. i meant empty except for me and who i'm talking to.
11:20:25 <yitz> kejoki: actually sometimes it turns out that the person you think you are talking to isn't even there.
11:20:43 <Ngevd> This is the largest room I've ever been to since I started IRCing a lot
11:21:07 <kejoki> #perl used to be pretty darn big.
11:21:19 <Ngevd> Never learnt perl
11:21:28 <yitz> kejoki: it isn't anymore?
11:21:38 <kejoki> yitz: :-)
11:21:56 <kejoki> yitz: I dunno, I haven't been in there in a while.
11:22:09 <elliott> #perl is smaller than this at least
11:22:13 <aristid> yitz: it's even funnier to do it in a query, where nobody else even CAN be
11:22:37 * kejoki has been more less a Tcl coder for a few years.
11:22:44 <elliott> ##linux, #git, #python, #jquery, #archlinux, #ubuntu, #debian, #freenode, #gentoo and here are the only channels with >800 users
11:23:21 <elliott> #gentoo, #debian, #ubuntu, #archlinux, #python and ##linux are the only larger channels
11:23:23 <yitz> kejoki: cool. do you work on macports?
11:24:11 <kejoki> yitz: Nope.  Interfaces, Protocols and Transformations (oh my!)
11:24:36 <yitz> kejoki: if you have a mac and know tcl, you should help out there.
11:25:09 <kejoki> no Mac, yitz -- can't afford it.
11:25:45 <mmos1127> I'm still getting errors on install of musicxml--- but I remember now! when I installed in a few months ago, I had to install an earlier version; there was a note on hackage saying the latest version was broken--however I can't find that note-- where do I look on hackage or whereever?
11:26:41 <parcs`> gentoo?
11:26:43 <elliott> http://hackage.haskell.org/package/musicxml?
11:27:01 <byorgey> mmos1127: an earlier version?  But the latest version is already 2.5 years old!
11:27:15 <mmos1127> I looked there, but can't find the information about which version isn't broken
11:27:26 <monochrom> there are only 3 versions. you can exhaustively try each one
11:27:29 <mmos1127> I just tried the previous version and same error
11:28:09 <mmos1127> okay trying previous previous version -- same error -- oh no, how did I do this before?  ???
11:28:12 <elliott> i wouldn't suggest using that package if it was last updated in 2009 and doesn't build on ghc 7 :P
11:28:26 <elliott> "cabal: cannot configure musicxml-0.1.2. It requires base ==3.*"
11:28:26 <yitz> mmos1127: hmm, just tried musicxml (using cabal-dev of course). it requires base==3.*, so won't work with any recent ghc. unless editing the cabal file works.
11:28:29 <elliott> you have to download it and edit the cabal file
11:28:36 <elliott> and "cabal install" in that directory
11:28:44 <byorgey> mmos1127: since musicxml doesn't specify version upper bounds on its dependencies, it's likely that since it was published several of its dependencies now have newer, incompatible versions
11:29:07 <yitz> don't cabal install, cabal-dev install, so you don't risk corrupting your package database.
11:29:09 <byorgey> mmos1127: so it might work to manually install older versions of some of its dependencies first
11:29:20 <byorgey> but I have no idea exactly which ones.
11:29:25 <mmos1127> okay how I do find its dependencies?
11:30:02 <yitz> mmos1127: look in the cabal file, or just look at its page on the hackage web site
11:30:14 <mmos1127> oh, I have another computer where it is current installed and working--I could check the versions of all libraries on that one -- how do I do that?
11:30:25 <mmos1127> like, how do I get a list of all packages with version numbers?
11:30:29 <yitz> mmos1127: ghc-pkg list
11:30:31 <elliott> there is no way that library is installed on that computer without modification
11:30:32 <elliott> or an ancient ghc
11:30:37 <elliott> no matter what version
11:30:40 <monochrom> ghc-pkg field musicxml depends
11:30:43 <mmos1127> it is an anceitn ghc
11:30:52 <elliott> right
11:30:54 <elliott> that's the problem
11:31:02 <elliott> the package is too old, it does not work on modern ghc, you'll have to edit the cabal file
11:31:15 <yitz> it may be more than just editing the cabal file
11:31:40 <mmos1127> what do I change when I edit the cabal file?
11:31:54 <elliott> probably lots of things
11:31:56 <KSkrzet> you can edit dependencies, mostly
11:32:00 <yitz> i really really recommend using cabal-dev in cases like this, unless you're not planning on using ghc for anything else on this computer, or unless you're in the mood for a re-install
11:32:05 <elliott> yitz: this is the reinstall
11:32:10 <elliott> try s/base == 3/base == 4/ and "cabal configure && cabal build"
11:32:22 <elliott> don't install anything until you verify it's working at least
11:32:30 <yitz> oh ok
11:33:43 <elliott> mmos1127: i would take this as an opportunity to stop using that package though
11:33:59 <monochrom> there is no replacement
11:34:16 <elliott> ok, take up maintainership of it then :P
11:34:57 <hpaste_> Tener pasted “musicxml fixed cabal file” at http://hpaste.org/56807
11:35:13 <mmos1127> elliot: I don't know what I'll do if I can't use it -- I'm a music student and I am using this pacakge together with some custom manipulation of MusicXML -- I don't have time to do anything else with it
11:35:25 <KSkrzet> mmos1127:  try the .cabal file I've pasted here: > Tener pasted musicxml fixed cabal file at http://hpaste.org/56807
11:35:32 <elliott> mmos1127: fair enough
11:35:50 <elliott> KSkrzet: yikes
11:35:53 <elliott> did you just remove all the bounds?
11:35:57 <KSkrzet> yep
11:35:58 <monochrom> heh
11:36:02 <elliott> :|
11:36:12 <KSkrzet> really, most of the time it just works
11:36:41 <KSkrzet> sad thing, this time it didn't... it just finished installing deps and failed
11:36:47 <elliott> karma!
11:36:48 <monochrom> no, only removed one bound. of base. all the other lack of bounds you see there, are in the original, too
11:36:49 <KSkrzet> so no, it won't work this time
11:37:33 <monochrom> although, I am suspicious of the presence of two "build-depends:" lines
11:38:07 <mmos1127> okay I looked on my other computer and it has an older version of text installed. I need to remove the later one from this computer-- is there something like "cabal uninstall"?
11:38:25 <monochrom> it is called "ghc-pkg unregister"
11:38:28 <elliott> erm
11:38:33 <KSkrzet> mmos1127: you don't have to actually
11:38:35 <elliott> yeah don't
11:38:48 <elliott> not only will it break other packages which want a newer text, it probably won't solve the musicxml problem
11:38:53 <elliott> you should _really_ just edit the cabal file :)
11:38:55 <KSkrzet> mmos1127: they will do fine with two versions or actually any number of them installed in parallel
11:39:12 <KSkrzet> I'm working on musicxml
11:39:12 <monochrom> musicxml does not directly depend on text
11:39:32 <KSkrzet> the problem is that it needs old HaXML which is incompatible with ghc7 because of prelude/haskell98 clash
11:39:33 <mmos1127> well I did "cabal install text-0.11.13" and still getting musicxml error -- okay on my other computer I have HaXml-1.20.2 which is older
11:39:34 <KSkrzet> working on it...
11:39:47 <mmos1127> I have an older version of ghc using base 3
11:39:49 <elliott> mmos1127: you're going to break everything again :)
11:39:55 <elliott> and have to remove it all again
11:40:02 <Apocalisp> pchiusano: how goes the datalog?
11:43:02 <KSkrzet> mmos1127: what is the precise version of GHC you have?
11:46:43 <mmos1127> KSkrzet: 6.12.3
11:47:22 <KSkrzet> mmos1127: ah, that makes things a bit different
11:47:47 <mmos1127> I'm making some progress by installing the same versions on my other computer where musicxml works
11:47:52 <hpaste_> “Tener (KSkrzet)” annotated “musicxml fixed cabal file” with “musicxml fixed cabal file (annotation)” at http://hpaste.org/56807#a56808
11:47:56 <KSkrzet> mmos1127: on 7.0.4 I got musicxml to built with this version of .cabal file (updated):
11:48:03 <KSkrzet> (see line above)
11:48:48 <KSkrzet> I'm trying to install with 6.12.3 now...
11:49:46 <mmos1127> KSrzet: thanks! one question: that cabal file doesn't look like my current one -- which doesn't have the "Name: , Version: " etc. am I supposed to copy all that stuff?
11:50:30 <elliott> it's to go in musicxml's directory
11:50:32 <elliott> not your project's.
11:50:46 <elliott> but it's probably not going to work if you're installing old versions of packages
11:51:55 <nand`> I installed the haskell platform a while back, what's the easiest way to update it?
11:51:55 <KSkrzet> mmos1127: this is .cabal file for musicxml. it works with 6.12.3 as well, just installed with it. it pulls required dependencies automatically. don't know about your project.
11:52:02 <mmos1127> well, I'm installing package by package mirroring my other computer and so far no errors -- haven't gotten to musicxml yet
11:52:25 <KSkrzet> mmos1127: it doesn't have to work unfortunately
11:52:26 <mmos1127> KSkrzet: now that I've installed a few packages manually will it still work to use your .cabal?
11:52:28 <elliott> nand`: what OS
11:52:30 <elliott> ?
11:52:34 <elliott> if Windows or OS X: just install the new one
11:52:44 <elliott> probably the same on Linux, but I don't know for sure
11:53:09 <nand`> elliott: windows 7; I thought there would be some sort of “cabal update” command which updates my GHC installation as well
11:53:21 <nand`> last time I ran the installer it cleared my Path
11:53:32 <nand`> I guess I'll back it up this time
11:53:43 <KSkrzet> mmos1127: you can run "cabal unpack musicxml", enter created directory musicxml-VERSION and replace the .cabal file there with the version I've pasted
11:53:43 <cheater_> oh man, windows
11:53:50 <cheater_> i tried using windows like a year back or so
11:53:57 <KSkrzet> mmos1127: from that point just "cabal install" while inside the directory
11:54:05 <cheater_> its lack of a package manager makes it impossible to use for anything at all
11:54:43 <elliott> nand`: you can upgrade with cabal, but that won't get you the new ghc or whatever
11:54:50 <nand`> oh
11:54:58 <KSkrzet> mmos1127: sorry I wasn't clear with that part from the beginning
11:55:03 <shergill> cheater_: also, lack of decent editor
11:55:05 <elliott> so i'd suggest using the installer
11:55:11 <nand`> I'm using 7.0.3, worth updating?
11:55:21 <elliott> i would recommend upgrading with the installer
11:55:32 <elliott> i don't think cabal based upgrades of the core platform packages are supported
11:55:34 <mmos1127> KSkret: I will try it now
11:56:11 <cheater_> shergill: also, yes
11:57:38 <yitz> shergill: it has vim and emacs. you might have trouble installing teco there though.
11:58:00 <shergill> yitz: emacs? under mingw?
11:58:02 <mmos1127> if I want to get a later version of cabal, what do I do?
11:58:19 <mmos1127> cabal install cabal-<something>?
11:58:19 <cheater_> emacs? reaaaally?
11:58:31 <monochrom> "cabal install cabal-install"
11:58:38 <monochrom> I use emacs just fine
11:58:44 <nand`> am I the only one who thinks the haskell platform would benefit from an automated updater
11:58:54 <elliott> nand`: no; you're free to contribute one :)
11:59:00 <monochrom> but actually I haven't used emacs on windows
11:59:01 <cheater_> i think it would benefit from a ubuntu ppa.
11:59:11 <yitz> shergill: it probably uses mingw or something, don't know. i just install it. takes a few seconds.
11:59:28 <nand`> elliott: I would if I knew anything about the haskell platform
11:59:34 <shergill> ah interesting. did not know
12:00:50 <monochrom> automatic destructive updater is problematic. automatic installer for peaceful co-existence with other versions is fine
12:01:04 <KSkrzet> I keep hearing about this Ubuntu and Windows things. Are they any better and more free than GNU Hurd I'm using?
12:01:18 <KSkrzet> (just kidding)
12:01:21 <monochrom> you... using Hurd?!
12:01:29 <yitz> monochrom: nice for the installer to have the *option* of removing older versions, like what mzero is doing for the mac.
12:01:34 <elliott> I had typed out "/ctcp" and was moving on to "KSkrzet version" when you said you're kidding.
12:02:20 <nand`> shergill: emacs is among the most ported non-trivial programs ever
12:02:26 <nand`> it runs on basically anything
12:02:48 <monochrom> you can't just remove the old version, if you're into removing. you have to also remove all packages that were built against the old version.
12:03:03 <shergill> nand`: sounds like the emacs philosophy, the 'everything' bit :P
12:03:32 <yitz> monochrom: right. well, the result of compiling the packages. the packages themselves can stay.
12:03:57 <yitz> monochrom: i think mzero's uninstaller may do that.
12:04:57 <mmos1127> yay! musicxml builds!
12:05:08 <monochrom> if it's acknowledged that destructive update incurs a much wider removal than just the platform's own files, I'm fine with the idea
12:06:16 <monochrom> but officially, platform versions tend to be tied to ghc versions to begin with
12:06:35 <yitz> monochrom: the default cabal config, and also mzero's modified one, orgainize things so that at least it is possible.
12:07:49 <nand`> oh wow
12:07:55 <nand`> installing haskell platform didn't nuke my path this time
12:09:15 <yitz> monochrom: on the mac, the platform install includes its own ghc. when you uninstall it, all the builds you did using that ghc should go. also the packages that came with the platform, of course.
12:09:41 <akosch> why is this a rank 2 type? > type RequestHandler = ToJSON a => Array -> IO a
12:09:48 <yitz> monochrom: on linux things haven't really settled down yet, the distros are still figuring things out
12:09:52 <shachaf> akosch: It's not.
12:10:06 <ski__> `a' is unbound
12:10:06 <shachaf> akosch: However, it implicitly quantifies "a".
12:10:18 <akosch> shachaf: GHC prompts me for the Rank2Types extension though
12:10:34 <shachaf> akosch: The way you're using it is probably rank-2.
12:10:42 <shachaf> akosch: Where are you expecting "a" to come from?
12:11:36 <akosch> shachaf: I'm using it the following way: handleRequest :: B.ByteString -> M.Map MethodName RequestHandler -> IO (B.ByteString)
12:11:57 <monochrom> "type RequestHandler a = ToJSON a => Array -> IO a" does not need any extension
12:12:11 <monochrom> "type RequestHandler = ToJSON a => Array -> IO a" is just weird, even if allowed
12:12:17 <elliott> i suspect akosch wants an existential in the return type
12:12:18 <yitz> akosch: if you just say f :: RequestHandler it's not rank 2. if you say f :: RequestHandler -> ... or data Foo = Foo RequestHandler then it is.
12:12:21 <elliott> and so really wants JSONObject or whatever it is called
12:12:34 <elliott> (the conversion to json can be handled by the lift* functions i suggested)
12:12:54 <akosch> yitz: thanks, I think I get it now
12:13:06 <monochrom> oh, oops, maybe the "=>" part needs an extension
12:13:44 <monochrom> don't use a type synonym for this
12:14:05 <akosch> I want handlers to be able to return anything they want, as long as I can create JSON from it
12:14:09 <elliott> right
12:14:15 <elliott> make it (Array -> IO Object) instead
12:14:21 <elliott> or... whatever aeson's object type is called, I forget
12:14:27 <elliott> the ToJSON should be handled by the lift* functions
12:14:39 <elliott> even with Rank2Types the type you have now won't do what you want
12:15:12 <akosch> elliott: hm, my mistake
12:16:45 <akosch> elliott: I still don't get why it won't work, seems logical to me :(
12:17:48 <elliott> akosch: if something has type
12:17:53 <prof7bit> sorry for interruption but i have a quick question: section 3.2 in http://www.haskell.org/haskellwiki/Typeclassopedia  in the excercises: "The composition of two Functors is also a Functor [...] if true, prove it by exhibiting some appropriate Haskell code" -- it was not explined up to this point how to formally "combine" two functors and how does one prove something as abstract as this with hasskell code?
12:17:53 <elliott> foo :: ToJSON a => Array -> IO a
12:17:58 <elliott> that means if you give foo an array
12:18:04 <elliott> you can use it as :: IO a for any a that is ToJSON
12:18:10 <elliott> so foo must be prepared to return a string, a list, a double, ...
12:18:27 <elliott> your confusion probably arises because blah :: ToJSON a => (Array -> IO a) -> ...
12:18:38 <DanBurton> why don't you just simplify the design by having it return an IO JSONObject?
12:18:38 <elliott> you want to represent the type of anything that can be an argument to blah -- which is an existential
12:18:39 <Axman6> prof7bit: the canonical example is map f . map g = map (f . g)
12:18:44 <elliott> DanBurton: that's what i suggested :)
12:18:53 <elliott> since every function is already being lifted in with a function, it can handle the ToJSON
12:19:01 <DanBurton> right
12:19:36 <Axman6> prof7bit: which should translate to Functor, and work for all functors: fmap f . fmap g = fmap (f . g)
12:20:03 <akosch> elliott: I see, so it's because the type variable a appears on the left side of ->, right?
12:20:24 <elliott> akosch: yeah
12:20:33 <DanBurton> it's the difference between "for all" and "there exists"
12:20:44 <akosch> elliott: great, thanks again! :)
12:20:54 <DanBurton> what you want is "there exists", but ToJSON a => Array IO a is a "for all"
12:21:23 <prof7bit> Axman6:  and how do i prove that this is actually true for all possible f and g?
12:21:35 <DanBurton> (^ just restating what elliott said in different terms)
12:21:53 <elliott> prof7bit: write the instance :)
12:22:02 <elliott> prof7bit: you can define functor composition as: newtype Comp f g a = Comp (f (g a))
12:22:33 <akosch> DanBurton: good explanation, I guess "there exists" doesn't make much sense here
12:23:55 <Axman6> prof7bit: f and g are not important, all you have to show is that if you say use fmap f (fmap g Nothing) and fmap (f . g) Nothing you get the same result, as well as for Just x. you can do the same thing for list
12:24:10 <elliott> Axman6: that's not what it's talking about
12:24:14 <elliott> that's the composition of two fmaps
12:24:20 <elliott> it's talking about the composition of two Functors
12:24:25 <elliott> i.e. f (g a)
12:24:37 <Axman6> hmm, ok
12:24:43 <elliott> it's asking for instance (Functor f, Functor g) => Functor (Comp f g)
12:24:52 <elliott> or (f `O` g), whatever cutesy name you want to give it :P
12:25:44 <erus`> has anyone designed a haskell syntax without so many un-needed constructs? like multiple function definitions when we have case
12:26:09 <elliott> yes. Church did
12:26:15 <hpaste_> nand pasted “Strip HTML tags” at http://hpaste.org/56809
12:26:16 <elliott> in the 30s.
12:26:27 <erus`> elliott thats untyped
12:26:40 <elliott> there are typed lambda calculi
12:26:42 <elliott> haskell is based on one
12:26:56 <elliott> http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus, http://en.wikipedia.org/wiki/Lambda_cube, etc.
12:27:09 <nand`> @hoogle Either a a -> a
12:27:09 <lambdabot> Data.Either rights :: [Either a b] -> [b]
12:27:09 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
12:27:09 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:27:12 <prof7bit> this is probably going to make my brain explode before i can write the first non-trivial program. How many years will it take?
12:27:42 <elliott> prof7bit: you're reading the typeclassopedia before writing a program?
12:27:42 <erus`> elliott is there something like lisp -> scheme   for haskel -> ?
12:27:56 <nand`> haskell -> x86 bytecode
12:27:57 <nand`> it's called GHC
12:28:08 <elliott> erus`: uh, liskell?
12:28:14 <elliott> that's just haskell with a lot of parens though
12:28:40 <elliott> erus`: Core doesn't have clauses, fwiw
12:28:42 <elliott> just case
12:28:54 <erus`> ah ok i will check out core
12:29:00 <prof7bit> elliott: i need to understand what i'm doing, so I need to start somewhere.
12:29:25 <Christopher> Are there any good examples of using UI frameworks from Haskelll?
12:29:47 <elliott> prof7bit: That somewhere would be better a Haskell tutorial :)
12:30:05 <elliott> The Typeclassopedia is mainly written for people who can already write programs in Haskell but want a more solid grip on the abstractions.
12:30:55 <tylermac1> prof7bit: Learn You a Haskell is great for beginners, I'm about halfway through it and have enjoyed every bit so far
12:31:08 <nand`> ^
12:31:14 <nand`> it's the best resource I know for beginners
12:31:19 <nand`> I enjoyed it thoroughly
12:31:26 <Ngevd> I'm most of the way through it
12:31:29 <Ngevd> It is good
12:31:40 <_Mikey> LYAH for life
12:31:50 <erus`> for great good
12:32:01 <tylermac1> I'm coming mainly from C++ so it has been a bit daunting at times.
12:32:03 <_Mikey> great good for life
12:32:05 <_Mikey> :)
12:32:09 <prof7bit> the typeclassopedia says: "anyone ignorant of the types in their code is doomed to eternal uncertainty. “Hmm, it doesn’t compile ... maybe I’ll stick in an fmap here ... nope, let’s see ... maybe I need another (.) somewhere? ... um ...” " and this sounds as if i have been there already while playng with some simple examples and trying to modify or expand them
12:32:21 <jamiltron1> LYAH is really good, but I wish it had exercises and more sample programs
12:32:27 <_Mikey> Are there any good examples of using UI frameworks from Haskell though?
12:32:35 <jamiltron1> I'm going through Real World Haskell
12:32:41 <jamiltron1> and really enjoy the exercises
12:32:55 <_Mikey> the exercises are good
12:32:57 <erus`> i remember when my first type error made sense :)
12:33:22 <_Mikey> :)
12:33:25 <_Mikey> good times
12:33:54 <erus`> i remember when monads REALLY kicked in. mind was blown
12:34:17 <nand`> I remember learning about the IO blackbox
12:34:20 <nand`> was disappointed
12:35:11 <_Mikey> they still haven't kicked in for me
12:39:15 <elliott> prof7bit: you'll have a much, much easier time of the typeclassopedia if you get the basics down first
12:39:21 <elliott> and get more out of it :)
12:40:49 <prof7bit> my reasoning was (after googling about monads) that the typeclassopedia seems to take the shortest possible path from Functor to Monad I thought It might help me finally completely understand Monads. It seems to me they are essential and all code snippets i have seen so far don't make any sense without understanding them.
12:41:44 <nand`> prof7bit: I recommend http://www.haskell.org/haskellwiki/Category_theory/Monads
12:41:47 <prof7bit> and the extremely complicated and counterintuitive type system
12:41:51 <nand`> and http://www.haskell.org/haskellwiki/Category_theory/Functor
12:41:58 <prof7bit> and the strange syntax to describe the types
12:42:18 <elliott> prof7bit: all code examples?
12:42:20 <elliott> you can't have seen many at all
12:42:23 <byorgey> prof7bit: that's certainly one of the goals of the typeclassopedia.
12:42:35 <elliott> i mean, it seems like you've started out not knowing much haskell at all
12:42:41 <elliott> and decided you absolutely have to learn monads to progress
12:42:45 <nand`> understand the theory behind it should remove the counterintuitiveness of the type system
12:42:46 <elliott> but that's not really the natural order at all
12:43:00 <elliott> it makes much more sense to get proficient writing simple haskell code before tackling that
12:44:13 <nand`> personally, the best way to understand monads is by accidentally writing (>>=)
12:44:58 <mike-burns> For me I understood the monad typeclass best by learning about typeclasses, learning other typeclasses, then realizing that Monad is a typeclass.
12:45:46 <monochrom> just treat >>= as an overloaded operator like +
12:45:58 <monochrom> there is no tutorial on "what is Num?"
12:46:02 <shergill> elliott: the problem is that for those who don't know haskell if they've heard anything about haskell, it's likely to be monads
12:46:28 <prof7bit> nand`: but this doesn't explain why in some of the do blocks i can use putStrLn and in some others not. and what exactly is going on with these other types of monads and how monad transformers work and wh and when i need them etc.
12:46:34 <shergill> and toot he fact that it's used in IO which is supposed to be one of the basic things in other programming languages
12:46:53 <nand`> prof7bit: do you know how “do” syntax works?
12:47:08 <monochrom> someone else observes that it is not so much monad as types
12:47:09 <mike-burns> prof7bit: That's the type system.
12:47:16 <mike-burns> Oh, I just did that!
12:47:31 <prof7bit> nand`: i believe i have a vague understanding of it and how it relates to the >>=
12:47:31 <byorgey> prof7bit: do you know what a type class is?
12:47:40 <nand`> prof7bit; do a; b; c is the same as writing a >> b >> c
12:47:42 <shergill> my initial mode when starting out with haskell was: oo what *are* these monads?? i want to know!. and then i was off shaving yak
12:47:49 <nand`> and do a <- b; c is the same as writing b >>= \a -> c
12:48:00 <nand`> :t (>>=)
12:48:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:48:02 <nand`> :t putStrLn
12:48:03 <lambdabot> String -> IO ()
12:48:22 <ski__> @undo do a <- b; c
12:48:22 <lambdabot> b >>= \ a -> c
12:48:35 <niteria> what's latest and greatest parser combinator library?
12:48:53 <yitz> niteria: that's a loaded question
12:48:54 <nand`> prof7bit: so you see putStrLn "something" has the type IO (); which is a monad; in this case, IO corresponds to “m” and () corresponds to “b” in the signature of >>=
12:49:02 <Axman6> nand`: it depends what you're parsing
12:49:02 <byorgey> niteria: try uu-parsinglib or trifecta
12:49:15 <niteria> or what's the best to learn first
12:49:26 <monochrom> I would say "IO is a monad", not "IO () is a monad"
12:49:32 <nand`> and since both m's have to be the same, you can only use >>= \_ -> putStrLn if the left hand side of >>= has the type “m a”, in this case “IO a”
12:49:42 <nand`> as such, you can only use putStrLn in a do block if the previous statement was also an IO monad
12:49:49 <aristid> niteria: parsec is easy to learn
12:49:52 <nand`> monochrom: oh yeah
12:49:54 <monochrom> especially since you're going to do "m = IO" not "m = IO ()"
12:50:32 <nand`> bad writing on my part there
12:50:36 <nand`> “applied monad”?
12:51:11 <monochrom> it is the difficult type part. people already know "plus :: a -> a -> a" polymorphic in a. they are surprised that you can also have "return :: m a" and be polymorphic in m
12:51:18 <ski__> `putStrLn "foo"' is a "monadic action"
12:51:27 <yitz> niteria: attoparsec is good for really fast parsing of text and bytestrings, if your parsers don't get too complicated.
12:52:45 <niteria> I want to play around with parser combinators
12:52:55 <hpaste_> nand annotated “Strip HTML tags” with “Strip HTML tags (annotation)” at http://hpaste.org/56809#a56810
12:53:47 <yitz> niteria: parsec is classic, and it comes with the platform so it's pretty ubiquitous
12:54:22 <nand`> so I read somewhere that if you can solve a problem over a sequence of data using both foldl and foldr, it's possible to rewrite it to be completely parallel
12:54:36 <nand`> eg. tree-based with an associative combinator
12:54:42 <aristid> uu parsinglib and trifecta are probably awesomer, but nobody knows how to use them :>
12:54:48 <Axman6> nand`: sounds reasonable
12:55:24 <yitz> the ReadP library is best for writing ReadS parsers due to GHC's built in support, but it doesn't sound like that is what niteria is looking for.
12:55:27 <niteria> Ok, I'll try parsec
12:56:38 <monochrom> the best way to play with parser combinators is to write your own based on an introductory paper on parser combinators
12:57:33 <kejoki> how about just a good introductory paper on combinators?
12:57:46 <monochrom> that loses the parser part big time
12:58:25 <kejoki> not for niteria...
12:58:48 <monochrom> S and K aren't very usable
12:59:04 * kejoki never even heard the word 'combinator' in college
12:59:14 <kejoki> it was grad level stuff at the time.
12:59:44 <OscarZ> monadic types always have to do with some other type..  like data Box a = Box a ?
12:59:44 <niteria> well, what's the introductory paper on parser combinators?
13:00:14 <monochrom> some textbooks have a chapter on that
13:00:52 <monochrom> also http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing
13:00:53 <OscarZ> I mean, types like data Foo = Bar | Baz can't be monads ?
13:01:10 <Axman6> OscarZ: things with kind * -> * can be monads
13:01:20 <monochrom> a monad type has to be a parameterized type, like data Box a = ...
13:01:38 <Axman6> Box has kind * -> *, because Box is a type constructor (you can have Box Int, Box String, Box Bool)
13:01:52 <monochrom> data Box a = Box will do fine. you don't have to "store" the parameter.
13:02:32 <nand`> For another example, “Either a b”. Either has kind * -> * -> *, so it can't be used as a monad. But something like “Either e” has kind * -> * since it already has one type parameter. Therefore, it can be a monad
13:02:47 <nand`> same with (->), which has the same kind as Either - but ((->) r) is a monad
13:02:57 <niteria> Denotational semantics: Gordon 1979 is a good monad tutorial :), without a word monad in it
13:03:25 <monochrom> yikes!
13:03:49 <nand`> monochrom: how will you implement (>>=) on your Box a?
13:04:04 <monochrom> _ >>= _ = Box
13:04:14 <nand`> oh, fair enough
13:04:25 <nand`> silly monad
13:04:27 <monochrom> verify that all the monad laws hold!
13:04:31 <OscarZ> right.. so as as list [a] is a monad, the monad part somehow captures the "listness" of the list type, without any knowledge of the stored type a ?
13:04:51 <OscarZ> it can take the elements out of the list ?
13:04:52 <nand`> monochrom: it's clearly associative and Box >>= return = Box
13:04:57 <monochrom> I don't know what that means, especially "without any knowledge of the stored type a"
13:05:09 <byorgey> OscarZ: it has nothing to do with "storing" anything.
13:05:11 <nand`> I keep forgetting the third law
13:05:15 <byorgey> OscarZ: [] is a monad.
13:05:25 <nand`> oh left identity
13:05:35 <byorgey> which means that there are certain operations  return :: a -> [a]  and (>>=) :: [a] -> (a -> [b]) -> [b]
13:05:52 <monochrom> also I am not sure whether monad captures the listness of [] or captures the non-listness of []
13:05:54 <byorgey> which work uniformly for all types a and b.
13:06:07 <monochrom> I guess it depends on what is "listness"
13:06:14 <nand`> return x >>= f == f x; since f by signature must produce a m b and the only possible value of m b is a Box, this holds
13:06:16 <byorgey> Monoid captures the listness of [].
13:06:25 <byorgey> lists being free monoids.
13:06:35 <OscarZ> hmm ok..
13:06:52 <nand`> personally I think the join version of monads are easier to understand
13:07:28 <monochrom> perhaps the definition is "listness of [] means the monadic aspect of []". survival of the fittest, may the best man win, etc.
13:07:47 <nand`> a monad is a functor which has two additional operations  return :: a -> m a  that just “wraps” the monad into minimal context, and  (join) :: m (m a) -> m a  which “unwraps” two nested monads
13:08:01 <monochrom> (how do you know what is fit? how do you know who is best?)
13:09:04 <danharaj_> what is the current conversation about?
13:09:23 <nand`> danharaj: 1. explaining monads to OscarZ and 2. arguing about what “listness” means
13:09:42 <kejoki> and how does it all apply to writing control systems for fly-by-wire micro-surgical tools?
13:10:00 <OscarZ> if its not necessary to "store anything", how can you define return as its type is a -> m a ?
13:10:16 <monochrom> anyway, seeing that [] and Maybe and IO and State and Cont and ... are all so disparate and yet their overlap is monad, I'm inclined to say monad captures the non-listness aspect
13:10:22 <sipa> OscarZ: in the case of a list, by returning [a]
13:10:26 <byorgey> OscarZ: it depends on m.
13:10:30 <sipa> (the singleton list)
13:10:43 <sipa> in the case of Maybe, Just a
13:10:57 <byorgey> OscarZ: for monochrom's example, earlier,  data Box a = Box, you would have   return a = Box
13:11:11 <OscarZ> oh right..
13:11:52 <byorgey> OscarZ: for the type of streams (infinite lists) you can define a monad where  'return a' gives you an infinite list of a's
13:11:58 <danharaj> The only way to gain an intuition for monads (and the only reason why you want that intuition is so you can spot the abstraction in your own designs) is to grok several examples.
13:11:58 <monochrom> very few monad examples store anything. in fact, in the extreme, Cont eats things, not stores things.
13:12:13 <byorgey> so you shouldn't think of return as making something that 'stores a single value'
13:12:41 <nand`> think about it like this: return makes an identity
13:12:54 <nand`> since m >>= return is m
13:13:23 <nand`> and return x >>= f is (f x)
13:13:29 <monochrom> getChar :: IO Char doesn't "store a Char for you to fetch" or even "gives a Char". in a correct model of getChar, it waits for you to provide a Char, actually.
13:13:34 <kejoki> As far as I can tell, return is a bit of "type trickery" that sort of pushes something into the monad you're doing things in at the time.
13:13:52 <dmwit> nand`: Stated another way, f >=> return is f, and return >=> f is f
13:14:15 <nand`> :t (>=>)
13:14:16 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:14:29 <elliott> Is #haskell trying to collectively explain monads to a hapless newbie all at once again?
13:14:35 <danharaj> yes.
13:14:38 <danharaj> It's our national sport.
13:14:43 <danharaj> Don't hate our culture.
13:14:43 <elliott> I'll check on this tab in half an hour.
13:14:48 <ski__> nand`: "“wraps” the monad into minimal context" and "“unwraps” two nested monads" are misleading/confused ..
13:14:49 <kejoki> more than one hapless noob
13:14:54 <elliott> Two hours, then :)
13:15:01 <monochrom> I am not trying to explain monads. instead I am trying to refute all explanations
13:15:04 <dmwit> nand`: The third law looks good with (>=>), too: (f >=> g) >=> h is f >=> (g >=> h)
13:15:15 <elliott> monochrom++ ;; noble as it is futile
13:15:29 <monochrom> "monad as container" --> data Box a = Hi
13:15:35 <OscarZ> ok.. i thought i understood something about how the bind works.. in lists it can pick elements out of list, apply some function to elements and then combine the results
13:15:52 <nand`> OscarZ: in the example of lists, yes
13:15:53 <monochrom> "monad as computation" --> getChar eats, not returns, a Char
13:15:54 <byorgey> OscarZ: that sounds right
13:16:00 <danharaj> That is exactly what >>= is for the list monad.
13:16:06 <nand`> > [1,2,3] >>= \x -> [x, -x]
13:16:07 <lambdabot>   [1,-1,2,-2,3,-3]
13:16:19 <nand`> Here's another easy example: Maybe a
13:16:27 <nand`> > return "foo" :: Maybe String
13:16:28 <lambdabot>   Just "foo"
13:16:34 <monochrom> the only explanation I don't refute is "see more examples". I endorse it. Piaget's theory etc
13:16:43 <Ngevd> > return 'a' :: String
13:16:44 <lambdabot>   "a"
13:17:03 <Ngevd> IRRELEVANT EXAMPLE
13:17:07 <Ngevd> I feel at home now
13:17:08 <Ngevd> :)
13:17:11 <nand`> > Nothing >>= \s -> Just s
13:17:12 <tikhonjelvis> monochrom: I tried explaining them as "things that do stuff" to a friend, but it didn't help. It isn't incorrect though.
13:17:12 <lambdabot>   Nothing
13:17:19 <nand`> > Just "foo" >>= \s -> Just (reverse s)
13:17:20 <lambdabot>   Just "oof"
13:17:22 <danharaj> What is the list monad, really? Well, what's the type `a -> [b]`? It's the type of functions that return a list of outputs. What's the most natural way to compose such functions?
13:17:45 <monochrom> "things that do stuff" is always vacuously correct. survival of the fittest, too.
13:17:45 <danharaj> The list monad is the natural composition you'd come up with yourself.
13:17:58 <nand`> in particular, >=>
13:18:12 <monochrom> "what is a computer?" "thing that does stuff"
13:18:14 <nand`> monochrom: that's a good way to put it
13:18:18 <nand`> wait
13:18:20 <nand`> does a Box do things
13:18:29 <nand`> (referring to our data Box a = Box example)
13:18:33 <monochrom> it wastes memory
13:18:44 <tikhonjelvis> nand`: For sufficiently broad definitions of "do" and "stuff".
13:18:49 <monochrom> and oh, Marx's "everything has internal contradictions" too
13:18:51 <nand`> it exists, I suppose
13:18:58 <Ngevd> A monad is like a hovercontext
13:19:03 <danharaj> and what is return? return really is the analogue of `id`.
13:19:13 <danharaj> for whatever your `a -> m b` are.
13:19:15 <monochrom> a monad is like an internal contradiction
13:19:25 <ski__> nand` : `return' takes a value and "wraps" it into a monadic action that has no nontrivial effects. `join' takes a monadic action that yields a new monadic action, and gives a new monadic action that when run will run the input action, then run the result value (which was another monadic action)
13:19:34 <danharaj> fuck actions.
13:19:52 <dmwit> Yeah, who needs getChar?
13:19:54 <OscarZ> hmm.. I guess I have some vague understanding of them at least.. for Maybe and Lists
13:20:04 <nand`> ski__: I don't like the “when run” wording. That only really works for IO
13:20:07 <roconnor>     No instance for (System.Random.Random Word64)
13:20:09 <nand`> how do you “run” a list?
13:20:10 <roconnor> :(
13:20:14 <roconnor> where is the instance?
13:20:16 <tikhonjelvis> The difficulty is that what monads *are* and how they are *used* are distinct concepts.
13:20:19 <nand`> > join [[1,2,3],[4,5,6],[7],[]]
13:20:20 <ski__> nand` : you run a list by looking at its elements
13:20:20 <lambdabot>   [1,2,3,4,5,6,7]
13:20:32 <tikhonjelvis> And, as a programmer blissfully unaware of theory, you can totally get away without know the former :)
13:21:04 <monochrom> I don't completely agree
13:21:15 <kejoki> tikhonjelvis: how can you possibly program if you don't know the theory?
13:21:19 <ski__> nand` : specifically, i'm generalizing the word `run' to apply to every monad
13:21:28 <OscarZ> as Maybe and List both have to do with storing something.. what are good examples of Monads that dont store anything?
13:21:37 <danharaj> OscarZ: the continuation monad
13:21:45 <tikhonjelvis> Like a dog trained to do a trick for a treat!
13:21:58 <dmwit>  ?remember monochrom Nothing is true.
13:22:00 <danharaj> The Reader monad.
13:22:00 <kejoki> ski__: 'run' like in 'execute'
13:22:08 <ski__> kejoki : yes
13:22:11 <danharaj> Reader is a nice one to learn, it's particularly useful in practice.
13:22:13 <tikhonjelvis> I was being facetious.
13:22:14 <danharaj> And it's very simple.
13:22:29 * kejoki contemplates the joy he would get by executing all the monads...
13:22:48 <monochrom> my classification: philosophy, theory, use. "what is" is philosophy, none of us need that. the monad laws are the theory, every user needs that, in fact every user is already using them, there is no escape. http://www.haskell.org/haskellwiki/Monad_laws
13:23:07 <OscarZ> ok..thanks, I'll look them up
13:23:23 <tikhonjelvis> Your "philosophy" sounds suspiciously like math...
13:23:24 <kejoki> OscarZ: best of luck.
13:23:28 <danharaj> The Cont monad is probably the most confusing to understand at first of the standard monads.
13:23:28 <nand`> how many more years until we can represent the monad laws in haskell and have it automatically enforce them on potential instances
13:23:37 <danharaj> I hope never.
13:23:42 <danharaj> I don't want proof obligations all up in my face.
13:23:48 <OscarZ> danharaj: heh... maybe Reader then :)
13:23:49 <tikhonjelvis> That would make inference difficult, wouldn't it?
13:23:50 <nand`> danharaj: you'd prefer broken monad instances?
13:23:54 <monochrom> well, look at that web page, and tell me honestly whether you have used the laws or not.
13:24:03 <danharaj> nand` : I can choose to not use broken code.
13:24:06 <tikhonjelvis> nand`: I can live with tests and hope.
13:24:55 <erus`> have any of you guys implemented a parametrically polymorphic or dependently typed lambda calc?
13:24:57 <monochrom> read section 2 and tell me you have never done that
13:26:14 <monochrom> my definition of "philosophy" is writing essays on "what is"
13:26:25 <danharaj> pff, that's ontology.
13:26:39 <danharaj> teleologoy is writing essays on 'what's the point of'
13:26:57 <tikhonjelvis> which is a loaded question, I think
13:27:11 <tikhonjelvis> but I am not a philosopher not by accident
13:29:45 <tikhonjelvis> Has everybody just given up on explaining Monads now?
13:30:07 <stepcut> tikhonjelvis: I figured everybody understands them by now, right ?
13:30:13 * kejoki <sigh>  I thought figuring out call/cc in Scheme was difficult
13:30:35 * stepcut still hasn't figure out the 'this' keyword in javascript.. now *that* is some crazy stuff
13:30:44 <tikhonjelvis> Pfft, it's just dynamically scoped.
13:31:01 <stepcut> that's gibberish to me
13:31:04 <kejoki> stepcut: what tikhonjelvis said
13:31:10 <tikhonjelvis> Have you ever used a dynamically scoped language?
13:31:27 <tikhonjelvis> Like elisp or Perl?
13:31:29 <kejoki> stepcut: try programming in elisp.
13:31:31 <stepcut> dunno. I've  mostly used Haskell
13:31:54 <OscarZ> tikhonjelvis: yeah, but theres that crazy hack that suddenly "this" means the "global object"..
13:32:03 <kejoki> tikhonjelvis: Perl is "did you want fries with that" scoped.
13:32:10 <tikhonjelvis> Ooh, you should learn elisp.
13:32:25 * kejoki loves Perl, just for the scope tricks you can pull.
13:32:29 <tikhonjelvis> OscarZ: That's just because of the dynamic scoping.
13:32:31 <stepcut> i started learning elisp.. until I found out they were against proper tail recursion
13:32:32 <ski__> kejoki : you should look up "Representing Monads" by Andrzej Filinski in 1994-01 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RM.ps.gz> for how to implement monadic side-effects in any language that has (delimited) continuations
13:32:48 <tikhonjelvis> I think some other lisps support dynamic scoping as well.
13:32:56 <prof7bit> are there any other programming languages that lead to these kinds of discussions? Is it actually a "programming" language at all?
13:33:06 <tikhonjelvis> stepcut: The language sucks, but you can do awesome things with it.
13:33:41 <tikhonjelvis> stepcut: You should learn it because it makes you magically more productive.
13:33:43 <kejoki> tikhonjelvis: macLisp did.
13:33:55 <tikhonjelvis> stepcut: As long as you use Emacs, naturally. And you should.
13:34:10 <tikhonjelvis> kejoki: What about Common Lisp?
13:34:16 <ski__> dynamic scope^Wextent was a mistake/bug in the initial lisp implementation
13:34:23 <monochrom> smalltalk probably leads to "what is object" discussions
13:34:32 <ski__> Common Lisp has static scope, per default
13:34:39 <tikhonjelvis> I think everybody thought lexical scoping was too slow.
13:34:51 <tikhonjelvis> ski__: Yes, but *can* you use dynamic scoping somehow?
13:35:12 <ski__> of course one can use it ..
13:35:21 <diman> hi everyone
13:35:57 <tikhonjelvis> Writing a simple Lisp interpreter is a great way to understand scoping.
13:36:06 <tikhonjelvis> That's one of the reasons SICP is a great book.
13:36:38 <kejoki> ski__: McCarthy (RIP) said so, later.  But then they named use "car" & "cdr" to mean "head" & "tail" -- they were still down on the bare silicon.
13:36:39 <ski__> "implicit parameters" in GHC is basically dynamic extent
13:37:14 <kejoki> s/use//
13:37:37 <tikhonjelvis> kejoki: My professor claimed they kept car/cdr because you could pronounce stuff like caddr.
13:38:18 <monochrom> I don't know how to pronounc cadddddr and caddddr so that they sound different
13:38:33 <nand`> cadurrrrrrrrrrrrrrrrrr
13:38:37 <tikhonjelvis> kah-da-da-da-da-r
13:38:45 <parcs`> aren't caddr and cadadr pronounced the same
13:38:57 <monochrom> yes, da-da-da... is an option, but then the audience needs a Geiger counter...
13:39:00 <tikhonjelvis> We actually had a function in our class Scheme library that showed how to pronounce them.
13:39:02 <elliott> \mon"see aye dee deed ..."
13:39:06 <elliott> argh
13:39:11 <elliott> monochrom: "see aye dee dee ..."
13:39:25 <monochrom> hehe
13:39:41 <elliott> better question:
13:39:46 <elliott> why are you using cadddddr
13:39:55 <tikhonjelvis> Because I can pronounce it!
13:40:10 <monochrom> just asking a hypothetical question
13:40:11 <niteria> :)
13:40:14 <kejoki> tikhonjelvis: ha.  They kept them because they were used to them.
13:40:26 <elliott> head/tail are bad names for car/cdr
13:40:35 <elliott> (tail '(1 . 2)) -> 2 ?! the tail of a list is a list
13:40:45 <elliott> banning irregular lists works, but that's not just a simple name change
13:40:49 <tikhonjelvis> It's really more like fst/snd.
13:40:57 <monochrom> yeah
13:41:25 <kejoki> ha.  we keep the Lisp notion of a list because we're used to it.
13:41:40 <tikhonjelvis> Well, that, and it's pretty clever.
13:41:41 * ski__ . o O (define knappsats-rubrik cadddddr)
13:42:40 <kejoki> so are Church numerals, but who uses an idea like that in a programming language?
13:42:50 <tikhonjelvis> Haskell lists are really very different from Lisp lists though.
13:43:03 <monochrom> Oleg does :)
13:43:25 <parcs`> lisp lists are just nested tuples
13:43:45 <elliott> the term is cons cells
13:44:08 <monochrom> I only see typing as the difference
13:44:23 <elliott> for a language that gave rise to GC, lisp has a pretty low-level view of memory
13:44:34 <kejoki> had
13:44:39 <tikhonjelvis> I've heard them called pairs.
13:44:52 <elliott> you "cons things" when you allocate them, so there's an explicit notion of allocation... the pointers in a cons cell are exposed (with rplacd etc.)
13:44:55 <kejoki> tikhonjelvis: that's pretty standard
13:44:56 <elliott> kejoki: fair enough
13:45:03 <elliott> but there are still remnants
13:46:55 * cmccann notes that right-nested pairs with a distinguished nil type is basically how things like HList work
13:47:05 <kejoki> rplacd and it's siblings are a great way to go on Really Fun Debugging Adventures
13:48:16 <kejoki> s/it's/its/ # and damn all irregularitys in the English language to boot.
13:49:17 <elliott> cmccann: it takes an oleg to greenspun haskell
13:49:24 <elliott> 's type system
13:50:14 <cmccann> elliott, nah, an HList is a homogenous list at the type level, everything is of kind *
13:50:16 <kejoki> It looks to me, from my noob perspective, like it would be awfully easy to write a Lisp in Haskell.  Particularly a Scheme.
13:50:50 <cmccann> kejoki, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:50:51 <tikhonjelvis> Well, there are some tricky bits. It's easier in Scheme.
13:51:10 <tikhonjelvis> But it is a *really* good exercise. I hate spelling "exercise".
13:51:24 <kejoki> cmccann: heh.  Well, there ya go.
13:51:56 <zachk> ccmccann: do you find that book, good, decent, or excellent?
13:52:10 <cmccann> never actually read through it
13:52:12 <tikhonjelvis> The Scheme one? I personally found it awesome.
13:52:15 <elliott> kejoki: For a true Greenspunning you need to embed the lisp in the language.
13:52:27 <tikhonjelvis> But I did it coming off SICP. So it was good timing.
13:52:36 <elliott> Otherwise you've intended it, and that means you're a smug lisp weenie, and smug lisp weenies never make mistakes, and Greenspunning is a mistake.
13:52:37 <kejoki> tikhonjelvis: think of spelling "exercise" as a kbd etude.
13:52:41 <elliott> So it can't be a Greenspunning.
13:52:56 <tikhonjelvis> I just let my spell-check based autocomplete help :)
13:52:58 * nand` makes a mental note to read it some day
13:53:35 <tikhonjelvis> Well, you can embed basic into the language, and that's almost as good. Right?
13:53:42 <nand`> I don't have any difficulties writing “exercise”. :) It's one of the times when strict adherence to the home row system can be detrimental to typing efficiency
13:54:01 <tikhonjelvis> The difficult bit isn't typing it but remembering which letters go in which order.
13:54:26 <elliott> Home row? That's the place where you never, ever rest your fingers, right?
13:54:34 <zachk> > splitAt 4 "exercise"
13:54:35 <lambdabot>   ("exer","cise")
13:54:59 <monochrom> exorcise
13:55:08 <kejoki> elliot: I'm looking up "Greenspunning".   I thought at first it had something to do with finance.
13:55:16 <elliott> kejoki: :D
13:55:20 <elliott> http://en.wikipedia.org/wiki/Greenspun's_tenth_rule
13:55:24 * ski__ . o O ( "excise" )
13:55:40 <zachk> iirc it means implementing most of ansi common lisp in your language to solve your problem in your given domain
13:55:44 <elliott> exercises excise exers
13:55:54 <elliott> exer is the unit of lack of understanding
13:56:11 <elliott> zachk: not most! only half.
13:56:12 <monochrom> what? is that real? exer?
13:56:31 <zachk> you need to exercise the executor function of the frontal lobe of your cerebellum
13:56:46 <elliott> monochrom: It is now.
13:56:49 <partyhard> Hi. Can somebody correct this
13:56:50 <partyhard> let square x = x * x * y in square 3 4
13:56:53 <elliott> monochrom: I trust #haskell will help me propagate it.
13:57:04 <nand`> On that matter, I believe the Camel completeness hypothesis states that it is impossible to write a program which is not a polyglot, by virtue of every program being valid perl
13:57:04 <monochrom> let square x = x * x * y in square 3
13:57:09 <elliott> partyhard: What's y?
13:57:10 <monochrom> oh, sorry
13:57:14 <elliott> Why are you multiplying by y?
13:57:15 <monochrom> let square x y = x * x * y in square 3 4
13:57:15 <zzo38> Please tell me if this program has a thing missing or wrong that you think it is:   http://sprunge.us/WQKG
13:57:19 <kejoki> :P  I'm getting too old -- can't believe I've never heard of G's tenth rule before.
13:57:20 <partyhard> x y are the parameters
13:57:24 <zachk> > let square x = x * x in square 3
13:57:25 <lambdabot>   9
13:57:28 <elliott> No they're not, you only declared the parameter "x" there.
13:57:35 <elliott> But yes, as monochrom says, add "y" to the parameter list and it will work.
13:57:39 <elliott> That's... not really squaring, though.
13:57:46 <partyhard> how would you use two variables
13:57:51 <elliott> <monochrom> let square x y = x * x * y in square 3 4
13:57:53 <monochrom> I have stopped interpreting function names long ago
13:58:07 <partyhard> let naem x = x * x * y in name 3 4
13:58:08 <elliott> zzo38: isJust is in Data.Maybe.
13:58:15 <partyhard> let name x = x * x * y in name 3 4
13:58:21 <elliott> partyhard: You say "let name x = ...".
13:58:25 <nand`> adding anything to the parameter list, or adding a lambda at the front would make it valid; assuming y has an appropriately defined Num instance
13:58:26 <monochrom> let name x y = x * x * y in name 3 4
13:58:28 <elliott> But you use it like "name 3 4". You want x to be 3, and y to be 4.
13:58:31 <elliott> So you want "let name x y = ...".
13:58:36 <partyhard> yes
13:58:44 <partyhard> elliott
13:58:52 <nand`> > let y = 5 in (let square x _ = x * x * y in square 3 4)
13:58:53 <lambdabot>   45
13:58:56 <zzo38> elliott: OK I fixed that part.
13:59:09 <monochrom> nand` wins :)
13:59:15 <partyhard> Ok Thanks
13:59:21 <elliott> > let y = 5 in (let square x = x * x * y in square 3 4)
13:59:22 <lambdabot>   45
13:59:24 <cmccann> monochrom, just use de bruijn indices for everything
13:59:25 * elliott wins.
13:59:29 <elliott> I didn't even change the code.
13:59:30 <zachk> partyhard: what are you trying to do?
13:59:32 <elliott> I just made it work!
13:59:35 <partyhard> I finnaly get "let"
13:59:43 <elliott> partyhard: yay
13:59:47 <partyhard> i just continued learning from try haskell
13:59:48 <zzo38> Is there anything else should be changed/complain of my program?
13:59:50 <monochrom> Haskell doesn't take my de Bruijn indexing
13:59:54 <nand`> elliott: haha. won't work in prelude though since functions are not numbers there
14:00:37 <elliott> partyhard: Has Learn You a Haskell been recommended yet? :)
14:00:46 <elliott> We need a bot that just links to LYAH every half-hour.
14:00:57 <monochrom> every 5 minutes
14:01:01 <partyhard> I want to finnish try haskell first then try a book
14:01:19 <partyhard> Its really a beautiful language
14:01:35 <kejoki> ski__: thanks for that link to the "Representing Monads" paper.
14:01:36 <monochrom> oh, I know. not every time period. every n sentences said by other people.
14:01:38 <elliott> monochrom: every second
14:01:43 <elliott> actually
14:01:46 <elliott> direct it at everybody that joins :)
14:01:52 <zachk> partyhard: you might like programming in haskell by graham hutton...
14:01:54 <elliott> partyhard: ah, ok -- you're still going through try haskell
14:02:05 <partyhard> :D
14:02:08 <elliott> I would recommend Learn You a Haskell after that (it's free online and available in printed book form too)
14:02:10 <tikhonjelvis> zachk: But LYAH has pretty pictures!
14:02:17 <partyhard> :P
14:02:19 <nand`> isn't it in the topic?
14:02:22 <partyhard> Thanks.:)
14:02:27 <cmccann> I actually saw a LYAH on a shelf in an actual bookstore some time ago
14:02:29 <elliott> Who reads the topic?
14:02:29 <tikhonjelvis> Does anybody read the topic?
14:02:32 <nand`> oh it isn't
14:02:36 <nand`> good question
14:02:37 <elliott> it's not actually in the topic, so you don't either :P
14:02:38 <nand`> I only see it when I join
14:02:38 <tikhonjelvis> Not nand`, apparently
14:02:43 <ski__> @where LYAH
14:02:43 <lambdabot> http://www.learnyouahaskell.com/
14:02:53 <nand`> why isn't it in the topic
14:02:54 <zachk> @where pih
14:02:55 <lambdabot> I know nothing about pih.
14:03:01 <elliott> cmccann: Was it in the Useless Impractical Theoretical Rubbish section?
14:03:09 <zachk> @where PIH
14:03:09 <lambdabot> I know nothing about pih.
14:03:11 <tikhonjelvis> Because nobody reads the topic. I thought we just established that.
14:03:14 <zachk> @where RWH
14:03:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:03:17 <elliott> zachk: lambdabot doesn't like your favourite book.
14:03:19 <zzo38> Useless Impractical Theoretical Rubbish section?
14:03:20 <nand`> tikhonjelvis: the chances are not zero
14:03:21 <monochrom>  @where is human-maintained. you have to add stuff to it
14:03:28 <elliott> @where lambdabot
14:03:28 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
14:03:39 <nand`> zzo38: that's the haskell section
14:03:55 <tikhonjelvis> nand`: They're indubitably sufficiently low that the effort of changing the topic is too much :)
14:03:57 <cmccann> elliott, nah, just sitting there amidst all the "learn enterprise java bean sprout factory factories  in twelve minutes" rubbish
14:04:07 <ski__> kejoki : yw
14:04:11 <elliott> cmccann: ah... just the useless impractical rubbish section, then
14:04:22 <monochrom> heh heh heh
14:04:34 <cmccann> elliott, I guess I can't really argue with that
14:04:36 <zzo38> I like mathematics though, even if some people don't.
14:04:37 <elliott> Java bean sprout factory factories sound like fun.
14:04:54 <elliott> Java and the Beanstalk factory factory
14:04:56 <tikhonjelvis> Especially when they have fat books about *normal* Java objects...
14:04:56 <monochrom> Mr. Bean is more fun, but I digress
14:05:06 <nand`> the entire universe is based on mathematics, so by virtue of liking things one likes mathematics
14:05:07 <kejoki> it's a self-ref ... it starts with UI, and how useless is that?
14:05:24 <zzo38> nand`: I think, that isn't how it works
14:05:42 <zzo38> Even though the universe is based on the mathematics that isn't the logic to liking things
14:05:44 <tikhonjelvis> nand`: It's mathematics that just happens to (probably) reflect the universe.
14:05:47 <kejoki> the UIR section.  I need to get that into my man pages.
14:05:49 <OscarZ> would it be possible to implement haskell on JVM ?
14:05:50 <tech2> nand`: I can like cathedrals without liking Christianity...
14:05:54 <elliott> OscarZ: LambdaVM
14:05:56 <elliott> it's been done
14:05:59 * monochrom contemplates University of Iowa User Interface Institute, UIUII?
14:06:03 <elliott> the JVM is really quite hostile to haskell though
14:06:12 <elliott> there's quite a semantic mismatch
14:06:13 <tech2> monochrom: cute
14:06:27 <tikhonjelvis> I've heard tail-call optimization is difficult on the JVM.
14:06:32 <kejoki> I thought in Iowa it would be eieio ??
14:06:37 <elliott> tikhonjelvis: More like "model" than "reflect".
14:06:47 <elliott> You can like something without liking a model of it.
14:06:55 <cmccann> I wonder how hard it would be to compile from GHC Core to something like clojure or scala
14:07:01 <elliott> tikhonjelvis: tail-recursion is easy, tail-calling requires trampolining, I think
14:07:12 <elliott> which requires exceptions, which are probably pretty slow
14:07:31 <elliott> cmccann: You'd need unsafeCoerce for the cast stuff in Scala, I think.
14:07:37 <elliott> Scala-equivalent-of-unsafeCoerce, that is.
14:08:05 * cmccann would probably try clojure first anyway
14:08:12 <kejoki> elliott: I knew there were more reasons to dislike Java than just "It's ugly" and "I don't want to do that much typing to get a working hello program."
14:08:25 <zzo38> Please tell me if my program is another thing wrong other than isJust
14:08:34 <zzo38> I fixed it now it is Data.Maybe
14:08:44 <tikhonjelvis> kejoki: Bah, the ugliness is reason enough by itself.
14:09:06 <cmccann> zzo38, what do you think might be wrong with it?
14:09:40 <zzo38> cmccann: I don't know, it is why I asked
14:09:51 <cmccann> zzo38, if you're talking about the link you gave a bit ago that's too much code to skim through easily
14:10:08 <cmccann> you'd be more likely to get help if you have specific questions
14:10:15 <cmccann> or a smaller piece of code
14:10:38 <cmccann> you could also try posting it here: codereview.stackexchange.com
14:11:05 <monochrom> how does posting code on a different site make it smaller?
14:11:32 <monochrom> err, nevermind, misread
14:11:36 <elliott> it doesn't, but people are more likely to read it all if it's on a site specifically for reading and commenting on large amounts of code
14:11:41 <cmccann> yeah
14:11:44 <elliott> well "large"
14:12:00 <Sgeo> I need to wean myself off of asking to have code reviewed
14:12:28 <monochrom> w00t, there is a "java monad implementation" there!
14:12:37 <tikhonjelvis> monochrom: The site could also have a smaller font size.
14:12:41 <zzo38> Does this code looks like correct to you?  ("delimit", Right $ \p @ ProgramState { psTokens = h : t } -> uncurry (:) . (Block *** tail) $ break (== h) t)
14:12:45 <zzo38> And other things too, not only that one
14:12:54 <Sgeo> :t (***)
14:12:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:13:00 * cmccann has been thinking about trying to encourage more use of codereview.se for haskell, actually, seems like it could actually be a useful resource
14:13:03 <elliott> It certainly typechecks. Define "correct".
14:13:09 <elliott> (Well, it might typecheck. I didn't actually, you know, check.)
14:13:22 <Sgeo> elliott, you're not GHC? Are you sure?
14:13:23 <zzo38> I know everything compiles and I tested stuff
14:13:46 <cmccann> zzo38, if it gives the correct result, it's correct
14:13:47 <zzo38> But I mean, like, the isJust is in Data.Maybe is there another function for such a thing?
14:13:52 <elliott> *in all situations
14:14:03 <Sgeo> :t isJust
14:14:04 <lambdabot> forall a. Maybe a -> Bool
14:14:04 <zzo38> Or other thing with other pieces of the codes. Maybe if it could be written in a better way
14:14:12 <tikhonjelvis> zzo38: So you're asking more about style stuff?
14:14:22 <zzo38> tikhonjelvis: Yes, that too.
14:14:45 <zzo38> Is there a better function to do what I was doing by that ("delimit", codes
14:14:50 <nand`> cmccann: most notable exception to this is perl
14:14:53 <Sgeo> :t (&&&)
14:14:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:15:13 <cheater_> cmccann: that only shows a parked domain.
14:15:14 <Sgeo> For the function arrow, is &&& generally more useful than ***?
14:15:17 <kejoki> nand`: Hey!
14:15:27 <elliott> (***) is useful.
14:15:29 <elliott> Especially join (***).
14:15:32 <elliott> :t join (***)
14:15:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:15:37 <cmccann> cheater_, what does? I meant http://codereview.stackexchange.com/
14:15:45 <cheater_> codereview.se does.
14:15:51 <cmccann> the ".se" was shorthand because I spend too much time on stack exchange sites :P
14:15:57 <cmccann> sorry about that
14:15:58 <cheater_> ok.
14:16:01 <cheater_> np
14:16:10 <elliott> SX or something would be a better abbreviation :P
14:16:43 <cheater_> i see jquery, sharepoint, and uml
14:16:48 * cheater_ alt-f4
14:17:03 <cmccann> cheater_, yes, that's why we need more haskell stuff there
14:17:06 <nand`> first page of results
14:17:09 <nand`> >Java monad implementation
14:17:11 <nand`> now I'm curious
14:17:35 <nand`> ah yes, that's completely straightforward, minimal, elegant and boilerplate-free
14:17:38 <nand`> http://codereview.stackexchange.com/questions/8055/java-monad-implementation
14:17:38 <cmccann> perhaps http://codereview.stackexchange.com/questions/tagged/haskell would be more useful
14:17:51 <cheater_> cmccann: no i don't think we need to go there
14:18:13 <elliott> cmccann: hehe, they just omit return, presumably because you can't express it in java :)
14:18:27 <cmccann> elliott, who needs it anyway
14:18:34 <cmccann> desugaring do notation doesn't require it
14:19:15 <kejoki> cmccann: looks like there are a few there already.
14:19:18 <mauke> everyone knows do notation is the most important part of monads
14:19:23 <elliott> cmccann: Yes, I'm sure that interface will work just fine to accomplish some abominable Java do-notation desugarer :P
14:19:26 <cmccann> mauke, exactly!
14:19:31 <nand`> public static <T> Maybe<T> nothing() { return new Maybe<T>((State<T>) Nothing.INSTANCE); }
14:19:35 <nand`> this just screams java
14:19:53 <cmccann> I've done something similar in C# before
14:19:54 <hpaste_> akosch pasted “fun with json-rpc” at http://hpaste.org/56812
14:19:55 <mauke> I can't even read that
14:19:56 <cmccann> it's a bit nicer though
14:20:02 <Sgeo> I see how to serialize a CString into a String, but what about CWstring into Text?
14:20:13 <zzo38> I have the gopher Stack Overflow service including Code Review
14:20:15 <Sgeo> Is there a way to do that more efficiently than CWString to String to Text?
14:20:23 <Sgeo> gopher Stack Overflow?
14:20:25 <elliott> You can access Stack Overflow by gopher?!
14:20:28 * elliott uninstalls Chrome.
14:20:36 <zzo38> I do not have the account though
14:20:42 <zzo38> And the gopher Stack Overflow is read-only
14:20:50 <akosch> can someone take a look at my code please? I'm open to all sorts of suggestions :)
14:20:54 <cmccann> well that won't work for elliott then
14:21:05 <elliott> cmccann: might be for the best :P
14:21:07 <zzo38> akosch: Then please post it otherwise I won't look
14:21:45 <zzo38> The gopher Stack Overflow is on my computer, if you connect to my computer then you will find it
14:21:54 <nand`> akosch: I looked at your code but I didn't see anything wrong with it.
14:22:00 <nand`> oh wait
14:22:02 <elliott> akosch: got a link?
14:22:02 <nand`> he actually did post it
14:22:05 <elliott> oh
14:22:11 <nand`> [02+0008] <hpaste_> akosch pasted “fun with json-rpc” at http://hpaste.org/56812
14:22:17 <nand`> I feel stupid now
14:22:17 <elliott> we need hpaste_ to use big flashing lights
14:22:19 <zzo38> O, it is http://hpaste.org/56812
14:22:20 <elliott> maybe rainbow colours, bold
14:22:32 <zzo38> Now I will look
14:22:35 <kejoki> singling telegram?
14:22:36 <akosch> zzo38: thanks :)
14:22:39 <nand`> elliott: wouldn't work, I have colors turned off
14:22:50 <nand`> I propose a more universal solution
14:22:52 <elliott> akosch: looks mostly OK to me but tryParseParam usage is wrong
14:22:55 <nand`> he should simply spam it 10 times into chat
14:22:59 <elliott> akosch: you should put tryParseParam in IO and use throwIO instead
14:23:02 <nand`> that will work on monocolor terminals
14:23:12 <elliott> because right now, if f has to force an argument for the error to appear
14:23:14 <elliott> if parsing it fails
14:23:23 <elliott> which is just... ugly
14:23:41 <elliott> I would also suggest using an applicative style
14:23:44 <akosch> elliott: sure thing, thank you
14:23:53 <elliott> toJSON =<< f <$> tryParseParam ps 0 <*> tryParseParam ps 1
14:24:00 <cmccann> or just return (Either String a) or something like that
14:24:03 <cmccann> instead of using exceptions
14:24:08 <cmccann> seems like less hassle to me
14:24:20 <elliott> cmccann: well if he's handling all errors in a uniform way it makes sense
14:24:32 <elliott> since akosch has said there's exceptions everywhere else in "f"s
14:24:39 <cmccann> true
14:24:43 <elliott> akosch: apart from that it looks fine, although why do your exceptions have Maybes in them?
14:25:08 <elliott> you might also want to do "handle (handleError rIdV) $ do ..." to avoid those parens
14:25:30 * cmccann just gets annoyed having to keep track of where exceptions can come from, vs. something like Either making it explicit
14:25:35 <akosch> elliott: I don't always want to specify a message (at least I thought that when I wrote it like this) ;)
14:25:38 <elliott> akosch: oh, runRequest should also use throwIO
14:25:47 <elliott> when in IO use throwIO rather than throw :)
14:25:56 <Sgeo> :t throwIO
14:25:57 <lambdabot> Not in scope: `throwIO'
14:26:05 <kejoki> akosch: you want exceptions with Nothing to report?
14:26:05 <Sgeo> @hoogle throwIO
14:26:05 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
14:26:06 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
14:26:06 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
14:26:19 <elliott> kejoki: >_<
14:26:29 <DanBurton> is there a library-provided way to find the minimum *element* (not key) in a Data.Map?
14:26:36 <akosch> kejoki: I always have an error-code, but sometimes I have no descriptive text
14:26:39 * kejoki I was young when I did it.
14:26:51 <cmccann> DanBurton, minimum meaning using an Ord instance on the element type?
14:26:57 <DanBurton> cmccann: right
14:27:03 <monochrom> cmccann: http://www.vex.net/~trebla/haskell/exception.xhtml
14:27:12 <Sgeo> A fold of some sort
14:27:13 <elliott> DanBurton: minimum . Map.elems
14:27:13 <Sgeo> ?
14:27:14 <cmccann> DanBurton, then the Map can't help you anyway so just toList and go from there
14:27:17 <akosch> kejoki: for example I don't elaborate on the error, when the user is sending invalid JSON
14:27:28 <cmccann> or elems, whatever it's called
14:27:28 <DanBurton> yeah I guess
14:27:45 <elliott> Sgeo: a fold might be slower, since minimum is probably optimised, and it'd be essentially treating the map as a list anyway
14:27:50 <elliott> cmccann: technically the Map could help
14:27:53 <elliott> by parallelising the search
14:27:59 <elliott> which wouldn't work so well streaming to a list
14:28:30 <Sgeo> Using the internal structure of the map?
14:28:44 <cmccann> elliott, true
14:28:45 <elliott> the tree structure, yes
14:29:17 <zzo38> Also tell me if, in my program, the "builtins" map has some things omitted, some things that shouldn't be there, or if any part of the programs seem works wrongly and there ought to be a better design
14:29:24 <parcs`> cmccann: maybe you want checked exceptions
14:29:54 <elliott> zzo38: those questions are really hard to answer without taking a very in-depth look at the code and knowing what you're trying to implement; I'd second the codereview stack exchange suggestion
14:30:08 <elliott> (not that i've ever used it, but it looks better than #haskell for questions like that :P)
14:30:38 <parcs`> indexed monads can make checked exceptions a reality in haskell
14:30:47 <kejoki> Oh goody.  Lightening & thunder.
14:30:55 <zzo38> I tried to write explanations of what I was trying to implement
14:31:01 <elliott> parcs`: we already have "checked exceptions", it's called ErrorT :P
14:31:04 <cmccann> parcs`, I've tried implementating that a few times actually
14:31:08 <zzo38> But tell me if it is not understandable
14:31:25 <parcs`> cmccann: me too! :P
14:31:25 <elliott> there's another package explicitly for it called uhh
14:31:30 <cmccann> elliott, I think parcs` means where the error type isn't fixed for the entire thing
14:31:40 <elliott> http://hackage.haskell.org/package/explicit-exception
14:31:46 <cmccann> hence the indexed monads
14:32:00 <elliott> cmccann: ah
14:32:03 <zzo38> Yes I know about indexed monads, and indexed comonads.
14:32:08 <elliott> cmccann: a mtl-style typeclass solution accomplishes that too
14:32:12 <elliott> a bit lighter-weight, too
14:32:19 <elliott> i.e. (Throws m ..., Throws m ...) => m ...
14:32:27 <Razz> elliott: I figured out the functort version for the 'free monad' but for the Monad type class I'm again confused, any hints?
14:32:32 <Razz> *functor
14:32:49 <elliott> Razz: you know how m >>= f = join (fmap f m)?
14:33:02 <Razz> elliott: I did not
14:33:02 <elliott> you might have a lot easier time writing a special join for the type and using that definition for (>>=)
14:33:04 <elliott> oh
14:33:08 <elliott> i thought it says that in the typeclassopedia
14:33:14 <Razz> thats next ;-)
14:33:21 <Razz> not there yet
14:33:25 <elliott> ah, it does that later :)
14:33:33 <elliott> ok, maybe you're not meant to do that
14:33:39 <parcs`> elliott: that won't work
14:33:42 <cmccann> monochrom, isn't that page you linked to just reimplementing (ErrorT Error IO), give or take?
14:33:46 <elliott> parcs`: what won't?
14:33:54 <zzo38> I very often write    x >>= f = join' (fmap f x) where { join' :: ........     (I called it join' instead of join so that the normal join can still be accessed, such as when defining a monad transformer)
14:33:59 <parcs`> elliott: (Throws m ..., ...) => m
14:34:08 <elliott> Razz: oh well, it's probably best to write it like that even if you don't know you're allowed to yet :)
14:34:12 <monochrom> click on the "click me if you can" button, and read again
14:34:20 <elliott> Razz: you can then "inline" your joinFree into the (>>=) definition getting a normal one back
14:34:32 <elliott> parcs`: why not?
14:34:42 <zzo38> join really ought to be a class method
14:34:48 <monochrom> or in short, isn't ErrorT Error IO just reimplementing IO
14:35:39 <cmccann> monochrom, unfortunately there's no way to exclude exceptions from IO, so it ends up being equivalent, yes
14:35:52 <monochrom> I call that fortunately
14:36:01 <parcs`> elliott: if a throws Foo, so does (a >> b). you need indexed monads to keep track of the possible exceptions that a computation may throw, and to make sure that 'main' is an action that throws no exceptions
14:36:03 <Razz> elliott: thx again :-)
14:36:18 <parcs`> elliott: that didn't really explain why, i know :P
14:36:22 <elliott> parcs`: you just need something like
14:36:56 <elliott> catch :: (ThrowyMonadThing m) => (forall n. (Throws n e) => n a) -> (e -> m a) -> m a
14:36:57 <elliott> or something :P
14:37:03 <monochrom> anyway, my point is that since the two are the same, people's opinion on them should also be the same.
14:37:15 <elliott> to explicitly discharg ethe obligation of being able to throw a certain exception type by handling it
14:37:17 <cmccann> monochrom, which is a fair point
14:37:21 <zzo38> newtype IxWriter c x y z = IxWriter { runIxWriter :: (c x y, z) };   is a indexed monad for (Category c)   newtype IxState x y z = IxState { runIxState :: x -> (z, y) };   is a indexed monad    newtype IxReader c x y z = IxReader { runIxReader :: c x y -> z };    is a indexed comonad for (Category c)
14:37:26 <elliott> *discharge the
14:37:37 <cmccann> monochrom, but I'd still rather do it explicitly and avoid the implicit form consistently
14:37:38 * ski__ . o O ( `tmap :: Monad m => (forall x. ErrorT Error m x -> ErrorT Error IO x) -> (ErrorT Error m a -> ErrorT Error IO a)' )
14:37:38 <zzo38> newtype IxStore x y z = IxStore { runIxStore :: (y -> z, x) };   is also indexed comonad
14:37:55 <cmccann> rather than embrace the implicit "errors from everywhere! who knows!"
14:38:12 <elliott> cmccann: What do you think of asynchronous exceptions to kill pure code, e.g. after a timeout?
14:39:22 <cmccann> elliott, if it's the only way to do that then so be it
14:40:04 <monochrom> if I'm writing a parser without IO, I use Either, not async exceptions, because checking for success vs failure with Either is reliable and does not require micro-managing evaluation order
14:40:19 <elliott> cmccann: so you're OK with one specific asynchronous exception? :)
14:40:40 <monochrom> buf if I'm writing IO code, I use exceptions, it does not obscure more
14:40:42 <cmccann> elliott, the lack of superior alternatives doesn't make me like something, merely tolerate it
14:41:10 * elliott doesn't really like pure exceptions either
14:41:16 <monochrom> in both cases, certain common doctrines are not in my consideration
14:41:20 <elliott> but I find the inability to time out pure code worse
14:41:29 <elliott> and I see no reason to restrict it once you open the semantic can of worms
14:41:35 <cmccann> elliott, yes, I wish there were better ways to do things like that
14:41:54 <monochrom> if you say, you wish every type signature to remind you which exceptions are relevant, I agree
14:42:28 <elliott> hmm... good, i think my pipe dream language concept handles pure code timeouts without async exceptions :P
14:42:34 * elliott resumes feeling superior
14:42:37 <zzo38> I think you should make it, the pure codes can be separate programs, pure in their own program. And then one program can be the management of it, which is allowed to treat the other program's pure codes into other stuff
14:43:18 <elliott> that just shoves the semantic issues of async exceptions onto the OS :P
14:43:29 <cmccann> monochrom, I wish every type signature to say what possible results that value can have, and not require that every type allow a bunch of values I don't want
14:43:35 <cmccann> which includes most possible errors
14:43:51 * cmccann would also prefer a language to be total by default if that's not obvious by now
14:43:56 <elliott> cmccann: I was just about to ask.
14:44:06 <cmccann> turing completeness is overrated anyhow
14:44:07 * elliott agrees, but only if we're given unsafePerformPartial :: Partial a -> a
14:44:17 <elliott> and "main" has both partial and IO effects
14:44:23 <elliott> I guess IO implies partial effects, really
14:45:29 <monochrom> it seems to me that the wish for a total language you will use is just like the wish for a latex irc plugin you will use
14:45:55 * elliott cannot make heads or tails of that comparison
14:46:01 <elliott> which is good, because head and tail are partial
14:46:13 <elliott> :t heads
14:46:14 <lambdabot> Not in scope: `heads'
14:46:15 <elliott> lame!
14:46:17 <monochrom> in the case of a latex irc plugin, people started wishing it 15 years ago, about 5 years ago pidgin got one, nobody uses it, people will keep wishing for another 15 years in the future
14:46:25 <elliott> oh, latex irc plugin
14:46:27 <elliott> not
14:46:31 <elliott> a latex package that can connect to irc
14:46:49 <elliott> that makes more sense and is less fun to imagine
14:46:54 <cmccann> monochrom, to a first order approximation nobody uses haskell either
14:46:57 <monochrom> so, I'm saying, when a total language finally comes your way, you will not use it, and you will keep wishing it for another 15 years
14:47:08 <tikhonjelvis> The latter sounds very useful though.
14:47:14 <tikhonjelvis> And the issue with a pidgin plugin is that I don't use pidgin.
14:47:20 <tikhonjelvis> Or, more generally, standardization.
14:47:24 <akosch> people with irssi would be a bit screwed
14:47:25 <cmccann> monochrom, is this a roundabout way of suggesting I learn agda? :P
14:47:28 <elliott> monochrom: I would probably not use it, because it's likely to majorly fall short in other areas
14:47:34 <elliott> thus "all else being equal"...
14:47:48 <elliott> (this is because basically all languages majorly fall short in some important area)
14:48:25 <akosch> why not just talk in latex source directly? people who use latex obviously spend more time with the source than with the output anyway ;)
14:48:29 <zzo38> Sometimes it happen. It is why, I have invented domain specific programming languages for specific purposes, and other people also doing so. And making a new IRC client if you do not like the other one, for example
14:49:50 <tikhonjelvis> akosch: That's what ends up happening. In reality, we probably just want to show off to people who can't use LaTex :)
14:49:54 <zzo38> When describing mathematical formula in IRC, I do sometimes use a TeX code for that purpose.
14:50:13 <yitz> @let heads x = [head x] -- here you go, elliott
14:50:13 <monochrom> tikhonjelvis, my thought is that if people were really cared about irc latex plugin, they would pay the price for it, in the form of switching to pidgin. seeing that they do not, I conclude that they're just talking hot air
14:50:15 <lambdabot>  Defined.
14:50:27 <tikhonjelvis> Did you know you can just plug most TeX expressions straight into WolframAlpha?
14:50:46 <zzo38> But I use Plain TeX rather than LaTeX so there are some differences
14:50:56 <elliott> yitz: no no no
14:51:02 <elliott> @src tails
14:51:03 <lambdabot> tails []         = [[]]
14:51:03 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:51:11 <elliott> tails xs = xs : tails (tail xs)
14:51:12 <yitz> @src inits
14:51:13 <lambdabot> inits []     =  [[]]
14:51:13 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
14:51:14 <monochrom> "put your money where your mouth is" is a very powerful test. and in this case not even much money is involved
14:51:16 <elliott> heads xs = xs : heads (head xs)
14:51:22 <elliott> @let heads xs = xs : heads (head xs)
14:51:23 <lambdabot>  <local>:5:16:
14:51:23 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]...
14:51:24 <tikhonjelvis> monochrom: Switching to Pidgin is very inconvenient.
14:51:40 <elliott> monochrom: pidgin is really terrible though
14:51:53 <elliott> "I want a LaTeX plugin" =/= "I want a LaTeX plugin to the exclusion of everything else"
14:51:55 <zzo38> Wolfram|Alpha has a large number of things missing. So, make a new similar thing, based on Haskell, including Haskell codes as well as English texts. And with free-software/open-source, with local mode, and access internet for data needed
14:52:34 <akosch> I tend to use latex in the wondrous world of html emails, just needs a script to compile the selection to an image then paste
14:52:39 <byorgey> zzo38: someone is working on that, actually.
14:52:46 <parcs`> @let heads = take 1
14:52:47 <lambdabot>  <local>:4:0:
14:52:47 <lambdabot>      Equations for `heads' have different numbers of arguments
14:52:47 <lambdabot> ...
14:53:00 <byorgey> zzo38: except not with the same focus on data.
14:53:01 <monochrom> oh, there is mathjax.org for that, akosch, and better than images
14:53:09 <tikhonjelvis> akosch: There are some nice JavaScript LaTeX engines, so you could just get your recipients to use those.
14:53:40 <monochrom> essentially, thanks to the idea of webfonts
14:53:41 <zzo38> byorgey: Yes, it is the Bob Profit Principle (which means that it is likely someone else think of the same idea you think of, but in the past).
14:53:49 <elliott> monochrom: that won't work in html mail
14:53:57 <elliott> unless they really do allow execution of arbitrary unchecked scripts accessing external resources
14:54:02 <antq> So, I've using uniplate uniplate for AST transformation, and now I'd like to do lambda lifting. However, I'd like it to track the bound variables as it descends during a transformM, buidling a list of them and, optionally, I'd also like it to know it's absolute "path" from the root. I see these both as the same problem but I'm not sure how uniplate might be used to do such a thing. Am I really going to have to do this the old fashioned way?
14:54:02 <elliott> which, uh... i doubt
14:54:13 <tikhonjelvis> elliott: No, just have people use it as a bookmarklet or extension.
14:54:27 <akosch> tikhonjelvis: I'm not sure I can get my recipients to do anything ;)
14:54:33 <monochrom> oh! mail, sorry, mathjax isn't entirely suitable
14:54:39 <zzo38> Many TeX codes just won't work in the webpages I try. I made up my own:    http://zzo38computer.cjb.net/texify/texify.htm
14:54:53 <tikhonjelvis> I think there's actually a gmail TeX plugin floating around too.
14:54:58 <elliott> tikhonjelvis: i doubt mathjax will apply properly to, e.g. a gmail page
14:55:03 <elliott> with all its frames and weird js and stuff
14:55:14 <tikhonjelvis> Hmm, I don't know. I'd have to try.
14:55:19 <zzo38> Supports colors, AMS-fonts, rotation, sizes, display error messages, etc
14:55:21 <zachk> send a pdf attachment , or post it someone and link
14:55:22 <monochrom> gmail probably drops your javascript anyway
14:55:25 <zachk> somewhere
14:55:32 <tikhonjelvis> http://alexeev.org/gmailtex.html
14:55:34 <elliott> monochrom: bookmarklet was the context
14:55:51 <zzo38> You can make a copy of the output of my program if you need those things
14:55:53 <tikhonjelvis> I don't know if it actually works, but it exists.
14:56:33 <monochrom> zzo38: have you seen mathbin.net ?
14:56:53 <zzo38> monochrom: Yes, and it doesn't work.
14:56:55 <monochrom> it seems to support a large variety of math tex code
14:57:03 <monochrom> ok, then cool
14:58:13 <zzo38> In mine, I have still disabled many commands, such as \write \read \openin \openout \special \font \input and so on. But \def and ^^ and stuff still works.
14:58:31 <monochrom> that is a tall order!
15:00:35 <zzo38> Here is the full list of commands which are disabled:   \special \font \errorstopmode \input \openout \openin \closeout \closein \write \read \immediate \errmessage \jobname \fontname \mag \magnification \dump   All other commands work. If you try to use a disabled command you will get an error message, even if you call the command in some other way such as ^^ or \csname or whatever else
15:00:53 <antq> no uniplate experts around "tonight"?
15:02:07 <zzo38> It uses a custom format file:   http://zzo38computer.cjb.net/texify/texify.php?source=3
15:02:37 <monochrom> God, you really hack TeX :)
15:06:26 <zzo38> monochrom: Yes.
15:06:44 <elliott> :D
15:11:59 <siracusa> zzo38: In \def\fitdisplay#1$${#1\relax\hskip ...} why do you need a \relax before \hskip?
15:13:12 <zzo38> To ensure the mode is correct. TeX sometimes is in the wrong mode during expansion, and \relax is not expandable so it ensure it to be correct.
15:14:49 <siracusa> But \hskip is not expandable too?
15:15:10 <zzo38> Correct \hskip is also not expandable. I was refering to the stuff in #1
15:15:40 <zzo38> It probably isn't needed there but is there just to make sure
15:15:57 <siracusa> okay
15:16:53 <zzo38> I have once tried to write a shortest FizzBuzz program in TeX, and this is what I came up with:   \newcount\-\let~\advance\day0\loop~\-1~\day1~\mit\ifnum\-=3\-0Fizz\fi\ifnum\fam=5Buzz\rm\fi\ifvmode\the\day\fi\endgraf\ifnum\day<100\repeat\bye
15:17:09 <zzo38> It probably confuses most people
15:18:21 <zzo38> Since \mit is ordinarily used only in math mode to select the math italic font (it doesn't change the font outside of math mode).
15:20:04 <zachk> so you use the \mit to `default the mode?
15:21:45 <zzo38> No. The math font family is reset when math mode is entered anyways. Also notice that I use \rm even though that is the default outside of math mode. And tihs FizzBuzz program doesn't even use math mode.
15:21:46 * ski__ . o O ( yin-yang continuations puzzle )
15:25:33 <mekeor> while importing a module i can use "hiding". can i do that while exporting a module, too? i image something like "module Foo hiding bar where"
15:25:45 <siracusa> zachk: I guess it's just a misusing the \fam counter :-)
15:25:49 <gregATio> is there a function called "ord"
15:25:57 <gregATio> what module is it in
15:26:02 <mekeor> @hoogle ord
15:26:03 <lambdabot> Prelude class Eq a => Ord a
15:26:03 <lambdabot> Data.Ord class Eq a => Ord a
15:26:03 <lambdabot> Prelude data Ordering :: *
15:26:13 <elliott> lambdabot...
15:26:14 <gregATio> thanks
15:26:15 <elliott> gregATio: it's in Data.Char
15:26:21 <elliott> it converts a Char to its codepoint number
15:26:27 <gregATio> @hoogle ord
15:26:28 <lambdabot> Prelude class Eq a => Ord a
15:26:28 <lambdabot> Data.Ord class Eq a => Ord a
15:26:28 <lambdabot> Prelude data Ordering :: *
15:26:38 <elliott> and lambdabot doesn't know about it. :|
15:26:44 <gregATio> lol
15:26:45 <gregATio> thanks
15:26:48 <elliott> mekeor: no, you can't
15:26:54 <mekeor> what a bummer.
15:27:03 <mekeor> elliott: what's the alternative?
15:27:03 <elliott> mekeor: the module system sucks :)
15:27:06 <zzo38> siracusa: Yes.
15:27:08 <elliott> mekeor: writing out every export
15:27:09 <mekeor> oh, i see.
15:27:10 <ski__> @index ord
15:27:11 <lambdabot> Data.Char
15:27:13 <elliott> apart from the one you don't want
15:27:16 <mekeor> elliott: ARGH
15:27:23 <elliott> mekeor: it's good practice anyway :P
15:27:26 <elliott> just keep telling yourself that
15:27:34 * mekeor listens
15:27:37 <elliott> mekeor: however.
15:27:41 <elliott> you _can_ do this:
15:27:45 * mekeor listens
15:27:48 <ski__> @hoogle ord
15:27:49 <lambdabot> Prelude class Eq a => Ord a
15:27:49 <lambdabot> Data.Ord class Eq a => Ord a
15:27:49 <elliott> Foo.Internal: module Foo.Internal where ...
15:27:49 <lambdabot> Prelude data Ordering :: *
15:27:50 <ski__> @hoogle+
15:27:51 <lambdabot> Data.Ord data Ordering :: *
15:27:53 <lambdabot> Data.Ord module Data.Ord
15:27:55 <lambdabot> Data.Char ord :: Char -> Int
15:27:56 <ski__> ^
15:27:57 <elliott> Foo: module Foo (module Foo.Internal) where import Foo.Internal hiding (Bar)
15:28:01 <elliott> mekeor: ^
15:28:17 <elliott> but uh, I'd just list the imports.
15:28:18 <mekeor> elliott: oh right!
15:28:21 <elliott> oh god.
15:28:23 <elliott> you're actually going to do that.
15:28:34 <mekeor> er, i am considering it, yes.
15:28:35 <mekeor> heh
15:29:01 <mekeor> elliott: but why is listing everything better in your opinion?
15:29:53 <elliott> mekeor: another file with an Internal module whose purpose is not obvious to most readers is IMO heavier than just listing exports, which is generally considered good practice anyway
15:30:09 <elliott> I would certainly spend a few minutes trying to figure out why you have an .Internal module; my first suspicion would be that you're importing it elsewhere in the package
15:30:57 <mekeor> elliott: hm. okay.
15:32:56 <rostayob> mm_freak: so did you manage to write that instance?
15:33:55 <elliott> rostayob: what is the instance, again?
15:34:03 * elliott almost wants to implement it out of sympathy :P
15:34:20 <rostayob> elliott: ArrowLoop for 'data SP a b = Put b (SP a b) | Get (a -> SP a b)'
15:34:32 <elliott> ooh, that sounds like fun!
15:34:45 <rostayob> elliott: i gave up after a while
15:35:08 <rostayob> it's the second exercise in john huges tutorial on arrows. damn you john huges.
15:35:09 <elliott> rostayob: I take it in Get (\n -> Put 42 ...), n should be 42?
15:35:52 <rostayob> elliott: mhm?
15:35:56 <elliott> right
15:36:08 <rostayob> that data type is used to process lists
15:36:15 <elliott> yeah, I know its purpose
15:36:21 <elliott> i was just checking that Gets could get future Puts
15:36:23 <elliott> with loop
15:36:30 <rostayob> yeah that's the idea
15:40:35 * roconnor doesn't understand how to format case statements :(
15:40:48 <rostayob> newline, 4 spaces?
15:42:01 <roconnor> http://hpaste.org/56815
15:42:05 <roconnor> what's wrong with this?
15:42:09 <roconnor> (inside a do expression)
15:42:11 <elliott> not the case
15:42:12 <elliott> the let
15:42:16 <elliott> you need to indent as far as the identifier
15:42:25 <elliott> think of it like e.g. a where block in a declaration
15:42:30 <elliott> you could also \n<indent> after "let"
15:42:32 <roconnor> I didn't know that
15:42:39 <elliott> it's annoying :(
15:42:46 <elliott> iirc monochrom gave an example of why you can't "fix" it
15:43:13 <elliott> roconnor: that said, one-space indentation?!
15:43:40 <rostayob> yeah man, really.
15:43:54 <elliott> i could even accept 3-space indentation
15:43:57 <elliott> but i draw the line at 1
15:46:02 <monochrom> the body of f must be indented more than the name of f, since there is always the possibility of a sibling definition in the same let block
15:46:03 <roconnor> I would normally put the case up on the let line
15:46:16 <roconnor> I was just trying to get anything to work
15:46:22 <roconnor> (though braces did work
15:47:21 <monochrom> but I forgot what example I gave and what other reasons I said
15:48:16 <rostayob> elliott: i think i'm going to bed, do you think that instance is doable, so that loop (arr id) = arr id?
15:48:40 <elliott> rostayob: erm, does that hold in general?
15:48:44 <Saizan> ?type loop
15:48:45 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
15:48:55 <rostayob> elliott: no, but huges wants that to hold for that
15:49:09 <elliott> rostayob: it sounds doable i think... do you have a link to the definition? i want to steal the arrow instance because i'm lazy :P
15:49:22 <elliott> monochrom: you could allow indentation of less than the "let "
15:49:33 <elliott> that discriminates against people with 4-space indents though
15:49:48 <hpaste_> rostayob pasted “Stuff about SP - elliot” at http://hpaste.org/56817
15:49:56 <rostayob> ^^^ that's what I had before getting stuck.
15:50:00 <elliott> thanks
15:50:21 <monochrom> oh, like "let\n f x = blah"?
15:50:48 <elliott> monochrom: like "let f x = do\n ..."
15:50:55 <elliott> that can't be another definition in the let block
15:50:58 <elliott> and it can't be a statement
15:51:00 <elliott> so you could technically allow that
15:51:10 <elliott> but it'd break as soon as someone tried to use 4 spaces there
15:51:15 <elliott> because it'd line up as a new definition
15:52:51 <Sgeo> @hoogle CWchar -> Word16
15:52:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:52:52 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
15:52:52 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:52:55 <Sgeo> Lovely
15:53:08 <rostayob> unsafeCoerce, my favourite type
15:53:27 <Sgeo> I just want to turn a Ptr CWchar into Text
15:53:29 <Sgeo> :/
15:53:40 <rostayob> CWchar?
15:53:47 <Sgeo> rostayob, wchar_t
15:53:56 <rostayob> i don't know what it is, but you have fuctions for CString
15:54:19 <Sgeo> I want to try to avoid them
15:54:22 <elliott> Sgeo: CWchar is probably Integral.
15:55:00 <elliott> So --> Ptr Word16 --> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/Data-Text-Array.html
15:55:10 <elliott> Oh
15:55:10 <elliott> http://hackage.haskell.org/packages/archive/text/0.11.1.12/doc/html/Data-Text-Foreign.html
15:55:14 <elliott> --> Ptr Word16 --> that
15:55:27 <elliott> fromPtr specifically.
15:55:47 <elliott> "Integral CWchar" -- yep.
15:55:48 <Sgeo> Is it guaranteed that it will work on all platforms
15:55:50 <elliott> Sgeo: no
15:55:53 <Sgeo> :(
15:56:01 <elliott> that's why you have to explicitly convert and decode
15:56:22 <Sgeo> Maybe I should just convert to a String then convert that to Text
15:56:42 <elliott> how do you plan to convert it to a String?
15:56:50 <Sgeo> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Foreign-C-String.html
15:57:02 <elliott> ah
15:57:25 <rostayob> elliott: going to bed. i'm really curious how the SP thing can be done
15:57:37 <elliott> Sgeo: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/Foreign-C-String.html#peekCWString
15:57:40 <rostayob> so if you manage... let me know :)
15:57:41 <elliott> just copy that
15:57:49 <elliott> rostayob: alright. btw, your Category instance differs from Hughes' (>>>) definition
15:57:53 <elliott> it may have equivalent semantics, dunno
15:58:13 <rostayob> elliott: where did you get Huges' definition?
15:58:36 <elliott> Generalising Monads to Arrows
15:58:42 <elliott> http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
15:58:48 <elliott> oh, that's not the tutorial you mentioned
15:58:54 <elliott> i just assumed :)
15:59:06 <rostayob> nope, the tutorial i was referring to is 'Programming with arrows'
15:59:08 <Sgeo> elliott, looking at the source, I don't think copying the source of that will be any more efficient than just doing that then String -> Text
15:59:30 <Sgeo> Well, hmm, maybe a little
15:59:55 <Sgeo> More importantly, it would be annoying to do
15:59:58 <elliott> Sgeo: The -> String conversion is "strict".
16:00:02 <elliott> How big are your strings?
16:00:09 <elliott> rostayob: I'll look at that too, then
16:00:30 <Sgeo> elliott, probably not that larger
16:00:32 <Sgeo> *large
16:00:44 <Sgeo> Well, some of them may be large, but I doubt anything that won't comfortably fit into memory
16:00:45 <rostayob> elliott: i'll take a look at the other one, tomorrow
16:00:47 <rostayob> thanks
16:00:52 <JoeyA> Why does Network.Socket use unsafe FFI calls for functions that can clearly block?  e.g. foreign import CALLCONV unsafe "connect"
16:01:02 <elliott> Sgeo: How large?
16:01:09 <elliott> Of course they comfortably fit into memory, you have a Ptr to them.
16:01:22 <elliott> JoeyA: unsafe isn't about blocking, it's about calling back into Haskell
16:01:28 <elliott> well, OK, it does change the blocking behaviour
16:01:30 <Sgeo> elliott, dunno, varies
16:01:41 <elliott> but it's not "unsafe" to do that, I don't think
16:01:44 <JoeyA> An unsafe FFI call blocks the whole RTS when it blocks.
16:01:44 <monochrom> yikes, that may be a glaring mistake
16:01:49 <elliott> Sgeo: 1 megabytes? 10 megabytes?
16:01:52 <elliott> 100?
16:01:55 <elliott> *megabyte
16:02:17 <elliott> JoeyA: i'd report a bug
16:02:20 <Sgeo> I'd be shocked if it was even 1MB most of the time. Some of the time it might be large, the documentation lists some of them as "long"
16:02:22 <JoeyA> I tested Network.Socket.connect on Win32 with -threaded, and it does block my program.
16:02:29 <JoeyA> Moral of the story: use safe FFI calls, people!
16:02:34 <Sgeo> I think those are the ones that I want to do ByteString, not Text, though
16:02:50 <monochrom> is it fixed in the latest version on hackage?
16:03:04 <JoeyA> I don't think so.
16:03:09 <monochrom> eww
16:03:25 <JoeyA> I'll first test my program with the proposed fix, then maybe send an issue.
16:07:44 <Sgeo> elliott, the absolute maximum is apparently 4095... either characters or bytes, the documentation seems to confuse them
16:10:18 <elliott> Sgeo: Okay, you could do each conversion a few thousand times and not notice the difference.
16:10:23 <elliott> So don't worry about it.
16:32:26 <Sgeo> elliott, now I'm wondering if I should even bother with Text
16:41:50 <roconnor> antq: I think there is an example using the state monad to do that sort of thing in the Uniplate paper
16:42:04 <mekeor> What's Data.IntMap (for) ?  I mean, I don't understand what kind of data structure it provides...
16:42:20 <hpc> mekeor: it's (Map Int), only faster
16:42:21 <mekeor> Is it like a list or like a set ?
16:42:33 <byorgey> it's like a map
16:42:42 <mekeor> what's a map ?
16:42:43 <cmccann> a map from Int specifically
16:42:44 <mekeor> >.>
16:43:04 <cmccann> mekeor, a key-value lookup
16:43:06 <hpc> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
16:43:06 <byorgey> mekeor: an association from keys of a certain type to values of another type
16:43:18 <byorgey> so you can look up by key and retrieve the associated value
16:43:37 <hpc> if you have used perl, it's a hash; if you've used python or javascript, it's a dict
16:43:59 <mekeor> so, it doesn't have anything in common with geography? (like google maps..) =)
16:44:01 <hpc> with some significant differences, but the general idea is the same
16:44:21 <DanBurton> Does "none = not .: any" exist in standard libs anywhere?
16:44:27 <hpc> mekeor: no, it's a map in the sense of "one-to-one *mapping*" or "map f xs"
16:44:43 <mekeor> hpc: okay. thank you :)
16:44:55 <byorgey> DanBurton: no, but it's also equivalent to  all . not
16:45:10 <DanBurton> indeed
16:45:35 <DanBurton> or rather, all . (not .), iinm
16:45:35 <hpc> DanBurton: (all . not) will have different performance too
16:45:48 <hpc> any will bail when the predicate is true, all will bail when false
16:46:02 <hpc> :t all .: not
16:46:03 <lambdabot>     Couldn't match expected type `g (a -> Bool)'
16:46:03 <lambdabot>            against inferred type `Bool'
16:46:03 <lambdabot>       Expected type: Bool -> g (a -> Bool)
16:46:18 * mekeor now understood what maps are.
16:46:21 <DanBurton> :t not .: any
16:46:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:46:27 <DanBurton> :t all . (not .)
16:46:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:46:34 <byorgey> uh, not .: any  and  any . (not .)  should have the same performance, shouldn't they?
16:46:36 <mekeor> :t (.:)
16:46:36 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:46:46 * cmccann suspects (not .:) would itself be useful enough to justify a dedicated name
16:46:49 <mekeor> @src (.:)
16:46:49 <lambdabot> Source not found. That's something I cannot allow to happen.
16:46:59 <hpc> :t (not .:P
16:47:00 <lambdabot> parse error (possibly incorrect indentation)
16:47:01 <hpc> :t (not .:)
16:47:01 <lambdabot> forall (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => f (g Bool) -> f (g Bool)
16:47:17 * cmccann sighs
16:47:19 <DanBurton> :t (not .:) `asAppliedTo` any
16:47:20 <lambdabot> forall a. ((a -> Bool) -> [a] -> Bool) -> (a -> Bool) -> [a] -> Bool
16:47:36 <mekeor> @hoogle (.:)
16:47:36 <lambdabot> No results found
16:47:40 <DanBurton> @let jk = (not .:)
16:47:41 <mekeor> what's .: ?
16:47:41 <lambdabot>  Defined.
16:47:44 <DanBurton> :t jk any
16:47:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:47:46 <hpc> perhaps (.:) needs a prefix name
16:47:50 <hpc> mekeor: fmap . fmap
16:48:11 <hpc> aka, "fmap two levels deep"
16:48:45 * cmccann was really only thinking of the function composition aspect
16:49:01 * mekeor didn't use functors yet (afaik)
16:49:03 <cmccann> i.e. a version of not that negates the result of a function (a -> b -> Bool)
16:49:26 <cmccann> seems like something that comes up pretty often
16:49:50 <DanBurton> :t jk `asAppliedTo` (undefined :: a -> b -> Bool)
16:49:51 <lambdabot> forall a b. (a -> b -> Bool) -> a -> b -> Bool
16:50:43 <DanBurton> cmccann: that doesn't sound like a strong argument for (not .:) to be in standard libraries so much as just sticking .: in standard libraries
16:51:18 <hpc> (.:) is one of my favorite infix functions
16:51:39 <cmccann> DanBurton, there are plenty of standard library functions defined as simple composition of other standard functions
16:51:45 <hpc> competing with (<$>), (<|>), and (??)
16:51:45 <Sgeo> You can think of a Map a b as being similar to a function a -> Maybe b
16:51:54 <Sgeo> You give it an a, and you might get back a b.
16:55:13 <DanBurton> @define mapToFunc m = \k -> lookup k m
16:56:06 <elliott> My favourite spelling of "not on function of two arguments" is (result . result) not.
16:56:08 <DanBurton> The difference is that it's more efficient to create a new map with a different value at a given key than it is to create a new function with a different output for a given input
16:56:24 <elliott> There's more difference than that.
16:56:36 <antq> roconnor: hmm ok. i've been reading it actually and all i've seen so far is para which only works with Uniplate (not Biplate). i'll do a search through it though. thanks
16:56:41 <DanBurton> s/The difference/one important difference
16:56:42 <elliott> For instance, a Map can only be Just for a finite number of values, and it can produce a list of those values.
16:57:27 <nand`> how expensive is appending to the end of a ByteString?
16:57:33 <elliott> cmccann: true, but those generally have special use
16:57:38 <shachaf> nand`: Five dola
16:57:51 <elliott> cmccann: "not" on a function of two arguments is not so important as to require its own name compared to any other mapping of a result of a function of two arguments
16:58:11 <roconnor> antq: see example 5
16:58:30 <elliott> nand`: O(n)
16:58:31 <cmccann> elliott, I'm not saying that I wouldn't want (.:) as well :P
16:58:35 <Axman6> nand`: strict or lazy?
16:58:36 <elliott> cheaper for lazy bytestrings i think
16:58:45 <hpc> @hoogle String -> String
16:58:45 <lambdabot> Data.Data tyconModule :: String -> String
16:58:45 <lambdabot> Data.Data tyconUQname :: String -> String
16:58:45 <lambdabot> Test.QuickCheck.Text bold :: String -> String
16:58:47 <elliott> cmccann: (.:) is overrated :)
16:58:49 <hpc> :t cycle
16:58:50 <lambdabot> forall a. [a] -> [a]
16:58:56 <elliott> cmccann: (result . result) not is easier to understand than (not .:) if you ask me.
16:59:16 <roconnor> antq: which apparently doesn't use state monad :^)
16:59:24 * cmccann shrugs
16:59:33 <nand`> Axman6: Data.ByteString.Char8, which I guess is strict
16:59:38 <cmccann> (.:) is easy to understand once you know what it means :P
16:59:48 <prof7bit> wow, i just discovered something...
16:59:50 <nand`> is (.:) the same as (.).(.)?
16:59:53 <elliott> yes
16:59:56 <Axman6> nand`: O(n)
17:00:09 <nand`> I keep defining that in ghci, very handy
17:00:15 <nand`> Axman6: alright, cool
17:00:18 <elliott> cmccann: I agree that binary is an unusually common case, but the SEC style is just so much more general *shrug*
17:01:06 <hpc> nand`: haskell is a family-friendly language; we can't go putting the boobs operator in all our code :P
17:01:35 <prof7bit> http://hpaste.org/56821
17:01:42 <prof7bit> this is crazy :-)
17:01:46 <Axman6> we have to settle for the tripple nipple instead hpc
17:01:56 <hpc> haha
17:01:56 <antq> roconnor: example 5? talking about CAF? actually after seeing 12 again, i'm thinking of just stacking transformM's... should work
17:02:41 <elliott> I also like { under o k = result k . argument o } -- you can say { inEndo = under appEndo } and then mappend = (inEndo . inEndo) Endo mappend
17:02:58 <elliott> similar to Newtype
17:03:41 <roconnor> antq: example 5 needs to remember bound variables
17:04:55 <guerrilla> i wonder if we're reading the same version of the document
17:05:53 <guerrilla> "Transformation and Analysisof Functional Programs" by N. Mitchel - June 2008 - official submission
17:05:54 <ski__> @type let (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f in \o k -> result k . argument o
17:05:55 <lambdabot> forall a b a1 a2. (a1 -> a2) -> (a -> b) -> (a2 -> a) -> a1 -> b
17:06:04 <elliott> prof7bit: you can also write that
17:06:05 <ski__> @type let (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f in (~>)
17:06:06 <lambdabot> forall (f :: * -> *) a a1 b. (Functor f) => f a -> (a1 -> b) -> (a -> a1) -> f b
17:06:07 <elliott> sqrt <$> [1,2,3]
17:06:10 <elliott> which is map sqrt [1,2,3] :P
17:06:18 <elliott> prof7bit: [sin, cos] <*> [...] is more impressive
17:06:23 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f in (~>)
17:06:24 <lambdabot> forall a b b1 c. (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
17:06:43 <elliott> ski__: /me prefers defining argument and result as the primitives
17:06:49 <elliott> (~>) can be built on top of them
17:07:24 <elliott> type Under big small = forall a r. (a -> r) -> (small -> a) -> big -> r
17:07:24 <elliott> under :: (big -> small) -> Under big small
17:07:24 <elliott> under o k = result k . argument o
17:07:24 <elliott> ^ Under shows the continuation-passing nature of it more clearly
17:07:34 <ski__> elliott : yeah, but should it be `result k . argument o' or `argument o . result k', then ?
17:07:41 <prof7bit> elliott: yes, i was just reading the chapter about applicatives in the typeclassopedia and looked at the definition of pure and thought: why not try to use the [] notation wich is defined the same way
17:07:49 <hpc> ski__: i think the two are the same
17:07:58 <guerrilla> roconnor: aha, you're reading, "Uniform Boilerplate and List Processing" - that explains why i didn't know what you were talking about :)
17:08:00 <elliott> ski__: i prefer the former; processing arguments before results makes sense to me
17:08:03 <ski__> hpc : exactly, so which should we write in the code ?
17:08:05 <elliott> well
17:08:10 <elliott> "before" in a very loose sense :)
17:08:20 <elliott> prof7bit: hehe
17:08:33 <ski__> it seems to me none are better than the other : therefore i prefer not to define `(~>)' in terms of `argument' and `result'
17:08:33 <hpc> elliott: "outside", perhaps?
17:08:45 <Lajla> Is elliott spelt with 2 ts?
17:08:49 <Lajla> I had no idea.
17:08:51 <elliott> my elliott is
17:08:53 <hpc> in the sense of (f . g) x = {- outside -} f ({- inside -} g x)
17:08:55 <elliott> other elliotts aren't necessarily
17:08:58 <prof7bit> i didn't even expect the [] to accepr a funtion. but it did!
17:08:59 <Lajla> Ahh
17:09:02 <elliott> hpc: but i preferred the former, which has result on the outside there :)
17:09:05 <Lajla> Sounds British
17:09:15 <Anpheus_> Anyone here know a bit about conduits, and want to help me grok the right way to do something?
17:09:16 <Lajla> I don't think Elliotts exist out of that Island.
17:09:26 <elliott> Lajla: Conal Elliott is also spelled Elliott, and I think there's another two Haskeller Elliotts running around the place
17:09:28 <guerrilla> roconnor: perfect, i see the patter now :) thanks.
17:09:36 <elliott> it's an unusually common name in Haskell for some reason, even though the spelling isn't very common
17:09:43 <elliott> I'm British, at least :P
17:10:00 <hpc> elliott: i blame bowties
17:10:03 <Lajla> elliott, I knew this British guy, he was named Nigel, his wife was named Emma.
17:10:09 <hpc> they are unusualness magnets
17:10:09 <Lajla> True story.
17:10:15 <ski__> elliott : why not `type Over light heavy = forall s b. (s -> heavy) -> (b -> light)', showing the state-in-context-passing nature of it all ?
17:10:23 <hpc> Lajla: cool story bro :P
17:10:56 <elliott> ski__: you can't implement any (Over light heavy)s, can you?
17:11:05 <elliott> at least there's nowhere to get an s
17:11:44 <Lajla> hpc, weren't you the one talking abotu Nestea?
17:12:01 <hpc> that's probably someone else
17:12:19 <hpc> pretty much half of #haskell has 3-character nicks, so it's easy to get confused
17:12:27 <Lajla> True
17:12:52 <Lajla> If you are named Hewlett Paxton Carlton you might also be British.
17:12:53 <ski__> elliott : oh sorry, missed to write the `b -> s' part of it : `type Over light heavy = forall s b. (b -> s) -> (s -> heavy) -> (b -> light)'
17:13:19 <elliott> ski__: hmm... how would that be used?
17:13:32 <elliott> fwiw, my "under" arose from operating "under" a newtype
17:13:44 <elliott> and big/small being the "wrapper"/consituent of the typei n question
17:14:55 <PardonMyRhetoric> http://www.tylerprete.com/2007/07/12/problem-spam-egg-list/  Would that problem be possible in Haskell, considering that it's functional and pure and only allows homogeneous lists?
17:15:42 <elliott> no
17:15:47 <elliott> you just need to represent the intended data type properly
17:15:59 <elliott> In this case it'd be Free [] a or something
17:16:06 <ski__>   over :: (heavy -> light) -> Over light heavy
17:16:06 <ski__>   over k o = o ~> k
17:16:07 <parcs`> or a rose tree
17:16:11 <elliott> yeah
17:16:11 <ski__> elliott : something like that
17:16:27 <PardonMyRhetoric> ah, I see
17:16:28 <ski__> elliott : note that i have no idea what `under' (nor `over') is good for ..
17:16:40 * prof7bit is speechless...  [(+)] <*> [1,2] <*> [3,4]          mind -> altered
17:16:43 <cmccann> rose trees are the free monad for [], aren't they?
17:16:51 <elliott> cmccann: not quite
17:16:58 <elliott> Var 42 :: Free [] Int
17:17:04 <elliott> oh, hmm
17:17:06 <elliott> i guess they might be isomorphic
17:17:11 <hpc> prof7bit: more idiomatic would be (+) <$> ...
17:17:12 <elliott> ski__: i showed what under is good for -- say you have: newtype Endo a = Endo { appEndo :: a -> a }, as in Data.Monoid
17:17:13 <ski__> i just thought it was strange to focus on continuations as opposed to state-in-context, here ..
17:17:18 <cmccann> oh right, rose trees have labelled nodes
17:17:21 <elliott> ski__: and you want to define mappend (Endo a) (Endo b) = Endo (mappend a b)
17:17:24 <cmccann> so not exactly the same
17:17:27 <elliott> typeclass morphism-style definitions
17:17:31 <hpc> but yeah, applicatives are crazy
17:17:41 <elliott> ski__: you can define: inEndo = under appEndo, and do: mappend = (inEndo . inEndo) Endo mappend
17:18:11 <ski__> elliott : that's basically `(~>)' -- what i didn't understand was what the type signature in `under :: (big -> small) -> Under big small' is much good for
17:18:12 <elliott> you can also do (inEndo . inEndo) Endo (.) to define composition, etc.
17:18:27 <prof7bit> hpc: i still can't get over the fact how i simply can put the [] arond the function and have it thereby lifted into the list context. mind boggling.
17:18:27 <elliott> ski__: oh, simply because
17:18:30 <elliott> inEndo :: Under (Endo a) (a -> a)
17:18:32 <elliott> is shorter than
17:18:47 <elliott> inEndo :: (a -> r) -> ((b -> b) -> a) -> Endo b -> r
17:18:52 <elliott> and easier to understand :P
17:19:08 <elliott> ski__: i don't think it's quite (~>). does (~>) generalise so easily to n-argument functions?
17:19:18 <elliott> note that you can also use e.g. under id
17:19:26 <elliott> if you have Endo a -> Int -> Endo a -> r or something
17:19:46 <elliott> (inEndo . under id . inEndo) id
17:19:57 * prof7bit needs to think about this for a while now...
17:22:17 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f in (~>) appEndo
17:22:18 <lambdabot> forall a b c. (b -> c) -> ((a -> a) -> b) -> Endo a -> c
17:22:21 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f; inEndo = (~>) appEndo in inEndo . inEndo
17:22:22 <lambdabot> forall a b c a1. (b -> c) -> ((a -> a) -> (a1 -> a1) -> b) -> Endo a -> Endo a1 -> c
17:22:25 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f; inEndo = (~>) appEndo in (inEndo . inEndo) Endo mappend
17:22:26 <lambdabot> forall a. (Monoid a) => Endo a -> Endo a -> Endo a
17:22:57 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f in (~>)
17:22:58 <lambdabot> forall a b b1 c. (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
17:23:12 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f; under o k = result k . argument o in under
17:23:13 <lambdabot> forall a b b1 c. (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
17:23:21 <ski__> elliott : looks the same, to me
17:23:44 <elliott> hmm
17:23:49 <elliott> ok
17:24:01 <elliott> under o k = (k .) . (. o), fwiw
17:24:23 <ski__> @type let (.) = (Prelude..); (f ~> g) h = g . h . f; argument f = f ~> id; result f = id ~> f in ((appEndo ~>) . (appEndo ~>)) Endo mappend
17:24:24 <lambdabot> forall a. (Monoid a) => Endo a -> Endo a -> Endo a
17:24:29 <ski__> elliott : yes
17:28:06 <hpaste_> elliott pasted “dumpList” at http://hpaste.org/56823
17:28:15 <elliott> argh, PardonMyRhetoric just left
17:28:25 <elliott> ski__: right
17:28:33 <elliott> ski__: using (~>) in sections like that is ugly though :P
17:29:30 <elliott> http://jroller.com/sto/entry/nested_list_question wow, what an ugly solution
17:30:32 <ski__>   (~>) :: forall a0 a1 b0 b1. (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1))
17:30:55 <ski__>   (~>) :: forall a0 a1. (a1 -> a0) -> (forall b0 b1. (b0 -> b1) -> (a0 -> b0) -> (a1 -> b1))
17:31:14 <ski__>   flip (~>) :: forall a0 a1 b0 b1. (b0 -> b1) -> (a1 -> a0) -> ((a0 -> b0) -> (a1 -> b1))
17:31:31 <ski__>   flip (~>) :: forall b0 b1. (b0 -> b1) -> (forall a0 a1. (a1 -> a0) -> (a0 -> b0) -> (a1 -> b1))
17:32:30 <JoeyA> Is it possible to "force quit" a thread?  (e.g. one hung on a foreign call)
17:34:54 <elliott> JoeyA: not on foreign calls
17:35:00 <elliott> but killThread works with threads stuck on e.g. standard IO
17:35:19 <elliott> due to its non-blocking implementation
17:35:58 <JoeyA> It doesn't have a non-blocking implementation on Windows, where I need it...
17:36:37 <JoeyA> thanks
17:38:23 <elliott> JoeyA: well, yes, it cannot help you work around bugs :P
17:58:46 <DanBurton> @pl foo a b = bar a =<< b
17:58:46 <lambdabot> foo = (=<<) . bar
18:00:26 <stepkut> I wrote a tutorial on using Data.Lens, but.. I just learned how to use Data.Lens yesterday, so I would love to hear if I am doing it right before I misinform too many people: http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
18:00:55 <DanBurton> I'll check it out. Disclaimer: I've never "actually" used lenses
18:00:58 <stepkut> it covers ixLens as well.. but that is basically the same as mapLens
18:01:14 <stepkut> so.. it should appeal to anyone that wants to use lenses
18:01:21 <stepkut> DanBurton: awesome!
18:01:50 <stepkut> seems to me that the precedence of some of the lens operators is wrong.. I need ( ) where I don't feel like I should
18:02:03 <Saizan> stepkut: on a side note, a less acid color scheme wouldn't hurt
18:02:04 <DanBurton> "like arrows but even worse" :) not sure if that's possible
18:02:48 <stepkut> DanBurton: CoArrows?
18:02:48 <DanBurton> Saizan: what did you expect from AcidState.html? :)
18:03:04 <DanBurton> stepkut: are those even real?
18:03:08 <tikhonjelvis> Saizan: I used to use a really similar color scheme for actually editing code...
18:03:42 <stepkut> Saizan: yeah.. I am not thrilled about the colors either.. I need to find a good scheme for coloring Haskell on a black background
18:03:52 <elliott> stepkut: looks correct to me
18:03:54 <tikhonjelvis> Does it have to be black?
18:04:02 <hpc> stepkut: i am fond of vim's default scheme
18:04:08 <elliott> the black is not nice with the white page
18:04:14 <elliott> stepkut: you might want to mention getL/setL/modL
18:04:24 <elliott> the operators are a little noisy for my tastes at least
18:04:33 <elliott> and getL is nicer to section with
18:04:34 <ski__> (white page ?)
18:04:34 <stepkut> elliott: you think the examples should not be on a black background?
18:04:37 <elliott> i.e. map (getL foo)
18:04:41 <elliott> stepkut: indeed
18:04:52 <elliott> black code blocks are kind of jarring on a page with such a bright text background
18:05:00 <stepkut> gray?
18:05:04 * ski__ thinks the whole page should be with dark background ..
18:05:20 <elliott> stepkut: maybe, just anything without too much contrast :)
18:05:23 <tikhonjelvis> How about some rounded corners?
18:05:36 <elliott> And Comic Sans!
18:05:43 <Saizan> black is not the only dark background :)
18:05:47 <tikhonjelvis> Now we're getting somewhere.
18:05:59 <tikhonjelvis> One of my friends actually hacked together a monospace version of Comic Sans.
18:06:16 <hpc> dark gray, with a lighter gray border of some sort, would be my suggestion
18:06:20 * cmccann suggests using the Dijkstra handwriting font
18:06:27 <DanBurton> needs more Papyrus font
18:06:47 <tikhonjelvis> As a compromise, just use a different font for each color. You can't go wrong1
18:06:56 <cmccann> yes
18:06:57 <DanBurton> stepkut: I see what you mean with the fixities. You'd think ^. would associate the other way
18:06:59 <Saizan> anyhow, let's focus on the lenses
18:07:22 <cmccann> *rimshot*
18:07:22 <stepkut> I made it a bit lighter.. not sure if it is better, worse, or the same now
18:07:30 * ski__ has no idea what font he's seeing here
18:07:58 <elliott> stepkut: a bit worse I think, since the foreground colours are all designed for a black background
18:08:02 <stepkut> yeah
18:08:29 * elliott doesn't know how good its Haskell support is, but http://pygments.org/ iirc has a command-line tool thing, and nice themes
18:08:33 <stepkut> i changed it back for now
18:08:48 <stepkut> I am thinking of changing the theme for the entire site soon anyway
18:08:54 <cmccann> how about lightly shaded gray text on a slightly darker gray background
18:09:16 <cmccann> you could make the page background light gray while you're at it
18:09:16 <stepkut> cmccann: my favorite! and 8pt so people don't have to scroll as much..
18:09:22 <cmccann> yes
18:09:24 <cmccann> good plan
18:09:30 <elliott> Don't forget to change the cursor.
18:09:37 <elliott> and scrollbar colours (remember when webpages could set scrollbar colousr?)
18:09:42 <elliott> *colours
18:09:44 <elliott> also, lots and lots of frames
18:09:53 <elliott> preferably each paragraph should go in a fixed-size iframe
18:09:53 * stepkut remembers when the <blink> and <marque> tags actually did something
18:09:58 <elliott> marquee still does something!
18:10:01 <elliott> they only killed <blink>
18:10:08 <stepkut> ah
18:10:09 <elliott> <marquee> is stronger. <marquee> can never die
18:10:50 <hpc> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454 -- related
18:10:57 <cmccann> hahahaha
18:10:59 <tikhonjelvis> Bah, none of that holds a candle to CSS3.
18:11:19 <cmccann> hpc, the <center> cannot hold
18:11:53 <hpc> cmccann: my favorite part is at the very end, "tony the pony"
18:12:11 <cmccann> hpc, yeah, but that's just a running joke from SO I think
18:12:12 <DanBurton> TIL <marquee> exists
18:12:24 <stepkut> I thought it was gone, but it turns out I was just using it wrong
18:12:33 <stepkut> http://www.mountaindragon.com/html/marquee.htm
18:12:41 <elliott> you're not worthy
18:12:45 <stepkut> the scrolling ones work in chrome atleast
18:12:53 <elliott> you can make whole animations by nesting marquees!
18:14:24 <elliott> i wonder what the last time someone implemented <marquee> was
18:14:28 <elliott> and what they were thinking
18:14:36 <elliott> I guess Chrome's is inherited from WebKit from KHTML
18:15:08 <stepkut> this one works on firefox, http://as-massive-tool.livejournal.com/17219.html
18:16:46 * cmccann writes a web browser that only supports <marquee>, <blink>, frames, and little things trailing behind the mouse cursor
18:17:20 <elliott> cmccann: Um, excuse me. You need to be able to set the background colour to #f00 too.
18:17:33 <elliott> Those are the five useful features of HTML.
18:17:34 <tikhonjelvis> And nonstop music!
18:17:37 <cmccann> hm, good point
18:17:41 <elliott> Oh, yes.
18:17:41 <cmccann> ah, yes
18:17:52 <elliott> Do it with <audio> for extra standards compliance, but ignore all <audio>s not set to autoplay.
18:17:55 <tikhonjelvis> I loved animated backgrounds with music when I was in 8th grade.
18:18:08 <cmccann> elliott, I'll just have them autoplay anyway
18:18:11 <cmccann> even if there's more than one
18:18:17 <cmccann> no, especially if there's more than one
18:18:47 <cmccann> oh, and yeah, background images are supported, but only animated GIFs
18:19:14 <cmccann> animated GIFs and full-saturation colors are the only supported backgrounds
18:19:16 <tikhonjelvis> Yeah, that pretty much describes half of my school projects back in the day...
18:20:23 * cmccann decides not to support flash, though, that's going too far and not funny anymore
18:20:30 <stepkut> i think browsers should have the old TI text-to-speach built in..
18:20:42 <elliott> well cmccann's browser doesn't support text
18:20:48 <elliott> so it should just automatically read it out to you instead
18:20:49 <cmccann> it does
18:20:53 <cmccann> but only inside marquee and blink tags
18:20:56 <elliott> ah
18:21:02 <stepkut> s/speach/speech/
18:21:05 <elliott> what if i nest two marquees so that the contents end up not moving at all
18:21:14 <elliott> does it enforce a minimum rate of movement?
18:22:20 <cmccann> maybe, haven't decided how to handle that yet
18:22:48 <hpc> elliott: the two marquee tags need to be perfectly aligned, or the opposite forces send the text into a spin :P
18:22:53 <cmccann> maybe I should just support images as well
18:22:57 <cmccann> so that people can put text in those
18:24:37 <elliott> cmccann: only jpegs of quality level 50 or lower
18:24:59 <Axman6> hmm, what's list difference in haskell again?
18:25:08 <elliott> :t (\\)
18:25:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
18:25:31 <elliott> (that was at Axman6)
18:25:47 <Axman6> hmm
18:25:52 <cmccann> elliott, or I could make it more convenient, and just JPEG-ify anything else
18:25:55 <cmccann> at very low quality of course
18:26:05 <cmccann> jpeg artifacts everywhere!
18:26:05 <elliott> cmccann: anything else? I don't see why you should exclude the images that are already jpegs
18:26:07 <Axman6> ok, i need a function which tells me which elements of one list are not in the other
18:26:17 <cmccann> good point, just convert everything
18:26:18 <elliott> > [1,2,3] \\ [2,3]
18:26:19 <lambdabot>   [1]
18:26:34 <elliott> > [1,2,3] \\ [2,3,1]
18:26:35 <lambdabot>   []
18:26:48 <hpc> > [1, 1, 1] \\ [1]
18:26:49 <lambdabot>   [1,1]
18:27:29 <cmccann> elliott, wait I know how to handle nested marquee tags
18:27:35 <cmccann> just make sure they can't be exactly the same size
18:27:39 <ski__> cmccann : make sure you display everything using the C64 font
18:27:41 <carter> Hey all, I've worked out a simple, easy way to have gtk everything easily work  on os x lion in both ghc and ghci, https://gist.github.com/1655271
18:27:43 <cmccann> so that the "edge" of the inner one keeps sliding past
18:27:49 <cmccann> blocking the text as it goes
18:27:51 <elliott> cmccann: perfect
18:28:05 <Axman6> carter: submit it to reddit
18:28:19 <carter> Axman6: ok
18:28:29 <elliott> does homebrew not have freetype?
18:28:33 <carter> nope
18:28:38 <carter> they say "use x11's"
18:28:50 <carter> but X11 / Xquartz, the .a file is depricated
18:28:53 <elliott> ah
18:28:56 <carter> so they only provide the dynamic lib
18:29:05 <carter> and this isn't stated ANYWHERE
18:29:12 * elliott just barely stops himself from trolling.
18:29:44 <carter> I mean that somehow the static lib version of freetype is depricated
18:30:57 * carter confused about the trolling remark
18:31:09 <carter> Axman6: its on reddit
18:31:10 <cmccann> elliott, it's unfortunate that animated GIFs don't support JPEG artifacts though
18:31:38 <sipa> ...
18:32:06 <cmccann> maybe I'll invent a non-standard animated JPEG format and only support that
18:32:14 <hpc> cmccann: you can call it "avi"
18:32:19 <cmccann> :D
18:32:25 <sipa> mjpeg
18:32:52 * ski__ . o O ( IFF ANIM )
18:35:42 <elliott> cmccann: just pack jpeg binary data in to the colour data of gifs
18:35:46 <elliott> the best of both worlds
18:35:59 <cmccann> hm, could work
18:36:09 <elliott> carter: the trolling was going to be something along the lines of "I'm glad I use an OS without ridiculous problems like that" :P
18:36:25 <carter> elliott: windows?
18:36:30 <carter> :p
18:36:46 <elliott> haha
18:36:48 <elliott> no :)
18:36:51 * cmccann decides to only support three fonts--comic sans ms, impact, and wingdings
18:36:55 <carter> Hurd?
18:37:05 <elliott> linux, we have completely different and exciting problems
18:37:32 <carter> i thought linux is the modern origin of the phrase "dll hell"
18:38:02 <carter> before epoch of the universal package manager for everything
18:38:10 <carter> *before the
18:38:33 <timemage> carter, modern origin?
18:38:40 <carter> 90's?
18:38:55 <carter> i'm getting old enough that I don't realize thats no longer "modern"
18:39:15 <carter> at the old age of mid 20's :p
18:39:44 <timemage> carter, i just find it curious you associate the term "dll hell" more strongly with linux than windows.
18:40:14 <carter> timemage: probably because i never did much windows dev
18:40:29 <timemage> carter, that would make sense :)
18:40:57 <elliott> .so hell
18:41:11 <carter> timemage: and at the same time, I definitely recall reading about "early linux years" when people had library versioning hell
18:41:28 <timemage> yeah.  although i don't remember running into as many problems with so compared with dll.
18:42:02 <timemage> carter, we had a lot of problems with glibc changing versions iirc.
18:42:28 <carter> for recent ghc?
18:42:36 <carter> i think i was the first person to report that bug in fact
18:42:53 <carter> for the recent instance of that with ghc
18:43:07 <timemage> carter, i didn't mean with respect to ghc.
18:43:12 <carter> oh
18:44:00 <stepkut> timemage: perhaps because you use a linux distro that largely manages things in a centralized manner than ensures 'dll hell' does not happen?
18:44:32 <timemage> stepcut, maybe.  used slakware a lot in the beginning.  not so much since 2001 or so.
18:44:56 <stepkut> a lot of dll help came from the fact that a random vendors where shipping conflicting .dll binaries in an uncoordinated manner
18:45:25 <stepkut> on slackware you would be building everything from source.. so not so much of a problem perhaps
18:45:41 <stepkut> also.. .so files do support versioning so you can have multiple versions installed at once..
18:45:43 <timemage> stepkut, not really.  had precompiled binaries for a lot of stuff.
18:46:01 <stepkut> been a looonog time since I used slackware
18:46:12 <stepkut> 15 years or so :-/
18:46:36 <carter> found the bug i was thinking of: http://hackage.haskell.org/trac/ghc/ticket/5011
18:46:38 <timemage> nearly all stuff actually.  by 2001 or so it was no longer as comprehensive as what came with something like redhat, so you did end up compiling a lot of non-core stuff.
18:46:41 <carter> :)
18:48:39 <hpaste_> nand pasted “Tag remover” at http://hpaste.org/56826
18:48:49 <nand`> at last, it is complete
18:49:20 <nand`> fully general purpose polymorphic tag remover, usable on any foldable functor and can output any monoid-producing monad (eg. :: String or :: Seq Char)
18:49:53 <nand`> intended for parallelization, since combine is an associative combinator function
18:53:50 <ski__> nand` : no idea what that's for, but instead of comparing with `<',`>',`==', you could use `compare'
18:54:36 * ski__ wonders whether `combine' is associative
18:55:56 <hpc> is there a spaceship operator in the standard library somewhere?
18:56:02 <hpc> @hoogle (<=>)
18:56:02 <lambdabot> No results found
18:56:14 <nand`> I'm actually wondering that as well, but I went through a few examples on paper when I designed it
18:56:16 <hpc> (<=>) = compare -- would be nice
18:56:25 * ski__ . o O O ( "Why, did you want to borrow one?" )
18:56:36 <nand`> and in my examples I was pairing the letterrs at a time in parallel, like they would on a supercomputer
18:57:01 <nand`> @hoogle compare
18:57:02 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
18:57:02 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
18:57:02 <lambdabot> Data.Text compareLength :: Text -> Int -> Ordering
18:57:14 <ski__> @src Ord
18:57:14 <lambdabot> class  (Eq a) => Ord a  where
18:57:15 <lambdabot>     compare      :: a -> a -> Ordering
18:57:15 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:57:15 <lambdabot>     max, min         :: a -> a -> a
18:57:28 <nand`> ski__: why Ord though? Eq is more general
18:57:38 <ski__> ?
18:57:48 <nand`> I only need (==), I don't use (<) or (>)
18:57:54 <ski__> you're already using `(<)' and `(>)'
18:58:03 <nand`> no
18:58:07 <nand`> oh
18:58:08 <ski__>       | o < c  = Close (c-o) b       -- If the closing bracket is nested higher, it wins
18:58:09 <nand`> I see what you mean
18:58:11 <ski__> &c.
18:58:19 <nand`> data Paren m = Open Int m | Close Int m
18:58:21 <nand`> I'm comparing the ints there
18:58:25 <ski__> i know
18:58:27 <elliott> compare will be faster
18:58:30 <elliott> "Monoid (m a)" -- consider MonadPlus m
18:58:33 <nand`> oh, I get it now
18:58:39 <nand`> you're telling me to use compare on the ints ¤_¤
18:58:45 <nand`> I thought you meant for | c == open
18:58:46 <elliott> also, that's not really parallel
18:58:53 <elliott> in that GHC is not going to actually run any of that in parallel
18:59:08 <nand`> elliott: I know, I just need to replace foldl with a suitable parallel folding function
18:59:18 <elliott> you can't do a parallel foldl :P
18:59:23 <elliott> you can do a parallel foldMap though
18:59:27 <ski__> nand` : well, first you should prove that `combine' is associative
18:59:39 <elliott> yeah
18:59:42 <ski__> (and that `Chunk mempty' is its identity)
19:02:23 <parcs`> is there a library that html parser that accepts malformed html?
19:04:19 <nand`> hmm
19:04:42 <nand`> seems I need to make (Paren m) an instance of Monoid then use foldMap (convert)
19:04:43 <byorgey> parcs`: tagsoup?
19:04:47 <parcs`> haha, my sentence is highly malformed :P
19:04:57 <nand`> assuming I can prove it's associative
19:05:03 <byorgey> parcs`: thankfully, my English parser accepts malformed English
19:05:11 <nand`> elliott: will what I just described parallelize in GHC?
19:05:16 <parcs`> byorgey: thanks :)
19:05:18 <nand`> if I use something like Data.Tree
19:05:52 <carter> byorgey: you'll be happy to know that now diagrams seem to work in its full glory on macs
19:05:57 <elliott> nand`: it depends on the instance
19:06:01 <elliott> Data.Tree's, probably not
19:06:03 <elliott> check the implementation
19:10:22 <byorgey> carter: yeah, I saw that! excellent!
19:11:42 <carter> byorgey: gtk not working properly on mac w/ both ghc and ghci has been driving me crazy for years!  I'm really happy I was able to pin down exactly what dependencies are needed + why ghc and ghci would act differently on the same programs
19:12:12 <carter> byorgey: btw- I may be at popl next week, still sorting out the housing side though
19:12:57 <carter> that being said, pinning down that gtk problem took a few hours of "experiment, rebuild, experiment, rebuild"
19:13:32 <nand`> elliott: foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts
19:13:35 <nand`> not sure how this will play out
19:13:42 <nand`> ts is a [Tree]
19:14:40 <elliott> nand`: it won't parallelise. well... I guess you could bake the parallelisation into mappend
19:14:47 <elliott> but that probably won't go well
19:14:54 <elliott> actually that wouldn't help i don't think
19:15:14 <nand`> elliott: I think I won't bother, actually
19:15:31 <nand`> this was more a theoretical exercise, it can be automatically parallelized on certain platforms eg. fortress designed for supercomputers
19:15:39 <nand`> assuming I provide it with a suitable combinator function
19:16:19 <nand`> accumulator patterns won't hold in the future, associative combinators are the only way forwards
19:56:29 <wvoq> Has there been any progress on "the configuration problem"?
19:56:40 <wvoq> I've seen many strategies advocated
19:57:13 <wvoq> viz., performUnsafeIO, implicit parameters, &c. &c.
19:57:26 <Philippa> I'm not sure I know it by that name - just, "how do you pipe configurations around"?
19:57:42 <elliott> *unsafePerformIO
19:57:49 <wvoq> it goes by many different names, apparently, but I think we mean the same thing
19:57:51 <wvoq> yeah, thanks
19:57:53 <elliott> there's oleg's reflection stuff
19:57:58 <elliott> but i don't really see the problem with ReaderT
19:58:40 <wvoq> I saw that paper, but IIRC correctly the authors themselves admit that the solution isn't fully satisfying
19:59:00 <elliott> well, i think people are using it anyway :P
19:59:00 <elliott> http://hackage.haskell.org/package/reflection
19:59:29 <Philippa> yeah, I tend to just use readers - monads are a big part of how I integrate code as there are more concerns to manage anyway
20:00:26 <wvoq> philippa: how do you mean?
20:00:35 <elliott> i wonder why Reader is like the one monad people think is most unacceptable... i don't often hear "i hate how i have to wrap all my code in the [] monad just for a tiny piece of nondeterminism" :)
20:01:50 <Jafet> unsafePerformUnsafeIO
20:02:07 <elliott> unsaferPerformIO
20:02:13 <elliott> it requires a proof the IO action has observable side-effects
20:02:24 <cmccann> hahaha
20:02:27 <cmccann> here we go again
20:02:41 <cmccann> unsafestPerformIO = fireZeMissiles
20:03:05 <elliott> no
20:03:11 <elliott> unsafestPerformIO starts cmccann's browser
20:03:15 <cmccann> haha
20:03:44 <Axman6> but i am le tired :(
20:03:51 <cmccann> well, have a nap
20:03:56 <cmccann> and then fire ze missiles
20:04:13 <Axman6> W.T.F mate? (more appropriate for me)
20:04:19 <wvoq> ahem, do = takeNap >> fireZeMissiles
20:04:54 <elliott> do =?
20:04:58 <elliott> redefining do notation to fire missiles is
20:05:00 <cmccann> Axman6, you're Australian, eh
20:05:01 <elliott> appropriately unsafe
20:05:29 <wvoq> text editor failure on a tiny laptop keyboard :(
20:05:30 <Axman6> indeed
20:05:32 <Jafet> Naw, he's 'Strayn
20:05:50 <Axman6> 'straryun
20:06:00 <Philippa> wvoq: once I need to do things like instrument functions, I end up using monads to pipe around pieces that I don't want to be actively thinking about all the time and have a clear pattern for. Likewise for the control flow equivalents - error handling, etc etc
20:06:54 <wvoq> doesn't that tend to gum up your type signatures
20:07:25 <elliott> in the same way that having to follow types totally messes up your program 'cause you have to be explicit about conversions :P
20:07:56 <elliott> a lot of people seem to be afraid of boilerplate that doesn't really end up existing in practice
20:08:13 <Philippa> not too badly - type synonyms are helpful, as is wrapping
20:08:17 <Jafet> Just use sufficiently polymorphic type signatures
20:08:34 <Philippa> that too - don't constrain where you don't need to
20:09:18 <Philippa> generally, the code inside the monad only really cares what control operators it has access to
20:09:59 <wvoq> I'm not sure that undue constraint is the issue; my specific concern is that I'm writing code for a scientic simulation involving a bunch of constants that should be set by a configuration file
20:10:16 <elliott> write the configuration file in haskell :P
20:10:25 <wvoq> thought about that
20:10:56 <sal23> how do you convert a storable MVector to IOVector?
20:10:57 <wvoq> but doesn't that involve a compilation step before each run?
20:10:57 <Philippa> I've done that, it works nicely
20:11:09 <elliott> wvoq: yeah but just of one small file
20:11:22 <Philippa> yeah, you'll spend more time linking than compiling
20:11:29 <elliott> i think reflection could also work well in that case, you could define your own class for just reifying your bunch of variables or whatever
20:11:33 <wvoq> hmm
20:11:50 <wvoq> the compile time is pretty negligible in comparison to the reproducibility concern
20:12:06 <elliott> wvoq: on the other hand, would it really never be useful to e.g. run two simulations in parallel?
20:12:17 <elliott> maybe you _do_ want to be passing these around as actual environments (with Reader or whatever)
20:12:38 <wvoq> hrm
20:13:05 <SirFrancisDrake> Is there a way to force evaluation of hashmaps? I'd like to write a benchmark on Data.HashMap, but I can't conquer all the laziness. Is there a way to use seq somehow?
20:13:44 <Philippa> wvoq: surely reproducability is just a matter of publishing /all/ the code?
20:14:07 <Philippa> the Reader'd probably be my default approach, admittedly. Compilation will be fastest though
20:14:28 <Philippa> (assuming a large compute load, for values of large that should be obvious)
20:14:39 <wvoq> Philippa: publishing the code is a given, but I'd prefer to have one output file associated with one config file
20:14:50 <wvoq> rather than a config module that's constantly getting edited and overwritten
20:15:06 <elliott> SirFrancisDrake: deepseq?
20:15:09 <Philippa> have the config file be Main, then?
20:15:15 <elliott> SirFrancisDrake: but hashmap is strict in structure
20:15:18 <elliott> so seq should work too
20:15:20 <Philippa> then it's just a ghc --make for each config and off you go
20:15:33 <elliott> wvoq: oh, i meant
20:15:37 <elliott> structure your code as a library
20:15:43 <tomprince> That is exactly what xmonad is.
20:15:50 <elliott> Philippa: hmm actually
20:15:50 <Philippa> or do something equivalent without the recursive dependency, of course
20:15:53 <wvoq> Philippa: that's more or less what I'm doing currently
20:15:55 <elliott> Philippa: that won't work, since it'd be a circular dependency
20:15:57 <elliott> oh, hs-boot
20:16:00 <elliott> never mind :)
20:16:07 <wvoq> right
20:16:11 <elliott> Main.hs-boot would be easy, of course, since it's just the vars + main :: IO ()
20:16:16 <Philippa> elliott: trust me, I've done /far/ hairier things with recursively dependent configs :-)
20:18:12 <wvoq> elliott: sorry, as a library as opposed to?
20:18:26 <elliott> wvoq: i was thinking wrongly, ignore me :)
20:18:44 <wvoq> :)
20:19:02 <Philippa> wvoq: there're many ways to avoid actually editing one "physical" file for the config, anyway?
20:19:36 <Philippa> for example, you should probably be making copious use of version control anyway: if you've got cheap branching then you're pretty much done
20:19:53 <wvoq> Philippa: I think what I'd most like to do would be to run ./executable run1.config
20:20:06 <Philippa> yeah. Reader's your best bet, then
20:20:11 <elliott> just generate /tmp/blah/Main.hs from that and compile and run it?
20:20:14 <wvoq> which creates the file run1.log with metadata about the config
20:21:01 <wvoq> and yes, version control is already being made copious use of
20:21:23 <Philippa> is there any reason ./executable can't be a wrapper around ghc, etc?
20:22:01 <wvoq> Philippa: only by my own ignorance
20:22:02 <Philippa> in your case it probably makes sense to fix the type at Reader, btw
20:22:14 <Philippa> or even a wrapper around reader that blocks local etc
20:22:20 <wvoq> yeah, that's the sense I'm getting from this discussion
20:22:31 <wvoq> I'll try it out and see whether it takes, so to speak
20:22:43 <wvoq> the other reason I'm hesitant invoke recompilation
20:23:01 <wvoq> is that this needs to be usable for scientists without working knowledge of Haskell
20:23:36 <wvoq> who find it distasteful to even look at source code, much less haskell source code
20:24:25 <Philippa> well, the question is: are they going to look at it?
20:24:27 <elliott> why would they need to?
20:24:37 <Philippa> If so, recompilation may be no worse for them to read
20:24:52 <elliott> just generate a Main module, have it define the variables and a stock main, importing your code and doing main = code'sMain
20:25:04 <elliott> only one file of a predefined format has to be compiled, and you can generate it from a variable definition file
20:26:13 <wvoq> Philippa: batch mode wouldn't be possible then, unfortunately
20:27:03 <elliott> huh?
20:27:17 <Philippa> not true. Your outer loop'd just run the batch
20:27:23 <Philippa> recompilations and all
20:28:15 <wvoq> are we still talking about pure haskell at this point, or haskell inside a bash script?
20:28:34 <Philippa> haskell can run shell commands too
20:29:23 <DanBurton> rather, Haskell can compose IO actions, including IO actions that run shell commands, and then run that composed action
20:31:45 <hpaste_> SirFrancisDrake pasted “How to force evaluation” at http://hpaste.org/56829
20:32:18 <wvoq> it's not that I doubted it was possible
20:32:44 <wvoq> I suppose I was just asking for the sense of the community about the best practice for this sort of thing
20:32:58 <wvoq> it seems to flare up like every 6 months on haskell-cafe
20:33:12 <SirFrancisDrake> pasted my problem. How can I make him evaluate? I'd really like to stay in IO and get some timestamps, to separate setting up from querying
20:33:45 <elliott> force what exactly?
20:33:57 <wvoq> but I'll try Reader and see what happens. thanks for your comments, everyone.
20:35:12 <Philippa> Reader may require a global refactoring and a lot of tedious binding work in a scientific context, FWIW
20:35:42 <SirFrancisDrake> elliott: force evaluating genHashMap and queryHashMap, I suppose
20:36:24 <wvoq> side effects may include global refactoring, tedious bindings, drymouth and hair loss
20:36:42 <wvoq> that's exactly what I'm dreading
20:37:29 <Philippa> yeah. You've got a lot of different fields to your config and they're going to crop up a lot, right?
20:38:16 <wvoq> precisely.
20:39:36 <Philippa> yeah. Go with recompilation. You just use Haskell instead of bash
20:40:31 <SirFrancisDrake> elliott: for example, making runTest return something like `concat hresult' and writing `putStrLn $ show hresult' *does* force some evaluation. Which means considerably larger execution time and lots of junk in console. Not exactly appropriate
20:40:51 * elliott does think that configurations could be easier. but it won't be with haskell type hackery
20:40:59 <elliott> SirFrancisDrake: evaluate hresult
20:41:10 <elliott> SirFrancisDrake: or if you need RNF not WHNF, evaluate (rnf hresult) (with Control.DeepSeq)
20:41:39 <elliott> (import Control.Exception for evaluate)
20:42:53 <SirFrancisDrake> elliott: I'll do that, thank you
20:43:03 <XexonixXexillion> is there an instance of NFData hashmap? I didn't think there was...
20:43:25 <elliott> easy to write one
20:43:44 <wvoq> elliott: i.e. Reader?
20:44:11 <elliott> wvoq: hm?
20:44:48 <wvoq> elliott: elliott does think that configurations could be easier. but it won't be with haskell type hackery
20:44:53 <wvoq> unless you were replying to someone else
20:45:35 <elliott> oh
20:45:53 <wvoq> or type hackery meant monads, rather than the scarier implicit parametrization typemancy
20:46:02 <elliott> i was just saying that i think the ease of configurations (and other things) can be improved a lot compared to the status quo, but it's not going to be with fancy tricks in the existing type system
20:46:53 <wvoq> right, I'm really tempted just to unsafePerformIO it :(
20:47:02 <cmccann> fancy type system tricks are a great way to avoid easy solutions though
20:47:03 <wvoq> I've never felt that before
20:48:19 <Sgeo> I may be addicted to IO (IO ())
20:48:36 <Sgeo> So far, used such things twice in my project
20:48:50 <wvoq> Sgeo: e.g.?
20:49:28 <startling> so, monadic values can never evaluate to non-monadic values, correct?
20:49:55 <Sgeo> A type isomorphic to reactive-banana's AddHandler, and a thing that allocates some memory to pass to a foreign library and gives an action to deallocate that memory
20:49:57 <elliott> :t runState
20:49:58 <lambdabot> forall s a. State s a -> s -> (a, s)
20:50:02 <elliott> State is monadic
20:50:16 <wvoq> :t (!!)
20:50:17 <lambdabot> forall a. [a] -> Int -> a
20:50:23 <elliott> cmccann: that's true!
20:50:27 <Jafet> Dyadic values
20:50:28 <elliott> cmccann: thankfully none of the solutions i have in mind are easy
20:50:28 <XexonixXexillion> :t fromJust
20:50:29 <lambdabot> forall a. Maybe a -> a
20:50:34 <elliott> XexonixXexillion: WRONG
20:50:35 <elliott> :t maybe
20:50:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:51:39 <Sgeo> If you really want to use fromJust, use fromMaybe with an error as the default instead
20:51:59 <Sgeo> Would be nice if fromJust didn't cause the issue it does with unfindability
20:52:05 <cmccann> on the other hand, if you think you want to use fromJust, you're probably wrong
20:52:53 <XexonixXexillion> fromJust is just as usable as head... which says something about the head function really
20:52:55 <Sgeo> cmccann, I used fromMaybe (error blah) when reading from a predefined map that I know must have my value... but maybe that's a bad idea
20:53:10 <Philippa> startling: what is a "non-monadic value"?
20:53:14 <Sgeo> Just go ahead and do the grudgework
20:53:26 <Philippa> or, for that matter, a "monadic value"?
20:53:45 <cmccann> Sgeo, depends on why you know it "must" have the key
20:55:03 <Sgeo> cmccann, because I'm using it only due to my laziness. The keys are constructors of my enum type, and all the constructors (except for 2, long story) are in there
20:55:26 <cmccann> Sgeo, yeah
20:55:34 <elliott> all the constructors except for 2... excellent
20:55:39 <Sgeo> If the error ever occurs, it's a bug that's my fault
20:55:41 <XexonixXexillion> > (succ >>= (+)) 5
20:55:42 <Sgeo> elliott, I blame AW
20:55:42 <lambdabot>   11
20:56:14 <elliott> Guys, I hear monads will revive my pets and bring about the end of the world if left in a humid container for too long. Right?
20:56:37 <cmccann> Sgeo, cases like that are one of the few places that fromJust can be... er, justified
20:56:38 <Sgeo> Wait, the keys are the integers, and the values are the constructors
20:56:47 <Sgeo> :/
20:56:52 <XexonixXexillion> elliott: They also launch missiles
20:58:16 <cmccann> Sgeo, I've also had cases that amounted to storing a graph using a map from node IDs to a list of adjacent nodes, where the map was constructed such that I knew every list would only contain valid nodes
20:58:27 <elliott> cmccann: Should have used Agda.
20:58:31 <Sgeo> But yeah, if the result is ever nothing, it's because I accidentally omitted something in my library code
20:58:40 <cmccann> and the actual Map itself was hidden inside another type, with the constructor not exported
20:59:35 <Sgeo> (error $ "Network.Activeworlds.RC.fromEnum: " ++ (show rc) ++ " is unknown. This is a bug in RC, please report it.")
21:00:03 <hpaste_> warpy pasted “array index swap” at http://hpaste.org/56831
21:00:15 <cmccann> Sgeo, should toss in an (unsafePerformIO $ sendEmailToSgeo "YOU DONE GOOFED")
21:00:20 <warpy> can someone help me with this one ^
21:00:30 <warpy> i am trying to make the swap strict
21:00:40 <Sgeo> There has to be an easier way to make enums where each thing corresponds with something other than what deriving (Enum) gives
21:00:53 <elliott> instance Enum T where
21:01:05 <Sgeo> Although since two of them map to 101, and two of them map to 102
21:01:10 <cmccann> haha
21:01:14 <elliott> warpy: it looks strict enough to me
21:01:15 <Sgeo> elliott, but then I have to write both toEnum and fromEnum
21:01:19 <Sgeo> And it gets repetitive
21:01:26 <elliott> Sgeo: sounds like a good thing, since you don't have a bijection
21:01:37 <warpy> elliott: profiling it shows linearly increasing memory usage
21:01:38 <elliott> although it really shouldn't be Enum anyway in that case...
21:01:51 <elliott> warpy: oh hm
21:01:53 <elliott> warpy: right, try
21:01:58 <Sgeo> I decided that toEnum 101 will just give UnknownRC
21:02:05 <elliott> swap i i' a = A.accum (\_ x -> x) a [(i, ai'), (i, ai) where !ai' = a ! i'; !ai = a ! i
21:02:05 <Sgeo> Err
21:02:07 <elliott> except on multiple lines
21:02:09 <Sgeo> UnknownRC 101
21:02:13 <elliott> and with a ]
21:02:18 <elliott> you can also drop the bang pattern
21:02:24 <warpy> elliott: ok. let me
21:02:25 <elliott> and do ai `seq` ai' `seq` A.accum ...
21:02:32 <elliott> (to avoid the BangPatterns extension)
21:06:17 <warpy> elliott: no use. still shows increasing memory
21:06:31 <elliott> warpy: i suspect swap isn't the problem, then
21:06:47 <elliott> (why not use // rather than accum, btw?)
21:07:24 <warpy> i did. it had same problem
21:08:13 <elliott> it's just nicer in general :) but it's hard to know what the problem might be without more details
21:08:43 <XexonixXexillion> warpy: Is the original array already fully evaluated before you start swapping?
21:09:05 <warpy> i am not sure
21:09:15 <warpy> here is the full code: https://github.com/abhin4v/russel-norvig-ai-problems/blob/master/chapter4/SlidingPuzzle.hs
21:09:25 <warpy> let me post the memory profile also
21:12:04 <elliott> by the way, it is "russell" :)
21:12:35 <warpy> http://i.imgur.com/tMMHd.png
21:12:43 <SirFrancisDrake> ghci with +s option outputs size of allocated space in bytes. Is there an option to automatically convert it to human-readable format?
21:12:45 <warpy> oh. my bad.
21:13:51 <elliott> if you do :set -XFoo in ~/.ghci, it doesn't affect files you import, right?
21:14:08 <warpy> i tried various thing but cant figure out how to reduce the memory usage
21:15:50 <elliott> oh, it does
21:15:51 <elliott> yikes
21:16:06 <elliott> even "ghci foo.hs"
21:17:33 <elliott> I wonder how you're meant to turn off the MR for ghci sessions without that nasty side-effect :/
21:33:23 <Sgeo> MR?
21:33:46 <ddarius> elliott: Just turn off the Monomorphism Restriction for everything.
21:35:24 <elliott> ddarius: Well, it's undesirable to have extensions you set in ~/.ghci be applied to files you load in general.
21:35:36 <elliott> Sgeo: Monomorphism resiotjjlkdgfg.
21:35:54 <elliott> "Monomorphism", easy. Getting me to type "restriction", that'll cost you.
21:37:47 * Sgeo looks at the wiki page
21:37:48 <Sgeo> -- This is allowed
21:37:48 <Sgeo> f1 x = show x
21:37:58 <Sgeo> Why is that allowed? I thought I understood the thing, I guess not
21:38:30 <Sgeo> (I guess I was thinking "not allowed to infer top-level functions that use =>")
21:41:41 <Sgeo> " In a few very rare cases, however, you may need to supply a type signature which is not valid Haskell."
21:41:52 <Sgeo> Examples? (Besides ScopedTypeVariables, which is mentioned)
21:50:18 <ddarius> If you stick to Haskell 98/2010, then I think the issue with scoped type variables is the only case where you can have a type that you can't write down.
22:17:59 <mgsloan1> djahandarie: https://github.com/mgsloan/newtype-th/commit/0c18582a1aa85401dec0ae930b5cc6346c9b76cd
22:43:44 <cl1> ping
22:44:15 <elliott> pong
22:44:30 <cl1> whew! thought something weird was going on
22:48:07 <DanBurton> I'm sure somewhere in the world, something weird is going on
23:21:59 <kniu> okay so
23:22:05 <kniu> how do I remove a cabal package?
23:23:12 <elliott> kniu: ha! haaa!
23:23:19 <elliott> you can't, mostly.
23:23:24 <kniu> dangit
23:23:33 <elliott> you can: (a) ghc-pkg unregister and try and hunt down what's left yourself
23:23:44 <elliott> (b) rm -r ~/.cabal ~/.ghc && cabal install everything else
23:23:49 <elliott> (c) use cabal-dev all the time
23:25:09 <kniu> somewhat unrelated:
23:25:12 <vyom> I need some help with basic Parsec usage. I cannot quite figure out how to parse leading whitespace in this : https://gist.github.com/1656230
23:25:21 <kniu> why does the LLVM-base package require a "lib.so"?
23:25:34 <kniu> Loading package llvm-base-3.0.0.0 ... can't load .so/.DLL for:  (lib.so: cannot open shared object file: No such file or directory)
23:25:43 <kniu> that's a damn weird name for a library
23:26:03 <elliott> probably Something Else is going wrong
23:26:10 <elliott> like it wants the empty string as a library for some reason
23:26:17 <kniu> hm
23:26:24 <Enigmagic> kniu: are you on osx?
23:26:28 <kniu> archlinux
23:27:06 <Enigmagic> kniu: ok, well here's the fix:
23:27:06 <kniu> Enigmagic, OSX has this bug too?
23:27:35 <Enigmagic> edit the llvm-base-*.conf in your package.conf.d dir, typically under ~/.ghc
23:27:50 <elliott> :|
23:27:51 <Enigmagic> remove this line: extra-ghci-libraries: ""
23:28:12 <Enigmagic> then rebuild the package conf using ghc-pkg recache --user
23:28:12 <elliott> surely it'd be better to fix the problem in the llvm-base.cabal or whatever? unless it's some weird unrelated issue
23:28:23 <Enigmagic> it's a bug in the autoconf script
23:28:26 <elliott> ugh
23:28:36 <kniu> okay
23:28:43 <kniu> what does recache --user do?
23:28:56 <Enigmagic> it rebuilds the package cache from the package.conf files
23:30:15 <Enigmagic> though in general ghci has problems with c++ libraries, so you may also need to build llvm as a shared library (if its not already) and make sure the package conf references the .so (e.g. libLLVM-3.0.so) instead of the .a files
23:30:24 <kniu> hm
23:30:40 <kniu> now it's complaining about
23:30:41 <kniu> Loading package llvm-base-3.0.0.0 ... can't load .so/.DLL for: LLVMSupport (libLLVMSupport.so: cannot open shared object file: No such file or directory)
23:31:43 <Enigmagic> so remove basically all of the LLVM* files from extra-libraries and just have LLVM-2.9 or LLVM-3.0 instead
23:32:08 <Enigmagic> (that's a problem with the llvm-config script not the llvm-base package)
23:32:25 <kniu> okay
