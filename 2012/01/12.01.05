00:13:03 <srhb> So I'm still trying to figure out monadic computations and failing horribly. I have the expression [1,2,3,4] !! (randomRIO (0,3)), which does not work, because randomRIO returns an IO a0. So how do I do this basic computation?
00:13:22 <srhb> I know it's not a pure function, so it should end up wrapped in a Monad... IO monad?
00:14:24 <shachaf> srhb: Monads have nothing to do with purity.
00:14:39 <shachaf> You should read an introduction to how IO in Haskell works.
00:14:42 <shachaf> @google introduction to io
00:14:42 <srhb> I have.
00:14:44 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
00:14:44 <lambdabot> Title: Introduction to IO - HaskellWiki
00:14:58 <shachaf> Oh. Well, read it again, then.
00:15:03 <shachaf> And then look at all the types involved.
00:17:24 <srhb> That's not helpful. If there's an explanation in there I don't get it. I know that the !! operator is [a] -> Int -> a, and that what I get from randomRIO is an IO Int.
00:17:52 <Axman6> so you need to get access to the int returned by calling randomRIO right?
00:17:58 <srhb> Right.
00:18:08 <Axman6> and then use that to extract a value from the list
00:18:13 <srhb> Indeed.
00:18:28 <srhb> But I can't do that purely, so I need to somehow.. chain the function through >>=?
00:18:37 <shachaf> Axman6: I would suggest using the word "produced" rather than "returned". Normally the ambiguity is OK, but here it's probably a good idea to be careful.
00:18:53 <srhb> Because it's an action?
00:18:59 <Axman6> so, you want something like: doStuff :: ... -> IO Int; doStuff = do { ...; i <- randomRIO (0,3); return ([1,2,3,4] !! i) }
00:19:22 <Axman6> srhb: it's much clearer using do notation than >>= directly
00:19:37 <Axman6> shachaf: indeed, thanks
00:19:40 <srhb> Yes, but I'm trying to avoid it because I don;t understand what's going on yet.
00:20:18 <ski> @undo do { i <- randomRIO (0,3); return ([1,2,3,4] !! i) }
00:20:18 <lambdabot> randomRIO (0, 3) >>= \ i -> return ([1, 2, 3, 4] !! i)
00:20:49 <Axman6> imo, IO makes a lot more sense when written using do notation. it gives it the imperative feel of what you're actually modelling
00:21:02 <srhb> I just wrote that, hurrah. So by using return I'm... wrapping the [..] !! i computation in a monad?
00:21:13 <srhb> Axman6: I'm trying to understand it on the type level right now.
00:21:18 <srhb> But maybe you're right.
00:21:19 <ski> s/in a monad/in a monadic action/
00:21:26 <srhb> Ah yes.
00:21:39 <Axman6> a monad is just a type, it's not a 'physical thing'
00:21:47 <srhb> No, indeed.
00:21:48 <ski> `IO' is the monad, `return ([1, 2, 3, 4] !! i)' (as well as `randomRIO (0, 3)') are monadic actions
00:22:04 <Axman6> you can 'put things into' specific monads, but you don't wrap something 'in a monad'
00:22:12 <srhb> and return here is specific to the IO monad, and type inference (from randomRIO) knows to use this one?
00:22:13 <Axman6> exactly
00:22:26 <ski> there is a `return' for every monad
00:22:37 <ski> but the details of what it does depends on the monad in question, yes
00:22:38 <srhb> Right. I'm getting there, slowly.
00:22:41 <shachaf> Axman6: "IO Int" is "Int" wrapped in "IO" in the same way that "Just 5" is "5" wrapped in "Just".
00:22:59 <Axman6> y u troll me
00:23:07 <shachaf> I'm not?
00:23:09 <shachaf> Anyway.
00:23:12 <srhb> But those are constructors, not monads, no?
00:23:15 <srhb> Or is both true?
00:23:17 <ski> but conceptually, `return x', always gives an `x' that "does nothing, and yields `x' as result", regardless of the monad
00:23:22 <shachaf> Those are two completely different things.
00:23:35 <ski> er, s/gives an `x'/gives an action/
00:23:41 <shachaf> srhb: Do you understand the following? "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
00:24:00 <srhb> shachaf: I think so.
00:24:09 <shachaf> What does it mean?
00:24:28 <ski> srhb : `IO' is a type constructor, just like `Maybe' and `Either'
00:24:51 <ski> `Just' otoh is a data constructor; it doesn't exist at the type level, but at the value level
00:25:18 <srhb> Well, I don't know exactly what you're fishing for. I suppose I do like produces more in that case, because getLine produces 'a' string (wrapped in IO), depending on state
00:25:42 <shachaf> srhb: I'm not sure what "wrapped in IO" or "depending on state" means.
00:25:46 * ski thinks the string "/bin/ls" doesn't contain any files, in itself
00:26:12 <srhb> Hmm.
00:26:16 <shachaf> ski: I didn't say the string /bin/ls, I said /bin/ls.
00:26:31 <shachaf> I.e., the binary, starting with "?ELF..."
00:26:39 <ski> ah, ok -- sorry
00:26:51 <srhb> OK, I guess I don't know either then. :-)
00:27:24 <shachaf> srhb: getLine :: IO String is a program that, when you run it, produces a String.
00:27:26 <srhb> Conceptually? I guess I think of "depending on state" as looking into a box where things might change at any time.
00:27:33 <srhb> Yes.
00:27:38 <shachaf> Functions can't run programs.
00:27:49 <shachaf> They can, however, compose programs into larger programs.
00:28:24 <srhb> I think I understand that in a very general sense.
00:28:27 <shachaf> There's no String anywhere inside getLine.
00:28:35 <Axman6> *cough*
00:28:36 <shachaf> It's not a "tainted value".
00:28:38 <srhb> Ie. I can't ever get an Int from somewhere where I use randomRIO
00:28:46 <shachaf> srhb: What?
00:28:54 <srhb> as a functional return value
00:29:05 <Axman6> we showed you how to get the int, and pass it to a pure function
00:29:07 <srhb> I can't have IO ... -> Int
00:29:20 <srhb> Oh, I thought it was the other way around
00:29:33 <srhb> That we were somehow converting a pure function to something not pure. Bleh.
00:29:57 <shachaf> srhb: You can construct a program that consists of running another program and then doing something with its return value.
00:30:07 <Axman6> no, we're using pure functions to do things to data from non-pure places (IO)
00:32:59 <srhb> I'm not sure how to build any kind of intuition about this. I guess I'll keep on playing around with it, trying to anticipate what is going on and explaining it as best I can.
00:33:03 <srhb> Thanks a lot for the help.
00:37:32 <erus`> I have a recursive data structure so i cant derive Eq because it will never halt. So i have to store references to each items myself (as an integer or something). Is there a standard way todo this?
00:38:39 <erus`> does that make sense?
00:41:50 <applicative> it can't be just that it's recursive, no?  data Moo a = Baah | Moo (Moo a) deriving Eq works fine.  You mean its' like Stream a = Cons a (Stream a)?
00:43:27 <frerich> erus`: I did use the derived 'Eq' instance for recursive types before (say, 'data Tree a = Leaf a | Tree (Tree a) (Tree a)'). I see no reason why 'Eq' couldn't be derived, assuming you *do* haev a base case (like 'Leaf a' here).
00:43:47 <frerich> erus`: Of course, if you never terminate the recursion, then I don't see how you could even write 'Eq' by hand.
00:44:27 <applicative> the compiler will derive it even without a base case. it just won't terminate. you could define a terminating Eq instance for Stream by hand, but its a question what use it is
00:44:54 <erus`> some structures are circular
00:45:17 <erus`> so i have to keep a reference for each item by hand
00:46:04 <erus`> I am doing it like this at the moment [(Item, Unique Integer)]
00:46:30 <erus`> I cant help but think this must be a common problem and there may be a built in solution
00:47:23 <erus`> (oh and on my data structure i reference other items by their integer index rather than the actual Item
00:47:32 <erus`> so now it terminates
01:01:30 <ski> applicative : well, it will terminate in case they are different :)
01:01:46 <applicative> of course yes
01:02:55 <applicative> i guess you could make use of that ...
01:06:13 <donri> can anyone point me at examples of Alternative not focused on parsing?
01:07:18 <Axman6> > (,) <$> [1..3] <*> [4..6]
01:07:19 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:07:29 <cwraith> that's applicative, not alternative
01:08:12 <cwraith> there are things like Snap, where alternative indicates alternate handlers for an http request
01:08:32 <cwraith> there are also things like STM, where alternative's operators map to orElse and retry
01:08:37 <donri> i noticed [] is an instance of alternative, perhaps a simple example with that?
01:08:51 <cwraith> No, [] is a pretty bad example
01:08:58 <cwraith> because it can't implement some or many
01:08:59 <donri> and Maybe?
01:09:04 <cwraith> maybe for the same reason
01:09:13 <donri> ok
01:09:14 <Axman6> oh, misread =)
01:09:58 <Axman6> there was a huge list on -cafe about removing some and many from alternative
01:10:10 <cwraith> yeah, it ended up going the other way
01:10:28 <cwraith> ...  better to make Maybe and [] not instances of Alternative
01:10:43 <applicative> evidently the stand you took ...
01:11:24 <applicative> > [1,2,3] <|> [4]
01:11:25 <lambdabot>   [1,2,3,4]
01:11:31 <applicative> I guess I don't need that...
01:11:42 <cwraith> the Maybe instance is more useful
01:13:07 <Sgeo> > Just 1 <|> Just 2
01:13:08 <lambdabot>   Just 1
01:13:17 <Sgeo> > Nothing <|> Just 2
01:13:18 <lambdabot>   Just 2
01:13:24 <c_wraith> Though there was some discussion that the current Alternative behavior for Maybe should be made its Monoid behavior, instead.
01:13:31 <c_wraith> Which makes sense, from my point of view
01:13:48 <Sgeo> > Nothing `mappend` Nothing
01:13:49 <lambdabot>   Nothing
01:13:52 <Sgeo> > Nothing `mappend` Just 1
01:13:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:13:53 <lambdabot>    `Data.Monoid.Monoid a'
01:13:53 <lambdabot>  ...
01:13:57 <Sgeo> > Nothing `mappend` Just 'a'
01:13:57 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
01:13:57 <lambdabot>    arising from a use o...
01:14:01 <Sgeo> Oh
01:14:05 <donri> > some [1]
01:14:05 <c_wraith> yeah, that's the problem with the Monoid instance for Maybe
01:14:09 <lambdabot>   mueval-core: Time limit exceeded
01:14:15 <shachaf> c_wraith: That's the problem?
01:14:16 <Sgeo> > Nothing `mappend` Just "a"
01:14:17 <lambdabot>   Just "a"
01:14:20 <shachaf> Char isn't a Semigroup.
01:14:20 <donri> what's up with it hanging
01:14:27 <Sgeo> > Just "y" `mappend` Just "a"
01:14:28 <lambdabot>   Just "ya"
01:14:36 <c_wraith> shachaf: it has different semantics for Monoid than it does as a Monad
01:14:50 <shachaf> What do you mean?
01:14:53 <c_wraith> shachaf: the Monoid semantics don't model failure
01:14:54 <shachaf> That's not a problem.
01:15:15 <c_wraith> Which is the intended purpose of Maybe
01:15:21 <c_wraith> or so the docs say
01:17:29 <c_wraith> if you want to convert a semigroup to a monoid, use a type with different semantics.  Even though the structure is isomorphic, what the type is intended to model is important.  Respect that.
01:18:13 <shachaf> Are you saying mplus should be the same as mappend whenever both are defined?
01:18:32 <c_wraith> I'm not talking about mplus at all.
01:18:34 <MostAwesomeDude> Hey, if I have a bunch of records, and I want to sum or otherwise foldr them, but some of the fields of some records are marked unique, how would I model that efficiently?
01:18:40 <owst> In Cabal is there a way to set ghc-options on a per module basis? I'd like to compile with -Wall, but my alex/happy generated modules are somewhat noisy (so I'd like to disable -Wall for them...).
01:18:59 <MostAwesomeDude> Like, some of the records are named and shouldn't overlap with other records with that name, on a per-field basis.
01:18:59 <c_wraith> I'm talking about Maybe representing "the result of a computation that can fail"
01:19:00 <Sgeo> GHC_OPTS?
01:19:18 <c_wraith> OPTIONS_GHC is actually the name of the pragma
01:19:18 <shachaf> owst: {-# OPTIONS_GHC ... #-}
01:19:21 <Sgeo> Oh
01:19:25 <Sgeo> >.>
01:19:30 <shachaf> c_wraith: Oh.
01:19:44 <owst> shachaf: Ah cool, I wasn't aware of that - thanks!
01:20:06 <c_wraith> someday, you might also need OPTIONS_HADDOCK.  I've needed it a couple times.  Much to my surprise. :)
01:20:49 <shachaf> c_wraith: Do you think there should be instance Monoid (Maybe a) at all?
01:21:36 <c_wraith> yes, though the name mappend is really silly in its case.  It should model taking the first successful result.
01:21:44 <MostAwesomeDude> My current solution, which I haven't typed out, is to switch my types from things like Int and Float to something like Annotated [Annotation] Int, which lets me say which other fields shouldn't overlap with this one, and then sum each field separately, examining those annotations per-field. Is there a better way?
01:26:32 <MostAwesomeDude> Maybe I'm not phrasing it right or I'm still not sure exactly how to model my data.
01:31:01 <hpaste> keep_learning pasted “error in installing ghc-7.2.2” at http://hpaste.org/56105
01:31:11 <keep_learning> Hello all
01:31:38 <keep_learning> I am getting installation error for ghc-7.2.2
01:34:22 <keep_learning> Some one please help me
01:44:58 * hackagebot unix-compat 0.3.0.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.3.0.1 (JacobStanley)
01:51:40 <AfC> It's nice to know there are new releases, but would be handy if Hackage & Cabal would show a changelog or release note of some kind.
01:51:48 <Veinor> keep_learning: did you download the 64-bit version on a 32-bit system?
01:52:24 <donri> AfC: you can browse old histories, it's crude but i use it to compare
01:52:30 <donri> old versions*
01:52:52 <keep_learning> Veinor: my system is 64 bit.
01:53:12 <Veinor> hmm
01:53:20 <Veinor> what's the output of uname -a and file utils/ghc-pwd/dist-install/build/tmp/ghc-pwd
01:53:30 <donri> AfC: i think there's packages for diffing cabal packages, not sure what that entails
01:53:55 <keep_learning> Veinor: Linux localhost.localdomain 2.6.41.4-1.fc15.i686.PAE #1 SMP Tue Nov 29 11:47:02 UTC 2011 i686 i686 i386 GNU/Linux
01:54:04 <Veinor> i686 means it's not 64-bit
01:55:19 <Axman6> not a 64 bit OS anyway
01:55:25 <Veinor> yeah
01:55:35 <keep_learning> Veinor: Processor my system is Core 2 duo and from wiki it say that 64 bit
01:55:46 <Veinor> right
01:55:52 <donri> AfC: http://hackage.haskell.org/package/precis
01:55:53 <Veinor> but you need a 64-bit operating system to run 64-bit programs
01:56:03 <keep_learning> Axman6 Veinor Yes , probably os is not 64 bit
01:56:26 <Axman6> keep_learning: the OS has to also be 64 bit for you to use the 64 bit version of GHC
01:56:57 <keep_learning> Axman6 Veinor : thank you
02:00:00 * hackagebot uAgda 1.2.0.0 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.2.0.0 (JeanPhilippeBernardy)
02:07:15 <Blkt> good day everyone
02:45:52 <fasta> How is one supposed to install GHC7.2 on Debian Stable?
02:46:07 <fasta> Or the latest Haskell Platform for that matter.
02:46:21 <rostayob> fasta: install the GHC binaries
02:46:22 <shachaf> fasta: GHC 7.2 is a "development preview"
02:46:35 <fasta> Ok, any version 7 then.
02:46:50 <rostayob> fasta: read above :P
02:47:02 <fasta> Will installing the binaries give me a working cabal install too?
02:47:14 <rostayob> fasta: no. install the binaries and then the haskell platform from source.
02:47:15 <fasta> Because currently my database is corrupted in some way.
02:47:28 <rostayob> first clean your system of all debian's haskell related packages
02:47:37 <shachaf> Installing the GHC 7.0 binary and then the Haskell Platform source, as instructed by the website, will give you a working cabal-install.
02:47:47 <shachaf> You don't need to uninstall Debian's GHC packages for this to work.
02:48:18 <rostayob> shachaf: really? what about the cabal packages?
02:48:21 <rostayob> ah right
02:48:33 <rostayob> well you can keep the debian packages, i guess
02:48:37 <fasta> I wonder whether there will ever be a time where one can expect 30 year old programs to Just Work.
02:48:53 <rostayob> but your cabal directory can be managed by one version of cabal :P
02:49:07 <fasta> In GHC packages are either too new or too old.
02:49:08 <rostayob> fasta: we don't want that world. bleeding edge is good! and we'd be out of work.
02:49:15 <int-e> fasta: just keep the hardware around with it *g*
02:49:17 <hpaste> keep_learning pasted “Cabal install error” at http://hpaste.org/56108
02:49:22 <fasta> rostayob: I disagree :)
02:49:28 <rostayob> fasta: it was a joke
02:49:38 <fasta> rostayob: there is some truth to it.
02:49:42 <hpaste> keep_learning annotated “Cabal install error” with “Cabal install error (annotation)” at http://hpaste.org/56108#a56109
02:49:50 <rostayob> yeah... but cabal really is a mess
02:50:00 <fasta> rostayob: because people create broken systems, they keep having to continue to patch the system.
02:51:04 <rostayob> fasta: well you're speaking in really abstract terms now
02:51:16 <rostayob> i'm more concerned with cabal's fixable problems
02:51:32 <fasta> rostayob: I already explained 5 years ago how cabal could be fixed ;)
02:51:53 <rostayob> fasta: you did?
02:51:58 <fasta> rostayob: yes, I did.
02:52:09 <fasta> rostayob: I am not a nneeeeewwwbieee.
02:52:37 <keep_learning> I am trying to install cabal-install for ghc-7.2.2
02:52:37 <rostayob> fasta: well now you just have to actually fix it and we're done :)
02:52:42 <keep_learning> but getting error.
02:52:59 <fasta> rostayob: it is an economics problem, not a technical problem.
02:53:07 <fasta> rostayob: everything can be fixed with money.
02:53:08 <keep_learning> http://hpaste.org/56108
02:54:21 <rostayob> fasta: or with violence
02:56:35 <int-e> keep_learning: cabal-install 0.10.2 can't be built with ghc-7.2; the darcs version works, I believe.
02:57:09 <somenick> hey guys
02:57:30 <somenick> is it possible to define a new type as only a "part" of an existing one?
02:57:48 <Lemmih> Nope.
02:58:16 <somenick> i only found that you can use 'type' to get an existing type kind of renamed and 'data' to combine some existing
02:58:52 <keep_learning> int-e: where can i find darcs version works.
02:59:10 <somenick> but what to do if i want to have a type 'MyOwnType' which can only have the values "abc" "def" "ghi", for example
02:59:36 <int-e> somenick: you can use newtype and redefine the operations of interest to take the restricted range into account.
03:00:21 <somenick> int-e: how would i do that? i thought newtype could only produce types out of combinations of existing types
03:02:02 <fasta> somenick: newtype MyOwnType = MyOwnType String;f x@"abc" = MyOwnType "x"
03:02:07 <int-e> somenick: newtype Nat = Nat Integer; instance Num Nat where ... fromInteger x | x < -1 = error "negative natural" | otherwise = Nat x .... It'll be quite a bit of boilerplate and often is not worth the effort (in my opinion), but semantically it'll give you the right thing.
03:02:33 <fasta> The 'real' solution for this stuff is dependent types.
03:02:56 <fasta> It is just that current implementations of dependent types are kind of bad.
03:03:30 <int-e> sorry. x <= -1 or x < 0. x < -1 is just wrong :-(
03:04:01 <somenick> fasta, int-e: hum. so it seems like there is no good way for doing this and it would be easier just to use type MyOwnType = String and then only use the values I want for that type?
03:04:08 <somenick> and do error checking manually, if needed
03:04:35 <Entroacceptor> somenick: you know about agebraic data types?
03:05:02 <somenick> yep. but i think you can only combine existing types using 'data', isn't it?
03:05:36 <Entroacceptor> @src Maybe
03:05:36 <lambdabot> data Maybe a = Nothing | Just a
03:05:45 <int-e> somenick: yeah. sometimes a change in design may be worthwhile. if you have a finite set of strings, why not use an enum? data MyOwnType = Abc | X | Def ...
03:07:00 <int-e> somenick: in the end it's often a trade-off between ease of use and type safety.
03:07:06 <somenick> int-e: can I assign the Abc, X, Def String values also?
03:07:20 <somenick> cause if, it would be exactly what I wanted :)
03:07:35 <Entroacceptor> fixed strings?
03:07:37 <somenick> if not, it would be easier to just use Strings ;)
03:07:39 <somenick> yeah
03:07:42 <int-e> somenick: you can provide a custom enum instance with fromEnum and toEnum implemented accordingly.
03:08:08 <somenick> int-e: okay, then i will search for the enum doc. thanks a lot!
03:08:20 <int-e> somenick: but that'll give you Int values only and you probably want strings.
03:08:29 <somenick> ah, okay
03:08:30 <somenick> yep
03:08:32 <somenick> :P
03:09:07 <somenick> actually, it's characters. so i could use ascii-codes as int as a workaround ;)
03:09:22 <int-e> right. yuck :)
03:09:26 <somenick> but that would be overthinking the problem
03:09:45 <somenick> so i would stick to type MyOwnType = String
03:09:48 <somenick> resp. Char
03:09:56 <int-e> either use strings or provide some ad hoc conversion functions  fromMyType / toMyType
03:09:56 <somenick> anyway, thanks for the quick help!
03:10:25 <somenick> nah, thats too complicated for my usage ;)
03:11:00 <robbert`> Hello,
03:11:03 <robbert`> I have a type class for dependent sequences (see http://hpaste.org/56111). Possible inhabitants are lists with elements of alternating type.
03:11:09 <robbert`> I would like to inhabit it with non-dependent lists too, but my current attempt is quite ugly. Allows Haskell me to do this in a nicer way?
03:11:28 <lukish> How can I generate all splits like f [1,2,3] = [[1,2,3],[[1,2],[3]],[[1],[2,3]],...]?
03:12:57 <shachaf> lukish: First write the type of the function you want.
03:13:50 <lukish> shachaf: [a] -> [[[a]]]
03:14:12 <rostayob> lukish: what about that first element?
03:14:36 <lukish> Typo
03:14:41 <rostayob> ok
03:15:09 <etpace> is it possible to have multiple files loaded in ghci? I'd like to throw a few functions together for debugging but they are not exported, so ideally id like the scope of having :load all three files.. at once
03:16:19 <Saizan> etpace: try :m + *Module
03:16:30 <aadrake> Enigmagic: (or anybody) do you know if there is a library that can map the structure of a JSON file or MongoDB database in order to determine all the unique keys?
03:18:07 <asda8> what's wrong with this code? http://hpaste.org/56112
03:18:38 <rostayob> lukish:
03:18:39 <rostayob> splits [] = []
03:18:41 <rostayob> splits (x : xs) = [[x], xs] : map (\(y : ys) -> (x : y) : ys) (splits xs)
03:19:00 <asda8> ghc gives me the warning "Defaulting following contraints to type `Integer` ... (Integral a0) arising from a use of `floor`"
03:19:04 <Sgeo> Saizan, is that also recommendable for not losing local bindings?
03:19:15 <Sgeo> Wait, can you reload modules?
03:19:21 <shachaf> asda8: I doubt that "x - ANYTHING" is a Bool.
03:19:44 <Saizan> shachaf: there's a <
03:19:55 <shachaf> Oh.
03:20:02 * shachaf misreads.
03:20:03 <srhb> Also, I get no error, asda8
03:20:08 <srhb> Nor warning.
03:20:12 <Saizan> asda8: it's just saying that the result of floor x that is passed to fromIntegral will be of type Integer
03:20:16 <Axman6> asda8: try (fromIntegral (floor x :: Int)) < ...
03:20:19 <shachaf> asda8: Well, what's wrong with it?
03:20:20 <asda8> -Wall
03:20:31 <rostayob> aadrake: all the unique keys in the documents of a DB? I remember you asking that a few days ago :)
03:20:38 <rostayob> the quickest thing is probably to hand craft that
03:20:59 <Axman6> hmm, also that test is for more computationally expensive than needed i think. it's just x < 1
03:21:00 <aadrake> rostayob: I think we talked about it a few days ago and concluded that it could be done with aeson
03:21:03 <shachaf> asda8: Are you really asking us to paste that code into a file and compile it with GHC with -Wall just to see what the error is? :-(
03:21:08 <Axman6> oh, there's the x-, my bad
03:21:19 <asda8> shachaf: just a sec
03:21:20 <lukish> rostayob: well, okay. But actually for [1,2,3,4] I want to have [[1],[2,3],[4]] too
03:21:21 <aadrake> rostayob: I wanted to ask Enigmatic though because he is going a lot of work with MongoDB so may know of a library
03:21:25 <rostayob> aadrake: aeson? no, if I understand well you just want to traverse a series of json document
03:21:32 <asda8> http://hpaste.org/56113
03:21:34 <rostayob> lukish: ah, wait
03:21:52 <aadrake> rostayob: I just want to run through the document and build a list of unique keys
03:21:58 <asda8> I mentioned the warning, but this is the exact message
03:22:16 <rostayob> aadrake: wait, 1 document?
03:22:25 <aadrake> rostayob: At the moment, yes
03:22:27 <rostayob> in a json document the keys are all unique
03:22:40 <shachaf> You aren't specifying the type of "floor x"
03:22:42 <shachaf> The first one, that is.
03:22:45 <aadrake> rostayob: What I mean is, not all records may have all keys, and I don't know which keys are in the file beforehand.
03:23:03 <rostayob> ok, so you want to traverse a series of JSON records, not just
03:23:05 <rostayob> 1
03:23:06 <shachaf> You're just flooring a Double and then fromIntegraling the result immediately.
03:23:11 <aadrake> rostayob: Correct
03:23:18 <rostayob> well how hard can that be? just keep a Set of keys
03:23:23 <aadrake> rostayob: Traverse a series of records and store unique keys.
03:23:26 <rostayob> and insert all the keys you find as you traverse the document
03:23:29 <asda8> shachaf: ok, I'll try to specify it then
03:23:41 <rostayob> at the end the Set will contain all the keys
03:24:05 <aadrake> rostayob: Correct, but I don't know if something like that already exists as part of a library.  If that were the case, I would use the library.
03:24:19 <rostayob> aadrake: we're talking about 5 lines of code here eh :P
03:24:21 <shachaf> asda8: You can use "fromInteger" instead of "fromIntegral". :-)
03:24:25 <rostayob> anyway got to go
03:24:35 <asda8> shachaf: thanks!
03:24:44 <aadrake> rostayob: I'm new to Haskell, so those 5 lines may take a while.  :) Have a good day.
03:24:57 <rostayob> aadrake: look at Data.Set
03:25:08 <rostayob> http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/Data-Set.html
03:25:31 <aadrake> rostayob: Will do.
03:28:24 <mux> do you guys know if John MacFarlane happens to come on this IRC channel?
03:28:58 <asda8> it's also strange that I have -fspec-constr-count set to 5, but still get warnings about it being 1 and not enough
03:30:04 <Sgeo> Is there something like Data.Set for if I only have an Eq?
03:30:29 <shachaf> Sgeo: There's []
03:31:08 <shachaf> I don't think there's exactly what you want in the standard library.
03:32:11 * Sgeo managed to temporarily confuse Set and Map
03:32:11 <Sgeo> :/
03:32:33 <shachaf> Oh.
03:32:36 <shachaf> In that case...
03:32:37 <shachaf> There's []
03:32:42 <shachaf> I don't think there's exactly what you want in the standard library.
03:32:55 * shachaf is glad to provide you with a new updated answer.
03:33:10 <int-e> @type lookup
03:33:11 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:37:41 <Saizan> asda8: it gets spent
03:38:10 <Saizan> asda8: anyhow you shouldn't worry too much about that, it's just giving up on an optimization
03:43:07 <Peaker> fasta: I missed your explanation of how to fix cabal from 5 years ago.. can you paste a link or so?
03:57:10 <aadrake> So I upgraded go GHC 7.4 last week, and now whenever I try to start ghci I get a segfault.  Any ideas?
03:57:11 <int-e> has anybody ever used Data.List.deleteFirstsBy?
03:57:45 <rostayob> aadrake: I don't know what your problem is, but you should use the haskell platform GHC for your day-to-day development
03:58:19 <aadrake> rostayob: I wanted to test the ekg library, which required GHC 7.4
03:59:35 <Lemmih> aadrake: Does -v say anything?
03:59:42 <rostayob> aadrake: well, that sucks. they're probably making use of GHC.Generic...
04:00:24 <gienah> GHCi, version 7.4.0.20111219 runs fine for me
04:00:37 <rostayob> but you don't want to use those libraries in production, imho. A lot of packages might break (if using the very last ghc and not the haskell platform)
04:01:02 <aadrake> Lemmih: ghci -v starts ghci without complaint but makes complains about dph-par and dph-seq missing
04:01:09 <aadrake> well warnings really
04:01:24 <Igloo> aadrake: Are you on OSX?
04:01:29 <aadrake> Igloo: Yes
04:01:54 <gienah> most of the breakages are trivial, there is some breakage that seems tricky though (e.g. happstack-server)
04:02:38 <aadrake> rostayob: This isn't for production, so it's okay :)
04:02:45 <rostayob> aadrake: ok, have fun then :)
04:02:57 <rostayob> GHC 7.4 introduces *a lot* of cool stuff
04:05:03 * gienah see that more packages are breaking on bumps with ghc 6.12.3
04:13:14 <The_Journey> hi, must my files be captilized to be imported from another file?
04:13:38 <kuznero> Good day, all!
04:14:00 <rostayob> The_Journey: modules have to start with capitals, and files have to match modules names, so...
04:14:36 <The_Journey> is there a reason Haskell does that? I always make my files lowercase before :(
04:14:36 <rostayob> actually, no
04:14:41 <rostayob> they don't have to match, sorry
04:15:02 <The_Journey> rostayob: how would I import another file then.?
04:15:17 <rostayob> The_Journey: haskell abstracts away the notion of file, you import the module directly
04:15:59 <rostayob> and the relative module will be imported automatically. the compiler will look for a file in the same directory tree, or for a module in your libraries
04:16:26 <rostayob> it's much more convenient then importing files manually. a lot of modern programming languages work that way (java, python)
04:16:54 <erus`> files are on the way out
04:17:02 <merijn> All sane languages work that way
04:17:07 <rostayob> well the most convenient thing is to have a module system like ML's, imho, but if you don't
04:17:13 <rostayob> merijn: look at SML
04:17:26 <rostayob> but modules are first class there
04:17:28 <The_Journey> rostayob: I don't understand, when my file is lowercase, the compiler still throws an error.?
04:17:32 <merijn> rostayob: SML has modules too, right. Rather than files
04:17:47 <byorgey> The_Journey: the file name must be the same as the module name.
04:18:09 <byorgey> rostayob: although the Haskell *language standard* does not specify anything about files, in practice *GHC* requires the file name to be the same as the module name.
04:18:09 <rostayob> byorgey: if you want to import it
04:18:29 <rostayob> otherwise it's fine
04:18:33 <byorgey> rostayob: yes, and that is what The_Journey is asking about.
04:18:40 <rostayob> ye[
04:18:42 <rostayob> *yep
04:19:04 <rostayob> in fact that's what I told him
04:19:25 <byorgey> ...
04:20:35 <ski> "A Ban on Imports" by Gilad Bracha at <http://gbracha.blogspot.com/2009/06/ban-on-imports.html>
04:22:27 <ski> merijn : there is no automatic mapping from module names to file names in e.g. SML/NJ
04:22:39 <rostayob> ski: I've already read that and I partly agree with him, in Java a lot of tools have been created to do dependency injection, which is basically a solution to that problem
04:22:47 <rostayob> SML solves it the nicest way
04:22:54 <rostayob> in Haskell the problem remains
04:23:03 * ski nods
04:23:06 <merijn> ski: Sure, but I wasn't really referring to that
04:23:12 <sebf1704> hello
04:23:15 <merijn> ski: Maybe I misparsed the conversation
04:23:24 <ski> (or maybe i did)
04:24:23 <rostayob> for example, this: http://code.google.com/p/google-guice/
04:24:36 <rostayob> which is hackish but works well for big ass java systems
04:28:38 <rostayob> also, I doubt you'll ever need recursive modules in SML...
04:35:31 <Joel_> does anyone know if c2hs is 'not working' on  c99 specifics such as the _Bool type ?
04:36:05 <rostayob> _Bool is not C99, afaik
04:37:38 <Joel_> Ah i see. But it is what the bool from stdbool (that popped up at c99) is defined as ?
04:38:12 <geekosaur> only in some implementations
04:38:28 <rostayob> Joel_: no, you're right and I'm wrong, C99 as _Bool
04:38:49 <rostayob> *has _Bool
04:39:55 <Joel_> The problem is a function that looks like this after preprocessing _Bool f(void) and c2hs says "The type specifiers of this declaration do not form a legal ANSI C(89) type"
04:41:01 * geekosaur intended a ? on the end of that comment
04:41:34 <rostayob> Joel_: firstly, why aren't you using _Bool and not just bool?
04:42:21 <arw> because its just #define bool _Bool?
04:42:55 <rostayob> yeah but I don't thing you're supposed to use _Bool explicitly
04:43:20 <rostayob> the _Bool layer is added to allow compatibility through stdbool.h
04:43:46 <rostayob> *don't think. can't spell today.
04:44:01 <arw> doesn't really matter, its really only a #define
04:44:55 <rostayob> arw: personally I'd cringe if I saw _Bool, and maybe the c2hs is related (although it's just a wild guess)
04:45:26 <arw> no. the error message says it all: _Bool is not valid ansi C.
04:45:27 <Joel_> _Bool is there after preprocessing, the source file says bool.
04:45:50 <rostayob> Joel_: ah. I'm afraid I can't help you then...
04:45:54 <arw> _Bool is C99, every earlier occurence of _Bool is a compiler specific extension.
04:46:21 <arw> and every earlier kind of bool is usually some fancy library that just redefines int.
04:47:56 <Joel_> Ok, thanks anyway all. Ill keep digging.
04:48:54 <arw> well. if c2hs says it wants C89 you just can't use _Bool.
04:49:10 <arw> no need to dig further than the error message there.
04:50:05 <Joel_> That is true.
04:50:51 <Joel_> Googling on this topic only finds vague things. something about a patch from years ago that "add _Bool and _Complex" .
04:51:17 <Joel_> That made me hopeful..
04:54:44 <xplat> fun question (i hope): can anyone come up with an alternate type for 'on' using 7.4 extensions that will type things like ((^) `on` (+1)) pi 1 or ((,) `on` succ) False 'a' ?
04:56:16 <djahandarie> Yes! (Proof incoming next commit.)
05:06:23 <Baughn> Teenage Boy: "I don't know how this place works"
05:06:23 <Baughn> Teenage Girl: "It's like iTunes but in a building"
05:06:30 <Baughn> ...CD shops are so dead.
05:06:49 <Starfire> Haha.
05:07:22 <mokus> they were dead before iTunes, Apple just put the last nails in the coffin
05:08:28 <clsmith> Baughn: wow, that actually happened? :|
05:08:34 * hackagebot paragon 0.1.7 - Paragon  http://hackage.haskell.org/package/paragon-0.1.7 (NiklasBroberg)
05:09:20 <Baughn> clsmith: Overheard on a local street
05:09:56 <clsmith> jeez
05:30:05 <hpaste> keep_learning pasted “Parallel  Fibonacci Computation” at http://hpaste.org/56114
05:30:31 <keep_learning> hello all
05:31:43 <keep_learning> I wrote a parallel fibonacci program but its run time is deteriorating with increasing cores.
05:32:26 <keep_learning> Could some one please having more cores kindly run the code and post the result.
05:33:13 <ddarius> That version is going to be much slower than the sequential equivalent.
05:34:45 <hpaste> dmwit annotated “Parallel  Fibonacci Computation” with “Parallel  Fibonacci Computation (annotation)” at http://hpaste.org/56114#a56115
05:36:03 <keep_learning> ddarius,  yes but I am computing it parallel to just get feeling of parallelism by Haskell.
05:36:09 <dmwit> GHC.Conc.numCapabilities reports 1 here as well, though I definitely have four cores.
05:37:00 <dmwit> Ah, numCapabilities just prints whatever number you pass to +RTS -N anyway.
05:37:14 <dmwit> It's not an indication of whether your machine can profitably use more threads or not.
05:37:33 <keep_learning> dmwit, Yes ,  i saw your 4 cores performed great ( Total   time   15.98s  (  4.52s elapsed) )
05:37:40 <keep_learning> dmwit, thank you
05:38:23 <keep_learning> dmwit, numCapabilities is not for counting the number of cores ?
05:38:49 <dmwit> keep_learning: No, it's not.
05:39:11 <ddarius> keep_learning: You can make a parallel version that will be faster than the sequential equivalent.  You are allocating 160,000,000 sparks and actually using 84.
05:40:17 <keep_learning> ddarius, yes but i don't know how to improve.
05:41:08 <keep_learning> ddarius, Probably most the values are evaluated but not sure. Just started learning   parallel haskell
05:41:37 <dmwit> Wow, what a huge number of GC'd sparks.
05:41:43 <dmwit> Plenty fizzled, too.
05:43:15 <cheater> hello
05:44:06 <cheater> i am having problems installing process-1.1.0.0 which requires runProcess.h. My ghc was installed from the "generic linux binary" tarball, and that tarball contains that file. how do i install this properly so that the file can be found?
05:45:26 <parcs`> xplat: you can do "on :: (k a1, k a2) => (a1 -> a2 -> c) -> (forall a. k a => a -> a) -> a1 -> a2 -> c" but eg k a and Enum a won't automatically unify
05:45:44 <ddarius> keep_learning: The only thing you need to do to improve it, is not spark a thread for every single element.  It is not profitable to run "1" in parallel.
05:47:22 <keep_learning> ddarius, I am bit confused with par , pseq and rpar , rseq .Why do we have both ?
05:49:02 <ddarius> keep_learning: You may want to compare the number returned by your program to the number of sparks.
05:51:47 <rostayob> is there a "Haskell style guide" flying somewhere? Each programmer seems to write Haskell with different indentation/spacing etc., it hurts my eyes
05:51:53 <rostayob> and i can't decide which is better?
05:52:07 <rostayob> do we put '=' on a new line? what about do's body?
05:52:28 <rostayob> even the base libraries are not consistent
05:52:31 <hpaste> keep_learning annotated “Parallel  Fibonacci Computation” with “Parallel  Fibonacci Computation (annotation)” at http://hpaste.org/56114#a56117
05:53:27 <keep_learning> ddarius,  i put a condition  if n <= 10 then compute sequential but still the lot of sparks have been killed.
05:53:34 <parcs`> rostayob: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
05:53:44 <hpc> rostayob: there's a style guide that doesn't specify a whole lot, but is 100% uncontrovertial
05:53:47 * hpc finds
05:54:13 <keep_learning> ddarius, did i understand you correctly.
05:54:29 <hpc> http://urchin.earth.li/~ian/style/haskell.html
05:54:34 <cheater> parcs`: any ideas how to get those headers installed properly?
05:54:35 <hpc> rostayob: ^
05:55:00 <rostayob> hpc: yeah, it doesn't specify a lot of things, but it's something.
05:55:27 <rostayob> like, do I align the function arguments?
05:55:44 <hpc> rostayob: that could go either way
05:55:55 <rostayob> do I always pattern match when possible or a lambdas in top-level definitions acceptable?
05:55:58 <hpc> i personally don't, unless it is hard to tell otherwise
05:56:02 <rostayob> pattern match at the top level
05:56:13 <parcs`> cheater: try installing process-1.0.1.5
05:56:37 <mm_freak> hpc: "100% uncontroversial" is 100% controversial
05:56:38 <parcs`> it doesn't seem to build on hackage as well
05:56:46 <hpc> rostayob: i follow the convention of "write it how it looks like"
05:57:02 <hpc> rostayob: if i use (f . g) more often than f . g $ x, i might write
05:57:09 <hpc> f . g = \x -> f (g x)
05:57:29 <hpc> it's the same thing, just with it being more obvious that (f . g) returns a function
05:57:50 <hpc> the way you write your code should draw attention to what it does/means
05:57:51 <rostayob> yeah actually the use of $ and . is tricky as well
05:58:27 <mm_freak> can you even make a comprehensive style guide in haskell?  it's not like C++, where you have some general pattern
05:58:44 <mm_freak> for example i find the style with aligned commas in records VERY ugly
05:59:06 <rostayob> i like that one
05:59:57 <rostayob> but we should agree at least on basic things, e.g. 4 spaces vs 2 spaces
06:00:07 <mm_freak> i like how you can read haskell code like a textbook, if it's written with that in mind…  records sort of correspond to lists there
06:00:09 <rostayob> i've even seen 1 spaces
06:00:17 <parcs`> lets compromise on 3 spaces
06:00:17 <mm_freak> yeah, that's true
06:00:45 <mm_freak> well, i use consistent, but context-sensitive indentation, so 4 by default, but 2 in certain places
06:00:51 <rostayob> also, the other thing that is not clear is do's: body on the same line or not, semi colons, braces and semi colons
06:00:52 <Saizan> i use randomRIO (1,8) spaces
06:01:49 <rostayob> the thing is that i can't decide myself lol
06:01:53 <rostayob> each time i write a different haskell
06:02:10 <ddarius> rostayob: Write your code so that it's easy to read.  Not that it follows some arbitrary rules.
06:02:18 <Saizan> i think "do not use braces and semicolons" is a rule we can all agree with, remembering that such rules are meant to be broken in rare cases
06:02:32 <rostayob> ddarius: well, i can't decide if 2 spaces are better than 4 spaces.
06:02:36 <mm_freak> fmap   iUse_spaces (    randomRIO        ( 1,    8 )   )
06:02:37 <ddarius> You should -typically- follow some arbitrary rules, but certainly not always, let alone everyone always following some arbitrary rules..
06:02:50 <ddarius> rostayob: Flip a coin.
06:03:17 <rostayob> i think i'm going to go for 4 spaces since i can indent the where 2 spaces less
06:03:46 <srhb> rostayob: Same argument goes for 2/2
06:03:51 <rostayob> ddarius: i agree, but in the haskell community there is no agreement watsoever, and it annoys me to read code with a new style each time
06:04:25 <srhb> Learn not to obsess. :-)
06:04:30 <rostayob> that's... hard
06:04:32 <ddarius> There are some general vague agreements, but as long as the style doesn't vary within the code base itself, I don't see what your problem is.
06:04:55 <srhb> I'm sure it'll be healthy practice. :P
06:05:17 <mm_freak> haskell is not meant to have a strict coding standard
06:05:29 <mm_freak> it's intentionally free-form
06:05:42 <mm_freak> at least nowadays, now that we see the advantages
06:05:54 <rostayob> i don't know. maybe the best answer is "learn not to obsess"
06:06:02 <mm_freak> code should be written to be easily readable, not to follow any standard
06:06:08 <mm_freak> yeah
06:06:34 <yrlnry> If you want to obsess over minutiae of syntax and whitespace layout, I think Perl is still available.
06:06:38 <rostayob> still, most programming communities have an idiomatic style
06:06:47 <mm_freak> do they?
06:06:52 <frerich> I'm sorry for being offtopic but I figure people around here (with an academic background) might have needed something like this in the past: I'm working on an internal presentation of some Haskell program (showing it to a few colleagues) and as part of this I'd liek to include a graphic which shows how a function maps certain strings to other strings. Both sets of strings (input and output) are about 15 elements.
06:06:52 <frerich>  Is anybody aware of some software which can be used to generate such illustrations nicely? My puny attempts using the Windows paint program arent' too impressive :-/
06:06:55 <ddarius> rostayob: No they don't.  They, at best, have several common styles.
06:07:00 <mm_freak> there are dozens of coding standards even for C
06:07:22 <rostayob> ddarius: java, python, ruby, js have one
06:07:30 <rostayob> C has several well recognised ones :P
06:07:38 <mm_freak> frerich: graphviz
06:07:42 <ddarius> rostayob: No they don't.
06:07:55 <rostayob> ddarius: yes they do, expecially java and python
06:08:03 <ddarius> Javascript has a lot of rather significant style differences.
06:08:17 <arw> frerich: if you are into (La)Tex: http://www.texample.net/tikz/examples/
06:08:24 <ddarius> Eclipse let's you specify several different options, same for Visual Studio for C#.
06:08:27 <mm_freak> rostayob: i get your point, but is the idiomatic style always the best style?  for example most company coding standards for PHP assume that all programmers are idiots
06:08:34 <ddarius> The only one of those that -might- is Python, but I doubt that too.
06:08:37 <rostayob> well, but for javascript, since it actually makes a difference, there is much agreement at least on keeping the braces on the lines
06:08:49 <rostayob> ddarius: java and python do have an official style
06:08:51 <mm_freak> i remember a coding standard, where you would be disallowed to use "continue", because other programmers may not know it
06:08:59 <rostayob> there's even a PEP iirc
06:09:04 <mux> yeah, there is
06:09:07 <mm_freak> let alone closures or even anonymous functions altogether
06:09:44 <rostayob> ddarius: and with javascript there is, more or less (braes on line, 4 spaces) i can't be sure about ruby
06:09:47 <ddarius> rostayob: Having something proclaim itself to be the "official style" is hardly the same as having the entire community follow that style, or even a majority.
06:10:05 <rostayob> ddarius: ? it's the official style in the sense that the language creators published it
06:10:16 <ddarius> rostayob: That doesn't mean the language users follow it.
06:10:19 <rostayob> and most of the code is written that style
06:10:30 <ddarius> rostayob: You've read most of the code written in Java?
06:10:49 <rostayob> i've read a lot of java code and it's mostly written in that style. python even more
06:11:13 <rostayob> with Haskell there isn't even a slight agreement. it's not a big deal, but i think it wouldn't hurt
06:11:31 <ddarius> So now it's already only "mostly written" in that style.
06:11:43 <arw> rostayob: what would be the point of an official style? it provides nothing but a useless point of friction between people about following or not following it.
06:11:45 <rostayob> ddarius: what are you trying to prove? of course people write what they wayt
06:11:45 <mux> it sure wouldn't, but let's not forget that the most important thing is still that style stays consistent within the same project
06:12:10 <rostayob> ddarius: but it's clear to me that the haskell and java/python community are very different on that matter
06:12:15 <frerich> mm_freak, arw: Thanks for the pointers! I'm doing this as mostly plain HTML actually (one page per slight), so (La)TeX is not very useful in this case, but graphviz seems nice. I new it, but I alawys only used it to draw trees... didn't occur to me to use it here :-}
06:12:33 <rostayob> arw: the fact that, at least for me, code would be easier to follow
06:13:06 <ddarius> mux: No, the most important thing is that the code is readable.  And obsessive consistency for minor syntactic details rarely impacts that much.  If I changed all my 4 space indents to 5 spaces, you probably wouldn't even realize it.
06:13:15 <mm_freak> frerich: you'll have to read the documentation on how to make it display graphs without roots nicely, though
06:13:19 <rostayob> ddarius: i'd definitely notice it.
06:13:29 <arw> rostayob: in haskell, following code is usually not a matter of reading the syntax but of understanding which of the 18299 variants of writing the same function the author picked.
06:13:44 <ddarius> rostayob: And it would immediately become impossible for you to read?
06:13:44 <rostayob> also, we're not talking about "minute details", just about 2 or 3 basic things
06:13:58 <rostayob> ddarius: no, but it would impact the ease of reading
06:14:04 <ddarius> rostayob: In what way?
06:14:12 <ddarius> Positively or negatively?
06:14:24 <mux> ddarius: obviously code needs to be readable. very obviously. but we were talking about different coding style, and that it should be readable is definitely a given...
06:14:25 <rostayob> negatively, i'd have to adjust my eyes and mind to the other style
06:14:41 <mux> ddarius: plus I'd definitely notice it (4 spaces vs 5)
06:16:06 <Saizan> ddarius point is that some code is more readable written some way and other code is more readable written in another
06:16:08 <ddarius> rostayob: Then there is something wrong with your eyes and/or mind.  You do essentially the same thing with written text all the time.
06:16:12 <mm_freak> rostayob: the haskell community has become quite large now…  the fact that there is still little agreement on style shows an interesting language property, do you see it?
06:16:16 <Saizan> and that's more important than consistency
06:16:16 <rostayob> i mean companies like google make a huge deal about this, and i don't think it's entirely silly
06:16:27 <srhb> If I have: do.. where.. can I then not use names from the do syntax in where?
06:16:38 <mux> Saizan: those differences can be incorporated in one single style without any problems.
06:16:42 <Saizan> srhb: nope, you can't
06:16:50 <rostayob> ddarius: and in fact there are a lot of conventions with written text, and if i change them you'd be annoyed.
06:16:53 <srhb> I see.
06:16:58 <arw> rostayob: in corporations, those things are usually the result of some management guy being bored...
06:16:59 <rostayob> paragraph indentation, 10/12pt fonts
06:17:04 <ddarius> rostayob: Yes, but there is also a lot of variety too.
06:17:05 <rostayob> not too large columns
06:17:18 <xplat> parcs`: how would you use it then?
06:17:20 <rostayob> ddarius: not really. you always read 10pt serif books and newspaper
06:17:22 <rostayob> s
06:17:27 <ddarius> Even in the text I'm writing write now, I have a different stylistic feature than most people here.  Do you know what it is?
06:17:27 <Saizan> srhb: you can use let inside do though, e.g. do x <- ..; let y = ..; someCommand x y
06:17:39 <mux> ddarius: two spaces after ending dot
06:17:40 <xplat> parcs`: if the unification won't happen automatically
06:17:41 <srhb> Saizan: Thanks. :)
06:17:43 <rostayob> ddarius: i don't, but whatever it is, you're used to it
06:17:56 <rostayob> and it'd take some time for me to adjust
06:18:14 <mux> it was immediately obvious to me, at least
06:18:20 <ddarius> rostayob: What does it matter whether I'm used to it?  Also, if you can't tell what it is, then it is apparently taking you 0 time/effort to get used to it.
06:18:34 * hackagebot monadiccp 0.7.2 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.2 (PieterWuille)
06:18:43 <rostayob> ddarius: of course it matters, you're used reading text that way on a computer
06:19:02 <rostayob> ddarius: are you really arguing that it's completely useless to have some code consistency? then why have consistency in the same project?
06:19:07 <ddarius> rostayob: No I'm not.  But the issue is what the readers of the text I'm writing will see.
06:19:08 <rostayob> *code style consistency
06:19:42 <rostayob> ddarius: what? i don't follow
06:20:01 <parcs`> xplat: you have to annotate the type of k somehow
06:20:18 <ddarius> rostayob: I'm saying it's bad to slavishly follow arbitrary rules about style and expecting them to be followed by absolutely everyone in a large community is ridiculous.  And I don't even recommend slavishly following a single style within the same project or even the same file.  I don't.
06:20:40 <ddarius> That said, there should be generally some coherence within a project including syntactically.
06:20:54 <mux> well yeah, so you don't, but you do
06:21:10 <mux> you're just pedantically bickering about the what constitutes a significant difference and what doesn't.
06:21:13 <rostayob> ddarius: ok, i think you are wrong on the idea that you can't have conventions on that (the mentioned programming communities have them and most of the people follow them)
06:21:13 <arw> rostayob: consistency within a project is usually an aesthetic and practical thing, you just don't want things to look weird, ugly or perhaps misleading. but between two projects, nothing of that is necessary.
06:21:40 <rostayob> ddarius: i also know for sure that these things matter to me. they clearly matter less to you
06:21:46 <erus`> whats the cutting edge ghc features people are working on?
06:21:54 <erus`> where can i read about them?
06:22:09 <ddarius> rostayob: And because it matters to you, tens of thousands of people should change what they do.
06:22:35 <xplat> parcs`: can you give me an example like one of my original 'ideal' examples?
06:22:44 <rostayob> ddarius: if they matter to me only, no. but i think that a lot of people care, if they went to great lengths to try to enforce them
06:22:50 <ddarius> mux: No, I'm saying even significant differences are allowable if they increase readability.
06:23:12 <mux> ddarius: significant differeneces typically hurt readability.
06:23:17 <ddarius> mux: Typically.
06:23:26 <mux> so I guess we agree.
06:23:30 <xplat> parcs`: i'm pretty new to actual use of ConstraintKinds
06:24:12 <mux> noone (that I saw) argued that we should all transform into style-nazis and punish people for a slight difference in coding style
06:24:27 <mux> it's still a good thing to at least /aim/ at consistency, where it makes sense.
06:25:32 <Saizan> the observable matter where some seem to be divided is "let's make an official haskell style guide"
06:25:38 <ddarius> mux: rostayob wants more than people just "aiming" at consistency.
06:25:39 <arw> mux: depends on how you define readability. code in a very consistent style easily hides things, one often overlooks bugs just because everything looks like what one is used to write. otoh, a different style announces code by a different programmer, so one pays more attention when reading.
06:26:13 <cheater> parcs`: thanks but that is already installed. shqq seems to be specifically requesting 1.1.0.0
06:26:17 <srhb> Hmpf. What's the reason where clauses can't see the bindings from do notation?
06:26:33 <srhb> It feels like it's just a loss of a readability tool.
06:26:49 <Saizan> srhb: because bindings in where clauses have a larger scope
06:27:24 <parcs`> xplat: the easiest way to annotate the type of k would be through adding a proxy argument, where "data Proxy a = Proxy". then you have "on :: (k a1, k a2) => (a1 -> a2 -> c) -> (forall a. k a => a -> a) -> Proxy k -> a1 -> a2 -> c" which you can use like so: "((,) `on` succ) (Proxy :: Proxy Enum) 5 False"
06:27:28 <srhb> At least there's a reason then. :-)
06:27:58 <srhb> Maybe I just haven't found the nice way to make let.. readable in do-notation.
06:28:00 <parcs`> xplat: this is a bad example of the new language extensions though because ideally ghc should be able to unify k a and Enum a automatically
06:29:55 <Sgeo> I'm sure this has been asked before, and I'm sure I've seen discussion, but is id strict?
06:30:02 <hpc> Sgeo: yes
06:30:13 <hpc> Sgeo: (id x) == x
06:30:19 <hpc> Sgeo: so when you evauate x, you evaluate x
06:30:32 <Saizan> const undefined is strict too
06:32:07 <Saizan> but "demands its argument" is often the more important property i guess
06:33:01 <hpc> Saizan: oh right, i forgot the definition of "strict"
06:33:12 <parcs`> cheater: try getting ghc 7.2.2, it comes with the latest version of process
06:33:39 <cheater> parcs`: i have 7.0.3...
06:33:59 <cheater> parcs`: is there a platform for 7.2.2 ?
06:34:17 <parcs`> nope
06:34:55 <cheater> i don't want to bother with non-platform... there needs to be a way to do it with 7.0.3
06:34:59 <cheater> it can't find the file
06:35:02 <cheater> or it finds the wrong one
06:36:45 <Sgeo> o.O at someone bringing a SimpleIRC-based bot in here
06:40:13 <parcs`> cheater: shqq probably doesn't need the latest version of process. try unpacking the package and removing the >= 1.1 constraint from the cabal file
06:42:33 <nexion> how could I sort [(x, y)] by x in ascending order? (x is a ByteString.Lazy)
06:42:53 <parcs`> sortBy (comparing fst)
06:43:38 <DukeDave> Mm, comparing.. Drool
06:44:00 <DukeDave> How does someone even spot that :)
06:44:21 <cheater> parcs`: i need to find a less problematic way to do it. i think the headers for ghc aren't installed properly.
06:44:57 <nexion> ty parcs`
06:44:59 <parcs`> cheater: it doesn't install for me, and i'm on ghc 7.2
06:45:36 <parcs`> cheater: and the header it's referring to is inside the cabal package
06:46:36 <cheater> parcs`: i also have a runProcess.h inside the ghc source tree..
06:46:43 <geekosaur> there's a bug in the latest released process package, yes, it doesn't install that header.  they were planning to release an update
06:46:58 <cheater> ...but that might be a version of process, if it gets bundled with ghc
06:47:12 <parcs`> cheater: same here but that's from an older version of process (in your case). look at its directory
06:48:08 <cheater> yeah that's for process 1.0.1.5
06:48:18 <erus`> is there a compiler switch to disallow partial functions?
06:48:47 <cheater> shqq displays in its dependencies: process >=1.1
06:48:59 <MostAwesomeDude> erus`: I can't imagine that there would be; currying's pretty essential to the language.
06:49:02 <geekosaur> erus`: I would doubt it, since they're kinda important
06:49:11 <erus`> no i mean
06:49:18 <geekosaur> ...that
06:49:21 <erus`> imcomplete patterns
06:49:27 <rostayob> -Werror
06:49:35 <MostAwesomeDude> ^^
06:49:49 <geekosaur> yeh, that's pretty much it
06:49:53 <rostayob> but that would stop a lot of other programs from compiling
06:50:08 <blueonyx> hi, anyone using the levmar package? what to do if i get the "InvalidValues" StopReason after one func call?
06:50:09 <rostayob> i don't know if there is a switch to turn just a specific kind of warning into errors
06:50:22 <geekosaur> also that's only part of the problem, it won;t e.g. stop you from using Prelude.head, only from defining your own
06:51:58 <aristid> geekosaur: solving that problem is impossible in haskell, i think :)
06:52:16 <cheater> geekosaur: any idea if the maintainer of process is in here?
06:52:52 <aristid> seeminglySafeHead (x:_) = x; seeminglySafeHead [] = seeminglySafeHead [] -- general recursion is dangerous ;)
06:53:32 <geekosaur> aristid, as I understand it we're only concerned with incomplete coverage of case expressions
06:53:33 <rostayob> aristid: wait, that function is safe in terms of pattern matching
06:54:03 <aristid> rostayob: that's the point!
06:54:11 <MostAwesomeDude> I prefer the Scheme solution: You have to ask null? before doing head.
06:54:17 <rostayob> anyway you can't have GHC to check compiled functions for partiality, for obvious reason, so -Werror will have an effect only on the current code as geekosaur said
06:54:25 <rostayob> MostAwesomeDude: you don't *have* to
06:54:36 <rostayob> aristid: ? the question was concerned with patterns coverage
06:54:56 <rostayob> MostAwesomeDude: you can car an empty list in Scheme
06:55:00 <aristid> rostayob: i was referring to "geekosaur | also that's only part of the problem, it won;t e.g. stop you from using Prelude.head, only from defining your own|
06:55:04 <MostAwesomeDude> rostayob: It's at the top of Little Schemer, though.
06:55:15 <rostayob> aristid: yeah, general recursion has nothing to do with that
06:55:26 <geekosaur> aristid, my point there was that -Werror won't help with incomplete patterns in already compiled code, not with the Halting Problem
06:55:30 <aristid> rostayob: yes it does :P
06:55:37 <aristid> rostayob: it's one of the ways to create bottom
06:55:44 <int-e> > map head . group . sort $ "abracadabra"
06:55:45 <lambdabot>   "abcdr"
06:55:47 <MostAwesomeDude> rostayob: Yeah, you don't *have* to, but if you follow the rules, you will write total Scheme every single time, which I think is a fine solution to the problem of people calling head without checking first.
06:55:53 <rostayob> ? no it doesn't, geekosaur was saying that -Werror won't check for partial functions outside the current code
06:55:57 <int-e> some uses of head are safe :)
06:55:57 <geekosaur> the question was not solving the halting problem, people.  it was erroring outon incomplete patterns
06:56:07 <aristid> @let uniq = map head . group
06:56:08 <lambdabot>  Defined.
06:56:15 <MostAwesomeDude> geekosaur: Welcome to #haskell! :3
06:56:19 <geekosaur> and my point was that -Werror won;t warn about already compiled code doing so
06:56:47 <rostayob> MostAwesomeDude: writing "total" scheme all the time doesn't make much sense to me. i doubt that even all the scheme in the little schemer is total.
06:57:18 <aristid> geekosaur: the popular to the halting problem seems to be to drop turing completeness (see: agda)
06:57:25 <aristid> *popular solution
06:57:32 <geekosaur> so has anyone trolled Agda as a response yet?  *eyeroll*
06:57:39 <rostayob> yeah but again: this has nothing to do with patterns
06:57:46 <rostayob> and the original question
06:57:47 <MostAwesomeDude> rostayob: Nah, after a couple chapters, it goes into assumptions about the lists that are being passed in.
06:57:52 <geekosaur> sigh.  aristid, could you focus on the question instead of trolling?
06:57:57 <aristid> rostayob: the ORIGINAL question was about partial functions.
06:58:01 <rostayob> MostAwesomeDude: exactly. "total" scheme would be incredibly tedious
06:58:07 <geekosaur> and explicated as being partial patterns
06:58:08 <rostayob> aristid: and geekosaur remark was about that as well
06:58:27 <aristid> geekosaur: i'm not trolling.
06:58:48 <MostAwesomeDude> I dunno. I think I just really prefer writing airtight code the first time around rather than having to fix it later. Maybe I've spent too much time as a maintenance programmer?
06:58:52 <geekosaur> no, you're just ignoring the parts of the question you don;t care about and berating everyone else for paying attention to them
06:59:10 <rostayob> MostAwesomeDude: languages like Scheme aren't about safety, imho.
06:59:12 <geekosaur> or something that's "not trolling" but also not helpful
06:59:28 <rostayob> you might as well exploit the lack of a type system
06:59:38 <Saizan> erus`: did you mean just partial patterns when you said partial functions initially? or the proper definition of partial functions?
06:59:42 <aristid> geekosaur: why were you mentioning that head is dangerous, then?
06:59:50 <aristid> geekosaur: that is not directly related to the question either.
06:59:53 <Saizan> *incomplete patterns
06:59:55 <geekosaur> I answered that twice.
07:00:00 <erus`> Saizan: i meant a partial pattern like head
07:00:02 <geekosaur> already compiled incomplete patterns
07:00:03 <aristid> head does not use incomplete patterns.
07:00:10 <aristid> it uses error.
07:00:31 <MostAwesomeDude> rostayob: Yeah, you're right, but OTOH my day job is writing safe Python, and I don't think that it's impossible to do so, but the programmer must be aware of the language's powers and pitfalls.
07:00:33 <Saizan> erus`: so allowing error and/or undefined is fine?
07:00:53 <erus`> yeah explicit error is ok i guess
07:00:54 <geekosaur> ok, play pedant instead to defend yourself.  that is still effectively a partial pattern, just with a custom error message, but far be it form anyone to detract from your repurposing of the question
07:00:54 <aristid> geekosaur: we're blowing this out of proportion, but i'm just really offended that you accused me of trolling.
07:01:10 <geekosaur> anyway I'm done, apparently it's wrong to ANSWER THE QUESTION ASKED
07:01:22 <aristid> no it's wrong to accuse me of trolling.
07:01:25 <geekosaur> and I'm offended that ANSWERING THE QUESION ASKED is offensive
07:01:27 <rostayob> aristid: i'm pretty sure that erus` didn't include functions that diverge into the picture, but yeah you guys are making a big deal out of this
07:01:41 <Saizan> erus`: anyhow there's just a warning about incomplete patterns, nothing more
07:01:43 <rostayob> MostAwesomeDude: but why would you use python then?
07:01:56 <erus`> Saizan: that will do :)
07:02:32 <aristid> geekosaur: i never criticized your original answer. i just tried to add context. and you criticized that as trolling.
07:03:05 <MostAwesomeDude> rostayob: Insanely fast development speed, powerful type system (in a totally different way than Haskell), ease of fluency, availability of libraries, etc.
07:03:25 <rostayob> MostAwesomeDude: type system? also, i doubt that you'd be fast with python if you want to write it "totally"...
07:04:10 <rostayob> def hello(x): print x.name
07:04:15 <MostAwesomeDude> rostayob: Python is never total. You take advantage of duck typing by specifying in your docs what kinds of inputs and outputs you expect, and then slapping people with a parrot whenever they mess up.
07:04:20 <rostayob> how do you fix this incredibly partial function?
07:04:28 <rostayob> MostAwesomeDude: oh, ok.
07:04:39 <MostAwesomeDude> You don't. You document "x must have a name attribute" and then walk away with a troll-stride. :3
07:04:59 <rostayob> well so the safety relies on people. so it's not that safe
07:05:36 <cheater> hmm
07:05:47 <Saizan> if only there were a system to make such properties checkable by a program..
07:05:47 <cheater> parcs`: i think you might be right with changing the dep in the .cabal
07:05:50 <MostAwesomeDude> There *are* strong interfaces. I could write this: def hello(x): named = INamed(x, None); if named is None: raise RuntimeError("hello: No name provided!");; print named.name
07:06:09 <cheater> but how do i get cabal to download the package for shqq ? i mean it doesn't store it in .cabal anywhere i can see which sucks
07:06:13 <rostayob> MostAwesomeDude: that is partial as well
07:06:14 <MostAwesomeDude> And there are times when that is needed. Last time I wrote a plugin system, I did this to discover interface implementations.
07:06:23 <Saizan> cheater: cabal unpack shqq
07:06:26 <aristid> MostAwesomeDude: but nobody guarantees that you didn't forgot to check for something first
07:06:34 <rostayob> you're replacing the interpreter error with your hand-crafted error
07:06:41 <mm_freak> i couldn't live with python's "type system"
07:06:47 <rostayob> eheh
07:06:56 <Saizan> cheater: cd shqq-*; edit the .cabal file also bumping the package version; cabal install
07:07:31 <mm_freak> since i know haskell i can't even live with most static, strong type systems…  let alone the dynamic "type system" of python
07:07:41 <rostayob> MostAwesomeDude: python isn't and will never be a safe language. still, it's really useful
07:07:41 <mm_freak> but i'd prefer python over most other dynamic languages
07:07:49 <rostayob> i really like python
07:07:51 <MostAwesomeDude> mm_freak: Stop putting it in quotes. You're not allowed to do that for languages which aren't PHP or JS.
07:08:01 <rostayob> JS is a nice language
07:08:08 <rostayob> stripped of the stupidity
07:08:10 <erus`> oh boy here we go
07:08:27 <mm_freak> MostAwesomeDude: my next statement is going to hurt a bit…  python is really just a (much) better PHP
07:08:28 <aristid> MostAwesomeDude: why not? it's true
07:08:29 <MostAwesomeDude> It's got undefined and null, == and ===, no custom types, horrible inheritance, bad coercion rules...
07:08:32 <cheater> Saizan: why would i bump the package version? i was thinking about lowering the package version rather than bumping it..
07:08:47 <MostAwesomeDude> mm_freak: Python predates PHP by several years. 0/10, try again.
07:08:47 <rostayob> MostAwesomeDude: true, still it's fun
07:08:48 <Saizan> cheater: i mean the version of shqq itself
07:08:55 <cheater> Saizan: so do i.
07:09:09 <mm_freak> MostAwesomeDude: so?  it's still a better PHP…  it has the same basic properties
07:09:19 <cheater> i find python much better than php
07:09:23 <cheater> world of difference
07:09:24 <Saizan> cheater: oh, well, the important part is that it must not match with any version on hackage
07:09:26 <MostAwesomeDude> mm_freak: Go on...
07:09:30 <parcs`> cheater: cabal unpack shqq; cd shqq-*; sed -ie 's/>= 1.1//' shqq.cabal; cabal install
07:09:31 <cheater> Saizan: why?
07:09:46 <cheater> parcs`: looks like a hack, not doing that!!
07:09:51 <mm_freak> executing files from top to bottom, dynamic typing, OO and the same design patterns in libraries
07:09:53 <Saizan> cheater: otherwise cabal will think it's the same as the one on hackage, which it won't because you edited it
07:09:59 <rostayob> there is a big usability difference between PHP and python, but they're in the same family
07:10:10 <cheater> Saizan: so what?
07:10:12 <MostAwesomeDude> mm_freak: PHP is object-oriented, Python is object-*based*.
07:10:18 <cheater> Saizan: i can force it to reinstall right?
07:10:29 <Saizan> cheater: so you'll get weird errors later because of this inconsistency
07:10:35 <cheater> MostAwesomeDude: php is not object oriented. don't make silly jokes.
07:10:39 <cheater> Saizan: ok
07:10:41 <mm_freak> MostAwesomeDude: PHP is not even object-oriented…  PHP is patched to support OO and is pretty sucky at that
07:10:46 <MostAwesomeDude> mm_freak: Python's got real lists, a parser that doesn't vomit easily, first-class functions at every scope, full callables and iterables, coroutines, exceptions that don't suck...
07:10:51 <rostayob> MostAwesomeDude: mah those are just definitions, in the end PHP and python are similar in the same way that Haskell and ML are similar and Java and C# is similar
07:11:02 <rostayob> *are similar
07:11:07 <cheater> how can i uninstall with cabal? i see no command that does it
07:11:09 <mm_freak> MostAwesomeDude: as said, a much better PHP =)
07:11:10 <MostAwesomeDude> rostayob: Yes, but those other two comparisons aren't highly insulting. :3
07:11:20 <mm_freak> it's still a scripting language, and i wouldn't write applications in it
07:11:21 <Saizan> shall we move the PHP vs. Python discussion on #php or #python ?
07:11:29 <mm_freak> uh
07:11:39 <parcs`> cheater: you can't, but you can 'unregister' a package with ghc-pkg unregister
07:11:44 <mm_freak> but yeah, i get your point…  let's stop it =)
07:11:50 <MostAwesomeDude> Agreed.
07:11:51 <cheater> that sucks very badly
07:11:54 <MostAwesomeDude> It's bagel time anyway.
07:12:13 <mm_freak> cheater: effectively no, but you can unregister packages
07:12:19 <mm_freak> cheater: ghc-pkg unregister --help
07:12:35 <cheater> yeah i just did that
07:12:37 <cheater> ok thanks.
07:12:53 <erus`> you can add to the global scope from within a function body. Which language am I?
07:13:08 <mm_freak> cheater: afterwards you can safely delete the files of the package…  usually they all live in ~/.cabal
07:13:21 <mm_freak> erus`: most languages
07:13:45 <mm_freak> erus`: restate the question:  "you can add to the globel scope without annotation from within a function body"
07:13:48 <mm_freak> then you are javascript
07:14:08 <erus`> how do i do the same in C C++ or java?
07:14:16 <mm_freak> you don't
07:14:21 <mm_freak> but there are many languages where you can
07:14:37 <mm_freak> python, PHP, TCL, perl, …
07:17:06 <singpolyma> Is there a common variant of Control.Exception.finally that does not re-throw the exception?
07:17:38 <cheater> i think it's called "catch".
07:17:41 <mm_freak> catch (x `finally` y) (const (return ())
07:18:20 <Saizan> cheater: x `finally` y runs y even when x doesn't throw exceptions
07:18:22 <mm_freak> but think harder, before you do that
07:18:51 <mm_freak> that code has unexpected side effects like the inability to killThread a thread using it
07:19:21 <singpolyma> mm_freak: ok, I could do that, but then I could just use try.  the problem is it wants a type signature the moment I use catch or try, whereas finally nicely does that for me
07:19:48 <Saizan> singpolyma: use SomeException if you want it to work for all of them
07:20:12 <mm_freak> singpolyma: that's actually a good thing…  you should only ignore certain expectable exceptions
07:20:15 <singpolyma> Saizan: yeah, ok, I guess I'll define a helper function for that, then
07:20:20 <mm_freak> ignoring SomeException is a very bad idea
07:20:48 <mm_freak> in any case, you can enable ScopedTypeVariables and do:  catch (…) (\(_ :: MyExceptionType) -> return ())
07:21:11 <mm_freak> or use catchJust
07:21:49 <Saizan> or (\(SomeException _) -> ..)
07:21:50 <donri> how do i include {- style comments inside {- style comments for haddock?
07:22:03 <Saizan> or any other constructor
07:22:12 <donri> such that haddock sees them*
07:22:17 <donri> for > code blocks
07:24:51 <ezyang> Argh. Anyone have bits on Hackage trac online right now?
07:25:00 <gwern> > 36.50 / 2
07:25:01 <lambdabot>   18.25
07:25:35 <solinent> Is there a library function which will swap window focus?  I hate pressing mod-e and mod-w alternatively.
07:26:56 <gwern> is someone handling the hackage spam?
07:26:58 <gwern> this is nuts
07:27:46 <aristid> gwern: what do you refer to?
07:27:56 <gwern> aristid: I just got like 40 spam emails from hackage
07:28:05 <gwern> something going through every open bug looks like
07:28:41 <gwern> 60
07:28:55 <aristid> gwern: are you a maintainer on a lot of packages?
07:28:59 <gwern> no
07:29:09 <gwern> looks like it's all going to cabal-devel
07:29:15 <gwern> besides hackage
07:29:30 <gwern> another 20
07:29:40 <aristid> anybody else affected?
07:29:55 <gwern> another 40
07:30:45 <gwern> (another 40)
07:31:34 <gwern> final 40
07:31:48 <ezyang> "oh trust me, there's a lot more than 40"
07:32:00 <aristid> > 60+20+40+40+40
07:32:01 <lambdabot>   200
07:32:07 <ezyang> Man, I swear I thought I had a login for abbot.
07:32:09 <aristid> gwern: you got 200 spam mails now?
07:32:13 <gwern> yeah.
07:32:22 <aristid> gwern: do you run your own mail server?
07:32:37 <gwern> aristid: no, this was for the sin of subscribing to cabal-devel, apparently
07:32:50 <aristid> oh, cabal-devel is a mailing list?
07:33:12 <gwern> what did you think I meant when I mentioned it?
07:33:33 <aristid> i thought it was the next generation website for hackage or something like that :D
07:37:02 <aristid> gwern: are the numbered mails here what you're referring to? http://www.haskell.org/pipermail/cabal-devel/2012-January/thread.html
07:37:13 <gwern> aristid: yes
07:39:06 <aristid> gwern: it seems like every single change on the bug tracker is sent to the list
07:43:02 <dmwit> solinent: yes, there's an implementation of an alt+tab alike
07:43:34 * hackagebot IntervalMap 0.2.2 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.2 (ChristophBreitkopf)
07:44:07 <cheater> dmwit: for what?
07:44:15 <dmwit> solinent: Oh, wait, are you talking about xmonad?
07:44:21 <dmwit> I thought I was in #xmonad.
07:46:30 <jamil_1> hi all
07:46:30 <jamil_1> haskell noob here
07:46:37 <jkff> hi
07:46:59 <dmwit> solinent: Anyway, if you meant for xmonad, then http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-CycleWindows.html may be relevant, and you should /join #xmonad.
07:47:22 <jamil_1> I have read how IO is handled and partially understand how/why it works
07:47:45 <jamil_1> My question how does wrapping everything in IO makes function pure
07:48:07 <jkff> do you mean, how can a function returning something of type IO ... be pure?
07:48:21 <jkff> i.e. be **called** pure
07:48:35 <jamil_1> jkff: yep
07:48:37 <int-e> because it has no (side) effect
07:48:51 <jkff> actually the only thing that matters is referential transparency
07:49:19 <Igloo> jamil_1: It is /executing/ the (IO t) that is impure
07:49:25 <jkff> When you calculate or even execute a value of type "IO ...", you do not violate referential transparency.
07:49:37 <jamil_1> and isn't wraping in IO is equivalent to wrapping the samething in List
07:49:40 <jkff> i.e. the presence of values with this type does not introduce a way to violate referential transparency in Haskell.
07:49:43 <int-e> and we cheat by saying that execution of IO actions is done outside of the Haskell language. :)
07:49:55 <dmwit> No, IO /= []
07:49:59 <jamil_1> My understanding is that IO of somthing is like a frozen computation
07:50:35 <jkff> jamil_1: In a sense, it is. But I'm not sure it's a good idea to employ analogies at this point.
07:51:01 <jkff> jamil_1: equivalent in what sense?
07:51:08 <merijn> jamil_1: An "IO a" is a sequence of computations that returns an "a"
07:51:12 <jamil_1> dmwit: I meant any *->* kind should do here. no ?
07:51:33 <jkff> jamil_1: "IO a" is not a sequence of computations, it's just a computation, even though one way to form it might be indeed to sequence some other computations.
07:51:40 <jkff> I meant merijn: ...
07:52:04 <merijn> jkff: Eh, yeah
07:52:08 <int-e> hmm 'computation'. should we say 'action' here?
07:52:09 <jamil_1> jkff: equivalent in the sense that both List and IO represent non-deterministic computation
07:52:12 <jkff> I mean, it's a "sequence of computations" no more than in the sense that "1 + 2 + 3" is a sequence of computations.
07:52:21 <merijn> int-e: action is just a different word for the same thing
07:52:40 <jkff> jamil_1: No. List represents a list. IO represents a value whose evaluation may produce a side effect.
07:53:40 <merijn> jamil_1: What is meant by non-deterministic in the List monad is very different from non-deterministic in IO
07:53:49 <mm_freak> jkff: its evaluation does not have side effects
07:53:53 <jkff> jamil_1: The main, and only, characteristic of IO is that you MUST impose an order on the execution of IO actions. This is achieved by hiding the constructor f the IO type.
07:54:00 <jkff> mm_freak: ok, execution.
07:54:03 <int-e> IO a is an IO action that when executed will produce a value of type a (that can be consumed by a function producing further IO actions -- that's what bind will do)
07:54:20 <jamil_1> merijn: how so ?
07:54:53 <mm_freak> jkff: you are assuming a certain intuition behind IO
07:54:56 <mm_freak> but there are many
07:55:04 <dmwit> "any *->* kind should do here, no?" <- I'm not sure what is being asked here
07:55:12 <merijn> jamil_1: You use the list monad to model non-deterministic computations, however the list monad is *not* and cannot be non-deterministic
07:55:19 <jkff> mm_freak: yes, you're right.
07:55:25 <mm_freak> a popular one is:  data IO :: * -> * where GetLine :: IO String; PutStrLn :: String -> IO (); …
07:55:35 <merijn> jamil_1: i.e. executing something in the List monad always returns the same thing. IO can produce different results
07:56:09 <jamil_1> merijn: right
07:56:20 <jkff> The "nondeterministic nature" of IO only manifests itself in the fact that you don't know whether an IO action is deterministic or not, because you essentially can't execute it twice.
07:56:41 <mm_freak> you can't execute it even once…  execution is outside the scope of haskell
07:56:43 <jamil_1> brb
07:57:54 <jkff> mm_freak: strictly speaking you're right, but are you sure it's beneficial to speak that strictly here?
07:58:09 <parcs`> jamil_1: what languages are you familiar with?
07:58:18 <merijn> jkff: Yes, otherwise you get confused
07:58:20 <mm_freak> yes, i am, because i explain IO as a type for recipes
07:58:41 <merijn> jkff: (Or rather, the person you explain it to gets confused)
07:58:42 <int-e> I agree with mm_freak there.
07:58:44 <mm_freak> in the haskell language you only /write/ the recipes
07:59:07 <merijn> jkff: If you can't execute an IO action twice, then what does "forever $ print "Hello!"" do?
07:59:08 <mm_freak> you can't even read them, let alone execute them
07:59:09 <jkff> OK, I feel like I'm incapable of giving a non-confusing explanation right now.
07:59:36 <jkff> merijn: I mean, execute twice with identical "context" - the "world" in which you execute it the first time will never be the same.
07:59:46 <parcs`> except for, like, unsafePerformIO :P
07:59:54 <jamil_1> parcs`: java and scala
07:59:58 <merijn> jkff: True, but it makes more sense to say "you can't execute anything at all"
08:00:09 <int-e> Because that's how you can reconcile the paradox that a pure language (which implies not having any effects) can nevertheless be useful: Because evaluation of that pure language is separate from the execution of the resulting IO program (to avoid 'action').
08:00:18 <merijn> jkff: You just combine actions into bigger actions which the runtime will eventuall execute for you
08:00:56 <jkff> merijn: true. I don't know how to formulate my point in this setting.
08:01:03 <jamil_1> parcs`: I started learning scala, there were many concepts tossed around that were borrowed from haskell so I decided to Learn from the source :)
08:01:26 <mm_freak> jkff: perhaps your point assumes a certain context, which may not be given
08:01:43 <parcs`> jamil_1: ah, cool :)
08:01:56 <mm_freak> you are building on the assumption that IO is modeled as a giant state monad
08:02:02 <merijn> jamil_1: Which books/site are you learning from, btw?
08:02:20 <jkff> jamil_1: I strongly advise you to try learning the non-trivial monads first - such as parsers, statistical distributions and the continuation monad, which actually give you some intuition on the structure and usage of a monad. IO is so trivial that it obscures the point of monads.
08:02:41 <cheater> is there something in haskell which lets me split a string on commas
08:02:58 <jkff> cheater: see Data.List.Split, there's a package on hackage
08:02:58 <merijn> jkff: Heh, I disagree IO makes perfect sense once you grok Maybe/List/Either
08:02:59 <cheater> "foo,bar,baz" -> ["foo", "bar", "baz"]
08:03:05 <merijn> :t splitAt
08:03:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:03:13 <cheater> @hoogle splitAt
08:03:13 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
08:03:14 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
08:03:14 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
08:03:25 <merijn> @hoogle a -> [a] -> [[a]]
08:03:26 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:03:26 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:03:26 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:03:29 <yitz> @hackage split
08:03:29 <lambdabot> http://hackage.haskell.org/package/split
08:03:37 <mm_freak> cheater: in the base library there is nothing for String, but for ByteString and Text
08:03:47 <cheater> no idea what i'm using
08:03:48 <mm_freak> (in the respective libraries)
08:03:51 <jkff> merijn: I don't like any of these three too :) I feel like they are too trivial as well, and provoke too trivial intuitions about the nature of monads.
08:03:59 <cheater> but it's just a general list based thing isn't it
08:04:05 <merijn> jkff: Monads *are* trivial
08:04:10 <jkff> merijn: I found that people understand monads really quick if you start explaining from the nontrivial monads - Parsers, Asynchronous computations etc.
08:04:28 <mm_freak> there is only one trivial monad:  Identity
08:04:32 <merijn> Once I understood how trivial, it became easy for me
08:04:50 <mm_freak> you are confusing "trivial" with "simple"
08:04:53 <int-e> Isn't it better to start simple? Maybe, List, Reader, State, then some Parser. Point out the differences, and the common core.
08:05:02 <jamil_1> merijn: from G. Hutton's Book, Erik Meijr's Videos on Channel 9 and Phil Wadlers Video Lectures
08:05:24 <merijn> mm_freak: No, I'm just using trivial in the colloquial sense rather than the formal mathematical sense
08:05:34 <merijn> jamil_1: I recommend "Learn You a Haskell"
08:05:37 <mm_freak> merijn: and you shouldn't do that
08:05:55 <mm_freak> there can be a large gap between "simple" and "trivial"
08:06:23 <mm_freak> ContT is in a sense "trivial", but in no way "simple"
08:06:24 <jkff> merijn: I found that the async monad is best for explaining, because with it all monadic operations (fmap, >>=, replicateM, filterM etc.) make some kind of sense and have realistic examples of usage
08:06:34 <mm_freak> it's "trivial", because it "follows"
08:07:22 <mm_freak> and please, guys, there is no "best way to explain monads"
08:07:26 <jkff> merijn: therefore, it doesn't make people ask "why all this stuff just to have computations with multiple results? we could use loops!" and instead provokes them to see how these combinators are generalizations of imperative constructs such as loops and conditionals
08:07:35 <mm_freak> just because /you/ found them easy to understand in a particular way
08:07:37 <jkff> mm_freak: I'm implicitly adding "in my experience"
08:07:45 <jkff> mm_freak: "in my experience of *explaining*"
08:08:21 <solinent> dmwit: I meant to join xmonad, I've been logging in and out and don't usually use irc.  Thanks!
08:08:36 <mm_freak> jkff: and yet you explain IO as a state monad…  i've explained IO to many people without explaining IO itself…  i explained how to use it, and they understood
08:09:03 <int-e> Does lambdabot know this link? https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:09:12 <jkff> mm_freak: I don't know the best way to explain the IO monad :) I'm just advertising a way of explaining monads as an algebraic structure.
08:09:32 <mm_freak> jkff: read the link int-e just posted =)
08:09:39 <solinent> dmwit: Actually, that wasn't what I was looking for, but I'll ask in the proper channel
08:09:44 <jkff> mm_freak: when talking about IO as State, I was refering to GHC's implementation and meant "that's the way it's actually implemented".
08:09:51 <Saizan> i think it's pretty important to explain what a value of type IO A is, the (State World a) is just not the right answer though
08:10:13 <int-e> it's a banana
08:10:14 <jkff> mm_freak: I read it :) I agree that vague intuition is a bad thing
08:10:18 <markus3> hi! I think the Hackage mailinglist just got hit with lots of spam
08:10:25 <int-e> you can peel it and out comes the flavor. wait, that's not like IO at all :)
08:10:31 <roconnor> Saizan++
08:11:06 <cheater> i might be asking something basic, but how the hell do i get a specific index out of a tuple?
08:11:15 <yitz> int-e: apfelmus will like your metaphor
08:11:17 <dolio> Yeah, State World just doesn't make any sense.
08:11:26 <cheater> (1, 2, 3) `foo` 2 -> 3
08:11:26 <parcs`> cheater: pattern matching
08:11:27 <dolio> Even if you appeal to the fact that Clean uses it directly.
08:11:28 <mm_freak> jkff: try to find an explanation of IO that gets along without any hypothetical way you could define it
08:11:28 <Saizan> cheater: pattern match
08:11:33 <cheater> only?
08:11:36 <cheater> ok.
08:11:37 <parcs`> yep
08:11:51 <roconnor> cheater: use fst and snd
08:11:53 <mm_freak> State World does make sense, but i argue it doesn't help at explaining
08:12:09 <dolio> No.
08:12:23 <jkff> cheater: yes, only - because otherwise the return type of foo would depend on the *value* of its second argument, and haskell doesn't support that.
08:12:26 <cheater> roconnor: does not work with a longer tuple.
08:12:28 <roconnor> Actually State World doesn't make sense, but the reason it doesn't is kinda technical
08:12:33 <Saizan> btw, the better explanation we have currently is that IO a is an imperative program, you can use the free monad to make that more complete
08:12:37 <mm_freak> (and yes, IMO State World does capture concurrency)
08:12:45 <dolio> State World doesn't make sense. There are specific cases where it's wrong.
08:12:48 <cheater> jkff: would this be solved by dependant types?
08:12:53 <Saizan> *concrete
08:12:53 <jkff> cheater: yes
08:12:57 <cheater> jkff: cool.
08:13:09 <mm_freak> dolio: those specific technical cases involve 'seq'
08:13:09 <dolio> Like, try to explain why 'forever (putStrLn "hello")' does something differe than '\s -> _|_'.
08:13:18 <roconnor> cheater: define sevenOfNine (_,_,_,_,_,_,x,_,_) = x
08:13:19 <mm_freak> and if you let 'seq' into the game, you can prove most monads wrong
08:13:25 <roconnor> cheater: :)
08:13:29 <dolio> Those two expressions denote the same thing.
08:13:42 <mm_freak> dolio: yes, and that's correct
08:13:46 <jkff> Oh well, gotta go - have a nice monad talk everyone :)
08:13:46 <dolio> But they do different things.
08:14:10 <roconnor> mm_freak: the specifical tenchical cases involve non-terminating, but productive, programs.
08:14:19 <int-e> the State World view fails miserably when it comes to concurrency
08:14:31 <mm_freak> int-e: i don't see how
08:14:39 <markus3> ok, so I'm repeating myself, but: the Hackage mailinglist just got hit with lots of spam! If anyone knows ho to contact about this, then please do!
08:14:43 <int-e> you can't have any interaction between threads in that model
08:14:48 <jkff> cheater: however, you can do some trickery with type-level numerals, type classes or type families, and make code like "(1,2,3) `foo` N2" compile and do what you want.
08:14:54 <parcs`> how would dependent types help with getting an arbitrary index out of an arbitrary tuple?
08:15:05 <mm_freak> int-e: the concurrent program becomes part of the world state, so that the next action will know it's there and can let it run
08:15:07 <dmwit> int-e: The state of the world includes the states of all the threads...
08:15:14 <mm_freak> particularly actions like takeMVar can wait for other threads
08:15:23 <mm_freak> so State World does capture concurrency
08:15:29 <parcs`> what would be the type of said function in eg agda?
08:15:32 <Saizan> parcs`: it'd help only if you tuples became a family of datatypes or something like that
08:16:02 <jkff> parcs`: You would write a function whose type would be something like: foo :: (a,b,c) -> (i:int | 0<i<4) -> case i of {1 -> a; 2 -> b; 3 -> c}
08:16:17 <mm_freak> in any case, i agree that State World is a bad idea
08:16:19 <parcs`> jkff: that's only for a three-tuple
08:16:30 <mm_freak> and personally i'd just let IO be the opaque thing it is anyway
08:16:31 <int-e> dmwit: I guess you can include the whole future of the program in that state, too. I don't like the philosophical implications of that though.
08:16:50 <dmwit> int-e: I don't see that you need to include the future of the program in the state.
08:17:21 <jkff> parcs`: just add a typeclass and you support arbitrary (though bounded) arity. To support unbounded arity, you have to either use (a,(b,c))-tuples, or have some kind of formalism for arbitrary-arity tuples in the language.
08:17:33 <jkff> that's it, I'm leaving. Bye everyone.
08:17:38 <dmwit> parcs`: Triples (a, b, c) are really just tuples (a, (b, (c, ()))) anyway... ;-)
08:17:41 <Saizan> mm_freak: (\ _ -> undefined) and forever (putStrLn "foo") are the same if you compare them as State World values, yet they are different programs, that's why it doesn't work as a model, and there's no involvement of seq here
08:17:53 <parcs`> dmwit: they should be :P
08:17:55 <roconnor> dolio: Someone needs to recall the proof that State World doesn't distingish between (forever (printStrLn "Hello")) and (return ()) and put it in a blog post.
08:18:11 <int-e> dmwit: The result of State a b is completely determined by the initial value of the state, thanks to purity.
08:18:20 <dolio> It isn't hard to write. I don't have a blog, though.
08:18:32 <dmwit> int-e: Yes, so?
08:18:34 * hackagebot wxdirect 0.13.1 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.13.1 (JeremyODonoghue)
08:18:36 * hackagebot wxcore 0.13.2 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.13.2 (JeremyODonoghue)
08:18:41 <dolio> Well, it isn't 'return ()'.
08:18:50 <dmwit> int-e: Different runs of the program don't start in the same world.
08:18:54 <roconnor> dolio: if you post it to hpaste I can put it on my blog and credit you if you like
08:18:58 <mm_freak> Saizan: true, but is that really incorrect?  you are never asking for the final state of the world, because it is never reached
08:19:12 <mm_freak> Saizan: in other words, even though they denote the same thing, they modify the state of the world
08:19:17 <mm_freak> so it's a philosophical question
08:19:24 <roconnor> dolio: oh right, s/(return ())/undefined
08:19:27 <mm_freak> int-e: think about how cooperative concurrency works
08:19:35 <roconnor> dolio: or any other non-terminating program
08:19:42 <parcs`> you don't need dependent types to define an index function on lisp-list-like tuples
08:19:52 <int-e> dmwit: yes, but to run two concurrent threads in the same program, you will at some point have to split the world token, and after that point, they will each run on their own world -- so any interaction between them must be pre-determined.
08:20:09 <dmwit> parcs`: You do if you want to use computed indices.
08:20:18 <mm_freak> int-e: takeMVar is responsible for running the other thread in this model
08:20:20 <roconnor> mm_freak: a -> (a,b) is a certain kind of CPO.
08:20:29 <Saizan> mm_freak: then i've proved those two programs equivalent, so i should be able to switch one for the other in my program and get the same results! but they don't
08:20:29 <dmwit> (that is, *value*-level computed indices -- say, given by user input)
08:20:31 <mm_freak> int-e: when takeMVar finishes, the other thread is suspended
08:20:36 <int-e> mm_freak: then IO a is no longer State World a, but some different monad.
08:21:00 <int-e> (probably some derivative of Cont)
08:21:21 <dmwit> int-e: I disagree with the assertion "to run two concurrent threads in the same program, you will at some point have to split the world token".
08:21:57 <mm_freak> Saizan: you do get the same result…  they still both denote a program that never ends, but this is really a philosophical discussion, and philosophically one program modifies the world state…  you just can't observe it
08:21:58 <dmwit> (We've had single-core multitasking for, what, twenty years? Thirty?)
08:22:07 <mm_freak> int-e: why?
08:22:27 <Saizan> mm_freak: no, i run the program and get different stuff printed to stdout, that's what it makes it not philosophical.
08:22:31 <mm_freak> int-e: if takeMVar includes an entire run-time system, you can very well model this as State World
08:22:51 <mm_freak> Saizan: i understand your point
08:22:56 <roconnor> mm_freak: I think I can observe the difference bewteen main = undefined and main = forever (printStrLn "Hello")
08:23:13 <mm_freak> roconnor: those two are different anyway
08:23:27 <mokus> undefined :: IO a doesn't denote a program that never ends, it denotes a program that fails to be well-defined
08:23:37 <mokus> it can't even start
08:23:39 <mm_freak> roconnor: the point is that forever (return ()) and forever (putStrLn "blah") denote the same thing, yet behave differently
08:23:42 <mokus> let alone not end
08:23:53 <mm_freak> but then 'undefined' and 'x = x' denote the same thing and still act differently
08:23:57 <dmwit> ?let undefined = forever (return ())
08:23:58 <lambdabot>  Defined.
08:24:01 <dmwit> there, that settles that
08:24:43 <int-e> mm_freak: Still IO a won't be State World a  when you do that. You will have a run time system running in a state monad (which then is a single thread of execution) running IO actions which are something different.
08:24:55 <mm_freak> in actual haskell you observe different behavior when replacing "undefined" by an infinite loop
08:25:01 <mm_freak> even though they denote the same thing
08:25:17 <quicksilver> mm_freak: what makes you think that "forever (return ())" and "forever (putStrLn "blah")" denote the same thing?
08:25:18 <int-e> anyway. all this discussion can be avoided by treating IO a as a black box.
08:25:34 <mm_freak> int-e: you can model concurrency as a single thread of execution
08:25:37 <quicksilver> they denote entirely different things.
08:25:46 <JoeyA> Looks like http://hackage.haskell.org/trac/hackage/ got ddosed by spammers.  Is my assessment correct?
08:25:58 <mm_freak> quicksilver: we are talking about the "IO = State World" intuition
08:26:02 <quicksilver> note that we have no formal denotation for IO but you could consider it a free construction over IO primitives.
08:26:14 <quicksilver> mm_freak: Oh, that's a horrible thing in oh so many ways.
08:26:18 <quicksilver> mm_freak: not just this one :) but fine.
08:26:34 <yitz> just got word that there will be a leap second on June 30.
08:27:01 <mm_freak> just for the record, i don't like the State World intuition =)
08:27:11 <mm_freak> but i don't go as far as to say it's totally wrong
08:27:18 <mm_freak> whether it's wrong is a philosophical question
08:27:25 <int-e> mm_freak: I guess I just completely disagree with that view philosophically because it precludes any element of chance.
08:27:37 <quicksilver> it's not philosphic
08:27:46 <mm_freak> int-e: that's a much better point
08:27:48 <quicksilver> it's aboslutely a black and white matter of theoretical computer science
08:27:58 <quicksilver> State World is absolutely *wrong* as a model for IO
08:28:08 <quicksilver> no philosophy and no opinion involved.
08:28:08 <JoeyA> @hoogle acme-realworld
08:28:08 <lambdabot> No results found
08:28:13 <JoeyA> @hackage acme-realworld
08:28:13 <lambdabot> http://hackage.haskell.org/package/acme-realworld
08:28:31 <quicksilver> it's an intuition at most
08:28:34 <mm_freak> let's leave IO as the black box it is…  that's the best intuition anyway =)
08:28:36 <quicksilver> it's not even a *good* intuition :P
08:28:37 * hackagebot wx 0.13.2 - wxHaskell  http://hackage.haskell.org/package/wx-0.13.2 (JeremyODonoghue)
08:29:50 <dolio> roconnor: http://hpaste.org/56119
08:30:40 <srhb> Perhaps one day, someone will come up with the ultimate monad explanation, and all will be glorious henceforth.
08:30:57 <dolio> Line 16 should probably be "... _|_ = (\s -> _|_) x <= ..." instead of that = being <=.
08:30:59 <quicksilver> monad explanations are a different species of fish to models for IO.
08:31:02 <mm_freak> i think this is not even about monads
08:31:04 <mm_freak> this is about IO
08:32:11 * mokus prefers to say "IO a" is a first-class "procedure with return type a" and leave it at that
08:32:28 <mokus> where "procedure" is to be interpreted in exactly the same sense as in C
08:32:52 <Saizan> mokus: that's one that works well
08:33:30 <Saizan> at least it's equational theory is conservative wrt the observational equality
08:33:38 * hackagebot data-lens-ixset 0.1.0 - A Lens for IxSet  http://hackage.haskell.org/package/data-lens-ixset-0.1.0 (DagOdenhall)
08:34:29 <mokus> if I really wanted to go deeper, i'd say IO is the algebraic theory of foreign imports
08:34:54 <mokus> which is basically the GADT view mm_freak mentioned
08:35:40 <dolio> There's some concurrency stuff thrown in there, too.
08:35:43 <dolio> And probably other stuff.
08:35:58 <dolio> Because, where else would you put it?
08:36:24 <mokus> concurrency just means some of the constructors in the algebra have the whole algebra as the type of a parameter
08:36:56 <mokus> it's a purely syntactic construction, it doesn't attempt to give meaning to execution
08:37:23 <mokus> meaning is given by a model of the theory
08:37:29 <mokus> which i decline to offer ;)
08:37:36 <nitencasi> how can i read a multiple line number from a file?
08:38:31 <osfameron> what's a multiple line number?
08:38:50 <Saizan> a number with a bunch of \n in the middle
08:39:07 <nitencasi> yes
08:39:24 <dolio> mokus: I know. There are papers on concurrency monads that are perfectly ordinary.
08:39:27 <Saizan> nitencasi: read the lines, concat them and then use read
08:39:34 <dolio> You just have to include stuff for it.
08:39:42 <Saizan> ?type concat
08:39:43 <lambdabot> forall a. [[a]] -> [a]
08:39:45 <dolio> Unless you consider those to be foreign imports as well.
08:40:43 <mokus> dolio: i would consider all "IO primitives" to fall under "foreign imports" in this case, or if I were being more careful with my description i'd include them from the start
08:40:54 <dolio> Okay.
08:41:28 <dolio> I agree that "algebraic theory of a whole bunch of crap" is about the best anyone's done.
08:41:33 <dolio> Maybe the best you can possibly do.
08:41:45 <mokus> the nice thing about it is it's a universal description that's still specific enough to make sense
08:41:56 <mokus> any other model of IO can be easily factored through it
08:42:03 <dolio> Right.
08:43:14 <mokus> another nice thing about it is that the 'algebraic theory' construction has been implemented in Haskell, so if someone asks "what the hell is that" you can point them to some fun toys on hackage to illustrate
08:43:39 <mokus> specifically, monadprompt / operational
08:43:41 <nitencasi> Saizan, it's already one string
08:43:59 <nitencasi> it "28374837\n7374832948\n3847382"
08:45:54 <dolio> Also it's the obvious story from category theory, where the primary use of monads is for describing algebraic theories.
08:45:59 <mokus> yea
08:46:00 <dolio> If I'm not mistaken.
08:46:04 <Saizan> nitencasi: use unlines then
08:46:14 <mokus> yep, IIRC lawvere's phd thesis was basically about that
08:46:18 <Saizan> > unlines "28374837\n7374832948\n3847382"
08:46:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:46:19 <lambdabot>         against inferred ty...
08:46:24 <nitencasi> Saizan, i am using words
08:46:32 <quicksilver> Saizan: lines? :)
08:46:35 <Saizan> > unlines . lines $ "28374837\n7374832948\n3847382"
08:46:36 <lambdabot>   "28374837\n7374832948\n3847382\n"
08:46:43 <Saizan> what am i doing?
08:46:50 <Saizan> > concat . lines $ "28374837\n7374832948\n3847382"
08:46:51 <lambdabot>   "2837483773748329483847382"
08:46:53 <dolio> Well, he's got his Lawvere theories. I never read enough of the thesis to know if he bothered with monads.
08:47:15 <dolio> Lawvere theories being a little nicer to work with, but missing some cases.
08:47:46 <Saizan> nitencasi: so to recap, (concat . lines) should work
08:47:52 <mokus> yea, i haven't read the thesis itself, i'm just recalling things i've read about it ;)
08:48:05 <mokus> i've been meaning to... got it on my laptop ready to go, just haven't yet
08:48:06 <Saizan> nitencasi: (concat . words) also, i think
08:48:23 <dolio> Like, you can combine Lawvere theories easily, I think.
08:48:33 <dolio> Instead of ad-hoc nonsense like monad transformers.
08:48:51 <dolio> But, I don't think there's a Lawvere theory equivalent of Cont.
08:49:12 <mokus> probably not, they're single sorted finitary algebraic theories i think
08:49:20 <dolio> Yeah.
08:49:30 <nitencasi> saiam, read(concat(words(handle)))::Integer
08:49:33 <mokus> but the correspondence to monads is much easier to see in the less general setting
08:49:41 <nitencasi> Saizan, ^
08:50:10 <mokus> Paul Taylor's Practical Foundations for Mathematics has a pretty good development of them as an intro to internal logics in general
08:50:23 <yitz> > concat . words $ "28374837\n7374832948\n3847382"
08:50:24 <lambdabot>   "2837483773748329483847382"
08:50:26 <plat0> You might find this interesting regarding Lawvere theories and monads: http://lambda-the-ultimate.org/node/3235
08:50:40 <Saizan> nitencasi: yeah, if handle is the String
08:50:40 <cheater> is there some simple way to define data for a haskell program in a file?
08:50:50 <nitencasi> Saizan, yes
08:50:53 <nitencasi> it is
08:50:54 <nitencasi> :)
08:50:56 <cheater> in python i can just write out a dictionary in a txt file and load that with eval
08:51:05 <cheater> what's the shortest way in haskell?
08:51:10 <yitz> > read . concat . words $ "28374837\n7374832948\n3847382" :: Integer
08:51:12 <lambdabot>   2837483773748329483847382
08:51:28 <dolio> There's also generalized Lawvere theories, which cover all monads, I think, but lose the nice properties (of course).
08:51:30 <mokus> plat0: there's also an interesting (but dense) bit about them on ncatlab
08:51:30 <Saizan> ?type read -- cheater
08:51:31 <lambdabot> forall a. (Read a) => String -> a
08:52:00 <mokus> at http://ncatlab.org/nlab/show/algebraic+theory
08:52:05 <cheater> > read " [(1, 'a')]"
08:52:06 <lambdabot>   *Exception: Prelude.read: no parse
08:52:13 <cheater> > read "[(1, 'a')]"
08:52:13 <yitz> cheater: write it as a list of tuples and then use Data.Map.fromList . read
08:52:14 <lambdabot>   *Exception: Prelude.read: no parse
08:52:18 <cheater> doesn't quite work
08:52:28 <geekosaur> you need t specify a type
08:52:32 <cheater> oh
08:52:40 <geekosaur> read determines how to parse by the requested return type
08:52:49 <cheater> > read "[(1, 'a')]" :: [(Int, Char)]
08:52:50 <lambdabot>   [(1,'a')]
08:52:58 <cheater> nice.
08:53:10 <yitz> > M.fromList . read $ "[(1,\"a\")] :: M.Map Int String
08:53:11 <lambdabot>   <no location info>:
08:53:11 <lambdabot>      lexical error in string/character literal at end o...
08:53:18 <yitz> > M.fromList . read $ "[(1,\"a\")]" :: M.Map Int String
08:53:19 <lambdabot>   fromList [(1,"a")]
08:53:29 <nitencasi> how can i use sum in a Integer ?
08:53:40 <cheater> fromInteger
08:53:57 <cheater> you know, i really do wish haskell had type juggling
08:54:00 <mokus> plat0: i hadn't seen that one, i'll have to add it to my to-read list :)
08:54:12 <rostayob> cheater: type juggling?
08:54:25 <rostayob> you mean type coercion? that's bad
08:54:39 <yitz> "duck typing"?
08:54:46 <cheater> the dynamic type conversion which happens when you do "2" + 3 in php.
08:54:55 <rostayob> you wish haskell had that.
08:55:00 <cheater> yes.
08:55:00 <mokus> it's hilarious how flame wars on #haskell tend to degenerate into category theory ;)
08:55:07 <JoeyA> It does
08:55:10 <JoeyA> @hackage regex-base
08:55:11 <lambdabot> http://hackage.haskell.org/package/regex-base
08:55:18 <cheater> wat
08:55:21 <rostayob> cheater:  you can overload functions in haskell
08:55:31 <cheater> rostayob: that's not type juggling
08:55:33 <JoeyA> regex-base overloads like crazy
08:55:39 <rostayob> your problem is that "3" is always a String and not something else
08:55:45 <rostayob> cheater: type juggling like that is horrible
08:55:51 <JoeyA> class RegexOptions regex compOpt execOpt | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt where
08:55:54 <cheater> it's like i say i want a car and you say "you can have this scooter"
08:56:16 <plat0> mokus: Have you seen Andrej Bauer's eff language?  He's trying to model side effects as algebraic theories.
08:56:20 <rostayob> haskell has type classes to do that safely
08:56:35 <rostayob> type coercion hard coded in the language is an ugly hack
08:56:49 <mokus> plat0: no, i haven't - i've been bogged down in agda as my side-language lately but i'll take a look
08:57:05 <mokus> plat0: in what way does that differ, practically speaking, from using monads?
08:57:07 <yitz> cheater: it's also like you say i want to step across these tracks and the language says "here's this freight train".
08:57:30 <mokus> plat0: creating ad-hoc ones by assembling theories of the operations you actually use?
08:58:10 <Saizan> mokus: and direct style syntax
08:58:31 <cheater> yitz: what
08:58:32 <geekosaur> from what I recall or andrej while at CMU, it probably is *based* in monads/category theory
08:58:44 <geekosaur> *of andrej
08:58:45 <plat0> mokus: you can check it out here: http://math.andrej.com/2010/09/27/programming-with-effects-i-theory/#more-560
08:59:13 <yitz> cheater: what i mean is that you will almost certainly get into trouble with that kind of coercion
08:59:21 <cheater> will i
08:59:24 <plat0> It's basically getting to grips with the algebraic theories directly, rather than abstracting them in a monad.
08:59:25 <cheater> thanks for changing my diaper
08:59:31 <mokus> sounds like a promising direction to go
09:00:01 <plat0> It looks very nice.  Andrej says it's "hard to type".  I think this means the mixing of effects is hard to type.
09:00:07 <plat0> So you don't get anything for free!
09:00:36 <mokus> i imagine you'd run into the usual problems with subtyping, magnified a bit by the fact that it occurs at a higher kind
09:00:54 <yitz> cheater: you can write expressions in haskell without specifying types. the type inference engine is smart if there's a unique way to make sense out of it that is guaranteed to be completely consistent, the compiler will do that for you. otherwise, it is definitely worth the trouble to convert it explicitly yourself.
09:01:04 <geekosaur> cheater, I'm pretty sure it's doable, but you're effectively "disabling" a goodly part of the type system by doing that and why bother staying in haskell in that case?
09:01:25 <monochrom> you can already write "instance IsString Int where ..." and turn on OverloadedStrings. that will give you "2" :: Int
09:01:54 <geekosaur> if you want to use a language which doesn't have strict typing, use one.
09:02:31 <monochrom> conceptually though, I don't understand why string enjoys this special privilege while other types don't
09:02:50 <yitz> monochrom: yes, and you can write "where fromString "666" = error "Your program just crashed"".
09:03:06 <rostayob> monochrom: because with OverloadedStrings you have to annotate much  more code
09:03:08 <rostayob> then with numbers
09:03:11 <Ke> I thought OverloadedStrings was a convenience for bytestring
09:03:27 <rostayob> Ke: OverloadedStrings types string literals as :: IsString a
09:03:32 <rostayob> much like number literals are Num a
09:03:41 <geekosaur> it is.  and there has been limited discussion of a more general utility, but I think it bogged down in implementation details
09:03:52 <yitz> monochrom: i wish string didn't enjoy that "privilege". we need a static way of overloading string literals, not at run time.
09:04:34 <yitz> OverloadedStrings are a way of disabling some of Haskell's static safety guarantees.
09:04:54 <rostayob> yitz: what? why?
09:04:57 <geekosaur> hm, right, come to think of it, that's where it bogged down, someone pointed out that was the real problem and then the hole thing got lost in "how do we do this sanely?"
09:05:00 <rostayob> OverloadedStrings is not unsafe
09:05:10 <yitz> rostayob: it is unsafe
09:05:11 <rostayob> not more unsafe than number literals anyways
09:05:27 <rostayob> yitz: why is it unsafe?
09:05:39 <yitz> rostayob: number literals are also unsafe in theory. in practice, it's less likely to be a problem very often.
09:05:47 <rostayob> yitz: what's the difference?
09:05:59 <rostayob> also i don't see the unsafety
09:06:49 <monochrom> I wish there were "class IsMaybe" and "OverloadedMaybes" so that I could write (lookup k xs <|> 3) and it expands to (lookup k xs <|> Just 3)
09:07:24 <yitz> rostayob: because the existence of OverloadedStrings encourages people to write libraries that cause your program to crash at runtime depending on what you write in your string literal. every other normal programming language checks that at compile time.
09:07:30 <shachaf> instance Num (Maybe Integer)
09:07:44 <rostayob> yitz: well but then Haskell is unsafe (see error)
09:07:50 <monochrom> ok, make it (lookup k xs <|> False)
09:08:00 <shachaf> OverloadedBool!
09:08:03 <rostayob> I don't see why polymorphic literals are more unsafe than plain haskell
09:08:26 <rostayob> of course you can write unsafe code but that's true for every haskell expression
09:08:41 <Ke> maybe id 3 (lookup k xs) =oP
09:08:59 <rostayob> (btw, I'm not in favour of OverloadedStrings by default)
09:09:06 <monochrom> anyway, "like PHP" is not a very good reason
09:09:13 <yitz> monochrom: i don't understand that. OverloadedStrings is for providing alternate interpretation of string literal syntax. which literal syntax are trying to re-interpret with OverloadedMaybe?
09:09:14 <rostayob> "unlike PHP" is
09:10:04 <yitz> rostayob: no the point is that OverloadedStrings causes the string literals to be compiled only at run time.
09:10:10 <monochrom> all other literal syntaxes
09:10:24 <Saizan> rostayob: well, aside from "unsafe", it's just that a literal looks like an innocent normal form, once overloaded it isn't
09:10:27 <rostayob> yitz: "compiled"? they're re-computed each time
09:10:37 <yitz> monochrom: your example was a numeric literal . those can already be overloaded.
09:10:47 <yitz> rostayob: it's a *literal*
09:10:55 <rostayob> yitz: i see what you mean, but what you are saying is true in general
09:11:06 <rostayob> you can litter your code with errors. that's it
09:11:10 <monochrom> I had a Bool example too. and a () example coming up. and a [(),()] example coming up...
09:11:16 <rostayob> it might be more surprising with literals
09:11:28 <rostayob> but it's not more unsafe
09:11:42 <monochrom> lookup k xs <|> [[], [False], [False, True]]
09:11:55 <yitz> rostayob: so why bother with type safety at all then? it's still possible for you program to fail at run time. just let every type error fail at run time
09:11:58 <rostayob> Saizan: i agree, and in fact i think that OverloadedStrings by default is a bad idea
09:12:06 <rostayob> yitz: no, that's different
09:12:13 <yitz> rostayob: it's not different at all
09:12:13 <rostayob> you're not introducing a new way to be type-unsafe
09:12:28 <rostayob> you're just introducing a way to implicitly write overloaded values
09:13:08 <yitz> rostayob: there is no reason for literals to be compiled at run time. that's stupid. we should use a mechanism that allows their type to be overloaded but still compile them at compile tiem.
09:13:24 <yitz> there are plenty of ways to do that
09:13:34 <rostayob> yitz: "compiled at run time" makes no sense to me
09:13:44 <rostayob> they're just re-computed
09:13:46 <Saizan> yitz: your use of the term "compiled" is biased
09:13:46 <yitz> a string literal is really just another kind of quasi-quote.
09:14:13 <Saizan> yitz: we can see what you mean but it's not an argument per se
09:14:13 <rostayob> so? it's sugar
09:14:53 <Saizan> anyhow i think we understand each other positions, some are just more worried about the guarantees lost with oveloaded string literals than others
09:15:02 <rostayob> yeah
09:15:10 <yitz> rostayob: all compilation is "just re-computed". it is "re-computing" the literal characters you write in your program. a literal is syntax, part of your program. it should not be 're-computed' at run time.
09:15:36 <yitz> Saizan: ok glad you see what i mean :)
09:15:46 <Saizan> yitz: yeah, it becomes syntax for fromString ("foo"::String)
09:15:46 <rostayob> so you'd say that foo = return () is "compiled at run time" when used?
09:16:00 <rostayob> i think it's a very misleading terminology
09:16:12 <Saizan> so stop pretending something utterly insane is happening :)
09:16:31 <yitz> but something utterly insane *is* happening
09:16:48 <rostayob> no, it's just a simple transformation... like the one from "foo" to ['f', 'o'
09:16:52 <rostayob> , 'o']
09:17:08 <Mongey> Hey, I have a data type called state ( https://gist.github.com/1566352). The header and records are made from contents of a csv. Any time I try to use records state, it says "Couldn't match expected type `State' with actual type `IO State' "
09:17:20 <rostayob> and from ['f', 'o', 'o'] to [112, 102, 102]
09:17:34 <rostayob> you're just adding one more step
09:18:08 <rostayob> i understand what you're saying but you're not adding any unsafety to haskell, the language
09:18:14 <Saizan> Mongey: you've to paste the code that triggers the error
09:19:11 <yitz> rostayob: the fact is that there are already libraries on hackage that call error depending on what you write in a string. that's insane.
09:19:52 <rostayob> yitz: yes, you can write insane stuff, even in haskell. and i agree with you that OverloadedStrings allows you to write subtle errors easily
09:19:57 <rostayob> but it's not more unsafe
09:21:11 <Saizan> Mongey: http://www.haskell.org/haskellwiki/Introduction_to_IO <- this would help, anyhow
09:22:09 <yitz> rostayob: why are you opposed to string literals being compiled at compile time?
09:22:24 <rostayob> yitz: what?
09:22:41 <rostayob> i'm opposed to OverloadedStrings mostly because if forces you to annotate your literals pretty often
09:23:01 <rostayob> also because it can lead to funny code like you said
09:23:36 <yitz> rostayob: why not have it work as syntax, like a quasi-quote? why are you so opposed to that?
09:24:22 <rostayob> yitz: I'm not sure I understand your proposal
09:24:32 <rostayob> also, I haven't shown opposition to anything up to now :P
09:24:51 <rostayob> apart from the notion that polymorphic literals are unsafe
09:24:57 <Mongey> Saizan: thanks, it's all very confusing!
09:25:34 <yitz> rostayob: let the compiler infer the type of the string literal from its context, and then use the function you supply it to compile the string then. it's what you would expect a string literal to do.
09:25:59 <rostayob> yitz: that already happens if you transform a string literal to "fromString lit"
09:26:10 <rostayob> no wait
09:26:13 <rostayob> "compile the string"?
09:26:25 <rostayob> i'm really confused by your use of "compile" i think
09:26:41 <yitz> rostayob: run the function then. during compilation. take the result and put it into your compiled executable.
09:27:11 <rostayob> oh. what's the difference? also, what do you do when you can infer a monomorphic type?
09:27:26 <rostayob> *can't
09:27:31 <JuanDaugherty> insane
09:28:05 <yitz> then it's an error, just like it is now. the point is to allow literals for Text, ByteStrings, etc.
09:28:16 <Saizan> rostayob: basically, yitz wants OverloadedString work more like an extension of the parser, so that an error from fromString is raised at compile-time
09:28:26 <Saizan> *to work
09:28:31 <rostayob> it doesn't make any difference in terms of safety if you allow it to be polymorphic. if you restrict literals to (inferred) monomorphic types, then your proposal is not too bad
09:28:46 <rostayob> i think i'd support something like that
09:28:51 <yitz> and the difference is that if your string can't be interpreted for its type, you get an error at compile time. not a customer service call.
09:29:11 <rostayob> yitz: yeah but you lose expressivity
09:29:19 <rostayob> but i think it's a good proposal
09:29:25 <yitz> right i don't want literal overloading for polymorphic types
09:29:34 <Saizan> yitz: i think you'd have a better time arguing for your proposal if you were less hyperbolic about the current situation
09:29:51 <yitz> Saizan: but i like hyperboles
09:30:14 <rostayob> also, the fact that OverloadedStrings is "unsafe" is just false
09:30:26 <Saizan> then you'll probably just have lengthy discussions instead of an improvement in ghc :)
09:30:27 <rostayob> since unsafe in  haskell is a word tied to functions like unsafePerformIO and unsafeCoerce
09:30:47 <Mongey> this is some of my code that loads in a csv file and makes a state from it. https://gist.github.com/74556e02aa78242ca064 , In ghci if I do 'let s = load "test.csv"' it'll return IO State, but how do I access the records value of it ??
09:31:07 <Saizan> Mongey: do s <- load "test.csv"
09:31:09 <yitz> rostayob: true i certainly didn't mean that
09:32:01 <yitz> rostayob: but otoh the reason that those are labeled unsafe is the same - they bypass static guarantees, and can lead to runtime crashes
09:32:02 <rostayob> but yours is not a bad idea
09:32:17 <rostayob> yitz: every function call can lead to runtime crashes in haskell.
09:32:43 <yitz> rostayob: you mean if you run out of memory or something?
09:33:08 <rostayob> the fact that "foo" would be desugared to fromString "foo" doesn't mean that the "unsafeness" is increased, just that some function is called behind the scenes when you demand that string
09:33:24 <rostayob> yitz: no, in the sense that every value might contain an undefined
09:33:28 <rostayob> somewhere
09:33:42 <rostayob> anyway i think we understood each other positions and we're arguing on terminology now :P
09:33:48 <Mongey> SaizanL awesome, that has saved me :D what's the difference between <- and let s =... ?
09:33:55 <yitz> ok :)
09:34:00 <Mongey> * Saizan
09:34:09 <byorgey> rostayob: the fact that an argument may contain undefined is not the fault of the function it is passed to.
09:34:25 <rostayob> byorgey: no, i mean the function that is being called
09:34:35 <rostayob> might throw undefined
09:34:47 <rostayob> as the "fromString" of a certain instance might
09:34:50 <byorgey> rostayob: "every function call can lead to runtime crashes" -- how can calling (:), for example, lead to runtime crashes?
09:34:55 <rostayob> (which is what yitz is warried about)
09:35:06 <rostayob> byorgey: that's because you know that (:) is total
09:35:28 <rostayob> but with the same reasoning, if i know that my fromString is total...
09:35:52 <byorgey> ok, never mind, I am not sure what we are arguing about =)
09:36:06 <yitz> rostayob: but you don't. you have no control (typically) over fromString, and you're unlikely ever to bother looking at it.
09:36:07 <int-e> @undo do let s = value; t <- action; return (s, t)
09:36:07 <lambdabot>  Parse error at "<-" (column 21)
09:36:18 <int-e> @undo do let { s = value }; t <- action; return (s, t)
09:36:18 <lambdabot> let { s = value} in action >>= \ t -> return (s, t)
09:36:23 <rostayob> byorgey: long and almost pointless discussion on OverloadedStrings :P
09:36:28 <byorgey> hehe, I see
09:36:36 <RUR32D4-J> a = 1
09:36:43 <rostayob> yitz: yeah yeah, I get your worries
09:37:06 <yitz> rostayob: right this was a tiresome way of getting to the point.
09:37:06 <Saizan> Mongey: x = foo; means that x is exactly the same as foo, so "s = load "test.csv"" means that s is the action load "test.csv" itself, not its result
09:37:11 <rwbarton> the discussion shouldn't be about strings at all, it should be about moving more evaluation to compile time
09:37:28 <yitz> rostayob: i conclude that i should write a bot to make these arguments for me when it comes up
09:37:29 <Saizan> Mongey: x <- foo instead means that x is bound with the result of foo
09:37:42 <rostayob> yitz: ahah. the OverloadedStrings markov chain.
09:37:49 <Mongey> Saizan : thanks a lot !
09:38:16 <rostayob> we should also have "is undefined a value" and "is haskell really pure" bots
09:38:23 <Saizan> Mongey: you can think of something of type IO A as code describing the side-effects to be executed
09:38:39 <int-e> Mongey: I'm not sure whether this helps you, but in the @undo above, note that 's = value' became a 'let' binding, while the 't <- action' became something involving >>= (called 'bind') ... it's this bind operation that allows you to chain actions in a monad, using their result in the following computation.
09:39:25 <rostayob> also, "is haskell lazy"
09:39:35 <rostayob> related to the undefined one
09:40:18 <Mongey> int-e : thanks
09:48:03 <nitencasi> how can i sum a list of integer values?
09:48:13 <lispy> ?hoogle sum
09:48:13 <lambdabot> Prelude sum :: Num a => [a] -> a
09:48:14 <lambdabot> Data.List sum :: Num a => [a] -> a
09:48:14 <lambdabot> Data.Monoid Sum :: a -> Sum a
09:48:23 <lispy> > sum [1,2,3]
09:48:24 <lambdabot>   6
09:48:44 <roconnor> > getSum . mconcat $ map Sum [1,2,3]
09:48:46 <lambdabot>   6
09:49:03 <roconnor> > getSum . mconcat . map Sum $ [1,2,3]
09:49:05 <lambdabot>   6
09:49:28 <rostayob> the set theory way
09:49:36 <nitencasi> sum is telling me that i cant join Integer it aspects an Int
09:49:55 <rostayob> nitencasi: foldr (+) 0
09:50:13 <roconnor> nitencasi: listen to lispy
09:50:14 <JoeyA> Can I rely on Parsec's non-backtracking semantics?  With Attoparsec, I can't count on this.  For example:
09:50:17 <JoeyA> let p = (char 'a' *> char 'b' *> char 'c') <|> (char 'a' *> char 'b' *> char 'd')
09:50:30 <JoeyA> parseOnly p "abd" ==> Right 'd'
09:51:54 <rostayob> JoeyA: so you want that not to succeed
09:52:14 <JoeyA> rostayob: Correct
09:52:16 <rostayob> since it consumes the 'c'? iirc parsec backtracks if it fails matching a single token of the stream
09:52:23 <rostayob> "backtracks"
09:52:28 <rostayob> but just for the single token
09:52:55 <yitz> rostayob: it consumed the a and b
09:53:04 <rostayob> oh right. then it shouldn't work
09:53:16 <rostayob> (in Parsec. I don't know about attoparsec)
09:53:45 <rostayob> but parse (char 'a' <|> char 'b') "b" should succeed
09:53:48 <JoeyA> Right.  The parser fails in Parsec (which I expect, because the left parser consumed input).
09:54:01 <nitencasi> lispy, sorry i did not understand the example
09:54:03 <JoeyA> But in Attoparsec, it didn't (but could).
09:54:06 <nitencasi> can you explain to me?
09:54:10 <yitz> JoeyA: the docs for attoparsec specify that the string parser does not consume anything when it fails. but that is interesting that even multiple individual characters are not consumed.
09:55:23 <JoeyA> So I know I can't count on backtracking to fail in Attoparsec.  I was wondering if it is the same with Parsec.
09:55:42 <JoeyA> err, can't count on <|> to fail if the left parser consumed input.
09:55:54 <yitz> JoeyA: i also noticed that at some point
09:56:11 <rostayob> JoeyA: parser doesn't backtrack unless you wrap the parse with try, which basically pushed back the state that the parser was in before
09:56:42 <JoeyA> I know.  But I can't count on that happening in Attoparsec, as shown in my abd example.
09:56:46 <nitencasi> can someone explain to me how can i sum a list of integer?
09:56:53 <yitz> JoeyA: in general, because of the way it works with continuations, you tend to use a lot of little parsers with attoparsec rather than one big one
09:56:53 <JoeyA> > sum [1..10]
09:56:54 <lambdabot>   55
09:56:55 <rwbarton> the parsec documentation appears to say that you can rely on this
09:57:00 <JoeyA> foldl' (+) 0 [1..10]
09:57:04 <rostayob> :t sum
09:57:05 <lambdabot> forall a. (Num a) => [a] -> a
09:57:05 <yitz> JoeyA: so it actually very rarely makes a difference.
09:57:07 <rwbarton> but it's not really that explicit I guess
09:57:13 <rostayob> nitencasi: sum should work with all numbers
09:57:24 <rwbarton> nitencasi: you have some other type error
09:57:30 <JoeyA> yits, rostayob, etc.: Thanks for the help.  I have to go now.
09:57:37 <nitencasi> i will post the code
09:57:41 <rwbarton> are you trying to average a list by any chance
09:58:06 <yitz> JoeyA: your example is contrived, you would never write a real parser that way anyway
09:58:18 <yitz> oops JoeyA is gone
09:58:42 <xplat> is there a package that has things like 'sortBy.comparing' and 'maximumBy.comparing' but where the key-function doesn't get reevaluated at every comparison?
09:59:23 <nitencasi> rwbarton, http://dpaste.com/682221/
09:59:48 <rostayob> xplat: the key function shouldn't be reevaluated
09:59:50 <yitz> xplat: not in the popular packages i know of. just use a schwartzian transform for that.
10:00:03 <rostayob> maybe i misunderstood the question :P
10:00:13 <Botje> xplat: map snd . sortBy (compare `on` fst) . map ((,) `ap` f)
10:00:16 <rostayob> gotta go as well
10:00:22 <rwbarton> nitencasi: as usual the first thing I try is compiling the given code... and it compiles fine
10:00:23 <shachaf> OverloadedBool!
10:00:35 <rwbarton> aside from "import Char" (are you using hugs?)
10:01:18 <Saizan> shachaf: instance IsBool Bool where fromBool = not
10:01:21 <cpennington> did the RTS opts available for heap profiling change in ghc 7.2.1?
10:01:23 <Botje> oh, bleh, i swapped snd and fst :(
10:01:48 <shachaf> class Isn'tBool where {}
10:02:01 <nitencasi> rwbarton, yes it compiles fine. but it does not give me the right output
10:02:04 <cpennington> I'm trying to use "+RTS -hc", and am getting a help message about available profiling flags
10:02:08 <nitencasi> rwbarton, ghc
10:02:15 <yitz> Saizan: instance IsBool Bool where fromBool True = True; fromBool False = error "bwahaha"
10:02:29 <rwbarton> I naively assumed this related to your question "sum is telling me that i cant join Integer it aspects an Int"
10:03:22 <nitencasi> rwbarton, i assumed that sum was able to sum them all together that why it return the wrong number
10:03:54 <cpennington> aha
10:04:03 <cpennington> hadn't compiled with profiling enabled
10:04:29 <rwbarton> nitencasi: do you have a question?
10:05:06 <nitencasi> rwbarton, yes what hell is going wrong with my code
10:05:09 <nitencasi> it seems fine
10:05:11 <nitencasi> it compiles
10:05:18 <nitencasi> but it gives me the wrong result
10:05:27 <rwbarton> probably your code is wrong then
10:06:02 <rwbarton> I don't know what you expect your program to do
10:06:22 <titto> is there any way of automatically deriving the Generic instance of a GADT ?
10:06:29 <Fuco> @type (<+>)
10:06:30 <lambdabot>     Ambiguous occurrence `<+>'
10:06:30 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
10:06:30 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
10:06:35 <b_jonas> no way
10:06:38 <nitencasi> rwbarton, i expect my code to solve problem 13 on euler http://projecteuler.net/problem=13
10:06:38 <Fuco> @type (Control.Arrow.<+>)
10:06:39 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
10:06:57 <b_jonas> haskell is a strongly typed language. if your haskell program compiles, then it must give the right results.
10:07:17 <c_wraith> b_jonas: if by that you mean "answers of the correct type"...
10:07:38 <c_wraith> > let sum x = 0 in sum [1..100]
10:07:39 <lambdabot>   0
10:07:43 <Fuco> main = putStrLn "4" ... but I wanted 7 :(
10:07:54 <rwbarton> nitencasi: well indeed, your program does not appear to do anything like what the problem asks you to do. I suggest you read the problem more carefully.
10:08:05 <Fuco> anyway, what the hell is this <+> thing
10:08:13 <c_wraith> Fuco: what library?
10:08:15 <geekosaur> titto, last I checked automaic deriving did not work with GADTs at all
10:08:17 <Fuco> xmonad
10:08:26 <geekosaur> xmonad defines <+> as a synonym for mappend
10:08:39 <b_jonas> rwbarton: has he showed his program yet?
10:08:40 <Fuco> omg you're everywhere!
10:08:46 <Fuco> thanks :P
10:09:06 <rwbarton> b_jonas: yep it's at http://dpaste.com/682221/
10:09:06 <nitencasi> rwbarton, i know that the part that it sum all the 10 first number of the sum of the greater number
10:09:10 <b_jonas> thank
10:09:11 <b_jonas> s
10:09:20 <nitencasi> but i only have an number is less that 10 digits
10:09:23 <titto> geekosaur: yes I see, but I hoped that there was some library that could handle that, I checked "derive" but I dont' see any support for Generic
10:09:52 <sheaf> is there a good way to write compositions like (a -> b -> c) -> (c -> d) -> (a -> b -> d)?
10:10:04 <b_jonas> sheaf: ask @pl
10:10:14 <geekosaur> I am under the impression that getting automatic deriving to work with GADTs is nontrivial
10:10:38 <Fuco> I guess it'll be ugly :P
10:10:59 <b_jonas> or maybe even djinn
10:11:08 <b_jonas> @djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
10:11:08 <lambdabot> f a b c d = b (a c d)
10:11:21 <b_jonas> @pl let { f a b c d = b (a c d) } in f
10:11:21 <lambdabot> (line 1, column 5):
10:11:21 <lambdabot> unexpected "{"
10:11:21 <lambdabot> expecting "()", natural, identifier or "in"
10:11:24 <Fuco> (.).(.)
10:11:32 <Fuco> oh, and flip that
10:11:46 <rwbarton> @pl  f a b c d = b (a c d)
10:11:47 <lambdabot> f = flip ((.) . (.))
10:11:48 <Fuco> turned out pretty nice
10:11:51 <b_jonas> @pl \ a b c d -> b (a c d)
10:11:52 <lambdabot> flip ((.) . (.))
10:12:07 <sheaf> yeah but then if it's (a -> b -> c -> d), ... etc
10:12:11 <Fuco> what is that called, boobs combinator? :D
10:12:16 <sheaf> ((.).(.).(.)) etc
10:12:16 <b_jonas> Fuco: yes, tits
10:12:20 <Fuco> sweet
10:20:58 <roconnor> Fuco: it's name after its creator: Jacques Tits (1964)
10:22:29 <b_jonas> roconnor: you must mean “discoverer”. all combinators were created by god.
10:23:10 <roconnor> b_jonas: Definitions are created/invented.  Proofs are discovered.
10:23:58 <roconnor> or rather "the fact that a proposition is true" is discovered.
10:24:15 <roconnor> usually by creating a proof :)
10:24:18 <rwbarton> okay, that's more palatable
10:24:57 <b_jonas> on the zeroth day, god created variables. on the ith day, god created compositions of each two previously created terms, and lambda abstractions of each previously created term over each variable. by day omega, all combinators were created.
10:26:35 <b_jonas> so he rested on day omega and blessed it
10:26:37 <rwbarton> I happen to think of discovery/invention as a kind of continuum
10:27:10 <roconnor> rwbarton: well the most important bit is that both kinds of things happen in mathematics.
10:27:16 <b_jonas> combinators are like integers or sets, they were created by god, we just rediscover them.
10:27:26 <rwbarton> where I would tend to say that the notion of monoid is something closer to "discovered" and the notion of set with a 684578616478780081468620053490547095553-ary operation closer to "invented"
10:28:43 <rwbarton> or alternatively the notion of a set with a binary operation satisfying the identity a * ((a * a) * (b * (a * b))) = b * (a * a) etc.
10:28:55 <roconnor> rwbarton: I would say that coalgebras and lenses were both invented, and the fact that lenses are coalgebras was discovered.
10:34:03 <dolio> roconnor: You get my paste?
10:36:12 <roconnor> dolio: ya, I wanted to ask what happens if f is _|_ in line 16
10:36:22 <b_jonas> what's the hip declarative language with strict semantics these days? ocaml? erlang?
10:36:30 <dolio> _|_ x = _|_ and _|_ <= _|_
10:37:01 <b_jonas> or maybe still standard ml?
10:37:16 <roconnor> dolio: so for all f, (\s -> _|_) <= f incluidng f = _|_ ?
10:37:30 <dolio> roconnor: It's not really sensible for \s -> _|_ to be different from _|_.
10:37:36 <dolio> Despite it being so in Haskell.
10:37:48 <roconnor> dolio: does it violoate CPO laws?
10:38:33 <dolio> If we assume the ordering on functions is point-wise, probably.
10:38:36 <dolio> I don't know of another one.
10:38:47 <rwbarton> doesn't it just fail to be the exponential?
10:38:48 <roconnor> hmm
10:38:50 <rwbarton> or is that what you meant
10:39:13 <roconnor> I'd like to know what the ordering on function is supposed to be if it isn't exactly pointwise.
10:39:21 <rwbarton> much like haskell lacks products and coproducts, we can say that haskell lacks functions!
10:39:34 <roconnor> I guess it is a lifted exponential
10:40:06 <roconnor> so it is f <= g iff (forall x, f x <= g x) unless f = _|_ or g = _|_ in which case _|_ is the smallest
10:40:32 <dolio> If that works.
10:40:41 <rwbarton> Haskell, the world's finest lifted functional programming language
10:41:20 <dolio> Anyhow, _|_ isn't a fixed point in that case, but \s -> _|_ is, which still doesn't make sense if you're trying to use it as a model for IO.
10:41:30 <roconnor> dolio: right
10:41:59 <xplat> isn't the whole point of using a high-abstraction language like haskell that we can easily abstract 'design patterns' like schwartzian transforms and not have to write them over and over again?
10:42:06 <cheater> does haskell have 1-tuples? what is the literal?
10:42:13 <rwbarton> I wonder how "lift" came to be the "normal" of functional programming terminology
10:42:23 <xplat> data-tuples has a 1-tuple type, but it doesn't have syntax
10:42:37 <cheater> so for tuples i need at least two?
10:42:40 <cheater> that sucks.
10:42:42 <cheater> why is it like this?
10:43:08 <roconnor> cheater: so that (x) doesn't box up expressions causing stupid type errors?
10:43:12 <xplat> the way tuples are used in haskell, you should never need a 1-tuple except for generic programming
10:43:24 <xplat> in that case, it's data-tuple to the rescue
10:43:54 <roconnor> I think the right answer is to get rid of 3-tuples and higher!
10:44:01 <roconnor> bwaaahh
10:44:21 <cheater> roconnor: but you oculd have (x,) or something, no?
10:44:28 <cheater> that's how you do it in pythonb
10:44:30 <cheater> python
10:44:31 <xplat> you wouldn't have something like "number %d of %d" % (index, total) in haskell where you might need to get rid of total and use a 1-tuple
10:45:03 <roconnor> cheater: oh, okay
10:45:09 <xplat> (you could have something similar with printf but that's curried)
10:45:13 <Saizan> > (1,) 2
10:45:14 <lambdabot>   Illegal tuple section: use -XTupleSections
10:45:19 <roconnor> cheater: though
10:45:23 <cheater> > (1,)
10:45:23 <lambdabot>   Illegal tuple section: use -XTupleSections
10:45:35 <roconnor> as I was going to say, tuple sections already use that notation
10:45:47 <cheater> what's a tuple section?
10:45:56 <Saizan> (1,) 2 == (1,2)
10:45:59 <roconnor> cheater: do you know what a section is?
10:46:02 <shachaf> rwbarton: I thought everything was a product in Haskell.
10:46:06 <xplat> tuple sections seem more useful than 1-tuples, generally speaking
10:46:30 <cheater> roconnor: probably not.
10:46:37 <cheater> roconnor: can you illustrate?
10:46:41 <roconnor> cheater: (3 +) is a section
10:46:42 <copumpkin> (+5)
10:46:53 <cheater> what does such a thing do?
10:46:54 <roconnor> cheater: so is (+ 5)
10:46:55 <copumpkin> (3+) is a section, (+3) is a retraction
10:47:03 <roconnor> copumpkin: is that true?
10:47:06 <copumpkin> lol
10:47:07 <copumpkin> no
10:47:11 <roconnor> whew
10:47:17 <Rc43> Hi, guys.
10:47:28 <roconnor> cheater: it is a way of doing parital application to infix operations
10:47:40 <roconnor> > (^2) 5
10:47:41 <lambdabot>   25
10:47:55 <roconnor> > map (5^) [0,1,2]
10:47:56 <lambdabot>   [1,5,25]
10:47:56 <cheater> roconnor: i understand the syntax but i've never heard of "sections"
10:48:05 <roconnor> ya, they are called sections
10:48:08 <roconnor> it's a poor name
10:48:12 <Rc43> Why LLVM can be desired for me?
10:49:23 <cheater> roconnor: i think haskell needs like a special point in the specification on NAMING things.
10:49:29 <cheater> because it obviously needs to improve.
10:49:34 <roconnor> cheater: http://www.haskell.org/onlinereport/exps.html#sections
10:51:58 <lukish> Is there some way to figured out, that a :: Ratio Integer is Integer-like. For example f 2 % 2 == True, f 4 % 3 == False.
10:52:34 <roconnor> @hoogle trunc
10:52:34 <lambdabot> Prelude truncate :: (RealFrac a, Integral b) => a -> b
10:52:34 <lambdabot> System.Posix.IO trunc :: OpenFileFlags -> Bool
10:52:34 <lambdabot> Codec.Compression.Zlib.Internal TruncatedInput :: DecompressError
10:52:43 <roconnor> > truncate (-1.0)
10:52:43 <lambdabot>   -1
10:52:52 <roconnor> wait that's not what I want
10:53:03 <roconnor> @info RealFrac
10:53:03 <lambdabot> RealFrac
10:53:08 <rwbarton> > denominator (2 % 2)
10:53:09 <lambdabot>   1
10:53:16 <rwbarton> > denominator (4 % 3)
10:53:17 <lambdabot>   3
10:53:22 <roconnor> rwbarton: clever
10:53:59 <cheater> thanks roconnor that was a nice explanation
10:54:23 <roconnor> I was going to say \x -> (0 = snd (properFraction x))
10:54:48 <rwbarton> > denominator (-1%1)
10:54:49 <lambdabot>   1
11:03:59 <roconnor> > denominator (1%0)
11:04:00 <lambdabot>   *Exception: Ratio.%: zero denominator
11:05:28 <copumpkin> > toRational (1 / 0)
11:05:29 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:05:35 <copumpkin> > toRational (0 / 0)
11:05:36 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
11:05:46 <copumpkin> > toRational (-1 / 0)
11:05:47 <lambdabot>   (-1797693134862315907729305190789024733617976978942306572734300811577326758...
11:06:11 <frerich_> I'm glad that this has been settled once and for all, I always wondered what you get when dividing by zero!
11:07:11 <rwbarton> @let nullity = toRational (0 / 0)
11:07:12 <lambdabot>  Defined.
11:07:29 <geekosaur> toRational is known buggy that way, IIRC
11:07:44 <JoeyA> > length $ show $ toRational (1 / 0)
11:07:45 <lambdabot>   313
11:08:16 <Shiney>  > toRational 3.14
11:08:28 <JoeyA> > map (length . show . toRational . (/ 0)) [-10..10]
11:08:28 <rwbarton> > realToFrac nullity
11:08:29 <lambdabot>   can't find file: L.hs
11:08:29 <lambdabot>   [316,316,316,316,316,316,316,316,316,316,316,313,313,313,313,313,313,313,31...
11:08:48 <rwbarton> > realToFrac nullity
11:08:49 <lambdabot>   -Infinity
11:08:51 <Shiney> > toRational 3.14
11:08:52 <lambdabot>   7070651414971679 % 2251799813685248
11:09:03 <ion> > nullity
11:09:04 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
11:09:11 <rwbarton> > realToFrac nullity :: CReal
11:09:13 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
11:09:18 <rwbarton> oh
11:09:32 <rwbarton> > denominator nullity
11:09:33 <lambdabot>   1
11:09:38 <rwbarton> just an integer
11:11:53 <JoeyA> > 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091 :: CReal
11:11:54 <lambdabot>   3.1415926535897932384626433832795028841972
11:12:20 <roconnor> JoeyA: the show for CReal is a little borked
11:12:38 <roconnor> JoeyA: soon we will be able to simply remove it
11:12:50 <copumpkin> then just use showCReal
11:13:00 <JoeyA> > showCReal 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091
11:13:01 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
11:13:01 <copumpkin> I want a CReal -> String that gives you an infinite string (all the time)
11:13:01 <lambdabot>    arising from the lit...
11:13:15 <JoeyA> :t showCReal
11:13:16 <lambdabot> Int -> CReal -> String
11:13:28 <JoeyA> > showCReal 250 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091
11:13:29 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
11:13:46 <parcs`> > showCReal 250 pi
11:13:47 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
11:13:51 <roconnor> JoeyA: private message with lambdabot will be longer
11:14:01 <JoeyA> > length $ showCReal 250 pi
11:14:01 <lambdabot>   252
11:14:23 <roconnor> > length $ show $ showCReal 250 pi
11:14:24 <lambdabot>   254
11:14:24 <rwbarton> > showCReal 50 1
11:14:25 <lambdabot>   "1.0"
11:14:31 <parcs`> > 1/0 :: Int
11:14:32 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
11:14:32 <lambdabot>    arising from a use o...
11:14:38 <rwbarton> > showCReal 50 (cos pi)
11:14:39 <lambdabot>   "-1.0"
11:14:47 <parcs`> > showCReal maxBound pi
11:14:48 <lambdabot>   "*Exception: Negative exponent
11:14:49 <rwbarton> magic
11:14:55 <parcs`> hmm
11:15:09 <parcs`> > showCReal (maxBound - 1) pi
11:15:10 <lambdabot>   "*Exception: Negative exponent
11:15:20 <parcs`> > showCReal (maxBound `div` 2) pi
11:15:21 <lambdabot>   "*Exception: Negative exponent
11:15:32 <parcs`> why
11:15:41 <roconnor> parcs`: CReal itself is a little borked
11:15:46 <copumpkin> b0rked
11:15:53 <lukish> Well
11:16:06 <lukish> I read some log, but cannot find the answer
11:16:27 <JoeyA> @hoogle CReal
11:16:27 <lambdabot> No results found
11:18:11 <parcs`> why aren't shiftL and shiftR named .<<. and .>>.?
11:19:37 <JoeyA> I demand to know why, too.
11:19:41 <JoeyA> Or I want my money back.
11:19:59 <JoeyA> Indeed, it would be nice to have those operator names.
11:20:02 <cheater> let's say i am somewhere deep in my code
11:20:17 <cheater> and suddenly i want to print out a value and its type for debugging purposes somewhere in some function
11:20:21 <cheater> how do i do that?
11:20:26 <JoeyA> @hoogle trace
11:20:27 <lambdabot> Debug.Trace module Debug.Trace
11:20:27 <lambdabot> Debug.Trace trace :: String -> a -> a
11:20:27 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
11:20:44 <byorgey> lukish: just check if the denominator is 1
11:20:48 <byorgey> > denominator (2 % 2)
11:20:49 <lambdabot>   1
11:20:51 <cheater> which one do i use JoeyA ?
11:20:53 <cheater> and how?
11:20:56 <byorgey> > denominator ((-5) % 1)
11:20:56 <lambdabot>   1
11:21:00 <parcs`> cheater: are you in IO
11:21:09 <cheater> no
11:21:16 <cheater> i am in a random place
11:21:19 <JoeyA> cheater: In pure code (i.e. not in IO), you "can't" perform arbitrary IO.
11:21:24 <JoeyA> Debug.Trace cheats
11:21:31 <cheater> yeah i realize
11:21:37 <drull95> having just discovered that unicode has alchemical symbols i think haskell should use them
11:21:37 <cheater> so which of those functions do i use?
11:21:42 <cheater> trace or traceShow ?
11:21:42 <drull95> http://www.unicode.org/charts/PDF/U1F700.pdf
11:21:46 <byorgey> oh, I guess rwbarton already said that
11:21:54 <cheater> and how? sorry i'm confused right now
11:21:55 <JoeyA> cheater: traceShow is a convenience function that automaticaly applies show to the argument.
11:22:00 <cheater> parcs` knows why
11:22:08 <b_jonas> cheater: you use traceShow
11:22:12 <cheater> ok
11:22:14 <JoeyA> > traceShow [1,2,3] 1
11:22:15 <lambdabot>   Not in scope: `traceShow'
11:22:40 <JoeyA> cheater: Because Haskell uses lazy evaluation, you have to insert your traceShow call into an expression that gets evaluated.
11:22:57 <cheater> JoeyA: i realize
11:22:58 <JoeyA> So instead of x + y, you'd say, for example, traceShow [x, y] (x+y)
11:23:00 <cheater> that's not a problem
11:23:13 <JoeyA> Or you can say trace "Adding x and y" (x+y)
11:23:35 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Debug-Trace.html  <-- documentation
11:23:37 <cheater> i just want to show a single var
11:23:49 <cheater> i figured out i need to do traceShow [x] x
11:23:51 <cheater> why do i?
11:23:56 <JoeyA> Or traceShow x x
11:24:02 <cheater> why is that?
11:24:05 <JoeyA> Either way.
11:24:10 <JoeyA> [x] will show brackets around it.
11:24:11 <parcs`> cheater: you can do trace (show x) x
11:24:24 <parcs`> traceShow x y = trace (show x) y
11:24:34 <parcs`> so you can also do traceShow x x
11:24:45 <b_jonas> join traceShow x
11:24:45 <cheater> what does the y in trace do?
11:24:50 <b_jonas> or does that not work?
11:25:02 <parcs`> trace s a means print s and return a
11:25:12 <cheater> "return" meaning "evaluate to"?
11:25:16 <parcs`> yah
11:25:20 <cheater> ok
11:25:27 <rwbarton> so you replace f x = x + 7 with f x = trace "Hello there" (x + 7)
11:25:34 <JoeyA> trace x is an identity function, as is traceShow x
11:25:49 <cheater> JoeyA: nice ok
11:25:50 <cheater> cool
11:25:52 <JoeyA> It's just that when you evaluate it, it produces a spurious side effect.
11:25:52 <cheater> thanks
11:26:01 <cheater> how would i get the *type* of something?
11:26:12 <JoeyA> :t (+)
11:26:13 <lambdabot> forall a. (Num a) => a -> a -> a
11:26:19 <donri> Typeable
11:26:21 <JoeyA> oh
11:26:28 <cheater> no i mean print it out
11:26:37 <applicative> b_jonas, well you'd need to bring Control.Monad and Control.Monad.Instances into scope, but that's always worth it
11:26:38 <lukish> byorgey: that's right, thnx
11:26:38 <parcs`> cheater: typeOf
11:26:44 <parcs`> > typeOf False
11:26:45 <lambdabot>   Bool
11:26:53 <b_jonas> applicative: ah, right, yes
11:26:53 <JoeyA> traceShow (typeOf x)
11:26:57 <cheater> @hoogle typeOf
11:26:57 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
11:26:57 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
11:26:57 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
11:26:58 <cheater> nice
11:26:59 <cheater> thanks guys
11:27:02 <monochrom> are you sure you absolutely need to print the type?
11:27:07 <parcs`> ur welcome cheater <3
11:27:11 <JoeyA> > typeOf (putStrLn "Hi")
11:27:11 <lambdabot>   IO ()
11:27:17 <cheater> monochrom: yes.
11:27:28 <JoeyA> > typeOf (return $ return $ putStrLn "Hi")
11:27:29 <lambdabot>   Ambiguous type variable `m' in the constraints:
11:27:30 <lambdabot>    `GHC.Base.Monad m'
11:27:30 <lambdabot>      ...
11:28:21 <b_jonas> you print the type of x like this: let () = x in trace "()" x
11:28:25 <monochrom> that is a strange application
11:28:34 <JoeyA> > map (print . typeOf) [3, "hi", True]
11:28:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:28:35 <lambdabot>         against inferred ty...
11:28:37 <b_jonas> that should give a compile time error of a type mismatch, telling the type of x
11:28:44 <rwbarton> oh
11:28:50 <b_jonas> (unless x has type (), when it prints that in runtime)
11:28:54 <rwbarton> I thought you meant it would only compile when ... yeah that.
11:29:29 <rwbarton> anyways when you don't know the type of some variable, usually it's because your program doesn't type-check yet
11:29:36 <rwbarton> you can't debug that with trace
11:29:52 <rwbarton> well, without some other tricks I guess
11:30:10 <JoeyA> > map (print . typeOf) ([3, "hi", True] :: [forall a. Typeable a => a])
11:30:10 <lambdabot>   Cannot match a monotype with `forall a.
11:30:11 <lambdabot>                                (Dat...
11:30:32 <rwbarton> JoeyA: you would need an existential wrapper there
11:30:33 <JoeyA> So why does GHC 7.0.3 say: No instance for (Typeable (forall a. Typeable a => a))   ?
11:30:41 <b_jonas> JoeyA: perhaps you want show instead of print; or you want mapM_ instead of map ?
11:30:42 <byorgey> JoeyA: 3, "hi", and True do not have the type  forall a. Typeable a => a
11:30:53 <monochrom> evidently, True :: forall a. Typeable a => a is wrong. True is not that polymorphic.
11:31:34 <b_jonas> ah, that's the earlier error, yes
11:31:35 <JoeyA> Oh, so the elements have to be universally, rather than existentially, qualified.
11:32:05 <rwbarton> if you assign them a universally quantified type, then yes :)
11:32:21 <b_jonas> isn't it the other way?
11:32:34 <JoeyA> But still, shouldn't an instance Typeable (forall a. Typeable a => a) exist?
11:32:37 <monochrom> the other way. True :: forall a. Typeable a => a is universally quantified and therefore wrong
11:32:44 <JoeyA> At least in theory?
11:32:48 <xplat> gr, why are there no maxBy and minBy?
11:32:57 <JoeyA> > map (print . typeOf) ([undefined, undefined] :: [forall a. Typeable a => a])
11:32:58 <lambdabot>   Ambiguous occurrence `undefined'
11:32:58 <lambdabot>  It could refer to either `L.undefined', d...
11:33:06 <JoeyA> > map (print . typeOf) ([L.undefined, L.undefined] :: [forall a. Typeable a => a])
11:33:07 <lambdabot>   Cannot match a monotype with `forall a.
11:33:07 <lambdabot>                                (Dat...
11:33:21 <rwbarton> JoeyA: you seem confused but i'm not sure in what way
11:33:27 <xplat> @hoogle (a -> a -> Ordering) -> a -> a -> a
11:33:27 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
11:33:28 <lambdabot> Data.Text.Lazy.Internal foldrChunks :: (Text -> a -> a) -> a -> Text -> a
11:33:28 <lambdabot> Data.Text.Lazy foldrChunks :: (Text -> a -> a) -> a -> Text -> a
11:33:36 <byorgey> JoeyA: I don't see what an instance Typeable (forall a. Typeable a => a) has to do with anything
11:33:38 <b_jonas> xplat: would those accept a custom comparator function? accept a function that extracts the weight from a value? accept a list of weights?
11:33:53 <rwbarton> universally quantified types can't be instances of type classes, can they
11:34:02 <Saizan> xplat: \c x y -> maximumBy c [x,y]
11:34:18 <xplat> b_jonas: comparator function, i already assumed a weight-extracting version wouldn't exist
11:34:24 <monochrom> data W = forall a. Typeable a => W a; whee = [W 3, W "xxx", W True]
11:34:35 <monochrom> whee :: [W]
11:34:37 <Saizan> rwbarton: nope
11:34:52 <monochrom> W is an existential type
11:35:00 <ikiki> 3,22]
11:35:37 <JoeyA> > show (undefined :: forall a. Show a => a)
11:35:38 <lambdabot>   Ambiguous occurrence `undefined'
11:35:38 <lambdabot>  It could refer to either `L.undefined', d...
11:35:42 <JoeyA> > show (L.undefined :: forall a. Show a => a)
11:35:42 <lambdabot>   Couldn't match expected type `a' against inferred type `m b'
11:35:43 <lambdabot>    `a' is a ri...
11:36:09 <rwbarton> L.undefined what
11:36:33 <JoeyA> > show (error "What happened to undefined?" :: forall a. Show a => a)
11:36:34 <lambdabot>   "*Exception: What happened to undefined?
11:36:38 <rwbarton> L is @let?
11:36:50 <geekosaur> yes iirc
11:37:04 <JoeyA> > map show ([error "What happened to undefined?"] :: [forall a. Show a => a])
11:37:05 <lambdabot>   Cannot match a monotype with `forall a. (GHC.Show.Show a) => a'
11:37:17 <rwbarton> :t L.undefined
11:37:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
11:38:00 <monochrom> what happened to undefined? answer: it was undefined
11:38:08 <rwbarton> :t L.undefined
11:38:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
11:38:12 <rwbarton> not yet :)
11:38:14 <JoeyA> No, undefined was defined too many times.
11:38:17 <rwbarton> @undefine
11:38:24 <JoeyA> @undefine undefined
11:38:41 <JoeyA> @define undefined Prelude.undefined
11:38:43 <mauke> @define undefined
11:38:50 <JoeyA> @let undefined=Prelude.undefined
11:38:50 <lambdabot>  Defined.
11:38:55 <JoeyA> > undefined
11:38:56 <lambdabot>   Ambiguous occurrence `undefined'
11:38:56 <lambdabot>  It could refer to either `L.undefined', d...
11:38:58 <mauke> @define undefined
11:38:58 <rwbarton> nice work
11:39:03 <monochrom> @undefine x
11:39:24 <monochrom> (that clears all @let's, not just x)
11:39:40 <monochrom> (essentially @undefine ignores parameters)
11:39:52 <JoeyA> > let undefined = undefined in undefined
11:39:56 <lambdabot>   mueval-core: Time limit exceeded
11:40:06 <monochrom> (and @define is typo-corrected to @undefine so "@define x=()" is the #1 mistake)
11:40:20 <JoeyA> > let (_|_) = error "bottom" in (_|_)
11:40:20 <lambdabot>   <no location info>: parse error on input `|'
11:40:24 <JoeyA> aww
11:43:03 <Philonous_> > let ⊥ = fix id in ⊥
11:43:04 <lambdabot>   <no location info>: parse error on input `
11:44:36 <rwbarton> > let ᚆ = fix id in ᚆ
11:44:40 <lambdabot>   mueval-core: Time limit exceeded
11:45:20 <JoeyA> > isAlpha 'ᚆ'
11:45:21 <lambdabot>   True
11:45:27 <rwbarton> not that that character actually renders in the font I'm using
11:45:37 <JoeyA> It does in mine :-)
11:45:43 <b_jonas> what's the truth in the rumour that type families are equistrong to fundeps?
11:45:50 <rwbarton> that was the hope :)
11:46:01 <JoeyA> (except it's tiny)
11:48:07 <augur> weird character
11:48:17 <augur> how is that alphanumeric
11:48:26 <augur> or alphabetical, even
11:48:28 <augur> is it hangul?
11:48:36 <rwbarton> it's an ogham letter
11:48:39 <augur> ahhhh
11:48:45 <augur> ok
11:48:45 <augur> that makes sense
11:48:49 <shachaf> What's the code point?
11:48:49 <ion> U+1686 OGHAM LETTER UATH
11:48:58 <shachaf> Thanks, ion. Thion.
11:49:03 <rwbarton> I used http://shapecatcher.com
11:49:27 * ion appreciates shachaf’s reference.
11:49:28 <JoeyA> Suppose I wanted to use Parsec to parse a simple line-based configuration file (e.g. INI).  Individual lines can be parsed in isolation (*), but the document as a whole has structure, such that lines can be thought of as tokens.
11:49:56 <JoeyA> (*) If I wanted to support multi-line statements, this wouldn't be quite as true.
11:50:39 <JoeyA> Would I want to create two parsers: an individual-line parser whose stream type is String, and a document parser whose stream type is [Line] ?
11:50:47 <JoeyA> Or would I be better off making it a single parser?
11:50:57 <JoeyA> (with stream type String)
11:51:10 <JoeyA> Or is a stream type of [Line] bogus?
11:53:23 <JoeyA> But if I used two kinds of parsers like that, wouldn't that mix up information about line and column numbers (used in error messages)?
11:56:48 <b_jonas> okay, let me get more specific
11:57:35 <monochrom> parsec has provision for you to provide your own row-column information. it takes more work.
11:58:34 <monochrom> actually exactly the same work for creating your own stream type [Line]
12:01:51 <JoeyA> There's a confusing typo in the Parsec documentation: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:token
12:02:05 <JoeyA> Under "token", it says: The parser tokenPrim showTok posFromTok testTok accepts a token ...
12:02:20 <JoeyA> And under "tokenPrim": The parser token showTok nextPos testTok accepts a token ...
12:04:06 <JoeyA> I think token and tokenPrim need to be swapped in the documentation text here.  I can infer what they mean from the argument descriptions, but it's still quite a stumbling block.
12:04:45 <KSkrzet> I have a weird problem with conduits...
12:04:49 <KSkrzet> src/extract-words.hs:64:44:
12:04:49 <KSkrzet>     No instance for (monad-control-0.3.1:Control.Monad.Trans.Control.MonadTransControl
12:04:49 <KSkrzet>                        ResourceT)
12:04:49 <KSkrzet>       arising from a use of `resourceLiftBase'
12:04:49 <KSkrzet>     Possible fix:
12:04:49 <KSkrzet>       add an instance declaration for
12:04:51 <KSkrzet>       (monad-control-0.3.1:Control.Monad.Trans.Control.MonadTransControl
12:04:53 <KSkrzet>          ResourceT)
12:04:55 <KSkrzet>     In the expression: resourceLiftBase (sinkFinish st)
12:04:57 <KSkrzet>     In the third argument of `sinkState', namely
12:05:01 <KSkrzet>       `(\ st -> resourceLiftBase (sinkFinish st))'
12:05:03 <KSkrzet>     In the expression:
12:05:05 <KSkrzet>       sinkState
12:05:07 <KSkrzet>         0 sinkWriteHashMap (\ st -> resourceLiftBase (sinkFinish st))
12:06:37 * hackagebot scotty 0.0.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.0.1 (AndrewFarmer)
12:29:08 <lukish> I apply some function with map to list of values and have exception: ,*** Exception: Ratio.%: zero denominator
12:29:43 <lukish> How can I go leave it and proceed aplying?
12:31:37 * hackagebot hexpat 0.19.9 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.9 (StephenBlackheath)
12:31:39 * hackagebot aws 0.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.1 (AristidBreitkreuz)
12:33:04 <Cale> lukish: you could use a list comprehension to try to avoid bad values ahead of time
12:34:36 <lukish> Cale: but how can I avoid bad value
12:34:38 <lukish> &
12:34:39 <lukish> ?
12:35:27 <Cale> lukish: Well, you'd have to know which values are bad for the function that you're applying ahead of time. It might be saner to use Maybe or Either in the case where it's hard to determine ahead of time.
12:35:33 <rwbarton> you should understand for what input values your function will fail
12:36:11 <lukish> I can't change that function.
12:36:23 <lukish> All I have is knowing of error
12:36:50 <rwbarton> of course you *can* change it
12:37:01 <rwbarton> where does this function come from? what does it do?
12:37:10 <lukish> I can only build a handler over it
12:37:25 <rwbarton> sure
12:38:04 <rwbarton> knowing what the function is supposed to do should tell you when the function will raise an error
12:38:31 <rwbarton> then in that case, don't call the function
12:40:11 <rwbarton> (If, instead, you don't know what the function is supposed to do, you have bigger problems than this one.)
12:40:52 <lukish> I have some Tree with operators and operands (+,-,/,*) and Integer in nodes
12:41:01 <lukish> So function is Solving that tree
12:41:08 <rwbarton> solving?
12:41:10 <rwbarton> evaluating?
12:41:11 <lukish> And / 0 give me exception
12:41:17 <lukish> Evaluating, right
12:41:22 <rwbarton> Okay
12:41:29 <lukish> I gonna show some code in minutes
12:41:58 <hpaste> lukish pasted “m” at http://hpaste.org/56123
12:42:34 <hpaste> lukish annotated “m” with “m (annotation)” at http://hpaste.org/56123#a56124
12:42:37 <rwbarton> if you're evaluating something that might fail, you should accept this fact and use Maybe or Either like Cale suggested.
12:42:41 <lukish> Fixed
12:43:31 <lukish> rwbarton: so, I should evaluate t2 and if it's equal 0 return Nothing?
12:43:39 <darrint> I don't know if it's me or hackage but it's painfully slow to read docs online today.
12:43:59 <nh2> http://hpaste.org/56122 - I'm getting crazy. InputT derives MonadReader (Settings m), but it is just not there and I cannot even see it in GHCI. Could somebody check in a GHC 7.2 env?
12:44:17 <b_jonas> lukish: yes, so basically you *guard* the division with the condition that t2 is nonzero
12:44:33 <rwbarton> lukish: yes, and then you'll need to modify the other cases to use Maybe Rational rather than Rational
12:44:54 <rwbarton> liftM2 or Applicative would be convenient ways to do this
12:45:07 <lukish> b_jonas: t2 is a tree, it cannot be equal 0
12:45:20 <b_jonas> okay
12:45:48 <lukish> :t liftM2
12:45:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:45:50 <byorgey> nh2: I wonder if you have MonadReader provided by multiple packages, and it is getting it from one different than the one haskeline was compiled with
12:46:13 <nh2> byorgey: how can I find out?
12:47:01 <byorgey> nh2: check to see if you have the monads-tf package installed, ghc-pkg list monads-tf
12:48:13 <nh2> byorgey: nope, not installed
12:48:54 <Duffman-> I'm having trouble understanding something again
12:48:58 <Duffman-> if you look at the type of fmap
12:48:59 <Duffman-> :t fmap
12:49:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:49:12 <byorgey> nh2: check for  mtl  transformers  monads-fd
12:49:13 <Duffman-> we see that it expects a function that takes 1 argument and produces a next one
12:49:34 <b_jonas> Duffman-: correct
12:49:41 <Duffman-> how come this doesn't raise an error
12:49:45 <Duffman-> :t fmap (+) (+3)
12:49:45 <lambdabot> forall a. (Num a) => a -> a -> a
12:50:00 <nh2> byorgey: I have mtl and transformers
12:50:03 <Duffman-> I'd think it would raise an exception because the type of + doesn't fit the type (a->b)
12:50:06 <Duffman-> :t (+)
12:50:07 <lambdabot> forall a. (Num a) => a -> a -> a
12:50:24 <b_jonas> Duffman-: it does, with b ~ (a -> a)
12:50:46 <Duffman-> :|
12:50:54 <byorgey> nh2: which versions?
12:51:16 <nh2> byorgey: transformers-0.2.2.0 and mtl-2.0.1.0
12:51:22 <Duffman-> b_jonas: thx
12:51:31 <byorgey> nh2: and what version of haskeline?
12:51:43 <nh2> byorgey: haskeline-0.6.4.6
12:51:54 <byorgey> HMMM
12:51:57 <byorgey> very strange
12:51:59 <rwbarton> hmmm... in http://hackage.haskell.org/packages/archive/haskeline/0.6.4.6/doc/html/System-Console-Haskeline.html why is only the first instance of MonadState hyperlinked
12:52:17 <lukish> rwbarton: solveTree (Node Add t1 t2) = Just $ (fromJust . solveTree $ t1) + (fromJust . solveTree $ t2)
12:52:21 <rwbarton> um also why are there two identical lines there
12:52:24 <lukish> Am I doing it right?
12:52:25 <rwbarton> lukish: no
12:52:43 <rwbarton> solveTree t1 might be Nothing
12:52:54 <lukish> How can I handle that?
12:53:09 <rwbarton> do you know about monads?
12:53:21 <byorgey> nh2: It looks to me from http://hackage.haskell.org/packages/archive/haskeline/0.6.4.6/doc/html/System-Console-Haskeline.html  like that instance is provided by haskeline
12:53:27 <byorgey> nh2: so I am quite confused
12:53:40 <lukish> rwbarton: a little
12:53:45 <rwbarton> okay
12:53:55 <rwbarton> here you can use the Maybe monad with liftM2
12:54:18 * b_jonas watches wether rwbarton will direct lukish to a solution with or without Applicative
12:54:26 <byorgey> rwbarton: ah, hmm, that is curious
12:54:40 * byorgey goes source-diving
12:54:42 <rwbarton> b_jonas, I picked more or less at random
12:54:53 <nh2> byorgey: yes, when I click source for "data Settings", it shows a "deriving MonadReader (Settings m)"
12:55:09 <nh2> but so far it looks like that is just ignored
12:55:15 <byorgey> what the
12:55:29 <byorgey> nh2: it looks like Haskeline defines its OWN version of MonadReader =(
12:55:40 <byorgey> but it is not exported so you cannot use it.
12:55:43 <byorgey> wtf!!!
12:55:43 <lukish> Anyway, I don't really imagine how can I use liftM2 here
12:55:53 <rwbarton> @type liftM2
12:55:54 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:56:07 <rwbarton> @type liftM2 (+) :: Maybe Rational -> Maybe Rational -> Maybe Rational
12:56:08 <lambdabot> Maybe Rational -> Maybe Rational -> Maybe Rational
12:56:29 <ion> @type liftA2 (+) `asAppliedTo` (undefined :: Maybe Rational)
12:56:29 <lambdabot> Maybe Rational -> Maybe Rational -> Maybe Rational
12:56:30 <nh2> byorgey: you mean in http://hackage.haskell.org/packages/archive/haskeline/0.6.4.6/doc/html/src/System-Console-Haskeline-Monads.html - wtf??
12:56:37 <rwbarton> lukish: let's imagine what you would write straightforwardly
12:56:45 <byorgey> nh2: yep
12:56:49 <nitencasi> i have this code http://dpaste.com/682221/ that is reading an enormous number and add then all but it's giving me a small number. can someone please help me?
12:57:13 <b_jonas> nitencasi: ah, you're back!
12:57:19 <b_jonas> nitencasi: that code has multiple problems
12:57:22 <b_jonas> (to say it nicely)
12:57:30 <nh2> byorgey: oh man that is cruel, this is where 7 hours of my life went ...
12:57:47 <b_jonas> nitencasi: for one, you say let a = ... :: Integer
12:57:51 <lukish> rwbarton: solveTree (Node Add t1 t2) = liftM2 (+) (solveTree t1) (solveTree t2)
12:57:51 <b_jonas> so you get only one integer
12:57:53 <nitencasi> b_jonas, sure i am a beginner in Haskell so it is strongly possible that my code sucks
12:58:04 <b_jonas> aren't you supposed to get a list of integers from the input somehow?
12:58:09 <b_jonas> you're getting just a single integer
12:58:10 <hpaste> rwbarton annotated “m” with “m (annotation) (annotation)” at http://hpaste.org/56123#a56126
12:58:14 <nitencasi> b_jonas, yes
12:58:37 <b_jonas> nitencasi: you should somehow try to read the file into a list of integers
12:59:11 <rwbarton> lukish: yes, that is what I had in mind
12:59:11 <nitencasi> b_jonas, the file has some \n in it
12:59:28 <b_jonas> nitencasi: yep
12:59:44 <lukish> :t on
12:59:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:59:47 <b_jonas> so?
12:59:59 <nitencasi> b_jonas, that wont be read also?
13:00:12 <b_jonas> nitencasi: the newlines will be read, and you need them
13:00:22 <b_jonas> that's how you know where each number ends
13:00:38 <lukish> rwbarton: solveTree (Node Add t1 t2) = liftM2 ((+) `on` solveTree) t1 t2
13:00:41 <tromp> > [n^2|n<-[4,14..94]]
13:00:42 <lambdabot>   [16,196,576,1156,1936,2916,4096,5476,7056,8836]
13:00:42 <lukish> Is that right?
13:00:50 <rwbarton> let me think
13:01:03 <nitencasi> b_jonas, no it's a all number
13:01:04 <rwbarton> not quite I believe
13:01:10 <b_jonas> nitencasi: no it's not
13:01:20 <tromp> > [n^2|n<-[6,16..96]]
13:01:21 <lambdabot>   [36,256,676,1296,2116,3136,4356,5776,7396,9216]
13:01:43 <rwbarton> nitencasi: your problem is not Haskell-related, it's that you've misunderstood what the question is asking you to do
13:01:51 <nitencasi> b_jonas, i think it is. http://projecteuler.net/problem=13
13:01:52 <tromp> > [n^2|n<-[24,124..924]]
13:01:53 <lambdabot>   [576,15376,50176,104976,179776,274576,389376,524176,678976,853776]
13:02:18 <rwbarton> :t liftM2 ((+) `on` ?solveTree)
13:02:19 <lambdabot> forall b a1 (m :: * -> *). (Num b, ?solveTree::a1 -> b, Monad m) => m a1 -> m a1 -> m b
13:02:56 <rwbarton> lukish: what you wrote earlier was correct. then you can think of it like this: solveTree (Node Add t1 t2) = (liftM2 (+)) (solveTree t1) (solveTree t2)
13:03:01 <rwbarton> does that help?
13:03:40 <Botje> nitencasi: you are summing all the digits of the numbers.
13:03:56 <Botje> nitencasi: you should take the sum of all numbers and then the first ten digits of *that*
13:04:27 <nitencasi> Botje,then i have the sum the results?
13:04:31 <Botje> nitencasi: no?
13:04:44 <nitencasi> like a sum all of the numbers
13:05:01 <nitencasi> then the result
13:05:11 <nitencasi> and take the first 10 digits from that?
13:05:29 <b_jonas> wait, so you mean nitencasi speaks a better haskell than he does English?
13:05:31 <Botje> you take the sum of those 100 big numbers
13:05:36 <rwbarton> well that is what "Work out the first ten digits of the sum of the following one-hundred 50-digit numbers" means
13:05:40 <rwbarton> so yes
13:05:44 <Botje> and the first ten digits of that sum is your answer.
13:06:05 <Botje> so take 10 (show (sum (map read (words contents))))
13:06:09 <Botje> or, a bit nicer
13:06:21 <Botje> take 10 . show . sum . map read $ words contents
13:06:25 <lukish> rwbarton: yes
13:07:01 <shachaf> Botje: Surely take 10 . show . sum . map read . words $ contents?
13:07:29 <b_jonas> shachaf: that works too, but Botje's is simpler
13:07:47 <Botje> i generally don't put the argument by itself
13:07:55 <shachaf> I think mine is simpler. You're composing one big function and then applying it.
13:08:06 <shachaf> Why give the last function in the chain special treatment?
13:08:48 <rwbarton> i don't really agree with that argument, but i do agree with the result in this particular case :P
13:08:52 <b_jonas> well, I prefer the parenthesis
13:09:09 <rwbarton> Sometimes the last function is conceptually separate
13:09:25 <shachaf> rwbarton: And sometimes the last two functions are conceptually separate. :-)
13:09:29 <rwbarton> yes!
13:09:39 <shachaf> > (take 10 . show . sum) . (map read . words) $ contents
13:09:40 <lambdabot>   Not in scope: `contents'
13:09:43 <tromp> :t intersect
13:09:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:10:06 <hpaste> lukish annotated “m” with “m (annotation) (annotation)” at http://hpaste.org/56123#a56127
13:10:08 <rwbarton> take 10 . show . sum $ map read . words $ contents
13:10:15 <shachaf> rwbarton: Do parentheses mollify you?
13:10:18 <shachaf> rwbarton: :-(
13:10:19 <lukish> rwbarton: I have exception again
13:10:27 <shachaf> rwbarton: What about infixl $ ?
13:10:39 <tromp> > intrersect [n*n|n<-[1..]] [l*(l+1)`div`2| l<-[1..]]
13:10:40 <lambdabot>   Not in scope: `intrersect'
13:10:44 <rwbarton> infixl $ is an abomination
13:10:45 <tromp> > intersect [n*n|n<-[1..]] [l*(l+1)`div`2| l<-[1..]]
13:10:49 <lambdabot>   mueval-core: Time limit exceeded
13:10:56 <shachaf> rwbarton: What! Why?
13:10:58 <rwbarton> (not really, but I figure that absurd hyperbole is expected in this context)
13:11:22 <rwbarton> because it prevents me from expressing my intent easily in this situation
13:11:47 <rwbarton> also because when I write map words $ ... and now I'm typing the ... I shouldn't have to have thought about whether it has a $ in it
13:11:51 <shachaf> rwbarton: Just use . to express your intent.
13:11:54 <rwbarton> I think this a huge point that no one ever considers
13:11:58 <shachaf> rwbarton: That second argument, though, I buy.
13:12:03 <shachaf> Mainly because I've made it several times.
13:12:05 <b_jonas> tromp: intersect doesn't work on two infinite lists
13:12:18 <rwbarton> Okay, well, I seem to have a pattern of agreeing with you on things. :)
13:12:19 <b_jonas> or does it? I dunno
13:12:25 <tromp> i realize now. have to write my own for sorted lists
13:12:28 <rwbarton> I haven't heard this point made before
13:12:34 <shachaf> I have IRC logs to prove it!
13:12:48 <b_jonas> tromp: I think it's possible to write a general one that works for any infinite lists, maybe
13:12:55 <b_jonas> but it's probably better to write one for sorted lists
13:13:04 <b_jonas> or, in this case, you can just use some other solution
13:13:21 <nexion> I'm looking for a lib that would generate session IDs which need to be unpredictable and guaranteed (or almost guaranteed) unique.. is there something like that already?
13:13:32 <b_jonas> like, checking membership in either of those sets with a direct computation
13:13:51 <rwbarton> the first point follows from the second, to some extent, if I think of several functions as applying as a unit then I will write f . g . h $, now when I what follows is of a different nature, it's separated by $
13:14:02 <rwbarton> hmm, editing failure
13:14:28 <shachaf> rwbarton: However, I do also appreciate Cale's arguments about infixl $ letting you reduce parentheses.
13:14:52 <rwbarton> what's an example for that?
13:15:01 <shachaf> It puts me in a dilemmic position which I get out of by arguing against whatever position someone else is arguing for.
13:15:12 <shachaf> f x $ g y $ h z
13:15:25 <rwbarton> instead of f x (g y) h z
13:15:36 <rwbarton> wait
13:15:39 <rwbarton> instead of f x (g y) (h z)
13:15:45 <shachaf> Right.
13:15:59 <shachaf> Well, the (h z) there could be eliminated with infixr $
13:16:04 <shachaf> But they (g y) couldn't.
13:16:23 <dolio> It also sets the precedent for infixl $!
13:16:29 <shachaf> That too.
13:16:30 <dolio> f $! x $! y
13:16:36 <rwbarton> well I find it hard to read (as you can see), but that's no doubt due to being used to the status quo
13:16:38 <dolio> Instead of (f $! x) $! y
13:17:11 <lukish> rwbarton: what should I add http://hpaste.org/56123 to avoid zero denominator case?
13:17:34 <shachaf> rwbarton: I'm ambivalent about it.
13:17:36 <rwbarton> lukish: well, some logic to deal with that case
13:17:58 <shachaf> I don't much like the thing where you can say either "f . g . h $ x" or "f $ g $ h $ x".
13:18:14 <lukish> solveTree (Node Div t1 t2) | (denominator . fromJust . solveTree $ t1) == 0 = Nothing | otherwise = liftM2 (/) (solveTree t1) (solveTree t2)
13:18:17 <lukish> I do that
13:18:21 <rwbarton> not denominator
13:18:27 <lukish> And get zero denominator again
13:18:30 <rwbarton> also not fromJust
13:18:49 <rwbarton> also not t1!
13:18:54 <lukish> Lol
13:18:57 <rwbarton> :)
13:19:18 <lukish> Okay, from t2.
13:19:29 <rwbarton> do syntax could be useful here.
13:19:45 <lukish> And it's time for some liftM again or what?
13:19:51 <b_jonas> what rwbarton says
13:19:55 <rwbarton> or define a function to use in place of liftM2 (/)
13:20:07 <rwbarton> divide _ (Just 0) = Nothing; divide x y = liftM2 (/) x y
13:20:14 <shachaf> rwbarton: Another, possibly simpler, example which Cale seems to have brought up is "f . g $ x $ y"
13:20:19 <rwbarton> though that strikes me as a bit odd
13:20:40 <rwbarton> what is this...
13:20:42 <rwbarton> f (g x) y?
13:20:48 <dolio> (f . g) x y
13:20:49 <rwbarton> that's terrible
13:20:50 <shachaf> (f . g) x y
13:20:54 <shachaf> That's not terrible.
13:21:03 <shachaf> It doesn't have to be (.)
13:21:11 <shachaf> blah `op` blah $ x $ y
13:21:17 <rwbarton> it might not be terrible if I wasn't thinking about f as a two-argument function
13:21:35 <rwbarton> with `op` it looks okay, yes
13:21:39 <shachaf> Hmm, I guess (f . g) x y *is* f (g x) y
13:21:46 <shachaf> <shachaf> Cale: I like to think, when I use $, that now whatever's on the left will be applied to whatever I type on the right.
13:21:53 <b_jonas> solveTree (Node Div t1 t2) = solveTree t2 >>= (\y -> guard (0 /= y) >> solveTree t1 / y)
13:21:54 <shachaf> Now that I reread that, I put it much more confusingly than you did.
13:21:56 <b_jonas> how about that?
13:22:01 <shachaf> But that's what I had in mind.
13:22:05 <rwbarton> Really this isn't infixl $ being terrible as much as writing f . g in this situation is terrible.
13:22:20 <rwbarton> Also, I can't grammar today.
13:22:33 <shachaf>  <shachaf> dcoutts_: Well... I like, in ghci, how I can have any expression at all, and do something like add "concat $" to the beginning of it, without worrying about it.
13:22:51 * shachaf is satisfied that he didn't just make this up.
13:22:57 <rwbarton> maybe we just need a new ($)-replacement that's infixl
13:23:18 <Botje> call it €.
13:23:22 <rwbarton> > let (€) -- damn you
13:23:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:23:29 <shachaf> rwbarton: Right. We can call it $
13:24:13 <rwbarton> I hope that is some goofy unicode character.
13:24:18 <shachaf> The simplest argument for infixl $ might be that regular application is the highest-precedence operation, and $ is its lowest-precedence counterpart.
13:24:33 <SolarNRG> I just had sex
13:24:36 <SolarNRG> And I had a tit wank
13:24:38 <SolarNRG> It was very nice
13:24:40 <hpaste> lukish annotated “m” with “m (annotation) (annotation) (annotation)” at http://hpaste.org/56123#a56128
13:24:41 <SolarNRG> Thought you should know
13:24:45 <rwbarton> > let f ᙚ x = f x in sin ᙚ 3
13:24:46 <lambdabot>   Not in scope: `
13:24:47 <SolarNRG> Now my gf is having a bath to wash off the cum
13:24:52 <shachaf> rwbarton: What's the code point?
13:24:54 <dolio> @where ops
13:24:54 <lukish> rwbarton: seems working now
13:24:54 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:25:12 <rwbarton> that one?
13:25:16 * shachaf doesn't have Unicode working completely.
13:25:28 <rwbarton> U+165A
13:25:30 <rwbarton> Neither do I
13:25:55 <rwbarton> unfortunately it's a letter
13:25:57 <shachaf> In particular, only code points <= 127 work.
13:25:58 --- mode: ChanServ set +o copumpkin
13:26:02 --- mode: copumpkin set +b *!SolarNRG@94-195-174-233.zone9.bethere.co.uk
13:26:02 --- kick: SolarNRG was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
13:26:08 --- mode: copumpkin set -o copumpkin
13:26:18 <shachaf> copumpkin++
13:27:22 <rwbarton> > "\x5a"
13:27:23 <lambdabot>   "Z"
13:28:11 <b_jonas> the yen sign?
13:28:19 <b_jonas> no wait, that's for zip
13:28:23 <rwbarton> lukish: that works, but...
13:28:35 <parcs`> > "\x0"
13:28:36 <lambdabot>   "\NUL"
13:28:49 <rwbarton> well first, you should just use | solveTree t2 == Just 0 = Nothing
13:28:51 <parcs`> > chr 80
13:28:52 <lambdabot>   'P'
13:28:56 <parcs`> > chr 90
13:28:57 <lambdabot>   'Z'
13:29:11 <rwbarton> and also, you potentially call solveTree t2 three times, not sure whether GHC will share those results.
13:29:40 <mauke> > '\80'
13:29:41 <lambdabot>   'P'
13:30:04 <parcs`> > read "\80" :: Char
13:30:04 <lambdabot>   *Exception: Prelude.read: no parse
13:30:18 <parcs`> > read "'\80'" :: Char
13:30:19 <lambdabot>   'P'
13:30:37 <mauke> > "'\80'"
13:30:38 <lambdabot>   "'P'"
13:30:47 <mauke> > read "'P'" :: Char
13:30:48 <lambdabot>   'P'
13:30:53 <parcs`> > read "'\\80'" :: Char
13:30:54 <lambdabot>   'P'
13:32:03 <parcs`> > let ord n = read ("\"'\\\\" ++ show n ++ "'\"") in ord 80
13:32:05 <lambdabot>   *Exception: Prelude.read: no parse
13:32:19 <b_jonas> rwbarton: could you avoid that like this? solveTree (Node Div t1 t2) | y -> Nothing = Nothing | y -> Just v = liftM (/v) (solveTree t2) where y = solveTree y
13:32:41 <rwbarton> yes, aside from a couple typos there
13:32:49 <b_jonas> rwbarton: if that doesn't work, there's still the do solution I typed above
13:33:00 <b_jonas> solveTree (Node Div t1 t2) = solveTree t2 >>= (\y -> guard (0 /= y) >> solveTree t1 / y)
13:33:11 <rwbarton> right, this is what I would be inclined to actually do
13:35:08 <b_jonas> is it possible to do that with just an applicative?
13:35:57 <rwbarton> shachaf: I think really the situation here is that it will/should never change because the costs would greatly outweigh the benefits (in either direction, regardless of which version you think is better in vacuum)
13:36:09 <rwbarton> due not even so much to breaking code as breaking people
13:36:40 <parcs`> > let ord n = read $ read ("\"'\\\\\\\\" ++ show n ++ "'\"") in ord 80 :: Char
13:36:41 <lambdabot>   *Exception: Prelude.read: no parse
13:36:46 <b_jonas> rwbarton: we could introduce a new operator, but it would need to have a longer name
13:36:53 <b_jonas> -$ or something
13:36:55 <rwbarton> Longer?
13:37:00 <b_jonas> longer than $
13:37:04 <rwbarton> I see
13:37:05 <b_jonas> because that's just one character
13:37:11 <rwbarton> well, there are still some other one-character names free
13:37:18 <rwbarton> @hoogle (&)
13:37:18 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
13:37:18 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
13:37:18 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
13:38:05 <b_jonas> rwbarton: aren't all those used for various ghc syntax extensions?
13:38:26 <rwbarton> I don't know of anything that uses &
13:38:30 <rwbarton> # is used yes
13:38:37 <b_jonas> and ? is used as well
13:38:43 <rwbarton> > let f # x = f x in sin # 3
13:38:43 <lambdabot>   0.1411200080598672
13:38:48 <rwbarton> > let f # x = f x in (#) sin 3
13:38:49 <lambdabot>   <no location info>: parse error on input `)'
13:39:01 <rwbarton> of course there would never be a reason to choose (#) over ($)
13:39:32 <rwbarton> might have (# x # y) I guess
13:39:38 <b_jonas> > let f # x = f x in ( # ) sin 3
13:39:39 <lambdabot>   0.1411200080598672
13:39:43 <rwbarton> yep, that works
13:39:51 <rwbarton> but slightly ugly to have to do that
13:39:55 <b_jonas> > let f ? x = f x in sin ? 3
13:39:55 <lambdabot>   0.1411200080598672
13:40:08 <rwbarton> @hoogle (%)
13:40:08 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
13:40:11 <rwbarton> oh yeah
13:40:12 <b_jonas> > let { f ? x = f x; z = 3 } in sin ? z
13:40:13 <lambdabot>   0.1411200080598672
13:40:22 <b_jonas> > let { f ? x = f x; z = 3 } in sin ?z
13:40:23 <lambdabot>   mueval-core: internal error: PAP object entered!
13:40:23 <lambdabot>      (GHC version 6.12.3 f...
13:41:02 <rwbarton> @type let f # x = f x; infixl 0 # in ( # ?a # ?b)
13:41:03 <lambdabot>     The operator `#' [infixl 0] of a section
13:41:03 <lambdabot>         must have lower precedence than that of the operand,
13:41:03 <lambdabot>           namely `#' [infixl 0]
13:41:07 <shachaf> rwbarton: Oh, I don't disagree with *that*.
13:41:15 <rwbarton> @type let f # x = f x; infixr 0 # in ( # ?a # ?b)
13:41:16 <lambdabot> forall t t1 t2. (?b::t2, ?a::t2 -> t) => (t -> t1) -> t1
13:41:19 <shachaf> rwbarton: And, as you said, there are points in favour of infixr $
13:41:39 <rwbarton> I think even adding a new infixl-ized ($) is questionable
13:41:41 <b_jonas> what fixity does `id` have again?
13:41:48 <hpc> shachaf: is that a section? im confused
13:41:59 <rostayob> the default is infixr 3, right?
13:42:07 <hpc> rostayob: thought it was 5
13:42:09 <shachaf> rwbarton: Using one of our valuable US-keyboard-layout symbols for that?
13:42:13 <shachaf> I also agree.
13:42:16 <hpc> foo `bar` baz == quux
13:42:18 <hpc> > foo `bar` baz == quux
13:42:19 <lambdabot>   Not in scope: `foo'Not in scope: `baz'Not in scope: `bar'Not in scope: `quux'
13:42:24 <parcs`> b_jonas: infixl 9
13:42:34 <rwbarton> I was more thinking that 90% of the time it just gives you yet another way to write "f x"
13:42:35 <lukish> @hoogle IO Integer
13:42:36 <lambdabot> Did you mean: :: IO Integer
13:42:36 <lambdabot> No results found
13:42:36 <hpc> > x `f` y == z :: Expr
13:42:36 <b_jonas> heh, three different answers
13:42:37 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:42:37 <lambdabot>         against inferred ...
13:42:40 <rostayob> hpc: mhm maybe i'm confusing haskell and sml
13:42:45 <hpc> argh
13:42:50 <shachaf> rwbarton: What about $! ?
13:42:51 <rwbarton> and it's more to learn for newcomers
13:42:57 <parcs`> all backquote operators have a fixity of infixl 9 by default
13:43:06 <shachaf> rwbarton: I think newcomers overuse $ way too much.
13:43:09 <lukish> I can read string with getLine. How can I read Integer?
13:43:19 <parcs`> lukish: fmap read getLine
13:43:23 <shachaf> lukish: Read a String and then get an Integer from it.
13:43:34 <rwbarton> well maybe, I was thinking about learning to read code though
13:43:37 <lukish> :t fmap read getLine
13:43:37 <lambdabot> forall a. (Read a) => IO a
13:43:55 <shachaf> I wonder if ($!) should actually be prefix.
13:44:02 <shachaf> As in "strictify f"
13:44:05 <parcs`> lukish: or do { s <- getLine; return (read s :: Int) }
13:45:10 <rwbarton> @src readLn
13:45:10 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
13:45:32 <parcs`> @hoogle readLn
13:45:32 <lambdabot> Prelude readLn :: Read a => IO a
13:45:32 <lambdabot> System.IO readLn :: Read a => IO a
13:45:35 <parcs`> cool
13:45:37 <hpc> oooooh
13:45:56 <shachaf> readLn will throw an IO exception if it fails to read, I think.
13:45:59 <shachaf> It's kind of silly.
13:46:13 <shachaf> @src readLn
13:46:13 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
13:46:18 <b_jonas> shachaf: why's that silly?
13:46:23 <lukish> What should I define to printing [Tree Integer] in main?
13:46:27 <rwbarton> I would have thought that #haskellers would love that
13:46:32 <shachaf> Well, why would it be an IO exception?
13:46:37 <shachaf> rwbarton: Why?
13:46:44 <lukish> I have instance (Show a) => Show (Tree a) where
13:46:48 <lukish> isn't it enouhg?
13:46:52 <rwbarton> rather than having readLn return a value that could cause a pure function to raise an exception based on the contents of a file!! (OMG!)
13:47:09 <parcs`> lukish: yes
13:47:11 <shachaf> rwbarton: I think #haskellers would rather just use Maybe.
13:47:20 <rwbarton> oh, well, fair enough
13:47:30 <rwbarton> given the type of readLn, though
13:47:33 <lukish> parcs`: what else?
13:47:54 <shachaf> Given the type of readLn, sure.
13:47:56 <parcs`> lukish: the application of a value of that type with 'print'
13:48:05 <mdmkolbe> Are there any other varients in the MVar/IORef family other than those two that I should know about?
13:48:06 <monochrom> read, reads, readIO, and readLn were conceived a long time ago, and definitely not by most of #haskell people, and even #haskell probably didn't exist back then
13:48:09 <shachaf> But I think it's kind of a silly place to compromise.
13:48:09 <rwbarton> as opposed to fmap read getLine
13:49:05 <monochrom> it's like saying "why doesn't C provide GC? I thought most of ##javaers prefer GC"
13:49:05 <rostayob> mdmkolbe: TMVar?
13:49:09 <shachaf> If you're already granting that reading might fail -- which, if you care about the type of exception that's thrown, I imagine you are -- then IO exceptions seem like an odd way to do it.
13:49:30 <mercury^> Has someone worked out what algebras for some of the common Haskell monads are?
13:49:41 <parcs`> mdmkolbe: see Control.Concurrent.* at http://hackage.haskell.org/package/base and http://hackage.haskell.org/package/stm
13:49:57 <monochrom> shachaf, do you have a time machine, that could bring you back to 1997 or before? you could confront the haskell committee back then, you know
13:51:11 <shachaf> monochrom: Good point.
13:51:30 <monochrom> and move hierarachical modules one decade earlier, and eliminate n+k patterns one decade earlier, why you're at it
13:51:56 <rwbarton> in some cases raising an IO exception because you misparsed something is reasonable
13:52:06 <b_jonas> what's so important in moving hierarchical modules earlier?
13:52:09 <rwbarton> the problem is that the alternative is not provided
13:52:15 <rwbarton> or not made as convenient
13:52:27 <b_jonas> I can see the point of eliminating n+k patterns, but hierarchical modules were fine as just a language extension
13:52:40 <b_jonas> it's not worth to use a time machine for
13:53:03 <b_jonas> go talk with Franklin about the electron charge stuff instead
13:53:08 <ben> I'm surprised n+k patterns were removed rather than generalised in the style of ViewPatterns
13:53:08 <monochrom> no importance is implied. just picking out Haskell 2010 features
13:53:55 * monochrom would prefer to influence ancient Greeks to write right-to-left
13:54:15 <b_jonas> monochrom: what? why?
13:54:19 <b_jonas> isn't left to right better?
13:54:31 <monochrom> I am Chinese and right-to-left is better!
13:54:32 <b_jonas> besides, wouldn't you have to go back further, to the Phoenicians
13:54:52 <rwbarton> I think the Phoenicians did write right-to-left
13:55:11 <rwbarton> and the Greeks used both for a while
13:55:15 <b_jonas> hmm, you're right
13:55:16 <b_jonas> sorry
13:55:27 <mdmkolbe> monochrom: isn't left to right is better for right handed people b/c you don't smear the ink with your hand and you can see what you just wrote
13:55:58 <monochrom> hehe
13:56:12 <b_jonas> mah, just invent pencils and good biros earlier if you don't want to smear the ink
13:56:23 <b_jonas> but seeing what you wrote is an important point
13:59:02 <monochrom> it's why we Chinese wrote top-to-bottom in the inner loop
13:59:26 <b_jonas> monochrom: that might help, yes
13:59:49 <monochrom> though you could arge that the outer loop should still be left-to-right for maximum visibility
14:01:20 <b_jonas> I guess column-major (top-to-bottom) writing has the advantage that you can review more lines of code on a landscape widescreen monitor
14:01:27 <rwbarton> if you are right-handed then the right side of the paper is easiest to reach, so you should try to mostly use the right side when possible
14:01:33 <monochrom> anyway I support read :: (Read a) => String -> Maybe a but don't try to ask why Haskell 98 did different. 1998, that's the answer, ok?
14:02:02 <monochrom> retrospective wisdom is retrospective
14:02:24 <monochrom> those who have not learned from the future are bound to trip over it
14:02:26 <c_wraith> I still think the structure of Show, and the hack it required to work properly with strings, is a good indication that type String = [Char] probably wasn't the best idea
14:06:39 * hackagebot timeparsers 0.3 - Attoparsec parsers for various Date/Time formats.  http://hackage.haskell.org/package/timeparsers-0.3 (NathanHunter)
14:13:53 <tgeeky> weird...
14:13:59 <tgeeky> > 2 + 2
14:14:00 <lambdabot>   4
14:53:19 <poops> hi
15:06:38 <xplat> is there a binary version of 'show', that is, 11 |-> "1011" ?
15:07:05 <xplat> there used to be NumExts.showBin back in the dark ages, but who knows where that's gone ...
15:07:16 <mokus> i think there's something for that in the Numeric module
15:07:25 <mokus> showAtBase or something
15:08:16 <c_wraith> @hoogle Int -> Int -> ShowS
15:08:17 <lambdabot> Prelude showsPrec :: Show a => Int -> a -> ShowS
15:08:17 <lambdabot> Text.Show showsPrec :: Show a => Int -> a -> ShowS
15:08:17 <lambdabot> Numeric showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
15:08:39 <c_wraith> @hoogle showIntegralAtBase
15:08:39 <lambdabot> No results found
15:08:43 <c_wraith> @hoogle showAtBase
15:08:44 <lambdabot> No results found
15:08:47 <c_wraith> bah
15:08:52 <mokus> Numeric.showIntAtBase
15:09:14 <mokus> args are the base, a digit-to-char function, and the number
15:09:18 <mokus> result is a ShowS
15:10:05 <nolrai> @hi
15:10:06 <mokus> > showIntAtBase 2 (head.show) 11 ""
15:10:08 <lambdabot>   "1011"
15:11:30 <nolrai> @hoogle (A,B) -> (A -> C) -> (B -> D) -> (C,D)
15:11:31 <lambdabot> Warning: Unknown type D
15:11:31 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:12:28 <nolrai> hmm. I don't think thats what I want.
15:12:54 <MostAwesomeDude> @hoogle (a,b) -> (a -> c) -> (b -> d) -> (c,d)
15:12:54 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:13:02 <MostAwesomeDude> Hm, I guess the caps didn't matter.
15:13:33 <MostAwesomeDude> I think there's an arrow for what you want, but I haven't really dug into arrows yet.
15:13:57 <mokus> :t (***)
15:13:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:14:14 <nolrai> Thats it!
15:14:25 <nolrai> thanks!
15:14:28 <mokus> i guess hoogle wasn't smart enough to try a = (->)
15:14:30 <mokus> np
15:14:43 <DanBurton> :t let foo :: a -> b; foo = undefined in (***) `asAppliedTo` foo
15:14:43 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
15:14:52 <MostAwesomeDude> Are there arrow tutorials?
15:16:24 <parcs`> the seminal paper on arrows
15:16:40 <MostAwesomeDude> @where arrows
15:16:40 <lambdabot> http://www.haskell.org/arrows/
15:16:44 <MostAwesomeDude> ^^ ?
15:17:23 <parcs`> http://www.haskell.org/arrows/biblio.html#Hug00
15:18:21 <nolrai> @pl f (a,b) (x,y) = (a+x,b+y)
15:18:21 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
15:19:19 <nolrai> hmm...that seems somewhat more pathological then usual for pointless.
15:19:44 <nolrai> :t flip flip
15:19:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
15:19:46 <DanBurton> s/lambdabot/trollbot
15:20:17 <c_wraith> nolrai: isn't that just (+) *** (+)
15:20:22 <nolrai> :t flip flip fst
15:20:23 <lambdabot> forall (f :: * -> *) b a b1. (Functor f) => f (((a, b1) -> a) -> b) -> f b
15:20:32 <c_wraith> :t (+) *** (+)
15:20:33 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
15:20:43 <c_wraith> oh, no, it's not
15:20:48 <DanBurton> :t (+) *** (+)
15:20:49 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
15:20:49 <c_wraith> it's half of it
15:21:08 <c_wraith> would need some sort of "apply tuple" to get the other half
15:21:44 <c_wraith> @pl \(x, y) = (+x) *** (+y)
15:21:44 <lambdabot> (line 1, column 9):
15:21:44 <lambdabot> unexpected "="
15:21:44 <lambdabot> expecting operator, pattern or "->"
15:21:52 <c_wraith> @pl \(x, y) -> (+x) *** (+y)
15:21:53 <lambdabot> uncurry ((. (+)) . (***) . (+))
15:22:03 <c_wraith> that's totally obvious
15:22:08 <DanBurton> ....ugh
15:22:35 <nolrai> Yeah I don't think I am going to use that. >.<
15:22:37 <MostAwesomeDude> It looks like a Tron lightcycle.
15:22:47 <parcs`> isn't that bimap or something
15:22:50 <parcs`> @hoogle bimap
15:22:50 <lambdabot> package bimap
15:23:14 <shachaf> c_wraith: Well, I mean, if you don't expect lambdabot to discover the use of (***) for one tuple, why do you expect lambdabot to simplify the other tuple?
15:23:40 <nolrai> Is there a good name for the list [-1,0,1]?
15:23:50 <shachaf> nolrai: [-1,0,1] is a pretty good name.
15:23:55 <c_wraith> nolrai: balanced ternary digits?
15:23:56 <shachaf> It's short and shows exactly what it is.
15:24:02 <parcs`> @oeis -1 0 1
15:24:03 <DanBurton> > let tupFunc f (x, y) (x', y') = (f x x', f y y') in tupFunc (+) (2,3) (7,8)
15:24:04 <lambdabot>   (9,11)
15:24:17 <lambdabot> Plugin `oeis' failed with: thread killed
15:24:32 <nolrai> Yes it is. Looked longer in my head.
15:24:38 <DanBurton> :t let tupFunc f (x, y) (x', y') = (f x x', f y y') in tupFunc
15:24:39 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
15:25:26 <parcs`> uncurry ((<<.>>) `on` (+))
15:25:41 <DanBurton> @hoogle a t (a t1 t2) -> (t, t) -> (t1, t1) -> (t2, t2)
15:25:41 <lambdabot> No results found
15:25:41 <hoqhuuep> Hi folks! In LYAH chapter 9 it says "So the taint of impurity spreads around much like the undead scourge and it's in our best interest to keep the I/O parts of our code as small as possible." ...
15:25:58 <shachaf> hoqhuuep: That sentence gives me a bad feeling about that chapter.
15:25:58 <nolrai> Yes?
15:26:01 <shachaf> (Not that I've read it.)
15:26:38 <DanBurton> LYAH is typically pretty clear and newb-friendly
15:27:05 <DanBurton> hoqhuuep: what about it?
15:27:16 <hoqhuuep> ... does this mean that "putSrtLn $ unlines $map show [1..10]" is preferable over "forM [1..10] print" because the text formatting and loop is done with pure code?
15:27:19 <shachaf> So people claim.
15:27:33 <shachaf> hoqhuuep: Not necessarily.
15:27:34 <DanBurton> LYAH was my first Haskell book, and it didn't screw me up too bad
15:27:35 <hoqhuuep> sorrt "forM [1..10] print"
15:27:39 <shachaf> hoqhuuep: Note that those two are completely different.
15:27:55 <shachaf> DanBurton: I don't think one is qualified to make that judgement about oneself. :-)
15:28:09 <DanBurton> shachaf: xD
15:28:27 <shachaf> hoqhuuep: I would worry about the difference between those two in the same way I'd worry in your average imperative language.
15:28:32 <shachaf> Well, not quite, because of laziness.
15:28:51 <shachaf> Anyway, remember: Dogma is always bad.
15:28:53 <shachaf> Always.
15:28:59 <hoqhuuep> Sorry, how are they completely different? They both print 1 to 10 line by line...
15:29:03 <saati> Dogma is a quite good film
15:29:13 <DanBurton> "Dogma is always bad"...isn't that a Dogma in and of itself though?
15:29:16 <parcs`> with the bifunctors package: "uncurry (bimap `on` (+)) :: (Num b, Bifunctor p) => (b, b) -> p b b -> p b b"
15:29:31 <shachaf> DanBurton: Oh, no, you've trapped me in a self-contradiction!
15:29:41 <MostAwesomeDude> Only Sith deal in absolutes!
15:29:45 <DanBurton> shachaf: the sentence does not highly recommend itself
15:29:57 <shachaf> hoqhuuep: One of them generates a whole string and then prints it; the other one prints one line at a time.
15:30:17 <shachaf> DanBurton: The sentence is a joke. Jokes rarely do.
15:30:49 <DanBurton> sometimes jokes in black-and-white text go "whoosh" over my head :)
15:31:22 <hoqhuuep> So you suggest that which is preferable would be determined by the contect perhaps? Rather than just the one which does less with impure code is better?
15:31:36 <hoqhuuep> s/contect/context
15:31:37 <shachaf> hoqhuuep: Yes, use your good judgment.
15:31:43 * hackagebot timeparsers 0.3.1 - Attoparsec parsers for various Date/Time formats.  http://hackage.haskell.org/package/timeparsers-0.3.1 (NathanHunter)
15:32:25 <hoqhuuep> With only 1 week of Haskell experience I don't think I posess "good judgement" yet ;-) ... I guess it will come with time...
15:32:34 <DanBurton> hoqhuuep: the reason LYAH compares IO to a "taint" is not because it is "bad", but rather, because it is contageous and "inescapable"
15:32:46 <shachaf> I wish people didn't say that about IO.
15:33:01 <shachaf> Even if it's technically justifiable.
15:33:17 <hoqhuuep> DanBurton, Because pure code cannot call impure code, right?
15:33:34 <shachaf> hoqhuuep: There's no such thing as "calling" impure code, exactly.
15:33:42 <shachaf> I mean, the short answer to your question is "yes".
15:33:49 <DanBurton> right-ish
15:34:03 <shachaf> But you should just go read about how IO works.
15:34:35 <DanBurton> the cool thing about Haskell is that you don't "call" IO code. Instead you "compose" IO actions, and you designate a particular composition of IO actions as the "main" program
15:34:39 <hoqhuuep> yeah, that whole thing about it returning an IO action which does what you want it to do rather than actually doing it?
15:37:31 <hoqhuuep> Anyhoo, thanks for letting me bounce my thoughts off you... I'll get back to reading... I'm sure it'll become clearer with time :)
15:37:48 <shachaf> hoqhuuep: Another introduction to IO is entitled "Introduction to IO"
15:37:51 <shachaf> @google introduction to io
15:37:53 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
15:37:53 <lambdabot> Title: Introduction to IO - HaskellWiki
15:38:20 <hoqhuuep> Thanks, I'll check it out
15:38:49 <DanBurton> hoqhuuep: the best way to learn Haskell is to play. Just mess around and try stuff; don't worry too much about what's "best" or "fastest" or "optimal" until you have a decent grasp on "composing" stuff
15:39:32 <DanBurton> although it is sort of a fun game to try and keep IO stuff as small as possible
15:39:55 <c_wraith> honestly, keeping IO stuff small is good for playing in ghci anyway
15:40:18 <shachaf> That is true.
15:40:22 <shachaf> In some cases, anyway.
15:40:32 <DanBurton> Rule #1 of Haskell: play.
15:40:33 <shachaf> Certainly "String" is a nicer type than "IO ()"
15:41:43 <shachaf> However, foos :: [String] is also probably a nicer type than unlines foos :: String.
15:52:39 <xplat> wow, that took some actual computation
15:55:55 <DanBurton> question from #scala - "what is CoState"?
15:56:59 <rostayob> DanBurton: I don't think we even have costate, not even in category-extras
15:57:06 <ddarius> Probably the CoState comonad.
15:57:11 <parcs`> DanBurton: http://hackage.haskell.org/packages/archive/comonad-transformers/2.0.2/doc/html/Control-Comonad-Trans-Store-Lazy.html
15:59:07 <DanBurton> doesn't edwardk have a post explaining the Store comonad somewhere?
16:03:39 <dee_> @type id
16:03:39 <lambdabot> forall a. a -> a
16:09:20 <roconnor> did someone say Store comonad?
16:11:05 <rostayob> roconnor: they did
16:11:45 <rostayob> and i've been stuck in comonad-transformers since
16:12:30 <rostayob> btw, are there any articles on nice use cases for Comonads?
16:12:37 <roconnor> rostayob: it's easy to get out of a comonad,  Use extract
16:12:43 <rostayob> roconnor:  :)
16:12:54 <roconnor> rostayob: they are great for cellular automata
16:13:11 <roconnor> or anything vaugely like a cellular automata
16:13:30 <rostayob> roconnor: something more concrete? like the little Maybe or [] example for Monad
16:13:36 <jjg> anyone familiar with parsec?
16:13:41 <rostayob> jjg: yes!
16:14:00 <jjg> i've got a simple parser that is succeeding when I want it to fail
16:14:07 <jjg> liftM (Integer . read) $ many1 digit
16:14:27 <jjg> "1 + 1" is currently parsing into Integer 1 successfully
16:14:37 <roconnor> rostayob: For Stream a, extract = head and duplicate = tails
16:14:38 <rostayob> first, you probably don't need that Integer
16:14:40 <rostayob> anyways
16:14:42 <jjg> but it doesn't consume all input, and I'm wondering why it won't fail
16:14:57 <rostayob> jjg: well because a parser can succeed while not consuming all input
16:15:06 <rostayob> you can check that you're at the end of the input with "eof"
16:15:11 <jjg> hmmm... i don't want it to
16:15:15 <rostayob> liftM (Integer . read) (many1 digit <* eof)
16:15:57 <jjg> in my little language I only want eof to occur after an Let binding
16:15:58 <rostayob> roconnor: yeah but those examples are not that nice, since they involve partial functions
16:16:09 <roconnor> rostayob: they are total with Stream a
16:16:48 <rostayob> roconnor: Stream a = Cons a (Stream a) | ?
16:17:03 <roconnor> Stream a = Cons a (Stream a)
16:17:15 <rostayob> jjg: well... then why would that with "1 + 1" fail?
16:17:19 <rostayob> roconnor: oh, ok.
16:17:38 <rostayob> still that's not something that I'd use even remotely often
16:18:08 <rostayob> is the concept of comonad useful in day to day programming as monads are?
16:18:13 <roconnor> rostayob: more generally for any monoid o, o -> a is a monoid where extract f = f mempty and duplicate f = \a b -> f (a `mappend` b)
16:18:14 <jjg> rostayob: well.. I'm writing unit tests for small segments of the language, which means not every unit test has a let binding
16:18:19 <roconnor> *is a comonad
16:18:32 <roconnor> rostayob: not as useful, but still useful.
16:18:38 <rostayob> jjg: ok, then check for the leftover to be empty manually and fail the test if it isn't
16:19:05 <rostayob> roconnor: you mean 'o -> a is a comonad'
16:19:06 <jjg> rostayob: I'll figure something out for this, I just thought parsec was supposed to parse the entirety of the input, thanks
16:19:08 <roconnor> rostayob: in some sense there are more monads than comonads because every monad has a corresponding comonad, but not vice versa.
16:19:23 <rostayob> jjg: parsec parses what it can and returns the leftover
16:19:57 <roconnor> rostayob: ya, 'o -> a' is a comonad I meant. it is the tracer comonad
16:19:59 <rostayob> roconnor: i think you mean the opposite
16:20:07 <rostayob> not all monads have duals
16:20:14 <rostayob> and that's why there are more monads
16:20:31 <roconnor> er right
16:20:31 <rostayob> (otherwise your observation doesn't make sense. also, IO)
16:20:37 <roconnor> every comonad has a corresponding monad
16:20:40 <rostayob> yeah
16:20:45 <roconnor> sorry
16:21:17 <rostayob> mh. i'll be waiting for a moment in which i can say "hah! this is a comonad"
16:21:45 <mike-burns> Comonads are useful for larger patterns, like traffic flow analysis or game of life?
16:21:50 <roconnor> rostayob: there is the (b,) comonad.  where extract = snd and duplicate (b,a) = (b,(b,a))
16:22:05 <rostayob> roconnor: yes but, is that useful?
16:22:26 <roconnor> rostayob: it is exactly as useful as the reader monad
16:23:24 <rostayob> mhm?
16:23:40 <rostayob> apart from a nice similarity with the writer monad i don't see how that is a reader monad
16:24:09 <rostayob> (how forall a. (b, a) is a reader monad with b as thing to be read)
16:24:21 <roconnor> Kleisli (b ->)  (the reader monad) is isomorphic to CoKleisli (b,)
16:24:44 <roconnor> Kleisli (b ->) x y  ~~ x -> b -> y
16:24:49 <singpolyma> is there a good / common way to abstract code like this: http://pastie.org/3134890
16:24:55 <roconnor> CoKleisli (b,) x y ~~ (b,x) -> y
16:25:02 <rostayob> oh, right. the currying
16:25:23 <parcs`> comonads are like inverted burritos
16:25:24 <mike-burns> :t elem -- singpolyma
16:25:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:25:27 <rostayob> it's not exactly isomorphic
16:25:35 <rostayob> well
16:25:45 <roconnor> modulo lifting mumbo jumbo
16:26:22 <mike-burns> singpolyma: Though those two functions are rather different. Maybe you're using them interestingly/refactoringly? Care to paste their use?
16:27:09 <singpolyma> mike-burns: I use them to extract the elements I care about from a list of getopt stuff.  basically the pattern is "find the first element that matches this pattern and return it, else return a default"
16:27:18 <rostayob> roconnor: wait, why do you need to throw Kleisli in the mix? (a ->) is a monad reader already
16:27:31 <mike-burns> singpolyma: Ah: the cmdargs package is the common way of abstracting that.
16:28:02 <roconnor> rostayob: I wanted to give two types that are isomorphic
16:28:12 <rostayob> also, i'm constantly in doubt wether i actually want to spend time understanding these things or not.
16:28:43 <roconnor> rostayob: no need to worry about it until you do something vaugely like a cellular automata
16:28:46 <singpolyma> mike-burns: ok, that's interesting I guess for my specific case.  I'm also a bit curious about the pattern I've got here.  In general it seems hard to abstract things where the prediate is a pattern match
16:28:58 <rostayob> roconnor: you don't need to know what a comonad is to do cellular automata :)
16:29:09 <rostayob> mine was a more general question anyway
16:29:21 <roconnor> like this guy needs: http://shinytoys.org/blog/today-i-created-death
16:29:35 <roconnor> rostayob: the above code would probably be cleaner with comonads
16:29:50 <roconnor> rostayob: though it is pretty good as is
16:29:57 <rostayob> uh, OCaml
16:30:04 <mike-burns> singpolyma: isHelp = elem Help
16:30:13 <roconnor> rostayob: squint and pretend it is Haskell
16:30:20 <rostayob> i don't mind OCaml
16:30:35 <roconnor> he made it purely functional so that is good
16:30:35 <rostayob> Try it yourself: <blank square>
16:30:39 <singpolyma> mike-burns: right.  the case where the pattern match is complete is a special case, I guess
16:30:49 <roconnor> rostayob: I think the server is now dead :(
16:31:17 <rostayob> pity
16:31:30 <roconnor> http://www.reddit.com/r/haskell/comments/ehnfh/today_i_created_death_fp_in_game_development_not/c187k9i
16:31:32 <roconnor> my comment
16:31:48 <rostayob> roconnor: what i was asking to myself is: do i want to dig deeper in the algebraic and category theoretic stuff or do i just want to code stuff instead?
16:32:03 <roconnor> rostayob: you need to do both hand in hand
16:32:15 <rostayob> well, i certanly don't *need* to :)
16:32:28 <rostayob> but i'm not sure what kind of programmer i want to be anymore lol
16:32:42 <roconnor> rostayob: one day you will either say, oh this categorical abstraction can solve that programming problem I had a while back very nicely or
16:33:09 <roconnor> rostayob: one day you will encounter a programming problem that you realize that crazy categorical abstraction will solve nicely
16:33:57 <roconnor> rostayob: but most important you should enjoy yourself
16:33:58 <rostayob> roconnor: i'm pretty sure that the bulk of hacking is made by people who have no idea whatsoever about this stuff, even in FP
16:34:14 <roconnor> rostayob: that is why it is "hack"ing
16:34:23 <rostayob> eheh
16:34:25 <roconnor> here we do eleganting
16:34:53 <rostayob> roconnor: i have more fun with the abstraction and all that, but while i do that i'm not doing anything remotely useful or cool and i feel kind of bad
16:34:55 <roconnor> http://r6.ca/blog/20110808T035622Z.html <- elegenting
16:36:21 <singpolyma> I guess what I probably want is an easier way of building predicates of the form: http://pastie.org/3134934
16:36:22 <rostayob> i'm just looking for the idea level of knowledge of this after which it's just curiosity
16:38:29 <Cale> <-- cannot wait for kind polymorphism in GHC 7.4
16:38:48 <mike-burns> singpolyma: Well that's just == (but you must derive Eq). The interesting bit is getListen, which actually uses a value from the pattern match.
16:39:07 <rostayob> mike-burns: no, you can't express the wildcard with ==
16:39:21 <hpaste> mike-burns pasted “refactorings for singpolyma” at http://hpaste.org/56130
16:39:33 <mike-burns> Oh I see, yeah.
16:40:25 <singpolyma> mike-burns: how is it == ?    (Just 1 == Just) certainly doesn't work
16:40:36 <mike-burns> Yeah rostayob pointed that out.
16:41:21 * Cale edits kind signatures in dozens of definitions just because of a lack of kind polymorphism
16:41:32 <mike-burns> I don't know of anything that automatically derives the function you want, singpolyma .
16:41:35 <rostayob> Cale: I can't wait either :P
16:41:51 <rostayob> singpolyma: you can TH it. but that's ugly.
16:42:10 <singpolyma> rostayob: TH?  oh, template haskell?  I haven't even touched that stuff yet
16:42:25 <rostayob> singpolyma: yeah. but it's overkill, don't do that
16:42:47 <rostayob> i'm pretty sure that case is the shortest form of what you want to do
16:43:09 <mike-burns> isJust (Just _) = True; isJust _ = False -- this is the shortest, I think.
16:43:19 <singpolyma> rostayob: well, what I've often done is declared a whole bunch of helper functions with pattern matches
16:43:26 <singpolyma> yeah, like that
16:43:26 <rostayob> singpolyma: yeah, or that
16:43:38 <rostayob> i mea there no shorter general solution
16:43:56 <singpolyma> right, ok
16:44:17 <singpolyma> I thought there wasn't, but I'm always being pleasantly suprised by stuff people suggest to me in here
16:44:51 <rostayob> singpolyma: #haskell is cool! but i tend to spend too much time on it lately eheh
16:45:57 <myrddian> Hello
16:46:00 <myrddian> I have a question
16:46:06 <myrddian> Might seem stupid,
16:46:15 <mike-burns> Are you going to ask the question?
16:46:33 <myrddian> I am just wondering how good is Haskell in regards to implementing a Language/VM ?
16:46:55 <mike-burns> It has some tools that make it simpler.
16:46:56 <rostayob> @faq can haskell be used to implement a Language/VM?
16:46:56 <lambdabot> The answer is: Yes! Haskell can do that.
16:47:13 <mike-burns> Parsing is pretty easy, I hear, using the parsec library.
16:47:38 <rostayob> myrddian: Haskell is great for manipulating regular languages. great.
16:47:52 <rostayob> parsing and all
16:47:55 <mike-burns> The memory management is tricky; often times it's great, but sometimes it leaks memory and you have no idea why.
16:48:09 <myrddian> ok
16:48:17 <myrddian> ts just I am used to using YACC
16:48:23 <myrddian> and its a pain to implement a compiler
16:48:31 <mike-burns> It's more modern than YACC.
16:48:51 <rostayob> myrddian: you have lex and yacc-like tools for haskell, and you also have a slew of parser combinators library
16:48:57 <rostayob> using farious technologies
16:49:29 <rostayob> haskell will be great at that, really. the part in which it will shine less (but it'll still be good imho) is implementing the VM
16:49:49 <rostayob> myrddian: but in general the question "can haskell do this" is "yes" because it truly is a general purpose language
16:50:33 <rostayob> you might not want to write really low level stuff with haskell (drivers, kernel modules, etc), although even that can be done
16:50:50 <rostayob> also, it's kind of hard to bring haskell to mobile or embedded platforms
16:50:54 <rostayob> apart from that, go for it
16:51:25 <The_Journey> hi, does anyone know what library the "ident" function is in?
16:51:26 <myrddian> yeah I am not thinking Kernel or things like that :)
16:51:31 <BMeph> rostayob: s/haskell/GHC/ in your last, otherwise, great. ;)
16:51:45 <mike-burns> @hoogle ident
16:51:46 <lambdabot> Text.Read.Lex Ident :: String -> Lexeme
16:51:46 <lambdabot> Text.Read Ident :: String -> Lexeme
16:51:46 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
16:52:03 <myrddian> just want to try to write a language based on Set Theory
16:52:07 <rostayob> BMeph: if you drop GHC, you drop more or less the whole Haskell enviroment. also what you have in mind for embedded platforms? the only thing i can think of is Hugs
16:52:33 <mike-burns> I know ipwn studios had Haskell compiling to the iPhone.
16:52:49 <apltse> am a newbie in functional programming paradigm
16:53:26 <mike-burns> http://projects.haskell.org/ghc-iphone/ - probably outdated now.
16:53:46 <rostayob> mike-burns: yeah, and it's very tricky afaik.
16:53:57 <mike-burns> Well it's the iPhone.
16:54:24 <BMeph> rostayob: I'm just saying, GHC is deliberately the leader in haskell compiler systems, but it is not the only way. :)
16:54:57 <rostayob> BMeph: well, Haskell without GHC is a lot less awesome. it's still awesome, in the same way SML is awesome (maybe a bit more)
16:55:01 <rostayob> but you're going to be bored soon
16:55:09 <Cale> If you're interested in GHC on iPhone, the person to talk to is Stephen Blackheath (who is on here as blackh fairly regularly)
16:55:15 <rostayob> re-inventing the wheel a thousand time
16:55:53 <mike-burns> rostayob: Unless you're doing something like compiling Haskell to JavaScript or Android or any other non-desktop, interesting environment.
16:55:53 <Cale> We have newer stuff than what's up there
16:56:23 <Cale> and we should be making it available... I'm pretty sure a lot of it is going into GHC 7.6
16:56:28 <myrddian> Cool
16:56:32 <myrddian> I'll keep that in mind
16:56:41 <rostayob> mike-burns: compiling Haskell to JavaScript and porting an Haskell application to Android have little in common
16:56:55 <mike-burns> Oh man, don't port things to Android.
16:57:00 <Cale> hm?
16:57:03 <mike-burns> Write 'em from scratch.
16:57:03 <Cale> Why not?
16:57:27 <mike-burns> If you port them then we get the old UI that you had, and I'm sick of iOS UIs on my Android phone.
16:57:27 * BMeph is mildly amused that much of GHC's success comes from constant bitching and moaning from newcomers between 2005-2009 about there being "too many choices" of Haskell compilers, and no "go-to industry certified single answer" for one...
16:57:29 <Cale> We will also likely be constructing an Android toolchain for GHC as well.
16:57:31 <rostayob> mike-burns: with "port" i mean compile to for android
16:58:02 <rostayob> BMeph: really? I think that GHC success comes from GHC being *awesome* and cabal
16:58:34 <mike-burns> I thought GHC's success was also in large part because other things were research projects that were ignored after a few years.
16:58:36 <myrddian> so the idea is just stick with GHC
16:58:43 <rostayob> myrddian: definitely
16:58:54 <Cale> I think GHC's success comes from the fact that all of SPJ's research gets into it first, and nothing else can compete as far as cool extensions are concerned :)
16:59:05 <frt_> i like the too many choices of haskell
16:59:06 <myrddian> Anybody here worked used it on platforms outside Linux?
16:59:12 <rostayob> mike-burns: hugs is fully haskell 98 compliant and very portable. same for nhc. but they're pretty useless on their own
16:59:22 <rostayob> (save the portability for what concerns nhc)
16:59:22 <mike-burns> rostayob: Are they still maintained?
16:59:36 <rostayob> mike-burns: no, but they were in 2000, when they were competing with GHC
16:59:52 <mike-burns> Right yeah, I used hugs in 2000. It had nicer error messages.
17:00:06 <rostayob> also, there isn't much to mantain, there is a standard and they implement it. if you want haskell 98, you're set.
17:00:49 <BMeph> rostayob: Don't get me wrong; two-thirds of GHC's awesomeness comes from dealing with Haskell. However, there was a definite, deliberate "push" by the community, reluctantly at times, but definite, to have a "go-to" compiler, simply because it was the constant complaint of newcomers at the time.
17:01:20 <rostayob> BMeph: mah. I disagree. I think that, even in 2005, there was no question about which was the best haskell compiler. that's why everyone used it
17:01:55 <myrddian> wow so HUGS is not even an option if its not maintained then
17:02:13 <myrddian> The wiki still recommends it
17:02:18 <ddarius> rostayob: The best Haskell compiler is HBC.
17:02:34 <ddarius> myrddian: That page probably hasn't been really updated in like ten years.
17:02:45 <myrddian> Probably should be
17:02:50 <ddarius> Probably.
17:03:04 <myrddian> Well I can see why GHC won out, compiled code >>>>> interpreted
17:03:10 <mike-burns> Hm.
17:04:04 <BMeph> Cale: I'd also say that much of GHC's success comes from many useful alternet compilers being abandoned at the time. Not saying that they were specifically abandoned because of the hue and cry for "One [compiler] to Rule them All," but it's tough to keep a project going in the face of  such constant steering of traffic away.
17:04:23 <BMeph> Err, "alternate", I meant.
17:04:30 <mike-burns> Also, research projects.
17:04:52 <ddarius> GHC has just been the compiler with the most features and the most efficient output for some time.  What really changed things was Hackage and such and the network effects that that entails.
17:04:59 <apltse> hi all
17:05:02 <mike-burns> Yeah.
17:05:04 <mike-burns> Hello, apltse .
17:05:05 <rostayob> ddarius: yeah, totally
17:05:09 <apltse> I am a newbie and got a quick question
17:05:14 <mike-burns> Quick!
17:05:39 <BMeph> apltse: Too slow, you're done! ;)
17:05:44 <apltse> I was trying to install haskell 2011.4.0.0 and it's throwing error
17:05:52 <mike-burns> @paste
17:05:52 <lambdabot> Haskell pastebin: http://hpaste.org/
17:05:56 <mike-burns> Can you paste the error?
17:06:05 <apltse> sure give me a min
17:06:05 <ion> No, we should guess it instead.
17:06:29 * BMeph believes reformatting the hard drive will solve the problem...
17:06:40 <apltse> Error opening file for writing
17:06:41 <ion> You should say something like “it’s throwing an error about types or something” and we’ll play the guessing game.
17:06:51 * ddarius doesn't need belief.  He knows that violence is the solution.
17:06:56 <apltse> well that's the exact message
17:07:04 <ion> Ah, that’s a great hint for the guessing game.
17:07:04 <mike-burns> apltse: That's everything in the output?
17:07:14 <mike-burns> I'm willing to believe this, mind you.
17:07:26 <ddarius> mike-burns: Yep and there's no code that generates it.  It just appears from the aether.
17:07:27 <apltse> and the path of the file
17:07:27 <Cale> apltse: Possibly a permission issue? Hopefully your disk isn't full.
17:07:40 <mike-burns> @paste
17:07:40 <lambdabot> Haskell pastebin: http://hpaste.org/
17:07:47 <mike-burns> Paste the error.
17:07:51 <ion> apltse: Please don’t tell the path of the file. That would be too easy for us.
17:07:57 <BMeph> apltse: Using Windows Vista, perhaps? ;)
17:08:08 <mike-burns> I too guess Windows!
17:08:12 <mike-burns> Second guess: OS X.
17:08:19 <apltse> it indeed is windows
17:08:21 <mike-burns> Yes!
17:08:28 <hoqhuuep> 7?
17:08:29 <ion> Congrats, mike-burns.
17:08:29 <apltse> I hate it too!
17:08:35 <mike-burns> Thank you, thank you.
17:08:39 <apltse> so what do you think?
17:08:39 * BMeph does the happy dance, followed by the sadness march
17:08:54 <mike-burns> Well this was fun.
17:08:56 <monochrom> in 20 questions or less, we can guess... the question!
17:08:56 <rostayob> mah. goodnight #haskell, back to erlang :P
17:08:57 <hoqhuuep> Did you run the installer as admin?
17:09:09 <ion> We do love the guessing game, don’t we? Unfortunately it won’t get you closer to fixing your issue.
17:09:11 <apltse> ahhh nah
17:09:16 <apltse> that must vbe it
17:09:21 <apltse> hold on let me
17:10:01 <apltse> thanks fellas
17:10:09 <apltse> installing now
17:10:24 <mike-burns> Impressive, hoqhuuep .
17:10:31 <apltse> ahaha
17:10:36 <apltse> thanks mike
17:11:02 * mike-burns takes notes: "I have an error" and they're on Windows -> run installer as admin.
17:11:09 <hoqhuuep> I guess running windows myself makes it easier for me to guess what it is :P
17:11:18 <mike-burns> Sure yeah!
17:11:25 <apltse> yup
17:11:41 <apltse> am a newbie
17:11:47 <mike-burns> We're all learning.
17:11:54 <apltse> and am using it for class
17:12:01 <apltse> what do you guys use it for?
17:12:10 <mike-burns> Programmin'.
17:12:37 * ddarius cooks hot dogs with it.
17:12:38 <ion> Hacking CSI mainframes.
17:12:48 <apltse> yes and thought it would have more functionalities than ml
17:12:57 <parcs`> use what? windows or haskel
17:13:14 <hoqhuuep> I'm just learning it to exercise my brain a bit...
17:13:24 <parcs`> i use windows to play tf2 and haskell to generate fibonacci sequences
17:13:27 <apltse> hmmm interesting
17:13:32 <apltse> are you a programmer?
17:13:48 <hoqhuuep> who?
17:13:50 <ion> I sometimes generate lists of primes, too.
17:13:59 <mike-burns> I only use unfoldr .
17:14:00 <apltse> ahaha great
17:14:07 <apltse> enjoy guys!
17:14:14 <apltse> thanks for the help!
17:14:14 <mike-burns> Goodluck.
17:14:19 <apltse> thanks mike
17:14:25 <apltse> you too!
17:14:29 <mike-burns> Thanks!
17:20:18 <AfC> Another one bites the dust.
17:22:52 <Sgeo> I wonder how many people turn away from Scheme for reasons related to the amount of implementations
17:22:59 <karoyakani> @pl  \s c@(x,y) -> (Data.Set.size $ Data.Set.intersection [[(x',y')|x'<-[x..x+1],y'<-[y..y+1]]) `elem` if c `Data.Set.member` s then [1..5] else [2..4]
17:22:59 <lambdabot> (line 1, column 5):
17:23:00 <lambdabot> unexpected "@"
17:23:00 <lambdabot> expecting pattern or "->"
17:23:15 <ddarius> Sgeo: Probably very few if any.
17:23:25 <mike-burns> I can't imagine doing that.
17:23:58 <mike-burns> If I had to write Scheme I'd use whatever Scheme compiler the grad students at my university wrote.
17:24:33 <parcs`> haha
17:24:40 <karoyakani> @pl \s x y -> (Data.Set.size $ Data.Set.intersection [[(x',y')|x'<-[x..x+1],y'<-[y..y+1]]) `elem` if c `Data.Set.member` s then [1..5] else [2..4]
17:24:40 <lambdabot> (line 1, column 50):
17:24:40 <lambdabot> unexpected "["
17:24:40 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
17:25:12 <monochrom> that's like saying "I wonder how many people turn away from computing for reasons related to the amount of implementations"
17:25:47 <mike-burns> Answer to that: every OS X user.
17:26:00 <monochrom> haha
17:26:48 <karoyakani> @pl \s x y -> (Data.Set.size $ Data.Set.intersection s Data.Set.fromList([(x',y')|x'<-[x..x+1],y'<-[y..y+1]])) `elem` if c `Data.Set.member` s then [1..5] else [2..4]
17:26:48 <lambdabot> (line 1, column 120):
17:26:48 <lambdabot> unexpected "`"
17:26:48 <lambdabot> expecting variable, "(", operator or "then"
17:27:11 <monochrom> but I have the 1970s in mind, when there were like already 10 different brands even if you just count PC, and every brand came with its own different OS and BASIC...
17:27:44 <karoyakani> @pl \s x y -> (Data.Set.size $ Data.Set.intersection s Data.Set.fromList([(x',y')|x'<-[x..x+1],y'<-[y..y+1]])) `elem` if (x,y) `Data.Set.member` s then [1..5] else [2..4]
17:27:44 <lambdabot> (line 1, column 124):
17:27:44 <lambdabot> unexpected "`"
17:27:44 <lambdabot> expecting variable, "(", operator or "then"
17:28:09 <ddarius> A lot, probably the majority (or at least plurality) of those PCs were in America, and everyone knows how much Americans hate choice.
17:28:16 <mike-burns> We sure do.
17:29:48 <karoyakani> @pl \s x y -> (Data.Set.size $ Data.Set.intersection s $ Data.Set.fromList [(x',y')|x'<-[x..x+1],y'<-[y..y+1]]) `elem` if (x,y) `Data.Set.member` s then [1..5] else [2..4]
17:29:48 <lambdabot> (line 1, column 125):
17:29:48 <lambdabot> unexpected "`"
17:29:48 <lambdabot> expecting variable, "(", operator or "then"
17:30:10 <mike-burns> karoyakani: Surely you can try compiling it locally first before @pl'ing it.
17:30:19 <mike-burns> Don't prematurely ... optimize?
17:30:49 <ddarius> mike-burns: It likely does parse.
17:30:53 <ddarius>  @pl is not Haskell.
17:31:36 <monochrom> @pl \x -> x `f` 0
17:31:36 <lambdabot> (`f` 0)
17:32:47 <monochrom> @pl \x -> x `f` if True then 0 else 1
17:32:47 <lambdabot> (`f` if' True 0 1)
17:33:37 <monochrom> @pl \x -> x `D.f` 0
17:33:38 <lambdabot> (line 1, column 9):
17:33:38 <lambdabot> unexpected "`"
17:33:38 <lambdabot> expecting variable, "(", operator or end of input
17:33:54 <monochrom> that probably is why
17:33:59 <mike-burns> Nice sleuthing.
17:34:17 * monochrom is a reductionist!
17:42:23 <dgpratt> it may be sacrilege to ask this question in this forum, but I know many Haskellers also do the Scala...is there a good resource for learning Scala if you are already familiar with Haskell?
17:43:03 <mike-burns> I found the Programming Scala book to be most useful.
17:43:35 <DarthArachides> I'm not tooooo familiar with either scala or haskell, but I found scala more similar to java than to haskell.
17:43:38 <dgpratt> mike-burns: well, good, I'm looking at it right now :)
17:43:48 <DarthArachides> scala seems more like java with functional features thrown in.
17:43:51 <mike-burns> The stuff you already know will be the Scala-esque classes, but all the Java and OO stuff will be different from Haskell.
17:44:30 <parcs`> > 2000000000 / 30 / 24 / 60 / 60
17:44:31 <lambdabot>   771.6049382716049
17:45:31 <mike-burns> Months?
17:48:34 <DukeDave> I want to 'extend' Data.Map by storing the key which was most recently added to the Map, but I'd like to still expose all of Map's functionality.
17:48:46 <DukeDave> What is a good approach for this pattern?
17:49:45 <mike-burns> data TrackingMap k v = TrackingMap { fromTrackingMap :: Map k v, lastKey :: k }
17:50:07 <mike-burns> Then you'll have to re-write all the Map functions to delegate to the composed Map.
17:50:12 <mike-burns> Any better ideas?
17:50:40 <DukeDave> mike-burns: Yes, it was the word "re-write" I was hoping to avoid
17:51:00 <Sgeo> In certain more dynamic languages, you'd be able to have it transparent send most operations to the map
17:51:02 <Sgeo> :/
17:51:12 <mike-burns> Sgeo: Well sure, in OO this would be a decorator.
17:52:41 <sanjoyd> Is there some idiomatic way to peek in Parsec?  i.e. a parser only succeeds if the next token is X, but does not consume anything?
17:54:42 <mike-burns> DukeDave: You could probably use TH to get the re-writen functions down to a line or two of code.
17:54:49 <mike-burns> Maybe.
17:55:13 <DukeDave> Bleugh, it doesn't smell right, does it.
17:55:26 * mike-burns shrugs
17:59:16 <DukeDave> Thanks though!
17:59:57 <Sgeo> > let F v = 5 in F 4
17:59:58 <lambdabot>   Not in scope: data constructor `F'Not in scope: data constructor `F'
18:03:56 <nh2> I need to understand http://www.haskell.org/haskellwiki/Functional_dependencies
18:04:11 <nh2> it says: (m1 * m2) * m3              -- type error; type of (m1*m2) is ambiguous
18:04:46 <nh2> why? From my point of view, there is only one function Matrix -> Matrix -> something, and that function dictates that something is Matrix
18:06:45 <parcs`> mike-burns: reddit gets 2B page views a month, which apparently is (on average) 770/s
18:07:08 <mike-burns> Ah.
18:07:39 <parcs`> > 2E9
18:07:40 <lambdabot>   2.0e9
18:08:11 <nh2> it kinda gives the answer: "Even if only one instance is defined, the type system will not figure it out without the functional dependency." - but I don't understand why that choice was made.
18:08:49 <aristid> > iterate (zipWith (+) <$> (0:) <*> (++[0])) [1]
18:08:50 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
18:08:58 <parcs`> it's probably like 2000/s during peak hours
18:09:56 <dominikh> hm, I'm fairly new to Haskell and pretty surprised that Haskell doesn't seem to employ memoization for recursive calls on its own
18:10:42 <aristid> dominikh: it only memoizes values.
18:10:51 <ion> Memoizing everything by default is a pessimization. When you know you want something to be memoized it’s not hard to do.
18:11:16 <aristid> so recursive values ARE memoized
18:11:56 <dominikh> ion: well, but it seems like needless boierplate. could've provided a language feature, a simple keyword or something that enabled memoization for a specific function
18:12:05 <ion> Yeah, at least top-level non-polymorphic values are memoized.
18:12:43 <dominikh> as an example I'm thinking fibonacci here (the same example the wiki uses for different ways to add memoization)
18:12:47 <shachaf> aristid: Haskell doesn't memoize values.
18:12:58 <shachaf> Or, rather, to say "Haskell memoizes values" is very misleading.
18:13:23 <shachaf> dominikh: Automatic memoization is not usually what you want.
18:14:01 <ion> dominikh: A top-level fibs :: [Integer] is… i was about to say memoized but shachaf will correct my incorrect understanding.
18:14:39 <aristid> shachaf: maybe i'm sitting on a misunderstanding myself *sigh*
18:14:59 <shachaf> ion: That's not the same as "Haskell memoizes values".
18:15:09 <aristid> shachaf: in what way aren't values memoized?
18:15:30 <ion> GHC memoizes values? :-)
18:15:33 <shachaf> In fact, «In computing, memoization is an optimization technique used primarily to speed up computer programs by having function calls avoid repeating the calculation of results for previously processed inputs.»
18:15:59 <mike-burns> Well we can think of values as functions with no arguments ...
18:16:05 <shachaf> ion: There's also that. Haskell doesn't talk about sharing at all.
18:16:08 <shachaf> mike-burns: No. We can't.
18:16:15 <shachaf> @google everything is a function in haskell
18:16:16 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
18:16:16 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
18:16:17 <mike-burns> trololololol
18:16:27 <shachaf> mike-burns: Come on. Someone is actually asking a question here.
18:16:35 <mike-burns> You're right, sorry.
18:16:52 <shachaf> dominikh: If you bind something to a name, the value of that name will only be computed once (as a rule, in GHC).
18:17:32 <shachaf> So let x = longComputation blah in something x x will only do the long computation once.
18:17:44 <shachaf> Whereas something (longComputation blah) (longComputation blah) will probably do it twice.
18:18:34 <aristid> shachaf: i would think of these two (longComputation blah) as two different values (ignoring the fact that they are equal)
18:19:02 <aristid> shachaf: may be the wrong way to think about it :)
18:19:21 <dominikh> shachaf: yeah, that's what I gathered so far. I also found http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion and the solution seems.. not straightforward to me
18:19:53 <shachaf> dominikh: Well, that's *a* way of doing memoization.
18:19:57 <shachaf> There are also simpler ones.
18:20:47 <shachaf> aristid: Well, they're not just (==) equal. They're equal in every way you can talk about values being equal, extensionally.
18:20:49 <dominikh> I was hoping for the wiki to have the simple ones ;)
18:21:45 <shachaf> aristid: In that particular sense of the word "value", you can say that a value will only be computed once, yes.
18:21:54 <shachaf> dominikh: Some of the simpler-to-use examples use some dirty tricks to work.
18:22:03 <aristid> shachaf: what would be a better word than value, for the thing that i mean?
18:22:06 <shachaf> dominikh: You should be able to understand how this example works before you use them. :-)
18:22:14 <shachaf> aristid: "name", maybe?
18:22:17 <shachaf> "thunk"?
18:22:22 <shachaf> "binding"?
18:22:23 <dominikh> shachaf: heh, okay
18:22:37 <aristid> shachaf: would "value expression" be OK, too? :)
18:23:07 <shachaf> aristid: "expression" usually has an unrelated meaning. As does "value", I think.
18:23:16 <shachaf> dominikh: In the second example, fib is defined in terms of indexing into a list.
18:23:31 <shachaf> So let's say you ask for "fib 4"
18:23:49 <shachaf> First it goes down the list to the fourth element. At this point the list looks like this:
18:24:06 <shachaf> [?, ?, ?, ?, ?, ...
18:24:15 <ion> > let fib :: Integer -> Integer; fib n = fibs !! n; fibs :: [Integer]; fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs 4  -- dominikh: here’s a quite simple implementation of Fibonacci numbers that uses memoization.
18:24:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:24:16 <lambdabot>         against inferred type ...
18:24:22 <ion> > let fib :: Integer -> Integer; fib n = fibs !! n; fibs :: [Integer]; fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fib 4
18:24:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:24:23 <lambdabot>         against inferred type ...
18:24:33 <shachaf> ion: That implementation is only simple to crazy people who've spent way too long in #haskell.
18:24:35 <ion> Frigging !!
18:24:45 <aristid> shachaf: i just want to find a way to express "values are memoized" correctly without using jargon that may not be understood
18:24:51 <shachaf> It'll only cause dominikh confusion if he can't understand the other one.
18:25:05 <shachaf> aristid: "bindings are computed only once"?
18:25:11 <shachaf> That's not quite ideal, I guess.
18:25:41 <ion> > let fib :: Integer -> Integer; fib n = fibs `genericIndex` n; fibs :: [Integer]; fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fib 4
18:25:42 <lambdabot>   3
18:25:56 <shachaf> dominikh: Then it examines that element and figures out that it means "memoized_fib 2 + memoized_fib 3"
18:26:23 <shachaf> So the list looks like [?, ?, ?, ?, memoized_fib 2 + memoized_fib 3, ...
18:26:27 <shachaf> Are you following so far?
18:26:30 <dominikh> yes
18:26:50 <shachaf> For convenience let's give this list a name. We'll call it fib_list.
18:28:08 <shachaf> So fib_list = [?, ?, ?, ?, fib_list!!2 + fib_list!!3, ...
18:28:37 <shachaf> Whichever one it tries to compute next -- let's say it's fib_list!!3 -- will compute further toward the beginning of the list.
18:28:47 <shachaf> Note that once a list entry has been computed, it won't be computed again.
18:29:15 <shachaf> Eventually something asks for fib_list!!0 or fib_list!!1, in which case it looks at that value and sees that it's just 0 or 1.
18:30:01 <shachaf> So eventually: fib_list = [0, 1, fib_list!!0 + fib_list!!1, fib_list!!1 + fib_list!!2, fib_list!!2 + fib_list!!3, ...
18:30:04 <ion> For that to work the initial fib_list has to be [0, 1, ?, ?, ?, ?, …
18:30:23 <shachaf> ion: That's how it's defined. Except until you examine them the 0 and 1 are also ?s.
18:30:32 <ion> aye
18:30:44 <shachaf> And later: fib_list = [0, 1, 1, 2, fib_list!!2 + fib_list!!3, ...
18:30:53 <shachaf> And later: fib_list = [0, 1, 1, 2, 3, ...
18:30:59 <dominikh> shachaf: so technically that works because initially the list begins to contain unevaluated statements, and in fib n = memoized_fib (... it won't try to compute it yet, due to lazy evaluation?
18:31:03 <shachaf> And now it's finished evaluating that fifth thunk, finally.
18:31:34 <shachaf> dominikh: I'm not sure what you mean.
18:32:10 <dominikh> shachaf: when I first saw that code, I wondered why in line 5, it could benefit from the list in the last line. I forgot that it won't try to actually compute anything in line 5 yet
18:32:48 <shachaf> Keep in mind that the following two lines are different:
18:33:19 <shachaf> > let { memoized_fib :: Int -> Integer; memoized_fib = let { fib 0 = 0; fib 1 = 1; fib n = memoized_fib (n-2) + memoized_fib (n-1) } in (map fib [0..] !!) } in memoized_fib 150
18:33:19 <lambdabot>   9969216677189303386214405760200
18:33:34 <shachaf> > let { memoized_fib :: Int -> Integer; memoized_fib n = let { fib 0 = 0; fib 1 = 1; fib n = memoized_fib (n-2) + memoized_fib (n-1) } in (map fib [0..] !!) n } in memoized_fib 150
18:33:38 <lambdabot>   mueval-core: Time limit exceeded
18:33:53 <shachaf> This approach is kind of fragile because of this sort of thing, I think.
18:34:36 <dominikh> okay, that dumbstrucks me right now.
18:35:39 <shachaf> dominikh: The line that ion gave before is much nicer, of course. :-)
18:36:08 <shachaf> If you understand this one and that one thoroughly then you'll have a much better understanding of laziness.
18:36:44 <shachaf> Cale, if he was here, would give a double double example.
18:36:46 <dominikh> I'll try to. Thanks for explaining it so thoroughly :)
18:36:50 <Cale> hi
18:38:23 <aristid> shachaf: you summoned him accidentally!
18:38:27 <aristid> hi Cale
18:38:50 <shachaf> Cale!
18:38:54 <shachaf> Are you going to Hac Boston?
18:39:07 <dolio> Please.
18:39:10 <dolio> Hac Beans.
18:39:45 <Cale> -.-
18:39:52 <MostAwesomeDude> Okay, lenses are pretty sweet.
18:40:16 <princess_> I'm new to Haskell, I'm trying to build a Graph, but I can't seem to get my head around it (I seem to build trees). Do I need to involve a map or something?
18:40:33 <Cale> princess_: Yeah, that's a good way
18:40:48 <princess_> Cool, I'll give it a go, thank you
18:41:05 <Cale> Map Vertex (Set Vertex) or some variation on that works well
18:41:17 <Cale> Depending on exactly what graph structure you need to represent
18:43:25 <dolio> Representing graphs well in Haskell is something quite a few people have banged their head against.
18:43:31 <dolio> So don't feel bad if it isn't obvious to you.
18:44:20 <princess_> Using a map sounds like a good way, I'm coming in from C though, so I have a pretty clear understanding of exactly how I want everything to be. The exercise here is to give up control I guess
18:44:52 <shachaf> type Graph = IntMap IntSet
18:46:05 <princess_> I understand the map solution, no worries. I was wondering whether there was a magic awesome way to do it. Thank you for the help.
18:46:10 <Cale> princess_: Yeah, if you have any C datastructure which uses pointers, you can use IntMap (or Map Int) to simulate the C heap
18:46:47 * hackagebot bindings-DSL 1.0.15 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.15 (MauricioAntunes)
18:46:55 <Cale> Well... there are some typing issues with that occasionally, but most of the time that'll just work out fine :)
18:47:45 <JoeyA> I just wrote the following commit message: Added documentation, and added someFuncName. Apparently, I think applying the monomorphism restriction to English is a good idea.
18:47:50 <Cale> (and it constitutes most of a proof that you can do anything with immutable structures what you can do with mutation with at most a log factor cost increase)
18:48:19 <shachaf> JoeyA: The monomorphism restriction?
18:48:26 <JoeyA> Ehh, maybe not
18:48:52 <ion> Why add “documentation” and a function in the same commit?
18:48:55 <JoeyA> Well, in this case, it's more like map SomeException (AsyncException ..., IOException ...)
18:49:02 <JoeyA> err, []
18:49:29 <JoeyA> Because Haskell is terse, giving me more time to document :-)
18:50:08 <JoeyA> It's a small commit anyway.
18:50:40 <aristid> Cale: if you consider the multiple levels of RAM cache on modern computers, doesn't it get kind of logarithmic again? :)
18:56:06 <jdavis> trying to understand this file: https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple.hs  it says it's exporting Base.close, but I don't see that defined there. What does that mean and where is it defined?
18:56:55 <jdavis> Wait, I think I know.
18:57:12 <jdavis> There's an import being renamed "Base" which I missed.
18:57:18 <xil> hello everyone. Is there a function that takes a list and an int and does something like: func [1,2,3,4,5,6] 3 = [[1,2,3],[4,5,6]]
18:57:38 <monochrom> your Base is belong to lpsmith :)
18:57:46 <ion> @hoogle [a] -> Integer -> [[a]]
18:57:47 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:57:47 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:57:47 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:57:52 <ion> @hoogle Integer -> [a] -> [[a]]
18:57:52 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:57:53 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:57:53 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:58:03 <ion> @hoogle splitEvery
18:58:03 <lambdabot> No results found
18:58:11 <Cale> aristid: yeah, well, asymptotics are often really unrealistic, because as memory increases without bound, eventually you're going to have to put it farther and farther away (assuming that the universe will only allow a finite amount of information in a given volume, which is pretty reasonable)
18:58:25 <MostAwesomeDude> xil: It's in the split package.
18:58:44 <ion> @hackage split
18:58:44 <lambdabot> http://hackage.haskell.org/package/split
18:58:53 <xil> MostAwesomeDude: thanks. I started looking there after ion's last @hoogle, haha
18:58:57 <xil> ion: thanks =]
18:58:57 <Cale> aristid: and so depending on your assumptions, the best you can do to access a random piece of memory is either O(n^(1/3)) or O(n^(1/2))
18:59:21 <Cale> (the latter if you accept the holographic principle)
19:00:00 <aristid> Cale: those asymptotics are possibly much more correct, but also much less useful than traditional asymptotics :)
19:00:07 <Cale> yeah
19:00:45 <Cale> But for real large applications where memory access becomes non-uniform, they do start getting more realistic.
19:01:13 <dominikh> shachaf: I don't quite get yet why the memoized_fib = ... version works, while memoized_fib n = ... does not :/
19:01:37 <aristid> Cale: is it already reasonable for an application that uses the whole of a single computer? i.e. the entire cache, RAM and hard disk
19:02:12 <Cale> aristid: Well, once you fix the size of the computer...
19:02:54 <shachaf> dominikh: Do you understand the difference let { f = let { y = product [1..1000000] } in \x -> x + y } and let { f = \x -> let { y = product [1..1000000] } in x + y }?
19:02:55 <aristid> Cale: heh, ignoring that :)
19:03:19 <Cale> But really I think that up to the size of an ordinary machine, you'll see a really non-smooth performance curve around the places where you leave cache and then when you start swapping
19:03:50 <shachaf> Cale: Around the places where you leave each cache. :-)
19:03:56 <Cale> yeah
19:04:10 <shachaf> (I mean that the former includes the latter.)
19:05:18 <dominikh> shachaf: I'm not sure, I don't think so
19:05:32 <shachaf> dominikh: Oh. Well, understand that first. :-)
19:05:49 <dominikh> shachaf: got a keyword to look for?
19:06:09 <dominikh> (keyword in the English sense, not programming language sense ;))
19:06:30 <shachaf> "double double 5" :-)
19:06:48 <shachaf> Cale: Did you ever put one of those explanations online anywhere other than in IRC logs?
19:07:24 <Cale> I seem to recall that someone did, but it wasn't me
19:10:35 <MostAwesomeDude> :t flip execStateT
19:10:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => a -> StateT a m a1 -> m a
19:14:54 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml may help. it doesn't cover "\x -> let" vs "let ... in \x ->" yet, but reading it already makes you sharing-aware
19:15:57 <dominikh> thanks
19:21:36 <ybit> Cale, hpc, monochrom, was it one of you who was speaking with me about linguistics at some point, trying to teach me some basic concepts...
19:21:44 <mjrosenb> monochrom: oh god, that uses inline svgs?
19:21:50 <Cale> not me
19:22:05 <ybit> aha
19:22:06 <ybit> augur:
19:22:10 <ybit> that's the guy
19:22:18 <augur> oh hello
19:22:21 <augur> whats up now
19:22:26 <augur> oh yes hi
19:22:29 <ybit> :)
19:22:38 <monochrom> "f x = let m = huge array in ..." you ask for f 5, it computes the huge array, then throws it away. not very nice if you intend to memoize. it is thrown away because it ceases to be live data, no one else has a handle on it
19:22:46 <ybit> i was wondering if you wanted to continue where we left off before my finals slammed me
19:22:57 <shachaf> Not in #haskell, if it's linguistics.
19:23:03 <shachaf> Maybe #haskell-blah-overflow
19:23:05 <ybit> right
19:23:12 <ybit> it's some other channel
19:23:13 <augur> ybit: whered we leave off!
19:23:22 <shachaf> Or ##linguistics
19:23:25 <augur> #haskell-linguistics
19:23:37 <shachaf> #linguistics
19:23:44 <shachaf> You get opped automatically by joining.
19:23:56 <shachaf> Or maybe not automatically.
19:24:50 <monochrom> "f x = let m = huge array in f (x-1)" you ask for f 5, it computes the huge array (sooner or later), it calls f 4 (sooner or later). the f 4 computes its own huge array and doesn't use f 5's huge array, because f 4 isn't even told about the existence of f 5's array. this completely defeats the point of memoization
19:26:28 <dominikh> so with "f x", for each different x, there's a different function in memory, while with "f", it can be shared?
19:26:30 <monochrom> now, "f = let m = huge array in \x -> ..." is just like "m = huge array" on one line and "f = \x -> ..." on another, apart from allowing only (\x -> ...) to use m. there is only one huge array, and f 5, f 4, and f 3 all use it.
19:26:54 <monochrom> mdmkolbe: isn't HTML5 exciting? :)
19:27:01 <dolio> Except you need a slightly more clever example.
19:27:14 <dolio> Because 'f x = let m = huge array in f (x-1)' will only allocate a thunk.
19:27:22 <dolio> And then collect it.
19:27:36 <monochrom> now, optimizations may or may not change all of the above.
19:30:44 <dominikh> there is no difference between "let" and "where" in this context, is there?
19:31:01 <monochrom> no difference
19:31:11 <shachaf> "where" is just syntax-sugar for particucular kinds of "let".
19:31:18 <shachaf> Stick to "let" until you understand it.
19:31:37 <dominikh> darn, because I liked where more :<
19:31:40 <shachaf> Mmm, I'd love to eat some particucumber soup.
19:31:59 <monochrom> actually it suffices to pick one and stick to it during learning.
19:32:17 <shachaf> monochrom: Except that "where" will cause more confusion because it only works with bindings.
19:32:25 <shachaf> Esecially in cases like f = \x -> ... where ...
19:33:47 <monochrom> f x = ... where ...
19:33:51 <dolio> 'f x = let ... in ...' vs. 'f = let ... in \x -> ...' is slightly more obvious in its difference than 'f x = ... where ...' vs. 'f = \x -> ... where ...'
19:34:05 <shachaf> Right.
19:34:12 <shachaf> What dolio said.
19:34:33 <shachaf> In fact, whenever dolio says something, imagine that I say "What dolio said." right afterward.
19:34:53 <dominikh> :D
19:34:54 <dolio> That shachaf guy is a total shmuck.
19:35:07 <shachaf> I stand by my previous statement.
19:35:32 <MostAwesomeDude> Hm. There's a lens function, focus, which looks like Lens a b -> StateT b m c -> StateT a m c.
19:36:00 <MostAwesomeDude> I gather that I can use it to take a StateT which operates on some specific field, and make it operate on a bigger record, right?
19:36:12 <dolio> Yes.
19:36:12 <MostAwesomeDude> Is there a way I could get that inside a single StateT block?
19:36:46 <MostAwesomeDude> I didn't want to ask "How can I switch my type of state inside StateT" since that seems inane. :3
19:37:30 <MostAwesomeDude> Oh! I see. I can do something like "do {focus myLens $ do {} }"
19:37:51 <shachaf> > do {}
19:37:51 <lambdabot>   <no location info>: Empty 'do' construct
19:37:53 <MostAwesomeDude> It's like a with-construct. Nifty.
19:38:03 <MostAwesomeDude> do {...}, I mean.
19:38:35 <shachaf> > do lio
19:38:36 <lambdabot>   What dolio said.
19:38:47 <MostAwesomeDude> Heh.
19:39:02 <MostAwesomeDude> dolio: You are obviously a cool guy.
19:39:10 <dolio> Obviously.
19:39:38 <shachaf> eh says insults and doesn't afraid of anything.
19:44:59 <Rc43> > (!! 999999) .sort $permutations ['0'..'9']
19:45:06 <lambdabot>   mueval: ExitFailure 1
19:45:06 <lambdabot>  mueval: Prelude.undefined
19:45:20 <Rc43> > :t permutations
19:45:25 <lambdabot>   mueval-core: Time limit exceeded
19:45:39 <shachaf> lambdabot isn't ghci
19:45:48 <Rc43> > length $ permutations ['0'..'9']
19:45:52 <lambdabot>   mueval-core: Time limit exceeded
19:46:02 <shachaf> What are you trying to do?
19:46:18 <Rc43> http://projecteuler.net/thread=25&page=8
19:46:34 <shachaf> If you don't have a question about this code that you want to ask #haskell, you can talk to lambdabot in /msg.
19:46:36 <Rc43> ctrl+f pro_24p
19:46:58 <Rc43> shachaf, I forgot, thanks
19:47:00 <monochrom> your approach is likely too slow
19:47:12 <Rc43> It isn't my approach
19:47:33 <Rc43> I just haven't haskell on this computer :)
19:48:33 <dolio> > product [1..10]
19:48:35 <lambdabot>   3628800
19:48:42 <mm_freak> can i tell the RTS never to collect garbage?
19:49:34 <monochrom> that's probably pretty hard. "seldom" is easier and you probably know how
19:50:31 <monochrom> someone once said "don't create garbage". not sure how easily you can do it
19:50:35 <Rc43> I can't understand, why  `(!! 999999) .sort $permutations ['0'..'9']` solves problem.
19:51:12 <mm_freak> hmm, ok
19:51:18 <shachaf> Rc43: Does it?
19:52:09 <monochrom> "What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?"  sounds like a direct transliteration
19:52:27 <Rc43> shachaf, dunno, but it is places in projecteuler thread (available after solution as i know)
19:53:02 <dolio> It will eventually solve it.
19:53:12 <MaskRay> factorial number system
19:53:23 <mm_freak> GC seems to be the performance killer for my parallel computation =/
19:53:24 <shachaf> monochrom: The problem seems to be about Fibonacci numbers.
19:53:50 <MaskRay> monochrom: http://en.wikipedia.org/wiki/Factorial_number_system
19:54:24 <monochrom> eh? thank you all for all the information. but I don't care about project euler problems
19:55:00 <The_Journey> just a question, the if-then-else syntax is rarely used in Haskell right?
19:55:22 <monochrom> depends on whom you ask. I use it all the time
19:55:38 <pikhq> The_Journey: Not sure I'd say "rarely", but much less so than it would be in more common languages.
19:55:40 <dolio> I use it way more than case ... of False -> ... ; True -> ...
19:55:47 <Rc43> Why > (take 10).sort $ permutations ['0'..'9'] fails?
19:55:48 <Rc43> > (take 10).sort $ permutations ['0'..'9']
19:55:53 <lambdabot>   mueval-core: Time limit exceeded
19:55:53 <ion> I’d usually want bool :: a -> a -> Bool -> a instead.
19:56:07 <pikhq> It's just a bit more common to use a pattern match than an if statement.
19:56:09 <Rc43> [08:35] <Rc43> > (take 10).sort $ permutations ['0'..'9'] [08:35] <lambdabot>   mueval: ExitFailure 1 [08:35] <lambdabot>  mueval: Prelude.undefined
19:56:13 <Rc43> strange
19:56:19 <The_Journey> I'm just asking because it's a pain to get the indentation correct using the if-then-else
19:56:40 <ion> Why is that? I haven’t found indentation a problem with if-then-else.
19:56:43 <monochrom> but of course, I don't write "if null xs" ever. I use pattern-matching for that. case xs of [] -> ...
19:57:02 <pikhq> ion: It would be if you use a more naive editor.
19:57:03 <monochrom> but I do write "if x>5" all the time
19:57:37 <The_Journey> but pattern matching is preferred over if-then-else whenever possible correct?
19:57:55 <Axman6> > permutations "abc"
19:57:56 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
19:58:01 <shachaf> The_Journey: That's not really a very clearly-defined question unless you're talking about the case dolio mentioned.
19:58:15 <monochrom> "pattern matching is preferred over if-then-else whenever possible" is equivalent to "always use pattern matching"
19:58:40 <monochrom> I certainly don't always use pattern matching.
19:58:47 <dolio> I'd use guards rather than if where applicable, too.
19:58:55 <Axman6> hmm, is it possible to make an implementation of permutations that returns the permutations in lexographic order (assuming the input list is ordered0?
19:58:57 <dolio> But sometimes testing a boolean isn't the first thing you do in a function.
19:59:18 <shachaf> dolio: But now the question is about whether pattern guards are preferable to boolean guards. :-)
19:59:30 <shachaf> Axman6: Yes.
19:59:37 <shachaf> sort . permutations is such an implementation.
19:59:59 <Axman6> i meant a more efficient version than that
20:00:10 <shachaf> Oho, suddenly we get constraints.
20:00:18 <shachaf> Next you'll want it to be elegant.
20:00:48 <monochrom> and in 10 characters or less
20:02:23 <monochrom> it is doable if you revive the old ACM tradition of cataloging and numbering algorithms. you would get "algo #30000" for the solution sought. efficient, elegant, succint.
20:03:14 <shachaf> monochrom: Sadly, that solution is in 11 characters.
20:03:22 <monochrom> oh dart
20:03:30 <shachaf> Dart and double dart!
20:04:05 <monochrom> so, no Haskell Weekly News this week either
20:04:27 <BMeph> > revrse . permutations $ "cba"
20:04:28 <lambdabot>   Not in scope: `revrse'
20:04:34 <BMeph> > reverse . permutations $ "cba"
20:04:36 <lambdabot>   ["cab","acb","bac","abc","bca","cba"]
20:04:52 <BMeph> > map reverse . permutations $ "cba"
20:04:54 <lambdabot>   ["abc","acb","cba","cab","bca","bac"]
20:05:02 <monochrom> I was hoping for my 4th-day-of-xmas quote to appear in HWN during boxing week.
20:05:13 <BMeph> ...well, fudge. :/
20:05:49 <monochrom> hrm, is permutations already lexicographical?
20:05:56 <monochrom> > permutations "abc"
20:05:57 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
20:06:03 <shachaf> @quote monochrom 4th
20:06:04 <lambdabot> monochrom says: "on the 4th day of christmas my true love sent to me, 4 cabal failures, 3 cabal failures, 2 cabal failures, and a cabal failure"
20:06:04 <monochrom> no wonder
20:06:44 <parcs`> @src permutations
20:06:45 <lambdabot> Source not found. Just try something else.
20:14:44 <Axman6> > let perms :: [a] -> [[a]]; perms [] = [[]]; perms xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (perms others)) ys in perms [1..5]
20:14:45 <lambdabot>   [[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1...
20:15:06 <Axman6> > let perms :: [a] -> [[a]]; perms [] = [[]]; perms xs = let ys = zipWith3 (\a b c -> (a,b++c)) xs (inits xs) (drop 1 $ tails xs) in concatMap (\(y,others) -> map (y:) (perms others)) ys in perms [1..9] !! 999999
20:15:10 <lambdabot>   mueval-core: Time limit exceeded
20:15:13 <Axman6> :(
20:17:13 <Axman6> anyway, that appears to give all the permutations, in lexographic order, assuming the input is sorted
20:17:41 <shachaf> Axman6: But is it efficient?!
20:17:59 <Axman6> efficient enough for the job at hand
20:18:05 <Axman6> @pl concatMap (\(y,others) -> map (y:) (perms others)) ys
20:18:05 <lambdabot> uncurry ((. perms) . map . (:)) =<< ys
20:18:22 <Axman6> hmm, no thanks
20:20:21 <MostAwesomeDude> Annoying; "when" only works with m (), not m a.
20:20:36 <Axman6> it can't work for m a though
20:20:43 <shachaf> monochrom: How should it work with m a?
20:20:59 <shachaf> s/monochrom/MostAwesomeDude/
20:21:00 <Axman6> well, it could i guess, when :: Bool -> m a -> m ()
20:21:19 <MostAwesomeDude> ^^
20:21:31 <shachaf> Oh, discarding the value of the action.
20:21:43 <shachaf> s/value/result/
20:21:45 <shachaf> I guess that's true.
20:21:56 <MostAwesomeDude> Yeah. I don't care about the result, but the type is constrained so I can't do that directly.
20:22:21 <shachaf> @hoogle m a -> m ()
20:22:22 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
20:22:22 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:22:22 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
20:33:04 <hpaste> stepcut pasted “does this terminate with GHC 7.0” at http://hpaste.org/56142
20:33:54 <stepkut> I am trying to create a test case for a bug in GHC 7.4rc1. Can someone confirm that that little program actually terminations under GHC 7.0?
20:34:43 <stepkut> it should print "done." at the end.
20:35:04 <parcs`> terminates on 7.2.2
20:35:11 <stepkut> oo
20:35:20 <stepkut> does it hang for anyone else in 7.4rc1?
20:36:47 <dolio> I don't understand why that would loop.
20:36:47 <stepkut> under 7.4rc1 I expect it to hang or print <<loop>>
20:36:56 <stepkut> dolio: compiler bug
20:37:19 <parcs`> loops in 7.5.20111215 too
20:37:48 <stepkut> k
20:37:59 <stepkut> I shall update this ticket, http://hackage.haskell.org/trac/ghc/ticket/5751
20:38:11 <stepkut> thanks a ton!
20:39:21 <rwbarton> do you have any idea why/where it hangs?
20:42:04 <stepkut> rwbarton: my guess is the type checker is busted and creates a case where the code runs around in circles trying to resolve an instance
20:42:14 <stepkut> rwbarton: that happened before if you look at the other bugs referenced at the bottom
20:42:31 <rwbarton> Hmm. but it compiles fine, right? so must be a recursive dictionary or something?
20:42:38 <stepkut> yeah
20:43:28 <stepkut> rwbarton: if you enable OverlappingInstances and add 'instance Widgets (IdentityT IO)' then it works
20:44:11 <rwbarton> oh, lines 22 and 24 are a bit odd
20:44:16 <stepkut> rwbarton: yes
20:44:26 <stepkut> rwbarton: it's weird code for sure
20:45:13 <rwbarton> I guess it is trying to use the Widgets dictionary that it knows it has from the superclass, rather than the one defined in the instance
20:45:19 <rwbarton> which of course is nonsense
20:45:26 <rwbarton> or something like that
20:46:05 <gienah> stepkut: last line in my tests: ghc-7.4.1-rc1: <<loop>>  ghc-7.2.2: done.  ghc-7.0.4: done.
20:46:33 <stepkut> gienah: sweet! Thanks!
20:50:45 <stepkut> ticket updated. Thanks everyone! http://hackage.haskell.org/trac/ghc/ticket/5751
20:50:58 <stepkut> if 7.4 is delayed now, you can all blame me for filing this bug :p
20:51:08 <Axman6> jerk
20:51:11 <Axman6> :P
20:54:52 <parcs`> "class (Widgets x) => MonadRender x" "instance MonadRender m => Widgets m" what
20:55:04 <stepkut> :)
20:55:08 <rwbarton> indeed
20:55:11 <stepkut> hey, it works under 7.0
20:55:32 <parcs`> yeah, that's true
20:55:37 <stepkut> and it compiles under 7.4
20:55:40 <parcs`> we'll see what the overlords have to say
20:55:42 <stepkut> just doesn't work right :)
20:55:55 <rwbarton> can you reduce the issue to those two lines (or so)?
20:56:07 <rwbarton> I'd try if I had a 7.4 installation
20:56:50 <stepkut> rwbarton: I started with tens of thousands of lines and hundreds of library depends.. that is pretty darn reduced already
20:57:40 <stepkut> oh, if you give 'web' a less vague type signature, (like, web :: IdentityT IO ()), I believe it also works
20:57:52 <parcs`> from +RTS --help: -B       Sound the bell at the start of each garbage collection
20:58:07 <djahandarie> Haha
20:58:40 <stepkut> in a less pruned down version of the test case, switching the order of Widgets and XMLGenerator in the web type signature also made it work.
20:59:16 <rwbarton> lovely
20:59:47 <karoyakani> help
21:00:03 <parcs`> hello
21:00:04 <karoyakani> quit
21:01:01 <parcs`> i don't even...
21:02:50 <sanjoyd> How are data constructors different from regular functions?
21:04:00 <Sgeo> sanjoyd, you can pattern match on data constructors
21:04:04 <liyang> You can't pattern match on functions.
21:04:22 <liyang> {-# RULES ... #-} aside ...
21:04:24 <Sgeo> > case (Just 5) of { Just x -> x ; Nothing -> 20 }
21:04:25 <lambdabot>   5
21:04:48 <karoyakani> ??list
21:05:00 <sanjoyd> But the other way?  Are there places I can use functions and not data constructors?
21:05:13 <shachaf> sanjoyd: Yes. For example True.
21:05:25 <Sgeo> shachaf, .. what?
21:05:36 <shachaf> True is a data constructor.
21:05:44 <Sgeo> Oh, derp
21:06:11 <Sgeo> sanjoyd, data constructors that have an argument are functions
21:06:20 <sanjoyd> What I meant is, is "Just" the same as (\x -> Just x)?
21:06:34 <Sgeo> sanjoyd, yes
21:06:38 <sanjoyd> Sgeo: thanks!
21:06:41 <shachaf> sanjoyd: That depends on what you mean by "the same".
21:06:42 <liyang> true :: Bool; true = True
21:06:44 <Sgeo> > (Just . Just) 20
21:06:46 <lambdabot>   Just (Just 20)
21:06:47 <shachaf> > Just {}
21:06:48 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
21:06:53 <shachaf> > (\x -> Just x) {}
21:06:54 <lambdabot>   <no location info>: Empty record update
21:07:09 <Jafet> Just is both a constructor and a function.
21:07:24 <Jafet> Nothing is both a constructor and a data value
21:07:25 <Sgeo> > :t Just
21:07:26 <lambdabot>   <no location info>: parse error on input `:'
21:07:27 <shachaf> But the function (Just) is eta-equivalent to the function (\x -> Just x).
21:07:38 <Sgeo> :t Just
21:07:39 <lambdabot> forall a. a -> Maybe a
21:07:40 <sanjoyd> shachaf: I meant is there a context where they would both behave differently?  I'm guessing now that the answer is no.
21:07:52 <Jafet> Constructors appear in patterns; functions appear in expressions.
21:08:00 <liyang> It's unconstructive to distinguish between values and functions here. Functions *are* values. But values are different from constructors.
21:08:19 <shachaf> Unconstructive, eh?
21:08:48 <Sgeo> All functions are values, not all values are constructors
21:08:48 <liyang> It's a word now.
21:08:58 <Sgeo> erm, not all values are functions either
21:09:25 <liyang> Let's not talk about functions... it's not really relevant here.
21:09:33 <Sgeo> Scrap the "not all values are constructors"
21:09:39 <Jafet> Values and constructors are syntactically distinct
21:09:53 <Sgeo> Jafet, I ... braino'd
21:10:02 <Jafet> It's a common braino
21:10:21 * Jafet somehow pictures Cheerios.
21:11:20 <dolio> Constructors are values.
21:11:54 <rwbarton> or if you prefer, every constructor has an associated value which is written the same way
21:12:11 <Jafet> Pedant hour begins
21:12:14 <Jafet> @where report
21:12:14 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
21:12:21 <shachaf> Ooh, my favourite hour!
21:12:47 <shachaf> One pedantry medal will be awarded at 09:53.
21:16:01 <mm_freak> Sgeo: "all values are functions" is wrong
21:16:48 <Sgeo> mm_freak, isn't that what I said?
21:17:24 * shachaf considers giving pedantry commentary.
21:17:43 <shachaf> That would be a fun competitive sport, I'm sure.
21:17:46 <mm_freak> oh
21:17:58 <Jafet> So, the report uses "constructor" also to refer to values derived from constructors.
21:18:03 <mm_freak> Sgeo: sorry, i didn't see the "not" and that misconception is so common =)
21:18:10 <Jafet> Also...
21:18:17 <Jafet> > 3.14159 :: Rational
21:18:18 <lambdabot>   314159 % 100000
21:18:28 <djahandarie> > pi :: Rational
21:18:28 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
21:18:29 <lambdabot>    arising from a us...
21:18:29 <mm_freak> you can't pattern-match on non-constructor values though
21:18:33 <djahandarie> :(
21:18:55 <shachaf> > let f 3.14159 = True; f _ = False in f 3.14159
21:18:57 <lambdabot>   True
21:19:36 <Jafet> > 1 == (1 + 1.00000000000000000001)
21:19:38 <lambdabot>   False
21:19:51 <mm_freak> i think the only exception to that rule is where you have both a Num and an Eq instance, which is sort of a special case
21:20:04 <karoyakani> prefix: list
21:20:07 <Jafet> 1 is a constructor too
21:20:10 <mm_freak> > (\3 -> 4) 3
21:20:11 <lambdabot>   4
21:20:12 <mzero> Jafet: really? in the report? reference to a section that does so?
21:20:22 <mm_freak> Jafet: no, it's not
21:20:26 <karoyakani> preflex: help
21:20:27 <preflex>  try 'help help' or see 'list' for available commands
21:20:40 <karoyakani> preflex: list
21:20:40 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
21:20:41 <preflex>  ZCode: [zdec, zenc]
21:20:43 <mm_freak> the literal "1" is translated to "fromInteger (1 :: Integer)"
21:20:57 <Jafet> It's a constructor for Integer, I suppose
21:21:02 <shachaf> karoyakani: You can /msg preflex if you want a longer conversation.
21:21:03 <mm_freak> and that (1 :: Integer) involves magic
21:21:05 <djahandarie> Recursively? :-)
21:21:08 <djahandarie> Aw :(
21:21:21 <mm_freak> Jafet: not really…  Integer doesn't have constructors, but for pattern-matching it has Eq, which is also strictly required
21:21:25 <Jafet> mzero: all over http://www.haskell.org/onlinereport/haskell2010/haskellch3.html
21:21:44 <shachaf> The Report also says that getChar is a function.
21:21:49 <mm_freak> Integer is an opaque type
21:22:39 <mzero> i don't seen any use of the term constructor there to mean a value
21:23:15 <Jafet> mzero: eg. 3.3: "Function application is written e1 e2. [...] Because e1 could be a data constructor, partial applications of data constructors are allowed."
21:23:39 <mzero> yes - that isn't a value
21:23:58 <mm_freak> i wonder, when you write your own Prelude, do you have to provide a Read instance for Integer?
21:24:00 <Jafet> Expressions can only contain values
21:24:05 <mzero> ?
21:24:11 <mm_freak> otherwise i don't see how the magic from literals to Integer can work
21:24:25 <shachaf> mm_freak: A *Read* instance?
21:24:31 <Jafet> mm_freak: using GHC's literal parser, of course
21:24:42 <Jafet> mm_freak: we're not as chaotic as C++ yet
21:24:42 <shachaf> Read is just a type class; it has nothing to do with how GHC parses your source.
21:24:50 <rwbarton> the question is what type does fromInteger have I think
21:24:56 <mm_freak> Jafet: data Integer = Neg Integer | Zero | Succ Integer
21:25:06 <mm_freak> in your own Prelude
21:25:07 <mzero> umm, I read that as a definition of a syntactic expression, which isn't concerned with values at all
21:25:08 <Jafet> mzero: (e1 e2) is an expression, so e1 and e2 are values. But the report referred to e1 being a constructor as well.
21:25:29 <mm_freak> the compiler can't magically figure out how to convert the literal "1" to a value of your Integer type
21:25:42 * ski thinks `True' is a value
21:25:43 <shachaf> mm_freak: Sure it can. It calls fromInteger on 1 :: GHC.Prim.Integer
21:26:03 <mm_freak> ah, i see
21:26:07 <Jafet> Can you even define Integer?
21:26:08 <mzero> no, the report talks in terms of  "a value of e1" etc... e1 is not, itself, a value
21:26:10 <mm_freak> so it's implementation-dependent
21:26:13 <mzero> it is an expression
21:26:29 <shachaf> Jafet: A type called Integer in your own module? Why not?
21:26:42 <shachaf> Hmm, does the Report even talk about hiding Prelude?
21:26:54 <mm_freak> i guess not…  it's too short for that =)
21:26:56 <Jafet> mm_freak isn't talking about the report, obviously
21:27:02 <Jafet> He doesn't want the pedantry medal
21:27:11 <mzero> notes  from §3.6 " where True and False are the two nullary constructors from the type Bool, as defined in the Prelude "
21:27:16 <shachaf> Oh, yes, it does.
21:27:48 <shachaf> But I expect that the Report doesn't support writing your own module named Prelude.
21:27:57 <shachaf> So your Prelude-replacement can just refer to Prelude.Integer.
21:28:13 <mzero> shachaf: yes, the report explains how to hide Prelude
21:28:21 <Jafet> Sure it does. All the names in the report, however, refer to the report's Prelude.
21:28:22 <mm_freak> well, yeah…  NoImplicitPrelude is an extension after all
21:28:42 <mm_freak> you can write "import Prelude ()", but that doesn't do the trick
21:28:52 <Jafet> The real meaning of NoImplicitPrelude is that many of the language constructs use your Prelude instead.
21:29:06 <mzero> §5.6.1
21:29:14 <shachaf> mzero: Yes, I saw.
21:29:30 <shachaf> mzero: How're the BayHac plans going, by the way? :-)
21:29:37 <mm_freak> Jafet: furthermore, the "import Prelude ()" doesn't hide everything
21:29:42 <mzero> shhhhh.... I'm coding.....   ;-P
21:30:10 <shachaf> Coding sense into the people of #haskell.
21:30:45 <shachaf> Jafet: Well, the in-scope definitions, I think, not your Prelude.
21:30:54 <Axman6> import Prelude hiding (if)
21:30:59 <shachaf> Can you let (>>=) = ... in ... for NoImplicitPrelude do?
21:31:15 <cmccann> shachaf, yes
21:31:27 <Jafet> You can even let fromInteger
21:31:31 <cmccann> in scope means in scope, it turns out
21:31:44 <Axman6> i don't think that rebinds the meaning of do notation though...
21:31:55 <rwbarton> well, certain pedants were claiming otherwise
21:32:04 <cmccann> well, I assume we're talking about rebindable syntax
21:32:07 <ski> (so `NoImplicitPrelude' makes `do' use dynamical scope, on the syntax level)
21:32:12 <Jafet> Oh, that's a separate extension
21:32:21 <cmccann> it's separate now
21:32:40 <Jafet> But yeah, people used it to make do use indexed monads
21:32:45 <Jafet> And other things
21:32:53 <cmccann> maybe it used to be part of something else, can't remember
21:32:55 <cmccann> anyway, yeah
21:32:59 <Sgeo> indexed monads?
21:33:06 <cmccann> with rebindable syntax you can replace all kinds of stuff
21:33:42 <shachaf> cmccann: Oh, right.
21:33:46 * shachaf was confusing extensions.
21:34:15 <Jafet> So I suppose NoImplicitPrelude just hides all the normal instances
21:34:21 <cmccann> yeah
21:34:28 <cmccann> and doesn't import it, obviously
21:34:37 <cmccann> but that's how it differs from "import Prelude ()"
21:34:38 <Sgeo> Trying NoImplicitPrelude in GHCi and unimporting Prelude still lets me type literal integers
21:34:44 <cmccann> GHCi is weird
21:35:01 <Jafet> Literal integers are syntax
21:35:03 <Sgeo> > :t 5
21:35:03 <Sgeo> 5 :: GHC.Num.Num a => a
21:35:04 <lambdabot>   <no location info>: parse error on input `:'
21:35:12 <Jafet> But try 5 :: Int
21:36:02 <Sgeo> That's not a demonstration of NoImplicitPrelude, that's a demonstration of Prelude not being loaded, I think
21:36:16 <shachaf> Sgeo: lambdabot is still not ghci
21:36:27 <Sgeo> shachaf, I was pasting from my GHCi
21:36:49 <shachaf> Don't use > as your ghci prompt, then.
21:36:51 <shachaf> Use λ>
21:36:54 <Jafet> Well, Prelude is normally always loaded in a Haskell program.
21:37:03 <shachaf> Oh, you unimported it.
21:37:04 <shachaf> Fine.
21:37:13 <mm_freak> what is the extension called?
21:37:19 <Sgeo> NoImplicitPrelude
21:37:26 <rwbarton> did you use ghci -XNoImplicitPrelude or :set -XNoImplicitPrelude?
21:37:31 * cmccann likes his GHCi prompt
21:37:38 <mm_freak> i mean the one for rebinding do-syntax
21:38:01 <cmccann> "∀x. x ⊢" is a much nicer prompt I think
21:38:20 <shachaf> cmccann: What code points are those?
21:38:24 <shachaf> I can't read most Unicodepoints.
21:38:29 <cmccann> shachaf, pf
21:38:34 <Sgeo> rwbarton, the latter
21:38:43 <cmccann> shachaf, forall x. x turnstile
21:38:51 <Jafet> "(print =<<) $ "
21:38:57 <shachaf> Turnstile?
21:39:02 <rwbarton> |-
21:39:06 <Sgeo> Sideways bottom
21:39:14 <shachaf> Oh.
21:39:18 <cmccann> http://en.wikipedia.org/wiki/Turnstile_(symbol)
21:40:02 <shachaf> Turnstile, not to be confused with turnstile or turnstile.
21:40:06 <Sgeo> Jafet, 5
21:40:11 * shachaf is lucky kmc isn't here.
21:40:24 <Sgeo> > (print =<<) $ 5
21:40:24 <ski> Sgeo : `class IndexedMonad m where return :: m i i a; (>>=) :: m i j a -> (a -> m j k b) -> m i k b'
21:40:25 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO a))
21:40:25 <lambdabot>    arising from the literal ...
21:40:42 <Jafet> Asian turnstiles
21:40:54 <cmccann> shachaf, neither of those looks like a turnstile to me
21:41:12 <mm_freak> found it
21:41:16 <mzero> > (print =<<) $ return 5
21:41:17 <mm_freak> it's -XRebindableSyntax
21:41:18 <lambdabot>   <IO ()>
21:41:18 <cmccann> on looks like Japanese phonetic script though
21:41:37 <mzero> but why you''d do that over     print 5    is beyond me!
21:41:57 <shachaf> mzero: For the reason rwbarton and I were discussing earlier.
21:42:19 * rwbarton tries to figure out the reason
21:42:27 <shachaf> Jafet was probably thinking of IO actions.
21:42:33 <Sgeo> mm_freak, oh
21:42:45 <shachaf> rwbarton: Oh, I meant why you'd do "(print =<<) $" instead of "print =<<".
21:42:56 <shachaf> I guess that's not the same as what mzero was saying.
21:43:00 <Sgeo> > 5
21:43:00 <Sgeo> <interactive>:1:1: Not in scope: `fromInteger'
21:43:00 <Sgeo> <interactive>:1:1: Not in scope: `>>'
21:43:01 <lambdabot>   5
21:43:12 <Sgeo> So what does NoImplicitPrelude do?
21:43:40 <shachaf> ghci is a bad place to test GHC extensions.
21:43:43 <shachaf> Go make a file.
21:43:46 <Sgeo> ^^above is with RebindableSyntax
21:44:40 <Sgeo> "-XRebindableSyntax implies -XNoImplicitPrelude."
22:07:51 <Sgeo> Is there a way to tell Data.Lens.Template that I want lenses to have the same name as accessors?
22:07:59 <Sgeo> I don't want to do the underscore thing, I think
22:08:41 <c_wraith> seems like that'd be a pain
22:08:57 <c_wraith> you'd have to put them in a different module than the data type, just to avoid the name clash
22:09:34 <shachaf> Sgeo: What do you mean?
22:09:42 <shachaf> You can't have two different values with the same name.
22:10:05 <Sgeo> Sometimes it may be more convenient for users of my library to use record syntax, I think
22:10:31 <Sgeo> (As though there will be any users other than me :/ )
22:12:45 <Sgeo> With lenses, it should be easy to compose several sets on one structure, like:
22:13:03 <Sgeo> setL x 5 . setL y 2 . setL z 3 $ myRecord
22:13:23 <Axman6> > lcm 64 96
22:13:24 <lambdabot>   192
22:13:29 <Sgeo> Right?
22:14:09 <shachaf> Sgeo: That's how functions usually work, yes. :-)
22:14:24 <Sgeo> ^= has the correct fixity for that sort of thing too?
22:19:21 <augur> what sort of compiled code does GHC produce?
22:19:51 <ion> The kind with machine instructions.
22:19:58 <augur> :P
22:20:13 <augur> but i mean, its essentially a stack evaluator, no?
22:20:26 <augur> with some execution magic for io, however thats implemented
22:20:39 <shachaf> Stack evaluator?
22:21:08 <quicksilver> I certainly wouldn't call it a stack machine
22:21:15 <shachaf> @google spineless tagless
22:21:16 <lambdabot> http://research.microsoft.com/apps/pubs/default.aspx?id=67083
22:21:16 <lambdabot> Title: Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless  ...
22:21:20 <augur> well, call frame stack widgetry
22:21:29 <augur> ugh spineless tagless g-machines
22:21:36 <augur> who even knows what those are!
22:21:43 <shachaf> The person who wrote that paper.
22:21:44 <ehuber_> sounds like something out of an aliens movie
22:21:46 <quicksilver> people who've read that paper
22:21:49 <shachaf> And fortunately he wrote an explanation in that paper.
22:22:06 <quicksilver> although GHC is not tagless any more
22:22:06 <augur> hush you
22:22:11 <quicksilver> and ISTR it's not entirely spineless
22:22:15 <shachaf> quicksilver: Finally.
22:22:17 <augur> noones ever read that paper!
22:22:25 <quicksilver> but the paper/book is still a good guide
22:22:28 * quicksilver has.
22:22:43 <augur> liar
22:23:07 <quicksilver> dullad
22:23:08 <shachaf> augur: Why do you ask for help -- in very vague terms -- and then insult people who answer you?
22:23:14 <quicksilver> dullard, rather
22:23:22 <augur> shachaf: you have no sense of humor
22:23:36 <shachaf> You have no sense of tact.
22:23:48 <augur> pfft!
22:24:29 <augur> ill read the stg paper tomorrow. im so tired :\
22:24:52 <shachaf> augur: It's ~70 pages.
22:25:13 <augur> ok so ill read it tomorrow and maybe the day after!
22:41:48 * hackagebot bindings-levmar 1.0.0.2 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.0.0.2 (BasVanDijk)
22:41:50 * hackagebot levmar 1.2.0.1 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.0.1 (BasVanDijk)
22:46:48 * hackagebot bindings-libusb 1.4.4.1 - Low level bindings to libusb.  http://hackage.haskell.org/package/bindings-libusb-1.4.4.1 (BasVanDijk)
23:21:48 * hackagebot ghc-mod 1.0.6 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.6 (KazuYamamoto)
23:44:16 <Sgeo> "That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.
23:44:16 <Sgeo> "
23:44:33 <Sgeo> What if I want to make a quasiquoter that's only intended for use as top-level declarations?
23:44:58 <quicksilver> put 'error' in the other cases?
23:45:37 <Sgeo> That feels ... not typesafe somehow, I think
23:45:53 <Sgeo> But I guess it will be detected when compiling the module using the quasiquoter anyway
23:46:49 * hackagebot static-hash 0.0.1 - Immutable hash  http://hackage.haskell.org/package/static-hash-0.0.1 (KazuYamamoto)
23:48:27 <quicksilver> Sgeo: well, anything in 'Q' can have IO in it, which means you can display warnings or force errors at compile time
23:50:48 <quicksilver> so QuasiQuoter { quoteExp = runIO $ error "SgeoCoolQQ only to be used in Decls" } should do something reasonable
23:51:58 <c_wraith> runIO error?
23:52:03 <c_wraith> that's an odd combination
23:52:11 <c_wraith> might as well just be error
23:52:50 <c_wraith> anyway, the accepted way to not compile, according to the docs, is to use fail in Q
23:52:50 * quicksilver wasn't sure
23:53:04 <quicksilver> that sounds better certainly :)
23:53:17 <c_wraith> I had to look this up recently
23:53:19 <c_wraith> :)
23:53:28 <quicksilver> c_wraith: I wasn't sure if all evaluation was guaranteed to happen at compile time
23:53:34 <quicksilver> probably not thinking very clearly
23:53:40 <c_wraith> it's just a wrapper around IO
23:53:45 <c_wraith> it has to run the whole thing
23:53:55 <c_wraith> but yeah, use fail
23:54:00 <c_wraith> it does the right thing
23:57:50 <Sgeo> Isn't that rare for fail?
23:58:02 <Sgeo> Or, well, I've heard "fail is an abomination" so many times
23:59:15 <rwbarton> it's not that every specific fail is bad
23:59:29 <rwbarton> just the inclusion of fail as a Monad method
