00:23:19 <LordTrev> exit
00:23:21 <LordTrev> er
00:23:24 <LordTrev> <_<
00:51:29 <nexion> I've had a need (or so I think) to use an MVar as a mutex because IO can't be performed in STM, but this opens up the possibility of forgetting to acquire the mutex... is there some way to require that a certain function not be called unless the mutex is held? even more importantly, am I on the wrong track with this?
00:52:24 <nexion> for similar scenarios, I return some data from the atomically and then perform IO with that
00:52:58 <nexion> but there is a space between the atomically is run and the IO is run in which race conditions could occur
00:53:22 <nexion> hence the idea to use a mutex
00:53:28 <rostayob> nexion: well the thing about STM is that you don't worry about those things. For MVars, just use 'withMVar'
00:53:36 <rostayob> wrap the function with withMVar
00:53:47 <rostayob> withMVar foo (\_ -> function)
00:54:14 <rostayob> but there is no way to "mark" the function itself
00:56:52 <nexion> yup.. I've got a function that basically does that
00:57:12 <nexion> so my design isn't an unnecessary evil?
00:57:39 <rostayob> nexion: well, doing IO while doing that kind of stuff is evil
00:57:43 <rostayob> why do you need that?
00:58:29 <rostayob> I mean you might need to do that in some situations
00:58:57 <nexion> I've got a function "onWaitingListUpdated" which sends out network messages to everyone on the waiting list with their position in the list
00:59:10 <rostayob> nexion: the best thing to do is to explain what you're trying to do
00:59:12 <nexion> which I call after the atomically block that makes changes to the list
00:59:31 <rostayob> ok
00:59:48 <nexion> so if I have two threads running the same function
01:00:25 <nexion> the atomically and the IO need to be sequenced
01:00:30 <rostayob> why?
01:00:39 <rostayob> ah
01:00:56 <rostayob> well, how are you sending the messages?
01:01:42 <nexion> hm..
01:01:56 <rostayob> because unless you're doing blocking sends you don't have such guarantees anyways
01:02:22 <nexion> actually.. each client has a sender loop that reads a TChan
01:02:29 <nexion> so you gave me an idea
01:02:36 <nexion> perhaps this is doable nicely after all
01:02:57 <rostayob> uh, ok
01:03:26 <nexion> but basically, the goal is to avoid a sequence like: atomically1 atomically2 io2 io1
01:03:54 <rostayob> nexion: I understand
01:04:00 <nexion> since io1 will send older data than was already sent
01:04:26 <nexion> so if I make my message sender function in STM, this works beautifully
01:04:28 <nexion> :)
01:04:37 <rostayob> nexion: a maybe nicer solution is to queue the messages to send in a MVar and have another function send them
01:04:49 <rostayob> instead of using the MVar as a mutex
01:05:16 <nexion> I think I can drop the MVar completely and just use STM
01:05:22 <rostayob> well, that would be better
01:05:35 <rostayob> but in general I wouldn't do blocking IO like that
01:05:51 <rostayob> (because if you don't do blocking IO you have the same problem)
01:06:49 <nexion> it won't be blocking IO in this case :)
01:07:05 <nexion> it'll write to a TChan, which won't block
01:07:10 <rostayob> nexion: well, if you're sending the messages without getting acks, then how do you know that they arrive in the correct order?
01:07:12 <rostayob> ah, doing STM
01:07:15 <nexion> and asynchronously send the message through the network
01:07:35 <nexion> but TChan forces the desired order
01:07:41 <rostayob> nexion: you're sending them in order
01:07:47 <rostayob> but you don't know they're arriving in order
01:08:03 <nexion> TCP ensures that
01:08:19 <kallisti> how do you represent a FunPtr to a function with no arguments?
01:08:26 <kallisti> FunPtr return_value  ?
01:08:37 <kallisti> or something like:  FunPtr (() -> return_value)
01:08:46 <rostayob> nexion: right
01:09:07 <nexion> rostayob, thanks :)
01:09:32 <rostayob> nexion: well, does TCP ensure that for different messages?
01:10:37 <nexion> what do you mean by different messages?
01:11:52 <nexion> each client has a thread that reads the "send" TChan for that client, and sends the messages using sendAll (simplified a bit, but that's the core of it)
01:11:58 <rostayob> I mean TCP will guarantee that packets will be ordered in the same connection
01:12:14 <nexion> ah, gotcha
01:12:25 <nexion> for what I'm doing, that's fine
01:12:33 <rostayob> ok :)
01:12:36 <rostayob> I just woke up eheh
01:12:36 <nexion> ty
01:13:00 <rostayob> nexion: oh I was just the rubber duck you solved your own problem :)
01:13:21 <rostayob> going to have breakfast
01:14:22 <elliott> would a TMVar lock work?
01:14:37 * elliott didn't really read :)
01:15:32 <nexion> oh cool
01:16:08 <nexion> good to know
01:17:16 <mr_sleepy> http://www.willamette.edu/~fruehr/haskell/evolution.html
01:17:20 <mr_sleepy> that one was funny
01:17:56 <Palmik> Is there some sort of mapM2 :: (Monad m, Traversable t) => (a -> b -> m c) -> t a -> t b -> m (t c) (which is in essence similar to zipWith) and mapM3 in the same fashion?
01:18:07 <Palmik> Or do I have to roll my own?
01:21:27 <frerich2> @hoogle (a -> b -> m c) -> t a -> t b -> m (t c)
01:21:28 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:21:28 <lambdabot> Data.IntMap differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
01:21:28 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
01:21:47 * elliott wonders what that's meant to do
01:22:00 <elliott> oh, zipWith for any Traversable or something?
01:22:01 <frerich2> Palmik: I guess zipWithM is close enough, except that it doesn't work on any traversable.
01:22:08 <elliott> I don't think Traversable can do that
01:22:15 <elliott> it only supports rebuilding "the same" structure, modified
01:22:24 <elliott> how would it combine structures of different shapes?
01:22:49 <Palmik> Yeah, maybe being Traversable is not enough.
01:23:12 <elliott> class Zippable t where zipA :: (Applicative f) => (a -> b -> f c) -> t a -> t b -> f (t c)
01:23:15 <elliott> *zipWithA
01:23:17 <elliott> done :P
01:25:32 <Palmik> I often find myself, having function f :: a -> b -> m c, wanting function f' :: Maybe a -> Maybe b -> m (Maybe c) (the same goes for a -> b -> c -> m d functions, etc.)
01:27:28 <elliott> Palmik: you could use MaybeT
01:27:35 <elliott> but it'd be more noisy than writing it out yourself I think
01:28:51 <Palmik> Yeah, I will just write few withMaybe1/2/3 withMaybeM1/2/3 :) Thanks.
01:29:05 <si14> guys, please, can you help me to remember? I've seen something like contracts in haskellwiki (pieces of constraints on function parameters written in comments like { ... } before the type signature), but can't remember what it was
01:37:47 <quicksilver> Palmik, elliott : runMaybeT ( f <$> aa <*> bb ) is not very noisy
01:38:01 <quicksilver> and it's nicer to have one function (runMaybeT) than 3 (withMaybe1/2/3)
01:38:11 <elliott> quicksilver: that won't work.
01:38:15 <elliott> (aa :: Maybe a).
01:38:26 <elliott> Maybe doesn't match MaybeT m
01:38:42 <quicksilver> hmm
01:38:51 <elliott> you need "maybe mzero return" so it's at least runMaybeT (f <$> liftMaybe aa <*> liftMaybe bb)
01:38:55 <Axman6> lift aa?
01:38:57 <quicksilver> I see
01:38:58 <elliott> which is noisier than defining liftMaybeM2 or something
01:39:07 <elliott> Axman6: that lifts m, not Maybe
01:39:17 <Axman6> ah right
01:39:22 <Axman6> return?
01:39:37 <elliott> Palmik: there is http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Zip.html
01:39:49 <elliott> but only for pure zipping functions
01:39:55 <elliott> Axman6: no, that lifts Identity :)
01:40:00 <elliott> MaybeT . return or maybe mzero return
01:41:46 <Palmik> Thanks, i will take a look at it.
01:43:44 <elliott> :t (?mzipWith :: (a -> b -> c) -> m a -> m b -> m c) (?f :: Int -> Int -> m Int)
01:43:45 <lambdabot>     Could not deduce (?mzipWith::(a -> b -> c) -> m a -> m b -> m c)
01:43:45 <lambdabot>       from the context ()
01:43:45 <lambdabot>       arising from a use of implicit parameter `?mzipWith'
01:43:49 <elliott> hmph
01:44:07 <elliott> I've forgotten how to do that :(
01:44:21 <elliott> :t let mzipWith :: (a -> b -> c) -> m a -> m b -> m c; mzipWith = undefined; f :: Int -> Int -> m Int; f = undefined in mzipWith f
01:44:22 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). m1 Int -> m1 Int -> m1 (m Int)
01:44:34 <elliott> Palmik: right, MonadZip + Traversable gets you it
01:44:43 <elliott> sequence (mzipWith f a b)
01:48:06 <quicksilver> elliott: nice
01:49:21 <Palmik> elliott, hmm, good find. Thanks.
01:51:47 <elliott> (unfortunately there is no Maybe instance :))
01:59:16 * hackagebot websockets 0.5.2.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.5.2.0 (JasperVanDerJeugt)
02:01:14 <MichaelBurge> Hmm, I noticed that in GHCi if you type "(,) a b" you get "(a, b)". But I can't find this comma operator on Hoogle or in any of the other usual places
02:01:21 <MichaelBurge> is it something special to the interpreter?
02:01:40 <Axman6> i believe it's built into the language
02:02:04 <Axman6> also, it's not really an operator, more a constructor, like Just
02:02:15 <Jaak> > (,2) 1
02:02:16 <lambdabot>   Illegal tuple section: use -XTupleSections
02:03:41 <quicksilver> MichaelBurge: not sure why hoogle can't see it, bit odd
02:04:00 <quicksilver> the only special thing about it is that it uses funny syntax
02:04:18 <quicksilver> apart from that (,) is a perfectly normal binary constructor (also type constructor for the related type)
02:04:27 <MichaelBurge> I might actually start using that TupleSections extension - I've been making lambdas every time I needed that
02:04:36 <MichaelBurge> quicksilver: Is there any reason it can't be an ordinary function?
02:06:11 <frerich2> I have a hard time imagining how (,) could be defined wtihin the language (much like (:)).
02:06:20 <frerich2> Maybe I'm just being dense tho.
02:07:34 <MichaelBurge> *Main> let (&*&*) a b = (a, b)
02:07:34 <MichaelBurge> *Main> 7 &*&* 5
02:07:34 <MichaelBurge> (7,5)
02:07:46 <elliott> frerich2:
02:07:51 <elliott> data MyTuple a b = Tuple a b
02:08:03 <elliott> (,) is just a reserved operator.
02:08:18 <elliott> With the sugar that (a,b) === (,) a b, slightly different from normal infix ops.
02:08:44 <sipa> : (,,)
02:08:49 <sipa> :t (,,)
02:08:50 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
02:08:56 <elliott> indeed, they are defined like data (,,) a b c = (,,) a b c in GHC.Tuple or whatever it was called
02:09:17 <MichaelBurge> Oooh, you can more than one
02:10:48 <MichaelBurge> :t (,,,,)
02:10:49 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
02:10:58 <elliott> I wonder if (,,3,,) works with tuple sections
02:12:10 <ovechkin> how does 'minlist = head . sort' work in O(n) and not nlogn?
02:14:17 * hackagebot flock 0.3.1 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1 (ErikHesselink)
02:15:16 <opqdonut> ovechkin: it works in O(n) if sort is e.g. a selection sort
02:15:21 <opqdonut> due to laziness
02:15:38 <kallisti> sort in GHC is a mergesort however.
02:16:17 <ovechkin> kallisti: yea, so how does this happen?
02:16:22 <ovechkin> or is this blog wrong?
02:16:27 <kallisti> probably wrong.
02:16:38 <ovechkin> http://www.updike.org/articles/Pure_Lazy_Functional
02:16:41 <kallisti> as far as I know that's not how mergesort works.
02:16:52 <Axman6> uh, i believe it is O(n) with mergesort too
02:17:11 <sipa> :t (,3,)
02:17:12 <lambdabot> Illegal tuple section: use -XTupleSections
02:17:15 <Axman6> to produce the first element, you only need to look at every element once, hence O(n)
02:18:23 <ovechkin> but doesnt head . sort, sort the list first?
02:18:32 <kallisti> no
02:18:42 <ovechkin> what am i missing here?
02:18:45 <Axman6> no, it only sorts enough of the list to give head its result
02:18:46 <kallisti> it sorts it enough to produce the first element.
02:18:57 <Axman6> and the first element is all that head needs to return
02:19:08 <ovechkin> hrmm
02:19:24 <ovechkin> so haskell just does enough work to satisfy the leftmost function?
02:19:30 <Axman6> ovechkin: do you understand how to implement mergesort in haskell?
02:19:47 <kallisti> ovechkin: that's a bit of an oversimplification
02:19:48 <ovechkin> Axman6: no
02:19:49 <Axman6> it does enough work to produce the answer you've asked it to. and it's not done my magic
02:20:05 <ovechkin> ok, thats pretty neat
02:22:50 <kallisti> Axman6: I wasn't sure if mergesort would interact the same way due to it being not quite so linear in nature as selection sort.
02:22:55 <Axman6> ovechkin: of course there are more efficient O(n) algorithms for finding the minimum element
02:23:00 <kallisti> however, I haven't learned exactly how GHC's mergesort works.
02:23:24 <Axman6> kallisti: well, the obvious way to implement mergesort produces the first element in O(n) time
02:24:33 <kallisti> ovechkin: I simpler example would be that if you take the length of a list it won't actually evaluate any of the elements.
02:24:37 <kallisti> s/I/a/
02:24:44 <opqdonut> Axman6: it does?
02:25:01 <kallisti> > length [error "a", error "b", error "c"]
02:25:02 <lambdabot>   3
02:25:18 <kallisti> > error "danger!"
02:25:18 <lambdabot>   *Exception: danger!
02:26:34 <frerich2> Axman6: Hmm, it never occurred to me that "head . sort" would be O(n). I figure that this is because of Haskell being lazy, but is this also made possible by the particular algorithm used by 'sort'?
02:27:04 <elliott> frerich2: yeah; http://apfelmus.nfshost.com/articles/quicksearch.html
02:27:57 <JaffaCake> b
02:28:03 <yitz> i doubt that head.sort is O(2) in the current implementation in Data.List
02:28:09 <yitz> O(n)
02:28:17 <kallisti> ovechkin: note that since lists in Haskell are linked lists, it does have to traverse the entire list to get its length, but it doesn't have to know anything about the elements so they're not evaluated at that point.
02:28:57 <frerich2> elliott: Ok, good, so my faith in my understanding remains. I would have been impressed (and then scared) if this would've worked with *any* sortign algorithm :-) And thanks for the link, reading it right now.
02:28:58 <Jafet> It is.
02:29:11 <Jafet> It's always been, in fact.
02:29:18 * hackagebot string-combinators 0.6.0.3 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6.0.3 (BasVanDijk)
02:29:26 <yitz> last i looked the approach is to start by chopping up the input into lists of length two
02:29:39 <elliott> i agree with yitz, seems like it's very sensitive to implementation details of the sort
02:29:45 <Jafet> The algorithm is mostly irrelevant, in fact.
02:29:49 <elliott> ?
02:29:55 <elliott> did you read the link I linked? :P
02:30:03 <Jafet> The Report's implementation of sort also makes head.sort O(n).
02:30:06 <Jafet> I think.
02:30:06 <elliott> it's explicitly noted that it's sensitive to even the implementation of mergesort used
02:30:27 <elliott> JaffaCake: c
02:30:36 <yitz> Jafet: i'm talking about the implementation distributed by GHC.
02:30:41 <kallisti> minList = head.bogosort   -- guaranteed O(n)
02:30:45 <JaffaCake> sorry, typing emacs commands into IRC :(
02:30:48 <Eduard_Munteanu> Yeah, sure it is. It's even more apparent for quicksort since pivots end up at their final location after every iteration.
02:31:27 <Eduard_Munteanu> But that's not really a basic idea in mergesort.
02:31:55 <Jafet> yitz: base sort splits the input into ascending and descending runs, which are then merged
02:33:06 <yitz> Jafet: the runs are merged by sorting them first. so it depends on that algorithm then.
02:33:35 <Jafet> There is no need to sort runs--they are already, by definition, sorted.
02:33:49 <yitz> Jafet: no sort the list of runs
02:33:53 <parcs`> head . sleepSort -- guaranteed O(1)
02:34:03 <Jafet> There is no need to do that, either.
02:34:05 <erus`> when will it be my turn for dependant types?
02:34:13 <Jafet> Therefore base sort does not do that.
02:35:55 <yitz> Jafet: how do you select which of the runs has the smallest element at its head? there are O(n) of those runs, don't forget.
02:36:11 <Jafet> If you're not convinced yet, copy out sortBy and add fifty traceShows
02:36:22 <Eduard_Munteanu> Anyway, I guess a simple example of head . someSort not being O(n) is when someSort is computed by extracting the maximum element out of the list at each step.
02:36:45 <Jafet> The runs are merged in pairs, as usual.
02:36:45 <yitz> Jafet: anyway, could be they changed the algorithm. i haven't looked in a while. but for a long time head.sort was definitely O(nlogn)
02:38:25 <Jafet> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/src/Data-List.html#sortBy
02:38:27 <MaskRay_> In each run only the head element gets evaluated.
02:38:55 <Jafet> According to the comments there, it's been O(n) since before 2002
02:39:18 <MaskRay_> There are O(n) runs and each merge requires O(1) time
02:49:15 <yitz> Jafet: it's essentially the same as ian's old algorithm w.r.t complexity. but i see, even though you do have to keep comparing as you span over the entire tree, head allows you to do only one compare at each node, so it still comes out to O(n).
03:29:02 <adimit> Is there an inverse function to intercalate? like [a] -> [a] -> [[a]]?
03:29:12 <adimit> (I know I could write my own, that's not the point :-P)
03:29:47 <adimit> something like a parameterizable words.
03:30:09 <donri> @hoogle split
03:30:10 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
03:30:10 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
03:30:10 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
03:30:26 <shachaf> Data.List.Split on hackage.
03:30:31 <elliott> adimit: hackage.haskell.org/package/split
03:30:32 <adimit> splitAt isn't what I wanted though.
03:30:39 <adimit> elliott, shachaf that's it!
03:30:39 <elliott> *http://hackage.haskell.org/package/split
03:30:41 <adimit> thanks.
04:29:55 <dp_wiz> cabal behaves just like gentoo at upgrade times...
04:31:44 <Cale> dp_wiz: Just be grateful it doesn't behave like Ubuntu at upgrade times, lol
04:32:15 <tejaswidp> This might be off topic, but I have a question on bayesian decision theory. In bayesian decision theory do the decision rules produce a decision boundary or do we have to use other methods which minimize the error?
04:34:05 <cheater_> Cale: haha
04:48:49 <dp_wiz> Cale: yeah. It just stumbled when compiling some of TemplateHaskell innards...
05:04:53 <dp_wiz> How to clean up 'versions installed' after upgrade is done?
05:12:47 <DevHC_> have there been any random ghc segfaults (suggesting a race condition) when compiling files?
05:12:54 <DevHC_> 7.0.3
05:20:34 <ronan> help me how to install the module gtk3 in Linux (Ubuntu)
05:22:43 <Botje> what are you having trouble with?
05:26:07 <ronan> Me?
05:26:46 <Botje> yes
05:27:33 <ronan> I can not install module Gtk
05:28:00 <Botje> and why not?
05:28:18 <elliott> I assume you've tried "cabal install gtk"? if so: cabal install gtk2hs-buildtools gtk
05:29:50 <ronan> yes
05:30:16 <si14> how do you write stateful tests in haskell?
05:30:27 <si14> let's say I have Mongo as a database and I want to mock it
05:30:52 <matthiasgorgens> si14: do you know how to do state in haskell in general?
05:31:01 <donri> use hunit to test impure code
05:32:13 <si14> matthiasgorgens: yeah, IO and so on
05:33:55 <elliott> hehe, IO is not exactly the first thing I'd think of for state
05:34:16 <Philippa_> yeah, it ought to be pretty much irrelevant to it
05:35:29 <si14> yeah, I'm interested in testing code that talks to e.g. database at most
05:35:59 <matthiasgorgens> si14: so you want to mock up the database with some kind of haskell substitute?
05:36:12 <si14> matthiasgorgens: yes
05:37:41 <matthiasgorgens> si14: what kind of structure does the code you want to test have?  Does it all live in IO, or in some more specialised (or pure) environment?
05:37:58 <si14> matthiasgorgens: actually it's Snap handlers
05:38:33 <si14> matthiasgorgens: so it's in monads, yes
05:39:31 <matthiasgorgens> si14: ok.
05:39:55 <matthiasgorgens> si14: you should probably look into quichkcheck, and if that isn't strong enough, hunit.
05:39:59 <ronan> This is error cabal: Error: some packages failed to install: cairo-0.12.2 failed during the configure step. The exception was: ExitFailure 1 gio-0.12.2 depends on glib-0.12.2 which failed to install. glib-0.12.2 failed during the configure step. The exception was: ExitFailure 1 gtk-0.12.2 depends on glib-0.12.2 which failed to install. pango-0.12.2 depends on glib-0.12.2 which failed to install.
05:40:04 <matthiasgorgens> si14: use quickcheck, if you can get away with it.
05:41:57 <matthiasgorgens> si14: in general, for structuring programs with certain side effects, the PromptMonad can also be helpful.  But I don't know anything about Snap Handlers.
05:51:30 <donri> si14: did you see Snap.Test in snap-core?
05:54:26 <elliott> ronan: that's not the error
05:54:30 <elliott> ronan: can you hpaste the entire build log?
05:54:50 <mysticc> I am working on some very low level file handling and was looking of implementing random read and write blocks of data on file .. Is there anything similar in haskell..
05:58:46 <Botje> isn't there an Mmap module?
06:00:32 <elliott> multiple
06:01:17 <savask> Hello. GHC requires itself to be compiled. Is there a way to "break the cycle"? I mean, to compile it without itself?
06:01:29 <ben> no, but you could download a binary ghc
06:01:50 <savask> No, using the binary one is forbidden :-P
06:01:58 <savask> But how it was made then?
06:02:20 <xTz> the haskell version of the hen or the egg
06:02:20 <xTz> :D
06:02:38 <ben> Someone who already had ghc built compiled it, I assume.
06:02:45 <si14> donri: thanks, I'll look at it.
06:04:34 <elliott> savask: GHC is built by its older versions
06:04:37 <elliott> (and then again by itself)
06:04:41 <limetree> imagine if everyone would lose their ghc binaries somehow
06:04:43 <elliott> it was bootstrapped with Lazy ML, I believe.
06:04:51 <elliott> limetree: a likely scenario :P
06:05:14 <elliott> IIRC it went like GHC first version written in lazy ML -> rewritten in Haskell afterwards.
06:06:05 <rostayob> elliott: that was the augusston compiler
06:06:24 <rostayob> *augustsson
06:06:46 <Botje> savask: it's the same problem as GCC, actually :)
06:06:50 <rostayob> I@m not sure how GHC came to be
06:06:51 <savask> elliott: So if I want to build GHC without binaries, I have to find the first version and compile it with ML compiler? Then compile the new version and so on?
06:07:12 <rostayob> savask: if you are interested in the history of haskell, read "Being Lazy with Class"
06:07:17 <savask> Botje: Well, there are other C/C++ compilers :-)
06:07:27 <Botje> savask: if you haven't read it yet, look up ken thompsons talk "reflections on trusting trust" (http://cm.bell-labs.com/who/ken/trust.html)
06:08:09 <savask> Thanks for books, but I'm not sure if they will help me to understand how to make GHC without binaries and a time machine.
06:08:10 <rostayob> savask: you always start with a compiler
06:08:38 <rostayob> savask: be it Lazy ML, or C, or whatever
06:09:27 <elliott> savask: No, that would be impossible.
06:09:36 <elliott> I believe.
06:09:40 <elliott> Well -- possible.
06:09:45 <elliott> But it requires getting your hands on a chain of compilers.
06:09:46 <savask> rostayob: Actually, you can try to use machine codes :-P If I recall correctly, Pascal compiler was made in such a way.
06:09:48 <Botje> you could hand-simulate the STG, but it won't be much fun.
06:09:55 <Philippa_> Botje: an even nastier variant is if someone pulls the same trick on a reflective system, so that you can't even inspect a binary
06:09:56 <elliott> I don't know if all the old GHC binaries are available.
06:10:03 <rostayob> savask: yeah if your program is written in assembly...
06:10:12 <elliott> savask: But anyway there's no reason to do so, so thankfully the daunting idea remains an academic thought experiment :P
06:10:24 <Botje> Philippa_: like rootkits?
06:10:31 <savask> elliott: The problem is that there is a reason.
06:10:37 <elliott> savask: What is it?
06:10:46 <rostayob> savask: what reason?
06:10:50 <savask> Maybe you've heard about GNU/Hurd
06:10:53 <rostayob> ahahahaha.
06:10:56 <elliott> savask: you want an unregistered port
06:10:57 <Philippa_> Botje: yeah, except if you're unlucky you might even have to inspect a live memory dump to spot it
06:11:01 <elliott> if you're trying to port ghc to hurd
06:11:08 <savask> It needs some packages to be ported, and GHC is the one among them.
06:11:19 <elliott> savask: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
06:11:29 <elliott> don't worry, porting ghc is significantly easier than compiling every version ever :p
06:11:34 <Philippa_> (rootkits can at least be spotted by prodding storage with another OS, assuming you're not running it from an encrypted partition)
06:11:57 <Botje> Philippa_: sneak rootkit into EFI, game over ;)
06:11:58 <savask> elliott: Even taking that fact into account, it wasn't ported yet o_O
06:12:15 <Botje> especially since EFI doesn't stop running once the OS boots
06:12:18 <elliott> savask: why would anybody port anything to hurd? :P
06:13:03 <savask> elliott: Just because :-) Nothing bad that there is a small microkernel OS.
06:13:09 <Philippa_> Botje: yesandno, in that you can swap mobos too
06:13:54 <int-e> Botje: or into some firmware.
06:15:07 <Botje> int-e: ah yes, I remember reading something about apple keyboards getting infected
06:17:17 <int-e> Botje: this guy http://www.youtube.com/watch?v=cYSOZIR3Kr0 targeted thinkpad firmware.
06:32:35 <mekeor> i've got a very difficult question: i want to write a program in haskell which gets a password and then encrypts a file. -- or do you think i should just use an extern program? which are there? -- or are there haskell-modules which have adequat functions? -- or should i just implement it myself? no? too difficult, right? -- so, actually, i just want to read (and write, by the way) into an ecrypted file.
06:32:58 <donri> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:cryptography
06:33:23 <elliott> mekeor: depends how much you care :P
06:33:32 <elliott> shelling out to gpg would be the simple solution
06:33:50 <CodeWeaver> keep in mind encryption's only as good as how much you trust that the implementors got it right.
06:34:01 <mekeor> elliott: and are there any problems that solution has? which?
06:34:26 <mekeor> CodeWeaver: wow. nice quote
06:34:31 <mekeor> @quote CodeWeaver
06:34:32 <lambdabot> No quotes match.
06:34:34 <elliott> mekeor: well, you don't get much control over the UI.
06:34:40 <mekeor> er, how can i save that quote?
06:34:46 <elliott>  @remember CodeWeaver ...
06:34:49 <mekeor> cool
06:35:04 <elliott> if you want to be *really* paranoid you'd want to store things in mutable arrays so you can overwrite them and avoid them getting swapped out or whatever :p
06:35:10 <elliott> at least i hear some software does that
06:35:11 <CodeWeaver> Uh…   neat!  I'm not even a cryptography guy. :D
06:35:21 <CodeWeaver> Yay my first quote maybe.
06:35:32 <mekeor> @quote CodeWeaver
06:35:32 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:35:34 <elliott> nobody's actually added you yet!
06:35:40 <elliott> i just gave instructions to mekeor
06:35:42 <CodeWeaver> Ahahaha probably for the best ;)
06:35:47 <CodeWeaver> Oh haha
06:36:22 <mekeor> ah
06:36:22 <mekeor> okay
06:36:40 <mekeor> @remember CodeWeaver keep in mind encryption's only as good as how much you trust that the implementors got it right.
06:36:41 <lambdabot> Nice!
06:36:46 <mekeor> @quote CodeWeaver
06:36:47 <lambdabot> CodeWeaver says: keep in mind encryption's only as good as how much you trust that the implementors got it right.
06:36:53 <CodeWeaver> hahahaha
06:36:57 <donri> mekeor: depending on what you're doing you might want to do the encryption on the filesystem level. there you can also encrypt the swap.
06:36:58 <mekeor> :)
06:37:49 <mekeor> donri: wow. oO. actually, i'm still nooby... so i probably have to train before i get strated with cryptology with haskell.
06:38:20 <mekeor> where train = repeat coding
06:38:29 <mekeor> :t repeat
06:38:30 <CodeWeaver> It'd be vaguely fun as a (not to be trusted in the real world) exercise to implement public key encryption in haskell.
06:38:30 <lambdabot> forall a. a -> [a]
06:38:43 <elliott> cryptology sounds like the disrespectable, less scientific relative of cryptography
06:39:06 <donri> cryptozoology!
06:39:15 <elliott> "from these 64 bytes of /dev/random that we decrypted, we can deliver your *personalised* cryptoscope"
06:39:27 <mekeor> AFAIK, cryptology=cryptography+cryptoanalysis
06:39:54 <CodeWeaver> That would make sense.
06:41:28 <byorgey> elliott: that's just because you're thinking of astronomy vs. astrology.
06:41:52 <elliott> shhh, you're ruining my brilliant joke! well... it was a joke at least.
06:42:05 <byorgey> "astrology" is a shameful etymological blemish upon the upstanding Greek word "logos"
06:42:44 <CodeWeaver> as is, say, scientology, and reflexology.  There's quite a number of them.
06:42:45 <ibid> ecology, antropology, sociology, ...
06:42:51 <mekeor> hehe
06:42:58 <byorgey> hehehe
06:42:59 <byorgey> so I suppose biology is the disreputable unscientific relative of biography ;)
06:43:06 <CodeWeaver> hahahahaha
06:43:19 <elliott> bionomy
06:43:19 <CodeWeaver> So, it turns out English is a mangled screwed up barnacle of a language.
06:43:34 <byorgey> CodeWeaver: news at 11.
06:43:39 <byorgey> =)
06:43:40 <mekeor> haha
06:43:41 <CodeWeaver> :D
06:43:49 <elliott> "astrography" somehow sounds even less reputable than "astrology"
06:43:55 <byorgey> hehe, so it does
06:43:56 <DevHC_> functionology
06:44:11 <CodeWeaver> monadonomics.
06:44:14 <ibid> of course, may do consider anthropology and sociology suspect :)
06:44:14 <byorgey> generatingfunctionology is quite reputable
06:44:28 <donri> programming? astroing!
06:44:38 <DevHC_> so... anyone having recent random ghc 7.0.3ish segfaults when compiling?
06:44:40 <CodeWeaver> congramming?
06:44:43 <byorgey> computology
06:44:43 <CodeWeaver> antigramming?
06:45:03 <DevHC_> ircology
06:45:11 <byorgey> DevHC_: you mean the compiler itself segfaults? Or the generated executables do?
06:45:14 <donri> eulogy
06:45:17 <elliott> mathology
06:45:18 <DevHC_> the compiler
06:45:18 <ibid> computology reminds me of computing science vs computer science
06:45:20 <byorgey> not that I have experienced either
06:45:24 <byorgey> DevHC_: yikes
06:45:28 <shachaf> DevHC_: Compiling what?
06:45:29 <mreh> any mature abstraction layers for 3D openGL yet?
06:45:30 <DevHC_> yiykes ind33d
06:45:35 <DevHC_> a small file
06:45:36 <donri> the study of the european union
06:45:36 <mreh> not just bindings
06:45:38 <mekeor> OMG heheheh
06:45:41 <elliott> DevHC_: you said it was nondeterministic, right?
06:45:44 <elliott> maybe your hardware is to blame
06:45:45 <DevHC_> yes
06:45:47 <DevHC_> orly
06:45:51 <elliott> memtest?
06:46:05 <DevHC_> i haven't experienced anything else segfault
06:46:07 <byorgey> mreh: diagrams now supports animation and it has always supported 3D, so you just need to write an openGL backend for it... =)
06:46:25 <mreh> byorgey: :(
06:48:02 <sclv> re generatingfunctionology -- if people haven't heard, herb wilf just passed away this month.
06:48:33 <sclv> everyone should read his books in memorium.
06:48:44 <ibid> full name?
06:48:58 <sclv> http://www.math.upenn.edu/~wilf/
06:49:55 <CodeWeaver> elliott:  Doesn't need to be a hardware failure.  Just something that executed differently on an OS running multiple threads.  A race condition in the compiler, or a memory access gone wrong that is 'harmless' except when a task gets switched out at a point.
06:50:15 <elliott> CodeWeaver: yes, but those are all GHC bugs
06:50:17 <elliott> GHC is never wrong :)
06:50:28 <CodeWeaver> *beeps elliott's nose*
06:50:48 <ibid> ohh, what an opening sentence!
06:50:49 <ibid> "A generating function is a clothesline on which we hang up a sequence
06:50:49 <ibid> of numbers for display.
06:50:50 <ibid> "
06:51:42 <DevHC_> CodeWeaver: ie.?
06:52:04 <byorgey> sclv: indeed.  Sadly I never met him, even though we were both at UPenn!
06:52:08 <CodeWeaver> ?  No examples pending.  complex software is complex.  Bugs happen.  News at 11.
06:52:20 <mreh> ibid: the only math writer i've heard such highs from is david berlinski
06:52:38 <DevHC_> CodeWeaver: i didn't ask for example, ie. is "that is"
06:53:06 <elliott> that just makes your question make even less sense :P
06:53:10 <CodeWeaver> id est.  Usually used to indicate an 'in other words' follows
06:53:33 <DevHC_> yes
06:53:35 <CodeWeaver> I had no in other words following
06:53:36 <DevHC_> so: in other words?
06:53:37 <jeff_s_> Hello, I'm having trouble getting the types to work out for a function I'm trying to write. My intent is to get a values of a type that is Bounded and Enum to a list of Ints that start at 0. (please see my hpasted function) Does anyone know how to do this short of calling a function like (minEnum :: (Bounded e, Enum e) :: e -> e); minEnum _ = minBound) for every value in the map?
06:53:42 <CodeWeaver> in other words, I got nothing.
06:54:08 <byorgey> CodeWeaver: perhaps DevHC_ was referring to the beeping of elliott's nose?
06:54:13 <CodeWeaver> Oh. :D
06:54:29 <jeff_s_> Hm, I don't see a link to my hpaste. Here it is: http://hpaste.org/57187
06:54:30 <CodeWeaver> Um, because elliott's statement was silly, so, I decided to be silly.  No rocket science there. :D
06:54:52 <elliott> i'm so confused :(
06:54:59 <CodeWeaver> "GHC is never wrong"
06:55:02 <elliott> jeff_s_: looks like the hpaste bot is dead
06:55:23 <CodeWeaver> Relax.  I'm occasionally 12 years old.  I've learned to live with it.
06:55:28 <elliott> jeff_s_: turn on ScopedTypeVariables extension, add "forall e." to the start
06:55:31 <elliott> then (minBound :: e) works
06:55:40 <jeff_s_> OK, I'll try it. Thanks!
06:55:42 <elliott> the alternative is ugly hacks like that :P
06:56:29 <byorgey> jeff_s_: see my annotation
06:56:30 <CodeWeaver> So it turns out generating primitive pythagorean triples strictly ordered is computationally annoying. :P
06:56:54 <byorgey> jeff_s_: the problem is that by default the 'e' in (minBound :: e) is not the same as the one in the type of normalizeEnums
06:57:22 <jeff_s_> byorgey - ya, i was going to solve that with a call to a function like (minEnum :: e -> e), but I didn't like that solution.
06:57:30 <byorgey> jeff_s_: yep
06:57:31 <DevHC_> byorgey: perhaps not
06:57:36 <cmccann> :t asTypeOf
06:57:37 <lambdabot> forall a. a -> a -> a
06:57:45 <cmccann> @src asTypeOf
06:57:46 <lambdabot> asTypeOf = const
06:58:01 <jeff_s_> byorgey and elliott - thanks, it works!
06:58:05 <byorgey> great!
06:58:08 <cmccann> > maxBound `asTypeOf` True
06:58:09 <lambdabot>   True
06:58:48 <CodeWeaver> So there's today's goofy haskell challenge.  Performance generation of primitive pythagorean triples.  Ordered x minor and y major.  Find term ten thousand in the sequence.'
06:59:26 <CodeWeaver> Actually I had a hard enough time doing it when I left non-primitives in the sequence.
06:59:35 <CodeWeaver> Not sure how to even do my own challenge. ;)
07:02:25 <mreh> how can i create Ptrs to my haskell values?
07:02:45 <CodeWeaver> For the purpose of what?
07:02:48 <mreh> e.g. raw bytes from a file
07:02:52 <mreh> texturing in openGL
07:03:08 <ClaudiusMaximus> @hoogle hGetBuf
07:03:09 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
07:03:09 <lambdabot> GHC.IO.Handle hGetBuf :: Handle -> Ptr a -> Int -> IO Int
07:03:09 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
07:03:11 <quicksilver> withArray, mreh
07:03:33 <jeff_s_> I have a question related to my previous one - why do I need "forall e."?
07:03:45 <jeff_s_> I'm sure it's in the ghc documentation somewhere.
07:03:48 <quicksilver> or ByteString.toForeignPtr
07:03:50 <elliott> jeff_s_: I think for backwards compatibility?
07:03:55 <elliott> jeff_s_: since you might say (foo :: e) elsewhere
07:03:58 <elliott> and that means universally quantified e normally
07:04:08 <elliott> adding "forall" means you have to explicitly invoke the extension's behaviour
07:04:09 <quicksilver> or, certainly, hGetBuf if they really were in a file
07:04:17 <quicksilver> (but you don't normally store raw texture bytes in a file)
07:04:28 <elliott> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/other-type-extensions.html#scoped-type-variables is the docs anyway
07:05:01 <mreh> quicksilver: shurely?
07:05:12 <mreh> say they're jpeg images
07:05:16 <DevHC_> local red alert !
07:05:22 <quicksilver> yes, jpeg images are not raw texture bytes
07:05:23 <jeff_s_> elliott - thanks, the scoping makes sense to me; thanks again!
07:05:33 <quicksilver> you can't hGetBuf a jpeg and pass that to an openGL texture
07:05:38 <DevHC_> ghc just segfaults at random times, basically with any input program and any compilation arguments
07:05:39 <mreh> i'll have to save them as a pixel map
07:05:40 <quicksilver> you need to use a jpeg reading library
07:05:44 <quicksilver> no, don't do that.
07:05:49 <quicksilver> just use an image library
07:05:57 <quicksilver> I have use wx for that but there are other options
07:06:03 <mreh> but i like unecessary massive files
07:06:46 <elliott> mreh: good luck with platforms of different endianness
07:07:05 <mreh> elliott: with opengl?
07:08:02 <mreh> i was hoping haskell and opengl would be rather cross platform
07:08:47 <elliott> mreh: i was referring to your plan to directly read files into pointers
07:09:16 <elliott> if there's any machine words involved, then doing that will make files nonportable across architectures of different endiannesses -- nothing to do with haskell there, your fault for trying to load things "directly" :P
07:10:56 <mreh> elliott: i'll use a lib :)
07:29:30 <byorgey> does anyone know of any packages on Hackage for parsing "natural language" times, such as "5pm tomorrow", "10 minutes from now", etc.?
07:30:51 <sm> byorgey: there's some of that in hledger-lib
07:31:17 <sm> http://hackage.haskell.org/packages/archive/hledger-lib/0.16.1/doc/html/Hledger-Data-Dates.html
07:31:37 <sclv_> i know that ashley y is working on ideas for how to represent various sorts of natural language descriptions of times and durations
07:31:45 <sclv_> but i don't know of any natural language parsing stuff
07:31:59 <byorgey> sm: thanks
07:32:22 <byorgey> yeah, I don't really care about *representing* natural language descriptions
07:32:57 <byorgey> I just want a function something like  String -> TimeZone -> UTCTime  which can accept things like "5pm tomorrow"
07:33:46 <sm> my stuff doesn't really handle time, just dates
07:33:58 <byorgey> ah, I see
07:34:25 <byorgey> sm: and it looks like you are also concerned with representing it, since you use it to do things like describe recurring dates, etc.?
07:35:26 <byorgey> I'll probably just write my own, I don't think it will be that hard.  It's just a matter of thinking up all the possible ways to describe a time/date and putting in an alternative for each
07:35:42 <shachaf> byorgey: Please include "hence"!
07:35:56 <byorgey> shachaf: OK!
07:36:01 <sclv_> ha! a quick google reveals two packages (along with papers). both packages are ruby gems.
07:36:03 <byorgey> as in "ten minutes hence" ?
07:36:08 <sclv_> https://github.com/mojombo/chronic/
07:36:09 <shachaf> Yes.
07:36:14 <sclv_> http://naturalinputs.com/
07:36:24 <sclv_> you could probably crawl their code for inspiration
07:36:31 <shachaf> You can probably take inspiration from libraries that people have made for other languages, yes.
07:36:48 <byorgey> ugh, regular expressions
07:36:52 <shachaf> Hey, it's sclv.
07:37:13 <Ngevd> Hello!
07:37:58 <sclv_> hi
07:38:12 <Ngevd> My Family Tree program is going well!
07:38:21 <sclv_> great
07:38:32 <Ngevd> I just need to figure out how to install e.g. gtk2hs
07:38:52 <sclv_> famous last words :-)
07:39:10 <Ngevd> To get to the next step
07:39:44 <matthiasgorgens> shachaf: how would you use `hence'?
07:40:12 <shachaf> matthiasgorgens: In the way byorgey demonstrated. "from now"
07:41:32 <mekeor> Ngevd: install it?  just use cabal...: cabal install gtk2hs
07:41:50 <mekeor> Ngevd: assuming you use linux (idk how to do that under windows...)
07:41:53 <kmc> yeah that... sometimes works
07:41:57 <Ngevd> Windows, I'm afraid
07:42:08 <kmc> at minimum you need to install gtk2hs-buildtools first
07:42:20 <kmc> but there are many other things that can go wrong
07:42:23 <matthiasgorgens> shachaf: oh, ok.
07:42:23 <cmccann> byorgey, have you looked at http://en.wiktionary.org/wiki/Category:en:Time for inspiration?
07:42:31 <kmc> (also, the package is named gtk, not gtk2hs)
07:42:36 <mekeor> oh =)
07:42:43 <kmc> HsHGtk2ForHaskell-hs
07:42:43 <elliott> Ngevd: windows has cabal
07:42:48 <byorgey> cmccann: oh, nice =)
07:42:50 <elliott> but it's cabal install gtk2hs-buildtools gtk
07:42:57 <elliott> oh kmc said that
07:43:12 <Ngevd> Okay, I'll try this
07:43:14 <byorgey> cmccann: "two fortnights ereyesterday"
07:43:35 <kmc> "four score and seven years ago"
07:43:56 <byorgey> "gloaming on February 17"
07:43:57 <cmccann> byorgey, sounds reasonable to me
07:44:04 <elliott> "once in a blue moon"
07:44:16 <elliott> "when i least expect it"
07:44:18 <Ngevd> "three times every second blue moon"
07:44:25 <byorgey> heh, actually, "civil twilight on <date>" would be reasonable =)
07:44:32 <byorgey> hahaha
07:44:41 <Ngevd> cabal install gtk has errored
07:44:50 <elliott> Ngevd: cabal install gtk2hs-buildtools
07:44:55 <Ngevd> Already done so
07:44:56 <elliott> ah
07:44:57 <osfameron> civil twilight at {long,lat,whatever}itude on <date>, surely?
07:44:58 <elliott> hpaste
07:45:10 <byorgey> osfameron: oh, good point
07:45:14 <Ngevd> Windows doesn't let copying from command lines, so I'll be a minute
07:45:24 <cmccann> byorgey, do you intend to handle ranges and approximate times, or just exact values?
07:45:29 <byorgey> osfameron: I was thinking of just sticking it in IO and having it try to autodetect a GPS receiver
07:45:29 <osfameron> Ngevd: sure it does.  it's just a bit rubbish
07:45:35 <osfameron> byorgey: hehe
07:45:39 <kmc> you also need the gtk c libraries installed, somewhere cabal will see them
07:45:47 <byorgey> cmccann: just exact values
07:45:52 <osfameron> Ngevd: ctrl-escape, or click on the icon at top-left and set QuickEdit mode
07:46:04 <osfameron> iirc, haven't used Windows for years now...
07:46:07 <byorgey> "two elephant gestation periods from tomorrow"
07:46:08 <kmc> when i used windows i would run cygwin sshd and ssh to localhost because PuTTY worked better than cmd.exe
07:46:20 <shapr> ha
07:46:23 <shapr> kmc: cute :-)
07:46:35 <Ngevd> ...Control-escape opens the start menu?
07:47:18 <matthiasgorgens> byorgey: "When my stars align"
07:47:40 <dgpratt> Ngevd: try Alt+Space
07:47:53 <Ngevd> I did the mousey one
07:48:01 <Ngevd> http://hpaste.org/57190
07:48:09 <Ngevd> That enough context?
07:49:00 <Peaker> which ghc version does cabal-install use by default, if "-w" is not specified?
07:50:01 <donri> Peaker: $ which ghc # <-- that one
07:52:02 <Peaker> donri: thanks
07:52:10 <sm> byorgey: and "for the nonce" !
07:53:10 <sm> all statements about time in shakespeare should parse :)
07:53:20 <byorgey> hehe
07:53:35 <elliott> Ngevd: no
07:53:37 <matthiasgorgens> Did the lambda-with-case or anonymious case-of proposals go anywhere?
07:53:38 <elliott> Ngevd: the whole build log
07:53:45 <elliott> matthiasgorgens: yes: bikeshedding
07:54:00 <Ngevd> I think it fails because it can't find glib-2.0 and glib-0.12.2 simultaneously?
07:54:03 <elliott> expect it sometime in 2020 with a syntax everybody dislikes equally :P
07:54:11 <elliott> Ngevd: oh, wait
07:54:15 <cmccann> byorgey, exact is probably easier, but it would be nice to allow things like "in a few days" or "before winter"
07:54:16 <elliott> Ngevd: you don't have glib development stuff installed
07:54:29 <elliott> you're on windows so you need to install gtk development stuff and i have absolutely no idea how
07:54:32 <Ngevd> Advice?
07:54:33 <kmc> matthiasgorgens, there is a patch on the ghc trac
07:54:45 <kmc> with much discussion on the accompanying ticket
07:54:47 <kmc> i don't think it's been merged yet
07:54:48 <byorgey> cmccann: sure, but what would it parse to?
07:55:06 <elliott> Ngevd:
07:55:07 <elliott> http://code.haskell.org/gtk2hs/INSTALL
07:55:09 <elliott> see "building on windows" section
07:55:19 <byorgey> cmccann: you'd need a whole new data type to represent ranges/approximate times
07:55:36 <cmccann> byorgey, yes, that's why I was asking if you were going to handle ranges :]
07:55:47 <matthiasgorgens> kmc: thanks.
07:56:15 <byorgey> cmccann: well, I'm writing this because I want it for something else, and I don't need ranges or approximate times
07:56:29 <byorgey> once I release it if you want to extend it to handle those, be my guest =)
07:56:36 <cmccann> no, sounds like too much effort :P
07:56:39 <smop> building on windows is tons of fun
08:10:26 <matthiasgorgens> Is there a reason why Haskell doesn't have or-patterns like OCaml?  Is it just an accident, or not possible for some reason?
08:10:59 <copumpkin> it's probably possible, but or patterns get icky with binders don't they?
08:11:31 <matthiasgorgens> what are binders?
08:11:53 <elliott> matthiasgorgens: Left p | Either q -> ...
08:11:54 <Enigmagic> i'm sure it's possible because i have to rewrite case statements to simulate an OR all the time :P
08:12:11 <elliott> matthiasgorgens: you need to ensure each pattern binds the same variables
08:12:29 <quicksilver> at the same types.
08:12:32 <cmccann> isn't it required that both sides of the | bind the same variables?
08:12:36 <matthiasgorgens> elliott, sure.  and they should also be same type, unless you define or-patterns strictly as syntactic sugar.
08:12:37 <cmccann> yeah
08:12:37 <quicksilver> or you just make the others underfined.
08:12:58 <elliott> it's kind of ugly :(
08:12:58 <quicksilver> which would be icky but consistent with the ickiness which is record syntax.
08:13:04 <matthiasgorgens> quicksilver: sounds like a good idea, might just lead to silent bugs, though.
08:13:14 <elliott> i kind of want to say: if you have common components like that, define a function to process them
08:13:14 <matthiasgorgens> quicksilver: perhaps give a warning.
08:13:19 <elliott> maybe even give them their own data type
08:13:23 <elliott> but that's not always suitable...
08:13:38 <matthiasgorgens> elliott, not always possible, if they have the same function calls, but different types, or is it?
08:13:54 <cmccann> anyway, seems like something that would allow a straightforward desugaring to me, once you decide on syntax and what the requirements are
08:14:02 <quicksilver> yes, or-patterns are easy
08:14:07 <matthiasgorgens>   go DBusByte = JArgNumber . toRational <$> (fromVariant v :: Maybe Word8)
08:14:08 <matthiasgorgens>   go DBusInt16 = JArgNumber . toRational <$> (fromVariant v :: Maybe Int16)
08:14:08 <matthiasgorgens>   go DBusInt32 = JArgNumber . toRational <$> (fromVariant v :: Maybe Int32)
08:14:09 <quicksilver> there is no good reason that haskell doesn't have them.
08:14:17 <quicksilver> SPJ said as much once.
08:14:18 <matthiasgorgens> We have a bunch of lines looking like these.
08:14:22 <matthiasgorgens> (sorry, for the spam.)
08:14:26 <quicksilver> However each new syntactical construct has a cost.
08:14:41 <cmccann> quicksilver, got a cite on that? sounds plausible to me but I'd like to know what SPJ thinks
08:15:13 <elliott> matthiasgorgens: well i would not want it to work with different types.
08:15:20 <elliott> that's really syntactic
08:15:35 <elliott> the expression on the RHS shouldn't be interpreted with a new meaning for each possible type of the bindings
08:15:40 <cmccann> matthiasgorgens, in some cases you can refactor stuff like that to avoid the redundancies
08:15:46 <elliott> or-patterns with same types would be fine though
08:15:48 <Enigmagic> matthiasgorgens: make a function "JAArgNumber . toRational . fmap fromVariant" and apply that instead?
08:15:57 <quicksilver> cmccann: can't find it. It was almost certainly a haskell-cafe post.
08:16:04 <cmccann> quicksilver, ok, thanks anyway
08:16:05 <matthiasgorgens> There's also a line like:   go DBusString = JArgString <$> fromVariant v
08:16:11 <matthiasgorgens> so it does depend on the LHS.
08:16:20 <elliott> matthiasgorgens: or-patterns couldn't solve that :P
08:16:23 <kmc> technically the variables of the same name don't need to have the same type, their types just need to unify
08:16:31 <elliott> go = writeMyBoringBoilerplateFunctionForMe
08:17:13 <matthiasgorgens> That's what I like about Functional Reactive Programming.  It makes boring boilerplate into highly experimental stuff that doesn't work.
08:17:23 <cmccann> haha
08:17:33 <kmc> haha yes
08:17:48 <cmccann> exciting, experimental boilerplate is the best kind of boilerplate
08:18:01 <cmccann> cf. most type hackery
08:18:02 <kmc> a similar thing happens with template haskell
08:18:13 <kmc> i will turn 6 lines of boilerplate into an incomprehensible 6-line macro
08:18:23 <kmc> but of course it's very clever, complicated code and so I feel good about myself
08:18:39 <Enigmagic> it makes me feel like a man
08:19:59 <cmccann> kmc, I've heard "engineer" defined as "someone who will spend 11 hours creating a tool to solve a 10-hour problem in 1 hour"
08:20:24 <kmc> :D
08:20:43 <kmc> it's useful if you have to solve that particular 10-hour problem a second time
08:20:56 <cmccann> yes
08:20:58 <matthiasgorgens> that's why the numbers are wrong.
08:21:04 <cmccann> and even pays off very quickly when you do
08:21:05 <kmc> over the years i have developed techniques for partially automating things
08:21:12 <matthiasgorgens> An engineer will spend 11 hours to solve a 1 hour problem in 1 min.
08:21:20 <kmc> sometimes I will write a shell script that outputs a shell script, edit that script, and then run it
08:21:37 <matthiasgorgens> kmc: that smacks of practicality.
08:21:37 <kmc> sometimes this is faster than either doing it manually or full automation of every special case
08:21:39 <dainanaki> I'm trying to figure out if there's a way to use the data-lens package to construct lenses that make use of IO actions, but I'm thinking that since IO isn't a comonad that it might be kind of futile. Am I correct in my thinking?
08:21:45 <elliott> that reminds me of plan 9's kill command
08:21:57 <elliott> which just prints out an rc script to kill the process by doing "echo ... >/proc/<pid>/..."
08:22:05 <kmc> haha
08:22:18 <cmccann> nice
08:22:23 <elliott> (i think it prints multiple lines for several ways of killing it, so it's not entirely pointless; I think it's also meant to act as an "are you sure?")
08:22:34 <matthiasgorgens> elliott, isn't there a race condition (or something) if the process dies of it's own, and the pid gets reused?
08:23:06 <elliott> matthiasgorgens: plan 9 users *feel* when a process dies, man
08:23:19 <matthiasgorgens> elliott, immediately?
08:23:33 <matthiasgorgens> elliott, because then I have an idea for time travel.
08:23:51 <matthiasgorgens> by the way, I finally succumbed to the temptation of using runKleisli (Kleisli fromVariant *** Kleisli convVariant)
08:24:04 <matthiasgorgens> to replace a do block I mentioned yesterday.
08:24:09 <elliott> :/
08:24:19 <elliott> at least call it ReaderT instead
08:24:29 <elliott> runReaderT (ReaderT fromVariant *** ReaderT convVariant)
08:24:39 <matthiasgorgens> but it's actually in the Maybe Monad.
08:24:44 <elliott> Kleisli === ReaderT
08:24:47 <elliott> same thing
08:24:49 <matthiasgorgens> ok.
08:25:00 <cmccann> I don't think (***) would work on ReaderT, though?
08:25:05 <aristid> elliott: is there also an Arrow instance on it?:)
08:25:05 <elliott> oh good point
08:25:10 <elliott> runKleisli $ ((***) `on` Kleisli) fromVariant convVariant -- :D
08:25:15 <aristid> :t (***)
08:25:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:25:29 <cmccann> you can make an arrow instance for ReaderT easily enough, just make a newtype wrapper that swaps the parameter order
08:25:38 <matthiasgorgens> and what's the benefit?
08:25:38 <cmccann> :D
08:25:43 <matthiasgorgens> instead of just using kleisli?
08:25:45 <elliott> cmccann: huh? ReaderT has the same order as Kleisli
08:25:48 <elliott> matthiasgorgens: none :P
08:25:56 <cmccann> matthiasgorgens, that's the joke
08:25:58 <matthiasgorgens> If I have to define more stuff, I might as well go back to the do-notation.
08:26:09 <cmccann> Kleisli and ReaderT are the same except for the type parameter order
08:26:34 <aristid> :t let m f g a b = do x <- f a; y <- g b; return (x, y) in m
08:26:35 <lambdabot> forall t (m :: * -> *) t1 t2 t3. (Monad m) => (t -> m t1) -> (t2 -> m t3) -> t -> t2 -> m (t1, t3)
08:28:04 <elliott> cmccann: :/ are you sure the type parameter order is different?
08:28:09 <elliott> Kleisli m a b = a -> m b
08:28:15 <elliott> ReaderT m r a = r -> m a
08:28:36 <cmccann> @src ReaderT
08:28:37 <lambdabot> Source not found. Sorry.
08:28:40 <cmccann> argh
08:28:42 <cmccann> :t ReaderT
08:28:43 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
08:29:22 <aristid> why not just write a ***-like combinators for a -> m b and move on?
08:30:13 <cmccann> elliott, the order has to be different because you want a MonadTrans instance for "ReaderT r"
08:30:32 <matthiasgorgens> aristid: yes, you could do that.
08:30:52 <matthiasgorgens> aristid: the wrapping in kleisli was just the shortest way.
08:31:04 <matthiasgorgens> aristid: using stuff already in base.
08:31:45 <aristid> *shrug*
08:34:30 * hackagebot HTF 0.8.2.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.8.2.0 (StefanWehr)
08:38:31 <kallisti> csend <*> pure m <*> pure cs
08:38:34 <kallisti> what's a better way to write this.
08:38:49 <tommd> csend m cs?
08:39:03 <kallisti> not quite.
08:39:15 <kallisti> csend is an IO of a function
08:39:44 <kallisti> csend >>= ($ m) >>= ($ cs)   ????
08:39:54 <kallisti> er, no.
08:39:56 <kmc> (\f -> f m cs) <$> csend
08:39:59 <kmc> maybe?
08:40:06 <kallisti> oh that's interesting
08:40:41 <kowey> I seem to understand that the hackage trac instance was shut down for spam
08:40:51 <kowey> where should we file cabal/cabal-install bugs then?
08:40:52 <tommd> hackage had a trac?
08:41:11 <donri> kowey: try cabal-devel ML, though no one has replied to me :P
08:41:20 <tommd> I always just e-mailed or messaged duncan.
08:41:26 <kallisti> @pl \cs -> (\f -> f m cs) <$> csend
08:41:26 <int-e> kmc: that's missing a join?
08:41:27 <lambdabot> (<$> csend) . flip ($ m)
08:41:34 <kowey> I could do that; it'd just make me feel guilty :-)
08:41:53 <tommd> More incentive for a github repo or hackage2 ;-)
08:42:02 <int-e> kmc: no it's not. sorry.
08:42:18 <kallisti> it should be a =<< instead of a <$> actually
08:42:20 <kallisti> I think.
08:42:27 <byorgey> kallisti: pure (csend m cs)
08:42:36 <byorgey> oh, wait, sorry
08:42:36 <kallisti> um, no.
08:42:44 <byorgey> I didn't realize the first op was <*> instead of <$>
08:42:52 <kallisti> yes indeed.
08:42:55 <tommd> That's what I was thinking too.
08:44:00 <kallisti> yes it is missing a join. <$> should be =<< I believe
08:44:42 <byorgey> kallisti: I think csend <*> pure m <*> pure cs  is probably the nicest way to write it.
08:45:11 <dainanaki> Is there any way that I can shoehorn a function of type (Class -> IO Int) and a function of type (Class -Int -> IO ()) into a lens?
08:45:18 <kallisti> @pl \cs -> csend <*> pure m <*> pure cs
08:45:19 <lambdabot> ((csend <*> pure m) <*>) . pure
08:45:54 <int-e> :t (\f -> f ?a ?b) <$> ?csend
08:45:55 <lambdabot> forall t t1 b (f :: * -> *). (?a::t, ?b::t1, ?csend::f (t -> t1 -> b), Functor f) => f b
08:46:07 <int-e> kallisti: looks fine.
08:46:17 <kallisti> @pl withCString s $ \cs -> csend <*> pure m <*> pure cs
08:46:17 <lambdabot> withCString s (((csend <*> pure m) <*>) . pure)
08:46:26 <copumpkin> kallisti: why would you do that?
08:46:31 <kallisti> copumpkin: do what exactly?
08:46:50 <copumpkin> apply it to a bunch of pure values
08:46:56 <byorgey> dainanaki: that doesn't really make sense to me.  in what way are the two functions related?
08:47:15 <kallisti> copumpkin: um, because that's what I need to do. is "lolFFI" a good explanation?
08:47:34 <cmccann> :t liftA3 id -- kallisti
08:47:34 <lambdabot> forall b c d (f :: * -> *). (Applicative f) => f (b -> c -> d) -> f b -> f c -> f d
08:48:03 <byorgey> cmccann: kallisti wants something of type   f (b -> c -> d) -> b -> c -> f d
08:48:15 <cmccann> oh, right
08:48:26 <kallisti> actually no I want  f (b -> c -> f d) -> b -> c -> f d
08:48:35 <kallisti> as it turns out
08:48:37 <elliott> If only we had idiom brackets(tm).
08:48:40 <byorgey> oh.
08:48:40 <copumpkin> whoa, there's an f d?
08:48:48 <copumpkin> that needs a monad then
08:48:50 <dainanaki> byorgey, One is a stateful getter, one is a stateful setter. I'm trying to figure out if I can fiddle the types around some way to make them into a lens, but I think since IO isn't a comonad that I'm probably out of luck.
08:48:56 <kallisti> yep. that's why with the <$> should have been a =<< before
08:49:27 <int-e> right, then just  do csend' <- csend; csend' m cs
08:49:30 <copumpkin> zomg f x y = do f <- g; f x y
08:49:31 <copumpkin> :P
08:49:47 <copumpkin> can't get much shorter than that
08:49:48 <elliott> kallisti: eh?
08:49:50 <danols_work> hi I am reading Learn You Haskel for greater Godo
08:49:52 <nand`> kallisti: so basically f a -> a?
08:49:53 <danols_work> good
08:49:55 * kallisti is, for context, writing a peek method for a Haskell structure that corresponds to a C structure of function pointers.
08:49:55 <elliott> oh
08:49:57 * copumpkin waits for Godo
08:49:58 <elliott> that (<$>)
08:50:01 <byorgey> danols_work: excellent
08:50:07 <danols_work> quesiton the 'where' clause
08:50:07 <c_wraith> copumpkin: you mean Greater Godo?
08:50:13 <danols_work> can one put it at top of the function defitinion ?
08:50:15 <copumpkin> c_wraith: nope
08:50:20 <c_wraith> lesser?
08:50:21 <byorgey> danols_work: no
08:50:25 <kallisti> copumpkin: yes that's what I ended up with, except with =<< and lambda
08:50:29 <danols_work> that is 'awkward'
08:50:34 <int-e> nand`: no, f (f a) -> f a. which will typically be done using join or bind, whichever is easier to use in the context.
08:50:42 <byorgey> danols_work: there are also let-expressions
08:50:47 <byorgey> danols_work: let x = ... in ...
08:51:03 <danols_work> from fresh perspective the 'where' at bottom of code is harder for readabilty
08:51:03 <byorgey> danols_work: why is it awkward?
08:51:04 <kallisti> @pl withCString s $ \cs -> (\f -> f m cs) =<< csend
08:51:05 <lambdabot> withCString s ((csend >>=) . flip ($ m))
08:51:06 <danols_work> any work around ?
08:51:26 <elliott> danols_work: it's only awkward if you have a bunch of lines in your clause
08:51:39 <elliott> which just suggests you need to move more into the where
08:51:40 <elliott> or refactor
08:51:42 <danols_work> it's awkward by design
08:51:45 <elliott> danols_work: anyway what's wrong with let...in?
08:52:01 <danols_work> elliott: I don't know I am just reading
08:52:02 * elliott loves where precisely because of how it's laid out
08:52:04 <int-e> kallisti: I would really prefer csend >>= ... there, then it'll be clearer what f is.
08:52:08 <danols_work> I have touched/coded in haskell in 2000
08:52:20 <danols_work> it's a lot i forgot so my perspective is fresh
08:52:27 <kallisti> int-e: ah yes.
08:52:37 <kallisti> I decided to make it pointless though. :>
08:53:01 <copumpkin> kallisti: I don't see what's wrong with do notation :P
08:53:02 <danols_work> elliott: why is it good at end, I'm looking at the code int he book and until I read the 'where' clause at bottom of function I have no idea what f, l might stand for
08:53:10 <copumpkin> kallisti: plus, I think the do version is actually shorter isn't it?
08:53:34 <int-e> copumpkin: perhaps it would be too easy to read
08:53:38 <kallisti> indeed.
08:53:57 <copumpkin> int-e: oh yeah, I always forget that we do our best to avoid that :)
08:54:02 <kallisti> I honestly prefer reading >>= to do
08:54:12 * copumpkin invents a new operator, >%<#%@+^>>++== for the purpose
08:54:31 <danols_work> is the 'where' clause used often in your experience guys/gals?
08:54:35 <copumpkin> yeah
08:54:37 <kallisti> definitely.
08:55:02 <elliott> danols_work: you realise mathematics does it the same way? :P
08:55:03 <int-e> copumpkin: good idea, but you should also have >%<#@%+^>>++== :)
08:55:05 <elliott> anyway, it flows more naturally
08:55:07 <elliott> rather than
08:55:12 <danols_work> when you are reading someone else code, it being at bottom hasn't crossed your mind being inconvenient ?
08:55:20 <elliott> "here's a bunch of helper definitions we need that you don't know what they're for yet ... now here's what the function actually is"
08:55:21 <elliott> it's
08:55:21 <danols_work> elliott: good point but still
08:55:24 <kallisti> danols_work: not if it's well-written
08:55:27 <int-e> there's http://www.haskell.org/haskellwiki/Obfuscation
08:55:34 <elliott> "here's what the function is, defined in terms of these helper functions which are given more context by their use above"
08:56:04 <elliott> a function definition should ideally only be one to four lines, so the "where" clause isn't so much "below" as "right next to" the code
08:56:05 <kallisti> danols_work: I agree that in some situations a let is more readable, but for a function with many small well-named subcomponents, a where is better because it shows the top-down structure.
08:56:21 <ion>     f = (+1)
08:56:23 <ion>   where
08:56:28 <ion> succs = map f
08:56:36 <ion> Reminds me of top-posting.
08:56:41 <danols_work> this is not an attack just an observation :)
08:56:42 <elliott> yes, danols_work's argument is basically one for bottom-up design :)
08:56:52 <elliott> defining all the little low-level components before revealing what you're actually talking about
08:56:57 * elliott doesn't interpret it as an attack -- just disagrees
08:56:59 <danols_work> elliott: yes
08:57:01 <copumpkin> yeah, if my where clause ends up having more than a handful of things in it, it's time to split up the function
08:57:14 <elliott> and, IMO, bottom-up design is a bad way to go about things most of the time
08:57:26 <danols_work> exactly --- when reading the book that's the thing that jumped out at me, and hoped I could put where at top of definition
08:57:37 * roconnor writes code starting from the middle
08:57:46 <elliott> but yeah, you can always just promote where clauses to real definitions if they get out of hand
08:57:54 <danols_work> elliott: bottom-up design and syntax here though are much different animals
08:57:56 * kallisti does this often.
08:58:07 <nand`> how do I run lambdabot in irc mode?
08:58:08 <elliott> also, foo a b c = go 0 1 [] c (a:b) where go ... = ...
08:58:21 <elliott> there, having the code before the "where" is exactly what you want, it's like the head of a for loop in C
08:58:27 <roconnor> So I've been starting to think that I shouldn't use where clauses for things that don't depend the the functions parameters.
08:58:47 <roconnor> Often I use where clauses for hiding functions, but maybe I should use the module system for that.
08:58:51 <kallisti> roconnor: maybe. it depends on how important the function is..
08:58:56 <elliott> roconnor: what about loops like ^?
08:59:03 <copumpkin> roconnor: which module system? :P
08:59:09 <elliott> those don't reference the params but don't make sense to split into their own definitions
08:59:17 <elliott> ...shadowing with a where clause is just evil though
08:59:21 <ion> roconnor: This would be elegantly symmetric:
08:59:26 <ion>     ys = [0..]
08:59:28 <ion>   where
08:59:30 * hackagebot fb 0.7 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7 (FelipeLessa)
08:59:31 <ion> xs = zip xs ys
08:59:32 <roconnor> elliott: I've had some recent problems with accidental capturing of function parameters :(
08:59:32 * hackagebot yesod-auth-fb 0.10.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-0.10.1 (FelipeLessa)
08:59:32 <ion>   where
08:59:33 <kallisti> @pl (\f -> f m cs)
08:59:33 <lambdabot> flip ($ m) cs
08:59:39 <ion>     zs = [1..]
08:59:45 <ion> (meant zip ys zs)
08:59:56 <elliott> roconnor: -Wall catches that, does it not?
09:00:07 <elliott> well, i guess not if you just use them accidentally
09:00:13 <danols_work> also when you are used 'to the haskell' way it's hard to see what I am trying to point out, anywho thanks for listening,
09:00:18 <danols_work> just an observation from a beginner
09:00:28 <elliott> danols_work: i saw what you were pointing out
09:00:36 <danols_work> k
09:00:46 <elliott> and it certainly applies sometimes, it's just that those times are when where clauses are inappropriate :)
09:01:03 <danols_work> k, thanks all
09:01:10 <danols_work> thanks elliott
09:03:09 <kallisti> @hoogle void
09:03:10 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:03:11 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
09:03:11 <lambdabot> package void
09:03:19 <kallisti> oh..
09:03:34 <roconnor> boo
09:03:36 <roconnor> that name is take
09:03:43 <kallisti> I'm guessing the function in Foreign.Marshal.Error is to account for what was once a lack of void in Control.Monad?
09:03:49 <roconnor> *taken
09:04:27 <roconnor> Functor f => f a -> f () should be called map!
09:04:39 <rwbarton> uh
09:04:48 <roconnor> but that isn't allowed in haskell
09:04:51 <rwbarton> oh
09:04:57 <roconnor> (the ! isn't punctuation :P)
09:05:03 <rwbarton> you mean '"map!"', not '"map"!'
09:05:07 <roconnor> :D
09:05:19 <monochrom> putting things inside "where" certainly inhibits testing them
09:05:32 <roconnor> monochrom: that's another good point
09:05:59 <roconnor> monochrom: how do you feel about pulling more things out of where clauses?
09:06:18 <ion> rwbarton: Except that in English they put dots and commas that don’t belong to the quotation inside the quotation, and to be consistent one would also need to do that for other punctuation, making “map!” ambiguous. :-P
09:06:45 <monochrom> apart from ease of testing, I don't mind either way. and usually I don't need to test many things
09:06:49 <CodeWeaver1> There's definitely some push-back I think about quoting exact quotes rather than mangling it based on terminating punctuation.
09:07:33 <kallisti> Warning: A do-notation statement discarded a result of type IO ().
09:07:34 <dainanaki> I find that pulling out functions from where clauses helps since it makes it easier to verify the types involved.
09:07:34 <kallisti> uh, what.
09:07:52 <kallisti> why is this a problem. o_o
09:08:06 <roconnor> dainanaki: well you can add type annotations in where clauses
09:08:29 <roconnor> dainanaki: hmm, unless type variables are involved :(
09:08:40 <tgeeky> but you can't ask ghci what the type of something in a where clause is :/
09:08:44 <elliott> roconnor: ! :: a -> ()? :p
09:08:48 <dainanaki> that was my point
09:08:58 <roconnor> ah
09:09:05 * elliott isn't sure why you'd test where definitions
09:09:09 <cmccann> roconnor, my rule of thumb is that if promoting a function to top level would more than double how many parameters it takes, I leave it in the where clause
09:09:13 <elliott> they're meant to be black-box internals, after all; test the thing you actually use
09:09:14 <monochrom> if type variables are involved, especially scoped, you have to put inside "where". then again it is a special case of "depends on parent's parameters" and covered
09:09:16 <kmc> kallisti, you got a value and threw it out?  you probably have something of type IO (IO ()) when you wanted IO ()
09:09:26 <kallisti> oh hmm
09:09:34 <elliott> kallisti: you forgot a join
09:09:41 <roconnor> cmccann: I was thinking of starting with promoting functions that would keep the number of parameters fixed.
09:09:49 <kallisti> elliott: typically for me that means I used a <$> when I meant =<<
09:10:14 <kallisti> okay that fixed it.
09:10:19 <kmc> this is like the perfect illustrative case for that warning
09:10:19 <monochrom> as a consolation, with GHC with -O, putting inside "where" and putting top level unexported are the same, so you can really choose whichever way you want
09:10:29 <ion> Yes, f =<< x = join (f <$> x).
09:10:50 <Sgeo> There needs to be an entry in the FAQ about "I used <$> and now my action isn't running"
09:10:50 <Sgeo> Or something
09:10:55 <Sgeo> >.>
09:11:15 <CodeWeaver1> >.>    The 'dodge' operator.
09:11:16 <kallisti> Sgeo: probably not very frequently asked
09:11:37 <kallisti> "wtf is this warning about IO ()" is probably a better FAQ
09:11:51 <cmccann> roconnor, functions that don't use anything not bound at top-level and do something meaningful outside the context of the where clause probably belong at top-level, I think
09:12:19 <kmc> you should add it to the FAQ!
09:12:39 <roconnor> cmccann: sometimes they have the first crieterion but not the second ... depending on what you mean by "meaningful"
09:12:56 <roconnor> cmccann: ie sometime these helper functions are only used by this one function
09:13:01 <cmccann> roconnor, meaning that I don't always want to promote auxiliary functions
09:13:01 <roconnor> *sometimes
09:13:06 <roconnor> ah
09:13:06 <elliott> it's really a case-by-case thing i think
09:13:26 <elliott> roconnor: here's a good reason to use where clauses: it makes your module scan easier
09:13:32 <elliott> you can see every important definition by the column it's in
09:13:43 <cmccann> like where "foo" does something recursive, but mangles parameters then calls an auxiliary function that does the actual loop
09:13:44 <elliott> rather than having to read each definition to see whether it's a helper function for something else or not
09:14:12 <roconnor> elliott: I agree, though this can be mitiguted somewhat by sending the helper functions to the end of the file, but OTOH that pulls it away from where it is being used. :(
09:14:16 <cmccann> putting the auxiliary function at top-level would just create a redundant version of foo with a more awkward type
09:14:20 <elliott> roconnor: yeah that's worse :P
09:14:45 <elliott> roconnor: I would focus on making sure the errors you've run into are caught with compiler warnings rather than not using where as much
09:15:02 <roconnor> ya, maybe I need to use -Wall more
09:15:12 <roconnor> I seem to recall i get some stupid warnings though
09:15:14 <roconnor> let me check
09:16:19 <roconnor> ya a couple
09:16:25 <roconnor>     Warning: Defined but not used: data constructor `E8'
09:16:44 <roconnor> oh and one really bad one
09:16:47 <roconnor> that I need to hpaste
09:16:51 <elliott> roconnor: so -fno-<warn> them
09:16:57 <elliott> in your cabal file or whatever
09:17:04 <elliott> or just turn on all the warnings you want manually
09:17:19 <elliott> roconnor: (but that does seem like a good warning to me, as it means you did not even export that constructor)
09:17:21 <oxryly> is there a way to declare a type of string that contains no whitespace?
09:17:54 <elliott> sort of
09:18:15 <tromp_> if you hide the constructor
09:18:19 <roconnor> elliott: ya, but E8 is just used to be an instance of Data.Fixed.HasResolution
09:18:25 <elliott> newtype NoWhitespace = NoWhitespace String; toString (NoWhitespace s) = s; fromString s | all (not . isSpace) s = NoWhiteSpace s | otherwise = error "no"
09:18:29 <elliott> and don't export the constructor
09:18:32 <elliott> roconnor: ah
09:18:59 <roconnor> http://hpaste.org/57193
09:19:06 * cmccann hopes nobody actually uses (error "no") to handle stuff like that
09:19:06 <roconnor> this is the worst warning cause I have tonnes of them
09:19:13 <roconnor> and fixing the warning would make the code harder to read.
09:19:14 <rwbarton> data CharThatIsn'tSpace = CharThatIsn'tSpaceNUL | CharThatIsn'tSpaceSOH | ...; type SpacelessString = [CharThatIsn'tSpace]
09:20:53 <oxryly> elliott: cool thanks.   so i put that in it's own module and use toString and fromString everywhere?
09:20:55 <elliott> rwbarton: beautiful
09:21:21 <elliott> oxryly: yeah -- you'll probably also want to do deriving (Eq, Ord, Show)
09:21:27 <elliott> oxryly: and define a bunch of operations like map etc.
09:21:33 <elliott> it's cumbersome though
09:21:34 <rwbarton> Stay tuned for my GADT version!
09:21:42 <roconnor> rwbarton: that is nice
09:21:42 <elliott> oxryly: of course, you can always just do: fromString . map f . toString
09:21:53 <elliott> oh i guess plain map isn't safe on NoWhitespaces
09:21:56 <cmccann> rwbarton, you should use type-level numbers to represent the unicode code points
09:21:56 <elliott> since it could return ' ', anyway
09:22:04 <roconnor> rwbarton: capturing invarients in your types is proper programming
09:22:17 <rwbarton> data UnicodeChar isAlpha isUpper isLower isSpace isPunctuation where
09:22:21 <oxryly> elliott: ok yeah.. conversion to string to do string operations in general
09:22:31 <roconnor> (see if only Yegge made jokes like that)
09:22:33 <rwbarton> {- 1114112 lines follow -}
09:23:09 * elliott tries to figure out roconnor's joke
09:23:21 <roconnor> elliott: it is rwbarton's joke
09:23:24 <Tomsik> and then you could write things like
09:23:39 <Tomsik> H.E.L.L.O $ ()
09:23:43 <Tomsik> Or something
09:23:48 <elliott> rwbarton: not all of those are allocated, are they?
09:23:50 <elliott> roconnor: ah
09:23:52 <rwbarton> no
09:23:59 <elliott> rwbarton: don't needa ll those lines then!
09:24:10 <elliott> Tomsik: need spaces thanks to the module system
09:24:11 <roconnor> elliott: how would you deal with my Defualting warning for writing (2 ^ 32) ?
09:24:16 <roconnor> elliott: turn off that warning?
09:24:46 <elliott> roconnor: oh, sorry, I didn't see that
09:24:55 <roconnor> elliott: http://hpaste.org/57193
09:24:58 <elliott> roconnor: yeah, then i saw it :)
09:25:06 <elliott> -fno-warn-type-defaults
09:25:12 <elliott> although I'd be tempted to add an annotation there anyway
09:25:18 <elliott> :t (^)
09:25:19 <roconnor> I was too
09:25:20 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:25:23 <roconnor> but it is really ugly
09:25:23 <elliott> (^)'s type is so terrible :(
09:25:31 <elliott> roconnor: define your own (^) that requires the same type on both sides :p
09:25:45 <roconnor> I'm sort of inclined to make a module specific implementation of (^)
09:25:47 <roconnor> ya
09:25:58 <elliott> :t (^^)
09:26:00 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
09:26:02 <elliott> gah!
09:26:04 <elliott> none of the names are free
09:26:08 <elliott> (^**^) = ...
09:26:10 <roconnor> I'll just use (**)
09:26:15 <rwbarton> ...
09:26:16 <elliott> :t (**)
09:26:17 <lambdabot> forall a. (Floating a) => a -> a -> a
09:26:18 <roconnor> what could go wrong
09:26:18 <elliott> that's taken too :P
09:26:30 <roconnor> ya but all the types are the same in (**)
09:26:41 <ion> ^-^
09:26:50 <oxryly> pow
09:26:56 <ion> (^-^)
09:27:21 <cmccann> ion, as always Haskell leads the world in syntactically-valid emoticons
09:27:29 <rwbarton> @hoogle (^-^)
09:27:29 <lambdabot> No results found
09:27:29 <roconnor> (^) :: (Num a) => a -> Integer -> a  (^) = (Prelude.^)
09:27:29 <Tomsik> (>^__^ >)
09:27:36 <roconnor> import Prelude hiding ((^))
09:27:51 <dainanaki> (<%~%>)
09:28:05 <oxryly> ah, "import Prelude hiding"   a sign of interesting times
09:28:21 <roconnor> I use it quite a bit
09:28:43 <CodeWeaver1> @hoogle ( =^o.o^=_____/ )
09:28:43 <lambdabot> Parse error:
09:28:43 <lambdabot>   ( =^o.o^=_____/ )
09:28:43 <lambdabot>       ^
09:28:45 <ion> An operator taken already? Just add < > around the name.
09:28:47 <roconnor> import Prelude hiding (pi)
09:28:52 * cmccann often does import Prelude (), import IdiosyncraticAlternatePrelude
09:28:57 <ion> (<^>)
09:28:58 <dainanaki> I appreciate that the prelude is supposed to be beginner-friendly, but it gets annoying after a while for taking up so many good names.
09:29:08 <roconnor> import Prelude hiding (length)
09:29:15 * cmccann notes that ಠ_ಠ is a valid identifier
09:29:16 <roconnor> import Prelude hiding (tan)
09:29:33 <cmccann> import Prelude hiding ((.), id) happens a lot :P
09:29:44 <CodeWeaver1> I am totally using that, cmccann.
09:29:45 <CodeWeaver1> :D
09:29:51 <dainanaki> let ಠ_ಠ = unsafePerformIO
09:30:00 <CodeWeaver1> HAHAHAHAHAHA
09:30:20 <ion> tan :: TanningAmount → Human → IO ()
09:30:36 <roconnor> ion: tan is a colour.
09:30:50 <CodeWeaver1> tan :: RGB
09:30:56 <roconnor> no no
09:31:02 <roconnor> tan :: Colour a
09:31:21 <ion> tan :: Colour a => a
09:31:26 <CodeWeaver1> tan :: Colour a => a
09:31:29 <elliott> cmccann: you import the prelude instances?!
09:31:30 <cmccann> roconnor, oh yeah Data.Colour is yours, right?
09:31:34 <elliott> not good enough!!!
09:31:38 <roconnor> tan :: (Ord a, Floating a) => Colour a
09:31:47 <CodeWeaver1> Hah
09:31:47 <CodeWeaver1> :D
09:31:53 <CodeWeaver1> This could get outta hand in a hurry
09:32:04 <roconnor> I forget where Ord comes in :(
09:32:09 <elliott> I like the colour package because it promotes the correct spelling of "colour" and must infuriate people using it who forget to spell it correctlyt.
09:32:12 <roconnor> probably for clipping.
09:32:14 <elliott> *-t
09:32:16 <cmccann> elliott, yes, my idiosyncratic alternate preludes mostly move things around, hide useless functions like head and tail, and give other things different names
09:32:24 <ion> tan :: Tan a => a  -- Both the color and the tangent function are instances.
09:32:26 <CodeWeaver1> elliott wins the internetz with that typo
09:32:44 <elliott> cmccann: if you used NoImplicitPrelude you could skip the import line
09:32:50 <elliott> cmccann: and redefine Monad without losing do notation
09:33:10 <cmccann> yes, but that's more drastic, and also a huge pain
09:33:16 <cmccann> I've done that as well and got tired of it
09:33:49 <dainanaki> ooh, this is an even better disappoint-face definition:
09:34:04 <dainanaki> let ಠ_ಠ = unsafeCoerce . unsafePerformIO . unsafeCoerce
09:34:23 <CodeWeaver1> O.o
09:34:31 * hackagebot Octree 0.2.1 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.2.1 (MichalGajda)
09:34:49 <elliott> cmccann: hmm, how is it a pain?
09:35:05 <Sgeo> Is there any reason to use the Prelude's folds over Data.Foldable foldsa?
09:35:06 <elliott> (GHC should really have a -use-prelude option so that you can use NoImplicitPrelude without writing an import line in every module)
09:35:06 <Sgeo> *folds
09:40:13 <shachaf> Isn't Data.Foldable more like Data.ToListable?
09:41:16 <CodeWeaver1> From what I recall you can use it to fold a container of data without actually producing any lists.
09:41:23 <CodeWeaver1> A binary tree being the obvious example.
09:41:32 <cmccann> elliott, well, it tends to make stuff incompatible with other code, and replacing/wrapping/re-exporting all the stuff in the standard libraries is a lot of effort
09:42:27 <roconnor> dainanaki: that is disturbingly unsafe
09:42:32 <elliott> hmm, I guess compatibility is a pain, yeah
09:42:41 <elliott> but it still saves a line even if you just re-export the classes from the Prelude!
09:43:09 <cmccann> elliott, it only saves a line if you use compiler flags
09:43:16 <cmccann> otherwise you're trading import Prelude () for a language pragma
09:43:43 <cmccann> and I prefer modules to be self-contained so that I can load them as-is in GHCi
09:44:25 <dainanaki> roconnor, I actually used something like that to cast an IO action that produced a list of newtype values which were really pointers under the hood to do some crazy pointer magic and then cast them into a different newtype value which had the same data representation under the hood.
09:44:30 <dainanaki> I'm a terrible person.
09:44:41 <roconnor> dainanaki: yes you are
09:44:53 <CodeWeaver1> dainanaki:  excellent.  carry on. :D
09:45:03 <CodeWeaver1> <— enabler
09:45:40 <cmccann> CodeWeaver1, did you ever get something satisfactory for those Pythagorean triples?
09:45:52 <dainanaki> To be fair, I at least had a monomorphic type signature on the function in question.
09:46:49 <CodeWeaver1> cmccann, no, but apparently I *severely* nerdsniped a math friend of mine.
09:46:56 <cmccann> CodeWeaver1, haha
09:47:12 <CodeWeaver1> I mean, I got the ability to produce triples, but they included non-primitive ones.
09:47:19 <CodeWeaver1> So in that sense I got a (slow) success.
09:47:34 <CodeWeaver1> But my friend pointed out that I really should be trying to do it for *primitive* tuples.
09:47:39 <cmccann> producing primitive triples without the ordering you want is easy enough
09:47:41 <CodeWeaver1> And that turns out to be somewhat compliex.
09:47:45 <CodeWeaver1> Yes, I know.
09:48:01 <CodeWeaver1> ordering, or primitive.  Easyish.  Both is hard on the complexity.
09:48:24 <CodeWeaver1> So fair enough, I nerd-sniped him, and he nerd-sniped me back.
09:48:29 <cmccann> generating primitives is easy and fast, so finding a way to prune the generation algorithm seems promising
09:48:39 <CodeWeaver1> We're trying.
09:48:41 <CodeWeaver1> Not succeeding yet.
09:48:53 <CodeWeaver1> We can't prove through primitive generation techniques that we aren't missing one 'in order'.  Not yet.
09:48:54 <cmccann> what ordering did you want, again?
09:49:05 <CodeWeaver1> ordered by y major and x minor.
09:49:17 <CodeWeaver1> Somewhat arbitrary, but the x varies fastest up to but not exceeding y.
09:50:37 <elliott> <cmccann> elliott, it only saves a line if you use compiler flags
09:50:42 <elliott> cmccann: yeah, we need a cabal-aware ghci :(
09:50:46 <elliott> and a cabal aware emacs
09:50:48 <elliott> and a cabal aware everything
09:51:08 <elliott> ghci should just traverse up from the directory of the file you load to find a .cabal file and apply all the settings
09:51:09 <eviltwin_b> I think there was a plan for cabal to be able to wrap ghci
09:51:15 <eviltwin_b> I don't recall if anythijng came of it
09:51:55 <eviltwin_b> doesn't look like it's in 0.10.2 at least
09:53:26 <eviltwin_b> @hackage cabal-ghci
09:53:26 <lambdabot> http://hackage.haskell.org/package/cabal-ghci
09:55:41 <tibbe> elliott: last year's GSoC added cabal repl, which launches ghci using your cabal config. I also think it rebinds :r to do the right thing
09:55:49 <Ngevd> Hello
09:55:49 <tibbe> i.e. rerun cabal build
09:55:55 <elliott> tibbe: \o/
09:56:00 <elliott> now we need that bound to C-c C-l
09:56:06 <elliott> (and cabal-dev'ised)
09:56:09 <tibbe> elliott: that would be nice
09:56:30 <tibbe> elliott: could probably follow the pattern used for :r. The way it works is that ghci reads a small script on startup that overrides :r
09:56:39 <Lemmih> tibbe: What version of cabal is that in?
09:56:42 <tibbe> elliott: the main problem is that the next version of cabal is long overdue
09:56:50 <tibbe> Lemmih, no released version
09:56:57 <tibbe> Lemmih, dcoutts_ is very busy
09:57:11 <Lemmih> But it has been pushed to head?
10:07:25 <CodeWeaver> Back shortly.
10:14:28 <Lemmih> tibbe: I don't see it in head. /-:
10:14:31 * hackagebot BerkeleyDB 0.8.5 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.5 (StephenBlackheath)
10:27:59 <leino> Hello everyone. I am trying to do 'modern opengl' in Haskell. I am following the example at: http://www.arcadianvisions.com/blog/?p=224
10:29:32 * hackagebot email-validate 0.2.8 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-0.2.8 (GeorgePollard)
10:30:25 <leino> in the required GLUtil library, I am getting some ambiguous references to GLfloat, due to the fact that the file Shaders.hs includes both Graphics.Rendering.OpenGL and Graphics.Rendering.OpenGL.Raw.Core31
10:30:40 <leino> (GLfloat is defined in both of these)
10:31:05 <leino> pretty silly, but I don't know how to get around this problem...
10:31:07 <Ngevd> import Graphics.Rendering.OpenGL.Raw.Core31 hiding (GLFLoat)?
10:31:15 <Ngevd> Without the ?
10:31:33 <Ngevd> Assuming the two GLfloats are the same
10:31:49 <leino> well, Core31 is included for other reasons than to get GLfloat :), some functions which are in Core31 are not in the plain OpenGL library
10:32:08 <leino> and those functions want the GLfloat from ..OpenGL.Core31
10:32:21 <Ngevd> "import Graphics.Rendering.OpenGL hiding (GLfloat)" should work
10:32:28 <leino> I tried doing that
10:32:37 <Ngevd> What happened?
10:33:46 <leino> it said that the functions glUniform* wanted the GLfloat from Graphics.Rendering.OpenGL.Raw.Core31, which is now hidden
10:33:57 <bgamari> What does it mean when my program's working set monotonically increases in size due to std_sel_upd and stg_ap_2_upd_info objects?
10:34:30 <Ngevd> Try putting the hiding clause in Graphics.Rendering.OpenGL?
10:34:46 <leino> Ngevd: basically, functions from usual opengl and raw opengl are sharing variables of GLfloat type so I don't think that will work!
10:36:42 <znutar> What does non-raw opengl do differently anyways?
10:38:10 <leino> znutar: not sure, but the tutorial doing "modern opengl" is using the raw version as well. I think the raw interface is more a straight translation from the c api to haskell; the usual one is not as exhaustive
10:38:58 <mreh> did someone say I could convert an array to a ptr?
10:40:19 <znutar> Yeah, pre-3.1 opengl has a lot of legacy kruft for things that mapped well to graphics hardware circa 1995 but doesn't match current generation stuff well at all and ends up stuck in weird places in the drivers and/or tricky bits of the hardware that are there just to handle legacy things.
10:40:22 <leino> Ngevd: ok, more precisely what happens if I do 'import Graphics.Rendering.OpenGL hiding (GLfloat)' is that I get an error saying that there is no instance for MatrixComponent for GLfloat's... (since GLfloat's are hidden and that instance is not defined in the 'raw opengl' module)
10:42:57 <Baughn> This is somewhat academic, since I should actually be using insertWith', but is there a way to make Data.Map.unionWith value-strict?
10:44:14 <roconnor> Baughn: Data.Map.Strict.unionWith ?
10:44:32 <Baughn> roconnor: I don't have that module.
10:45:21 <Baughn> roconnor: ..actually, where /is/ it defined? I can't seem to find it in hackage.
10:45:30 <roconnor> oh, maybe it is unreleased
10:46:30 <roconnor> Baughn: apparently it is in the unreleased containers 0.5 version
10:46:49 <Baughn> Ah.
10:46:53 <roconnor> ... it's in github
10:46:55 <Baughn> I'll just use insertWith.
10:47:12 <Baughn> Can I assume there's no clever way to make unionWith strict without redefining it? :P
10:48:36 * prof7bit writing little Haskell IDE to make life easier: http://imagebin.org/196393 (got too much time)
10:48:59 <roconnor> Baughn: I cannot imagine one, but I lack imagination
10:49:26 <elliott> prof7bit: cool
10:49:30 <Baughn> piis3141: Looks nice. Have you tried Emacs?
10:49:40 <elliott> how long did that take to get working?
10:49:50 <prof7bit> i don't write it in haskell ;-)
10:49:54 <piis3141> Baughn: huh?
10:50:03 <Baughn> prof7bit, I mean
10:50:22 <efie> at some points in my screen terminal application i want to hide every text which has been shown before and display something new at the top of the prompt. if i print enough newlines to hide the old text, the next is printed at the bottom of the prompt. if i use "clear screen" the text still is not displayed at the top but somewhere in the middle of the screen. is there a solution to this?
10:50:33 <Baughn> efie: Yes, use ncurses.
10:50:43 <piis3141> Baughn: ok (and yes I have tried Emacs)
10:50:49 <Baughn> efie: Or more appropriately, hscurses
10:51:25 <prof7bit> once I know more haskell I will start writing *parts* of it in haskell, for example properly interfacing with the ghc API, parsing error messages, etc. But for the GUI I am using my favorite RAD tool.
10:52:19 <prof7bit> Baughn: I have tried using Emacs several times, but cannot make friends with it
10:52:33 <Baughn> prof7bit: I see
10:53:01 <prof7bit> its ust too different from everything else I use. (everything = CUA key bindings and behavior etc.)
10:53:09 <elliott> cua-mode :P
10:53:59 <prof7bit> tried cua-mode that too, its a little better but still cannot convince me
10:54:21 <tech2> cua-mode is the wrong way to try using emacs, it's like trying to swim without getting wet.
10:56:42 <tswett> Do forgive me, but given two abelian groups A and B, is their tensor product simply the free abelian group generated by the underlying set of A x B?
10:56:46 <prof7bit> when I need to edit on the command line (for example when ssh from remote) i use joe (I know its not CUA also but for some strange reason I am used to joe's shortcuts from another application on the C-64 from 25 years ago)
10:57:06 <roconnor> tswett: their tensor is as if they were Z-modules
10:57:09 <roconnor> tswett: which they are
10:58:44 <efie> baughn: thanks for your reply. "cabal install hscurses" fails: Missing (or bad) header file: HSCurses.h, Missing library: curses
10:59:13 <rwbarton> take the free abelian group generated by the underlying set of A x B and introduce relations which state that (x) is linear in each variable separately
10:59:16 <Baughn> efie: Install ncurses-dev.
11:00:58 <tibbe> Lemmih, sigh, perhaps the patches haven't been merged yet
11:00:58 <efie> baughn: this is not a package, is it?
11:02:14 <efie> i am not sure where to download / how to install it
11:02:27 <Baughn> efie: Your linux distribution will have a copy
11:02:33 <tswett> rwbarton: oh, right.  So the relations make it a quotient group of what I said.
11:02:42 <efie> baughn: i am using windows
11:02:51 <Baughn> efie: Oh..
11:03:01 <Baughn> efie: Maybe you can use pdcurses? ...
11:03:21 <Baughn> efie: ..you're probably screwed. Windows is not well set up for this kind of programming.
11:03:43 <Baughn> Might want to install Linux
11:05:48 <tswett> Well, surely there exists a package manager for Windows, so that installing ncurses-dev is as easy as typing "sudo apt-get install ncurses-dev".
11:05:56 <tswett> But if there is one, I don't know what it is.
11:06:37 <Baughn> tswett: Don't be silly. There's no such thing, nor a standard location for libraries and headers.
11:06:59 <Baughn> That would make too much sense.
11:07:39 <tswett> It would, wouldn't it.
11:07:40 <luite> mingw-get install should do it eventually, but progress is slow
11:08:42 <Baughn> Also mingw is not typically installed
11:10:04 <efie> this might be a stupid question, but i cannot create a .exe file under linux and execute it under windows with the clearingscreen function working, can i?
11:10:23 <elliott> Linux can cross-compile.
11:10:25 <elliott> But GHC can't.
11:10:26 <elliott> So no.
11:10:34 <elliott> (s/Linux/Typical Linux development tools/)
11:10:50 <elliott> *However* you could run GHC in Wine... which would eliminate the advantage of the package-manager for the most part.
11:11:02 <tommd> Owch, owch, owch.
11:11:04 <mreh> do they talk about ptrs in RWH?
11:11:22 <tommd> They talk some about interfacing for foreign code, and that's part of it.
11:11:27 <tommd> s/for/with/
11:11:37 <Baughn> mreh: Ptrs? What do you want to know?
11:11:57 <mreh> Baughn: how to manipulate them, how they work
11:12:33 <mreh> the interface for advancing them is pure, but the interfcae for reading/writing to them isn't
11:13:06 <Baughn> mreh: Well, effectively the same as pointers in C
11:13:10 <rwbarton> yes
11:13:17 <Baughn> You can do the same pointer arithmetic, etc.
11:13:26 <Baughn> And that /is/ just arithmetic, so of course it's pure
11:13:37 <rwbarton> a Ptr Whatever is basically just an integral type of the appropriate size for your architecture, but thought of as representing an address in memory
11:13:58 <Baughn> Right. GHC might well have newtype Ptr = Ptr Word somewhere.
11:13:59 <efie> this means i have to change to linux as a whole? i did not really like creating a GUI in haskell, but without such a clearing function it makes no sense to do a terminal application under windos as well. there really is not such a function for windows?
11:14:17 <Baughn> efie: There is pdcurses
11:14:34 <Baughn> efie: I do not know how well hscurses works with that though, if at all
11:14:45 <Baughn> efie: In general, it's far easier to learn programming on Linux than Windows
11:15:00 <efie> why?
11:15:15 <Baughn> Because Linux was made by programmers, for programmers.
11:15:24 <Baughn> Windows was made by programmers, for non-programmers. :P
11:15:31 <efie> :D
11:15:36 <efie> ok
11:15:50 <Baughn> Also the ability for me to say something like "Just apt-get install ncurses-dev" to fix that hscurses error
11:16:01 <Baughn> Or "Just apt-get install haskell-platform" to install Haskell in the first place
11:16:57 <ion> I’d say the availability of quite decent package managers helps since it’s often trivial to get the libraries etc. you need. Having something like Cabal (in the case of Haskell) for Windows reduces the pain, though.
11:17:01 <Baughn> efie: Of course knowledge gained about unix doesn't transfer to Windows very well, but in general being a unix (linux, perhaps) administrator/coder is a better life than writing CRUD apps in windows.
11:17:11 <Baughn> IMO, anyway
11:18:23 <smoge> I want to parse files that can have different deconding and eol. Is there a wise advise on that?
11:18:49 <smoge> files from people that will edit them on random OS and text editors
11:19:07 <Baughn> smoge: EOL style? As in, CR/LF?
11:19:29 <smoge> yes. Parse subtitle files made by non-tech people
11:19:40 <smoge> I can expect different standards
11:20:08 <Baughn> smoge: The /simple/ answer is to assume everything is utf-8 unless told otherwise, and do something like "many1 (oneOf [cr, lf])" for the line-ending
11:20:11 <smoge> I'm not familiar with this, but I guess some windows editors will do womething different?
11:20:29 <Baughn> Though probably less willing to collapse blank lines
11:20:35 <efie> baughn: convincing reaons. i installed pdcurses, but the same error occures. i guess i will really switch to linux... and then might ask again ;)
11:20:44 <ion> smoge: If you want to parse a file with a single predetermined EOL style etc, you could have a data structure with the intended parsers and carry it around. If you want to support files with arbitrary EOL styles (even mixed), just have your EOL parser accept either one of them.
11:20:52 <donri> or, make your program take options for eol style and encoding. safest bet.
11:21:06 <donri> well, eol can probably be automated unless there's ambiguity in the format.
11:21:24 <Baughn> It's a subtitle file.. probably no ambiguity.
11:21:26 <smoge> I guess some of the files are mixed
11:21:32 <Baughn> I figure a relatively simple parsec parser can handle this.
11:21:37 <smoge> when I open in emacs, I gewt strange characters
11:21:41 <tomprince> Well, if the only issue is eol style, \r?\n would handle either and mixed.
11:22:01 <ion> With subtitle files i’d just make the parser tolerant against whatever crap people come up with.
11:22:04 * Baughn generally tries not to abuse regexen
11:22:21 <smoge> thanks
11:22:39 * tomprince doesn't know parsec off the top of my head
11:22:45 <elliott> I wouldn't assume utf-8.
11:22:47 <elliott> If Windows is involved.
11:23:07 <elliott> smoge: The user must specify the encoding the file is in if you can't just force UTF-8; there is no truly reliable way to detect character encoding.
11:23:23 <smoge> really? hum..
11:23:24 <rwbarton> it's not really "abusing" regexes until you write stuff like (?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)
11:23:42 <Baughn> smoge: For one thing, the pre-unicode codepages don't have /invalid/ forms
11:23:50 <Baughn> smoge: Absolutely anything is valid ISO-8859-1
11:23:51 <smoge> would be nice to detect it, because the authors probably won't know it
11:24:07 <rostayob> How do I tell cabal to use a specific version of GHC?
11:24:11 <efie> baughn: cna you recommend a linux distribution most suitable for programmers? (is there one?)
11:24:25 <donri> efie: oh, don't go there. xD
11:24:27 <Baughn> smoge: The usual trick is to try utf-8, then try utf-16, then fall back to iso-8859-1. That mostly works.
11:24:38 <Baughn> smoge: But always, *always* provide a manual override.
11:24:51 <Baughn> efie: You want gentooarchbuntulinux
11:25:02 <Baughn> efie: Er.
11:25:15 <Baughn> efie: For now, I'd default to Ubuntu.
11:25:17 <elliott> efie: If you don't want to spend ages tweaking things, just install Ubuntu or Debian.
11:25:17 <donri> efie: i suggest ubuntu because it's most likely to just work for you
11:25:27 <tech2> efie: I'm not advocating anything, but the debians (debian and ubuntu being the more popular) generally have the largest base of packages available, which can make some things easier. But it all depends what you're most comfortable with.
11:25:33 <elliott> Learning Linux in depth and Haskell simultaneously might be fun but it won't be efficient.
11:25:45 <ion> If you know the locality from where the file came, you can often make a very good guess. For Finnish text, trying UTF-8 first and falling back to CP1252 (which is a Microsoft™ superset of ISO-8859-1 which is a superset of ASCII) works right almost certainly.
11:25:55 <Baughn> efie: Linux breaks about as easily as Windows. The saving grace is that, unlike windows, it's typically quite easy to /fix/.
11:26:09 <Baughn> And also that it'S easier to avoid breaking it.
11:26:22 <elliott> (My experience is basically the opposite, if anything.)
11:26:22 <Baughn> But some distributions, like Ubuntu, make it harder to fix..
11:26:41 <donri> I'd say it's less prone to breaking /by design/ (e.g. installation from trusted repositories rather than random googling)
11:26:45 <elliott> (When a Linux system breaks hard it takes days to fix; but it rarely does this decade.)
11:26:47 <smoge> I like archlinux, easy to do what you want
11:27:04 <Baughn> efie: Ubuntu will likely work out of the box, but if it breaks it'll often break mysteriously. Debian will need more up-front work and understanding, but is also quite a lot more solid and easier to understand.
11:27:36 <elliott> I think that's an odd statement considering Ubuntu is still essentially Debian.
11:27:38 <ion> Huh. Ubuntu is *very* similar to Debian.
11:27:47 <Baughn> True, Ubuntu is built on Debian.
11:27:58 <cmccann> my experience is that windows is more likely to break for unclear reasons, rather than "because I did something intentionally dumb"
11:28:02 <Baughn> It's the autodetection and message bus stuff they've added that tends to break mysteriously
11:28:08 <cmccann> but it's also much easier to do intentionally dumb things to a linux system
11:28:11 <elliott> And I wouldn't think the layers of gloss and autoconfiguration on top would mask failures.
11:28:17 <elliott> If anything, they'll show them up, because they'll stop working.
11:28:33 <prof7bit> i have never really seen my Ubuntu "breaking" nd I do a lot of stupid things sometimes
11:28:42 <donri> Personally, I'm partial to the oft-neglected Fedora. But I'll still suggest Ubuntu to a beginner.
11:28:46 <Baughn> prof7bit: So long as you don't do it as root..
11:28:52 <efie> thanks for your information
11:29:41 <statusfailed> efie: is it too late to suggest Arch Linux? :D
11:29:44 <elliott> efie: Ubuntu also has a (much) simpler installer.
11:29:58 <elliott> Arch Linux for someone trying Linux just because of Haskell, really? :)
11:30:04 <donri> stop suggesting arch linux darnit
11:30:07 <statusfailed> ahahah
11:30:10 <statusfailed> but it's so lovely :d
11:30:13 <donri> no
11:30:17 <statusfailed> it's like slackware with a package manager
11:30:19 * mekeor prefers Debian: it's both simple and configurable.
11:30:35 * elliott uses Arch and would never recommend it to a beginner.
11:30:39 <joe9> crux?
11:30:56 <elliott> Crux still exists?
11:31:11 <ion> I’d only recommend distributions where you can easily rebuild everything with -O999 -funroll-loops.
11:31:12 <joe9> elliott: stronger than ever..
11:31:25 <statusfailed> elliott: It's not worse than slackware for a beginner surely?
11:31:35 <statusfailed> I guess if you just want some haskells then something like ubuntu would be better
11:31:39 <elliott> statusfailed: Yeah, 'cuz everyone was suggesting Slackware...
11:31:43 <mekeor> when i do `head $ quicksort list', does haskell apply quicksort on the full list? or does it then really evaluate quicksort lazily?
11:31:53 <elliott> mekeor: Yes, Haskell is lazy.
11:31:57 <mekeor> nice
11:32:04 <mekeor> elliott: always?
11:32:04 <elliott> Hey, if I link http://apfelmus.nfshost.com/articles/quicksearch.html, it'll be the second time today.
11:32:16 <eviltwin_b> mekeor, haskell will be lazy, but how lazy depends on whether quicksort is written lazily
11:32:18 <elliott> mekeor: Well, no, a compiler is free to quicksort the entire list if it can prove it terminates.
11:32:21 <elliott> Strictness analysis and all that.
11:32:29 <elliott> But yes, if the sort is the right one, it'll do what you expect.
11:32:31 <Baughn> And doesn't add work..
11:32:43 <Baughn> Well, isn't Prelude.sort merge-sort though?
11:32:50 <elliott> Yes, but mekeor said quicksort.
11:32:56 <roconnor> Baughn: nothing in haskell semantics says that extra operations cannot occur
11:32:58 <prof7bit> can you sort an infinite list lazily?
11:33:07 <mekeor> alright. ty.
11:33:09 <roconnor> prof7bit: nope
11:33:13 <elliott> prof7bit: Yes, but you'll never get any elements.
11:33:17 <donri> ^_^
11:33:24 <roconnor> elliott is more correct
11:33:29 <elliott> You could for boundedSort :: (Bounded a, Ord a) => [a] -> [a], though.
11:33:36 <elliott> Actually you'd want Enum so you could get more than one element.
11:34:16 <Baughn> roconnor: Yes, true, but in practice GHC tries not to
11:34:32 <cmccann> elliott, are you sure you could get anything besides minBound from that?
11:34:34 <statusfailed> elliott: how could Enum help you get more than one?
11:34:40 <Baughn> prof7bit: If the list is infinite, how would you ever know which element should be the first one?
11:34:40 <statusfailed> dang
11:35:33 <prof7bit> Baughn: exactly. thats why I think I can pove that the soting will terminate by simply looking at the length of the list
11:35:39 <mreh> i never realised you could use guards when defining constants
11:35:52 <prof7bit> my "r" key is broken :-(
11:35:57 <cmccann> mreh, it's handy
11:36:21 <cmccann> CodeWeaver, still around?
11:36:27 <elliott> statusfailed: because
11:36:27 <mreh> it is a function with no arguments
11:36:28 <rexim> prof7bit: so how did you write "broken"?
11:36:29 <roconnor> mreh: did you know you can use pattern matching when defining constants?
11:36:30 <elliott> minBound, succ minBound
11:36:31 <statusfailed> mreh: i'm not sure I've seen that, example?
11:36:31 <elliott> etc.
11:36:35 <rexim> it contains "r"
11:36:43 <elliott> ofc Float/Double break that
11:36:46 <mreh> statusfailed: http://www.haskell.org/pipermail/hopengl/2004-May/000489.html
11:36:48 <cmccann> elliott, how do you know how many minBound elements are in the list?
11:36:49 <elliott> but Float/Double's Enum instance breaks LIFE
11:36:56 <Baughn> prof7bit: There is no way in haskell for isListInfinite to return True. ;P
11:37:01 <mreh> c.f. withCheckImage
11:37:02 <elliott> cmccann: oh, shucks. sortNubBounded, then.
11:37:06 <prof7bit> rexim: i need to hammer it really hard to make it react.
11:37:20 <mreh> roconnor: no
11:37:28 <mreh> pattern matching what? it has no arguments
11:37:37 <statusfailed> elliott: ah :)
11:37:41 <cmccann> elliott, it'd still diverge on many lists
11:37:57 <aaa`938> brandonw !
11:38:16 <roconnor> mreh: I often do things like:
11:38:24 <roconnor> Just startBlockChain = newChain 1
11:38:37 <cmccann> elliott, in fact, it would diverge on things like (repeat minBound), wouldn't it?
11:38:44 <cmccann> you'd get (minBound:_|_)
11:38:50 <prof7bit> Baughn: thsi is simple: if length does never return then you know its infinite ;-)
11:39:11 <mreh> roconnor: oh yes, i like that a lot
11:39:14 <Baughn> > length [1..]
11:39:17 <lambdabot>   mueval-core: Time limit exceeded
11:39:23 <Baughn> Ooh! It's infinite.
11:39:27 <statusfailed> can we increase the time limit?
11:39:28 <statusfailed> maybe it's not
11:39:29 <mreh> annoying you have to turn on an extension for (a,b) <- somethingTuple
11:39:39 * hackagebot arrowapply-utils 0.1 - Utilities for working with ArrowApply instances more naturally  http://hackage.haskell.org/package/arrowapply-utils-0.1 (AndrewMiller)
11:39:49 <mreh> i might be mistaken
11:39:56 <cmccann> > length [1..10^20]
11:39:58 <roconnor> mreh: I think you are mistaken
11:40:00 <lambdabot>   mueval-core: Time limit exceeded
11:40:08 <cmccann> looks like 10^20 is infinity
11:40:13 <Baughn> Yes.
11:40:32 <statusfailed> cmccann: hm, what's the smallest integer that isn't infinity, then?
11:40:51 <statusfailed> binary search time
11:41:16 <Axman6> > minBound :: Int -- *cough*
11:41:17 <lambdabot>   -9223372036854775808
11:41:25 * cmccann becomes a co-ultrafinitist--infinities exist, and include sufficiently large finite numbers
11:41:52 <statusfailed> Axman6: curse you :D
11:42:08 * shachaf becomes an ultrainfinitist -- infinities exist, as opposed to finite numbers.
11:42:39 * Baughn becomes a trans-finitist. All finite numbers are infinite.
11:44:21 * monochrom is an indefferentist
11:44:58 * elliott is an initist
11:45:55 * roconnor becomes a nilist. All numbers are 0.
11:46:10 <nand`> roconnor: that's actually quite a good stance
11:46:16 * monochrom is a consist. cons vs nil. :)
11:47:33 * wavewave is a nonexist. nothing exist!
11:48:12 <elliott> @remember cmccann <cmccann> > length [1..10^20]  <lambdabot>   mueval-core: Time limit exceeded  <cmccann> looks like 10^20 is infinity
11:48:13 <lambdabot> Done.
11:49:40 * hackagebot citeproc-hs 0.3.4 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.4 (AndreaRossato)
11:57:06 * cmccann considers that the tongue-in-cheek definition of "infinite" as "finite, but sufficiently large" does make some amount of sense in a coinductive setting
11:57:33 <cmccann> in fact, I might even say it makes an infinite amount of sense
11:58:08 <elliott> >_<
11:58:14 <Tomsik> I wonder what happened to the people that were trying to show that some superexponential functions did not halt
11:58:33 <monochrom> hahaha
11:58:34 <elliott> Some people don't believe plain exponential functions halt.
11:58:52 <elliott> IIRC the guy who had that (retracted) proof of PA inconsistency doesn't.
11:59:13 <shachaf> cmccann: There is prior art.
11:59:32 <shachaf> kmc described a train seat as having infinite legroom for instance.
11:59:47 <cmccann> my favorite, slightly less tongue in cheek definition of coinductive infinity is "at least one more than I end up needing" which sort of amounts to the same thing
11:59:51 <Tomsik> Darn, it was retracted? It would be pretty mind-blowing if it were true
11:59:56 <shachaf> s/m /m, /
12:01:59 <cmccann> really, coinductive infinity is just a formalization of the age-old practice of setting upper bounds based on "this should always be big enough"
12:02:46 <statusfailed> ^ clearly operation was not infinite enough
12:05:12 <Axman6> please choose a larger infinity
12:05:57 <absence> is there a haskell-like scripting language that can be used instead of e.g. lua for embedding in own programs?
12:06:13 <c_wraith> in practice, all operations halt when the computer running them fails.
12:06:57 <donri> absence: why not haskell
12:07:23 <cmccann> c_wraith, you can give any algorithm a halting guarantee by setting an upper bound that's decremented at each step
12:07:35 <cmccann> running a program on physical hardware is just one way of doing that
12:07:57 <elliott> donri: I wouldn't exactly call Haskell easy to embed.
12:08:15 <monochrom> well, "algorithm" receives a definition that says it both halts and gives a correct answer, not just halts
12:08:44 <donri> ey said "can", not "easy" ;)
12:08:54 <absence> donri: i assumed that full haskell has a much bigger runtime than lua, but maybe that's not the case
12:09:00 * cmccann defines "oops, ran out of time" as a correct answer
12:09:57 <monochrom> that would allow a whole new class of sorting algorithms
12:09:58 * cmccann can see value to a Haskell-ish language with a small runtime, fast compilation, and emphasis on quasi-FFI via embedding
12:10:28 <nand`> I've wanted to embed haskell before
12:10:52 <nand`> to allow the user to write haskell functions which would be used as part of a processing chain in a larger program
12:11:11 <cmccann> monochrom, oh btw, after some consideration your page about ErrorT IO vs. exceptions has thoroughly convinced me
12:11:12 <nand`> but I figured the interfaces for communicating data between the two are too clumsy or ugly
12:11:30 <monochrom> ok good. thank you for choosing monochrom!
12:11:49 <cmccann> specifically it's convinced me that pervasive use of ErrorT is just as bad, and should also be avoided
12:11:50 <elliott> monochrom's page just reaffirmed my believe that IO exceptions and ErrorT are both kinda lame
12:11:55 <elliott> *belief
12:12:06 <donri> why a haskell-*ish* language rather than going for actual haskell 98/2010? note that i'm not saying "ghc haskell" here.
12:12:12 <Ralith> the startup I'm interning for in about a week implemented a haskell-like for the express purpose of convenient embedding and extensibility in java
12:12:31 <elliott> for all the insults java's checked exceptions get they're its best feature
12:12:34 * cmccann will probably leave ErrorT out of any "core" monad transformer stacks in the future
12:12:35 <luite> monochrom: where is this page?
12:12:38 <elliott> Ralith: what, lazy?
12:13:02 <elliott> I doubt anyone constrained to the JVM would choose to make a language lazy if not actually implementing an already-lazy language
12:13:13 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
12:13:15 <absence> donri: like i said, i assumed the runtime would be too large, but it may have been a bad assumption. do you know of any haskell environments that could fit?
12:13:19 <Ralith> elliott: an actual haskell-like, not just a language having a feature which is characteristic of haskell
12:13:32 <elliott> Ralith: I was asking whether it was lazy or not
12:13:35 <Ralith> oh
12:13:36 <Ralith> yes
12:13:51 <Ralith> though they make heavy use of forced evaluation in practice, I believe
12:13:58 <Ralith> that may just be an artifact of the programmer.
12:14:15 <funktronic> Ralith: engineer you mean
12:14:26 <Ralith> no, I mean programmer.
12:15:20 <mekeor> @pl \a x->x++[a]
12:15:20 <lambdabot> flip (++) . return
12:15:27 <mekeor> @pl \x a->x++[a]
12:15:27 <lambdabot> (. return) . (++)
12:15:55 <absence> donri: for comparison, a compiled lua interpreter adds 150 kB to the executable size
12:16:35 <mm_freak> ok, assuming that the search speed is just the time t itself, i have constructed this equation:  integral(n/t, t = t0..t1) = n
12:16:42 <mm_freak> how would i go about solving this for t1?
12:16:52 <c_wraith> absence: nothing else comes close to lua for what it's designed to do.
12:17:08 <mm_freak> and does this even sound right?
12:17:48 <elliott> c_wraith: apart from the languages imitating lua :p
12:18:03 <elliott> squirrel, tinyscheme, nasal, etc.
12:18:07 <mm_freak> oh shit
12:18:08 <c_wraith> elliott: most of them aren't really that close to lua, either.
12:18:10 <mm_freak> wrong channel, sorry =)
12:19:14 <elliott> c_wraith: no, but they're designed with embedding in mind
12:22:35 <absence> c_wraith: it doesn't have to be 150 kB, so long as it's not multiple megabytes
12:22:59 <aluink> can someone explain what's going on here, http://hpaste.org/57195
12:23:32 <aluink> buildNewFile :: IO ()
12:23:34 <c_wraith> well, GHC is certainly multiple (about 20 megabytes extra to embed the compiler/interpreter in a binary, from my testing) megabytes. You'll have to look elsewhere.
12:23:40 <elliott> aluink: let me guess
12:23:45 <elliott> aluink: you're using readFile and writeFile?
12:23:51 <aluink> yep ;)
12:23:52 <ion> aluink: Windows™? It likes to lock files like that.
12:23:58 <aluink> actually, only read
12:24:01 <elliott> oh
12:24:04 <elliott> ion: in fact, haskell requires such locking
12:24:06 <elliott> unbelievably
12:24:06 <aluink> buildNewFile is using Tar.write
12:24:12 <aluink> but yeah...same idea I guess
12:24:14 <elliott> and so ghc forces it on unix users too, although only within the same process
12:24:21 <elliott> aluink: depends whether Tar.write uses lazy io
12:24:23 <ion> elliott: ಠ_ಠ
12:24:27 <elliott> or hmm, no it doesn't
12:24:31 <elliott> lkjdfkgl i'm too tired for this :)
12:24:31 <aluink> i believe it does
12:24:41 <elliott> aluink: there is no way those two implementations can differ
12:24:45 * aluink goes to check Tar.write
12:24:55 <elliott> if you think you're observing a difference between them, you're not
12:26:00 <aluink> yes, it uses BS.writeFile from Data.ByteString.Lazy
12:26:28 <aluink> well, one throws that error, while the other returns without error
12:26:50 <aluink> if that's not a difference, then what is it?
12:27:08 <elliott> well... either you're imagining it, or there's some other external factor, or it's unpredictable enough that the optimiser is changing the semantics
12:27:15 <elliott> the last one may be possible if you are using readFile.
12:32:10 * cmccann wonders if the two versions of aluink's function desugar differently
12:32:10 <aluink> http://hpaste.org/57196
12:32:39 <aluink> could it be related to that existence logic in buildNewFile?
12:33:16 <aluink> indexFile = file
12:33:35 <aluink> cause the error comes from line 10 in the recent paste
12:33:43 <elliott> never use doesFileExist, ever
12:34:01 <aluink> ok. why?
12:34:16 <statusfailed> Ok, incoming uneducated question: Arrows and Data.Enumerator sound like they would be useful together... is there an instance of Arrow for Iteratee?
12:34:19 <elliott> race condition waiting to happen
12:34:53 <aluink> ok, that makes sense.  alternate solution to wiping a file to replace it?
12:35:11 <yitz> @quote elliott race condition waiting to happen
12:35:12 <lambdabot> No quotes match. It can only be attributed to human error.
12:35:14 <cmccann> remove it, write it, handle exceptions as appropriate
12:35:28 <yitz> @remember elliott race condition waiting to happen
12:35:29 <lambdabot> I will remember.
12:35:54 <elliott> aluink: remove it and catch the exception
12:36:25 <elliott> (heh, my first SO answer was about this exact situation)
12:36:26 <aluink> hmm, that's unfortunate
12:36:43 <elliott> why?
12:37:14 <CodeWeaver> Geez, go and get some coffee, come back to a mile of scrollback.  Whelp.  *starts hiking the mile*
12:37:15 * cmccann would phrase it as "a race condiwtaiiotni ng to happen"
12:37:21 <aluink> i find what I had done already much cleaner, but I can see the real problem it creates
12:38:06 <elliott> aluink: it's simple: http://stackoverflow.com/questions/8502201/remove-file-if-it-exists-in-haskell/8502391#8502391
12:38:24 <elliott> (only first code snippet is relevant)
12:39:00 <aluink> yeah
12:39:11 <cmccann> CodeWeaver, oh, wanted to show you a possible implementation for the Pythagorean triple stuff
12:39:16 * eviltwin_b mildly amused he just answered that question (properly) in another context recently
12:39:23 <yitz> cmccann: Why did the multi-threaded chicken cross the road?
12:39:29 <CodeWeaver> Oh?  You found something intriguing?  I've got a few ideas my own self.
12:39:31 <aluink> i guess it doesn't look so bad.  I've just learned that exceptions are out of ordinary, not to be planned for
12:39:33 <cmccann> yitz, do tell
12:39:36 <yitz> side. get to the To other
12:39:43 <cmccann> :D
12:39:51 <CodeWeaver> oh my stars.  That's horrible.
12:39:57 <CodeWeaver> :D
12:40:30 * elliott tries to figure out why my line was quoted
12:40:32 <cmccann> CodeWeaver, http://hpaste.org/57197
12:40:33 <aluink> yitz: lol
12:40:34 <elliott> did I accidentally make a joke?
12:40:47 <cmccann> CodeWeaver, I think that works correctly
12:41:00 <aluink> elliott: but I agree with you.  thanks for the pointer
12:41:04 * eviltwin_b does not know either, suspects context should have been included
12:41:09 * aluink goes and writes removeIfExists
12:41:11 <CodeWeaver> cmccann, this is using the idea of a triple tree?
12:41:19 <eviltwin_b> (or, someone didn't actually realize it was a serious response)
12:41:22 <CodeWeaver> (via.. uh… I'm guessing fibonacci boxes?)
12:41:26 <cmccann> CodeWeaver, yes
12:41:31 <cmccann> hence "FBox"
12:41:39 <elliott> aluink: well, the alternative would be a status code return, since there's no way to know of the condition without actually performing the operation
12:41:43 <CodeWeaver> But what guarantee do you have that they come out in the required order?
12:41:48 <elliott> I think there's a good argument to be made that removeFile should succeed if the file doesn't exist.
12:42:01 * aluink prepares a System.Directory patch to include removeIfExists ;)
12:42:14 <CodeWeaver> Granted, linear time production of all triples is kinda cool.
12:42:18 <CodeWeaver> all primitives no less.
12:42:40 <CodeWeaver> No make that epic cool.
12:42:43 <aluink> elliott: yeah, the solution you shared is simple enough.  thanks again!
12:42:57 <cmccann> CodeWeaver,  some quick and dirty calculations plus quick and dirty empirical testing
12:43:21 <cmccann> but I'm not 100% certain
12:43:27 <CodeWeaver> Oh?  Okay, well, then we should be able to compare a short list manually… I'll test a longer list automatically in a bit… my starting list for 20 elements is:
12:43:37 <CodeWeaver> [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(20,21,29),(7,24,25),(10,24,26),(18,24,30),(21,28,35),(16,30,34),(24,32,40),(12,35,37),(15,36,39),(27,36,45),(9,40,41),(30,40,50),(40,42,58)]
12:43:38 <yitz> elliott: i just thought "waiting to happen" is an ironic thing to say about a race condition, which is inherently about timing
12:44:25 <dylukes> FBoxes?
12:44:34 <CodeWeaver> WHoops, that's with the non-primitives still in there.
12:44:38 <CodeWeaver> Haven't gotten rid of those yet.
12:45:05 <tromp_> don't you want them sorted by c?
12:45:13 <CodeWeaver> by b in this case.
12:45:24 <CodeWeaver> and then by a wherein the b's are equal.
12:46:58 <cmccann> CodeWeaver, basically the idea is that given a box B, the three boxes generated from it will correspond to triples that come after the triple associated with B
12:48:14 <cmccann> so it keeps a list of boxes sorted by triple, takes the first element, produces the triple, generates new boxes from it, then inserts those into the sorted list
12:48:19 <CodeWeaver> I understand it generates child triples, but that doesn't guarantee any particular order that they come out.
12:48:47 <CodeWeaver> You can do a breadth-first traversal of the tree, but that doesn't guarantee the ordering of all triples by b.
12:49:08 <CodeWeaver> Or by c or by a for that matter.
12:49:10 <cmccann> CodeWeaver, right, hence the insertion
12:50:20 <cmccann> but since any box will produce triples that come later, if you sort the "pending" boxes by triple, nothing in remaining tree can ever be less than that triple
12:50:31 <cmccann> (of the minimal element in the list, that is)
12:50:31 <CodeWeaver> How do you know that a later box  won't produce a triple that should have come before ones already processed?
12:51:25 <cmccann> CodeWeaver, well, that's the part that I'm not 100% confident about, of course
12:51:43 <CodeWeaver> Okay, so that's the sticky point.  Other than that, though, I do like it.
12:52:04 <CodeWeaver> I would have never thought of it, never having seen the tree before today.
12:52:06 <roconnor> is there a quick way to test if an integer is a square?
12:52:36 <CodeWeaver> ish…. take its square root as a double, round it to an int, and resquare it.
12:52:43 <CodeWeaver> Constant time, if slightly gross.
12:52:48 <roconnor> too gross
12:53:27 <CodeWeaver> Short of having a high performance sqrt :: Int -> Int function, I'm not sure what else.
12:53:50 <CodeWeaver> Maybe a giant lookup table. :P
12:53:59 <elliott> roconnor: http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer ?
12:54:06 <elliott> seems mostly focused on low-level trickery
12:54:19 <CodeWeaver> Whoa.
12:54:29 <cmccann> CodeWeaver, I'm pretty sure it works, both because I think the reasoning is sound and because generating several thousand triples produces a list in sorted order
12:54:41 <aluink> elliott: well, that was a nice learning experience for me.  however, my original problem persists :(
12:54:45 <elliott> "Notes: I'm using this function in many Project Euler problems. So no one else will ever have to maintain this code. And this kind of micro-optimization could actually make a difference, since part of the challenge is to do every algorithm in less than a minute, and this function will need to be called millions of times in some problems."
12:54:51 <elliott> methinks this person has missed the point of project euler quite massively ;/
12:54:58 <elliott> *:/
12:55:00 <CodeWeaver> cmccann, okay, I'll have to ponder it…
12:55:53 <elliott> aluink: i suggest just getting rid of the lazy io.
12:55:55 <elliott> i.e. readFile
12:56:14 <elliott> roconnor: it seems like the loop at the end is what you'd want to copy
12:56:22 <elliott> and the rest are just special-case tricks
12:56:46 <cmccann> CodeWeaver, oh and (5535,612712,612737) is the ten thousandth triple generated, I think that's what you asked for originally?
12:57:10 <cmccann> takes about 15s to find that on my machine, fwiw
12:57:16 <CodeWeaver> cmccann yes.
12:57:26 <CodeWeaver> I'll do what I can to verify via an alternate method. :)
13:00:02 <aluink> elliott: GZip.(de)compress works with Lazy
13:00:15 <yitz> > [(a',b',c)|v<-[3,5..],u<-[1,3..v-2],let a=u*v; b=(v*v-u*u)`div`2; c=(v*v+u*u)`div`2; (a',b')=if a<b then (a,b) else (b,a)]
13:00:16 <lambdabot>   [(3,4,5),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(12,35,37),(9,40,41),(27,...
13:00:26 <elliott> aluink: not relevant
13:00:32 <elliott> that's lazy bytestring, not the same thing as lazy io
13:00:37 <elliott> the only thing you need to eliminate is readFile
13:00:55 <elliott> > [(a',b',c)|v<-[3,5..],u<-[1,3..v-2],let a=u*v; b=(v*v-u*u)`div`2; c=(v*v+u*u)`div`2; (a',b') | a <- b = (a,b) | otherwise = (b,a)]
13:00:56 <lambdabot>   [(4,4,5),(12,12,13),(8,8,17),(24,24,25),(20,20,29),(12,12,37),(40,40,41),(3...
13:00:57 <elliott> cool, that works!
13:01:00 * aluink is pretty new to Haskell
13:01:32 <aluink> if I change the readFile to regular Data.ByteString.Char8 it complains that it's not Lazy because of the GZip it's reading from
13:01:42 <elliott> oh hmm, wait
13:02:07 <elliott> right... LBS.readFile is lazy
13:02:15 <elliott> well
13:02:20 <elliott> aluink: there's the easy and gross fix
13:02:28 <aluink> oooh! sounds fun!
13:02:33 <elliott> put evaluate (LBS.length bs) below the readFIle line
13:02:38 <elliott> (you may need to import Control.Exception (evaluate))
13:02:51 <elliott> (or if you don't list evaluate explicitly you'll also need to import Prelude hiding (catch))
13:04:01 <aluink> elliott: and why only the readFile and not the writeFile?
13:04:57 <elliott> aluink: because readFile does lazy input
13:05:05 <elliott> writeFile is just, uh, "lazy output", which is just... output
13:05:15 <elliott> aluink: basically: what you get from readFile is not the file's contents
13:05:23 <elliott> as you force the string, it reads more and more from the file
13:05:28 <elliott> and _only when you reach the end_ does it close the file handle
13:05:42 <elliott> so if you try and open the same file before fully forcing it? it doesn't work because you already have it open
13:05:46 <cmccann> lazy output should wait to produce anything until some other process tries to read the file
13:06:26 <aluink> cmccann: is that a joke?
13:06:40 <Clint> what does '' mean in TH?
13:06:48 <cmccann> aluink, yes
13:06:53 <aluink> ok
13:06:54 <cmccann> CodeWeaver, http://www.math.rutgers.edu/~erowland/tripleslist-long.html
13:07:05 <elliott> http://hpaste.org/57199 who is responsible for this
13:07:11 <elliott> mroman: you! explain yourself
13:08:40 <CodeWeaver> Nice find, cmccann!
13:08:58 <CodeWeaver> Ordered by z I see.  Hm.
13:09:47 <cmccann> CodeWeaver, interestingly changing the sort order in my code seems to also work
13:09:50 <Veinor> elliott: the parens there aren't balanced
13:10:16 <aluink> elliott: ok, that works
13:10:23 <aluink> thanks again!!
13:10:59 <CodeWeaver> Provided you're not missing any because of the caveat…. then it is clearly going to be the winner.  You'd just have to keep that container sorted.  You could even use a faster container.
13:11:06 <CodeWeaver> That's where the bottleneck will be.
13:11:17 <CodeWeaver> That being said, the caveat still bugs me.
13:11:22 <cmccann> CodeWeaver, yeah
13:11:44 <cmccann> CodeWeaver, though my program agrees with that list (the first 1000-ish)
13:12:08 <cmccann> which means that if it's wrong, it's probably wrong in an interesting way
13:13:22 <cmccann> but yeah, using a list as a priority queue is not really ideal :P
13:13:23 <CodeWeaver> Well, I love to find out when things get wrong in an interesting way. :D
13:14:19 <cmccann> CodeWeaver, I'm probably done with it but feel free to make it faster and/or convince yourself that it's correct :P
13:14:52 <seeg> hello
13:16:05 <seeg> i'm trying to compare two lists and get only the elements that they have in common and in different order
13:16:59 <seeg> so my code looks like this
13:16:59 <seeg> http://hpaste.org/57200
13:17:45 <seeg> it works, but only if arguments to these functions are lists of integers
13:18:08 <seeg> for more abstract type (like a line consiting of two points) I get
13:18:23 <CodeWeaver> cmccann:  No worries! Thanks for enlightening me!  I'll report back what I find!
13:18:24 <seeg>    Couldn't match expected type `Line' with actual type `[a0]'
13:30:48 <etpace> @hoogle (a -> a -> m b) -> m a -> m a -> m b
13:30:49 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
13:30:49 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
13:30:49 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:33:07 <jameysharp> I'm supposed to be able to compile using -with-rtsopts even if -rtsopts is set to some or none, right? I'm getting "Most RTS options are disabled. Link with -rtsopts to enable them."
13:33:24 <jameysharp> (Using GHC 7.0.4.)
13:34:13 <c_wraith> jameysharp: You get that error message when running the compiled program with no RTS args?
13:34:29 <lpsmith> dcoutts_, zlib doesn't compile with ghc-7.4.1-rc2,  gcc seems to choke on "#if MIN_VERSION_base(4,4,0)" from Stream.hsc for some reason
13:34:31 <Cale> jameysharp: I'm not sure that you are allowed to
13:34:41 <jameysharp> Yeah, as far as I can tell I'm not passing any flags on the command line or in the environment.
13:35:07 <Cale> jameysharp: why not just enable rtsopts when compiling? It's really derpy that they're disabled by default anyway.
13:35:12 <c_wraith> huh.  That seems likely something you should be allowed to do.
13:35:21 <etpace> Is there an idiomatic version of: \f x y -> x >>= \x' -> y >>= \y' -> f x' y'
13:35:34 <Cale> etpace: that's liftM2
13:35:44 <cmccann> not quite
13:35:46 <jameysharp> Cale: This is a fastcgi script, which I gathered was the big motivation for turning off RTS by default, so I thought I'd try to be good.
13:35:47 <Cale> @pl \f x y -> x >>= \x' -> y >>= \y' -> f x' y'
13:35:47 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
13:35:49 <Cale> errr
13:35:54 <etpace> liftM2 has f resultas unlifted
13:35:57 <cmccann> liftM2 followed by a join
13:36:03 <Cale> ah, yeah
13:36:16 <etpace> yeah, Im using applicative style and having a prefix join $ is a bit ugly
13:36:19 <etpace> was wondering if there is something nicer
13:36:21 <Cale> it'd need to be return (f x' y') for that
13:36:50 * cmccann uses a (=<*) combinator to write things like "f <$> x <*> y =<* z"
13:37:41 <elliott> jameysharp: isn't it cgi, not fastcgi, that's the problem?
13:38:19 <jameysharp> elliott: A fine question. I didn't really understand the argument for the change in behavior to begin with.
13:38:53 <cmccann> etpace, anyway your best options are 1) a do block 2) the "join $" approach 3) a combinator like my (=<*)
13:39:03 <Cale> The argument is that herp derp someone might setuid a Haskell program to root and then people could use RTS options to obliterate files!!!11one
13:39:03 <lpsmith> dcoutts_, ahh it appears that people know about this.  Though, I would like to see the design for the incremental cabal update =)
13:39:30 <jameysharp> Though, on the principle of least privilege, I was happy to prevent my fastcgi from doing things I wasn't planning to ask it to do anyway; but I really want to set the maximum heap size.
13:39:42 * hackagebot probability 0.2.3 - Probabilistic Functional Programming  http://hackage.haskell.org/package/probability-0.2.3 (HenningThielemann)
13:40:30 <jameysharp> Cale, can you explain how people got from there to "CGI is vulnerable"?
13:41:39 <Cale> No idea
13:42:14 <glguy> The cgi executable didn't have to be root to do something that would violate a security expectation
13:43:07 <jameysharp> glguy: That's fair, but an HTTP client can't set an environment variable named GHCRTS for a CGI, nor pass command-line arguments, can it?
13:43:20 <elliott> Cale: it was because you could do /foo?+RTS+log+to+important+file, I think.
13:43:23 <elliott> or something
13:44:16 <jameysharp> elliott: Oh, if query parameters are passed to CGIs as arguments, then that makes sense.
13:44:26 <cmccann> I think there being some way to get command line arguments to a CGI script was the crux of the issue, yes
13:44:38 <cmccann> and the result was a legitimate security problem
13:44:46 <Cale> Of course, if the user that the CGI program is running as has no rights to write to things, then that'll fail.
13:45:25 <jameysharp> OK. And if that's the concern, then it clearly doesn't affect FastCGI, because a FastCGI is started without any visitor-controlled environment.
13:49:16 <jameysharp> I still think it's a bug that compiling with -with-rtsopts doesn't work without also specifying -rtsopts=all, since the user's manual seems to say otherwise, but I no longer care enough. :-) Thanks!
13:50:52 <Cale> jameysharp: I agree that it ought to work, even if it doesn't.
13:50:58 <cmccann> yes, that sounds like a bug
13:51:09 <cmccann> or at least a misfeature
13:51:12 <Cale> Or a missing feature
13:51:12 <Cale> yeah
13:52:39 <lpsmith> Ok, this is obnoxious:   I can't import both Foreign and Foreign.ForeignPtr.Unsafe and use unsafeForeignPtrToPtr,  because they aren't the exact same definition
13:53:08 <lpsmith> and I can't hide the definition from Foreign without breaking my library at some unspecified point in the future
13:53:18 <lpsmith> (GHC 7.6 I would assume)
13:53:34 <lpsmith> my only choice is to import qualified
13:54:58 <rwbarton> or explicitly list your imports from Foreign
13:55:11 <lpsmith> rwbarton, true :)
13:55:21 <lpsmith> But also tedious for what I'm doing
13:57:14 <lpsmith> I suppose I could --ddump-minimal-imports,  though that gets to be a bit of a pain to maintain.
14:09:05 <tgeeky> breaking libraries at unspecified points in the future is the way to go
14:13:50 <JoeyA> > where is lambdabot?
14:13:51 <lambdabot>   <no location info>: parse error on input `where'
14:14:04 <cmccann> @where lambdabot
14:14:04 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
14:14:20 <tgeeky> JoeyA: he's right there ^^
14:14:27 <tgeeky> s/he/she/
14:15:22 <JoeyA> @pl \x -> a x && b x
14:15:22 <lambdabot> liftM2 (&&) a b
14:18:19 <eyebloom> Is the GHC typechecker available as a library?
14:18:28 <cmccann> as much as GHC is
14:19:06 <c_wraith> meaning: yes, kind of, but it's really awkward to use
14:19:40 <cmccann> also meaning: yes, and GHC is that library, good luck
14:20:05 <c_wraith> actually, hint *may* do what you want
14:20:16 <c_wraith> It has things that return string descriptions of types
14:20:31 <c_wraith> or a Bool if something typechecks
14:20:49 <eyebloom> Basically I'm looking to typecheck arbitrary higher order syntax expressions. i.e. expressions that aren't created before compile time.
14:21:07 <c_wraith> eyebloom: only to see if they are well-typed?
14:21:17 <c_wraith> or do you want some sort of run-time representation of their type?
14:21:28 <eyebloom> The second one.
14:21:40 <c_wraith> that's really tough then
14:21:53 <monochrom> what will you use this for?
14:22:22 <monochrom> it seems to be very strange that people are so bent on reflection
14:22:39 <eyebloom> I'm not really bent on reflection.
14:22:56 * mjrosenb is not horribly sure what reflegtion is
14:23:16 <eyebloom> But if I'm trying to help the user construct valid terms, I need some information about the types of those terms.
14:23:33 <monochrom> reflection means writing a program in language L that performs everything that an L interpreter/compiler does
14:24:06 <c_wraith> hint can help you if a string is a sufficient representation of the type
14:24:20 <c_wraith> beyond that...  You're actually in a world of pain, in GHC-land.
14:24:32 <eyebloom> I can imagine.
14:24:37 <mjga> mjrosenb: reflection means that you may take a code fragment, and change it as a value, and then lift it back to computation land
14:24:48 <c_wraith> dynamic loading and Typeable have bizarre interactions
14:25:07 <c_wraith> mostly because Typeable is actually an unsafe interface
14:25:13 <mjga> it is easy to generalize certain thinks by imagining how they would be translated to simpler programs.
14:26:20 <mjga> that is what compiler front-end like GHC does: parses a convenient syntax (Haskell is claimed to have one of the best beside Python), and generates code in system FC alias GHC core language
14:26:38 <mjrosenb> mjga: gotcha.
14:26:43 <mjga> the point of template haskell is to allow any user to add more sugar
14:27:19 <c_wraith> honestly, I feel like haskell's syntax is actually more regular than python's
14:27:36 <c_wraith> but both have a lot of special cases, when you think about them
14:28:03 <cmccann> haskell's syntax may allow uglier code, by virtue of flexibility if nothing else
14:28:13 <eyebloom> It's not super difficult to implement a simple type checker, if your type system only includes variables, arrows and basic types. There are only a few rules that need to be applied to a "parrallel" type system, but I'm just curious what is available.
14:28:28 <mjga> c_wraith: depends what you do, I would say that even more user input, and testing would certainly help. otherwise people would not like to "simplify" Haskell from time to time just for the students
14:29:08 <c_wraith> mjga: most of the "simplified" haskells have to do with type classes and error reporting. one of those has minimal language syntax, and the other has none
14:29:49 <acowley> Someone had a good zinger about Haskell syntax at OBT after POPL this weekend
14:29:58 <mjga> c_wraith: Python started as a language to teach students, and for imperative/object-oriented programming it seems to succeed very well. Many people use it not for ease of use, but because they want to make sure that everybody understands their code.
14:30:21 <acowley> Paraphrasing: Haskell's syntax is too beautiful for the numerical simulation community.
14:30:50 <c_wraith> mjga: ah. I didn't say haskell's syntax is better for beginners, either.  I said it's more regular - that is, fewer special cases.
14:30:57 <mjga> c_wraith: I disagree. for example GHC records for a long time were just simplified compared to TREX and other extensible record proposals.
14:31:18 <c_wraith> mjga: more special cases can often make things easier for beginners.
14:31:35 <monochrom> haskell is probably also too non-strict for numerical simulation
14:32:19 <acowley> Haskell is (almost) as strict as you want it to be
14:32:22 <mjga> acowley: I do numerical sim, and I believe it is just impractical for defining a lot of numerical array ops. of course having thousands of different array mechanisms with different syntaxes doesn't help
14:32:34 <erus`> :t fmap
14:32:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:32:42 <mjga> monochrom: {-# LANGUAGE BangPatterns #-}
14:33:46 <mjga> two phrases: 1. hmatrix is GPL, not a BSD base library. 2. Array syntax in haskell is a pain
14:33:58 <kallisti_> So I'm compiling with: ghc --make -shared -fPIC -dynamic -I.. Bayes.hs bayes.c -o bayes.so
14:35:19 <Axman6> .c?
14:35:43 <kallisti_> which is successful, but then when I try to use dlfcn.h to load the shared library I get the following error:
14:35:52 <monochrom> yes you can give bayes.c to ghc. ghc will call gcc for you. with useful options, too
14:36:08 <Axman6> handeh
14:36:15 <kallisti_> "/usr/local/lib/ghc-7.2.2/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.2.2.so:  undefined symbol: stg_newByteArrayzh".
14:38:03 <Enigmagic> kallisti_: could try linking directly with libHSrts*.so
14:39:43 * hackagebot csv-enumerator 0.10.1.1 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.10.1.1 (OzgunAtaman)
14:40:30 <kallisti_> Enigmagic: the error is originating from that .so, so that would hardly do anything.
14:41:25 <Enigmagic> kallisti_: looked like libHSghc-prim not the rts? or did i read that wrong
14:45:02 <mjga> btw: anybody would see a chance to see blas/lapack in base library, if the library was BSD?
14:45:53 <mjga> or in haskell platform
14:46:13 <c_wraith> doubtful
14:46:19 <c_wraith> it's just not of wide use
14:47:08 <mjga> come on - we have OpenGL in platform, and probably would like to have some cross-platform windowing lib, if such was BSD
14:47:16 <kallisti_> Enigmagic: oh no. I misread.
14:47:30 <kallisti_> I would think that GHC links the RTS.....
14:47:39 <Axman6> mjga: base /= platform
14:47:47 <mjga> probably some people would would like to have sqlite in platform too
14:48:02 <mjga> axman6: sorry, I correct myself. I mean Haskell Platform, not base
14:48:24 <mike-burns> I would have no use for either.
14:48:26 <c_wraith> why would a windowing toolkit be of the same common appeal as a matrix lib?
14:48:46 <mjga> for some people...
14:48:56 <kallisti_> Enigmagic: oh, hmmm... apparently manually linking the RTS did it.
14:49:02 <kallisti_> weird. seems like something --make would handle
14:49:15 <Axman6> mjga: to get into the platform, it owuld have to be mature and widely used and needed
14:49:28 <kallisti_> maybe it's different for shared libraries? all of the FFI examples never explicitly link the RTS
14:49:57 <mjga> there are at least four widely used programming languages that are used solely because of great math support, mainly linear algebra: matlab, mathematica, octave, r or s
14:50:11 <mike-burns> OK.
14:51:35 <kallisti_> Enigmagic: good. now it's just segfaults instead of linking errors. much better.
14:51:36 <Enigmagic> kallisti_: i think there is a bug somewhere, at least on my box (pre-7.4) the ghc-prim dylib references the rts
14:51:38 <mjga> for linear algebra lapack would cover most needs, not sure if there is a similar quality (and license) statistical library, but financial haskellers would certainly be happy (there are at least three different implementations of erf on hackage AFAIR)
14:52:12 <Enigmagic> kallisti_: excellent :P
14:52:41 <rwbarton> did you initialize the ghc RTS before calling your haskell function?
14:53:02 <mike-burns> mjga: Is that the only library they would need? If not, perhaps a better effort would be a Financial Haskell distribution, with HP + needed libs.
14:53:02 <kallisti_> yes
14:54:43 <mjga> mike-burns: I am not financial, but yes lapack+basic probability functions like erf cover 99% of what I do not write by myself. the other things may be implemented using lapack and basic statistical functions anyway
15:13:01 <erus`> @src Monad
15:13:01 <lambdabot> class  Monad m  where
15:13:01 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:13:01 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:13:01 <lambdabot>     return      :: a -> m a
15:13:01 <lambdabot>     fail        :: String -> m a
15:41:51 <Zamarok> @src do
15:41:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:42:27 <nyingen> @quote
15:42:27 <lambdabot> c2.com says: If you can program anything in HappS you actually already learned Haskell
15:44:30 <Sgeo> Hey, return and fail in the Monad definition listed don't bother with the forall
15:45:53 <eviltwin_b> doesn't @src show what the report says (and specifically the h98 report)?  h98 didn't have forall
15:52:14 <byorgey> eviltwin_b: apparently, it doesn't.
16:19:46 <kallisti_> if I wanted to make a call to a vararg function in C, while basically ignoring the fact that it's variadic, how would I do that.
16:20:14 <shapr> Hail Eris.
16:20:17 <kallisti_> as an easy example: I want to define the type for printf, where I'm only interested in specifying the format.
16:25:29 <mauke> kallisti_: impossible
16:25:46 <mauke> vararg functions have a different calling convention
16:28:46 <mjrosenb> mauke: that is only on amd64; on x86 they follow the same convention
16:29:21 <mauke> I mean in standard C
16:30:03 <mauke> the C standard says that you can't call a vararg function unless there's a declaration in scope
16:30:30 <mauke> meaning C compilers are free to do whatever they want with vararg functions
16:37:54 <joshft91> Hey guys - quick question.  I have two little functions...one that returns the max of a list and one that returns the minimum (we're supposed to write this without using min and max)
16:38:10 <joshft91> now I'm trying to make it so that when I call maxandmin of a list it'll return both
16:38:19 <joshft91> listMaxandMin' [] = (minimumList, maximumList)
16:38:37 <joshft91> minimumList and maximumList both take lists and return their respective value
16:39:32 <CodeWeaver> Sure...
16:40:03 <joshft91> CodeWeaver: ?  I'm jsut not sure how you make it into one function call
16:40:05 <nyingen> I don't understand the question
16:40:25 <nyingen> maxAndMin l = (max l, min l) ?
16:40:27 <joshft91> one sec
16:40:48 <nyingen> using your custom functions instead of max and min, I mean
16:40:48 <joshft91> http://pastebin.com/RXz44h4w
16:40:51 <mauke> The paste RXz44h4w has been copied to http://hpaste.org/57204
16:41:10 <CodeWeaver> If you want to do it 'as you go' rather than calling two seperate hand-written min/max functions, that's doable too.
16:41:46 <joshft91> CodeWeaver: as you can see, I have 2 function to handle max and min..but I want to call them both on a list I input and have them output the min and max
16:42:13 <CodeWeaver> Well, you could hand-write min and max and then just call them as nyingen suggests.
16:42:28 <CodeWeaver> Do you want to basically do it in one-pass of the list, or are two passes allowed?
16:42:52 <Eduard_Munteanu> joshft91: but there you're not, you're returning something of type ([a] -> a, [a] -> a)   (well, forgetting about Ord for a sec)
16:42:53 <joshft91> Ideally I'd like it to be an input like "listMaxandMin' [1,2,3,4,5]"
16:42:58 <mjrosenb> joshft91: just fyi, you probably shouldn't be using minimum in you definition.
16:42:59 <joshft91> then it'd return a 1 and 5
16:43:20 <CodeWeaver> Well, yes, josh, but if you already ahve min and max of your own, then just returning (mymin list, mymax list) would work.
16:43:33 <CodeWeaver> It would just do each as a separate pass.
16:43:53 <mjrosenb> > let mandm l = (minimum l, maximum l) in mandm [1,2,3,4,5]
16:43:54 <lambdabot>   (1,5)
16:44:07 <CodeWeaver> If you want to do it in one pass, you can do that, but you'd have to write a recursive function of your own.
16:44:08 <Eduard_Munteanu> @pl \xs -> (f xs, g xs)
16:44:08 <lambdabot> liftM2 (,) f g
16:44:19 <nyingen> heh
16:44:27 <CodeWeaver> In the basic sense, a list processing function is recursive.  So, if the list has one element (presumably your base case), you have your answer for both.  If your list has a head and a tail, then you have to relate the value at the head to the min and max you get back from the tail.  So it's basically two cases for one function.
16:44:43 <ion> Use the (Min a, Max a) monoid.
16:44:57 <Eduard_Munteanu> (But that would be wrong too unless you omit the argument in the left hand side)
16:45:00 <ion> and mconcat
16:45:10 <joshft91> hm... guess I'm kind of confused then =/
16:45:18 <joshft91> are you saying I only need one of those instead of 2?
16:45:39 <CodeWeaver> The simplest way, josh, is something like:
16:45:39 <CodeWeaver> minmax xs = (min xs, max xs)
16:45:47 <CodeWeaver> And yer done.
16:45:54 <CodeWeaver> You just have to write min and max yourself.
16:46:09 <joshft91> hm, right...which I already did right?
16:46:15 <nyingen> looks that way
16:46:16 <CodeWeaver> If you say you have, then you have.
16:46:21 <Eduard_Munteanu> :t min
16:46:22 <lambdabot> forall a. (Ord a) => a -> a -> a
16:46:27 <joshft91> I'll give this a shot and see what happens
16:46:35 <CodeWeaver> But minmax written that way processes the input list twice, completely.
16:46:45 <CodeWeaver> So you have to be aware of that.  There's a way to write it so it only processes the list once.
16:46:56 <CodeWeaver> I'll be back after I get foodz.
16:47:02 <Eduard_Munteanu> @type minimum
16:47:03 <lambdabot> forall a. (Ord a) => [a] -> a
16:48:02 <bgamari> How does one approach a leak of std_sel_upd and stg_ap_2_upd_info thunks?
16:48:10 <bgamari> Google appears to be useless here
16:48:14 <nyingen> @src minimum
16:48:14 <lambdabot> minimum [] = undefined
16:48:15 <lambdabot> minimum xs = foldl1 min xs
16:48:25 <bgamari> Unfortunately even the ghc source has very little explanation of why these objects are produced
16:49:47 * hackagebot swish 0.6.4.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.4.0 (DouglasBurke)
16:52:12 <ion> λ> let minMax (Just -> a) = (MinPriority a, MaxPriority a); getMinMax (MinPriority a, MaxPriority b) = liftA2 (,) a b in getMinMax (foldMap minMax [5..42])
16:52:15 <ion> Just (5,42)
16:53:16 <ion> getMinMax (foldMap minMax [0,20] `mappend` foldMap minMax [-10,10])
16:53:17 <ion> Just (-10,20)
16:54:49 * hackagebot text-register-machine 0.1.0 - A Haskell implementation of the 1# Text Register Machine  http://hackage.haskell.org/package/text-register-machine-0.1.0 (AdamFoltzer)
16:55:00 <Jafet> ion: golfclap
16:57:41 <joshft91> well...still confused
16:57:44 <joshft91> This runs =/
16:57:44 <joshft91> http://hpaste.org/57205
16:57:51 <joshft91> however, it doesn't return the min and the max...
16:58:21 <mjrosenb> joshft91: you don't want to remove the first element of the list
16:58:31 <joshft91> right, that's what I thought
16:58:40 <joshft91> but I'm not sure how you do it without that format
16:58:44 <mjrosenb> joshft91: you are matching x:xs in your definition of minmax, then ignoring x(the first element)
16:58:51 <mjrosenb> just minmax xs = ...
16:59:01 <joshft91> hm, thought I tried that and it didn't work :S
16:59:04 <joshft91> give it a shot again.
16:59:33 <CodeWeaver> Once you get that working, try to do it in one pass. :D
16:59:48 <joshft91> Hmm...
17:00:02 <joshft91> I don't know if I wanna think anymore.  My brain might explode
17:00:08 <CodeWeaver> hahahaah
17:00:08 <joshft91> you mean one pass through the recursion?
17:00:10 <CodeWeaver> haskell will do that.
17:00:11 <CodeWeaver> Yes.
17:00:21 <CodeWeaver> Well, basically you have to go all the way down the original list twice.
17:00:40 <CodeWeaver> Which means you have to hold on to the entire list between the two.
17:00:56 <CodeWeaver> Sometimes its nice just to process a list once, and throw away the 'beginning' from your calculations in case nobody wants it.
17:01:03 <Jafet> There is never an obligation to think.
17:01:05 <joshft91> hmm
17:01:14 <CodeWeaver> So its worth knowing how to do that, at least.
17:01:29 <joshft91> I really have no idea where to start...would it be adding more 'guards' or whatever?
17:01:32 <joshft91> "tubes"
17:01:49 <CodeWeaver> Nope, just a single function that looks very similar to, say, your minimum function.
17:02:07 <CodeWeaver> Except you're returning a tuple back up the chain instead of a single value.
17:02:08 <joshft91> hmm
17:02:35 <joshft91> thinkin' here
17:02:45 <joshft91> I'm like 3 days into haskell :S
17:02:54 <CodeWeaver> :D
17:03:01 <CodeWeaver> EMBRACE THE MADNESS… errr, sorry, have a cookie.
17:03:34 <Jafet> You seem to be the only mad one
17:03:57 <joshft91> Yeah, pretty sure I'm lost
17:03:59 <joshft91> =/
17:04:09 <tikhonjelvis> No, almost everybody around here is at least a little mad :)
17:04:10 <CodeWeaver> josh, it may help if you have a helper function called min, which takes two values and returns the minimum.  Same for max.  A two valued version.
17:04:13 <joshft91> been a long day...and I still ahve tons of reading to do
17:04:18 <CodeWeaver> No worries.
17:04:22 <joshft91> hm
17:04:25 <joshft91> well I can do those easy
17:04:29 <joshft91> sec
17:05:01 <CodeWeaver> That will simplify your existing recursions… and then having done that it may be more obvious.
17:05:38 <joshft91> soemthing like this?
17:05:38 <CodeWeaver> Remember, where you're getting the minimum of the tail with:
17:05:38 <joshft91> max' a b = if a > b then a else b
17:05:38 <CodeWeaver> minTail = minimumOfList xs
17:05:38 <CodeWeaver> with a combined version, it'd be something like
17:05:39 <CodeWeaver> tuple = minmax xs
17:05:40 <CodeWeaver> in the where clause.
17:05:44 <CodeWeaver> Genius.
17:05:52 <joshft91> one for max and one for min I take it
17:06:07 <CodeWeaver> Yes.  useful utility functions.
17:06:17 <joshft91> mk, got those in...
17:06:19 <joshft91> now what to do with that
17:06:21 <joshft91> *them
17:06:40 <CodeWeaver> Well, consider how you could use those instead of guards to clean up minimumOfList and maximumOfList, to start with.
17:07:00 <CodeWeaver> (ie you could get rid of your guards)
17:07:05 <joshft91> right.
17:07:09 <joshft91> mk...
17:07:13 <joshft91> let's see ehre.
17:07:14 <joshft91> gahhhh
17:08:01 <Jafet> I suggest considering how to view minimumOfList as a fold.
17:08:15 <James> hi
17:08:20 <James> hi
17:08:30 <joshft91> yea, I'm not sure how I'd get rid of the guards with the function I just made =/
17:08:31 <CodeWeaver> Jafet:  Quite easy, but don't hurt josh's brain too much :D
17:08:50 <joshft91> if I can get it working in one pass, Ithat'd be awesome
17:08:50 <CodeWeaver> Consider, josh:  The test you're doing in the guards is now part of your new functions.
17:09:00 <joshft91> but I don't have a lot of time unfortunately
17:09:07 <joshft91> right...
17:09:10 <CodeWeaver> We're not at the one-pass stage yet, but you could simplify each of the two functions you have.
17:09:12 <joshft91> I'm just not sure how to put it in there
17:09:13 <Jafet> Muscles hurt when you exercise them.
17:09:20 <CodeWeaver> Okay, well, you already have minTail
17:09:28 <CodeWeaver> And the new value that is a candidate is x
17:09:38 <CodeWeaver> The result you want to return is…. the minimum of those two.
17:09:41 <CodeWeaver> That's what your'e doing in yoru guards.
17:09:57 <CodeWeaver> But there's a simler way to say 'return the minimum of x and mintail' now.
17:10:06 <Guest65482> can osmone explain to me why perm xs = [x:ps |x<-xs, ps <- perms (perm (delete x xs)] does not work?
17:10:31 <Guest65482> it returns an empty list all the time
17:10:35 <Guest65482> -_-
17:10:57 <Twey> Guest65482: It returns a syntax error, actually
17:11:06 <joshft91> so I'd call it like
17:11:10 <joshft91> min' x maxTail
17:11:13 <Jafet> What is perm []?
17:11:15 <Jafet> (What are the permutations of []?)
17:11:27 <Guest65482> a list
17:11:40 <Guest65482> of characters
17:11:47 <CodeWeaver> Well, basically, josh, though presumably you meant min' x minTail in the minimumOfList function
17:11:53 <Twey> Using ‘forall’ for existential types always confuses me
17:12:00 <joshft91> oh whooops
17:12:01 <joshft91> yes...
17:12:32 <Jafet> guest: what are the permutations of an empty sequence?
17:12:56 <CodeWeaver> If you did it right, josh, you shouldn't need guards in those lists anymore.
17:13:04 <CodeWeaver> In those individual functions I mean.
17:13:15 <joshft91> CodeWeaver: would I define mintail like this?
17:13:15 <joshft91> let minTail = minimumOfList xs
17:13:19 <andromedab> possibleValues xs = [ x:ps | x <- xs , ps <- possibleValues ( delete x xs ) ]
17:13:19 <andromedab> delete x xs = [ x | x <- xs, x /= x ]
17:13:19 <andromedab> main = print $ delete 1 [1,2,3,4]
17:13:22 <andromedab> that's the code i have
17:13:28 <CodeWeaver> That's reasonable for minTail josh
17:13:36 <andromedab> what's wrong @_@
17:13:38 <CodeWeaver> It's the minimum of 'everything else but the head'
17:13:52 <joshft91> right... for some reason, getting a parse error on this line "max' a b = if a > b then a else b"
17:14:09 <CodeWeaver> does b have an extra quote after it?
17:14:19 <andromedab> im trying to find permetations
17:14:21 <andromedab> of a string
17:14:21 <CodeWeaver> No, probably not
17:14:25 <Jafet> My homework smell is tingling
17:14:32 <kallisti_> > permutations "hello"
17:14:33 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
17:14:33 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
17:14:47 <Jafet> andromedab: what are the permutations of an empty sequence?
17:14:56 <joshft91> http://hpaste.org/57207
17:14:58 <andromedab> empty ?
17:15:18 <CodeWeaver> minimumOfList (x:xs)
17:15:18 <CodeWeaver>     min' x minTail
17:15:23 <andromedab> right?
17:15:26 <Jafet> No, there is at least one permutation of an empty sequence.
17:15:28 <CodeWeaver> Forgot the =, there josh
17:15:40 <andromedab> huh?
17:15:47 <kallisti_> > permutations []
17:15:49 <lambdabot>   [[]]
17:15:53 <joshft91> which =?
17:16:08 <CodeWeaver> minimumOfList (x:xs)  = min' x minTail
17:16:19 <CodeWeaver> Whether on one line or two.  Without the guards, you need the = directly there.
17:16:27 <andromedab> okay yeah got that
17:16:43 <andromedab> delete x xs = [ x | x <- xs, x /= x ]
17:16:43 <andromedab> main = print $ delete 1 [1,2,3,4]
17:16:47 <andromedab> why does that return []
17:17:03 <CodeWeaver> x /= x?
17:17:04 <joshft91> like so?
17:17:04 <joshft91> minimumOfList (x:xs) = min' x minTail
17:17:08 <CodeWeaver> You don't see a problem with that andromedab?
17:17:09 <joshft91> or get rid of the =?
17:17:11 <eviltwin_b> because you shadowed the parameter x with the local binding
17:17:11 <andromedab> shouldnt it return 2 3 4?
17:17:15 <CodeWeaver> That's fine, josh
17:17:16 <eviltwin_b> use something else
17:17:33 <CodeWeaver> Josh, try it out. :D
17:17:38 <joshft91> still giving me a parse error on the line with min' a b
17:17:43 <CodeWeaver> Huh.
17:17:44 <CodeWeaver> Oh.
17:17:49 <CodeWeaver> Heheh
17:17:51 <kallisti_> andromedab: x /= is always false
17:17:52 <kallisti_> er
17:17:56 <kallisti_> * x /= x
17:18:11 <joshft91> ?_?
17:18:17 <eviltwin_b> andromedab, the list comprehension creates a new x that shadows (hides) the one you defined as a parameter
17:18:19 <ion> (*x)++;
17:18:34 <andromedab> kk thx
17:18:35 <CodeWeaver> josh, when you have a 'subexpression' like mintail, you don't use a let afterwards, you use a where.  You can use a let before. ie
17:18:36 <CodeWeaver> let (mintail = minimumOfList xs) in expr
17:18:38 <CodeWeaver> or
17:18:40 <Jafet> Yet another professor: "Haskell is dwim!"
17:18:42 <eviltwin_b> haskell does not track one of them as being the list comprehension's x and the other as being from the outside; they're both the same binding
17:19:00 <CodeWeaver> expr
17:19:01 <CodeWeaver>     where
17:19:01 <CodeWeaver>       mintail = minimumOfList xs
17:19:17 <CodeWeaver> josh:  two ways of introducing subexpressions.
17:19:24 <CodeWeaver> josh:  You had a broken hybrid.
17:20:02 <joshft91> hm
17:20:04 <joshft91> so...
17:20:04 <ski> Twey : the `forall' is because the constructor is polymorphic ..
17:20:05 <joshft91> where minTail = minimumOfList xs
17:20:25 <joshft91> forgot the "?"
17:20:43 <joshft91> I must just be failing big time here
17:21:13 <Twey> ski: I know why it's like that, but it doesn't stop me getting confused by it :þ
17:21:53 * ski isn't sure what there is to be confused about
17:22:54 <joshft91> CodeWeaver: still says it's giving me a parse error on this line "min' a b = if a < b then b else a"
17:23:04 <CodeWeaver> Hmmmmmm
17:23:16 <joshft91> http://hpaste.org/57208
17:23:20 <CodeWeaver> No, you're probably not.  Can you repaste, or update your hpaste code?
17:23:21 <CodeWeaver> Hah
17:23:23 <CodeWeaver> Beat me
17:23:26 <joshft91> :D
17:23:41 <Jafet> forsome: n. an orgy
17:23:43 <CodeWeaver> The where might have to be indented.
17:23:44 <ski> you need to indent `where' at least one space
17:24:30 <ski> `minmax (xs)' can be simpler written as `minmax xs'
17:25:00 <joshft91> so now that I got it comparing the two...
17:25:02 <ski> i think your  min'  and max'  are backwards
17:25:08 <joshft91> need to make it find the smallest - it returns the max atm
17:25:24 <joshft91> aha
17:25:25 <CodeWeaver> Your min' and max' are backwards. ;)
17:25:25 <joshft91> whoops
17:25:29 <CodeWeaver> hahahahahah
17:25:32 <CodeWeaver> Classic :D
17:26:03 <joshft91> so that should be it for that one, right?
17:26:10 <joshft91> should be able to easily do the max function
17:26:10 <CodeWeaver> As long as it works.
17:26:15 <CodeWeaver> And it's pretty simple, you have to admit.
17:26:22 <ski> btw, i assume you know that  min' x minTail  could be replaced by  min' x (minimumOfList xs)  right ?
17:27:01 <joshft91> hm, I think i see that.  just further simplification right?
17:27:23 <CodeWeaver> I suppose, a little more elegant, but also to clean it up in prep for doing both at once.
17:27:31 <CodeWeaver> There was nothing wrong at all with the way you had it.
17:27:38 <CodeWeaver> It was totally correct and readable.
17:28:10 <joshft91> mk, well they're both working now...
17:28:12 <CodeWeaver> Neat.
17:28:36 <CodeWeaver> Okay, so consider:  At each level of recursion, you're returning the best-so-far min or max (respectively) to the caller further back in the recursion.
17:28:38 <CodeWeaver> Follow?
17:28:45 <joshft91> Yup.
17:28:52 <CodeWeaver> But what if you didn't just return one value at each level.
17:28:53 <ski> joshft91 : yeah, if you think it's clearer to you to name `minTail', by all means, do it that way
17:28:56 <CodeWeaver> What happens if you return a tuple?
17:29:04 <CodeWeaver> At every level?
17:29:17 <CodeWeaver> A tuple that contains the min *AND* the max.
17:29:21 <CodeWeaver> Best seen so far.
17:29:26 <joshft91> right...
17:29:29 <joshft91> eeesh.
17:29:37 <CodeWeaver> Both at the base case, and at every level.
17:29:55 <CodeWeaver> Remember to reuse your min' and max' because they're handy declutterers. :)
17:30:05 * ski idly ponders a version that computes a running minimum, on the way down, and a running maximum, on the way up
17:30:10 <scooty-puff> if i have a list, that i call init, last, and zipWith on - zipWith (<>) (init xs) (...) ++ [last xs <> (...)]
17:30:10 <scooty-puff> can i assume the traversals will be fused?
17:30:10 <scooty-puff> and how can i check?
17:30:31 <CodeWeaver> ski, you're twisted. :D
17:30:44 <joshft91> CodeWeaver: Thanks for all the help man...though right now I think I need to move on to other stuff due this week =/
17:30:49 <CodeWeaver> Okay.  No worries.
17:31:02 <joshft91> CodeWeaver: thanks for all the help :D
17:31:10 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
17:31:10 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:48 2011]
17:31:10 --- names: list (clog koala_man HW42 mulletron audunska flux CosmicRay ixzkn mroman pcavs jahred posteverything scooty-puff jrslepak quintess` danharaj sbahra estebistec DevHC cwb` LordTrev hgolden looopy homie thlorenz tikhonjelvis betamine mreh_ irene-knapp glguy magicman dolio joshft91 fryguybob adlan MaskRay Zamarok gienah phenom_ warrenharris Eduard_Munteanu hajimehoshi gabber pantski alip aavogt juhp Rotaerk chops_ dylukes rexim taruti ksf papermachine dnolen cmasseraf)
17:31:10 --- names: list (ccc_ coeus tavelram__ theorbtwo copumpkin micahjohnston ceasarbautista kfish Eleanore kallisti_ PhilRod Jafet lnostdal funktronic|2 synonymous PatrickRobotham CodeWeaver jrslepak_ ivan` augur_ junsuijin Luke trin_cz Draconx|Laptop Enigmagic Triplefox kvey shapr dgpratt adam_ amagnus brownea whotemp DanBurton baldo1 MoALTz A1kmm miclorb_ GreaseMonkey amaron MrFahrenheit tensorpudding drwho bytbox afarmer stephenjudkins aluink SphericalCow JaffaCake1 m3ga)
17:31:10 --- names: list (NothingMan65 gwern Jantaro chops doserj ketil conal alexrn fcr_ ozgura pommes_ alpounet hughfdjackson Anoq gniourf_gniourf tswett toddles ajhager __main__ sysop_fb everzet bl4ckcomb aartamonau path[l] Vq brisbin tener__ EyesIsServer psii salisbury Nordvind MichaelBurge_ mjga shakakai nand` eno AtnNn torkjak brodo c2thunes_ noam_ danols_work sclv_ skiold pesco jeff_s_ nexx perlite gerard0 jbauman confab mysticc take_cheeze jabirali lambdanaut Tinned_Tuna knoc)
17:31:10 --- names: list (jml nus pcapriotti amiri ceii_ jklvxnasd EarlGray^ ville pikhq xarch__ ftrvxmtrx vortexion Ptival Internet13 fbern ceii The_third_man byorgey KaneTW [[zzz]] iago Obfuscate proqesi`` proq master_of_master jamil_1 emmanuelux ion gehho2 dreixel danvet joeytwiddle pi8027 quicksilver saati Jaxan insomniaSalt ByronJohnson repnop gmcabrita acfoltzer thirsteh liyang alang jrk_ ChongLi mbernstein dmos xinming scm minsa m_stone gentz Philonous_ otto_s wespee_ hadriano)
17:31:10 --- names: list (eZet PreciousMetals Pseudonym SeanTAllen MacMagnus DrSyzygy moonlite mauke twn rglenn RogueShadow brandonw dubellz mxweas|away sheaf BMeph shutdown_-h_now jix Sgeo hundskatt dkannan mndrix puzza007 strmpnk tomh si14 lopex arnihermann mimico bradwright wilfredh_ avocado joe9 mnestic zaero SonicvanaJr vithos hammi statusfailed teiresias wunki_off genivf ps-auxw dino- kolmodin Jonno_FTW ft X-Scale dMazz OscarZ dflemstr MK_FG SHODAN mimico_ BlastHardcheese Shou-)
17:31:10 --- names: list (Philippa_ jtannenbaum russellw Cale srid bcoppens pranq blast_hardcheese zeiris tromp_ purpleposeidon nyingen danlndi jonathanj Yarou_ tempire ahf zw01 levitation[A] Ralith tgeeky exobit gdsx Veinor trhodes vav Martty Spockz_ cmccann blackrain klugez janne sunfun akosch lusory nowhereman Bwild popx gltest_ daimrod oleiade_ BlankVerse yrlnry Smokey` mrdomino otk floomp timemage Lajla ambroff idoru bezik stepcut em kakos alios tsuraan_ Nimatek shepheb Blub\0)
17:31:10 --- names: list (vold pr Gunni Valodim Nisstyre hamilyon mee srh brendyn linduxed tazjin|away enobscuratus Belgarion schroedinbug gbeshers smly- davidL mr_sleepy lomeo lambdabot dcoutts_ gredman ernst idnar callen mercury^ guibou darkgerm kaol dannynn folone chee1 ArchGT frerich matthiasgorgens ujm hugin jedai Khisanth anders^^ burp jd10 abc05 maloi Masxmasx jlaire hpc drbean kanak Razz GeminiRai jonke ramier _root_ s4msung samek aliak Blazeix wagle noddy maurer mlh pdxleif)
17:31:10 --- names: list (preflex Amadiro Boney_ rsimoes milkpost dimmy otterdam peterhil bartavelle iulian dings snetz edwtjo kshannon doubledensity nighty- `10 chipdude BrianHV andrewsw Draggor redheadphones Botje @ChanServ ian_mi MostAwesomeDude ciaranm SimonRC Krinn fall_ krakrjak guerrilla overrosy smop dp_wiz milli monochrom akahn wto adimit abbe aristid Nshag Innominate Derander jlewis suiside a11235_ scgilardi poucet_ mateu joni6128 Hunner Zarathu ido zmoazeni_ lbotos kalven)
17:31:10 --- names: list (mdwright nots _jesse_ sordina ice799 welterde bddn jyyou erg lukish Gilly __class__ shoerain chr1s olsner ben Intensity ricky Solver tuv araujo mrshoe yeltzooo majoh kleini__ davean ahkurtz k0ral ski comak zenazn loccipocci lpsmith Corey copton othiym23 epdtry DustyDingo arcatan hackagebot Nereid tessier FireFly cygnus_ prof7bit gwillen mortberg Nanar cods setmeaway2 hirsch_ plat0 dmwit Ornedan tommd jonafan johs mjhan Liskni_si jimleroyer Dashkal Taggnostr2)
17:31:10 --- names: list (cschneid HalfWayMan hiredman R496_ mantovan1 flori warpy caligula_ gereedy saiam ve pyryp pettter aszlig tlockney nniro arkx Twey EvanR adnam SamB_XP yottis herself boyscared IvdSangen solarus blooberr sohum elliottcable liesen bobry nkpart wjlroe niko earthy LeNsTR|off Cerise Redshift64 jrockway _habnabit flamingspinach dumael djanatyn zomg stchang harlekin Damn3d bbee sahazel_ int-e nibalizer bd_ zygoloid confound `Zerax` mrd ziman BRMatt jackhill Lemmih)
17:31:10 --- names: list (lefant_ Ke reacocard quaestor CindyLinz snarkyboojum dcolish tsuraan__ PHO_ thorkilnaur dabradley aninhumer Yacoby Jaak ybit shawn wires cynick cjay ray dju petanqk inr electrogeek luite endojelly wayne[mobile] anachron Dybber elgot sipa Vulpyne alistra jayne Mathieu dqd Clint mejalx dlmalloc brixen hyko skaar MarcWeber integral sm djahandarie jmcarthur ubiquill jakeskik dilinger profmakx etabot bmiddleton bford helgikrs1 Runar Yahovah_ devn sagelywizard)
17:31:10 --- names: list (mikeplus64 koninkje_away brainproxy biio jamiely_desktop tamiko Raynes Dave2 Aikawa impl wingless tomprince `0660 kniu seats shachaf jbalint_ tg zorzar kate_r peddie clsmith scsibug Deewiant ehamberg jcapper kloeri xplat xsysstar chra Mitar opqdonut jakky ocharles mjrosenb norm2782 ahihi2 pou Igloo szbalint vmeson tomku stepnem angstrom mattp_ saruman_ thetallguy1 Astro edwinb dogmaT dcguru aleator sp3ctum jrib kissyboy benj_ Gracenotes nicoo wavewave mimi_vx)
17:31:10 --- names: list (ClaudiusMaximus Tene noplamodo nominolo iFire freiksenet alexsdutton zenzike drdo almostsix znutar antonh dropdrive TML companion_cube cncl atomicity sjl mornfall And[y] CoverSlide ddarius OnionKnight amiller danr ibid Starfire MrNibbles Laney eyck mike-burns Younos mokus_ eviltwin_b bogner frigga robinbb Entroacceptor franny froztbyte KitB etpace lokydor_ Phlogistique xnyhps Gothmog_ davv3 yezariaely tridactyla def-lkb buddyholly nlogax ttvd McManiaC mendez)
17:31:10 --- names: list (Saizan nihtml danm_ inimino ormaaj kyagrd)
17:31:10 <CodeWeaver> More than happy to help.
17:31:14 <joshft91> CodeWeaver: and how fast do you type?  because...you pump out text.
17:31:29 <CodeWeaver> Wow, that 's a spammy mess there
17:31:51 <CodeWeaver> Oh I dunno, about 40-80 wpm depending how technical the typing is.
17:32:07 <CodeWeaver> Lots and lots of online tutoring.  Just not normally in haskell. ;)  I'm branching out.
17:32:07 <joshft91> Hm
17:32:08 <tikhonjelvis> The trick isn't to type fast but to think fast
17:32:12 <joshft91> seems like a lot faster than that though
17:32:27 <joshft91> either way... good job. lol
17:32:41 <ski> CodeWeaver : ty
17:32:50 <CodeWeaver> :)
17:33:10 <joshft91> peace all!
17:34:37 <nyingen> @quote
17:34:38 <lambdabot> hofstadter says: That is, despite one's sense of departing ever further from one's origin, one winds up, to one's shock, exactly where one had started out. In short, a strange loop is a paradoxical
17:34:38 <lambdabot> level-crossing feedback loop.
17:37:14 <Jafet> > foldl1' (\(a,b) -> min a *** max b) . join zip $ [42..69]
17:37:16 <lambdabot>   (42,69)
17:37:37 <CodeWeaver> I have no idea what that even does, Jafet.
17:37:49 <CodeWeaver> But well done.
17:37:55 <ski> @src (->) (***)
17:37:56 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
17:38:02 <om-foxy> I'm trying to get a device context from a native window handle using WX.  I can get the native handle with `hwnd <- windowGetHandle f` but I can't see what function to call on `hwnd` to get the DC.
17:38:45 <ski> > (foldl1' (uncurry (***) . (min *** max)) . join zip) [42..69]  -- more illegible
17:38:47 <lambdabot>   (42,69)
17:39:27 <copumpkin> join zip?
17:39:29 <copumpkin> lol
17:39:34 * Jafet gives ski a point.
17:40:10 <ski> aka `map (join (,))'
17:40:10 <ion> :-)
17:40:32 <copumpkin> map . join (,) == join zip
17:40:33 <CodeWeaver> *cries*  Clearly I need much more haskell.
17:40:38 <CodeWeaver> *tries to eat Haskell book*
17:40:38 <copumpkin> I'm sure that's a profound categorical statement
17:40:58 <ski> > map . join (,) == join zip
17:41:00 <lambdabot>   Couldn't match expected type `a -> b'
17:41:00 <lambdabot>         against inferred type `(a1, a...
17:41:15 <copumpkin> pfft
17:41:20 <copumpkin> you know what I mean
17:41:20 <ion> @type [map (join (,)), join zip]
17:41:24 <nand`> @check (==) <$>  map . join (,) <*> join zip
17:41:26 <lambdabot> forall a. [[a] -> [(a, a)]]
17:41:27 <lambdabot>   Couldn't match expected type `a -> b'
17:41:49 <ski> > map (join (,)) == join zip
17:41:50 <lambdabot>   *Exception: (==): No overloading for function
17:42:39 <nand`> @check \x ->  (map . join (,)) x == join zip x
17:42:40 <Jafet> What
17:42:40 <lambdabot>   Couldn't match expected type `a -> b'
17:42:53 <ion> @check \xs -> map (join (,)) xs = join zip xs
17:42:53 <lambdabot>   Parse error at "=" (column 26)
17:42:56 <ski> @check liftM2 (==) (map (join (,))) (join zip)
17:42:57 <ion> @check \xs -> map (join (,)) xs == join zip xs
17:42:57 <lambdabot>   "OK, passed 500 tests."
17:42:58 <ski> @check liftM2 (==) (map (join (,))) (join zip :: [Bool] -> [(Bool,Bool)])
17:42:58 <lambdabot>   "OK, passed 500 tests."
17:42:59 <lambdabot>   "OK, passed 500 tests."
17:43:00 <mapreduce> How can I write readIORef fp >>= \fpv -> readIORef x >>= \xv -> printf "Final value of x is %f = %f\n" fpv xv
17:43:08 <mapreduce> without wanting to rip my eyes out.
17:43:30 <tikhonjelvis> Using do?
17:43:34 <nand`> @check (==) <$> join zip ,*>  map (join (,))
17:43:35 <lambdabot>   Parse error at "*>" (column 20)
17:43:36 <Jafet> @check liftM2 (==) (map $ join (,)) (ap zip reverse)
17:43:37 <lambdabot>   "OK, passed 500 tests."
17:43:39 <nand`> @check (==) <$> join zip <*>  map (join (,))
17:43:41 <lambdabot>   "OK, passed 500 tests."
17:43:44 <mapreduce> I'm in a do block already, you mean nest 'em?
17:43:57 <tikhonjelvis> Sure, why not? It'll probably make it more readable.
17:44:05 <ski>   join (printf "Final value of x is %f = %f\n" `ap` readIORef fp `ap` readIORef x)
17:44:08 <tikhonjelvis> You could also refactor this into its own function.
17:44:09 <Jafet> > do do do do do do do do do do return 5 :: [Int]
17:44:10 <lambdabot>   [5]
17:44:13 <eviltwin_b> applicative?
17:44:21 <ski> @type ap
17:44:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:44:37 <ion> > do do do do do do do do do do do do do do do do batman
17:44:39 <parcs`> liftM2 (printf "Final value of x is %f = %f\n") (readIORef fp) (readIORef x)
17:44:39 <lambdabot>   batman
17:44:43 <ski> hm, actually, the first `ap' should be `liftM'
17:44:57 <mapreduce> Nesting do does help.
17:45:18 <ion> Wait. Why do you need to nest “do” in this case?
17:45:39 <mapreduce> Because I don't want these variables having a large scope.
17:46:01 <mapreduce> I'd rather not even give them names, which is why I'm about to try parcs`' solution out.
17:46:50 <Jafet> printf "%f = %f" <$> readIORef fp <*> readIORef x
17:46:51 <parcs`> maybe applicative is nicer here: printf "Final value of x is %f = %f\n" <$> readIORef fp <*> readIORef x
17:47:44 <augur_> so are there any hierarchies of computational "style"?
17:48:07 <mapreduce> parcs`: I had to add a nice big type annotation to printf to make the first compile.
17:48:12 <augur_> like, ignoring memory limitations, focusing instead of what kinds of behavior the computer can have?
17:48:18 <mapreduce> Let's try that <$> version..
17:48:32 <nand`> augur_: I can only imagine there are
17:48:56 <nand`> there's a clear hierarchy between turing complete and non-turing complete machines
17:49:07 <Jafet> mapreduce: of course you do. You don't ever use the result of printf
17:49:31 <nand`> factor quantum computers, SIMD etc. into this and I guess you get some form of hierarchy in terms of what kind of behavior the computer is capable of
17:49:47 * hackagebot text-register-machine 0.2.0 - A Haskell implementation of the 1# Text Register Machine  http://hackage.haskell.org/package/text-register-machine-0.2.0 (AdamFoltzer)
17:49:59 <parcs`> oh right..
17:50:17 <mapreduce> I still need a type annotation even with the applicative version.
17:50:35 <augur_> nand`: hmm.
17:50:39 * ski . o O ( <http://en.wikipedia.org/wiki/Arithmetical_hierarchy> )
17:50:44 <Jafet> If you don't ever use the result of printf, the type of the result cannot be inferred.
17:50:45 <parcs`> mapreduce: try join (printf "..." <$> ...)
17:51:34 <nand`> augur_: consider the relationship between types of algorithms and runtime
17:51:51 <nand`> for example an O(1) algorithm on a SIMD machine is inevitably O(n) on a SISD machine
17:52:09 <nand`> (assuming you don't change the algorithm eg. to use mathematical calculations or heuristics)
17:52:14 <mapreduce> :t join
17:52:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:52:17 <Jafet> What is "computational \"style\""
17:52:24 <mapreduce> parcs`: Why did that work?
17:52:41 <sbahra> Nanar, how is an O(1) algorithm on a SIMD machine inevitably O(n) on a SISD machine?
17:52:47 <nand`> therefore a SIMD machine has some form of expressiveness that is more powerful than SISD
17:53:01 <mapreduce> Jafet: However, if I use printf "foo" x y the type of printf can be inferred.
17:53:05 <sbahra> nand`, woops, how is an O(1) algorithm on a SIMD machine inevitably O(n) on a SISD machine?
17:53:11 <nand`> sbahra: a single instruction in a SIMD machine can operate on an (in theory) indefinate amount of unconnected data simultaneously
17:53:23 <sbahra> Ah, ok. :)
17:53:28 <nand`> for example
17:53:40 <nand`> zipWith (+) on a SIMD machine would be O(1)
17:54:12 <Jafet> Yes, executing 1 instruction requires O(1) instruction executions.
17:54:47 * hackagebot xturtle 0.0.7 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.7 (YoshikuniJujo)
17:54:51 <cmccann> Jafet, a remarkable coincidence that occasionally misleads people into thinking that arithmetic is inherently O(1)
17:54:59 <nand`> furthermore, theoretical quantum computing machines could perform operations in less than O(n) time that you'd need O(n) or worse in every current architecture
17:55:45 <Jafet> But it is! An arithmetic operation takes O(1) arithmetic operations.
17:55:56 <Jafet> I don't know what your point is.
17:56:02 <DanBurton> But if we're in theory land, I personally prefer the oracle machine that computes anything in O(1) time.
17:56:02 <nand`> n in the context of arithmetic is the size of the number, is it not?
17:56:09 <nand`> so addition between two n-sized integers is O(n)
17:56:34 <nand`> but yeah, depends on what you define as "instruction"
17:57:05 <Jafet> You haven't defined anything, you left out all the units
18:01:22 <nand`> Generally speaking “n” is inevitably a function with some given domain (eg. number of elements in a data set) and a codomain (number of state transitions involving states composed of elements of the domain)
18:01:51 <nand`> so for example if the domain is number of elements, the codomain would be how many times you have to rearrange or modify these elements in some way to get your desired result
18:01:58 <nand`> That's my interpretation at least
18:03:42 <Jafet> It merely amuses me that people always privately assume a certain computing model when they use O() without units, even in a discussion about comparing widely disparate computing models
18:06:12 <nand`> Jafet: well it's generally assumed on that you're scaling with the same thing (eg. number of elements of a list)
18:08:07 <Jafet> Big-O is used to scale one thing with another thing. There is no point scaling one thing with the same thing.
18:08:25 <parcs`> mapreduce: because printf returns an IO (), but lifting its arguments to type IO a also lifts its result to type IO (IO ()).  thus you need join to flatten the result back to IO () in order to execute as intended.
18:09:02 <parcs`> mapreduce: another way: (printf "Final value of x is %f = %f\n" =<< readIORef fp) =<< readIORef x
18:09:09 <Jafet> If an algorithm on n items uses up O(n) monkeys, you are scaling the number of items with the number of monkeys.
18:09:18 <mapreduce> parcs`: Interesting, thank you.
18:09:21 <Jafet> It may also use up O(n^2) bananas.
18:09:28 <Jafet> @instances PrintfType
18:09:29 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
18:09:42 <nand`> Jafet: I meant two people comparing algorithms in different languages
18:09:51 <nand`> they're scaling with the same input quantity
18:09:53 <Jafet> parcs`: IO () is not one of the results that may be returned by printf
18:10:18 <parcs`> Jafet: instance [safe] PrintfType (IO a) -- Defined in Text.Printf
18:10:35 <Jafet> Oh ok
18:10:36 <Sgeo> parcs`, [safe]?
18:10:38 <Jafet> What a silly instance
18:11:21 <Jafet> It's still probably shorter to type putStr.printf...
18:12:02 <Jafet> Sadly, it would have to be liftM putStr
18:12:19 <parcs`> Sgeo: i think that has to do with the new Safe language extension
18:13:19 <Jafet> nand: that's irrelevant to what I said.
18:13:35 <nand`> readFile closes its file when it reads the last character, right?
18:14:05 <Jafet> Probably not
18:14:11 <Axman6> no
18:14:27 <parcs`> Sgeo: wait no, it has to do with OverlappingInstances. if enabled, [safe] means that the instance doesn't overlap
18:14:32 <Axman6> it closes when the gc decides its a good time to
18:14:44 <Axman6> which can be wrong
18:14:52 <Jafet> At the least, it would not close before end-of-file is read
18:15:06 <Axman6> i dont think thats true
18:15:11 <nand`> hm
18:15:43 <nand`> according to http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-IO-Handle.html#v:hGetContents a semi-closed handle becomes closed when the entire contents of the handle has been read
18:16:14 <Saizan> nand`: yeah, it does close it
18:16:39 <nand`> oh wait nvm forget I asked, I'll just hOpenFile and hClose manually
18:18:43 <Axman6> nand`: consider using ResourceT too
18:19:14 <nand`> or even better, withFile
18:19:37 <Axman6> i wouldnt say better
18:19:44 <nand`> how so?
18:20:26 <nand`> I'm writing a plugin for xmobar, and every second it should poll the contents of a file, do some light computations on it (which may or may not read the entire contents), return that as an IO String and close the file
18:20:29 <nand`> is withFile not perfect?
18:20:57 <Axman6> because resourceT lets you open many resources in a single do block, without having to worry about all that nesting. and it's not always clear that a single resource like a file should be released in the reverse order in which they were opened
18:21:08 <Jafet> If readFile uses hGetContents, then it can't close the file before reaching end-of-file
18:21:21 <Jafet> Because it has no way of knowing where end-of-file is
18:21:45 <Jafet> I guess that wasn't the question though
18:22:36 <dolio> The file can be closed before EOF is read if all references to the string fall out of scope and it gets collected.
18:22:49 <Jafet> Also, you can hGetContents and hClose manually
18:22:49 <diginet> so Haskellers...I think I've been converted
18:23:04 <Axman6> i believe one of the problems with lazy IO has been that if you use something like hGetcontents, you may not get all the contents of the handle before its closed, and you don't get the rest of that data
18:23:16 <Jafet> As long as you don't care about the contents after that
18:23:46 <dolio> That only happens if you close the handle manually.
18:23:50 <diginet> after my frustration with Lispers heresy, I mean "multi-paradigm" -ness, I've decided to follow the path of the one true lord, err I mean play with pure functional languages
18:23:57 <dolio> Which you should never do if you're doing lazy I/O.
18:24:05 <nand`> Jafet: yeah, I considered that earlier
18:24:12 <nand`> then I realized withFile would implement the exact s ame logic
18:24:21 <nand`> Axman6: sounds interesting, I'll have a look
18:24:22 <Axman6> diginet: we use IO all the time, be warned
18:24:29 <diginet> I know
18:24:34 <mike-burns> And OO ideas.
18:24:36 <diginet> but Monads are pure
18:24:45 <mike-burns> Monad is a typeclass.
18:24:53 <Axman6> except for the ones that arent
18:25:01 <diginet> Well Haskell IO I like a lot better than Lisp IO
18:25:56 <Axman6> that is probably true
18:26:10 <diginet> this channel is huge by the way, how popular is Haskell?
18:26:20 <diginet> I thought it was fairly obscure...
18:26:21 <mike-burns> Is there a metric?
18:26:22 <Axman6> enough
18:26:41 <diginet> I mean, I don't care either way
18:27:02 <nand`> withFile f ReadMode $ \hf -> withFile b ReadMode $ \hb -> highlight <$> hGetContents hf <*> hGetContents hb -- is a bit ugly
18:27:49 <Axman6> it would be less ugly with ResourceT i think
18:27:58 <nand`> Axman6: you mentioned ResourceT, but I can't find any information on it
18:28:04 <nand`> on hoogle
18:28:11 <Axman6> @google resourceT
18:28:12 <mike-burns> It's in conduit.
18:28:13 <lambdabot> http://www.t-quoter.com/
18:28:13 <lambdabot> Title: ReSource T-Quoter
18:28:16 <Axman6> hmm
18:28:21 <nand`> hmm
18:28:25 <Axman6> @google resourceT yesod
18:28:27 <lambdabot> http://www.yesodweb.com/blog/2011/12/resourcet
18:28:27 <lambdabot> Title: The Resource monad transformer
18:28:33 <diginet> what does haskell have in terms of analogues to lisp-style lists?
18:28:33 <nand`> google for "resourceT haskell" pulls up a reddit link
18:28:35 <nand`> or that
18:28:37 <mike-burns> http://hackage.haskell.org/packages/archive/conduit/0.1.1.1/doc/html/Control-Monad-Trans-Resource.html
18:28:51 <Axman6> diginet: what are lisp style lists?
18:29:10 <mike-burns> diginet: You can make lots of data structures in Haskell. What do you need?
18:29:13 <diginet> linked lists, cons cells, or are my desire to use such data structures part of the olds ways
18:29:27 <Axman6> haskell lists are linked lists too
18:29:30 <diginet> ah okay
18:29:35 <Jafet> diginet: in other words, lists that may secretly masquerade as any other data structure?
18:29:39 <diginet> yeah
18:29:40 <Axman6> haskell is fantastic for data structures
18:29:45 <diginet> sweet!
18:29:48 <Axman6> ew
18:29:52 <diginet> ?
18:29:55 <Axman6> lists are lists, nothing more
18:30:06 <Axman6> well, they're also our for loops
18:30:09 <nand`> haskell has several dozen different list/sequence/array/enumeration/string-type structures
18:30:17 <nand`> (okay probably less)
18:30:20 <diginet> well, I mean, I used cons cells for arbitrary data structures
18:30:21 <mike-burns> We tend to use real data structures in Haskell, instead of making lists into tuples, records, etc.
18:30:28 <diginet> ah okay
18:30:42 <nand`> haskell has types
18:30:48 <diginet> I feel like this is the cold war, and I'm defecting to the soviet union or something...
18:30:49 <diginet> lol
18:30:53 <Axman6> data Tree a = Nil  Leaf a | Node a (Tree a) (Tree a)
18:30:57 <DanBurton> The two constructors for a regular list in Haskell are [], the empty list, and (:) which is cons
18:31:09 <nand`> diginet: perspective
18:31:12 <Axman6> > 1 : []
18:31:13 <lambdabot>   [1]
18:31:18 <Axman6> > 1 : 2 : []
18:31:20 <lambdabot>   [1,2]
18:31:23 <Axman6> > [1,2]
18:31:25 <lambdabot>   [1,2]
18:31:32 <diginet> what is the best non-noobish intro to Haskell (i.e. for someone who knows stuff about programming already)
18:31:49 <DanBurton> > let cons = (:); empty = [] in (cons 1 (cons 2 (cons 3 empty)))
18:31:50 <lambdabot>   [1,2,3]
18:31:53 <Draggor> diginet: http://learnyouahaskell.com/
18:31:55 <Axman6> probably still lyah
18:31:57 <nand`> Axman6: Leaf a is the same as Node a Nil Nil
18:31:59 <diginet> ah
18:31:59 <nand`> why bother?
18:32:01 <diginet> sweet
18:32:02 <mike-burns> The Haskell 98 Language Report.
18:32:10 <nand`> just easier pattern matching?
18:32:11 <Axman6> nand`: they could have different semantics
18:32:39 <Axman6> null at the end of a list is the same as null at the branch of a tree, but it doesn't make it a good idea to use null
18:32:40 <Jafet> That's almost as bad as learning lisp from hyperspec.
18:33:18 <Jafet> nand: uses less space
18:33:27 <Draggor> diginet: I bought the book, which is quite nice.  Also, this has been tons of fun: http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
18:34:47 * hackagebot yesod-auth-ldap 0.0.1.1 - LDAP Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-ldap-0.0.1.1 (MichaelLitchard)
18:35:12 <Jafet> Or generalised: Tree a b = Nil | Leaf a | Branch b (Tree a b) (Tree a b)
18:35:50 <Draggor> diginet: That last link is writing a scheme interpreter in haskell
18:36:05 <Axman6> also, a rose tree: data RTree b a = Leaf a | Node b [RTree b a]
18:37:44 <Axman6> hmm, can you generalise that much more? (apart from maybe puttin the a's and b's in lists too =)
18:38:59 <Jafet> Yes.
18:46:00 <nand`> you can generalize anything to: data Blob = End | Blob Blob
18:46:04 <Veinor> whee, bootstrapping to 7.4.0 using 7.0.4
18:46:31 <nand`> (but not in the type system)
18:47:02 <Axman6> i don't see how a representation of natural numbers helps very much
18:47:56 <nand`> (g :: BitSequence -> Data) . (f :: Blob -> BitSequence)
18:49:17 <Axman6> so, you go from a number that fits in O(log n) space, to a number which fits in O(n) space?
19:05:01 <mapreduce> @quote posh
19:05:01 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
19:05:33 <nyingen> haskell is hardly a posh calculator. no coercion
19:05:36 <mapreduce> That's me.  I've been battling this just now by going through a C tutorial and porting the examples to Haskell, without altering them to be idiomatic.
19:07:06 <mapreduce> The world's finest imperative programming language looks quite clumsy in my hands, http://pastebin.com/w0UxCsRq compared to the original http://einstein.drexel.edu/courses/Comp_Phys/General/C_basics/#arrays
19:07:08 <mauke> The paste w0UxCsRq has been copied to http://hpaste.org/57209
19:08:46 <mapreduce> It's surprising that every array type and reference type has its own function names for reading and writing instead of using some typeclass for it.
19:09:24 <mapreduce> writeArray, writeIOArray, memset, readArray, readIOArray, peek
19:10:55 <mapreduce> Any suggestions for shrinking that code?
19:11:30 <Cale> mapreduce: I'll have a look
19:12:00 <Cale> um
19:12:12 <Cale> Well, is the point to use Ptr?
19:12:31 <Cale> Because, if it's not essential to use Ptr, then you could be 100x more idiomatic ;)
19:13:29 * ski . o O ( "loop in C , recursion in haskell",<http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html> )
19:13:45 <Cale> loop in C, higher order function in haskell
19:13:58 <Cale> heh
19:14:00 <Cale> yeah
19:14:03 <dolio> if b then ... else return () = when b (...)
19:14:06 <Cale> that old post :D
19:14:09 <mapreduce> I just wanted to port the C code (which does use pointer deliberately) without altering the meaning too much.
19:14:15 <mapreduce> dolio: Yep, hpaste told me that one. :)
19:14:27 <ski> s/hpaste/hint/
19:14:34 <mysticc> Why alex is no updated .. it gives error of recursive dependencies while installing >
19:17:24 <Cale> mapreduce: why not:  forM_ [(i, 0.5 * fromIntegral i) | i <- [0..3]] $ \(i,v) -> printf "  %d  %f \n" i v
19:17:35 <Cale> ;)
19:17:48 <Cale> well, that should be [0..2]
19:17:59 <mapreduce> Because I prefer my eyes to remain within my head.
19:18:04 <Cale> heh
19:18:14 <Cale> or:
19:18:16 <Sgeo> Why is the function withSocketsDo and not initSockets?
19:18:45 <Cale> forM_ [0..2] $ \i -> printf "  %d  %f \n" i (0.5 * fromIntegral i)
19:18:49 <copumpkin> that thing needs to die
19:19:03 <mapreduce> Cale: Very nice.
19:19:38 <mapreduce> Clearly I need to work on my list comprehension comprehension, given my reaction to the first.
19:19:51 <zachbarnett> lambdabot: help
19:19:53 <Cale> mapreduce: basically loops translate into lists, and loop bodies transform into higher order functions on them
19:20:12 <Cale> mapreduce: At least, that should be a good starting point
19:20:46 <Cale> Lists in Haskell often don't actually make very good sequence datastructures for other uses (but we have those, separately)
19:21:48 <Cale> But for any case where you're iterating over a set of things one by one, and not jumping around, they're perfect.
19:23:58 <Cale> also,   join (f <$> g)  =  f =<< g
19:24:13 <ski> @help zachbarnett
19:24:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:24:20 <Cale> join (printf "  %d  %f \n" i <$> readArray x i)
19:24:31 <Cale> = printf "  %d  %f \n" i =<< readArray x i
19:24:34 <zachbarnett> @help zachbarnett
19:24:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:24:43 <zachbarnett> @list
19:24:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:25:03 <mapreduce> Cale: Well, that pretty much halved the line count!
19:29:39 <Sgeo> o.O at "withSocketsDo x = x"
19:29:48 * hackagebot text-register-machine 0.3.0 - A Haskell implementation of the 1# Text Register Machine  http://hackage.haskell.org/package/text-register-machine-0.3.0 (AdamFoltzer)
19:30:01 <Sgeo> Presumably, there was a compile-time thing involved?
19:30:21 <Sgeo> Where is the .hsc?
19:30:27 <Sgeo> Is it available easily on the web?
19:32:01 <zachbarnett> @babel
19:32:01 <lambdabot>   bzzt.
19:33:20 <Adrian_GG> hello
19:34:53 <Adrian_GG> I am new to haskell and I would like to learn it
19:35:17 <Adrian_GG> and I am trying to understand the function foldl
19:35:18 <companion_cube> @where lyah
19:35:18 <lambdabot> http://www.learnyouahaskell.com/
19:35:23 <companion_cube> hop, done :]
19:35:24 <Adrian_GG> yes
19:35:26 <Adrian_GG> i already
19:35:27 <Adrian_GG> went
19:35:29 <Adrian_GG> and
19:35:30 <Cale> Adrian_GG: okay
19:35:31 <companion_cube> sorry ^^
19:35:31 <Adrian_GG> studied
19:35:32 <Adrian_GG> the online
19:35:37 <Adrian_GG> http://pastebin.com/A3UUeMhs
19:35:37 <Adrian_GG> here
19:35:39 <mauke> The paste A3UUeMhs has been copied to http://hpaste.org/57211
19:35:55 <Adrian_GG> I do not understand why that would not work
19:36:04 <Cale> foldl takes another parameter
19:36:30 <Cale> and the function it takes as its first parameter has to combine two things
19:36:48 <Cale> you could write  foldl max 1 list
19:36:57 <Adrian_GG> yes i know
19:37:05 <Adrian_GG> and it works
19:37:11 <Adrian_GG> one second
19:37:21 <companion_cube> > foldl max 1 [0,1,2,3,4]
19:37:22 <lambdabot>   4
19:37:36 <Adrian_GG> yes but what I want to do here is call a function made by me
19:37:43 <Cale> sure
19:37:58 <monochrom> maxA is a wrong function for foldl. and I can't guess what you want.
19:37:59 <Cale> also, you're applying the x parameter to 1
19:38:03 <Cale> So x has to be a function
19:38:11 <Cale> (x 1) is a function application
19:38:22 <Cale> perhaps you meant
19:38:28 <Cale> maxA x = max x 1
19:38:41 <Cale> but then maxA isn't really the right type to be a parameter to foldl
19:39:02 <Cale> http://cale.yi.org/share/Folds.svg
19:39:16 <Cale> Perhaps the diagram for foldl here will help
19:39:33 <companion_cube> wow, cool
19:39:42 <Adrian_GG> ok i will try to grasp and understand what u just wrote
19:39:45 <Cale> foldl f z takes a list, like [1,2,3,4,5] = 1 : (2 : (3 : (4 : (5 : []))))
19:40:02 <companion_cube> Cale: how did you generate that?
19:40:08 <Cale> companion_cube: by hand
19:40:19 <Axman6> he wrote the bits himself
19:40:20 <Cale> (in inkscape)
19:40:23 <Axman6> one by one
19:40:29 <Adrian_GG> :))
19:40:40 <Axman6> using a telegraph ticker
19:40:43 <Cale> lol, with a magnetised needle on my open case hard drive
19:41:06 <companion_cube> you really used inkscape? :/
19:41:09 <Cale> yes
19:41:14 <Cale> why?
19:41:18 <monochrom> better than needles
19:41:53 <Cale> It's great for diagrams
19:42:00 <companion_cube> I was hoping you had a cool graph generation code :)
19:42:37 <nand`> Cale: are you the person that's been bastardizing my view of the world with supergeneralized prelude functions?
19:42:37 <Cale> everyone seems to hope that
19:42:42 <Cale> lol
19:42:58 <Cale> problem?
19:43:18 <Cale> ANYway
19:43:22 <magicman_> @hackage vacuum
19:43:22 <lambdabot> http://hackage.haskell.org/package/vacuum
19:43:32 <Cale> Adrian_GG: have a look at the diagram for foldl there
19:43:37 <Adrian_GG> im trying
19:43:39 <Adrian_GG> to understand
19:43:43 <Adrian_GG> but the concept seems
19:43:46 <Cale> Adrian_GG: if you'd like to see it written out in flat language...
19:43:46 <Adrian_GG> really weird to me
19:43:56 <Axman6> Adrian_GG: please
19:44:01 <Adrian_GG> yes
19:44:01 <Axman6> don't use
19:44:02 <Axman6> the
19:44:05 <Axman6> return
19:44:07 <Axman6> key
19:44:08 <Axman6> so
19:44:10 <Cale> > foldl f z (1:(2:(3:(4:(5:[])))))
19:44:11 <Axman6> much
19:44:11 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
19:44:13 <Axman6> .
19:44:16 <Axman6> ok
19:44:18 <Axman6> ?
19:44:21 <monochrom> please don't press the return key ever. just don't press it.
19:45:03 <Cale> In the diagram, lines run from the bottom of each function to the top of its arguments
19:45:27 <Cale> These graphs represent the actual structure of the expressions in memory
19:45:32 <nand`> Cale: are you also the one who impregnated lambdabot with a Num (a -> a) instance or was that some other joker?
19:45:58 <Cale> nand`: That was half me and half Conal Elliott
19:46:20 <nand`> aka “some” other joker
19:46:23 <Cale> (he wrote the vector-space library, I imported its modules)
19:47:11 * mgsloan ponders writing a diagrams backend for vacuum
19:48:49 <mzero> what can I use to pump bytes in one end, utf-8 decode them, and pull characters out the other --- the hitch being that I am going to pump buffers of bytes in over time, and pull strings out as I can.... in otherwords I want something that can keep track of the intermediate character state, should a character span two buffers full
19:49:16 <irene-knapp> that sounds like the probably-remote-exploitable crasher I found in expat
19:49:36 <irene-knapp> a UTF8 character crossing two internal-chunk boundaries will crash it
19:49:56 <Sgeo> http://codepad.org/WVjfiHRr why can
19:50:01 <Sgeo> why can't it find Data.Data?
19:50:04 <mzero> well, hoping to find a non-crashing version here
19:50:13 <irene-knapp> indeed
19:50:25 <irene-knapp> well, no idea :)
19:51:49 <Axman6> mzero: is Text useful for that? I guess the incremental nature isn't so good there. seems like a good use for an enumeratee/conduit
19:52:00 <mzero> Sgeo - what version of GHC / base package do you have? I have a vague recollection that Data.Data was added to base at some point in recent history
19:52:12 <Sgeo> mzero, the question is what is codepad using
19:52:21 <mzero> Axman6: I don't see any support for buffering the input
19:52:32 <mzero> I thought something like GHC 6.12
19:52:42 <Sgeo> ...I think perhaps I should use cereal to solve all my problems.
19:53:04 <Sgeo> I can define a Serialize instance with my own put and get, right?
19:53:22 <Sgeo> Because what I'll be putting and getting will be different from whatever the automatic thing might come up with
19:53:44 <Axman6> mzero: i wonder whether it would be easy to implement using attoparsec.
19:54:20 <mzero> oh, probably - but given as my project has like four UTF-8 codecs in it already - I was hoping I didn't have to write this!
19:54:21 <Axman6> because you can get partial parser results, which expect more input, and i think it can return the rest of the bytestring once it has a result i believe
19:54:26 <Cale> Adrian_GG: anyway...  consider something like  foldl (\n d -> 10*n + d) 0 [1,2,3,4,5]
19:54:34 <Cale> > foldl (\n d -> 10*n + d) 0 [1,2,3,4,5]
19:54:35 <lambdabot>   12345
19:54:48 * mzero counts: GHC's IO codec, utf8-stirngs package, text package, blaze package
19:54:56 <Cale> We can reduce it step by step to see how it works, if you like
19:55:26 <Cale> (though it might be best to do the evaluation in a different order from how it'd actually occur under plain lazy evaluation)
19:55:31 <Cale> @src foldl
19:55:32 <lambdabot> foldl f z []     = z
19:55:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:55:44 <Cale> Adrian_GG: still here?
19:55:59 <Axman6> @hoogle ByteString -> (Char, ByteString)
19:56:02 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
19:56:02 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
19:56:02 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
19:56:20 <monochrom> mzero: using the "utf8-string" package, or the "encoding" package, you can feed a lazy bytestring, and obtain a [Char].
19:57:43 <mzero> well, I'm picking up buffers in IO code -- as in, in response to some program event, pulling all the buffers (IO from File Descriptors) that are available, and returning all the chars I can decode.....
19:58:02 <mzero> so I can't pull those together into a lazy list
19:58:04 <Adrian_GG> yes Cale I am trying to understand this
19:58:11 <Cale> Adrian_GG: okay
19:58:40 <Cale> So according to the second equation for foldl...
19:59:05 <Cale> foldl (\n d -> 10*n + d) 0 (1 : [2,3,4,5]) = foldl (\n d -> 10*n + d) (10*0 + 1) [2,3,4,5]
19:59:17 <Cale> yeah?
19:59:44 <Axman6> that would be clearer on two lines i think
19:59:50 <Cale> yeah, maybe
20:00:22 * Axman6 remembers the days when Cale would explain things line by line to him
20:00:50 <Cale> I'm tired, and I need to get back to doing work :S
20:00:54 <Cale> lol
20:01:09 <Cale> = foldl (\n d -> 10*n + d) (10*0 + 1) [2,3,4,5] -- repeat of previous RHS
20:02:53 * ski wonders whether Cale is about to hand-trace this expression
20:03:04 <Adrian_GG> I will return in 5 minutes thank you
20:05:31 <Cale> ski: I was going to, but my attention is quite divided
20:07:43 <tkahn6> hey guys can y'all help me out with this… what am I doing wrong here? http://hpaste.org/57214
20:08:30 <monochrom> mzero: then GHC.IO.Encoding since GHC 7.0 seems like the closest, giving you buffer-level control
20:09:54 <cmccann> tkahn6, you've got a bunch of funny triangles in there, maybe that's the problem :D
20:09:58 <tkahn6> heh
20:10:01 <tkahn6> those are tabs
20:10:08 <mzero> monochrom: oy, but *that* only operates in IO
20:10:12 <cmccann> right, I gathered
20:10:19 <mzero> which, I suppose I could deal with
20:10:36 <tkahn6> i just left them in there to show my spacing
20:10:41 <mzero> for now... (has his own, er, well, honestly, funny fake IO like monad to contend with)
20:11:01 <cmccann> tkahn6, hm, your parentheses look imbalanced
20:11:14 <tkahn6> cmccann: :)
20:11:15 <tkahn6> thanks
20:11:36 <cmccann> interesting choice of error message there, took me a while to spot that
20:11:52 <tkahn6> you have saved the day
20:12:13 <tkahn6> and it's only 6 minutes old on the east coast
20:12:57 <cmccann> yes, that was my good deed for the day, now I'm free to be a useless jackass for the next 23 hours and 53 minutes
20:13:06 <tkahn6> win-win!
20:14:41 <monochrom> mzero: I think you can steal GHC.IO.Encoding's source code's utf8 part and modify it to be IO-free, essentially chasing down how it models a buffer by a ForeignPtr and replacing that by a pure array
20:15:17 <mzero> yeah - lovely.... urp! I think I can code a pure one (not efficient, but I'm not worried about that at present) in just a few lines
20:15:21 <mzero> just annoying to have to
20:15:27 <monochrom> haha
20:16:13 <monochrom> in practice the IO is just for ForeignPtr etc being its idea of buffers.
20:16:38 <Axman6> might ST be useful for this?
20:18:27 <mzero> AHA - uncons :: ByteString -> Maybe (Char, ByteString)
20:18:30 <mzero> that'll do
20:19:18 <Axman6> does that work for unicode chars though?
20:20:17 <zzo38> (<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a; x <>>= f = x >>= ap (<$) f; infixl 1 <>>=;   How useful is this to you?
20:21:11 <Axman6> :t \f -> ap (<$)
20:21:11 <lambdabot> forall t a (f :: * -> *) b. (Functor f) => t -> (a -> f b) -> a -> f a
20:21:23 <Axman6> :t \f -> ap (<$) f
20:21:24 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a -> f b) -> a -> f a
20:21:52 <mzero> bah ! no! it just gobbles up the bits at the end of the buffer as ReplacementChar
20:21:53 <mzero> file
20:22:27 <zzo38> ap (same as <*>) is like the S combinator.
20:22:40 <Adrian_GG> I want to create a binary search tree in Haskell and I want to do it with foldl does this make sense http://pastebin.com/hrN9MEMS ?
20:22:42 <mauke> The paste hrN9MEMS has been copied to http://hpaste.org/57216
20:23:14 <monochrom> @type foldl
20:23:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:23:52 <monochrom> no, and several things wrong, not just one
20:24:01 <zzo38> Why is that eta reduce thing an error? It should say warning instead of error, isn't it?
20:25:04 <monochrom> presumably you like to say "foldl insertTree empty_tree_here list", right? well, why is the empty tree called BST? why isn't it called Leaf?
20:25:27 <monochrom> insertTree has its parameter order wrong
20:26:07 <zzo38> Why is BST in there anyways? I do not see a constructor with that name
20:26:30 <ski> zzo38 : you should make it have context `Monad m'
20:26:42 <Adrian_GG> http://pastebin.com/d1MDWTEf
20:26:44 <mauke> The paste d1MDWTEf has been copied to http://hpaste.org/57217
20:26:51 <Adrian_GG> it is there I defined the constructor
20:26:53 <monochrom> that is, from the type of foldl, (a -> b -> a) -> a -> [b] -> a, clearly you want to set a=BST, b=Int, and get (BST -> Int -> BST) -> BST -> [Int] -> BST. that tells you the right type of insertTree
20:26:54 <Adrian_GG> at the beggining
20:27:20 <zzo38> ski: I will do that if they fix the Monad class. But for now I always define everything that requires Monad as requiring Functor as well.
20:27:36 <ski> zzo38 : does not always work
20:28:24 <zzo38> ski: Do it in your own program with only Monad m if that is what you want; I am just asking about use of this function to you in general.
20:29:11 <zzo38> They should fix the Monad class by making join a class method and making Functor a requirement to make Monad class
20:29:38 <ski> well, i might call it `before', instead of `(<>>=)'
20:30:11 <tkahn6> so i am getting absolutely terrible memory performance with tagsoup
20:30:13 <ski> i think it might be useful sometimes, but not very commonly
20:30:19 <tkahn6> is this common or am i doing something wrong
20:30:21 <Axman6> mzero: http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.0/doc/html/Data-Attoparsec-Text.html is so close, but it'll require the Text values to have full characters, so you can't just convert the ByteString to a Text value and hope it'll work :(
20:32:02 <zzo38> ski: OK. I called it <>>= because I use it infix, but call it before if that is what you prefer. But how much do you use such things? I find it useful in some file writing IO stuff (I also sometimes use <* in IO stuff between hTell and hSeek), but there are other ways of programming these things so not really needed but it help to me at least
20:32:16 <ski> you could use `before' infix, as well
20:32:29 <mzero> I think I can just build one out of Data.Attoparsec -- should be about four lines for the parser
20:32:43 <mzero> then the continuation function suffices
20:33:04 <zzo38> ski: Yes you could, but I prefer names with punctuations for infix operators; but do what you prefer.
20:33:17 <ski> hm, i suppose one could rename `finally' into `finally_', and then call this `finally'
20:33:28 <ski> @type finally
20:33:29 <lambdabot> Not in scope: `finally'
20:33:38 <ski> @type Control.Exception.finally
20:33:39 <lambdabot> forall a b. IO a -> IO b -> IO a
20:33:57 <Adrian_GG> so for my parameters for insertTree I should have insertTree :: BST -> [Int] -> BST ?
20:34:18 <ski> Adrian_GG : why `[Int]' ?
20:34:26 <Adrian_GG> I could have Int
20:34:40 <Adrian_GG> I do not have a list there just an integer
20:34:46 <ski> *nod*
20:35:04 <ski> try it ?
20:35:09 <russ_> yes
20:35:12 <zzo38> (I find <>>= useful both for reading and writing files in IO, and sometimes other stuff too; In addition I find <* useful in writing and <*> useful in reading; while >> is useful in all IO stuff, and >>= is also useful in all IO stuff; but >>= and <>>= are hardly ever useful for parsers.)
20:35:42 <russ_> lesson1 step13: map (+1) [1..5] says "Terminated!"
20:35:45 <Sgeo> <>>= ?
20:35:47 <russ_> what up with that?
20:35:49 <zzo38> (For parsers, the useful operators are <*> <* *> <$ <$> anything else is rarely needed)
20:35:57 <ski> > map (+1) [1..5]
20:35:58 <lambdabot>   [2,3,4,5,6]
20:36:06 <tikhonjelvis> :t (<>>=)
20:36:06 <tikhonjelvis> What operator is that?
20:36:07 <lambdabot> Not in scope: `<>>='
20:36:07 <ski> russ_ : seems to work ok, here
20:36:10 <zzo38> Sgeo: See above; I defined <>>= above
20:36:13 <russ_> hm, weird
20:36:14 <tikhonjelvis> oh
20:36:24 <tikhonjelvis> Umm, could you repeat your definition? I missed it.
20:36:29 <ski> russ_ : it might be the server on which you run that was temporarily over-worked, try again ?
20:36:37 <russ_> > map (+1) [1..5]
20:36:38 <lambdabot>   [2,3,4,5,6]
20:36:39 <zzo38> (<>>=) :: (Functor m, Monad m) => m a -> (a -> m b) -> m a; x <>>= f = x >>= ap (<$) f; infixl 1 <>>=;
20:36:41 <russ_> cool
20:36:58 <tikhonjelvis> thanks
20:37:05 <ski> russ_ : i mean, try it in the place you originally did (and got the error) ? :)
20:37:46 <russ_> yeah i still get the error
20:37:58 <russ_> none of the map commands in the tutorial are working for me
20:39:31 <Sgeo> @src (<*)
20:39:31 <lambdabot> (<*) = liftA2 const
20:39:36 <Sgeo> @src (<$)
20:39:36 <lambdabot> (<$) = (<$>) . const
20:39:55 <Sgeo> :t (<$)
20:39:56 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:40:21 <ski> @let infixl 1 <>>=; (<>>=) :: Monad m => m a -> (a -> m b) -> m a; ma <>>= amb = ma >>= liftM2 liftM const amb
20:40:22 <lambdabot>  Defined.
20:40:26 <zzo38> Probably the type signature for <>>= can explain its purpose a little bit
20:40:39 <ski> preflex: xseen chrisdone
20:40:39 <preflex>  chrisdone was last seen on freenode/#haskell 1 day, 17 hours, 26 minutes and 2 seconds ago, saying: dzhus: sounds like you're trying to parse it into the wrong type?
20:40:59 <ski> russ_ : hm, strange .. i suppose something is up with that server
20:41:31 <russ_> i just skipped that step, thanks tho
20:41:33 <ski> russ_ : how about `map not []', also aborts ?
20:41:48 <russ_> that one worked
20:42:10 <russ_> oh, now the other commands work too
20:42:22 <russ_> cool
20:51:59 <zzing> I was wondering how a certain problem would be handled in a 'functional' fashion. I have an array of bytes representing a BGR image. I must convert it to an ABGR image. So the indices in the original go from i to 4(i/3)+(i%3)+1. This is easy for me to think about in an imperative style.
20:52:41 <tikhonjelvis> Sounds like a map...
20:53:43 <tikhonjelvis> The high level idea is given a toARGB function, you just do 'map toARGB image'.
20:53:58 <cmccann> it would be a simple map if you treated it as an array of RGB values
20:54:06 <cmccann> rather than an array of color component bytes
20:54:25 <tikhonjelvis> Oh, are you using a one dimensional array?
20:54:29 <tikhonjelvis> hmm
20:54:37 <zzing> It is one dimensional yes
20:54:49 <zzing> Actually that might make sense
20:55:05 <tikhonjelvis> Have you heard of repa? It's a nice array library for this sort of thing.
20:55:47 <zzing> I have to deal with 'functional theory' right now ;)
20:55:57 <tikhonjelvis> functional theory?
20:56:11 <zzing> How you would do it in the style rather than specific implementation
20:56:16 <tikhonjelvis> ah
20:56:37 <tikhonjelvis> Well, if you stored it as an array of colors, or something similar, it would be just a map.
20:56:52 <zzing> That would certainly make it easier to reason
20:57:19 <tikhonjelvis> It also makes more sense semantically--right now, you have an array of numbers which mean different things.
20:57:26 <zzing> yes
20:58:38 <zzing> One sample of implementation is a c++ vector. Funny that I know exactly now how I would do it in haskell :-)
21:03:50 <Ralith> zzing: I think the "functional style" here *is* to use a more meaningful datatype
21:04:27 <tkahn6> that feel when you spend 2 hours 'optimizing' code and it performs 2x worse
21:04:49 <tikhonjelvis> and then you change a line and it gets faster again for no discernable reason
21:05:08 <tkahn6> i wish
21:06:20 <tkahn6> in my application, at least the way i've written it, using String is more memory efficent than using Strict ByteString which is more efficient than using Lazy ByteString
21:20:23 <sopvop> o/ hello #haskell.
21:22:47 <nyingen> @quote
21:22:47 <lambdabot> Dzlk says: you can make the Id monad somewhat better behaved by wrapping it in SuperegoT.
21:27:37 <Adrian_GG> im a bit confused here can someone help me out with how can i implement the insertation of a binary search tree from this point ? http://pastebin.com/VvGvicpy
21:27:39 <mauke> The paste VvGvicpy has been copied to http://hpaste.org/57218
21:28:29 <Adrian_GG> I do not know how to approach this
21:34:13 <rexim> http://hpaste.org/57219 ?
21:37:21 <Adrian_GG> http://pastebin.com/VvGvicpy
21:37:21 <mauke> The paste VvGvicpy has been copied to http://hpaste.org/57218
21:38:08 <tikhonjelvis> Adrian_GG: I think it would be easiest if you just used hpaste directly. It even offers to announce your paste on the channel.
21:38:12 <copumpkin> :t on
21:38:13 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:38:31 <Adrian_GG> what is hpaste
21:38:39 <Adrian_GG> just paste directly into the channel?
21:38:40 <tikhonjelvis> hpaste.org
21:38:43 <Adrian_GG> ok
21:38:50 <tikhonjelvis> It's a pastebin-like site for Haskell in Haskell
21:38:52 <CodeWeaver> Have you implemented a binary search tree before in another language?
21:39:17 <Adrian_GG> http://hpaste.org/57220
21:39:20 <Adrian_GG> yes
21:39:23 <Adrian_GG> in java
21:39:25 <Adrian_GG> and c
21:39:26 <Adrian_GG> i think
21:39:29 <Adrian_GG> I understand
21:39:37 <Adrian_GG> what a binary search tree is supposed to do
21:39:50 <Adrian_GG> but I have troubles understanding how to implement it in haskell
21:39:59 <Adrian_GG> only with the data type as specified
21:40:09 <CodeWeaver> There isn't a lot different.  The only thing is, in Java and C you are probably used to being able to set the left or right child at a particular node explictly (mutating the node).
21:40:25 <CodeWeaver> You usually do this to add a new 'leaf', when you're adding a new piece of data.
21:40:36 <CodeWeaver> Yeah?
21:40:36 <ski>   insertTree bst0 n bst1 = ...  -- should be the basic shape to start from
21:41:10 <Adrian_GG> yes as you see i have this insertTree BST a BST
21:41:25 <ski> er, actually
21:41:27 <Adrian_GG> but I do not know how to compare the value of the leafs
21:41:32 <ski>   insertTree bst n = ...  -- should be the basic shape to start from
21:41:54 <ski> one `BST' and one `Int' as input, and the output should be a `BST'
21:41:55 <Adrian_GG> ok then I have to use foldr and use reverse on the list
21:42:01 <CodeWeaver> The problem is in haskell you're not allowed to mutate data generally speaking.  So when you go and alter one of the low down leaves to have a new child, you have to alter the nodes all the way back to the root as the recursion unwinds.  Key difference.
21:42:13 <ski> but then `bst' here could either be `Leaf' or `Node n leftBst rightBst', so you will get two cases here
21:42:41 <ski>   insertTree  Leaf                     n0 = ...
21:42:41 <ski>   insertTree (Node n leftBst rightBst) n0 = ...
21:42:49 <CodeWeaver> Yah.  Indeed.
21:42:54 <ski> then you'll have to fill in the `...' in the two cases
21:43:16 <ski> Adrian_GG : does that make sense ?
21:43:21 <Adrian_GG> so I can do this using foldl
21:43:24 <Adrian_GG> right?
21:43:33 <ski> no, `foldl' works on lists
21:43:44 <Adrian_GG> my input will be a list
21:43:48 <Adrian_GG> and i have to generate from it
21:43:50 <Adrian_GG> a BST
21:43:53 <ski> you can use `foldl' with `insertTree' to define `buildBST'
21:43:55 <CodeWeaver> Well, buildBST can fold a list into the BST sure.
21:44:04 <ski> but `insertTree' will not be done using `foldl'
21:44:15 <Adrian_GG> mhhmmm
21:44:35 <ski> you would probably do `insertTree' something along the lines i sketched above
21:45:00 <ski> i.e. two cases : (a) inserting into empty tree ; (b) inserting into non-empty tree
21:45:09 <Adrian_GG> i was trying to make the foldl call the inserTree function for every element in the list and insertTree would be responsible for adding the corresponding nodes/ leafs
21:45:41 <rexim> http://hpaste.org/57221
21:46:22 <CodeWeaver> Ayup.
21:46:23 <Adrian_GG> how are you guys so good with this stuff ? r u guys working for haskell??
21:46:34 <CodeWeaver> Uh, me, just learning on my own.
21:46:42 <tikhonjelvis> haskell isn't really a company
21:46:57 <CodeWeaver> But I've been writing in various languages for a long time.  This is pretty new to me too
21:47:01 <companion_cube> Adrian_GG: people who succeed in reading this chan for a while without turning mad become goood
21:47:16 <tikhonjelvis> That said, it is basically a Microsoft product.
21:47:19 <tikhonjelvis> sort of
21:47:49 <Adrian_GG> does it help in the industry
21:47:51 <Adrian_GG> to know
21:47:53 <Adrian_GG> haskell?
21:48:02 <tikhonjelvis> I found an internship doing Haskell :) Does that count?
21:48:05 <CodeWeaver> Probably helps you to have a better mental toolkit at least.
21:48:22 <Adrian_GG> :))
21:48:25 <CodeWeaver> Haskell jobs are probably not plentiful on their own.
21:48:31 <CodeWeaver> Though apparently they exist.
21:48:38 <Adrian_GG> I am trying to get an intership this summer to but more into information security related fields
21:48:38 <nyingen> soon, world domination.
21:48:53 <tikhonjelvis> Well, Haskell could be used in any field; it's just a language.
21:49:01 <tikhonjelvis> That company I'm talking to is in genomics, of all things.
21:49:03 <CodeWeaver> But building the mental toolkit is very valuable.  Also looks cool to some employers to stretch beyond the obvious languages.
21:49:37 <Adrian_GG> rexim thank you I am trying to understand now what you wrote there
21:49:40 <CodeWeaver> Yes, it *could*, tikhonjelvis, but I haven't seen it hugely prolific in job postings.  Still one can hope.
21:49:53 <tikhonjelvis> Eh, I haven't seen any job postings that aren't a year old either.
21:50:25 <ski> (tikhonjelvis : Haskell /= GHC, and even GHC isn't an MS product)
21:50:51 <tikhonjelvis> well, perhaps not a product, but that's the closest to a "haskell company".
21:51:23 * ski thinks Galois is a Haskell company
21:52:19 <tikhonjelvis> Do they just use Haskell, or do they actually work on the language itself?
21:53:06 * cmccann thinks active participation from a company itself is more significant than who signs SPJ's paycheck
21:55:18 <Adrian_GG> do you guys know
21:55:20 <Adrian_GG> a script
21:55:23 <Adrian_GG> that highlights
21:55:27 <Adrian_GG> code for mirc
21:55:47 <tikhonjelvis> Just use Emacs :)
21:56:02 <companion_cube> Idon't think many people here use mIRC
21:56:08 <Adrian_GG> I am using notepad++ at the moment, I never liked Emacs
21:56:30 <Adrian_GG> ohh I am on Windows .. i know..shame on myself
21:56:58 <tikhonjelvis> Emacs works on Windows. Don't know about its irc client though.
21:57:05 <CodeWeaver> notepad++ is pretty good for coding.
21:57:20 <ski> (there are several. at least erc and circe)
21:57:44 <tikhonjelvis> Is circe any good? I've only used erc.
21:58:08 * ski has not used either of them
21:58:44 <ski> (bah, 509 on <http://www.silverex.org/download/>)
21:58:57 * ski was going to suggest that to Adrian_GG .. :(
21:59:06 <tikhonjelvis> suggest what?
21:59:14 <ski> that link
21:59:29 <ski> (it's X-Chat 2 for Windows)
21:59:47 <tikhonjelvis> ah
21:59:50 <tikhonjelvis> never heard of it
22:00:58 <ski> (for some strange reason, <http://xchat.org/windows/> requires registration, so i tend not to point to that)
22:07:29 <Adrian_GG> I would like to explain my understanding of the BST functionality provided remix can I do it on the channel here or would anyone be ok if I would explain it in private?
22:08:56 <Adrian_GG> I do not know the rules of this channel yet
22:09:32 <tikhonjelvis> Umm, I don't think anybody will mind since nobody is talking anyhow. On the other hand, nobody might respond.
22:10:01 <Adrian_GG> okay
22:11:23 <Adrian_GG> 1. we have call our buildBST function with the integer list [3,4,2,5]
22:13:44 <Adrian_GG> 2. the buildBST calls through foldl the insertTree function with Leaf and 3
22:15:03 <Adrian_GG> 3. insertTree has now inputs Leaf and 3, and it executes insertTree (Leaf) x = Node x Leaf Leaf, creating a Node with the integer 3 and 2 additional leafs
22:15:47 <mauke> :t Tree
22:15:48 <lambdabot> Not in scope: data constructor `Tree'
22:15:52 <mauke> :t Node
22:15:53 <lambdabot> forall a. a -> Forest a -> Tree a
22:16:11 <Adrian_GG> 4. the buildBST calls thrhough foldl the insertTree function now with Leaf and 4
22:16:27 <mauke> I haven't seen your code but that seems unlikely
22:16:36 <Adrian_GG> :(
22:16:47 <Adrian_GG> " <rexim> http://hpaste.org/57221 "
22:17:15 <Adrian_GG> I am trying to understand the trace of that program
22:17:22 <tikhonjelvis> The fold keeps building up the tree as it goes along.
22:17:46 <mauke> next step is insertTree (Node 3 Leaf Leaf) 4
22:17:52 <ski> Adrian_GG : 1-3 sounds ok, 4. not
22:18:07 <tikhonjelvis> Have you ever used fold before?
22:18:13 <Adrian_GG> no
22:18:18 <tikhonjelvis> ah
22:18:19 <Adrian_GG> I never used haskell before
22:18:27 <tikhonjelvis> Fold comes up in other languages
22:18:28 <Adrian_GG> I am trying to understand haskell and learn it
22:18:35 <tikhonjelvis> it's also called accumulate or reduce
22:18:46 <Adrian_GG> I have experience in Java c, c++, php
22:18:58 <Adrian_GG> and never had to deal with a function similar with fold
22:19:00 <tikhonjelvis> right
22:19:24 <tikhonjelvis> :t foldl
22:19:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:19:51 <tikhonjelvis> foldl (+) 0 [1,2,3,4] is basically 0 + 1 + 2 + 3 + 4
22:19:54 <tikhonjelvis> does that make sense?
22:19:56 <Adrian_GG> yes
22:20:00 <ski>      buildBST [3,4,2,5]
22:20:04 <ski>   =  foldl insertTree Leaf [3,4,2,5]
22:20:08 <ski>   =  foldl insertTree (insertTree Leaf 3) [4,2,5]
22:20:13 <ski>   =  foldl insertTree (Node 3 Leaf Leaf) [4,2,5]
22:20:14 <ski>   =  foldl insertTree (insertTree (Node 3 Leaf Leaf) 4) [2,5]
22:20:39 <ski> Adrian_GG : that's the first few steps of how you could conceptually think about how your initial call will reduce
22:21:10 <mauke> > let insertTree Nothing x = Just (Node x [Nothing, Nothing]); insertTree (Just (Node value [left, right])) x | x <= value = Just (Node value (insertTree left x) right) | otherwise = Just (Node value left (insertTree right x)) in ()
22:21:10 <ski> so, note that in step 4, `insertTree' gets passed `4', and the tree `Node 3 Leaf Leaf', *not* the tree `Leaf' as you said above
22:21:11 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
22:21:11 <lambdabot>         against inferred ty...
22:21:34 <Adrian_GG> ohhh ok
22:21:37 <Adrian_GG> i think i got it
22:21:52 <tikhonjelvis> I think the most intuitive name for fold would be accumulate
22:21:56 <mzero> Adrian_GG: I like to think of foldl as taking a value, and marching down the list, transforming it at each step via the function
22:22:10 <mzero> else step down the list gets the result of the prior operation
22:22:33 <mzero> ^else^each
22:22:42 <ski> in the next step, `insertTree' needs to decide whether `x <= value' or `x > value' is `True', i.e. in this case, whether `4 <= 3' or `4 > 3' is `True'
22:23:02 <ski> in this case, it's the latter, so the latter branch is selected, so the next step then becomes
22:23:20 <mzero> (foldr can be thought of the same, marching from the back of the list to the front.... only, bizarrely, it isn't nearly as inefficient as it sounds!!!!!)
22:23:33 <mauke> zomg!!!!!!!!!
22:23:38 <ski>   =  foldl insertTree (Node 3 Leaf (insertTree Leaf 4)) [2,5]
22:23:47 <ski>   =  foldl insertTree (Node 3 Leaf (Node 4 Leaf Leaf)) [2,5]
22:23:58 <ski>   =  foldl insertTree (insert (Node 3 Leaf (Node 4 Leaf Leaf)) 2) [5]
22:24:05 <mzero> (okay, so maybe I was a little heavy on the exclamation point key...)
22:24:18 <ski> now `2' is less than `3', so the former branch is selected
22:24:47 <ski>   =  foldl insertTree (Node 3 (insertTree Leaf 2) (Node 4 Leaf Leaf)) [5]
22:25:02 <ski>   =  foldl insertTree (Node 3 (Node 2 Leaf Leaf) (Node 4 Leaf Leaf)) [5]
22:25:06 <Adrian_GG> ok i will print these up and read them
22:25:13 <ski>   =  foldl insertTree (insertTree (Node 3 (Node 2 Leaf Leaf) (Node 4 Leaf Leaf)) 5) []
22:25:18 <tikhonjelvis> heh, too much information from too many directions all at once?
22:25:31 <ski>   =  foldl insertTree (Node 3 (Node 2 Leaf Leaf) (insertTree (Node 4 Leaf Leaf) 5)) []
22:25:46 <ski>   =  foldl insertTree (Node 3 (Node 2 Leaf Leaf) (Node 4 Leaf (insertTree Leaf 5))) []
22:25:49 <Adrian_GG> no, but this is a really interesting concept that I have never come across in programming and I would like to understand it really good
22:25:54 <ski>   =  foldl insertTree (Node 3 (Node 2 Leaf Leaf) (Node 4 Leaf (Node 5 Leaf Leaf))) []
22:26:00 <ski>   =  Node 3 (Node 2 Leaf Leaf) (Node 4 Leaf (Node 5 Leaf Leaf))
22:26:04 <ski> and that's the end of it
22:26:38 <Adrian_GG> thank you ski :) If I ever become a guru at this I will try to help you too if you are in need
22:26:48 * ski smiles
22:27:58 <ski> @src foldl
22:27:58 <lambdabot> foldl f z []     = z
22:27:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:28:07 <ski> Adrian_GG : i might also help knowing that ^
22:28:13 <ski> s/i /it /
22:28:42 <ski> > foldl f z [a,b,c,d]
22:28:43 <lambdabot>   f (f (f (f z a) b) c) d
22:28:47 <ski> > foldl (+) z [a,b,c,d]
22:28:48 <lambdabot>   z + a + b + c + d
22:28:58 <ski> > foldr f z [a,b,c,d]
22:28:59 <lambdabot>   f a (f b (f c (f d z)))
22:29:03 <ski> > foldr (+) z [a,b,c,d]
22:29:04 <lambdabot>   a + (b + (c + (d + z)))
22:31:35 <tkahn6> what's the best cross-platform way to implement the sizeOf method for the Storable type class?
22:32:23 <tkahn6> the sizeOf a CInt is architecture dependent
22:34:48 * hackagebot llrbtree 0.1.1 - Purely functional sets and heaps  http://hackage.haskell.org/package/llrbtree-0.1.1 (KazuYamamoto)
22:35:18 <nexion> hey guys, how can I resolve "orphan instance" warnings? I've declared a Show for TVar so that I could display records containing TVars, but I get a warning about it
22:35:22 <nexion> instance Show (TVar a) where
22:35:22 <nexion>   show _ = "TVar"
22:36:33 <nexion> I recall reading somewhere that the warning can be ignored, but I'm trying to keep it free of all warnings with -Wall
22:37:49 * ski supposes one resolves it by moving the instance declaration into the module defining the type `TVar'
22:38:46 <nexion> yeah, I suspect so
22:40:18 <nexion> I might have to resort to -fno-warn-orphans
22:50:48 <ski> nexion : you could specify it only for that module, using `{-# OPTIONS_GHC -fno-warn-orphans #-}', i think
22:56:06 <Adrian_GG> im thinking now of a nice way to print the tree
22:56:56 <tikhonjelvis> That's good.
22:57:39 <Adrian_GG> :D
22:59:30 <Ngevd> Hello!
22:59:51 <Ngevd> In my repeated attemptes to install gtk2hs, I've messed up the PATH variable on Windows...
23:06:16 <Ngevd> What should it be for Cabal to work?
23:09:52 <CodeWeaver> well, you'll need to add to the path the folder in which the cabal executable lives at least.
23:10:40 <Ngevd> Can you give me a package that should install so I can test?
23:11:18 <CodeWeaver> sure.  try sequence
23:11:50 <CodeWeaver> also the bin folder cabal itself write compiled executables to
23:12:34 <CodeWeaver> if you use cabal to install happy for example, that builds a utility app
23:13:20 <ski> Adrian_GG : as long as you don't name your pretty-printer `show', it's fine :)
23:13:46 <Adrian_GG> what what
23:14:10 <Adrian_GG> man this concept of foldl i understand it now thank you, but I cannot conceptualize it really good
23:14:13 <ski> Adrian_GG : if you haven't been thinking about doing that, just ignore that comment ;)
23:14:26 <Adrian_GG> i need practice
23:15:16 <tikhonjelvis> Adrian_GG: Have you been reading some Haskell books?
23:15:34 <ski> Adrian_GG : you might find Cale's <http://cale.yi.org/share/Folds.svg> useful
23:16:14 <CodeWeaver> also http://learnyouahaskell.com/
23:16:26 <Adrian_GG> i feel like I understand it, I even practiced by writing on a paper what ski said about the behaviour of that algorithm but I feel theres no way I could create myself a function that does all that stuff, its weird im in 4th year Computer Science and this is sooooo crazy for me
23:16:34 <ski> Adrian_GG : you should also practice on `foldr'
23:16:41 <CodeWeaver> also http://www.realworldhaskell.org/blog/
23:16:51 <tikhonjelvis> Adrian_GG: Ooh, this isn't Haskell related, but you should read SICP
23:17:01 <ski> Adrian_GG : with some practice, all this is going to get easier
23:17:27 <ski> (btw, the mind bending that you might experience is good for you)
23:17:28 <Adrian_GG> ok can you please give me an algorithm to create right now? :)
23:17:45 <ski> Adrian_GG : write `reverse', using `foldl'
23:18:01 <Adrian_GG> reverse of a list
23:18:04 <Adrian_GG> ok
23:18:05 <CodeWeaver> nice
23:18:16 <ski> write `and',`or' using `foldr' (or `foldl')
23:18:36 <Adrian_GG> i will do the reverse
23:18:38 <Adrian_GG> of a list
23:18:39 <ski> write `maximum',`minimum',`sum',`product', using `foldr1' (or `foldl1')
23:19:14 <Adrian_GG> guys are u usually on this channel?
23:19:25 <tikhonjelvis> somewhat
23:19:33 <ski> write a function that translates a list of digits `[1,4,2]' to a number `142', using `foldl'
23:19:34 <tikhonjelvis> there's almost always *somebody* here
23:19:37 <CodeWeaver> Writ foldl using foldr.  (no don't, it's heinous ;))
23:19:52 <ski> write `map' and `filter' using `foldr'
23:20:01 <tikhonjelvis> heh, I was about to suggest map...
23:20:03 <CodeWeaver> yah, i just started coming here.
23:20:17 <ski> CodeWeaver : write `zipWith' using `foldr' only for matching on lists and recursion
23:20:18 <Adrian_GG> ok I think I'll start coming here too
23:20:23 <CodeWeaver> good people.  i want to learn more from 'em.
23:20:39 <CodeWeaver> ski owwowwoww
23:20:47 <tikhonjelvis> If you're going to be reimplementing every single list function using fold, you may as well write foldl yourself first.
23:20:51 <CodeWeaver> *boots ghci*
23:21:02 <ski> CodeWeaver : note that that one is a lot harder than the others above (including the `foldl' in terms of `foldr', i think)
23:21:17 <ddarius> ski: uncons
23:21:19 <CodeWeaver> will ponder
23:21:24 <Adrian_GG> ski did u practice most of these?
23:21:41 <qqMuppetpp> meh. write something you care about instead of reimplementing the standard library ;)
23:21:58 <tikhonjelvis> No, writing the standard functions is a really good way of getting the basic idea.
23:21:58 <ski> ddarius : yeah, that's considered cheating :)
23:22:12 <ddarius> ski: I'm saying implement uncons with foldr.=
23:22:21 <ski> there should be at most one `foldr' call for each list (including tails of that list)
23:22:34 <ski> ddarius : yeah, i know you meant that :)
23:22:46 <ddarius> "Exercise: Write your MMORPG as a fold."
23:22:56 <ski> Adrian_GG : well, i pondered some of them, at least
23:23:02 <CodeWeaver> "…foldr only for matching on lists and recursion?  "  i think i get the restriction
23:23:31 <Adrian_GG> ok I will practice them thank you
23:24:01 <ski> CodeWeaver : yeah, the point is, you can't do explicit recursion, you can't call any other recursive function on lists, and you can't use `uncons' or something similar, defined by `foldr'
23:24:33 <tikhonjelvis> I read uncons as unicorns first. It didn't make any sense.
23:24:33 <ddarius> ski: You still misunderstood what I said.
23:24:42 <ski> oh ?
23:25:39 <CodeWeaver> uncons?  never used it.  ok, zipWith using foldr,
23:25:47 <ddarius> Implementing uncons with foldr is one of the harder "implement this function as a foldr" exercises.
23:26:11 <ski> ahh, ok
23:26:16 <ddarius> (Unless you are friendly with Lambek's lemma.)
23:26:28 * ski hasn't heard that term before
23:26:57 <shachaf> unconsWithFoldr = uncons . foldr (:) []
23:27:01 <shachaf> What's uncons?
23:27:44 <Ngevd> Presumably the inverse of cons
23:27:56 <shachaf> uncons :: [a] -> Maybe (a,[a])?
23:28:02 <ddarius> @hoogle uncons
23:28:03 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
23:28:03 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
23:28:03 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
23:31:47 * ski didn't find it very hard to implement `uncons'
23:31:56 <shachaf> Are you supposed to do it without using any [] constructors directly?
23:32:25 <ski> well, you're not allowed to *match* explicitly on them
23:32:40 <shachaf> But you're allowed to call them?
23:32:44 <ski> i'm not sure whether ddarius wanted to disallow *calling* them
23:32:57 <ski> (i did that, anyway)
23:33:00 <shachaf> > let cons Nothing = []; cons (Just (x,xs)) = x : xs; uncons = foldr (\x xs -> Just (x,cons xs)) Nothing in uncons [1,2,3]
23:33:01 <lambdabot>   Just (1,[2,3])
23:33:58 <Adrian_GG> will deletion of a node be more complicated than the fold concept of a BST in haskell?
23:34:05 <ski> > (snd . foldr (\a (as,_) -> (a:as,Just (a,as))) ([],Nothing)) "abcd"  -- fwiw
23:34:07 <lambdabot>   Just ('a',"bcd")
23:34:47 <ski> Adrian_GG : i don't think deletion of a node is related to `foldl' or `foldr' at all
23:35:03 <Sgeo> Foldables allow foldr, right?
23:35:10 <Sgeo> :t Foldable.foldr
23:35:11 <lambdabot> Couldn't find qualified module.
23:35:13 <Sgeo> :t Data.Foldable.foldr
23:35:14 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
23:35:15 <tikhonjelvis> ski: Adrian_GG was operating on binary search trees earlier.
23:35:23 <ddarius> Sgeo: Foldable just means you have a toList function.
23:35:24 <ski> deletion of a node in a binary search tree is comparable to your `insertTree', i think
23:35:29 <ski> (tikhonjelvis : i know)
23:35:31 <CodeWeaver> deletion is harder than insertion like it is in imperative languages — preserving the ordering.
23:35:31 <tikhonjelvis> ah
23:36:03 <Sgeo> ddarius, blah, I was just about to note how it would be easy to get a list out of any foldable
23:36:09 <CodeWeaver> but the rebuild-on-the-way-back-up is basically similar.
23:36:22 <Sgeo> But now... are lists traversable?
23:36:31 <Sgeo> And if so, why are not all foldables traversables?
23:36:40 <ski> @hoogle toList :: [a] -> [a]
23:36:42 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
23:37:21 <ddarius> Sgeo: Foldable gives you know way at all to build back up the "Foldable" data type.
23:37:43 <Adrian_GG> :)
23:38:18 <ski> @type Data.Traversable.traverse
23:38:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:38:20 <ski> @type Data.Traversable.traverse :: (a -> Maybe b) -> (Tree a -> Maybe (Tree b))
23:38:20 <lambdabot> forall a b. (a -> Maybe b) -> Tree a -> Maybe (Tree b)
23:38:31 <Sgeo> Should the prelude use Foldable and Traversable functions rhather than the list specific functions?
23:38:31 <ddarius> :t Data.Traversable.sequence
23:38:32 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
23:38:51 <ddarius> It wouldn't really make much of a difference.
23:39:12 * ski isn't sure what `Foldable' is good for
23:39:26 <ddarius> Also note that by making a Foldable instance you are arbitrarily distinguishing one "flattening" of the data structure.
23:40:10 <ddarius> ski: Mainly to do some manual deforestation and superficial generalization.
23:40:28 <Sgeo> superficial?
23:40:31 <ddarius> ski: But I, for the most part, have the same perspective.
23:41:24 <ski> (ddarius : yeah, i was sortof suspecting that)
23:41:40 <Sgeo> manual deforestation
23:41:41 <Sgeo> ?
23:41:46 <Sgeo> Also, I really should sleep now
23:42:47 <shachaf> > let cons = unfoldr (maybe Nothing (Just . second uncons)); uncons = foldr (curry (Just . second cons)) Nothing in (uncons "abc", cons (Just ('a',"bc")))
23:42:48 <lambdabot>   (Just ('a',"bc"),"abc")
23:43:55 <shachaf> If only foldr was defined in a way dual to unfoldr.
23:44:07 <Sgeo> :t unfoldr
23:44:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:44:20 <shachaf> foldr :: (Maybe (a,b) -> b) -> [a] -> b
23:44:47 * Sgeo raises an eyebrow
23:45:14 <ddarius> :t \alg ->  foldr (uncurry $ alg . Just) (alg Nothing)
23:45:14 <Sgeo> ...Oh, I get it
23:45:15 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b -> b
23:45:15 <lambdabot>     Probable cause: `alg' is applied to too few arguments
23:45:15 <lambdabot>     In the second argument of `foldr', namely `(alg Nothing)'
23:45:17 <danr> shachaf: that's a nice way to see it
23:45:32 <danr> what is that called in CT?
23:45:45 <danr> are that the cata and anamorphisms?
23:45:47 <ddarius> :t \alg ->  foldr (curry $ alg . Just) (alg Nothing)
23:45:48 <lambdabot> forall a c. (Maybe (a, c) -> c) -> [a] -> c
23:47:37 <ski> danr : `foldr' is the catamorphism for the type of finite lists. `unfoldr' is the anamorphism for the type of possibly (in)finite streams
23:48:25 <ddarius> "Catamorphism" and "anamorphism" are not the words most categorists would use to describe these.  Most wouldn't even recognize those words.
23:48:57 <danr> ski: and how is this related to (F)-algebras?
23:49:39 <danr> ddarius: aha. so where is the terminology from? the banana and barbed wire paper?
23:50:05 <ddarius> danr: The Squiggolists.
23:51:02 <danr> ddarius: thanks!
23:51:25 <ddarius> danr: Just so you know, this information isn't really useful.
23:51:54 <danr> ddarius: maybe it is useful for me?
23:53:52 <ski> danr : well, the catamorphism is the unique morphism from the initial `F'-algebra, and the anamorphism is the unique morphism to the terminal/final `F'-coalgebra
23:54:14 <nexion> is there a library for escaping/sanitizing HTML? I'm looking for something to run on input from a user which can then be sent to another user to be written into the DOM as a chat message/comment
23:55:25 <ski> danr : maybe you'd like looking at "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs,Jan Rutten 1997 in at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> ?
23:56:28 <danr> ski: wow thanks! and it isn't even my birthday today!
23:56:57 <ski> have fun !
23:57:02 <danr> ^^
23:59:06 <Blkt> good morning everyone
