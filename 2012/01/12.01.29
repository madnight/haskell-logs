00:00:09 <EvanR> 02:52 < ddarius> dolio: Skip lists.
00:00:29 <elliott> Noooo! My assertion crumbles under the stone cold weight of EVIDENCE!!!
00:00:39 <elliott> I didn't sign up for this universe :(
00:00:44 <ddarius> That wasn't a suggestion for EvanR, it was a suggestion for dolio.
00:00:56 * Sgeo wonders if Mnesia is usable from Haskell
00:01:01 <mrotondo> saved on a technicality
00:01:18 <ddarius> Sgeo: There's something that talks Erlang that, I imagine, could be used to talk to Mnesia.
00:01:29 <Sgeo> ddarius, Foreign.Erlang sucks.
00:01:31 <Sgeo> :/
00:01:37 <elliott> ddarius: You must have missed Sgeo complaining about that library!
00:01:47 <Oxryly> don't drive your car into the wall made of brick, drive it into the wall made of wood so you'll do less damage!
00:01:51 <EvanR> elliott: back to the graph, how do you mutate a graph
00:02:14 <ddarius> That may (or may not) be the library to which I was referring.  At any rate, I do not care.  I don't use Erlang.
00:02:28 <Oxryly> what's the specific graph data structure?
00:02:34 <EvanR> Data.Graph
00:02:35 <Sgeo> Are there any libraries that don't suck? ftphs sucks, Foreign.Erlang sucks, the Prelude sucks..
00:02:45 <elliott> EvanR: Why do you want to mutate it?
00:02:57 <Oxryly> oh. figures.
00:03:20 <elliott> Also, I'm not convinced Data.Graph is suitable.
00:03:31 <EvanR> elliott: because theres a command which moves thing from room to room
00:03:59 <elliott> EvanR: Since you're not using concurrency, there's no reason not to simply transform the graph.
00:04:05 <mrotondo> EvanR: I think you should watch a video of rich hickey talking about state & identity
00:04:09 <EvanR> thats what i asked o_O
00:04:24 <mrotondo> it'll change your life :D
00:04:40 <elliott> I assumed you meant mutate as in actually mutate.
00:04:45 <EvanR> mrotondo: not sure i need to do that
00:04:58 <Oxryly> what's the motivation for the explicit graph structure rather than rooms containing exits?
00:05:00 <EvanR> elliott: as in foo { bar = baz }
00:05:01 <elliott> Anyway, Data.Graph is kidn of limited, I understand.
00:05:04 <elliott> And I expect you want labelled edges.
00:05:07 <ddarius> If the graph representation is an adjacency structure, you're fucked.  If it's a "Map" from vertices to vertex data, then you just update the Map.
00:05:07 <elliott> To name exits.
00:05:19 <EvanR> Oxryly: at this point, nothing but dignity
00:05:25 <elliott> http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/Data-Graph.html#g:2
00:05:35 <elliott> Oxryly: That would lead to circular structures.
00:05:41 <elliott> Which are a pain to update.
00:05:45 <elliott> And even more painful to serialise.
00:05:53 <Oxryly> seems overkill, overly restrictive. the graph structure doesn
00:06:01 <Oxryly> doesn't appear to need to be explicit
00:06:05 <ddarius> If this was all in a relational database, there'd be no need to serialize anything.
00:06:08 <elliott> The alternative was using int references.
00:06:15 <elliott> Which is making the graph a lot more explicit than this is.
00:06:16 <EvanR> ddarius: yes but a Map is what i came in here with first, im talking about a true graph
00:06:21 <elliott> (But I still don't suggest Data.Graph.)
00:06:24 <elliott> EvanR: What's a true graph?
00:06:29 <ddarius> EvanR: There's nothing not "true" about that representation.
00:06:35 <EvanR> a structure from a library i dont have to program myself
00:06:41 <elliott> Anyway, a relational model might fit better than this, I agree.
00:06:55 <mrotondo> yeah, again, you care about the transitions between the nodes a lot
00:07:00 <mrotondo> they might not even be symmetric always
00:07:08 <mrotondo> so you'll need a very custom graph structure if you use one
00:07:15 <EvanR> mrotondo: well as i see it, they are always one way
00:07:16 <mrotondo> they'll be labelled differently both ways etc
00:07:19 <Oxryly> EvanR: i don't think you need to program any actual graph algorithms to get going....
00:07:31 <mrotondo> okay, so that's good
00:07:37 <mrotondo> that simplifies things
00:07:38 <EvanR> they are talking about serializing lol
00:07:55 <elliott> EvanR: Always one way?
00:07:59 <Oxryly> EvanR: if all moves are one step or jumps, there's no need for Graph Theory here
00:08:02 <elliott> So you can never, e.g. step through a door, and then step back through it?
00:08:12 <dzhus> How to perform action inside a monad conditionally? Like if cond then doStuff
00:08:14 <EvanR> you can step through a door and take the corresponding other exit back
00:08:19 <EvanR> dzhus: when
00:08:20 <elliott> dzhus: if cond then doStuff else doOtherStuff
00:08:30 <elliott> dzhus: If doOtherStuff = return (), then you can use: when cond doStuff
00:08:41 <mrotondo> looks like graph can give you a topologically sorted list of your graph nodes
00:08:42 <Oxryly> this is a directed implicit graph
00:08:45 <mrotondo> data.graph that is
00:08:50 <ddarius> Incidentally, Data.Graph is just a "Map" of vertices (labelled by Ints) to vertex data, and basically all it provides is some basic standard graph algorithms on that representation.
00:08:51 <dzhus> EvanR: elliott thank you
00:09:04 <mrotondo> elliott: there can be back-connections
00:09:13 <elliott> ddarius: Er?
00:09:15 <mrotondo> cycles
00:09:16 <elliott> http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/Data-Graph.html#g:2
00:09:19 <elliott> It's adjacency-list based.
00:09:31 <Oxryly> cycles, exactly. this is not a DAG
00:09:45 <EvanR> directed cyclic graph
00:09:54 <elliott> Right.
00:09:58 <kallisti> ...I would say that thinking about it in terms of graphs is probably not useful.
00:10:02 <EvanR> well as i see it theres no point to using any graph anything, besides calling it a graph after its done
00:10:04 <Oxryly> you won't need any actual graph traversals or searches of any kind... just list exits in rooms and be done with it.
00:10:05 <elliott> kallisti: As opposed to?
00:10:21 <elliott> Oxryly: List exists in what format?
00:10:25 <elliott> *exits
00:10:32 <kallisti> basically what Oxryly said
00:10:33 <EvanR> thats auxilliary data
00:10:49 <mrotondo> i dunno
00:10:56 <EvanR> relational is looking better and better
00:10:58 <kallisti> Map Exit Room
00:11:05 <kallisti> that's pretty much all you need for that.
00:11:11 <Oxryly> elliott: good question. references to globally unique room/container instances
00:11:12 <mrotondo> the graph seems to model the concept so well. think about implementing enemy AI
00:11:30 <elliott> Oxryly: OK, so directly include the structure in the list of exits?
00:11:32 <EvanR> enemies are generally idiotic in muds
00:11:34 <elliott> That's a cyclic structure.
00:11:34 <mrotondo> you could say "if any player is reachable within a 3-depth search from enemy position, chase him"
00:11:37 <mrotondo> oh come on
00:11:40 <mrotondo> what a cop out!
00:11:47 <EvanR> lol
00:11:56 <mrotondo> you have a chance to do cool stuff :)
00:11:59 <elliott> kallisti: That has the same problem.
00:12:04 <ddarius> You could have your cake and eat it too.  Use stigmergy.  It's more "realistic" anyway.
00:12:08 <Oxryly> elliott: no, reference of some sort.  start with a unique long name (string)
00:12:14 <kallisti> unless you're trying to create something state of the art, the basic enemy AI code is "if the person you're fighting moves to a different room, follow them"
00:12:17 <EvanR> elliott: right, you seem to be suggesting various ways to 'include' the data inside of other data, this will eventually lead to cyclic data, which is doabel in haskell but... ;)
00:12:30 <elliott> EvanR: I'm explicitly not suggesting that.
00:12:39 <elliott> Not doing that was the reason I suggested a graph.
00:12:40 <EvanR> you never got that far
00:12:44 <elliott> Oxryly: Right, so we're back around to int refs.
00:12:48 <mrotondo> is the idea here to explicitly make what has been made before?
00:12:58 <mrotondo> that would be so sad
00:12:58 <EvanR> elliott: well you suggested putting the mobs into the graph node data directly
00:13:00 <kallisti> mrotondo: seems to be a simple prototype.
00:13:08 <elliott> EvanR: Yes, I did.
00:13:08 <mrotondo> yeah but prototyping is for trying new ideas
00:13:09 <kallisti> mrotondo: don't worry I'll revolutionize MUDs one day.
00:13:13 <elliott> Which is perfectly reasonable under certain assumptions about mobs.
00:13:37 <Oxryly> elliott: yeah I don't know about int refs, but certainly a container/room instances should just list its exits
00:13:45 <EvanR> in a relational model unique ids will be all over the place (if for no other reason to distinguish uniqueness of records)
00:13:47 <mrotondo> kallisti: lemme know when & i'll come complain about your implementation :)
00:13:50 <EvanR> and thats gonna be ints
00:14:39 <Oxryly> how are your rooms going to be specified? is there a DSL that will need to name the rooms uniquely?
00:14:48 <kallisti> mrotondo: well I was actually planning to make a MMO text based centered on pen and paper RPGs. which actually requires very little in terms of "world simulation", but I may play around with that as well.
00:15:07 <EvanR> Oxryly: whats unique is their unique identifier, and its not the room title
00:15:41 <Oxryly> EvanR: I'm thinking of what I saw looking at TADS3, where you type in the room description and exits etc, and you name it uniquely
00:16:03 <EvanR> that sounds like a bug in their UI
00:16:23 <Oxryly> unless you have some process generating rooms, *someone* will name it for you
00:16:35 <EvanR> naming it != generating a new unique id
00:16:35 <kallisti> unique names are distinctly better than identifiers from the builders perspective because they're easier to remember.
00:16:46 <mrotondo> yeah, you can have both
00:16:58 <kallisti> note that these names are not the ones that are displayed to players. simply a identifier name for the builder to reference
00:17:00 <EvanR> muds generally have a bunch of rooms with the same name
00:17:08 <mrotondo> the editor uses a human-readable name, and the engine generates identifiers when it plugs everything together
00:17:12 <EvanR> ok then thats more auxilliary data
00:17:17 <EvanR> a ui thing for builds
00:17:18 <EvanR> builders
00:17:23 <mrotondo> yes
00:17:28 <EvanR> personal map of aliases for ids
00:17:31 <Oxryly> i just wouldn't want to build/maintain a world where the same room exists in multiple places... there's got to be some other way to do that
00:17:41 <kallisti> EvanR: your choice.
00:17:41 <EvanR> Oxryly: its not the same room
00:17:48 <kallisti> I was suggesting the uniquen name be the identifier.
00:17:51 <kallisti> -n
00:18:01 <mrotondo> lots of "rooms" named "A grassy plain", for example
00:18:17 <EvanR> kallisti: if its for the purpose of a builder remembering something easier, like an alias, its not going to be meaningful or unique
00:18:21 <mrotondo> connected together into a large plain that you can wander about
00:18:26 <EvanR> in the whole words
00:18:27 <EvanR> world
00:18:38 <kallisti> EvanR: it's for the purposes of labelling each room with a unique human-readable name, not aliases for a specific builder.
00:18:38 <Oxryly> the build will name those "grassy plains" according to some grid, and the display name will always be "A grassy plain"
00:19:01 <elliott> What build?
00:19:07 <elliott> That falls apart when you have dynamic scripting.
00:19:07 <mrotondo> On a related note, it's interesting to think about this design choice as it relates to instancing a la most MMOs
00:19:07 <EvanR> kallisti: why should all the similar rooms have globally unique human readable names?
00:19:10 <Oxryly> build => builder
00:19:38 <mrotondo> because they clearly can't refer to a single representation of any space & what it contains, since there are any number of instances of that space running at any time
00:19:39 <EvanR> a boring room, a really boring room, boring room nine
00:19:50 <EvanR> now they arent boring anymore xD
00:19:55 <Oxryly> elliott: it doesn't have to. the builder incorporates it (you can generate uniquely named rooms in your script, I'd imagine)
00:20:15 <mrotondo> (those int keys you were talking about)
00:20:26 <EvanR> this convo is confusing various different 'names'
00:20:39 <kallisti> EvanR: for the same reason you would use integers, except now builders can actually memorize useful names. I suppose it could be a seperate alias that's distinct from the integer ID, but it should still be probably be global.
00:20:45 <Oxryly> grassyPlain01, grassyPlain10, grassyPlain20, grassyPlain21, blah blah
00:21:02 <EvanR> kallisti: if its for builders, let builders have their own personal palette of aliases
00:21:11 <kallisti> sure
00:21:24 <EvanR> just haskell lets you have variable names that are use differently in different programs
00:21:32 <EvanR> just like*
00:21:38 <Oxryly> EvanR: let them have aliases, but make them give you unique names. they have to organize their design anyway
00:22:03 <EvanR> obviously they have to be unique in their alias list or its illogical o_O
00:22:15 <kallisti> I imagine if you useinteger IDs without unique names, then builders will still likely need something that basically searches by other useful names, so that they can find the ID they're looking for. assuming a large enough world.
00:22:22 <Oxryly> EvanR: ok, i suppose I'm not sure they need aliases at all
00:22:39 <EvanR> Oxryly: me neither since MOO and many muds just use the number
00:23:01 <EvanR> a short word alias list would be interesting UI feature
00:23:05 <EvanR> not part of the underlying rep
00:23:21 <Oxryly> If I had to lay out a rough 3x6 grid of grass plains, I'd name them something unique and somewhat useful......
00:23:35 <EvanR> have you ever done this ;)
00:23:48 <Oxryly> not exactly
00:23:55 <EvanR> thats 18 unique and 'useful' 'names'
00:24:13 <EvanR> that ostensibly dont show up in the title
00:24:16 <kallisti> I've worked with other people who were builders and used integer IDs to reference everything. it looked like they had "fun"
00:24:21 <EvanR> pretty wasteful
00:24:34 <Oxryly> again, grass00, grass01, grass02, .... grass10, grass11, ....
00:24:44 <EvanR> o_O
00:25:10 <Oxryly> the player never sees, you don't see it, only them and the occasional admin (same person, right?)
00:25:13 <Ngevd> Hello!
00:25:16 <EvanR> and thats globally unique?
00:25:24 <kallisti> it can be enforced to be, yes.
00:25:28 <EvanR> thats stupid
00:25:31 <Oxryly> no reason not to be
00:25:34 <mrotondo> it doesn't have to be
00:25:39 <mrotondo> that'd be a nice feature
00:25:44 <mrotondo> "naming sessions"
00:26:01 <Oxryly> seems you'd ultimately do them a favor by enforcing it
00:26:01 <EvanR> ... i guarantee you theres more fields somewhere else and someone will be pissed you used the word 'grass' in the prefix
00:26:05 <EvanR> already
00:26:19 <kallisti> Land of Vast Boring Fields: the MUD
00:26:20 <mrotondo> start, and everything you name is referenceable by the name you give it until you end the session
00:26:22 <mrotondo> lol
00:26:25 <Oxryly> maybe... is the other area named.......???
00:26:42 <EvanR> c_style_module_namspacing00
00:26:43 <Oxryly> Endless Field of Grass
00:26:59 <EvanR> now thats useful
00:27:01 <EvanR> -_
00:27:02 <EvanR> -
00:27:15 <Oxryly> c_style_module_namspacing00:grass00   :D
00:27:28 <elliott> If you're going to generate globally unique IDs, just generate a GUID.
00:27:29 <kallisti> the best way I think to simulate large areas of space is to not use the traditional room design
00:27:32 <elliott> That's sort of what they're for.
00:27:49 <kallisti> EvanR: here's an idea. represent locations with coordinates.
00:27:53 <EvanR> the implementation of the UID isnt important really
00:28:04 <ddarius> Why wouldn't you just use instances of a room and "paint" such swaths of rooms on a map.
00:28:05 <mrotondo> kallisti dropping some design innovation
00:28:05 <ddarius> ?
00:28:38 <kallisti> it's not really anything new I've played MUDs that use coordinates. they had large vast stretches of planet that you could traverse. it was a sci-fi MUD.
00:28:39 <EvanR> kallisti: spatial mud, right, not here
00:28:58 <EvanR> also muds with hex grids, interesting
00:29:11 <EvanR> anyway
00:29:22 <kallisti> it was a hybrid sort of thing where when you leave the big city you're now in a large field. the "room" metaphor kind of disappears at that point and you're just kind of walking around a big ASCII map.
00:29:32 <Ngevd> Could ((->) r) be given an instance of MonadPlus with id as mzero and (.) as mplus?
00:29:57 <Oxryly> so basically you can cobble together a unique name via a few different approaches. problem solved.
00:30:02 <kallisti> > id >>= (+1)
00:30:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
00:30:03 <shachaf> Ngevd: That doesn't particularly type-check.
00:30:09 <kallisti> Ngevd: nope
00:30:14 <ddarius> http://www.medievia.com/medmap.html?MedMapZonesGrid
00:30:30 <Sgeo> > id >>= (+)
00:30:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:30:31 <lambdabot>    arising from a use of `...
00:30:36 <Sgeo> :t id >>= (+)
00:30:39 <lambdabot> forall a. (Num a) => a -> a
00:30:43 <EvanR> again, missing the different orthogonal points to various different 'names' only one of which needs to be unique and thats the relational part
00:31:00 <kallisti> EvanR: sure.
00:31:52 <Sgeo> So, should my API functions return values of type ReaderT AWInstance IO a?
00:32:06 <Sgeo> Considering most of them will need the AWInstance, and most of the time the AWInstance will be the same
00:32:09 <kallisti> Sgeo: is the Reader state needs beyond that point?
00:32:13 <kallisti> *needed
00:32:24 <Sgeo> "beyond that point"?
00:32:25 <kallisti> oh
00:32:36 <kallisti> yes, will the calling code need it. and apparently the answer is yes.
00:32:48 <EvanR> Sgeo: libraries do export stuff like that, typically under a type synonym
00:33:03 <ddarius> Typically under a newtype.
00:33:04 <Sgeo> type AW = ReaderT AWInstance IO ?
00:33:13 <Sgeo> Or would it have to be type AW a = ReaderT AWInstance IO a?
00:33:22 <kallisti> that
00:33:24 <kallisti> but I'd use newtype.
00:33:25 <ddarius> Sgeo: The former is preferable.
00:33:30 <kallisti> ...oh
00:33:34 <kallisti> yes they're equivalent. I misread.
00:33:43 <ddarius> kallisti: They aren't quite equivalent.
00:33:48 <ddarius> But you almost always want to newtype wrap your monad stacks.
00:34:08 <kallisti> no I meant the type T = Blah vs. type T a = Blah a
00:34:10 <dzhus> what's the easy way of creating Data.ByteString.Lazy.Internal.ByteString from String?
00:34:12 <Sgeo> Consider also that I can imagine forking from within the monad
00:34:14 <EvanR> newtype so they cant directly read the state?
00:34:18 <ddarius> kallisti: Yes, they aren't quite equivalent.
00:34:31 <Sgeo> And also can on occasion use a different AWInstance
00:34:32 <EvanR> dzhus: fromString
00:34:35 <kallisti> ddarius: how so?
00:34:36 <Sgeo> So I'd want to wrap local
00:35:04 <ddarius> kallisti: You can't partially apply type synonyms so Foo T is an error for the latter and not for the former.
00:35:09 <Sgeo> Well, thing blah =  local (const blah)
00:35:33 <kallisti> ddarius: oh that's weird.
00:35:43 <Sgeo> @hoogle fork
00:35:45 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
00:35:45 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
00:35:45 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
00:35:56 <Sgeo> Where's the thing that allows forking of more than IO?
00:36:05 <MarcWeber> I'd like cabal-ghci to forward SIGINT to ghci. The fastest thing to do would be using bash's 'exec' command replacing the cabal-ghci process with ghci - does any library provide it?
00:36:17 <kallisti> Sgeo: you'd probably want GeneralizedNewtypeDeriving as well so you can get things like MonadIO
00:36:22 <MarcWeber> Two alternative solutions would be catching the signal and sending it to the child or using FFI.
00:36:30 <elliott> Sgeo: What does forking more than IO entail?
00:36:39 <elliott> For instances, how do you fork (StateT s IO)?
00:37:10 <Sgeo> elliott, I think the thing I've seen makes that thread read the state but writes to it stay in that thread
00:37:12 <kallisti> :t liftIO
00:37:12 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:37:31 <elliott> Sgeo: You're probably thinking of monad-control + lifted-base.
00:37:33 <Sgeo> http://hackage.haskell.org/packages/archive/lifted-base/latest/doc/html/Control-Concurrent-Lifted.html#v:fork
00:37:44 <Sgeo> elliott, yeah
00:38:34 <Sgeo> I still don't get the newtype wrapping the monad stack thing though
00:39:13 <Sgeo> Why?
00:39:21 <Sgeo> And would I Generalize Newtype Derive the Reader stuff?
00:39:27 <Sgeo> MonadReader?
00:39:40 <Sgeo> Or just export my own variation of local and perhaps ask
00:39:44 <ddarius> Sgeo: It depends.  Usually you wouldn't because there is a tighter, more relevant interface.
00:40:19 <Sgeo> ddarius, I wouldn't really expose local, maybe localInstance inst = local (const inst)
00:40:27 <Sgeo> (module newtype wrapping)
00:40:32 <Sgeo> *modulo
00:40:36 <ddarius> Sgeo: By newtype wrapping, you hide implementation details which lets you add features to the monad stack later on without affecting users.  You also make it much simpler for the users in terms of things like error messages or needing to lift.  You also can present a smaller interface.
00:40:59 <eviltwin_b> MarcWeber: System.Posix.Process?
00:42:32 <Sgeo> I think I recently saw something on Reddit about this stuff not being sound?
00:42:49 <Sgeo> ddarius, also, I can just generalize newtype derive MonadBaseControl... can I?
00:43:00 <Sgeo> It looks like an MPTC
00:47:27 <Sgeo> Apparently the answer is yes if... the thing in question is the last one
00:47:38 <Sgeo> Which it looks like it would be :D
00:49:59 <EvanR> eh... IxSet seems to be missing some basic type safety?
00:50:41 <EvanR> getEQ :: k -> IxSet a -> IxSet a, runtime error if the ixset is not indexed on k
00:52:19 <elliott> EvanR: No?
00:52:24 <elliott> It returns a subset.
00:52:27 <elliott> That subset may be empty.
00:52:40 <Sgeo> elliott, are you happy about the conduit changes?
00:52:58 <donri> elliott: but it works via Typeable
00:53:00 <EvanR> elliott: well i see now that the library is pretty dynamic overall
00:53:18 <elliott> Sgeo: Sure, I... guess?
00:53:27 <EvanR> im kind of scared to see how haskells type system would help ;)
00:55:16 <donri> EvanR: you can of course make your own more strict functions
00:55:57 <EvanR> a hard candy shell to stop the chocolate from melting in your hands ;)
00:56:49 <donri> getUser :: IxSet User -> UserId -> Maybe User; getUser ix uid = getOne $ ix @= uid
00:56:52 <donri> etc
00:57:44 <donri> http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
00:58:15 <donri> i wonder if ixset could be rewritten to make use of type families though ...
00:58:18 <EvanR> donri: that by itself doesnt stop the user of your getUser function from passing in an IxSet which mistakenly was not equipped with UserId index during runtime
00:59:13 <EvanR> but an additional function which is intended to be the only way to get a IxSet User should be a good, along with the culture of not fooling with internal stuff of other modules
00:59:46 <EvanR> (and then uhg unit testing the module exporting the IxSet)
01:00:02 <donri> typeable is scary stuff :)
01:00:28 <EvanR> it makes me feel like im using ruby python php javascript :(
01:01:00 <EvanR> phpythonscruby
01:01:03 <donri> stepcut: could ixset be made more type safe perhaps via type families or something?
01:06:11 <EvanR> ok i have my relational model
01:06:39 <mrotondo> do tell
01:07:17 <EvanR> trying to use hpaste...
01:07:36 <hpaste> EvanR pasted “mud” at http://hpaste.org/57142
01:08:21 <EvanR> :sweetjesus face:
01:08:26 <mrotondo> :]
01:08:40 <mrotondo> and that plays nice with acid-state & IxSet?
01:09:14 <EvanR> four ixsets, the extra indexes would be on room0, room, loc
01:10:32 <mrotondo> what's Etc, in not too many words? (this looks very intriguing and i'm gonna play with it later!)
01:10:48 <mrotondo> (inset that is. not your data model)
01:11:00 <mrotondo> *ixset
01:11:01 <EvanR> four different etcs
01:11:10 <EvanR> just the additional data youd expect to get
01:11:14 <mrotondo> hm ok.
01:11:19 <elliott> EvanR: room0 room1 -- why not src, dest?
01:11:22 <EvanR> room name, room description, room temperature ;)
01:11:40 <srhb> elliott: It goes both ways though, no?
01:11:44 <EvanR> no it doesnt
01:11:46 <EvanR> its one way
01:11:52 <srhb> Ah, then he's definitely right.
01:11:52 <EvanR> elliott: youre right would be more explanatory
01:11:54 <mrotondo> imagine a cliff
01:13:30 <EvanR> now its seems pretty obvious how to program a look command, inventory command, use an exit, get an item, etc
01:13:48 <EvanR> assuming you have relevant ids ;)
01:13:58 <EvanR> the player mob id
01:14:13 <EvanR> and targets
01:14:57 <_Mikey> guys
01:15:12 <_Mikey> I have a spacing issue..
01:15:16 <_Mikey> but I don't know why :s
01:15:48 <hpaste> “_Mikey” pasted “Spacing” at http://hpaste.org/57143
01:16:54 <elliott> _Mikey: Did you use tabs?
01:17:07 <elliott>            | fst x < snd x    = ((x,North),(y,(South))
01:17:16 <elliott> Take a look at the parentheses.
01:17:19 <Sgeo> Why is HasRef still a part of Resource?
01:17:28 <Sgeo> Conduits don't need it anymore right?
01:17:52 <Oxryly> EvanR: now you're on to the interesting problems ;)
01:18:11 <Oxryly> EvanR: i'll be interested to see your command parsing approachj
01:19:40 <_Mikey> one tab
01:19:50 <_Mikey> elliot: and then spaces to the line
01:19:52 <mekeor> _Mikey: you have to add one bracket at the end.
01:20:07 <mekeor> one closing bracket like that )
01:20:44 <_Mikey> mekeor, on which line..
01:20:48 <_Mikey> they all should be closed :s
01:20:50 <mekeor> _Mikey: w8
01:21:12 <EvanR> Oxryly: well thats basic in haskell
01:21:17 <hpaste> “_Mikey” annotated “Spacing” with “Spacing (annotation)” at http://hpaste.org/57143#a57144
01:21:21 <elliott> _Mikey: <elliott>            | fst x < snd x    = ((x,North),(y,(South))
01:21:25 <hpaste> mekeor pasted “@ _mikey” at http://hpaste.org/57145
01:21:25 <elliott> Read that line *carefully*.
01:21:41 <_Mikey> :o
01:21:44 <mekeor> haahah
01:21:45 <_Mikey> ok
01:21:47 <mekeor> :D
01:21:52 <_Mikey> damn.. ;/
01:22:07 <_Mikey> I feel so stupid.
01:22:21 <mekeor> _Mikey: just remove the opening bracket before the last "South"...
01:23:11 <Oxryly> EvanR: even so... parsing basic english (subject verb object preposition) is not trivial
01:23:43 <elliott> Oxryly: It's not like nobody has ever written a text adventure game or MUD before :)
01:24:15 <_Mikey> elliott, mekeor, thanks guys..
01:25:16 <EvanR> Oxryly: well in muds its usually pretty damn basic commands
01:25:18 <EvanR> verb object
01:25:41 <EvanR> so first look for verbs, the rest of the command is the object ;)
01:26:18 <kallisti> Sgeo: it's just a subclass that represents a monad with mutable references. The idea is that Resource is not unique to Conduits.
01:26:26 <kallisti> it can be used for other purposes.
01:26:57 <kallisti> and, other monads can implement the interface.
01:27:03 <chrisdone> Oxryly: http://en.wikipedia.org/wiki/Attempto_Controlled_English
01:27:06 <mrotondo> have you guys seen Inform 7?
01:27:17 <mekeor> mrotondo: whats that?
01:27:25 <mekeor> @google inform 7
01:27:26 <lambdabot> http://inform7.com/
01:27:27 <lambdabot> Title: Home : Inform
01:27:41 <mrotondo> it's what we should be _trying_ to make instead of thinking about crappy old MUD conventions
01:27:55 <mrotondo> it's a text adventure language that compiles (roughly) natural language
01:28:06 <mrotondo> that's the cool shit
01:28:09 <mrotondo> not verb noun
01:28:12 <EvanR> chrisdone: i think its funny that the article carefully avoids 'artificial intelligence' :0
01:28:51 <russellw> Inform 7 is a very interesting piece of work, but bear in mind that it's designed for text adventure games of a style that puts a strong emphasis on story
01:29:00 <EvanR> mrotondo: mudders arent interested in typing beautiful prose when in the heat of battle
01:29:16 <EvanR> although that would be hilarious
01:29:16 <mrotondo> EvanR: I just think there might be a middle ground :)
01:29:24 <russellw> If you're creating a mud where the emphasis is on simulation and there isn't very much story, inform 7 is probably not the right tool
01:30:11 <mrotondo> russellw: I'm not saying to shoot for that level of complexity, I just think it'd be interesting to think about what enhancements to the conventional MUD command language WOULD be suitable and interesting
01:30:12 <EvanR> MOO is some pretty scary tech for making commands seem natural
01:30:18 <EvanR> but it ended up in the uncanny valley
01:30:31 <EvanR> it was better than zork
01:30:44 <EvanR> but still frustrating
01:31:00 <mrotondo> everything gets frustrating
01:31:21 <mrotondo> even the best modern IF is ridiculously frustrating when you run into a situation where you just can't guess the noun they want you to use
01:31:28 <russellw> mrotondo, sure, I agree with that. I would just be inclined to look for enhancements oriented around improving the simulation, rather than oriented around trying to turn the thing into literature
01:31:34 <EvanR> i think zork was optimized for people who did not know the commands, and muds are optimized for people who do know the commands and want to get shit done fast
01:31:53 <mrotondo> EvanR:
01:31:54 <EvanR> (zork is turn based)
01:31:54 <mrotondo> oops
01:32:02 <mrotondo> anyway what's the state of auto-completion in MUDS
01:32:19 <EvanR> in the UI? impossible, its telnet
01:32:21 <mrotondo> do any of them do it client-side? or do they let you send partial nouns to the sim and it'll resolve them? or is there none?
01:32:37 <russellw> Last I heard there wasn't any, for the reason EvanR mentions
01:32:42 <EvanR> some clients will autocomplete heuristically based on the recent output
01:32:43 <mrotondo> well i know there have been some dedicated clients
01:32:49 <russellw> Though I haven't exactly been keeping up with the cutting edge of mud technology lately :-)
01:33:00 <EvanR> but server side good muds let you type prefixes
01:33:03 <mrotondo> you could demux a side channel coming back from the server
01:33:12 <mrotondo> :)
01:33:15 <EvanR> yeeeah
01:33:22 <mrotondo> i've been reading way -too-complicated network code this weekend
01:33:23 <mrotondo> sorry
01:33:26 <EvanR> use the extra phone wires!!
01:33:33 <russellw> :D
01:33:40 <EvanR> they are there for a reason
01:34:04 <mrotondo> anyway cool, never mind on that then
01:34:17 <russellw> An RS-232 interface lead has what, twenty-five pins, and a modem uses something like three of them? Untapped resources! :)
01:34:30 <EvanR> i read that as R2D2 interface
01:34:36 <russellw> :)
01:35:19 <EvanR> (were lucky something important didnt get fused into those extra pins lol)
01:35:25 <EvanR> like html or something
01:35:31 <russellw> heh, yeah
01:36:03 <Oxryly> is there a wireless RS-232 standard?
01:36:05 <EvanR> innovation by the seat of your pants sometimes lights your ass on fire
01:37:00 <Oxryly> AX25
01:37:29 <EvanR> btw, i will now explain my 'strategy' for running a haskell mud. when you want to change code, in old muds (and in a basic haskell mud) you need to kick everyone off, reboot, then have them reconnect
01:38:09 <EvanR> instead, how about two processes, one accumulates and dispatches network lines and communicates to the main server which can independently reboot without disconnecting
01:38:21 <EvanR> the acid state survives ;)
01:39:03 <mrotondo> well if that's the intention, i'd put some early thought into maintaining data integrity across data model changes
01:39:08 <mrotondo> cool idea
01:39:11 <EvanR> thats safecopy
01:39:17 <mrotondo> whuzzat
01:39:23 <Oxryly> so where does the dynamic world state reside?
01:39:26 <EvanR> which... come to think of it doesnt sound too safe in that context lol
01:39:37 <EvanR> what dynamic world state
01:40:00 <Triplefox> if it's like a traditional diku only character state is retained between reboots
01:40:00 <Oxryly> all the players and where they are and what they are doing etc etc
01:40:05 <EvanR> mrotondo: safecopy lets you migrate old data types to new ones incrementally
01:40:13 <mrotondo> neat.
01:40:13 <EvanR> Oxryly: well i just pasted that
01:40:29 <EvanR> Triplefox: right...
01:40:41 <EvanR> as it stands extra work is required to NOT save some state ;)
01:40:56 <Oxryly> ah i see
01:43:15 <EvanR> the hardest part of writing a mud from scratch is fighting off all the 'would be cool if' features which swarm you, and would never be even close to accomplished without getting the basic stuff working first
01:43:34 <ddarius> EvanR: Such as?
01:43:43 <Triplefox> i.e. "build games not engines"
01:43:53 * hackagebot scion-browser 0.2.5 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.5 (AlejandroSerrano)
01:44:13 <EvanR> ddarius: what such as
01:44:23 <mrotondo> all the stuff we are suggesting :)
01:44:38 <ddarius> What "would be cool" features are you considering?
01:44:49 <EvanR> im not even going to dare entertaining all that
01:45:04 <EvanR> counterproductive and considered harmful
01:46:07 <EvanR> complex combat simulation with fluid dynamics for blood and advanced neural networks for enemy strategy!
01:46:10 <EvanR> lol
01:46:28 <ddarius> Rendering that in text over telnet would be impressive.
01:46:41 <mrotondo> ddarius: you've seen dwarf fortress?
01:46:50 <EvanR> mail delivery where rigid body dynamics determines how and where mail gets lost along the way
01:46:58 <mrotondo> o_O
01:46:58 <EvanR> mrotondo: lol i didnt even think of that
01:47:06 <ddarius> EvanR: That would be hard.
01:47:24 <EvanR> 'dwarf economy'
01:47:42 * chrisdone thinks creating these games is far more interesting than playing them
01:47:46 <mrotondo> dwarf fortress is _the_ insane ascii feature extravaganza
01:47:52 <mrotondo> it doesn't get any more insane
01:47:57 <mrotondo> or unplayable
01:48:12 <ddarius> chrisdone: Indeed.  It makes no sense to me to build your own text-based MUD from scratch if your goal is a game rather than a code toy.
01:48:14 <mrotondo> and yet last night i learned to play and it is _so much fun_
01:48:42 <EvanR> mrotondo: especially in evil glaciers
01:48:50 <russellw> yeah. I've tried dwarf fortress, it's fun in a lot of ways but eventually trying to micromanage the dwarves via that interface got to be too much like hard work for me. But I'd love to write an AI player if it had an API
01:48:50 <mrotondo> haha
01:49:19 <mrotondo> i think it might? there's at least a bunch of visualizations and clients, i think, for it
01:49:20 <EvanR> evil glacier with aquifers
01:49:25 <mrotondo> haha
01:49:34 <mrotondo> EvanR: i see you've taken "Losing is fun!" to heart
01:49:40 <EvanR> *you cant drink melted glacier* :(
01:49:44 <ddarius> Text is so 1960s.  How 'bout we make a speech-based MUD.
01:50:11 <EvanR> mrotondo: ive never lost
01:50:22 <mrotondo> there've been a couple experiments recently with no-visuals first-person games
01:50:28 <russellw> mrotondo, yes but those programs have to resort to all sorts of heroic measures like reverse engineering binary data structures in RAM. I mean, I know how to do that kind of stuff, but the time when I did it for fun was a long time ago
01:50:39 <mrotondo> first-person in the sense that they use wads for movement and mouselook to orient your head (ears)
01:50:54 <EvanR> lol wads
01:50:56 <EvanR> doom
01:51:12 <mrotondo> friggin autocorrect
01:52:05 <Sgeo> I don't entirely grasp the difference between (Data,Typeable) and Generic
01:52:17 <Sgeo> What does Generic do that Data doesn't allow?
01:52:24 <chrisdone> me neither, i didn't yet look at the documentation
01:52:29 <mrotondo> turns out playing by sound alone is very difficult, although the experiments i played certainly could've been more sophisticated sonically to get a better 3d sound field
01:54:19 <EvanR> ok now to drop a bomb
01:54:28 <EvanR> can ixset do joins? ;)
01:56:22 <elliott> Sgeo: GHC Generics aren't runtime introspection in the same way.
01:56:35 <elliott> So for one, they're usually a lot faster.
01:57:49 <everythingWorks> where's the problem here? > takeWhile ((<10) && (>5)) [1..10]
01:57:59 <everythingWorks> > takeWhile ((<10) && (>5)) [1..10]
01:58:00 <lambdabot>   The section `GHC.Classes.< 10' takes one argument,
01:58:01 <lambdabot>  but its type `GHC.Bool....
01:58:16 <EvanR> :t (<10)
01:58:17 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
01:58:34 <everythingWorks> hm..
01:58:35 <EvanR> everythingWorks: && takes Bools
01:59:14 <Sgeo> elliott, they're runtime introspection in a different way?
01:59:28 <Sgeo> So, in what cases might I use Generics over Data or Typeable?
01:59:51 <elliott> No, Generics is basically compile-time.
01:59:51 <EvanR> @pl \x -> x>5 && x<10
01:59:52 <lambdabot> liftM2 (&&) (> 5) (< 10)
01:59:54 <elliott> Generics is for things like deriving instances.
02:00:00 <EvanR> everythingWorks: ^
02:00:03 <elliott> Data is for AST traversal and the like.
02:00:17 <elliott> everythingWorks:
02:00:18 <elliott> :t (&&)
02:00:19 <lambdabot> Bool -> Bool -> Bool
02:00:25 <elliott> (<10) and (>5) quite obviously aren't booleans.
02:00:48 <everythingWorks> jup, got it! :D
02:01:06 <EvanR> elliott: any idea how to do relational joins
02:01:16 <EvanR> besides hooking up a sql database ;)
02:01:25 <everythingWorks> elliott: you think lambdas would be appropriate?
02:01:27 <everythingWorks> >  takeWhile (\x -> x>5 && x<10) [1..10]
02:01:29 <lambdabot>   []
02:01:34 <everythingWorks> That would work :)
02:01:36 <EvanR> everythingWorks: easier to read for most people
02:01:50 <aristid> everythingWorks: that's not a join
02:01:59 <everythingWorks> aristid hm?
02:02:08 <aristid> EvanR: list comprehensions will probably do what you want.
02:02:14 <EvanR> yes
02:02:26 <EvanR> join is cartesian product followed by a filter
02:02:30 <EvanR> however
02:02:34 <aristid> EvanR: at their heart, joins are cartesian products, and list comprehensions provide that.
02:02:43 <everythingWorks> the lambda output is exactly as expected, aristid. What do you mean?
02:02:47 <EvanR> thats gonna be intractible
02:03:20 <aristid> everythingWorks: it's a filter, not a join
02:03:34 <EvanR> he wasnt asking about joins
02:03:53 * hackagebot pointless-fun 1.1.0.1 - Some common point-free combinators.  http://hackage.haskell.org/package/pointless-fun-1.1.0.1 (WrenThornton)
02:04:17 <everythingWorks> aristid: Sorry, i dont know what you mean
02:04:29 <aristid> everythingWorks: nevermind, i was confused by the timing of your statement
02:04:46 <aristid> everythingWorks: you said it right after EvanR talked about joins
02:05:07 <everythingWorks> okay
02:05:56 <aristid> EvanR: what do you mean with intractible?
02:06:42 <EvanR> ok its intractable, but its n^2 and im expecting to find between zero and a few results
02:06:49 <EvanR> n*m
02:07:27 <EvanR> aristid: we were talking about making an acid state which used ixset for relational stuff, but i dont think it does joins
02:07:27 <russellw> EvanR, would it make sense to use sqlite? That's pleasantly lightweight, as the name implies, and it's done a lot of this kind of work for you
02:07:42 <EvanR> well sqlite be as good as acid state
02:07:51 <russellw> yeah
02:08:15 <EvanR> whats the state of haskelldb
02:08:21 <everythingWorks> what are you guys actually using haskell for? :)
02:08:38 <everythingWorks> Which types of programs do you create with it? What do you do with it? :)
02:08:40 <EvanR> everythingWorks: we were just discussing muds
02:09:02 <everythingWorks> EvanR: mud?
02:09:31 <russellw> everythingWorks, honestly I'm not actually using Haskell at the moment, but I'm hanging out here anyway because the quality of conversation is better than on any other IRC channel I've come across ^.^
02:09:38 <EvanR> lol
02:09:44 <mekeor> lol
02:09:59 <russellw> But yeah, mud = multiuser dungeon = mmorpg text adventure game
02:10:01 <ddarius> russellw: You do have the option of not hanging out on IRC channels.-
02:10:14 <everythingWorks> russellw: fully agree with you :)
02:10:18 <ddarius> MUD does not imply text.
02:10:18 <EvanR> russellw: well i have a distinct feeling that marshalling and type safety are worse than in acid state
02:10:18 <russellw> ddarius, but that would be less fun
02:10:30 <mekeor> (#)haskell is great :)
02:10:35 <ddarius> russellw: The idea would not be that you replace that time with staring at a wall.
02:10:44 <everythingWorks> ah, thought of 'mud' as the english word 'mud' :P
02:10:47 <EvanR> referring to muds as mmorpgs is sacrilage
02:11:04 <ddarius> Just change "massively" to "moderately."
02:11:08 <chrisdone> EvanR: feel free to express your nerd rage
02:11:09 <EvanR> lol
02:11:20 <russellw> ddarius, well I find this is good for micro-breaks while I'm spending a few minutes chewing over a programming problem. Going off and reading a novel instead would be a much bigger break than I'm looking for
02:11:37 <everythingWorks> Im using it for getting an uderstanding how different/functional programming paradigmns work :)
02:12:12 <russellw> everythingWorks, it is definitely very good for that. I would put it on the short list of languages (along with C and Scheme) that everyone should learn for that reason
02:12:25 <aristid> EvanR: i don't understand why everybody feels the need to build key-value stores without joins :)
02:13:10 <mrotondo> haskell is infecting my braaaain
02:13:22 <mrotondo> i just read the number 6.7 and thought
02:13:24 <EvanR> aristid: im not familiar with that yet, im new to 'nosql' ;)
02:13:35 <mrotondo> "wait… what's the composition of 6 and 7"?
02:13:38 <EvanR> its a barren existence it seems
02:13:49 <EvanR> > 6 . 7
02:13:50 <lambdabot>   No instance for (GHC.Show.Show (f b))
02:13:50 <lambdabot>    arising from a use of `M5666410053...
02:13:54 <EvanR> :t 6 . 7
02:13:55 <lambdabot> forall a b (f :: * -> *). (Num b, Num (f a), Functor f) => f b
02:14:02 <mrotondo> haha
02:14:08 <mrotondo> :B
02:14:13 <aristid> EvanR: i'm not closely following the nosql stuff either, but from what i've seen they must all be a pain to work with if you want to actually query your data.
02:15:09 <mekeor> i often use isNothing and isJust while using Maybe. but i don't know how to use Either since there's no isLeft or isRight. how do you handle that?
02:15:23 <EvanR> dont use isNothing and isJust
02:15:24 <ddarius> aristid: Because hobby programmers tend to be rather unacquainted with RDMSes, and for some reason think that man-centuries of work will fail to meet their needs, and that they will be able to get "what they need" with a weekend of hacking, which is only almost entirely false.
02:15:29 <EvanR> mekeor: use maybe and either
02:15:33 <EvanR> and fromMaybe
02:15:38 <Sgeo> Are there user-definable data types that cannot have a deriving (Data, Typeable, Generic) sort of thing?
02:15:44 <Lemmih> mekeor: Or case expressions.
02:15:48 <EvanR> or case
02:15:53 <chrisdone> aristid: it seems to be good for small apps that just need to store flat sets of data. i don't really understand writing real applications without an real database is desirable
02:15:59 <Sgeo> Such as, am I able to do data SomeFunction = SomeFunction (Int -> Int) deriving Data?
02:16:00 <elliott> mekeor: Don't use isNothing or isJust. Ever.
02:16:01 <mekeor> EvanR: hmm
02:16:02 <elliott> mekeor: Use pattren matching.
02:16:05 <elliott> Which also works fine on Eithers.
02:16:13 <elliott> maybe/either/fromMaybe can be useful, but pattern matching is the fundamental concept.
02:16:18 <mekeor> and why not isJust/isNothing ?
02:16:24 <elliott> Because the inevitable next step is fromJust.
02:16:26 <aristid> EvanR: oh look, i just found this on hackage. maybe this is interesting for you? http://db.inf.uni-tuebingen.de/research/ferry
02:16:35 <elliott> Which means you've reinvented pattern-matching without the convenience or safety :)
02:16:37 <everythingWorks> russlw: Why C instead of c++(11)?
02:16:43 <russellw> ddarius, agreed completely. I will go so far as to say that most projects using nosql would be better off with a proper SQL database, and therefore the world would be better off if every project followed the rule 'always use a proper SQL database even if you think you are the exception to the rule'
02:16:50 <ddarius> aristid: It is interesting, though I'm not sure how much from a Haskell perspective.
02:17:06 <aristid> ddarius: there is a hackage package
02:17:13 <ddarius> aristid: I know.
02:17:19 <ddarius> It's also a lot of other things.
02:17:19 <mekeor> elliott, EvanR: okay. alright.
02:17:24 <ddarius> E.g. there's a Linq provider.
02:17:30 <chrisdone> russellw: not necessarily SQL, but a relational or logic database seems better to me
02:17:33 <ddarius> russellw: You should read the papers in that Ferry link then, because it's a great case-in-point.
02:17:34 <companion_cube> russellw: why do you find SQL databases so much better ?
02:17:51 <companion_cube> key/value is quite convenient too
02:18:08 * mekeor doesn't use case often...
02:18:13 <ddarius> companion_cube: "man-centuries"
02:18:14 <EvanR> so i guess linq is on the right track
02:18:19 <EvanR> which is weird for microsoft
02:18:25 <mekeor> BAH
02:18:30 <Sgeo> LINQ was inspired by something, right?
02:18:33 <Sgeo> HaskellDB iirc?
02:18:37 <EvanR> heh
02:18:40 <ddarius> Sgeo: Uh, Haskell monads.
02:18:48 <mrotondo> I'm pretty sure that nobody is going to say that the concept of relational data is a bad one
02:18:49 <companion_cube> ddarius: wht if you don't need the relational model?
02:18:50 <russellw> companion_cube, key/value seems convenient initially. Then you discover you need the features of a proper relational database after all, and you typically discover this around the time you've blown a good chunk of time reinventing 0.1% of that wheel. Then you've got to blow another good chunk of time porting everything over
02:18:57 <Sgeo> Is HaskellDB still maintained?
02:19:04 <russellw> It would be so much more efficient to just use a relational database from the start
02:19:09 <mrotondo> I think the problem is mainly with the inability to uphold the relational guarantees under heavy concurrent load
02:19:21 <companion_cube> well, key/value DB also provide transactions
02:19:33 <ddarius> companion_cube: You'll still get man-centuries of effort.  Just because you don't need all of it doesn't mean you could get "just what you need" in a better manner easily.
02:19:38 <aristid> companion_cube: transactions are not really what russellw is referring to, i think.
02:19:40 <EvanR> companion_cube: well if you followed the convo i started tonight / this morning, youd see how this progression goes
02:19:53 <elliott> COBOL also has man-centuries of effort, I feel compelled to point out.
02:19:59 <mrotondo> Yeah. the game has changed
02:20:15 <companion_cube> +1 elliott
02:20:16 <mrotondo> the design constraints that RDBMS had it's man-centuries of effort take place under are different now
02:20:16 <chrisdone> companion_cube: the constraints and consistency, benefits of a common theoretical understanding of how data is modelled, and decades of research and industrial innovation in the software to implement these things… those kind of benefits
02:20:18 <aristid> EvanR: you started out with wanting a key/value db?
02:20:25 <EvanR> aristid: no
02:20:43 <EvanR> i started wonder about a good data model in haskell for a mud
02:20:51 <XexonixXexillion> elliott: please don't use the C-word. It still gives me nightmares :p
02:20:55 <aristid> also relational algebra has the word algebra in it. big plus :D
02:20:56 <EvanR> after beating heads against walls i decided on relational
02:20:59 <companion_cube> well, i think relational DB are cool if you have a relational problem to solve, but sometime you don't
02:21:03 <EvanR> now it seems doing relational in haskell is hard
02:21:14 <companion_cube> and a datalog, key/value or graph database can be more suited to the task
02:21:17 <ddarius> mrotondo: Relational databases probably have more research effort and industry financing than any area of computer science.  I'd put a substantial wager that this is true overall and also in the top-ten, for the last five years.
02:21:31 <aristid> EvanR: relational with lists is easy :D
02:22:00 <EvanR> companion_cube: well the idea here is that you start out not knowing the full set of data and use of that data, and its easy to expand later with a basic relational system
02:22:13 <EvanR> which is what i just did trying to add a single new feature to initial setup
02:22:13 <ddarius> The history of RDBMSes is people constantly coming up with things "beyond the relational model" or that "don't fit the relational model" and then those features getting swallowed and improved shortly, if not immediately, by relational databases.
02:22:25 <mrotondo> Hm I think I may have come across as saying that their day is done
02:22:27 <mrotondo> I don't think that
02:22:34 <ddarius> Datalog is relational.
02:22:35 <mrotondo> I just disagree that they are always the right answer
02:22:44 <chrisdone> companion_cube: the point above is that most developers are solving relational problems, if not immediately then eventually
02:22:50 <companion_cube> ddarius: so, if all I want is to represent some persistent tree structure?
02:23:05 <companion_cube> ddarius: relational is datalog :þ
02:23:10 <ddarius> mrotondo: They aren't always the right answer, but they are almost always a useable answer, and one that scales if your needs change.
02:23:11 <EvanR> companion_cube: then you are really really lucky
02:23:19 <EvanR> use json or xml
02:23:29 <companion_cube> (e.g. ldap)
02:23:30 <EvanR> otherwise back to the drawing board
02:23:35 <elliott> companion_cube: Not that I was defending NoSQL :P
02:23:43 <russellw> companion_cube, if that's all you want today, then you will do fine with a simple noSQL database today... And then tomorrow you will find you want something more, and oops, now you have a big porting job that you wouldn't have had if you had used a relational database from the start
02:24:10 <EvanR> companion_cube: ldap is the not 'representing a persistent tree', you often want to ask questions about the account database that cant be answered because theres no relational system
02:24:18 <companion_cube> but if I had used a relational DB to represent a tree, it would have been slow and unnatural
02:24:39 <ddarius> companion_cube: I represent hierarchical data in relational databases all the time.
02:24:51 <EvanR> companion_cube: 99% of stuff we try to do is *not* looking like a tree, in fact its mostly something else that someone has crammed into a tree for trees sake
02:25:09 <russellw> companion_cube, relational databases have had a staggering amount of effort put into making them run fast. So have modern computers. It is very very rare that a properly used relational database will be too slow in real life
02:25:22 <ddarius> russellw: Truth.
02:25:22 <aristid> ddarius: in the straightforward manner that one would immediately think of, or with a more sophisticated scheme?
02:25:25 <elliott> I heard MongoDB is web scale, thoug.
02:25:26 <companion_cube> russellw: well, lots of accesses to single rows
02:25:26 <elliott> *h
02:25:39 <russellw> Unless you're talking about a sufficiently heavy number crunching job or whatever that a nosql database wouldn't be appropriate either
02:25:46 <ddarius> aristid: Usually in the straightforward manner.  I typically work with Microsoft Sql Server which has recursive queries.
02:25:47 <EvanR> on that note truely tree data should not be dismantled and stored into a RDBMS for RDBMS sake
02:25:48 <elliott> Actually that's not true, I've never actually heard a sincere "web scale" claim.
02:26:07 <mrotondo> BigTable?
02:26:29 <aristid> ddarius: maybe most of the limitations of "relational databases" are really limitations of mysql or whatever the people know :D
02:26:57 <aristid> EvanR: how else would you store truly tree data?
02:26:57 <EvanR> mysql shall henceforth be stricken from the record
02:27:06 <ddarius> aristid: I think, for people who don't work with relational databases, most of the "limitations" they "know" are myths.
02:27:17 <EvanR> aristid: bytestring
02:27:20 <mrotondo> Also, it's not like you can't store blob data in a RDBMS
02:27:26 <ddarius> aristid: But yes, there are a lot of less than pleasant relational database implementations.
02:27:26 <aristid> EvanR: srsly?
02:27:26 <mrotondo> there's your tree
02:28:13 <EvanR> aristid: yes, does your dbms have functional language for traversing json?
02:28:43 <aristid> EvanR: recursive queries?
02:28:57 <EvanR> o_O
02:29:03 <rostayob> spj in a recent Haskell talk ( http://yow.eventer.com/events/1004/talks/1054 ) mentions a GHC bug that deletes the source when it had a type error
02:29:20 <aristid> rostayob: he mentions that in every talk, it seems
02:29:25 <companion_cube> DELETE ALL TYPE ERRORS!
02:29:48 <aristid> EvanR: am i not making sense? sorry, then :)
02:30:14 <EvanR> aristid: a single type of tree could span ten tables, and then you get into the case where the project somehow has more than one kind of tree data
02:30:15 <ddarius> aristid: The Ferry papers have a good example of DB2's relational databases beating the crap out of DB2's XML database support by just applying some relatively simple optimizations to the query plans a naive translation of XQuery to SQL produces, to produce simply SQL queries that are more in line with what a RDBMS expects.
02:30:38 <EvanR> aristid: the main problem here being most people have all their data in a tree to begin with, when it shouldnt be
02:30:38 <mrotondo> aristid: you are. there's lots of data that' not truly relational that you end up needing to store. say you have a drawing app: each path has loads of points, that's not very useful to store relationally. so you store a list of points in a binary blob and store it in the db
02:30:48 <aristid> ddarius: guess i should actually read them.
02:30:51 <rostayob> erg: sowhen did that happen :D?
02:30:55 <ddarius> aristid: They are interesting.
02:31:07 <EvanR> 'not truly relational' is missing-the-point-language for 'tree'
02:31:28 <EvanR> reevaluate whether its really a tree or just some asshole from microsoft who read too many books from barnes and noble IT section
02:31:31 <ddarius> EvanR: Most "big" databases support XML more or less natively.  They have facilities for querying tree-structured/semi-structured data well.
02:31:48 <ddarius> Trees are not an unsolved problem for relational databases.
02:32:03 <EvanR> uhg xml
02:32:12 <EvanR> \o/
02:32:28 <EvanR> free the data from the shackles of XML!!!!
02:32:40 <elliott> EvanR: I'm sure the support for XML is completely and utterly inapplicable to any other kind of structured tree data in existence.
02:32:47 <mrotondo> when i say "not truly relational" i'm just saying that there is probably some point at which RDBMS _will_ break down, and it's not worth pushing it to that point. like someone said earlier, they are performant when used correctly
02:32:51 <elliott> Good thing we don't believe the XML hype here in #haskell!
02:33:00 <mrotondo> so you might as well use the right tool for the job
02:33:03 <EvanR> mrotondo: 'probably' ?
02:33:16 <sipa> elliott: is that some ML dialect? ;)
02:33:27 <ddarius> EvanR: The point isn't that you should translate your JSON to XML (though you have that route) the point is that there has been substantial effort on how to handle specifically the type of data you are talking about.  As I said earlier, RDBMSes are probably in the top ten areas research effort has been put in the last five or ten years.  Probably the top five.
02:34:07 <companion_cube> so are virtual machines like the jvm, but they are not the ultimate solution to any programming language problem
02:34:16 <elliott> @quote platitude
02:34:16 <lambdabot> ddarius says: "use the right platitude for the job"
02:34:26 <ddarius> It's surprising what modern RDBMSes -can- handle.
02:34:29 <elliott> lambdabot should automatically quote that whenever anyone says use.*right.*tool.*job
02:34:37 <mrotondo> :}
02:34:39 <EvanR> i still think the data probably shouldnt be in literally a tree, probably a literal DOM is the only thing in standard practice which is a tree and wth stores the literal dom and why
02:35:00 <mrotondo> ?
02:35:27 <EvanR> answer nobody so no more trees
02:36:04 <mrotondo> well that settles it, out with that data structure.
02:36:14 <EvanR> for business purposes yes
02:36:36 <EvanR> probably most applications
02:37:10 <companion_cube> hey, what if i want to represent a b-tree in a database? ;)
02:37:20 <ddarius> @google raytracer sql
02:37:22 <lambdabot> http://www.codeproject.com/Articles/15935/Yet-Another-RayTracer-for-NET
02:37:23 <lambdabot> Title: Yet Another RayTracer for .NET - CodeProject®
02:37:40 <mrotondo> nopers
02:37:40 <EvanR> companion_cube: big if
02:37:47 <EvanR> next question
02:37:55 <EvanR> sqlite is a C library
02:38:14 <EvanR> im deathly afraid of using libraries in haskell which are bindings to C libraries
02:38:20 <EvanR> now what
02:39:16 <EvanR> do the whole thing in C :(
02:39:24 <ddarius> EvanR: You use HDBC which has a sqlite backend already.
02:39:41 <EvanR> hdbc :(((
02:39:53 <EvanR> that uses the ffi too
02:40:23 <EvanR> mysql-simple is great, but it means i would have to use mysql :(((
02:40:34 <EvanR> relational cant be done in haskell
02:40:40 <jedai> postgresql-simple ?
02:40:43 <ddarius> Or you could use HDBC, HaskellDB, Takuan, or others.
02:40:56 * EvanR checks on haskelldb
02:40:58 <elliott> *Takusen I think.
02:41:16 <elliott> EvanR: You realise that the only alternative to using SQLite via the FFI is to use SQLite via the command-line tool?
02:41:38 <EvanR> elliott: which would make me feel better
02:41:44 <EvanR> since you cant segfault
02:41:45 <aristid> there's a direct sqlite bindings package too, i think
02:41:50 <companion_cube> why are you afraid of linking with sqlite?
02:42:01 <EvanR> im afraid of any haskell lib which uses C ffi
02:42:11 <aristid> oO
02:42:23 <EvanR> since 90% of the ones i used so far have caused segfaults
02:42:32 <EvanR> segfaults in haskell :(
02:42:41 <companion_cube> wow
02:43:02 <companion_cube> I use sqlite in python, never met any segfault... but then the bindings are not the same
02:43:16 <EvanR> yeah but people dont really care when python crashes
02:43:25 <EvanR> thats normal
02:43:26 <EvanR> lol
02:43:54 * ddarius has used sqlite via HDBC for a small web server project.  He had more problems with a buggy GHC and no segfaults.
02:43:54 <russellw> EvanR, heh... But another thing to consider, have you thought about what scripting language you are going to provide?
02:44:02 <russellw> That might also influence your choice of technology stack
02:44:06 <chrisdone> the regex ffi libraries were a cause of segfault for hpaste for a while. pretty worrying
02:44:09 <elliott> EvanR:
02:44:13 <elliott> You can segfault without the FFI.
02:44:27 <EvanR> elliott: impossible!
02:44:44 <chrisdone> EvanR: that's what the error message looks like, yeah
02:45:08 <EvanR> russellw: no plans for a scripting language
02:45:22 <russellw> Okay fair enough
02:45:34 <EvanR> sounds like a can of worms
02:45:36 <aristid> EvanR: no plans a scripting language ... other than haskell! :D
02:45:49 <russellw> Are you planning to create all the content yourself, then?
02:45:51 <EvanR> yes type code into haskell, recompile, reboot server
02:46:00 <russellw> ah, okay
02:46:00 <chrisdone> EvanR: i have a postgresql library written in haskell. you can use that if you're afraid of ffi
02:46:11 <russellw> Honestly that sounds like a bigger can of worms, but there you are :)
02:46:16 <aristid> chrisdone: without ffi?
02:46:21 <EvanR> russellw: content == scripting?
02:46:25 <aristid> chrisdone: binding directly to the network protocol?
02:46:29 <chrisdone> aristid: yeha
02:46:42 <chrisdone> hpaste uses it
02:46:43 <aristid> chrisdone: cool. well-tested, too?
02:47:20 <russellw> EvanR, well typically yes. I mean you can take content as patches written in Haskell, but I think you will quickly find that becomes very inconvenient
02:47:31 <EvanR> russellw: i started by saying it was a basic mud, so its gonna be so terribly boring probably wont be worth it to make any real content
02:47:42 <EvanR> russellw: no, theres a state which gets modified
02:47:46 <EvanR> its outside the code
02:47:47 <russellw> hell, there is a reason most game studios use a scripting language even for their internal use by their own employees
02:48:13 <chrisdone> aristid: i wouldn't say well-tested or stable. it's been used by hpaste for about 6 months. i imagine there're probably speed/memory usage issues, as i haven't done any profiling/benchmarking
02:48:17 <russellw> State which gets modified, what does that have to do with the current topic?
02:48:22 <EvanR> russellw: 'content'
02:48:27 <EvanR> was the topic
02:48:38 <russellw> ah, you mean you were thinking of content as pure data with no code?
02:48:45 <aristid> chrisdone: but then, EvanR's biggest fear is segfaults, not other bugs
02:48:56 <EvanR> yes thats usually what content in a mud consists of, the descriptions, layouts, items
02:49:20 <russellw> *blinks* nearly all the content I've ever heard of, needs at least a little bit of scripting
02:49:22 <everythingWorks> >
02:49:44 <EvanR> russellw: the minecart which moves back and forth isnt much content
02:50:08 <EvanR> the 10000 rooms of text, and 1000 monster descriptions
02:50:10 <russellw> I mean this is how programs end up with crappy homebrew scripting languages. You start off thinking you don't need scripting, and then you say well we need a mine cart which moves back and forth, so we will provide a way to specify that...
02:50:21 <chrisdone> this might be of interest, “Crash-Only Software” http://radlab.cs.berkeley.edu/people/fox/static/pubs/pdf/c22.pdf
02:50:36 <EvanR> russellw: the original mud codebases just hardcoded that into the code
02:50:41 <russellw> Iterate a thousand times, and you have created a crappy homebrew scripting language by accreting one piece at a time :P
02:50:51 <chrisdone> russellw: e.g. php
02:51:01 <russellw> chrisdone, precisely
02:51:59 <EvanR> yeah but trying to come up with all the features that would be nice before even the database works is a good way to end the project before it begins
02:52:32 <russellw> EvanR, absolutely. That's why you want to start by taking an existing scripting language, that way you know you have something in which you can add features as you think of them, without breaking your architecture
02:53:16 <nand`> or you come up with a dependent type system so expressive that no feature you think of will be a problem later on
02:53:19 <EvanR> if youre adding features with a scripting language, might as well write the whole thing in a scripting language
02:53:35 * ddarius needs 9 9s of uptime for my game with 0 users.
02:53:39 <russellw> nand`, or that if you think you're hard enough
02:53:40 <mrotondo> or you call it a prototype and write a shitty version first that works, and then throw it away and take the knowledge into the next version
02:54:05 <russellw> EvanR, that would be my philosophy, though opinions and project requirements vary
02:54:22 <russellw> mrotondo, yes, that's also often a good approach. Just keep an eye out for when it's time to do the rewrite
02:54:28 <EvanR> and on the subject of 'use x which already exists' lol look at the billion mud codebases already existing xD
02:54:42 <EvanR> mostly not even running anywhere
02:54:57 <russellw> EvanR, indeed :) but there's nothing wrong with writing your own if you think you can do better
02:55:01 <EvanR> (zero in haskell, that i know of)
02:55:10 <chrisdone> ddarius: i got 99 problems but a user ain't one?
02:55:15 <EvanR> i dont think i can do better than some of these
02:55:26 <russellw> Well there you are :)
02:56:00 <EvanR> but this is like saying im not going to learn the play instrument X because john mccartney is better
02:56:09 <EvanR> might as well just listen to him!
02:56:47 <russellw> EvanR, sure. To take that analogy, I'm saying if you are going to learn to play the guitar, you might as well try to learn properly using the best techniques instead of just plinking at random
02:57:06 <chrisdone> i wanted a hackable ircd, so wrote my own haskell one, like a boss
02:57:09 <ddarius> EvanR: Yes, but the bizarre thing is you also seem to be saying stuff like "I don't want to reach too far because then I might fail to deliver a product I have no plans of delivering anyway."
02:57:16 <EvanR> i seriously dont think a scripting language is important
02:57:18 <ddarius> EvanR: Do crazy things and have fun.
02:57:21 <russellw> Or not if you don't feel like it, but you did come asking for opinions, and that's mine :)
02:57:23 <ddarius> EvanR: I agree.
02:58:12 <elliott> I think we should continue running EvanR's project into the ground collaboratively.
02:58:19 <mrotondo> yeah i'm having a blast
02:58:45 <chrisdone> that's true, the easiest way to make your project fail is talking to other people about it
02:59:01 <mrotondo> i think you should run ghci as a subprocess of your server daemon
02:59:03 <chrisdone> compounded by http://sivers.org/zipit
02:59:07 <russellw> yep. At the end of the day you've got to make a decision and go with it, for better or worse
02:59:16 <mrotondo> and make calls out to it with code stored in your db, and read stout to get the result
02:59:32 <mrotondo> there's your scripting
02:59:33 <elliott> EvanR: I think you should use Agda instead.
02:59:41 <nand`> ^
02:59:56 <elliott> But only program in nand gates.
02:59:59 <elliott> Thanks for the inspiration, nand`.
03:00:01 <mrotondo> chrisdone: i love that article
03:00:03 <nand`> You're welcome
03:00:09 <EvanR> elliott: minecraft
03:00:13 <nand`> of course, the nand gates have to be on a type level
03:00:14 <EvanR> lol
03:00:14 <XexonixXexillion> +1 on the do it in agda
03:00:44 <EvanR> i allow scripting but it takes the form of teleporting into the mobs brain and arranging blocks of redstone
03:00:44 <chrisdone> it should have a web interface too
03:01:03 <nand`> chrisdone: isn't that the default assumption these days?
03:01:08 <chrisdone> for muds?
03:01:17 <elliott> EvanR: Actually, it should run in the web browser.
03:01:21 <chrisdone> i thought it was still some telnet-ish client
03:01:23 <EvanR> and to get 8 bytes of memory requires 4000 blocks covering 60 rooms
03:01:24 <elliott> By which I mean, it should be a patch set to Firefox.
03:01:33 <elliott> Containing Agda compiled to C++.
03:01:35 <mrotondo> lol
03:01:44 <nand`> chrisdone: for everything
03:01:53 <nand`> no
03:02:00 <nand`> agda compiled to machine code, decompiled to C with intrinsics
03:02:03 <chrisdone> elliott: i don't think agda direct to c++ would be very reliable. maybe you should compile to php first and then use facebook's php-to-C++ compiler
03:02:27 <elliott> chrisdone: I thought that's how all Agda compilers worked nowadays.
03:02:56 <mrotondo> the agda compiler is actually a Facebook app
03:03:08 <EvanR> i was in a job interview talking about haskell, and the dude anxiously told me 'you know every time someone says anything about haskell i think they are trying to be elistist'
03:03:08 <XexonixXexillion> elliott: I send my agda to code to monkeys with typewriters to make into x86
03:03:09 <companion_cube> of course they compile to php, to benefit from its blazing-fast JIT
03:03:11 <EvanR> your jokes arent helpin g;)
03:03:17 <mekeor> mrotondo: lol?
03:03:24 <ddarius> chrisdone: You can telnet in a web browser.
03:03:36 <chrisdone> EvanR: is elisticism a disease?
03:03:39 * elliott uses Haskell to be elitist.
03:03:48 <mrotondo> haha
03:03:50 <EvanR> chrisdone: thats what i said
03:04:11 <companion_cube> elliott: template haskell then, haskell is so mainstream nowadays
03:04:17 <mrotondo> i just heard a story about another interviewer saying that as of 5 years ago, knowing haskell was basically an auto-hire
03:04:27 <EvanR> o_O
03:04:34 <companion_cube> yay
03:04:35 <mrotondo> so hey
03:04:43 <chrisdone> ddarius: sure, but i thought part of the MUD experience was to avoid newfangled technologies like programs that support more than 256 colours?
03:04:45 <Jafet> ...for a position in C++
03:05:03 * EvanR hulksmashes ixset into the ground for not being able to join
03:05:08 <EvanR> chrisdone: you mean 16 colors
03:05:13 <chrisdone> i do mean 16 colours
03:05:25 <chrisdone> 256 is probably too much, right, mudders?
03:05:26 <EvanR> in the old days you had 2 or 3
03:05:44 <EvanR> bright green, green, and bright black
03:05:47 <mekeor> b&w ?
03:06:24 <mrotondo> haha beautiful… the google image search results for [mud screenshot] are a bunch of MUDs interspersed with stills from girls-driving-cars-stuck-in-mud fetish videos
03:06:33 <EvanR> ...
03:06:43 <tech2> My terminal has supported 256 colours for several years now. Even if mudding lagged behind the times somewhat, you'd think they'd make use of the tools made available to them?
03:06:51 <aristid> mrotondo: which is precisely what you wanted.
03:07:02 <EvanR> some muds come with custom clients
03:07:09 <EvanR> in addition to telnet
03:07:30 <mrotondo> http://www.aardwolf.com/images/aardwolf-mud-client4.jpg
03:07:32 <chrisdone> mrotondo: i've been a regular of, um, *reads* carstuckgirls.com for years!
03:07:44 <EvanR> MOO supported an 'out of band' mode which was supposed to be trigged by clients supporting fancy stuff
03:08:01 <everythingWorks> What could this 'literal style' mean? http://dl.dropbox.com/u/6559846/hlitsty.PNG
03:08:16 <everythingWorks> literate*
03:08:26 <aristid> mrotondo: evilness
03:08:50 <opqdonut> everythingWorks: it means literate haskell, see e.g. http://www.haskell.org/haskellwiki/Literate_programming
03:09:31 <chrisdone> everythingWorks: how many days did it take you to boot up eclipse? haha, it's funny because eclipse is slow!
03:10:01 <aristid> chrisdone: i'm sure that everythingWorks just burst out laughing
03:10:19 <Jafet> Doesn't eclipse use Hibernate?
03:10:20 <aristid> chrisdone: you know the good old joke about "eight megabytes and constantly swapping"?
03:10:33 <everythingWorks> i like eclipse :pp
03:10:43 <everythingWorks> Im used to use it from java :/
03:10:59 <chrisdone> aristid: yeah, eclipse and netbeans are the new emacs
03:11:07 <everythingWorks> Would be interesting if i would be more productive using vim
03:11:16 <aristid> chrisdone: should i switch from haskell-mode to haskell-ide btw?
03:11:45 <chrisdone> aristid: stop making up names for my project :p i swear everytime you mention it you say something different
03:11:49 <elliott> chipdude: HA HA HA HA HA HA HA
03:11:50 <elliott> Oops.
03:11:52 <elliott> *chrisdone:
03:12:10 * chrisdone high-fives elliott
03:12:21 <aristid> chrisdone: oO
03:12:32 <aristid> chrisdone: i think i haven't talked to you about it before :)
03:12:35 <elliott> chrisdone: You should make emacs-hs-support support lots of features so that haskellmacs gets better.
03:12:42 <elliott> Then everyone will use emacskell rather than haskell-mode.
03:12:49 * chrisdone giggles
03:13:21 <chrisdone> aristid: i anticipated such questions: there's a one liner in the readme file to boot it up with a fresh emacs to try it out. from that you can play around and decided if you want to switch to it
03:13:56 <dzhus> Why Aeson fails to parse "{\"a\": null}"? Null is valid JSON value
03:14:32 <Sgeo> everythingWorks, literate style means everything is a comment by default unless otherwise specified
03:14:43 <Sgeo> Lines of code in traditional literate Haskell style begin with >
03:14:50 <elliott> dzhus: What error?
03:15:25 <everythingWorks> sgeo: okay. What's the recommended way?
03:15:32 <chrisdone> dzhus: sounds like you're trying to parse it into the wrong type?
03:16:03 <Sgeo> everythingWorks, for most code? Probably not literate, unless you're writing a tutorial or something.
03:16:05 <Sgeo> I think
03:16:16 <everythingWorks> I understand :)
03:21:40 <rostayob> Sgeo: I've seen a lot of literate code in the base library, and GHC as well
03:22:00 <rostayob> mainly using the LaTeX syntax (\begin{code}...\end{code{)
03:22:35 <elliott> GHC likes literate haskell
03:22:38 <elliott> but base avoids it for portability iirc
03:22:54 <rostayob> yeah maybe it was GHC code...
03:24:52 <everythingWorks> rostayob: Didnt thought so. just prefix code with a '>' - char seems far simpler and more comfortable
03:25:01 <everythingWorks> think*
03:25:39 <jedai> everythingWorks: Well yes but the latex variant is noce because ... LateX ! And for mathematical and CS theory papers that's interesting
03:25:48 <jedai> s/nice/nice
03:26:03 <jedai> s/noce/nice
03:27:09 <jedai> everythingWorks: Beside in the LaTeX variant you don't need to put the same thing before each of your line (though haskell-mode handles that IIRC)
03:31:52 <ddarius> For making papers from Haskell code, I'd say to use lhs2TeX
03:33:53 <everythingWorks> kk thanks
03:39:37 <ddarius> elliott: Also, to be clear about something earlier, when I was saying "man-centuries" I was saying a -single- RDBMS implementation that you might use will likely have man-centuries of effort spent just on implementing/tuning it, not that there are man-centuries of effort in the field overall (there are orders of magnitude more) or man-centuries of effort using RDBMSes (there are several orders of magnitude more.)
03:40:05 * elliott was at least 60% kidding with the COBOL comment.
04:10:13 <statusfailed> Can anyone help me with this? http://hpaste.org/57146
04:10:22 <statusfailed> Attoparsec says "out of input" when I run main, but I don't see why
04:10:31 <statusfailed> oh wait
04:10:34 <statusfailed> maybe I do
04:11:10 <statusfailed> no I don't
04:11:24 <nand`> cabal fails: http://pastebin.com/dWYJ8u6q any clues?
04:11:26 <mauke> I have copied your paste dWYJ8u6q to http://hpaste.org/57147 - pray I don't copy it any further.
04:11:52 <nand`> running debian wheezy, in which libgmp3c2 is deprecated
04:12:49 <MarcWeber> statusfailed How do you cope with such situtation?
04:13:00 <MarcWeber> How do you track down "unexpected results"? You try to narrow down the test case
04:13:13 <MarcWeber> Thus remove items from both: the parser and the input unil you have success
04:13:23 <MarcWeber> Then add items again till you find the thing causing the trouble.
04:13:46 <MarcWeber> Thus start by parsing "var" only, pasre "var" and skipSpcase, parse "var" and identifier etc.
04:14:21 <nand`> found out what my problem was
04:15:47 <srhb> For looping over and doing "something" on a number of input lines, is the idiomatic solution something along the line of forM lines $ \l -> do ... ?
04:16:29 <chemistree> ahihi2
04:16:54 <elliott> srhb: forM_
04:17:00 <elliott> forM accumulates a list
04:17:05 <elliott> (and thus leaks memory for things like that)
04:17:08 <srhb> elliott: Ah yes. Thanks.
04:17:32 <mm_freak> srhb: if you don't expect the result to be another list, foldM is more like what you want
04:17:39 <elliott> nand`: What did you change, if cabal worked before?
04:19:06 <nand`> elliott: upgraded from squeeze to wheezy, which removed the deprecated libgmp3c2. However, ~/.cabal/bin/cabal was still built against the old version. Solved by running /usr/bin/cabal install cabal to recompile the local version
04:19:45 <statusfailed> MarcWeber: oh, well it's the endOfLine.. odd
04:20:12 <statusfailed> oh..... skipSpace must include newlines
04:20:38 <elliott> nand`: You'll need to recompile every local package, then.
04:20:41 <aadrake_> So I'm trying to use the normaldistribution library, and in main I have samples <- normalsIO (which works fine in GHC) but when I try to runhaskell with that in main I get an error I don't understand about ambiguous types: Ambiguous type variable `a0' in the constraints: (System.Random.Random a0) arising from a use of `normalsIO'
04:20:43 <elliott> Since gmp will be linked to all of them.
04:20:58 <aadrake_> I mean it works fine in GHCi
04:21:05 <elliott> aadrake_: That's because of defaulting.
04:21:13 <aadrake_> However, in ghci, :t samples is just [Double]
04:21:16 <nand`> elliott: feared as much. any easy way to do it all? or do I delete my bin folder and wait for error messages?
04:21:25 <elliott> aadrake_: Basically, your samples can be [a] for any instance of Random a.
04:21:37 <elliott> In GHCi, it picks Double for you.
04:21:44 <aadrake_> elliott: So I should just add ::Double and everything will be fine?
04:21:51 <elliott> aadrake_: :: IO [Double] should do it.
04:21:58 <elliott> After normalsIO.
04:22:22 <aristid> nand`: if you delete ~/.ghc and ~/.cabal, you have a clean slate :>
04:22:27 <chemistree> foldplop
04:22:46 <MarcWeber> statusfailed well done :)
04:23:14 <statusfailed> MarcWeber: thanks ^^
04:23:22 <elliott> nand`: cabal install --reinstall world.
04:23:23 <statusfailed> (for the kick up the arse~)
04:24:01 <nand`> elliott: thanks
04:24:32 <aadrake> elliott: Works like a charm, thank you.  Also, is there an equilvalent to push and pop functions in Haskell?  Now that I have an infinite list of values I'd like to pop them off the list as they're used so that they don't get reused.
04:24:54 <elliott> aadrake: That's a bit of an imperative mindset ;)
04:24:59 <aadrake> elliott: I know :)
04:25:02 <nand`> aadrake: I don't know the context but I think you want the state monad here
04:25:05 <elliott> You could use an IORef or a State monad, but structuring your program as a scan or a fold or such is better.
04:25:28 <aadrake> nand`: I was reading about the State monad yesterday but it seemed overly complex for what I was after.  Maybe I'll have to go that route.
04:25:28 <elliott> (Or any other kind of traversal.)
04:25:55 <nand`> aadrake: http://learnyouahaskell.com/for-a-few-monads-more#state see the headline called "stacks and stones"
04:25:56 * elliott would not suggest the state monad here.
04:26:08 <elliott> Yes, it can implement stacks, but a stack probably isn't what's really desired.
04:26:20 <nand`> but what elliott said is probably more important
04:26:24 <nand`> unless you intend on writing poor haskell
04:26:27 <aadrake> elliott: I don't really need to traverse on the list of values though.  I just need random numbers here and there to incorporate into calculations and it's important that the numbers are not reused.
04:26:38 <nand`> so use random
04:26:50 <elliott> aadrake: *shrug* -- you could just sprinkle randomIO everywhere.
04:26:55 <elliott> But it won't help you learn Haskell.
04:27:07 <nand`> the idiomatic random solution is to use (RandomGen g) => State g
04:27:12 <elliott> I mean, if you're going to do it like that there's no point using an infinite list like that.
04:28:32 <aadrake> elliott: I was originally trying to keep everything as pure as possible, but it got to the point where I was spending hours trying to figure out how to perform the equivalent of rand() in other languages so I kind of gave up.
04:30:12 <elliott> aadrake: that's what happens when you learn a language that isn't a carbon-copy-with-slightly-different-syntax to every other language you know :P
04:30:27 <nand`> randomList = unfoldr (Just . random)
04:31:13 <aadrake> elliott: Well I think you'll agree that just as some things that are complicated in other languages are easy in Haskell, there are some things that are complicated in Haskell that are easy in other languages.
04:31:25 <nand`> aadrake: well if you're mixing IO and random values and you don't mind going impure you can just use randomIO
04:31:53 <elliott> aadrake: I don't, really; Haskell is my favourite imperative language and like I said it's perfectly possible to do such a stack thing in Haskell.
04:32:03 <aadrake> nand`: The way I was trying to get around making the function impure was to create the infinite list of randoms and pass that as an argument into the pure function.
04:32:19 <elliott> But -- no offense -- but I wouldn't really consider someone new to a language qualified to judge whether it's possible to write some code easily and elegantly in a language.
04:32:55 <nand`> imperative programs are just State World
04:33:03 <aadrake> elliott: Yes, if you take the "Haskell is the most beautiful imperative language ever invented" approach then many of the differences become syntactic.  Philosophically though, the language is much different than C or Python or Ruby.
04:33:14 <elliott> (Certainly some things are easier in other languages, but when it isn't down to library support it's probably not because they're imperative -- for instance, J is better at array processing.)
04:33:14 <aadrake> elliott: No offense taken.
04:33:34 <elliott> aadrake: Philosophically, yes, i.e. there's a culture of preferring functional programs.
04:33:37 <elliott> nand`: No.
04:33:42 <elliott> nand`: That model can't account for concurrency.
04:33:58 <nand`> aadrake: you can't create an infinite list of randoms in a pure way unless you pass it a random generator, and if you're passing around a random generator then the function you pass it to needs to be aware of a random generator too, etc.
04:34:29 <elliott> aadrake: But this will probably become a flamewar if I respond any further, so I'd just ask you to defer your judgement until you have more experience with Haskell before writing it off as theoretically interesting but a pain to actually do things in -- the learning curve is steep mainly because of your prior experience with other languages that are very different.
04:34:37 <nand`> elliott: true, though it will account for pseudo-concurrency / multi-threading on a single core machine, assuming you implement your own scheduler
04:34:52 <aadrake> elliott: Actually, it's not a pain to do most things in.
04:35:41 <elliott> aadrake: Anyway, you should probably check out http://hackage.haskell.org/package/MonadRandom.
04:36:25 <aadrake> elliott: Thank you for your help.
04:43:06 <blub__> ?
04:43:09 <nand`> good introduction to monad transformers and how to use them?
04:43:17 <blub__> sry wrong window
04:43:31 <elliott> nand`: Does LYAH not cover them?
04:44:04 <elliott> They're just type constructors of kind (* -> *) -> * -> * that transform a monad into another monad, where you have lift :: (Monad m) => m a -> t m a (where "t" is the transformer).
04:44:19 <nand`> elliott: it doesn't in the chapters I've read, unless they're covered in the last chapter, "zippers"
04:44:20 <elliott> How they transform the monad is up to them; e.g. StateT s m a = s -> m (a, s)
04:44:25 <elliott> nand`: They won't be.
04:44:51 <nand`> I see
04:44:52 <elliott> (Most monads can be derived from their transformer form, e.g. State s = StateT s Identity, and indeed that's how they're defined in the mtl.)
04:45:25 <elliott> tl;dr: They're monads which take a monad as a parameter, and you can run actions in the parameter (the "transformed" monad) in them.
04:45:28 <nand`> what's an example of when they're useful?
04:45:57 <elliott> Everywhere.
04:46:04 <elliott> If you want state while doing IO, StateT s IO.
04:46:06 <galvatron> nand`: "All about monads" has good examples (http://www.haskell.org/haskellwiki/All_About_Monads)
04:46:15 <elliott> If you want to carry around an environment, ReaderT r m.
04:46:36 <elliott> If you want to keep an accumulator which you update based on state and external input, reading from an environment:
04:46:55 <elliott> ReaderT MyEnv (StateT MyState (WriterT MyAccum IO))
04:47:05 <aristid> elliott: RWS!
04:48:47 <elliott> aristid: That was completely accidental :(
04:49:15 <aristid> elliott: you didn't mean to build a RWS without RWS?
04:49:32 <elliott> I didn't mean to build a RWS at all.
04:50:41 <aristid> why did you, then?
05:44:33 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r", "GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors:  http://hpaste.org/new/haskell", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://bit.ly/5mwtRQ",  "admin/spam issues: #haskell-ops"]'
05:44:33 --- topic: set by copumpkin!~pumpkin@unaffiliated/pumpkingod on [Sat Dec 17 14:06:48 2011]
05:44:33 --- names: list (clog stephenjudkins Cromulent peterjoel owst xinming danharaj jutaro smarter jklvxnasd watermind liyang Blkt cwb` bru`` LMolr DevHC_ piotr_ gehmehgeh SG11 ProfDrum jamiltron fantasticsid Guest93002 pcavs MoALTz sebz erus` Proge schlicht empity alpounet galvatron Jonno_FTW xcombelle ft mjga dnjaramba_ cfricke hajimehoshi jem777 bytbox stulli pommes_ ceii_ mceier vikramverma frusen X-Scale reshef phyrex1an The_third_man MaciejP trin_cz Chaze twanvl danvet)
05:44:33 --- names: list (dMazz fbern ttt-- [[zz]] MrFahrenheit plutoniix iago donri zhulikas Shammah Aune baldo1 Spockz` ceii dschoepe der_eq kevinqcs takuan nexx OscarZ ksion pcapriotti faber mpiechotka blub__ adlan TheJH emmanuelux master_of_master dflemstr MK_FG copumpkin mreh QinGW` SHODAN awgn tty7 shintah srhb ablokzijl hrehf RayNbow Eduard_Munteanu ksf_ lpeterse mekeor edon milessabin pikhq_ Snark fengshaun albel727 insomniaSalt kaf3ii mmaruseacph2 derpladee homie jaspervdj)
05:44:33 --- names: list (bkolera nexion dzhus h00k_ mimico_ BlastHardcheese rsmith cdidd Palmik lukexi augur MaskRay areil Skhaz_ axeljohnsson sanjoyd sbahra Shou- stekro dmos ccc scm mgsloan Lemon DasIch Philippa_ gwern wespee vili otto_s Argue jtannenbaum Axman6 russellw Cale phenom_ xrl strmpnk srid bcoppens ftrvxmtrx pranq blast_hardcheese zeiris koeien tromp_ purpleposeidon nyingen danlndi jonathanj Yarou_ tempire ahf zw01 dufflebunk ulfdoz xcv wwkeyboard elliott joe9)
05:44:33 --- names: list (levitation[A] rprije mulletron Ralith rtharper gentz tauntaun roconnor tgeeky theorbtwo rostayob exobit ajhager tavelram cheater_ SonicvanaJr gdsx Veinor Sgeo hydo trhodes JaffaCake1 jfredett dubellz vav Martty PreciousMetals unixpro1970 brodo amiri Spockz_ cubi c_wraith cmccann fryguybob_ blackrain klugez janne lnostdal bgamari take_cheeze sunfun magicman kallisti akosch blbrown_win3 brandonw Eelis lusory SphericalCow Anoq xarch EarlGray^ sei8 nus)
05:44:33 --- names: list (nowhereman teiresias Bwild popx gltest_ jsgf hiptobecubic drwho eno daimrod oleiade_ dino- zax_ BlankVerse yrlnry Smokey` mrdomino avocado EyesIsServer otk ovechkin floomp parcs` confab taruti sysop_fb timemage TTimo1 cheater irene-knapp HisDivineShadow chops vithos __main__ c1de0x Zephyrus gniourf_gniourf ambroff ozgura idoru tener_ bezik stepcut em kakos alios noam__ tsuraan_ Nimatek shepheb Blub\0 proq vold pr Gunni Valodim Nisstyre hamilyon mee srh)
05:44:33 --- names: list (Zamarok brendyn dreixel linduxed tazjin|away enobscuratus Belgarion schroedinbug gbeshers bl4ckcomb smly- davidL mr_sleepy lomeo gtirloni newsham lambdabot dcoutts_ kosmikus ernst gredman idnar Olorin- callen mercury^ guibou darkgerm kaol dannynn folone chee1 gmcabrita ArchGT frerich2 matthiasgorgens ujm ketil borkman hang hugin adnap jedai Tinned_Tuna Khisanth anders^^ burp jd10 saati_ proqesi` abc05 maloi Masxmasx jlaire hpc drbean Varakh kanak Razz)
05:44:33 --- names: list (ville Jafet GeminiRai jonke ramier _root_ gemelen s4msung samek m3ga aliak Blazeix wagle rglenn srcerer kolmodin noddy maurer macUzer Muad_Dibber mlh Vq pdxleif preflex jix quicksilver perlite Amadiro hundskatt Boney_ rsimoes milkpost dimmy otterdam peterhil bartavelle Counter-Strike wunki iulian dkannan jbauman dings snetz edwtjo TacticalGrace kshannon hammi doubledensity nighty- brisbin `10 AtnNn chipdude BrianHV andrewsw ChristianS Draggor mxweas)
05:44:33 --- names: list (redheadphones Botje Baughn @ChanServ ian_mi MostAwesomeDude ciaranm SimonRC Krinn fall_ krakrjak twn choptastic_ guerrilla overrosy smop CosmicRay dp_wiz milli monochrom flux akahn wto adimit abbe j2jx si14 torkjak danols_work aristid Nshag Innominate Derander jlewis suiside a11235_ scgilardi poucet_ mateu joni6128 Hunner Zarathu ido zmoazeni_ lmatos kalven mdwright nots _jesse_ sordina ice799 jrslepak_ welterde bddn jyyou erg lukish Gilly __class__)
05:44:33 --- names: list (shoerain chr1s olsner Enigmagic ben Intensity ricky Solver m_stone tuv araujo mrshoe yeltzooo majoh jrk_ kleini__ davean ahkurtz k0ral ski comak zenazn loccipocci lpsmith Corey copton othiym23 epdtry DustyDingo arcatan hackagebot freedrull Nereid tessier FireFly trez cygnus_ prof7bit jml gwillen mortberg Nanar Internet13 cods setmeaway2 polux_ hirsch_ sully plat0 dmwit Ornedan tommd jonafan johs mjhan Liskni_si jimleroyer Dashkal Taggnostr2 cschneid)
05:44:33 --- names: list (HalfWayMan lebastr hiredman R496_ mantovan1 flori warpy caligula_ gereedy i1126 saiam waterlaz ve Boxo pyryp pettter aszlig birkenfeld tlockney nniro arkx Twey EvanR adnam SamB_XP yottis herself boyscared IvdSangen solarus blooberr sohum elliottcable liesen bradwright bobry lopex nkpart arnihermann mimico wjlroe tomh ivan` niko mndrix wilfredh_ puzza007 earthy mauke demolithion LeNsTR|off Cerise ehuber Redshift64 jrockway args[0] _habnabit flamingspinach)
05:44:33 --- names: list (zaero brett dumael djanatyn zomg tafryn stchang harlekin Damn3d pi8027 kyagrd ormaaj inimino danm_ nihtml Saizan mendez jabirali McManiaC repnop ttvd nlogax buddyholly def-lkb tridactyla yezariaely davv3 Gothmog_ statusfailed Phlogistique xnyhps fwg obcode lokydor_ CrazyThinker Ptival etpace ChongLi KitB froztbyte franny kqr Jaxan Entroacceptor robinbb frigga bogner eviltwin_b ps-auxw KaneTW mokus_ Younos mike-burns eyck robbert Laney MrNibbles Starfire)
05:44:33 --- names: list (ibid danr amiller OnionKnight ddarius joeytwiddle CoverSlide hvr rby snorble And[y] mornfall gernot sjl atomicity dominikh eZet cncl companion_cube Dodek TML MightyMoose dropdrive antonh znutar felipe_ almostsix drdo ousado zenzike alexsdutton freiksenet iFire nominolo noplamodo Tene ClaudiusMaximus mimi_vx wavewave nicoo Gracenotes benj_ kissyboy ion A1kmm jrib sp3ctum aleator dcguru dogmaT edwinb levi Astro thetallguy1 saruman_ mattp_ angstrom stepnem)
05:44:33 --- names: list (tomku DrSyzygy vmeson sunnavy_ afarmer osfameron szbalint pantski Igloo pou ahihi2 norm2782 mjrosenb moonlite ocharles jakky opqdonut Obfuscate Mitar chra xsysstar xplat Arnar kloeri jcapper Maxdamantus noj ehamberg Deewiant scsibug marienz clsmith tomaw peddie kate_r zorzar tg Will| jbalint_ ixzkn_ shachaf mroman sahn_ seats kniu `0660 tomprince thetallguy wingless impl mbernstein Aikawa Dave2 Raynes tamiko jamiely_desktop biio brainproxy koninkje_away)
05:44:33 --- names: list (mikeplus64 sagelywizard jlouis rwbarton ByronJohnson devn saurik Yahovah_ Runar shutdown_-h_now helgikrs1 bford bmiddleton etabot profmakx dilinger acfoltzer jakeskik ubiquill jmcarthur djahandarie sm integral mm_freak dever MarcWeber skaar hyko thirsteh brixen dlmalloc mejalx Clint dqd alip Mathieu jayne alistra Vulpyne sipa elgot lispy bbee sahazel_ int-e nibalizer joshc bd_ hzh zygoloid confound `Zerax` mrd ziman BRMatt jackhill Lemmih lefant_ Ke)
05:44:33 --- names: list (reacocard quaestor CindyLinz snarkyboojum dcolish tsuraan__ PHO_ thorkilnaur dabradley aninhumer Yacoby dom96 naneau Jaak Guest61372 eigenwea1e dixie ybit koala_man shawn byorgey wires cynick deavid cjay Dybber anachron wayne[mobile] endojelly luite electrogeek inr petanqk dju ray audunska Eliel rvncerr mike1703 limetree ptrf c2thunes alexbobp nimred mietek emias)
05:44:57 <byorgey> > let lst = [Just 4, Nothing, Just 5, Nothing] in [x | Just x <- lst]
05:44:58 <lambdabot>   [4,5]
05:45:04 <Saizan> watermind: i meant more M-x set-input-mode RET Agda RET
05:45:34 <watermind> Saizan: I see, sorry never seen that before...
05:45:43 <stulli> Lemmih: Oh, i didn't think about list comprehension at all. Currently i'm doing recursion + pattern matching
05:45:52 <hpc> > compare '“' '"' -- Lemmih, here's your problem with that string above
05:45:54 <lambdabot>   GT
05:46:08 <hpc> > "你好" -- note the end quote
05:46:09 <lambdabot>   "\20320\22909"
05:46:15 <Lemmih> hpc: Oh dear, you're right.
05:46:43 <byorgey> stulli: you can also write a function like   isJust (Just _) = True; isJust _ = False  and then do 'filter isJust'
05:46:56 <byorgey> stulli: but there is no automatic way to derive the isJust function
05:47:13 <watermind> Saizan: it worked! nice :)
05:47:17 <hpc> byorgey: im sure there's TH to do it though
05:47:33 <byorgey> hpc: yeah, I'm sure there is in some package somewhere
05:47:47 <byorgey> probably not worth it for stulli though.
05:47:52 <stulli> byorgey: thanks, that also looks nice
05:48:07 <hpc> @hoogle isJust
05:48:07 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
05:48:17 <stulli> no, TH would be serious overkill i guess
05:48:45 <byorgey> yeah, isJust already exists, I was just showing how to write that type of function in general
05:49:23 <byorgey> if the constructor has lots of fields you can also use the record syntax trick, like so:
05:49:46 <byorgey> isCtorWith30Fields (CtorWith30Fields {}) = True; is... _ = False
05:50:02 <byorgey> since otherwise you would have to write  (CtorWith30Fields _ _ _ _ _ _ _ _ _ .....)
05:51:45 <stulli> heh, nice
05:52:48 <shachaf> I think in the case that your constructor has 30 fields, you have other issues to worry about.
05:53:08 <byorgey> true.
05:55:13 <mjga> shachaf: what issues? I actually have datatype with 50 constructors, each of them with up to 13 fields
05:56:19 <shachaf> What datatype is that?
05:59:02 * hackagebot hactors 0.0.3.1 - Practical actors for Haskell.  http://hackage.haskell.org/package/hactors-0.0.3.1 (HekaTreep)
06:01:10 <rwbarton> it takes a long time to describe
06:03:14 <mjga> shachaf: intermediate representation during parsing
06:03:34 <mjga> shachaf: ASTs are commonly contrived and complicated things :-)
06:04:22 <shachaf> Ah.
06:04:34 <Saizan> which language?
06:04:42 <shachaf> I would think that you could chunk some of the fields together or something. But perhaps not.
06:04:59 <mjga> Protein DataBank, I hope to put it to Hackage soon
06:07:43 <mjga> shachaf: actually there are thousands of formats that Haskell does not yet parse, if you want to play with parsing
06:07:45 <mjga> :-)
06:13:13 <ion> I wonder if the author of hactors knows about remote?
06:17:31 <Grace_> hello
06:21:57 <mekeor> hello, Grace_
06:25:41 <Grace_> I have some problem with code to find an intersection of two user-defined 'Set x' as below:
06:25:42 <Grace_> intersectS :: (Ord a) => Set a -> Set a -> Set a
06:25:44 <Grace_> intersectS (Set xs) (Set ys) = Set $ intersect xs ys
06:25:45 <Grace_>            where
06:25:47 <Grace_>                 intersect [] ys = []
06:25:48 <Grace_>                 intersect xs [] = []
06:25:50 <Grace_>                 intersect (x:xs) (y:ys)
06:25:51 <Grace_>                           | x == y = Set (addS x (intersect xs ys))
06:25:53 <Grace_>                           | otherwise = x:intersect xs (y:ys) || y:intersect (x:xs) ys
06:25:54 <Grace_> When I load it, the interpreter says:
06:25:56 <Grace_> Couldn't match expected type `[a0]' with actual type `Set a1'
06:25:57 <Grace_>     In the return type of a call of `addS'
06:25:59 <Grace_>     In the first argument of `Set', namely `(addS x (intersect xs ys))'
06:26:00 <Grace_>     In the expression: Set (addS x (intersect xs ys))
06:26:02 <Grace_> Failed, modules loaded: none.
06:26:03 <Grace_> with addS is to add an element to a Set.
06:26:05 <Grace_> Thanks.
06:26:24 <elliott> Grace_: please use hpaste.org for pastes of >1 line in future
06:26:51 <jedai> Grace_: You should use hpaste instead of pasting your code directly in the channel (that's valable everywhere not just on #haskell)
06:27:01 <jedai> @where hpaste
06:27:04 <lambdabot> http://hpaste.org/
06:27:38 <Grace_> sorry how to use it because I am new.
06:27:55 <jedai> Grace_: go there
06:28:22 <Grace_> I got it. Thanks.
06:29:20 <jedai> Grace_: anyway your problem seems to be that you're conflating two types here : your Set (which are just a wrapper around lists) and lists
06:30:07 <jedai> Grace_: especially, the result of intercept is a list, but you call addS on it, addS seems to work on Set (that's what the error says)
06:31:45 <jedai> Grace_: then there is the || between two lists ? what does it mean, is it an user-defined operator ? if yes, this is probably a bad idea since (||) is usually reserved for the boolean or
06:34:12 <Grace_> It's just my logic. I thought of comparing two heads of two Sets, if they are equal, then add them to the Set and recursively traverse the two tails of the two Sets. And otherwise traverse the list with x is head or y is head.
06:35:38 <jedai> and ? what do you make of these traversal ? What would it means to "or" them ? You probably want to return only one list, so which will be returned by the or ?
06:35:56 <jedai> Grace_: Are the list in Set already sorted ?
06:36:10 <jedai> *Is
06:36:31 <Grace_> Maybe this won't work. Any ideas for a better approach? Thanks.
06:36:53 <Grace_> jedai: yest it is
06:36:58 <Grace_> *yes
06:37:39 <jedai> Grace_: Ah good, that simplify it quite a bit, since that means you can check if there's ever a chance of x being in ys
06:38:32 <jedai> Grace_: the case for x == y is fine (just replace addS by something that work on list rather than set : how do you add an x to a list ?)
06:39:14 <jedai> Grace_: the problem is that you didn't separate the case where x < y from x > y, when you'll do that the right way should be clearer to you
06:40:47 <Grace_> Maybe you misunderstand this. I am working on a User-Defined set which is:
06:40:49 <Grace_> data Set x = Set [x]
06:40:51 <Grace_>                     deriving (Show,Eq,Ord)
06:41:46 <hpc> Grace_: it's still sorted, so you still need to separate the cases
06:42:16 <jedai> Grace_: No, I don't misunderstand. You seems to be confused on the type of your functions. intersectS :: (Ord a) => Set a -> Set a -> Set a
06:42:49 <jedai> Grace_: but your local function intersect only works with lists (sorted though)
06:43:15 <jedai> Grace_: intersect :: (Ord a) => [a] -> [a] -> [a]
06:45:08 <jedai> Grace_: just try to handle those two case I indicated and think if x has a chance to be in ys or y in xs
06:46:20 <Grace_> so in the where clause, it should be:
06:46:21 <Grace_>      intersect [] ys = Set []
06:46:23 <Grace_>      intersect xs [] = Set []
06:46:24 <Grace_> for the first two cases.
06:46:26 <Grace_>   
06:47:11 <jedai> Grace_: No, not if you keep "intersectS (Set xs) (Set ys) = Set $ intersect xs ys"
06:47:33 <jedai> Grace_: intersect must return a list
06:47:49 <Grace_> I see
06:48:11 <luite> if you have a haskell program that has some problems, and you suspect that somewhere deep in the dependencies lies the cause, how would you debug that, if it's difficult to manually reconstruct the data/function calls that lead to the problem?
06:50:38 <mjga> luite: divide and conquer
06:50:59 <luite> mjga: what's that in practical terms?
06:51:26 <mjga> luite: try a minimal test case, and then try to split your program in half until you know in which part/call to dependencies the problem lies
06:51:41 <mjga> luite: hard to be more specific, if you don't tell anything else about the problem
06:52:30 <elliott> luite: Sprinkle error calls in places, -xc?
06:54:35 <jedai> luite: What kind of problem ? error call ? wrong result ?
06:55:37 <luite> mjga: hm, right, the particular example I had isn't really valid anymore since I found some deeper function that I could call
06:56:16 <luite> mjga: but it often happens when debugging web apps, you have a specific combination of user session data, some other web app state, database connections and an exception from some deep depenceny
06:56:32 <luite> elliott: that only works if it happens in your own package, right?
06:57:01 <elliott> luite: Well, sure.
06:57:01 <luite> elliott: I mean, would you modify lots of existing packages and add error calls all over the place?
06:57:13 <elliott> no
06:57:23 <luite> if you do: how do you reinstall them without breaking the rest of the packages :p
06:58:52 <luite> hmm, I just mean, if you could set a breakpoint, and inspect the data, you have a much better starting point for investigations than when you have to "manually" (Reading haskell source) reconstruct everything in a test program, especially if lots of external things (database, user web request) are involved
06:59:23 <jedai> luite: you know about the ghci debugger right ?
07:00:08 <luite> I feel totally lost when debugging those issues, tend to rebuild cabal-dev environments with different package versions (takes more than half an hour each for a yesod web app) or test versions with trace stuff
07:00:44 <luite> jedai: I know it exists, but have no idea how to use it for these situations, is it even possible to debug other (compiled) packages with that?
07:00:47 <mjga> luite: usually it is good enough to validate data before and after call to another package. I must say that I live by putStrLn and show most of the time :->. as far as I split the problem well, it becomes easy anyway
07:02:05 <elliott> mjga: putStrLn and show? you're in for a treat: there's a *predefined composition* of those!
07:02:30 <brill> Just installed haskell on Debian on Emacs. *That* was easy
07:02:35 <luite> mjga: well, that works sometimes, but only for data that's actually showable
07:02:52 <luite> try to do it with a GHC AST
07:04:00 <elliott> deriving instance Show ...
07:04:03 <mjga> luite: I have a MissingInstances module that makes everything showable, and complain about GHCi whenever it says it cannot show something, since I believe it should simply show the type in one line and comment -- missing Show
07:04:14 <luite> everything?
07:04:23 <elliott> instance Show a where show _ = "something"
07:04:31 <luite> yes very useful :)
07:06:09 <mjga> @src print -- I know Elliot, not that it is important to know it
07:06:09 <lambdabot> Source not found. :(
07:06:24 <mjga> @src print
07:06:24 <lambdabot> print x = putStrLn (show x)
07:06:24 <elliott> the only output you need is whether your expression diverges or not
07:06:33 <elliott> instance Show a where show a = "maybe..." ++ a `seq` "yep"
07:07:19 <nand`> is there any way to get a list of all pkg-config prerequisites I'd need to install a cabal package? going back and forth between cabal install and apt-get is annoying, if it could just tell me ahead of time what packages I'm going to need I could preinstall them
07:07:37 <mjga> elliot: the point was that difference of print vs GHCi debugger is convenience, but not the order of time that you spend debugging. careful unit testing and splitting modules gives you an _order_ of magnitude improvement when searching for error
07:08:29 <Saizan> nand`: i don't think there's a command for that, so you're stuck with reading the .cabal files
07:08:32 <mjga> elliot: though I must agree that -xc gives similar improvement, given that without it one is pretty much at loss as to where in thousand lines the problem may be (if a program is long enough)
07:08:32 <luite> hmm, I specifically meant errors deep in dependencies
07:09:03 <mjga> luite: is it a regression, so that you know a package version that fixes it?
07:09:03 <elliott> mjga: btw, i only get nick-pinged with the extra "t" (maybe i should fix that :P)
07:09:04 <Saizan> nand`: unless these packages have configure scripts too, in which case it's harder
07:10:32 <mjga> elliott: crap! if only I knew how to configure xchat so that it nick-pings properly... or found a better IRC agent that is GNOME-ish, libnotify-ied and has such a feature (Emacs excluded - sorry I am VIM guy)
07:10:55 <luite> mjga: hmm, well the particular problem I was debugging is now narrowed down to 3 packages or so, I still don't know exactly where, but it's not that bad anymore
07:11:22 <elliott> mjga: doesn't <tab> work to complete nicks?
07:11:26 <mjga> elliott: correctness of my typing is a known problem, with a lot of GHC-generated documentation in form of err msgs
07:11:26 <elliott> does for me
07:11:32 <elliott> oh, you want colon rather than ,?
07:11:36 <elliott> that's in the setting
07:11:37 <elliott> s
07:11:49 <mjga> luite: which packages? are they interdependent?
07:11:53 <elliott> (interface -> input box, also I generally set the sorting to last-spoke order)
07:12:07 <luite> mjga: tls-extra, tls, http-conduit, authenticate
07:12:16 <luite> and certificate
07:13:41 <mjga> so I understand that when you switch off encryption the problem disappears? what about using a different certificate type?
07:14:03 * hackagebot cabal2nix 1.24 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.24 (PeterSimons)
07:15:15 <mjga> elliott: are there any irc clients that do proper nick spellchecking?
07:15:19 <luite> mjga: oh the problem is in the certificate validation of BrowserId authentication certificates, can't just disable encryption there
07:15:49 <elliott> mjga: I doubt it, though xchat has scripting support
07:16:38 <mjga> elliott: in python, but not in haskell ;-)
07:17:56 <nand`> I wish weechat had Haskell support
07:18:12 <elliott> mjga: there's a python<->haskell bridge :P
07:18:20 <luite> mjga: but there are often similar problems, recently someone reported that sessions disappear when deploying yesod on heroku. now heroku is extra difficult because you don't have ssh access, but at least if you could set a breakpoint on the session validation function, you could see if that's where the session is rejected, and if so, if the session data is corrupted or the key is incorrect etc
07:19:05 <luite> if you can't break there, you can print the session cookie back to the user, perhaps the session encryption key, but if that's not it, how do you find out where the problem is? these are things that are usually done automatically by the web framework
07:19:13 <mjga> luite: so you don't have logging monad handy in there, do you?
07:19:30 <luite> well everything is MonadIO
07:20:07 <mjga> could you inject logging for changing of connection status?
07:21:24 <luite> that means reinstalling dependencies, right? say I have dependency x, and it depends on 20 packages, and 50 other packages depend on it, all in a cabal-dev setup. how do you reinstall that package with extra logging, without bracking the rest?
07:22:49 <luite> if there's an easy way to do that, that would solve most of these issues for me
07:29:05 <mjga> luite: I don't know, ssldump?
07:32:07 <morq> hi, i need help with haskell, i got an exame next week an i need to learn haskell for that, i allready had it last year, so i only need to refresh it
07:32:17 <morq> problem is, my stuff doesnt work anymore
07:32:26 <morq> for example a funcito is
07:32:34 <morq> nand a b = not (a&&b)
07:32:47 <morq> i allways got an error on the =
07:33:05 <Clint> mmm... funcito fresco
07:33:27 <morq> i dont know with standart it is we are suposed to use
07:33:28 <luite> morq: that doesn't work in ghci
07:33:40 <luite> (although perhaps in ghci 7.4)
07:33:40 <morq> why?
07:34:08 <jedai> morq: ghci is like a do-block, declarations of functions or vaue have to be done after a let
07:34:33 <jedai> morq: in a file, your nand would work perfectly
07:34:37 <morq> ah ok, so let nand a b = not (a&&b) ?
07:34:42 <luite> it's better to use a file, and then :l filename in ghci
07:34:51 <morq> ok thanks
07:34:55 <morq> ill try
07:35:24 <jedai> morq: Yes, though if you want some permanence make some scratch file and load it into ghci (note that haskell-mode for emacs is pretty good for that)
07:57:38 <galvatron> is there an easy way to interface State monad computations with non-State monad functions?  E.g., I have a function "foo :: a -> StdGen -> (a, StdGen)" which I need to call from a State monad.  I'm now doing it with "do rnd <- gets rnd; let (x,rnd') = foo a rnd; modify (\s -> s {rnd = rnd'}); return x"
07:58:02 <ion> @type state
07:58:03 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:58:37 <galvatron> but that feels a bit too verbose
07:58:46 <ion> @type state `asAppliedTo` (undefined :: StdGen -> (a, StdGen))
07:58:47 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> State StdGen a
07:59:23 <dp_wiz> http://zguide.zeromq.org/hs:wuproxy -- Why use 'fix' here? Wouldn't "forever" suffice?
08:00:29 <nand`> :t asAppliedTo
08:00:29 <lambdabot> forall t b. (t -> b) -> t -> t -> b
08:00:46 <ion> It doesn’t look like it’s the same as forever, but dropping the “fix” and replacing “loop” with “proxy from to” would work.
08:00:54 <ion> when more (proxy from to)
08:01:22 <nand`> @src asAppliedTo
08:01:23 <lambdabot> Source not found. My mind is going. I can feel it.
08:01:33 <dp_wiz> why not simply "forever $ do ...." ?
08:01:43 <ion> f `asAppliedTo` a = f `asTypeIn` ($a)
08:01:57 <ion> Because it’s not supposed to loop forever.
08:02:29 <nand`> ion: and asTypeIn?
08:02:33 <ion> @src asTypeIn
08:02:34 <lambdabot> a `asTypeIn` f = a where _ = f a
08:02:34 <lambdabot> infixl 0 `asTypeIn`
08:05:06 <jedai> galvatron: Did you get that you should use "state (foo a)"
08:07:05 <dp_wiz> ion: http://hpaste.org/57156 version i wrote. then i took a look at reference example and now wondering why this fix-shmix magick....
08:08:01 <jedai> dp_wiz: forever wouldn't allow you to choose if you want to loop (this version of proxy stop when there is no more to receive from "from")
08:08:33 <jedai> dp_wiz: basically you could get the same effect with an explicitely recursive function (but not with forever)
08:09:03 * hackagebot bson-generic 0.0.6 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.6 (PetrPilar)
08:09:04 <jedai> though you could get out of a forver with an exception but then you have to catch it, it's a bit dirty
08:09:30 <mm_freak> jedai: you can get out of forever with many monads
08:09:36 <mm_freak> Maybe, Either, Cont, etc.
08:09:43 <dp_wiz> wouldn't forever restart proxy inner loop again?
08:09:43 <galvatron> jedai: No, I don't think I understood exactly what was meant here :)
08:10:00 <dp_wiz> even if it chooses not to continue any more..
08:10:28 <jedai> mm_freak: Well right but in IO you have to use an exception (here he seems to be in IO)
08:10:43 <mm_freak> jedai: or MaybeT or ContT
08:10:46 <galvatron> I did write a helper function for calling random needing functions inside my monad, so that I can do "q <- withRnd (foo x)" where withRnd runs in the monad, gets the random state, calls my function, and puts the new random state back
08:11:00 <mm_freak> but a better approach is probably to use 'fix'
08:11:05 <mm_freak> fix $ \again -> …
08:11:05 <jedai> mm_freak: I said in IO, not monadio
08:12:04 <jedai> galvatron: so what was said is that to plug a function of type "s -> (a,s)" in State, you just have to use the function "state"
08:12:47 <jedai> mm_freak: That's what's done here with proxy but dp_wiz has a point since this proxy call is stuck in a forever... Maybe it's used somewhere else
08:12:49 <galvatron> jedai: oh, I wasn't aware of that function!  thanks, I'll poke around with that
08:13:07 <jedai> galvatron: thanks ion for it :)
08:13:26 <mm_freak> jedai: i wasn't really responding to that…  i was really just responding to your statement in isolation
08:13:37 <mm_freak> because the name "forever" is a bit misleading
08:14:15 <jedai> mm_freak: Well sure, in any monad where you can short-circuit you can get out properly of forever :)
08:14:48 <jedai> So what should it be named ? maybeForever'''orNot
08:15:11 <statusfailed> What would be a better way to write this? notEol c = Prelude.all $ [Char.isSpace, (/= '\n')] <*> [c]
08:16:02 <galvatron> ion, jedai: looks like I've been looking at old/wrong docs for the State monad :(
08:16:25 <nand`> why not just notEol c = isSpace c && c /= '\n'
08:16:53 <statusfailed> you know I genuinely don't know
08:16:56 <statusfailed> wtf
08:17:22 <ion> galvatron: http://www.haskell.org/hoogle/?hoogle=State and the first result.
08:17:39 <statusfailed> nand`: I guess I figured it would be cumbersome if I added more comparisons?
08:17:41 <nand`> but if you want to do it the pointless way, replace [c] with pure c then eta reduce it to get rid of the parameter name
08:17:53 <nand`> statusfailed: how is , , , more cumbersome than && && &&
08:18:03 <nand`> less*
08:18:20 <nand`> only reason I see to do it with the list applicative is if you want to generate a list of comparisons from somewhere else
08:18:28 <jedai> nand`: Well I guess he wouldn't have to put c in every one ...
08:18:43 <jedai> ;)
08:18:54 <dp_wiz> strange... for some reason c/cpp example also uses double "while(1)": http://zguide.zeromq.org/cpp:wuproxy
08:19:09 <lispy> hello
08:19:22 <statusfailed> jedai: I think that was my reasoning..
08:19:30 <jedai> dp_wiz: there may be some subtility of network design at play there... but I don't know enough to help any more
08:19:42 <jedai> lispy: hi
08:20:15 <nand`> > let numberwang c  = all $ map ($c) [(>5), (<10)] in numberwang 7
08:20:16 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
08:20:17 <lambdabot>         against inferred ...
08:21:08 <nand`> > let numberwang c  = and $ map ($c) [(>5), (<10)] in numberwang 7
08:21:09 <lambdabot>   True
08:21:58 <lispy> :t ($?c)
08:21:59 <lambdabot> Not in scope: `$?'
08:22:03 <lispy> :t ($ ?c)
08:22:04 <lambdabot> forall a b. (?c::a) => (a -> b) -> b
08:22:26 <jedai> lispy: it's the "apply to c" section
08:22:35 <nand`> :t ($)
08:22:36 <lambdabot> forall a b. (a -> b) -> a -> b
08:22:44 <lispy> yah, just trying to think if there is an easier way to write that in this case
08:22:56 <jedai> > ($ 8) (+1)
08:22:57 <lambdabot>   9
08:23:53 <lispy> :t map ($ ?c)
08:23:54 <lambdabot> forall a b. (?c::a) => [a -> b] -> [b]
08:25:29 <lispy> :t zipWith ($) ?fs (repeat ?c) -- not simpler
08:25:30 <lambdabot> forall b b1. (?c::b, ?fs::[b -> b1]) => [b1]
08:25:34 <jedai> lispy: there are other ways but this one is considered the most lightweight one AFAIK
08:26:10 <lispy> :t zipWith id ?fs (repeat ?c)
08:26:11 <nand`> the obvious other way is to use (<*>) as demonstrated earlier
08:26:12 <lambdabot> forall b c. (?c::b, ?fs::[b -> c]) => [c]
08:26:27 <statusfailed> What's all this crazy syntax flying about!?
08:26:50 <lispy> statusfailed: do you mean the ? for implicit parameters?
08:27:19 <statusfailed> lispy: Yeah, I was wondering what :: was as well, but I just realised i'm a dumbass
08:27:34 <elliott> statusfailed: (&&) <$> isSpace <*> (/= '\n') would also work.
08:27:46 <lispy> Nah, the implicit parameters stuff is kind of weird.  I only use it with lambdabot, myself
08:28:03 <jedai> ($c) <$> ...
08:28:47 <jedai> but ideally you'll want it in the other direction and I'm not aware of any operator that would do this directly ?
08:29:59 <elliott> > flip c [(>5), (<10)]
08:30:00 <lambdabot>   Couldn't match expected type `f (a -> b)'
08:30:01 <lambdabot>         against inferred type `Si...
08:30:03 <elliott> > flip [(>5), (<10)] c
08:30:05 <lambdabot>   [True,False]
08:30:12 <elliott> jedai: Caleskell to the rescue.
08:30:22 <elliott> > let numberwang = and . flip [(>5), (<10)] in numberwang 7
08:30:24 <lambdabot>   True
08:31:16 <lispy> elliott: do you know what instances that relies on?  I'd guess that something has an instance for [a->b] in play here
08:31:26 <jedai> @type flip
08:31:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:31:42 <lispy> ooh, I didn't even think about flip getting generalized to functor.  Clever.
08:31:48 <elliott> Clever and awful.
08:31:52 <jedai> ugh
08:32:14 <lispy> > flip (a,b)
08:32:15 <lambdabot>   Couldn't match expected type `a -> b'
08:32:15 <lambdabot>         against inferred type `Simple...
08:32:21 <lispy> > flip (1,2)
08:32:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (t, b))
08:32:22 <lambdabot>    arising from a use...
08:32:27 <jedai> Ok, (.) or (++) I can see it but flip...
08:32:31 <lispy> > flip (1,2) :: (Int,Int)
08:32:32 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
08:32:32 <lambdabot>         again...
08:32:35 <elliott> > flip ((+), (-)) 42
08:32:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
08:32:36 <lambdabot>    arising from a use...
08:32:40 <elliott> > flip ((+), (-)) 42 123
08:32:41 <lambdabot>   Couldn't match expected type `t1 -> t'
08:32:41 <lambdabot>         against inferred type `(a ->...
08:32:54 <elliott> :t flip (f::Expr->Expr,g::Expr->Expr)
08:32:56 <lambdabot> Expr -> (Expr -> Expr, Expr)
08:33:06 <elliott> > flip (42,f) x
08:33:06 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:33:07 <lambdabot>    `SimpleReflect.FromExpr ...
08:33:09 <elliott> *sigh*
08:33:12 <elliott> > flip (42,f) x :: (Int,Expr)
08:33:14 <lambdabot>   (42,f x)
08:33:17 <lispy> ?instances (,)
08:33:18 <lambdabot> Couldn't find class `(,)'. Try @instances-importing
08:33:25 <lispy> ?instances-importing (,)
08:33:26 <lambdabot> Couldn't find class `(,)'. Try @instances-importing
08:34:15 <lispy> Having a functor happy prelude
08:34:18 <lispy> oops
08:34:27 <jedai> elliott: that kind of makes sense (once you have tried them all for us) since functor instance is for (,) e
08:34:41 <lispy> Having a functor happy prelude could be handy, but I don't think I want it as the default
08:34:49 <jedai> ?instances (,) e
08:34:50 <lambdabot> Couldn't find class `(,) e'. Try @instances-importing
08:35:01 <jedai> ?instances-importing (,) e
08:35:02 <lambdabot> Couldn't find class `e'. Try @instances-importing
08:35:12 <lispy> ?instances Functor
08:35:13 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:35:16 <jedai> ?instances-importing ((,) e)
08:35:16 <lambdabot> Couldn't find class `e)'. Try @instances-importing
08:35:23 <jedai> bah
08:35:38 <lispy> instances is always the opposite of what I want :)
08:35:46 <elliott> lispy: (.) as (Control.Category..) is the reform all reasonable people support.
08:35:52 <lispy> I want to go from a type to a list of instances not from a class to a list of instances
08:36:13 <jedai> elliott: Yep, and (++) as `mappend`is quite nice too
08:37:23 <elliott> Yes.
08:37:32 <elliott> And map as fmap.
08:37:41 <mekeor> i want to add my data-type to Read but i unfortunately don't (really) understand the readsPrec-function. What does it do exactly?
08:38:21 <nand`> but fmap is already in prelude
08:38:29 <nand`> so it's just one keystroke
08:38:30 <jedai> mekeor: you know that you can just derive Read ?
08:38:37 <mekeor> jedai: yep
08:38:57 <jedai> mekeor: you want to do it by hand then  ?
08:39:04 <lispy> mekeor: http://stackoverflow.com/questions/5520940/creating-instance-of-read-type-class-in-haskell-for-custom-data-type
08:39:11 <jedai> @type readsPrec
08:39:12 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
08:39:14 <mekeor> actually i've got a function :: String -> MyDataType, but i wanna call that func "read"...
08:39:35 <mekeor> @type readPrec
08:39:36 <lambdabot> Not in scope: `readPrec'
08:39:42 <mekeor> :t readPrec
08:39:43 <lambdabot> Not in scope: `readPrec'
08:39:53 <mekeor> (readPrec is GHC only...)
08:40:01 <jedai> mekeor: Well readsPrec take priorities into account
08:40:44 <jedai> but if you just ignore that, it's close to what you already have (though it should keep the rest of the string after the parsed part)
08:41:13 <lispy> mekeor: keep in mind, Read/Show are really for programmer output/input.  If you need serialization, a proper parser, or you're building a language you really want something else.
08:41:33 <mekeor> lispy: hmm. i see.
08:42:12 <mekeor> lispy: i think you're right, yep. alright. thanks anyway, guys =)
08:42:16 <lispy> With that in mind, "deriving (Read, Show)" is nearly always good enough
08:43:09 * lispy goes to find a book
08:43:18 <lispy> time to learn me some more rewriting logic
08:46:02 <byorgey> I remember seeing a package that gives you persistent, versioned, ACID-y storage of data in a file, does anyone know what I'm talking about/what it's called?
08:46:29 <lispy> I know what you're talking about, but I forgotten the name.  persistent?
08:46:33 <donri> byorgey: acid-state
08:47:00 <byorgey> ah, acid-state it is. thanks!
08:47:07 <byorgey> donri++
08:47:45 <donri> also have a look at ixset
08:49:45 <byorgey> oh, that looks neat, although it's not useful for my purposes
08:49:57 <lispy> byorgey: what are you building?
08:50:05 * lispy is just plainly curious
08:50:32 * lispy also feels out of touch with #haskell these days.
08:50:38 <byorgey> lispy: a scheduler for my life
08:51:02 <lispy> I assume we received a few new crops of people.  Yet, I only recognize the older names.
08:51:31 <byorgey> lispy: I create a configuration file of tasks with deadlines and/or desired percentage of time working on each
08:51:52 <lispy> hmm
08:51:58 <byorgey> then I run the scheduler and say "I have two hours now" and it says "you should work on project X"
08:52:03 <lispy> byorgey: Do you have any visualization for it?
08:52:12 <byorgey> lispy: visualization?
08:52:29 <lispy> Yeah, I'm very much a visual thinker when it comes to scheduling.
08:52:46 <byorgey> well, seeing as it only exists as an idea in my head right now, I don't have much of anything for it =)
08:52:51 <lispy> I guess the thing here is that it tells you what to do next instead of giving you a plan
08:53:34 <byorgey> right.  The problem with plans is that I rarely stick to them, and then I feel guilty and don't do the remainder of the plan either
08:53:38 <luite> hmm, persistent would also work for that i guess
08:53:47 <luite> if you use an sqlite file
08:54:23 <donri> but acid-state would be so much simpler with less external dependencies :)
08:54:25 <byorgey> sure. For now I am just trying to keep it as simple as possible. So just a Haskell data structure with the data is perfect.
08:55:13 <luite> donri: is sqlite really an external dep? I think it's bundled with the sqlite client for haskell
08:55:18 <byorgey> I could spend a lot of time generalizing it, adding bells and whistles etc., but that would defeat the entire purpose (which is to get actual work done).
08:55:58 <luite> byorgey: hmm that's true, but I like being able to use existing tools to analyze (and modify if necessary) the data file
08:56:13 <luite> dunno what's available for acid-state
08:57:16 <byorgey> luite: sure, but presumably if I decide I want that, I can always write a little utility to take the data and put it in an sqlite file
08:57:53 <donri> luite: ghci? :)
08:58:44 <byorgey> donri: exactly =)
08:59:13 <lispy> byorgey: I agree that plans change (and with the motivation you mentioned).  You might think about this: How can your tool help you see when you do (or do not) have enough time in your schedule to get all the things done?  Or, how much will you be able to get done based on estimates of effort required?
09:00:42 <luite> byorgey: oh right, I just meant the sqlite command line util, but how difficult is it for example for acid-state to deal with changes in your data types, if you add fields for example?
09:01:12 <donri> not difficult http://hackage.haskell.org/packages/archive/safecopy/0.6.1/doc/html/Data-SafeCopy.html
09:01:55 <donri> and most of that example code can be done with template haskell
09:02:02 <donri> mainly just write the Migrate instance
09:02:06 <byorgey> luite: yeah, that's the point, it does versioning so you can add fields easily etc.
09:02:32 <byorgey> lispy: yep, good ideas
09:02:33 <luite> ah that's interesting
09:02:38 <luite> looks good
09:05:40 <LordDeath> hi everyone
09:05:46 <monad_> I have built a monad of type "EitherT String (MaybeT (ST s)) Int". How can I access the underlying MaybeT? Unfortunately, I always receive the integer value, when extracting the monad with "<-"
09:05:54 <LordDeath> I have problems with understand a line of code
09:06:10 <LordDeath> understand = understanding
09:06:55 <monad_> I just want to whether EitherT "stores" a Nothing or a Just
09:07:09 <monad_> ... want to test ...
09:07:13 <jedai> LordDeath: paste it on hpaste.org (except if it's really one line without context)
09:07:17 <LordDeath> I have a function, which sums up the values of my list type
09:07:21 <LordDeath> http://pastebin.com/TMM0BmCC
09:07:23 <mauke> The paste TMM0BmCC has been copied to http://hpaste.org/57158
09:07:44 <LordDeath> what happens in line 6?
09:08:20 <LordDeath> oh, my date type is: "data List = Nil | Cons Int List deriving Show "
09:08:36 <jedai> LordDeath: Well try to develop the application a few step by yourself
09:08:47 <jedai> on an example
09:09:18 <Botje> monad_: won't it stop executing if you ever have a.Nothing?
09:09:19 <LordDeath> "6:21: Warning: Avoid lambda" <-- ?
09:09:34 <LordDeath> my brain is incompatible with lambda ^^
09:09:42 <jedai> sumList (Cons 1 (Cons 2 Nil)) ==> foldList (\i v -> i +v) 0 (Cons 1 (Cons 2 Nil))
09:10:01 <Botje> you can write it as (+) as well
09:10:23 <Botje> a lamda is just a function without a name
09:10:32 <jedai> ==> (2nd pat ) (\ i v -> i + v) 1 (foldList (...) 0 (Cons 2 Nil))
09:10:32 <byorgey> monad_: you have to use  runEitherT and then runMaybeT.
09:10:39 <Botje> a function pointer with bells on, if you will
09:10:42 <monad_> Botje: I constructed built 2 monad-transformers (EitherT, MonadT) on top of the ST monad. I don't know how to check whether Maybe t contains Nothing or a Just-value
09:10:59 <jedai> ==> 1 + foldList (...) 0 (Cons 2 Nil)
09:11:05 <jedai> LordDeath: and so on
09:11:06 <donri> EvanR: http://hackage.haskell.org/package/HiggsSet and (not yet released) http://darcs.monoid.at/kdtree/ are more type safe alternatives to ixset (that was you earlier, right?)
09:11:30 <Botje> monad_:  then use what byorgey said
09:11:30 <jedai> LordDeath: you see that it becomes a sequence of addition
09:12:13 <jedai> LordDeath: a way to see foldlist is that it replace each Cons by the function and Nil by c
09:12:21 <monad_> LordDeath: This coding simply sums up a list, but it's not complete (missing list-definition?!)
09:12:41 <zzo38> Is Edward Kmett on?
09:12:53 <jedai> monad_: It's just the classic user-defined List type for beginners
09:13:16 <donri> preflex: seen edwardk
09:13:17 <preflex>  edwardk was last seen on #haskell 12 hours, 19 minutes and 14 seconds ago, saying: yottabit: it may have worn off a bit by now
09:13:35 <jedai> LordDeath: So (Cons 1 (Cons 2 Nil) ==> ((+) 1 ((+) 2 0))
09:13:51 <jedai> LordDeath: or in infix notation : 1 + (2 + 0)
09:14:02 <zzo38> He wrote some things about Yoneda lemma, and I have independently discovered Yoneda lemma, but I tried to make some other kind of things based on it and have a some question?
09:14:03 * hackagebot gps2htmlReport 0.3.1 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.3.1 (RobStewart)
09:14:32 <monad_> Botje: I will try with byorgey's suggestion. Haskell can be sometimes very complicated ...
09:14:34 <mjga> I like KdTree, but it is for Real^n indexing. I understand that IxSet doesn't need numbers?
09:15:44 <monad_> Botje: I think runMaybeT should work for me, because I am calling in this monad a function with result MaybeT (ST s) Int
09:16:15 <zzo38> The Yoneda lemma is:  newtype Yoneda f a = Yoneda (forall r. (a -> r) -> f r)
09:16:49 <dolio> No.
09:17:20 <zzo38> I have another type:  newtype T w f a = T (forall r. (a -> w r) -> f r)   Can this type do a monadic join if w is a comonad?
09:17:36 <zzo38> Or any other properties? Or if you move around the w?
09:19:03 <zzo38> Do you know any of these things?
09:19:05 <Saizan> iirc it can be a monad if w and f are adjoints?
09:19:16 <Saizan> look at the monad-ran package
09:19:20 <dolio> T is the right kan extension.
09:19:45 <dolio> Of w and f somehow. I can't remember the order.
09:20:17 <dolio> Yoneda is the Yoneda embedding, not the Yoneda lemma.
09:20:25 <zzo38> O, yes.
09:21:03 <zzo38> Well, then, I have independently discovered the Yoneda embedding.
09:22:12 <zzo38> I can see the similarity to my type T and the monad-ran package.
09:22:45 <zzo38> What if you move the w to another position?
09:23:31 <dolio> Actually, It's not even the Yoneda embedding.
09:23:55 <zzo38> I do know, if f is a functor and w is a comonad, you can lift (making a monad transformer) in that type.
09:24:10 <dolio> Yoneda f a is the type asserted to be isomorphic to f a by the Yoneda lemma.
09:25:40 <zzo38> dolio: O, well, then yes I have figured out that it was isomorphic, independently.
09:26:38 <Saizan> nope, monad-ran doesn't give much hints on when that can be a monad, except for w = f
09:28:20 <zzo38> When w = f it is Codensity
09:28:31 <Saizan> yeah
09:29:04 * hackagebot cabal-ghci 0.2.1 - Set up ghci with options taken from a .cabal file  http://hackage.haskell.org/package/cabal-ghci-0.2.1 (EtienneLaurin)
09:29:22 <zzo38> If f is a monad and w is Identity, it is also a monad
09:30:21 <Saizan> maybe w being pointed is enough?
09:31:37 <zzo38> Saizan: To use lift, you do need extract. Maybe to use join, you need duplicate. I don't know
09:32:55 <monad_> Hi I still don't know how to extract the maybe-value from the monad EitherT String (MaybeT (ST s)) ! I have put the shortened coding on http://hpaste.org/57162 . The problem is at line 68 (see question there).
09:33:49 <Saizan> zzo38: when w is Identity the instance uses the fact that you can write a function (a >
09:33:59 <Saizan> zzo38: a function (a -> Identity a)
09:34:08 <monad_> the problem also is that runST doesn't work there...
09:34:43 <Saizan> @unmtl EitherT String (MaybeT (ST s))
09:34:44 <lambdabot> EitherT String (MaybeT (ST s))
09:35:25 <Saizan> anyhow EitherT String (MaybeT (ST s)) X ~ ST s (Maybe (Either String X))
09:36:25 <monad_> Saizan: I know, but how is that done in the coding...
09:36:54 <monad_> Saizan: I don't want to have cascading code
09:36:58 <Saizan> monad_: so, expose :: EitherT String (MaybeT m) a -> m (Maybe (Either String a)); expose = runMaybeT . runErrorT
09:37:07 <zzo38> Saizan: OK. For any comonad w you have (w a -> w (w a)) but I don't know if that help. But if w is a comonad, you can have lift, and therefore return, with extract you have (w a -> a)
09:37:32 <byorgey> monad_: why do you have both MaybeT and EitherT String?
09:37:52 <Saizan> monad_: but i guess you'd prefer expose :: EitherT String (MaybeT m) a -> EitherT String (MaybeT m) (Maybe (Either String a)); expose = lift . lift . runMaybeT . runErrorT
09:38:39 <lambdanaut> I want to do something like " 1 == True " in Haskell. Is there a Duck Typing library or something like that for Haskell?
09:38:39 <Saizan> zzo38: how do you make return?
09:38:55 <byorgey> lambdanaut: no.
09:39:06 <byorgey> lambdanaut: why would you want to do "1 == True"?
09:39:27 <Saizan> there is Data.Dynamic, but i'd advise against going that route
09:39:28 <zzo38> lambdanaut:  instance Num Bool where { fromInteger 1 = True; }
09:39:34 <monad_> Saizan: I will try this, thank you. My intent was to return a fault message with Either on base of the getColum-Result (that's MaybeT)
09:39:46 <xarch> zzo38: that's ugly
09:39:51 <ceii> zzo38: ugh
09:39:52 <zzo38> (Probably not what you wanted anyways)
09:40:10 <byorgey> monad_: once you have an  ST s (Maybe a)  after doing runMaybeT, you can do  "fmap (maybe ...)" to decide what to do with the maybe and end up with  ST s (Maybe (Either String a))
09:40:12 <zzo38> Saizan:  lift x = T $ \y -> liftM (extract . y) x;
09:40:15 <lambdanaut> Because I'm implementing this crazy thing that my friend calls "LB". LB is a unit of measure that is ALWAYS the measurement of the topic of conversation
09:40:20 <lambdanaut> So how many pounds do you weigh?
09:40:21 <lambdanaut> LB
09:40:30 <lambdanaut> how far away is the moon from you? One LB
09:40:38 <lambdanaut> etc
09:40:38 <xarch> what?
09:40:38 <byorgey> monad_: then apply MaybeT and EitherT constructors to get back the transformer-stack version
09:41:01 <zzo38> And then, you always have:   return = lift . return;    (I always prefer to define monad transformers in terms of lift, fmap, and join; return and (>>=) follow from those)
09:41:21 <monad_> byorgey: ty, I will try that
09:41:28 <byorgey> monad_: but it is weird to be shuffling error conditions around among the transformers in a stack.
09:42:19 <monad_> byorgey: Have you another suggestion. I just mentioned my intent: I want to return an error on base of the return column, which is expressed by MaybeT
09:42:21 <byorgey> lambdanaut: type LB = Int; computeTheAnswer :: String -> LB; computeTheAnswer _ = 1
09:42:27 <byorgey> lambdanaut: there, I just implemented it for you
09:42:47 <zzo38> lambdanaut: The moon is approx 0.0029686 AU away
09:43:12 <byorgey> monad_: why is it expressed with MaybeT?
09:43:25 <byorgey> if you are just going to translate it into an EitherT String later
09:43:40 <byorgey> why not do everything in terms of EitherT from the beginning?
09:43:45 <monad_> byorgey: I also could have chosen ST (Maybe Int), but that's nicer
09:44:30 <byorgey> monad_: because you basically use MaybeT to wrap up the result of getColumn and then immediately use 'runMaybeT' to get it out again and convert to EitherT
09:44:57 <byorgey> that's silly, just don't use MaybeT in the first place, and convert the Maybe into an Either with an appropriate error message right away
09:45:08 <byorgey> in the result of getColumn
09:45:16 <monad_> ok
09:46:17 <zzo38> Saizan: Now do you know how I make return? You asked me that, and I have answered; did you have a response/complaint to that?
09:46:54 <monad_> but it would not be correct in this case, because if getColumn returns Nothing the algorithm would stop and else continue
09:47:50 <Saizan> zzo38: i thought you meant return for w
09:47:56 <teel> how can i input in the active interpreter a function def, like func :: (Show a) => [a] -> [Char]? It says "lacks an accompanying binding"
09:48:27 <ion> Add a binding
09:49:07 <Saizan> if you are at the repl you've to do it in one line like: let func :: ...; func = ...
09:49:11 <mauke> teel: why do you need the explicit type signature?
09:49:31 <teel> im just trying haskell out :>
09:50:23 <teel> oh i even tried that Saizan, but had a typi and thought its a real error :(
09:50:30 <teel> *typo
09:50:41 <zzo38> Saizan: O, well, that is not what I meant. Do you have other ideas?
09:52:22 <Saizan> zzo38: nope
09:59:14 <teel> when getting head and tail from a list why does let func (h:t) = h do the job? isnt (…) a tuple actually?
09:59:48 <sbahra> :t (:)
09:59:49 <danr> teel: (h:t) pattern matches on the list cons constructor :
09:59:49 <lambdabot> forall a. a -> [a] -> [a]
10:00:20 <mauke> teel: no, it isn't
10:00:21 <ion> (…,…) is a tuple.
10:00:28 <teel> thats confusing
10:00:33 <sbahra> (...), those are just parenthesis teel.
10:00:38 <mauke> teel: the parens are for precedence
10:00:46 <mauke> , is what tuples tuples
10:00:47 <sbahra> Remember, func (h (: t)).
10:00:48 <nand`> (,) is a tuple
10:00:56 <sbahra> For example.
10:01:04 <sbahra> > negate 3 + 3
10:01:05 <lambdabot>   0
10:01:09 <sbahra> > negate (3 + 3)
10:01:10 <ion> mauke is what verbs nouns
10:01:10 <lambdabot>   -6
10:01:17 <sbahra> > negate $ 3 + 3
10:01:18 <lambdabot>   -6
10:01:42 <nand`> > 3 , 3
10:01:42 <lambdabot>   <no location info>: parse error on input `,'
10:01:54 <nand`> > let (x,y) = 3,3 in x+y
10:01:55 <lambdabot>   <no location info>: parse error on input `,'
10:01:58 <ion> sbahra: “func (h (: t))”, whaat?
10:02:18 <sbahra> ion, bad example (see negate 3 + 3 example).
10:03:46 <teel> i see so i would actually use h:[list] to prepend, but when i use it in the function definition, he can do some magic, reminds me abit of prolog?
10:04:16 <sbahra> teel, no real magic, it is pattern matching.
10:04:23 <nand`> (:) is a value constructor, it can be used anywhere value constructors can - for example pattern matching
10:04:26 <sbahra> teel, (:) is a constructor.
10:04:47 <nand`> > let (Just x, y:z) = (Just 3, [1,2,3]) in (x,y,z)
10:04:48 <lambdabot>   (3,1,[2,3])
10:05:29 <nand`> > case "hello" of (a:b:c:_) -> [c,b,a]
10:05:30 <lambdabot>   "leh"
10:06:20 <ion> > let f (x:y:z) = (x, y, z) in f ('o':' ':'h':'a':'i':[])
10:06:21 <lambdabot>   ('o',' ',"hai")
10:06:30 <teel> i guess i need some diluent to make my brain shapeable
10:07:35 <ion> data [a] = [] | a:[a]; f (x:xs) = …
10:07:51 <ion> data List a = Empty | Cons a [a]; f (Cons x xs) = …
10:08:01 <nand`> > let f = uncurry (:) in f ('h', f ('e', "llo"))
10:08:02 <lambdabot>   "hello"
10:09:43 <Oxryly> > :t uncurry
10:09:44 <lambdabot>   <no location info>: parse error on input `:'
10:09:55 <Oxryly> how do you check the type?
10:10:09 <nand`> :t uncurrecy
10:10:10 <lambdabot> Not in scope: `uncurrecy'
10:10:12 <nand`> err
10:10:13 <nand`> :t uncurry
10:10:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:11:12 <Oxryly> :t (:)
10:11:13 <lambdabot> forall a. a -> [a] -> [a]
10:11:28 <Oxryly> :t uncurry (:)
10:11:29 <lambdabot> forall a. (a, [a]) -> [a]
10:13:19 <princess> I'm trying to create a list of pairs. Last elm of one pair
10:13:19 <princess> has same type as first elm of the next. I don't (can't) care
10:13:19 <princess> about the inbetween types. I try this:
10:13:19 <princess> data Foo a b = Stop (a, b) | Cons (a, c) (Foo c b)
10:13:19 <princess> Compiler rightfully complains. Do I need to seriously rethink?
10:14:29 <Saizan> not necessarily
10:14:43 <Saizan> but you need ExistentialQuantification
10:15:00 <Saizan> data Foo a b = Stop (a, b) | forall c. Cons (a, c) (Foo c b)
10:15:44 <princess> Ah, I'm new to Haskell, never seen that before. Thank you :)
10:16:52 <Saizan> it's even an extension to haskell :)
10:17:35 <Saizan> in fact you need {-# LANGUAGE ExistentialQuantification #-} at the top of your file
10:21:06 <princess> I'm still having problems, but I have a lot to go on. I'll be back if I can't get it to work, thank you :)
10:24:12 <porco> :t [1, 2]
10:24:13 <lambdabot> forall t. (Num t) => [t]
10:24:35 <porco> :t ['a', 'b']
10:24:36 <lambdabot> [Char]
10:25:11 <teel> :t :t
10:25:12 <lambdabot> parse error on input `:'
10:40:56 <liyang> Saizan, princess: that looks like a reflexive transitive closure. :)
10:41:37 <aristid> liyang: Data.Star. oh wait, wrong language :D
10:42:46 <teel> are guards like a switch statement in other langs?
10:42:53 <liyang> http://hpaste.org/57163
10:43:21 <jedai> teel: not really, i would say that pattern match is closer to switch
10:43:29 <CodeWeaver> guards are probably better analogized to a chain of if-else if-else if-else if-elses.
10:43:42 <liyang> aristid: give it a few years...
10:43:48 <CodeWeaver> The guard expressions can be arbitrary boolean tests.
10:44:02 <CodeWeaver> A switch statement corresponds best with the haskell 'case'.
10:44:09 <aristid> liyang: i don't like that random Show contraint in there :P
10:44:18 <ion> > let a | False = 5 | True = 6 in a
10:44:19 <lambdabot>   6
10:44:45 <Cale> I always find it slightly weird when someone changes their nick from something reasonable to a Guest92459 sort of nick :)
10:45:00 <ion> cale: That’s probably a nick collision.
10:45:03 <parcs`> Cale: i think freenode does that automatically
10:45:03 <liyang> aristid: neither do I!
10:45:12 <Cale> oh, right, freenode :)
10:45:39 <aristid> Cale: other networks do it much more aggressively :)
10:45:50 <Zamarok> Hi.. I'm looking for some Haskell code to study so I can learn more about how other people code with it.. what's a good open-source project that I can read and comprehend in a reasonable amount of time?
10:46:19 <aristid> Cale: i'm in a network where regularly, half of the channel members change their nick to Guest* because PART of the authentication system fails to work
10:46:29 <jedai> Zamarok: What's a reasonable amount of time ?
10:46:33 <Cale> aristid: haha
10:46:36 <aristid> well, maybe not _regularly_, but it happens from time to time :D
10:46:58 <Zamarok> jedai: A a day or so, I guess
10:46:59 <Cale> aristid: I think in the old days I recall IRC networks just refusing to connect you if your nick was taken.
10:47:00 <merijn> Zamarok: Xmonad seems like a good starting point, fairly popular, but not extremely big
10:47:33 <Zamarok> Oh good, I'm using Xmonad right now.. will check it out
10:48:03 * nand` wonders how many people here actually use xmonad
10:48:05 <nand`> I do, for one
10:48:24 <merijn> I don't, but I would if I was actually running X11 :p
10:48:29 <Cale> I would if I could stand tiling window managers at all
10:48:53 <Zamarok> I hate taking my hands off the keyboard.. Xmonad is the perfect solution
10:50:23 <parcs`> is it? have you tried other tiling wms?
10:50:57 <Zamarok> I stopped when I found the perfect one lol
10:51:09 <ProfDrum> Does "bonus" ever appear in here?
10:51:12 <Zamarok> which may have been the first
10:51:21 <Cale> ProfDrum: he used to hang out here a lot
10:51:26 <Cale> ProfDrum: I don't know about lately
10:51:33 <eviltwin_b> Cale, they still do that.  the difference is that "taken" used to mean "actively in use by someone logged in right now" and these days there is the concept of reserved names
10:51:45 <nand`> what attracts me about xmonad isn't its features (which I believe others like awesomwm can satisfy as well) but because of the fact that it's written in a sane language which allows me to edit it and look at the source without getting a headache
10:51:55 <Cale> eviltwin_b: yeah, I suppose that's just it :)
10:51:55 <aristid> preflex: seen bonus
10:51:55 <preflex>  bonus was last seen on #haskell 274 days, 17 minutes and 58 seconds ago, saying: yeah i think that's better as well
10:51:57 <ProfDrum> thats a pity, I just wanted to thank him/her/it for writing a Haskell book that doesnt make me want to beat myself to death with it
10:52:12 <donri> preflex: seen BONUS
10:52:12 <preflex>  BONUS was last seen on #haskell 274 days, 18 minutes and 15 seconds ago, saying: yeah i think that's better as well
10:52:19 <donri> guess not.
10:52:28 <ProfDrum> ah well
10:52:57 <Cale> It's always weird when people fall off the face of the earth with respect to IRC
10:53:06 <mauke> preflex: karma bonus
10:53:07 <preflex>  bonus: 23
10:53:10 <ciaranm> didn't someone say he was still on other networks?
10:53:11 <ProfDrum> especially with such cryptic final messages
10:53:37 <donri> "famous last words, IRC edition"
10:53:56 <mauke> hah, I've got megabytes of that in preflex's state file
10:54:10 <hpc> mauke: paste it!
10:54:23 <mauke> it's binary
10:54:27 <hpc> aw
10:54:55 <aristid> preflex: seen lambdabot
10:54:55 <preflex>  lambdabot was last seen on #haskell 10 minutes and 35 seconds ago, saying:   6
10:54:58 <aristid> :D
10:55:01 <aristid> sorry.
10:55:11 <mauke> preflex: seen God
10:55:11 <preflex>  God was last seen on ##c++ 2 years, 117 days, 20 hours, 43 minutes and 50 seconds ago, saying: I don't really know either actually
10:55:27 <teel> preflex: seen preflex
10:55:28 <preflex>  what
10:55:29 <donri> God may be omnipotent, but ey's not omniscient.
10:55:48 <hpc> preflex: seen hpc
10:55:49 <preflex>  hpc was last seen on #haskell 1 minute and 21 seconds ago, saying: aw
10:55:54 <CodeWeaver> preflex: seen a therapist
10:55:54 <preflex>  a was last seen on #perl 189 days, 6 hours, 45 minutes and 51 seconds ago, saying: use*
10:56:00 <CodeWeaver> hahahah
10:56:02 <CodeWeaver> Oh well.
10:56:19 <teel> preflex: seen NickServ
10:56:19 <preflex>  NickServ was last seen 2 days, 21 hours and 41 seconds ago, saying: <private message>
10:56:26 <teel> ohh ;)
10:56:32 <hpc> haha
10:57:02 <nand`> preflex: seen preflex
10:57:02 <preflex>  what
10:57:33 <teel> preflex: seen mauke
10:57:33 <preflex>  mauke was last seen on #haskell 2 minutes and 22 seconds ago, saying: preflex: seen God
10:57:55 <mauke> preflex: seen stroustrup
10:57:56 <preflex>  Sorry, I haven't seen stroustrup
10:58:59 <raichoo> pew, thankfullly ^^
10:59:30 <mauke> preflex: seen SteveJobs
10:59:30 <preflex>  Sorry, I haven't seen SteveJobs
11:01:57 <teel> > :q
11:01:58 <lambdabot>   <no location info>: parse error on input `:'
11:03:40 <MrJones> hi :)
11:04:07 <teel> hello MrJones
11:04:27 <MrJones> I am just learning haskell with hugs, and I tried this construct in hugs (sept 2006 win32 version): http://fpaste.org/IAL3/
11:04:36 <CodeWeaver> heehee.  My last name is Jones.  For a moment I thought somebody I knew had tracked me down ehre.
11:04:38 <MrJones> now line 15+ fails due to my guards inside guards thing
11:04:39 <CodeWeaver> That's hilarious.
11:04:48 <MrJones> obviously since I have no idea how to do it properly :P
11:05:09 <MrJones> can someone tell me whether some similar construct is possible and if yes, how? :D I have no idea but I am just gravely wondering if this works in some similar way, or whether guards inside guards is totally impossible
11:05:42 <jedai> first, you should never write xs == []
11:05:43 <CodeWeaver> Well, you could easily do it by introducing an inner let clause between the guards.
11:06:12 <CodeWeaver> Errrrr...
11:06:15 <CodeWeaver> Not quite what I meant to say.
11:06:17 <jedai> MrJones: It arbitrarily restrict the possible content of the list to things that support equality
11:06:45 <jedai> MrJones: Instead you should use pattern matching or the function null depending on the context
11:06:57 <jedai> Here you want to use pattern matching
11:07:04 <MrJones> jedai: it is only supposed to work with integers :)
11:07:05 <mauke> MrJones: [x] : n makes no sense
11:07:14 <MrJones> and I am wondering how guards inside guards work
11:07:19 <ion> > [x]:undefined
11:07:20 <lambdabot>   [[x]*Exception: Prelude.undefined
11:08:02 <CodeWeaver> nested guards.
11:08:02 <jedai> MrJones: Right I neted you used < after that (but you still should avoid the xs == [] and use pattern matching instead so you won't have two layer of guards anymore
11:08:04 <Eduard_Munteanu> MrJones: similar to how nested ifs work?
11:08:05 <Saizan> MrJones: you can't have guards inside guards like that
11:08:08 <MrJones> CodeWeaver: yea, how does that work?
11:08:19 <CodeWeaver> Give me a second.  I'm trying to formulate it without having to test compile.
11:08:31 <CodeWeaver> I'm not as quick as some of these guys.
11:08:43 <Eduard_Munteanu> Ah, if that's what you mean...
11:08:56 <mauke> MrJones: your factorialList is broken. it doesn't work for empty lists
11:09:00 <jedai> MrJones: sortInsert n [x] | ...= | ... = \n sortInsert (x:xs) |...
11:09:56 <CodeWeaver> | otherwise = x'
11:09:57 <CodeWeaver>    where x'
11:09:57 <CodeWeaver>                     | x >= n    = ([n] : x) : [xs]
11:10:01 <CodeWeaver> Does that work?  I forget
11:10:02 <jedai> MrJones: Which makes it obvious that you don't handle the empty list case (is it what you want ?)
11:10:52 <CodeWeaver> Basically introducing a separate variable binding like that, where you can then define that variable binding to be based on its own guards.
11:11:09 <mauke> what the fuck
11:11:11 <mauke> fpaste.org--
11:11:34 <MrJones> hm
11:11:49 <MrJones> so is true nested guards not possible? jedai: I am not sure what you want to tell me with that line
11:11:50 <jedai> MrJones: But anyway you should probably write the type of your function to better understand what you're trying to do (since the type of n is not clear at all, it won't work as actually written)
11:11:54 <mauke> MrJones: http://hpaste.org/57164
11:12:28 <mauke> except that's broken because I mixed up n and x at some point
11:12:28 <MrJones> jedia: it should be Int->[Int]->[Int]
11:12:55 <CodeWeaver> Purely nested guards aren't supported as far as I know.
11:13:19 <CodeWeaver> But if I break out my interpreter instead of faking it, I can probably get something very very close to it to compile.
11:13:31 <jedai> MrJones: then expression like [x] : n or [n] : xs definitely won't work
11:13:37 <joshft91> Hey guys, easy question here.  I need to make a little function that computes all pythagorean triples.
11:13:41 <joshft91> I have this so far...
11:13:46 <joshft91> pythTriples' n = [ (x, y, z) | x <- [1..n], y <- [1..x], z <- [1..n], x^2 + y^2 == z^2 ]
11:14:03 <joshft91> now I just need to make it find all of them...I thought I could just remove "n", but that doesn't appear to work
11:14:05 <joshft91> any ideas?
11:14:21 <jedai> MrJones: mauke's solution is correct of course (though the name sortInsert is pretty much wrong)
11:14:23 <mauke> joshft91: that looks extremely inefficient
11:14:33 <c_wraith> it also repeats solutions
11:14:34 <mauke> jedai: why? it inserts into a sorted list
11:14:47 <joshft91> @mauke yea, this is like my 2nd day working on haskell =/
11:14:47 <lambdabot> Unknown command, try @list
11:14:47 <CodeWeaver> Using list-comprehension like that doesn't work, joshft, because it tries to exhaust one of the infinite lists before moving on to future elements of the other lists.
11:14:58 <jedai> mauke: Well yes, it's not an insertion sort, it's an insertion, not a sort
11:15:14 <mauke> jedai: yes, that's why it's called sortInsert, not insertSort :-)
11:15:32 <joshft91> how do you direct a message at someone? =/
11:15:35 <c_wraith> joshft91: one major inefficiency there is that you don't need to walk through values of z. you can just calculate it, if it exists
11:15:38 <mauke> joshft91: you don't
11:15:56 <hpc> joshft91: start typing their name, then press tab
11:16:03 <CodeWeaver> If you did:  [(x,y) | x<-[1..10], y<-[99..103]] you would see the order in which the inner lists are processed.  And it exhausts one before moving on to the next element of the other.
11:16:12 <CodeWeaver> So this will never work with multiple infinite lists being drawn from.
11:16:30 <CodeWeaver> Follow?
11:16:30 <jedai> mauke: ok, I guess I can see that but I still think I wouldn't name it like that (to be honest I would probably put this as a local function since it's only guaranteed to work on a sorted list
11:16:49 <ProfDrum> it'd work if they were all 1..n
11:16:52 <joshft91> CodeWeaver: Hm, I think so - so basically I can only compute a certain number?
11:17:03 <CodeWeaver> The way you've written it, yes.
11:17:18 <joshft91> CodeWeaver: right.  How would I change it to just compute all of them?
11:17:32 <joshft91> CodeWeaver: I realize this is a ridiculously easy question, but I'm new to haskell
11:17:49 <MrJones> blub
11:18:21 <CodeWeaver> It's okay.  Let's talk two-tuples and you can extend it to 3 if you like.  For any pair (x,y), the corresponding pair (y,x) is basically the same for this kind of evaluation, yeah?
11:18:34 <CodeWeaver> That is, exchanging the values of two of your variables won't change the answer.
11:18:49 <joshft91> Right, I understand that
11:19:01 <CodeWeaver> So if you let one of your inner lists be infinite… and then let the other one only go up as far as the first...
11:19:02 <jedai> MrJones: Any way you can't have nested guards, if you need them, you either flatten the tree or just call a function with the inner guards from the main function which has the outer guards
11:19:17 <MrJones> jedai: ok thanks. I was just wondering whether it is possible
11:19:18 <CodeWeaver> …and you get the order of the extraction the right way around...
11:19:23 <joshft91> CodeWeaver: Huh, that makes sense, amazingly
11:19:31 <MrJones> your objections with xs == [] is true, I will avoid it from now
11:19:33 <CodeWeaver> …then you only have one infinite list, and the others are finite.
11:19:40 <joshft91> CodeWeaver: so I only need one infinite list...
11:19:50 <joshft91> CodeWeaver: I'll give it a shot and come back if I'm stuck again.  Thank you sir1
11:19:51 <CodeWeaver> Only way to go, if you're using list comprehension, I think.
11:19:52 <joshft91> !
11:19:53 <CodeWeaver> :D
11:19:56 <CodeWeaver> Yay I was helpful!
11:20:05 <CodeWeaver> *does a snoopy dance*
11:20:18 <joshft91> lol
11:20:19 <joshft91> thanks again
11:20:32 <jedai> joshft91: Note that you don't need to test several z
11:20:39 <CodeWeaver> Optimization detail.
11:20:44 <CodeWeaver> leave the poor boy alone.
11:20:45 <CodeWeaver> :D
11:21:00 <joshft91> Yea, I've read that too, but we're only working with haskell for about a week here
11:21:02 <joshft91> then on to prologue
11:21:12 <CodeWeaver> Mm, prolog's fun.
11:21:17 <ProfDrum> joshft91, are you at my uni? 
11:21:24 <jedai> joshft91: there's only one value that will everwork (that is x^2+y^2...), you just have to check if the sqrt is an integer
11:21:31 <joshft91> ProfDrum: I have no idea?
11:22:08 <joshft91> jedai: Yea, I understand that too ;)
11:23:05 <joshft91> ProfDrum: which uni you at?
11:23:23 <jedai> joshft91: Well with all that, you should have somethin much better :) (Of course you can do even better with a more advanced algorithm)
11:23:28 <ProfDrum> Durham, we do Haskell followed by Prolog
11:23:57 <joshft91> Oh, nope, mus tnot be.  Sounds like w'ere on a similar curhiculam though
11:24:06 <liyang> No Whitespace?
11:24:19 <CodeWeaver> liyang, that's just evil.
11:24:20 <ProfDrum> No Whitespace, although Edwin is giving a compsoc talk soon :P
11:24:38 <ProfDrum> no Kaya either, if we're language-dropping ;)
11:24:57 <CodeWeaver> And in any event if you want to be evil, you definitely need to do Intercal
11:25:10 <joshft91> CodeWeaver: So here's what I have -- pythTriples = [ (x, y, z) | x <- [1..], y <- [1..x], z <- [1..x], x^2 + y^2 == z^2]
11:25:24 <CodeWeaver> Yup, if that doesn't work, something close to it will.
11:25:33 <joshft91> CodeWeaver: when I try to run it, it doesn't error but it gives me no output either
11:25:43 <CodeWeaver> Well, except you need your parameters listed after pythTriples
11:25:49 <CodeWeaver> No wait.
11:25:51 <CodeWeaver> Um.
11:25:52 <CodeWeaver> Yes, you do.
11:25:56 <CodeWeaver> At least n.
11:26:01 <CodeWeaver> No wait.
11:26:03 <CodeWeaver> Its an infinite list.
11:26:06 <joshft91> o.o
11:26:06 <CodeWeaver> What am I saying.
11:26:18 <CodeWeaver> Sorry, I'm having a moment.
11:26:20 <jedai> joshft91: how is this supposed to work if you limit z to x...
11:26:23 <CodeWeaver> booting ghci
11:26:32 <aristid> CodeWeaver: just take a deep breath :)
11:26:33 <joshft91> Yeah... well the problem here says to "write a list comprehension for all pythagorean triples"
11:26:50 <jedai> joshft91: how could z^2 be equal to x^2+y^2 when it's x^2 at max
11:27:01 <CodeWeaver> Well, that's one problem.
11:27:18 <CodeWeaver> The other is the order of evaluation of the inner lists.
11:27:19 <jedai> CodeWeaver: That's _the_ problem
11:27:22 <Saizan> > [ (x, y, z) | x <- [1..], y <- [1..x], z <- [1..x], x^2 == y^2 + z^2]
11:27:24 <lambdabot>   [(5,3,4),(5,4,3),(10,6,8),(10,8,6),(13,5,12),(13,12,5),(15,9,12),(15,12,9),...
11:27:37 <CodeWeaver> Yah.
11:27:43 <Saizan> > [ (x, y, z) | x <- [1..], y <- [1..x], z <- [1..y], x^2 == y^2 + z^2]
11:27:45 <lambdabot>  Terminated
11:27:58 <CodeWeaver> The one that's allowed to get to a big value has to be the one that is the sum of the other two squares.
11:27:59 <jedai> Saizan: cheater ;)
11:28:21 <CodeWeaver> I stand corrected.  That's the only problem, as Saizan showed.
11:28:27 <Saizan> > [ (x, y, z) | x <- [1..], y <- [1..x], z <- [1..y], x^2 == y^2 + z^2]
11:28:30 <lambdabot>   [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8),(20,16,12),(25,20,15),(25,2...
11:28:45 <joshft91> Hm...
11:28:50 <Saizan> i guess i shouldn't have given that away
11:28:55 <joshft91> how come you have "x^2 == y^2 + z^2" instead of x^2 + y^2 = z^2
11:28:58 <CodeWeaver> Otherwise the term that is the sum of the other two isn't allowed to ever get big enough.
11:29:08 <joshft91> it's all good, I want to make suer I understand it though
11:29:21 <CodeWeaver> josh: because z in your version is pinned to be a maximum of x.
11:29:41 <CodeWeaver> That is, the sum-of-squares value is pinned to be no bigger than x, not even x^2.
11:29:48 <CodeWeaver> That will never be true.
11:29:52 <joshft91> hm
11:30:02 <Saizan> joshft91: well, i just considered x to be the length of the ipotenuse instead
11:30:06 <jedai> Saizan: Well I guess he still can improve it by computing the third number and checking it's an integer instead of searching it among integer)
11:30:10 <joshft91> is there a way to change it so as to keep the x2 + y2 = z2?
11:30:15 <Saizan> *hypotenuse
11:30:22 <CodeWeaver> Yes, use z as the 'can get arbitrarily large' number.
11:30:25 <CodeWeaver> in your list generation.
11:30:37 <Saizan> yeah, what CodeWeaver says
11:30:41 <joshft91> hm
11:30:47 <joshft91> well I'll play around with it since I have the basic idea here
11:30:50 <CodeWeaver> :)
11:32:23 <CodeWeaver> man that's elegant code.  Just sayin.
11:32:27 <CodeWeaver> Love this language.
11:34:08 <pcavs> (Snap/Heist Question) What's the easiest way to just serve some JSON from Snap/Heist ?
11:34:13 <asante> do i have to install some package, before using the Data.Text-module? cause ghci says "Could not find module `Data.Text'"
11:35:24 <jedai> asante: yes, the text package
11:35:56 <jedai> asante: though it will probably be in hte Haskell platform very soon (in fact I thought it was already in it ?)
11:36:14 <jedai> asante: You know how to install packages ?
11:36:19 <CodeWeaver> :t round
11:36:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:36:26 <CodeWeaver> Sweeeeeeet
11:36:32 <asante> no, but i think thats easy to find ;)
11:36:46 <asante> is the package named in the header of hackage?
11:37:00 <asante> the "text-0.11.1.13" for data.text?
11:37:09 <jedai> asante: the header of hackage ?
11:37:43 <jedai> asante: anyway to install a package just use cabal-install (command : "cabal install text" after a "cabal update")
11:38:02 <asante> okay thanks
11:38:29 <asante> ya.. when you look for the data.text package on hackage, you'll find this page
11:38:30 <asante> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html
11:38:53 <mjga> which 3d vector would you use as a base for space-partitioning data structure? is there anything that is mostly used? I noticed that Data.Vector seem geared towards arbitrary size, and doesn't implement Num
11:38:54 <ProfDrum> Im having a really basic problem. I need to check an array in all directions recursively for a tile. What Im want to do essentially is "if array!(x,y) == White, array (x+1, y)"
11:39:02 <MrJones> what is the type of a list with any objects inside? not ::[] it seems
11:39:06 <ProfDrum> and I just cant get my head round it
11:39:37 <byorgey> MrJones: [a]
11:39:38 <mauke> MrJones: what do you mean by "any"?
11:39:41 <mjga> I see vec package, and tensor, but tensor is rather sparse in vector operations (like Num instances)
11:39:47 <MrJones> byorgey: thanks
11:39:56 <luite> mjga: you can't really implement Num sensibly for arbitrary sized vectors
11:39:57 <MrJones> mauke: well just any..
11:40:04 <jedai> MrJones: any object ? list in haskell are homogenous, they only contain one type of thing
11:40:06 <asante> jedai: i don't know if its called "header", but just the first line of the page
11:40:15 <MrJones> jedai: any homogenous type the list contains
11:40:17 <mjga> luite: that's why I would prefer unboxed fixed-dimension vectors
11:40:20 <mauke> MrJones: ok, bye
11:40:44 <luite> mjga: even for fixed dimension vectors, what would multiplication be?
11:40:48 <mjga> luite: they are 3D and will stay 3D, the only thing I may do them is to transform by homogeneous matrices, or export to OpenGL
11:40:55 <byorgey> asante: the name of a package does not necessarily have any relation to the names of the module(s) it exports
11:41:07 <mjga> luite: mostly dot-product
11:41:09 <jedai> MrJones: That's usually called a polymorphic list
11:41:20 <MrJones> jedai: [a] is what I want
11:41:24 <luite> mjga: wrong type, (*) :: Num a => a -> a -> a
11:41:26 <jedai> MrJones: Well a polymorphic type of list
11:41:27 <MrJones> if that is a homogenous list with type a
11:41:28 <mjga> luite: but of course Num * would have to be vector product, which is also useful
11:41:35 <byorgey> MrJones: yes
11:41:39 <jedai> MrJones: Right it is :)
11:41:47 <MrJones> that is all I wanted :)
11:41:52 <zzo38> I have made something that can make up a list where the second part of a pair of one is the type of the first part of the pair next one, a type called Walk which forms the category from any quiver.
11:42:07 <zzo38> So, (Walk (,)) will be such a thing
11:42:22 <luite> mjga: yes, but really only useful for 3d vectors
11:42:35 <asante> byorgey, thats my question. if thats the package name, or the modul-name. and if its the modul name, where can i find the package, which contains the modul?
11:42:37 <luite> admittedly those are the ones you want :p
11:42:59 <mjga> luite: the problem for me is that we have zillions of 3d vector types: OpenGL has one (and you need to use realFrac all the time). I want to do some translations, rotations, some distance checking - it is all physics, so Num (*) makes sense for me.
11:43:00 <byorgey> asante: Data.Text is the name of a module
11:43:13 <byorgey> asante: to find which package exports it, you can try searching on Hayoo
11:43:16 <byorgey> @where hayoo
11:43:17 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:43:45 <mjga> luite: at the same time there is not so much a standard, so it may so happen that library user will get through hell of converting everything for OpenGL visualization etc. Or worse - will have to reimplement basic operations
11:44:09 * hackagebot epub-metadata 2.3.0 - Library for parsing and manipulating ePub files and OPF package data  http://hackage.haskell.org/package/epub-metadata-2.3.0 (DinoMorelli)
11:44:10 <byorgey> asante: now, for Data.Text in particular, I can tell you that the package you want is indeed 'text'
11:44:27 <CodeWeaver> Hah, implemented the pythtriples thing in a single list comprehension using the sqrt test.
11:44:28 <mjga> luite: Nobody would like to introduce dependency on OpenGL to a general purpose library though
11:45:30 <mjga> is there anything that lets you know "pagerank" of hackage packages, so that one can search and check if standards emerge in a particular domain, where there are many?
11:45:45 <asante> byorgey, ah ok, hoogle tells the package, too.
11:45:46 <asante> thanks
11:46:30 <sm> cabal-install & Cabal packages on hackage are looking a bit stale
11:46:33 <asante> ja, i believed jedai in that info ;) just want to know it for later questions.
11:46:53 <Enigmagic> mjga: not really, revdeps sorta works for this though http://packdeps.haskellers.com/reverse
11:48:52 <mjga> Enigmagic: thanks, I have lost the link previously. Very useful...
11:49:01 <jedai> sm: What do you mean ? Hackage has never seen so much uploads daily
11:49:18 <sm> jedai: I mean the cabal-install and Cabal packages
11:49:38 <mjga> luite: I suppose one would need to somehow accept subset types for 3D vectors if one would like to make them compatible with n-dim vectors
11:50:45 <jedai> sm: ah the package Cabal and cabal-install... well they work, I know there is some work continuing about them, maybe in wait of new GHC releases ?
11:51:17 <sm> I've been using a newer-than-hackage version for a long time, and ghc 7.4 rc has a newer Cabal still (1.14)
11:52:01 <jedai> sm: Yes, I guess they will be on hackage soon after the release of GHC 7.4
11:52:13 <sm> was just dipping my toe into the GHC 7.4 world
11:52:48 <jedai> sm: It looks pretty nice on many fronts (though there are still regressions to squash)
11:53:57 <Zamarok> @src (\\)
11:53:57 <lambdabot> (\\) = foldl (flip delete)
11:58:27 <oxryly> EvanR: how's the MUD project going?
12:04:53 <mjga> sm: I also tried GHC 7.4rc2. Didn't manage to get Haskell Platform working, but my own code quickly started to be 10x faster in case that overflown stack. pathological case, and of course it still needs +RTS -k512M
12:06:00 <sm> nice!
12:06:32 <sm> in my case I'm seeing a few too many broken packages, I'll hold off a little more
12:06:54 <sm> I think my point about Cabal on hackage is that it's lagging behind even GHC 7.2's Cabal
12:07:22 <sm> I guess the one on hackage doesn't really get used so it doesn't matter
12:09:58 <mjga> sm: sorry I meant upper stack limit +RTS -K512M
12:10:19 <mjga> sm: what do you need to build? I built most of HP for GHC7.4
12:11:18 <he-sk> sm: can't compile latest hledger-web from darcs, there's a conflict with cmdargs
12:11:46 <mjga> sm: so I can't help with it... most of what I compiled  just required adding (Eq a) to type context where previously it was happy with (Num a), and dependency on base <4.6 in *.cabal
12:12:39 <he-sk> sm: hledger-0.16.1 requires cmdargs 0.8
12:12:53 <he-sk> sm: hledger-web-0.16.5 requires cmdargs > 0.9.1
12:13:50 <pVi> what does => mean in haskell? For example `func :: (Ord a) => Set a`
12:14:05 <benchmark> what's the best way to represent the search space for Frogger
12:14:20 <benchmark> http://en.wikipedia.org/wiki/Frogger
12:15:01 <ozgura> pVi: things to the left hand side of => are type class constraints
12:15:22 <ozgura> in the example you gave, it means func is of type Set a, provided a is an instance of Ord.
12:16:01 <parcs`> :t (+) :: Num a => a -> Num a => a -> Num a => a
12:16:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = (Num a) => a
12:16:02 <lambdabot>     In the expression:
12:16:03 <lambdabot>           (+) :: (Num a) => a -> (Num a) => a -> (Num a) => a
12:16:26 <pVi> thanks ozgura
12:16:28 <parcs`> *shrug* works in ghc 7.2
12:16:51 <ozgura> parcs`: what's that supposed to mean?
12:17:13 <ozgura> ah, ok
12:17:27 <ozgura> :t (+) (Num a => a) -> (Num a => a) -> (Num a => a)
12:17:28 <lambdabot> parse error on input `=>'
12:17:32 <parcs`> no
12:17:38 <ozgura> :t (+) :: (Num a => a) -> (Num a => a) -> (Num a => a)
12:17:39 <lambdabot>     Could not deduce (Num a) from the context ()
12:17:39 <lambdabot>       arising from a use of `+' at <interactive>:1:0-2
12:17:39 <lambdabot>     Possible fix:
12:17:46 <sm> oh. he-sk, mjga: hledger in darcs should work but you need to install all the local packages, eg run make install (updated today)
12:18:05 <sm> ie: cabal install ./hledger-lib ./hledger ./hledger-web
12:18:40 <joshft91> mk, I'm back. lol
12:18:48 <parcs`> ozgura: => is right associative. "Num a => a -> Num a => a -> Num a => a" is supposed to mean the same thing as "Num a => a -> a -> a", after duplicate constraints are removed
12:18:56 <joshft91> working on a function to compute perfect numbers, and I got it to work...but it's hella inefficient I think
12:18:58 <benchmark> any suggestions on data structures representing the search space for Frogger? http://en.wikipedia.org/wiki/Frogger
12:19:03 <joshft91> Here's what I have so far: perfectNumbers = [x| x <- [1..], x == sum [i | i <- [1..x-1], x `mod` i == 0]]
12:19:18 <joshft91> is there a better way to compute perfect numbers?
12:19:48 <parcs`> :t succ :: a -> Enum a => a
12:19:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = (Enum a) => a
12:19:49 <lambdabot>     In the expression: succ :: a -> (Enum a) => a
12:19:53 <ozgura> parcs`: and it works in 7.4 ?
12:19:59 <parcs`> ozgura: 7.2
12:20:01 <parcs`> 7.4 too
12:20:05 <ozgura> 7.2 even
12:20:07 <ozgura> good to know.
12:21:46 <parcs`> it's sort of like how 'forall a b. a -> b -> a' ~ `forall a. a -> forall b. b -> a'
12:25:21 <mjga> parcs`: it does not _look_ correct though, I would assume that context binds a variable so (Num a)= > a -> (Num a) => a, would be interpreted by some people as (Num a)=> a -> (Num b) => b
12:25:43 <parcs`> the context doesn't bind a variable, forall doe
12:25:45 <parcs`> s
12:26:26 <parcs`> but actually the comparison to forall is wrong
12:27:32 <nand`> so I have the choice between python, perl, tcl, lua and ruby to write a haskell plugin wrapper, which should I choose and why?
12:27:42 <teel> python!
12:27:43 <mjga> parcs`: yes, that's it :->. (Num a) is just a predicate, it was just an ancient syntax where it was "set aside" before the other parts of type. Only after foralls were introduced, it started to appear in the middle of a type
12:28:03 <nand`> (based on how well haskell integrates with the language)
12:44:10 * hackagebot epub-tools 1.1.2 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-1.1.2 (DinoMorelli)
12:57:42 <slack1256> throw :: Exception e => e -> a
12:57:55 <slack1256> catch ::
12:57:56 <slack1256> => IO a	
12:57:58 <slack1256> The computation to run
12:57:59 <slack1256> -> (e -> IO a)	
12:58:01 <slack1256> Handler to invoke if an exception is raised
12:58:02 <slack1256> -> IO a
12:58:06 <monochrom> Haskell integrates best with C. C is not on your list.
12:58:24 <slack1256> throw can be used in pure code, but catch can only "catch" IO a
12:58:34 <monochrom> to some extent, everyone on your list are equal
12:58:36 <parcs`> slack1256: throwIO in Control.Exception
12:58:44 <slack1256> how do i catch pure code exceptions on IO monad
12:58:51 <slack1256> can i do that from pure code?
12:58:52 <monochrom> at this point, I would say, toss a coin
12:59:03 <ion> Also, avid throwing exceptions from pure code.
12:59:06 <ion> avoid
12:59:23 <slack1256> ion: yeah but this is a proof of concept.
12:59:33 <parcs`> you can't catch 'pure' exceptions from pure code
13:00:10 <tommd> But if you find yourself wishing you could then use the ErrorT monad.
13:00:24 <russellw> nand`, while I haven't tried it myself, Lua is designed to be by far the easiest to embed in your own code, so that's what I would go for
13:00:31 <monochrom> beware of the XY Problem
13:00:39 <slack1256> mmm. because i have something that typecheck but doesn't work
13:01:17 <russellw> both Lua and Haskell are designed to interoperate with C, which is the lingua franca, so I would imagine it ought to work if you are prepared if necessary to write a bit of glue code in C
13:02:11 <slack1256> so how should i use the "throw" function in Control.Exception
13:04:39 <parcs`> you shouldn't
13:05:15 <slack1256> ohh. okay then
13:05:28 <slack1256> thanks #haskell kep bright as always
13:05:30 <slack1256> :Q
13:05:32 <slack1256> damn
13:09:27 <Zamarok> How come I can't (concat . zipWith)?
13:09:46 <merijn> :t concat . zipWith
13:09:47 <lambdabot>     Couldn't match expected type `[[a]]'
13:09:47 <lambdabot>            against inferred type `[a1] -> [b] -> [c]'
13:09:47 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
13:09:51 <merijn> :t concat
13:09:52 <lambdabot> forall a. [[a]] -> [a]
13:09:57 <irene-knapp> :t concat . zipWith (==)
13:09:58 <lambdabot>     Couldn't match expected type `[[a]]'
13:09:58 <lambdabot>            against inferred type `[a1] -> [Bool]'
13:09:58 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
13:10:03 <irene-knapp> :t zipWith
13:10:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:10:10 <CodeWeaver> Heh.
13:10:24 <CodeWeaver> zipWith needs a 'what to zip with' clause in addition to its list input.
13:10:26 <merijn> Zamarok: It depends on what you're callng zipWith with
13:10:26 <ion> > (concat .: zipWith (++)) ["foo","baz"] ["baz","quux"]
13:10:28 <lambdabot>   "foobazbazquux"
13:10:41 <irene-knapp> > let { as = [1, 2, 3] ; bs = [4, 5, 6] } in concat . zipWith (+) as bs
13:10:42 <lambdabot>   No instance for (GHC.Num.Num [[a]])
13:10:42 <lambdabot>    arising from a use of `e_1123456' at...
13:10:58 <irene-knapp> > let { as = [1, 2, 3] ; bs = [4, 5, 6] } in concat $ zipWith (+) as bs
13:10:59 <lambdabot>   No instance for (GHC.Num.Num [a])
13:10:59 <lambdabot>    arising from a use of `e_1123456' at <...
13:11:00 <Drakeson> Is there an s-expression version of haskell? (I want real haskell, just with a different syntax)
13:11:02 <Zamarok> Oh.. well I can just include xs ys arguments and pass them explicitely
13:11:04 <irene-knapp> > let { as = [1, 2, 3] ; bs = [4, 5, 6] } in concat $ zipWith (+) as bs :: [Int]
13:11:05 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
13:11:05 <lambdabot>    arising from a use of `GHC...
13:11:09 <merijn> irene-knapp: That won't work, (=) doesn't produce a list
13:11:11 <Saizan> Zamarok: zipWith requires 3 arguments, (.) will only give it 1
13:11:16 <merijn> err, (+)
13:11:17 <irene-knapp> er, indeed
13:11:43 <Zamarok> Saizan: is there a multi-argument way to do that?
13:11:55 <Saizan> Zamarok: no
13:12:01 <CodeWeaver> let { as = [1, 2, 3] ; bs = [4, 5, 6] } in (concat.(zipWith (+))) as bs
13:12:10 <CodeWeaver> >let { as = [1, 2, 3] ; bs = [4, 5, 6] } in (concat.(zipWith (+))) as bs
13:12:14 <CodeWeaver> Sigh.
13:12:15 <merijn> \x y z -> concat  .  zipWith x y z
13:12:18 <CodeWeaver> bots don't like me
13:12:19 <merijn> @pl \x y z -> concat  .  zipWith x y z
13:12:20 <lambdabot> (((join .) .) .) . zipWith
13:12:22 <Saizan> Zamarok: you could define your own operators for specific arities, but one usually uses a lambda
13:12:26 <merijn> CodeWeaver: Space after >
13:12:31 <CodeWeaver> > let { as = [1, 2, 3] ; bs = [4, 5, 6] } in (concat.(zipWith (+))) as bs
13:12:32 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
13:12:36 <CodeWeaver> Glargh
13:12:36 <CodeWeaver> :D
13:12:49 <Zamarok> Ok, thanks
13:12:51 <merijn> CodeWeaver: concat wants [[a]], (+) produces [a]
13:12:51 <ion> > (concat .:: zipWith) (++) ["foo","bar"] ["baz","quux"]
13:12:52 <lambdabot>   Not in scope: `.::'
13:12:53 <irene-knapp> @hoogle foldm
13:12:53 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:12:53 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
13:12:53 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:12:59 <ion> > let (.::) = (.).(.).(.) in (concat .:: zipWith) (++) ["foo","bar"] ["baz","quux"]
13:13:00 <lambdabot>   "foobazbarquux"
13:13:07 <CodeWeaver> > let { as = [1, 2, 3] ; bs = [4, 5, 6] } in (concat.(zipWith (++))) as bs
13:13:08 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
13:13:21 <CodeWeaver> Yeah of course.
13:13:25 <CodeWeaver> Duh.
13:13:35 <hatomic> How do I get the latest wxhaskell's wxcore-0.13.2 to compile with cabal? Having trouble with wx-config to compile wxhaskell 0.13.
13:13:46 <Zamarok> ion: alright, you win haha
13:13:51 <CodeWeaver> hatomic, I've been fighting with that myself.
13:14:16 <CodeWeaver> Mind you I'm on osx right now.
13:14:32 <hatomic> CodeWeaver: I think there's a fork of wx-config but I don't know where to get it
13:14:51 <hatomic> To compile the latest wxhaskell, that is.4
13:15:07 <CodeWeaver> Maybe.  I'm waiting for wxhaskell to catch up with wxWidgets 2.9.3. I got wxWidgets to work.
13:15:12 <int80_h> I just recieved my username/password for hackage. How do I use cabal to upload to hackage?
13:15:14 <CodeWeaver> I know they're trying bloody hard.
13:15:52 <CodeWeaver> Wish I could help.  I honestly don't know.  I've been trying for 4 or 5 days.  wx-config wasn't my problem.
13:16:01 <int80_h> n/m
13:17:41 <int80_h> doesn't the bot announce new packages anymore?
13:17:52 <monochrom> it does
13:18:00 <int80_h> hmm
13:18:09 <int80_h> I better chck to see if it was actually uploded
13:18:44 <int80_h> hmm, it was uploaded
13:19:10 * hackagebot authenticate-ldap 0.0.1 - LDAP authentication for Haskell web applications.  http://hackage.haskell.org/package/authenticate-ldap-0.0.1 (MichaelLitchard)
13:19:16 <int80_h> ahh, lag
13:19:29 <monochrom> rather, periodic batch
13:19:42 <int80_h> I see
13:20:48 <Sgeo> Source can be a monad?
13:20:49 <Sgeo> o.O
13:20:56 <Sgeo> "You can write specific instances for Source, such as Functor, Monoid, and Monad. (Note: we haven't written the last instance since there are in fact two different valid Monad instances, and it's not clear which is the best one to choose.)"
13:34:10 * hackagebot yesod-auth-ldap 0.0.1 - LDAP Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-ldap-0.0.1 (MichaelLitchard)
13:35:15 <aristid> Sgeo: i think that statement is not true. there is only one valid monad instance, i think. and it would be list-like.
13:36:42 <hpc> aristid: i thought Logic was the alt instance for []
13:37:47 <aristid> hpc: and Source is pretty close to Logic, is it not? :)
13:37:57 <CodeWeaver> Okay, I might as well ask this.  I can *use* monads, and I understand what the laws *are*, but (within the context of haskell programming) what are some useful or interesting consequences of them?
13:38:19 <aristid> hpc: but actually i'm not 100% sure whether the list-like instance for Source would be in accordance with the monad laws.
13:38:42 <aristid> hpc: but i am sure that the ZipList-like instance would be invalid :)
13:38:55 <hpc> ZipList is definitely not a monad
13:39:05 <aristid> yeah
13:39:47 <ciaranm> iirc there's at most one way to get a monad for any given functor
13:39:57 <aristid> ciaranm: really?
13:40:10 <rwbarton> actually ZipList does seem to be a monad
13:40:20 <aristid> rwbarton: huh?
13:40:28 <aristid> rwbarton: what would be join?
13:40:40 <ciaranm> aristid: if F and G are adjoint, that's unique, at least
13:40:51 <rwbarton> it was discussed here a few weeks ago, there is a trick to getting join = take the diagonal to work
13:40:55 <aristid> ciaranm: i wish i knew what these words mean :)
13:41:13 <rwbarton> ciaranm, certainly not, you could have Writer w for two different monoid structures on w
13:41:39 <aristid> rwbarton: i think those would be considered different functors, too?
13:41:44 <rwbarton> no
13:42:17 <rwbarton> another example is the backwards state monad
13:43:33 <aristid> the what?:)
13:44:08 <rwbarton> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
13:45:30 <hpc> aristid: values go forward, state goes backwards
13:46:03 <hpc> getting the state is pretty much just structural recursion
13:46:08 <rwbarton> in more detail, the "different monoid structures" would be something like making ((,) Int) a monad with join (x, (y, a)) = (x + y, a) v.s. (x * y, a)
13:47:34 <ciaranm> oh, right
13:48:43 <aristid> hpc: omg
13:49:34 <Sgeo> Can I think of the State monad that just sequences everything in the reverse order of expectation, thus read from bottom to top, or is there something more going on that, say, makes it more useful than a parlor trick?
13:51:21 <rwbarton> there's definitely more going on than that
13:52:28 <rwbarton> you can't in general just "reverse" a monad
13:53:25 <jedai> Sgeo: hpc> aristid: values go forward, state goes backwards
13:54:01 <Sgeo> Maybe I should try to understand bind
13:54:17 <jedai> Sgeo: That would be a good first step ;)
13:54:41 <ciaranm> Sgeo: pretend you've got fmap, return and join, and implement bind
13:55:17 <Sgeo> ciaranm, I was talking about a specific monad, not bind in general.
13:56:09 <ciaranm> oh. in that case forget bind and understand join!
13:56:22 <ciaranm> join's usually far more obvious
13:57:21 <Sgeo> The code on this page shows the definition of bind, not join.
13:57:57 <Sgeo> Oh, you thought I was implementing my own monad?
13:58:09 <Sgeo> I'm not, I'm reading the Reverse State thing
14:05:24 <Sgeo> :t runState
14:05:25 <lambdabot> forall s a. State s a -> s -> (a, s)
14:09:19 <ion> I think join for RState would be: join st = rstate $ \s -> let (a, s'') = runRState st s'; (b, s') = runRState a s in (b, s'')
14:21:11 <ion> State (the normal one) can be implemented in a nice form: fmap f st = State (first f . runState st); pure a = State (a,); join st = State (uncurry runState . runState st)
14:21:41 <mm_freak> ion: what's RState?
14:22:05 <ion> It was discussed above: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
14:24:42 <mm_freak> uh…  that hurts
14:25:51 <mm_freak> is there anything that RState excels at?
14:28:14 <ion> From a discussion from a ~week ago: < ion> I actually found a use for RState once. http://hpaste.org/49828  < ion> Convert a number between 0 and (length ['A'..'Z'] ^ 3 * length ['0'..'9'] ^ 4 - 1) into a string like WZA-4381. With State, 1 results in BAA-0000. With RState, 1 results in AAA-0001.
14:29:37 <mm_freak> i see
14:30:08 <Jafet> “Gosh, what is it with you people and your “real world”? Isn’t imperative-looking code that has hauntingly freaky semantics when you interpret it imperatively enough? Why does everything have to have a use?”
14:30:57 <mm_freak> Jafet: because i like to use weird concepts in real code =)
14:33:31 <ion> @type \fs as -> state (uncurry (\f -> first f . runState as)) . runState fs)
14:33:32 <lambdabot> parse error on input `)'
14:33:40 <ion> @type \fs as -> state (uncurry (\f -> first f . runState as) . runState fs)
14:33:40 <lambdabot> forall b c d. State d (b -> c) -> State d b -> State d c
14:33:43 <kallisti> would there be any reason to use multiple acid state structures to break up a large structure into smaller acid state structures? or does acid-state already handle large data structures?
14:35:15 <mm_freak> kallisti: that depends on your schema…  i'd expect most people to use either nested data structures or a relational schema with IxSet
14:35:50 <donri> they say you should newtype your monad transformers. is there a point to newtypes like: newtype Environmental m a = Environmental (ReaderT Environment m a)  -- or is the whole point with newtyping to fixate the reader (in this case) to one "m" and "a"?
14:35:56 <DanBurton> say, is there some way to host a .lhs file on github, and have it displayed nicely? (meaning, syntax highlight appropriately)
14:36:07 <mm_freak> usually there is little reason to split things up, but one possible reason is when you use acid-state's remoting feature and you don't want to expose everything
14:36:23 <donri> DanBurton: .lhs already does syntax highlight code
14:36:41 <kallisti> mm_freak: ah okay. in my case I won't need that.
14:36:43 <DanBurton> donri: but does it syntax highlight *Literate* Haskell code appropriately?
14:36:50 <donri> yes
14:36:56 <DanBurton> hm TIL
14:36:58 <DanBurton> cool
14:37:03 <mm_freak> donri: it gives you some additional type safety…  you have to decide whether the extra work is worth it
14:37:06 <kallisti> mm_freak: I just didn't want the entire structure to be locked up during a transaction, but I guess acid-state is a bit more sophistcated than that.
14:37:09 <donri> but the rest is treated as plain text
14:37:35 <DanBurton> it doesn't handle any sort of markdown in the prose of Literate Haskell?
14:37:43 <donri> nope
14:37:44 <mm_freak> donri: for example you might not want to expose the internal structure of the environment value, but with an unwrapped ReaderT you expose it
14:38:07 <mm_freak> kallisti: i'm not sure…  you'll have to try that out
14:38:34 <Sgeo> mm_freak, what if I don't mind exposing the environment value?
14:38:41 <kallisti> mm_freak: it mentions that updates and queries can be executed in parallel so I would assume that it doesn't lock the entire structure.
14:38:44 <Sgeo> Which is already an abstract type, so
14:39:06 <mm_freak> kallisti: i'm surprised as to how that is even possible
14:39:37 <mm_freak> Sgeo: personally i just expose most things, unless there are some safety-related reasons not to do that
14:39:38 <donri> kallisti: queries can't mutate the state so they don't [b]lock anything
14:39:47 <kallisti> donri: of course.
14:40:02 <kallisti> however they do need a consistent state.
14:40:13 <mm_freak> Sgeo: that's because i'm often annoyed by libraries with an überabstracted interface
14:40:18 <niteria> I can't do something like foldr (.) fmap [fmap | _ <- [1..10]], can I?
14:40:30 <kallisti> it doesn't mention that queries and updates can be performed in parallel, it specifically mentions that many queries or many updates can be done in parallel.
14:40:41 <niteria> but I can do fmap fmap fmap fmap ...
14:40:46 <rwbarton> those are different
14:40:53 <mm_freak> niteria: that looks like a type error to me
14:40:57 <niteria> it is
14:40:58 <rwbarton> but no, you can't do that because you'd need each fmap in the list to be at a different type
14:41:31 <mm_freak> :t foldr (.) id (replicate 10 sin)
14:41:32 <lambdabot> forall b. (Floating b) => b -> b
14:41:35 <niteria> so I can't generalize (fmap)^n in any way?
14:41:40 <mm_freak> > foldr (.) id (replicate 10 sin) 0.25
14:41:42 <lambdabot>   0.22720316073613017
14:41:58 <niteria> not that I need it, I'm just curious
14:42:08 <mm_freak> what would it do?  would it map over nested functors?
14:42:12 <rwbarton> well the n-fold composition of fmap with itself has different types for different ns, so you would need to try to do it with type class hackery
14:42:29 <niteria> so it's doable?
14:42:47 <mm_freak> you want an easy way to write fmap (fmap (fmap (fmap f)))?
14:42:57 <niteria> yes
14:43:14 <ion> > (fmap . fmap) (+1) [[0..3], [4..7]]
14:43:16 <lambdabot>   [[1,2,3,4],[5,6,7,8]]
14:43:20 <mm_freak> for that you need at least what's called lightweight dependent types
14:43:44 <mm_freak> it's possible, but i'd expect that you need functors to be aware of that
14:46:28 <rwbarton> you can certainly try to do the type class hackery (class DeepFmap a b fa fb | a b fa -> fb where deepfmap :: (a -> b) -> (fa -> fb); instance DeepFmap a b a b where deepfmap = id; instance (Functor g, DeepFmap a b fa fb) => DeepFmap a b (g fa) (g fb) where deepfmap = fmap . deepfmap)
14:47:22 <rwbarton> the question in practice is whether the instance selection works well without explicit type signatures that are as long as the fmap . fmap . ... that you're replacing
14:48:17 <rwbarton> actually I'm not even sure GHC will accept those declarations
14:48:40 <niteria> so it can't infer the type for (fmap)^c
14:49:01 <niteria> assuming we can define (fmap)^c
14:49:12 <rwbarton> well...
14:49:25 <rwbarton> there is no way to express the type of "(fmap)^c" at all in Haskell-minus-type-classes
14:49:38 <niteria> Would it be possible in other language with dependent types?
14:50:13 <rwbarton> it should be, assuming you also have type classes (for fmap)
14:50:42 <rwbarton> certainly you can write the type of "(map)^c" in agda, for instance
14:50:53 <lispy> ^c?
14:51:13 <ion> fmap^2 = fmap . fmap
14:51:16 <niteria> c is set on compile time
14:51:22 <rwbarton> he means the composition of c copies of map
14:52:30 <rwbarton> well if you want to choose c at compile time you can just use TH
14:53:06 <niteria> it doesn't make sense to choose it at run time, does it?
14:53:13 <rwbarton> it can
14:53:39 <rwbarton> via polymorphic recursion
14:53:44 <lispy> :t fmap . fmap
14:53:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:53:58 <rwbarton> and the type class hackery solution should work fine with that
14:54:00 <lispy> That type gets hairy quickly
14:56:06 <niteria> I feel like I'll spend all my life learning haskell :)
14:57:10 <rostayob> niteria: well learning Haskell isn't a problem, keeping up with GHC is
14:57:10 <ion> Yes, you will indeed.
15:09:42 <lispy> if you manage to learn all the haskell then you can start in on coq, isabelle, agda, idris, etc.
15:29:35 <ddarius> The backward state monad is closely related to synthesized attributes in attribute grammars.  In fact, attribute grammars are basically monadic folds with inherited attributes in a state component and synthesized attributes in a backward state component.
15:30:01 <Sgeo> ?!
15:30:01 <lambdabot> Maybe you meant: . ? @ v
15:31:25 <nyingen> @quote
15:31:25 <lambdabot> geheimdienst says: #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
15:35:42 <CodeWeaver> That is a brilliant quote. :D
15:36:13 <nyingen> @quote
15:36:14 <lambdabot> monochrom says: That does not explain why people struggle with Haskell, a language that is a clean break from other computer languages. However, I can also offer a way out: people preconceive
15:36:14 <lambdabot> Haskell to be "just another computer language", and so they are tricked. If you sold it as "the mother tongue of Martians", perhaps they'll actually pick it up comfortably. :)
15:38:58 <CodeWeaver> There we go.  haskell is the mother tongue of martians.
15:44:57 <nyingen> @quote
15:44:57 <lambdabot> RasmusLerdorf says: "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept
15:44:57 <lambdabot> adding the next logical step on the way."
15:45:02 <zzo38> Is it OK in Haskell to have a class C and then a function of type   C () => Int -> String   and have it not callable unless you define that instance in the main program which imports that library? (Assuming relevant extensions are enabled)
15:45:25 <nyingen> If Rasmus actually said that, that's hilarious
15:45:33 <nyingen> "help! i can't stop this thing!"
15:45:37 <zzo38> I do have some ideas of such use, such as instead of .hs-boot
15:45:54 <zzo38> nyingen: Then that must be why PHP is badly designed, I suppose
15:46:55 <nyingen> zzo38: what's the use case for that function?
15:47:33 <ddarius> @google site:tunes.org inurl:haskell "nullary type classes"
15:47:34 <lambdabot> http://tunes.org/~nef//logs/haskell/11.07.04
15:47:43 <zzo38> nyingen: One might be to do something similar to .hs-boot but without .hs-boot; you can even define associated types and so on
15:47:50 <byorgey> zzo38: yes, sounds fine
15:47:54 <zzo38> ddarius: And, yes, I have wanted nullary type classes too
15:52:58 <j2jxx> ?
15:53:03 <j2jxx> ?
15:53:49 <mjga> zzo38: for me it seems not fine, since C is constraint on type of (), and this type does not appear in the type of your function. All predicates must be resolved or attached to some type expression with at least on type variable
15:58:11 <zzo38> mjga: Have you ever used the .hs-boot files, or other things like that?
15:59:27 <mjga> zzo38: nope, never used .hs-boot. I prefer to keep my life simple, and usual succeed in that. The only contrived thing I like to use is Template Haskell, but I still curse each time GHC complains that it cannot build a profiling binary because of this.
16:00:25 <byorgey> > let f :: Show Int => Char -> Char; f = id in f 'x'
16:00:26 <lambdabot>   'x'
16:01:00 <mjga> byorgey: but (Show Int) is resolved -> you can statically determine which dictionary it uses
16:01:39 <mjga> > let f :: (Show a) => Char -> Char; f = id in f 'x'
16:01:40 <lambdabot>   Ambiguous constraint `GHC.Show.Show a'
16:01:40 <lambdabot>      At least one of the forall'd ty...
16:02:39 <mjga> zzo38: as you see
16:03:02 <byorgey> @type let f :: Ord (Int -> Int) => Bool; f = (\x -> x + 1) < (\y -> y * 2)
16:03:03 <lambdabot> <no location info>:
16:03:03 <lambdabot>     not an expression: `let f :: Ord (Int -> Int) => Bool; f = (\x -> x + 1) < (\y -> y * 2)'
16:03:08 <byorgey> @type let f :: Ord (Int -> Int) => Bool; f = (\x -> x + 1) < (\y -> y * 2) in f
16:03:08 <lambdabot> Bool
16:03:15 <byorgey> mjga: see, it works fine.
16:03:26 <byorgey> you can define f.
16:03:37 <byorgey> > let f :: Ord (Int -> Int) => Bool; f = (\x -> x + 1) < (\y -> y * 2) in f
16:03:38 <lambdabot>   *Exception: (==): No overloading for function
16:03:48 <byorgey> oh.
16:03:57 <mjga> niteria: you may generate fmap^n with template Haskell, but typechecking will probably happen after code generation
16:03:57 <byorgey> lambdabot does have an Ord instance for functions =P
16:04:07 <byorgey> hmm
16:04:23 <ddarius> In GHC there is a distinction between: f :: Show Int => Char -> String and f :: Char -> String.
16:05:19 <mjga> byorgey: what is this Ord (a -> b) for?
16:05:30 <ddarius> :t let f :: Bits (Int -> Int) => Bool; f = True in f
16:05:31 <lambdabot>     No instance for (Bits (Int -> Int))
16:05:31 <lambdabot>       arising from a use of `f' at <interactive>:1:48
16:05:31 <lambdabot>     Possible fix: add an instance declaration for (Bits (Int -> Int))
16:06:05 <byorgey> mjga: the point is you can define a function that depends on a non-existant instance.
16:06:13 <byorgey> you just can't call it unless there is an instance in scope.
16:07:03 <byorgey> see http://hpaste.org/57169
16:07:16 <mjga> byorgey: maybe, I am just afraid of what danger may come out of this.
16:07:25 <byorgey> that hpaste shows that you can do what zzo38 was asking.
16:10:07 <DanBurton> "This compiles just fine.  When you try to call f you get an error." -- isn't that generally the *opposite* of what we are going for with Haskell?
16:10:16 <ddarius> DanBurton: You get a type error.
16:10:49 <zzo38> You get an error at compile time, I think.
16:10:49 <ddarius> DanBurton: You can't compile -uses- without an instance in scope (or pushing the constraint outward.)
16:11:54 <zzo38> But you could have the main program import a library with those kind of functions and define an instance in the main program (which cannot interfere with any other instances since it is not a library and is only compiled into executable file)
16:12:50 <DanBurton> zzo38++
16:14:11 * hackagebot Octree 0.2 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.2 (MichalGajda)
16:15:24 <mjga> byorgey: looks like this is something new about these FlexibleContexts. and even useful :-)
16:16:21 <zzo38> Are you sure it is new?
16:19:26 <mjga> zzo38: I didn't read about it yet - so for me it is.
16:20:07 <mjga> zzo38: not that I have now time to keep myself up to date with type classes. I have become just a user ;-)
16:20:48 <zzo38> I have not read about such a use anywhere either, but I have read about FlexibleContexts extension in general.
16:21:15 <ddarius> FlexibleContexts just removes the arbitrary restriction from Haskell 98 that contexts have to be of the form (T a b ... c)
16:21:32 <mjga> zzo38: I know that flag exists, but until I read through a nicely laid out type inference rules I cannot say how it works.
16:22:37 <mjga> ddarius: but it also gives opportunity for having "dangling" context with type variable that is absent from function declaration. but it should be somehow decided, if there are two instances of this type then what?
16:22:50 <glguy> Could someone suggest a library for playing simple sound effects in a vty-based game? The offering in the Sound section on Hackage is a bit overwhelming
16:23:09 <glguy> (for the curious http://www.galois.com/~emertens/Game.hs )
16:23:13 <zzo38> mjga: Then it is the problem; I suggested not defining such instances except in modules which are not part of a library.
16:23:17 <ddarius> mjga: There can't be two instances of a type unless you enable something like overlapping and/or incoherent instances.
16:23:37 * DanBurton has done very little with sound in Haskell, aside from playing with Euterpa
16:23:53 <zzo38> ddarius: And I don't like overlapping/incoherent instance extensions much; I made my own proposal for a InstanceDisambiguation extension.
16:24:26 <mjga> ddarius: nope, there could be C () and C Int, if you wish. and you must pick them before type variable disappears from function type - or so I thought
16:24:40 <ddarius> mjga: If you like, you can reduce FlexibleContexts to Haskell 98 contexts plus equality constraints by turning (T (S x) (V y)) into (a ~ S x, b ~ V y, T a b)
16:25:53 <zzo38> This is my proposal (there may still be things wrong with it; it is a draft copy):  http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_instance_disambiguation
16:25:58 <ddarius> mjga: What type variable?  Also, that's two instances for two types?  And the example zzo38 and byorgey are talking about there is only C ().
16:26:11 <mjga> zzo38: certainly ambiguous instances and flexible contexts are very useful, even though I have been also cut, when trying to use them in a less conventional way. I recall that you cannot define a transitive predicate this way, which was a pain in my case. I had to generate all instances one by one with Template Haskell.
16:26:54 <mjga> ddarius: but you can always define another instance. It is always left open AFAIR. what sense would have a class that has only one instance otherwise?
16:27:24 <ddarius> mjga: You can define C Int, that has no bearing at all on that example.  C could just as well have been Bits.
16:27:41 <zzo38> mjga: Yes I did try defining transitive predicates in this way too, and it didn't work.
16:28:51 <ddarius> Attempting to define transitive predicates using something like this would result in non-deterministic instance resolution.
16:29:04 <glguy> Also, does anyone know if this game has a game? http://www.galois.com/~emertens/game-ss.png It used to come in Gnome Games… you can remove a connected set of matching colors and the goal is to remove large sets at a time and clear the screen.
16:29:13 <mjga> ddarius: I do not doubt in its decidability
16:29:31 <ddarius> No one has said anything about decidability.
16:29:41 <rwbarton> "this game has a name"?
16:29:47 <nyingen> glguy: I've seen that under a number of names
16:29:51 <Sgeo> How copyrightable is a game?
16:29:59 <rwbarton> http://en.wikipedia.org/wiki/SameGame
16:30:07 * Sgeo wants to make a Logication clone
16:30:11 <glguy> rwbarton: thanks!
16:30:22 <zzo38> I think only the implementation and texts are copyrightable, although the name can be trademarked
16:30:43 <Sgeo> http://www.brainblock.com/logication.html this thing
16:31:08 <Sgeo> Some time ago the free version didn't have a time limit
16:31:12 <glguy> Sgeo: that looks like a game I have called Omnigon
16:31:21 <glguy> I think it is a similar idea but on a hexagonal board
16:32:23 <Sgeo> There's no shielding rule in Logication
16:32:24 <zzo38> Sgeo: Then please do make a clone, but give it a different title, cross-platform, open-source, and not exactly the same kind of things (for example different levels, possibly in a different order, different graphics, etc)
16:32:39 <Sgeo> At least, if I understand the shielding correctly
16:32:53 <glguy> In Omnigon you can't capture through someone's arrow
16:32:54 <Sgeo> Oh, and no rotation of pieces
16:33:05 <glguy> ahh… starting to look less similar :)
16:34:03 <Sgeo> I don't know which is a better game if either
16:34:32 <Sgeo> Also, with Logication, there are different levels, as in, starting configurations
16:34:46 <Sgeo> I have no idea how someone would design such a thing. There really isn't a default one.
16:36:13 <ddarius> mjga: You will not find a paper that describes FlexibleContexts formally as it is just removing a fairly arbitrary restriction.  If you view instance resolution as a (deterministic) logic program, the restriction would be like saying you can only have one layer of pattern matching in a rule.  This can always be overcome by making multiple rules (type classes), but those other rules would just be noise.
16:36:41 <mjga> aha, ok
16:46:12 <ddarius> Actually, my description applies to FlexibleInstances, FlexibleContexts is more like you can't call a rule with anything but a free parameter.  This can be gotten around in much the same way though.
16:56:53 <ddarius> The constraints on instances was probably added to make the decidability check trivial.
16:57:55 <ddarius> + contexts as instances can have contexts.
16:59:00 <Sgeo> I guess I'm thinking about RState too imperatively.
16:59:28 <ddarius> Sgeo: Look up attribute grammars.
17:05:19 <hinkes> Hi.  I'm trying to use a Data.Binary.Get.Get to parse a binary string.  I'm using runGet.  Is there a good way to detect errors?
17:06:04 <glguy> there are better binary parsing libraries for when you want to handle failure nicely
17:06:22 <hinkes> What would you use? cereal?
17:06:47 <glguy> That's what I'd use. Attoparsec is another possibility
17:11:04 <hinkes> Hmm, Data.Serialize.Get.runGetLazy doesn't do what I want.  It too seems to call 'fail'
17:11:56 <glguy> What did you want it to do?
17:12:10 <hinkes> Return Left errorString
17:12:29 <kallisti> http://repetae.net/recent/out/classalias.html  I don't understand this proposal. Why use this new syntax when you could simply have:  class (A a, B a, C a) => D a
17:12:41 <kallisti> it seems as though this proposal wants to be able to add new methods to a type alias? this doesn't make sense to me.
17:12:51 <glguy> hinkes: What function are you looking at?
17:12:51 <kallisti> *typeclass alias
17:13:11 <hinkes> runGetLazy
17:13:22 <glguy> runGetLazy m lstr = fst (runGetLazy' m lstr)
17:13:32 <glguy> I mean what function are you looking at that fails in a way you didn't expect
17:14:16 <Sgeo> Under what circumstances might using RState fail?
17:14:58 <glguy> hinkes: "fail" in Data.Serialize's "Get" monad ultimately returns a Left
17:15:08 <parcs`> Sgeo: runRState (get >>= put) ()
17:15:53 <parcs`> the state of the next computation cannot depend on the state of the previous computation, or something like that
17:16:49 <hinkes> ok, thanks.  I'll try to figure out what I'm doing wrong.  I have a HUnit test that parses a lazy binarystring.  I'm testing the parsing of an invalid string.
17:25:29 <parcs`> this is why modify is written directly instead of in terms of get and put :P
17:26:56 <Sgeo> Hm
17:35:16 <slack1256> realworld haskell says that mvars are non-strict
17:35:29 <slack1256> but that doesn't seem useful also the have IO () types on operations
17:35:39 <slack1256> which one is it?
17:35:46 <glguy> I think you misunderstood
17:35:56 <glguy> If you put a thunk inside an mvar it will stay unevaluated
17:36:00 <kallisti> out of curiousity, is it possible to call C function pointers with the FFI? :D
17:36:07 <kallisti> *curiosity
17:36:12 <glguy> if another thread reads that mvar and evaluates it
17:36:19 <glguy> it might do all the "work" of evaluation
17:36:28 <slack1256> right.
17:37:04 <slack1256> so if i for example will do heavy work on a thread, I must evaluate it before must it in a mvar
17:37:14 <glguy> correct
17:37:26 <slack1256> *sorry my english got mess up in the last part
17:37:29 <slack1256> thanks glguy
17:37:34 <glguy> which might involve DeepSeq or something else specific to your application
17:37:42 <slack1256> right
17:39:12 * hackagebot attoparsec-text 0.8.5.3 - (deprecated)  http://hackage.haskell.org/package/attoparsec-text-0.8.5.3 (FelipeLessa)
17:39:14 * hackagebot attoparsec-text-enumerator 0.2.0.1 - (deprecated)  http://hackage.haskell.org/package/attoparsec-text-enumerator-0.2.0.1 (FelipeLessa)
17:40:03 <nand`> http://hpaste.org/57171 how can I improve this?
17:40:26 <nand`> I'm not happy with it, code duplication here and there and the way I compare workspaces seems very slow and ugly
17:44:13 <kallisti> oh nevermind I found FunPtr. are you supposed to call the function via peek ordo you use this dynamic stub thing.
17:44:59 <Sgeo> There are two foreign import things that make the sort of thing that converts FunPtrs in either direction
17:45:00 <Sgeo> iirc
17:45:15 <kallisti> foreign import ccall "dynamic"   mkFun :: FunPtr IntFunction -> IntFunction
17:45:36 <kallisti> is this how you actually call FunPtrs or is this something else?
17:46:36 <Sgeo> I don't think there's another way to do it. peeking doesn't really make sense
17:46:49 <Sgeo> castFunPtrToPtr is unreliable
17:47:31 <Sgeo> I know that bindings-dsl has a thing to nicely make the dynamic thing for you
17:47:34 <kallisti> oh right Storable requires Ptr
17:48:13 <kallisti> is it possible to wrap a Haskell function in a FunPtr?
17:48:30 <ion> Yes. Search words: import ccall wrapper
17:49:06 <Sgeo> wrapper and dynamic make the functions that you need to go in either direction
17:50:30 <ion> I love bindings-dsl.
17:53:08 <kallisti> hmm, oh, so calling a Haskell function in C is always calling a function pointer then?
17:53:27 <kallisti> or can it be either a "regular" function or a function pointer?
17:54:55 <ddarius> Yes.  Haskell functions can be made to look like function pointers.  GHC has to do some run-time code generation to make that happen.
17:58:40 <ion> What’s the difference between a “regular” function and a function pointer? :-P
18:03:38 <kallisti> FFI is pretty impressive, I must say.
18:12:19 <fbern> I'm struggling getting that parser right. The parser I'm trying to write has the definition:     par1 :: Parser (Maybe Double). I'm failing to write the nothing part of my parser because I don't know how to construct it. Am I missing the obvious? my code so far is: par1 = do (Just <$> double <|> ?????) <* sepP. How do I formulate the ???? part?
18:13:44 <kallisti> return Nothing, I believe.
18:13:56 <kallisti> that would make the type match, anyway.
18:14:09 <slack1256> fbern: parsec or attoparsec?
18:14:17 <fbern> kallisti: it seems not to work... that was what I expected
18:14:28 <fbern> slack1256: attoparsec. sorry forgot to mention
18:14:48 <kallisti> > (+1) <$> [1..10] <|> [1..10]
18:14:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,1,2,3,4,5,6,7,8,9,10]
18:15:08 <kallisti> okay, well it's not a precedence issue, then.
18:15:36 <kallisti> fbern: so the type is incorrect but it's not doing what you want?
18:15:40 <kallisti> *correct
18:15:46 <fbern> kallisti: looks like if I return Nothing it won't capture the Parser instance.
18:15:57 <slack1256> fbern: could you provide a example string and what would you spect to receive?
18:17:07 <kallisti> "won't capture the Parser instance" I don't know what you mean by that.
18:18:00 <fbern> slack1256: parse par1 "10.2," should return Just 10.2 and if it fails to parse it to a double Nothing should be returned.
18:18:38 <glguy> fbern: I don't know what library you are using, but    fmap Just double <|> return Nothing     would be my guess
18:18:48 <glguy> I don't know how <$> and <|> interact off the top of my head
18:18:57 <fbern> glguy: attoparsec
18:19:04 <kallisti> that would type correctly, and do what he described.
18:19:08 <kallisti> as far as I know.
18:19:52 <nand`> :t (<|>)
18:19:53 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
18:19:59 <slack1256> fbern: are you sure about the Nothing part?, attoparsec has data Result = Done | Fail | Partial
18:20:04 <fbern> kallisti: if I just return Nothing the type becomes Maybe Price but it should be Parser (Maybe Price)
18:20:09 <slack1256> Fail fit there quite nicely
18:20:16 <slack1256> anyways if you really want to do that
18:21:00 <fbern> slack1256: well that's the thing. it should not fail as the value is allowed to be missing.
18:21:06 <alpounet> wow, building snap is scary
18:21:25 <glguy> fbern: did you forget "return"?
18:21:34 <kallisti> fbern: no return Nothing is Parser (Maybe Double)
18:21:48 <kallisti> the type you're describing would be expressed by simply saying "Nothing"
18:21:50 <slack1256> parse ((Just <*> double) <* char ',') "10.2,"
18:22:02 <slack1256> shit i forgot about the maybe part
18:22:05 <slack1256> wait a sec
18:23:07 <kallisti> (Just <$> double <|> return Nothing) <* sepP
18:23:09 <kallisti> should be correct
18:23:17 <kallisti> you might also want to wrap Just <$> double within a try
18:23:21 <kallisti> depending on what you're parsing
18:23:21 <fbern> kallisti: ghci tells me: Couldn't match expected type ..... In the second argument of `(<|>)', namely `(Nothing :: Maybe Double)'
18:23:51 <slack1256> fbern: maybeResult $ parse ((Just <*> double) <* char ',') "10.2,"
18:23:56 <slack1256> that is how you do it
18:23:59 <kallisti> fbern: is it literally "return Nothing" or just "Nothing"
18:24:12 <fbern> ghci tells me Couldn't match expected type ...  In the second argument of '(<|>)', namely '(Nothing :: Maybe Price)'
18:24:17 <glguy> Just <$> double <|> return Nothing  is this parsing as (Just <$> double) <|> return Nothing
18:24:23 <glguy> or Just <$> (double <|> return Nothing)
18:24:24 <kallisti> glguy: yes
18:24:26 <kallisti> first
18:24:28 <glguy> ok
18:24:29 <kallisti> I tested that.
18:24:54 <kallisti> slack1256: <$> not <*>
18:24:56 <fbern> kallistig: you might be right. I haven't yet tried ...<|> return Nothing...
18:24:56 <kallisti> Just <$> double
18:25:07 <kallisti> fbern: ..that's what I suggested. not Nothing but return Nothing
18:25:08 <slack1256> kallisti: yeah you are right!
18:25:31 <kallisti> but maybeResult looks promising as well.
18:25:51 <fbern> kallisti: thank you. i over looked that...
18:25:56 <fbern> it seems to be working now.
18:26:14 <kallisti> cool.
18:26:16 <fbern> i should probably go back to the basics...
18:26:25 <slack1256> fbern: this is
18:26:29 <slack1256> fbern:maybeResult $ parse ( double <* char ',') (pack "10.2,")
18:26:40 <slack1256> Just 10.2
18:26:48 <kallisti> yes maybeResult is likely what you want.
18:26:55 <slack1256> maybeResult $ parse ( double <* char ',') (pack "helloWorld,")
18:26:56 <Sgeo> :t maybeResult
18:26:57 <lambdabot> Not in scope: `maybeResult'
18:26:58 <kallisti> instead of explicitly writing the Maybe behavior
18:26:59 <slack1256> Nothing
18:27:11 <kallisti> so that a failure automatically becomes Nothing, and anything else is Just whatever
18:27:14 <fbern> slack1256: the Just was always right. I struggled with the Nothing part. But 'return Nothing' instead of just 'Nothing' solved the problem.
18:27:19 * BMeph prefers "pure Nothing" to "return Nothing" after a '<|>'...
18:27:29 <kallisti> there's also an eitherResult if you want to have error messages.
18:28:02 <kallisti> fbern: if you find yourself writing a lot of this Maybe plumbing then you probably actually want maybeResult because it does it for you.
18:28:07 * slack1256 thinks eitherResult result more practical in the RealWorld(tm)
18:28:12 <kallisti> fbern: what he's suggesting is also correct and requires less code overall.
18:29:09 <fbern> it's there is tons of other fields to parse and it is completely valid for the double field to be missing in the message... the final type should look something like data Final = Final F1 F2 F3 (Maybe Double) F5 F6 ...
18:29:43 <kallisti> ah I see.
18:30:24 <fbern> its less code to write with the maybe otherwise I would need another parsing step.
18:30:35 <kallisti> hmmm Parsec has optionMaybe
18:30:40 <kallisti> but I don't know if attoparsec has this.
18:30:42 <fbern> to all: thank you very much for your help!
18:30:57 <slack1256> happy hacking
18:31:07 <fbern> BMeph: "pure Nothing" ... that's the obvious of course.
18:31:40 <fbern> (Maybe Coffee)
18:47:55 <abhi_> hi
18:47:59 <kallisti> hello
18:48:04 <mm_freak> given two nonrecursive types that differ only in the strictness of their constructors, are they isomorphic?
18:48:22 <mm_freak> like:  "data Maybe a = Just a | Nothing" vs. "data MaybeS = JustS !a | NothingS"
18:49:13 * hackagebot pandoc-types 1.9 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.9 (JohnMacFarlane)
18:50:18 <slack1256> am i the only one that when compiling from cabal sudenly i have 50% of mem used by ghc?
18:50:52 <mm_freak> slack1256: if it happens regardless of whether you use cabal-install, you're not alone =)
18:51:18 <slack1256> xD
18:51:35 <slack1256> http://labs.scrive.com/2011/08/running-ghc-on-low-memory-computers/ blames the guilt on "gnu ld"
18:51:37 <slack1256> but even so
18:52:01 <ddarius> mm_freak: No.  Why would they be isomorphic?
18:52:19 <mm_freak> ddarius: because i'm not sure whether bottom counts
18:52:40 <mm_freak> i can't see a fully defined value i can construct with Maybe, but not with MaybeS
18:53:19 <ddarius> Why wouldn't bottom count?
18:53:39 <mm_freak> ddarius: because there are a few things, where bottom doesn't count
18:53:40 <ddarius> slack1256: GHC, particularly with split-objs, stresses the linker.
18:53:54 <ddarius> mm_freak: Such as?
18:54:03 <mm_freak> ddarius: the C-H isomorphism
18:54:16 <ddarius> mm_freak: Uh, bottom still matters there.
18:54:22 <companion_cube> slack1256: actually yes, the linker takes a lot of memory
18:54:23 <mm_freak> really?  how?
18:54:27 <ddarius> mm_freak: Why wouldn't it?
18:55:11 <slack1256> any setting or blog post on how to reduce its uasge?
18:55:13 <slack1256> *usage
18:55:31 <mm_freak> ddarius: i can see how you could define a proof of a proposition as a fully defined value of the corresponding type, but you can define proofs without bottom
18:57:21 <mm_freak> am i missing something?
18:57:31 <ddarius> mm_freak: If you are going to use something like the Curry-Howard correspondence, you don't get to pick and choose which things you want to talk about.  You can, but then you are simply applying the correspondence to something different.
18:57:47 <ddarius> At any rate, if "bottom doesn't count" then it doesn't even make sense to talk about strictness.
18:58:16 <mm_freak> true, so isomorphism always counts bottoms?
18:59:13 * hackagebot Dangerous 0.3.2 - Monads for operations that can exit early and produce warnings  http://hackage.haskell.org/package/Dangerous-0.3.2 (NateSoares)
19:02:29 <ddarius> mm_freak: Isomorphism is relative to whatever the notion of morphism is.  If you have bottoms, presumably your notion of morphism will need to account for them some way.
19:03:16 <mm_freak> makes sense…  and i'm asking for the common notion
19:03:28 <mm_freak> so i don't confuse people when i claim that two types are isomorphic
19:04:05 <mm_freak> so in other words, "newtype Identity a = Identity a" is a real identity monad, but the same with 'data' instead of 'newtype' is not?
19:04:12 <ddarius> mm_freak: If you want to talk about Haskell types, typically you want Haskell functions to be the morphisms though done naively that doesn't quite make a category.
19:04:45 <ddarius> All you need to do is make to Haskell functions f and g and prove that f . g = id and g . f = id.
19:05:12 <mm_freak> i see
19:06:18 <ddarius> You won't be able to do that for functions between Maybe and MaybeS as Just undefined will be mapped to undefined and you won't be able to get Just undefined back from undefined without breaking something else.
19:06:34 <mm_freak> yeah, makes sense
19:08:07 <mm_freak> now, given an "up to isomorphism" notion of the identity monad, you would need to write two functions f :: Identity a -> a and g :: a -> Identity a and prove that f . g = id and g . f = id, right?
19:09:07 <ddarius> mm_freak: Yes.  The equality in f . g = id and g . f = id would typically be observational equality.
19:09:24 <Sgeo> Suppose I store a huge list of newtype constructors.
19:09:27 <mm_freak> ok, thanks a lot
19:09:41 <Sgeo> I suppose each constructor takes up some memory, but are they just physically id, or what?
19:10:18 <parcs`> newtypes don't exist at runtime
19:10:28 <mm_freak> Sgeo: the low level representations are the same as without the wrapping newtype
19:10:53 <mm_freak> but you might still get different code, where you would expect the same, because some RULEs won't fire
19:11:23 <ceasarbautista> How does one convert a boolean to an int?
19:11:37 <ceasarbautista> Google is not being helpful.
19:11:38 <tkahn6> if b then 1 else 0
19:11:47 <copumpkin> fromEnum
19:11:48 <ddarius> if b then 234636 else 1957393
19:11:54 <ceasarbautista> ah
19:11:58 <ceasarbautista> Thank you!
19:12:02 <tkahn6> > :t fromEnum
19:12:03 <lambdabot>   <no location info>: parse error on input `:'
19:12:05 <tkahn6> :(
19:12:12 <Sgeo> mm_freak, so, when I hold onto, say, Identity :: a -> Identity a, and have a list of, say, [Identity, Identity, Identity, Identity] :: [a -> Identity a], surely those Identity exist at runtime? The list exists, at least.
19:12:58 <mm_freak> Sgeo: likely yes…  technically you'll have a list of identity functions
19:13:15 <mm_freak> tkahn6: without ">"
19:13:18 <mm_freak> :t fromEnum
19:13:19 <lambdabot> forall a. (Enum a) => a -> Int
19:13:24 <tkahn6> thanks
20:32:12 <tkahn6> is there a way to get aggressive runtime GC?
20:32:52 <tkahn6> using the -c RTS flag seems to help, but maybe there are more things i could be doing
20:33:11 <shachaf> Presumably you can fiddle with all the other RTS flags.
20:33:16 <shachaf> (That mention GC.)
20:33:37 <tkahn6> shachaf: i've been doing that :)
20:39:16 <Enigmagic> tkahn6: what are you trying to do?
20:40:01 <tkahn6> Enigmagic: basically i have a worker process which recieves a command and does some work and sends it on
20:40:11 <tkahn6> it doesn't need to retain any data
20:40:58 <glguy> When the worker is completely blocked waiting for the next event it should GC to see if that frees anything up to run
20:41:26 <tkahn6> right that would be ideal
20:41:28 <Enigmagic> tkahn6: are you having GC problems?
20:42:18 <tkahn6> Enigmagic: yes the memory usage seems a little high, and it grows with each workload even though the task is the exact same each time
20:42:36 <tkahn6> or at least i think i'm having GC problems
20:42:51 <Enigmagic> have you tried running with +RTS -sstderr ?
20:43:06 <tkahn6> no let me try that
20:43:59 <Enigmagic> if the GC stats from that don't look too bad then you may consider doing some profiling runs before blindly hammering away at the GC settings
20:44:00 <stanrifkin> there is not much going on at comp.lang.haskell - is there another one? or is news not that much in use of haskell
20:45:38 <Enigmagic> stanrifkin: i think most of the traffic is either on haskell-cafe (email list), irc (on here), stackoverflow and reddit
20:46:14 <Jafet> Haskell is too hip for news
20:46:59 <stanrifkin> Enigmagic: haskell-cafe is new to me - I will subscribe it
20:47:58 <glguy> You'll probably want to filter it into its own folder :)
20:48:49 <tkahn6> Enigmagic: http://hpaste.org/57174
20:49:56 <tkahn6> what's the diagnosis doctor
20:51:12 <Enigmagic> tkahn6: try bumping the arena size a bit, +RTS -A2m
20:51:29 <Enigmagic> looks like a lot of crap is getting copied during each gen0 collection
20:51:38 <tkahn6> thanks
20:52:16 <Enigmagic> if that doesn't help then i'd do some profiling runs. stats like that can indicate too much laziness
20:53:37 <tkahn6>  Generation 0:   266 collections,     0 parallel,  0.18s,  0.18s elapsed
20:53:37 <tkahn6>   Generation 1:    17 collections,     0 parallel,  0.14s,  0.15s elapsed
20:54:57 <tkahn6> hmm memory usage seems to be increasing tho
20:56:04 <Enigmagic> alright, so first step would be to run the same app with +RTS -hT
20:56:41 <tkahn6> k
20:56:54 <Enigmagic> that will generate a file called <programname>.hp which can be rendered with hp2ps (probably already installed) or hp2pretty (on hackage)
20:57:16 <tkahn6> do i have to have my libraries compiled with debug symbols and stuff?
20:57:21 <Enigmagic> nope
20:57:23 <tkahn6> nice
20:57:46 <Enigmagic> though if you need more information you'll need to recompile everything with profiling enabled
20:58:09 <Enigmagic> -hT is useful enough though, sometimes that's all you need
21:01:33 <tkahn6> Enigmagic: all I got was an empty graph
21:01:40 <tkahn6> (with hp2pretty)
21:01:48 <Enigmagic> is the .hp file empty?
21:01:51 <tkahn6> JOB "Worker"
21:01:51 <tkahn6> DATE "Mon Jan 30 00:51 2012"
21:01:51 <tkahn6> SAMPLE_UNIT "seconds"
21:01:51 <tkahn6> VALUE_UNIT "bytes"
21:01:51 <tkahn6> BEGIN_SAMPLE 0.00
21:01:52 <tkahn6> END_SAMPLE 0.00
21:01:52 <tkahn6> BEGIN_SAMPLE 0.27
21:01:53 <tkahn6> END_SAMPLE 0.27
21:01:59 <tkahn6> :/
21:02:42 <Enigmagic> doesn't look like there is much in the sample :-/
21:02:47 <kejoki> looks like factually empty no, actually empty yes.
21:03:03 <tkahn6> yeah lol
21:04:11 <Enigmagic> you might try running some more requests against the service to see if it picks up anything, otherwise try rebuilding with profiling
21:04:19 <tkahn6> k
21:04:30 <tkahn6> probably gonna head to sleep, thanks for your help Enigmagic
21:04:42 <Enigmagic> np, hope you can get it figured out soon
21:05:08 <tkahn6> thanks
21:19:49 <yitz> preflex: seen thoughtpolice
21:19:50 <preflex>  thoughtpolice was last seen on #haskell-blah 44 days, 35 minutes and 35 seconds ago, saying: copumpkin: you can flaunt bitcoins, can't you?
21:20:30 <kejoki> Seems to answer that question.
21:46:00 <kallisti> how do I use hsc2hs to generate the alignment method for a Storable instance?
21:46:22 <kallisti> I don't see anything like #{alignment structname}
21:48:29 <elliott> kallisti: you can define your own macros
21:48:49 <elliott> and use alignof
21:55:46 <kallisti> elliott: is there a better source of documentation than http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/hsc2hs.html
21:56:06 <elliott> that covers everything
21:56:15 <elliott> #let name parameters = "definition"
21:56:15 <elliott> Defines a macro to be applied to the Haskell source. Parameter names are comma-separated, not inside parens. Such macro is invoked as other #-constructs, starting with #name. The definition will be put in the C program inside parens as arguments of printf. To refer to a parameter, close the quote, put a parameter name and open the quote again, to let C string literals concatenate. Or use printf's format directives. Values of arguments must be give
21:56:15 <elliott> n as strings, unless the macro stringifies them itself using the C preprocessor's #parameter syntax.
21:56:21 <elliott> that's what you need to define an alignment macro
21:58:31 <kallisti> elliott: oh I was confused about the C program bit, but it's referring to the C program that generates the Haskell.
21:59:24 <elliott> hsc2hs just turns your program into a big c program
21:59:28 <elliott> then compiles and runs that, producing an .hs
21:59:30 <elliott> which is then compiled
21:59:41 <kallisti> it can also produce a C file yes?
21:59:49 <elliott> sure, that's the big C program
22:00:41 <kallisti> elliott: did you mean offsetof instead of alignof?
22:01:40 <elliott> i don't think so. you asked for alignment
22:01:44 <elliott> try __alignof__ if it doesn't work
22:02:08 <elliott> you can implement it yourself if that still doesn't work
22:02:32 <kallisti> ah I found something here http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
22:02:54 <elliott> yes, that is the typical implementation of alignof
22:05:06 <kallisti> I wonder if #let can include other macros.. I don't see how that would possibly work though.
22:18:40 <rsmith> "class Sized x where size :: x -> Integer" : Is this a reasonable way to associate a constant integer to data so that the size function is computed only once?
22:18:51 <elliott> no
22:19:03 <elliott> it's a function, so the result is not going to be memoised in that manner
22:19:25 <elliott> you'll need explicit memoisation if you want it
22:19:41 <elliott> in fact, even "data Tagged s a = Tagged a; class Sized x where size :: Tagged x Integer" will recompute size, I think, since size gets compiled down to a function
22:20:26 <rsmith> Wow, you're fast.  Thanks!  Now I have to go look up the definition of "memoised" :)
22:20:42 <elliott> hehe, http://www.haskell.org/haskellwiki/Memoization
22:21:06 <elliott> rsmith: as a general rule of thumb, GHC will evaluate top-level definitions with monomorphic types only once
22:21:19 <elliott> but this doesn't mean that e.g. a top-level /function/ definition will get its results automatically cached
22:21:34 <elliott> because it's the function itself that's the CAF (constant applicative form), iirc
22:21:47 <rsmith> ok, I see
22:22:36 <Jafet> How can you compute something that depends on a parameter only once
22:22:41 <rsmith> Thanks!  This is the most helpful forum EVA!
22:23:11 <rsmith> For example, if the data is a list, xs, say, and the function is sum xs
22:23:43 <elliott> Jafet: By storing the association, naturally.
22:24:25 <Jafet> Doing that for size is probably silly
22:25:05 <rsmith> I use it for the degree of a monomial-- size was just a silly example
22:25:06 <CodeWeaver> boo
22:26:26 <Jafet> That's just the degree of the highest term
22:26:40 <Jafet> size = exponent . head
22:26:47 <shachaf> monomial++
22:27:01 <Jafet> Oh wait.
22:27:19 <rsmith> No, multivariate monomials.  Not single variable polynomials
22:28:15 <Jafet> Either way, the algorithm only does work proportional to the size of the input.
22:28:46 <Jafet> It is generally inadvisable to memoize such an algorithm
22:29:30 <rsmith> My thinking: The degree of a monomial should be computed once if it is going to be computed with hundreds of times
22:30:36 <Jafet> And you propose to modify size so that this happens.
22:30:59 <rsmith> yes
22:32:00 <elliott> rsmith: the problem is that to look up the input in an association will require traversing it all anyway
22:32:05 <elliott> so you'll not save anything
22:32:16 <elliott> the closest thing to what you want would be based on pointer identity
22:32:36 <elliott> but that's very easy to break by doing "nops" in haskell so there's a good chance you'll not do anything but waste RAM with it
22:33:22 <Jafet> This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
22:34:28 <shachaf> Jafet: Well, if removing evidence is significantly more complicated than searching for evidence, that might be reasonable.
22:34:57 <elliott> @remember Jafet [on memoising a O(n) algorithm:] This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
22:34:57 <lambdabot> Good to know.
22:35:17 <elliott> oh, that should be "an"
22:35:22 <elliott> @forget Jafet [on memoising a O(n) algorithm:] This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
22:35:23 <lambdabot> Done.
22:35:25 <elliott> @remember Jafet [on memoising an O(n) algorithm:] This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
22:35:26 <lambdabot> Good to know.
22:37:15 <rsmith> :)  O.k., I was thinking something along the lines of a C++ class X { const int degree;}.  So degree must be computed when the object is created.
22:37:46 <Jafet> data Monomial = Monomial { size :: Int, ... }
22:38:03 <elliott> yes, what Jafet said
22:38:05 <Jafet> Or to imitate that dreadful language, size :: !Int
22:38:14 <elliott> make your functions that construct Monomials construct the size
22:38:18 <Jafet> This precludes size from lazy evaluation
22:38:18 <elliott> and functions that process them update it
22:38:21 <elliott> and you'll get the caching you want
22:39:03 <rsmith> ok, thanks!
22:41:28 <rsmith> I was doing it in a very round-a-bout way
22:53:33 <kallisti> how would I write a dynamic stub that extracts a FunPtr to a vararg C function?
22:54:41 <shachaf> You're probably best off making a C-side wrapper for the vararg function rather than using the FFI.
22:54:52 <shachaf> C varargs are enough of a mess when you're just using C.
22:55:02 <elliott> There's that libffi binding thing.
22:55:07 <elliott> The objective-c binding on reddit a while ago used that.
22:55:14 <elliott> It let them do varargs with a funptr.
22:55:15 <elliott> At least iirc.
23:02:47 <Sgeo> libffi?
23:15:22 <kallisti> I'm probably trying to do too much without using a C wrapper, but can I use hcs2hs to get a FunPtr from a C struct? I'm thinking I could use #offset to calculate its offset within the struct and then do some pointer casting, but isn't that unsafe?
23:15:51 <kallisti> actually if I cast from Ptr to FunPtr I might as well use #ptr
23:19:36 <Sgeo> kallisti, there's a thing that will generate the dynamic and wrapper stuff for you
23:19:38 <Sgeo> Hold on
23:20:10 <kallisti> Sgeo: erm I think I'm already familiar with that.
23:20:39 <kallisti> for FunPtr a -> a
23:20:44 <kallisti> is this something else?
23:21:13 <Sgeo> What do you mean, a FunPtr from a C struct?
23:21:48 <kallisti> let's say I have a pointer to a struct passed to my Haskell function and I want to use hsc2hs to extract a function pointer from within a struct
23:21:54 <kallisti> can I accomplish that with #peek alone?
23:22:29 * Sgeo has no idea
23:22:33 <Sgeo> </helpful>
23:22:53 <zomg> FunPtrs sound so fun
23:23:11 <otk> abstracting away from the concept of pointers sounds more fun
23:23:24 <Jafet> @hoogle Seq a -> [a]
23:23:24 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
23:23:24 <lambdabot> Prelude repeat :: a -> [a]
23:23:24 <lambdabot> Data.List repeat :: a -> [a]
23:23:33 <Jafet> What
23:23:49 <danr> toList
23:23:54 <Sgeo> Is Seq a Foldable?
23:24:13 <danr> yes
23:24:14 <danr> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
23:24:17 <Sgeo> Looks it.
23:24:19 <danr> why shouldn't it be?
23:24:31 <Sgeo> Jafet, there's your answer
23:24:43 <kallisti> I'm kind of  confused about the difference between #poke and #ptr now
23:25:08 <kallisti> something I read on Haskellwiki I believe suggested that when extracting C strings from a struct you want to use #ptr, but... why wouldn't #peek work
23:25:12 <kallisti> s/#poke/#peek/
23:26:42 <Jafet> The question is, why isn't there Sequence.toList.
23:27:17 <kallisti> oh I misread.
23:27:25 <kallisti> #ptr is for a char array in a struct.
23:27:28 <danr> Jafet: there is, but you need to import Data.Foldable
23:27:30 <kallisti> that makes more sense.
23:28:41 <Sgeo> There should be a typeclass for the operations common between lists, sets, etc.
23:28:46 <Sgeo> Accessing by ... wait
23:29:51 <kallisti> foreign export ccall f :: Ptr Msg -> Ptr a -> IO ()
23:29:54 <kallisti> is "Ptr a" valid here?
23:30:17 <kallisti> nothing in the standard seems to suggest that it's invalid.
23:31:03 <Goose124> Hey everyone.
23:31:16 <kallisti> hi
23:34:09 <Goose124> I've been on a hiatus, now I need to relearn what I knew of haskell :|
23:36:13 <Blkt> good morning everyone
23:36:35 <Goose124> Morning, however it just barely is for me.
23:37:10 <Jafet> Oh mister sun, sun, mister golden sun
23:37:53 <Goose124> I'm about 5 hours away from a golden sun. :|
23:38:17 <zomg> I'm about 2 minutes away from a _good_ morning
23:38:33 <zomg> 2 minutes ago I saw the brilliance that is the code my coworkers produce -> fuck this shit
23:38:37 <zomg> =)
23:39:29 <Goose124> Heh, I'm not looking forward to school today.
23:40:27 <zomg> At least you can sit around doing nothing in school
23:40:28 <zomg> =)
23:41:44 <Jafet> A PhD allows you to sit around indefinitely..
23:41:47 <Goose124> True, but I'm taking supplementary college courses to get ahead so it's always relaly long.
23:50:33 <earthy> jafet: not entirely true
